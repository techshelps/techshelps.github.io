<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>APPINIT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2491"></a>APPINIT.C</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED <br>//  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR <br>//  A PARTICULAR PURPOSE. <br>// <br>//  Copyright 1993 - 1998 Microsoft Corporation. All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br>// <br>//  appinit.c <br>// <br>//  Description: <br>//      This file contains initialization and termination code for the <br>//      application (as well as some rarely used stuff). <br>// <br>//  History: <br>//      11/ 8/92    created. <br>// <br>//==========================================================================; <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include &lt;commdlg.h&gt; <br>#ifndef WIN32 <br>#include &lt;shellapi.h&gt; <br>#endif <br>#include &lt;stdarg.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;memory.h&gt; <br>#include "appport.h" <br>#include "app.h" <br>#include "mciapp.h" <br> <br>#include "debug.h" <br> <br> <br> <br>//==========================================================================; <br>// <br>//  Application helper functions and rarely called stuff... <br>// <br>// <br>//==========================================================================; <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  DWORD AppGetWindowsVersion <br>// <br>//  Description: <br>//      This function returns the version of Windows that the application <br>//      is running on plus some platform information. <br>// <br>//  Arguments: <br>//      PTSTR pach: Options pointer to buffer to receive text string of <br>//      the Windows version and platform. <br>// <br>//  Return (LRESULT): <br>//      The return value will be the version and platform information of <br>//      the current operating system in the following format: <br>// <br>//      0xPPPPMMRR where: <br>// <br>//      MM      :   major version of Windows <br>//      RR      :   minor version (revision) of Windows <br>//      PPPP    :   the platform the application is running on which <br>//                  will be one of the following: <br>// <br>//                  #ifdef WIN32 <br>//                      the HIWORD() is RESERVED except for the high bit: <br>//                          high bit is 0 = Windows NT <br>//                          high bit is 1 = Win32s/Windows 3.1 <br>//                  #else <br>//                      0xMMRR = Major and Minor version of [MS-]DOS <br>//                      GetWinFlags() &amp; 0x8000 = Windows on OS/2 (WLO) <br>//                      GetWinFlags() &amp; 0x4000 = Windows on Windows NT (WOW) <br>//                  #endif <br>// <br>//  History: <br>//       2/13/93    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>LRESULT FNGLOBAL AppGetWindowsVersion <br>( <br>    PTSTR           pszEnvironment, <br>    PTSTR           pszPlatform <br>) <br>{ <br> <br>    BYTE    bVerWinMajor; <br>    BYTE    bVerWinMinor; <br>    UINT    uVerEnv; <br>    DWORD   dw; <br>    LRESULT lr; <br> <br>    dw = GetVersion(); <br> <br>    // <br>    //  massage the version information into something intelligent <br>    // <br>    // <br>    bVerWinMajor = LOBYTE(LOWORD(dw)); <br>    bVerWinMinor = HIBYTE(LOWORD(dw)); <br>    uVerEnv      = HIWORD(dw); <br>    lr = MAKELPARAM(((UINT)bVerWinMajor &lt;&lt; 8) | bVerWinMinor, uVerEnv); <br> <br>    // <br>    //  if caller wants the environment string version... <br>    // <br>    if (NULL != pszEnvironment) <br>    { <br>    // <br>    // <br>    // <br>#ifdef WIN32 <br>{ <br>    static TCHAR    szFormatVersion[]   = TEXT("%s Version %u.%.2u"); <br>    static TCHAR    szEnvWinNT[]        = TEXT("Windows NT"); <br>    static TCHAR    szEnvWin32s[]       = TEXT("Win32s"); <br> <br>    wsprintf(pszEnvironment, szFormatVersion, <br>             (LPSTR)((0x8000 &amp; uVerEnv) ? szEnvWin32s : szEnvWinNT), <br>             bVerWinMajor, bVerWinMinor); <br>} <br>#else <br>{ <br>#ifndef WF_WINNT <br>    #define WF_WINNT        0x4000 <br>    #define WF_WLO          0x8000 <br>#endif <br>#ifndef WF_CPUMASK <br>    #define WF_CPUMASK      0xFC000000 <br>    #define WF_CPU_X86      0 <br>    #define WF_CPU_R4000    1 <br>    #define WF_CPU_ALPHA    2 <br>    #define WF_CPU_CLIPPER  3 <br>#endif <br> <br>    static TCHAR    szFormatSubSys[]= TEXT("Windows Version %u.%.2u (%s%s)\n%s Subsystem, DOS Version %u.%.2u"); <br>    static TCHAR    szFormatDOS[]   = TEXT("Windows Version %u.%.2u (%s%s)\nDOS Version %u.%.2u"); <br>    static TCHAR    szSubSysWLO[]   = TEXT("WLO"); <br>    static TCHAR    szSubSysWOW[]   = TEXT("WOW"); <br>    static TCHAR    szModeEnhanced[]= TEXT("Enhanced"); <br>    static TCHAR    szModeStandard[]= TEXT("Standard"); <br>    static TCHAR    szEnvPaging[]   = TEXT(", Paging"); <br> <br>    DWORD   dwWinFlags; <br>    PTSTR   pszMode; <br> <br>    BYTE    bVerEnvMajor    = HIBYTE(LOWORD(uVerEnv)); <br>    BYTE    bVerEnvMinor    = LOBYTE(LOWORD(uVerEnv)); <br> <br>    dwWinFlags = GetWinFlags(); <br> <br>    pszMode = (dwWinFlags &amp; WF_ENHANCED) ? szModeEnhanced : szModeStandard; <br>    if (dwWinFlags &amp; (WF_WLO | WF_WINNT)) <br>    { <br>        wsprintf(pszEnvironment, szFormatSubSys, bVerWinMajor, bVerWinMinor, <br>                 (LPSTR)pszMode, <br>                 (LPSTR)((dwWinFlags &amp; WF_PAGING) ? szEnvPaging : gszNull), <br>                 (LPSTR)((dwWinFlags &amp; WF_WINNT) ? szSubSysWOW : szSubSysWLO), <br>                 bVerEnvMajor, bVerEnvMinor); <br>    } <br>    else <br>    { <br>        wsprintf(pszEnvironment, szFormatDOS, bVerWinMajor, bVerWinMinor, <br>                 (LPSTR)pszMode, <br>                 (LPSTR)((dwWinFlags &amp; WF_PAGING) ? szEnvPaging : gszNull), <br>                 bVerEnvMajor, bVerEnvMinor); <br>    } <br>} <br>#endif <br>    } <br> <br>    // <br>    //  if caller wants the platform string version... <br>    // <br>    if (NULL != pszPlatform) <br>    { <br>#ifdef WIN32 <br>{ <br>    static TCHAR    szFormatPlatform[]  = TEXT("%s%u, %u Processor(s)"); <br>    static TCHAR    szProcessorIntel[]  = TEXT("Intel "); <br>    static TCHAR    szProcessorMIPS[]   = TEXT("MIPS R"); <br>    static TCHAR    szProcessorAlpha[]  = TEXT("DEC Alpha "); <br>    static TCHAR    szProcessorUnknown[]  = TEXT("Unknown"); <br> <br>    SYSTEM_INFO sysinfo; <br>    PTSTR       pszProcessor; <br> <br>    // <br>    //  this is absolutely silly. one would think that the dwOemId member <br>    //  would provide something useful like the processor class... but <br>    //  no, it doesn't--it is always 0. <br>    // <br>    GetSystemInfo(&amp;sysinfo); <br>    switch (sysinfo.dwProcessorType) <br>    { <br>        case PROCESSOR_INTEL_386: <br>        case PROCESSOR_INTEL_486: <br>            pszProcessor = szProcessorIntel; <br>            break; <br> <br>        case PROCESSOR_MIPS_R4000: <br>            pszProcessor = szProcessorMIPS; <br>            break; <br> <br>        case PROCESSOR_ALPHA_21064: <br>            pszProcessor = szProcessorAlpha; <br>            break; <br> <br>        default: <br>            pszProcessor = szProcessorUnknown; <br>            break; <br>    } <br> <br>    // <br>    // <br>    // <br>    if (pszProcessor != szProcessorUnknown) <br>        wsprintf(pszPlatform, szFormatPlatform, (LPSTR)pszProcessor, <br>                 sysinfo.dwProcessorType, sysinfo.dwNumberOfProcessors); <br>    else <br>        lstrcpy(pszPlatform, pszProcessor); <br>} <br>#else <br>{ <br>    static TCHAR    szPlat286[]         = TEXT("80286"); <br>    static TCHAR    szPlat386[]         = TEXT("80386"); <br>    static TCHAR    szPlat486[]         = TEXT("i486"); <br>    static TCHAR    szPlatR4000[]       = TEXT("MIPS R4000, Emulation: "); <br>    static TCHAR    szPlatAlpha21064[]  = TEXT("Alpha 21064, Emulation: "); <br>    static TCHAR    szPlatClipper[]     = TEXT("Clipper, Emulation: "); <br>    static TCHAR    szPlat80x87[]       = TEXT(", 80x87"); <br> <br>    DWORD   dwWinFlags; <br> <br>    dwWinFlags = GetWinFlags(); <br>    pszPlatform[0] = '\0'; <br> <br>    if (dwWinFlags &amp; (WF_WLO | WF_WINNT)) <br>    { <br>        switch ((dwWinFlags &amp; WF_CPUMASK) &gt;&gt; 26) <br>        { <br>            case WF_CPU_X86: <br>                break; <br> <br>            case WF_CPU_R4000: <br>                lstrcpy(pszPlatform, szPlatR4000); <br>                break; <br> <br>            case WF_CPU_ALPHA: <br>                lstrcpy(pszPlatform, szPlatAlpha21064); <br>                break; <br> <br>            case WF_CPU_CLIPPER: <br>                lstrcpy(pszPlatform, szPlatClipper); <br>                break; <br>        } <br>    } <br> <br>    if (dwWinFlags &amp; WF_CPU286) <br>        lstrcat(pszPlatform, szPlat286); <br>    else if (dwWinFlags &amp; WF_CPU386) <br>        lstrcat(pszPlatform, szPlat386); <br>    else if (dwWinFlags &amp; WF_CPU486) <br>        lstrcat(pszPlatform, szPlat486); <br> <br>    if (dwWinFlags &amp; WF_80x87) <br>        lstrcat(pszPlatform, szPlat80x87); <br>} <br>#endif <br>    } <br> <br>    // <br>    //  return the result <br>    // <br>    return (lr); <br>} // AppGetWindowsVersion() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  LRESULT AppWinIniChange <br>// <br>//  Description: <br>//      This function is responsible for handling the WM_WININICHANGE <br>//      message. This message is sent when modifications have been made <br>//      to WIN.INI (from SystemParametersInfo() or other sources). <br>// <br>//      An application should re-enumerate system metrics (GetSystemMetrics) <br>//      and system color (GetSystemColors) information that it has cached. <br>//      Note that checking the section that was modified should be done if <br>//      some enumerations are time consuming. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to window that generated the WM_INITMENUPOPUP <br>//      message. <br>// <br>//      LPCTSTR pszSection: Pointer to section name that has been modified <br>//      in WIN.INI. Note that this argument might be NULL (sent by apps <br>//      that were written incorrectly!). If it is NULL, then this application <br>//      should re-enumerate ALL metrics, colors, etc. <br>// <br>//  Return (LRESULT): <br>//      The return value is zero if the message is processed. <br>// <br>//  History: <br>//       2/15/93    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>LRESULT FNGLOBAL AppWinIniChange <br>( <br>    HWND            hwnd, <br>    LPCTSTR         pszSection <br>) <br>{ <br>    DPF(0, "AppWinIniChanged(hwnd=%Xh, pszSection='%s')", <br>            hwnd, (NULL == pszSection) ? TEXT("(null)") : pszSection); <br> <br>    // <br>    //  we processed the message... <br>    // <br>    return (0L); <br>} // AppWinIniChange() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  HFONT AppChooseFont <br>// <br>//  Description: <br>//      This function is a wrapper for the ChooseFont() common dialog. <br>//      The purpose of this function is to let the user choose a font that <br>//      looks good to them--regardless of how stupid it really looks. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to parent window for chooser dialog. <br>// <br>//      HFONT hfont: Handle to current font (default for chooser dialog). <br>// <br>//      PLOGFONT plf: Pointer to optional LOGFONT structure to receive a <br>//      copy of the LOGFONT information for the newly chosen font. <br>// <br>//  Return (HFONT): <br>//      The return value is the newly chosen font. If no new font was chosen <br>//      then the return value is NULL. <br>// <br>//  History: <br>//       2/ 7/93    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>HFONT FNGLOBAL AppChooseFont <br>( <br>    HWND            hwnd, <br>    HFONT           hfont, <br>    PLOGFONT        plf <br>) <br>{ <br>    LOGFONT     lf; <br>    CHOOSEFONT  cf; <br>    BOOL        f; <br>    HFONT       hfontNew; <br> <br>    // <br>    //  get the font info for the current font... <br>    // <br>    GetObject(hfont, sizeof(LOGFONT), (LPVOID)&amp;lf); <br> <br>    // <br>    //  fill in the choosefont structure <br>    // <br>    cf.lStructSize  = sizeof(CHOOSEFONT); <br>    cf.hwndOwner    = hwnd; <br>    cf.hDC          = NULL; <br>    cf.Flags        = CF_SCREENFONTS | CF_INITTOLOGFONTSTRUCT; <br>    cf.lCustData    = 0; <br>    cf.lpfnHook     = NULL; <br>    cf.hInstance    = NULL; <br>    cf.nFontType    = SCREEN_FONTTYPE; <br>    cf.lpLogFont    = (LPLOGFONT)&amp;lf; <br> <br>    // <br>    //  splash a dialog into the user's face.. <br>    // <br>    hfontNew = NULL; <br>    f = ChooseFont(&amp;cf); <br>    if (f) <br>    { <br>        // <br>        //  create the new font.. <br>        // <br>        hfontNew = CreateFontIndirect(&amp;lf); <br>        if (NULL == hfontNew) <br>            return (NULL); <br> <br>        // <br>        //  copy the logfont structure if caller wants it <br>        // <br>        if (NULL != plf) <br>            *plf = lf; <br>    } <br> <br>    // <br>    //  return the new font (if one was chosen) <br>    // <br>    return (hfontNew); <br>} // AppChooseFont() <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  BOOL AppProfileWriteBytes <br>//   <br>//  Description: <br>//      This function writes a raw structure of bytes to the application's <br>//      ini section that can later be retrieved using AppProfileReadBytes. <br>//      This gives an application the ability to write any structure to <br>//      the ini file and restore it later--very useful. <br>// <br>//      NOTE! Starting with Windows for Workgroups 3.1 there are two new <br>//      profile functions that provide the same functionality of this <br>//      function. Specifically, these functions are GetPrivateProfileStruct <br>//      and WritePrivateProfileStruct. These new functions are provided <br>//      by the Common Controls DLL. The prototypes are as follows: <br>// <br>//      BOOL GetPrivateProfileStruct <br>//      ( <br>//          LPSTR       szSection, <br>//          LPSTR       szKey, <br>//          LPBYTE      lpStruct, <br>//          UINT        uSizeStruct, <br>//          LPSTR       szFile <br>//      ); <br>// <br>//      BOOL WritePrivateProfileStruct <br>//      ( <br>//          LPSTR       szSection, <br>//          LPSTR       szKey, <br>//          LPBYTE      lpStruct, <br>//          UINT        uSizeStruct, <br>//          LPSTR       szFile <br>//      ); <br>// <br>//      If you are building an application that is for Window for Workgroups <br>//      or newer versions of Windows, you will probably want to use the <br>//      above functions. <br>// <br>//  Arguments: <br>//      PCTSTR pszKey: Pointer to key name for the stored data. <br>//   <br>//      LPBYTE pbStruct: Pointer to the data to be saved. <br>//   <br>//      UINT cbStruct: Count in bytes of the data to store. <br>//   <br>//  Return (BOOL): <br>//      The return value is TRUE if the function is successful. It is FALSE <br>//      if it fails. <br>//   <br>//  History: <br>//       3/10/93   created. <br>//   <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNGLOBAL AppProfileWriteBytes <br>( <br>    PCTSTR          pszKey, <br>    LPBYTE          pbStruct, <br>    UINT            cbStruct <br>) <br>{ <br>    static TCHAR achNibbleToChar[] = <br>    { <br>        '0', '1', '2', '3', '4', '5', '6', '7', <br>        '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', <br>    }; <br>    #define     NIBBLE2CHAR(x)      (achNibbleToChar[x]) <br>     <br>    TCHAR       ach[APP_MAX_STRING_RC_CHARS]; <br>    LPTSTR      psz; <br>    LPTSTR      pch; <br>    UINT        cchTemp; <br>    BOOL        fAllocated; <br>    BOOL        fReturn; <br>    BYTE        b; <br>    BYTE        bChecksum; <br> <br>    // <br>    //  if pbStruct is NULL, then erase the key from the ini file, otherwise <br>    //  format the raw bytes into a hex string and write that out... <br>    // <br>    fAllocated = FALSE; <br>    psz        = NULL; <br>    if (NULL != pbStruct) <br>    { <br>        // <br>        //  check if the quick buffer can be used for formatting the output <br>        //  text--if it cannot, then alloc space for it. note that space <br>        //  must be available for an ending checksum byte (2 bytes for high <br>        //  and low nibble) as well as a null terminator. <br>        // <br>        psz     = (LPTSTR)ach; <br>        cchTemp = cbStruct * 2 + 3; <br>        if (cchTemp &gt; SIZEOF(ach)) <br>        { <br>            psz = GlobalAllocPtr(GHND, cchTemp * sizeof(TCHAR)); <br>            if (NULL == psz) <br>                return (FALSE); <br> <br>            fAllocated = TRUE; <br>        } <br>   <br>        // <br>        //  step through all bytes in the structure and convert it to <br>        //  a string of hex numbers... <br>        // <br>        bChecksum = 0; <br>        for (pch = psz; 0 != cbStruct; cbStruct--, pbStruct++) <br>        { <br>            // <br>            //  grab the next byte and add into checksum... <br>            // <br>            bChecksum += (b = *pbStruct); <br>       <br>            *pch++ = NIBBLE2CHAR((b &gt;&gt; (BYTE)4) &amp; (BYTE)0x0F); <br>            *pch++ = NIBBLE2CHAR(b &amp; (BYTE)0x0F); <br>        } <br> <br>        // <br>        //  add the checksum byte to the end and null terminate the hex <br>        //  dumped string... <br>        // <br>        *pch++ = NIBBLE2CHAR((bChecksum &gt;&gt; (BYTE)4) &amp; (BYTE)0x0F); <br>        *pch++ = NIBBLE2CHAR(bChecksum &amp; (BYTE)0x0F); <br>        *pch   = '\0'; <br>    } <br> <br>    // <br>    //  write the string of hex bytes out to the ini file... <br>    // <br>    fReturn = WriteProfileString(gszAppSection, pszKey, psz); <br> <br>    // <br>    //  free the temporary buffer if one was allocated (lots of bytes!) <br>    // <br>    if (fAllocated) <br>        GlobalFreePtr(psz); <br>   <br>    return (fReturn); <br>} // AppProfileWriteBytes <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  BOOL AppProfileReadBytes <br>//   <br>//  Description: <br>//      This function reads a previously stored structure of bytes from <br>//      the application's ini file. This data must have been written with <br>//      the AppProfileWriteBytes function--it is checksumed to keep bad <br>//      data from blowing up the application. <br>//   <br>//      NOTE! Starting with Windows for Workgroups 3.1 there are two new <br>//      profile functions that provide the same functionality of this <br>//      function. Specifically, these functions are GetPrivateProfileStruct <br>//      and WritePrivateProfileStruct. These new functions are provided <br>//      by the Common Controls DLL. The prototypes are as follows: <br>// <br>//      BOOL GetPrivateProfileStruct <br>//      ( <br>//          LPSTR       szSection, <br>//          LPSTR       szKey, <br>//          LPBYTE      lpStruct, <br>//          UINT        uSizeStruct, <br>//          LPSTR       szFile <br>//      ); <br>// <br>//      BOOL WritePrivateProfileStruct <br>//      ( <br>//          LPSTR       szSection, <br>//          LPSTR       szKey, <br>//          LPBYTE      lpStruct, <br>//          UINT        uSizeStruct, <br>//          LPSTR       szFile <br>//      ); <br>// <br>//      If you are building an application that is for Window for Workgroups <br>//      or newer versions of Windows, you will probably want to use the <br>//      above functions. <br>//   <br>//  Arguments: <br>//      PCTSTR pszKey: Pointer to key that contains the data. <br>//   <br>//      LPBYTE pbStruct: Pointer to buffer to receive the data. <br>//   <br>//      UINT cbStruct: Number of bytes expected. <br>//   <br>//  Return (BOOL): <br>//      The return value is TRUE if the function is successful. It is FALSE <br>//      if the function fails (bad checksum, missing key, etc). <br>//   <br>//  History: <br>//       3/10/93   created. <br>//   <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNGLOBAL AppProfileReadBytes <br>( <br>    PCTSTR          pszKey, <br>    LPBYTE          pbStruct, <br>    UINT            cbStruct <br>) <br>{ <br>    // <br>    //  note that the following works for both upper and lower case, and <br>    //  will return valid values for garbage chars <br>    // <br>    #define CHAR2NIBBLE(ch) (BYTE)( ((ch) &gt;= '0' &amp;&amp; (ch) &lt;= '9') ?  \ <br>                                (BYTE)((ch) - '0') :                \ <br>                                ((BYTE)(10 + (ch) - 'A') &amp; (BYTE)0x0F) ) <br> <br>    TCHAR       ach[APP_MAX_STRING_RC_CHARS]; <br>    LPTSTR      psz; <br>    LPTSTR      pch; <br>    UINT        cchTemp; <br>    UINT        u; <br>    BOOL        fAllocated; <br>    BOOL        fReturn; <br>    BYTE        b; <br>    BYTE        bChecksum; <br>    TCHAR       ch; <br> <br>    // <br>    //  add one the the number of bytes needed to accomodate the checksum <br>    //  byte placed at the end by AppProfileWriteBytes... <br>    // <br>    cbStruct++; <br> <br>    // <br>    //  check if the quick buffer can be used for retrieving the input <br>    //  text--if it cannot, then alloc space for it. note that there must <br>    //  be space available for the null terminator (the +1 below). <br>    // <br>    fAllocated = FALSE; <br>    psz        = (LPTSTR)ach; <br>    cchTemp    = cbStruct * 2 + 1; <br>    if (cchTemp &gt; SIZEOF(ach)) <br>    { <br>        psz = GlobalAllocPtr(GHND, cchTemp * sizeof(TCHAR)); <br>        if (NULL == psz) <br>            return (FALSE); <br> <br>        fAllocated = TRUE; <br>    } <br> <br>    // <br>    //  read the hex string... if it is not the correct length, then assume <br>    //  error and return. <br>    // <br>    fReturn = FALSE; <br>    u = (UINT)GetProfileString(gszAppSection, pszKey, gszNull, psz, cchTemp); <br>    if ((cbStruct * 2) == u) <br>    { <br>        bChecksum = 0; <br>        for (pch = psz; 0 != cbStruct; cbStruct--, pbStruct++) <br>        { <br>            ch = *pch++; <br>            b  = CHAR2NIBBLE(ch) &lt;&lt; (BYTE)4; <br>            ch = *pch++; <br>            b |= CHAR2NIBBLE(ch); <br> <br>            // <br>            //  if this is not the final byte (the checksum byte), then  <br>            //  store it and accumulate checksum.. <br>            // <br>            if (cbStruct != 1) <br>                bChecksum += (*pbStruct = b); <br>        } <br> <br>        // <br>        //  check the last byte read against the checksum that we calculated <br>        //  if they are not equal then return error... <br>        // <br>        fReturn = (bChecksum == b); <br>    } <br> <br> <br>    // <br>    //  free the temporary buffer if one was allocated (lots of bytes!) <br>    // <br>    if (fAllocated) <br>        GlobalFreePtr(psz); <br>   <br>    return (fReturn); <br>} // AppProfileReadBytes <br> <br> <br>//==========================================================================; <br>// <br>//  Initialization and exit code... <br>// <br>// <br>//==========================================================================; <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL AppRegisterPenApp <br>// <br>//  Description: <br>//      This function is used to register and de-register an application <br>//      as being 'Pen Enhanced.' If the Windows installation is Pen enabled <br>//      then this function allows the RC Manager to replace all 'Edit' <br>//      controls with 'HEdit' controls. <br>// <br>//      This function must be called to register the application BEFORE <br>//      creating any edit controls. <br>// <br>//  Arguments: <br>//      BOOL fRegister: If this argument is TRUE, the app is registered <br>//      with the RC Manager as being Pen aware. If this argument is FALSE <br>//      the app is de-registered. <br>// <br>//  Return (BOOL): <br>//      The return value is TRUE if Windows for Pen Computing is installed <br>//      on the system. The return value is FALSE if the Windows installation <br>//      is not Pen enabled. <br>// <br>//  History: <br>//       3/ 1/93    created.  <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNLOCAL AppRegisterPenApp <br>( <br>    BOOL    fRegister <br>) <br>{ <br>    #define RPA_DEFAULT     0x0001 <br> <br>    typedef void (FAR PASCAL *PENWINREGISTERPROC)(UINT, BOOL); <br> <br>    static char                 szRegPenApp[]   = "RegisterPenApp"; <br>    static PENWINREGISTERPROC   pfnRegPenApp    = NULL; <br> <br>    HINSTANCE   hinstPenWin; <br> <br>    // <br>    //  check if Windows for Pen Computing is installed--and if it is,  <br>    //  dyna-link to the RegisterPenApp() function. <br>    // <br>    //  if Pens are not supported, then return FALSE. <br>    // <br>    if (NULL == pfnRegPenApp) <br>    { <br>        hinstPenWin = (HINSTANCE)GetSystemMetrics(SM_PENWINDOWS); <br>        if (NULL == hinstPenWin) <br>            return (FALSE); <br> <br>        (FARPROC)pfnRegPenApp = GetProcAddress(hinstPenWin, szRegPenApp); <br>        if (NULL == pfnRegPenApp) <br>            return (FALSE); <br>    } <br> <br>    // <br>    //  either enable or disable the RC Manager's Pen meathooks.. <br>    // <br>    (*pfnRegPenApp)(RPA_DEFAULT, fRegister); <br> <br>    return (TRUE); <br>} // AppRegisterPenApp() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  LRESULT AppCreate <br>// <br>//  Description: <br>//      This function is called to handle the WM_CREATE message for the <br>//      applications window. The application should finish the creation <br>//      of the window (create controls, allocate resources, etc). The <br>//      window has not been displayed (CreateWindow[Ex] has not returned). <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to the window that is in the process of being <br>//      created. <br>// <br>//      LPCREATESTRUCT pcs: Pointer to a CREATESTRUCT that contains info <br>//      about the window being created. <br>// <br>//  Return (LRESULT): <br>//      The return value should be nonzero if the application wishes to <br>//      let the window finish being created. A return of zero tells <br>//      CreateWindow[Ex] to fail the creation of the window. <br>// <br>//  History: <br>//      11/ 8/92    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>LRESULT FNGLOBAL AppCreate <br>( <br>    HWND            hwnd, <br>    LPCREATESTRUCT  pcs <br>) <br>{ <br>    static TCHAR    szButtonStep[]  = TEXT("&amp;Step"); <br>    static TCHAR    szButtonGo[]    = TEXT("&amp;Go"); <br>    static TCHAR    szButtonRun[]   = TEXT("&amp;Run"); <br> <br>    static TCHAR    szTextCount[]   = TEXT("&amp;Count: "); <br>    static TCHAR    szTextOutput[]  = TEXT("Output: "); <br>    static TCHAR    szTextOne[]     = TEXT("1");        // !!! <br> <br>    static TCHAR    szBunnySmag[]   = TEXT("zYzBunnySmag"); <br>    static TCHAR    szButton[]      = TEXT("button"); <br>    static TCHAR    szEdit[]        = TEXT("edit"); <br>    static TCHAR    szStatic[]      = TEXT("static"); <br> <br>    HINSTANCE   hinst; <br>    HFONT       hfont; <br>    HFONT       hfontFixed; <br>    TEXTMETRIC  tm; <br>    HDC         hdc; <br>    HWND        hwndButton; <br>    HWND        hwndScript; <br>    HWND        hwndStatus; <br>    SIZE        sSize; <br>    int         nHeightButton; <br>    int         nWidthButton; <br>    int         nHeightText; <br> <br>    DPF(0, "AppCreate(hwnd=%Xh, cs.x=%d, cs.y=%d, cs.cx=%d, cs.cy=%d)", <br>            hwnd, pcs-&gt;x, pcs-&gt;y, pcs-&gt;cx, pcs-&gt;cy); <br> <br>    hinst = pcs-&gt;hInstance; <br> <br>    // <br>    //  create the button bar and status bar--use a non-bold var font. <br>    //  to use the non-bold font and make the controls a 'proper' size, <br>    //  we need to get the metrics of the font.. note that the extent <br>    //  we use for the width of the buttons on the button bar are <br>    //  computed using the longest text we expect to display <br>    // <br>    hfont = GetStockFont(SYSTEM_FONT); <br>    hfontFixed = GetStockFont(SYSTEM_FIXED_FONT); <br>    hdc = GetDC(hwnd); <br>    { <br>        hfont = SelectFont(hdc, hfont); <br>        GetTextMetrics(hdc, &amp;tm); <br>        GetTextExtentPoint(hdc, szButton, SIZEOF(szButton), (LPSIZE)&amp;sSize); <br>        hfont = SelectFont(hdc, hfont); <br>    } <br>    ReleaseDC(hwnd, hdc); <br> <br>    // <br>    //  compute some almost random numbers for width and height... <br>    // <br>    nHeightText   = (int)(tm.tmHeight + tm.tmExternalLeading); <br>    nHeightButton = nHeightText * 3 / 2 + 2; <br>    nWidthButton  = sSize.cx * 3 / 2; <br> <br> <br>    // <br>    //  create the script window--use a non-bold fixed font... <br>    // <br>    hwndScript = CreateWindow(szEdit, gszNull, <br>                              ES_LEFT | ES_MULTILINE | WS_TABSTOP | <br>                              ES_AUTOVSCROLL | ES_AUTOHSCROLL | <br>                              ES_NOHIDESEL | WS_BORDER | WS_VSCROLL | <br>                              WS_HSCROLL | WS_VISIBLE | WS_CHILD, <br>                              0, 0, 0, 0, hwnd, (HMENU)IDD_APP_EDIT_SCRIPT, <br>                              hinst, NULL); <br>    SetWindowFont(hwndScript, hfontFixed, FALSE); <br> <br>    // <br>    //  when creating a multiline edit control, the default text limit is <br>    //  32k _even in Win 32_. note that in Win 32 you can set text length <br>    //  to &gt;32k without sending EM_LIMITTEXT, but you cannot EDIT the text! <br>    // <br>    //  so, send a limit of 'max int' which is the largest size this <br>    //  application can deal with (selections, etc are integers): <br>    // <br>    //      Win 16  : 0x7FFF _bytes_ <br>    //      Win 32  : 0x7FFFFFFF _characters_ <br>    // <br>    Edit_LimitText(hwndScript, (int)((UINT)-1 &lt;&lt; 1 &gt;&gt; 1)); <br> <br> <br>    // <br>    //  the status bar <br>    // <br>    hwndStatus = CreateWindow(szEdit, gszNull, <br>                              ES_LEFT | ES_AUTOHSCROLL | ES_READONLY | <br>                              WS_VISIBLE | WS_CHILD, <br>                              0, 0, 0, nHeightText, <br>                              hwnd, (HMENU)IDD_APP_TEXT_STATUS, hinst, NULL); <br>    SetWindowFont(hwndStatus, hfont, FALSE); <br> <br>    hwndStatus = CreateWindow(szStatic, gszNull, <br>                              WS_BORDER | WS_VISIBLE | WS_CHILD, <br>                              0, 0, 0, nHeightText, <br>                              hwnd, (HMENU)IDD_APP_BOX_SEPARATOR1, hinst, NULL); <br> <br>    hwndStatus = CreateWindow(szEdit, gszNull, <br>                              ES_LEFT | ES_AUTOHSCROLL | ES_READONLY | <br>                              WS_VISIBLE | WS_CHILD, <br>                              0, 0, 0, nHeightText, <br>                              hwnd, (HMENU)IDD_APP_TEXT_NOTIFY, hinst, NULL); <br>    SetWindowFont(hwndStatus, hfont, FALSE); <br> <br> <br>    hwndStatus = CreateWindow(szStatic, gszNull, <br>                              WS_BORDER | WS_VISIBLE | WS_CHILD, <br>                              0, 0, 0, nHeightText, <br>                              hwnd, (HMENU)IDD_APP_BOX_SEPARATOR2, hinst, NULL); <br> </code></pre>
<p>
</p>
<pre><code>hwndStatus = CreateWindow(szStatic, gszNull, <br>                              SS_CENTER | WS_VISIBLE | WS_CHILD, <br>                              0, 0, 0, nHeightText, <br>                              hwnd, (HMENU)IDD_APP_TEXT_OPTIONS, hinst, NULL); <br>    SetWindowFont(hwndStatus, hfontFixed, FALSE); <br> <br> <br> <br> <br>    // <br>    //  the button bar <br>    // <br>    hwndButton = CreateWindow(szButton, szButtonStep, <br>                              BS_PUSHBUTTON | WS_TABSTOP | WS_VISIBLE | WS_CHILD, <br>                              0, 0, nWidthButton, nHeightButton, <br>                              hwnd, (HMENU)IDD_APP_BTN_STEP, hinst, NULL); <br>    SetWindowFont(hwndButton, hfont, FALSE); <br> <br>    hwndButton = CreateWindow(szButton, szButtonGo, <br>                              BS_PUSHBUTTON | WS_TABSTOP | WS_VISIBLE | WS_CHILD, <br>                              nWidthButton, 0, nWidthButton, nHeightButton, <br>                              hwnd, (HMENU)IDD_APP_BTN_GO, hinst, NULL); <br>    SetWindowFont(hwndButton, hfont, FALSE); <br> <br>    hwndButton = CreateWindow(szButton, szButtonRun, <br>                              BS_PUSHBUTTON | WS_TABSTOP | WS_VISIBLE | WS_CHILD, <br>                              nWidthButton * 2, 0, nWidthButton, nHeightButton, <br>                              hwnd, (HMENU)IDD_APP_BTN_RUN, hinst, NULL); <br>    SetWindowFont(hwndButton, hfont, FALSE); <br> <br> <br>    // <br>    // <br>    // <br>    hwndStatus = CreateWindow(szStatic, szTextCount, <br>                              SS_RIGHT | WS_VISIBLE | WS_CHILD, <br>                              nWidthButton * 3, (nHeightButton - nHeightText) / 2, <br>                              nWidthButton, nHeightText, <br>                              hwnd, (HMENU)-1, hinst, NULL); <br>    SetWindowFont(hwndStatus, hfont, FALSE); <br> <br>    hwndScript = CreateWindow(szEdit, szTextOne, <br>                              ES_LEFT | ES_AUTOHSCROLL | WS_BORDER | <br>                              WS_TABSTOP | WS_VISIBLE | WS_CHILD, <br>                              nWidthButton * 4, 0, nWidthButton, nHeightButton, <br>                              hwnd, (HMENU)IDD_APP_EDIT_RUNCOUNT, hinst, NULL); <br>    SetWindowFont(hwndScript, hfont, FALSE); <br> <br> <br>    // <br>    // <br>    // <br>    hwndStatus = CreateWindow(szStatic, szTextOutput, <br>                              SS_RIGHT | WS_VISIBLE | WS_CHILD, <br>                              nWidthButton * 5, (nHeightButton - nHeightText) / 2, <br>                              nWidthButton, nHeightText, <br>                              hwnd, (HMENU)-1, hinst, NULL); <br>    SetWindowFont(hwndStatus, hfont, FALSE); <br> <br>    hwndStatus = CreateWindow(szEdit, gszNull, <br>                              ES_LEFT | ES_AUTOHSCROLL | ES_READONLY | <br>                              WS_VISIBLE | WS_CHILD, <br>                              nWidthButton * 6, (nHeightButton - nHeightText) / 2, <br>                              nWidthButton, nHeightText, <br>                              hwnd, (HMENU)IDD_APP_TEXT_OUTPUT, hinst, NULL); <br>    SetWindowFont(hwndStatus, hfont, FALSE); <br> <br> <br> <br>    // <br>    //  we want the focus to default to the script window so the user <br>    //  can immediately start typing... <br>    // <br>    SetFocus(hwndScript); <br> <br> <br>    // <br>    //  return nonzero to succeed the creation of the window <br>    // <br>    return (1L); <br>} // AppCreate() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  LRESULT AppQueryEndSession <br>// <br>//  Description: <br>//      This function handles the WM_QUERYENDSESSION. This message is sent <br>//      by USER when ExitWindows has been called to end the Windows session. <br>//      This function can stop Windows from exiting if it is not convenient <br>//      for Windows to end. <br>// <br>//      Giving the user the option to save modified data before continueing <br>//      with the shutdown of Windows is a good idea. <br>// <br>//      Telling Windows to continue with the exit procedure does not <br>//      necessarily mean Windows will exit. All applications are queried <br>//      for shutdown approval. When the actual decision is made on whether <br>//      Windows will exit, WM_ENDSESSION will be sent with the result. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to window that received the message. <br>// <br>//  Return (LRESULT): <br>//      Returns zero to STOP Windows from exiting. Returns non-zero to <br>//      allows windows to shut down. <br>// <br>//  History: <br>//       2/ 9/93    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>LRESULT FNGLOBAL AppQueryEndSession <br>( <br>    HWND            hwnd <br>) <br>{ <br>    BOOL    f; <br> <br>    DPF(0, "AppQueryEndSession(hwnd=%Xh)", hwnd); <br> <br>    // <br>    //  attempt to shut down--if this fails (user canceled it, etc) then <br>    //  do NOT allow the Windows to exit. <br>    // <br>    f = MciAppShutdown(hwnd, gszAppFilePath, gszAppFileTitle); <br>    if (!f) <br>        return (0L); <br> <br> <br>    // <br>    //  tell Windows to proceed with the shutdown process! <br>    // <br>    return (1L); <br>} // AppQueryEndSession() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  LRESULT AppEndSession <br>// <br>//  Description: <br>//      This function is called to handle the WM_ENDSESSION message. This <br>//      message is generated after the application answers the <br>//      WM_QUERYENDSESSION message. The purpose of the WM_ENDSESSION <br>//      message is to tell the application if Windows will be exiting <br>//      (TRUE  == fEndSession) or the end session was canceled by an <br>//      application (FALSE == fEndSession). <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to window that received the message. <br>// <br>//      BOOL fEndSession: TRUE if Windows is exiting. FALSE if the end <br>//      session was canceled. <br>// <br>//  Return (LRESULT): <br>//      Returns zero if the message is processed. Note that an application <br>//      cannot halt the termination of Windows from this message--the <br>//      WM_QUERYENDSESSION is the only message that allows that behaviour. <br>//      If fEndSession is TRUE, Windows *WILL* exit--whether you like it <br>//      or not. <br>// <br>//  History: <br>//       2/ 9/93    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>LRESULT FNGLOBAL AppEndSession <br>( <br>    HWND            hwnd, <br>    BOOL            fEndSession <br>) <br>{ <br>    DPF(0, "AppEndSession(hwnd=%Xh, fEndSession=%d)", hwnd, fEndSession); <br> <br>    // <br>    //  we processed the message, return zero.. <br>    // <br>    return (0L); <br>} // AppEndSession() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  LRESULT AppClose <br>// <br>//  Description: <br>//      This function handles the WM_CLOSE message for the application. <br>//      If the application should close, DestroyWindow() must be called <br>//      by this function. Otherwise the application will not close. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to window that generated the WM_CLOSE message. <br>// <br>//  Return (LRESULT): <br>//      There return value is zero. The DestroyWindow function will have <br>//      been called if the application should actually close. <br>// <br>//  History: <br>//       2/ 6/93    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>LRESULT FNGLOBAL AppClose <br>( <br>    HWND            hwnd <br>) <br>{ <br>    HWND        hwndScript; <br>    HFONT       hfont; <br>    BOOL        f; <br> <br>    // <br>    //  if the Shift key is held down during the close message, then just <br>    //  save the current state but don't destroy the window... this is <br>    //  useful if the user does not want to exit the app and rerun it <br>    //  to make sure the state is saved--just before the user does something <br>    //  that may crash Windows or something.. <br>    // <br>    if (GetKeyState(VK_SHIFT) &lt; 0) <br>    { <br>        // <br>        //  save any settings that should be saved on app termination... <br>        // <br>        MciAppSettingsSave(hwnd); <br>        return (0L); <br>    } <br> <br>    // <br>    //  attempt to shut down--if this fails (user canceled it, etc) then <br>    //  do NOT allow the window to be destroyed. <br>    // <br>    f = MciAppShutdown(hwnd, gszAppFilePath, gszAppFileTitle); <br>    if (!f) <br>        return (0L); <br> <br>    // <br>    //  destroy the font we are using... before deleting the font, select <br>    //  the system font back into the script window so the font won't <br>    //  be 'in use' anymore. <br>    // <br>    hwndScript = GetDlgItem(hwnd, IDD_APP_EDIT_SCRIPT); <br> <br>    hfont = GetWindowFont(hwndScript); <br>    SetWindowFont(hwndScript, NULL, FALSE); <br>    DeleteFont(hfont); <br> <br>    // <br>    //  make the window close and terminate the application <br>    // <br>    DestroyWindow(hwnd); <br> <br>    return (0L); <br>} // AppClose() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL AppInit <br>// <br>//  Description: <br>//      This function is called to initialize a new instance of the <br>//      application. We want to parse our command line, create our window, <br>//      allocate resources, etc. <br>// <br>//      The arguments passed to this function are exactly the same as <br>//      those passed to WinMain. <br>// <br>//  Arguments: <br>//      HINSTANCE hinst: Identifies the current instance of the <br>//      application. <br>// <br>//      HINSTANCE hinstPrev: Identifies the previous instance of the <br>//      application (NULL if first instance). For Win 32, this argument <br>//      is _always_ NULL. <br>// <br>//      LPTSTR pszCmdLine: Points to null-terminated unparsed command line. <br>//      If the application is compiled for Unicode, then this argument is <br>//      ignored. <br>// <br>//      int nCmdShow: How the main window for the application is to be <br>//      shown by default. <br>// <br>//  Return (HWND): <br>//      Returns the newly created handle to the applications main window. <br>//      This handle is NULL if something went wrong and tells the application <br>//      to exit immediately. <br>// <br>//  History: <br>//      11/ 8/92    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>HWND FNGLOBAL AppInit <br>( <br>    HINSTANCE       hinst, <br>    HINSTANCE       hinstPrev, <br>    LPTSTR          pszCmdLine, <br>    int             nCmdShow <br>) <br>{ <br>    HWND        hwnd; <br>    WNDCLASS    wc; <br> <br>    DPF(0, "AppInit(hinst=%Xh, hinstPrev=%Xh, pszCmdLine='%s', nCmdShow=%d)", <br>            hinst, hinstPrev, pszCmdLine, nCmdShow); <br> <br>    LoadString(hinst, IDS_APP_NAME, gszAppName, SIZEOF(gszAppName)); <br>    LoadString(hinst, IDS_FILE_UNTITLED, gszFileUntitled, SIZEOF(gszFileUntitled)); <br> <br> <br>    // <br>    //  determine whether a new window class needs to be registered for <br>    //  this application. for Win 16, this only needs to be done for the <br>    //  first instance of the application created. for Win 32, this must <br>    //  be done for EVERY instance of the application. <br>    // <br>    if (NULL == hinstPrev) <br>    { <br>        wc.style         = CS_HREDRAW | CS_VREDRAW; <br>        wc.lpfnWndProc   = (WNDPROC)AppWndProc; <br>        wc.cbClsExtra    = 0; <br>        wc.cbWndExtra    = 0; <br>        wc.hInstance     = hinst; <br>        wc.hIcon         = LoadIcon(hinst, ICON_APP); <br>        wc.hCursor       = LoadCursor(NULL, IDC_ARROW); <br>        wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1); <br>        wc.lpszMenuName  = MENU_APP; <br>        wc.lpszClassName = gszAppName; <br> <br>        if (!RegisterClass(&amp;wc)) <br>            return (NULL); <br>    } <br> <br> <br>    // <br>    //  if Windows for Pen Computing is installed, then allow the RC <br>    //  Manager to replace all edit controls created from this point on <br>    //  with hedit controls <br>    // <br>    AppRegisterPenApp(TRUE); <br> <br> <br>    // <br>    //  create the application's main window <br>    // <br>    //  style bits available: <br>    //      WS_EX_ACCEPTFILES   :  will receive WM_DROPFILES messages <br>    //      WS_EX_DLGMODALFRAME :  creates window with double border <br>    //      WS_EX_NOPARENTNOTIFY:  won't receive WM_PARENTNOTIFY messages <br>    //      WS_EX_TOPMOST       :  puts window in topmost space <br>    //      WS_EX_TRANSPARENT   :  a very bizarre style indeed (Win 16 only) <br>    // <br>    hwnd = CreateWindowEx(WS_EX_ACCEPTFILES | WS_EX_NOPARENTNOTIFY, <br>                          gszAppName, <br>                          gszAppName, <br>                          WS_OVERLAPPEDWINDOW, <br>                          APP_WINDOW_XOFFSET, <br>                          APP_WINDOW_YOFFSET, <br>                          APP_WINDOW_WIDTH, <br>                          APP_WINDOW_HEIGHT, <br>                          NULL, <br>                          NULL, <br>                          hinst, <br>                          NULL); <br> <br>    if (NULL == hwnd) <br>        return (NULL); <br> <br> <br>#ifdef UNICODE <br>    // <br>    //  GetCommandLine() returns a pointer to our command line. but this <br>    //  command line includes the complete command line used to launch <br>    //  the application--which is different than the pszCmdLine argument <br>    //  passed through WinMain()... <br>    // <br>    //  so, skip over the command name to get to the argument string <br>    // <br>    pszCmdLine = GetCommandLine(); <br>    if (NULL != pszCmdLine) <br>    { <br>        while (('\0' != *pszCmdLine) &amp;&amp; (' ' != *pszCmdLine++)) <br>            ; <br>    } <br>#endif <br> <br> <br>    // <br>    // <br>    // <br>    // <br>    MciAppInit(hwnd, gszAppFilePath, gszAppFileTitle, pszCmdLine, nCmdShow); <br> <br> <br>    // <br>    //  finally, get the window displayed and return success <br>    // <br>    //  the ShowWindow call is made during MciAppInit <br>    // <br>//  ShowWindow(hwnd, nCmdShow); <br>//  UpdateWindow(hwnd); <br> <br>    return (hwnd); <br>} // AppInit() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  int AppExit <br>// <br>//  Description: <br>//      This function is called just before the application exits from <br>//      WinMain. Its purpose is to clean up any resources that were allocated <br>//      for running the application: brushes, heaps, etc.. <br>// <br>//  Arguments: <br>//      HINSTANCE hinst: Identifies the current instance of the <br>//      application that is exiting. <br>// <br>//      int nResult: The result of the WM_QUIT message (in wParam of the <br>//      MSG structure. This argument will usually be 0 (even if the message <br>//      loop was never entered). <br>// <br>//  Return (int): <br>//      The return value is usually nResult--be we give this function the <br>//      opportunity to modify its value. <br>// <br>//  History: <br>//      11/ 8/92    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>int FNGLOBAL AppExit <br>( <br>    HINSTANCE       hinst, <br>    int             nResult <br>) <br>{ <br>    DPF(0, "AppExit(hinst=%Xh, nResult=%d)", hinst, nResult); <br> <br>    MciAppExit(); <br> <br>    // <br>    //  if Windows for Pen Computing is installed, then de-register the <br>    //  application so the RC Manager knows we will no longer need its <br>    //  services... <br>    // <br>    AppRegisterPenApp(FALSE); <br> <br>    return (nResult); <br>} // AppExit() <br> <br> <br>//==========================================================================; <br>// <br>//  Misc rarely used application dialogs and stuff... <br>// <br>// <br>//==========================================================================; <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL AboutDlgProc <br>// <br>//  Description: <br>//      This dialog procedure is used for the ubiquitous about box. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to window. <br>// <br>//      UINT uMsg: Message being sent to the window. <br>// <br>//      WPARAM wParam: Specific argument to message. <br>// <br>//      LPARAM lParam: Specific argument to message. <br>// <br>//  Return (BOOL): <br>//      The return value is specific to the message that was received. For <br>//      the most part, it is FALSE if this dialog procedure does not handle <br>//      a message. <br>// <br>//  History: <br>//       1/ 2/93    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNEXPORT AboutDlgProc <br>( <br>    HWND            hwnd, <br>    UINT            uMsg, <br>    WPARAM          wParam, <br>    LPARAM          lParam <br>) <br>{ <br>    HWND    hwndT; <br>    PTSTR   pach; <br>    UINT    u; <br> <br>    switch (uMsg) <br>    { <br>        case WM_INITDIALOG: <br>            // <br>            //  display some OS version information <br>            // <br>            // <br>            pach = (PTSTR)LocalAlloc(LPTR, APP_MAX_STRING_RC_BYTES); <br>            if (NULL == pach) <br>                return (TRUE); <br> <br>            AppGetWindowsVersion(pach, NULL); <br>            hwndT = GetDlgItem(hwnd, IDD_ABOUT_VERSION_OS); <br>            SetWindowText(hwndT, pach); <br> <br>            AppGetWindowsVersion(NULL, pach); <br>            hwndT = GetDlgItem(hwnd, IDD_ABOUT_VERSION_PLATFORM); <br>            SetWindowText(hwndT, pach); <br> <br>            LocalFree((HLOCAL)pach); <br>            return (TRUE); <br> <br>        case WM_COMMAND: <br>            u = GET_WM_COMMAND_ID(wParam, lParam); <br>            if ((IDOK == u) || (IDCANCEL == u)) <br>            { <br>                EndDialog(hwnd, (IDOK == u)); <br>            } <br>            break; <br>    } <br> <br>    return (FALSE); <br>} // AboutDlgProc() </code></pre>
<p>&nbsp;</p></body>
</HTML>
