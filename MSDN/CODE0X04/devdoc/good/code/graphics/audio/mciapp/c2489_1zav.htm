<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>APP.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2497"></a>APP.C</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED <br>//  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR <br>//  A PARTICULAR PURPOSE. <br>// <br>//  Copyright 1993 - 1998 Microsoft Corporation. All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br>// <br>//  app.c <br>// <br>//  Description: <br>//      This is a sample application that demonstrates how to use the <br>//      Media Control Interface (MCI) in Windows. This application is <br>//      also useful as an MCI device tester. <br>// <br>//  History: <br>//      11/ 8/92    created. <br>// <br>//==========================================================================; <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include &lt;commdlg.h&gt; <br>#include &lt;shellapi.h&gt; <br>#include &lt;stdarg.h&gt; <br>#include &lt;memory.h&gt; <br>#include "appport.h" <br>#include "app.h" <br>#include "mciapp.h" <br> <br>#include "debug.h" <br> <br> <br>// <br>//  globals, no less <br>// <br>HINSTANCE       ghinst; <br>UINT            gfuAppOptions       = APP_OPTF_YIELDEXEC; <br> <br>TCHAR           gszAppSection[]     = TEXT("MCI App"); <br>TCHAR           gszNull[]           = TEXT(""); <br> <br>TCHAR           gszAppName[APP_MAX_APP_NAME_CHARS]; <br>TCHAR           gszFileUntitled[APP_MAX_FILE_TITLE_CHARS]; <br>TCHAR           gszAppFileTitle[APP_MAX_FILE_TITLE_CHARS]; <br>TCHAR           gszAppFilePath[APP_MAX_FILE_PATH_CHARS]; <br> <br> <br>//==========================================================================; <br>// <br>//  Application helper functions <br>// <br>// <br>//==========================================================================; <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  int AppMsgBox <br>// <br>//  Description: <br>//      This function displays a message for the application in a standard <br>//      message box. <br>// <br>//      Note that this function takes any valid argument list that can <br>//      be passed to wsprintf. Because of this, the application must <br>//      remember to cast near string pointers to FAR when built for Win 16. <br>//      You will get a nice GP fault if you do not cast them correctly. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to parent window for message box holding the <br>//      message. <br>// <br>//      UINT fuStyle: Style flags for MessageBox(). <br>// <br>//      PCTSTR pszFormat: Format string used for wvsprintf(). <br>// <br>//  Return (int): <br>//      The return value is the result of MessageBox() function. <br>// <br>//  History: <br>//       2/13/93    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>int FNCGLOBAL AppMsgBox <br>( <br>    HWND            hwnd, <br>    UINT            fuStyle, <br>    PCTSTR          pszFormat, <br>    ... <br>) <br>{ <br>    va_list     va; <br>    TCHAR       ach[APP_MAX_STRING_ERROR_CHARS]; <br>    int         n; <br> <br>    // <br>    //  format and display the message.. <br>    // <br>    va_start(va, pszFormat); <br>    wvsprintf(ach, pszFormat, va); <br>    va_end(va); <br> <br>    n = MessageBox(hwnd, ach, gszAppName, fuStyle); <br> <br>    return (n); <br>} // AppMsgBox() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  int AppMsgBoxId <br>// <br>//  Description: <br>//      This function displays a message for the application. The message <br>//      text is retrieved from the string resource table using LoadString. <br>// <br>//      Note that this function takes any valid argument list that can <br>//      be passed to wsprintf. Because of this, the application must <br>//      remember to cast near string pointers to FAR when built for Win 16. <br>//      You will get a nice GP fault if you do not cast them correctly. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to parent window for message box holding the <br>//      message. <br>// <br>//      UINT fuStyle: Style flags for MessageBox(). <br>// <br>//      UINT uIdsFormat: String resource id to be loaded with LoadString() <br>//      and used a the format string for wvsprintf(). <br>// <br>//  Return (int): <br>//      The return value is the result of MessageBox() if the string <br>//      resource specified by uIdsFormat is valid. The return value is zero <br>//      if the string resource failed to load. <br>// <br>//  History: <br>//       2/13/93    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>int FNCGLOBAL AppMsgBoxId <br>( <br>    HWND            hwnd, <br>    UINT            fuStyle, <br>    UINT            uIdsFormat, <br>    ... <br>) <br>{ <br>    va_list     va; <br>    TCHAR       szFormat[APP_MAX_STRING_RC_CHARS]; <br>    TCHAR       ach[APP_MAX_STRING_ERROR_CHARS]; <br>    int         n; <br> <br>    n = LoadString(ghinst, uIdsFormat, szFormat, SIZEOF(szFormat)); <br>    if (0 != n) <br>    { <br>        // <br>        //  format and display the message.. <br>        // <br>        va_start(va, uIdsFormat); <br>        wvsprintf(ach, szFormat, va); <br>        va_end(va); <br> <br>        n = MessageBox(hwnd, ach, gszAppName, fuStyle); <br>    } <br> <br>    return (n); <br>} // AppMsgBoxId() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  void AppHourGlass <br>// <br>//  Description: <br>//      This function changes the cursor to that of the hour glass or <br>//      back to the previous cursor. <br>// <br>//      This function can be called recursively. <br>// <br>//  Arguments: <br>//      BOOL fHourGlass: TRUE if we need the hour glass.  FALSE if we need <br>//      the arrow back. <br>// <br>//  Return (void): <br>//      On return, the cursor will be what was requested. <br>// <br>//  History: <br>//      11/ 8/92    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>void FNGLOBAL AppHourGlass <br>( <br>    BOOL            fHourGlass <br>) <br>{ <br>    static HCURSOR  hcur; <br>    static UINT     uWaiting = 0; <br> <br>    if (fHourGlass) <br>    { <br>        if (!uWaiting) <br>        { <br>            hcur = SetCursor(LoadCursor(NULL, IDC_WAIT)); <br>            ShowCursor(TRUE); <br>        } <br> <br>        uWaiting++; <br>    } <br>    else <br>    { <br>        --uWaiting; <br> <br>        if (!uWaiting) <br>        { <br>            ShowCursor(FALSE); <br>            SetCursor(hcur); <br>        } <br>    } <br>} // AppHourGlass() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL AppYield <br>// <br>//  Description: <br>//      This function yields by dispatching all messages stacked up in the <br>//      application queue. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to main window of application if not yielding <br>//      for a dialog. Handle to dialog box if yielding for a dialog box. <br>// <br>//      BOOL fIsDialog: TRUE if being called to yield for a dialog box. <br>// <br>//  Return (BOOL): <br>//      The return value is always TRUE. <br>// <br>//  History: <br>//       2/ 7/93    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNGLOBAL AppYield <br>( <br>    HWND            hwnd, <br>    BOOL            fIsDialog <br>) <br>{ <br>    MSG     msg; <br> <br>    if (fIsDialog) <br>    { <br>        while (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) <br>        { <br>            if ((NULL == hwnd) || !IsDialogMessage(hwnd, &amp;msg)) <br>            { <br>                // <br>                //  see comment below.. <br>                // <br>                MciAppDispatchMessage(GetParent(hwnd), &amp;msg); <br>            } <br>        } <br>    } <br>    else <br>    { <br>        while (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) <br>        { <br>            // <br>            //  normally, we would only do the following here: <br>            // <br>            //      TranslateMessage(&amp;msg); <br>            //      DispatchMessage(&amp;msg); <br>            // <br>            //  but this app is special, so dispatch messages in a <br>            //  special way... <br>            // <br>            MciAppDispatchMessage(hwnd, &amp;msg); <br>        } <br>    } <br> <br>    return (TRUE); <br>} // AppYield() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  int AppSetWindowText <br>// <br>//  Description: <br>//      This function formats a string and sets the specified window text <br>//      to the result. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to window to receive the new text. <br>// <br>//      PCTSTR pszFormat: Pointer to any valid format for wsprintf. <br>// <br>//  Return (int): <br>//      The return value is the number of bytes that the resulting window <br>//      text was. <br>// <br>//  History: <br>//       2/ 7/93    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>int FNCGLOBAL AppSetWindowText <br>( <br>    HWND            hwnd, <br>    PCTSTR          pszFormat, <br>    ... <br>) <br>{ <br>    va_list     va; <br>    TCHAR       ach[APP_MAX_STRING_ERROR_CHARS]; <br>    int         n; <br> <br>    // <br>    //  format and display the string in the window... <br>    // <br>    va_start(va, pszFormat); <br>    n = wvsprintf(ach, pszFormat, va); <br>    va_end(va); <br> <br>    SetWindowText(hwnd, ach); <br> <br>    return (n); <br>} // AppSetWindowText() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  int AppSetWindowTextId <br>// <br>//  Description: <br>//      This function formats a string and sets the specified window text <br>//      to the result. The format string is extracted from the string <br>//      table using LoadString() on the uIdsFormat argument. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to window to receive the new text. <br>// <br>//      UINT uIdsFormat: String resource id to be loaded with LoadString() <br>//      and used a the format string for wvsprintf(). <br>// <br>//  Return (int): <br>//      The return value is the number of bytes that the resulting window <br>//      text was. This value is zero if the LoadString() function fails <br>//      for the uIdsFormat argument. <br>// <br>//  History: <br>//       2/ 7/93    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>int FNCGLOBAL AppSetWindowTextId <br>( <br>    HWND            hwnd, <br>    UINT            uIdsFormat, <br>    ... <br>) <br>{ <br>    va_list     va; <br>    TCHAR       szFormat[APP_MAX_STRING_RC_CHARS]; <br>    TCHAR       ach[APP_MAX_STRING_ERROR_CHARS]; <br>    int         n; <br> <br>    n = LoadString(ghinst, uIdsFormat, szFormat, SIZEOF(szFormat)); <br>    if (0 != n) <br>    { <br>        // <br>        //  format and display the string in the window... <br>        // <br>        va_start(va, uIdsFormat); <br>        n = wvsprintf(ach, szFormat, va); <br>        va_end(va); <br> <br>        SetWindowText(hwnd, ach); <br>    } <br> <br>    return (n); <br>} // AppSetWindowTextId() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL AppGetFileTitle <br>// <br>//  Description: <br>//      This function extracts the file title from a file path and returns <br>//      it in the caller's specified buffer. <br>// <br>//  Arguments: <br>//      PCTSTR pszFilePath: Pointer to null terminated file path. <br>// <br>//      PTSTR pszFileTitle: Pointer to buffer to receive the file title. <br>// <br>//  Return (BOOL): <br>//      Always returns TRUE. But should return FALSE if this function <br>//      checked for bogus values, etc. <br>// <br>//  History: <br>//       2/ 6/93    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNGLOBAL AppGetFileTitle <br>( <br>    PCTSTR          pszFilePath, <br>    PTSTR           pszFileTitle <br>) <br>{ <br>    #define IS_SLASH(c)     ('/' == (c) || '\\' == (c)) <br> <br>    PTSTR       pch; <br> <br>    // <br>    //  scan to the end of the file path string.. <br>    // <br>    for (pch = pszFilePath; '\0' != *pch; pch++) <br>        ; <br> <br>    // <br>    //  now scan back toward the beginning of the string until a slash (\), <br>    //  colon, or start of the string is encountered. <br>    // <br>    while ((pch &gt;= pszFilePath) &amp;&amp; !IS_SLASH(*pch) &amp;&amp; (':' != *pch)) <br>    { <br>        pch--; <br>    } <br> <br>    // <br>    //  finally, copy the 'title' into the destination buffer.. skip ahead <br>    //  one char since the above loop steps back one too many chars... <br>    // <br>    lstrcpy(pszFileTitle, ++pch); <br> <br>    return (TRUE); <br>} // AppGetFileTitle() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL AppGetFileName <br>// <br>//  Description: <br>//      This function is a wrapper for the Get[Open/Save]FileName commdlg <br>//      chooser dialogs. Based on the fuFlags argument, this function will <br>//      display the appropriate chooser dialog and return the result. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to parent window for chooser dialog. <br>// <br>//      PTSTR pszFilePath: Pointer to buffer to receive the file path. <br>// <br>//      PTSTR pszFileTitle: Pointer to buffer to receive the file title. <br>//      This argument may be NULL, in which case no title will be returned. <br>// <br>//      UINT fuFlags: <br>// <br>//  Return (BOOL): <br>//      The return value is TRUE if a file was chosen. It is FALSE if the <br>//      user canceled the operation. <br>// <br>//  History: <br>//       2/ 6/93    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNGLOBAL AppGetFileName <br>( <br>    HWND            hwnd, <br>    PTSTR           pszFilePath, <br>    PTSTR           pszFileTitle, <br>    UINT            fuFlags <br>) <br>{ <br>    #define APP_OFN_FLAGS_SAVE  (OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT) <br>    #define APP_OFN_FLAGS_OPEN  (OFN_HIDEREADONLY | OFN_FILEMUSTEXIST) <br> <br>    TCHAR           szExtDefault[APP_MAX_EXT_DEFAULT_CHARS]; <br>    TCHAR           szExtFilter[APP_MAX_EXT_FILTER_CHARS]; <br>    OPENFILENAME    ofn; <br>    BOOL            f; <br>    PTCHAR          pch; <br> <br> <br>    // <br>    //  get the extension filter and default extension for this application <br>    // <br>    LoadString(ghinst, IDS_OFN_EXT_DEF, szExtDefault, SIZEOF(szExtDefault)); <br>    LoadString(ghinst, IDS_OFN_EXT_FILTER, szExtFilter, SIZEOF(szExtFilter)); <br> <br> <br>    // <br>    //  NOTE! building the filter string for the OPENFILENAME structure <br>    //  is a bit more difficult when dealing with Unicode and C8's new <br>    //  optimizer. it joyfully removes literal '\0' characters from <br>    //  strings that are concatted together. if you try making each <br>    //  string separate (array of pointers to strings), the compiler <br>    //  will dword align them... etc, etc. <br>    // <br>    //  if you can think of a better way to build the silly filter string <br>    //  for common dialogs and still work in Win 16 and Win 32 [Unicode] <br>    //  i'd sure like to hear about it... <br>    // <br>    for (pch = &amp;szExtFilter[0]; '\0' != *pch; pch++) <br>    { <br>        if ('!' == *pch) <br>            *pch = '\0'; <br>    } <br> <br>    // <br>    //  initialize the OPENFILENAME members <br>    // <br>    memset(&amp;ofn, 0, sizeof(OPENFILENAME)); <br> <br>    pszFilePath[0]          = '\0'; <br>    if (pszFileTitle) <br>        pszFileTitle[0]     = '\0'; <br> <br>    ofn.lStructSize         = sizeof(OPENFILENAME); <br>    ofn.hwndOwner           = hwnd; <br>    ofn.lpstrFilter         = szExtFilter; <br>    ofn.lpstrCustomFilter   = NULL; <br>    ofn.nMaxCustFilter      = 0L; <br>    ofn.nFilterIndex        = 1L; <br>    ofn.lpstrFile           = pszFilePath; <br>    ofn.nMaxFile            = APP_MAX_FILE_PATH_CHARS; <br>    ofn.lpstrFileTitle      = pszFileTitle; <br>    ofn.nMaxFileTitle       = pszFileTitle ? APP_MAX_FILE_TITLE_CHARS : 0; <br>    ofn.lpstrInitialDir     = NULL; <br>    ofn.nFileOffset         = 0; <br>    ofn.nFileExtension      = 0; <br>    ofn.lpstrDefExt         = szExtDefault; <br> <br>    // <br>    //  if the fuFlags.APP_GFNF_SAVE bit is set, then call GetSaveFileName() <br>    //  otherwise call GetOpenFileName(). why commdlg was designed with <br>    //  two separate functions for save and open only clark knows. <br>    // <br>    if (fuFlags &amp; APP_GFNF_SAVE) <br>    { <br>        ofn.Flags = APP_OFN_FLAGS_SAVE; <br>        f = GetSaveFileName(&amp;ofn); <br>    } <br>    else <br>    { <br>        ofn.Flags = APP_OFN_FLAGS_OPEN; <br>        f = GetOpenFileName(&amp;ofn); <br>    } <br> <br>    return (f); <br>} // AppGetFileName() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL AppTitle <br>// <br>//  Description: <br>//      This function formats and sets the title text of the application's <br>//      window. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to application window to set title text for. <br>// <br>//      PCTSTR pszFileTitle: Pointer to file title to display. <br>// <br>//  Return (BOOL): <br>//      The return value is always TRUE. <br>// <br>//  History: <br>//       2/ 6/93    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNGLOBAL AppTitle <br>( <br>    HWND            hwnd, <br>    PCTSTR          pszFileTitle <br>) <br>{ <br>    static  TCHAR   szFormatTitle[]     = TEXT("%s - %s"); <br> <br>    TCHAR       ach[APP_MAX_FILE_PATH_CHARS]; <br> <br>    // <br>    //  format the title text as 'AppName - FileTitle' <br>    // <br>    wsprintf(ach, szFormatTitle, (LPSTR)gszAppName, (LPSTR)pszFileTitle); <br>    SetWindowText(hwnd, ach); <br> <br>    return (TRUE); <br>} // AppTitle() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL AppFileNew <br>// <br>//  Description: <br>//      This function is called to handle the IDM_FILE_NEW message. It is <br>//      responsible for clearing the working area for a new unnamed file. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to application window. <br>// <br>//      PTSTR pszFilePath: Pointer to current null terminated file path. <br>//      This buffer will be reinitialized if the function succeeds. <br>// <br>//      PTSTR pszFileTitle: Pointer to current null terminated file title. <br>//      This buffer will be reinitialized if the function succeeds. <br>// <br>//  Return (BOOL): <br>//      The return value is TRUE if the working area was cleared and is <br>//      ready for new stuff. The return value is FALSE if the user canceled <br>//      the operation. <br>// <br>//  History: <br>//       2/ 6/93    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNGLOBAL AppFileNew <br>( <br>    HWND            hwnd, <br>    PTSTR           pszFilePath, <br>    PTSTR           pszFileTitle <br>) <br>{ <br>    BOOL    f; <br> <br>    // <br>    //  if there is currently a file path, then we have to do some real <br>    //  work... <br>    // <br>    if ('\0' != pszFilePath[0]) <br>    { <br>        f = MciAppFileNew(hwnd, pszFilePath, pszFileTitle); <br>        if (!f) <br>            return (FALSE); <br>    } <br> <br>    // <br>    //  blow away the old file path and title; set the window title and <br>    //  return success <br>    // <br>    lstrcpy(pszFilePath,  gszFileUntitled); <br>    lstrcpy(pszFileTitle, gszFileUntitled); <br> <br>    AppTitle(hwnd, pszFileTitle); <br> <br>    MciAppResetStatus(hwnd); <br>    AppSetWindowTextId(GetDlgItem(hwnd, IDD_APP_TEXT_STATUS), <br>                       IDS_MCI_SCRIPT_CREATED, (LPSTR)pszFilePath); <br> <br>    SetFocus(GetDlgItem(hwnd, IDD_APP_EDIT_SCRIPT)); <br> <br>    return (TRUE); <br>} // AppFileNew() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL AppFileOpen <br>// <br>//  Description: <br>//      This function handles the IDM_FILE_OPEN message. It is responsible <br>//      for getting a new file name from the user and opening that file <br>//      if possible. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to application window. <br>// <br>//      PTSTR pszFilePath: Pointer to current null terminated file path. <br>//      This buffer will contain the new file path if one is selected. <br>// <br>//      PTSTR pszFileTitle: Pointer to current null terminated file title. <br>//      This buffer will contain the new file title if one is selected. <br>// <br>//  Return (BOOL): <br>//      The return value is TRUE if a new file was selected and opened. <br>//      It is FALSE if the user canceled the operation. <br>// <br>//  History: <br>//       2/ 6/93    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNLOCAL AppFileOpen <br>( <br>    HWND            hwnd, <br>    PTSTR           pszFilePath, <br>    PTSTR           pszFileTitle <br>) <br>{ <br>    TCHAR       szFilePath[APP_MAX_FILE_PATH_CHARS]; <br>    TCHAR       szFileTitle[APP_MAX_FILE_TITLE_CHARS]; <br>    BOOL        f; <br> <br>    // <br>    //  first test for a modified script that has not been saved. if the <br>    //  return value is FALSE we should cancel the File.Open operation. <br>    // <br>    f = MciAppFileSaveModified(hwnd, pszFilePath, pszFileTitle); <br>    if (!f) <br>        return (FALSE); <br> <br> <br>    // <br>    //  get the file name of the new script into temporary buffers (so <br>    //  if we fail to open it we can back out cleanly). <br>    // <br>    f = AppGetFileName(hwnd, szFilePath, szFileTitle, APP_GFNF_OPEN); <br>    if (!f) <br>        return (FALSE); <br> <br> <br>    // <br>    //  read the new script... <br>    // <br>    f = MciAppFileOpen(hwnd, szFilePath, NULL); <br>    if (f) <br>    { <br>        // <br>        //  copy the new file path and title into the global buffers and <br>        //  set the window title text... <br>        // <br>        lstrcpy(gszAppFilePath,  szFilePath); <br>        lstrcpy(gszAppFileTitle, szFileTitle); <br> <br>        AppTitle(hwnd, szFileTitle); <br>        MciAppResetStatus(hwnd); <br> <br>        AppSetWindowTextId(GetDlgItem(hwnd, IDD_APP_TEXT_STATUS), <br>                           IDS_MCI_SCRIPT_OPENED, (LPSTR)szFilePath); <br> <br>        SetFocus(GetDlgItem(hwnd, IDD_APP_EDIT_SCRIPT)); <br>    } <br> <br>    return (f); <br>} // AppFileOpen() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL AppFileSave <br>// <br>//  Description: <br>//      This function handles the IDM_FILE_SAVE[AS] messages. It is <br>//      responsible for saving the current file. If a file name needs <br>//      to be specified then the save file dialog is displayed. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to application window. <br>// <br>//      PTSTR pszFilePath: Pointer to current null terminated file path. <br>//      This buffer will contain the new file path if one is selected. <br>// <br>//      PTSTR pszFileTitle: Pointer to current null terminated file title. <br>//      This buffer will contain the new file title if one is selected. <br>// <br>//      BOOL fSaveAs: TRUE if the save file chooser should be displayed <br>//      before saving the file. FALSE if should operate like File.Save. <br>// <br>//  Return (BOOL): <br>//      The return value is TRUE if the file was saved. It is FALSE if the <br>//      user canceled the operation or the file does not need saved. <br>// <br>//  History: <br>//       2/ 6/93    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNGLOBAL AppFileSave <br>( <br>    HWND            hwnd, <br>    PTSTR           pszFilePath, <br>    PTSTR           pszFileTitle, <br>    BOOL            fSaveAs <br>) <br>{ <br>    TCHAR       szFilePath[APP_MAX_FILE_PATH_CHARS]; <br>    TCHAR       szFileTitle[APP_MAX_FILE_TITLE_CHARS]; <br>    BOOL        f; <br> <br>    // <br>    //  check if we should bring up the save file chooser dialog... <br>    // <br>    if (fSaveAs || !lstrcmp(pszFileTitle, gszFileUntitled)) <br>    { <br>        // <br>        //  get the file name for saving the script to into temporary <br>        //  buffers (so if we fail to save it we can back out cleanly). <br>        // <br>        f = AppGetFileName(hwnd, szFilePath, szFileTitle, APP_GFNF_SAVE); <br>        if (!f) <br>            return (FALSE); <br>    } <br>    else <br>    { <br>        // <br>        //  copy the file path into our temporary buffer so we don't have <br>        //  to special case this on MciAppFileSave.. <br>        // <br>        lstrcpy(szFilePath,  pszFilePath); <br>        lstrcpy(szFileTitle, pszFileTitle); <br>    } <br> <br>    // <br>    //  save the script... <br>    // <br>    f = MciAppFileSave(hwnd, szFilePath); <br>    if (f) <br>    { <br>        // <br>        //  copy the (possibly) new file path and title into the global <br>        //  buffers and set the window title text... <br>        // <br>        lstrcpy(gszAppFilePath,  szFilePath); <br>        lstrcpy(gszAppFileTitle, szFileTitle); <br> <br>        AppTitle(hwnd, szFileTitle); <br> <br>        // <br>        //  changes have been saved, so clear the modified bit... <br>        // <br>        Edit_SetModify(GetDlgItem(hwnd, IDD_APP_EDIT_SCRIPT), FALSE); <br> <br>        AppSetWindowTextId(GetDlgItem(hwnd, IDD_APP_TEXT_STATUS), <br>                           IDS_MCI_SCRIPT_SAVED, (LPSTR)szFilePath); <br> <br>        SetFocus(GetDlgItem(hwnd, IDD_APP_EDIT_SCRIPT)); <br>    } <br> <br>    return (f); <br>} // AppFileSave() <br> <br> <br>//==========================================================================; <br>// <br>//  Main application window handling code... <br>// <br>// <br>//==========================================================================; <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  LRESULT AppInitMenuPopup <br>// <br>//  Description: <br>//      This function handles the WM_INITMENUPOPUP message. This message <br>//      is sent to the window owning the menu that is going to become <br>//      active. This gives an application the ability to modify the menu <br>//      before it is displayed (disable/add items, etc). <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to window that generated the WM_INITMENUPOPUP <br>//      message. <br>// <br>//      HMENU hmenu: Handle to the menu that is to become active. <br>// <br>//      int nItem: Specifies the zero-based relative position of the menu <br>//      item that invoked the popup menu. <br>// <br>//      BOOL fSysMenu: Specifies whether the popup menu is a System menu <br>//      (TRUE) or it is not a System menu (FALSE). <br>// <br>//  Return (LRESULT): <br>//      Returns zero if the message is processed. <br>// <br>//  History: <br>//       1/ 2/93    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>LRESULT FNLOCAL AppInitMenuPopup <br>( <br>    HWND            hwnd, <br>    HMENU           hmenu, <br>    int             nItem, <br>    BOOL            fSysMenu <br>) <br>{ <br>    BOOL    f; <br>    int     nSelStart; <br>    int     nSelEnd; <br>    HWND    hwndScript; <br> <br>    DPF(0, "AppInitMenuPopup(hwnd=%Xh, hmenu=%Xh, nItem=%d, fSysMenu=%d)", <br>            hwnd, hmenu, nItem, fSysMenu); <br> <br>    // <br>    //  if the system menu is what got hit, succeed immediately... this <br>    //  application has no stuff in the system menu. <br>    // <br>    if (fSysMenu) <br>        return (0L); <br> <br>    // <br>    //  initialize the menu that is being 'popped up' <br>    // <br>    switch (nItem) <br>    { <br>        case APP_MENU_ITEM_FILE: <br>            // <br>            //  if the script has been modified, then enable the File.Save <br>            //  menu <br>            // <br>            hwndScript = GetDlgItem(hwnd, IDD_APP_EDIT_SCRIPT); <br>            f = Edit_GetModify(hwndScript); <br>            EnableMenuItem(hmenu, IDM_FILE_SAVE, <br>                           (UINT)(f ? MF_ENABLED : MF_GRAYED)); <br>            break; <br> <br>        case APP_MENU_ITEM_EDIT: <br>            // <br>            //  check to see if something is selected in the script edit <br>            //  window and enable/disable Edit menu options appropriately <br>            // <br>            hwndScript = GetDlgItem(hwnd, IDD_APP_EDIT_SCRIPT); <br>            Edit_GetSelEx(hwndScript, &amp;nSelStart, &amp;nSelEnd); <br> <br>            f = (nSelStart != nSelEnd); <br>            EnableMenuItem(hmenu, WM_CUT,   (UINT)(f ? MF_ENABLED : MF_GRAYED)); <br>            EnableMenuItem(hmenu, WM_COPY,  (UINT)(f ? MF_ENABLED : MF_GRAYED)); <br>            EnableMenuItem(hmenu, WM_CLEAR, (UINT)(f ? MF_ENABLED : MF_GRAYED)); <br> <br>            f = Edit_CanUndo(hwndScript); <br>            EnableMenuItem(hmenu, WM_UNDO,  (UINT)(f ? MF_ENABLED : MF_GRAYED)); <br> <br>            f = IsClipboardFormatAvailable(CF_TEXT); <br>            EnableMenuItem(hmenu, WM_PASTE, (UINT)(f ? MF_ENABLED : MF_GRAYED)); <br>            break; <br> <br>        case APP_MENU_ITEM_DEVICE: <br>            // <br>            // <br>            // <br>            f = (0 != (gfuAppOptions &amp; APP_OPTF_DEVICELIST)); <br>            CheckMenuItem(hmenu, IDM_DEVICE_OPENLIST, <br>                          (UINT)(f ? MF_CHECKED : MF_UNCHECKED)); <br> <br>            f = (MciAppGetNumDevices(hwnd) != 0); <br>            EnableMenuItem(hmenu, IDM_DEVICE_CLOSEALL, <br>                           (UINT)(f ? MF_ENABLED : MF_GRAYED)); <br>            break; <br> <br>        case APP_MENU_ITEM_OPTIONS: <br>            // <br>            //  make sure the options that need a checkmark are checked.. <br>            // <br>            f = (0 != (gfuAppOptions &amp; APP_OPTF_EDITONLY)); <br>            CheckMenuItem(hmenu, IDM_OPTIONS_EDITONLY, <br>                          (UINT)(f ? MF_CHECKED : MF_UNCHECKED)); <br> <br>            f = (0 != (gfuAppOptions &amp; APP_OPTF_YIELDEXEC)); <br>            CheckMenuItem(hmenu, IDM_OPTIONS_YIELDEXEC, <br>                          (UINT)(f ? MF_CHECKED : MF_UNCHECKED)); <br> <br>            f = (0 != (gfuAppOptions &amp; APP_OPTF_DEBUGLOG)); <br>            CheckMenuItem(hmenu, IDM_OPTIONS_DEBUGLOG, <br>                          (UINT)(f ? MF_CHECKED : MF_UNCHECKED)); <br>            break; <br>    } <br> <br>    // <br>    //  we processed the message--return 0... <br>    // <br>    return (0L); <br>} // AppInitMenuPopup() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  LRESULT AppCommand <br>// <br>//  Description: <br>//      This function handles the WM_COMMAND message. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to window receiving the WM_COMMAND message. <br>// <br>//      int nId: Control or menu item identifier. <br>// <br>//      HWND hwndCtl: Handle of control if the message is from a control. </code></pre>
<p>
</p>
<pre><code>//      This argument is NULL if the message was not generated by a control. <br>// <br>//      UINT uCode: Notification code. This argument is 1 if the message <br>//      was generated by an accelerator. If the message is from a menu, <br>//      this argument is 0. <br>// <br>//  Return (LRESULT): <br>//      Returns zero if the message is processed. <br>// <br>//  History: <br>//      11/ 8/92    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>LRESULT FNLOCAL AppCommand <br>( <br>    HWND            hwnd, <br>    int             nId, <br>    HWND            hwndCtl, <br>    UINT            uCode <br>) <br>{ <br>    BOOL        f; <br> <br>    if (gfExecuting) <br>    { <br>        if ((IDD_ACCL_ABORT == nId) || (IDD_APP_BTN_STOP == nId)) <br>            gfAbortExec = TRUE; <br> <br>        return (0L); <br>    } <br> <br>    switch (nId) <br>    { <br>        case IDM_FILE_NEW: <br>            AppFileNew(hwnd, gszAppFilePath, gszAppFileTitle); <br>            break; <br> <br>        case IDM_FILE_OPEN: <br>            AppFileOpen(hwnd, gszAppFilePath, gszAppFileTitle); <br>            break; <br> <br>        case IDM_FILE_SAVE: <br>            AppFileSave(hwnd, gszAppFilePath, gszAppFileTitle, FALSE); <br>            break; <br> <br>        case IDM_FILE_SAVEAS: <br>            AppFileSave(hwnd, gszAppFilePath, gszAppFileTitle, TRUE); <br>            break; <br> <br>        case IDM_FILE_ABOUT: <br>            DialogBox(ghinst, DLG_ABOUT, hwnd, (DLGPROC)AboutDlgProc); <br>            break; <br> <br>        case IDM_FILE_EXIT: <br>            FORWARD_WM_CLOSE(hwnd, SendMessage); <br>            break; <br> <br> <br>        case WM_UNDO: <br>        case WM_CUT: <br>        case WM_COPY: <br>        case WM_PASTE: <br>        case WM_CLEAR: <br>            // <br>            //  pass edit messages received to the script edit window <br>            // <br>            SendMessage(GetDlgItem(hwnd, IDD_APP_EDIT_SCRIPT), nId, 0, 0L); <br>            break; <br> <br>        case IDM_EDIT_SELECTALL: <br>            Edit_SetSel(GetDlgItem(hwnd, IDD_APP_EDIT_SCRIPT), 0, -1); <br>            break; <br> <br> <br>        case IDM_DEVICE_CLOSEALL: <br>            MciAppCloseAllDevices(hwnd); <br>            break; <br> <br> <br>        case IDM_OPTIONS_EDITONLY: <br>            gfuAppOptions ^= APP_OPTF_EDITONLY; <br>            MciAppUpdateOptions(hwnd); <br>            break; <br> <br>        case IDM_OPTIONS_YIELDEXEC: <br>            gfuAppOptions ^= APP_OPTF_YIELDEXEC; <br>            MciAppUpdateOptions(hwnd); <br>            break; <br> <br>        case IDM_OPTIONS_DEBUGLOG: <br>            gfuAppOptions ^= APP_OPTF_DEBUGLOG; <br>            MciAppUpdateOptions(hwnd); <br>            break; <br> <br>        case IDM_DEVICE_OPENLIST: <br>            // <br>            //  bring up the device list dialog--if this event was triggered <br>            //  by an accelerator (uCode == 1) then do not give the focus <br>            //  to the dialog. if this event was triggered by the user <br>            //  selecting the menu option with the mouse, then give the <br>            //  focus to the device list dialog... <br>            // <br>            gfuAppOptions ^= APP_OPTF_DEVICELIST; <br>            MciAppDeviceList(hwnd, (1 != uCode)); <br>            break; <br> <br>        case IDM_OPTIONS_FONT: <br>            MciAppChooseFont(hwnd); <br>            break; <br> <br> <br>        case IDD_APP_BTN_STEP: <br>            // <br>            //  execute the current line in the script window <br>            // <br>            MciAppSingleStep(hwnd); <br>            break; <br> <br>        case IDD_APP_BTN_RUN: <br>            // <br>            //  execute every line in the script window starting from the <br>            //  _first_ line.. <br>            // <br>            Edit_SetSel(GetDlgItem(hwnd, IDD_APP_EDIT_SCRIPT), 0, 0); <br> <br>            // -- Fall Through -- <br> <br>        case IDD_APP_BTN_GO: <br>            // <br>            //  execute every line in the script window starting from the <br>            //  _current_ line.. <br>            // <br>            f = (0 != (gfuAppOptions &amp; APP_OPTF_YIELDEXEC)); <br>            MciAppExecute(hwnd, f); <br>            break; <br> <br> <br>        case IDOK: <br>            // <br>            //  when we receive an IDOK for the script window (user pressed <br>            //  return key), 'enter' the new line... <br>            // <br>            //  uCode will be 0 if Alt+Enter was pressed, so reverse the <br>            //  logic of the Edit Only option in this case <br>            // <br>            if (GetDlgItem(hwnd, IDD_APP_EDIT_SCRIPT) == hwndCtl) <br>            { <br>                f = (0 != (gfuAppOptions &amp; APP_OPTF_EDITONLY)); <br>                MciAppEnterLine(hwnd, (1 == uCode) ? f : !f); <br>            } <br>            break; <br>    } <br> <br>    return (0L); <br>} // AppCommand() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  LRESULT AppDropFiles <br>// <br>//  Description: <br>//      This function handles the WM_DROPFILES message. This message is <br>//      sent when files are 'dropped' on the window from file manager <br>//      (or other drag/drop servers made by ISV's that figured out the <br>//      undocumented internal workings of the SHELL). <br>// <br>//      A window must be registered to receive these messages either by <br>//      called DragAcceptFiles() or using CreateWindowEx() with the <br>//      WS_EX_ACCEPTFILES style bit. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to window receiving the message. <br>// <br>//      HDROP hdrop: Handle to drop structure. <br>// <br>//  Return (LRESULT): <br>//      Returns 0 if the message is processed. <br>// <br>//  History: <br>//       2/ 8/93    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>LRESULT FNLOCAL AppDropFiles <br>( <br>    HWND            hwnd, <br>    HDROP           hdrop <br>) <br>{ <br>    TCHAR       szFileTitle[APP_MAX_FILE_PATH_CHARS]; <br>    TCHAR       szFilePath[APP_MAX_FILE_PATH_CHARS]; <br>    UINT        uNumFiles; <br>    UINT        u; <br>    BOOL        f; <br>    int         n; <br> <br>    // <br>    //  if executing a script and this message is received, we bail... <br>    //  too much code to fix this... <br>    // <br>    if (gfExecuting) <br>    { <br>        MessageBeep((UINT)-1); <br>        goto App_Drop_Files_Exit; <br>    } <br> <br> <br>    // <br>    //  first test for a modified script that has not been saved. if the <br>    //  return value is FALSE we should cancel the drop operation. <br>    // <br>    f = MciAppFileSaveModified(hwnd, gszAppFilePath, gszAppFileTitle); <br>    if (!f) <br>        goto App_Drop_Files_Exit; <br> <br>    // <br>    //  get number of files dropped on our window <br>    // <br>    uNumFiles = DragQueryFile(hdrop, (UINT)-1, NULL, 0); <br> <br>    DPF(0, "AppDropFiles(hwnd=%Xh, hdrop=%Xh)--uNumFiles=%u", <br>             hwnd, hdrop, uNumFiles); <br> <br>    // <br>    //  step through each file and stop on the one the user wants or <br>    //  the last file (whichever comes first). <br>    // <br>    for (u = 0; u &lt; uNumFiles; u++) <br>    { <br>        // <br>        //  get the next file name and try to open it--if not a valid <br>        //  file, then skip to the next one (if there is one). <br>        // <br>        DragQueryFile(hdrop, u, szFilePath, SIZEOF(szFilePath)); <br> <br> <br>        // <br>        //  attempt to open the file <br>        // <br>        f = MciAppFileOpen(hwnd, szFilePath, szFileTitle); <br>        if (!f) <br>            continue; <br> <br>        // <br>        //  update display info <br>        // <br>        lstrcpy(gszAppFilePath, szFilePath); <br>        lstrcpy(gszAppFileTitle, szFileTitle); <br> <br>        AppTitle(hwnd, szFileTitle); <br>        MciAppResetStatus(hwnd); <br> <br>        AppSetWindowTextId(GetDlgItem(hwnd, IDD_APP_TEXT_STATUS), <br>                           IDS_MCI_SCRIPT_OPENED, (LPSTR)szFilePath); <br> <br> <br>        // <br>        //  if this is NOT the last file in the list of files that are <br>        //  being dropped on us, then bring up a box asking if we should <br>        //  continue or stop where we are.. <br>        // <br>        if ((uNumFiles - 1) != u) <br>        { <br>            n = AppMsgBoxId(hwnd, MB_YESNO | MB_ICONQUESTION | MB_TASKMODAL, <br>                            IDS_DROP_CONTINUE); <br>            if (IDNO == n) <br>                break; <br>        } <br>    } <br> <br>    // <br>    //  tell the shell to release the memory it allocated for beaming <br>    //  the file name(s) over to us... return 0 to show we processed <br>    //  the message. <br>    // <br>App_Drop_Files_Exit: <br> <br>    DragFinish(hdrop); <br>    return (0L); <br>} // AppDropFiles() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  LRESULT AppSize <br>// <br>//  Description: <br>//      This function handles the WM_SIZE message for the application's <br>//      window. This message is sent to the application window after the <br>//      size has changed (but before it is painted). <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to window that generated the WM_SIZE message. <br>// <br>//      UINT fuSizeType: Specifies the type of resizing requested. This <br>//      argument is one of the following: SIZE_MAXIMIZED, SIZE_MINIMIZED, <br>//      SIZE_RESTORED, SIZE_MAXHIDE, or SIZE_MAXSHOW. <br>// <br>//      int nWidth: Width of the new client area for the window. <br>// <br>//      int nHeight: Height of the new client area for the window. <br>// <br>//  Return (LRESULT): <br>//      Returns zero if the application processes the message. <br>// <br>//  History: <br>//       2/ 5/93    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>LRESULT FNLOCAL AppSize <br>( <br>    HWND            hwnd, <br>    UINT            fuSizeType, <br>    int             nWidth, <br>    int             nHeight <br>) <br>{ <br>    HWND    hwndButton; <br>    HWND    hwndOutput; <br>    HWND    hwndScript; <br>    HWND    hwndStatus; <br>    HWND    hwndSeparator; <br>    HWND    hwndNotify; <br>    HWND    hwndOptions; <br>    RECT    rc; <br>    int     nHeightButton; <br>    int     nWidthButton; <br>    int     nHeightScript; <br>    int     nHeightStatus; <br>    int     n, m; <br>    int     nWidthNotify; <br> <br>    DPF(0, "AppSize(hwnd=%Xh, fuSizeType=%u, nWidth=%d, nHeight=%d)", <br>            hwnd, fuSizeType, nWidth, nHeight); <br> <br>    // <br>    //  unless this application is the one being resized then don't waste <br>    //  time computing stuff that doesn't matter. this applies to being <br>    //  minimized also because this application does not have a custom <br>    //  minimized state. <br>    // <br>    if ((SIZE_RESTORED != fuSizeType) &amp;&amp; (SIZE_MAXIMIZED != fuSizeType)) <br>        return (0L); <br> <br>    // <br>    //  for this application, we have three different sections that need <br>    //  to be fit into the newly sized client area--it looks roughly like <br>    //  this: <br>    // <br>    //  +-------------------------------------------+ <br>    //  | - |        MCI App - ZYZSMAG.MCI      |^|v| &lt;- title bar <br>    //  +-------------------------------------------+ <br>    //  | File Edit Options                         | &lt;- menu bar <br>    //  +-------------------------------------------+ <br>    //  |{Step}{ Go }{ Run } Count:[x ] Output: zyz | &lt;- button bar <br>    //  +-------------------------------------------+ <br>    //  | MCI script window                         | &lt;- script window <br>    //  |                                           | <br>    //  |                                           | <br>    //  |                                           | <br>    //  |                                           | <br>    //  |                                           | <br>    //  |                                           | <br>    //  +-------------------------------------------+ <br>    //  | Silly status bar      | Notify: zyz | EYL | &lt;- options status <br>    //  +-------------------------------------------+ <br>    //       ^                  ^   ^ <br>    //       +- status bar      |   +- notify window <br>    //                          | <br>    //                          +----- separator <br>    // <br>    //  the 'button bar' does not have to move or change size (except the <br>    //  width of the output window) <br>    // <br>    //  the 'script window' should fill all space between the bottom of <br>    //  the button bar and the top of the status bar. <br>    // <br>    //  the 'status bar' should sit on the bottom of the window and <br>    //  remain a constant height. <br>    // <br>    //  the 'notify window' should sit on the bottom of the window to the <br>    //  right of the status bar and remain a constant height. <br>    // <br>    //  the 'options status' window should sit in the bottom right corner <br>    //  and remain a constant width and height. <br>    // <br>    //  the 'separators' should be a visible separator between the status <br>    //  bar, notify window, and options status. <br>    // <br> <br>    // <br>    //  first grab handles to all the windows we need to muck with... <br>    // <br>    hwndButton  = GetDlgItem(hwnd, IDD_APP_BTN_GO); <br>    hwndOutput  = GetDlgItem(hwnd, IDD_APP_TEXT_OUTPUT); <br>    hwndScript  = GetDlgItem(hwnd, IDD_APP_EDIT_SCRIPT); <br>    hwndStatus  = GetDlgItem(hwnd, IDD_APP_TEXT_STATUS); <br>    hwndNotify  = GetDlgItem(hwnd, IDD_APP_TEXT_NOTIFY); <br>    hwndOptions = GetDlgItem(hwnd, IDD_APP_TEXT_OPTIONS); <br> <br>    // <br>    //  get the height of the button bar and status bar <br>    // <br>    GetClientRect(hwndButton, &amp;rc); <br>    nHeightButton = (int)(rc.bottom - rc.top); <br>    nWidthButton  = (int)(rc.right - rc.left); <br> <br> <br>    // <br>    //  change width of output window.. <br>    // <br>    GetClientRect(hwndStatus, &amp;rc); <br>    nHeightStatus = (int)(rc.bottom - rc.top); <br> <br>    n = nWidthButton * 6; <br>    m = (nWidth &gt; (n + 2)) ? (nWidth - n - 2) : 0; <br>    rc.top = (nHeightButton - nHeightStatus) / 2; <br>    MoveWindow(hwndOutput, n, (int)rc.top, m, nHeightStatus, TRUE); <br> <br> <br>    // <br>    //  calculate the new height for the script window and move it to just <br>    //  below the bottom of the button bar and above the status bar (which <br>    //  is the height of the button bar)... note that we put the left and <br>    //  right edges of the script window outside of the client area because <br>    //  it looks better that way. <br>    // <br>    nHeightScript = nHeight - (nHeightButton * 2); <br>    if (nHeightScript &lt; 0) <br>        nHeightScript = 0; <br> <br>    MoveWindow(hwndScript, -1, nHeightButton, nWidth + 2, nHeightScript, TRUE); <br> <br> <br>    // <br>    //  put the status bar sitting on top of the bottom of the app window <br>    //  note that we center it in a space that is as high as the button <br>    //  bar so it looks better... it is assumed (correctly) that the button <br>    //  bar is taller than the status bar control. <br>    // <br>    //  ~                                           ~ <br>    //  |                                           | <br>    //  +-------------------------------------------+ <br>    //  | Silly status bar      | Notify: zyz | EYL | <br>    //  +-------------------------------------------+ <br>    //  ^                       ^             ^     ^ <br>    //  +------ min = 20 -------+-min = ~130 -+- 40-+ <br>    // <br>    //  there is pad of 2 on the left and right of each text window (giving <br>    //  a separator a effective width of 5). <br>    // <br>    // <br>    nWidthNotify = (nWidth &lt; (20 + 5 + 130 + 5 + 40)) ? <br>                        (nWidth - (20 + 5 + 5 + 40)) : 130; <br> <br>    hwndSeparator = GetDlgItem(hwnd, IDD_APP_BOX_SEPARATOR1); <br>    MoveWindow(hwndSeparator, nWidth - nWidthNotify - 3 - 5 - 40, <br>                              nHeight - nHeightButton, <br>                              1, nHeightButton, TRUE); <br> <br> <br>    n = nHeightStatus + ((nHeightButton - nHeightStatus) / 2); <br>    MoveWindow(hwndStatus, 2, nHeight - n, <br>                           nWidth - nWidthNotify - 8 - 5 - 40, <br>                           nHeightStatus, TRUE); <br> <br>    MoveWindow(hwndNotify, nWidth - nWidthNotify - 5 - 40, nHeight - n, <br>                           nWidthNotify - 2, nHeightStatus, TRUE); <br> <br>    hwndSeparator = GetDlgItem(hwnd, IDD_APP_BOX_SEPARATOR2); <br>    MoveWindow(hwndSeparator, nWidth - 3 - 40, <br>                              nHeight - nHeightButton, <br>                              1, nHeightButton, TRUE); <br> <br>    MoveWindow(hwndOptions, nWidth - 40, nHeight - n, <br>                           40 - 2, nHeightStatus, TRUE); <br> <br>    // <br>    //  we processed the message.. <br>    // <br>    return (0L); <br>} // AppSize() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  LRESULT AppWndProc <br>// <br>//  Description: <br>//      This is the main application window procedure. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to window. <br>// <br>//      UINT uMsg: Message being sent to the window. <br>// <br>//      WPARAM wParam: Specific argument to message. <br>// <br>//      LPARAM lParam: Specific argument to message. <br>// <br>//  Return (LRESULT): <br>//      The return value depends on the message that is being processed. <br>// <br>//  History: <br>//      11/ 8/92    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>LRESULT FNEXPORT AppWndProc <br>( <br>    HWND            hwnd, <br>    UINT            uMsg, <br>    WPARAM          wParam, <br>    LPARAM          lParam <br>) <br>{ <br>    LRESULT     lr; <br> <br>    switch (uMsg) <br>    { <br>        case WM_CREATE: <br>            lr = HANDLE_WM_CREATE(hwnd, wParam, lParam, AppCreate); <br>            return (lr); <br> <br>        case WM_WININICHANGE: <br>            HANDLE_WM_WININICHANGE(hwnd, wParam, lParam, AppWinIniChange); <br>            return (0L); <br> <br>        case WM_INITMENUPOPUP: <br>            HANDLE_WM_INITMENUPOPUP(hwnd, wParam, lParam, AppInitMenuPopup); <br>            return (0L); <br> <br>        case WM_COMMAND: <br>            lr = HANDLE_WM_COMMAND(hwnd, wParam, lParam, AppCommand); <br>            return (lr); <br> <br>        case WM_DROPFILES: <br>            // <br>            //  some windowsx.h files have a screwed up message cracker for <br>            //  WM_DROPFILES. because this is a sample app, i don't want <br>            //  people having trouble with bogus windowsx.h files, so crack <br>            //  the message manually... you should use the message cracker <br>            //  if you know your windowsx.h file is good. <br>            // <br>            //  lr = HANDLE_WM_DROPFILES(hwnd, wParam, lParam, AppDropFiles); <br>            // <br>            lr = AppDropFiles(hwnd, (HDROP)wParam); <br>            return (lr); <br> <br>        case WM_SIZE: <br>            // <br>            //  handle what we want for sizing, and then always call the <br>            //  default handler... <br>            // <br>            HANDLE_WM_SIZE(hwnd, wParam, lParam, AppSize); <br>            break; <br> <br>        case WM_QUERYENDSESSION: <br>            lr = HANDLE_WM_QUERYENDSESSION(hwnd, wParam, lParam, AppQueryEndSession); <br>            return (lr); <br> <br>        case WM_ENDSESSION: <br>            HANDLE_WM_ENDSESSION(hwnd, wParam, lParam, AppEndSession); <br>            return (0L); <br> <br>        case WM_CLOSE: <br>            HANDLE_WM_CLOSE(hwnd, wParam, lParam, AppClose); <br>            return (0L); <br> <br>        case WM_DESTROY: <br>            PostQuitMessage(0); <br>            return (0L); <br> <br> <br>        case MM_MCINOTIFY: <br>            MciAppHandleNotify(hwnd, wParam, LOWORD(lParam)); <br>            break; <br>    } <br> <br>    return (DefWindowProc(hwnd, uMsg, wParam, lParam)); <br>} // AppWndProc() <br> <br> <br>//==========================================================================; <br>// <br>//  Main entry and message dispatching code <br>// <br>// <br>//==========================================================================; <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  int WinMain <br>// <br>//  Description: <br>//      This function is called by the system as the initial entry point <br>//      for a Windows application. <br>// <br>//  Arguments: <br>//      HINSTANCE hinst: Identifies the current instance of the <br>//      application. <br>// <br>//      HINSTANCE hinstPrev: Identifies the previous instance of the <br>//      application (NULL if first instance). For Win 32, this argument <br>//      is _always_ NULL. <br>// <br>//      LPSTR pszCmdLine: Points to null-terminated unparsed command line. <br>//      This string is strictly ANSI regardless of whether the application <br>//      is built for Unicode. To get the Unicode equivalent call the <br>//      GetCommandLine() function (Win 32 only). <br>// <br>//      int nCmdShow: How the main window for the application is to be <br>//      shown by default. <br>// <br>//  Return (int): <br>//      Returns result from WM_QUIT message (in wParam of MSG structure) if <br>//      the application is able to enter its message loop. Returns 0 if <br>//      the application is not able to enter its message loop. <br>// <br>//  History: <br>//      11/ 8/92    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>int PASCAL WinMain <br>( <br>    HINSTANCE       hinst, <br>    HINSTANCE       hinstPrev, <br>    LPSTR           pszCmdLine, <br>    int             nCmdShow <br>) <br>{ <br>    int     nResult; <br>    HWND    hwnd; <br>    MSG     msg; <br> <br>    // <br>    //  our documentation states that WinMain is supposed to return 0 if <br>    //  we do not enter our message loop--so assume the worst... <br>    // <br>    nResult = 0; <br> <br>    // <br>    //  make our instance handle global for convenience.. <br>    // <br>    ghinst = hinst; <br> <br>    // <br>    //  init some stuff, create window, etc.. note the explicit cast of <br>    //  pszCmdLine--this is to mute a warning (and an ugly ifdef) when <br>    //  compiling for Unicode. see AppInit() for more details. <br>    // <br>    hwnd = AppInit(hinst, hinstPrev, (LPTSTR)pszCmdLine, nCmdShow); <br>    if (hwnd) <br>    { <br>        // <br>        //  dispatch messages <br>        // <br>        while (GetMessage(&amp;msg, NULL, 0, 0)) <br>        { <br>            // <br>            //  do all the special stuff required for this application <br>            //  when dispatching messages.. <br>            // <br>            MciAppDispatchMessage(hwnd, &amp;msg); <br>        } <br> <br>        // <br>        //  return result of WM_QUIT message. <br>        // <br>        nResult = (int)msg.wParam; <br>    } <br> <br>    // <br>    //  shut things down, clean up, etc. <br>    // <br>    nResult = AppExit(hinst, nResult); <br> <br>    return (nResult); <br>} // WinMain() <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
