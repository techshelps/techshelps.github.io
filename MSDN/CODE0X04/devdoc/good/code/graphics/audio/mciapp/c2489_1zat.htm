<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MCIAPP.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2495"></a>MCIAPP.C</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED <br>//  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR <br>//  A PARTICULAR PURPOSE. <br>// <br>//  Copyright 1993 - 1998 Microsoft Corporation. All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br>// <br>//  mciapp.c <br>// <br>//  Description: <br>//      This is a sample application that demonstrates how to use the <br>//      Media Control Interface (MCI) in Windows. This application is <br>//      also useful as an MCI device tester. <br>// <br>//  History: <br>//       2/ 6/93    created. <br>// <br>//==========================================================================; <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include &lt;commdlg.h&gt; <br>#include &lt;stdarg.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br>#include "appport.h" <br>#include "app.h" <br>#include "mciapp.h" <br> <br>#include "debug.h" <br> <br> <br>// <br>// <br>// <br>BOOL            gfExecuting; <br>BOOL            gfAbortExec; <br> <br> <br>HWND            ghwndDevices; <br> <br>TCHAR           gszNone[]           = TEXT("(none)"); <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL MciAppFileSaveModified <br>// <br>//  Description: <br>//      This function tests if the current script has been modified, and <br>//      if it has it gives the option of saving the file. <br>// <br>//      NOTE! This function does *NOT* clear the modified bit for the <br>//      script window. The calling function must do this if necessary. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to main window. <br>// <br>//      PTSTR pszFilePath: Pointer to null terminated file path of current <br>//      script. This buffer will receive the new file path if one is chosen. <br>// <br>//      PTSTR pszFileTitle: Pointer to null terminated file title of <br>//      current script. This buffer will receive the new file title if one <br>//      is chosen. <br>// <br>//  Return (BOOL): <br>//      Returns TRUE if the calling function should continue--the file was <br>//      either saved or the user does not wish to save it. Returns FALSE <br>//      if the calling function should cancel its operation--the user <br>//      wants to keep the data, but it has not been saved. <br>// <br>//  History: <br>//       2/ 6/93    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNGLOBAL MciAppFileSaveModified <br>( <br>    HWND            hwnd, <br>    PTSTR           pszFilePath, <br>    PTSTR           pszFileTitle <br>) <br>{ <br>    BOOL    f; <br>    int     n; <br>    HWND    hwndScript; <br> <br>    // <br>    //  check if the contents of the script window have been modified--if <br>    //  they have then ask the user if they want to save the current <br>    //  contents... <br>    // <br>    hwndScript = GetDlgItem(hwnd, IDD_APP_EDIT_SCRIPT); <br>    f = Edit_GetModify(hwndScript); <br>    if (f) <br>    { <br>        // <br>        //  display an appropriate message box asking for the user's opinion <br>        // <br>        n = AppMsgBoxId(hwnd, MB_YESNOCANCEL | MB_ICONQUESTION| MB_SETFOREGROUND, <br>                        IDS_MCI_SCRIPT_CHANGED, (LPSTR)pszFilePath); <br>        switch (n) <br>        { <br>            case IDYES: <br>                f = AppFileSave(hwnd, pszFilePath, pszFileTitle, FALSE); <br>                if (f) <br>                    break; <br> <br>                // -- fall through -- <br> <br>            case IDCANCEL: <br>                // <br>                //  don't continue! <br>                // <br>                return (FALSE); <br> <br>            case IDNO: <br>                break; <br>        } <br>    } <br> <br>    // <br>    //  ok to continue... <br>    // <br>    return (TRUE); <br>} // MciAppFileSaveModified() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL MciAppFileNew <br>// <br>//  Description: <br>//      This function simply clears the script window. If a modified script <br>//      will be destroyed, then the user is asked if the script should be <br>//      saved first. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to main window. <br>// <br>//      PTSTR pszFilePath: Pointer to null terminated file path of current <br>//      script. This buffer will receive the newly initialized file path. <br>// <br>//      PTSTR pszFileTitle: Pointer to null terminated file title of <br>//      current script. This buffer will receive the newly initialized file <br>//      title. <br>// <br>//  Return (BOOL): <br>//      The return value is TRUE if the script window was cleared. It is <br>//      FALSE if the user canceled the operation. <br>// <br>//  History: <br>//       2/ 6/93    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNGLOBAL MciAppFileNew <br>( <br>    HWND            hwnd, <br>    PTSTR           pszFilePath, <br>    PTSTR           pszFileTitle <br>) <br>{ <br>    BOOL    f; <br>    HWND    hwndScript; <br> <br>    // <br>    //  test for a modified script first... <br>    // <br>    f = MciAppFileSaveModified(hwnd, pszFilePath, pszFileTitle); <br>    if (!f) <br>        return (FALSE); <br> <br>    // <br>    //  blow away all the text and set the modified bit to 'NOT' <br>    // <br>    hwndScript = GetDlgItem(hwnd, IDD_APP_EDIT_SCRIPT); <br>    SetWindowText(hwndScript, gszNull); <br>    Edit_SetModify(hwndScript, FALSE); <br> <br>    // <br>    //  success <br>    // <br>    return (TRUE); <br>} // MciAppFileNew() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL MciAppFileOpen <br>// <br>//  Description: <br>//      This function opens the specified text file and copies the contents <br>//      of the file into the script edit control. <br>// <br>//      NOTE! This function does NOT check for a modified script! It is <br>//      assumed that the calling function took care of everything before <br>//      calling this function. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to main window. <br>// <br>//      PTSTR pszFilePath: Pointer to null terminated file path to open as <br>//      an MCI script. This buffer will be returned with a fully qualified <br>//      path of the file that was opened (if successful). <br>// <br>//      PTSTR pszFileTitle: Pointer to buffer to receive the file title of <br>//      the newly opened file. This buffer does not need to be initialized. <br>// <br>//  Return (BOOL): <br>//      The return value is TRUE if the function is successful. It is FALSE <br>//      if an error occurred. If an error does occur, then the contents <br>//      of the script window, pszFilePath and pszFileTitle will remain <br>//      unchanged. <br>// <br>//  History: <br>//       2/ 6/93    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNGLOBAL MciAppFileOpen <br>( <br>    HWND            hwnd, <br>    PTSTR           pszFilePath, <br>    PTSTR           pszFileTitle <br>) <br>{ <br>#ifdef UNICODE <br>    HANDLE      hf; <br>#else <br>    #define SEEK_SET        0       // flags for _lseek <br>    #define SEEK_CUR        1 <br>    #define SEEK_END        2 <br> <br>    HFILE       hf; <br>    OFSTRUCT    of; <br>#endif <br>    HWND        hwndScript; <br>    UINT        uFileLen; <br>    LPTSTR      psz; <br>    BOOL        fReturn; <br> <br>    // <br>    //  open the file for reading.. <br>    // <br>#ifdef UNICODE <br>    hf = CreateFile(pszFilePath, GENERIC_READ, FILE_SHARE_READ, NULL, <br>                    OPEN_EXISTING, 0, 0); <br>    if (INVALID_HANDLE_VALUE == hf) <br>        return (FALSE); <br>#else <br>    of.cBytes = sizeof(of); <br>    hf = OpenFile(pszFilePath, &amp;of, OF_READ); <br>    if (HFILE_ERROR == hf) <br>        return (FALSE); <br>#endif <br> <br>    // <br>    //  assume the worst <br>    // <br>    fReturn = FALSE; <br> <br>    // <br>    //  determine the length in _bytes_ of the file--note that win 16 is <br>    //  limited to 32k so big files get truncated... improperly. <br>    // <br>    //  !!! need to handle files that are too big better !!! <br>    // <br>#ifdef WIN32 <br>    uFileLen = (UINT)GetFileSize((HANDLE)hf, NULL); <br>#else <br>    uFileLen = (UINT)_llseek(hf, 0L, SEEK_END); <br>    _llseek(hf, 0L, SEEK_SET); <br>#endif <br> <br> <br>    // <br>    //  now read the contents of the file into a buffer--display an hour <br>    //  glass in case the file is large and/or we are reading from a slow <br>    //  device... note that the memory allocation may take some time if <br>    //  the pager is in meltdown mode. <br>    // <br>    AppHourGlass(TRUE); <br>    for (;;) <br>    { <br>        // <br>        //  allocate enough memory to hold the complete image of the file <br>        //  plus one character for good measure (the forced null termination <br>        //  could fault if don't add one char to size). <br>        // <br>        psz = GlobalAllocPtr(GMEM_MOVEABLE, uFileLen + sizeof(TCHAR)); <br>        if (NULL == psz) <br>            break; <br> <br>        // <br>        //  read the file and copy the contents into the script window <br>        // <br>#ifdef UNICODE <br>        fReturn = ReadFile(hf, psz, uFileLen, (LPDWORD)&amp;uFileLen, NULL); <br>        if (!fReturn) <br>            break; <br>#else <br>        uFileLen = _lread(hf, psz, uFileLen); <br>        if ((UINT)-1 == uFileLen) <br>            break; <br>#endif <br> <br>        // <br>        //  make sure the text gets null terminated, then shove it into <br>        //  the script window. <br>        // <br>        psz[uFileLen / sizeof(TCHAR)] = '\0'; <br> <br>        hwndScript = GetDlgItem(hwnd, IDD_APP_EDIT_SCRIPT); <br>#ifdef UNICODE <br>        // <br>        //  determine whether the text is Unicode or ANSI: Unicode files <br>        //  all start with a Byte Order Mark (BOM) that will be 0xFEFF in <br>        //  the proper Endian for the file. <br>        // <br>        //  !!! this application only deals with ANSI and Little Endian <br>        //      Unicode files--should handle more gracefully if not... <br>        // <br>        if ((uFileLen &gt;= sizeof(TCHAR)) &amp;&amp; (psz[0] == 0xFEFF)) <br>        { <br>            // <br>            //  set the window text as Unicode--note that we do not send <br>            //  the BOM, the edit control doesn't want it... <br>            // <br>            gfuAppOptions |= APP_OPTF_UNICODE; <br>            SetWindowTextW(hwndScript, (LPCWSTR)&amp;psz[1]); <br>        } <br>        else <br>        { <br>            gfuAppOptions &amp;= ~APP_OPTF_UNICODE; <br>            SetWindowTextA(hwndScript, (LPCSTR)psz); <br>        } <br>#else <br>        SetWindowText(hwndScript, (LPCTSTR)psz); <br>#endif <br> <br>        // <br>        //  now return the fully qualified path and title for the file <br>        //!!! <br>#ifndef UNICODE <br>        lstrcpy(pszFilePath, of.szPathName); <br>#endif <br>        if (NULL != pszFileTitle) <br>        { <br>            AppGetFileTitle(pszFilePath, pszFileTitle); <br>        } <br> <br>        fReturn = TRUE; <br>        break; <br>    } <br>    AppHourGlass(FALSE); <br> <br> <br>    // <br>    //  free memory (if allocated) and close the file. return the result <br>    //  of our attempt... <br>    // <br>    if (psz) <br>        GlobalFreePtr(psz); <br> <br>#ifdef UNICODE <br>    CloseHandle(hf); <br>#else <br>    _lclose(hf); <br>#endif <br> <br> <br>    // <br>    //  !!! before returning, we really should try to display a error <br>    //      message... memory error, etc.. <br>    // <br>    return (fReturn); <br>} // MciAppFileOpen() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL MciAppFileSave <br>// <br>//  Description: <br>//      This function saves the current script to the specified file. <br>// <br>//      NOTE! This function does NOT bring up a save file chooser dialog <br>//      if the file path is invalid. The calling function is responsible <br>//      for making sure the file path is valid before calling this function. <br>// <br>//      This function also does NOT modify the 'modified' bit of the script <br>//      window. This is up to the calling function. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to main window. <br>// <br>//      PCTSTR pszFilePath: Pointer to null terminated file path to save <br>//      the script to. <br>// <br>//  Return (BOOL): <br>//      The return value is TRUE if the function is successful. It is FALSE <br>//      if an error occurred. If an error does occur, then the contents <br>//      of the script window was not saved. <br>// <br>//  History: <br>//       2/ 6/93    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNGLOBAL MciAppFileSave <br>( <br>    HWND            hwnd, <br>    PCTSTR          pszFilePath <br>) <br>{ <br>#ifdef UNICODE <br>    HANDLE      hf; <br>#else <br>    HFILE       hf; <br>    OFSTRUCT    of; <br>#endif <br>    HWND        hwndScript; <br>    UINT        uFileLen; <br>    DWORD       cbBytes; <br>    LPTSTR      psz; <br>    BOOL        fReturn; <br> <br>    // <br>    //  create the new file--if it already exists, this will open and init <br>    //  it to zero length. <br>    // <br>#ifdef UNICODE <br>    hf = CreateFile(pszFilePath, GENERIC_WRITE, FILE_SHARE_READ, <br>                    NULL, CREATE_ALWAYS, 0, 0); <br>    if (INVALID_HANDLE_VALUE == hf) <br>        return (FALSE); <br>#else <br>    of.cBytes = sizeof(of); <br>    hf = OpenFile(pszFilePath, &amp;of, OF_CREATE); <br>    if (HFILE_ERROR == hf) <br>        return (FALSE); <br>#endif <br> <br>    // <br>    //  assume the worst <br>    // <br>    fReturn = FALSE; <br> <br>    // <br>    //  get the length in bytes of the script--we add 1 to the result <br>    //  because GetWindowTextLength returns the length in bytes NOT including <br>    //  the null terminator. <br>    // <br>    //  !!! UNICODE !!! <br>    // <br>    hwndScript = GetDlgItem(hwnd, IDD_APP_EDIT_SCRIPT); <br>    uFileLen = (UINT)GetWindowTextLength(hwndScript) + 1; <br> <br>    //!!! nFileLen = nFileLen*sizeof(TCHAR);  We write ASCII <br> <br>    // <br>    //  allocate a buffer to hold the script text, get the text, and write <br>    //  it out. display an hour glass in case the file is large and/or we <br>    //  are writing to a slow device... <br>    // <br>    AppHourGlass(TRUE); <br>    for (;;) <br>    { <br>        // <br>        //  allocate enough memory to hold the complete image of the script <br>        // <br>        psz = GlobalAllocPtr(GMEM_MOVEABLE, uFileLen + sizeof(TCHAR)); <br>        if (NULL == psz) <br>            break; <br> <br>        // <br>        //  read the contents of the script window and write it to the <br>        //  new file <br>        // <br>#ifdef UNICODE <br>        // !!!! Save ASCII file <br>        GetWindowTextA(hwndScript, (LPSTR)psz, uFileLen); <br>        WriteFile(hf, psz, uFileLen, &amp;cbBytes, NULL); <br>#else <br>        GetWindowText(hwndScript, (LPTSTR)psz, uFileLen); <br>        cbBytes = (DWORD)_lwrite(hf, (LPSTR)psz, uFileLen); <br>#endif <br> <br>        // <br>        //  succeed <br>        // <br>        fReturn = TRUE; <br>        break; <br>    } <br>    AppHourGlass(FALSE); <br> <br> <br>    // <br>    //  free memory (if allocated) and close the file. return the result <br>    //  of our attempt... <br>    // <br>    if (psz) <br>        GlobalFreePtr(psz); <br> <br>#ifdef UNICODE <br>    CloseHandle(hf); <br>#else <br>    _lclose(hf); <br>#endif <br> <br> <br>    // <br>    //  !!! before returning, we really should try to display an error <br>    //      message... memory error, etc.. <br>    // <br>    return (fReturn); <br>} // MciAppFileSave() <br> <br> <br>//==========================================================================; <br>// <br>//  MCI Device List stuff <br>// <br>// <br>// <br>//==========================================================================; <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  UINT MciAppGetNumDevices <br>// <br>//  Description: <br>//      This function sends a command to MCI querying it as to how many <br>//      devices are currently open in the system. This number is the <br>//      return value. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to main window. <br>// <br>//  Return (UINT): <br>//      Returns the number of currently open MCI devices in the system. <br>// <br>//  History: <br>//       2/ 7/93    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>UINT FNGLOBAL MciAppGetNumDevices <br>( <br>    HWND            hwnd <br>) <br>{ <br>    MCI_SYSINFO_PARMS   msip; <br>    MCIERROR            mciError; <br>    DWORD               dwDevices; <br> <br>    // <br>    //  set things up so that MCI puts the number of open devices directly <br>    //  into dwDevices <br>    // <br>    msip.lpstrReturn = (LPVOID)&amp;dwDevices; <br>    msip.dwRetSize   = sizeof(dwDevices); <br> <br>    // <br>    //  ask MCI how many open devices are in the system--if this errors <br>    //  then return 0... <br>    // <br>    mciError = mciSendCommand(MCI_ALL_DEVICE_ID, <br>                              MCI_SYSINFO, <br>                              MCI_SYSINFO_OPEN | MCI_SYSINFO_QUANTITY, <br>                              (DWORD)(LPVOID)&amp;msip); <br> <br>    if (MMSYSERR_NOERROR == mciError) <br>        return ((UINT)dwDevices); <br> <br>    return (0); <br>} // MciAppGetNumDevices() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL MciAppDeviceListUpdate <br>// <br>//  Description: <br>//      This function updates the MCI Device List window if it is displayed. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to main window. <br>// <br>//      BOOL fForceUpdate: Forces the list to be updated even if number <br>//      of devices has not changed. <br>// <br>//  Return (BOOL): <br>//      Returns TRUE if the device list needed to be updated. FALSE if <br>//      the list was fine... <br>// <br>//  History: <br>//       2/ 7/93    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNLOCAL MciAppDeviceListUpdate <br>( <br>    HWND            hwnd, <br>    HWND            hwndDevices, <br>    BOOL            fForceUpdate <br>) <br>{ <br>    static TCHAR    szFormatDevice[]    = TEXT("%2d. '%s'"); <br>    static UINT     uLastNumDevices; <br> <br>    TCHAR               ach[APP_MAX_STRING_RC_CHARS]; <br>    TCHAR               szDevName[APP_MAX_STRING_RC_CHARS]; <br>    MCI_SYSINFO_PARMS   msip; <br>    MCIERROR            mciError; <br>    HWND                hwndList; <br>    UINT                uNumDevs; <br>    UINT                u; <br> <br>    // <br>    //  if the devices window is not displayed, then fail.. <br>    // <br>    if (NULL == hwndDevices) <br>        return (FALSE); <br> <br>    uNumDevs = MciAppGetNumDevices(hwnd); <br> <br>    // <br>    //  if not being forced to update list, then make a quick check to <br>    //  see if we should update the list... <br>    // <br>    if (!fForceUpdate &amp;&amp; (uNumDevs == uLastNumDevices)) <br>        return (FALSE); <br> <br>    // <br>    //  really update the device list... <br>    // <br>    uLastNumDevices = uNumDevs; <br> <br>    // <br>    //  initialize the devices listbox... <br>    // <br>    hwndList = GetDlgItem(hwndDevices, IDD_MCIDEVS_LIST_OPEN); <br>    ListBox_ResetContent(hwndList); <br> <br>    SetWindowRedraw(hwndList, FALSE); <br> <br>    // <br>    //  get the name of each open device in the system and add it to the <br>    //  device list box... <br>    // <br>    for (u = 1; u &lt;= uNumDevs; ++u) <br>    { <br>        msip.dwNumber    = u; <br>        msip.lpstrReturn = (LPVOID)&amp;szDevName; <br>        msip.dwRetSize   = SIZEOF(szDevName); <br> <br>        // <br>        //  get the name--if an error is encountered, then skip to the <br>        //  next device... <br>        // <br>        mciError = mciSendCommand(MCI_ALL_DEVICE_ID, <br>                                  MCI_SYSINFO, <br>                                  MCI_SYSINFO_OPEN | MCI_SYSINFO_NAME, <br>                                  (DWORD)(LPVOID)&amp;msip); <br> <br>        if (MMSYSERR_NOERROR != mciError) <br>            continue; <br> <br>        // <br>        //  add the device name to the listbox.. <br>        // <br>        wsprintf(ach, szFormatDevice, u, (LPSTR)szDevName); <br>        ListBox_AddString(hwndList, ach); <br>    } <br> <br>    if (0 != uNumDevs) <br>        ListBox_SetCurSel(hwndList, 0); <br> <br>    SetWindowRedraw(hwndList, TRUE); <br>    InvalidateRect(hwndList, NULL, TRUE); <br> <br>    // <br>    //  set the info button to the correct state: enabled if there are <br>    //  devices open--disabled if no devices are open. <br>    // <br>    EnableWindow(GetDlgItem(hwndDevices, IDD_MCIDEVS_BTN_INFO), 0 != uNumDevs); <br> <br>    return (TRUE); <br>} // MciAppDeviceListUpdate() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL MciAppCloseAllDevices <br>// <br>//  Description: <br>//      This function sends the MCI command "close all" and then updates <br>//      the displayed info for the application. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to main window. <br>// <br>//  Return (BOOL): <br>//      Always returns TRUE. <br>// <br>//  History: <br>//       2/ 8/93    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNGLOBAL MciAppCloseAllDevices <br>( <br>    HWND            hwnd <br>) <br>{ <br>    static TCHAR    szCloseAll[]    = TEXT("close all"); <br> <br>    // <br>    //  close all open devices and update the device list if it is being <br>    //  displayed... <br>    // <br>    mciSendString(szCloseAll, NULL, 0, NULL); <br>    MciAppDeviceListUpdate(hwnd, ghwndDevices, FALSE); <br> <br>    return (TRUE); <br>} // MciAppCloseAllDevices() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL MciAppDeviceDlgProc <br>// <br>//  Description: <br>//      Callback function for the dialog box which displays a list of the <br>//      currently opened MCI devices. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to window. <br>// <br>//      UINT uMsg: Message being sent to the window. <br>// <br>//      WPARAM wParam: Specific argument to message. <br>// <br>//      LPARAM lParam: Specific argument to message. <br>// <br>//  Return (BOOL): <br>//      The return value is specific to the message that was received. For <br>//      the most part, it is FALSE if this dialog procedure does not handle <br>//      a message. <br>// <br>//  History: <br>//       2/ 7/93    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNEXPORT MciAppDeviceDlgProc <br>( <br>    HWND            hwnd, <br>    UINT            uMsg, <br>    WPARAM          wParam, <br>    LPARAM          lParam <br>) <br>{ <br>    RECT    rcApp; <br>    RECT    rc; <br>    HFONT   hfont; <br>    HWND    hwndParent; <br>    UINT    u; <br>    int     n; <br> <br>    switch (uMsg) <br>    { <br>        case WM_INITDIALOG: <br>            // <br>            //  move the window so it sits in the upper right corner of the <br>            //  main window by default... <br>            // <br>            GetWindowRect(GetParent(hwnd), &amp;rcApp); <br>            GetWindowRect(hwnd, &amp;rc); <br> <br>            n = (int)(rc.right - rc.left); <br>            rc.left = rcApp.right - n - 30; <br>            MoveWindow(hwnd, (int)rc.left, (int)rc.top, <br>                       n, (int)(rc.bottom - rc.top), FALSE); <br> <br>            // <br>            // <br>            // <br>            hfont = GetStockFont(SYSTEM_FIXED_FONT); <br>            SetWindowFont(GetDlgItem(hwnd, IDD_MCIDEVS_LIST_OPEN), hfont, FALSE); <br> <br>            // <br>            //  update the information displayed in the listbox <br>            // <br>            MciAppDeviceListUpdate(GetParent(hwnd), hwnd, TRUE); <br> <br>            return (TRUE); <br> <br>        case WM_COMMAND: <br>            u = GET_WM_COMMAND_ID(wParam, lParam); <br>            switch (u) <br>            { <br>                case IDCANCEL: <br>                case IDOK: <br>                    // <br>                    //  return button id of the one that was pressed... <br>                    // <br>                    hwndParent = GetParent(hwnd); <br>                    EndDialog(hwnd, u); <br> <br>                    ghwndDevices = NULL; <br>                    gfuAppOptions &amp;= ~APP_OPTF_DEVICELIST; <br>                    SetFocus(GetDlgItem(hwndParent, IDD_APP_EDIT_SCRIPT)); <br>                    break; <br> <br>                case IDD_MCIDEVS_BTN_INFO: <br>                    n = ListBox_GetCurSel(GetDlgItem(hwnd, IDD_MCIDEVS_LIST_OPEN)); <br>                    if (LB_ERR == n) <br>                        break; <br> <br>                    break; <br>            } <br>            break; <br>    } <br> <br>    return (FALSE); <br>} // MciAppDeviceDlgProc() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL MciAppDeviceList <br>// <br>//  Description: <br>//      This function either displays or destroys the MCI device list <br>//      window. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to main window. <br>// <br>//      BOOL fActivate: TRUE if the device list window should keep <br>//      the activation. FALSE if the current active window should remain <br>//      active. <br>// <br>//  Return (BOOL): <br>//      The return value is TRUE if the device list is displayed. It is <br>//      FALSE if the device list has been canceled/closed. <br>// <br>//  History: <br>//       2/ 7/93    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNGLOBAL MciAppDeviceList <br>( <br>    HWND            hwnd, <br>    BOOL            fActivate <br>) <br>{ <br>    HWND        hwndFocus; <br> <br>    // <br>    //  should we display or destroy it? <br>    // <br>    if (0 != (gfuAppOptions &amp; APP_OPTF_DEVICELIST)) <br>    { <br>        if (NULL != ghwndDevices) <br>            return (TRUE); <br> <br>        hwndFocus = GetFocus(); <br> <br>        ghwndDevices = CreateDialog(ghinst, DLG_MCIDEVS, hwnd, (DLGPROC)MciAppDeviceDlgProc); <br>        if (NULL  == ghwndDevices) <br>        { <br>            gfuAppOptions &amp;= ~APP_OPTF_DEVICELIST; <br>            return (FALSE); <br>        } <br> <br>        // <br>        //  note that the window will 'flash' because we used CreateDialog <br>        //  when creating the device list window. we keep the flash to <br>        //  a minimum by creating the device window hidden and then showing <br>        //  it... if you want to get rid of the flash completely, then <br>        //  use CreateWindow and write a lot more code. <br>        // <br>        if (fActivate) <br>        { <br>            ShowWindow(ghwndDevices, SW_SHOW); <br>        } <br>        else <br>        { <br>            SetActiveWindow(hwnd); <br>            SetFocus(hwndFocus); <br>            ShowWindow(ghwndDevices, SW_SHOWNA); <br>        } <br> <br>        return (TRUE); <br>    } <br>    else <br>    { <br>        if (NULL != ghwndDevices) <br>        { <br>            EndDialog(ghwndDevices, IDOK); <br>            ghwndDevices = NULL; <br>        } <br> <br>        return (FALSE); <br>    } <br>} // MciAppDeviceList() <br> <br> <br>//==========================================================================; <br>// <br>// <br>// <br>// <br>//==========================================================================; <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL MciAppUpdateOptions <br>// <br>//  Description: <br>//      This function updates the options status window to reflect the <br>//      current status of the options. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to main window. <br>// <br>//  Return (BOOL): <br>//      Always returns TRUE. <br>// <br>//  History: <br>//       2/ 8/93    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNGLOBAL MciAppUpdateOptions <br>( <br>    HWND            hwnd <br>) <br>{ <br>#ifdef UNICODE <br>    static TCHAR    szFormatOptions[]   = TEXT("%c%c%c%c"); <br>#else <br>    static TCHAR    szFormatOptions[]   = TEXT("%c%c%c"); <br>#endif <br> <br>    TCHAR       ach[APP_MAX_STRING_RC_CHARS]; <br> <br>    // <br>    //  format an appropriate string for the options <br>    // <br>    wsprintf(ach, szFormatOptions, <br>#ifdef UNICODE <br>             (0 != (gfuAppOptions &amp; APP_OPTF_UNICODE))   ? 'U' : '-', <br>#endif <br>             (0 != (gfuAppOptions &amp; APP_OPTF_EDITONLY))  ? 'E' : '-', <br>             (0 != (gfuAppOptions &amp; APP_OPTF_YIELDEXEC)) ? 'Y' : '-', <br>             (0 != (gfuAppOptions &amp; APP_OPTF_DEBUGLOG))  ? 'L' : '-'); <br> <br>    SetWindowText(GetDlgItem(hwnd, IDD_APP_TEXT_OPTIONS), ach); <br> <br>    return (TRUE); <br>} // MciAppUpdateOptions() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL MciAppResetStatus <br>// <br>//  Description: <br>//      This function resets all of the status windows (status, notify, <br>//      and output). This is used when a new script is created/opened. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to main window. <br>// <br>//  Return (BOOL): <br>//      Always returns TRUE. <br>// <br>//  History: <br>//       2/ 7/93    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNGLOBAL MciAppResetStatus <br>( <br>    HWND            hwnd <br>) <br>{ <br>    // <br>    //  nuke all status text... <br>    // <br>    SetWindowText(GetDlgItem(hwnd, IDD_APP_TEXT_OUTPUT), gszNone); <br>    SetWindowText(GetDlgItem(hwnd, IDD_APP_TEXT_STATUS), gszNull); <br>    SetWindowText(GetDlgItem(hwnd, IDD_APP_TEXT_NOTIFY), gszNull); <br> <br>    MciAppUpdateOptions(hwnd); <br> <br>    return (TRUE); <br>} // MciAppResetStatus() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  void MciAppDebugLog <br>// <br>//  Description: <br>//      This function logs information to the debugger if the Debug Log <br>//      option is set. You can then run DBWin (or something similar) <br>//      to redirect the output whereever you want. Very useful for debugging <br>//      MCI drivers. <br>// <br>//  Arguments: <br>//      PCTSTR pszFormat: Pointer to any valid format for wsprintf. <br>// <br>//  Return (void): <br>//      None. <br>// <br>//  History: <br>//       2/ 7/93    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>void FNCGLOBAL MciAppDebugLog <br>( <br>    PCTSTR          pszFormat, <br>    ... <br>) <br>{ <br>    va_list     va; <br>    TCHAR       ach[APP_MAX_STRING_ERROR_CHARS]; <br> <br> <br>    // </code></pre>
<p>
</p>
<pre><code>//  !!! UNICODE !!! <br>    // <br>    // <br>    if (0 != (gfuAppOptions &amp; APP_OPTF_DEBUGLOG)) <br>    { <br>        // <br>        //  format and display the string in a message box... <br>        // <br>        va_start(va, pszFormat); <br>        wvsprintf(ach, pszFormat, va); <br>        va_end(va); <br> <br>        OutputDebugString(gszAppName); <br>        OutputDebugString(TEXT(": ")); <br>        OutputDebugString(ach); <br>        OutputDebugString(TEXT("\r\n")); <br>    } <br>} // MciAppDebugLog() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL MciAppHandleNotify <br>// <br>//  Description: <br>//      This function handles displaying the notification message from <br>//      commands sent with the 'notify' option. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to main window. <br>// <br>//      UINT fuNotify: Notification flags (wParam) from MM_MCINOTIFY message. <br>// <br>//      UINT uId: Device id sending notification. <br>// <br>//  Return (BOOL): <br>//      Always returns TRUE. <br>// <br>//  History: <br>//       2/ 7/93    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNGLOBAL MciAppHandleNotify <br>( <br>    HWND            hwnd, <br>    UINT            fuNotify, <br>    UINT            uId <br>) <br>{ <br>    static TCHAR    szFormatNotify[]        = TEXT("Notify(%u,%u): %s"); <br>    static TCHAR    szDBFormatNotify[]      = TEXT("    MCI Notify: Id=%u, Flag(%u)='%s'"); <br> <br>    HWND        hwndNotify; <br>    TCHAR       ach[APP_MAX_STRING_RC_CHARS]; <br>    UINT        uIds; <br> <br>    // <br>    // <br>    // <br>    // <br>    switch (fuNotify) <br>    { <br>        case MCI_NOTIFY_SUCCESSFUL: <br>            uIds = IDS_MCI_NOTIFY_SUCCESSFUL; <br>            break; <br> <br>        case MCI_NOTIFY_SUPERSEDED: <br>            uIds = IDS_MCI_NOTIFY_SUPERSEDED; <br>            break; <br> <br>        case MCI_NOTIFY_ABORTED: <br>            uIds = IDS_MCI_NOTIFY_ABORTED; <br>            break; <br> <br>        case MCI_NOTIFY_FAILURE: <br>            uIds = IDS_MCI_NOTIFY_FAILURE; <br>            break; <br> <br>        default: <br>            uIds = IDS_MCI_NOTIFY_UNKNOWN; <br>            break; <br>    } <br> <br>    LoadString(ghinst, uIds, ach, SIZEOF(ach)); <br>    hwndNotify = GetDlgItem(hwnd, IDD_APP_TEXT_NOTIFY); <br>    AppSetWindowText(hwndNotify, szFormatNotify, uId, fuNotify, (LPSTR)ach); <br> <br>    // <br>    //  !!! UNICODE !!! <br>    // <br>    MciAppDebugLog(szDBFormatNotify, uId, fuNotify, (LPSTR)ach); <br> <br>    return (TRUE); <br>} // MciAppHandleNotify() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL MciAppErrorDlgProc <br>// <br>//  Description: <br>//      Callback function for the dialog box which occurs during the <br>//      execution of an error in a loop of script commands. It displays <br>//      Abort, Continue and Ignore buttons. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to window. <br>// <br>//      UINT uMsg: Message being sent to the window. <br>// <br>//      WPARAM wParam: Specific argument to message. <br>// <br>//      LPARAM lParam: Specific argument to message. <br>// <br>//  Return (BOOL): <br>//      The return value is specific to the message that was received. For <br>//      the most part, it is FALSE if this dialog procedure does not handle <br>//      a message. <br>// <br>//  History: <br>//       2/ 7/93    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNEXPORT MciAppErrorDlgProc <br>( <br>    HWND            hwnd, <br>    UINT            uMsg, <br>    WPARAM          wParam, <br>    LPARAM          lParam <br>) <br>{ <br>    UINT    u; <br> <br>    switch (uMsg) <br>    { <br>        case WM_INITDIALOG: <br>            return (TRUE); <br> <br>        case WM_COMMAND: <br>            u = GET_WM_COMMAND_ID(wParam, lParam); <br>            switch (u) <br>            { <br>                case IDABORT: <br>                case IDOK: <br>                case IDIGNORE: <br>                    // <br>                    //  return button id of the one that was pressed... <br>                    // <br>                    EndDialog(hwnd, u); <br>                    break; <br>            } <br>            break; <br>    } <br> <br>    return (FALSE); <br>} // MciAppErrorDlgProc() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  MCIERROR MciAppSendString <br>// <br>//  Description: <br>//      Sends the specified string command to an MCI device via the MCI <br>//      string interface. Any return strings from MCI devices are displayed <br>//      in the 'Output' text box. Error values are displayed in the status <br>//      bar. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to main window. <br>// <br>//      PCTSTR pszCommand: Pointer to the string command to be executed. <br>// <br>//  Return (MCIERROR): <br>//      The return value is the result of the mciSendString() function. <br>// <br>//  History: <br>//       2/ 7/93    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>MCIERROR FNGLOBAL MciAppSendString <br>( <br>    HWND            hwnd, <br>    PCTSTR          pszCommand <br>) <br>{ <br>    static TCHAR    szFormatDBSendString[]  = TEXT("mciSendString('%s')"); <br>    static TCHAR    szFormatOutput[]        = TEXT("'%s'"); <br>    static TCHAR    szFormatDBOutput[]      = TEXT("    MCI Output: '%s'"); <br>    static TCHAR    szFormatError[]         = TEXT("MCI Error: [%lu], %s"); <br>    static TCHAR    szFormatDBError[]       = TEXT("    MCI Error : [%lu], '%s'"); <br> <br>    TCHAR       ach[APP_MAX_STRING_ERROR_CHARS]; <br>    HWND        hwndOutput; <br>    HWND        hwndStatus; <br>    MCIERROR    mciError; <br> <br>    // <br>    //  reset the notify window text.. <br>    // <br>    SetWindowText(GetDlgItem(hwnd, IDD_APP_TEXT_NOTIFY), gszNull); <br> <br> <br>    // <br>    //  send the string command to MCI--capture the return value and have <br>    //  the notification code go to the main window (MM_MCINOTIFY)... <br>    // <br>    //  !!! UNICODE !!! <br>    // <br>    MciAppDebugLog(szFormatDBSendString, (LPSTR)pszCommand); <br>    mciError = mciSendString(pszCommand, ach, SIZEOF(ach), hwnd); <br> <br>    // <br>    //  if the command errored, then beep the _speaker_ (-1). don't want <br>    //  to use wave devices because many mci scripts use them.. <br>    // <br>    if (MMSYSERR_NOERROR != mciError) <br>        MessageBeep((UINT)-1); <br> <br>    MciAppDebugLog(szFormatDBOutput, (LPSTR)ach); <br> <br>    // <br>    //  put the text message returned by MCI into the 'Output' box <br>    // <br>    hwndOutput = GetDlgItem(hwnd, IDD_APP_TEXT_OUTPUT); <br>    if ('\0' == ach[0]) <br>        SetWindowText(hwndOutput, gszNone); <br>    else <br>        AppSetWindowText(hwndOutput, szFormatOutput, (LPSTR)ach); <br> <br> <br>    // <br>    //  decode the error number returned by MCI and display the string in <br>    //  the status bar... <br>    // <br>    //  !!! UNICODE !!! <br>    // <br>    mciGetErrorString(mciError, ach, SIZEOF(ach)); <br>    MciAppDebugLog(szFormatDBError, mciError, (LPSTR)ach); <br> <br>    hwndStatus = GetDlgItem(hwnd, IDD_APP_TEXT_STATUS); <br>    AppSetWindowText(hwndStatus, szFormatError, mciError, (LPSTR)ach); <br> <br> <br>    // <br>    //  update our list of currently open devices and stuff... <br>    // <br>    MciAppDeviceListUpdate(hwnd, ghwndDevices, FALSE); <br> <br>    return (mciError); <br>} // MciAppSendString() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL MciAppGetLine <br>// <br>//  Description: <br>//      Retrieves the contents of line (uLine) from the script window. <br>//      The string is placed in the pszLineBuffer. All leading and trailing <br>//      spaces (and comments) are removed. <br>// <br>//  Arguments: <br>//      HWND hwndScript: Handle to script window (multiline edit control) <br>//      to extract nLine from. <br>// <br>//      int nLine: Line index (zero based) to retrieve. <br>// <br>//      PTSTR pszBuffer: Pointer to string buffer to receive nLine's <br>//      contents. <br>// <br>//      UINT cchBuffer: Size of pszBuffer is _characters_. <br>// <br>//  Return (BOOL): <br>//      The return value is TRUE if nLine was extracted from the script <br>//      window. The return value is FALSE if nLine is out of range for <br>//      the current contents of the script window. <br>// <br>//  History: <br>//       2/ 7/93    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNLOCAL MciAppGetLine <br>( <br>    HWND            hwndScript, <br>    int             nLine, <br>    PTSTR           pszBuffer, <br>    UINT            cchBuffer <br>) <br>{ <br>    #define IS_SPACE(c)     (' '  == (c) || '\t' == (c)) <br>    #define IS_EOL(c)       ('\n' == (c) || '\r' == (c)) <br>    #define IS_WHITE(c)     (IS_SPACE(c) || IS_EOL(c)) <br> <br>    int     nNumLines; <br> <br>    // <br>    //  find out how many lines are in the script window--if it is out of <br>    //  range then fail.... <br>    // <br>    nNumLines = Edit_GetLineCount(hwndScript); <br>    if ((nLine &lt; 0) || (nLine &gt;= nNumLines)) <br>    { <br>        pszBuffer[0] = '\0'; <br>        return (FALSE); <br>    } <br> <br>    // <br>    //  read the line requested into the string buffer.. <br>    // <br>    cchBuffer = Edit_GetLine(hwndScript, nLine, pszBuffer, cchBuffer); <br> <br> <br>    // <br>    //  strip trailing spaces <br>    // <br>    while ((cchBuffer &gt; 0) &amp;&amp; IS_WHITE(pszBuffer[cchBuffer - 1])) <br>    { <br>        cchBuffer--; <br>    } <br> <br>    pszBuffer[cchBuffer] = '\0'; <br> <br>    return (TRUE); <br>} // MciAppGetLine() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL MciAppInternalCommand <br>// <br>//  Description: <br>// <br>// <br>//  Arguments: <br>// <br>// <br>//  Return (BOOL): <br>// <br>// <br>//  History: <br>//       2/20/93    created.  <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNLOCAL MciAppInternalCommand <br>( <br>    HWND            hwnd, <br>    PTSTR           pszCommandLine, <br>    BOOL            fYield <br>) <br>{ <br>    static TCHAR    szWhiteToken[]      = " \t\n"; <br>    static TCHAR    szTokenSleep[]      = "sleep"; <br>    static TCHAR    szTokenPause[]      = "pause"; <br> <br>    static TCHAR    szFormatError[]     = TEXT("INTERNAL Error: Command (%s), %s."); <br>    static TCHAR    szFormatDBError[]   = TEXT("    ICmd Error: Command (%s), %s."); <br> <br>    static TCHAR    szSleepComplete[]   = TEXT("Sleep complete."); <br>    static TCHAR    szSleepDBComplete[] = TEXT("      Sleeping:  sleep complete."); <br> <br>    static TCHAR    szErrorBadCmd[]     = TEXT("unrecognized command"); <br>    static TCHAR    szErrorBadParam[]   = TEXT("invalid parameter"); <br>    static TCHAR    szErrorParamRqd[]   = TEXT("parameter(s) required"); <br> <br>    static TCHAR    szFormatSleeping[]  = TEXT("Sleeping for %lu %s..."); <br>    static TCHAR    szSeconds[]         = TEXT("seconds"); <br>    static TCHAR    szMilliseconds[]    = TEXT("milliseconds"); <br>    static TCHAR    szMinutes[]         = TEXT("minutes"); <br>    static TCHAR    szHours[]           = TEXT("hours"); <br> <br>    PTSTR       pchToken; <br>    PTSTR       pchCommand; <br>    HWND        hwndStatus; <br>    long        l; <br>    DWORD       dwSleep; <br>    PTSTR       szSleepUnit; <br> <br>    // <br>    //  parse the internal command line... <br>    // <br>    pchToken = strtok(pszCommandLine, szWhiteToken); <br>    if (NULL == pchToken) <br>        return (TRUE); <br> <br>    hwndStatus = GetDlgItem(hwnd, IDD_APP_TEXT_STATUS); <br>    pchCommand = pchToken; <br> <br>//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; <br>// <br>//  sleep x [ms | s | m | h]        (default is milliseconds) <br>//  pause x [ms | s | m | h]        (default is milliseconds) <br>// <br>// <br>//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; <br> <br>    if ((0 == lstrcmpi(pchCommand, szTokenSleep)) || <br>        (0 == lstrcmpi(pchCommand, szTokenPause))) <br>    { <br>        pchToken = strtok(NULL, szWhiteToken); <br>        if (NULL == pchToken) <br>        { <br>            MessageBeep((UINT)-1); <br>            AppSetWindowText(hwndStatus, szFormatError, <br>                             (LPSTR)pchCommand, (LPSTR)szErrorParamRqd); <br>            MciAppDebugLog(szFormatDBError, (LPSTR)pchCommand, <br>                           (LPSTR)szErrorParamRqd); <br>            return (TRUE); <br>        } <br> <br>        // <br>        //  assume the first token after sleep/pause command is a <br>        //  number--do not allow zero or negative numbers! <br>        // <br>        l = atol(pchToken); <br>        if (0 &gt;= l) <br>        { <br>            MessageBeep((UINT)-1); <br>            AppSetWindowText(hwndStatus, szFormatError, <br>                             (LPSTR)pchCommand, (LPSTR)szErrorBadParam); <br>            MciAppDebugLog(szFormatDBError, (LPSTR)pchCommand, <br>                           (LPSTR)szErrorBadParam); <br>            return (TRUE); <br>        } <br> <br>        // <br>        //  now see what unit <br>        // <br>        dwSleep     = (DWORD)l; <br>        szSleepUnit = szMilliseconds; <br>        pchToken    = strtok(NULL, szWhiteToken); <br>        if (NULL != pchToken) <br>        { <br>            switch (pchToken[0]) <br>            { <br>                case 's': <br>                case 'S': <br>                    dwSleep *= 1000; <br>                    szSleepUnit = szSeconds; <br>                    break; <br> <br>                case 'm': <br>                case 'M': <br>                    // <br>                    //  if unit marker is not 'ms' then assume minutes <br>                    // <br>                    if ('s' != pchToken[1]) <br>                    { <br>                        dwSleep *= 1000L * 60; <br>                        szSleepUnit = szMinutes; <br>                    } <br>                    break; <br> <br>                case 'h': <br>                case 'H': <br>                    dwSleep *= 1000L * 60 * 60; <br>                    szSleepUnit = szHours; <br>                    break; <br>            } <br>        } <br> <br>        // <br>        // <br>        // <br>        AppSetWindowText(hwndStatus, szFormatSleeping, l, (LPSTR)szSleepUnit); <br>        MciAppDebugLog(szFormatSleeping, l, (LPSTR)szSleepUnit); <br> <br>        if (!fYield) <br>            UpdateWindow(hwndStatus); <br> <br>        // <br>        //  !!! broken !!! <br>        // <br>        // <br>#ifdef WIN32 <br>        Sleep(dwSleep); <br>#else <br>{ <br>        DWORD   dwStart; <br> <br>        if (!fYield) <br>            AppHourGlass(TRUE); <br> <br>        dwStart = timeGetTime(); <br>        while ((timeGetTime() - dwStart) &lt; dwSleep) <br>        { <br>            if (fYield) <br>            { <br>                AppYield(hwnd, FALSE); <br>                if (gfAbortExec) <br>                    break; <br>            } <br>            else <br>            { <br>                if (GetAsyncKeyState(VK_ESCAPE) &lt; 0) <br>                    break; <br>            } <br>        } <br> <br>        if (!fYield) <br>            AppHourGlass(FALSE); <br>} <br>#endif <br>         <br>        AppSetWindowText(hwndStatus, szSleepComplete); <br>        MciAppDebugLog(szSleepDBComplete); <br> <br>        if (!fYield) <br>            UpdateWindow(hwndStatus); <br> <br>        return (TRUE); <br>    } <br> <br> <br>//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; <br>// <br>//  unrecognized command... <br>// <br>// <br>//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; <br> <br>    MessageBeep((UINT)-1); <br>    AppSetWindowText(hwndStatus, szFormatError, <br>                     (LPSTR)pchCommand, (LPSTR)szErrorBadCmd); <br>    MciAppDebugLog(szFormatDBError, (LPSTR)pchCommand, (LPSTR)szErrorBadCmd); <br> <br>    return (TRUE); <br>} // MciAppInternalCommand() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  MCIERROR MciAppSingleStep <br>// <br>//  Description: <br>//      Executes one line from the script window. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to main window. <br>// <br>//  Return (MCIERROR): <br>//      The return value is the MCIERROR return value from mciSendString. <br>// <br>//  History: <br>//       2/ 7/93    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>MCIERROR FNGLOBAL MciAppSingleStep <br>( <br>    HWND            hwnd <br>) <br>{ <br>    TCHAR       ach[APP_MAX_STRING_ERROR_CHARS]; <br>    HWND        hwndScript; <br>    int         nLine; <br>    int         nLineStart; <br>    int         nSelStart; <br>    int         nSelEnd; <br>    MCIERROR    mciError; <br>    BOOL        fDidOne; <br> <br>    // <br>    //  initialize a bunch of stuff... <br>    // <br>    hwndScript = GetDlgItem(hwnd, IDD_APP_EDIT_SCRIPT); <br>    mciError   = MMSYSERR_NOERROR; <br>    fDidOne    = FALSE; <br>    nLineStart = Edit_LineFromChar(hwndScript, -1); <br>    nLine      = nLineStart; <br> <br>    // <br>    //  step through the script starting with the current line until we <br>    //  execute one non-comment/blank line... <br>    // <br>    for ( ; MciAppGetLine(hwndScript, nLine, ach, SIZEOF(ach)); nLine++) <br>    { <br>        // <br>        //  select the current line that is going to be executed.... <br>        // <br>        nSelStart = Edit_LineIndex(hwndScript, nLine); <br>        nSelEnd   = Edit_LineIndex(hwndScript, nLine + 1); <br>        if (nSelEnd &lt; nSelStart) <br>            nSelEnd = 0x7FFF; <br>        else if (nSelEnd &gt; nSelStart) <br>            nSelEnd -= 1; <br> <br>        Edit_SetSel(hwndScript, nSelStart, nSelEnd); <br> <br>        // <br>        //  anything worth doing something with? <br>        // <br>        if (('\0' == ach[0]) || (';' == ach[0])) <br>            continue; <br> <br>        // <br>        //  if first character is '!' then process rest of line as an <br>        //  internale MCI App command... <br>        // <br>        if ('!' == ach[0]) <br>        { <br>            MciAppInternalCommand(hwnd, &amp;ach[1], FALSE); <br>            continue; <br>        } <br> <br>        // <br>        //  if we have actually executed a line, then break out... we do <br>        //  this so the above code will have selected the next line for <br>        //  single stepping. <br>        // <br>        if (fDidOne) <br>            break; <br> <br> <br>        // <br>        //  send the command on the current line to MCI via the string <br>        //  interface. <br>        // <br>        mciError = MciAppSendString(hwnd, ach); <br>        fDidOne  = TRUE; <br>    } <br> <br>    SetFocus(hwndScript); <br>    return (mciError); <br>} // MciAppSingleStep() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  MCIERROR MciAppExecute <br>// <br>//  Description: <br>//      Executes the MCI command which is currently selected in the script <br>//      window. If fSingleStep is TRUE, then only this one line will be <br>//      executed. Otherwise, every line from the currently selected line to <br>//      the last line in the script window will be executed sequentially. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to main window. <br>// <br>//      BOOL fYield: TRUE if execution should yield between MCI commands. <br>// <br>//  Return (MCIERROR): <br>//      The return value is the last MCIERROR return value from executing. <br>// <br>//  History: <br>//       2/ 7/93    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>MCIERROR FNGLOBAL MciAppExecute <br>( <br>    HWND            hwnd, <br>    BOOL            fYield <br>) <br>{ <br>    static TCHAR    szFormatRuncount[]     = TEXT("%u"); <br> <br>    TCHAR       ach[APP_MAX_STRING_ERROR_CHARS]; <br>    HWND        hwndScript; <br>    HWND        hwndRuncount; <br>    UINT        uRunCount; <br>    UINT        u; <br>    UINT        uLinesExecuted; <br>    int         n; <br>    int         nLine; <br>    int         nLineStart; <br>    int         nSelStart; <br>    int         nSelEnd; <br>    MCIERROR    mciError; <br>    BOOL        fIgnoreErrors; <br> <br> <br>    hwndScript   = GetDlgItem(hwnd, IDD_APP_EDIT_SCRIPT); <br>    hwndRuncount = GetDlgItem(hwnd, IDD_APP_EDIT_RUNCOUNT); <br> <br>    uRunCount  = GetDlgItemInt(hwnd, IDD_APP_EDIT_RUNCOUNT, NULL, TRUE); <br> <br>    uLinesExecuted = 0; <br>    mciError       = MMSYSERR_NOERROR; <br>    fIgnoreErrors  = FALSE; <br> <br>    gfExecuting    = TRUE; <br>    gfAbortExec    = FALSE; <br> <br> <br>    // <br>    //  if we are yielding, then disable a bunch of controls... <br>    // <br>    //  if we are not yielding during then bring up an hour glass to show <br>    //  we be busy... don't bother with disabling controls--they can't <br>    //  be used <br>    // <br>    if (fYield) <br>    { <br>        static TCHAR    szButtonStop[]  = TEXT("&amp;Stop"); <br> <br>        SetWindowText(GetDlgItem(hwnd, IDD_APP_BTN_STEP), szButtonStop); <br> <br>        EnableWindow(GetDlgItem(hwnd, IDD_APP_BTN_GO),        FALSE); <br>        EnableWindow(GetDlgItem(hwnd, IDD_APP_BTN_RUN),       FALSE); <br>        EnableWindow(GetDlgItem(hwnd, IDD_APP_EDIT_RUNCOUNT), FALSE); <br>    } <br>    else <br>    { <br>        AppHourGlass(TRUE); <br>    } <br> <br> <br>    // <br>    //  go through every line in the script window from the currently <br>    //  selected line to the last line... <br>    // <br>    nLineStart = Edit_LineFromChar(hwndScript, -1); <br>    for (u = uRunCount; u; u--) <br>    { <br>        nLine = nLineStart; <br>        for ( ; MciAppGetLine(hwndScript, nLine, ach, SIZEOF(ach)); nLine++) <br>        { <br>            // <br>            //  select the current line that is going to be executed.... <br>            // <br>            nSelStart = Edit_LineIndex(hwndScript, nLine); <br>            nSelEnd   = Edit_LineIndex(hwndScript, nLine + 1); <br>            if (nSelEnd &lt; nSelStart) <br>                nSelEnd = 0x7FFF; <br>            else if (nSelEnd &gt; nSelStart) <br>                nSelEnd -= 1; <br> <br>            Edit_SetSel(hwndScript, nSelStart, nSelEnd); <br> <br> <br>            // <br>            //  check for abort... <br>            // <br>            if (gfAbortExec) <br>            { <br>                n = AppMsgBoxId(hwnd, MB_YESNO | MB_ICONQUESTION | MB_TASKMODAL, <br>                                IDS_EXEC_ABORT); <br>                if (IDYES == n) <br>                    goto MciApp_Execute_Exit; <br> <br>                gfAbortExec = FALSE; <br>            } <br> <br> <br>            // <br>            //  anything worth doing something with? <br>            // <br>            if (('\0' == ach[0]) || (';' == ach[0])) <br>                continue; <br> <br>            // <br>            //  if first character is '!' then process rest of line as an <br>            //  internale MCI App command... <br>            // <br>            if ('!' == ach[0]) <br>            { <br>                MciAppInternalCommand(hwnd, &amp;ach[1], fYield); <br>                continue; <br>            } <br> <br>            // <br>            //  send the command on the current line to MCI via the string <br>            //  interface. <br>            // <br>            mciError = MciAppSendString(hwnd, ach); <br>            if ((MMSYSERR_NOERROR != mciError) &amp;&amp; !fIgnoreErrors) <br>            { <br>                n = DialogBox(ghinst, DLG_MCIERR, hwnd, (DLGPROC)MciAppErrorDlgProc); <br>                switch (n) <br>                { <br>                    case IDABORT: <br>                        goto MciApp_Execute_Exit; <br> <br>                    case IDIGNORE: <br>                        fIgnoreErrors = TRUE; <br>                        break; <br>                } <br>            } <br> <br>            uLinesExecuted++; <br> <br>            // <br>            //  yield like a good little app.. <br>            // <br>            if (fYield) <br>                AppYield(hwnd, FALSE); <br>            else <br>            { <br>                UpdateWindow(GetDlgItem(hwnd, IDD_APP_TEXT_STATUS)); <br>                UpdateWindow(GetDlgItem(hwnd, IDD_APP_TEXT_OUTPUT)); <br>            } <br>        } <br> <br>        // <br>        //  SetDlgItemInt() won't update the field unless we yield <br>        //  so set window text instead... in case not yielding. <br>        // <br>        SetDlgItemInt(hwnd, IDD_APP_EDIT_RUNCOUNT, u, TRUE); <br>        if (fYield) <br>            AppYield(hwnd, FALSE); <br>        else <br>            UpdateWindow(GetDlgItem(hwnd, IDD_APP_EDIT_RUNCOUNT)); <br>    } <br> <br> <br>MciApp_Execute_Exit: <br> <br>    gfExecuting = FALSE; <br>    if (fYield) <br>    { <br>        static TCHAR    szButtonStep[]  = TEXT("&amp;Step"); <br> <br>        SetWindowText(GetDlgItem(hwnd, IDD_APP_BTN_STEP), szButtonStep); <br> <br>        EnableWindow(GetDlgItem(hwnd, IDD_APP_BTN_GO),        TRUE); <br>        EnableWindow(GetDlgItem(hwnd, IDD_APP_BTN_RUN),       TRUE); <br>        EnableWindow(GetDlgItem(hwnd, IDD_APP_EDIT_RUNCOUNT), TRUE); <br>    } <br>    else <br>    { <br>        AppHourGlass(FALSE); <br>    } <br> <br>    SetDlgItemInt(hwnd, IDD_APP_EDIT_RUNCOUNT, uRunCount, TRUE); <br>    SetFocus(hwndScript); <br> <br>    return (mciError); <br>} // MciAppExecute() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL MciAppEnterLine <br>// <br>//  Description: <br>//      This function handles entering a new line into the script window. <br>//      This may involve executing the new line if Options.Edit Only is <br>//      not selected. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to main window. <br>// <br>//      BOOL fEditOnly: TRUE if in data entry mode (won't single step the <br>//      current line before inserting CR/LF). FALSE if the current line <br>//      should be executed and a CR/LF inserted at the _END_ of the <br>//      current line. <br>// <br>//  Return (BOOL): <br>//      The return value is always TRUE. <br>// <br>//  History: <br>//       2/ 7/93    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNGLOBAL MciAppEnterLine <br>( <br>    HWND            hwnd, <br>    BOOL            fEditOnly <br>) <br>{ <br>    static TCHAR    szEOL[]     = TEXT("\r\n"); <br> <br>    HWND    hwndScript; <br>    int     n; <br> <br>    hwndScript = GetDlgItem(hwnd, IDD_APP_EDIT_SCRIPT); <br> <br>    // <br>    //  if Options.Edit Only is checked or the user pressed Alt+Enter, <br>    //  then act like a simple edit control... <br>    // <br>    if (fEditOnly) <br>    { <br>        Edit_ReplaceSel(hwndScript, szEOL); <br>        return (TRUE); <br>    } <br> <br>    // <br>    //  get current line (containing caret)--if there is a <br>    //  selection, the line number of the line containing the <br>    //  _beginning_ of the selection is retrieved. <br>    // <br>    SetFocus(hwndScript); <br>    n = Edit_LineFromChar(hwndScript, -1); <br>    MciAppSingleStep(hwnd); <br>    n = Edit_LineIndex(hwndScript, n); <br>    Edit_SetSel(hwndScript, n, n); <br> <br>    // <br>    //  now force CR/LF at the _end_ of the current line <br>    // <br>    FORWARD_WM_KEYDOWN(hwndScript, VK_END, 1, 0, SendMessage); <br>    FORWARD_WM_KEYUP(hwndScript, VK_END, 1, 0, SendMessage); <br>    Edit_ReplaceSel(hwndScript, szEOL); <br> <br>    return (TRUE); <br>} // MciAppEnterLine() <br> <br> <br>//==========================================================================; <br>// <br>// <br>// <br>// <br>//==========================================================================; <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL MciAppDispatchMessage <br>// <br>//  Description: <br>// <br>// <br>//  Arguments: <br>// <br>// <br>//  Return (BOOL): <br>// <br>// <br>//  History: <br>//       2/ 8/93    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNGLOBAL MciAppDispatchMessage <br>( <br>    HWND            hwnd, <br>    PMSG            pmsg <br>) <br>{ <br>    static HWND     hwndScript; <br>    static HACCEL   haccl; <br> <br>    UINT        u; <br> <br>    // <br>    //  if this is the first time through, cache some stuff... <br>    // <br>    if (NULL == hwndScript) <br>        hwndScript = GetDlgItem(hwnd, IDD_APP_EDIT_SCRIPT); <br> <br>    if (NULL == haccl) <br>        haccl = LoadAccelerators(ghinst, ACCEL_APP); <br> <br> <br>    // <br>    //  peek at the message being sent. if it is one of the special <br>    //  things for the script window, then deal with it... <br>    // <br>    //  !!! this is somewhat bogus !!! <br>    // <br>    if ((WM_KEYDOWN == pmsg-&gt;message) || (WM_SYSKEYDOWN == pmsg-&gt;message)) <br>    { <br>        if (GetActiveWindow() != hwnd) <br>            goto MciApp_Dispatch_Continue; <br> <br>        switch (pmsg-&gt;wParam) <br>        { <br>            case VK_RETURN: <br>                if (GetFocus() != hwndScript) <br>                    break; <br> <br>                // <br>                //  force a line to be 'executed' and stuff... if Alt+Enter <br>                //  was used, then reverse the logic of 'Edit Only' by <br>                //  setting uCode to 0 (from menu) <br>                // <br>                u = (GetKeyState(VK_MENU) &lt; 0) ? 0 : 1; <br>                FORWARD_WM_COMMAND(hwnd, IDOK, hwndScript, u, PostMessage); <br>                return (TRUE); <br> <br>            case VK_TAB: <br>                if (WM_SYSKEYDOWN == pmsg-&gt;message) <br>                    break; <br> <br>                if (GetKeyState(VK_CONTROL) &lt; 0) <br>                { <br>                    if (GetFocus() == hwndScript) <br>                    { <br>                        SetFocus(GetDlgItem(hwnd, IDD_APP_BTN_STEP)); <br>                        return (TRUE); <br>                    } <br> <br>                    SetFocus(GetDlgItem(hwnd, IDD_APP_EDIT_SCRIPT)); <br>                    return (TRUE); <br>                } <br>                else if (GetFocus() == hwndScript) <br>                { <br>                    static TCHAR    szTab[]     = TEXT("\t"); <br>                    Edit_ReplaceSel(hwndScript, szTab); <br>                    return (TRUE); <br>                } <br>                break; <br>        } <br>    } <br> <br> <br>MciApp_Dispatch_Continue: <br> <br>    // <br>    //  update the device list if it needs to be updated--also <br>    //  do the floating dialog box message thing... <br>    // <br>    if (NULL != ghwndDevices) <br>    { <br>        MciAppDeviceListUpdate(hwnd, ghwndDevices, FALSE); <br> <br>        if (IsDialogMessage(ghwndDevices, pmsg)) <br>            return (TRUE); <br>    } <br> <br> <br>    // <br>    //  take care of accelerators and dialog box style things... <br>    // <br>    if (TranslateAccelerator(hwnd, haccl, pmsg) || <br>        IsDialogMessage(hwnd, pmsg)) </code></pre>
<p>
</p>
<pre><code>{ <br>        return (TRUE); <br>    } <br> <br>    TranslateMessage(pmsg); <br>    DispatchMessage(pmsg); <br> <br>    return (TRUE); <br>} // MciAppDispatchMessage() <br> <br> <br>//==========================================================================; <br>// <br>//  Startup and shutdown code... <br>// <br>// <br>//==========================================================================; <br> <br>TCHAR   gszKeyOptions[]     = TEXT("Options"); <br>TCHAR   gszFormatOptions[]  = TEXT("%u"); <br> <br>TCHAR   gszKeyWindow[]      = TEXT("Window"); <br>TCHAR   gszKeyFont[]        = TEXT("Font"); <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL MciAppChooseFont <br>// <br>//  Description: <br>//      This function lets the user choose a new font for the script window. <br>//      After a new font is chosen, the font structure is stored to the <br>//      .ini file so it can be restored on the next run of this application. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to main window. <br>// <br>//  Return (BOOL): <br>//      The return value is TRUE if a new font was chosen. It is FALSE if <br>//      the user canceled the operation. <br>// <br>//  History: <br>//       2/ 7/93    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNGLOBAL MciAppChooseFont <br>( <br>    HWND            hwnd <br>) <br>{ <br>    LOGFONT     lf; <br>    HWND        hwndScript; <br>    HFONT       hfont; <br>    HFONT       hfontNew; <br> <br>    hwndScript = GetDlgItem(hwnd, IDD_APP_EDIT_SCRIPT); <br> <br>    // <br>    //  get the current script font and pass it to the choose font dialog <br>    // <br>    hfont = GetWindowFont(hwndScript); <br> <br>    hfontNew = AppChooseFont(hwnd, hfont, &amp;lf); <br>    if (NULL == hfontNew) <br>        return (FALSE); <br> <br>    // <br>    //  select the new font into the script window and delete the old one <br>    // <br>    SetWindowFont(hwndScript, hfontNew, TRUE); <br>    DeleteFont(hfont); <br> <br> <br>    // <br>    //  save the complete description of the chosen font so there can be <br>    //  no strangness in the font mapping next run. this is overkill, but <br>    //  it works... <br>    // <br>    AppProfileWriteBytes(gszKeyFont, (LPBYTE)&amp;lf, sizeof(lf)); <br> <br>    return (TRUE); <br>} // MciAppChooseFont() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL MciAppSettingsRestore <br>// <br>//  Description: <br>//      This function restores state information for the application. This <br>//      function is called just after the main window is created (it has <br>//      not been ShowWindow()'d). This function will generate the call <br>//      to ShowWindow before returning. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to main window that has just been created but <br>//      not shown. <br>// <br>//      int nCmdShow: The state that the application window should show as. <br>// <br>//  Return (BOOL): <br>//      The return value is always TRUE. <br>// <br>//  History: <br>//       2/15/93    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNLOCAL MciAppSettingsRestore <br>( <br>    HWND            hwnd, <br>    int             nCmdShow <br>) <br>{ <br>    static TCHAR    szSecExtensions[]   = TEXT("Extensions"); <br>    static TCHAR    szKeyMCI[]          = TEXT("mci"); <br>    static TCHAR    szValAssocMCI[]     = TEXT("mciapp.exe ^.mci"); <br>    static TCHAR    szKeyMCS[]          = TEXT("mcs"); <br>    static TCHAR    szValAssocMCS[]     = TEXT("mciapp.exe ^.mcs"); <br> <br>    TCHAR           ach[APP_MAX_STRING_RC_CHARS]; <br>    WINDOWPLACEMENT wp; <br>    HFONT           hfont; <br>    LOGFONT         lf; <br>    UINT            u; <br>    RECT            rc; <br>    RECT            rcWindow; <br>    POINT           pt; <br>    int             n; <br>    BOOL            f; <br> <br> <br>    // <br>    //  restore the previous Options state... <br>    // <br>    gfuAppOptions = GetProfileInt(gszAppSection, gszKeyOptions, gfuAppOptions); <br> <br> <br>    // <br>    //  we want to make sure that the association for .MCI and .MCS files is <br>    //  to run MCIAPP.EXE. this way any app that ShellExecute's a .MCI or <br>    //  .MCS file will run this app... <br>    // <br>    //  in WIN.INI: <br>    // <br>    //      [Extensions] <br>    //      mci = mciapp.exe ^.mci <br>    //      mcs = mciapp.exe ^.mcs <br>    // <br>    u = (UINT)GetProfileString(szSecExtensions, szKeyMCI, gszNull, ach, SIZEOF(ach)); <br>    if ((0 == u) || lstrcmpi(ach, szValAssocMCI)) <br>    { <br>        WriteProfileString(szSecExtensions, szKeyMCI, szValAssocMCI); <br>    } <br> <br>    u = (UINT)GetProfileString(szSecExtensions, szKeyMCS, gszNull, ach, SIZEOF(ach)); <br>    if ((0 == u) || lstrcmpi(ach, szValAssocMCS)) <br>    { <br>        WriteProfileString(szSecExtensions, szKeyMCS, szValAssocMCS); <br>    } <br> <br>    // <br>    //  restore the user's preferred font. <br>    // <br>    f = AppProfileReadBytes(gszKeyFont, (LPBYTE)&amp;lf, sizeof(lf)); <br>    if (f) <br>    { <br>        hfont = CreateFontIndirect(&amp;lf); <br>        if (NULL != hfont) <br>        { <br>            SetWindowFont(GetDlgItem(hwnd, IDD_APP_EDIT_SCRIPT), hfont, FALSE); <br>        } <br>    } <br> <br> <br>    // <br>    //  grab the stored window position and size from the .ini file... <br>    //  there must be four arguments stored or the entry is considered <br>    //  invalid. <br>    // <br>    f = AppProfileReadBytes(gszKeyWindow, (LPBYTE)&amp;rcWindow, sizeof(rcWindow)); <br>    if (f) <br>    { <br>        // <br>        //  to make sure the user can always get at the window, check to <br>        //  see if the midpoint of the caption is visible--if it is not, <br>        //  then default to the default position used when creating the <br>        //  window. <br>        // <br>        n = (rcWindow.right - rcWindow.left) / 2; <br>        pt.x = (n + rcWindow.left); <br> <br>        n = GetSystemMetrics(SM_CYCAPTION) / 2 + GetSystemMetrics(SM_CXFRAME); <br>        pt.y = (n + rcWindow.top); <br> <br>        GetWindowRect(GetDesktopWindow(), &amp;rc); <br>        if (PtInRect(&amp;rc, pt)) <br>        { <br>            // <br>            //  fill out the window placement structure--default the <br>            //  maximized and minimized states to default placement by <br>            //  getting its current placement. <br>            // <br>            wp.length = sizeof(wp); <br>            GetWindowPlacement(hwnd, &amp;wp); <br> <br>            wp.showCmd          = nCmdShow; <br>            wp.rcNormalPosition = rcWindow; <br> <br>            SetWindowPlacement(hwnd, &amp;wp); <br>            return (TRUE); <br>        } <br>    } <br> <br>    // <br>    //  show defaulted and succeed <br>    // <br>    ShowWindow(hwnd, nCmdShow); <br>    return (TRUE); <br>} // MciAppSettingsRestore() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL MciAppSettingsSave <br>// <br>//  Description: <br>//      This function saves the current state information for the application. <br>//      It is called just before the main window is closed (destroyed); or <br>//      as Windows is exiting (query end session). <br>// <br>//      Note that this function should not destroy any resources--it can <br>//      be called at any time to save a snapshot of the application state. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to main window that will be destroyed shortly. <br>// <br>//  Return (BOOL): <br>//      The return value is always TRUE. <br>// <br>//  History: <br>//       2/15/93    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNGLOBAL MciAppSettingsSave <br>( <br>    HWND            hwnd <br>) <br>{ <br>    TCHAR           ach[APP_MAX_STRING_RC_CHARS]; <br>    WINDOWPLACEMENT wp; <br>    PRECT           prc; <br>    BOOL            f; <br> <br>    // <br>    //  save the current option settings--note that we ALWAYS turn off the <br>    //  debug logging option so the app doesn't try to OutputDebugString <br>    //  unexpectedly during the next session... <br>    // <br>    gfuAppOptions &amp;= ~APP_OPTF_DEBUGLOG; <br>    if (GetProfileInt(gszAppSection, gszKeyOptions, 0) != gfuAppOptions) <br>    { <br>        wsprintf(ach, gszFormatOptions, gfuAppOptions); <br>        WriteProfileString(gszAppSection, gszKeyOptions, ach); <br>    } <br> <br>    // <br>    //  save the current window placement--only store the size and location <br>    //  of the restored window. maximized and minimized states should <br>    //  remain defaulted on the next invocation of this application. <br>    // <br>    wp.length = sizeof(wp); <br>    f = GetWindowPlacement(hwnd, &amp;wp); <br>    if (f) <br>    { <br>        prc = &amp;wp.rcNormalPosition; <br> <br>        DPF(0, "WindowPlacement: show=%d, minX=%d, minY=%d, maxX=%d, maxY=%d", <br>             wp.showCmd, wp.ptMinPosition.x, wp.ptMinPosition.y, <br>             wp.ptMaxPosition.x, wp.ptMaxPosition.y); <br> <br>        DPF(0, "                 normX=%d, normY=%d, normW=%d, normH=%d", <br>             prc-&gt;left, prc-&gt;top, prc-&gt;right, prc-&gt;bottom); <br> <br>        // <br>        //  save the _bounding rectangle_ of the restored window state... <br>        // <br>        AppProfileWriteBytes(gszKeyWindow, (LPBYTE)prc, sizeof(*prc)); <br>    } <br> <br> <br>    // <br>    //  succeed <br>    // <br>    return (TRUE); <br>} // MciAppSettingsSave() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL MciAppShutdown <br>// <br>//  Description: <br>//      This function is called to gracefully shut down the application. <br>//      If the application should not be closed, a FALSE value is returned. <br>//      This function is called for WM_CLOSE and WM_QUERYENDSESSION <br>//      messages... <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to main window. <br>// <br>//      PTSTR pszFilePath: Pointer to current file path of script. If the <br>//      file needs to be saved, then this buffer will receive the new <br>//      file path if one is chosen. <br>// <br>//      PTSTR pszFilePath: Pointer to current file title of script. If the <br>//      file needs to be saved, then this buffer will receive the new <br>//      file title if one is chosen. <br>// <br>//  Return (BOOL): <br>//      Returns TRUE if the application can proceed with close. Returns <br>//      FALSE if the application should NOT be closed. <br>// <br>//  History: <br>//       2/ 9/93    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNGLOBAL MciAppShutdown <br>( <br>    HWND            hwnd, <br>    PTSTR           pszFilePath, <br>    PTSTR           pszFileTitle <br>) <br>{ <br>    int         n; <br>    UINT        u; <br>    BOOL        f; <br> <br>    // <br>    //  if we are currently executing a script (Run or Go), things would <br>    //  get very messy if we tried to close the application. so disallow <br>    //  it! <br>    // <br>    //  !!! this is rude--bring up dialog with the problem statement !!! <br>    // <br>    if (gfExecuting) <br>    { <br>        MessageBeep((UINT)-1); <br>        return (FALSE); <br>    } <br> <br>    // <br>    //  check if the script has been modified without saving. if the user <br>    //  cancels the operation, then we will NOT close the application. <br>    // <br>    f = MciAppFileSaveModified(hwnd, pszFilePath, pszFileTitle); <br>    if (!f) <br>        return (FALSE); <br> <br>    // <br>    //  if devices are still open, ask user if we should close them down <br>    //  before exiting. the only reason we don't do this by default is <br>    //  for application cleanup testing in mmsystem... i suppose it is <br>    //  a nifty reminder for scripts that don't close devices also. <br>    // <br>    u = MciAppGetNumDevices(hwnd); <br>    if (0 != u) <br>    { <br>        n = AppMsgBoxId(hwnd, MB_YESNOCANCEL | MB_ICONEXCLAMATION | MB_TASKMODAL <br>                        | MB_SETFOREGROUND, IDS_WARN_OPEN_DEVICES, u); <br>        switch (n) <br>        { <br>            case IDYES: <br>                MciAppCloseAllDevices(hwnd); <br>                break; <br> <br>            case IDNO: <br>                break; <br> <br>            case IDCANCEL: <br>                return (FALSE); <br>        } <br>    } <br> <br> <br>    // <br>    //  save any settings that should be saved on app termination... <br>    // <br>    MciAppSettingsSave(hwnd); <br> <br>    // <br>    //  allow closing of application... <br>    // <br>    return (TRUE); <br>} // MciAppShutdown() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL MciAppInit <br>// <br>//  Description: <br>// <br>// <br>//  Arguments: <br>// <br>// <br>//  Return (BOOL): <br>// <br>// <br>//  History: <br>//       2/15/93    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNGLOBAL MciAppInit <br>( <br>    HWND            hwnd, <br>    PTSTR           pszFilePath, <br>    PTSTR           pszFileTitle, <br>    LPTSTR          pszCmdLine, <br>    int             nCmdShow <br>) <br>{ <br>    BOOL        f; <br> <br>    // <br>    // <br>    // <br>    MciAppSettingsRestore(hwnd, nCmdShow); <br> <br>    // <br>    //  strip the command line.. <br>    // <br>    if (NULL != pszCmdLine) <br>    { <br>        while (('\0' != *pszCmdLine) &amp;&amp; (' ' == *pszCmdLine)) <br>            pszCmdLine++; <br>    } <br> <br>    // <br>    //  if there is a command line, assume it is a filename for a script <br>    //  and try to open it. otherwise, just initialize the script window. <br>    // <br>    if ((NULL != pszCmdLine) &amp;&amp; ('\0' != *pszCmdLine)) <br>    { <br>        // <br>        //  attempt to open the specified file.. <br>        // <br>        lstrcpy(pszFilePath, pszCmdLine); <br>        f = MciAppFileOpen(hwnd, pszFilePath, pszFileTitle); <br>        if (f) <br>        { <br>            AppTitle(hwnd, pszFileTitle); <br>            SetFocus(GetDlgItem(hwnd, IDD_APP_EDIT_SCRIPT)); <br>        } <br>        else <br>        { <br>            // <br>            //  opening the command line file was untriumphant.. <br>            // <br>            AppMsgBoxId(hwnd, MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL, <br>                        IDS_ERROR_OPEN_FAILED, (LPSTR)pszFilePath); <br> <br> <br>            pszFilePath[0]  = '\0'; <br>            pszFileTitle[0] = '\0'; <br>            AppFileNew(hwnd, pszFilePath, pszFileTitle); <br>        } <br>    } <br>    else <br>    { <br>        AppFileNew(hwnd, pszFilePath, pszFileTitle); <br>    } <br> <br> <br>    // <br>    // <br>    // <br>    // <br>    MciAppDeviceList(hwnd, FALSE); <br> <br>    return (TRUE); <br>} // MciAppInit() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL MciAppExit <br>// <br>//  Description: <br>// <br>// <br>//  Arguments: <br>// <br>// <br>//  Return (BOOL): <br>// <br>// <br>//  History: <br>//       2/15/93    created. <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNGLOBAL MciAppExit <br>( <br>    void <br>) <br>{ <br>    // <br>    //  clean up any resources and stuff we have allocated... <br>    // <br> <br>    return (TRUE); <br>} // MciAppExit() </code></pre>
<p>&nbsp;</p></body>
</HTML>
