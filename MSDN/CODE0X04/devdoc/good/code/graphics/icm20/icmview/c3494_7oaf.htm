<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ICMVIEW.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3507"></a>ICMVIEW.C</h2>
<pre><code>//THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>//ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>//THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>// PARTICULAR PURPOSE. <br>// <br>// Copyright  1994-1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//  FILE: <br>//    ICMVIEW.C <br>// <br>//  PURPOSE: <br>// <br>// <br>//  PLATFORMS: <br>//    Windows 95, Windows NT <br>// <br>//  SPECIAL INSTRUCTIONS: N/A <br>// <br> <br>// Windows Header Files: <br>#pragma warning(disable:4001)   // Single-line comment warnings <br>#pragma warning(disable:4115)   // Named type definition in parentheses <br>#pragma warning(disable:4201)   // Nameless struct/union warning <br>#pragma warning(disable:4214)   // Bit field types other than int warnings <br>#pragma warning(disable:4514)   // Unreferenced inline function has been removed <br> <br>// Windows Header Files: <br>#include &lt;Windows.h&gt; <br>#include &lt;WindowsX.h&gt; <br>#include "icm.h" <br> <br>// Restore the warnings--leave the single-line comment warning OFF <br>#pragma warning(default:4115)   // Named type definition in parentheses <br>#pragma warning(default:4201)   // Nameless struct/union warning <br>#pragma warning(default:4214)   // Bit field types other than int warnings <br> <br>// C RunTime Header Files <br>#include &lt;stdlib.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;malloc.h&gt; <br>#include &lt;memory.h&gt; <br>#include &lt;tchar.h&gt; <br> <br>// Local Header Files <br>#include "Resource.h" <br> <br>#define   ICMVIEW_INTERNAL <br>#include "ICMView.h" <br>#undef    ICMVIEW_INTERNAL <br> <br>#include "Print.H" <br>#include "DibInfo.H" <br>#include "Dialogs.H" <br>#include "AppInit.H" <br>#include "child.h" <br>#include "Debug.h" <br> <br> <br>// Global Variables: <br>HINSTANCE   ghInst;                         // Global instance handle <br>TCHAR       gstTitle[MAX_STRING];           // The title bar text <br>HWND        ghAppWnd;                       // Handle to application window <br>HWND        ghWndMDIClient; <br>DWORD       gdwLastError;                   // Used to track last error value <br>TCHAR       gstProfilesDir[MAX_PATH];       // System directory for ICM profiles <br> <br>// Foward declarations of functions included in this code module: <br>LRESULT CALLBACK About(HWND, UINT, WPARAM, LPARAM); <br> <br>// <br>//  FUNCTION: WinMain(HANDLE, HANDLE, LPTSTR, int) <br>// <br>//  PURPOSE: Entry point for the application. <br>// <br>//  COMMENTS: <br>// <br>//      This function initializes the application and processes the <br>//      message loop. <br>// <br>int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) <br>{ <br>    MSG msg; <br>    HANDLE hAccelTable; <br> <br>    if (!hPrevInstance) <br>    { <br>        // Perform instance initialization: <br>        if (!InitApplication(hInstance)) <br>        { <br>            return (FALSE); <br>        } <br>    } <br> <br>    // Perform application initialization: <br>    if (!InitInstance(hInstance, nCmdShow)) <br>    { <br>        return (FALSE); <br>    } <br> <br>    hAccelTable = LoadAccelerators (hInstance, APPNAME); <br>    ASSERT(hAccelTable); <br> <br>    // Main message loop: <br>    while (GetMessage(&amp;msg, NULL, 0, 0)) <br>    { <br>        if ((!TranslateMDISysAccel (ghWndMDIClient, &amp;msg)) <br>            &amp;&amp; (!TranslateAccelerator (msg.hwnd, hAccelTable, &amp;msg))) <br>        { <br>            TranslateMessage(&amp;msg); <br>            DispatchMessage(&amp;msg); <br>        } <br>    } <br>    return (msg.wParam); <br>    lpCmdLine; // This will prevent 'unused formal parameter' warnings <br>} <br> <br>// <br>//  FUNCTION: WndProc(HWND, unsigned, WORD, LONG) <br>// <br>//  PURPOSE:  Processes messages for the main window. <br>// <br>//  MESSAGES: <br>// <br>//      WM_COMMAND - process the application menu <br>//      WM_PAINT - Paint the main window <br>//      WM_DESTROY - post a quit message and return <br>//      WM_DISPLAYCHANGE - message sent to Plug &amp; Play systems when the display changes <br>//      WM_RBUTTONDOWN - Right mouse click -- put up context menu here if appropriate <br>//      WM_NCRBUTTONUP - User has clicked the right button on the application's system menu <br>// <br>// <br>LRESULT CALLBACK WndProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam) <br>{ <br>    int         wmId, wmEvent; <br>    POINT       pnt; <br>    HMENU       hMenu; <br>    int         iDlg; <br> <br>    // Init variables <br>    iDlg = 0; <br> <br>    switch (uiMsg) <br>    { <br> <br>        case WM_INITMENUPOPUP: <br>            InitImageMenu(hwnd); <br>            break; <br> <br>        case WM_CREATE: <br>            { <br>                CLIENTCREATESTRUCT ccs; <br> <br>                // Find window menu where children will be listed <br>                ccs.hWindowMenu  = GetSubMenu (GetMenu (hwnd), WINDOWMENU_POS); <br>                ccs.idFirstChild = FIRSTCHILD; <br> <br>                // Create the MDI client window, which will fill the client area <br>                ghWndMDIClient = CreateWindow ( <br>                                              __TEXT("MDICLIENT"), <br>                                              NULL, <br>                                              WS_CHILD | WS_CLIPCHILDREN | WS_VSCROLL | WS_HSCROLL, <br>                                              0, <br>                                              0, <br>                                              0, <br>                                              0, <br>                                              hwnd, <br>                                              (HMENU) 0xCAC, <br>                                              ghInst, <br>                                              (LPTSTR)&amp;ccs); <br> <br>                ShowWindow (ghWndMDIClient, SW_SHOW); <br>                break; <br>            } <br> <br>        case WM_COMMAND: <br>            wmId    = LOWORD(wParam); // Remember, these are... <br>            wmEvent = HIWORD(wParam); // ...different for Win32! <br> <br>            //Parse the menu selections: <br>            switch (wmId) <br>            { <br>                case IDM_HELP_ABOUT: <br>                    DialogBox(ghInst, __TEXT("AboutBox"), hwnd, (DLGPROC)About); <br>                    break; <br> <br>                case IDM_FILE_EXIT: <br>                    DestroyWindow (hwnd); <br>                    break; <br> <br>                case IDM_FILE_OPEN: <br>                    fOpenNewImage(hwnd, NULL); <br>                    break; <br> <br>                case IDM_WINDOW_CASCADE: <br>                    SendMessage(ghWndMDIClient, WM_MDICASCADE, 0, 0);; <br>                    break; <br> <br>                case IDM_WINDOW_TILE_HORIZONTAL: <br>                    SendMessage(ghWndMDIClient, WM_MDITILE, (WPARAM)MDITILE_HORIZONTAL, 0);; <br>                    break; <br> <br>                case IDM_WINDOW_TILE_VERTICAL: <br>                    SendMessage(ghWndMDIClient, WM_MDITILE, (WPARAM)MDITILE_VERTICAL, 0);; <br>                    break; <br> <br>                case IDM_WINDOW_ARRANGE: <br>                    SendMessage(ghWndMDIClient, WM_MDIICONARRANGE, 0, 0); <br>                    break; <br> <br>                case IDM_FILE_RECENT: <br>                case IDM_FILE_RECENT1: <br>                case IDM_FILE_RECENT2: <br>                case IDM_FILE_RECENT3: <br>                    { <br>                        HANDLE  hRecent; <br>                        LPTSTR  *ppszRecent; <br>                        LPTSTR  lpszFileName; <br> <br>                        // Get handle to recent file list table. <br>                        hRecent = GetProp(hwnd, APP_RECENT); <br>                        if (NULL != hRecent) <br>                        { <br>                            // Get pointer to recent file array. <br>                            ppszRecent = (LPTSTR*) GlobalLock(hRecent); <br>                            ASSERT(NULL != ppszRecent); <br> <br>                            // Copy file name into buffer. <br>                            lpszFileName = GlobalAlloc(GPTR,(lstrlen(ppszRecent[ wmId - IDM_FILE_RECENT]) +1) * sizeof(TCHAR)); <br> <br>                            // Open the file. <br>                            if (lpszFileName != NULL) <br>                            { <br>                                // Copy recent file name to file name buffer. <br>                                _tcscpy(lpszFileName, ppszRecent[ wmId - IDM_FILE_RECENT]); <br>                                GlobalUnlock(hRecent); <br> <br>                                // Open new image of recent file. <br>                                fOpenNewImage(hwnd, lpszFileName); <br>                            } <br>                        } <br>                    } <br>                    break; <br> <br>                default: <br>                    { <br>                        HWND  hwndActiveChild; <br> <br>                        hwndActiveChild = GetCurrentMDIWnd(); <br>                        ASSERT(hwndActiveChild != NULL); <br>                        if (hwndActiveChild) <br>                        { <br>                            PostMessage(hwndActiveChild, uiMsg, wmId, wmEvent); <br>                        } <br>                        break; <br>                    } <br>            } <br>            break; <br> <br>        case WM_RBUTTONDOWN: // RightClick in windows client area... <br>            pnt.x = LOWORD(lParam); <br>            pnt.y = HIWORD(lParam); <br>            ClientToScreen(hwnd, (LPPOINT) &amp;pnt); <br>            hMenu = GetSubMenu (GetMenu (hwnd), 2); <br>            if (hMenu) <br>            { <br>                TrackPopupMenu (hMenu, 0, pnt.x, pnt.y, 0, hwnd, NULL); <br>            } <br>            else  // Couldn't find the menu... <br>            { <br>                MessageBeep(0); <br>            } <br>            break; <br> <br>        case WM_DISPLAYCHANGE: // Only comes through on plug'n'play systems <br>            { <br>                SIZE szScreen; <br>                BOOL fChanged = (BOOL)wParam; <br> <br>                szScreen.cx = LOWORD(lParam); <br>                szScreen.cy = HIWORD(lParam); <br>            } <br>            break; <br> <br>        case WM_CLOSE: <br>            DestroyWindow(hwnd); <br>            return 1L; <br> <br>        case WM_DESTROY: <br>            { <br>                DWORD             dwFlags = 0L; <br>                HANDLE            hRecent; <br>                WINDOWPLACEMENT   WndPlacement; <br> <br>                // Store application settings. <br>                dwFlags |= IsZoomed(hwnd) ? IVF_MAXIMIZED : 0L; <br>                WndPlacement.length = sizeof(WINDOWPLACEMENT); <br>                GetWindowPlacement(hwnd, &amp;WndPlacement); <br>                hRecent = GetProp(hwnd, APP_RECENT); <br>                SetSettings(&amp;WndPlacement.rcNormalPosition, dwFlags, hRecent); <br> <br>                // Remove recent file attachment and free memory. <br>                RemoveProp(hwnd, APP_RECENT); <br>                GlobalFree(hRecent); <br>            } <br>            PostQuitMessage(0); <br>            break; <br> <br>        case WM_QUERYNEWPALETTE: <br>            { <br>                HWND hwndActive; <br> <br>                hwndActive = GetCurrentMDIWnd(); <br>                if (NULL != hwndActive) <br>                { <br>                    return SendMessage(hwndActive, MYWM_QUERYNEWPALETTE, (WPARAM) hwnd, 0L); <br>                } <br>                return FALSE; <br>            } <br> <br>        case WM_SIZE: <br>            InvalidateRect(hwnd, NULL, TRUE); <br>            break; <br>    } <br>    return DefFrameProc(hwnd,ghWndMDIClient, uiMsg, wParam, lParam); <br>} <br> <br>// <br>//  FUNCTION: About(HWND, unsigned, WORD, LONG) <br>// <br>//  PURPOSE:  Processes messages for "About" dialog box <br>//              This version allows greater flexibility over the contents of the 'About' box, <br>//              by pulling out values from the 'Version' resource. <br>// <br>//  MESSAGES: <br>// <br>//      WM_INITDIALOG - initialize dialog box <br>//      WM_COMMAND    - Input received <br>// <br>// <br>LRESULT CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>    static  HFONT hfontDlg;         // Font for dialog text <br>    static  HFONT hFinePrint;       // Font for 'fine print' in dialog <br>    DWORD   dwVerInfoSize;          // Size of version information block <br>    LPTSTR   lpVersion;              // String pointer to 'version' text <br>    DWORD   dwVerHnd=0;             // An 'ignored' parameter, always '0' <br>    UINT    uVersionLen; <br>    int     iRootLen; <br>    BOOL    bRetCode; <br>    int     i; <br>    TCHAR   szFullPath[256]; <br>    TCHAR   szResult[256]; <br>    TCHAR   szGetName[256]; <br>    DWORD   dwVersion; <br>    TCHAR   szVersion[40]; <br>    DWORD   dwResult; <br> <br>    wParam = wParam; //Eliminate 'unused formal parameter' warning <br>    lParam = lParam; //Eliminate 'unused formal parameter' warning <br> <br>    switch (message) <br>    { <br>        case WM_INITDIALOG: <br>            ShowWindow (hDlg, SW_HIDE); <br>            hfontDlg = CreateFont(14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, VARIABLE_PITCH | FF_SWISS, __TEXT("")); <br>            hFinePrint = CreateFont(11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, VARIABLE_PITCH | FF_SWISS, __TEXT("")); <br>            CenterWindow (hDlg, GetWindow (hDlg, GW_OWNER)); <br>            GetModuleFileName (ghInst, szFullPath, sizeof(szFullPath)); <br> <br>            // Now let's dive in and pull out the version information: <br>            dwVerInfoSize = GetFileVersionInfoSize(szFullPath, &amp;dwVerHnd); <br>            if (dwVerInfoSize) <br>            { <br>                LPTSTR   lpstrVffInfo; <br>                HANDLE  hMem; <br>                hMem = GlobalAlloc(GMEM_MOVEABLE, dwVerInfoSize); <br>                lpstrVffInfo  = GlobalLock(hMem); <br>                GetFileVersionInfo(szFullPath, dwVerHnd, dwVerInfoSize, lpstrVffInfo); <br> <br>                // The below 'hex' value looks a little confusing, but <br>                // essentially what it is, is the hexidecimal representation <br>                // of a couple different values that represent the language <br>                // and character set that we are wanting string values for. <br>                // 040904E4 is a very common one, because it means: <br>                //   US English, Windows MultiLingual characterset <br>                // Or to pull it all apart: <br>                // 04//////        = SUBLANG_ENGLISH_USA <br>                // --09////        = LANG_ENGLISH <br>                // ////04E4 = 1252 = Codepage for Windows:Multilingual <br>                _tcscpy(szGetName, __TEXT("\\StringFileInfo\\040904E4\\")); <br>                iRootLen = lstrlen(szGetName); // Save this position <br> <br>                // Set the title of the dialog: <br>                lstrcat (szGetName, __TEXT("ProductName")); <br>                bRetCode = VerQueryValue((LPVOID)lpstrVffInfo, (LPTSTR)szGetName, (LPVOID)&amp;lpVersion, (UINT *)&amp;uVersionLen); <br>                _tcscpy(szResult, __TEXT("About ")); <br>                lstrcat(szResult, lpVersion); <br>                SetWindowText (hDlg, szResult); <br> <br>                // Walk through the dialog items that we want to replace: <br>                for (i = DLG_VERFIRST; i &lt;= DLG_VERLAST; i++) <br>                { <br>                    GetDlgItemText(hDlg, i, szResult, sizeof(szResult)); <br>                    szGetName[iRootLen] = __TEXT('\0'); <br>                    lstrcat (szGetName, szResult); <br>                    uVersionLen   = 0; <br>                    lpVersion     = NULL; <br>                    bRetCode      =  VerQueryValue((LPVOID)lpstrVffInfo, (LPTSTR)szGetName, (LPVOID)&amp;lpVersion, (UINT *)&amp;uVersionLen); <br> <br>                    if ( bRetCode &amp;&amp; uVersionLen &amp;&amp; lpVersion) <br>                    { <br>                        // Replace dialog item text with version info <br>                        _tcscpy(szResult, lpVersion); <br>                        SetDlgItemText(hDlg, i, szResult); <br>                    } <br>                    else <br>                    { <br>                        dwResult = GetLastError(); <br>                        wsprintf (szResult,__TEXT("Error %lu"), dwResult); <br>                        SetDlgItemText (hDlg, i, szResult); <br>                    } <br>                    SendMessage (GetDlgItem (hDlg, i), WM_SETFONT, (UINT)((i==DLG_VERLAST)?hFinePrint:hfontDlg), TRUE); <br>                } // for (i = DLG_VERFIRST; i &lt;= DLG_VERLAST; i++) <br>                GlobalUnlock(hMem); <br>                GlobalFree(hMem); <br>            } <br>            else <br>            { <br>                // No version information available. <br>            } // if (dwVerInfoSize) <br> <br>            SendMessage (GetDlgItem (hDlg, IDC_LABEL), WM_SETFONT, (WPARAM)hfontDlg,(LPARAM)TRUE); <br> <br>            // We are  using GetVersion rather then GetVersionEx <br>            // because earlier versions of Windows NT and Win32s <br>            // didn't include GetVersionEx: <br>            dwVersion = GetVersion(); <br>            if (dwVersion &lt; 0x80000000) <br>            { <br>                // Windows NT <br>                wsprintf (szVersion,__TEXT("Microsoft Windows NT %u.%u (Build: %u)"), (DWORD)(LOBYTE(LOWORD(dwVersion))), (DWORD)(HIBYTE(LOWORD(dwVersion))),(DWORD)(HIWORD(dwVersion)) ); <br>            } <br>            else <br>            { <br>                if (LOBYTE(LOWORD(dwVersion)) &lt; 4) <br>                { <br>                    // Win32s <br>                    wsprintf (szVersion, __TEXT("Microsoft Win32s %u.%u (Build: %u)"), (DWORD)(LOBYTE(LOWORD(dwVersion))), (DWORD)(HIBYTE(LOWORD(dwVersion))),(DWORD)(HIWORD(dwVersion) &amp; ~0x8000) ); <br>                } <br>                else <br>                { <br>                    // Windows 95 <br>                    wsprintf (szVersion, __TEXT("Microsoft Windows 95 %u.%u"), (DWORD)(LOBYTE(LOWORD(dwVersion))), (DWORD)(HIBYTE(LOWORD(dwVersion))) ); <br>                } <br>            } <br>            SetWindowText (GetDlgItem(hDlg, IDC_OSVERSION), szVersion); <br>            ShowWindow (hDlg, SW_SHOW); <br>            return (TRUE); <br> <br>        case WM_COMMAND: <br>            if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) <br>            { <br>                EndDialog(hDlg, TRUE); <br>                DeleteObject (hfontDlg); <br>                DeleteObject (hFinePrint); <br>                return (TRUE); <br>            } <br>            break; <br>    } <br>    return FALSE; <br>} <br> <br>// <br>//   FUNCTION: CenterWindow(HWND, HWND) <br>// <br>//   PURPOSE: Centers one window over another. <br>// <br>//   COMMENTS: <br>// <br>//        In this function, we save the instance handle in a global variable and <br>//        create and display the main program window. <br>// <br>//              This function will center one window over another ensuring that <br>//              the placement of the window is within the 'working area', meaning <br>//              that it is both within the display limits of the screen, and not <br>//              obscured by the tray or other framing elements of the desktop. <br>BOOL CenterWindow (HWND hwndChild, HWND hwndParent) <br>{ <br>    RECT    rChild, rParent, rWorkArea; <br>    int     wChild, hChild, wParent, hParent; <br>    int     xNew, yNew; <br>    BOOL    bResult; <br> <br>    // Get the Height and Width of the child window <br>    GetWindowRect (hwndChild, &amp;rChild); <br>    wChild = rChild.right - rChild.left; <br>    hChild = rChild.bottom - rChild.top; <br> <br>    // Get the Height and Width of the parent window <br>    GetWindowRect (hwndParent, &amp;rParent); <br>    wParent = rParent.right - rParent.left; <br>    hParent = rParent.bottom - rParent.top; <br> <br>    // Get the limits of the 'workarea' <br>    bResult = SystemParametersInfo( <br>                                  SPI_GETWORKAREA, <br>                                  sizeof(RECT), <br>                                  &amp;rWorkArea, <br>                                  0); <br>    if (!bResult) <br>    { <br>        rWorkArea.left = rWorkArea.top = 0; <br>        rWorkArea.right = GetSystemMetrics(SM_CXSCREEN); <br>        rWorkArea.bottom = GetSystemMetrics(SM_CYSCREEN); <br>    } <br>    // Calculate new X position, then adjust for workarea <br>    xNew = rParent.left + ((wParent - wChild) / 2); <br>    if (xNew &lt; rWorkArea.left) <br>    { <br>        xNew = rWorkArea.left; <br>    } <br>    else if ((xNew + wChild) &gt; rWorkArea.right) <br>    { <br>        xNew = rWorkArea.right - wChild; <br>    } <br>    // Calcualte new Y position, then adjust for workarea <br>    yNew = rParent.top + ((hParent - hChild) /2); <br>    if (yNew &lt; rWorkArea.top) <br>    { <br>        yNew = rWorkArea.top; <br>    } <br>    else if ((yNew + hChild) &gt; rWorkArea.bottom) <br>    { <br>        yNew = rWorkArea.bottom - hChild; <br>    } <br> <br>    //Set it and return <br>    return(SetWindowPos(hwndChild, NULL, xNew, yNew, 0, 0, SWP_NOSIZE | SWP_NOZORDER)); <br>} <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  CopyString <br>// <br>//  Description: <br>//    Allocates space and copies one LPTSTR into a new one.  Allocates <br>//    exactly as much memory as necessary. <br>// <br>//  Parameters: <br>//    LPTSTR    Source string to be copied. <br>// <br>//  Returns: <br>//    LPTSTR  Pointer to copy of string; NULL if failure. <br>// <br>//  Comments: <br>// <br>// <br>////////////////////////////////////////////////////////////////////////// <br>LPTSTR CopyString(LPTSTR  lpszSrc) <br>{ <br>    // Local variables <br>    LPTSTR    lpszDest; <br>    int       iStrLen; <br> <br>    //  Initialize variables <br>    lpszDest = NULL; <br> <br>    if (lpszSrc == NULL) <br>    { <br>        DebugMsg(__TEXT("ICMVIEW.C : CopyString : lpszSrc == NULL\r\n")); <br>        return(NULL); <br>    } <br>    iStrLen = ((int)(lstrlen(lpszSrc) +1) * sizeof(TCHAR)); <br>    lpszDest = GlobalAlloc(GPTR, iStrLen); <br>    _tcscpy(lpszDest, lpszSrc); <br>    return(lpszDest); <br>}   // End of function CopyString <br> <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  UpdateString <br>// <br>//  Description: <br>//    Replaces target string with source string.  Frees target first <br>//    if necessary. <br>// <br>//  Parameters: <br>//    LPTSTR    Destination string <br>//    LPTSTR    Source string <br>// <br>//  Returns: <br>//    LPTSTR    Destination string. <br>// <br>//  Comments: <br>// <br>// <br>////////////////////////////////////////////////////////////////////////// <br>BOOL UpdateString(LPTSTR *lpszDest, LPTSTR lpszSrc) <br>{ <br>    // Local variables <br>    HGLOBAL hMem, hDest; <br>    LPTSTR  lpszNew; <br> <br>    //  Initialize variables <br>    if (NULL == lpszSrc) <br>    { <br>        DebugMsg(__TEXT("ICMVIEW.C : UpdateString : NULL source\r\n")); <br>        *lpszDest = NULL; <br>        return(FALSE); <br>    } <br> <br>    if (NULL != *lpszDest) <br>    { <br>        hDest = GlobalHandle(*lpszDest); <br>        GlobalUnlock(hDest); <br>        GlobalFree(hDest); <br>    } <br>    hMem = GlobalAlloc(GPTR, (1 + lstrlen(lpszSrc))* sizeof(TCHAR)); <br>    if (NULL == hMem) <br>    { <br>        DebugMsg(__TEXT("UpdateString : GlobalAlloc failed\r\n")); <br>        return(FALSE); <br>    } <br>    lpszNew = GlobalLock(hMem); <br>    _tcscpy(lpszNew, lpszSrc); <br>    *lpszDest = lpszNew; <br>    return(TRUE); <br>}   // End of function UpdateString <br> <br> <br> <br>BOOL ConvertIntent(DWORD dwOrig, DWORD dwDirection, LPDWORD lpdwXlate) <br>{ <br>    DWORD   adwIntents[MAX_ICC_INTENT + 1] = { LCS_GM_IMAGES, LCS_GM_GRAPHICS, LCS_GM_BUSINESS, LCS_GM_GRAPHICS}; <br>    int     idx; <br> <br>    ASSERT((ICC_TO_LCS == dwDirection) || (LCS_TO_ICC == dwDirection)); <br>    *lpdwXlate = (DWORD)-1; <br> <br>    switch (dwDirection) <br>    { <br>        case LCS_TO_ICC: <br>            for (idx = MAX_ICC_INTENT+1; idx &gt;0; idx--) <br>            { <br>                if (adwIntents[idx] == dwOrig) <br>                { <br>                    *lpdwXlate = idx; <br>                    return(TRUE); <br>                } <br>            } <br>            break; <br> <br>        case ICC_TO_LCS: <br>            if (dwOrig &lt;= MAX_ICC_INTENT) <br>            { <br>                *lpdwXlate = adwIntents[dwOrig]; <br>                return(TRUE); <br>            } <br>        default: <br>            SetLastError(ERROR_INVALID_PARAMETER); <br>            return(FALSE); <br>            break; <br>    } <br>    return(FALSE); <br>} <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  SetDWFlags <br>// <br>//  Description: <br>//    Sets flag values in a DWORD flag. <br>// <br>//  Parameters: <br>//    LPDWORD Pointer to flag variable to be changed. <br>//    DWORD   Value to be set/cleared. <br>//    BOOL    Indicates if value is to be set or cleared. <br>// <br>//  Returns: <br>//    DWORD   Value of flag variable prior to call. <br>// <br>//  Comments: <br>// <br>////////////////////////////////////////////////////////////////////////// <br>DWORD SetDWFlags(LPDWORD lpdwFlag, DWORD dwBitValue, BOOL bSet) <br>{ <br>    // Initialize variables <br>    if (bSet) <br>    { <br>        (*lpdwFlag) |= dwBitValue; <br>    } <br>    else <br>    { <br>        (*lpdwFlag) &amp;= (~dwBitValue); <br>    } <br>    return(*lpdwFlag); <br>} // End of function SetDWFlags <br> <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  InitImageMenu <br>// <br>//  Description: <br>//    Handles the WM_CONTEXTMENU message <br>// <br>//  Parameters: <br>//    @@@ <br>// <br>//  Returns: <br>//    LRESULT <br>// <br>//  Comments: <br>// <br>// <br>////////////////////////////////////////////////////////////////////////// <br>HMENU InitImageMenu(HWND hwnd) <br>{ <br>    // Local variables <br>    HMENU       hMenu, hActiveMenu; <br>    UINT        uiMenuFlag; <br>    LPDIBINFO   lpDIBInfo; <br>    HWND        hwndImage; <br> <br>    //  Initialize variables <br>    lpDIBInfo = NULL; <br> <br>    hwndImage = GetCurrentMDIWnd(); <br>    if (hwndImage)  // we have an active child window <br>    { <br>        lpDIBInfo = GetDIBInfoPtr(hwndImage); <br>        if (!lpDIBInfo) <br>        { <br>            return(NULL); <br>        } <br>    } <br> <br>    if (hwnd == ghAppWnd) // dealing with main app window <br>    { <br>        hMenu = GetMenu(hwnd); <br>        hActiveMenu = GetSubMenu(hMenu, IsZoomed(hwndImage) ? 1 : 0); <br>        uiMenuFlag = (hwndImage != NULL) ? MF_ENABLED : MF_GRAYED; <br>        EnableMenuItem(hActiveMenu, IDM_FILE_CLOSE, uiMenuFlag); <br>        EnableMenuItem(hActiveMenu, IDM_FILE_PRINT_SETUP, uiMenuFlag); <br>        EnableMenuItem(hActiveMenu, IDM_FILE_PRINT, uiMenuFlag); <br>        EnableMenuItem(hActiveMenu, IDM_FILE_DISPLAY, uiMenuFlag); <br>        EnableMenuItem(hActiveMenu, IDM_FILE_CONFIGURE_ICM, uiMenuFlag); <br>        EnableMenuItem(hActiveMenu, ID_FILE_SAVEAS, uiMenuFlag); <br>    } <br>    else  // dealing with child window--must init context menu <br>    { <br>        hMenu = LoadMenu(ghInst, __TEXT("ImageContext")); <br>        hActiveMenu = GetSubMenu(hMenu, 0); <br>    } <br> <br>    // Check EITHER ICM 2.0 or ICM 1.0 (Inside DC or Outside DC) <br>    if (hActiveMenu &amp;&amp; lpDIBInfo) <br>    { <br>        uiMenuFlag = (CHECK_DWFLAG(lpDIBInfo-&gt;dwICMFlags, ICMVFLAGS_ICM20) ? MF_CHECKED : MF_UNCHECKED); <br>        CheckMenuItem(hActiveMenu, IDM_FILE_ICM20, uiMenuFlag); <br>        CheckMenuItem(hActiveMenu, IDM_FILE_ICM10, uiMenuFlag == MF_CHECKED ? MF_UNCHECKED : MF_CHECKED); <br>    } <br> <br>    if (lpDIBInfo) <br>        GlobalUnlock(GlobalHandle(lpDIBInfo)); <br> <br>    return(hActiveMenu); <br>}   // End of function InitImageMenu <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  GetBaseFilename <br>// <br>//  Description: <br>// <br>// <br>//  Parameters: <br>//      @@@ <br>// <br>//  Returns: <br>//      BOOL <br>// <br>//  Comments: <br>// <br>// <br>////////////////////////////////////////////////////////////////////////// <br>BOOL GetBaseFilename(LPTSTR lpszFilename, LPTSTR *lpszBaseFilename) <br>{ <br>    // Local variables <br>    TCHAR   stFile[MAX_PATH], stExt[MAX_PATH]; <br> <br>    //  ASSERTs and parameter validations <br>    ASSERT(NULL != lpszFilename); <br>    if (NULL == lpszFilename) <br>    { <br>        SetLastError(ERROR_INVALID_PARAMETER); <br>        return(FALSE); <br>    } <br> <br>    //  Initialize variables <br>    _tsplitpath(lpszFilename, NULL, NULL, stFile, stExt); <br>    (*lpszBaseFilename) = (LPTSTR)GlobalAlloc(GPTR, ((_tcslen(stFile) + _tcslen(stExt) + 1 ) * sizeof(TCHAR))); <br>    if (NULL != *lpszBaseFilename) <br>    { <br>        _stprintf(*lpszBaseFilename, __TEXT("%s%s"), stFile, stExt); <br>    } <br>    //  Cleanup any allocated resources <br>    return(NULL != *(lpszBaseFilename)); <br>} // End of function GetBaseFilename <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
