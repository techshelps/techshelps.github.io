<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PRINT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3509"></a>PRINT.C</h2>
<pre><code>//THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>//ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>//THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>// PARTICULAR PURPOSE. <br>// <br>// Copyright  1994-1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//  FILE: <br>//    Print.c <br>// <br>//  PURPOSE: <br>//    Illustrates the 'minimum' functionality of a well-behaved Win32 application. <br>// <br>//  PLATFORMS: <br>//    Windows 95, Windows NT <br>// <br>//  SPECIAL INSTRUCTIONS: N/A <br>// <br> <br>// Windows Header Files: <br>#pragma warning(disable:4001)   // Single-line comment warnings <br>#pragma warning(disable:4115)   // Named type definition in parentheses <br>#pragma warning(disable:4201)   // Nameless struct/union warning <br>#pragma warning(disable:4214)   // Bit field types other than int warnings <br>#pragma warning(disable:4514)   // Unreferenced inline function has been removed <br> <br>// Windows Header Files: <br>#include &lt;Windows.h&gt; <br>#include &lt;WindowsX.h&gt; <br>#include &lt;commdlg.h&gt; <br>#include &lt;winspool.h&gt; <br>#include "icm.h" <br> <br>// Restore the warnings--leave the single-line comment warning OFF <br>#pragma warning(default:4115)   // Named type definition in parentheses <br>#pragma warning(default:4201)   // Nameless struct/union warning <br>#pragma warning(default:4214)   // Bit field types other than int warnings <br>#pragma warning(default:4514)   // Unreferenced inline function has been removed <br> <br>// C RunTime Header Files <br>#include &lt;TCHAR.H&gt; <br> <br>// Local Header Files <br>#include "IcmView.h" <br>#include "Child.h" <br>#include "dibinfo.h" <br>#include "Dibs.h" <br> <br>#include "Debug.h" <br> <br>#include "Print.h" <br>#include "RegUtil.h" <br>#include "Resource.h" <br> <br>// local definitions <br> <br>#ifndef ICM_DONE_OUTSIDEDC <br>    #define ICM_DONE_OUTSIDEDC  4 <br>#endif <br> <br>// default settings <br> <br>// external functions <br> <br>// external data <br> <br>// public data <br> <br>// private data <br>BOOL      gbUserAbort; <br>FARPROC   glpfnPrintDlgProc; <br>FARPROC   glpfnAbortProc; <br>HWND      ghDlgPrint; <br>HWND      ghWndParent; <br>LOGFONT   gLogFont = { 0, 0, 0, 0, 400, 0, 0, 0, 0, 0, 0, 0, 0, __TEXT("Arial")}; <br> <br>// private functions <br>BOOL FreeMemory(HANDLE hInfo); <br>LPBYTE GetMemory(LPHANDLE lphInfo, DWORD dwSize); <br>DWORD SPL_EnumPrinters(DWORD dwType, LPTSTR lpszName, DWORD dwLevel, LPHANDLE lphPrinterInfo); <br>BOOL PrintDIB (HANDLE hDIB, HDC hDC, int xOrigin, int yOrigin, int xSize, int ySize, BOOL bStretch); <br>static HDC PASCAL InitPrinting(HWND hWnd, LPTSTR lpszFriendlyName, PDEVMODE pDevMode); <br>static void PASCAL TermPrinting(HDC hDC); <br>BOOL FAR PASCAL PrintDlgProc (HWND hDlg, unsigned iMessage, WORD wParam, DWORD lParam); <br>BOOL FAR PASCAL AbortProc (HDC hPrnDC, short nCode); <br> <br> <br>extern DWORD NumColorsInDIB(LPBITMAPINFOHEADER lpbi); <br> <br>// public functions <br> <br>///////////////////////////////////////////////////////////////////// <br>//  Function:  SelectPrinter <br>// <br>//  Description: <br>//    Uses the Print common dialog box to provide the user with the <br>//    opportunity to select and set up a particular printer. <br>// <br>//  Parameters: <br>//    hWnd    Handle to the parent window. <br>// <br>//  Returns: <br>//    HDC to requested printer if successful; NULL otherwise. <br>// <br>// Comments: <br>//   If this function returns NULL, the caller should check <br>//   the latest COMMDLG error by calling CommDlgExtendedError(). <br>// <br>///////////////////////////////////////////////////////////////////// <br> <br>HDC SelectPrinter(HWND hWnd) <br>{ <br>    // Local variables <br>    BOOL      bPrintDlg;        // Return code from PrintDlg function <br>    PRINTDLG  pd;               // Printer dialog structure <br>    DWORD     dwError; <br>    HDC       hDC;              // DC to printer <br> <br>    //  Initialize variables <br>    hDC = NULL; <br>#ifdef _DEBUG <br>    memset(&amp;pd, UNINIT_BYTE, sizeof(PRINTDLG)); <br>#endif <br> <br>    /* Initialize the PRINTDLG members. */ <br> <br>    pd.lStructSize = sizeof(PRINTDLG); <br>    pd.hwndOwner = hWnd; <br>    pd.Flags = PD_RETURNDC | PD_PRINTSETUP; <br>    pd.hDevMode = (HANDLE) NULL; <br>    pd.hDevNames = (HANDLE) NULL; <br>    pd.hDC = (HDC) NULL; <br>    pd.nFromPage = 1; <br>    pd.nToPage = 1; <br>    pd.nMinPage = 0; <br>    pd.nMaxPage = 0; <br>    pd.nCopies = 1; <br>    pd.hInstance = (HANDLE) NULL; <br>    pd.lCustData = 0L; <br>    pd.lpfnPrintHook = (LPPRINTHOOKPROC) NULL; <br>    pd.lpfnSetupHook = (LPSETUPHOOKPROC) NULL; <br>    pd.lpPrintTemplateName = (LPTSTR) NULL; <br>    pd.lpSetupTemplateName = (LPTSTR)  NULL; <br>    pd.hPrintTemplate = (HANDLE) NULL; <br>    pd.hSetupTemplate = (HANDLE) NULL; <br> <br>    // Display the PRINT dialog box. <br>    bPrintDlg = PrintDlg(&amp;pd); <br>    if (!bPrintDlg)  // Either no changes, or a common dialog error occured <br>    { <br>        dwError = CommDlgExtendedError(); <br>        if (dwError != 0) <br>        { <br>            return(NULL); <br>        } <br>    } <br>    else // Passed call, set up DC <br>    { <br>        ASSERT(pd.hDC != NULL); // HDC should never be NULL if we passed the call <br>        hDC = pd.hDC; <br>    } <br>    return(hDC); <br>}   // End of SelectPrinter <br> <br> <br>// private functions <br> <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  GetPrinterDC <br>// <br>//  Description: <br>//    Obtains a DC from the specified friendly name. <br>// <br>//  Parameters: <br>//    @@@ <br>// <br>//  Returns: <br>//    HDC <br>// <br>//  Comments: <br>// <br>// <br>////////////////////////////////////////////////////////////////////////// <br>HDC GetPrinterDC(LPTSTR lpszFriendlyName, PDEVMODE pDevMode) <br>{ <br>    HDC     hDC; <br>    BOOL    bFreeDevMode = FALSE; <br> <br> <br>    //  Initialize variables <br>    hDC = NULL; <br> <br>    if (lpszFriendlyName != NULL) <br>    { <br>        // Make sure that we have a devmode. <br>        if (NULL == pDevMode) <br>        { <br>            pDevMode = GetDefaultPrinterDevMode(lpszFriendlyName); <br>            bFreeDevMode = TRUE; <br>        } <br> <br>        // Now get a DC for the printer <br>        hDC = CreateDC(NULL, lpszFriendlyName, NULL, pDevMode); <br> <br>        // Free devmode if created in routine. <br>        if (bFreeDevMode) <br>        { <br>            GlobalFree((HANDLE)pDevMode); <br>        } <br>    } <br>    else <br>    { <br>        DebugMsg(__TEXT("GetPrinterDC:  lpszFriendlyName == NULL")); <br>    } <br> <br>    return hDC; <br>}   // End of function GetPrinterDC <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  GetDefaultPrinterName <br>// <br>//  Description: <br>//    Obtains the name of the default printer. <br>// <br>//  Parameters: <br>//    none <br>// <br>//  Returns: <br>//    LPTSTR   Name of printer, or NULL if failed. <br>// <br>//  Comments: <br>// <br>// <br>////////////////////////////////////////////////////////////////////////// <br>LPTSTR GetDefaultPrinterName(void) <br>{ <br>    // Local variables <br>    LPTSTR     lpszDefaultPrinter = NULL; <br> <br>    if (IS_WIN95) <br>    { <br> <br>        lpszDefaultPrinter = GetRegistryString(HKEY_CURRENT_CONFIG, <br>                                               __TEXT("SYSTEM\\CurrentControlSet\\Control\\Print\\Printers"), <br>                                               __TEXT("Default")); <br>    } <br>    else if (IS_NT) <br>    { <br>        TCHAR szTemp[MAX_PATH]; <br>        LPTSTR lpszTemp; <br> <br>        // Get Default printer name. <br>        GetProfileString(__TEXT("windows"), __TEXT("device"), __TEXT(""), <br>                         szTemp, sizeof(szTemp)); <br> <br>        if (lstrlen(szTemp) == 0) <br>        { <br>            // INVARIANT:  no default printer. <br>            return(NULL); <br>        } <br> <br>        // Terminate at first comma, just want printer name. <br>        lpszTemp = _tcschr(szTemp, ','); <br>        if (lpszTemp != NULL) <br>        { <br>            *lpszTemp = '\x0'; <br>        } <br>        lpszDefaultPrinter = CopyString((LPTSTR)szTemp); <br>    } <br>    return(lpszDefaultPrinter); <br>}   // End of function GetDefaultPrinterName <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  PopulatePrinterCombobox <br>// <br>//  Description: <br>//    Enumerates all printers into a ComboBox based upon the provided flags. <br>// <br>//  Parameters: <br>//    @@@ <br>// <br>//  Returns: <br>//    DWORD Number of printers enumerated.  -1 indicates failure. <br>// <br>//  Comments: <br>// <br>// <br>////////////////////////////////////////////////////////////////////////// <br>DWORD PopulatePrinterCombobox(HWND hDlg, int iControlId, LPTSTR lpszCurrentPrinter) <br>{ <br>    // Local variables <br>    DWORD             dwReturnCode; <br>    DWORD             dwIndex; <br>    DWORD             dwNumPRN; <br>    LPPRINTER_INFO_2  lpPrinterInfo2; <br>    HGLOBAL           hFree; <br> <br>    //  Initialize variables <br>    lpPrinterInfo2 = NULL; <br> <br>    // Initialize ComboBox <br>    SendDlgItemMessage(hDlg, iControlId, EM_LIMITTEXT, (WPARAM)MAX_PATH, 0L); <br>    SendDlgItemMessage(hDlg,  iControlId, CB_RESETCONTENT, (WPARAM)0, (LPARAM)0L); <br> <br>    dwNumPRN = SPL_EnumPrinters(PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS, NULL, 2, (LPVOID)&amp;lpPrinterInfo2); <br>    EnableWindow(GetDlgItem(hDlg, iControlId), (dwNumPRN != 0)); <br>    if (dwNumPRN &lt;= 0) <br>    { <br>        dwReturnCode = SendDlgItemMessage(hDlg, iControlId, CB_ADDSTRING, 0, (LPARAM)(LPTSTR)__TEXT("No printers installed")); <br>        dwReturnCode = SendDlgItemMessage(hDlg, iControlId, WM_SETTEXT, 0, (LPARAM)(LPTSTR)__TEXT("No printers installed")); <br>        return (dwNumPRN);  // No printers to deal with.  -1 if EnumPrinters call failed. <br>    } <br> <br>    if (lpPrinterInfo2 != NULL) // Got array of PRINTER_INFO structures <br>    { <br>        for (dwIndex =0; dwIndex &lt; dwNumPRN; dwIndex++) <br>        { <br>            dwReturnCode = SendDlgItemMessage(hDlg, iControlId, CB_ADDSTRING, 0, (LPARAM)(LPTSTR)lpPrinterInfo2[dwIndex].pPrinterName); <br>            if (dwReturnCode == CB_ERR) <br>            { <br>                return((DWORD)-1); <br>            } <br> <br>            // If this is the current printer, load it into edit control <br>            if (lstrcmpi((LPTSTR)lpPrinterInfo2[dwIndex].pPrinterName, lpszCurrentPrinter) == 0) <br>            { <br>                dwReturnCode = SendDlgItemMessage(hDlg, iControlId, WM_SETTEXT, 0, (LPARAM)(LPTSTR)lpPrinterInfo2[dwIndex].pPrinterName); <br>                if (dwReturnCode == CB_ERR) <br>                { <br>                    return((DWORD)-1); <br>                }  // CB_ERR <br>            }  // current printer <br>        } // for (dwIndex = 0 ... <br>    }  // if (lpPrinterInfo2 != NULL) <br>    else <br>    { <br>        return((DWORD)-1); <br>    } <br> <br>    // Free memory <br>    hFree = GlobalFree(lpPrinterInfo2); <br>    return(dwNumPRN); <br>}   // End of function PopulatePrinterCombobox <br> <br>//////////////////////////////////////////////////////////////////////////// <br>// <br>// FunctionName: SPL_EnumPrinters() <br>// <br>// Purpose: <br>// <br>// Parameters: <br>//    None. <br>// <br>// Return Value: <br>// <br>// Comments: <br>// <br>//////////////////////////////////////////////////////////////////////////// <br> <br>DWORD SPL_EnumPrinters(DWORD dwType, LPTSTR lpszName, DWORD dwLevel, LPVOID *lpvPrinterInfo) <br> <br>{ <br>    DWORD        dwSize; <br>    DWORD        dwPrinters; <br>    DWORD        dwNeeded    = 0; <br>    DWORD        dwErrorCode = 0; <br>    BOOL         bReturnCode; <br>    BOOL         bRC         = FALSE; <br>    LPBYTE       lpInfo      = NULL; <br> <br>    // Enumerate Printers. <br>    bReturnCode = EnumPrinters(dwType, lpszName, dwLevel, NULL, 0, &amp;dwSize, &amp;dwPrinters); <br> <br>    // If Return Code is TRUE, there is nothing to enumerate. <br>    if (bReturnCode) <br>    { <br>        DebugMsg(__TEXT("EnumPrinter():  No printers found\r\n")); <br>        return(0); <br>    } <br> <br>    // Since Return Code is FALSE, check LastError. <br>    // If LastError is any thing other than allocate size error, flag and exit. <br>    dwErrorCode = GetLastError(); <br>    if (dwErrorCode != ERROR_INSUFFICIENT_BUFFER) <br>    { <br>        return((DWORD)-1); <br>    } <br> <br>    // Loop until we have size right. <br>    while (!bRC) <br>    { <br>        if (NULL != (lpInfo = (LPBYTE)GlobalAlloc(GPTR, dwSize))) <br>        { <br>#ifdef _DEBUG <br>            memset(lpInfo, UNINIT_BYTE, dwSize); <br>#endif <br>            // Enumerate <br>            bRC = EnumPrinters(dwType, lpszName, dwLevel, lpInfo, dwSize, &amp;dwNeeded, &amp;dwPrinters); <br>            if (!bRC) <br>            { <br>                dwErrorCode = GetLastError(); <br> <br>                // If anything other than allocate size error, flag and exit. <br>                if (dwErrorCode != ERROR_INSUFFICIENT_BUFFER) <br>                { <br>                    return((DWORD)-1); <br>                } <br>                else <br>                { <br>                    GlobalFree(lpInfo); <br>                    lpInfo = NULL; <br>                    dwSize = dwNeeded; <br>                } <br>            } // if (!bRC) <br>            else  // EnumPrinters returned success <br>            { <br>                *lpvPrinterInfo = lpInfo;  // Save pointer to PRINTER_INFO structure <br>            } <br>        } <br>        else <br>        { <br>            return((DWORD)-1); <br>        } <br>    } <br>    return(dwPrinters); <br>}  // End of function SPL_EnumPrinters <br> <br>//////////////////////////////////////////////////////////////////////////// <br>// <br>//  FUNCTION:  PrintDIB(HANDLE hDIB, HDC hDC, int x, int y, int dx, int dy) <br>// <br>//  PURPOSE:  Set the DIB bits to the printer DC. <br>// <br>//////////////////////////////////////////////////////////////////////////// <br>BOOL PrintDIB (HANDLE hDIB, HDC hDC, int xOrigin, int yOrigin, int xSize, int ySize, BOOL bStretch) <br>{ <br>    int                 iBits; <br>    HCURSOR             hCurSave; <br>    LPBITMAPINFOHEADER  lpDIB; <br>    LPBITMAPINFOHEADER  lpbi; <br> <br> <br>    // Initailize variables <br>    START_WAIT_CURSOR(hCurSave);  // put up busy cursor <br> <br>    lpDIB = (LPBITMAPINFOHEADER)GlobalLock(hDIB); <br> <br>    // If size &gt; BITMAPINFOHEADER header then <br>    // need to convert to BITMAPINFOHEADER. <br>    lpbi = lpDIB; <br>#ifdef OSR2 <br>    if (sizeof(BITMAPINFOHEADER) &lt; lpDIB-&gt;biSize) <br>    { <br>        DWORD dwColorTableSize; <br>        DWORD dwHeaderDataSize; <br> <br>        // Allocate Bitmapinfo memory. <br>        dwHeaderDataSize = sizeof(BITMAPINFOHEADER) + (lpDIB-&gt;biCompression == BI_BITFIELDS ? 12 : 0); <br>        dwColorTableSize = NumColorsInDIB(lpDIB) * sizeof(RGBQUAD); <br>        lpbi = (LPBITMAPINFOHEADER) GlobalAlloc(GPTR, dwHeaderDataSize + dwColorTableSize); <br>        if (NULL == lpbi) <br>        { <br>            return FALSE; <br>        } <br> <br>        // Convert header data into bitmapinfo header. <br>        memcpy(lpbi, lpDIB, dwHeaderDataSize); <br>        lpbi-&gt;biSize = sizeof(BITMAPINFOHEADER); <br> <br>        // Copy color table if any. <br>        if (0 != dwColorTableSize) <br>            memcpy((LPBYTE)lpbi + dwHeaderDataSize, (LPBYTE)lpDIB + lpDIB-&gt;biSize, dwColorTableSize); <br>    } <br>#endif <br> <br>    if (bStretch) <br>    { <br>        iBits = StretchDIBits(hDC, <br>                              xOrigin, yOrigin, <br>                              xSize, ySize, <br>                              0, 0, <br>                              BITMAPWIDTH(lpbi), abs(BITMAPHEIGHT(lpbi)), <br>                              FindDIBBits(lpDIB), <br>                              (LPBITMAPINFO)lpbi, <br>                              DIB_RGB_COLORS, <br>                              SRCCOPY); <br>    } <br>    else <br>    { <br>        iBits  =   SetDIBitsToDevice (hDC,                                  // hDC <br>                                      xOrigin,                              // DestX <br>                                      yOrigin,                              // DestY <br>                                      BITMAPWIDTH(lpbi),                    // nDestWidth <br>                                      abs(BITMAPHEIGHT(lpbi)),              // nDestHeight <br>                                      0,                                    // SrcX <br>                                      0,                                    // SrcY <br>                                      0,                                    // nStartScan <br>                                      abs(BITMAPHEIGHT(lpbi)),              // nNumScans <br>                                      FindDIBBits(lpDIB), <br>                                      (LPBITMAPINFO) lpbi,                  // lpBitsInfo <br>                                      DIB_RGB_COLORS);                      // wUsage <br>    } <br>    END_WAIT_CURSOR(hCurSave);   // restore cursor <br>    if (lpbi != lpDIB) <br>    { <br>        GlobalFree((HANDLE)lpbi); <br>    } <br>    GlobalUnlock(hDIB); <br>    return((iBits != 0) &amp;&amp; (iBits != GDI_ERROR)); <br>} <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  PrintImage <br>// <br>//  Description: <br>//    Prints the image to the printer specified within the DIBINFO structure. <br>// <br>//  Parameters: <br>//    @@@ <br>// <br>//  Returns: <br>//    BOOL <br>// <br>//  Comments: <br>// <br>// <br>////////////////////////////////////////////////////////////////////////// <br>BOOL PrintImage(HWND hWnd) <br>{ <br>    // Local variables <br>    LPBITMAPINFOHEADER lpBi; <br>    int               xSize, ySize, xRes, yRes, dx, dy; <br>    LPDIBINFO         lpDIBInfo; <br>    HDC               hDC; <br>    HANDLE            hDIB; <br>    int               iICMMode, iPrevICMMode; <br>    int               iXOrigin, iYOrigin; <br>    BOOL              bRC;                    // general return code <br>    BOOL              bStretch;     // TRUE if to use StretchDIBits, <br>                                    // FALSE if to use SetDIBitsToDevice <br>    TCHAR             stPrintMsg[MAX_PATH*2]; <br>    HANDLE            hDIBPrinter; <br>    DWORD             dwLCSIntent; <br> <br> <br>    //  Initialize variables <br>    hDIBPrinter = NULL; <br>    lpDIBInfo = GetDIBInfoPtr(hWnd); <br>    if (NULL == lpDIBInfo) <br>    { <br>        SetLastError(ERROR_INVALID_DATA);; <br>        return(FALSE); <br>    } <br>    hDIB = lpDIBInfo-&gt;hDIB; <br>    if (!ConvertIntent(lpDIBInfo-&gt;dwRenderIntent, ICC_TO_LCS, &amp;dwLCSIntent)) <br>    { <br>        ErrMsg(hWnd, __TEXT("Invalid Intent.  Aborting Print process")); <br>    } <br> <br> <br>    if (CHECK_DWFLAG(lpDIBInfo-&gt;dwICMFlags, ICMVFLAGS_ICM20) <br>        &amp;&amp; (CHECK_DWFLAG(lpDIBInfo-&gt;dwICMFlags, ICMVFLAGS_ENABLE_ICM))) <br>    { <br>        // ICM On, using outside DC, a.k.a. ICM20 <br>        DebugMsg(__TEXT("PrintImage:  Outside DC, ICM Enabled\r\n")); <br> <br>        // Create transform of the original bits to the printer <br>        ASSERT(NULL != lpDIBInfo-&gt;lpszPrinterProfile); <br>        hDIBPrinter  = TransformDIBOutsideDC(lpDIBInfo-&gt;hDIB, <br>                                             lpDIBInfo-&gt;bmFormat, <br>                                             lpDIBInfo-&gt;lpszPrinterProfile, <br>                                             NULL, <br>                                             USE_BITMAP_INTENT, NULL, 0); <br>        if (NULL == hDIBPrinter) <br>        { <br>            ErrMsg(hWnd, __TEXT("PrintImage:  Unable to transform DIB")); <br>            return(FALSE); <br>        } <br>        else // Transform worked <br>        { <br>            hDIB = hDIBPrinter; <br>        } <br>    } <br>    ASSERT(NULL != hDIB); <br>    lpBi = GlobalLock(hDIB); <br> <br>    // Initialize printing <br>    hDC = InitPrinting(hWnd, lpDIBInfo-&gt;lpszPrinterName, lpDIBInfo-&gt;pDevMode); <br>    if (NULL != hDC) <br>    { <br>        // Get addresses of dialog procs <br>        glpfnPrintDlgProc = (FARPROC)&amp;PrintDlgProc; <br>        glpfnAbortProc = (FARPROC)&amp;AbortProc; <br> <br>        // Create the printing dialog <br>        ghDlgPrint = CreateDialog(ghInst, MAKEINTRESOURCE(IDD_PRINTING), ghWndParent, (DLGPROC)glpfnPrintDlgProc); <br> <br>        EnableWindow( ghWndParent, FALSE);  // Disable Parent <br>        CenterWindow(ghDlgPrint, ghWndParent); <br>        wsprintf(stPrintMsg, __TEXT("Printing image\r\n\r\n%s\r\n\r\nto\r\n\r\n%s"), lpDIBInfo-&gt;lpszImageFileName, lpDIBInfo-&gt;lpszPrinterName); <br>        SetWindowText(GetDlgItem(ghDlgPrint, IDC_PRINT_FILENAME), (LPTSTR)stPrintMsg); <br>        ShowWindow(ghDlgPrint, SW_SHOW); <br> <br>        // Set the abort procedure <br>        if (SetAbortProc(hDC, (ABORTPROC)glpfnAbortProc) == SP_ERROR) <br>        { <br>            ErrMsg(hWnd, __TEXT("InitPrinting:  SetAbortProc FAILED, LastError = %ld"), GetLastError()); <br>        } <br> <br>        // Use the printable region of the printer to determine <br>        // the margins. <br>        iXOrigin = GetDeviceCaps(hDC, PHYSICALOFFSETX); <br>        iYOrigin = GetDeviceCaps(hDC, PHYSICALOFFSETY); <br> <br>        // Obtain info about printer resolution <br>        xSize = GetDeviceCaps(hDC, HORZRES); <br>        ySize = GetDeviceCaps(hDC, VERTRES); <br>        xRes  = GetDeviceCaps(hDC, LOGPIXELSX); <br>        yRes  = GetDeviceCaps(hDC, LOGPIXELSY); <br> <br>        // Stretch to best fit, if necessary.  Maintain the same aspect ratio. <br>        if (CHECK_DWFLAG(lpDIBInfo-&gt;dwPrintOption,ICMV_PRINT_BESTFIT)) <br>        { <br>            bStretch = TRUE; <br>            dy = ySize - (yRes/2); <br>            dx = ((int)((long)dy * BITMAPWIDTH(lpBi)/abs(BITMAPHEIGHT(lpBi)) )); <br> <br>            // Make sure the image still fits. <br>            if (dx &gt; xSize) <br>            { <br>                dx = xSize - xRes/2; <br>                dy = ((int)((long)dx * abs(BITMAPHEIGHT(lpBi))/BITMAPWIDTH(lpBi))); <br>            } <br>        } <br>        else // Actual size <br>        { <br>            bStretch = FALSE; <br>            dx = BITMAPWIDTH(lpBi); <br>            dy = abs(BITMAPHEIGHT(lpBi)); <br>        } <br> <br>        // Set ICM mode according to properties set in ICMINFO structure <br>        iICMMode = ICM_OFF; <br>        if (CHECK_DWFLAG(lpDIBInfo-&gt;dwICMFlags, ICMVFLAGS_ENABLE_ICM)) <br>        { <br>            if (!CHECK_DWFLAG(lpDIBInfo-&gt;dwICMFlags, ICMVFLAGS_ICM20)) <br>            { <br>                TCHAR   stProfile[MAX_PATH]; <br> <br> <br>                // ICM enabled, using ICM10--inside DC <br> <br>                iICMMode = ICM_ON; <br>                wsprintf(stProfile, __TEXT("%s\\%s"), gstProfilesDir, lpDIBInfo-&gt;lpszPrinterProfile); <br>                bRC = SetICMProfile(hDC, (LPTSTR)stProfile); <br>                DebugMsg(__TEXT("PrintImage:  Inside DC using profile \"%s\".\r\n"), stProfile); <br>                if (!bRC) <br>                { <br>                    DebugMsg(__TEXT("Print.C, PrintImage:  SetICMProfile() FAILED!!\r\n")); <br>                } <br>            } <br>            else <br>            { <br>                iICMMode = ICM_DONE_OUTSIDEDC; <br>            } <br>        } <br>        iPrevICMMode = SetICMMode(hDC, iICMMode);  // Explicitly set ICMMode--don't count on any behavior <br>        if (0 == iPrevICMMode) <br>        { <br>            DebugMsg(__TEXT("PRINT.C : PrintImage : SetICMMode(%d) FAILED \r\n"), iICMMode); <br>        } <br>        PrintDIB(hDIB, hDC, iXOrigin, iYOrigin, dx, dy, bStretch); <br> <br>        // Terminate printing and delete the printer DC <br>        TermPrinting(hDC); <br>        DeleteDC(hDC); <br>    } <br> <br>    // Delete DIB transform for printer if necessary <br>    GlobalUnlock(hDIB); <br>    if (NULL != hDIBPrinter) <br>    { <br>        GlobalFree(hDIBPrinter); <br>    } <br> <br>    GlobalUnlock(GlobalHandle(lpDIBInfo)); <br> <br>    return TRUE; <br>}   // End of function PrintImage <br> <br> <br>// ////////////////////////////////////////////////////////////////////////// <br>// <br>//  FUNCTION:  PrintDlgProc (hWnd, unsigned , WORD , DWORD ) <br>// <br>//  PURPOSE:  Dialog function for the "Cancel Printing" dialog. It sets <br>//              the abort flag if the user presses &lt;Cancel&gt;. <br>// <br>// ////////////////////////////////////////////////////////////////////////// <br>BOOL FAR PASCAL PrintDlgProc (HWND hDlg, unsigned iMessage, WORD wParam, DWORD lParam) <br>{ <br> <br>    lParam = lParam;  // Eliminates 'unused formal parameter' warning <br>    wParam = wParam;  // Eliminates 'unused formal parameter' warning <br> <br>    switch (iMessage) <br>    { <br>        case WM_INITDIALOG: <br>            EnableMenuItem (GetSystemMenu (hDlg, FALSE), SC_CLOSE, MF_GRAYED); <br>            break; <br> <br>        case WM_COMMAND: <br>            gbUserAbort = TRUE; <br>            EnableWindow (ghWndParent, TRUE); <br>            DestroyWindow (hDlg); <br>            ghDlgPrint = 0; <br>            break; <br> <br>        default: <br>            return(FALSE); <br>    } <br>    return(TRUE); <br>} <br> <br>// ////////////////////////////////////////////////////////////////////////// <br>// <br>//  FUNCTION:  AbortProc (HDC hPrnDC, short nCode) <br>// <br>//  PURPOSE:  Checks message queue for messages from the "Cancel Printing" <br>//              dialog. If it sees a message, (this will be from a print <br>//              cancel command), it terminates. <br>// <br>//  RETURNS:  Inverse of Abort flag <br>// <br>// ////////////////////////////////////////////////////////////////////////// <br>BOOL FAR PASCAL AbortProc (HDC hPrnDC, short nCode) <br>{ <br>    MSG   msg; <br> <br>    nCode = nCode;  // Eliminates 'unused formal paramater' warning <br>    hPrnDC = hPrnDC;  // Eliminates 'unused formal paramater' warning <br>    while (!gbUserAbort &amp;&amp; PeekMessage (&amp;msg, NULL, 0, 0, PM_REMOVE)) <br>    { <br>        if (!ghDlgPrint || !IsDialogMessage(ghDlgPrint, &amp;msg)) <br>        { <br>            TranslateMessage (&amp;msg); <br>            DispatchMessage (&amp;msg); <br>        } <br>    } <br>    return(!gbUserAbort); <br>} <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  InitPrinting <br>// <br>//  Description: <br>//    Sets up print job. <br>// <br>//  Parameters: <br>//    @@@ <br>// <br>//  Returns: <br>//    HDC PASCAL <br>// <br>//  Comments: <br>// <br>// <br>////////////////////////////////////////////////////////////////////////// <br>static HDC PASCAL InitPrinting(HWND hWnd, LPTSTR lpszFriendlyName, PDEVMODE pDevMode) <br>{ <br>    // Local variables <br>    HDC       hDC; <br>    DOCINFO   diDocInfo;      // Document infor for StartDoc call <br>    BOOL      bRetVal; <br> <br>    //  Initialize variables <br>    hDC = NULL; <br>    bRetVal = TRUE; <br>    gbUserAbort = FALSE; <br>    ghWndParent = hWnd; <br>    SetLastError(0); <br> <br>    hDC = GetPrinterDC(lpszFriendlyName, pDevMode); <br>    if (hDC == NULL) <br>    { <br>        DebugMsg(__TEXT("InitPrinting : GetPrinterDC returned NULL\r\n")); <br>        return(NULL); <br>    } <br> <br>    // Fill in the DOCINFO structure <br>    diDocInfo.cbSize = sizeof(DOCINFO); <br>    diDocInfo.lpszDocName = lpszFriendlyName; <br>    diDocInfo.lpszOutput = NULL; <br>    diDocInfo.lpszDatatype = NULL; <br>    diDocInfo.fwType = 0; <br> <br>    // Start the document <br>    if (StartDoc(hDC, &amp;diDocInfo)== SP_ERROR) <br>    { <br>        ErrMsg(hWnd, __TEXT("InitPrinting:  StartDoc FAILED")); <br>        bRetVal = FALSE; <br>        goto exit; <br>    } <br> <br>    // Start the page <br>    if (StartPage(hDC) == SP_ERROR) <br>    { <br>        DISPLAY_LASTERROR(LASTERROR_NOALLOC,GetLastError()); <br>        ErrMsg(hWnd, __TEXT("InitPrinting:  StartPage FAILED")); <br>        AbortDoc(hDC); <br>        bRetVal = FALSE; <br>    } <br> <br>    exit: <br>    if (bRetVal == FALSE) <br>    { <br>        EnableWindow(   ghWndParent,    TRUE); <br>        DestroyWindow(ghDlgPrint); <br>    } <br>    return(hDC); <br>}   // End of function InitPrinting <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  TermPrinting <br>// <br>//  Description: <br>//    Terminates the print job. <br>// <br>//  Parameters: <br>//    @@@ <br>// <br>//  Returns: <br>//    void PASCAL <br>// <br>//  Comments: <br>// <br>// <br>////////////////////////////////////////////////////////////////////////// <br>static void PASCAL TermPrinting(HDC hDC) <br>{ <br>    // Local variables <br>    if (EndPage(hDC) == SP_ERROR) <br>    { <br>        ErrMsg(NULL, __TEXT("TermPrinting:  EndPage FAILED")); <br>    } <br>    if (EndDoc(hDC) == SP_ERROR) <br>    { <br>        ErrMsg(NULL, __TEXT("TermPrinting:  EndDoc FAILED")); <br>    } <br> <br>    // Dstroy the dialog <br>    EnableWindow(ghWndParent, TRUE); <br>    DestroyWindow(ghDlgPrint); <br>}   // End of function TermPrinting <br> <br> <br> <br> <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  GetDefaultPrinterDC <br>// <br>//  Description: <br>//    Returns a DC for the default printer. <br>// <br>//  Parameters: <br>//    @@@ <br>// <br>//  Returns: <br>//    HDC <br>// <br>//  Comments: <br>// <br>// <br>////////////////////////////////////////////////////////////////////////// <br>HDC GetDefaultPrinterDC() <br>{ <br>    HDC     hDC; <br>    LPTSTR  lpszPrinterName; <br> <br> <br>    //  Initialize variables <br>    hDC = NULL; <br> <br>    lpszPrinterName = GetDefaultPrinterName(); <br>    if (lpszPrinterName != NULL) <br>    { <br>        hDC = GetPrinterDC(lpszPrinterName, NULL); <br>        GlobalFree(lpszPrinterName); <br>    } <br>    else <br>    { <br>        DebugMsg(__TEXT("GetDefaultPrinterDC:  Could not obtain default printer name.\r\n")); <br>    } <br> <br>    return hDC; <br>}   // End of function GetDefaultPrinterDC <br> <br> <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  GetDefaultPrinterDevMode <br>// <br>//  Description: <br>//    Returns a printer's default devmode. <br>// <br>//  Parameters: <br>//    @@@ <br>// <br>//  Returns: <br>//    PDEVMODE <br>// <br>//  Comments: <br>// <br>// <br>////////////////////////////////////////////////////////////////////////// <br>PDEVMODE GetDefaultPrinterDevMode(LPTSTR lpszPrinterName) <br>{ <br>    LONG        lDevModeSize; <br>    HANDLE      hDevMode; <br>    PDEVMODE    pDevMode = NULL; <br> <br> <br>    lDevModeSize = DocumentProperties(NULL, NULL, lpszPrinterName, NULL, NULL, 0); <br>    if (lDevModeSize &gt; 0) <br>    { <br>        hDevMode = GlobalAlloc(GHND, lDevModeSize); <br>        pDevMode = (PDEVMODE) GlobalLock(hDevMode); <br>        DocumentProperties(NULL, NULL, lpszPrinterName, pDevMode, NULL, DM_OUT_BUFFER); <br>    } <br>    else <br>    { <br>        DebugMsg(__TEXT("GetDefaultPrinterDevMode:  Could not obtain printer's devmode.\r\n")); <br>    } <br> <br>    return pDevMode; <br>} <br> <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
