<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DEBUG.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3499"></a>DEBUG.C</h2>
<pre><code>//THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>//ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>//THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>// PARTICULAR PURPOSE. <br>// <br>// Copyright  1994-1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//  FILE: <br>//    DEBUG.C <br>// <br>//  PURPOSE: <br>//    Debugging routines. <br>// <br>//  PLATFORMS: <br>//    Windows 95, Windows NT <br>// <br>//  SPECIAL INSTRUCTIONS: N/A <br>// <br> <br>// Windows Header Files: <br>#pragma warning(disable:4001)   // Single-line comment warnings <br>#pragma warning(disable:4115)   // Named type definition in parentheses <br>#pragma warning(disable:4201)   // Nameless struct/union warning <br>#pragma warning(disable:4214)   // Bit field types other than int warnings <br>#pragma warning(disable:4514)   // Unreferenced inline function has been removed <br> <br>// Windows Header Files: <br>#include &lt;Windows.h&gt; <br>#include &lt;WindowsX.h&gt; <br>#include &lt;icm.h&gt; <br> <br> <br>// Restore the warnings--leave the single-line comment warning OFF <br>#pragma warning(default:4115)   // Named type definition in parentheses <br>#pragma warning(default:4201)   // Nameless struct/union warning <br>#pragma warning(default:4214)   // Bit field types other than int warnings <br>#pragma warning(default:4514)   // Unreferenced inline function has been removed <br> <br>// C RunTime Header Files <br>#include &lt;stdio.h&gt; <br>#include &lt;TCHAR.H&gt; <br>#include &lt;stdlib.h&gt; <br> <br>// Local Header Files <br>#include "icmview.h" <br>#include "dibinfo.h" <br>#define I_AM_DEBUG <br>#include "Debug.h" <br>#undef I_AM_DEBUG <br> <br>// local definitions <br> <br>// default settings <br> <br>// external functions <br> <br>// external data <br> <br>// public data <br> <br>// private data <br> <br>// public functions <br> <br>// private functions <br> <br> <br> <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  _Assert <br>// <br>//  Description: <br>//    Replacement assertion function <br>// <br>//  Parameters: <br>//    LPSTR    Name of file <br>//    UINT      Line number@@@ <br>// <br>//  Returns: <br>//    void <br>// <br>//  Comments: <br>// <br>// <br>////////////////////////////////////////////////////////////////////////// <br>void _Assert(LPSTR strFile, UINT uiLine) <br>{ <br>    // Local variables <br>    char  stAssert[255]; <br> <br>    //  Initialize variables <br>    wsprintfA(stAssert, "Assertion failed %s, line %u\r\n", strFile, uiLine); <br>    OutputDebugStringA(stAssert); <br>} // End of function _Assert <br> <br>/////////////////////////////////////////////////////////////////////////// <br>// <br>//  FUNCTION: DebugMsg <br>// <br>//  PURPOSE: <br>//    To provide a printf type DebugMsg function. <br>// <br>//  PARAMETERS: <br>//    LPTSTR  Format string <br>//    &lt;variable arguments&gt;  printf-style arguments <br>// <br>//  RETURN VALUE: <br>//    void <br>// <br>//  COMMENTS: <br>// <br>/////////////////////////////////////////////////////////////////////////// <br> <br>void DebugMsg (LPTSTR lpszMessage,...) <br>{ <br>#ifdef _DEBUG <br>    va_list VAList; <br>    TCHAR   szMsgBuf[256]; <br> <br>    // Pass the variable parameters to wvsprintf to be formated. <br>    va_start(VAList, lpszMessage); <br>    wvsprintf(szMsgBuf, lpszMessage, VAList); <br>    va_end(VAList); <br> <br>    ASSERT(lstrlen((LPTSTR)szMsgBuf) &lt; MAX_DEBUG_STRING); <br>    OutputDebugString(szMsgBuf); <br>#endif <br>    lpszMessage = lpszMessage;  // Eliminates 'unused formal parameter' warning <br>} <br> <br>void DebugMsgA (LPSTR lpszMessage,...) <br>{ <br>#ifdef _DEBUG <br>    va_list VAList; <br>    char    szMsgBuf[256]; <br> <br>    // Pass the variable parameters to wvsprintf to be formated. <br>    va_start(VAList, lpszMessage); <br>    wvsprintfA(szMsgBuf, lpszMessage, VAList); <br>    va_end(VAList); <br> <br>    ASSERT(strlen((LPSTR)szMsgBuf) &lt; MAX_DEBUG_STRING); <br>    OutputDebugStringA(szMsgBuf); <br>#endif <br>    lpszMessage = lpszMessage;  // Eliminates 'unused formal parameter' warning <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////// <br>// <br>//  FUNCTION: ErrMsg <br>// <br>//  PURPOSE: <br>//    To provide a printf type error message box. <br>// <br>//  PARAMETERS: <br>//    LPTSTR  wsprintf-style format string <br>//    ...     formatting information <br>// <br>//  RETURN VALUE: <br>//    Value from MessageBox function; 0 if failure, non-zero <br>//    otherwise.  For specific values, see MessageBox. <br>// <br>//  COMMENTS: <br>// <br>/////////////////////////////////////////////////////////////////////////// <br>int ErrMsg (HWND hwndOwner, LPTSTR lpszMessage,...) <br>{ <br>    va_list VAList; <br>    TCHAR   szMsgBuf[256]; <br> <br>    // Pass the variable parameters to wvsprintf to be formated. <br>    va_start(VAList, lpszMessage); <br>    wvsprintf(szMsgBuf, lpszMessage, VAList); <br>    va_end(VAList); <br> <br>    ASSERT(lstrlen((LPTSTR)szMsgBuf) &lt; MAX_DEBUG_STRING); <br>    return(MessageBox(hwndOwner, (LPCTSTR)szMsgBuf, (LPCTSTR)__TEXT("Error"), MB_ICONSTOP|MB_APPLMODAL)); <br>} <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  DumpMemory <br>// <br>//  Description: <br>//    Dumps values at specified memory. <br>// <br>//  Parameters: <br>//    LPVOID    Pointer to memory <br>//    UINT      Size of each element, i.e. 8 or 16 <br>//    UINT      Number of elements to dump. <br>// <br>//  Returns: <br>//    void <br>// <br>//  Comments: <br>//    -Need to add validation of uiElementSize. <br>//    -uiElementSize * uiNumElements should not exceed the size <br>//     of the buffer; otherwise, wacky and wonderful events will <br>//     take place. <br>// <br>////////////////////////////////////////////////////////////////////////// <br>void DumpMemory(LPBYTE lpbMem, UINT uiElementSize, UINT uiNumElements) <br>{ <br>    // Local variables <br>    UINT  uiIdx; <br> <br>    uiElementSize = uiElementSize; // Eliminates 'unused formal parameters' <br> <br>    // Initialize variables <br>    for (uiIdx = 0; uiIdx &lt; uiNumElements; uiIdx++) <br>    { <br>        if (uiIdx == 0 || ((uiIdx % 16) == 0)) <br>        { <br>            DebugMsg(__TEXT("\r\n0x%08X\t"), (DWORD)(lpbMem + (uiIdx))); <br>        } <br>        DebugMsg(__TEXT("%02x "), (WORD)*(lpbMem + uiIdx)); <br>    } <br>} // End of function DumpMemory <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  DumpProfile <br>// <br>//  Description: <br>//    Dumps the PROFILE structure provided. <br>// <br>//  Parameters: <br>//    PPROFILE  Pointer to the profile. <br>// <br>//  Returns: <br>//    void <br>// <br>//  Comments: <br>////////////////////////////////////////////////////////////////////////// <br>void DumpProfile(PPROFILE pProfile) <br>{ <br>    // Local variables <br>    TCHAR   stProfileType[MAX_PATH]; <br> <br>    // Initialize variables <br>    if (pProfile == NULL) <br>    { <br>        DebugMsg(__TEXT("DEBUG.C : DumpProfile : NULL pProfile\r\n")); <br>        return; <br>    } <br> <br>    // Set type string <br>    _tcscpy(stProfileType, __TEXT("UNKNOWN")); <br>    if (PROFILE_FILENAME == pProfile-&gt;dwType) <br>    { <br>        _tcscpy(stProfileType, __TEXT("FILE")); <br>    } <br>    if (PROFILE_MEMBUFFER == pProfile-&gt;dwType) <br>    { <br>        _tcscpy(stProfileType, __TEXT("MEMBUFFER")); <br>    } <br> <br>    DebugMsg(__TEXT("***** PROFILE *****\r\n")); <br>    DebugMsg(__TEXT("pProfile        0x%08lX\r\n"), pProfile); <br>    DebugMsg(__TEXT("dwType          %s\r\n"), stProfileType); <br>    DebugMsg(__TEXT("pProfileData    0x%08lX\r\n"), pProfile-&gt;pProfileData); <br>    if (PROFILE_FILENAME == pProfile-&gt;dwType) <br>    { <br>        DebugMsg(__TEXT("Filename        %s\r\n"), pProfile-&gt;pProfileData); <br>    } <br>    DebugMsg(__TEXT("cbDataSize      %ld\r\n\r\n"), pProfile-&gt;cbDataSize); <br>} // End of function DumpMemory <br> <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  DumpRectangle <br>// <br>//  Description: <br>//    Dumps the coordinates of a rectangle structure <br>// <br>//  Parameters: <br>//    LPTSTR    Comment <br>//    LPRECT    Rectangle to dump <br>// <br>//  Returns: <br>//    void <br>// <br>//  Comments: <br>// <br>// <br>////////////////////////////////////////////////////////////////////////// <br>void DumpRectangle(LPTSTR lpszDesc, LPRECT lpRect) <br>{ <br>    DebugMsg(__TEXT("%s:  %ld, %ld, %ld, %ld\r\n"), lpszDesc, lpRect-&gt;left, lpRect-&gt;top, lpRect-&gt;right, <br>             lpRect-&gt;bottom); <br>}   // End of function DumpRectangle <br> <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  SafeFree <br>// <br>//  Description: <br>//    Debug Free routine which checks lock counts and return codes. <br>// <br>//  Parameters: <br>//    @@@ <br>// <br>//  Returns: <br>//    HGLOBAL <br>// <br>//  Comments: <br>//    This function assumes that the HGLOBAL object has been unlocked; <br>//    if not, the item will still be freed, but a warning message will <br>//    be displayed.  This is useful for tracking down items which have <br>//    been locked without being unlocked. <br>// <br>//    The last error value will be preserved if no error occurs in this <br>//    function.  If an error does occur, it will be passed to the calling <br>//    function. <br>// <br>////////////////////////////////////////////////////////////////////////// <br>HGLOBAL SafeFree(LPTSTR lpszFile, UINT uiLine, HGLOBAL hMemory) <br>{ <br>    // Local variables <br>    UINT      uiLockCount, uiFlags; <br>    DWORD     dwLastError; <br>    HGLOBAL   hFreed;                         // Return from GlobalFree <br>    TCHAR   szName[MAX_PATH], szExt[MAX_PATH]; <br> <br>    //  Initialize variables <br>    _tsplitpath(lpszFile, NULL, NULL, szName, szExt); <br>    wsprintf(lpszFile,__TEXT("%s%s"), szName, szExt); <br>    if (NULL == hMemory) <br>    { <br>        DebugMsg(__TEXT("%s(%lu) : SafeFree:  NULL hMem!!!  This will cause an exception!!!!   Fix it!!!\r\n"), lpszFile, uiLine); <br>        DebugBreak(); <br>        return(NULL); <br>    } <br>    SetLastError(0); <br> <br>    hFreed = GlobalFree(hMemory); <br>    if (NULL != hFreed) // unsuccessful free <br>    { <br>        dwLastError = GetLastError(); <br>        uiFlags = GlobalFlags(hMemory); <br>        uiLockCount = uiFlags &amp; GMEM_LOCKCOUNT; <br>        uiFlags = HIBYTE(LOWORD(uiFlags)); <br>        DebugMsg(__TEXT("SafeFree : &lt;%s(%lu)&gt; failed\tLastError = %ld, Flags = %lu, Lock Count = %lu\r\n"), <br>                 lpszFile, uiLine, dwLastError, uiFlags, uiLockCount); <br>    } <br>    return(hFreed); <br>}   // End of function SafeFree <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  SafeUnlock <br>// <br>//  Description: <br>//    Unlocks handle and displays the lock count and flags information. <br>// <br>//  Parameters: <br>//    @@@ <br>// <br>//  Returns: <br>//    BOOL <br>// <br>//  Comments: <br>// <br>// <br>////////////////////////////////////////////////////////////////////////// <br>BOOL SafeUnlock(LPTSTR lpszFile, UINT uiLine, HGLOBAL hMemory) <br>{ <br>    // Local variables <br>    BOOL    bUnlocked; <br>    UINT    uiLockCount,   uiFlags; <br>    DWORD   dwLastError; <br>    TCHAR   szName[MAX_PATH], szExt[MAX_PATH]; <br> <br>    //  Initialize variables <br>    _tsplitpath(lpszFile, NULL, NULL, szName, szExt); <br>    wsprintf(lpszFile, __TEXT("%s%s"), szName, szExt); <br> <br>    if (NULL == hMemory) <br>    { <br>        DebugMsg(__TEXT("%s(%lu) : SafeUnlock:  NULL hMem\r\n"), lpszFile, uiLine); <br>        return(0); <br>    } <br>    SetLastError(0); <br> <br>    bUnlocked = GlobalUnlock(hMemory); <br>    dwLastError = GetLastError(); <br>    uiFlags = GlobalFlags(hMemory); <br>    uiLockCount = uiFlags &amp; GMEM_LOCKCOUNT; <br>    if (0 != dwLastError) <br>    { <br>        uiFlags = HIBYTE(LOWORD(uiFlags)); <br>    } <br>    DebugMsg(__TEXT("SafeUnlock : &lt;%s(%lu)&gt;\tGlobalUnlock(0x%08lX) returned %4d w/LastError = %4ld, Lock Count = %4lu, Flags = %4lu\r\n"), <br>             lpszFile, uiLine, hMemory, bUnlocked, dwLastError, uiLockCount, uiFlags); <br>    return(bUnlocked); <br>}   // End of function SafeUnlock <br> <br> <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  SafeLock <br>// <br>//  Description: <br>//    Locks memory and reports lock count. <br>// <br>//  Parameters: <br>//    @@@ <br>// <br>//  Returns: <br>//    LPVOID <br>// <br>//  Comments: <br>// <br>// <br>////////////////////////////////////////////////////////////////////////// <br>LPVOID SafeLock(LPTSTR lpszFile, UINT uiLine, HGLOBAL hMemory) <br>{ <br>    // Local variables <br>    LPVOID  lpMem; <br>    UINT    uiLockCount, uiFlags; <br>    DWORD   dwLastError; <br>    TCHAR   szName[MAX_PATH], szExt[MAX_PATH]; <br> <br>    //  Initialize variables <br>    _tsplitpath(lpszFile, NULL, NULL, szName, szExt); <br>    wsprintf(lpszFile, __TEXT("%s%s"), szName, szExt); <br>    if (NULL == hMemory) <br>    { <br>        DebugMsg(__TEXT("%s(%lu) : SafeLock:  NULL hMem\r\n"), lpszFile, uiLine); <br>        return((LPVOID)NULL); <br>    } <br>    SetLastError(0); <br> <br>    lpMem = GlobalLock(hMemory); <br>    dwLastError = GetLastError(); <br>    uiFlags = GlobalFlags(hMemory); <br>    uiLockCount = uiFlags &amp; GMEM_LOCKCOUNT; <br>    uiFlags = HIBYTE(LOWORD(uiFlags)); <br> <br>    DebugMsg(__TEXT("SafeLock : &lt;%s(%lu)&gt;\tGlobalLock(0x%08lX) returned 0x%08lX w/LastError = %ld, Lock Count = %lu, Flags = %lu\r\n"), <br>             lpszFile, uiLine, hMemory, lpMem, dwLastError, uiLockCount, uiFlags); <br>    return(lpMem); <br>}   // End of function SafeLock <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  FormatLastError <br>// <br>//  Description: <br>//    Allocates and formats a string of LastError's text-equivalent message. <br>//    If the caller requests, the message will be displayed and the memory <br>//    will be deallocated. <br>// <br>//  Parameters: <br>//    LPTSTR  Name of file where error occured <br>//    UINT    Line of file at which point error occured <br>//    DWORD Numeric value of LastError <br>//    UINT  Display and free indicator <br>//            LASTERROR_NOALLOC  Display via DebugMsg and deallocate <br>//            LASTERROR_ALLOC    Return pointer to allocated string <br>// <br>//  Returns: <br>//    BOOL <br>// <br>//  Comments: <br>//    Caller must free memory returned by this function. <br>// <br>////////////////////////////////////////////////////////////////////////// <br>LPTSTR FormatLastError(LPTSTR lpszFile, UINT uiLine, UINT uiOutput, DWORD dwLastError) <br>{ <br>    // Local variables <br>    LPTSTR  lpszLastErrorMsg; <br>    LPTSTR  lpszDebugMsg; <br>    DWORD   cbBytes; <br> <br>    //  Initialize variables <br>    lpszLastErrorMsg = NULL; <br>    cbBytes = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER <br>                            | FORMAT_MESSAGE_FROM_SYSTEM, <br>                            NULL, <br>                            dwLastError, <br>                            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), //The user default language <br>                            (LPTSTR) &amp;lpszLastErrorMsg, <br>                            0, <br>                            NULL ); <br> <br>    if (0 == cbBytes) // Error occured in FormatMessage <br>    { <br>        SetLastError(dwLastError); // restore the last error to time of call <br>    } <br> <br>    // Create the error message <br>    lpszDebugMsg = GlobalAlloc(GPTR, ((cbBytes + 512) * sizeof(TCHAR))); <br>    ASSERT(NULL != lpszDebugMsg); <br>    wsprintf(lpszDebugMsg, __TEXT("&lt;%s(%lu)&gt;:\r\n\tLastError(ld, lu) = (%ld, %lu)\r\n\t\t%s\r\n"), <br>             lpszFile, <br>             uiLine, <br>             dwLastError, <br>             dwLastError, <br>             NULL != lpszLastErrorMsg ? lpszLastErrorMsg : __TEXT("UNKNOWN LASTERROR")); <br> <br>    // Free the buffer memory if requested <br>    if (LASTERROR_NOALLOC == uiOutput) <br>    { <br>        DebugMsg(lpszDebugMsg); <br>        GlobalFree(lpszDebugMsg); <br>    } <br> <br>    // Always free the string created by FormatMessage <br>    if (NULL != lpszLastErrorMsg) <br>    { <br>        GlobalFree(lpszLastErrorMsg); <br>    } <br>    return(lpszDebugMsg); <br>}   // End of function FormatLastError <br> <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  DumpBITMAPFILEHEADER <br>// <br>//  Description: <br>//    Dumps the contents of a BITMAPFILEHEADER. <br>// <br>//  Parameters: <br>//    @@@ <br>// <br>//  Returns: <br>//    void <br>// <br>//  Comments: <br>// <br>// <br>////////////////////////////////////////////////////////////////////////// <br>void DumpBITMAPFILEHEADER(LPBITMAPFILEHEADER lpBmpFileHeader) <br>{ <br>    // Local variables <br>    DebugMsg(__TEXT("////////////////// BITMAPFILEHEADER ///////////////////\r\n")); <br>    DebugMsg(__TEXT("sizeof(BITMAPFILEHEADER)    %ld\r\n"), sizeof(BITMAPFILEHEADER)); <br>    DebugMsg(__TEXT("bfType                      0x%04x\r\n"), lpBmpFileHeader-&gt;bfType); <br>    DebugMsg(__TEXT("bfSize                      %ld\r\n"), lpBmpFileHeader-&gt;bfSize); <br>    DebugMsg(__TEXT("bfReserved1                 %d\r\n"), lpBmpFileHeader-&gt;bfReserved1); <br>    DebugMsg(__TEXT("bfReserved2                 %d\r\n"), lpBmpFileHeader-&gt;bfReserved1); <br>    DebugMsg(__TEXT("bfOffBits                   %ld\r\n"), lpBmpFileHeader-&gt;bfOffBits); <br>    DebugMsg(__TEXT("///////////////////////////////////////////////////////\r\n")); <br> <br>    //  Initialize variables <br> <br>}   // End of function DumpBITMAPFILEHEADER <br> <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  DumpBITMAPINFOHEADER <br>// <br>//  Description: <br>//    Dumps a BITMAPINFO header structure. <br>// <br>//  Parameters: <br>//    @@@ <br>// <br>//  Returns: <br>//    void <br>// <br>//  Comments: <br>// <br>// <br>////////////////////////////////////////////////////////////////////////// <br>void DumpBmpHeader(LPVOID lpvBmpHeader) <br>{ <br>    // Local variables <br>    LPBITMAPV5HEADER  lpBmpV5Header; <br>    TCHAR             stNumText[MAX_PATH]; <br> <br>    //  Initialize variables <br>    lpBmpV5Header = (LPBITMAPV5HEADER)lpvBmpHeader; <br> <br>    switch (lpBmpV5Header-&gt;bV5Size) <br>    { <br>        case sizeof(BITMAPCOREHEADER): <br>            _tcscpy(stNumText,__TEXT("BITMAPCOREHEADER")); <br>            break; <br> <br>        case sizeof(BITMAPINFOHEADER): <br>            _tcscpy(stNumText, __TEXT("BITMAPINFOHEADER")); <br>            break; <br> <br>        case sizeof(BITMAPV4HEADER): <br>            _tcscpy(stNumText, __TEXT("BITMAPV4HEADER")); <br>            break; <br> <br>        case sizeof(BITMAPV5HEADER): <br>            _tcscpy(stNumText,__TEXT("BITMAPV5HEADER")); <br>            break; <br> <br>        default: <br>            _tcscpy(stNumText, __TEXT("UNKNOWN HEADER SIZE")); <br>            break; <br>    } <br>    DebugMsg(__TEXT("/////////////////// %s /////////////////////\r\n"), stNumText); <br>    DebugMsg(__TEXT("HeaderSize        %ld\r\n"), lpBmpV5Header-&gt;bV5Size); <br>    DebugMsg(__TEXT("Width             %lu\r\n"), lpBmpV5Header-&gt;bV5Width); <br>    DebugMsg(__TEXT("Height            %lu\r\n"), lpBmpV5Header-&gt;bV5Height); <br>    DebugMsg(__TEXT("Planes            %d\r\n"), lpBmpV5Header-&gt;bV5Planes); <br>    DebugMsg(__TEXT("BitCount          %d\r\n"), lpBmpV5Header-&gt;bV5BitCount); <br>    if ( sizeof(BITMAPCOREHEADER)== lpBmpV5Header-&gt;bV5Size) goto End; <br> <br>    switch (lpBmpV5Header-&gt;bV5Compression) <br>    { <br>        case BI_RGB: <br>            _tcscpy(stNumText, __TEXT("BI_RGB")); <br>            break; <br> <br>        case BI_RLE8: <br>            _tcscpy(stNumText, __TEXT("BI_RLE8")); <br>            break; <br> <br>        case BI_RLE4: <br>            _tcscpy(stNumText,__TEXT("BI_RLE4")); <br>            break; <br> <br>        case BI_BITFIELDS: <br>            _tcscpy(stNumText, __TEXT("BI_BITFIELDS")); <br>            break; <br> <br>        default: <br>            _tcscpy(stNumText,__TEXT("Unknown Compression")); <br>            break; <br>    } <br>    DebugMsg(__TEXT("Compression       %s\r\n"), stNumText); <br>    DebugMsg(__TEXT("SizeImage         %ld\r\n"), lpBmpV5Header-&gt;bV5SizeImage); <br>    DebugMsg(__TEXT("XPelsPerMeter     %ld\r\n"), lpBmpV5Header-&gt;bV5XPelsPerMeter); <br>    DebugMsg(__TEXT("YPelsPerMeter     %ld\r\n"), lpBmpV5Header-&gt;bV5YPelsPerMeter); <br>    DebugMsg(__TEXT("ClrUsed           %ld\r\n"), lpBmpV5Header-&gt;bV5ClrUsed); <br>    DebugMsg(__TEXT("ClrImportant      %ld\r\n"), lpBmpV5Header-&gt;bV5ClrImportant); <br>    if (sizeof(BITMAPINFOHEADER) == lpBmpV5Header-&gt;bV5Size) goto End; <br> <br>    DebugMsg(__TEXT("Red Mask          0x%08lx\r\n"), lpBmpV5Header-&gt;bV5RedMask); <br>    DebugMsg(__TEXT("Green Mask        0x%08lx\r\n"), lpBmpV5Header-&gt;bV5GreenMask); <br>    DebugMsg(__TEXT("Blue Mask         0x%08lx\r\n"), lpBmpV5Header-&gt;bV5BlueMask); <br>    DebugMsg(__TEXT("Alpha Mask        0x%08lx\r\n"), lpBmpV5Header-&gt;bV5AlphaMask); <br> <br>    DebugMsg(__TEXT("CS Type           ")); <br>    switch (lpBmpV5Header-&gt;bV5CSType) <br>    { <br>        case PROFILE_LINKED: <br>            DebugMsg(__TEXT("LINKED\r\n")); <br>            break; <br> <br>        case PROFILE_EMBEDDED: <br>            DebugMsg(__TEXT("EMBEDDED\r\n")); <br>            break; <br> <br>        default: <br>            DebugMsg(__TEXT("0x%08lx\r\n"), lpBmpV5Header-&gt;bV5CSType); <br>            break; <br>    } <br> <br> <br>    DebugMsg(__TEXT("Gamma Red         %ld\r\n"), lpBmpV5Header-&gt;bV5GammaRed); <br>    DebugMsg(__TEXT("Gamma Green       %ld\r\n"), lpBmpV5Header-&gt;bV5GammaGreen); <br>    DebugMsg(__TEXT("Gamma Blue        %ld\r\n"), lpBmpV5Header-&gt;bV5GammaBlue); <br>    if (sizeof(BITMAPV4HEADER) == lpBmpV5Header-&gt;bV5Size) goto End; <br> <br>    DebugMsg(__TEXT("Intent            %ld\r\n"), lpBmpV5Header-&gt;bV5Intent); <br>    DebugMsg(__TEXT("ProfileData       %ld\r\n"), lpBmpV5Header-&gt;bV5ProfileData); <br>    DebugMsg(__TEXT("ProfileSize       %ld\r\n"), lpBmpV5Header-&gt;bV5ProfileSize); <br>    DebugMsg(__TEXT("Reserved          %ld\r\n"), lpBmpV5Header-&gt;bV5Reserved); <br> <br>    End: <br>    DebugMsg(__TEXT("///////////////////////////////////////////////////////\r\n")); <br>}   // End of function DumpBITMAPINFOHEADER <br> <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  DumpLogColorSpace <br>// <br>//  Description: <br>//    Dumps a LOGCOLORSPACE structure. <br>// <br>//  Parameters: <br>//    @@@ <br>// <br>//  Returns: <br>//    void <br>// <br>//  Comments: <br>// <br>// <br>////////////////////////////////////////////////////////////////////////// <br> <br>void DumpLogColorSpace(LPLOGCOLORSPACE pColorSpace) <br>{ <br>    DebugMsg(__TEXT("/////////////////// LOGCOLORSPACE /////////////////////\r\n")); <br>    DebugMsg(__TEXT("lcsSignature                       %#lx\r\n"), pColorSpace-&gt;lcsSignature); <br>    DebugMsg(__TEXT("lcsVersion                         %#lx\r\n"), pColorSpace-&gt;lcsVersion); <br>    DebugMsg(__TEXT("lcsSize                            %#lx\r\n"), pColorSpace-&gt;lcsSize); <br>    DebugMsg(__TEXT("lcsCSType                          %#lx\r\n"), pColorSpace-&gt;lcsCSType); <br>    DebugMsg(__TEXT("lcsIntent                          %#lx\r\n"), pColorSpace-&gt;lcsIntent); <br>    DebugMsg(__TEXT("lcsEndpoints.ciexyzRed.ciexyzX      %#lx\r\n"), pColorSpace-&gt;lcsEndpoints.ciexyzRed.ciexyzX); <br>    DebugMsg(__TEXT("lcsEndpoints.ciexyzRed.ciexyzY      %#lx\r\n"), pColorSpace-&gt;lcsEndpoints.ciexyzRed.ciexyzY); <br>    DebugMsg(__TEXT("lcsEndpoints.ciexyzRed.ciexyzZ      %#lx\r\n"), pColorSpace-&gt;lcsEndpoints.ciexyzRed.ciexyzZ); <br>    DebugMsg(__TEXT("lcsEndpoints.ciexyzGreen.ciexyzX    %#lx\r\n"), pColorSpace-&gt;lcsEndpoints.ciexyzGreen.ciexyzX); <br>    DebugMsg(__TEXT("lcsEndpoints.ciexyzGreen.ciexyzY    %#lx\r\n"), pColorSpace-&gt;lcsEndpoints.ciexyzGreen.ciexyzY); <br>    DebugMsg(__TEXT("lcsEndpoints.ciexyzGreen.ciexyzZ    %#lx\r\n"), pColorSpace-&gt;lcsEndpoints.ciexyzGreen.ciexyzZ); <br>    DebugMsg(__TEXT("lcsEndpoints.ciexyzBlue.ciexyzX     %#lx\r\n"), pColorSpace-&gt;lcsEndpoints.ciexyzBlue.ciexyzX); <br>    DebugMsg(__TEXT("lcsEndpoints.ciexyzBlue.ciexyzY     %#lx\r\n"), pColorSpace-&gt;lcsEndpoints.ciexyzBlue.ciexyzY); <br>    DebugMsg(__TEXT("lcsEndpoints.ciexyzBlue.ciexyzZ     %#lx\r\n"), pColorSpace-&gt;lcsEndpoints.ciexyzBlue.ciexyzZ); <br>    DebugMsg(__TEXT("lcsGammaRed                        %#lx\r\n"), pColorSpace-&gt;lcsGammaRed); <br>    DebugMsg(__TEXT("lcsGammaGreen                      %#lx\r\n"), pColorSpace-&gt;lcsGammaGreen); <br>    DebugMsg(__TEXT("lcsGammaBlue                       %#lx\r\n"), pColorSpace-&gt;lcsGammaBlue); <br>    DebugMsg(__TEXT("lcsFilename                        %s\r\n"), pColorSpace-&gt;lcsFilename); <br>    DebugMsg(__TEXT("///////////////////////////////////////////////////////\r\n")); <br>} <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  DumpCOLORMATCHSETUP <br>// <br>//  Description: <br>//    Dumps COLORMATCHSETUP structure <br>// <br>//  Parameters: <br>//    @@@ <br>// <br>//  Returns: <br>//    void <br>// <br>//  Comments: <br>// <br>// <br>////////////////////////////////////////////////////////////////////////// <br>void DumpCOLORMATCHSETUP(LPCOLORMATCHSETUP lpCM) <br>{ <br>    // Local variables <br> <br>    //  ASSERTs and parameter validations <br>    DebugMsg(__TEXT("***** COLORMATCHSETUP 0x%08lx\r\n"), lpCM); <br>    DebugMsg(__TEXT("dwSize                        %ld\r\n"),     lpCM-&gt;dwSize); <br>    DebugMsg(__TEXT("dwVersion                     0x%08lx\r\n"), lpCM-&gt;dwVersion); <br>    DebugMsg(__TEXT("dwFlags                       0x%08lx\r\n"), lpCM-&gt;dwFlags); <br>    DebugMsg(__TEXT("hwndOwner                     0x%08lx\r\n"), lpCM-&gt;hwndOwner); <br> <br>    DebugMsg(__TEXT("pSourceName                   0x%08lX &lt;%s&gt;\r\n"), lpCM-&gt;pSourceName   , lpCM-&gt;pSourceName    ? lpCM-&gt;pSourceName    : __TEXT("NULL PTR")); <br>    DebugMsg(__TEXT("pDisplayName                  0x%08lX &lt;%s&gt;\r\n"), lpCM-&gt;pDisplayName   , lpCM-&gt;pDisplayName    ? lpCM-&gt;pDisplayName    : __TEXT("NULL PTR")); <br>    DebugMsg(__TEXT("pPrinterName                  0x%08lX &lt;%s&gt;\r\n"), lpCM-&gt;pPrinterName   , lpCM-&gt;pPrinterName    ? lpCM-&gt;pPrinterName    : __TEXT("NULL PTR")); <br> <br>    DebugMsg(__TEXT("dwRenderIntent                %ld\r\n"),     lpCM-&gt;dwRenderIntent); <br>    DebugMsg(__TEXT("dwProofingIntent              %ld\r\n"),     lpCM-&gt;dwProofingIntent); <br> <br>    DebugMsg(__TEXT("pMonitorProfile               0x%08lX &lt;%s&gt;\r\n"), lpCM-&gt;pMonitorProfile   , lpCM-&gt;pMonitorProfile    ? lpCM-&gt;pMonitorProfile    : __TEXT("NULL PTR")); <br>    DebugMsg(__TEXT("ccMonitorProfile              %ld\r\n"),     lpCM-&gt;ccMonitorProfile); <br> <br>    DebugMsg(__TEXT("pPrinterProfile               0x%08lX &lt;%s&gt;\r\n"), lpCM-&gt;pPrinterProfile   , lpCM-&gt;pPrinterProfile    ? lpCM-&gt;pPrinterProfile    : __TEXT("NULL PTR")); <br>    DebugMsg(__TEXT("ccPrinterProfile              %ld\r\n"),     lpCM-&gt;ccPrinterProfile); <br> <br>    DebugMsg(__TEXT("pTargetProfile                0x%08lX &lt;%s&gt;\r\n"), lpCM-&gt;pTargetProfile   , lpCM-&gt;pTargetProfile    ? lpCM-&gt;pTargetProfile    : __TEXT("NULL PTR")); <br>    DebugMsg(__TEXT("ccTargetProfile               %ld\r\n"),     lpCM-&gt;ccTargetProfile); <br> <br>    DebugMsg(__TEXT("lpfnHook                      0x%08lx\r\n"), lpCM-&gt;lpfnHook); <br>    DebugMsg(__TEXT("lParam                        0x%08lx\r\n"), lpCM-&gt;lParam); <br>    DebugMsg(__TEXT("***** COLORMATCHSETUP 0x%08lx\r\n"), lpCM); <br>} // End of function DumpCOLORMATCHSETUP <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
