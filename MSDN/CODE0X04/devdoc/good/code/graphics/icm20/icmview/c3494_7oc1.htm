<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>APPINIT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3511"></a>APPINIT.C</h2>
<pre><code>//THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>//ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>//THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>// PARTICULAR PURPOSE. <br>// <br>// Copyright  1994-1996  Microsoft Corporation.  All Rights Reserved. <br>// <br>//  FILE: <br>//    INIT.C <br>// <br>//  PURPOSE: <br>//    Initializes ICMVIEW. <br>// <br>//  PLATFORMS: <br>//    Windows 95, Windows NT <br>// <br>//  SPECIAL INSTRUCTIONS: N/A <br>// <br> <br>// Windows Header Files: <br>// Windows Header Files: <br>#pragma warning(disable:4001)   // Single-line comment warnings <br>#pragma warning(disable:4115)   // Named type definition in parentheses <br>#pragma warning(disable:4201)   // Nameless struct/union warning <br>#pragma warning(disable:4214)   // Bit field types other than int warnings <br>#pragma warning(disable:4514)   // Unreferenced inline function has been removed <br> <br>// Windows Header Files: <br>#include &lt;Windows.h&gt; <br>#include &lt;WindowsX.h&gt; <br>#include &lt;commctrl.h&gt; <br>#include "icm.h" <br> <br>// Restore the warnings--leave the single-line comment warning OFF <br>#pragma warning(default:4115)   // Named type definition in parentheses <br>#pragma warning(default:4201)   // Nameless struct/union warning <br>#pragma warning(default:4214)   // Bit field types other than int warnings <br> <br>// C RunTime Header Files <br>#include &lt;stdlib.h&gt; <br>#include &lt;tchar.h&gt; <br> <br>// Local Header Files <br>#include "AppInit.h" <br>#include "icmview.h" <br>#include "child.h" <br>#include "DibInfo.H" <br>#include "debug.h" <br>#include "resource.h" <br> <br> <br>#define RECENT_MENU         0 <br>#define RECENT_POSITION     11 <br> <br> <br>// local definitions <br>BOOL RegisterICMViewClasses(HINSTANCE); <br>BOOL CreateGlobalDIBInfo(void); <br>BOOL GetSettings(LPRECT, LPDWORD, HANDLE); <br>BOOL UpdateRecentFiles(HWND, HANDLE); <br>int RegisterCMMProc(LPCTSTR lpszFileName); <br> <br>// default settings <br> <br>// external functions <br> <br>// external data <br> <br>// public data <br> <br>// private data <br> <br>// <br>// Public functions <br>// <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  InitApplication <br>// <br>//  Description: <br>//    Initializes window data and registers window class. <br>// <br>//  Parameters: <br>//    HINSTANCE   Instance handle. <br>// <br>//  Returns: <br>//    BOOL    Success indicator <br>// <br>//  Comments: <br>// <br>// <br>////////////////////////////////////////////////////////////////////////// <br>BOOL  InitApplication(HINSTANCE hInstance) <br>{ <br>    //  Initialize variables <br>    SetLastError(0); <br> <br>    return RegisterICMViewClasses(hInstance); <br>}   // End of function InitApplication <br> <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  InitInstance <br>// <br>//  Description: <br>//    Initializes this instance and saves an instance handle. <br>// <br>//  Parameters: <br>//    HINSTANCE Instance handle <br>//    int       Integer identifying initial display mode@@@ <br>// <br>//  Returns: <br>//    BOOL    Success indicator. <br>// <br>//  Comments: <br>// <br>// <br>////////////////////////////////////////////////////////////////////////// <br>BOOL InitInstance(HINSTANCE hInstance, int nCmdShow) <br>{ <br>    // Local variables <br>    HDC       hDisplay = GetDC(NULL); <br>    int       nScreenWidth = GetDeviceCaps(hDisplay, HORZRES); <br>    int       nScreenHeight = GetDeviceCaps(hDisplay, VERTRES); <br>    HWND      hWnd; <br>    RECT      rCoord; <br>    DWORD     dwFlags = 0L; <br>    HANDLE    hRecent = NULL; <br>    DWORD     dwPathSize; <br> <br>    // No longer need display DC. <br>    if (hDisplay) <br>        ReleaseDC(NULL, hDisplay); <br> <br>    //  Initialize variables <br>    ghInst = hInstance; // Store instance handle in our global variable <br> <br>    // Get stored coordinates from last run. <br>    GetSettings(&amp;rCoord, &amp;dwFlags, &amp;hRecent); <br>    if ( ((rCoord.left + rCoord.right)/2 &lt; 0) <br>         || <br>         ((rCoord.left + rCoord.right)/2 &gt; nScreenWidth) <br>         || <br>         ((rCoord.top + rCoord.bottom)/2 &lt; 0) <br>         || <br>         ((rCoord.top + rCoord.bottom)/2 &gt; nScreenHeight) <br>         || <br>         ( (double)(rCoord.right - rCoord.left)/(double)(nScreenHeight) * 1.1 <br>           &gt;= (double)(nScreenWidth)/(double)(rCoord.bottom - rCoord.top) ) <br>       ) <br>    { <br>        SetRect(&amp;rCoord, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT); <br>    } <br>    else <br>    { <br>        // Set right and bottom to width and height. <br>        rCoord.right -= rCoord.left; <br>        rCoord.bottom -= rCoord.top; <br>    } <br> <br>    // Create the window using stored coordinates. <br>    _tcscpy(gstTitle, APPNAME); <br>    hWnd = CreateWindowEx(WS_EX_OVERLAPPEDWINDOW, APPNAME, gstTitle, WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | WS_CLIPSIBLINGS, <br>                          rCoord.left, rCoord.top, rCoord.right, rCoord.bottom, NULL, NULL, hInstance, NULL); <br> <br>    if (!hWnd)  // Couldn't create main window, exit w/FAILURE code <br>    { <br>        DebugMsg(__TEXT("InitInstance:  CreateWindow failed.\r\n")); <br>        return (FALSE); <br>    } <br>    ghAppWnd = hWnd;  // Save main application window handle <br> <br>    // Attach recent files to main window and display them. <br>    SetProp(hWnd, APP_RECENT, hRecent); <br>    UpdateRecentFiles(hWnd, hRecent); <br> <br>    // Store profiles directory <br>    dwPathSize = MAX_PATH; <br>    GetColorDirectory(NULL, gstProfilesDir, &amp;dwPathSize); <br> <br>    if (!CreateGlobalDIBInfo()) <br>    { <br>        DebugMsg(__TEXT("InitInstance:  CreateGlobalDIBInfo failed\r\n")); <br>        return(FALSE); <br>    } <br>    InitCommonControls(); <br> <br>    // Figure out how the window should be shown. <br>    if ((SW_NORMAL == nCmdShow) &amp;&amp; (IVF_MAXIMIZED &amp; dwFlags)) <br>    { <br>        nCmdShow = SW_MAXIMIZE; <br>    } <br> <br>    // Show window. <br>    ShowWindow(hWnd, nCmdShow); <br>    UpdateWindow(hWnd); <br> <br>    return (TRUE); <br>}   // End of function InitInstance <br> <br>// <br>// Private functions <br>// <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  RegisterICMViewClasses <br>// <br>//  Description: <br>//    Registers the window class <br>// <br>//  Parameters: <br>//    @@@ <br>// <br>//  Returns: <br>//    BOOL <br>// <br>//  Comments: <br>//    This function and its usage is only necessary if you want this code <br>//    to be compatible with Win32 systems prior to the 'RegisterClassEx' <br>//    function that was added to Windows 95. It is important to call this <br>//    function so that the application will get 'well formed' small icons <br>//    associated with it. <br>// <br>////////////////////////////////////////////////////////////////////////// <br>BOOL RegisterICMViewClasses(HINSTANCE hInstance) <br>{ <br>    // Local variables <br>    BOOL          bAppClass, bChildClass;   // Booleans indicate if classes registered successfully <br>    WNDCLASSEX    wcex; <br> <br>    //  Initialize variables <br>    bAppClass = bChildClass = FALSE; <br>    wcex.style         = 0; <br>    wcex.lpfnWndProc   = (WNDPROC)WndProc; <br>    wcex.cbClsExtra    = 0; <br>    wcex.cbWndExtra    = ICMVIEW_CBWNDEXTRA; <br>    wcex.hInstance     = hInstance; <br>    wcex.hIcon         = LoadIcon (hInstance, APPNAME); <br>    wcex.hCursor       = LoadCursor(NULL, IDC_ARROW); <br>    wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); <br> <br>    // Set menu depending upon Operating System <br>    wcex.lpszMenuName = APPNAME; <br>    wcex.lpszClassName = APPNAME; <br> <br>    // Added elements for Windows 95: <br>    wcex.cbSize = sizeof(WNDCLASSEX); <br>    wcex.hIconSm = LoadIcon(wcex.hInstance, __TEXT("SMALL")); <br> <br>    // Register App Class <br>    bAppClass = RegisterClassEx(&amp;wcex); <br> <br>    if (bAppClass) <br>    { <br>        // Register the child class <br>        wcex.style         = CS_SAVEBITS; <br>        wcex.lpfnWndProc   = ChildWndProc; <br>        wcex.lpszMenuName  = (LPCTSTR)NULL; <br>        wcex.cbWndExtra    = CHILD_CBWNDEXTRA; <br>        wcex.hbrBackground = (HBRUSH) (COLOR_WINDOW + 1); <br>        wcex.lpszClassName = CHILD_CLASSNAME; <br>        wcex.hIcon         = NULL; <br>        bChildClass = RegisterClassEx(&amp;wcex); <br>    } <br>    return    (   bAppClass    &amp;&amp;    bChildClass); <br>}   // End of function RegisterICMViewClasses <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  CreateGlobalDIBInfo <br>// <br>//  Description: <br>//    Creates and initializes the DIBINFO structure for the global ICMVIEW application window. <br>// <br>//  Parameters: <br>//    @@@ <br>// <br>//  Returns: <br>//    BOOL <br>// <br>//  Comments: <br>// <br>// <br>////////////////////////////////////////////////////////////////////////// <br>BOOL CreateGlobalDIBInfo(void) <br>{ <br>    // Local variables <br>    HGLOBAL     hDIBInfo; <br>    LPDIBINFO   lpDIBInfo; <br> <br>    //  Initialize variables <br>    hDIBInfo = CreateDIBInfo(); <br>    if (NULL == hDIBInfo) <br>    { <br>        DebugMsg(__TEXT("CreateGlobalDIBInfo:  CreateDIBInfo failed.\r\n")); <br>        return(FALSE); <br>    } <br>    lpDIBInfo = GlobalLock(hDIBInfo); <br>    lpDIBInfo-&gt;hWndOwner = ghAppWnd; <br>    GlobalUnlock(hDIBInfo); <br>    SetWindowLong(ghAppWnd, GWL_DIBINFO, (LONG)hDIBInfo); <br>    GetDefaultICMInfo(); <br>    return(TRUE); <br>}   // End of function CreateGlobalDIBInfo <br> <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  GetSettings <br>// <br>//  Description: <br>//    Grabs stored settings from registry. <br>// <br>//  Parameters: <br>//    lpRect    Pointer to rect of window position and size. <br>//    phRecent  Pointer to handle of an array of most recent files. <br>// <br>//  Returns: <br>//    BOOL <br>// <br>//  Comments: <br>// <br>// <br>////////////////////////////////////////////////////////////////////////// <br>BOOL GetSettings(LPRECT lpRect, LPDWORD pdwFlags, LPHANDLE phRecent) <br>{ <br>    HKEY    hKey; <br>    LONG    lResult; <br>    DWORD   dwSize; <br>    DWORD   dwType; <br> <br> <br>    // Initialize coordinates and recent file list in case we fail. <br>    if (NULL != phRecent) <br>    { <br>        // Free and re-allocate. <br>        if (NULL != *phRecent) <br>        { <br>            GlobalFree(*phRecent); <br>        } <br> <br>        // Allocate string table. <br>        *phRecent = GlobalAlloc(GHND, (sizeof(LPTSTR) + MAX_PATH * sizeof(TCHAR)) * MAX_RECENT); <br>    } <br>    if (NULL != lpRect) <br>    { <br>        SetRect(lpRect, 0, 0, CW_USEDEFAULT, CW_USEDEFAULT); <br>    } <br> <br>    // Open top level registry to application settings. <br>    lResult = RegOpenKeyEx(HKEY_CURRENT_USER, APP_REG, 0L, KEY_ALL_ACCESS, &amp;hKey); <br>    if (ERROR_SUCCESS == lResult) <br>    { <br>        // INVARIANT:  Application registry key exists. <br>        // If lpRect is non-null, attempt to get the stored window coord. <br>        if (NULL != lpRect) <br>        { <br>            dwSize = sizeof(RECT); <br>            RegQueryValueEx(hKey, APP_COORD, NULL, &amp;dwType, (LPBYTE)lpRect, &amp;dwSize); <br>        } <br> <br>        // Get stored state flags. <br>        dwSize = sizeof(DWORD); <br>        RegQueryValueEx(hKey, APP_FLAGS, NULL, &amp;dwType, (LPBYTE)pdwFlags, &amp;dwSize); <br> <br>        // If ppszRecent is non-null, attempt to get the stored recent file list. <br>        if (NULL != phRecent) <br>        { <br>            TCHAR    szReg[32]; <br>            DWORD   dwCount; <br>            LPTSTR  *ppszRecent; <br> <br>            // Make sure alloc succeded from above. <br>            if (NULL == *phRecent) <br>            { <br>                RegCloseKey(hKey); <br>                return FALSE; <br>            } <br>            ppszRecent = (LPTSTR*)GlobalLock(*phRecent); <br> <br>            // Get each of the recent files. <br>            for (dwCount = 0; dwCount &lt; MAX_RECENT; dwCount++) <br>            { <br>                // Build the key name to the nth recent file. <br>                wsprintf(szReg, __TEXT("%s%d"), APP_RECENT, dwCount); <br> <br>                // Get the size of the recent file string. <br>                dwSize = 0; <br>                lResult = RegQueryValueEx(hKey, szReg, NULL, &amp;dwType, NULL, &amp;dwSize); <br> <br>                // Alloc the string and attempt to get the recent file. <br>                if ((ERROR_SUCCESS == lResult) &amp;&amp; (0 != dwSize)) <br>                { <br>                    ASSERT(dwSize &lt;= MAX_PATH); <br>                    ppszRecent[dwCount] = (LPTSTR) ((LPBYTE)(ppszRecent + MAX_RECENT) + MAX_PATH <br>                                                    * sizeof(TCHAR) * dwCount); <br>                    if (NULL != ppszRecent[dwCount]) <br>                    { <br>                        RegQueryValueEx(hKey, szReg, NULL, &amp;dwType, (LPBYTE)ppszRecent[dwCount], &amp;dwSize); <br>                    } <br>                } <br>            } <br>        } <br>        RegCloseKey(hKey); <br>        GlobalUnlock(*phRecent); <br>    } <br>    return TRUE; <br>} <br> <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  SetSettings <br>// <br>//  Description: <br>//    Store settings into registry. <br>// <br>//  Parameters: <br>//    lpRect          Pointer to rect of window position and size. <br>//    ppszRecent      Pointer to an array of most recent files. <br>// <br>//  Returns: <br>//    BOOL <br>// <br>//  Comments: <br>// <br>// <br>////////////////////////////////////////////////////////////////////////// <br>BOOL SetSettings(LPRECT lpRect, DWORD dwFlags, HANDLE hRecent) <br>{ <br>    HKEY    hKey; <br>    LONG    lResult; <br>    DWORD   dwType; <br>    LPTSTR  *ppszRecent = NULL; <br> <br>    // Open top level registry to application settings. <br>    lResult = RegCreateKeyEx(HKEY_CURRENT_USER, APP_REG, 0L, NULL, <br>                             REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, <br>                             &amp;hKey, &amp;dwType); <br>    if (ERROR_SUCCESS == lResult) <br>    { <br>        // INVARIANT:  Application registry key exists or has been created. <br>        // If lpRect is non-null, attempt to store the window coord. <br>        if (NULL != lpRect) <br>        { <br>            RegSetValueEx(hKey, APP_COORD, 0, REG_BINARY, (LPBYTE)lpRect, sizeof(RECT)); <br>        } <br> <br>        // Store ICMView state flags. <br>        RegSetValueEx(hKey, APP_FLAGS, 0, REG_DWORD, (LPBYTE)&amp;dwFlags, sizeof(dwFlags)); <br> <br>        // If ppszRecent is non-null, attempt to store recent file list. <br>        if (NULL != hRecent) <br>        { <br>            ppszRecent = (LPTSTR*) GlobalLock(hRecent); <br>        } <br>        if (NULL != ppszRecent) <br>        { <br>            TCHAR    szReg[32]; <br>            DWORD   dwCount; <br> <br> <br>            // Set each of the recent files. <br>            for (dwCount = 0; dwCount &lt; MAX_RECENT; dwCount++) <br>            { <br>                // Build the key name to the nth recent file. <br>                wsprintf(szReg, __TEXT("%s%d"), APP_RECENT, dwCount); <br> <br>                // Set the the recent file string. <br>                if (NULL != ppszRecent[dwCount]) <br>                { <br>                    RegSetValueEx(hKey, szReg, 0, REG_SZ, (LPBYTE)ppszRecent[dwCount], <br>                                  lstrlen(ppszRecent[dwCount]) * sizeof(TCHAR) ); <br>                } <br>            } <br>            GlobalUnlock(hRecent); <br>        } <br>        RegCloseKey(hKey); <br>    } <br>    return TRUE; <br>} <br> <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  AddRecentFile <br>// <br>//  Description: <br>//    Adds and displays recent file strins. <br>// <br>//  Parameters: <br>//    hWnd                    Window that was menu and prop for recent file list. <br>//    lpszFileName    File name string to add to recent files list. <br>// <br>//  Returns: <br>//    BOOL <br>// <br>//  Comments: <br>// <br>// <br>////////////////////////////////////////////////////////////////////////// <br>BOOL AddRecentFile(HWND hWnd, LPTSTR lpszFileName) <br>{ <br>    int             nFind; <br>    int             nCount; <br>    HANDLE  hRecent; <br>    LPTSTR  *ppszRecent; <br> <br>    // Make sure valid paramters. <br>    if (!IsWindow(hWnd) || (NULL == lpszFileName) ||(lstrlen(lpszFileName) == 0)) <br>    { <br>        return FALSE; <br>    } <br> <br>    // Get Recent file list. <br>    hRecent = GetProp(hWnd, APP_RECENT); <br>    if (NULL == hRecent) <br>    { <br>        return FALSE; <br>    } <br> <br>    // Get pointer to string array. <br>    ppszRecent = (LPTSTR*) GlobalLock(hRecent); <br>    ASSERT(ppszRecent != NULL); <br> <br>    // Search array for an occurence of the string <br>    // we are adding. <br>    for (nFind = 0; (nFind &lt; MAX_RECENT) &amp;&amp; (NULL != ppszRecent[nFind]) <br>        &amp;&amp; lstrcmpi(ppszRecent[nFind], lpszFileName); nFind++); <br> <br>    // Make sure that nFind element is valid string. <br>    // nFind - 1 should be non null or not indexed. <br>    if ( (nFind &lt; MAX_RECENT) &amp;&amp; (NULL == ppszRecent[nFind])) <br>    { <br>        ppszRecent[nFind] = (LPTSTR)((LPBYTE)(ppszRecent + MAX_RECENT) + MAX_PATH * sizeof(TCHAR) * nFind); <br>    } <br> <br>    // Move strings from nFind to zero down one to make room <br>    // to add string to top of list. <br>    for (nCount = __min(nFind, MAX_RECENT -1); nCount &gt; 0; nCount--) <br>        _tcscpy(ppszRecent[nCount], ppszRecent[nCount -1]); <br> <br>    // Add file to first position. <br>    _tcscpy(ppszRecent[0], lpszFileName); <br> <br>    // Unlock array. <br>    GlobalUnlock(hRecent); <br> <br>    // Display strings. <br>    UpdateRecentFiles(hWnd, hRecent); <br> <br>    return TRUE; <br>} <br> <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  UpdateRecentFiles <br>// <br>//  Description: <br>//    Displays recent files. <br>// <br>//  Parameters: <br>// <br>//    hWnd            Window that was menu and prop for recent file list. <br>//    hRecent         Handle to an array of most recent files. <br>// <br>//  Returns: <br>//    BOOL <br>// <br>//  Comments: <br>// <br>// <br>////////////////////////////////////////////////////////////////////////// <br> <br>BOOL UpdateRecentFiles(HWND hWnd, HANDLE hRecent) <br>{ <br>    int                    nMenuAdjust; <br>    int                    nCount; <br>    TCHAR                  szTemp[MAX_PATH + 4]; <br>    HWND                   hwndActiveChild; <br>    HMENU                  hMenu; <br>    LPTSTR                 *ppszRecent; <br>    MENUITEMINFO          ItemInfo; <br> <br>    // Validate paramters. <br>    if ( !IsWindow(hWnd) || (NULL == hRecent) ) <br>    { <br>        return FALSE; <br>    } <br> <br>    // Get current active MDI window and check to see <br>    // if it is maximized.  Need to add 1 to menu if it <br>    // is maximized. <br>    hwndActiveChild = GetCurrentMDIWnd(); <br>    nMenuAdjust = 0; <br>    if (IsZoomed(hwndActiveChild)) <br>    { <br>        nMenuAdjust = 1; <br>    } <br> <br>    // Get file menu. <br>    hMenu = GetMenu(hWnd); <br>    ASSERT(hMenu != NULL); <br>    hMenu = GetSubMenu(hMenu, RECENT_MENU + nMenuAdjust); <br>    ASSERT(hMenu != NULL); <br>    ASSERT(GetMenuItemCount(hMenu) &gt; RECENT_POSITION); <br> <br>    // Get pointer to recent file array. <br>    ppszRecent = (LPTSTR*) GlobalLock(hRecent); <br>    ASSERT(ppszRecent != NULL); <br> <br>    // Add each string in recent file list to menu. <br>    // Replace menu items until separator, then insert them. <br>    for (nCount = 0; nCount &lt; MAX_RECENT; nCount++) <br>    { <br>        // Only add strings that are not null or zero length. <br>        if ( (NULL != ppszRecent[nCount]) &amp;&amp; (lstrlen(ppszRecent[nCount]) != 0) ) <br>        { <br>            // Build recent file menu string. <br>            wsprintf(szTemp, __TEXT("&amp;%d %s"), nCount +1, ppszRecent[nCount]); <br> <br>            // Determine if replacing item or inserting. <br>            memset(&amp;ItemInfo, 0, sizeof(MENUITEMINFO)); <br>            ItemInfo.cbSize = sizeof(MENUITEMINFO); <br>            ItemInfo.fMask = MIIM_TYPE; <br>            GetMenuItemInfo(hMenu, RECENT_POSITION + nCount, TRUE, &amp;ItemInfo); <br>            if (MFT_SEPARATOR == ItemInfo.fType) <br>            { <br>                // Insert item. MIIM_ID <br>                ItemInfo.fMask = MIIM_TYPE | MIIM_ID; <br>                ItemInfo.wID = IDM_FILE_RECENT + nCount; <br>                ItemInfo.fType = MFT_STRING; <br>                ItemInfo.dwTypeData = szTemp; <br>                ItemInfo.cch = lstrlen(ItemInfo.dwTypeData); <br>                InsertMenuItem(hMenu, RECENT_POSITION + nCount, TRUE, &amp;ItemInfo); <br>            } <br>            else <br>            { <br>                // Replace menu item. <br>                ItemInfo.fMask = MIIM_TYPE | MIIM_STATE; <br>                ItemInfo.fState = MFS_ENABLED; <br>                ItemInfo.fType = MFT_STRING; <br>                ItemInfo.dwTypeData = szTemp; <br>                ItemInfo.cch = lstrlen(ItemInfo.dwTypeData); <br>                SetMenuItemInfo(hMenu, RECENT_POSITION + nCount, TRUE, &amp;ItemInfo); <br>            } <br>        } <br>    } <br> <br>    // Unlock recent array. <br>    GlobalUnlock(hRecent); <br>    return TRUE; <br>} <br> <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
