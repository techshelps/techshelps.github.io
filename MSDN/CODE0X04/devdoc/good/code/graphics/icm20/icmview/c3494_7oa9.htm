<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DIALOGS.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3501"></a>DIALOGS.C</h2>
<pre><code>//THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>//ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>//THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>// PARTICULAR PURPOSE. <br>// <br>// Copyright  1994-1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//  FILE: <br>//    DIALOGS.C <br>// <br>//  DESCRIPTION: <br>// <br>// <br>//  PLATFORMS: <br>//    Windows 95, Windows NT <br>// <br>//  SPECIAL INSTRUCTIONS: <br>// <br> <br>// <br>// Pre-processor directives <br>// <br> <br>#define REGISTRY_CURRENT_DISPLAY "System\\CurrentControlSet\\Services\\Class\\DISPLAY\\0000" <br>#define TOGGLE_BOOLEAN(b) b=!b <br> <br>// Windows Header Files: <br>#pragma warning(disable:4001)   // Single-line comment warnings <br>#pragma warning(disable:4115)   // Named type definition in parentheses <br>#pragma warning(disable:4201)   // Nameless struct/union warning <br>#pragma warning(disable:4214)   // Bit field types other than int warnings <br>#pragma warning(disable:4514)   // Unreferenced inline function has been removed <br> <br>// Windows Header Files: <br>#include &lt;Windows.h&gt; <br>#include &lt;WindowsX.h&gt; <br>#include &lt;commdlg.h&gt; <br>#include &lt;commctrl.h&gt; <br>#include "icm.h" <br> <br>// Restore the warnings--leave the single-line comment warning OFF <br>#pragma warning(default:4115)   // Named type definition in parentheses <br>#pragma warning(default:4201)   // Nameless struct/union warning <br>#pragma warning(default:4214)   // Bit field types other than int warnings <br>#pragma warning(default:4514)   // Unreferenced inline function has been removed <br> <br>// C-runtime header files <br>#include &lt;TCHAR.H&gt; <br>#include &lt;stdlib.h&gt; <br> <br>// Local header files <br>#include "icmview.h" <br>#include "resource.h" <br>#include "DibInfo.H" <br>#include "Dialogs.h" <br>#include "CDErr.h" <br>#include "print.h" <br>#include "child.h" <br>#include "Dibs.H" <br>#include "AppInit.h" <br>#include "Debug.h" <br> <br>// Private structures/typedefs <br>typedef struct tagDIBPROPSHEETINFO <br>{ <br>    UINT            uiPageNum;          // Page number of propsheet <br>    HGLOBAL         hDIBInfo;           // Handle to DIBINFO structure <br>} DIBPROPSHEETINFO, *LPDIBPROPSHEETINFO; <br> <br>// Private function prototypes <br>void            ProcessCDError(DWORD dwErrorCode, HWND hWnd); <br>int CALLBACK    EnumICMProfileCallback(LPCTSTR lpszFileName, LPARAM lParam); <br>LPTSTR          GetOpenImageName(HWND hWnd , PBOOL pbUserCancel); <br>void            DlgDIBInfoPaint(HWND  hDlg, LPDIBINFO lpDIBInfo); <br>BOOL            SaveDIBInfoDlgPage(HWND hDlg, LPDIBINFO lpDIBInfo, UINT uiPageNum); <br>LPTSTR          GetDlgItemString(HWND hDlg, int iControlId, LPTSTR lpszCurrentString); <br>DWORD           SetColorMatchUIFlags(DWORD dwDIFlags); <br>BOOL WINAPI     ColorSetupApply(PCOLORMATCHSETUP pcmSetup, LPARAM lParam); <br>VOID            ApplyColorSettings(LPDIBINFO lpDIBInfo, PCOLORMATCHSETUP pCMSetup); <br>BOOL CALLBACK PrintDialogProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam); <br> <br>// Global external variables <br> <br>// Global private variables <br>//UINT  guiNumProfiles = 0; <br>BOOL  gbOpenCanceled; <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// <br>//   FUNCTION: ProcessCDError(DWORD) <br>// <br>//   PURPOSE:  Processes errors from the common dialog functions. <br>// <br>//   COMMENTS: <br>// <br>//       This function is called whenever a common dialog function <br>//       fails.  The CommonDialogExtendedError() value is passed to <br>//       the function which maps the error value to a string table. <br>//       The string is loaded and displayed for the user. <br>// <br>//   RETURN VALUES: <br>//       void. <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>void ProcessCDError(DWORD dwErrorCode, HWND hWnd) <br>{ <br>    WORD  wStringID; <br>    TCHAR  buf[256]; <br> <br>    switch (dwErrorCode) <br>    { <br>        case CDERR_DIALOGFAILURE:   wStringID=IDS_DIALOGFAILURE;   break; <br>        case CDERR_STRUCTSIZE:      wStringID=IDS_STRUCTSIZE;      break; <br>        case CDERR_INITIALIZATION:  wStringID=IDS_INITIALIZATION;  break; <br>        case CDERR_NOTEMPLATE:      wStringID=IDS_NOTEMPLATE;      break; <br>        case CDERR_NOHINSTANCE:     wStringID=IDS_NOHINSTANCE;     break; <br>        case CDERR_LOADSTRFAILURE:  wStringID=IDS_LOADSTRFAILURE;  break; <br>        case CDERR_FINDRESFAILURE:  wStringID=IDS_FINDRESFAILURE;  break; <br>        case CDERR_LOADRESFAILURE:  wStringID=IDS_LOADRESFAILURE;  break; <br>        case CDERR_LOCKRESFAILURE:  wStringID=IDS_LOCKRESFAILURE;  break; <br>        case CDERR_MEMALLOCFAILURE: wStringID=IDS_MEMALLOCFAILURE; break; <br>        case CDERR_MEMLOCKFAILURE:  wStringID=IDS_MEMLOCKFAILURE;  break; <br>        case CDERR_NOHOOK:          wStringID=IDS_NOHOOK;          break; <br>        case PDERR_SETUPFAILURE:    wStringID=IDS_SETUPFAILURE;    break; <br>        case PDERR_PARSEFAILURE:    wStringID=IDS_PARSEFAILURE;    break; <br>        case PDERR_RETDEFFAILURE:   wStringID=IDS_RETDEFFAILURE;   break; <br>        case PDERR_LOADDRVFAILURE:  wStringID=IDS_LOADDRVFAILURE;  break; <br>        case PDERR_GETDEVMODEFAIL:  wStringID=IDS_GETDEVMODEFAIL;  break; <br>        case PDERR_INITFAILURE:     wStringID=IDS_INITFAILURE;     break; <br>        case PDERR_NODEVICES:       wStringID=IDS_NODEVICES;       break; <br>        case PDERR_NODEFAULTPRN:    wStringID=IDS_NODEFAULTPRN;    break; <br>        case PDERR_DNDMMISMATCH:    wStringID=IDS_DNDMMISMATCH;    break; <br>        case PDERR_CREATEICFAILURE: wStringID=IDS_CREATEICFAILURE; break; <br>        case PDERR_PRINTERNOTFOUND: wStringID=IDS_PRINTERNOTFOUND; break; <br>        case CFERR_NOFONTS:         wStringID=IDS_NOFONTS;         break; <br>        case FNERR_SUBCLASSFAILURE: wStringID=IDS_SUBCLASSFAILURE; break; <br>        case FNERR_INVALIDFILENAME: wStringID=IDS_INVALIDFILENAME; break; <br>        case FNERR_BUFFERTOOSMALL:  wStringID=IDS_BUFFERTOOSMALL;  break; <br> <br>        case 0:   //User may have hit CANCEL or we got a *very* random error <br>            return; <br> <br>        default: <br>            wStringID=IDS_UNKNOWNERROR; <br>    } <br> <br>    LoadString(NULL, wStringID, buf, sizeof(buf)); <br>    MessageBox(hWnd, buf, NULL, MB_OK); <br>    return; <br>} <br> <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  GetOpenImageName <br>// <br>//  Description: <br>//    Invokes common dialog function to open a file and opens it, returning <br>//    the LPHANDLE to the opened file (NULL if failure) and setting the <br>//    LPTSTR parameter to the FULLY QUALIFIED name of the file which was opened. <br>//    If the user cancels out of the dialog, the bUserCancelled variable is <br>//    set to TRUE, allowing the calling function to discriminate between this <br>//    action and an actual failure of the open dialog calls. <br>// <br>//  Parameters: <br>//    HWND      Handle to the associated window <br>//    *BOOL     Indicates if user cancelled out of dialog. <br>// <br>//  Returns: <br>//    LPTSTR     Pointer to the buffer to hold the filename. <br>// <br>//  Comments: <br>// <br>////////////////////////////////////////////////////////////////////////// <br> <br>LPTSTR GetOpenImageName(HWND hWnd , PBOOL pbUserCancel) <br>{ <br>    // Local variables <br>    OPENFILENAME    OpenFileName;   // Structure for common dialog File/Open <br>    TCHAR           szFilter[]=__TEXT("Images(*.BMP,*.DIB)\0*.BMP;*.DIB\0All Files(*.*)\0*.*\0\0"); <br>    TCHAR           szFile[MAX_PATH]; <br>    LPTSTR          lpszFileName; <br> <br>    // Initialize variables <br>    szFile[0] = __TEXT('\0'); <br>    OpenFileName.lStructSize       = sizeof(OPENFILENAME); <br>    OpenFileName.hwndOwner         = hWnd; <br>    OpenFileName.hInstance         = (HANDLE) ghInst; <br>    OpenFileName.lpstrFilter       = szFilter; <br>    OpenFileName.lpstrCustomFilter = (LPTSTR) NULL; <br>    OpenFileName.nMaxCustFilter    = 0L; <br>    OpenFileName.nFilterIndex      = 1L; <br>    OpenFileName.lpstrFile         = szFile; <br>    OpenFileName.nMaxFile          = sizeof(szFile); <br>    OpenFileName.lpstrFileTitle    = NULL; <br>    OpenFileName.nMaxFileTitle     = 0; <br>    OpenFileName.lpstrInitialDir   = NULL; <br>    OpenFileName.lpstrTitle        = __TEXT("ICMVIEW:  Open Image"); <br>    OpenFileName.nFileOffset       = 0; <br>    OpenFileName.nFileExtension    = 0; <br>    OpenFileName.lpstrDefExt       = NULL;  // No default extension <br>    OpenFileName.lCustData         = 0; <br> <br>    OpenFileName.Flags = OFN_SHOWHELP | OFN_PATHMUSTEXIST | <br>                         OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | <br>                         OFN_EXPLORER | OFN_LONGNAMES; <br> <br>    if (GetOpenFileName(&amp;OpenFileName)) <br>    { <br>        *pbUserCancel = FALSE; <br>        // We have a valid filename, let's copy it into the buffer <br>        lpszFileName = GlobalAlloc(GPTR, (lstrlen(OpenFileName.lpstrFile)+1)); <br>        if (NULL == lpszFileName) <br>        { <br>            return(NULL); <br>        } <br>        _tcscpy(lpszFileName,OpenFileName.lpstrFile); <br>    } <br>    else // User didn't select a file <br>    { <br>        *pbUserCancel = TRUE; <br>        ProcessCDError(CommDlgExtendedError(), hWnd ); <br>        return (NULL); <br>    } <br>    return(lpszFileName); <br>}   // End of GetOpenImageName <br> <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  fOpenNewImage <br>// <br>//  Description: <br>//    Performs all tasks associated with opening a new file.  This includes <br>//    creating the File Open common dialog, and if a file was successfully <br>//    opened, creating a new thread and window to handle the selected image. <br>// <br>//  Parameters: <br>//    HWND    Handle to associated window. <br>// <br>//  Returns: <br>//    BOOL    Indicates if a file was successfully opened. <br>// <br>//  Comments: <br>// <br>////////////////////////////////////////////////////////////////////////// <br> <br>BOOL fOpenNewImage(HWND hWnd, LPTSTR lpszFileName) <br>{ <br>    // Local variables <br>    BOOL        bUserCancelled;   // TRUE if user cancels open dialog <br>    HGLOBAL     hDIBInfo, hMem; <br>    BOOL        bRC; <br>    HCURSOR     hCur; <br> <br>    // If lpszFileName is NULL, get file name from user. <br>    if (NULL == lpszFileName) <br>    { <br>        lpszFileName = GetOpenImageName(hWnd, &amp;bUserCancelled); <br>        if (lpszFileName == NULL) <br>        { <br>            if (!bUserCancelled) <br>            { <br>                ErrMsg(hWnd, __TEXT("fOpenNewImage:  lpszFileName == NULL")); <br>            } <br>            return(FALSE); <br>        } <br>    } <br> <br>    START_WAIT_CURSOR(hCur); <br>    hDIBInfo = ReadDIBFile(lpszFileName); <br>    END_WAIT_CURSOR(hCur); <br>    if (hDIBInfo) <br>    { <br>        LPDIBINFO lpDIBInfo, lpGlobalDIBInfo; <br> <br>        // Add file to recent files list. <br>        AddRecentFile(hWnd, lpszFileName); <br> <br>        // Copy ICM information from global LPDIBINFO <br>        lpDIBInfo = GlobalLock(hDIBInfo); <br>        lpGlobalDIBInfo = GetDIBInfoPtr(ghAppWnd); <br>        fDuplicateICMInfo(lpDIBInfo, lpGlobalDIBInfo); <br> <br>        // Now copy default options <br>        lpDIBInfo-&gt;bStretch          = lpGlobalDIBInfo-&gt;bStretch; <br>        lpDIBInfo-&gt;dwStretchBltMode  = lpGlobalDIBInfo-&gt;dwStretchBltMode; <br>        lpDIBInfo-&gt;dwPrintOption     = lpGlobalDIBInfo-&gt;dwPrintOption; <br> <br>        CreateNewImageWindow(hDIBInfo); <br>        GlobalUnlock(GlobalHandle(lpGlobalDIBInfo)); <br>        GlobalUnlock(GlobalHandle(lpDIBInfo)); <br>        bRC = TRUE; <br>    } <br>    else <br>    { <br>        ErrMsg(hWnd, __TEXT("Unable to open file %s"), lpszFileName); <br>        bRC = (FALSE); <br>    } <br>    hMem = GlobalHandle(lpszFileName); <br>    GlobalFree(hMem); <br>    return(bRC); <br>}   // End of fOpenNewImage <br> <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  CreateDIBPropSheet <br>// <br>//  Description: <br>//    Creates the property sheet used to describe a DIB. <br>// <br>//  Parameters: <br>//    HWND        Handle to the window which owns the property sheet <br>//    HINSTANCE   Instance handle <br>// <br>//  Returns: <br>//    int   Return value from the call to Win32 API PropertySheet <br>// <br>//  Comments: <br>// <br>////////////////////////////////////////////////////////////////////////// <br>int CreateDIBPropSheet(HWND hwndOwner, HINSTANCE hInst, int nStartPage, LPTSTR lpszCaption) <br>{ <br>    // Local variables <br>    PROPSHEETPAGE     PropSheetPage[(DIB_PROPSHEET_MAX+1)]; <br>    PROPSHEETHEADER   PropSheetHdr; <br>    DIBPROPSHEETINFO  DIBPropSheetInfo[(DIB_PROPSHEET_MAX+1)]; <br>    int               iPropSheet;  // Return code for PropertySheet call <br> <br>    // Initialize vars <br>    SetLastError(0); <br>    ASSERT((DIB_PROPSHEET_MIN &lt;= nStartPage) &amp;&amp; (DIB_PROPSHEET_MAX &gt;= nStartPage)); <br>    if ((DIB_PROPSHEET_MIN &gt; nStartPage) &amp;&amp; (DIB_PROPSHEET_MAX &lt; nStartPage)) <br>    { <br>        nStartPage = DIB_PROPSHEET_DEFAULT; <br>    } <br> <br>    // Initialize PROPERTYSHEETHEADER <br>    PropSheetHdr.dwSize = sizeof(PROPSHEETHEADER); <br>    PropSheetHdr.dwFlags = PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW; <br>    PropSheetHdr.hwndParent = hwndOwner; <br>    PropSheetHdr.hInstance = hInst; <br>    PropSheetHdr.pszIcon = NULL; <br>    PropSheetHdr.pszCaption = lpszCaption; <br>    PropSheetHdr.nPages = sizeof(PropSheetPage) / sizeof(PROPSHEETPAGE); <br>    PropSheetHdr.ppsp = (LPCPROPSHEETPAGE)&amp;PropSheetPage; <br>    PropSheetHdr.nStartPage = nStartPage; <br> <br>    // Initialize DIB Display Property Sheet <br>    PropSheetPage[0].dwSize = sizeof(PROPSHEETPAGE); <br>    PropSheetPage[0].dwFlags = PSP_USETITLE; <br>    PropSheetPage[0].hInstance = hInst; <br>    PropSheetPage[0].pszTemplate = MAKEINTRESOURCE(IDD_DISPLAY); <br>    PropSheetPage[0].pszIcon = NULL; <br>    PropSheetPage[0].pfnDlgProc = DlgDIBPropSheet; <br>    PropSheetPage[0].pszTitle = __TEXT("Display"); <br>    DIBPropSheetInfo[0].uiPageNum = DIB_PROPSHEET_DISPLAY; <br>    DIBPropSheetInfo[0].hDIBInfo = GetDIBInfoHandle(hwndOwner); <br>    PropSheetPage[0].lParam = (LPARAM)(LPDIBPROPSHEETINFO)&amp;DIBPropSheetInfo[0]; <br> <br>    // Initialize DIB Print Property Sheet <br>    PropSheetPage[1].dwSize = sizeof(PROPSHEETPAGE); <br>    PropSheetPage[1].dwFlags = PSP_USETITLE; <br>    PropSheetPage[1].hInstance = hInst; <br>    PropSheetPage[1].pszTemplate = MAKEINTRESOURCE(IDD_PRINT); <br>    PropSheetPage[1].pszIcon = NULL; <br>    PropSheetPage[1].pfnDlgProc = DlgDIBPropSheet; <br>    PropSheetPage[1].pszTitle = __TEXT("Printer"); <br>    DIBPropSheetInfo[1].uiPageNum = DIB_PROPSHEET_PRINT; <br>    DIBPropSheetInfo[1].hDIBInfo = GetDIBInfoHandle(hwndOwner); <br>    PropSheetPage[1].lParam = (LPARAM)(LPDIBPROPSHEETINFO)&amp;DIBPropSheetInfo[1]; <br> <br>    // Create the property sheet and return <br>    iPropSheet = PropertySheet(&amp;PropSheetHdr); <br>    return(iPropSheet); <br>} // End of function CreateDIBPropSheet <br> <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  DlgDIBPropSheet <br>// <br>//  Description: <br>//    Routine to handle the DIB Display properties property sheet. <br>// <br>//  Parameters: <br>//    @@@ <br>// <br>//  Returns: <br>//    @@@ <br>// <br>//  Comments: <br>// <br>////////////////////////////////////////////////////////////////////////// <br>BOOL APIENTRY DlgDIBPropSheet(HWND hwndPSPage, UINT uiMsg, WPARAM wParam, LPARAM lParam) <br>{ <br>    // Local variables <br>    HGLOBAL           hDIBInfo; <br>    LPDIBINFO         lpDIBInfo; <br>    static  UINT      uiPageNum = (UINT)UNINIT_DWORD; <br>    static  LPDIBINFO lpTempDIBInfo = NULL; <br>    static  HWND      hwndOwner = NULL; <br>    static  HWND      hwndPSPagePropSheet = NULL; <br>    HDC     hDC; <br>    LPTSTR   lpszInitialProfile; <br>    LPDIBPROPSHEETINFO  lpDIBPropSheetInfo; <br> <br>    // Init variables <br>    hDC = NULL; <br>    lpszInitialProfile = NULL; <br>    switch (uiMsg) <br>    { <br>        case WM_INITDIALOG: <br>            // Save the page number associated w/this page <br>            lpDIBPropSheetInfo = (LPDIBPROPSHEETINFO) ((LPPROPSHEETPAGE)lParam)-&gt;lParam; <br>            uiPageNum = lpDIBPropSheetInfo-&gt;uiPageNum; <br>            ASSERT(uiPageNum &gt;= DIB_PROPSHEET_MIN &amp;&amp; uiPageNum &lt;= DIB_PROPSHEET_MAX); <br>            SetWindowLong(hwndPSPage, GWL_ID, uiPageNum); <br>            hDIBInfo = lpDIBPropSheetInfo-&gt;hDIBInfo; <br>            lpDIBInfo = GlobalLock(hDIBInfo); <br>            hwndOwner = lpDIBInfo-&gt;hWndOwner; <br>            lpTempDIBInfo = fDuplicateDIBInfo(lpTempDIBInfo, lpDIBInfo); <br> <br>            if (uiPageNum == DIB_PROPSHEET_DISPLAY) <br>            { <br>                ASSERT(lpDIBInfo); <br> <br>                // Copy the DIBINFO structure for the image to a temporary DIBINFO <br>                // structure.  If the user presses "OK" or "Accept" to close the <br>                // property sheet, the temporary DIBINFO will be copied back into the <br>                // image's DIBINFO to reflect any possible changes. <br>                ASSERT(lpTempDIBInfo); <br>                lpszInitialProfile = lpTempDIBInfo-&gt;lpszMonitorProfile; <br>            } <br>            else if (uiPageNum == DIB_PROPSHEET_PRINT) <br>            { <br>                lpszInitialProfile = lpTempDIBInfo-&gt;lpszPrinterProfile; <br>            } <br> <br>            GlobalUnlock(hDIBInfo); <br>            break; <br> <br>        case WM_DESTROY: <br>            ASSERT(NULL != hwndOwner); <br>            if (NULL != hwndOwner) <br>            { <br>                InvalidateRect(      hwndOwner,       NULL,       FALSE); <br>            } <br>            if (lpTempDIBInfo) <br>            { <br>                fFreeDIBInfo(GlobalHandle(lpTempDIBInfo), FALSE); <br>            } <br>            lpTempDIBInfo = NULL; <br>            break; <br> <br>        case WM_NOTIFY: <br>            switch (((LPNMHDR)lParam)-&gt;code)  // type of notification message <br>            { <br>                case PSN_SETACTIVE: <br>                    // Initialize the controls <br>                    uiPageNum = GetWindowLong(hwndPSPage,GWL_ID); <br>                    if (uiPageNum == DIB_PROPSHEET_PRINT) <br>                    { <br>                        PopulatePrinterCombobox(hwndPSPage, IDC_PRINT_PRINTERLIST, lpTempDIBInfo-&gt;lpszPrinterName); <br>                    } <br> <br>                    // Update the dialog based upon the contents of lpDIBInfo <br>                    DlgDIBInfoPaint(hwndPSPage, lpTempDIBInfo); <br>                    SetDlgMsgResult(hwndPSPage, uiMsg, FALSE); <br>                    break; <br> <br>                case PSN_KILLACTIVE: <br>                    SaveDIBInfoDlgPage(hwndPSPage, lpTempDIBInfo, uiPageNum); <br>                    SetDlgMsgResult(hwndPSPage, uiMsg, FALSE); <br>                    break; <br> <br>                case PSN_APPLY: <br>                    lpDIBInfo = GetDIBInfoPtr(hwndOwner); <br>                    if (NULL == fDuplicateDIBInfo(lpDIBInfo, lpTempDIBInfo )) <br>                    { <br>                        ErrMsg(hwndPSPage, __TEXT("fDuplicateDIBInfo:  Failed to copy DIBINFO")); <br>                    } <br>                    ASSERT(lpDIBInfo != NULL); <br>                    GlobalUnlock(GlobalHandle(lpDIBInfo)); <br>                    SetDlgMsgResult(hwndPSPage, uiMsg, PSNRET_NOERROR); <br>                    break; <br> <br>                case PSN_RESET: <br>                    fFreeDIBInfo(lpTempDIBInfo, FALSE); <br>                    lpTempDIBInfo = NULL; <br>                    SetDlgMsgResult(hwndPSPage, uiMsg, FALSE); <br>                    break; <br> <br>                default: <br>                    break; <br>            } <br> <br>        case WM_COMMAND: <br>            { <br>                switch (LOWORD(wParam)) <br>                { <br>                    case IDC_DISPLAY_STRETCH: <br>                        { <br>                            BOOL  bChecked; <br> <br>                            bChecked = IsDlgButtonChecked(hwndPSPage, IDC_DISPLAY_STRETCH); <br>                            EnableWindow(GetDlgItem(hwndPSPage, IDC_DISPLAY_ANDSCAN), bChecked); <br>                            EnableWindow(GetDlgItem(hwndPSPage, IDC_DISPLAY_DELETESCAN), bChecked); <br>                            EnableWindow(GetDlgItem(hwndPSPage, IDC_DISPLAY_ORSCAN), bChecked); <br>                        } <br>                        break; <br> <br>                    case IDC_PRINT_IMAGE: <br>                        { <br>                            HCURSOR hCur; <br>                            HGLOBAL hDIBInfo, hTempDIBInfo; <br> <br>                            START_WAIT_CURSOR(hCur); <br>                            hDIBInfo = GetDIBInfoHandle(hwndOwner); <br>                            SaveDIBInfoDlgPage(hwndPSPage, lpTempDIBInfo, uiPageNum); <br> <br>                            // Use current settings <br>                            hTempDIBInfo = GlobalHandle(lpTempDIBInfo); <br>                            SetWindowLong(hwndOwner, GWL_DIBINFO, (LONG)hTempDIBInfo); <br> <br>                            PrintImage(hwndOwner); <br> <br>                            //Restore settings <br>                            SetWindowLong(hwndOwner, GWL_DIBINFO, (LONG)hDIBInfo); <br>                            END_WAIT_CURSOR(hCur); <br>                        } <br>                        break; <br> <br>                    default: <br>                        break; <br>                } <br> <br>            } <br>        default: <br>            break; <br>    } <br>    return(FALSE);  // FALSE means let the system property sheet code take over <br>} // End of function DlgDIBPropSheet <br> <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  DlgDIBInfoPaint <br>// <br>//  Description: <br>//    Update the dialog based upon the contents of lpDIBInfo.  This includes <br>//    determining which property sheet page is visible, and using this <br>//    information to populate the device profile ComboBox for the proper <br>//    device type. <br>// <br>//  Parameters: <br>//    HWND      Handle to the dialog. <br>//    LPDIBINFO Pointer to DIBINFO structure. <br>//    LPICMINFO Pointer to ICMINFO structure. <br>// <br>//  Returns: <br>//    void <br>// <br>//  Comments: <br>// <br>////////////////////////////////////////////////////////////////////////// <br>void DlgDIBInfoPaint(HWND  hDlg, LPDIBINFO lpDIBInfo) <br>{ <br>    // Local variables <br>    UINT    uiPageNum;        // ID's which property sheet page is visible <br> <br> <br>    // Initialize variables <br>    ASSERT(lpDIBInfo != NULL); <br>    uiPageNum = GetWindowLong(hDlg, GWL_ID); <br>    ASSERT(uiPageNum &lt;= DIB_PROPSHEET_MAX); <br> <br>    // Update the page-specific elements first <br>    switch (uiPageNum) <br>    { <br>        case DIB_PROPSHEET_DISPLAY: <br> <br>            // Display the display method information <br>            CheckDlgButton(hDlg, IDC_DISPLAY_STRETCH, lpDIBInfo-&gt;bStretch); <br> <br>            // Enable/Disable stretch mode buttons <br>            EnableWindow(GetDlgItem(hDlg, IDC_DISPLAY_ANDSCAN), lpDIBInfo-&gt;bStretch); <br>            EnableWindow(GetDlgItem(hDlg, IDC_DISPLAY_DELETESCAN), lpDIBInfo-&gt;bStretch); <br>            EnableWindow(GetDlgItem(hDlg, IDC_DISPLAY_ORSCAN), lpDIBInfo-&gt;bStretch); <br> <br>            // Select stretch mode if necessary <br>            ASSERT(lpDIBInfo-&gt;dwStretchBltMode &gt;= STRETCH_ANDSCANS); <br>            ASSERT(lpDIBInfo-&gt;dwStretchBltMode &lt;= STRETCH_DELETESCANS); <br>            switch ((int)(lpDIBInfo-&gt;dwStretchBltMode)) <br>            { <br>                case STRETCH_ANDSCANS: <br>                    CheckRadioButton(hDlg, IDC_DISPLAY_ANDSCAN, IDC_DISPLAY_ORSCAN, IDC_DISPLAY_ANDSCAN); <br>                    break; <br>                case STRETCH_DELETESCANS: <br>                    CheckRadioButton(hDlg, IDC_DISPLAY_ANDSCAN, IDC_DISPLAY_ORSCAN, IDC_DISPLAY_DELETESCAN); <br>                    break; <br>                case STRETCH_ORSCANS: <br>                    CheckRadioButton(hDlg, IDC_DISPLAY_ANDSCAN, IDC_DISPLAY_ORSCAN, IDC_DISPLAY_ORSCAN); <br>                    break; <br>                default: <br>                    CheckRadioButton(hDlg, IDC_DISPLAY_ANDSCAN, IDC_DISPLAY_ORSCAN, IDC_DISPLAY_ANDSCAN); <br>            } <br>            break; <br> <br> <br>        case DIB_PROPSHEET_PRINT: <br>            // Select print size <br>            { <br>                int iPrintSize = IDC_PRINT_BESTFIT; <br> <br>                if (lpDIBInfo-&gt;dwPrintOption == ICMV_PRINT_ACTUALSIZE) <br>                { <br>                    iPrintSize = IDC_PRINT_ACTUALSIZE; <br>                } <br>                CheckRadioButton(hDlg, IDC_PRINT_ACTUALSIZE, IDC_PRINT_BESTFIT, iPrintSize); <br>            } <br>            break; <br> <br>        default: <br>            break; <br>    } <br> <br>} // End of function DlgDIBInfoPaint <br> <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  SaveDIBInfoDlgPage <br>// <br>//  Description: <br>//    Saves the current page of the property sheet to the specified DIBINFO structure. <br>// <br>//  Parameters: <br>//    @@@ <br>// <br>//  Returns: <br>//    BOOL  TRUE upon success, FALSE otherwise <br>// <br>//  Comments: <br>// <br>// <br>////////////////////////////////////////////////////////////////////////// <br>BOOL SaveDIBInfoDlgPage(HWND hDlg, LPDIBINFO lpDIBInfo, UINT uiPageNum) <br>{ <br>    switch (uiPageNum) <br>    { <br>        case DIB_PROPSHEET_DISPLAY: <br>            lpDIBInfo-&gt;bStretch = IsDlgButtonChecked(hDlg, IDC_DISPLAY_STRETCH); <br>            if (IsDlgButtonChecked(hDlg, IDC_DISPLAY_ANDSCAN)) <br>                lpDIBInfo-&gt;dwStretchBltMode = STRETCH_ANDSCANS; <br>            else if (IsDlgButtonChecked(hDlg, IDC_DISPLAY_DELETESCAN)) <br>                lpDIBInfo-&gt;dwStretchBltMode = STRETCH_DELETESCANS; <br>            else if (IsDlgButtonChecked(hDlg, IDC_DISPLAY_ORSCAN)) <br>                lpDIBInfo-&gt;dwStretchBltMode = STRETCH_ORSCANS; <br> <br>            if (CHECK_DWFLAG(lpDIBInfo-&gt;dwICMFlags, ICMVFLAGS_ICM20)) <br>            { <br>                SetDWFlags((LPDWORD)&amp;(lpDIBInfo-&gt;dwICMFlags), ICMVFLAGS_CREATE_TRANSFORM, TRUE); <br>            } <br>            break; <br> <br>        case DIB_PROPSHEET_PRINT: <br>            { <br>                LPTSTR  pszTemp; <br> <br> <br>                pszTemp = GetDlgItemString(hDlg, IDC_PRINT_PRINTERLIST, NULL); <br>                if ( (NULL != pszTemp) <br>                     &amp;&amp; <br>                     (_tcscmp(pszTemp, __TEXT("No printers installed"))) <br>                   ) <br>                { <br>                    if (lstrcmpi(pszTemp, lpDIBInfo-&gt;lpszPrinterName)) <br>                    { <br>                        HDC     hPrinterDC; <br>                        TCHAR   szProfile[MAX_PATH]; <br>                        DWORD   dwSize = MAX_PATH; <br> <br> <br>                        GlobalFree(lpDIBInfo-&gt;lpszPrinterName); <br>                        lpDIBInfo-&gt;lpszPrinterName = pszTemp; <br>                        if (NULL != lpDIBInfo-&gt;pDevMode) <br>                            GlobalFree(GlobalHandle(lpDIBInfo-&gt;pDevMode)); <br>                        lpDIBInfo-&gt;pDevMode = GetDefaultPrinterDevMode(lpDIBInfo-&gt;lpszPrinterName); <br> <br>                        hPrinterDC = CreateDC(NULL, lpDIBInfo-&gt;lpszPrinterName, NULL, lpDIBInfo-&gt;pDevMode); <br>                        if (NULL != hPrinterDC) <br>                        { <br>                            if (GetICMProfile(hPrinterDC, &amp;dwSize, szProfile)) <br>                                UpdateString(&amp;lpDIBInfo-&gt;lpszPrinterProfile, szProfile); <br>                            DeleteDC(hPrinterDC); <br>                        } <br>                    } <br>                } <br>                else <br>                { <br>                    if (NULL != lpDIBInfo-&gt;lpszPrinterName) <br>                    { <br>                        GlobalFree(lpDIBInfo-&gt;lpszPrinterName); <br>                        lpDIBInfo-&gt;lpszPrinterName = NULL; <br>                    } <br> <br>                    if (NULL != pszTemp) <br>                    { <br>                        GlobalFree(pszTemp); <br>                    } <br>                } <br> <br>                if (IsDlgButtonChecked(hDlg, IDC_PRINT_ACTUALSIZE)) <br>                { <br>                    lpDIBInfo-&gt;dwPrintOption = ICMV_PRINT_ACTUALSIZE; <br>                } <br>                else <br>                { <br>                    lpDIBInfo-&gt;dwPrintOption = ICMV_PRINT_BESTFIT; <br>                } <br>            } <br>            break; <br> <br>        default: <br>            DebugMsg(__TEXT("DIALOGS.C : SaveDIBInfoDlgPage : Invalid uiPageNum\r\n")); <br>            return(FALSE); <br>            break; <br>    } <br>    return(TRUE); <br>}   // End of function SaveDIBInfoDlgPage <br> <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  GetDlgItemString <br>// <br>//  Description: <br>//    If the specified control identifier text differs from the string <br>//    passed in, the string will be reallocated to the proper size and <br>//    the currently displayed item will be copied into the string. <br>// <br>//  Parameters: <br>//    @@@ <br>// <br>//  Returns: <br>//    LPTSTR <br>// <br>//  Comments: <br>// <br>// <br>////////////////////////////////////////////////////////////////////////// <br>LPTSTR GetDlgItemString(HWND hDlg, int iControlId, LPTSTR lpszCurrentString) <br>{ <br>    // Local variables <br>    TCHAR    szEditString[MAX_PATH + 1]; <br> <br>    //  Initialize variables <br>    if (lpszCurrentString == NULL) <br>    { <br>        lpszCurrentString = GlobalAlloc(GPTR, sizeof(TCHAR)); <br>        _tcscpy(lpszCurrentString, __TEXT("")); <br>    } <br> <br>    GetDlgItemText(hDlg, iControlId, szEditString, MAX_PATH); <br>    { <br>        if (_tcscmp(szEditString, lpszCurrentString) != 0) <br>        { <br>            // Edit control differs from current string <br>            HGLOBAL hNewString, hCurrentString; <br> <br>            hCurrentString = GlobalHandle(lpszCurrentString); <br>            GlobalUnlock(hCurrentString); <br>            hNewString = GlobalReAlloc(hCurrentString, (lstrlen(szEditString)+1) *sizeof(TCHAR), GMEM_MOVEABLE); <br>            lpszCurrentString = GlobalLock(hNewString); <br> <br>            _tcscpy(lpszCurrentString, szEditString); <br>        } <br>    } <br>    return(lpszCurrentString); <br>}   // End of function GetDlgItemString <br> <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  ColorMatchUI <br>// <br>//  Description: <br>//    Fills in COLORMATCHSETUP structure and calls SetupColorMatching, the new ICM 2.0 UI. <br>// <br>//  Parameters: <br>//    HWND  Owner window; NULL if dialog to have no owner. <br>// <br>//  Returns: <br>//    BOOL <br>// <br>//  Comments: <br>// <br>// <br>////////////////////////////////////////////////////////////////////////// <br> <br>BOOL ColorMatchUI(HWND hwndOwner, LPVOID lpvDIBInfo) <br>{ <br>    // Local variables <br>    COLORMATCHSETUP     CMSetup; <br>    BOOL                bSetup; <br>    TCHAR               stPrinterProfile[MAX_PATH]; </code></pre>
<p>
</p>
<pre><code>TCHAR               stMonitorProfile[MAX_PATH]; <br>    TCHAR               stTargetProfile[MAX_PATH]; <br>    LPDIBINFO           lpDIBInfo; <br>    DWORD               dwICMFlags; <br>    LPBITMAPV5HEADER    lpbi; <br> <br>    //  ASSERTs and parameter validations <br>    ASSERT((NULL != hwndOwner) &amp;&amp; (NULL != lpvDIBInfo)); <br>    if ((NULL == hwndOwner) || (NULL == lpvDIBInfo)) <br>    { <br>        SetLastError(ERROR_INVALID_PARAMETER); <br>        return(FALSE); <br>    } <br> <br>    //  Initialize variables <br>#ifdef _DEBUG <br>    memset((PBYTE)&amp;CMSetup, UNINIT_BYTE, sizeof(COLORMATCHSETUP)); <br>#endif <br> <br>    lpDIBInfo = (LPDIBINFO)lpvDIBInfo; <br>    dwICMFlags = lpDIBInfo-&gt;dwICMFlags; <br> <br>    // Fill in required information <br>    // HACK for differnect versions of ICMUI. <br>    CMSetup.dwSize    = sizeof(COLORMATCHSETUP); <br>    CMSetup.dwVersion = COLOR_MATCH_VERSION; <br> <br>    // Set ICM Flags <br>    CMSetup.dwFlags   = SetColorMatchUIFlags(lpDIBInfo-&gt;dwICMFlags) | CMS_USEAPPLYCALLBACK; <br>    CMSetup.hwndOwner = hwndOwner; <br> <br>    // Fill in source name <br>    CMSetup.pSourceName   =  NULL; <br>    lpbi = (LPBITMAPV5HEADER)GlobalLock(lpDIBInfo-&gt;hDIB); <br>    if (IS_BITMAPV5HEADER(lpbi)) <br>    { <br>        switch (lpbi-&gt;bV5CSType) <br>        { <br>            case PROFILE_LINKED: <br>                CMSetup.pSourceName = (LPCTSTR)GETPROFILEDATA(lpbi); <br>                break; <br> <br>            case PROFILE_EMBEDDED: <br>                CMSetup.pSourceName = &amp;(__TEXT("Embedded Profile")); <br>                break; <br> <br>            default: <br>                break; <br>        } <br> <br>    } <br>    GlobalUnlock(lpDIBInfo-&gt;hDIB); <br> <br>    // Fill in device names <br>    CMSetup.pDisplayName  =  lpDIBInfo-&gt;lpszMonitorName; <br>    CMSetup.pPrinterName  =  lpDIBInfo-&gt;lpszPrinterName; <br> <br>    // Fill in profile names.  Make local copies of the values within <br>    // the DIBINFO structure, as they may have been allocated to the <br>    // size of the actual strings. <br> <br>    stPrinterProfile[0] = (TCHAR)'\0'; <br>    if (lpDIBInfo-&gt;lpszPrinterProfile) <br>    { <br>        _tcscpy((LPTSTR)stPrinterProfile, lpDIBInfo-&gt;lpszPrinterProfile); <br>    } <br>    CMSetup.pPrinterProfile = (LPTSTR)&amp;stPrinterProfile; <br>    CMSetup.ccPrinterProfile = MAX_PATH; <br> <br>    stMonitorProfile[0] = (TCHAR)'\0'; <br>    if (lpDIBInfo-&gt;lpszMonitorProfile) <br>    { <br>        _tcscpy((LPTSTR)stMonitorProfile, lpDIBInfo-&gt;lpszMonitorProfile); <br>    } <br>    CMSetup.pMonitorProfile = (LPTSTR)&amp;stMonitorProfile; <br>    CMSetup.ccMonitorProfile = MAX_PATH; <br> <br>    stTargetProfile[0] = (TCHAR)'\0'; <br>    if (lpDIBInfo-&gt;lpszTargetProfile) <br>    { <br>        _tcscpy((LPTSTR)stTargetProfile, lpDIBInfo-&gt;lpszTargetProfile); <br>    } <br>    CMSetup.pTargetProfile = (LPTSTR)&amp;stTargetProfile; <br>    CMSetup.ccTargetProfile = MAX_PATH; <br> <br>    // Set up rendering intents <br>    CMSetup.dwRenderIntent = lpDIBInfo-&gt;dwRenderIntent; <br>    CMSetup.dwProofingIntent = lpDIBInfo-&gt;dwProofingIntent; <br> <br>    // Set up for apply callback. <br>    CMSetup.lpfnApplyCallback = ColorSetupApply; <br>    CMSetup.lParamApplyCallback = (LPARAM) lpDIBInfo; <br> <br>    // Clear unused items <br>    CMSetup.lpfnHook = NULL; <br>    CMSetup.lParam = (LPARAM)NULL; <br> <br>    // Save ICM state before call <br>    dwICMFlags = lpDIBInfo-&gt;dwICMFlags; <br> <br> <br>    // Call the function to create the actual dialog <br>    SetLastError(0); <br>    bSetup = SetupColorMatching(&amp;CMSetup); <br> <br>    // Save information from dialog <br>    if (!bSetup) <br>    { <br>        if (ERROR_SUCCESS == GetLastError()) // User cancelled the dialog <br>        { <br>            return(TRUE); <br>        } <br>        else  // Something unexpected happened <br>        { <br>            DISPLAY_LASTERROR(LASTERROR_NOALLOC, GetLastError()); <br>        } <br>    } <br> <br>    ApplyColorSettings(lpDIBInfo, &amp;CMSetup); <br> <br>    return(bSetup); <br>} // End of function ColorMatchUI <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  SetColorMatchUIFlags <br>// <br>//  Description: <br>//    Function which converts a DIBINFO's dwFlags to a COLORMATCHSETUP flag. <br>// <br>//  Parameters: <br>//    @@@ <br>// <br>//  Returns: <br>//    BOOL <br>// <br>//  Comments: <br>// <br>// <br>////////////////////////////////////////////////////////////////////////// <br>DWORD SetColorMatchUIFlags(DWORD dwDIFlags) <br>{ <br>    // Local variables <br>    DWORD       dwCMFlags;      // COLORMATCHSETUP flags <br> <br>    //  ASSERTs and parameter validations <br> <br>    //  Initialize variables <br>    dwCMFlags = CMS_SETRENDERINTENT | CMS_SETPROOFINTENT | CMS_SETTARGETPROFILE <br>                | CMS_SETMONITORPROFILE | CMS_SETPRINTERPROFILE; <br> <br>    if (!CHECK_DWFLAG(dwDIFlags, ICMVFLAGS_ENABLE_ICM)) <br>    { <br>        dwCMFlags |= CMS_DISABLEICM; <br>    } <br> <br>    if (CHECK_DWFLAG(dwDIFlags, ICMVFLAGS_PROOFING)) <br>    { <br>        dwCMFlags |= CMS_ENABLEPROOFING; <br>    } <br>    return(dwCMFlags); <br>} // End of function SetColorMatchUIFlags <br> <br> <br>/////////////////////////////////////////////////////////////////////// <br>// <br>// Function:   SaveDIBToFileDialog <br>// <br>// Purpose:    Gets file name and saves DIB to file. <br>// <br>// Parms: <br>// <br>/////////////////////////////////////////////////////////////////////// <br> <br>void SaveDIBToFileDialog(HWND hWnd, LPDIBINFO lpDIBInfo) <br>{ <br>    TCHAR           szFileName[MAX_PATH]; <br>    DWORD           dwSaveAs[3] = {LCS_sRGB, LCS_sRGB, LCS_sRGB}; <br>    OPENFILENAME    OpenFileName; <br>    PBITMAPV5HEADER pBitmap; <br> <br> <br>    // Validate parameters. <br>    if (NULL == lpDIBInfo) <br>        return; <br> <br>    // Save bitmap. <br>    pBitmap = (PBITMAPV5HEADER) GlobalLock(lpDIBInfo-&gt;hDIB); <br>    if (NULL != pBitmap) <br>    { <br>        // Initialize OPENFILENAME structure for getting save as file name. <br>        lstrcpy(szFileName, lpDIBInfo-&gt;lpszImageFileName); <br>        memset(&amp;OpenFileName, 0, sizeof(OPENFILENAME)); <br>        OpenFileName.lStructSize = sizeof(OPENFILENAME); <br>        OpenFileName.hwndOwner = hWnd; <br>        OpenFileName.lpstrFile = szFileName; <br>        OpenFileName.nMaxFile = MAX_PATH; <br>        OpenFileName.lpstrTitle = __TEXT("Save Bitmap As"); <br>        OpenFileName.Flags = OFN_CREATEPROMPT | OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT; <br>        OpenFileName.lpstrDefExt = __TEXT("bmp"); <br> <br>        if ( (sizeof(BITMAPINFOHEADER) &lt; pBitmap-&gt;bV5Size) <br>             &amp;&amp; <br>             (LCS_CALIBRATED_RGB == pBitmap-&gt;bV5CSType) <br>           ) <br>        { <br>            // INVARIANT:  Bitmap is a calibrated RGB bitmap. <br> <br>            // Can save as sRGB or calibrated bitmap. <br>            OpenFileName.lpstrFilter = __TEXT("sRGB Bitmap (*.bmp)\0*.bmp\0Calibrated RGB Bitmap\0 (*.bmp)\0*.bmp\0"); <br>            dwSaveAs[1] = LCS_CALIBRATED_RGB; <br>        } <br>        else if ( (sizeof(BITMAPINFOHEADER) &lt; pBitmap-&gt;bV5Size) <br>                  &amp;&amp; <br>                  ( (PROFILE_LINKED == pBitmap-&gt;bV5CSType) <br>                    || <br>                    (PROFILE_EMBEDDED == pBitmap-&gt;bV5CSType) <br>                  ) <br>                ) <br>        { <br>            // INVARIANT:  Bitmap is either a LINKed or MBEDed bitmap. <br> <br>            // Can save as sRGB, linked or embeded, <br>            OpenFileName.lpstrFilter = __TEXT("sRGB Bitmap (*.bmp)\0*.bmp\0Linked Bitmap (*.bmp)\0*.bmp\0Embedded Bitmap (*.bmp)\0*.bmp\0\0"); <br>            dwSaveAs[1] = PROFILE_LINKED; <br>            dwSaveAs[2] = PROFILE_EMBEDDED; <br>        } <br>        else <br>        { <br>            // Can only save as sRGB bitmap. <br>            OpenFileName.lpstrFilter = __TEXT("sRGB Bitmap (*.bmp)\0*.bmp\0\0"); <br>        } <br> <br>        // No longer need hDIB in this routine. <br>        GlobalUnlock(lpDIBInfo-&gt;hDIB); <br> <br>        if (GetSaveFileName(&amp;OpenFileName)) <br>        { <br>            // INVARIANT:  User specified file and choice OK. <br> <br>            // Save DIB. <br>            SaveDIBToFile(hWnd, OpenFileName.lpstrFile, lpDIBInfo, dwSaveAs[OpenFileName.nFilterIndex -1]); <br>        } <br> <br>    } <br>} // End of function SaveDIBToFileDialog <br> <br> <br>/////////////////////////////////////////////////////////////////////// <br>// <br>// Function:   GetProfileSaveName <br>// <br>// Purpose:    Gets file name to save profile to. <br>// <br>// Parms: <br>// <br>/////////////////////////////////////////////////////////////////////// <br> <br>BOOL GetProfileSaveName(HWND hWnd, LPSTR* ppszFileName, DWORD dwSize) <br>{ <br>    OPENFILENAMEA   OpenFileName; <br> <br> <br>    // Initialize OPENFILENAME structure for getting save as file name. <br>    memset(&amp;OpenFileName, 0, sizeof(OPENFILENAME)); <br>    OpenFileName.lStructSize = sizeof(OPENFILENAME); <br>    OpenFileName.hwndOwner = hWnd; <br>    OpenFileName.lpstrFile = *ppszFileName; <br>    OpenFileName.nMaxFile = dwSize; <br>    OpenFileName.lpstrTitle = "Save Profile As"; <br>    OpenFileName.Flags = OFN_CREATEPROMPT | OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT; <br>    OpenFileName.lpstrFilter = "ICC Color Profile (*.icm, *.icc)\0*.icm;*.icc\0\0"; <br>    OpenFileName.lpstrDefExt = "icm"; <br> <br>    return GetSaveFileNameA(&amp;OpenFileName); <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////// <br>// <br>// Function:   ColorSetupApply <br>// <br>// Purpose:    Applies current color setup dialog values. <br>// <br>// Parms: <br>// <br>/////////////////////////////////////////////////////////////////////// <br> <br>BOOL WINAPI ColorSetupApply(PCOLORMATCHSETUP pcmSetup, LPARAM lParam) <br>{ <br>    ApplyColorSettings((LPDIBINFO)lParam, pcmSetup); <br>    return TRUE; <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////// <br>// <br>// Function:   ApplyColorSettings <br>// <br>// Purpose:    Applies color settings to dib info. <br>// <br>// Parms: <br>// <br>/////////////////////////////////////////////////////////////////////// <br> <br>VOID ApplyColorSettings(LPDIBINFO lpDIBInfo, PCOLORMATCHSETUP pCMSetup) <br>{ <br>    DWORD   dwICMFlags = lpDIBInfo-&gt;dwICMFlags; <br> <br> <br>    // Check if ICM and/or proofing is enabled <br>    SetDWFlags(&amp;(lpDIBInfo-&gt;dwICMFlags), ICMVFLAGS_PROOFING, CHECK_DWFLAG(pCMSetup-&gt;dwFlags, CMS_ENABLEPROOFING)); <br>    SetDWFlags(&amp;(lpDIBInfo-&gt;dwICMFlags), ICMVFLAGS_ENABLE_ICM, (!CHECK_DWFLAG(pCMSetup-&gt;dwFlags, CMS_DISABLEICM))); <br>    if ((dwICMFlags != lpDIBInfo-&gt;dwICMFlags) &amp;&amp; (CHECK_DWFLAG(lpDIBInfo-&gt;dwICMFlags, ICMVFLAGS_ICM20))) <br>    { <br>        SetDWFlags(&amp;(lpDIBInfo-&gt;dwICMFlags), ICMVFLAGS_CREATE_TRANSFORM, TRUE); <br>    } <br> <br>    // Update Intents <br>    if ((lpDIBInfo-&gt;dwRenderIntent != pCMSetup-&gt;dwRenderIntent) || (lpDIBInfo-&gt;dwProofingIntent != pCMSetup-&gt;dwProofingIntent)) <br>    { <br>        SetDWFlags(&amp;(lpDIBInfo-&gt;dwICMFlags), ICMVFLAGS_CREATE_TRANSFORM, TRUE); <br>    } <br>    lpDIBInfo-&gt;dwRenderIntent = pCMSetup-&gt;dwRenderIntent; <br>    lpDIBInfo-&gt;dwProofingIntent = pCMSetup-&gt;dwProofingIntent; <br> <br>    // Update DIBINFO profile strings if CMSetup strings have changed <br>    if (0 != _tcscmp(__TEXT(""), pCMSetup-&gt;pMonitorProfile)) <br>    { <br>        UpdateString(&amp;(lpDIBInfo-&gt;lpszMonitorProfile), pCMSetup-&gt;pMonitorProfile); <br>        SetDWFlags(&amp;(lpDIBInfo-&gt;dwICMFlags), ICMVFLAGS_CREATE_TRANSFORM, TRUE); <br>    } <br> <br>    if (0 != _tcscmp(__TEXT(""), pCMSetup-&gt;pPrinterProfile)) <br>    { <br>        UpdateString(&amp;(lpDIBInfo-&gt;lpszPrinterProfile), pCMSetup-&gt;pPrinterProfile); <br>    } <br> <br>    if (0 != _tcscmp(__TEXT(""), pCMSetup-&gt;pTargetProfile)) <br>    { <br>        UpdateString(&amp;(lpDIBInfo-&gt;lpszTargetProfile),  pCMSetup-&gt;pTargetProfile); <br>        SetDWFlags(&amp;(lpDIBInfo-&gt;dwICMFlags), ICMVFLAGS_CREATE_TRANSFORM, TRUE); <br>    } <br> <br>    InvalidateRect(lpDIBInfo-&gt;hWndOwner, NULL, FALSE); <br>} <br> <br> <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  PrintDialog <br>// <br>//  Description: <br>//    Displays printing dialog box. <br>// <br>//  Parameters: <br>//    @@@ <br>// <br>//  Returns: <br>//    BOOL <br>// <br>//  Comments: <br>// <br>// <br>////////////////////////////////////////////////////////////////////////// <br>BOOL PrintDialog(HWND hWnd, HINSTANCE hInst, LPDIBINFO lpDIBInfo) <br>{ <br>    PRINTDLG    Print; <br> <br> <br>    memset(&amp;Print, 0, sizeof(PRINTDLG)); <br>    Print.lStructSize = sizeof(PRINTDLG); <br>    Print.hwndOwner = hWnd; <br>    Print.hDevMode = GlobalHandle(lpDIBInfo-&gt;pDevMode); <br> <br>    if (PrintDlg(&amp;Print)) <br>    { <br>        lpDIBInfo-&gt;pDevMode = (PDEVMODE) GlobalLock(Print.hDevMode); <br>        if (lstrcmpi(lpDIBInfo-&gt;lpszPrinterName, lpDIBInfo-&gt;pDevMode-&gt;dmDeviceName)) <br>        { <br>            HDC     hPrinterDC; <br>            TCHAR   szProfile[MAX_PATH]; <br>            DWORD   dwSize = MAX_PATH; <br> <br> <br>            UpdateString(&amp;lpDIBInfo-&gt;lpszPrinterName, lpDIBInfo-&gt;pDevMode-&gt;dmDeviceName); <br>            hPrinterDC = CreateDC(NULL, lpDIBInfo-&gt;lpszPrinterName, NULL, lpDIBInfo-&gt;pDevMode); <br>            if (NULL != hPrinterDC) <br>            { <br>                if (GetICMProfile(hPrinterDC, &amp;dwSize, szProfile)) <br>                    UpdateString(&amp;lpDIBInfo-&gt;lpszPrinterProfile, szProfile); <br>                DeleteDC(hPrinterDC); <br>            } <br>        } <br>        PrintImage(hWnd); <br>    } <br> <br>    return TRUE; <br>} <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
