<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CHILD.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3497"></a>CHILD.C</h2>
<pre><code>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>// PARTICULAR PURPOSE. <br>// <br>// Copyright  1994-1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//  FILE: <br>//    CHILD.C <br>// <br>//  PURPOSE: <br>//    Routines for child windows. <br>// <br>//  PLATFORMS: <br>//    Windows 95, Windows NT <br>// <br>//  SPECIAL INSTRUCTIONS: N/A <br>// <br> <br>// These pragmas allow for the maximum warning level to be set <br>// without getting bombarded by warnings from the Windows SDK <br>// include files. <br>#pragma warning(disable:4001)   // Single-line comment warnings <br>#pragma warning(disable:4115)   // Named type definition in parentheses <br>#pragma warning(disable:4201)   // Nameless struct/union warning <br>#pragma warning(disable:4214)   // Bit field types other than int warnings <br>#pragma warning(disable:4514)   // Unreferenced inline function has been removed <br> <br>// Windows Header Files: <br>#include &lt;Windows.h&gt; <br>#include &lt;WindowsX.h&gt; <br>#include &lt;CommCtrl.h&gt; <br>#include &lt;STDLIB.H&gt; <br>#include "icm.h" <br> <br>// Restore the warnings--leave the single-line comment warning OFF <br>#pragma warning(default:4115)   // Named type definition in parentheses <br>#pragma warning(default:4201)   // Nameless struct/union warning <br>#pragma warning(default:4214)   // Bit field types other than int warnings <br> <br>// C RunTime Header Files <br> <br>// Local Header Files <br>#include "icmview.h" <br>#include "resource.h" <br>#include "child.h" <br>#include "DibInfo.H" <br>#include "dialogs.h" <br>#include "Dibs.h" <br>#include "print.h" <br>#include "debug.h" <br> <br>// Pre-processor definitions and macros <br> <br>// Typedefs and structs <br> <br>typedef struct TAG_PROGRESSPARAM <br>{ <br>    BOOL    bCancel; <br>    HWND    hWnd; <br>    HWND    hDialog; <br>    DWORD   dwStartTick; <br>} PROGRESSPARAM, *PPROGRESSPARAM; <br> <br> <br>// External global data <br> <br>// Private Global DataPrivate data <br> <br>// Function prototypes <br>void ChildWndPaint (HWND hWnd); <br>BOOL ChildWndQueryNewPalette (HWND hWnd, HWND hWndFrame); <br>BOOL WINAPI TransformProgress(ULONG ulMax, ULONG ulCurrent, ULONG ulCallbackData); <br>BOOL CALLBACK TransformProgressProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam); <br>void SizeScrollBars(HWND hWnd, LPDIBINFO lpDIBInfo, UINT uiWindowHeight, UINT uiWindowWidth); <br>void InitializeScrollBars(HWND hWnd, LPDIBINFO lpDIBInfo); <br>BOOL ScrollChildWindow(HWND hWnd, int nScrollBar, WORD wScrollCode); <br> <br> <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  ChildWndProc <br>// <br>//  Description: <br>//    Child window procedure. <br>// <br>//  Parameters: <br>//    HWND    handle of window <br>//    UINT    message identifier <br>//    WPARAM  first message parameter <br>//    LPARAM  second message parameter <br>// <br>//  Returns: <br>// <br>//  Comments: <br>// <br>////////////////////////////////////////////////////////////////////////// <br> <br>LRESULT CALLBACK ChildWndProc(HWND hWnd, UINT uiMsg, WPARAM wParam, LPARAM lParam) <br>{ <br>    LPDIBINFO   lpDIBInfo; <br>    int wmId, wmEvent; <br> <br>    // Initialize variables <br>    lpDIBInfo = GetDIBInfoPtr(hWnd); <br>    switch (uiMsg) <br>    { <br>        case WM_COMMAND: <br>            wmId    = LOWORD(wParam); <br>            wmEvent = HIWORD(wParam); <br> <br>            switch (wmId) <br>            { <br>                case ID_FILE_SAVEAS: <br>                    SaveDIBToFileDialog(hWnd, lpDIBInfo); <br>                    break; <br> <br>                case IDM_FILE_PRINT_SETUP: <br>                    CreateDIBPropSheet(hWnd, ghInst, DIB_PROPSHEET_PRINT, lpDIBInfo-&gt;lpszImageFileName); <br>                    SetFocus(ghAppWnd); <br>                    break; <br> <br>                case IDM_FILE_PRINT: <br>                    PrintDialog(hWnd, ghInst, lpDIBInfo); <br>                    break; <br> <br>                case IDM_FILE_DISPLAY: <br>                    CreateDIBPropSheet(hWnd, ghInst, DIB_PROPSHEET_DISPLAY, lpDIBInfo-&gt;lpszImageFileName); <br>                    InvalidateRect(hWnd, NULL, FALSE); <br>                    break; <br> <br>                case IDM_FILE_CLOSE: <br>                    SendMessage(hWnd, WM_CLOSE, 0, 0); <br>                    break; <br> <br>                case IDM_FILE_ICM20: <br>                case IDM_FILE_ICM10: <br>                case IDM_FILE_CONFIGURE_ICM: <br>                    { <br>                        HGLOBAL     hDIBInfo; <br>                        BOOL        bFreed; <br> <br>                        switch (wmId) <br>                        { <br>                            case IDM_FILE_ICM20: <br>                                if (!CHECK_DWFLAG(lpDIBInfo-&gt;dwICMFlags, ICMVFLAGS_ICM20))  // Don't redundantly transform DIB <br>                                { <br>                                    SetDWFlags((LPDWORD)&amp;(lpDIBInfo-&gt;dwICMFlags), ICMVFLAGS_CREATE_TRANSFORM, TRUE); <br>                                    SetDWFlags((LPDWORD)&amp;(lpDIBInfo-&gt;dwICMFlags), (ICMVFLAGS_ICM20), TRUE); <br>                                } <br>                                break; <br> <br>                            case IDM_FILE_ICM10: <br>                                SetDWFlags((LPDWORD)&amp;(lpDIBInfo-&gt;dwICMFlags), ICMVFLAGS_ICM20, FALSE); <br>                                break; <br> <br>                            case IDM_FILE_CONFIGURE_ICM: <br>                                ColorMatchUI(hWnd, lpDIBInfo); <br>                                break; <br> <br>                            default: <br>                                break; <br>                        } <br>                        hDIBInfo = GlobalHandle(lpDIBInfo); <br>                        bFreed = GlobalUnlock(hDIBInfo); <br>                        InvalidateRect(hWnd, NULL, FALSE); <br>                    } <br>                    break; <br> <br>                default: <br>                    return(DefMDIChildProc(hWnd, uiMsg, wParam, lParam)); <br>                    break; <br>            } <br>            break; <br> <br>        case WM_CONTEXTMENU: <br>            { <br>                HMENU hMenu; <br>                hMenu = InitImageMenu(hWnd); <br>                if (hMenu) <br>                { <br>                    TrackPopupMenu (hMenu, TPM_LEFTALIGN | TPM_RIGHTBUTTON, LOWORD(lParam), HIWORD(lParam), 0, hWnd, NULL); <br>                    DestroyMenu(hMenu); <br>                } <br>                return(0); <br>            } <br>            break; <br> <br>        case WM_PAINT: <br>            ChildWndPaint(hWnd); <br>            return(0); // We have processed the message <br>            break; <br> <br>        case WM_CLOSE: <br>            SendMessage(ghWndMDIClient, WM_MDIDESTROY, (WPARAM)(HWND)hWnd, 0); <br>            DestroyWindow(hWnd); <br>            SetFocus(ghAppWnd); <br>            return(1L); <br> <br>        case WM_DESTROY: <br>            fFreeDIBInfo(GetDIBInfoHandle(hWnd), TRUE); <br>            SetWindowLong(hWnd, GWL_DIBINFO, (LONG)NULL); <br>            break; <br> <br>        case WM_MDIACTIVATE: <br>            if (0 != wParam) <br>            { <br>                SendMessage (hWnd, MYWM_QUERYNEWPALETTE, (WPARAM) GetParent(ghWndMDIClient), 0L); <br>            } <br>            break; <br> <br>        case WM_SIZE: <br>            // May need to show or hide scroll bars. <br>            SizeScrollBars(hWnd, lpDIBInfo, HIWORD(lParam), LOWORD(lParam)); <br> <br>            // This makes sure that we redraw <br>            // all the window if we are stretching to window <br>            // and the size changes. <br>            InvalidateRect(hWnd, NULL, FALSE); <br>            break; <br> <br>        case WM_VSCROLL: <br>            ScrollChildWindow(hWnd, SB_VERT, LOWORD(wParam)); <br>            return FALSE; <br> <br>        case WM_HSCROLL: <br>            ScrollChildWindow(hWnd, SB_HORZ, LOWORD(wParam)); <br>            return FALSE; <br> <br>        case MYWM_QUERYNEWPALETTE: <br>            return ChildWndQueryNewPalette (hWnd, (HWND) wParam); <br>    } <br>    return DefMDIChildProc(hWnd, uiMsg, wParam, lParam); <br>} <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  CreateNewImageWindow <br>// <br>//  Description: <br>//    Creates a new window for a new image.  As this function is the <br>//    startup function for a new thread, some administrative duties <br>//    are required.  The following actions are taken when the new <br>//    thread is created: <br>//      -A new window is created. <br>//                      -A DIBINFO structure is created and associated with the <br>//       window via a SetWindowLong call. <br>//                      -The contents of the DIBINFO structure associated with the <br>//       main application window are copied into the new window's <br>//       DIBINFO structure. <br>// <br>//  Parameters: <br>//    DWORD   Actually an LPTSTR to the file name of the image. <br>// <br>//  Returns: <br>//    DWORD to be returned by implicit CloseThread call <br>// <br>//  Comments: <br>// <br>////////////////////////////////////////////////////////////////////////// <br> <br>DWORD CreateNewImageWindow(HANDLE hDIBInfo) <br>{ <br>    // Local variables <br>    int             nWidth; <br>    int             nHeight; <br>    HWND            hwndImage; <br>    HANDLE          hAccel; <br>    RECT            rcWindow; <br>    RECT            rcClient; <br>    LPDIBINFO       lpDIBInfo; <br> <br> <br>    //  Initialize variables <br>    ASSERT(ghWndMDIClient != NULL);  // If it's NULL, won't get a window for thread <br>    ASSERT(NULL != hDIBInfo); <br>    if (NULL == hDIBInfo) <br>    { <br>        return(FALSE); <br>    } <br>    lpDIBInfo = GlobalLock(hDIBInfo); <br> <br>    // Determine the necessary window size to hold the DIB. <br>    rcWindow.left   = 0; <br>    rcWindow.top    = 0; <br>    rcWindow.right  = (int) lpDIBInfo-&gt;uiDIBWidth; <br>    rcWindow.bottom = (int) lpDIBInfo-&gt;uiDIBHeight; <br> <br>    if (!AdjustWindowRectEx (&amp;rcWindow, <br>                             MDIS_ALLCHILDSTYLES|WS_CHILD|WS_SYSMENU|WS_CAPTION|WS_THICKFRAME|WS_MINIMIZEBOX|WS_MAXIMIZEBOX, <br>                             FALSE, WS_EX_MDICHILD)) <br>    { <br>        DebugMsg(__TEXT("CreateNewImageWindow:  AdjustWindowRectEx failed, LastError = %lu\r\n"), GetLastError()); <br>        return(ERROR_INVALID_PARAMETER); <br>    } <br> <br>    // Make sure child window is not larger than parent's client area. <br>    GetClientRect(ghWndMDIClient, &amp;rcClient); <br>    nWidth  = __min(rcClient.right, rcWindow.right - rcWindow.left); <br>    nHeight = __min(rcClient.bottom, rcWindow.bottom - rcWindow.top); <br> <br>    // Create child window; class declaration leaves room for pointer to DIBINFO. <br>    hwndImage = CreateWindowEx(WS_EX_MDICHILD, CHILD_CLASSNAME, <br>                               lpDIBInfo-&gt;lpszImageFileName, <br>                               MDIS_ALLCHILDSTYLES | WS_CHILD|WS_SYSMENU|WS_CAPTION|WS_THICKFRAME|WS_MINIMIZEBOX|WS_MAXIMIZEBOX, <br>                               0, 0, nWidth, nHeight, ghWndMDIClient, NULL, ghInst, 0); <br> <br>    if (hwndImage != NULL) <br>    { <br>        // Obtain handle to main window's ICMINFO <br>        lpDIBInfo-&gt;hWndOwner = hwndImage;  // Establish ownership of DIBINFO structure <br>        SetWindowLong(hwndImage, GWL_DIBINFO, (LONG)hDIBInfo); <br> <br>        // Initial scroll information. <br>        InitializeScrollBars(hwndImage, lpDIBInfo); <br> <br>        ShowWindow(hwndImage, SW_NORMAL); <br>        UpdateWindow(hwndImage); <br> <br>        SendMessage(hwndImage, MYWM_QUERYNEWPALETTE, (WPARAM) ghAppWnd, 0L); <br>    } <br>    else <br>    { <br>        DebugMsg(__TEXT("CreateNewImageWindow:  hwndImage = NULL, LastError = %lu\r\n"), GetLastError); <br>        return(ERROR_INVALID_PARAMETER); <br>    } <br> <br>    // Unlock handle <br>    GlobalUnlock(hDIBInfo); <br>    lpDIBInfo = NULL; <br> <br>    hAccel = LoadAccelerators(ghInst, __TEXT("ICMVIEW")); <br>    ASSERT(hAccel); <br>    return(ERROR_SUCCESS); <br>}   // End of CreateNewImageWindow <br> <br> <br>/////////////////////////////////////////////////////////////////////// <br>// <br>// Function:   ChildWndPaint <br>// <br>// Purpose:    Called by ChildWndProc() on WM_PAINT.  Does all paints <br>//             for this MDI child window. <br>// <br>//             Reads position of scroll bars to find out what part <br>//             of the DIB to display. <br>// <br>//             Checks the stretching flag in the DIBINFO structure for <br>//             this window to see if we are stretching to the window <br>//             (if we're iconic, we always stretch to a tiny bitmap). <br>// <br>//             Selects/Realizes the palette as a background palette. <br>//             The palette was realized as the foreground palette in <br>//             ChildWndQueryNewPalette() if this is the active window. <br>// <br>// <br>// Parms:      hWnd == Handle to window being painted. <br>// <br>/////////////////////////////////////////////////////////////////////// <br> <br>void ChildWndPaint(HWND hWnd) <br>{ <br>    HDC                 hDC; <br>    RECT                rectClient; <br>    RECT                rectDDB; <br>    BOOL                bStretch; <br>    HGLOBAL             hDIBInfo; <br>    LPDIBINFO           lpDIBInfo; <br>    HANDLE              hDIB; <br>    LPTSTR              lpszTargetProfile; <br>    DWORD               dwLCSIntent; <br>    HCURSOR             hCur; <br>    PAINTSTRUCT         ps; <br>    PROGRESSPARAM       ProgressParam; <br>    LPBITMAPINFOHEADER  lpBi; <br> <br>    // Initialize variables <br>    lpDIBInfo = NULL; <br>    lpBi = NULL; <br>    hDIBInfo = NULL; <br>    hDIB = NULL; <br>    lpszTargetProfile = NULL; <br> <br>    START_WAIT_CURSOR(hCur); <br>    hDC = BeginPaint (hWnd, &amp;ps); <br>    hDIBInfo = GetDIBInfoHandle(hWnd); <br> <br>    if ( (NULL != hDC) <br>         &amp;&amp; <br>         (NULL != hDIBInfo) <br>         &amp;&amp; <br>         (RECTWIDTH(&amp;ps.rcPaint) != 0) <br>         &amp;&amp; <br>         (RECTHEIGHT(&amp;ps.rcPaint) !=0) <br>       ) <br>    { <br>        lpDIBInfo = (LPDIBINFO)GlobalLock(hDIBInfo); <br> <br>        //Check if we're using ICM outside of the DC. If so, it might be necessary to <br>        // create a color transform. <br>        if ( CHECK_DWFLAG(lpDIBInfo-&gt;dwICMFlags,ICMVFLAGS_ICM20) &amp;&amp; CHECK_DWFLAG(lpDIBInfo-&gt;dwICMFlags, ICMVFLAGS_ENABLE_ICM)) <br>        { <br>            // Outside DC selected <br>            hDIB = lpDIBInfo-&gt;hDIBTransformed; <br>            if (CHECK_DWFLAG(lpDIBInfo-&gt;dwICMFlags, ICMVFLAGS_CREATE_TRANSFORM) || (hDIB == NULL)) <br>            { <br>                if (NULL != lpDIBInfo-&gt;hDIBTransformed)  // Free old transformed bits <br>                { <br>                    GlobalFree(lpDIBInfo-&gt;hDIBTransformed); <br>                } <br>                // Set up for transform <br>                if (CHECK_DWFLAG(lpDIBInfo-&gt;dwICMFlags, ICMVFLAGS_PROOFING)) <br>                { <br>                    lpszTargetProfile = lpDIBInfo-&gt;lpszTargetProfile; <br>                } <br>                // Initialize Progress Param structure. <br>                ProgressParam.bCancel = FALSE; <br>                ProgressParam.hWnd = hWnd; <br>                ProgressParam.hDialog = NULL; <br>                ProgressParam.dwStartTick = GetTickCount(); <br> <br>                ConvertIntent(lpDIBInfo-&gt;dwRenderIntent, ICC_TO_LCS, &amp;dwLCSIntent); <br>                lpDIBInfo-&gt;hDIBTransformed = TransformDIBOutsideDC(lpDIBInfo-&gt;hDIB, <br>                                                                   lpDIBInfo-&gt;bmFormat, <br>                                                                   lpDIBInfo-&gt;lpszMonitorProfile, <br>                                                                   lpszTargetProfile, <br>                                                                   USE_BITMAP_INTENT, NULL, //TransformProgress, <br>                                                                   (ULONG) &amp;ProgressParam); <br>                // May need to destroy progress dialog. <br>                if (IsWindow(ProgressParam.hDialog)) <br>                    DestroyWindow(ProgressParam.hDialog); <br> <br>                if (NULL == lpDIBInfo-&gt;hDIBTransformed) <br>                { <br>                    ErrMsg(hWnd, __TEXT("DIB Transform failed.  Disabling ICM")); <br>                    hDIB = lpDIBInfo-&gt;hDIB; <br>                    SetDWFlags((LPDWORD)&amp;(lpDIBInfo-&gt;dwICMFlags), ICMVFLAGS_ENABLE_ICM, FALSE); <br>                } <br>                else <br>                { <br>                    SetDWFlags((LPDWORD)&amp;(lpDIBInfo-&gt;dwICMFlags), ICMVFLAGS_CREATE_TRANSFORM, FALSE); <br>                    hDIB = lpDIBInfo-&gt;hDIBTransformed; <br>                } <br>            } <br>        } <br>        else  // Inside DC selected <br>        { <br>            hDIB = lpDIBInfo-&gt;hDIB; <br>        } <br> <br>        if (NULL != hDIB) <br>        { <br>            lpBi = GlobalLock(hDIB); <br>        } <br>        if (NULL == lpBi) <br>        { <br>            DebugMsg(__TEXT("CHILD.C : ChildWndPaint : NULL lpBi\r\n")); <br>            goto ABORTPAINT; <br>        } <br>        bStretch = lpDIBInfo-&gt;bStretch; <br> <br>        // Set up the necessary rectangles -- i.e. the rectangle <br>        //  we're rendering into, and the rectangle in the DIB. <br>        if (bStretch) <br>        { <br>            GetClientRect(hWnd, &amp;rectClient); <br>            rectDDB.left   = 0; <br>            rectDDB.top    = 0; <br>            rectDDB.right  = BITMAPWIDTH(lpBi); <br>            rectDDB.bottom = abs(BITMAPHEIGHT(lpBi)); <br>        } <br>        else <br>        { <br>            int xScroll; <br>            int yScroll; <br> <br> <br>            xScroll  = GetScrollPos(hWnd, SB_HORZ); <br>            yScroll  = GetScrollPos(hWnd, SB_VERT); <br>            CopyRect(&amp;rectClient, &amp;ps.rcPaint); <br> <br>            rectDDB.left   = xScroll + rectClient.left; <br>            rectDDB.top    = yScroll + rectClient.top; <br>            rectDDB.right  = rectDDB.left + RECTWIDTH(&amp;rectClient); <br>            rectDDB.bottom = rectDDB.top + RECTHEIGHT(&amp;rectClient); <br> <br>            if (rectDDB.right &gt; BITMAPWIDTH(lpBi)) <br>            { <br>                int dx; <br> <br>                dx = BITMAPWIDTH(lpBi) - rectDDB.right; <br>                rectDDB.right     += dx; <br>                rectClient.right  += dx; <br>            } <br> <br>            if (rectDDB.bottom &gt; abs(BITMAPHEIGHT(lpBi))) <br>            { <br>                int dy; <br> <br>                dy = abs(BITMAPHEIGHT(lpBi)) - rectDDB.bottom; <br>                rectDDB.bottom    += dy; <br>                rectClient.bottom += dy; <br>            } <br>        } <br>        DIBPaint (hDC, &amp;rectClient, hDIB, &amp;rectDDB, lpDIBInfo); <br> <br>        // Draw the clipboard selection rubber-band. <br>        SetWindowOrgEx (hDC, GetScrollPos(hWnd, SB_HORZ), GetScrollPos (hWnd, SB_VERT), NULL); <br>    } <br>    else <br>    { <br>        if (NULL == hDC) <br>        { <br>            END_WAIT_CURSOR(hCur); <br>            DebugMsg(__TEXT("ChildWndPaint : NULL hDC\r\n")); <br>            return; <br>        } <br>    } <br> <br>    ABORTPAINT: <br>    EndPaint (hWnd, &amp;ps); <br>    END_WAIT_CURSOR(hCur); <br> <br>    if (hDIB &amp;&amp; lpBi) <br>    { <br>        GlobalUnlock(hDIB); <br>    } <br>    if (lpDIBInfo) <br>    { <br>        GlobalUnlock(hDIBInfo); <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////// <br>// <br>// Function:   ChildWndQueryNewPalette <br>// <br>// Purpose:    Called by ChildWndProc() on WM_QUERYNEWPALETTE. <br>// <br>//             We get this message when an MDI child is getting <br>//             focus (by hocus pocus in FRAME.C, and by passing <br>//             this message when we get WM_MDIACTIVATE).  Normally <br>//             this message is passed only to the top level window(s) <br>//             of an application. <br>// <br>//             We want this window to have the foreground palette when this <br>//             happens, so we select and realize the palette as <br>//             a foreground palette (of the frame Window).  Then make <br>//             sure the window repaints, if necessary. <br>// <br>// Parms:      hWnd      == Handle to window getting WM_QUERYNEWPALETTE. <br>//             hWndFrame == Handle to the frame window (i.e. the top-level <br>//                            window of this app. <br>// <br>/////////////////////////////////////////////////////////////////////// <br> <br>BOOL ChildWndQueryNewPalette (HWND hWnd, HWND hWndFrame) <br>{ <br>    HPALETTE  hOldPal; <br>    HDC       hDC; <br>    HGLOBAL   hDIBInfo; <br>    LPDIBINFO lpDIBInfo; <br>    int       nColorsChanged; <br> <br>    hDIBInfo = GetDIBInfoHandle (hWnd); <br> <br>    if (!hDIBInfo) <br>        return FALSE; <br> <br>    lpDIBInfo = (LPDIBINFO) GlobalLock (hDIBInfo); <br> <br>    if (!lpDIBInfo-&gt;hPal) <br>    { <br>        GlobalUnlock (hDIBInfo); <br>        return FALSE; <br>    } <br> <br> <br>    // We're going to make our palette the foreground palette for <br>    //  this application.  Window's palette manager expects the <br>    //  top-level window of the application to have the palette, <br>    //  so, we get a DC for the frame here! <br> <br>    hDC     = GetDC (hWndFrame); <br>    hOldPal = SelectPalette (hDC, lpDIBInfo-&gt;hPal, FALSE); <br> <br>    nColorsChanged = RealizePalette (hDC); <br>    InvalidateRect (hWnd, NULL, FALSE); <br> <br>    if (hOldPal) <br>        SelectPalette (hDC, hOldPal, FALSE); <br> <br>    ReleaseDC (hWndFrame, hDC); <br> <br>    GlobalUnlock (hDIBInfo); <br> <br>    return (nColorsChanged != 0); <br>} <br> <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  TransformProgress <br>// <br>//  Description: <br>// <br>// <br>//  Parameters: <br>//    @@@ <br>// <br>//  Returns: <br>//    BOOL <br>// <br>//  Comments: <br>// <br>// <br>////////////////////////////////////////////////////////////////////////// <br>BOOL WINAPI TransformProgress(ULONG ulMax, ULONG ulCurrent, ULONG ulCallbackData) <br>{ <br>    PPROGRESSPARAM  pProgressParam = (PPROGRESSPARAM) ulCallbackData; <br> <br> <br>    DebugMsg(__TEXT("TransformProgress:  ulCurrent = %d, ulMax = %d\r\n"), ulCurrent, ulMax); <br> <br>    if (!IsWindow(pProgressParam-&gt;hDialog)) <br>    { <br>        DWORD   dwTick = GetTickCount(); <br> <br>        // May need to create progress dialog for translate bitmap bits. <br>        // Create dialog only if translation takes awhile to do. <br>        if ( (dwTick - pProgressParam-&gt;dwStartTick &gt; 1000L) &amp;&amp; ((double)ulCurrent/ulMax &lt; 0.33)) <br>        { <br>            // Created dialog must be destroyed by TranslateBitmapBits caller. <br>            pProgressParam-&gt;hDialog = CreateDialogParam(NULL, MAKEINTRESOURCE(IDD_TRANSLATE), <br>                                                        pProgressParam-&gt;hWnd, TransformProgressProc, <br>                                                        (LPARAM) ulCallbackData); <br>            ShowWindow(pProgressParam-&gt;hDialog, SW_SHOWNORMAL); <br>            UpdateWindow(pProgressParam-&gt;hDialog); <br>            SendDlgItemMessage(pProgressParam-&gt;hDialog, IDC_PROGRESS, PBM_SETRANGE, 0, MAKELONG(0, ulMax)); <br>            SendDlgItemMessage(pProgressParam-&gt;hDialog, IDC_PROGRESS, PBM_SETPOS, ulCurrent, 0); <br>        } <br>    } <br>    else <br>    { <br>        // Update dialog's progress bar. <br>        SendDlgItemMessage(pProgressParam-&gt;hDialog, IDC_PROGRESS, PBM_SETPOS, ulCurrent, 0); <br>    } <br> <br>    return !pProgressParam-&gt;bCancel; <br>} <br> <br> <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  TransformProgressProc <br>// <br>//  Description: <br>// <br>// <br>//  Parameters: <br>//    @@@ <br>// <br>//  Returns: <br>//    BOOL <br>// <br>//  Comments: <br>// <br>// <br>////////////////////////////////////////////////////////////////////////// <br>BOOL CALLBACK TransformProgressProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam) <br>{ <br> <br>    switch (uMsg) <br>    { <br>        case WM_INITDIALOG: <br>            ASSERT(lParam != 0); <br>            SetWindowLong(hDlg, GWL_USERDATA, lParam); <br>            return TRUE; <br> <br>        case WM_COMMAND: <br>            switch (LOWORD(wParam)) <br>            { <br>                case IDCANCEL: <br>                    { <br>                        PPROGRESSPARAM  pProgressParam = (PPROGRESSPARAM) GetWindowLong(hDlg, GWL_USERDATA); <br> <br>                        pProgressParam-&gt;bCancel = TRUE; <br>                    } <br>                    break; <br>            } <br>            break; <br>    } <br> <br>    return FALSE; <br>} <br> <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  SizeScrollBars <br>// <br>//  Description: <br>// <br>// <br>//  Parameters: <br>//    @@@ <br>// <br>//  Returns: <br>//    BOOL <br>// <br>//  Comments: <br>// <br>// <br>////////////////////////////////////////////////////////////////////////// <br>void SizeScrollBars(HWND hWnd, LPDIBINFO lpDIBInfo, UINT uiWindowHeight, UINT uiWindowWidth) <br>{ <br>    static BOOL    bAdjusting = FALSE; <br> <br> <br>    // Only size for validte windows and dib info. <br>    // Don't SizeScrollBars if in process of adjusting them. <br>    if ( IsWindow(hWnd) <br>         &amp;&amp; <br>         (NULL != lpDIBInfo) <br>         &amp;&amp; <br>         !bAdjusting <br>       ) <br>    { <br>        int         nScrollHeight = GetSystemMetrics (SM_CXVSCROLL); <br>        int         nScrollWidth = GetSystemMetrics (SM_CYHSCROLL); <br>        SCROLLINFO  VertScrollInfo; <br>        SCROLLINFO  HorzScrollInfo; <br> <br>        // Make sure that we don't get into an infinite loop when updating scroll bars. <br>        bAdjusting = TRUE; <br> <br>        // Get current vertical scroll info. <br>        VertScrollInfo.cbSize = sizeof(SCROLLINFO); <br>        VertScrollInfo.fMask = SIF_ALL; <br>        GetScrollInfo(hWnd, SB_VERT, &amp;VertScrollInfo); <br> <br>        // Get current horizontal scroll info. <br>        HorzScrollInfo.cbSize = sizeof(SCROLLINFO); <br>        HorzScrollInfo.fMask = SIF_ALL; <br>        GetScrollInfo(hWnd, SB_HORZ, &amp;HorzScrollInfo); <br> <br>        // Only adjust if not stretching to fit. <br>        // Turn off scroll bars if stretching to fit. <br>        if (!lpDIBInfo-&gt;bStretch) <br>        { <br>            // Adjust window width and height to account for current scroll bars. <br>            if ((int) VertScrollInfo.nPage &lt;= VertScrollInfo.nMax) <br>            { <br>                // INVARIANT:  Vertical scroll bar exists. <br> <br>                // modify width to account for scroll bars width. <br>                uiWindowWidth += nScrollWidth; <br>            } <br>            if ((int) HorzScrollInfo.nPage &lt;= HorzScrollInfo.nMax) <br>            { <br>                // INVARIANT:   Horizantal scroll bar exists. <br> <br>                // Modify height to account for scroll bars height. <br>                uiWindowHeight += nScrollHeight; <br>            } <br> <br>            // Adjust width and height based on what will happen. <br>            if ((int) uiWindowHeight &lt; VertScrollInfo.nMax) <br>            { <br>                uiWindowWidth -= nScrollWidth; <br>                if ((int) uiWindowWidth &lt; HorzScrollInfo.nMax) <br>                { <br>                    uiWindowHeight -= nScrollHeight; <br>                } <br>            } <br>            else if ((int) uiWindowWidth &lt; HorzScrollInfo.nMax) <br>            { <br>                uiWindowHeight -= nScrollHeight; <br>                if ((int) uiWindowHeight &lt; VertScrollInfo.nMax) <br>                { <br>                    uiWindowWidth -= nScrollWidth; <br>                } <br>            } <br> <br>            // If width or height equals bitmap, need to make it larger <br>            // so that scroll bars will not appear. <br>            if ((int) uiWindowWidth == HorzScrollInfo.nMax) <br>            { <br>                ++uiWindowWidth; <br>            } <br>            if ((int) uiWindowHeight == VertScrollInfo.nMax) <br>            { <br>                ++uiWindowHeight; <br>            } <br>        } <br>        else <br>        { <br>            uiWindowHeight = VertScrollInfo.nMax + 1; <br>            uiWindowWidth = HorzScrollInfo.nMax + 1; <br>        } <br> <br>        // Update vertical scroll info. <br>        VertScrollInfo.fMask = SIF_PAGE; <br>        VertScrollInfo.nPage = uiWindowHeight; <br>        SetScrollInfo(hWnd, SB_VERT, &amp;VertScrollInfo, FALSE); <br> <br>        // Update horizontal scroll info. <br>        HorzScrollInfo.fMask = SIF_PAGE; <br>        HorzScrollInfo.nPage = uiWindowWidth; <br>        SetScrollInfo(hWnd, SB_HORZ, &amp;HorzScrollInfo, FALSE); <br> <br>        bAdjusting = FALSE; <br>    } <br>} <br> <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  InitializeScrollBars <br>// <br>//  Description: <br>// <br>// <br>//  Parameters: <br>//    @@@ <br>// <br>//  Returns: <br>//    BOOL <br>// <br>//  Comments: <br>// <br>// <br>////////////////////////////////////////////////////////////////////////// <br>void InitializeScrollBars(HWND hWnd, LPDIBINFO lpDIBInfo) <br>{ <br>    RECT        rClient; <br>    SCROLLINFO  ScrollInfo; <br> <br> <br>    // Get windows client size. <br>    GetClientRect(hWnd, &amp;rClient); <br> <br>    // If client size is equel to dib size, then add one to client size <br>    // so that we don't show scroll bars. <br>    // However, if client size is less than dib size, subtract scroll bar <br>    // size form client size so that page size will be correct when <br>    // scroll bars are shown. <br>    if ((UINT) rClient.bottom == lpDIBInfo-&gt;uiDIBHeight) <br>        ++rClient.bottom; <br>    else if ((UINT) rClient.bottom &lt; lpDIBInfo-&gt;uiDIBHeight) <br>        rClient.bottom -= GetSystemMetrics (SM_CYHSCROLL); <br>    if ((UINT) rClient.right == lpDIBInfo-&gt;uiDIBWidth) <br>        ++rClient.right; <br>    else if ((UINT) rClient.right &lt; lpDIBInfo-&gt;uiDIBWidth) <br>        rClient.right -= GetSystemMetrics (SM_CXVSCROLL); <br> <br>    // Initialize vertical scroll bar. <br>    ScrollInfo.cbSize = sizeof(SCROLLINFO); <br>    ScrollInfo.fMask = SIF_ALL; <br>    ScrollInfo.nMin = 0; <br>    ScrollInfo.nMax = lpDIBInfo-&gt;uiDIBHeight; <br>    ScrollInfo.nPage = rClient.bottom; <br>    ScrollInfo.nPos = 0; <br>    SetScrollInfo(hWnd, SB_VERT, &amp;ScrollInfo, TRUE); <br> <br>    // Initialize vertical scroll bar. <br>    ScrollInfo.nMax = lpDIBInfo-&gt;uiDIBWidth; <br>    ScrollInfo.nPage = rClient.right; <br>    SetScrollInfo(hWnd, SB_HORZ, &amp;ScrollInfo, TRUE); <br>} <br> <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  ScrollChildWindow <br>// <br>//  Description: <br>// <br>// <br>//  Parameters: <br>//    @@@ <br>// <br>//  Returns: <br>//    BOOL <br>// <br>//  Comments: <br>// <br>// <br>////////////////////////////////////////////////////////////////////////// <br>BOOL ScrollChildWindow(HWND hWnd, int nScrollBar, WORD wScrollCode) <br>{ <br>    int         nPosition; <br>    int         nHorzScroll = 0; <br>    int         nVertScroll = 0; <br>    SCROLLINFO  ScrollInfo; <br> <br> <br>    // Get current scroll information. </code></pre>
<p>
</p>
<pre><code>ScrollInfo.cbSize = sizeof(SCROLLINFO); <br>    ScrollInfo.fMask = SIF_ALL; <br>    GetScrollInfo(hWnd, nScrollBar, &amp;ScrollInfo); <br>    nPosition = ScrollInfo.nPos; <br> <br>    // Modify scroll information based on requested <br>    // scroll action. <br>    switch (wScrollCode) <br>    { <br>        case SB_LINEDOWN: <br>            ScrollInfo.nPos++; <br>            break; <br> <br>        case SB_LINEUP: <br>            ScrollInfo.nPos--; <br>            break; <br> <br>        case SB_PAGEDOWN: <br>            ScrollInfo.nPos += ScrollInfo.nPage; <br>            break; <br> <br>        case SB_PAGEUP: <br>            ScrollInfo.nPos -= ScrollInfo.nPage; <br>            break; <br> <br>        case SB_TOP: <br>            ScrollInfo.nPos = ScrollInfo.nMin; <br>            break; <br> <br>        case SB_BOTTOM: <br>            ScrollInfo.nPos = ScrollInfo.nMax; <br>            break; <br> <br>            // Don't do anything. <br>        case SB_THUMBPOSITION: <br>        case SB_THUMBTRACK: <br>            ScrollInfo.nPos = ScrollInfo.nTrackPos; <br>            break; <br> <br>        case SB_ENDSCROLL: <br>            default: <br>            return FALSE; <br>    } <br> <br>    // Make sure that scroll position is in range. <br>    if (0 &gt; ScrollInfo.nPos) <br>        ScrollInfo.nPos = 0; <br>    else if (ScrollInfo.nMax - (int) ScrollInfo.nPage + 1 &lt; ScrollInfo.nPos) <br>        ScrollInfo.nPos = ScrollInfo.nMax  - ScrollInfo.nPage + 1; <br> <br>    // Set new scroll position. <br>    ScrollInfo.fMask = SIF_POS; <br>    SetScrollInfo(hWnd, nScrollBar, &amp;ScrollInfo, TRUE); <br> <br>    // Scroll window. <br>    if (SB_VERT == nScrollBar) <br>        nVertScroll = nPosition - ScrollInfo.nPos; <br>    else <br>        nHorzScroll = nPosition - ScrollInfo.nPos; <br> <br>    ScrollWindowEx(hWnd, nHorzScroll, nVertScroll, NULL, NULL, <br>                   NULL, NULL, SW_INVALIDATE); <br> <br>    return TRUE; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
