<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DIBS.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3505"></a>DIBS.C</h2>
<pre><code>//THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>//ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>//THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>// PARTICULAR PURPOSE. <br>// <br>// Copyright  1994-1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//  FILE: <br>//    DIBS.C <br>// <br>//  PURPOSE: <br>//    DIB routines for the ICMVIEW application. <br>// <br>//  PLATFORMS: <br>//    Windows 95, Windows NT <br>// <br>//  SPECIAL INSTRUCTIONS: N/A <br>// <br> <br>// Windows Header Files: <br>#pragma warning(disable:4001)   // Single-line comment warnings <br>#pragma warning(disable:4115)   // Named type definition in parentheses <br>#pragma warning(disable:4201)   // Nameless struct/union warning <br>#pragma warning(disable:4214)   // Bit field types other than int warnings <br>#pragma warning(disable:4514)   // Unreferenced inline function has been removed <br> <br>// Windows Header Files: <br>#include &lt;Windows.h&gt; <br>#include &lt;WindowsX.h&gt; <br>//#include &lt;CommCtrl.h&gt; <br>#include &lt;icm.h&gt; <br> <br>// Restore the warnings--leave the single-line comment warning OFF <br>#pragma warning(default:4115)   // Named type definition in parentheses <br>#pragma warning(default:4201)   // Nameless struct/union warning <br>#pragma warning(default:4214)   // Bit field types other than int warnings <br>#pragma warning(default:4514)   // Unreferenced inline function has been removed <br> <br>// C RunTime Header Files <br>#include &lt;string.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;TCHAR.H&gt; <br> <br>// Local Header Files <br>#include "icmview.h"  // specific to this program <br>#include "child.h" <br>#include "dibinfo.h" <br>#include "dibs.h"      // specific to this file <br>#include "dialogs.h" <br>#include "debug.h" <br>#include "print.h" <br>#include "regutil.h" <br>#include "resource.h" <br> <br>// local definitions <br>DWORD NumColorsInDIB(LPBITMAPINFOHEADER lpbi); <br>LONG      DIBHeight (LPBYTE lpDIB); <br>LONG      DIBWidth (LPBYTE lpDIB); <br>LPLOGCOLORSPACE GetColorSpaceFromBitmap(LPBITMAPINFOHEADER lpBitmapInfo, DWORD dwIntent, LPBOOL pbDeleteProfile); <br>HPROFILE  OpenColorProfileFromFile(LPTSTR lpszProfileName); <br>BOOL TranslateColorTable(HTRANSFORM hColorTransform, PCOLOR paInputColors, DWORD nColors, COLORTYPE ctInput, PCOLOR paOutputColors, COLORTYPE ctOutput, int biBitCount); <br> <br>// default settings <br> <br>// external functions <br> <br>// external data <br> <br>// public data <br> <br>// private data <br> <br>// public functions <br> <br>// private functions <br> <br> <br>/////////////////////////////////////////////////////////////////////// <br>// <br>// Function:   DIBPaint <br>// <br>// Purpose:    Painting routine for a DIB.  Calls StretchDIBits() or <br>//             SetDIBitsToDevice() to paint the DIB.  The DIB is <br>//             output to the specified DC, at the coordinates given <br>//             in lpDCRect.  The area of the DIB to be output is <br>//             given by lpDIBRect.  The specified palette is used. <br>// <br>// Parms:      hDC       == DC to do output to. <br>//             lpDCRect  == Rectangle on DC to do output to. <br>//             hDIB      == Handle to global memory with a DIB spec <br>//                          in it (either a BITMAPINFO or BITMAPCOREINFO <br>//                          followed by the DIB bits). <br>//             lpDIBRect == Rect of DIB to output into lpDCRect. <br>//             hPal      == Palette to be used. <br>// <br>/////////////////////////////////////////////////////////////////////// <br> <br>void DIBPaint (HDC hDC, LPRECT lpDCRect, HGLOBAL hDIB,LPRECT lpDIBRect, <br>               LPDIBINFO lpDIBInfo) <br>{ <br>    int                 iScanLines; <br>    HDC                 hDCPrinter; <br>    BOOL                bRC; <br>    LPBYTE              lpbDIBBits; <br>    HPALETTE            hOldPal; <br>    LPBITMAPINFOHEADER  lpDIBHdr; <br>    LPBITMAPINFOHEADER  lpbi; <br> <br> <br>    // Initialize variables <br>    if (!hDIB) <br>    { <br>        return; <br>    } <br>    ASSERT(hDC != NULL); <br>    hDCPrinter = NULL; <br>    SetLastError(0); <br>    hOldPal = NULL; <br>    lpbi = NULL; <br> <br>    // Lock down DIB, get a pointer to the beginning of the bit buffer. <br>    lpDIBHdr  = GlobalLock(hDIB); <br>    if (NULL == lpDIBHdr ) <br>    { <br>        goto Release; <br>    } <br>    lpbDIBBits = FindDIBBits(lpDIBHdr); <br>    if (NULL == lpbDIBBits) <br>    { <br>        goto Release; <br>    } <br> <br>    // If size &gt; BITMAPINFOHEADER header then <br>    // need to convert to BITMAPINFOHEADER. <br>    lpbi = lpDIBHdr; <br>#ifdef OSR2 <br>    if (sizeof(BITMAPINFOHEADER) &lt; lpDIBHdr-&gt;biSize) <br>    { <br>        DWORD dwColorTableSize; <br>        DWORD dwHeaderDataSize; <br> <br>        // Allocate Bitmapinfo memory. <br>        dwHeaderDataSize = sizeof(BITMAPINFOHEADER) + (lpDIBHdr-&gt;biCompression == BI_BITFIELDS ? 12 : 0); <br>        dwColorTableSize = NumColorsInDIB(lpDIBHdr) * sizeof(RGBQUAD); <br>        lpbi = (LPBITMAPINFOHEADER) GlobalAlloc(GPTR, dwHeaderDataSize + dwColorTableSize); <br>        if (NULL == lpbi) <br>        { <br>            goto Release; <br>        } <br> <br>        // Convert header data into bitmapinfo header. <br>        memcpy(lpbi, lpDIBHdr, dwHeaderDataSize); <br>        lpbi-&gt;biSize = sizeof(BITMAPINFOHEADER); <br> <br>        // Copy color table if any. <br>        if (0 != dwColorTableSize) <br>            memcpy((LPBYTE)lpbi + dwHeaderDataSize, (LPBYTE)lpDIBHdr + lpDIBHdr-&gt;biSize, dwColorTableSize); <br>    } <br>#endif <br> <br>    SetupDC(hDC, lpDIBInfo, &amp;hOldPal, &amp;hDCPrinter); <br> <br>    // Determine whether to call StretchDIBits() or SetDIBitsToDevice(). <br>    if (!(lpDIBInfo-&gt;bStretch)) <br>    { <br>        iScanLines = SetDIBitsToDevice (hDC,          // hDC <br>                                        lpDCRect-&gt;left,               // dest upper-left x <br>                                        lpDCRect-&gt;top,                // dest upper-left y <br>                                        RECTWIDTH (lpDCRect),         // src width <br>                                        RECTHEIGHT (lpDCRect),        // src height <br>                                        lpDIBRect-&gt;left,              // src lower-left x <br>                                        (int) DIBHeight((LPBYTE)lpDIBHdr) - <br>                                        lpDIBRect-&gt;top - <br>                                        RECTHEIGHT (lpDIBRect),       // src lower-left y <br>                                        0,                            // nStartScan <br>                                        (UINT) DIBHeight((LPBYTE)lpDIBHdr),   // nNumScans <br>                                        lpbDIBBits,                   // lpBits <br>                                        (LPBITMAPINFO) lpbi,      // lpBitsInfo <br>                                        DIB_RGB_COLORS);              // wUsage <br>    } <br>    else <br>    { <br>        // Use the specified stretch mode <br>        SetStretchBltMode (hDC, (int)lpDIBInfo-&gt;dwStretchBltMode); <br>        iScanLines = StretchDIBits (hDC,                          // hDC <br>                                    lpDCRect-&gt;left,               // dest upper-left x <br>                                    lpDCRect-&gt;top,                // dest upper-left y <br>                                    RECTWIDTH (lpDCRect),         // src width <br>                                    RECTHEIGHT (lpDCRect),        // src height <br>                                    lpDIBRect-&gt;left,              // src lower-left x <br>                                    lpDIBRect-&gt;top,               // src lower-left y <br>                                    RECTWIDTH (lpDIBRect),        // nStartScan <br>                                    RECTHEIGHT (lpDIBRect),       // nNumScans <br>                                    lpbDIBBits,                   // lpBits <br>                                    (LPBITMAPINFO)lpbi,                   // lpBitsInfo <br>                                    DIB_RGB_COLORS,               // wUsage <br>                                    SRCCOPY);                     // dwROP <br>    } <br>    if (DIBHeight((LPBYTE)lpDIBHdr) != iScanLines) <br>    { <br>        DebugMsg(__TEXT("DIBS.C : DIBPaint:  iScanLines expected %ld, returned %ld\r\n"), DIBHeight((LPBYTE)lpDIBHdr), iScanLines); <br>    } <br> <br>    // Fix up the palette. <br>    if (NULL == SelectPalette (hDC, hOldPal, TRUE)) <br>    { <br>        DISPLAY_LASTERROR(LASTERROR_NOALLOC, GetLastError()); <br>    } <br> <br> <br>    Release: <br>    if (lpbi != lpDIBHdr) <br>        GlobalFree((HANDLE)lpbi); <br>    if (NULL != lpDIBHdr) <br>    { <br>        GlobalUnlock(hDIB); <br>    } <br>    if (hDCPrinter) <br>    { <br>        bRC = ColorMatchToTarget(hDC, hDCPrinter, CS_DISABLE); <br>        if (0 == bRC) <br>        { <br>            DebugMsg(__TEXT("DIBS.C : DIBPaint : ColorMatchToTarget failed to DISABLE transform.\r\n")); <br>            DISPLAY_LASTERROR(LASTERROR_NOALLOC,GetLastError()); <br>        } <br>        bRC = ColorMatchToTarget(hDC, hDCPrinter, CS_DELETE_TRANSFORM); <br>        if (0 == bRC) <br>        { <br>            DebugMsg(  __TEXT(  "DIBS.C : DIBPaint : ColorMatchToTarget failed to DELETE transform.\r\n")); <br>            DISPLAY_LASTERROR(LASTERROR_NOALLOC,GetLastError()); <br>        } <br>        bRC = DeleteDC(hDCPrinter); <br>        if (0 == bRC) <br>        { <br>            DebugMsg(__TEXT("DIBS.C : DIBPaint : Failed to delete printer DC\r\n")); <br>            DISPLAY_LASTERROR(LASTERROR_NOALLOC,GetLastError()); <br>        } <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////// <br>// <br>// Function:   CreateDIBPalette <br>// <br>// Purpose:    Given a handle to a DIB, constructs a logical palette, <br>//             and returns a handle to this palette. <br>// <br>//             Stolen almost verbatim from ShowDIB. <br>// <br>// Parms:      hDIB == HANDLE to global memory with a DIB header <br>//                     (either BITMAPINFOHEADER or BITMAPCOREHEADER) <br>// <br>/////////////////////////////////////////////////////////////////////// <br>HPALETTE CreateDIBPalette(HANDLE hDIB) <br>{ <br>    LPLOGPALETTE          lpPal; <br>    HGLOBAL               hLogPal; <br>    HPALETTE              hPal = NULL; <br>    UINT                  i; <br>    DWORD                 dwNumColors; <br>    LPBITMAPINFOHEADER    lpBmpInfoHdr; <br>    LPBITMAPINFO          lpbmi; <br>    LPBITMAPCOREINFO      lpbmc; <br>    BOOL                  bWinStyleDIB; <br> <br>    if (!hDIB) <br>    { <br>        return NULL; <br>    } <br> <br>    lpBmpInfoHdr = GlobalLock (hDIB); <br>    lpbmi        = (LPBITMAPINFO)lpBmpInfoHdr; <br>    lpbmc        = (LPBITMAPCOREINFO)lpBmpInfoHdr; <br>    dwNumColors  = NumColorsInDIB(lpBmpInfoHdr); <br>    bWinStyleDIB = IS_WIN30_DIB(lpBmpInfoHdr); <br> <br>    if (0 != dwNumColors) <br>    { <br>        hLogPal = GlobalAlloc (GHND, sizeof (LOGPALETTE) + sizeof (PALETTEENTRY) * dwNumColors); <br>        if (!hLogPal) <br>        { <br>            GlobalUnlock(hDIB); <br>            return NULL; <br>        } <br> <br>        lpPal = (LPLOGPALETTE) GlobalLock (hLogPal); <br>        lpPal-&gt;palVersion    = PALVERSION; <br>        lpPal-&gt;palNumEntries = (WORD)dwNumColors; <br> <br>        for (i = 0;  i &lt; dwNumColors;  i++) <br>        { <br>            if (bWinStyleDIB) <br>            { <br>                lpPal-&gt;palPalEntry[i].peRed   = lpbmi-&gt;bmiColors[i].rgbRed; <br>                lpPal-&gt;palPalEntry[i].peGreen = lpbmi-&gt;bmiColors[i].rgbGreen; <br>                lpPal-&gt;palPalEntry[i].peBlue  = lpbmi-&gt;bmiColors[i].rgbBlue; <br>                lpPal-&gt;palPalEntry[i].peFlags = 0; <br>            } <br>            else <br>            { <br>                lpPal-&gt;palPalEntry[i].peRed   = lpbmc-&gt;bmciColors[i].rgbtRed; <br>                lpPal-&gt;palPalEntry[i].peGreen = lpbmc-&gt;bmciColors[i].rgbtGreen; <br>                lpPal-&gt;palPalEntry[i].peBlue  = lpbmc-&gt;bmciColors[i].rgbtBlue; <br>                lpPal-&gt;palPalEntry[i].peFlags = 0; <br>            } <br>        } <br> <br>        hPal = CreatePalette (lpPal); <br>        GlobalUnlock(hLogPal); <br>        GlobalFree(hLogPal); <br>    } <br>    GlobalUnlock(hDIB); <br>    return(hPal); <br>} <br> <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  GetDefaultICMProfile <br>// <br>//  Description: <br>//    Uses GetICMProfile to retrieve the filename of the default ICM <br>//    profile for the DC. <br>// <br>//  Parameters: <br>//    @@@ <br>// <br>//  Returns: <br>//    LPTSTR <br>// <br>//  Comments: <br>// <br>// <br>////////////////////////////////////////////////////////////////////////// <br>LPTSTR GetDefaultICMProfile(HDC hDC) <br>{ <br>    // Local variables <br>    LPTSTR    lpszProfileName; <br>    BOOL      bProfile; <br>    DWORD     dwProfileLen; <br>    TCHAR     stProfileName[MAX_PATH+1]; <br>    HGLOBAL   hFree; <br> <br>    //  Initialize variables <br>    lpszProfileName = NULL; <br>    dwProfileLen = 0; <br>    stProfileName[0] = __TEXT('\0'); <br> <br>    // Query for size of profile name string <br>    bProfile = GetICMProfile(hDC, &amp;dwProfileLen, NULL); <br>    if (bProfile) <br>    { <br>        DebugMsg(__TEXT("GetDefaultICMProfile:  GetICMProfile returned TRUE on query, dwProfileLen = %ld\r\n"), dwProfileLen); <br>        return(FALSE); <br>    } <br> <br>    if (ERROR_INSUFFICIENT_BUFFER != GetLastError()) <br>    { <br>        DebugMsg(__TEXT("GetDefaultICMProfile:  GetICMProfile set unexpected LastError %ld on query, dwProfileLen = %ld\r\n"), <br>                 GetLastError(), dwProfileLen); <br>        DISPLAY_LASTERROR(LASTERROR_NOALLOC, GetLastError()); <br>        dwProfileLen = MAX_PATH; <br>    } <br>    else <br>    { <br>        if (0 == dwProfileLen) <br>        { <br>            DebugMsg(__TEXT("GetDefaultICMProfile:  GetICMProfile returned FALSE on query, DID NOT SET dwProfileLen\r\n")); <br>            return(FALSE); <br>        } <br>    } <br> <br> <br>    // Fill in lpszProfileName with actual profile filename <br>    lpszProfileName = GlobalAlloc(GPTR, (dwProfileLen+1) * sizeof(TCHAR)); <br>    if (lpszProfileName != NULL) <br>    { <br>        bProfile = GetICMProfile(hDC, &amp;dwProfileLen, lpszProfileName); <br>        if (!bProfile) <br>        { <br>            DebugMsg(__TEXT("GetDefaultICMProfile:  GetICMProfile FAILED\r\n")); <br>            DISPLAY_LASTERROR(LASTERROR_NOALLOC, GetLastError()); <br>            hFree = GlobalFree(lpszProfileName); <br>            return(NULL); <br>        } <br>        else  // Successfully id'd default profile <br>        { <br>            TCHAR   szName[MAX_PATH], szExt[MAX_PATH]; <br> <br>            DebugMsg(__TEXT("Full profile name:  &lt;%s&gt;\r\n"), lpszProfileName); <br>            _tsplitpath(lpszProfileName, NULL, NULL, szName, szExt); <br>            wsprintf(lpszProfileName, __TEXT("%s%s"), szName, szExt); <br>        } <br>    } <br>    else <br>    { <br>        DebugMsg(__TEXT("GetDefaultICMProfile:  Unable to allocate lpszProfileName.\r\n")); <br>    } <br>    return(lpszProfileName); <br>} // End of function GetDefaultICMProfile <br> <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  TransformDIBOutsideDC <br>// <br>//  Description: <br>//    Transforms the provided hDIB using the provided profile names. <br>// <br>//  Parameters: <br>//    HANDLE      Handle to DIB to process <br>//    LPTSTR      Destination profile <br>//    LPTSTR      Target profile <br>// <br>//  Returns: <br>//    HANDLE to transformed bits; NULL upon failure. <br>// <br>//  Comments: <br>//    Uses ICM functions <br>//        CreateColorTransform <br>//        TranslateBitmapBits <br>//        TranslateColors <br>// <br>////////////////////////////////////////////////////////////////////////// <br>HANDLE TransformDIBOutsideDC(HANDLE hDIB, BMFORMAT bmInput, LPTSTR lpszDestProfile, <br>                             LPTSTR lpszTargetProfile, DWORD dwIntent, PBMCALLBACKFN pBMCallback, <br>                             ULONG ulCallbackData) <br>{ <br>    // Local variables <br>    HANDLE          hDIBTransformed;    // Handle to transformed DIB <br>    HPROFILE        hDestProfile, hTargetProfile; <br>    HTRANSFORM      hTransform; <br>    LPLOGCOLORSPACE lpLogColorSpace; <br>    PVOID           pSrcBits, pDestBits; <br>    LPBITMAPINFOHEADER  lpbSrcDIBHdr, lpbDestDIBHdr; <br>    BOOL            bTranslated, bProfileClosed, bDeleted, bDeleteProfile; <br>    DWORD           dwCopySize; <br> <br>    //  Initialize variables <br>    ASSERT(NULL != hDIB); <br>    ASSERT(NULL != lpszDestProfile); <br>    hDIBTransformed = NULL; <br>    SetLastError(0); <br>    hTransform = NULL; <br>    bTranslated = FALSE; <br> <br>    hDestProfile   = OpenColorProfileFromFile(lpszDestProfile ); <br>    hTargetProfile = OpenColorProfileFromFile(lpszTargetProfile); <br> <br>    if (NULL == hDestProfile) <br>    { <br>        DebugMsg(__TEXT("TransformDIBOutsideDC : NULL dest file\r\n")); <br>        return(NULL); <br>    } <br> <br>    // Get bits from original DIB <br>    lpbSrcDIBHdr = GlobalLock(hDIB); <br> <br>    pSrcBits = (PVOID)FindDIBBits(lpbSrcDIBHdr); <br> <br>    // Get LPLOGCOLORSPACE for transform <br>    lpLogColorSpace = GetColorSpaceFromBitmap(lpbSrcDIBHdr, dwIntent, &amp;bDeleteProfile); <br> <br>    if (NULL != lpLogColorSpace) <br>    { <br>        //Create the transform to use <br>        SetLastError(0); <br>        hTransform = CreateColorTransform(lpLogColorSpace, hDestProfile, hTargetProfile, ENABLE_GAMUT_CHECKING | NORMAL_MODE | 0x80000000); <br> <br>        if (NULL != hTransform) <br>        { <br>            // Allocate for new DIB <br>            hDIBTransformed = GlobalAlloc(GHND, GlobalSize(hDIB)); <br>            lpbDestDIBHdr = GlobalLock(hDIBTransformed); <br> <br>            switch (BITCOUNT(lpbSrcDIBHdr)) <br>            { <br>                DWORD   dwSrcOffBytes, dwDestOffBytes; <br> <br>                case 1: // BM_1GRAY: <br>                case 4: <br>                case 8: <br>                    ASSERT((((LPBITMAPV5HEADER)lpbSrcDIBHdr)-&gt;bV5ClrUsed) &lt;= (DWORD)( 1 &lt;&lt; ((LPBITMAPV5HEADER)lpbSrcDIBHdr)-&gt;bV5BitCount)); <br>                    // Copy entire DIB.  Color table will be replaced by TranslateColors <br>                    dwCopySize = GlobalSize(hDIB); <br>                    memset(lpbDestDIBHdr, 0x17, dwCopySize); <br>                    memcpy(lpbDestDIBHdr, lpbSrcDIBHdr, dwCopySize); <br> <br>                    dwSrcOffBytes = *(LPDWORD)lpbSrcDIBHdr; <br>                    dwDestOffBytes   = *(LPDWORD)lpbDestDIBHdr; <br> <br>                    pSrcBits  = (PBYTE)lpbSrcDIBHdr  + dwSrcOffBytes; <br>                    pDestBits = (PBYTE)lpbDestDIBHdr + dwDestOffBytes; <br> <br>                    // Needed to use different translation if BITMAPCORE bitmap. <br>                    if (dwSrcOffBytes &gt;= sizeof(BITMAPINFOHEADER)) <br>                    { <br>                        bTranslated = TranslateColorTable(hTransform, <br>                                                          (PCOLOR)pSrcBits, // paInputColors, <br>                                                          ((LPBITMAPV5HEADER)lpbSrcDIBHdr)-&gt;bV5ClrUsed, // nColors, <br>                                                          COLOR_RGB, // ctInput, <br>                                                          (PCOLOR)pDestBits, // paOutputColors, <br>                                                          COLOR_RGB,  // ctOutput) <br>                                                          lpbSrcDIBHdr-&gt;biBitCount); <br>                    } <br>                    else <br>                    { <br>                        bTranslated = TranslateBitmapBits(hTransform, <br>                                                          pSrcBits, <br>                                                          BM_RGBTRIPLETS, <br>                                                          NumColorsInDIB(lpbSrcDIBHdr), <br>                                                          1, <br>                                                          0, <br>                                                          pDestBits, <br>                                                          BM_RGBTRIPLETS, <br>                                                          0, <br>                                                          NULL, <br>                                                          0); <br>                    } <br> <br>                    if (0 == bTranslated) <br>                    { <br>                        DebugMsg(__TEXT("TransformDIBOutsideDC : TranslateColors failed, :")); <br>                        DISPLAY_LASTERROR(LASTERROR_NOALLOC, GetLastError()); <br>                    } <br>                    break; <br> <br>                case 16: // BM_RGBTRIPLETS: <br>                case 24: // BM_xRGBQUADS: <br>                case 32: // BM_x555RGB: <br> <br>                    // Copy header from original DIB to new DIB <br>                    memcpy(lpbDestDIBHdr, lpbSrcDIBHdr, sizeof(BITMAPV5HEADER)); <br>                    pDestBits = (PVOID)FindDIBBits(lpbDestDIBHdr); <br> <br>                    bTranslated = TranslateBitmapBits(hTransform, <br>                                                      pSrcBits, <br>                                                      bmInput, <br>                                                      BITMAPWIDTH(lpbSrcDIBHdr), <br>                                                      abs(BITMAPHEIGHT(lpbSrcDIBHdr)), <br>                                                      0, <br>                                                      pDestBits, <br>                                                      bmInput, <br>                                                      0, <br>                                                      pBMCallback, <br>                                                      ulCallbackData); <br> <br>                    if (0 == bTranslated) <br>                    { <br>                        DebugMsg(__TEXT("TransformDIBOutsideDC : TranslateBitmapBits failed:\r\n")); <br>                        DISPLAY_LASTERROR(LASTERROR_NOALLOC, GetLastError()); <br>                    } <br>                    break; <br> <br>                default:  // 8bpp <br>                    DebugMsg(__TEXT("TransformDIBOutsideDC : Unrecognized format\r\n")); <br>                    bTranslated = FALSE; <br>                    break; <br>            } <br>            bDeleted = DeleteColorTransform(hTransform); <br>            if (0 == bDeleted) <br>            { <br>                DebugMsg(__TEXT("TransformDIBOutsideDC : DeleteColorTransform failed, : ")); <br>                DISPLAY_LASTERROR(LASTERROR_NOALLOC, GetLastError()); <br>            } <br>        } <br>        else <br>        { <br>            ErrMsg(NULL, __TEXT("TransformDIBOutsideDC : CreateColorTransform failed")); <br>            DISPLAY_LASTERROR(LASTERROR_NOALLOC, GetLastError()); <br>        } <br> <br>        if (bDeleteProfile) <br>        { <br>            DeleteFile(lpLogColorSpace-&gt;lcsFilename); <br>        } <br> <br>        GlobalFree((HANDLE)lpLogColorSpace); <br>    } <br>    else // Failed to get LOGCOLORSPACE <br>    { <br>        ErrMsg(NULL, __TEXT("TransformDIBOutsideDC : Failed to get LOGCOLORSPACE")); <br>    } <br> <br>    if (NULL != hDestProfile) <br>    { <br>        bProfileClosed = CloseColorProfile(hDestProfile); <br>        if (0 == bProfileClosed) <br>        { <br>            DebugMsg(__TEXT("TransformDIBOutsideDC : Failed to close hDestProfile, ")); <br>            DISPLAY_LASTERROR(LASTERROR_NOALLOC, GetLastError()); <br>        } <br>    } <br> <br>    if (NULL != hTargetProfile) <br>    { <br>        bProfileClosed = CloseColorProfile(hTargetProfile); <br>        if (0 == bProfileClosed) <br>        { <br>            DebugMsg(__TEXT("TransformDIBOutsideDC : Failed to close hTargetProfile, ")); <br>            DISPLAY_LASTERROR(LASTERROR_NOALLOC, GetLastError()); <br>        } <br>    } <br>    if (NULL != hDIBTransformed) <br>    { <br>        GlobalUnlock(hDIBTransformed); <br>    } <br>    if ((NULL == hTransform) || (0 == bTranslated)) <br>    { <br>        if (NULL != hDIBTransformed) <br>        { <br>            GlobalFree(hDIBTransformed); <br>            hDIBTransformed = NULL; <br>        } <br>        lpbDestDIBHdr = NULL; <br>        pDestBits = NULL; <br>    } <br>    return(hDIBTransformed); <br>}   // End of function TransformDIBOutsideDC <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  OpenColorProfileFromFile <br>// <br>//  Description: <br>//    Creates a color profile based upon the parameters passed. <br>// <br>//  Parameters: <br>//    LPTSTR  Profile name <br>// <br>//  Returns: <br>//    HPROFILE Handle to PROFILE structure, NULL if failure. <br>// <br>//  Comments: <br>// <br>// <br>////////////////////////////////////////////////////////////////////////// <br>HPROFILE OpenColorProfileFromFile(LPTSTR lpszProfileName) <br>{ <br>    // Local variables <br>    PPROFILE  pProfile; <br>    HPROFILE  hProfile; <br>    DWORD     cbDataSize; <br>    DWORD     dwProfileSize; <br>    TCHAR     stFullProfile[MAX_PATH]; <br>    BOOL      bValid; <br> <br>    //  Initialize variables <br>    if (NULL == lpszProfileName) <br>    { <br>        return(NULL); <br>    } <br> <br>    // Add COLOR dir path if profile name does not contain a path. <br>    if ( (NULL == _tcschr(lpszProfileName, __TEXT(':'))) <br>         &amp;&amp; <br>         (NULL == _tcschr(lpszProfileName, __TEXT('\\'))) <br>       ) <br>    { <br>        wsprintf(stFullProfile, __TEXT("%s\\%s"), gstProfilesDir, lpszProfileName); <br>    } <br>    else <br>    { <br>        lstrcpy(stFullProfile, lpszProfileName); <br>    } <br>    dwProfileSize = sizeof(PROFILE); <br>    cbDataSize = (lstrlen(stFullProfile) * sizeof(TCHAR)) + sizeof(TCHAR); // String plus NULL <br>    pProfile = GlobalAlloc(GPTR, (dwProfileSize + cbDataSize)); <br>#ifdef _DEBUG <br>    memset(pProfile, UNINIT_BYTE, (cbDataSize+dwProfileSize)); <br>#endif <br> <br>    pProfile-&gt;dwType = PROFILE_FILENAME; <br>    pProfile-&gt;cbDataSize = cbDataSize; <br>    pProfile-&gt;pProfileData = (PVOID)((LPBYTE)pProfile + dwProfileSize); <br>    _tcscpy(pProfile-&gt;pProfileData, stFullProfile); <br>    hProfile = OpenColorProfile(pProfile, PROFILE_READ, FILE_SHARE_READ, OPEN_EXISTING); <br>    if (NULL  == hProfile) <br>    { <br>        ErrMsg(NULL,__TEXT("Unable to open color profile &lt;%s&gt;"), stFullProfile); <br>        DISPLAY_LASTERROR(LASTERROR_NOALLOC, GetLastError()); <br>    } <br>    else <br>    { <br>        // Validate the profile <br>        bValid = IsColorProfileValid(hProfile, &amp;bValid); <br>        if (0 == bValid) <br>        { <br>            ErrMsg(NULL,__TEXT("Color profile %s is not valid"), stFullProfile); <br>            DISPLAY_LASTERROR(LASTERROR_NOALLOC, GetLastError()); <br>            CloseColorProfile(hProfile); <br>            hProfile = NULL; <br>        } <br>    } <br>    // Cleanup <br>    GlobalFree(GlobalHandle(pProfile)); <br>    return(hProfile); <br>}   // End of function OpenColorProfileFromDisk <br> <br> <br>/////////////////////////////////////////////////////////////////////// <br>// <br>// Function:   GetColorSpaceFromBitmap <br>// <br>// Purpose:    Creates a LOGCOLORSPACE based on information in bitmap. <br>// <br>// <br>// Parms:      lpBitmapHeader   Pointer to bitmap header and info. <br>//             dwIntent         Color Space Intent. <br>//             pbDeleteProfile  Flag, on return, will indicate if the profile needs <br>//                              to be deleted before LOGCOLORSPACE is freed. <br>// <br>// <br>/////////////////////////////////////////////////////////////////////// <br> <br>LPLOGCOLORSPACE GetColorSpaceFromBitmap(LPBITMAPINFOHEADER lpBitmapInfo, DWORD dwIntent, <br>                                        LPBOOL pbDeleteProfile) <br>{ <br>    LPLOGCOLORSPACE lpColorSpace = NULL; <br>    PBITMAPV5HEADER lpBitmapV5 = (PBITMAPV5HEADER) lpBitmapInfo; <br> <br>    // Validate parameters. <br>    ASSERT(NULL != lpBitmapInfo); <br>    if ( (NULL == lpBitmapInfo) <br>         || <br>         (NULL == pbDeleteProfile) <br>         || <br>         ( (sizeof(BITMAPCOREHEADER) != lpBitmapInfo-&gt;biSize) <br>           &amp;&amp; <br>           (sizeof(BITMAPINFOHEADER) != lpBitmapInfo-&gt;biSize) <br>           &amp;&amp; <br>           (sizeof(BITMAPV4HEADER) != lpBitmapInfo-&gt;biSize) <br>           &amp;&amp; <br>           (sizeof(BITMAPV5HEADER) != lpBitmapInfo-&gt;biSize) <br>         ) <br>       ) <br>    { <br>        return NULL; <br>    } <br> <br>    // Initalize delete flag. <br>    *pbDeleteProfile = FALSE; <br> <br>    // Allocate LOGCOLORSPACE. <br>    lpColorSpace = (LPLOGCOLORSPACE) GlobalAlloc(GPTR, sizeof(LOGCOLORSPACE)); <br>    if (NULL == lpColorSpace) <br>    { <br>        return NULL; <br>    } <br> <br>    // Initialize color space. <br>    lpColorSpace-&gt;lcsSignature = 'PSOC';  // The signature should always be 'PSOC'. <br>    lpColorSpace-&gt;lcsVersion = 0x400; <br>    lpColorSpace-&gt;lcsSize = sizeof(LOGCOLORSPACE); <br> <br>    // If BITMAPCOREHEADER or BITMAPINFOHEADER, bitmap has no information <br>    // about color space; use sRGB. <br>    if (sizeof(BITMAPINFOHEADER) &gt;= lpBitmapInfo-&gt;biSize) <br>    { <br>        // Set color space to default values. <br> <br>        lpColorSpace-&gt;lcsCSType = LCS_sRGB; <br> <br>        // Set endpoints to sRGB values. <br> <br>        lpColorSpace-&gt;lcsEndpoints.ciexyzRed.ciexyzX = __FXPT2DOT30(.64); <br>        lpColorSpace-&gt;lcsEndpoints.ciexyzRed.ciexyzY = __FXPT2DOT30(.33); <br>        lpColorSpace-&gt;lcsEndpoints.ciexyzRed.ciexyzZ = __FXPT2DOT30(.03); <br> <br>        lpColorSpace-&gt;lcsEndpoints.ciexyzGreen.ciexyzX = __FXPT2DOT30(.3); <br>        lpColorSpace-&gt;lcsEndpoints.ciexyzGreen.ciexyzY = __FXPT2DOT30(.6); <br>        lpColorSpace-&gt;lcsEndpoints.ciexyzGreen.ciexyzZ = __FXPT2DOT30(.1); <br> <br>        lpColorSpace-&gt;lcsEndpoints.ciexyzBlue.ciexyzX   =   __FXPT2DOT30(  .15); <br>        lpColorSpace-&gt;lcsEndpoints.ciexyzBlue.ciexyzY = __FXPT2DOT30(.06); <br>        lpColorSpace-&gt;lcsEndpoints.ciexyzBlue.ciexyzZ = __FXPT2DOT30(.79); <br> <br>        // Just so that if monitor has 2.2 gamma, the over all gamma is 1.0. <br>        lpColorSpace-&gt;lcsGammaRed = __FXPT16DOT16(0.45); <br>        lpColorSpace-&gt;lcsGammaGreen = __FXPT16DOT16(0.45); <br>        lpColorSpace-&gt;lcsGammaBlue = __FXPT16DOT16(0.45); <br>    } <br>    else <br>    { <br>        // Copy information from portion that is similar between BITMAPV4HEADERs and <br>        // BITMAPV5HEADERs. <br>        memcpy(&amp;lpColorSpace-&gt;lcsEndpoints, &amp;lpBitmapV5-&gt;bV5Endpoints, sizeof(CIEXYZTRIPLE)); <br>        lpColorSpace-&gt;lcsGammaRed = lpBitmapV5-&gt;bV5GammaRed; <br>        lpColorSpace-&gt;lcsGammaGreen = lpBitmapV5-&gt;bV5GammaGreen; <br>        lpColorSpace-&gt;lcsGammaBlue = lpBitmapV5-&gt;bV5GammaBlue; <br> <br>        // BITMAPV4HEADERs do not have complete color space information, <br>        // we need to assume some things. <br>        if (sizeof(BITMAPV4HEADER) == lpBitmapInfo-&gt;biSize) <br>        { <br>            // Fill in default values for fields that do not <br>            // have equivalents in BITMAPV4HEADER. <br>            lpColorSpace-&gt;lcsCSType = lpBitmapV5-&gt;bV5CSType; <br>            lpColorSpace-&gt;lcsIntent = LCS_GM_IMAGES; <br>        } <br>        else </code></pre>
<p>
</p>
<pre><code>{ <br>            // BITMAPV5HEADERs have complete color space information. <br>            // No assumptions to make. <br>            lpColorSpace-&gt;lcsIntent = lpBitmapV5-&gt;bV5Intent; <br> <br>            // Look to see if no, linked, or embedded profile. <br>            switch (lpBitmapV5-&gt;bV5CSType) <br>            { <br>                case 'MBED': <br>                    // Need to create profile file and reference <br>                    // profile in the color space. <br>                    lpColorSpace-&gt;lcsCSType = LCS_CALIBRATED_RGB; <br> <br>                    // Make sure that profile data offset is valid and not zero length. <br>                    if ( (lpBitmapV5-&gt;bV5Size &gt; lpBitmapV5-&gt;bV5ProfileData) <br>                         || <br>                         (0L == lpBitmapV5-&gt;bV5ProfileSize) <br>                       ) <br>                    { <br>                        GlobalFree((HANDLE)lpColorSpace); <br>                        return NULL; <br>                    } <br> <br>                    // Create unique temp name. <br>                    { <br>                        DWORD   dwWritten; <br>                        TCHAR   szTempPath[MAX_PATH]; <br>                        HANDLE  hFile; <br> <br>                        GetTempPath(MAX_PATH, szTempPath); <br>                        if (!GetTempFileName(szTempPath, __TEXT("ICM"), 0, lpColorSpace-&gt;lcsFilename)) <br>                        { <br>                            GlobalFree((HANDLE)lpColorSpace); <br>                            return NULL; <br>                        } <br> <br>                        // Create temp profile that contains the embedded profile. <br>                        hFile = CreateFile(lpColorSpace-&gt;lcsFilename, GENERIC_READ | GENERIC_WRITE, <br>                                           0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); <br>                        if (INVALID_HANDLE_VALUE == hFile) <br>                        { <br>                            GlobalFree((HANDLE)lpColorSpace); <br>                            return NULL; <br>                        } <br> <br>                        // Write embedded profile to disk. <br>                        WriteFile(hFile, GETPROFILEDATA(lpBitmapV5), lpBitmapV5-&gt;bV5ProfileSize, <br>                                  &amp;dwWritten, NULL); <br> <br>                        // No longer need file open. <br>                        CloseHandle(hFile); <br> <br>                        // Need to indicate to caller that this file needs to be deleted <br>                        // before LOGCOLORSPACE is freed. <br>                        *pbDeleteProfile = TRUE; <br>                    } <br>                    break; <br> <br>                case 'LINK': <br>                    // Need to reference profile. <br>                    lpColorSpace-&gt;lcsCSType = LCS_CALIBRATED_RGB; <br>                    lstrcpyn(lpColorSpace-&gt;lcsFilename, (LPTSTR) GETPROFILEDATA(lpBitmapV5), MAX_PATH); <br>                    break; <br> <br>                default: <br>                    // Just use color space type in the bitmap. <br>                    lpColorSpace-&gt;lcsCSType = lpBitmapV5-&gt;bV5CSType; <br>                    break; <br>            } <br>        } <br>    } <br>    // Set intent to default or to users selection. <br>    if (0xffffffffL == dwIntent) <br>    { <br>        lpColorSpace-&gt;lcsIntent = LCS_GM_IMAGES; <br>    } <br>    else <br>    { <br>        lpColorSpace-&gt;lcsIntent = dwIntent; <br>    } <br> <br>    return(lpColorSpace); <br>} <br> <br> <br>// <br>// Functions for extracting information from DIBs <br>// <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  NumColorsInDIB <br>// <br>//  Description: <br>//    Determines the number of colors in the DIB by looking at the <br>//    BitCount field in the info block. <br>// <br>//  Parameters: <br>//    LPBINTMAPV5HEADER Pointer to BITMAPINFO structure <br>// <br>//  Returns: <br>//    DWORD   Number of colors in the DIB <br>// <br>//  Comments: <br>// <br>// <br>////////////////////////////////////////////////////////////////////////// <br>DWORD NumColorsInDIB(LPBITMAPINFOHEADER lpbi) <br>{ <br>    WORD    wBitCount; <br>    DWORD   dwColors = 0; <br> <br> <br>    // If this is a Windows style DIB, the number of colors in the <br>    //  color table can be less than the number of bits per pixel <br>    //  allows for (i.e. lpbi-&gt;biClrUsed can be set to some value). <br>    //  If this is the case, return the appropriate value. <br>    if ( (sizeof(BITMAPINFOHEADER) &lt;= lpbi-&gt;biSize) <br>         &amp;&amp; <br>         (0 != lpbi-&gt;biClrUsed) <br>       ) <br>    { <br>        dwColors = lpbi-&gt;biClrUsed; <br>    } <br>    else <br>    { <br>        // Calculate the number of colors in the color table based on <br>        //  the number of bits per pixel for the DIB. <br>        wBitCount = BITCOUNT(lpbi); <br>        if (MAX_BPP_COLOR_TABLE &gt;= wBitCount) <br>        { <br>            dwColors = 1 &lt;&lt; wBitCount;  // Colors = 2^BitCount <br>        } <br>    } <br> <br>    return dwColors; <br>}   // End of function NumColorsInDIB <br> <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  PaletteSize <br>// <br>//  Description: <br>//    Calculates the palette size in bytes. <br>// <br>//  Parameters: <br>//    @@@ <br>// <br>//  Returns: <br>//    DWORD   Palette size in bytes. <br>// <br>//  Comments: <br>// <br>// <br>////////////////////////////////////////////////////////////////////////// <br>DWORD PaletteSize(LPBITMAPINFOHEADER lpbi) <br>{ <br>    DWORD   dwSize = 0L; <br> <br> <br>    if (sizeof(BITMAPINFOHEADER) &lt;= lpbi-&gt;biSize) <br>    { <br>        dwSize = NumColorsInDIB(lpbi) * sizeof(RGBQUAD); <br> <br>        if ( (lpbi-&gt;biCompression == BI_BITFIELDS) <br>             &amp;&amp; <br>             (sizeof(BITMAPV4HEADER) &gt; lpbi-&gt;biSize) <br>           ) <br>        { <br>            dwSize = 3 * sizeof(DWORD); <br>        } <br>    } <br>    else <br>    { <br>        dwSize = NumColorsInDIB(lpbi) * sizeof (RGBTRIPLE); <br>    } <br> <br>    return dwSize; <br>}   // End of function PaletteSize <br> <br> <br>/////////////////////////////////////////////////////////////////////// <br>// <br>// Function:   FindDIBBits <br>// <br>// Purpose:    Given a pointer to a DIB, returns a pointer to the <br>//             DIB's bitmap bits. <br>// <br>// Parms:      lpbi == pointer to DIB header (either BITMAPINFOHEADER <br>//                       or BITMAPCOREHEADER) <br>// <br>/////////////////////////////////////////////////////////////////////// <br> <br>LPBYTE FindDIBBits(LPBITMAPINFOHEADER lpbi) <br>{ <br>    ASSERT(NULL != lpbi); <br>    return ((LPBYTE)lpbi + *(LPDWORD)lpbi + PaletteSize(lpbi) + PROFILESIZE(lpbi)); <br>} <br> <br>/////////////////////////////////////////////////////////////////////// <br>// <br>// Function:   FindDIBBits <br>// <br>// Purpose:    Given a pointer to a DIB, returns a pointer to the <br>//             DIB's bitmap bits. <br>// <br>// Parms:      lpbi == pointer to DIB header (either BITMAPINFOHEADER <br>//                       or BITMAPCOREHEADER) <br>// <br>/////////////////////////////////////////////////////////////////////// <br> <br>LPBYTE FindColorTable(LPBITMAPINFOHEADER lpbi) <br>{ <br>    ASSERT(NULL != lpbi); <br>    return ((LPBYTE)lpbi + *(LPDWORD)lpbi + PaletteSize(lpbi) + PROFILESIZE(lpbi)); <br>} <br> <br>/////////////////////////////////////////////////////////////////////// <br>// <br>// Function:   DIBHeight <br>// <br>// Purpose:    Given a pointer to a DIB, returns the ABSOLUTE VALUE of <br>//             its height.  Note that it returns a DWORD (since a Win30 <br>//             DIB can have a DWORD in its height field), but under <br>//             Win30, the high order word isn't used! <br>// <br>// Parms:      lpDIB == pointer to DIB header (either BITMAPINFOHEADER <br>//                       or BITMAPCOREHEADER) <br>// <br>/////////////////////////////////////////////////////////////////////// <br> <br>LONG DIBHeight (LPBYTE lpDIB) <br>{ <br>    LPBITMAPINFOHEADER lpbmi; <br>    LPBITMAPCOREHEADER lpbmc; <br> <br>    lpbmi = (LPBITMAPINFOHEADER) lpDIB; <br>    lpbmc = (LPBITMAPCOREHEADER) lpDIB; <br>    if (lpbmi-&gt;biSize &gt;= sizeof (BITMAPINFOHEADER)) <br>    { <br>        return labs(lpbmi-&gt;biHeight); // biHeight can now be negative! 8/9/93 <br>    } <br>    else <br>    { <br>        return (LONG) lpbmc-&gt;bcHeight; <br>    } <br>} <br> <br> <br> <br>/////////////////////////////////////////////////////////////////////// <br>// <br>// Function:   DIBWidth <br>// <br>// Purpose:    Given a pointer to a DIB, returns its width.  Note <br>//             that it returns a DWORD (since a Win30 DIB can have <br>//             a DWORD in its width field), but under Win30, the <br>//             high order word isn't used! <br>// <br>// Parms:      lpDIB == pointer to DIB header (either BITMAPINFOHEADER <br>//                       or BITMAPCOREHEADER) <br>// <br>/////////////////////////////////////////////////////////////////////// <br> <br>LONG DIBWidth (LPBYTE lpDIB) <br>{ <br>    LPBITMAPINFOHEADER lpbmi; <br>    LPBITMAPCOREHEADER lpbmc; <br> <br>    lpbmi = (LPBITMAPINFOHEADER) lpDIB; <br>    lpbmc = (LPBITMAPCOREHEADER) lpDIB; <br> <br>    if (lpbmi-&gt;biSize &gt;= sizeof (BITMAPINFOHEADER)) <br>    { <br>        return lpbmi-&gt;biWidth; <br>    } <br>    else <br>    { <br>        return (LONG) lpbmc-&gt;bcWidth; <br>    } <br>} <br> <br> <br>// <br>//  Functions for reading DIBs <br>// <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  ReadDIBFile <br>// <br>//  Description: <br>//     Open a DIB file and create <br>//          -a memory DIB <br>//          -a memory handle containing BITMAPINFO, palette, and the bits <br>// <br>// <br>//  Parameters: <br>//    @@@ <br>// <br>//  Returns: <br>//    HGLOBAL Handle to DIB memory; NULL upon failure. <br>// <br>//  Comments: <br>// <br>////////////////////////////////////////////////////////////////////////// <br>HGLOBAL ReadDIBFile(LPTSTR lpszFileName) <br>{ <br>    // Local variables <br>    HGLOBAL             hDIBInfo; <br>    LPDIBINFO           lpDIBInfo; <br>    BOOL                bGotDIBInfo; <br> <br>    //  Initialize variables <br>    hDIBInfo = CreateDIBInfo(); <br>    if (hDIBInfo == NULL) <br>    { <br>        return(NULL); <br>    } <br>    lpDIBInfo = GlobalLock(hDIBInfo); <br>    if (lpDIBInfo == (LPDIBINFO)NULL) <br>    { <br>        GlobalFree(hDIBInfo); <br>        return(NULL); <br>    } <br>    bGotDIBInfo =  fReadDIBInfo(lpszFileName, lpDIBInfo); <br>    GlobalUnlock(hDIBInfo); <br>    if (0 == bGotDIBInfo)  // failed to open file <br>    { <br>        fFreeDIBInfo(hDIBInfo, TRUE); <br>        hDIBInfo = NULL; <br>    } <br>    return(hDIBInfo); <br>}   // End of function ReadDIBFile <br> <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:   ReadDIBFromFile <br>// <br>//  Description: <br>//      Reads in the bitmap information. <br>// <br>//  Parameters: <br>//      hFile   Handle to bitmap file. <br>// <br>//  Returns:  Handle to DIB Bitmap.  NULL on error. <br>// <br>//  Comments: <br>// <br>////////////////////////////////////////////////////////////////////////// <br>HANDLE ReadDIBFromFile(HANDLE hFile) <br>{ <br>    UINT                    nNumColors; <br>    DWORD                   offBits; <br>    DWORD                   dwRead; <br>    DWORD                   dwImageBytes; <br>    DWORD                   dwSizeImage; <br>    HANDLE                  hDIB; <br>    BITMAPFILEHEADER        BmpFileHeader; <br>    LPBITMAPINFOHEADER      lpbi; <br> <br>    // Make sure non-null file handle. <br> <br>    if (NULL == hFile) <br>    { <br>        return NULL; <br>    } <br> <br>    // Read in Bitmap file header. <br>    if (0L != SetFilePointer(hFile, 0, NULL, FILE_BEGIN)) <br>    { <br>        return NULL; <br>    } <br>    ReadFile(hFile, &amp;BmpFileHeader, sizeof(BITMAPFILEHEADER), &amp;dwRead, NULL); <br>    if (sizeof(BITMAPFILEHEADER) != dwRead) <br>    { <br>        return NULL; <br>    } <br> <br>    // Make sure that the file is a bitmap file. <br>    if (BFT_BITMAP != BmpFileHeader.bfType) <br>    { <br>        return NULL; <br>    } <br> <br>    // Detemine size of bitmap header. <br>    ReadFile(hFile, &amp;dwImageBytes, sizeof(DWORD), &amp;dwRead, NULL); <br>    if (sizeof(DWORD) != dwRead) <br>    { <br>        return NULL; <br>    } <br> <br>    // Allocate memory for header &amp; color table. <br>    // We'll enlarge this memory as needed. <br>    hDIB = GlobalAlloc(GHND, dwImageBytes + (256L * sizeof(RGBQUAD))); <br>    if (!hDIB) <br>    { <br>        return NULL; <br>    } <br>    lpbi = (LPBITMAPINFOHEADER)GlobalLock(hDIB); <br>    if (!lpbi) <br>    { <br>        GlobalFree(hDIB); <br>        return NULL; <br>    } <br> <br>    // Back up to begining of bitmap header and read bitmap header. <br>    SetFilePointer(hFile, sizeof(BITMAPFILEHEADER), NULL, FILE_BEGIN); <br>    ReadFile(hFile, lpbi, dwImageBytes, &amp;dwRead, NULL); <br>    if (dwRead != dwImageBytes) <br>    { <br>        GlobalUnlock(hDIB); <br>        GlobalFree(hDIB); <br>        return NULL; <br>    } <br> <br>    // Dump debug info about type of bitmap opened. <br>#ifdef MAXDEBUG <br>    DumpBmpHeader((LPVOID)lpbi); <br>#endif <br> <br>    // Check to see that it's a Windows DIB or an OS/2 DIB. <br>    // It assumed that anything that is not a OS/2 DIB is a Windows DIB. <br>    // This at least allows the opening of newer bitmap types, although GDI <br>    // may not handle them so we may not be able to display them. <br>    // More critical checking could be done by checking against <br>    // BITMAPV4HEADER and BITMAPV5HEADER sizes. <br> <br>    if (lpbi-&gt;biSize &gt;= sizeof(BITMAPINFOHEADER)) <br>    { <br>        DWORD   dwProfileData = 0; <br>        DWORD   dwColorTableSize; <br>        HANDLE  hTemp; <br> <br>        // Now determine the size of the color table and read it.  Since the <br>        // bitmap bits are offset in the file by bfOffBits, we need to do some <br>        // special processing here to make sure the bits directly follow <br>        // the color table (because that's the format we are susposed to pass <br>        // back) <br> <br>        // no color table for 24-bit, default size otherwise <br>        nNumColors = (UINT)lpbi-&gt;biClrUsed; <br>        if (0 == nNumColors) <br>        { <br>            if (lpbi-&gt;biBitCount &lt;= MAX_BPP_COLOR_TABLE) <br>            { <br>                nNumColors = 1 &lt;&lt; lpbi-&gt;biBitCount;             // standard size table <br>            } <br>        } <br> <br>        // Fill in some default values if they are zero <br>        if (0 == lpbi-&gt;biClrUsed) <br>        { <br>            lpbi-&gt;biClrUsed = nNumColors; <br>        } <br> <br>        if (0 == lpbi-&gt;biSizeImage) <br>        { <br>            // Calculate size using DWORD alignment <br>            dwSizeImage = (((lpbi-&gt;biWidth * lpbi-&gt;biBitCount + 31) &amp; ~31) <br>                           &gt;&gt; 3) * abs(lpbi-&gt;biHeight); <br>        } <br>        else <br>        { <br>            dwSizeImage = lpbi-&gt;biSizeImage; <br>        } <br> <br>        // get a proper-sized buffer for header, color table and bits <br>        // Figure out the size of the bitmap AND it's color table. <br>        dwColorTableSize = PaletteSize(lpbi); <br> <br>        // Calculate profile data size; <br>        // zero if not BITMAPV5HEADER, else in use bV5ProfileSize. <br>        dwProfileData =  PROFILESIZE(lpbi); <br> <br>        // Resize DIB buffer. <br>        dwImageBytes = lpbi-&gt;biSize + dwSizeImage + dwColorTableSize + dwProfileData; <br>        GlobalUnlock(hDIB); <br>        hTemp = GlobalReAlloc(hDIB, dwImageBytes, GHND); <br>        DebugMsg(__TEXT("ReadDIBFromFile:  Allocating %lu bytes for header, color table, and image\r\n"), dwImageBytes); <br>        if (NULL == hTemp) // can't resize buffer for loading <br>        { <br>            GlobalFree(hDIB); <br>            return NULL; <br>        } <br> <br>        hDIB = hTemp; <br>        lpbi = (LPBITMAPINFOHEADER)GlobalLock(hDIB); <br> <br>        // read the color table, if any, into buffer starting past Bitmap header. <br>        if (0 != dwColorTableSize) <br>        { <br>            ReadFile(hFile, (LPBYTE)lpbi + lpbi-&gt;biSize, dwColorTableSize, &amp;dwRead, NULL); <br>            if (dwColorTableSize != dwRead) <br>            { <br>                GlobalUnlock(hDIB); <br>                GlobalFree(hDIB); <br>                return NULL; <br>            } <br>        } <br> <br>        // Load profile data, if any. <br>        if (0 != dwProfileData) <br>        { <br>            // Move to profile data. <br>            SetFilePointer(hFile, sizeof(BITMAPFILEHEADER) <br>                           + ((LPBITMAPV5HEADER)lpbi)-&gt;bV5ProfileData, NULL, FILE_BEGIN); <br> <br>            // Read the profile data in after the header and color table. <br>            ReadFile(hFile, (LPBYTE)lpbi + lpbi-&gt;biSize + dwColorTableSize, dwProfileData, &amp;dwRead, NULL); <br>            if (dwProfileData != dwRead) <br>            { <br>                GlobalUnlock(hDIB); <br>                GlobalFree(hDIB); <br>                return NULL; <br>            } <br> <br>            // Need to change the offset in the header. <br>            ((LPBITMAPV5HEADER)lpbi)-&gt;bV5ProfileData = lpbi-&gt;biSize + dwColorTableSize; <br>        } <br> <br>        // offset to the bits from start of DIB header <br>        offBits = lpbi-&gt;biSize + dwColorTableSize + dwProfileData; <br>        DumpBmpHeader((LPVOID)lpbi); <br>    } <br>    else <br>    { <br>        // It's an OS/2 DIB, the color table is an array of RGBTRIPLEs. <br>        HANDLE                          hTemp; <br>        LPBITMAPCOREHEADER      lpbc = (LPBITMAPCOREHEADER) lpbi; <br> <br>        // Gotta back up to beginning of color table. <br>        SetFilePointer(hFile, sizeof (BITMAPFILEHEADER) + sizeof (BITMAPCOREHEADER), NULL, FILE_BEGIN); <br> <br>        // Now determine the size of the color table and read it.  Since the <br>        // bitmap bits are offset in the file by bfOffBits, we need to do some <br>        // special processing here to make sure the bits directly follow <br>        // the color table (because that's the format we are susposed to pass <br>        // back) <br> <br>        if (lpbc-&gt;bcBitCount &lt;= MAX_BPP_COLOR_TABLE) <br>        { <br>            nNumColors = 1 &lt;&lt; lpbc-&gt;bcBitCount;    // standard size table <br>        } <br>        else <br>        { <br>            nNumColors = 0; <br>        } <br> <br>        // Determine the size of the image <br>        dwSizeImage = (((lpbc-&gt;bcWidth * lpbc-&gt;bcBitCount + 31) &amp; ~31) &gt;&gt; 3) <br>                      * lpbc-&gt;bcHeight; <br> <br>        // get a proper-sized buffer for header, color table and bits <br>        GlobalUnlock(hDIB); <br>        hTemp = GlobalReAlloc(hDIB, lpbc-&gt;bcSize + (nNumColors * sizeof(RGBTRIPLE)) <br>                              + dwSizeImage, GHND); <br>        if (!hTemp) // can't resize buffer for loading <br>        { <br>            GlobalFree(hDIB); <br>            return NULL; <br>        } <br> <br>        hDIB = hTemp; <br>        lpbc = (LPBITMAPCOREHEADER) GlobalLock(hDIB); <br>        lpbi = (LPBITMAPINFOHEADER) lpbc; <br> <br>        // read the color table <br>        ReadFile(hFile, (LPBYTE)lpbc + lpbc-&gt;bcSize, nNumColors * sizeof(RGBTRIPLE), &amp;dwRead, NULL); <br>        if (nNumColors * sizeof(RGBTRIPLE) != dwRead) <br>        { <br>            GlobalUnlock(hDIB); <br>            GlobalFree(hDIB); <br>            return NULL; <br>        } <br> <br>        // offset to the bits from start of DIB header <br>        offBits = lpbc-&gt;bcSize + nNumColors * sizeof(RGBTRIPLE); <br>    } <br> <br>    // If the bfOffBits field is non-zero, then the bits might *not* be <br>    // directly following the color table in the file.  Use the value in <br>    // bfOffBits to seek the bits. <br> <br>    if (BmpFileHeader.bfOffBits != 0L) <br>    { <br>        SetFilePointer(hFile, BmpFileHeader.bfOffBits, NULL, FILE_BEGIN); <br>    } <br> <br>    // Read the actual bits <br>    ReadFile(hFile, (LPBYTE)lpbi + offBits, dwSizeImage, &amp;dwRead, NULL); <br>    if (dwRead != dwSizeImage) <br>    { <br>        GlobalUnlock(hDIB); <br>        GlobalFree(hDIB); <br>        return NULL; <br>    } <br>    GlobalUnlock(hDIB); <br>    return hDIB; <br>}  // End of function ReadDIBFromFile <br> <br> <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  TranslateColorTable <br>// <br>//  Description: <br>// <br>// <br>//  Parameters: <br>//    @@@ <br>// <br>//  Returns: <br>//    BOOL <br>// <br>//  Comments: <br>// <br>// <br>////////////////////////////////////////////////////////////////////////// <br>BOOL TranslateColorTable(HTRANSFORM hColorTransform, <br>                         PCOLOR    paInputColors, <br>                         DWORD   nColors, <br>                         COLORTYPE     ctInput, <br>                         PCOLOR    paOutputColors, <br>                         COLORTYPE   ctOutput, <br>                         int         biBitCount <br>                        ) <br>{ <br>    //  Initialize variables <br>    if (ctInput == COLOR_RGB) <br>    { <br>        return(TranslateBitmapBits(hColorTransform, <br>                                   (PVOID)paInputColors, <br>                                   BM_xRGBQUADS, <br>                                   1&lt;&lt;biBitCount, <br>                                   1, <br>                                   0, <br>                                   (PVOID)paOutputColors, <br>                                   BM_xRGBQUADS, <br>                                   0, <br>                                   NULL, <br>                                   0)); <br>    } <br>    else <br>    { <br>        return(TranslateColors(hColorTransform, paInputColors, nColors, ctInput, paOutputColors, ctOutput)); <br>    } <br>}   // End of function TranslateColorTable <br> <br> <br>////////////////////////////////////////////////////////////////////////// <br>//  Function:  SaveDIBToFile <br>// <br>//  Description: <br>// <br>// <br>//  Parameters: <br>//    @@@ <br>// <br>//  Returns: <br>//    BOOL <br>// <br>//  Comments: <br>// <br>// <br>////////////////////////////////////////////////////////////////////////// <br>BOOL SaveDIBToFile(HWND hWnd, LPCTSTR lpszFileName, LPDIBINFO lpDIBInfo, DWORD dwType) <br>{ <br>    BOOL                bResult = FALSE; <br>    HANDLE              hFile; <br>    HANDLE              hDIBTransformed = NULL; <br>    PBITMAPINFOHEADER   pBitmapInfo; <br> <br> <br>    // Validate Parameters. <br>    if ( (NULL == lpszFileName) <br>         || <br>         (NULL == lpDIBInfo) <br>         || <br>         (NULL == lpDIBInfo-&gt;hDIB) <br>         || <br>         ( (LCS_sRGB != dwType) <br>           &amp;&amp; <br>           (LCS_CALIBRATED_RGB != dwType) <br>           &amp;&amp; <br>           (PROFILE_LINKED != dwType) <br>           &amp;&amp; <br>           (PROFILE_EMBEDDED != dwType) <br>         ) <br>       ) <br>    { <br>        return FALSE; <br>    } <br>    pBitmapInfo = (PBITMAPINFOHEADER) GlobalLock(lpDIBInfo-&gt;hDIB); <br> <br>    // Open file handle. <br>    hFile = CreateFile(lpszFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, <br>                       FILE_ATTRIBUTE_NORMAL, NULL); <br>    if (INVALID_HANDLE_VALUE != hFile) <br>    { <br>        DWORD               dwBytes; <br>        DWORD               dwProfileSize; <br>        PBYTE               pProfileData; <br>        LPSTR               lpszProfileName; <br>        BITMAPV5HEADER      BitmapHeader; <br>        BITMAPFILEHEADER    FileHeader; <br> <br> <br>        // Initialize variables. <br>        dwProfileSize = PROFILESIZE(pBitmapInfo); <br>        pProfileData = GETPROFILEDATA(pBitmapInfo); <br>        lpszProfileName = NULL; <br>        memset(&amp;BitmapHeader, 0, sizeof(BITMAPV5HEADER)); <br>        memset(&amp;FileHeader, 0, sizeof(BITMAPFILEHEADER)); <br> <br>        // Convert to proper type. <br>        if (dwType != BITMAPCSTYPE(pBitmapInfo)) <br>        { <br>            if (PROFILE_LINKED == dwType) <br>            { <br>                ASSERT(PROFILE_EMBEDDED == BITMAPCSTYPE(pBitmapInfo)); <br> <br>                // Going from Embedded profile to linked. <br>                // Save embedded profile data to file. <br> <br>                // Create file name from manufacture and model name of profile header. <br>                lpszProfileName = (LPSTR) GlobalAlloc(GPTR, 1024); <br> <br>                // Get save name and save profile data. <br>                if (GetProfileSaveName(hWnd, &amp;lpszProfileName, 1024)) <br>                { <br>                    HANDLE  hProfile; <br> <br>                    hProfile = CreateFileA(lpszProfileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, <br>                                           FILE_ATTRIBUTE_NORMAL, NULL); <br>                    if (INVALID_HANDLE_VALUE != hProfile) <br>                    { <br>                        WriteFile(hProfile, pProfileData, dwProfileSize, &amp;dwBytes, NULL); <br>                        CloseHandle(hProfile); <br>                    } <br> <br>                    // Change profile variables to point to linked name. <br>                    pProfileData = (PBYTE) lpszProfileName; <br>                    dwProfileSize = strlen(lpszProfileName); <br>                } <br>            } <br>            else if (PROFILE_EMBEDDED == dwType) <br>            { <br>                DWORD       dwSize = 0; <br>                PROFILE     Profile; <br>                HPROFILE    hProfile; <br> <br> <br>                ASSERT(PROFILE_EMBEDDED == BITMAPCSTYPE(pBitmapInfo)); <br> <br>                // Going from linked profile to Embedded. <br>                // Embed Linked profile data. <br> <br>                // Open profile. <br>                Profile.dwType = PROFILE_FILENAME; <br>                Profile.pProfileData = pProfileData; <br>                Profile.cbDataSize = dwProfileSize; <br>                hProfile = OpenColorProfile(&amp;Profile, PROFILE_READ, FILE_SHARE_READ, OPEN_EXISTING); <br> <br>                // Get profile data form handle. <br>                if (NULL != hProfile) <br>                { <br>                    GetColorProfileFromHandle(hProfile, NULL, &amp;dwSize); <br>                    lpszProfileName = (LPSTR) GlobalAlloc(GPTR, dwSize); <br>                    GetColorProfileFromHandle(hProfile, (PBYTE) lpszProfileName, &amp;dwSize); <br> <br>                    CloseColorProfile(hProfile); <br>                } <br> <br>                // Change profile variables to point at data to embed. <br>                pProfileData = (PBYTE) lpszProfileName; <br>                dwProfileSize = dwSize; <br>            } <br>            else if (LCS_sRGB == dwType) <br>            { <br>                DWORD       dwSize; <br>                LPTSTR      pszSRGB; <br> <br> <br>                // Need to translate from current type to sRGB. <br> <br>                // Open sRGB profile. <br>                GetStandardColorSpaceProfile(NULL, LCS_sRGB, NULL, &amp;dwSize); <br>                pszSRGB = (LPTSTR) GlobalAlloc(GPTR, dwSize); <br>                GetStandardColorSpaceProfile(NULL, LCS_sRGB, pszSRGB, &amp;dwSize); <br> <br>                if (NULL != pszSRGB) <br>                { <br>                    // Translate DIB. <br>                    hDIBTransformed = TransformDIBOutsideDC(lpDIBInfo-&gt;hDIB, <br>                                                            lpDIBInfo-&gt;bmFormat, <br>                                                            pszSRGB, <br>                                                            NULL, <br>                                                            USE_BITMAP_INTENT, <br>                                                            NULL, <br>                                                            0); <br> <br>                    // Clean up. <br>                    GlobalFree((HANDLE)pszSRGB); <br> <br>                    // Change bitmap info variable to point at tranlated DIB. <br>                    pBitmapInfo = (PBITMAPINFOHEADER) GlobalLock(hDIBTransformed); <br>                } <br>            } <br>        } <br> <br>        if (NULL != pBitmapInfo) <br>        { <br>            // Create file header and write it to the file. <br>            FileHeader.bfType = BFT_BITMAP; <br>            FileHeader.bfSize = sizeof(BITMAPFILEHEADER); <br>            FileHeader.bfSize += sizeof(BITMAPV5HEADER); <br>            FileHeader.bfSize += NumColorsInDIB(pBitmapInfo) * sizeof(RGBQUAD); <br>            FileHeader.bfSize += BITMAPSIZE(pBitmapInfo); <br>            FileHeader.bfSize += dwProfileSize; <br>            FileHeader.bfOffBits = sizeof(BITMAPFILEHEADER); <br>            FileHeader.bfOffBits += sizeof(BITMAPV5HEADER); <br>            FileHeader.bfOffBits += NumColorsInDIB(pBitmapInfo) * sizeof(RGBQUAD); <br>            WriteFile(hFile, &amp;FileHeader, sizeof(BITMAPFILEHEADER), &amp;dwBytes, NULL); <br> <br>            // Create bitmap header and write it to file. <br>            BitmapHeader.bV5Size = sizeof(BITMAPV5HEADER); <br>            BitmapHeader.bV5Width = BITMAPWIDTH(pBitmapInfo); <br>            BitmapHeader.bV5Height = BITMAPHEIGHT(pBitmapInfo); <br>            BitmapHeader.bV5Planes = 1; <br>            BitmapHeader.bV5BitCount = (WORD) BITCOUNT(pBitmapInfo); <br>            BitmapHeader.bV5Compression = BITMAPCOMPRESSION(pBitmapInfo); <br>            BitmapHeader.bV5SizeImage = BITMAPIMAGESIZE(pBitmapInfo); <br>            BitmapHeader.bV5ClrUsed = BITMAPCLRUSED(pBitmapInfo); <br>            BitmapHeader.bV5ClrImportant = BITMAPCLRIMPORTANT(pBitmapInfo); <br>            BitmapHeader.bV5RedMask = BITMAPREDMASK(pBitmapInfo); <br>            BitmapHeader.bV5GreenMask = BITMAPGREENMASK(pBitmapInfo); <br>            BitmapHeader.bV5BlueMask = BITMAPBLUEMASK(pBitmapInfo); <br>            BitmapHeader.bV5CSType = dwType; <br>            if (sizeof(BITMAPV4HEADER) &lt;= *(LPDWORD)pBitmapInfo) <br>            { <br>                memcpy(&amp;BitmapHeader.bV5Endpoints, &amp;((PBITMAPV4HEADER)pBitmapInfo)-&gt;bV4Endpoints, <br>                       sizeof(CIEXYZTRIPLE) + sizeof(DWORD) * 3); <br>            } <br>            BitmapHeader.bV5Intent = BITMAPINTENT(pBitmapInfo); <br>            BitmapHeader.bV5ProfileData = sizeof(BITMAPV5HEADER); <br>            BitmapHeader.bV5ProfileData += NumColorsInDIB(pBitmapInfo) * sizeof(RGBQUAD); <br>            BitmapHeader.bV5ProfileData += BITMAPSIZE(pBitmapInfo); <br>            BitmapHeader.bV5ProfileSize = dwProfileSize; <br>            WriteFile(hFile, &amp;BitmapHeader, sizeof(BITMAPV5HEADER), &amp;dwBytes, NULL); <br> <br>            // Write color table. <br>            if (!IS_BITMAPCOREHEADER(pBitmapInfo)) <br>            { <br>                PBYTE   pColorTable; <br>                DWORD   dwColorTableSize; <br> <br>                dwColorTableSize = NumColorsInDIB(pBitmapInfo) * sizeof(RGBQUAD); <br>                pColorTable = (PBYTE)pBitmapInfo + *(LPDWORD)pBitmapInfo; <br>                if ( IS_BITMAPINFOHEADER(pBitmapInfo) <br>                     &amp;&amp; <br>                     (BI_BITFIELDS == BITMAPCOMPRESSION(pBitmapInfo)) <br>                   ) <br>                { <br>                    dwColorTableSize += sizeof(DWORD) * 3; <br>                } <br> <br>                WriteFile(hFile, pColorTable, dwColorTableSize, &amp;dwBytes, NULL); <br>            } <br>            else <br>            { <br>                PBYTE   pColorTable; <br>                DWORD   dwCount; </code></pre>
<p>
</p>
<pre><code>RGBQUAD ColorTable[256]; <br> <br> <br>                pColorTable = (PBYTE)pBitmapInfo + *(LPDWORD)pBitmapInfo; <br>                memset(ColorTable, 0, sizeof(ColorTable)); <br>                for (dwCount = 0; dwCount &lt; NumColorsInDIB(pBitmapInfo); dwCount++) <br>                    memcpy(ColorTable + dwCount, pColorTable + dwCount, sizeof(RGBTRIPLE)); <br> <br>                WriteFile(hFile, ColorTable, NumColorsInDIB(pBitmapInfo) * sizeof(RGBQUAD), &amp;dwBytes, NULL); <br>            } <br> <br>            // Save bitmap data. <br>            WriteFile(hFile, FindDIBBits(pBitmapInfo), BITMAPSIZE(pBitmapInfo), &amp;dwBytes, NULL); <br> <br>            // Save profile data. <br>            if (0 != dwProfileSize) <br>            { <br>                WriteFile(hFile, pProfileData, dwProfileSize, &amp;dwBytes, NULL); <br>            } <br> <br>            bResult = TRUE; <br>        } <br> <br>        // Clean up. <br>        CloseHandle(hFile); <br>        if (NULL != lpszProfileName) <br>            GlobalFree((HANDLE)lpszProfileName); <br>        if (NULL != hDIBTransformed) <br>        { <br>            GlobalUnlock(hDIBTransformed); <br>            GlobalFree(hDIBTransformed); <br>        } <br> <br>        // If failed, delete file. <br>        if (!bResult) <br>            DeleteFile(lpszFileName); <br>    } <br> <br>    //Clean up. <br>    GlobalUnlock(lpDIBInfo-&gt;hDIB); <br> <br>    return bResult; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
