<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DPLAUNCH.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3062"></a>DPLAUNCH.C</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved. <br> * <br> *  File:       dplaunch.c <br> *  Content:Implementation of a DirectPlay launching utility <br> * <br> ***************************************************************************/ <br> <br>#define INITGUID <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;objbase.h&gt; <br>#include &lt;cguid.h&gt; <br> <br>#include "dplay.h" <br>#include "dplobby.h" <br> <br>#include "resource.h" <br> <br>// constants <br>#define NAMEMAX200// maximum size of a string name <br>#define ADDRESSTYPEMAX10// maximum no. address types <br> <br>// GUID for sessions this application creates <br>// {D559FC00-DC12-11cf-9C4E-00A0C905425E} <br>DEFINE_GUID(MY_SESSION_GUID,  <br>0xd559fc00, 0xdc12, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e); <br> <br>// structures <br> <br>// list of address types <br>typedef struct { <br>DWORDdwCount; <br>GUIDguidAddressTypes[ADDRESSTYPEMAX]; <br>} ADDRESSTYPELIST, *LPADDRESSTYPELIST; <br> <br>// prototypes <br>BOOL CALLBACKLauncherWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam); <br>HRESULTInitializeLauncherWindow(HWND hWnd, LPDIRECTPLAYLOBBY2A *lplpDPlayLobby); <br>HRESULTUpdateAddressInfo(HWND hWnd, LPDIRECTPLAYLOBBY2A lpDPlayLobby); <br>voidDestroyLauncherWindow(HWND hWnd, LPDIRECTPLAYLOBBY2A lpDPlayLobby); <br>voidLaunchDirectPlayApplication(HWND hWnd, LPDIRECTPLAYLOBBY2A lpDPlayLobby); <br>HRESULTGetComboBoxGuid(HWND hWnd, LONG iDialogItem, LPGUID lpguidServiceProvider); <br>HRESULTFillModemComboBox(HWND hWnd, LPDIRECTPLAYLOBBY2A lpDPlayLobby, LPGUID lpguidServiceProvider); <br> <br> <br>// --------------------------------------------------------------------------- <br>// WinMain <br>// --------------------------------------------------------------------------- <br>// Description:             Main windows entry point. <br>// Arguments: <br>//  HINSTANCE               [in] Standard windows stuff <br>//  HINSTANCE               [in] <br>//  LPSTR                   [in] <br>//  int                     [in] <br>// Returns: <br>//  int <br>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, <br>    LPSTR lpCmdLine, int nCmdShow ) <br>{ <br>    return DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_LAUNCHERDIALOG), NULL, LauncherWndProc, (LPARAM) hInstance); <br>} <br> <br> <br>// --------------------------------------------------------------------------- <br>// LauncherWndProc <br>// --------------------------------------------------------------------------- <br>// Description:             Message callback function for Launcher dialog. <br>// Arguments: <br>//  HWND                    [in] Dialog window handle. <br>//  UINT                    [in] Window message identifier. <br>//  WPARAM                  [in] Depends on message. <br>//  LPARAM                  [in] Depends on message. <br>// Returns: <br>//  BOOL                    TRUE if message was processed internally. <br>BOOL CALLBACK LauncherWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) <br>{ <br>    static HINSTANCEhInst; <br>static LPDIRECTPLAYLOBBY2AlpDPlayLobby; <br>HRESULThr; <br> <br>    switch(uMsg) <br>    { <br>        case WM_INITDIALOG: <br>            // Save the instance handle <br>            hInst = (HINSTANCE)lParam; <br>                         <br>// Initialize dialog with launcher information <br>lpDPlayLobby = NULL; <br>hr = InitializeLauncherWindow(hWnd, &amp;lpDPlayLobby); <br>            break; <br> <br>        case WM_DESTROY: <br>// Destroy launcher information in dialog <br>DestroyLauncherWindow(hWnd, lpDPlayLobby); <br> <br>            // Return failure <br>            EndDialog(hWnd, FALSE); <br> <br>            break; <br> <br>        case WM_COMMAND: <br>            switch(LOWORD(wParam)) <br>            { <br>case IDC_SPCOMBO: <br> <br>switch (HIWORD(wParam)) <br>{ <br>case CBN_SELCHANGE: <br>// update the address info display <br>UpdateAddressInfo(hWnd, lpDPlayLobby); <br>break; <br>} <br>break; <br> <br>                case IDC_RUNAPPBUTTON: <br>// get settings and launch application <br>                    LaunchDirectPlayApplication(hWnd, lpDPlayLobby); <br> <br>                    break; <br> <br>                case IDCANCEL: <br>                    // Return failure <br>                    EndDialog(hWnd, TRUE); <br> <br>                    break; <br>            } <br> <br>            break; <br>    } <br> <br>    // Allow for default processing <br>    return FALSE; <br>} <br> <br>// --------------------------------------------------------------------------- <br>// EnumApp <br>// --------------------------------------------------------------------------- <br>// Description:             Enumeration callback called by DirectPlay. <br>//Enumerates the applications registered with DirectPlay. <br>// Arguments: <br>//  LPDPLAPPINFO            [in] information about the application <br>//  LPVOID    [in] user-defined context <br>//  DWORD[in] flags <br>// Returns: <br>//  BOOLTRUE to continue enumerating <br>BOOL FAR PASCAL EnumApp(LPCDPLAPPINFO lpAppInfo, LPVOID lpContext, DWORD dwFlags) <br>{ <br>    HWNDhWnd = lpContext; <br>    LRESULTiIndex; <br>LPGUIDlpGuid; <br> <br>// store application name in combo box <br>iIndex = SendDlgItemMessage(hWnd, IDC_APPCOMBO, CB_ADDSTRING, 0, (LPARAM) lpAppInfo-&gt;lpszAppNameA); <br>if (iIndex == LB_ERR) <br>goto Failure; <br> <br>// make space for application GUID <br>lpGuid = (LPGUID) GlobalAllocPtr(GHND, sizeof(GUID)); <br>if (lpGuid == NULL) <br>goto Failure; <br> <br>// store pointer to GUID in combo box <br>*lpGuid = lpAppInfo-&gt;guidApplication; <br>SendDlgItemMessage(hWnd, IDC_APPCOMBO, CB_SETITEMDATA, (WPARAM) iIndex, (LPARAM) lpGuid); <br> <br>Failure: <br>    return (TRUE); <br>} <br> <br>// --------------------------------------------------------------------------- <br>// EnumSP <br>// --------------------------------------------------------------------------- <br>// Description:             Enumeration callback called by DirectPlay. <br>//Enumerates service providers registered with DirectPlay. <br>// Arguments: <br>//  LPGUID[in] GUID of service provider <br>//  LPTSTR[in] name of service provider <br>//  DWORD[in] major version of DirectPlay <br>//  DWORD[in] minor version of DirectPlay <br>//  LPVOID    [in] user-defined context <br>// Returns: <br>//  BOOLTRUE to continue enumerating <br>BOOL FAR PASCAL EnumSP(LPGUID lpSPGuid, LPTSTR lptszDesc, DWORD dwMajorVersion, <br>       DWORD dwMinorVersion, LPVOID lpContext) <br>{ <br>    HWNDhWnd = lpContext; <br>    LRESULTiIndex; <br>LPGUIDlpGuid; <br> <br>// store service provider name in combo box <br>iIndex = SendDlgItemMessage(hWnd, IDC_SPCOMBO, CB_ADDSTRING, 0, (LPARAM) lptszDesc); <br>if (iIndex == LB_ERR) <br>goto Failure; <br> <br>// make space for service provider GUID <br>lpGuid = (LPGUID) GlobalAllocPtr(GHND, sizeof(GUID)); <br>if (lpGuid == NULL) <br>goto Failure; <br> <br>// store pointer to GUID in combo box <br>*lpGuid = *lpSPGuid; <br>SendDlgItemMessage(hWnd, IDC_SPCOMBO, CB_SETITEMDATA, (WPARAM) iIndex, (LPARAM) lpGuid); <br> <br>Failure: <br>    return (TRUE); <br>} <br> <br>// --------------------------------------------------------------------------- <br>// InitializeLauncherWindow <br>// --------------------------------------------------------------------------- <br>// Description:             Initializes the window for the Launcher. <br>// Arguments: <br>//  HWND                    [in] Window handle. <br>//  LPDIRECTPLAYLOBBY2A[out] IDirectPlayLobby interface. <br>// Returns: <br>//  HRESULTany errors initializing the window <br>HRESULT InitializeLauncherWindow(HWND hWnd, LPDIRECTPLAYLOBBY2A *lplpDPlayLobby) <br>{ <br>LPDIRECTPLAYLOBBYAlpDPlayLobbyA = NULL; <br>LPDIRECTPLAYLOBBY2AlpDPlayLobby2A = NULL; <br>HRESULThr; <br> <br>// get ANSI DirectPlayLobby interface <br>hr = DirectPlayLobbyCreate(NULL, &amp;lpDPlayLobbyA, NULL, NULL, 0); <br>if FAILED(hr) <br>goto Failure; <br> <br>// get ANSI DirectPlayLobby2 interface <br>hr = lpDPlayLobbyA-&gt;lpVtbl-&gt;QueryInterface(lpDPlayLobbyA, <br>&amp;IID_IDirectPlayLobby2A, (LPVOID *) &amp;lpDPlayLobby2A); <br>if FAILED(hr) <br>goto Failure; <br> <br>// don't need DirectPlayLobby interface anymore <br>lpDPlayLobbyA-&gt;lpVtbl-&gt;Release(lpDPlayLobbyA); <br>lpDPlayLobbyA = NULL; <br> <br>// put all the DirectPlay applications in a combo box <br>lpDPlayLobby2A-&gt;lpVtbl-&gt;EnumLocalApplications(lpDPlayLobby2A, EnumApp, hWnd, 0); <br> <br>// put all the service providers in a combo box <br>DirectPlayEnumerate(EnumSP, hWnd); <br> <br>// initialize the controls <br>SendDlgItemMessage(hWnd, IDC_APPCOMBO, CB_SETCURSEL, (WPARAM) 0, 0); <br>SendDlgItemMessage(hWnd, IDC_SPCOMBO, CB_SETCURSEL, (WPARAM) 0, 0); <br>SendDlgItemMessage(hWnd, IDC_HOSTRADIO, BM_SETCHECK, (WPARAM) BST_CHECKED, 0); <br> <br>// update the address info display <br>hr = UpdateAddressInfo(hWnd, lpDPlayLobby2A); <br> <br>// return the ANSI lobby interface <br>*lplpDPlayLobby = lpDPlayLobby2A; <br> <br>return (DP_OK); <br> <br>Failure: <br>if (lpDPlayLobbyA) <br>lpDPlayLobbyA-&gt;lpVtbl-&gt;Release(lpDPlayLobbyA); <br>if (lpDPlayLobby2A) <br>lpDPlayLobby2A-&gt;lpVtbl-&gt;Release(lpDPlayLobby2A); <br> <br>return (hr); <br>} <br> <br>// --------------------------------------------------------------------------- <br>// DestroyLauncherWindow <br>// --------------------------------------------------------------------------- <br>// Description:             Destroys the launcher window. <br>// Arguments: <br>//  HWND                    [in] Window handle. <br>//  LPDIRECTPLAYLOBBY2A      [in] DirectPlay Lobby interface to destroy <br>// Returns: <br>//  Nothing <br>void DestroyLauncherWindow(HWND hWnd, LPDIRECTPLAYLOBBY2A lpDPlayLobby) <br>{ <br>WPARAMindex; <br>LRESULTlpData; <br> <br>// destroy the GUID's stored with each app name <br>index = 0; <br>while (TRUE) <br>{ <br>lpData = SendDlgItemMessage(hWnd, IDC_APPCOMBO, CB_GETITEMDATA, (WPARAM) index, 0); <br>if ((lpData == CB_ERR) || (lpData == 0)) <br>break; <br> <br>GlobalFreePtr((LPVOID) lpData); <br>index += 1; <br>} <br> <br>// destroy the GUID's stored with each service provider name <br>index = 0; <br>while (TRUE) <br>{ <br>lpData = SendDlgItemMessage(hWnd, IDC_SPCOMBO, CB_GETITEMDATA, (WPARAM) index, 0); <br>if ((lpData == CB_ERR) || (lpData == 0)) <br>break; <br> <br>GlobalFreePtr((LPVOID) lpData); <br>index += 1; <br>} <br> <br>// release the lobby interface <br>if (lpDPlayLobby) <br>lpDPlayLobby-&gt;lpVtbl-&gt;Release(lpDPlayLobby); <br>} <br> <br>// --------------------------------------------------------------------------- <br>// EnumAddressTypes <br>// --------------------------------------------------------------------------- <br>// Description:             Enumeration callback called by DirectPlayLobby. <br>//Enumerates the address types supported by the <br>//given Service Provider and returns them in a list. <br>// Arguments: <br>//  REFGUID                 [in] GUID of the address type <br>//  LPVOID    [in] user-defined context <br>//  DWORD[in] flags <br>// Returns: <br>//  BOOLFALSE to stop enumerating after the first callback <br>BOOL FAR PASCAL EnumAddressTypes(REFGUID guidAddressType, LPVOID lpContext, <br>DWORD dwFlags) <br>{ <br>LPADDRESSTYPELISTlpAddressTypes = (LPADDRESSTYPELIST) lpContext; <br> <br>// make sure there is room <br>if (lpAddressTypes-&gt;dwCount &lt; ADDRESSTYPEMAX) <br>{ <br>// save the address type guid in the list <br>lpAddressTypes-&gt;guidAddressTypes[lpAddressTypes-&gt;dwCount] = *guidAddressType; <br>lpAddressTypes-&gt;dwCount++; <br>} <br> <br>return (TRUE); <br>} <br> <br>// --------------------------------------------------------------------------- <br>// UpdateAddressInfo <br>// --------------------------------------------------------------------------- <br>// Description:             Updates address information elements in dialog. <br>//Calls EnumAddressTypes() to determine what address <br>//information should be displayed and arranges dialog <br>//to display and collect the needed information. <br>// Arguments: <br>//  HWND[in] window handle <br>//  LPDIRECTPLAYLOBBY2A[in] DirectPlay Lobby interface to use <br>// Returns: <br>//  HRESULTDP_OK if it succeedes, otherwise the error <br>HRESULT UpdateAddressInfo(HWND hWnd, LPDIRECTPLAYLOBBY2A lpDPlayLobby) <br>{ <br>GUIDguidServiceProvider, guidAddressType; <br>ADDRESSTYPELISTaddressTypeList; <br>DWORDi; <br>HRESULThr; <br> <br>// get guid of currently selected service provider <br>hr = GetComboBoxGuid(hWnd, IDC_SPCOMBO, &amp;guidServiceProvider); <br>if FAILED(hr) <br>goto Failure; <br> <br>// get the list of address types for this service provider <br>ZeroMemory(&amp;addressTypeList, sizeof(ADDRESSTYPELIST)); <br>hr = lpDPlayLobby-&gt;lpVtbl-&gt;EnumAddressTypes(lpDPlayLobby, <br>EnumAddressTypes, &amp;guidServiceProvider, &amp;addressTypeList, 0L); <br>if FAILED(hr) <br>goto Failure; <br> <br>// clear and hide address dialog items <br>SendDlgItemMessage(hWnd, IDC_ADDRESSCOMBO, CB_RESETCONTENT, <br>(WPARAM) 0, (LPARAM) 0); <br>ShowWindow(GetDlgItem(hWnd, IDC_ADDRESSCOMBO), SW_HIDE); <br>ShowWindow(GetDlgItem(hWnd, IDC_ADDRESSCOMBOLABEL), SW_HIDE); <br> <br>SetDlgItemText(hWnd, IDC_ADDRESSEDIT, ""); <br>ShowWindow(GetDlgItem(hWnd, IDC_ADDRESSEDIT), SW_HIDE); <br>ShowWindow(GetDlgItem(hWnd, IDC_ADDRESSEDITLABEL), SW_HIDE); <br> <br>// loop over the address types <br>for (i = 0; i &lt; addressTypeList.dwCount; i++) <br>{ <br>guidAddressType = addressTypeList.guidAddressTypes[i]; <br> <br>// phone number <br>if (IsEqualGUID(&amp;guidAddressType, &amp;DPAID_Phone)) <br>{ <br>SetDlgItemText(hWnd, IDC_ADDRESSEDITLABEL, "Phone number"); <br>ShowWindow(GetDlgItem(hWnd, IDC_ADDRESSEDIT), SW_SHOW); <br>ShowWindow(GetDlgItem(hWnd, IDC_ADDRESSEDITLABEL), SW_SHOW); <br>} <br> <br>// modem <br>else if (IsEqualGUID(&amp;guidAddressType, &amp;DPAID_Modem)) <br>{ <br>SetDlgItemText(hWnd, IDC_ADDRESSCOMBOLABEL, "Modem"); <br>ShowWindow(GetDlgItem(hWnd, IDC_ADDRESSCOMBO), SW_SHOW); <br>ShowWindow(GetDlgItem(hWnd, IDC_ADDRESSCOMBOLABEL), SW_SHOW); <br>FillModemComboBox(hWnd, lpDPlayLobby, &amp;guidServiceProvider); <br>} <br> <br>// internet address <br>else if (IsEqualGUID(&amp;guidAddressType, &amp;DPAID_INet)) <br>{ <br>SetDlgItemText(hWnd, IDC_ADDRESSEDITLABEL, "IP address"); <br>ShowWindow(GetDlgItem(hWnd, IDC_ADDRESSEDIT), SW_SHOW); <br>ShowWindow(GetDlgItem(hWnd, IDC_ADDRESSEDITLABEL), SW_SHOW); <br>} <br>} <br> <br>Failure: <br>return (hr); <br>} <br> <br>// --------------------------------------------------------------------------- <br>// CreateAddress <br>// --------------------------------------------------------------------------- <br>// Description:             Creates a DPADDRESS using the address information <br>//from the dialog. <br>// Arguments: <br>//  HWND[in] window handle <br>//  LPDIRECTPLAYLOBBY2A      [in] DirectPlay Lobby interface to use <br>//  LPGUID[in] GUID of servicer provider to create address for <br>//  LPVOID*[out] pointer to return address in <br>//  LPDWORD[out] pointer to return address size in <br>// Returns: <br>//  HRESULTany error creating the address <br>HRESULT CreateAddress(HWND hWnd, LPDIRECTPLAYLOBBY2A lpDPlayLobby, <br>  LPGUID lpguidServiceProvider, <br>  LPVOID *lplpAddress, LPDWORD lpdwAddressSize) <br>{ <br>GUIDguidAddressType; <br>ADDRESSTYPELISTaddressTypeList; <br>DPCOMPOUNDADDRESSELEMENTaddressElements[1 + ADDRESSTYPEMAX]; <br>CHARszPhoneNumberString[NAMEMAX]; <br>CHARszModemString[NAMEMAX]; <br>CHARszIPAddressString[NAMEMAX]; <br>LPVOIDlpAddress = NULL; <br>DWORDdwAddressSize = 0; <br>DWORDi, dwElementCount; <br>HRESULThr; <br> <br>// get the list of address types for this service provider <br>ZeroMemory(&amp;addressTypeList, sizeof(ADDRESSTYPELIST)); <br>hr = lpDPlayLobby-&gt;lpVtbl-&gt;EnumAddressTypes(lpDPlayLobby, <br>EnumAddressTypes, lpguidServiceProvider, &amp;addressTypeList, 0L); <br>if FAILED(hr) <br>goto Failure; <br> <br>dwElementCount = 0; <br> <br>// all DPADDRESS's must have a service provider chunk <br>addressElements[dwElementCount].guidDataType = DPAID_ServiceProvider; <br>addressElements[dwElementCount].dwDataSize = sizeof(GUID); <br>addressElements[dwElementCount].lpData = lpguidServiceProvider; <br>dwElementCount++; <br> <br>// loop over the address types <br>for (i = 0; i &lt; addressTypeList.dwCount; i++) <br>{ <br>guidAddressType = addressTypeList.guidAddressTypes[i]; <br> <br>// phone number <br>if (IsEqualGUID(&amp;guidAddressType, &amp;DPAID_Phone)) <br>{ <br>// add a phone number chunk <br>GetDlgItemText(hWnd, IDC_ADDRESSEDIT, szPhoneNumberString, NAMEMAX); <br>addressElements[dwElementCount].guidDataType = DPAID_Phone; <br>addressElements[dwElementCount].dwDataSize = lstrlen(szPhoneNumberString) + 1; <br>addressElements[dwElementCount].lpData = szPhoneNumberString; <br>dwElementCount++; <br>} <br> <br>// modem <br>else if (IsEqualGUID(&amp;guidAddressType, &amp;DPAID_Modem)) <br>{ <br>// add a modem chunk <br>GetDlgItemText(hWnd, IDC_ADDRESSCOMBO, szModemString, NAMEMAX); <br>addressElements[dwElementCount].guidDataType = DPAID_Modem; <br>addressElements[dwElementCount].dwDataSize = lstrlen(szModemString) + 1; <br>addressElements[dwElementCount].lpData = szModemString; <br>dwElementCount++; <br>} <br> <br>// internet address <br>else if (IsEqualGUID(&amp;guidAddressType, &amp;DPAID_INet)) <br>{ <br>// add an IP address chunk <br>GetDlgItemText(hWnd, IDC_ADDRESSEDIT, szIPAddressString, NAMEMAX); <br>addressElements[dwElementCount].guidDataType = DPAID_INet; <br>addressElements[dwElementCount].dwDataSize = lstrlen(szIPAddressString) + 1; <br>addressElements[dwElementCount].lpData = szIPAddressString; <br>dwElementCount++; <br>} <br>} <br> <br>// bail if no address data is available <br>if (dwElementCount == 1) <br>return (DPERR_GENERIC); <br> <br>// see how much room is needed to store this address <br>hr = lpDPlayLobby-&gt;lpVtbl-&gt;CreateCompoundAddress(lpDPlayLobby, <br>addressElements, dwElementCount, <br>NULL, &amp;dwAddressSize); <br>if (hr != DPERR_BUFFERTOOSMALL) <br>goto Failure; <br> <br>// allocate space <br>lpAddress = GlobalAllocPtr(GHND, dwAddressSize); <br>if (lpAddress == NULL) <br>{ <br>hr = DPERR_NOMEMORY; <br>goto Failure; <br>} <br> <br>// create the address <br>hr = lpDPlayLobby-&gt;lpVtbl-&gt;CreateCompoundAddress(lpDPlayLobby, <br>addressElements, dwElementCount, <br>lpAddress, &amp;dwAddressSize); <br>if FAILED(hr) <br>goto Failure; <br> <br>// return the address info <br>*lplpAddress = lpAddress; <br>*lpdwAddressSize = dwAddressSize; <br> <br>return (DP_OK); <br> <br>Failure: <br>if (lpAddress) <br>GlobalFreePtr(lpAddress); <br> <br>return (hr); <br>} <br> <br>// --------------------------------------------------------------------------- <br>// RunApplication <br>// --------------------------------------------------------------------------- <br>// Description:             Wrapper for the IDirectPlayLobby::RunApplication() method. <br>// Arguments: <br>//  LPDIRECTPLAYLOBBY2A[in] DirectPlay Lobby interface to use <br>//  LPGUID[in] GUID of application to launch <br>//  LPGUID[in] GUID of session to host with <br>//  LPSTR[in] GUID of service provider to connect with <br>//  LPVOID[in] service-provider address to connect to <br>//  DWORD[in] length of address <br>//  LPSTR[in] name of session to host <br>//  LPSTR[in] name of our player <br>//  BOOL[in] TRUE to host session, FALSE to join <br>// Returns: <br>//  HRESULTany error running the application <br>HRESULT RunApplication(LPDIRECTPLAYLOBBY2A lpDPlayLobby, <br>   LPGUID lpguidApplication, <br>   LPGUID lpguidInstance, <br>   LPGUID lpguidServiceProvider, <br>   LPVOID lpAddress, <br>   DWORD  dwAddressSize, <br>   LPSTR  lpszSessionName, <br>   LPSTR  lpszPlayerName, <br>   BOOL  bHostSession) <br>{ <br>DWORDappID; <br>DPSESSIONDESC2sessionInfo; <br>DPNAMEplayerName; <br>DPLCONNECTIONconnectInfo; <br>HRESULThr; <br> <br>if (lpDPlayLobby == NULL) <br>return (DPERR_NOINTERFACE); <br> <br>// fill out session description <br>ZeroMemory(&amp;sessionInfo, sizeof(DPSESSIONDESC2)); <br>    sessionInfo.dwSize = sizeof(DPSESSIONDESC2);// Size of structure <br>sessionInfo.dwFlags = 0;// DPSESSION_xxx flags <br>    sessionInfo.guidInstance = *lpguidInstance;// ID for the session instance <br>    sessionInfo.guidApplication = *lpguidApplication;// GUID of the DirectPlay application. <br>    sessionInfo.dwMaxPlayers = 0;// Maximum # players allowed in session <br>    sessionInfo.dwCurrentPlayers = 0;// Current # players in session (read only) <br>sessionInfo.lpszSessionNameA = lpszSessionName;// ANSI name of the session <br>sessionInfo.lpszPasswordA = NULL;// ANSI password of the session (optional) <br>sessionInfo.dwReserved1 = 0;// Reserved for future MS use. <br>    sessionInfo.dwReserved2 = 0; <br>    sessionInfo.dwUser1 = 0;// For use by the application <br>    sessionInfo.dwUser2 = 0; <br>    sessionInfo.dwUser3 = 0; <br>    sessionInfo.dwUser4 = 0; <br> <br>// fill out player name <br>ZeroMemory(&amp;playerName, sizeof(DPNAME)); <br>playerName.dwSize = sizeof(DPNAME);// Size of structure <br>    playerName.dwFlags = 0;// Not used. Must be zero. <br>playerName.lpszShortNameA = lpszPlayerName;// ANSI short or friendly name <br>playerName.lpszLongNameA = lpszPlayerName;// ANSI long or formal name <br> <br>// fill out connection description <br>ZeroMemory(&amp;connectInfo, sizeof(DPLCONNECTION)); <br>connectInfo.dwSize = sizeof(DPLCONNECTION);// Size of this structure <br>if (bHostSession) <br>connectInfo.dwFlags = DPLCONNECTION_CREATESESSION; // Create a new session <br>else <br>connectInfo.dwFlags = DPLCONNECTION_JOINSESSION; // Join existing session <br>connectInfo.lpSessionDesc = &amp;sessionInfo;// Pointer to session desc to use on connect <br>connectInfo.lpPlayerName = &amp;playerName;// Pointer to Player name structure <br>connectInfo.guidSP = *lpguidServiceProvider;// GUID of the DPlay SP to use <br>connectInfo.lpAddress = lpAddress;// Address for service provider <br>connectInfo.dwAddressSize = dwAddressSize;// Size of address data <br> <br>// launch and connect the game <br>hr = lpDPlayLobby-&gt;lpVtbl-&gt;RunApplication(lpDPlayLobby, <br>0,// Flags <br>&amp;appID,// App ID <br>&amp;connectInfo,// Connection data <br>NULL);// Connect event <br>return (hr); <br>} <br> <br>// --------------------------------------------------------------------------- <br>// LaunchDirectPlayApplication <br>// --------------------------------------------------------------------------- <br>// Description:             Gathers information from the dialog and runs the application. <br>// Arguments: <br>//  HWND                    [in] Window handle. <br>//  LPDIRECTPLAYLOBBY2A      [in] DirectPlay Lobby interface to use <br>// Returns: <br>//  Nothing <br>void LaunchDirectPlayApplication(HWND hWnd, LPDIRECTPLAYLOBBY2A lpDPlayLobby) <br>{ <br>GUIDguidApplication, guidSession, guidServiceProvider; <br>LPSTRlpPlayerName, lpSessionName; <br>LPVOIDlpAddress = NULL; <br>DWORDdwAddressSize = 0; <br>CHARszPlayerName[NAMEMAX], szSessionName[NAMEMAX]; <br>LRESULTiHost; <br>HRESULThr; <br> <br>SetDlgItemText(hWnd, IDC_STATUSEDIT, "Launching..."); <br> <br>// get guid of application to launch <br>hr = GetComboBoxGuid(hWnd, IDC_APPCOMBO, &amp;guidApplication); <br>if FAILED(hr) <br>goto Failure; <br> <br>// get guid of service provider to use <br>hr = GetComboBoxGuid(hWnd, IDC_SPCOMBO, &amp;guidServiceProvider); <br>if FAILED(hr) <br>goto Failure; <br> <br>// get address to use with this service provider <br>hr = CreateAddress(hWnd, lpDPlayLobby, &amp;guidServiceProvider, <br>   &amp;lpAddress, &amp;dwAddressSize); <br>// ignore the error because lpAddress will just be null <br> <br>// get guid of session to create. <br>guidSession = MY_SESSION_GUID; <br> <br>// get name of our player <br>GetDlgItemText(hWnd, IDC_PLAYEREDIT, szPlayerName, NAMEMAX); <br>lpPlayerName = szPlayerName; <br> <br>// get host vs. join flag <br>iHost = SendDlgItemMessage(hWnd, IDC_HOSTRADIO, BM_GETCHECK, (WPARAM) 0, 0); <br>if (iHost == BST_CHECKED) <br>{ <br>iHost = TRUE;// we are hosting a session <br> <br>// get name of session <br>GetDlgItemText(hWnd, IDC_SESSIONEDIT, szSessionName, NAMEMAX); <br>lpSessionName = szSessionName; <br>} <br>else <br>{ <br>iHost = FALSE;// we are joining an existing session <br>lpSessionName = NULL;// don't need a session name if we are joining <br>} <br> <br>// launch the application <br>hr = RunApplication(lpDPlayLobby, <br>&amp;guidApplication, <br>&amp;guidSession, <br>&amp;guidServiceProvider, <br>lpAddress, dwAddressSize, <br>lpSessionName, lpPlayerName, <br>iHost); <br>if FAILED(hr) <br>goto Failure; <br> <br>SetDlgItemText(hWnd, IDC_STATUSEDIT, "Launch successful"); <br> <br>if (lpAddress) <br>GlobalFreePtr(lpAddress); <br>return; <br> <br>Failure: <br>if (lpAddress) <br>GlobalFreePtr(lpAddress); <br> <br>SetDlgItemText(hWnd, IDC_STATUSEDIT, "Launch failed"); <br> <br>return; <br>} <br> <br>// --------------------------------------------------------------------------- <br>// GetComboBoxGuid <br>// --------------------------------------------------------------------------- <br>// Description:             Returns GUID stored with a combo box item <br>// Arguments: <br>//  HWND                    [in]  Window handle. <br>//  LONG[in]  Dialog box item ID of combo box <br>//  LPGUID[out] GUID stored with item in combo box <br>// Returns: <br>//  HRESULTany error getting the GUID <br>HRESULT GetComboBoxGuid(HWND hWnd, LONG iDialogItem, LPGUID lpguidReturn) <br>{ <br>LONGiIndex; <br> <br>// get index of selected item <br>iIndex = SendDlgItemMessage(hWnd, iDialogItem, CB_GETCURSEL, <br>(WPARAM) 0, (LPARAM) 0); <br>if (iIndex == CB_ERR) <br>return (DPERR_GENERIC); <br> <br>// get data associated with this item <br>iIndex = SendDlgItemMessage(hWnd, iDialogItem, CB_GETITEMDATA, <br>(WPARAM) iIndex, (LPARAM) 0); <br>if ((iIndex == CB_ERR) || (iIndex == 0)) <br>return (DPERR_GENERIC); <br> <br>// data is a pointer to a guid <br>*lpguidReturn = *((LPGUID) iIndex); <br> <br>return (DP_OK); <br>} <br> <br>// --------------------------------------------------------------------------- <br>// EnumModemAddress <br>// --------------------------------------------------------------------------- <br>// Description:             Enumeration callback called by DirectPlayLobby. <br>//Enumerates the DirectPlay address chunks. If the <br>//chunk contains modem strings, add them to the control. <br>// Arguments: <br>//  REFGUID                 [in] GUID of the address type <br>//  DWORD[in] size of chunk <br>//  LPVOID    [in] pointer to chunk <br>//  LPVOID    [in] user-defined context <br>// Returns: <br>//  BOOLFALSE to stop enumerating after the first callback <br>BOOL FAR PASCAL EnumModemAddress(REFGUID lpguidDataType, DWORD dwDataSize, <br>LPCVOID lpData, LPVOID lpContext) <br>{ <br>HWNDhWnd = (HWND) lpContext; <br>LPSTRlpszStr = (LPSTR) lpData; <br> <br>// modem <br>if (IsEqualGUID(lpguidDataType, &amp;DPAID_Modem)) <br>{ <br>// loop over all strings in list <br>while (lstrlen(lpszStr)) <br>{ <br>// store modem name in combo box <br>SendDlgItemMessage(hWnd, IDC_ADDRESSCOMBO, CB_ADDSTRING, 0, (LPARAM) lpszStr); <br> <br>// skip to next string <br>lpszStr += lstrlen(lpszStr) + 1; <br>} <br>} <br> <br>return (TRUE); <br>} <br> <br>// --------------------------------------------------------------------------- <br>// FillModemComboBox <br>// --------------------------------------------------------------------------- <br>// Description:             Fills combo box with modem names <br>// Arguments: <br>//  HWND                    [in]  Window handle. <br>//  LPDIRECTPLAYLOBBY2A     [in]  DirectPlay Lobby interface to use <br>//  LPGUID[out] GUID of service provider to use <br>// Returns: <br>//  HRESULTany error <br>HRESULT FillModemComboBox(HWND hWnd, LPDIRECTPLAYLOBBY2A lpDPlayLobby, LPGUID lpguidServiceProvider) <br>{ <br>LPDIRECTPLAYlpDPlay1 = NULL; <br>LPDIRECTPLAY3AlpDPlay3A = NULL; <br>LPVOIDlpAddress = NULL; <br>DWORDdwAddressSize = 0; <br>HRESULThr; <br> <br>// get a DirectPlay interface for this service provider <br>hr = DirectPlayCreate(lpguidServiceProvider, &amp;lpDPlay1, NULL); <br>if FAILED(hr) <br>goto Failure; <br> <br>// query for an ANSI DirectPlay3 interface <br>hr = lpDPlay1-&gt;lpVtbl-&gt;QueryInterface(lpDPlay1, &amp;IID_IDirectPlay3A, (LPVOID *) &amp;lpDPlay3A); <br>if FAILED(hr) <br>goto Failure; <br> <br>// get size of player address for player zero <br>hr = lpDPlay3A-&gt;lpVtbl-&gt;GetPlayerAddress(lpDPlay3A, DPID_ALLPLAYERS, NULL, &amp;dwAddressSize); <br>if (hr != DPERR_BUFFERTOOSMALL) <br>goto Failure; <br> <br>// make room for it <br>lpAddress = GlobalAllocPtr(GHND, dwAddressSize); <br>if (lpAddress == NULL) <br>{ <br>hr = DPERR_NOMEMORY; <br>goto Failure; <br>} <br> <br>// get the address <br>hr = lpDPlay3A-&gt;lpVtbl-&gt;GetPlayerAddress(lpDPlay3A, DPID_ALLPLAYERS, lpAddress, &amp;dwAddressSize); <br>if FAILED(hr) <br>goto Failure; <br> <br>// get modem strings from address and put them in the combo box <br>hr = lpDPlayLobby-&gt;lpVtbl-&gt;EnumAddress(lpDPlayLobby, EnumModemAddress,  <br> lpAddress, dwAddressSize, hWnd); <br>if FAILED(hr) <br>goto Failure; <br> <br>// select first item in list <br>SendDlgItemMessage(hWnd, IDC_ADDRESSCOMBO, CB_SETCURSEL, (WPARAM) 0, 0); <br> <br>Failure: <br>if (lpDPlay1) <br>lpDPlay1-&gt;lpVtbl-&gt;Release(lpDPlay1); <br>if (lpDPlay3A) <br>lpDPlay3A-&gt;lpVtbl-&gt;Release(lpDPlay3A); <br>if (lpAddress) <br>GlobalFreePtr(lpAddress); <br> <br>return (hr); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
