<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DIFF1.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3033"></a>DIFF1.CPP</h2>
<pre><code>/************************************************************************** <br> <br>    DIFF1.CPP - DirectInput simple force feedback sample 1 <br> <br>    Demonstrates an application which plays a force on the joystick <br>    in response to mouse clicks. <br> <br> **************************************************************************/ <br>/************************************************************************** <br> <br>    (C) Copyright 1997 Microsoft Corp.  All rights reserved. <br> <br>    You have a royalty-free right to use, modify, reproduce and <br>    distribute the Sample Files (and/or any modified version) in <br>    any way you find useful, provided that you agree that <br>    Microsoft has no warranty obligations or liability for any <br>    Sample Application Files which are modified. <br> <br> **************************************************************************/ <br> <br>#include "diff1.h" <br>#include &lt;windowsx.h&gt; <br>#include &lt;dinput.h&gt; <br>#include &lt;math.h&gt; <br> <br>/**************************************************************************** <br> * <br> *      Global variables <br> * <br> ****************************************************************************/ <br> <br>char c_szClassName[] = "DIFF1"; <br> <br>HINSTANCE       g_hinst;                /* My instance handle */ <br>BOOL            g_fPaused = TRUE;       /* Should I be paused? */ <br>int             g_xForce;               /* Coordinates of the active force */ <br>int             g_yForce; <br>int             g_cxClient;             /* Client window size */ <br>int             g_cyClient; <br> <br>/**************************************************************************** <br> * <br> *      DirectInput globals <br> * <br> ****************************************************************************/ <br> <br>LPDIRECTINPUT           g_pdi; <br>LPDIRECTINPUTDEVICE2    g_pJoystick; <br>LPDIRECTINPUTEFFECT     g_pEffect; <br> <br>/**************************************************************************** <br> * <br> *      Complain <br> * <br> *      Whine and moan. <br> * <br> ****************************************************************************/ <br> <br>void <br>Complain( <br>    HWND hwndOwner, <br>    HRESULT hr, <br>    LPCSTR pszMessage <br>) <br>{ <br>    MessageBox(hwndOwner, pszMessage, "DirectInput Sample", MB_OK); <br>} <br> <br>/**************************************************************************** <br> * <br> *      EnumFFJoysticksCallback <br> * <br> *      Called once for each enumerated force feedback joystick. <br> * <br> *      If we find one, create a device interface on it so we can <br> *      play with it. <br> * <br> *      Parameters: <br> * <br> *          pinst <br> * <br> *              Pointer to DIDEVICEINSTANCE structure which describes <br> *              the device. <br> * <br> *          lpvContext <br> * <br> *              The pointer we passed to EnumDevices which we don't <br> *              use for anything. <br> * <br> ****************************************************************************/ <br> <br>BOOL CALLBACK <br>EnumFFJoysticksCallback(LPCDIDEVICEINSTANCE pinst, LPVOID lpvContext) <br>{ <br>    HRESULT hr; <br>    LPDIRECTINPUTDEVICE pdev; <br>    LPDIRECTINPUTDEVICE2 pdev2; <br> <br>    /* <br>     *  Obtain an interface to the enumerated force feedback joystick. <br>     * <br>     *  Parameters: <br>     * <br>     *      pinst-&gt;guidInstance <br>     * <br>     *          The instance GUID for the device we wish to access. <br>     * <br>     *      &amp;pdev <br>     * <br>     *          Receives pointer to the IDirectInputDevice interface <br>     *          that was created. <br>     * <br>     *      NULL <br>     * <br>     *          We do not use OLE aggregation, so this parameter <br>     *          must be NULL. <br>     * <br>     */ <br>    hr = g_pdi-&gt;CreateDevice(pinst-&gt;guidInstance, &amp;pdev, NULL); <br> <br>    /* <br>     *  If it failed, then we can't use this joystick for some <br>     *  bizarre reason.  (Maybe the user unplugged it while we <br>     *  were in the middle of enumerating it.) <br>     * <br>     *  Continue enumerating; maybe we'll have better luck with the <br>     *  next one. <br>     */ <br>    if (FAILED(hr)) { <br>        return DIENUM_CONTINUE; <br>    } <br> <br>    /* <br>     *  We really want to use IDirectInputDevice2, so move there <br>     *  once and for all. <br>     * <br>     *  Parameters: <br>     * <br>     *      IID_IDirectInputDevice2 <br>     * <br>     *          The interface we are requesting. <br>     * <br>     *      &amp;pdev2 <br>     * <br>     *          Receives a pinter to the new interface. <br>     */ <br> <br>    hr = pdev-&gt;QueryInterface(IID_IDirectInputDevice2, <br>                              (LPVOID *)&amp;pdev2); <br> <br>    /* <br>     *  Whether or not the QueryInterface worked, we are finished <br>     *  with the old interface. <br>     */ <br>    pdev-&gt;Release(); <br> <br>    /* <br>     *  If the QueryInterface failed, then something weird happened. <br>     *  Maybe the currently-installed version of DirectInput doesn't <br>     *  support force feedback. <br>     * <br>     *  Continue enumerating; maybe we'll have better luck with the <br>     *  next one. <br>     */ <br>    if (FAILED(hr)) { <br>        return DIENUM_CONTINUE; <br>    } <br> <br>    /* <br>     *  We successfully created an IDirectInputDevice2. <br>     * <br>     *  No point in looking for another one. <br>     */ <br>    g_pJoystick = pdev2; <br>    return DIENUM_STOP; <br> <br>} <br> <br>/**************************************************************************** <br> * <br> *      DIInit <br> * <br> *      Initialize the DirectInput variables. <br> * <br> *      This entails the following four functions: <br> * <br> *          DirectInputCreate <br> *          IDirectInput::EnumDevices           (to find a joystick) <br> *          IDirectInputDevice2::SetDataFormat <br> *          IDirectInputDevice2::SetCooperativeLevel <br> *          IDirectInputDevice2::SetProperty    (to disable auto-center) <br> *          IDirectInputDevice2::CreateEffect <br> * <br> ****************************************************************************/ <br> <br>BOOL <br>DIInit(HWND hwnd) <br>{ <br>    HRESULT hr; <br> <br>    /* <br>     *  Register with the DirectInput subsystem and get a pointer <br>     *  to a IDirectInput interface we can use. <br>     * <br>     *  Parameters: <br>     * <br>     *      g_hinst <br>     * <br>     *          Instance handle to our application or DLL. <br>     * <br>     *      DIRECTINPUT_VERSION <br>     * <br>     *          The version of DirectInput we were designed for. <br>     *          We take the value from the &lt;dinput.h&gt; header file. <br>     * <br>     *      &amp;g_pdi <br>     * <br>     *          Receives pointer to the IDirectInput interface <br>     *          that was created. <br>     * <br>     *      NULL <br>     * <br>     *          We do not use OLE aggregation, so this parameter <br>     *          must be NULL. <br>     * <br>     */ <br>    hr = DirectInputCreate(g_hinst, DIRECTINPUT_VERSION, &amp;g_pdi, NULL); <br> <br>    if (FAILED(hr)) { <br>        Complain(hwnd, hr, "DirectInputCreate"); <br>        return FALSE; <br>    } <br> <br>    /* <br>     *  Look for a force feedback joystick we can use for this <br>     *  sample program. <br>     * <br>     *  Parameters: <br>     * <br>     *      DIDEVTYPE_JOYSTICK <br>     * <br>     *          Enumerate only joystick devices. <br>     * <br>     *      EnumFFJoysticksCallback <br>     * <br>     *          Callback function that is called once for <br>     *          each force feedback joystick found. <br>     * <br>     *      NULL <br>     * <br>     *          Context which is passed to the callback function. <br>     * <br>     *      DIEDFL_ATTACHEDONLY | DIEDFL_FORCEFEEDBACK <br>     * <br>     *          Flags that further restrict the enumeration. <br>     * <br>     *          We are interested only in attached joysticks <br>     *          which support force feedback. <br>     */ <br>    hr = g_pdi-&gt;EnumDevices(DIDEVTYPE_JOYSTICK, <br>                            EnumFFJoysticksCallback, <br>                            NULL, <br>                            DIEDFL_ATTACHEDONLY | DIEDFL_FORCEFEEDBACK); <br> <br>    if (g_pJoystick == NULL) { <br>        Complain(hwnd, hr, "Couldn't find any force feedback joysticks"); <br>        return FALSE; <br>    } <br> <br>    /* <br>     *  Set the data format to "simple joystick format". <br>     * <br>     *  A data format specifies which controls on a device we <br>     *  are interested in, and how they should be reported. <br>     * <br>     *  This tells DirectInput that we will be passing a <br>     *  DIJOYSTATE structure to IDirectInputDevice2::GetDeviceState. <br>     *  Even though we won't actually do it in this sample. <br>     *  But setting the data format is important so that <br>     *  the DIJOFS_* values work properly. <br>     * <br>     *  Parameters: <br>     * <br>     *      c_dfDIJoystick <br>     * <br>     *          Predefined data format which describes <br>     *          a DIJOYSTATE structure. <br>     */ <br>    hr = g_pJoystick-&gt;SetDataFormat(&amp;c_dfDIJoystick); <br> <br>    if (FAILED(hr)) { <br>        Complain(hwnd, hr, "SetDataFormat"); <br>        return FALSE; <br>    } <br> <br> <br>    /* <br>     *  Set the cooperativity level to let DirectInput know how <br>     *  this device should interact with the system and with other <br>     *  DirectInput applications. <br>     * <br>     *  Parameters: <br>     * <br>     *      DISCL_EXCLUSIVE <br>     * <br>     *          Exclusive access is required in order to perform <br>     *          force feedback. <br>     * <br>     *      DISCL_FOREGROUND <br>     * <br>     *          If the user switches away from our application, <br>     *          automatically release the joystick back to the system. <br>     * <br>     */ <br>    hr = g_pJoystick-&gt;SetCooperativeLevel(hwnd, <br>                                          DISCL_EXCLUSIVE | DISCL_FOREGROUND); <br> <br>    if (FAILED(hr)) { <br>        Complain(hwnd, hr, "SetCooperativeLevel"); <br>        return FALSE; <br>    } <br> <br>    /* <br>     *  Since we will be playing force feedback effects, <br>     *  we should disable the auto-centering spring. <br>     * <br>     *  DIPROPDWORD::diph.dwSize <br>     * <br>     *      Must be sizeof(DIPROPDWORD) <br>     * <br>     *  DIPROPDWORD::diph.dwHeaderSize <br>     * <br>     *      Must be sizeof(DIPROPHEADER) <br>     * <br>     *  DIPROPDWORD::diph.dwObj <br>     * <br>     *      Must be zero for device properties. <br>     * <br>     *  DIPROPDWORD::diph.dwHow <br>     * <br>     *      DIPH_DEVICE for device properties. <br>     * <br>     *  DIPROPDWORD::dwData <br>     * <br>     *      FALSE to disable auto-centering. <br>     */ <br>    DIPROPDWORD dipdw; <br>    dipdw.diph.dwSize = sizeof(DIPROPDWORD); <br>    dipdw.diph.dwHeaderSize = sizeof(DIPROPHEADER); <br>    dipdw.diph.dwObj = 0; <br>    dipdw.diph.dwHow = DIPH_DEVICE; <br>    dipdw.dwData = FALSE; <br> <br>    hr = g_pJoystick-&gt;SetProperty(DIPROP_AUTOCENTER, &amp;dipdw.diph); <br> <br>    if (FAILED(hr)) { <br>        Complain(hwnd, hr, "SetProperty(Autocenter)"); <br>        return FALSE; <br>    } <br> <br>    /* <br>     *  This application needs only one effect:  Applying raw forces. <br>     * <br>     *  DIEFFECT::dwSize <br>     * <br>     *          Must be sizeof(DIEFFECT). <br>     * <br>     *  DIEFFECT::dwFlags <br>     * <br>     *          DIEFF_CARTESIAN because we will be applying X and Y <br>     *          forces, not angles. <br>     * <br>     *          DIEFF_OBJECTOFFSETS because we will be using the <br>     *          DIJOFS_* macros to specify the axes. <br>     * <br>     *  DIEFFECT::dwDuration <br>     * <br>     *          INFINITE because we want the force to continue playing <br>     *          indefinitely until we explicitly change it. <br>     * <br>     *  DIEFFECT::dwSamplePeriod <br>     * <br>     *          0 means "use default".  Using a custom sample period <br>     *          is a special effect which we don't particularly care <br>     *          about. <br>     * <br>     *  DIEFFECT::dwGain <br>     * <br>     *          DI_FFNOMINALMAX to play all values at exactly the <br>     *          strength we specify. <br>     * <br>     *  DIEFFECT::dwTriggerButton <br>     * <br>     *          DIEB_NOTRIGGER because we don't want this effect <br>     *          to be associated with a trigger. <br>     * <br>     *  DIEFFECT::dwTriggerRepeatInterval <br>     * <br>     *          0 because there no trigger. <br>     * <br>     *  DIEFFECT::cAxes <br>     * <br>     *          2 because we have two axes, X and Y. <br>     * <br>     *  DIEFFECT::rgdwAxes <br>     * <br>     *          Points to an array which identifies the two axes <br>     *          we want to talk to, namely X and Y. <br>     * <br>     *  DIEFFECT::rglDirection <br>     * <br>     *          Points to an array which gives the direction in <br>     *          which the force should be applied. <br>     *          Nothing yet. <br>     * <br>     *  DIEFFECT::lpEnvelope <br>     * <br>     *          NULL because we don't want to apply an envelope <br>     *          to the effect. <br>     * <br>     *  DIEFFECT::cbTypeSpecificParameters <br>     *  DIEFFECT::lpvTypeSpecificParameters <br>     * <br>     *          Size of and pointer to type-specific parameters. <br>     *          For a constant force effect, we need a <br>     *          DICONSTANTFORCE structure. <br>     */ <br> <br>    DIEFFECT eff; <br>    DWORD rgdwAxes[2] = { DIJOFS_X, DIJOFS_Y }; <br>    LONG rglDirection[2] = { 0, 0 }; <br>    DICONSTANTFORCE cf = { 0 }; <br> <br>    eff.dwSize = sizeof(DIEFFECT); <br>    eff.dwFlags = DIEFF_CARTESIAN | DIEFF_OBJECTOFFSETS; <br>    eff.dwDuration = INFINITE; <br>    eff.dwSamplePeriod = 0; <br>    eff.dwGain = DI_FFNOMINALMAX; <br>    eff.dwTriggerButton = DIEB_NOTRIGGER; <br>    eff.dwTriggerRepeatInterval = 0; <br>    eff.cAxes = 2; <br>    eff.rgdwAxes = rgdwAxes; <br>    eff.rglDirection = rglDirection; <br>    eff.lpEnvelope = 0; <br>    eff.cbTypeSpecificParams = sizeof(DICONSTANTFORCE); <br>    eff.lpvTypeSpecificParams = &amp;cf; <br> <br>    /* <br>     *  Now create this effect we prepared. <br>     * <br>     *  Parameters: <br>     * <br>     *      GUID_ConstantForce <br>     * <br>     *          We are playing a raw force, plain and simple. <br>     * <br>     *      &amp;eff <br>     * <br>     *          The DIEFFECT structure that describes it. <br>     * <br>     *      &amp;g_pEffect <br>     * <br>     *          Receives pointer to the IDirectInputEffect interface <br>     *          that was created. <br>     * <br>     *      NULL <br>     * <br>     *          We do not use OLE aggregation, so this parameter <br>     *          must be NULL. <br>     * <br>     */ <br>    hr = g_pJoystick-&gt;CreateEffect(GUID_ConstantForce, <br>                                   &amp;eff, <br>                                   &amp;g_pEffect, <br>                                   NULL); <br> <br>    if (FAILED(hr)) { <br>        Complain(hwnd, hr, "CreateEffect"); <br>        return FALSE; <br>    } <br> <br>    return TRUE; <br> <br>} <br> <br>/**************************************************************************** <br> * <br> *      DITerm <br> * <br> *      Terminate our usage of DirectInput. <br> * <br> ****************************************************************************/ <br> <br>void <br>DITerm(void) <br>{ <br> <br>    /* <br>     *  Destroy any lingering IDirectInputEffect object. <br>     */ <br>    if (g_pEffect) { <br> <br>        g_pEffect-&gt;Release(); <br>        g_pEffect = NULL; <br>    } <br> <br>    /* <br>     *  Destroy any lingering IDirectInputDevice object. <br>     */ <br>    if (g_pJoystick) { <br> <br>        /* <br>         *  Cleanliness is next to godliness.  Unacquire the device <br>         *  one last time just in case we got really confused and tried <br>         *  to exit while the device is still acquired. <br>         */ <br>        g_pJoystick-&gt;Unacquire(); <br> <br>        g_pJoystick-&gt;Release(); <br>        g_pJoystick = NULL; <br>    } <br> <br>    /* <br>     *  Destroy any lingering IDirectInput object. <br>     */ <br>    if (g_pdi) { <br>        g_pdi-&gt;Release(); <br>        g_pdi = NULL; <br>    } <br> <br>} <br> <br>/**************************************************************************** <br> * <br> *      joySetForcesXY <br> * <br> *      Apply the X and Y forces to the effect we prepared. <br> * <br> *      Parameters: <br> * <br> *          peff <br> * <br> *              Pointer to a constant-force LPDIRECTINPUEFFECT <br> *              which we will push in the appropriate direction <br> *              with the appropriate amount of force. <br> * <br> *          x, y <br> * <br> *              X and Y forces to apply, respectively, in the <br> *              range -DI_FFNOMINALMAX to +DI_FFNOMINALMAX. <br> * <br> ****************************************************************************/ <br> <br>HRESULT <br>joySetForcesXY(LPDIRECTINPUTEFFECT peff, int x, int y) <br>{ <br>    HRESULT hres; <br> <br>    /* <br>     *  Modifying an effect is basically the same as creating <br>     *  a new one, except you need only specify the parameters <br>     *  you are modifying; the rest are left alone. <br>     * <br>     *  DIEFFECT::dwSize <br>     * <br>     *          Must be sizeof(DIEFFECT). <br>     * <br>     *  DIEFFECT::dwFlags <br>     * <br>     *          DIEFF_CARTESIAN because we will be applying X and Y <br>     *          forces, not angles. <br>     * <br>     *          DIEFF_OBJECTOFFSETS because we used the <br>     *          DIJOFS_* macros to specify the axes. <br>     * <br>     *  DIEFFECT::cAxes <br>     * <br>     *          2 because we have two axes, X and Y. <br>     * <br>     *  DIEFFECT::rglDirection <br>     * <br>     *          Points to an array which gives the direction in <br>     *          which the force should be applied. <br>     * <br>     *          We use the x and y values directly to specify <br>     *          the direction.  Note that DirectInput currently <br>     *          uses these values to specify direction only, not <br>     *          magnitude.  Magnitude needs to be specified <br>     *          elsewhere.  (See below.) <br>     * <br>     *  DIEFFECT::cbTypeSpecificParameters <br>     *  DIEFFECT::lpvTypeSpecificParameters <br>     * <br>     *          Size of and pointer to type-specific parameters. <br>     *          For a constant force effect, we need a <br>     *          DICONSTANTFORCE structure. <br>     * <br>     *  DICONSTANTFORCE::lMagnitude <br>     * <br>     *          The total magnitude of the force, which is <br>     *          the hypotenuse of x and y. <br>     */ <br> <br>    LONG rglDirection[2] = { x, y }; <br> <br>    DICONSTANTFORCE cf; <br>    cf.lMagnitude = (DWORD)sqrt((double)x * (double)x + <br>                                (double)y * (double)y); <br> <br>    DIEFFECT eff; <br>    eff.dwSize = sizeof(DIEFFECT); <br>    eff.dwFlags = DIEFF_CARTESIAN | DIEFF_OBJECTOFFSETS; <br>    eff.cAxes = 2; <br>    eff.rglDirection = rglDirection; <br>    eff.lpEnvelope = 0; <br>    eff.cbTypeSpecificParams = sizeof(DICONSTANTFORCE); <br>    eff.lpvTypeSpecificParams = &amp;cf; <br> <br>    /* <br>     *  Now set the new parameters and start the effect immediately. <br>     * <br>     *  Parameters: <br>     * <br>     *      &amp;eff <br>     * <br>     *          The DIEFFECT structure that describes the new parameters. <br>     * <br>     *      DIEP_DIRECTION <br>     *      DIEP_TYPESPECIFICPARAMS <br>     * <br>     *          We want to change the direction and the DICONSTANTFORCE. <br>     * <br>     *      DIEP_START <br>     * <br>     *          Start the effect as soon as the parameters are downloaded. <br>     */ <br>    hres = peff-&gt;SetParameters(&amp;eff, DIEP_DIRECTION | <br>                                     DIEP_TYPESPECIFICPARAMS | <br>                                     DIEP_START); <br> <br>    return hres; <br>} <br> <br>/**************************************************************************** <br> * <br> *      Ex_SyncAcquire <br> * <br> *      Acquire or unacquire the joystick, depending on the the g_fPaused <br> *      flag.  This synchronizes the device with our internal view of <br> *      the world. <br> * <br> ****************************************************************************/ <br> <br>void <br>Ex_SyncAcquire(HWND hwnd) <br>{ <br>    if (g_fPaused) { <br>        if (g_pJoystick) { <br>            g_pJoystick-&gt;Unacquire(); <br>        } <br>    } else { <br>        if (g_pJoystick) g_pJoystick-&gt;Acquire(); <br>        if (g_pEffect) { <br>            g_pEffect-&gt;Start(1, 0); <br>        } <br>    } <br>} <br> <br>/**************************************************************************** <br> * <br> *      Ex_OnSize <br> * <br> *      The window client size changed.  Remember the new size. <br> * <br> ****************************************************************************/ <br> <br>void <br>Ex_OnSize(HWND hwnd, UINT state, int cx, int cy) <br>{ <br>    g_cxClient = cx; <br>    g_cyClient = cy; <br>} <br> <br>/**************************************************************************** <br> * <br> *      Ex_OnPaint <br> * <br> *      Paint our little target area thingie. <br> * <br> *      We draw a small crosshairs at the center (so the user knows <br> *      where the center is) <br> * <br> ****************************************************************************/ <br> <br>void <br>Ex_OnPaint(HWND hwnd) <br>{ <br>    PAINTSTRUCT ps; <br>    HDC hdc = BeginPaint(hwnd, &amp;ps); <br> <br>    if (hdc) { <br> <br>        HPEN hpenOld, hpenBlack; <br>        HBRUSH hbrOld, hbrBlack; <br>        int x, y; <br> <br>        /* <br>         *  Everything is scaled to the size of the window. <br>         */ <br> <br>        hpenBlack = GetStockPen(BLACK_PEN); <br>        hpenOld = SelectPen(hdc, hpenBlack); <br> <br>        x = g_cxClient / 2; <br>        y = g_cyClient / 2; <br> <br>        MoveToEx(hdc, x, y - 10, NULL); <br>        LineTo(hdc, x, y + 10 + 1); <br> <br>        MoveToEx(hdc, x - 10, y, NULL); <br>        LineTo(hdc, x + 10 + 1, y); <br> <br>        hbrBlack = GetStockBrush(BLACK_BRUSH); <br>        hbrOld = SelectBrush(hdc, hbrBlack); <br> <br>        x = MulDiv(g_cxClient, g_xForce + DI_FFNOMINALMAX, 2 * DI_FFNOMINALMAX); <br>        y = MulDiv(g_cyClient, g_yForce + DI_FFNOMINALMAX, 2 * DI_FFNOMINALMAX); <br> <br>        Ellipse(hdc, x-5, y-5, x+6, y+6); <br> <br>        SelectBrush(hdc, hbrOld); <br>        SelectPen(hdc, hpenOld); <br> <br>        EndPaint(hwnd, &amp;ps); <br>    } <br> <br>} <br> <br>/**************************************************************************** <br> * <br> *      Ex_CoordToForce <br> * <br> *      Convert a coordinate 0 &lt;= x &lt;= cx to a force value <br> *      in the range -DI_FFNOMINALMAX to +DI_FFNOMINALMAX. <br> * <br> ****************************************************************************/ <br> <br>int <br>Ex_CoordToForce(int x, int cx) <br>{ <br>    x = MulDiv(x, 2 * DI_FFNOMINALMAX, cx) - DI_FFNOMINALMAX; <br>    if (x &lt; -DI_FFNOMINALMAX) { <br>        x = -DI_FFNOMINALMAX; <br>    } <br>    if (x &gt; +DI_FFNOMINALMAX) { <br>        x = +DI_FFNOMINALMAX; <br>    } <br>    return x; <br>} <br> <br>/**************************************************************************** <br> * <br> *      Ex_OnMouseMove <br> * <br> *      If the mouse button is down, then change the direction of <br> *      the force to match the new location. <br> * <br> ****************************************************************************/ <br> <br>void <br>Ex_OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags) <br>{ <br>    if (keyFlags &amp; MK_LBUTTON) { <br>        g_xForce = Ex_CoordToForce(x, g_cxClient); <br>        g_yForce = Ex_CoordToForce(y, g_cyClient); <br> <br>        InvalidateRect(hwnd, 0, TRUE); <br>        UpdateWindow(hwnd); <br> <br>        joySetForcesXY(g_pEffect, g_xForce, g_yForce); <br> <br>    } <br>} <br> <br>/**************************************************************************** <br> * <br> *      Ex_OnLButtonDown <br> * <br> *      Capture the mouse so we can follow it, and start updating the <br> *      force information. <br> * <br> ****************************************************************************/ <br> <br>void <br>Ex_OnLButtonDown(HWND hwnd, BOOL fDblClk, int x, int y, UINT keyFlags) <br>{ <br>    SetCapture(hwnd); <br>    Ex_OnMouseMove(hwnd, x, y, MK_LBUTTON); <br>} <br> <br>/**************************************************************************** <br> * <br> *      Ex_OnLButtonUp <br> * <br> *      Stop capturing the mouse when the button goes up. <br> * <br> ****************************************************************************/ <br> <br>void <br>Ex_OnLButtonUp(HWND hwnd, int x, int y, UINT keyFlags) <br>{ <br>    ReleaseCapture(); <br>} <br> <br>/**************************************************************************** <br> * <br> *      Ex_WndProc <br> * <br> *      Window procedure for simple force feedback sample. <br> * <br> ****************************************************************************/ <br> <br>LRESULT CALLBACK <br>Ex_WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br> <br>    switch (msg) { <br> <br>    HANDLE_MSG(hwnd, WM_PAINT, Ex_OnPaint); <br>    HANDLE_MSG(hwnd, WM_MOUSEMOVE, Ex_OnMouseMove); <br>    HANDLE_MSG(hwnd, WM_LBUTTONDOWN, Ex_OnLButtonDown); <br>    HANDLE_MSG(hwnd, WM_LBUTTONUP, Ex_OnLButtonUp); <br>    HANDLE_MSG(hwnd, WM_SIZE, Ex_OnSize); <br> <br>    /* <br>     *  WM_ACTIVATE <br>     * <br>     *      Windows sends this message when the window becomes <br>     *      the active window or stops being the active window. <br>     * <br>     *      wParam = WA_INACTIVE if window is no longer active <br>     * <br>     *      wParam = WA_ACTIVE or WA_CLICKACTIVE if window is now active <br>     * <br>     *      If we are losing activation, then pause. <br>     * <br>     *      If we are gaining activation, then unpause. <br>     * <br>     *      After deciding whether we are paused or unpaused, <br>     *      tell DirectInput that we don't (paused) or do (unpaused) <br>     *      want access to the joystick. <br>     * <br>     */ <br>    case WM_ACTIVATE: <br>        g_fPaused = wParam == WA_INACTIVE; <br>        Ex_SyncAcquire(hwnd); <br>        break; <br> <br>    case WM_DESTROY: <br>        PostQuitMessage(0); <br>        break; <br> <br>    } <br> <br>    return DefWindowProc(hwnd, msg, wParam, lParam); <br>} <br> <br>/**************************************************************************** <br> * <br> *      AppInit <br> * <br> *      Set up everything the application needs to get started. <br> * <br> ****************************************************************************/ <br> <br>HWND <br>AppInit( <br>    HINSTANCE hinst, <br>    int nCmdShow <br>) <br>{ <br> <br>    /* <br>     *  Save instance handle for future reference. <br>     */ <br>    g_hinst = hinst; <br> <br>    /* <br>     *  Set up the window class. <br>     */ <br>    WNDCLASS wc; <br> <br>    wc.hCursor        = LoadCursor(0, IDC_ARROW); <br>    wc.hIcon          = LoadIcon(NULL, MAKEINTRESOURCE(IDI_APPLICATION)); <br>    wc.lpszMenuName   = NULL; <br>    wc.lpszClassName  = c_szClassName; <br>    wc.hbrBackground  = GetStockBrush(WHITE_BRUSH); <br>    wc.hInstance      = hinst; <br>    wc.style          = CS_HREDRAW | CS_VREDRAW; <br>    wc.lpfnWndProc    = Ex_WndProc; <br>    wc.cbClsExtra     = 0; <br>    wc.cbWndExtra     = 0; <br> <br>    if (!RegisterClass(&amp;wc)) { <br>        return NULL; <br>    } <br> <br>    HWND hwnd = CreateWindow( <br>                    c_szClassName,                  // Class name <br>                    "DIFF1 - Click in target to change force value", // Caption <br>                    WS_OVERLAPPEDWINDOW,            // Style <br>                    CW_USEDEFAULT, CW_USEDEFAULT,   // Position <br>                    CW_USEDEFAULT, CW_USEDEFAULT,   // Size <br>                    NULL,                           // No parent <br>                    NULL,                           // No menu <br>                    g_hinst,                        // inst handle <br>                    0                               // no params <br>                    ); <br> <br>    if (!DIInit(hwnd)) { <br>        DestroyWindow(hwnd); <br>        return NULL; <br>    } <br> <br>    ShowWindow(hwnd, nCmdShow); <br> <br>    return hwnd; <br>} <br> <br>/**************************************************************************** <br> * <br> *      WinMain <br> * <br> *      Application entry point. <br> * <br> ****************************************************************************/ <br> <br>int PASCAL <br>WinMain(HINSTANCE hinst, HINSTANCE hinstPrev, LPSTR szCmdLine, int nCmdShow) <br>{ <br>    MSG msg; <br>    msg.wParam = 0;         /* In case something goes horribly wrong */ <br> <br>    HWND hwnd = AppInit(hinst, nCmdShow); <br> <br>    if (hwnd) { <br> <br>        /* <br>         *  Standard message loop. <br>         */ <br>        while (GetMessage(&amp;msg, NULL, 0, 0)) { <br> <br>            TranslateMessage(&amp;msg); <br>            DispatchMessage(&amp;msg); <br>        } <br>    } <br> <br>    DITerm(); <br> <br>    return msg.wParam; <br> <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
