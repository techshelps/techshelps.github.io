<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DIALOG.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3059"></a>DIALOG.CPP</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved. <br> * <br> *  File:       dialog.cpp <br> *  Content:Creates a dialog to query the user for connection settings <br> *and establish a connection. <br> * <br> ***************************************************************************/ <br> <br>#define INITGUID <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;cguid.h&gt; <br> <br>#include "dpchat.h" <br>#include "resource.h" <br> <br>// constants <br>const DWORD MAXNAMELEN= 200;// max size of a session or player name <br>const UINTTIMERID= 1;// timer ID to use <br>const UINTTIMERINTERVAL= 1000;// timer interval <br> <br>// prototypes <br>BOOL CALLBACKConnectWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam); <br> <br>HRESULTCreateDirectPlayInterface(LPDIRECTPLAY3A *lplpDirectPlay3A ); <br>BOOL FAR PASCAL DirectPlayEnumConnectionsCallback(LPCGUID lpguidSP, <br>LPVOID lpConnection, DWORD dwConnectionSize, <br>LPCDPNAME lpName, DWORD dwFlags, LPVOID lpContext); <br>HRESULTDestroyDirectPlayInterface(HWND hWnd, LPDIRECTPLAY3A lpDirectPlay3A); <br>HRESULTHostSession(LPDIRECTPLAY3A lpDirectPlay3A, <br>LPSTR lpszSessionName, LPSTR lpszPlayerName, <br>LPDPLAYINFO lpDPInfo); <br>HRESULTJoinSession(LPDIRECTPLAY3A lpDirectPlay3A, <br>LPGUID lpguidSessionInstance, LPSTR lpszPlayerName, <br>LPDPLAYINFO lpDPInfo); <br>HRESULTEnumSessions(HWND hWnd, LPDIRECTPLAY3A lpDirectPlay3A); <br> <br>HRESULTGetConnection(HWND hWnd, LPVOID *lplpConnection); <br>voidDeleteConnectionList(HWND hWnd); <br>HRESULTGetSessionInstanceGuid(HWND hWnd, LPGUID lpguidSessionInstance); <br>voidSelectSessionInstance(HWND hWnd, LPGUID lpguidSessionInstance); <br>voidDeleteSessionInstanceList(HWND hWnd); <br>voidEnableDlgButton(HWND hDlg, int nIDDlgItem, BOOL bEnable); <br> <br>HRESULT ConnectUsingDialog(HINSTANCE hInstance, LPDPLAYINFO lpDPInfo) <br>{ <br>// ask user for connection settings <br>if (DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_CONNECTDIALOG), <br>   NULL, (DLGPROC) ConnectWndProc, (LPARAM) lpDPInfo)) <br>{ <br>return (DP_OK); <br>} <br>else <br>{ <br>return (DPERR_USERCANCEL); <br>} <br>} <br> <br>BOOL CALLBACK ConnectWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) <br>{ <br>static LPDPLAYINFOlpDPInfo; <br>static LPDIRECTPLAY3AlpDirectPlay3A; <br>static UINTidTimer; <br>GUIDguidSessionInstance; <br>charszSessionName[MAXNAMELEN]; <br>charszPlayerName[MAXNAMELEN]; <br>DWORDdwNameSize; <br>HRESULThr; <br>LPVOIDlpConnection = NULL; <br> <br>    switch(uMsg) <br>    { <br>    case WM_INITDIALOG: <br>        // save the connection info pointer <br>        lpDPInfo = (LPDPLAYINFO) lParam; <br>lpDirectPlay3A = NULL; <br> <br>// Create an IDirectPlay3 interface <br>hr = CreateDirectPlayInterface(&amp;lpDirectPlay3A); <br>if (FAILED(hr)) <br>goto SETUP_FAILURE; <br> <br>// set first item in the connections combo box <br>SendDlgItemMessage(hWnd, IDC_SPCOMBO, CB_ADDSTRING, (WPARAM) 0, (LPARAM) "&lt;Select a service provider&gt;"); <br>SendDlgItemMessage(hWnd, IDC_SPCOMBO, CB_SETITEMDATA, (WPARAM) 0, (LPARAM) 0); <br>SendDlgItemMessage(hWnd, IDC_SPCOMBO, CB_SETCURSEL, (WPARAM) 0, (LPARAM) 0); <br> <br>// put all the available connections in a combo box <br>lpDirectPlay3A-&gt;EnumConnections(&amp;DPCHAT_GUID, DirectPlayEnumConnectionsCallback, hWnd, 0); <br> <br>// setup initial button state <br>EnableDlgButton(hWnd, IDC_HOSTBUTTON, FALSE); <br>EnableDlgButton(hWnd, IDC_JOINBUTTON, FALSE); <br>break; <br> <br>SETUP_FAILURE: <br>MessageBox(NULL, "This application requires DirectX 5 or later.", NULL, MB_OK); <br>EndDialog(hWnd, FALSE); <br>break; <br> <br>    case WM_DESTROY: <br>// delete information stored along with the lists <br>DeleteConnectionList(hWnd); <br>DeleteSessionInstanceList(hWnd); <br>        break; <br> <br>case WM_TIMER: <br>// refresh the session list <br>hr = EnumSessions(hWnd, lpDirectPlay3A); <br>break; <br> <br>    case WM_COMMAND: <br>        switch(LOWORD(wParam)) <br>        { <br>case IDC_SPCOMBO: <br>switch (HIWORD(wParam)) <br>{ <br>case CBN_SELCHANGE: <br>// service provider changed, so rebuild display and <br>// delete any existing DirectPlay interface <br>KillTimer(hWnd, idTimer );  <br>hr = DestroyDirectPlayInterface(hWnd, lpDirectPlay3A); <br>lpDirectPlay3A = NULL; <br> <br>// get pointer to the selected connection <br>hr = GetConnection(hWnd, &amp;lpConnection); <br>if FAILED(hr) <br>goto SP_FAILURE; <br> <br>if (lpConnection) <br>{ <br>/* <br> * Create a new DPlay interface. <br> */ <br> <br>hr = CreateDirectPlayInterface( &amp;lpDirectPlay3A ); <br> <br>if ((FAILED(hr)) || (NULL == lpDirectPlay3A)) <br>goto SP_FAILURE; <br> <br>// initialize the connection <br>hr = lpDirectPlay3A-&gt;InitializeConnection(lpConnection, 0); <br>if FAILED(hr) <br>goto SP_FAILURE; <br> <br>// OK to host now <br>EnableDlgButton(hWnd, IDC_HOSTBUTTON, TRUE); <br> <br>// start enumerating the sessions <br>hr = EnumSessions(hWnd, lpDirectPlay3A); <br>if FAILED(hr) <br>goto SP_FAILURE; <br> <br>// set a timer to refresh the session list <br>idTimer = SetTimer(hWnd, TIMERID, TIMERINTERVAL, NULL); <br>} <br>else <br>{ <br>// They've selected the generic option "&lt;Select a service provider&gt;" <br>EnableDlgButton(hWnd, IDC_HOSTBUTTON, FALSE); <br>EnableDlgButton(hWnd, IDC_JOINBUTTON, FALSE); <br>} <br>break; <br>} <br>break; <br> <br>SP_FAILURE: <br>if (hr != DPERR_USERCANCEL) <br>ErrorBox("Could not select service provider because of error 0x%08X", hr); <br>break; <br> <br> <br>case IDC_HOSTBUTTON: <br>// should have an interface by now <br>if (lpDirectPlay3A == NULL) <br>break; <br> <br>KillTimer(hWnd, idTimer );  <br>// use computer name for session name <br>dwNameSize = MAXNAMELEN; <br>if (!GetComputerName(szSessionName, &amp;dwNameSize)) <br>lstrcpy(szSessionName, "Session"); <br> <br>// use user name for player name <br>dwNameSize = MAXNAMELEN; <br>if (!GetUserName(szPlayerName, &amp;dwNameSize)) <br>lstrcpy(szPlayerName, "unknown"); <br> <br>// host a new session on this service provider <br>hr = HostSession(lpDirectPlay3A, szSessionName, szPlayerName, lpDPInfo); <br>if FAILED(hr) <br>goto HOST_FAILURE; <br> <br>// dismiss dialog if we succeeded in hosting <br>EndDialog(hWnd, TRUE); <br>break; <br> <br>HOST_FAILURE: <br>ErrorBox("Could not host session because of error 0x%08X", hr); <br>break; <br> <br>        case IDC_JOINBUTTON: <br> <br>// should have an interface by now <br>if (lpDirectPlay3A == NULL) <br>break; <br> <br>KillTimer(hWnd, idTimer );  <br>// get guid of selected session instance <br>hr = GetSessionInstanceGuid(hWnd, &amp;guidSessionInstance); <br>if FAILED(hr) <br>goto JOIN_FAILURE; <br> <br>// use user name for player name <br>dwNameSize = MAXNAMELEN; <br>if (!GetUserName(szPlayerName, &amp;dwNameSize)) <br>lstrcpy(szPlayerName, "unknown"); <br> <br>// join this session <br>hr = JoinSession(lpDirectPlay3A, &amp;guidSessionInstance, szPlayerName, lpDPInfo); <br> <br>if FAILED(hr) <br>goto JOIN_FAILURE; <br> <br>// dismiss dialog if we succeeded in joining <br>EndDialog(hWnd, TRUE); <br>            break; <br> <br>JOIN_FAILURE: <br>ErrorBox("Could not join session because of error 0x%08X", hr); <br>break; <br> <br> <br>        case IDCANCEL: <br>KillTimer(hWnd, idTimer );  <br>// delete any interface created if cancelling <br>hr = DestroyDirectPlayInterface(hWnd, lpDirectPlay3A); <br>lpDirectPlay3A = NULL; <br> <br>EndDialog(hWnd, FALSE); <br>            break; <br>        } <br> <br>        break; <br>    } <br> <br>    // Allow for default processing <br>    return FALSE; <br>} <br> <br>BOOL FAR PASCAL DirectPlayEnumConnectionsCallback( <br>LPCGUID     lpguidSP, <br>LPVOIDlpConnection, <br>DWORDdwConnectionSize, <br>LPCDPNAME   lpName, <br>DWORD dwFlags, <br>LPVOID lpContext) <br>{ <br> <br>    HWNDhWnd = (HWND) lpContext; <br>    LRESULTiIndex; <br>LPVOIDlpConnectionBuffer; <br> <br>// store service provider name in combo box <br>iIndex = SendDlgItemMessage(hWnd, IDC_SPCOMBO, CB_ADDSTRING, 0,  <br>(LPARAM) lpName-&gt;lpszShortNameA); <br>if (iIndex == CB_ERR) <br>goto FAILURE; <br> <br>// make space for connection shortcut <br>lpConnectionBuffer = GlobalAllocPtr(GHND, dwConnectionSize); <br>if (lpConnectionBuffer == NULL) <br>goto FAILURE; <br> <br>// store pointer to connection shortcut in combo box <br>memcpy(lpConnectionBuffer, lpConnection, dwConnectionSize); <br>SendDlgItemMessage(hWnd, IDC_SPCOMBO, CB_SETITEMDATA, (WPARAM) iIndex,  <br>(LPARAM) lpConnectionBuffer); <br> <br>FAILURE: <br>    return (TRUE); <br>} <br> <br> <br>HRESULT CreateDirectPlayInterface( LPDIRECTPLAY3A *lplpDirectPlay3A ) <br>{ <br>HRESULThr; <br>LPDIRECTPLAY3AlpDirectPlay3A = NULL; <br> <br>// Create an IDirectPlay3 interface <br>hr = CoCreateInstance(CLSID_DirectPlay, NULL, CLSCTX_INPROC_SERVER,  <br>IID_IDirectPlay3A, (LPVOID*)&amp;lpDirectPlay3A); <br> <br>// return interface created <br>*lplpDirectPlay3A = lpDirectPlay3A; <br> <br>return (hr); <br>} <br> <br> <br>HRESULT DestroyDirectPlayInterface(HWND hWnd, LPDIRECTPLAY3A lpDirectPlay3A) <br>{ <br>HRESULThr = DP_OK; <br> <br>if (lpDirectPlay3A) <br>{ <br>DeleteSessionInstanceList(hWnd); <br>EnableDlgButton(hWnd, IDC_JOINBUTTON, FALSE); <br> <br>hr = lpDirectPlay3A-&gt;Release(); <br>} <br> <br>return (hr); <br>} <br> <br>HRESULT HostSession(LPDIRECTPLAY3A lpDirectPlay3A, <br>LPSTR lpszSessionName, LPSTR lpszPlayerName, <br>LPDPLAYINFO lpDPInfo) <br>{ <br>DPIDdpidPlayer; <br>DPNAMEdpName; <br>DPSESSIONDESC2sessionDesc; <br>HRESULThr; <br> <br>// check for valid interface <br>if (lpDirectPlay3A == NULL) <br>return (DPERR_INVALIDOBJECT); <br> <br>// host a new session <br>ZeroMemory(&amp;sessionDesc, sizeof(DPSESSIONDESC2)); <br>sessionDesc.dwSize = sizeof(DPSESSIONDESC2); <br>    sessionDesc.dwFlags = DPSESSION_MIGRATEHOST | DPSESSION_KEEPALIVE; <br>    sessionDesc.guidApplication = DPCHAT_GUID; <br>    sessionDesc.dwMaxPlayers = MAXPLAYERS; <br>sessionDesc.lpszSessionNameA = lpszSessionName; <br> <br>hr = lpDirectPlay3A-&gt;Open(&amp;sessionDesc, DPOPEN_CREATE); <br>if FAILED(hr) <br>goto OPEN_FAILURE; <br> <br>// fill out name structure <br>ZeroMemory(&amp;dpName, sizeof(DPNAME)); <br>dpName.dwSize = sizeof(DPNAME); <br>dpName.lpszShortNameA = lpszPlayerName; <br>dpName.lpszLongNameA = NULL; <br> <br>// create a player with this name <br>hr = lpDirectPlay3A-&gt;CreatePlayer(&amp;dpidPlayer, &amp;dpName,  <br>lpDPInfo-&gt;hPlayerEvent, NULL, 0, 0); <br>if FAILED(hr) <br>goto CREATEPLAYER_FAILURE; <br> <br>// return connection info <br>lpDPInfo-&gt;lpDirectPlay3A = lpDirectPlay3A; <br>lpDPInfo-&gt;dpidPlayer = dpidPlayer; <br>lpDPInfo-&gt;bIsHost = TRUE; <br> <br>return (DP_OK); <br> <br>CREATEPLAYER_FAILURE: <br>OPEN_FAILURE: <br>lpDirectPlay3A-&gt;Close(); <br>return (hr); <br>} <br> <br>HRESULT JoinSession(LPDIRECTPLAY3A lpDirectPlay3A, <br>LPGUID lpguidSessionInstance, LPSTR lpszPlayerName, <br>LPDPLAYINFO lpDPInfo) <br>{ <br>DPIDdpidPlayer; <br>DPNAMEdpName; <br>DPSESSIONDESC2sessionDesc; <br>HRESULThr; <br> <br>// check for valid interface <br>if (lpDirectPlay3A == NULL) <br>return (DPERR_INVALIDOBJECT); <br> <br>// join existing session <br>ZeroMemory(&amp;sessionDesc, sizeof(DPSESSIONDESC2)); <br>sessionDesc.dwSize = sizeof(DPSESSIONDESC2); <br>    sessionDesc.guidInstance = *lpguidSessionInstance; <br> <br>hr = lpDirectPlay3A-&gt;Open(&amp;sessionDesc, DPOPEN_JOIN); <br>if FAILED(hr) <br>goto OPEN_FAILURE; <br> <br>// fill out name structure <br>ZeroMemory(&amp;dpName, sizeof(DPNAME)); <br>dpName.dwSize = sizeof(DPNAME); <br>dpName.lpszShortNameA = lpszPlayerName; <br>dpName.lpszLongNameA = NULL; <br> <br>// create a player with this name <br>hr = lpDirectPlay3A-&gt;CreatePlayer(&amp;dpidPlayer, &amp;dpName,  <br>lpDPInfo-&gt;hPlayerEvent, NULL, 0, 0); <br>if FAILED(hr) <br>goto CREATEPLAYER_FAILURE; <br> <br>// return connection info <br>lpDPInfo-&gt;lpDirectPlay3A = lpDirectPlay3A; <br>lpDPInfo-&gt;dpidPlayer = dpidPlayer; <br>lpDPInfo-&gt;bIsHost = FALSE; <br> <br>return (DP_OK); <br> <br>CREATEPLAYER_FAILURE: <br>OPEN_FAILURE: <br>lpDirectPlay3A-&gt;Close(); <br>return (hr); <br>} <br> <br>BOOL FAR PASCAL EnumSessionsCallback( <br>LPCDPSESSIONDESC2lpSessionDesc, <br>LPDWORDlpdwTimeOut, <br>DWORDdwFlags, <br>LPVOIDlpContext) <br>{ <br>HWNDhWnd = (HWND) lpContext; <br>LPGUIDlpGuid; <br>LONGiIndex; <br> <br>// see if last session has been enumerated <br>    if (dwFlags &amp; DPESC_TIMEDOUT) <br>return (FALSE); <br> <br>// store session name in list <br>iIndex = SendDlgItemMessage( hWnd, IDC_SESSIONLIST, LB_ADDSTRING,  <br>(WPARAM) 0, (LPARAM) lpSessionDesc-&gt;lpszSessionNameA); <br> <br>if (iIndex == LB_ERR) <br>goto FAILURE; <br> <br> <br>// make space for session instance guid <br>lpGuid = (LPGUID) GlobalAllocPtr( GHND, sizeof(GUID) ); <br>if (lpGuid == NULL) <br>goto FAILURE; <br> <br>// store pointer to guid in list <br>*lpGuid = lpSessionDesc-&gt;guidInstance; <br>SendDlgItemMessage( hWnd, IDC_SESSIONLIST, LB_SETITEMDATA, (WPARAM) iIndex, (LPARAM) lpGuid); <br> <br>FAILURE: <br>    return (TRUE); <br>} <br> <br>HRESULT EnumSessions(HWND hWnd, LPDIRECTPLAY3A lpDirectPlay3A) <br>{ <br>DPSESSIONDESC2sessionDesc; <br>GUIDguidSessionInstance; <br>LONGiIndex; <br>HRESULThr; <br> <br>// check for valid interface <br>if (lpDirectPlay3A == NULL) <br>return (DPERR_INVALIDOBJECT); <br> <br>// get guid of currently selected session <br>guidSessionInstance = GUID_NULL; <br>hr = GetSessionInstanceGuid(hWnd, &amp;guidSessionInstance); <br> <br>// delete existing session list <br>DeleteSessionInstanceList(hWnd); <br> <br>// add sessions to session list <br>ZeroMemory(&amp;sessionDesc, sizeof(DPSESSIONDESC2)); <br>sessionDesc.dwSize = sizeof(DPSESSIONDESC2); <br>    sessionDesc.guidApplication = DPCHAT_GUID; <br> <br>hr = lpDirectPlay3A-&gt;EnumSessions(&amp;sessionDesc, 0, EnumSessionsCallback, <br>  hWnd, DPENUMSESSIONS_AVAILABLE | DPENUMSESSIONS_ASYNC); <br> <br>// select the session that was previously selected <br>SelectSessionInstance(hWnd, &amp;guidSessionInstance); <br> <br>// hilite "Join" button only if there are sessions to join <br>iIndex = SendDlgItemMessage(hWnd, IDC_SESSIONLIST, LB_GETCOUNT, <br>   (WPARAM) 0, (LPARAM) 0); <br> <br>EnableDlgButton(hWnd, IDC_JOINBUTTON, (iIndex &gt; 0) ? TRUE : FALSE); <br> <br>return (hr); <br>} <br> <br>HRESULT GetConnection(HWND hWnd, LPVOID *lplpConnection) <br>{ <br>LONGiIndex; <br> <br>// get index of the item currently selected in the combobox <br>iIndex = SendDlgItemMessage(hWnd, IDC_SPCOMBO, CB_GETCURSEL, <br>(WPARAM) 0, (LPARAM) 0); <br>if (iIndex == CB_ERR) <br>return (DPERR_GENERIC); <br> <br>// get the pointer to the connection shortcut associated with <br>// the item <br>iIndex = SendDlgItemMessage(hWnd, IDC_SPCOMBO, CB_GETITEMDATA, <br>(WPARAM) iIndex, (LPARAM) 0); <br>if (iIndex == CB_ERR) <br>return (DPERR_GENERIC); <br> <br>*lplpConnection = (LPVOID) iIndex; <br> <br>return (DP_OK); <br>} <br> <br>void DeleteConnectionList(HWND hWnd) <br>{ <br>WPARAMi; <br>LONGlpData; <br> <br>// destroy the GUID's stored with each service provider name <br>i = 0; <br>while (TRUE) <br>{ <br>// get data pointer stored with item <br>lpData = SendDlgItemMessage(hWnd, IDC_SPCOMBO, CB_GETITEMDATA, <br>(WPARAM) i, (LPARAM) 0); <br>if (lpData == CB_ERR)// error getting data <br>break; <br> <br>if (lpData != 0)// no data to delete <br>GlobalFreePtr((LPVOID) lpData); <br> <br>i += 1; <br>} <br> <br>// delete all items in combo box <br>SendDlgItemMessage(hWnd, IDC_SPCOMBO, CB_RESETCONTENT, <br>(WPARAM) 0, (LPARAM) 0); <br>} <br> <br>HRESULT GetSessionInstanceGuid(HWND hWnd, LPGUID lpguidSessionInstance) <br>{ <br>LONGiIndex; <br> <br>// get guid for session <br>iIndex = SendDlgItemMessage(hWnd, IDC_SESSIONLIST, LB_GETCURSEL, <br>(WPARAM) 0, (LPARAM) 0); <br>if (iIndex == LB_ERR) <br>return (DPERR_GENERIC); <br> <br>iIndex = SendDlgItemMessage(hWnd, IDC_SESSIONLIST, LB_GETITEMDATA, <br>(WPARAM) iIndex, (LPARAM) 0); <br>if ((iIndex == LB_ERR) || (iIndex == 0)) <br>return (DPERR_GENERIC); <br> <br>*lpguidSessionInstance = *((LPGUID) iIndex); <br> <br>return (DP_OK); <br>} <br> <br>void DeleteSessionInstanceList(HWND hWnd) <br>{ <br>WPARAMi; <br>LONGlpData; <br> <br>// destroy the GUID's stored with each session name <br>i = 0; <br>while (TRUE) <br>{ <br>// get data pointer stored with item <br>lpData = SendDlgItemMessage(hWnd, IDC_SESSIONLIST, LB_GETITEMDATA, <br>(WPARAM) i, (LPARAM) 0); <br>if (lpData == CB_ERR)// error getting data <br>break; <br> <br>if (lpData == 0)// no data to delete <br>continue; <br> <br>GlobalFreePtr((LPVOID) lpData); <br>i += 1; <br>} <br> <br>// delete all items in list <br>SendDlgItemMessage(hWnd, IDC_SESSIONLIST, LB_RESETCONTENT, <br>(WPARAM) 0, (LPARAM) 0); <br>} <br> <br>void SelectSessionInstance(HWND hWnd, LPGUID lpguidSessionInstance) <br>{ <br>WPARAMi, iIndex; <br>LONGlpData; <br> <br>// loop over the GUID's stored with each session name <br>// to find the one that matches what was passed in <br>i = 0; <br>iIndex = 0; <br>while (TRUE) <br>{ <br>// get data pointer stored with item <br>lpData = SendDlgItemMessage(hWnd, IDC_SESSIONLIST, LB_GETITEMDATA, <br>(WPARAM) i, (LPARAM) 0); <br>if (lpData == CB_ERR)// error getting data <br>break; <br> <br>if (lpData == 0)// no data to compare to <br>continue; <br> <br>// guid matches <br>if (IsEqualGUID(*lpguidSessionInstance, *((LPGUID) lpData))) <br>{ <br>iIndex = i;// store index of this string <br>break; <br>} <br> <br>i += 1; <br>} <br> <br>// select this item <br>SendDlgItemMessage(hWnd, IDC_SESSIONLIST, LB_SETCURSEL, (WPARAM) iIndex, (LPARAM) 0); <br>} <br> <br>void EnableDlgButton(HWND hDlg, int nIDDlgItem, BOOL bEnable) <br>{ <br>EnableWindow(GetDlgItem(hDlg, nIDDlgItem), bEnable); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
