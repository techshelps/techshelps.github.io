<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DPCHAT.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3056"></a>DPCHAT.CPP</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved. <br> * <br> *  File:       dpchat.cpp <br> *  Content:Simple chat program using DirectPlay. <br> * <br> ***************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br> <br>#include "dpchat.h" <br>#include "resource.h" <br> <br>// constants <br>const DWORD APPMSG_CHATSTRING= 0;// message type for chat string <br>const UINTWM_USER_ADDSTRING= WM_USER+257;// window message to add string to chat string list <br>const DWORDMAXSTRLEN= 200;// max size of a temporary string <br> <br>// structures <br> <br>// message structure used to send a chat string to another player <br>typedef struct { <br>DWORDdwType;// message type (APPMSG_CHATSTRING) <br>charszMsg[1];// message string (variable length) <br>} MSG_CHATSTRING, *LPMSG_CHATSTRING; <br> <br>// globals <br>HANDLEghReceiveThread = NULL;// handle of receive thread <br>DWORDgidReceiveThread = 0;// id of receive thread <br>HANDLEghKillReceiveEvent = NULL;// event used to kill receive thread <br>HWNDghChatWnd = NULL;// main chat window <br> <br>// prototypes <br>BOOL CALLBACKChatWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam); <br>HRESULTSetupConnection(HINSTANCE hInstance, LPDPLAYINFO lpDPInfo); <br>HRESULTShutdownConnection(LPDPLAYINFO lpDPInfo); <br>DWORD WINAPIReceiveThread(LPVOID lpThreadParameter); <br>HRESULTReceiveMessage(LPDPLAYINFO lpDPInfo); <br>voidHandleApplicationMessage(LPDPLAYINFO lpDPInfo, LPDPMSG_GENERIC lpMsg, DWORD dwMsgSize, <br> DPID idFrom, DPID idTo); <br>voidHandleSystemMessage(LPDPLAYINFO lpDPInfo, LPDPMSG_GENERIC lpMsg, DWORD dwMsgSize, <br>DPID idFrom, DPID idTo); <br>HRESULTGetChatPlayerName(LPDIRECTPLAY3A lpDirectPlay3A, DPID dpidPlayer, <br>  LPDPNAME *lplpName); <br>HRESULTSendChatMessage(HWND hWnd, LPDPLAYINFO lpDPInfo); <br>HRESULTNewChatString(LPDIRECTPLAY3A lpDirectPlay3A, DPID dpidPlayer, <br>  LPSTR lpszMsg, LPSTR *lplpszStr); <br> <br>int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, <br>   LPSTR lpCmdLine, int nCmdShow ) <br>{ <br>DPLAYINFODPInfo; <br>intiResult = 0; <br>HRESULThr; <br> <br>// Initialize COM library <br>hr = CoInitialize(NULL); <br>if ( FAILED(hr) ) <br>goto FAILURE; <br> <br> <br>// setup the connection <br>hr = SetupConnection(hInstance, &amp;DPInfo); <br>if FAILED(hr) <br>goto FAILURE; <br> <br>// show the chat window <br>iResult = DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_CHATDIALOG), NULL, (DLGPROC) ChatWndProc, (LPARAM) &amp;DPInfo); <br> <br>FAILURE: <br>// shut down the connection <br>hr = ShutdownConnection(&amp;DPInfo); <br> <br>// Uninitialize the COM library <br>CoUninitialize(); <br> <br>return (iResult); <br>} <br> <br>BOOL CALLBACK ChatWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) <br>{ <br>static LPDPLAYINFOlpDPInfo; <br>DWORDdwTextLen; <br> <br>    switch(uMsg) <br>    { <br>    case WM_INITDIALOG: <br>        // Save the connection info pointer <br>        lpDPInfo = (LPDPLAYINFO) lParam; <br> <br>// store global window <br>ghChatWnd = hWnd; <br>        break; <br> <br>    case WM_DESTROY: <br>ghChatWnd = NULL; <br>        break; <br> <br>// this is a user-defined message used to add strings to the log window <br>case WM_USER_ADDSTRING: <br>// get length of text in log window <br>dwTextLen = SendDlgItemMessage(hWnd, IDC_LOGEDIT, WM_GETTEXTLENGTH, <br>   (WPARAM) 0, (LPARAM) 0); <br> <br>// put selection at end <br>dwTextLen = SendDlgItemMessage(hWnd, IDC_LOGEDIT, EM_SETSEL, <br>   (WPARAM) dwTextLen, (LPARAM) dwTextLen); <br> <br>// add string in lParam to log window <br>SendDlgItemMessage(hWnd, IDC_LOGEDIT, EM_REPLACESEL, <br>(WPARAM) FALSE, (LPARAM) lParam); <br>GlobalFreePtr((LPVOID) lParam); <br>break; <br> <br>    case WM_COMMAND: <br>        switch(LOWORD(wParam)) <br>        { <br>        case IDC_SENDBUTTON: <br>SendChatMessage(hWnd, lpDPInfo); <br>break; <br> <br>        case IDCANCEL: <br>EndDialog(hWnd, FALSE); <br>            break; <br>} <br>break; <br>} <br> <br>    // Allow for default processing <br>    return FALSE; <br>} <br> <br>HRESULT SetupConnection(HINSTANCE hInstance, LPDPLAYINFO lpDPInfo) <br>{ <br>HRESULThr; <br> <br>ZeroMemory(lpDPInfo, sizeof(DPLAYINFO)); <br> <br>// create event used by DirectPlay to signal a message has arrived <br>lpDPInfo-&gt;hPlayerEvent = CreateEvent(NULL,// no security <br> FALSE,// auto reset <br> FALSE,// initial event reset <br> NULL);// no name <br>if (lpDPInfo-&gt;hPlayerEvent == NULL) <br>{ <br>hr = DPERR_NOMEMORY; <br>goto FAILURE; <br>} <br> <br>// create event used to signal that the receive thread should exit <br>ghKillReceiveEvent = CreateEvent(NULL,// no security <br> FALSE,// auto reset <br> FALSE,// initial event reset <br> NULL);// no name <br>if (ghKillReceiveEvent == NULL) <br>{ <br>hr = DPERR_NOMEMORY; <br>goto FAILURE; <br>} <br> <br>// create thread to receive player messages <br>ghReceiveThread = CreateThread(NULL,// default security <br>   0,// default stack size <br>   ReceiveThread,// pointer to thread routine <br>   lpDPInfo,// argument for thread <br>   0,// start it right away <br>   &amp;gidReceiveThread); <br>if (ghReceiveThread == NULL) <br>{ <br>hr = DPERR_NOMEMORY; <br>goto FAILURE; <br>} <br> <br>// try to connect using the lobby <br>hr = ConnectUsingLobby(lpDPInfo); <br>if FAILED(hr) <br>{ <br>// if the error returned is DPERR_NOTLOBBIED, that means we <br>// were not launched by a lobby and we should ask the user for <br>// connection settings. If any other error is returned it means <br>// we were launched by a lobby but there was an error making the <br>// connection. <br> <br>if (hr != DPERR_NOTLOBBIED) <br>ErrorBox("Could not connect using lobby because of error 0x%08X", hr); <br> <br>// if there is no lobby connection, ask the user for settings <br>hr = ConnectUsingDialog(hInstance, lpDPInfo); <br>if FAILED(hr) <br>goto FAILURE; <br>} <br> <br>return (DP_OK); <br> <br>FAILURE: <br>ShutdownConnection(lpDPInfo); <br> <br>return (hr); <br>} <br> <br>HRESULT ShutdownConnection(LPDPLAYINFO lpDPInfo) <br>{ <br>if (ghReceiveThread) <br>{ <br>// wake up receive thread and wait for it to quit <br>SetEvent(ghKillReceiveEvent); <br>WaitForSingleObject(ghReceiveThread, INFINITE); <br> <br>CloseHandle(ghReceiveThread); <br>ghReceiveThread = NULL; <br>} <br> <br>if (ghKillReceiveEvent) <br>{ <br>CloseHandle(ghKillReceiveEvent); <br>ghKillReceiveEvent = NULL; <br>} <br> <br>if (lpDPInfo-&gt;lpDirectPlay3A) <br>{ <br>if (lpDPInfo-&gt;dpidPlayer) <br>{ <br>lpDPInfo-&gt;lpDirectPlay3A-&gt;DestroyPlayer(lpDPInfo-&gt;dpidPlayer); <br>lpDPInfo-&gt;dpidPlayer = 0; <br>} <br>lpDPInfo-&gt;lpDirectPlay3A-&gt;Close(); <br>lpDPInfo-&gt;lpDirectPlay3A-&gt;Release(); <br>lpDPInfo-&gt;lpDirectPlay3A = NULL; <br>} <br> <br>if (lpDPInfo-&gt;hPlayerEvent) <br>{ <br>CloseHandle(lpDPInfo-&gt;hPlayerEvent); <br>lpDPInfo-&gt;hPlayerEvent = NULL; <br>} <br> <br>return (DP_OK); <br>} <br> <br>DWORD WINAPI ReceiveThread(LPVOID lpThreadParameter) <br>{ <br>    LPDPLAYINFOlpDPInfo = (LPDPLAYINFO) lpThreadParameter; <br>HANDLEeventHandles[2]; <br> <br>eventHandles[0] = lpDPInfo-&gt;hPlayerEvent; <br>eventHandles[1] = ghKillReceiveEvent; <br> <br>// loop waiting for player events. If the kill event is signaled <br>// the thread will exit <br>while (WaitForMultipleObjects(2, eventHandles, FALSE, INFINITE) == WAIT_OBJECT_0) <br>{ <br>// receive any messages in the queue <br>ReceiveMessage(lpDPInfo); <br>} <br> <br>ExitThread(0); <br> <br>return (0); <br>} <br> <br>HRESULT ReceiveMessage(LPDPLAYINFO lpDPInfo) <br>{ <br>DPIDidFrom, idTo; <br>LPVOIDlpvMsgBuffer; <br>DWORDdwMsgBufferSize; <br>HRESULThr; <br> <br>lpvMsgBuffer = NULL; <br>dwMsgBufferSize = 0; <br> <br>// loop to read all messages in queue <br>do <br>{ <br>// loop until a single message is successfully read <br>do <br>{ <br>// read messages from any player, including system player <br>idFrom = 0; <br>idTo = 0; <br> <br>hr = lpDPInfo-&gt;lpDirectPlay3A-&gt;Receive(&amp;idFrom, &amp;idTo, DPRECEIVE_ALL, <br>   lpvMsgBuffer, &amp;dwMsgBufferSize); <br> <br>// not enough room, so resize buffer <br>if (hr == DPERR_BUFFERTOOSMALL) <br>{ <br>if (lpvMsgBuffer) <br>GlobalFreePtr(lpvMsgBuffer); <br>lpvMsgBuffer = GlobalAllocPtr(GHND, dwMsgBufferSize); <br>if (lpvMsgBuffer == NULL) <br>hr = DPERR_OUTOFMEMORY; <br>} <br>} while (hr == DPERR_BUFFERTOOSMALL); <br> <br>if ((SUCCEEDED(hr)) &amp;&amp;// successfully read a message <br>(dwMsgBufferSize &gt;= sizeof(DPMSG_GENERIC)))// and it is big enough <br>{ <br>// check for system message <br>if (idFrom == DPID_SYSMSG) <br>{ <br>HandleSystemMessage(lpDPInfo, (LPDPMSG_GENERIC) lpvMsgBuffer, <br>dwMsgBufferSize, idFrom, idTo); <br>} <br>else <br>{ <br>HandleApplicationMessage(lpDPInfo, (LPDPMSG_GENERIC) lpvMsgBuffer, <br> dwMsgBufferSize, idFrom, idTo); <br>} <br>} <br>} while (SUCCEEDED(hr)); <br> <br>// free any memory we created <br>if (lpvMsgBuffer) <br>GlobalFreePtr(lpvMsgBuffer); <br> <br>return (DP_OK); <br>} <br> <br>void HandleApplicationMessage(LPDPLAYINFO lpDPInfo, LPDPMSG_GENERIC lpMsg, DWORD dwMsgSize, <br>  DPID idFrom, DPID idTo) <br>{ <br>LPSTRlpszStr = NULL; <br>HRESULThr; <br> <br>switch (lpMsg-&gt;dwType) <br>{ <br>case APPMSG_CHATSTRING: <br>        { <br>            LPMSG_CHATSTRING   lp = (LPMSG_CHATSTRING) lpMsg; <br> <br>// create string to display <br>hr = NewChatString(lpDPInfo-&gt;lpDirectPlay3A, idFrom, lp-&gt;szMsg, &amp;lpszStr); <br>if FAILED(hr) <br>break; <br>        } <br>break; <br>} <br> <br>// post string to chat window <br>if (lpszStr) <br>{ <br>// make sure window is still valid <br>if (ghChatWnd) <br>PostMessage(ghChatWnd, WM_USER_ADDSTRING, (WPARAM) 0, (LPARAM) lpszStr); <br>else <br>GlobalFreePtr(lpszStr); <br>} <br>} <br> <br>void HandleSystemMessage(LPDPLAYINFO lpDPInfo, LPDPMSG_GENERIC lpMsg, DWORD dwMsgSize, <br> DPID idFrom, DPID idTo) <br>{ <br>LPSTRlpszStr = NULL; <br> <br>    // The body of each case is there so you can set a breakpoint and examine <br>    // the contents of the message received. <br>switch (lpMsg-&gt;dwType) <br>{ <br>case DPSYS_CREATEPLAYERORGROUP: <br>        { <br>            LPDPMSG_CREATEPLAYERORGROUPlp = (LPDPMSG_CREATEPLAYERORGROUP) lpMsg; <br>LPSTRlpszPlayerName; <br>LPSTRszDisplayFormat = "\"%s\" has joined\r\n"; <br>             <br>// get pointer to player name <br>if (lp-&gt;dpnName.lpszShortNameA) <br>lpszPlayerName = lp-&gt;dpnName.lpszShortNameA; <br>else <br>lpszPlayerName = "unknown"; <br> <br>// allocate space for string <br>lpszStr = (LPSTR) GlobalAllocPtr(GHND, lstrlen(szDisplayFormat) + <br>   lstrlen(lpszPlayerName) + 1); <br>if (lpszStr == NULL) <br>break; <br> <br>// build string <br>wsprintf(lpszStr, szDisplayFormat, lpszPlayerName); <br>        } <br>break; <br> <br>case DPSYS_DESTROYPLAYERORGROUP: <br>        { <br>            LPDPMSG_DESTROYPLAYERORGROUPlp = (LPDPMSG_DESTROYPLAYERORGROUP)lpMsg; <br>LPSTRlpszPlayerName; <br>LPSTRszDisplayFormat = "\"%s\" has left\r\n"; <br>             <br>// get pointer to player name <br>if (lp-&gt;dpnName.lpszShortNameA) <br>lpszPlayerName = lp-&gt;dpnName.lpszShortNameA; <br>else <br>lpszPlayerName = "unknown"; <br> <br>// allocate space for string <br>lpszStr = (LPSTR) GlobalAllocPtr(GHND, lstrlen(szDisplayFormat) + <br>   lstrlen(lpszPlayerName) + 1); <br>if (lpszStr == NULL) <br>break; <br> <br>// build string <br>wsprintf(lpszStr, szDisplayFormat, lpszPlayerName); <br>        } <br>break; <br> <br>case DPSYS_ADDPLAYERTOGROUP: <br>        { <br>            LPDPMSG_ADDPLAYERTOGROUP lp = (LPDPMSG_ADDPLAYERTOGROUP)lpMsg; <br>        } <br>break; <br> <br>case DPSYS_DELETEPLAYERFROMGROUP: <br>        { <br>            LPDPMSG_DELETEPLAYERFROMGROUP lp = (LPDPMSG_DELETEPLAYERFROMGROUP)lpMsg; <br>        } <br>break; <br> <br>case DPSYS_SESSIONLOST: <br>        { <br>            LPDPMSG_SESSIONLOST lp = (LPDPMSG_SESSIONLOST)lpMsg; <br>        } <br>break; <br> <br>case DPSYS_HOST: <br>        { <br>            LPDPMSG_HOSTlp = (LPDPMSG_HOST)lpMsg; <br>LPSTRszDisplayFormat = "You have become the host\r\n"; <br> <br>// allocate space for string <br>lpszStr = (LPSTR) GlobalAllocPtr(GHND, lstrlen(szDisplayFormat) + 1); <br>if (lpszStr == NULL) <br>break; <br> <br>// build string <br>lstrcpy(lpszStr, szDisplayFormat); <br> <br>// we are now the host <br>lpDPInfo-&gt;bIsHost = TRUE; <br>        } <br>break; <br> <br>case DPSYS_SETPLAYERORGROUPDATA: <br>        { <br>            LPDPMSG_SETPLAYERORGROUPDATA lp = (LPDPMSG_SETPLAYERORGROUPDATA)lpMsg; <br>        } <br>break; <br> <br>case DPSYS_SETPLAYERORGROUPNAME: <br>        { <br>            LPDPMSG_SETPLAYERORGROUPNAME lp = (LPDPMSG_SETPLAYERORGROUPNAME)lpMsg; <br>        } <br>break; <br>} <br> <br>// post string to chat window <br>if (lpszStr) <br>{ <br>// make sure window is still valid <br>if (ghChatWnd) <br>PostMessage(ghChatWnd, WM_USER_ADDSTRING, (WPARAM) 0, (LPARAM) lpszStr); <br>else <br>GlobalFreePtr(lpszStr); <br>} <br>} <br> <br>HRESULT GetChatPlayerName(LPDIRECTPLAY3A lpDirectPlay3A, DPID dpidPlayer, <br>  LPDPNAME *lplpName) <br>{ <br>LPDPNAMElpName = NULL; <br>DWORDdwNameSize; <br>HRESULThr; <br> <br>// get size of player name data <br>hr = lpDirectPlay3A-&gt;GetPlayerName(dpidPlayer, NULL, &amp;dwNameSize); <br>if (hr != DPERR_BUFFERTOOSMALL) <br>goto FAILURE; <br> <br>// make room for it <br>lpName = (LPDPNAME) GlobalAllocPtr(GHND, dwNameSize); <br>if (lpName == NULL) <br>{ <br>hr = DPERR_OUTOFMEMORY; <br>goto FAILURE; <br>} <br> <br>// get player name data <br>hr = lpDirectPlay3A-&gt;GetPlayerName(dpidPlayer, lpName, &amp;dwNameSize); <br>if FAILED(hr) <br>goto FAILURE; <br> <br>// return pointer to name structure <br>*lplpName = lpName; <br> <br>return (DP_OK); <br> <br>FAILURE: <br>if (lpName) <br>GlobalFreePtr(lpName); <br> <br>return (hr); <br>} <br> <br>HRESULT SendChatMessage(HWND hWnd, LPDPLAYINFO lpDPInfo) <br>{ <br>LPSTRlpszChatStr = NULL; <br>LPSTRlpszStr = NULL; <br>LPMSG_CHATSTRINGlpChatMessage = NULL; <br>DWORDdwChatMessageSize; <br>LONGlStrLen; <br>HRESULThr; <br> <br>// get length of item text <br>lStrLen = SendDlgItemMessage(hWnd, IDC_SENDEDIT, WM_GETTEXTLENGTH, <br>(WPARAM) 0, (LPARAM) 0); <br> <br>// make room for it <br>lpszChatStr = (LPSTR) GlobalAllocPtr(GHND, lStrLen + 1); <br>if (lpszChatStr == NULL) <br>{ <br>hr = DPERR_OUTOFMEMORY; <br>goto FAILURE; <br>} <br> <br>// get item text <br>lStrLen = GetDlgItemText(hWnd, IDC_SENDEDIT, lpszChatStr, lStrLen + 1); <br> <br>// create string to display this text <br>hr = NewChatString(lpDPInfo-&gt;lpDirectPlay3A, lpDPInfo-&gt;dpidPlayer, lpszChatStr, &amp;lpszStr); <br>if FAILED(hr) <br>goto FAILURE; <br> <br>// display this string <br>PostMessage(hWnd, WM_USER_ADDSTRING, (WPARAM) 0, (LPARAM) lpszStr); <br>lpszStr = NULL;// set to NULL so we don't delete it below <br> <br>// create space for message plus string (string length included in message header) <br>dwChatMessageSize = sizeof(MSG_CHATSTRING) + lstrlen(lpszChatStr); <br>lpChatMessage = (LPMSG_CHATSTRING) GlobalAllocPtr(GHND, dwChatMessageSize); <br>if (lpChatMessage == NULL) <br>{ <br>hr = DPERR_OUTOFMEMORY; <br>goto FAILURE; <br>} <br> <br>// build message <br>lpChatMessage-&gt;dwType = APPMSG_CHATSTRING; <br>lstrcpy(lpChatMessage-&gt;szMsg, lpszChatStr); <br> <br>// send this string to all other players <br>hr = lpDPInfo-&gt;lpDirectPlay3A-&gt;Send(lpDPInfo-&gt;dpidPlayer, DPID_ALLPLAYERS, <br>DPSEND_GUARANTEED, lpChatMessage, dwChatMessageSize); <br>if FAILED(hr) <br>goto FAILURE; <br> <br>FAILURE: <br>if (lpszChatStr) <br>GlobalFreePtr(lpszChatStr); <br> <br>if (lpszStr) <br>GlobalFreePtr(lpszStr); <br> <br>if (lpChatMessage) <br>GlobalFreePtr(lpChatMessage); <br> <br>SetDlgItemText(hWnd, IDC_SENDEDIT, ""); <br> <br>return (hr); <br>} <br> <br>HRESULT NewChatString(LPDIRECTPLAY3A lpDirectPlay3A, DPID dpidPlayer, <br>  LPSTR lpszMsg, LPSTR *lplpszStr) <br>{ <br>LPDPNAMElpName = NULL; <br>LPSTRlpszStr = NULL; <br>LPSTRlpszPlayerName; <br>LPSTRszDisplayFormat = "%s&gt;\t%s\r\n"; <br>HRESULThr; <br> <br>// get name of player <br>hr = GetChatPlayerName(lpDirectPlay3A, dpidPlayer, &amp;lpName); <br>if FAILED(hr) <br>goto FAILURE; <br> <br>if (lpName-&gt;lpszShortNameA) <br>lpszPlayerName = lpName-&gt;lpszShortNameA; <br>else <br>lpszPlayerName = "unknown"; <br> <br>// allocate space for display string <br>lpszStr = (LPSTR) GlobalAllocPtr(GHND, lstrlen(szDisplayFormat) + <br>   lstrlen(lpszPlayerName) + <br>   lstrlen(lpszMsg) + 1); <br>if (lpszStr == NULL) <br>{ <br>hr = DPERR_OUTOFMEMORY; <br>goto FAILURE; <br>} <br> <br>// build string <br>wsprintf(lpszStr, szDisplayFormat, lpszPlayerName, lpszMsg); <br> <br>*lplpszStr = lpszStr; <br>lpszStr = NULL; <br> <br>FAILURE: <br>if (lpszStr) <br>GlobalFreePtr(lpszStr); <br> <br>if (lpName) <br>GlobalFreePtr(lpName); <br> <br>return (hr); <br>} <br> <br>void ErrorBox(LPSTR lpszErrorStr, HRESULT hr) <br>{ <br>charszStr[MAXSTRLEN]; <br> <br>wsprintf(szStr, lpszErrorStr, hr); <br> <br>MessageBox(NULL, szStr, "Error", MB_OK); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
