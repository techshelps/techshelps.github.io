<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TEXTURE.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3353"></a>TEXTURE.C</h2>
<pre><code>/* <br> *  Copyright (C) 1995, 1996 Microsoft Corporation. All Rights Reserved. <br> * <br> *  File: texture.c <br> * <br> *  Loads and manages textures.  Part of D3DApp. <br> * <br> *  D3DApp is a collection of helper functions for Direct3D applications. <br> *  D3DApp consists of the following files: <br> *d3dapp.h    Main D3DApp header to be included by application <br> *      d3dappi.h   Internal header <br> *      d3dapp.c    D3DApp functions seen by application. <br> *      ddcalls.c   All calls to DirectDraw objects except textures <br> *      d3dcalls.c  All calls to Direct3D objects except textures <br> *      texture.c   Texture loading and managing texture list <br> *      misc.c    Miscellaneous calls <br> */ <br> <br>#include "d3dappi.h" <br> <br>#define MAGICBYTES 2 <br> <br>/* <br> * STATIC FUNCTION DECLARATIONS <br> */ <br>static void D3DAppIAddPathList(const char *path); <br>static void D3DAppIInitialisePathList(); <br>static FILE * D3DAppIFindFile(const char *name, const char *mode); <br>static BOOL loadPPMHeader(FILE *fp, DWORD *width, DWORD *height, int *maxgrey); <br> <br> <br>/***************************************************************************/ <br>/*                        Managing the texture list                        */ <br>/***************************************************************************/ <br>/* <br> * D3DAppILoadTextureSurf <br> * Creates a texture map surface and texture object from the numbered PPM <br> * file.  This is done in a two step process.  A source texture surface and <br> * object are created in system memory.  A second, initially empty, texture <br> * surface is created (in video memory if hardware is present).  The source <br> * texture is loaded into the destination texture surface and then discarded. <br> * This process allows a device to compress or reformat a texture map as it <br> * enters video memory during the Load call. <br> */ <br>BOOL <br>D3DAppILoadTextureSurf(int n, BOOL* bInVideo) <br>{ <br>    DDSURFACEDESC ddsd; <br>    LPDIRECTDRAWSURFACE lpSrcTextureSurf = NULL; <br>    LPDIRECT3DTEXTURE2 lpSrcTexture = NULL; <br>    LPDIRECTDRAWPALETTE lpDstPalette = NULL; <br>    PALETTEENTRY ppe[256]; <br>    DWORD pcaps; <br>    /* <br>     * Release the surface if it is hanging around <br>     */ <br>    RELEASE(d3dappi.lpTextureSurf[n]); <br>    /* <br>     * Create a surface in system memory and load the PPM file into it. <br>     * Query for the texture interface. <br>     */ <br>    lpSrcTextureSurf = D3DAppILoadSurface(d3dappi.lpDD, d3dappi.ImageFile[n], <br>  &amp;d3dappi.ThisTextureFormat.ddsd, <br>  DDSCAPS_SYSTEMMEMORY); <br>    if (!lpSrcTextureSurf) <br>goto exit_with_error; <br>    LastError = lpSrcTextureSurf-&gt;lpVtbl-&gt;QueryInterface(lpSrcTextureSurf, <br>     &amp;IID_IDirect3DTexture2, <br>     (LPVOID*)&amp;lpSrcTexture); <br>    if (LastError != DD_OK) { <br>D3DAppISetErrorString("Failed to obtain D3D texture interface for a source texture.\n%s", D3DAppErrorToString(LastError)); <br>goto exit_with_error; <br>    } <br>    /* <br>     * Create an empty texture surface to load the source texture into. <br>     * The DDSCAPS_ALLOCONLOAD flag allows the DD driver to wait until the <br>     * load call to allocate the texture in memory because at this point, <br>     * we may not know how much memory the texture will take up (e.g. it <br>     * could be compressed to an unknown size in video memory). <br>     * Make sure SW renderers get textures in system memory <br>     */ <br>    LastError = D3DAppIGetSurfDesc(&amp;ddsd, lpSrcTextureSurf); <br>    if (LastError != DD_OK) { <br>D3DAppISetErrorString("Could not get the surface description of the source texture.\n%s", <br>      D3DAppErrorToString(LastError)); <br>goto exit_with_error; <br>    } <br>    ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT; <br>    ddsd.ddsCaps.dwCaps = DDSCAPS_TEXTURE | DDSCAPS_ALLOCONLOAD; <br>    if (!d3dappi.ThisDriver.bIsHardware) <br>ddsd.ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY; <br>    LastError = D3DAppICreateSurface(&amp;ddsd, &amp;d3dappi.lpTextureSurf[n]); <br>    if (LastError != DD_OK) { <br>D3DAppISetErrorString("Could not create the destination texture surface.\n%s", <br>      D3DAppErrorToString(LastError)); <br>goto exit_with_error; <br>    } <br>    if (ddsd.ddpfPixelFormat.dwFlags &amp; DDPF_PALETTEINDEXED8) { <br>pcaps = DDPCAPS_8BIT | DDPCAPS_ALLOW256; <br>    } else if (ddsd.ddpfPixelFormat.dwFlags &amp; DDPF_PALETTEINDEXED4) { <br>pcaps = DDPCAPS_4BIT; <br>    } else { <br>pcaps = 0; <br>    } <br>    if (pcaps) { <br>memset(ppe, 0, sizeof(PALETTEENTRY) * 256); <br>LastError = d3dappi.lpDD-&gt;lpVtbl-&gt;CreatePalette(d3dappi.lpDD, pcaps, <br> ppe, &amp;lpDstPalette, NULL); <br>if (LastError != DD_OK) { <br>    D3DAppISetErrorString("Failed to create a palette for the destination texture.\n%s", <br>  D3DAppErrorToString(LastError)); <br>    goto exit_with_error; <br>} <br>LastError = d3dappi.lpTextureSurf[n]-&gt;lpVtbl-&gt;SetPalette(d3dappi.lpTextureSurf[n], <br>lpDstPalette); <br>if (LastError != DD_OK) { <br>    D3DAppISetErrorString("Failed to set the destination texture's palette.\n%s", <br>  D3DAppErrorToString(LastError)); <br>    goto exit_with_error; <br>} <br>//lpDstPalette-&gt;lpVtbl-&gt;Release(lpDstPalette); <br>    } <br>    /* <br>     * Query our destination surface for a texture interface <br>     */ <br>    LastError = d3dappi.lpTextureSurf[n]-&gt;lpVtbl-&gt;QueryInterface(d3dappi.lpTextureSurf[n], <br>     &amp;IID_IDirect3DTexture2, <br>     (LPVOID*)&amp;d3dappi.lpTexture[n]); <br>    if (LastError != DD_OK) { <br>D3DAppISetErrorString("Failed to obtain D3D texture interface for a destination texture.\n%s", <br>      D3DAppErrorToString(LastError)); <br>goto exit_with_error; <br>    } <br>    /* <br>     * Load the source texture into the destination.  During this call, a <br>     * driver could compress or reformat the texture surface and put it in <br>     * video memory. <br>     */ <br>    LastError = d3dappi.lpTexture[n]-&gt;lpVtbl-&gt;Load(d3dappi.lpTexture[n], lpSrcTexture); <br>    if (LastError != DD_OK) { <br>D3DAppISetErrorString("Could not load a source texture into a destination texture.\n%s", <br>      D3DAppErrorToString(LastError)); <br>goto exit_with_error; <br>    } <br> <br>    /*  <br>     * Now we are done with the source texture <br>     */ <br>    RELEASE(lpSrcTexture); <br>    RELEASE(lpSrcTextureSurf); <br> <br>    /* <br>     * Did the texture end up in video memory? <br>     */ <br>    LastError = D3DAppIGetSurfDesc(&amp;ddsd, d3dappi.lpTextureSurf[n]); <br>    if (LastError != DD_OK) { <br>D3DAppISetErrorString("Could not get the surface description of the loaded texture surface.\n%s", <br>      D3DAppErrorToString(LastError)); <br>goto exit_with_error; <br>    } <br>    if (ddsd.ddsCaps.dwCaps &amp; DDSCAPS_VIDEOMEMORY) <br>*bInVideo = TRUE; <br>    else <br>*bInVideo = FALSE; <br>     <br>     <br>    return TRUE; <br> <br>exit_with_error: <br>    RELEASE(lpSrcTexture); <br>    RELEASE(lpSrcTextureSurf); <br>    RELEASE(lpDstPalette); <br>    RELEASE(d3dappi.lpTexture[n]); <br>    RELEASE(d3dappi.lpTextureSurf[n]); <br>    return FALSE;        <br>} <br> <br>/* <br> * D3DAppIReloadTextureSurf <br> * Reloads a lost and restored texture surface <br> */ <br>BOOL <br>D3DAppIReloadTextureSurf(int n) <br>{ <br>    LPDIRECTDRAWSURFACE lpSrcTextureSurf = NULL; <br>    LPDIRECT3DTEXTURE2 lpSrcTexture = NULL; <br> <br>    /* <br>     * Create a surface in system memory and load the PPM file into it. <br>     * Query for the texture interface. <br>     */ <br>    lpSrcTextureSurf = D3DAppILoadSurface(d3dappi.lpDD, d3dappi.ImageFile[n], <br>  &amp;d3dappi.ThisTextureFormat.ddsd, <br>  DDSCAPS_SYSTEMMEMORY); <br>    if (!lpSrcTextureSurf) <br>goto exit_with_error; <br>    LastError = lpSrcTextureSurf-&gt;lpVtbl-&gt;QueryInterface(lpSrcTextureSurf, <br>     &amp;IID_IDirect3DTexture2, <br>     (LPVOID*)&amp;lpSrcTexture); <br>    if (LastError != DD_OK) { <br>D3DAppISetErrorString("Failed to obtain D3D texture interface for a source texture.\n%s", D3DAppErrorToString(LastError)); <br>goto exit_with_error; <br>    } <br>    /* <br>     * Load the source texture into the destination.  During this call, a <br>     * driver could compress or reformat the texture surface and put it in <br>     * video memory. <br>     */ <br>    LastError = d3dappi.lpTexture[n]-&gt;lpVtbl-&gt;Load(d3dappi.lpTexture[n], lpSrcTexture); <br>    if (LastError != DD_OK) { <br>D3DAppISetErrorString("Could not load a source texture into a destination texture.\n%s", <br>      D3DAppErrorToString(LastError)); <br>goto exit_with_error; <br>    } <br>    /*  <br>     * Now we are done with the source texture <br>     */ <br>    RELEASE(lpSrcTexture); <br>    RELEASE(lpSrcTextureSurf); <br> <br>    return TRUE; <br> <br>exit_with_error: <br>    RELEASE(lpSrcTexture); <br>    RELEASE(lpSrcTextureSurf); <br>    return FALSE;        <br>} <br> <br> <br>/* <br> * D3DAppIGetTextureHandle <br> * Get a texture handle from the current D3D device for this texture and save <br> * it in the MasterTextureHandle list and public texture handle list. <br> */ <br>BOOL <br>D3DAppIGetTextureHandle(int n) <br>{ <br>    LastError = d3dappi.lpTexture[n]-&gt;lpVtbl-&gt;GetHandle(d3dappi.lpTexture[n], <br>       d3dappi.lpD3DDevice, &amp;MasterTextureHandle[n]); <br>    if (LastError != DD_OK) { <br>D3DAppISetErrorString("Could not get a handle to loaded texture %i.\n%s", <br>      n, D3DAppErrorToString(LastError)); <br>goto exit_with_error; <br>    } <br>    /* <br>     * If textures are enabled, put the handle in the public texture list, <br>     * otherwise, keep it as zero. <br>     */ <br>    if (!d3dappi.bTexturesDisabled) { <br>d3dappi.TextureHandle[n] = MasterTextureHandle[n]; <br>    } else { <br>d3dappi.TextureHandle[n] = 0; <br>    } <br>    return TRUE; <br>exit_with_error: <br>    MasterTextureHandle[n] = 0; <br>    d3dappi.TextureHandle[n] = 0; <br>    return FALSE;        <br>} <br> <br>/* <br> * D3DAppIReleaseTexture <br> * Release this texture surface and texture interface.  Remember, a texture <br> * handle is NOT and object and does not need to be released or destroyed. <br> * The handle is no longer valid after the device is destroyed, so set it to <br> * zero here. <br> */ <br>void <br>D3DAppIReleaseTexture(int n) <br>{ <br>    RELEASE(d3dappi.lpTexture[n]); <br>    RELEASE(d3dappi.lpTextureSurf[n]); <br>    MasterTextureHandle[n] = 0; <br>    d3dappi.TextureHandle[n] = 0; <br>} <br> <br>/* <br> * D3DAppIReleaseAllTextures <br> * Release all texture surfaces and texture interfaces <br> */ <br>void <br>D3DAppIReleaseAllTextures(void) <br>{ <br>    int i; <br>    for (i = 0; i &lt; d3dappi.NumTextures; i++) { <br>D3DAppIReleaseTexture(i); <br>    } <br>} <br> <br>/* <br> * D3DAppILoadAllTextures <br> * Load all texture surfaces, qeury them for texture interfaces and get <br> * handles for them from the current D3D driver. <br> */ <br>BOOL <br>D3DAppILoadAllTextures(void) <br>{ <br>    int i; <br>    if (d3dappi.ThisDriver.bDoesTextures) { <br>d3dappi.NumUsableTextures = 0; <br>for (i = 0; i &lt; d3dappi.NumTextures; i++) { <br>    BOOL bInVideo; <br>    ATTEMPT(D3DAppILoadTextureSurf(i, &amp;bInVideo)); <br>    if (!bInVideo &amp;&amp; d3dappi.ThisDriver.bIsHardware) { <br>/* <br> * If a texture fails to load into video memory for a hardware <br> * device, stop the NumUsableTextures count here. <br> */ <br>D3DAppIReleaseTexture(i); <br>break; <br>    } else { <br>++d3dappi.NumUsableTextures; <br>    } <br>} <br>for (i = 0; i &lt; d3dappi.NumUsableTextures; i++) { <br>    ATTEMPT(D3DAppIGetTextureHandle(i)); <br>} <br>    } else { <br>d3dappi.NumUsableTextures = 0; <br>    } <br>    return TRUE; <br> <br>exit_with_error: <br>    for (i = 0; i &lt; d3dappi.NumTextures; i++) { <br>D3DAppIReleaseTexture(i); <br>    } <br>    return FALSE; <br>} <br> <br>/***************************************************************************/ <br>/*                    Loading a PPM file into a surface                    */ <br>/***************************************************************************/ <br>/* <br> * LoadSurface <br> * Loads a ppm file into a texture map DD surface of the given format.  The <br> * memory flag specifies DDSCAPS_SYSTEMMEMORY or DDSCAPS_VIDEOMEMORY. <br> */ <br>LPDIRECTDRAWSURFACE <br>D3DAppILoadSurface(LPDIRECTDRAW lpDD, LPCSTR lpName, <br>   LPDDSURFACEDESC lpFormat, DWORD memoryflag) <br>{ <br>    LPDIRECTDRAWSURFACE lpDDS; <br>    DDSURFACEDESC ddsd, format; <br>    D3DCOLOR colors[256]; <br>    D3DCOLOR c; <br>    DWORD dwWidth, dwHeight; <br>    int i, j; <br>    FILE *fp; <br>    char *lpC; <br>    LPDIRECTDRAWPALETTE lpDDPal; <br>    PALETTEENTRY ppe[256]; <br>    int psize; <br>    DWORD pcaps; <br>    int color_count; <br>    BOOL bQuant = FALSE; <br>    HRESULT ddrval; <br> <br>    /* <br>     * Find the image file and open it <br>     */ <br>    fp = D3DAppIFindFile(lpName, "rb"); <br>    if (fp == NULL) { <br>        D3DAppISetErrorString("Cannot find %s.\n", lpName); <br>return NULL; <br>    } <br>    /* <br>     * Parse the PPM header <br>     */ <br>    if (!loadPPMHeader(fp, &amp;dwWidth, &amp;dwHeight, &amp;i)) { <br>fclose(fp); <br>D3DAppISetErrorString("Could not load or parse PPM header in %s.\n", lpName); <br>return NULL; <br>    } <br>    /* <br>     * Create a surface of the given format using the dimensions of the PPM <br>     * file. <br>     */ <br>    memcpy(&amp;format, lpFormat, sizeof(DDSURFACEDESC)); <br>    if (format.ddpfPixelFormat.dwFlags &amp; DDPF_PALETTEINDEXED8) { <br>        bQuant = TRUE; <br>psize = 256; <br>pcaps = DDPCAPS_8BIT | DDPCAPS_ALLOW256; <br>    } else if (format.ddpfPixelFormat.dwFlags &amp; DDPF_PALETTEINDEXED4) { <br>        bQuant = TRUE; <br>psize = 16; <br>pcaps = DDPCAPS_4BIT; <br>    } <br>    memcpy(&amp;ddsd, &amp;format, sizeof(DDSURFACEDESC)); <br>    ddsd.dwSize = sizeof(DDSURFACEDESC); <br>    ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT; <br>    ddsd.ddsCaps.dwCaps = DDSCAPS_TEXTURE | memoryflag; <br>    ddsd.dwHeight = dwHeight; <br>    ddsd.dwWidth = dwWidth; <br> <br>    ddrval = lpDD-&gt;lpVtbl-&gt;CreateSurface(lpDD, &amp;ddsd, &amp;lpDDS, NULL); <br>    if (ddrval != DD_OK) { <br>        D3DAppISetErrorString("CreateSurface for texture failed (loadtex).\n%s", <br>      D3DAppErrorToString(ddrval)); <br>return NULL; <br>    } <br>    /* <br>     * Lock the surface so it can be filled with the PPM file <br>     */ <br>    memset(&amp;ddsd, 0, sizeof(DDSURFACEDESC)); <br>    ddsd.dwSize = sizeof(DDSURFACEDESC); <br>    ddrval = lpDDS-&gt;lpVtbl-&gt;Lock(lpDDS, NULL, &amp;ddsd, 0, NULL); <br>    if (ddrval != DD_OK) { <br>lpDDS-&gt;lpVtbl-&gt;Release(lpDDS); <br>        D3DAppISetErrorString("Lock failed while loading surface (loadtex).\n%s", <br>      D3DAppErrorToString(ddrval)); <br>return NULL; <br>    } <br>    /* <br>     * The method of loading depends on the pixel format of the dest surface <br>     */ <br>    if (!bQuant) { <br>/* <br> * The texture surface is not palettized <br> */ <br>        unsigned long* lpLP; <br>unsigned short* lpSP; <br>unsigned char* lpCP; <br>        unsigned long m; <br>        int s; <br>        int red_shift, red_scale; <br>        int green_shift, green_scale; <br>        int blue_shift, blue_scale; <br>/* <br> * Determine the red, green and blue masks' shift and scale. <br> */ <br>        for (s = 0, m = format.ddpfPixelFormat.dwRBitMask; !(m &amp; 1); <br>       s++, m &gt;&gt;= 1); <br>        red_shift = s; <br>        red_scale = 255 / (format.ddpfPixelFormat.dwRBitMask &gt;&gt; s); <br>        for (s = 0, m = format.ddpfPixelFormat.dwGBitMask; !(m &amp; 1); <br>       s++, m &gt;&gt;= 1); <br>        green_shift = s; <br>        green_scale = 255 / (format.ddpfPixelFormat.dwGBitMask &gt;&gt; s); <br>        for (s = 0, m = format.ddpfPixelFormat.dwBBitMask; !(m &amp; 1); <br>       s++, m &gt;&gt;= 1); <br>        blue_shift = s; <br>        blue_scale = 255 / (format.ddpfPixelFormat.dwBBitMask &gt;&gt; s); <br>/* <br> * Each RGB bit count requires different pointers <br> */ <br>switch (format.ddpfPixelFormat.dwRGBBitCount) { <br>    case 32 : <br>for (j = 0; j &lt; (int)dwHeight; j++) { <br>    /* <br>     * Point to next row in texture surface <br>     */ <br>    lpLP = (unsigned long*)(((char*)ddsd.lpSurface) + <br>    ddsd.lPitch * j); <br>    for (i = 0; i &lt; (int)dwWidth; i++) { <br>int r, g, b; <br>/* <br> * Read each value, scale it and shift it into position <br> */ <br>r = getc(fp) / red_scale; <br>g = getc(fp) / green_scale; <br>b = getc(fp) / blue_scale; <br>*lpLP = (r &lt;&lt; red_shift) | (g &lt;&lt; green_shift) | <br>(b &lt;&lt; blue_shift); <br>lpLP++; <br>    } <br>} <br>break; <br>    case 16 : <br>for (j = 0; j &lt; (int)dwHeight; j++) { <br>    lpSP = (unsigned short*)(((char*)ddsd.lpSurface) + <br>    ddsd.lPitch * j); <br>    for (i = 0; i &lt; (int)dwWidth; i++) { <br>int r, g, b; <br>r = getc(fp) / red_scale; <br>g = getc(fp) / green_scale; <br>b = getc(fp) / blue_scale; <br>*lpSP = (r &lt;&lt; red_shift) | (g &lt;&lt; green_shift) | <br>(b &lt;&lt; blue_shift); <br>lpSP++; <br>    } <br>} <br>break; <br>    case 8: <br>for (j = 0; j &lt; (int)dwHeight; j++) { <br>    lpCP = (unsigned char*)(((char*)ddsd.lpSurface) + <br>    ddsd.lPitch * j); <br>    for (i = 0; i &lt; (int)dwWidth; i++) { <br>int r, g, b; <br>r = getc(fp) / red_scale; <br>g = getc(fp) / green_scale; <br>b = getc(fp) / blue_scale; <br>*lpCP = (r &lt;&lt; red_shift) | (g &lt;&lt; green_shift) |  <br>(b &lt;&lt; blue_shift); <br>lpCP++; <br>    } <br>} <br>break; <br>    default: <br>/* <br> * This wasn't a format I recognize <br> */ <br>    lpDDS-&gt;lpVtbl-&gt;Unlock(lpDDS, NULL); <br>fclose(fp); <br>lpDDS-&gt;lpVtbl-&gt;Release(lpDDS); <br>                D3DAppISetErrorString("Unknown pixel format (loadtex)."); <br>return NULL; <br>} <br>/* <br> * Unlock the texture and return the surface pointer <br> */ <br>lpDDS-&gt;lpVtbl-&gt;Unlock(lpDDS, NULL); <br>        fclose(fp); <br>        return (lpDDS); <br>    } <br> <br>    /* <br>     * We assume the 8-bit palettized case <br>     */ <br>    color_count = 0;/* number of colors in the texture */ <br>    for (j = 0; j &lt; (int)dwHeight; j++) { <br>/* <br> * Point to next row in surface <br> */ <br>lpC = ((char*)ddsd.lpSurface) + ddsd.lPitch * j; <br>for (i = 0; i &lt; (int)dwWidth; i++) { <br>    int r, g, b, k; <br>    /* <br>     * Get the next red, green and blue values and turn them into a <br>     * D3DCOLOR <br>     */ <br>    r = getc(fp); <br>    g = getc(fp); <br>    b = getc(fp); <br>            c = RGB_MAKE(r, g, b); <br>    /* <br>     * Search for this color in a table of colors in this texture <br>     */ <br>            for (k = 0; k &lt; color_count; k++) <br>                if (c == colors[k]) break; <br>            if (k == color_count) { <br>/* <br> * This is a new color, so add it to the list <br> */ <br>                color_count++; <br>/* <br> * More than 256 and we fail (8-bit)  <br> */ <br>                if (color_count &gt; psize) { <br>    color_count--; <br>    k = color_count - 1; <br>                    //goto burst_colors; <br>} <br>                colors[k] = c; <br>            } <br>    /* <br>     * Set the "pixel" value on the surface to be the index into the <br>     * color table <br>     */ <br>    if (psize == 16) { <br>if ((i &amp; 1) == 0) <br>    *lpC = k &amp; 0xf; <br>else { <br>    *lpC |= (k &amp; 0xf) &lt;&lt; 4; <br>    lpC++; <br>} <br>    } else { <br>*lpC = (char)k; <br>lpC++; <br>    } <br>        } <br>    } <br>    /* <br>     * Close the file and unlock the surface <br>     */ <br>    fclose(fp); <br>    lpDDS-&gt;lpVtbl-&gt;Unlock(lpDDS, NULL); <br> <br>//burst_colors: <br>    if (color_count &gt; psize) { <br>/* <br> * If there are more than 256 colors, we overran our palette <br> */ <br>        lpDDS-&gt;lpVtbl-&gt;Unlock(lpDDS, NULL); <br>lpDDS-&gt;lpVtbl-&gt;Release(lpDDS); <br>        D3DAppISetErrorString("Palette burst. (loadtex).\n"); <br>return (NULL); <br>    } <br> <br>    /* <br>     * Create a palette with the colors in our color table <br>     */ <br>    memset(ppe, 0, sizeof(PALETTEENTRY) * 256); <br>    for (i = 0; i &lt; color_count; i++) { <br>ppe[i].peRed = (unsigned char)RGB_GETRED(colors[i]); <br>        ppe[i].peGreen = (unsigned char)RGB_GETGREEN(colors[i]); <br>ppe[i].peBlue = (unsigned char)RGB_GETBLUE(colors[i]); <br>    } <br>    /* <br>     * Set all remaining entry flags to D3DPAL_RESERVED, which are ignored by <br>     * the renderer. <br>     */ <br>    for (; i &lt; 256; i++) <br>ppe[i].peFlags = D3DPAL_RESERVED; <br>    /* <br>     * Create the palette with the DDPCAPS_ALLOW256 flag because we want to <br>     * have access to all entries. <br>     */ <br>    ddrval = lpDD-&gt;lpVtbl-&gt;CreatePalette(lpDD, <br> DDPCAPS_INITIALIZE | pcaps, <br> ppe, &amp;lpDDPal, NULL); <br>    if (ddrval != DD_OK) { <br>        lpDDS-&gt;lpVtbl-&gt;Release(lpDDS); <br>        D3DAppISetErrorString("Create palette failed while loading surface (loadtex).\n%s", <br>      D3DAppErrorToString(ddrval)); <br>return (NULL); <br>    } <br>    /* <br>     * Finally, bind the palette to the surface <br>     */ <br>    ddrval = lpDDS-&gt;lpVtbl-&gt;SetPalette(lpDDS, lpDDPal); <br>    if (ddrval != DD_OK) { <br>lpDDS-&gt;lpVtbl-&gt;Release(lpDDS); <br>lpDDPal-&gt;lpVtbl-&gt;Release(lpDDPal); <br>        D3DAppISetErrorString("SetPalette failed while loading surface (loadtex).\n%s", <br>      D3DAppErrorToString(ddrval)); <br>return (NULL); <br>    } <br> <br>    lpDDPal-&gt;lpVtbl-&gt;Release(lpDDPal); <br> <br>    return lpDDS; <br>} <br> <br>static BOOL <br>ppm_getbyte(FILE *fp, char *newByte) <br>{ <br>    char cchar; <br>    int cc; <br> <br>    /* Get a byte, and dump comments */ <br>    cchar = cc = getc(fp); <br>    if (cc == EOF) { <br>      return FALSE; <br>    } <br>   <br>    if (cchar == '#') { <br>/* Read until next end of line */ <br>do { <br>    cchar = cc = getc(fp); <br>    if (cc == EOF) <br>return FALSE; <br>} while (cchar != '\n' &amp;&amp; cchar != '\r'); <br>    } <br> <br>  *newByte = cchar; <br> <br>  return TRUE; <br>} <br> <br>static BOOL <br>ppm_getint(FILE *fp, int *newInt) <br>{ <br>  int cint; <br>  char cchar; <br> <br>  do { <br>    if (!ppm_getbyte(fp, &amp;cchar)) return FALSE; <br>  } while (isspace(cchar)); <br>   <br>  if (!isdigit(cchar)) { <br>    return FALSE; <br>  } <br>   <br>  cint = 0; <br>   <br>  do { <br>    cint = (cint * 10) + (cchar - '0'); <br>    if (!ppm_getbyte(fp, &amp;cchar)) return FALSE; <br>  } while(isdigit(cchar)); <br> <br>  *newInt = cint; <br> <br>  return TRUE; <br>} <br>     <br>static BOOL <br>loadPPMHeader(FILE *fp, DWORD *width, DWORD *height, int *maxgrey) <br>{ <br>    char magic[MAGICBYTES], cchar; <br> <br>    /* Slurp up ppm header until we get width, height and maxgrey values */ <br> <br>    /* Read and check the magic bytes */ <br>    if (fread(magic, MAGICBYTES, 1, fp) != 1) <br>return FALSE; <br>    if (magic[0] != 'P' || magic[1] != '6') <br>return FALSE; <br> <br>    /* Now we can actually read some numbers */ <br>    if (!ppm_getint(fp, width)) <br>return FALSE; <br>    if (!ppm_getint(fp, height)) <br>return FALSE; <br>    if (!ppm_getint(fp, maxgrey)) <br>return FALSE; <br> <br>    /* Slurp up rest of white space so we get to actual data */ <br>    do { <br>if (!ppm_getbyte(fp, &amp;cchar)) <br>    return FALSE; <br>    } while (cchar == ' ' || cchar == '\t' || cchar == '\n' || cchar == '\r'); <br> <br>    fseek(fp, -1, SEEK_CUR); <br> <br>    return TRUE; <br>} <br> <br> <br>/***************************************************************************/ <br>/*                         Finding Textures                                */ <br>/***************************************************************************/ <br> <br>#define MAXPATH    256 <br>#define PATHSEP    ';' <br>#define FILESEP    '\\' <br>#define MAXCONTENTS 25 <br>#define RESPATH     "Software\\Microsoft\\Direct3D" <br> <br>static int PathListInitialised = FALSE; <br> <br>/* <br> * PathList structure <br> * A list of directories in which to search for the texture. <br> */ <br>static struct { <br>    int count; <br>    char *contents[MAXCONTENTS]; <br>} PathList; <br> <br>/* <br> * D3DAppIAddPathList <br> * Add this string to the search path list <br> */ <br>static void  <br>D3DAppIAddPathList(const char *path) <br>{ <br>    char *p; <br>    char *elt; <br>    int len; <br> <br>    while (path) { <br>p = LSTRCHR(path, PATHSEP); <br>if (p) <br>    len = p - path; <br>else <br>    len = lstrlen(path); <br>elt = (char *) malloc(len + 1); <br>if (elt == NULL) <br>    return; <br>lstrcpyn(elt, path, len + 1); <br>elt[len] = '\0'; <br>PathList.contents[PathList.count] = elt; <br>PathList.count++; <br>if (p) <br>    path = p + 1; <br>else <br>    path = NULL; <br>if (PathList.count == MAXCONTENTS) <br>    return; <br>    } <br>    return; <br>} <br> <br>/* <br> * D3DAppIInitialisePathList <br> * Create a search path with the D3DPATH env. var and D3D Path registry entry <br> */ <br>static void  <br>D3DAppIInitialisePathList() <br>{ <br>    long result; <br>    HKEY key; <br>    DWORD type, size; <br>    static char buf[512]; <br>    char* path; <br> <br>    if (PathListInitialised) <br>return; <br>    PathListInitialised = TRUE; <br> <br>    PathList.count = 0; <br>    path = getenv("D3DPATH"); <br>    D3DAppIAddPathList("."); <br>    if (path != NULL) { <br>        D3DAppIAddPathList(path); <br>        return; <br>    } <br>    result = RegOpenKeyEx(HKEY_LOCAL_MACHINE, RESPATH, 0, KEY_READ, &amp;key); <br>    if (result == ERROR_SUCCESS) { <br>        size = sizeof(buf); <br>result = RegQueryValueEx(key, "D3D Path", NULL, &amp;type, (LPBYTE) buf, <br>                         &amp;size); <br>RegCloseKey(key); <br>if (result == ERROR_SUCCESS &amp;&amp; type == REG_SZ) <br>    D3DAppIAddPathList(buf); <br>    } <br>} <br> <br> <br>/* <br> * D3DAppIFindFile <br> * Find and open a file using the current search path. <br> */ <br>static FILE* <br>D3DAppIFindFile(const char *name, const char *mode) <br>{ <br>    FILE *fp; <br>    char buf[MAXPATH]; <br>    static char filesep[] = {FILESEP, 0}; <br>    int i; <br> <br>    D3DAppIInitialisePathList(); <br> <br>    fp = fopen(name, mode); <br>    if (fp != NULL) <br>return fp; <br> <br>    for (i = 0; i &lt; PathList.count; i++) { <br>lstrcpy(buf, PathList.contents[i]); <br>lstrcat(buf, filesep); <br>lstrcat(buf, name); <br>fp = fopen(buf, mode); <br>if (fp) <br>    return fp; <br>    } <br>    return NULL; <br>} <br> <br>/* <br> * D3DAppIReleasePathList <br> * Release the path list for program termination <br> */ <br>void <br>D3DAppIReleasePathList(void) <br>{ <br>    int i; <br>    for (i = 0; i &lt; PathList.count; i++) { <br>        free(PathList.contents[i]); <br>        PathList.contents[i] = NULL; <br>    } <br>    PathList.count = 0; <br>    PathListInitialised = FALSE; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
