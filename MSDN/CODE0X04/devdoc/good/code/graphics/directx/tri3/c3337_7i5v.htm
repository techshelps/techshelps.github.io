<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>D3DMAIN.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3343"></a>D3DMAIN.CPP</h2>
<pre><code>/* <br> *  Copyright (C) 1995, 1996 Microsoft Corporation. All Rights Reserved. <br> * <br> *  File: d3dmain.cpp <br> * <br> *  Each of the Direct3D samples must be linked with this file.  It contains <br> *  the code which allows them to run in the Windows environment. <br> * <br> *  A window is created using d3dmain.res which allows the user to select the <br> *  Direct3D driver to use and change the render options.  The D3DApp <br> *  collection of functions is used to initialize DirectDraw, Direct3D and <br> *  keep surfaces and D3D devices available for rendering. <br> * <br> *  Frame rate and a screen mode information buffer is Blt'ed to the screen <br> *  by functions in stats.cpp. <br> * <br> *  Each sample is executed through the functions: InitScene, InitView, <br> *  RenderScene, ReleaseView, ReleaseScene and OverrideDefaults, as described <br> *  in d3ddemo.h.  Samples can also read mouse and keyboard input via <br> *  SetMouseCallback and SetKeyboardCallback. <br> */ <br> <br>#include "d3dmain.h" <br> <br>/* <br> * GLOBAL VARIABLES <br> */ <br>D3DAppInfo* d3dapp;    /* Pointer to read only collection of DD and D3D <br>       objects maintained by D3DApp */ <br>d3dmainglobals myglobs;    /* collection of global variables */ <br> <br>BOOL(*MouseHandler)(UINT, WPARAM, LPARAM);    /* sample's function which traps <br> mouse input */ <br>BOOL(*KeyboardHandler)(UINT, WPARAM, LPARAM); /* sample's functions which traps <br>                                                 keyboard input */ <br> <br>/* <br> *  INTERNAL FUNCTION PROTOTYPES <br> */ <br>static BOOL AppInit(HINSTANCE hInstance, LPSTR lpCmdLine); <br>static BOOL CreateD3DApp(LPSTR lpCmdLine); <br>static BOOL BeforeDeviceDestroyed(LPVOID lpContext); <br>static BOOL AfterDeviceCreated(int w, int h, LPDIRECT3DVIEWPORT2* lpViewport, <br>       LPVOID lpContext); <br>void CleanUpAndPostQuit(void); <br>static void InitGlobals(void); <br>static BOOL AppPause(BOOL f); <br>void ReportD3DAppError(void); <br>static BOOL RenderLoop(void); <br>static BOOL RestoreSurfaces(); <br>long FAR PASCAL WindowProc(HWND hWnd, UINT message, WPARAM wParam, <br>   LPARAM lParam ); <br> <br>/****************************************************************************/ <br>/*                            WinMain                                       */ <br>/****************************************************************************/ <br>/* <br> * Initializes the application then enters a message loop which calls sample's <br> * RenderScene until a quit message is received. <br> */ <br>int PASCAL <br>WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <br>int nCmdShow) <br>{ <br>    int failcount = 0; /* number of times RenderLoop has failed */ <br>    MSGmsg; <br>    HACCEL hAccelApp; <br> <br>    hPrevInstance; <br>    /* <br>     * Create the window and initialize all objects needed to begin rendering <br>     */ <br>    if(!AppInit(hInstance, lpCmdLine)) <br>    return FALSE; <br>    hAccelApp = LoadAccelerators(hInstance, "AppAccel");     <br> <br>    while (!myglobs.bQuit) { <br>/*  <br> * Monitor the message queue until there are no pressing <br> * messages <br> */ <br>        if (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) { <br>            if (msg.message == WM_QUIT) { <br>CleanUpAndPostQuit(); <br>                break; <br>    } <br>            if (!myglobs.hWndMain || !TranslateAccelerator(myglobs.hWndMain, <br>   hAccelApp, &amp;msg)) { <br>                TranslateMessage(&amp;msg);  <br>                DispatchMessage(&amp;msg); <br>            } <br>/*  <br> * If the app is not minimized, not about to quit, not paused, either the <br> * active fullscreen app or in a window and D3D has been initialized, <br> * we can render <br> */ <br>        } else if (d3dapp-&gt;bRenderingIsOK &amp;&amp; !d3dapp-&gt;bMinimized  <br>   &amp;&amp; !d3dapp-&gt;bPaused &amp;&amp; !myglobs.bQuit <br>   &amp;&amp; (d3dapp-&gt;bAppActive || !d3dapp-&gt;bFullscreen)) { <br>    /* <br>     * If were are not in single step mode or if we are and the <br>     * bDrawAFrame flag is set, render one frame <br>     */ <br>            if (!(myglobs.bSingleStepMode &amp;&amp; !myglobs.bDrawAFrame)) { <br>/*  <br> * Attempt to render a frame, if it fails, take a note.  If <br> * rendering fails more than twice, abort execution. <br> */ <br>if (!RenderLoop()) { <br>    ++failcount; <br>    if (failcount == 3) { <br>Msg("Rendering has failed too many times.  Aborting execution.\n"); <br>CleanUpAndPostQuit(); <br>break; <br>    } <br>} <br>    } <br>    /* <br>     * Reset the bDrawAFrame flag if we are in single step mode <br>     */ <br>            if (myglobs.bSingleStepMode) <br>                myglobs.bDrawAFrame = FALSE; <br>        } else { <br>            WaitMessage(); <br>} <br>    } <br> <br>    DestroyWindow(myglobs.hWndMain); <br>    return msg.wParam; <br>} <br> <br>/****************************************************************************/ <br>/*             D3DApp Initialization and callback functions                 */ <br>/****************************************************************************/ <br>/* <br> * AppInit <br> * Creates the window and initializes all objects necessary to begin rendering <br> */ <br>static BOOL <br>AppInit(HINSTANCE hInstance, LPSTR lpCmdLine) <br>{ <br>    WNDCLASS wc; <br> <br>    /* <br>     * Initialize the global variables <br>     */ <br>    InitGlobals(); <br>    myglobs.hInstApp = hInstance; <br>    /* <br>     * Register the window class <br>     */ <br>    wc.style = CS_HREDRAW | CS_VREDRAW; <br>    wc.lpfnWndProc = WindowProc; <br>    wc.cbClsExtra = 0; <br>    wc.cbWndExtra = 0; <br>    wc.hInstance = hInstance; <br>    wc.hIcon = LoadIcon( hInstance, "AppIcon"); <br>    wc.hCursor = LoadCursor( NULL, IDC_ARROW ); <br>    wc.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH); <br>    wc.lpszMenuName = "AppMenu"; <br>    wc.lpszClassName = "Example"; <br>    if (!RegisterClass(&amp;wc)) <br>        return FALSE; <br>    /* <br>     * Create a window with some default settings that may change <br>     */ <br>    myglobs.hWndMain = CreateWindowEx( <br>         WS_EX_APPWINDOW, <br> "Example", <br> "D3D Example", <br> WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | <br> WS_THICKFRAME | WS_MINIMIZEBOX, <br>         CW_USEDEFAULT, CW_USEDEFAULT, <br> START_WIN_SIZE, START_WIN_SIZE, <br>         NULL,    /* parent window */ <br> NULL,    /* menu handle */ <br> hInstance,    /* program handle */ <br> NULL);    /* create parms */ <br>    if (!myglobs.hWndMain){ <br>    Msg("CreateWindowEx failed"); <br>    return FALSE; <br>    } <br>    /* <br>     * Display the window <br>     */ <br>    ShowWindow(myglobs.hWndMain, SW_SHOWNORMAL); <br>    UpdateWindow(myglobs.hWndMain); <br>    /*  <br>     * Have the example initialize it components which remain constant <br>     * throughout execution <br>     */ <br>    if (!InitScene()) <br>        return FALSE; <br>    /* <br>     * Call D3DApp to initialize all DD and D3D objects necessary to render. <br>     * D3DApp will call the device creation callback which will initialize the <br>     * viewport and the sample's execute buffers. <br>     */ <br>    if (!CreateD3DApp(lpCmdLine)) <br>return FALSE; <br> <br>    return TRUE; <br>} <br> <br>/* <br> * CreateD3DApp <br> * Create all DirectDraw and Direct3D objects necessary to begin rendering. <br> * Add the list of D3D drivers to the file menu. <br> */ <br>static BOOL <br>CreateD3DApp(LPSTR lpCmdLine) <br>{ <br>    HMENU hmenu; <br>    int i; <br>    LPSTR option; <br>    BOOL bOnlySystemMemory, bOnlyEmulation; <br>    DWORD flags; <br>    Defaults defaults; <br> <br>    /* <br>     * Give D3DApp a list of textures to keep track of. <br>     */ <br>    D3DAppAddTexture("checker.ppm"); <br>    D3DAppAddTexture("tex2.ppm"); <br>    D3DAppAddTexture("tex7.ppm"); <br>    D3DAppAddTexture("win95.ppm"); <br>    /* <br>     * Parse the command line in seach of one of the following options: <br>     *     systemmemory  All surfaces should be created in system memory. <br>     *                   Hardware DD and D3D devices are disabled, but <br>     *                   debugging during the Win16 lock becomes possible. <br>     *     emulation     Do not use hardware DD or D3D devices. <br>     */ <br>    bOnlySystemMemory = FALSE; <br>    bOnlyEmulation = FALSE; <br>    option = strtok(lpCmdLine, " -"); <br>    while(option != NULL )   { <br>        if (!lstrcmp(option, "systemmemory")) { <br>            bOnlySystemMemory = TRUE; <br>        } else if (!lstrcmp(option, "emulation")) { <br>    bOnlyEmulation = TRUE; <br>} else { <br>            Msg("Invalid command line options given.\nLegal options: -systemmemory, -emulation\n"); <br>            return FALSE; <br>        } <br>        option = strtok(NULL, " -"); <br>    } <br>    /* <br>     * Set the flags to pass to the D3DApp creation based on command line <br>     */ <br>    flags = ((bOnlySystemMemory) ? D3DAPP_ONLYSYSTEMMEMORY : 0) |  <br>    ((bOnlyEmulation) ? (D3DAPP_ONLYD3DEMULATION | <br> D3DAPP_ONLYDDEMULATION) : 0); <br>    /* <br>     * Create all the DirectDraw and D3D objects neccesary to render.  The <br>     * AfterDeviceCreated callback function is called by D3DApp to create the <br>     * viewport and the example's execute buffers. <br>     */ <br>    if (!D3DAppCreateFromHWND(flags, myglobs.hWndMain, AfterDeviceCreated, <br>      NULL, BeforeDeviceDestroyed, NULL, &amp;d3dapp)) { <br>ReportD3DAppError(); <br>return FALSE; <br>    } <br>    /* <br>     * Add the the list of display modes D3DApp found to the mode menu <br>     */ <br>    hmenu = GetSubMenu(GetMenu(myglobs.hWndMain), 4); <br>    for (i = 0; i &lt; d3dapp-&gt;NumModes; i++) { <br>        char ach[80]; <br>        wsprintf(ach,"%dx%dx%d", d3dapp-&gt;Mode[i].w, d3dapp-&gt;Mode[i].h, <br> d3dapp-&gt;Mode[i].bpp); <br>        AppendMenu(hmenu, MF_STRING, MENU_FIRST_MODE+i, ach); <br>    } <br>    /* <br>     * Add the list of D3D drivers D3DApp foudn to the file menu <br>     */ <br>    hmenu = GetSubMenu(GetMenu(myglobs.hWndMain), 0); <br>    for (i = 0; i &lt; d3dapp-&gt;NumDrivers; i++) { <br>        InsertMenu(hmenu, 6 + i, MF_BYPOSITION | MF_STRING, <br>   MENU_FIRST_DRIVER + i, d3dapp-&gt;Driver[i].Name); <br>    } <br>    /* <br>     * Allow the sample to override the default render state and other <br>     * settings <br>     */ <br>    if (!D3DAppGetRenderState(&amp;defaults.rs)) { <br>ReportD3DAppError(); <br>return FALSE; <br>    } <br>    lstrcpy(defaults.Name, "D3D Example"); <br>    defaults.bTexturesDisabled = FALSE; <br>    defaults.bResizingDisabled = myglobs.bResizingDisabled; <br>    defaults.bClearsOn = myglobs.bClearsOn; <br>    OverrideDefaults(&amp;defaults); <br>    myglobs.bClearsOn = defaults.bClearsOn; <br>    myglobs.bResizingDisabled = defaults.bResizingDisabled; <br>    /* <br>     * Apply any changes to the render state <br>     */ <br>    memcpy(&amp;myglobs.rstate, &amp;defaults.rs, sizeof(D3DAppRenderState)); <br>    if (!D3DAppSetRenderState(&amp;myglobs.rstate)) { <br>ReportD3DAppError(); <br>return FALSE; <br>    } <br>    /* <br>     * If I should begin with textures off, disable them and re-create <br>     * the view. <br>     */ <br>    if (defaults.bTexturesDisabled) { <br>if (!D3DAppDisableTextures(defaults.bTexturesDisabled)) { <br>    ReportD3DAppError(); <br>    return FALSE; <br>} <br>/* <br> * Release all objects (ie execute buffers) created by InitView <br> */ <br>ReleaseView(d3dapp-&gt;lpD3DViewport); <br>/* <br> * Create the sample's execute buffers via InitView <br> */ <br>if (!InitView(d3dapp-&gt;lpDD, d3dapp-&gt;lpD3D, d3dapp-&gt;lpD3DDevice, <br>      d3dapp-&gt;lpD3DViewport, d3dapp-&gt;NumUsableTextures, <br>      d3dapp-&gt;TextureHandle)) { <br>    Msg("InitView failed.\n"); <br>    CleanUpAndPostQuit(); <br>    return FALSE; <br>} <br>    } <br> <br>    SetWindowText(myglobs.hWndMain, defaults.Name); <br> <br>    return TRUE; <br>} <br> <br>/* <br> * AfterDeviceCreated <br> * D3DApp will call this function immediately after the D3D device has been <br> * created (or re-created).  D3DApp expects the D3D viewport to be created and <br> * returned.  The sample's execute buffers are also created (or re-created) <br> * here. <br> */ <br>static BOOL <br>AfterDeviceCreated(int w, int h, LPDIRECT3DVIEWPORT2* lplpViewport, LPVOID lpContext) <br>{ <br>    HMENU hmenu; <br>    int i; <br>    char ach[20]; <br>    LPDIRECT3DVIEWPORT2 lpD3DViewport; <br>    HRESULT rval; <br> <br>    /* <br>     * Create the D3D viewport object <br>     */ <br>    rval = d3dapp-&gt;lpD3D-&gt;CreateViewport(&amp;lpD3DViewport, NULL); <br>    if (rval != D3D_OK) { <br>    Msg("Create D3D viewport failed.\n%s", D3DAppErrorToString(rval)); <br>CleanUpAndPostQuit(); <br>return FALSE; <br>    } <br>    /* <br>     * Add the viewport to the D3D device <br>     */ <br>    rval = d3dapp-&gt;lpD3DDevice-&gt;AddViewport(lpD3DViewport); <br>    if (rval != D3D_OK) { <br>    Msg("Add D3D viewport failed.\n%s", D3DAppErrorToString(rval)); <br>CleanUpAndPostQuit(); <br>return FALSE; <br>    } <br>    /* <br>     * Setup the viewport for a reasonable viewing area <br>     */ <br>    D3DVIEWPORT2 viewData; <br>    memset(&amp;viewData, 0, sizeof(D3DVIEWPORT2)); <br>    viewData.dwSize = sizeof(D3DVIEWPORT2); <br>    viewData.dwX = viewData.dwY = 0; <br>    viewData.dwWidth = w; <br>    viewData.dwHeight = h; <br>viewData.dvClipX = -1.0f; <br>viewData.dvClipWidth = 2.0f; <br>viewData.dvClipHeight = h * 2.0f / w; <br>viewData.dvClipY = viewData.dvClipHeight / 2.0f; <br>viewData.dvMinZ = 0.0f; <br>viewData.dvMaxZ = 1.0f; <br>    rval = lpD3DViewport-&gt;SetViewport2(&amp;viewData); <br>    if (rval != D3D_OK) { <br>    Msg("SetViewport failed.\n%s", D3DAppErrorToString(rval)); <br>CleanUpAndPostQuit(); <br>return FALSE; <br>    } <br>    /* <br>     * Return the viewport to D3DApp so it can use it <br>     */ <br>    *lplpViewport = lpD3DViewport; <br>    /* <br>     * Create the sample's execute buffers via InitView <br>     */ <br>    if (!InitView(d3dapp-&gt;lpDD, d3dapp-&gt;lpD3D, d3dapp-&gt;lpD3DDevice, <br>  lpD3DViewport, d3dapp-&gt;NumUsableTextures, <br>  d3dapp-&gt;TextureHandle)) { <br>Msg("InitView failed.\n"); <br>CleanUpAndPostQuit(); <br>return FALSE; <br>    } <br>    /* <br>     * Add the list of texture formats found by D3DApp to the texture menu <br>     */ <br>    hmenu = GetSubMenu(GetMenu(myglobs.hWndMain), 3); <br>    for (i = 0; i &lt; d3dapp-&gt;NumTextureFormats; i++) { <br>if (d3dapp-&gt;TextureFormat[i].bPalettized) { <br>    wsprintf(ach, "%d-bit Palettized", <br>     d3dapp-&gt;TextureFormat[i].IndexBPP); <br>} else { <br>    wsprintf(ach, "%d%d%d RGB", d3dapp-&gt;TextureFormat[i].RedBPP, <br>     d3dapp-&gt;TextureFormat[i].GreenBPP, <br>     d3dapp-&gt;TextureFormat[i].BlueBPP); <br>} <br>        AppendMenu(hmenu, MF_STRING, MENU_FIRST_FORMAT + i, ach); <br>    } <br>    /* <br>     * Create and initialize the surfaces containing the frame rate and <br>     * window information <br>     */ <br>    if (!InitFontAndTextBuffers()) { <br>Msg("InitFontAndTextBuffers failed.\n"); <br>CleanUpAndPostQuit(); <br>return FALSE; <br>} <br> <br>    return TRUE; <br>} <br> <br>/* <br> * BeforeDeviceDestroyed <br> * D3DApp will call this function before the current D3D device is destroyed <br> * to give the app the opportunity to destroy objects it has created with the <br> * DD or D3D objects. <br> */ <br>static BOOL <br>BeforeDeviceDestroyed(LPVOID lpContext) <br>{ <br>    HMENU hmenu; <br>    int i; <br>    /* <br>     * Release the font object and buffers containing stats <br>     */ <br>    ReleaseFontAndTextBuffers(); <br>    /* <br>     * Release all objects (ie execute buffers) created by InitView <br>     */ <br>    ReleaseView(d3dapp-&gt;lpD3DViewport); <br>    /* <br>     * Since we created the viewport it is our responsibility to release <br>     * it.  Use D3DApp's pointer to it since we didn't save one. <br>     */ <br>    d3dapp-&gt;lpD3DViewport-&gt;Release(); <br>    /* <br>     * Delete the list of texture formats from the texture menu because <br>     * they are likely to change <br>     */ <br>    if (myglobs.hWndMain) { <br>hmenu = GetSubMenu(GetMenu(myglobs.hWndMain), 3); <br>if (hmenu) { <br>    for (i = 0; i &lt; d3dapp-&gt;NumTextureFormats; i++) { <br>DeleteMenu(hmenu, MENU_FIRST_FORMAT + i, MF_BYCOMMAND); <br>    } <br>} <br>    } <br>    return TRUE; <br>} <br> <br>/****************************************************************************/ <br>/*                            Rendering loop                                */ <br>/****************************************************************************/ <br>/* <br> * RenderLoop <br> * Render the next frame and update the window <br> */ <br>static BOOL <br>RenderLoop() <br>{ <br>    D3DRECT extents[D3DAPP_MAXCLEARRECTS]; <br>    int count; <br>    /* <br>     * If all the DD and D3D objects have been initialized we can render <br>     */ <br>    if (d3dapp-&gt;bRenderingIsOK) { <br>/* <br> * Restore any lost surfaces <br> */ <br>        if (!RestoreSurfaces()) { <br>    /* <br>     * Restoring surfaces sometimes fails because the surfaces cannot <br>     * yet be restored.  If this is the case, the error will show up <br>     * somewhere else and we should return success here to prevent <br>     * unnecessary error's being reported. <br>     */ <br>    return TRUE; <br>} <br>/* <br> * Calculate the frame rate <br> */ <br>        if (!CalculateFrameRate()) <br>    return FALSE; <br> <br>        /* <br>         * Clear the back buffer and Z buffer if enabled.  If bResized is set, <br> * clear the entire window. <br>         */ <br>if (myglobs.bClearsOn) { <br>    if (!D3DAppClearBackBuffer(myglobs.bResized ? <br>       D3DAPP_CLEARALL : NULL)) { <br>ReportD3DAppError(); <br>return FALSE; <br>    } <br>} <br>/* <br> * Call the sample's RenderScene to render this frame <br> */ <br>{ <br>// init the extent to something wrong <br>extents[0].x1 = 2048; <br>extents[0].x2 = 0; <br>extents[0].y1 = 2048; <br>extents[0].y2 = 0; <br>    if (!RenderScene(d3dapp-&gt;lpD3DDevice, d3dapp-&gt;lpD3DViewport, <br>     &amp;extents[0])) { <br>Msg("RenderScene failed.\n"); <br>return FALSE; <br>    } <br>    count = 1; <br>} <br>/* <br> * Blt the frame rate and window stat text to the back buffer <br> */ <br>        if (!DisplayFrameRate(&amp;count, &amp;extents[1])) <br>    return FALSE; <br>/* <br> * Give D3DApp the extents so it can keep track of dirty sections of <br> * the back and front buffers.  Look to see if the extent from RenderScene <br> * changed any.  If not, skip it's dirty rect. <br> */ <br> <br>if (extents[0].x1 == 2048.0) {// nothing changed <br>if (!D3DAppRenderExtents(count-1, &amp;extents[1], myglobs.bResized ? <br> D3DAPP_CLEARALL : NULL)) { <br>ReportD3DAppError(); <br>return FALSE; <br>} <br>} else { <br>// correct for not quite right extent behavior in some drivers <br>if (extents[0].x1 != 0) <br>extents[0].x1 -= 1; <br>if (extents[0].y1 != 0) <br>extents[0].y1 -= 1; <br>if (!D3DAppRenderExtents(count, extents, myglobs.bResized ? <br> D3DAPP_CLEARALL : NULL)) { <br>ReportD3DAppError(); <br>return FALSE; <br>} <br>} <br>/* <br> * Blt or flip the back buffer to the front buffer.  Don't report an <br> * error if this fails. <br> */ <br>D3DAppShowBackBuffer(myglobs.bResized ? D3DAPP_SHOWALL : NULL); <br> <br>/* <br> * Reset the resize flag <br> */ <br>        myglobs.bResized = FALSE; <br>    } <br>    return TRUE; <br>} <br> <br>/* <br> * AppPause <br> * Pause and unpause the application <br> */ <br>static BOOL <br>AppPause(BOOL f) <br>{ <br>    /* <br>     * Flip to the GDI surface and halt rendering <br>     */ <br>    if (!D3DAppPause(f)) <br>return FALSE; <br>    /* <br>     * When returning from a pause, reset the frame rate count <br>     */ <br>    if (!f) { <br>        ResetFrameRate(); <br>    } <br>    return TRUE; <br>} <br> <br>/* <br> * RestoreSurfaces <br> * Restores any lost surfaces.  Returns TRUE if all surfaces are not lost and <br> * FALSE if one or more surfaces is lost and can not be restored at the <br> * moment. <br> */ <br>static BOOL <br>RestoreSurfaces() <br>{ <br>    HRESULT d3drval; <br> <br>    /* <br>     * Have D3DApp check all the surfaces it's in charge of <br>     */ <br>    if (!D3DAppCheckForLostSurfaces()) { <br>            return FALSE; <br>    } <br>    /* <br>     * Check frame rate and info surfaces and re-write them if they <br>     * were lost. <br>     */ <br>    if (myglobs.lpFrameRateBuffer-&gt;IsLost() == DDERR_SURFACELOST) { <br>        d3drval = myglobs.lpFrameRateBuffer-&gt;Restore(); <br>        if (d3drval != DD_OK) { <br>            return FALSE; <br>        } <br>if (!WriteFrameRateBuffer(0.0f, 0)) <br>    return FALSE; <br>    } <br>    if (myglobs.lpInfoBuffer-&gt;IsLost() == DDERR_SURFACELOST) { <br>        d3drval = myglobs.lpInfoBuffer-&gt;Restore(); <br>        if (d3drval != DD_OK) { <br>            return FALSE; <br>        } <br>if (!WriteInfoBuffer()) <br>    return FALSE; <br>    } <br>    return TRUE; <br>} <br> <br> <br>/************************************************************************* <br>  Windows message handlers <br> *************************************************************************/ <br>/* <br> * AppAbout <br> * About box message handler <br> */ <br>BOOL <br>FAR PASCAL AppAbout(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>  switch (msg) <br>  { <br>    case WM_COMMAND: <br>      if (LOWORD(wParam) == IDOK) <br>        EndDialog(hwnd, TRUE); <br>      break; <br> <br>    case WM_INITDIALOG: <br>      return TRUE; <br>  } <br>  return FALSE; <br>} <br> <br>/* <br> * WindowProc <br> * Main window message handler. <br> */ <br>long <br>FAR PASCAL WindowProc(HWND hWnd, UINT message, WPARAM wParam, <br>   LPARAM lParam ) <br>{ <br>    int i; <br>    BOOL bStop; <br>    LRESULT lresult; <br> <br>    /* <br>     * Give D3DApp an opportunity to process any messages it MUST see in order <br>     * to perform it's function. <br>     */ <br>    if (!D3DAppWindowProc(&amp;bStop, &amp;lresult, hWnd, message, wParam, lParam)) { <br>ReportD3DAppError(); <br>CleanUpAndPostQuit(); <br>return 0; <br>    } <br> <br>    /* <br>     * Prevent resizing through this message <br>     */ <br>    if (message == WM_GETMINMAXINFO &amp;&amp; myglobs.bResizingDisabled &amp;&amp; !d3dapp-&gt;bFullscreen &amp;&amp; !d3dapp-&gt;bMinimized) { <br>RECT rc; <br>GetWindowRect(hWnd, &amp;rc); <br>((LPMINMAXINFO)lParam)-&gt;ptMaxTrackSize.x = START_WIN_SIZE; <br>((LPMINMAXINFO)lParam)-&gt;ptMaxTrackSize.y = START_WIN_SIZE; <br>((LPMINMAXINFO)lParam)-&gt;ptMinTrackSize.x = START_WIN_SIZE; <br>((LPMINMAXINFO)lParam)-&gt;ptMinTrackSize.y = START_WIN_SIZE; <br>        return 0; <br>    } <br> <br>    /*  <br>     * If bStop is set by D3DApp, the app should not process the message but <br>     * return lresult. <br>     */ <br>    if (bStop) <br>return lresult; <br> <br>    switch( message ) { <br>        case WM_MOUSEMOVE: <br>        case WM_LBUTTONDOWN: <br>        case WM_LBUTTONUP: <br>        case WM_RBUTTONDOWN: <br>        case WM_RBUTTONUP: <br>        case WM_MBUTTONDOWN: <br>        case WM_MBUTTONUP: <br>    /* <br>     * Call the sample's MouseHandler if available <br>     */ <br>            if (!MouseHandler) <br>                break; <br>            if ((MouseHandler)(message, wParam, lParam)) <br>                return 1; <br>            break; <br>        case WM_KEYDOWN: <br>    /* <br>     * Call the sample's keyboard handler if available <br>     */ <br>            if (!KeyboardHandler) <br>                break; <br>            if ((KeyboardHandler)(message, wParam, lParam)) <br>                return 1; <br>            break; <br>/* <br> * Pause and unpause the app when entering/leaving the menu <br> */ <br>        case WM_ENTERMENULOOP: <br>            AppPause(TRUE); <br>            break; <br>        case WM_EXITMENULOOP: <br>            AppPause(FALSE); <br>            break; <br>    case WM_DESTROY: <br>            myglobs.hWndMain = NULL; <br>            CleanUpAndPostQuit(); <br>            break; <br>        case WM_INITMENUPOPUP: <br>    /* <br>             * Check and enable the appropriate menu items <br>     */ <br>    if (d3dapp-&gt;ThisDriver.bDoesZBuffer) { <br>EnableMenuItem((HMENU)wParam, MENU_ZBUFFER, MF_ENABLED); <br>CheckMenuItem((HMENU)wParam, MENU_ZBUFFER, myglobs.rstate.bZBufferOn ? MF_CHECKED : MF_UNCHECKED); <br>    } else { <br>EnableMenuItem((HMENU)wParam, MENU_ZBUFFER, MF_GRAYED); <br>CheckMenuItem((HMENU)wParam, MENU_ZBUFFER, MF_UNCHECKED); <br>    } <br>            CheckMenuItem((HMENU)wParam, MENU_STEP, (myglobs.bSingleStepMode) ? MF_CHECKED : MF_UNCHECKED); <br>            EnableMenuItem((HMENU)wParam, MENU_GO, (myglobs.bSingleStepMode) ? MF_ENABLED : MF_GRAYED); <br>            CheckMenuItem((HMENU)wParam, MENU_FLAT, (myglobs.rstate.ShadeMode == D3DSHADE_FLAT) ? MF_CHECKED : MF_UNCHECKED); <br>            CheckMenuItem((HMENU)wParam, MENU_GOURAUD, (myglobs.rstate.ShadeMode == D3DSHADE_GOURAUD) ? MF_CHECKED : MF_UNCHECKED); <br>            CheckMenuItem((HMENU)wParam, MENU_PHONG, (myglobs.rstate.ShadeMode == D3DSHADE_PHONG) ? MF_CHECKED : MF_UNCHECKED); <br>    EnableMenuItem((HMENU)wParam, MENU_PHONG, MF_GRAYED); <br>            CheckMenuItem((HMENU)wParam, MENU_CLEARS, myglobs.bClearsOn ? MF_CHECKED : MF_UNCHECKED); <br>            CheckMenuItem((HMENU)wParam, MENU_POINT, (myglobs.rstate.FillMode == D3DFILL_POINT) ? MF_CHECKED : MF_UNCHECKED); <br>            CheckMenuItem((HMENU)wParam, MENU_WIREFRAME, (myglobs.rstate.FillMode == D3DFILL_WIREFRAME) ? MF_CHECKED : MF_UNCHECKED); <br>            CheckMenuItem((HMENU)wParam, MENU_SOLID, (myglobs.rstate.FillMode == D3DFILL_SOLID) ? MF_CHECKED : MF_UNCHECKED); <br>            CheckMenuItem((HMENU)wParam, MENU_DITHERING, myglobs.rstate.bDithering ? MF_CHECKED : MF_UNCHECKED); <br>            CheckMenuItem((HMENU)wParam, MENU_SPECULAR, myglobs.rstate.bSpecular ? MF_CHECKED : MF_UNCHECKED); <br>            EnableMenuItem((HMENU)wParam, MENU_SPECULAR, MF_ENABLED); <br>            CheckMenuItem((HMENU)wParam, MENU_FOG, myglobs.rstate.bFogEnabled ? MF_CHECKED : MF_UNCHECKED); <br>            CheckMenuItem((HMENU)wParam, MENU_ANTIALIAS, myglobs.rstate.bAntialiasing ? MF_CHECKED : MF_UNCHECKED); <br>    if (d3dapp-&gt;ThisDriver.bDoesTextures) { <br>CheckMenuItem((HMENU)wParam, MENU_TEXTURE_TOGGLE, (!d3dapp-&gt;bTexturesDisabled) ? MF_CHECKED : MF_UNCHECKED); <br>EnableMenuItem((HMENU)wParam, MENU_TEXTURE_TOGGLE, MF_ENABLED); <br>EnableMenuItem((HMENU)wParam, MENU_TEXTURE_SWAP, (d3dapp-&gt;bTexturesDisabled) ? MF_GRAYED : MF_ENABLED); <br>CheckMenuItem((HMENU)wParam, MENU_PERSPCORRECT, myglobs.rstate.bPerspCorrect ? MF_CHECKED : MF_UNCHECKED); <br>EnableMenuItem((HMENU)wParam, MENU_PERSPCORRECT, (d3dapp-&gt;bTexturesDisabled) ? MF_GRAYED : MF_ENABLED); <br>CheckMenuItem((HMENU)wParam, MENU_POINT_FILTER, (myglobs.rstate.TextureFilter == D3DFILTER_NEAREST) ? MF_CHECKED : MF_UNCHECKED); <br>EnableMenuItem((HMENU)wParam, MENU_POINT_FILTER, (d3dapp-&gt;bTexturesDisabled) ? MF_GRAYED : MF_ENABLED); <br>CheckMenuItem((HMENU)wParam, MENU_LINEAR_FILTER, (myglobs.rstate.TextureFilter == D3DFILTER_LINEAR) ? MF_CHECKED : MF_UNCHECKED); <br>EnableMenuItem((HMENU)wParam, MENU_LINEAR_FILTER, (d3dapp-&gt;bTexturesDisabled) ? MF_GRAYED : MF_ENABLED); <br>for (i = 0; i &lt; d3dapp-&gt;NumTextureFormats; i++) { <br>    CheckMenuItem((HMENU)wParam, MENU_FIRST_FORMAT + i, (i == d3dapp-&gt;CurrTextureFormat) ? MF_CHECKED : MF_UNCHECKED); <br>    EnableMenuItem((HMENU)wParam, MENU_FIRST_FORMAT + i, (d3dapp-&gt;bTexturesDisabled) ? MF_GRAYED : MF_ENABLED); <br>} <br>    } else { <br>EnableMenuItem((HMENU)wParam, MENU_TEXTURE_SWAP, MF_GRAYED); <br>EnableMenuItem((HMENU)wParam, MENU_TEXTURE_TOGGLE, MF_GRAYED); <br>EnableMenuItem((HMENU)wParam, MENU_POINT_FILTER, MF_GRAYED); <br>EnableMenuItem((HMENU)wParam, MENU_LINEAR_FILTER, MF_GRAYED); <br>EnableMenuItem((HMENU)wParam, MENU_PERSPCORRECT, MF_GRAYED); <br>    } <br>    if (d3dapp-&gt;bIsPrimary) { <br>CheckMenuItem((HMENU)wParam, MENU_FULLSCREEN, d3dapp-&gt;bFullscreen ? MF_CHECKED : MF_UNCHECKED); <br>EnableMenuItem((HMENU)wParam, MENU_FULLSCREEN, d3dapp-&gt;bFullscreen &amp;&amp; !d3dapp-&gt;ThisDriver.bCanDoWindow ? MF_GRAYED : MF_ENABLED); <br>EnableMenuItem((HMENU)wParam, MENU_NEXT_MODE, (!d3dapp-&gt;bFullscreen) ? MF_GRAYED : MF_ENABLED); <br>EnableMenuItem((HMENU)wParam, MENU_PREVIOUS_MODE, (!d3dapp-&gt;bFullscreen) ? MF_GRAYED : MF_ENABLED); <br>    } else { <br>EnableMenuItem((HMENU)wParam, MENU_FULLSCREEN, MF_GRAYED); <br>EnableMenuItem((HMENU)wParam, MENU_NEXT_MODE, MF_GRAYED); <br>EnableMenuItem((HMENU)wParam, MENU_PREVIOUS_MODE, MF_GRAYED); <br>    } <br>    for (i = 0; i &lt; d3dapp-&gt;NumModes; i++) { <br>CheckMenuItem((HMENU)wParam, MENU_FIRST_MODE + i, (i == d3dapp-&gt;CurrMode) ? MF_CHECKED : MF_UNCHECKED); <br>EnableMenuItem((HMENU)wParam, MENU_FIRST_MODE + i, (d3dapp-&gt;Mode[i].bThisDriverCanDo) ? MF_ENABLED : MF_GRAYED); <br>    } <br>            for (i = 0; i &lt; d3dapp-&gt;NumDrivers; i++) { <br>                CheckMenuItem((HMENU)wParam, MENU_FIRST_DRIVER + i, (i == d3dapp-&gt;CurrDriver) ? MF_CHECKED : MF_UNCHECKED); <br>            } <br>            break; <br>case WM_GETMINMAXINFO: <br>    /* <br>     * Some samples don't like being resized, such as those which use <br>     * screen coordinates (TLVERTEXs). <br>     */ <br>    if (myglobs.bResizingDisabled) { <br>((LPMINMAXINFO)lParam)-&gt;ptMaxTrackSize.x = START_WIN_SIZE; <br>((LPMINMAXINFO)lParam)-&gt;ptMaxTrackSize.y = START_WIN_SIZE; <br>((LPMINMAXINFO)lParam)-&gt;ptMinTrackSize.x = START_WIN_SIZE; <br>((LPMINMAXINFO)lParam)-&gt;ptMinTrackSize.y = START_WIN_SIZE; <br>return 0; <br>    } <br>    break; <br>        case WM_COMMAND: <br>            switch(LOWORD(wParam)) { <br>                case MENU_ABOUT: <br>                    AppPause(TRUE); <br>                    DialogBox(myglobs.hInstApp, "AppAbout", myglobs.hWndMain, (DLGPROC)AppAbout); <br>                    AppPause(FALSE); <br>                    break; <br>                case MENU_EXIT: <br>            CleanUpAndPostQuit(); <br>            break; <br>                case MENU_STEP: <br>    /* <br>     * Begin single step more or draw a frame if in single <br>     * step mode <br>     */ <br>                    if (!myglobs.bSingleStepMode) { <br>                        myglobs.bSingleStepMode = TRUE; <br>                        myglobs.bDrawAFrame = TRUE; <br>                    } else if (!myglobs.bDrawAFrame) { <br>                        myglobs.bDrawAFrame = TRUE; <br>                    } <br>                    break; <br>                case MENU_GO: <br>    /* <br>     * Exit single step mode <br>     */ <br>                    if (myglobs.bSingleStepMode) { <br>                        myglobs.bSingleStepMode = FALSE; <br>                        ResetFrameRate(); <br>                    } <br>                    break; <br>                case MENU_STATS: <br>    /* <br>     * Toggle output of frame rate and window info <br>     */ <br>                    if ((myglobs.bShowFrameRate) &amp;&amp; (myglobs.bShowInfo)) { <br>                        myglobs.bShowFrameRate = FALSE; <br>                        myglobs.bShowInfo = FALSE; <br>                        break; <br>                    } <br>                    if ((!myglobs.bShowFrameRate) &amp;&amp; (!myglobs.bShowInfo)) { <br>                        myglobs.bShowFrameRate = TRUE; <br>                        break; <br>                    } <br>                    myglobs.bShowInfo = TRUE; </code></pre>
<p>
</p>
<pre><code>break; <br>        case MENU_FULLSCREEN: <br>    if (d3dapp-&gt;bFullscreen) { <br>/* <br> * Return to a windowed mode.  Let D3DApp decide which <br> * D3D driver to use in case this one cannot render to <br> * the Windows display depth <br> */ <br>if (!D3DAppWindow(D3DAPP_YOUDECIDE, D3DAPP_YOUDECIDE)) { <br>    ReportD3DAppError(); <br>    CleanUpAndPostQuit(); <br>    break; <br>} <br>    } else { <br>/* <br> * Enter the current fullscreen mode.  D3DApp may <br> * resort to another mode if this driver cannot do <br> * the currently selected mode. <br> */ <br>if (!D3DAppFullscreen(d3dapp-&gt;CurrMode)) { <br>    ReportD3DAppError(); <br>    CleanUpAndPostQuit(); <br>    break; <br>} <br>    } <br>                break; <br>/* <br> * Texture filter method selection <br> */ <br>                case MENU_POINT_FILTER: <br>                    if (myglobs.rstate.TextureFilter == D3DFILTER_NEAREST) <br>                        break; <br>                    myglobs.rstate.TextureFilter = D3DFILTER_NEAREST; <br>                    if (!D3DAppSetRenderState(&amp;myglobs.rstate)) { <br>ReportD3DAppError(); <br>break; <br>    } <br>    break; <br>                case MENU_LINEAR_FILTER: <br>                    if (myglobs.rstate.TextureFilter == D3DFILTER_LINEAR) <br>                        break; <br>                    myglobs.rstate.TextureFilter = D3DFILTER_LINEAR; <br>                    if (!D3DAppSetRenderState(&amp;myglobs.rstate)) { <br>ReportD3DAppError(); <br>break; <br>    } <br>    break; <br>/*  <br> * Shading selection <br> */ <br>                case MENU_FLAT: <br>                    if (myglobs.rstate.ShadeMode == D3DSHADE_FLAT) <br>                        break; <br>                    myglobs.rstate.ShadeMode = D3DSHADE_FLAT; <br>                    if (!D3DAppSetRenderState(&amp;myglobs.rstate)) { <br>ReportD3DAppError(); <br>break; <br>    } <br>    break; <br>                case MENU_GOURAUD: <br>                    if (myglobs.rstate.ShadeMode == D3DSHADE_GOURAUD) <br>                        break; <br>                    myglobs.rstate.ShadeMode = D3DSHADE_GOURAUD; <br>                    if (!D3DAppSetRenderState(&amp;myglobs.rstate)) { <br>ReportD3DAppError(); <br>break; <br>    } <br>                    break; <br>                case MENU_PHONG: <br>                    if (myglobs.rstate.ShadeMode == D3DSHADE_PHONG) <br>                        break; <br>                    myglobs.rstate.ShadeMode = D3DSHADE_PHONG; <br>                    if (!D3DAppSetRenderState(&amp;myglobs.rstate)) { <br>ReportD3DAppError(); <br>break; <br>    } <br>                    break; <br>/* <br> * Fill mode selection <br> */ <br>                case MENU_POINT: <br>                    if (myglobs.rstate.FillMode == D3DFILL_POINT) <br>                        break; <br>                    myglobs.rstate.FillMode = D3DFILL_POINT; <br>                    if (!D3DAppSetRenderState(&amp;myglobs.rstate)) { <br>ReportD3DAppError(); <br>break; <br>    } <br>                    break; <br>                case MENU_WIREFRAME: <br>                    if (myglobs.rstate.FillMode == D3DFILL_WIREFRAME) <br>                        break; <br>                    myglobs.rstate.FillMode = D3DFILL_WIREFRAME; <br>                    if (!D3DAppSetRenderState(&amp;myglobs.rstate)) { <br>ReportD3DAppError(); <br>break; <br>    } <br>                    break; <br>                case MENU_SOLID: <br>                    if (myglobs.rstate.FillMode == D3DFILL_SOLID) <br>                        break; <br>                    myglobs.rstate.FillMode = D3DFILL_SOLID; <br>                    if (!D3DAppSetRenderState(&amp;myglobs.rstate)) { <br>ReportD3DAppError(); <br>break; <br>    } <br>                    break; <br>                case MENU_PERSPCORRECT: <br>    /* <br>     * Toggle perspective correction <br>     */ <br>                    myglobs.rstate.bPerspCorrect = <br>!myglobs.rstate.bPerspCorrect; <br>                    if (!D3DAppSetRenderState(&amp;myglobs.rstate)) { <br>ReportD3DAppError(); <br>break; <br>    } <br>                    break; <br>                case MENU_CLEARS: <br>    /* <br>     * Toggle the clearing the the back buffer and Z-buffer <br>     * and set the resized flag to clear the entire window <br>     */ <br>                    myglobs.bClearsOn = !myglobs.bClearsOn; <br>                    if (myglobs.bClearsOn) <br>                        myglobs.bResized = TRUE; <br>                    break; <br>                case MENU_ZBUFFER: <br>    /* <br>     * Toggle the use of a Z-buffer <br>     */ <br>                    myglobs.rstate.bZBufferOn = !myglobs.rstate.bZBufferOn; <br>                    if (!D3DAppSetRenderState(&amp;myglobs.rstate)) { <br>ReportD3DAppError(); <br>break; <br>    } <br>    break; <br>                case MENU_DITHERING: <br>    /* <br>     * Toggle dithering <br>     */ <br>                    myglobs.rstate.bDithering = !myglobs.rstate.bDithering; <br>                    if (!D3DAppSetRenderState(&amp;myglobs.rstate)) { <br>ReportD3DAppError(); <br>break; <br>    } <br>    break; <br>                case MENU_SPECULAR: <br>    /* <br>     * Toggle specular highlights <br>     */ <br>                    myglobs.rstate.bSpecular = !myglobs.rstate.bSpecular; <br>                    if (!D3DAppSetRenderState(&amp;myglobs.rstate)) { <br>ReportD3DAppError(); <br>break; <br>    } <br>    break; <br>                case MENU_FOG: <br>    /* <br>     * Toggle fog <br>     */ <br>                    myglobs.rstate.bFogEnabled = !myglobs.rstate.bFogEnabled; <br>                    if (!D3DAppSetRenderState(&amp;myglobs.rstate)) { <br>ReportD3DAppError(); <br>break; <br>    } <br>    break; <br>                case MENU_ANTIALIAS: <br>    /* <br>     * Toggle anti-aliasing <br>     */ <br>                    myglobs.rstate.bAntialiasing = <br>!myglobs.rstate.bAntialiasing; <br>                    if (!D3DAppSetRenderState(&amp;myglobs.rstate)) { <br>ReportD3DAppError(); <br>break; <br>    } <br>    break; <br>                case MENU_TEXTURE_TOGGLE: <br>    /* <br>     * Release the sample's execute buffers, toggle the <br>     * texture disabled state and recreate them. <br>     */ <br>    ReleaseView(d3dapp-&gt;lpD3DViewport); <br>    D3DAppDisableTextures(!d3dapp-&gt;bTexturesDisabled); <br>    { <br>if (!InitView(d3dapp-&gt;lpDD, d3dapp-&gt;lpD3D, <br>      d3dapp-&gt;lpD3DDevice, <br>      d3dapp-&gt;lpD3DViewport, <br>      d3dapp-&gt;NumUsableTextures, <br>      d3dapp-&gt;TextureHandle)) { <br>    Msg("InitView failed.\n"); <br>    CleanUpAndPostQuit(); <br>    break; <br>} <br>    } <br>    myglobs.bResized = TRUE; <br>    break; <br>case MENU_TEXTURE_SWAP: <br>    /* <br>     * Swap textures using the load command <br>     */ <br>    if (!D3DAppSwapTextures()) { <br>ReportD3DAppError(); <br>break; <br>    } <br>    /* <br>     * Just in case we have a texture background <br>     */ <br>    myglobs.bResized = TRUE; <br>    break; <br>case MENU_NEXT_MODE: <br>    /* <br>     * Enter the next usable fullscreen mode <br>     */ <br>    i = d3dapp-&gt;CurrMode; <br>    do { <br>++i; <br>if (i &gt;= d3dapp-&gt;NumModes) <br>    i = 0; <br>if (!d3dapp-&gt;Mode[i].bThisDriverCanDo) <br>    continue; <br>else { <br>    if (!D3DAppFullscreen(i)) { <br>ReportD3DAppError(); <br>CleanUpAndPostQuit(); <br>    } <br>    break; <br>} <br>    } while(i != d3dapp-&gt;CurrMode); <br>    break; <br>case MENU_PREVIOUS_MODE: <br>    /* <br>     * Enter the previous usable fullscreen mode <br>     */ <br>    i = d3dapp-&gt;CurrMode; <br>    do { <br>--i; <br>if (i &lt; 0) <br>    i = d3dapp-&gt;NumModes - 1; <br>if (!d3dapp-&gt;Mode[i].bThisDriverCanDo) <br>    continue; <br>else { <br>    if (!D3DAppFullscreen(i)) { <br>ReportD3DAppError(); <br>CleanUpAndPostQuit(); <br>    } <br>    break; <br>} <br>    } while(i != d3dapp-&gt;CurrMode); <br>                    break; <br>            } <br>            if (   LOWORD(wParam) &gt;= MENU_FIRST_FORMAT <br>&amp;&amp; LOWORD(wParam) &lt; MENU_FIRST_FORMAT + <br>    D3DAPP_MAXTEXTUREFORMATS <br>&amp;&amp; d3dapp-&gt;CurrTextureFormat != <br>    LOWORD(wParam) - MENU_FIRST_FORMAT) { <br>/* <br> * Release the sample's execute buffers, change the texture <br> * format and recreate the view. <br> */ <br>ReleaseView(d3dapp-&gt;lpD3DViewport); <br>if (!D3DAppChangeTextureFormat(LOWORD(wParam) - <br>         MENU_FIRST_FORMAT)) { <br>    ReportD3DAppError(); <br>    CleanUpAndPostQuit(); <br>} <br>{ <br>    if (!InitView(d3dapp-&gt;lpDD, d3dapp-&gt;lpD3D, <br>  d3dapp-&gt;lpD3DDevice, d3dapp-&gt;lpD3DViewport, <br>  d3dapp-&gt;NumUsableTextures, <br>  d3dapp-&gt;TextureHandle)) { <br>Msg("InitView failed.\n"); <br>CleanUpAndPostQuit(); <br>break; <br>    } <br>} <br>                ResetFrameRate(); <br>            } <br>            if (   LOWORD(wParam) &gt;= MENU_FIRST_DRIVER <br>&amp;&amp; LOWORD(wParam) &lt; MENU_FIRST_DRIVER + D3DAPP_MAXD3DDRIVERS <br>&amp;&amp; d3dapp-&gt;CurrDriver != LOWORD(wParam) - MENU_FIRST_DRIVER) { <br>/* <br> * Change the D3D driver <br> */ <br>if (!D3DAppChangeDriver(LOWORD(wParam) - MENU_FIRST_DRIVER, <br>NULL)) { <br>    ReportD3DAppError(); <br>    CleanUpAndPostQuit(); <br>} <br>            } <br>            if (   LOWORD(wParam) &gt;= MENU_FIRST_MODE <br>&amp;&amp; LOWORD(wParam) &lt; MENU_FIRST_MODE+100) { <br>/* <br> * Switch to the selected fullscreen mode <br> */ <br>if (!D3DAppFullscreen(LOWORD(wParam) - MENU_FIRST_MODE)) { <br>    ReportD3DAppError(); <br>    CleanUpAndPostQuit(); <br>} <br>            } <br>    /* <br>     * Whenever we receive a command in single step mode, draw a frame <br>     */ <br>    if (myglobs.bSingleStepMode) <br>myglobs.bDrawAFrame = TRUE; <br>            return 0L; <br>    } <br>    return DefWindowProc(hWnd, message, wParam, lParam); <br>} <br> <br> <br>/****************************************************************************/ <br>/*                 Setting up callbacks for examples                        */ <br>/****************************************************************************/ <br> /* <br>  * SetMouseCallback <br>  * Called in an example to set a callback function for all WM messages <br>  * dealing with the mouse.  The handler should return whether or not <br>  * it handled the message. <br>  */ <br>BOOL <br>SetMouseCallback(BOOL(*Handler)(UINT, WPARAM, LPARAM)) <br>{ <br>    MouseHandler = Handler; <br>    return TRUE; <br>} <br>  <br>/* <br> * SetKeyboardCallback <br> * Called in an example to set a callback function for all WM messages <br> * dealing with the keyboard. The handler should return whether or not it <br> * handled the message. <br> */ <br>BOOL <br>SetKeyboardCallback(BOOL(*Handler)(UINT, WPARAM, LPARAM)) { <br>     <br>    KeyboardHandler = Handler; <br>    return TRUE; <br>} <br> <br>/****************************************************************************/ <br>/*          Initialization, error reporting and release functions.          */ <br>/****************************************************************************/ <br>/* <br> * InitGlobals <br> * Called once at program initialization to initialize global variables. <br> */ <br>static void <br>InitGlobals(void) <br>{ <br>    d3dapp = NULL; <br>    memset(&amp;myglobs.rstate, 0, sizeof(myglobs.rstate)); <br>    memset(&amp;myglobs, 0, sizeof(myglobs)); <br>    myglobs.bClearsOn = TRUE; <br>    myglobs.bShowFrameRate = TRUE; <br>    myglobs.bShowInfo = TRUE; <br>    MouseHandler = NULL; <br>    KeyboardHandler = NULL; <br>} <br> <br>/* <br> * CleanUpAndPostQuit <br> * Release all D3D objects, post a quit message and set the bQuit flag <br> */ <br>void <br>CleanUpAndPostQuit(void) <br>{ <br>    if (myglobs.bQuit) <br>return; <br>    if (!D3DAppDestroy()) <br>ReportD3DAppError(); <br>    ReleaseScene(); <br>    myglobs.bQuit = TRUE; <br>    PostQuitMessage( 0 ); <br>} <br> <br>/* <br> * ReportD3DAppError <br> * Reports an error during a d3d app call. <br> */ <br>void <br>ReportD3DAppError(void) <br>{ <br>    Msg("%s", D3DAppLastErrorString()); <br>} <br> <br>/* Msg <br> * Message output for error notification. <br> */ <br>void __cdecl <br>Msg( LPSTR fmt, ... ) <br>{ <br>    char buff[256]; <br>    va_list va; <br> <br>    va_start( va, fmt ); <br>    wvsprintf( buff, fmt, va ); <br>    va_end( va ); <br>    lstrcat(buff, "\r\n"); <br>    AppPause(TRUE); <br>    if (d3dapp &amp;&amp; d3dapp-&gt;bFullscreen) <br>SetWindowPos(myglobs.hWndMain, HWND_NOTOPMOST, 0, 0, 0, 0, <br>     SWP_NOSIZE | SWP_NOMOVE); <br>    MessageBox( myglobs.hWndMain, buff, "D3D Example Message", MB_OK ); <br>    if (d3dapp &amp;&amp; d3dapp-&gt;bFullscreen) <br>SetWindowPos(myglobs.hWndMain, HWND_TOPMOST, 0, 0, 0, 0, <br>     SWP_NOSIZE | SWP_NOMOVE); <br>    AppPause(FALSE); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
