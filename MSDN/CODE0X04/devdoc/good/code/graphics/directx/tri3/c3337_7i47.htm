<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>D3DAPP.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3337"></a>D3DAPP.C</h2>
<pre><code>/* <br> *  Copyright (C) 1995, 1996 Microsoft Corporation. All Rights Reserved. <br> * <br> *  File: d3dapp.c <br> * <br> *  Top level D3DApp functions and internal global variables.  See <br> *  d3dapp.h for more information. <br> * <br> *  D3DApp is a collection of helper functions for Direct3D applications. <br> *  D3DApp consists of the following files: <br> *d3dapp.h    Main D3DApp header to be included by application <br> *      d3dappi.h   Internal header <br> *      d3dapp.c    D3DApp functions seen by application. <br> *      ddcalls.c   All calls to DirectDraw objects except textures <br> *      d3dcalls.c  All calls to Direct3D objects except textures <br> *      texture.c   Texture loading and managing texture list <br> *      misc.c    Miscellaneous calls <br> */ <br> <br>#include "d3dappi.h" <br> <br>#define INITGUID <br> <br>/***************************************************************************/ <br>/*                           GLOBAL VARIABLES                              */ <br>/***************************************************************************/ <br>/* <br> * All DD and D3D objects which are also available to the application <br> * See d3dapp.h for typedef <br> */ <br>D3DAppInfo d3dappi; <br>/* <br> * Internal record of the render state.  See d3dapp.h for typedef <br> */ <br>D3DAppRenderState d3dapprs;  <br>/*  <br> * Callback functions for D3D device creation and destruction <br> */ <br>BOOL(*D3DDeviceDestroyCallback)(LPVOID); <br>LPVOID D3DDeviceDestroyCallbackContext; <br>BOOL(*D3DDeviceCreateCallback)(int, int, LPDIRECT3DVIEWPORT2*, LPVOID); <br>LPVOID D3DDeviceCreateCallbackContext; <br>/* <br> * The last error code and string <br> */ <br>HRESULT LastError; <br>char LastErrorString[256]; <br>/* <br> * List of dirty rectangles on back buffer and client area <br> */ <br>int NumDirtyClientRects, NumDirtyBackRects, NumDirtyZRects; <br>D3DRECT DirtyClient[D3DAPP_MAXCLEARRECTS]; <br>D3DRECT DirtyBack[D3DAPP_MAXCLEARRECTS]; <br>D3DRECT DirtyZ[D3DAPP_MAXCLEARRECTS]; <br>/* <br> * List of texture handles which is copied to D3DAppInfo structure when <br> * necessary <br> */ <br>D3DTEXTUREHANDLE MasterTextureHandle[D3DAPP_MAXTEXTURES]; <br> <br>LPDIRECTDRAWCLIPPER lpClipper; /* Clipper in windowed case */ <br>LPDIRECTDRAWPALETTE lpPalette; /* Front buffer's palette */ <br>PALETTEENTRY ppe[256];         /* Current palette entries */ <br>PALETTEENTRY Originalppe[256]; /* Windows palette entries at startup */ <br>BOOL bD3DAppInitialized;       /* Is D3DApp initialized? */ <br>BOOL bPrimaryPalettized;       /* Is the front buffer palettized? */ <br>BOOL bPaletteActivate;       /* Is the front buffer's palette valid? */ <br>BOOL bIgnoreWM_SIZE;       /* Ignore this WM_SIZE messages */ <br>SIZE szLastClient;       /* Dimensions of the last window */ <br>SIZE szBuffers;       /* Current buffer dimensions, not necessarily <br>  the same as the client window */ <br>int CallbackRefCount;       /* How many times DeviceCreateCallback has <br>  been called in a row */ <br> <br>/***************************************************************************/ <br>/*                               FUNCTIONS                                 */ <br>/***************************************************************************/ <br>/* <br> * D3DAppCreateFromHWND <br> */ <br>BOOL D3DAppCreateFromHWND(DWORD flags, HWND hwnd, <br>  BOOL(*DeviceCreateCallback)(int, int, <br>      LPDIRECT3DVIEWPORT2*, <br>      LPVOID), <br>  LPVOID lpCreateContext, <br>  BOOL(*DeviceDestroyCallback)(LPVOID), <br>  LPVOID lpDestroyContext, <br>  D3DAppInfo** D3DApp) <br>{ <br>    int driver, mode, w, h; <br>    /*  <br>     * Clean the global varaibles and check the flags <br>     */ <br>    D3DAppISetDefaults(); <br>    if (flags &amp; D3DAPP_ONLYSYSTEMMEMORY) { <br>d3dappi.bOnlySystemMemory = TRUE; <br>d3dappi.bOnlyEmulation = TRUE; <br>    } <br>    if (flags &amp; D3DAPP_ONLYD3DEMULATION) <br>d3dappi.bOnlyEmulation = TRUE; <br>    /*  <br>     * Create DirectDraw, remember the Windows display mode and enumerate the <br>     * display modes <br>     */ <br>    ATTEMPT(D3DAppICreateDD(d3dappi.bOnlyEmulation ? <br>    D3DAPP_ONLYDDEMULATION : 0L)); <br>    ATTEMPT(D3DAppIRememberWindowsMode()); <br>    ATTEMPT(D3DAppIEnumDisplayModes()); <br>    /* <br>     * Create Direct3D and enumerate the D3D drivers <br>     */ <br>    ATTEMPT(D3DAppICreateD3D()); <br>    ATTEMPT(D3DAppIEnumDevices()); <br>    /* <br>     * Set the device creation and destroy callback functions <br>     */ <br>    D3DDeviceDestroyCallback = DeviceDestroyCallback; <br>    D3DDeviceDestroyCallbackContext = lpDestroyContext; <br>    D3DDeviceCreateCallback = DeviceCreateCallback; <br>    D3DDeviceCreateCallbackContext = lpCreateContext; <br>    *D3DApp = &amp;d3dappi; <br>    d3dappi.hwnd = hwnd; <br>    /* <br>     * Choose a driver and display mode.  Using the current window is  <br>     * prefered, but a fullscreen mode may be selected.  Set the cooperative <br>     * level and create the front and back buffers for this mode. <br>     */ <br>    driver = D3DAPP_YOUDECIDE; <br>    mode = D3DAPP_YOUDECIDE; <br>    ATTEMPT(D3DAppIVerifyDriverAndMode(&amp;driver, &amp;mode)); <br>    D3DAppIGetClientWin(hwnd); <br>    if (mode == D3DAPP_USEWINDOW) { <br>w = d3dappi.szClient.cx; <br>h = d3dappi.szClient.cy; <br>ATTEMPT(D3DAppISetCoopLevel(hwnd, FALSE)); <br>ATTEMPT(D3DAppICreateBuffers(hwnd, w, h, D3DAPP_BOGUS, FALSE, <br>     d3dappi.Driver[driver].bIsHardware)); <br>/* <br> * Change the currently selected mode if it's not compatible with <br> * this driver.  Just to make sure that CurrMode is always a mode the <br> * current driver can do. <br> */ <br>if (!(d3dappi.Driver[driver].Desc.dwDeviceRenderBitDepth &amp; <br>      D3DAppIBPPToDDBD(d3dappi.Mode[d3dappi.CurrMode].bpp))){ <br>    ATTEMPT(D3DAppIPickDisplayMode(&amp;d3dappi.CurrMode, <br>        d3dappi.Driver[driver].Desc.dwDeviceRenderBitDepth)); <br>} <br>    } else { <br>szLastClient = d3dappi.szClient; <br>w = d3dappi.Mode[mode].w; <br>h = d3dappi.Mode[mode].h; <br>d3dappi.szClient.cx = w; d3dappi.szClient.cy = h; <br>ATTEMPT(D3DAppISetCoopLevel(hwnd, TRUE)); <br>ATTEMPT(D3DAppISetDisplayMode(w, h, d3dappi.Mode[mode].bpp)); <br>d3dappi.CurrMode = mode; <br>ATTEMPT(D3DAppICreateBuffers(hwnd, w, h, d3dappi.Mode[mode].bpp, TRUE, <br>     d3dappi.Driver[driver].bIsHardware)); <br>    } <br>    /* <br>     * If the front buffer is palettized, initialize its palette <br>     */ <br>    ATTEMPT(D3DAppICheckForPalettized()); <br>    /* <br>     * Create the Z-buffer <br>     */ <br>    ATTEMPT(D3DAppICreateZBuffer(w, h, driver)); <br>    /* <br>     * Create the D3D device, load the textures, call the device create <br>     * callback and set a default render state <br>     */ <br>    ATTEMPT(D3DAppICreateDevice(driver)); <br>    ATTEMPT(D3DAppILoadAllTextures()); <br>    ATTEMPT(D3DAppIFilterDisplayModes(driver));  /* bThisDriverCanDo flags */ <br>    ATTEMPT(D3DAppICallDeviceCreateCallback(w, h)); <br>    ATTEMPT(D3DAppISetRenderState()); <br>    /*  <br>     * Initialize dirty rectangle information <br>     */ <br>    D3DAppIValidateDirtyRects(); <br>    /* <br>     * Ready to render <br>     */ <br>    bD3DAppInitialized = TRUE; <br>    d3dappi.bRenderingIsOK = TRUE; <br>    return TRUE; <br> <br>exit_with_error: <br>    D3DAppICallDeviceDestroyCallback(); <br>    RELEASE(d3dappi.lpD3DDevice); <br>    RELEASE(d3dappi.lpZBuffer); <br>    RELEASE(lpPalette); <br>    RELEASE(lpClipper); <br>    RELEASE(d3dappi.lpBackBuffer); <br>    RELEASE(d3dappi.lpFrontBuffer); <br>    if (d3dappi.bFullscreen) { <br>D3DAppIRestoreDispMode(); <br>D3DAppISetCoopLevel(hwnd, FALSE); <br>    } <br>    RELEASE(d3dappi.lpD3D); <br>    RELEASE(d3dappi.lpDD); <br>    return FALSE; <br>}    <br> <br>/* <br> * D3DAppFullscreen <br> */ <br>BOOL D3DAppFullscreen(int mode) <br>{ <br>    int w, h, bpp; <br>    BOOL b; /* was already in a fullscreen mode? */ <br> <br>    d3dappi.bRenderingIsOK = FALSE; <br>    /*  <br>     * Make sure this is a valid request, otherwise doctor mode so it will <br>     * work with this driver. <br>     */ <br>    ATTEMPT(D3DAppIVerifyDriverAndMode(&amp;d3dappi.CurrDriver, &amp;mode)); <br>    /*  <br>     * Release everything <br>     */ <br>    ATTEMPT(D3DAppICallDeviceDestroyCallback()); <br>    if (d3dappi.bFullscreen) { <br>ATTEMPT(D3DAppIClearBuffers()); <br>    } <br>    D3DAppIReleaseAllTextures(); <br>    RELEASE(d3dappi.lpD3DDevice); <br>    RELEASE(d3dappi.lpZBuffer); <br>    RELEASE(lpPalette); <br>    RELEASE(lpClipper); <br>    RELEASE(d3dappi.lpBackBuffer); <br>    RELEASE(d3dappi.lpFrontBuffer); <br>    /* <br>     * Record information about the current status <br>     */ <br>    b = d3dappi.bFullscreen; <br>    w = d3dappi.Mode[mode].w; <br>    h = d3dappi.Mode[mode].h; <br>    bpp = d3dappi.Mode[mode].bpp; <br>    if (!b) { <br>/* <br> * If this is not a fullscreen mode, we'll need to record the window <br> * size for when we return to it. <br> */ <br>szLastClient = d3dappi.szClient; <br>    } <br>    /* <br>     * Set the cooperative level and create front and back buffers <br>     */ <br>    d3dappi.szClient.cx = w; d3dappi.szClient.cy = h; <br>    ATTEMPT(D3DAppISetCoopLevel(d3dappi.hwnd, TRUE)); <br>    ATTEMPT(D3DAppISetDisplayMode(w, h, bpp)); <br>    d3dappi.CurrMode = mode; <br>    ATTEMPT(D3DAppICreateBuffers(d3dappi.hwnd, w, h, bpp, TRUE, <br> d3dappi.Driver[d3dappi.CurrDriver].bIsHardware)); <br>    /* <br>     * If the front buffer is palettized, initialize its palette <br>     */ <br>    ATTEMPT(D3DAppICheckForPalettized()); <br>    /* <br>     * Create the Z-buffer <br>     */ <br>    ATTEMPT(D3DAppICreateZBuffer(w, h, d3dappi.CurrDriver)); <br>    /* <br>     * Create the D3D device, load the textures, call the device create <br>     * callback and set a default render state <br>     */ <br>    ATTEMPT(D3DAppICreateDevice(d3dappi.CurrDriver)); <br>    ATTEMPT(D3DAppILoadAllTextures()); <br>    ATTEMPT(D3DAppICallDeviceCreateCallback(w, h)); <br>    ATTEMPT(D3DAppISetRenderState()); <br>    /*  <br>     * Set current mode and clear dirty rectangle information <br>     */ <br>    d3dappi.CurrMode = mode; <br>    D3DAppIValidateDirtyRects(); <br>    d3dappi.bRenderingIsOK = TRUE; <br>    return TRUE; <br> <br>exit_with_error: <br>    D3DAppICallDeviceDestroyCallback(); <br>    RELEASE(d3dappi.lpD3DDevice); <br>    RELEASE(d3dappi.lpZBuffer); <br>    RELEASE(lpPalette); <br>    RELEASE(lpClipper); <br>    RELEASE(d3dappi.lpBackBuffer); <br>    RELEASE(d3dappi.lpFrontBuffer); <br>    if (!b) { <br>D3DAppIRestoreDispMode(); <br>D3DAppISetCoopLevel(d3dappi.hwnd, FALSE); <br>    } <br>    return FALSE; <br>} <br> <br>/* <br> * D3DAppWindow <br> */ <br>BOOL <br>D3DAppWindow(int w, int h) <br>{ <br>    BOOL b; /* changing from a fullscreen mode? */ <br> <br>    if (!d3dappi.bIsPrimary) { <br>D3DAppISetErrorString("It is not possible to create a D3D window with a hardware DirectDraw device.  Check the bIsPrimary flag before calling D3DAppWindow."); <br>return FALSE; <br>    } <br>    b = d3dappi.bFullscreen; <br>    /* <br>     * If asked to set the window size, return it to the last value or use <br>     * a default value. <br>     */ <br>    if (w == D3DAPP_YOUDECIDE) { <br>w = b ? szLastClient.cx : D3DAPP_DEFAULTWINDOWDIM; <br>    } <br>    if (h == D3DAPP_YOUDECIDE) { <br>h = b ? szLastClient.cy : D3DAPP_DEFAULTWINDOWDIM; <br>    } <br>    /* <br>     * Release everything <br>     */ <br>    d3dappi.bRenderingIsOK = FALSE; <br>    ATTEMPT(D3DAppICallDeviceDestroyCallback()); <br>    if (b) { <br>ATTEMPT(D3DAppIClearBuffers()); <br>    } <br>    D3DAppIReleaseAllTextures(); <br>    RELEASE(d3dappi.lpD3DDevice); <br>    RELEASE(d3dappi.lpZBuffer); <br>    RELEASE(lpPalette); <br>    RELEASE(lpClipper); <br>    RELEASE(d3dappi.lpBackBuffer); <br>    RELEASE(d3dappi.lpFrontBuffer); <br>    /*  <br>     * Restore the display mode if we were in a fullscreen mode <br>     */ <br>    if (b) { <br>D3DAppIRestoreDispMode(); <br>    } <br>    /*  <br>     * Set the cooperative level and create front and back buffers <br>     */ <br>    D3DAppISetCoopLevel(d3dappi.hwnd, FALSE); <br>    D3DAppISetClientSize(d3dappi.hwnd, w, h, b); <br>    ATTEMPT(D3DAppICreateBuffers(d3dappi.hwnd, w, h, D3DAPP_BOGUS, FALSE, <br> d3dappi.Driver[d3dappi.CurrDriver].bIsHardware)); <br>    /* <br>     * If the front buffer is palettized, initialize its palette <br>     */ <br>    ATTEMPT(D3DAppICheckForPalettized()); <br>    /* <br>     * Create the Z-buffer <br>     */ <br>    ATTEMPT(D3DAppICreateZBuffer(szBuffers.cx, szBuffers.cy, <br> d3dappi.CurrDriver)); <br>    /* <br>     * Create the D3D device, load the textures, call the device create <br>     * callback and set a default render state <br>     */ <br>    ATTEMPT(D3DAppICreateDevice(d3dappi.CurrDriver)); <br>    ATTEMPT(D3DAppILoadAllTextures()); <br>    ATTEMPT(D3DAppICallDeviceCreateCallback(szBuffers.cx, szBuffers.cy)); <br>    ATTEMPT(D3DAppISetRenderState()); <br>    /*  <br>     * Clear dirty rectangle information <br>     */ <br>    D3DAppIValidateDirtyRects(); <br>    d3dappi.bRenderingIsOK = TRUE; <br>    return TRUE; <br> <br>exit_with_error: <br>    D3DAppICallDeviceDestroyCallback(); <br>    RELEASE(d3dappi.lpD3DDevice); <br>    RELEASE(d3dappi.lpZBuffer); <br>    RELEASE(lpPalette); <br>    RELEASE(lpClipper); <br>    RELEASE(d3dappi.lpBackBuffer); <br>    RELEASE(d3dappi.lpFrontBuffer); <br>    return FALSE;   <br>} <br> <br> <br>/* <br> * D3DAppChangeDriver  <br> */ <br>BOOL <br>D3DAppChangeDriver(int driver, DWORD flags) <br>{ <br>    int mode; <br> <br>    /* <br>     * Verify the compatibility of this mode with the specified driver. <br>     * The mode may change. <br>     */ <br>    if (d3dappi.bFullscreen) <br>mode = d3dappi.CurrMode; <br>    else <br>mode = D3DAPP_USEWINDOW; <br>    ATTEMPT(D3DAppIVerifyDriverAndMode(&amp;driver, &amp;mode)); <br>    if (driver == D3DAPP_BOGUS || mode == D3DAPP_BOGUS) <br>goto exit_with_error; <br>    /* <br>     * Update the current driver and set bThisDriverCanDo flags <br>     */ <br>    d3dappi.CurrDriver = driver; <br>    ATTEMPT(D3DAppIFilterDisplayModes(driver)); <br>    /* <br>     * Either call D3DAppWindow or D3DAppFullscreen depending on mode <br>     */ <br>    if (mode == D3DAPP_USEWINDOW) { <br>if (d3dappi.bFullscreen) { <br>    /* <br>     * We need to switch to a window.  D3DApp will either use the <br>     * size of the last window it saw or use a default size. <br>     */ <br>    ATTEMPT(D3DAppWindow(D3DAPP_YOUDECIDE, D3DAPP_YOUDECIDE)); <br>} else { <br>    /* <br>     * We need to recreate the current window.  Don't let D3DApp <br>     * decide on the size. <br>     */ <br>    ATTEMPT(D3DAppWindow(d3dappi.szClient.cx, d3dappi.szClient.cy)); <br>} <br>/* <br> * Change the currently selected mode if it's not compatible with <br> * this driver.  Just to make sure that CurrMode is always a mode the <br> * current driver can do. <br> */ <br>if (!(d3dappi.Driver[driver].Desc.dwDeviceRenderBitDepth &amp; <br>      D3DAppIBPPToDDBD(d3dappi.Mode[d3dappi.CurrMode].bpp))){ <br>    ATTEMPT(D3DAppIPickDisplayMode(&amp;d3dappi.CurrMode, <br>        d3dappi.Driver[driver].Desc.dwDeviceRenderBitDepth)); <br>} <br>return TRUE; <br>    } else { <br>/* <br> * We need to switch to fullscreen or switch fullscreen modes or stay <br> * in the same fullscreen mode.  In any of these cases, we call the <br> * same function. <br> */ <br>ATTEMPT(D3DAppFullscreen(mode)); <br>return TRUE; <br>    } <br> <br>exit_with_error: <br>    /* <br>     * The failed mode setting call would have released everything <br>     */ <br>    return FALSE; <br>} <br> <br> <br>/* <br> * D3DAppWindowProc <br> */ <br>BOOL <br>D3DAppWindowProc(BOOL* bStopProcessing, LRESULT* lresult, HWND hwnd, <br> UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>    PAINTSTRUCT ps; <br>    *bStopProcessing = FALSE; <br>    if (!bD3DAppInitialized) <br>return TRUE; <br>    /* <br>     * Look for messages which effect rendering.  In some cases, we will not <br>     * want the app to continue processing the message, so set the flag and <br>     * provide a return value in lresult. <br>     */ <br>    switch(message) { <br>case WM_SIZE: <br>    if (!bIgnoreWM_SIZE) { <br>/* <br> * Too long to fit here, see ddcalls.c. Updates the buffers <br> * and re-creates the device. <br> */ <br>ATTEMPT(D3DAppIHandleWM_SIZE(lresult, d3dappi.hwnd, message, <br>     wParam, lParam)); <br>*bStopProcessing = TRUE; <br>    } <br>    break; <br>case WM_MOVE: <br>    /* <br>     * Update client window position information <br>     */ <br>    d3dappi.pClientOnPrimary.x = d3dappi.pClientOnPrimary.y = 0; <br>    ClientToScreen(hwnd, &amp;d3dappi.pClientOnPrimary); <br>    break; <br>case WM_ACTIVATE: <br>    /* <br>     * Set the front buffer's palette <br>     */ <br>    if (bPaletteActivate &amp;&amp; bPrimaryPalettized &amp;&amp; <br>d3dappi.lpFrontBuffer) { <br>d3dappi.lpFrontBuffer-&gt;lpVtbl-&gt;SetPalette(d3dappi.lpFrontBuffer, <br>  lpPalette); <br>    } <br>    break; <br>        case WM_ACTIVATEAPP: <br>            d3dappi.bAppActive = (BOOL)wParam; <br>            break; <br>        case WM_SETCURSOR: <br>    /* <br>     * Prevent the cursor from being shown in fullscreen <br>     */ <br>            if (d3dappi.bFullscreen &amp;&amp; !d3dappi.bPaused) { <br>                SetCursor(NULL); <br>                *lresult = 1; <br>*bStopProcessing = TRUE; <br>return TRUE; <br>            } <br>            break; <br>case WM_MOVING: <br>    /* <br>     * Prevent the window from moving in fullscreen <br>     */ <br>    if (d3dappi.bFullscreen) { <br>GetWindowRect(hwnd, (LPRECT)lParam); <br>                *lresult = 1; <br>*bStopProcessing = TRUE; <br>return TRUE; <br>    } <br>    break; <br>case WM_GETMINMAXINFO: <br>    /* <br>     * Ensure the window won't resize in fullscreen <br>     */ <br>    if (d3dappi.bFullscreen) { <br>((LPMINMAXINFO)lParam)-&gt;ptMaxTrackSize.x= d3dappi.ThisMode.w; <br>((LPMINMAXINFO)lParam)-&gt;ptMaxTrackSize.y= d3dappi.ThisMode.h; <br>((LPMINMAXINFO)lParam)-&gt;ptMinTrackSize.x= d3dappi.ThisMode.w; <br>((LPMINMAXINFO)lParam)-&gt;ptMinTrackSize.y= d3dappi.ThisMode.h; <br>                *lresult = 0; <br>*bStopProcessing = TRUE; <br>return TRUE; <br>    } else { <br>((LPMINMAXINFO)lParam)-&gt;ptMaxTrackSize.x = <br>    d3dappi.WindowsDisplay.w; <br>((LPMINMAXINFO)lParam)-&gt;ptMaxTrackSize.y = <br>    d3dappi.WindowsDisplay.h; <br>                *lresult = 0; <br>*bStopProcessing = TRUE; <br>return TRUE; <br>    } <br>    break; <br>case WM_PAINT: <br>    /* <br>     * Clear the rectangle and blt the backbuffer image <br>     */ <br>    BeginPaint(hwnd, &amp;ps); <br>    if (d3dappi.bRenderingIsOK &amp;&amp; !d3dappi.bFullscreen) { <br>D3DAppShowBackBuffer(D3DAPP_SHOWALL); <br>    } <br>    D3DAppIValidateDirtyRects(); <br>    EndPaint(hwnd, &amp;ps); <br>    *lresult = 1; <br>    *bStopProcessing = TRUE; <br>    return TRUE; <br>case WM_NCPAINT: <br>    /* <br>     * When in fullscreen mode, don't draw the window frame. <br>     */ <br>    if (d3dappi.bFullscreen &amp;&amp; !d3dappi.bPaused) { <br>*lresult = 0; <br>*bStopProcessing = TRUE; <br>return TRUE; <br>    } <br>    break; <br>    } <br>    return TRUE; <br> <br>exit_with_error: <br>    return FALSE; <br>} <br> <br>/* <br> * D3DAppAddTexture  <br> */ <br>BOOL <br>D3DAppAddTexture(const char* imagefile) <br>{ <br>    if (d3dappi.NumTextures == D3DAPP_MAXTEXTURES - 1) { <br>D3DAppISetErrorString("Can only load %i textures.", D3DAPP_MAXTEXTURES); <br>return FALSE; <br>    } <br>    lstrcpy(d3dappi.ImageFile[d3dappi.NumTextures], imagefile); <br>    /* <br>     * If this driver does texture mapping, load the texture. <br>     * This test also tests that a device has been created. <br>     */ <br>    if (d3dappi.ThisDriver.bDoesTextures &amp;&amp; d3dappi.NumUsableTextures == d3dappi.NumTextures) { <br>BOOL bInVideo; <br>ATTEMPT(D3DAppILoadTextureSurf(d3dappi.NumTextures, &amp;bInVideo)); <br>if (!bInVideo &amp;&amp; d3dappi.ThisDriver.bIsHardware) { <br>    D3DAppIReleaseTexture(d3dappi.NumTextures); <br>} else { <br>    ATTEMPT(D3DAppIGetTextureHandle(d3dappi.NumTextures)); <br>    ++d3dappi.NumUsableTextures; <br>} <br>    } <br>    d3dappi.NumTextures++; <br>    return TRUE; <br> <br>exit_with_error: <br>    d3dappi.ImageFile[d3dappi.NumTextures][0] = 0; <br>    return FALSE; <br>} <br> <br>/* <br> * D3DAppChangeTextureFormat <br> */ <br>BOOL <br>D3DAppChangeTextureFormat(int format) <br>{ <br>    /* <br>     * Release all the textures, change the format and load them again <br>     */ <br>    d3dappi.bRenderingIsOK = FALSE; <br>    D3DAppIReleaseAllTextures(); <br>    d3dappi.CurrTextureFormat = format; <br>    memcpy(&amp;d3dappi.ThisTextureFormat, &amp;d3dappi.TextureFormat[format], <br>   sizeof(D3DAppTextureFormat)); <br>    ATTEMPT(D3DAppILoadAllTextures()); <br>    d3dappi.bRenderingIsOK = TRUE; <br>    return TRUE; <br> <br>exit_with_error: <br>    D3DAppIReleaseAllTextures(); <br>    return FALSE; <br>} <br> <br>/* <br> * D3DAppDisableTextures <br> */ <br>BOOL <br>D3DAppDisableTextures(BOOL flag) <br>{ <br>    int i; <br>    if (flag == d3dappi.bTexturesDisabled) <br>return TRUE; <br>    if (flag) { <br>/* <br> * Set all the texture handles to 0 <br> */ <br>d3dappi.bTexturesDisabled = TRUE; <br>for (i = 0; i &lt; d3dappi.NumTextures; i++) <br>    d3dappi.TextureHandle[i] = 0; <br>    } else { <br>/* <br> * Restore the texture handles from the master array <br> */ <br>d3dappi.bTexturesDisabled = FALSE; <br>memcpy(d3dappi.TextureHandle, MasterTextureHandle, <br>       sizeof(D3DTEXTUREHANDLE) * D3DAPP_MAXTEXTURES); <br>    } <br>    return TRUE; <br>} <br> <br>/* <br> * D3DAppSwapTextures <br> */ <br>BOOL <br>D3DAppSwapTextures() <br>{ <br>    int i; <br>    char tempfile[30]; <br>    LPDIRECT3DTEXTURE2 lptempTexture; <br>    LPDIRECTDRAWSURFACE lptempSurface; <br>  if (d3dappi.bTexturesDisabled || d3dappi.NumTextures == 0) { <br>D3DAppISetErrorString("Cannot swap textures which are disable or not loaded.\n"); <br>goto exit_with_error; <br>    } <br>    if (!d3dappi.ThisDriver.bDoesTextures) <br>return TRUE; <br>    /* <br>     * Swap texture 1 with 2, then 2 with 3, then 3 with 4, etc. <br>     * Don't forget the image file names, texture objects and surfaces <br>     */ <br>    for (i = 0; i &lt; d3dappi.NumUsableTextures - 1; i++) { <br>lstrcpy(tempfile, d3dappi.ImageFile[i]); <br>lstrcpy(d3dappi.ImageFile[i], d3dappi.ImageFile[i+1]); <br>lstrcpy(d3dappi.ImageFile[i+1], tempfile); <br>d3dappi.lpD3DDevice-&gt;lpVtbl-&gt;SwapTextureHandles(d3dappi.lpD3DDevice, <br>      d3dappi.lpTexture[i], <br>      d3dappi.lpTexture[i+1]); <br>lptempTexture = d3dappi.lpTexture[i]; <br>d3dappi.lpTexture[i] = d3dappi.lpTexture[i+1]; <br>d3dappi.lpTexture[i+1] = lptempTexture; <br>lptempSurface = d3dappi.lpTextureSurf[i]; <br>d3dappi.lpTextureSurf[i] = d3dappi.lpTextureSurf[i+1]; <br>d3dappi.lpTextureSurf[i+1] = lptempSurface; <br>    } <br>    return TRUE; <br>exit_with_error: <br>    return FALSE; <br>} <br> <br>/* <br> * D3DAppSetRenderState <br> */ <br>BOOL <br>D3DAppSetRenderState(D3DAppRenderState* lpState) <br>{ <br>    /* <br>     * If none was provided, reset the current render state. <br>     */ <br>    if (!lpState) <br>lpState = &amp;d3dapprs; <br>    /* <br>     * Record this render state and set it. <br>     */ <br>    if (lpState != &amp;d3dapprs) <br>memcpy(&amp;d3dapprs, lpState, sizeof(D3DAppRenderState)); <br>    if (d3dappi.bRenderingIsOK) { <br>ATTEMPT(D3DAppISetRenderState()); <br>    } <br>    return TRUE; <br> <br>exit_with_error: <br>    return FALSE; <br>} <br> <br>/* <br> * D3DAppGetRenderState <br> */ <br>BOOL <br>D3DAppGetRenderState(D3DAppRenderState* lpState) <br>{ <br>    memcpy(lpState, &amp;d3dapprs, sizeof(D3DAppRenderState)); <br>    return TRUE; <br>} <br> <br>/* <br> * D3DAppShowBackBuffer <br> */ <br>BOOL <br>D3DAppShowBackBuffer(DWORD flags) <br>{ <br>    if (!d3dappi.bRenderingIsOK) { <br>D3DAppISetErrorString("Cannot call D3DAppShowBackBuffer while bRenderingIsOK is FALSE.\n"); <br>return FALSE; <br>    } <br>    if (d3dappi.bPaused) <br>return TRUE; <br>    if (d3dappi.bFullscreen) {   <br>int numtemp; <br>D3DRECT temp[D3DAPP_MAXCLEARRECTS]; <br>/* <br> * Flip the back and front buffers <br> */ <br>        LastError = d3dappi.lpFrontBuffer-&gt;lpVtbl-&gt;Flip(d3dappi.lpFrontBuffer, <br>d3dappi.lpBackBuffer, <br>1); <br>if (LastError == DDERR_SURFACELOST) { <br>    d3dappi.lpFrontBuffer-&gt;lpVtbl-&gt;Restore(d3dappi.lpFrontBuffer); <br>    d3dappi.lpBackBuffer-&gt;lpVtbl-&gt;Restore(d3dappi.lpBackBuffer); <br>    D3DAppIClearBuffers(); <br>} else if (LastError != DD_OK) { <br>            D3DAppISetErrorString("Flipping complex display surface failed.\n%s", D3DAppErrorToString(LastError)); <br>            return FALSE; <br>        } <br>if (d3dappi.bBackBufferInVideo) { <br>    /* <br>     * This is a real flip, so the client and back buffer dirty <br>     * rectangles also flip <br>     */ <br>    D3DAppICopyRectList(&amp;numtemp, temp, NumDirtyClientRects, <br>DirtyClient); <br>    D3DAppICopyRectList(&amp;NumDirtyClientRects, DirtyClient, <br>NumDirtyBackRects, DirtyBack); <br>    D3DAppICopyRectList(&amp;NumDirtyBackRects, DirtyBack, numtemp, temp); <br>} else { <br>    /* <br>     * The flip is being emulated as a blt from a system memory back <br>     * buffer, so the back buffer's dirty rectangles are now also the <br>     * client's. <br>     */ <br>    D3DAppICopyRectList(&amp;NumDirtyClientRects, DirtyClient, <br>NumDirtyBackRects, DirtyBack); <br>} <br>    } else { <br>int NumFrontRects, NumBufferRects, i; <br>RECT front[D3DAPP_MAXCLEARRECTS]; <br>RECT buffer[D3DAPP_MAXCLEARRECTS]; <br>/* <br> * Set the rectangle to blt from the back to front bufer <br> */ <br>if (flags &amp; D3DAPP_SHOWALL) { <br>    /* <br>     * Set to entire client window <br>     */ <br>    NumBufferRects = 1; <br>    SetRect(&amp;buffer[0], 0, 0, d3dappi.szClient.cx, <br>    d3dappi.szClient.cy); <br>    SetRect(&amp;front[0], <br>    d3dappi.pClientOnPrimary.x, d3dappi.pClientOnPrimary.y, <br>    d3dappi.szClient.cx + d3dappi.pClientOnPrimary.x, <br>    d3dappi.szClient.cy + d3dappi.pClientOnPrimary.y); <br>} else { <br>    /* <br>     * Merge the back and front buffer dirty rectangle lists to get <br>     * a list of rectangles to blt.  This will simultaneously clear <br>     * the smallest front buffer region while blt'ing all the back <br>     * buffer which changed. <br>     */ <br>    D3DAppIMergeRectLists(&amp;NumBufferRects, (LPD3DRECT)buffer, <br>  NumDirtyClientRects, DirtyClient, <br>  NumDirtyBackRects, DirtyBack); <br>    D3DAppICopyRectList(&amp;NumFrontRects, (LPD3DRECT)front, <br>NumBufferRects, (LPD3DRECT)buffer); <br>    for (i = 0; i &lt; NumFrontRects; i++) { <br>front[i].top += d3dappi.pClientOnPrimary.y; <br>front[i].left += d3dappi.pClientOnPrimary.x; <br>front[i].bottom += d3dappi.pClientOnPrimary.y; <br>front[i].right += d3dappi.pClientOnPrimary.x; <br>    } <br>} <br>/* <br> * Blt the list of rectangles from the back to front buffer <br> */ <br>for (i = 0; i &lt; NumBufferRects; i++) { <br>    LastError = <br>    d3dappi.lpFrontBuffer-&gt;lpVtbl-&gt;Blt(d3dappi.lpFrontBuffer, <br>                             &amp;front[i], d3dappi.lpBackBuffer, <br>     &amp;buffer[i], DDBLT_WAIT, NULL); <br>    if (LastError == DDERR_SURFACELOST) { <br>d3dappi.lpFrontBuffer-&gt;lpVtbl-&gt;Restore(d3dappi.lpFrontBuffer); <br>d3dappi.lpBackBuffer-&gt;lpVtbl-&gt;Restore(d3dappi.lpBackBuffer); <br>D3DAppIClearBuffers(); <br>    } else if (LastError != DD_OK) { <br>D3DAppISetErrorString("Blt of back buffer to front buffer failed.\n%s", D3DAppErrorToString(LastError)); <br>return FALSE; <br>    } <br>} <br>/* <br> * The back buffer's dirty rectangles are now also the client's <br> */ <br>D3DAppICopyRectList(&amp;NumDirtyClientRects, DirtyClient, <br>    NumDirtyBackRects, DirtyBack); <br>    } <br>    return TRUE; <br>} <br> <br>/* <br> * D3DAppRenderExtents <br> */ <br>BOOL <br>D3DAppRenderExtents(DWORD dwCount, LPD3DRECT extent, DWORD flags) <br>{ <br>    if (dwCount &gt; D3DAPP_MAXCLEARRECTS) { <br>D3DAppISetErrorString("The number of clear rectangles exceeded D3DAPP_MAXCLEARRECTS."); <br>return FALSE; <br>    } <br>    if (flags &amp; D3DAPP_CLEARALL) { <br>/* <br> * Set the back buffer dirty rectangle to the entire client area <br> */ <br>D3DRECT dummy; <br>dummy.x1 = dummy.y1 = 0; <br>dummy.x2 = d3dappi.szClient.cx; <br>dummy.y2 = d3dappi.szClient.cy; <br>D3DAppICopyRectList(&amp;NumDirtyBackRects, DirtyBack, 1, &amp;dummy); <br>D3DAppICopyRectList(&amp;NumDirtyClientRects, DirtyClient, 1, &amp;dummy); <br>D3DAppICopyRectList(&amp;NumDirtyZRects, DirtyZ, 1, &amp;dummy); <br>    } else { <br>/* <br> * Set the back and Z buffer dirty rectangle list as specified <br> */ <br>D3DAppICopyRectList(&amp;NumDirtyBackRects, DirtyBack, dwCount, extent); <br>D3DAppICopyRectList(&amp;NumDirtyZRects, DirtyZ, dwCount, extent); <br>    } <br>    return TRUE; <br>} <br> <br>/* <br> * D3DAppClearBackBuffer <br> */ <br>BOOL <br>D3DAppClearBackBuffer(DWORD flags) <br>{ <br>    if (!d3dappi.bRenderingIsOK) { <br>D3DAppISetErrorString("Cannot call D3DAppClearBackBuffer while bRenderingIsOK is FALSE.\n"); <br>return FALSE; <br>    } <br>    if (flags &amp; D3DAPP_CLEARALL) { <br>/* <br> * Clear the entire back buffer <br> */ <br>int clearflags; <br>D3DRECT dummy; <br>/* <br> * Decided wether to clear just back buffer or also z-buffer <br> */ <br>clearflags = D3DCLEAR_TARGET; <br>if (d3dapprs.bZBufferOn) <br>    clearflags |= D3DCLEAR_ZBUFFER; <br>dummy.x1 = dummy.y1 = 0; <br>dummy.x2 = d3dappi.szClient.cx; <br>dummy.y2 = d3dappi.szClient.cy; <br>LastError = <br>          d3dappi.lpD3DViewport-&gt;lpVtbl-&gt;Clear(d3dappi.lpD3DViewport, <br>       1, &amp;dummy, <br>       clearflags); <br>if (LastError != D3D_OK) { <br>    D3DAppISetErrorString("Viewport clear failed.\n%s", <br>                  D3DAppErrorToString(LastError)); <br>    return FALSE; <br>} <br>    } else { <br>/* <br> * Clear the dirty rectangles on the back buffer <br> */ <br>LastError = <br>          d3dappi.lpD3DViewport-&gt;lpVtbl-&gt;Clear(d3dappi.lpD3DViewport, <br>                                       NumDirtyBackRects, <br>      DirtyBack, D3DCLEAR_TARGET); <br>if (LastError != D3D_OK) { <br>    D3DAppISetErrorString("Viewport clear of back buffer failed.\n%s", <br>                  D3DAppErrorToString(LastError)); <br>    return FALSE; <br>} <br>/* <br> * Clear the dirty rectangles on the Z buffer <br> */ <br>LastError = <br>          d3dappi.lpD3DViewport-&gt;lpVtbl-&gt;Clear(d3dappi.lpD3DViewport, <br>                                       NumDirtyZRects, <br>      DirtyZ, D3DCLEAR_ZBUFFER); <br>if (LastError != D3D_OK) { <br>    D3DAppISetErrorString("Viewport clear of Z buffer failed.\n%s", <br>                  D3DAppErrorToString(LastError)); <br>    return FALSE; <br>} <br> <br>    } <br>    return TRUE; <br>} <br> <br>/* <br> * D3DAppCheckForLostSurfaces <br> */ <br>#define CHECKSURF(x) if (x) {    \ <br>if (x-&gt;lpVtbl-&gt;IsLost(x) == DDERR_SURFACELOST) {    \ <br>    LastError = x-&gt;lpVtbl-&gt;Restore(x);    \ <br>    if (LastError != DD_OK) goto exit_with_error;   \ <br>    b = TRUE;    \ <br>}    \ <br>     } <br>BOOL <br>D3DAppCheckForLostSurfaces(void) <br>{ <br>    int i; <br>    BOOL b = FALSE; <br>    /* <br>     * Check all the surfaces D3DApp owns and restore them if lost. </code></pre>
<p>
</p>
<pre><code>*/ <br>    CHECKSURF(d3dappi.lpFrontBuffer); <br>    CHECKSURF(d3dappi.lpBackBuffer); <br>    CHECKSURF(d3dappi.lpZBuffer); <br>    if (b) { <br>/* <br> * If any of the surfaces were lost and restored, clear all the buffers. <br> * If this fails, that's fine, just move on. <br> */ <br>D3DAppIClearBuffers(); <br>    } <br>    for (i = 0; i &lt; d3dappi.NumUsableTextures; i++) { <br>b = FALSE; <br>CHECKSURF(d3dappi.lpTextureSurf[i]); <br>if (b) { <br>    ATTEMPT(D3DAppIReloadTextureSurf(i)); <br>} <br>    } <br>    return TRUE; <br> <br>exit_with_error: <br>    D3DAppISetErrorString("Restoring of a lost surface failed.\n%s", <br>          D3DAppErrorToString(LastError)); <br>    return FALSE; <br>} <br> <br>/* <br> * D3DAppPause <br> */ <br>BOOL <br>D3DAppPause(BOOL flag) <br>{ <br>    static int pausecount; <br> <br>    /* <br>     * Keep a count of the number of times D3DAppPause has been called to  <br>     * prevent pausing more than once in a row. <br>     */ <br>    if (pausecount != 0) { <br>if (flag) { <br>    ++pausecount; <br>    return TRUE; <br>} else { <br>    --pausecount; <br>    if (pausecount != 0) <br>return TRUE; <br>}  <br>    } <br> <br>    d3dappi.bPaused = flag; <br>    if (!flag) { <br>/* <br> * Returning from a pause <br> */ <br>        if (d3dappi.bFullscreen &amp;&amp; bPrimaryPalettized &amp;&amp; lpPalette) { <br>    /* <br>     * Set front buffer's palette back to what it was before pause <br>     */ <br>            LastError = lpPalette-&gt;lpVtbl-&gt;SetEntries(lpPalette, 0, 0, 256, <br>      &amp;ppe[0]); <br>    if (LastError != DD_OK) { <br>D3DAppISetErrorString("Setting palette entries during unpause failed.\n%s", D3DAppErrorToString(LastError)); <br>goto exit_with_error; <br>    } <br>        } <br>/* <br> * Dirty rectangle info is no longer valid <br> */ <br>D3DAppIValidateDirtyRects(); <br>    } <br>    if (flag &amp;&amp; d3dappi.bFullscreen) { <br>/* <br> * Pausing in a fullscreen mode <br> */ <br>        if (bPrimaryPalettized &amp;&amp; lpPalette) { <br>    /* <br>     * Save the front buffer's current palette and restore the <br>     * original Windows palette. <br>     */ <br>            int i; <br>            LastError = lpPalette-&gt;lpVtbl-&gt;GetEntries(lpPalette, 0, 0, 256, <br>      &amp;ppe[0]); <br>    if (LastError != DD_OK) { <br>D3DAppISetErrorString("Getting palette entries before a pause failed.\n%s", D3DAppErrorToString(LastError)); <br>goto exit_with_error; <br>    } <br>            for (i = 10; i &lt; 246; i++) <br>                Originalppe[i] = ppe[i]; <br>            LastError = lpPalette-&gt;lpVtbl-&gt;SetEntries(lpPalette, 0, 0, 256, <br>       &amp;Originalppe[0]); <br>    if (LastError != DD_OK) { <br>D3DAppISetErrorString("Returning palette entries to defaults failed.\n%s", D3DAppErrorToString(LastError)); <br>goto exit_with_error; <br>    } <br>        } <br>/* <br> * Flip to GDI surface (either front or back buffer) <br> */ <br>        if (d3dappi.lpDD) { <br>            LastError = d3dappi.lpDD-&gt;lpVtbl-&gt;FlipToGDISurface(d3dappi.lpDD); <br>    if (LastError != DD_OK) { <br>D3DAppISetErrorString("Flipping to GDI surface failed.\n%s", D3DAppErrorToString(LastError)); <br>goto exit_with_error; <br>    } <br>} <br>/* <br> * Draw the menu and frame <br> */ <br>        DrawMenuBar(d3dappi.hwnd); <br>        RedrawWindow(d3dappi.hwnd, NULL, NULL, RDW_FRAME); <br>    } <br>    return TRUE; <br>exit_with_error: <br>    return FALSE; <br>} <br> <br>/* <br> * D3DAppCreateSurface <br> */ <br>BOOL <br>D3DAppCreateSurface(DDSURFACEDESC *ddsd, LPDIRECTDRAWSURFACE *lplpSurf) <br>{ <br>    return D3DAppICreateSurface(ddsd, lplpSurf); <br>} <br> <br>/* <br> * D3DAppLastError <br> */ <br>HRESULT <br>D3DAppLastError(void) <br>{ <br>    return LastError;   <br>} <br> <br>/* <br> * D3DAppLastD3DAppISetErrorString <br> */ <br>char* <br>D3DAppLastErrorString(void) <br>{ <br>    return LastErrorString; <br>} <br> <br> <br>/* <br> * D3DAppDestroy <br> */ <br>BOOL <br>D3DAppDestroy(void) <br>{ <br>    /* <br>     * Destroys all objects including Direct Draw. <br>     */ <br>    d3dappi.bRenderingIsOK = FALSE; <br>    d3dappi.hwnd = NULL; <br>    ATTEMPT(D3DAppICallDeviceDestroyCallback()); <br>    D3DAppIReleaseAllTextures(); <br>    RELEASE(d3dappi.lpD3DDevice); <br>    RELEASE(d3dappi.lpZBuffer); <br>    RELEASE(lpPalette); <br>    RELEASE(lpClipper); <br>    RELEASE(d3dappi.lpBackBuffer); <br>    RELEASE(d3dappi.lpFrontBuffer); <br>    if (d3dappi.bFullscreen) { <br>D3DAppIRestoreDispMode(); <br>D3DAppISetCoopLevel(d3dappi.hwnd, FALSE); <br>    } <br>    D3DAppIReleasePathList(); <br>    RELEASE(d3dappi.lpD3D); <br>    RELEASE(d3dappi.lpDD); <br>    return TRUE; <br>exit_with_error: <br>    return FALSE; <br>} <br> <br> <br>/* <br> * D3DAppErrorToString <br> */ <br>char* <br>D3DAppErrorToString(HRESULT error) <br>{ <br>    switch(error) { <br>        case DD_OK: <br>            return "No error.\0"; <br>        case DDERR_ALREADYINITIALIZED: <br>            return "This object is already initialized.\0"; <br>        case DDERR_BLTFASTCANTCLIP: <br>            return "Return if a clipper object is attached to the source surface passed into a BltFast call.\0"; <br>        case DDERR_CANNOTATTACHSURFACE: <br>            return "This surface can not be attached to the requested surface.\0"; <br>        case DDERR_CANNOTDETACHSURFACE: <br>            return "This surface can not be detached from the requested surface.\0"; <br>        case DDERR_CANTCREATEDC: <br>            return "Windows can not create any more DCs.\0"; <br>        case DDERR_CANTDUPLICATE: <br>            return "Can't duplicate primary &amp; 3D surfaces, or surfaces that are implicitly created.\0"; <br>        case DDERR_CLIPPERISUSINGHWND: <br>            return "An attempt was made to set a cliplist for a clipper object that is already monitoring an hwnd.\0"; <br>        case DDERR_COLORKEYNOTSET: <br>            return "No src color key specified for this operation.\0"; <br>        case DDERR_CURRENTLYNOTAVAIL: <br>            return "Support is currently not available.\0"; <br>        case DDERR_DIRECTDRAWALREADYCREATED: <br>            return "A DirectDraw object representing this driver has already been created for this process.\0"; <br>        case DDERR_EXCEPTION: <br>            return "An exception was encountered while performing the requested operation.\0"; <br>        case DDERR_EXCLUSIVEMODEALREADYSET: <br>            return "An attempt was made to set the cooperative level when it was already set to exclusive.\0"; <br>        case DDERR_GENERIC: <br>            return "Generic failure.\0"; <br>        case DDERR_HEIGHTALIGN: <br>            return "Height of rectangle provided is not a multiple of reqd alignment.\0"; <br>        case DDERR_HWNDALREADYSET: <br>            return "The CooperativeLevel HWND has already been set. It can not be reset while the process has surfaces or palettes created.\0"; <br>        case DDERR_HWNDSUBCLASSED: <br>            return "HWND used by DirectDraw CooperativeLevel has been subclassed, this prevents DirectDraw from restoring state.\0"; <br>        case DDERR_IMPLICITLYCREATED: <br>            return "This surface can not be restored because it is an implicitly created surface.\0"; <br>        case DDERR_INCOMPATIBLEPRIMARY: <br>            return "Unable to match primary surface creation request with existing primary surface.\0"; <br>        case DDERR_INVALIDCAPS: <br>            return "One or more of the caps bits passed to the callback are incorrect.\0"; <br>        case DDERR_INVALIDCLIPLIST: <br>            return "DirectDraw does not support the provided cliplist.\0"; <br>        case DDERR_INVALIDDIRECTDRAWGUID: <br>            return "The GUID passed to DirectDrawCreate is not a valid DirectDraw driver identifier.\0"; <br>        case DDERR_INVALIDMODE: <br>            return "DirectDraw does not support the requested mode.\0"; <br>        case DDERR_INVALIDOBJECT: <br>            return "DirectDraw received a pointer that was an invalid DIRECTDRAW object.\0"; <br>        case DDERR_INVALIDPARAMS: <br>            return "One or more of the parameters passed to the function are incorrect.\0"; <br>        case DDERR_INVALIDPIXELFORMAT: <br>            return "The pixel format was invalid as specified.\0"; <br>        case DDERR_INVALIDPOSITION: <br>            return "Returned when the position of the overlay on the destination is no longer legal for that destination.\0"; <br>        case DDERR_INVALIDRECT: <br>            return "Rectangle provided was invalid.\0"; <br>        case DDERR_LOCKEDSURFACES: <br>            return "Operation could not be carried out because one or more surfaces are locked.\0"; <br>        case DDERR_NO3D: <br>            return "There is no 3D present.\0"; <br>        case DDERR_NOALPHAHW: <br>            return "Operation could not be carried out because there is no alpha accleration hardware present or available.\0"; <br>        case DDERR_NOBLTHW: <br>            return "No blitter hardware present.\0"; <br>        case DDERR_NOCLIPLIST: <br>            return "No cliplist available.\0"; <br>        case DDERR_NOCLIPPERATTACHED: <br>            return "No clipper object attached to surface object.\0"; <br>        case DDERR_NOCOLORCONVHW: <br>            return "Operation could not be carried out because there is no color conversion hardware present or available.\0"; <br>        case DDERR_NOCOLORKEY: <br>            return "Surface doesn't currently have a color key\0"; <br>        case DDERR_NOCOLORKEYHW: <br>            return "Operation could not be carried out because there is no hardware support of the destination color key.\0"; <br>        case DDERR_NOCOOPERATIVELEVELSET: <br>            return "Create function called without DirectDraw object method SetCooperativeLevel being called.\0"; <br>        case DDERR_NODC: <br>            return "No DC was ever created for this surface.\0"; <br>        case DDERR_NODDROPSHW: <br>            return "No DirectDraw ROP hardware.\0"; <br>        case DDERR_NODIRECTDRAWHW: <br>            return "A hardware-only DirectDraw object creation was attempted but the driver did not support any hardware.\0"; <br>        case DDERR_NOEMULATION: <br>            return "Software emulation not available.\0"; <br>        case DDERR_NOEXCLUSIVEMODE: <br>            return "Operation requires the application to have exclusive mode but the application does not have exclusive mode.\0"; <br>        case DDERR_NOFLIPHW: <br>            return "Flipping visible surfaces is not supported.\0"; <br>        case DDERR_NOGDI: <br>            return "There is no GDI present.\0"; <br>        case DDERR_NOHWND: <br>            return "Clipper notification requires an HWND or no HWND has previously been set as the CooperativeLevel HWND.\0"; <br>        case DDERR_NOMIRRORHW: <br>            return "Operation could not be carried out because there is no hardware present or available.\0"; <br>        case DDERR_NOOVERLAYDEST: <br>            return "Returned when GetOverlayPosition is called on an overlay that UpdateOverlay has never been called on to establish a destination.\0"; <br>        case DDERR_NOOVERLAYHW: <br>            return "Operation could not be carried out because there is no overlay hardware present or available.\0"; <br>        case DDERR_NOPALETTEATTACHED: <br>            return "No palette object attached to this surface.\0"; <br>        case DDERR_NOPALETTEHW: <br>            return "No hardware support for 16 or 256 color palettes.\0"; <br>        case DDERR_NORASTEROPHW: <br>            return "Operation could not be carried out because there is no appropriate raster op hardware present or available.\0"; <br>        case DDERR_NOROTATIONHW: <br>            return "Operation could not be carried out because there is no rotation hardware present or available.\0"; <br>        case DDERR_NOSTRETCHHW: <br>            return "Operation could not be carried out because there is no hardware support for stretching.\0"; <br>        case DDERR_NOT4BITCOLOR: <br>            return "DirectDrawSurface is not in 4 bit color palette and the requested operation requires 4 bit color palette.\0"; <br>        case DDERR_NOT4BITCOLORINDEX: <br>            return "DirectDrawSurface is not in 4 bit color index palette and the requested operation requires 4 bit color index palette.\0"; <br>        case DDERR_NOT8BITCOLOR: <br>            return "DirectDrawSurface is not in 8 bit color mode and the requested operation requires 8 bit color.\0"; <br>        case DDERR_NOTAOVERLAYSURFACE: <br>            return "Returned when an overlay member is called for a non-overlay surface.\0"; <br>        case DDERR_NOTEXTUREHW: <br>            return "Operation could not be carried out because there is no texture mapping hardware present or available.\0"; <br>        case DDERR_NOTFLIPPABLE: <br>            return "An attempt has been made to flip a surface that is not flippable.\0"; <br>        case DDERR_NOTFOUND: <br>            return "Requested item was not found.\0"; <br>        case DDERR_NOTLOCKED: <br>            return "Surface was not locked.  An attempt to unlock a surface that was not locked at all, or by this process, has been attempted.\0"; <br>        case DDERR_NOTPALETTIZED: <br>            return "The surface being used is not a palette-based surface.\0"; <br>        case DDERR_NOVSYNCHW: <br>            return "Operation could not be carried out because there is no hardware support for vertical blank synchronized operations.\0"; <br>        case DDERR_NOZBUFFERHW: <br>            return "Operation could not be carried out because there is no hardware support for zbuffer blitting.\0"; <br>        case DDERR_NOZOVERLAYHW: <br>            return "Overlay surfaces could not be z layered based on their BltOrder because the hardware does not support z layering of overlays.\0"; <br>        case DDERR_OUTOFCAPS: <br>            return "The hardware needed for the requested operation has already been allocated.\0"; <br>        case DDERR_OUTOFMEMORY: <br>            return "DirectDraw does not have enough memory to perform the operation.\0"; <br>        case DDERR_OUTOFVIDEOMEMORY: <br>            return "DirectDraw does not have enough memory to perform the operation.\0"; <br>        case DDERR_OVERLAYCANTCLIP: <br>            return "The hardware does not support clipped overlays.\0"; <br>        case DDERR_OVERLAYCOLORKEYONLYONEACTIVE: <br>            return "Can only have ony color key active at one time for overlays.\0"; <br>        case DDERR_OVERLAYNOTVISIBLE: <br>            return "Returned when GetOverlayPosition is called on a hidden overlay.\0"; <br>        case DDERR_PALETTEBUSY: <br>            return "Access to this palette is being refused because the palette is already locked by another thread.\0"; <br>        case DDERR_PRIMARYSURFACEALREADYEXISTS: <br>            return "This process already has created a primary surface.\0"; <br>        case DDERR_REGIONTOOSMALL: <br>            return "Region passed to Clipper::GetClipList is too small.\0"; <br>        case DDERR_SURFACEALREADYATTACHED: <br>            return "This surface is already attached to the surface it is being attached to.\0"; <br>        case DDERR_SURFACEALREADYDEPENDENT: <br>            return "This surface is already a dependency of the surface it is being made a dependency of.\0"; <br>        case DDERR_SURFACEBUSY: <br>            return "Access to this surface is being refused because the surface is already locked by another thread.\0"; <br>        case DDERR_SURFACEISOBSCURED: <br>            return "Access to surface refused because the surface is obscured.\0"; <br>        case DDERR_SURFACELOST: <br>            return "Access to this surface is being refused because the surface memory is gone. The DirectDrawSurface object representing this surface should have Restore called on it.\0"; <br>        case DDERR_SURFACENOTATTACHED: <br>            return "The requested surface is not attached.\0"; <br>        case DDERR_TOOBIGHEIGHT: <br>            return "Height requested by DirectDraw is too large.\0"; <br>        case DDERR_TOOBIGSIZE: <br>            return "Size requested by DirectDraw is too large, but the individual height and width are OK.\0"; <br>        case DDERR_TOOBIGWIDTH: <br>            return "Width requested by DirectDraw is too large.\0"; <br>        case DDERR_UNSUPPORTED: <br>            return "Action not supported.\0"; <br>        case DDERR_UNSUPPORTEDFORMAT: <br>            return "FOURCC format requested is unsupported by DirectDraw.\0"; <br>        case DDERR_UNSUPPORTEDMASK: <br>            return "Bitmask in the pixel format requested is unsupported by DirectDraw.\0"; <br>        case DDERR_VERTICALBLANKINPROGRESS: <br>            return "Vertical blank is in progress.\0"; <br>        case DDERR_WASSTILLDRAWING: <br>            return "Informs DirectDraw that the previous Blt which is transfering information to or from this Surface is incomplete.\0"; <br>        case DDERR_WRONGMODE: <br>            return "This surface can not be restored because it was created in a different mode.\0"; <br>        case DDERR_XALIGN: <br>            return "Rectangle provided was not horizontally aligned on required boundary.\0"; <br>        case D3DERR_BADMAJORVERSION: <br>            return "D3DERR_BADMAJORVERSION\0"; <br>        case D3DERR_BADMINORVERSION: <br>            return "D3DERR_BADMINORVERSION\0"; <br>        case D3DERR_EXECUTE_LOCKED: <br>            return "D3DERR_EXECUTE_LOCKED\0"; <br>        case D3DERR_EXECUTE_NOT_LOCKED: <br>            return "D3DERR_EXECUTE_NOT_LOCKED\0"; <br>        case D3DERR_EXECUTE_CREATE_FAILED: <br>            return "D3DERR_EXECUTE_CREATE_FAILED\0"; <br>        case D3DERR_EXECUTE_DESTROY_FAILED: <br>            return "D3DERR_EXECUTE_DESTROY_FAILED\0"; <br>        case D3DERR_EXECUTE_LOCK_FAILED: <br>            return "D3DERR_EXECUTE_LOCK_FAILED\0"; <br>        case D3DERR_EXECUTE_UNLOCK_FAILED: <br>            return "D3DERR_EXECUTE_UNLOCK_FAILED\0"; <br>        case D3DERR_EXECUTE_FAILED: <br>            return "D3DERR_EXECUTE_FAILED\0"; <br>        case D3DERR_EXECUTE_CLIPPED_FAILED: <br>            return "D3DERR_EXECUTE_CLIPPED_FAILED\0"; <br>        case D3DERR_TEXTURE_NO_SUPPORT: <br>            return "D3DERR_TEXTURE_NO_SUPPORT\0"; <br>        case D3DERR_TEXTURE_NOT_LOCKED: <br>            return "D3DERR_TEXTURE_NOT_LOCKED\0"; <br>        case D3DERR_TEXTURE_LOCKED: <br>            return "D3DERR_TEXTURELOCKED\0"; <br>        case D3DERR_TEXTURE_CREATE_FAILED: <br>            return "D3DERR_TEXTURE_CREATE_FAILED\0"; <br>        case D3DERR_TEXTURE_DESTROY_FAILED: <br>            return "D3DERR_TEXTURE_DESTROY_FAILED\0"; <br>        case D3DERR_TEXTURE_LOCK_FAILED: <br>            return "D3DERR_TEXTURE_LOCK_FAILED\0"; <br>        case D3DERR_TEXTURE_UNLOCK_FAILED: <br>            return "D3DERR_TEXTURE_UNLOCK_FAILED\0"; <br>        case D3DERR_TEXTURE_LOAD_FAILED: <br>            return "D3DERR_TEXTURE_LOAD_FAILED\0"; <br>        case D3DERR_MATRIX_CREATE_FAILED: <br>            return "D3DERR_MATRIX_CREATE_FAILED\0"; <br>        case D3DERR_MATRIX_DESTROY_FAILED: <br>            return "D3DERR_MATRIX_DESTROY_FAILED\0"; <br>        case D3DERR_MATRIX_SETDATA_FAILED: <br>            return "D3DERR_MATRIX_SETDATA_FAILED\0"; <br>        case D3DERR_SETVIEWPORTDATA_FAILED: <br>            return "D3DERR_SETVIEWPORTDATA_FAILED\0"; <br>        case D3DERR_MATERIAL_CREATE_FAILED: <br>            return "D3DERR_MATERIAL_CREATE_FAILED\0"; <br>        case D3DERR_MATERIAL_DESTROY_FAILED: <br>            return "D3DERR_MATERIAL_DESTROY_FAILED\0"; <br>        case D3DERR_MATERIAL_SETDATA_FAILED: <br>            return "D3DERR_MATERIAL_SETDATA_FAILED\0"; <br>        case D3DERR_LIGHT_SET_FAILED: <br>            return "D3DERR_LIGHT_SET_FAILED\0"; <br>        default: <br>            return "Unrecognized error value.\0"; <br>    } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
