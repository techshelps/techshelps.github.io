<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>D3DCALLS.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3340"></a>D3DCALLS.C</h2>
<pre><code>/* <br> *  Copyright (C) 1995, 1996 Microsoft Corporation. All Rights Reserved. <br> * <br> *  File: d3dcalls.c <br> * <br> *  Calls to Direct3D objects needed for rendering.  Part of D3DApp. <br> * <br> *  D3DApp is a collection of helper functions for Direct3D applications. <br> *  D3DApp consists of the following files: <br> *d3dapp.h    Main D3DApp header to be included by application <br> *      d3dappi.h   Internal header <br> *      d3dapp.c    D3DApp functions seen by application. <br> *      ddcalls.c   All calls to DirectDraw objects except textures <br> *      d3dcalls.c  All calls to Direct3D objects except textures <br> *      texture.c   Texture loading and managing texture list <br> *      misc.c    Miscellaneous calls <br> */ <br> <br>#define INITGUID <br>#include "d3dappi.h" <br> <br>/***************************************************************************/ <br>/*                            Creation of D3D                              */ <br>/***************************************************************************/ <br>BOOL <br>D3DAppICreateD3D(void) <br>{ <br>    LastError = d3dappi.lpDD-&gt;lpVtbl-&gt;QueryInterface(d3dappi.lpDD, <br>    &amp;IID_IDirect3D2, (LPVOID*)&amp;d3dappi.lpD3D); <br>    if (LastError != DD_OK) { <br>        D3DAppISetErrorString("Creation of IDirect3D failed.\n%s", <br>      D3DAppErrorToString(LastError)); <br>goto exit_with_error; <br>    } <br>    return TRUE; <br>exit_with_error: <br>    return FALSE; <br>} <br> <br>/***************************************************************************/ <br>/*                           D3D Device Enumeration                        */ <br>/***************************************************************************/ <br>/* <br> * enumDeviceFunc <br> * Device enumeration callback.  Record information about the D3D device <br> * reported by D3D. <br> */ <br>static BOOL bRampHasEnumerated = FALSE; <br>static HRESULT <br>WINAPI enumDeviceFunc(LPGUID lpGuid, LPSTR lpDeviceDescription, <br>      LPSTR lpDeviceName, LPD3DDEVICEDESC lpHWDesc, <br>      LPD3DDEVICEDESC lpHELDesc, LPVOID lpContext) <br>{ <br>    lpContext = lpContext; <br>/*if (! bRampHasEnumerated) <br>{ <br>bRampHasEnumerated = TRUE; <br>return D3DENUMRET_OK; <br>}*/ <br>    /* <br>     * Don't accept any hardware D3D devices if emulation only option is set <br>     */ <br>    if (lpHWDesc-&gt;dcmColorModel &amp;&amp; d3dappi.bOnlyEmulation) <br>return D3DENUMRET_OK; <br>    /* <br>     * Record the D3D driver's inforamation <br>     */ <br>    memcpy(&amp;d3dappi.Driver[d3dappi.NumDrivers].Guid, lpGuid, sizeof(GUID)); <br>    lstrcpy(d3dappi.Driver[d3dappi.NumDrivers].About, lpDeviceDescription); <br>    lstrcpy(d3dappi.Driver[d3dappi.NumDrivers].Name, lpDeviceName); <br>    /* <br>     * Is this a hardware device or software emulation?  Checking the color <br>     * model for a valid model works. <br>     */ <br>    if (lpHWDesc-&gt;dcmColorModel) { <br>d3dappi.Driver[d3dappi.NumDrivers].bIsHardware = TRUE; <br>memcpy(&amp;d3dappi.Driver[d3dappi.NumDrivers].Desc, lpHWDesc, <br>       sizeof(D3DDEVICEDESC)); <br>    } else { <br>d3dappi.Driver[d3dappi.NumDrivers].bIsHardware = FALSE; <br>memcpy(&amp;d3dappi.Driver[d3dappi.NumDrivers].Desc, lpHELDesc, <br>       sizeof(D3DDEVICEDESC)); <br>    } <br>    /* <br>     * Does this driver do texture mapping? <br>     */ <br>    d3dappi.Driver[d3dappi.NumDrivers].bDoesTextures = <br>(d3dappi.Driver[d3dappi.NumDrivers].Desc.dpcTriCaps.dwTextureCaps &amp; <br> D3DPTEXTURECAPS_PERSPECTIVE) ? TRUE : FALSE; <br>    /* <br>     * Can this driver use a z-buffer? <br>     */ <br>    d3dappi.Driver[d3dappi.NumDrivers].bDoesZBuffer = <br>d3dappi.Driver[d3dappi.NumDrivers].Desc.dwDeviceZBufferBitDepth <br>? TRUE : FALSE; <br>    /* <br>     * Can this driver render to the Windows display depth <br>     */ <br>    d3dappi.Driver[d3dappi.NumDrivers].bCanDoWindow = <br>(d3dappi.Driver[d3dappi.NumDrivers].Desc.dwDeviceRenderBitDepth &amp; <br> D3DAppIBPPToDDBD(d3dappi.WindowsDisplay.bpp)) ? TRUE : FALSE; <br>    if (!d3dappi.bIsPrimary) <br>d3dappi.Driver[d3dappi.NumDrivers].bCanDoWindow = FALSE; <br> <br>    d3dappi.NumDrivers++; <br>    if (d3dappi.NumDrivers == D3DAPP_MAXD3DDRIVERS) <br>        return (D3DENUMRET_CANCEL); <br>    return (D3DENUMRET_OK); <br>} <br> <br>/* <br> * D3DAppIEnumDevices <br> * Get the available drivers from Direct3D by enumeration. <br> */ <br>BOOL <br>D3DAppIEnumDevices(void) <br>{ <br>    d3dappi.NumDrivers = 0; <br>    LastError = d3dappi.lpD3D-&gt;lpVtbl-&gt;EnumDevices(d3dappi.lpD3D, <br>   enumDeviceFunc, NULL); <br>    if (LastError != DD_OK) { <br>        D3DAppISetErrorString("Enumeration of drivers failed.\n%s", <br>      D3DAppErrorToString(LastError)); <br>return FALSE; <br>    } <br>    d3dappi.CurrDriver = 0; <br>    return TRUE; <br>} <br> <br>/***************************************************************************/ <br>/*                    Enumeration of texure format                         */ <br>/***************************************************************************/ <br>/* <br> * EnumTextureFormatsCallback <br> * Record information about each texture format the current D3D driver can <br> * support. Choose one as the default format (paletted formats are prefered) <br> * and return it through lpContext. <br> */ <br>static HRESULT <br>CALLBACK EnumTextureFormatsCallback(LPDDSURFACEDESC lpDDSD, LPVOID lpContext) <br>{ <br>    unsigned long m; <br>    int r, g, b; <br>    int *lpStartFormat = (int *)lpContext; <br>    /* <br>     * Record the DDSURFACEDESC of this texture format <br>     */ <br>    memset(&amp;d3dappi.TextureFormat[d3dappi.NumTextureFormats], 0, <br>   sizeof(D3DAppTextureFormat)); <br>    memcpy(&amp;d3dappi.TextureFormat[d3dappi.NumTextureFormats].ddsd, lpDDSD, <br>   sizeof(DDSURFACEDESC)); <br>    /* <br>     * Is this format palettized?  How many bits?  Otherwise, how many RGB <br>     * bits? <br>     */ <br>    if (lpDDSD-&gt;ddpfPixelFormat.dwFlags &amp; DDPF_PALETTEINDEXED8) { <br>        d3dappi.TextureFormat[d3dappi.NumTextureFormats].bPalettized = TRUE; <br>d3dappi.TextureFormat[d3dappi.NumTextureFormats].IndexBPP = 8; <br>    } else if (lpDDSD-&gt;ddpfPixelFormat.dwFlags &amp; DDPF_PALETTEINDEXED4) { <br>        d3dappi.TextureFormat[d3dappi.NumTextureFormats].bPalettized = TRUE; <br>d3dappi.TextureFormat[d3dappi.NumTextureFormats].IndexBPP = 4; <br>    } else if (lpDDSD-&gt;ddpfPixelFormat.dwFlags &amp; DDPF_ALPHAPIXELS) { <br>/* <br> * The sample apps don't currently understand <br> * the alpha bit - just filter this format <br> * away for now. <br> */ <br> <br>return DDENUMRET_OK; <br>    } else <br>    { <br>        d3dappi.TextureFormat[d3dappi.NumTextureFormats].bPalettized = FALSE; <br>d3dappi.TextureFormat[d3dappi.NumTextureFormats].IndexBPP = 0; <br>        for (r = 0, m = lpDDSD-&gt;ddpfPixelFormat.dwRBitMask; !(m &amp; 1); <br>       r++, m &gt;&gt;= 1); <br>        for (r = 0; m &amp; 1; r++, m &gt;&gt;= 1); <br>        for (g = 0, m = lpDDSD-&gt;ddpfPixelFormat.dwGBitMask; !(m &amp; 1); <br>       g++, m &gt;&gt;= 1); <br>        for (g = 0; m &amp; 1; g++, m &gt;&gt;= 1); <br>        for (b = 0, m = lpDDSD-&gt;ddpfPixelFormat.dwBBitMask; !(m &amp; 1); <br>       b++, m &gt;&gt;= 1); <br>        for (b = 0; m &amp; 1; b++, m &gt;&gt;= 1); <br>d3dappi.TextureFormat[d3dappi.NumTextureFormats].RedBPP = r; <br>d3dappi.TextureFormat[d3dappi.NumTextureFormats].GreenBPP = g; <br>d3dappi.TextureFormat[d3dappi.NumTextureFormats].BlueBPP = b; <br>    } <br>    /* <br>     * If lpStarFormat is -1, this is the first format.  Select it. <br>     */ <br>    if (*lpStartFormat == -1) <br>        *lpStartFormat = d3dappi.NumTextureFormats; <br>    /*  <br>     * If this format is paletted, select it. <br>     */ <br>    if (d3dappi.TextureFormat[d3dappi.NumTextureFormats].bPalettized) { <br>        *lpStartFormat = d3dappi.NumTextureFormats; <br>    } <br>    d3dappi.NumTextureFormats++; <br>    return DDENUMRET_OK; <br>} <br> <br>/* <br> * D3DAppIEnumTextureFormats <br> * Get a list of available texture map formats from the Direct3D driver by <br> * enumeration.  Choose a default format (paletted is prefered). <br> */ <br>BOOL <br>D3DAppIEnumTextureFormats(void) <br>{ <br>    int StartFormat; <br>    /* <br>     * Set the default format to -1 to let the callback know it's being  <br>     * called for the first time. <br>     */ <br>    StartFormat = -1; <br>    d3dappi.NumTextureFormats = 0; <br>    LastError = <br> d3dappi.lpD3DDevice-&gt;lpVtbl-&gt;EnumTextureFormats(d3dappi.lpD3DDevice, <br>  EnumTextureFormatsCallback, <br>                                                  (LPVOID)&amp;StartFormat); <br>    if (LastError != DD_OK) { <br>D3DAppISetErrorString("Enumeration of texture formats failed.\n%s", <br>      D3DAppErrorToString(LastError)); <br>return FALSE; <br>    } <br>    memcpy(&amp;d3dappi.ThisTextureFormat, &amp;d3dappi.TextureFormat[StartFormat], <br>   sizeof(D3DAppTextureFormat)); <br>    d3dappi.CurrTextureFormat = StartFormat; <br>    return TRUE; <br>} <br> <br>/***************************************************************************/ <br>/*                               Device creation                           */ <br>/***************************************************************************/ <br>/* <br> * D3DAppICreateDevice <br> * Create the D3D device and enumerate the texture formats <br> */ <br>BOOL <br>D3DAppICreateDevice(int driver) <br>{ <br>    RELEASE(d3dappi.lpD3DDevice); <br> <br>    if (d3dappi.Driver[driver].bIsHardware &amp;&amp; !d3dappi.bBackBufferInVideo) { <br>D3DAppISetErrorString("Could not fit the rendering surfaces in video memory for this hardware device.\n"); <br>goto exit_with_error; <br>    } <br> <br>    d3dappi.CurrDriver = driver; <br>    memcpy(&amp;d3dappi.ThisDriver, &amp;d3dappi.Driver[driver], sizeof(D3DAppD3DDriver)); <br>#if 1 <br>    LastError = d3dappi.lpD3D-&gt;lpVtbl-&gt;CreateDevice(d3dappi.lpD3D,  <br>&amp;d3dappi.Driver[driver].Guid, <br>        d3dappi.lpBackBuffer, &amp;d3dappi.lpD3DDevice); <br>#else <br>    LastError = <br>   d3dappi.lpBackBuffer-&gt;lpVtbl-&gt;QueryInterface(d3dappi.lpBackBuffer, <br>&amp;d3dappi.Driver[driver].Guid, <br>      (LPVOID*)&amp;d3dappi.lpD3DDevice); <br>#endif <br>    if (LastError != DD_OK) { <br>    D3DAppISetErrorString("Create D3D device failed.\n%s", <br>      D3DAppErrorToString(LastError)); <br>        goto exit_with_error; <br>    } <br>    d3dappi.CurrDriver = driver; <br>    d3dappi.NumTextureFormats = 0; <br>    if (d3dappi.Driver[driver].bDoesTextures) { <br>if (!D3DAppIEnumTextureFormats()) <br>    goto exit_with_error; <br>    } <br> <br>    return TRUE; <br>exit_with_error: <br>    RELEASE(d3dappi.lpD3DDevice); <br>    return FALSE; <br>} <br> <br>/***************************************************************************/ <br>/*                      Setting the render state                           */ <br>/***************************************************************************/ <br>/* <br> * D3DAppISetRenderState <br> * Create and execute an execute buffer which will set the render state and <br> * light state for the current viewport. <br> */ <br>BOOL <br>D3DAppISetRenderState() <br>{ <br>LPDIRECT3DDEVICE2 pDev = d3dappi.lpD3DDevice; <br> <br>    /* <br>     * If there is no D3D Viewport, we must return true because it is not <br>     * required. <br>     */ <br>    if (!d3dappi.lpD3DViewport) <br>return TRUE; <br>    LastError = pDev-&gt;lpVtbl-&gt;BeginScene(pDev); <br>    if (LastError != D3D_OK) { <br>        D3DAppISetErrorString("BeginScene failed in SetRenderState.\n%s", <br>                              D3DAppErrorToString(LastError)); <br>        goto exit_with_error; <br>    } <br>LastError = pDev-&gt;lpVtbl-&gt;SetCurrentViewport(pDev, d3dappi.lpD3DViewport); <br>if (LastError !=D3D_OK) { <br>        D3DAppISetErrorString("SetViewport failed in SetRenderState.\n%s", <br>      D3DAppErrorToString(LastError)); <br>goto exit_with_error; <br>    } <br>    /* <br>     * Set render state <br>     */ <br>    pDev-&gt;lpVtbl-&gt;SetRenderState(pDev, D3DRENDERSTATE_SHADEMODE, (DWORD)d3dapprs.ShadeMode); <br>    pDev-&gt;lpVtbl-&gt;SetRenderState(pDev, D3DRENDERSTATE_TEXTUREPERSPECTIVE, (DWORD)d3dapprs.bPerspCorrect); <br>    pDev-&gt;lpVtbl-&gt;SetRenderState(pDev, D3DRENDERSTATE_ZENABLE, (DWORD)(d3dapprs.bZBufferOn &amp;&amp; <br>                                  d3dappi.ThisDriver.bDoesZBuffer)); <br>    pDev-&gt;lpVtbl-&gt;SetRenderState(pDev, D3DRENDERSTATE_ZWRITEENABLE, (DWORD)d3dapprs.bZBufferOn); <br>    pDev-&gt;lpVtbl-&gt;SetRenderState(pDev, D3DRENDERSTATE_ZFUNC, D3DCMP_LESSEQUAL); <br>    pDev-&gt;lpVtbl-&gt;SetRenderState(pDev, D3DRENDERSTATE_TEXTUREMAG, (DWORD)d3dapprs.TextureFilter); <br>    pDev-&gt;lpVtbl-&gt;SetRenderState(pDev, D3DRENDERSTATE_TEXTUREMIN, (DWORD)d3dapprs.TextureFilter); <br>    pDev-&gt;lpVtbl-&gt;SetRenderState(pDev, D3DRENDERSTATE_TEXTUREMAPBLEND, (DWORD)d3dapprs.TextureBlend); <br>    pDev-&gt;lpVtbl-&gt;SetRenderState(pDev, D3DRENDERSTATE_FILLMODE, (DWORD)d3dapprs.FillMode); <br>    pDev-&gt;lpVtbl-&gt;SetRenderState(pDev, D3DRENDERSTATE_DITHERENABLE, (DWORD)d3dapprs.bDithering); <br>    pDev-&gt;lpVtbl-&gt;SetRenderState(pDev, D3DRENDERSTATE_SPECULARENABLE, (DWORD)d3dapprs.bSpecular); <br>    pDev-&gt;lpVtbl-&gt;SetRenderState(pDev, D3DRENDERSTATE_ANTIALIAS, (DWORD)d3dapprs.bAntialiasing); <br>    pDev-&gt;lpVtbl-&gt;SetRenderState(pDev, D3DRENDERSTATE_FOGENABLE, (DWORD)d3dapprs.bFogEnabled); <br>    pDev-&gt;lpVtbl-&gt;SetRenderState(pDev, D3DRENDERSTATE_FOGCOLOR, (DWORD)d3dapprs.FogColor); <br>    /* <br>     * Set light state <br>     */ <br>    pDev-&gt;lpVtbl-&gt;SetLightState(pDev, D3DLIGHTSTATE_FOGMODE, (DWORD)d3dapprs.bFogEnabled ? <br>                 d3dapprs.FogMode : D3DFOG_NONE); <br>    pDev-&gt;lpVtbl-&gt;SetLightState(pDev, D3DLIGHTSTATE_FOGSTART, *(unsigned long*)&amp;d3dapprs.FogStart); <br>    pDev-&gt;lpVtbl-&gt;SetLightState(pDev, D3DLIGHTSTATE_FOGEND, *(unsigned long*)&amp;d3dapprs.FogEnd); <br> <br>    LastError = pDev-&gt;lpVtbl-&gt;EndScene(pDev); <br>    if (LastError != D3D_OK) { <br>        D3DAppISetErrorString("EndScene failed in SetRenderState.\n%s", <br>      D3DAppErrorToString(LastError)); <br>goto exit_with_error; <br>    } <br>return TRUE; <br>exit_with_error: <br>    return FALSE; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
