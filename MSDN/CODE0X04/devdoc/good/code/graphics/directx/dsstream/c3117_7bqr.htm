<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>NOTIFY.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3123"></a>NOTIFY.C</h2>
<pre><code>// =============================================================== <br>// notify.c <br>// =============================================================== <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;mmsystem.h&gt; <br> <br>#include &lt;dsound.h&gt; <br>#include "dsstream.h" <br> <br>// externs  <br>extern LPDIRECTSOUNDBUFFER lpDSBStreamBuffer; <br>extern LPDIRECTSOUNDNOTIFY lpDirectSoundNotify; <br>extern WAVEINFOCA wiWave; <br>extern HWND  hWndMain; <br>  <br>// function prototypes <br>void UpdateProgressBar(void); <br> <br>// =============================================================== <br>// HandleNotifications <br>//Deals with the notification events. <br>//Two events have been defined in SetNotifications(). <br>//The first (index 0) handles position notifications, triggered <br>//after wiWave.dwNotifySize bytes and the second event deals with <br>//the stop notification. <br>//Initally, the entire buffer is filled with the FillDataBuffer() <br>//call, when the user asks the stream to play. With each subsequent <br>//notification, handled by this function, the rest of the file  <br>//is read into the buffer. <br>// =============================================================== <br>DWORD HandleNotifications(LPVOID lpvoid) <br>{ <br>DWORD hr = DS_OK; <br>#ifdef DEBUG <br>DWORD dwPlayPos, dwWritePos; <br>#endif <br>DWORD hRet = 0; <br> <br>while((hRet = WaitForMultipleObjects(2, hNotifyEvent, FALSE, INFINITE))!= WAIT_FAILED) <br>{ <br>if (wiWave.bDonePlaying == TRUE) <br>{ <br>DPF(0, "Posting stop message"); <br>UpdateProgressBar(); <br>SendMessage( hWndMain, WM_DSSTREAM_DONE, (WPARAM)0, (LPARAM)0 ); <br>break; //quit while loop. <br>} <br> <br>// Deal with the event that got signalled. <br>switch(hRet-WAIT_OBJECT_0) <br>{ <br>case 0: <br>{// A play notification has been received. <br>LPBYTE lpWrite1; <br>DWORD dwWrite1; <br>UINT cbActual = 0; <br>// update the progress slider and wiWave.dwProgress. <br>UpdateProgressBar(); <br> <br>// If the entire file has been read into the buffer, bFoundEnd will be TRUE. <br>if (!wiWave.bFoundEnd) <br>{// read in more of the file. <br>DPF(0, "Received a notify event with FoundEnd = FALSE. NR = %lu", wiWave.dwNextWriteOffset ); <br>#ifdef DEBUG <br>hr = lpDSBStreamBuffer-&gt;lpVtbl-&gt;GetCurrentPosition(lpDSBStreamBuffer, &amp;dwPlayPos, &amp;dwWritePos); <br>DPF(1, "dwPlayPos = %lu and dwWritePos = %lu", dwPlayPos, dwWritePos); <br>#endif <br>// Lock the buffer. <br>hr = lpDSBStreamBuffer-&gt;lpVtbl-&gt;Lock(lpDSBStreamBuffer,  <br>wiWave.dwNextWriteOffset,  <br>wiWave.dwNotifySize,  <br>&amp;lpWrite1, &amp;dwWrite1, <br>NULL, NULL, 0); <br>if (hr != DS_OK) <br>{ <br>DPF(0, "couldn't lock buffer with hr = %lu", hr); <br>return hr; <br>} <br> <br>if (dwWrite1 &lt; wiWave.dwNotifySize) <br>{ <br>DPF(0, "Lock returned number of bytes and requested size differ"); <br>} <br> <br>// now read the file.  <br>hr = WaveReadFile(wiWave.hmmio, dwWrite1, lpWrite1, &amp;wiWave.mmck, &amp;cbActual); <br> <br>//if cbActual is less than the amount asked for, we may have <br>//reached end of file. If we are looping, we will simply read the  <br>//file in again until we have written dwWrite1 bytes into the buffer. <br>//If not looping we fill with silence. <br>if ((DWORD)cbActual &lt; dwWrite1) <br>{ <br>DPF(3, "ReadFile read less than what we asked for. less by %lu", dwWrite1-(DWORD)cbActual); <br>if (!wiWave.bLoopFile) <br>{ <br>wiWave.bFoundEnd = TRUE; <br>// fill up the rest of the buffer with silence. <br>DPF(0, "Filling in silence"); <br>FillMemory( lpWrite1+cbActual, (UINT)dwWrite1-cbActual,  <br>(BYTE)(wiWave.pwfx-&gt;wBitsPerSample == 8 ? 128 : 0)); <br>} <br>else <br>{// we're looping. Read in the file again. <br>int nChkErr = 0; <br>UINT cbWritten = cbActual;// from previous call above. <br>DPF(0, "Looping so read in file again"); <br>while (cbWritten &lt; (UINT)dwWrite1)// write only one notification worth. <br>{// this will keep reading in until the buffer is full. For very short files. <br>nChkErr = WaveStartDataRead( &amp;wiWave.hmmio, &amp;wiWave.mmck, &amp;wiWave.mmckInRIFF ); <br>ASSERT(nChkErr == 0);// we've already this before so shouldn't fail. <br>nChkErr = WaveReadFile(wiWave.hmmio, (UINT)dwWrite1-cbWritten,  <br>lpWrite1 + cbWritten, &amp;wiWave.mmck, &amp;cbActual); <br>ASSERT(nChkErr == 0);// we've already this before so shouldn't fail. <br>cbWritten += cbActual; <br>} // while <br>ASSERT(wiWave.bFoundEnd == FALSE); <br>}// if or not looping <br>} <br> <br>//unlock now <br>hr = lpDSBStreamBuffer-&gt;lpVtbl-&gt;Unlock(lpDSBStreamBuffer, (LPVOID)lpWrite1, dwWrite1,  NULL, 0 ); <br>// setup the nextwrite offset. <br>wiWave.dwNextWriteOffset += dwWrite1; <br>if (wiWave.dwNextWriteOffset &gt;= wiWave.dwBufferSize) <br>wiWave.dwNextWriteOffset -= wiWave.dwBufferSize; <br>}// if !bFoundEnd. <br>else <br>{ <br>// We have read in the whole file. We will keep filling in silence <br>// in the buffer to allow the remaining sound bytes filled earlier  <br>// to be played.  <br>DPF(1, "Received a notify event and bFoundEnd = TRUE"); <br>ASSERT(wiWave.bLoopFile == FALSE); <br>#ifdef DEBUG <br>// if we've read all the file and we're not looping,  <br>hr = lpDSBStreamBuffer-&gt;lpVtbl-&gt;GetCurrentPosition(lpDSBStreamBuffer, &amp;dwPlayPos, &amp;dwWritePos); <br>DPF(1, "dwPlayPos = %lu and dwWritePos = %lu", dwPlayPos, dwWritePos); <br>#endif <br>// Allow the rest of the bytes to be played and fill here <br>// with silence. The next notification will quit the while loop. <br>hr = lpDSBStreamBuffer-&gt;lpVtbl-&gt;Lock(lpDSBStreamBuffer,  <br>wiWave.dwNextWriteOffset,  <br>wiWave.dwNotifySize,  <br>&amp;lpWrite1, &amp;dwWrite1, <br>NULL, NULL, 0); <br>DPF(0, "Filling in silence"); <br>FillMemory(lpWrite1, dwWrite1,(BYTE)(wiWave.pwfx-&gt;wBitsPerSample == 8 ? 128 : 0)); <br> <br>hr = lpDSBStreamBuffer-&gt;lpVtbl-&gt;Unlock(lpDSBStreamBuffer, (LPVOID)lpWrite1, dwWrite1,  NULL, 0 ); <br> <br>// We don't want to cut off the sound before it's done playing. <br>// If doneplaying is set, the next notification event will post a stop message. <br>if (wiWave.mmckInRIFF.cksize &gt; wiWave.dwNotifySize &amp;&amp; <br>wiWave.dwProgress &gt;= wiWave.mmckInRIFF.cksize - wiWave.dwNotifySize) <br>{ <br>wiWave.bDonePlaying = TRUE; <br>} <br>else// for short files. <br>if (wiWave.dwProgress &gt;= wiWave.mmckInRIFF.cksize) <br>wiWave.bDonePlaying = TRUE; <br>}// else <br>} <br>break; <br> <br>case 1: <br>{// A stop notification has been received. <br>DPF(0, "Received the stop event"); <br>// update ui. <br>//UpdateProgressBar(); <br>#ifdef DEBUG <br>hr = lpDSBStreamBuffer-&gt;lpVtbl-&gt;GetCurrentPosition(lpDSBStreamBuffer, &amp;dwPlayPos, &amp;dwWritePos); <br>DPF(1, "dwPlayPos = %lu and dwWritePos = %lu", dwPlayPos, dwWritePos); <br>#endif <br>// Set bDonePlaying to True.  <br>wiWave.bDonePlaying = TRUE; <br>// call stop. <br>if (lpDSBStreamBuffer) <br>{ <br>hr = lpDSBStreamBuffer-&gt;lpVtbl-&gt;Stop(lpDSBStreamBuffer); <br>ASSERT(hr == DS_OK);// why would this fail in tis app? <br>} <br>CloseHandle(hNotifyEvent[0]); <br>CloseHandle(hNotifyEvent[1]); <br>hNotifyEvent[0] = hNotifyEvent[1] = (HANDLE)NULL; <br>break; <br>} <br> <br>default: <br>ASSERT(FALSE);// we should never fall in here. <br>break; <br> <br>}// end switch <br> <br>} // while <br> <br>//UpdateProgressBar(); <br>DPF(0, "Exiting thread"); <br>return TRUE; <br>} //handlenotifications() <br> <br>// =========================================================== <br>// UpdateProgressBar <br>// Gets the current play position and updates the progress <br>// bar accordingly. <br>// =========================================================== <br>void UpdateProgressBar(void) <br>{ <br>DWORD dwPlayPos, dwWritePos; <br>int hr = 0;  <br>DWORD dwPlayed = 0; <br> <br>hr = lpDSBStreamBuffer-&gt;lpVtbl-&gt;GetCurrentPosition(lpDSBStreamBuffer, &amp;dwPlayPos, &amp;dwWritePos); <br>if (hr != DS_OK) <br>{ <br>DPF(0, "getCurrentPos returned failure"); <br>} <br> <br>DPF(1, "CurrentPos = %lu and LastPos = %lu", dwPlayPos, wiWave.dwLastPos); <br> <br>if (dwPlayPos &lt; wiWave.dwLastPos) <br>{ <br>dwPlayed = wiWave.dwBufferSize - wiWave.dwLastPos + dwPlayPos; <br>} <br>else <br>{ <br>dwPlayed = dwPlayPos - wiWave.dwLastPos; <br>} <br> <br>wiWave.dwProgress += dwPlayed; <br> <br>wiWave.dwLastPos = dwPlayPos; <br> <br>DPF(1, "wiWave.dwProgress =  %lu", wiWave.dwProgress); <br>DPF(1, "Posting %lu", wiWave.dwProgress);  <br>PostMessage( hWndMain, WM_DSSTREAM_PROGRESS, 0L, wiWave.dwProgress ); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
