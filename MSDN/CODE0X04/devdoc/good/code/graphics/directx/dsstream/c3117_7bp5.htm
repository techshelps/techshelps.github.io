<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DSSTREAM.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3119"></a>DSSTREAM.C</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1995-1997 Microsoft Corporation. All Rights Reserved. <br> * <br> *  File:   dsstream.c <br> *  Content:   Illustrates streaming data from a disk WAVE file to a <br> *             DirectSound secondary buffer for playback. <br> * <br> ***************************************************************************/ <br>#define WIN32_LEAN_AND_MEAN <br>#define INITGUID <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include &lt;dsound.h&gt; <br>#include &lt;commctrl.h&gt; <br>#include &lt;commdlg.h&gt; <br>#include &lt;memory.h&gt; <br>#include &lt;cderr.h&gt; <br> <br>#include "dsstream.h" <br>#include "wassert.h" <br> <br>char szAppClass[] = "DSStreamWndClass"; <br>char szAppName[]  = "DSStream"; <br> <br>char szAppTitle[64]; <br>char szAppCaption[64]; <br>char szPan[32]; <br>char szVolume[32]; <br>char szFrequency[32]; <br>char szProgress[32]; <br>char szOpenFilter[128]; <br>char szOpenDLGTitle[64]; <br> <br> <br>char szTemp[256]; <br>char szDebug[128]; <br>char szFileBuffer[MAX_PATH]; <br>char szFileTitle[MAX_PATH]; <br>char szCDStartPath[MAX_PATH];        // The path to start the Open dialog in <br>  <br>// Registry Key and Value names that allow us to retrive a path something like <br>// "C:\DXSDK\SDK\MEDIA", but matching the current install. <br>static const TCHAR gszRegKeyDirect3D[] = TEXT("Software\\Microsoft\\Direct3D"); <br>static const TCHAR gszRegValueD3DPath[] = TEXT("D3D Path"); <br> <br>// Size of longest token below <br>#define MAX_TOKEN_LEN7 <br> <br> <br>static TCHAR gszPlayToken[] = TEXT("PLAY"); <br>static TCHAR gszLoopToken[] = TEXT("LOOP"); <br>static TCHAR gszCloseToken[] = TEXT("CLOSE"); <br>static TCHAR gszStickyToken[] = TEXT("STICKY"); <br>static TCHAR gszGlobalToken[] = TEXT("GLOBAL"); <br> <br>LPDIRECTSOUNDlpDS = NULL; <br>LPDIRECTSOUNDBUFFERlpDSBStreamBuffer = NULL; <br>LPDIRECTSOUNDNOTIFY lpDirectSoundNotify = NULL; <br> <br>WAVEINFOCAwiWave; <br> <br>HWNDhWndMain, hWndPan, hWndPanText, hWndVol, hWndVolText, hWndFreqText; <br>HWNDhWndBar, hWndPlay, hWndStop, hWndLoopCheck, hWndFreq, hWndProg; <br>HWNDhWndProgText; <br> <br>#ifdef DEBUG <br>HWNDhWndList; <br>#endif <br> <br>HINSTANCEhInst; <br> <br>static BOOLbFileOpen = FALSE, bPlaying = FALSE; <br>static BOOL     bEnumDrivers = FALSE, gfCloseOnDone = FALSE; <br>static UINT     uTimerID = 0, uLastPercent = 100; <br>static GUID     guID; <br>static DWORDgdwFocus = 0; <br> <br>static BOOL InitApp( HINSTANCE ); <br>static BOOL InitInstance( HINSTANCE, int ); <br>static void BuildTitleBarText( void ); <br>// Call this in initialization to set the szCDStartPath[] global variable <br>static void GetMediaStartPath( void ); <br>static void FillDataBuffer( void ); <br>static void LoadFromCommandLine( LPSTR lpszCmd ); <br>extern void UpdateProgressBar(void); <br>/****************************************************************************** <br> * WinMain() <br> * <br> * Entry point for all Windows programs - performs initialization, message loop <br> */ <br>int PASCAL WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, <br>LPSTR lpCmdLine, int nCmdShow ) <br>    { <br>    MSG     msg; <br> <br>    hInst = hInstance; <br> <br>    /* Make sure the common controls are loaded for our use */ <br>    InitCommonControls(); <br> <br> <br>    if( !hPrevInstance ) <br>        if( !InitApp( hInstance )) <br>            { <br>            ErrorMessageBox( IDS_ERROR_APPINIT, MB_ICONSTOP ); <br>            return( FALSE ); <br>    } <br> <br>    if( !InitInstance( hInstance, nCmdShow )) <br>        { <br>        ErrorMessageBox( IDS_ERROR_INSTANCEINIT, MB_ICONSTOP ); <br>        return( FALSE ); <br>} <br> <br>    // We know how to take exactly one file name from the command-line and open <br>    // it as a file to play.  We can also accept a couple command like /play, <br>    // /close, and /loop <br>    if( lpCmdLine[0] ) <br>LoadFromCommandLine( lpCmdLine ); <br> <br>    while( GetMessage((LPMSG)&amp;msg, NULL, 0, 0 )) <br>        { <br>        TranslateMessage( &amp;msg ); <br>        DispatchMessage( &amp;msg ); <br>        } <br> <br>    UnregisterClass( szAppClass, hInstance ); <br>    return( msg.wParam ); <br>    } /* End of WinMain() */ <br> <br> <br>/*****************************************************************************/ <br>/* InitApp()     */ <br>/*      */ <br>/*   Inits things that only need to be created once for the this application */ <br>/* (like creating the window class).     */ <br>/*****************************************************************************/ <br>static BOOL InitApp( HINSTANCE hInstance ) <br>    { <br>    WNDCLASSwc; <br> <br>    /* Set up and register a window class */ <br>    wc.style= CS_HREDRAW | CS_VREDRAW; <br>    wc.lpszClassName= szAppClass; <br>    wc.lpfnWndProc= (WNDPROC)MainWindowProc; <br>    wc.cbClsExtra= 0; <br>    wc.cbWndExtra= sizeof( DWORD ); <br>    wc.hInstance= hInstance; <br>    wc.hIcon            = LoadIcon( hInstance, MAKEINTRESOURCE( IDI_ICON1 )); <br>    wc.hCursor= LoadCursor( NULL, IDC_ARROW ); <br>    wc.hbrBackground= (HBRUSH)(COLOR_WINDOW); <br>    wc.lpszMenuName= MAKEINTRESOURCE( IDR_MAINMENU ); <br> <br>    if( !RegisterClass( &amp;wc )) <br>        { <br>ErrorMessageBox( IDS_ERROR_REGISTERCLASS, MB_ICONSTOP ); <br>        return( FALSE ); <br>        } <br>    return( TRUE ); <br>    } /* End of InitApp() */ <br> <br> <br>/*****************************************************************************/ <br>/* InitInstance()     */ <br>/*      */ <br>/* Performs initialization that must be done for each application instance.  */ <br>/*      */ <br>/*****************************************************************************/ <br>static BOOL InitInstance( HINSTANCE hInstance, int nCmdShow ) <br>    { <br>    HWNDhWnd; <br>    HRESULTdsRetVal; <br>    RECTcrect; <br>    intcx, cy; <br>    UINTuCharsRead; <br>    BOOLfUseGuid = FALSE; <br>    HMENUhSysMenu; <br> <br>    DbgInitialize( TRUE ); <br> <br>    // Initialize the Media start path for common open boxes <br>    GetMediaStartPath(); <br>  <br>    LoadString( hInstance, IDS_APP_TITLE, szAppTitle, sizeof(szAppTitle)); <br>    LoadString( hInstance, IDS_APP_CAPTION, szAppCaption, sizeof(szAppCaption)); <br>    LoadString( hInstance, IDS_TBTITLE_PAN, szPan, sizeof(szPan)); <br>    LoadString( hInstance, IDS_TBTITLE_VOLUME, szVolume, sizeof(szVolume)); <br>    LoadString( hInstance, IDS_TBTITLE_FREQUENCY, <br>        szFrequency, sizeof(szFrequency)); <br>    LoadString( hInstance, IDS_TBTITLE_PROGRESS, <br>        szProgress, sizeof(szProgress)); <br>    LoadString( hInstance, IDS_OPEN_DLGTITLE, <br>    szOpenDLGTitle, sizeof(szOpenDLGTitle)); <br>/* This is a little trick designed to allow us to load a common dialog box <br> * filter string, which is really a concatentation of several NULL-terminated <br> * strings. Note that while is is possible to enter something else into the <br> * resource as placeholders for the NULL characters, this has the undesireable <br> * effect of forcing us to search-and-replace byte-by-byte and doesn't make it <br> * as easy to internationalize our strings... <br> */ <br>    memset( szOpenFilter, 0, sizeof(szOpenFilter)); <br>    uCharsRead = LoadString( hInstance, IDS_OPEN_FILTER1, <br>szOpenFilter, sizeof(szOpenFilter)) + 1; <br>    uCharsRead += LoadString( hInstance, IDS_OPEN_FILTER2, <br>    &amp;szOpenFilter[uCharsRead], <br>    sizeof(szOpenFilter) - uCharsRead ) + 1; <br>    uCharsRead += LoadString( hInstance, IDS_OPEN_FILTER3, <br>    &amp;szOpenFilter[uCharsRead], <br>    sizeof(szOpenFilter) - uCharsRead ) + 1; <br>    LoadString( hInstance, IDS_OPEN_FILTER4, <br>    &amp;szOpenFilter[uCharsRead], <br>    sizeof(szOpenFilter) - uCharsRead ); <br> <br>    /* Calculate the size of the client window */ <br>    cx = CONTROL_SPACE_CX + 2*BORDER_SPACE_CX + BUTTON_CX + PAN_TB_CX <br>+ 2*GetSystemMetrics( SM_CXBORDER ) + PAN_TEXT_CX + TEXT_SPACE_CX; <br> <br>    cy = 2*(BORDER_SPACE_CY + GetSystemMetrics( SM_CYBORDER )) <br>+ PAN_TB_CY + VOL_TB_CY + FREQ_TB_CY + PROG_TB_CY <br>+ GetSystemMetrics( SM_CYMENU ) + 3*CONTROL_SPACE_CY <br>+ GetSystemMetrics( SM_CYCAPTION ); <br> <br>    /* Create an application window */ <br>#ifdef DEBUG <br>    hWnd = CreateWindow( szAppClass,/* class name */ <br>szAppCaption,/* caption for window */ <br>WS_OVERLAPPEDWINDOW/* style */ <br> &amp; ~WS_THICKFRAME | WS_BORDER, <br>CW_USEDEFAULT,/* x position */ <br>CW_USEDEFAULT,/* y position */ <br>cx,/* width */ <br>cy + 200,               /* height */ <br>NULL,/* parent window */ <br>NULL,/* menu */ <br>hInstance,/* instance */ <br>NULL );/* parms */ <br>#else <br>    hWnd = CreateWindow( szAppClass,/* class name */ <br>szAppCaption,/* caption for window */ <br>WS_OVERLAPPEDWINDOW/* style */ <br> &amp; ~WS_THICKFRAME | WS_BORDER, <br>CW_USEDEFAULT,/* x position */ <br>CW_USEDEFAULT,/* y position */ <br>cx,/* width */ <br>cy,/* height */ <br>NULL,/* parent window */ <br>NULL,/* menu */ <br>hInstance,/* instance */ <br>NULL );/* parms */ <br>#endif <br> <br>    if( !hWnd ) <br>        { <br>ErrorMessageBox( IDS_ERROR_MAINWNDCREATE, MB_ICONSTOP ); <br>        return( FALSE ); <br>} <br> <br>    hWndMain = hWnd; <br>    GetClientRect( hWndMain, &amp;crect ); <br> <br>    // Apparently WM_INITMENU isn't called for the main window's context version <br>    // of the system menu, so we must gray these at startup as well. <br>    hSysMenu = GetSystemMenu( hWndMain, FALSE ); <br>    EnableMenuItem( hSysMenu, SC_SIZE, MF_BYCOMMAND | MF_GRAYED ); <br>    EnableMenuItem( hSysMenu, SC_MAXIMIZE, MF_BYCOMMAND | MF_GRAYED ); <br> <br>#ifdef DEBUG <br>    cy = 2*BORDER_SPACE_CY + PAN_TB_CY + VOL_TB_CY + FREQ_TB_CY + PROG_TB_CY <br>    + 3*CONTROL_SPACE_CY; <br> <br>    hWndList = CreateWindow( "listbox", NULL, WS_CHILD | WS_VISIBLE <br>    | LBS_NOINTEGRALHEIGHT | WS_VSCROLL, <br>0, cy, crect.right-crect.left, <br>crect.bottom - crect.top - cy, <br>hWnd, NULL, hInstance, NULL ); <br>#endif <br> <br>    /* Create some controls for things like volume, panning, etc. */ <br>    if( CreateChildren( crect )) <br>        return( FALSE ); <br> <br>    ShowWindow( hWnd, nCmdShow ); <br>    UpdateWindow( hWnd ); <br> <br>    /* Create the main DirectSound object */ <br> <br>    bEnumDrivers = GetProfileInt( "DSSTREAM", "EnumDrivers", FALSE ); <br>    if( bEnumDrivers &amp;&amp; !DoDSoundEnumerate( &amp;guID )) <br>{ <br>fUseGuid = TRUE; <br>} <br>    dsRetVal = DirectSoundCreate( fUseGuid ? &amp;guID : NULL, &amp;lpDS, NULL ); <br> <br>     <br>    if( dsRetVal != DS_OK ) <br>        { <br>        ErrorMessageBox( IDS_ERROR_DSCREATE, MB_ICONSTOP ); <br>        return( FALSE ); <br>        } <br> <br>    dsRetVal = lpDS-&gt;lpVtbl-&gt;SetCooperativeLevel( lpDS, <br>                                                hWndMain, <br>                                                DSSCL_NORMAL ); <br>    if( dsRetVal != DS_OK ) <br>        { <br>        ErrorMessageBox( IDS_ERROR_DSCOOPERATIVE, MB_ICONSTOP ); <br>        return( FALSE ); <br>        } <br> <br> <br>    return( TRUE ); <br>    } /* End of InitInstance() */ <br> <br> <br>/****************************************************************************/ <br>/* MainWindowProc()                                                         */ <br>/*                                                                          */ <br>/*    Messages for our main window are handled here                         */ <br>/*                                                                          */ <br>/****************************************************************************/ <br>LRESULT CALLBACK MainWindowProc( HWND hWnd, unsigned uMsg, <br>WPARAM wParam, LPARAM lParam ) <br>    { <br>#ifndef DEBUG <br>    LPMINMAXINFO lpMinMax; <br>#endif <br>    DWORD   dwCDErr = 0, dwProg; <br>    float   fPercent; <br>    UINT    uPercent; <br>    BOOL    bResult = FALSE; <br>    int    nChkErr; <br>    HRESULT dsrval; <br> <br>    switch( uMsg ) <br>        { <br>        case WM_DSSTREAM_PROGRESS: <br>            dwProg = (DWORD)lParam; <br>    dwProg  = dwProg % wiWave.mmckInRIFF.cksize; <br>            fPercent = (float)((dwProg * 100)/ wiWave.mmckInRIFF.cksize);   <br>            SendMessage( hWndProg, TBM_SETPOS,TRUE, (DWORD)(float)(fPercent*(float)PROG_MULTIPLIER)); <br>            uPercent = (UINT)fPercent; <br>wsprintf( szTemp, "%s: %u%%", szProgress, uPercent ); <br>Static_SetText( hWndProgText, szTemp ); <br>break; <br> <br>         /*This message will be posted by the helper DLL when the TimeFunc <br>         * is done streaming the WAVE file. It serves as notification that the <br>         * caller should terminate WAVE playback and end the MM timer event. <br>         */ <br>        case WM_DSSTREAM_DONE: <br>            /* Emulate a WM_COMMAND to ourselves */ <br>DPF(0, "received a dsstream_done message"); <br>            PostMessage( hWnd, WM_COMMAND, MAKEWPARAM( IDM_STOP, 0 ), 0L ); <br>            break; <br> <br>#ifdef DEBUG <br>        case WM_DSSTREAM_DEBUG: <br>            if( LOWORD(wParam) == DEBUGF_PLAYPOSITION ) <br>                { <br>                wsprintf( szDebug, "pp = %li", lParam ); <br>                ListBox_AddString( hWndList, szDebug ); <br>                DPF( 4, szDebug ); <br>                } <br>            else if( LOWORD(wParam) == DEBUGF_WRITEPOSITION ) <br>                { <br>                wsprintf( szDebug, "wp = %li", lParam ); <br>                ListBox_AddString( hWndList, szDebug ); <br>                DPF( 4, szDebug ); <br>                } <br>            else if( LOWORD(wParam) == DEBUGF_NEXTWRITE ) <br>                { <br>                wsprintf( szDebug, "nw = %li", lParam ); <br>                ListBox_AddString( hWndList, szDebug ); <br>                DPF( 4, szDebug ); <br>                } <br>            else if( LOWORD(wParam) == DEBUGF_SKIP ) <br>                { <br>                ListBox_AddString( hWndList, "Skipped segment read" ); <br>                DPF( 5, szDebug ); <br>                } <br>            break; <br>#endif <br> <br>        case WM_COMMAND: <br>            switch( LOWORD( wParam )) <br>                { <br>                case IDM_FILE_OPEN: <br>                    { <br>                    OPENFILENAMEofn; <br>/* <br> * Clear out and fill in an OPENFILENAME structure in preparation <br> * for creating a common dialog box to open a file. <br> */ <br>                    memset( &amp;ofn, 0, sizeof(OPENFILENAME)); <br>                    ofn.lStructSize= sizeof(OPENFILENAME); <br>                    ofn.hwndOwner= hWnd; <br>                    ofn.hInstance= hInst; <br>                    ofn.lpstrFilter= szOpenFilter; <br>                    ofn.nFilterIndex= 1; <br>                    szFileBuffer[0]= '\0'; <br>                    ofn.lpstrFile= szFileBuffer; <br>                    ofn.nMaxFile= sizeof(szFileBuffer); <br>ofn.lpstrFileTitle= szFileTitle; <br>ofn.nMaxFileTitle= sizeof(szFileTitle); <br> ofn.lpstrInitialDir = szCDStartPath; <br>                    ofn.lpstrDefExt= "WAV"; <br>                    ofn.lpstrTitle= szOpenDLGTitle; <br>                    ofn.Flags= OFN_FILEMUSTEXIST | OFN_HIDEREADONLY; <br> <br>                    bResult = GetOpenFileName( &amp;ofn ); /* Do the dialog box */ <br>/* <br> *A return of TRUE indicates that the user did not select a filename. <br> * The possible reasons are: Cancel was clicked, or an error occured. <br> * If Cancel was clicked, the CommDlgExtendedError() function will not <br> * return a valid code.  For anything else, an error code will come back. <br> */ <br>                    if( bResult == FALSE ) <br>                        { <br>                        dwCDErr = CommDlgExtendedError(); <br>                        if( dwCDErr ) <br>                            { <br>                            /* Handle a common dialog box error */ <br>                            HandleCommDlgError( dwCDErr ); <br>                            } <br>                        else/* Clicked Cancel, so finish msg processing */ <br>                            return( 0 ); <br>                        } <br>                    else <br>                        { <br>// Copy the directory name we opened from so that we start there <br>// next time we open the dialog box... <br>lstrcpy( szCDStartPath, szFileBuffer ); <br>szCDStartPath[ofn.nFileOffset] = '\0'; <br> <br>                        if( bFileOpen ) <br>                            { <br>// Before we force a close, disable auto close <br>// because the user has picked a new file and is <br>// obviously not ready for us to go away yet. <br>    gfCloseOnDone = FALSE; <br>/* Need to close the previous file before we open a new one.  The best <br> * way to do this is by faking a menu command, so that we only have the <br> * actual code in one place and it can easily be changed. <br> */ <br>                            SendMessage( hWnd, WM_COMMAND, <br>                            MAKEWPARAM( IDM_FILE_CLOSE, 0 ), 0L ); <br>                            } <br> <br>if(( nChkErr = StreamBufferSetup()) != 0 ) <br>                            { <br>            // Error opening the WAVE file so abort <br>    break; <br>                            } <br>                        else <br>                            { <br>                            bFileOpen = TRUE; <br>                            EnableMenuItem( GetMenu( hWnd ), IDM_PLAY, <br>                            MF_BYCOMMAND | MF_ENABLED ); <br>                            EnableWindow( hWndPlay, TRUE ); <br>                            EnableMenuItem( GetMenu( hWnd ), IDM_FILE_CLOSE, <br>                            MF_BYCOMMAND | MF_ENABLED ); <br>                            DrawMenuBar( hWnd ); <br>BuildTitleBarText(); <br>                            } <br>                        } <br>                    } <br>                    break; <br> <br>                case IDM_FILE_CLOSE: <br>                    SendMessage( hWnd, WM_COMMAND, <br>                    MAKEWPARAM( IDM_STOP, <br>                                            DSSTREAM_STOPF_NOREOPEN ), 0L ); <br>    BuildTitleBarText(); <br>                    break; <br> <br>                case IDM_OPTIONS_ENUMDRIVERS: <br>                    bEnumDrivers = !bEnumDrivers; <br>                    if( bEnumDrivers ) <br>                        { <br>                        LoadString( hInst, IDS_ENUMWARNING, szTemp, sizeof(szTemp)); <br>                        MessageBox( hWnd, szTemp, szAppCaption, MB_OK ); <br>                        } <br>                    break; <br> <br>                case IDM_HELP_ABOUT: <br>                    DialogBox( hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWndMain, <br>                    (DLGPROC)DLG_About ); <br>                    break; <br> <br>                case IDC_LOOPCHECK: <br>                    wiWave.bLoopFile = !wiWave.bLoopFile; <br>                    Button_SetCheck( hWndLoopCheck, wiWave.bLoopFile ); <br>                    if( !bPlaying &amp;&amp; bFileOpen ) <br>                        ResetWavePlayer(); <br>                    break; <br> <br>                case IDM_PLAY: <br>DPF(0, "In idm_play"); <br>                    if( bPlaying ) <br>    { <br>gfCloseOnDone = FALSE; <br>SendMessage( hWnd, WM_COMMAND, MAKEWPARAM( IDM_STOP, 0 ), 0L ); <br>} <br> <br>                    if( bFileOpen &amp;&amp; lpDSBStreamBuffer ) <br>                    { <br>dsrval = SetupNotifications(); <br>if (dsrval != DS_OK) <br>{ <br>DPF(0, "In Play command, setupnotifications failed"); <br>break; <br>} <br> <br>                        // Ensure that position is at 0, ready to go <br>                        dsrval = lpDSBStreamBuffer-&gt;lpVtbl-&gt;SetCurrentPosition(lpDSBStreamBuffer, 0 ); <br>ASSERT(dsrval == DS_OK); <br>#ifdef DEBUG <br>{ <br>DWORD dwWrite, dwPlay; <br>dsrval = lpDSBStreamBuffer-&gt;lpVtbl-&gt;GetCurrentPosition(lpDSBStreamBuffer, &amp;dwPlay, &amp;dwWrite); <br>ASSERT(dsrval == DS_OK); <br>if (dwPlay != 0) <br>DPF(0, "Couldn't set pos to 0"); <br>} <br>#endif  <br>wiWave.bDonePlaying = FALSE; <br>DPF(0, "calling play()"); <br>                        dsrval = lpDSBStreamBuffer-&gt;lpVtbl-&gt;Play( lpDSBStreamBuffer,0, 0, DSBPLAY_LOOPING );                                                       <br>                    } <br>                    else <br>                    { <br>                        bPlaying = FALSE; <br>                        break; <br>                    } <br> <br>                    bPlaying = TRUE; <br>EnableWindow(hWndPlay,FALSE); <br>EnableMenuItem(GetMenu( hWnd ), IDM_PLAY, MF_BYCOMMAND | MF_GRAYED ); <br>                    EnableMenuItem(GetMenu( hWnd ), IDM_STOP, MF_BYCOMMAND | MF_ENABLED ); <br>                    EnableWindow( hWndStop, TRUE ); <br>                    DrawMenuBar( hWnd ); <br>                    break; <br> <br> <br>                case IDM_STOP: <br>DPF(0, "received a idm_stop"); <br>if (gfCloseOnDone) <br>wiWave.bDonePlaying = TRUE; <br>                    if( bPlaying ) <br>                        { <br>bPlaying = FALSE; <br>dsrval = lpDSBStreamBuffer-&gt;lpVtbl-&gt;Stop( lpDSBStreamBuffer ); <br>EnableMenuItem(GetMenu( hWnd ), IDM_STOP,MF_BYCOMMAND | MF_GRAYED );                                             <br>EnableWindow(hWndStop, FALSE ); <br>DrawMenuBar( hWnd ); <br>                        } <br>// Short circuit to allow command-line forced shutdown <br>if(!( HIWORD(wParam) &amp; DSSTREAM_STOPF_NOREOPEN ) &amp;&amp; !gfCloseOnDone ) <br>{ <br>ResetWavePlayer(); <br>            EnableMenuItem(GetMenu( hWnd ), IDM_PLAY, MF_BYCOMMAND | MF_ENABLED ); <br>EnableWindow(hWndPlay, TRUE); <br>DrawMenuBar( hWnd ); <br>break; <br>} <br>                    else <br>                        { <br>                        if( bFileOpen ) <br>                            { <br>DPF(0, "In Stop: Closing read file"); <br>WaveCloseReadFile( &amp;wiWave.hmmio, &amp;wiWave.pwfx );                                                             <br>if (lpDirectSoundNotify) <br>dsrval = lpDirectSoundNotify-&gt;lpVtbl-&gt;Release(lpDirectSoundNotify); <br>lpDirectSoundNotify = NULL; <br> <br>if( lpDSBStreamBuffer ) <br>dsrval = lpDSBStreamBuffer-&gt;lpVtbl-&gt;Release(lpDSBStreamBuffer ); <br>lpDSBStreamBuffer = NULL; <br> <br>bFileOpen = FALSE; <br>// The file is closed, so disable the close option <br>EnableMenuItem( GetMenu( hWnd ), IDM_FILE_CLOSE, <br>MF_BYCOMMAND | MF_GRAYED ); <br>EnableMenuItem( GetMenu( hWnd ), IDM_PLAY, <br>MF_BYCOMMAND | MF_GRAYED ); <br>EnableWindow( hWndPlay, FALSE ); <br>DrawMenuBar( hWnd ); <br>PostMessage( hWnd, WM_DSSTREAM_PROGRESS, 0L, 0L ); <br>if( gfCloseOnDone &amp;&amp; <br>!(HIWORD(wParam) &amp;&amp; DSSTREAM_STOPF_NOEXIT)) <br>SendMessage( hWnd, WM_COMMAND, <br>MAKEWPARAM( IDM_FILE_EXIT, 0 ), 0L ); <br>                            } <br>            } <br>    break; <br> <br>                case IDM_FILE_EXIT: <br>                    DestroyWindow( hWnd ); <br>                    break; <br>                } <br>            break; <br>#ifndef DEBUG <br>        case WM_GETMINMAXINFO: <br>    /* <br>     * We know exactly how big this window should be, and it's sort of a <br>     * little pop-up control panel, so we can disable window sizing by <br>     * forcing all the minimum and maximum sizes to be the calculated size. <br>     */ <br>            lpMinMax = (LPMINMAXINFO)lParam; <br> <br>            lpMinMax-&gt;ptMaxSize.x = CONTROL_SPACE_CX + 2*BORDER_SPACE_CX <br>                                    + BUTTON_CX + PAN_TB_CX + PAN_TEXT_CX <br>                                    + TEXT_SPACE_CX <br>                                    + 2*GetSystemMetrics( SM_CXBORDER ); <br>            lpMinMax-&gt;ptMaxSize.y = 2*(BORDER_SPACE_CY <br>                                    + GetSystemMetrics( SM_CYBORDER )) <br>                                    + PAN_TB_CY + VOL_TB_CY + FREQ_TB_CY <br>                                    + PROG_TB_CY + 3*CONTROL_SPACE_CY <br>                                    + GetSystemMetrics( SM_CYMENU ) <br>                                    + GetSystemMetrics( SM_CYCAPTION ); <br> <br>            lpMinMax-&gt;ptMinTrackSize.x = lpMinMax-&gt;ptMaxTrackSize.x <br>                            = lpMinMax-&gt;ptMaxSize.x; <br> <br>            lpMinMax-&gt;ptMinTrackSize.y = lpMinMax-&gt;ptMaxTrackSize.y <br>                            = lpMinMax-&gt;ptMaxSize.y; <br>            break; <br>#endif <br>        case WM_HSCROLL: <br>            if(((HWND)lParam == hWndPan) &amp;&amp; lpDSBStreamBuffer ) <br>                { <br>                HandlePanScroll( (int)LOWORD(wParam), (int)HIWORD(wParam)); <br>                } <br>            else if(((HWND)lParam == hWndVol) &amp;&amp; lpDSBStreamBuffer ) <br>                { <br>                HandleVolScroll( (int)LOWORD(wParam), (int)HIWORD(wParam)); <br>                } <br>            else if(((HWND)lParam == hWndFreq) &amp;&amp; lpDSBStreamBuffer ) <br>                { <br>                HandleFreqScroll( (int)LOWORD(wParam), (int)HIWORD(wParam)); <br>                } <br>            break; <br> <br>        case WM_INITMENU: <br>    { <br>    HMENUhSysMenu = GetSystemMenu( hWnd, FALSE ); <br> <br>    EnableMenuItem( hSysMenu, SC_MAXIMIZE, MF_BYCOMMAND | MF_GRAYED ); <br>    EnableMenuItem( hSysMenu, SC_SIZE, MF_BYCOMMAND | MF_GRAYED ); <br> <br>    if((HMENU)wParam != GetMenu( hWnd )) <br>                break; <br>            CheckMenuItem((HMENU)wParam, IDM_OPTIONS_ENUMDRIVERS, <br>                                bEnumDrivers ? MF_CHECKED : MF_UNCHECKED ); <br>    } <br>            break; <br> <br>        case WM_DESTROY: <br>/* <br> * Free all the DirectSound objects we created <br> */ <br>    SendMessage( hWnd, WM_COMMAND, <br>                          MAKEWPARAM( IDM_STOP, DSSTREAM_STOPF_NOREOPEN <br>| DSSTREAM_STOPF_NOEXIT ), 0 ); <br> <br> <br>            if( lpDS ) dsrval = lpDS-&gt;lpVtbl-&gt;Release( lpDS ); <br> <br>            WriteProfileString( "DSSTREAM", "EnumDrivers", <br>                                        bEnumDrivers ? "1" : "0" ); <br> <br>            PostQuitMessage( 0 ); <br>            break; <br> <br>        default: <br>            return DefWindowProc( hWnd, uMsg, wParam, lParam ); <br>        } <br>    return 0L; <br>    } /* WindowProc */ <br> <br> <br>/*****************************************************************************/ <br>/* DLG_About()                                                               */ <br>/*                                                                           */ <br>/*   Dialog procedure for the Help...About... box which simply pops up a     */ <br>/* little copyright message and brief program description.                   */ <br>/*                                                                           */ <br>/*****************************************************************************/ <br>BOOL CALLBACK DLG_About( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam ) <br>    { <br>    switch( msg ) <br>        { <br>        case WM_INITDIALOG: <br>            break; <br> <br>        case WM_COMMAND: <br>            switch( LOWORD(wParam)) <br>                { <br>                case IDOK: <br>                    EndDialog( hDlg, FALSE ); <br>                    return( TRUE ); <br> <br>                default: <br>                    break; <br>                } <br>            break; <br> <br>        default: <br>            return( FALSE ); <br>        } <br> <br>    return( FALSE ); <br>    } <br> <br> <br>/*****************************************************************************/ <br>/* HandleCommDlgError()                                                      */ <br>/*                                                                           */ <br>/*    The function translates extended common dialog error codes into a      */ <br>/* string resource ID, loads that string from our module, and displays it in */ <br>/* a message box. This implementation only covers the general CD error codes.*/ <br>/*                                                                           */ <br>/*****************************************************************************/ <br>int HandleCommDlgError( DWORD dwError ) <br>    { <br>    char szTitle[128]; <br>    UINT uMsgID; <br> <br>    if( dwError == CDERR_DIALOGFAILURE ) <br>        uMsgID = IDS_CDERR_DIALOGFAILURE; <br>    else <br>        uMsgID = (UINT)dwError + IDS_CDERR_GENERAL_BASE; <br> <br>    LoadString( hInst, uMsgID, szTemp, sizeof(szTemp)); <br>    LoadString( hInst, IDS_CDERR_TITLESTRING, szTitle, sizeof(szTitle)); <br>    MessageBox( GetActiveWindow(), szTemp, szTitle, <br>                    MB_OK | MB_ICONEXCLAMATION ); <br> <br>    return( 0 ); <br>    } <br> <br> <br>/*****************************************************************************/ <br>/* StreamBufferSetup()                                                       */ <br>/*                                                                           */ <br>/* This function uses the filename stored in the global character array to*/ <br>/* open a WAVE file. Then it creates a secondary DirectSoundBuffer object    */ <br>/* which will later be used to stream that file from disk during playback.   */ <br>/*                                                                           */ <br>/*****************************************************************************/ <br>int StreamBufferSetup( void ) <br>    { <br>    DSBUFFERDESC dsbd; <br>    HRESULT      dsRetVal; <br> <br>    int nChkErr; <br>int nRem; <br> <br>    /* This portion of the WAVE I/O is patterned after what's in DSTRWAVE, which <br>     * was in turn adopted from WAVE.C which is part of the DSSHOW sample. <br>     */ <br> <br>    if(( nChkErr = WaveOpenFile( szFileBuffer, &amp;wiWave.hmmio, &amp;wiWave.pwfx, &amp;wiWave.mmckInRIFF )) != 0 ) <br>        { <br>        ErrorMessageBox( IDS_ERROR_WAVEFILEOPEN, MB_ICONEXCLAMATION ); <br>        return( ERR_WAVE_OPEN_FAILED ); <br>        } <br> <br>    if( wiWave.pwfx-&gt;wFormatTag != WAVE_FORMAT_PCM ) <br>        { <br>        ErrorMessageBox( IDS_ERROR_WAVENOTPCM, MB_ICONEXCLAMATION ); <br>        WaveCloseReadFile( &amp;wiWave.hmmio, &amp;wiWave.pwfx ); <br>        return( ERR_WAVE_INVALID_FORMAT ); <br>} <br>    // Seek to the data chunk. mmck.ckSize will be the size of all the data in the file. <br>    if(( nChkErr = WaveStartDataRead( &amp;wiWave.hmmio, &amp;wiWave.mmck, &amp;wiWave.mmckInRIFF )) != 0 ) <br>        { <br>        ErrorMessageBox( IDS_ERROR_WAVESEEKFAILED, MB_ICONEXCLAMATION ); <br>        WaveCloseReadFile( &amp;wiWave.hmmio, &amp;wiWave.pwfx ); <br>        return( ERR_WAVE_CORRUPTED_FILE ); <br>        } <br> <br>    // Calculate a buffer length 3 sec. long. This should be an integral number of the <br>// number of bytes in one notification period.  <br>wiWave.dwNotifySize = wiWave.pwfx-&gt;nSamplesPerSec * 3 * (DWORD)wiWave.pwfx-&gt;nBlockAlign; <br>wiWave.dwNotifySize = wiWave.dwNotifySize/NUM_PLAY_NOTIFICATIONS; </code></pre>
<p>
</p>
<pre><code>// the notify size should be an intergral multiple of the nBlockAlignvalue. <br>if ((nRem = wiWave.dwNotifySize%(DWORD)wiWave.pwfx-&gt;nBlockAlign) != 0) <br>{ <br>wiWave.dwNotifySize += (wiWave.pwfx-&gt;nBlockAlign - nRem); <br>} <br>wiWave.dwBufferSize = wiWave.dwNotifySize * NUM_PLAY_NOTIFICATIONS; <br>    DPF(0, "BufferSize = %lu ", wiWave.dwBufferSize); <br> <br>#ifdef DEBUG <br>    wsprintf( szDebug, "BufferSize = %lu", wiWave.dwBufferSize ); <br>    ListBox_AddString( hWndList, szDebug ); <br>#endif <br> <br>     //Create the secondary DirectSoundBuffer object to receive our sound data. <br>    memset( &amp;dsbd, 0, sizeof( DSBUFFERDESC )); <br>    dsbd.dwSize = sizeof( DSBUFFERDESC ); <br>    // Use new GetCurrentPosition() accuracy (DirectX 2 feature) <br>    dsbd.dwFlags = DSBCAPS_CTRLPOSITIONNOTIFY| DSBCAPS_CTRLDEFAULT | DSBCAPS_GETCURRENTPOSITION2 | gdwFocus; <br>    dsbd.dwBufferBytes = wiWave.dwBufferSize; <br> <br>    //Set Format properties according to the WAVE file we just opened <br>    dsbd.lpwfxFormat = wiWave.pwfx; <br>     <br>dsRetVal = lpDS-&gt;lpVtbl-&gt;CreateSoundBuffer( lpDS, &amp;dsbd,&amp;lpDSBStreamBuffer,NULL ); <br>    if( dsRetVal != DS_OK ) <br>        { <br>        ErrorMessageBox( IDS_ERROR_DSBCREATE, MB_ICONEXCLAMATION ); <br>        return( ERR_CREATEDSB_FAILED ); <br>        } <br> <br>    wiWave.lpDSBStreamBuffer = lpDSBStreamBuffer; <br>    wiWave.bFoundEnd = FALSE; <br>wiWave.dwNextWriteOffset = 0; <br>    wiWave.bLoopFile = Button_GetCheck( hWndLoopCheck ); <br> <br>// now get the pointer to the notification interface. <br>dsRetVal = IDirectSoundNotify_QueryInterface(lpDSBStreamBuffer, &amp;IID_IDirectSoundNotify, &amp;((LPVOID)lpDirectSoundNotify)); <br>if (dsRetVal != DS_OK) <br>{ <br>ErrorMessageBox(IDS_ERROR_QINOTIFY_FAILED, MB_ICONEXCLAMATION); <br>    return (dsRetVal); <br>    } <br> <br>// Fill data in the buffer. <br>    FillDataBuffer(); <br> <br>// we're set to play now. <br>    wiWave.bDonePlaying = FALSE; <br> <br>#ifdef DEBUG <br>    wsprintf( szDebug, "wiWave.dwBufferSize = %lu", wiWave.dwBufferSize ); <br>    DPF( 3, "StreamBufferSetup Debug" ); <br>    DPF( 3, szDebug ); <br>#endif <br> <br>    SendMessage( hWndVol, TBM_SETPOS, TRUE, VOL_MAX ); <br>    SendMessage( hWndPan, TBM_SETPOS, TRUE, PAN_CENTER ); <br>    SendMessage( hWndFreq, TBM_SETPOS, TRUE,(LPARAM)wiWave.pwfx-&gt;nSamplesPerSec / FREQ_MULTIPLIER ); <br>    PostMessage( hWndMain, WM_DSSTREAM_PROGRESS, 0L, 0L ); <br>    UpdateFromControls(); <br>    return( 0 ); <br>    } <br> <br> <br>/*****************************************************************************/ <br>/* ResetWavePlayer()                                                         */ <br>/*                                                                           */ <br>/*  Performs a subset of the above operations (in StreamBufferSetup). Things */ <br>/* not done include creating a DSB and opening the file (it's already open). */ <br>/*                                                                           */ <br>/*****************************************************************************/ <br>void ResetWavePlayer( void ) <br>    { <br>int nChkErr = DS_OK; <br>DPF(1, "Resetting wave player"); <br>ASSERT(bPlaying == FALSE); <br> <br>    /* Seek to the data chunk */ <br>    if(( nChkErr = WaveStartDataRead( &amp;wiWave.hmmio, &amp;wiWave.mmck, &amp;wiWave.mmckInRIFF )) != 0 ) <br>        { <br>// This shouldn't happen, since we've done this before. <br>        DPF(0, "Error seeking to file in ResetWavePlayer"); <br>return; <br>        } <br> <br>    wiWave.bFoundEnd = FALSE; <br>wiWave.dwNextWriteOffset = 0; <br> <br>DPF(0, "Reset: Filldatabuffer"); <br>    FillDataBuffer(); <br> <br>    wiWave.bDonePlaying = FALSE; <br>    PostMessage( hWndMain, WM_DSSTREAM_PROGRESS, 0L, 0L ); <br>    } <br> <br> <br>/*****************************************************************************/ <br>/* FillDataBuffer()                                                          */ <br>/*                                                                           */ <br>/*   This function fills the sound buffer with a block of data, starting at  */ <br>/* the current read position.  The entire buffer is filled.                  */ <br>/*                                                                           */ <br>/*****************************************************************************/ <br> void FillDataBuffer( void ) <br> { <br>    LPBYTE  lpWrite1, lpWrite2; <br>    DWORDdwLen1, dwLen2; <br>    UINTuActualBytesWritten; <br>    intnChkErr; <br>    HRESULTdsRetVal; <br>DWORD dwBytes = wiWave.dwBufferSize;  <br> <br>// This is the initial read. So we fill the entire buffer. <br>// This will not wrap around so the 2nd pointers will be NULL. <br>    dsRetVal = lpDSBStreamBuffer-&gt;lpVtbl-&gt;Lock( lpDSBStreamBuffer, 0, dwBytes, <br>&amp;((LPVOID)lpWrite1), &amp;dwLen1, <br>&amp;(LPVOID)lpWrite2, &amp;dwLen2, 0 ); <br>ASSERT(lpWrite2 == NULL); <br>ASSERT(dwLen2 == 0); <br> <br>if (dwLen1 != dwBytes) <br>{ <br>DPF(0, "FillDataBuffer: dwBytes != dwLen1"); <br>} <br> <br> <br>    if( dsRetVal != DS_OK ) <br>{ <br>ASSERT(FALSE); <br>return;  <br>} <br> <br>ASSERT(dwLen1); <br>ASSERT( NULL != lpWrite1 ); <br>ASSERT(wiWave.dwNextWriteOffset &lt; wiWave.dwBufferSize); <br> <br>    nChkErr = WaveReadFile( wiWave.hmmio, (UINT)dwLen1, lpWrite1, <br>                            &amp;wiWave.mmck, &amp;uActualBytesWritten ); <br>// if the number of bytes written is less than the  <br>// amount we requested, we have a short file. <br>if (uActualBytesWritten &lt; dwLen1) <br>{ <br>DPF(0, "FillDataBuffer: Actual written is less than dwlen1"); <br>if (!wiWave.bLoopFile) <br>{ <br>// we set the bFoundEnd flag if the length is less than <br>// one notify period long which is when the first notification comes in. <br>// The next notification will then call send a message to process a stop.  <br>if (uActualBytesWritten &lt; wiWave.dwNotifySize) <br>wiWave.bFoundEnd = TRUE; <br>// Fill in silence for the rest of the buffer. <br>DPF(0, "Filling in silence"); <br>FillMemory(lpWrite1+uActualBytesWritten, dwLen1-uActualBytesWritten,  <br>(BYTE)(wiWave.pwfx-&gt;wBitsPerSample == 8 ? 128 : 0)); <br>} <br>else <br>{ <br>// we are looping. <br>UINT uWritten = uActualBytesWritten;// from previous call above. <br>while (uWritten &lt; dwLen1) <br>{// this will keep reading in until the buffer is full. For very short files. <br>nChkErr = WaveStartDataRead( &amp;wiWave.hmmio, &amp;wiWave.mmck, &amp;wiWave.mmckInRIFF ); <br>ASSERT(nChkErr == 0);// we've already this before so shouldn't fail. <br>nChkErr = WaveReadFile(wiWave.hmmio, (UINT)dwLen1-uWritten,  <br>lpWrite1 + uWritten, &amp;wiWave.mmck, &amp;uActualBytesWritten); <br>uWritten += uActualBytesWritten; <br>} // while <br>ASSERT(wiWave.bFoundEnd == FALSE); <br>} // else <br>} <br> <br>// now unlock the buffer. <br>dsRetVal = lpDSBStreamBuffer-&gt;lpVtbl-&gt;Unlock( lpDSBStreamBuffer, (LPVOID)lpWrite1, dwLen1,NULL, 0 ); <br>                                                                              <br>wiWave.dwNextWriteOffset += dwLen1; <br>// this is a circular buffer. Do mod buffersize. <br>if (wiWave.dwNextWriteOffset &gt;= wiWave.dwBufferSize) <br>wiWave.dwNextWriteOffset -= wiWave.dwBufferSize;  <br> <br>DPF(3, "Setting dwProgress = 0"); <br>wiWave.dwProgress = 0; <br>wiWave.dwLastPos = 0; <br>} <br> <br> <br>/*****************************************************************************/ <br>/* CreateChildren()                                                          */ <br>/*                                                                           */ <br>/*   This function creates a bunch of child controls for the main window.    */ <br>/* Most of them are used for controling various things about a playing sound */ <br>/* file, like volume and panning. Returns FALSE if no errors, TRUE otherwise.*/ <br>/*                                                                           */ <br>/*****************************************************************************/ <br>int CreateChildren( RECT crect ) <br>    { <br>    SIZE  Size; <br>    HDC   hDC; <br>    int  x, y; <br>    UINT  uType; <br>    char  szTemplate[128], szType[32]; <br>    LPSTR lpszControl; <br> <br>    LoadString( hInst, IDS_ERROR_CHILDTEMPLATE, szTemplate, sizeof(szTemplate)); <br> <br>    /* Don't handle failure for this one, because the app will still run fine */ <br>    hWndBar = CreateWindow( "static", NULL, <br>                            WS_CHILD | WS_VISIBLE | SS_ETCHEDHORZ, <br>                            0, 0, crect.right, 2, hWndMain, <br>                            (HMENU)0, hInst, NULL ); <br> <br>    hDC = GetDC( hWndMain ); <br>    if( !GetTextExtentPoint32( hDC, szPan, strlen(szPan), &amp;Size )) <br>        { <br>        ErrorMessageBox( IDS_ERROR_GETTEXTEXTENT, MB_ICONEXCLAMATION ); <br>        ReleaseDC( hWndMain, hDC ); <br>        return( TRUE ); <br>        } <br>    ReleaseDC( hWndMain, hDC ); <br> <br>    y = BORDER_SPACE_CY; <br> <br>    /* STATIC control -- text label for the pan trackbar */ <br>    if(( hWndPanText = CreateWindow( "static", szPan, <br>                                    WS_CHILD | WS_VISIBLE | SS_LEFTNOWORDWRAP,  <br>                                    BORDER_SPACE_CX + PAN_TB_CX + TEXT_SPACE_CX, <br>                                    y + (PAN_TB_CY - Size.cy)/2, <br>                                    PAN_TEXT_CX, Size.cy, <br>                                    hWndMain, (HMENU)0, hInst, NULL)) == NULL ) <br>        { <br>        lpszControl = szPan; <br>uType = IDS_ERROR_STATICTEXT; <br>        goto DISPLAY_CREATE_FAILURE; <br>        } <br> <br>    /* PAN (left to right balance) trackbar control */ <br>    if(( hWndPan = CreateWindow( TRACKBAR_CLASS, NULL, <br>                                WS_CHILD | WS_VISIBLE | TBS_HORZ | TBS_BOTTOM, <br>                                BORDER_SPACE_CX, <br>                                y, PAN_TB_CX, PAN_TB_CY, <br>                                hWndMain, (HMENU)0, hInst, NULL)) == NULL ) <br>        { <br>        lpszControl = szPan; <br>uType = IDS_ERROR_TRACKBAR; <br>        goto DISPLAY_CREATE_FAILURE; <br>} <br> <br>    SendMessage( hWndPan, TBM_SETRANGE, FALSE, MAKELONG( PAN_MIN, PAN_MAX ));  <br>    SendMessage( hWndPan, TBM_SETPOS, TRUE, PAN_CENTER ); <br>    SendMessage( hWndPan, TBM_SETPAGESIZE, 0L, PAN_PAGESIZE ); <br> <br>    y += PAN_TB_CY + CONTROL_SPACE_CY; <br> <br>    /* STATIC control -- text label for the volume trackbar */ <br>    if(( hWndVolText = CreateWindow( "static", szVolume, <br>                                    WS_CHILD | WS_VISIBLE | SS_LEFTNOWORDWRAP,  <br>                                    BORDER_SPACE_CX + VOL_TB_CX + TEXT_SPACE_CX, <br>                                    y + (VOL_TB_CY - Size.cy)/2, <br>                                    VOL_TEXT_CX, Size.cy, <br>                                    hWndMain, (HMENU)0, hInst, NULL)) == NULL ) <br>        { <br>        lpszControl = szVolume; <br>uType = IDS_ERROR_STATICTEXT; <br>        goto DISPLAY_CREATE_FAILURE; <br>} <br> <br>    /* Create the VOLUME trackbar */ <br>    if(( hWndVol = CreateWindow( TRACKBAR_CLASS, NULL, <br>                                WS_CHILD | WS_VISIBLE | TBS_HORZ | TBS_BOTTOM, <br>                                BORDER_SPACE_CX, <br>                                y, VOL_TB_CX, VOL_TB_CY, <br>                                hWndMain, (HMENU)0, hInst, NULL)) == NULL ) <br>        { <br>        lpszControl = szVolume; <br>uType = IDS_ERROR_TRACKBAR; <br>        goto DISPLAY_CREATE_FAILURE; <br>} <br> <br>    SendMessage( hWndVol, TBM_SETRANGE, FALSE, <br>                                        MAKELONG( VOL_MIN, VOL_MAX )); <br>    SendMessage( hWndVol, TBM_SETPOS, TRUE, VOL_MAX ); <br>    SendMessage( hWndVol, TBM_SETPAGESIZE, 0L, VOL_PAGESIZE ); <br> <br>    y += VOL_TB_CY + CONTROL_SPACE_CY; <br> <br>    /* STATIC control -- text label for the frequency trackbar */ <br>    if(( hWndFreqText = CreateWindow( "static", szFrequency, <br>                                    WS_CHILD | WS_VISIBLE | SS_LEFTNOWORDWRAP,  <br>                                    BORDER_SPACE_CX + FREQ_TB_CX + TEXT_SPACE_CX, <br>                                    y + (FREQ_TB_CY - Size.cy)/2, <br>                                    FREQ_TEXT_CX, Size.cy, <br>                                    hWndMain, (HMENU)0, hInst, NULL)) == NULL ) <br>        { <br>        lpszControl = szFrequency; <br>uType = IDS_ERROR_STATICTEXT; <br>        goto DISPLAY_CREATE_FAILURE; <br>} <br> <br>    /* Create the FREQUENCY trackbar */ <br>    if(( hWndFreq = CreateWindow( TRACKBAR_CLASS, NULL, <br>                                WS_CHILD | WS_VISIBLE | TBS_HORZ | TBS_BOTTOM, <br>                                BORDER_SPACE_CX, <br>                                y, FREQ_TB_CX, FREQ_TB_CY, <br>                                hWndMain, (HMENU)0, hInst, NULL)) == NULL ) <br>        { <br>        lpszControl = szFrequency; <br>uType = IDS_ERROR_TRACKBAR; <br>        goto DISPLAY_CREATE_FAILURE; <br>} <br> <br>    SendMessage( hWndFreq, TBM_SETRANGE, FALSE, MAKELONG( FREQ_MIN, FREQ_MAX )); <br>    SendMessage( hWndFreq, TBM_SETPOS, TRUE, FREQ_MAX ); <br>    SendMessage( hWndFreq, TBM_SETPAGESIZE, 0L, FREQ_PAGESIZE ); <br> <br>    y += FREQ_TB_CY + CONTROL_SPACE_CY; <br> <br>    /* STATIC control -- text label for the progress trackbar */ <br>    if(( hWndProgText = CreateWindow( "static", szProgress, <br>                                    WS_CHILD | WS_VISIBLE | SS_LEFTNOWORDWRAP,  <br>                                    BORDER_SPACE_CX + PROG_TB_CX + TEXT_SPACE_CX, <br>                                    y + (PROG_TB_CY - Size.cy)/2, <br>                                    PROG_TEXT_CX, Size.cy, <br>                                    hWndMain, (HMENU)0, hInst, NULL)) == NULL ) <br>        { <br>        lpszControl = szProgress; <br>uType = IDS_ERROR_STATICTEXT; <br>        goto DISPLAY_CREATE_FAILURE; <br>} <br> <br>    /* Create the PROGRESSS trackbar */ <br>    if(( hWndProg = CreateWindow( TRACKBAR_CLASS, NULL, <br>                                WS_CHILD | WS_VISIBLE | TBS_HORZ <br>| TBS_BOTTOM | WS_DISABLED, <br>                                BORDER_SPACE_CX, <br>                                y, PROG_TB_CX, PROG_TB_CY, <br>                                hWndMain, (HMENU)0, hInst, NULL)) == NULL ) <br>        { <br>        lpszControl = szProgress; <br>uType = IDS_ERROR_TRACKBAR; <br>        goto DISPLAY_CREATE_FAILURE; <br>} <br> <br>    SendMessage( hWndProg, TBM_SETRANGE, <br>    FALSE, MAKELPARAM( PROG_MIN, PROG_MAX )); <br>    SendMessage( hWndProg, TBM_SETPOS, TRUE, 0L ); <br> <br>    x = BORDER_SPACE_CX + PAN_TEXT_CX + TEXT_SPACE_CX <br>    + PAN_TB_CX + CONTROL_SPACE_CX; <br>    y += PROG_TB_CY; <br>    y -= 2*(BUTTON_CY + BUTTON_SPACE_CY) + CHECK_CY; <br> <br>    /* Create the LOOPED CHECKBOX */ <br>    LoadString( hInst, IDS_CHECK_LOOPED, szTemp, sizeof(szTemp)); <br>    if(( hWndLoopCheck = CreateWindow( "button", szTemp, <br>                                WS_CHILD | WS_VISIBLE | BS_CHECKBOX, <br>                                x, y, CHECK_CX, CHECK_CY, hWndMain, <br>                                (HMENU)IDC_LOOPCHECK, hInst, NULL )) == NULL ) <br>        { <br>        lpszControl = szTemp; <br>uType = IDS_ERROR_CHECK; <br>        goto DISPLAY_CREATE_FAILURE; <br>} <br>    y += CHECK_CY + BUTTON_SPACE_CY; <br> <br>    /* Create the PLAY BUTTON */ <br>    LoadString( hInst, IDS_BUTTON_PLAY, szTemp, sizeof(szTemp)); <br>    if(( hWndPlay = CreateWindow( "button", szTemp, <br>                                    WS_CHILD | WS_VISIBLE | WS_DISABLED, <br>                                    x, y, BUTTON_CX, BUTTON_CY, hWndMain, <br>                                    (HMENU)IDM_PLAY, hInst, NULL )) == NULL ) <br>        { <br>        lpszControl = szTemp; <br>uType = IDS_ERROR_BUTTON; <br>        goto DISPLAY_CREATE_FAILURE; <br>} <br>    y += BUTTON_CY + BUTTON_SPACE_CY; <br> <br>    /* Create the STOP BUTTON */ <br>    LoadString( hInst, IDS_BUTTON_STOP, szTemp, sizeof(szTemp)); <br>    if(( hWndStop = CreateWindow( "button", szTemp, <br>                                    WS_CHILD | WS_VISIBLE | WS_DISABLED, <br>                                    x, y, BUTTON_CX, BUTTON_CY, hWndMain, <br>                                    (HMENU)IDM_STOP, hInst, NULL )) == NULL ) <br>        { <br>        lpszControl = szTemp; <br>uType = IDS_ERROR_BUTTON; <br>        goto DISPLAY_CREATE_FAILURE; <br>} <br> <br>    UpdateFromControls(); <br>    goto RETURN_NORMAL; <br> <br>DISPLAY_CREATE_FAILURE: <br>    LoadString( hInst, uType, szType, sizeof(szType)); <br>    wsprintf( szTemp, szTemplate, lpszControl, szType ); <br>    MessageBox( GetActiveWindow(), szTemp, <br>                        szAppTitle, MB_OK | MB_ICONEXCLAMATION ); <br>    return( TRUE ); <br> <br>RETURN_NORMAL: <br>    return( FALSE ); <br>    } <br> <br> <br>/********************************************************************************/ <br>/* UpdateFromControls()                                                         */ <br>/*                                                                              */ <br>/*    This function gets all the required values from the DirectSoundBuffer and */ <br>/* updates the screen interface controls.                                       */ <br>/*                                                                              */ <br>/********************************************************************************/ <br>void UpdateFromControls( void ) <br>    { <br>    longlPan, lVol, lFreq; <br>    HRESULT hr; <br> <br>    lPan = (LONG)SendMessage( hWndPan, TBM_GETPOS, (WPARAM)0, (LPARAM)0 ); <br>    lVol = (LONG)SendMessage( hWndVol, TBM_GETPOS, (WPARAM)0, (LPARAM)0 ); <br>    lFreq = (LONG)SendMessage( hWndFreq, TBM_GETPOS, (WPARAM)0, (LPARAM)0 ); <br> <br>    /* Set the volume and then the pan */ <br>    if( lpDSBStreamBuffer ) <br>        { <br>        /* Set the volume */ <br>        wsprintf( szTemp, "%s: %lidB", szVolume, <br>                                            ( lVol + VOL_SHIFT ) / VOL_DIV ); <br>        Static_SetText( hWndVolText, szTemp ); <br> <br>        hr = lpDSBStreamBuffer-&gt;lpVtbl-&gt;SetVolume( lpDSBStreamBuffer, <br>                                            (((lVol+VOL_SHIFT) * VOL_MULT)) ); <br>        if( hr != 0 ) <br>            DPF( 0, "Unable to SetVolume in UpdateFromControls()" ); <br>        else <br>            { <br>            wsprintf( szDebug, "Set volume to %lidB", <br>                                            ( lVol + VOL_SHIFT ) / VOL_DIV ); <br>            DPF( 3, szDebug ); <br>            } <br> <br>        /* Set the Pan */ <br>        wsprintf( szTemp, "%s: %lidB", szPan, ( lPan + PAN_SHIFT ) / PAN_DIV ); <br>        Static_SetText( hWndPanText, szTemp ); <br> <br>        hr = lpDSBStreamBuffer-&gt;lpVtbl-&gt;SetPan( lpDSBStreamBuffer, <br>                                            (((lPan+PAN_SHIFT) * PAN_MULT)) ); <br>        if( hr != 0 ) <br>            DPF( 0, "Unable to SetPan in UpdateFromControls()" ); <br>        else <br>            { <br>            wsprintf( szDebug, "Set pan to %lidB", <br>                                            ( lPan + PAN_SHIFT ) / PAN_DIV ); <br>            DPF( 3, szDebug ); <br>            } <br> <br>        /* Set the frequency */ <br>        wsprintf( szTemp, "%s: %liHz", szFrequency, lFreq * FREQ_MULTIPLIER ); <br>        Static_SetText( hWndFreqText, szTemp ); <br> <br>        hr = lpDSBStreamBuffer-&gt;lpVtbl-&gt;SetFrequency( lpDSBStreamBuffer, <br>                                                        lFreq * FREQ_MULTIPLIER); <br>        if( hr != 0 ) <br>            DPF( 0, "Unable to SetFrequency in UpdateFromControls()" ); <br>        else <br>            { <br>            wsprintf( szDebug, "Set frequency to %liHz", lFreq*FREQ_MULTIPLIER ); <br>            DPF( 3, szDebug ); <br>            } <br>        } <br>        return; <br>    } <br> <br> <br>/********************************************************************************/ <br>/* HandlePanScroll()                                                            */ <br>/*                                                                              */ <br>/*   Handles the pan trackbar scroll when a WM_HSCROLL is received.             */ <br>/*                                                                              */ <br>/********************************************************************************/ <br>void HandlePanScroll( int nCode, int nPos ) <br>    { <br>    long  lPan, lDelta; <br> <br>    lPan = (LONG)SendMessage( hWndPan, TBM_GETPOS, (WPARAM)0, (LPARAM)0 ); <br> <br>    switch( nCode ) <br>        { <br>        case TB_LINEUP: <br>            if( lPan &gt;= PAN_MIN - 1 ) <br>                lDelta = -1; <br>            break; <br>        case TB_LINEDOWN: <br>            if( lPan &lt;= PAN_MAX + 1 ) <br>                lDelta = 1; <br>            break; <br>        case TB_PAGEUP: <br>            if( lPan &gt;= PAN_MIN - PAN_PAGESIZE ) <br>                lDelta = -16; <br>            break; <br>        case TB_PAGEDOWN: <br>            if( lPan &lt;= PAN_MAX + PAN_PAGESIZE ) <br>                lDelta = 16; <br>            break; <br>        case TB_ENDTRACK: <br>            return; <br>        default: <br>            lDelta = 0; <br>        } <br> <br>    if( lDelta ) <br>        SendMessage( hWndPan, TBM_SETPOS, TRUE, lPan + lDelta ); <br>    else <br>        SendMessage( hWndPan, TBM_SETPOS, TRUE, (long)nPos ); <br>    UpdateFromControls(); <br>    } <br> <br> <br>/********************************************************************************/ <br>/* HandleVolScroll()                                                            */ <br>/*                                                                              */ <br>/*   Handles the volume trackbar scrolling when a WM_HSCROLL is received.       */ <br>/*                                                                              */ <br>/********************************************************************************/ <br>void HandleVolScroll( int nCode, int nPos ) <br>    { <br>    long  lVol, lDelta; <br> <br>    lVol = (LONG)SendMessage( hWndVol, TBM_GETPOS, (WPARAM)0, (LPARAM)0 ); <br> <br>    switch( nCode ) <br>        { <br>        case TB_LINEDOWN: <br>            if( lVol &lt;= VOL_MAX - 1 ) <br>                lDelta = 1; <br>            break; <br>        case TB_LINEUP: <br>            if( lVol &gt;= VOL_MIN + 1 ) <br>                lDelta = -1; <br>            break; <br>        case TB_PAGEDOWN: <br>            if( lVol &lt;= VOL_MAX - VOL_PAGESIZE ) <br>                lDelta = 10; <br>            break; <br>        case TB_PAGEUP: <br>            if( lVol &gt;= VOL_MIN + VOL_PAGESIZE ) <br>                lDelta = -10; <br>            break; <br>        case TB_ENDTRACK: <br>            return; <br>        default: <br>            lDelta = 0; <br>        } <br> <br>    if( lDelta ) <br>        SendMessage( hWndVol, TBM_SETPOS, TRUE, (lVol + lDelta)); <br>    else <br>        SendMessage( hWndVol, TBM_SETPOS, TRUE, (long)nPos ); <br>    UpdateFromControls(); <br>    } <br> <br> <br>/********************************************************************************/ <br>/* HandleFreqScroll()                                                           */ <br>/*                                                                              */ <br>/*   Handles the volume trackbar scrolling when a WM_HSCROLL is received.       */ <br>/*                                                                              */ <br>/********************************************************************************/ <br>void HandleFreqScroll( int nCode, int nPos ) <br>    { <br>    long  lFreq, lDelta; <br> <br>    lFreq = (LONG)SendMessage( hWndFreq, TBM_GETPOS, (WPARAM)0, (LPARAM)0 ); <br> <br>    switch( nCode ) <br>        { <br>        case TB_LINEDOWN: <br>            if( lFreq &lt;= FREQ_MAX-1 ) <br>                lDelta = 1; <br>            break; <br>        case TB_LINEUP: <br>            if( lFreq &gt;= FREQ_MIN+1 ) <br>                lDelta = -1; <br>            break; <br>        case TB_PAGEDOWN: <br>            if( lFreq &lt;= FREQ_MAX - FREQ_PAGESIZE ) <br>                lDelta = 10; <br>            break; <br>        case TB_PAGEUP: <br>            if( lFreq &gt;= FREQ_MIN + FREQ_PAGESIZE ) <br>                lDelta = -10; <br>            break; <br>        case TB_ENDTRACK: <br>            return; <br>        default: <br>            lDelta = 0; <br>        } <br> <br>    if( lDelta ) <br>        SendMessage( hWndFreq, TBM_SETPOS, TRUE, (lFreq + lDelta)); <br>    else <br>        SendMessage( hWndFreq, TBM_SETPOS, TRUE, (long)nPos ); <br>    UpdateFromControls(); <br>    } <br> <br> <br>/****************************************************************************/ <br>/* ErrorMessageBox()                                                        */ <br>/*                                                                          */ <br>/*   A little routine to load error messages from the string resource table */ <br>/* and pop them up in a MessageBox() for the world to see. The dwMBFlags    */ <br>/* parameter allows the caller to specify the type of icon to use.          */ <br>/*                                                                          */ <br>/****************************************************************************/ <br>void ErrorMessageBox( UINT uID, DWORD dwMBFlags ) <br>    { <br>    LoadString( hInst, uID, szTemp, sizeof(szTemp)); <br>    MessageBox( GetActiveWindow(), szTemp, szAppTitle, MB_OK | dwMBFlags ); <br>    } <br> <br> <br>/****************************************************************************/ <br>/* BuildTitleBar()                                                          */ <br>/*                                                                          */ <br>/*   Small routine to build and set the title bar text depending on whether */ <br>/* or not a file is open.                                                   */ <br>/****************************************************************************/ <br>void BuildTitleBarText( void ) <br>    { <br>    char szTitle[ sizeof(szAppCaption) + MAX_PATH + sizeof(" - ")]; <br> <br>    lstrcpy( szTitle, szAppCaption ); <br>    if( bFileOpen ) <br>{ <br>lstrcat( szTitle, " - " ); <br>lstrcat( szTitle, szFileTitle ); <br>} <br>    SetWindowText( hWndMain, szTitle ); <br>    } <br> <br> <br>/****************************************************************************/ <br>/* GetMediaStartPath()                                                      */ <br>/*                                                                          */ <br>/*   This helper function attempts to get the media directory for Direct3D, */ <br>/* which is where all the installed DX wave files go. If it can't find that */ <br>/* it settles for the media sub-directory of the Windows directory.         */ <br>/****************************************************************************/ <br>void GetMediaStartPath( void ) <br>    { <br>    HKEY    hReg; <br>    DWORD   cbStartPathLen; <br> <br>    if( ERROR_SUCCESS != RegOpenKeyEx( HKEY_LOCAL_MACHINE, <br>gszRegKeyDirect3D, <br>0, KEY_READ, &amp;hReg )) <br>{ <br>        goto REG_OPEN_FAILED; <br>} <br>    else <br>{ <br>// Query the Registry for the path to the media directory <br>cbStartPathLen = sizeof( szCDStartPath ); <br>if( ERROR_SUCCESS != RegQueryValueEx( hReg, gszRegValueD3DPath, <br>NULL, NULL, <br>szCDStartPath, &amp;cbStartPathLen )) <br>    { <br>    goto REG_OPEN_FAILED; <br>    } <br>RegCloseKey( hReg ); <br>hReg = NULL; <br>} <br> <br>    return; <br> <br>REG_OPEN_FAILED: <br>    // Start off by getting the Windows directory -- we're trying to build a <br>    // file path like "C:\WINDOWS\MEDIA", but the WINDOWS directory could be <br>    // named anything, so we must ask. <br>    GetWindowsDirectory( szCDStartPath, sizeof(szCDStartPath)); <br>    // If there's no trailing backslash, append one <br>    if( lstrcmp( &amp;szCDStartPath[lstrlen(szCDStartPath)], TEXT("\\") )) <br>lstrcat( szCDStartPath, TEXT("\\")); <br>    // Now add on the MEDIA part of the path <br>    lstrcat( szCDStartPath, TEXT("MEDIA")); <br>    } <br> <br> <br>void LoadFromCommandLine( LPSTR lpszCmd ) <br>    { <br>    LPSTR lpsz = lpszCmd; <br>    LPSTR lpToken; <br>    BOOL  fStartPlaying = FALSE, fStartLooping = FALSE; <br>    char  szToken[MAX_TOKEN_LEN+1]; <br>    int   i; <br> <br>    if( !lpsz ) <br>return; <br> <br>    // Clear leading spaces <br>    while( *lpsz == ' ' ) <br>lpsz++; <br>     <br>    // If we need to accept more command-line parameters later, we can <br>    // extend the code below into a loop that searchs for each one. <br>    while( *lpsz == '/' || *lpsz == '-' ) <br>{ <br>// Don't advance lpsz until we're sure we really should be reading <br>// this string (i.e. we recognize that it's the play command <br>lpToken = ++lpsz; <br>for( i = 0; i &lt; MAX_TOKEN_LEN; i++ ) <br>    { <br>    if( !*lpToken || *lpToken == ' ' ) <br>break; <br>    szToken[i] = *lpToken++; <br>    } <br>szToken[i] = 0; <br> <br>if( !lstrcmpi( szToken, gszPlayToken )) <br>    { <br>    // Automagically start playing the file <br>    fStartPlaying = TRUE; <br>    lpsz = lpToken; <br>    } <br>else if( !lstrcmpi( szToken, gszLoopToken )) <br>    { <br>    // Set the player in looping mode at startup <br>    fStartLooping = TRUE; <br>    lpsz = lpToken; <br>    } <br>else if( !lstrcmpi( szToken, gszStickyToken )) <br>    { <br>    // Use Sticky Focus for the buffer <br>    gdwFocus = DSBCAPS_STICKYFOCUS; <br>    lpsz = lpToken; <br>    } <br>else if( !lstrcmpi( szToken, gszGlobalToken )) <br>    { <br>    // Use Global Focus for the buffer <br>    gdwFocus = DSBCAPS_GLOBALFOCUS; <br>    lpsz = lpToken; <br>    } <br>else if( !lstrcmpi( szToken, gszCloseToken )) <br>    { <br>    // "/close" will cause the program to shutdown after it's done <br>    // playing the file that was presumably loaded at the command-line <br>    gfCloseOnDone = TRUE; <br>    lpsz = lpToken; <br>    } <br>else <br>    { <br>    // Unrecognized parameter followed the slash, so skip over it <br>    // and find the next break <br>    while( *lpsz &amp;&amp; *lpsz != ' ' ) <br>lpsz++; <br>    } <br>// Clear any spaces out again <br>while( *lpsz == ' ' ) <br>    lpsz++; <br>} <br> <br>    // If that's all that was on the command-line, simply return <br>    if( !*lpsz ) <br>return; <br> <br>    // ASSUMPTION: We assume that a single filename is the only remaining <br>    // parameter.  This works out okay because anything else will fail in the <br>    // file load inside StreamBufferSetup(); <br>    lstrcpy( szFileBuffer, lpsz ); <br> <br>    // Search backwards and find the last backslash, stopping at the <br>    // beginning of the file name <br>    lpsz = &amp;szFileBuffer[lstrlen(szFileBuffer)]; <br> <br>    while( lpsz &gt; szFileBuffer ) <br>{ <br>if( *(lpsz-1) == '\\' ) <br>    { <br>    break; <br>    } <br>lpsz--; <br>} <br>    // Fake the szFileTitle, which normally gets set by the Common Dialog <br>    lstrcpy( szFileTitle, lpsz ); <br>    lstrcpy( szCDStartPath, szFileBuffer ); <br>    szCDStartPath[lpsz-szFileBuffer] = 0; <br> <br>    if( fStartLooping ) <br>{ <br>// Allowing auto-close when the user will have plenty of time to click <br>// stop would cause the app to shutdown right as they hit the button, <br>// which is weird behavior. </code></pre>
<p>
</p>
<pre><code>gfCloseOnDone = FALSE; <br>Button_SetCheck( hWndLoopCheck, TRUE ); <br>} <br> <br>    if( StreamBufferSetup() != 0 ) <br>{ <br>// Error opening the WAVE file so abort <br>return; <br>} <br>    else <br>{ <br>bFileOpen = TRUE; <br>EnableMenuItem( GetMenu( hWndMain ), IDM_PLAY, <br>MF_BYCOMMAND | MF_ENABLED ); <br>EnableWindow( hWndPlay, TRUE ); <br>EnableMenuItem( GetMenu( hWndMain ), IDM_FILE_CLOSE, <br>MF_BYCOMMAND | MF_ENABLED ); <br>DrawMenuBar( hWndMain ); <br>BuildTitleBarText(); <br> <br>if( fStartPlaying ) <br>    SendMessage( hWndMain, WM_COMMAND, MAKEWPARAM( IDM_PLAY, 0 ), 0L ); <br>} <br>    } <br> <br> <br>// ========================================================== <br>// SetupNotifications <br>//Sets notifications and also creates the events.  <br>// ========================================================== <br>int SetupNotifications(void) <br>{ <br>int hr = DS_OK; <br>DSBPOSITIONNOTIFY dsbPosNotify[NUM_PLAY_NOTIFICATIONS +1 ]; <br>DWORD dwSize = wiWave.dwNotifySize; <br>DWORD dwThreadId; <br>int i; <br> <br>// Create the 2 events. One for Play one for stop. <br>hNotifyEvent[0] = CreateEvent(NULL, FALSE, FALSE, NULL); <br>ASSERT(hNotifyEvent[0]); <br>hNotifyEvent[1] = CreateEvent(NULL, FALSE, FALSE, NULL); <br>ASSERT(hNotifyEvent[1]); <br> <br>// setup the first one. <br>dsbPosNotify[0].dwOffset = dwSize; <br>dsbPosNotify[0].hEventNotify = hNotifyEvent[0]; <br>DPF(0, "Set notifies for position %lu", dsbPosNotify[0].dwOffset); <br> <br>for (i = 1; i &lt; NUM_PLAY_NOTIFICATIONS; i++) <br>{ <br>dsbPosNotify[i].dwOffset = dsbPosNotify[i-1].dwOffset + dwSize; <br>dsbPosNotify[i].hEventNotify = hNotifyEvent[0]; <br>DPF(0, "Set notifies for positions %lu", dsbPosNotify[i].dwOffset); <br>} <br> <br>dsbPosNotify[i-1].dwOffset -= 1; <br>// set the stop notification. <br>dsbPosNotify[i].dwOffset = DSBPN_OFFSETSTOP; <br>dsbPosNotify[i].hEventNotify = hNotifyEvent[1]; <br> <br>// Now create the thread to wait on the events created. <br>if (CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)HandleNotifications, NULL, 0, &amp;dwThreadId) == NULL) <br>{ <br>DPF(0, "CreateThread failed"); <br>goto HandleErr; <br>} <br>else <br>DPF(0, "Created thread"); <br> <br>// setup notification <br>hr = lpDirectSoundNotify-&gt;lpVtbl-&gt;SetNotificationPositions(lpDirectSoundNotify,  <br>NUM_PLAY_NOTIFICATIONS +1, <br>dsbPosNotify); <br> <br>HandleErr: <br>if (hr != DS_OK) <br>{if (hr == DSERR_INVALIDPARAM) <br>DPF(0, "SetupNotificationPos failed. Invalid Param"); <br>if (hr == DSERR_OUTOFMEMORY) <br>DPF(0, "SetupNotificationPos failed. OutOfMemory"); <br>CloseHandle(hNotifyEvent[0]); <br>CloseHandle(hNotifyEvent[1]); <br>hNotifyEvent[0] = hNotifyEvent[1] = (HANDLE)NULL; <br>} <br>#ifdef DEBUG <br>else <br>{ <br>DPF(3, "SetNotificationPos succeeded."); <br>} <br>#endif <br> <br>return (hr); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
