<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DIALOG.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3065"></a>DIALOG.CPP</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved. <br> * <br> *  File:       dialog.cpp <br> *  Content:Creates a dialog to query the user for connection settings <br> *and establish a connection. <br> * <br> ***************************************************************************/ <br> <br>#define INITGUID <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;cguid.h&gt; <br> <br>#include "dpslots.h" <br>#include "resource.h" <br> <br>// constants <br>const UINTTIMERID= 1;// timer ID to use <br>const UINTTIMERINTERVAL= 1000;// timer interval <br> <br>// structures <br> <br>// server configuration information <br>typedef struct { <br>CHARszServerName[MAXSTRLEN]; <br>CHARszDatabaseFile[MAXSTRLEN]; <br>CHARszSecurityProvider[MAXSTRLEN]; <br>BOOLbRequireSecureLogin; <br>} SERVERCONFIG, *LPSERVERCONFIG; <br> <br>// client login information <br>typedef struct { <br>CHARszPlayerName[MAXSTRLEN]; <br>CHARszUserName[MAXSTRLEN]; <br>CHARszPassword[MAXSTRLEN]; <br>CHARszDomain[MAXSTRLEN]; <br>} CLIENTLOGIN, *LPCLIENTLOGIN; <br> <br>// prototypes <br>BOOL CALLBACKConnectWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam); <br> <br>HRESULTCreateDirectPlayInterface(LPDIRECTPLAY3A *lplpDirectPlay3A ); <br>BOOL FAR PASCAL DirectPlayEnumConnectionsCallback(LPCGUID lpguidSP, <br>LPVOID lpConnection, DWORD dwConnectionSize, <br>LPCDPNAME lpName, DWORD dwFlags, LPVOID lpContext); <br>HRESULTDestroyDirectPlayInterface(HWND hWnd, LPDIRECTPLAY3A lpDirectPlay3A); <br>HRESULTHostSession(LPDIRECTPLAY3A lpDirectPlay3A, <br>LPSERVERCONFIG lpServerConfig, <br>LPDPLAYINFO lpDPInfo); <br>HRESULTJoinSession(LPDIRECTPLAY3A lpDirectPlay3A, <br>LPGUID lpguidSessionInstance, <br>LPCLIENTLOGIN lpClientLogin, <br>LPDPLAYINFO lpDPInfo); <br>HRESULTEnumSessions(HWND hWnd, LPDIRECTPLAY3A lpDirectPlay3A); <br> <br>HRESULTGetConnection(HWND hWnd, LPVOID *lplpConnection); <br>voidDeleteConnectionList(HWND hWnd); <br>HRESULTGetSessionInstanceGuid(HWND hWnd, LPGUID lpguidSessionInstance); <br>voidSelectSessionInstance(HWND hWnd, LPGUID lpguidSessionInstance); <br>voidDeleteSessionInstanceList(HWND hWnd); <br>BOOLGetServerConfig(HWND hWnd, LPSERVERCONFIG lpServerConfig); <br>BOOLGetClientLogin(HWND hWnd, LPCLIENTLOGIN lpClientLogin); <br>HRESULTGetSessionDesc(LPDIRECTPLAY3A lpDirectPlay3A, LPDPSESSIONDESC2 *lplpSessionDesc); <br> <br>HRESULT ConnectUsingDialog(HINSTANCE hInstance, LPDPLAYINFO lpDPInfo) <br>{ <br>// ask user for connection settings <br>if (DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_CONNECTDIALOG), <br>   NULL, (DLGPROC) ConnectWndProc, (LPARAM) lpDPInfo)) <br>{ <br>return (DP_OK); <br>} <br>else <br>{ <br>return (DPERR_USERCANCEL); <br>} <br>} <br> <br>BOOL CALLBACK ConnectWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) <br>{ <br>static LPDPLAYINFOlpDPInfo; <br>static LPDIRECTPLAY3AlpDirectPlay3A; <br>static UINTidTimer; <br>GUIDguidSessionInstance; <br>SERVERCONFIGserverConfig; <br>CLIENTLOGINclientLogin; <br>LPVOIDlpConnection = NULL; <br>DWORDdwNameSize; <br>HRESULThr; <br> <br>    switch(uMsg) <br>    { <br>    case WM_INITDIALOG: <br>        // save the connection info pointer <br>        lpDPInfo = (LPDPLAYINFO) lParam; <br>lpDirectPlay3A = NULL; <br> <br>// Create an IDirectPlay3 interface <br>hr = CreateDirectPlayInterface( &amp;lpDirectPlay3A ); <br> <br>if (FAILED(hr)) <br>goto SETUP_FAILURE; <br> <br>// set first item in the connections combo box <br>SendDlgItemMessage(hWnd, IDC_SPCOMBO, CB_ADDSTRING, (WPARAM) 0, (LPARAM) "&lt;Select a service provider&gt;"); <br>SendDlgItemMessage(hWnd, IDC_SPCOMBO, CB_SETITEMDATA, (WPARAM) 0, (LPARAM) 0); <br>SendDlgItemMessage(hWnd, IDC_SPCOMBO, CB_SETCURSEL, (WPARAM) 0, (LPARAM) 0); <br> <br>// put all the available connections in a combo box <br>lpDirectPlay3A-&gt;EnumConnections(&amp;DPSLOTS_GUID, DirectPlayEnumConnectionsCallback, hWnd, 0); <br> <br>// setup initial button state <br>EnableDlgButton(hWnd, IDC_HOSTBUTTON, FALSE); <br>EnableDlgButton(hWnd, IDC_JOINBUTTON, FALSE); <br>break; <br> <br>SETUP_FAILURE: <br>ErrorBox("Could not create DirectPlay object because of error 0x%08X", hr); <br>EndDialog(hWnd, FALSE); <br>break; <br> <br>    case WM_DESTROY: <br>// delete information stored along with the lists <br>DeleteConnectionList(hWnd); <br>DeleteSessionInstanceList(hWnd); <br>        break; <br> <br>case WM_TIMER: <br>// refresh the session list <br>hr = EnumSessions(hWnd, lpDirectPlay3A); <br>break; <br> <br>    case WM_COMMAND: <br>        switch(LOWORD(wParam)) <br>        { <br>case IDC_SPCOMBO: <br>switch (HIWORD(wParam)) <br>{ <br>case CBN_SELCHANGE: <br>// service provider changed, so rebuild display and <br>// delete any existing DirectPlay interface <br>KillTimer(hWnd, idTimer );  <br>hr = DestroyDirectPlayInterface(hWnd, lpDirectPlay3A); <br>lpDirectPlay3A = NULL; <br> <br>// get pointer to the selected connection <br>hr = GetConnection(hWnd, &amp;lpConnection); <br>if FAILED(hr) <br>goto SP_FAILURE; <br> <br>if (lpConnection) <br>{ <br>hr = CreateDirectPlayInterface( &amp;lpDirectPlay3A ); <br> <br>if ((FAILED(hr)) || (NULL == lpDirectPlay3A)) <br>goto SP_FAILURE; <br> <br>// initialize the connection <br>hr = lpDirectPlay3A-&gt;InitializeConnection(lpConnection, 0); <br>if FAILED(hr) <br>goto SP_FAILURE; <br> <br>// OK to host now <br>EnableDlgButton(hWnd, IDC_HOSTBUTTON, TRUE); <br> <br>// start enumerating the sessions <br>hr = EnumSessions(hWnd, lpDirectPlay3A); <br>if FAILED(hr) <br>goto SP_FAILURE; <br> <br>// set a timer to refresh the session list <br>idTimer = SetTimer(hWnd, TIMERID, TIMERINTERVAL, NULL); <br>} <br>else <br>{ <br>// They've selected the generic option "&lt;Select a service provider&gt;" <br>EnableDlgButton(hWnd, IDC_HOSTBUTTON, FALSE); <br>EnableDlgButton(hWnd, IDC_JOINBUTTON, FALSE); <br>} <br>break; <br>} <br>break; <br> <br>SP_FAILURE: <br>if (hr != DPERR_USERCANCEL) <br>ErrorBox("Could not select service provider because of error 0x%08X", hr); <br>break; <br> <br> <br>case IDC_HOSTBUTTON: <br>// should have an interface by now <br>if (lpDirectPlay3A == NULL) <br>break; <br> <br>// get server configuration from user <br>ZeroMemory(&amp;serverConfig, sizeof(SERVERCONFIG)); <br>if (!GetServerConfig(hWnd, &amp;serverConfig)) <br>break; <br> <br>// host a new session on this service provider <br>hr = HostSession(lpDirectPlay3A, &amp;serverConfig, lpDPInfo); <br>if FAILED(hr) <br>goto HOST_FAILURE; <br> <br>// dismiss dialog if we succeeded in hosting <br>EndDialog(hWnd, TRUE); <br>break; <br> <br>HOST_FAILURE: <br>ErrorBox("Could not host session because of error 0x%08X", hr); <br>break; <br> <br>        case IDC_JOINBUTTON: <br> <br>// should have an interface by now <br>if (lpDirectPlay3A == NULL) <br>break; <br> <br>// get guid of selected session instance <br>hr = GetSessionInstanceGuid(hWnd, &amp;guidSessionInstance); <br>if FAILED(hr) <br>goto JOIN_FAILURE; <br> <br>// get server configuration from user <br>ZeroMemory(&amp;clientLogin, sizeof(CLIENTLOGIN)); <br> <br>// use user name for player name <br>dwNameSize = MAXSTRLEN; <br>GetUserName(clientLogin.szPlayerName, &amp;dwNameSize); <br> <br>// join this session <br>hr = JoinSession(lpDirectPlay3A, &amp;guidSessionInstance, &amp;clientLogin, lpDPInfo); <br> <br>// need to ask user for credentials <br>if (hr == DPERR_LOGONDENIED) <br>{ <br>if (!GetClientLogin(hWnd, &amp;clientLogin)) <br>break; <br> <br>// try again, this time with credentials <br>hr = JoinSession(lpDirectPlay3A, &amp;guidSessionInstance, &amp;clientLogin, lpDPInfo); <br>} <br> <br>if FAILED(hr) <br>goto JOIN_FAILURE; <br> <br>// dismiss dialog if we succeeded in joining <br>EndDialog(hWnd, TRUE); <br>            break; <br> <br>JOIN_FAILURE: <br>ErrorBox("Could not join session because of error 0x%08X", hr); <br>break; <br> <br>        case IDCANCEL: <br>// delete any interface created if cancelling <br>hr = DestroyDirectPlayInterface(hWnd, lpDirectPlay3A); <br>lpDirectPlay3A = NULL; <br> <br>EndDialog(hWnd, FALSE); <br>            break; <br>        } <br> <br>        break; <br>    } <br> <br>    // Allow for default processing <br>    return FALSE; <br>} <br> <br>BOOL FAR PASCAL DirectPlayEnumConnectionsCallback( <br>LPCGUID     lpguidSP, <br>LPVOIDlpConnection, <br>DWORDdwConnectionSize, <br>LPCDPNAME   lpName, <br>DWORD dwFlags, <br>LPVOID lpContext) <br>{ <br> <br>    HWNDhWnd = (HWND) lpContext; <br>    LRESULTiIndex; <br>LPVOIDlpConnectionBuffer; <br> <br>// store service provider name in combo box <br>iIndex = SendDlgItemMessage(hWnd, IDC_SPCOMBO, CB_ADDSTRING, 0,  <br>(LPARAM) lpName-&gt;lpszShortNameA); <br>if (iIndex == CB_ERR) <br>goto FAILURE; <br> <br>// make space for Connection Shortcut <br>lpConnectionBuffer = GlobalAllocPtr(GHND, dwConnectionSize); <br>if (lpConnectionBuffer == NULL) <br>goto FAILURE; <br> <br>// store pointer to GUID in combo box <br>memcpy(lpConnectionBuffer, lpConnection, dwConnectionSize); <br>SendDlgItemMessage(hWnd, IDC_SPCOMBO, CB_SETITEMDATA, (WPARAM) iIndex,  <br>(LPARAM) lpConnectionBuffer); <br> <br>FAILURE: <br>    return (TRUE); <br>} <br> <br> <br>HRESULT CreateDirectPlayInterface( LPDIRECTPLAY3A *lplpDirectPlay3A ) <br>{ <br>HRESULThr; <br>LPDIRECTPLAY3AlpDirectPlay3A = NULL; <br> <br>// Create an IDirectPlay3 interface <br>hr = CoCreateInstance(CLSID_DirectPlay, NULL, CLSCTX_INPROC_SERVER,  <br>IID_IDirectPlay3A, (LPVOID*)&amp;lpDirectPlay3A); <br> <br>// return interface created <br>*lplpDirectPlay3A = lpDirectPlay3A; <br> <br>return (hr); <br>} <br> <br> <br>HRESULT DestroyDirectPlayInterface(HWND hWnd, LPDIRECTPLAY3A lpDirectPlay3A) <br>{ <br>HRESULThr = DP_OK; <br> <br>if (lpDirectPlay3A) <br>{ <br>DeleteSessionInstanceList(hWnd); <br>EnableDlgButton(hWnd, IDC_JOINBUTTON, FALSE); <br> <br>hr = lpDirectPlay3A-&gt;Release(); <br>} <br> <br>return (hr); <br>} <br> <br>HRESULT HostSession(LPDIRECTPLAY3A lpDirectPlay3A, <br>LPSERVERCONFIG lpServerConfig, <br>LPDPLAYINFO lpDPInfo) <br>{ <br>DPIDdpidPlayer; <br>DPSESSIONDESC2sessionDesc; <br>DPSECURITYDESCsecurityDesc; <br>LPDPSECURITYDESClpSecurityDesc; <br>HRESULThr; <br> <br>// check for valid interface <br>if (lpDirectPlay3A == NULL) <br>return (DPERR_INVALIDOBJECT); <br> <br>// host a new session <br>ZeroMemory(&amp;sessionDesc, sizeof(DPSESSIONDESC2)); <br>sessionDesc.dwSize = sizeof(DPSESSIONDESC2); <br>    sessionDesc.guidApplication = DPSLOTS_GUID; <br>    sessionDesc.dwMaxPlayers = 0; <br>sessionDesc.lpszSessionNameA = lpServerConfig-&gt;szServerName; <br>sessionDesc.dwFlags = SESSIONFLAGS(lpServerConfig-&gt;bRequireSecureLogin); <br> <br>// assume no security descriptor will be needed <br>lpSecurityDesc = NULL; <br> <br>if (lpServerConfig-&gt;bRequireSecureLogin) <br>{ <br>// a service provider string was entered, so use it <br>if (lstrlen(lpServerConfig-&gt;szSecurityProvider)) <br>{ <br>ZeroMemory(&amp;securityDesc, sizeof(DPSECURITYDESC)); <br>securityDesc.dwSize = sizeof(DPSECURITYDESC); <br>securityDesc.dwFlags = 0; <br>securityDesc.lpszSSPIProviderA = lpServerConfig-&gt;szSecurityProvider; <br>lpSecurityDesc = &amp;securityDesc; <br>} <br>} <br> <br>// host the session <br>hr = lpDirectPlay3A-&gt;SecureOpen(&amp;sessionDesc, DPOPEN_CREATE, lpSecurityDesc, NULL); <br>if FAILED(hr) <br>goto FAILURE; <br> <br>// create a server player with no name <br>hr = lpDirectPlay3A-&gt;CreatePlayer(&amp;dpidPlayer, NULL,  <br>lpDPInfo-&gt;hPlayerEvent, NULL, 0, SERVERPLAYERFLAGS); <br>if FAILED(hr) <br>goto FAILURE; <br> <br>// return connection info <br>lpDPInfo-&gt;lpDirectPlay3A = lpDirectPlay3A; <br>lpDPInfo-&gt;dpidPlayer = dpidPlayer; <br>lpDPInfo-&gt;bIsHost = TRUE; <br>lpDPInfo-&gt;bIsSecure = lpServerConfig-&gt;bRequireSecureLogin; <br> <br>// save database name in global <br>lstrcpy(gszDatabaseName, lpServerConfig-&gt;szDatabaseFile); <br> <br>return (DP_OK); <br> <br>FAILURE: <br>lpDirectPlay3A-&gt;Close(); <br>return (hr); <br>} <br> <br>HRESULT JoinSession(LPDIRECTPLAY3A lpDirectPlay3A, <br>LPGUID lpguidSessionInstance, <br>LPCLIENTLOGIN lpClientLogin, <br>LPDPLAYINFO lpDPInfo) <br>{ <br>    DPID                dpidPlayer; <br>DPNAMEdpName; <br>DPSESSIONDESC2sessionDesc; <br>LPDPSESSIONDESC2lpSessionDesc = NULL; <br>DPCREDENTIALScredentials; <br>LPDPCREDENTIALSlpCredentials; <br>HRESULThr; <br> <br>// check for valid interface <br>if (lpDirectPlay3A == NULL) <br>return (DPERR_INVALIDOBJECT); <br> <br>// join existing session <br>ZeroMemory(&amp;sessionDesc, sizeof(DPSESSIONDESC2)); <br>sessionDesc.dwSize = sizeof(DPSESSIONDESC2); <br>    sessionDesc.guidInstance = *lpguidSessionInstance; <br> <br>// assume no credentials are going to be used <br>lpCredentials = NULL; <br> <br>// setup credentials <br>ZeroMemory(&amp;credentials, sizeof(DPCREDENTIALS)); <br>credentials.dwSize = sizeof(DPCREDENTIALS); <br>credentials.dwFlags = 0; <br> <br>if (lstrlen(lpClientLogin-&gt;szUserName)) <br>{ <br>credentials.lpszUsernameA = lpClientLogin-&gt;szUserName; <br>lpCredentials = &amp;credentials; <br>} <br> <br>if (lstrlen(lpClientLogin-&gt;szPassword)) <br>{ <br>credentials.lpszPasswordA = lpClientLogin-&gt;szPassword;  <br>lpCredentials = &amp;credentials; <br>} <br> <br>if (lstrlen(lpClientLogin-&gt;szDomain)) <br>{ <br>credentials.lpszDomainA = lpClientLogin-&gt;szDomain;  <br>lpCredentials = &amp;credentials; <br>} <br> <br>// join the session  <br>hr = lpDirectPlay3A-&gt;SecureOpen(&amp;sessionDesc, DPOPEN_JOIN, NULL, lpCredentials); <br> <br>if FAILED(hr) <br>goto FAILURE; <br> <br>// fill out name structure <br>ZeroMemory(&amp;dpName, sizeof(DPNAME)); <br>dpName.dwSize = sizeof(DPNAME); <br>dpName.lpszShortNameA = lpClientLogin-&gt;szPlayerName; <br>dpName.lpszLongNameA = NULL; <br> <br>// create a player with this name <br>hr = lpDirectPlay3A-&gt;CreatePlayer(&amp;dpidPlayer, &amp;dpName,  <br>lpDPInfo-&gt;hPlayerEvent, NULL, 0, CLIENTPLAYERFLAGS); <br>if FAILED(hr) <br>goto FAILURE; <br> <br>// get the session desc <br>hr = GetSessionDesc(lpDirectPlay3A, &amp;lpSessionDesc); <br>if FAILED(hr) <br>goto FAILURE; <br> <br>// return connection info <br>lpDPInfo-&gt;lpDirectPlay3A = lpDirectPlay3A; <br>lpDPInfo-&gt;dpidPlayer = dpidPlayer; <br>lpDPInfo-&gt;bIsHost = FALSE; <br> <br>if (lpSessionDesc-&gt;dwFlags &amp; DPSESSION_SECURESERVER) <br>lpDPInfo-&gt;bIsSecure = TRUE; <br>else <br>lpDPInfo-&gt;bIsSecure = FALSE; <br> <br>GlobalFreePtr(lpSessionDesc); <br> <br>return (DP_OK); <br> <br>FAILURE: <br>if (lpSessionDesc) <br>GlobalFreePtr(lpSessionDesc); <br> <br>lpDirectPlay3A-&gt;Close(); <br>return (hr); <br>} <br> <br>BOOL FAR PASCAL EnumSessionsCallback( <br>LPCDPSESSIONDESC2lpSessionDesc, <br>LPDWORDlpdwTimeOut, <br>DWORDdwFlags, <br>LPVOIDlpContext) <br>{ <br>HWNDhWnd = (HWND) lpContext; <br>LPGUIDlpGuid; <br>LONGiIndex; <br> <br>// see if last session has been enumerated <br>    if (dwFlags &amp; DPESC_TIMEDOUT) <br>return (FALSE); <br> <br>// store session name in list <br>iIndex = SendDlgItemMessage(hWnd, IDC_SESSIONLIST, LB_ADDSTRING,  <br>(WPARAM) 0, (LPARAM) lpSessionDesc-&gt;lpszSessionNameA); <br> <br>if (iIndex == LB_ERR) <br>goto FAILURE; <br> <br> <br>// make space for session instance guid <br>lpGuid = (LPGUID) GlobalAllocPtr(GHND, sizeof(GUID)); <br>if (lpGuid == NULL) <br>goto FAILURE; <br> <br>// store pointer to guid in list <br>*lpGuid = lpSessionDesc-&gt;guidInstance; <br>SendDlgItemMessage( hWnd, IDC_SESSIONLIST, LB_SETITEMDATA, (WPARAM) iIndex, (LPARAM) lpGuid); <br> <br>FAILURE: <br>    return (TRUE); <br>} <br> <br>HRESULT EnumSessions(HWND hWnd, LPDIRECTPLAY3A lpDirectPlay3A) <br>{ <br>DPSESSIONDESC2sessionDesc; <br>GUIDguidSessionInstance; <br>LONGiIndex; <br>HRESULThr; <br> <br>// check for valid interface <br>if (lpDirectPlay3A == NULL) <br>return (DPERR_INVALIDOBJECT); <br> <br>// get guid of currently selected session <br>guidSessionInstance = GUID_NULL; <br>hr = GetSessionInstanceGuid(hWnd, &amp;guidSessionInstance); <br> <br>// delete existing session list <br>DeleteSessionInstanceList(hWnd); <br> <br>// add sessions to session list <br>ZeroMemory(&amp;sessionDesc, sizeof(DPSESSIONDESC2)); <br>sessionDesc.dwSize = sizeof(DPSESSIONDESC2); <br>    sessionDesc.guidApplication = DPSLOTS_GUID; <br> <br>hr = lpDirectPlay3A-&gt;EnumSessions(&amp;sessionDesc, 0, EnumSessionsCallback, <br>  hWnd, DPENUMSESSIONS_AVAILABLE | DPENUMSESSIONS_ASYNC); <br> <br>// select the session that was previously selected <br>SelectSessionInstance(hWnd, &amp;guidSessionInstance); <br> <br>// hilite "Join" button only if there are sessions to join <br>iIndex = SendDlgItemMessage(hWnd, IDC_SESSIONLIST, LB_GETCOUNT, <br>   (WPARAM) 0, (LPARAM) 0); <br> <br>EnableDlgButton(hWnd, IDC_JOINBUTTON, (iIndex &gt; 0) ? TRUE : FALSE); <br> <br>return (hr); <br>} <br> <br>HRESULT GetConnection(HWND hWnd, LPVOID *lplpConnection) <br>{ <br>LONGiIndex; <br> <br>// get index of the item currently selected in the combobox <br>iIndex = SendDlgItemMessage(hWnd, IDC_SPCOMBO, CB_GETCURSEL, <br>(WPARAM) 0, (LPARAM) 0); <br>if (iIndex == CB_ERR) <br>return (DPERR_GENERIC); <br> <br>// get the pointer to the connection shortcut associated with <br>// the item <br>iIndex = SendDlgItemMessage(hWnd, IDC_SPCOMBO, CB_GETITEMDATA, <br>(WPARAM) iIndex, (LPARAM) 0); <br>if (iIndex == CB_ERR) <br>return (DPERR_GENERIC); <br> <br>*lplpConnection = (LPVOID) iIndex; <br> <br>return (DP_OK); <br>} <br> <br>void DeleteConnectionList(HWND hWnd) <br>{ <br>WPARAMi; <br>LONGlpData; <br> <br>// destroy the GUID's stored with each service provider name <br>i = 0; <br>while (TRUE) <br>{ <br>// get data pointer stored with item <br>lpData = SendDlgItemMessage(hWnd, IDC_SPCOMBO, CB_GETITEMDATA, <br>(WPARAM) i, (LPARAM) 0); <br>if (lpData == CB_ERR)// error getting data <br>break; <br> <br>if (lpData != 0)// no data to delete <br>GlobalFreePtr((LPVOID) lpData); <br> <br>i += 1; <br>} <br> <br>// delete all items in combo box <br>SendDlgItemMessage(hWnd, IDC_SPCOMBO, CB_RESETCONTENT, <br>(WPARAM) 0, (LPARAM) 0); <br>} <br> <br>HRESULT GetSessionInstanceGuid(HWND hWnd, LPGUID lpguidSessionInstance) <br>{ <br>LONGiIndex; <br> <br>// get guid for session <br>iIndex = SendDlgItemMessage(hWnd, IDC_SESSIONLIST, LB_GETCURSEL, <br>(WPARAM) 0, (LPARAM) 0); <br>if (iIndex == LB_ERR) <br>return (DPERR_GENERIC); <br> <br>iIndex = SendDlgItemMessage(hWnd, IDC_SESSIONLIST, LB_GETITEMDATA, <br>(WPARAM) iIndex, (LPARAM) 0); <br>if ((iIndex == LB_ERR) || (iIndex == 0)) <br>return (DPERR_GENERIC); <br> <br>*lpguidSessionInstance = *((LPGUID) iIndex); <br> <br>return (DP_OK); <br>} <br> <br>void DeleteSessionInstanceList(HWND hWnd) <br>{ <br>WPARAMi; <br>LONGlpData; <br> <br>// destroy the GUID's stored with each session name <br>i = 0; <br>while (TRUE) <br>{ <br>// get data pointer stored with item <br>lpData = SendDlgItemMessage(hWnd, IDC_SESSIONLIST, LB_GETITEMDATA, <br>(WPARAM) i, (LPARAM) 0); <br>if (lpData == CB_ERR)// error getting data <br>break; <br> <br>if (lpData == 0)// no data to delete <br>continue; <br> <br>GlobalFreePtr((LPVOID) lpData); <br>i += 1; <br>} <br> <br>// delete all items in list <br>SendDlgItemMessage(hWnd, IDC_SESSIONLIST, LB_RESETCONTENT, <br>(WPARAM) 0, (LPARAM) 0); <br>} <br> <br>void SelectSessionInstance(HWND hWnd, LPGUID lpguidSessionInstance) <br>{ <br>WPARAMi, iIndex; <br>LONGlpData; <br> <br>// loop over the GUID's stored with each session name <br>// to find the one that matches what was passed in <br>i = 0; <br>iIndex = 0; <br>while (TRUE) <br>{ <br>// get data pointer stored with item <br>lpData = SendDlgItemMessage(hWnd, IDC_SESSIONLIST, LB_GETITEMDATA, <br>(WPARAM) i, (LPARAM) 0); <br>if (lpData == CB_ERR)// error getting data <br>break; <br> <br>if (lpData == 0)// no data to compare to <br>continue; <br> <br>// guid matches <br>if (IsEqualGUID(*lpguidSessionInstance, *((LPGUID) lpData))) <br>{ <br>iIndex = i;// store index of this string <br>break; <br>} <br> <br>i += 1; <br>} <br> <br>// select this item <br>SendDlgItemMessage(hWnd, IDC_SESSIONLIST, LB_SETCURSEL, (WPARAM) iIndex, (LPARAM) 0); <br>} <br> <br>HRESULT GetSessionDesc(LPDIRECTPLAY3A lpDirectPlay3A, LPDPSESSIONDESC2 *lplpSessionDesc) <br>{ <br>LPDPSESSIONDESC2lpSessionDesc = NULL; <br>DWORDdwSessionDescSize; <br>HRESULThr; <br> <br>// get size of session desc <br>hr = lpDirectPlay3A-&gt;GetSessionDesc(NULL, &amp;dwSessionDescSize); <br>if (hr != DPERR_BUFFERTOOSMALL) <br>goto FAILURE; <br> <br>// make room for it <br>lpSessionDesc = (LPDPSESSIONDESC2) GlobalAllocPtr(GHND, dwSessionDescSize); <br>if (lpSessionDesc == NULL) <br>{ <br>hr = DPERR_OUTOFMEMORY; <br>goto FAILURE; <br>} <br> <br>// get the session desc <br>hr = lpDirectPlay3A-&gt;GetSessionDesc(lpSessionDesc, &amp;dwSessionDescSize); <br>if FAILED(hr) <br>goto FAILURE; <br> <br>// return account description <br>*lplpSessionDesc = lpSessionDesc; <br>lpSessionDesc = NULL; <br> <br>FAILURE: <br>if (lpSessionDesc) <br>GlobalFreePtr(lpSessionDesc); <br> <br>return (hr); <br>} <br> <br>void InitializeServerConfigWindow(HWND hWnd) <br>{ <br>charszSessionName[MAXSTRLEN]; <br>DWORDdwNameSize; <br> <br>// use username for default <br>dwNameSize = MAXSTRLEN; <br>if (GetComputerName(szSessionName, &amp;dwNameSize)) <br>SetDlgItemText(hWnd, IDC_SERVERNAMEEDIT, szSessionName); <br> <br>// use default name <br>SetDlgItemText(hWnd, IDC_DATABASEFILEEDIT, DEFAULTDATABASE); <br> <br>// security off by default <br>CheckDlgItem(hWnd, IDC_SECURECHECK, FALSE); <br>} <br> <br>void SaveServerConfig(HWND hWnd, LPSERVERCONFIG lpServerConfig) <br>{ <br>// get strings from dialog <br>GetDlgItemText(hWnd, IDC_SERVERNAMEEDIT, lpServerConfig-&gt;szServerName, MAXSTRLEN); <br>GetDlgItemText(hWnd, IDC_DATABASEFILEEDIT, lpServerConfig-&gt;szDatabaseFile, MAXSTRLEN); <br>GetDlgItemText(hWnd, IDC_SECURITYPROVIDEREDIT, lpServerConfig-&gt;szSecurityProvider, MAXSTRLEN); <br> <br>if (DlgItemIsChecked(hWnd, IDC_SECURECHECK)) <br>lpServerConfig-&gt;bRequireSecureLogin = TRUE; <br>else <br>lpServerConfig-&gt;bRequireSecureLogin = FALSE; <br>} <br> <br>BOOL CALLBACK ServerConfigWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) <br>{ <br>static LPSERVERCONFIGlpServerConfig; <br> <br>    switch(uMsg) <br>    { <br>        case WM_INITDIALOG: <br> <br>// globals are passed in lParam <br>lpServerConfig = (LPSERVERCONFIG) lParam; <br> <br>// Initialize dialog with appropriate information <br>InitializeServerConfigWindow(hWnd); <br>            break; <br> <br>        case WM_DESTROY: <br>            break; <br> <br>        case WM_COMMAND: <br>            switch(LOWORD(wParam)) <br>            { <br>case IDOK: <br>// save changes they made <br>SaveServerConfig(hWnd, lpServerConfig); <br>                    // Return success <br>                    EndDialog(hWnd, TRUE); <br> <br>                    break; <br> <br>case IDCANCEL: <br>                    // Return failure <br>                    EndDialog(hWnd, FALSE); <br> <br>                    break; <br>            } <br> <br>            break; <br>    } <br> <br>    // Allow for default processing <br>    return FALSE; <br>} <br> <br>BOOL GetServerConfig(HWND hWnd, LPSERVERCONFIG lpServerConfig) <br>{ <br>// collect server config from dialog <br>return (DialogBoxParam(ghInstance, MAKEINTRESOURCE(IDD_SERVERCONFIGDIALOG), hWnd, (DLGPROC) ServerConfigWndProc, (LPARAM) lpServerConfig)); <br>} <br> <br>void InitializeClientLoginWindow(HWND hWnd) <br>{ <br>charszPlayerName[MAXSTRLEN]; <br>DWORDdwNameSize; <br> <br>// use user name for player name <br>dwNameSize = MAXSTRLEN; <br>if (GetUserName(szPlayerName, &amp;dwNameSize)) <br>SetDlgItemText(hWnd, IDC_USERNAMEEDIT, szPlayerName); <br>} <br> <br>void SaveClientLogin(HWND hWnd, LPCLIENTLOGIN lpClientLogin) <br>{ <br>// get strings from dialog <br>GetDlgItemText(hWnd, IDC_USERNAMEEDIT, lpClientLogin-&gt;szUserName, MAXSTRLEN); <br>GetDlgItemText(hWnd, IDC_PASSWORDEDIT, lpClientLogin-&gt;szPassword, MAXSTRLEN); <br>GetDlgItemText(hWnd, IDC_DOMAINEDIT, lpClientLogin-&gt;szDomain, MAXSTRLEN); <br>} <br> <br>BOOL CALLBACK ClientLoginWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) <br>{ <br>static LPCLIENTLOGINlpClientLogin; <br> <br>    switch(uMsg) <br>    { <br>        case WM_INITDIALOG: <br> <br>// globals are passed in lParam <br>lpClientLogin = (LPCLIENTLOGIN) lParam; <br> <br>// Initialize dialog with appropriate information <br>InitializeClientLoginWindow(hWnd); <br>            break; <br> <br>        case WM_DESTROY: <br>            break; <br> <br>        case WM_COMMAND: <br>            switch(LOWORD(wParam)) <br>            { <br>case IDOK: <br>// save changes they made <br>SaveClientLogin(hWnd, lpClientLogin); <br>                    // Return success <br>                    EndDialog(hWnd, TRUE); <br> <br>                    break; <br> <br>case IDCANCEL: <br>                    // Return failure <br>                    EndDialog(hWnd, FALSE); <br> <br>                    break; <br>            } <br> <br>            break; <br>    } <br> <br>    // Allow for default processing <br>    return FALSE; <br>} <br> <br>BOOL GetClientLogin(HWND hWnd, LPCLIENTLOGIN lpClientLogin) <br>{ <br>// collect server config from dialog <br>return (DialogBoxParam(ghInstance, MAKEINTRESOURCE(IDD_CLIENTLOGINDIALOG), hWnd, (DLGPROC) ClientLoginWndProc, (LPARAM) lpClientLogin)); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
