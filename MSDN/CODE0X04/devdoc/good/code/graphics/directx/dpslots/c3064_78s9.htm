<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CLIENT.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3069"></a>CLIENT.CPP</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved. <br> * <br> *  File:       client.cpp <br> *  Content:Slot machine client using DirectPlay. <br> * <br> ***************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;stdio.h&gt; <br> <br>#include "dpslots.h" <br>#include "resource.h" <br> <br>// constants <br>const DWORD SLOTWIDTH= 110;// width of slot <br>const DWORD SLOTHEIGHT= 119;// height of slot <br>const DWORD SLOTBORDER= 9;// space between slots <br>const DWORD REVSPERSECOND= 1;// no. revolutions per second <br>const DWORD PIXELSPERSLOT= SLOTHEIGHT - SLOTBORDER;// no. vertical pixels per slot <br>const DWORD PIXELSPERREV= PIXELSPERSLOT * SLOTSPERWHEEL;// no. vertical pixels drawn per revolution <br>const DWORD PIXELSPERSECOND= PIXELSPERREV * REVSPERSECOND;// no. vertical pixels drawn per second <br>const UINTTIMERID= 1;// timer ID to use <br>const UINTTIMERINTERVAL= 50;// timer interval <br>const UINTMAXSTRING= 200;// max size of a string <br> <br>// window messages <br>const UINTWM_USER_UPDATEBALANCE = WM_USER + BALANCERESPONSE; <br>const UINTWM_USER_STARTSPINNING = WM_USER + SPINRESPONSE; <br> <br>// structures <br>typedef struct { <br>DWORDdwIndex;// index of wheel slot to show <br>    DWORDdwStartTicks;// time wheel started spinning <br>DWORDdwDuration;// duration wheel should spin <br>} WHEELINFO, *LPWHEELINFO; <br> <br>// globals <br>HWNDghClientWnd = NULL;// main window <br> <br>// prototypes <br>HRESULTSendBalanceRequest(LPDPLAYINFO lpDPInfo); <br>HRESULTSendSpinRequest(LPDPLAYINFO lpDPInfo, DWORD dwAmountBet); <br>voidDrawWheels(LPWHEELINFO lpWheels, HBITMAP hWheelBitmap, <br>   HDC hDC, LPRECT lpBoundsRect); <br>voidStartSpinning(LPWHEELINFO lpWheels); <br>BOOLSpinWheels(HWND hWnd, LPWHEELINFO lpWheels, HBITMAP hWheelBitmap); <br> <br>BOOL CALLBACK ClientWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) <br>{ <br>static LPDPLAYINFOlpDPInfo = NULL; <br>static UINTidTimer = 0; <br>static HBITMAPhWheelBitmap = NULL; <br>static WHEELINFOWheelInfo[NUMWHEELS]; <br>static MSG_SPINRESPONSESpinResponse; <br>CHARszStr[MAXSTRING]; <br>DWORDi; <br>DWORDdwAmountBet; <br> <br>    switch(uMsg) <br>    { <br>    case WM_INITDIALOG: <br>        // save the connection info pointer <br>        lpDPInfo = (LPDPLAYINFO) lParam; <br> <br>// store global window <br>ghClientWnd = hWnd; <br> <br>// get slots bitmap <br>hWheelBitmap = LoadBitmap(ghInstance, MAKEINTRESOURCE(IDB_SLOTSBITMAP)); <br> <br>// initialize slots <br>for (i = 0; i &lt; NUMWHEELS; i++) <br>WheelInfo[i].dwIndex = ((DWORD)rand()) % SLOTSPERWHEEL; <br> <br>        // get starting balance <br>SendBalanceRequest(lpDPInfo); <br>break; <br> <br>    case WM_DESTROY: <br>// stop the timer <br>if (idTimer) <br>{ <br>KillTimer(hWnd, idTimer);  <br>idTimer = 0; <br>} <br> <br>// free the bitmap handle <br>if (hWheelBitmap) <br>{ <br>DeleteObject(hWheelBitmap); <br>hWheelBitmap = NULL; <br>} <br>ghClientWnd = NULL; <br>        break; <br> <br>case WM_USER_UPDATEBALANCE: <br> <br>// balance is in lParam <br>        sprintf(szStr, "$%4d", lParam); <br> <br>        // display new balance <br>SetDlgItemText(hWnd, IDC_EDIT_BALANCE, szStr); <br>break; <br> <br>case WM_USER_STARTSPINNING: <br> <br>// copy spin response message from lParam <br>SpinResponse = *((LPMSG_SPINRESPONSE) lParam); <br>GlobalFreePtr((LPVOID) lParam);// free memory <br> <br>// check for valid spin <br>if FAILED(SpinResponse.hr) <br>{ <br>SetDlgItemText(hWnd, IDC_RESULTEDIT, "You don't have enough money!"); <br>} <br>else <br>{ <br>// copy slot settings specified by server <br>for (i = 0; i &lt; NUMWHEELS; i++) <br>WheelInfo[i].dwIndex = SpinResponse.dwIndex[i]; <br> <br>// clear win or lose <br>SetDlgItemText(hWnd, IDC_RESULTEDIT, ""); <br> <br>// start things spinning <br>StartSpinning(WheelInfo); <br>idTimer = SetTimer(hWnd, TIMERID, TIMERINTERVAL, NULL); <br> <br>// disable spin button while spinning <br>EnableDlgButton(hWnd, IDC_SPINBUTTON, FALSE); <br>} <br>break; <br> <br>case WM_TIMER: <br>// readraw any spinning wheels <br>if (!SpinWheels(hWnd, WheelInfo, hWheelBitmap)) <br>{ <br>KillTimer(hWnd, idTimer);  <br>idTimer = 0; <br> <br>// display amount won or lost <br>if (SpinResponse.dwAmountWonOrLost &gt; 0) <br>{ <br>sprintf(szStr,"You win $%d!", SpinResponse.dwAmountWonOrLost); <br>PlaySound(MAKEINTRESOURCE(IDR_WINWAVE), ghInstance, SND_ASYNC | SND_RESOURCE); <br>} <br>else if (SpinResponse.dwAmountWonOrLost &lt; 0) <br>{ <br>sprintf(szStr,"You lose $%d!", -SpinResponse.dwAmountWonOrLost); <br>PlaySound(MAKEINTRESOURCE(IDR_LOSEWAVE), ghInstance, SND_ASYNC | SND_RESOURCE); <br>} <br>else <br>{ <br>strcpy(szStr, ""); <br>} <br> <br>// display win or loss <br>SetDlgItemText(hWnd, IDC_RESULTEDIT, szStr); <br> <br>PostMessage(hWnd, WM_USER_UPDATEBALANCE, (WPARAM) 0, (LPARAM) SpinResponse.dwBalance); <br> <br>// enable spin button again <br>EnableDlgButton(hWnd, IDC_SPINBUTTON, TRUE); <br>} <br>break; <br> <br>    case WM_DRAWITEM: <br>{ <br>DRAWITEMSTRUCT*diInfo; <br> <br>diInfo = (DRAWITEMSTRUCT *) lParam; <br> <br>switch (diInfo-&gt;CtlID) <br>{ <br>case IDC_SLOTS: <br>if (diInfo-&gt;itemAction == ODA_DRAWENTIRE) <br>{ <br>DrawWheels(WheelInfo, hWheelBitmap, diInfo-&gt;hDC, &amp;diInfo-&gt;rcItem); <br>} <br>break; <br>} <br>} <br>break; <br> <br>case WM_COMMAND: <br>        switch(LOWORD(wParam)) <br>        { <br>case IDC_SPINBUTTON: <br>// find out how much was bet <br>dwAmountBet = 0; <br> <br>// one dollar <br>if (DlgItemIsChecked(hWnd, IDC_BET1CHECK)) <br>dwAmountBet += 1; <br> <br>// five dollars <br>if (DlgItemIsChecked(hWnd, IDC_BET2CHECK)) <br>dwAmountBet += 5; <br> <br>// ten dollars <br>if (DlgItemIsChecked(hWnd, IDC_BET3CHECK)) <br>dwAmountBet += 10; <br> <br>// ask server for results of spin using this bet <br>            SendSpinRequest(lpDPInfo, dwAmountBet);             <br>break; <br> <br>        case IDCANCEL: <br>EndDialog(hWnd, FALSE); <br>            break; <br>} <br>break; <br>} <br> <br>    // Allow for default processing <br>    return FALSE; <br>} <br> <br>void ClientApplicationMessage(LPDPLAYINFO lpDPInfo, LPDPMSG_GENERIC lpMsg, DWORD dwMsgSize, <br>  DPID idFrom, DPID idTo) <br>{ <br>switch (lpMsg-&gt;dwType) <br>{ <br>    case BALANCERESPONSE: <br>        { <br>            LPMSG_BALANCERESPONSE lpBalance = (LPMSG_BALANCERESPONSE)lpMsg; <br> <br> PostMessage(ghClientWnd, WM_USER_UPDATEBALANCE, (WPARAM) 0, (LPARAM) lpBalance-&gt;dwBalance); <br>        } <br>        break; <br> <br>    case SPINRESPONSE: <br>        { <br>            LPMSG_SPINRESPONSE lpSpin = (LPMSG_SPINRESPONSE)lpMsg; <br>            LPMSG_SPINRESPONSE lpSpinCopy; <br> <br>// make a copy of the message so we can pass it to the wndproc <br>lpSpinCopy = (LPMSG_SPINRESPONSE) GlobalAllocPtr(GHND, sizeof(MSG_SPINRESPONSE)); <br>if (lpSpinCopy == NULL) <br>break; <br> <br>*lpSpinCopy = *lpSpin; <br> <br>            PostMessage(ghClientWnd, WM_USER_STARTSPINNING, (WPARAM) 0, (LPARAM) lpSpinCopy); <br>        } <br>        break; <br> <br>    default: <br>        break;  <br>} <br>} <br> <br>void ClientSystemMessage(LPDPLAYINFO lpDPInfo, LPDPMSG_GENERIC lpMsg, DWORD dwMsgSize, <br> DPID idFrom, DPID idTo) <br>{ <br>    // The body of each case is there so you can set a breakpoint and examine <br>    // the contents of the message received. <br>switch (lpMsg-&gt;dwType) <br>{ <br>case DPSYS_CREATEPLAYERORGROUP: <br>        { <br>            LPDPMSG_CREATEPLAYERORGROUP lp = (LPDPMSG_CREATEPLAYERORGROUP) lpMsg; <br>        } <br>break; <br> <br>case DPSYS_DESTROYPLAYERORGROUP: <br>        { <br>            LPDPMSG_DESTROYPLAYERORGROUP lp = (LPDPMSG_DESTROYPLAYERORGROUP)lpMsg; <br>        } <br>break; <br> <br>case DPSYS_ADDPLAYERTOGROUP: <br>        { <br>            LPDPMSG_ADDPLAYERTOGROUP lp = (LPDPMSG_ADDPLAYERTOGROUP)lpMsg; <br>        } <br>break; <br> <br>case DPSYS_DELETEPLAYERFROMGROUP: <br>        { <br>            LPDPMSG_DELETEPLAYERFROMGROUP lp = (LPDPMSG_DELETEPLAYERFROMGROUP)lpMsg; <br>        } <br>break; <br> <br>case DPSYS_SESSIONLOST: <br>        { <br>            LPDPMSG_SESSIONLOST lp = (LPDPMSG_SESSIONLOST)lpMsg; <br>        } <br>break; <br> <br>case DPSYS_HOST: <br>        { <br>            LPDPMSG_HOSTlp = (LPDPMSG_HOST)lpMsg; <br>        } <br>break; <br> <br>case DPSYS_SETPLAYERORGROUPDATA: <br>        { <br>            LPDPMSG_SETPLAYERORGROUPDATA lp = (LPDPMSG_SETPLAYERORGROUPDATA)lpMsg; <br>        } <br>break; <br> <br>case DPSYS_SETPLAYERORGROUPNAME: <br>        { <br>            LPDPMSG_SETPLAYERORGROUPNAME lp = (LPDPMSG_SETPLAYERORGROUPNAME)lpMsg; <br>        } <br>break; <br> <br>case DPSYS_SECUREMESSAGE: <br>        { <br>            LPDPMSG_SECUREMESSAGE lp = (LPDPMSG_SECUREMESSAGE)lpMsg; <br> <br>ClientApplicationMessage(lpDPInfo, (LPDPMSG_GENERIC) lp-&gt;lpData, lp-&gt;dwDataSize, <br>  lp-&gt;dpIdFrom, idTo); <br> <br>        } <br>break; <br>} <br>} <br> <br>HRESULT SendBalanceRequest(LPDPLAYINFO lpDPInfo) <br>{ <br>    MSG_BALANCEREQUESTMsg; <br> <br>    ZeroMemory(&amp;Msg, sizeof(MSG_BALANCEREQUEST)); <br>    Msg.dwType = BALANCEREQUEST; <br> <br>    return (lpDPInfo-&gt;lpDirectPlay3A-&gt;Send(lpDPInfo-&gt;dpidPlayer, <br>DPID_SERVERPLAYER, SENDFLAGS(lpDPInfo-&gt;bIsSecure), <br>&amp;Msg, sizeof(MSG_BALANCEREQUEST))); <br>} <br> <br>HRESULT SendSpinRequest(LPDPLAYINFO lpDPInfo, DWORD dwAmountBet) <br>{ <br>    MSG_SPINREQUESTMsg; <br> <br>    ZeroMemory(&amp;Msg, sizeof(MSG_SPINREQUEST)); <br>    Msg.dwType = SPINREQUEST; <br>Msg.dwAmountBet = dwAmountBet; <br> <br>    return (lpDPInfo-&gt;lpDirectPlay3A-&gt;Send(lpDPInfo-&gt;dpidPlayer, <br>DPID_SERVERPLAYER, SENDFLAGS(lpDPInfo-&gt;bIsSecure), <br>&amp;Msg, sizeof(MSG_SPINREQUEST))); <br>} <br> <br>#define RECTWIDTH(lpRect)     ((lpRect)-&gt;right - (lpRect)-&gt;left) <br>#define RECTHEIGHT(lpRect)    ((lpRect)-&gt;bottom - (lpRect)-&gt;top) <br> <br>BOOL PaintBitmap(HDC hDC, LPRECT lpDCRect, HBITMAP hDDB,  LPRECT lpDDBRect) <br>{ <br>    HDC         hMemDC;            // Handle to memory DC <br>    HBITMAP     hOldBitmap;        // Handle to previous bitmap <br>    BOOL        bSuccess = FALSE;  // Success/fail flag <br> <br>    // Create a memory DC <br> <br>    hMemDC = CreateCompatibleDC(hDC); <br> <br>    // If this failed, return FALSE <br> <br>    if (!hMemDC) <br>        return FALSE; <br> <br>    // Select bitmap into the memory DC <br> <br>    hOldBitmap = (HBITMAP) SelectObject (hMemDC, hDDB); <br> <br>    // Make sure to use the stretching mode best for color pictures <br> <br>    SetStretchBltMode (hDC, COLORONCOLOR); <br> <br>    // Determine whether to call StretchBlt() or BitBlt() <br>    if ((RECTWIDTH(lpDCRect)  == RECTWIDTH(lpDDBRect)) &amp;&amp; <br>            (RECTHEIGHT(lpDCRect) == RECTHEIGHT(lpDDBRect))) <br>        bSuccess = BitBlt(hDC, lpDCRect-&gt;left, lpDCRect-&gt;top, <br>                lpDCRect-&gt;right - lpDCRect-&gt;left, <br>                lpDCRect-&gt;bottom - lpDCRect-&gt;top, hMemDC, lpDDBRect-&gt;left, <br>                lpDDBRect-&gt;top, SRCCOPY); <br>    else <br>        bSuccess = StretchBlt(hDC, lpDCRect-&gt;left,  lpDCRect-&gt;top,  <br>                lpDCRect-&gt;right - lpDCRect-&gt;left, <br>                lpDCRect-&gt;bottom - lpDCRect-&gt;top, hMemDC, lpDDBRect-&gt;left,  <br>                lpDDBRect-&gt;top,  lpDDBRect-&gt;right - lpDDBRect-&gt;left, <br>                lpDDBRect-&gt;bottom - lpDDBRect-&gt;top, SRCCOPY); <br> <br>    // Clean up <br> <br>    SelectObject(hMemDC, hOldBitmap); <br> <br>    DeleteDC(hMemDC); <br> <br>    // Return with success/fail flag <br> <br>    return bSuccess; <br>} <br> <br>void DrawWheels(LPWHEELINFO lpWheels, HBITMAP hWheelBitmap, HDC hDC, LPRECT lpBoundsRect) <br>{ <br>RECTrectDC, rectSlot; <br>DWORDdwWidth, dwHeight, dwXOffset, dwYOffset; <br>DWORDi; <br> <br>if (hWheelBitmap == NULL) <br>return; <br> <br>dwWidth = lpBoundsRect-&gt;right - lpBoundsRect-&gt;left; <br>dwHeight = lpBoundsRect-&gt;bottom - lpBoundsRect-&gt;top; <br> <br>dwXOffset = (dwWidth - (SLOTWIDTH * NUMWHEELS)) / (NUMWHEELS + 1); <br>dwYOffset = (dwHeight - SLOTHEIGHT) / 2; <br> <br>SetRect(&amp;rectDC, dwXOffset, dwYOffset, <br>dwXOffset + SLOTWIDTH, dwYOffset + SLOTHEIGHT); <br> <br>for (i = 0; i &lt; NUMWHEELS; i++) <br>{ <br>SetRect(&amp;rectSlot, 0, 0, SLOTWIDTH, SLOTHEIGHT); <br>OffsetRect(&amp;rectSlot, 0, lpWheels[i].dwIndex * PIXELSPERSLOT); <br> <br>PaintBitmap(hDC, &amp;rectDC, hWheelBitmap, &amp;rectSlot); <br> <br>OffsetRect(&amp;rectDC, SLOTWIDTH + dwXOffset, 0); <br>} <br>} <br> <br>void StartSpinning(LPWHEELINFO lpWheels) <br>{ <br>DWORDi; <br> <br>for (i = 0; i &lt; NUMWHEELS; i++) <br>{ <br>lpWheels[i].dwStartTicks = GetTickCount(); <br>lpWheels[i].dwStartTicks -= lpWheels[i].dwIndex * PIXELSPERSLOT * 1000 / PIXELSPERREV; <br>lpWheels[i].dwDuration = 1000 * (i + 1) + 1000; <br>} <br>} <br> <br>BOOL SpinWheels(HWND hWnd, LPWHEELINFO lpWheels, HBITMAP hWheelBitmap) <br>{ <br>HDChDC; <br>RECTrectBounds; <br>LPRECTlpBoundsRect; <br>RECTrectDC, rectSlot; <br>DWORDdwWidth, dwHeight, dwXOffset, dwYOffset, dwYStart; <br>DWORDi, dwTicks, dwStoppedCount; <br> <br>if (hWheelBitmap == NULL) <br>return (FALSE); <br> <br>hDC = GetWindowDC(GetDlgItem(hWnd, IDC_SLOTS)); <br>if (hDC == NULL) <br>return (FALSE); <br> <br>if (!GetWindowRect(GetDlgItem(hWnd, IDC_SLOTS), &amp;rectBounds)) <br>return (FALSE); <br> <br>lpBoundsRect = &amp;rectBounds; <br> <br>dwWidth = lpBoundsRect-&gt;right - lpBoundsRect-&gt;left; <br>dwHeight = lpBoundsRect-&gt;bottom - lpBoundsRect-&gt;top; <br> <br>dwXOffset = (dwWidth - (SLOTWIDTH * NUMWHEELS)) / (NUMWHEELS + 1); <br>dwYOffset = (dwHeight - SLOTHEIGHT) / 2; <br> <br>SetRect(&amp;rectDC, dwXOffset, dwYOffset, <br>dwXOffset + SLOTWIDTH, dwYOffset + SLOTHEIGHT); <br> <br>dwStoppedCount = 0; <br>for (i = 0; i &lt; NUMWHEELS; i++) <br>{ <br>if (lpWheels[i].dwDuration == 0) <br>{ <br>dwStoppedCount++; <br>} <br>else <br>{ <br>dwTicks = GetTickCount() - lpWheels[i].dwStartTicks; <br>dwYStart = (dwTicks * PIXELSPERSECOND) / 1000; <br>dwYStart %= PIXELSPERREV; <br> <br>if (dwTicks &gt;= lpWheels[i].dwDuration) <br>{ <br>//lpWheels[i].value = ((dwYStart + (PIXELSPERSLOT - 1)) / PIXELSPERSLOT) % SLOTSPERWHEEL; <br> <br>SetRect(&amp;rectSlot, 0, 0, SLOTWIDTH, SLOTHEIGHT); <br>OffsetRect(&amp;rectSlot, 0, lpWheels[i].dwIndex * PIXELSPERSLOT); <br>PaintBitmap(hDC, &amp;rectDC, hWheelBitmap, &amp;rectSlot); <br> <br>lpWheels[i].dwDuration = 0; <br>                if (dwStoppedCount == (NUMWHEELS - 1)) <br>                    PlaySound(MAKEINTRESOURCE(IDR_STOPWAVE), ghInstance, SND_RESOURCE); <br>                else <br>                    PlaySound(MAKEINTRESOURCE(IDR_STOPWAVE), ghInstance, SND_ASYNC | SND_RESOURCE); <br>            } <br>else <br>{ <br>SetRect(&amp;rectSlot, 0, 0, SLOTWIDTH, SLOTHEIGHT); <br>OffsetRect(&amp;rectSlot, 0, dwYStart); <br>if (rectSlot.bottom &gt; PIXELSPERREV) <br>{ <br>RECTrectSlotTmp, rectDCTmp; <br>DWORDheight; <br> <br>// copy from bottom end of bitmap <br>height = PIXELSPERREV - rectSlot.top; <br>rectSlotTmp = rectSlot; <br>rectSlotTmp.bottom = rectSlotTmp.top + height; <br>rectDCTmp = rectDC; <br>rectDCTmp.bottom = rectDCTmp.top + height; <br>PaintBitmap(hDC, &amp;rectDCTmp, hWheelBitmap, &amp;rectSlotTmp); <br> <br>height = rectSlot.bottom - PIXELSPERREV; <br>rectSlotTmp = rectSlot; <br>rectSlotTmp.top = 0; <br>rectSlotTmp.bottom = height; <br>rectDCTmp = rectDC; <br>rectDCTmp.top = rectDCTmp.bottom - height; <br>PaintBitmap(hDC, &amp;rectDCTmp, hWheelBitmap, &amp;rectSlotTmp); <br>} <br>else <br>PaintBitmap(hDC, &amp;rectDC, hWheelBitmap, &amp;rectSlot); <br>} <br>} <br>OffsetRect(&amp;rectDC, SLOTWIDTH + dwXOffset, 0); <br>} <br> <br>return (dwStoppedCount != NUMWHEELS); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
