<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SERVER.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3071"></a>SERVER.CPP</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved. <br> * <br> *  File:       server.cpp <br> *  Content:Slot machine server using DirectPlay. <br> * <br> ***************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;stdio.h&gt; <br> <br>#include "dpslots.h" <br>#include "resource.h" <br> <br>// constants <br>const UINTMAX_RECORD_LENGTH= 256;// max database record size <br>const DWORDINDEX_JACKPOT= 3;// index of jackpot image <br>const DWORDINDEX_SPOILER= 5;// index of spoiler image <br> <br>// window messages <br>const UINTWM_USER_ADDSTRING = WM_USER + 257;// add string to log window <br> <br>// structures <br>typedef struct { <br>DWORDdwBalance;// account record from database <br>} ACCOUNTINFO, *LPACCOUNTINFO; <br> <br>// globals <br>HWNDghServerWnd = NULL;// main window <br>FILE*glpFile = NULL;// database file <br> <br>// prototypes <br>HRESULTHandleBalanceRequest(LPDPLAYINFO lpDPInfo, LPMSG_BALANCEREQUEST lpBalance, DPID idTo); <br>HRESULTHandleSpinRequest(LPDPLAYINFO lpDPInfo, LPMSG_SPINREQUEST lpBalance, DPID idTo); <br>voidLogRequest(LPSTR lpszFormat, LPDPACCOUNTDESC lpAccountDesc, DWORD dwValue); <br>LONGGetAmountWonOrLost(DWORD dwAmountBet, DWORD dwIndex[]); <br>FILE*OpenAccountDB(LPSTR lpszDBName); <br>voidCloseAccountDB(FILE *lpFile); <br>BOOLQueryAccount(FILE *lpFile, LPSTR lpszAccountID, LPACCOUNTINFO lpAccountInfo); <br>BOOLUpdateAccount(FILE *lpFile, LPSTR lpszAccountID, LPACCOUNTINFO lpAccountInfo); <br>HRESULTGetAccountDesc(LPDPLAYINFO lpDPInfo, DPID idPlayer, LPDPACCOUNTDESC *lplpAccountDesc); <br> <br>BOOL CALLBACK ServerWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) <br>{ <br>static LPDPLAYINFOlpDPInfo = NULL; <br>static UINTidTimer = 0; <br>static FILE*lpFile = NULL; <br>DWORDdwTextLen; <br> <br>    switch(uMsg) <br>    { <br>    case WM_INITDIALOG: <br>        // save the connection info pointer <br>        lpDPInfo = (LPDPLAYINFO) lParam; <br> <br>// store global window <br>ghServerWnd = hWnd; <br> <br>// open account database <br>glpFile = OpenAccountDB(gszDatabaseName); <br>break; <br> <br>    case WM_DESTROY: <br>// stop the timer <br>if (idTimer) <br>{ <br>KillTimer(hWnd, idTimer);  <br>idTimer = 0; <br>} <br> <br>// close account database <br>if (glpFile) <br>CloseAccountDB(glpFile); <br> <br>ghServerWnd = NULL; <br>        break; <br> <br>// this is a user-defined message used to add strings to the log window <br>case WM_USER_ADDSTRING: <br>// get length of text in log window <br>dwTextLen = SendDlgItemMessage(hWnd, IDC_LOGEDIT, WM_GETTEXTLENGTH, <br>   (WPARAM) 0, (LPARAM) 0); <br> <br>// put selection at end <br>dwTextLen = SendDlgItemMessage(hWnd, IDC_LOGEDIT, EM_SETSEL, <br>   (WPARAM) dwTextLen, (LPARAM) dwTextLen); <br> <br>// add string in lParam to log window <br>SendDlgItemMessage(hWnd, IDC_LOGEDIT, EM_REPLACESEL, <br>(WPARAM) FALSE, (LPARAM) lParam); <br>GlobalFreePtr((LPVOID) lParam); <br>break; <br> <br>case WM_COMMAND: <br>        switch(LOWORD(wParam)) <br>        { <br>        case IDCANCEL: <br>EndDialog(hWnd, FALSE); <br>            break; <br>} <br>break; <br>} <br> <br>    // Allow for default processing <br>    return FALSE; <br>} <br> <br>void ServerApplicationMessage(LPDPLAYINFO lpDPInfo, LPDPMSG_GENERIC lpMsg, DWORD dwMsgSize, <br>  DPID idFrom, DPID idTo) <br>{ <br>switch (lpMsg-&gt;dwType) <br>{ <br>    case BALANCEREQUEST: <br> <br>HandleBalanceRequest(lpDPInfo, (LPMSG_BALANCEREQUEST)lpMsg, idFrom); <br>        break; <br> <br>    case SPINREQUEST: <br> <br>HandleSpinRequest(lpDPInfo, (LPMSG_SPINREQUEST)lpMsg, idFrom); <br>        break; <br> <br>    default: <br>        break;  <br>} <br>} <br> <br>void ServerSystemMessage(LPDPLAYINFO lpDPInfo, LPDPMSG_GENERIC lpMsg, DWORD dwMsgSize, <br> DPID idFrom, DPID idTo) <br>{ <br>    // The body of each case is there so you can set a breakpoint and examine <br>    // the contents of the message received. <br>switch (lpMsg-&gt;dwType) <br>{ <br>case DPSYS_CREATEPLAYERORGROUP: <br>        { <br>            LPDPMSG_CREATEPLAYERORGROUP lp = (LPDPMSG_CREATEPLAYERORGROUP) lpMsg; <br>        } <br>break; <br> <br>case DPSYS_DESTROYPLAYERORGROUP: <br>        { <br>            LPDPMSG_DESTROYPLAYERORGROUP lp = (LPDPMSG_DESTROYPLAYERORGROUP)lpMsg; <br>        } <br>break; <br> <br>case DPSYS_ADDPLAYERTOGROUP: <br>        { <br>            LPDPMSG_ADDPLAYERTOGROUP lp = (LPDPMSG_ADDPLAYERTOGROUP)lpMsg; <br>        } <br>break; <br> <br>case DPSYS_DELETEPLAYERFROMGROUP: <br>        { <br>            LPDPMSG_DELETEPLAYERFROMGROUP lp = (LPDPMSG_DELETEPLAYERFROMGROUP)lpMsg; <br>        } <br>break; <br> <br>case DPSYS_SESSIONLOST: <br>        { <br>            LPDPMSG_SESSIONLOST lp = (LPDPMSG_SESSIONLOST)lpMsg; <br>        } <br>break; <br> <br>case DPSYS_HOST: <br>        { <br>            LPDPMSG_HOSTlp = (LPDPMSG_HOST)lpMsg; <br>        } <br>break; <br> <br>case DPSYS_SETPLAYERORGROUPDATA: <br>        { <br>            LPDPMSG_SETPLAYERORGROUPDATA lp = (LPDPMSG_SETPLAYERORGROUPDATA)lpMsg; <br>        } <br>break; <br> <br>case DPSYS_SETPLAYERORGROUPNAME: <br>        { <br>            LPDPMSG_SETPLAYERORGROUPNAME lp = (LPDPMSG_SETPLAYERORGROUPNAME)lpMsg; <br>        } <br>break; <br> <br>case DPSYS_SECUREMESSAGE: <br>        { <br>            LPDPMSG_SECUREMESSAGE lp = (LPDPMSG_SECUREMESSAGE)lpMsg; <br> <br>ServerApplicationMessage(lpDPInfo, (LPDPMSG_GENERIC) lp-&gt;lpData, lp-&gt;dwDataSize, <br>  lp-&gt;dpIdFrom, idTo); <br> <br>        } <br>break; <br>} <br>} <br> <br>HRESULT HandleBalanceRequest(LPDPLAYINFO lpDPInfo, LPMSG_BALANCEREQUEST lpBalance, DPID idTo) <br>{ <br>    MSG_BALANCERESPONSEMsg; <br>LPDPACCOUNTDESClpAccountDesc = NULL; <br>ACCOUNTINFOAccountInfo; <br>HRESULThr; <br> <br>// create balance response message <br>ZeroMemory(&amp;Msg, sizeof(MSG_BALANCERESPONSE)); <br>Msg.dwType = BALANCERESPONSE; <br> <br>// get account description for this player <br>hr = GetAccountDesc(lpDPInfo, idTo, &amp;lpAccountDesc); <br>    if FAILED(hr) <br>goto FAILURE; <br> <br>// get account information from database using account ID <br>if ((glpFile == NULL) || <br>(!QueryAccount(glpFile, lpAccountDesc-&gt;lpszAccountIDA, &amp;AccountInfo))) <br>{ <br>hr = DPERR_ACCESSDENIED; <br>goto FAILURE; <br>} <br> <br>// return balance from database <br>Msg.dwBalance = AccountInfo.dwBalance; <br> <br>FAILURE: <br>Msg.hr = hr; <br> <br>if FAILED(Msg.hr) <br>LogRequest("Balance request for \"%s\" failed: 0x%08X\r\n", lpAccountDesc, Msg.hr); <br>else <br>LogRequest("Balance request for \"%s\" returned $%d\r\n", lpAccountDesc, Msg.dwBalance); <br> <br>if (lpAccountDesc) <br>GlobalFreePtr(lpAccountDesc); <br> <br>// send the message <br>    return (lpDPInfo-&gt;lpDirectPlay3A-&gt;Send(lpDPInfo-&gt;dpidPlayer, <br>idTo, SENDFLAGS(lpDPInfo-&gt;bIsSecure), <br>&amp;Msg, sizeof(MSG_BALANCERESPONSE))); <br>} <br> <br>HRESULT HandleSpinRequest(LPDPLAYINFO lpDPInfo, LPMSG_SPINREQUEST lpSpin, DPID idTo) <br>{ <br>    MSG_SPINRESPONSEMsg; <br>LPDPACCOUNTDESClpAccountDesc = NULL; <br>ACCOUNTINFOAccountInfo; <br>DWORDi; <br>HRESULThr; <br> <br>// create spin response message <br>    ZeroMemory(&amp;Msg, sizeof(MSG_SPINRESPONSE)); <br>    Msg.dwType = SPINRESPONSE; <br> <br>// get account description for this player <br>hr = GetAccountDesc(lpDPInfo, idTo, &amp;lpAccountDesc); <br>    if FAILED(hr) <br>goto FAILURE; <br> <br>// get account information from database using account ID <br>if ((glpFile == NULL) || <br>(!QueryAccount(glpFile, lpAccountDesc-&gt;lpszAccountIDA, &amp;AccountInfo))) <br>{ <br>hr = DPERR_ACCESSDENIED; <br>goto FAILURE; <br>} <br> <br>// bet exceeds balance in database <br>if (lpSpin-&gt;dwAmountBet &gt; AccountInfo.dwBalance) <br>{ <br>hr = DPERR_UNAVAILABLE; <br>goto FAILURE; <br>} <br> <br>// generate new slot settings <br>for (i = 0; i &lt; NUMWHEELS; i++) <br>Msg.dwIndex[i] = ((DWORD)rand()) % SLOTSPERWHEEL; <br> <br>// determine amount won or lost <br>Msg.dwAmountWonOrLost = GetAmountWonOrLost(lpSpin-&gt;dwAmountBet, Msg.dwIndex); <br> <br>// update account info in database for this player <br>AccountInfo.dwBalance += Msg.dwAmountWonOrLost; <br> <br>if (!UpdateAccount(glpFile, lpAccountDesc-&gt;lpszAccountIDA, &amp;AccountInfo)) <br>{ <br>hr = DPERR_ACCESSDENIED; <br>goto FAILURE; <br>} <br> <br>// send new balance back <br>    Msg.dwBalance = AccountInfo.dwBalance; <br> <br>FAILURE: <br>Msg.hr = hr; <br> <br>if FAILED(Msg.hr) <br>LogRequest("Spin request for \"%s\" failed: 0x%08X\r\n", lpAccountDesc, Msg.hr); <br>else <br>LogRequest("Spin request for \"%s\" returned $%d\r\n", lpAccountDesc, Msg.dwAmountWonOrLost); <br> <br>if (lpAccountDesc) <br>GlobalFreePtr(lpAccountDesc); <br> <br>// send the message <br>    return (lpDPInfo-&gt;lpDirectPlay3A-&gt;Send(lpDPInfo-&gt;dpidPlayer, <br>idTo, SENDFLAGS(lpDPInfo-&gt;bIsSecure), <br>&amp;Msg, sizeof(MSG_SPINRESPONSE))); <br>} <br> <br>void LogRequest(LPSTR lpszFormat, LPDPACCOUNTDESC lpAccountDesc, DWORD dwValue) <br>{ <br>LPSTRlpszStr; <br>LPSTRlpszAccountID; <br> <br>// make sure we have an account ID <br>if (lpAccountDesc == NULL) <br>lpszAccountID = "unknown"; <br>else <br>lpszAccountID = lpAccountDesc-&gt;lpszAccountIDA; <br> <br>// create a buffer for the output string, account string and a numeric value <br>lpszStr = (LPSTR) GlobalAllocPtr(GHND, strlen(lpszFormat) + strlen(lpszAccountID) + 10); <br>if (lpszStr == NULL) <br>return; <br> <br>// format the string to log <br>wsprintf(lpszStr, lpszFormat, lpszAccountID, dwValue); <br> <br>// log it - main wnd proc will dispose of the string <br>PostMessage(ghServerWnd, WM_USER_ADDSTRING, (WPARAM) 0, (LPARAM) lpszStr); <br>} <br> <br>LONG GetAmountWonOrLost(DWORD dwAmountBet, DWORD dwIndex[]) <br>{ <br>LONG    nMultiplier; <br> <br>// check for jackpot <br>if ((dwIndex[0] == INDEX_JACKPOT) &amp;&amp; <br>(dwIndex[1] == INDEX_JACKPOT) &amp;&amp; <br>(dwIndex[2] == INDEX_JACKPOT)) <br>{ <br>nMultiplier = 100; <br>} <br> <br>// three in a row <br>else if ((dwIndex[0] == dwIndex[1]) &amp;&amp; <br> (dwIndex[1] == dwIndex[2])) <br>{ <br>nMultiplier = 25; <br>} <br> <br>// first two match <br>else if (dwIndex[0] == dwIndex[1]) <br>{ <br>nMultiplier = 5; <br>} <br> <br>// you lose! <br>else <br>nMultiplier = -1; <br> <br>// any spoiler and you lose <br>if ((dwIndex[0] == INDEX_SPOILER) || <br>(dwIndex[1] == INDEX_SPOILER) || <br>(dwIndex[2] == INDEX_SPOILER)) <br>{ <br>nMultiplier = -1; <br>} <br> <br>// return amount won or lost <br>return (dwAmountBet * nMultiplier); <br>} <br> <br>FILE* OpenAccountDB(LPSTR lpszDBName) <br>{ <br>FILE*lpFile; <br> <br>lpFile = fopen(lpszDBName, "r+b"); <br> <br>return (lpFile); <br>} <br> <br>void CloseAccountDB(FILE *lpFile) <br>{ <br>fclose(lpFile); <br>} <br> <br>BOOL GetRecord(FILE *lpFile, LPSTR lpszKey, LPSTR lpszRecord) <br>{ <br>rewind(lpFile); <br>while (fgets(lpszRecord, MAX_RECORD_LENGTH, lpFile)) <br>{ <br>_strupr(lpszRecord); <br>if (!strncmp(lpszRecord, lpszKey, strlen(lpszKey))) <br>return (TRUE); <br>} <br> <br>return (FALSE); <br>} <br> <br>BOOL PutRecord(FILE *lpFile, LPSTR lpszKey, LPSTR lpszRecord) <br>{ <br>CHARszLine[MAX_RECORD_LENGTH]; <br>DWORDdwRecordIndex; <br> <br>rewind(lpFile); <br>dwRecordIndex = 0; <br>while (fgets(szLine, MAX_RECORD_LENGTH, lpFile)) <br>{ <br>_strupr(szLine); <br>if (!strncmp(szLine, lpszKey, strlen(lpszKey))) <br>{ <br>fseek(lpFile, dwRecordIndex, SEEK_SET); <br>fputs(lpszRecord, lpFile); <br>return (TRUE); <br>} <br>dwRecordIndex += strlen(szLine); <br>} <br> <br>return (FALSE); <br>} <br> <br>BOOL QueryAccount(FILE *lpFile, LPSTR lpszAccountID, LPACCOUNTINFO lpAccountInfo) <br>{ <br>    CHARszBuffer[MAX_RECORD_LENGTH]; <br>    CHAR*lpToken; <br> <br>    if (!GetRecord(lpFile, lpszAccountID, szBuffer)) <br>    { <br>        return FALSE; <br>    } <br> <br>    lpToken = strtok(szBuffer, ","); <br>    if (lpToken) <br>    { <br>        lpToken = strtok(NULL, "\n"); <br>        if (lpToken) <br>        { <br>            lpAccountInfo-&gt;dwBalance = atoi(lpToken); <br>        } <br>    } <br> <br>    return TRUE; <br>} <br> <br>BOOL UpdateAccount(FILE *lpFile, LPSTR lpszAccountID, LPACCOUNTINFO lpAccountInfo) <br>{ <br>    CHARszBuffer[MAX_RECORD_LENGTH]; <br> <br>    if (!GetRecord(lpFile, lpszAccountID, szBuffer)) <br>    { <br>        return FALSE; <br>    } <br> <br>sprintf(szBuffer, "%s,%8d", lpszAccountID, lpAccountInfo-&gt;dwBalance); <br>return (PutRecord(lpFile, lpszAccountID, szBuffer)); <br>} <br> <br>HRESULT GetSecureAccountDesc(LPDPLAYINFO lpDPInfo, DPID idPlayer, LPDPACCOUNTDESC *lplpAccountDesc) <br>{ <br>LPDPACCOUNTDESClpAccountDesc = NULL; <br>DWORDdwAccountDescSize; <br>HRESULThr; <br> <br>// get size of account description <br>hr = lpDPInfo-&gt;lpDirectPlay3A-&gt;GetPlayerAccount(idPlayer, 0, <br>NULL, &amp;dwAccountDescSize); <br>if (hr != DPERR_BUFFERTOOSMALL) <br>goto FAILURE; <br> <br>// make room for it <br>lpAccountDesc = (LPDPACCOUNTDESC) GlobalAllocPtr(GHND, dwAccountDescSize); <br>if (lpAccountDesc == NULL) <br>{ <br>hr = DPERR_OUTOFMEMORY; <br>goto FAILURE; <br>} <br> <br>// get the account description for this player <br>hr = lpDPInfo-&gt;lpDirectPlay3A-&gt;GetPlayerAccount(idPlayer, 0, <br>lpAccountDesc, &amp;dwAccountDescSize); <br>if FAILED(hr) <br>goto FAILURE; <br> <br>// return account description <br>_strupr(lpAccountDesc-&gt;lpszAccountIDA); <br>*lplpAccountDesc = lpAccountDesc; <br>lpAccountDesc = NULL; <br> <br>FAILURE: <br>if (lpAccountDesc) <br>GlobalFreePtr(lpAccountDesc); <br> <br>return (hr); <br>} <br> <br>HRESULT GetUnsecureAccountDesc(LPDPLAYINFO lpDPInfo, DPID idPlayer, LPDPACCOUNTDESC *lplpAccountDesc) <br>{ <br>LPDPACCOUNTDESClpAccountDesc = NULL; <br>DWORDdwAccountDescSize; <br>LPDPNAMElpName; <br>HRESULThr; <br> <br>// get size of player name <br>hr = lpDPInfo-&gt;lpDirectPlay3A-&gt;GetPlayerName(idPlayer, <br>NULL, &amp;dwAccountDescSize); <br>if (hr != DPERR_BUFFERTOOSMALL) <br>goto FAILURE; <br> <br>// make room for it <br>lpAccountDesc = (LPDPACCOUNTDESC) GlobalAllocPtr(GHND, sizeof(DPACCOUNTDESC) + dwAccountDescSize); <br>if (lpAccountDesc == NULL) <br>{ <br>hr = DPERR_OUTOFMEMORY; <br>goto FAILURE; <br>} <br> <br>// get the player name <br>lpName = (LPDPNAME) (((LPSTR)lpAccountDesc) + sizeof(DPACCOUNTDESC)); <br>hr = lpDPInfo-&gt;lpDirectPlay3A-&gt;GetPlayerName(idPlayer, <br>lpName, &amp;dwAccountDescSize); <br>if FAILED(hr) <br>goto FAILURE; <br> <br>// return account description <br>lpAccountDesc-&gt;lpszAccountIDA = lpName-&gt;lpszShortNameA; <br>_strupr(lpAccountDesc-&gt;lpszAccountIDA); <br>*lplpAccountDesc = lpAccountDesc; <br>lpAccountDesc = NULL; <br> <br>FAILURE: <br>if (lpAccountDesc) <br>GlobalFreePtr(lpAccountDesc); <br> <br>return (hr); <br>} <br> <br>HRESULT GetAccountDesc(LPDPLAYINFO lpDPInfo, DPID idPlayer, LPDPACCOUNTDESC *lplpAccountDesc) <br>{ <br>HRESULThr; <br> <br>if (lpDPInfo-&gt;bIsSecure) <br>{ <br>hr = GetSecureAccountDesc(lpDPInfo, idPlayer, lplpAccountDesc); <br>} <br>else <br>{ <br>hr = GetUnsecureAccountDesc(lpDPInfo, idPlayer, lplpAccountDesc); <br>} <br> <br>return (hr); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
