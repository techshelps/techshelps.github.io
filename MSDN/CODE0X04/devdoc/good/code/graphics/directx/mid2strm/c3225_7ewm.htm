<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MID2STRM.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3226"></a>MID2STRM.C</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1995-1996 Microsoft Corporation. All Rights Reserved. <br> * <br> *  File:mid2strm.c <br> *  Content:Converts a MIDI file into a MDS (MidiStream) File. <br> * <br> ***************************************************************************/ <br>#include &lt;stdio.h&gt; <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include &lt;assert.h&gt; <br> <br>// MIDI file constants <br>// <br>#define MThd0x6468544D// Start of file <br>#define MTrk0x6B72544D// Start of track <br> <br>#define MIDI_SYSEX((BYTE)0xF0)// SysEx begin <br>#define MIDI_SYSEXEND((BYTE)0xF7)// SysEx begin <br>#define MIDI_META((BYTE)0xFF)// Meta event begin <br>#define MIDI_META_TEMPO((BYTE)0x51) <br>#define MIDI_META_EOT((BYTE)0x2F)// End-of-track <br> <br>#define MIDI_NOTEOFF((BYTE)0x80)// + note + velocity <br>#define MIDI_NOTEON((BYTE)0x90)// + note + velocity <br>#define MIDI_POLYPRESS  ((BYTE)0xA0)// + pressure (2 bytes) <br>#define MIDI_CTRLCHANGE ((BYTE)0xB0)// + ctrlr + value <br>#define MIDI_PRGMCHANGE((BYTE)0xC0)// + new patch <br>#define MIDI_CHANPRESS((BYTE)0xD0)// + pressure (1 byte) <br>#define MIDI_PITCHBEND((BYTE)0xE0)// + pitch bend (2 bytes) <br> <br>#define CB_STREAMBUF(4096)// Size of each stream buffer <br> <br>#define MIDS_SHORTMSG(0x00000000) <br>#define MIDS_TEMPO(0x01000000) <br> <br>// Macros for swapping hi/lo-endian data <br>// <br>#define WORDSWAP(w)(((w) &gt;&gt; 8) | \ <br>(((w) &lt;&lt; 8) &amp; 0xFF00)) <br> <br>#define DWORDSWAP(dw) (((dw) &gt;&gt; 24) |\ <br>(((dw) &gt;&gt; 8) &amp; 0x0000FF00) |\ <br>(((dw) &lt;&lt; 8) &amp; 0x00FF0000) |\ <br>(((dw) &lt;&lt; 24) &amp; 0xFF000000)) <br> <br>// In debug builds, TRACKERR will show us where the parser died <br>// <br>#ifdef _DEBUG <br>#define TRACKERR(p,sz) ShowTrackError(p,sz); <br>#else <br>#define TRACKERR(p,sz) <br>#endif <br> <br> <br>// These structures are stored in MIDI files; they need to be byte <br>// aligned. <br>// <br>#pragma pack(1) <br> <br>// Chunk header. dwTag is either MTrk or MThd. <br>// <br>typedef struct <br>{ <br>DWORDdwTag;// Type <br>DWORDcbChunk;// Length (hi-lo) <br>} MIDICHUNK; <br> <br>// Contents of MThd chunk. <br>typedef struct <br>{ <br>WORDwFormat;// Format (hi-lo) <br>WORDcTrack;// # tracks (hi-lo) <br>WORDwTimeDivision;// Time division (hi-lo) <br>} MIDIFILEHDR; <br> <br>#pragma pack() <br> <br>// One event we're reading or writing to a track <br>// <br>typedef struct <br>{ <br>DWORDtkEvent;// Absolute time of event <br>BYTEabEvent[4];// Event type and parameters if channel msg <br>DWORDcbEvent;// Of data which follows if meta or sysex <br>LPBYTEpEvent;// -&gt; Event data if applicable <br>} MEVENT; <br> <br>// Description of a track open for read <br>// <br>#define ITS_F_ENDOFTRK0x00000001 <br> <br>typedef struct <br>{ <br>DWORDfdwTrack;// Track status <br>DWORDcbTrack;// Total bytes in track <br>DWORDcbLeft;// Bytes left unread in track <br>LPBYTEpTrack;// -&gt; start of track data <br>LPBYTEpTrackPointer;// -&gt; next byte to read <br>DWORDtkNextEventDue;// Absolute time of next event in track <br>BYTEbRunningStatus;// Running status from last channel msg <br>#ifdef _DEBUG <br>DWORDnTrack;// # of this track for debugging <br>#endif <br>} INTRACKSTATE; <br> <br>// Description of the input MIDI file <br>// <br>typedef struct <br>{ <br>DWORDcbFile;// Total bytes in file <br>LPBYTEpFile;// -&gt; entire file in memory <br>DWORDcbLeft;// Bytes left unread <br>LPBYTEpFilePointer;// -&gt; next byte to read <br> <br>DWORDdwTimeDivision;// Original time division <br>DWORDdwFormat;// Original format <br>DWORDcTrack;// Track count (specifies apIts size) <br>INTRACKSTATE*apIts;// -&gt; array of tracks in this file <br>} INFILESTATE; <br> <br>// Description of a stream buffer on the output side <br>// <br>typedef struct STREAMBUF *PSTREAMBUF; <br>typedef struct STREAMBUF <br>{ <br>LPBYTEpBuffer;// -&gt; Start of actual buffer <br>DWORDtkStart;// Tick time just before first event <br>LPBYTEpbNextEvent;// Where to write next event <br>DWORDcbLeft; // bytes left in buffer <br>DWORDcbLeftUncompressed;// bytes left when uncompressed <br>PSTREAMBUFpNext;// Next buffer <br>} STREAMBUF; <br> <br>// Description of output stream open for write <br>// <br>typedef struct <br>{ <br>DWORDtkTrack;// Current tick position in track <br>PSTREAMBUFpFirst;// First stream buffer <br>PSTREAMBUFpLast;// Last (current) stream buffer <br>} OUTSTREAMSTATE; <br> <br>// Format of structs within a MSD file <br>// <br>// 'fmt ' chunk <br>// <br> <br>#define MDS_F_NOSTREAMID0x00000001// Stream ID's skipped; reader inserts <br>typedef struct <br>{ <br>DWORDdwTimeFormat;// Low word == time format in SMF format <br>DWORDcbMaxBuffer;// Guaranteed max buffer size <br>DWORDdwFlags;// Format flags <br>} MIDSFMT; <br> <br>// 'data' chunk buffer header <br>// <br>typedef struct <br>{ <br>DWORDtkStart;// Absolute tick offset at start of buffer <br>DWORDcbBuffer;// Bytes in this buffer <br>} MIDSBUFFER; <br> <br>// A few globals <br>// <br>static HANDLEhInFile= INVALID_HANDLE_VALUE; <br>static HANDLEhOutFile= INVALID_HANDLE_VALUE; <br>static INFILESTATE  ifs; <br>static OUTSTREAMSTATE ots; <br>static BOOLfCompress= FALSE; <br> <br>// Messages <br>// <br>static char szInitErrMem[]= "Out of memory.\n"; <br>static char szInitErrInFile[]= "Read error on input file or file is corrupt.\n"; <br> <br>#ifdef _DEBUG <br>static char gteBadRunStat[] = "Reference to missing running status."; <br>static char gteRunStatMsgTrunc[] = "Running status message truncated"; <br>static char gteChanMsgTrunc[] = "Channel message truncated"; <br>static char gteSysExLenTrunc[] = "SysEx event truncated (length)"; <br>static char gteSysExTrunc[] = "SysEx event truncated"; <br>static char gteMetaNoClass[] ="Meta event truncated (no class byte)"; <br>static char gteMetaLenTrunc[] = "Meta event truncated (length)"; <br>static char gteMetaTrunc[] = "Meta event truncated"; <br>#endif <br> <br>// Prototypes <br>// <br>static BOOL Init(LPSTR szInFile, LPSTR szOutFile); <br>static LPBYTEGetInFileData(DWORD cbToGet); <br>static void Cleanup(void); <br>static BOOLBuildNewTracks(void); <br>static BOOLWriteStreamBuffers(void); <br>static BOOLGetTrackVDWord(INTRACKSTATE* pTs, LPDWORD lpdw); <br>static BOOLGetTrackEvent(INTRACKSTATE* pTs, MEVENT *pMe); <br>static BOOLAddEventToStream(MEVENT *pMe); <br>static LPBYTEGetOutStreamBytes(DWORD tkNow, DWORD cbNeeded, DWORD cbUncompressed); <br>#ifdef _DEBUG <br>static void ShowTrackError(INTRACKSTATE* pTs, char* szErr); <br>#endif <br> <br>void main(int argc, char* argv[]) <br>{ <br>UINTidxFnames; <br> <br>if (argc &lt; 3) <br>{ <br>fprintf(stderr, "Format is mid2strm [-c] infile outfile\n"); <br>fprintf(stderr, "-c\tNo-stream-id compression\n"); <br>exit(1); <br>} <br> <br>idxFnames = 1; <br>if (argv[1][0] == '-') <br>{ <br>++idxFnames; <br>if (argv[1][1] == 'c') <br>fCompress = TRUE; <br>} <br> <br>if (!Init(argv[idxFnames], argv[idxFnames+1])) <br>exit(1); <br> <br>if (!BuildNewTracks()) <br>exit(1); <br> <br>if (!WriteStreamBuffers()) <br>exit(1); <br> <br>// Add cleanup code!!! <br>// <br>Cleanup(); <br> <br>exit(0); <br>} <br> <br>// Init <br>//  <br>// Open the input and output files <br>// Allocate and read the entire input file into memory <br>// Validate the input file structure <br>// Allocate the input track structures and initialize them <br>// Initialize the output track structures <br>// <br>// Return TRUE on success <br>// Prints its own error message if something goes wrong <br>// <br>static BOOL Init(LPSTR szInFile, LPSTR szOutFile) <br>{ <br>BOOLfRet = FALSE; <br>DWORDcbRead; <br>LPDWORDlpdwTag; <br>LPDWORDlpcbHeader; <br>DWORDcbHeader; <br>MIDIFILEHDR*pHeader; <br>INTRACKSTATE*pTs; <br>UINTidx; <br> <br>// Initialize things we'll try to free later if we fail <br>// <br>ifs.cbFile = 0; <br>ifs.pFile = NULL; <br>ifs.apIts = NULL; <br> <br>// Attempt to open the input and output files <br>// <br>hInFile = CreateFile(szInFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); <br>if (INVALID_HANDLE_VALUE == hInFile) <br>{ <br>fprintf(stderr, "Could not open \"%s\" for read.\n", szInFile); <br>goto Init_Cleanup; <br>} <br> <br>hOutFile = CreateFile(szOutFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); <br>if (INVALID_HANDLE_VALUE == hOutFile) <br>{ <br>fprintf(stderr, "Could not open \"%s\" for write.\n", szOutFile); <br>goto Init_Cleanup; <br>} <br> <br>// Figure out how big the input file is and allocate a chunk of memory big enough <br>// to hold the whole thing. Read the whole file in at once. <br>// <br>if (((UINT)-1) == (ifs.cbFile = GetFileSize(hInFile, NULL))) <br>{ <br>fprintf(stderr, "File system error on input file.\n"); <br>goto Init_Cleanup; <br>} <br> <br>if (NULL == (ifs.pFile = GlobalAllocPtr(GPTR, ifs.cbFile))) <br>{ <br>fprintf(stderr, szInitErrMem); <br>goto Init_Cleanup; <br>} <br> <br>if ((!ReadFile(hInFile, ifs.pFile, ifs.cbFile, &amp;cbRead, NULL)) || <br>cbRead != ifs.cbFile) <br>{ <br>fprintf(stderr, szInitErrInFile); <br>goto Init_Cleanup; <br>} <br> <br>// Set up to read from the memory buffer. Read and validate <br>// - MThd header <br>// - size of file header chunk <br>// - file header itself <br>// <br>ifs.cbLeft = ifs.cbFile; <br>ifs.pFilePointer = ifs.pFile; <br> <br>if (NULL == (lpdwTag = (LPDWORD)GetInFileData(sizeof(*lpdwTag))) || <br>*lpdwTag != MThd || <br>NULL == (lpcbHeader = (LPDWORD)GetInFileData(sizeof(*lpcbHeader))) || <br>(cbHeader = DWORDSWAP(*lpcbHeader)) &lt; sizeof(MIDIFILEHDR) || <br>NULL == (pHeader = (MIDIFILEHDR*)GetInFileData(cbHeader))) <br>{ <br>fprintf(stderr, szInitErrInFile); <br>goto Init_Cleanup; <br>} <br> <br>// File header is stored in hi-lo order. Swap this into Intel order and save <br>// parameters in our native int size (32 bits) <br>// <br>ifs.dwFormat = (DWORD)WORDSWAP(pHeader-&gt;wFormat); <br>ifs.cTrack = (DWORD)WORDSWAP(pHeader-&gt;cTrack); <br>ifs.dwTimeDivision = (DWORD)WORDSWAP(pHeader-&gt;wTimeDivision); <br> <br>// We know how many tracks there are; allocate the structures for them and parse <br>// them. The parse merely looks at the MTrk signature and track chunk length <br>// in order to skip to the next track header. <br>// <br>ifs.apIts = (INTRACKSTATE*)GlobalAllocPtr(GPTR, ifs.cTrack*sizeof(INTRACKSTATE)); <br>if (NULL == ifs.apIts) <br>{ <br>fprintf(stderr, szInitErrMem); <br>goto Init_Cleanup; <br>} <br> <br>for (idx = 0, pTs = ifs.apIts; idx &lt; ifs.cTrack; ++idx, ++pTs) <br>{ <br>if (NULL == (lpdwTag = (LPDWORD)GetInFileData(sizeof(*lpdwTag))) || <br>*lpdwTag != MTrk || <br>NULL == (lpcbHeader = (LPDWORD)GetInFileData(sizeof(*lpcbHeader)))) <br>{ <br>fprintf(stderr, szInitErrInFile); <br>goto Init_Cleanup; <br>} <br> <br>cbHeader = DWORDSWAP(*lpcbHeader); <br>pTs-&gt;cbTrack = cbHeader; <br>pTs-&gt;cbLeft = cbHeader; <br>pTs-&gt;pTrack = GetInFileData(cbHeader); <br>if (NULL == pTs-&gt;pTrack) <br>{ <br>fprintf(stderr, szInitErrInFile); <br>goto Init_Cleanup; <br>} <br> <br>#ifdef _DEBUG <br>pTs-&gt;nTrack = idx; <br>#endif <br>pTs-&gt;pTrackPointer = pTs-&gt;pTrack; <br>pTs-&gt;cbLeft = pTs-&gt;cbTrack; <br>pTs-&gt;fdwTrack = 0; <br>pTs-&gt;bRunningStatus = 0; <br> <br>// Handle bozo MIDI files which contain empty track chunks <br>// <br>if (!pTs-&gt;cbLeft) <br>{ <br>pTs-&gt;fdwTrack |= ITS_F_ENDOFTRK; <br>continue; <br>} <br> <br> <br>// We always preread the time from each track so the mixer code can <br>// determine which track has the next event with a minimum of work <br>// <br>if (!GetTrackVDWord(pTs, &amp;pTs-&gt;tkNextEventDue)) <br>{ <br>fprintf(stderr, szInitErrInFile); <br>goto Init_Cleanup; <br>} <br>} <br> <br>ots.tkTrack = 0; <br>ots.pFirst = NULL; <br>ots.pLast = NULL; <br> <br>fRet = TRUE; <br> <br>Init_Cleanup: <br>if (!fRet) <br>Cleanup(); <br> <br>return fRet; <br>} <br> <br>// <br>// GetInFileData <br>// <br>// Gets the requested number of bytes of data from the input file and returns <br>// a pointer to them. <br>//  <br>// Returns a pointer to the data or NULL if we'd read more than is <br>// there. <br>// <br>static LPBYTEGetInFileData(DWORD cbToGet) <br>{ <br>LPBYTEpRet; <br> <br>if (ifs.cbLeft &lt; cbToGet) <br>return NULL; <br> <br>pRet = ifs.pFilePointer; <br> <br>ifs.cbLeft -= cbToGet; <br>ifs.pFilePointer += cbToGet; <br> <br>return pRet; <br>} <br> <br>// <br>// Cleanup <br>// <br>// Free anything we ever allocated <br>// <br>static void Cleanup(void) <br>{ <br>PSTREAMBUFpCurr; <br>PSTREAMBUFpNext; <br> <br>if (hInFile != INVALID_HANDLE_VALUE) CloseHandle(hInFile); <br>if (hOutFile != INVALID_HANDLE_VALUE) CloseHandle(hOutFile); <br>if (ifs.pFile)GlobalFreePtr(ifs.pFile); <br>if (ifs.apIts)GlobalFreePtr(ifs.apIts); <br> <br> <br>pCurr = ots.pFirst; <br>while (pCurr) <br>{ <br>pNext = pCurr-&gt;pNext; <br>GlobalFreePtr(pCurr); <br>pCurr = pNext; <br>} <br>} <br> <br>// <br>// BuildNewTracks <br>// <br>// This is where the actual work gets done. <br>// <br>// Until all tracks are done, <br>//  Scan the tracks to find the next due event <br>//  Figure out where the event belongs in the new mapping <br>//  Put it there <br>// Add end of track metas to all new tracks that now have any data <br>// <br>// Return TRUE on success <br>// Prints its own error message if something goes wrong <br>// <br>static BOOLBuildNewTracks(void) <br>{ <br>INTRACKSTATE*pTs; <br>INTRACKSTATE*pTsFound; <br>UINTidx; <br>DWORDtkNext; <br>MEVENTme; <br> <br>for(;;) <br>{ <br>// Find nearest event due <br>// <br>pTsFound = NULL; <br>tkNext = 0xFFFFFFFFL; <br> <br>for (idx = 0, pTs = ifs.apIts; idx &lt; ifs.cTrack; ++idx, ++pTs) <br>if ((!(pTs-&gt;fdwTrack &amp; ITS_F_ENDOFTRK)) &amp;&amp; (pTs-&gt;tkNextEventDue &lt; tkNext)) <br>{ <br>tkNext = pTs-&gt;tkNextEventDue; <br>pTsFound = pTs; <br>} <br> <br>// None found? We must be done <br>// <br>if (!pTsFound) <br>break; <br> <br>// Ok, get the event header from that track <br>// <br> <br>if (!GetTrackEvent(pTsFound, &amp;me)) <br>{ <br>fprintf(stderr, "MIDI file is corrupt!\n"); <br>return FALSE; <br>} <br> <br>// Don't add end of track event 'til we're done <br>// <br>if (me.abEvent[0] == MIDI_META &amp;&amp; me.abEvent[1] == MIDI_META_EOT) <br>continue; <br> <br>if (!AddEventToStream(&amp;me)) <br>{ <br>fprintf(stderr, "Out of memory building tracks.\n"); <br>return FALSE; <br>} <br>} <br> <br>return TRUE; <br>} <br> <br>// <br>// WriteStreamBuffers <br>// <br>// Write stream buffers into an MDS file (RIFF MIDS format) <br>// <br>// Return TRUE on success <br>// Prints its own error message if something goes wrong <br>// <br>#define FOURCC_MIDSmmioFOURCC('M','I','D','S') <br>#define FOURCC_fmt  mmioFOURCC('f','m','t',' ') <br>#define FOURCC_data mmioFOURCC('d','a','t','a') <br> <br>static BOOLWriteStreamBuffers(void) <br>{ <br>DWORDcbFmt; <br>DWORDcbData; <br>DWORDcbRiff; <br>PSTREAMBUFpsb; <br>FOURCCfcc; <br>FOURCCfcc2; <br>MIDSFMTfmt; <br>MIDSBUFFERdata; <br>DWORDcb; <br>DWORDcBuffers; <br> <br>// Walk buffer list to find entire size of data chunk <br>// <br>cbData = sizeof(cBuffers); <br>cBuffers = 0; <br>for (psb = ots.pFirst; psb; psb = psb-&gt;pNext, ++cBuffers) <br>cbData += sizeof(MIDSBUFFER) + (CB_STREAMBUF - psb-&gt;cbLeft); <br> <br>cbFmt = sizeof(fmt); <br> <br>// Figure size of entire RIFF chunk <br>// <br>cbRiff =  <br>sizeof(FOURCC) +// RIFF form type ('MIDS') <br>sizeof(FOURCC) +// Format chunk type ('fmt ') <br>sizeof(DWORD) + // Format chunk size <br>sizeof(MIDSFMT) +// Format chunk contents <br>sizeof(FOURCC) +// Data chunk type ('data') <br>sizeof(DWORD) +// Data chunk size <br>cbData;// Data chunk contents <br> <br>fcc = FOURCC_RIFF; <br>fcc2 = FOURCC_MIDS; <br>if ((!WriteFile(hOutFile, &amp;fcc, sizeof(fcc), &amp;cb, NULL)) || <br>(!WriteFile(hOutFile, &amp;cbRiff, sizeof(cbRiff), &amp;cb, NULL)) || <br>(!WriteFile(hOutFile, &amp;fcc2, sizeof(fcc2), &amp;cb, NULL))) <br>return FALSE; <br> <br> <br>fmt.dwTimeFormat = ifs.dwTimeDivision; <br>fmt.cbMaxBuffer= CB_STREAMBUF; <br>fmt.dwFlags = 0; <br>if (fCompress) <br>fmt.dwFlags|= MDS_F_NOSTREAMID; <br> <br>fcc = FOURCC_fmt; <br>if ((!WriteFile(hOutFile, &amp;fcc, sizeof(fcc), &amp;cb, NULL)) || <br>(!WriteFile(hOutFile, &amp;cbFmt, sizeof(cbFmt), &amp;cb, NULL)) || <br>(!WriteFile(hOutFile, &amp;fmt, sizeof(fmt), &amp;cb, NULL))) <br>return FALSE; <br> <br>fcc = FOURCC_data; <br>if ((!WriteFile(hOutFile, &amp;fcc, sizeof(fcc), &amp;cb, NULL)) || <br>(!WriteFile(hOutFile, &amp;cbData, sizeof(cbData), &amp;cb, NULL)) || <br>(!WriteFile(hOutFile, &amp;cBuffers, sizeof(cBuffers), &amp;cb, NULL))) <br>return FALSE; <br> <br>for (psb = ots.pFirst; psb; psb = psb-&gt;pNext) <br>{ <br>data.tkStart = psb-&gt;tkStart; <br>data.cbBuffer = CB_STREAMBUF - psb-&gt;cbLeft; <br> <br>if ((!WriteFile(hOutFile, &amp;data, sizeof(data), &amp;cb, NULL)) || <br>(!WriteFile(hOutFile, psb-&gt;pBuffer, data.cbBuffer, &amp;cb, NULL))) <br>return FALSE; <br>} <br> <br>return TRUE; <br>} <br> <br>// <br>// GetTrackVDWord <br>// <br>// Attempts to parse a variable length DWORD from the given track. A VDWord <br>// in a MIDI file <br>//  (a) is in lo-hi format  <br>//  (b) has the high bit set on every byte except the last <br>// <br>// Returns the DWORD in *lpdw and TRUE on success; else <br>// FALSE if we hit end of track first. Sets ITS_F_ENDOFTRK <br>// if we hit end of track. <br>// <br>static BOOLGetTrackVDWord(INTRACKSTATE* pTs, LPDWORD lpdw) <br>{ <br>BYTEb; <br>DWORDdw = 0; <br> <br>if (pTs-&gt;fdwTrack &amp; ITS_F_ENDOFTRK) <br>return FALSE; <br> <br>do <br>{ <br>if (!pTs-&gt;cbLeft) <br>{ <br>pTs-&gt;fdwTrack |= ITS_F_ENDOFTRK; <br>return FALSE; <br>} <br> <br>b = *pTs-&gt;pTrackPointer++; <br>--pTs-&gt;cbLeft; <br> <br> dw = (dw &lt;&lt; 7) | (b &amp; 0x7F); <br>} while (b &amp; 0x80); <br> <br>*lpdw = dw; <br> <br>return TRUE; <br>} <br> <br>// <br>// GetTrackEvent <br>// <br>// Fills in the event struct with the next event from the track <br>// <br>// pMe-&gt;tkEvent will contain the absolute tick time of the event <br>// pMe-&gt;abEvent[0] will contain <br>//  MIDI_META if the event is a meta event; <br>//   in this case pMe-&gt;abEvent[1] will contain the meta class <br>//  MIDI_SYSEX or MIDI_SYSEXEND if the event is a SysEx event <br>//  Otherwise, the event is a channel message and pMe-&gt;abEvent[1] <br>//   and pMe-&gt;abEvent[2] will contain the rest of the event. <br>// <br>// pMe-&gt;cbEvent will contain <br>//  The total length of the channel message in pMe-&gt;abEvent if <br>//   the event is a channel message <br>//  The total length of the paramter data pointed to by <br>//   pMe-&gt;pEvent otherwise <br>// <br>// pMe-&gt;pEvent will point at any additional paramters if the  <br>//  event is a SysEx or meta event with non-zero length; else <br>//  it will contain NULL <br>// <br>// Returns TRUE on success or FALSE on any kind of parse error <br>// Prints its own error message ONLY in the debug version <br>// <br>// Maintains the state of the input track (i.e. pTs-&gt;cbLeft, <br>// pTs-&gt;pTrackPointers, and pTs-&gt;bRunningStatus). <br>// <br>static BOOLGetTrackEvent(INTRACKSTATE* pTs, MEVENT *pMe) <br>{ <br>BYTEb; <br>UINTcbEvent; <br> <br>pMe-&gt;pEvent = NULL; <br> <br>// Already at end of track? There's nothing to read. <br>// <br>if ((pTs-&gt;fdwTrack &amp; ITS_F_ENDOFTRK) || !pTs-&gt;cbLeft) <br>return FALSE; <br> <br>// Get the first byte, which determines the type of event. <br>// <br>b = *pTs-&gt;pTrackPointer++; <br>--pTs-&gt;cbLeft; <br> <br>// If the high bit is not set, then this is a channel message <br>// which uses the status byte from the last channel message <br>// we saw. NOTE: We do not clear running status across SysEx or <br>// meta events even though the spec says to because there are <br>// actually files out there which contain that sequence of data. <br>// <br>if (!(b &amp; 0x80)) <br>{ <br>// No previous status byte? We're hosed. <br>// <br>if (!pTs-&gt;bRunningStatus) <br>{ <br>TRACKERR(pTs, gteBadRunStat); <br>return FALSE; <br>} <br> <br>pMe-&gt;abEvent[0] = pTs-&gt;bRunningStatus; <br>pMe-&gt;abEvent[1] = b; <br> <br>b = pMe-&gt;abEvent[0] &amp; 0xF0; <br>pMe-&gt;cbEvent = 2; <br> <br>// Only program change and channel pressure events are 2 bytes long; <br>// the rest are 3 and need another byte <br>// <br>if (b != MIDI_PRGMCHANGE &amp;&amp; b != MIDI_CHANPRESS) <br>{ <br>if (!pTs-&gt;cbLeft) <br>{ <br>TRACKERR(pTs, gteRunStatMsgTrunc); <br>pTs-&gt;fdwTrack |= ITS_F_ENDOFTRK; <br>return FALSE; <br>} <br> <br>pMe-&gt;abEvent[2] = *pTs-&gt;pTrackPointer++; <br>--pTs-&gt;cbLeft; <br>++pMe-&gt;cbEvent; <br>} <br>} <br>else if ((b &amp; 0xF0) != MIDI_SYSEX) <br>{ <br>// Not running status, not in SysEx range - must be <br>// normal channel message (0x80-0xEF) <br>// <br>pMe-&gt;abEvent[0] = b; <br>pTs-&gt;bRunningStatus = b; <br> <br>// Strip off channel and just keep message type <br>// <br>b &amp;= 0xF0; <br> <br>cbEvent = (b == MIDI_PRGMCHANGE || b == MIDI_CHANPRESS) ? 1 : 2; <br>pMe-&gt;cbEvent = cbEvent + 1; <br> <br>if (pTs-&gt;cbLeft &lt; cbEvent) <br>{ <br>TRACKERR(pTs, gteChanMsgTrunc); <br>pTs-&gt;fdwTrack |= ITS_F_ENDOFTRK; <br>return FALSE; <br>} <br> <br>pMe-&gt;abEvent[1] = *pTs-&gt;pTrackPointer++; <br>if (cbEvent == 2) <br>pMe-&gt;abEvent[2] = *pTs-&gt;pTrackPointer++; <br> <br>pTs-&gt;cbLeft -= cbEvent; <br>}  <br>else if (b == MIDI_SYSEX || b == MIDI_SYSEXEND) <br>{ <br>// One of the SysEx types. (They are the same as far as we're concerned; <br>// there is only a semantic difference in how the data would actually <br>// get sent when the file is played. We must take care to put the correct <br>// event type back on the output track, however.) <br>// <br>// Parse the general format of: <br>//  BYTE bEvent (MIDI_SYSEX or MIDI_SYSEXEND) <br>//  VDWORD cbParms <br>//  BYTE   abParms[cbParms] <br>// <br>pMe-&gt;abEvent[0] = b; <br>if (!GetTrackVDWord(pTs, &amp;pMe-&gt;cbEvent)) <br>{ <br>TRACKERR(pTs, gteSysExLenTrunc); <br>return FALSE; <br>} <br> <br>if (pTs-&gt;cbLeft &lt; pMe-&gt;cbEvent) <br>{ <br>TRACKERR(pTs, gteSysExTrunc); <br>pTs-&gt;fdwTrack |= ITS_F_ENDOFTRK; <br>return FALSE; <br>} <br> <br>pMe-&gt;pEvent = pTs-&gt;pTrackPointer; <br>pTs-&gt;pTrackPointer += pMe-&gt;cbEvent; <br>pTs-&gt;cbLeft -= pMe-&gt;cbEvent; <br>}  <br>else if (b == MIDI_META) <br>{ <br>// It's a meta event. Parse the general form: <br>//  BYTEbEvent(MIDI_META) <br>//BYTEbClass <br>//  VDWORDcbParms <br>//BYTEabParms[cbParms] <br>// <br>pMe-&gt;abEvent[0] = b; <br> <br>if (!pTs-&gt;cbLeft) <br>{ <br>TRACKERR(pTs, gteMetaNoClass); <br>pTs-&gt;fdwTrack |= ITS_F_ENDOFTRK; <br>return FALSE; <br>} <br> <br>pMe-&gt;abEvent[1] = *pTs-&gt;pTrackPointer++; <br>--pTs-&gt;cbLeft; <br> <br>if (!GetTrackVDWord(pTs, &amp;pMe-&gt;cbEvent)) <br>{ <br>TRACKERR(pTs, gteMetaLenTrunc); <br>return FALSE; <br>} <br> <br>// NOTE: Perfectly valid to have a meta with no data <br>// In this case, cbEvent == 0 and pEvent == NULL <br>// <br>if (pMe-&gt;cbEvent) <br>{ <br>if (pTs-&gt;cbLeft &lt; pMe-&gt;cbEvent) <br>{ <br>TRACKERR(pTs, gteMetaTrunc); <br>pTs-&gt;fdwTrack |= ITS_F_ENDOFTRK; <br>return FALSE; <br>} <br> <br>pMe-&gt;pEvent = pTs-&gt;pTrackPointer; <br>pTs-&gt;pTrackPointer += pMe-&gt;cbEvent; <br>pTs-&gt;cbLeft -= pMe-&gt;cbEvent; <br>} <br> <br>if (pMe-&gt;abEvent[1] == MIDI_META_EOT) <br>pTs-&gt;fdwTrack |= ITS_F_ENDOFTRK; <br>} <br>else <br>{ <br>// Messages in this range are system messages and aren't supposed to <br>// be in a normal MIDI file. If they are, we've misparsed or the <br>// authoring software is stpuid. <br>// <br>return FALSE; <br>} <br> <br>// Event time was already stored as the current track time <br>// <br>pMe-&gt;tkEvent = pTs-&gt;tkNextEventDue; <br> <br>// Now update to the next event time. The code above MUST properly <br>// maintain the end of track flag in case the end of track meta is <br>// missing.  <br>// <br>if (!(pTs-&gt;fdwTrack &amp; ITS_F_ENDOFTRK)) <br>{ <br>DWORDtkDelta; <br> <br>if (!GetTrackVDWord(pTs, &amp;tkDelta)) <br>return FALSE; <br> <br>pTs-&gt;tkNextEventDue += tkDelta; <br>} <br> <br>return TRUE; <br>} <br> <br>// <br>// AddEventToStream <br>// <br>// Put the given event onto the given output track. <br>// pMe must point to an event filled out in accordance with the <br>// description given in GetTrackEvent <br>// <br>// Returns TRUE on sucess or FALSE if we're out of memory <br>// <br>static BOOLAddEventToStream(MEVENT *pMe) <br>{ <br>PDWORDpdw; <br>DWORDtkNow; <br>DWORDtkDelta; <br>UINTcdw; <br> <br>tkNow = ots.tkTrack; <br> <br>// Delta time is absolute event time minus absolute time <br>// already gone by on this track <br>// <br>tkDelta = pMe-&gt;tkEvent - ots.tkTrack; <br> <br>// Event time is now current time on this track <br>// <br>ots.tkTrack = pMe-&gt;tkEvent; <br> <br>if (pMe-&gt;abEvent[0] &lt; MIDI_SYSEX) <br>{ <br>// Channel message. We know how long it is, just copy it. Need 3 DWORD's: delta-t,  <br>// stream-ID, event <br>//  <br>// TODO: Compress with running status <br>// <br> <br>cdw = (fCompress ? 2 : 3); <br>if (NULL == (pdw = (PDWORD)GetOutStreamBytes(tkNow, cdw * sizeof(DWORD), 3 * sizeof(DWORD)))) <br>return FALSE; <br> <br>*pdw++ = tkDelta; <br>if (!fCompress) <br>*pdw++ = 0; <br>*pdw =(pMe-&gt;abEvent[0]) | <br>(((DWORD)pMe-&gt;abEvent[1]) &lt;&lt; 8) | <br>(((DWORD)pMe-&gt;abEvent[2]) &lt;&lt; 16) | <br>MIDS_SHORTMSG; <br> <br>} <br>else if (pMe-&gt;abEvent[0] == MIDI_SYSEX || pMe-&gt;abEvent[0] == MIDI_SYSEXEND) <br>{ <br>fprintf(stderr, "NOTE: Ignoring SysEx for now.\n"); <br>} <br>else <br>{ <br>// Better be a meta event. <br>//  BYTEbEvent <br>//  BYTE bClass <br>//VDWORDcbParms <br>//BYTEabParms[cbParms] <br>// <br>assert(pMe-&gt;abEvent[0] == MIDI_META); <br> <br>// The only meta-event we care about is change tempo <br>// <br>if (pMe-&gt;abEvent[1] != MIDI_META_TEMPO) <br>return TRUE; <br> <br>assert(pMe-&gt;cbEvent == 3); <br> <br>cdw = (fCompress ? 2 : 3); <br>pdw = (PDWORD)GetOutStreamBytes(tkNow, cdw * sizeof(DWORD), 3 * sizeof(DWORD)); <br>if (NULL == pdw) <br>return FALSE; <br> <br>*pdw++ = tkDelta; <br>if (!fCompress) <br>*pdw++ = (DWORD)-1; <br>*pdw =(pMe-&gt;pEvent[2]) | <br>(((DWORD)pMe-&gt;pEvent[1]) &lt;&lt; 8) | <br>(((DWORD)pMe-&gt;pEvent[0]) &lt;&lt; 16) | <br>MIDS_TEMPO; <br>} <br> <br>return TRUE; <br>} <br> <br>// <br>// GetOutStreamBytes <br>// <br>// This function performs the memory management and pseudo-file I/O for output <br>// tracks. <br>//  <br>// We build a linked list of stream buffers as they would exist if they were <br>// about to be played. Each buffer is CB_STREAMBUF bytes long maximum. They are <br>// filled as full as possible; events are not allowed to cross buffers. <br>// <br>// Returns a pointer to the number of requested bytes or NULL if we're out of memory <br>// <br>static LPBYTEGetOutStreamBytes(DWORD tkNow, DWORD cbNeeded, DWORD cbUncompressed) <br>{ <br>LPBYTEpb; <br> <br>// Round request up to the next DWORD boundry. This aligns the final output buffer correctly <br>// and allows the above routines to deal with byte-aligned data <br>// <br>cbNeeded = (cbNeeded + 3) &amp; ~3; <br>cbUncompressed = (cbUncompressed + 3) &amp; ~3; <br> <br>assert(cbUncompressed &gt;= cbNeeded); <br> <br>if (NULL == ots.pLast || cbUncompressed &gt; ots.pLast-&gt;cbLeftUncompressed) <br>{ <br>PSTREAMBUF pNew; <br> <br>pNew = GlobalAllocPtr(GHND, sizeof(*pNew) + CB_STREAMBUF); <br>if (NULL == pNew) <br>return NULL; <br> <br>pNew-&gt;pBuffer = (LPBYTE)(pNew + 1); <br>pNew-&gt;tkStart= tkNow; <br>pNew-&gt;pbNextEvent = pNew-&gt;pBuffer; <br>pNew-&gt;cbLeft = CB_STREAMBUF; <br>pNew-&gt;cbLeftUncompressed = CB_STREAMBUF; <br>pNew-&gt;pNext = NULL; <br> <br>if (!ots.pLast) <br>{ <br>ots.pFirst = pNew; <br>ots.pLast  = pNew; <br>} <br>else <br>{ <br>ots.pLast-&gt;pNext = pNew; <br>ots.pLast= pNew; <br>} <br>} <br> <br>// If there's STILL not enough room for the requested block, then an event is bigger than  <br>// the buffer size -- this is unacceptable.  <br>// <br>if (cbNeeded &gt; ots.pLast-&gt;cbLeft) <br>{ <br>fprintf(stderr, "NOTE: An event requested %lu bytes of memory; the\n", cbNeeded); <br>fprintf(stderr, "      maximum configured buffer size is %lu.\n", (DWORD)CB_STREAMBUF); <br> <br>return NULL; <br>} <br> <br>pb = ots.pLast-&gt;pbNextEvent; <br> <br>ots.pLast-&gt;pbNextEvent += cbNeeded; <br>ots.pLast-&gt;cbLeft -= cbNeeded; <br>ots.pLast-&gt;cbLeftUncompressed -= cbUncompressed; <br> <br>return pb; <br>} <br> <br>#ifdef _DEBUG <br>static void ShowTrackError(INTRACKSTATE* pTs, char* szErr) <br>{ <br>fprintf(stderr, "Track %u: %s\n", pTs-&gt;nTrack, szErr); <br>fprintf(stderr, "Track offset %lu\n", (DWORD)(pTs-&gt;pTrackPointer - pTs-&gt;pTrack)); <br>fprintf(stderr, "Track total %lu  Track left %lu\n", pTs-&gt;cbTrack, pTs-&gt;cbLeft); <br>} <br>#endif <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
