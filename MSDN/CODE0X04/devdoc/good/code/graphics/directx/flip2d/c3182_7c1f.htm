<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DUMB3D.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3183"></a>DUMB3D.H</h2>
<pre><code>/************************************************************************** <br>  dumb3d.h - A simple linear algebra library for 3D. <br> <br> **************************************************************************/ <br>/************************************************************************** <br> <br>    (C) Copyright 1995-1997 Microsoft Corp.  All rights reserved. <br> <br>    You have a royalty-free right to use, modify, reproduce and  <br>    distribute the Sample Files (and/or any modified version) in  <br>    any way you find useful, provided that you agree that  <br>    Microsoft has no warranty obligations or liability for any  <br>    Sample Application Files which are modified.  <br> <br> **************************************************************************/ <br> <br>#if !defined(DUMB3D_HPP) <br>#define DUMB3D_HPP <br> <br>/*---------------------------------------------------------------------------- <br> <br>This header contains the declarations for the dumb3d functions. <br> <br>*/ <br> <br> <br>// real type <br> <br>typedef double real; <br> <br> <br>#define M_PI            3.14159265358979323846 <br> <br> <br>// forward declarations <br> <br>class point_4; <br>class vector_4; <br>class matrix_4x4; <br> <br>/*---------------------------------------------------------------------------- <br> <br>globally useful functions. <br> <br>*/ <br> <br>inline vector_4 operator-( point_4 const &amp;Operand1, point_4 const &amp;Operand2 ); <br> <br>inline vector_4 operator+( vector_4 const &amp;Operand1, <br>    vector_4 const &amp;Operand2 ); <br> <br>inline vector_4 operator-( vector_4 const &amp;Operand1, <br>    vector_4 const &amp;Operand2 ); <br> <br>inline vector_4 operator*( vector_4 const &amp;Multiplicand, <br>    real const &amp;Multiplier ); <br> <br>inline vector_4 operator*( real const &amp;Multiplier, <br>    vector_4 const &amp;Multiplicand ); <br>     <br>inline point_4 operator+( point_4 const &amp;Operand1, vector_4 const &amp;Operand2 ); <br>inline point_4 operator-( point_4 const &amp;Operand1, vector_4 const &amp;Operand2 ); <br>inline point_4 operator+( vector_4 const &amp;Operand2, point_4 const &amp;Operand1 ); <br> <br>inline vector_4 operator-( vector_4 const &amp;Operand1 ); <br> <br>inline vector_4 CrossProduct( vector_4 const &amp;Operand1, <br>    vector_4 const &amp;Operand2 ); <br> <br>inline real DotProduct( vector_4 const &amp;Operand1, vector_4 const &amp;Operand2 ); <br> <br>matrix_4x4 operator*( matrix_4x4 const &amp;Multiplicand, <br>    matrix_4x4 const &amp;Multiplier ); <br> <br>vector_4 operator*( matrix_4x4 const &amp;Multiplicand, <br>    vector_4 const &amp;Multiplier ); <br> <br>point_4 operator*( matrix_4x4 const &amp;Multiplicand, <br>    point_4 const &amp;Multiplier ); <br> <br> <br> <br> <br>/*---------------------------------------------------------------------------- <br> <br>quadruple.  Base class for homogeneous vectors and points. <br> <br>*/ <br> <br>class quadruple <br>{ <br>public: <br> <br>  inline real GetElement( int Row ) const; <br> <br>  inline real GetX( void ) const; <br>  inline real GetY( void ) const; <br>  inline real GetZ( void ) const; <br>  inline real GetW( void ) const; <br> <br>  inline void SetElement( int Row, real Value ); <br> <br>  inline void SetX( real Value ); <br>  inline void SetY( real Value ); <br>  inline void SetZ( real Value ); <br>  inline void SetW( real Value ); <br> <br> <br>protected: <br> <br>  inline quadruple( void ); <br>  inline quadruple( real X, real Y, real Z, real W ); <br>  inline quadruple( quadruple const &amp; ); <br>  inline quadruple &amp;operator=( quadruple const &amp; ); <br>   <br>  real aElements[4]; <br>}; <br> <br> <br>/*---------------------------------------------------------------------------- <br> <br>point_4.  This class represents a homogeneous 3D point. <br> <br>*/ <br> <br>class point_4 : <br>  public quadruple <br>{ <br>public: <br> <br>  inline point_4( void ); <br>  inline point_4( real X, real Y, real Z ); <br> <br>  inline void Homogenize( void ); <br>}; <br> <br>/*---------------------------------------------------------------------------- <br> <br>vector_4.  This class represents a homogeneous 3D vector. <br> <br>*/ <br> <br>class vector_4 : <br>  public quadruple <br>{ <br>public: <br> <br>  inline vector_4( void ); <br>  inline vector_4( real X, real Y, real Z ); <br> <br>  vector_4 &amp;Normalize( void ); <br>}; <br> <br> <br> <br>/*---------------------------------------------------------------------------- <br> <br>matrix_4x4.  This class represents row major 4x4 homogeneous matrices. <br> <br>*/ <br> <br>class matrix_4x4 <br>{ <br>public: <br> <br>  matrix_4x4( void ); <br> <br>  matrix_4x4 &amp;ConcatenateXRotation( real Degrees ); <br>  matrix_4x4 &amp;ConcatenateYRotation( real Degrees ); <br>  matrix_4x4 &amp;ConcatenateZRotation( real Degrees ); <br> <br>  matrix_4x4 &amp;ConcatenateXTranslation( real Distance ); <br>  matrix_4x4 &amp;ConcatenateYTranslation( real Distance ); <br>  matrix_4x4 &amp;ConcatenateZTranslation( real Distance ); <br> <br>  inline real GetElement( int Row, int Column ) const; <br>  inline matrix_4x4 &amp;SetElement( int Row, int Column, real Value ); <br>  inline matrix_4x4 &amp; operator=(matrix_4x4 const &amp; m); <br>   <br>protected: <br> <br>  enum do_not_initialize { DoNotInitialize }; <br> <br>  inline matrix_4x4( do_not_initialize ); <br> <br>  real aElements[4][4]; <br>}; <br> <br>/*---------------------------------------------------------------------------- <br> <br>view transform. <br> <br>*/ <br> <br>class view_transform : <br>  public matrix_4x4 <br>{ <br>public: <br> <br>  view_transform( point_4 const &amp;Viewpoint, vector_4 const &amp;ViewDirection, <br>    vector_4 const &amp;Up ); <br>}; <br> <br> <br>/*---------------------------------------------------------------------------- <br> <br>inline function definitions. <br> <br>*/ <br> <br> <br>inline vector_4 operator-( point_4 const &amp;Operand1, point_4 const &amp;Operand2 ) <br>{ <br>  return vector_4(Operand1.GetX() - Operand2.GetX(), <br>          Operand1.GetY() - Operand2.GetY(), <br>          Operand1.GetZ() - Operand2.GetZ()); <br>} <br> <br>inline vector_4 operator+( vector_4 const &amp;Operand1, <br>    vector_4 const &amp;Operand2 ) <br>{ <br>  return vector_4(Operand1.GetX() + Operand2.GetX(), <br>          Operand1.GetY() + Operand2.GetY(), <br>          Operand1.GetZ() + Operand2.GetZ()); <br>} <br> <br>inline vector_4 operator-( vector_4 const &amp;Operand1, <br>    vector_4 const &amp;Operand2 ) <br>{ <br>  return vector_4(Operand1.GetX() - Operand2.GetX(), <br>          Operand1.GetY() - Operand2.GetY(), <br>          Operand1.GetZ() - Operand2.GetZ()); <br>} <br> <br>inline vector_4 operator-( vector_4 const &amp;Operand1 ) <br>{ <br>  return vector_4(-Operand1.GetX(),-Operand1.GetY(),-Operand1.GetZ()); <br>} <br> <br>inline vector_4 operator*( vector_4 const &amp;Multiplicand, <br>    real const &amp;Multiplier ) <br>{ <br>  return vector_4(Multiplicand.GetX() * Multiplier, <br>          Multiplicand.GetY() * Multiplier, <br>          Multiplicand.GetZ() * Multiplier); <br>} <br> <br>inline vector_4 operator*( real const &amp;Multiplier, <br>    vector_4 const &amp;Multiplicand )  <br>{ <br>  return vector_4(Multiplicand.GetX() * Multiplier, <br>          Multiplicand.GetY() * Multiplier, <br>          Multiplicand.GetZ() * Multiplier); <br>} <br>     <br>inline point_4 operator+( point_4 const &amp;Operand1, vector_4 const &amp;Operand2 ) <br>{ <br>  return point_4(Operand1.GetX() + Operand2.GetX(), <br>          Operand1.GetY() + Operand2.GetY(), <br>          Operand1.GetZ() + Operand2.GetZ()); <br>} <br> <br>inline point_4 operator-( point_4 const &amp;Operand1, vector_4 const &amp;Operand2 ) <br>{ <br>  return point_4(Operand1.GetX() - Operand2.GetX(), <br>          Operand1.GetY() - Operand2.GetY(), <br>          Operand1.GetZ() - Operand2.GetZ()); <br>} <br> <br>inline point_4 operator+( vector_4 const &amp;Operand1, point_4 const &amp;Operand2 ) <br>{ <br>  return Operand2 + Operand1; <br>} <br> <br>inline vector_4 CrossProduct( vector_4 const &amp;Operand1, <br>    vector_4 const &amp;Operand2 ) <br>{ <br>  real X = Operand1.GetY() * Operand2.GetZ() - <br>        Operand1.GetZ() * Operand2.GetY(); <br>  real Y = Operand1.GetZ() * Operand2.GetX() - <br>        Operand1.GetX() * Operand2.GetZ(); <br>  real Z = Operand1.GetX() * Operand2.GetY() - <br>        Operand1.GetY() * Operand2.GetX(); <br> <br>  return vector_4(X,Y,Z); <br>} <br> <br>inline real DotProduct( vector_4 const &amp;Operand1, vector_4 const &amp;Operand2 ) <br>{ <br>  return Operand1.GetX() * Operand2.GetX() + <br>      Operand1.GetY() * Operand2.GetY() + <br>      Operand1.GetZ() * Operand2.GetZ(); <br>} <br> <br> <br>inline real quadruple::GetElement( int Row ) const <br>{ <br>  return aElements[Row]; <br>} <br> <br>inline real quadruple::GetX( void ) const <br>{ <br>  return aElements[0]; <br>} <br> <br>inline real quadruple::GetY( void ) const <br>{ <br>  return aElements[1]; <br>} <br> <br>inline real quadruple::GetZ( void ) const <br>{ <br>  return aElements[2]; <br>} <br> <br>inline real quadruple::GetW( void ) const <br>{ <br>  return aElements[3]; <br>} <br> <br>inline void quadruple::SetElement( int Row, real Value ) <br>{ <br>  aElements[Row] = Value; <br>} <br> <br>inline void quadruple::SetX( real Value ) <br>{ <br>  aElements[0] = Value; <br>} <br> <br>inline void quadruple::SetY( real Value ) <br>{ <br>  aElements[1] = Value; <br>} <br> <br>inline void quadruple::SetZ( real Value ) <br>{ <br>  aElements[2] = Value; <br>} <br> <br>inline void quadruple::SetW( real Value ) <br>{ <br>  aElements[3] = Value; <br>} <br> <br>inline void point_4::Homogenize( void ) <br>{ <br>  aElements[0] = aElements[0] / aElements[3]; <br>  aElements[1] = aElements[1] / aElements[3]; <br>  aElements[2] = aElements[2] / aElements[3]; <br>} <br> <br>inline quadruple::quadruple( void ) <br>{ <br>  aElements[0] = aElements[1] = aElements[2] = aElements[3] = 0; <br>} <br> <br>inline quadruple::quadruple( real X, real Y, real Z, real W ) <br>{ <br>  aElements[0] = X; <br>  aElements[1] = Y; <br>  aElements[2] = Z; <br>  aElements[3] = W; <br>} <br> <br>inline quadruple::quadruple( quadruple const &amp;Source ) <br>{ <br>  aElements[0] = Source.aElements[0]; <br>  aElements[1] = Source.aElements[1]; <br>  aElements[2] = Source.aElements[2]; <br>  aElements[3] = Source.aElements[3]; <br>} <br> <br>inline quadruple &amp;quadruple::operator=( quadruple const &amp;Source ) <br>{ <br>  aElements[0] = Source.aElements[0]; <br>  aElements[1] = Source.aElements[1]; <br>  aElements[2] = Source.aElements[2]; <br>  aElements[3] = Source.aElements[3]; <br> <br>  return *this; <br>} <br> <br>inline point_4::point_4( void ) : <br>  quadruple(0,0,0,1) <br>{ <br> <br>} <br> <br>inline point_4::point_4( real X, real Y, real Z ) : <br>  quadruple(X,Y,Z,1) <br>{ <br>#if 0 <br>  char aBuffer[100]; <br>  sprintf(aBuffer,"X: %f Y: %f Z: %f",X,Y,Z); <br>  MessageBox(0,aBuffer,"foobar",MB_OK); <br>  sprintf(aBuffer,"X: %f Y: %f Z: %f W:%f",aElements[0],aElements[1], <br>    aElements[2],aElements[3]); <br>  MessageBox(0,aBuffer,"foobar",MB_OK); <br>#endif <br>} <br> <br>inline vector_4::vector_4( void ) : <br>  quadruple(0,0,0,0) <br>{ <br> <br>} <br> <br>inline vector_4::vector_4( real X, real Y, real Z ) : <br>  quadruple(X,Y,Z,0) <br>{ <br> <br>} <br> <br>inline real matrix_4x4::GetElement( int Row, int Column ) const <br>{ <br>  return aElements[Row][Column]; <br>} <br> <br>inline matrix_4x4 &amp;matrix_4x4::SetElement( int Row, int Column, real Value ) <br>{ <br>  aElements[Row][Column] = Value; <br> <br>  return *this; <br>} <br> <br>inline matrix_4x4::matrix_4x4( do_not_initialize ) <br>{ <br> <br>} <br> <br>inline matrix_4x4 &amp; matrix_4x4::operator=(matrix_4x4 const &amp; m) <br>{ <br>    memcpy((void *) aElements, (void *) m.aElements,sizeof(aElements)); <br>    return *this; <br>} <br>#endif </code></pre>
<p>&nbsp;</p></body>
</HTML>
