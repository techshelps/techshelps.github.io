<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TRI.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3188"></a>TRI.CPP</h2>
<pre><code>/************************************************************************** <br> <br>    TRI.CPP - Simple triangle rasterizer <br> <br> **************************************************************************/ <br>/************************************************************************** <br> <br>    (C) Copyright 1995-1997 Microsoft Corp.  All rights reserved. <br> <br>    You have a royalty-free right to use, modify, reproduce and  <br>    distribute the Sample Files (and/or any modified version) in  <br>    any way you find useful, provided that you agree that  <br>    Microsoft has no warranty obligations or liability for any  <br>    Sample Application Files which are modified.  <br> <br> **************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include "Fixed.h" <br> <br>#define SWAP(x,y)   ((x)^=(y)^=(x)^=(y)) <br>//SWAP has a compiler generated problem on alpha.... do it the old fashioned way: <br>#define SWAPPT(a,b) {POINT p; p=a;a=b;b=p;} //(SWAP(a.y,b.y), SWAP(a.x,b.x)) <br> <br>/************************************************************************** <br> <br>    FillScan8 <br> <br>    fill a scan from x0 to x1 (inclusive) with color c <br> <br>    does optimal DWORD writes, making sure to stay aligned so <br>    it is safe for video memory. <br> <br> **************************************************************************/ <br>inline void FillScan8(BYTE *p, int x0, int x1, DWORD c) <br>{ <br>    int dx; <br>    int z; <br> <br>    dx = x1-x0+1; <br>    p += x0; <br> <br>    if (dx &gt; 4) <br>    { <br>        if (z = (DWORD)p &amp; 0x03) <br>        { <br>            while (z++ &lt; 4) <br>            { <br>                *p++ = (BYTE)c; <br>                dx--; <br>            } <br>        } <br> <br>        while (dx &gt;= 4) <br>        { <br>            *((DWORD*)p) = c; <br>            p += 4; <br>            dx -= 4; <br>        } <br>    } <br> <br>    while (dx-- &gt; 0) <br>    { <br>        *p++ = (BYTE)c; <br>    } <br>} <br> <br>/************************************************************************** <br> <br>    Triangle8 <br> <br>    rasterize a solid color triangle into a 8bpp memory buffer. <br> <br>    NOTE this code does no clipping you better pass <br> <br>    rasterizes a solid color triangle into a memory buffer with any pitch <br>    also is careful to always write DWORD aligned, so it is safe to be <br>    used on video memory (and faster too...) <br> <br> **************************************************************************/ <br> <br>void Triangle8(BYTE *p, int next_scan, POINT P0, POINT P1, POINT P2, DWORD c) <br>{ <br>    Fixed   d,d0; <br>    Fixed   x,x0; <br>    int     y; <br> <br>    // <br>    // expand the color to a DWORD <br>    // <br>    c |= c&lt;&lt;8; <br>    c |= c&lt;&lt;16; <br> <br>    // <br>    //  sort points so P0.y &lt;= P1.y &lt;= P2.y <br>    // <br>    if (P0.y &gt; P1.y) SWAPPT(P0,P1); <br>    if (P1.y &gt; P2.y) SWAPPT(P1,P2); <br>    if (P0.y &gt; P1.y) SWAPPT(P0,P1); <br> <br>    // <br>    //  check for quick out? <br>    // <br>    if (P2.y - P0.y == 0) <br>    { <br>        return; <br>    } <br> <br>    // <br>    //  compute "long" side walk from P0 to P2 <br>    // <br>    d = (Fixed)(P2.x - P0.x) / (Fixed)(P2.y - P0.y); <br> <br>    x  = P0.x; <br>    y  = P0.y; <br>    p += P0.y * next_scan;   // point p to correct scan. <br> <br>    // <br>    //  do the top <br>    // <br>    if (P0.y &lt; P1.y) <br>    { <br>        d0 = (Fixed)(P1.x - P0.x) / (Fixed)(P1.y - P0.y); <br>        x0 = P0.x; <br> <br>        // <br>        // check for left or right fill <br>        // <br>        if (d &lt; d0) <br>        { <br>            while (y &lt; P1.y) <br>            { <br>                FillScan8(p, x, x0, c); <br>                y++; <br>                p  += next_scan; <br>                x  += d; <br>                x0 += d0; <br>            } <br>        } <br>        else <br>        { <br>            while (y &lt; P1.y) <br>            { <br>                FillScan8(p, x0, x, c); <br>                y++; <br>                p  += next_scan; <br>                x  += d; <br>                x0 += d0; <br>            } <br>        } <br>    } <br> <br>    // <br>    // do the bottom. <br>    // <br>     <br>    if (P2.y - P1.y == 0) <br>    { <br>        return; <br>    } <br> <br>    d0 = (Fixed)(P2.x - P1.x) / (Fixed)(P2.y - P1.y); <br>    x0 = P1.x; <br> <br>    // <br>    // check for left or right fill <br>    // <br>    if (x &lt; x0) <br>    { <br>        while (y &lt; P2.y) <br>        { <br>            FillScan8(p, x, x0, c); <br>            y++; <br>            p  += next_scan; <br>            x  += d; <br>            x0 += d0; <br>        } <br>    } <br>    else <br>    { <br>        while (y &lt; P2.y) <br>        { <br>            FillScan8(p, x0, x, c); <br>            y++; <br>            p  += next_scan; <br>            x  += d; <br>            x0 += d0; <br>        } <br>    } <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
