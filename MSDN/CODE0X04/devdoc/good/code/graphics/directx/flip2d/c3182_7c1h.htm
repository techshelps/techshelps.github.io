<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FLIPCUBE.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3185"></a>FLIPCUBE.CPP</h2>
<pre><code>/************************************************************************** <br> <br>    FLIPCUBE.CPP - A spinning cube demo for DirectDraw <br> <br>    basic page fliping app, just render to the back buffer and flip <br>    that is all I do. <br> <br> **************************************************************************/ <br>/************************************************************************** <br> <br>    (C) Copyright 1995-1997 Microsoft Corp.  All rights reserved. <br> <br>    You have a royalty-free right to use, modify, reproduce and <br>    distribute the Sample Files (and/or any modified version) in <br>    any way you find useful, provided that you agree that <br>    Microsoft has no warranty obligations or liability for any <br>    Sample Application Files which are modified. <br> <br> **************************************************************************/ <br> <br>#define INITGUID <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include &lt;ddraw.h&gt; <br>#include &lt;dinput.h&gt; <br>#include &lt;math.h&gt; <br> <br>#include "flipcube.h" <br>#include "dumb3d.h" <br> <br>// code is in tri.cpp <br>extern void Triangle8(BYTE *p, int next_scan, POINT P0, POINT P1, POINT P2, DWORD c); <br> <br>/************************************************************************** <br>  Global Variables <br> **************************************************************************/ <br> <br>static char szAppName[]="DirectDraw Spinning Cube"; <br> <br>static HINSTANCE  hInstApp; <br>static BOOL       fAppActive; <br>static BOOL       fAppPaused; <br>static HWND       hwndApp; <br>static HACCEL     hAccelApp; <br>static HFONT      AppFont; <br>static SIZE       ScreenSize; <br>static BOOL       fDrawWithGDI; <br> <br>/************************************************************************** <br>  DirectDraw Globals <br> **************************************************************************/ <br> <br>IDirectDraw            *dd; <br>IDirectDrawSurface     *FrontBuffer; <br>IDirectDrawSurface     *BackBuffer; <br>IDirectDrawPalette     *Palette; <br> <br>/************************************************************************** <br>  DirectInput Globals <br> **************************************************************************/ <br>LPDIRECTINPUTlpdi; <br>LPDIRECTINPUTDEVICE             lpdiZoom;       // Used for zooming <br>LPDIRECTINPUTDEVICE             lpdiRot;        // Use for rotation <br>BOOL                            fMouseAcquired = FALSE; // Acquired for rot'n <br> <br>/************************************************************************** <br>  dumb 3D Globals <br> **************************************************************************/ <br> <br>//*** Cube vertices, normals, shades, and modeling transform <br>static point_4 CubeVertices[8] = <br>{ <br>  point_4( -10,  10, -10 ), <br>  point_4( -10,  10,  10 ), <br>  point_4(  10,  10,  10 ), <br>  point_4(  10,  10, -10 ), <br>  point_4(  10, -10, -10 ), <br>  point_4(  10, -10,  10 ), <br>  point_4( -10, -10,  10 ), <br>  point_4( -10, -10, -10 ) <br>}; <br>static vector_4   CubeSurfaceNormals[6]; <br>static real       CubeSurfaceShades[6]; <br>static matrix_4x4 CubeTransform; <br> <br>//*** Cube edges - ordered indices into the vertex array <br>const int CubeFaces[6][4] = <br>{ <br>  0, 1, 2, 3, <br>  2, 1, 6, 5, <br>  3, 2, 5, 4, <br>  0, 3, 4, 7, <br>  1, 0, 7, 6, <br>  4, 5, 6, 7 <br>}; <br> <br>//*** Cube colors - one RGB color per surface <br>const unsigned char CubeColors[6][3] = <br>{ <br>  240,  20,  20,    // Unsaturated Red <br>   20, 240,  20,    // Unsaturated Green <br>   20,  20, 240,    // Unsaturated Blue <br>  128,  64,   0,    // Brown <br>  240,  20, 240,    // Unsaturated Magenta <br>  240, 240,  20     // Unsaturated Yellow <br>}; <br> <br>//*** Lighting <br>vector_4   LightSourceDirection; <br>const real AmbientLight = 0.2; <br> <br>//*** Viewing and perspective <br>static matrix_4x4  ViewPerspective; <br>static point_4     Viewpoint(60, 60, 60); <br>static vector_4    Up(0, 1, 0); <br>static point_4     Origin; <br> <br>/************************************************************************** <br>   Internal function declarations <br> **************************************************************************/ <br> <br>LONG  CALLBACK AppWndProc(HWND hwnd,UINT msg,WPARAM wParam,LPARAM lParam); <br>BOOL  InitDInput(void); <br>BOOL  AppIdle(void); <br>void  RenderFrame(void); <br> <br>void  TransformCube(matrix_4x4 const &amp;Transform); <br>BOOL  ProjectAndDrawCube(HDC hdc, int XOffset, int YOffset); <br>BOOL  ProjectAndDrawCube(IDirectDrawSurface *pdds, int XOffset, int YOffset); <br> <br>/************************************************************************** <br>  AppAbout <br> <br>  Description: <br>    This function handles messages belonging to the "About" dialog box. <br>  The only message that it looks for is WM_COMMAND, indicating the user <br>  has pressed the "OK" button. <br> **************************************************************************/ <br> <br>BOOL FAR PASCAL AppAbout(HWND hwnd,UINT msg,WPARAM wParam,LPARAM lParam) <br>{ <br>  switch (msg) <br>  { <br>    case WM_COMMAND: <br>      if (LOWORD(wParam) == IDOK) <br>        EndDialog(hwnd, TRUE); <br>      break; <br> <br>    case WM_INITDIALOG: <br>      return TRUE; <br>  } <br>  return FALSE; <br>} <br> <br>/************************************************************************** <br>  DDInit <br> <br>  Description: <br>    initialize all the DirectDraw specific stuff <br> **************************************************************************/ <br> <br>BOOL DDInit() <br>{ <br>    HRESULT err; <br> <br>    err = DirectDrawCreate(NULL, &amp;dd, NULL); <br> <br>    if (err != DD_OK) <br>        return FALSE; <br> <br>    err = dd-&gt;SetCooperativeLevel(hwndApp, <br>        DDSCL_EXCLUSIVE | DDSCL_FULLSCREEN | DDSCL_ALLOWMODEX); <br> <br>    if (err != DD_OK) <br>        return FALSE; <br> <br>// NEWNEW init DirectInput iff DDraw inits ok <br>if(!InitDInput()) <br>return FALSE; <br> <br>    return TRUE; <br>} <br> <br>/************************************************************************** <br>  CreateMouse <br> **************************************************************************/ <br> <br>BOOL CreateMouse(GUID &amp;guid, LPDIRECTINPUTDEVICE&amp; lpdiMouse, DWORD dwAccess) <br>{ <br>    HRESULT err; <br> <br>    err = lpdi-&gt;CreateDevice(guid, &amp;lpdiMouse, NULL); <br> <br>    if(err != DI_OK) <br>    { <br>            MessageBox(NULL, "Unable to Create DirectInput Mouse Device", <br>                    "DirectDraw Spinning Cube", MB_OK); <br>            goto fail; <br>    } <br> <br>    // Tell DirectInput that we want to receive data in mouse format <br>    err = lpdiMouse-&gt;SetDataFormat(&amp;c_dfDIMouse); <br> <br>    if(err != DI_OK) <br>    { <br>            MessageBox(NULL, "Unable to Access DirectInput Device as a mouse", <br>                    "DirectDraw Spinning Cube", MB_OK); <br>            goto fail; <br>    } <br> <br>    // set desired access mode <br>    err = lpdiMouse-&gt;SetCooperativeLevel(hwndApp, dwAccess); <br>    if(err != DI_OK) <br>    { <br>        // Don't complain if asking for DISCL_NONEXCLUSIVE since <br>        // not all systems support it.  (The caller will gracefully <br>        // degrade.) <br>        if (dwAccess &amp; DISCL_EXCLUSIVE) { <br>            MessageBox(NULL, "Unable to set cooperativity level", <br>                    "DirectDraw Spinning Cube", MB_OK); <br>        } <br>        goto fail; <br>    } <br> <br>    return TRUE; <br> <br>fail:; <br>    if (lpdiMouse)      lpdiMouse-&gt;Release(),       lpdiMouse = 0; <br>    return FALSE; <br>} <br> <br>/************************************************************************** <br>  InitDInput <br> **************************************************************************/ <br>BOOL InitDInput(void) <br>{ <br>HRESULTerr; <br>GUID     guid = GUID_SysMouse; <br>    // Need DirectX 3 or better <br>    err = DirectInputCreate(hInstApp, 0x0300, &amp;lpdi, NULL); <br> <br>if(err != DI_OK) <br>{ <br>MessageBox(NULL, "Unable to Create DirectInput Object", <br>"DirectDraw Spinning Cube", MB_OK); <br>return FALSE; <br>} <br> <br>        // Create a mouse for zooming.  Zooming is done non-exclusively. <br>        if (!CreateMouse(guid, lpdiZoom, DISCL_NONEXCLUSIVE | DISCL_FOREGROUND)) <br>        { <br>                /* Note!  This is not a fatal error */ <br>        } else { <br> <br>            if (fAppActive) lpdiZoom-&gt;Acquire(); <br> <br>        } <br> <br>        // Create a mouse for rotation.  Rotation is done exclusively. <br>        if (!CreateMouse(guid, lpdiRot, DISCL_EXCLUSIVE | DISCL_FOREGROUND)) <br>        { <br>                goto fail; <br>        } <br> <br>        // if we get here, all DirectInput objects were created ok <br>return TRUE; <br> <br>fail: <br>        if (lpdiZoom)  lpdiZoom-&gt;Release(), lpdiZoom = NULL; <br>        if (lpdiRot)   lpdiRot -&gt;Release(), lpdiRot  = NULL; <br>        if (lpdi)      lpdi    -&gt;Release(), lpdi     = NULL; <br>        return FALSE; <br> <br>} <br> <br> <br>/************************************************************************** <br>  DDSetMode <br> **************************************************************************/ <br> <br>BOOL DDSetMode(int width, int height, int bpp) <br>{ <br>    HRESULT err; <br> <br>    err = dd-&gt;SetDisplayMode(width, height, bpp); <br> <br>    if (err != DD_OK) <br>        return FALSE; <br> <br>    ScreenSize.cx = width; <br>    ScreenSize.cy = height; <br> <br>    // get rid of any previous surfaces. <br>    if (BackBuffer)  BackBuffer-&gt;Release(),     BackBuffer = NULL; <br>    if (FrontBuffer) FrontBuffer-&gt;Release(),    FrontBuffer = NULL; <br>    if (Palette)     Palette-&gt;Release(),        Palette = NULL; <br> <br>    // <br>    // Create surfaces <br>    // <br>    // what we want is a tripple buffered surface in video memory <br>    // so we try to create this first. <br>    // <br>    // if we cant get a triple buffered surface, we try again <br>    // for a double buffered surface (still must be in video memory) <br>    // <br>    // if we cant get a double buffered surface, we try for a double <br>    // buffered surface not being specific about video memory, we will <br>    // get back a main-memory surface, that work use HW page flipping <br>    // but at least we run. <br>    // <br>    // NOTE you need to recreate the surfaces for a new display mode <br>    // they wont work when/if the mode is changed. <br>    // <br>    DDSURFACEDESC ddsd; <br> <br>    ZeroMemory(&amp;ddsd, sizeof(ddsd)); <br>    ddsd.dwSize = sizeof(ddsd); <br>    ddsd.dwFlags = DDSD_CAPS | DDSD_BACKBUFFERCOUNT; <br>    ddsd.dwBackBufferCount = 2; <br>    ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE | <br>                          DDSCAPS_FLIP | <br>                          DDSCAPS_COMPLEX | <br>                          DDSCAPS_VIDEOMEMORY; <br> <br>    // try to get a triple buffered video memory surface. <br>    err = dd-&gt;CreateSurface(&amp;ddsd, &amp;FrontBuffer, NULL); <br> <br>    if (err != DD_OK) <br>    { <br>        // try to get a double buffered video memory surface. <br>        ddsd.dwBackBufferCount = 1; <br>        err = dd-&gt;CreateSurface(&amp;ddsd, &amp;FrontBuffer, NULL); <br>    } <br> <br>    if (err != DD_OK) <br>    { <br>        // settle for a main memory surface. <br>        ddsd.ddsCaps.dwCaps &amp;= ~DDSCAPS_VIDEOMEMORY; <br>        err = dd-&gt;CreateSurface(&amp;ddsd, &amp;FrontBuffer, NULL); <br>    } <br> <br>    if (err != DD_OK) <br>        return FALSE; <br> <br>    // get a pointer to the back buffer <br>    DDSCAPS caps; <br>    caps.dwCaps = DDSCAPS_BACKBUFFER; <br>    err = FrontBuffer-&gt;GetAttachedSurface(&amp;caps, &amp;BackBuffer); <br> <br>    if (err != DD_OK) <br>        return FALSE; <br> <br>    // create a palette if we are in a paletized display mode. <br>    // <br>    // NOTE because we want to be able to show dialog boxs and <br>    // use our menu, we leave the windows reserved colors as is <br>    // so things dont look ugly. <br>    // <br>    // palette is setup like so: <br>    // <br>    //      10      windows system colors <br>    //      64      red wash <br>    //      64      grn wash <br>    //      64      blu wash <br>    // <br>    PALETTEENTRY ape[256]; <br>    HDC hdc = GetDC(NULL); <br>    if (GetDeviceCaps(hdc, RASTERCAPS) &amp; RC_PALETTE) <br>    { <br>        // get the current windows colors. <br>        GetSystemPaletteEntries(hdc, 0, 256, ape); <br> <br>        // make a red, grn, and blu wash for our cube. <br>        for (int i=0; i&lt;64; i++) <br>        { <br>            ape[10+64*0+i].peRed   = i * 255/63; <br>            ape[10+64*0+i].peGreen = 0; <br>            ape[10+64*0+i].peBlue  = 0; <br> <br>            ape[10+64*1+i].peRed   = 0; <br>            ape[10+64*1+i].peGreen = i * 255/63; <br>            ape[10+64*1+i].peBlue  = 0; <br> <br>            ape[10+64*2+i].peRed   = 0; <br>            ape[10+64*2+i].peGreen = 0; <br>            ape[10+64*2+i].peBlue  = i * 255/63; <br>        } <br> <br>        // create the palette. <br>        err = dd-&gt;CreatePalette(DDPCAPS_8BIT, ape, &amp;Palette, NULL); <br> <br>        if (err == DD_OK) <br>        { <br>            FrontBuffer-&gt;SetPalette(Palette); <br>        } <br>    } <br>    ReleaseDC(NULL, hdc); <br> <br>    if (AppFont) <br>        DeleteObject(AppFont); <br> <br>    AppFont = CreateFont(width &lt; 640 ? 24 : 48, <br>        0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE, <br>        ANSI_CHARSET, <br>        OUT_DEFAULT_PRECIS, <br>        CLIP_DEFAULT_PRECIS, <br>        NONANTIALIASED_QUALITY, <br>        VARIABLE_PITCH, <br>        "Comic Sans MS"); <br> <br>    return TRUE; <br>} <br> <br> <br>/************************************************************************** <br>  DDTerm <br> **************************************************************************/ <br> <br>void DDTerm() <br>{ <br>    if (BackBuffer)  BackBuffer-&gt;Release(),     BackBuffer = NULL; <br>    if (FrontBuffer) FrontBuffer-&gt;Release(),    FrontBuffer = NULL; <br>    if (Palette)     Palette-&gt;Release(),        Palette = NULL; <br>    if (dd)          dd-&gt;Release(),             dd = NULL; <br>    if (lpdi)        lpdi-&gt;Release(),           lpdi = NULL; <br>} <br> <br>/************************************************************************** <br>  ModeCallback <br> **************************************************************************/ <br> <br>#define MAKEMENUITEMDATA(width, height, bpp) \ <br>        (width) | ((height) &lt;&lt; 12) | ((bpp) &lt;&lt; 24) <br> <br>HRESULT CALLBACK ModeCallback(LPDDSURFACEDESC pdds, LPVOID lParam) <br>{ <br>    HMENU hmenu = (HMENU)lParam; <br>    char ach[80]; <br>    int n; <br>    int width  = pdds-&gt;dwWidth; <br>    int height = pdds-&gt;dwHeight; <br>    int bpp    = pdds-&gt;ddpfPixelFormat.dwRGBBitCount; <br> <br>    n = GetMenuItemCount(hmenu); <br>    wsprintf(ach,"%dx%dx%d",width,height,bpp); <br>    AppendMenu(hmenu,MF_STRING,MENU_MODE+n,ach); <br> <br>    MENUITEMINFO mii; <br> <br>    // pack the mode info into a DWORD and set the extra item data. <br>    mii.cbSize = sizeof(mii); <br>    mii.fMask = MIIM_DATA; <br>    mii.dwItemData = MAKEMENUITEMDATA(width, height, bpp); <br>    SetMenuItemInfo(hmenu, MENU_MODE+n, MF_BYCOMMAND, &amp;mii); <br> <br>    //return S_TRUE to stop enuming modes, S_FALSE to continue <br>    return S_FALSE; <br>} <br> <br>/************************************************************************** <br>  AppInit <br> <br>  Description: <br>    This is called when the application is first loaded. It initializes <br>  all variables, registers the window class, and creates the main app <br>  window. <br> **************************************************************************/ <br> <br>BOOL AppInit(HINSTANCE hInst,HINSTANCE hPrev,int sw,LPSTR szCmdLine) <br>{ <br>  WNDCLASS cls; <br> <br>  /* Save instance handle for DialogBoxes */ <br>  hInstApp = hInst; <br> <br>  if (!hPrev) <br>  { <br>    //***  Register a class for the main application window <br>    cls.hCursor        = LoadCursor(0,IDC_ARROW); <br> <br>    //*** Just for fun, we'll draw our own spinning cube icon. <br>    cls.hIcon          = LoadIcon(hInst, "AppIcon"); <br>    cls.lpszMenuName   = "AppMenu"; <br>    cls.lpszClassName  = szAppName; <br>    cls.hbrBackground  = (HBRUSH)GetStockObject(BLACK_BRUSH); <br>    cls.hInstance      = hInst; <br>    cls.style          = CS_VREDRAW | CS_HREDRAW; <br>    cls.lpfnWndProc    = (WNDPROC)AppWndProc; <br>    cls.cbClsExtra     = 0; <br>    cls.cbWndExtra     = 0; <br> <br>    if (!RegisterClass(&amp;cls)) <br>      return FALSE; <br>  } <br> <br>  hAccelApp = LoadAccelerators(hInst, "AppAccel"); <br> <br>  //*** Set and normalize the light source <br>  LightSourceDirection = vector_4(50, 30, -15); <br>  LightSourceDirection.Normalize(); <br> <br>  //*** Distance to view plane: <br>  ViewPerspective.SetElement(3, 2, 1/300.0); <br>  ViewPerspective.SetElement(3, 3, 0); <br> <br>  //*** Viewport scaling - some arbitrary number like 3.5 will do <br>  ViewPerspective.SetElement(0, 0, 3.5); <br>  ViewPerspective.SetElement(1, 1, 3.5); <br> <br>  //*** Calculate the initial normals and shades <br>  TransformCube(CubeTransform); <br> <br>  //*** Then generate an interesting rotation for the spin <br>  CubeTransform.ConcatenateYRotation(6.0); <br>  CubeTransform.ConcatenateXRotation(3.5); <br>  CubeTransform.ConcatenateZRotation(2.0); <br> <br>  hwndApp = CreateWindowEx( <br>                  WS_EX_APPWINDOW, <br>                  szAppName,           // Class name <br>                  szAppName,           // Caption <br>                  WS_POPUP | <br>                  WS_SYSMENU | <br>                  WS_CAPTION, <br>  0, 0,        // Position <br>  640,480,       // Size <br>                  0,                   // Parent window (no parent) <br>                  0,                   // use class menu <br>                  hInst,               // handle to window instance <br>                  0                    // no params to pass on <br>                  ); <br>  ShowWindow(hwndApp,sw); <br>  UpdateWindow(hwndApp); <br> <br>  if (!DDInit()) <br>    return FALSE; <br> <br>  // Enumerate all posible display modes, and stick them in our menu. <br>  // we use the extra item DWORD of a menu item to store the mode info <br>  HMENU hmenu = CreatePopupMenu(); <br>  dd-&gt;EnumDisplayModes(0,NULL,(LPVOID)hmenu,ModeCallback); <br>  AppendMenu(GetMenu(hwndApp),MF_POPUP,(UINT)hmenu,"&amp;Modes"); <br> <br>  if (!DDSetMode(640,480,8) &amp;&amp; <br>      !DDSetMode(640,480,16)) <br>    return FALSE; <br> <br>  return TRUE; <br>} <br> <br>/************************************************************************** <br>  WinMain <br> <br>  Description: <br>    The main procedure for the App.  After initializing, it just goes <br>  into a message-processing loop until it gets a WM_QUIT message. <br> **************************************************************************/ <br> <br>int PASCAL WinMain(HINSTANCE hInst, HINSTANCE hPrev, LPSTR szCmdLine, int sw) <br>{ <br>  MSG     msg; <br> <br>  //*** Call initialization procedure <br>  if (!AppInit(hInst,hPrev,sw,szCmdLine)) <br>    return FALSE; <br> <br>    //*** Polling messages from event queue until quit <br>  for (;;) <br>  { <br>    if (PeekMessage(&amp;msg, 0, 0, 0, PM_REMOVE)) <br>    { <br>      if (msg.message == WM_QUIT) <br>        break; <br> <br>      if (!hwndApp || !TranslateAccelerator(hwndApp, hAccelApp, &amp;msg)) <br>      { <br>        TranslateMessage(&amp;msg); <br>        DispatchMessage(&amp;msg); <br>      } <br>    } <br>    else <br>    { <br>      if (AppIdle()) <br>        WaitMessage(); <br>    } <br>  } <br> <br>  DDTerm(); <br>  return msg.wParam; <br>} <br> <br>/************************************************************************** <br>  AppPause <br> <br> **************************************************************************/ <br> <br>void AppPause(BOOL f) <br>{ <br>    if (f) <br>    { <br>        DDSCAPS caps; <br>        FrontBuffer-&gt;GetCaps(&amp;caps); <br> <br>        // if we are in ModeX go back to a windows mode <br>        // so we can see the menu or dialog box. <br> <br>        if (caps.dwCaps &amp; DDSCAPS_MODEX) <br>        { <br>            DDSetMode(640,480,8); <br>        } <br> <br>        // turn off rotation while paused <br>        if (lpdiRot) lpdiRot-&gt;Unacquire(); <br>        fMouseAcquired = FALSE; <br> <br>        fAppPaused = TRUE; <br>        dd-&gt;FlipToGDISurface(); <br>        DrawMenuBar(hwndApp); <br>        RedrawWindow(hwndApp, NULL, NULL, RDW_FRAME); <br>    } <br>    else <br>    { <br>        fAppPaused = FALSE; <br> <br>    } <br>} <br> <br>/************************************************************************** <br>  MagnifyCube <br> <br>  Description: <br>    Magnify the cube the indicated number of times.  A negative number <br>    makes it smaller. <br> **************************************************************************/ <br> <br>void MagnifyCube(double times) <br>{ <br>    matrix_4x4 m; <br>    double factor = pow(1.5, times); <br>    m.SetElement(0,0,factor); <br>    m.SetElement(1,1,factor); <br>    m.SetElement(2,2,factor); <br>    TransformCube(m); <br>} <br> <br>/************************************************************************** <br>  AppIdle <br> <br>  return TRUE if the app is idle <br>  return FALSE if the app is not idle. <br> <br>  Description: <br> **************************************************************************/ <br> <br>BOOL AppIdle() <br>{ <br>  DIMOUSESTATE dims; <br> <br>  //*** Spin while the app is active, lbutton is up, and spinning is on. <br> <br>  //*** Spin while the app is iconized. <br>  if (fAppActive &amp;&amp; !fAppPaused) <br>  { <br>    //*** If the app is active, spin the cube and redraw <br> <br>    // See if any zooming needs to be done. <br>    if(lpdiZoom &amp;&amp; <br>       lpdiZoom-&gt;GetDeviceState(sizeof(DIMOUSESTATE), &amp;dims) == DI_OK) { <br>        // 240 units of motion in the Z-axis equals one unit of <br>        // magnification / shrinkage. <br>        if(dims.lZ) { <br>           MagnifyCube(dims.lZ / 240.0); <br>        } <br>    } <br> <br>    if(fMouseAcquired) <br> { <br>//** If we have the mouse acquired... <br> <br>// user spins cube if GetDeviceState succeeds and if the left button (button 0) is held <br>                if(lpdiRot-&gt;GetDeviceState(sizeof(DIMOUSESTATE), &amp;dims) == DI_OK) <br>{ <br>         if(dims.rgbButtons[0] &amp; 0x80) <br>         { <br>            if(dims.lX || dims.lY) <br>            { <br>               matrix_4x4 Movement; <br>               Movement.ConcatenateYRotation(dims.lX); <br>               Movement.ConcatenateXRotation(dims.lY); <br>               TransformCube(Movement); <br>            } <br> <br>         } <br>         else <br>   { <br>   // unacquire the mouse <br>                           lpdiRot-&gt;Unacquire(); <br>   fMouseAcquired = FALSE; <br>   } <br>      } <br>    } <br>    else <br>    { <br>         TransformCube(CubeTransform); <br>    } <br>    RenderFrame(); <br>    return FALSE; <br>  } <br>  else <br>  { <br>    //*** Don't do anything when not the active app <br>    return TRUE; <br>  } <br>} <br> <br>/************************************************************************** <br>  RenderFrame <br> <br>  render the frame into the back buffer and do a page flip. <br> <br>  things to NOTE: <br> <br>    we use the blter to clear the backbuffer, this usualy is a big <br>    win blters are real fast. <br> <br>    we use GDI to draw the frame rate, and info text <br> <br>    we either use GDI to draw the faces of the cube, or our own code <br>    based on the fDrawWithGDI global variable. <br> <br> **************************************************************************/ <br> <br>int FrameRate; <br>int FrameCount; <br>int FrameCount0; <br>DWORD FrameTime; <br>DWORD FrameTime0; <br> <br>void RenderFrame() <br>{ <br>  HDC hdc; <br> <br>  //*** always need to handle DDERR_SURFACELOST, this will happen <br>  //*** when we get switched away from. <br> <br>  if (FrontBuffer-&gt;IsLost() == DDERR_SURFACELOST) <br>    FrontBuffer-&gt;Restore(); <br> <br>  //*** use the blter to do a color fill to clear the back buffer <br> <br>  DDBLTFX ddbltfx; <br>  ddbltfx.dwSize = sizeof(ddbltfx); <br>  ddbltfx.dwFillColor = 0; <br>  BackBuffer-&gt;Blt(NULL,NULL,NULL,DDBLT_COLORFILL | DDBLT_WAIT,&amp;ddbltfx); <br> <br>  //*** based on the fDrawWithGDI global variable, we either <br>  //*** render the polygons ourself or let GDI do it <br> <br>  BOOL fGDI = fDrawWithGDI; <br> <br>  //*** render the cube with our own code. <br>  //*** we need to do this outside of the GetDC, because we cant <br>  //*** lock a buffer while we have a DC on it. <br>  //*** if ProjectAndDrawCube returns FALSE it did not want to <br>  //*** draw for some reason, so go ahead and use GDI <br> <br>  if (!fGDI) <br>     fGDI = !ProjectAndDrawCube(BackBuffer, ScreenSize.cx/2, ScreenSize.cy/2); <br> <br>  if (BackBuffer-&gt;GetDC(&amp;hdc) == DD_OK) <br>  { <br>    //*** use GDI to draw the cube. <br>    if (fGDI) <br>      ProjectAndDrawCube(hdc, ScreenSize.cx/2, ScreenSize.cy/2); <br> <br>    //*** draw stats, like frame number and frame rate <br> <br>    char ach[128]; <br>    int len; <br>    static char szHelp[] = "F10=Menu F7=Smaller F8=Larger"; <br> <br>    SetBkMode(hdc, TRANSPARENT); <br>    SelectObject(hdc, AppFont); <br> <br>    len = wsprintf(ach, "FPS %02d Frame %05d", FrameRate, FrameCount); <br> <br>    SetTextColor(hdc, RGB(255, 255, 0)); <br>    TextOut(hdc, 0, 0, ach, len); <br>    TextOut(hdc, 0, ScreenSize.cy-(ScreenSize.cx&lt;640 ? 24:48),szHelp,sizeof(szHelp)-1); <br> <br>    BackBuffer-&gt;ReleaseDC(hdc); <br>  } <br> <br>  //*** we have rendered the backbuffer, call flip so we can see it <br>  FrontBuffer-&gt;Flip(NULL, DDFLIP_WAIT); <br> <br>  FrameCount++; <br>  FrameTime = timeGetTime(); <br> <br>  if (FrameTime - FrameTime0 &gt; 1000) <br>  { <br>    FrameRate = (FrameCount - FrameCount0) * 1000 / (FrameTime - FrameTime0); <br>    FrameTime0 = FrameTime; <br>    FrameCount0 = FrameCount; <br>  } <br>} <br> <br>/************************************************************************** <br>  AppInitMenuPopup <br> <br>    If it's the Cube menu, then check or uncheck the GDI item accordingly. <br> <br>    If it's the mode list popup, then add a MENUBARBREAK as necessary. <br> <br> **************************************************************************/ <br> <br>void AppInitMenuPopup(HWND hwnd, HMENU hmenuPopup, UINT uPos, BOOL fSys) <br>{ <br>    if (fSys) return;       /* Don't mess with the sysmenu */ <br> <br>    switch (uPos) { <br>    case 0:                 /* Cube menu */ <br>        CheckMenuItem(hmenuPopup, MENU_GDI, <br>                      fDrawWithGDI ? MF_CHECKED : MF_UNCHECKED); <br>        break; <br> <br>    case 1:                 /* Mode menu */ <br>        /* <br>         *  Compute how many menu items fit on the screen. <br>         * <br>         *  Note that we use ScreenSize instead of SM_CYSCREEN. <br>         *  This allows us to do the right thing in the face of <br>         *  multiple monitors.  (ScreenSize is the size of our <br>         *  monitor.) <br>         */ <br>        int cmi; <br> <br>        cmi = GetMenuItemCount(hmenuPopup); <br>        if (cmi) { <br> <br>            RECT rcClient; <br>            GetClientRect(hwnd, &amp;rcClient); <br> <br>            RECT rc; <br>            GetMenuItemRect(hwnd, hmenuPopup, 0, &amp;rc); <br> <br>            int dyMenuItem = rc.bottom - rc.top; <br> <br>            /* <br>             *  Aargh.  If the menu has never appeared yet, USER <br>             *  returns an empty rectangle.  DON'T DIVIDE BY ZERO! <br>             * <br>             *  In such case, we use the height of the menu bar. <br>             *  Not perfect, but close enough.  And it happens only <br>             *  once. <br>             */ <br>            if (dyMenuItem == 0) { <br>                dyMenuItem = GetSystemMetrics(SM_CYMENU); <br>            } <br> <br>            /* <br>             *  Aargh.  You can't change MF_MENUBARBREAK without <br>             *  also changing the text, so we have to get the <br>             *  old text and set it back. <br>             * <br>             *  While we're here, we may as well put a check-box <br>             *  next to the item that matches our current screen res. <br>             */ <br> <br>            HDC hdc = GetDC(0); <br> <br>            DWORD dwItemDataMatch = MAKEMENUITEMDATA( <br>                            GetDeviceCaps(hdc, HORZRES), <br>                            GetDeviceCaps(hdc, VERTRES), <br>                            GetDeviceCaps(hdc, BITSPIXEL) * <br>                            GetDeviceCaps(hdc, PLANES)); <br>            ReleaseDC(0, hdc); <br> <br> <br>            MENUITEMINFO mii; <br>            TCHAR tsz[80]; <br> <br>            mii.cbSize = sizeof(mii); <br>            mii.fMask = MIIM_TYPE | MIIM_DATA | MIIM_STATE; <br>            mii.dwTypeData = tsz; <br> <br>            /* <br>             *  Compute the number of MI's that fit in our client area. <br>             *  Note: Client area, not screen size.  This ensures that <br>             *  the menu pops in a reasonable location. <br>             */ <br> <br>            int cmiScreen = rcClient.bottom / dyMenuItem; <br> BOOL bModeMatch = FALSE; <br>            for (int imi = 0; imi &lt; cmi; imi++) { <br>                mii.cch = sizeof(tsz) / sizeof(tsz[0]); <br>                if (GetMenuItemInfo(hmenuPopup, imi, MF_BYPOSITION, &amp;mii)) { <br>                    if (imi &gt; 0 &amp;&amp; imi % cmiScreen == 0) { <br>                        mii.fType |= MFT_MENUBARBREAK; <br>                    } else { <br>                        mii.fType &amp;= ~MFT_MENUBARBREAK; <br>                    } <br> <br>                    if (mii.dwItemData == dwItemDataMatch) { <br>                        mii.fState |= MFS_CHECKED; <br>bModeMatch = TRUE; <br>                    } else { <br>                        mii.fState &amp;= ~MFS_CHECKED; <br>                    } <br> <br>                    SetMenuItemInfo(hmenuPopup, imi, MF_BYPOSITION, &amp;mii); <br>                } <br>            } <br>if(bModeMatch == FALSE) _asm int 3 <br> <br>        } <br>        break; <br>    } <br> <br>} <br> <br>/************************************************************************** <br>  AppWndProc <br> <br>  Description: <br>    Main window proc. Standard Windows fare. <br> **************************************************************************/ <br> <br>LONG CALLBACK AppWndProc(HWND hwnd,UINT msg,WPARAM wParam,LPARAM lParam) <br>{ <br>  RECT Rect; <br> <br>  switch (msg) <br>  { <br>    case WM_CREATE: <br>      break; <br> <br>    case WM_ACTIVATEAPP: <br>      //*** Keep track of whether or not the app is in the foreground <br>      fAppActive = (BOOL)wParam; <br>          // re-acquire the zooming controller when we are activated <br>          if (fAppActive) { <br>                if (lpdiZoom) lpdiZoom-&gt;Acquire(); <br>          } else{           // unacquire everything if app is not active <br>                if (lpdiZoom) lpdiZoom-&gt;Unacquire(); <br>                if (lpdiRot) lpdiRot-&gt;Unacquire(); <br>fMouseAcquired = FALSE; <br>  } <br>      break; <br> <br>    case WM_SETCURSOR: <br>      if (fAppActive &amp;&amp; !fAppPaused) <br>      { <br>        SetCursor(NULL); <br>        return 1; <br>      } <br>      break; <br> <br>    case WM_ENTERMENULOOP: <br>      AppPause(TRUE); <br>      break; <br> <br>    case WM_EXITMENULOOP: <br>      AppPause(FALSE); <br>      break; <br> <br>    case WM_INITMENUPOPUP: <br>        AppInitMenuPopup(hwnd, (HMENU)wParam, <br>                         (UINT)LOWORD(lParam), (BOOL)HIWORD(lParam)); </code></pre>
<p>
</p>
<pre><code>break; <br> <br>    case WM_COMMAND: <br>      switch(LOWORD(wParam)) <br>      { <br>        case MENU_ABOUT: <br>          AppPause(TRUE); <br>          DialogBox(hInstApp, "AppAbout", hwnd, (DLGPROC)AppAbout); <br>          AppPause(FALSE); <br>          break; <br> <br>        case MENU_EXIT: <br>          PostMessage(hwnd, WM_CLOSE, 0, 0L); <br>          break; <br> <br>        case MENU_LARGER: <br>          MagnifyCube(+1.0); <br>          break; <br> <br>        case MENU_SMALLER: <br>          MagnifyCube(-1.0); <br>          break; <br> <br>        case MENU_GDI: <br>          fDrawWithGDI = !fDrawWithGDI; <br>          break; <br>      } <br>      if (LOWORD(wParam) &gt;= MENU_MODE &amp;&amp; LOWORD(wParam) &lt; MENU_MODE+100) <br>      { <br>        MENUITEMINFO mii; <br> <br>        mii.cbSize = sizeof(mii); <br>        mii.fMask = MIIM_DATA; <br>        GetMenuItemInfo(GetMenu(hwnd), LOWORD(wParam), MF_BYCOMMAND, &amp;mii); <br> <br>        DDSetMode( <br>            (mii.dwItemData &gt;&gt; 0)  &amp; 0xFFF, <br>            (mii.dwItemData &gt;&gt; 12) &amp; 0xFFF, <br>            (mii.dwItemData &gt;&gt; 24) &amp; 0x0FF); <br>      } <br>      return 0L; <br> <br>    case WM_DESTROY: <br>  // clean up DirectInput objects <br>          if (fMouseAcquired) lpdiRot-&gt;Unacquire(); <br>          if (lpdiZoom)  lpdiZoom-&gt;Release(), lpdiZoom = NULL; <br>          if (lpdiRot)   lpdiRot -&gt;Release(), lpdiRot  = NULL; <br>          if (lpdi)      lpdi    -&gt;Release(), lpdi     = NULL; <br> <br>      hwndApp = NULL; <br>      PostQuitMessage(0); <br>      break; <br> <br>    case WM_PAINT: <br>      break; <br> <br>    case WM_MOVE: <br>    case WM_SIZE: <br>    case WM_DISPLAYCHANGE: <br>      if (fAppActive &amp;&amp; !IsIconic(hwnd)) <br>      { <br>        SetRect(&amp;Rect, 0, GetSystemMetrics(SM_CYCAPTION), GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN)); <br>        AdjustWindowRectEx(&amp;Rect, WS_POPUP | WS_CAPTION, FALSE, 0); <br>        SetWindowPos(hwnd, NULL, Rect.left, Rect.top, Rect.right-Rect.left, Rect.bottom-Rect.top, SWP_NOACTIVATE | SWP_NOZORDER); <br>      } <br>      break; <br> <br>    case WM_LBUTTONDOWN: <br>    case WM_RBUTTONDOWN: <br>    case WM_MBUTTONDOWN: <br>          if(lpdiRot-&gt;Acquire() == DI_OK) <br>     { <br>        fMouseAcquired = TRUE; <br>     } <br>  else <br>  { <br>// not acquired, mouse will not do anything <br>  } <br>      break; <br> <br>  } <br> <br>  return DefWindowProc(hwnd,msg,wParam,lParam); <br>} <br> <br>/************************************************************************** <br>  TransformCube <br> <br>  Description: <br>    Transforms the cube vertices by the current rotation matrix. <br>    Recalculates normals and flat shade values for the <br>  directional light source. <br> **************************************************************************/ <br> <br>void TransformCube(matrix_4x4 const &amp;Transform) <br>{ <br>  int i; <br> <br>  //*** Transform the cube by the matrix <br>  for (i = 0; i &lt; 8; ++i) <br>    CubeVertices[i] = Transform * CubeVertices[i]; <br> <br>  //*** Recalculate normals and shades <br>  for (i = 0; i &lt; 6; ++i) <br>  { <br>    //*** Normals are perpendicular to two edges of the cube <br>    vector_4 Edge1, Edge2; <br>    Edge1 = CubeVertices[CubeFaces[i][1]] - CubeVertices[CubeFaces[i][0]]; <br>    Edge2 = CubeVertices[CubeFaces[i][3]] - CubeVertices[CubeFaces[i][0]]; <br>    CubeSurfaceNormals[i] = CrossProduct(Edge1, Edge2); <br>    CubeSurfaceNormals[i].Normalize(); <br> <br>    //*** Cosine shading based on the surface normal, clamped to [0, 1] <br>    real Shade = DotProduct(CubeSurfaceNormals[i], LightSourceDirection); <br>    Shade = Shade + AmbientLight; <br>    if (Shade &lt; 0) Shade = 0; <br>    else if (Shade &gt; 1.0) Shade = 1.0; <br>    CubeSurfaceShades[i] = Shade; <br>  } <br>} <br> <br>/************************************************************************** <br>  ProjectAndDrawCube <br> <br>  Description: <br>    Projects the cube vertices for the current viewpoint then culls <br>  in screen space and draws into the DC via GDI. <br> **************************************************************************/ <br> <br>BOOL ProjectAndDrawCube(HDC hdc, int XOffset, int YOffset) <br>{ <br>  //*** Create a viewing transform for the current eye position <br>  vector_4 ViewDirection = Origin - Viewpoint; <br>  ViewDirection.Normalize(); <br>  view_transform View(Viewpoint, ViewDirection, Up); <br> <br>  //*** Transform and project the vertices into screen space <br>  int i; <br>  POINT aScreenVertices[8]; <br>  for (i = 0; i &lt; 8; ++i) <br>  { <br>    point_4 Temp = View * CubeVertices[i]; <br>    Temp = ViewPerspective * Temp; <br>    Temp.Homogenize(); <br> <br>    aScreenVertices[i].x = (int)Temp.GetX() + XOffset; <br>    aScreenVertices[i].y = (int)Temp.GetY() + YOffset; <br>  } <br> <br>  SelectPen(hdc, GetStockPen(NULL_PEN)); <br> <br>  for (i = 0; i &lt; 6; ++i) <br>  { <br>    //*** Standard culling operation based on the z value of the <br>    //*** cross product of the edges: are the vertices oriented in the <br>    //*** counterclockwise or clockwise direction? <br>    real v1 = aScreenVertices[ CubeFaces[i][2] ].x - <br>      aScreenVertices[ CubeFaces[i][1] ].x; <br>    real w1 = aScreenVertices[ CubeFaces[i][0] ].x - <br>      aScreenVertices[ CubeFaces[i][1] ].x; <br>    real v2 = aScreenVertices[ CubeFaces[i][2] ].y - <br>      aScreenVertices[ CubeFaces[i][1] ].y; <br>    real w2 = aScreenVertices[ CubeFaces[i][0] ].y - <br>      aScreenVertices[ CubeFaces[i][1] ].y; <br>    if ((v1*w2 - v2*w1) &lt;= 0) <br>      continue; <br> <br>    //*** Create a brush for the shaded face color using the selected dither <br> <br>    HBRUSH hbr; <br> <br>    //*** Get the shading colors <br> <br>    int Red, Green, Blue; <br> <br>    Red   = (int)(CubeColors[i][0] * CubeSurfaceShades[i]); <br>    Green = (int)(CubeColors[i][1] * CubeSurfaceShades[i]); <br>    Blue  = (int)(CubeColors[i][2] * CubeSurfaceShades[i]); <br> <br>    //*** Create the dithered or PALETTERGB brush <br> <br>    COLORREF cr; <br> <br>    cr = RGB(Red, Green, Blue); <br>    hbr = CreateSolidBrush(cr); <br> <br>    //*** Collect the correct points in an array <br>    POINT aQuadVertices[4]; <br>    for (int j = 0; j &lt; 4; ++j) <br>      aQuadVertices[j] = aScreenVertices[ CubeFaces[i][j] ]; <br> <br>    //*** Use GDI to draw the face <br>    hbr = SelectBrush(hdc, hbr); <br>    Polygon(hdc, aQuadVertices, 4); <br>    hbr = SelectBrush(hdc, hbr); <br>    DeleteObject(hbr); <br>  } <br> <br>  return TRUE; <br>} <br> <br>/************************************************************************** <br>  ProjectAndDrawCube <br> <br>  Description: <br>    Projects the cube vertices for the current viewpoint then culls <br>  in screen space and draws them into a DirectDrawSurface via custom code <br> **************************************************************************/ <br> <br>BOOL ProjectAndDrawCube(IDirectDrawSurface *pdds, int XOffset, int YOffset) <br>{ <br>  //*** Lock the DirectDraw surface <br>  DDSURFACEDESC ddsd; <br>  ddsd.dwSize = sizeof(ddsd); <br> <br>  if (pdds-&gt;Lock(NULL, &amp;ddsd, DDLOCK_WAIT, NULL) != DD_OK) <br>    return FALSE; <br> <br>  //*** This code only works for 8bpp <br>  if (ddsd.ddpfPixelFormat.dwRGBBitCount != 8) <br>  { <br>    pdds-&gt;Unlock(NULL); <br>    return FALSE; <br>  } <br> <br>  //*** Create a viewing transform for the current eye position <br>  vector_4 ViewDirection = Origin - Viewpoint; <br>  ViewDirection.Normalize(); <br>  view_transform View(Viewpoint, ViewDirection, Up); <br> <br>  //*** Transform and project the vertices into screen space <br>  int i; <br>  POINT aScreenVertices[8]; <br>  for (i = 0; i &lt; 8; ++i) <br>  { <br>    point_4 Temp = View * CubeVertices[i]; <br>    Temp = ViewPerspective * Temp; <br>    Temp.Homogenize(); <br> <br>    aScreenVertices[i].x = (int)Temp.GetX() + XOffset; <br>    aScreenVertices[i].y = (int)Temp.GetY() + YOffset; <br> <br>    //*** !!! OUR CODE DOES NOT CLIP, SO FAIL IF WE NEED CLIPPING <br>    if (aScreenVertices[i].x &lt; 0 || aScreenVertices[i].x &gt;= ScreenSize.cx || <br>        aScreenVertices[i].y &lt; 0 || aScreenVertices[i].y &gt;= ScreenSize.cy) <br>    { <br>      pdds-&gt;Unlock(NULL); <br>      return FALSE; <br>    } <br>  } <br> <br>  for (i = 0; i &lt; 6; ++i) <br>  { <br>    //*** Standard culling operation based on the z value of the <br>    //*** cross product of the edges: are the vertices oriented in the <br>    //*** counterclockwise or clockwise direction? <br>    real v1 = aScreenVertices[ CubeFaces[i][2] ].x - <br>      aScreenVertices[ CubeFaces[i][1] ].x; <br>    real w1 = aScreenVertices[ CubeFaces[i][0] ].x - <br>      aScreenVertices[ CubeFaces[i][1] ].x; <br>    real v2 = aScreenVertices[ CubeFaces[i][2] ].y - <br>      aScreenVertices[ CubeFaces[i][1] ].y; <br>    real w2 = aScreenVertices[ CubeFaces[i][0] ].y - <br>      aScreenVertices[ CubeFaces[i][1] ].y; <br>    if ((v1*w2 - v2*w1) &lt;= 0) <br>      continue; <br> <br>    //*** Get the shading color, palette is setup like so: <br>    //*** 10 system, 64 red, 64 green, 64 blue <br> <br>    BYTE color; <br> <br>    if (CubeColors[i][0] &gt;= 128) <br>        color = (BYTE)(10 + 0*64 + (63 * CubeSurfaceShades[i])); <br>    else if (CubeColors[i][1] &gt;= 128) <br>        color = (BYTE)(10 + 1*64 + (63 * CubeSurfaceShades[i])); <br>    else <br>        color = (BYTE)(10 + 2*64 + (63 * CubeSurfaceShades[i])); <br> <br>    //*** Use code in tri.cpp draw the face <br> <br>    Triangle8((BYTE*)ddsd.lpSurface, ddsd.lPitch, <br>        aScreenVertices[CubeFaces[i][0]], <br>        aScreenVertices[CubeFaces[i][1]], <br>        aScreenVertices[CubeFaces[i][2]], <br>        color); <br> <br>    Triangle8((BYTE*)ddsd.lpSurface, ddsd.lPitch, <br>        aScreenVertices[CubeFaces[i][2]], <br>        aScreenVertices[CubeFaces[i][3]], <br>        aScreenVertices[CubeFaces[i][0]], <br>        color); <br>  } <br> <br>  //*** Never ever forget to unlock! <br>  pdds-&gt;Unlock(NULL); <br>  return TRUE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
