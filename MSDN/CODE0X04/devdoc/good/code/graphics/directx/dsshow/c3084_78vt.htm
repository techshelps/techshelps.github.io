<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SHELL.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3089"></a>SHELL.C</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1995-1997 Microsoft Corporation. All Rights Reserved. <br> * <br> *  File:       shell.c <br> *  Content:    Direct Sound show-off. <br> *  This app basically uses the direct sound api's and pops up some <br> *  controls that the user can play with at runtime to change <br> *  the sound frequency, panning, volume, etc.   It has a few <br> *  other functions built in. <br> * <br> *  This app also takes a couple command-line parameters.  The format is: <br> * <br> *DSShow [/PLAY [/LOOP]] [file] [file] ... <br> * <br> *    Specifying /PLAY causes any specified files to be played as they're <br> * opened.  Adding the /LOOP causes them to loop as well.  /LOOP without <br> * /PLAY means nothing.  Everything else is assumed to be one or more file <br> * names.  Filenames can be enclosed in quotes.  This also means you can <br> * drag and drop files onto the program's icon <br> * <br> * <br> ***************************************************************************/ <br> <br>#define INITGUID <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;commctrl.h&gt; <br>#include &lt;commdlg.h&gt; <br>#include &lt;stdio.h&gt; <br> <br>#include &lt;mmsystem.h&gt; <br>#include &lt;mmreg.h&gt; <br>#include &lt;msacm.h&gt; <br>#include &lt;dsound.h&gt; <br> <br> <br>#include "wassert.h" <br>#include "wave.h" <br> <br>#include "resource.h" <br>#include "shell.h" <br>#include "dsenum.h" <br> <br> <br>// ======================================================================= <br>/* Procedure called when the application is loaded for the first time */ <br>// ======================================================================= <br>BOOL ClassInit( hInstance ) <br>HANDLE hInstance; <br>{ <br>    WNDCLASS    myClass; <br>     <br>    myClass.hCursor             = LoadCursor( NULL, IDC_ARROW ); <br>    myClass.hIcon               = LoadIcon( hInstance, MAKEINTRESOURCE(IDI_ICON3)); <br>    myClass.lpszMenuName        = MAKEINTRESOURCE(IDR_MAINMENU); <br>    myClass.lpszClassName       = (LPSTR)szAppName; <br>    myClass.hbrBackground       = (HBRUSH)(COLOR_WINDOW); <br>    myClass.hInstance           = hInstance; <br>    myClass.style               = CS_HREDRAW | CS_VREDRAW; <br>    myClass.lpfnWndProc         = WndProc; <br>    myClass.cbClsExtra          = 0; <br>    myClass.cbWndExtra          = 0; <br> <br>    if (!RegisterClass( &amp;myClass ) ) <br>       return FALSE; <br> <br>    return TRUE;        /* Initialization succeeded */ <br>} <br> <br> <br>// ======================================================================= <br>/* This "hook procedure" is called by the common dialog code for certain <br> *   events that may occur during the life of our nested dialog structure. <br> * We nest the Explorer style dialog inside our file open dialog so we <br> *   can addd a check box for stick buffers. <br> */ <br> // ======================================================================= <br>UINT CALLBACK FileOpenCustomTemplateDlgProc( hDlg, message, wParam, lParam ) <br>HWND hDlg; <br>UINT message; <br>WPARAM wParam; <br>LPARAM lParam; <br>{ <br>    static LPOPENFILENAME   lpofn = NULL; <br> <br>    switch( message ) <br>    { <br>    case WM_INITDIALOG: <br>        lpofn = (LPOPENFILENAME)lParam; <br> <br>        /* Set the flag to match the current state of the check box control */ <br>        *((LPBOOL)lpofn-&gt;lCustData) = SendDlgItemMessage( hDlg, IDC_FONEST_STICKY, <br>                                                            BM_GETCHECK, 0, 0 ); <br>        return TRUE; <br> <br>    case WM_NOTIFY: <br>        switch(((LPOFNOTIFY)lParam)-&gt;hdr.code) <br>        { <br>        case CDN_SELCHANGE: <br>            /* Use this area to process anything that must be updated when the <br>             * user changes the selection in the Common Dialog Box. <br>             *   NOTE: Provided only for informational purposes <br>             */ <br>            return FALSE; <br> <br>        case CDN_FILEOK: <br>            /* We can do lots of things in this notification message.  The most <br>             * important is that we can decide whether the Common Dialog call will <br>             * go through or whether it will fail.  I decided to handle the checkbox <br>             * control in this one place versus 4 others... -PRN <br>             */ <br>            Assert( lpofn != NULL ); <br>            *((LPBOOL)lpofn-&gt;lCustData) = SendDlgItemMessage( hDlg, IDC_FONEST_STICKY, <br>                                                                BM_GETCHECK, 0, 0 ); <br>            /* Returning zero signifies that we "approve" of the OK command, <br>             * and allows the common dialog to finish. <br>             */ <br>            return FALSE; <br>        } <br>        /* Let the default dialog do/continue processing */ <br>        return FALSE; <br>    } <br>    return FALSE; <br>} <br> <br> <br>// ======================================================================= <br>// ======================================================================= <br>int PASCAL WinMain( hInstance, hPrevInstance, lpszCmdLine, cmdShow ) <br>HINSTANCE hInstance, hPrevInstance; <br>LPSTR lpszCmdLine; <br>int cmdShow; <br>{ <br>    MSG   msg; <br>    HWND  hWnd; <br> <br>    // We must call this to ensure the common controls are setup for <br>    // this application <br>    InitCommonControls(); <br> <br>    if (!hPrevInstance) { <br>/* Call initialization procedure if this is the first instance */ <br>    if (!ClassInit( hInstance )) <br>    return FALSE; <br>} <br> <br>     <br>    hWnd = CreateWindow((LPSTR)szAppName, <br>(LPSTR)szMessage, <br>WS_OVERLAPPEDWINDOW, <br>CW_USEDEFAULT,     <br>CW_USEDEFAULT,     <br>DX_MINWINDOW,      <br>DY_MINWINDOW,      <br>(HWND)NULL,         <br>(HMENU)NULL,       <br>(HANDLE)hInstance,  <br>(LPSTR)NULL         <br>); <br> <br>    if (!hWnd) return (int)msg.wParam; <br> <br>    // Make a long line across the top. <br>    CreateWindow( <br>"STATIC",  <br>"",  <br>WS_CHILD | WS_VISIBLE | SS_ETCHEDHORZ,  <br>0, <br>0, <br>8000,  <br>2,               <br>hWnd,  <br>(HMENU)0,  <br>hInst,  <br>NULL); <br> <br> <br>    /* Save instance handle for DialogBox */ <br>    hInst = hInstance; <br>     <br>    ShowWindow( hWnd, cmdShow ); <br> <br>    if( lpszCmdLine &amp;&amp; *lpszCmdLine ) <br>        if( !ParseCommandLine( lpszCmdLine )) <br>    goto Exit_WinMain; <br>     <br>    /* Polling messages from event queue */ <br>    while (GetMessage((LPMSG)&amp;msg, NULL, 0, 0)) { <br>TranslateMessage((LPMSG)&amp;msg); <br>DispatchMessage((LPMSG)&amp;msg); <br>} <br> <br>Exit_WinMain: <br>    DestroyWindow(hWnd); <br>    UnregisterClass(szAppName, hInstance); <br>    return (int)msg.wParam; <br>} <br> <br>// ======================================================================= <br>/*  This function updates the status window by writing the specified <br>    string to the window, prepended by a string indicating whether <br>    the buffer is in hardware or software <br>*/ <br>// ======================================================================= <br>void UpdateStatus(FILEINFO *pFileInfo, DWORD dwStatus) <br>{ <br>    TCHAR szStatus[200]; <br>    DWORD dwPlay, dwWrite; <br>    HRESULT hr; <br> <br>    lstrcpy(szStatus, pFileInfo-&gt;fHardware ? szHW : szSW); <br>    if (dwStatus &amp; DSBSTATUS_BUFFERLOST) <br>    { <br>    lstrcat(szStatus, szLost); <br>    SendMessage(pFileInfo-&gt;hWndStatus_TXT, WM_SETTEXT, 0, (LPARAM)szStatus); <br>    } <br>    else if (dwStatus &amp; DSBSTATUS_PLAYING) <br>    { <br>    lstrcat(szStatus, szPlaying); <br>    SendMessage(pFileInfo-&gt;hWndStatus_TXT, WM_SETTEXT, 0, (LPARAM)szStatus); <br>    } <br>    else <br>    { <br>    lstrcat(szStatus, szStopped); <br>    SendMessage(pFileInfo-&gt;hWndStatus_TXT, WM_SETTEXT, 0, (LPARAM)szStatus); <br>    } <br> <br>    if (pFileInfo-&gt;fSticky) <br>{ <br>lstrcat(szStatus, szSticky); <br>    SendMessage(pFileInfo-&gt;hWndStatus_TXT, WM_SETTEXT, 0, (LPARAM)szStatus); <br>} <br>    hr = IDirectSoundBuffer_GetCurrentPosition(pFileInfo-&gt;pDSB, &amp;dwPlay, &amp;dwWrite); <br>    if (DS_OK == hr) { <br>    wsprintf(szStatus, szFmtPlayPosition, dwPlay); <br>    SendMessage(pFileInfo-&gt;hWndPlayPosition_TXT, WM_SETTEXT, 0, (LPARAM)szStatus); <br>    wsprintf(szStatus, szFmtWritePosition, dwWrite); <br>    SendMessage(pFileInfo-&gt;hWndWritePosition_TXT, WM_SETTEXT, 0, (LPARAM)szStatus); <br>    } <br> <br>    return; <br>} <br> <br>// ======================================================================= <br>/*  This function updates the main window title to show some <br>    relevant information about the direct sound object <br>*/ <br>// ======================================================================= <br>void UpdateMainStatus() <br>{ <br>    DSCAPS  dsc; <br>    TCHAR   szTitle[200]; <br>     <br>    // Update main window title with some relevant info <br>    dsc.dwSize = sizeof(dsc); <br>    IDirectSound_GetCaps(gpds, &amp;dsc); <br>    wsprintf(szTitle, "%s : free hw memory = %dKb, free hw buffers = %d", <br> szMessage, (dsc.dwFreeHwMemBytes+512)/1024, <br> dsc.dwFreeHwMixingAllBuffers); <br>    SendMessage(hWndMain, WM_SETTEXT, 0, (LPARAM)szTitle); <br>    return; <br>} <br> <br> <br>// ======================================================================= <br>/*  This routine will set up everything needed for the app to run. <br> <br>    Input: <br>hWnd                - App main window handle <br> <br>    Output: <br>None. <br> <br>*/ <br>// ======================================================================= <br>int AppInit(HWND hWnd) <br>{ <br>    UINT            cT; <br>    DSBUFFERDESC    dsbd; <br>    BOOL    fUseGuid; <br>    HRESULT         hr; <br>    DWORD           dw; <br> <br>    // Set up the global window handle. <br>    hWndMain = hWnd; <br> <br>    // Set up the global File...Open dialog's start directory <br>    GetMediaStartPath(); <br> <br>    // Set up the file info header <br>    FileInfoFirst.pNext = NULL; <br>    FileInfoFirst.pwfx = NULL; <br>    FileInfoFirst.cox = COX_STARTCONTROL; <br>    FileInfoFirst.coy = COY_STARTCONTROL; <br> <br>    // Clear the coordinate buffer.  Used to find the next available <br>    // position to use for a new control.  -1 is the invalid value. <br>    for (cT=0; cT&lt;MAXCONTROLS; cT++) rgfcoxAvail[cT] = FALSE; <br> <br>    // Setup the timer... <br>    if ((dwTimer = SetTimer(hWnd, 1, TIMERPERIOD, NULL)) == 0)  <br>{ <br>MessageBox(hWnd, "Cannot allocate timer, aborting", "DirectSound Demo", MB_OK|MB_ICONSTOP); <br>return -1; <br>    } <br> <br>    // Now set up all the direct sound stuff... <br> <br>    // Get the largest waveformatex structure. <br>    if (MMSYSERR_NOERROR != acmMetrics(NULL, ACM_METRIC_MAX_SIZE_FORMAT, &amp;dw)) <br>    { <br>MessageBox(hWnd, "ACM Metrics failed, aborting", "DirectSound Demo", <br>   MB_OK|MB_ICONSTOP); <br>return -1; <br>    } <br> <br> <br>    // Setup the format, frequency, volume, etc. <br>    if ((FileInfoFirst.pwfx = GlobalAllocPtr(GPTR, dw)) == NULL) <br>    { <br>MessageBox(hWnd, "Out of Memory", "DirectSound Demo", <br>   MB_OK|MB_ICONSTOP); <br>return -1; <br>    } <br> <br> <br> <br>    FileInfoFirst.pwfx-&gt;wFormatTag = WAVE_FORMAT_PCM; <br>    FileInfoFirst.pwfx-&gt;nChannels = 2; <br>    FileInfoFirst.pwfx-&gt;nSamplesPerSec = 22050; <br>    FileInfoFirst.pwfx-&gt;nAvgBytesPerSec = 22050*2*2; <br>    FileInfoFirst.pwfx-&gt;nBlockAlign = 4; <br>    FileInfoFirst.pwfx-&gt;wBitsPerSample = 16; <br>    FileInfoFirst.pwfx-&gt;cbSize = 0; <br>     <br>#ifdef STARTEIGHTBITS <br> <br>    FileInfoFirst.pwfx-&gt;wFormatTag = WAVE_FORMAT_PCM; <br>    FileInfoFirst.pwfx-&gt;nChannels = 2; <br>    FileInfoFirst.pwfx-&gt;nSamplesPerSec = 22050; <br>    FileInfoFirst.pwfx-&gt;nAvgBytesPerSec = 22050*1*2; <br>    FileInfoFirst.pwfx-&gt;nBlockAlign = 2; <br>    FileInfoFirst.pwfx-&gt;wBitsPerSample = 8; <br>    FileInfoFirst.pwfx-&gt;cbSize = 0; <br>#endif <br> <br>#ifdef STARTMONO     <br>    FileInfoFirst.pwfx-&gt;wFormatTag = WAVE_FORMAT_PCM; <br>    FileInfoFirst.pwfx-&gt;nChannels = 1; <br>    FileInfoFirst.pwfx-&gt;nSamplesPerSec = 22050; <br>    FileInfoFirst.pwfx-&gt;nAvgBytesPerSec = 22050*1*2; <br>    FileInfoFirst.pwfx-&gt;nBlockAlign = 2; <br>    FileInfoFirst.pwfx-&gt;wBitsPerSample = 16; <br>    FileInfoFirst.pwfx-&gt;cbSize = 0; <br>#endif <br>     <br>    // Optionally enumerate DSOUND devices and allow the user to pick one... <br> <br>    if (!SUCCEEDED(CoInitialize(NULL))) { <br>MessageBox(hWnd, "Failed to initialize COM library", "DirectSound Demo", MB_OK | MB_ICONSTOP); <br>return -1; <br>    } <br>     <br>    fEnumDrivers = (BOOL)GetProfileInt( "DSSHOW", "EnumDrivers", FALSE ); <br>fUseGuid = (fEnumDrivers &amp;&amp; !DoDSoundEnumerate(&amp;guID)); <br> <br>// Create the direct sound object. <br>    hr = CoCreateInstance(&amp;CLSID_DirectSound, NULL, CLSCTX_INPROC_SERVER, <br>  &amp;IID_IDirectSound, &amp;gpds); <br> <br>    if (SUCCEEDED(hr) &amp;&amp; (NULL != gpds)) <br>{ <br>hr = IDirectSound_Initialize(gpds, fUseGuid ? &amp;guID : NULL); <br>if (SUCCEEDED(hr))  <br>{ <br>// Note we need to set the level to be priority to set the <br>// format of the primary buffer <br>hr = IDirectSound_SetCooperativeLevel(gpds, hWndMain, DSSCL_PRIORITY); <br>if (SUCCEEDED(hr))  <br>{ <br> <br>// Set up the primary direct sound buffer. <br>ZeroMemory(&amp;dsbd, sizeof(dsbd)); <br>dsbd.dwSize = sizeof(dsbd); <br>dsbd.dwFlags = DSBCAPS_PRIMARYBUFFER; <br>     <br>hr = IDirectSound_CreateSoundBuffer(gpds, &amp;dsbd, &amp;(FileInfoFirst.pDSB), NULL); <br>if (SUCCEEDED(hr))  <br>{ <br>hr = IDirectSoundBuffer_Play(FileInfoFirst.pDSB, 0, 0, DSBPLAY_LOOPING); <br>if (SUCCEEDED(hr))  <br>{ <br>UpdateMainStatus(); <br>}  <br>else  <br>{ <br>MessageBox(hWnd, "Cannot play primary buffer","DirectSound Demo", MB_OK|MB_ICONSTOP); <br>IDirectSoundBuffer_Release(FileInfoFirst.pDSB); <br>FileInfoFirst.pDSB = NULL; <br>    } <br>}  <br>else  <br>{ <br>MessageBox(hWnd, "Cannot create primary buffer","DirectSound Demo", MB_OK|MB_ICONSTOP); <br>} <br>    }  <br>else  <br>{ <br>MessageBox(hWnd, "DirectSound SetCooperativeLevel failed","DirectSound Demo", MB_OK|MB_ICONSTOP); <br>    } <br>} //initialize <br>else  <br>{ <br>    MessageBox(hWnd, "Failed to Initialize DirectSound object", "DirectSound Demo", MB_OK | MB_ICONSTOP); <br>} <br> <br>if (!SUCCEEDED(hr))  <br>{ <br>    IDirectSound_Release(gpds); <br>    gpds = NULL; <br>} <br> <br> }  <br>else  <br>{ <br>MessageBox(hWnd, "Failed to create DirectSound COM object", <br>   "DirectSound Demo", MB_OK | MB_ICONSTOP); <br>} <br> <br>if (SUCCEEDED(hr))  <br>{ <br>return 0; <br>}  <br>else  <br>{ <br>CoUninitialize(); <br>return -1; <br>} <br>} <br> <br>// ======================================================================= <br>/*  This will destroy all the created objects, allocated memory, etc.  Must be called <br>    before termination of app. <br> <br>    Input: <br>hWnd                - Window handle of main window <br> <br>    Output: <br>None. <br> <br>*/ <br>// ======================================================================= <br>void AppDestroy( HWND hWnd ) <br>{ <br> <br>    HRESULT     hr = 0; <br> <br>    if (dwTimer != 0) <br>    { <br>KillTimer(hWnd, dwTimer); <br>dwTimer = 0; <br>    } <br> <br> <br>    StopAllDSounds(hWnd, &amp;FileInfoFirst); <br>    FreeAllList(hWnd, &amp;FileInfoFirst); <br> <br> <br>    // Destroy the direct sound buffer. <br>    if(FileInfoFirst.pDSB != NULL)  <br>    { <br>IDirectSoundBuffer_Stop(FileInfoFirst.pDSB); <br>IDirectSoundBuffer_Release(FileInfoFirst.pDSB); <br>FileInfoFirst.pDSB = NULL; <br>    } <br> <br>    // Destroy the direct sound object. <br>    if (gpds != NULL) <br>    { <br>IDirectSound_Release(gpds); <br>gpds = NULL; <br>CoUninitialize(); <br>    } <br> <br>    if (FileInfoFirst.pwfx != NULL) <br>    { <br>GlobalFreePtr(FileInfoFirst.pwfx); <br>FileInfoFirst.pwfx = NULL; <br>    } <br> <br>    if (FileInfoFirst.pbData != NULL) <br>    { <br>GlobalFreePtr(FileInfoFirst.pbData); <br>FileInfoFirst.pbData = NULL; <br>    } <br> <br>    WriteProfileString( "DSSHOW", "EnumDrivers", fEnumDrivers ? "1" : "0" ); <br> <br>} <br> <br>// ======================================================================= <br>/* Procedures which make up the window class. */ <br>// ======================================================================= <br>long FAR PASCAL WndProc( hWnd, message, wParam, lParam ) <br>HWND hWnd; <br>unsigned message; <br>WPARAM wParam; <br>LPARAM lParam; <br>{ <br> <br> <br> <br>    switch (message) <br>{ <br> <br>case WM_CREATE: <br>    if (AppInit(hWnd)) return (-1); <br>    break; <br> <br>case WM_TIMER:   <br>    if (!UIMainWindowTimerHandler(hWnd, wParam, lParam)) <br>return(DefWindowProc(hWnd, message, wParam, lParam));                            <br>    break; <br>     <br>     <br>case WM_HSCROLL: <br>    if (!UIMainWindowHSBHandler(hWnd, wParam, lParam)) <br>return(DefWindowProc(hWnd, message, wParam, lParam)); <br>     <br>    break; <br> <br>case WM_VSCROLL: <br>    if (!UIMainWindowVSBHandler(hWnd, wParam, lParam)) <br>return(DefWindowProc(hWnd, message, wParam, lParam)); <br>    break; <br>     <br> <br>case WM_INITMENU: <br>if((HMENU)wParam != GetMenu( hWnd )) <br>    break; <br>CheckMenuItem((HMENU)wParam, IDPD_ENUMDRIVERS, <br>fEnumDrivers ? MF_CHECKED : MF_UNCHECKED ); <br>break; <br> <br>case WM_COMMAND: <br>    if (!UIMainWindowCMDHandler(hWnd, wParam, lParam)) <br>return(DefWindowProc(hWnd, message, wParam, lParam)); <br>    break; <br>     <br>    break; <br> <br>/*case WM_PAINT: <br>    {            <br>     <br>    break; <br>    }*/ <br> <br> <br>case WM_DESTROY: <br>    AppDestroy(hWnd); <br>    PostQuitMessage( 0 ); <br>    break; <br> <br>default: <br>    return DefWindowProc( hWnd, message, wParam, lParam ); <br>    break; <br>     <br>} <br>     <br>    return(0L); <br>} <br> <br>// ======================================================================= <br>/*  This routine will pop up the open file dialog and open a file, and make any internal <br>    arrangements so we know the file is loaded. <br> <br>    Input: <br>hWnd            -   Handle of parent window. <br> <br>    Output: <br>None. <br> <br>*/ <br>// ======================================================================= <br>void PD_FileOpen( HWND hWnd ) <br>{ <br> <br>    char            szFileName[MAX_PATH]; <br>    UINT            cSamples; <br>    FILEINFO        *pFileInfo                  = NULL; <br>    int             nFileName; <br>    BOOL            fSticky; <br> <br>    if (GetNumControls(&amp;FileInfoFirst) &gt;= MAXCONTROLS) <br>    { <br>    MessageBox(hWnd, "No more controls allowed", <br>   "Hold on a sec...", MB_OK); <br>    return; <br>    } <br> <br>    // Open the file, and check its format, etc. <br>    if (OpenFileDialog(hWnd, szFileName, &amp;nFileName, &amp;fSticky)) <br>    { <br> <br>    // Allocate the memory for the structure. <br>    if ((pFileInfo = GlobalAllocPtr(GPTR, sizeof(FILEINFO))) == NULL) <br>    { <br>MessageBox(hWnd, "Cannot add this file", <br>       "Out of Memory", MB_OK|MB_ICONSTOP); <br>goto ERROR_DONE_ROUTINE; <br>    } <br> <br>    pFileInfo-&gt;pbData   = NULL; <br>    pFileInfo-&gt;pwfx     = NULL; <br>    pFileInfo-&gt;pDSB     = NULL; <br>    pFileInfo-&gt;fSticky  = fSticky; <br>    strcpy(pFileInfo-&gt;szFileName, szFileName); <br>     <br>    if (WaveLoadFile(szFileName, &amp;pFileInfo-&gt;cbSize,  <br>    &amp;cSamples, &amp;pFileInfo-&gt;pwfx, &amp;pFileInfo-&gt;pbData) != 0) <br>    { <br>MessageBox(hWnd, "Bad wave file or file too big to fit in memory", <br>"Cannot load wave", MB_OK|MB_ICONSTOP); <br>goto ERROR_DONE_ROUTINE; <br>    } <br> <br>    GetNextControlCoords(&amp;FileInfoFirst, <br>     &amp;pFileInfo-&gt;cox, &amp;pFileInfo-&gt;coy); <br> <br>    if (NewDirectSoundBuffer(pFileInfo) != 0) <br>    { <br>MessageBox(hWnd, "Cannot create new buffer", <br>       "Direct Sound Error", MB_OK|MB_ICONSTOP); <br>goto ERROR_DONE_ROUTINE; <br>    } <br> <br>    Assert(pFileInfo-&gt;pbData != NULL); <br> <br>    // If we fail after this, make sure to update the list!!! <br>    if (AddToList(&amp;FileInfoFirst, pFileInfo) != 0) <br>    { <br>MessageBox(hWnd, "Cannot add file to list", <br>   "Out of Memory", MB_OK|MB_ICONSTOP); <br>goto ERROR_DONE_ROUTINE; <br>    } <br> <br>    pFileInfo-&gt;nFileName = nFileName; <br>    CreateControl(hWnd, pFileInfo, pFileInfo-&gt;pwfx-&gt;nSamplesPerSec, <br>      (MAXPAN_TB-MINPAN_TB)/2, MINVOL_TB ); <br>    ChangeOutputVol(pFileInfo); <br>    ChangeOutputFreq(pFileInfo); <br>    ChangeOutputPan(pFileInfo); <br>    UpdateMainStatus(); <br> <br>    } <br> <br>    goto DONE_ROUTINE; <br>    <br>ERROR_DONE_ROUTINE: <br>    if (pFileInfo != NULL) <br>    { <br> <br>    ReleaseDirectSoundBuffer(pFileInfo); <br> <br>    if (pFileInfo-&gt;pwfx != NULL) <br>    { <br>GlobalFreePtr(pFileInfo-&gt;pwfx); <br>     <br>    } <br>    if (pFileInfo-&gt;pbData != NULL) <br>    { <br>GlobalFreePtr(pFileInfo-&gt;pbData);            <br>    } <br> <br>    GlobalFreePtr(pFileInfo); <br>    pFileInfo = NULL; <br>    } <br> <br>DONE_ROUTINE: <br>    return; <br> <br>} <br> <br>// ======================================================================= <br>/*  This routine will initialize a new direct sound buffer, <br>    set the data in the buffer,  <br>    set the rate, format, etc... <br> <br>    Input: <br>pFileInfo   -   Pointer to file info with all <br>nessecary info filled,  <br>like pbData, cbData, etc... <br> <br>    Output: <br>0 if successful, else the error code. <br> <br>*/ <br>// ======================================================================= <br>int NewDirectSoundBuffer(FILEINFO *pFileInfo) <br>{ <br> <br>    DSBUFFERDESC        dsbd; <br>    DSBCAPS         dsbc; <br>    HRESULT         hr; <br>    BYTE            *pbData         = NULL; <br>    BYTE            *pbData2        = NULL; <br>    DWORD           dwLength; <br>    DWORD           dwLength2; <br> <br>    // Set up the direct sound buffer.  <br>    memset(&amp;dsbd, 0, sizeof(DSBUFFERDESC)); <br>    dsbd.dwSize                 = sizeof(DSBUFFERDESC); <br>    dsbd.dwFlags                = 0; <br>    dsbd.dwFlags                |= DSBCAPS_STATIC; <br>    // Use new GetCurrentPosition() accuracy (DirectX 2 feature) <br>    dsbd.dwFlags                |= DSBCAPS_CTRLDEFAULT | DSBCAPS_GETCURRENTPOSITION2; <br>    if (pFileInfo-&gt;fSticky) <br>        dsbd.dwFlags |= DSBCAPS_STICKYFOCUS; <br>    dsbd.dwBufferBytes               = pFileInfo-&gt;cbSize; <br>    dsbd.lpwfxFormat            = pFileInfo-&gt;pwfx; <br>    if ((hr = gpds-&gt;lpVtbl-&gt;CreateSoundBuffer(gpds, <br>  &amp;dsbd, <br>  &amp;(pFileInfo-&gt;pDSB), <br>  NULL )) != 0) <br>{ <br>goto ERROR_IN_ROUTINE; <br>} <br> <br>    // Ok, lock the sucker down, and copy the memory to it. <br>    if ((hr = pFileInfo-&gt;pDSB-&gt;lpVtbl-&gt;Lock(pFileInfo-&gt;pDSB, <br>0, <br>pFileInfo-&gt;cbSize, <br>&amp;pbData, <br>&amp;dwLength, <br>&amp;pbData2, <br>&amp;dwLength2, <br>    0L)) != 0) <br>    { <br>    goto ERROR_IN_ROUTINE; <br>    } <br> <br>    Assert(pbData != NULL); <br>    memcpy(pbData, pFileInfo-&gt;pbData, pFileInfo-&gt;cbSize); <br> <br>    // Ok, now unlock the buffer, we don't need it anymore. <br>    if ((hr = pFileInfo-&gt;pDSB-&gt;lpVtbl-&gt;Unlock(pFileInfo-&gt;pDSB, <br>      pbData, pFileInfo-&gt;cbSize, <br>      NULL, 0)) != 0) <br>    { <br>    goto ERROR_IN_ROUTINE; <br>    } <br> <br>    pbData = NULL; <br> <br>    if ((hr = pFileInfo-&gt;pDSB-&gt;lpVtbl-&gt;SetVolume(pFileInfo-&gt;pDSB, <br>    MAXVOL_VAL)) != 0) <br>    { <br>    goto ERROR_IN_ROUTINE; <br>    } <br> <br>    if ((hr = pFileInfo-&gt;pDSB-&gt;lpVtbl-&gt;SetPan(pFileInfo-&gt;pDSB, <br>    MIDPAN_VAL)) != 0) <br>    { <br>    goto ERROR_IN_ROUTINE; <br>    } <br> <br>    dsbc.dwSize = sizeof(dsbc); <br>    if (hr = IDirectSoundBuffer_GetCaps(pFileInfo-&gt;pDSB, &amp;dsbc)) <br>    { <br>    goto ERROR_IN_ROUTINE; <br>    } <br> <br>    if (dsbc.dwFlags &amp; DSBCAPS_LOCHARDWARE) { <br>    pFileInfo-&gt;fHardware = TRUE; <br>    } else { <br>    pFileInfo-&gt;fHardware = FALSE; <br>    } <br> <br>    goto DONE_ROUTINE; <br> <br>ERROR_IN_ROUTINE: <br>    if (pbData != NULL) <br>    { <br>    hr = pFileInfo-&gt;pDSB-&gt;lpVtbl-&gt;Unlock(pFileInfo-&gt;pDSB, pbData, <br>pFileInfo-&gt;cbSize, NULL, 0); <br>    pbData = NULL; <br>    } <br> <br>    if (pFileInfo-&gt;pDSB != NULL) <br>    { <br>    pFileInfo-&gt;pDSB-&gt;lpVtbl-&gt;Release(pFileInfo-&gt;pDSB); <br>    pFileInfo-&gt;pDSB = NULL; <br>    } <br>     <br>DONE_ROUTINE: <br> <br>    return(hr);  <br> <br>} <br> <br>// ======================================================================= <br>/*  This routine will release a direct sound buffer, <br>    freeing up memory, resources,  <br>    whatever. <br> <br>    Input: <br>pFileInfo   -   Pointer to the file info, <br>with the proper stuff set. <br> <br>    Output:  <br>0 if successful, else the error code. <br> <br>*/ <br>// ======================================================================= <br>int ReleaseDirectSoundBuffer( FILEINFO *pFileInfo ) <br>{ <br> <br>    if (pFileInfo-&gt;pDSB != NULL) <br>    { <br>    pFileInfo-&gt;pDSB-&gt;lpVtbl-&gt;Release(pFileInfo-&gt;pDSB); <br>    pFileInfo-&gt;pDSB = NULL;  <br>    } <br> <br>    return(0); <br> <br>} <br> <br>// ======================================================================= <br>/*  This routine will find the next x and y coordinates to <br>    write the control to. <br>    The rgfcoxAvail is an array of booleans. <br>    If false, then the index can be  <br>    used as an x coordinate. <br> <br>    Input: <br>pFileInfoHead - Header of the linked list. <br>pcox, pcoy    - Filled upon return with next <br>coordinates to use. <br> <br>    Output: <br>Only pcox and pcoy change. <br> <br>*/ <br>// ======================================================================= <br>void GetNextControlCoords(                      <br>    FILEINFO    *pFileInfoHead,  <br>    int         *pcox,  <br>    int         *pcoy <br>    ) <br>{ <br>    UINT            cT; <br> <br>    for (cT=0; cT&lt;MAXCONTROLS; cT++) <br>    { <br>    if (rgfcoxAvail[cT] == FALSE) <br>    { <br>rgfcoxAvail[cT] = TRUE; <br>break; <br>    } <br>     <br>    } <br> <br>    if (cT == MAXCONTROLS) <br>    { <br>    Assert(FALSE); <br>    // Couldn't find a place to put control, shouldn't happen though. <br>    cT = 666;       // Well, at least put it off screen. <br>    } <br> <br>    *pcox = cT*DX_CONTROLSPACING+COX_STARTCONTROL;      //Offsetting the text from the border <br>    *pcoy = COY_STARTCONTROL; <br>     <br> <br>} <br> <br>// ======================================================================= <br>/*  CreateControl <br> <br>    This will create the control used for the window, actually it is a <br>    bundle of controls put together.  I was thinking of a good way to <br>    figure out id codes for the controls but found no good way except a <br>    "funny" way...I'm going to use the x coordinate of the control as the <br>    id for the first control, then id+1 for the second control.  Since <br>    all the controls have different x coordinates, this is fine, as long <br>    as the # of windows in the control is not more than the spacing of <br>    the controls. <br> <br>    Input: <br>hWnd                -   Parent Window. <br>pFileInfo           -   Pointer to FileInfo structure with the cox and coy filled. <br>dwFreq, dwPan, dwVol-   Default track bar values. <br> <br>    Output: <br>0 if successful, else the error code. <br> <br>*/ <br>// ======================================================================= <br>int CreateControl(HWND hWnd, FILEINFO *pFileInfo, DWORD dwFreq,DWORD dwPan, DWORD dwVol) <br>{ <br>    intcox, coy; <br>    int     coxOld, coyOld; <br>    int     nError = 0; <br>    DWORDidBase; <br>    SIZE    Size;        <br>    HDC     hDC = NULL; <br>DWORD dwMinFreq, dwMaxFreq; <br> <br>    /* Figure out the values of dwPan and dwVol that the track bars like */ <br> <br>    idBase = pFileInfo-&gt;cox; <br>    Assert(pFileInfo != NULL); <br>    cox = pFileInfo-&gt;cox+DX_TEXTSPACING; <br>    coy = pFileInfo-&gt;coy+DY_TEXTSPACING;        //We may have to shift this <br> <br>    coxOld = cox; <br>    coyOld = coy; <br>coy -= 8;                       //We must adjust to fit the text in the border <br> <br>    if ((hDC = GetDC(hWnd)) == NULL) <br>{ <br>nError = -1; <br>goto DONE_ROUTINE; <br>} <br> <br> <br>    if (!GetTextExtentPoint32(hDC, pFileInfo-&gt;szFileName+pFileInfo-&gt;nFileName, strlen(pFileInfo-&gt;szFileName+pFileInfo-&gt;nFileName), &amp;Size)) <br>{ <br>nError = -1; <br>goto DONE_ROUTINE; <br>} <br> <br>    //Creates the Filename window <br>    if ((pFileInfo-&gt;hWndFileName_TXT = CreateWindow( <br>"STATIC",  <br>pFileInfo-&gt;szFileName+pFileInfo-&gt;nFileName,  <br>WS_CHILD | WS_VISIBLE | SS_LEFTNOWORDWRAP,  <br>cox, <br>coy,                                                                     <br>DX_FILENAME_TXT,                                                                         <br>Size.cy,               <br>hWnd,  <br>(HMENU)0,  <br>hInst,  <br>NULL)) == NULL) <br>{ <br>nError = -1; <br>goto DONE_ROUTINE; <br>}    <br>//Create line under Filename             <br>    cox += DX_LOOPEDSPACING; <br>    coy += Size.cy + DY_TEXTSPACING + DY_LOOPEDSPACING; <br> <br>    if ((pFileInfo-&gt;hWndFileName_EDGE = CreateWindow( <br>"STATIC",  <br>"",  <br>WS_CHILD | WS_VISIBLE | SS_ETCHEDHORZ,  <br>cox, <br>coy - (DY_LOOPEDSPACING+DY_TEXTSPACING)/2, <br>DX_LINEEDGE,  <br>DY_LINEEDGE,                 <br>hWnd,  <br>(HMENU)0,  <br>hInst,  <br>NULL)) == NULL) <br>{ <br>nError = -1; <br>goto DONE_ROUTINE; <br>}    <br> <br>    // Now create status if required. <br>     <br>    #ifdef SHOWSTATUS    <br> <br>    if (!GetTextExtentPoint32(hDC, szPlaying, strlen(szPlaying), &amp;Size)) <br>{ <br>nError = -1; <br>goto DONE_ROUTINE; <br>} <br> <br> <br>    //Creates Status Window <br>    if ((pFileInfo-&gt;hWndStatus_TXT = CreateWindow( <br>"STATIC",  <br>"", <br>WS_CHILD | WS_VISIBLE | SS_LEFTNOWORDWRAP,  <br>cox, <br>coy, <br>DX_STATUS_TXT,  <br>Size.cy, // + DY_TEXTSPACING,                <br>hWnd,  <br>(HMENU)0,  <br>hInst,  <br>NULL)) == NULL) <br>{ <br>nError = -1; <br>goto DONE_ROUTINE; <br>}    <br> <br>    cox += DX_LOOPEDSPACING; <br>    coy += Size.cy + DY_TEXTSPACING + DY_LOOPEDSPACING; <br> <br>    //Create line under Status <br>    if ((pFileInfo-&gt;hWndStatus_EDGE = CreateWindow( <br>"STATIC",  <br>"",  <br>WS_CHILD | WS_VISIBLE | SS_ETCHEDHORZ,  <br>cox, <br>coy - (DY_LOOPEDSPACING+DY_TEXTSPACING)/2, <br>DX_LINEEDGE,  <br>DY_LINEEDGE,                 <br>hWnd,  <br>(HMENU)0,  <br>hInst,  <br>NULL)) == NULL) <br>{ <br>nError = -1; <br>goto DONE_ROUTINE; <br>} <br> <br>    //Creates PlayPos Window <br>    if ((pFileInfo-&gt;hWndPlayPosition_TXT = CreateWindow( <br>"STATIC", "", <br>WS_CHILD | WS_VISIBLE | SS_LEFTNOWORDWRAP, <br>cox,  <br>coy, <br>DX_STATUS_TXT,  <br>Size.cy, <br>hWnd,  <br>NULL,  <br>hInst,  <br>NULL)) == NULL) <br>    { <br>nError = -1; <br>goto DONE_ROUTINE; <br>    } <br> <br>    cox += DX_LOOPEDSPACING; <br>    coy += Size.cy + DY_TEXTSPACING + DY_LOOPEDSPACING; //Create line under PlayPos <br>     <br>    if ((pFileInfo-&gt;hWndPlayPosition_EDGE = CreateWindow( <br>"STATIC", "",  <br>WS_CHILD | WS_VISIBLE | SS_ETCHEDHORZ,  <br>cox,  <br>coy - (DY_LOOPEDSPACING+DY_TEXTSPACING)/2, <br>DX_LINEEDGE,  <br>DY_LINEEDGE,                <br>hWnd,  <br>NULL,  <br>hInst,  <br>NULL)) == NULL) <br>    { <br>nError = -1; <br>goto DONE_ROUTINE; <br>    } <br>     <br>    //Creates WritePos Window </code></pre>
<p>
</p>
<pre><code>if ((pFileInfo-&gt;hWndWritePosition_TXT = CreateWindow( <br>"STATIC", "", <br>WS_CHILD | WS_VISIBLE | SS_LEFTNOWORDWRAP, <br>cox,  <br>coy, <br>DX_STATUS_TXT,  <br>Size.cy, <br>hWnd,  <br>NULL,  <br>hInst,  <br>NULL)) == NULL) <br>    { <br>nError = -1; <br>goto DONE_ROUTINE; <br>    } <br> <br>    cox += DX_LOOPEDSPACING; <br>    coy += Size.cy + DY_TEXTSPACING + DY_LOOPEDSPACING; <br>     <br>    //Create line under WritePos <br>    if ((pFileInfo-&gt;hWndWritePosition_EDGE = CreateWindow( <br>"STATIC", "",  <br>WS_CHILD | WS_VISIBLE | SS_ETCHEDHORZ,  <br>cox,  <br>coy - (DY_LOOPEDSPACING+DY_TEXTSPACING)/2, <br>DX_LINEEDGE, <br>DY_LINEEDGE,                <br>hWnd, <br>NULL,  <br>hInst,  <br>NULL)) == NULL) <br>    { <br>nError = -1; <br>goto DONE_ROUTINE; <br>    } <br>     <br>    #endif       <br> <br>    //Set up the Freq Text <br>    if (!GetTextExtentPoint32(hDC, szFreq, strlen(szFreq), &amp;Size)) <br>{ <br>nError = -1; <br>goto DONE_ROUTINE; <br>} <br> <br>    // Make the frequency text there. <br>    if ((pFileInfo-&gt;hWndFreq_TXT = CreateWindow( <br>"STATIC",  <br>szFreq,  <br>WS_CHILD | WS_VISIBLE | SS_LEFTNOWORDWRAP,  <br>cox, <br>coy, <br>DX_FREQ_TXT,  <br>Size.cy,                 <br>hWnd,  <br>(HMENU)0,  <br>hInst,  <br>NULL)) == NULL) <br>{ <br>nError = -1; <br>goto DONE_ROUTINE; <br>}    <br> <br>    coy += Size.cy; <br> <br>    // Make the frequency trackbar. <br>    if ((pFileInfo-&gt;hWndFreq_TB = CreateWindow( <br>TRACKBAR_CLASS,  <br>"",  <br>WS_CHILD | WS_VISIBLE | TBS_HORZ | TBS_BOTH,  <br>cox, <br>coy, <br>DX_FREQ_TB,  <br>DY_FREQ_TB,              <br>hWnd,  <br>(HMENU)(idBase+idFreqTB),  <br>hInst,  <br>NULL)) == NULL) <br>{ <br>nError = -1; <br>goto DONE_ROUTINE; <br>}    <br> <br>// get the min and max range that the sound card supports. <br>// If the buffer is in hardware query the card, else use <br>// our ifdef'd values. <br>if (pFileInfo-&gt;fHardware) <br>{ <br>DSCAPS dsc; <br>memset(&amp;dsc, 0, sizeof(DSCAPS)); <br>dsc.dwSize = sizeof(DSCAPS); <br>    nError = IDirectSound_GetCaps(gpds, &amp;dsc); <br>Assert(nError == DS_OK); <br>dwMinFreq = dsc.dwMinSecondarySampleRate; <br>dwMaxFreq = dsc.dwMaxSecondarySampleRate; <br>} <br>else <br>{ <br>dwMinFreq = DSBFREQUENCY_MIN; <br>dwMaxFreq = DSBFREQUENCY_MAX; <br>} <br> <br>SendMessage(pFileInfo-&gt;hWndFreq_TB, TBM_SETRANGEMIN, FALSE, dwMinFreq / FREQFACTOR ); <br>SendMessage(pFileInfo-&gt;hWndFreq_TB, TBM_SETRANGEMAX, FALSE, dwMaxFreq / FREQFACTOR ); <br> <br>    SendMessage(pFileInfo-&gt;hWndFreq_TB, TBM_SETPAGESIZE, 0, FREQPAGE ); <br>    SendMessage(pFileInfo-&gt;hWndFreq_TB, TBM_SETPOS, TRUE, (dwFreq + FREQADD)/FREQFACTOR); <br>    pFileInfo-&gt;dwFreq = dwFreq; <br> <br> <br>    coy += DY_FREQ_TB+DY_PANSPACING;     <br> <br>    if ((pFileInfo-&gt;hWndFreq_EDGE = CreateWindow( <br>"STATIC",  <br>"",  <br>WS_CHILD | WS_VISIBLE | SS_ETCHEDHORZ,  <br>cox, <br>coy - (DY_PANSPACING+DY_TEXTSPACING)/2, <br>DX_LINEEDGE,  <br>DY_LINEEDGE,                 <br>hWnd,  <br>(HMENU)0,  <br>hInst,  <br>NULL)) == NULL) <br>{ <br>nError = -1; <br>goto DONE_ROUTINE; <br>}    <br> <br>    //Adjusts the relative position of the Text     <br>    coy -= (((DY_PANSPACING+DY_TEXTSPACING)/2)-((DY_LOOPEDSPACING+DY_TEXTSPACING)/2)); <br> <br>    if (!GetTextExtentPoint32(hDC, szPan, strlen(szPan), &amp;Size)) <br>{ <br>nError = -1; <br>goto DONE_ROUTINE; <br>} <br> <br> <br>    // Make the pan text there. <br>    if ((pFileInfo-&gt;hWndPan_TXT = CreateWindow( <br>"STATIC",  <br>szPan,  <br>WS_CHILD | WS_VISIBLE | SS_LEFTNOWORDWRAP,  <br>cox, <br>coy, <br>DX_PAN_TXT,  <br>Size.cy,                 <br>hWnd,  <br>(HMENU)0,  <br>hInst,  <br>NULL)) == NULL) <br>{ <br>nError = -1; <br>goto DONE_ROUTINE; <br>}    <br> <br>    coy += Size.cy; <br> <br>    // Make the pan trackbar. <br>    if ((pFileInfo-&gt;hWndPan_TB = CreateWindow( <br>TRACKBAR_CLASS,  <br>"",  <br>WS_CHILD | WS_VISIBLE | TBS_HORZ | TBS_BOTH,  <br>cox, <br>coy, <br>DX_PAN_TB,  <br>DY_PAN_TB,               <br>hWnd,  <br>(HMENU)(idBase+idPanTB),  <br>hInst,  <br>NULL)) == NULL) <br>{ <br>nError = -1; <br>goto DONE_ROUTINE; <br>}    <br> <br>    SendMessage(pFileInfo-&gt;hWndPan_TB, TBM_SETRANGE, FALSE, MAKELONG(MINPAN_TB, MAXPAN_TB));  <br>    SendMessage(pFileInfo-&gt;hWndPan_TB, TBM_SETPOS, TRUE, dwPan); <br>SendMessage(pFileInfo-&gt;hWndPan_TB, TBM_SETPAGESIZE, 0, PANPAGE ); <br>    pFileInfo-&gt;dwPan = dwPan; <br> <br> <br>    coy += DY_PAN_TB + DY_VOLSPACING; <br> <br>    if ((pFileInfo-&gt;hWndPan_EDGE = CreateWindow( <br>"STATIC",  <br>"",  <br>WS_CHILD | WS_VISIBLE | SS_ETCHEDHORZ,  <br>cox, <br>coy - (DY_VOLSPACING+DY_TEXTSPACING)/2, <br>DX_LINEEDGE,  <br>DY_LINEEDGE,                 <br>hWnd,  <br>(HMENU)0,  <br>hInst,  <br>NULL)) == NULL) <br>{ <br>nError = -1; <br>goto DONE_ROUTINE; <br>}    <br> <br>    //Adjusts the relative position of the Text <br>    coy -= (((DY_PANSPACING+DY_TEXTSPACING)/2)-((DY_LOOPEDSPACING+DY_TEXTSPACING)/2)); <br> <br>    if (!GetTextExtentPoint32(hDC, szVolume, strlen(szVolume), &amp;Size)) <br>{ <br>nError = -1; <br>goto DONE_ROUTINE; <br>} <br> <br>    // Make the volume text there. <br>    if ((pFileInfo-&gt;hWndVol_TXT = CreateWindow( <br>"STATIC",  <br>szVolume,  <br>WS_CHILD | WS_VISIBLE | SS_LEFTNOWORDWRAP,  <br>cox, <br>coy, <br>DX_VOL_TXT,  <br>Size.cy,                 <br>hWnd,  <br>(HMENU)idBase,  <br>hInst,  <br>NULL)) == NULL) <br>{ <br>nError = -1; <br>goto DONE_ROUTINE; <br>}    <br> <br>    coy += Size.cy; <br> <br>    // Make the volume trackbars. <br>    // Create main volume bar. <br>    if ((pFileInfo-&gt;hWndVolM_TB = CreateWindow( <br>TRACKBAR_CLASS,  <br>"",  <br>WS_CHILD | WS_VISIBLE | TBS_VERT | TBS_BOTH,  <br>cox, <br>coy, <br>DX_VOL_TB,  <br>DY_VOL_TB,               <br>hWnd,  <br>(HMENU)(idBase+idVolMTB),  <br>hInst,  <br>NULL)) == NULL) <br>{ <br>nError = -1; <br>goto DONE_ROUTINE; <br>}    <br> <br>    SendMessage(pFileInfo-&gt;hWndVolM_TB, TBM_SETRANGE, FALSE, MAKELONG(MINVOL_TB, MAXVOL_TB));  <br>    SendMessage(pFileInfo-&gt;hWndVolM_TB, TBM_SETPOS, TRUE, dwVol); <br>    pFileInfo-&gt;dwVol = MAXVOL_TB - dwVol; <br> <br> <br> <br>    // Now the left volume. <br>    if ((pFileInfo-&gt;hWndVolL_TB = CreateWindow( <br>TRACKBAR_CLASS,  <br>"",  <br>WS_CHILD | WS_VISIBLE |WS_DISABLED| TBS_VERT | TBS_BOTH,  <br>cox+DX_VOL_TB+DX_VOLSPACING_TB, <br>coy, <br>DX_VOL_TB,  <br>DY_VOL_TB,               <br>hWnd,  <br>(HMENU)(idBase+idVolLTB),  <br>hInst,  <br>NULL)) == NULL) <br>{ <br>nError = -1; <br>goto DONE_ROUTINE; <br>}    <br> <br>    SendMessage(pFileInfo-&gt;hWndVolL_TB, TBM_SETRANGE, FALSE, MAKELONG(MINVOL_TB, MAXVOL_TB));  <br>    SendMessage(pFileInfo-&gt;hWndVolL_TB, TBM_SETPOS, TRUE, MAXVOL_TB); <br> <br>    if ((pFileInfo-&gt;hWndVolL_TXT = CreateWindow( <br>"STATIC",  <br>"L",  <br>WS_CHILD | WS_VISIBLE | SS_LEFTNOWORDWRAP,  <br>cox+DX_VOL_TB*3/2+DX_VOLSPACING_TB/2, <br>coy+DY_VOL_TB+DY_VOLSPACINGY, <br>DX_VOLUMECHAR,  <br>Size.cy,                 <br>hWnd,  <br>(HMENU)0,  <br>hInst,  <br>NULL)) == NULL) <br>{ <br>nError = -1; <br>goto DONE_ROUTINE; <br>}    <br> <br> <br>    // And right volume. <br>    if ((pFileInfo-&gt;hWndVolR_TB = CreateWindow( <br>TRACKBAR_CLASS,  <br>"",  <br>WS_CHILD | WS_VISIBLE | WS_DISABLED | TBS_VERT | TBS_BOTH,  <br>cox+DX_VOL_TB*2+DX_VOLSPACING_TB*2, <br>coy, <br>DX_VOL_TB,  <br>DY_VOL_TB,               <br>hWnd,  <br>(HMENU)(idBase+idVolRTB),  <br>hInst,  <br>NULL)) == NULL) <br>{ <br>nError = -1; <br>goto DONE_ROUTINE; <br>}    <br> <br>    SendMessage(pFileInfo-&gt;hWndVolR_TB, <br>    TBM_SETRANGE, FALSE, MAKELONG(MINVOL_TB, MAXVOL_TB));  <br>    SendMessage(pFileInfo-&gt;hWndVolR_TB, <br>    TBM_SETPOS, TRUE, MAXVOL_TB); <br> <br>    if ((pFileInfo-&gt;hWndVolR_TXT = CreateWindow( <br>"STATIC",  <br>"R",  <br>WS_CHILD | WS_VISIBLE | SS_LEFTNOWORDWRAP,  <br>cox+DX_VOL_TB*5/2+DX_VOLSPACING_TB/2+2, <br>    // +2 to look nice. <br>coy+DY_VOL_TB+DY_VOLSPACINGY, <br>DX_VOLUMECHAR,  <br>Size.cy,                 <br>hWnd,  <br>(HMENU)0,  <br>hInst,  <br>NULL)) == NULL) <br>{ <br>nError = -1; <br>goto DONE_ROUTINE; <br>}    <br> <br>  <br>    coy += DY_VOL_TB + DY_BEFOREFIRSTBUTTON;    //Line under L &amp; R <br> <br>    if ((pFileInfo-&gt;hWndVol_EDGE = CreateWindow( <br>"STATIC",  <br>"",  <br>WS_CHILD | WS_VISIBLE | SS_ETCHEDHORZ,  <br>cox, <br>coy - (DY_BEFOREFIRSTBUTTON)/2, <br>DX_LINEEDGE,  <br>DY_LINEEDGE,                 <br>hWnd,  <br>(HMENU)0,  <br>hInst,  <br>NULL)) == NULL) <br>{ <br>nError = -1; <br>goto DONE_ROUTINE; <br>}    <br> <br> <br> <br>    if (!GetTextExtentPoint32(hDC, szPlay, strlen(szPlay), &amp;Size)) <br>{ <br>nError = -1; <br>goto DONE_ROUTINE; <br>} <br> <br> <br>    //Create Play Button <br>    if ((pFileInfo-&gt;hWndPlay_BN = CreateWindow( <br>"BUTTON",  <br>szPlay,  <br>WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,  <br>cox, <br>coy, <br>DX_BUTTONSPACING,  <br>Size.cy + DY_BUTTONSPACING,              <br>hWnd,  <br>(HMENU)(idBase+idPlayBN),  <br>hInst,  <br>NULL)) == NULL) <br>{ <br>nError = -1; <br>goto DONE_ROUTINE; <br>}        <br> <br>    //coy += Size.cy + DY_BUTTONSPACING + DY_BETWEENBUTTONS; <br>     <br>    if (!GetTextExtentPoint32(hDC, szPlay, strlen(szPlay), &amp;Size)) <br>{ <br>nError = -1; <br>goto DONE_ROUTINE; <br>} <br>      <br>    //Make Remove button <br>    if ((pFileInfo-&gt;hWndRemove_BN = CreateWindow( <br>"BUTTON",  <br>szRemove,  <br>WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,  <br>cox + DX_BUTTONSPACING + DY_BETWEENBUTTONS, <br>coy, <br>DX_BUTTONSPACING,  <br>Size.cy + DY_BUTTONSPACING,              <br>hWnd,  <br>(HMENU)(idBase+idRemoveBN),  <br>hInst,  <br>NULL)) == NULL) <br>{ <br>nError = -1; <br>goto DONE_ROUTINE; <br>}        <br> <br>    coy += Size.cy + DY_BUTTONSPACING+ DY_BETWEENBUTTONS; <br> <br> <br>    //Set up Looped Checkbox  <br>    if (!GetTextExtentPoint32(hDC, szLooped, strlen(szLooped), &amp;Size)) <br>{ <br>nError = -1; <br>goto DONE_ROUTINE; <br>} <br> <br>    //Create Looped Checkbox window <br>    if ((pFileInfo-&gt;hWndLooped_BN = CreateWindow( <br>"BUTTON",  <br>szLooped,  <br>WS_CHILD | WS_VISIBLE | BS_AUTOCHECKBOX,  <br>cox, <br>coy, <br>DX_LOOPED_TXT,  <br>Size.cy + DY_TEXTSPACING -2,                <br>hWnd,  <br>(HMENU)(idBase+idLoopedBN),  <br>hInst,  <br>NULL)) == NULL) <br>{ <br>nError = -1; <br>goto DONE_ROUTINE; <br>}        <br>   <br> <br>    // Don't need the between buttons spacing <br>    //  because there are no more controls. <br>    coy += Size.cy;// + DY_BUTTONSPACING; //+ DY_BETWEENBUTTONS; <br> <br>    if ((pFileInfo-&gt;hWndWhole_EDGE = CreateWindow( <br>"STATIC",  <br>"",  <br>WS_CHILD | WS_VISIBLE | SS_ETCHEDFRAME,  <br>coxOld-DX_FRAMEEDGE, <br>coyOld-DY_FRAMEEDGE, <br>DX_CONTROLSPACING-DX_FRAMEEDGEINNER,  <br>coy - coyOld + DY_FRAMEEDGE*2,               <br>hWnd,  <br>(HMENU)0,  <br>hInst,  <br>NULL)) == NULL) <br>{ <br>nError = -1; <br>goto DONE_ROUTINE; <br>}    <br> <br>     <br>    SetAllText(pFileInfo); <br>    UpdateLRVolume(pFileInfo); <br> <br>     <br>DONE_ROUTINE:    <br>    if (hDC != NULL) <br>    { <br>if (ReleaseDC(hWnd, hDC) == 0) <br>{ <br>nError = -1; <br>goto DONE_ROUTINE; <br>} <br>    } <br> <br>    return(nError); <br> <br>} <br> <br>// ======================================================================= <br>/*  This will add to the linked list of FileInfo's. <br>    The FileInfo's keep track of the <br>    files loaded, and this is done in a linked list format <br> <br>    Input: <br>pFileInfoHead   -   Top of linked list. <br>pFileInfo   -   Pointer to entry to add. <br> <br>    Output: <br>0 if successful, else the error code. <br> <br>*/       <br>// ======================================================================= <br>int AddToList(FILEINFO *pFileInfoHead, FILEINFO *pFileInfo) <br>{ <br>    pFileInfo-&gt;pNext = NULL;     <br>    pFileInfo-&gt;fPlaying = FALSE; <br> <br>    while (pFileInfoHead-&gt;pNext != NULL) <br>{ <br>pFileInfoHead = pFileInfoHead-&gt;pNext; <br>} <br> <br>    pFileInfoHead-&gt;pNext = pFileInfo; <br> <br>    return(0); <br> <br>} <br> <br>// ======================================================================= <br>/*  This routine will get the number of controls in the window. <br>    Can be used to determine new size of window. <br> <br>    Input: <br>pFileInfoHead           -   Header of linked list. <br> <br>    Output: <br># of controls. <br>*/ <br>// ======================================================================= <br>int GetNumControls( FILEINFO *pFileInfoHead ) <br>{ <br> <br>    int cT  = 0; <br> <br>    while (pFileInfoHead-&gt;pNext != NULL) <br>    { <br>    pFileInfoHead = pFileInfoHead-&gt;pNext; <br>    cT++; <br>    } <br> <br>    return(cT); <br> <br>} <br> <br>// ======================================================================= <br>/*  This routine will free the whole linked list in pFileInfoFirst, <br>    including all the <br>    memory used by the wave file, waveformatex structure, etc. <br>*/ <br>// ======================================================================= <br>int FreeAllList(HWND hWnd, FILEINFO *pFileInfoFirst) <br>{ <br> <br>    FILEINFO        *pFileInfo, *pFileNext; <br>    UINT        cT; <br> <br>    Assert(pFileInfoFirst != NULL); <br>    pFileInfo = pFileInfoFirst-&gt;pNext; <br> <br>    while (pFileInfo != NULL) <br>    { <br>    ReleaseDirectSoundBuffer(pFileInfo); <br>    GlobalFreePtr(pFileInfo-&gt;pwfx); <br>    GlobalFreePtr(pFileInfo-&gt;pbData); <br>    pFileNext = pFileInfo-&gt;pNext; <br>    GlobalFreePtr(pFileInfo); <br>    pFileInfo = pFileNext; <br>    } <br> <br>    for (cT=0; cT&lt;MAXCONTROLS; cT++) <br>    rgfcoxAvail[cT] = FALSE; <br> <br> <br> <br>    return(0);           <br> <br> <br>} <br> <br>// ======================================================================= <br>/*  This routine will remove an entry from the list, i.e. will remove <br>    pFileInfo and all its allocated memory from the list pointed by the header <br>    by pFileInfoHead <br> <br>    Input: <br>pFileInfo               -   Pointer to entry to remove. <br>pFileInfoHead           -   Head, first entry. <br> <br>    Output: <br>0 if successful, else the error. <br> <br>*/ <br>// ======================================================================= <br>int RemoveFromList(FILEINFO *pFileInfo, FILEINFO *pFileInfoHead) <br>{ <br> <br>    FILEINFO        *pFileNext; <br> <br>    Assert(pFileInfoHead != NULL); <br> <br>    // This used to be pFileInfoHead != NULL <br>    while (pFileInfoHead-&gt;pNext != NULL) <br>{ <br>if (pFileInfoHead-&gt;pNext == pFileInfo) <br>    { <br>    Assert(pFileInfo-&gt;cox/DX_CONTROLSPACING &lt; MAXCONTROLS); <br>    rgfcoxAvail[pFileInfo-&gt;cox/DX_CONTROLSPACING] = FALSE; <br>    <br>    DestroyWindow(pFileInfo-&gt;hWndFileName_TXT);  <br>    DestroyWindow(pFileInfo-&gt;hWndFreq_TB);       <br>    DestroyWindow(pFileInfo-&gt;hWndFreq_TXT);      <br>    DestroyWindow(pFileInfo-&gt;hWndPan_TB);            <br>    DestroyWindow(pFileInfo-&gt;hWndPan_TXT);       <br>    DestroyWindow(pFileInfo-&gt;hWndVol_TXT);       <br>    DestroyWindow(pFileInfo-&gt;hWndVolL_TB);       <br>    DestroyWindow(pFileInfo-&gt;hWndVolR_TB);       <br>    DestroyWindow(pFileInfo-&gt;hWndVolM_TB);       <br>    DestroyWindow(pFileInfo-&gt;hWndLooped_BN);         <br>    DestroyWindow(pFileInfo-&gt;hWndPlay_BN);       <br>    DestroyWindow(pFileInfo-&gt;hWndRemove_BN); <br>    DestroyWindow(pFileInfo-&gt;hWndFileName_EDGE); <br>    DestroyWindow(pFileInfo-&gt;hWndLooped_EDGE);   <br>    DestroyWindow(pFileInfo-&gt;hWndFreq_EDGE);         <br>    DestroyWindow(pFileInfo-&gt;hWndPan_EDGE);      <br>    DestroyWindow(pFileInfo-&gt;hWndVol_EDGE);      <br>    DestroyWindow(pFileInfo-&gt;hWndWhole_EDGE);        <br>    DestroyWindow(pFileInfo-&gt;hWndVolL_TXT);      <br>    DestroyWindow(pFileInfo-&gt;hWndVolR_TXT);      <br>    #ifdef SHOWSTATUS <br>    DestroyWindow(pFileInfo-&gt;hWndStatus_TXT); <br>    DestroyWindow(pFileInfo-&gt;hWndStatus_EDGE); <br>    DestroyWindow(pFileInfo-&gt;hWndPlayPosition_TXT); <br>    DestroyWindow(pFileInfo-&gt;hWndPlayPosition_EDGE); <br>    DestroyWindow(pFileInfo-&gt;hWndWritePosition_TXT); <br>    DestroyWindow(pFileInfo-&gt;hWndWritePosition_EDGE); <br>    #endif <br> <br> <br> <br> <br>    GlobalFree(pFileInfoHead-&gt;pNext-&gt;pwfx); <br>    GlobalFree(pFileInfoHead-&gt;pNext-&gt;pbData); <br>    pFileNext = pFileInfoHead-&gt;pNext-&gt;pNext; <br>    GlobalFreePtr(pFileInfoHead-&gt;pNext); <br>    pFileInfoHead-&gt;pNext = pFileNext;                                                          <br>    break; <br>    } <br>pFileInfoHead = pFileInfoHead-&gt;pNext; <br>} <br> <br>    return(0); <br>} <br> <br>// ======================================================================= <br>/*  This will pop up the open file dialog and allow the user to pick one file.  <br>     <br>    Input:   <br>hWnd            -   Handle of parent window. <br>pszFileName         -   String to store filename in, must be at least MAX_PATH long. <br> <br> <br>    Output: <br>TRUE if a file was  picked successfully, else FALSE (user didn't pick a file) <br> <br> */ <br>// ======================================================================= <br>BOOL OpenFileDialog(HWND hWnd, LPSTR pszFileName, int *nFileName, LPBOOL lpfSticky) <br>{ <br>    BOOL            fReturn, <br>    fValid; <br>    OPENFILENAME    ofn;                 <br> <br>    pszFileName[0]          = 0; <br> <br>    ofn.lStructSize         = sizeof(ofn); <br>    ofn.hwndOwner           = hWnd; <br>    ofn.hInstance           = hInst; <br>    ofn.lpstrFilter         = "Wave Files\0*.wav\0All Files\0*.*\0\0"; <br>    ofn.lpstrCustomFilter   = NULL; <br>    ofn.nMaxCustFilter      = 0; <br>    ofn.nFilterIndex        = 1; <br>    ofn.lpstrFile           = pszFileName; <br>    ofn.nMaxFile            = MAX_PATH; <br>    ofn.lpstrFileTitle      = NULL; <br>    ofn.nMaxFileTitle       = 0; <br>    ofn.lpstrInitialDir     = gszCDStartPath; <br>    ofn.lpstrTitle          = "File Open"; <br>    ofn.Flags               = OFN_FILEMUSTEXIST | OFN_EXPLORER <br>                                | OFN_ENABLETEMPLATE | OFN_ENABLEHOOK | OFN_HIDEREADONLY; <br>    ofn.nFileOffset         = 0; <br>    ofn.nFileExtension      = 0; <br>    ofn.lpstrDefExt         = "wav"; <br>    ofn.lCustData           = (LONG)lpfSticky; <br>    ofn.lpfnHook            = FileOpenCustomTemplateDlgProc; <br>    ofn.lpTemplateName      = MAKEINTRESOURCE(IDD_FILEOPEN_NEST); <br> <br>    fValid = FALSE; <br>    do   {     <br> <br>    if (fReturn = GetOpenFileName(&amp;ofn)) <br>    {                                <br>// Set the start path for the next time this dialog is opened <br>        lstrcpy( gszCDStartPath, pszFileName ); <br>        gszCDStartPath[ofn.nFileOffset] = '\0'; <br> <br>fValid = IsValidWave(pszFileName); <br>if (!fValid) <br>{ <br>MessageBox(hWnd, "Wave files must be PCM format!", <br>       "Invalid Wave File", MB_OK|MB_ICONSTOP); <br>} <br>else <br>*nFileName = ofn.nFileOffset; <br>    } <br>    else fValid = TRUE;         // Force break out of loop. <br>     <br>    } while (!fValid); <br> <br>    return(fReturn);      <br> <br>} <br> <br>// ======================================================================= <br>/*  This function will determine if the filename passed <br>    in is a valid wave for this <br>    app, that is a PCM wave. <br> <br>    Input: <br>pszFileName -   FileName to check. <br> <br>    Output: <br>FALSE if not a valid wave, TRUE if it is. <br>     <br>*/ <br>// ======================================================================= <br>BOOL IsValidWave(LPSTR pszFileName) <br>{  <br>    BOOL            fReturn     = FALSE; <br>    int             nError      = 0; <br>    HMMIO           hmmio; <br>    MMCKINFO        mmck; <br>    WAVEFORMATEX    *pwfx; <br> <br>    if ((nError = WaveOpenFile(pszFileName, &amp;hmmio, &amp;pwfx, &amp;mmck)) != 0) <br>{        <br>goto ERROR_IN_ROUTINE; <br>} <br> <br>    if (pwfx-&gt;wFormatTag != WAVE_FORMAT_PCM)  <br>{ <br>goto ERROR_IN_ROUTINE; <br>} <br> <br>    WaveCloseReadFile(&amp;hmmio, &amp;pwfx); <br> <br>    fReturn = TRUE; <br> <br>ERROR_IN_ROUTINE: <br>    return(fReturn);     <br> <br>} <br> <br>// ======================================================================= <br>// ======================================================================= <br>BOOL UIMainWindowVSBHandler(HWND hWnd, WPARAM wParam, LPARAM lParam) <br>{ <br> <br>    FILEINFO    *pFileInfo; <br>    BOOL        fReturn             = FALSE; <br> <br>    pFileInfo = FileInfoFirst.pNext; <br> <br>    Assert(pFileInfo != NULL); <br> <br>    while (pFileInfo != NULL) <br>    { <br> <br>    if ((HWND)lParam == pFileInfo-&gt;hWndVolM_TB) <br>    { <br>pFileInfo-&gt;dwVol = MAXVOL_TB - <br>SendMessage(pFileInfo-&gt;hWndVolM_TB, TBM_GETPOS, 0, 0); <br>ChangeOutputVol(pFileInfo); <br>SetAllText(pFileInfo); <br>UpdateLRVolume(pFileInfo); <br>fReturn = TRUE; <br>    } <br> <br>    pFileInfo = pFileInfo-&gt;pNext; <br>     <br>    } <br> <br>    return (fReturn); <br> <br>} <br> <br> <br>// ======================================================================= <br>/*  This routine will handle all the calls to the WM_HSCROLL <br>    for the main window, that <br>    is, all the horizontal scrollbar (and trackbar) messages. <br> <br>    Input: <br>Standard parameters (minus the "message" parameter) <br>for a window callback, though <br>this is called from the window callback. <br> <br>    Output: <br>FALSE if the message isn't processed, else TRUE if it is. <br>If FALSE, the <br>return procedure should call the default windows procedure. <br>*/ <br>// ======================================================================= <br>BOOL UIMainWindowHSBHandler(HWND hWnd, WPARAM wParam, LPARAM lParam) <br>{ <br> <br>    FILEINFO    *pFileInfo; <br>    BOOL        fReturn             = FALSE; <br> <br>    pFileInfo = FileInfoFirst.pNext; <br>     <br>    Assert(pFileInfo != NULL); <br> <br>    while (pFileInfo != NULL) <br>    { <br> <br>    if ((HWND)lParam == pFileInfo-&gt;hWndFreq_TB) <br>    { <br>pFileInfo-&gt;dwFreq = (SendMessage(pFileInfo-&gt;hWndFreq_TB, <br>TBM_GETPOS, 0, 0) * FREQFACTOR) - FREQADD; <br>ChangeOutputFreq(pFileInfo); <br>SetAllText(pFileInfo);           <br>fReturn = TRUE; <br>    } <br> <br>    else if ((HWND)lParam == pFileInfo-&gt;hWndPan_TB) <br>    { <br>pFileInfo-&gt;dwPan = SendMessage(pFileInfo-&gt;hWndPan_TB, <br>       TBM_GETPOS, 0, 0); <br>ChangeOutputPan(pFileInfo); <br>SetAllText(pFileInfo); <br>UpdateLRVolume(pFileInfo); <br>fReturn = TRUE; <br>    } <br> <br>    pFileInfo = pFileInfo-&gt;pNext; <br>     <br>    } <br> <br>    return (fReturn); <br> <br> <br> <br>} <br> <br>// ======================================================================= <br>/*  This routine will handle all the calls to the WM_COMMAND <br>    for the main window. <br> <br>    Input: <br>    Standard parameters (minus the "message" parameter) <br>    for a window callback, though <br>    this is called from the window callback. <br> <br>    Output: <br>FALSE if the message isn't processed, else TRUE if it is. <br>If FALSE, the <br>return procedure should call the default windows procedure. <br> <br> <br>*/ <br>// ======================================================================= <br>BOOL UIMainWindowCMDHandler(HWND hWnd, WPARAM wParam, LPARAM lParam) <br>{ <br> <br>    BOOL        fReturn     = FALSE; <br>    FILEINFO        *pFileInfo; <br>    FILEINFO        *pFileInfoNext; <br>    DWORD       dwLooping; <br> <br>    pFileInfo = FileInfoFirst.pNext; <br>    while (pFileInfo != NULL) <br>    { <br>     <br>    pFileInfoNext = pFileInfo-&gt;pNext; <br>     <br>    if ((HWND)lParam == pFileInfo-&gt;hWndLooped_BN) <br>    { <br>pFileInfo-&gt;fLooped = SendMessage(pFileInfo-&gt;hWndLooped_BN, <br> BM_GETCHECK, 0, 0); <br>// If it is playing then reset the looping to be proper <br>if( pFileInfo-&gt;fPlaying ) { <br>if( pFileInfo-&gt;fLooped ) { <br>    dwLooping = DSBPLAY_LOOPING; <br>} else { <br>    dwLooping = 0; <br>} <br>pFileInfo-&gt;pDSB-&gt;lpVtbl-&gt;Play(pFileInfo-&gt;pDSB, <br>0, 0, dwLooping ); <br>}  <br>fReturn = TRUE; <br>    } <br>    else if ((HWND)lParam == pFileInfo-&gt;hWndPlay_BN) <br>    { <br>if (pFileInfo-&gt;fPlaying) <br>{ <br>if (StopDSound(hWnd, pFileInfo) == 0) <br>{ <br>    SendMessage((HWND)lParam, <br>WM_SETTEXT, 0, (LPARAM)(LPCTSTR)szPlay); <br> <br>#ifdef SHOWSTATUS <br>    UpdateStatus(pFileInfo, 0); <br>#endif <br>     <br>    fReturn = TRUE; <br>    break; <br>} <br> <br>} <br>else             <br>{ <br>if (StartDSound(hWnd, pFileInfo) == 0) <br>{ <br>    SendMessage((HWND)lParam, <br>WM_SETTEXT, 0, (LPARAM)(LPCTSTR)szStop); <br>#ifdef SHOWSTATUS <br>    UpdateStatus(pFileInfo, DSBSTATUS_PLAYING); <br>#endif <br>     <br>    fReturn = TRUE; <br>    break; <br>} <br> <br>} <br>fReturn = TRUE; <br>    } <br> <br>    else if ((HWND)lParam == pFileInfo-&gt;hWndRemove_BN) <br>    { <br>ReleaseDirectSoundBuffer(pFileInfo); <br>RemoveFromList(pFileInfo, &amp;FileInfoFirst); <br>        UpdateMainStatus(); <br> <br>fReturn = TRUE; <br>    } <br> <br> <br>    pFileInfo = pFileInfoNext; <br>     <br>    } <br>     <br>    if (!fReturn) <br>    { <br> <br>    switch(wParam) <br>    { <br> <br>case IDPD_FILE_EXIT:     <br>PostMessage(hWnd, WM_CLOSE, 0, 0); <br>break; <br> <br>case IDPD_FILE_OPEN: <br>PD_FileOpen(hWnd); <br>break; <br>     <br>case IDPD_HELP_ABOUT: <br>DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUT), <br>      hWnd, (DLGPROC)DLGHelpAbout); <br>break; <br> <br>case IDPD_OPTIONS_OUTPUTTYPE: <br>DialogBox(hInst, MAKEINTRESOURCE(IDD_OUTPUTBUFFERTYPE), <br>      hWnd, (DLGPROC)DLGOutputBufferType); <br>break; <br> <br>case IDPD_CHECKLATENCY: <br>StopAllDSounds(hWnd, &amp;FileInfoFirst); <br>// Now fake that we're on in each voice so the <br>//timer will update the  <br>// strings in the window. <br>pFileInfo = FileInfoFirst.pNext; <br>while (pFileInfo != NULL) <br>{                                            <br>    pFileInfo-&gt;fPlaying = TRUE; <br>    pFileInfo = pFileInfo-&gt;pNext;        <br>} <br> <br>DialogBox(hInst, MAKEINTRESOURCE(IDD_CHECKLATENCY), <br>      hWnd, (DLGPROC)DLGCheckLatency); <br>break; <br> <br>    case IDPD_ENUMDRIVERS: <br>fEnumDrivers = !fEnumDrivers; <br>if( fEnumDrivers ) <br>    { <br>    MessageBox( hWnd, <br>    "Drivers will not be enumerated until DSSHOW is run again.", <br>    szAppName, MB_OK ); <br>    } <br>break; <br> <br>default: <br>return(FALSE); <br> <br>    } <br>    } <br> <br>    return(TRUE); <br> <br> <br>} <br> <br>// ======================================================================= <br>/*  This routine will handle the timer messages. <br> <br>    Input: <br>Standard input. <br> <br>    Output:  <br>TRUE if processed message, otherwise FALSE <br>*/ <br>// ======================================================================= <br>BOOL UIMainWindowTimerHandler(HWND hWnd, WPARAM wParam, LPARAM lParam) <br>{ <br>    FILEINFO        *pFileInfo; <br>    BOOL            fReturn             = FALSE; <br>    DWORD           dwStatus            = 0; <br> <br>    for (pFileInfo = FileInfoFirst.pNext; pFileInfo != NULL; pFileInfo = pFileInfo-&gt;pNext) <br>    { <br>    HRESULT hr; <br> <br>    hr = IDirectSoundBuffer_GetStatus(pFileInfo-&gt;pDSB, &amp;dwStatus); <br>    if (DS_OK != hr) continue; <br> <br>    if (dwStatus &amp; DSBSTATUS_BUFFERLOST) { <br>LPBYTE pbData, pbData2; <br>DWORD  dwLength, dwLength2; <br> <br>// <br>//  Restore the buffer, rewrite data, and play <br>// <br>hr = IDirectSoundBuffer_Restore(pFileInfo-&gt;pDSB); <br>if (DS_OK == hr) { <br> <br>hr = IDirectSoundBuffer_Lock(pFileInfo-&gt;pDSB, 0, <br> pFileInfo-&gt;cbSize, <br> &amp;pbData, &amp;dwLength, <br> &amp;pbData2, &amp;dwLength2, <br> 0); <br> <br>if (DS_OK == hr) { <br> <br>    Assert(pbData != NULL); <br>    Assert(pFileInfo-&gt;pbData != NULL); <br>    memcpy(pbData, pFileInfo-&gt;pbData, pFileInfo-&gt;cbSize); <br> <br>    hr = IDirectSoundBuffer_Unlock(pFileInfo-&gt;pDSB, <br>       pbData, dwLength, <br>       NULL, 0); <br> <br>    if (DS_OK == hr) { <br> <br>    if (pFileInfo-&gt;fPlaying) { <br>if (pFileInfo-&gt;fLooped) { <br>IDirectSoundBuffer_Play( pFileInfo-&gt;pDSB, 0, 0, <br> DSBPLAY_LOOPING ); <br>} else { <br>IDirectSoundBuffer_Play( pFileInfo-&gt;pDSB, 0, 0, <br> 0 ); <br>} <br>    } <br> <br>    IDirectSoundBuffer_GetStatus(pFileInfo-&gt;pDSB, &amp;dwStatus); <br> <br>    } <br>} <br>} <br>    } <br> <br>#ifdef SHOWSTATUS <br>    UpdateStatus(pFileInfo, dwStatus); <br>#endif <br> <br>    if (!(dwStatus &amp; DSBSTATUS_BUFFERLOST)) <br>    { <br>if ((pFileInfo-&gt;fPlaying) &amp;&amp; (!(dwStatus &amp; DSBSTATUS_PLAYING)) ) <br>{ <br>if (StopDSound(hWnd, pFileInfo) == 0) <br>{ <br>    SendMessage(pFileInfo-&gt;hWndPlay_BN, <br>WM_SETTEXT, 0, (LPARAM)(LPCTSTR)szPlay); <br>} <br>} <br>    } <br> <br>    pFileInfo-&gt;fLost = dwStatus &amp; DSBSTATUS_BUFFERLOST; <br> <br>    fReturn = TRUE; <br>    } <br> <br>    return (fReturn); <br> <br>}    <br> <br> <br> <br>// ======================================================================= <br>/*  This routine will start a sound to be played.   <br>    Input: <br>hWnd        -   Of parent window. <br>pFileInfo   -   Pointer to file to start, <br>which is loaded and the <br>data is filled in the structure, <br>such as pbData,  <br>etc. <br> <br>    Output: <br>0 if successful, else the error code. <br>*/ <br>// ======================================================================= <br>int StartDSound(HWND hWnd, FILEINFO *pFileInfo) <br>{ <br>    HRESULT     hr              = 0; <br>    DWORD           dwLooped; <br>    DWORD           dwStatus                = 0; <br> <br>    // Already playing? <br> <br>    // Start sound here.... <br>    dwLooped = 0; <br>    if (pFileInfo-&gt;fLooped) { <br>    dwLooped = DSBPLAY_LOOPING; <br>    } <br>     <br> <br>    if ((hr = pFileInfo-&gt;pDSB-&gt;lpVtbl-&gt;GetStatus(pFileInfo-&gt;pDSB, <br> &amp;dwStatus)) == 0) <br>    { <br>    if ((dwStatus&amp;DSBSTATUS_PLAYING) == DSBSTATUS_PLAYING) <br>    { <br>// Don't bother playing, just restart <br>if ((hr = pFileInfo-&gt;pDSB-&gt;lpVtbl-&gt;SetCurrentPosition( <br>    pFileInfo-&gt;pDSB, 0)) != 0) <br>{ <br>MessageBox(hWnd, "Cannot set current position", <br>       "Direct Sound Error", MB_OK); <br>} <br>    } <br>    // Yes gotos are bad but this is real life not school. <br>    else goto PLAY_THE_THING;            <br>    } <br>     <br>    else <br>    { <br>PLAY_THE_THING: <br>    if ((hr = pFileInfo-&gt;pDSB-&gt;lpVtbl-&gt;Play(pFileInfo-&gt;pDSB, <br>    0, 0, dwLooped)) != 0) <br>    { <br>    MessageBox(hWnd, "Cannot start playing", <br>   "Direct Sound Error", MB_OK); <br>    } <br>    else <br>    pFileInfo-&gt;fPlaying = TRUE; <br>    } <br> <br>    return(hr); <br> <br> <br>} <br> <br>// ======================================================================= <br>/*  This routine will stop a sound which is playing. <br> <br>    Input: <br>hWnd        - Of parent window. <br>pFileInfo       - Pointer to file to stop playing. <br> <br>    Output: <br>0 if successful, else the error code. <br> <br>*/ <br>// ======================================================================= <br>int StopDSound(HWND hWnd, FILEINFO *pFileInfo) <br>{ <br>    HRESULT     hr          = 0; <br> <br>    if (!pFileInfo-&gt;fPlaying) <br>    return(0); <br>    <br> <br>    // Stop sound here... <br>    if ((hr = pFileInfo-&gt;pDSB-&gt;lpVtbl-&gt;Stop(pFileInfo-&gt;pDSB)) != 0)  <br>    { <br>    MessageBox(hWnd, "Cannot stop sound", <br>   "Direct Sound Error", MB_OK);         <br>    } </code></pre>
<p>
</p>
<pre><code>else <br>    pFileInfo-&gt;fPlaying = FALSE;     <br> <br>    return(hr); <br> <br>} <br> <br>// ======================================================================= <br>/*  This routine will stop all the sounds which are playing. <br> <br>    Input: <br>hWnd        - Of parent window. <br>pFileInfo   - Pointer to file to stop playing. <br>(i.e. the head) <br> <br>    Output: <br>0 if successful, else the error code. <br> <br>*/ <br>// ======================================================================= <br>int StopAllDSounds(HWND hWnd, FILEINFO *pFileInfo) <br>{ <br>    while (pFileInfo-&gt;pNext != NULL) <br>{ <br>StopDSound(hWnd, pFileInfo-&gt;pNext); <br>pFileInfo = pFileInfo-&gt;pNext;        <br>} <br> <br>    return(0); <br> <br>} <br> <br> <br> <br>// ======================================================================= <br>/*  This routine will set the freq, vol and pan slider text <br>    according to the value  <br>    passed in. <br> <br>    Input: <br>pFileInfo   -   File pointer to set frequency for. <br> <br>    The dwFreq in the pFileInfo structure must be set. <br>    This also uses the window handle <br>    in the pFileInfo structure. <br>     <br>    Output: <br>None. <br>*/ <br>// ======================================================================= <br>void SetAllText(FILEINFO    *pFileInfo) <br>{ <br>    char            szBufT[128]; <br> <br>    sprintf(szBufT, "%s: %lu Hz     ", <br>szFreq, pFileInfo-&gt;dwFreq); <br>    SetWindowText(pFileInfo-&gt;hWndFreq_TXT, szBufT); <br> <br>    // Change PAN val to show full range <br>    sprintf(szBufT, "%s: %ld", szPan, <br>(((LONG)(pFileInfo-&gt;dwPan) + SHIFTPAN_TB) * MULTPAN_TB ) ); <br>    SetWindowText(pFileInfo-&gt;hWndPan_TXT, szBufT); <br> <br>    // Change VOLUME val to show full range <br>    sprintf(szBufT, "%s: %ld", szVolume, <br>(((LONG)(pFileInfo-&gt;dwVol) + SHIFTVOL_TB) * MULTVOL_TB )); <br>    SetWindowText(pFileInfo-&gt;hWndVol_TXT, szBufT); <br> <br> <br>} <br> <br>// ======================================================================= <br>/*  This routine will update the left and right <br>    volume according to main volume  <br>    and pan. <br> <br>    Input: <br>pFileInfo   - Pointer to fileinfo to update. <br> <br>    Output: <br>Nothing worth using. <br>*/ <br>// ======================================================================= <br>void UpdateLRVolume(FILEINFO *pFileInfo) <br>{ <br> <br>    int             volLeft, volRight; <br> <br>    if (pFileInfo-&gt;dwPan &lt; MIDPAN_TB) <br>    { <br>    volLeft = pFileInfo-&gt;dwVol; <br>    volRight = (((int)pFileInfo-&gt;dwPan) <br>    *(int)pFileInfo-&gt;dwVol)/((int)MIDPAN_TB); <br>    } <br>    else <br>    { <br>    volLeft = ((((int)pFileInfo-&gt;dwPan - MAXPAN_TB)*-1) <br>   *(int)pFileInfo-&gt;dwVol)/((int)MIDPAN_TB); <br>    volRight = pFileInfo-&gt;dwVol; <br>    } <br> <br> <br> <br>    SendMessage(pFileInfo-&gt;hWndVolL_TB, TBM_SETPOS, TRUE, MAXVOL_TB-volLeft); <br>    SendMessage(pFileInfo-&gt;hWndVolR_TB, TBM_SETPOS, TRUE, MAXVOL_TB-volRight); <br>     <br> <br> <br>} <br> <br>// ======================================================================= <br>/*  This will change the output panning position for a certain FILEINFO. <br>    This is  <br>    done by sending messages to the direct sound driver  <br> <br>    Input:   <br>pFileInfo   -   FileInfo to set.  This must contain the <br>panning value to set. <br> <br>    Output: <br>0 if successful, else the error code. <br> <br>*/ <br>// ======================================================================= <br>int ChangeOutputPan(FILEINFO *pFileInfo) <br>{ <br> <br>    HRESULT     hr      = 0; <br> <br>    // Change PAN val  since TB does not go full range <br>    if ((hr = pFileInfo-&gt;pDSB-&gt;lpVtbl-&gt;SetPan(pFileInfo-&gt;pDSB, <br>(((pFileInfo-&gt;dwPan) + SHIFTPAN_TB) * MULTPAN_TB) )) != 0) <br>    { <br>goto ERROR_DONE_ROUTINE; <br>    } <br> <br>ERROR_DONE_ROUTINE: <br>    return(hr); <br> <br>} <br> <br>// ======================================================================= <br>/*  This will change the output freq for a certain FILEINFO.  This is  <br>    done by sending messages to the direct sound driver  <br> <br>    Input:   <br>pFileInfo                   -   FileInfo to set.  This must contain the <br>freq value to set. <br> <br>    Output: <br>0 if successful, else the error code. <br> <br>*/ <br>// ======================================================================= <br>int ChangeOutputFreq(FILEINFO *pFileInfo) <br>{ <br> <br>    HRESULT     hr      = 0; <br> <br>    if ((hr = pFileInfo-&gt;pDSB-&gt;lpVtbl-&gt;SetFrequency(pFileInfo-&gt;pDSB, pFileInfo-&gt;dwFreq)) != 0) <br>{ <br>goto ERROR_DONE_ROUTINE; <br>} <br> <br>ERROR_DONE_ROUTINE: <br>    return(hr); <br> <br>} <br> <br> <br> <br>// ======================================================================= <br>/*  This will change the output vol for a certain FILEINFO.  This is  <br>    done by sending messages to the direct sound driver  <br> <br>    Input:   <br>pFileInfo                   -   FileInfo to set.  This must contain the <br>freq value to set. <br> <br>    Output: <br>0 if successful, else the error code. <br> <br>*/ <br>// ======================================================================= <br>int ChangeOutputVol(FILEINFO *pFileInfo) <br>{ <br> <br>    HRESULT     hr      = 0; <br> <br>    // Shift VOLUME val by 4 bits since TB does not go full range <br>    if ((hr = pFileInfo-&gt;pDSB-&gt;lpVtbl-&gt;SetVolume(pFileInfo-&gt;pDSB, <br>(((pFileInfo-&gt;dwVol) + SHIFTVOL_TB) * MULTVOL_TB) )) != 0) <br>{ <br>goto ERROR_DONE_ROUTINE; <br>} <br> <br>ERROR_DONE_ROUTINE: <br>    return(hr); <br> <br>} <br> <br> <br>// ======================================================================= <br>/*  This is the dialog box handler for the check latency dialog box. <br> <br>    Input: <br>Standard dialog box input. <br> <br>    Output: <br>Standard dialog box output. <br> <br>*/ <br>// ======================================================================= <br>long FAR PASCAL DLGCheckLatency(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) <br>{ <br> <br>    static HWND     hWndFiles_LB; <br>    FILEINFO        *pFileInfo              = NULL; <br>    int         nSelected; <br>    int         cT; <br> <br> <br>    switch(uMsg) <br>    { <br>    case WM_INITDIALOG: <br>hWndFiles_LB = GetDlgItem(hWnd, IDC_FILES_LB); <br> <br>pFileInfo = FileInfoFirst.pNext; <br>while (pFileInfo != NULL) <br>{                <br>SendMessage(hWndFiles_LB, <br>LB_ADDSTRING, <br>0, <br>(LPARAM)(pFileInfo-&gt;szFileName <br>     + pFileInfo-&gt;nFileName)); <br>pFileInfo = pFileInfo-&gt;pNext;        <br>} <br> <br>break;       <br> <br>    case WM_COMMAND: <br>switch(wParam) <br>{ <br>case ID_DONE:                    <br>    PostMessage(hWnd, WM_CLOSE, 0, 0); <br>    break; <br>     <br>case ID_PLAY:                        <br>    if ((nSelected = SendMessage(hWndFiles_LB, <br> LB_GETCURSEL, 0, 0)) <br>!= LB_ERR) <br>    { <br>    for (cT=0, pFileInfo = FileInfoFirst.pNext; <br>pFileInfo != NULL; <br>pFileInfo = pFileInfo-&gt;pNext, cT++) <br>    { <br>if (cT == nSelected) <br>{ <br>StartDSound(hWnd, pFileInfo); <br>break; <br>} <br>    } <br>     <br>    } <br>     <br>    break; <br>     <br>case ID_STOP: <br>    StopAllDSounds(hWnd, &amp;FileInfoFirst); <br>    break; <br>     <br>default: <br>    break; <br>     <br>} <br>break; <br> <br>    case WM_CLOSE: <br>StopAllDSounds(hWnd, &amp;FileInfoFirst); <br>EndDialog(hWnd, 0); <br>break; <br> <br>    default: <br>return(0); <br>break;                <br> <br>    } <br>     <br>    return(1); <br> <br>} <br> <br> <br>// ======================================================================= <br>/*  The help about dialog procedure.   <br>     <br>    Input: <br>Standard windows dialog procedure. <br> <br>    Output: <br>Standard windows dialog procedure. <br> <br>*/ <br>// ======================================================================= <br>long FAR PASCAL DLGHelpAbout(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) <br>{ <br>    switch(uMsg) <br>    { <br>    case WM_INITDIALOG: <br>break;       <br> <br>    case WM_COMMAND: <br>switch(wParam) <br>{ <br>case ID_OK:                  <br>    PostMessage(hWnd, WM_CLOSE, 0, 0); <br>    break; <br>     <br>default: <br>    break; <br>     <br>} <br>break; <br> <br>    case WM_CLOSE: <br>EndDialog(hWnd, 0); <br>break; <br> <br>    default: <br>return(0); <br>break;                <br> <br>    } <br>     <br>    return(1); <br> <br>} <br> <br> <br>// ======================================================================= <br>/*  The help about dialog procedure.   <br>     <br>    Input: <br>Standard windows dialog procedure. <br> <br>    Output: <br>Standard windows dialog procedure. <br> <br>*/ <br>// ======================================================================= <br>long FAR PASCAL DLGOutputBufferType(HWND hWnd,UINT uMsg, WPARAM wParam, LPARAM lParam) <br>{ <br> <br>    static HWND     hWndFormats_LB          = NULL; <br>    int         cT; <br>    int         nSelection; <br> <br>      <br>    switch(uMsg) <br>    { <br>    case WM_INITDIALOG: <br>// Get the windows we need. <br>hWndFormats_LB = GetDlgItem(hWnd, IDC_FORMATS); <br> <br>// Put the strings in the list box. <br>for (cT=0; cT&lt;C_DROPDOWNPCMFORMATS; cT++) <br>SendMessage(hWndFormats_LB, <br>LB_ADDSTRING, 0, (LPARAM)rgszTypes[cT]); <br> <br>// Get the current format and highlight it in the list box. <br>if ((nSelection = FormatToIndex(hWnd, &amp;FileInfoFirst)) != LB_ERR) <br>{ <br>SendMessage(hWndFormats_LB, LB_SETCURSEL, nSelection, 0); <br>} <br> <br> <br>break;       <br> <br>    case WM_COMMAND: <br>    switch(LOWORD(wParam)) <br>{ <br>case IDC_FORMATS: <br>    if( HIWORD( wParam ) == LBN_DBLCLK ) <br>{ <br>SendMessage( hWnd, WM_COMMAND, MAKEWPARAM( ID_OK, 0 ), <br>0L ); <br>} <br>    break; <br> <br>case ID_OK: <br>    if ((nSelection = SendMessage(hWndFormats_LB, <br>LB_GETCURSEL, 0, 0)) != LB_ERR) <br>    { <br>    if (IndexToFormat(hWnd, &amp;FileInfoFirst, nSelection) <br>    == 0) <br>PostMessage(hWnd, WM_CLOSE, 0, 0); <br>    } <br>    break; <br> <br>case ID_CANCEL:                  <br>    PostMessage(hWnd, WM_CLOSE, 0, 0); <br>    break; <br> <br>case ID_APPLY:                   <br>    if ((nSelection = SendMessage(hWndFormats_LB, <br>LB_GETCURSEL, 0, 0)) != LB_ERR) <br>    IndexToFormat(hWnd, &amp;FileInfoFirst, nSelection); <br> <br>    break; <br> <br> <br>default: <br>    break; <br> <br>} <br>break; <br> <br>    case WM_CLOSE: <br>EndDialog(hWnd, 0); <br>break; <br> <br>    default: <br>return(0); <br>break;                <br> <br>    } <br> <br>    return(1); <br> <br>} <br> <br>// ======================================================================= <br>/*  This routine will determine the output format in <br>    terms of an integer from the <br>    current output rate, type, etc. <br>    stored in the direct sound routines.   Integer <br>    values designate the string # in rgszTypes, <br>    i.e. index 0 is 8000kHz, 8 bit mono,  <br>    etc... <br> <br>    Input: <br>hWnd    - Handle of the current window. <br>pFileInfo   - Pointer to the file info to retrieve the format for. <br> <br>    Output: <br>The index of the format, LB_ERR if undetermined. <br> <br>*/ <br>// ======================================================================= <br>int FormatToIndex(HWND hWnd, FILEINFO *pFileInfo) <br>{ <br> <br>    WAVEFORMATEX    wfx; <br>    DWORD       dwWaveStyle; <br>    DWORD       dwSize; <br>    int         nError              = 0; <br> <br>    // Get the format. <br>    if ((nError = pFileInfo-&gt;pDSB-&gt;lpVtbl-&gt;GetFormat(pFileInfo-&gt;pDSB, <br>    &amp;wfx, sizeof(wfx), &amp;dwSize)) != 0) <br>    { <br>    goto ERROR_IN_ROUTINE; <br>    } <br>    if( dwSize &gt; sizeof( wfx ) ) { <br>    nError = DSERR_GENERIC; <br>    goto ERROR_IN_ROUTINE; <br>    } <br> <br> <br>    // Change wfx to an integer. <br>    // Assume theres an error and check all parameters to  <br>    // see if its valid. <br>    nError = LB_ERR; <br>    dwWaveStyle = 0; <br> <br>    if (wfx.wFormatTag != WAVE_FORMAT_PCM) <br>   goto ERROR_IN_ROUTINE; <br> <br>    // Check the channels <br>switch (wfx.nChannels) <br>{ <br>case 1: <br>break; <br> <br>case 2: <br>    dwWaveStyle |= 1; <br>break; <br> <br>    default: <br>goto ERROR_IN_ROUTINE; <br>} <br> <br>    // Check the bits... <br>switch (wfx.wBitsPerSample) <br>{ <br>case 8: <br>break; <br> <br>case 16: <br>dwWaveStyle |= 2; <br>break; <br> <br>    default: <br>goto ERROR_IN_ROUTINE; <br>    } <br> <br>    // Check the rate. <br>switch(wfx.nSamplesPerSec) <br>{ <br>case 8000: <br>break; <br> <br>case 11025: <br>    dwWaveStyle |= 4; <br>break; <br> <br>case 22050: <br>    dwWaveStyle |= 8; <br>break; <br> <br>case 44100: <br>    dwWaveStyle |= 12; <br>break; <br> <br>    default: <br>goto ERROR_IN_ROUTINE; <br>    } <br> <br>    nError = (int)dwWaveStyle; <br> <br>ERROR_IN_ROUTINE: <br>    return(nError); <br>} <br> <br> <br>// ======================================================================= <br>/*  This will convert an index (from a list box for instance) <br>    to a format by passing <br>    in the format to direct sound. <br> <br>    Input: <br>hWnd        -   Handle to window. <br>pFileInfo   -   Pointer to current file info. <br>index       -   Index value to convert to a <br>    waveformat structure. <br> <br>    Output: <br>0 if successful, else the error code. <br>*/ <br>// ======================================================================= <br>int IndexToFormat(HWND hWnd, FILEINFO *pFileInfo, int index) <br>{ <br> <br>    int         nError      = 0; <br> <br> <br>    pFileInfo-&gt;pwfx-&gt;wFormatTag = WAVE_FORMAT_PCM; <br> <br>    pFileInfo-&gt;pwfx-&gt;nChannels = 2;                                     // Assume stereo. <br>    if ((index%2) == 0) <br>    pFileInfo-&gt;pwfx-&gt;nChannels = 1;                                 // Its mono. <br> <br>    // Assume 16 bit     <br>    pFileInfo-&gt;pwfx-&gt;nBlockAlign = 2*pFileInfo-&gt;pwfx-&gt;nChannels; <br>    pFileInfo-&gt;pwfx-&gt;wBitsPerSample = 16; <br>    if ((index%4) &lt; 2) { <br>    // Its 8 bit. <br>    pFileInfo-&gt;pwfx-&gt;nBlockAlign = 1*pFileInfo-&gt;pwfx-&gt;nChannels; <br>    pFileInfo-&gt;pwfx-&gt;wBitsPerSample = 8; <br>    } <br>     <br>    pFileInfo-&gt;pwfx-&gt;nSamplesPerSec = 44100;    // Assume 44.1 kHz <br>    if (index &lt; 4) <br>pFileInfo-&gt;pwfx-&gt;nSamplesPerSec = 8000; <br>    else if (index &lt; 8) <br>pFileInfo-&gt;pwfx-&gt;nSamplesPerSec = 11025; <br>    else if (index &lt; 12) <br>pFileInfo-&gt;pwfx-&gt;nSamplesPerSec = 22050; <br>     <br>     <br>    pFileInfo-&gt;pwfx-&gt;nAvgBytesPerSec = pFileInfo-&gt;pwfx-&gt;nSamplesPerSec * <br>       pFileInfo-&gt;pwfx-&gt;nBlockAlign;                                         <br>    pFileInfo-&gt;pwfx-&gt;cbSize = 0; <br> <br>    if ((nError = pFileInfo-&gt;pDSB-&gt;lpVtbl-&gt;SetFormat(pFileInfo-&gt;pDSB, <br>pFileInfo-&gt;pwfx)) != DS_OK)         { <br>MessageBox(hWnd, "Cannot set format buffer", <br>   "Direct Sound Error", MB_OK); <br>    goto ERROR_DONE_ROUTINE; <br> <br>    } <br> <br>ERROR_DONE_ROUTINE: <br>    return(nError); <br> <br>} <br> <br> <br>// ======================================================================= <br>/* GetMediaStartPath()                                                      */ <br>/*                                                                          */ <br>/*   This helper function attempts to get the media directory for Direct3D, */ <br>/* which is where all the installed DX wave files go. If it can't find that */ <br>/* it settles for the media sub-directory of the Windows directory.         */ <br>// ======================================================================= <br>void GetMediaStartPath( void ) <br>    { <br>    HKEY    hReg; <br>    DWORD   cbStartPathLen; <br> <br>    if( ERROR_SUCCESS != RegOpenKeyEx( HKEY_LOCAL_MACHINE, <br>gszRegKeyDirect3D, <br>0, KEY_READ, &amp;hReg )) <br>{ <br>        goto REG_OPEN_FAILED; <br>} <br>    else <br>{ <br>// Query the Registry for the path to the media directory <br>cbStartPathLen = sizeof( gszCDStartPath ); <br>if( ERROR_SUCCESS != RegQueryValueEx( hReg, gszRegValueD3DPath, <br>NULL, NULL, <br>gszCDStartPath, &amp;cbStartPathLen )) <br>    { <br>    goto REG_OPEN_FAILED; <br>    } <br>RegCloseKey( hReg ); <br>hReg = NULL; <br>} <br> <br>    return; <br> <br>REG_OPEN_FAILED: <br>    // Start off by getting the Windows directory -- we're trying to build a <br>    // file path like "C:\WINDOWS\MEDIA", but the WINDOWS directory could be <br>    // named anything, so we must ask. <br>    GetWindowsDirectory( gszCDStartPath, sizeof(gszCDStartPath)); <br>    // If there's no trailing backslash, append one <br>    if( lstrcmp( &amp;gszCDStartPath[lstrlen(gszCDStartPath)], TEXT("\\") )) <br>lstrcat( gszCDStartPath, TEXT("\\")); <br>    // Now add on the MEDIA part of the path <br>    lstrcat( gszCDStartPath, TEXT("MEDIA")); <br>    } <br> <br> <br>// ======================================================================= <br>// fGetToken() <br>// <br>//    Parses the command-line string "in place" starting at pszStart.  A ptr <br>// to the start of the next token and it's length will be the out parameters, <br>// or NULL and 0 if no token.  Note that *ppszRet will NOT be NULL-terminated <br>// since the string is part of another string.  That's what then length is for. <br>// <br>// Returns: TRUE if a token was retrieved, or FALSE if there was no token. <br>// ======================================================================= <br>BOOL fGetToken( PSTR pszStart, PSTR *ppszRet, int *pcchRet ) <br>    { <br>    PSTR  pszCur = pszStart; <br>    PSTR  pszTokStart; <br> <br>    if( !pszStart || NULL == ppszRet || NULL == pcchRet ) <br>return FALSE; <br> <br>    // Skip leading whitespace <br>    while( *pszCur &amp;&amp; (*pszCur == ' ' || *pszCur == '\t')) <br>pszCur++; <br> <br>    *ppszRet = NULL; <br>    *pcchRet = 0; <br> <br>    if( *pszCur ) <br>{ <br>pszTokStart = pszCur; <br> <br>while( *pszCur &amp;&amp; *pszCur != ' ' &amp;&amp; *pszCur != '\t' ) <br>    pszCur++; <br> <br>*ppszRet = pszTokStart; <br>*pcchRet = (int)(pszCur - pszTokStart); <br>} <br> <br>    if( *pcchRet != 0 ) <br>return TRUE; <br>    else <br>return FALSE; <br>    } <br> <br> <br>// ======================================================================= <br>// fMatchToken() <br>// <br>//    Attempts to match the first cchLen characters of pszDatum to the <br>// string at pszString.  The comparison is case-insensitive (this function <br>// is designed for command-line switch matching). <br>// <br>// Returns: TRUE if the first cchLen characters are a match, else FALSE. <br>// ======================================================================= <br>BOOL fMatchToken( PSTR pszString, PSTR pszDatum, int cchLen ) <br>    { <br>    inti; <br> <br>    for( i = 0; i &lt; cchLen; i++ ) <br>{ <br>if( CharLower( (LPTSTR)MAKELONG( pszString[i], 0 )) <br>    != CharLower( (LPTSTR)MAKELONG( pszDatum[i], 0 ))) <br>    return FALSE; <br>} <br>    return TRUE; <br>    } <br> <br> <br>// ======================================================================= <br>// ParseCommandLine() <br>// <br>//    Given a command-line string without the module name, this function will <br>// parse the command line and takes action on whatever it finds there. <br>// <br>// Returns: TRUE if successful, or FALSE if there was an error. <br>// ======================================================================= <br>BOOL ParseCommandLine(LPSTR lpszCmdLine) <br>    { <br>    PSTRpszCur,pszToken; <br>    PSTRppszFiles[MAXCONTROLS]; <br>    BOOLfStartPlaying = FALSE, fStartLooping = FALSE; <br>    intcchTokLen = 0, i, nFilesFound; <br> <br>    pszCur = lpszCmdLine; <br> <br>    // First get all the command line switches <br>    while( fGetToken(pszCur, &amp;pszToken, &amp;cchTokLen) &amp;&amp; <br>   (pszToken[0] == '/' || pszToken[0] == '-' )) <br>{ <br>pszCur = pszToken + cchTokLen; <br>pszToken++; <br> <br>if( fMatchToken( pszToken, "PLAY", 4 )) <br>    { <br>    fStartPlaying = TRUE; <br>    } <br>else if( fMatchToken( pszToken, "LOOP", 4 )) <br>    { <br>    fStartLooping = TRUE; <br>    } <br>else <br>    { <br>    // We don't recognize this mysterious switch, so eat it and move on <br>    } <br>} <br> <br>    // Anything left on the command-line will be treated as a filename and <br>    // we'll attempt to open it after we've found them all <br>    nFilesFound = 0; <br>    while( fGetToken(pszCur, &amp;pszToken, &amp;cchTokLen) &amp;&amp; nFilesFound &lt; MAXCONTROLS ) <br>{ <br>pszCur = pszToken + cchTokLen; <br>ppszFiles[nFilesFound] = GlobalAllocPtr( GPTR, (cchTokLen+1)*sizeof(char)); <br>// Copy the token out of the command-line string and into our buffer <br>CopyMemory( ppszFiles[nFilesFound], pszToken, cchTokLen*sizeof(char)); <br>// Append a NULL terminator to what we just copied (to be safe) <br>*(ppszFiles[nFilesFound] + cchTokLen) = 0; <br>nFilesFound++; <br>} <br>    // This function will take the array of strings we've created and open <br>    // each string as a file.  It will obey the global fStartPlaying and <br>    // fStartLooping flags we may have already set above <br>    if( nFilesFound ) <br>BatchOpenFiles( ppszFiles, nFilesFound, fStartPlaying, fStartLooping ); <br> <br>    // Free the space we allocated <br>    for( i = 0; i &lt; nFilesFound; i++ ) <br>{ <br>GlobalFreePtr( ppszFiles[i] ); <br>ppszFiles[i] = NULL; <br>} <br> <br>    // Returning TRUE means the caller should continue doing what they <br>    // were doing: we succeeded. <br>    return TRUE; <br>    } <br> <br> <br>// ======================================================================= <br>// BatchOpenFiles() <br>// <br>//    Takes an array of string pointers and tries to open each as a file to <br>// playback.  If fPlay is TRUE, the files will be played as they are being <br>// opened.  If fLoop is TRUE, they will also be set to loop. <br>// <br>// Returns: FALSE in the event of catastrophic failure, otherwise TRUE. <br>// ======================================================================= <br>BOOL BatchOpenFiles( PSTR *ppszFiles, int nFiles, BOOL fPlay, BOOL fLoop ) <br>    { <br>    int i; <br>    FILEINFO *pfi; <br>    DWORD cSamples; <br> <br>    // Cap the number of files we can load out of the given set if we'd load <br>    // too many otherwise <br>    if( GetNumControls(&amp;FileInfoFirst) + nFiles &gt; MAXCONTROLS ) <br>nFiles = MAXCONTROLS - GetNumControls(&amp;FileInfoFirst); <br> <br>    for( i = 0; i &lt; nFiles; i++ ) <br>{ <br>if(( pfi = GlobalAllocPtr(GPTR, sizeof(FILEINFO))) == NULL ) <br>    goto BOF_Fail; <br> <br>ZeroMemory( pfi, sizeof(FILEINFO)); <br>strcpy( pfi-&gt;szFileName, ppszFiles[i] ); <br> <br>if( WaveLoadFile( ppszFiles[i], &amp;pfi-&gt;cbSize, &amp;cSamples, <br>  &amp;pfi-&gt;pwfx, &amp;pfi-&gt;pbData ) != 0 ) <br>    goto BOF_LoopError; <br> <br>GetNextControlCoords( &amp;FileInfoFirst, &amp;pfi-&gt;cox, &amp;pfi-&gt;coy ); <br>if( NewDirectSoundBuffer(pfi) != 0) <br>    goto BOF_LoopError; <br>Assert( pfi-&gt;pbData != NULL ); <br> <br>if( AddToList( &amp;FileInfoFirst, pfi ) != 0 ) <br>    goto BOF_LoopError; <br> <br>pfi-&gt;nFileName = 0; <br> <br>if( CreateControl( hWndMain, pfi, pfi-&gt;pwfx-&gt;nSamplesPerSec, <br>       (MAXPAN_TB-MINPAN_TB)/2, MINVOL_TB ) != 0 ) <br>    { <br>    ReleaseDirectSoundBuffer(pfi); <br>    RemoveFromList( pfi, &amp;FileInfoFirst ); <br>    // RemoveFromList will do all the cleanup <br>    pfi = NULL; <br>    goto BOF_LoopError; <br>    } <br>ChangeOutputVol(pfi); <br>ChangeOutputFreq(pfi); <br>ChangeOutputPan(pfi); <br> <br>// LOOP is only obeyed if PLAY was also specified <br>if( fPlay ) <br>    { <br>    if( fLoop ) <br>{ <br>pfi-&gt;fLooped = TRUE; <br>SendMessage( pfi-&gt;hWndLooped_BN, BM_SETCHECK, TRUE, 0L ); <br>} <br>    SendMessage( hWndMain, WM_COMMAND, 0, (LPARAM)pfi-&gt;hWndPlay_BN ); <br>    } <br> <br>// Avoid the in-loop error cleanup by using a continue statement here <br>// to jump back up to the top <br>continue; <br> <br>// Cleanup code in case we fail to open a particular file -- we should <br>// just ignore this one and continue because we might still be able to <br>// open other files <br>    BOF_LoopError: <br>if( NULL != pfi ) <br>    { <br>    if( NULL != pfi-&gt;pwfx ) <br>{ <br>GlobalFreePtr(pfi-&gt;pwfx); <br>pfi-&gt;pwfx = NULL; <br>} <br>    if( NULL != pfi-&gt;pbData ) <br>{ <br>GlobalFreePtr(pfi-&gt;pbData); <br>pfi-&gt;pbData = NULL; <br>} <br> <br>    ReleaseDirectSoundBuffer(pfi); <br>    GlobalFreePtr(pfi); <br>    pfi = NULL; <br>    } <br>} <br> <br>    UpdateMainStatus(); <br> <br>    return TRUE; <br> <br>BOF_Fail: <br>    return FALSE; <br>    } <br> <br> <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
