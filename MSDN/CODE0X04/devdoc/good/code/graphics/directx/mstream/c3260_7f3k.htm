<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>README.TXT</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3260"></a>README.TXT</h2>
<pre><code><br>                                   MSTREAM <br>  <br>                        Design Description and Notes <br> <br>   The MSTREAM sample application is an example of how you can use the new <br>midiStream API that's built into Windows 95 to play MIDI data with low <br>latency and low processor overhead. <br> <br>   The basic idea behind the implementation is to start the application and <br>initialize the user interface.  After that's done, the following events occur. <br> <br>When a user selects and opens a file <br>------------------------------------ <br>Open a MIDI output device (the Microsoft MIDI Mapper in this case) <br>Open the file using buffered I/O and fill our buffers with data in MIDI stream <br>   format <br>Prepare and queue the buffers using midiOutPrepareHeader and midiStreamOut <br>Wait until the user decides to do something else <br> <br>When PLAY is selected <br>--------------------- <br>Call midiStreamRestart to un-pause the device and begin playback <br>As buffers are returned, the callback function fills them with more data and <br>sends them back to be played by calling midiStreamOut() again.  IT IS <br>IMPORTANT THAT YOU NOTE THAT IT IS NOT NECESSARY FOR YOU TO UNPREPARE AND <br>PREPARE BUFFERS EVERY TIME THEY ARE RETURNED.  This is only a waste of time. <br>All you have to do is send them back into the subsystem with midiStreamOut(). <br>The API documentation is a bit confusing on this point. <br> <br>When PAUSE is selected <br>---------------------- <br>Call midiStreamPause() and wait for a PLAY or PAUSE to call midiStreamRestart(). <br>Note that pausing may make your audio sound kind of funny, since all notes are <br>turned off and some note on events may be lost when playback is restarted. <br> <br>When STOP is selected <br>--------------------- <br>Call midiStreamStop().  Since the callback function is in another thread, we <br>use a Win32 synchronization object, an event to block the main thread until <br>the callback thread has received all buffers.  When this happens, we know it's <br>okay to go ahead and call midiStreamReset() and then to go ahead and free all <br>our buffers.  Currently, the device is also closed using midiStreamClose(). <br>Then, if we are resetting the file to playback starting at its beginning point <br>the next time PLAY is hit, reopen the file by calling StreamBufferSetup(), <br>which is the workhorse function for opening a file and initializing the <br>the converter and the buffers. <br> <br>Note that the reason we must close and reopen the device is due to an apparent <br>bug in the Multimedia System which causes undesireable playback once a device <br>has been stopped.  If you disable the code for closing the device, then the rest <br>of the code will automatically know it does not have to reopen the device. <br>However, the following may occur: After the first instance of playback followed <br>by a midiStreamStop() and a midiStreamReset(), there will be a pause equal in <br>length to the first playback period before playback begins once more with a call <br>to midiStreamRestart(). <br> <br>If Looped is selected <br>--------------------- <br>Notice that the converter has a little function in it called RewindConverter() <br>which is called by ConvertToBuffer() if the bLooped variable is TRUE.  This <br>function resets the track state structures and performs most of the steps <br>originally executed in ConvertInit() with the notable exception of opening the <br>file and reading in file and track header data.  It simply resets the tracks <br>to their initial state. <br> <br> <br>More on the buffering scheme <br>---------------------------- <br>Note that there is an OUT_BUFFER_SIZE and a BUFFER_TIME_LENGTH.  The idea is <br>that the converter counts ticks and calculates when it has put at least <br>BUFFER_TIME_LENGTH milliseconds worth of events in the buffer.  At this point, <br>it returns to the caller with a "full" buffer.  At the very worst, there will <br>be as many events as can fit into OUT_BUFFER_SIZE bytes.  Imagine that you have <br>to MIDI files loaded into memory somehow and you want to switch between them in <br>a hurry to correspond to some action the player performed like switching rooms. <br>All you have to do is start filling the next buffer with new data (assuming <br>they streams use similar patch sets, time division settings, etc.) and after <br>(NUM_STREAM_BUFFERS-1)*BUFFER_TIME_LENGTH milliseconds, the music will switch <br>over automatically.  This theory is sort of illustrated by the tempo trackbar <br>control in this sample.  This control sets a flag which forces the converter <br>code to start a new buffer, with the first event being a new tempo setting. <br>The tempo setting is calculated as a relative increase with respect to the <br>last real tempo event from the file.  Of course, to implement the scheme <br>mentioned above requires some modification to the converter code so that it <br>will work with multiple MIDI files. <br> <br>Since the buffering scheme uses very small buffers, it is currently rather <br>sensitive to heavy activity which may prevent it from completing processing <br>in time.  This can be solved by increasing the NUM_STREAM_BUFFERS constant, <br>but you must make a trade-off between latency and playback stability. <br> <br> <br>Known problems and possible improvements: <br>----------------------------------------- <br>It is more desireable to enumerate all possible MIDI output devices and then <br>   either allow the user to use a specific device, or choose one which has <br>   desireable capabilities.  It is not recommended that you ship a product <br>   which is hard-coded to use the MIDI Mapper only.  For more on enumerating <br>   MIDI output devices, see the MIDIPLYR sample application which is part of <br>   the Win32 SDK. <br> <br>Instead of using the BUFFER_TIME_LENGTH, it would be possible to handle the <br>   time signature META event in MIDI files and calculate the length of a <br>   measure of music.  Then you could change buffers at the end of each measure, <br>   which would probably yield a smoother sounding transition.  It may even be <br>   possible to define system-exclusive events or other such extensions to the <br>   MIDI converter code designed to provide your application with extra data <br>   about when to switch between buffers or do other processing, though it is <br>   not necessarily recommended that you modify the MIDI file format spec.  For <br>   more information on that spec, contact the International MIDI Association. <br> <br>You may wish to modify the way a change in tempo is handled, or remove this <br>   code entirely.  Right now, there is a chunk of code in the convert function <br>   AddEventToStreamBuffer() which detects tempo events and stores the new tempo. <br>   There is also code which will react to the tempo slider by calculating a new <br>   tempo, truncating the current buffer, and starting the next buffer with a <br>   tempo event reflecting the new desired tempo. It may be more desireable to <br>   force any tempo changes which are not encoded in the file originally to take <br>   effect only on buffer boundaries, instead of always creating a buffer <br>   boundary.  Proceeding under the above context of buffers equal in length to <br>   measures of music, it may make more sense to only change tempo between each <br>   measure.  You can also send tempo change messages using the midiOutShortMsg() <br>   function, similar to the way SetAllChannelVolumes() behaves. <br> <br>The volume control is a channel-wide, percentage-based control which relies on <br>   a cache of volumes for each channel.  As the converter encounters a volume <br>   change message, it flags it for a callback.  This causes the MidiProc() to <br>   receive notification when that event is reached.  MidiProc() then grabs a <br>   copy of the new volume event and sends a MIDI short message to the proper <br>   channel which reflects the current slider position.  In other words, the <br>   code saves the "full" or "raw" value and then modifies it so the volume <br>   trackbar represents a percentage of that volume.  Though it is not shown <br>   here, this scheme could be broken down to allow for individual volume <br>   control also.  This idea could also be expanded to include the LSB volume <br>   controller(39), which is not handled here. <br> <br>Further, by duplicating the volume code described above and making slight <br>   modifications to the converter (to detect other events), it is possible to <br>   handle pan, balance, or other controller messages using the exact same idea. <br> <br>Having said the above, it should be noted that attaching the volume change code <br>   to a trackbar is for illustration purposes only.  The implementation shown <br>   and described works best for isolated volume events, like when your player <br>   moves away from the sound source and you need to update volume.  It should <br>   not really be used for real-time scrolling because the method tends to flood <br>   the MIDI output device with short messages, which interferes severly with <br>   playback. <br> <br>BUG: If you are using an internal MIDI device which uses the OPL chipset, you <br>   should be aware of a bug which seems to occur in most of these drivers.  If <br>   a volume channel message is sent to these drivers, they will not reflect the <br>   change until a note on/off event occurs.  This means long sustaining notes <br>   will not reduce in volume. </code></pre>
<p>&nbsp;</p></body>
</HTML>
