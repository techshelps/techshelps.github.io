<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MSTRHELP.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3266"></a>MSTRHELP.C</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1995-1997 Microsoft Corporation. All Rights Reserved. <br> * <br> *  File:   mstream.c <br> *  Content:   Illustrates streaming data from a disk MIDI file to a <br> *             midiStream buffer for playback. <br> * <br> ***************************************************************************/ <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;commctrl.h&gt; <br>#include &lt;memory.h&gt; <br>#include &lt;mmreg.h&gt; <br> <br>#include "debug.h" <br>#include "resource.h" <br>#include "midstuff.h" <br>#include "mstream.h" <br> <br>extern char szAppTitle[64]; <br>extern char szAppCaption[64]; <br>extern char szFileBuffer[64]; <br>extern char szFileTitle[64]; <br>extern char szTempo[64]; <br>extern char szVolume[64]; <br>extern char szProgress[64]; <br>extern char szTemp[256]; <br>extern char szDebug[256]; <br> <br>extern HWND hWndMain, hWndTempo, hWndVol, hWndProg, hWndPlay, hWndPause; <br>extern HWND hWndStop, hWndTempoText, hWndVolText, hWndLoopCheck, hWndProgText; <br>extern HINSTANCE hInst; <br>extern HMIDISTRMhStream; <br> <br>extern BOOLbFileOpen, bPlaying, bPaused, bInsertTempo; <br>extern intnTextControlHeight; <br>extern DWORDdwBufferTickLength, dwTempoMultiplier, dwCurrentTempo; <br>extern DWORDdwProgressBytes, dwVolumePercent, dwVolCache[NUM_CHANNELS]; <br> <br>#ifdef DEBUG <br>extern HWNDhWndList; <br>#endif <br> <br>/*****************************************************************************/ <br>/* CreateChildren()                                                          */ <br>/*                                                                           */ <br>/*   This function creates a bunch of child controls for the main window.    */ <br>/* Most of them are used for controling various things about a playing sound */ <br>/* file, like volume and panning. Returns FALSE if no errors, TRUE otherwise.*/ <br>/*                                                                           */ <br>/*****************************************************************************/ <br>int CreateChildren( RECT crect ) <br>    { <br>    SIZE  Size; <br>    HDC   hDC; <br>    int  x, y; <br>    UINT  uType; <br>    char  szTemplate[128], szType[32]; <br>    LPSTR lpszControl; <br> <br>    LoadString( hInst, IDS_ERROR_CHILDTEMPLATE, szTemplate, sizeof(szTemplate)); <br> <br>    /* Don't handle failure for this one, because the app will still run fine */ <br>    CreateWindow( "static", NULL, WS_CHILD | WS_VISIBLE | SS_ETCHEDHORZ, <br>0, 0, crect.right, 2, hWndMain, (HMENU)0, hInst, NULL ); <br> <br>    hDC = GetDC( hWndMain ); <br>    if( !GetTextExtentPoint32( hDC, szProgress, strlen(szProgress), &amp;Size )) <br>{ <br>ErrorMessageBox( IDS_ERROR_GETTEXTEXTENT, MB_ICONEXCLAMATION ); <br>ReleaseDC( hWndMain, hDC ); <br>return( TRUE ); <br>} <br>    ReleaseDC( hWndMain, hDC ); <br>    nTextControlHeight = Size.cy; <br> <br>    y = BORDER_SPACE_CY; <br> <br>    /* STATIC control -- text label for the TEMPO trackbar */ <br>    if(( hWndTempoText = CreateWindow( "static", szTempo, <br>                                    WS_CHILD | WS_VISIBLE | SS_LEFTNOWORDWRAP,  <br>                                    BORDER_SPACE_CX, <br>                                    y, <br>                                    TEMPO_TEXT_CX, nTextControlHeight, <br>                                    hWndMain, (HMENU)0, hInst, NULL)) == NULL ) <br>        { <br>        lpszControl = szTempo; <br>uType = IDS_ERROR_STATICTEXT; <br>        goto DISPLAY_CREATE_FAILURE; <br>} <br> <br>    /* Create the TEMPO trackbar */ <br>    if(( hWndTempo = CreateWindow( TRACKBAR_CLASS, NULL, <br>WS_CHILD | WS_VISIBLE | TBS_HORZ | TBS_BOTTOM, <br>BORDER_SPACE_CX, <br>y + nTextControlHeight + TEXT_SPACE_CY, <br>TEMPO_TB_CX, TEMPO_TB_CY, <br>hWndMain, (HMENU)0, hInst, NULL)) == NULL ) <br>        { <br>        lpszControl = szTempo; <br>uType = IDS_ERROR_TRACKBAR; <br>        goto DISPLAY_CREATE_FAILURE; <br>} <br> <br>    dwTempoMultiplier = 100; <br>    SendMessage( hWndTempo, TBM_SETRANGE, FALSE, <br>                                        MAKELONG( TEMPO_MIN, TEMPO_MAX )); <br>    SendMessage( hWndTempo, TBM_SETPOS, TRUE, dwTempoMultiplier ); <br> <br>    /* STATIC control -- text label for the VOLUME trackbar */ <br>    if(( hWndVolText = CreateWindow( "static", szVolume, <br>                                    WS_CHILD | WS_VISIBLE | SS_LEFTNOWORDWRAP,  <br>                                    BORDER_SPACE_CX + TEMPO_TB_CX <br>                                    + CONTROL_SPACE_CX, <br>                                    y, <br>                                    VOL_TEXT_CX, nTextControlHeight, <br>                                    hWndMain, (HMENU)0, hInst, NULL)) == NULL ) <br>        { <br>        lpszControl = szVolume; <br>uType = IDS_ERROR_STATICTEXT; <br>        goto DISPLAY_CREATE_FAILURE; <br>} <br>    y += nTextControlHeight + TEXT_SPACE_CY; <br> <br>    /* Create the VOLUME trackbar */ <br>    if(( hWndVol = CreateWindow( TRACKBAR_CLASS, NULL, <br>WS_CHILD | WS_VISIBLE | TBS_HORZ | TBS_BOTTOM, <br>BORDER_SPACE_CX + TEMPO_TB_CX <br>+ CONTROL_SPACE_CX, <br>y, VOL_TB_CX, VOL_TB_CY, <br>hWndMain, (HMENU)0, hInst, NULL)) == NULL ) <br>        { <br>        lpszControl = szVolume; <br>uType = IDS_ERROR_TRACKBAR; <br>        goto DISPLAY_CREATE_FAILURE; <br>} <br> <br>    SendMessage( hWndVol, TBM_SETRANGE, FALSE, <br>                                        MAKELONG( VOL_TB_MIN, VOL_TB_MAX )); <br>    SendMessage( hWndVol, TBM_SETPOS, TRUE, VOL_TB_MAX ); <br>    SendMessage( hWndVol, TBM_SETPAGESIZE, 0L, VOL_PAGESIZE ); <br> <br>    x = BORDER_SPACE_CX + TEMPO_TB_CX + 2 * CONTROL_SPACE_CX + VOL_TB_CX; <br>    y = BORDER_SPACE_CY; <br> <br>    /* Create the LOOPED CHECKBOX */ <br>    LoadString( hInst, IDS_CHECK_LOOPED, szTemp, sizeof(szTemp)); <br>    if(( hWndLoopCheck = CreateWindow( "button", szTemp, <br>                                WS_CHILD | WS_VISIBLE | BS_CHECKBOX, <br>                                x, y, CHECK_CX, CHECK_CY, hWndMain, <br>                                (HMENU)IDC_LOOPCHECK, hInst, NULL )) == NULL ) <br>        { <br>        lpszControl = szTemp; <br>uType = IDS_ERROR_CHECK; <br>        goto DISPLAY_CREATE_FAILURE; <br>} <br> <br>    x = BORDER_SPACE_CX + TEMPO_TB_CX + VOL_TB_CX + 2 * CONTROL_SPACE_CX + CHECK_CX <br>- 3 * BUTTON_CX - 2 * BUTTON_SPACE_CX; <br>    y = BORDER_SPACE_CY + nTextControlHeight + TEXT_SPACE_CY + TEMPO_TB_CY <br>+ CONTROL_SPACE_CY; <br> <br>    /* STATIC control -- text label for the progress trackbar. */ <br>    if(( hWndProgText = CreateWindow( "static", szProgress, <br>                                    WS_CHILD | WS_VISIBLE | SS_LEFTNOWORDWRAP, <br>                                    BORDER_SPACE_CX, <br>                                    y, <br>                                    x - BORDER_SPACE_CX, nTextControlHeight, <br>                                    hWndMain, (HMENU)0, hInst, NULL)) == NULL ) <br>        { <br>        lpszControl = szProgress; <br>uType = IDS_ERROR_STATICTEXT; <br>        goto DISPLAY_CREATE_FAILURE; <br>} <br> <br>    /* Create the PLAY BUTTON */ <br>    LoadString( hInst, IDS_BUTTON_PLAY, szTemp, sizeof(szTemp)); <br>    if(( hWndPlay = CreateWindow( "button", szTemp, <br>                                    WS_CHILD | WS_VISIBLE | WS_DISABLED, <br>                                    x, y, BUTTON_CX, BUTTON_CY, hWndMain, <br>                                    (HMENU)IDC_PLAY, hInst, NULL )) == NULL ) <br>        { <br>        lpszControl = szTemp; <br>uType = IDS_ERROR_BUTTON; <br>        goto DISPLAY_CREATE_FAILURE; <br>} <br>    x += BUTTON_CX + BUTTON_SPACE_CX; <br> <br>    /* Create the PAUSE BUTTON */ <br>    LoadString( hInst, IDS_BUTTON_PAUSE, szTemp, sizeof(szTemp)); <br>    if(( hWndPause = CreateWindow( "button", szTemp, <br>    WS_CHILD | WS_VISIBLE | WS_DISABLED, <br>    x, y, BUTTON_CX, BUTTON_CY, hWndMain, <br>    (HMENU)IDC_PAUSE, hInst, NULL )) == NULL ) <br>{ <br>lpszControl = szTemp; <br>uType = IDS_ERROR_BUTTON; <br>goto DISPLAY_CREATE_FAILURE; <br>} <br>    x += BUTTON_CX + BUTTON_SPACE_CX; <br> <br>    /* Create the STOP BUTTON */ <br>    LoadString( hInst, IDS_BUTTON_STOP, szTemp, sizeof(szTemp)); <br>    if(( hWndStop = CreateWindow( "button", szTemp, <br>                                    WS_CHILD | WS_VISIBLE | WS_DISABLED, <br>                                    x, y, BUTTON_CX, BUTTON_CY, hWndMain, <br>                                    (HMENU)IDC_STOP, hInst, NULL )) == NULL ) <br>        { <br>        lpszControl = szTemp; <br>uType = IDS_ERROR_BUTTON; <br>        goto DISPLAY_CREATE_FAILURE; <br>} <br> <br>    UpdateFromControls(); <br>    goto RETURN_NORMAL; <br> <br>DISPLAY_CREATE_FAILURE: <br>    LoadString( hInst, uType, szType, sizeof(szType)); <br>    wsprintf( szTemp, szTemplate, lpszControl, szType ); <br>    MessageBox( GetActiveWindow(), szTemp, <br>                        szAppTitle, MB_OK | MB_ICONEXCLAMATION ); <br>    return( TRUE ); <br> <br>RETURN_NORMAL: <br>    return( FALSE ); <br>    } <br> <br> <br>/********************************************************************************/ <br>/* HandleTempoScroll()                                                          */ <br>/*                                                                              */ <br>/*   Handles the tempo trackbar scroll when a WM_HSCROLL is received.           */ <br>/*                                                                              */ <br>/********************************************************************************/ <br>void HandleTempoScroll( int nCode, int nPos ) <br>    { <br>    long  lTempo, lDelta; <br> <br>    lTempo = (LONG)SendMessage( hWndTempo, TBM_GETPOS, (WPARAM)0, (LPARAM)0 ); <br> <br>    switch( nCode ) <br>        { <br>        case TB_LINEUP: <br>            if( lTempo &gt;= TEMPO_MIN-1 ) <br>                lDelta = -1; <br>            break; <br>        case TB_LINEDOWN: <br>            if( lTempo &lt;= TEMPO_MAX+1 ) <br>                lDelta = 1; <br>            break; <br>        case TB_PAGEUP: <br>            if( lTempo &gt;= TEMPO_MIN - TEMPO_PAGESIZE ) <br>                lDelta = -TEMPO_PAGESIZE; <br>            break; <br>        case TB_PAGEDOWN: <br>            if( lTempo &lt;= TEMPO_MAX + TEMPO_PAGESIZE ) <br>                lDelta = TEMPO_PAGESIZE; <br>            break; <br>        case TB_ENDTRACK: <br>            return; <br>        default: <br>            lDelta = 0; <br>        } <br> <br>    if( lDelta ) <br>{ <br>SendMessage( hWndTempo, TBM_SETPOS, TRUE, lTempo + lDelta ); <br>dwTempoMultiplier = (DWORD)( lTempo + lDelta ); <br>} <br>    else <br>{ <br>SendMessage( hWndTempo, TBM_SETPOS, TRUE, (long)nPos ); <br>dwTempoMultiplier = (DWORD)nPos; <br>} <br> <br>    UpdateFromControls(); <br>    } <br> <br> <br>/********************************************************************************/ <br>/* HandleVolScroll()                                                            */ <br>/*                                                                              */ <br>/*   Handles the volume trackbar scrolling when a WM_HSCROLL is received.       */ <br>/*                                                                              */ <br>/********************************************************************************/ <br>void HandleVolScroll( int nCode, int nPos ) <br>    { <br>    long  lVol, lDelta; <br> <br>    lVol = (LONG)SendMessage( hWndVol, TBM_GETPOS, (WPARAM)0, (LPARAM)0 ); <br> <br>    switch( nCode ) <br>        { <br>        case TB_LINEDOWN: <br>            if( lVol &lt;= VOL_TB_MAX - 1 ) <br>                lDelta = 1; <br>            break; <br>        case TB_LINEUP: <br>            if( lVol &gt;= VOL_TB_MIN + 1 ) <br>                lDelta = -1; <br>            break; <br>        case TB_PAGEDOWN: <br>            if( lVol &lt;= VOL_TB_MAX - VOL_PAGESIZE ) <br>                lDelta = VOL_PAGESIZE; <br>            break; <br>        case TB_PAGEUP: <br>            if( lVol &gt;= VOL_TB_MIN + VOL_PAGESIZE ) <br>                lDelta = -VOL_PAGESIZE; <br>            break; <br>        case TB_ENDTRACK: <br>            return; <br>        default: <br>            lDelta = 0; <br>        } <br> <br>    if( lDelta ) <br>        SendMessage( hWndVol, TBM_SETPOS, TRUE, (lVol + lDelta)); <br>    else <br>        SendMessage( hWndVol, TBM_SETPOS, TRUE, (long)nPos ); <br> <br>    UpdateFromControls(); <br>    } <br> <br> <br>/********************************************************************************/ <br>/* UpdateFromControls()                                                         */ <br>/*                                                                              */ <br>/*    This function gets all the required values from the DirectSoundBuffer and */ <br>/* updates the screen interface controls.                                       */ <br>/*                                                                              */ <br>/********************************************************************************/ <br>void UpdateFromControls( void ) <br>    { <br>    longlTempo; <br> <br>    lTempo = (LONG)SendMessage( hWndTempo, TBM_GETPOS, (WPARAM)0, (LPARAM)0 ); <br>    dwVolumePercent = (WORD)SendMessage( hWndVol, TBM_GETPOS, <br>    (WPARAM)0, (LPARAM)0 ); <br> <br>    /* Set the Volume text */ <br>    wsprintf( szTemp, "%s: %lu%%", szVolume, dwVolumePercent / 10 ); <br>    Static_SetText( hWndVolText, szTemp ); <br>    if( hStream ) <br>SetAllChannelVolumes( dwVolumePercent ); <br> <br>    /* Set the Tempo text */ <br>    wsprintf( szTemp, "%s: %li%%", szTempo, lTempo ); <br>    Static_SetText( hWndTempoText, szTemp ); <br>    bInsertTempo = TRUE; <br> <br>    /* Set the Progress text */ <br>    wsprintf( szTemp, "%s: %lu bytes", szProgress, dwProgressBytes ); <br>    Static_SetText( hWndProgText, szTemp ); <br> <br>    return; <br>    } <br> <br> <br>/****************************************************************************/ <br>/* ErrorMessageBox()                                                        */ <br>/*                                                                          */ <br>/*   A little routine to load error messages from the string resource table */ <br>/* and pop them up in a MessageBox() for the world to see. The dwMBFlags    */ <br>/* parameter allows the caller to specify the type of icon to use.          */ <br>/*                                                                          */ <br>/****************************************************************************/ <br>void ErrorMessageBox( UINT uID, DWORD dwMBFlags ) <br>    { <br>    LoadString( hInst, uID, szTemp, sizeof(szTemp)); <br>    MessageBox( GetActiveWindow(), szTemp, szAppTitle, MB_OK | dwMBFlags ); <br>#ifdef DEBUG <br>    wsprintf( szDebug, "General error: %s", szTemp ); <br>    DebugPrint( szDebug ); <br>#endif <br>    } <br> <br> <br>/****************************************************************************/ <br>/* MidiErrorMessageBox()                                                    */ <br>/*                                                                          */ <br>/*   Calls the midiOutGetErrorText() function and displays the text which   */ <br>/* corresponds to a midi subsystem error code.                              */ <br>/*                                                                          */ <br>/****************************************************************************/ <br>void MidiErrorMessageBox( MMRESULT mmr ) <br>    { <br>    midiOutGetErrorText( mmr, szTemp, sizeof(szTemp)); <br>    MessageBox( GetActiveWindow(), szTemp, szAppTitle, <br>    MB_OK | MB_ICONSTOP ); <br>#ifdef DEBUG <br>    wsprintf( szDebug, "Midi subsystem error: %s", szTemp ); <br>    DebugPrint( szDebug ); <br>#endif <br>    } <br> <br> <br>/*****************************************************************************/ <br>/* HandleCommDlgError()                                                      */ <br>/*                                                                           */ <br>/*    The function translates extended common dialog error codes into a      */ <br>/* string resource ID, loads that string from our module, and displays it in */ <br>/* a message box. This implementation only covers the general CD error codes.*/ <br>/*                                                                           */ <br>/*****************************************************************************/ <br>int HandleCommDlgError( DWORD dwError ) <br>    { <br>    char szTitle[128]; <br>    UINT uMsgID; <br> <br>    if( dwError == CDERR_DIALOGFAILURE ) <br>        uMsgID = IDS_CDERR_DIALOGFAILURE; <br>    else <br>        uMsgID = (UINT)dwError + IDS_CDERR_GENERAL_BASE; <br> <br>    LoadString( hInst, uMsgID, szTemp, sizeof(szTemp)); <br>    LoadString( hInst, IDS_CDERR_TITLESTRING, szTitle, sizeof(szTitle)); <br>    MessageBox( GetActiveWindow(), szTemp, szTitle, <br>                    MB_OK | MB_ICONEXCLAMATION ); <br> <br>    return( 0 ); <br>    } <br> <br> <br>/****************************************************************************/ <br>/* BuildTitleBarText()                                                      */ <br>/*                                                                          */ <br>/*   Helper function designed to updated the title bar text of the main     */ <br>/* window to reflect the currently loaded file (if there is one).           */ <br>/*                                                                          */ <br>/****************************************************************************/ <br>void BuildTitleBarText( void ) <br>    { <br>    char szTitle[sizeof(szAppCaption) + MAX_PATH + sizeof( " -  (Paused)")]; <br> <br>    lstrcpy( szTitle, szAppCaption ); <br>    if( bFileOpen ) <br>{ <br>lstrcat( szTitle, " - " ); <br>lstrcat( szTitle, szFileTitle ); <br>} <br>    if( bPaused ) <br>    lstrcat( szTitle, " (Paused)" ); <br>    SetWindowText( hWndMain, szTitle ); <br>    } <br> <br> <br>/****************************************************************************/ <br>/* SetAllChannelVolumes()                                                   */ <br>/*                                                                          */ <br>/*   Given a percent in tenths of a percent, sets volume on all channels to */ <br>/* reflect the new value.                                                   */ <br>/****************************************************************************/ <br>void SetAllChannelVolumes( DWORD dwVolumePercent ) <br>    { <br>    DWORDdwEvent, dwStatus, dwVol, idx; <br>    MMRESULTmmrRetVal; <br> <br>    if( !bPlaying ) <br>return; <br> <br> <br>    for( idx = 0, dwStatus = MIDI_CTRLCHANGE; idx &lt; NUM_CHANNELS; idx++, <br>dwStatus++ ) <br>{ <br>dwVol = ( dwVolCache[idx] * dwVolumePercent ) / 1000; <br>dwEvent = dwStatus | ((DWORD)MIDICTRL_VOLUME &lt;&lt; 8) <br>| ((DWORD)dwVol &lt;&lt; 16); <br>if(( mmrRetVal = midiOutShortMsg( (HMIDIOUT)hStream, dwEvent )) <br>!= MMSYSERR_NOERROR ) <br>    { <br>    MidiErrorMessageBox( mmrRetVal ); <br>    return; <br>    } <br>} <br>    } <br> <br> <br>/****************************************************************************/ <br>/* SetChannelVolume()                                                       */ <br>/*                                                                          */ <br>/*   Given a percent in tenths of a percent, sets volume on a specified     */ <br>/* channel to reflect the new value.                                        */ <br>/****************************************************************************/ <br>void SetChannelVolume( DWORD dwChannel, DWORD dwVolumePercent ) <br>    { <br>    DWORDdwEvent, dwVol; <br>    MMRESULTmmrRetVal; <br> <br>    if( !bPlaying ) <br>return; <br> <br>    dwVol = ( dwVolCache[dwChannel] * dwVolumePercent ) / 1000; <br>    dwEvent = MIDI_CTRLCHANGE | dwChannel | ((DWORD)MIDICTRL_VOLUME &lt;&lt; 8) <br>| ((DWORD)dwVol &lt;&lt; 16); <br>    if(( mmrRetVal = midiOutShortMsg( (HMIDIOUT)hStream, dwEvent )) <br>!= MMSYSERR_NOERROR ) <br>{ <br>MidiErrorMessageBox( mmrRetVal ); <br>return; <br>} <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
