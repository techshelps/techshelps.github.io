<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MSTRCONV.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3263"></a>MSTRCONV.C</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1995-1997 Microsoft Corporation. All Rights Reserved. <br> * <br> *  File:mstrconv.c <br> *  Content:Converts a MIDI file into a midiStream, placing the results <br> *              in a buffer that the MSTREAM sample application can use for <br> *              playback with the midiStream* API under Win95. <br> * <br> ***************************************************************************/ <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br> <br>#include &lt;mmsystem.h&gt; <br>#include &lt;assert.h&gt; <br>#include &lt;stdio.h&gt; <br> <br>#include "debug.h" <br>#include "mstream.h" <br>#include "midstuff.h" <br> <br>// Global stuff which is defined in the main module <br>// <br>extern char szTemp[256]; <br>extern char szDebug[256]; <br>extern char szAppTitle[64]; <br> <br>BOOLbInsertTempo = FALSE; <br> <br>// A few global variables used by this module only <br>// <br>static HANDLEhInFile= INVALID_HANDLE_VALUE; <br>INFILESTATEifs; <br>static DWORDtkCurrentTime; <br> <br>// Tracks how many malloc blocks exist. If there are any and we decide to shut <br>// down, we must scan for them and free them.  Malloc blocks are only created as <br>// temporary storgae blocks for extra parameter data associated with MIDI_SYSEX, <br>// MIDI_SYSEXEND, and MIDI_META events. <br>static DWORDdwMallocBlocks= 0; <br> <br>extern DWORDdwBufferTickLength, dwTempoMultiplier, dwCurrentTempo; <br>extern DWORDdwProgressBytes, dwVolumePercent; <br>extern BOOLbLooped; <br> <br>// Messages <br>// <br>static char szInitErrMem[]= "Out of memory.\n"; <br>static char szInitErrInFile[]= "Read error on input file or file is corrupt.\n"; <br>static char szNoTrackBuffMem[]= "Insufficient memory for track buffer allocation\n"; <br> <br>#ifdef DEBUG <br>static char gteBadRunStat[] = "Reference to missing running status."; <br>static char gteRunStatMsgTrunc[]= "Running status message truncated"; <br>static char gteChanMsgTrunc[]= "Channel message truncated"; <br>static char gteSysExLenTrunc[]= "SysEx event truncated (length)"; <br>static char gteSysExTrunc[]= "SysEx event truncated"; <br>static char gteMetaNoClass[]= "Meta event truncated (no class byte)"; <br>static char gteMetaLenTrunc[]= "Meta event truncated (length)"; <br>static char gteMetaTrunc[]= "Meta event truncated"; <br>static char gteNoMem[]= "Out of memory during malloc call"; <br>#endif <br> <br>// Prototypes <br>// <br>static intAddEventToStreamBuffer( PTEMPEVENT pteTemp, LPCONVERTINFO ); <br>static BOOLGetInFileData( LPVOID lpDest, DWORD cbToGet ); <br>static BOOLGetTrackByte( PINTRACKSTATE ptsTrack, LPBYTE lpbyByte ); <br>static BOOLGetTrackEvent( PINTRACKSTATE ptsTrack, PTEMPEVENT pteTemp ); <br>static BOOLGetTrackVDWord( PINTRACKSTATE ptsTrack, LPDWORD lpdw ); <br>static BOOLRefillTrackBuffer( PINTRACKSTATE ptsTrack ); <br>static BOOLRewindConverter( void ); <br> <br>#ifdef DEBUG <br>static void ShowTrackError( PINTRACKSTATE ptsTrack, char* szErr ); <br>#endif <br> <br>// ConverterInit <br>//  <br>// Open the input file <br>// Allocate and read the entire input file into memory <br>// Validate the input file structure <br>// Allocate the input track structures and initialize them <br>// Initialize the output track structures <br>// <br>// Return TRUE on success <br>// Prints its own error message if something goes wrong <br>// <br>BOOL ConverterInit( LPSTR szInFile ) <br>    { <br>    BOOLfRet = TRUE; <br>    DWORDcbRead, dwTag, cbHeader, dwToRead; <br>    MIDIFILEHDRHeader; <br>    PINTRACKSTATEptsTrack; <br>    UINTidx; <br> <br>    tkCurrentTime = 0; <br> <br>    // Initialize things we'll try to free later if we fail <br>    // <br>    memset( &amp;ifs, 0, sizeof(INFILESTATE)); <br>    ifs.cbFileLength = 0; <br>    ifs.pitsTracks = NULL; <br> <br>    // Attempt to open the input and output files <br>    // <br>    hInFile = CreateFile( szInFile, GENERIC_READ, <br>FILE_SHARE_READ, NULL, OPEN_EXISTING, <br>FILE_ATTRIBUTE_NORMAL, NULL); <br>    if( hInFile == INVALID_HANDLE_VALUE ) <br>{ <br>wsprintf( szTemp, "Could not open \"%s\" for read.\n", szInFile ); <br>MessageBox( GetActiveWindow(), szTemp, <br>szAppTitle, MB_OK | MB_ICONEXCLAMATION ); <br>goto Init_Cleanup; <br>} <br> <br>// Figure out how big the input file is. <br>    if((( ifs.cbFileLength = GetFileSize( hInFile, NULL )) == (UINT)-1 )) <br>{ <br>MessageBox( GetActiveWindow(), "File system error on input file.\n", <br>        szAppTitle, MB_OK | MB_ICONEXCLAMATION ); <br>goto Init_Cleanup; <br>} <br> <br>// Set up to read from the memory buffer. Read and validate <br>// - MThd header <br>// - size of file header chunk <br>// - file header itself <br>// <br>    if( GetInFileData( &amp;dwTag, sizeof(DWORD)) <br>    || ( dwTag != MThd ) <br>    || GetInFileData( &amp;cbHeader, sizeof(DWORD)) <br>    || (( cbHeader = DWORDSWAP( cbHeader )) &lt; sizeof(MIDIFILEHDR)) <br>            || GetInFileData( &amp;Header, cbHeader ) ) <br>        { <br>        MessageBox( GetActiveWindow(), szInitErrInFile, <br>        szAppTitle, MB_OK | MB_ICONEXCLAMATION ); <br>        goto Init_Cleanup; <br>        } <br> <br>// File header is stored in hi-lo order. Swap this into Intel order and save <br>// parameters in our native int size (32 bits) <br>// <br>    ifs.dwFormat = (DWORD)WORDSWAP( Header.wFormat ); <br>    ifs.dwTrackCount = (DWORD)WORDSWAP( Header.wTrackCount ); <br>    ifs.dwTimeDivision = (DWORD)WORDSWAP( Header.wTimeDivision ); <br> <br>// We know how many tracks there are; allocate the structures for them and parse <br>// them. The parse merely looks at the MTrk signature and track chunk length <br>// in order to skip to the next track header. <br>// <br>    ifs.pitsTracks = (PINTRACKSTATE)GlobalAllocPtr( GPTR, <br>    ifs.dwTrackCount * sizeof(INTRACKSTATE)); <br>    if( ifs.pitsTracks == NULL ) <br>        { <br>        MessageBox( GetActiveWindow(), szInitErrMem, <br>        szAppTitle, MB_OK | MB_ICONEXCLAMATION ); <br>        goto Init_Cleanup; <br>        } <br> <br>    for( idx = 0, ptsTrack = ifs.pitsTracks; idx &lt; ifs.dwTrackCount; <br>    ++idx, ++ptsTrack ) <br>{ <br>if(( ptsTrack-&gt;pTrackStart <br>= GlobalAllocPtr( GHND, TRACK_BUFFER_SIZE )) == NULL ) <br>    { <br>    MessageBox( GetActiveWindow(), szNoTrackBuffMem, <br>    szAppTitle, MB_OK | MB_ICONEXCLAMATION ); <br>    goto Init_Cleanup; <br>    } <br> <br>if( GetInFileData( &amp;dwTag, sizeof(dwTag)) || ( dwTag != MTrk ) <br>|| GetInFileData( &amp;cbHeader, sizeof(cbHeader))) <br>    { <br>    MessageBox( GetActiveWindow(), szInitErrInFile, <br>    szAppTitle, MB_OK | MB_ICONEXCLAMATION ); <br>    goto Init_Cleanup; <br>    } <br> <br>cbHeader = DWORDSWAP( cbHeader ); <br>ptsTrack-&gt;dwTrackLength = cbHeader;// Total track length <br>/////////////////////////////////////////////////////////////////////////////// <br>// Here we need to determine if all track data will fit into a single one of <br>// our track buffers.  If not, we need to read in a buffer full and come back <br>// for more later, saving the file offset to continue from and the amount left <br>// to read in the track structure. <br> <br>// Save the file offset of the beginning of this track <br>ptsTrack-&gt;foTrackStart = SetFilePointer( hInFile, 0, NULL, <br>FILE_CURRENT ); <br> <br>if( ptsTrack-&gt;dwTrackLength &gt; TRACK_BUFFER_SIZE ) <br>    dwToRead = TRACK_BUFFER_SIZE; <br>else <br>    dwToRead = ptsTrack-&gt;dwTrackLength; <br>if( !ReadFile( hInFile, ptsTrack-&gt;pTrackStart, dwToRead, &amp;cbRead, NULL ) <br>|| ( cbRead != dwToRead )) <br>    { <br>    MessageBox( GetActiveWindow(), szInitErrInFile, <br>szAppTitle, MB_OK | MB_ICONEXCLAMATION ); <br>    goto Init_Cleanup; <br>    } <br>// Save the number of bytes that didn't make it into the buffer <br>ptsTrack-&gt;dwLeftOnDisk = ptsTrack-&gt;dwTrackLength - cbRead; <br>ptsTrack-&gt;dwLeftInBuffer = cbRead; <br>// Save the current file offset so we can seek to it later <br>ptsTrack-&gt;foNextReadStart = SetFilePointer( hInFile, 0, <br>NULL, FILE_CURRENT ); <br> <br>        // Setup pointer to the current position in the track <br>        ptsTrack-&gt;pTrackCurrent = ptsTrack-&gt;pTrackStart; <br>        ptsTrack-&gt;fdwTrack = 0; <br>        ptsTrack-&gt;byRunningStatus = 0; <br>        ptsTrack-&gt;tkNextEventDue = 0; <br> <br>        // Handle bozo MIDI files which contain empty track chunks <br>        // <br>        if( !ptsTrack-&gt;dwLeftInBuffer &amp;&amp; !ptsTrack-&gt;dwLeftOnDisk ) <br>            { <br>            ptsTrack-&gt;fdwTrack |= ITS_F_ENDOFTRK; <br>            continue; <br>            } <br> <br>        // We always preread the time from each track so the mixer code can <br>        // determine which track has the next event with a minimum of work <br>        // <br>        if( GetTrackVDWord( ptsTrack, &amp;ptsTrack-&gt;tkNextEventDue )) <br>            { <br>            MessageBox( GetActiveWindow(), szInitErrInFile, <br>            szAppTitle, MB_OK | MB_ICONEXCLAMATION ); <br>            goto Init_Cleanup; <br>            } <br>// Step over any unread data, advancing to the beginning of the next <br>// track's data <br>SetFilePointer( hInFile, ptsTrack-&gt;foTrackStart + ptsTrack-&gt;dwTrackLength, <br>NULL, FILE_BEGIN ); <br>        }// End of track initialization code <br> <br>    fRet = FALSE; <br> <br>    Init_Cleanup: <br>    if( fRet ) <br>        ConverterCleanup(); <br> <br>    return( fRet ); <br>    } <br> <br>// <br>// GetInFileData <br>// <br>// Gets the requested number of bytes of data from the input file and returns <br>// a pointer to them. <br>//  <br>// Returns a pointer to the data or NULL if we'd read more than is <br>// there. <br>// <br>static BOOL GetInFileData( LPVOID lpDest, DWORD cbToGet ) <br>    { <br>    DWORDcbRead; <br> <br>    if( !ReadFile( hInFile, lpDest, cbToGet, &amp;cbRead, NULL ) <br>    || ( cbRead != cbToGet )) <br>        { <br>        return( TRUE ); <br>        } <br> <br>    return( FALSE ); <br>    } <br> <br> <br>// <br>// ConverterCleanup <br>// <br>// Free anything we ever allocated <br>// <br>void ConverterCleanup( void ) <br>    { <br>    DWORD   idx; <br> <br>    if( hInFile != INVALID_HANDLE_VALUE ) <br>        { <br>        CloseHandle( hInFile ); <br>hInFile = INVALID_HANDLE_VALUE; <br>} <br> <br>    if( ifs.pitsTracks ) <br>        { <br>// De-allocate all our track buffers <br>for( idx = 0; idx &lt; ifs.dwTrackCount; idx++ ) <br>    if( ifs.pitsTracks[idx].pTrackStart ) <br>GlobalFreePtr( ifs.pitsTracks[idx].pTrackStart ); <br> <br>        GlobalFreePtr( ifs.pitsTracks ); <br>ifs.pitsTracks = NULL; <br>} <br>    } <br> <br> <br>/*****************************************************************************/ <br>/* RewindConverter()                                                         */ <br>/*                                                                           */ <br>/*   This little function is an adaptation of the ConverterInit() code which */ <br>/* resets the tracks without closing and opening the file, thus reducing the */ <br>/* time it takes to loop back to the beginning when looping.                 */ <br>/*****************************************************************************/ <br>static BOOL RewindConverter( void ) <br>    { <br>    DWORD   dwToRead, cbRead, idx; <br>    BOOL    fRet; <br> <br>    PINTRACKSTATEptsTrack; <br> <br>    tkCurrentTime = 0; <br> <br>    for( idx = 0, ptsTrack = ifs.pitsTracks; idx &lt; ifs.dwTrackCount; <br>    ++idx, ++ptsTrack ) <br>{ <br>/////////////////////////////////////////////////////////////////////////////// <br>// Here we need to determine if all track data will fit into a single one of <br>// our track buffers.  If not, we need to read in a buffer full and come back <br>// for more later, saving the file offset to continue from and the amount left <br>// to read in the track structure. <br> <br>SetFilePointer( hInFile, ptsTrack-&gt;foTrackStart, NULL, FILE_BEGIN ); <br> <br>if( ptsTrack-&gt;dwTrackLength &gt; TRACK_BUFFER_SIZE ) <br>    dwToRead = TRACK_BUFFER_SIZE; <br>else <br>    dwToRead = ptsTrack-&gt;dwTrackLength; <br>if( !ReadFile( hInFile, ptsTrack-&gt;pTrackStart, dwToRead, &amp;cbRead, NULL ) <br>|| ( cbRead != dwToRead )) <br>    { <br>    MessageBox( GetActiveWindow(), szInitErrInFile, <br>szAppTitle, MB_OK | MB_ICONEXCLAMATION ); <br>    goto Rewind_Cleanup; <br>    } <br>// Save the number of bytes that didn't make it into the buffer <br>ptsTrack-&gt;dwLeftOnDisk = ptsTrack-&gt;dwTrackLength - cbRead; <br>ptsTrack-&gt;dwLeftInBuffer = cbRead; <br>// Save the current file offset so we can seek to it later <br>ptsTrack-&gt;foNextReadStart = SetFilePointer( hInFile, 0, <br>NULL, FILE_CURRENT ); <br> <br>        // Setup pointer to the current position in the track <br>        ptsTrack-&gt;pTrackCurrent = ptsTrack-&gt;pTrackStart; <br>        ptsTrack-&gt;fdwTrack = 0; <br>        ptsTrack-&gt;byRunningStatus = 0; <br>        ptsTrack-&gt;tkNextEventDue = 0; <br> <br> <br>        // Handle bozo MIDI files which contain empty track chunks <br>        // <br>        if( !ptsTrack-&gt;dwLeftInBuffer &amp;&amp; !ptsTrack-&gt;dwLeftOnDisk ) <br>            { <br>            ptsTrack-&gt;fdwTrack |= ITS_F_ENDOFTRK; <br>            continue; <br>            } <br> <br>        // We always preread the time from each track so the mixer code can <br>        // determine which track has the next event with a minimum of work <br>        // <br>        if( GetTrackVDWord( ptsTrack, &amp;ptsTrack-&gt;tkNextEventDue )) <br>            { <br>            MessageBox( GetActiveWindow(), szInitErrInFile, <br>            szAppTitle, MB_OK | MB_ICONEXCLAMATION ); <br>            goto Rewind_Cleanup; <br>            } <br>// Step over any unread data, advancing to the beginning of the next <br>// track's data <br>SetFilePointer( hInFile, ptsTrack-&gt;foTrackStart + ptsTrack-&gt;dwTrackLength, <br>NULL, FILE_BEGIN ); <br>        }// End of track initialization code <br> <br>    fRet = FALSE; <br> <br>    Rewind_Cleanup: <br> <br>    if( fRet ) <br>return( TRUE ); <br> <br>    return( FALSE ); <br>    } <br> <br> <br>/*****************************************************************************/ <br>/* ConvertToBuffer()                                                         */ <br>/*                                                                           */ <br>/*    This function converts MIDI data from the track buffers setup by a     */ <br>/* previous call to ConverterInit().  It will convert data until an error is */ <br>/* encountered or the output buffer has been filled with as much event data  */ <br>/* as possible, not to exceed dwMaxLength. This function can take a couple   */ <br>/* bit flags, passed through dwFlags. Information about the success/failure  */ <br>/* of this operation and the number of output bytes actually converted will  */ <br>/* be returned in the CONVERTINFO structure pointed at by lpciInfo.          */ <br>/*                                                                           */ <br>/*****************************************************************************/ <br>int ConvertToBuffer( DWORD dwFlags, LPCONVERTINFO lpciInfo ) <br>    { <br>    static INTRACKSTATE*ptsTrack, *ptsFound; <br>    static DWORDdwStatus; <br>    static DWORDtkNext; <br>    static TEMPEVENTteTemp; <br> <br>    int    nChkErr; <br>    DWORD   idx; <br> <br>    lpciInfo-&gt;dwBytesRecorded = 0; <br> <br>    if( dwFlags &amp; CONVERTF_RESET ) <br>{ <br>dwProgressBytes = 0; <br>dwStatus = 0; <br>memset( &amp;teTemp, 0, sizeof(TEMPEVENT)); <br>ptsTrack = ptsFound = NULL; <br>} <br>    // If we were already done, then return with a warning... <br>    if( dwStatus &amp; CONVERTF_STATUS_DONE ) <br>{ <br>if( bLooped ) <br>    { <br>    RewindConverter(); <br>    dwProgressBytes = 0; <br>    dwStatus = 0; <br>    } <br>else <br>    return( CONVERTERR_DONE ); <br>} <br>    // The caller is asking us to continue, but we're already hosed because we <br>    // previously identified something as corrupt, so complain louder this time. <br>    else if( dwStatus &amp; CONVERTF_STATUS_STUCK ) <br>    { <br>return( CONVERTERR_STUCK ); <br>} <br>    else if( dwStatus &amp; CONVERTF_STATUS_GOTEVENT ) <br>    { <br>// Turn off this bit flag <br>dwStatus ^= CONVERTF_STATUS_GOTEVENT; <br> <br>/* <br> *  The following code for this case is duplicated from below, and is <br> * designed to handle a "straggler" event, should we have one left over <br> * from previous processing the last time this function was called. <br> */ <br> <br>// Don't add end of track event 'til we're done <br>// <br>if( teTemp.byShortData[0] == MIDI_META <br>    &amp;&amp; teTemp.byShortData[1] == MIDI_META_EOT ) <br>    { <br>    if( dwMallocBlocks ) <br>{ <br>free( teTemp.pLongData ); <br>dwMallocBlocks--; <br>} <br>    } <br> <br>else if(( nChkErr = AddEventToStreamBuffer( &amp;teTemp, lpciInfo )) <br>!= CONVERTERR_NOERROR ) <br>    { <br>    if( nChkErr == CONVERTERR_BUFFERFULL ) <br>{ <br>// Do some processing and tell caller that this buffer's full <br>dwStatus |= CONVERTF_STATUS_GOTEVENT; <br>return( CONVERTERR_NOERROR ); <br>} <br>    else if( nChkErr == CONVERTERR_METASKIP ) <br>{ <br>// We skip by all meta events that aren't tempo changes... <br>} <br>    else <br>{ <br>DebugPrint( "Unable to add event to stream buffer." ); <br>if( dwMallocBlocks ) <br>    { <br>    free( teTemp.pLongData ); <br>    dwMallocBlocks--; <br>    } <br>return( TRUE ); <br>} <br>    } <br>} <br> <br>    for( ; ; ) <br>        { <br>        ptsFound = NULL; <br>        tkNext = 0xFFFFFFFFL; <br>        // Find nearest event due <br>        // <br>        for( idx = 0, ptsTrack = ifs.pitsTracks; idx &lt; ifs.dwTrackCount; <br>            ++idx, ++ptsTrack ) <br>            { <br>            if(( !( ptsTrack-&gt;fdwTrack &amp; ITS_F_ENDOFTRK )) <br>&amp;&amp; ( ptsTrack-&gt;tkNextEventDue &lt; tkNext )) <br>                { <br>                tkNext = ptsTrack-&gt;tkNextEventDue; <br>                ptsFound = ptsTrack; <br>                } <br>    } <br> <br>// None found?  We must be done, so return to the caller with a smile. <br>// <br>if( !ptsFound ) <br>    { <br>    dwStatus |= CONVERTF_STATUS_DONE; <br>            // Need to set return buffer members properly <br>    return( CONVERTERR_NOERROR ); <br>    } <br> <br>// Ok, get the event header from that track <br>// <br>if( GetTrackEvent( ptsFound, &amp;teTemp )) <br>            { <br>    // Warn future calls that this converter is stuck at a corrupt spot <br>    // and can't continue <br>            dwStatus |= CONVERTF_STATUS_STUCK; <br>            return( CONVERTERR_CORRUPT ); <br>            } <br> <br>// Don't add end of track event 'til we're done <br>// <br>if( teTemp.byShortData[0] == MIDI_META <br>    &amp;&amp; teTemp.byShortData[1] == MIDI_META_EOT ) <br>    { <br>    if( dwMallocBlocks ) <br>{ <br>free( teTemp.pLongData ); <br>dwMallocBlocks--; <br>} <br>    continue; <br>    } <br> <br>if(( nChkErr = AddEventToStreamBuffer( &amp;teTemp, lpciInfo )) <br>!= CONVERTERR_NOERROR ) <br>    { <br>    if( nChkErr == CONVERTERR_BUFFERFULL ) <br>{ <br>// Do some processing and tell somebody this buffer is full... <br>dwStatus |= CONVERTF_STATUS_GOTEVENT; <br>return( CONVERTERR_NOERROR ); <br>} <br>    else if( nChkErr == CONVERTERR_METASKIP ) <br>{ <br>// We skip by all meta events that aren't tempo changes... <br>} <br>    else <br>{ <br>DebugPrint( "Unable to add event to stream buffer." ); <br>if( dwMallocBlocks ) <br>    { <br>    free( teTemp.pLongData ); <br>    dwMallocBlocks--; <br>    } <br>return( TRUE ); <br>} <br>    } <br>        } <br> <br>    return( CONVERTERR_NOERROR ); <br>    } <br> <br> <br>// <br>// GetTrackVDWord <br>// <br>// Attempts to parse a variable length DWORD from the given track. A VDWord <br>// in a MIDI file <br>//  (a) is in lo-hi format  <br>//  (b) has the high bit set on every byte except the last <br>// <br>// Returns the DWORD in *lpdw and TRUE on success; else <br>// FALSE if we hit end of track first. Sets ITS_F_ENDOFTRK <br>// if we hit end of track. <br>// <br>static BOOL GetTrackVDWord( PINTRACKSTATE ptsTrack, LPDWORD lpdw ) <br>    { <br>    BYTE    byByte; <br>    DWORD   dw = 0; <br> <br>    if( ptsTrack-&gt;fdwTrack &amp; ITS_F_ENDOFTRK ) <br>        return( TRUE ); <br> <br>    do <br>        { <br>        if( !ptsTrack-&gt;dwLeftInBuffer &amp;&amp; !ptsTrack-&gt;dwLeftOnDisk ) <br>            { <br>            ptsTrack-&gt;fdwTrack |= ITS_F_ENDOFTRK; <br>            return( TRUE ); <br>            } <br> <br>        if( GetTrackByte( ptsTrack, &amp;byByte )) <br>    return( TRUE ); <br> <br>        dw = ( dw &lt;&lt; 7 ) | ( byByte &amp; 0x7F ); <br>        } while( byByte &amp; 0x80 ); <br> <br>    *lpdw = dw; <br> <br>    return( FALSE ); <br>    } <br> <br> <br>// <br>// GetTrackEvent <br>// <br>// Fills in the event struct with the next event from the track <br>// <br>// pteTemp-&gt;tkEvent will contain the absolute tick time of the event <br>// pteTemp-&gt;byShortData[0] will contain <br>//  MIDI_META if the event is a meta event; <br>//   in this case pteTemp-&gt;byShortData[1] will contain the meta class <br>//  MIDI_SYSEX or MIDI_SYSEXEND if the event is a SysEx event <br>//  Otherwise, the event is a channel message and pteTemp-&gt;byShortData[1] <br>//   and pteTemp-&gt;byShortData[2] will contain the rest of the event. <br>// <br>// pteTemp-&gt;dwEventLength will contain <br>//  The total length of the channel message in pteTemp-&gt;byShortData if <br>//   the event is a channel message <br>//  The total length of the paramter data pointed to by <br>//   pteTemp-&gt;pLongData otherwise <br>// <br>// pteTemp-&gt;pLongData will point at any additional paramters if the  <br>//  event is a SysEx or meta event with non-zero length; else <br>//  it will contain NULL <br>// <br>// Returns FALSE on success or TRUE on any kind of parse error <br>// Prints its own error message ONLY in the debug version <br>// <br>// Maintains the state of the input track (i.e. ptsTrack-&gt;dwLeftInBuffer, <br>// ptsTrack-&gt;pTrackPointers, and ptsTrack-&gt;byRunningStatus). <br>// <br>static BOOL GetTrackEvent( INTRACKSTATE *ptsTrack, PTEMPEVENT pteTemp ) <br>    { <br>    DWORD   idx; <br>    BYTE    byByte; <br>    UINT    dwEventLength; <br> <br>    // Clear out the temporary event structure to get rid of old data... <br>    memset( pteTemp, 0, sizeof(TEMPEVENT)); <br> <br>    // Already at end of track? There's nothing to read. <br>    // <br>    if(( ptsTrack-&gt;fdwTrack &amp; ITS_F_ENDOFTRK ) <br>    || ( !ptsTrack-&gt;dwLeftInBuffer &amp;&amp; !ptsTrack-&gt;dwLeftOnDisk )) <br>        return( TRUE ); <br> <br>    // Get the first byte, which determines the type of event. <br>    // <br>    if( GetTrackByte( ptsTrack, &amp;byByte )) <br>return( TRUE ); <br> <br>    // If the high bit is not set, then this is a channel message <br>    // which uses the status byte from the last channel message <br>    // we saw. NOTE: We do not clear running status across SysEx or <br>    // meta events even though the spec says to because there are <br>    // actually files out there which contain that sequence of data. <br>    // <br>    if( !( byByte &amp; 0x80 )) <br>        { <br>        // No previous status byte? We're hosed. <br>        if( !ptsTrack-&gt;byRunningStatus ) <br>            { <br>            TRACKERR(ptsTrack, gteBadRunStat); <br>            return( TRUE ); <br>            } <br> <br>        pteTemp-&gt;byShortData[0] = ptsTrack-&gt;byRunningStatus; <br>        pteTemp-&gt;byShortData[1] = byByte; <br> <br>        byByte = pteTemp-&gt;byShortData[0] &amp; 0xF0; <br>        pteTemp-&gt;dwEventLength = 2; <br> <br>        // Only program change and channel pressure events are 2 bytes long; <br>        // the rest are 3 and need another byte <br>        // <br>        if(( byByte != MIDI_PRGMCHANGE ) &amp;&amp; ( byByte != MIDI_CHANPRESS )) <br>            { <br>            if( !ptsTrack-&gt;dwLeftInBuffer &amp;&amp; !ptsTrack-&gt;dwLeftOnDisk ) <br>                { <br>                TRACKERR( ptsTrack, gteRunStatMsgTrunc ); <br>                ptsTrack-&gt;fdwTrack |= ITS_F_ENDOFTRK; <br>                return( TRUE ); <br>                } <br> <br>            if( GetTrackByte( ptsTrack, &amp;pteTemp-&gt;byShortData[2] )) <br>return( TRUE ); <br>            ++pteTemp-&gt;dwEventLength; <br>            } <br>        } <br>    else if(( byByte &amp; 0xF0 ) != MIDI_SYSEX ) <br>        { <br>        // Not running status, not in SysEx range - must be <br>        // normal channel message (0x80-0xEF) <br>        // <br>        pteTemp-&gt;byShortData[0] = byByte; <br>        ptsTrack-&gt;byRunningStatus = byByte; <br> <br>        // Strip off channel and just keep message type <br>        // <br>        byByte &amp;= 0xF0; <br> <br>        dwEventLength = ( byByte == MIDI_PRGMCHANGE || byByte == MIDI_CHANPRESS ) ? 1 : 2; <br>        pteTemp-&gt;dwEventLength = dwEventLength + 1; <br> <br>        if(( ptsTrack-&gt;dwLeftInBuffer + ptsTrack-&gt;dwLeftOnDisk ) &lt; dwEventLength ) <br>            { <br>            TRACKERR( ptsTrack, gteChanMsgTrunc ); <br>            ptsTrack-&gt;fdwTrack |= ITS_F_ENDOFTRK; <br>            return( TRUE ); <br>            } <br> <br>if( GetTrackByte( ptsTrack, &amp;pteTemp-&gt;byShortData[1] )) <br>    return( TRUE ); <br>        if( dwEventLength == 2 ) <br>            if( GetTrackByte( ptsTrack, &amp;pteTemp-&gt;byShortData[2] )) <br>return( TRUE ); <br>        }  <br>    else if(( byByte == MIDI_SYSEX ) || ( byByte == MIDI_SYSEXEND )) <br>        { <br>        // One of the SysEx types. (They are the same as far as we're concerned; <br>        // there is only a semantic difference in how the data would actually <br>        // get sent when the file is played. We must take care to put the proper <br>        // event type back on the output track, however.) <br>        // <br>        // Parse the general format of: <br>        //  BYTE bEvent (MIDI_SYSEX or MIDI_SYSEXEND) <br>        //  VDWORD cbParms <br>        //  BYTE   abParms[cbParms] <br>        // <br>        pteTemp-&gt;byShortData[0] = byByte; <br>        if( GetTrackVDWord( ptsTrack, &amp;pteTemp-&gt;dwEventLength )) <br>            { <br>            TRACKERR( ptsTrack, gteSysExLenTrunc ); <br>            return( TRUE ); <br>            } <br> <br>        if(( ptsTrack-&gt;dwLeftInBuffer + ptsTrack-&gt;dwLeftOnDisk ) <br>            &lt; pteTemp-&gt;dwEventLength ) <br>            { <br>            TRACKERR( ptsTrack, gteSysExTrunc ); <br>            ptsTrack-&gt;fdwTrack |= ITS_F_ENDOFTRK; <br>            return( TRUE ); <br>            } <br> <br>// Malloc a temporary memory block to hold the parameter data <br>if(( pteTemp-&gt;pLongData = malloc( pteTemp-&gt;dwEventLength )) == NULL ) <br>    { <br>    TRACKERR( ptsTrack, gteNoMem ); <br>    return( TRUE ); <br>    } <br>// Copy from the input buffer to the parameter data buffer <br>for( idx = 0; idx &lt; pteTemp-&gt;dwEventLength; idx++ ) <br>    if( GetTrackByte( ptsTrack, pteTemp-&gt;pLongData + idx )) <br>{ <br>TRACKERR( ptsTrack, gteSysExTrunc ); <br>return( TRUE ); <br>} <br>// Increment our counter, which tells the program to look around for <br>// a malloc block to free, should it need to exit or reset before the <br>// block would normally be freed <br>dwMallocBlocks++; <br>        }  <br>    else if( byByte == MIDI_META ) <br>        { <br>        // It's a meta event. Parse the general form: <br>        //  BYTEbEvent(MIDI_META) <br>        //  BYTEbClass <br>        //  VDWORDcbParms <br>        //  BYTEabParms[cbParms] <br>        // <br>        pteTemp-&gt;byShortData[0] = byByte; <br> <br>        if( !ptsTrack-&gt;dwLeftInBuffer &amp;&amp; !ptsTrack-&gt;dwLeftOnDisk ) <br>            { <br>            TRACKERR(ptsTrack, gteMetaNoClass ); <br>            ptsTrack-&gt;fdwTrack |= ITS_F_ENDOFTRK; <br>            return( TRUE ); <br>            } <br> <br>if( GetTrackByte( ptsTrack, &amp;pteTemp-&gt;byShortData[1] )) <br>    return( TRUE ); <br> <br>        if( GetTrackVDWord( ptsTrack, &amp;pteTemp-&gt;dwEventLength )) <br>            { <br>            TRACKERR( ptsTrack, gteMetaLenTrunc ); <br>            return( TRUE ); <br>            } <br> <br>        // NOTE: It's perfectly valid to have a meta with no data <br>        // In this case, dwEventLength == 0 and pLongData == NULL <br>        // <br>        if( pteTemp-&gt;dwEventLength ) <br>            { <br>            if(( ptsTrack-&gt;dwLeftInBuffer + ptsTrack-&gt;dwLeftOnDisk ) <br>            &lt; pteTemp-&gt;dwEventLength ) <br>                { <br>                TRACKERR( ptsTrack, gteMetaTrunc ); <br>                ptsTrack-&gt;fdwTrack |= ITS_F_ENDOFTRK; <br>                return( TRUE ); <br>                } <br> <br>// Malloc a temporary memory block to hold the parameter data <br>    if(( pteTemp-&gt;pLongData = malloc( pteTemp-&gt;dwEventLength )) <br>        == NULL ) <br>{ <br>TRACKERR( ptsTrack, gteNoMem ); <br>return( TRUE ); <br>} <br>// Copy from the input buffer to the parameter data buffer <br>    for( idx = 0; idx &lt; pteTemp-&gt;dwEventLength; idx++ ) <br> if( GetTrackByte( ptsTrack, pteTemp-&gt;pLongData + idx )) <br>     { <br>     TRACKERR( ptsTrack, gteMetaTrunc ); <br>     return( TRUE ); <br>     } <br>// Increment our counter, which tells the program to look around for <br>// a malloc block to free, should it need to exit or reset before the <br>// block would normally be freed <br>    dwMallocBlocks++; <br>            } <br> <br>        if( pteTemp-&gt;byShortData[1] == MIDI_META_EOT ) <br>            ptsTrack-&gt;fdwTrack |= ITS_F_ENDOFTRK; <br>        } <br>    else <br>        { <br>        // Messages in this range are system messages and aren't supposed to <br>        // be in a normal MIDI file. If they are, we've either misparsed or the <br>        // authoring software is stupid. <br>        // <br>        return( TRUE ); <br>        } <br> <br>    // Event time was already stored as the current track time <br>    // <br>    pteTemp-&gt;tkEvent = ptsTrack-&gt;tkNextEventDue; <br> <br>    // Now update to the next event time. The code above MUST properly <br>    // maintain the end of track flag in case the end of track meta is <br>    // missing.  NOTE: This code is a continuation of the track event <br>    // time pre-read which is done at the end of track initialization. <br>    // <br>    if( !( ptsTrack-&gt;fdwTrack &amp; ITS_F_ENDOFTRK )) <br>        { <br>        DWORDtkDelta; <br> <br>        if( GetTrackVDWord( ptsTrack, &amp;tkDelta )) <br>            return( TRUE ); <br> <br>        ptsTrack-&gt;tkNextEventDue += tkDelta; <br>        } <br> <br>    return( FALSE ); <br>    } <br> <br> <br>// <br>// GetTrackByte <br>// <br>// Retrieve the next byte from the track buffer, refilling the buffer from <br>// disk if necessary. <br>// <br>static BOOL GetTrackByte( PINTRACKSTATE ptsTrack, LPBYTE lpbyByte ) <br>    { <br>    if( !ptsTrack-&gt;dwLeftInBuffer ) <br>{ <br>if( RefillTrackBuffer( ptsTrack )) <br>    return( TRUE ); <br>} <br> <br>    *lpbyByte = *ptsTrack-&gt;pTrackCurrent++; <br>    ptsTrack-&gt;dwLeftInBuffer--; <br>    return( FALSE ); <br>    } <br> <br> <br>// <br>// RefillTrackBuffer() <br>// <br>// This function attempts to read in a buffer-full of data for a MIDI track. <br>// <br>BOOL RefillTrackBuffer( PINTRACKSTATE ptsTrack ) <br>    { <br>    DWORDdwBytesRead, dwResult; <br>    BOOLbResult; <br> <br>    if( ptsTrack-&gt;dwLeftOnDisk ) <br>        { <br>        ptsTrack-&gt;pTrackCurrent = ptsTrack-&gt;pTrackStart; <br> <br>        // Seek to the proper place in the file, indicated by <br>        // ptsTrack-&gt;foNextReadStart and read in the remaining data, <br>        // up to a maximum of the buffer size. <br> <br>        if(( dwResult = SetFilePointer( hInFile, </code></pre>
<p>
</p>
<pre><code>(long)ptsTrack-&gt;foNextReadStart, <br>        0L, FILE_BEGIN )) == 0xFFFFFFFF ) <br>            { <br>            MessageBox( GetActiveWindow(), <br>    "Unable to seek to track buffer location in RefillTrackBuffer()!!", <br>    szAppTitle, MB_OK | MB_ICONEXCLAMATION ); <br>            return( TRUE ); <br>            } <br>        if( ptsTrack-&gt;dwLeftOnDisk &gt; TRACK_BUFFER_SIZE ) <br>            ptsTrack-&gt;dwLeftInBuffer = TRACK_BUFFER_SIZE; <br>        else <br>            ptsTrack-&gt;dwLeftInBuffer = ptsTrack-&gt;dwLeftOnDisk; <br>        bResult = ReadFile( hInFile, ptsTrack-&gt;pTrackStart, <br>ptsTrack-&gt;dwLeftInBuffer, <br>&amp;dwBytesRead, NULL ); <br> <br>        ptsTrack-&gt;dwLeftOnDisk -= dwBytesRead; <br>        ptsTrack-&gt;foNextReadStart = dwResult + dwBytesRead; <br>ptsTrack-&gt;dwLeftInBuffer = dwBytesRead; <br> <br>        if( !bResult || ( bResult &amp;&amp; !dwBytesRead ) <br>    || ( bResult &amp;&amp; dwBytesRead != ptsTrack-&gt;dwLeftInBuffer )) <br>            { <br>            MessageBox( GetActiveWindow(), <br>"Read operation failed prematurely!!", <br>szAppTitle, MB_OK | MB_ICONEXCLAMATION ); <br>    ptsTrack-&gt;dwLeftInBuffer = dwBytesRead; <br>            return( TRUE ); <br>            } <br>        else <br>    return( FALSE ); <br>        } <br> <br>    return( TRUE ); <br>    } <br> <br> <br>// <br>// AddEventToStreamBuffer <br>// <br>// Put the given event into the given stream buffer at the given location <br>// pteTemp must point to an event filled out in accordance with the <br>// description given in GetTrackEvent <br>// <br>// Returns FALSE on sucess or TRUE on an error condition <br>// Handles its own error notification by displaying to the appropriate <br>// output device (either our debugging window, or the screen). <br>// <br>static int AddEventToStreamBuffer( PTEMPEVENT pteTemp, CONVERTINFO *lpciInfo ) <br>    { <br>    DWORDtkNow, tkDelta; <br>    MIDIEVENT*pmeEvent; <br> <br>    pmeEvent = (MIDIEVENT *)( lpciInfo-&gt;mhBuffer.lpData <br>    + lpciInfo-&gt;dwStartOffset <br>    + lpciInfo-&gt;dwBytesRecorded ); <br> <br>    // When we see a new, empty buffer, set the start time on it... <br>    if( !lpciInfo-&gt;dwBytesRecorded ) <br>lpciInfo-&gt;tkStart = tkCurrentTime; <br> <br>    // Use the above set start time to figure out how much longer we should fill <br>    // this buffer before officially declaring it as "full" <br>    if( tkCurrentTime - lpciInfo-&gt;tkStart &gt; dwBufferTickLength ) <br>if( lpciInfo-&gt;bTimesUp ) <br>    { <br>    lpciInfo-&gt;bTimesUp = FALSE; <br>    return( CONVERTERR_BUFFERFULL ); <br>    } <br>else <br>    lpciInfo-&gt;bTimesUp = TRUE; <br> <br>    tkNow = tkCurrentTime; <br> <br>    // Delta time is absolute event time minus absolute time <br>    // already gone by on this track <br>    tkDelta = pteTemp-&gt;tkEvent - tkCurrentTime; <br> <br>    // Event time is now current time on this track <br>    tkCurrentTime = pteTemp-&gt;tkEvent; <br> <br>    if( bInsertTempo ) <br>{ <br>bInsertTempo = FALSE; <br> <br>if( lpciInfo-&gt;dwMaxLength-lpciInfo-&gt;dwBytesRecorded &lt; 3*sizeof(DWORD)) <br>    { <br>    // Cleanup from our write operation <br>    return( CONVERTERR_BUFFERFULL ); <br>    } <br>if( dwCurrentTempo ) <br>    { <br>    pmeEvent-&gt;dwDeltaTime = 0; <br>    pmeEvent-&gt;dwStreamID = 0; <br>    pmeEvent-&gt;dwEvent = ( dwCurrentTempo * 100 ) / dwTempoMultiplier; <br>    pmeEvent-&gt;dwEvent |= (((DWORD)MEVT_TEMPO ) &lt;&lt; 24 ) | MEVT_F_SHORT; <br> <br>    lpciInfo-&gt;dwBytesRecorded += 3 * sizeof(DWORD); <br>    pmeEvent += 3 * sizeof(DWORD); <br>    } <br>} <br> <br>    if( pteTemp-&gt;byShortData[0] &lt; MIDI_SYSEX ) <br>        { <br>        // Channel message. We know how long it is, just copy it. <br>        // Need 3 DWORD's: delta-t, stream-ID, event <br>if( lpciInfo-&gt;dwMaxLength-lpciInfo-&gt;dwBytesRecorded &lt; 3*sizeof(DWORD)) <br>    { <br>    // Cleanup from our write operation <br>    return( CONVERTERR_BUFFERFULL ); <br>    } <br> <br>pmeEvent-&gt;dwDeltaTime = tkDelta; <br>pmeEvent-&gt;dwStreamID = 0; <br>pmeEvent-&gt;dwEvent = ( pteTemp-&gt;byShortData[0] ) <br>| (((DWORD)pteTemp-&gt;byShortData[1] ) &lt;&lt; 8 ) <br>| (((DWORD)pteTemp-&gt;byShortData[2] ) &lt;&lt; 16 ) <br>| MEVT_F_SHORT; <br> <br>        if((( pteTemp-&gt;byShortData[0] &amp; 0xF0) == MIDI_CTRLCHANGE ) <br>        &amp;&amp; ( pteTemp-&gt;byShortData[1] == MIDICTRL_VOLUME )) <br>    { <br>    // If this is a volume change, generate a callback so we can grab <br>    // the new volume for our cache <br>    pmeEvent-&gt;dwEvent |= MEVT_F_CALLBACK; <br>    } <br>lpciInfo-&gt;dwBytesRecorded += 3 *sizeof(DWORD); <br>} <br>    else if(( pteTemp-&gt;byShortData[0] == MIDI_SYSEX ) <br>|| ( pteTemp-&gt;byShortData[0] == MIDI_SYSEXEND )) <br>{ <br>DebugPrint( "AddEventToStreamBuffer: Ignoring SysEx event." ); <br>if( dwMallocBlocks ) <br>    { <br>    free( pteTemp-&gt;pLongData ); <br>    dwMallocBlocks--; <br>    } <br>} <br>    else <br>{ <br>// Better be a meta event. <br>//  BYTEbyEvent <br>//  BYTEbyEventType <br>//  VDWORDdwEventLength <br>//  BYTEpLongEventData[dwEventLength] <br>        // <br>        assert( pteTemp-&gt;byShortData[0] == MIDI_META ); <br> <br>        // The only meta-event we care about is change tempo <br>        // <br>        if( pteTemp-&gt;byShortData[1] != MIDI_META_TEMPO ) <br>            { <br>    if( dwMallocBlocks ) <br>{ <br>free( pteTemp-&gt;pLongData ); <br>dwMallocBlocks--; <br>} <br>            return( CONVERTERR_METASKIP ); <br>    } <br> <br>        // We should have three bytes of parameter data... <br>        assert( pteTemp-&gt;dwEventLength == 3 ); <br> <br>        // Need 3 DWORD's: delta-t, stream-ID, event data <br>if( lpciInfo-&gt;dwMaxLength - lpciInfo-&gt;dwBytesRecorded &lt; 3 *sizeof(DWORD)) <br>    { <br>    // Cleanup the temporary event if necessary and return <br>    if( dwMallocBlocks ) <br>{ <br>free( pteTemp-&gt;pLongData ); <br>dwMallocBlocks--; <br>} <br>    return( CONVERTERR_BUFFERFULL ); <br>    } <br> <br>pmeEvent-&gt;dwDeltaTime = tkDelta; <br>pmeEvent-&gt;dwStreamID = 0; <br>// Note: this is backwards from above because we're converting a single <br>//       data value from hi-lo to lo-hi format... <br>pmeEvent-&gt;dwEvent = ( pteTemp-&gt;pLongData[2] ) <br>| (((DWORD)pteTemp-&gt;pLongData[1] ) &lt;&lt; 8 ) <br>| (((DWORD)pteTemp-&gt;pLongData[0] ) &lt;&lt; 16 ); <br> <br>/* This next step has absolutely nothing to do with the conversion of a <br> * MIDI file to a stream, it's simply put here to add the functionality <br> * of the tempo slider. If you don't need this, be sure to remove the <br> * next two lines. <br> */ <br>dwCurrentTempo = pmeEvent-&gt;dwEvent; <br>pmeEvent-&gt;dwEvent = (pmeEvent-&gt;dwEvent * 100 ) / dwTempoMultiplier; <br> <br>pmeEvent-&gt;dwEvent |= (((DWORD)MEVT_TEMPO ) &lt;&lt; 24 ) | MEVT_F_SHORT; <br> <br>dwBufferTickLength = ( ifs.dwTimeDivision * 1000 * BUFFER_TIME_LENGTH ) / dwCurrentTempo; <br>wsprintf( szTemp, "dwBufferTickLength = %lu", dwBufferTickLength ); <br>DebugPrint( szTemp ); <br> <br>if( dwMallocBlocks ) <br>    { <br>    free( pteTemp-&gt;pLongData ); <br>    dwMallocBlocks--; <br>    } <br>lpciInfo-&gt;dwBytesRecorded += 3 *sizeof(DWORD); <br>} <br> <br>    return( FALSE ); <br>    } <br> <br> <br>#ifdef DEBUG <br>static void ShowTrackError( PINTRACKSTATE ptsTrack, LPSTR lpszErr ) <br>    { <br>    wsprintf( szTemp, "Track buffer offset %lu", <br>    (DWORD)(ptsTrack-&gt;pTrackCurrent - ptsTrack-&gt;pTrackStart)); <br>    DebugPrint( szTemp ); <br>    wsprintf( szTemp, "Track total %lu  Track left %lu", <br>    ptsTrack-&gt;dwTrackLength, ptsTrack-&gt;dwLeftInBuffer ); <br>    DebugPrint( szTemp ); <br>    } <br> <br>#endif <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
