<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MSTREAM.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3264"></a>MSTREAM.C</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1995-1997 Microsoft Corporation. All Rights Reserved. <br> * <br> *  File:   mstream.c <br> *  Content:   Illustrates streaming data from a disk MIDI file to a <br> *             MIDI stream buffer for playback. <br> * <br> ***************************************************************************/ <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;commctrl.h&gt; <br>#include &lt;memory.h&gt; <br>#include &lt;mmreg.h&gt; <br> <br>#include "resource.h" <br>#include "debug.h" <br>#include "midstuff.h" <br>#include "mstream.h" <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// Lots of global variables <br> <br>char szAppClass[] = "MStreamWndClass"; <br>char szAppName[]  = "MStream"; <br> <br>char szAppTitle[64]; <br>char szAppCaption[64]; <br>char szOpenFilter[128]; <br>char szOpenDLGTitle[64]; <br>char szProgress[64]; <br>char szTempo[64]; <br>char szVolume[64]; <br> <br>char szTemp[256]; <br>char szDebug[256]; <br>char szFileBuffer[MAX_PATH]; <br>char szFileTitle[MAX_PATH]; <br> <br>HWNDhWndMain, hWndProgText, hWndProg, hWndVolText, hWndVol, hWndTempoText; <br>HWNDhWndTempo, hWndLoopCheck, hWndPlay, hWndPause, hWndStop; <br> <br>HINSTANCEhInst; <br> <br>BOOLbFileOpen = FALSE, bPlaying = FALSE, bBuffersPrepared = FALSE; <br>BOOLbPaused = FALSE, bLooped = FALSE; <br>UINTuMIDIDeviceID = MIDI_MAPPER, uCallbackStatus; <br>intnTextControlHeight, nCurrentBuffer, nEmptyBuffers; <br>DWORDdwBufferTickLength, dwTempoMultiplier, dwCurrentTempo, dwProgressBytes; <br>DWORDdwVolumePercent, dwVolCache[NUM_CHANNELS]; <br> <br>HMIDISTRM    hStream; <br>CONVERTINFO  ciStreamBuffers[NUM_STREAM_BUFFERS]; <br> <br>// Private to this module... <br>static HANDLEhBufferReturnEvent; <br> <br>// From another module... <br>extern INFILESTATEifs; <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// Module-scope function declarations <br> <br>static BOOL InitApp( HINSTANCE ); <br>static BOOL InitInstance( HINSTANCE, int ); <br>static void FreeBuffers( void ); <br> <br>/****************************************************************************** <br> * WinMain() <br> * <br> * Entry point for all Windows programs - performs initialization, message loop <br> */ <br>int PASCAL WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, <br>LPSTR lpCmdLine, int nCmdShow ) <br>    { <br>    MSG     msg; <br> <br>    hInst = hInstance; <br> <br>    /* Make sure the common controls are loaded for our use */ <br>    InitCommonControls(); <br> <br>// Turn debugging output on or off <br>#ifdef DEBUG <br>    DbgInitialize( TRUE ); <br>#else <br>    DbgInitialize( FALSE ); <br>#endif <br> <br>    if( !hPrevInstance ) <br>        if( !InitApp( hInstance )) <br>            { <br>            ErrorMessageBox( IDS_ERROR_APPINIT, MB_ICONSTOP ); <br>            return( FALSE ); <br>    } <br> <br>    if( !InitInstance( hInstance, nCmdShow )) <br>        { <br>        ErrorMessageBox( IDS_ERROR_INSTANCEINIT, MB_ICONSTOP ); <br>        return( FALSE ); <br>} <br> <br>    while( GetMessage((LPMSG)&amp;msg, NULL, 0, 0 )) <br>        { <br>        TranslateMessage( &amp;msg ); <br>        DispatchMessage( &amp;msg ); <br>        } <br> <br>    UnregisterClass( szAppClass, hInstance ); <br>    return( msg.wParam ); <br>    } /* End of WinMain() */ <br> <br> <br>/*****************************************************************************/ <br>/* InitApp()     */ <br>/*      */ <br>/*   Inits things that only need to be created once for the this application */ <br>/* (like creating the window class).     */ <br>/*****************************************************************************/ <br>static BOOL InitApp( HINSTANCE hInstance ) <br>    { <br>    WNDCLASSwc; <br> <br>    /* Set up and register a window class */ <br>    wc.style= CS_HREDRAW | CS_VREDRAW; <br>    wc.lpszClassName= szAppClass; <br>    wc.lpfnWndProc= (WNDPROC)MainWindowProc; <br>    wc.cbClsExtra= 0; <br>    wc.cbWndExtra= sizeof( DWORD ); <br>    wc.hInstance= hInstance; <br>    wc.hIcon= LoadIcon( hInstance, MAKEINTRESOURCE( IDI_ICON3 )); <br>    wc.hCursor= LoadCursor( NULL, IDC_ARROW ); <br>    wc.hbrBackground= (HBRUSH)( COLOR_WINDOW ); <br>    wc.lpszMenuName= MAKEINTRESOURCE( IDR_MAINMENU ); <br> <br>    if( !RegisterClass( &amp;wc )) <br>        { <br>ErrorMessageBox( IDS_ERROR_REGISTERCLASS, MB_ICONSTOP ); <br>        return( FALSE ); <br>        } <br>    return( TRUE ); <br>    } /* End of InitApp() */ <br> <br> <br>/*****************************************************************************/ <br>/* InitInstance()     */ <br>/*      */ <br>/* Performs initialization that must be done for each application instance.  */ <br>/*      */ <br>/*****************************************************************************/ <br>static BOOL InitInstance( HINSTANCE hInstance, int nCmdShow ) <br>    { <br>    HWNDhWnd; <br>    RECTcrect; <br>    UINTuCharsRead; <br>    MMRESULTmmrRetVal; <br> <br>    LoadString( hInstance, IDS_APP_TITLE, szAppTitle, sizeof(szAppTitle)); <br>    LoadString( hInstance, IDS_APP_CAPTION, szAppCaption, sizeof(szAppCaption)); <br>    LoadString( hInstance, IDS_TBTITLE_VOLUME, szVolume, sizeof(szVolume)); <br>    LoadString( hInstance, IDS_TBTITLE_TEMPO, szTempo, sizeof(szTempo)); <br>    LoadString( hInstance, IDS_TBTITLE_PROGRESS, <br>        szProgress, sizeof(szProgress)); <br>    LoadString( hInstance, IDS_OPEN_DLGTITLE, <br>    szOpenDLGTitle, sizeof(szOpenDLGTitle)); <br>/* This is a little trick designed to allow us to load a common dialog box <br> * filter string, which is really a concatentation of several NULL-terminated <br> * strings. Note that while is is possible to enter something else into the <br> * resource as placeholders for the NULL characters, this has the undesireable <br> * effect of forcing us to search-and-replace byte-by-byte and doesn't make it <br> * as easy to internationalize our strings... <br> */ <br>    memset( szOpenFilter, 0, sizeof(szOpenFilter)); <br>    uCharsRead = LoadString( hInstance, IDS_OPEN_FILTER1, <br>szOpenFilter, sizeof(szOpenFilter)) + 1; <br>    uCharsRead += LoadString( hInstance, IDS_OPEN_FILTER2, <br>    &amp;szOpenFilter[uCharsRead], <br>    sizeof(szOpenFilter) - uCharsRead ) + 1; <br>    uCharsRead += LoadString( hInstance, IDS_OPEN_FILTER3, <br>    &amp;szOpenFilter[uCharsRead], <br>    sizeof(szOpenFilter) - uCharsRead ) + 1; <br>    LoadString( hInstance, IDS_OPEN_FILTER4, <br>    &amp;szOpenFilter[uCharsRead], <br>    sizeof(szOpenFilter) - uCharsRead ); <br> <br>    /* Create an application window */ <br>    hWnd = CreateWindow( szAppClass,/* class name */ <br>szAppCaption,/* caption for window */ <br>WS_OVERLAPPEDWINDOW,/* style */ <br>CW_USEDEFAULT,/* x position */ <br>CW_USEDEFAULT,/* y position */ <br>CW_USEDEFAULT,/* width */ <br>CW_USEDEFAULT,/* height */ <br>NULL,/* parent window */ <br>NULL,/* menu */ <br>hInstance,/* instance */ <br>NULL );/* parms */ <br> <br>    if( !hWnd ) <br>        { <br>ErrorMessageBox( IDS_ERROR_MAINWNDCREATE, MB_ICONSTOP ); <br>        return( FALSE ); <br>} <br> <br>    hWndMain = hWnd; <br>    GetClientRect( hWndMain, &amp;crect ); <br> <br>    /* Create some controls for things like volume, tempo, progress, etc. */ <br>    if( CreateChildren( crect )) <br>        return( FALSE ); <br> <br>    // Resize window, now that we know the height of the static text controls <br>    SetWindowPos( hWnd, NULL, 0, 0, <br>        2 * BORDER_SPACE_CX + TEMPO_TB_CX + 2 * CONTROL_SPACE_CX <br>        + VOL_TB_CX + CHECK_CX, <br>    2 * BORDER_SPACE_CY + nTextControlHeight + TEXT_SPACE_CY <br>    + CONTROL_SPACE_CY + BUTTON_CY + TEMPO_TB_CY, <br>    SWP_NOMOVE | SWP_NOZORDER ); <br> <br>    ShowWindow( hWnd, nCmdShow ); <br>    UpdateWindow( hWnd ); <br> <br>    if(( mmrRetVal = midiStreamOpen( &amp;hStream, <br>    &amp;uMIDIDeviceID, <br>    (DWORD)1, (DWORD)MidiProc, <br>    (DWORD)0, <br>    CALLBACK_FUNCTION )) != MMSYSERR_NOERROR ) <br>{ <br>MidiErrorMessageBox( mmrRetVal ); <br>return( FALSE ); <br>} <br> <br>    return( TRUE ); <br>    } /* End of InitInstance() */ <br> <br> <br>/****************************************************************************/ <br>/* MainWindowProc()                                                         */ <br>/*                                                                          */ <br>/*    Messages for our main window are handled here                         */ <br>/*                                                                          */ <br>/****************************************************************************/ <br>LRESULT CALLBACK MainWindowProc( HWND hWnd, unsigned uMsg, <br>WPARAM wParam, LPARAM lParam ) <br>    { <br>    LPMINMAXINFO    lpMinMax; <br>    DWORDdwCDErr = 0; <br>    BOOLbResult = FALSE; <br>    MMRESULTmmrRetVal; <br>     <br>    switch( uMsg ) <br>        { <br>case WM_CREATE: <br>    hBufferReturnEvent = CreateEvent( NULL, FALSE, <br>    FALSE, "Wait For Buffer Return" ); <br>    break; <br> <br>case WM_MSTREAM_UPDATEVOLUME: <br>    SetChannelVolume( wParam, dwVolumePercent ); <br>    break; <br> <br>case WM_MSTREAM_PROGRESS: <br>    /* Set the Progress text */ <br>            wsprintf( szTemp, "%s: %lu bytes", szProgress, dwProgressBytes ); <br>            Static_SetText( hWndProgText, szTemp ); <br>    break; <br> <br>        case WM_COMMAND: <br>            switch( LOWORD( wParam )) <br>                { <br>                case IDM_FILE_OPEN: <br>                    { <br>                    OPENFILENAMEofn; <br>    /* <br>     * Clear out and fill in an OPENFILENAME structure in preparation <br>     * for creating a common dialog box to open a file. <br>     */ <br>                    memset( &amp;ofn, 0, sizeof(OPENFILENAME)); <br>                    ofn.lStructSize= sizeof(OPENFILENAME); <br>                    ofn.hwndOwner= hWnd; <br>                    ofn.hInstance= hInst; <br>                    ofn.lpstrFilter= szOpenFilter; <br>                    ofn.nFilterIndex= 1; <br>                    szFileBuffer[0]= '\0'; <br>                    ofn.lpstrFile= szFileBuffer; <br>                    ofn.nMaxFile= sizeof(szFileBuffer); <br>                    ofn.lpstrFileTitle= szFileTitle; <br>                    ofn.nMaxFileTitle= sizeof(szFileTitle); <br>                    ofn.lpstrDefExt= "MID"; <br>                    ofn.lpstrTitle= szOpenDLGTitle; <br>                    ofn.Flags= OFN_FILEMUSTEXIST; <br> <br>                    bResult = GetOpenFileName( &amp;ofn ); /* Do the dialog box */ <br> <br>    /* <br>     *A return of TRUE indicates that the user did not select a filename. <br>     * The possible reasons are: Cancel was clicked, or an error occured. <br>     * If Cancel was clicked, the CommDlgExtendedError() function will not <br>     * return a valid code.  For anything else, an error code will come back. <br>     */ <br>                    if( bResult == FALSE ) <br>                        { <br>                        dwCDErr = CommDlgExtendedError(); <br>                        if( dwCDErr ) <br>                            { <br>                            /* Handle a common dialog box error */ <br>                            HandleCommDlgError( dwCDErr ); <br>                            } <br>                        else/* Clicked Cancel, so finish msg processing */ <br>                            return( 0 ); <br>                        } <br>                    else <br>                        { <br>                        if( bFileOpen ) <br>                            { <br>// Need to close the previous file before we open a new one.  The best way to <br>// do this is by faking a menu command, so that we only have the actual code in <br>// one place and it can easily be changed. <br>                            SendMessage( hWnd, WM_COMMAND, <br>                            MAKEWPARAM( IDM_FILE_CLOSE, 0 ), 0L ); <br>                            } <br> <br>                        if( StreamBufferSetup()) <br>                            { <br>                            // Error opening the MIDI file so abort <br>    // The function already took care of notification <br>    break; <br>                            } <br>                        else <br>                            { <br>                            bFileOpen = TRUE; <br>                            EnableWindow( hWndPlay, TRUE ); <br>                            BuildTitleBarText(); <br>                            } <br>                        } <br>                    } <br>                    break; <br> <br>                case IDM_FILE_CLOSE: <br>    SendMessage( hWnd, WM_COMMAND, <br>MAKEWPARAM( IDC_STOP, <br>MSTREAM_STOPF_NOREOPEN ), 0L ); <br>                    BuildTitleBarText(); <br>                    break; <br> <br>                case IDM_HELP_ABOUT: <br>                    DialogBox( hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWndMain, <br>                    (DLGPROC)DLG_About ); <br>                    break; <br> <br>case IDM_ACTIONS_PAUSE: <br>                case IDC_PAUSE: <br>    if( bPaused ) <br>midiStreamRestart( hStream ); <br>    else <br>midiStreamPause( hStream ); <br>    bPaused = !bPaused; <br>                    // If we're paused, the title bar will show (Paused) <br>                    BuildTitleBarText(); <br>    break; <br> <br>case IDM_ACTIONS_LOOPED: <br>case IDC_LOOPCHECK: <br>    Button_SetCheck( hWndLoopCheck, !bLooped ); <br>    bLooped = !bLooped; <br>    break; <br> <br>case IDM_ACTIONS_PLAY: <br>                case IDC_PLAY: <br>    // Clicking play while playback is paused will un-pause it <br>    if( bPaused ) <br>{ <br>SendMessage( hWnd, WM_COMMAND, <br>MAKEWPARAM( IDC_PAUSE, 0 ), 0L ); <br>break; <br>} <br>                    // Clicking play while playing will restart from scratch <br>                    if( bPlaying ) <br>    { <br>    // Stop the file, allowing it to bve reset so that we <br>// can start it over again from the beginning <br>    SendMessage( hWnd, WM_COMMAND, <br>    MAKEWPARAM( IDC_STOP, 0 ), 0L ); <br>} <br> <br>                    if( bFileOpen ) <br>                        { <br>                        // Clear the status of our callback so it will handle <br>// MOM_DONE callbacks once more <br>                        uCallbackStatus = 0; <br>                        if(( mmrRetVal = midiStreamRestart( hStream )) <br>                        != MMSYSERR_NOERROR ) <br>    { <br>    MidiErrorMessageBox( mmrRetVal ); <br>    break; <br>    } <br>                        } <br>                    else <br>                        { <br>                        bPlaying = FALSE; <br>                        break; <br>                        } <br> <br>    bPlaying = TRUE; <br>    EnableWindow( hWndPause, TRUE ); <br>    EnableWindow( hWndStop, TRUE ); <br>                    break; <br> <br>                case IDM_ACTIONS_STOP: <br>                case IDC_STOP: <br>                    if( bFileOpen || bPlaying <br>                    || ( uCallbackStatus != STATUS_CALLBACKDEAD )) <br>{ <br>EnableWindow( hWndStop, FALSE ); <br>EnableWindow( hWndPause, FALSE ); <br>bPlaying = bPaused = FALSE; <br>if( uCallbackStatus != STATUS_CALLBACKDEAD &amp;&amp; uCallbackStatus != STATUS_WAITINGFOREND ) <br>    uCallbackStatus = STATUS_KILLCALLBACK; <br> <br>                        if(( mmrRetVal = midiStreamStop( hStream )) <br>                        != MMSYSERR_NOERROR ) <br>    { <br>    MidiErrorMessageBox( mmrRetVal ); <br>    break; <br>    } <br>                        if(( mmrRetVal = midiOutReset( (HMIDIOUT)hStream )) <br>                        != MMSYSERR_NOERROR ) <br>    { <br>    MidiErrorMessageBox( mmrRetVal ); <br>    break; <br>    } <br>// Wait for the callback thread to release this thread, which it will do by <br>// calling SetEvent() once all buffers are returned to it <br>                        if( WaitForSingleObject( hBufferReturnEvent, <br>                        DEBUG_CALLBACK_TIMEOUT ) <br>                            == WAIT_TIMEOUT ) <br>    { <br>// Note, this is a risky move because the callback may be genuinely busy, but <br>// when we're debugging, it's safer and faster than freezing the application, <br>// which leaves the MIDI device locked up and forces a system reset... <br>    DebugPrint( "Timed out waiting for MIDI callback" ); <br>    uCallbackStatus = STATUS_CALLBACKDEAD; <br>    } <br>                        } <br> <br>    if( uCallbackStatus == STATUS_CALLBACKDEAD ) <br>{ <br>uCallbackStatus = 0; <br>if( bFileOpen ) <br>    { <br>    ConverterCleanup(); <br>    FreeBuffers(); <br>    if( hStream ) <br>{ <br>if(( mmrRetVal = midiStreamClose( hStream )) <br>    != MMSYSERR_NOERROR ) <br>    { <br>    MidiErrorMessageBox( mmrRetVal ); <br>    } <br>hStream = NULL; <br>} <br> <br>    EnableWindow( hWndPlay, FALSE ); <br>    bFileOpen = FALSE; <br>    } <br>                         <br>                        if(!( HIWORD(wParam) &amp; MSTREAM_STOPF_NOREOPEN )) <br>                            { <br>                            if( StreamBufferSetup()) <br>{ <br>// Error setting up for MIDI file <br>// Notification is already taken care of... <br>break; <br>} <br>                            else <br>                                { <br>                                bFileOpen = TRUE; <br>                                EnableWindow( hWndPlay, TRUE ); <br>                                } <br>                            } <br>BuildTitleBarText();// Update the title bar <br>                        } <br>                    break; <br> <br>                case IDM_FILE_EXIT: <br>                    DestroyWindow( hWnd ); <br>                    break; <br>                } <br>            break; <br> <br>case WM_INITMENU: <br>    if( bFileOpen ) <br>{ <br>EnableMenuItem( GetMenu( hWnd ), IDM_ACTIONS_PLAY, <br>                                            MF_BYCOMMAND | MF_ENABLED ); <br>EnableMenuItem( GetMenu( hWnd ), IDM_FILE_CLOSE, <br>                                            MF_BYCOMMAND | MF_ENABLED ); <br>} <br>    else <br>{ <br>EnableMenuItem( GetMenu( hWnd ), IDM_ACTIONS_PLAY, <br>                                            MF_BYCOMMAND | MF_GRAYED ); <br>EnableMenuItem( GetMenu( hWnd ), IDM_FILE_CLOSE, <br>                                            MF_BYCOMMAND | MF_GRAYED ); <br>} <br>    if( bLooped ) <br>EnableMenuItem( GetMenu( hWnd ), IDM_ACTIONS_LOOPED, <br>                                            MF_BYCOMMAND | MF_ENABLED ); <br>    else <br>EnableMenuItem( GetMenu( hWnd ), IDM_ACTIONS_LOOPED, <br>                                            MF_BYCOMMAND | MF_GRAYED ); <br>    if( bPlaying ) <br>{ <br>EnableMenuItem( GetMenu( hWnd ), IDM_ACTIONS_PAUSE, <br>                                            MF_BYCOMMAND | MF_ENABLED ); <br>EnableMenuItem( GetMenu( hWnd ), IDM_ACTIONS_STOP, <br>                                            MF_BYCOMMAND | MF_ENABLED ); <br>} <br>    else <br>{ <br>EnableMenuItem( GetMenu( hWnd ), IDM_ACTIONS_PAUSE, <br>                                            MF_BYCOMMAND | MF_GRAYED ); <br>EnableMenuItem( GetMenu( hWnd ), IDM_ACTIONS_STOP, <br>                                            MF_BYCOMMAND | MF_GRAYED ); <br>} <br>    break; <br> <br>        case WM_GETMINMAXINFO: <br>    /* <br>     * We know exactly how big this window should be, and it's sort of a <br>     * little pop-up control panel, so we can disable window sizing by <br>     * forcing all the minimum and maximum sizes to be the calculated size. <br>     */ <br>            lpMinMax = (LPMINMAXINFO)lParam; <br> <br>            lpMinMax-&gt;ptMaxSize.x = 2*CONTROL_SPACE_CX + 2*BORDER_SPACE_CX <br>                                    + CHECK_CX + TEMPO_TB_CX + VOL_TB_CX <br>                                    + 2*GetSystemMetrics( SM_CXBORDER ); <br>            lpMinMax-&gt;ptMaxSize.y = 2*(BORDER_SPACE_CY <br>                                    + GetSystemMetrics( SM_CYBORDER )) <br>                                    + TEXT_SPACE_CY + nTextControlHeight <br>                                    + TEMPO_TB_CY + BUTTON_CY <br>                                    + CONTROL_SPACE_CY <br>                                    + GetSystemMetrics( SM_CYMENU ) <br>                                    + GetSystemMetrics( SM_CYCAPTION ); <br> <br>            lpMinMax-&gt;ptMinTrackSize.x = lpMinMax-&gt;ptMaxTrackSize.x <br>                            = lpMinMax-&gt;ptMaxSize.x; <br> <br>            lpMinMax-&gt;ptMinTrackSize.y = lpMinMax-&gt;ptMaxTrackSize.y <br>                            = lpMinMax-&gt;ptMaxSize.y; <br>            break; <br> <br>        case WM_HSCROLL: <br>            if(((HWND)lParam == hWndTempo) &amp;&amp; bFileOpen ) <br>                { <br>                HandleTempoScroll( (int)LOWORD(wParam), (int)HIWORD(wParam)); <br>                } <br>            else if(((HWND)lParam == hWndVol) &amp;&amp; bFileOpen ) <br>                { <br>                HandleVolScroll( (int)LOWORD(wParam), (int)HIWORD(wParam)); <br>                } <br>            break; <br> <br>case WM_ENDSESSION: <br>    // If the sesson is ending, we need to do our WM_DESTROY processing <br>    if (!wParam) break; <br>    // NOTE!!! we are falling through to the WM_CLOSE processing. <br>        case WM_DESTROY: <br>            // Stop anything that might be playing and send a flag which will <br>    // tell the code not to automatically reload the file for replay. <br>            if( hStream ) <br>SendMessage( hWnd, WM_COMMAND, <br>                          MAKEWPARAM( IDC_STOP, MSTREAM_STOPF_NOREOPEN ), 0 ); <br> <br>    FreeBuffers(); <br> <br>    if( hStream ) <br>{ <br>if(( mmrRetVal = midiStreamClose( hStream )) <br>    != MMSYSERR_NOERROR ) <br>    { <br>    MidiErrorMessageBox( mmrRetVal ); <br>    } <br>hStream = NULL; <br>} <br> <br>            CloseHandle( hBufferReturnEvent ); <br>             <br>            PostQuitMessage( 0 ); <br>            break; <br> <br>        default: <br>            return DefWindowProc( hWnd, uMsg, wParam, lParam ); <br>        } <br>    return 0L; <br>    } /* MainWindowProc */ <br> <br> <br>/*****************************************************************************/ <br>/* DLG_About()                                                               */ <br>/*                                                                           */ <br>/*   Dialog procedure for the Help...About... box which simply pops up a     */ <br>/* little copyright message and brief program description.                   */ <br>/*                                                                           */ <br>/*****************************************************************************/ <br>BOOL CALLBACK DLG_About( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam ) <br>    { <br>    switch( msg ) <br>        { <br>        case WM_INITDIALOG: <br>            break; <br> <br>        case WM_COMMAND: <br>            switch( LOWORD(wParam)) <br>                { <br>                case IDOK: <br>                    EndDialog( hDlg, FALSE ); <br>                    return( TRUE ); <br> <br>                default: <br>                    break; <br>                } <br>            break; <br> <br>        default: <br>            return( FALSE ); <br>        } <br> <br>    return( FALSE ); <br>    } <br> <br> <br>/*****************************************************************************/ <br>/* FreeBuffers()                                                             */ <br>/*                                                                           */ <br>/*   This function unprepares and frees all our buffers -- something we must */ <br>/* do to work around a bug in MMYSYSTEM that prevents a device from playing  */ <br>/* back properly unless it is closed and reopened after each stop.           */ <br>/*****************************************************************************/ <br>void FreeBuffers( void ) <br>    { <br>    DWORDidx; <br>    MMRESULTmmrRetVal; <br> <br>    if( bBuffersPrepared ) <br>{ <br>for( idx = 0; idx &lt; NUM_STREAM_BUFFERS; idx++ ) <br>    if(( mmrRetVal = midiOutUnprepareHeader( (HMIDIOUT)hStream, <br>&amp;ciStreamBuffers[idx].mhBuffer, <br>sizeof(MIDIHDR))) <br>!= MMSYSERR_NOERROR ) <br>{ <br>MidiErrorMessageBox( mmrRetVal ); <br>} <br>    bBuffersPrepared = FALSE; <br>    } <br>// Free our stream buffers... <br>for( idx = 0; idx &lt; NUM_STREAM_BUFFERS; idx++ ) <br>    if( ciStreamBuffers[idx].mhBuffer.lpData ) <br>{ <br>GlobalFreePtr( ciStreamBuffers[idx].mhBuffer.lpData ); <br>ciStreamBuffers[idx].mhBuffer.lpData = NULL; <br>} <br>    } <br> <br> <br>/*****************************************************************************/ <br>/* StreamBufferSetup()                                                       */ <br>/*                                                                           */ <br>/*    This function uses the filename stored in the global character array to*/ <br>/* open a MIDI file. Then it goes about converting at least the first part of*/ <br>/* that file into a midiStream buffer for playback.                          */ <br>/*****************************************************************************/ <br>BOOL StreamBufferSetup( void ) <br>    { <br>    int     nChkErr; <br>    BOOL    bFoundEnd = FALSE; <br>    DWORD   dwConvertFlag, idx; <br> <br>    MMRESULTmmrRetVal; <br>    MIDIPROPTIMEDIVmptd; <br> <br>    if( !hStream ) <br>if(( mmrRetVal = midiStreamOpen( &amp;hStream, <br>    &amp;uMIDIDeviceID, <br>    (DWORD)1, (DWORD)MidiProc, <br>    (DWORD)0, <br>    CALLBACK_FUNCTION )) != MMSYSERR_NOERROR ) <br>    { <br>    MidiErrorMessageBox( mmrRetVal ); <br>    return( TRUE ); <br>    } <br> <br>    for( idx = 0; idx &lt; NUM_STREAM_BUFFERS; idx++ ) <br>{ <br>ciStreamBuffers[idx].mhBuffer.dwBufferLength = OUT_BUFFER_SIZE; <br>if(( ciStreamBuffers[idx].mhBuffer.lpData <br>= GlobalAllocPtr( GHND, OUT_BUFFER_SIZE )) == NULL ) <br>    { <br>    // Buffers we already allocated will be killed by WM_DESTROY <br>    // after we fail on the create by returning with -1 <br>    return( -1 ); <br>    } <br>} <br>    if( ConverterInit( szFileBuffer )) <br>return( TRUE ); <br> <br>    // Initialize the volume cache array to some pre-defined value <br>    for( idx = 0; idx &lt; NUM_CHANNELS; idx++ ) <br>dwVolCache[idx] = VOL_CACHE_INIT; <br> <br>    mptd.cbStruct = sizeof(mptd); <br>    mptd.dwTimeDiv = ifs.dwTimeDivision; <br>    if(( mmrRetVal = midiStreamProperty( hStream, (LPBYTE)&amp;mptd, <br>    MIDIPROP_SET | MIDIPROP_TIMEDIV )) <br>    != MMSYSERR_NOERROR ) <br>{ <br>MidiErrorMessageBox( mmrRetVal ); <br>ConverterCleanup(); <br>return( TRUE ); <br>} <br> <br>    nEmptyBuffers = 0; <br>    dwConvertFlag = CONVERTF_RESET; <br> <br>    for( nCurrentBuffer = 0; nCurrentBuffer &lt; NUM_STREAM_BUFFERS; <br>        nCurrentBuffer++ ) <br>{ <br>    // Tell the converter to convert up to one entire buffer's length of output <br>    // data. Also, set a flag so it knows to reset any saved state variables it <br>    // may keep from call to call. <br>ciStreamBuffers[nCurrentBuffer].dwStartOffset = 0; <br>ciStreamBuffers[nCurrentBuffer].dwMaxLength = OUT_BUFFER_SIZE; <br>ciStreamBuffers[nCurrentBuffer].tkStart = 0; <br>        ciStreamBuffers[nCurrentBuffer].bTimesUp = FALSE; <br> <br>if(( nChkErr = ConvertToBuffer( dwConvertFlag, <br>&amp;ciStreamBuffers[nCurrentBuffer] )) <br>    != CONVERTERR_NOERROR ) <br>        { <br>    if( nChkErr == CONVERTERR_DONE ) <br>{ <br>bFoundEnd = TRUE; <br>} <br>    else <br>{ <br>DebugPrint( "Initial conversion pass failed" ); <br>ConverterCleanup(); <br>return( TRUE ); <br>} <br>    } <br>ciStreamBuffers[nCurrentBuffer].mhBuffer.dwBytesRecorded <br>    = ciStreamBuffers[nCurrentBuffer].dwBytesRecorded; <br> <br>if( !bBuffersPrepared ) <br>    if(( mmrRetVal = midiOutPrepareHeader( (HMIDIOUT)hStream, <br>    &amp;ciStreamBuffers[nCurrentBuffer].mhBuffer, <br>    sizeof(MIDIHDR))) != MMSYSERR_NOERROR ) <br>{ <br>MidiErrorMessageBox( mmrRetVal ); <br>ConverterCleanup(); <br>return( TRUE ); <br>} <br>if(( mmrRetVal = midiStreamOut( hStream, <br>    &amp;ciStreamBuffers[nCurrentBuffer].mhBuffer, <br>    sizeof(MIDIHDR))) != MMSYSERR_NOERROR ) <br>    { <br>    MidiErrorMessageBox( mmrRetVal ); <br>    break; <br>    } <br>dwConvertFlag = 0; <br> <br>if( bFoundEnd ) <br>    break; <br>} <br> <br>    bBuffersPrepared = TRUE; <br>    nCurrentBuffer = 0; <br>    UpdateFromControls(); <br>    return( FALSE ); <br>    } <br> <br> <br>/*****************************************************************************/ <br>/* MidiProc()                                                                */ <br>/*                                                                           */ <br>/*   This is the callback handler which continually refills MIDI data buffers*/ <br>/* as they're returned to us from the audio subsystem.                       */ <br>/*****************************************************************************/ <br>void CALLBACK MidiProc( HMIDIIN hMidi, UINT uMsg, DWORD dwInstance, <br>DWORD dwParam1, DWORD dwParam2 ) <br>    { <br>    static intnWaitingBuffers = 0; <br>    MIDIEVENT*pme; <br>    MIDIHDR*pmh; <br> <br>    MMRESULTmmrRetVal; <br>    intnChkErr; <br> <br> <br>    switch( uMsg ) <br>{ <br>case MOM_DONE: <br>            if( uCallbackStatus == STATUS_CALLBACKDEAD ) <br>                return; <br> <br>    nEmptyBuffers++; <br> <br>    if( uCallbackStatus == STATUS_WAITINGFOREND ) <br>{ <br>if( nEmptyBuffers &lt; NUM_STREAM_BUFFERS ) <br>    { <br>    return; <br>    } <br>else <br>    { <br>    uCallbackStatus = STATUS_CALLBACKDEAD; <br>    PostMessage( hWndMain, WM_COMMAND, <br>MAKEWPARAM( IDC_STOP, 0 ), 0L ); <br>    SetEvent( hBufferReturnEvent ); <br>    return; <br>    } <br>} <br> <br>// This flag is set whenever the callback is waiting for all buffers to <br>// come back. <br>            if( uCallbackStatus == STATUS_KILLCALLBACK ) <br>{ <br>// Count NUM_STREAM_BUFFERS-1 being returned for the last time <br>if( nEmptyBuffers &lt; NUM_STREAM_BUFFERS ) <br>                    { <br>                    return; <br>                    } <br>// Then send a stop message when we get the last buffer back... <br>else <br>    { <br>    // Change the status to callback dead <br>    uCallbackStatus = STATUS_CALLBACKDEAD; <br>    SetEvent( hBufferReturnEvent ); <br>    return; <br>    } <br>                } <br> <br>            dwProgressBytes <br>                += ciStreamBuffers[nCurrentBuffer].mhBuffer.dwBytesRecorded; <br>    PostMessage( hWndMain, WM_MSTREAM_PROGRESS, 0L, 0L ); <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// Fill an available buffer with audio data again... <br> <br>    if( bPlaying &amp;&amp; nEmptyBuffers ) <br>{ <br> ciStreamBuffers[nCurrentBuffer].dwStartOffset = 0; <br>ciStreamBuffers[nCurrentBuffer].dwMaxLength = OUT_BUFFER_SIZE; </code></pre>
<p>
</p>
<pre><code>ciStreamBuffers[nCurrentBuffer].tkStart = 0; <br>ciStreamBuffers[nCurrentBuffer].dwBytesRecorded = 0; <br>ciStreamBuffers[nCurrentBuffer].bTimesUp = FALSE; <br> <br>if(( nChkErr = ConvertToBuffer( 0, <br>    &amp;ciStreamBuffers[nCurrentBuffer] )) <br>    != CONVERTERR_NOERROR ) <br>        { <br>    if( nChkErr == CONVERTERR_DONE ) <br>{ <br>// Don't include this one in the count <br>nWaitingBuffers = NUM_STREAM_BUFFERS - 1; <br>uCallbackStatus = STATUS_WAITINGFOREND; <br>return; <br>} <br>    else <br>{ <br>DebugPrint( "MidiProc() conversion pass failed!" ); <br>ConverterCleanup(); <br>return; <br>} <br>    } <br> <br>ciStreamBuffers[nCurrentBuffer].mhBuffer.dwBytesRecorded <br>    = ciStreamBuffers[nCurrentBuffer].dwBytesRecorded; <br> <br>if(( mmrRetVal = midiStreamOut( hStream, <br>    &amp;ciStreamBuffers[nCurrentBuffer].mhBuffer, <br>    sizeof(MIDIHDR))) != MMSYSERR_NOERROR ) <br>    { <br>    MidiErrorMessageBox( mmrRetVal ); <br>    ConverterCleanup(); <br>    return; <br>    } <br>nCurrentBuffer = ( nCurrentBuffer + 1 ) % NUM_STREAM_BUFFERS; <br>nEmptyBuffers--; <br>} <br> <br>    break; <br> <br>case MOM_POSITIONCB: <br>    pmh = (MIDIHDR *)dwParam1; <br>    pme = (MIDIEVENT *)(pmh-&gt;lpData + pmh-&gt;dwOffset); <br>    if( MIDIEVENT_TYPE( pme-&gt;dwEvent ) == MIDI_CTRLCHANGE ) <br>{ <br>if( MIDIEVENT_DATA1( pme-&gt;dwEvent ) == MIDICTRL_VOLUME_LSB ) <br>    { <br>    DebugPrint( "Got an LSB volume event" ); <br>    break; <br>    } <br>if( MIDIEVENT_DATA1( pme-&gt;dwEvent ) != MIDICTRL_VOLUME ) <br>    break; <br> <br>// Mask off the channel number and cache the volume data byte <br>dwVolCache[ MIDIEVENT_CHANNEL( pme-&gt;dwEvent )] <br>= MIDIEVENT_VOLUME( pme-&gt;dwEvent ); <br>// Post a message so that the main program knows to counteract <br>// the effects of the volume event in the stream with its own <br>// generated event which reflects the proper trackbar position. <br>PostMessage( hWndMain, WM_MSTREAM_UPDATEVOLUME, <br>MIDIEVENT_CHANNEL( pme-&gt;dwEvent ), 0L ); <br>} <br>    break; <br> <br>default: <br>    break; <br>} <br> <br>    return; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
