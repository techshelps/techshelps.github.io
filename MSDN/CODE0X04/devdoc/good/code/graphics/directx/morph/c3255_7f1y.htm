<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MORPH.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3256"></a>MORPH.CPP</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1995, 1996 Microsoft Corporation. All Rights Reserved. <br> * <br> *  File: morph.c <br> * <br> ***************************************************************************/ <br> <br>/* <br> * An example of the use of interpolators. <br> */ <br> <br>#include "rmdemo.h" <br> <br>#define NO_NORMAL {D3DVAL(0), D3DVAL(0), D3DVAL(0)}, D3DVAL(0), D3DVAL(0), 0 <br> <br>/* cube corners */ <br>#define CFTL(v){{-D3DVAL(v), +D3DVAL(v), -D3DVAL(v)}, NO_NORMAL} <br>#define CFTR(v){{+D3DVAL(v), +D3DVAL(v), -D3DVAL(v)}, NO_NORMAL} <br>#define CFBR(v){{+D3DVAL(v), -D3DVAL(v), -D3DVAL(v)}, NO_NORMAL} <br>#define CFBL(v){{-D3DVAL(v), -D3DVAL(v), -D3DVAL(v)}, NO_NORMAL} <br>#define CBTL(v){{-D3DVAL(v), +D3DVAL(v), +D3DVAL(v)}, NO_NORMAL} <br>#define CBTR(v){{+D3DVAL(v), +D3DVAL(v), +D3DVAL(v)}, NO_NORMAL} <br>#define CBBR(v){{+D3DVAL(v), -D3DVAL(v), +D3DVAL(v)}, NO_NORMAL} <br>#define CBBL(v){{-D3DVAL(v), -D3DVAL(v), +D3DVAL(v)}, NO_NORMAL} <br> <br>/* face centers */ <br>#define FRT(v){{ D3DVAL(0),  D3DVAL(0), -D3DVAL(v)}, NO_NORMAL} <br>#define BCK(v){{ D3DVAL(0),  D3DVAL(0),  D3DVAL(v)}, NO_NORMAL} <br>#define BTM(v){{ D3DVAL(0), -D3DVAL(v),  D3DVAL(0)}, NO_NORMAL} <br>#define TOP(v){{ D3DVAL(0),  D3DVAL(v),  D3DVAL(0)}, NO_NORMAL} <br>#define LFT(v){{-D3DVAL(v),  D3DVAL(0),  D3DVAL(0)}, NO_NORMAL} <br>#define RGT(v){{ D3DVAL(v),  D3DVAL(0),  D3DVAL(0)}, NO_NORMAL} <br> <br> <br>D3DRMVERTEX verts0[] = <br>{   CFTL(1), CFTR(1), CFBR(1), CFBL(1), <br>    CBBR(1), CBTR(1), CBTL(1), CBBL(1), <br>    CFBR(1), CBBR(1), CBBL(1), CFBL(1), <br>    CBTL(1), CBTR(1), CFTR(1), CFTL(1), <br>    CBTL(1), CFTL(1), CFBL(1), CBBL(1), <br>    CFBR(1), CFTR(1), CBTR(1), CBBR(1), <br>    FRT(5), BCK(5), BTM(5), TOP(5), LFT(5), RGT(5) <br>}; <br> <br>D3DRMVERTEX verts1[] = <br>{   CFTL(2), CFTR(2), CFBR(2), CFBL(2), <br>    CBBR(2), CBTR(2), CBTL(2), CBBL(2), <br>    CFBR(2), CBBR(2), CBBL(2), CFBL(2), <br>    CBTL(2), CBTR(2), CFTR(2), CFTL(2), <br>    CBTL(2), CFTL(2), CFBL(2), CBBL(2), <br>    CFBR(2), CFTR(2), CBTR(2), CBBR(2), <br>    FRT(1), BCK(1), BTM(1), TOP(1), LFT(1), RGT(1) <br>}; <br> <br>unsigned faces[] = <br>{    0,  1, 24,  1,  2, 24,  2,  3, 24,  3,  0, 24, <br>     4,  5, 25,  5,  6, 25,  6,  7, 25,  7,  4, 25, <br>     8,  9, 26,  9, 10, 26, 10, 11, 26, 11,  8, 26, <br>    12, 13, 27, 13, 14, 27, 14, 15, 27, 15, 12, 27, <br>    16, 17, 28, 17, 18, 28, 18, 19, 28, 19, 16, 28, <br>    20, 21, 29, 21, 22, 29, 22, 23, 29, 23, 20, 29 <br>}; <br> <br>static void CDECL destroyInterp(LPDIRECT3DRMOBJECT obj, void* arg) <br>{ <br>    LPDIRECT3DRMINTERPOLATOR meshInterp = (LPDIRECT3DRMINTERPOLATOR) arg; <br> <br>    if (meshInterp) meshInterp-&gt;Release(); <br>} <br> <br>void CDECL  <br>interpolate(LPDIRECT3DRMFRAME frame, void *arg, D3DVALUE delta) <br>{ <br>    static D3DVALUE val = D3DVAL(0); <br>    LPDIRECT3DRMINTERPOLATOR meshInterp = (LPDIRECT3DRMINTERPOLATOR) arg; <br> <br>    meshInterp-&gt;Interpolate(val += delta, NULL, D3DRMINTERPOLATION_CLOSED | D3DRMINTERPOLATION_LINEAR); <br>} <br> <br>void generate_normals(D3DRMVERTEX verts[]) <br>{ <br>    unsigned i; <br>    D3DVECTOR a, b; <br> <br>    for (i = 0; i &lt; 24; i++) <br>    { <br>D3DRMVectorSubtract(&amp;a, &amp;verts[faces[i * 3 + 1]].position, &amp;verts[i].position); <br>D3DRMVectorSubtract(&amp;b, &amp;verts[faces[i * 3 + 2]].position, &amp;verts[i].position); <br>D3DRMVectorCrossProduct(&amp;verts[i].normal, &amp;a, &amp;b); <br>D3DRMVectorNormalize(&amp;verts[i].normal); <br>    } <br>} <br> <br>#define D3DTRY(x) if (FAILED(x)) goto generic_error <br> <br>#define CREATE(type, obj) CreateObject(CLSID_C##type, NULL, IID_I##type, (void **) obj) <br> <br>BOOL <br>BuildScene(LPDIRECT3DRMDEVICE dev, LPDIRECT3DRMVIEWPORT view, <br>   LPDIRECT3DRMFRAME scene, LPDIRECT3DRMFRAME camera) <br>{ <br>    LPDIRECT3DRMMESH mesh = NULL, meshProxy = NULL; <br>    LPDIRECT3DRMFRAME frame = NULL, proxyFrame = NULL; <br>    LPDIRECT3DRMFRAME axis = NULL; <br>    LPDIRECT3DRMFRAME orbit = NULL; <br>    LPDIRECT3DRMLIGHT light1 = NULL; <br>    LPDIRECT3DRMLIGHT light2 = NULL; <br>    LPDIRECT3DRMINTERPOLATOR meshInterp = NULL; <br> <br>    dev, view, camera; <br> <br>    /* generate flat-shading normals for faces */ <br>    generate_normals(verts0); <br>    generate_normals(verts1); <br> <br>    D3DTRY(lpD3DRM-&gt;CreateObject(CLSID_CDirect3DRMMeshInterpolator, NULL,  <br> IID_IDirect3DRMInterpolator, (void **) &amp;meshInterp)); <br>    D3DTRY(meshInterp-&gt;QueryInterface(IID_IDirect3DRMMesh, (void **) &amp;meshProxy)); <br> <br>    D3DTRY(meshInterp-&gt;SetIndex(D3DVAL(0))); <br>    D3DTRY(meshProxy-&gt;SetVertices(0, 0, 30, verts1)); <br>    D3DTRY(meshProxy-&gt;SetGroupColorRGB(0, D3DVAL(0.5), D3DVAL(0.4), D3DVAL(0.7))); <br> <br>    D3DTRY(meshInterp-&gt;SetIndex(D3DVAL(25))); <br>    D3DTRY(meshProxy-&gt;SetVertices(0, 0, 30, verts0)); <br>    D3DTRY(meshProxy-&gt;SetGroupColorRGB(0, D3DVAL(1), D3DVAL(0.0), D3DVAL(0.3))); <br> <br>    D3DTRY(meshInterp-&gt;SetIndex(D3DVAL(40))); <br>    D3DTRY(meshProxy-&gt;SetGroupColorRGB(0, D3DVAL(0.6), D3DVAL(0.6), D3DVAL(0.6))); <br> <br>    D3DTRY(meshInterp-&gt;SetIndex(D3DVAL(75))); <br>    meshProxy-&gt;Release(); <br> <br>    D3DTRY(lpD3DRM-&gt;CREATE(Direct3DRMLight, &amp;light1)); <br>    D3DTRY(light1-&gt;SetType(D3DRMLIGHT_AMBIENT)); <br>    D3DTRY(light1-&gt;SetColorRGB(D3DVAL(0.2), D3DVAL(0.2), D3DVAL(0.2))); <br> <br>    D3DTRY(lpD3DRM-&gt;CREATE(Direct3DRMLight, &amp;light2)); <br>    D3DTRY(light2-&gt;SetType(D3DRMLIGHT_DIRECTIONAL)); <br>    D3DTRY(light2-&gt;SetColorRGB(D3DVAL(1), D3DVAL(1), D3DVAL(1))); <br> <br>    D3DTRY(scene-&gt;AddLight(light1)); <br>    D3DTRY(scene-&gt;SetSceneBackgroundRGB(D3DVAL(0.3), D3DVAL(0.6), D3DVAL(0.3))); <br> <br>    D3DTRY(lpD3DRM-&gt;CREATE(Direct3DRMFrame, &amp;frame)); <br>    D3DTRY(scene-&gt;AddChild(frame)); <br>    D3DTRY(frame-&gt;SetOrientation(scene, D3DVAL(0.5), -D3DVAL(0.5), D3DVAL(1), <br> D3DVAL(0), D3DVAL(1), D3DVAL(0))); <br> <br>    D3DTRY(frame-&gt;AddLight(light2)); <br>    frame-&gt;Release(); <br> <br>    D3DTRY(lpD3DRM-&gt;CREATE(Direct3DRMFrame, &amp;frame)); <br>    D3DTRY(scene-&gt;AddChild(frame)); <br>    D3DTRY(frame-&gt;SetPosition(scene, D3DVAL(0), D3DVAL(0), D3DVAL(15))); <br>    D3DTRY(frame-&gt;SetOrientation(scene, D3DVAL(0), D3DVAL(1.0), D3DVAL(0), <br>    D3DVAL(0), D3DVAL(0), D3DVAL(1))); <br>    D3DTRY(frame-&gt;SetRotation(scene, D3DVAL(0), D3DVAL(0.9), D3DVAL(1.0), D3DVAL(0.04))); <br> <br>    D3DTRY(lpD3DRM-&gt;CREATE(Direct3DRMMesh, &amp;mesh)); <br>    D3DTRY(mesh-&gt;AddGroup(30, 24, 3, faces, NULL)); <br>    D3DTRY(mesh-&gt;SetGroupQuality(0, D3DRMRENDER_FLAT)); <br> <br>    D3DTRY(meshInterp-&gt;AttachObject(mesh)); <br>    D3DTRY(frame-&gt;AddVisual(mesh)); <br> <br>    D3DTRY(frame-&gt;AddMoveCallback(interpolate, meshInterp)); <br>    D3DTRY(frame-&gt;AddDestroyCallback(destroyInterp, meshInterp)); <br> <br>    D3DTRY(lpD3DRM-&gt;CREATE(Direct3DRMFrame, &amp;axis)); <br>    D3DTRY(frame-&gt;AddChild(axis)); <br>    D3DTRY(axis-&gt;SetRotation(frame, D3DVAL(0), D3DVAL(1), D3DVAL(0), D3DVAL(0.04))); <br> <br>    D3DTRY(lpD3DRM-&gt;CREATE(Direct3DRMFrame, &amp;orbit)); <br>    D3DTRY(axis-&gt;AddChild(orbit)); <br>    D3DTRY(orbit-&gt;SetPosition(axis, D3DVAL(2.6), D3DVAL(0), D3DVAL(0))); <br> <br>    RELEASE(mesh); <br>    RELEASE(frame); <br>    RELEASE(axis); <br>    RELEASE(orbit); <br>    RELEASE(light1); <br>    RELEASE(light2); <br>    /* don't release the wrap */ <br>    return TRUE; <br>generic_error: <br>    Msg("A failure occurred while building the scene.\n"); <br>    RELEASE(mesh); <br>    RELEASE(frame); <br>    RELEASE(axis); <br>    RELEASE(orbit); <br>    RELEASE(light1); <br>    RELEASE(light2); <br>    return FALSE; <br>} <br> <br>void <br>OverrideDefaults(Defaults* defaults) <br>{ <br>    defaults-&gt;bConstRenderQuality = TRUE; <br>    lstrcpy(defaults-&gt;Name, "Interpolator Direct3DRM Example"); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
