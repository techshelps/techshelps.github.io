<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>D3DEX1.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3002"></a>D3DEX1.C</h2>
<pre><code>/*********************************************************************** <br> * <br> * File :       d3dex1.c <br> * <br> * Abstract :   A very simple Direct3D example which simply draws a <br> *              single, rotating, Gouraud shaded triangle in a fixed <br> *              size window. <br> * <br> *              For code clarity a number of issues have not been <br> *              addressed in this sample. For example, full screen <br> *              operation, resizing the window, texture mapping are <br> *              not included. Furthermore, certain optimizations have <br> *              not been included where they would obfuscate the code. <br> *              Every attempt has been made to highlight these areas <br> *              will extensive comments. <br> * <br> * Author :     Colin D. C. McCartney <br> * <br> * Date :       09/04/96 <br> * <br> * Version :    V1.0 <br> * <br> * To do: <br> * - Handle DDERR_WRONGMODE <br> * <br> * Copyright (C) 1995-1997 Microsoft Corporation. All Rights Reserved. <br> ***********************************************************************/ <br> <br>/*********************************************************************** <br> * <br> * Include files <br> * <br> ***********************************************************************/ <br> <br>#define  INITGUID <br>#include &lt;windows.h&gt; <br>#include &lt;math.h&gt; <br>#include &lt;assert.h&gt; <br>#include &lt;ddraw.h&gt; <br>#include &lt;d3d.h&gt; <br> <br>#include "nowarn.h" <br>#include "resource.h" <br> <br>#ifdef DEBUG <br>// Make it possible to get reasonable symbols for poor debuggers <br>#define static  <br>#endif <br> <br> /*********************************************************************** <br> * <br> * Constants <br> * <br> ***********************************************************************/ <br> <br>/* <br> * Class name for this application's window class. <br> */ <br>#define WINDOW_CLASSNAME      "D3DSample1Class" <br> <br>/* <br> * Title for the application's window. <br> */ <br>#define WINDOW_TITLE          "D3D Sample 1" <br> <br>/* <br> * String to be displayed when the application is paused. <br> */ <br>#define PAUSED_STRING         "Paused" <br> <br>/* <br> * Half height of the view window. <br> */ <br>#define HALF_HEIGHT           D3DVAL(0.5) <br> <br>/* <br> * Front and back clipping planes. <br> */ <br>#define FRONT_CLIP            D3DVAL(1.0) <br>#define BACK_CLIP             D3DVAL(1000.0) <br> <br>/* <br> * Fixed window size. <br> */ <br>#define WINDOW_WIDTH          320 <br>#define WINDOW_HEIGHT         200 <br> <br>/* <br> * Maximum length of the chosen device name and description of the <br> * chosen Direct3D device. <br> */ <br>#define MAX_DEVICE_NAME       256 <br>#define MAX_DEVICE_DESC       256 <br> <br>/* <br> * Amount to rotate per frame. <br> */ <br>#define M_PI                  3.14159265359 <br>#define M_2PI                 6.28318530718 <br>#define ROTATE_ANGLE_DELTA    (M_2PI / 300.0) <br> <br>/* <br> * Execute buffer contents <br> */ <br>#define NUM_VERTICES          3UL <br>#define NUM_INSTRUCTIONS      6UL <br>#define NUM_STATES            8UL <br>#define NUM_PROCESSVERTICES   1UL <br>#define NUM_TRIANGLES         1UL <br> <br>/*********************************************************************** <br> * <br> * Macro funtions. <br> * <br> ***********************************************************************/ <br> <br>/* <br> * Extract the error code from an HRESULT <br> */ <br>#define CODEFROMHRESULT(hRes) ((hRes) &amp; 0x0000FFFFUL) <br> <br>/*********************************************************************** <br> * <br> * Global store <br> * <br> ***********************************************************************/ <br> <br>/* <br> * Application instance handle (set in WinMain). <br> */ <br>static HINSTANCE               hAppInstance              = NULL; <br> <br>/* <br> * Running in debug mode? <br> */ <br>static BOOL                    fDebug                    = FALSE; <br> <br>/* <br> * Is the app. active? <br> */ <br>static BOOL                    fActive                   = TRUE; <br> <br>/* <br> * Has the app. been suspended? <br> */ <br>static BOOL                    fSuspended                = FALSE; <br> <br>/* <br> * DirectDraw interfaces <br> */ <br>static LPDIRECTDRAW            lpdd                      = NULL; <br>static LPDIRECTDRAWSURFACE     lpddPrimary               = NULL; <br>static LPDIRECTDRAWSURFACE     lpddDevice                = NULL; <br>static LPDIRECTDRAWSURFACE     lpddZBuffer               = NULL; <br>static LPDIRECTDRAWPALETTE     lpddPalette               = NULL; <br> <br>/* <br> * Direct3D interfaces <br> */ <br>static LPDIRECT3D              lpd3d                     = NULL; <br>static LPDIRECT3DDEVICE        lpd3dDevice               = NULL; <br>static LPDIRECT3DMATERIAL      lpd3dMaterial             = NULL; <br>static LPDIRECT3DMATERIAL      lpd3dBackgroundMaterial   = NULL; <br>static LPDIRECT3DVIEWPORT      lpd3dViewport             = NULL; <br>static LPDIRECT3DLIGHT         lpd3dLight                = NULL; <br>static LPDIRECT3DEXECUTEBUFFER lpd3dExecuteBuffer        = NULL; <br> <br>/* <br> * Direct3D handles <br> */ <br>static D3DMATRIXHANDLE         hd3dWorldMatrix           = 0UL; <br>static D3DMATRIXHANDLE         hd3dViewMatrix            = 0UL; <br>static D3DMATRIXHANDLE         hd3dProjMatrix            = 0UL; <br>static D3DMATERIALHANDLE       hd3dSurfaceMaterial       = 0UL; <br>static D3DMATERIALHANDLE       hd3dBackgroundMaterial    = 0UL; <br> <br>/* <br> * Globals used for selecting the Direct3D device. They are <br> * globals as it makes it easy for the enumeration callback <br> * to read and write from them. <br> */ <br>static BOOL                    fDeviceFound              = FALSE; <br>static DWORD                   dwDeviceBitDepth          = 0UL; <br>static GUID                    guidDevice; <br>static char                    szDeviceName[MAX_DEVICE_NAME]; <br>static char                    szDeviceDesc[MAX_DEVICE_DESC]; <br>static D3DDEVICEDESC           d3dHWDeviceDesc; <br>static D3DDEVICEDESC           d3dSWDeviceDesc; <br> <br>/* <br> * The screen coordinates of the client area of the window. This <br> * rectangle defines the destination into which we blit to update <br> * the client area of the window with the results of the 3D rendering. <br> */ <br>static RECT                    rDstRect; <br> <br>/* <br> * This rectangle defines the portion of the rendering target surface <br> * into which we render. The top left coordinates of this rectangle <br> * are always zero and the right and bottom give the size of the <br> * viewport. <br> */ <br>static RECT                    rSrcRect; <br> <br>/* <br> * Angle of rotation of the world matrix. <br> */ <br>static double                  dAngleOfRotation          = 0.0; <br> <br>/* <br> * Predefined transformations. <br> */ <br>static D3DMATRIX d3dWorldMatrix = <br>{ <br>    D3DVAL( 1.0), D3DVAL( 0.0), D3DVAL( 0.0), D3DVAL( 0.0), <br>    D3DVAL( 0.0), D3DVAL( 1.0), D3DVAL( 0.0), D3DVAL( 0.0), <br>    D3DVAL( 0.0), D3DVAL( 0.0), D3DVAL( 1.0), D3DVAL( 0.0), <br>    D3DVAL( 0.0), D3DVAL( 0.0), D3DVAL( 0.0), D3DVAL( 1.0) <br>}; <br> <br>static D3DMATRIX d3dViewMatrix = <br>{ <br>    D3DVAL( 1.0), D3DVAL( 0.0), D3DVAL( 0.0), D3DVAL( 0.0), <br>    D3DVAL( 0.0), D3DVAL( 1.0), D3DVAL( 0.0), D3DVAL( 0.0), <br>    D3DVAL( 0.0), D3DVAL( 0.0), D3DVAL( 1.0), D3DVAL( 0.0), <br>    D3DVAL( 0.0), D3DVAL( 0.0), D3DVAL( 5.0), D3DVAL( 1.0) <br>}; <br> <br>static D3DMATRIX d3dProjMatrix = <br>{ <br>    D3DVAL( 2.0), D3DVAL( 0.0), D3DVAL( 0.0), D3DVAL( 0.0), <br>    D3DVAL( 0.0), D3DVAL( 2.0), D3DVAL( 0.0), D3DVAL( 0.0), <br>    D3DVAL( 0.0), D3DVAL( 0.0), D3DVAL( 1.0), D3DVAL( 1.0), <br>    D3DVAL( 0.0), D3DVAL( 0.0), D3DVAL(-1.0), D3DVAL( 0.0) <br>}; <br> <br>/*********************************************************************** <br> * <br> * Function prototypes <br> * <br> ***********************************************************************/ <br> <br>static void           ReportError(HWND hwnd, int nMessage, HRESULT hRes); <br>static void           FatalError(HWND hwnd, int nMessage, HRESULT hRes); <br> <br>static DWORD          BitDepthToFlags(DWORD dwBitDepth); <br>static DWORD          FlagsToBitDepth(DWORD dwFlags); <br> <br>static void           SetPerspectiveProjection(LPD3DMATRIX lpd3dMatrix, <br>                                               double      dHalfHeight, <br>                                               double      dFrontClipping, <br>                                               double      dBackClipping); <br>static void           SetRotationAboutY(LPD3DMATRIX lpd3dMatrix, <br>                                        double      dAngleOfRotation); <br> <br>static HRESULT        CreateDirect3D(HWND hwnd); <br>static HRESULT        ReleaseDirect3D(void); <br> <br>static HRESULT        CreatePrimary(HWND hwnd); <br>static HRESULT        RestorePrimary(void); <br>static HRESULT        ReleasePrimary(void); <br> <br>static HRESULT WINAPI EnumDeviceCallback(LPGUID          lpGUID,  <br>                                         LPSTR           lpszDeviceDesc, <br>                                         LPSTR           lpszDeviceName, <br>                                         LPD3DDEVICEDESC lpd3dHWDeviceDesc, <br>                                         LPD3DDEVICEDESC lpd3dSWDeviceDesc, <br>                                         LPVOID          lpUserArg); <br>static HRESULT        ChooseDevice(void); <br> <br>static HRESULT        CreateDevice(DWORD dwWidth, DWORD dwHeight); <br>static HRESULT        RestoreDevice(void); <br>static HRESULT        ReleaseDevice(void); <br> <br>static LRESULT        RestoreSurfaces(void); <br> <br>static HRESULT        FillExecuteBuffer(void); <br>static HRESULT        CreateScene(void); <br>static HRESULT        ReleaseScene(void); <br>static HRESULT        AnimateScene(void); <br> <br>static HRESULT        UpdateViewport(void); <br> <br>static HRESULT        RenderScene(void); <br>static HRESULT        DoFrame(HWND hwnd); <br>static void           PaintSuspended(HWND hwnd, HDC hdc); <br> <br>static LRESULT        OnMove(HWND hwnd, int x, int y); <br>static LRESULT        OnSize(HWND hwnd, int w, int h); <br>static LRESULT        OnPaint(HWND hwnd, HDC hdc, LPPAINTSTRUCT lpps); <br>static LRESULT        OnIdle(HWND hwnd); <br> <br>LRESULT CALLBACK      WndProc(HWND hwnd, UINT msg, <br>                              WPARAM wParam, LPARAM lParam); <br>int PASCAL            WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, <br>                              LPSTR lpszCommandLine, int cmdShow); <br> <br>/*********************************************************************** <br> * <br> * Macro functions <br> * <br> ***********************************************************************/ <br> <br>/***********************************************************************/ <br> <br>#ifdef _DEBUG <br>#define ASSERT(x)       assert(x) <br>#else <br>#define ASSERT(x) <br>#endif <br> <br>/***********************************************************************/ <br> <br>/* <br> * Used to keep the compiler happy about any unused parameters. <br> */ <br>#define USE_PARAM(x)    (x) = (x) <br> <br>/***********************************************************************/ <br> <br>/*********************************************************************** <br> * <br> * Functions <br> * <br> ***********************************************************************/ <br> <br>/***********************************************************************/ <br> <br>/* <br> * Report the given error by display a message box. <br> */ <br>static void <br>ReportError(HWND hwnd, int nMessage, HRESULT hRes) <br>{ <br>    HDC  hdc; <br>    char szBuffer[256]; <br>    char szMessage[128]; <br>    char szError[128]; <br>    int  nStrID; <br> <br>    /* <br>     * Turn the animation loop off. <br>     */ <br>    fSuspended = TRUE; <br> <br>    /* <br>     * Get the high level error message. <br>     */ <br>    LoadString(hAppInstance, nMessage, szMessage, sizeof(szMessage)); <br> <br>    /* <br>     * We issue sensible error messages for common run time errors. For <br>     * errors which are internal or coding errors we simply issue an <br>     * error number (they should never occur). <br>     */ <br>    switch (hRes) <br>    { <br>        case DDERR_EXCEPTION:        nStrID = IDS_ERR_EXCEPTION;        break; <br>        case DDERR_GENERIC:          nStrID = IDS_ERR_GENERIC;          break; <br>        case DDERR_OUTOFMEMORY:      nStrID = IDS_ERR_OUTOFMEMORY;      break; <br>        case DDERR_OUTOFVIDEOMEMORY: nStrID = IDS_ERR_OUTOFVIDEOMEMORY; break; <br>        case DDERR_SURFACEBUSY:      nStrID = IDS_ERR_SURFACEBUSY;      break; <br>        case DDERR_SURFACELOST:      nStrID = IDS_ERR_SURFACELOST;      break; <br>        case DDERR_WRONGMODE:        nStrID = IDS_ERR_WRONGMODE;        break; <br>        default:                     nStrID = IDS_ERR_INTERNALERROR;    break; <br>    } <br>    LoadString(hAppInstance, nStrID, szError, sizeof(szError)); <br> <br>    /* <br>     * Show the "paused" display. <br>     */ <br>    hdc = GetDC(hwnd); <br>    PaintSuspended(hwnd, hdc); <br>    ReleaseDC(hwnd, hdc); <br> <br>    /* <br>     * Convert the error code into a string (not very informative but <br>     * it keeps the code simple). <br>     */ <br>    wsprintf(szBuffer, "%s\n%s (Error #%d)", szMessage, szError, CODEFROMHRESULT(hRes)); <br>    MessageBox(hwnd, szBuffer, WINDOW_TITLE, MB_OK | MB_APPLMODAL); <br>    fSuspended = FALSE; <br>} <br> <br>/***********************************************************************/ <br> <br>/* <br> * Handle a fatal error. Displays the error message via a message box <br> * and then destroys the window. <br> */ <br>static void <br>FatalError(HWND hwnd, int nMessage, HRESULT hRes) <br>{ <br>    /* <br>     * Report the error. <br>     */ <br>    ReportError(hwnd, nMessage, hRes); <br>    fSuspended = TRUE; <br> <br>    /* <br>     * And shut down. <br>     * <br>     * NOTE: We don't attempt to clean up. That will be done <br>     * when WM_DESTROY happens. <br>     */ <br>    DestroyWindow(hwnd); <br>} <br> <br>/***********************************************************************/ <br> <br>/* <br> * Converts a bit depth into the appropriate DirectDraw bit depth flag. <br> */ <br>static DWORD <br>BitDepthToFlags(DWORD dwBitDepth) <br>{ <br>    switch (dwBitDepth) <br>    { <br>        case  1UL: return DDBD_1; <br>        case  2UL: return DDBD_2; <br>        case  4UL: return DDBD_4; <br>        case  8UL: return DDBD_8; <br>        case 16UL: return DDBD_16; <br>        case 24UL: return DDBD_24; <br>        case 32UL: return DDBD_32; <br>        default:   return 0UL;     /* Oh, please... */ <br>    } <br>} <br> <br>/***********************************************************************/ <br> <br>/* <br> * Convert bit depth flags to an acutal bit count. Selects the smallest <br> * bit count in the mask if more than one flag is present. <br> */ <br>static DWORD <br>FlagsToBitDepth(DWORD dwFlags) <br>{ <br>    if (dwFlags &amp; DDBD_1) <br>        return 1UL; <br>    else if (dwFlags &amp; DDBD_2) <br>        return 2UL; <br>    else if (dwFlags &amp; DDBD_4) <br>        return 4UL; <br>    else if (dwFlags &amp; DDBD_8) <br>        return 8UL; <br>    else if (dwFlags &amp; DDBD_16) <br>        return 16UL; <br>    else if (dwFlags &amp; DDBD_24) <br>        return 24UL; <br>    else if (dwFlags &amp; DDBD_32) <br>        return 32UL; <br>    else <br>        return 0UL; /* Oh, please... */ <br>} <br> <br>/***********************************************************************/ <br> <br>/* <br> * Set the given matrix to a perspective transform for the given half <br> * height and front and back clipping planes. <br> */ <br>static void <br>SetPerspectiveProjection(LPD3DMATRIX lpd3dMatrix, <br>                         double      dHalfHeight, <br>                         double      dFrontClipping, <br>                         double      dBackClipping) <br>{ <br>    double dTmp1; <br>    double dTmp2; <br> <br>    ASSERT(NULL != lpd3dMatrix); <br> <br>    dTmp1 = dHalfHeight / dFrontClipping; <br>    dTmp2 = dBackClipping / (dBackClipping - dFrontClipping); <br> <br>    lpd3dMatrix-&gt;_11 =  D3DVAL(2.0); <br>    lpd3dMatrix-&gt;_12 =  D3DVAL(0.0); <br>    lpd3dMatrix-&gt;_13 =  D3DVAL(0.0); <br>    lpd3dMatrix-&gt;_14 =  D3DVAL(0.0); <br>    lpd3dMatrix-&gt;_21 =  D3DVAL(0.0); <br>    lpd3dMatrix-&gt;_22 =  D3DVAL(2.0); <br>    lpd3dMatrix-&gt;_23 =  D3DVAL(0.0); <br>    lpd3dMatrix-&gt;_24 =  D3DVAL(0.0); <br>    lpd3dMatrix-&gt;_31 =  D3DVAL(0.0); <br>    lpd3dMatrix-&gt;_32 =  D3DVAL(0.0); <br>    lpd3dMatrix-&gt;_33 =  D3DVAL(dTmp1 * dTmp2); <br>    lpd3dMatrix-&gt;_34 =  D3DVAL(dTmp1); <br>    lpd3dMatrix-&gt;_41 =  D3DVAL(0.0); <br>    lpd3dMatrix-&gt;_42 =  D3DVAL(0.0); <br>    lpd3dMatrix-&gt;_43 =  D3DVAL(-dHalfHeight * dTmp2); <br>    lpd3dMatrix-&gt;_44 =  D3DVAL(0.0); <br>} <br> <br> <br>/***********************************************************************/ <br> <br>/* <br> * Set the given matrix to a rotation about Y transform of the given <br> * number of radians. <br> */ <br>static void <br>SetRotationAboutY(LPD3DMATRIX lpd3dMatrix, double dAngleOfRotation) <br>{ <br>    D3DVALUE dvCos; <br>    D3DVALUE dvSin; <br> <br>    ASSERT(NULL != lpd3dMatrix); <br> <br>    dvCos = D3DVAL(cos(dAngleOfRotation)); <br>    dvSin = D3DVAL(sin(dAngleOfRotation)); <br> <br>    lpd3dMatrix-&gt;_11 =  dvCos; <br>    lpd3dMatrix-&gt;_12 =  D3DVAL(0.0); <br>    lpd3dMatrix-&gt;_13 = -dvSin; <br>    lpd3dMatrix-&gt;_14 =  D3DVAL(0.0); <br>    lpd3dMatrix-&gt;_21 =  D3DVAL(0.0); <br>    lpd3dMatrix-&gt;_22 =  D3DVAL(1.0); <br>    lpd3dMatrix-&gt;_23 =  D3DVAL(0.0); <br>    lpd3dMatrix-&gt;_24 =  D3DVAL(0.0); <br>    lpd3dMatrix-&gt;_31 =  dvSin; <br>    lpd3dMatrix-&gt;_32 =  D3DVAL(0.0); <br>    lpd3dMatrix-&gt;_33 =  dvCos; <br>    lpd3dMatrix-&gt;_34 =  D3DVAL(0.0); <br>    lpd3dMatrix-&gt;_41 =  D3DVAL(0.0); <br>    lpd3dMatrix-&gt;_42 =  D3DVAL(0.0); <br>    lpd3dMatrix-&gt;_43 =  D3DVAL(0.0); <br>    lpd3dMatrix-&gt;_44 =  D3DVAL(1.0); <br>} <br> <br>/***********************************************************************/ <br> <br>/* <br> * Create the DirectDraw/3D driver object and get DirectDraw and Direct3D <br> * interfaces for communicating with that object. <br> */ <br>static HRESULT <br>CreateDirect3D(HWND hwnd) <br>{ <br>    HRESULT hRes; <br> <br>    ASSERT(NULL == lpdd); <br>    ASSERT(NULL == lpd3d); <br> <br>    /* <br>     * Create the DirectDraw/3D driver object and get the DirectDraw <br>     * interface to that object. <br>     */ <br>    hRes = DirectDrawCreate(NULL, &amp;lpdd, NULL); <br>    if (FAILED(hRes)) <br>        return hRes; <br> <br>    /* <br>     * As we are running in a window set the cooperative level to  <br>     * normal. Also, to ensure that the palette is realized correctly <br>     * we need to pass the hwnd of the main window. <br>     */ <br>    hRes = lpdd-&gt;lpVtbl-&gt;SetCooperativeLevel(lpdd, hwnd, DDSCL_NORMAL); <br>    if (FAILED(hRes)) <br>        return hRes; <br> <br>    /* <br>     * Get the Direct3D interface to the DirectDraw/3D driver object. <br>     */ <br>    hRes = lpdd-&gt;lpVtbl-&gt;QueryInterface(lpdd, &amp;IID_IDirect3D, &amp;lpd3d); <br>    if (FAILED(hRes)) <br>        return hRes; <br> <br>    return DD_OK; <br>} <br> <br>/***********************************************************************/ <br> <br>/* <br> * Release the DirectDraw/3D driver object. <br> */ <br>static HRESULT <br>ReleaseDirect3D(void) <br>{ <br>    if (NULL != lpd3d) <br>    { <br>        lpd3d-&gt;lpVtbl-&gt;Release(lpd3d); <br>        lpd3d = NULL; <br>    } <br>    if (NULL != lpdd) <br>    { <br>        lpdd-&gt;lpVtbl-&gt;Release(lpdd); <br>        lpdd = NULL; <br>    } <br> <br>    return DD_OK; <br>} <br> <br>/***********************************************************************/ <br> <br>/* <br> * Create the primary surface (representing the desktop) and create and <br> * attach a clipper and, if necessary, a palette. <br> */ <br>static HRESULT <br>CreatePrimary(HWND hwnd) <br>{ <br>    HRESULT             hRes; <br>    DDSURFACEDESC       ddsd; <br>    LPDIRECTDRAWCLIPPER lpddClipper; <br>    HDC                 hdc; <br>    int                 i; <br>    PALETTEENTRY        peColorTable[256]; <br> <br>    ASSERT(NULL != hwnd); <br>    ASSERT(NULL != lpdd); <br>    ASSERT(NULL == lpddPrimary); <br>    ASSERT(NULL == lpddPalette); <br> <br>    /* <br>     * Create the primary surface. <br>     */ <br>    ZeroMemory(&amp;ddsd, sizeof(ddsd)); <br>    ddsd.dwSize         = sizeof(ddsd); <br>    ddsd.dwFlags        = DDSD_CAPS; <br>    ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE; <br>    hRes = lpdd-&gt;lpVtbl-&gt;CreateSurface(lpdd, &amp;ddsd, &amp;lpddPrimary, NULL); <br>    if (FAILED(hRes)) <br>        return hRes; <br> <br>    /* <br>     * Create the clipper. We bind the application's window to the <br>     * clipper and attach it to the primary. This ensures then when we <br>     * blit from the rendering surface to the primary we don't write <br>     * outside the visible region of the window. <br>     */ <br>    hRes = DirectDrawCreateClipper(0UL, &amp;lpddClipper, NULL); <br>    if (FAILED(hRes)) <br>        return hRes; <br>    hRes = lpddClipper-&gt;lpVtbl-&gt;SetHWnd(lpddClipper, 0UL, hwnd); <br>    if (FAILED(hRes)) <br>    { <br>        lpddClipper-&gt;lpVtbl-&gt;Release(lpddClipper); <br>        return hRes; <br>    } <br>    hRes = lpddPrimary-&gt;lpVtbl-&gt;SetClipper(lpddPrimary, lpddClipper); <br>    if (FAILED(hRes)) <br>    { <br>        lpddClipper-&gt;lpVtbl-&gt;Release(lpddClipper); <br>        return hRes; <br>    } <br> <br>    /* <br>     * We release the clipper interface after attaching it to the surface <br>     * as we don't need to use it again. The surface holds a reference to <br>     * the clipper when its been attached. The clipper will therefore be <br>     * released when the surface is released. <br>     */ <br>    lpddClipper-&gt;lpVtbl-&gt;Release(lpddClipper); <br> <br>    /* <br>     * If the primary is palettized then so will the device (the device <br>     * surface must have the same pixel format as the current primary if <br>     * we want to double buffer with DirectDraw). Hence, if the primary <br>     * is palettized we need to create a palette and attach it to the <br>     * primary (and to the device surface when we create it). <br>     */ <br>    ZeroMemory(&amp;ddsd, sizeof(ddsd)); <br>    ddsd.dwSize = sizeof(ddsd); <br>    hRes = lpddPrimary-&gt;lpVtbl-&gt;GetSurfaceDesc(lpddPrimary, &amp;ddsd); <br>    if (FAILED(hRes)) <br>        return hRes; <br>    if (ddsd.ddpfPixelFormat.dwFlags &amp; DDPF_PALETTEINDEXED8) <br>    { <br>        /* <br>         * Initializing the palette correctly is essential. We are <br>         * running in a window so we need to be a good windows app <br>         * and not mess with the top ten and bottom ten static <br>         * colors. Therefore, we copy them from the system palette <br>         * and mark them as read only (D3DPAL_READONLY). The middle <br>         * 236 entries are free for use by Direct3D so we mark them <br>         * free (D3DPAL_FREE). <br>         * <br>         * NOTE: In order that the palette entries are correctly <br>         * allocated it is essential that the free entries are <br>         * also marked reserved to GDI (PC_RESERVED). <br>         * <br>         * NOTE: We don't need to specify the palette caps flag <br>         * DDPCAPS_INITIALIZE. This flag is obsolete. CreatePalette <br>         * must be given a valid palette entry array and always <br>         * initializes from it. <br>         */ <br>        hdc = GetDC(NULL); <br>        GetSystemPaletteEntries(hdc, 0, 256, peColorTable); <br>        ReleaseDC(NULL, hdc); <br> <br>        for (i = 0; i &lt; 10; i++) <br>            peColorTable[i].peFlags = D3DPAL_READONLY; <br>        for (i = 10; i &lt; 246; i++) <br>            peColorTable[i].peFlags = D3DPAL_FREE | PC_RESERVED; <br>        for (i = 246; i &lt; 256; i++) <br>            peColorTable[i].peFlags = D3DPAL_READONLY; <br>        hRes = lpdd-&gt;lpVtbl-&gt;CreatePalette(lpdd, <br>                                           DDPCAPS_8BIT, <br>                                           peColorTable, <br>                                           &amp;lpddPalette, <br>                                           NULL); <br>        if (FAILED(hRes)) <br>            return hRes; <br> <br>        hRes = lpddPrimary-&gt;lpVtbl-&gt;SetPalette(lpddPrimary, lpddPalette); <br>            return hRes; <br>    } <br> <br>    return DD_OK; <br>} <br> <br>/***********************************************************************/ <br> <br>/* <br> * Attempt to restore the video memory allocated for the primary. This <br> * function will be invoked by a DirectX function returning <br> * DDERR_SURFACELOST due to a mode switch or fullscreen DOS box <br> * invalidating video memory. <br> */ <br>static HRESULT <br>RestorePrimary(void) <br>{ <br>    ASSERT(NULL != lpddPrimary); <br> <br>    return lpddPrimary-&gt;lpVtbl-&gt;Restore(lpddPrimary); <br>} <br> <br>/***********************************************************************/ <br> <br>/* <br> * Release the primary surface and its attached clipper and palette. <br> */ <br>static HRESULT <br>ReleasePrimary(void) <br>{ <br>    if (NULL != lpddPalette) <br>    { <br>        lpddPalette-&gt;lpVtbl-&gt;Release(lpddPalette); <br>        lpddPalette = NULL; <br>    } <br>    if (NULL != lpddPrimary) <br>    { <br>        lpddPrimary-&gt;lpVtbl-&gt;Release(lpddPrimary); <br>        lpddPrimary = NULL; <br>    } <br> <br>    return DD_OK; <br>} <br> <br>/***********************************************************************/ <br> <br>/* <br> * This callback is invoked for each Direct3D device installed on the <br> * system. For each device we get its identifying GUID, a name and <br> * description, a description of its hardware and software capabilities <br> * and a user argument (which we don't use). <br> */ <br>static HRESULT WINAPI <br>EnumDeviceCallback(LPGUID          lpGUID,  <br>                   LPSTR           lpszDeviceDesc, <br>                   LPSTR           lpszDeviceName, <br>                   LPD3DDEVICEDESC lpd3dHWDeviceDesc, <br>                   LPD3DDEVICEDESC lpd3dSWDeviceDesc, <br>                   LPVOID          lpUserArg) <br>{ <br>    BOOL            fIsHardware; <br>    LPD3DDEVICEDESC lpd3dDeviceDesc; <br> <br>    /* <br>     * We don't use the user argument so just keep the compiler happy. <br>     */ <br>    USE_PARAM(lpUserArg); <br> <br>    /* <br>     * If there is no hardware support then the color model is zero. <br>     */ <br>    fIsHardware     = (0UL != lpd3dHWDeviceDesc-&gt;dcmColorModel); <br>    lpd3dDeviceDesc = (fIsHardware ? lpd3dHWDeviceDesc : lpd3dSWDeviceDesc); <br> <br>    /* <br>     * If we are in debug mode and this is a hardware device skip it. <br>     */ <br>    if (fDebug &amp;&amp; fIsHardware) <br>        return D3DENUMRET_OK; <br> <br>    /* <br>     * Does the device render at the depth we want? <br>     */ <br>    if (0UL == (lpd3dDeviceDesc-&gt;dwDeviceRenderBitDepth &amp; dwDeviceBitDepth)) <br>    { <br>        /* <br>         * No skip this device. <br>         */ <br>        return D3DENUMRET_OK; <br>    } <br> <br>    /* <br>     * The device must support gouraud shaded triangles. <br>     */ <br>    if (D3DCOLOR_MONO == lpd3dDeviceDesc-&gt;dcmColorModel) <br>    { <br>        if (!(lpd3dDeviceDesc-&gt;dpcTriCaps.dwShadeCaps &amp; D3DPSHADECAPS_COLORGOURAUDMONO)) <br>        { <br>            /* <br>             * No gouraud shading. Skip this device. <br>             */ <br>            return D3DENUMRET_OK; <br>        } <br>    } <br>    else <br>    { <br>        if (!(lpd3dDeviceDesc-&gt;dpcTriCaps.dwShadeCaps &amp; D3DPSHADECAPS_COLORGOURAUDRGB)) <br>        { <br>            /* <br>             * No gouraud shading. Skip this device. <br>             */ <br>            return D3DENUMRET_OK; <br>        } <br>    } <br> <br>    if (!fIsHardware &amp;&amp; fDeviceFound &amp;&amp; (D3DCOLOR_RGB == lpd3dDeviceDesc-&gt;dcmColorModel)) <br>    { <br>        /* <br>         * If this is software RGB and we already have found a software <br>         * mono already then we are not interested. Skip it. <br>         */ <br>        return D3DENUMRET_OK; <br>    } <br> <br>    /* <br>     * This is a device we are interested in - cache the details away. <br>     */ <br>    fDeviceFound = TRUE; <br>    CopyMemory(&amp;guidDevice, lpGUID, sizeof(GUID)); <br>    strcpy(szDeviceDesc, lpszDeviceDesc); <br>    strcpy(szDeviceName, lpszDeviceName); <br>    CopyMemory(&amp;d3dHWDeviceDesc, lpd3dHWDeviceDesc, sizeof(D3DDEVICEDESC)); <br>    CopyMemory(&amp;d3dSWDeviceDesc, lpd3dSWDeviceDesc, sizeof(D3DDEVICEDESC)); <br> <br>    /* <br>     * If this is a hardware device we have found what we are looking <br>     * for. <br>     */ <br>    if (fIsHardware) <br>        return D3DENUMRET_CANCEL; <br> <br>    /* <br>     * Keep looking... <br>     */ <br>    return D3DENUMRET_OK; <br>} <br>                             <br>/***********************************************************************/ <br> <br>/* <br> * Choose an appropriate Direct3D using the following mechanism: <br> * <br> * 1) Discard any devices which don't match the current display depth. <br> * 2) Discard any devices which can't do gouraud shaded triangles. <br> * 3) If a hardware device is found which matches 1) and 2) use it. <br> *    However, if we are running in debug mode we will skip hardware. <br> * 4) Otherwise favour Mono/Ramp mode software renderers over RGB ones <br> *    as, at least until MMX is widespread, Mono will be faster. <br> * <br> * The actual implementation of this mechanism is in the callback <br> * function above. <br> */ <br>static HRESULT <br>ChooseDevice(void) <br>{ <br>    DDSURFACEDESC ddsd; <br>    HRESULT       hRes; <br> <br>    ASSERT(NULL != lpd3d); <br>    ASSERT(NULL != lpddPrimary); <br> <br>    /* <br>     * As we are running in a window we will not be changing the screen <br>     * depth and hence the pixel format of the rendering target must match <br>     * the pixel format of the current primary. Therefore, we need to <br>     * determine the pixel format of the primary. <br>     */ <br>    ZeroMemory(&amp;ddsd, sizeof(ddsd)); <br>    ddsd.dwSize = sizeof(ddsd); <br>    hRes = lpddPrimary-&gt;lpVtbl-&gt;GetSurfaceDesc(lpddPrimary, &amp;ddsd); <br>    if (FAILED(hRes)) <br>        return hRes; <br> <br>    dwDeviceBitDepth = BitDepthToFlags(ddsd.ddpfPixelFormat.dwRGBBitCount); <br> <br>    /* <br>     * Enumerate the devices and pick one. <br>     */ <br>    fDeviceFound = FALSE; <br>    hRes = lpd3d-&gt;lpVtbl-&gt;EnumDevices(lpd3d, EnumDeviceCallback, &amp;fDeviceFound); <br>    if (FAILED(hRes)) <br>        return hRes; <br> <br>    if (!fDeviceFound) <br>    { <br>        /* <br>         * No suitable device was found. We have no alternative but to <br>         * fail creation entirely. <br>         */ <br>        return DDERR_NOTFOUND; <br>    } <br> <br>    return DD_OK; <br>} <br> <br>/***********************************************************************/ <br> <br>/* <br> * Create an instance of the Direct3D device we choose earlier with the <br> * given width and height. <br> * <br> * This function handles all aspects of the device creation including <br> * choosing surface memory type, create the device surface, the z-buffer <br> * (if necessary) and attaching the palette (if required). <br> */ <br>static HRESULT <br>CreateDevice(DWORD dwWidth, DWORD dwHeight) <br>{ <br>    LPD3DDEVICEDESC lpd3dDeviceDesc; <br>    DWORD           dwDeviceMemType; <br>    DWORD           dwZBufferMemType; <br>    DDSURFACEDESC   ddsd; <br>    HRESULT         hRes; <br>    DWORD           dwZBufferBitDepth; <br> <br>    ASSERT(NULL != lpdd); <br>    ASSERT(NULL != lpd3d); <br>    ASSERT(NULL != lpddPrimary); <br>    ASSERT(NULL == lpddDevice); </code></pre>
<p>
</p>
<pre><code>ASSERT(NULL == lpd3dDevice); <br> <br>    /* <br>     * The first step is to determine the kind of memory (system or <br>     * video) from which the device surface should be allocated. <br>     */ <br>    if (0UL != d3dHWDeviceDesc.dcmColorModel) <br>    { <br>        lpd3dDeviceDesc = &amp;d3dHWDeviceDesc; <br> <br>        /* <br>         * Device has a hardware rasterizer. Currently this means that <br>         * the device surface must be in video memory. <br>         */ <br>        dwDeviceMemType  = DDSCAPS_VIDEOMEMORY; <br>        dwZBufferMemType = DDSCAPS_VIDEOMEMORY; <br>    } <br>    else <br>    { <br>        lpd3dDeviceDesc = &amp;d3dSWDeviceDesc; <br> <br>        /* <br>         * Device has a software rasterizer. We will let DirectDraw <br>         * decide where the device surface resides unless we are <br>         * running in debug mode in which case we will force it into <br>         * system memory. For a software rasterizer the z-buffer should <br>         * always go into system memory. A z-buffer in video memory will <br>         * kill performance. <br>         */ <br>        dwDeviceMemType  = (fDebug ? DDSCAPS_SYSTEMMEMORY : 0UL); <br>        dwZBufferMemType = DDSCAPS_SYSTEMMEMORY; <br>    } <br> <br>    /* <br>     * Create the device surface. The pixel format will be identical <br>     * to the primary so we don't have to explicitly specify it. We do <br>     * need to explicity specify the size, memory type and capabilities <br>     * of the surface. <br>     */ <br>    ZeroMemory(&amp;ddsd, sizeof(ddsd)); <br>    ddsd.dwSize         = sizeof(ddsd); <br>    ddsd.dwFlags        = DDSD_CAPS | DDSD_WIDTH | DDSD_HEIGHT; <br>    ddsd.dwWidth        = dwWidth; <br>    ddsd.dwHeight       = dwHeight; <br>    ddsd.ddsCaps.dwCaps = DDSCAPS_3DDEVICE | DDSCAPS_OFFSCREENPLAIN | dwDeviceMemType; <br>    hRes = lpdd-&gt;lpVtbl-&gt;CreateSurface(lpdd, &amp;ddsd, &amp;lpddDevice, NULL); <br>    if (FAILED(hRes)) <br>        return hRes; <br> <br>    /* <br>     * If we have created a palette then we have already determined that <br>     * the primary (and hence the device surface) is palettized so  <br>     * attach the palette to the device surface (its already attached to <br>     * the primary). <br>     */ <br>    if (NULL != lpddPalette) <br>    { <br>        hRes = lpddDevice-&gt;lpVtbl-&gt;SetPalette(lpddDevice, lpddPalette); <br>        if (FAILED(hRes)) <br>            return hRes; <br>    } <br> <br>    /* <br>     * We now determine whether we need a z-buffer or not and if so <br>     * its bit depth.  <br>     */ <br>    if (0UL != lpd3dDeviceDesc-&gt;dwDeviceZBufferBitDepth) <br>    { <br>        /* <br>         * The device supports z-buffering. Determine the depth. We <br>         * select the lowest supported z-buffer depth to save memory. <br>         * Accuracy is not too important for this sample. <br>         */ <br>        dwZBufferBitDepth = FlagsToBitDepth(lpd3dDeviceDesc-&gt;dwDeviceZBufferBitDepth); <br> <br>        /* <br>         * Create the z-buffer. <br>         */ <br>        ZeroMemory(&amp;ddsd, sizeof(ddsd)); <br>        ddsd.dwSize            = sizeof(ddsd); <br>        ddsd.dwFlags           = DDSD_CAPS   | <br>                                 DDSD_WIDTH  | <br>                                 DDSD_HEIGHT | <br>                                 DDSD_ZBUFFERBITDEPTH; <br>        ddsd.ddsCaps.dwCaps    = DDSCAPS_ZBUFFER | dwZBufferMemType; <br>        ddsd.dwWidth           = dwWidth; <br>        ddsd.dwHeight          = dwHeight; <br>        ddsd.dwZBufferBitDepth = dwZBufferBitDepth; <br>        hRes = lpdd-&gt;lpVtbl-&gt;CreateSurface(lpdd, &amp;ddsd, &amp;lpddZBuffer, NULL); <br>        if (FAILED(hRes)) <br>            return hRes; <br> <br>        /* <br>         * Attach it to the rendering target. <br>         */ <br>        hRes = lpddDevice-&gt;lpVtbl-&gt;AddAttachedSurface(lpddDevice, lpddZBuffer); <br>        if (FAILED(hRes)) <br>            return hRes; <br>    } <br> <br>    /* <br>     * Now all the elements are in place (device surface in correct <br>     * memory type, attached z-buffer of correct depth and memory <br>     * type, and palette if necessary) we can actually query for the <br>     * Direct3D we choose earlier. <br>     */ <br>    hRes = lpddDevice-&gt;lpVtbl-&gt;QueryInterface(lpddDevice, <br>                                              &amp;guidDevice, <br>                                              &amp;lpd3dDevice); <br>    if (FAILED(hRes)) <br>        return hRes; <br> <br>    return DD_OK; <br>} <br> <br>/***********************************************************************/ <br> <br>/* <br> * Restore the video memory for the device surface and z-buffer if it <br> * has been lost. <br> */ <br>static HRESULT <br>RestoreDevice(void) <br>{ <br>    HRESULT hRes; <br> <br>    if (NULL != lpddZBuffer) <br>    { <br>        hRes = lpddZBuffer-&gt;lpVtbl-&gt;Restore(lpddZBuffer); <br>        if (FAILED(hRes)) <br>            return hRes; <br>    } <br> <br>    if (NULL != lpddDevice) <br>    { <br>        hRes = lpddDevice-&gt;lpVtbl-&gt;Restore(lpddDevice); <br>        if (FAILED(hRes)) <br>            return hRes; <br>    } <br> <br>    return DD_OK; <br>} <br> <br>/***********************************************************************/ <br> <br>/* <br> * Release the Direct3D device and its associated surfaces. <br> */ <br>static HRESULT <br>ReleaseDevice(void) <br>{ <br>    if (NULL != lpd3dDevice) <br>    { <br>        lpd3dDevice-&gt;lpVtbl-&gt;Release(lpd3dDevice); <br>        lpd3dDevice = NULL; <br>    } <br>    if (NULL != lpddZBuffer) <br>    { <br>        lpddZBuffer-&gt;lpVtbl-&gt;Release(lpddZBuffer); <br>        lpddZBuffer = NULL; <br>    } <br>    if (NULL != lpddDevice) <br>    { <br>        lpddDevice-&gt;lpVtbl-&gt;Release(lpddDevice); <br>        lpddDevice = NULL; <br>    } <br> <br>    return DD_OK; <br>} <br> <br>/***********************************************************************/ <br> <br>/* <br> * Attempt to restore all the surfaces used by the application. <br> */ <br>static LRESULT <br>RestoreSurfaces(void) <br>{ <br>    HRESULT hRes; <br> <br>    hRes = RestorePrimary(); <br>    if (FAILED(hRes)) <br>        return hRes; <br> <br>    hRes = RestoreDevice(); <br>    if (FAILED(hRes)) <br>        return hRes; <br> <br>    return DD_OK; <br>} <br> <br>/***********************************************************************/ <br> <br>/* <br> * Fill the single execute buffer used in this sample with all the <br> * vertices, transform, light and render state and drawing primitives <br> * necessary to draw our triangle. <br> * <br> * NOTE: This is not the most efficient way of organizing the execute <br> * buffer. For best performance you want to minimize state changes. In <br> * this sample we submit the execute buffer for each frame in the <br> * animation loop and no state in the buffer is modified. The only  <br> * thing we modify is the world matrix (its contents - not its handle). <br> * Therefore, it would be more efficient to extract all the static <br> * state instructions into a separate execute buffer which we issue <br> * once only at startup and, from then on, simply execute a second <br> * execute buffer with vertices and triangles. <br> * However, this sample is not exactly performance critical so we will <br> * just use one execute buffer and resubmit it its entirety for each <br> * frame. <br> */ <br>static HRESULT <br>FillExecuteBuffer(void) <br>{ <br>    HRESULT              hRes; <br>    D3DEXECUTEBUFFERDESC d3dExeBufDesc; <br>    LPD3DVERTEX          lpVertex; <br>    LPD3DINSTRUCTION     lpInstruction; <br>    LPD3DPROCESSVERTICES lpProcessVertices; <br>    LPD3DTRIANGLE        lpTriangle; <br>    LPD3DSTATE           lpState; <br> <br>    ASSERT(NULL != lpd3dExecuteBuffer); <br>    ASSERT(0UL  != hd3dSurfaceMaterial); <br>    ASSERT(0UL  != hd3dWorldMatrix); <br>    ASSERT(0UL  != hd3dViewMatrix); <br>    ASSERT(0UL  != hd3dProjMatrix); <br> <br>    /* <br>     * Lock the execute buffer. <br>     */ <br>    ZeroMemory(&amp;d3dExeBufDesc, sizeof(d3dExeBufDesc)); <br>    d3dExeBufDesc.dwSize = sizeof(d3dExeBufDesc); <br>    hRes = lpd3dExecuteBuffer-&gt;lpVtbl-&gt;Lock(lpd3dExecuteBuffer, &amp;d3dExeBufDesc); <br>    if (FAILED(hRes)) <br>        return hRes; <br> <br>    /* <br>     * For explanatory purposes we fill the execute buffer by casting <br>     * a pointer to the execute buffer to the appropriate data structures. <br>     * <br>     * !!! NOTE: Issue - alignment. <br>     */ <br>    lpVertex = (LPD3DVERTEX)d3dExeBufDesc.lpData; <br> <br>    /* <br>     * First vertex. <br>     */ <br>    lpVertex-&gt;dvX  = D3DVAL( 0.0); /* Position in model coordinates       */ <br>    lpVertex-&gt;dvY  = D3DVAL( 1.0); <br>    lpVertex-&gt;dvZ  = D3DVAL( 0.0); <br>    lpVertex-&gt;dvNX = D3DVAL( 0.0); /* Normalized illumination normal      */ <br>    lpVertex-&gt;dvNY = D3DVAL( 0.0); <br>    lpVertex-&gt;dvNZ = D3DVAL(-1.0); <br>    lpVertex-&gt;dvTU = D3DVAL( 0.0); /* Texture coordinates (not used here) */ <br>    lpVertex-&gt;dvTV = D3DVAL( 1.0); <br>    lpVertex++; <br> <br>    /* <br>     * Second vertex. <br>     */ <br>    lpVertex-&gt;dvX  = D3DVAL( 1.0); /* Position in model coordinates       */ <br>    lpVertex-&gt;dvY  = D3DVAL(-1.0); <br>    lpVertex-&gt;dvZ  = D3DVAL( 0.0); <br>    lpVertex-&gt;dvNX = D3DVAL( 0.0); /* Normalized illumination normal      */ <br>    lpVertex-&gt;dvNY = D3DVAL( 0.0); <br>    lpVertex-&gt;dvNZ = D3DVAL(-1.0); <br>    lpVertex-&gt;dvTU = D3DVAL( 1.0); /* Texture coordinates (not used here) */ <br>    lpVertex-&gt;dvTV = D3DVAL( 1.0); <br>    lpVertex++; <br> <br>    /* <br>     * Third vertex. <br>     */ <br>    lpVertex-&gt;dvX  = D3DVAL(-1.0); /* Position in model coordinates       */ <br>    lpVertex-&gt;dvY  = D3DVAL(-1.0); <br>    lpVertex-&gt;dvZ  = D3DVAL( 0.0); <br>    lpVertex-&gt;dvNX = D3DVAL( 0.0); /* Normalized illumination normal      */ <br>    lpVertex-&gt;dvNY = D3DVAL( 0.0); <br>    lpVertex-&gt;dvNZ = D3DVAL(-1.0); <br>    lpVertex-&gt;dvTU = D3DVAL( 1.0); /* Texture coordinates (not used here) */ <br>    lpVertex-&gt;dvTV = D3DVAL( 0.0); <br>    lpVertex++; <br> <br>    /* <br>     * Transform state - world, view and projection. <br>     */ <br>    lpInstruction = (LPD3DINSTRUCTION)lpVertex; <br>    lpInstruction-&gt;bOpcode = D3DOP_STATETRANSFORM; <br>    lpInstruction-&gt;bSize   = sizeof(D3DSTATE); <br>    lpInstruction-&gt;wCount  = 3U; <br>    lpInstruction++; <br>    lpState = (LPD3DSTATE)lpInstruction; <br>    lpState-&gt;dtstTransformStateType = D3DTRANSFORMSTATE_WORLD; <br>    lpState-&gt;dwArg[0] = hd3dWorldMatrix; <br>    lpState++; <br>    lpState-&gt;dtstTransformStateType = D3DTRANSFORMSTATE_VIEW; <br>    lpState-&gt;dwArg[0] = hd3dViewMatrix; <br>    lpState++; <br>    lpState-&gt;dtstTransformStateType = D3DTRANSFORMSTATE_PROJECTION; <br>    lpState-&gt;dwArg[0] = hd3dProjMatrix; <br>    lpState++; <br> <br>    /* <br>     * Lighting state. <br>     */ <br>    lpInstruction = (LPD3DINSTRUCTION)lpState; <br>    lpInstruction-&gt;bOpcode = D3DOP_STATELIGHT; <br>    lpInstruction-&gt;bSize   = sizeof(D3DSTATE); <br>    lpInstruction-&gt;wCount  = 2U; <br>    lpInstruction++; <br>    lpState = (LPD3DSTATE)lpInstruction; <br>    lpState-&gt;dlstLightStateType = D3DLIGHTSTATE_MATERIAL; <br>    lpState-&gt;dwArg[0] = hd3dSurfaceMaterial; <br>    lpState++; <br>    lpState-&gt;dlstLightStateType = D3DLIGHTSTATE_AMBIENT; <br>    lpState-&gt;dwArg[0] = RGBA_MAKE(128, 128, 128, 128); <br>    lpState++; <br> <br>    /* <br>     * Render state. <br>     */ <br>    lpInstruction = (LPD3DINSTRUCTION)lpState; <br>    lpInstruction-&gt;bOpcode = D3DOP_STATERENDER; <br>    lpInstruction-&gt;bSize = sizeof(D3DSTATE); <br>    lpInstruction-&gt;wCount = 3U; <br>    lpInstruction++; <br>    lpState = (LPD3DSTATE)lpInstruction; <br>    lpState-&gt;drstRenderStateType = D3DRENDERSTATE_FILLMODE; <br>    lpState-&gt;dwArg[0] = D3DFILL_SOLID; <br>    lpState++; <br>    lpState-&gt;drstRenderStateType = D3DRENDERSTATE_SHADEMODE; <br>    lpState-&gt;dwArg[0] = D3DSHADE_GOURAUD; <br>    lpState++; <br>    lpState-&gt;drstRenderStateType = D3DRENDERSTATE_DITHERENABLE; <br>    lpState-&gt;dwArg[0] = TRUE; <br>    lpState++; <br> <br>    /* <br>     * The process vertices instruction tells the driver what to <br>     * do with the vertices in the buffer. In this sample we want <br>     * Direct3D to perform the entire pipeline on our behalf so <br>     * the instruction is D3DPROCESSVERTICES_TRANSFORMLIGHT. <br>     */ <br>    lpInstruction = (LPD3DINSTRUCTION)lpState; <br>    lpInstruction-&gt;bOpcode = D3DOP_PROCESSVERTICES; <br>    lpInstruction-&gt;bSize   = sizeof(D3DPROCESSVERTICES); <br>    lpInstruction-&gt;wCount  = 1U; <br>    lpInstruction++; <br>    lpProcessVertices = (LPD3DPROCESSVERTICES)lpInstruction; <br>    lpProcessVertices-&gt;dwFlags    = D3DPROCESSVERTICES_TRANSFORMLIGHT; <br>    lpProcessVertices-&gt;wStart     = 0U;           /* First source vertex */ <br>    lpProcessVertices-&gt;wDest      = 0U; <br>    lpProcessVertices-&gt;dwCount    = NUM_VERTICES; /* Number of vertices  */ <br>    lpProcessVertices-&gt;dwReserved = 0UL; <br>    lpProcessVertices++; <br> <br>    /* <br>     * Draw the triangle. <br>     */ <br>    lpInstruction = (LPD3DINSTRUCTION)lpProcessVertices; <br>    lpInstruction-&gt;bOpcode = D3DOP_TRIANGLE; <br>    lpInstruction-&gt;bSize   = sizeof(D3DTRIANGLE); <br>    lpInstruction-&gt;wCount  = 1U; <br>    lpInstruction++; <br>    lpTriangle = (LPD3DTRIANGLE)lpInstruction; <br>    lpTriangle-&gt;wV1    = 0U;  <br>    lpTriangle-&gt;wV2    = 1U; <br>    lpTriangle-&gt;wV3    = 2U; <br>    lpTriangle-&gt;wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE; <br>    lpTriangle++; <br> <br>    /* <br>     * Stop execution of the buffer. <br>     */ <br>    lpInstruction = (LPD3DINSTRUCTION)lpTriangle; <br>    lpInstruction-&gt;bOpcode = D3DOP_EXIT; <br>    lpInstruction-&gt;bSize   = 0UL; <br>    lpInstruction-&gt;wCount  = 0U; <br> <br>    /* <br>     * Unlock the execute buffer. <br>     */ <br>    lpd3dExecuteBuffer-&gt;lpVtbl-&gt;Unlock(lpd3dExecuteBuffer); <br> <br>    return DD_OK; <br>} <br> <br>/***********************************************************************/ <br> <br>/* <br> * Create the elements making up the 3D scene. <br> * <br> * In this sample the scene consists of the single light, the viewport, <br> * the background and surface material, the three transformation matrices <br> * and the execute buffer holding the state changes and drawing primitives. <br> */ <br>static HRESULT <br>CreateScene(void) <br>{ <br>    HRESULT              hRes; <br>    D3DMATERIAL          d3dMaterial; <br>    D3DLIGHT             d3dLight; <br>    DWORD                dwVertexSize; <br>    DWORD                dwInstructionSize; <br>    DWORD                dwExecuteBufferSize; <br>    D3DEXECUTEBUFFERDESC d3dExecuteBufferDesc; <br>    D3DEXECUTEDATA       d3dExecuteData; <br> <br>    ASSERT(NULL != lpd3d); <br>    ASSERT(NULL != lpd3dDevice); <br>    ASSERT(NULL == lpd3dViewport); <br>    ASSERT(NULL == lpd3dMaterial); <br>    ASSERT(NULL == lpd3dBackgroundMaterial); <br>    ASSERT(NULL == lpd3dExecuteBuffer); <br>    ASSERT(NULL == lpd3dLight); <br>    ASSERT(0UL  == hd3dWorldMatrix); <br>    ASSERT(0UL  == hd3dViewMatrix); <br>    ASSERT(0UL  == hd3dProjMatrix); <br> <br>    /* <br>     * Create the light. <br>     */ <br>    hRes = lpd3d-&gt;lpVtbl-&gt;CreateLight(lpd3d, &amp;lpd3dLight, NULL); <br>    if (FAILED(hRes)) <br>        return hRes; <br> <br>    ZeroMemory(&amp;d3dLight, sizeof(d3dLight)); <br>    d3dLight.dwSize = sizeof(d3dLight); <br>    d3dLight.dltType = D3DLIGHT_POINT; <br>    d3dLight.dcvColor.dvR    = D3DVAL( 1.0); <br>    d3dLight.dcvColor.dvG    = D3DVAL( 1.0); <br>    d3dLight.dcvColor.dvB    = D3DVAL( 1.0); <br>    d3dLight.dcvColor.dvA    = D3DVAL( 1.0); <br>    d3dLight.dvPosition.dvX  = D3DVAL( 1.0); <br>    d3dLight.dvPosition.dvY  = D3DVAL(-1.0); <br>    d3dLight.dvPosition.dvZ  = D3DVAL(-1.0); <br>    d3dLight.dvAttenuation0  = D3DVAL( 1.0); <br>    d3dLight.dvAttenuation1  = D3DVAL( 0.1); <br>    d3dLight.dvAttenuation2  = D3DVAL( 0.0); <br>    hRes = lpd3dLight-&gt;lpVtbl-&gt;SetLight(lpd3dLight, &amp;d3dLight); <br>    if (FAILED(hRes)) <br>        return hRes; <br> <br>    /* <br>     * Create the background material. <br>     */ <br>    hRes = lpd3d-&gt;lpVtbl-&gt;CreateMaterial(lpd3d, &amp;lpd3dBackgroundMaterial, NULL); <br>    if (FAILED(hRes)) <br>        return hRes; <br> <br>    ZeroMemory(&amp;d3dMaterial, sizeof(d3dMaterial)); <br>    d3dMaterial.dwSize = sizeof(d3dMaterial); <br>    d3dMaterial.dcvDiffuse.r  = D3DVAL(0.0); <br>    d3dMaterial.dcvDiffuse.g  = D3DVAL(0.0); <br>    d3dMaterial.dcvDiffuse.b  = D3DVAL(0.0); <br>    d3dMaterial.dcvAmbient.r  = D3DVAL(0.0); <br>    d3dMaterial.dcvAmbient.g  = D3DVAL(0.0); <br>    d3dMaterial.dcvAmbient.b  = D3DVAL(0.0); <br>    d3dMaterial.dcvSpecular.r = D3DVAL(0.0); <br>    d3dMaterial.dcvSpecular.g = D3DVAL(0.0); <br>    d3dMaterial.dcvSpecular.b = D3DVAL(0.0); <br>    d3dMaterial.dvPower       = D3DVAL(0.0); <br> <br>    /* <br>     * As this is the background material we don't want a ramp allocated (we <br>     * are not going to be smooth shading the background). <br>     */ <br>    d3dMaterial.dwRampSize    = 1UL; <br>     <br>    hRes = lpd3dBackgroundMaterial-&gt;lpVtbl-&gt;SetMaterial(lpd3dBackgroundMaterial, <br>                                                        &amp;d3dMaterial); <br>    if (FAILED(hRes)) <br>        return hRes; <br>    hRes = lpd3dBackgroundMaterial-&gt;lpVtbl-&gt;GetHandle(lpd3dBackgroundMaterial, <br>                                                      lpd3dDevice, <br>                                                      &amp;hd3dBackgroundMaterial); <br>    if (FAILED(hRes)) <br>        return hRes; <br> <br>    /* <br>     * Create the viewport. <br>     * <br>     * The actual viewport parameter are set in the function UpdateViewport <br>     * which is called in response to WM_SIZE. <br>     */ <br>    hRes = lpd3d-&gt;lpVtbl-&gt;CreateViewport(lpd3d, &amp;lpd3dViewport, NULL); <br>    if (FAILED(hRes)) <br>        return hRes; <br>    hRes = lpd3dDevice-&gt;lpVtbl-&gt;AddViewport(lpd3dDevice, lpd3dViewport); <br>    if (FAILED(hRes)) <br>        return hRes; <br>    hRes = lpd3dViewport-&gt;lpVtbl-&gt;SetBackground(lpd3dViewport, hd3dBackgroundMaterial); <br>    if (FAILED(hRes)) <br>        return hRes; <br>    hRes = lpd3dViewport-&gt;lpVtbl-&gt;AddLight(lpd3dViewport, lpd3dLight); <br>    if (FAILED(hRes)) <br>        return hRes; <br> <br>    /* <br>     * Create the matrices. <br>     */ <br>    hRes = lpd3dDevice-&gt;lpVtbl-&gt;CreateMatrix(lpd3dDevice, &amp;hd3dWorldMatrix); <br>    if (FAILED(hRes)) <br>        return hRes; <br>    hRes = lpd3dDevice-&gt;lpVtbl-&gt;SetMatrix(lpd3dDevice, hd3dWorldMatrix, &amp;d3dWorldMatrix); <br>    if (FAILED(hRes)) <br>        return hRes; <br>    hRes = lpd3dDevice-&gt;lpVtbl-&gt;CreateMatrix(lpd3dDevice, &amp;hd3dViewMatrix); <br>    if (FAILED(hRes)) <br>        return hRes; <br>    hRes = lpd3dDevice-&gt;lpVtbl-&gt;SetMatrix(lpd3dDevice, hd3dViewMatrix, &amp;d3dViewMatrix); <br>    if (FAILED(hRes)) <br>        return hRes; <br>    hRes = lpd3dDevice-&gt;lpVtbl-&gt;CreateMatrix(lpd3dDevice, &amp;hd3dProjMatrix); <br>    if (FAILED(hRes)) <br>        return hRes; <br>    SetPerspectiveProjection(&amp;d3dProjMatrix, HALF_HEIGHT, FRONT_CLIP, BACK_CLIP); <br>    hRes = lpd3dDevice-&gt;lpVtbl-&gt;SetMatrix(lpd3dDevice, hd3dProjMatrix, &amp;d3dProjMatrix); <br>    if (FAILED(hRes)) <br>        return hRes; <br> <br>    /* <br>     * Create the surface material. <br>     */ <br>    hRes = lpd3d-&gt;lpVtbl-&gt;CreateMaterial(lpd3d, &amp;lpd3dMaterial, NULL); <br>    if (FAILED(hRes)) <br>        return hRes; <br>    ZeroMemory(&amp;d3dMaterial, sizeof(d3dMaterial)); <br>    d3dMaterial.dwSize = sizeof(d3dMaterial); <br> <br>    /* <br>     * Base green with white specular. <br>     */ <br>    d3dMaterial.dcvDiffuse.r  = D3DVAL(0.0); <br>    d3dMaterial.dcvDiffuse.g  = D3DVAL(1.0); <br>    d3dMaterial.dcvDiffuse.b  = D3DVAL(0.0); <br>    d3dMaterial.dcvAmbient.r  = D3DVAL(0.0); <br>    d3dMaterial.dcvAmbient.g  = D3DVAL(0.4); <br>    d3dMaterial.dcvAmbient.b  = D3DVAL(0.0); <br>    d3dMaterial.dcvSpecular.r = D3DVAL(1.0); <br>    d3dMaterial.dcvSpecular.g = D3DVAL(1.0); <br>    d3dMaterial.dcvSpecular.b = D3DVAL(1.0); <br>    d3dMaterial.dvPower       = D3DVAL(20.0); <br>    d3dMaterial.dwRampSize    = 16UL; <br>     <br>    hRes = lpd3dMaterial-&gt;lpVtbl-&gt;SetMaterial(lpd3dMaterial, &amp;d3dMaterial); <br>    if (FAILED(hRes)) <br>        return hRes; <br> <br>    hRes = lpd3dMaterial-&gt;lpVtbl-&gt;GetHandle(lpd3dMaterial, lpd3dDevice, &amp;hd3dSurfaceMaterial); <br>    if (FAILED(hRes)) <br>        return hRes; <br> <br>    /* <br>     * Build the execute buffer. <br>     */ <br>    dwVertexSize        = (NUM_VERTICES        * sizeof(D3DVERTEX)); <br>    dwInstructionSize   = (NUM_INSTRUCTIONS    * sizeof(D3DINSTRUCTION))     + <br>                          (NUM_STATES          * sizeof(D3DSTATE))           + <br>                          (NUM_PROCESSVERTICES * sizeof(D3DPROCESSVERTICES)) + <br>                          (NUM_TRIANGLES       * sizeof(D3DTRIANGLE)); <br>    dwExecuteBufferSize = dwVertexSize + dwInstructionSize; <br>    ZeroMemory(&amp;d3dExecuteBufferDesc, sizeof(d3dExecuteBufferDesc)); <br>    d3dExecuteBufferDesc.dwSize       = sizeof(d3dExecuteBufferDesc); <br>    d3dExecuteBufferDesc.dwFlags      = D3DDEB_BUFSIZE; <br>    d3dExecuteBufferDesc.dwBufferSize = dwExecuteBufferSize; <br>    hRes = lpd3dDevice-&gt;lpVtbl-&gt;CreateExecuteBuffer(lpd3dDevice, <br>                                                    &amp;d3dExecuteBufferDesc, <br>                                                    &amp;lpd3dExecuteBuffer, <br>                                                    NULL); <br>    if (FAILED(hRes)) <br>        return hRes; <br> <br>    /* <br>     * Fill the execute buffer with the required vertices, state <br>     * instructions and drawing primitives. <br>     */ <br>    hRes = FillExecuteBuffer(); <br>    if (FAILED(hRes)) <br>        return hRes; <br> <br>    /* <br>     * Set the execute data so Direct3D knows how many vertices are in the <br>     * buffer and where the instructions start. <br>     */ <br>    ZeroMemory(&amp;d3dExecuteData, sizeof(d3dExecuteData)); <br>    d3dExecuteData.dwSize = sizeof(d3dExecuteData); <br>    d3dExecuteData.dwVertexCount       = NUM_VERTICES; <br>    d3dExecuteData.dwInstructionOffset = dwVertexSize; <br>    d3dExecuteData.dwInstructionLength = dwInstructionSize; <br>    hRes = lpd3dExecuteBuffer-&gt;lpVtbl-&gt;SetExecuteData(lpd3dExecuteBuffer, &amp;d3dExecuteData); <br>    if (FAILED(hRes)) <br>        return hRes; <br> <br>    return DD_OK; <br>} <br> <br>/***********************************************************************/ <br> <br>/* <br> * Release all the objects comprising the 3D scene. <br> */ <br>static HRESULT <br>ReleaseScene(void) <br>{ <br>    if (NULL != lpd3dExecuteBuffer) <br>    { <br>        lpd3dExecuteBuffer-&gt;lpVtbl-&gt;Release(lpd3dExecuteBuffer); <br>        lpd3dExecuteBuffer = NULL; <br>    } <br>    if (NULL != lpd3dBackgroundMaterial) <br>    { <br>        lpd3dBackgroundMaterial-&gt;lpVtbl-&gt;Release(lpd3dBackgroundMaterial); <br>        lpd3dBackgroundMaterial = NULL; <br>    } <br>    if (NULL != lpd3dMaterial) <br>    { <br>        lpd3dMaterial-&gt;lpVtbl-&gt;Release(lpd3dMaterial); <br>        lpd3dMaterial = NULL; <br>    } <br>    if (0UL != hd3dWorldMatrix) <br>    { <br>        lpd3dDevice-&gt;lpVtbl-&gt;DeleteMatrix(lpd3dDevice, hd3dWorldMatrix); <br>        hd3dWorldMatrix = 0UL; <br>    } <br>    if (0UL != hd3dViewMatrix) <br>    { <br>        lpd3dDevice-&gt;lpVtbl-&gt;DeleteMatrix(lpd3dDevice, hd3dViewMatrix); <br>        hd3dViewMatrix = 0UL; <br>    } <br>    if (0UL != hd3dProjMatrix) <br>    { <br>        lpd3dDevice-&gt;lpVtbl-&gt;DeleteMatrix(lpd3dDevice, hd3dProjMatrix); <br>        hd3dProjMatrix = 0UL; <br>    } <br>    if (NULL != lpd3dLight) <br>    { <br>        lpd3dLight-&gt;lpVtbl-&gt;Release(lpd3dLight); <br>        lpd3dLight = NULL; <br>    } <br>    if (NULL != lpd3dViewport) <br>    { <br>        lpd3dViewport-&gt;lpVtbl-&gt;Release(lpd3dViewport); <br>        lpd3dViewport = NULL; <br>    } <br> <br>    return DD_OK; <br>} <br> <br>/***********************************************************************/ <br> <br>/* <br> * Animate the scene. <br> * <br> * The animation in this sample is simply a rotation about the Y axis. <br> * So all we need to do is build a rotation matrix and set the world <br> * matrix to that new rotation matrix. <br> * <br> * Note, we don't need to modify the execute buffer in any way to peform <br> * this rotation. We simply set the matrix and resubmit the execute <br> * buffer. <br> */ <br>static HRESULT <br>AnimateScene(void) <br>{ <br>    HRESULT hRes; <br> <br>    ASSERT(NULL != lpd3dDevice); <br>    ASSERT(0UL  != hd3dWorldMatrix); <br> <br>    /* <br>     * We rotate the triangle by setting thr world transform to a <br>     * rotation matrix. <br>     */ <br>    SetRotationAboutY(&amp;d3dWorldMatrix, dAngleOfRotation); <br>    dAngleOfRotation += ROTATE_ANGLE_DELTA; <br>    hRes = lpd3dDevice-&gt;lpVtbl-&gt;SetMatrix(lpd3dDevice, <br>                                          hd3dWorldMatrix, <br>                                          &amp;d3dWorldMatrix); <br>    if (FAILED(hRes)) <br>        return hRes; <br> <br>    return DD_OK; <br>} <br> <br>/***********************************************************************/ <br> <br>/* <br> * Update the viewport in response to a change in window size. This <br> * ensures that we render at a resolution which matches the client <br> * area of the target window. <br> */ <br>static HRESULT <br>UpdateViewport(void) <br>{ <br>    D3DVIEWPORT d3dViewport; <br> <br>    ASSERT(NULL != lpd3dViewport); <br> <br>    ZeroMemory(&amp;d3dViewport, sizeof(d3dViewport)); <br>    d3dViewport.dwSize   = sizeof(d3dViewport); <br>    d3dViewport.dwX      = 0UL; <br>    d3dViewport.dwY      = 0UL; <br>    d3dViewport.dwWidth  = (DWORD)rSrcRect.right; <br>    d3dViewport.dwHeight = (DWORD)rSrcRect.bottom; <br>    d3dViewport.dvScaleX = D3DVAL((float)d3dViewport.dwWidth / 2.0); <br>    d3dViewport.dvScaleY = D3DVAL((float)d3dViewport.dwHeight / 2.0); <br>    d3dViewport.dvMaxX   = D3DVAL(1.0); <br>    d3dViewport.dvMaxY   = D3DVAL(1.0); <br>    return lpd3dViewport-&gt;lpVtbl-&gt;SetViewport(lpd3dViewport, &amp;d3dViewport); <br>} <br> <br>/***********************************************************************/ <br> <br>/* <br> * Render the 3D scene. <br> * <br> * Fundamentally this involved submitting our single execute buffer. <br> * However, we also need to clear the back and z-buffers and demark <br> * the start and end of the scene (which in this case is a single <br> * execute). <br> */ <br>static HRESULT <br>RenderScene(void) <br>{ <br>    HRESULT hRes; <br>    D3DRECT d3dRect; <br> <br>    ASSERT(NULL != lpd3dViewport); <br>    ASSERT(NULL != lpd3dDevice); <br>    ASSERT(NULL != lpd3dExecuteBuffer); <br> <br>    /* <br>     * Clear both back and z-buffer. <br>     * <br>     * NOTE: Its safe to specify the z-buffer clear flag even if we <br>     * don't have an attached z-buffer. Direct3D will simply discard <br>     * the flag if no z-buffer is being used. <br>     * <br>     * NOTE: For maximum efficiency we only want to clear those <br>     * regions of the device surface and z-buffer which we actually <br>     * rendered to in the last frame. This is the purpose of the <br>     * array of rectangles and count passed to this function. It is <br>     * possible to query Direct3D for the regions of the device <br>     * surface that were rendered to by that execute. The application <br>     * can then accumulate those rectangles and clear only those <br>     * regions. However this is a very simple sample and so, for <br>     * simplicity, we will just clear the entire device surface and <br>     * z-buffer. Probably not something you want to do in a real <br>     * application. <br>     */ <br>    d3dRect.lX1 = rSrcRect.left; <br>    d3dRect.lX2 = rSrcRect.right; <br>    d3dRect.lY1 = rSrcRect.top; <br>    d3dRect.lY2 = rSrcRect.bottom; <br>    hRes = lpd3dViewport-&gt;lpVtbl-&gt;Clear(lpd3dViewport, <br>                                        1UL, <br>                                        &amp;d3dRect, <br>                                        D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER); <br>    if (FAILED(hRes)) <br>        return hRes; <br> <br>    /* <br>     * Start the scene. <br>     * <br>     * This function must be called once and once only for every frame <br>     * of animation. If you have multiple execute buffers comprising a <br>     * single frame you must have one call to BeginScene() before <br>     * submitting those execute buffers. <br>     * <br>     * NOTE: If you have more than one device being rendered in a <br>     * single frame, say a rear view mirror in a racing game, call <br>     * BeginScene() and EndScene() once for each device. <br>     */ <br>    hRes = lpd3dDevice-&gt;lpVtbl-&gt;BeginScene(lpd3dDevice); <br>    if (FAILED(hRes)) <br>        return hRes; <br> <br>    /* <br>     * Submit the execute buffer. <br>     * <br>     * We want Direct3D to clip the data on our behalf so we specify <br>     * D3DEXECUTE_CLIPPED. <br>     */ <br>    hRes = lpd3dDevice-&gt;lpVtbl-&gt;Execute(lpd3dDevice, <br>                                        lpd3dExecuteBuffer, <br>                                        lpd3dViewport, <br>                                        D3DEXECUTE_CLIPPED); <br>    if (FAILED(hRes)) <br>    { <br>        lpd3dDevice-&gt;lpVtbl-&gt;EndScene(lpd3dDevice); <br>        return hRes; <br>    } <br> <br>    /* <br>     * End the scene. <br>     */ <br>    hRes = lpd3dDevice-&gt;lpVtbl-&gt;EndScene(lpd3dDevice); <br>    if (FAILED(hRes)) <br>        return hRes; <br> <br>    /* <br>     * At this point the scene will have been rendered and the device <br>     * surface will hold the contents of the rendering. <br>     */ <br> <br>    return DD_OK; <br>} <br> <br>/***********************************************************************/ <br> <br>/* <br> * Render and show a single frame. <br> * <br> * This involves rendering the scene and blitting the result to client <br> * area of the application window on the primary surface. <br> * <br> * NOTE: This function handles lost surfaces by attempting to restore <br> * the applications surfaces and then retrying the rendering. <br> */ <br>static HRESULT <br>DoFrame(HWND hwnd) <br>{ <br>    HRESULT hRes; <br> <br>    /* <br>     * We keeping trying until we succeed or we fail for a reason <br>     * other than DDERR_SURFACELOST. <br>     */ <br>    while (TRUE) <br>    { <br>        hRes = RenderScene(); <br>        if (SUCCEEDED(hRes)) <br>        { <br>    POINT pt; <br>    RECT rTmp; <br> <br>    pt.x = pt.y = 0; <br>    ClientToScreen( hwnd, &amp;pt ); <br> <br>    rTmp = rDstRect; <br>    OffsetRect(&amp;rTmp, pt.x, pt.y); <br> <br>            hRes = lpddPrimary-&gt;lpVtbl-&gt;Blt(lpddPrimary, <br>                                            &amp;rTmp, <br>                                            lpddDevice, <br>                                            &amp;rSrcRect, <br>                                            DDBLT_WAIT, <br>                                            NULL); <br>            if (SUCCEEDED(hRes)) <br>                /* <br>                 * It worked. Bail. <br>                 */ <br>                return hRes; <br>        } <br>        while (DDERR_SURFACELOST == hRes) <br>            /* <br>             * The surfaces are lost. Restore them. <br>             */ <br>            hRes = RestoreSurfaces(); <br>        if (FAILED(hRes)) <br>            /* <br>             * Something went wrong and it wasn't DDERR_SURFACELOST. <br>             */ <br>            return hRes; <br>    } <br>} <br> <br>/***********************************************************************/ <br> <br>/* <br> * The application suspends when in the background or when handling and <br> * error. We signal this fact by drawing a notification string in the <br> * client area of the window. <br> */ <br>static void </code></pre>
<p>
</p>
<pre><code>PaintSuspended(HWND hwnd, HDC hdc) <br>{ <br>    HPEN     hOldPen; <br>    HBRUSH   hOldBrush; <br>    COLORREF crOldTextColor; <br>    int      oldMode; <br>    int      x; <br>    int      y; <br>    SIZE     size; <br>    RECT     rect; <br>    int      nStrLen; <br> <br>    /* <br>     * Black background. <br>     */ <br>    hOldPen   = SelectObject(hdc, GetStockObject(NULL_PEN)); <br>    hOldBrush = SelectObject(hdc, GetStockObject(BLACK_BRUSH)); <br> <br>    /* <br>     * White text. <br>     */ <br>    oldMode = SetBkMode(hdc, TRANSPARENT); <br>    crOldTextColor = SetTextColor(hdc, RGB(255, 255, 255)); <br> <br>    GetClientRect(hwnd, &amp;rect); <br> <br>    /* <br>     * Clear the client area. <br>     */ <br>    Rectangle(hdc, rect.left, rect.top, rect.right + 1, rect.bottom + 1); <br> <br>    /* <br>     * Draw the string centered in the client area. <br>     */ <br>    nStrLen = strlen(PAUSED_STRING); <br>    GetTextExtentPoint32(hdc, PAUSED_STRING, nStrLen, &amp;size); <br>    x = (rect.right  - size.cx) / 2; <br>    y = (rect.bottom - size.cy) / 2; <br>    TextOut(hdc, x, y, PAUSED_STRING, nStrLen); <br> <br>    SetTextColor(hdc, crOldTextColor); <br>    SetBkMode(hdc, oldMode); <br> <br>    SelectObject(hdc, hOldBrush); <br>    SelectObject(hdc, hOldPen); <br>} <br> <br>/***********************************************************************/ <br> <br>static LRESULT <br>OnMove(HWND hwnd, int x, int y) <br>{ <br>    HRESULT hRes; <br> <br>    /* <br>     * No action if the device has not yet been created or if we are <br>     * suspended. <br>     */ <br>    if ((NULL != lpd3dDevice) &amp;&amp; !fSuspended) <br>    { <br>        /* <br>         * Repaint the client area. <br>         */ <br>        hRes = DoFrame(hwnd); <br>        if (FAILED(hRes)) <br>        { <br>            FatalError(hwnd, IDS_ERRMSG_RENDERSCENE, hRes); <br>            return 0L; <br>        } <br>    } <br> <br>    return 0L; <br>} <br> <br>/***********************************************************************/ <br> <br>static LRESULT <br>OnSize(HWND hwnd, int w, int h) <br>{ <br>    HRESULT       hRes; <br>    DDSURFACEDESC ddsd; <br> <br>    /* <br>     * Nothing to do if we are suspended. <br>     */ <br>    if (!fSuspended) <br>    { <br>        /* <br>         * Update the source and destination rectangles (used by the <br>         * blit which shows the rendering in the client area). <br>         */ <br>        rDstRect.right  = rDstRect.left + w; <br>        rDstRect.bottom = rDstRect.top  + h; <br>        rSrcRect.right  = w; <br>        rSrcRect.bottom = h; <br> <br>        if (NULL != lpd3dDevice) <br>        { <br>            /* <br>             * We already have a device. But is it big enough for the the <br>             * new window client size? <br>             * <br>             * NOTE: As this window is fixed size we should not ever be <br>             * end up being resized. But just in case we will handle it. <br>             * This will be useful when we make the application resizable. <br>             */ <br>            ZeroMemory(&amp;ddsd, sizeof(ddsd)); <br>            ddsd.dwSize = sizeof(ddsd); <br>            hRes = lpddDevice-&gt;lpVtbl-&gt;GetSurfaceDesc(lpddDevice, &amp;ddsd); <br>            if (FAILED(hRes)) <br>            { <br>                FatalError(hwnd, IDS_ERRMSG_DEVICESIZE, hRes); <br>                return 0L; <br>            } <br>     <br>            if ((w &gt; (int)ddsd.dwWidth) || (h &gt; (int)ddsd.dwHeight)) <br>            { <br>                /* <br>                 * Nope, the device is too small. We need to shut it down <br>                 * and rebuild it. <br>                 */ <br> <br>                /* <br>                 * Execute buffers are bound to devices so when we release <br>                 * the device we must release the execute buffer. <br>                 */ <br>                ReleaseScene(); <br>                ReleaseDevice(); <br>            } <br>        } <br> <br>        if (NULL == lpd3dDevice) <br>        { <br>            /* <br>             * No Direct3D device yet. This is either because this is the <br>             * first time through the loop or because we discarded the <br>             * existing device because it was not big enough for the new <br>             * window client size. <br>             */ <br>            hRes = CreateDevice((DWORD)w, (DWORD)h); <br>            if (FAILED(hRes)) <br>            { <br>                FatalError(hwnd, IDS_ERRMSG_CREATEDEVICE, hRes); <br>                return 0L; <br>            } <br>            hRes = CreateScene(); <br>            if (FAILED(hRes)) <br>            { <br>                FatalError(hwnd, IDS_ERRMSG_BUILDSCENE, hRes); <br>                return 0L; <br>            } <br>        } <br> <br>        hRes = UpdateViewport(); <br>        if (FAILED(hRes)) <br>        { <br>            FatalError(hwnd, IDS_ERRMSG_UPDATEVIEWPORT, hRes); <br>            return 0L; <br>        } <br> <br>        /* <br>         * Render at the new size and show the results in the window's <br>         * client area. <br>         */ <br>        hRes = DoFrame(hwnd); <br>        if (FAILED(hRes)) <br>        { <br>            FatalError(hwnd, IDS_ERRMSG_RENDERSCENE, hRes); <br>            return 0L; <br>        } <br>    } <br> <br>    return 0L; <br>} <br> <br>/***********************************************************************/ <br> <br>static LRESULT <br>OnPaint(HWND hwnd, HDC hdc, LPPAINTSTRUCT lpps) <br>{ <br>    HRESULT hRes; <br> <br>    USE_PARAM(lpps); <br> <br>    if (fActive &amp;&amp; !fSuspended &amp;&amp; (NULL != lpd3dDevice)) <br>    { <br>        /* <br>         * NOTE: DoFrame() re-renders the scene as well as blitting the <br>         * result to the primary. As all we really want to do here is <br>         * repaint the client area we don't really need to re-render - <br>         * just re-blit. For this simple sample this inefficiency <br>         * doesn't matter but for real applications not re-rendering <br>         * may be a useful optimization. <br>         */ <br>        hRes = DoFrame(hwnd); <br>        if (FAILED(hRes)) <br>        { <br>            FatalError(hwnd, IDS_ERRMSG_RENDERSCENE, hRes); <br>            return 0L; <br>        } <br>    } <br>    else <br>    { <br>        /* <br>         * Show the suspended image if we are not active, or suspended or <br>         * if we have not yet created the device. <br>         */ <br>        PaintSuspended(hwnd, hdc); <br>    } <br> <br>    return 0L; <br>} <br> <br>/***********************************************************************/ <br> <br>static LRESULT <br>OnIdle(HWND hwnd) <br>{ <br>    HRESULT hRes; <br> <br>    /* <br>     * Only animate if we are the foreground app, we aren't suspended <br>     * and we have completed initialization. <br>     */ <br>    if (fActive &amp;&amp; !fSuspended &amp;&amp; (NULL != lpd3dDevice)) <br>    { <br>        hRes = AnimateScene(); <br>        if (FAILED(hRes)) <br>        { <br>            FatalError(hwnd, IDS_ERRMSG_ANIMATESCENE, hRes); <br>            return 0L; <br>        } <br> <br>        hRes = DoFrame(hwnd); <br>        if (FAILED(hRes)) <br>        { <br>            FatalError(hwnd, IDS_ERRMSG_RENDERSCENE, hRes); <br>            return 0L; <br>        } <br>    } <br> <br>    return 0L; <br>} <br> <br>/***********************************************************************/ <br> <br>LRESULT CALLBACK <br>WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>    HDC         hdc; <br>    PAINTSTRUCT ps; <br>    LRESULT     lResult; <br>    HRESULT     hRes; <br>    char        szBuffer[128]; <br> <br>    switch (msg) <br>    { <br>        case WM_CREATE: <br>            hRes = CreateDirect3D(hwnd); <br>            if (FAILED(hRes)) <br>            { <br>                ReportError(hwnd, IDS_ERRMSG_CREATEDEVICE, hRes); <br>                ReleaseDirect3D(); <br>                return -1L; <br>            } <br> <br>            hRes = CreatePrimary(hwnd); <br>            if (FAILED(hRes)) <br>            { <br>                ReportError(hwnd, IDS_ERRMSG_INITSCREEN, hRes); <br>                ReleasePrimary(); <br>                ReleaseDirect3D(); <br>                return -1L; <br>            } <br> <br>            hRes = ChooseDevice(); <br>            if (FAILED(hRes)) <br>            { <br>                ReportError(hwnd, IDS_ERRMSG_NODEVICE, hRes); <br>                ReleasePrimary(); <br>                ReleaseDirect3D(); <br>                return -1L; <br>            } <br> <br>            /* <br>             * Update the title to show the name of the chosen device. <br>             */ <br>            wsprintf(szBuffer, "%s: %s", WINDOW_TITLE, szDeviceName); <br>            SetWindowText(hwnd, szBuffer); <br> <br>            return 0L; <br> <br>        case WM_MOVE: <br>            return OnMove(hwnd, (int)(signed short)LOWORD(lParam), (int)(signed short)HIWORD(lParam)); <br> <br>        case WM_SIZE: <br>            return OnSize(hwnd, (int)LOWORD(lParam), (int)HIWORD(lParam)); <br> <br>        case WM_ERASEBKGND: <br>            /* <br>             * Our rendering fills the entire viewport so we won't bother <br>             * erasing the background. <br>             */ <br>            return 1L; <br> <br>        case WM_PAINT: <br>            hdc = BeginPaint(hwnd, &amp;ps); <br> <br>            lResult = OnPaint(hwnd, hdc, &amp;ps); <br> <br>            EndPaint(hwnd, &amp;ps); <br>            return lResult; <br> <br>        case WM_ACTIVATEAPP: <br>            fActive = (BOOL)wParam; <br>            if (fActive &amp;&amp; !fSuspended &amp;&amp; (NULL != lpddPalette)) <br>            { <br>                /* <br>                 * Realizing the palette using DirectDraw is quite different <br>                 * from GDI. To realize the palette we call SetPalette() <br>                 * each time our application is activated. <br>                 * <br>                 * NOTE: DirectDraw spots the fact that the new palette is the <br>                 * same as the old one and so does not increase the reference <br>                 * count of the palette. <br>                 */ <br>                hRes = lpddPrimary-&gt;lpVtbl-&gt;SetPalette(lpddPrimary, lpddPalette); <br>                if (FAILED(hRes)) <br>                { <br>                    FatalError(hwnd, IDS_ERRMSG_REALIZEPALETTE, hRes); <br>                    return 0L; <br>                } <br> <br>            } <br>            else <br>            { <br>                /* <br>                 * If we have been deactived invalidate to show the suspended <br>                 * display. <br>                 */ <br>                InvalidateRect(hwnd, NULL, FALSE); <br>            } <br>            return 0L; <br> <br>        case WM_KEYUP: <br>            /* <br>             * We use the escape key as a quick way of getting out of the <br>             * application. <br>             */ <br>            if (VK_ESCAPE == (int)wParam) <br>            { <br>                DestroyWindow(hwnd); <br>                return 0L; <br>            } <br>            break; <br> <br>        case WM_CLOSE: <br>            DestroyWindow(hwnd); <br>            return 0L; <br> <br>        case WM_DESTROY: <br>            /* <br>             * All cleanup is done here when terminating normally or <br>             * shutting down due to an error. <br>             */ <br>            ReleaseScene(); <br>            ReleaseDevice(); <br>            ReleasePrimary(); <br>            ReleaseDirect3D(); <br> <br>            PostQuitMessage(0); <br>            return 0L; <br>    } <br> <br>    return DefWindowProc(hwnd, msg, wParam, lParam); <br>} <br>                         <br>/***********************************************************************/ <br> <br>int PASCAL <br>WinMain(HINSTANCE hInstance, <br>        HINSTANCE hPrevInstance, <br>        LPSTR     lpszCommandLine, <br>        int       cmdShow) <br>{ <br>    WNDCLASS wndClass; <br>    HWND     hwnd; <br>    MSG      msg; <br> <br>    USE_PARAM(hPrevInstance); <br> <br>    /* <br>     * Record the instance handle. <br>     */ <br>    hAppInstance = hInstance; <br> <br>    /* <br>     * Very, very primitive command line processing. We only have one <br>     * option, debug so we will just assume that if anything was <br>     * specified on the command line that means debug mode (no hardware <br>     * all surfaces explicitly in system memory). <br>     */ <br>    if (0 != *lpszCommandLine) <br>        fDebug = TRUE; <br> <br>    /* <br>     * Register the window class. <br>     */ <br>    wndClass.style         = 0; <br>    wndClass.lpfnWndProc   = WndProc; <br>    wndClass.cbClsExtra    = 0; <br>    wndClass.cbWndExtra    = 0; <br>    wndClass.hInstance     = hInstance; <br>    wndClass.hIcon         = LoadIcon(hAppInstance, MAKEINTRESOURCE(IDI_APPICON)); <br>    wndClass.hCursor       = LoadCursor(NULL, IDC_ARROW); <br>    wndClass.hbrBackground = GetStockObject(WHITE_BRUSH); <br>    wndClass.lpszMenuName  = NULL; <br>    wndClass.lpszClassName = WINDOW_CLASSNAME; <br> <br>    RegisterClass(&amp;wndClass); <br> <br>    /* <br>     * Create the main window of the instance. <br>     */ <br>    hwnd = CreateWindow(WINDOW_CLASSNAME, <br>                        WINDOW_TITLE, <br>                        WS_OVERLAPPED | WS_SYSMENU, <br>                        CW_USEDEFAULT, CW_USEDEFAULT, <br>                        WINDOW_WIDTH, WINDOW_HEIGHT, <br>                        NULL, <br>                        NULL, <br>                        hInstance, <br>                        NULL); <br> <br>    ShowWindow(hwnd, cmdShow); <br>    UpdateWindow(hwnd); <br> <br>    /* <br>     * The main message dispatch loop. <br>     * <br>     * NOTE: For simplicity we handle the message loop with a <br>     * simple PeekMessage scheme. This might not be the best <br>     * mechanism for a real application (a separate render worker <br>     * thread might be better).  <br>     */ <br>    while (TRUE) <br>    { <br>        if (PeekMessage(&amp;msg, NULL, 0U, 0U, PM_REMOVE)) <br>        { <br>            /* <br>             * Message pending. If its QUIT then exit the message <br>             * loop. Otherwise, process the message. <br>             */ <br>            if (WM_QUIT == msg.message) <br>            { <br>                break; <br>            } <br>            else <br>            { <br>                TranslateMessage(&amp;msg); <br>                DispatchMessage(&amp;msg); <br>            } <br>        } <br>        else <br>        { <br>            /* <br>             * Animate the scene. <br>             */ <br>            OnIdle(hwnd); <br>        } <br>    } <br> <br>    return msg.wParam; <br>} <br> <br>/***********************************************************************/ <br> <br>/*********************************************************************** <br> * <br> * End of file <br> * <br> ***********************************************************************/ </code></pre>
<p>&nbsp;</p></body>
</HTML>
