<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MOSQUITO.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3258"></a>MOSQUITO.CPP</h2>
<pre><code>//**************************************************************************** <br>//* Program: Mosquito <br>//* <br>//* Description: <br>//*     Sample application to demonstrate the creation, display, and  <br>//*     positioning of overlays. <br>//* <br>//* Contents: <br>//*     WinMain() - Main entry point for this application. <br>//*     MainDlgProc() - Message proc for this app. <br>//*     InitDirectDraw() - Creates core DirectDraw objects. <br>//*     FreeDirectDraw() - Frees up core DirectDraw objects. <br>//*     CreatePrimarySurface() - Creates Primary surface. <br>//*     CreateOverlay() - Creates a multi-buffer flippable overlay surface. <br>//*     DestroyOverlay() - Hides overlay surface and releases it. <br>//*     CopyBitmapToYUVSurface() - Copies a GDI bitmap to a YUV surface. <br>//*                                Used by LoadImageOntoSurface(). <br>//*     LoadImageOntoSurface() - Loads a resource based bitmap onto a surface. <br>//*     EnumAttachedCallback() - Callback for EnumAttachedSurfaces(). <br>//*     DisplayOverlay() - Displays our overlay on the primary. <br>//*     RestoreAllSurfaces() - Restores the primary and overlay surfaces. <br>//*     MoveOverlayTimerCallback() - TimerProc for moving the overlay surface. <br>//* <br>//* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF  <br>//* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO  <br>//* THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A  <br>//* PARTICULAR PURPOSE. <br>//* <br>//* Copyright 1996 - 1998 Microsoft Corporation.  All Rights Reserved. <br>//**************************************************************************** <br> <br>// C RunTime Header Files <br>#include &lt;stdlib.h&gt; <br>#include &lt;malloc.h&gt; <br>#include &lt;memory.h&gt; <br> <br>// Windows Header Files: <br>#include &lt;windows.h&gt; <br>#include &lt;mmsystem.h&gt; //added to compile under NT <br>#define INITGUID <br>#include &lt;objbase.h&gt; <br>#include &lt;initguid.h&gt; <br>#include &lt;ddraw.h&gt;                                                                 <br> <br>// Local Headers <br>#include "resource.h" <br> <br>// Define some macros <br>#define INIT_DIRECTDRAW_STRUCT(x) (ZeroMemory(&amp;x, sizeof(x)), x.dwSize=sizeof(x)) <br>#define RAND_INT(x) (rand()*x/RAND_MAX) <br>#define RANDOM_VELOCITY() ((RAND_INT(5)+3)*2) <br>  <br>// Global Variables: <br> <br>LPDIRECTDRAW2       g_lpdd = NULL; <br>LPDIRECTDRAWSURFACE g_lpddsPrimary = NULL; <br>LPDIRECTDRAWSURFACE g_lpddsOverlay = NULL; <br> <br>int g_nOverlayXPos, g_nOverlayYPos; <br>int g_nOverlayXVel, g_nOverlayYVel; <br>int g_nOverlayWidth, g_nOverlayHeight; <br>int g_nOverlayFlipCounter;  <br>DWORD g_dwOverlayXPositionAlignment;  // used to keep track of any alignment <br>                                      // restrictions on the X postion of <br>                                      // our overlay surface.  Comes from the <br>                                      // the DDCAPS dwBoundaryAlignDest field. <br>                                      // Initialized in DisplayOverlay(). <br> <br>// These are the pixel formats this app supports.  Most display adapters <br>// with overlay support will recognize one or more of these formats. <br>// The first on our list is the 16-bit RGB formats.  These have the widest <br>// support. <br>DDPIXELFORMAT g_ddpfOverlayFormats[] =  <br>{   {sizeof(DDPIXELFORMAT), DDPF_RGB, 0, 16,  0x7C00, 0x03e0, 0x001F, 0},      // 16-bit RGB 5:5:5 <br>    {sizeof(DDPIXELFORMAT), DDPF_RGB, 0, 16,  0xF800, 0x07e0, 0x001F, 0},   // 16-bit RGB 5:6:5 <br>    {sizeof(DDPIXELFORMAT), DDPF_FOURCC,MAKEFOURCC('U','Y','V','Y'),0,0,0,0,0}, // UYVY <br>    {sizeof(DDPIXELFORMAT), DDPF_FOURCC,MAKEFOURCC('Y','U','Y','2'),0,0,0,0,0}};  // YUY2 <br> <br>#define NUM_OVERLAY_FORMATS (sizeof(g_ddpfOverlayFormats) / sizeof(g_ddpfOverlayFormats[0])) <br> <br>// Define some error messages.  If we had many more we'd stick 'em in our RC file. <br>#define NO_OVERLAY_HARDWARE     "Sorry, In order to run this sample application you must "\ <br>                                "have a display adapter and driver which support overlays." <br> <br>#define UNABLE_TO_CREATE_OVERLAY    "Sorry, your display adapter appears to "\ <br>                                    "support overlays, but we were unable to "\ <br>                                    "create an overlay in any of the formats "\ <br>                                    "this app supports (16-bit RGB and YUV).  "\ <br>                                    "You may want to try shutting down other "\ <br>                                    "DirectX apps to free video memory, or try "\ <br>                                    "rerunning this app in a different display "\ <br>                                    "mode." <br> <br>#define UNABLE_TO_DISPLAY_OVERLAY   "Sorry, we created an overlay on your "\ <br>                                    "system, but were unable to display it.  "\ <br>                                    "Please try rerunning this app in "\ <br>                                    "a different display mode." <br> <br>//**************************************************************************** <br>//* Function: FreeDirectDraw <br>//* <br>//* Description: <br>//*             Releases core DirectDraw objects <br>//**************************************************************************** <br>void FreeDirectDraw(void) <br>{ <br>if (g_lpddsPrimary) <br>{ <br>g_lpddsPrimary-&gt;Release(); <br>g_lpddsPrimary=NULL; <br>} <br> <br>    if (g_lpdd) <br>{ <br>g_lpdd-&gt;Release(); <br>g_lpdd=NULL; <br>} <br>} <br> <br> <br>//**************************************************************************** <br>//* Function: CreatePrimarySurface() <br>//* <br>//* Description: <br>//*     Creates a Primary Surface.  Implemented as a separate function from <br>//* InitDirectDraw() because we occasionally need to just recreate the primary <br>//* surface such as when a mode change occurs. <br>//**************************************************************************** <br>HRESULT CreatePrimarySurface() <br>{ <br>DDSURFACEDESC   ddsd; <br>    HRESULT         ddrval; <br> <br>    if (!g_lpdd) return E_FAIL; <br> <br>    INIT_DIRECTDRAW_STRUCT(ddsd); <br>    ddsd.dwFlags = DDSD_CAPS; <br>    ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE; <br>    ddrval = g_lpdd-&gt;CreateSurface(&amp;ddsd, &amp;g_lpddsPrimary, NULL ); <br> <br>    return ddrval; <br>} <br> <br> <br>//**************************************************************************** <br>//* Function: InitDirectDraw <br>//* <br>//* Description: <br>//*     Performs DirectDraw initialization.  Creates a primary surface which <br>//*     is needed to display our overlay on.  The actual overlay surface is <br>//*     created later in our CreateOverlay() call. <br>//**************************************************************************** <br>BOOL InitDirectDraw() <br>{ <br>HRESULT         ddrval; <br>    LPDIRECTDRAW    lpDD1; <br> <br>    ddrval = DirectDrawCreate( NULL, &amp;lpDD1, NULL ); <br>    if( FAILED(ddrval)) <br>    goto ErrorOut; <br> <br>    ddrval = lpDD1-&gt;QueryInterface(IID_IDirectDraw2, (void **)&amp;g_lpdd); <br>    if( FAILED(ddrval)) <br>    goto ErrorOut; <br>     <br>    lpDD1-&gt;Release(); <br> <br>    // For NORMAL cooperative level we no longer need to provide an HWND. <br>    ddrval = g_lpdd-&gt;SetCooperativeLevel(NULL, DDSCL_NORMAL); <br>    if( FAILED(ddrval)) <br>    goto ErrorOut; <br> <br>    ddrval= CreatePrimarySurface(); <br>    if( FAILED(ddrval)) <br>        goto ErrorOut; <br> <br> <br>    return TRUE; <br> <br>ErrorOut: <br> <br>FreeDirectDraw(); <br> <br>return FALSE; <br>} <br> <br> <br>//**************************************************************************** <br>//* Function: DestroyOverlay() <br>//* Description: <br>//*     Hides the overlay then releases it's surface. <br>//**************************************************************************** <br>void DestroyOverlay() <br>{ <br>if (g_lpddsOverlay) <br>{ <br>        // Use UpdateOverlay() with the DDOVER_HIDE flag to remove an overlay  <br>        // from the display. <br>        g_lpddsOverlay-&gt;UpdateOverlay(NULL, g_lpddsPrimary, NULL, DDOVER_HIDE, NULL); <br>g_lpddsOverlay-&gt;Release(); <br>g_lpddsOverlay=NULL; <br>} <br>} <br> <br> <br>//**************************************************************************** <br>//* Function: CopyBitmapToYUVSurface <br>//* Description:  <br>//*     Copies an RGB GDI bitmap to a YUV surface. Both bitmap and surface <br>//*     must be a multiple of 2 pixels in width for the supported YUV formats.   <br>//*     The following formats are supported: <br>//*             YUY2 <br>//*             UYVY <br>//*      <br>//*     The "YUY2" YUV pixel format looks like this: <br>//*         As a series of BYTES:    [Y0][U][Y1][V] (reverse it for a DWORD) <br>//* <br>//*     The "UYVY" YUV pixel format looks like this: <br>//*         As a series of BYTES:    [U][Y0][V][Y1] (reverse it for a DWORD) <br>//* <br>//*     As you can see, both formats pack two pixels into a single DWORD. The  <br>//*     pixels share U and V components and have separate Y components. <br>//*      <br>//* Returns: TRUE if successful, otherwise FALSE. <br>//**************************************************************************** <br>BOOL CopyBitmapToYUVSurface(LPDIRECTDRAWSURFACE lpDDSurf, HBITMAP hbm) <br>{ <br>    HDC                 hdcImage; <br>    HRESULT             ddrval; <br>    DDSURFACEDESC       ddsd; <br>    DWORD               x, y, dwWidth, dwHeight; <br>    LONG                lPitch; <br>    LPBYTE              pSurf; <br>    DWORD               dwBytesInRow; <br>    COLORREF            color; <br>    BYTE                R,G,B, Y0,Y1,U,V; <br>    BOOL                bRet = FALSE; <br> <br>    if (hbm == NULL || lpDDSurf == NULL) <br>        return FALSE; <br> <br>    // <br>    //  select bitmap into a memoryDC so we can use it. <br>    // <br>    hdcImage = CreateCompatibleDC(NULL); <br>    SelectObject(hdcImage, hbm); <br> <br> <br>    INIT_DIRECTDRAW_STRUCT(ddsd); <br>    // Lock down the surface so we can modify it's contents. <br>    ddrval=lpDDSurf-&gt;Lock( NULL, &amp;ddsd, DDLOCK_SURFACEMEMORYPTR|DDLOCK_WAIT, NULL); <br>    if (FAILED(ddrval)) <br>    goto CleanUp; <br> <br>    dwWidth=ddsd.dwWidth; <br>    dwHeight=ddsd.dwHeight; <br>    lPitch=ddsd.lPitch; <br>    pSurf=(LPBYTE)ddsd.lpSurface; <br>dwBytesInRow=ddsd.dwWidth*2; <br> <br>    // Go through the image 2 pixels at a time and convert to YUV <br>    for(y=0; y&lt;dwHeight; y++) <br>    { <br>    for(x=0; x&lt;dwWidth; x+=2) <br>{ <br>            // The equations for color conversion used here, probably aren't  <br>            // exact, but they seem to do an OK job. <br>color=GetPixel(hdcImage, x,y); <br>R=GetRValue(color); <br>G=GetGValue(color); <br>B=GetBValue(color); <br>        Y0= (BYTE)(0.29*R + 0.59*G + 0.14*B); <br>U= (BYTE)(128.0 - 0.14*R - 0.29*G + 0.43*B); <br> <br>color=GetPixel(hdcImage, x+1,y); <br>R=GetRValue(color); <br>G=GetGValue(color); <br>B=GetBValue(color); <br>Y1= (BYTE)(0.29*R + 0.57*G + 0.14*B); <br>V= (BYTE)(128.0 + 0.36*R - 0.29*G - 0.07*B); <br> <br>switch (ddsd.ddpfPixelFormat.dwFourCC) <br>{ <br>case MAKEFOURCC('Y','U','Y','2'):  <br>*(pSurf++) = Y0; <br>*(pSurf++) = U; <br>*(pSurf++) = Y1; <br>*(pSurf++) = V; <br>break; <br>case MAKEFOURCC('U','Y','V','Y'):  <br>*(pSurf++) = U; <br>*(pSurf++) = Y0; <br>*(pSurf++) = V; <br>*(pSurf++) = Y1; <br>break; <br>}                        <br>} <br>pSurf+=(lPitch-dwBytesInRow); <br>    } <br> <br>    lpDDSurf-&gt;Unlock(NULL);      <br> <br>CleanUp: <br>    if(hdcImage) <br>        DeleteDC(hdcImage); <br> <br>return TRUE; <br>} <br> <br>//**************************************************************************** <br>//* Function: LoadImageOnToSurface <br>//* Description: <br>//*     Loads a resource based bitmap image onto a DirectDraw surface.  Can <br>//*     covert the bitmap to all RGB formats, plus a couple YUV formats. <br>//**************************************************************************** <br>BOOL LoadImageOntoSurface(LPDIRECTDRAWSURFACE lpdds, LPSTR lpstrResID) <br>{ <br>    HBITMAP hbm; <br>    HDC     hdcImage= NULL; <br>    HDC     hdcSurf = NULL; <br>    BOOL bRetVal = FALSE; <br>    HRESULT ddrval; <br>    DDSURFACEDESC ddsd; <br> <br>    if (!lpdds) <br>        return FALSE; <br> <br>    // <br>    // get surface size and format. <br>    // <br>    INIT_DIRECTDRAW_STRUCT(ddsd); <br>    ddsd.dwFlags = DDSD_HEIGHT | DDSD_WIDTH; <br>    ddrval = lpdds-&gt;GetSurfaceDesc(&amp;ddsd); <br>    if (FAILED(ddrval)) <br>        goto Exit; <br> <br>   // Load the bitmap resource.  We'll use LoadImage() since it'll scale the  <br>    // image to fit our surface, and maintain the color information in the <br>    // bitmap. <br>    hbm = (HBITMAP) LoadImage(GetModuleHandle(NULL), MAKEINTRESOURCE(lpstrResID), IMAGE_BITMAP, ddsd.dwWidth, ddsd.dwHeight, LR_CREATEDIBSECTION); <br>if (hbm == NULL) <br>        goto Exit; <br> <br> <br>    // If our surface is a FOURCC YUV format, we need to do a little work to convert <br>    // our RGB resource bitmap into the appropriate YUV format. <br>    if (ddsd.ddpfPixelFormat.dwFlags == DDPF_FOURCC) <br>    { <br>        if (!CopyBitmapToYUVSurface(lpdds, hbm)) <br>            goto Exit;         <br>    } <br>    else  //Looks like we're just using a standard RGB surface format, let GDI do the work. <br>    { <br>        // Create a DC and associate the bitmap with it. <br>        hdcImage = CreateCompatibleDC(NULL); <br>        SelectObject(hdcImage, hbm); <br>    <br>        ddrval = lpdds-&gt;GetDC(&amp;hdcSurf); <br>        if (FAILED(ddrval)) <br>            goto Exit; <br>     <br>        if (BitBlt(hdcSurf, 0, 0, ddsd.dwWidth, ddsd.dwHeight, hdcImage, 0, 0, SRCCOPY) == FALSE) <br>            goto Exit; <br>    } <br> <br>    bRetVal = TRUE; <br>     <br>Exit: <br>    if (hdcSurf) <br>        lpdds-&gt;ReleaseDC(hdcSurf); <br>    if (hdcImage) <br>        DeleteDC(hdcImage); <br>    if(hbm) <br>        DeleteObject(hbm); <br> <br>    return bRetVal; <br> <br>} <br> <br> <br>//**************************************************************************** <br>//* Function: EnumAttachedCallback <br>//*  <br>//* Description: <br>//*     Callback function for EnumAttachedSurfaces().  Used to recursively <br>//*     load each frame of the flying insect animation onto the appropriate <br>//*     overlay surface buffer. <br>//**************************************************************************** <br>HRESULT WINAPI EnumAttachedCallback(LPDIRECTDRAWSURFACE lpdds, LPDDSURFACEDESC lpddsd, LPVOID lpContext) <br>{ <br>    int     nResourceID = (int)lpContext; <br>    HRESULT hr = DDENUMRET_OK; <br> <br>    // Check to see if we've gone full circle through all surfaces and are now looking at the first one again. <br>    if (lpdds == g_lpddsOverlay) <br>        goto Exit; <br> <br>    if (!LoadImageOntoSurface(lpdds, MAKEINTRESOURCE(nResourceID))) <br>    { <br>        hr = DDENUMRET_CANCEL; <br>        goto Exit; <br>    } <br> <br>    nResourceID++; <br> <br>    lpdds-&gt;EnumAttachedSurfaces((LPVOID)nResourceID, EnumAttachedCallback);     <br> <br>Exit: <br>    lpdds-&gt;Release(); <br>    return DDENUMRET_OK; <br>} <br> <br>//**************************************************************************** <br>//* Function: DisplayOverlay <br>//* <br>//* Description: <br>//*     Displays the overlay on the primary surface <br>//**************************************************************************** <br>BOOL DisplayOverlay() <br>{ <br>    HRESULT         ddrval; <br>    RECT            rs, rd; <br>    DDOVERLAYFX     ovfx; <br>    DDCAPS          capsDrv; <br>    unsigned int    uStretchFactor1000; <br>    unsigned int    uDestSizeAlign, uSrcSizeAlign; <br>    DWORD           dwUpdateFlags; <br> <br>    if(!g_lpdd || !g_lpddsPrimary || !g_lpddsOverlay) <br>        return FALSE; <br> <br>    // Get driver capabilities <br>    INIT_DIRECTDRAW_STRUCT(capsDrv); <br>    ddrval = g_lpdd-&gt;GetCaps(&amp;capsDrv, NULL); <br>    if (FAILED(ddrval)) <br>        return FALSE; <br> <br>    // We need to check the minimum stretch.  Many display adpators require that <br>    // the overlay be stretched by a minimum amount.  The stretch factor will  <br>    // usually vary with the display mode (including changes in refresh rate). <br>    // The stretch factor is returned x1000. <br>    uStretchFactor1000 = capsDrv.dwMinOverlayStretch&gt;1000 ? capsDrv.dwMinOverlayStretch : 1000; <br> <br>    // Grab any alignment restrictions.  The DDCAPS struct contains a series of <br>    // alignment fields that are not clearly defined. They are intended for <br>    // overlay use.  It's important to observe alignment restrictions. <br>    // Many adapters with overlay capabilities require the overlay image be <br>    // located on 4 or even 8 byte boundaries, and have similar restrictions <br>    // on the overlay width (for both source and destination areas). <br>    uDestSizeAlign = capsDrv.dwAlignSizeDest; <br>    uSrcSizeAlign =  capsDrv.dwAlignSizeSrc; <br> <br>    // Set the flags we'll send to UpdateOverlay <br>    dwUpdateFlags = DDOVER_SHOW | DDOVER_DDFX; <br> <br>    // Does the overlay hardware support source color keying? <br>    // If so, we can hide the black background around the image. <br>    // This probably won't work with YUV formats <br>    if (capsDrv.dwCKeyCaps &amp; DDCKEYCAPS_SRCOVERLAY) <br>        dwUpdateFlags |= DDOVER_KEYSRCOVERRIDE; <br> <br>    // Create an overlay FX structure so we can specify a source color key. <br>    // This information is ignored if the DDOVER_SRCKEYOVERRIDE flag isn't set. <br>    INIT_DIRECTDRAW_STRUCT(ovfx); <br>    ovfx.dckSrcColorkey.dwColorSpaceLowValue=0; // Specify black as the color key <br>    ovfx.dckSrcColorkey.dwColorSpaceHighValue=0; <br> <br>    // Set up our Source Rect. This is the area of the overlay surface we <br>    // want to display.  If you want to display your entire surface and <br>    // happen to know for certain that your surface width meets any alignment <br>    // restrictions you can go ahead and pass NULL for the source rect in your <br>    // calls to UpdateOverlay().  Our surface width of 320 probably will meet <br>    // every alignment restriction, but just in case we'll create a source rect <br>    // and check for it. <br>    rs.left=0; rs.top=0; // position 0,0 is already position (boundary aligned) <br>    rs.right = 320; <br>    rs.bottom = 240; <br>    //Apply any size alignment restrictions if necessary. <br>    if (capsDrv.dwCaps &amp; DDCAPS_ALIGNSIZESRC &amp;&amp; uSrcSizeAlign) <br>        rs.right -= rs.right % uSrcSizeAlign; <br> <br>    // Set up our destination rect, indicating where we want the overlay to  <br>    // appear on the primary surface.  This is where we have to take into  <br>    // account any stretch factor which may be needed to ensure the overlay is <br>    // displayed.  Really only the destination width must be stretched for the <br>    // overlay hardware to work, but we stretch the height as well just to <br>    // maintain a proper aspect ratio. <br> <br> <br>    // Note: We use the source rect dimensions, not the surface dimensions in <br>    // case they differ. <br>    // UpdateOverlay will fail unless the minimum stretch value is observed. <br>     <br>    rd.left=0; rd.top=0;  <br>    rd.right  = (rs.right*uStretchFactor1000+999)/1000; // adding 999 takes care of integer truncation problems. <br>    rd.bottom = rs.bottom*uStretchFactor1000/1000; <br> <br>    // It's also important to observe any alignment restrictions on size and <br>    // position with respect to the destination rect. Tweak the destination  <br>    // width a bit more to get the size alignment correct (Be sure to round up <br>    // to keep any minimum stretch restrictions met). we'll assume the  <br>    // position 0,0 is already "position aligned". <br>    if (capsDrv.dwCaps &amp; DDCAPS_ALIGNSIZEDEST &amp;&amp; uDestSizeAlign) <br>        rd.right = (int)((rd.right+uDestSizeAlign-1)/uDestSizeAlign)*uDestSizeAlign; <br> <br>    // Make the call to UpdateOverlay() which actually displays the overlay on <br>    // the screen. <br>    ddrval = g_lpddsOverlay-&gt;UpdateOverlay(&amp;rs, g_lpddsPrimary, &amp;rd, dwUpdateFlags, &amp;ovfx); <br>    if(FAILED(ddrval)) <br>    { <br>        // Ok, the call to UpdateOVerlay() failed.  A likely cause is the <br>        // driver lied about the minimum stretch needed.  <br>        // Ideally we should try upping the destination size a bit, or <br>        // perhaps shrinking the source size so the destination stretch <br>        // is effectively higher.   For this sample, however, we'll just <br>        // bail! <br>        return FALSE; <br>    } <br> <br>    // Set the initial position and velocity for our overlay.  We'll actually <br>    // move the image around using a timer proc (see MoveOverlayTimerCallback <br>    // below). <br>    g_nOverlayXPos = 0; <br>    g_nOverlayYPos = 0; <br>    g_nOverlayXVel = RANDOM_VELOCITY(); <br>    g_nOverlayYVel = RANDOM_VELOCITY(); <br>    g_nOverlayWidth = rd.right - rd.left; <br>    g_nOverlayHeight = rd.bottom - rd.top; <br>    g_nOverlayFlipCounter=0; <br>     <br>    // Set the "destination position alignment" global so we won't have to <br>    // keep calling GetCaps() everytime we move the overlay surface. <br>    if (capsDrv.dwCaps &amp; DDCAPS_ALIGNBOUNDARYDEST) <br>        g_dwOverlayXPositionAlignment = capsDrv.dwAlignBoundaryDest; <br>    else  <br>        g_dwOverlayXPositionAlignment = 0; <br> <br>    return TRUE; <br>} <br> <br> <br>//**************************************************************************** <br>//* Function: AreOverlaysSupported <br>//* <br>//* Description: <br>//*     Determines whether or not the display hardware supports overlays.  If <br>//*     so, the function returns TRUE, otherwise FALSE. <br>//**************************************************************************** <br>BOOL AreOverlaysSupported() <br>{ <br>    DDCAPS  capsDrv; <br>    HRESULT ddrval; <br> <br>    // Get driver capabilities to determine Overlay support. <br>    INIT_DIRECTDRAW_STRUCT(capsDrv); <br>    ddrval = g_lpdd-&gt;GetCaps(&amp;capsDrv, NULL); <br>    if (FAILED(ddrval)) <br>        return FALSE; <br> <br>    // Does the driver support overlays in the current mode?  <br>    // (Currently the DirectDraw emulation layer does not support overlays. <br>    // Overlay related APIs will fail without hardware support).   <br>    if (!(capsDrv.dwCaps &amp; DDCAPS_OVERLAY)) <br>        return FALSE; <br> <br>    return TRUE; <br>} <br> <br> <br>//**************************************************************************** <br>//* Function: CreateOverlay <br>//* <br>//* Description: <br>//*     This is where we create the overlay surface, and put the flying insect  <br>//*     artwork on it. <br>//**************************************************************************** <br>BOOL CreateOverlay() <br>{ <br>    DDSURFACEDESC   ddsdOverlay; <br>    HRESULT         ddrval; <br>    int             i; <br> <br>    if (!g_lpdd || !g_lpddsPrimary) <br>        return FALSE; <br>     <br>    // It's currently not possible to query for pixel formats supported by the <br>    // overlay hardware (though GetFourCCCodes() usually provides a partial  <br>    // list).  Instead you need to call CreateSurface() to try a variety of   <br>    // formats till one works.   <br>    INIT_DIRECTDRAW_STRUCT(ddsdOverlay); <br>ddsdOverlay.ddsCaps.dwCaps=DDSCAPS_OVERLAY | DDSCAPS_FLIP | DDSCAPS_COMPLEX | DDSCAPS_VIDEOMEMORY; <br>    ddsdOverlay.dwFlags= DDSD_CAPS|DDSD_HEIGHT|DDSD_WIDTH|DDSD_BACKBUFFERCOUNT| DDSD_PIXELFORMAT; <br>ddsdOverlay.dwWidth=320; <br>ddsdOverlay.dwHeight=240; <br>    ddsdOverlay.dwBackBufferCount=2; <br> <br>    // Try to create an overlay surface using one of the pixel formats in our <br>    // global list. <br>    i=0; <br>    do  <br>    { <br>            ddsdOverlay.ddpfPixelFormat=g_ddpfOverlayFormats[i]; <br>            // Try to create the overlay surface <br>            ddrval = g_lpdd-&gt;CreateSurface(&amp;ddsdOverlay, &amp;g_lpddsOverlay, NULL); <br>    } while( FAILED(ddrval) &amp;&amp; (++i &lt; NUM_OVERLAY_FORMATS) ); <br> <br>    // If we failed to create an overlay surface, let's try again with a single <br>    // (non-flippable) buffer. <br>    if(FAILED(ddrval)) <br>    { <br>        // Just in case we're short on video memory or the hardware doesn't like flippable <br>        // overlay surfaces, let's make another pass using a single buffer. <br>        ddsdOverlay.dwBackBufferCount=0; <br>        ddsdOverlay.ddsCaps.dwCaps=DDSCAPS_OVERLAY | DDSCAPS_VIDEOMEMORY; <br>        ddsdOverlay.dwFlags= DDSD_CAPS|DDSD_HEIGHT|DDSD_WIDTH|DDSD_PIXELFORMAT; <br>        // Try to create the overlay surface <br>        ddrval = g_lpdd-&gt;CreateSurface(&amp;ddsdOverlay, &amp;g_lpddsOverlay, NULL); <br>        i=0; <br>        do  <br>        { <br>                ddsdOverlay.ddpfPixelFormat=g_ddpfOverlayFormats[i]; <br>                ddrval = g_lpdd-&gt;CreateSurface(&amp;ddsdOverlay, &amp;g_lpddsOverlay, NULL); <br>        } while( FAILED(ddrval) &amp;&amp; (++i &lt; NUM_OVERLAY_FORMATS) ); <br> <br>        // We just couldn't create an overlay surface.  Let's exit. <br>        if (FAILED(ddrval)) <br>            return FALSE; <br>    } <br> <br>    // Put the first bug image onto the first buffer of our complex surface. <br>    if (!LoadImageOntoSurface(g_lpddsOverlay, MAKEINTRESOURCE(IDB_BUGIMAGE1))) <br>        return FALSE; <br> <br>    // This will recursively get all back buffers and load them with the appropriate image. <br>    ddrval = g_lpddsOverlay-&gt;EnumAttachedSurfaces((LPVOID)IDB_BUGIMAGE2, EnumAttachedCallback); <br>    if(FAILED(ddrval)) <br>        return FALSE; <br> <br>    return TRUE; <br>} <br> <br> <br>//**************************************************************************** <br>//* Function: RestoreAllSurfaces <br>//**************************************************************************** <br>BOOL RestoreAllSurfaces() <br>{ <br>    HRESULT ddrval; <br> <br>    // It's possible that our surfaces were destroyed in a prior call to  <br>    // RestoreAllSurfaces().  If this happened we need to check for it,  <br>    // and perhaps try to recreate the surfaces. <br>    if (!g_lpddsPrimary) <br>    { <br>        ddrval = CreatePrimarySurface(); <br>        if (FAILED(ddrval)) <br>        { <br>            // We probably couldn't recreate the primary because someone has <br>            // exclusive mode. <br>            g_lpddsPrimary = NULL; <br>            return FALSE; <br>        } <br>    } <br> <br>    if(!g_lpddsOverlay) <br>        if (!CreateOverlay()) <br>            return FALSE; <br> <br>    // Try Restoring the primary surface. <br>    ddrval = g_lpddsPrimary-&gt;Restore(); <br>    if(FAILED(ddrval)) <br>    { <br>        // If we weren't able to restore the primary surface, It's probably  <br>        // because some one else has exclusive mode, or the display mode <br>        // has been changed such that our primary surface needs to be recreated <br>         <br>        // Check to see if the mode changed on us.  Is so, we'll need to recreate <br>        // all surfaces.  (Note: we could have watched for the WM_DISPLAYCHANGE  <br>        // message as well) <br>        if (ddrval == DDERR_WRONGMODE) <br>        { <br>            g_lpddsPrimary-&gt;Release(); <br>            DestroyOverlay(); <br>            g_lpddsPrimary = NULL; <br>            g_lpddsOverlay = NULL; <br>             <br>            return FALSE; <br>        } <br> <br>        else  <br>            return FALSE; <br>    } <br> <br>    // Try Restoring the overlay surface. <br>    ddrval = g_lpddsOverlay-&gt;Restore(); <br>    if (FAILED(ddrval)) <br>        return FALSE; <br> <br>    // Reload artwork onto overlay <br>    // Put the first bug image onto the first buffer of our complex surface. <br>    if ( !LoadImageOntoSurface(g_lpddsOverlay, MAKEINTRESOURCE(IDB_BUGIMAGE1)) ) <br>        return FALSE; <br> <br>    // This will recursively get all back buffers and load them with the appropriate image. <br>    ddrval = g_lpddsOverlay-&gt;EnumAttachedSurfaces((LPVOID)IDB_BUGIMAGE2, EnumAttachedCallback); <br>    if(FAILED(ddrval)) <br>        return FALSE; <br> <br>    // Redisplay overlay <br>    if(!DisplayOverlay()) <br>        return FALSE; <br> <br>    return TRUE; <br>} <br> <br> <br>//**************************************************************************** <br>//* Function: MoveOverlayTimerCallback <br>//* <br>//* Description: <br>//*     TimeProc callback for moving the overlay surface around <br>//**************************************************************************** <br>void CALLBACK MoveOverlayTimerCallback(HWND hwndUnused, UINT uUnused, UINT uUnused2, DWORD dwUnused) <br>{ <br>    HRESULT ddrval; <br>    DWORD   dwXAligned; <br> <br>    // Make sure the overlay really exists before we mess with it. <br>    if (!g_lpddsOverlay) <br>        if (!RestoreAllSurfaces()) <br>            return; <br> <br>    //Add the current velocity vectors to the position. <br>    g_nOverlayXPos += g_nOverlayXVel; <br>    g_nOverlayYPos += g_nOverlayYVel; <br> <br>    // Check to see if this new position puts the overlay off the edge of the screen. <br>    // SetOverlayPosition() won't like that. <br> <br>    // Have we gone off the left edge? <br>    if (g_nOverlayXPos &lt; 0) <br>    { <br>        g_nOverlayXPos = 0; <br>        g_nOverlayXVel = RANDOM_VELOCITY(); <br>    } <br> <br>    // Have we gone off the right edge? <br>    if ( (g_nOverlayXPos+g_nOverlayWidth) &gt;  GetSystemMetrics(SM_CXSCREEN)) <br>    { <br>        g_nOverlayXPos = GetSystemMetrics(SM_CXSCREEN)-g_nOverlayWidth; <br>        g_nOverlayXVel = -RANDOM_VELOCITY(); <br>    } <br> <br>    // Have we gone off the top edge? <br>    if (g_nOverlayYPos &lt; 0) <br>    { <br>        g_nOverlayYPos = 0; <br>        g_nOverlayYVel = RANDOM_VELOCITY(); <br>    } <br> <br>    // Have we gone off the bottom edge? <br>    if ( (g_nOverlayYPos+g_nOverlayHeight) &gt;  GetSystemMetrics(SM_CYSCREEN)) <br>    { <br>        g_nOverlayYPos = GetSystemMetrics(SM_CYSCREEN)-g_nOverlayHeight; <br>        g_nOverlayYVel = -RANDOM_VELOCITY(); <br>    } <br> <br>    // We need to check for any alignment restrictions on the X position <br>    if (g_dwOverlayXPositionAlignment) <br>        dwXAligned = g_nOverlayXPos - g_nOverlayXPos % g_dwOverlayXPositionAlignment; <br>    else <br>        dwXAligned = g_nOverlayXPos; <br> <br>    // Set the overlay to it's new position. <br>    ddrval = g_lpddsOverlay-&gt;SetOverlayPosition(dwXAligned, g_nOverlayYPos); <br>    if (ddrval == DDERR_SURFACELOST) <br>    { <br>        if (!RestoreAllSurfaces())  <br>            return; <br>    } <br> <br>    // Every fourth time this timer proc is called, lets flip the overlay surface. <br>    if (g_nOverlayFlipCounter++ &gt; 3)  <br>    { <br>        g_nOverlayFlipCounter = 0; // reset counter <br>        // Flip to the next image in the sequence.  This is gonna fail if we <br>        // our overlay surface only contains one buffer (see CreateOverlay.  <br>        // This is a possibility), but the failure should be benign. <br>        g_lpddsOverlay-&gt;Flip(NULL, DDFLIP_WAIT); <br>    } <br>} <br> <br>//**************************************************************************** <br>//* Function: DisplayError <br>//* Description: <br>//*    Displays an error message box. <br>//**************************************************************************** <br>int DisplayError(HINSTANCE hInst, LPSTR lpstrErr) <br>{ <br>    MSGBOXPARAMS mbp; <br>     <br>    mbp.cbSize = sizeof(mbp); <br>    mbp.hwndOwner=NULL; <br>    mbp.hInstance=hInst; </code></pre>
<p>
</p>
<pre><code>mbp.lpszText = lpstrErr; <br>    mbp.lpszCaption = "Mosquito Error!"; <br>    mbp.dwStyle = MB_OK | MB_USERICON; <br>    mbp.lpszIcon = MAKEINTRESOURCE(IDI_BUGICON); <br>    mbp.dwContextHelpId = NULL; <br>    mbp.lpfnMsgBoxCallback = NULL; <br>    mbp.dwLanguageId = NULL; <br> <br>    return MessageBoxIndirect(&amp;mbp); <br>} <br> <br>//**************************************************************************** <br>//* Function: MainDialogProc <br>//**************************************************************************** <br>LRESULT CALLBACK MainDialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>    int uTimer=0; <br> <br>switch (message)  <br>    { <br>        case WM_INITDIALOG: <br>            // Create a timer to periodically move the overlay image around. <br>            uTimer = SetTimer(NULL, 0, 50, (TIMERPROC)MoveOverlayTimerCallback); <br>            break; <br> <br>case WM_COMMAND: <br>            // Check to see if the "Quit" button was clicked. <br>            if ( IDQUIT == LOWORD(wParam)) <br>            { <br>                KillTimer(NULL, uTimer); <br>    EndDialog(hDlg, TRUE); <br>return (TRUE); <br>} <br>break; <br> <br>        case WM_CLOSE: <br>            KillTimer(NULL, uTimer); <br>    EndDialog(hDlg, TRUE); <br>return (TRUE); <br>} <br> <br>    return FALSE; <br>} <br> <br> <br>//**************************************************************************** <br>//* Function: WinMain(HANDLE, HANDLE, LPSTR, int) <br>//* <br>//* Description:  <br>//*     Entry point for the application.  Since we use a simple dialog for  <br>//*     user interaction we don't need to pump messages. <br>//* <br>//**************************************************************************** <br>int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) <br>{ <br> <br>    // Call DirectDraw Initialization function <br>    if (!InitDirectDraw()) <br>        return FALSE; <br> <br> <br>    if (!AreOverlaysSupported()) <br>    { <br>        // Display an error dialog if the hardware doesn't support overlays. <br>        DisplayError(hInstance, NO_OVERLAY_HARDWARE); <br>        return FALSE; <br>    } <br> <br>    if (!CreateOverlay()) <br>    { <br>        // display an error dialog if we couldn't create the overlay. <br>        DisplayError(hInstance, UNABLE_TO_CREATE_OVERLAY); <br>        return FALSE; <br>    } <br> <br>    if (!DisplayOverlay()) <br>    { <br>        // Display an error dialog if we couldn't display the overlay. <br>        DisplayError(hInstance, UNABLE_TO_DISPLAY_OVERLAY); <br>        return FALSE; <br>    } <br> <br>    // Display our "Quit" dialog box.  As part of it's initialization it'll get the overlay going. <br>    DialogBox(hInstance, MAKEINTRESOURCE(IDD_QUITDIALOG), NULL, (DLGPROC)MainDialogProc); <br> <br>    DestroyOverlay(); <br>    FreeDirectDraw(); <br> <br>    lpCmdLine; // This will prevent 'unused formal parameter' warnings <br> <br>    return TRUE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
