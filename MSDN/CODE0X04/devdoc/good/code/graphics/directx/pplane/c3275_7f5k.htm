<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>D3DUTILS.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3278"></a>D3DUTILS.H</h2>
<pre><code>#ifndef D3DUTILS_H <br>#define D3DUTILS_H <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DUtils.h <br>** Purpose: Various D3D utility functions <br>** Notes: <br>** <br>** Copyright (c) 1995 - 1997 by Microsoft, all rights reserved <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>#define D3D_OVERLOADS <br>#include &lt;d3d.h&gt; <br>#include &lt;d3dtypes.h&gt; <br> <br>extern const float pi; <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Function Prototypes <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>// generic simple matrix routines <br>extern D3DMATRIX ZeroMatrix(void); <br>extern D3DMATRIX IdentityMatrix(void); <br> <br>extern D3DMATRIX ProjectionMatrix(const float near_plane, const float far_plane, const float fov); <br>extern D3DMATRIX ViewMatrix(const D3DVECTOR &amp; from, const D3DVECTOR &amp; at,  <br>const D3DVECTOR &amp; up, const float roll=0.0f); <br> <br>extern D3DMATRIX RotateXMatrix(const float rads); <br>extern D3DMATRIX RotateYMatrix(const float rads); <br>extern D3DMATRIX RotateZMatrix(const float rads); <br>extern D3DMATRIX TranslateMatrix(const float dx, const float dy, const float dz); <br>extern D3DMATRIX TranslateMatrix(const D3DVECTOR &amp; v); <br>extern D3DMATRIX ScaleMatrix(const float size); <br>extern D3DMATRIX ScaleMatrix(const float a, const float b, const float c); <br>extern D3DMATRIX ScaleMatrix(const D3DVECTOR &amp; v); <br> <br>extern D3DMATRIX MatrixMult(const D3DMATRIX &amp; a, const D3DMATRIX &amp; b); <br>extern D3DMATRIX MatrixInverse(const D3DMATRIX &amp; m); <br>extern D3DMATRIX MatrixTranspose(const D3DMATRIX &amp; m); <br> <br>extern D3DVECTOR TransformVector(const D3DVECTOR &amp; v, const D3DMATRIX &amp; m); <br>extern D3DVECTOR TransformNormal(const D3DVECTOR &amp; v, const D3DMATRIX &amp; m); <br> <br>// Other stuff <br>extern float rnd(void); <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Classes <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**Class:Light <br>**Purpose: <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>class Light { <br>protected: <br>public: <br>D3DLIGHT2light;// structure defining the light <br>LPDIRECT3DLIGHTlpD3DLight;// object pointer for the light <br>intchanged; <br>public: <br>Light(LPDIRECT3D2 lpD3D); <br>~Light(); <br> <br>HRESULTAddToViewport(LPDIRECT3DVIEWPORT2 lpView); <br>HRESULTRemoveFromViewport(LPDIRECT3DVIEWPORT2 lpView); <br>HRESULTSet(void); <br> <br>voidSetColor(const D3DVECTOR&amp; color); <br>D3DVECTORGetColor(void) const; <br>voidSetPosition(const D3DVECTOR&amp; position); <br>D3DVECTORGetPosition(void) const; <br>voidSetDirection(const D3DVECTOR&amp; direction); <br>D3DVECTORGetDirection(void) const; <br>voidSetAttenuation(const D3DVECTOR&amp; attenuation); <br>D3DVECTORGetAttenuation(void) const; <br>voidSetRange(const float range); <br>floatGetRange(void) const; <br>voidSetFalloff(const float falloff); <br>floatGetFalloff(void) const; <br>voidSetUmbra(const float falloff); <br>floatGetUmbra(void) const; <br>voidSetPenumbra(const float falloff); <br>floatGetPenumbra(void) const; <br>voidSetFlags(const DWORD flags); <br>DWORDGetFlags(void) const; <br>}; // End Light <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**Class:PointLight <br>**Purpose: <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>class PointLight : public Light { <br>public: <br>PointLight(LPDIRECT3D2 lpD3D,  <br>const D3DVECTOR &amp; color,  <br>const D3DVECTOR &amp; position); <br>}; // End PointLight <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**Class:SpotLight <br>**Purpose: <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>class SpotLight : public Light { <br>public: <br>SpotLight(LPDIRECT3D2 lpD3D,  <br>const D3DVECTOR&amp; color,  <br>const D3DVECTOR&amp; position,  <br>const D3DVECTOR&amp; direction,  <br>const float umbra_angle,  <br>const float penumbra_angle); <br>}; // End SpotLight <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**Class:DirectionalLight <br>**Purpose: <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>class DirectionalLight : public Light { <br>public: <br>DirectionalLight(LPDIRECT3D2 lpD3D,  <br>const D3DVECTOR&amp; color, const D3DVECTOR&amp; direction); <br>}; <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**Class:ParallelPointLight <br>**Purpose: <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>class ParallelPointLight : public Light { <br>public: <br>ParallelPointLight(LPDIRECT3D2 lpD3D, const D3DVECTOR&amp; color, const D3DVECTOR&amp; position); <br>}; // End ParallelPointLight <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**Class:Material <br>**Purpose: <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>class Material  <br>{ <br>protected: <br>D3DMATERIALMat; <br>    D3DMATERIALHANDLEhMat; <br>LPDIRECT3DMATERIAL2 lpMat; <br>intchanged; <br>public: <br>Material(LPDIRECT3D2 lpD3D, LPDIRECT3DDEVICE2 lpDev); <br>~Material(); <br> <br>HRESULTSetAsCurrent(LPDIRECT3DDEVICE2 lpDev); <br>HRESULTSetAsBackground(LPDIRECT3DVIEWPORT2 lpView); <br>HRESULTSet(void); <br> <br>voidSetDiffuse(const D3DVECTOR&amp; color); <br>D3DVECTORGetDiffuse(void) const; <br>voidSetAlpha(const float&amp; alpha); <br>floatGetAlpha(void) const; <br>voidSetAmbient(const D3DVECTOR&amp; color); <br>D3DVECTORGetAmbient(void) const; <br>voidSetEmissive(const D3DVECTOR&amp; color); <br>D3DVECTORGetEmissive(void) const; <br>voidSetSpecular(const D3DVECTOR&amp; color); <br>D3DVECTORGetSpecular(void) const; <br>voidSetPower(const D3DVALUE&amp; power); <br>D3DVALUEGetPower(void) const; <br>voidSetRampSize(const DWORD&amp; ramp); <br>DWORDGetRampSize(void) const; <br>voidSetTextureHandle(const D3DTEXTUREHANDLE&amp; hTexture); <br>D3DTEXTUREHANDLEGetTextureHandle(void); <br>}; // End Material <br> <br> <br>// <br>// include the inline functions for the classes <br>// <br>#include "d3dutils.inl" <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**End of File <br>**----------------------------------------------------------------------------- <br>*/ <br>#endif // D3DUTILS_H <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
