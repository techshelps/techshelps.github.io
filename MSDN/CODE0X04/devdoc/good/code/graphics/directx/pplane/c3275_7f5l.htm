<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>D3DWIN.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3279"></a>D3DWIN.CPP</h2>
<pre><code>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       D3DWin.cpp <br>**  Purpose:    Shows how to set up a windowed D3D framework <br>**  Notes: <br>** <br>**Basic Initialization proceeds as follows: <br>** <br>**1.  Enumerate all Driver, modes, D3D devices (see DrvMgr.cpp for details) <br>**2.  Choose a starting driver, mode, D3D device <br>**- default driver = primary display driver (lpGuidDD = NULL) <br>**- default mode   = current desktop <br>**- default device = D3D device compatible with desktop mode <br>**3.  Validate driver, mode, D3D device <br>**4.  Create interfaces (from DD driver) <br>**  5.  Set window (from associated window handle) <br>**  6.  Create DD/D3D interfaces (lpDD, lpDD2, lpD3D) <br>**  7.  Create Primary surface (primary palette, if necessary) <br>**- Attach a clipper to primary surface <br>**  8.  Create Render surface  <br>**- Render surface (and associated Z-buffer) <br>**- D3D Device  <br>**- D3D Viewport <br>** <br>**  After initialization is complete, we have the <br>**following objects necessary for rendering: <br>** <br>**lpDD2 - DirectDraw interface, used for creating texture surfaces <br>**lpD3D - Direct3D interface, used for creating materials, lights, viewports <br>**lpD3DDevice - D3D device (current material, current viewport, etc.) <br>**lpViewport - current viewport <br>**lpPrimary  - front buffer <br>**lpRender   - render target <br>** <br>**  Copyright (c) 1995 - 1997 by Microsoft, all rights reserved <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Includes <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>#include "D3DWin.h" <br>#include "WinProc.h" <br>#include "D3DScene.h" <br>#include "Debug.h" <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**D3DWindow Methods <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::D3DWindow <br>** Purpose: Default Constructor <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>D3DWindow::D3DWindow (void) <br>{ <br>    ZeroMemory (this, sizeof(D3DWindow)); <br>    this-&gt;dwSize = sizeof(D3DWindow); <br> <br>// Default to creating a z-buffer <br>createZBufferOn (); <br>} // End D3DWindow::D3DWindow () <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::~D3DWindow <br>** Purpose: Destructor <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>D3DWindow::~D3DWindow (void) <br>{ <br>// Destroy all objects <br>    Fini (); <br> <br>// Mark all other pointers as invalid <br>// In case user tries to reuse this object incorrectly <br>lpCurrDriver = NULL; <br>lpCurrMode = NULL; <br>lpCurrDevice = NULL; <br>hWindow = NULL; <br>lpd3dScene = NULL; <br> <br>} // End D3DWindow::~D3DWindow <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::Create <br>** Purpose: Creates a D3DWindow  <br>** <br>** Basic Algorithm: <br>**- Validate parameters <br>**- Choose (and validate choices) for driver, mode, device <br>**- Create Interfaces <br>**- Set Window <br>**- Create Primary surface (and palette) <br>**- Create Render surface (and D3D device) <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::Create ( <br>HWND   hWnd,/* In:  Window */ <br>LPGUID lpGuidDD,/* In:  Requested DirectDraw Device */ <br>DWORD  dwW,/* In:Requested Mode */ <br>DWORD  dwH, <br>DWORD  dwBPP, <br>DWORD  dwRefresh, <br>LPGUID lpGuidD3D,/* In:  Requested D3D device */ <br>BOOL   fUseZBuffer, /* In:Create Z-buffer */ <br>LPRECT lprSurf)/* In:  requested surface size (NULL =&gt; use client area) */ <br>{ <br>    HRESULT         hResult; <br> <br>    // Check parameters <br>if ((! hWnd) || (! IsWindow (hWnd))) <br>{ <br>REPORTERR (DDERR_INVALIDPARAMS); <br>return DDERR_INVALIDPARAMS; <br>} <br> <br>// Set Current Window <br>hWindow = hWnd; <br> <br>    // Set Use Z-Buffer On/Off <br>    if (fUseZBuffer) <br>        createZBufferOn (); <br>    else <br>        createZBufferOff (); <br> <br>    // Choose Default Driver, Mode, device  <br>    hResult = ChooseDriverDefaults (lpGuidDD, <br>dwW, dwH, dwBPP, dwRefresh, <br>lpGuidD3D, <br>FALSE, <br>&amp;lpCurrDriver, <br>&amp;lpCurrMode, <br>&amp;lpCurrDevice); <br>    if (FAILED (hResult)) <br>        return hResult; <br>     <br>    // Create DD/D3D Interface objects <br>    hResult = InitInterfaces (); <br>    if (FAILED (hResult)) <br>        return hResult; <br> <br>// Attach window to DD interface <br>hResult = InitWindow (); <br>if (FAILED (hResult)) <br>goto lblCLEANUP; <br> <br>    // Create Primary Surface (and palette) <br>    hResult = InitPrimary (); <br>    if (FAILED (hResult)) <br>        goto lblCLEANUP; <br> <br>// Get initial surface size <br>if (lprSurf) <br>rSurf = *lprSurf; <br>else <br>GetClientRect (hWindow, &amp;rSurf); <br> <br>// Create the Render Surface (and D3D Device) <br>    hResult = InitRender (); <br>    if (FAILED (hResult)) <br>        goto lblCLEANUP; <br> <br>// Notify the window of a successful initialization <br>SendMessage (hWindow, D3DWIN_INIT, 0, (LPARAM)(void *)this); <br> <br>    // Success <br>    return DD_OK; <br> <br>lblCLEANUP: <br>    // Cleanup <br>    Fini (); <br> <br>    return hResult; <br>} // End D3DWindow::Create <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::Init <br>** Purpose:  <br>** <br>** Basic Algorithm: <br>**- Validate driver, mode, device <br>**- Create Interfaces <br>**- Attach Window <br>**- Create Primary surface (and palette) <br>**- Create Render surface (and D3D device) <br>** <br>** Notes: <br>**1.  Assumes that a valid window handle has already <br>**been associated with this D3DWindow <br>**2.  Assumes that driver, mode, device already choosen <br>**- however if not, reasonable defaults will be choosen <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::Init (void) <br>{ <br>    HRESULT         hResult; <br> <br>    // Check parameters <br>if ((! hWindow) || (! IsWindow (hWindow))) <br>{ <br>// Error, we absolutely need a valid window <br>REPORTERR (DDERR_INVALIDPARAMS); <br>return DDERR_INVALIDPARAMS; <br>} <br> <br>    // Validate Curr Driver, mode, device <br>hResult = ValidateDefaults (); <br>if (FAILED (hResult)) <br>return hResult; <br> <br>    // Create DD/D3D Interface objects <br>    hResult = InitInterfaces (); <br>    if (FAILED (hResult)) <br>goto lblCLEANUP; <br> <br>// Attach the window to the DD interface <br>hResult = InitWindow (); <br>if (FAILED (hResult)) <br>goto lblCLEANUP; <br> <br>    // Create Primary Surface (and palette) <br>    hResult = InitPrimary (); <br>    if (FAILED (hResult)) <br>        goto lblCLEANUP; <br> <br>// Create Render surface (and D3D device) <br>    hResult = InitRender (); <br>    if (FAILED (hResult)) <br>        goto lblCLEANUP; <br> <br>// Notify the window of a successful initialization <br>SendMessage (hWindow, D3DWIN_INIT, 0, (LPARAM)(void *)this); <br> <br>    // Success <br>    return DD_OK; <br> <br>lblCLEANUP: <br>    // Cleanup <br>    Fini (); <br>    return hResult; <br>} // End D3DWindow::Init <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::Fini <br>** Purpose: Destroys a D3DWindow <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::Fini (void) <br>{ <br>// Notify the window that we are cleaning up <br>SendMessage (hWindow, D3DWIN_FINI, 0, (LPARAM)(void *)this); <br> <br>// Cleanup <br>    FiniRender (); <br>    FiniPrimary (); <br>//FiniWindow (); <br>    FiniInterfaces (); <br> <br>// Success <br>return DD_OK; <br>} // End D3DWindow::Fini <br> <br> <br>   <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::ValidateDefaults <br>** Purpose: Verify's current driver, mode, and device <br>** Notes:    <br>** <br>**1.  Rather than fail completely, this will pick new defaults <br>**      if the current defaults don't work. <br>** <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::ValidateDefaults (void) <br>{ <br>LPGUIDlpGuidDD, lpGuidD3D; <br>HRESULThResult; <br>    LPDDDrvInfolpDrvNew; <br>LPDDModeInfolpModeNew; <br>LPD3DDevInfolpDevNew; <br> <br>// Initialize Driver Manager, if necessary <br>if (! DDDrvMgr::isInitialized ()) <br>{ <br>hResult = DDDrvMgr::Init (); <br>if (FAILED (hResult)) <br>return DDERR_INVALIDPARAMS; <br>} <br>     <br>    // Get DD Guid <br>if (lpCurrDriver) <br>lpGuidDD = lpCurrDriver-&gt;GetGuid (); <br>else <br>lpGuidDD = NULL; <br> <br>// Get D3D Guid <br>if (lpCurrDevice) <br>lpGuidD3D = &amp;(lpCurrDevice-&gt;guid); <br>else <br>lpGuidD3D = NULL; <br> <br>// Get Driver corresponding to DD Guid <br>    lpDrvNew = ValidateDriver (lpGuidDD); <br>if (! lpDrvNew) <br>    { <br>        // Error, invalid DD Guid <br>REPORTERR (DDERR_INVALIDPARAMS); <br>        return DDERR_INVALIDPARAMS; <br>    } <br> <br>// Get Desktop mode and compatible D3D device <br>if (! GetDesktopMode (lpDrvNew, lpGuidD3D, &amp;lpModeNew, &amp;lpDevNew)) <br>{ <br>REPORTERR (DDERR_GENERIC); <br>return DDERR_GENERIC; <br>} <br> <br>// Note:  Instead of complaining let's go ahead <br>//  and use the new defaults <br>// Save new defaults <br>lpCurrDriver = lpDrvNew; <br>lpCurrMode = lpModeNew; <br>lpCurrDevice = lpDevNew; <br> <br>    // Success <br>    return DD_OK; <br>} // End D3DWindow::ValidateDefaults <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::CreateInterfaces <br>** Purpose: Creates DD/D3D interfaces from specified Guid <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::CreateInterfaces (LPGUID lpDDGuid) <br>{ <br>LPDDDrvInfo lpDrvNew; <br>HRESULThResult; <br> <br>// Verify Guid <br>lpDrvNew = ValidateDriver (lpDDGuid); <br>if (! lpDrvNew) <br>{ <br>REPORTERR (DDERR_GENERIC); <br>return DDERR_GENERIC; <br>} <br> <br>lpCurrDriver = lpDrvNew; <br> <br>hResult = D3DWindow::InitInterfaces (); <br>if (FAILED (hResult)) <br>return hResult; <br> <br>// Success <br>return DD_OK; <br>} // End D3DWindow::CreateInterfaces <br> <br>   <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::InitInterfaces <br>** Purpose: Creates DD/D3D interfaces <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::InitInterfaces (void) <br>{ <br>    HRESULT         hResult; <br>    LPGUID          lpGuid; <br> <br>    // Do we have a current DD Driver <br>    if (! lpCurrDriver) <br>    { <br>// Try to grab the Primary DD driver instead <br>lpCurrDriver = ValidateDriver (NULL); <br>if (! lpCurrDriver) <br>{ <br>REPORTERR (DDERR_GENERIC); <br>return DDERR_GENERIC; <br>} <br>    } <br> <br>    // Get DD Guid <br>    lpGuid = lpCurrDriver-&gt;GetGuid (); <br>     <br>    // Create DD interface <br>    hResult = DirectDrawCreate (lpGuid, &amp;lpDD, NULL); <br>    if (FAILED (hResult)) <br>    { <br>        // Error <br>REPORTERR (hResult); <br>goto lblERROR; <br>    } <br> <br>    // Get DD2 interface <br>    hResult = lpDD-&gt;QueryInterface ((REFIID)IID_IDirectDraw2, (void **)&amp;lpDD2); <br>    if (FAILED (hResult)) <br>    { <br>        // Error <br>REPORTERR (hResult); <br>        goto lblERROR; <br>    } <br> <br>    // Get D3D interface <br>    hResult = lpDD2-&gt;QueryInterface ((REFIID)IID_IDirect3D2, (void **)&amp;lpD3D); <br>    if (FAILED (hResult)) <br>    { <br>        // Error <br>REPORTERR (hResult); <br>        goto lblERROR; <br>    } <br> <br>// Mark this stage as done <br>turnValidInterfaceOn (); <br> <br>    // Success <br>    return DD_OK; <br> <br>lblERROR: <br>    // Failure <br>    FiniInterfaces (); <br> <br>    return hResult; <br>} // End InitInterfaces <br> <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::FiniInterfaces <br>** Purpose: Destroys DD/D3D interfaces <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::FiniInterfaces (void) <br>{ <br>// Mark this stage as invalid <br>turnValidInterfaceOff (); <br> <br>    // Release Direct3D Interface <br>    if (lpD3D) <br>    { <br>        lpD3D-&gt;Release (); <br>        lpD3D = NULL; <br>    } <br> <br>    // Release DirectDraw2 Interface <br>    if (lpDD2) <br>    { <br>        lpDD2-&gt;Release (); <br>        lpDD2 = NULL; <br>    } <br> <br>    // Release DirectDraw Interface <br>    if (lpDD) <br>    { <br>        lpDD-&gt;Release (); <br>        lpDD = NULL; <br>    } <br> <br>// Success <br>return DD_OK; <br>} // End D3DWindow::FiniInterfaces <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**Name:D3DWindow::InitWindow <br>**Purpose:Attaches Window to Direct Draw Interface <br>**Notes:Assumes window handle already associated with this D3DWindow. <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::InitWindow (void) <br>{ <br>HRESULT hResult; <br>DWORDdwFlags; <br> <br>// Check Initialization <br>if ((! hWindow) || (! IsWindow (hWindow))) <br>{ <br>// Error, we have to have an associated window to continue <br>REPORTERR (DDERR_GENERIC); <br>return DDERR_GENERIC; <br>} <br> <br>    // Get Cooperative Flags <br>    dwFlags = DDSCL_NORMAL; <br> <br>    // Set Cooperative Level <br>    hResult = lpDD2-&gt;SetCooperativeLevel (hWindow, dwFlags); <br>    if (FAILED (hResult)) <br>    { <br>        // Error <br>        REPORTERR (hResult); <br>return hResult; <br>    } <br> <br>// Success <br>return DD_OK; <br>} // End D3DWindow::InitWindow <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::FiniWindow <br>** Purpose: Cleanups window <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::FiniWindow (void) <br>{ <br>// Currently does nothing <br> <br>// Success <br>return DD_OK; <br>} // End D3DWindow::FiniWindow <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**Name:    D3DWindow::InitPrimary <br>**Purpose: Creates a primary surface <br>** <br>**Basic Algorithm: <br>**1.  Create primary surface (from desktop mode) <br>**2.  Create and attach a clipper object <br>**3.  Create and attach a palette object, if desktop is palettized <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::InitPrimary (void) <br>{ <br>    HRESULThResult; <br>    DDSURFACEDESCddsd; <br>    LPDIRECTDRAWCLIPPER lpddcClipper = NULL;     <br> <br>    // Check Initialization <br>    if ((! lpCurrMode) || (! lpDD2)) <br>    { <br>        // Error <br>REPORTERR (DDERR_GENERIC); <br>        return DDERR_GENERIC; <br>    } <br> <br>//  <br>// Step 1.  Create Primary Surface <br>// <br> <br>// Note:  No need to fill in width, height, etc. <br>//        They system knows how to do it automatically <br>//  for a primary surface <br>    ddsd.dwSize         = sizeof(ddsd); <br>    ddsd.dwFlags        = DDSD_CAPS; <br>    ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE; <br> <br>// Create Primary surface <br>    hResult = lpDD2-&gt;CreateSurface (&amp;ddsd, &amp;lpddsPrimary, NULL); <br>    if (FAILED (hResult)) <br>    { <br>        // Error <br>        REPORTERR (hResult); <br>        return hResult; <br>    } <br> <br> <br>//  <br>// Step 2.   Create and attach clipper <br>// <br>// Note:This needs to be done to prevent drawing outside <br>//of the windows current client area <br> <br>// Create Clipper object <br>    hResult = DirectDrawCreateClipper (0L, &amp;lpddcClipper, 0); <br>    if (FAILED (hResult)) <br>    { <br>        // Error <br>        REPORTERR (hResult); <br>goto lblCLEANUP; <br>    } <br>     <br>// Attach window to clipper <br>    hResult = lpddcClipper-&gt;SetHWnd (0L, hWindow); <br>    if (FAILED (hResult)) <br>    { <br>        // Error <br>        REPORTERR (hResult); <br>goto lblCLEANUP; <br>    } <br> <br>// Attach clipper to primary surface <br>    hResult = lpddsPrimary-&gt;SetClipper (lpddcClipper); <br>    if (FAILED (hResult)) <br>    { <br>        // Error <br>        REPORTERR (hResult); <br>goto lblCLEANUP; <br>    } <br> <br>    // Go ahead and release the clipper interface,  <br>    // we don't need it anymore and it will be <br>    // destroyed automatically with the surface <br>    lpddcClipper-&gt;Release (); <br> <br>// Create and attach palette, if necessary <br>hResult = InitPalette (); <br>if (FAILED (hResult)) <br>goto lblCLEANUP; <br> <br>// Mark as Valid <br>turnValidPrimaryOn (); <br> <br>    // Success <br>    return DD_OK; <br> <br>lblCLEANUP: <br>// Failure <br> <br>// Cleanup before leaving <br>if (lpddcClipper) <br>lpddcClipper-&gt;Release (); <br> <br>FiniPrimary (); <br> <br>return hResult; <br>} // End D3DWindow::InitPrimary <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::FiniPrimary <br>** Purpose: Destroys the Primary Surface <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::FiniPrimary (void) <br>{ <br>// Mark as Invalid <br>turnValidPrimaryOff (); <br> <br>// Cleanup palette <br>FiniPalette (); <br> <br>    // Release Primary Surface Object <br>    if (lpddsPrimary) <br>    { <br>        lpddsPrimary-&gt;Release (); <br>        lpddsPrimary = NULL; <br>    } <br> <br>// Success <br>return DD_OK; <br>} // End D3DWindow::FiniPrimary <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::InitPalette <br>** Purpose: Creates a primary palette if necessary <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::InitPalette () <br>{ <br>    HRESULT             hResult; <br>    HDC                 hdc; <br>    DWORD               ii; <br>    PALETTEENTRY        pePalette[256]; <br>    DWORD               cPal; <br>    DWORD               cbSize; <br>    DWORD               dwFlags; <br>    DDSURFACEDESC       ddsd; <br> <br>    // Destroy old palette <br>    FiniPalette (); <br> <br>    // Make sure we are properly intialized  <br>    // for this to work <br>    if ((! lpDD2) || (! lpddsPrimary)) <br>    { <br>        // Error <br>REPORTERR (DDERR_GENERIC); <br>        return DDERR_GENERIC; <br>    } <br> <br>    // Get primary surface caps <br>    ZeroMemory(&amp;ddsd, sizeof(ddsd)); <br>    ddsd.dwSize = sizeof(ddsd); <br>    hResult = lpddsPrimary-&gt;GetSurfaceDesc(&amp;ddsd); <br>    if (FAILED (hResult)) <br>    { <br>        // Error <br>        REPORTERR (hResult); <br>        return hResult; <br>    } <br> <br>    // Make sure it is a palettized surface <br>    if (! isPalettized (&amp;(ddsd.ddpfPixelFormat))) <br>    { <br>        // Success, primary isn't palettized <br>// So we don't need to create a palette <br>        return DD_OK; <br>    } <br> <br>    // Create and save System palette <br>    hdc = GetDC (NULL); <br>    cPal = GetDeviceCaps (hdc, SIZEPALETTE); <br>    if (cPal) <br>    { <br>        if (cPal &gt; 256) <br>            cPal = 256; <br> <br>        // Get memory for palette entries <br>        lppePalette = new PALETTEENTRY[cPal]; <br>        if (! lppePalette) <br>        { <br>            // Error, not enough memory <br>ReleaseDC (NULL, hdc); <br> <br>hResult = DDERR_OUTOFMEMORY; <br>REPORTERR (hResult); <br>goto lblCLEANUP; <br>        } <br> <br>        // Save system palette <br>        GetSystemPaletteEntries (hdc, 0, cPal, lppePalette); <br> <br>        // Copy system palette to temporary values <br>        cbSize = cPal * sizeof (PALETTEENTRY); <br>        CopyMemory (pePalette, lppePalette, cbSize); <br>    } <br>ReleaseDC (NULL, hdc); <br> <br>    if (ddsd.ddpfPixelFormat.dwFlags &amp; DDPF_PALETTEINDEXED1) <br>    { <br>        dwFlags = DDPCAPS_1BIT; <br> <br>        // Only 2 palette entries, we need them all <br>        for (ii = 0; ii &lt; 2; ii++) <br>            pePalette[ii].peFlags = D3DPAL_FREE | PC_RESERVED; <br> <br>    } <br>    else if (ddsd.ddpfPixelFormat.dwFlags &amp; DDPF_PALETTEINDEXED2) <br>    { <br>        // Only 4 palette entries, we need them all <br>        for (ii = 0; ii &lt; 4; ii++) <br>            pePalette[ii].peFlags = D3DPAL_FREE | PC_RESERVED; <br> <br>        dwFlags = DDPCAPS_2BIT; <br>    } <br>    else if (ddsd.ddpfPixelFormat.dwFlags &amp; DDPF_PALETTEINDEXED4) <br>    { <br>        // Only 16 palette entries, we will save black and white <br>        // and keep the rest for ourselves. <br> <br>        pePalette[0].peFlags = D3DPAL_READONLY; <br>        pePalette[15].peFlags = D3DPAL_READONLY; <br> <br>        for (ii = 1; ii &lt; 15; ii++) <br>            pePalette[ii].peFlags = D3DPAL_FREE | PC_RESERVED; <br> <br>        dwFlags = DDPCAPS_4BIT; <br>    } <br>    else if (ddsd.ddpfPixelFormat.dwFlags &amp; DDPF_PALETTEINDEXED8) <br>    { <br>        // 256 palette entries, we can afford to be nice <br>        // and save the first 10 and last 10 palette entries <br>        // for system use  <br>        for (ii = 0; ii &lt; 10; ii++) <br>        { <br>            pePalette[ii].peFlags = D3DPAL_READONLY; <br>            pePalette[246+ii].peFlags = D3DPAL_READONLY; <br>        } <br> <br>        for (ii = 10; ii &lt; 246; ii++) <br>            pePalette[ii].peFlags = D3DPAL_FREE | PC_RESERVED; <br> <br>        dwFlags = DDPCAPS_8BIT;         <br>    } <br>    else <br>    { <br>        // Error, programming (unknown palette type) <br>hResult = DDERR_GENERIC; <br>REPORTERR (hResult); <br>goto lblCLEANUP; <br>    } <br> <br>    // Create Primary Palette <br>    hResult = lpDD2-&gt;CreatePalette (dwFlags, <br>                                    pePalette, <br>                                    &amp;lpddpPalette, <br>                                    NULL); <br>    if (FAILED (hResult)) <br>    { <br>        // Error <br>        REPORTERR (hResult); <br>        goto lblCLEANUP; <br>    } <br> <br>    // Attach palette to primary surface <br>    hResult = lpddsPrimary-&gt;SetPalette (lpddpPalette); <br>    if (FAILED (hResult)) <br>    { <br>        // Error <br>        REPORTERR (hResult); <br>        goto lblCLEANUP; <br>    } <br> <br>    // Success <br>    return DD_OK; <br> <br>lblCLEANUP: <br>// Cleanup before leaving <br>    FiniPalette (); <br> <br>// Failure <br>return hResult; <br>} // D3DWindow::InitPalette <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::FiniPalette <br>** Purpose: Destroys primary palette <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::FiniPalette (void) <br>{ <br>    // Note:  Should we Detach Palette object from surfaces <br>    // No way to do this that I know of... <br>     <br>    // Cleanup up DD Palette object <br>    if (lpddpPalette) <br>    { <br>        lpddpPalette-&gt;Release (); <br>        lpddpPalette = NULL; <br>    } <br> <br>    // Cleanup System Palette <br>    if (lppePalette) <br>    { <br>        // Note:  Should we try and restore system palette here ?!? <br> <br>        // Destroy system palette <br>        delete [] lppePalette; <br>        lppePalette = NULL; <br>    } <br> <br>// Success <br>return DD_OK; <br>} // End FiniPalette <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::ValidateSize <br>** Purpose: Validate Surface Size <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::ValidateSize (void) <br>{ <br>long x, y, w,h; <br>    long wwMax, whMax;  // maximum windows width, height <br>    long wwMin, whMin;  // minimum windows width, height <br> <br>// Get Min, max window sizes <br>    wwMax = GetSystemMetrics (SM_CXMAXTRACK); <br>    whMax = GetSystemMetrics (SM_CYMAXTRACK); <br>    wwMin = GetSystemMetrics (SM_CXMIN); <br>    whMin = GetSystemMetrics (SM_CYMIN); <br> <br>// Null Size =&gt; use client area of window for size <br>w = abs (rSurf.right - rSurf.left); <br>h = abs (rSurf.bottom - rSurf.top); <br>if ((w == 0) || (h == 0)) <br>{ <br>if ((! hWindow) || (! IsWindow (hWindow))) <br>return DDERR_GENERIC; <br> <br>GetClientRect (hWindow, &amp;rSurf); <br>} <br> <br>// Get canonical pos, size <br>if (rSurf.right &lt; rSurf.left) <br>{ <br>x = rSurf.right; <br>w = rSurf.left - rSurf.right; <br>} <br>else <br>{ <br>x = rSurf.left; <br>w = rSurf.right - rSurf.left; <br>} <br> <br>if (rSurf.bottom &lt; rSurf.top) <br>{ <br>y = rSurf.bottom; <br>h = rSurf.top - rSurf.bottom; <br>} <br>else <br>{ <br>y = rSurf.top; <br>h = rSurf.bottom - rSurf.top; <br>} <br> <br> <br>// Clamp to min,max sizes <br>if (w &lt; D3DWIN_MIN_SIZE) <br>w = D3DWIN_MIN_SIZE; <br>if (w &lt; wwMin) <br>w = wwMin; <br>if (w &gt; wwMax) <br>w = wwMax; <br> <br>if (h &lt; D3DWIN_MIN_SIZE) <br>h = D3DWIN_MIN_SIZE; <br>if (h &lt; whMin) <br>h = whMin; <br>if (h &gt; whMax) <br>h = whMax; <br> <br>// Save validated surface <br>rSurf.left   = x; <br>rSurf.right  = x + w; <br>rSurf.top    = y; <br>rSurf.bottom = y + h; <br> <br>// Success <br>return DD_OK; <br>} // End D3DWindow::ValidateSize <br> <br> <br>     <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::CreateRender <br>** Purpose: Creates the rendering surface from requested device and  <br>**surface size <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::CreateRender (LPGUID lpD3DGuid, LPRECT lprSurf) <br>{ <br>HRESULT hResult; <br>LPD3DDevInfo lpDevNew; <br> <br>// Check Initialization <br>if ((! lpCurrDriver) || (! lpCurrMode)) <br>{ <br>REPORTERR (DDERR_GENERIC); <br>return DDERR_GENERIC; <br>} <br> <br>// Make sure this D3D device works with this mode <br>lpDevNew = ValidateDevice (lpCurrDriver, lpD3DGuid, lpCurrMode); <br>if (! lpDevNew) <br>{ <br>REPORTERR (DDERR_INVALIDPARAMS); <br>return DDERR_INVALIDPARAMS; <br>} <br>// Save new D3D device <br>lpCurrDevice = lpDevNew; <br> <br> <br>// Get Surface Size <br>if (! lprSurf) <br>GetClientRect (hWindow, &amp;rSurf); <br>else <br>rSurf = *lprSurf; <br> <br>// Cleanup old render surface <br>FiniRender (); <br> <br>// Create new Render surface (using new Device) <br>hResult = InitRender (); <br>if (FAILED (hResult)) <br>return hResult; <br> <br>// Success <br>return DD_OK; <br>} <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::InitRender <br>** Purpose: Creates the rendering surface and D3D device <br>** Notes: <br>** <br>**1. The main problem here is a catch 22 situation.  In order to create the <br>**   D3D device you need a valid render surface.   However, in order to create <br>**     a render surface properly, you need to know some D3D device caps  <br>**- Does the device support Z-buffers <br>**- Video vs. System memory <br>**- etc. <br>** <br>**   Fortunately, our Driver Manager already has all that information. <br>**   So we can break the catch 22.  Without having to resort to some extra <br>**     complexity in the code here. <br>** <br>**  <br>** Basic Algorithm: <br>** <br>**  1. Validate Device <br>**  2. Validate Surface size <br>**  3. Setup Surface Desc (width, height, bpp) <br>**4. Create Render Surface (from surface desc) <br>**  5. Create Z-buffer (optional) <br>**6. Create D3D Device <br>**7. Create Viewport <br>**8. InitScene (optional) <br>** <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::InitRender (void) <br>{ <br>    HRESULT         hResult; <br>    DWORD           dwMemType; <br>    LPD3DDEVICEDESC lpDeviceDesc; <br>    DDSURFACEDESC   ddsd; <br>    DWORD           dwWidth, dwHeight, dwBPP; <br>LPGUIDlpGuidD3D; <br>LPD3DDevInfolpDevNew; <br> <br>// Check Initialization <br>    if ((! hWindow) || (! IsWindow (hWindow)) || <br>(! lpCurrDevice) || (! lpCurrMode) ||  <br>(! lpDD2) || (! lpD3D) || (! lpddsPrimary)) <br>    { <br>        // Error, Not initialized properly <br>REPORTERR (DDERR_GENERIC); <br>        return DDERR_GENERIC; <br>    } <br> <br> <br>// <br>// Step 1.  Validate Device <br>// <br>if (lpCurrDevice) <br>lpGuidD3D = &amp;(lpCurrDevice-&gt;guid); <br>else <br>lpGuidD3D = NULL; <br> <br>lpDevNew = ValidateDevice (lpCurrDriver, lpGuidD3D, lpCurrMode); <br>if (! lpDevNew) <br>{ <br>REPORTERR (DDERR_GENERIC); <br>return DDERR_GENERIC; <br>} <br> <br>// Save new D3D device <br>lpCurrDevice = lpDevNew; <br> <br> <br>//  <br>// Step 2. Validate Surface size <br>// <br>hResult = ValidateSize (); <br>if (FAILED (hResult)) <br>return hResult; <br> <br>dwWidth = rSurf.right - rSurf.left; <br>dwHeight = rSurf.bottom - rSurf.top; <br> <br> <br>    // <br>// Step 3.  Setup DD surface desc (width, height, BPP) <br>// <br> <br>// Get Memory Type <br>if (lpCurrDevice-&gt;isHardware ()) <br>{ <br>// Hardware device <br>dwMemType = DDSCAPS_VIDEOMEMORY; <br>lpDeviceDesc = &amp;(lpCurrDevice-&gt;d3dHalDesc); <br>} <br>else <br>{ <br>// Software device  <br>// Note:  It doesn't have to be in system memory but <br>//        it makes debugging a lot easier  <br>//  (Win16locks don't get in the way) <br>dwMemType = DDSCAPS_SYSTEMMEMORY; <br>lpDeviceDesc = &amp;(lpCurrDevice-&gt;d3dHelDesc); <br>} <br> <br>    // Get primary surface caps <br>    ZeroMemory(&amp;ddsd, sizeof(ddsd)); <br>    ddsd.dwSize = sizeof (DDSURFACEDESC); <br>    hResult = lpddsPrimary-&gt;GetSurfaceDesc (&amp;ddsd); <br>    if (FAILED (hResult)) <br>    { <br>      // Error <br>      REPORTERR (hResult); <br>      return hResult; <br>    } <br> <br>    // Create device surface <br>// Note: We don't need to specify the pixel format, it will <br>//       automatically default to same format as primary <br>    ddsd.dwSize         = sizeof(ddsd); <br>    ddsd.dwFlags        = DDSD_CAPS | DDSD_WIDTH | DDSD_HEIGHT;// | DDSD_PIXELFORMAT; <br>    ddsd.dwWidth        = dwWidth; <br>    ddsd.dwHeight       = dwHeight; <br>    ddsd.ddsCaps.dwCaps = DDSCAPS_3DDEVICE | DDSCAPS_OFFSCREENPLAIN | dwMemType; </code></pre>
<p>
</p>
<pre><code><br> <br>//  <br>// Step 2.  Create Rendering Surface (from dd surface desc) <br>// <br>hResult = lpDD2-&gt;CreateSurface (&amp;ddsd, &amp;lpddsRender, NULL); <br>if (FAILED(hResult)) <br>{ <br>REPORTERR (hResult); <br>return hResult; <br>} <br> <br>// Attach palette, if any <br>if (NULL != lpddpPalette) <br>{ <br>hResult = lpddsRender-&gt;SetPalette (lpddpPalette); <br>if (FAILED (hResult)) <br>{ <br>// Error <br>REPORTERR (hResult); <br>return hResult; <br>} <br>} <br> <br> <br>// <br>// Step 3.Create and attach Z-buffer (optional) <br>// <br>    if ((isCreateZBuffer ()) &amp;&amp;  <br>        (0L != lpDeviceDesc-&gt;dwDeviceZBufferBitDepth)) <br>    { <br>        dwBPP = FlagsToBitDepth (lpDeviceDesc-&gt;dwDeviceZBufferBitDepth); <br> <br>        // Create the z-buffer. <br>        ZeroMemory (&amp;ddsd, sizeof(ddsd)); <br>        ddsd.dwSize            = sizeof(ddsd); <br>        ddsd.dwFlags           = DDSD_CAPS   | <br>                                 DDSD_WIDTH  | <br>                                 DDSD_HEIGHT | <br>                                 DDSD_ZBUFFERBITDEPTH; <br>        ddsd.ddsCaps.dwCaps    = DDSCAPS_ZBUFFER | dwMemType; <br>        ddsd.dwWidth           = dwWidth; <br>        ddsd.dwHeight          = dwHeight; <br>        ddsd.dwZBufferBitDepth = dwBPP; <br>        hResult = lpDD2-&gt;CreateSurface (&amp;ddsd, &amp;lpddsZBuff, NULL); <br>        if (FAILED(hResult)) <br>        { <br>            // Note: we may be able to continue without a z buffer <br>            REPORTERR (hResult); <br>        } <br>else <br>{ <br>// Attach Z-buffer to rendering surface <br>hResult = lpddsRender-&gt;AddAttachedSurface (lpddsZBuff); <br>if (FAILED (hResult)) <br>{ <br>// Note: we may be able to continue without a z buffer <br>REPORTERR (hResult); <br>if (lpddsZBuff) <br>{ <br>lpddsZBuff-&gt;Release (); <br>lpddsZBuff = NULL; <br>} <br>} <br>} <br>    } <br> <br> <br>    // <br>    // Step 4.  Create the D3D device interface <br>// <br>hResult = lpD3D-&gt;CreateDevice (lpCurrDevice-&gt;guid, <br>    lpddsRender,  <br>    &amp;lpd3dDevice); <br>    if (FAILED (hResult)) <br>    { <br>        REPORTERR (hResult); <br>        return hResult; <br>    } <br> <br> <br>// <br>// Step 5.  Create the viewport <br>// <br>hResult = InitViewport (); <br>if (FAILED (hResult)) <br>return hResult; <br> <br>// Mark as valid <br>turnValidRenderOn (); <br>turnCalcRectsOn (); <br> <br> <br>//  <br>// Step 6.Initialize Scene (if attached) <br>// <br>if (lpd3dScene) <br>{ <br>hResult = lpd3dScene-&gt;Init (this); <br>if (FAILED (hResult)) <br>return hResult; <br>} <br> <br>    // Success <br>    return DD_OK; <br>} // End D3DWindow::InitRender <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::FiniRender <br>** Purpose: Destroys the Rendering surface <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::FiniRender (void) <br>{ <br>// Mark as invalid <br>turnValidRenderOff (); <br> <br>// Cleanup Associated Scene <br>if (lpd3dScene) <br>{ <br>lpd3dScene-&gt;Fini (); <br>} <br> <br>// Cleanup viewport <br>FiniViewport (); <br> <br>    // Release D3D Device <br>    if (lpd3dDevice) <br>    { <br>        lpd3dDevice-&gt;Release (); <br>        lpd3dDevice = NULL; <br>    } <br> <br>    // Release Z Buffer <br>    if (lpddsZBuff) <br>    { <br>        // Detach Z-Buffer from back buffer <br>        if (lpddsRender) <br>            lpddsRender-&gt;DeleteAttachedSurface (0L, lpddsZBuff); <br>        lpddsZBuff-&gt;Release (); <br>        lpddsZBuff = NULL; <br>    } <br> <br>    // Release rendering surface <br>    if (lpddsRender) <br>    { <br>        lpddsRender-&gt;Release (); <br>        lpddsRender = NULL; <br>    } <br> <br>// Success <br>return DD_OK; <br>} // End D3DWindow::FiniRender <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       D3DWindow::InitViewport <br>**  Purpose:     <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::InitViewport (void) <br>{ <br>HRESULT hResult; <br> <br>// Check Initialization <br>if ((! lpD3D) || (! lpd3dDevice)) <br>{ <br>        REPORTERR (DDERR_GENERIC); <br>        return DDERR_GENERIC; <br>} <br> <br>// Create Viewport <br>    hResult = lpD3D-&gt;CreateViewport (&amp;lpd3dViewport, NULL); <br>    if (FAILED (hResult)) <br>    { <br>        REPORTERR (hResult); <br>        return hResult; <br>    } <br> <br>// Attach viewport to D3D device <br>    hResult = lpd3dDevice-&gt;AddViewport (lpd3dViewport); <br>    if (FAILED (hResult)) <br>    { <br>        REPORTERR (hResult); <br>        return hResult; <br>    } <br> <br>// Set up Initial Viewport parameters <br>hResult = UpdateViewport (); <br>    if (FAILED (hResult)) <br>        return hResult; <br> <br>/// Success <br>return DD_OK; <br>} // End D3DWindow::InitViewport <br>   <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       D3DWindow::FiniViewport <br>**  Purpose:    Cleanup viewport <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::FiniViewport (void) <br>{ <br>// Release D3D viewport <br>    if (lpd3dViewport) <br>    { <br>        lpd3dViewport-&gt;Release (); <br>        lpd3dViewport  = NULL; <br>    } <br> <br>// Success <br>return DD_OK; <br>} // End D3DWindow::FiniViewport <br> <br>   <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       D3DWindow::UpdateViewport <br>**  Purpose:    Keeps viewport updated with current window size <br>**  Notes: <br>** <br>**1. The viewport construction here assumes that you are rendering  <br>**Triangles using the D3DVERTEX and D3DIM is doing Transform, <br>**lighting, and rasterization for you. <br>** <br>**2. If you are rendering triangles using D3DTLVERTEX and doing your <br>**   own transform and lighting then you need to setup the viewport <br>**   differently.   As follows: <br>** <br>**      // Replace the following values below: <br>**dvClipX= 0.0f; <br>**dvClipY= 0.0f; <br>**dvClipWidth= dwSurfW; <br>**dvClipHeight= dvSurfH; <br>** <br>**  3. This perserves the aspect ratio.  If you don't need or want to <br>**     perserve the aspect ratio then set inv_aspect = 1.0 below and <br>**     work this constant through the rest of the viewport setup. <br>** <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::UpdateViewport (void) <br>{ <br>    HRESULThResult; <br>    D3DVIEWPORT2d3dViewport; <br>DWORDdwSurfW, dwSurfH; <br> <br>    // Check Parameters <br>if ((! lpd3dDevice) || (! lpd3dViewport)) <br>{ <br>// Not properly initialized. <br>REPORTERR (DDERR_GENERIC); <br>return DDERR_GENERIC; <br>} <br> <br>// Get Surface Width and Height <br>dwSurfW = abs (rSurf.right - rSurf.left); <br>dwSurfH = abs (rSurf.bottom - rSurf.top); <br> <br>float inv_aspect; <br> <br>if (dwSurfW) <br>inv_aspect = (float)dwSurfH/(float)dwSurfW; <br>else <br>                inv_aspect = 1.0f; <br> <br>    // Update Viewport <br>    ZeroMemory (&amp;d3dViewport, sizeof(d3dViewport)); <br>    d3dViewport.dwSize= sizeof(d3dViewport);     // Always set size of structure!!! <br>    d3dViewport.dwX= 0UL; <br>    d3dViewport.dwY= 0UL; <br>    d3dViewport.dwWidth= dwSurfW; <br>    d3dViewport.dwHeight= dwSurfH; <br>    d3dViewport.dvClipX= -1.0f; <br>    d3dViewport.dvClipY= inv_aspect; <br>    d3dViewport.dvClipWidth= 2.0f; <br>    d3dViewport.dvClipHeight = 2.0f * inv_aspect; <br>    d3dViewport.dvMinZ= 0.0f; <br>    d3dViewport.dvMaxZ= 1.0f; <br> <br>// Update Viewport <br>    hResult = lpd3dViewport-&gt;SetViewport2 (&amp;d3dViewport); <br>    if (FAILED (hResult)) <br>    { <br>        REPORTERR (hResult); <br>        return hResult; <br>    } <br> <br>// Update D3D device to use this viewport <br>    hResult = lpd3dDevice-&gt;SetCurrentViewport (lpd3dViewport); <br>    if (FAILED (hResult)) <br>    { <br>        REPORTERR (hResult); <br>        return hResult; <br>    } <br> <br>    // Success <br>    return DD_OK; <br>} // End D3DWindow::UpdateViewport <br> <br>   <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::DrawFrame <br>** Purpose: Paints current surface to window <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::DrawFrame (void) <br>{ <br>    HRESULT hResult = DD_OK; <br> <br>// Check Initialization <br>    if (! isValid ()) <br>    { <br>        // Error, not properly initialized <br>        return DDERR_GENERIC; <br>    } <br> <br>    if (isPaused ()) <br>    { <br>        // Don't draw, if paused <br>        return DD_OK; <br>    } <br> <br>    // Double check parameters <br>    if ((! lpddsPrimary) || (! lpddsRender)) <br>    { <br>        // Error, not properly initialized <br>        return DDERR_GENERIC; <br>    } <br>     <br>    // Get current src, dest rectangles <br>    CalcRects (); <br> <br>    if (! checkPaint ()) <br>    { <br>        // Nothing to draw, so return immediately <br>        return DD_OK; <br>    } <br> <br>    // Paint until we truly succeed or error out <br>    while (TRUE) <br>    { <br>// Render D3D Scene <br>if (lpd3dScene) <br>hResult = lpd3dScene-&gt;Render (); <br> <br>if (SUCCEEDED (hResult)) <br>{ <br>// Blt Rendering surface onto primary surface <br>hResult = lpddsPrimary-&gt;Blt (&amp;rDrawDest,// Dest Rect <br>                     lpddsRender,   // Src Surface <br>                 &amp;rDrawSrc,     // Src Rect <br>             DDBLT_WAIT,    // Wait <br>         NULL);         // Blt Special Effects (none) <br> <br>// Did it work ?!?   <br>if (SUCCEEDED (hResult)) <br>{ <br>// Success, exit <br>return hResult; <br>} <br>} <br> <br>        // Check if busy or drawing <br>        if ((DDERR_SURFACEBUSY == hResult) || <br>            (DDERR_WASSTILLDRAWING == hResult)) <br>        { <br>            // Try again <br>            continue; <br>        } <br> <br>        // Check for lost surfaces <br>        while (DDERR_SURFACELOST == hResult) <br>        { <br>            // Restore surfaces <br>            hResult = Restore (); <br>        } <br> <br>        // Check for real error <br>        if (FAILED (hResult)) <br>        { <br>            // Error, <br>            REPORTERR (hResult); <br>            return hResult; <br>        } <br>    } <br> <br>    // Success <br>    return DD_OK; <br>} // End D3DWindow::DrawFrame <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::Move <br>** Purpose: Move window to new coordinates <br>** Notes:   This used to be simpler. (See CalcRects) <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::Move (long x, long y) <br>{ <br>    // Need to recalculate src, dest rectangles <br>    turnCalcRectsOn (); <br> <br>    // Success <br>    return DD_OK; <br>} // D3DWindow::Move <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::Resize <br>** Purpose: Resizes the Window <br>** Notes: <br>**We need to resize the render surface to stay in sync <br>**with the new window size <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::Resize (DWORD dwWidth, DWORD dwHeight) <br>{ <br>HRESULThResult; <br>RECTrSurfOld; <br> <br>    // Need to recalculate src, dest rectangles  <br>    turnCalcRectsOn (); <br> <br>// Save old Surface coordinates <br>rSurfOld = rSurf; <br> <br>// Update the surface rectangle <br>rSurf.left   = 0; <br>rSurf.top    = 0; <br>rSurf.right  = dwWidth; <br>rSurf.bottom = dwHeight; <br> <br>// Check if properly initialized <br>if (! isValid ()) <br>{ <br>// Try to re-initialize <br>Fini (); <br>hResult = Init (); <br>if (FAILED (hResult)) <br>return hResult; <br> <br>// Successful re-initialization <br>return DD_OK; <br>} <br> <br>    // Cleanup Render Surface (and D3D Device) <br>    FiniRender (); <br> <br>// Re-create Render Surface (at new size) <br>hResult = InitRender (); <br>if (FAILED (hResult)) <br>{ <br>if ((hResult == DDERR_OUTOFMEMORY) ||  <br>(hResult == DDERR_OUTOFVIDEOMEMORY)) <br>{ <br>// Try to restore old surface size <br>rSurf = rSurfOld; <br> <br>FiniRender (); <br>hResult = InitRender (); <br>if (FAILED (hResult)) <br>return hResult; <br> <br>// Successfully returned to previous size <br>return DD_OK; <br>} <br> <br>return hResult; <br>} <br> <br>// Success <br>return DD_OK; <br>} // End D3DWindow::Resize  <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       D3DWindow::RealizePalette <br>**  Purpose:     <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::RealizePalette (void) <br>{ <br>HRESULT hResult; <br> <br>// <br>    // Realizing the palette using DirectDraw is quite different <br>    // from GDI. To realize the palette we call SetPalette() <br>    // each time our application is activated. <br>    // <br>    // NOTE: DirectDraw spots the fact that the new palette is the <br>    // same as the old one and so does not increase the reference <br>    // count of the palette. <br>    // <br> <br>if ((lpddsPrimary) &amp;&amp; (lpddpPalette)) <br>{ <br>hResult = lpddsPrimary-&gt;SetPalette (lpddpPalette); <br>if (FAILED (hResult)) <br>        { <br>            REPORTERR (hResult); <br>            return hResult; <br>        } <br>} <br> <br>// Success <br>return DD_OK; <br>} // End D3DWindow::RealizePalette <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::Pause <br>** Purpose: Pause any work on DD/D3D resources <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::Pause (BOOL fPause) <br>{ <br>    // Turning pausing on/off ?!? <br>    if (fPause) <br>    { <br>        if (dwPaused == 0L) <br>        { <br>// Very first time paused, do anything special here... <br> <br>// Force screen redraw <br>if (hWindow) <br>InvalidateRect (hWindow, NULL, FALSE); <br>        } <br>        dwPaused++; <br>    } <br>    else <br>    { <br>        if (dwPaused == 0L) <br>        { <br>            // Programmer Error, already paused <br>REPORTERR (DDERR_GENERIC); <br>            return DDERR_GENERIC; <br>        } <br> <br>        // Decrement semaphore <br>        dwPaused--; <br>        if (dwPaused == 0L) <br>        { <br>// Very last time unpaused, do anything special here... <br> <br>// Force screen redraw <br>if (hWindow) <br>InvalidateRect (hWindow, NULL, FALSE); <br>        } <br>    } <br> <br>    // Success <br>    return DD_OK; <br>} // D3DWindow::Pause <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::AttachScene <br>** Purpose:  <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::AttachScene (LPD3DScene lpNewScene) <br>{ <br>// Check parameters <br>if (! lpNewScene) <br>{ <br>return DDERR_INVALIDPARAMS; <br>} <br> <br>DetachScene (); <br> <br>// Save Scene pointer <br>lpd3dScene = lpNewScene; <br> <br>// Initialize Scene ?!? <br>if (isValid ()) <br>{ <br>lpd3dScene-&gt;Init (this); <br>} <br> <br>// Success <br>return DD_OK; <br>} // End D3DWindow::AttachScene <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::DetachScene <br>** Purpose:  <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::DetachScene (void) <br>{ <br>// Cleanup Scene <br>if (lpd3dScene) <br>{ <br>lpd3dScene-&gt;Fini (); <br>lpd3dScene = NULL; <br>} <br> <br>// Success <br>return DD_OK; <br>} // End D3DWindow::DetachScene <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::CalcRects <br>** Purpose: Recalculate src,dest rectangles <br>** <br>** Notes:Without this protection we get a GPF when we drag the window <br>**off the edge of the screen.  This is because we are trying to <br>**write pixels to a non-existent location.   The clipper object <br>**attached to the primary protects the primary surface from  <br>**stray pixels outside of the window's client area.  However, it <br>**doesn't stop us from trying to write outside the primary.  So <br>**we need to protect ourselves. <br>**  <br>** Basic Algorithm:    <br>** <br>**     - Get Client rectangle <br>**     - Get Render Surface rectangle <br>**     - Intersect client with surface to get initial src rect <br>** <br>**     - Get Primary surface rectangle <br>**     - Map Src rect to primary surface coordinates <br>** <br>**     - Intersect primary with src to get dest rect. <br>**     - Map dest rect back into surface coordinates to get final src rect. <br>** <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::CalcRects (void) <br>{ <br>    // Do we need to recalculate the rectangles <br>// I.E. Can we avoid doing work <br>    if (checkCalcRects ()) <br>    { <br>        HRESULT       hResult; <br>        DDSURFACEDESC ddsd;         // Surface desc. <br>        POINT         pnt; <br>        RECT          rClient; <br>        RECT          rSrc; <br>        RECT          rDest; <br>        RECT          rTemp; <br>         <br>        if (! isValid ()) <br>        { <br>            // Error, not properly initialized <br>            return DDERR_GENERIC; <br>        } <br> <br>        // Assume we are going to paint <br>        turnPaintOn (); <br> <br>        // Get Client rectangle pos/size <br>        GetClientRect (hWindow, &amp;rClient); <br> <br>        // Get Surface rectangle size <br>        ddsd.dwSize = sizeof (DDSURFACEDESC); <br>        hResult = lpddsRender-&gt;GetSurfaceDesc (&amp;ddsd); <br>        if (FAILED (hResult)) <br>        { <br>            // Error <br>            REPORTERR (hResult); <br>            return hResult; <br>        } <br>        rSurf.right     = rSurf.left + ddsd.dwWidth; <br>        rSurf.bottom    = rSurf.top + ddsd.dwHeight; <br> <br>        // Intersect client with surface to get initial Src Rect <br>        if (! IntersectRect (&amp;rSrc, &amp;rClient, &amp;rSurf)) <br>        { <br>            // No intersection, means nothing to draw <br>            turnPaintOff (); <br>            rSrc.left   = 0; <br>            rSrc.top    = 0; <br>            rSrc.right  = 0; <br>            rSrc.bottom = 0; <br>        } <br> <br>        // Get Primary Rectangle <br>        ZeroMemory (&amp;ddsd, sizeof(ddsd)); <br>        ddsd.dwSize = sizeof (DDSURFACEDESC); <br>        hResult = lpddsPrimary-&gt;GetSurfaceDesc (&amp;ddsd); <br>        if (FAILED (hResult)) <br>        { <br>            // Error <br>            return hResult; <br>        } <br> <br>        rPrim.left      = 0; <br>        rPrim.top       = 0; <br>        rPrim.right     = rPrim.left + ddsd.dwWidth; <br>        rPrim.bottom    = rPrim.top + ddsd.dwHeight; <br> <br>        // Map src rectangle in surface coordinates to  <br>// primary surface coordinates <br>        pnt.x = rSrc.left; <br>        pnt.y = rSrc.top; <br>        ClientToScreen (hWindow, &amp;pnt); <br> <br>        rTemp.left   = pnt.x; <br>        rTemp.top    = pnt.y; <br>        rTemp.right  = rTemp.left + (rSrc.right - rSrc.left); <br>        rTemp.bottom = rTemp.top + (rSrc.bottom - rSrc.top); <br> <br>        // Intersect temp with primary to get dest Rect <br>        if (! IntersectRect (&amp;rDest, &amp;rPrim, &amp;rTemp)) <br>        { <br>            // No intersection, means nothing to draw <br>            turnPaintOff (); <br>            rDest.left   = 0; <br>            rDest.top    = 0; <br>            rDest.right  = 0; <br>            rDest.bottom = 0; <br>        } <br> <br>        // Now we have to map the dest rectangle back into <br>        // surface space to to get the final src rectangle <br>        rSrc.left   = rSrc.left + (rDest.left - pnt.x); <br>        rSrc.top    = rSrc.top + (rDest.top - pnt.y); <br>        rSrc.right  = rSrc.left + (rDest.right - rDest.left); <br>        rSrc.bottom = rSrc.top + (rDest.bottom - rDest.top); <br> <br>        // Save src and dest rectangles <br>        rDrawDest.left   = rDest.left; <br>        rDrawDest.top    = rDest.top; <br>        rDrawDest.right  = rDest.right; <br>        rDrawDest.bottom = rDest.bottom; <br> <br>        rDrawSrc.left   = rSrc.left; <br>        rDrawSrc.top    = rSrc.top; <br>        rDrawSrc.right  = rSrc.right; <br>        rDrawSrc.bottom = rSrc.bottom; <br> <br>        // No longer need to calculate rects <br>        turnCalcRectsOff (); <br>    } <br> <br>    // Success <br>    return DD_OK; <br>} // End D3DWindow::CalcRects <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::Restore <br>** Purpose: Restores lost surfaces <br>** Note:    Eventually we should inform the user somehow that <br>**          they need to redraw the surface but for now punt <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::Restore (void) <br>{ <br>    HRESULT hResult; <br> <br>// Check Initialization <br>    if (! isValid ()) <br>        return DDERR_GENERIC; <br> <br>    // Restore Primary Surface <br>    if (lpddsPrimary) <br>    { <br>        hResult = lpddsPrimary-&gt;Restore (); <br>        if (FAILED (hResult)) <br>            return hResult; <br>    } <br> <br>    // Restore Z Buffer <br>    if (lpddsZBuff) <br>    { <br>        hResult = lpddsZBuff-&gt;Restore (); <br>        if (FAILED (hResult)) <br>            return hResult; <br>    } <br> <br>    // Restore Rendering surface <br>    if (lpddsRender) <br>    { <br>        hResult = lpddsRender-&gt;Restore (); <br>        if (FAILED (hResult)) <br>            return hResult; <br>    } <br> <br>// Allow D3D Scene to restore any surfaces <br>if (lpd3dScene) <br>{ <br>hResult = lpd3dScene-&gt;Restore (); <br>if (FAILED (hResult)) <br>return hResult; <br>} <br> <br>    // Success <br>    return DD_OK; <br>} // End D3DWindow::Restore <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::GetSurfaceRect <br>** Purpose: Get bounding rectangle of surface <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::GetSurfaceRect (RECT &amp; rSurface) <br>{ <br>    HRESULT hResult; <br> <br>    if (! isValid ()) <br>    { <br>        // Error <br>        return DDERR_GENERIC; <br>    } <br> <br>    // Force update of rectangle coordinates <br>    hResult = CalcRects (); <br>    if (FAILED (hResult)) <br>        return hResult; <br> <br>    // Return Surface rectangle <br>    rSurface = rSurf; <br> <br>    // Success <br>    return DD_OK; <br>} // D3DWindow::GetSurfaceRect <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::GetPrimaryRect <br>** Purpose: Get bounding rectangle of primary surface <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::GetPrimaryRect (RECT &amp; rPrimary) <br>{ <br>    HRESULT hResult; <br> <br>    if (! isValid ()) <br>    { <br>        // Error <br>        return DDERR_GENERIC; <br>    } <br> <br>    // Force update of rectangle coordinates <br>    hResult = CalcRects (); <br>    if (FAILED (hResult)) <br>    { <br>        // Error <br>        REPORTERR (hResult); <br>        return hResult; <br>    } <br> <br>    // Return Primary rectangle <br>    rPrimary = rPrim; <br> <br>    // Success <br>    return DD_OK; <br>} // GetPrimaryRect <br>   <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::GetSrcRect <br>** Purpose: Get current Src Rectangle <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::GetSrcRect (RECT &amp; rSrc) <br>{ <br>    HRESULT hResult; <br> <br>    if (! isValid ()) <br>    { <br>        // Error <br>        return DDERR_GENERIC; <br>    } <br> <br>    // Force update of rectangle coordinates <br>    hResult = CalcRects (); <br>    if (FAILED (hResult)) <br>        return hResult; <br> <br>    // Return Surface rectangle <br>    rSrc = rDrawSrc; <br> <br>    // Success <br>    return DD_OK; <br>} // D3DWindow::GetSrcRect <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::GetDestRect <br>** Purpose: Get current Dest Rectangle <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::GetDestRect (RECT &amp; rDest) <br>{ <br>    HRESULT hResult; <br> <br>    if (! isValid ()) <br>    { <br>        // Error <br>        return DDERR_GENERIC; <br>    } <br> <br>    // Force update of rectangle coordinates <br>    hResult = CalcRects (); <br>    if (FAILED (hResult)) <br>        return hResult; <br> <br>    // Return Surface rectangle <br>    rDest = rDrawDest; <br> <br>    // Success <br>    return DD_OK; <br>} // D3DWindow::GetDestRect <br>   <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       D3DWindow::ChangeDesktop <br>**  Purpose:    The Primary Desktop has changed Modes, so we need <br>**to update our current mode to stay in sync <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::ChangeDesktop (void) <br>{ <br>HRESULT hResult; <br>LPDDDrvInfo  lpDrvOld; <br>LPDDModeInfo lpModeOld, lpModeNew; <br>LPD3DDevInfo lpDevOld, lpDevNew; <br>LPGUID lpGuidD3D; <br> <br>// Check Initialization <br>if ((! hWindow) || (! IsWindow (hWindow))) <br>{ <br>REPORTERR (DDERR_INVALIDPARAMS); <br>return DDERR_INVALIDPARAMS; <br>} <br> <br>lpDrvOld  = lpCurrDriver; <br>lpModeOld = lpCurrMode; <br>lpDevOld  = lpCurrDevice; <br> <br>if (! lpDrvOld) <br>{ <br>REPORTERR (DDERR_GENERIC); <br>return DDERR_GENERIC; <br>} <br> <br> <br>// <br>// Step 1. Get New Mode (and new device) <br>// <br> <br>// Get D3D Guid <br>if (lpDevOld) <br>lpGuidD3D = &amp;(lpDevOld-&gt;guid); <br>else <br>lpGuidD3D = NULL; <br> <br>// Get New Mode and Device corresponding to current desktop <br>if (! GetDesktopMode (lpDrvOld, lpGuidD3D, &amp;lpModeNew, &amp;lpDevNew)) <br>{ <br>REPORTERR (DDERR_GENERIC); <br>return DDERR_GENERIC; <br>} <br> <br>// Do they match <br>if (lpModeOld == lpModeNew) <br>{ <br>// Nothing to do <br>return DD_OK; <br>} <br> <br>//  <br>// Step 2.Destroy current Mode <br>// <br>FiniRender (); <br>FiniPrimary (); <br>//  FiniMode ();// Don't do this =&gt; unnecessary mode switch <br> <br>// <br>// Step 3.  Create new mode <br>// <br>lpCurrMode = lpModeNew; <br>if (lpDevNew) <br>lpCurrDevice = lpDevNew; <br> <br>// Create Primary Surface <br>hResult = InitPrimary (); <br>if (FAILED (hResult)) <br>{ <br>// Error, no point in trying to restore old defaults <br>// they are out of sync with the current desktop <br>return hResult; <br>} <br> <br> <br>// Create Render surface <br>hResult = InitRender (); <br>if (FAILED (hResult)) <br>{ <br>// Error, no point in trying to restore old defaults <br>// they are out of sync with the current desktop <br>return hResult; <br>} <br> <br>// Notify the window of a successful change in Mode <br>SendMessage (hWindow, D3DWIN_CHANGED_MODE, 0, 0); <br> <br>// Success <br>    return DD_OK; <br>} // D3DInfo::ChangeDesktop <br>   <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::ChangeDriver <br>** Purpose:  <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::ChangeDriver (LPGUID lpGuidDD, LPD3DDevInfo lpDevHint) <br>{ <br>HRESULT hResult; <br>    LPGUID       lpGuidD3D; <br>LPDDDrvInfo  lpDrvNew,  lpDrvOld; <br>LPDDModeInfo lpModeNew, lpModeOld; <br>LPD3DDevInfo lpDevNew, lpDevOld; <br> <br>// Get New Driver <br>lpDrvNew = ValidateDriver (lpGuidDD); <br>if (! lpDrvNew) <br>{ <br>return DDERR_GENERIC; <br>} <br> <br>// Are we already using the requested driver <br>if ((isValid ()) &amp;&amp; (lpDrvNew == lpCurrDriver)) <br>return DD_OK; <br> <br>// Get reasonable defaults for Mode and D3D device <br>if (lpDevHint) <br>lpGuidD3D = &amp;(lpDevHint-&gt;guid); <br>else if (lpCurrDevice) <br>lpGuidD3D = &amp;(lpCurrDevice-&gt;guid); <br>else <br>lpGuidD3D = NULL; <br> <br>if (! GetDesktopMode (lpDrvNew, lpGuidD3D, &amp;lpModeNew, &amp;lpDevNew)) <br>{ <br>return DDERR_GENERIC; <br>} <br> <br>// Save old defaults <br>lpDrvOld= lpCurrDriver; <br>lpModeOld= lpCurrMode; <br>lpDevOld= lpCurrDevice; <br> <br>// Destroy almost everything <br>Fini (); <br> <br>// Set new defaults <br>lpCurrDriver = lpDrvNew; <br>lpCurrMode   = lpModeNew; <br>lpCurrDevice = lpDevNew; <br> <br>// Re-create almost everything based on new driver <br>hResult = Init (); <br>if (FAILED (hResult)) <br>{ <br>// Try to restore old defaults <br>Fini (); <br> <br>lpCurrDriver = lpDrvOld; <br>lpCurrMode   = lpModeOld; <br>lpCurrDevice = lpDevOld; <br> <br>Init (); <br>return hResult; <br>} <br> <br>// Notify the window of a successful change in Driver <br>SendMessage (hWindow, D3DWIN_CHANGED_DRIVER, 0, 0); <br> <br>// Success <br>    return DD_OK; <br>} // End D3DWindow::ChangeDriver <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::ChangeDevice <br>** Purpose: Change to a new D3D device (RAMP, RGB, Hardware, etc.) <br>** Notes: <br>** <br>**  Algorithm: <br>**- Destroy the current D3D Device (and associated surfaces) <br>**- Recreate a new D3D device from the new GUID <br>** <br>**  1.The new D3D Device may not be supported by the current DD Device. <br>** <br>**  2.  The new D3D Device may not be compatible with the current Mode <br>**- If we are windowed, then punt (we shouldn't change the desktop) <br>**- If we are full-screen then pick a new mode that is compatible <br>**- This means destroy the current mode and recreate it. <br>** <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::ChangeDevice (LPGUID lpD3DGuid) <br>{ <br>    HRESULT         hResult; <br>LPDDDrvInfolpDrvOld; <br>LPDDModeInfo    lpModeOld; <br>LPD3DDevInfolpDevNew, lpDevOld; <br> <br>// Check Parameters <br>if (! lpD3DGuid) <br>{ <br>REPORTERR (DDERR_INVALIDPARAMS); <br>        return DDERR_INVALIDPARAMS; </code></pre>
<p>
</p>
<pre><code>} <br> <br>// Check Initialization <br>    if (! isValid () || (! lpddsRender)) <br>{ <br>REPORTERR (DDERR_GENERIC); <br>        return DDERR_GENERIC; <br>} <br> <br>// Save Original State <br>lpDrvOld= lpCurrDriver; <br>lpModeOld   = lpCurrMode; <br>lpDevOld= lpCurrDevice; <br> <br>// Verify new D3D device belongs to current DD driver <br>lpDevNew = lpDrvOld-&gt;FindDevice (lpD3DGuid, NULL); <br>if (! lpDevNew) <br>{ <br>REPORTERR (DDERR_INVALIDPARAMS); <br>        return DDERR_INVALIDPARAMS; <br>} <br> <br>// <br>//Step 1. Verify new D3D device is supported with current mode <br>// <br>if (! lpModeOld-&gt;ModeSupported (lpDevNew)) <br>{ <br>// We can't change the mode <br>// as we shouldn't be changing the desktop <br>REPORTERR (DDERR_INVALIDPARAMS); <br>return DDERR_INVALIDPARAMS; <br>} <br> <br> <br>// <br>//Step 2.  Destroy Old D3D Device <br>// <br>FiniRender (); <br> <br>// <br>//Step 3. Create new D3D Device <br>// <br> <br>// Set new D3D device (and mode) <br>lpCurrDevice = lpDevNew; <br> <br>// Create new D3D Device <br>hResult = InitRender (); <br>if (FAILED (hResult)) <br>{ <br>// Try to restore original device <br>lpCurrDevice = lpDevOld; <br>InitRender (); <br> <br>// Return Error <br>REPORTERR (hResult); <br>return hResult; <br>} <br> <br>// Notify the window of a successful change in device <br>SendMessage (hWindow, D3DWIN_CHANGED_DEVICE, 0, 0); <br> <br>    // Success <br>    return DD_OK; <br>} // End D3DWindow::ChangeDevice <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** End of File <br>**----------------------------------------------------------------------------- <br>*/ </code></pre>
<p>&nbsp;</p></body>
</HTML>
