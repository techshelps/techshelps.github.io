<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>D3DUTILS.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3277"></a>D3DUTILS.CPP</h2>
<pre><code>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DUtils.cpp <br>** Purpose: Various D3D utility functions <br>** Notes: <br>** <br>** Copyright (c) 1995 - 1997 by Microsoft, all rights reserved. <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>// Note:  Must Define D3D_OVERLOADS to get C++ version of D3DMATRIX <br>#define D3D_OVERLOADS <br>#include &lt;float.h&gt; <br>#include &lt;math.h&gt; <br> <br>#include "d3dutils.h" <br> <br>const float pi = 3.141592654f; <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Functions <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       ZeroMatrix <br>**  Purpose:sets D3D matrix to all 0's <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>D3DMATRIX  <br>ZeroMatrix(void) <br>{ <br>    D3DMATRIX ret; <br>    for (int i=0; i&lt;4; i++) { <br>        for (int j=0; j&lt;4; j++) { <br>            ret(i, j) = 0.0f; <br>} <br>} <br>    return ret; <br>} // end ZeroMatrix <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       IdentityMatrix <br>**  Purpose:sets D3D matrix to Identiy (1's on diagonal, zero's elsewhere) <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>D3DMATRIX <br>IdentityMatrix(void) <br>{ <br>    D3DMATRIX ret; <br>    for (int i=0; i&lt;4; i++) { <br>        for (int j=0; j&lt;4; j++){ <br>            ret(i, j) = 0.0f; <br>} <br>ret(i,i) = 1.0f; <br>} <br>    return ret; <br>} // end IdentityMatrix <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       ProjectionMatrix <br>**  Purpose:sets Projection matrix from fov, near and far planes <br>**  Notes: <br>**1. fov is in radians. <br>**2. See Blinn, "A Trip Down the Graphics Pipeline" pg 188 for details. <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>D3DMATRIX  <br>ProjectionMatrix(const float near_plane,  <br> const float far_plane,  <br> const float fov) <br>{ <br>floatc, s, Q; <br> <br>c = (float) cos(fov*0.5); <br>s = (float) sin(fov*0.5); <br>Q = s/(1.0f - near_plane/far_plane); <br> <br>    D3DMATRIX ret = ZeroMatrix(); <br>    ret(0, 0) = c; <br>    ret(1, 1) = c; <br>ret(2, 2) = Q; <br>ret(3, 2) = -Q*near_plane; <br>    ret(2, 3) = s; <br>    return ret; <br>}// end ProjectionMatrix <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       ViewMatrix <br>**  Purpose:Controls where the camara is. <br>**  Notes: <br>**1. Note the roll parameter is in radians and rools the viewpoint <br>**around the viewing direction <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>D3DMATRIX <br>ViewMatrix(const D3DVECTOR&amp; from,  <br>   const D3DVECTOR&amp; at,  <br>   const D3DVECTOR&amp; world_up,  <br>   const float roll) <br>{ <br>    D3DMATRIX view = IdentityMatrix(); <br>    D3DVECTOR up, right, view_dir; <br> <br>    view_dir = Normalize(at - from); <br>right = CrossProduct(world_up, view_dir); <br>up = CrossProduct(view_dir, right); <br> <br>right = Normalize(right); <br>up = Normalize(up); <br> <br>    view(0, 0) = right.x; <br>    view(1, 0) = right.y; <br>    view(2, 0) = right.z; <br>    view(0, 1) = up.x; <br>    view(1, 1) = up.y; <br>    view(2, 1) = up.z; <br>    view(0, 2) = view_dir.x; <br>    view(1, 2) = view_dir.y; <br>    view(2, 2) = view_dir.z; <br> <br>    view(3, 0) = -DotProduct(right, from); <br>    view(3, 1) = -DotProduct(up, from); <br>    view(3, 2) = -DotProduct(view_dir, from); <br> <br>// Set roll <br>if (roll != 0.0f) { <br>view = MatrixMult(RotateZMatrix(-roll), view); <br>} <br> <br>    return view; <br>} // end ViewMatrix <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       RotateXMatrix <br>**  Purpose:Rotate matrix about X axis <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>D3DMATRIX <br>RotateXMatrix(const float rads) <br>{ <br>floatcosine, sine; <br> <br>cosine = (float) cos(rads); <br>sine = (float) sin(rads); <br>    D3DMATRIX ret = IdentityMatrix(); <br>    ret(1,1) = cosine; <br>ret(2,2) = cosine; <br>ret(1,2) = -sine; <br>ret(2,1) = sine; <br>    return ret; <br>} // end RotateXMatrix <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       RotateYMatrix <br>**  Purpose:Rotate matrix about Y axis <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>D3DMATRIX <br>RotateYMatrix(const float rads) <br>{ <br>floatcosine, sine; <br> <br>cosine = (float) cos(rads); <br>sine = (float) sin(rads); <br>    D3DMATRIX ret = IdentityMatrix(); <br>    ret(0,0) = cosine; <br>ret(2,2) = cosine; <br>ret(0,2) = sine; <br>ret(2,0) = -sine; <br>    return ret; <br>} // end RotateY <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       RotateZMatrix <br>**  Purpose:Rotate matrix about Z axis <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>D3DMATRIX <br>RotateZMatrix(const float rads) <br>{ <br>floatcosine, sine; <br> <br>cosine = (float) cos(rads); <br>sine = (float) sin(rads); <br>    D3DMATRIX ret = IdentityMatrix(); <br>    ret(0,0) = cosine; <br>ret(1,1) = cosine; <br>ret(0,1) = -sine; <br>ret(1,0) = sine; <br>    return ret; <br>} // end RotateZMatrix <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       TranslateMatrix <br>**  Purpose:    Returns matrix to translate by (dx, dy, dz) <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>D3DMATRIX  <br>TranslateMatrix(const float dx, const float dy, const float dz) <br>{ <br>    D3DMATRIX ret = IdentityMatrix(); <br>ret(3, 0) = dx; <br>ret(3, 1) = dy; <br>ret(3, 2) = dz; <br>return ret; <br>} // end TranslateMatrix <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       TranslateMatrix <br>**  Purpose:    Returns matrix to translate by v <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>D3DMATRIX  <br>TranslateMatrix(const D3DVECTOR&amp; v) <br>{ <br>    D3DMATRIX ret = IdentityMatrix(); <br>ret(3, 0) = v[0]; <br>ret(3, 1) = v[1]; <br>ret(3, 2) = v[2]; <br>return ret; <br>} // end TranslateMatrix <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       ScaleMatrix <br>**  Purpose:    scale matrix (uniform) <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>D3DMATRIX  <br>ScaleMatrix(const float size) <br>{ <br>    D3DMATRIX ret = IdentityMatrix(); <br>ret(0, 0) = size; <br>ret(1, 1) = size; <br>ret(2, 2) = size; <br>return ret; <br>} // end ScaleMatrix <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       ScaleMatrix <br>**  Purpose:scale matrix <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>D3DMATRIX  <br>ScaleMatrix(const float a, const float b, const float c) <br>{ <br>    D3DMATRIX ret = IdentityMatrix(); <br>ret(0, 0) = a; <br>ret(1, 1) = b; <br>ret(2, 2) = c; <br>return ret; <br>} // end ScaleMatrix <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       ScaleMatrix <br>**  Purpose:scale matrix <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>D3DMATRIX  <br>ScaleMatrix(const D3DVECTOR&amp; v) <br>{ <br>    D3DMATRIX ret = IdentityMatrix(); <br>ret(0, 0) = v.x; <br>ret(1, 1) = v.y; <br>ret(2, 2) = v.z; <br>return ret; <br>} // end ScaleMatrix <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       MatrixMult <br>**  Purpose:[C] = [A] * [B] <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>D3DMATRIX <br>MatrixMult(const D3DMATRIX &amp; a, const D3DMATRIX &amp; b) <br>{ <br>D3DMATRIX ret = ZeroMatrix(); <br> <br>for (int i=0; i&lt;4; i++) { <br>for (int j=0; j&lt;4; j++) { <br>for (int k=0; k&lt;4; k++) { <br>ret(i, j) += a(k, j) * b(i, k); <br>} <br>} <br>} <br>return ret; <br>} // end MatrixMult <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       TransformVector <br>**  Purpose:V' = V * [M] <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>D3DVECTOR  <br>TransformVector(const D3DVECTOR&amp; v, const D3DMATRIX &amp; m) <br>{ <br>floathvec[4]; <br> <br>for (int i=0; i&lt;4; i++) { <br>hvec[i] = 0.0f; <br>for (int j=0; j&lt;4; j++) { <br>if (j==3) { <br>hvec[i] += m(j, i); <br>} else { <br>hvec[i] += v[j] * m(j, i); <br>} <br>} <br>} <br>D3DVECTOR ret(hvec[0]/hvec[3], hvec[1]/hvec[3], hvec[2]/hvec[3]); <br> <br>return ret; <br>} // end TransformVector <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       TransformNormal <br>**  Purpose:N' = N * [M] <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>D3DVECTOR <br>TransformNormal(const D3DVECTOR&amp; v, const D3DMATRIX &amp; mat) <br>{ <br>D3DMATRIXm; <br> <br>m = MatrixInverse(mat); <br>m = MatrixTranspose(m); <br>return TransformVector(v, m); <br>}  // end TransformNormal <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       MatrixInverse <br>**  Purpose:Creates the inverse of a 4x4 matrix <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>static voidlubksb(D3DMATRIX &amp; a, int *indx, float *b); <br>static void ludcmp(D3DMATRIX &amp; a, int *indx, float *d); <br> <br>D3DMATRIX    <br>MatrixInverse(const D3DMATRIX &amp; m) <br>{ <br>D3DMATRIXn, y; <br>inti, j, indx[4]; <br>floatd, col[4]; <br> <br>n = m; <br>ludcmp(n, indx, &amp;d); <br> <br>for (j=0; j&lt;4; j++) { <br>for (i=0; i&lt;4; i++) { <br>col[i] = 0.0f; <br>} <br>col[j] = 1.0f; <br>lubksb(n, indx, col); <br>for (i=0; i&lt;4; i++) { <br>y(i, j) = col[i]; <br>} <br>} <br>return y; <br>} // end MatrixInverse <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       lubksb <br>**  Purpose:backward subsitution <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>static void  <br>lubksb(D3DMATRIX &amp; a, int *indx, float *b) <br>{ <br>inti, j, ii=-1, ip; <br>floatsum; <br> <br>for (i=0; i&lt;4; i++) { <br>ip = indx[i]; <br>sum = b[ip]; <br>b[ip] = b[i]; <br>if (ii&gt;=0) { <br>for (j=ii; j&lt;=i-1; j++) { <br>sum -= a(i, j) * b[j]; <br>} <br>} else if (sum != 0.0) { <br>ii = i; <br>} <br>b[i] = sum; <br>} <br>for (i=3; i&gt;=0; i--) { <br>sum = b[i]; <br>for (j=i+1; j&lt;4; j++) { <br>sum -= a(i, j) * b[j]; <br>} <br>b[i] = sum/a(i, i); <br>} <br>} // end lubksb <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       ludcmp <br>**  Purpose:LU decomposition <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>static void  <br>ludcmp(D3DMATRIX &amp; a, int *indx, float *d) <br>{ <br>floatvv[4];               /* implicit scale for each row */ <br>floatbig, dum, sum, tmp; <br>inti, imax, j, k; <br> <br>*d = 1.0f; <br>for (i=0; i&lt;4; i++) { <br>big = 0.0f; <br>for (j=0; j&lt;4; j++) { <br>if ((tmp = (float) fabs(a(i, j))) &gt; big) { <br>big = tmp; <br>} <br>} <br>/* <br>if (big == 0.0f) { <br>printf("ludcmp(): singular matrix found...\n"); <br>exit(1); <br>} <br>*/ <br>vv[i] = 1.0f/big; <br>} <br>for (j=0; j&lt;4; j++) { <br>for (i=0; i&lt;j; i++) { <br>sum = a(i, j); <br>for (k=0; k&lt;i; k++) { <br>sum -= a(i, k) * a(k, j); <br>} <br>a(i, j) = sum; <br>} <br>big = 0.0f; <br>for (i=j; i&lt;4; i++) { <br>sum = a(i, j); <br>for (k=0; k&lt;j; k++) { <br>sum -= a(i, k)*a(k, j); <br>} <br>a(i, j) = sum; <br>if ((dum = vv[i] * (float)fabs(sum)) &gt;= big) { <br>big = dum; <br>imax = i; <br>} <br>} <br>if (j != imax) { <br>for (k=0; k&lt;4; k++) { <br>dum = a(imax, k); <br>a(imax, k) = a(j, k); <br>a(j, k) = dum; <br>} <br>*d = -(*d); <br>vv[imax] = vv[j]; <br>} <br>indx[j] = imax; <br>if (a(j, j) == 0.0f) { <br>a(j, j) = 1.0e-20f;      /* can be 0.0 also... */ <br>} <br>if (j != 3) { <br>dum = 1.0f/a(j, j); <br>for (i=j+1; i&lt;4; i++) { <br>a(i, j) *= dum; <br>} <br>} <br>} <br>} // end ludcmp <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       Matrix Transpose <br>**  Purpose:[M] = [M]' <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>D3DMATRIX  <br>MatrixTranspose(const D3DMATRIX &amp; m) <br>{ <br>D3DMATRIXret; <br>inti, j; <br> <br>for (i=0; i&lt;4; i++) { <br>for (j=0; j&lt;4; j++) { <br>ret(i, j) = m(j, i); <br>} <br>} <br> <br>return ret; <br>} // end MatrixTranspose <br> <br>/* <br>Class Methods <br>*/ <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       Light::Light <br>**  Purpose:Constructor <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>Light::Light(LPDIRECT3D2 lpD3D) <br>{ <br>    memset(&amp;light, 0, sizeof(D3DLIGHT2)); <br>light.dwSize = sizeof(D3DLIGHT2); <br>    lpD3D-&gt;CreateLight(&amp;lpD3DLight, NULL); <br>changed = 1; <br> <br>// default to no attenuation with distance <br>    light.dvAttenuation0 = 1.0f; <br>    light.dvAttenuation1 = 0.0f; <br>    light.dvAttenuation2 = 0.0f; <br>// default to no max distance <br>light.dvRange = D3DLIGHT_RANGE_MAX; <br>// default to linear ramp from inner to outer cone <br>light.dvFalloff = 1.0f; <br>// default to on <br>light.dwFlags = D3DLIGHT_ACTIVE; <br>} // end of Light::Light <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       Light::~Light <br>**  Purpose:Destructor <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>Light::~Light() <br>{ <br>if (lpD3DLight) { <br>lpD3DLight-&gt;Release(); <br>lpD3DLight = NULL; <br>} <br>} // end Light::~Light <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       PointLight::PointLight <br>**  Purpose:Constructor <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>PointLight::PointLight(LPDIRECT3D2lpD3D,  <br>   const D3DVECTOR&amp;color,  <br>   const D3DVECTOR&amp;position) : Light(lpD3D) <br>{ <br>    light.dltType = D3DLIGHT_POINT; <br>    light.dcvColor.r = color[0]; <br>    light.dcvColor.g = color[1]; <br>    light.dcvColor.b = color[2]; <br>    light.dvPosition.x = position[0]; <br>    light.dvPosition.y = position[1]; <br>    light.dvPosition.z = position[2]; <br> <br>changed = 1; <br>} // end PointLight::PointLight <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       SpotLight::SpotLight <br>**  Purpose:Constructor <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>SpotLight::SpotLight(LPDIRECT3D2lpD3D,  <br> const D3DVECTOR&amp;color,  <br> const D3DVECTOR&amp;position,  <br> const D3DVECTOR&amp;direction,  <br> const floatumbra_angle, <br> const floatpenumbra_angle) : Light(lpD3D) <br>{ <br>    light.dltType = D3DLIGHT_SPOT; <br>    light.dcvColor.r = color[0]; <br>    light.dcvColor.g = color[1]; <br>    light.dcvColor.b = color[2]; <br>    light.dvPosition.x = position[0]; <br>    light.dvPosition.y = position[1]; <br>    light.dvPosition.z = position[2]; <br>    light.dvDirection.x = direction[0]; <br>    light.dvDirection.y = direction[1]; <br>    light.dvDirection.z = direction[2]; <br>light.dvTheta = umbra_angle; <br>light.dvPhi = penumbra_angle; <br> <br>changed = 1; <br>} // end of SpotLight::SpotLight <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DirectionalLight::DirectionalLight <br>**  Purpose:Constructor <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>DirectionalLight::DirectionalLight(LPDIRECT3D2lpD3D,  <br>   const D3DVECTOR&amp;color,  <br>   const D3DVECTOR&amp;direction) : Light(lpD3D) <br>{ <br>    light.dltType = D3DLIGHT_DIRECTIONAL; <br>    light.dcvColor.r = color[0]; <br>    light.dcvColor.g = color[1]; <br>    light.dcvColor.b = color[2]; <br>    light.dvDirection.x = direction[0]; <br>    light.dvDirection.y = direction[1]; <br>    light.dvDirection.z = direction[2]; <br> <br>changed = 1; <br>}// end of DirectionalLight::DirectionalLight <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       ParallelLight::ParallelLight <br>**  Purpose:Constructor <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>ParallelPointLight::ParallelPointLight(LPDIRECT3D2lpD3D,  <br>   const D3DVECTOR&amp;color,  <br>   const D3DVECTOR&amp;position) : Light(lpD3D) <br>{ <br>    light.dltType = D3DLIGHT_PARALLELPOINT; <br>    light.dcvColor.r = color[0]; <br>    light.dcvColor.g = color[1]; <br>    light.dcvColor.b = color[2]; <br>    light.dvPosition.x = position[0]; <br>    light.dvPosition.y = position[1]; <br>    light.dvPosition.z = position[2]; <br> <br>changed = 1; <br>} // end of ParallelPointLight::ParallelPointLight constructor <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       Material::Material <br>**  Purpose:Constructor <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>Material::Material(LPDIRECT3D2 lpD3D, LPDIRECT3DDEVICE2 lpDev) <br>{ <br>    memset(&amp;Mat, 0, sizeof(D3DMATERIAL)); <br>Mat.dwSize = sizeof(D3DMATERIAL); <br> <br>// leave the default material black <br> <br>    Mat.dwRampSize = 16; <br>Mat.diffuse.a = 1.0f; <br> <br>lpD3D-&gt;CreateMaterial(&amp;lpMat, NULL); <br>    lpMat-&gt;SetMaterial(&amp;Mat); <br>    lpMat-&gt;GetHandle(lpDev, &amp;hMat); <br> <br>changed = 1; <br>Set(); <br>} // end of Material::Material <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       Material::~Material <br>**  Purpose:Destructor <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>Material::~Material() <br>{ <br>if (lpMat) { <br>lpMat-&gt;Release(); <br>lpMat = NULL; <br>} <br>} // end of Material::~Material <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       rnd <br>**  Purpose:Returns a random number (float) in the range [0.0 - 1.0] <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>float  <br>rnd(void) <br>{ <br>return float(rand())/RAND_MAX; <br>}// end of rnd() <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  end of File <br>**----------------------------------------------------------------------------- <br>*/ <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
