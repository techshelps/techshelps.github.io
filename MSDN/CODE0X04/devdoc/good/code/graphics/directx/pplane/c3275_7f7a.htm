<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PPLANE.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3286"></a>PPLANE.CPP</h2>
<pre><code>/* <br>**----------------------------------------------------------------------------- <br>**  File:       PPlane.cpp <br>**  Purpose:    Paper plane demo <br>**  Notes:Sample demonstrating D3DLVERTEX's, DrawPrimitive,  <br>**and SetTransform <br>** <br>** Copyright (c) 1995 - 1997 by Microsoft, all rights reserved <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**Include files <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>#include "Common.h" <br>#include "Debug.h" <br>#include "D3DScene.h" <br>#include &lt;time.h&gt; <br>#include "d3dutils.h" <br>#include "pplane.h" <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**Local variables <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LPDIRECT3DMATERIAL2 g_lpmatBackground, g_lpMat; <br> <br>extern const float pi; <br> <br>//#define POINT_LINE_TEST <br>#define GROUND_GRID <br>DWORDg_hBackTex; <br>DWORDg_hTex; <br>DWORDg_hBackMat; <br>DWORDg_hMat; <br> <br>#define NUM_PLANES42 <br>Planeplanes[NUM_PLANES]; <br> <br>#define PPLANE_VERTICES36 <br>#define PPLANE_INDICES60 <br>D3DVERTEXpplane[PPLANE_VERTICES]; <br>WORDpplane_indices[PPLANE_INDICES]; <br> <br>#ifdef GROUND_GRID <br>#define NUM_GRID22 <br>#define GRID_WIDTH800.0f <br>D3DVERTEXgrid[NUM_GRID*NUM_GRID]; <br>#endif <br> <br>#ifdef POINT_LINE_TEST <br>#define LOTS_OF_POINTS(222) <br>D3DVERTEXpoints[LOTS_OF_POINTS]; <br>#endif <br> <br> <br>D3DMATRIXg_proj, g_view, g_world;// Matrices <br> <br>D3DLIGHTg_light;// Structure defining the light <br>LPDIRECT3DLIGHTg_lpD3DLight;// Object pointer for the light <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**Local prototypes <br>**----------------------------------------------------------------------------- <br>*/ <br> <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**D3DScene Methods <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>/* <br>**---------------------------------------------------------------------------- <br>** Name:        D3DScene::D3DScene <br>** Purpose:Default Constructor <br>**---------------------------------------------------------------------------- <br>*/ <br> <br>D3DScene::D3DScene (void) <br>{ <br>lpd3dWindow = NULL; <br>} // End D3DScene::D3DScene <br> <br> <br>   <br>/* <br>**---------------------------------------------------------------------------- <br>** Name:        D3DScene::~D3DScene <br>** Purpose:Default Destructor <br>**---------------------------------------------------------------------------- <br>*/ <br> <br>D3DScene::~D3DScene (void) <br>{ <br>Fini (); <br>lpd3dWindow = NULL; <br>} // End D3DScene::~D3DScene <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DrawPPlane <br>**  Purpose:Draws a single Paper plane <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT <br>DrawPPlane (LPDIRECT3DDEVICE2 lpDev) <br>{ <br>HRESULT hResult; <br> <br>#ifdef POINT_LINE_TEST <br>        hResult = lpDev-&gt;DrawPrimitive (D3DPT_LINESTRIP, D3DVT_VERTEX, (LPVOID)points, LOTS_OF_POINTS, D3DDP_WAIT); <br>    if (FAILED (hResult)) <br>{ <br>        REPORTERR (hResult); <br>return hResult; <br>} <br>#endif <br> <br>        hResult =lpDev-&gt;DrawIndexedPrimitive (D3DPT_TRIANGLELIST, D3DVT_VERTEX, (LPVOID)pplane, PPLANE_VERTICES, pplane_indices, PPLANE_INDICES, D3DDP_WAIT); <br>    if (FAILED (hResult)) <br>{ <br>        REPORTERR (hResult); <br>return hResult; <br>} <br> <br>// Success <br>return hResult; <br>} <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       D3DWindow::Init <br>**  Purpose:Initialize scene objects <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DScene::Init (LPD3DWindow lpd3dWin) <br>{ <br>HRESULT hResult; <br> <br>// Check Parameters <br>if (! lpd3dWin) <br>{ <br>REPORTERR (DDERR_INVALIDPARAMS); <br>return DDERR_INVALIDPARAMS; <br>} <br> <br>// Save pointer to D3D Window <br>lpd3dWindow = lpd3dWin; <br> <br> <br>// <br>// generate the paper plane data <br>// <br> <br>// right wing top <br>pplane[ 0] = D3DVERTEX(D3DVECTOR(0.125f, 0.03125f, 3.5f), Normalize(D3DVECTOR(-0.25f, 1.0f, 0.0f)), rnd(), rnd()); <br>pplane[ 1] = D3DVERTEX(D3DVECTOR(0.75f, 0.1875f, 3.25f), Normalize(D3DVECTOR(-0.25f, 1.0f, 0.0f)), rnd(), rnd()); <br>pplane[ 2] = D3DVERTEX(D3DVECTOR(2.75f, 0.6875f, -2.0f), Normalize(D3DVECTOR(-0.25f, 1.0f, 0.0f)), rnd(), rnd()); <br>pplane[ 3] = D3DVERTEX(D3DVECTOR(2.0f, 0.5f, -4.25f), Normalize(D3DVECTOR(-0.25f, 1.0f, 0.0f)), rnd(), rnd()); <br>pplane[ 4] = D3DVERTEX(D3DVECTOR(0.5f, 0.125f, -3.5f), Normalize(D3DVECTOR(-0.25f, 1.0f, 0.0f)), rnd(), rnd()); <br> <br>// right wing bottom <br>pplane[ 5] = D3DVERTEX(D3DVECTOR(0.125f, 0.03125f, 3.5f), Normalize(D3DVECTOR(0.25f, -1.0f, 0.0f)), rnd(), rnd()); <br>pplane[ 6] = D3DVERTEX(D3DVECTOR(0.75f, 0.1875f, 3.25f), Normalize(D3DVECTOR(0.25f, -1.0f, 0.0f)), rnd(), rnd()); <br>pplane[ 7] = D3DVERTEX(D3DVECTOR(2.75f, 0.6875f, -2.0f), Normalize(D3DVECTOR(0.25f, -1.0f, 0.0f)), rnd(), rnd()); <br>pplane[ 8] = D3DVERTEX(D3DVECTOR(2.0f, 0.5f, -4.25f), Normalize(D3DVECTOR(0.25f, -1.0f, 0.0f)), rnd(), rnd()); <br>pplane[ 9] = D3DVERTEX(D3DVECTOR(0.5f, 0.125f, -3.5f), Normalize(D3DVECTOR(0.25f, -1.0f, 0.0f)), rnd(), rnd()); <br> <br>// left wing bottom <br>pplane[10] = D3DVERTEX(D3DVECTOR(-0.125f, 0.03125f, 3.5f), Normalize(D3DVECTOR(-0.25f, -1.0f, 0.0f)), rnd(), rnd()); <br>pplane[11] = D3DVERTEX(D3DVECTOR(-0.75f, 0.1875f, 3.25f), Normalize(D3DVECTOR(-0.25f, -1.0f, 0.0f)), rnd(), rnd()); <br>pplane[12] = D3DVERTEX(D3DVECTOR(-2.75f, 0.6875f, -2.0f), Normalize(D3DVECTOR(-0.25f, -1.0f, 0.0f)), rnd(), rnd()); <br>pplane[13] = D3DVERTEX(D3DVECTOR(-2.0f, 0.5f, -4.25f), Normalize(D3DVECTOR(-0.25f, -1.0f, 0.0f)), rnd(), rnd()); <br>pplane[14] = D3DVERTEX(D3DVECTOR(-0.5f, 0.125f, -3.5f), Normalize(D3DVECTOR(-0.25f, -1.0f, 0.0f)), rnd(), rnd()); <br> <br>// left wing top <br>pplane[15] = D3DVERTEX(D3DVECTOR(-0.125f, 0.03125f, 3.5f), Normalize(D3DVECTOR(0.25f, 1.0f, 0.0f)), rnd(), rnd()); <br>pplane[16] = D3DVERTEX(D3DVECTOR(-0.75f, 0.1875f, 3.25f), Normalize(D3DVECTOR(0.25f, 1.0f, 0.0f)), rnd(), rnd()); <br>pplane[17] = D3DVERTEX(D3DVECTOR(-2.75f, 0.6875f, -2.0f), Normalize(D3DVECTOR(0.25f, 1.0f, 0.0f)), rnd(), rnd()); <br>pplane[18] = D3DVERTEX(D3DVECTOR(-2.0f, 0.5f, -4.25f), Normalize(D3DVECTOR(0.25f, 1.0f, 0.0f)), rnd(), rnd()); <br>pplane[19] = D3DVERTEX(D3DVECTOR(-0.5f, 0.125f, -3.5f), Normalize(D3DVECTOR(0.25f, 1.0f, 0.0f)), rnd(), rnd()); <br> <br>// right body outside <br>pplane[20] = D3DVERTEX(D3DVECTOR(0.125f, 0.03125f, 3.5f), Normalize(D3DVECTOR(1.0f, -0.1f, 0.0f)), rnd(), rnd()); <br>pplane[21] = D3DVERTEX(D3DVECTOR(0.5f, 0.125f, -3.5f), Normalize(D3DVECTOR(1.0f, -0.1f, 0.0f)), rnd(), rnd()); <br>pplane[22] = D3DVERTEX(D3DVECTOR(0.0f, -2.25f, -2.75f), Normalize(D3DVECTOR(1.0f, -0.1f, 0.0f)), rnd(), rnd()); <br>pplane[23] = D3DVERTEX(D3DVECTOR(0.0f, -0.5f, 3.625f), Normalize(D3DVECTOR(1.0f, -0.1f, 0.0f)), rnd(), rnd()); <br> <br>// right body inside <br>pplane[24] = D3DVERTEX(D3DVECTOR(0.125f, 0.03125f, 3.5f), Normalize(D3DVECTOR(-1.0f, 0.1f, 0.0f)), rnd(), rnd()); <br>pplane[25] = D3DVERTEX(D3DVECTOR(0.5f, 0.125f, -3.5f), Normalize(D3DVECTOR(-1.0f, 0.1f, 0.0f)), rnd(), rnd()); <br>pplane[26] = D3DVERTEX(D3DVECTOR(0.0f, -2.25f, -2.75f), Normalize(D3DVECTOR(-1.0f, 0.1f, 0.0f)), rnd(), rnd()); <br>pplane[27] = D3DVERTEX(D3DVECTOR(0.0f, -0.5f, 3.625f), Normalize(D3DVECTOR(-1.0f, 0.1f, 0.0f)), rnd(), rnd()); <br> <br>// left body outside <br>pplane[28] = D3DVERTEX(D3DVECTOR(-0.125f, 0.03125f, 3.5f), Normalize(D3DVECTOR(-1.0f, -0.1f, 0.0f)), rnd(), rnd()); <br>pplane[29] = D3DVERTEX(D3DVECTOR(-0.5f, 0.125f, -3.5f), Normalize(D3DVECTOR(-1.0f, -0.1f, 0.0f)), rnd(), rnd()); <br>pplane[30] = D3DVERTEX(D3DVECTOR(0.0f, -2.25f, -2.75f), Normalize(D3DVECTOR(-1.0f, -0.1f, 0.0f)), rnd(), rnd()); <br>pplane[31] = D3DVERTEX(D3DVECTOR(0.0f, -0.5f, 3.625f), Normalize(D3DVECTOR(-1.0f, -0.1f, 0.0f)), rnd(), rnd()); <br> <br>// left body inside <br>pplane[32] = D3DVERTEX(D3DVECTOR(-0.125f, 0.03125f, 3.5f), Normalize(D3DVECTOR(1.0f, 0.1f, 0.0f)), rnd(), rnd()); <br>pplane[33] = D3DVERTEX(D3DVECTOR(-0.5f, 0.125f, -3.5f), Normalize(D3DVECTOR(1.0f, 0.1f, 0.0f)), rnd(), rnd()); <br>pplane[34] = D3DVERTEX(D3DVECTOR(0.0f, -2.25f, -2.75f), Normalize(D3DVECTOR(1.0f, 0.1f, 0.0f)), rnd(), rnd()); <br>pplane[35] = D3DVERTEX(D3DVECTOR(0.0f, -0.5f, 3.625f), Normalize(D3DVECTOR(1.0f, 0.1f, 0.0f)), rnd(), rnd()); <br> <br>// right wing top <br>pplane_indices[ 0] = 0; <br>pplane_indices[ 1] = 1; <br>pplane_indices[ 2] = 4; <br>pplane_indices[ 3] = 1; <br>pplane_indices[ 4] = 2; <br>pplane_indices[ 5] = 4; <br>pplane_indices[ 6] = 4; <br>pplane_indices[ 7] = 2; <br>pplane_indices[ 8] = 3; <br> <br>// right wing bottom <br>pplane_indices[ 9] = 5; <br>pplane_indices[10] = 9; <br>pplane_indices[11] = 6; <br>pplane_indices[12] = 6; <br>pplane_indices[13] = 9; <br>pplane_indices[14] = 7; <br>pplane_indices[15] = 7; <br>pplane_indices[16] = 9; <br>pplane_indices[17] = 8; <br> <br>// left wing top <br>pplane_indices[18] = 10; <br>pplane_indices[19] = 11; <br>pplane_indices[20] = 14; <br>pplane_indices[21] = 11; <br>pplane_indices[22] = 12; <br>pplane_indices[23] = 14; <br>pplane_indices[24] = 14; <br>pplane_indices[25] = 12; <br>pplane_indices[26] = 13; <br> <br>// left wing bottom <br>pplane_indices[27] = 15; <br>pplane_indices[28] = 19; <br>pplane_indices[29] = 16; <br>pplane_indices[30] = 16; <br>pplane_indices[31] = 19; <br>pplane_indices[32] = 17; <br>pplane_indices[33] = 17; <br>pplane_indices[34] = 19; <br>pplane_indices[35] = 18; <br> <br>// right body outside <br>pplane_indices[36] = 20; <br>pplane_indices[37] = 23; <br>pplane_indices[38] = 21; <br>pplane_indices[39] = 21; <br>pplane_indices[40] = 23; <br>pplane_indices[41] = 22; <br> <br>// right body inside <br>pplane_indices[42] = 24; <br>pplane_indices[43] = 25; <br>pplane_indices[44] = 27; <br>pplane_indices[45] = 25; <br>pplane_indices[46] = 26; <br>pplane_indices[47] = 27; <br> <br>// left body outside <br>pplane_indices[48] = 28; <br>pplane_indices[49] = 29; <br>pplane_indices[50] = 31; <br>pplane_indices[51] = 29; <br>pplane_indices[52] = 30; <br>pplane_indices[53] = 31; <br> <br>// left body inside <br>pplane_indices[54] = 32; <br>pplane_indices[55] = 35; <br>pplane_indices[56] = 33; <br>pplane_indices[57] = 33; <br>pplane_indices[58] = 35; <br>pplane_indices[59] = 34; <br> <br>// seed the random number generator <br>srand (time (0)); <br> <br>for (int i=0; i&lt;NUM_PLANES; i++)  <br>{ <br>planes[i].loc = D3DVECTOR(0.0f, 0.0f, 0.0f); <br>planes[i].goal = D3DVECTOR(10.0f*(rnd()-rnd()), 10.0f*(rnd()-rnd()), 10.0f*(rnd()-rnd())); <br>planes[i].delta = D3DVECTOR(0.0f, 0.0f, 1.0f); <br>planes[i].yaw = 0.0f; <br>planes[i].pitch = 0.0f; <br>planes[i].roll = 0.0f; <br>planes[i].dyaw = 0.0f; <br>} <br> <br> <br>#ifdef POINT_LINE_TEST <br>for (i=0; i&lt;LOTS_OF_POINTS; i++)  <br>{ <br>float y = cos(pi*(double)i/LOTS_OF_POINTS); <br>float x = (float)sin (pi*20.0*(double)i/LOTS_OF_POINTS) * (1.0f-y*y); <br>float z = (float)cos (pi*20.0*(double)i/LOTS_OF_POINTS) * (1.0f-y*y); <br>D3DVECTORp(x, y, z); <br> <br>p = Normalize (p); <br>points[i] = _D3DVERTEX(10.0*p, p, rnd(), rnd()); <br>} <br>#endif <br> <br>#ifdef GROUND_GRID <br>floatsize = GRID_WIDTH/(NUM_GRID-1.0f); <br>floatoffset = GRID_WIDTH/2.0f; <br>for (i=0; i&lt;NUM_GRID; i++)  <br>{ <br>for (int j=0; j&lt;NUM_GRID; j++)  <br>{ <br>grid[j+i*NUM_GRID] = D3DVERTEX(D3DVECTOR(i*size-offset, 0.0f, j*size-offset), Normalize(D3DVECTOR(0.0f, 1.0f, 0.0f)), 0.0f, 0.0f); <br>} <br>} <br>#endif <br> <br>// Initialize Viewport <br>hResult = InitViewport (); <br>if (FAILED (hResult)) <br>return hResult; <br> <br>    return DD_OK; <br>} // End D3DScene::Init <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       D3DScene::Fini <br>**  Purpose:Cleanup scene objects <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DScene::Fini (void) <br>{ <br>FiniViewport (); <br> <br>// Success <br>return DD_OK; <br>} // End D3DScene::Fini <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       D3DScene::Render <br>**  Purpose:Draws scene <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DScene::Render (void) <br>{ <br>LPDIRECT3DDEVICE2lpDev; <br>LPDIRECT3DVIEWPORT2 lpView;  <br>RECTrSrc; <br>LPD3DRECTlpExtent = NULL; <br>    D3DRECTd3dRect; <br>D3DCLIPSTATUSstatus; <br>HRESULThResult; <br> <br>// Check Initialization <br>if ((! lpd3dWindow) || (! lpd3dWindow-&gt;isValid ())) <br>{ <br>// Error, <br>REPORTERR (DDERR_GENERIC); <br>return DDERR_GENERIC; <br>} <br> <br>lpDev= lpd3dWindow-&gt;lpd3dDevice; <br>lpView  = lpd3dWindow-&gt;lpd3dViewport; <br>lpd3dWindow-&gt;GetSrcRect (rSrc); <br> <br>     <br>// <br>    // Clear both back and z-buffer. <br>    // <br>    // NOTE: Its safe to specify the z-buffer clear flag even if we <br>    // don't have an attached z-buffer. Direct3D will simply discard <br>    // the flag if no z-buffer is being used. <br>    // <br>    // NOTE: For maximum efficiency we only want to clear those <br>    // regions of the device surface and z-buffer which we actually <br>    // rendered to in the last frame. This is the purpose of the <br>    // array of rectangles and count passed to this function. It is <br>    // possible to query Direct3D for the regions of the device <br>    // surface that were rendered to by that execute. The application <br>    // can then accumulate those rectangles and clear only those <br>    // regions. However this is a very simple sample and so, for <br>    // simplicity, we will just clear the entire device surface and <br>    // z-buffer. Probably not something you wan't to do in a real <br>    // application. <br>    /// <br>d3dRect.lX1 = rSrc.left; <br>d3dRect.lX2 = rSrc.right; <br>d3dRect.lY1 = rSrc.top; <br>d3dRect.lY2 = rSrc.bottom; <br>hResult = lpView-&gt;Clear (1UL, &amp;d3dRect, <br> D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER); <br>if (FAILED (hResult)) <br>{ <br>REPORTERR (hResult); <br>return hResult; <br>} <br> <br>// Calculate exclude region <br>if (lpExtent) <br>{ <br>status.dwFlags = D3DCLIPSTATUS_EXTENTS2; <br>status.dwStatus = 0; <br>status.minx = (float)lpExtent-&gt;x1; <br>status.maxx = (float)lpExtent-&gt;x2; <br>status.miny = (float)lpExtent-&gt;y1; <br>status.maxy = (float)lpExtent-&gt;y2; <br>status.minz = 0.0f; <br>status.maxz = 0.0f; <br>} <br> <br>hResult = lpDev-&gt;BeginScene (); <br>if (FAILED (hResult)) <br>{ <br>        REPORTERR (hResult); <br>return hResult; <br>} <br> <br>// Exclude text region <br>if (lpExtent) <br>{ <br>hResult = lpDev-&gt;SetClipStatus (&amp;status); <br>if (FAILED (hResult)) <br>{ <br>        REPORTERR (hResult); <br>return hResult; <br>} <br>} <br> <br>    hResult = lpDev-&gt;SetLightState (D3DLIGHTSTATE_MATERIAL, g_hMat); <br>if (FAILED (hResult)) <br>{ <br>        REPORTERR (hResult); <br>return hResult; <br>} <br> <br>    hResult = lpDev-&gt;SetRenderState (D3DRENDERSTATE_ZENABLE, 1); <br>if (FAILED (hResult)) <br>{ <br>        REPORTERR (hResult); <br>return hResult; <br>} <br> <br>    hResult = lpDev-&gt;SetRenderState (D3DRENDERSTATE_TEXTUREHANDLE, 0); <br>if (FAILED (hResult)) <br>{ <br>        REPORTERR (hResult); <br>return hResult; <br>} <br> <br>// turn on some ambient light <br>    hResult = lpDev-&gt;SetLightState (D3DLIGHTSTATE_AMBIENT, RGBA_MAKE(60, 60, 60, 60)); <br>if (FAILED (hResult)) <br>{ <br>        REPORTERR (hResult); <br>return hResult; <br>} <br> <br>// set the projection matrix <br>g_proj = ProjectionMatrix (10.0f, 500.0f, pi/2.0f); <br>hResult = lpDev-&gt;SetTransform (D3DTRANSFORMSTATE_PROJECTION, &amp;g_proj); <br>if (FAILED (hResult)) <br>{ <br>        REPORTERR (hResult); <br>return hResult; <br>} <br> <br>// play with planes <br>static floattic = 0.0f; <br>static floatspeed=2.0f; <br>static floatangle_tweak = 0.02f; <br>static D3DVECTORz_ward(0.0f, 0.0f, 1.0f); <br> <br>for (int i=0; i&lt;NUM_PLANES; i++)  <br>{ <br>D3DVECTORoffset; <br> <br>// tweek orientation based on last position and goal <br>offset = planes[i].goal - planes[i].loc; <br> <br>// first, tweak the pitch <br>if (offset.y &gt; 1.0) {// we're too low <br>planes[i].pitch += angle_tweak; <br>if (planes[i].pitch &gt; 0.8f) <br>planes[i].pitch = 0.8f; <br>} else if (offset.y &lt; -1.0) {// we're too high <br>planes[i].pitch -= angle_tweak; <br>if (planes[i].pitch &lt; -0.8f) <br>planes[i].pitch = -0.8f; <br>} else { <br>// add damping <br>planes[i].pitch *= 0.95f; <br>} <br> <br>// now figure out yaw changes <br>offset.y = 0.0f;  planes[i].delta.y = 0.0f; <br>planes[i].delta = Normalize (planes[i].delta); <br>offset = Normalize (offset); <br>floatdot = DotProduct (offset, planes[i].delta); <br>offset = CrossProduct (offset, planes[i].delta); <br>dot = (1.0f-dot)/2.0f * angle_tweak * 10.0f; <br>if (offset.y &gt; 0.01) { <br>planes[i].dyaw = (planes[i].dyaw*9.0f + dot) * 0.1f; <br>} else if (offset.y &lt; 0.01) { <br>planes[i].dyaw = (planes[i].dyaw*9.0f - dot) * 0.1f; <br>} <br>planes[i].yaw += planes[i].dyaw; <br>planes[i].roll = -planes[i].dyaw * 9.0f; <br> <br>if (rnd() &lt; 0.03)  <br>{ <br>planes[i].goal = D3DVECTOR(60.0f*(rnd()-rnd()), 60.0f*(rnd()-rnd()), rnd()*300.0f - 100.0f); <br>} <br> <br>// build the world matrix for the pplane <br>g_world = MatrixMult (MatrixMult (RotateYMatrix (planes[i].yaw), RotateXMatrix (planes[i].pitch)), RotateZMatrix (planes[i].roll)); <br> <br>// get delta buy grabbing the z axis out of the transform <br>planes[i].delta[0] = g_world(2, 0); <br>planes[i].delta[1] = g_world(2, 1); <br>planes[i].delta[2] = g_world(2, 2); <br>// update position <br>planes[i].loc += speed * planes[i].delta; <br> <br>// before we draw the first plane use it's position to update the camera <br>if (i==0)  <br>{ <br>D3DVECTORfrom, at, local_up; <br>D3DVECTORup(0.0f, 1.0f, 0.0f); <br> <br>local_up[0] = g_world(1, 0); <br>local_up[1] = g_world(1, 1); <br>local_up[2] = g_world(1, 2); <br>from = planes[0].loc - 20.0f * planes[0].delta + 6.0f * local_up; <br>at = planes[0].loc + planes[0].delta; <br> <br>g_view = ViewMatrix (from, at, up, planes[0].roll); <br>hResult = lpDev-&gt;SetTransform (D3DTRANSFORMSTATE_VIEW, &amp;g_view); <br>if (FAILED (hResult)) <br>{ <br>REPORTERR (hResult); <br>return hResult; <br>} <br>} <br> <br>// first translate into place, then set orientation, then scale <br>g_world = TranslateMatrix (planes[i].loc); <br>g_world = MatrixMult (g_world, MatrixMult (MatrixMult (RotateYMatrix (planes[i].yaw), RotateXMatrix (planes[i].pitch)), RotateZMatrix (planes[i].roll))); <br>//g_world = MatrixMult (g_world, Scale(5.0f)); <br> <br>// apply the world matrix <br>hResult = lpDev-&gt;SetTransform (D3DTRANSFORMSTATE_WORLD, &amp;g_world); <br>if (FAILED (hResult)) <br>{ <br>    REPORTERR (hResult); <br>return hResult; <br>} <br> <br>// display the pplane <br>DrawPPlane (lpDev); <br>}// end of loop for each pplane <br> <br>#ifdef GROUND_GRID <br>g_world = TranslateMatrix (0.0f, -60.0f, 0.0f); <br>hResult = lpDev-&gt;SetTransform (D3DTRANSFORMSTATE_WORLD, &amp;g_world); <br>if (FAILED (hResult)) <br>{ <br>        REPORTERR (hResult); <br>return hResult; <br>} <br> <br>        hResult = lpDev-&gt;DrawPrimitive (D3DPT_LINELIST, D3DVT_VERTEX, (LPVOID)grid, NUM_GRID*NUM_GRID, D3DDP_WAIT); <br>if (FAILED (hResult)) <br>{ <br>        REPORTERR (hResult); <br>return hResult; <br>} <br> <br>g_world = MatrixMult (g_world, RotateYMatrix (pi/2.0f)); <br>hResult = lpDev-&gt;SetTransform (D3DTRANSFORMSTATE_WORLD, &amp;g_world); <br>if (FAILED (hResult)) <br>{ <br>        REPORTERR (hResult); <br>return hResult; <br>} <br> <br>        hResult = lpDev-&gt;DrawPrimitive (D3DPT_LINELIST, D3DVT_VERTEX, (LPVOID)grid, NUM_GRID*NUM_GRID, D3DDP_WAIT); <br>if (FAILED (hResult)) <br>{ <br>        REPORTERR (hResult); <br>return hResult; <br>} <br>#endif <br> <br>tic += 0.01f; <br> <br>if (lpExtent) <br>{ <br>hResult = lpDev-&gt;GetClipStatus (&amp;status); <br>if (FAILED (hResult)) <br>{ <br>REPORTERR (hResult); <br>return hResult; <br>} <br>} <br> <br>    hResult = lpDev-&gt;EndScene (); <br>if (FAILED (hResult)) <br>{ <br>        REPORTERR (hResult); <br>return hResult; <br>} <br> <br>if (lpExtent) <br>{ <br>// return clip status in extent struct <br>if (status.dwFlags &amp; D3DCLIPSTATUS_EXTENTS2) <br>{ <br>lpExtent-&gt;x1 = (long)floor ((double)status.minx); <br>lpExtent-&gt;x2 = (long)ceil ((double)status.maxx); <br>lpExtent-&gt;y1 = (long)floor ((double)status.miny); <br>lpExtent-&gt;y2 = (long)ceil ((double)status.maxy); <br>} <br>} <br> <br>// Success <br>    return DD_OK; <br>} // End D3DScene::Render <br> <br> <br>   <br>/* <br>**---------------------------------------------------------------------------- <br>** Name:        D3DScene::Restore <br>** Purpose:     Restore any scene specific surfaces that might have been <br>**lost on a DDERR_LOSTSURFACE message <br>**---------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DScene::Restore (void) <br>{ <br>// Nothing to do for now <br> <br>// Success <br>return DD_OK; <br>} // End D3DScene::Restore <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       D3DScene::InitViewport <br>**  Purpose:Initialize Viewport <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DScene::InitViewport (void) <br>{ <br>LPDIRECT3D2lpD3D; <br>LPDIRECT3DDEVICE2   lpDev; <br>LPDIRECT3DVIEWPORT2 lpViewport; <br>HRESULThResult; <br>    D3DMATERIALmatBackground, mat; <br>    D3DMATERIALHANDLEhBackMat, hMat; <br> <br>// Check Initialization <br>if ((! lpd3dWindow) || (! lpd3dWindow-&gt;isValid ())) <br>{ <br>// Error, <br>REPORTERR (DDERR_GENERIC); <br>return DDERR_GENERIC; <br>} <br> <br>lpD3D  = lpd3dWindow-&gt;lpD3D; <br>lpDev  = lpd3dWindow-&gt;lpd3dDevice; <br>lpViewport = lpd3dWindow-&gt;lpd3dViewport; <br> <br>if ((! lpD3D) || (! lpDev) || (! lpViewport)) <br>{ <br>REPORTERR (DDERR_GENERIC); <br>return DDERR_GENERIC; <br>} <br>    <br>// Create and set up the background material <br>    hResult = lpD3D-&gt;CreateMaterial (&amp;g_lpmatBackground, NULL); <br>if (FAILED (hResult)) <br>{ <br>        REPORTERR (hResult); <br>return hResult; <br>    } <br> <br>    memset (&amp;matBackground, 0, sizeof(D3DMATERIAL)); <br>    matBackground.dwSize = sizeof(D3DMATERIAL); <br>    matBackground.diffuse.r = (D3DVALUE)0.2; <br>    matBackground.diffuse.g = (D3DVALUE)0.6; <br>    matBackground.diffuse.b = (D3DVALUE)1.0; <br>    matBackground.ambient.r = (D3DVALUE)1.0; <br>    matBackground.ambient.g = (D3DVALUE)1.0; <br>    matBackground.ambient.b = (D3DVALUE)1.0; <br>//    matBackground.hTexture = hBackTex; <br>matBackground.dwRampSize = 1; <br>     <br>hResult = g_lpmatBackground-&gt;SetMaterial (&amp;matBackground); <br>if (FAILED (hResult)) <br>{ <br>REPORTERR (hResult); <br>return hResult; <br>} <br>     <br>hResult = g_lpmatBackground-&gt;GetHandle (lpDev, &amp;hBackMat); <br>if (FAILED (hResult)) <br>{ <br>REPORTERR (hResult); <br>return hResult; <br>} <br> <br>    hResult = lpViewport-&gt;SetBackground (hBackMat); <br>if (FAILED (hResult)) <br>{ <br>REPORTERR (hResult); <br>return hResult; <br>} <br> <br>g_hBackMat = hBackMat; <br> <br>// create and set up the plane material <br>    hResult = lpD3D-&gt;CreateMaterial (&amp;g_lpMat, NULL); <br>if (FAILED (hResult)) <br>{ <br>        REPORTERR (hResult); <br>return hResult; <br>    } <br> <br>    memset(&amp;mat, 0, sizeof(D3DMATERIAL)); <br>    mat.dwSize = sizeof(D3DMATERIAL); <br>    mat.diffuse.r = (D3DVALUE)1.0; <br>    mat.diffuse.g = (D3DVALUE)1.0; <br>    mat.diffuse.b = (D3DVALUE)1.0; <br>    mat.ambient.r = (D3DVALUE)1.0; <br>    mat.ambient.g = (D3DVALUE)1.0; <br>    mat.ambient.b = (D3DVALUE)1.0; <br>#define SPECULAR <br>#ifdef SPECULAR <br>    mat.specular.r = (D3DVALUE)1.0; <br>    mat.specular.g = (D3DVALUE)1.0; <br>    mat.specular.b = (D3DVALUE)1.0; <br>    mat.power = (float)40.0; <br>#else <br>    mat.specular.r = (D3DVALUE)0.0; <br>    mat.specular.g = (D3DVALUE)0.0; <br>    mat.specular.b = (D3DVALUE)0.0; <br>    mat.power = (float)0.0; <br>#endif     <br>//    mat.hTexture = hTexure; <br>    mat.dwRampSize = 16; <br>    g_lpMat-&gt;SetMaterial (&amp;mat); <br>    g_lpMat-&gt;GetHandle (lpDev, &amp;hMat); <br>g_hMat= (DWORD) hMat; <br>//g_hTex= hTexure; <br> <br>//g_view = ViewMatrix(100.0f); <br>g_proj = ProjectionMatrix (1.0f, 1000.0f, 90.0f); <br>g_world = IdentityMatrix (); <br> <br>// set up the light <br>    memset (&amp;g_light, 0, sizeof(D3DLIGHT)); <br>    g_light.dwSize = sizeof(D3DLIGHT); <br>    g_light.dltType = D3DLIGHT_POINT; <br>// position light behind viewer <br>    g_light.dvPosition.x = 0.0f; <br>    g_light.dvPosition.y = 1000.0f; <br>    g_light.dvPosition.z = -100.0f; <br>    g_light.dcvColor.r = D3DVAL(1.0); <br>    g_light.dcvColor.g = D3DVAL(1.0); <br>    g_light.dcvColor.b = D3DVAL(1.0); <br>    g_light.dvAttenuation0 = (float)1.0; <br>    g_light.dvAttenuation1 = (float)0.0; <br>    g_light.dvAttenuation2 = (float)0.0; <br> <br>    hResult = lpD3D-&gt;CreateLight (&amp;g_lpD3DLight, NULL); <br>if (FAILED (hResult)) <br>{ <br>        REPORTERR (hResult); <br>return hResult; <br>    } <br> <br>    hResult = g_lpD3DLight-&gt;SetLight (&amp;g_light); <br>if (FAILED (hResult)) <br>{ <br>        REPORTERR (hResult); <br>return hResult; <br>    } <br> <br>    hResult = lpViewport-&gt;AddLight (g_lpD3DLight); <br>if (FAILED (hResult)) <br>{ <br>        REPORTERR (hResult); <br>return hResult; <br>    } <br> <br>// Success <br>    return DD_OK; <br>} // End D3DScene::InitViewport <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       D3DScene::FiniViewport <br>**  Purpose:Cleanup Viewport <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DScene::FiniViewport (void) <br>{ <br>HRESULT hResult; <br>LPDIRECT3DVIEWPORT2 lpViewport; <br> <br>// Check Initialization <br>if (! lpd3dWindow) <br>{ <br>// Error, <br>REPORTERR (DDERR_GENERIC); <br>return DDERR_GENERIC; <br>} <br> <br>lpViewport = lpd3dWindow-&gt;GetViewport (); <br> <br>// Cleanup light <br>if (g_lpD3DLight) <br>{ <br>// Remove from current view <br>    if (lpViewport)  <br>{ <br>hResult = lpViewport-&gt;DeleteLight (g_lpD3DLight); <br>if (FAILED (hResult)) <br>{ <br>REPORTERR (hResult); <br>} <br> <br>} <br> <br>// Release light <br>hResult = g_lpD3DLight-&gt;Release (); <br>if (FAILED (hResult)) <br>{ <br>REPORTERR (hResult); <br>} <br> <br>g_lpD3DLight = NULL; <br>} <br> <br>// Cleanup Material <br>    if (g_lpMat) <br>{ <br>hResult = g_lpMat-&gt;Release (); <br>if (FAILED (hResult)) <br>{ <br>REPORTERR (hResult); <br>} <br> <br>g_lpMat = NULL; <br>g_hMat = NULL; <br>} <br> <br>// Cleanup Background <br>if (g_lpmatBackground) <br>{ <br>hResult = g_lpmatBackground-&gt;Release (); <br>if (FAILED (hResult)) <br>{ <br>REPORTERR (hResult); <br>} <br> <br>g_lpmatBackground = NULL; <br>g_hBackMat = NULL; <br>} <br> <br>// Success <br>return DD_OK; <br>} // End D3DScene::FiniViewport <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**End of File <br>**----------------------------------------------------------------------------- <br>*/ <br> <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
