<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DRVMGR.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3284"></a>DRVMGR.H</h2>
<pre><code>#ifndef DRVMGR_H <br>#define DRVMGR_H <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DrvMgr.h <br>**  Purpose:    Creates and manages DD/D3D drivers static info <br>** <br>**  Copyright (c) 1995 - 1997 by Microsoft, all rights reserved <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Includes <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>#include "Common.h" <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Defines <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>// DD Driver Flags <br>#define DDDRV_INIT0x00000001L <br> <br>#define DDDRV_VALID0x00000001L <br>#define DDDRV_PRIMARY0x00000002L <br>#define DDDRV_D3D0x00000004L <br> <br>#define DDDRV_MODES_LOADED0x00000008L <br>#define DDDRV_DEVICES_LOADED0x00000010L <br> <br> <br>// D3D Device Flags <br>#define D3DDEV_VALID0x00000001L <br>#define D3DDEV_FORMATS_LOADED0x00000002L <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Typedefs <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>// Forward declarations <br>class DDModeInfo; <br>typedef DDModeInfo * LPDDModeInfo; <br> <br>class D3DDevInfo; <br>typedef D3DDevInfo * LPD3DDevInfo; <br> <br>class DDDrvInfo; <br>typedef DDDrvInfo * LPDDDrvInfo; <br> <br>class DDDrvMgr; <br>typedef DDDrvMgr * LPDDDrvMgr; <br> <br> <br>// Enumeration Callback Info <br>#define ENUM_STOP  0x80000000L <br> <br>typedef enum { <br>    ENUM_ERROR    = 0, <br>    ENUM_FAILURE  = 1, <br>    ENUM_SUCCESS  = 2 <br>}; <br> <br> <br>// Callback function prototypes <br>typedef DWORD (*ENUMDDDRVCALLBACK)(LPVOID lpDriver, LPVOID lpData, DWORD dwExtra); <br>typedef DWORD (*ENUMD3DDEVCALLBACK)(LPVOID lpDevice, LPVOID lpData, DWORD dwExtra); <br> <br>// Enum Driver Callback Info <br>typedef struct tagDDDRV_ENUMINFO <br>{ <br>    void *              lpStart;        // Starting Node <br>    ENUMDDDRVCALLBACK   fpcbEnum;       // Enumeration Callback function <br>    DWORD               dwExtra;        // User defined extra data for callback <br>} DDDRV_ENUMINFO; <br>typedef DDDRV_ENUMINFO * LPDDDRV_ENUMINFO; <br> <br>// Enum D3D Device Callback Info <br>typedef struct tagD3DDEV_ENUMINFO <br>{ <br>    void *              lpStart;        // Starting Node <br>    ENUMD3DDEVCALLBACK  fpcbEnum;       // Enumeration Callback function <br>    DWORD               dwExtra;        // User defined extra data for callback <br>} D3DDEV_ENUMINFO; <br>typedef D3DDEV_ENUMINFO * LPD3DDEV_ENUMINFO; <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Functions <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LPDDDrvInfo ValidateDriver (LPGUID lpDDGuid); <br>LPDDModeInfo ValidateMode (LPDDDrvInfo lpDriver, DWORD w, DWORD h, <br>   DWORD bpp, DWORD refresh, LPD3DDevInfo lpFilter); <br>LPD3DDevInfo ValidateDevice (LPDDDrvInfo lpDriver, LPGUID lpD3DGuid, <br>     LPDDModeInfo lpFilter); <br> <br>BOOL GetDesktopMode (LPDDDrvInfo lpDriver, LPGUID lpD3DGuid, <br> LPDDModeInfo * lpMode,LPD3DDevInfo * lpDev); <br> <br>BOOL GetFullscreenMode (LPDDDrvInfo lpDriver,  LPGUID lpD3DGuid, <br>DWORD w, DWORD h, DWORD bpp, DWORD refresh, <br>    LPDDModeInfo * lpMode,LPD3DDevInfo * lpDev); <br> <br>HRESULT ChooseDriverDefaults (LPGUID lpGuidDD, DWORD w, DWORD h, <br>  DWORD bpp, DWORD refresh, LPGUID lpGuidD3D, <br>  BOOL fFullScreen, LPDDDrvInfo * lpDriver, <br>  LPDDModeInfo * lpMode, LPD3DDevInfo * lpDevice); <br> <br>DWORD FlagsToBitDepth (DWORD dwFlags); <br>DWORD BitDepthToFlags (DWORD dwBPP); <br>BOOL  isPalettized (LPDDPIXELFORMAT lpddpf); <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Classes <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DDModeInfo <br>**  Purpose:    DirectDraw Mode info  <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>class DDModeInfo <br>{ <br>private: <br>protected: <br>public: <br>    // Data <br>    DDSURFACEDESC   ddSurfDesc;     // Complete Surface Description <br>LPDDModeInfolpPrev;// Prev Node in List <br>LPDDModeInfo    lpNext;// Next Node In List <br> <br>    // Constructors <br>    DDModeInfo (void) <br>        {  <br>            ZeroMemory (&amp;ddSurfDesc, sizeof (ddSurfDesc));  <br>            ddSurfDesc.dwSize = sizeof (DDSURFACEDESC); <br> <br>lpPrev = NULL; <br>lpNext = NULL; <br>        } <br> <br>    DDModeInfo (const DDSURFACEDESC &amp; ddDesc) <br>        {  <br>            CopyMemory (&amp;ddSurfDesc, (const void *)&amp;ddDesc, sizeof (ddSurfDesc));  <br>            ddSurfDesc.dwSize = sizeof (DDSURFACEDESC); <br> <br>lpPrev = NULL; <br>lpNext = NULL; <br>        } <br>    ~DDModeInfo (void)  <br>{ <br>lpPrev = NULL; <br>lpNext = NULL; <br>} <br> <br>    // Methods <br>DWORD GetWidth (void); <br>DWORD GetHeight (void); <br>DWORD GetBPP (void); <br>HRESULT GetMode (DWORD &amp; dwWidth, DWORD &amp; dwHeight,  <br> DWORD &amp; dwBPP, DWORD &amp; dwRefresh); <br> <br>BOOL ModeSupported (LPD3DDevInfo lpDevice); <br> <br>    BOOL Match (DWORD dwW, DWORD dwH, DWORD dwBPP); <br>    BOOL Match (const DDSURFACEDESC &amp; ddsd); <br> <br>BOOL Match (DWORD dwBPP); <br>BOOL Match (const DDPIXELFORMAT &amp; ddpf); <br>}; // DDModeInfo <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       D3DDevInfo <br>**  Purpose:    D3D Device/driver info for D3D Driver Manager <br>**Notes: <br>** <br>**- The Texture Format is a Mode (both are DDSURFACEDESC wrappers) <br>** <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>class D3DDevInfo <br>{ <br>private: <br>protected: <br>public: <br>    // D3D Device Driver info <br>    DWORD           fFlags;                 // Flags <br> <br>    // D3D Info <br>    GUID            guid;                   // GUID <br>    LPTSTR          szName;// Driver Name <br>    LPTSTR          szDesc;// Driver Description <br>    D3DDEVICEDESC   d3dHalDesc;             // HAL info <br>    D3DDEVICEDESC   d3dHelDesc;             // HEL info <br> <br>    // Texture Formats <br>DWORDcFormats;// Count of Texture Formats <br>    LPDDModeInfo    lpFormatRoot;// List of Texture Formats (root) <br>LPDDModeInfolpFormatTail;// List of Texture Formats (tail) <br> <br>// Node Info <br>LPD3DDevInfolpPrev;// Prev Node <br>LPD3DDevInfolpNext;// Next Node <br> <br>    // Flags <br>    BOOL isValid (void)     { return (fFlags &amp; DDDRV_VALID); } <br>    void validOn (void)     { fFlags |= DDDRV_VALID; } <br>    void validOff (void)    { fFlags &amp;= ~DDDRV_VALID; } <br> <br>    // Methods <br>    HRESULT Create (LPGUID lpGuid, LPTSTR lpName, LPTSTR lpDesc, <br>                    LPD3DDEVICEDESC lpHalDevice, <br>                    LPD3DDEVICEDESC lpHelDevice); <br>    void Destroy (void); <br> <br>    // Constructors  <br>    D3DDevInfo (void)  <br>        {  <br>validOff (); <br>turnFormatsLoadedOff (); <br> <br>szName = NULL; <br>szDesc = NULL; <br> <br>        ZeroMemory (&amp;d3dHalDesc, sizeof(D3DDEVICEDESC));  <br>        d3dHalDesc.dwSize = sizeof (D3DDEVICEDESC); <br> <br>        ZeroMemory (&amp;d3dHelDesc, sizeof(D3DDEVICEDESC));  <br>        d3dHelDesc.dwSize = sizeof (D3DDEVICEDESC); <br> <br>cFormats = 0L; <br>lpFormatRoot = NULL; <br>lpFormatTail = NULL; <br> <br>lpPrev = NULL; <br>lpNext = NULL; <br>        } <br> <br>    ~D3DDevInfo (void)  <br>{  <br>Destroy ();  <br>} <br> <br> <br>// Texure Format Methods <br>BOOL formatsLoaded (void){ return ((fFlags &amp; D3DDEV_FORMATS_LOADED) ? TRUE : FALSE); } <br>void turnFormatsLoadedOn (void){ fFlags |= D3DDEV_FORMATS_LOADED; } <br>void turnFormatsLoadedOff (void){ fFlags &amp;= ~D3DDEV_FORMATS_LOADED; } <br> <br>HRESULT LoadFormats (LPDIRECT3DDEVICE2 lpd3dDevice); <br>HRESULT DestroyFormats (void); <br> <br>HRESULT AddFormat (LPDDModeInfo lpFormatNew); <br>HRESULT DelFormat (LPDDModeInfo lpFormatDel); <br>DWORD   countFormats (void) { return cFormats; } <br> <br>    LPDDModeInfo FindFormat (DWORD dwBPP,  <br>     LPDDModeInfo * lpNextBest, <br>     LPDDModeInfo lpStartFormat = NULL); <br>    LPDDModeInfo FindFormat (LPDDPIXELFORMAT lpddsd,  <br>     LPDDModeInfo * lpNextBest, <br>     LPDDModeInfo lpStartFormat = NULL); <br> <br>    DWORD EnumFormats (const D3DDEV_ENUMINFO &amp; eiInfo); <br> <br> <br>    // Methods <br>    BOOL isHardware (void); <br>    BOOL Match (LPGUID lpGuid); <br>    BOOL Match (LPD3DDEVICEDESC lpHalDesc, LPD3DDEVICEDESC lpHelDesc); <br> <br>}; // End D3DDevInfo <br> <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DDDrvInfo <br>**  Purpose:    Encapsulates DD/D3D driver info <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>class DDDrvInfo <br>{ <br>private: <br>protected: <br>public: <br> <br>    // Structure info <br>    DWORD           fFlags;                         // D3D Driver flags <br> <br>    // Driver Info <br>    GUID            guid;                           // guid, if any <br>    LPTSTR          szName;// name <br>    LPTSTR          szDesc;// description <br> <br>    // Driver Caps <br>    DDCAPS          ddHalCaps;                      // Hardware caps <br>    DDCAPS          ddHelCaps;                      // Emulation caps <br> <br>    // Mode Info <br>DWORDcModes;// Count of Modes <br>    LPDDModeInfo    lpModeRoot;// List of Modes (root) <br>LPDDModeInfolpModeTail;// List of Modes (tail) <br> <br>    // D3D Info <br>DWORDcDevices;// Count of D3D devices <br>    LPD3DDevInfo    lpDeviceRoot;// List of D3D Devices (root) <br>LPD3DDevInfolpDeviceTail;// List of D3D Devices (tail) <br> <br>// Node Info <br>LPDDDrvInfolpPrev;// Previous node <br>LPDDDrvInfolpNext;// Next node <br> <br> <br>    // <br>    // Flag Methods <br>    // <br>    BOOL isValid (void)     { return (fFlags &amp; DDDRV_VALID); } <br>    void validOn (void)     { fFlags |= DDDRV_VALID; } <br>    void validOff (void)    { fFlags &amp;= ~DDDRV_VALID; } <br> <br>    BOOL isPrimary (void)   { return (fFlags &amp; DDDRV_PRIMARY); } <br>    void primaryOn (void)   { fFlags |= DDDRV_PRIMARY; } <br>    void primaryOff (void)  { fFlags &amp;= ~DDDRV_PRIMARY; } <br> <br>    BOOL isD3D (void)     { return (fFlags &amp; DDDRV_D3D); } <br>    void d3dOn (void)     { fFlags |= DDDRV_D3D; } <br>    void d3dOff (void)    { fFlags &amp;= ~DDDRV_D3D; } <br> <br> <br>    // Methods <br>    HRESULT Create (LPGUID lpGuid, LPTSTR lpszName, LPTSTR lpszDesc); <br>    void    Destroy (void); <br> <br>    // Constructors <br>    DDDrvInfo (void) <br>        {  <br>validOff (); <br>         <br>ZeroMemory (&amp;ddHalCaps, sizeof (DDCAPS));  <br>ddHalCaps.dwSize = sizeof (DDCAPS); <br> <br>ZeroMemory (&amp;ddHelCaps, sizeof (DDCAPS));  <br>ddHelCaps.dwSize = sizeof (DDCAPS); <br> <br>cModes  = 0L; <br>lpModeRoot = NULL; <br>lpModeTail = NULL; <br> <br>cDevices = 0L; <br>lpDeviceRoot = NULL; <br>lpDeviceTail = NULL; <br> <br>lpPrev = NULL; <br>lpNext = NULL; <br>        } <br> <br>    ~DDDrvInfo (void)  <br>{  <br>Destroy ();  <br>} <br> <br> <br>// Mode Methods <br>BOOL modesLoaded (void){ return ((fFlags &amp; DDDRV_MODES_LOADED) ? TRUE : FALSE); } <br>void turnModesLoadedOn (void){ fFlags |= DDDRV_MODES_LOADED; } <br>void turnModesLoadedOff (void){ fFlags &amp;= ~DDDRV_MODES_LOADED; } <br> <br>HRESULT LoadModes (LPDIRECTDRAW2 lpDD2); <br>HRESULT DestroyModes (void); <br> <br>HRESULT AddMode (LPDDModeInfo lpModeNew); <br>HRESULT DelMode (LPDDModeInfo lpModeDel); <br>DWORD countModes (void) { return cModes; } <br> <br>    LPDDModeInfo FindMode (DWORD dwW, DWORD dwH,  <br>   DWORD dwBPP, DWORD dwRefresh, <br>   LPDDModeInfo * lpNextBest, <br>   LPDDModeInfo lpStartMode = NULL); <br>    LPDDModeInfo FindMode (LPDDSURFACEDESC lpddsd,  <br>   LPDDModeInfo * lpNextBest, <br>   LPDDModeInfo lpStartMode = NULL); <br> <br>    DWORD EnumModes (const DDDRV_ENUMINFO &amp; eiInfo); <br> <br>// D3D Device Methods <br>BOOL devicesLoaded (void){ return ((fFlags &amp; DDDRV_DEVICES_LOADED) ? TRUE : FALSE); } <br>void turnDevicesLoadedOn (void){ fFlags |= DDDRV_DEVICES_LOADED; } <br>void turnDevicesLoadedOff (void){ fFlags &amp;= ~DDDRV_DEVICES_LOADED; } <br> <br>HRESULT LoadDevices (LPDIRECT3D2 lpD3D2); <br>HRESULT DestroyDevices (void); <br> <br>HRESULT AddDevice (LPD3DDevInfo lpModeNew); <br>HRESULT DelDevice (LPD3DDevInfo lpModeDel); <br>DWORD countDevices (void) { return cDevices; } <br> <br>    LPD3DDevInfo FindDevice (LPGUID lpGuid, LPD3DDevInfo * lpNextBest, <br> LPD3DDevInfo lpStart = NULL); <br>    LPD3DDevInfo FindDevice (LPD3DDEVICEDESC lpHal, LPD3DDEVICEDESC lpHel,  <br> LPD3DDevInfo * lpNextBest, <br> LPD3DDevInfo lpStart = NULL); <br> <br>    DWORD EnumDevices (const DDDRV_ENUMINFO &amp; eiInfo); <br> <br>// Mode &lt;=&gt; Device compatible find functions  <br>    LPD3DDevInfo FindDeviceSupportsMode (LPGUID lpGuid,  <br> LPDDModeInfo lpMode, <br>     LPD3DDevInfo * lpNextBest, <br>     LPD3DDevInfo lpStart = NULL); <br>LPDDModeInfo FindModeSupportsDevice (DWORD dwW, DWORD dwH,  <br> DWORD dwBPP, DWORD dwRefresh, <br> LPD3DDevInfo lpDevice, <br> LPDDModeInfo * lpNextBest, <br> LPDDModeInfo lpStart = NULL); <br>  <br> <br>    // Methods <br>    BOOL  Match (LPGUID lpGuid); <br>    BOOL  Match (LPDDCAPS lpHal, LPDDCAPS lpHel); <br> <br>LPGUID GetGuid (void); <br> <br>}; // End class DDDrvInfo <br> <br> <br>    <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DDDrvMgr <br>**  Purpose:    Creates and Manages DD/D3D driver info <br>**  Notes: <br>**          1.  Modes and D3D Drivers may be incompatible with each other <br>**              code needs to be added to detect and mark this <br>**          2.  Need to add code for finding exact and nearest mode matches <br>**              from requested width, height, pixel format, and refresh rate <br>**          3.  Need to add code for finding D3D devices from <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>class DDDrvMgr <br>{ <br>private: <br>protected: <br>public: <br>    // Static Data <br>    static DWORD         g_fFlags;                  // Global flags <br>static DWORD g_cDrivers;// Count of DD Drivers <br>    static LPDDDrvInfo g_lpDriverRoot;// Global list of DD Device Drivers (root) <br>    static LPDDDrvInfo g_lpDriverTail;// Global list of DD Device Drivers (tail) <br> <br>             <br>    // Data <br>    LPDDDrvInfolpCurrDriver;// Pointer to current DD Device driver <br>    LPDDModeInfolpCurrMode;// Pointer to current mode in DD driver <br>    LPD3DDevInfolpCurrDevice;// Pointer to current D3D device <br>LPDDModeInfolpCurrTextureFormat;// Pointer to current Texture Format <br> <br>    // Static Methods <br>    static HRESULT Init (void); <br>    static HRESULT Fini (void); <br> <br>    static BOOL isInitialized (void)    { return (g_fFlags &amp; DDDRV_INIT); } <br>    static void initOn (void)           { g_fFlags |= DDDRV_INIT; } <br>    static void initOff (void)          { g_fFlags &amp;= ~DDDRV_INIT; } <br> <br>// Driver Methods <br>static HRESULT LoadDrivers (void); <br>static HRESULT DestroyDrivers (void); <br> <br>static HRESULT AddDriver (LPDDDrvInfo lpDrvNew); <br>static HRESULT DelDriver (LPDDDrvInfo lpDrvDel); <br>static DWORD countDrivers (void) { return g_cDrivers; } <br> <br>    static DWORD EnumDrivers (const DDDRV_ENUMINFO &amp; eiInfo); <br> <br>    static LPDDDrvInfo FindDriver (LPGUID lpGuidDD, LPDDDrvInfo * dwNextBest, <br>   LPDDDrvInfo lpStart = NULL); <br>    static LPDDDrvInfo FindDriver (LPDDCAPS lpHalCaps, LPDDCAPS lpHelCaps,  <br>   LPDDDrvInfo * dwNextBest, <br>   LPDDDrvInfo lpStart = NULL); <br> <br>    // Constructors <br>    DDDrvMgr (void); <br>    ~DDDrvMgr (void); <br> <br>// DD info methods <br>    LPDDDrvInfo GetCurrDriver (void)              <br>{ <br>return lpCurrDriver; <br>} <br> <br>    // Mode Methods <br>    DWORD countModes (void)               <br>{  <br>if (lpCurrDriver) <br>return lpCurrDriver-&gt;countModes (); <br>return 0L; <br>} <br> <br>    LPDDModeInfo GetCurrMode (void)              <br>{ <br>return lpCurrMode; <br>} <br> <br>    // D3D info methods <br>    DWORD countDevices (void) <br>{  <br>if (lpCurrDriver) <br>return lpCurrDriver-&gt;countDevices (); <br>return 0L; <br>}     <br> <br>    LPD3DDevInfo GetCurrDevice (void) <br>{  <br>return lpCurrDevice; <br>} <br> <br>// Texture Format methods <br>DWORD countFormats (void) <br>{ <br>if (lpCurrDevice) <br>return lpCurrDevice-&gt;countFormats (); <br>return 0L; <br>} <br> <br>LPDDModeInfo GetCurrTextureFormat (void) <br>{ <br>return lpCurrTextureFormat; <br>} <br>         <br>}; // End class DDDrvMgr <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  End of File <br>**----------------------------------------------------------------------------- <br>*/ <br>#endif // DRVMGR_H <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
