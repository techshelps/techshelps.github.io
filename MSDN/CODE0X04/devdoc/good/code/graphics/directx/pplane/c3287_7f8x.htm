<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WINPROC.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3291"></a>WINPROC.CPP</h2>
<pre><code>/* <br>**----------------------------------------------------------------------------- <br>**  File:       WinProc.cpp <br>**  Purpose:    A sample windows proc for supporting D3D. <br>**  Notes: <br>** <br>** <br>**  Copyright (c) 1995 - 1997 by Microsoft, all rights reserved <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**Include Files <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>#include "WinProc.h" <br>#include "WinMain.h" <br>#include "Debug.h" <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**Local Typedefs <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>typedef struct tagChangeDDInfo { <br>DDDrvInfo  * lpDrvOrig;// Original Driver <br>DDDrvInfo  * lpDrvNew;// New Driver (user choice) <br> <br>D3DDevInfo * lpDevOrig;// Original D3D device <br>D3DDevInfo * lpDevNew;// New D3D device (user choice) <br> <br>DDModeInfo * lpModeOrig;// Orignal Mode <br>DDModeInfo * lpModeNew;// New Mode (user choice) <br>} ChangeDDInfo; <br>typedef ChangeDDInfo * LPChangeDDInfo; <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**Local Variables <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>// Used for 3Dfx Voodoo driver detection below <br>const GUID guid3DfxVoodoo = { <br>0x3A0CFD01, <br>0x9320, <br>0x11CF, <br>0xAC,0xA1,0x00,0xA0,0x24,0x13,0xC2,0xE2 <br>}; <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**Local function prototypes <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>// About message proc <br>BOOL FAR PASCAL AboutBoxProc (HWND hWnd, UINT uiMsg, <br>  WPARAM wParam, LPARAM lParam); <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**Local function prototypes <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>// Change Dialog <br>BOOL DlgDriversInit (HWND hDlg); <br>BOOL DlgDevicesInit (HWND hDlg); <br>BOOL DlgModesInit (HWND hDlg); <br> <br>int _cdecl CompareModes (const void* element1, const void* element2); <br> <br>LPDDDrvInfo  DlgGetDriver (HWND hDlg); <br>LPD3DDevInfo DlgGetDevice (HWND hDlg); <br>LPDDModeInfo DlgGetMode (HWND hDlg); <br> <br>BOOL FAR PASCAL ChangeDriverProc (HWND hWnd, UINT uiMsg, <br>      WPARAM wParam, LPARAM lParam); <br>void OnChangeDriver (HWND hWindow, int idDialog); <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**Functions <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       D3DWindowProc <br>**  Purpose:    handles windows messages for D3DWindow's <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LRESULT CALLBACK D3DWindowProc ( <br>    HWND    hWindow, <br>    UINT    uiMsg, <br>    WPARAM  wParam, <br>    LPARAM  lParam) <br>{ <br>LONG lResult; <br> <br>    // <br>    // Windows messages <br>    // <br>    switch (uiMsg) <br>    { <br>case WM_ACTIVATE: <br>// Note:  Do we need to handle this ?!? <br>break; <br> <br>    case WM_ACTIVATEAPP: <br>        return OnActivateApp (hWindow, wParam, lParam); <br> <br>case WM_CLOSE: <br>return OnClose (hWindow); <br> <br>    case WM_COMMAND: <br>        return OnCommand (hWindow, wParam, lParam); <br> <br>    case WM_CREATE: <br>return OnCreate (hWindow); <br> <br>    case WM_DESTROY: <br>return OnDestroy (hWindow); <br> <br>case WM_DISPLAYCHANGE: <br>return OnDisplayChange (hWindow); <br> <br>    case WM_ERASEBKGND: <br>return OnEraseBackground (hWindow, wParam, lParam); <br> <br>    case WM_GETMINMAXINFO: <br>return OnGetMinMaxInfo (hWindow, (LPMINMAXINFO) lParam); <br> <br>    case WM_MOVE: <br>        return OnMove (hWindow, (INT)LOWORD(lParam), (INT)HIWORD(lParam)); <br> <br>    case WM_PAINT: <br>    { <br>        HDC         hdc; <br>        PAINTSTRUCT ps; <br> <br>        hdc = BeginPaint (hWindow, &amp;ps);             <br>        lResult = OnPaint (hWindow, hdc, &amp;ps); <br>        EndPaint (hWindow, &amp;ps); <br>    } <br>        return lResult; <br> <br> <br>case WM_PALETTECHANGED: <br>// Note:  We need to support this <br>break; <br> <br>case WM_QUERYNEWPALETTE: <br>// Note:  We need to support this <br>break; <br> <br>    case WM_SIZE: <br>        return OnSize (hWindow, (INT)LOWORD(lParam), (INT)HIWORD(lParam)); <br>      <br> // <br>     // D3D Window messages <br>     //   <br>    case D3DWIN_GET_VALID:       // Get valid size <br>{ <br>LPD3DWindow lpd3dWindow; <br> <br>//Get D3DWindow pointer <br>lpd3dWindow =  (LPD3DWindow)GetWindowLong (hWindow, GWL_USERDATA); <br>        if (! lpd3dWindow) <br>            return FALSE; <br>        return lpd3dWindow-&gt;isValid(); <br>} <br> <br>    case D3DWIN_GET_POINTER: <br>//Get D3DWindow pointer <br>return (LRESULT)GetWindowLong (hWindow, GWL_USERDATA); <br> <br>    case D3DWIN_GET_SURFACE: <br>{ <br>LPD3DWindow lpd3dWindow; <br> <br>//Get D3DWindow pointer <br>lpd3dWindow =  (LPD3DWindow)(void *)GetWindowLong (hWindow, GWL_USERDATA); <br>        if (! lpd3dWindow) <br>            return NULL; <br>        return (LPARAM)(lpd3dWindow-&gt;GetRender ()); <br>} <br> <br>case D3DWIN_INIT: <br>return OnD3DInit (hWindow, (LPD3DWindow) lParam); <br> <br>case D3DWIN_FINI: <br>return OnD3DFini (hWindow, (LPD3DWindow) lParam); <br> <br>case D3DWIN_CHANGED_DRIVER: <br>return OnD3DChangeDriver (hWindow); <br> <br>case D3DWIN_CHANGED_DEVICE: <br>return OnD3DChangeDevice (hWindow); <br> <br>case D3DWIN_CHANGED_MODE: <br>return OnD3DChangeMode (hWindow); <br>    } // End Switch <br> <br>   // Do Default window behavior <br>   return (DefWindowProc (hWindow, uiMsg, wParam, lParam)); <br>} // End D3DWindowProc <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       AboutBoxProc <br>**  Purpose:    handles messages for About Dialog box <br>**----------------------------------------------------------------------------- <br>*/ <br>BOOL <br>FAR PASCAL AboutBoxProc (HWND hWnd, UINT uiMsg, WPARAM wParam, LPARAM lParam) <br>{ <br>switch (uiMsg) <br>{ <br>case WM_COMMAND: <br>if (LOWORD(wParam) == IDOK) <br>EndDialog (hWnd, TRUE); <br>break; <br> <br>    case WM_INITDIALOG: <br>return TRUE; <br>} <br>return FALSE; <br>} // End AboutBoxProc  <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       OnAbout <br>**  Purpose:    Display About Dialog <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LRESULT OnAbout (HWND hWindow) <br>{ <br>HINSTANCE hInstance; <br> <br>if ((! hWindow) || (! IsWindow (hWindow))) <br>return 0L; <br> <br>hInstance = (HINSTANCE) GetWindowLong (hWindow, GWL_HINSTANCE); <br>if (! hInstance) <br>return 0L; <br> <br>    // Pause App <br>    OnPause (hWindow, TRUE); <br> <br>    // Do About Dialog here <br>    DialogBox (hInstance, MAKEINTRESOURCE (IDD_ABOUT), hWindow, (DLGPROC)AboutBoxProc); <br> <br>    // UnPause app <br>    OnPause (hWindow, FALSE); <br> <br>    return 0L; <br>} // End OnAbout <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       OnActivateApp <br>**  Purpose:    ActivateApp <br>**  Note: <br>**always let it fall through to Default window proc <br>**to set up keyboard focus properly, etc. <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LRESULT OnActivateApp (HWND hWindow, WPARAM wParam, LPARAM lParam) <br>{ <br>BOOL fActive = (BOOL)wParam; <br> <br>// Get D3D Window pointer <br>LPD3DWindow lpd3dWindow =  (LPD3DWindow)GetWindowLong (hWindow, GWL_USERDATA); <br> <br>    if (fActive) <br>    { <br>// Reactivating - Realize current palette <br>if (lpd3dWindow) <br>{ <br>lpd3dWindow-&gt;turnActiveOn (); <br>lpd3dWindow-&gt;RealizePalette (); <br>} <br>    } <br>    else <br>    { <br>        // <br>        //  If we have been deactivated invalidate <br>        //  to show the paused display. <br>        // <br>if (lpd3dWindow) <br>{ <br>lpd3dWindow-&gt;turnActiveOff (); <br>        InvalidateRect (hWindow, NULL, FALSE); <br>} <br> <br>    } <br> <br>    // Do default behavior <br>return DefWindowProc (hWindow, WM_ACTIVATEAPP, wParam, lParam); <br>} // End OnActivateApp <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       OnClose <br>**  Purpose:    Shut down app <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LRESULT OnClose (HWND hWindow) <br>{ <br>// Just Destroy the window for now <br>    DestroyWindow (hWindow); <br>return 0L; <br>} // End OnClose <br> <br>   <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       OnCommand <br>**  Purpose:    Handle User commands <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LRESULT OnCommand (HWND hWindow, WPARAM wParam, LPARAM lParam) <br>{    <br>HWND  hControl= (HWND)lParam; <br>    DWORD dwNotify= (DWORD)HIWORD(wParam); <br>    DWORD dwID      = (DWORD)LOWORD(wParam); <br> <br>    if (hControl) <br>    { <br>// <br>    // Handle messages from controls here <br>        // <br>    } <br>    else  <br>{ <br>//  <br>// Handle Menu messages here <br>// <br>switch (dwID) <br>{ <br>case IDM_EXIT: <br>// Close down app <br>SendMessage (hWindow, WM_CLOSE, 0, 0); <br>return 0; <br> <br>case IDM_ABOUT: <br>// Bring up About Dialog <br>OnAbout (hWindow); <br>break; <br> <br>case IDM_CHANGE_DRIVERS: <br>// Bring up the "Change Driver" dialog <br>OnChangeDriver (hWindow, IDD_CHANGE_DRIVER); <br>break; <br> <br>default: <br>// Unknown Menu Command <br>break; <br>} <br>} <br> <br>    // Let Default Window Proc handle it for us. <br>    return DefWindowProc (hWindow, WM_COMMAND, wParam, lParam); <br>} // End OnCommand <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       OnCreate <br>**  Purpose:    Initialization of any Window objects <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LRESULT OnCreate (HWND hWindow) <br>{ <br>    // Success <br>    return 0L; <br>} // End OnCreate <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       OnDestroy <br>**  Purpose:    Cleanup and shut down app <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LRESULT OnDestroy (HWND hWindow) <br>{ <br>    LPD3DWindow lpd3dWindow; <br> <br>    //Delete associated D3DWindow from this window <br>lpd3dWindow =  (LPD3DWindow)GetWindowLong (hWindow, 0L); <br>if (lpd3dWindow) <br>lpd3dWindow-&gt;Fini (); <br>SetWindowLong (hWindow, GWL_USERDATA, 0L); <br> <br>    // Tell windows to QUIT! <br>    PostQuitMessage (0); <br>    return 0L; <br>} // End OnDestroy <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       OnDisplayChange <br>**  Purpose:    Cleanup and shut down app <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LRESULT OnDisplayChange (HWND hWindow) <br>{ <br>HRESULThResult; <br>    LPD3DWindow lpd3dWindow; <br> <br>// Get D3D window pointer <br>lpd3dWindow =  (LPD3DWindow)GetWindowLong (hWindow, GWL_USERDATA); <br>if (! lpd3dWindow) <br>return 0L; <br> <br>// Change Primary surface to new desktop <br>hResult = lpd3dWindow-&gt;ChangeDesktop (); <br>if (FAILED (hResult)) <br>return 0L; <br> <br>// Success <br>    return 0L; <br>} // End OnDestroy <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       OnEraseBackground <br>**  Purpose:    Erase Window background <br>**  Notes: <br>**1.  The only time we need to do this is when <br>**the rendering surface is valid yet smaller than the client area <br>**any other situation and we are re-painting the entire client area. <br>**so we don't need to erase the background <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LRESULT OnEraseBackground (HWND hWindow, WPARAM wParam, LPARAM lParam) <br>{ <br>    LPD3DWindow lpd3dWindow; <br>RECT        rTemp, rSurf, rClient; <br> <br>// Get D3D window pointer <br>lpd3dWindow =  (LPD3DWindow)GetWindowLong (hWindow, GWL_USERDATA); <br>if (! lpd3dWindow) <br>return 0L; <br> <br>if ((lpd3dWindow-&gt;isValid ()) &amp;&amp; (! lpd3dWindow-&gt;isPaused ())) <br>{ <br>GetClientRect (hWindow, &amp;rClient); <br>lpd3dWindow-&gt;GetSurfaceRect (rSurf); <br> <br>// Does surface rect contain the client rectangle? <br>if (IntersectRect (&amp;rTemp, &amp;rClient, &amp;rSurf)) <br>{ <br>if (! EqualRect (&amp;rTemp, &amp;rClient)) <br>{ <br>// No, then allow system to erase the background for us <br>return DefWindowProc (hWindow, WM_ERASEBKGND, wParam, lParam); <br>} <br>} <br>} <br> <br>// Success <br>// Tell system we erased background, even though we didn't <br>    return 1L; <br>} // End OnEraseBackground <br>   <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       OnGetMinMaxInfo <br>**  Purpose:    Set Minimum, Maximum Window sizes <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LRESULT OnGetMinMaxInfo (HWND hWindow, LPMINMAXINFO lpmmi) <br>{ <br>RECT rMin; <br>DWORD dwStyle, dwStyleEx; <br>HMENU hMenu; <br>BOOL fMenu; <br>    LPD3DWindow  lpd3dWindow; <br> <br>// Get D3D window pointer <br>lpd3dWindow =  (LPD3DWindow)GetWindowLong (hWindow, GWL_USERDATA); <br>if (! lpd3dWindow) <br>return 0L; <br> <br>// Get Window Style <br>dwStyle   = GetWindowLong (hWindow, GWL_STYLE); <br>dwStyleEx = GetWindowLong (hWindow, GWL_EXSTYLE); <br>hMenu  = GetMenu (hWindow); <br>fMenu     = (hMenu ? TRUE : FALSE); <br> <br>rMin.left= 0; <br>rMin.top= 0; <br>rMin.right  = MIN_WIN_SIZE_X; <br>rMin.bottom= MIN_WIN_SIZE_Y; <br> <br>AdjustWindowRectEx (&amp;rMin, dwStyle, fMenu, dwStyleEx); <br> <br> lpmmi-&gt;ptMinTrackSize.x = rMin.right - rMin.left; <br>lpmmi-&gt;ptMinTrackSize.y = rMin.bottom  - rMin.top; <br> <br>return 0L; <br>} // End OnGetMinMaxInfo <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       OnIdle <br>**  Purpose:    Animate while system is idle <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>void OnIdle (HWND hWindow) <br>{ <br>    HRESULT hResult; <br>    LPD3DWindow  lpd3dWindow; <br> <br>// Get D3D window pointer <br>lpd3dWindow =  (LPD3DWindow)GetWindowLong (hWindow, GWL_USERDATA); <br>if (! lpd3dWindow) <br>return; <br> <br>    // <br>    // Only animate if we are the foreground app, we aren't suspended <br>    // and we have completed initialization. <br>    // <br>    // <br>    // Only animate if we are the foreground app, we aren't suspended <br>    // and we have completed initialization. <br>    // <br>if (! lpd3dWindow-&gt;isActive () ||  <br>(lpd3dWindow-&gt;isPaused ()) || <br>(! lpd3dWindow-&gt;isValid ())) <br>return; <br> <br>hResult = lpd3dWindow-&gt;DrawFrame (); <br>    if (FAILED (hResult)) <br>return; <br> <br>    return; <br>} // End OnIdle <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       OnMove <br>**  Purpose:    Move window <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LRESULT OnMove (HWND hWindow, INT nX, INT nY) <br>{ <br>    HRESULT hResult; <br>    LPD3DWindow lpd3dWindow; <br> <br>// Get D3D Window pointer <br>lpd3dWindow =  (LPD3DWindow)GetWindowLong (hWindow, GWL_USERDATA); <br>if (! lpd3dWindow) <br>return 0L; <br> <br>    /* <br>     * No action if the device has not yet been created or if we are <br>     * suspended. <br>     */ <br>    if (! lpd3dWindow-&gt;isPaused() || ! lpd3dWindow-&gt;isValid ()) <br>    { <br>// Keep the D3D info in synch with the change <br>hResult = lpd3dWindow-&gt;Move (nX, nY); <br>        if (FAILED (hResult)) <br>            return 0L; <br> <br>        // Repaint the client area. <br>        hResult = lpd3dWindow-&gt;DrawFrame (); <br>        if (FAILED (hResult)) <br>            return 0L; <br>    } <br> <br>    // Success <br>    return 0L; <br>} // End OnMove <br> <br>   <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       OnPaint <br>**  Purpose:Paint the window <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LRESULT OnPaint (HWND hWindow, HDC hdc, LPPAINTSTRUCT lpps) <br>{ <br>    HRESULT hResult; <br>LPD3DWindow lpd3dWindow; <br> <br>// Get D3D Window pointer <br>lpd3dWindow =  (LPD3DWindow)GetWindowLong (hWindow, GWL_USERDATA); <br>if (! lpd3dWindow) <br>{ <br>        PaintPaused (hWindow, hdc); <br>return 0L; <br>} <br> <br>    if (lpd3dWindow-&gt;isActive () &amp;&amp;  <br>!lpd3dWindow-&gt;isPaused () &amp;&amp;  <br>lpd3dWindow-&gt;isValid()) <br>    { <br>        // <br>        // NOTE: DrawFrame() re-renders the scene as well as blitting the <br>        // result to the primary. As all we really want to do here is <br>        // repaint the client area we don't really need to re-render - <br>        // just re-blit. For this simple sample this inefficiency <br>        // doesn't matter but for real applications not re-rendering <br>        // may be a useful optimization. <br>        // <br>        hResult = lpd3dWindow-&gt;DrawFrame (); <br>        if (FAILED (hResult)) <br>            return 0L; <br>    } <br>    else <br>    { <br>        // <br>        // Show the suspended image if we are not active,  <br>        // or paused, or if we have not yet created the device. <br>        // <br>        PaintPaused (hWindow, hdc); <br>    } <br> <br>    return 0L; <br>} // End OnPaint <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:OnPause <br>**  Purpose:Pause/Unpause app <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>void OnPause (HWND hWindow, BOOL fPause) <br>{ <br>LPD3DWindow lpd3dWindow; <br> <br>// Get D3D Window pointer <br>lpd3dWindow =  (LPD3DWindow)GetWindowLong (hWindow, GWL_USERDATA); <br>if (! lpd3dWindow) <br>return; <br> <br>lpd3dWindow-&gt;Pause (fPause); <br>} // End OnPause <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       OnSize <br>**  Purpose:Resize main window <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LRESULT OnSize (HWND hWindow, INT nW, INT nH) <br>{ <br>    HRESULT       hResult; <br>    LPD3DWindow  lpd3dWindow; <br> <br>// Get D3D window pointer <br>lpd3dWindow =  (LPD3DWindow)GetWindowLong (hWindow, GWL_USERDATA); <br>if (! lpd3dWindow) <br>return 0L; <br> <br>    // Check if we are paused  <br>    if (! lpd3dWindow-&gt;isPaused ()) <br>    { <br>// Resize D3D surfaces <br>hResult = lpd3dWindow-&gt;Resize (nW, nH); <br>        if (FAILED (hResult)) <br>            return 0L; <br> <br>        // <br>        // Render at the new size and show the results <br>        // in the main window's client area. <br>        // <br>        hResult = lpd3dWindow-&gt;DrawFrame (); <br>        if (FAILED (hResult)) <br>            return 0L; <br>    } <br> <br>    // Success <br>    return 0L; <br>} // End OnSize <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       OnD3DInit <br>**  Purpose:Notification that associated D3D Window object <br>**has successfully initialized <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LRESULT OnD3DInit (HWND hWindow, LPD3DWindow lpd3dWindow) <br>{ <br>if ((! lpd3dWindow) || (! lpd3dWindow-&gt;isValid ())) <br>{ <br>// Error, something went wrong <br>return 0L; <br>} <br> <br>// Save the pointer to the D3D Window object <br>SetWindowLong (hWindow, GWL_USERDATA, (long)(void *)lpd3dWindow); <br> <br>// Make sure we are properly marked as active/inactive <br>HWND hActive = GetActiveWindow (); <br>if (hActive == hWindow) <br>lpd3dWindow-&gt;turnActiveOn (); <br>else <br>lpd3dWindow-&gt;turnActiveOff (); <br> <br>// Success <br>return 0L; <br>} // End OnD3DInit <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       OnD3DFini <br>**  Purpose:Notification that the D3D window object <br>**is cleaning up. <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LRESULT OnD3DFini (HWND hWindow, LPD3DWindow lpd3dWindow) <br>{ <br>// Set our window pointer to NULL <br>// so we don't attempt to misuse it later. <br>SetWindowLong (hWindow, GWL_USERDATA, 0L); <br> <br>// Success <br>return 0L; <br>} // End OnD3DFini <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       OnD3DChangeDriver <br>**  Purpose:Notification that our associated D3D Window object <br>**has changed it's DD Driver. <br>**  Notes:This is a good time to update our Menus <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LRESULT OnD3DChangeDriver (HWND hWindow) <br>{ <br>// Success <br>return 0L; <br>} // End OnD3DChangeDriver <br> <br>   <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       OnD3DChangeMode <br>**  Purpose:Notification that our associated D3D Window object <br>**has changed it's mode. <br>**  Notes: <br>**1. This is probably caused by the user changing the Desktop mode <br>**2. This is a good time to update our Menus <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LRESULT OnD3DChangeMode (HWND hWindow) <br>{ <br>// Success <br>return 0L; <br>} // End OnD3DChangeMode <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       OnD3DChangeDevice <br>**  Purpose:Notification that our associated D3D Window object <br>**has changed it's D3D device. <br>**  Notes:This is a good time to update our Menus <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LRESULT OnD3DChangeDevice (HWND hWindow) <br>{ <br>// Success <br>return 0L; <br>} // End OnD3DChangeDevice <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       PaintPaused <br>**  Purpose:Paint the window as Paused <br>**  Notes:       <br>** <br>**  1.  We show the paused state by drawing a text string <br>**      in the client area of the window. <br>** <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>void PaintPaused (HWND hWindow, HDC hdc) <br>{ <br>    HPEN     hOldPen; <br>    HBRUSH   hOldBrush; <br>    COLORREF crOldTextColor; <br>    INT      oldMode; <br>    INT      x; <br>    INT      y; <br>    SIZE     size; <br>    RECT     rect; <br>    INT      nStrLen; <br> <br>    // <br>    // Black background. <br>    // <br>    hOldPen   = (HPEN)SelectObject (hdc, GetStockObject (NULL_PEN)); <br>    hOldBrush = (HBRUSH)SelectObject (hdc, GetStockObject (BLACK_BRUSH)); <br> <br>    // <br>    // White text. <br>    // <br>    oldMode = SetBkMode (hdc, TRANSPARENT); <br>    crOldTextColor = SetTextColor (hdc, RGB(255, 255, 255)); <br> <br>    //  <br>    GetClientRect (hWindow, &amp;rect); <br> <br>    // <br>    // Clear the client area. <br>    // <br>    Rectangle (hdc, rect.left, rect.top, rect.right + 1, rect.bottom + 1); <br> <br>    // <br>    // Draw the string centered in the client area. <br>    // <br>    nStrLen = strlen (g_szPaused); <br>    GetTextExtentPoint32 (hdc, g_szPaused, nStrLen, &amp;size); <br>    x = (rect.right  - size.cx) / 2; <br>    y = (rect.bottom - size.cy) / 2; <br>    TextOut (hdc, x, y, g_szPaused, nStrLen); <br> <br>    // Cleanup <br>    SetTextColor (hdc, crOldTextColor); <br>    SetBkMode (hdc, oldMode); <br> <br>    SelectObject (hdc, hOldBrush); <br>    SelectObject (hdc, hOldPen); <br>} // End PaintPaused <br> <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**Dialog Functions <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DlgDriversInit <br>**  Purpose:    Set up Drivers for dialog  <br>**  Notes:Shows list of current Drivers <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>BOOL DlgDriversInit (HWND hDlg) <br>{ <br>LPChangeDDInfolpChange; <br>LPDDDrvInfolpDriver; <br>LPDDDrvInfolpCurr, lpNext; <br>DWORDdwIndex; <br>LPGUIDlpGuidDD; <br> <br>// Check Parameters <br>lpChange = (LPChangeDDInfo)(void *)GetWindowLong (hDlg, DWL_USER); <br>if (! lpChange) <br>return FALSE; <br> <br>lpDriver = lpChange-&gt;lpDrvNew; <br> <br>// Validate Driver <br>if (! lpDriver) <br>lpGuidDD = NULL; <br>else <br>lpGuidDD = lpDriver-&gt;GetGuid (); <br>lpDriver = ValidateDriver (lpGuidDD); <br>if (! lpDriver) <br>return FALSE; <br> <br>// Dump Driver list to Combo Box <br>dwIndex = 0; <br>lpCurr = DDDrvMgr::g_lpDriverRoot; <br>while (lpCurr) <br>{ <br>TCHAR szBuff[80]; <br>DWORD dwNew; <br>LPGUID lpGuidDD; <br> <br>lpNext = lpCurr-&gt;lpNext; <br> <br>// Hack: Do a Quick check for the 3Dfx Voodoo driver <br>// which doesn't support windowed mode <br>lpGuidDD = lpCurr-&gt;GetGuid (); <br>if (lpGuidDD) <br>{ <br>if (*lpGuidDD == guid3DfxVoodoo) <br>{ <br>// Don't add 3Dfx Voodoo driver. <br>// This is a windowed app and it isn't supported <br>lpCurr = lpNext; <br>continue; <br>} <br>} <br> <br>if (lpCurr-&gt;isPrimary ()) <br>wsprintf (szBuff, TEXT("%s (Primary)"), lpCurr-&gt;szName); <br>else <br>wsprintf (szBuff, TEXT("%s"), lpCurr-&gt;szName); <br> <br>// Add String to Combo Box <br>dwNew = SendDlgItemMessage (hDlg, IDC_DRIVERS, CB_ADDSTRING, 0, (LPARAM)(LPCTSTR)szBuff); <br> <br>// Set up pointer to driver for this item <br>SendDlgItemMessage (hDlg, IDC_DRIVERS, CB_SETITEMDATA, (WPARAM)dwNew, (LPARAM)(void *)lpCurr); <br> <br>// Is it the current Driver <br>if (lpDriver == lpCurr) <br>{ <br>// Set as our current selection <br>SendDlgItemMessage (hDlg, IDC_DRIVERS, CB_SETCURSEL, (WPARAM)dwNew, 0L); <br>} <br> <br>lpCurr = lpNext; <br>} <br> <br>// Success <br>return TRUE; <br>} // End DlgDriversInit <br>     <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DlgDevicesInit <br>**  Purpose:    Set up Devices for dialog  <br>**  Notes:Shows list of current Devices <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>BOOL DlgDevicesInit (HWND hDlg) <br>{ <br>LPChangeDDInfolpChange; <br>LPDDDrvInfolpDriver; <br>LPD3DDevInfolpDevice; <br>LPD3DDevInfolpCurr, lpNext; <br>DWORDdwIndex; <br>LPGUIDlpGuidD3D; <br> <br>// Check Parameters <br>lpChange = (LPChangeDDInfo)(void *)GetWindowLong (hDlg, DWL_USER); <br>if (! lpChange) <br>return FALSE; <br> <br>lpDriver = lpChange-&gt;lpDrvNew; <br>if (! lpDriver) <br>return FALSE; <br> <br>lpDevice = lpChange-&gt;lpDevNew; <br> <br>// Validate Device <br>if (! lpDevice) <br>lpGuidD3D = NULL; <br>else <br>lpGuidD3D = &amp;(lpDevice-&gt;guid); <br>lpDevice = ValidateDevice (lpDriver, lpGuidD3D, NULL); <br>if (! lpDevice) <br>return FALSE; <br> <br>// Dump Device list to Combo Box <br>dwIndex = 0; <br>lpCurr = lpDriver-&gt;lpDeviceRoot; <br>while (lpCurr) <br>{ <br>TCHAR szBuff[80]; <br>DWORD dwNew; <br> <br>lpNext = lpCurr-&gt;lpNext; <br> <br>// Get Device String <br>wsprintf (szBuff, TEXT("%s"), lpCurr-&gt;szName); <br> <br>// Add String to Combo Box <br>dwNew = SendDlgItemMessage (hDlg, IDC_DEVICES, CB_ADDSTRING, 0, (LPARAM)(LPCTSTR)szBuff); <br> <br>// Set up pointer to device for this item <br>SendDlgItemMessage (hDlg, IDC_DEVICES, CB_SETITEMDATA, (WPARAM)dwNew, (LPARAM)(void *)lpCurr); <br> <br>// Is it the current device <br>if (lpDevice == lpCurr) <br>{ <br>// Set as our current selection <br>SendDlgItemMessage (hDlg, IDC_DEVICES, CB_SETCURSEL, (WPARAM)dwNew, 0L); <br>} <br> <br>lpCurr = lpNext; <br>} <br> <br>// Success <br>return TRUE; <br>} // End DlgDevicesInit <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       CompareModes <br>**  Purpose:    Comparision function used with Quick sort  <br>**to get sorted list of modes <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>int _cdecl CompareModes (const void * element1, const void * element2)  <br>{ <br>LPDDModeInfo lpMode1; <br>LPDDModeInfo lpMode2; <br>DWORD w1, h1, bpp1, refresh1; <br>DWORD w2, h2, bpp2, refresh2; <br>int   iCompare = 0; <br> <br>    lpMode1 = *((LPDDModeInfo *)element1); <br>    lpMode2 = *((LPDDModeInfo *)element2); <br> <br>// Handle Null pointers <br>if ((! lpMode1) &amp;&amp; (! lpMode2)) <br>return 0; <br>if ((lpMode1) &amp;&amp; (! lpMode2)) <br>return -1; <br>if ((! lpMode2) &amp;&amp; (lpMode2)) <br>return 1; <br> <br>// Get Mode Data <br>lpMode1-&gt;GetMode (w1, h1, bpp1, refresh1); <br>lpMode2-&gt;GetMode (w2, h2, bpp2, refresh2); <br> <br>// Sort first on BPP then width then height <br>    if (bpp1 &lt; bpp2) <br>iCompare = -1; <br>    else if (bpp1 &gt; bpp2) <br>iCompare = 1; <br>    else if (w1 &lt; w2) <br>iCompare = -1; <br>    else if (w1 &gt; w2) <br>iCompare = 1; <br>    else if (h1 &lt; h2) <br>iCompare = -1; <br>    else if (h1 &gt; h2) <br>iCompare = 1; <br> <br>// Equality <br>    return iCompare; <br>} // End CompareModes <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DlgModesInit <br>**  Purpose:    Set up Modes for dialog  <br>**  Notes:Shows list of current modes, compatible with the current  <br>**device.  This list is displayed in sorted order (bpp, w, h) <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>BOOL DlgModesInit (HWND hDlg) <br>{ <br>LPChangeDDInfolpChange; <br>LPDDDrvInfolpDriver; </code></pre>
<p>
</p>
<pre><code>LPD3DDevInfolpDevice; <br>LPDDModeInfolpModeCurr, lpModeRoot, lpCurr, lpNext; <br>DWORDcModes; <br>DWORDcbSize; <br>DWORDdwIndex; <br>LPDDModeInfo *lpModes; <br> <br>// Check Parameters <br>lpChange = (LPChangeDDInfo)(void *)GetWindowLong (hDlg, DWL_USER); <br>if (! lpChange) <br>return FALSE; <br> <br>lpDriver   = lpChange-&gt;lpDrvNew; <br>lpDevice   = lpChange-&gt;lpDevNew; <br>lpModeCurr = lpChange-&gt;lpModeNew; <br> <br>if (! lpDriver) <br>return FALSE; <br> <br>if (! lpDevice) <br>{ <br>lpDevice = ValidateDevice (lpDriver, NULL, NULL); <br>if (! lpDevice) <br>return FALSE; <br>} <br> <br>lpModeRoot = lpDriver-&gt;lpModeRoot; <br>if (! lpModeRoot) <br>return FALSE; <br> <br>cModes = lpDriver-&gt;countModes (); <br>if (! cModes) <br>return FALSE; <br> <br>if (! lpModeCurr) <br>{ <br>lpModeCurr = ValidateMode (lpDriver, 640, 480, 16, 0, lpDevice); <br>} <br> <br>// Get memory for Mode list <br>cbSize = cModes * sizeof (LPDDModeInfo); <br>lpModes = (LPDDModeInfo *) malloc (cbSize); <br>if (! lpModes) <br>return FALSE; <br> <br>// Create Mode List <br>dwIndex = 0; <br>lpCurr = lpModeRoot; <br>while (lpCurr) <br>{ <br>lpNext = lpCurr-&gt;lpNext; <br> <br>lpModes[dwIndex] = lpCurr; <br> <br>dwIndex++; <br> <br>lpCurr = lpNext; <br>} <br> <br>// Sort Mode list <br>    qsort ((void *)lpModes, (size_t)cModes, sizeof(LPDDModeInfo), CompareModes); <br> <br>// Dump Mode list to Combo Box <br>for (dwIndex = 0; dwIndex &lt; cModes; dwIndex++) <br>{ <br>// Make sure mode is supported by D3D device <br>if ((lpModes[dwIndex]) &amp;&amp;  <br>(lpModes[dwIndex]-&gt;ModeSupported (lpDevice))) <br>{ <br>TCHAR szBuff[80]; <br>DWORD w, h, bpp, refresh; <br>DWORD dwNew; <br> <br>lpModes[dwIndex]-&gt;GetMode (w, h, bpp, refresh); <br> <br>// Set up Mode String <br>if (refresh) <br>wsprintf (szBuff, TEXT("%4d x %4d x %4d (%4d Hz)"),  <br>      w, h, bpp, refresh); <br>else <br>wsprintf (szBuff, TEXT("%4d x %4d x %4d"),  <br>      w, h, bpp); <br> <br>// Add String to Combo Box <br>dwNew = SendDlgItemMessage (hDlg, IDC_MODES, CB_ADDSTRING, 0, (LPARAM)(LPCTSTR)szBuff); <br> <br>// Set up pointer to Mode Info for this item <br>SendDlgItemMessage (hDlg, IDC_MODES, CB_SETITEMDATA, (WPARAM)dwNew, (LPARAM)(void *)lpModes[dwIndex]); <br> <br>// Is it the current Mode  <br>if (lpModeCurr == lpModes[dwIndex]) <br>{ <br>// Set as our current selection <br>SendDlgItemMessage (hDlg, IDC_MODES, CB_SETCURSEL, (WPARAM)dwNew, 0L); <br>} <br>} <br>} <br> <br>// Cleanup Memory <br>free (lpModes); <br>lpModes = NULL; <br> <br>// Success <br>return TRUE; <br>} // End DlgModesInit <br> <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DlgGetDriver <br>**  Purpose:    Get current driver selection <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LPDDDrvInfo DlgGetDriver (HWND hDlg) <br>{ <br>DWORD dwIndex = SendDlgItemMessage (hDlg, IDC_DRIVERS, CB_GETCURSEL, 0, 0); <br>if (dwIndex != CB_ERR) <br>{ <br>// Get pointer to driver <br>LPDDDrvInfo lpDriver = (LPDDDrvInfo) SendDlgItemMessage (hDlg,  <br>       IDC_DRIVERS,  <br> CB_GETITEMDATA,  <br> (WPARAM)dwIndex,  <br> (LPARAM)0); <br>return lpDriver; <br>} <br> <br>// Failure <br>return NULL; <br>} // End DlgGetDriver <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DlgGetDevice <br>**  Purpose:    Get current device selection <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LPD3DDevInfo DlgGetDevice (HWND hDlg) <br>{ <br>DWORD dwIndex = SendDlgItemMessage (hDlg, IDC_DEVICES, CB_GETCURSEL, 0, 0); <br>if (dwIndex != CB_ERR) <br>{ <br>// Get pointer to device <br>LPD3DDevInfo lpDevice = (LPD3DDevInfo) SendDlgItemMessage (hDlg,  <br>         IDC_DEVICES,  <br>   CB_GETITEMDATA,  <br>   (WPARAM)dwIndex,  <br>   (LPARAM)0); <br>return lpDevice; <br>} <br> <br>// Failure <br>return NULL; <br>} // End DlgGetDevice <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DlgGetMode <br>**  Purpose:    Get current mode selection <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LPDDModeInfo DlgGetMode (HWND hDlg) <br>{ <br>DWORD dwIndex = SendDlgItemMessage (hDlg, IDC_MODES, CB_GETCURSEL, 0, 0); <br>if (dwIndex != CB_ERR) <br>{ <br>// Get pointer to device <br>LPDDModeInfo lpMode = (LPDDModeInfo) SendDlgItemMessage (hDlg,  <br>         IDC_MODES,  <br> CB_GETITEMDATA,  <br> (WPARAM)dwIndex,  <br> (LPARAM)0); <br>return lpMode; <br>} <br> <br>// Failure <br>return NULL; <br>} // End DlgGetMode <br> <br>   <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       OnChangeDriver <br>**  Purpose:    Allows user to choose a new Driver from dialog <br>**Notes:User can also choose a new device and mode <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>void OnChangeDriver (HWND hWindow, int idDialog) <br>{ <br>HINSTANCEhInstance; <br>intfResult; <br>ChangeDDInfochangeInfo; <br>LPD3DWindowlpd3dWindow; <br> <br>// Get application instance <br>hInstance = (HINSTANCE) GetWindowLong (hWindow, GWL_HINSTANCE); <br>if (! hInstance) <br>return; <br> <br>// Get D3D Window pointer <br>lpd3dWindow =  (LPD3DWindow)GetWindowLong (hWindow, GWL_USERDATA); <br>if (! lpd3dWindow) <br>return; <br> <br>// Setup Change info <br>changeInfo.lpDrvOrig= lpd3dWindow-&gt;GetDriverInfo (); <br>changeInfo.lpDrvNew= changeInfo.lpDrvOrig; <br> <br>changeInfo.lpDevOrig= lpd3dWindow-&gt;GetDeviceInfo (); <br>changeInfo.lpDevNew= changeInfo.lpDevOrig; <br> <br>changeInfo.lpModeOrig= lpd3dWindow-&gt;GetModeInfo (); <br>changeInfo.lpModeNew= changeInfo.lpModeOrig; <br> <br> <br>    // Pause App <br>    OnPause (hWindow, TRUE); <br> <br>    // Do Change Mode Dialog here <br>    fResult = DialogBoxParam (hInstance, MAKEINTRESOURCE (idDialog),  <br>  hWindow, (DLGPROC)ChangeDriverProc, <br>  (LPARAM)(void *)&amp;changeInfo); <br> <br>    // UnPause app <br>    OnPause (hWindow, FALSE); <br> <br>// Did user request a change ?!? <br>if (fResult == TRUE) <br>{ <br>LPGUID lpGuidDD, lpGuidD3D; <br> <br>if (changeInfo.lpDrvOrig != changeInfo.lpDrvNew) <br>{ <br>if (changeInfo.lpDrvNew) <br>lpGuidDD = changeInfo.lpDrvNew-&gt;GetGuid (); <br>else <br>lpGuidDD = NULL; <br> <br>lpd3dWindow-&gt;ChangeDriver (lpGuidDD, changeInfo.lpDevNew); <br>} <br>else if (changeInfo.lpDevOrig != changeInfo.lpDevNew) <br>{ <br>if (changeInfo.lpDevNew) <br>lpGuidD3D = &amp;(changeInfo.lpDevNew-&gt;guid); <br>else <br>lpGuidD3D = NULL; <br> <br>lpd3dWindow-&gt;ChangeDevice (lpGuidD3D); <br>} <br>} <br>} // End OnChangeDriver <br>   <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       ChangeDriverProc <br>**  Purpose:    handles messages for Change Driver, <br>**D3D device, and mode dialog boxes <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>BOOL CALLBACK ChangeDriverProc( <br>    HWND hDlg,// handle to dialog box <br>    UINT uiMsg,// message <br>    WPARAM wParam,// first message parameter <br>    LPARAM lParam) // second message parameter <br>{ <br>BOOLfChanged; <br>LPChangeDDInfo  lpChange; <br>LPDDDrvInfolpDriver; <br>LPDDModeInfolpMode; <br>LPD3DDevInfolpDevice; <br> <br>switch (uiMsg) <br>{ <br>case WM_COMMAND: <br>switch (LOWORD(wParam)) <br>{ <br>case IDOK: <br>// Get Change Info <br>lpChange = (LPChangeDDInfo) GetWindowLong (hDlg, DWL_USER); <br>if (! lpChange) <br>EndDialog (hDlg, FALSE); <br> <br>fChanged = FALSE; <br> <br>// Get New Driver <br>lpDriver = DlgGetDriver (hDlg); <br>if ((lpDriver) &amp;&amp; (lpDriver != lpChange-&gt;lpDrvOrig)) <br>{ <br>fChanged = TRUE; <br>lpChange-&gt;lpDrvNew = lpDriver; <br>} <br>else <br>lpChange-&gt;lpDrvNew = lpChange-&gt;lpDrvOrig; <br> <br>// Get New Device <br>lpDevice = DlgGetDevice (hDlg); <br>if ((lpDevice) &amp;&amp; (lpDevice != lpChange-&gt;lpDevOrig)) <br>{ <br>fChanged = TRUE; <br>lpChange-&gt;lpDevNew = lpDevice; <br>} <br>else <br>lpChange-&gt;lpDevNew = lpChange-&gt;lpDevOrig; <br> <br>// Get New Mode <br>lpMode = DlgGetMode (hDlg); <br>if ((lpMode) &amp;&amp; (lpMode != lpChange-&gt;lpModeOrig)) <br>{ <br>fChanged = TRUE; <br>lpChange-&gt;lpModeNew = lpMode; <br>} <br>else <br>lpChange-&gt;lpModeNew = lpChange-&gt;lpModeOrig; <br> <br>// Return success/failure <br>EndDialog (hDlg, fChanged); <br>break; <br> <br>case IDCANCEL: <br>EndDialog (hDlg, FALSE); <br>break; <br> <br>case IDC_DRIVERS: <br>switch (HIWORD (wParam)) <br>{ <br>case CBN_SELENDOK: <br>// User has changed the current driver <br>lpChange = (LPChangeDDInfo) GetWindowLong (hDlg, DWL_USER); <br> <br>// Check if user has changed the Driver <br>lpDriver = DlgGetDriver (hDlg); <br>if ((lpDriver) &amp;&amp; (lpDriver != lpChange-&gt;lpDrvNew)) <br>{ <br>lpChange-&gt;lpDrvNew = lpDriver; <br>lpChange-&gt;lpDevNew = NULL;// Pick a new device <br>lpChange-&gt;lpModeNew = NULL;// Pick a new mode <br> <br>// Update the Device list <br>SendDlgItemMessage (hDlg, IDC_DEVICES, CB_RESETCONTENT, 0, 0); <br>DlgDevicesInit (hDlg); <br> <br>// Update the Mode list <br>SendDlgItemMessage (hDlg, IDC_MODES, CB_RESETCONTENT, 0, 0); <br>DlgModesInit (hDlg); <br>} <br>break; <br>} <br>break; <br> <br>case IDC_DEVICES: <br>switch (HIWORD (wParam)) <br>{ <br>case CBN_SELENDOK: <br>// User has changed the current device <br>lpChange = (LPChangeDDInfo) GetWindowLong (hDlg, DWL_USER); <br> <br>// Check if user has changed the device <br>lpDevice = DlgGetDevice (hDlg); <br>if ((lpDevice) &amp;&amp; (lpDevice != lpChange-&gt;lpDevNew)) <br>{ <br>lpChange-&gt;lpDevNew = lpDevice; <br> <br>// Update the Mode list <br>SendDlgItemMessage (hDlg, IDC_MODES, CB_RESETCONTENT, 0, 0); <br>DlgModesInit (hDlg); <br>} <br>break; <br>} <br>break; <br> <br>case IDC_MODES: <br>switch (HIWORD (wParam)) <br>{ <br>case CBN_SELENDOK: <br>// User has changed the current mode <br>lpChange = (LPChangeDDInfo) GetWindowLong (hDlg, DWL_USER); <br> <br>// Check if user has changed the Mode <br>lpMode = DlgGetMode (hDlg); <br>if ((lpMode) &amp;&amp; (lpMode != lpChange-&gt;lpModeNew)) <br>{ <br>lpChange-&gt;lpModeNew = lpMode; <br>} <br>break; <br>} <br>break; <br>} <br>break; <br> <br>    case WM_INITDIALOG: <br>// Save pointer to ChangeInfo <br>SetWindowLong (hDlg, DWL_USER, (long)lParam); <br> <br>// Set up the current driver, device, and mode lists <br>if (GetDlgItem (hDlg, IDC_DRIVERS)) <br>if (! DlgDriversInit (hDlg)) <br>return FALSE; <br> <br>if (GetDlgItem (hDlg, IDC_DEVICES)) <br>if (! DlgDevicesInit (hDlg)) <br>return FALSE; <br> <br>if (GetDlgItem (hDlg, IDC_MODES)) <br>if (! DlgModesInit (hDlg)) <br>return FALSE; <br> <br>// Successful init <br>return TRUE; <br>} <br>return FALSE; <br>} // End ChangeDriverProc  <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  End of File <br>**----------------------------------------------------------------------------- <br>*/ <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
