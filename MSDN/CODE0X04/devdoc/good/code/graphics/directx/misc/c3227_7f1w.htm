<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>RMSTATS.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3254"></a>RMSTATS.CPP</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1995, 1996 Microsoft Corporation. All Rights Reserved. <br> * <br> *  File: rmstats.cpp <br> * <br> ***************************************************************************/ <br>#include "rmfull.h" <br> <br>/* <br> * GLOBAL VARIABLES <br> */ <br>extern D3DAppInfo* d3dapp;    /* Pointer to read only collection of DD and D3D <br>               objects maintained by D3DApp */ <br>extern rmfullglobals myglobs;    /* collection of global variables */ <br> <br>static struct { <br>    HFONT hFont; <br>    SIZE szFrameRate; <br>    SIZE szInfo; <br>} statglobs; <br> <br> /************************************************************************ <br>  Frame rate and info text <br> ************************************************************************/ <br> <br>BOOL <br>WriteFrameRateBuffer(float fps, long tps) <br>{ <br>    HRESULT LastError; <br>    HDC hdc; <br>    RECT rc; <br>    char buf1[30], buf2[30], buf[60]; <br>    int len; <br> <br>    if (!myglobs.lpFrameRateBuffer) <br>return TRUE; <br>    if (fps &gt; 0.0f) <br>        wsprintf(buf1, "%d.%02d fps   ", <br>        (int)( fps * 100 ) / 100, <br>        (int)( fps * 100 ) % 100); <br>    else <br>        buf1[0] = 0; <br>    if (tps &gt; 0) <br>        wsprintf(buf2, "%ld tps   ", tps); <br>    else <br>        buf2[0] = 0; <br>    len = wsprintf(buf, "%s%s", buf1, buf2); <br>    if (!myglobs.lpFrameRateBuffer) <br>        return FALSE; <br>    LastError = myglobs.lpFrameRateBuffer-&gt;GetDC(&amp;hdc); <br>    if (LastError != DD_OK) { <br>/* <br> *  This is not vital, don't report an error. <br> */ <br>        return TRUE; <br>    } <br>    SelectObject(hdc, statglobs.hFont); <br>    SetTextColor(hdc, RGB(255,255,0)); <br>    SetBkColor(hdc, RGB(0,0,0)); <br>    SetBkMode(hdc, OPAQUE); <br>    GetTextExtentPoint32(hdc, buf, len, &amp;statglobs.szFrameRate); <br>    SetRect(&amp;rc, 0, 0, statglobs.szFrameRate.cx, statglobs.szFrameRate.cy); <br>    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &amp;rc, buf, len, NULL); <br>    myglobs.lpFrameRateBuffer-&gt;ReleaseDC(hdc); <br>    return TRUE; <br>} <br> <br>BOOL <br>WriteInfoBuffer(void) <br>{ <br>    HRESULT LastError; <br>    HDC hdc; <br>    RECT rc; <br>    char buf[40]; <br>    int len; <br> <br>    if (!myglobs.lpInfoBuffer) <br>return TRUE; <br>    if (d3dapp-&gt;bFullscreen) <br>len = wsprintf(buf, "%dx%dx%d (%s)", d3dapp-&gt;ThisMode.w, d3dapp-&gt;ThisMode.h, d3dapp-&gt;ThisMode.bpp, <br>       (d3dapp-&gt;ThisDriver.Desc.dcmColorModel == D3DCOLOR_MONO) ? "MONO" : "RGB"); <br>    else <br>len = wsprintf(buf, "%dx%d (%s)", d3dapp-&gt;szClient.cx, d3dapp-&gt;szClient.cy,  <br>       (d3dapp-&gt;ThisDriver.Desc.dcmColorModel == D3DCOLOR_MONO) ? "MONO" : "RGB"); <br>    if (!myglobs.lpInfoBuffer) <br>        return FALSE; <br>    LastError = myglobs.lpInfoBuffer-&gt;GetDC(&amp;hdc); <br>    if (LastError != DD_OK) { <br>/* <br> *  This is not vital, don't report an error. <br> */ <br>        return TRUE; <br>    } <br> <br>    SelectObject(hdc, statglobs.hFont); <br>    SetTextColor(hdc, RGB(255,255,0)); <br>    SetBkColor(hdc, RGB(0,0,0)); <br>    SetBkMode(hdc, OPAQUE); <br>    GetTextExtentPoint32(hdc, buf, len, &amp;statglobs.szInfo); <br>    SetRect(&amp;rc, 0, 0, statglobs.szInfo.cx, statglobs.szInfo.cy); <br>    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &amp;rc, buf, len, NULL); <br>    myglobs.lpInfoBuffer-&gt;ReleaseDC(hdc); <br>    return TRUE; <br>} <br> <br> <br>BOOL <br>InitFontAndTextBuffers(void) <br>{ <br>    DDCOLORKEY          ddck; <br>    DDSURFACEDESC       ddsd; <br>    HDC hdc; <br>    HRESULT ddrval; <br>    char dummyinfo[] = "000x000x00 (MONO) 0000"; <br>    char dummyfps[] = "000.00 fps 00000000.00 tps 0000.00 mppps"; <br>    <br>    /* <br>     * Create the font. <br>     */ <br>    RELEASE(myglobs.lpInfoBuffer); <br>    RELEASE(myglobs.lpFrameRateBuffer); <br>    if (statglobs.hFont != NULL) { <br>        DeleteObject(statglobs.hFont); <br>    } <br>    statglobs.hFont = CreateFont( <br>        d3dapp-&gt;szClient.cx &lt;= 600 ? 12 : 24, <br>        0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE, <br>        ANSI_CHARSET, <br>        OUT_DEFAULT_PRECIS, <br>        CLIP_DEFAULT_PRECIS, <br>        DEFAULT_QUALITY, <br>        VARIABLE_PITCH, <br>        "Arial" ); <br> <br>    hdc = GetDC(NULL); <br>    SelectObject(hdc, statglobs.hFont); <br>    GetTextExtentPoint(hdc, dummyfps, strlen(dummyfps), &amp;statglobs.szFrameRate); <br>    GetTextExtentPoint(hdc, dummyinfo, strlen(dummyinfo), &amp;statglobs.szInfo); <br>    ReleaseDC(NULL, hdc); <br> <br>    memset( &amp;ddsd, 0, sizeof( ddsd ) ); <br>    ddsd.dwSize = sizeof( ddsd ); <br>    ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT |DDSD_WIDTH; <br>    ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN; <br>    ddsd.dwHeight = statglobs.szFrameRate.cy; <br>    ddsd.dwWidth = statglobs.szFrameRate.cx; <br>    ddrval = D3DAppCreateSurface(&amp;ddsd, &amp;myglobs.lpFrameRateBuffer); <br>    if (ddrval != DD_OK) { <br>Msg("Could not create frame rate buffer.\n%s", D3DAppErrorToString(ddrval)); <br>        goto exit_with_error; <br>    } <br>    memset(&amp;ddck, 0, sizeof(ddck)); <br>    myglobs.lpFrameRateBuffer-&gt;SetColorKey(DDCKEY_SRCBLT, &amp;ddck); <br>    if (!WriteFrameRateBuffer(0.0f, 0)) { <br>        goto exit_with_error; <br>    } <br>    memset( &amp;ddsd, 0, sizeof( ddsd ) ); <br>    ddsd.dwSize = sizeof( ddsd ); <br>    ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT |DDSD_WIDTH; <br>    ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN; <br>    ddsd.dwHeight = statglobs.szInfo.cy; <br>    ddsd.dwWidth = statglobs.szInfo.cx; <br>    ddrval = D3DAppCreateSurface(&amp;ddsd, &amp;myglobs.lpInfoBuffer); <br>    if (ddrval != DD_OK) { <br>Msg("Could not create info buffer.\n%s", D3DAppErrorToString(ddrval)); <br>goto exit_with_error; <br>    } <br>    memset(&amp;ddck, 0, sizeof(ddck)); <br>    myglobs.lpInfoBuffer-&gt;SetColorKey(DDCKEY_SRCBLT, &amp;ddck); <br>    if (!WriteInfoBuffer()) <br>goto exit_with_error; <br>    return TRUE; <br>exit_with_error: <br>    RELEASE(myglobs.lpInfoBuffer); <br>    RELEASE(myglobs.lpFrameRateBuffer); <br>    if (statglobs.hFont != NULL) { <br>        DeleteObject(statglobs.hFont); <br>    } <br>    return FALSE; <br>} <br> <br>/************************************************************************* <br>  Frame rate output. <br> *************************************************************************/ <br> <br>#define INTERVAL 100 <br> <br>char StatTxt[100]; <br>int StatTxtLen; <br>int count = 0; <br>int last_polygons = 0; <br>int this_frames = 0; <br>time_t last_time; <br>float fps; <br>long tps; <br> <br>/* <br> * ResetFrameRate <br> * Initializes the frame rate counter. <br> */ <br>void <br>ResetFrameRate(void) <br>{ <br>    last_time = clock(); <br>    count = 0; <br>    last_polygons = 0; <br>    this_frames = 0; <br>    fps = 0.0f; tps = 0; <br>    StatTxt[0] = 0; <br>    StatTxtLen = 0; <br>} <br> <br>BOOL <br>CalculateFrameRate() <br>{ <br>    /* <br>     * Calculate the frame rate and get other stats. <br>     */ <br>    count++; <br>    this_frames++; <br>    if (count == INTERVAL) { <br>    double t; <br>int p, f; <br>        time_t this_time; <br> <br>        count = 0; <br>this_time = clock(); <br>t = (this_time - last_time) / (double)CLOCKS_PER_SEC; <br>last_time = this_time; <br> <br>p = myglobs.dev-&gt;GetTrianglesDrawn() - last_polygons; <br>last_polygons = myglobs.dev-&gt;GetTrianglesDrawn(); <br> <br>f = this_frames; <br>this_frames = 0; <br> <br>        fps = (float)(f / t); <br>        tps = (long)(p / t); <br> <br>        if (myglobs.bShowFrameRate) { <br>            if (!WriteFrameRateBuffer(fps, tps)) <br>                return FALSE; <br>        } <br>    } <br>    return TRUE; <br>} <br> <br>/* <br> * DisplayFrameRate <br> * Outputs frame rate info and screen mode to back buffer when appropriate. <br> */ <br>BOOL <br>DisplayFrameRate(int* count, LPD3DRECT lpExtents ) <br>{ <br>    RECT rc; <br>    int x, y; <br>    HRESULT ddrval = DD_OK; <br>    if (myglobs.bShowFrameRate &amp;&amp; !myglobs.bSingleStepMode &amp;&amp; statglobs.szFrameRate.cx &gt; 0 &amp;&amp; statglobs.szFrameRate.cy &gt; 0 &amp;&amp; <br>        statglobs.szFrameRate.cx &lt; d3dapp-&gt;szClient.cx &amp;&amp; statglobs.szFrameRate.cy &lt; d3dapp-&gt;szClient.cy) { <br>        SetRect(&amp;rc, 0, 0, statglobs.szFrameRate.cx, statglobs.szFrameRate.cy); <br>        x = (int)(0.5 * (d3dapp-&gt;szClient.cx - statglobs.szFrameRate.cx) + 0.5); <br>        y = 0; <br>if (myglobs.lpFrameRateBuffer) <br>    ddrval = d3dapp-&gt;lpBackBuffer-&gt;BltFast(x, y, myglobs.lpFrameRateBuffer, &amp;rc, <br> DDBLTFAST_SRCCOLORKEY | DDBLTFAST_WAIT); <br>if (ddrval != DD_OK) { <br>    /* <br>     * Blting the frame rate has failed. Since it is not vital, we <br>     * aren't going to report an error.  Check to see if the surfaces <br>     * have been lost and then return. <br>     */ <br>    if (ddrval == DDERR_SURFACELOST) { <br>d3dapp-&gt;lpBackBuffer-&gt;Restore(); <br>myglobs.lpFrameRateBuffer-&gt;Restore(); <br>    } <br>    return TRUE; <br>} <br>SetRect((LPRECT)(lpExtents), x, y, statglobs.szFrameRate.cx + x, statglobs.szFrameRate.cy); <br>++(*count); <br>++lpExtents; <br>    } <br>    if (myglobs.bShowInfo &amp;&amp; statglobs.szInfo.cx &lt; d3dapp-&gt;szClient.cx &amp;&amp; statglobs.szInfo.cy &lt; d3dapp-&gt;szClient.cy) { <br>        SetRect(&amp;rc, 0, 0, statglobs.szInfo.cx, statglobs.szInfo.cy); <br>        x = (int)(0.5 * (d3dapp-&gt;szClient.cx - statglobs.szInfo.cx) + 0.5); <br>        y = d3dapp-&gt;szClient.cy - statglobs.szInfo.cy; <br>if (myglobs.lpInfoBuffer) <br>    ddrval = d3dapp-&gt;lpBackBuffer-&gt;BltFast(x,y, myglobs.lpInfoBuffer, &amp;rc, <br> DDBLTFAST_SRCCOLORKEY | DDBLTFAST_WAIT); <br>if (ddrval != DD_OK) { <br>    /* <br>     * Blting the info has failed. Since it is not vital, we <br>     * aren't going to report an error.  Check to see if the surfaces <br>     * have been lost and then return. <br>     */ <br>    if (ddrval == DDERR_SURFACELOST) { <br>d3dapp-&gt;lpBackBuffer-&gt;Restore(); <br>myglobs.lpInfoBuffer-&gt;Restore(); <br>    } <br>    return TRUE; <br>} <br>SetRect((LPRECT)(lpExtents), x, y, x + statglobs.szInfo.cx, y + statglobs.szInfo.cy); <br>++(*count); <br>    } <br>    return TRUE; <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
