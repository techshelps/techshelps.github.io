<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>RMMAIN.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3252"></a>RMMAIN.CPP</h2>
<pre><code>/* <br> *  Copyright (C) 1995, 1996 Microsoft Corporation. All Rights Reserved. <br> * <br> *  File: rmmain.cpp <br> * <br> *  Each of the Direct3D retained mode (D3DRM) samples must be linked with <br> *  this file.  It contains the code which allows them to run in the Windows <br> *  environment. <br> * <br> *  A window is created using the rmmain.res which allows the user to select <br> *  the Direct3D driver to use and change the render options. <br> * <br> *  Individual samples are executed through two functions, BuildScene and <br> *  OverrideDefaults, as described in rmdemo.h.  Samples can also read <br> *  mouse input via ReadMouse. <br> */ <br> <br>#define INITGUID <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;malloc.h&gt; <br>#include &lt;math.h&gt; <br>#include &lt;direct.h&gt; <br>#include &lt;d3drmwin.h&gt; <br>#include "rmdemo.h"             /* prototypes for functions to commumicate <br>                                   with each sample */ <br>#include "rmmain.h"             /* defines constants used in rmmain.rc */ <br>#include "rmerror.h"            /* prototypes for error reporting: error.c */ <br> <br>#define MAX_DRIVERS 5           /* maximum D3D drivers we ever expect to find */ <br> <br>/*  <br> * GLOBAL VARIABLES <br> */ <br>LPDIRECT3DRM lpD3DRM;           /* Direct3DRM object */ <br>LPDIRECTDRAWCLIPPER lpDDClipper;/* DirectDrawClipper object */ <br> <br>struct _myglobs { <br>    LPDIRECT3DRMDEVICE dev;     /* Direct3DRM device */ <br>    LPDIRECT3DRMVIEWPORT view;  /* Direct3DRM viewport through which we view <br>                                   the scene */ <br>    LPDIRECT3DRMFRAME scene;    /* Master frame in which others are placed */ <br>    LPDIRECT3DRMFRAME camera;   /* Frame describing the users POV */ <br> <br>    GUID DriverGUID[MAX_DRIVERS];     /* GUIDs of the available D3D drivers */ <br>    char DriverName[MAX_DRIVERS][50]; /* names of the available D3D drivers */ <br>    int  NumDrivers;                  /* number of available D3D drivers */ <br>    int  CurrDriver;                  /* number of D3D driver currently <br>                                         being used */ <br> <br>    D3DRMRENDERQUALITY RenderQuality;   /* current shade mode, fill mode and <br>                                           lighting state */ <br>    D3DRMTEXTUREQUALITY TextureQuality; /* current texture interpolation */ <br>    BOOL bDithering;                    /* is dithering on? */ <br>    BOOL bAntialiasing;                 /* is antialiasing on? */ <br> <br>    BOOL bQuit;                 /* program is about to terminate */ <br>    BOOL bInitialized;          /* all D3DRM objects have been initialized */ <br>    BOOL bMinimized;            /* window is minimized */ <br>    BOOL bSingleStepMode;       /* render one frame at a time */ <br>    BOOL bDrawAFrame;           /* render on this pass of the main loop */ <br>    BOOL bNoTextures;           /* this sample doesn't use any textures */ <br>    BOOL bConstRenderQuality;   /* this sample is not constructed with <br>                                   MeshBuilders and so the RenderQuality <br>                                   cannot be changed */ <br> <br>    int BPP;                    /* bit depth of the current display mode */ <br> <br>    int mouse_buttons;          /* mouse button state */ <br>    int mouse_x;                /* mouse cursor x position */ <br>    int mouse_y;                /* mouse cursor y position */ <br>} myglobs; <br> <br>/* <br> * PROTOTYPES <br> */ <br>static HWND InitApp(HINSTANCE, int); <br>static void InitGlobals(void); <br>long FAR PASCAL WindowProc(HWND, UINT, WPARAM, LPARAM); <br>static HRESULT CreateDevAndView(LPDIRECTDRAWCLIPPER lpDDClipper, int driver, int width, int height); <br>static BOOL RenderLoop(void); <br>static void CleanUpAndPostQuit(void); <br>static HRESULT SetRenderState(void); <br>static BOOL EnumDevices(HWND win); <br>extern "C" void ReadMouse(int*, int*, int*); <br> <br>/****************************************************************************/ <br>/*                               WinMain                                    */ <br>/****************************************************************************/ <br>/* <br> * Initializes the application then enters a message loop which renders the <br> * scene until a quit message is received. <br> */ <br>int PASCAL <br>WinMain (HINSTANCE this_inst, HINSTANCE prev_inst, LPSTR cmdline, int cmdshow) <br>{ <br>    HWND    hwnd; <br>    MSG     msg; <br>    HACCEL  accel; <br>    int     failcount = 0;  /* number of times RenderLoop has failed */ <br> <br>    prev_inst; <br>    cmdline; <br> <br>    /* <br>     * Create the window and initialize all objects needed to begin rendering <br>     */ <br>    if (!(hwnd = InitApp(this_inst, cmdshow))) <br>        return 1; <br> <br>    accel = LoadAccelerators(this_inst, "AppAccel"); <br> <br>    while (!myglobs.bQuit) { <br>        /*  <br>         * Monitor the message queue until there are no pressing <br>         * messages <br>         */ <br>        while (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) { <br>            if (msg.message == WM_QUIT) { <br>                CleanUpAndPostQuit(); <br>                break; <br>            } <br>            if (!TranslateAccelerator(msg.hwnd, accel, &amp;msg)) { <br>                TranslateMessage(&amp;msg); <br>                DispatchMessage(&amp;msg); <br>            } <br>        } <br>if (myglobs.bQuit) <br>    break; <br>        /*  <br>         * If the app is not minimized, not about to quit and D3DRM has <br>         * been initialized, we can render <br>         */ <br>        if (!myglobs.bMinimized &amp;&amp; !myglobs.bQuit &amp;&amp; myglobs.bInitialized) { <br>            /* <br>             * If were are not in single step mode or if we are and the <br>             * bDrawAFrame flag is set, render one frame <br>             */ <br>            if (!(myglobs.bSingleStepMode &amp;&amp; !myglobs.bDrawAFrame)) { <br>                /*  <br>                 * Attempt to render a frame, if it fails, take a note.  If <br>                 * rendering fails more than twice, abort execution. <br>                 */ <br>                if (!RenderLoop()) <br>                    ++failcount; <br>                if (failcount &gt; 2) { <br>                    Msg("Rendering has failed too many times.  Aborting execution.\n"); <br>                    CleanUpAndPostQuit(); <br>                    break; <br>                } <br>            } <br>            /* <br>             * Reset the bDrawAFrame flag if we are in single step mode <br>             */ <br>            if (myglobs.bSingleStepMode) <br>                myglobs.bDrawAFrame = FALSE; <br>        } else { <br>    WaitMessage(); <br>} <br>    } <br>    DestroyWindow(hwnd); <br>    return msg.wParam; <br>} <br> <br>/****************************************************************************/ <br>/*                   Initialization and object creation                     */ <br>/****************************************************************************/ <br>/* <br> * InitApp <br> * Creates window and initializes all objects neccessary to begin rendering <br> */ <br>static HWND <br>InitApp(HINSTANCE this_inst, int cmdshow) <br>{ <br>    HWND win; <br>    HDC hdc; <br>    DWORD flags; <br>    WNDCLASS wc; <br>    Defaults defaults; <br>    HRESULT rval; <br>    RECT rc; <br> <br>    /* <br>     * set up and registers the window class <br>     */ <br>    wc.style = CS_HREDRAW | CS_VREDRAW; <br>    wc.lpfnWndProc = WindowProc; <br>    wc.cbClsExtra = 0; <br>    wc.cbWndExtra = sizeof(DWORD); <br>    wc.hInstance = this_inst; <br>    wc.hIcon = LoadIcon(this_inst, "AppIcon"); <br>    wc.hCursor = LoadCursor(NULL, IDC_ARROW); <br>    wc.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH); <br>    wc.lpszMenuName = "AppMenu"; <br>    wc.lpszClassName = "D3DRM Example"; <br>    if (!RegisterClass(&amp;wc)) <br>        return FALSE; <br>    /* <br>     * Initialize the global variables and allow the sample code to override <br>     * some of these default settings. <br>     */ <br>    InitGlobals(); <br>    defaults.bNoTextures = myglobs.bNoTextures; <br>    defaults.bConstRenderQuality = myglobs.bConstRenderQuality; <br>    defaults.bResizingDisabled = FALSE; <br>    lstrcpy(defaults.Name, "D3DRM Example"); <br>    OverrideDefaults(&amp;defaults); <br>    myglobs.bNoTextures = defaults.bNoTextures; <br>    myglobs.bConstRenderQuality = defaults.bConstRenderQuality; <br>    /* <br>     * Create the window <br>     */ <br>    if (defaults.bResizingDisabled) <br>        flags =  WS_VISIBLE | WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | <br>                 WS_MINIMIZEBOX | WS_MAXIMIZEBOX; <br>    else <br>        flags = WS_OVERLAPPEDWINDOW; <br>    win = <br>        CreateWindow <br>        (   "D3DRM Example",            /* class */ <br>            defaults.Name,              /* caption */ <br>            flags,                      /* style */ <br>            CW_USEDEFAULT,              /* init. x pos */ <br>            CW_USEDEFAULT,              /* init. y pos */ <br>            300,                        /* init. x size */ <br>            300,                        /* init. y size */ <br>            NULL,                       /* parent window */ <br>            NULL,                       /* menu handle */ <br>            this_inst,                  /* program handle */ <br>            NULL                        /* create parms */ <br>        ); <br>    if (!win) <br>        return FALSE; <br>    /* <br>     * Record the current display BPP <br>     */ <br>    hdc = GetDC(win); <br>    myglobs.BPP = GetDeviceCaps(hdc, BITSPIXEL); <br>    ReleaseDC(win, hdc); <br>    /* <br>     * Enumerate the D3D drivers and select one <br>     */ <br>    if (!EnumDevices(win)) <br>        return FALSE; <br>    /* <br>     * Create the D3DRM object and the D3DRM window object <br>     */ <br>    rval = Direct3DRMCreate(&amp;lpD3DRM); <br>    if (rval != D3DRM_OK) { <br>        Msg("Failed to create Direct3DRM.\n%s", D3DRMErrorToString(rval)); <br>        return FALSE; <br>    } <br>    /* <br>     * Create the master scene frame and camera frame <br>     */ <br>    rval = lpD3DRM-&gt;CreateFrame(NULL, &amp;myglobs.scene); <br>    if (rval != D3DRM_OK) { <br>        Msg("Failed to create the master scene frame.\n%s", D3DRMErrorToString(rval)); <br>        return FALSE; <br>    } <br>    rval = lpD3DRM-&gt;CreateFrame(myglobs.scene, &amp;myglobs.camera); <br>    if (rval != D3DRM_OK) { <br>        Msg("Failed to create the camera's frame.\n%s", D3DRMErrorToString(rval)); <br>        return FALSE; <br>    } <br>    rval = myglobs.camera-&gt;SetPosition(myglobs.scene, D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0)); <br>    if (rval != D3DRM_OK) { <br>        Msg("Failed to position the camera in the frame.\n%s", D3DRMErrorToString(rval)); <br>        return FALSE; <br>    } <br>    /* <br>     * Create a clipper and associate the window with it <br>     */ <br>    rval = DirectDrawCreateClipper(0, &amp;lpDDClipper, NULL); <br>    if (rval != DD_OK) { <br>        Msg("Failed to create DirectDrawClipper"); <br>        return FALSE; <br>    } <br>    rval = lpDDClipper-&gt;SetHWnd(0, win); <br>    if (rval != DD_OK) { <br>        Msg("Failed to set hwnd on the clipper"); <br>        return FALSE; <br>    } <br>    /* <br>     * Created the D3DRM device with the selected D3D driver <br>     */ <br>    GetClientRect(win, &amp;rc); <br>    if (rval = CreateDevAndView(lpDDClipper, myglobs.CurrDriver, rc.right, rc.bottom)) { <br>myglobs.CurrDriver = 0; <br>if (rval = CreateDevAndView(lpDDClipper, myglobs.CurrDriver, rc.right, rc.bottom)) { <br>    Msg("Failed to create the D3DRM device.\n%s", D3DRMErrorToString(rval)); <br>    return FALSE; <br>} <br>    } <br>    /* <br>     * Create the scene to be rendered by calling this sample's BuildScene <br>     */ <br>    if (!BuildScene(myglobs.dev, myglobs.view, myglobs.scene, myglobs.camera)) <br>        return FALSE; <br>    /* <br>     * Display the window <br>     */ <br>    ShowWindow(win, cmdshow); <br>    UpdateWindow(win); <br>    /* <br>     * Now we are ready to render <br>     */ <br>    myglobs.bInitialized = TRUE; <br> <br>    return win; <br>} <br> <br>/* <br> * CreateDevAndView <br> * Create the D3DRM device and viewport with the given D3D driver and of the <br> * specified size. <br> */ <br>static HRESULT <br>CreateDevAndView(LPDIRECTDRAWCLIPPER lpDDClipper, int driver, int width, int height) <br>{ <br>    HRESULT rval; <br> <br>    if (!width || !height) <br>        return D3DRMERR_BADVALUE; <br>    /* <br>     * Create the D3DRM device from this window and using the specified D3D <br>     * driver. <br>     */ <br>    rval = lpD3DRM-&gt;CreateDeviceFromClipper(lpDDClipper, &amp;myglobs.DriverGUID[driver], <br>                                        width, height, &amp;myglobs.dev); <br>    if (rval != D3DRM_OK) <br>        return rval; <br>    /* <br>     * Create the D3DRM viewport using the camera frame.  Set the background <br>     * depth to a large number.  The width and height may be slightly <br>     * adjusted, so get them from the device to be sure. <br>     */ <br>    width = myglobs.dev-&gt;GetWidth(); <br>    height = myglobs.dev-&gt;GetHeight(); <br>    rval = lpD3DRM-&gt;CreateViewport(myglobs.dev, myglobs.camera, 0, 0, width, <br>                                   height, &amp;myglobs.view); <br>    if (rval != D3DRM_OK) { <br>myglobs.bInitialized = FALSE; <br>        RELEASE(myglobs.dev); <br>        return rval; <br>    } <br>    rval = myglobs.view-&gt;SetBack(D3DVAL(5000.0)); <br>    if (rval != D3DRM_OK) { <br>myglobs.bInitialized = FALSE; <br>        RELEASE(myglobs.dev); <br>        RELEASE(myglobs.view); <br>        return rval; <br>    } <br>    /* <br>     * Set the render quality, fill mode, lighting state and color shade info <br>     */ <br>    if (rval = SetRenderState()) { <br>myglobs.bInitialized = FALSE; <br>        RELEASE(myglobs.dev); <br>        RELEASE(myglobs.view); <br>        return rval; <br>    } <br> <br>    return D3DRM_OK; <br>} <br> <br>/****************************************************************************/ <br>/*                         D3D Device Enumeration                           */ <br>/****************************************************************************/ <br>/* <br> * BPPToDDBD <br> * Converts bits per pixel to a DirectDraw bit depth flag <br> */ <br>static DWORD <br>BPPToDDBD(int bpp) <br>{ <br>    switch(bpp) { <br>        case 1: <br>            return DDBD_1; <br>        case 2: <br>            return DDBD_2; <br>        case 4: <br>            return DDBD_4; <br>        case 8: <br>            return DDBD_8; <br>        case 16: <br>            return DDBD_16; <br>        case 24: <br>            return DDBD_24; <br>        case 32: <br>            return DDBD_32; <br>        default: <br>            return 0; <br>    } <br>} <br> <br>/* <br> * enumDeviceFunc <br> * Callback function which records each usable D3D driver's name and GUID <br> * Chooses a driver to begin with and sets *lpContext to this starting driver <br> */ <br>static HRESULT <br>WINAPI enumDeviceFunc(LPGUID lpGuid, LPSTR lpDeviceDescription, LPSTR lpDeviceName, <br>        LPD3DDEVICEDESC lpHWDesc, LPD3DDEVICEDESC lpHELDesc, LPVOID lpContext) <br>{ <br>    static BOOL hardware = FALSE; /* current start driver is hardware */ <br>    static BOOL mono = FALSE;     /* current start driver is mono light */ <br>    LPD3DDEVICEDESC lpDesc; <br>    int *lpStartDriver = (int *)lpContext; <br>    /* <br>     * Decide which device description we should consult <br>     */ <br>    lpDesc = lpHWDesc-&gt;dcmColorModel ? lpHWDesc : lpHELDesc; <br>    /* <br>     * If this driver cannot render in the current display bit depth skip <br>     * it and continue with the enumeration. <br>     */ <br>    if (!(lpDesc-&gt;dwDeviceRenderBitDepth &amp; BPPToDDBD(myglobs.BPP))) <br>        return D3DENUMRET_OK; <br>    /* <br>     * Record this driver's info <br>     */ <br>    memcpy(&amp;myglobs.DriverGUID[myglobs.NumDrivers], lpGuid, sizeof(GUID)); <br>    lstrcpy(&amp;myglobs.DriverName[myglobs.NumDrivers][0], lpDeviceName); <br>    /* <br>     * Choose hardware over software, RGB lights over mono lights <br>     */ <br>    if (*lpStartDriver == -1) { <br>        /* <br>         * this is the first valid driver <br>         */ <br>        *lpStartDriver = myglobs.NumDrivers; <br>        hardware = lpDesc == lpHWDesc ? TRUE : FALSE; <br>        mono = lpDesc-&gt;dcmColorModel &amp; D3DCOLOR_MONO ? TRUE : FALSE; <br>    } else if (lpDesc == lpHWDesc &amp;&amp; !hardware) { <br>        /* <br>         * this driver is hardware and start driver is not <br>         */ <br>        *lpStartDriver = myglobs.NumDrivers; <br>        hardware = lpDesc == lpHWDesc ? TRUE : FALSE; <br>        mono = lpDesc-&gt;dcmColorModel &amp; D3DCOLOR_MONO ? TRUE : FALSE; <br>    } else if ((lpDesc == lpHWDesc &amp;&amp; hardware ) || (lpDesc == lpHELDesc <br>                                                     &amp;&amp; !hardware)) { <br>        if (lpDesc-&gt;dcmColorModel == D3DCOLOR_MONO &amp;&amp; !mono) { <br>            /* <br>             * this driver and start driver are the same type and this <br>             * driver is mono while start driver is not <br>             */ <br>            *lpStartDriver = myglobs.NumDrivers; <br>            hardware = lpDesc == lpHWDesc ? TRUE : FALSE; <br>            mono = lpDesc-&gt;dcmColorModel &amp; D3DCOLOR_MONO ? TRUE : FALSE; <br>        } <br>    } <br>    myglobs.NumDrivers++; <br>    if (myglobs.NumDrivers == MAX_DRIVERS) <br>        return (D3DENUMRET_CANCEL); <br>    return (D3DENUMRET_OK); <br>} <br> <br>/* <br> * EnumDevices <br> * Enumerate the available D3D drivers, add them to the file menu, and choose <br> * one to use. <br> */ <br>static BOOL <br>EnumDevices(HWND win) <br>{ <br>    LPDIRECTDRAW lpDD; <br>    LPDIRECT3D lpD3D; <br>    HRESULT rval; <br>    HMENU hmenu; <br>    int i; <br> <br>    /* <br>     * Create a DirectDraw object and query for the Direct3D interface to use <br>     * to enumerate the drivers. <br>     */ <br>    rval = DirectDrawCreate(NULL, &amp;lpDD, NULL); <br>    if (rval != DD_OK) { <br>        Msg("Creation of DirectDraw HEL failed.\n%s", D3DRMErrorToString(rval)); <br>        return FALSE; <br>    } <br>    rval = lpDD-&gt;QueryInterface(IID_IDirect3D, (void**) &amp;lpD3D); <br>    if (rval != DD_OK) { <br>        Msg("Creation of Direct3D interface failed.\n%s", D3DRMErrorToString(rval)); <br>        lpDD-&gt;Release(); <br>        return FALSE; <br>    } <br>    /* <br>     * Enumerate the drivers, setting CurrDriver to -1 to initialize the <br>     * driver selection code in enumDeviceFunc <br>     */ <br>    myglobs.CurrDriver = -1; <br>    rval = lpD3D-&gt;EnumDevices(enumDeviceFunc, &amp;myglobs.CurrDriver); <br>    if (rval != DD_OK) { <br>        Msg("Enumeration of drivers failed.\n%s", D3DRMErrorToString(rval)); <br>        return FALSE; <br>    } <br>    /* <br>     * Make sure we found at least one valid driver <br>     */ <br>    if (myglobs.NumDrivers == 0) { <br>        Msg("Could not find a D3D driver which is compatible with this display depth"); <br>        return FALSE; <br>    } <br>    lpD3D-&gt;Release(); <br>    lpDD-&gt;Release(); <br>    /* <br>     * Add the driver names to the File menu <br>     */ <br>    hmenu = GetSubMenu(GetMenu(win), 0); <br>    for (i = 0; i &lt; myglobs.NumDrivers; i++) { <br>        InsertMenu(hmenu, 5 + i, MF_BYPOSITION | MF_STRING, MENU_FIRST_DRIVER + i, <br>                   myglobs.DriverName[i]); <br>    } <br>    return TRUE; <br>} <br> <br>/****************************************************************************/ <br>/*                             Render Loop                                  */ <br>/****************************************************************************/ <br>/* <br> * Clear the viewport, render the next frame and update the window <br> */ <br>static BOOL <br>RenderLoop() <br>{ <br>    HRESULT rval; <br>    /* <br>     * Tick the scene <br>     */ <br>    rval = myglobs.scene-&gt;Move(D3DVAL(1.0)); <br>    if (rval != D3DRM_OK) { <br>        Msg("Moving scene failed.\n%s", D3DRMErrorToString(rval)); <br>        return FALSE; <br>    } <br>    /*  <br>     * Clear the viewport <br>     */ <br>    rval = myglobs.view-&gt;Clear(); <br>    if (rval != D3DRM_OK) { <br>        Msg("Clearing viewport failed.\n%s", D3DRMErrorToString(rval)); <br>        return FALSE; <br>    } <br>    /* <br>     * Render the scene to the viewport <br>     */ <br>    rval = myglobs.view-&gt;Render(myglobs.scene); <br>    if (rval != D3DRM_OK) { <br>        Msg("Rendering scene failed.\n%s", D3DRMErrorToString(rval)); <br>        return FALSE; <br>    } <br>    /* <br>     * Update the window <br>     */ <br>    rval = myglobs.dev-&gt;Update(); <br>    if (rval != D3DRM_OK) { <br>        Msg("Updating device failed.\n%s", D3DRMErrorToString(rval)); <br>        return FALSE; <br>    } <br>    return TRUE; <br>} <br> <br> <br>/****************************************************************************/ <br>/*                    Windows Message Handlers                              */ <br>/****************************************************************************/ <br>/* <br> * AppAbout <br> * About box message handler <br> */ <br>BOOL <br>FAR PASCAL AppAbout(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lParam) <br>{ <br>  switch (msg) <br>  { <br>    case WM_COMMAND: <br>      if (LOWORD(wparam) == IDOK) <br>        EndDialog(hwnd, TRUE); <br>      break; <br> <br>    case WM_INITDIALOG: <br>      return TRUE; <br>  } <br>  return FALSE; <br>} <br> <br>/* <br> * WindowProc <br> * Main window message handler <br> */ <br>LONG FAR PASCAL WindowProc(HWND win, UINT msg, WPARAM wparam, LPARAM lparam) <br>{ <br>    int i; <br>    HRESULT rval; <br>    RECT rc; <br> <br>if (!myglobs.bInitialized) { <br>return DefWindowProc(win, msg, wparam, lparam); <br>} <br> <br>    switch (msg)    { <br>        case WM_LBUTTONDOWN: <br>        case WM_LBUTTONUP: <br>        case WM_RBUTTONDOWN: <br>        case WM_RBUTTONUP: <br>        case WM_MOUSEMOVE: <br>            /* <br>             * Record the mouse state for ReadMouse <br>             */ <br>            myglobs.mouse_buttons = wparam; <br>            myglobs.mouse_x = LOWORD(lparam); <br>            myglobs.mouse_y = HIWORD(lparam); <br>            break; <br>        case WM_INITMENUPOPUP: <br>            /* <br>             * Check and enable the appropriate menu items <br>             */ <br>            CheckMenuItem((HMENU)wparam, MENU_STEP,(myglobs.bSingleStepMode) ? MF_CHECKED : MF_UNCHECKED); <br>            EnableMenuItem((HMENU)wparam, MENU_GO,(myglobs.bSingleStepMode) ? MF_ENABLED : MF_GRAYED); <br>            if (!myglobs.bConstRenderQuality) { <br>                CheckMenuItem((HMENU)wparam, MENU_LIGHTING, (myglobs.RenderQuality &amp; D3DRMLIGHT_MASK) == D3DRMLIGHT_ON ? MF_CHECKED : MF_GRAYED); <br>                CheckMenuItem((HMENU)wparam, MENU_FLAT, (myglobs.RenderQuality &amp; D3DRMSHADE_MASK) == D3DRMSHADE_FLAT ? MF_CHECKED : MF_UNCHECKED); <br>                CheckMenuItem((HMENU)wparam, MENU_GOURAUD, (myglobs.RenderQuality &amp; D3DRMSHADE_MASK) == D3DRMSHADE_GOURAUD ? MF_CHECKED : MF_UNCHECKED); <br>                CheckMenuItem((HMENU)wparam, MENU_PHONG, (myglobs.RenderQuality &amp; D3DRMSHADE_MASK) == D3DRMSHADE_PHONG ? MF_CHECKED : MF_UNCHECKED); <br>                EnableMenuItem((HMENU)wparam, MENU_PHONG, MF_GRAYED); <br>                CheckMenuItem((HMENU)wparam, MENU_POINT, (myglobs.RenderQuality &amp; D3DRMFILL_MASK) == D3DRMFILL_POINTS ? MF_CHECKED : MF_UNCHECKED); <br>                CheckMenuItem((HMENU)wparam, MENU_WIREFRAME, (myglobs.RenderQuality &amp; D3DRMFILL_MASK) == D3DRMFILL_WIREFRAME ? MF_CHECKED : MF_UNCHECKED); <br>                CheckMenuItem((HMENU)wparam, MENU_SOLID, (myglobs.RenderQuality &amp; D3DRMFILL_MASK) == D3DRMFILL_SOLID ? MF_CHECKED : MF_UNCHECKED); <br>            } else { <br>                EnableMenuItem((HMENU)wparam, MENU_LIGHTING, MF_GRAYED); <br>                EnableMenuItem((HMENU)wparam, MENU_FLAT, MF_GRAYED); <br>                EnableMenuItem((HMENU)wparam, MENU_GOURAUD, MF_GRAYED); <br>                EnableMenuItem((HMENU)wparam, MENU_PHONG, MF_GRAYED); <br>                EnableMenuItem((HMENU)wparam, MENU_POINT, MF_GRAYED); <br>                EnableMenuItem((HMENU)wparam, MENU_WIREFRAME, MF_GRAYED); <br>                EnableMenuItem((HMENU)wparam, MENU_SOLID, MF_GRAYED); <br>            } <br>            if (!myglobs.bNoTextures) { <br>                CheckMenuItem((HMENU)wparam, MENU_POINT_FILTER, (myglobs.TextureQuality == D3DRMTEXTURE_NEAREST) ? MF_CHECKED : MF_UNCHECKED); <br>                CheckMenuItem((HMENU)wparam, MENU_LINEAR_FILTER, (myglobs.TextureQuality == D3DRMTEXTURE_LINEAR) ? MF_CHECKED : MF_UNCHECKED); <br>            } else { <br>                EnableMenuItem((HMENU)wparam, MENU_POINT_FILTER, MF_GRAYED); <br>                EnableMenuItem((HMENU)wparam, MENU_LINEAR_FILTER, MF_GRAYED); <br>            } <br>            CheckMenuItem((HMENU)wparam, MENU_DITHERING, (myglobs.bDithering) ? MF_CHECKED : MF_UNCHECKED); <br>            CheckMenuItem((HMENU)wparam, MENU_ANTIALIAS, (myglobs.bAntialiasing) ? MF_CHECKED : MF_UNCHECKED); <br>            EnableMenuItem((HMENU)wparam, MENU_ANTIALIAS, MF_GRAYED); <br>            for (i = 0; i &lt; myglobs.NumDrivers; i++) { <br>                CheckMenuItem((HMENU)wparam, MENU_FIRST_DRIVER + i, <br>                       (i == myglobs.CurrDriver) ? MF_CHECKED : MF_UNCHECKED); <br>            } <br>            break; <br>        case WM_COMMAND: <br>            switch(LOWORD(wparam)) { <br>                case MENU_ABOUT: <br>                    DialogBox((HINSTANCE)GetWindowLong(win, GWL_HINSTANCE), <br>                              "AppAbout", win, (DLGPROC)AppAbout); <br>                    break; <br>                case MENU_EXIT: <br>                    CleanUpAndPostQuit(); <br>                    break; <br>                case MENU_STEP: <br>                    /* <br>                     * Begin single step more or draw a frame if in single <br>                     * step mode <br>                     */ <br>                    if (!myglobs.bSingleStepMode) { <br>                        myglobs.bSingleStepMode = TRUE; <br>                        myglobs.bDrawAFrame = TRUE; <br>                    } else if (!myglobs.bDrawAFrame) { <br>                        myglobs.bDrawAFrame = TRUE; <br>                    } <br>                    break; <br>                case MENU_GO: <br>                    /* <br>                     * Exit single step mode <br>                     */ <br>                    myglobs.bSingleStepMode = FALSE; <br>                    break; <br>                /* <br>                 * Lighting toggle <br>                 */ <br>                case MENU_LIGHTING: <br>                    myglobs.RenderQuality ^= D3DRMLIGHT_ON; <br>                    SetRenderState(); <br>                    break; <br>                /* <br>                 * Fill mode selection <br>                 */ <br>                case MENU_POINT: <br>                    myglobs.RenderQuality = (myglobs.RenderQuality &amp; ~D3DRMFILL_MASK) | D3DRMFILL_POINTS; <br>                    SetRenderState(); <br>                    break; <br>                case MENU_WIREFRAME: <br>                    myglobs.RenderQuality = (myglobs.RenderQuality &amp; ~D3DRMFILL_MASK) | D3DRMFILL_WIREFRAME; <br>                    SetRenderState(); <br>                    break; <br>                case MENU_SOLID: <br>                    myglobs.RenderQuality = (myglobs.RenderQuality &amp; ~D3DRMFILL_MASK) | D3DRMFILL_SOLID; <br>                    SetRenderState(); <br>                    break; <br>                /* <br>                 * Shade mode selection <br>                 */ <br>                case MENU_FLAT: <br>                    myglobs.RenderQuality = (myglobs.RenderQuality &amp; ~D3DRMSHADE_MASK) | D3DRMSHADE_FLAT; <br>                    SetRenderState(); <br>                    break; <br>                case MENU_GOURAUD: <br>                    myglobs.RenderQuality = (myglobs.RenderQuality &amp; ~D3DRMSHADE_MASK) | D3DRMSHADE_GOURAUD; <br>                    SetRenderState(); <br>                    break; <br>                case MENU_PHONG: <br>                    myglobs.RenderQuality = (myglobs.RenderQuality &amp; ~D3DRMSHADE_MASK) | D3DRMSHADE_PHONG; <br>                    SetRenderState(); <br>                    break; <br> <br>                case MENU_DITHERING: <br>                    myglobs.bDithering = !myglobs.bDithering; <br>                    SetRenderState(); <br>                    break; <br>                case MENU_ANTIALIAS: <br>                    myglobs.bAntialiasing = !myglobs.bAntialiasing; <br>                    break; <br>                /* <br>                 * Texture filter selection <br>                 */ <br>                case MENU_POINT_FILTER: <br>                    if (myglobs.TextureQuality == D3DRMTEXTURE_NEAREST) <br>                        break; <br>                    myglobs.TextureQuality = D3DRMTEXTURE_NEAREST; <br>                    SetRenderState(); <br>                    break; <br>                case MENU_LINEAR_FILTER: <br>                    if (myglobs.TextureQuality == D3DRMTEXTURE_LINEAR) <br>                        break; <br>                    myglobs.TextureQuality = D3DRMTEXTURE_LINEAR; <br>                    SetRenderState(); <br>                    break; <br>                } <br>                /* <br>                 * Changing the D3D Driver <br>                 */ <br>                if (LOWORD(wparam) &gt;= MENU_FIRST_DRIVER &amp;&amp; <br>                    LOWORD(wparam) &lt; MENU_FIRST_DRIVER + MAX_DRIVERS &amp;&amp; <br>                    myglobs.CurrDriver != LOWORD(wparam) - MENU_FIRST_DRIVER) <br>{ <br>                    /* <br>                     * Release the current viewport and device and create <br>                     * the new one <br>                     */ <br>    int LastDriver = myglobs.CurrDriver; <br>    myglobs.bInitialized = FALSE; <br>                    RELEASE(myglobs.view); <br>                    RELEASE(myglobs.dev); <br>                    myglobs.CurrDriver = LOWORD(wparam)-MENU_FIRST_DRIVER; <br>                    GetClientRect(win, &amp;rc); <br>                    if (rval = CreateDevAndView(lpDDClipper, myglobs.CurrDriver, <br>rc.right, rc.bottom)) <br>    { <br>myglobs.CurrDriver = LastDriver; <br>if (rval = CreateDevAndView(lpDDClipper, myglobs.CurrDriver, <br>    rc.right, rc.bottom)) <br>{ <br>    Msg("Failed to create the D3DRM device.\n%s", D3DRMErrorToString(rval)); <br>    CleanUpAndPostQuit(); <br>} <br>else <br>{ <br>    Msg("There was not enough video memory available to use the 3D accelerated hardware device.\nRestoring old software device."); <br>    myglobs.bInitialized = TRUE; <br>} <br>                    } <br>    else <br>    { <br>myglobs.bInitialized = TRUE; <br>    } <br>                } <br>                /* <br>                 * Draw a frame in single step mode after ever command <br>                 */ <br>                myglobs.bDrawAFrame = TRUE; <br>            break; <br>    case WM_DESTROY: <br>        CleanUpAndPostQuit(); <br>        break; <br>    case WM_SIZE: <br>        /* <br>         * Handle resizing of the window <br>         */ <br>        { <br>        int width = LOWORD(lparam); <br>        int height = HIWORD(lparam); <br>        if (width &amp;&amp; height &amp;&amp; myglobs.view &amp;&amp; myglobs.dev) { <br>            int view_width = myglobs.view-&gt;GetWidth(); <br>            int view_height = myglobs.view-&gt;GetHeight(); <br>            int dev_width = myglobs.dev-&gt;GetWidth(); </code></pre>
<p>
</p>
<pre><code>int dev_height = myglobs.dev-&gt;GetHeight(); <br>            /* <br>             * If the window hasn't changed size and we aren't returning from <br>             * a minimize, there is nothing to do <br>             */ <br>            if (view_width == width &amp;&amp; view_height == height &amp;&amp; <br>                !myglobs.bMinimized) <br>                break; <br>            if (width &lt;= dev_width &amp;&amp; height &lt;= dev_height) { <br>                /* <br>                 * If the window has shrunk, we can use the same device with a <br>                 * new viewport <br>                 */ <br>myglobs.bInitialized = FALSE; <br>                RELEASE(myglobs.view); <br>                rval = lpD3DRM-&gt;CreateViewport(myglobs.dev, myglobs.camera, <br>                                               0, 0, width, height, <br>                                               &amp;myglobs.view); <br>                if (rval != D3DRM_OK) { <br>                    Msg("Failed to resize the viewport.\n%s", <br>                        D3DRMErrorToString(rval)); <br>                    CleanUpAndPostQuit(); <br>                    break; <br>                } <br>                rval = myglobs.view-&gt;SetBack(D3DVAL(5000.0)); <br>                if (rval != D3DRM_OK) { <br>                    Msg("Failed to set background depth after viewport resize.\n%s", <br>                        D3DRMErrorToString(rval)); <br>                    CleanUpAndPostQuit(); <br>                    break; <br>                } <br>myglobs.bInitialized = TRUE; <br>            } else { <br>                /* <br>                 * If the window got larger than the current device, create a <br>                 * new device. <br>                 */ <br>myglobs.bInitialized = FALSE; <br>                RELEASE(myglobs.view); <br>                RELEASE(myglobs.dev); <br>                if (rval = CreateDevAndView(lpDDClipper, myglobs.CurrDriver, <br>    width, height)) <br>{ <br>    myglobs.CurrDriver = 0; <br>    if (rval = CreateDevAndView(lpDDClipper, myglobs.CurrDriver, <br>width, height)) <br>    { <br>Msg("Failed to create the D3DRM device.\n%s", D3DRMErrorToString(rval)); <br>CleanUpAndPostQuit(); <br>    } <br>    else <br>    { <br>Msg("There was not enough video memory available to use the 3D accelerated hardware device.\nUsing software rendering instead."); <br>myglobs.bInitialized = TRUE; <br>    } <br>                } <br>else <br>{ <br>    myglobs.bInitialized = TRUE; <br>} <br>myglobs.bInitialized = TRUE; <br>            } <br>            /* <br>             * We must not longer be minimized <br>             */ <br>            myglobs.bMinimized = FALSE; <br>        } else { <br>            /* <br>             * This is a minimize message <br>             */ <br>            myglobs.bMinimized = TRUE; <br>        } <br>        } <br>myglobs.bDrawAFrame = TRUE; <br>        break; <br>    case WM_ACTIVATE: <br>        { <br>        /* <br>         * Create a Windows specific D3DRM window device to handle this <br>         * message <br>         */ <br>        LPDIRECT3DRMWINDEVICE windev; <br>        if (!myglobs.dev) <br>            break; <br>        if (SUCCEEDED(myglobs.dev-&gt;QueryInterface(IID_IDirect3DRMWinDevice, <br>            (void **) &amp;windev)))  { <br>                if (FAILED(windev-&gt;HandleActivate(wparam))) <br>                    Msg("Failed to handle WM_ACTIVATE.\n"); <br>                windev-&gt;Release(); <br>        } else { <br>            Msg("Failed to create Windows device to handle WM_ACTIVATE.\n"); <br>        } <br>        } <br>        break; <br>    case WM_PAINT: <br>        if (!myglobs.bInitialized || !myglobs.dev) <br>            return DefWindowProc(win, msg, wparam, lparam); <br>        /* <br>         * Create a Windows specific D3DRM window device to handle this <br>         * message <br>         */ <br>        RECT r; <br>        PAINTSTRUCT ps; <br>        LPDIRECT3DRMWINDEVICE windev; <br> <br>        if (GetUpdateRect(win, &amp;r, FALSE)) { <br>            BeginPaint(win, &amp;ps); <br>            if (SUCCEEDED(myglobs.dev-&gt;QueryInterface(IID_IDirect3DRMWinDevice, <br>                (void **) &amp;windev))) { <br>                if (FAILED(windev-&gt;HandlePaint(ps.hdc))) <br>                    Msg("Failed to handle WM_PAINT.\n"); <br>                windev-&gt;Release(); <br>            } else { <br>                Msg("Failed to create Windows device to handle WM_PAINT.\n"); <br>            } <br>            EndPaint(win, &amp;ps); <br>        } <br>        break; <br>    case WM_DISPLAYCHANGE: <br>{ <br>    /* <br>     * If this display change message was generated because another application <br>     * has gone exclusive, ignore it. <br>     */ <br>    LPDIRECTDRAW lpDD; <br>    LPDIRECTDRAWSURFACE lpDDS; <br>    DDSURFACEDESC ddsd; <br>    HRESULT err; <br> <br>    if (DirectDrawCreate(NULL, &amp;lpDD, NULL)) <br>break; <br>    err = lpDD-&gt;SetCooperativeLevel(win, DDSCL_NORMAL); <br>    if (err) { <br>lpDD-&gt;Release(); <br>break; <br>    } <br>    memset(&amp;ddsd, 0, sizeof(ddsd)); <br>    ddsd.dwSize = sizeof(ddsd); <br>    ddsd.dwFlags = DDSD_CAPS; <br>    ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE; <br>    err = lpDD-&gt;CreateSurface(&amp;ddsd, &amp;lpDDS, NULL); <br>    if (err == DDERR_NOEXCLUSIVEMODE) { <br>// This exclusive mode generated WM_DISPLAYCHANGE, ignoring <br>lpDD-&gt;Release(); <br>break; <br>    } <br>    if (!err) <br>lpDDS-&gt;Release(); <br>    lpDD-&gt;Release();     <br>} <br>GetClientRect(win, &amp;rc); <br>myglobs.bInitialized = FALSE; <br>        if (rval = CreateDevAndView(lpDDClipper, myglobs.CurrDriver, <br>    rc.right, rc.bottom)) { <br>    myglobs.CurrDriver = 0; <br>    if (rval = CreateDevAndView(lpDDClipper, myglobs.CurrDriver, <br>rc.right, rc.bottom)) <br>    { <br>Msg("Failed to create the D3DRM device.\n%s", D3DRMErrorToString(rval)); <br>CleanUpAndPostQuit(); <br>    } <br>    else <br>    { <br>// Don't bother the user with an error message here <br>//Msg("There was not enough video memory available to use the 3D accelerated hardware device.\nUsing software rendering instead."); <br>myglobs.bInitialized = TRUE; <br>    } <br>        } <br>else <br>{ <br>    myglobs.bInitialized = TRUE; <br>} <br>break; <br>    default: <br>        return DefWindowProc(win, msg, wparam, lparam); <br>    } <br>    return 0L; <br>} <br> <br>/* <br> * SetRenderState <br> * Set the render quality, dither toggle and shade info if any of them has <br> * changed <br> */ <br>HRESULT <br>SetRenderState(void) <br>{ <br>    HRESULT rval; <br>    /* <br>     * Set the render quality (light toggle, fill mode, shade mode) <br>     */ <br>    if (myglobs.dev-&gt;GetQuality() != myglobs.RenderQuality) { <br>        rval = myglobs.dev-&gt;SetQuality(myglobs.RenderQuality); <br>        if (rval != D3DRM_OK) <br>    return rval; <br>    } <br>    /* <br>     * Set dithering toggle <br>     */ <br>    if (myglobs.dev-&gt;GetDither() != myglobs.bDithering) { <br>        rval = myglobs.dev-&gt;SetDither(myglobs.bDithering); <br>        if (rval != D3DRM_OK)  <br>    return rval; <br>    } <br>    /* <br>     * Set the texture quality (point or linear filtering) <br>     */ <br>    if (myglobs.dev-&gt;GetTextureQuality() != myglobs.TextureQuality) { <br>        rval = myglobs.dev-&gt;SetTextureQuality(myglobs.TextureQuality); <br>        if (rval != D3DRM_OK)  <br>    return rval; <br>    } <br>    /* <br>     * Set shade info based on current bits per pixel <br>     */ <br>    switch (myglobs.BPP) { <br>    case 1: <br>        if (rval = myglobs.dev-&gt;SetShades(4)) <br>            return rval; <br>        if (rval = lpD3DRM-&gt;SetDefaultTextureShades(4)) <br>            return rval; <br>        break; <br>    case 16: <br>        if (rval = myglobs.dev-&gt;SetShades(32)) <br>            return rval; <br>        if (rval = lpD3DRM-&gt;SetDefaultTextureColors(64)) <br>            return rval; <br>        if (rval = lpD3DRM-&gt;SetDefaultTextureShades(32)) <br>            return rval; <br>        break; <br>    case 24: <br>    case 32: <br>        if (rval = myglobs.dev-&gt;SetShades(256)) <br>            return rval; <br>        if (rval = lpD3DRM-&gt;SetDefaultTextureColors(64)) <br>            return rval; <br>        if (rval = lpD3DRM-&gt;SetDefaultTextureShades(256)) <br>            return rval; <br>        break; <br>    } <br>    return D3DRM_OK; <br>} <br> <br>/****************************************************************************/ <br>/*                          Additional Functions                            */ <br>/****************************************************************************/ <br>/* <br> * ReadMouse <br> * Returns the mouse status for interaction with sample code <br> */ <br>void <br>ReadMouse(int* b, int* x, int* y) <br>{ <br>    *b = myglobs.mouse_buttons; <br>    *x = myglobs.mouse_x; <br>    *y = myglobs.mouse_y; <br>} <br> <br>/* <br> * InitGlobals <br> * Initialize the global variables <br> */ <br>void <br>InitGlobals(void) <br>{ <br>    lpD3DRM = NULL; <br>    memset(&amp;myglobs, 0, sizeof(myglobs)); <br>    myglobs.RenderQuality = D3DRMLIGHT_ON | D3DRMFILL_SOLID | <br>                            D3DRMSHADE_GOURAUD; <br>    myglobs.TextureQuality = D3DRMTEXTURE_NEAREST; <br>} <br> <br>/* <br> * CleanUpAndPostQuit <br> * Release all D3DRM objects, post a quit message and set the bQuit flag <br> */ <br>void <br>CleanUpAndPostQuit(void) <br>{ <br>    myglobs.bInitialized = FALSE; <br>    RELEASE(myglobs.scene); <br>    RELEASE(myglobs.camera); <br>    RELEASE(myglobs.view); <br>    RELEASE(myglobs.dev); <br>    RELEASE(lpD3DRM); <br>    RELEASE(lpDDClipper); <br>    myglobs.bQuit = TRUE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
