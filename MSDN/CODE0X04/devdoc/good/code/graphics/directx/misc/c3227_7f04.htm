<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MISC.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3244"></a>MISC.C</h2>
<pre><code>/* <br> *  Copyright (C) 1995, 1996 Microsoft Corporation. All Rights Reserved. <br> * <br> *  File: misc.c <br> * <br> *  Miscellaneous functions not involving DD and D3D.  Part of D3DApp. <br> * <br> *  D3DApp is a collection of helper functions for Direct3D applications. <br> *  D3DApp consists of the following files: <br> *d3dapp.h    Main D3DApp header to be included by application <br> *      d3dappi.h   Internal header <br> *      d3dapp.c    D3DApp functions seen by application. <br> *      ddcalls.c   All calls to DirectDraw objects except textures <br> *      d3dcalls.c  All calls to Direct3D objects except textures <br> *      texture.c   Texture loading and managing texture list <br> *      misc.c    Miscellaneous calls <br> */ <br> <br>#include "d3dappi.h" <br>#include &lt;stdarg.h&gt; <br> <br>/***************************************************************************/ <br>/*                          Setting Defaults                               */ <br>/***************************************************************************/ <br>/* <br> * D3DAppISetDefaults <br> * Set all the global variables to their default values.  Do not reset the <br> * image files. <br> */ <br>void <br>D3DAppISetDefaults(void) <br>{ <br>    int n; <br>    char backup[D3DAPP_MAXTEXTURES][50]; <br> <br>    n = d3dappi.NumTextures; <br>    memcpy(&amp;backup[0][0], &amp;d3dappi.ImageFile[0][0], 50 * D3DAPP_MAXTEXTURES); <br>    ZEROMEM(d3dappi); <br>    memcpy(&amp;d3dappi.ImageFile[0][0], &amp;backup[0][0], 50 * D3DAPP_MAXTEXTURES); <br>    d3dappi.NumTextures = n; <br>    d3dappi.bAppActive = TRUE; <br>    ZEROMEM(d3dapprs); <br>    d3dapprs.bZBufferOn = TRUE; <br>    d3dapprs.bPerspCorrect = FALSE; <br>    d3dapprs.ShadeMode = D3DSHADE_GOURAUD; <br>    d3dapprs.TextureFilter = D3DFILTER_NEAREST; <br>    d3dapprs.TextureBlend = D3DTBLEND_MODULATE; <br>    d3dapprs.FillMode = D3DFILL_SOLID; <br>    d3dapprs.bDithering = FALSE; <br>    d3dapprs.bSpecular = TRUE; <br>    d3dapprs.bAntialiasing = FALSE; <br>    d3dapprs.bFogEnabled = FALSE; <br>    d3dapprs.FogColor = RGB_MAKE(0, 0, 0); <br>    d3dapprs.FogMode = D3DFOG_LINEAR; <br>    d3dapprs.FogStart = D3DVAL(6.0); <br>    d3dapprs.FogEnd = D3DVAL(11.0); <br> <br>    lpClipper = NULL; <br>    lpPalette = NULL; <br>    bPrimaryPalettized = FALSE; <br>    bPaletteActivate = FALSE; <br>    bIgnoreWM_SIZE = FALSE; <br>    ZEROMEM(ppe); <br>    ZEROMEM(Originalppe); <br>    LastError = DD_OK; <br>    ZEROMEM(LastErrorString); <br>    D3DDeviceDestroyCallback = NULL; <br>    D3DDeviceDestroyCallbackContext = NULL; <br>    D3DDeviceCreateCallback = NULL; <br>    D3DDeviceCreateCallbackContext = NULL; <br>} <br> <br>/***************************************************************************/ <br>/*                Calling Device Create And Destroy Callbacks              */ <br>/***************************************************************************/ <br>BOOL <br>D3DAppICallDeviceDestroyCallback(void) <br>{ <br>    if (D3DDeviceDestroyCallback) { <br>if (CallbackRefCount) { <br>    --CallbackRefCount; <br>    return (D3DDeviceDestroyCallback)(D3DDeviceDestroyCallbackContext); <br>} <br>    } <br>    return TRUE; <br>} <br> <br>BOOL <br>D3DAppICallDeviceCreateCallback(int w, int h) <br>{ <br>    if (D3DDeviceCreateCallback) { <br>++CallbackRefCount; <br>return (D3DDeviceCreateCallback)(w, h, &amp;d3dappi.lpD3DViewport, <br> D3DDeviceCreateCallbackContext); <br>    } <br>    return TRUE; <br>} <br> <br>/***************************************************************************/ <br>/*            Choosing and verifying the driver and display mode           */ <br>/***************************************************************************/ <br>/* <br> * D3DAppIPickDriver <br> * Choose a driver from the list of available drivers which can render to one <br> * of the given depths.  Hardware is prefered.  Mono-lighting drivers are <br> * prefered over RGB. <br> */ <br>BOOL <br>D3DAppIPickDriver(int* driver, DWORD depths) <br>{ <br>    int i, j; <br>    j = 0; <br>    for (i = 0; i &lt; d3dappi.NumDrivers; i++) <br>if (d3dappi.Driver[i].Desc.dwDeviceRenderBitDepth &amp; depths) <br>    break; <br>    if (i &gt;= d3dappi.NumDrivers) { <br>*driver = D3DAPP_BOGUS; <br>return TRUE; <br>    } <br>    j = i; <br>    for (i = 0; i &lt; d3dappi.NumDrivers; i++) { <br>if (d3dappi.Driver[i].Desc.dwDeviceRenderBitDepth &amp; depths) { <br>    if (d3dappi.Driver[i].bIsHardware &amp;&amp; <br>      !d3dappi.Driver[j].bIsHardware) <br>          j = i; <br>    else if (d3dappi.Driver[i].bIsHardware == <br>     d3dappi.Driver[j].bIsHardware) { <br>if (d3dappi.Driver[i].Desc.dcmColorModel &amp; D3DCOLOR_MONO &amp;&amp; <br>    !(d3dappi.Driver[j].Desc.dcmColorModel &amp; D3DCOLOR_MONO)) <br>j = i; <br>    } <br>} <br>    } <br>    if (j &gt;= d3dappi.NumDrivers) <br>*driver = D3DAPP_BOGUS; <br>    else <br>*driver = j; <br>    return TRUE; <br>} <br> <br>/* <br> * D3DAppIFilterDisplayModes <br> * Set the bThisDriverCanDo flag for each display mode if the given driver <br> * can render in that depth.  Also checks to make sure there is enough <br> * total video memory for front/back/z-buffer in video memory if it's a <br> * hardware device. <br> */ <br>BOOL <br>D3DAppIFilterDisplayModes(int driver) <br>{ <br>    int i; <br>    DWORD depths = d3dappi.Driver[driver].Desc.dwDeviceRenderBitDepth; <br> <br>    for (i = 0; i &lt; d3dappi.NumModes; i++) { <br>d3dappi.Mode[i].bThisDriverCanDo = FALSE; <br>if (!(D3DAppIBPPToDDBD(d3dappi.Mode[i].bpp) &amp; depths)) <br>    continue; <br>d3dappi.Mode[i].bThisDriverCanDo = TRUE; <br>     <br>    } <br>    d3dappi.ThisMode.bThisDriverCanDo = <br>     d3dappi.Mode[d3dappi.CurrMode].bThisDriverCanDo; <br>    return TRUE; <br>} <br> <br>/* <br> * D3DAppIPickDisplayMode <br> * Pick a display mode of one of the given depths.  640x480x16 is prefered. <br> */ <br>BOOL <br>D3DAppIPickDisplayMode(int *mode, DWORD depths) <br>{ <br>    int i, j; <br>    for (i = 0; i &lt; d3dappi.NumModes; i++) <br>if (D3DAppIBPPToDDBD(d3dappi.Mode[i].bpp) &amp; depths) <br>    break; <br>    j = i; <br>    for (; i &lt; d3dappi.NumModes; i++) { <br>if (!(D3DAppIBPPToDDBD(d3dappi.Mode[i].bpp) &amp; depths)) <br>    continue; <br>if (d3dappi.Mode[i].w == 640 &amp;&amp; d3dappi.Mode[i].h == 480 &amp;&amp; <br>    d3dappi.Mode[i].bpp == 16) { <br>    j = i; <br>    break; <br>} <br>    } <br>    if (j &gt;= d3dappi.NumModes) <br>*mode = D3DAPP_BOGUS; <br>    else <br>*mode = j; <br>    return TRUE; <br>} <br> <br>/* <br> * D3DAppIVerifyDriverAndMode <br> * Verifies the selected driver and mode combination.  If the driver is <br> * specified, the mode will be changed to accomodate the driver if it's not <br> * compatible.  If the driver is not specified, one will be selected which is <br> * compatible with the specified mode.  If neither are specified, a suitable <br> * pair will be returned. <br> */ <br>BOOL <br>D3DAppIVerifyDriverAndMode(int* lpdriver, int* lpmode) <br>{ <br>    DWORD depths; <br>    int driver, mode, i; <br>    driver = *lpdriver; mode = *lpmode; <br> <br>    if (mode == D3DAPP_USEWINDOW &amp;&amp; !d3dappi.bIsPrimary) { <br>D3DAppISetErrorString("Cannot render to a window when the DirectDraw device is not the primary.\n"); <br>goto exit_with_error; <br>    } <br> <br>    /* <br>     * If I've been ask to choose a driver, choose one which is compatible <br>     * with the specified mode. <br>     */ <br>    if (driver == D3DAPP_YOUDECIDE) { <br>if (mode == D3DAPP_USEWINDOW) { <br>    /* <br>     * I must find a driver for this display depth <br>     */ <br>    depths = D3DAppIBPPToDDBD(d3dappi.WindowsDisplay.bpp); <br>    ATTEMPT(D3DAppIPickDriver(&amp;driver, depths)); <br>    if (driver == D3DAPP_BOGUS) { <br>D3DAppISetErrorString("Cannot find a D3D device driver which is compatible with the current display depth.\n"); <br>goto exit_with_error; <br>    } <br>    /* <br>     * I don't need to go through the mode selection since I've <br>     * verified it here <br>     */ <br>    goto ret_ok; <br>} else if (mode == D3DAPP_YOUDECIDE) { <br>    /* <br>     * I'm free to choose any driver which can use even one <br>     * supported depth <br>     */ <br>    if (d3dappi.bIsPrimary) <br>depths = D3DAppIBPPToDDBD(d3dappi.WindowsDisplay.bpp); <br>    else <br>depths = 0; <br>    for (i = 0; i &lt; d3dappi.NumModes; i++) <br>depths |= D3DAppIBPPToDDBD(d3dappi.Mode[i].bpp); <br>    ATTEMPT(D3DAppIPickDriver(&amp;driver, depths)); <br>    if (driver == D3DAPP_BOGUS) { <br>D3DAppISetErrorString("Cannot find a D3D device driver which is compatible with the current display depth or any supported fullscreen mode.\n"); <br>goto exit_with_error; <br>    } <br>    /* <br>     * The mode will be chosen in the next section <br>     */ <br>} else { <br>    /* <br>     * Must pick a driver which uses the given mode depth <br>     */ <br>    ATTEMPT(D3DAppIPickDriver(&amp;driver, <br>  D3DAppIBPPToDDBD(d3dappi.Mode[mode].bpp))); <br>    if (driver == D3DAPP_BOGUS) { <br>D3DAppISetErrorString("Cannot find a D3D device driver which is compatible with the specified fullscreen mode.\n"); <br>goto exit_with_error; <br>    } <br>    /* <br>     * I don't need to go through the mode selection since I've <br>     * verified it here <br>     */ <br>    goto ret_ok; <br>} <br>    } <br> <br>    /*  <br>     * At this stage, I have a driver I want to match the mode to. <br>     */ <br>    if (mode == D3DAPP_YOUDECIDE) { <br>/* <br> * If it's my choice, I prefer windowed over fullscreen <br> */ <br>if (d3dappi.bIsPrimary) { <br>    if (D3DAppIBPPToDDBD(d3dappi.WindowsDisplay.bpp) &amp;  <br>    d3dappi.Driver[driver].Desc.dwDeviceRenderBitDepth) { <br>mode = D3DAPP_USEWINDOW; <br>goto ret_ok; <br>    } <br>} <br>/* <br> * Either this is not a primary DD device or the driver cannot use <br> * the Windows display depth <br> */ <br>ATTEMPT(D3DAppIPickDisplayMode(&amp;mode, <br>d3dappi.Driver[driver].Desc.dwDeviceRenderBitDepth)); <br>if (mode == D3DAPP_BOGUS) { <br>    D3DAppISetErrorString("The selected D3D device driver is not compatible with the current display depth or any supported fullscreen modes.\n"); <br>    goto exit_with_error; <br>} <br>goto ret_ok; <br>    } else if (mode == D3DAPP_USEWINDOW) { <br>/* <br> * Check to see if this driver can use the Windows display depth <br> */ <br>if (D3DAppIBPPToDDBD(d3dappi.WindowsDisplay.bpp) &amp; <br>d3dappi.Driver[driver].Desc.dwDeviceRenderBitDepth) { <br>    goto ret_ok; <br>} else { <br>    /* <br>     * Since it cannot, call this function again to choose any  <br>     * display mode which is compatible  <br>     */ <br>    mode = D3DAPP_YOUDECIDE; <br>    ATTEMPT(D3DAppIVerifyDriverAndMode(&amp;driver, &amp;mode)); <br>    if (driver == D3DAPP_BOGUS) <br>goto exit_with_error; <br>    goto ret_ok; <br>} <br>    } else { <br>/* <br> * Check to see if this driver can use the specified fullscreen mode <br> */ <br>if (D3DAppIBPPToDDBD(d3dappi.Mode[mode].bpp) &amp; <br>d3dappi.Driver[driver].Desc.dwDeviceRenderBitDepth) { <br>    goto ret_ok; <br>} else { <br>    /* <br>     * Since it cannot, call this function again to choose any <br>     * display mode which is compatible <br>     */ <br>    mode = D3DAPP_YOUDECIDE; <br>    ATTEMPT(D3DAppIVerifyDriverAndMode(&amp;driver, &amp;mode)); <br>    if (driver == D3DAPP_BOGUS) <br>goto exit_with_error; <br>    goto ret_ok; <br>} <br>    } <br> <br>ret_ok: <br>    *lpdriver = driver; *lpmode = mode; <br>    return TRUE; <br>exit_with_error: <br>    return FALSE; <br>} <br> <br>/***************************************************************************/ <br>/*                        Dirty Rectangle Functions                        */ <br>/***************************************************************************/ <br>/* <br> * D3DAppIValidateDirtyRects <br> * Set the dirty rectangles for the front and back buffers to the entire <br> * client size. <br> */ <br>void <br>D3DAppIValidateDirtyRects(void) <br>{ <br>    NumDirtyClientRects = 1; NumDirtyBackRects = 1; NumDirtyZRects = 1; <br>    SetRect((LPRECT)&amp;DirtyClient[0], 0, 0, d3dappi.szClient.cx, <br>    d3dappi.szClient.cy); <br>    SetRect((LPRECT)&amp;DirtyBack[0], 0, 0, d3dappi.szClient.cx, <br>    d3dappi.szClient.cy); <br>    SetRect((LPRECT)&amp;DirtyZ[0], 0, 0, d3dappi.szClient.cx, <br>    d3dappi.szClient.cy); <br>} <br> <br>/* <br> * D3DAppICopyRectList <br> * Copy a list of rectangles to another <br> */ <br>void <br>D3DAppICopyRectList(int* dstnum, LPD3DRECT dst, int srcnum, LPD3DRECT src) <br>{ <br>    int i; <br>    for (i = 0; i &lt; srcnum; i++) <br>dst[i] = src[i]; <br>    *dstnum = srcnum; <br>} <br> <br>/* <br> * MERGE macro <br> * Set first rectangle to be the smallest rectangle containing both rects <br> */ <br>#undef MERGE <br>#define MERGE(rc1, rc2)\ <br>    do {\ <br>if (rc2.x1 &lt; rc1.x1) rc1.x1 = rc2.x1;\ <br>if (rc2.y1 &lt; rc1.y1) rc1.y1 = rc2.y1;\ <br>if (rc2.x2 &gt; rc1.x2) rc1.x2 = rc2.x2;\ <br>if (rc2.y2 &gt; rc1.y2) rc1.y2 = rc2.y2;\ <br>    } while(0) <br> <br>/* <br> * D3DAppIMergeRectLists <br> * Merge two lists of rectangles to create another list of rectangles. The <br> * merged list of rectangles covers all the area of the original two with NO <br> * OVERLAPPING amongst it's rectangles. <br> */ <br>void <br>D3DAppIMergeRectLists(int* dstnum, LPD3DRECT dst, int src1num, LPD3DRECT src1, <br>     int src2num, LPD3DRECT src2) <br>{ <br>    LPD3DRECT rc; <br>    int* isvalid; <br>    int num, i, j, intersect; <br>    rc = (LPD3DRECT)malloc(sizeof(D3DRECT) * D3DAPP_MAXCLEARRECTS * 2); <br>    memset(rc, 0, sizeof(D3DRECT) * D3DAPP_MAXCLEARRECTS * 2); <br>    isvalid = (int*)malloc(sizeof(int) * D3DAPP_MAXCLEARRECTS * 2); <br>    memset(isvalid, 0, sizeof(int) * D3DAPP_MAXCLEARRECTS * 2); <br>    for (i = 0; i &lt; src1num; i++) { <br>memcpy(&amp;rc[i], &amp;src1[i], sizeof(D3DRECT)); <br>if ((rc[i].x1 == 0 &amp;&amp; rc[i].x2 == 0) || <br>    (rc[i].y1 == 0 &amp;&amp; rc[i].y2 == 0)) <br>    isvalid[i] = 0; <br>        else if (rc[i].x1 &lt;= rc[i].x2 &amp;&amp; rc[i].y1 &lt;= rc[i].y2) <br>    isvalid[i] = 1; <br>        else <br>            isvalid[i] = 0; <br>    } <br>    for (i = 0; i &lt; src2num; i++) { <br>memcpy(&amp;rc[i + src1num], &amp;src2[i], sizeof(D3DRECT)); <br>        if (rc[i + src1num].x1 &lt;= rc[i + src1num].x2 &amp;&amp; <br>            rc[i + src1num].y1 &lt;= rc[i + src1num].y2) <br>    isvalid[i + src1num] = 1; <br>        else <br>            isvalid[i + src1num] = 0; <br> <br>    } <br>    num = src1num + src2num; <br>    for (i = 0; i &lt; num - 1; i++) { <br>        if (!isvalid[i]) continue; <br>j = i + 1; <br>do { <br>    intersect = 0; <br>    for (; j &lt; num; j++) { <br>if (j != i &amp;&amp; isvalid[j]) { <br>    if (rc[i].x1 &lt; rc[j].x1) { <br>if (rc[i].x2 &lt; rc[j].x1) <br>    continue; <br>    } else { <br>if (rc[j].x2 &lt; rc[i].x1) <br>    continue; <br>    } <br>    if (rc[i].y1 &lt; rc[j].y1) { <br>if (rc[i].y2 &lt; rc[j].y1) <br>    continue; <br>    } else { <br>if (rc[j].y2 &lt; rc[i].y1) <br>    continue; <br>    } <br>    MERGE(rc[i], rc[j]); <br>    isvalid[j] = 0; <br>    j = 0; intersect = 1; <br>    break; <br>} <br>    } <br>} while(intersect); <br>    } <br> <br>    for (i = 0, j = 0; i &lt; num; i++) <br>if (isvalid[i]) ++j; <br>    if (j &gt; D3DAPP_MAXCLEARRECTS) { <br>for (i = 0; i &lt; num; i++) <br>    if (isvalid[i]) break; <br>if (i &lt; num) { <br>    *dstnum = 1; <br>    dst[0] = rc[i]; <br>    for (; i &lt; num; i++) { <br>if (isvalid[i]) { <br>    MERGE(dst[0], rc[i]); <br>} <br>    } <br>} else { <br>    *dstnum = 0; <br>} <br>    } else { <br>for (i = 0, j = 0; i &lt; num; i++) { <br>    if (isvalid[i]) { <br>memcpy(&amp;dst[j], &amp;rc[i], sizeof(D3DRECT)); <br>++j; <br>    } <br>} <br>*dstnum = j; <br>    } <br>    free(rc); <br>    free(isvalid); <br>} <br> <br>/***************************************************************************/ <br>/*                     Getting and Setting Window Attribs                  */ <br>/***************************************************************************/ <br>/* <br> * D3DAppISetClientSize <br> * Set the client size of the given window.  A WM_SIZE message is generated, <br> * but ignored. <br> */ <br>void <br>D3DAppISetClientSize(HWND hwnd, int w, int h, BOOL bReturnFromFullscreen) <br>{ <br>    RECT rc; <br> <br>    bIgnoreWM_SIZE = TRUE; <br>    if (bReturnFromFullscreen) { <br>SetRect(&amp;rc, 0, 0, w, h); <br>AdjustWindowRectEx(&amp;rc, GetWindowLong(hwnd, GWL_STYLE), <br>           GetMenu(hwnd) != NULL, <br>           GetWindowLong(hwnd, GWL_EXSTYLE)); <br>SetWindowPos(hwnd, NULL, 0, 0, rc.right-rc.left, <br>             rc.bottom-rc.top, <br>             SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE); <br>SetWindowPos(hwnd, HWND_NOTOPMOST, 0, 0, 0, 0, <br>             SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE); <br> <br>    } else { <br>/* <br> * This is the only way to set the client size correctly if the menu <br> * is stacked, so do it unless we are returning from a fullscreen <br> * mode. <br> */ <br>SendMessage(hwnd, WM_SIZE, SIZE_RESTORED, w + h &lt;&lt; 16); <br>GetWindowRect(hwnd, &amp;rc); <br>SetWindowPos(hwnd, NULL, 0, 0, rc.right-rc.left, <br>             rc.bottom-rc.top, <br>             SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE); <br>SetWindowPos(hwnd, HWND_NOTOPMOST, 0, 0, 0, 0, <br>             SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE); <br>    } <br>    bIgnoreWM_SIZE = FALSE; <br>    d3dappi.pClientOnPrimary.x = d3dappi.pClientOnPrimary.y = 0; <br>    ClientToScreen(hwnd, &amp;d3dappi.pClientOnPrimary); <br>    d3dappi.szClient.cx = w; d3dappi.szClient.cy = h; <br>} <br> <br>/* <br> * D3DAppIGetClientWin <br> * Gets the client window size and sets it in the D3DAppInfo structure <br> */ <br>void <br>D3DAppIGetClientWin(HWND hwnd) <br>{ <br>    RECT rc; <br>    if (!d3dappi.bFullscreen) { <br>d3dappi.pClientOnPrimary.x = d3dappi.pClientOnPrimary.y = 0; <br>ClientToScreen(hwnd, &amp;d3dappi.pClientOnPrimary); <br>GetClientRect(hwnd, &amp;rc); <br>d3dappi.szClient.cx = rc.right; <br>d3dappi.szClient.cy = rc.bottom; <br>    } else { <br>/* <br> * In the fullscreen case, we must be careful because if the window <br> * frame has been drawn, the client size has shrunk and this can <br> * cause problems, so it's best to report the entire screen. <br> */ <br>d3dappi.pClientOnPrimary.x = d3dappi.pClientOnPrimary.y = 0; <br>d3dappi.szClient.cx = d3dappi.ThisMode.w; <br>d3dappi.szClient.cy = d3dappi.ThisMode.h; <br>    } <br>} <br> <br> <br>/***************************************************************************/ <br>/*                              Error reporting                            */ <br>/***************************************************************************/ <br> <br>/* <br> * D3DAppISetErrorString <br> * Set the global variable which records the last error string. <br> */ <br>void <br>D3DAppISetErrorString( LPSTR fmt, ... ) <br>{ <br>    char buff[256]; <br>    va_list args; <br>     <br>    buff[0] = 0; <br>    va_start(args, fmt); <br>    wvsprintf(&amp;buff[0], fmt, args); <br>    va_end(args); <br>     <br>    lstrcat(buff, "\r\n"); <br>    lstrcpy(LastErrorString, buff); <br>} <br> <br>/* dpf <br> * Debug printf.  Very useful for fullscreen exclusive mode or when surfaces <br> * are in video memory. <br> */ <br>void __cdecl <br>dpf( LPSTR fmt, ... ) <br>{ <br>    char buff[256]; <br>    va_list args; <br>     <br>    lstrcpy(buff, "D3DApp: "); <br>    va_start(args, fmt); <br>    wvsprintf(&amp;buff[lstrlen(buff)], fmt, args); <br>    va_end(args); <br>     <br>    lstrcat(buff, "\r\n"); <br>    OutputDebugString(buff); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
