<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>RMERROR.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3247"></a>RMERROR.C</h2>
<pre><code>/* <br> *  Copyright (C) 1995, 1996 Microsoft Corporation. All Rights Reserved. <br> * <br> *  File: rmerror.cpp <br> * <br> *  Error reporting code for D3DRM examples. <br> * <br> */ <br> <br>#include "rmerror.h" <br>#include &lt;stdarg.h&gt; <br> <br>/* Msg <br> * Displays a message box containing the given formatted string. <br> */ <br>void __cdecl <br>Msg( LPSTR fmt, ... ) <br>{ <br>    char buff[256]; <br>    va_list args; <br>     <br>    va_start(args, fmt); <br>    wvsprintf(buff, fmt, args); <br>    va_end(args); <br>     <br>    lstrcat(buff, "\r\n"); <br>    MessageBox( NULL, buff, "D3DRM Example Message", MB_OK ); <br>} <br> <br>/* <br> * D3DRMErrorToString <br> * Returns a pointer to a string describing the given DD, D3D or D3DRM error code. <br> */ <br>char* <br>D3DRMErrorToString(HRESULT error) <br>{ <br>    switch(error) { <br>        case DD_OK: <br>    /* Also includes D3D_OK and D3DRM_OK */ <br>            return "No error.\0"; <br>        case DDERR_ALREADYINITIALIZED: <br>            return "This object is already initialized.\0"; <br>        case DDERR_BLTFASTCANTCLIP: <br>            return "Return if a clipper object is attached to the source surface passed into a BltFast call.\0"; <br>        case DDERR_CANNOTATTACHSURFACE: <br>            return "This surface can not be attached to the requested surface.\0"; <br>        case DDERR_CANNOTDETACHSURFACE: <br>            return "This surface can not be detached from the requested surface.\0"; <br>        case DDERR_CANTCREATEDC: <br>            return "Windows can not create any more DCs.\0"; <br>        case DDERR_CANTDUPLICATE: <br>            return "Can't duplicate primary &amp; 3D surfaces, or surfaces that are implicitly created.\0"; <br>        case DDERR_CLIPPERISUSINGHWND: <br>            return "An attempt was made to set a cliplist for a clipper object that is already monitoring an hwnd.\0"; <br>        case DDERR_COLORKEYNOTSET: <br>            return "No src color key specified for this operation.\0"; <br>        case DDERR_CURRENTLYNOTAVAIL: <br>            return "Support is currently not available.\0"; <br>        case DDERR_DIRECTDRAWALREADYCREATED: <br>            return "A DirectDraw object representing this driver has already been created for this process.\0"; <br>        case DDERR_EXCEPTION: <br>            return "An exception was encountered while performing the requested operation.\0"; <br>        case DDERR_EXCLUSIVEMODEALREADYSET: <br>            return "An attempt was made to set the cooperative level when it was already set to exclusive.\0"; <br>        case DDERR_GENERIC: <br>            return "Generic failure.\0"; <br>        case DDERR_HEIGHTALIGN: <br>            return "Height of rectangle provided is not a multiple of reqd alignment.\0"; <br>        case DDERR_HWNDALREADYSET: <br>            return "The CooperativeLevel HWND has already been set. It can not be reset while the process has surfaces or palettes created.\0"; <br>        case DDERR_HWNDSUBCLASSED: <br>            return "HWND used by DirectDraw CooperativeLevel has been subclassed, this prevents DirectDraw from restoring state.\0"; <br>        case DDERR_IMPLICITLYCREATED: <br>            return "This surface can not be restored because it is an implicitly created surface.\0"; <br>        case DDERR_INCOMPATIBLEPRIMARY: <br>            return "Unable to match primary surface creation request with existing primary surface.\0"; <br>        case DDERR_INVALIDCAPS: <br>            return "One or more of the caps bits passed to the callback are incorrect.\0"; <br>        case DDERR_INVALIDCLIPLIST: <br>            return "DirectDraw does not support the provided cliplist.\0"; <br>        case DDERR_INVALIDDIRECTDRAWGUID: <br>            return "The GUID passed to DirectDrawCreate is not a valid DirectDraw driver identifier.\0"; <br>        case DDERR_INVALIDMODE: <br>            return "DirectDraw does not support the requested mode.\0"; <br>        case DDERR_INVALIDOBJECT: <br>            return "DirectDraw received a pointer that was an invalid DIRECTDRAW object.\0"; <br>        case DDERR_INVALIDPARAMS: <br>            return "One or more of the parameters passed to the function are incorrect.\0"; <br>        case DDERR_INVALIDPIXELFORMAT: <br>            return "The pixel format was invalid as specified.\0"; <br>        case DDERR_INVALIDPOSITION: <br>            return "Returned when the position of the overlay on the destination is no longer legal for that destination.\0"; <br>        case DDERR_INVALIDRECT: <br>            return "Rectangle provided was invalid.\0"; <br>        case DDERR_LOCKEDSURFACES: <br>            return "Operation could not be carried out because one or more surfaces are locked.\0"; <br>        case DDERR_NO3D: <br>            return "There is no 3D present.\0"; <br>        case DDERR_NOALPHAHW: <br>            return "Operation could not be carried out because there is no alpha accleration hardware present or available.\0"; <br>        case DDERR_NOBLTHW: <br>            return "No blitter hardware present.\0"; <br>        case DDERR_NOCLIPLIST: <br>            return "No cliplist available.\0"; <br>        case DDERR_NOCLIPPERATTACHED: <br>            return "No clipper object attached to surface object.\0"; <br>        case DDERR_NOCOLORCONVHW: <br>            return "Operation could not be carried out because there is no color conversion hardware present or available.\0"; <br>        case DDERR_NOCOLORKEY: <br>            return "Surface doesn't currently have a color key\0"; <br>        case DDERR_NOCOLORKEYHW: <br>            return "Operation could not be carried out because there is no hardware support of the destination color key.\0"; <br>        case DDERR_NOCOOPERATIVELEVELSET: <br>            return "Create function called without DirectDraw object method SetCooperativeLevel being called.\0"; <br>        case DDERR_NODC: <br>            return "No DC was ever created for this surface.\0"; <br>        case DDERR_NODDROPSHW: <br>            return "No DirectDraw ROP hardware.\0"; <br>        case DDERR_NODIRECTDRAWHW: <br>            return "A hardware-only DirectDraw object creation was attempted but the driver did not support any hardware.\0"; <br>        case DDERR_NOEMULATION: <br>            return "Software emulation not available.\0"; <br>        case DDERR_NOEXCLUSIVEMODE: <br>            return "Operation requires the application to have exclusive mode but the application does not have exclusive mode.\0"; <br>        case DDERR_NOFLIPHW: <br>            return "Flipping visible surfaces is not supported.\0"; <br>        case DDERR_NOGDI: <br>            return "There is no GDI present.\0"; <br>        case DDERR_NOHWND: <br>            return "Clipper notification requires an HWND or no HWND has previously been set as the CooperativeLevel HWND.\0"; <br>        case DDERR_NOMIRRORHW: <br>            return "Operation could not be carried out because there is no hardware present or available.\0"; <br>        case DDERR_NOOVERLAYDEST: <br>            return "Returned when GetOverlayPosition is called on an overlay that UpdateOverlay has never been called on to establish a destination.\0"; <br>        case DDERR_NOOVERLAYHW: <br>            return "Operation could not be carried out because there is no overlay hardware present or available.\0"; <br>        case DDERR_NOPALETTEATTACHED: <br>            return "No palette object attached to this surface.\0"; <br>        case DDERR_NOPALETTEHW: <br>            return "No hardware support for 16 or 256 color palettes.\0"; <br>        case DDERR_NORASTEROPHW: <br>            return "Operation could not be carried out because there is no appropriate raster op hardware present or available.\0"; <br>        case DDERR_NOROTATIONHW: <br>            return "Operation could not be carried out because there is no rotation hardware present or available.\0"; <br>        case DDERR_NOSTRETCHHW: <br>            return "Operation could not be carried out because there is no hardware support for stretching.\0"; <br>        case DDERR_NOT4BITCOLOR: <br>            return "DirectDrawSurface is not in 4 bit color palette and the requested operation requires 4 bit color palette.\0"; <br>        case DDERR_NOT4BITCOLORINDEX: <br>            return "DirectDrawSurface is not in 4 bit color index palette and the requested operation requires 4 bit color index palette.\0"; <br>        case DDERR_NOT8BITCOLOR: <br>            return "DirectDrawSurface is not in 8 bit color mode and the requested operation requires 8 bit color.\0"; <br>        case DDERR_NOTAOVERLAYSURFACE: <br>            return "Returned when an overlay member is called for a non-overlay surface.\0"; <br>        case DDERR_NOTEXTUREHW: <br>            return "Operation could not be carried out because there is no texture mapping hardware present or available.\0"; <br>        case DDERR_NOTFLIPPABLE: <br>            return "An attempt has been made to flip a surface that is not flippable.\0"; <br>        case DDERR_NOTFOUND: <br>            return "Requested item was not found.\0"; <br>        case DDERR_NOTLOCKED: <br>            return "Surface was not locked.  An attempt to unlock a surface that was not locked at all, or by this process, has been attempted.\0"; <br>        case DDERR_NOTPALETTIZED: <br>            return "The surface being used is not a palette-based surface.\0"; <br>        case DDERR_NOVSYNCHW: <br>            return "Operation could not be carried out because there is no hardware support for vertical blank synchronized operations.\0"; <br>        case DDERR_NOZBUFFERHW: <br>            return "Operation could not be carried out because there is no hardware support for zbuffer blitting.\0"; <br>        case DDERR_NOZOVERLAYHW: <br>            return "Overlay surfaces could not be z layered based on their BltOrder because the hardware does not support z layering of overlays.\0"; <br>        case DDERR_OUTOFCAPS: <br>            return "The hardware needed for the requested operation has already been allocated.\0"; <br>        case DDERR_OUTOFMEMORY: <br>            return "DirectDraw does not have enough memory to perform the operation.\0"; <br>        case DDERR_OUTOFVIDEOMEMORY: <br>            return "DirectDraw does not have enough memory to perform the operation.\0"; <br>        case DDERR_OVERLAYCANTCLIP: <br>            return "The hardware does not support clipped overlays.\0"; <br>        case DDERR_OVERLAYCOLORKEYONLYONEACTIVE: <br>            return "Can only have ony color key active at one time for overlays.\0"; <br>        case DDERR_OVERLAYNOTVISIBLE: <br>            return "Returned when GetOverlayPosition is called on a hidden overlay.\0"; <br>        case DDERR_PALETTEBUSY: <br>            return "Access to this palette is being refused because the palette is already locked by another thread.\0"; <br>        case DDERR_PRIMARYSURFACEALREADYEXISTS: <br>            return "This process already has created a primary surface.\0"; <br>        case DDERR_REGIONTOOSMALL: <br>            return "Region passed to Clipper::GetClipList is too small.\0"; <br>        case DDERR_SURFACEALREADYATTACHED: <br>            return "This surface is already attached to the surface it is being attached to.\0"; <br>        case DDERR_SURFACEALREADYDEPENDENT: <br>            return "This surface is already a dependency of the surface it is being made a dependency of.\0"; <br>        case DDERR_SURFACEBUSY: <br>            return "Access to this surface is being refused because the surface is already locked by another thread.\0"; <br>        case DDERR_SURFACEISOBSCURED: <br>            return "Access to surface refused because the surface is obscured.\0"; <br>        case DDERR_SURFACELOST: <br>            return "Access to this surface is being refused because the surface memory is gone. The DirectDrawSurface object representing this surface should have Restore called on it.\0"; <br>        case DDERR_SURFACENOTATTACHED: <br>            return "The requested surface is not attached.\0"; <br>        case DDERR_TOOBIGHEIGHT: <br>            return "Height requested by DirectDraw is too large.\0"; <br>        case DDERR_TOOBIGSIZE: <br>            return "Size requested by DirectDraw is too large, but the individual height and width are OK.\0"; <br>        case DDERR_TOOBIGWIDTH: <br>            return "Width requested by DirectDraw is too large.\0"; <br>        case DDERR_UNSUPPORTED: <br>            return "Action not supported.\0"; <br>        case DDERR_UNSUPPORTEDFORMAT: <br>            return "FOURCC format requested is unsupported by DirectDraw.\0"; <br>        case DDERR_UNSUPPORTEDMASK: <br>            return "Bitmask in the pixel format requested is unsupported by DirectDraw.\0"; <br>        case DDERR_VERTICALBLANKINPROGRESS: <br>            return "Vertical blank is in progress.\0"; <br>        case DDERR_WASSTILLDRAWING: <br>            return "Informs DirectDraw that the previous Blt which is transfering information to or from this Surface is incomplete.\0"; <br>        case DDERR_WRONGMODE: <br>            return "This surface can not be restored because it was created in a different mode.\0"; <br>        case DDERR_XALIGN: <br>            return "Rectangle provided was not horizontally aligned on required boundary.\0"; <br>        case D3DERR_BADMAJORVERSION: <br>            return "D3DERR_BADMAJORVERSION\0"; <br>        case D3DERR_BADMINORVERSION: <br>            return "D3DERR_BADMINORVERSION\0"; <br>        case D3DERR_EXECUTE_LOCKED: <br>            return "D3DERR_EXECUTE_LOCKED\0"; <br>        case D3DERR_EXECUTE_NOT_LOCKED: <br>            return "D3DERR_EXECUTE_NOT_LOCKED\0"; <br>        case D3DERR_EXECUTE_CREATE_FAILED: <br>            return "D3DERR_EXECUTE_CREATE_FAILED\0"; <br>        case D3DERR_EXECUTE_DESTROY_FAILED: <br>            return "D3DERR_EXECUTE_DESTROY_FAILED\0"; <br>        case D3DERR_EXECUTE_LOCK_FAILED: <br>            return "D3DERR_EXECUTE_LOCK_FAILED\0"; <br>        case D3DERR_EXECUTE_UNLOCK_FAILED: <br>            return "D3DERR_EXECUTE_UNLOCK_FAILED\0"; <br>        case D3DERR_EXECUTE_FAILED: <br>            return "D3DERR_EXECUTE_FAILED\0"; <br>        case D3DERR_EXECUTE_CLIPPED_FAILED: <br>            return "D3DERR_EXECUTE_CLIPPED_FAILED\0"; <br>        case D3DERR_TEXTURE_NO_SUPPORT: <br>            return "D3DERR_TEXTURE_NO_SUPPORT\0"; <br>        case D3DERR_TEXTURE_NOT_LOCKED: <br>            return "D3DERR_TEXTURE_NOT_LOCKED\0"; <br>        case D3DERR_TEXTURE_LOCKED: <br>            return "D3DERR_TEXTURELOCKED\0"; <br>        case D3DERR_TEXTURE_CREATE_FAILED: <br>            return "D3DERR_TEXTURE_CREATE_FAILED\0"; <br>        case D3DERR_TEXTURE_DESTROY_FAILED: <br>            return "D3DERR_TEXTURE_DESTROY_FAILED\0"; <br>        case D3DERR_TEXTURE_LOCK_FAILED: <br>            return "D3DERR_TEXTURE_LOCK_FAILED\0"; <br>        case D3DERR_TEXTURE_UNLOCK_FAILED: <br>            return "D3DERR_TEXTURE_UNLOCK_FAILED\0"; <br>        case D3DERR_TEXTURE_LOAD_FAILED: <br>            return "D3DERR_TEXTURE_LOAD_FAILED\0"; <br>        case D3DERR_MATRIX_CREATE_FAILED: <br>            return "D3DERR_MATRIX_CREATE_FAILED\0"; <br>        case D3DERR_MATRIX_DESTROY_FAILED: <br>            return "D3DERR_MATRIX_DESTROY_FAILED\0"; <br>        case D3DERR_MATRIX_SETDATA_FAILED: <br>            return "D3DERR_MATRIX_SETDATA_FAILED\0"; <br>        case D3DERR_SETVIEWPORTDATA_FAILED: <br>            return "D3DERR_SETVIEWPORTDATA_FAILED\0"; <br>        case D3DERR_MATERIAL_CREATE_FAILED: <br>            return "D3DERR_MATERIAL_CREATE_FAILED\0"; <br>        case D3DERR_MATERIAL_DESTROY_FAILED: <br>            return "D3DERR_MATERIAL_DESTROY_FAILED\0"; <br>        case D3DERR_MATERIAL_SETDATA_FAILED: <br>            return "D3DERR_MATERIAL_SETDATA_FAILED\0"; <br>        case D3DERR_LIGHT_SET_FAILED: <br>            return "D3DERR_LIGHT_SET_FAILED\0"; <br>case D3DRMERR_BADOBJECT: <br>    return "D3DRMERR_BADOBJECT\0"; <br>case D3DRMERR_BADTYPE: <br>    return "D3DRMERR_BADTYPE\0"; <br>case D3DRMERR_BADALLOC: <br>    return "D3DRMERR_BADALLOC\0"; <br>case D3DRMERR_FACEUSED: <br>    return "D3DRMERR_FACEUSED\0"; <br>case D3DRMERR_NOTFOUND: <br>    return "D3DRMERR_NOTFOUND\0"; <br>case D3DRMERR_NOTDONEYET: <br>    return "D3DRMERR_NOTDONEYET\0"; <br>case D3DRMERR_FILENOTFOUND: <br>    return "The file was not found.\0"; <br>case D3DRMERR_BADFILE: <br>    return "D3DRMERR_BADFILE\0"; <br>case D3DRMERR_BADDEVICE: <br>    return "D3DRMERR_BADDEVICE\0"; <br>case D3DRMERR_BADVALUE: <br>    return "D3DRMERR_BADVALUE\0"; <br>case D3DRMERR_BADMAJORVERSION: <br>    return "D3DRMERR_BADMAJORVERSION\0"; <br>case D3DRMERR_BADMINORVERSION: <br>    return "D3DRMERR_BADMINORVERSION\0"; <br>case D3DRMERR_UNABLETOEXECUTE: <br>    return "D3DRMERR_UNABLETOEXECUTE\0"; <br>        default: <br>            return "Unrecognized error value.\0"; <br>    } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
