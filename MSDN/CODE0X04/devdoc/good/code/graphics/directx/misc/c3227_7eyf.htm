<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DDUTIL2.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3237"></a>DDUTIL2.CPP</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1995-1996 Microsoft Corporation. All Rights Reserved. <br> * <br> *  File:       ddutil.cpp <br> *  Content:    Routines for loading bitmap and palettes from resources <br> * <br> ***************************************************************************/ <br>#undef WIN32_LEAN_AND_MEAN <br>#define WIN32_LEAN_AND_MEAN <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;ddraw.h&gt; <br>#include "ddutil2.h" <br> <br>/* <br> *  DDLoadBitmap <br> * <br> *  create a DirectDrawSurface from a bitmap resource. <br> * <br> */ <br>extern "C" IDirectDrawSurface3 * DDLoadBitmap2(IDirectDraw2 *pdd, LPCSTR szBitmap, int dx, int dy) <br>{ <br>    HBITMAP             hbm; <br>    BITMAP              bm; <br>    DDSURFACEDESC       ddsd; <br>    IDirectDrawSurface3 *pdds; <br> <br>    // <br>    //  try to load the bitmap as a resource, if that fails, try it as a file <br>    // <br>    hbm = (HBITMAP)LoadImage(GetModuleHandle(NULL), szBitmap, IMAGE_BITMAP, dx, dy, LR_CREATEDIBSECTION); <br> <br>    if (hbm == NULL) <br>hbm = (HBITMAP)LoadImage(NULL, szBitmap, IMAGE_BITMAP, dx, dy, LR_LOADFROMFILE|LR_CREATEDIBSECTION); <br> <br>    if (hbm == NULL) <br>return NULL; <br> <br>    // <br>    // get size of the bitmap <br>    // <br>    GetObject(hbm, sizeof(bm), &amp;bm);      // get size of bitmap <br> <br>    // <br>    // create a DirectDrawSurface for this bitmap <br>    // <br>    ZeroMemory(&amp;ddsd, sizeof(ddsd)); <br>    ddsd.dwSize = sizeof(ddsd); <br>    ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT |DDSD_WIDTH; <br>    ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN; <br>    ddsd.dwWidth = bm.bmWidth; <br>    ddsd.dwHeight = bm.bmHeight; <br> <br>    LPDIRECTDRAWSURFACE lpDDSTemp; <br>    if (pdd-&gt;CreateSurface(&amp;ddsd, &amp;lpDDSTemp, NULL) != DD_OK) <br>    { <br>        OutputDebugString("CreateSurf failed"); <br>        return NULL; <br>    }; <br>    if (lpDDSTemp-&gt;QueryInterface(IID_IDirectDrawSurface3,(void**)&amp;pdds) != DD_OK) <br>    { <br>        OutputDebugString("QueryInterface failed"); <br>        return NULL; <br>    } <br>    lpDDSTemp-&gt;Release(); <br> <br>    DDCopyBitmap2(pdds, hbm, 0, 0, 0, 0); <br> <br>    DeleteObject(hbm); <br> <br>    return pdds; <br>} <br> <br>/* <br> *  DDReLoadBitmap <br> * <br> *  load a bitmap from a file or resource into a directdraw surface. <br> *  normaly used to re-load a surface after a restore. <br> * <br> */ <br>HRESULT DDReLoadBitmap2(IDirectDrawSurface3 *pdds, LPCSTR szBitmap) <br>{ <br>    HBITMAP             hbm; <br>    HRESULT             hr; <br> <br>    // <br>    //  try to load the bitmap as a resource, if that fails, try it as a file <br>    // <br>    hbm = (HBITMAP)LoadImage(GetModuleHandle(NULL), szBitmap, IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION); <br> <br>    if (hbm == NULL) <br>hbm = (HBITMAP)LoadImage(NULL, szBitmap, IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE|LR_CREATEDIBSECTION); <br> <br>    if (hbm == NULL) <br>    { <br>OutputDebugString("handle is null\n"); <br>return E_FAIL; <br>    } <br> <br>    hr = DDCopyBitmap2(pdds, hbm, 0, 0, 0, 0); <br>    if (hr != DD_OK) <br>    { <br>OutputDebugString("ddcopybitmap failed \n"); <br>    } <br> <br> <br>    DeleteObject(hbm); <br>    return hr; <br>} <br> <br>/* <br> *  DDCopyBitmap <br> * <br> *  draw a bitmap into a DirectDrawSurface <br> * <br> */ <br>extern "C" HRESULT DDCopyBitmap2(IDirectDrawSurface3 *pdds, HBITMAP hbm, int x, int y, int dx, int dy) <br>{ <br>    HDC                 hdcImage; <br>    HDC                 hdc; <br>    BITMAP              bm; <br>    DDSURFACEDESC       ddsd; <br>    HRESULT             hr; <br> <br>    if (hbm == NULL || pdds == NULL) <br>return E_FAIL; <br> <br>    // <br>    // make sure this surface is restored. <br>    // <br>    pdds-&gt;Restore(); <br> <br>    // <br>    //  select bitmap into a memoryDC so we can use it. <br>    // <br>    hdcImage = CreateCompatibleDC(NULL); <br>    if (!hdcImage) <br>OutputDebugString("createcompatible dc failed\n"); <br>    SelectObject(hdcImage, hbm); <br> <br>    // <br>    // get size of the bitmap <br>    // <br>    GetObject(hbm, sizeof(bm), &amp;bm);    // get size of bitmap <br>    dx = dx == 0 ? bm.bmWidth  : dx;    // use the passed size, unless zero <br>    dy = dy == 0 ? bm.bmHeight : dy; <br> <br>    // <br>    // get size of surface. <br>    // <br>    ddsd.dwSize = sizeof(ddsd); <br>    ddsd.dwFlags = DDSD_HEIGHT | DDSD_WIDTH; <br>    pdds-&gt;GetSurfaceDesc(&amp;ddsd); <br> <br>    if ((hr = pdds-&gt;GetDC(&amp;hdc)) == DD_OK) <br>    { <br>        StretchBlt(hdc, 0, 0, ddsd.dwWidth, ddsd.dwHeight, hdcImage, x, y, dx, dy, SRCCOPY); <br>        pdds-&gt;ReleaseDC(hdc); <br>    } <br> <br>    DeleteDC(hdcImage); <br> <br>    return hr; <br>} <br> <br>// <br>//  DDLoadPalette <br>// <br>//  Create a DirectDraw palette object from a bitmap resoure <br>// <br>//  if the resource does not exist or NULL is passed create a <br>//  default 332 palette. <br>// <br>extern "C" IDirectDrawPalette * DDLoadPalette2(IDirectDraw2 *pdd, LPCSTR szBitmap) <br>{ <br>    IDirectDrawPalette* ddpal; <br>    int                 i; <br>    int                 n; <br>    int                 fh; <br>    HRSRC               h; <br>    LPBITMAPINFOHEADER  lpbi; <br>    PALETTEENTRY        ape[256]; <br>    RGBQUAD *           prgb; <br> <br>    // <br>    // build a 332 palette as the default. <br>    // <br>    for (i=0; i&lt;256; i++) <br>    { <br>ape[i].peRed   = (BYTE)(((i &gt;&gt; 5) &amp; 0x07) * 255 / 7); <br>ape[i].peGreen = (BYTE)(((i &gt;&gt; 2) &amp; 0x07) * 255 / 7); <br>ape[i].peBlue  = (BYTE)(((i &gt;&gt; 0) &amp; 0x03) * 255 / 3); <br>ape[i].peFlags = (BYTE)0; <br>    } <br> <br>    // <br>    // get a pointer to the bitmap resource. <br>    // <br>    if (szBitmap &amp;&amp; (h = FindResource(NULL, szBitmap, RT_BITMAP))) <br>    { <br>lpbi = (LPBITMAPINFOHEADER)LockResource(LoadResource(NULL, h)); <br>if (!lpbi) <br>    OutputDebugString("lock resource failed\n"); <br>prgb = (RGBQUAD*)((BYTE*)lpbi + lpbi-&gt;biSize); <br> <br>if (lpbi == NULL || lpbi-&gt;biSize &lt; sizeof(BITMAPINFOHEADER)) <br>    n = 0; <br>else if (lpbi-&gt;biBitCount &gt; 8) <br>    n = 0; <br>else if (lpbi-&gt;biClrUsed == 0) <br>    n = 1 &lt;&lt; lpbi-&gt;biBitCount; <br>else <br>    n = lpbi-&gt;biClrUsed; <br> <br>// <br>//  a DIB color table has its colors stored BGR not RGB <br>//  so flip them around. <br>// <br>for(i=0; i&lt;n; i++ ) <br>{ <br>    ape[i].peRed   = prgb[i].rgbRed; <br>    ape[i].peGreen = prgb[i].rgbGreen; <br>    ape[i].peBlue  = prgb[i].rgbBlue; <br>    ape[i].peFlags = 0; <br>} <br>    } <br>    else if (szBitmap &amp;&amp; (fh = _lopen(szBitmap, OF_READ)) != -1) <br>    { <br>BITMAPFILEHEADER bf; <br>BITMAPINFOHEADER bi; <br> <br>_lread(fh, &amp;bf, sizeof(bf)); <br>_lread(fh, &amp;bi, sizeof(bi)); <br>_lread(fh, ape, sizeof(ape)); <br>_lclose(fh); <br> <br>if (bi.biSize != sizeof(BITMAPINFOHEADER)) <br>    n = 0; <br>else if (bi.biBitCount &gt; 8) <br>    n = 0; <br>else if (bi.biClrUsed == 0) <br>    n = 1 &lt;&lt; bi.biBitCount; <br>else <br>    n = bi.biClrUsed; <br> <br>// <br>//  a DIB color table has its colors stored BGR not RGB <br>//  so flip them around. <br>// <br>for(i=0; i&lt;n; i++ ) <br>{ <br>    BYTE r = ape[i].peRed; <br>    ape[i].peRed  = ape[i].peBlue; <br>    ape[i].peBlue = r; <br>} <br>    } <br> <br>    pdd-&gt;CreatePalette(DDPCAPS_8BIT, ape, &amp;ddpal, NULL); <br> <br>    return ddpal; <br>} <br> <br>/* <br> * DDColorMatch <br> * <br> * convert a RGB color to a pysical color. <br> * <br> * we do this by leting GDI SetPixel() do the color matching <br> * then we lock the memory and see what it got mapped to. <br> */ <br>extern "C" DWORD DDColorMatch2(IDirectDrawSurface3 *pdds, COLORREF rgb) <br>{ <br>    COLORREF rgbT; <br>    HDC hdc; <br>    DWORD dw = CLR_INVALID; <br>    DDSURFACEDESC ddsd; <br>    HRESULT hres; <br> <br>    // <br>    //  use GDI SetPixel to color match for us <br>    // <br>    if (rgb != CLR_INVALID &amp;&amp; pdds-&gt;GetDC(&amp;hdc) == DD_OK) <br>    { <br>rgbT = GetPixel(hdc, 0, 0);             // save current pixel value <br>SetPixel(hdc, 0, 0, rgb);               // set our value <br>pdds-&gt;ReleaseDC(hdc); <br>    } <br> <br>    // <br>    // now lock the surface so we can read back the converted color <br>    // <br>    ddsd.dwSize = sizeof(ddsd); <br>    while ((hres = pdds-&gt;Lock(NULL, &amp;ddsd, 0, NULL)) == DDERR_WASSTILLDRAWING) <br>; <br> <br>    if (hres == DD_OK) <br>    { <br>dw  = *(DWORD *)ddsd.lpSurface;                     // get DWORD <br>dw &amp;= (1 &lt;&lt; ddsd.ddpfPixelFormat.dwRGBBitCount)-1;  // mask it to bpp <br>pdds-&gt;Unlock(NULL); <br>    } <br> <br>    // <br>    //  now put the color that was there back. <br>    // <br>    if (rgb != CLR_INVALID &amp;&amp; pdds-&gt;GetDC(&amp;hdc) == DD_OK) <br>    { <br>SetPixel(hdc, 0, 0, rgbT); <br>pdds-&gt;ReleaseDC(hdc); <br>    } <br> <br>    return dw; <br>} <br> <br>/* <br> * DDSetColorKey <br> * <br> * set a color key for a surface, given a RGB. <br> * if you pass CLR_INVALID as the color key, the pixel <br> * in the upper-left corner will be used. <br> */ <br>extern "C" HRESULT DDSetColorKey2(IDirectDrawSurface3 *pdds, COLORREF rgb) <br>{ <br>    DDCOLORKEY          ddck; <br> <br>    ddck.dwColorSpaceLowValue  = DDColorMatch2(pdds, rgb); <br>    ddck.dwColorSpaceHighValue = ddck.dwColorSpaceLowValue; <br>    return pdds-&gt;SetColorKey(DDCKEY_SRCBLT, &amp;ddck); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
