<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>RMFULL.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3249"></a>RMFULL.CPP</h2>
<pre><code>/* <br> *  Copyright (C) 1995, 1996 Microsoft Corporation. All Rights Reserved. <br> * <br> *  File: rmfull.cpp <br> * <br> *  Each of the Direct3D retained mode (D3DRM) samples may be linked with <br> *  this file.  It contains the code which allows them to run in the Windows <br> *  environment as a window or fullscreen.  It is a modified version of <br> *  d3dmain.cpp.  Comparing these two files is instructive. <br> * <br> *  A window is created using rmfull.res which allows the user to select the <br> *  Direct3D driver to use and change the render options.  The D3DApp <br> *  collection of functions is used to initialize DirectDraw, Direct3D and <br> *  keep surfaces and D3D devices available for rendering. <br> * <br> *  Frame rate and a screen mode information buffer is Blt'ed to the screen <br> *  by functions in rmstats.cpp. <br> * <br> *  Individual samples are executed through two functions, BuildScene and <br> *  OverrideDefaults, as described in rmdemo.h.  Samples can also read <br> *  mouse input via ReadMouse. <br> */ <br> <br>#include "rmfull.h" <br>#include &lt;stdarg.h&gt; <br> <br>/* <br> * GLOBAL VARIABLES <br> */ <br>D3DAppInfo* d3dapp;    /* Pointer to read only collection of DD and D3D <br>       objects maintained by D3DApp */ <br>rmfullglobals myglobs;    /* collection of global variables */ <br>LPDIRECT3DRM lpD3DRM;/* Direct3DRM object */ <br> <br>/* <br> *  INTERNAL FUNCTION PROTOTYPES <br> */ <br>static BOOL AppInit(HINSTANCE hInstance, LPSTR lpCmdLine); <br>static BOOL CreateD3DApp(LPSTR lpCmdLine); <br>static BOOL BeforeDeviceDestroyed(LPVOID lpContext); <br>static BOOL AfterDeviceCreated(int w, int h, LPDIRECT3DVIEWPORT* lpViewport, <br>       LPVOID lpContext); <br>void CleanUpAndPostQuit(void); <br>static void InitGlobals(void); <br>static BOOL AppPause(BOOL f); <br>void ReportD3DAppError(void); <br>static BOOL RenderLoop(void); <br>static BOOL RestoreSurfaces(); <br>long FAR PASCAL WindowProc(HWND hWnd, UINT message, WPARAM wParam, <br>   LPARAM lParam ); <br>extern "C" void ReadMouse(int*, int*, int*); <br>extern "C" char* D3DRMErrorToString(HRESULT error); <br>BOOL CreateD3DRM(HWND win); <br>BOOL SetRenderState(void); <br> <br>/****************************************************************************/ <br>/*                            WinMain                                       */ <br>/****************************************************************************/ <br>/* <br> * Initializes the application then enters a message loop which calls sample's <br> * RenderScene until a quit message is received. <br> */ <br>int PASCAL <br>WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <br>int nCmdShow) <br>{ <br>    int failcount = 0; /* number of times RenderLoop has failed */ <br>    MSGmsg; <br>    HACCEL hAccelApp; <br> <br>    hPrevInstance; <br>    /* <br>     * Create the window and initialize all objects needed to begin rendering <br>     */ <br>    if(!AppInit(hInstance, lpCmdLine)) <br>    return FALSE; <br>    hAccelApp = LoadAccelerators(hInstance, "AppAccel"); <br> <br>    while (!myglobs.bQuit) { <br>/*  <br> * Monitor the message queue until there are no pressing <br> * messages <br> */ <br>        if (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) { <br>            if (msg.message == WM_QUIT) { <br>CleanUpAndPostQuit(); <br>                break; <br>    } <br>            if (!myglobs.hWndMain || !TranslateAccelerator(myglobs.hWndMain, <br>   hAccelApp, &amp;msg)) { <br>                TranslateMessage(&amp;msg);  <br>                DispatchMessage(&amp;msg); <br>            } <br>/*  <br> * If the app is not minimized, not about to quit, not paused, either the <br> * active fullscreen app or in a window and D3D has been initialized, <br> * we can render <br> */ <br>        } else if (d3dapp-&gt;bRenderingIsOK &amp;&amp; !d3dapp-&gt;bMinimized <br>   &amp;&amp; !d3dapp-&gt;bPaused &amp;&amp; !myglobs.bQuit  <br>   &amp;&amp; (d3dapp-&gt;bAppActive || !d3dapp-&gt;bFullscreen)) { <br>    /* <br>     * If were are not in single step mode or if we are and the <br>     * bDrawAFrame flag is set, render one frame <br>     */ <br>            if (!(myglobs.bSingleStepMode &amp;&amp; !myglobs.bDrawAFrame)) { <br>/*  <br> * Attempt to render a frame, if it fails, take a note.  If <br> * rendering fails more than twice, abort execution. <br> */ <br>if (!RenderLoop()) { <br>    ++failcount; <br>    if (failcount == 3) { <br>Msg("Rendering has failed too many times.  Aborting execution.\n"); <br>CleanUpAndPostQuit(); <br>break; <br>    } <br>} <br>    } <br>    /* <br>     * Reset the bDrawAFrame flag if we are in single step mode <br>     */ <br>            if (myglobs.bSingleStepMode) <br>                myglobs.bDrawAFrame = FALSE; <br>        } else { <br>    WaitMessage(); <br>} <br>    } <br>    DestroyWindow(myglobs.hWndMain); <br>    return msg.wParam; <br>} <br> <br>/****************************************************************************/ <br>/*             D3DApp Initialization and callback functions                 */ <br>/****************************************************************************/ <br>/* <br> * AppInit <br> * Creates the window and initializes all objects necessary to begin rendering <br> */ <br>static BOOL <br>AppInit(HINSTANCE hInstance, LPSTR lpCmdLine) <br>{ <br>    WNDCLASS wc; <br>    HMENU hmenu; <br>    DWORD flags; <br>    int i; <br>    Defaults defaults; <br> <br>    /* <br>     * Register the window class <br>     */ <br>    wc.style = CS_HREDRAW | CS_VREDRAW; <br>    wc.lpfnWndProc = WindowProc; <br>    wc.cbClsExtra = 0; <br>    wc.cbWndExtra = 0; <br>    wc.hInstance = hInstance; <br>    wc.hIcon = LoadIcon( hInstance, "AppIcon"); <br>    wc.hCursor = LoadCursor( NULL, IDC_ARROW ); <br>    wc.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH); <br>    wc.lpszMenuName = "AppMenu"; <br>    wc.lpszClassName = "Example"; <br>    if (!RegisterClass(&amp;wc)) <br>        return FALSE; <br>    /* <br>     * Initialize the global variables and allow the sample code to override <br>     * some of these default settings. <br>     */ <br>    InitGlobals(); <br>    myglobs.hInstApp = hInstance; <br>    defaults.bNoTextures = myglobs.bNoTextures; <br>    defaults.bConstRenderQuality = myglobs.bConstRenderQuality; <br>    defaults.bResizingDisabled = FALSE; <br>    lstrcpy(defaults.Name, "D3DRM Example"); <br>    OverrideDefaults(&amp;defaults); <br>    myglobs.bNoTextures = defaults.bNoTextures; <br>    myglobs.bConstRenderQuality = defaults.bConstRenderQuality; <br>    myglobs.lpCmdLine = lpCmdLine; <br> <br>    /* <br>     * Enumerate the DD drivers <br>     */ <br>    if (!D3DAppEnumerateDDDevices(&amp;myglobs.NumDDDrivers, &amp;myglobs.DDDriver[0])) { <br>ReportD3DAppError(); <br>return FALSE; <br>    } <br>    /* <br>     * Choose the last device enumerated which will probably be secondary 3d hardware. <br>     */ <br>    myglobs.CurrDDDriver = myglobs.NumDDDrivers - 1; <br> <br>    /* <br>     * Create the window <br>     */ <br>    if (defaults.bResizingDisabled) <br>flags =  WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | <br> WS_MINIMIZEBOX | WS_MAXIMIZEBOX; <br>    else <br>flags = WS_OVERLAPPEDWINDOW; <br>    /* <br>     * Create a window with some default settings that may change <br>     */ <br>    myglobs.hWndMain = CreateWindowEx( <br>          WS_EX_APPWINDOW, <br> "Example", <br> defaults.Name, <br> flags, <br>         CW_USEDEFAULT, CW_USEDEFAULT, <br> START_WIN_SIZE, START_WIN_SIZE, <br>         NULL,    /* parent window */ <br> NULL,    /* menu handle */ <br> hInstance,    /* program handle */ <br> NULL);    /* create parms */ <br>    if (!myglobs.hWndMain){ <br>    Msg("CreateWindowEx failed"); <br>    return FALSE; <br>    } <br>    /* <br>     * Display the window <br>     */ <br>    ShowWindow(myglobs.hWndMain, SW_SHOWNORMAL); <br>    UpdateWindow(myglobs.hWndMain); <br>    /* <br>     * Add the list of DD drivers D3DApp found to the file menu <br>     */ <br>    hmenu = GetSubMenu(GetMenu(myglobs.hWndMain), 0); <br>    for (i = 0; i &lt; myglobs.NumDDDrivers; i++) { <br>        InsertMenu(hmenu,  6 + i, MF_BYPOSITION | MF_STRING, <br>   MENU_FIRST_DDDRIVER + i, myglobs.DDDriver[i].Name); <br>    } <br>    /*  <br>     * Create the D3DRM object which are initialized only when the program <br>     * starts <br>     */ <br>    if (!CreateD3DRM(myglobs.hWndMain)) <br>        return FALSE; <br>    /* <br>     * Call D3DApp to initialize all DD and D3D objects necessary to render. <br>     * D3DApp will call the device creation callback which will initialize the <br>     * viewport and the sample's execute buffers. <br>     */ <br>    if (!CreateD3DApp(lpCmdLine)) <br>return FALSE; <br>    /* <br>     * Create the scene to be rendered by calling this sample's BuildScene <br>     */ <br>    if (!BuildScene(myglobs.dev, myglobs.view, myglobs.scene, myglobs.camera)) <br>return FALSE; <br> <br>    return TRUE; <br>} <br> <br>/* <br> * CreateD3DRM <br> * Create main D3DRM objects which are only initialized once. <br> */ <br>BOOL <br>CreateD3DRM(HWND win) <br>{ <br>    HRESULT rval; <br> <br>    /* <br>     * Create the D3DRM object <br>     */ <br>    rval = Direct3DRMCreate(&amp;lpD3DRM); <br>    if (rval != D3DRM_OK) { <br>Msg("Failed to create Direct3DRM.\n%s", D3DAppErrorToString(rval)); <br>return FALSE; <br>    } <br>    /* <br>     * Create the master scene frame and camera frame <br>     */ <br>    rval = lpD3DRM-&gt;CreateFrame(NULL, &amp;myglobs.scene); <br>    if (rval != D3DRM_OK) { <br>Msg("Failed to create the master scene frame.\n%s", D3DAppErrorToString(rval)); <br>return FALSE; <br>    } <br>    rval = lpD3DRM-&gt;CreateFrame(myglobs.scene, &amp;myglobs.camera); <br>    if (rval != D3DRM_OK) { <br>Msg("Failed to create the camera's frame.\n%s", D3DAppErrorToString(rval)); <br>return FALSE; <br>    } <br>    rval = myglobs.camera-&gt;SetPosition(myglobs.scene, D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0)); <br>    if (rval != D3DRM_OK) { <br>Msg("Failed to position the camera in the frame.\n%s", D3DAppErrorToString(rval)); <br>return FALSE; <br>    } <br>    return TRUE; <br>} <br> <br>/* <br> * CreateD3DApp <br> * Create all DirectDraw and Direct3D objects necessary to begin rendering. <br> * Add the list of D3D drivers to the file menu. <br> */ <br>static BOOL <br>CreateD3DApp(LPSTR lpCmdLine) <br>{ <br>    HMENU hmenu; <br>    int i; <br>    LPSTR option; <br>    BOOL bOnlySystemMemory, bOnlyEmulation; <br>    DWORD flags; <br> <br>    /* <br>     * Parse the command line in seach of one of the following options: <br>     *     systemmemory  All surfaces should be created in system memory. <br>     *                   Hardware DD and D3D devices are disabled, but <br>     *                   debugging during the Win16 lock becomes possible. <br>     *     emulation     Do not use hardware DD or D3D devices. <br>     */ <br>    bOnlySystemMemory = FALSE; <br>    bOnlyEmulation = FALSE; <br>    option = strtok(lpCmdLine, " -"); <br>    while(option != NULL )   { <br>        if (!lstrcmp(option, "systemmemory")) { <br>            bOnlySystemMemory = TRUE; <br>        } else if (!lstrcmp(option, "emulation")) { <br>    bOnlyEmulation = TRUE; <br>} else { <br>            Msg("Invalid command line options given.\nLegal options: -systemmemory, -emulation\n"); <br>            return FALSE; <br>        } <br>        option = strtok(NULL, " -"); <br>    } <br>    /* <br>     * Set the flags to pass to the D3DApp creation based on command line <br>     */ <br>    flags = ((bOnlySystemMemory) ? D3DAPP_ONLYSYSTEMMEMORY : 0) |  <br>    ((bOnlyEmulation) ? (D3DAPP_ONLYD3DEMULATION | <br> D3DAPP_ONLYDDEMULATION) : 0); <br>    /* <br>     * Create all the DirectDraw and D3D objects neccesary to render.  The <br>     * AfterDeviceCreated callback function is called by D3DApp to create the <br>     * viewport and the example's execute buffers. <br>     */ <br>    if (!D3DAppCreateFromHWND(flags, myglobs.hWndMain,  <br>      myglobs.DDDriver[myglobs.CurrDDDriver].bIsPrimary ? NULL : &amp;myglobs.DDDriver[myglobs.CurrDDDriver].Guid, <br>      AfterDeviceCreated, NULL, BeforeDeviceDestroyed, NULL, &amp;d3dapp)) { <br>ReportD3DAppError(); <br>return FALSE; <br>    } <br>    /* <br>     * Add the the list of display modes D3DApp found to the mode menu <br>     */ <br>    hmenu = GetSubMenu(GetMenu(myglobs.hWndMain), 2); <br>    for (i = 0; i &lt; d3dapp-&gt;NumModes; i++) { <br>        char ach[80]; <br>        wsprintf(ach,"%dx%dx%d", d3dapp-&gt;Mode[i].w, d3dapp-&gt;Mode[i].h, <br> d3dapp-&gt;Mode[i].bpp); <br>        AppendMenu(hmenu, MF_STRING, MENU_FIRST_MODE+i, ach); <br>    } <br>    /* <br>     * Add the list of D3D drivers D3DApp foudn to the file menu <br>     */ <br>    hmenu = GetSubMenu(GetMenu(myglobs.hWndMain), 0); <br>    for (i = 0; i &lt; d3dapp-&gt;NumDrivers; i++) { <br>        InsertMenu(hmenu, 7 + myglobs.NumDDDrivers + i, MF_BYPOSITION | MF_STRING, <br>   MENU_FIRST_DRIVER + i, d3dapp-&gt;Driver[i].Name); <br>    } <br> <br>    return TRUE; <br>} <br> <br>/* <br> * DestroyD3DApp <br> * <br> * Destroy D3DApp and changes to menu <br> */ <br>static void <br>DestroyD3DApp(void) <br>{ <br>    HMENU hmenu; <br>    int i; <br> <br>    /* <br>     * Remove the list of display modes <br>     */ <br>    hmenu = GetSubMenu(GetMenu(myglobs.hWndMain), 4); <br>    for (i = 0; i &lt; d3dapp-&gt;NumModes; i++) { <br>        DeleteMenu(hmenu, MENU_FIRST_MODE + i, MF_BYCOMMAND); <br>    } <br>    /* <br>     * Remove the list of D3D drivers <br>     */ <br>    hmenu = GetSubMenu(GetMenu(myglobs.hWndMain), 0); <br>    for (i = 0; i &lt; d3dapp-&gt;NumDrivers; i++) { <br>        DeleteMenu(hmenu, MENU_FIRST_DRIVER + i, MF_BYCOMMAND); <br>    } <br>    RELEASE(myglobs.lpInfoBuffer); <br>    RELEASE(myglobs.lpFrameRateBuffer); <br>    D3DAppDestroy(); <br>} <br> <br>/* <br> * AfterDeviceCreated <br> * D3DApp will call this function immediately after the D3D device has been <br> * created (or re-created).  D3DApp expects the D3D viewport to be created and <br> * returned.  In this case, we will return NULL because we only have a D3DRM <br> * viewport.  This is fine as long as we don't use any of the D3D viewport <br> * functionality of D3DApp. <br> */ <br>static BOOL <br>AfterDeviceCreated(int w, int h, LPDIRECT3DVIEWPORT* lplpViewport, LPVOID lpContext) <br>{ <br>    HRESULT rval; <br> <br>    rval = lpD3DRM-&gt;CreateDeviceFromD3D(d3dapp-&gt;lpD3D, d3dapp-&gt;lpD3DDevice, <br>&amp;myglobs.dev); <br>    if (rval != D3DRM_OK) { <br>        Msg("Creation of D3DRM device failed.\n%s", D3DAppErrorToString(rval)); <br>        return FALSE; <br>    } <br>    /* <br>     * Create the D3DRM viewport using the camera frame.  Set the background <br>     * depth to a large number.  The width and height may be slightly <br>     * adjusted, so get them from the device to be sure. <br>     */ <br>    w = myglobs.dev-&gt;GetWidth(); <br>    h = myglobs.dev-&gt;GetHeight(); <br>    rval = lpD3DRM-&gt;CreateViewport(myglobs.dev, myglobs.camera, 0, 0, w, <br>   h, &amp;myglobs.view); <br>    if (rval != D3DRM_OK) { <br>Msg("Failed to create the D3DRM viewport.\n%s", <br>    D3DAppErrorToString(rval)); <br>RELEASE(myglobs.dev); <br>return FALSE; <br>    } <br>    rval = myglobs.view-&gt;SetBack(D3DVAL(5000.0)); <br>    if (rval != D3DRM_OK) { <br>Msg("Failed to set the background depth of the D3DRM viewport.\n%s", <br>    D3DAppErrorToString(rval)); <br>RELEASE(myglobs.dev); <br>RELEASE(myglobs.view); <br>return FALSE; <br>    } <br>    /* <br>     * Set the render quality, fill mode, lighting state and color shade info <br>     */ <br>    if (!SetRenderState()) <br>return FALSE; <br> <br>    /* <br>     * Return NULL for the viewport <br>     */ <br>    *lplpViewport = NULL; <br>    /* <br>     * Create and initialize the surfaces containing the frame rate and <br>     * window information <br>     */ <br>    InitFontAndTextBuffers(); <br> <br>    return TRUE; <br>} <br> <br>/* <br> * BeforeDeviceDestroyed <br> * D3DApp will call this function before the current D3D device is destroyed <br> * to give the app the opportunity to destroy objects it has created with the <br> * DD or D3D objects. <br> */ <br>static BOOL <br>BeforeDeviceDestroyed(LPVOID lpContext) <br>{ <br>    RELEASE(myglobs.view); <br>    RELEASE(myglobs.dev); <br>    return TRUE; <br>} <br> <br>/****************************************************************************/ <br>/*                            Rendering loop                                */ <br>/****************************************************************************/ <br>/* <br> * RenderLoop <br> * Render the next frame and update the window <br> */ <br>static BOOL <br>RenderLoop() <br>{ <br>    D3DRECT extents[D3DAPP_MAXCLEARRECTS]; <br>    int count; <br>    HRESULT rval; <br>    static BOOL b = FALSE; // Clear the second buffer on also <br> <br>    /* <br>     * If all the DD and D3D objects have been initialized we can render <br>     */ <br>    if (d3dapp-&gt;bRenderingIsOK) { <br>/* <br> * Restore any lost surfaces <br> */ <br>        if (!RestoreSurfaces()) { <br>    /* <br>     * Restoring surfaces sometimes fails because the surfaces cannot <br>     * yet be restored.  If this is the case, the error will show up <br>     * somewhere else and we should return success here to prevent <br>     * unnecessary error's being reported. <br>     */ <br>    return TRUE; <br>} <br>/* <br> * Force an update of the entire client window if the resized flag is set <br> */ <br>if (myglobs.bResized || b) <br>    myglobs.view-&gt;ForceUpdate(0, 0, d3dapp-&gt;szClient.cx, d3dapp-&gt;szClient.cy); <br>/* <br> * Use b to makesure the second buffer is cleared also <br> */ <br>if (b) <br>    b = FALSE; <br>if (myglobs.bResized) <br>    b = TRUE; <br> <br>/* <br> * Calculate the frame rate <br> */ <br>        if (!CalculateFrameRate()) <br>    return FALSE; <br> <br>/* <br> * Tick the scene <br> */ <br>rval = myglobs.scene-&gt;Move(D3DVAL(1.0)); <br>if (rval != D3DRM_OK) { <br>    Msg("Moving scene failed.\n%s", D3DAppErrorToString(rval)); <br>    return FALSE; <br>} <br>/*  <br> * Clear the viewport <br> */ <br>rval = myglobs.view-&gt;Clear(); <br>if (rval != D3DRM_OK) { <br>    Msg("Clearing viewport failed.\n%s", D3DAppErrorToString(rval)); <br>    return FALSE; <br>} <br>/* <br> * Render the scene to the viewport <br> */ <br>rval = myglobs.view-&gt;Render(myglobs.scene); <br>if (rval != D3DRM_OK) { <br>    Msg("Rendering scene failed.\n%s", D3DAppErrorToString(rval)); <br>    return FALSE; <br>} <br>/* <br> * Blt the frame rate and window stat text to the back buffer <br> */ <br>count = 0; <br>        if (!DisplayFrameRate(&amp;count, &amp;extents[0])) <br>    return FALSE; <br>for (;count;--count) <br>    myglobs.view-&gt;ForceUpdate(extents[count-1].x1, extents[count-1].y1, <br>      extents[count-1].x2, extents[count-1].y2); <br>/* <br> * Update the window <br> */ <br>rval = myglobs.dev-&gt;Update(); <br>if (rval != D3DRM_OK) { <br>    Msg("Updating device failed.\n%s", D3DAppErrorToString(rval)); <br>    return FALSE; <br>} <br>/* <br> * Blt or flip the back buffer to the front buffer.  If this fails, <br> * don't report an error. <br> */ <br>D3DAppShowBackBuffer(myglobs.bResized ? D3DAPP_SHOWALL : NULL); <br> <br>/* <br> * Reset the resize flag <br> */ <br>        myglobs.bResized = FALSE; <br>    } <br>    return TRUE; <br>} <br> <br>/* <br> * AppPause <br> * Pause and unpause the application <br> */ <br>static BOOL <br>AppPause(BOOL f) <br>{ <br>    /* <br>     * Flip to the GDI surface and halt rendering <br>     */ <br>    if (!D3DAppPause(f)) <br>return FALSE; <br>    /* <br>     * When returning from a pause, reset the frame rate count <br>     */ <br>    if (!f) { <br>        ResetFrameRate(); <br>myglobs.bResized = TRUE; <br>    } <br>    return TRUE; <br>} <br> <br>/* <br> * RestoreSurfaces <br> * Restores any lost surfaces.  Returns TRUE if all surfaces are not lost and <br> * FALSE if one or more surfaces is lost and can not be restored at the <br> * moment. <br> */ <br>static BOOL <br>RestoreSurfaces() <br>{ <br>    HRESULT d3drval; <br> <br>    /* <br>     * Have D3DApp check all the surfaces it's in charge of <br>     */ <br>    if (!D3DAppCheckForLostSurfaces()) { <br>            return FALSE; <br>    } <br>    /* <br>     * Check frame rate and info surfaces and re-write them if they <br>     * were lost. <br>     */ <br>    if (myglobs.lpFrameRateBuffer-&gt;IsLost() == DDERR_SURFACELOST) { <br>        d3drval = myglobs.lpFrameRateBuffer-&gt;Restore(); <br>        if (d3drval != DD_OK) { <br>            return FALSE; <br>        } <br>if (!WriteFrameRateBuffer(0.0f, 0)) <br>    return FALSE; <br>    } <br>    if (myglobs.lpInfoBuffer-&gt;IsLost() == DDERR_SURFACELOST) { <br>        d3drval = myglobs.lpInfoBuffer-&gt;Restore(); <br>        if (d3drval != DD_OK) { <br>            return FALSE; <br>        } <br>if (!WriteInfoBuffer()) <br>    return FALSE; <br>    } <br>    return TRUE; <br>} <br> <br> <br>/************************************************************************* <br>  Windows message handlers <br> *************************************************************************/ <br>/* <br> * AppAbout <br> * About box message handler <br> */ <br>BOOL <br>FAR PASCAL AppAbout(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>  switch (msg) <br>  { <br>    case WM_COMMAND: <br>      if (LOWORD(wParam) == IDOK) <br>        EndDialog(hwnd, TRUE); <br>      break; <br> <br>    case WM_INITDIALOG: <br>      return TRUE; <br>  } <br>  return FALSE; <br>} <br> <br>/* <br> * WindowProc <br> * Main window message handler. <br> */ <br>long <br>FAR PASCAL WindowProc(HWND hWnd, UINT message, WPARAM wParam, <br>   LPARAM lParam ) <br>{ <br>    int i; <br>    BOOL bStop; <br>    LRESULT lresult; <br> <br>    /* <br>     * Give D3DApp an opportunity to process any messages it MUST see in order <br>     * to perform it's function. <br>     */ <br>    if (!D3DAppWindowProc(&amp;bStop, &amp;lresult, hWnd, message, wParam, lParam)) { <br>ReportD3DAppError(); <br>CleanUpAndPostQuit(); <br>return 0; <br>    } <br>    /*  <br>     * If bStop is set by D3DApp, the app should not process the message but <br>     * return lresult. <br>     */ <br>    if (bStop) <br>return lresult; <br> <br>    if (!d3dapp || !d3dapp-&gt;bRenderingIsOK) { <br>return DefWindowProc(hWnd, message, wParam, lParam); <br>    } <br> <br>    switch( message ) { <br>case WM_LBUTTONDOWN: <br>case WM_LBUTTONUP: <br>case WM_RBUTTONDOWN: <br>case WM_RBUTTONUP: <br>case WM_MOUSEMOVE: <br>    /* <br>     * Record the mouse state for ReadMouse <br>     */ <br>    myglobs.mouse_buttons = wParam; <br>    myglobs.mouse_x = LOWORD(lParam); <br>    myglobs.mouse_y = HIWORD(lParam); <br>    break; <br>        case WM_ENTERMENULOOP: <br>            AppPause(TRUE); <br>            break; <br>        case WM_EXITMENULOOP: <br>            AppPause(FALSE); <br>            break; <br>    case WM_DESTROY: <br>            myglobs.hWndMain = NULL; <br>            CleanUpAndPostQuit(); <br>            break; <br>        case WM_INITMENUPOPUP: <br>    /* <br>             * Check and enable the appropriate menu items <br>     */ <br>            CheckMenuItem((HMENU)wParam, MENU_STEP, (myglobs.bSingleStepMode) ? MF_CHECKED : MF_UNCHECKED); <br>            EnableMenuItem((HMENU)wParam, MENU_GO, (myglobs.bSingleStepMode) ? MF_ENABLED : MF_GRAYED); <br>    EnableMenuItem((HMENU)wParam, MENU_PHONG, MF_GRAYED); <br>    if (!myglobs.bConstRenderQuality) { <br>CheckMenuItem((HMENU)wParam, MENU_LIGHTING, (myglobs.RenderQuality &amp; D3DRMLIGHT_MASK) == D3DRMLIGHT_ON ? MF_CHECKED : MF_GRAYED); <br>CheckMenuItem((HMENU)wParam, MENU_FLAT, (myglobs.RenderQuality &amp; D3DRMSHADE_MASK) == D3DRMSHADE_FLAT ? MF_CHECKED : MF_UNCHECKED); <br>CheckMenuItem((HMENU)wParam, MENU_GOURAUD, (myglobs.RenderQuality &amp; D3DRMSHADE_MASK) == D3DRMSHADE_GOURAUD ? MF_CHECKED : MF_UNCHECKED); <br>CheckMenuItem((HMENU)wParam, MENU_PHONG, (myglobs.RenderQuality &amp; D3DRMSHADE_MASK) == D3DRMSHADE_PHONG ? MF_CHECKED : MF_UNCHECKED); <br>EnableMenuItem((HMENU)wParam, MENU_PHONG, MF_GRAYED); <br>CheckMenuItem((HMENU)wParam, MENU_POINT, (myglobs.RenderQuality &amp; D3DRMFILL_MASK) == D3DRMFILL_POINTS ? MF_CHECKED : MF_UNCHECKED); <br>CheckMenuItem((HMENU)wParam, MENU_WIREFRAME, (myglobs.RenderQuality &amp; D3DRMFILL_MASK) == D3DRMFILL_WIREFRAME ? MF_CHECKED : MF_UNCHECKED); <br>CheckMenuItem((HMENU)wParam, MENU_SOLID, (myglobs.RenderQuality &amp; D3DRMFILL_MASK) == D3DRMFILL_SOLID ? MF_CHECKED : MF_UNCHECKED); <br>    } else { <br>EnableMenuItem((HMENU)wParam, MENU_LIGHTING, MF_GRAYED); <br>EnableMenuItem((HMENU)wParam, MENU_FLAT, MF_GRAYED); <br>EnableMenuItem((HMENU)wParam, MENU_GOURAUD, MF_GRAYED); <br>EnableMenuItem((HMENU)wParam, MENU_PHONG, MF_GRAYED); <br>EnableMenuItem((HMENU)wParam, MENU_POINT, MF_GRAYED); <br>EnableMenuItem((HMENU)wParam, MENU_WIREFRAME, MF_GRAYED); <br>EnableMenuItem((HMENU)wParam, MENU_SOLID, MF_GRAYED); <br>    } <br>            if (!myglobs.bNoTextures &amp;&amp; d3dapp-&gt;ThisDriver.bDoesTextures) { <br>CheckMenuItem((HMENU)wParam, MENU_POINT_FILTER, (myglobs.TextureQuality == D3DRMTEXTURE_NEAREST) ? MF_CHECKED : MF_UNCHECKED); <br>CheckMenuItem((HMENU)wParam, MENU_LINEAR_FILTER, (myglobs.TextureQuality == D3DRMTEXTURE_LINEAR) ? MF_CHECKED : MF_UNCHECKED); <br>    } else { <br>EnableMenuItem((HMENU)wParam, MENU_POINT_FILTER, MF_GRAYED); <br>EnableMenuItem((HMENU)wParam, MENU_LINEAR_FILTER, MF_GRAYED); <br>    } <br>            CheckMenuItem((HMENU)wParam, MENU_DITHERING, (myglobs.bDithering) ? MF_CHECKED : MF_UNCHECKED); <br>            CheckMenuItem((HMENU)wParam, MENU_ANTIALIAS, (myglobs.bAntialiasing) ? MF_CHECKED : MF_UNCHECKED); <br>            EnableMenuItem((HMENU)wParam, MENU_ANTIALIAS, MF_GRAYED); <br>    if (d3dapp-&gt;bIsPrimary) { <br>CheckMenuItem((HMENU)wParam, MENU_FULLSCREEN, d3dapp-&gt;bFullscreen ? MF_CHECKED : MF_UNCHECKED); <br>EnableMenuItem((HMENU)wParam, MENU_FULLSCREEN, d3dapp-&gt;bFullscreen &amp;&amp; !d3dapp-&gt;ThisDriver.bCanDoWindow ? MF_GRAYED : MF_ENABLED); <br>EnableMenuItem((HMENU)wParam, MENU_NEXT_MODE, (!d3dapp-&gt;bFullscreen) ? MF_GRAYED : MF_ENABLED); <br>EnableMenuItem((HMENU)wParam, MENU_PREVIOUS_MODE, (!d3dapp-&gt;bFullscreen) ? MF_GRAYED : MF_ENABLED); <br>    } else { <br>EnableMenuItem((HMENU)wParam, MENU_FULLSCREEN, MF_GRAYED); <br>EnableMenuItem((HMENU)wParam, MENU_NEXT_MODE, MF_GRAYED); <br>EnableMenuItem((HMENU)wParam, MENU_PREVIOUS_MODE, MF_GRAYED); <br>    } <br>    for (i = 0; i &lt; d3dapp-&gt;NumModes; i++) { <br>CheckMenuItem((HMENU)wParam, MENU_FIRST_MODE + i, (i == d3dapp-&gt;CurrMode) ? MF_CHECKED : MF_UNCHECKED); <br>EnableMenuItem((HMENU)wParam, MENU_FIRST_MODE + i, (d3dapp-&gt;Mode[i].bThisDriverCanDo) ? MF_ENABLED : MF_GRAYED); <br>    } <br>            for (i = 0; i &lt; d3dapp-&gt;NumDrivers; i++) { <br>                CheckMenuItem((HMENU)wParam, MENU_FIRST_DRIVER + i, (i == d3dapp-&gt;CurrDriver) ? MF_CHECKED : MF_UNCHECKED); <br>            } <br>            break; <br>        case WM_COMMAND: <br>            switch(LOWORD(wParam)) { <br>                case MENU_ABOUT: <br>                    AppPause(TRUE); <br>                    DialogBox(myglobs.hInstApp, "AppAbout", myglobs.hWndMain, (DLGPROC)AppAbout); <br>                    AppPause(FALSE); <br>                    break; <br>                case MENU_EXIT: <br>            CleanUpAndPostQuit(); <br>            break; <br>                case MENU_STEP: <br>    /* <br>     * Begin single step more or draw a frame if in single <br>     * step mode <br>     */ <br>                    if (!myglobs.bSingleStepMode) { <br>                        myglobs.bSingleStepMode = TRUE; <br>                        myglobs.bDrawAFrame = TRUE; <br>                    } else if (!myglobs.bDrawAFrame) { <br>                        myglobs.bDrawAFrame = TRUE; <br>                    } <br>                    break; <br>                case MENU_GO: <br>    /* <br>     * Exit single step mode <br>     */ <br>                    if (myglobs.bSingleStepMode) { <br>                        myglobs.bSingleStepMode = FALSE; <br>                        ResetFrameRate(); <br>                    } <br>                    break; <br>                case MENU_STATS: <br>    /* <br>     * Toggle output of frame rate and window info <br>     */ <br>                    if ((myglobs.bShowFrameRate) &amp;&amp; (myglobs.bShowInfo)) { <br>                        myglobs.bShowFrameRate = FALSE; <br>                        myglobs.bShowInfo = FALSE; <br>                        break; <br>                    } <br>                    if ((!myglobs.bShowFrameRate) &amp;&amp; (!myglobs.bShowInfo)) { <br>                        myglobs.bShowFrameRate = TRUE; <br>                        break; <br>                    } <br>                    myglobs.bShowInfo = TRUE; <br>                    break; <br>        case MENU_FULLSCREEN: <br>    if (d3dapp-&gt;bFullscreen) { <br>/* <br> * Return to a windowed mode.  Let D3DApp decide which <br> * D3D driver to use in case this one cannot render to <br> * the Windows display depth <br> */ <br>if (!D3DAppWindow(D3DAPP_YOUDECIDE, D3DAPP_YOUDECIDE)) { <br>    ReportD3DAppError(); <br>    CleanUpAndPostQuit(); <br>    break; <br>} <br>    } else { <br>/* <br> * Enter the current fullscreen mode.  D3DApp may <br> * resort to another mode if this driver cannot do <br> * the currently selected mode. <br> */ <br>if (!D3DAppFullscreen(d3dapp-&gt;CurrMode)) { <br>    ReportD3DAppError(); <br>    CleanUpAndPostQuit(); <br>    break; <br>} <br>    } <br>                break; <br>/* <br> * Lighting toggle <br> */ <br>case MENU_LIGHTING: <br>    myglobs.RenderQuality ^= D3DRMLIGHT_ON; <br>    SetRenderState(); <br>    break; <br>/* <br> * Fill mode selection <br> */ <br>case MENU_POINT: <br>    myglobs.RenderQuality = (myglobs.RenderQuality &amp; ~D3DRMFILL_MASK) | D3DRMFILL_POINTS; <br>    SetRenderState(); <br>    break; <br>case MENU_WIREFRAME: <br>    myglobs.RenderQuality = (myglobs.RenderQuality &amp; ~D3DRMFILL_MASK) | D3DRMFILL_WIREFRAME; <br>    SetRenderState(); <br>    break; <br>case MENU_SOLID: <br>    myglobs.RenderQuality = (myglobs.RenderQuality &amp; ~D3DRMFILL_MASK) | D3DRMFILL_SOLID; <br>    SetRenderState(); <br>    break; <br>/* <br> * Shade mode selection <br> */ <br>case MENU_FLAT: <br>    myglobs.RenderQuality = (myglobs.RenderQuality &amp; ~D3DRMSHADE_MASK) | D3DRMSHADE_FLAT; <br>    SetRenderState(); <br>    break; <br>case MENU_GOURAUD: <br>    myglobs.RenderQuality = (myglobs.RenderQuality &amp; ~D3DRMSHADE_MASK) | D3DRMSHADE_GOURAUD; <br>    SetRenderState(); <br>    break; <br>case MENU_PHONG: <br>    myglobs.RenderQuality = (myglobs.RenderQuality &amp; ~D3DRMSHADE_MASK) | D3DRMSHADE_PHONG; <br>    SetRenderState(); <br>    break; <br> <br>case MENU_DITHERING: <br>    myglobs.bDithering = !myglobs.bDithering; <br>    SetRenderState(); <br>    break; <br>case MENU_ANTIALIAS: <br>    myglobs.bAntialiasing = !myglobs.bAntialiasing; <br>    SetRenderState(); <br>    break; <br>/* <br> * Texture filter selection <br> */ <br>case MENU_POINT_FILTER: <br>    if (myglobs.TextureQuality == D3DRMTEXTURE_NEAREST) <br>break; <br>    myglobs.TextureQuality = D3DRMTEXTURE_NEAREST; <br>    SetRenderState(); <br>    break; <br>case MENU_LINEAR_FILTER: <br>    if (myglobs.TextureQuality == D3DRMTEXTURE_LINEAR) <br>break; <br>    myglobs.TextureQuality = D3DRMTEXTURE_LINEAR; <br>    SetRenderState(); </code></pre>
<p>
</p>
<pre><code>break; <br>case MENU_NEXT_MODE: <br>    /* <br>     * Enter the next usable fullscreen mode <br>     */ <br>    i = d3dapp-&gt;CurrMode; <br>    do { <br>++i; <br>if (i &gt;= d3dapp-&gt;NumModes) <br>    i = 0; <br>if (!d3dapp-&gt;Mode[i].bThisDriverCanDo) <br>    continue; <br>else { <br>    if (!D3DAppFullscreen(i)) { <br>ReportD3DAppError(); <br>CleanUpAndPostQuit(); <br>    } <br>    break; <br>} <br>    } while(i != d3dapp-&gt;CurrMode); <br>    break; <br>case MENU_PREVIOUS_MODE: <br>    /* <br>     * Enter the previous usable fullscreen mode <br>     */ <br>    i = d3dapp-&gt;CurrMode; <br>    do { <br>--i; <br>if (i &lt; 0) <br>    i = d3dapp-&gt;NumModes - 1; <br>if (!d3dapp-&gt;Mode[i].bThisDriverCanDo) <br>    continue; <br>else { <br>    if (!D3DAppFullscreen(i)) { <br>ReportD3DAppError(); <br>CleanUpAndPostQuit(); <br>    } <br>    break; <br>} <br>    } while(i != d3dapp-&gt;CurrMode); <br>                    break; <br>            } <br>            if (   LOWORD(wParam) &gt;= MENU_FIRST_DRIVER <br>&amp;&amp; LOWORD(wParam) &lt; MENU_FIRST_DRIVER + D3DAPP_MAXD3DDRIVERS <br>&amp;&amp; d3dapp-&gt;CurrDriver != LOWORD(wParam) - MENU_FIRST_DRIVER) { <br>/* <br> * Change the D3D driver <br> */ <br>if (!D3DAppChangeDriver(LOWORD(wParam) - MENU_FIRST_DRIVER, <br>NULL)) { <br>    ReportD3DAppError(); <br>    CleanUpAndPostQuit(); <br>} <br>            } <br>            if (   LOWORD(wParam) &gt;= MENU_FIRST_MODE <br>&amp;&amp; LOWORD(wParam) &lt; MENU_FIRST_MODE+100) { <br>/* <br> * Switch to the selected fullscreen mode <br> */ <br>if (!D3DAppFullscreen(LOWORD(wParam) - MENU_FIRST_MODE)) { <br>    ReportD3DAppError(); <br>    CleanUpAndPostQuit(); <br>} <br>            } <br>            if (   LOWORD(wParam) &gt;= MENU_FIRST_DDDRIVER <br>&amp;&amp; LOWORD(wParam) &lt; MENU_FIRST_DDDRIVER + D3DAPP_MAXDDDRIVERS <br>&amp;&amp; myglobs.CurrDDDriver != LOWORD(wParam) - MENU_FIRST_DDDRIVER) { <br>/* <br> * Change the DD driver <br> */ <br>DestroyD3DApp(); <br>myglobs.CurrDDDriver = LOWORD(wParam) - MENU_FIRST_DDDRIVER; <br>SetWindowPos(myglobs.hWndMain, HWND_NOTOPMOST, 0, 0, START_WIN_SIZE, START_WIN_SIZE, SWP_NOMOVE | SWP_SHOWWINDOW); <br>if (!CreateD3DApp(myglobs.lpCmdLine)) <br>    return FALSE; <br>            } <br>    /* <br>     * Whenever we receive a command in single step mode, draw a frame <br>     */ <br>    if (myglobs.bSingleStepMode) <br>myglobs.bDrawAFrame = TRUE; <br>            return 0L; <br>    } <br>    return DefWindowProc(hWnd, message, wParam, lParam); <br>} <br> <br>/****************************************************************************/ <br>/*                          Additional Functions                            */ <br>/****************************************************************************/ <br>/* <br> * ReadMouse <br> * Returns the mouse status for interaction with sample code <br> */ <br>void <br>ReadMouse(int* b, int* x, int* y) <br>{ <br>    *b = myglobs.mouse_buttons; <br>    *x = myglobs.mouse_x; <br>    *y = myglobs.mouse_y; <br>} <br> <br>/* <br> * SetRenderState <br> * Set the render quality, dither toggle and shade info if any of them has <br> * changed <br> */ <br>BOOL <br>SetRenderState(void) <br>{ <br>    HRESULT rval; <br>    /* <br>     * Set the number of buffers so D3DRM can keep track of extents properly <br>     */ <br>    rval = myglobs.dev-&gt;SetBufferCount(d3dapp-&gt;bFullscreen &amp;&amp; <br>       d3dapp-&gt;bBackBufferInVideo ? 2 : 1); <br>    if (rval != D3DRM_OK) { <br>Msg("Setting the buffer count failed.\n%s", D3DAppErrorToString(rval)); <br>return FALSE; <br>    } <br>    /* <br>     * Set the render quality (light toggle, fill mode, shade mode) <br>     */ <br>    if (myglobs.dev-&gt;GetQuality() != myglobs.RenderQuality) { <br>rval = myglobs.dev-&gt;SetQuality(myglobs.RenderQuality); <br>if (rval != D3DRM_OK) { <br>    Msg("Setting the render quality failed.\n%s", <br>D3DAppErrorToString(rval)); <br>    return FALSE; <br>} <br>    } <br>    /* <br>     * Set dithering toggle <br>     */ <br>    if (myglobs.dev-&gt;GetDither() != myglobs.bDithering) { <br>rval = myglobs.dev-&gt;SetDither(myglobs.bDithering); <br>if (rval != D3DRM_OK) { <br>    Msg("Setting dither mode failed.\n%s", D3DAppErrorToString(rval)); <br>    return FALSE; <br>} <br>    } <br>    /* <br>     * Set the texture quality (point or linear filtering) <br>     */ <br>    if (myglobs.dev-&gt;GetTextureQuality() != myglobs.TextureQuality) { <br>rval = myglobs.dev-&gt;SetTextureQuality(myglobs.TextureQuality); <br>if (rval != D3DRM_OK) { <br>    Msg("Setting texture quality failed.\n%s", <br>D3DAppErrorToString(rval)); <br>    return FALSE; <br>} <br>    } <br>    /* <br>     * Set shade info based on current bits per pixel <br>     */ <br>    switch (d3dapp-&gt;ThisMode.bpp) { <br>case 1: <br>    if (FAILED(myglobs.dev-&gt;SetShades(4))) <br>goto shades_error; <br>    if (FAILED(lpD3DRM-&gt;SetDefaultTextureShades(4))) <br>goto shades_error; <br>    break; <br>case 16: <br>    if (FAILED(myglobs.dev-&gt;SetShades(32))) <br>goto shades_error; <br>    if (FAILED(lpD3DRM-&gt;SetDefaultTextureColors(64))) <br>goto shades_error; <br>    if (FAILED(lpD3DRM-&gt;SetDefaultTextureShades(32))) <br>goto shades_error; <br>    break; <br>case 24: <br>case 32: <br>    if (FAILED(myglobs.dev-&gt;SetShades(256))) <br>goto shades_error; <br>    if (FAILED(lpD3DRM-&gt;SetDefaultTextureColors(64))) <br>goto shades_error; <br>    if (FAILED(lpD3DRM-&gt;SetDefaultTextureShades(256))) <br>goto shades_error; <br>    break; <br>    } <br>    return TRUE; <br>shades_error: <br>    Msg("A failure occurred while setting color shade information.\n"); <br>    return FALSE; <br>} <br> <br>/****************************************************************************/ <br>/*          Initialization, error reporting and release functions.          */ <br>/****************************************************************************/ <br>/* <br> * InitGlobals <br> * Called once at program initialization to initialize global variables. <br> */ <br>static void <br>InitGlobals(void) <br>{ <br>    d3dapp = NULL; <br>    memset(&amp;myglobs, 0, sizeof(myglobs)); <br>    myglobs.bShowFrameRate = TRUE; <br>    myglobs.bShowInfo = TRUE; <br>    myglobs.RenderQuality = D3DRMLIGHT_ON | D3DRMFILL_SOLID | <br>    D3DRMSHADE_GOURAUD; <br>    myglobs.TextureQuality = D3DRMTEXTURE_NEAREST; <br>} <br> <br>/* <br> * CleanUpAndPostQuit <br> * Release all D3D objects, post a quit message and set the bQuit flag <br> */ <br>void <br>CleanUpAndPostQuit(void) <br>{ <br>    if (myglobs.bQuit) <br>return; <br>    if (!D3DAppDestroy()) <br>ReportD3DAppError(); <br>    RELEASE(myglobs.scene); <br>    RELEASE(myglobs.camera); <br>    RELEASE(lpD3DRM); <br>    myglobs.bQuit = TRUE; <br>    PostQuitMessage( 0 ); <br>} <br> <br>/* <br> * ReportD3DAppError <br> * Reports an error during a d3d app call. <br> */ <br>void <br>ReportD3DAppError(void) <br>{ <br>    Msg("%s", D3DAppLastErrorString()); <br>} <br> <br>/* Msg <br> * Message output for error notification. <br> */ <br>void __cdecl <br>Msg( LPSTR fmt, ... ) <br>{ <br>    char buff[256]; <br>    va_list args; <br>     <br>    va_start(args, fmt); <br>    wvsprintf(buff, fmt, args); <br>    va_end(args); <br>     <br>    lstrcat(buff, "\r\n"); <br>    AppPause(TRUE); <br>    if (d3dapp &amp;&amp; d3dapp-&gt;bFullscreen) <br>SetWindowPos(myglobs.hWndMain, HWND_NOTOPMOST, 0, 0, 0, 0, <br>     SWP_NOSIZE | SWP_NOMOVE); <br>    MessageBox( NULL, buff, "D3D Example Message", MB_OK ); <br>    if (d3dapp &amp;&amp; d3dapp-&gt;bFullscreen) <br>SetWindowPos(myglobs.hWndMain, HWND_TOPMOST, 0, 0, 0, 0, <br>     SWP_NOSIZE | SWP_NOMOVE); <br>    AppPause(FALSE); <br>} <br> <br>/* <br> * D3DRMErrorToString <br> * Allows the samples to return error strings. <br> */ <br>char* <br>D3DRMErrorToString(HRESULT error) <br>{ <br>    return D3DAppErrorToString(error); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
