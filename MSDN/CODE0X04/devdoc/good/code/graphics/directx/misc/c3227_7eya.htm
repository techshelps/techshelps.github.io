<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DDCALLS.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3232"></a>DDCALLS.C</h2>
<pre><code>/* <br> *  Copyright (C) 1995, 1996 Microsoft Corporation. All Rights Reserved. <br> * <br> *  File: ddcalls.c <br> * <br> *  Manages DirectDraw objects needed for rendering.  Part of D3DApp. <br> * <br> *  D3DApp is a collection of helper functions for Direct3D applications. <br> *  D3DApp consists of the following files: <br> *d3dapp.h    Main D3DApp header to be included by application <br> *      d3dappi.h   Internal header <br> *      d3dapp.c    D3DApp functions seen by application. <br> *      ddcalls.c   All calls to DirectDraw objects except textures <br> *      d3dcalls.c  All calls to Direct3D objects except textures <br> *      texture.c   Texture loading and managing texture list <br> *      misc.c    Miscellaneous calls <br> */ <br> <br>#include "d3dappi.h" <br> <br>/***************************************************************************/ <br>/*                         Direct Draw Enumeration                         */ <br>/***************************************************************************/ <br> <br>typedef struct { <br>    D3DAppDDDriver* driver; <br>    int    numdriver; <br>} DDEnumCallbackContext; <br> <br>/* <br> * D3DAppIDDEnumCallback <br> * Callback function used during enumeration of DirectDraw drivers. <br> */ <br>BOOL FAR PASCAL D3DAppIDDEnumCallback(GUID FAR* lpGUID, LPSTR lpDriverDesc, LPSTR lpDriverName, LPVOID lpContext) <br>{ <br>    LPDIRECTDRAW lpDD; <br>    DDCAPS DriverCaps, HELCaps; <br>    DDEnumCallbackContext *context = (DDEnumCallbackContext*)lpContext; <br>    D3DAppDDDriver* driver = &amp;context-&gt;driver[context-&gt;numdriver]; <br> <br>    /* <br>     * Create the DirectDraw device using this driver.  If it fails, <br>     * just move on to the next driver. <br>     */ <br>    if (FAILED(DirectDrawCreate(lpGUID, &amp;lpDD, NULL))) { <br>return DDENUMRET_OK; <br>    } <br>    /* <br>     * Get the capabilities of this DirectDraw driver.  If it fails, <br>     * just move on to the next driver. <br>     */ <br>    memset(&amp;DriverCaps, 0, sizeof(DDCAPS)); <br>    DriverCaps.dwSize = sizeof(DDCAPS); <br>    memset(&amp;HELCaps, 0, sizeof(DDCAPS)); <br>    HELCaps.dwSize = sizeof(DDCAPS); <br>    if (FAILED(lpDD-&gt;lpVtbl-&gt;GetCaps(lpDD, &amp;DriverCaps, &amp;HELCaps))) { <br>lpDD-&gt;lpVtbl-&gt;Release(lpDD); <br>return DDENUMRET_OK; <br>    } <br>    if (lpGUID &amp;&amp; (DriverCaps.dwCaps &amp; DDCAPS_3D)) { <br>/* <br> * We have found a secondary 3d hardware device.  Return the DD object <br> * and stop enumeration. <br> */ <br>memcpy(&amp;driver-&gt;Guid, lpGUID, sizeof(GUID)); <br>memcpy(&amp;driver-&gt;HWCaps, &amp;DriverCaps, sizeof(DDCAPS)); <br>lstrcpy(driver-&gt;Name, lpDriverName); <br>driver-&gt;bIsPrimary = FALSE; <br>context-&gt;numdriver++; <br>    } else { <br>/* <br> * It's the primary, fill in some fields. <br> */ <br>memset(&amp;driver-&gt;Guid, 0, sizeof(GUID)); <br>memcpy(&amp;driver-&gt;HWCaps, &amp;DriverCaps, sizeof(DDCAPS)); <br>lstrcpy(driver-&gt;Name, "Primary Device"); <br>driver-&gt;bIsPrimary = TRUE; <br>context-&gt;numdriver++; <br>    } <br>    lpDD-&gt;lpVtbl-&gt;Release(lpDD); <br>    if (context-&gt;numdriver &gt;= D3DAPP_MAXDDDRIVERS) <br>return DDENUMRET_CANCEL; <br>    else <br>        return DDENUMRET_OK; <br>} <br> <br>/* <br> * D3DAppIEnumDDDevices <br> * Enumerate all 3D capable devices and the primary display, filling in <br> * the driver information variables.  lpDriver must point to a region <br> * with enough room for the maximum DD drivers. <br> */ <br>BOOL <br>D3DAppIEnumDDDevices(int* NumDriver, D3DAppDDDriver* lpDriver) <br>{ <br>    DDEnumCallbackContext context; <br> <br>    context.numdriver = 0; <br>    context.driver = lpDriver; <br>    LastError = DirectDrawEnumerate(D3DAppIDDEnumCallback, &amp;context); <br>    if (LastError != DD_OK) { <br>D3DAppISetErrorString("DirectDrawEnumerate failed.\n%s", <br>      D3DAppErrorToString(LastError)); <br>return FALSE; <br>    } <br>    *NumDriver = context.numdriver; <br>    return TRUE; <br>} <br> <br>/***************************************************************************/ <br>/*                         Direct Draw Creation                            */ <br>/***************************************************************************/ <br> <br>/* <br> * D3DAppICreateDD <br> * Creates the DirectDraw device and saves the current palette. <br> * It is assumed that a 3D capable secondary DD driver is not the <br> * primary device and hence cannot operate in a window (ie it's a <br> * fullscreen only device displaying on a second monitor).  Valid flags: <br> *     D3DAPP_ONLYDDEMULATION    Always use the DirectDraw HEL <br> */ <br>BOOL <br>D3DAppICreateDD(DWORD flags, LPGUID lpGuid) <br>{ <br>    HDC hdc; <br>    int i; <br>    LPDIRECTDRAW lpDD = NULL; <br> <br>    if (flags &amp; D3DAPP_ONLYDDEMULATION) <br>lpGuid = NULL; <br> <br>    if (!lpGuid) <br>d3dappi.bIsPrimary = TRUE; <br>    else <br>d3dappi.bIsPrimary = FALSE; <br> <br>    LastError = DirectDrawCreate(lpGuid, &amp;d3dappi.lpDD, NULL); <br>    if (LastError != DD_OK) { <br>D3DAppISetErrorString("DirectDrawCreate failed.\n%s", <br>      D3DAppErrorToString(LastError)); <br>return FALSE; <br>    } <br>    /* <br>     * Save the original palette for when we are paused.  Just in case we <br>     * start in a fullscreen mode, put them in ppe. <br>     */ <br>    hdc = GetDC(NULL); <br>    GetSystemPaletteEntries(hdc, 0, (1 &lt;&lt; 8), <br>    (LPPALETTEENTRY)(&amp;Originalppe[0])); <br>    for (i = 0; i &lt; 256; i++) <br>        ppe[i] = Originalppe[i]; <br>    ReleaseDC(NULL, hdc); <br>    return TRUE; <br>} <br> <br>/***************************************************************************/ <br>/*                   Enumerating the display modes                         */ <br>/***************************************************************************/ <br>/* <br> * EnumDisplayModesCallback <br> * Callback to save the display mode information. <br> */ <br>static HRESULT <br>CALLBACK EnumDisplayModesCallback(LPDDSURFACEDESC pddsd, LPVOID lpContext) <br>{ <br>    /* <br>     * Very large resolutions cause problems on some hardware.  They are also <br>     * not very useful for real-time rendering.  We have chosen to disable <br>     * them by not reporting them as available. <br>     */ <br>    if (pddsd-&gt;dwWidth &gt; 1024 || pddsd-&gt;dwHeight &gt; 768) <br>return DDENUMRET_OK; <br>    /* <br>     * Save this mode at the end of the mode array and increment mode count <br>     */ <br>    d3dappi.Mode[d3dappi.NumModes].w = pddsd-&gt;dwWidth; <br>    d3dappi.Mode[d3dappi.NumModes].h = pddsd-&gt;dwHeight; <br>    d3dappi.Mode[d3dappi.NumModes].bpp = pddsd-&gt;ddpfPixelFormat.dwRGBBitCount; <br>    d3dappi.Mode[d3dappi.NumModes].bThisDriverCanDo = FALSE; <br>    d3dappi.NumModes++; <br>    if (d3dappi.NumModes == D3DAPP_MAXMODES) <br>return DDENUMRET_CANCEL; <br>    else <br>return DDENUMRET_OK; <br>} <br> <br>/* <br> * CompareModes <br> * Compare two display modes during sorting.  Modes are sorted by depth and <br> * then resolution. <br> */ <br>static int <br>_cdecl CompareModes(const void* element1, const void* element2) { <br>    D3DAppMode *lpMode1, *lpMode2; <br> <br>    lpMode1 = (D3DAppMode*)element1; <br>    lpMode2 = (D3DAppMode*)element2; <br> <br>    if (lpMode1-&gt;bpp &gt; lpMode2-&gt;bpp) <br>        return -1; <br>    else if (lpMode2-&gt;bpp &gt; lpMode1-&gt;bpp) <br>        return 1; <br>    else if (lpMode1-&gt;w &gt; lpMode2-&gt;w) <br>        return -1; <br>    else if (lpMode2-&gt;w &gt; lpMode1-&gt;w) <br>        return 1; <br>    else if (lpMode1-&gt;h &gt; lpMode2-&gt;h) <br>        return -1; <br>    else if (lpMode2-&gt;h &gt; lpMode1-&gt;h) <br>        return 1; <br>    else <br>        return 0; <br>} <br> <br>/* <br> * EnumerateDisplayModes <br> * Generates the list of available display modes. <br> */ <br>BOOL <br>D3DAppIEnumDisplayModes(void) <br>{ <br>    int i; <br>    /* <br>     * Get a list of available display modes from DirectDraw <br>     */ <br>    d3dappi.NumModes = 0; <br>    LastError = d3dappi.lpDD-&gt;lpVtbl-&gt;EnumDisplayModes(d3dappi.lpDD, 0, NULL, <br>0, EnumDisplayModesCallback); <br>    if(LastError != DD_OK ) { <br>        D3DAppISetErrorString("EnumDisplayModes failed.\n%s", <br>      D3DAppErrorToString(LastError)); <br>d3dappi.NumModes = 0; <br>        return FALSE; <br>    } <br>    /* <br>     * Sort the list of display modes <br>     */ <br>    qsort((void *)&amp;d3dappi.Mode[0], (size_t)d3dappi.NumModes, sizeof(D3DAppMode), <br>          CompareModes); <br>    /* <br>     * Pick a default display mode.  640x480x16 is a very good mode for <br>     * rendering, so choose it over all others.  Otherwise, just take the <br>     * first one.  This selection may be overriden later if a driver is <br>     * created which cannot render in this mode. <br>     */ <br>    d3dappi.CurrMode = 0; <br>    for (i = 0; i &lt; d3dappi.NumModes; i++) { <br>if (d3dappi.Mode[i].w == 640 &amp;&amp; d3dappi.Mode[i].h == 480 &amp;&amp; <br>    d3dappi.Mode[i].bpp == 16) <br>    d3dappi.CurrMode = i; <br>    } <br>    memcpy(&amp;d3dappi.ThisMode, &amp;d3dappi.Mode[d3dappi.CurrMode], <br>   sizeof(D3DAppMode)); <br>    return TRUE; <br>} <br> <br>/***************************************************************************/ <br>/*               Creating Front and Back Buffers (and misc surf funcs)     */ <br>/***************************************************************************/ <br>/* <br> * D3DAppICreateSurface <br> * Create a DirectDraw Surface of the given description.  Using this function <br> * ensures that all surfaces end up in system memory if that option was set. <br> * Returns the result of the CreateSurface call. <br> */ <br>HRESULT <br>D3DAppICreateSurface(LPDDSURFACEDESC lpDDSurfDesc, <br>                LPDIRECTDRAWSURFACE FAR *lpDDSurface) { <br>    HRESULT result; <br>    if (d3dappi.bOnlySystemMemory) <br>        lpDDSurfDesc-&gt;ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY; <br>    result = d3dappi.lpDD-&gt;lpVtbl-&gt;CreateSurface(d3dappi.lpDD, lpDDSurfDesc, <br> lpDDSurface, NULL); <br>    return result; <br>} <br> <br>/* <br> * D3DAppIGetSurfDesc <br> * Get the description of the given surface.  Returns the result of the <br> * GetSurfaceDesc call. <br> */ <br>HRESULT <br>D3DAppIGetSurfDesc(LPDDSURFACEDESC lpDDSurfDesc,LPDIRECTDRAWSURFACE lpDDSurf) <br>{ <br>    HRESULT result; <br>    memset(lpDDSurfDesc, 0, sizeof(DDSURFACEDESC)); <br>    lpDDSurfDesc-&gt;dwSize = sizeof(DDSURFACEDESC); <br>    result = lpDDSurf-&gt;lpVtbl-&gt;GetSurfaceDesc(lpDDSurf, lpDDSurfDesc); <br>    return result; <br>} <br> <br>/* <br> * D3DAppICreateBuffers <br> * Creates the front and back buffers for the window or fullscreen case <br> * depending on the bFullscreen flag.  In the window case, bpp is ignored. <br> */ <br>BOOL <br>D3DAppICreateBuffers(HWND hwnd, int w, int h, int bpp, BOOL bFullscreen, BOOL bIsHardware) <br>{ <br>    DDSURFACEDESC ddsd; <br>    DDSCAPS ddscaps; <br> <br>    /* <br>     * Release any old objects that might be lying around.  This should have <br>     * already been taken care of, but just in case... <br>     */ <br>    RELEASE(lpClipper); <br>    RELEASE(d3dappi.lpBackBuffer); <br>    RELEASE(d3dappi.lpFrontBuffer); <br>    /* <br>     * The size of the buffers is going to be w x h, so record it now <br>     */ <br>    if (w &lt; D3DAPP_WINDOWMINIMUM) <br>w = D3DAPP_WINDOWMINIMUM; <br>    if (h &lt; D3DAPP_WINDOWMINIMUM) <br>h = D3DAPP_WINDOWMINIMUM; <br>    szBuffers.cx = w; <br>    szBuffers.cy = h; <br> <br>    if (bFullscreen) { <br>        /* <br>         * Create a complex flipping surface for fullscreen mode with one <br> * back buffer. <br>         */ <br>        memset(&amp;ddsd,0,sizeof(DDSURFACEDESC)); <br>ddsd.dwSize = sizeof( ddsd ); <br>    ddsd.dwFlags = DDSD_CAPS | DDSD_BACKBUFFERCOUNT; <br>    ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE | DDSCAPS_FLIP | <br>        DDSCAPS_3DDEVICE | DDSCAPS_COMPLEX; <br>    ddsd.dwBackBufferCount = 1; <br>if (bIsHardware) <br>    ddsd.ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY; <br>        LastError = D3DAppICreateSurface(&amp;ddsd, &amp;d3dappi.lpFrontBuffer); <br>    if(LastError != DD_OK) { <br>    if (LastError == DDERR_OUTOFMEMORY || LastError == DDERR_OUTOFVIDEOMEMORY) { <br>D3DAppISetErrorString("There was not enough video memory to create the rendering surface.\nPlease restart the program and try another fullscreen mode with less resolution or lower bit depth."); <br>    } else { <br>D3DAppISetErrorString("CreateSurface for fullscreen flipping surface failed.\n%s", <br>      D3DAppErrorToString(LastError)); <br>    } <br>            goto exit_with_error; <br>} <br>/*  <br> * Obtain a pointer to the back buffer surface created above so we <br> * can use it later.  For now, just check to see if it ended up in <br> * video memory (FYI). <br> */ <br>    ddscaps.dwCaps = DDSCAPS_BACKBUFFER; <br>    LastError = d3dappi.lpFrontBuffer-&gt;lpVtbl-&gt;GetAttachedSurface(d3dappi.lpFrontBuffer, &amp;ddscaps, &amp;d3dappi.lpBackBuffer); <br>    if(LastError != DD_OK) { <br>            D3DAppISetErrorString("GetAttachedSurface failed to get back buffer.\n%s", <br>  D3DAppErrorToString(LastError)); <br>            goto exit_with_error; <br>} <br>        LastError = D3DAppIGetSurfDesc(&amp;ddsd, d3dappi.lpBackBuffer); <br>if (LastError != DD_OK) { <br>    D3DAppISetErrorString("Failed to get surface description of back buffer.\n%s", <br>  D3DAppErrorToString(LastError)); <br>            goto exit_with_error; <br>} <br>        d3dappi.bBackBufferInVideo = <br>          (ddsd.ddsCaps.dwCaps &amp; DDSCAPS_VIDEOMEMORY) ? TRUE : FALSE; <br>    } <br>    else { <br>        /* <br>         * In the window case, create a front buffer which is the primary <br> * surface and a back buffer which is an offscreen plane surface. <br>         */ <br>        memset(&amp;ddsd,0,sizeof(DDSURFACEDESC)); <br>        ddsd.dwSize = sizeof(DDSURFACEDESC); <br>        ddsd.dwFlags = DDSD_CAPS; <br>        ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE; <br>/* <br> * If we specify system memory when creating a primary surface, we <br> * won't get the actual primary surface in video memory.  So, don't <br> * use D3DAppICreateSurface(). <br> */ <br>LastError = d3dappi.lpDD-&gt;lpVtbl-&gt;CreateSurface(d3dappi.lpDD, <br>&amp;ddsd, &amp;d3dappi.lpFrontBuffer, NULL); <br>        if(LastError != DD_OK ) { <br>    if (LastError == DDERR_OUTOFMEMORY || LastError == DDERR_OUTOFVIDEOMEMORY) { <br>D3DAppISetErrorString("There was not enough video memory to create the rendering surface.\nTo run this program in a window of this size, please adjust your display settings for a smaller desktop area or a lower palette size and restart the program."); <br>    } else { <br>D3DAppISetErrorString("CreateSurface for window front buffer failed.\n%s", <br>      D3DAppErrorToString(LastError)); <br>    } <br>            goto exit_with_error; <br>        } <br>    ddsd.dwFlags = DDSD_WIDTH | DDSD_HEIGHT | DDSD_CAPS; <br>    ddsd.dwWidth = w; <br>    ddsd.dwHeight = h; <br>    ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN | DDSCAPS_3DDEVICE; <br>if (bIsHardware) <br>    ddsd.ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY; <br>else <br>    ddsd.ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY; <br>        LastError = D3DAppICreateSurface(&amp;ddsd, &amp;d3dappi.lpBackBuffer); <br>    if (LastError != DD_OK) { <br>    if (LastError == DDERR_OUTOFMEMORY || LastError == DDERR_OUTOFVIDEOMEMORY) { <br>D3DAppISetErrorString("There was not enough video memory to create the rendering surface.\nTo run this program in a window of this size, please adjust your display settings for a smaller desktop area or a lower palette size and restart the program."); <br>    } else { <br>D3DAppISetErrorString("CreateSurface for window back buffer failed.\n%s", <br>      D3DAppErrorToString(LastError)); <br>    } <br>            goto exit_with_error; <br>} <br>/* <br> * Check to see if the back buffer is in video memory (FYI). <br> */ <br>LastError = D3DAppIGetSurfDesc(&amp;ddsd, d3dappi.lpBackBuffer); <br>if (LastError != DD_OK) { <br>    D3DAppISetErrorString("Failed to get surface description for back buffer.\n%s", <br>  D3DAppErrorToString(LastError)); <br>            goto exit_with_error; <br>} <br>d3dappi.bBackBufferInVideo = <br>          (ddsd.ddsCaps.dwCaps &amp; DDSCAPS_VIDEOMEMORY) ? TRUE : FALSE; <br>        /* <br>         * Create the DirectDraw Clipper object and attach it to the window <br> * and front buffer. <br>         */ <br>        LastError = d3dappi.lpDD-&gt;lpVtbl-&gt;CreateClipper(d3dappi.lpDD, 0, <br>&amp;lpClipper, NULL); <br>        if(LastError != DD_OK ) { <br>            D3DAppISetErrorString("CreateClipper failed.\n%s", <br>  D3DAppErrorToString(LastError)); <br>            goto exit_with_error; <br>} <br>    LastError = lpClipper-&gt;lpVtbl-&gt;SetHWnd(lpClipper, 0, hwnd); <br>        if(LastError != DD_OK ) { <br>            D3DAppISetErrorString("Attaching clipper to window failed.\n%s", <br>  D3DAppErrorToString(LastError)); <br>            goto exit_with_error; <br>} <br>    LastError = <br>     d3dappi.lpFrontBuffer-&gt;lpVtbl-&gt;SetClipper(d3dappi.lpFrontBuffer, <br>       lpClipper); <br>        if(LastError != DD_OK ) { <br>            D3DAppISetErrorString("Attaching clipper to front buffer failed.\n%s", <br>  D3DAppErrorToString(LastError)); <br>            goto exit_with_error; <br>} <br>    } <br> <br>    D3DAppIClearBuffers(); <br>    return TRUE; <br> <br>exit_with_error: <br>    RELEASE(d3dappi.lpFrontBuffer); <br>    RELEASE(d3dappi.lpBackBuffer); <br>    RELEASE(lpClipper); <br>    return FALSE; <br>} <br> <br>/* <br> * D3DAppICheckForPalettized <br> * If the front/back buffer is palettized, we need to create a palette. <br> */ <br>BOOL <br>D3DAppICheckForPalettized(void) <br>{ <br>    DDSURFACEDESC ddsd; <br>    /* <br>     * Get the back buffer surface description and check to see if it's <br>     * palettized <br>     */ <br>    LastError = D3DAppIGetSurfDesc(&amp;ddsd, d3dappi.lpBackBuffer); <br>    if (LastError != DD_OK) { <br>D3DAppISetErrorString("Failed to get surface description for back buffer for palettizing.\n%s", <br>      D3DAppErrorToString(LastError)); <br>        goto exit_with_error; <br>    } <br>    bPrimaryPalettized =  <br>(ddsd.ddpfPixelFormat.dwFlags &amp; DDPF_PALETTEINDEXED8) ? TRUE : FALSE; <br> <br>    if (bPrimaryPalettized) { <br>int i; <br>/* <br> * Get the current palette. <br> */ <br> HDC hdc = GetDC(NULL); <br>GetSystemPaletteEntries(hdc, 0, (1 &lt;&lt; 8), ppe); <br>ReleaseDC(NULL, hdc); <br>/* <br> * Change the flags on the palette entries to allow D3D to change <br> * some of them.  In the window case, we must not change the top and <br> * bottom ten (system colors), but in a fullscreen mode we can have <br> * all but the first and last. <br> */ <br>        if (!d3dappi.bFullscreen) { <br>    for (i = 0; i &lt; 10; i++) ppe[i].peFlags = D3DPAL_READONLY; <br>    for (i = 10; i &lt; 256 - 10; i++) ppe[i].peFlags = D3DPAL_FREE | PC_RESERVED; <br>    for (i = 256 - 10; i &lt; 256; i++) ppe[i].peFlags = D3DPAL_READONLY; <br>        } else { <br>    ppe[0].peFlags = D3DPAL_READONLY; <br>    for (i = 1; i &lt; 255; i++) ppe[i].peFlags = D3DPAL_FREE | PC_RESERVED; <br>    ppe[255].peFlags = D3DPAL_READONLY; <br>} <br>/* <br> * Create a palette using the old colors and new flags <br> */ <br>LastError = d3dappi.lpDD-&gt;lpVtbl-&gt;CreatePalette(d3dappi.lpDD, <br>   DDPCAPS_8BIT | DDPCAPS_INITIALIZE, <br>   ppe, &amp;lpPalette, NULL); <br>if (LastError != DD_OK) { <br>    D3DAppISetErrorString("CreatePalette failed.\n%s", <br>  D3DAppErrorToString(LastError)); <br>            goto exit_with_error; <br>} <br>/* <br> * Set this as the front and back buffers' palette <br> */ <br>LastError = <br>       d3dappi.lpBackBuffer-&gt;lpVtbl-&gt;SetPalette(d3dappi.lpBackBuffer, <br>        lpPalette); <br>        if(LastError != DD_OK ) { <br>            D3DAppISetErrorString("SetPalette failed on back buffer.\n%s", <br>  D3DAppErrorToString(LastError)); <br>            goto exit_with_error; <br>} <br>LastError = <br>     d3dappi.lpFrontBuffer-&gt;lpVtbl-&gt;SetPalette(d3dappi.lpFrontBuffer, <br>       lpPalette); <br>        if(LastError != DD_OK ) { <br>            D3DAppISetErrorString("SetPalette failed on front buffer.\n%s", <br>  D3DAppErrorToString(LastError)); <br>            goto exit_with_error; <br>} <br>/* <br> * The palette is now valid, so set it again on anyt WM_ACTIVATE <br> */ <br>bPaletteActivate = TRUE; <br>    } <br>    return TRUE; <br>exit_with_error: <br>    RELEASE(lpPalette); <br>    return FALSE; <br>} <br> <br>/***************************************************************************/ <br>/*                           Creation of Z-Buffer                          */ <br>/***************************************************************************/ <br>/* <br> * D3DAppICreateZBuffer <br> * Create a Z-Buffer of the appropriate depth and attach it to the back <br> * buffer. <br> */ <br>BOOL <br>D3DAppICreateZBuffer(int w, int h, int driver) <br>{ <br>    DDSURFACEDESC ddsd; <br>    DWORD devDepth; <br>    /* <br>     * Release any Z-Buffer that might be around just in case. <br>     */ <br>    RELEASE(d3dappi.lpZBuffer); <br>     <br>    /* <br>     * If this driver does not do z-buffering, don't create a z-buffer <br>     */ <br>    if (!d3dappi.Driver[driver].bDoesZBuffer) <br>return TRUE; <br> <br>    memset(&amp;ddsd, 0 ,sizeof(DDSURFACEDESC)); <br>    ddsd.dwSize = sizeof( ddsd ); <br>    ddsd.dwFlags = DDSD_WIDTH | DDSD_HEIGHT | DDSD_CAPS | <br>   DDSD_ZBUFFERBITDEPTH; <br>    ddsd.ddsCaps.dwCaps = DDSCAPS_ZBUFFER; <br>    ddsd.dwHeight = h; <br>    ddsd.dwWidth = w; <br>    /* <br>     * If this is a hardware D3D driver, the Z-Buffer MUST end up in video <br>     * memory.  Otherwise, it MUST end up in system memory. <br>     */ <br>    if (d3dappi.Driver[driver].bIsHardware) <br>ddsd.ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY; <br>    else <br>ddsd.ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY; <br>    /* <br>     * Get the Z buffer bit depth from this driver's D3D device description <br>     */ <br>    devDepth = d3dappi.Driver[driver].Desc.dwDeviceZBufferBitDepth; <br>    if (devDepth &amp; DDBD_32) <br>ddsd.dwZBufferBitDepth = 32; <br>    else if (devDepth &amp; DDBD_24) <br>ddsd.dwZBufferBitDepth = 24; <br>    else if (devDepth &amp; DDBD_16) <br>ddsd.dwZBufferBitDepth = 16; <br>    else if (devDepth &amp; DDBD_8) <br>ddsd.dwZBufferBitDepth = 8; <br>    else { <br>D3DAppISetErrorString("Unsupported Z-buffer depth requested by device.\n"); <br>return FALSE; <br>    } <br>    LastError = d3dappi.lpDD-&gt;lpVtbl-&gt;CreateSurface(d3dappi.lpDD, &amp;ddsd, <br>    &amp;d3dappi.lpZBuffer, <br>    NULL); <br>    if(LastError != DD_OK) { <br>if (LastError == DDERR_OUTOFMEMORY || LastError == DDERR_OUTOFVIDEOMEMORY) { <br>    if (d3dappi.bFullscreen) { <br>D3DAppISetErrorString("There was not enough video memory to create the Z-buffer surface.\nPlease restart the program and try another fullscreen mode with less resolution or lower bit depth."); <br>    } else { <br>D3DAppISetErrorString("There was not enough video memory to create the Z-buffer surface.\nTo run this program in a window of this size, please adjust your display settings for a smaller desktop area or a lower palette size and restart the program."); <br>    } <br>} else { <br>    D3DAppISetErrorString("CreateSurface for Z-buffer failed.\n%s", <br>  D3DAppErrorToString(LastError)); <br>} <br>        goto exit_with_error; <br>    } <br>    /* <br>     * Attach the Z-buffer to the back buffer so D3D will find it <br>     */ <br>    LastError = <br>       d3dappi.lpBackBuffer-&gt;lpVtbl-&gt;AddAttachedSurface(d3dappi.lpBackBuffer, <br>d3dappi.lpZBuffer); <br>    if(LastError != DD_OK) { <br>        D3DAppISetErrorString("AddAttachedBuffer failed for Z-Buffer.\n%s", <br>      D3DAppErrorToString(LastError)); <br>goto exit_with_error; <br>    } <br>    /* <br>     * Find out if it ended up in video memory. <br>     */ <br>    LastError = D3DAppIGetSurfDesc(&amp;ddsd, d3dappi.lpZBuffer); <br>    if (LastError != DD_OK) { <br>D3DAppISetErrorString("Failed to get surface description of Z buffer.\n%s", <br>      D3DAppErrorToString(LastError)); <br>        goto exit_with_error; <br>    } <br>    d3dappi.bZBufferInVideo = <br>          (ddsd.ddsCaps.dwCaps &amp; DDSCAPS_VIDEOMEMORY) ? TRUE : FALSE; <br>    if (d3dappi.Driver[driver].bIsHardware &amp;&amp; !d3dappi.bZBufferInVideo) { <br>D3DAppISetErrorString("Could not fit the Z-buffer in video memory for this hardware device.\n"); <br>goto exit_with_error; <br>    } <br> <br>    return TRUE; <br> <br>exit_with_error: <br>    RELEASE(d3dappi.lpZBuffer); <br>    return FALSE; <br>} <br> <br>/***************************************************************************/ <br>/*                             WM_SIZE Handler                             */ <br>/***************************************************************************/ <br>/* <br> * D3DAppIHandleWM_SIZE <br> * Processes the WM_SIZE message.  Resizes all the buffers and re-creates <br> * device if necessary. <br> */ <br>BOOL <br>D3DAppIHandleWM_SIZE(LRESULT* lresult, HWND hwnd, UINT message, <br>     WPARAM wParam, LPARAM lParam) <br>{ <br>    int w, h, i; <br>    /* <br>     * If we have minimzied, take note and call the default window proc <br>     */ <br>    if (wParam == SIZE_MINIMIZED) { <br>d3dappi.bMinimized = TRUE; <br>*lresult = DefWindowProc(hwnd, message, wParam, lParam); <br>return TRUE; <br>    } <br>    /* <br>     * In fullscreen mode, restore our surfaces and let DDraw take <br>     * care of the rest. <br>     */ <br>    if (d3dappi.bFullscreen) { <br>D3DAppIValidateDirtyRects(); <br>D3DAppCheckForLostSurfaces(); <br>d3dappi.bMinimized = FALSE; <br>*lresult = DefWindowProc(hwnd, message, wParam, lParam); <br>return TRUE; <br>    } <br>    /* <br>     * If we are minimized, this is the un-minimized size message. <br>     */ <br>    if (d3dappi.bMinimized) { <br>/* <br> * Restore our surfaces and update the dirty rectangle info <br> */ <br>D3DAppIValidateDirtyRects(); <br>D3DAppCheckForLostSurfaces(); <br>d3dappi.bMinimized = FALSE; <br>*lresult = DefWindowProc(hwnd, message, wParam, lParam); <br>return TRUE; <br>    } <br>    /* <br>     * Since we are still here, this must be a regular, window resize <br>     * message.  A new viewport will definitely be needed, but the <br>     * device and buffers will only be re-created if they have gotten bigger <br>     * or change size by a very large amount. <br>     */ <br>    D3DAppIGetClientWin(hwnd); <br>    w = LOWORD(lParam); <br>    h = HIWORD(lParam); <br>    /* <br>     * If w and h are under the minimum, create buffers of the minimum size <br>     */ <br>    if (w &lt; D3DAPP_WINDOWMINIMUM) <br>        w = D3DAPP_WINDOWMINIMUM; <br>    if (h &lt; D3DAPP_WINDOWMINIMUM) <br>        h = D3DAPP_WINDOWMINIMUM; <br>    /* <br>     * Destroy the viewport and all execute buffers <br>     */ <br>    d3dappi.bRenderingIsOK = FALSE; <br>    ATTEMPT(D3DAppICallDeviceDestroyCallback()); <br>    /* <br>     * Only create a new device and buffers if they changed significantly, <br>     * otherwise just make sure the old buffers aren't lost. <br>     */ <br>    if ((w &gt; szBuffers.cx || h &gt; szBuffers.cy) || <br>(w &lt; szBuffers.cx / 2 || h &lt; szBuffers.cy / 2)) { <br>/* <br> * Release the device <br> */ <br>RELEASE(d3dappi.lpD3DDevice); <br>/* <br> * Release the old buffers <br> */ <br>RELEASE(d3dappi.lpZBuffer); <br>RELEASE(lpPalette); <br>RELEASE(lpClipper); <br>RELEASE(d3dappi.lpBackBuffer); <br>RELEASE(d3dappi.lpFrontBuffer); <br>/* <br> * Create new ones <br> */ <br>ATTEMPT(D3DAppICreateBuffers(hwnd, w, h, D3DAPP_BOGUS, FALSE, d3dappi.ThisDriver.bIsHardware)); <br>ATTEMPT(D3DAppICheckForPalettized()); <br>ATTEMPT(D3DAppICreateZBuffer(w, h, d3dappi.CurrDriver)); <br>/* <br> * Create the driver <br> */ <br>ATTEMPT(D3DAppICreateDevice(d3dappi.CurrDriver)); <br>/* <br> * Since the driver did not change, the texture surfaces are still valid. <br> * We just need to get new handles. <br> */ <br>if (d3dappi.ThisDriver.bDoesTextures) { <br>    for (i = 0; i &lt; d3dappi.NumUsableTextures; i++) { <br>D3DAppIGetTextureHandle(i); <br>    } <br>} <br>    } else { <br>D3DAppCheckForLostSurfaces(); <br>    } <br>    /* <br>     * Call the device create callback to create the viewport, set the render <br>     * state and clear the dirty rectangle info <br>     */ <br>    ATTEMPT(D3DAppICallDeviceCreateCallback(w, h)); <br>    ATTEMPT(D3DAppISetRenderState()); <br>    D3DAppIValidateDirtyRects(); <br>    d3dappi.bRenderingIsOK = TRUE; <br>    /* <br>     * Call the default window proc <br>     */ <br>    *lresult = DefWindowProc(hwnd, message, wParam, lParam); <br>    return TRUE; <br>exit_with_error: <br>    D3DAppICallDeviceDestroyCallback(); <br>    RELEASE(d3dappi.lpD3DDevice); <br>    RELEASE(d3dappi.lpZBuffer); <br>    RELEASE(lpPalette); <br>    RELEASE(lpClipper); <br>    RELEASE(d3dappi.lpBackBuffer); <br>    RELEASE(d3dappi.lpFrontBuffer); <br>    return FALSE; <br>} <br> <br>/***************************************************************************/ <br>/*              Setting the display mode and cooperative level             */ <br>/***************************************************************************/ <br>/* <br> * D3DAppISetCoopLevel <br> * Set the cooperative level to exclusive mode for fullscreen and normal for <br> * a window.  Set the bIgnoreWM_SIZE flag because SetCooperativeLevel <br> * generates a WM_SIZE message you do not have to resize the buffers on. <br> */ <br>BOOL <br>D3DAppISetCoopLevel(HWND hwnd, BOOL bFullscreen) <br>{ <br>    if (bFullscreen) { <br>bIgnoreWM_SIZE = TRUE; <br>LastError = d3dappi.lpDD-&gt;lpVtbl-&gt;SetCooperativeLevel(d3dappi.lpDD, <br>   hwnd, DDSCL_EXCLUSIVE | DDSCL_FULLSCREEN); <br>bIgnoreWM_SIZE = FALSE; <br>if(LastError != DD_OK ) { <br>    D3DAppISetErrorString("SetCooperativeLevel to fullscreen failed.\n%s", <br>  D3DAppErrorToString(LastError)); <br>    return FALSE; <br>} <br>d3dappi.bFullscreen = TRUE; <br>    } else { <br>bIgnoreWM_SIZE = TRUE; <br>        LastError = d3dappi.lpDD-&gt;lpVtbl-&gt;SetCooperativeLevel(d3dappi.lpDD, <br> hwnd, DDSCL_NORMAL); <br>bIgnoreWM_SIZE = FALSE; <br>if(LastError != DD_OK ) { <br>            D3DAppISetErrorString("SetCooperativeLevel to normal failed.\n%s", <br>  D3DAppErrorToString(LastError)); <br>            return FALSE; <br>        } <br>d3dappi.bFullscreen = FALSE; <br>    } <br>    return TRUE; <br>} <br> <br>/* <br> * D3DAppISetDisplayMode <br> * Set the display mode to the given dimensions and bits per pixel.  The <br> * bIgnoreWM_SIZE message is set because the display change generates a <br> * WM_SIZE message which we don't want to resize the buffers on. <br> */ <br>BOOL <br>D3DAppISetDisplayMode(int w, int h, int bpp) <br>{ <br>    d3dappi.ThisMode.w = w; d3dappi.ThisMode.h = h; <br>    d3dappi.ThisMode.bpp = bpp; <br>    bIgnoreWM_SIZE = TRUE; <br>    LastError = d3dappi.lpDD-&gt;lpVtbl-&gt;SetDisplayMode(d3dappi.lpDD, w, h, <br>     bpp); <br>    bIgnoreWM_SIZE = FALSE; <br>    if(LastError != DD_OK ) { <br>        D3DAppISetErrorString("SetDisplayMode to %dx%dx%d failed\n%s", <br>      w, h, bpp, D3DAppErrorToString(LastError)); <br>        return FALSE; <br>    } <br>    return TRUE; <br>} <br> <br>/* <br> * D3DAppIRestoreDispMode <br> * Restores the display mode to the current windows display mode.  The <br> * bIgnoreWM_SIZE message is set because the display change generates a <br> * WM_SIZE message which we don't want to resize the buffers on. <br> */ <br>BOOL <br>D3DAppIRestoreDispMode(void) <br>{ <br>    bIgnoreWM_SIZE = TRUE; <br>    LastError = d3dappi.lpDD-&gt;lpVtbl-&gt;RestoreDisplayMode(d3dappi.lpDD); </code></pre>
<p>
</p>
<pre><code>if (LastError != DD_OK) { <br>D3DAppISetErrorString("RestoreDisplayMode failed.\n%s", <br>      D3DAppErrorToString(LastError)); <br>return FALSE; <br>    } <br>    bIgnoreWM_SIZE = FALSE; <br>    return TRUE; <br>} <br> <br>/* <br> * D3DAppRememberWindowsMode <br> * Record the current display mode in d3dappi.WindowsDisplay <br> */ <br>BOOL <br>D3DAppIRememberWindowsMode(void) <br>{ <br>    DDSURFACEDESC ddsd; <br> <br>    memset(&amp;ddsd, 0, sizeof(DDSURFACEDESC)); <br>    ddsd.dwSize = sizeof(DDSURFACEDESC); <br>    LastError = d3dappi.lpDD-&gt;lpVtbl-&gt;GetDisplayMode(d3dappi.lpDD, &amp;ddsd); <br>    if (LastError != DD_OK) { <br>D3DAppISetErrorString("Getting the current display mode failed.\n%s", <br>      D3DAppErrorToString(LastError)); <br>return FALSE; <br>    } <br>    d3dappi.WindowsDisplay.w = ddsd.dwWidth; <br>    d3dappi.WindowsDisplay.h = ddsd.dwHeight; <br>    d3dappi.WindowsDisplay.bpp = ddsd.ddpfPixelFormat.dwRGBBitCount; <br>    return TRUE; <br>} <br> <br>/***************************************************************************/ <br>/*                          Misc DD Utilities                              */ <br>/***************************************************************************/ <br> <br>/* <br> * D3DAppIClearBuffers <br> * Clear the front and back buffers to black <br> */ <br>BOOL <br>D3DAppIClearBuffers(void) <br>{ <br>    DDSURFACEDESC ddsd; <br>    RECT dst; <br>    DDBLTFX ddbltfx; <br>    /* <br>     * Find the width and height of the front buffer by getting its <br>     * DDSURFACEDESC <br>     */ <br>    if (d3dappi.lpFrontBuffer) { <br>LastError = D3DAppIGetSurfDesc(&amp;ddsd, d3dappi.lpFrontBuffer); <br>if (LastError != DD_OK) { <br>    D3DAppISetErrorString("Failure getting the surface description of the front buffer before clearing.\n%s", <br>  D3DAppErrorToString(LastError)); <br>    return FALSE; <br>} <br>/* <br> * Clear the front buffer to black <br> */ <br>memset(&amp;ddbltfx, 0, sizeof(ddbltfx)); <br>ddbltfx.dwSize = sizeof(DDBLTFX); <br>SetRect(&amp;dst, 0, 0, ddsd.dwWidth, ddsd.dwHeight); <br>LastError = d3dappi.lpFrontBuffer-&gt;lpVtbl-&gt;Blt(d3dappi.lpFrontBuffer, <br>    &amp;dst, NULL, NULL,  <br>    DDBLT_COLORFILL | DDBLT_WAIT, <br>    &amp;ddbltfx); <br>if (LastError != DD_OK) { <br>    D3DAppISetErrorString("Clearing the front buffer failed.\n%s", <br>  D3DAppErrorToString(LastError)); <br>    return FALSE; <br>} <br>    } <br>    if (d3dappi.lpBackBuffer) { <br>/* <br> * Find the width and height of the back buffer by getting its <br> * DDSURFACEDESC <br> */ <br>LastError = D3DAppIGetSurfDesc(&amp;ddsd, d3dappi.lpBackBuffer); <br>if (LastError != DD_OK) { <br>    D3DAppISetErrorString("Failure while getting the surface description of the back buffer before clearing.\n%s", <br>  D3DAppErrorToString(LastError)); <br>    return FALSE; <br>} <br>/* <br> * Clear the back buffer to black <br> */ <br>memset(&amp;ddbltfx, 0, sizeof(ddbltfx)); <br>ddbltfx.dwSize = sizeof(DDBLTFX); <br>SetRect(&amp;dst, 0, 0, ddsd.dwWidth, ddsd.dwHeight); <br>LastError = d3dappi.lpBackBuffer-&gt;lpVtbl-&gt;Blt(d3dappi.lpBackBuffer, &amp;dst, <br>     NULL, NULL, <br>     DDBLT_COLORFILL | DDBLT_WAIT, <br>     &amp;ddbltfx); <br>if (LastError != DD_OK) { <br>    D3DAppISetErrorString("Clearing the front buffer failed.\n%s", <br>  D3DAppErrorToString(LastError)); <br>    return FALSE; <br>} <br>    } <br>    return TRUE; <br>} <br> <br>/* <br> * D3DAppIBPPToDDBD <br> * Convert an integer bit per pixel number to a DirectDraw bit depth flag <br> */ <br>DWORD <br>D3DAppIBPPToDDBD(int bpp) <br>{ <br>    switch(bpp) { <br>case 1: <br>    return DDBD_1; <br>case 2: <br>    return DDBD_2; <br>case 4: <br>    return DDBD_4; <br>case 8: <br>    return DDBD_8; <br>case 16: <br>    return DDBD_16; <br>case 24: <br>    return DDBD_24; <br>case 32: <br>    return DDBD_32; <br>default: <br>    return (DWORD)D3DAPP_BOGUS; <br>    } <br>} <br> <br>/* <br> * D3DAppTotalVideoMemory <br> * Returns the amount of total video memory supported (not free) <br> */ <br>DWORD <br>D3DAppTotalVideoMemory(void) <br>{ <br>    DDCAPS DriverCaps, HELCaps; <br>    memset (&amp;DriverCaps, 0, sizeof(DDCAPS)); <br>    DriverCaps.dwSize = sizeof(DDCAPS); <br>    memset (&amp;HELCaps, 0, sizeof(DDCAPS)); <br>    HELCaps.dwSize = sizeof(DDCAPS); <br>    LastError = d3dappi.lpDD-&gt;lpVtbl-&gt;GetCaps(d3dappi.lpDD, &amp;DriverCaps, <br>      &amp;HELCaps); <br>    if (LastError != DD_OK) { <br>D3DAppISetErrorString("Getting DD capabilities failed while checking total video memory.\n%s", <br>      D3DAppErrorToString(LastError)); <br>return 0L; <br>    } <br>    if (DriverCaps.dwVidMemTotal) <br>return DriverCaps.dwVidMemTotal; <br>    else <br>return HELCaps.dwVidMemTotal; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
