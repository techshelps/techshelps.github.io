<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MULTIMON.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3245"></a>MULTIMON.H</h2>
<pre><code>#if !defined(_WIN32_WINNT) || (_WIN32_WINNT &lt; 0x0500) <br> <br>//============================================================================= <br>// <br>// MULTIMON <br>// stub module that fakes multiple monitor apis on pre Memphis Win32 OSes <br>// <br>// By using this header your code will work unchanged on Win95, <br>// you will get back default values from GetSystemMetrics() for new metrics <br>// and the new APIs will act like only one display is present. <br>// <br>// exactly one source must include this with COMPILE_MULTIMON_STUBS defined <br>// <br>//============================================================================= <br> <br>#ifdef __cplusplus <br>extern "C" {            /* Assume C declarations for C++ */ <br>#endif  /* __cplusplus */ <br> <br>// <br>// if we are building on Win95/NT4 headers we need to declare this stuff ourselves <br>// <br>#ifndef SM_CMONITORS <br> <br>#define SM_XVIRTUALSCREEN       76 <br>#define SM_YVIRTUALSCREEN       77 <br>#define SM_CXVIRTUALSCREEN      78 <br>#define SM_CYVIRTUALSCREEN      79 <br>#define SM_CMONITORS            80 <br>#define SM_SAMEDISPLAYFORMAT    81 <br> <br>DECLARE_HANDLE(HMONITOR); <br> <br>#define MONITOR_DEFAULTTONULL       0x00000000 <br>#define MONITOR_DEFAULTTOPRIMARY    0x00000001 <br>#define MONITOR_DEFAULTTONEAREST    0x00000002 <br> <br>#define MONITORINFOF_PRIMARY        0x00000001 <br> <br>typedef struct tagMONITORINFO <br>{ <br>    DWORD   cbSize; <br>    RECT    rcMonitor; <br>    RECT    rcWork; <br>    DWORD   dwFlags; <br>} MONITORINFO, *LPMONITORINFO; <br> <br>#define CCHDEVICENAME 32 <br> <br>#ifdef __cplusplus <br>typedef struct tagMONITORINFOEX : public tagMONITORINFO <br>{ <br>    TCHAR       szDevice[CCHDEVICENAME]; <br>} MONITORINFOEX, *LPMONITORINFOEX; <br>#else <br>typedef struct <br>{ <br>    MONITORINFO; <br>    TCHAR       szDevice[CCHDEVICENAME]; <br>} MONITORINFOEX, *LPMONITORINFOEX; <br>#endif <br> <br>typedef BOOL (CALLBACK* MONITORENUMPROC)(HMONITOR, HDC, LPRECT, LPARAM); <br> <br>#endif  // SM_CMONITORS <br> <br>#undef GetMonitorInfo <br>#undef GetSystemMetrics <br>#undef MonitorFromWindow <br>#undef MonitorFromRect <br>#undef MonitorFromPoint <br>#undef EnumDisplayMonitors <br> <br>// <br>// define this to compile the stubs <br>// otherwise you get the declarations <br>// <br>#ifdef COMPILE_MULTIMON_STUBS <br> <br>//----------------------------------------------------------------------------- <br>// <br>// Implement the API stubs. <br>// <br>//----------------------------------------------------------------------------- <br> <br>int      (WINAPI* g_pfnGetSystemMetrics)(int); <br>HMONITOR (WINAPI* g_pfnMonitorFromWindow)(HWND, BOOL); <br>HMONITOR (WINAPI* g_pfnMonitorFromRect)(LPCRECT, BOOL); <br>HMONITOR (WINAPI* g_pfnMonitorFromPoint)(POINT, BOOL); <br>BOOL     (WINAPI* g_pfnGetMonitorInfo)(HMONITOR, LPMONITORINFO); <br>BOOL     (WINAPI* g_pfnEnumDisplayMonitors)(HDC, LPCRECT, MONITORENUMPROC, LPARAM); <br> <br>BOOL InitMultipleMonitorStubs(void) <br>{ <br>    HMODULE hUser32; <br>    static BOOL fInitDone; <br> <br>    if (fInitDone) <br>    { <br>        return g_pfnGetMonitorInfo != NULL; <br>    } <br> <br>    if ((hUser32 = GetModuleHandle(TEXT("USER32"))) &amp;&amp; <br>        (*(FARPROC*)&amp;g_pfnGetSystemMetrics    = GetProcAddress(hUser32,"GetSystemMetrics")) &amp;&amp; <br>        (*(FARPROC*)&amp;g_pfnMonitorFromWindow   = GetProcAddress(hUser32,"MonitorFromWindow")) &amp;&amp; <br>        (*(FARPROC*)&amp;g_pfnMonitorFromRect     = GetProcAddress(hUser32,"MonitorFromRect")) &amp;&amp; <br>        (*(FARPROC*)&amp;g_pfnMonitorFromPoint    = GetProcAddress(hUser32,"MonitorFromPoint")) &amp;&amp; <br>        (*(FARPROC*)&amp;g_pfnEnumDisplayMonitors = GetProcAddress(hUser32,"EnumDisplayMonitors")) &amp;&amp; <br>#ifdef UNICODE <br>        (*(FARPROC*)&amp;g_pfnGetMonitorInfo      = GetProcAddress(hUser32,"GetMonitorInfoW")) &amp;&amp; <br>#else <br>        (*(FARPROC*)&amp;g_pfnGetMonitorInfo      = GetProcAddress(hUser32,"GetMonitorInfoA")) &amp;&amp; <br>#endif <br>        // <br>        // Old builds of Memphis had different indices for these metrics, and <br>        // some of the APIs and structs have changed since then, so validate that <br>        // the returned metrics are not totally stupid.  (for example on an old <br>        // Memphis build, the new index for SM_CYVIRTUALSCREEN will fetch 0) <br>        // <br>        // If this is preventing you from using the shell on secondary monitors <br>        // under Memphis then upgrade to a new Memphis build that is in sync with <br>        // the current version of the multi-monitor APIs. <br>        // <br>        (GetSystemMetrics(SM_CXVIRTUALSCREEN) &gt;= GetSystemMetrics(SM_CXSCREEN)) &amp;&amp; <br>        (GetSystemMetrics(SM_CYVIRTUALSCREEN) &gt;= GetSystemMetrics(SM_CYSCREEN)) ) <br>    { <br>        fInitDone = TRUE; <br>        return TRUE; <br>    } <br>    else <br>    { <br>        g_pfnGetSystemMetrics    = NULL; <br>        g_pfnMonitorFromWindow   = NULL; <br>        g_pfnMonitorFromRect     = NULL; <br>        g_pfnMonitorFromPoint    = NULL; <br>        g_pfnGetMonitorInfo      = NULL; <br>        g_pfnEnumDisplayMonitors = NULL; <br> <br>        fInitDone = TRUE; <br>        return FALSE; <br>    } <br>} <br> <br>//----------------------------------------------------------------------------- <br>// <br>// fake implementations of Monitor APIs that work with the primary display <br>// no special parameter validation is made since these run in client code <br>// <br>//----------------------------------------------------------------------------- <br> <br>int WINAPI <br>xGetSystemMetrics(int nIndex) <br>{ <br>    if (InitMultipleMonitorStubs()) <br>        return g_pfnGetSystemMetrics(nIndex); <br> <br>    switch (nIndex) <br>    { <br>    case SM_CMONITORS: <br>    case SM_SAMEDISPLAYFORMAT: <br>        return 1; <br> <br>    case SM_XVIRTUALSCREEN: <br>    case SM_YVIRTUALSCREEN: <br>        return 0; <br> <br>    case SM_CXVIRTUALSCREEN: <br>        nIndex = SM_CXSCREEN; <br>        break; <br> <br>    case SM_CYVIRTUALSCREEN: <br>        nIndex = SM_CYSCREEN; <br>        break; <br>    } <br> <br>    return GetSystemMetrics(nIndex); <br>} <br> <br>#define xPRIMARY_MONITOR ((HMONITOR)0x42) <br> <br>HMONITOR WINAPI <br>xMonitorFromRect(LPCRECT lprcScreenCoords, UINT uFlags) <br>{ <br>    if (InitMultipleMonitorStubs()) <br>        return g_pfnMonitorFromRect(lprcScreenCoords, uFlags); <br> <br>    if ((uFlags &amp; (MONITOR_DEFAULTTOPRIMARY | MONITOR_DEFAULTTONEAREST)) || <br>        ((lprcScreenCoords-&gt;right &gt; 0) &amp;&amp; <br>        (lprcScreenCoords-&gt;bottom &gt; 0) &amp;&amp; <br>        (lprcScreenCoords-&gt;left &lt; GetSystemMetrics(SM_CXSCREEN)) &amp;&amp; <br>        (lprcScreenCoords-&gt;top &lt; GetSystemMetrics(SM_CYSCREEN)))) <br>    { <br>        return xPRIMARY_MONITOR; <br>    } <br> <br>    return NULL; <br>} <br> <br>HMONITOR WINAPI <br>xMonitorFromPoint(POINT ptScreenCoords, UINT uFlags) <br>{ <br>    if (InitMultipleMonitorStubs()) <br>        return g_pfnMonitorFromPoint(ptScreenCoords, uFlags); <br> <br>    if ((uFlags &amp; (MONITOR_DEFAULTTOPRIMARY | MONITOR_DEFAULTTONEAREST)) || <br>        ((ptScreenCoords.x &gt;= 0) &amp;&amp; <br>        (ptScreenCoords.x &lt; GetSystemMetrics(SM_CXSCREEN)) &amp;&amp; <br>        (ptScreenCoords.y &gt;= 0) &amp;&amp; <br>        (ptScreenCoords.y &lt; GetSystemMetrics(SM_CYSCREEN)))) <br>    { <br>        return xPRIMARY_MONITOR; <br>    } <br> <br>    return NULL; <br>} <br> <br>HMONITOR WINAPI <br>xMonitorFromWindow(HWND hWnd, UINT uFlags) <br>{ <br>    RECT rc; <br> <br>    if (InitMultipleMonitorStubs()) <br>        return g_pfnMonitorFromWindow(hWnd, uFlags); <br> <br>    if (uFlags &amp; (MONITOR_DEFAULTTOPRIMARY | MONITOR_DEFAULTTONEAREST)) <br>        return xPRIMARY_MONITOR; <br> <br>    if (GetWindowRect(hWnd, &amp;rc)) <br>        return xMonitorFromRect(&amp;rc, uFlags); <br> <br>    return NULL; <br>} <br> <br>BOOL WINAPI <br>xGetMonitorInfo(HMONITOR hMonitor, LPMONITORINFO lpMonitorInfo) <br>{ <br>    RECT rcWork; <br> <br>    if (InitMultipleMonitorStubs()) <br>        return g_pfnGetMonitorInfo(hMonitor, lpMonitorInfo); <br> <br>    if ((hMonitor == xPRIMARY_MONITOR) &amp;&amp; lpMonitorInfo &amp;&amp; <br>        (lpMonitorInfo-&gt;cbSize &gt;= sizeof(MONITORINFO)) &amp;&amp; <br>        SystemParametersInfo(SPI_GETWORKAREA, 0, &amp;rcWork, 0)) <br>    { <br>        lpMonitorInfo-&gt;rcMonitor.left = 0; <br>        lpMonitorInfo-&gt;rcMonitor.top  = 0; <br>        lpMonitorInfo-&gt;rcMonitor.right  = GetSystemMetrics(SM_CXSCREEN); <br>        lpMonitorInfo-&gt;rcMonitor.bottom = GetSystemMetrics(SM_CYSCREEN); <br>        lpMonitorInfo-&gt;rcWork = rcWork; <br>        lpMonitorInfo-&gt;dwFlags = MONITORINFOF_PRIMARY; <br> <br>        if (lpMonitorInfo-&gt;cbSize &gt;= sizeof(MONITORINFOEX)) <br>            lstrcpy(((MONITORINFOEX*)lpMonitorInfo)-&gt;szDevice, TEXT("DISPLAY")); <br> <br>        return TRUE; <br>    } <br> <br>    return FALSE; <br>} <br> <br>BOOL WINAPI <br>xEnumDisplayMonitors(HDC hdcOptionalForPainting, <br>    LPCRECT lprcEnumMonitorsThatIntersect, MONITORENUMPROC lpfnEnumProc, <br>    LPARAM lData) <br>{ <br>    RECT rcCallback, rcLimit; <br> <br>    if (InitMultipleMonitorStubs()) <br>        return g_pfnEnumDisplayMonitors(hdcOptionalForPainting, <br>            lprcEnumMonitorsThatIntersect, lpfnEnumProc, lData); <br>     <br>    if (!lpfnEnumProc) <br>        return FALSE; <br> <br>    rcLimit.left   = 0; <br>    rcLimit.top    = 0; <br>    rcLimit.right  = GetSystemMetrics(SM_CXSCREEN); <br>    rcLimit.bottom = GetSystemMetrics(SM_CYSCREEN); <br> <br>    if (hdcOptionalForPainting) <br>    { <br>        RECT rcClip; <br>        HWND hWnd; <br> <br>        if ((hWnd = WindowFromDC(hdcOptionalForPainting)) == NULL) <br>            return FALSE; <br> <br>        switch (GetClipBox(hdcOptionalForPainting, &amp;rcClip)) <br>        { <br>        default: <br>            MapWindowPoints(NULL, hWnd, (LPPOINT)&amp;rcLimit, 2); <br>            if (IntersectRect(&amp;rcCallback, &amp;rcClip, &amp;rcLimit)) <br>                break; <br>            //fall thru <br>        case NULLREGION: <br>             return TRUE; <br>        case ERROR: <br>             return FALSE; <br>        } <br> <br>        rcLimit = rcCallback; <br>    } <br> <br>    if (!lprcEnumMonitorsThatIntersect || <br>        IntersectRect(&amp;rcCallback, lprcEnumMonitorsThatIntersect, &amp;rcLimit)) <br>    { <br>        lpfnEnumProc(xPRIMARY_MONITOR, hdcOptionalForPainting, &amp;rcCallback, <br>            lData); <br>    } <br> <br>    return TRUE; <br>} <br> <br>#undef xPRIMARY_MONITOR <br>#undef COMPILE_MULTIMON_STUBS <br> <br>#else// COMPILE_MULTIMON_STUBS <br> <br>extern intWINAPI xGetSystemMetrics(int); <br>extern HMONITOR WINAPI xMonitorFromWindow(HWND, UINT); <br>extern HMONITOR WINAPI xMonitorFromRect(LPCRECT, UINT); <br>extern HMONITOR WINAPI xMonitorFromPoint(POINT, UINT); <br>extern BOOLWINAPI xGetMonitorInfo(HMONITOR, LPMONITORINFO); <br>extern BOOLWINAPI xEnumDisplayMonitors(HDC, LPCRECT, MONITORENUMPROC, LPARAM); <br> <br>#endif// COMPILE_MULTIMON_STUBS <br> <br>// <br>// build defines that replace the regular APIs with our versions <br>// <br>#define GetSystemMetrics    xGetSystemMetrics <br>#define MonitorFromWindow   xMonitorFromWindow <br>#define MonitorFromRect     xMonitorFromRect <br>#define MonitorFromPoint    xMonitorFromPoint <br>#define GetMonitorInfo      xGetMonitorInfo <br>#define EnumDisplayMonitors xEnumDisplayMonitors <br> <br>#ifdef __cplusplus <br>} <br>#endif/* __cplusplus */ <br> <br>#endif  /* !defined(_WIN32_WINNT) || (_WIN32_WINNT &lt; 0x0500) */ </code></pre>
<p>&nbsp;</p></body>
</HTML>
