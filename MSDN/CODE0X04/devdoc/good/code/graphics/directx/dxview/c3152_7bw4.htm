<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DXVIEW.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3154"></a>DXVIEW.C</h2>
<pre><code>/**************************************************************************** <br> <br>    Copyright (C) 1995-1997 Microsoft Corporation. All Rights Reserved. <br> <br>    PROGRAM: dxview.c <br> <br>    PURPOSE: DirectX Device Viewer <br> <br>    FUNCTIONS: <br> <br>    COMMENTS: <br> <br>****************************************************************************/ <br> <br>#include "dxview.h" <br> <br>#pragma comment(lib, "dxguid") <br>#pragma comment(lib, "ddraw") <br>#pragma comment(lib, "dsound") <br>#pragma comment(lib, "dplayx") <br>#pragma comment(lib, "dinput") <br>#pragma comment(lib, "comctl32") <br> <br>/**************************************************************************** <br> ***************************************************************************/ <br> <br>HINSTANCE   g_hInstance; <br>char        g_szAppName[]   = "DXView"; <br>char        g_szClassName[] = "DXView"; <br>char        g_szTitle[]     = "DirectX Device Viewer"; <br>HWND        g_hwndMain; <br> <br>HWND        g_hwndLV;        // List view <br>HWND        g_hwndTV;        // Tree view <br>HIMAGELIST  g_hImageList; <br>HFONT       g_hFont; <br>int         g_xPaneSplit; <br>int         g_xHalfSplitWidth; <br>BOOL        g_bSplitMove; <br>DWORD       g_dwViewState; <br>DWORD       g_tmAveCharWidth; <br>extern BOOL g_PrintToFile; <br>UINTg_idTimer; <br>LPLOCALAPPg_lpLocalApp; <br> <br>HINSTANCE g_hDSoundLib = NULL; <br> <br>typedef HRESULT (WINAPI * PFN_DSCREATE)(LPGUID lpguid, LPDIRECTSOUND * ppDS, IUnknown FAR * pUnkOuter); <br>typedef BOOL (WINAPI * PFN_DSENUMERATE)(LPDSENUMCALLBACK lpDSEnumCallback, LPVOID lpContext); <br>typedef HRESULT (WINAPI * PFN_DSCCREATE)(LPGUID lpGUID,LPDIRECTSOUNDCAPTURE *lplpDSC,LPUNKNOWN pUnkOuter); <br>typedef BOOL (WINAPI * PFN_DSCENUMERATE)(LPDSENUMCALLBACK lpDSEnumCallback,LPVOID lpContext); <br> <br>/**************************************************************************** <br> ***************************************************************************/ <br> <br>IDirectDraw *lpDD;                  // DirectDraw object <br>IDirectDraw2 *lpDD2;                // DirectDraw object <br>IDirect3D2  *lp3D;                  // Direct3D object <br>GUID *       ddid; <br> <br>IDirectSound *lpDS;                 // DirectSound object <br>GUID *       dsid; <br> <br>IDirectSoundCapture *lpDSC;         // DirectSoundCapture object <br>GUID *       dscid; <br> <br>IDirectPlay3A  *lpDP3A;             // DirectPlay object <br>GUID *       dpid; <br> <br>/**************************************************************************** <br> ***************************************************************************/ <br> <br>#define DDCAPDEF(name,val,flag) {name, FIELD_OFFSET(DDCAPS,val), flag} <br>#define DDVALDEF(name,val)      {name, FIELD_OFFSET(DDCAPS,val), 0} <br>#define DDHEXDEF(name,val)      {name, FIELD_OFFSET(DDCAPS,val), 0xFFFFFFFF} <br>#define ROPDEF(name,dwRops,rop) DDCAPDEF(name,dwRops[((rop&gt;&gt;16)&amp;0xFF)/32],(1&lt;&lt;((rop&gt;&gt;16)&amp;0xFF)%32)) <br> <br>#define DSCAPDEF(name,val,flag) {name, FIELD_OFFSET(DSCAPS,val), flag} <br>#define DSVALDEF(name,val)      {name, FIELD_OFFSET(DSCAPS,val), 0} <br> <br>#define DSCCAPDEF(name,val,flag) {name, FIELD_OFFSET(DSCCAPS,val), flag} <br>#define DSCVALDEF(name,val)      {name, FIELD_OFFSET(DSCCAPS,val), 0} <br> <br>#define DPCAPDEF(name,val,flag) {name, FIELD_OFFSET(DPCAPS,val), flag} <br>#define DPHEXDEF(name,val)      {name, FIELD_OFFSET(DPCAPS,val), 0xFFFFFFFF} <br>#define DPVALDEF(name,val)      {name, FIELD_OFFSET(DPCAPS,val), 0} <br> <br>#define D3CAPDEF(name,val,flag) {name, FIELD_OFFSET(D3DDEVICEDESC,val), flag} <br>#define D3HEXDEF(name,val)      {name, FIELD_OFFSET(D3DDEVICEDESC,val), 0xFFFFFFFF} <br>#define D3VALDEF(name,val)      {name, FIELD_OFFSET(D3DDEVICEDESC,val), 0} <br> <br>#define SURFCAPDEF(name,val,flag) {name, FIELD_OFFSET(DDSURFACEDESC,val), flag} <br>#define SURFVALDEF(name,val)      {name, FIELD_OFFSET(DDSURFACEDESC,val), 0} <br> <br>#define MAKEMODE(xres,yres,bpp) (((DWORD)xres &lt;&lt; 20) | ((DWORD)yres &lt;&lt; 8) | bpp) <br>#define GETXRES(mode)           (int)((mode &gt;&gt; 20) &amp; 0x0FFF) <br>#define GETYRES(mode)           (int)((mode &gt;&gt; 8)  &amp; 0x0FFF) <br>#define GETCRES(mode)           (int)((mode &gt;&gt; 0)  &amp; 0x00FF) <br> <br>IDirectDraw * DDCreate(GUID *pid); <br> <br>BOOL PrintValueLine(char * szText, DWORD dwValue, PRINTCBINFO *lpInfo) <br>{ <br>    char    szBuff[80]; <br>    DWORD cchLen; <br>    int xName, xVal, yLine; <br> <br>    // Calculate Name and Value column x offsets <br>    xName   = (lpInfo-&gt;dwCurrIndent * DEF_TAB_SIZE * lpInfo-&gt;dwCharWidth); <br>    xVal    = xName + (32 * lpInfo-&gt;dwCharWidth); <br>    yLine   = (lpInfo-&gt;dwCurrLine * lpInfo-&gt;dwLineHeight); <br> <br>    // Print name <br>    wsprintf (szBuff, szText); <br>    cchLen = _tcslen (szText); <br>    if (! PrintLine (xName, yLine, szBuff, cchLen, lpInfo)) <br>        return FALSE; <br> <br>    // Print value <br>    wsprintf (szBuff, "%d", dwValue); <br>    cchLen = _tcslen (szBuff); <br>    if (! PrintLine (xVal, yLine, szBuff, cchLen, lpInfo)) <br>        return FALSE; <br> <br>    // Advance to next line on page <br>    if (! PrintNextLine (lpInfo)) <br>        return FALSE; <br> <br>   return TRUE; <br>} <br> <br>VOID VidMem(long lParam1, long foo2) <br>{ <br>    HRESULT ddrval; <br>    DWORD dwTotalMem; <br>    DWORD dwFreeMem; <br>    DDSCAPS DDSCaps; <br> <br>    LVAddColumn(g_hwndLV, 0, "Type", 24); <br>    LVAddColumn(g_hwndLV, 1, "Total", 10); <br>    LVAddColumn(g_hwndLV, 2, "Free", 10); <br> <br>    if (DDCreate((GUID*)lParam1)) <br>    { <br>        IDirectDraw_QueryInterface(lpDD,&amp;IID_IDirectDraw2,&amp;lpDD2); <br> <br>        DDSCaps.dwCaps = DDSCAPS_VIDEOMEMORY; <br>        ddrval = IDirectDraw2_GetAvailableVidMem(lpDD2, &amp;DDSCaps, &amp;dwTotalMem, &amp;dwFreeMem ); <br>        if(ddrval != DD_OK) <br>        { <br>            dwTotalMem = 0; <br>            dwFreeMem = 0; <br>        }; <br>        LVAddText(g_hwndLV, 0, "Video"); <br>        LVAddText(g_hwndLV, 1, "%d", dwTotalMem); <br>        LVAddText(g_hwndLV, 2, "%d", dwFreeMem); <br> <br>        DDSCaps.dwCaps = DDSCAPS_LOCALVIDMEM; <br>        ddrval = IDirectDraw2_GetAvailableVidMem(lpDD2, &amp;DDSCaps, &amp;dwTotalMem, &amp;dwFreeMem ); <br>        if(ddrval != DD_OK) <br>        { <br>            dwTotalMem = 0; <br>            dwFreeMem = 0; <br>        }; <br>        LVAddText(g_hwndLV, 0, "Video (local)"); <br>        LVAddText(g_hwndLV, 1, "%d", dwTotalMem); <br>        LVAddText(g_hwndLV, 2, "%d", dwFreeMem); <br> <br>        DDSCaps.dwCaps = DDSCAPS_NONLOCALVIDMEM; <br>        ddrval = IDirectDraw2_GetAvailableVidMem(lpDD2, &amp;DDSCaps, &amp;dwTotalMem, &amp;dwFreeMem ); <br>        if(ddrval != DD_OK) <br>        { <br>            dwTotalMem = 0; <br>            dwFreeMem = 0; <br>        }; <br>        LVAddText(g_hwndLV, 0, "Video (non-local)"); <br>        LVAddText(g_hwndLV, 1, "%d", dwTotalMem); <br>        LVAddText(g_hwndLV, 2, "%d", dwFreeMem); <br> <br>        DDSCaps.dwCaps = DDSCAPS_TEXTURE; <br>        ddrval = IDirectDraw2_GetAvailableVidMem(lpDD2, &amp;DDSCaps, &amp;dwTotalMem, &amp;dwFreeMem ); <br>        if(ddrval != DD_OK) <br>        { <br>            dwTotalMem = 0; <br>            dwFreeMem = 0; <br>        }; <br>        LVAddText(g_hwndLV, 0, "Texture"); <br>        LVAddText(g_hwndLV, 1, "%d", dwTotalMem); <br>        LVAddText(g_hwndLV, 2, "%d", dwFreeMem); <br>    } <br>} <br> <br>BOOL VidMemPrint(long lParam1, long lParam2, PRINTCBINFO *lpInfo) <br>{ <br>    HRESULT ddrval; <br>    DWORD dwTotalMem; <br>    DWORD dwFreeMem; <br>    DDSCAPS DDSCaps; <br> <br>    if (DDCreate((GUID*)lParam1)) <br>    { <br>        IDirectDraw_QueryInterface(lpDD,&amp;IID_IDirectDraw2,&amp;lpDD2); <br> <br>        DDSCaps.dwCaps = DDSCAPS_VIDEOMEMORY; <br>        ddrval = IDirectDraw2_GetAvailableVidMem(lpDD2, &amp;DDSCaps, &amp;dwTotalMem, &amp;dwFreeMem ); <br>        if(ddrval != DD_OK) <br>        { <br>            dwTotalMem = 0; <br>            dwFreeMem = 0; <br>        }; <br>        PrintValueLine("TotalMem",dwTotalMem,lpInfo); <br>        PrintValueLine("FreeMem",dwFreeMem,lpInfo); <br> <br>        DDSCaps.dwCaps = DDSCAPS_LOCALVIDMEM; <br>        ddrval = IDirectDraw2_GetAvailableVidMem(lpDD2, &amp;DDSCaps, &amp;dwTotalMem, &amp;dwFreeMem ); <br>        if(ddrval != DD_OK) <br>        { <br>            dwTotalMem = 0; <br>            dwFreeMem = 0; <br>        }; <br>        PrintValueLine("TotalVideoMem",dwTotalMem,lpInfo); <br>        PrintValueLine("FreeVideoMem",dwFreeMem,lpInfo); <br> <br>        DDSCaps.dwCaps = DDSCAPS_NONLOCALVIDMEM; <br>        ddrval = IDirectDraw2_GetAvailableVidMem(lpDD2, &amp;DDSCaps, &amp;dwTotalMem, &amp;dwFreeMem ); <br>        if(ddrval != DD_OK) <br>        { <br>            dwTotalMem = 0; <br>            dwFreeMem = 0; <br>        }; <br>        PrintValueLine("TotalAGPMem",dwTotalMem,lpInfo); <br>        PrintValueLine("FreeAGPMem",dwFreeMem,lpInfo); <br> <br>        DDSCaps.dwCaps = DDSCAPS_TEXTURE; <br>        ddrval = IDirectDraw2_GetAvailableVidMem(lpDD2, &amp;DDSCaps, &amp;dwTotalMem, &amp;dwFreeMem ); <br>        if(ddrval != DD_OK) <br>        { <br>            dwTotalMem = 0; <br>            dwFreeMem = 0; <br>        }; <br>        PrintValueLine("TotalTextureMem",dwTotalMem,lpInfo); <br>        PrintValueLine("FreeTextureMem",dwFreeMem,lpInfo); <br>    } <br>    return TRUE;  <br>}; <br> <br>/**************************************************************************** <br> ***************************************************************************/ <br>CAPDEF OtherInfoDefs[] = <br>{ <br>    DDVALDEF("VidMemTotal",                   dwVidMemTotal), <br>    DDVALDEF("VidMemFree",                    dwVidMemFree), <br>    DDHEXDEF("AlphaBltConstBitDepths",        dwAlphaBltConstBitDepths), <br>    DDCAPDEF("  8",                           dwAlphaBltConstBitDepths, DDBD_8), <br>    DDCAPDEF("  16",                          dwAlphaBltConstBitDepths, DDBD_16), <br>    DDCAPDEF("  24",                          dwAlphaBltConstBitDepths, DDBD_24), <br>    DDCAPDEF("  32",                          dwAlphaBltConstBitDepths, DDBD_32), <br>    DDHEXDEF("AlphaBltPixelBitDepths",        dwAlphaBltPixelBitDepths), <br>    DDCAPDEF("  8",                           dwAlphaBltPixelBitDepths, DDBD_8), <br>    DDCAPDEF("  16",                          dwAlphaBltPixelBitDepths, DDBD_16), <br>    DDCAPDEF("  24",                          dwAlphaBltPixelBitDepths, DDBD_24), <br>    DDCAPDEF("  32",                          dwAlphaBltPixelBitDepths, DDBD_32), <br>    DDHEXDEF("AlphaBltSurfaceBitDepths",      dwAlphaBltSurfaceBitDepths), <br>    DDCAPDEF("  8",                           dwAlphaBltSurfaceBitDepths, DDBD_8), <br>    DDCAPDEF("  16",                          dwAlphaBltSurfaceBitDepths, DDBD_16), <br>    DDCAPDEF("  24",                          dwAlphaBltSurfaceBitDepths, DDBD_24), <br>    DDCAPDEF("  32",                          dwAlphaBltSurfaceBitDepths, DDBD_32), <br>    DDHEXDEF("AlphaOverlayConstBitDepths",    dwAlphaOverlayConstBitDepths), <br>    DDCAPDEF("  8",                           dwAlphaOverlayConstBitDepths, DDBD_8), <br>    DDCAPDEF("  16",                          dwAlphaOverlayConstBitDepths, DDBD_16), <br>    DDCAPDEF("  24",                          dwAlphaOverlayConstBitDepths, DDBD_24), <br>    DDCAPDEF("  32",                          dwAlphaOverlayConstBitDepths, DDBD_32), <br>    DDHEXDEF("AlphaOverlayPixelBitDepths",    dwAlphaOverlayPixelBitDepths), <br>    DDCAPDEF("  8",                           dwAlphaOverlayPixelBitDepths, DDBD_8), <br>    DDCAPDEF("  16",                          dwAlphaOverlayPixelBitDepths, DDBD_16), <br>    DDCAPDEF("  24",                          dwAlphaOverlayPixelBitDepths, DDBD_24), <br>    DDCAPDEF("  32",                          dwAlphaOverlayPixelBitDepths, DDBD_32), <br>    DDHEXDEF("AlphaOverlaySurfaceBitDepths",  dwAlphaOverlaySurfaceBitDepths), <br>    DDCAPDEF("  8",                           dwAlphaOverlaySurfaceBitDepths, DDBD_8), <br>    DDCAPDEF("  16",                          dwAlphaOverlaySurfaceBitDepths, DDBD_16), <br>    DDCAPDEF("  24",                          dwAlphaOverlaySurfaceBitDepths, DDBD_24), <br>    DDCAPDEF("  32",                          dwAlphaOverlaySurfaceBitDepths, DDBD_32), <br>    DDHEXDEF("ZBufferBitDepths",              dwZBufferBitDepths), <br>    DDCAPDEF("  8",                           dwZBufferBitDepths, DDBD_8), <br>    DDCAPDEF("  16",                          dwZBufferBitDepths, DDBD_16), <br>    DDCAPDEF("  24",                          dwZBufferBitDepths, DDBD_24), <br>    DDCAPDEF("  32",                          dwZBufferBitDepths, DDBD_32), <br>    DDVALDEF("MaxVisibleOverlays",            dwMaxVisibleOverlays), <br>    DDVALDEF("CurrVisibleOverlays",           dwCurrVisibleOverlays), <br>    DDVALDEF("NumFourCCCodes",                dwNumFourCCCodes), <br>    DDVALDEF("AlignBoundarySrc",              dwAlignBoundarySrc), <br>    DDVALDEF("AlignSizeSrc",                  dwAlignSizeSrc), <br>    DDVALDEF("AlignBoundaryDest",             dwAlignBoundaryDest), <br>    DDVALDEF("AlignSizeDest",                 dwAlignSizeDest), <br>    DDVALDEF("AlignStrideAlign",              dwAlignStrideAlign), <br>    DDVALDEF("MinOverlayStretch",             dwMinOverlayStretch), <br>    DDVALDEF("MaxOverlayStretch",             dwMaxOverlayStretch), <br>    DDVALDEF("MinLiveVideoStretch",           dwMinLiveVideoStretch), <br>    DDVALDEF("MaxLiveVideoStretch",           dwMaxLiveVideoStretch), <br>    DDVALDEF("MinHwCodecStretch",             dwMinHwCodecStretch), <br>    DDVALDEF("MaxHwCodecStretch",             dwMaxHwCodecStretch), <br>    DDVALDEF("dwReserved1",                   dwReserved1), <br>    DDVALDEF("dwReserved2",                   dwReserved2), <br>    DDVALDEF("dwReserved3",                   dwReserved3), <br> <br>    //DDHEXDEF("dwCaps",                      dwCaps), <br>    DDVALDEF("dwMaxVideoPorts",               dwMaxVideoPorts), <br>    DDVALDEF("dwCurrVideoPorts",               dwCurrVideoPorts), <br>    //DDVALDEF("dwSVBCaps2",                   dwSVBCaps2), <br>    { "", 0, 0 } <br>}; <br> <br>/**************************************************************************** <br> ***************************************************************************/ <br> <br>#define GEN_CAPS(dwCaps)                                                     \ <br>\ <br>    DDCAPDEF("3D",                        dwCaps, DDCAPS_3D),                   \ <br>    DDCAPDEF("ALIGNBOUNDARYDEST",         dwCaps, DDCAPS_ALIGNBOUNDARYDEST),    \ <br>    DDCAPDEF("ALIGNSIZEDEST",             dwCaps, DDCAPS_ALIGNSIZEDEST),        \ <br>    DDCAPDEF("ALIGNBOUNDARYSRC",          dwCaps, DDCAPS_ALIGNBOUNDARYSRC),     \ <br>    DDCAPDEF("ALIGNSIZESRC",              dwCaps, DDCAPS_ALIGNSIZESRC),         \ <br>    DDCAPDEF("ALIGNSTRIDE",               dwCaps, DDCAPS_ALIGNSTRIDE),          \ <br>    DDCAPDEF("GDI",                       dwCaps, DDCAPS_GDI),                  \ <br>    DDCAPDEF("OVERLAY",                   dwCaps, DDCAPS_OVERLAY),              \ <br>    DDCAPDEF("OVERLAYCANTCLIP",           dwCaps, DDCAPS_OVERLAYCANTCLIP),      \ <br>    DDCAPDEF("OVERLAYFOURCC",             dwCaps, DDCAPS_OVERLAYFOURCC),        \ <br>    DDCAPDEF("OVERLAYSTRETCH",            dwCaps, DDCAPS_OVERLAYSTRETCH),       \ <br>    DDCAPDEF("PALETTE",                   dwCaps, DDCAPS_PALETTE),              \ <br>    DDCAPDEF("PALETTEVSYNC",              dwCaps, DDCAPS_PALETTEVSYNC),         \ <br>    DDCAPDEF("READSCANLINE",              dwCaps, DDCAPS_READSCANLINE),         \ <br>    DDCAPDEF("STEREOVIEW",                dwCaps, DDCAPS_STEREOVIEW),           \ <br>    DDCAPDEF("VBI",                       dwCaps, DDCAPS_VBI),                  \ <br>    DDCAPDEF("ZOVERLAYS",                 dwCaps, DDCAPS_ZOVERLAYS),            \ <br>    DDCAPDEF("NOHARDWARE",                dwCaps, DDCAPS_NOHARDWARE),           \ <br>    DDCAPDEF("BANKSWITCHED",              dwCaps, DDCAPS_BANKSWITCHED), <br> <br> <br>#define GEN_CAPS2(dwCaps2)                                                      \ <br>    DDCAPDEF("CERTIFIED",                 dwCaps2,DDCAPS2_CERTIFIED),           \ <br>    DDCAPDEF("NO2DDURING3DSCENE",         dwCaps2,DDCAPS2_NO2DDURING3DSCENE),   \ <br>    DDCAPDEF("VIDEOPORT",                 dwCaps2,DDCAPS2_VIDEOPORT),           \ <br>    DDCAPDEF("AUTOFLIPOVERLAY",           dwCaps2,DDCAPS2_AUTOFLIPOVERLAY),     \ <br>    DDCAPDEF("CANBOBINTERLEAVED",         dwCaps2,DDCAPS2_CANBOBINTERLEAVED),   \ <br>    DDCAPDEF("CANBOBNONINTERLEAVED",      dwCaps2,DDCAPS2_CANBOBNONINTERLEAVED),\ <br>    DDCAPDEF("COLORCONTROLOVERLAY",       dwCaps2,DDCAPS2_COLORCONTROLOVERLAY), \ <br>    DDCAPDEF("COLORCONTROLPRIMARY",       dwCaps2,DDCAPS2_COLORCONTROLPRIMARY), \ <br>    DDCAPDEF("NONLOCALVIDMEM",            dwCaps2,DDCAPS2_NONLOCALVIDMEM),      \ <br>    DDCAPDEF("NONLOCALVIDMEMCAPS",        dwCaps2,DDCAPS2_NONLOCALVIDMEMCAPS),  \ <br>    DDCAPDEF("WIDESURFACES",              dwCaps2,DDCAPS2_WIDESURFACES),        \ <br>    DDCAPDEF("NOPAGELOCKREQUIRED",        dwCaps2,DDCAPS2_NOPAGELOCKREQUIRED),   <br> <br> <br>#define GEN_BLTCAPS(dwCaps)                                                     \ <br>    DDCAPDEF("BLT",                       dwCaps, DDCAPS_BLT),                  \ <br>    DDCAPDEF("BLTCOLORFILL",              dwCaps, DDCAPS_BLTCOLORFILL),         \ <br>    DDCAPDEF("BLTDEPTHFILL",              dwCaps, DDCAPS_BLTDEPTHFILL),         \ <br>    DDCAPDEF("BLTFOURCC",                 dwCaps, DDCAPS_BLTFOURCC),            \ <br>    DDCAPDEF("BLTSTRETCH",                dwCaps, DDCAPS_BLTSTRETCH),           \ <br>    DDCAPDEF("BLTQUEUE",                  dwCaps, DDCAPS_BLTQUEUE),             \ <br>    DDCAPDEF("COLORKEY",                  dwCaps, DDCAPS_COLORKEY),             \ <br>    DDCAPDEF("ALPHA",                     dwCaps, DDCAPS_ALPHA),                \ <br>    DDCAPDEF("CKEYHWASSIST",              dwCaps, DDCAPS_COLORKEYHWASSIST),     \ <br>    DDCAPDEF("CANCLIP",                   dwCaps, DDCAPS_CANCLIP),              \ <br>    DDCAPDEF("CANCLIPSTRETCHED",          dwCaps, DDCAPS_CANCLIPSTRETCHED),     \ <br>    DDCAPDEF("CANBLTSYSMEM",              dwCaps, DDCAPS_CANBLTSYSMEM),         \ <br>    DDCAPDEF("ZBLTS",                     dwCaps, DDCAPS_ZBLTS),                 <br> <br> <br>#define GEN_BLTCAPS2(dwCaps2)                                                   \ <br>    DDCAPDEF("CANDROPZ16BIT",             dwCaps2,DDCAPS2_CANDROPZ16BIT),       \ <br>    DDCAPDEF("NOPAGELOCKREQUIRED",        dwCaps2,DDCAPS2_NOPAGELOCKREQUIRED),   <br> <br> <br>/**************************************************************************** <br> ***************************************************************************/ <br>CAPDEF GenCaps[] = <br>{ <br>    GEN_CAPS(dwCaps) <br>    GEN_CAPS2(dwCaps2) <br>    { "", 0, 0 } <br>}; <br> <br>// <br>// NOTE GenCaps and CapsDefs are the same <br>// because some are blt caps that apply to VRAM-&gt;VRAM blts and <br>// some are "general" caps... <br>// <br>CAPDEF CapsDefs[] = <br>{ <br>    GEN_BLTCAPS(dwCaps) <br>    GEN_BLTCAPS2(dwCaps2) <br>    { "", 0, 0 } <br>}; <br>CAPDEF SVBCapsDefs[] = <br>{ <br>    GEN_BLTCAPS(dwSVBCaps) <br>    GEN_BLTCAPS2(dwSVBCaps2) <br>    { "", 0, 0 } <br>}; <br>CAPDEF VSBCapsDefs[] = <br>{ <br>    GEN_BLTCAPS(dwVSBCaps) <br>//  GEN_BLTCAPS2(dwVSBCaps2) <br>    { "", 0, 0 } <br>}; <br>CAPDEF SSBCapsDefs[] = <br>{ <br>    GEN_BLTCAPS(dwSSBCaps) <br>//  GEN_BLTCAPS2(dwSSBCaps2) <br>    { "", 0, 0 } <br>}; <br>CAPDEF NLVBCapsDefs[] = <br>{ <br>    GEN_BLTCAPS(dwNLVBCaps) <br>    GEN_BLTCAPS2(dwNLVBCaps2) <br>    { "", 0, 0 } <br>}; <br> <br>/**************************************************************************** <br> ***************************************************************************/ <br>#define GEN_CKCAPS(dwCKeyCaps)                                                              \ <br>    DDCAPDEF("DESTBLT",                 dwCKeyCaps, DDCKEYCAPS_DESTBLT),                  \ <br>    DDCAPDEF("DESTBLTCLRSPACE",         dwCKeyCaps, DDCKEYCAPS_DESTBLTCLRSPACE),          \ <br>    DDCAPDEF("DESTBLTCLRSPACEYUV",      dwCKeyCaps, DDCKEYCAPS_DESTBLTCLRSPACEYUV),       \ <br>    DDCAPDEF("DESTBLTYUV",              dwCKeyCaps, DDCKEYCAPS_DESTBLTYUV),               \ <br>    DDCAPDEF("DESTOVERLAY",             dwCKeyCaps, DDCKEYCAPS_DESTOVERLAY),              \ <br>    DDCAPDEF("DESTOVERLAYCLRSPACE",     dwCKeyCaps, DDCKEYCAPS_DESTOVERLAYCLRSPACE),      \ <br>    DDCAPDEF("DESTOVERLAYCLRSPACEYUV",  dwCKeyCaps, DDCKEYCAPS_DESTOVERLAYCLRSPACEYUV),   \ <br>    DDCAPDEF("DESTOVERLAYONEACTIVE",    dwCKeyCaps, DDCKEYCAPS_DESTOVERLAYONEACTIVE),     \ <br>    DDCAPDEF("DESTOVERLAYYUV",          dwCKeyCaps, DDCKEYCAPS_DESTOVERLAYYUV),           \ <br>    DDCAPDEF("SRCBLT",                  dwCKeyCaps, DDCKEYCAPS_SRCBLT),                   \ <br>    DDCAPDEF("SRCBLTCLRSPACE",          dwCKeyCaps, DDCKEYCAPS_SRCBLTCLRSPACE),           \ <br>    DDCAPDEF("SRCBLTCLRSPACEYUV",       dwCKeyCaps, DDCKEYCAPS_SRCBLTCLRSPACEYUV),        \ <br>    DDCAPDEF("SRCBLTYUV",               dwCKeyCaps, DDCKEYCAPS_SRCBLTYUV),                \ <br>    DDCAPDEF("SRCOVERLAY",              dwCKeyCaps, DDCKEYCAPS_SRCOVERLAY),               \ <br>    DDCAPDEF("SRCOVERLAYCLRSPACE",      dwCKeyCaps, DDCKEYCAPS_SRCOVERLAYCLRSPACE),       \ <br>    DDCAPDEF("SRCOVERLAYCLRSPACEYUV",   dwCKeyCaps, DDCKEYCAPS_SRCOVERLAYCLRSPACEYUV),    \ <br>    DDCAPDEF("SRCOVERLAYONEACTIVE",     dwCKeyCaps, DDCKEYCAPS_SRCOVERLAYONEACTIVE),      \ <br>    DDCAPDEF("SRCOVERLAYYUV",           dwCKeyCaps, DDCKEYCAPS_SRCOVERLAYYUV), <br> <br>CAPDEF CKeyCapsDefs[] = <br>{ <br>    GEN_CKCAPS(dwCKeyCaps) <br>    { "", 0, 0} <br>}; <br>CAPDEF VSBCKeyCapsDefs[] = <br>{ <br>    GEN_CKCAPS(dwVSBCKeyCaps) <br>    { "", 0, 0} <br>}; <br>CAPDEF SVBCKeyCapsDefs[] = <br>{ <br>    GEN_CKCAPS(dwSVBCKeyCaps) <br>    { "", 0, 0} <br>}; <br>CAPDEF SSBCKeyCapsDefs[] = <br>{ <br>    GEN_CKCAPS(dwSSBCKeyCaps) <br>    { "", 0, 0} <br>}; <br>CAPDEF NLVBCKeyCapsDefs[] = <br>{ <br>    GEN_CKCAPS(dwNLVBCKeyCaps) <br>    { "", 0, 0} <br>}; <br> <br> <br>/**************************************************************************** <br> ***************************************************************************/ <br>#define GEN_FXCAPS(dwFXCaps)                                                            \ <br>    DDCAPDEF("BLTARITHSTRETCHY",          dwFXCaps, DDFXCAPS_BLTARITHSTRETCHY),         \ <br>    DDCAPDEF("BLTARITHSTRETCHYN",         dwFXCaps, DDFXCAPS_BLTARITHSTRETCHYN),        \ <br>    DDCAPDEF("BLTMIRRORLEFTRIGHT",        dwFXCaps, DDFXCAPS_BLTMIRRORLEFTRIGHT),       \ <br>    DDCAPDEF("BLTMIRRORUPDOWN",           dwFXCaps, DDFXCAPS_BLTMIRRORUPDOWN),          \ <br>    DDCAPDEF("BLTROTATION",               dwFXCaps, DDFXCAPS_BLTROTATION),              \ <br>    DDCAPDEF("BLTROTATION90",             dwFXCaps, DDFXCAPS_BLTROTATION90),            \ <br>    DDCAPDEF("BLTSHRINKX",                dwFXCaps, DDFXCAPS_BLTSHRINKX),               \ <br>    DDCAPDEF("BLTSHRINKXN",               dwFXCaps, DDFXCAPS_BLTSHRINKXN),              \ <br>    DDCAPDEF("BLTSHRINKY",                dwFXCaps, DDFXCAPS_BLTSHRINKY),               \ <br>    DDCAPDEF("BLTSHRINKYN",               dwFXCaps, DDFXCAPS_BLTSHRINKYN),              \ <br>    DDCAPDEF("BLTSTRETCHX",               dwFXCaps, DDFXCAPS_BLTSTRETCHX),              \ <br>    DDCAPDEF("BLTSTRETCHXN",              dwFXCaps, DDFXCAPS_BLTSTRETCHXN),             \ <br>    DDCAPDEF("BLTSTRETCHY",               dwFXCaps, DDFXCAPS_BLTSTRETCHY),              \ <br>    DDCAPDEF("BLTSTRETCHYN",              dwFXCaps, DDFXCAPS_BLTSTRETCHYN),             \ <br>    DDCAPDEF("OVERLAYARITHSTRETCHY",      dwFXCaps, DDFXCAPS_OVERLAYARITHSTRETCHY),     \ <br>    DDCAPDEF("OVERLAYARITHSTRETCHYN",     dwFXCaps, DDFXCAPS_OVERLAYARITHSTRETCHYN),    \ <br>    DDCAPDEF("OVERLAYSHRINKX",            dwFXCaps, DDFXCAPS_OVERLAYSHRINKX),           \ <br>    DDCAPDEF("OVERLAYSHRINKXN",           dwFXCaps, DDFXCAPS_OVERLAYSHRINKXN),          \ <br>    DDCAPDEF("OVERLAYSHRINKY",            dwFXCaps, DDFXCAPS_OVERLAYSHRINKY),           \ <br>    DDCAPDEF("OVERLAYSHRINKYN",           dwFXCaps, DDFXCAPS_OVERLAYSHRINKYN),          \ <br>    DDCAPDEF("OVERLAYSTRETCHX",           dwFXCaps, DDFXCAPS_OVERLAYSTRETCHX),          \ <br>    DDCAPDEF("OVERLAYSTRETCHXN",          dwFXCaps, DDFXCAPS_OVERLAYSTRETCHXN),         \ <br>    DDCAPDEF("OVERLAYSTRETCHY",           dwFXCaps, DDFXCAPS_OVERLAYSTRETCHY),          \ <br>    DDCAPDEF("OVERLAYSTRETCHYN",          dwFXCaps, DDFXCAPS_OVERLAYSTRETCHYN),         \ <br>    DDCAPDEF("OVERLAYMIRRORLEFTRIGHT",    dwFXCaps, DDFXCAPS_OVERLAYMIRRORLEFTRIGHT),   \ <br>    DDCAPDEF("OVERLAYMIRRORUPDOWN",       dwFXCaps, DDFXCAPS_OVERLAYMIRRORUPDOWN), <br> <br>CAPDEF FXCapsDefs[] = <br>{ <br>    GEN_FXCAPS(dwFXCaps) <br>    { "", 0, 0} <br>}; <br>CAPDEF VSBFXCapsDefs[] = <br>{ <br>    GEN_FXCAPS(dwVSBFXCaps) <br>    { "", 0, 0} <br>}; <br>CAPDEF SVBFXCapsDefs[] = <br>{ <br>    GEN_FXCAPS(dwSVBFXCaps) <br>    { "", 0, 0} <br>}; <br>CAPDEF SSBFXCapsDefs[] = <br>{ <br>    GEN_FXCAPS(dwSSBFXCaps) <br>    { "", 0, 0} <br>}; <br>CAPDEF NLVBFXCapsDefs[] = <br>{ <br>    GEN_FXCAPS(dwNLVBFXCaps) <br>    { "", 0, 0} <br>}; <br> <br>/**************************************************************************** <br> ***************************************************************************/ <br>CAPDEF PalCapsDefs[] = <br>{ <br>    DDCAPDEF("4BIT",              dwPalCaps, DDPCAPS_4BIT), <br>    DDCAPDEF("8BITENTRIES",       dwPalCaps, DDPCAPS_8BITENTRIES), <br>    DDCAPDEF("8BIT",              dwPalCaps, DDPCAPS_8BIT), <br>    DDCAPDEF("INITIALIZE",        dwPalCaps, DDPCAPS_INITIALIZE), <br>    DDCAPDEF("PRIMARYSURFACE",    dwPalCaps, DDPCAPS_PRIMARYSURFACE), <br>    DDCAPDEF("PRIMARYSURFACELEFT",dwPalCaps, DDPCAPS_PRIMARYSURFACELEFT), <br>    DDCAPDEF("VSYNC",             dwPalCaps, DDPCAPS_VSYNC), <br>    { "", 0, 0} <br>}; <br> <br>/**************************************************************************** <br> ***************************************************************************/ <br>CAPDEF SurfCapsDefs[] = <br>{ <br>    DDCAPDEF( "3DDEVICE",             ddsCaps.dwCaps, DDSCAPS_3DDEVICE), <br>    DDCAPDEF( "ALPHA",                ddsCaps.dwCaps, DDSCAPS_ALPHA), <br>    DDCAPDEF( "BACKBUFFER",           ddsCaps.dwCaps, DDSCAPS_BACKBUFFER), <br>    DDCAPDEF( "COMPLEX",              ddsCaps.dwCaps, DDSCAPS_COMPLEX), <br>    DDCAPDEF( "FLIP",                 ddsCaps.dwCaps, DDSCAPS_FLIP), <br>    DDCAPDEF( "FRONTBUFFER",          ddsCaps.dwCaps, DDSCAPS_FRONTBUFFER), <br>    DDCAPDEF( "MIPMAP",               ddsCaps.dwCaps, DDSCAPS_MIPMAP), <br>    DDCAPDEF( "OFFSCREENPLAIN",       ddsCaps.dwCaps, DDSCAPS_OFFSCREENPLAIN), <br>    DDCAPDEF( "OVERLAY",              ddsCaps.dwCaps, DDSCAPS_OVERLAY), <br>    DDCAPDEF( "PALETTE",              ddsCaps.dwCaps, DDSCAPS_PALETTE), <br>    DDCAPDEF( "PRIMARYSURFACE",       ddsCaps.dwCaps, DDSCAPS_PRIMARYSURFACE), <br>    DDCAPDEF( "PRIMARYSURFACELEFT",   ddsCaps.dwCaps, DDSCAPS_PRIMARYSURFACELEFT), <br>    DDCAPDEF( "SYSTEMMEMORY",         ddsCaps.dwCaps, DDSCAPS_SYSTEMMEMORY), <br>    DDCAPDEF( "TEXTURE",              ddsCaps.dwCaps, DDSCAPS_TEXTURE), <br>    DDCAPDEF( "VIDEOMEMORY",          ddsCaps.dwCaps, DDSCAPS_VIDEOMEMORY), <br>    DDCAPDEF( "VISIBLE",              ddsCaps.dwCaps, DDSCAPS_VISIBLE), <br>    DDCAPDEF( "WRITEONLY",            ddsCaps.dwCaps, DDSCAPS_WRITEONLY), <br>    DDCAPDEF( "ZBUFFER",              ddsCaps.dwCaps, DDSCAPS_ZBUFFER), <br>    DDCAPDEF( "OWNDC",                ddsCaps.dwCaps, DDSCAPS_OWNDC), <br>    DDCAPDEF( "LIVEVIDEO",            ddsCaps.dwCaps, DDSCAPS_LIVEVIDEO), <br>    DDCAPDEF( "HWCODEC",              ddsCaps.dwCaps, DDSCAPS_HWCODEC), <br>    DDCAPDEF( "MODEX",                ddsCaps.dwCaps, DDSCAPS_MODEX), <br>    { "", 0, 0} <br>}; <br> <br>/**************************************************************************** <br> ***************************************************************************/ <br>CAPDEF SVisionCapsDefs[] = <br>{ <br>    DDCAPDEF( "ENIGMA",  dwSVCaps, DDSVCAPS_ENIGMA), <br>    DDCAPDEF( "FLICKER", dwSVCaps, DDSVCAPS_FLICKER), <br>    DDCAPDEF( "REDBLUE", dwSVCaps, DDSVCAPS_REDBLUE), <br>    DDCAPDEF( "SPLIT",   dwSVCaps, DDSVCAPS_SPLIT), <br>    { "", 0, 0} <br>}; <br> <br>/**************************************************************************** <br> ***************************************************************************/ <br>#define GEN_ROPS(dwRops)\ <br>    ROPDEF("SRCCOPY",    dwRops, SRCCOPY),      \ <br>    ROPDEF("SRCPAINT",   dwRops, SRCPAINT),     \ <br>    ROPDEF("SRCAND",     dwRops, SRCAND),       \ <br>    ROPDEF("SRCINVERT",  dwRops, SRCINVERT),    \ <br>    ROPDEF("SRCERASE",   dwRops, SRCERASE),     \ <br>    ROPDEF("NOTSRCCOPY", dwRops, NOTSRCCOPY),   \ <br>    ROPDEF("NOTSRCERASE",dwRops, NOTSRCERASE),  \ <br>    ROPDEF("MERGECOPY",  dwRops, MERGECOPY),    \ <br>    ROPDEF("MERGEPAINT", dwRops, MERGEPAINT),   \ <br>    ROPDEF("PATCOPY",    dwRops, PATCOPY),      \ <br>    ROPDEF("PATPAINT",   dwRops, PATPAINT),     \ <br>    ROPDEF("PATINVERT",  dwRops, PATINVERT),    \ <br>    ROPDEF("DSTINVERT",  dwRops, DSTINVERT),    \ <br>    ROPDEF("BLACKNESS",  dwRops, BLACKNESS),    \ <br>    ROPDEF("WHITENESS",  dwRops, WHITENESS), <br> <br>CAPDEF ROPCapsDefs[] = <br>{ <br>    GEN_ROPS(dwRops) <br>    {"", 0, 0} <br>}; <br>CAPDEF VSBROPCapsDefs[] = <br>{ <br>    GEN_ROPS(dwVSBRops) <br>    {"", 0, 0} <br>}; <br>CAPDEF SVBROPCapsDefs[] = <br>{ <br>    GEN_ROPS(dwSVBRops) <br>    {"", 0, 0} <br>}; <br>CAPDEF SSBROPCapsDefs[] = <br>{ <br>    GEN_ROPS(dwSSBRops) <br>    {"", 0, 0} <br>}; <br>CAPDEF NLVBROPCapsDefs[] = <br>{ <br>    GEN_ROPS(dwNLVBRops) <br>    {"", 0, 0} <br>}; <br> <br>/**************************************************************************** <br> ***************************************************************************/ <br>CAPDEFS DDCapDefs[] = <br>{ <br>    {"",                    NULL,               (LPARAM)0,                  NULL}, <br>    {"Memory",              VidMem,             (LPARAM)0,                  VidMemPrint}, <br> <br>    {"+Caps",               NULL,               (LPARAM)0,                  NULL}, <br>    {"General",             DDAddCaps,          (LPARAM)GenCaps,           DDPrintCaps}, <br>    {"Palette Caps",        DDAddCaps,          (LPARAM)PalCapsDefs,        DDPrintCaps}, <br>    {"Surface Caps",        DDAddCaps,          (LPARAM)SurfCapsDefs,       DDPrintCaps}, <br>    {"Stereo Vision Caps",  DDAddCaps,          (LPARAM)SVisionCapsDefs,    DDPrintCaps}, <br> <br>    {"+Video - Video",      NULL,               (LPARAM)0,                  NULL}, <br>    {"General",             DDAddCaps,          (LPARAM)CapsDefs,           DDPrintCaps}, <br>    {"Color Key",           DDAddCaps,          (LPARAM)CKeyCapsDefs,       DDPrintCaps}, <br>    {"FX",                  DDAddCaps,          (LPARAM)FXCapsDefs,         DDPrintCaps}, <br>    {"ROPS",                DDAddCaps,          (LPARAM)ROPCapsDefs,        DDPrintCaps}, <br>    {"-",                   NULL,               (LPARAM)0,                  NULL}, <br> <br>    {"+System - Video",     NULL,               (LPARAM)0,                  NULL}, <br>    {"General",             DDAddCaps,          (LPARAM)SVBCapsDefs,        DDPrintCaps}, <br>    {"Color Key",           DDAddCaps,          (LPARAM)SVBCKeyCapsDefs,    DDPrintCaps}, <br>    {"FX",                  DDAddCaps,          (LPARAM)SVBFXCapsDefs,      DDPrintCaps}, </code></pre>
<p>
</p>
<pre><code>{"ROPS",                DDAddCaps,          (LPARAM)SVBROPCapsDefs,     DDPrintCaps}, <br>    {"-",                   NULL,               (LPARAM)0,                  NULL}, <br> <br>    {"+Video - System",     NULL,               (LPARAM)0,                  NULL}, <br>    {"General",             DDAddCaps,          (LPARAM)VSBCapsDefs,        DDPrintCaps}, <br>    {"Color Key",           DDAddCaps,          (LPARAM)SSBCKeyCapsDefs,    DDPrintCaps}, <br>    {"FX",                  DDAddCaps,          (LPARAM)SSBFXCapsDefs,      DDPrintCaps}, <br>    {"ROPS",                DDAddCaps,          (LPARAM)VSBROPCapsDefs,     DDPrintCaps}, <br>    {"-",                   NULL,               (LPARAM)0,                  NULL}, <br> <br>    {"+System - System",    NULL,               (LPARAM)0,                  NULL}, <br>    {"General",             DDAddCaps,          (LPARAM)SSBCapsDefs,        DDPrintCaps}, <br>    {"Color Key",           DDAddCaps,          (LPARAM)SSBCKeyCapsDefs,    DDPrintCaps}, <br>    {"FX",                  DDAddCaps,          (LPARAM)SSBFXCapsDefs,      DDPrintCaps}, <br>    {"ROPS",                DDAddCaps,          (LPARAM)SSBROPCapsDefs,     DDPrintCaps}, <br>    {"-",                   NULL,               (LPARAM)0,                  NULL}, <br> <br>    {"+NonLocal - Video",   NULL,               (LPARAM)0,                  NULL}, <br>    {"General",             DDAddCaps,          (LPARAM)NLVBCapsDefs,       DDPrintCaps}, <br>    {"Color Key",           DDAddCaps,          (LPARAM)NLVBCKeyCapsDefs,   DDPrintCaps}, <br>    {"FX",                  DDAddCaps,          (LPARAM)NLVBFXCapsDefs,     DDPrintCaps}, <br>    {"ROPS",                DDAddCaps,          (LPARAM)NLVBROPCapsDefs,    DDPrintCaps}, <br>    {"-",                   NULL,               (LPARAM)0,                  NULL}, <br> <br>    {"-",                   NULL,               (LPARAM)0,                  NULL}, <br> <br>    {"Video Modes",         DDAddVideoModes,    (LPARAM)0,                  DDPrintVideoModes}, <br>    {"FourCC Formats",      DDFourCCFormat,     (LPARAM)0,                  DDPrintFourCCFormat}, <br>    {"Other",               DDAddCaps,          (LPARAM)OtherInfoDefs,      DDPrintCaps}, <br> <br>    { NULL, 0, 0, NULL} <br>}; <br> <br>/**************************************************************************** <br> ***************************************************************************/ <br>CAPDEF ValidFlags[] = <br>{ <br>    D3CAPDEF("COLORMODEL",            dwFlags, D3DDD_COLORMODEL),            <br>    D3CAPDEF("DEVCAPS",               dwFlags, D3DDD_DEVCAPS),               <br>    D3CAPDEF("TRANSFORMCAPS",         dwFlags, D3DDD_TRANSFORMCAPS),         <br>    D3CAPDEF("LIGHTINGCAPS",          dwFlags, D3DDD_LIGHTINGCAPS),          <br>    D3CAPDEF("BCLIPPING",             dwFlags, D3DDD_BCLIPPING),             <br>    D3CAPDEF("LINECAPS",              dwFlags, D3DDD_LINECAPS),              <br>    D3CAPDEF("TRICAPS",               dwFlags, D3DDD_TRICAPS),               <br>    D3CAPDEF("DEVICERENDERBITDEPTH",  dwFlags, D3DDD_DEVICERENDERBITDEPTH),  <br>    D3CAPDEF("DEVICEZBUFFERBITDEPTH", dwFlags, D3DDD_DEVICEZBUFFERBITDEPTH), <br>    D3CAPDEF("MAXBUFFERSIZE",         dwFlags, D3DDD_MAXBUFFERSIZE),         <br>    D3CAPDEF("MAXVERTEXCOUNT",        dwFlags, D3DDD_MAXVERTEXCOUNT),        <br>    {"",0,0} <br>}; <br> <br>/**************************************************************************** <br> ***************************************************************************/ <br>CAPDEF ColorModel[] = <br>{ <br>    D3CAPDEF("D3DCOLOR_MONO",           dcmColorModel, D3DCOLOR_MONO), <br>    D3CAPDEF("D3DCOLOR_RGB",            dcmColorModel, D3DCOLOR_RGB), <br>    {"",0,0} <br>}; <br> <br>/**************************************************************************** <br> ***************************************************************************/ <br>CAPDEF DevCaps[] = <br>{ <br>    D3CAPDEF("SORTINCREASINGZ",             dwDevCaps, D3DDEVCAPS_SORTINCREASINGZ), <br>    D3CAPDEF("SORTDECREASINGZ",             dwDevCaps, D3DDEVCAPS_SORTDECREASINGZ), <br>    D3CAPDEF("SORTEXACT",                   dwDevCaps, D3DDEVCAPS_SORTEXACT), <br>    D3CAPDEF("EXECUTESYSTEMMEMORY",         dwDevCaps, D3DDEVCAPS_EXECUTESYSTEMMEMORY), <br>    D3CAPDEF("EXECUTEVIDEOMEMORY",          dwDevCaps, D3DDEVCAPS_EXECUTEVIDEOMEMORY), <br>    D3CAPDEF("TLVERTEXSYSTEMEMORY",         dwDevCaps, D3DDEVCAPS_TLVERTEXSYSTEMMEMORY), <br>    D3CAPDEF("TLVERTEXVIDEOMEMORY",         dwDevCaps, D3DDEVCAPS_TLVERTEXVIDEOMEMORY), <br>    D3CAPDEF("TEXTURESYSTEMMEMORY",         dwDevCaps, D3DDEVCAPS_TEXTURESYSTEMMEMORY), <br>    D3CAPDEF("TEXTUREVIDEOMEMORY",          dwDevCaps, D3DDEVCAPS_TEXTUREVIDEOMEMORY), <br>    D3CAPDEF("FLOATTLVERTEX"              , dwDevCaps, D3DDEVCAPS_FLOATTLVERTEX), <br>    D3CAPDEF("DRAWPRIMTLVERTEX"           , dwDevCaps, D3DDEVCAPS_DRAWPRIMTLVERTEX), <br>    D3CAPDEF("CANRENDERAFTERFLIP"         , dwDevCaps, D3DDEVCAPS_CANRENDERAFTERFLIP), <br>    D3CAPDEF("TEXTURENONLOCALVIDMEM" , dwDevCaps, D3DDEVCAPS_TEXTURENONLOCALVIDMEM), <br> <br>    {"",0,0} <br>}; <br> <br>/**************************************************************************** <br> ***************************************************************************/ <br>CAPDEF TransformCaps[] = <br>{ <br>    D3CAPDEF("CLIP",  dtcTransformCaps.dwCaps, D3DTRANSFORMCAPS_CLIP),   <br>    {"",0,0} <br>}; <br> <br>/**************************************************************************** <br> ***************************************************************************/ <br>CAPDEF LightingCaps[] = <br>{ <br>    D3CAPDEF("D3DLIGHTINGMODEL_RGB",       dlcLightingCaps.dwLightingModel, D3DLIGHTINGMODEL_RGB),       <br>    D3CAPDEF("D3DLIGHTINGMODEL_MONO",      dlcLightingCaps.dwLightingModel, D3DLIGHTINGMODEL_MONO),      <br> <br>    D3CAPDEF("D3DLIGHTCAPS_POINT",         dlcLightingCaps.dwCaps,          D3DLIGHTCAPS_POINT),         <br>    D3CAPDEF("D3DLIGHTCAPS_SPOT",          dlcLightingCaps.dwCaps,          D3DLIGHTCAPS_SPOT),          <br>    D3CAPDEF("D3DLIGHTCAPS_DIRECTIONAL",   dlcLightingCaps.dwCaps,          D3DLIGHTCAPS_DIRECTIONAL),   <br>    D3CAPDEF("D3DLIGHTCAPS_PARALLELPOINT", dlcLightingCaps.dwCaps,          D3DLIGHTCAPS_PARALLELPOINT), <br>    D3VALDEF("dwNumLights",                dlcLightingCaps.dwNumLights),    <br>    {"",0,0} <br>}; <br> <br>/**************************************************************************** <br> ***************************************************************************/ <br>CAPDEF BClipping[] = <br>{ <br>    D3CAPDEF("bClipping", bClipping, TRUE), <br>    {"",0,0} <br>}; <br> <br>/**************************************************************************** <br> ***************************************************************************/ <br>CAPDEF TriMisc[] = <br>{ <br>    D3CAPDEF("MASKPLANES",            dpcTriCaps.dwMiscCaps,           D3DPMISCCAPS_MASKPLANES), <br>    D3CAPDEF("MASKZ",                 dpcTriCaps.dwMiscCaps,           D3DPMISCCAPS_MASKZ), <br>    D3CAPDEF("LINEPATTERNREP",        dpcTriCaps.dwMiscCaps,           D3DPMISCCAPS_LINEPATTERNREP), <br>    D3CAPDEF("CONFORMANT",            dpcTriCaps.dwMiscCaps,           D3DPMISCCAPS_CONFORMANT), <br>    D3CAPDEF("CULLNONE",              dpcTriCaps.dwMiscCaps,           D3DPMISCCAPS_CULLNONE), <br>    D3CAPDEF("CULLCW",                dpcTriCaps.dwMiscCaps,           D3DPMISCCAPS_CULLCW), <br>    D3CAPDEF("CULLCCW",               dpcTriCaps.dwMiscCaps,           D3DPMISCCAPS_CULLCCW), <br> <br>    D3CAPDEF("DITHER",              dpcTriCaps.dwRasterCaps,         D3DPRASTERCAPS_DITHER), <br>    D3CAPDEF("ROP2",                dpcTriCaps.dwRasterCaps,         D3DPRASTERCAPS_ROP2), <br>    D3CAPDEF("XOR",                 dpcTriCaps.dwRasterCaps,         D3DPRASTERCAPS_XOR), <br>    D3CAPDEF("PAT",                 dpcTriCaps.dwRasterCaps,         D3DPRASTERCAPS_PAT), <br>    D3CAPDEF("ZTEST",               dpcTriCaps.dwRasterCaps,         D3DPRASTERCAPS_ZTEST), <br>    D3CAPDEF("SUBPIXEL",            dpcTriCaps.dwRasterCaps,         D3DPRASTERCAPS_SUBPIXEL), <br>    D3CAPDEF("SUBPIXELX",           dpcTriCaps.dwRasterCaps,         D3DPRASTERCAPS_SUBPIXELX), <br>    D3CAPDEF("FOGVERTEX",           dpcTriCaps.dwRasterCaps,         D3DPRASTERCAPS_FOGVERTEX), <br>    D3CAPDEF("FOGTABLE",            dpcTriCaps.dwRasterCaps,         D3DPRASTERCAPS_FOGTABLE), <br> <br>    {"",0,0} <br>}; <br> <br>/**************************************************************************** <br> ***************************************************************************/ <br>CAPDEF TriFog[] = <br>{ <br>    D3CAPDEF("FOGVERTEX",       dpcTriCaps.dwRasterCaps,         D3DPRASTERCAPS_FOGVERTEX), <br>    D3CAPDEF("FOGTABLE",        dpcTriCaps.dwRasterCaps,         D3DPRASTERCAPS_FOGTABLE), <br> <br>    D3CAPDEF("FOG FLAT",        dpcTriCaps.dwShadeCaps,          D3DPSHADECAPS_FOGFLAT             ), <br>    D3CAPDEF("FOG GOURAUD",     dpcTriCaps.dwShadeCaps,          D3DPSHADECAPS_FOGGOURAUD          ), <br>    D3CAPDEF("FOG PHONG",       dpcTriCaps.dwShadeCaps,          D3DPSHADECAPS_FOGPHONG            ), <br> <br>    {"",0,0} <br>}; <br> <br> <br>/**************************************************************************** <br> ***************************************************************************/ <br>CAPDEF TriCull[] = <br>{ <br>    D3CAPDEF("CULL NONE",           dpcTriCaps.dwMiscCaps,           D3DPMISCCAPS_CULLNONE), <br>    D3CAPDEF("CULL CW",             dpcTriCaps.dwMiscCaps,           D3DPMISCCAPS_CULLCW), <br>    D3CAPDEF("CULL CCW",            dpcTriCaps.dwMiscCaps,           D3DPMISCCAPS_CULLCCW), <br> <br>    {"",0,0} <br>}; <br> <br>/**************************************************************************** <br> ***************************************************************************/ <br>CAPDEF TriTextureBlend[] = <br>{ <br>    D3CAPDEF("DECAL",           dpcTriCaps.dwTextureBlendCaps,   D3DPTBLENDCAPS_DECAL              ), <br>    D3CAPDEF("MODULATE",        dpcTriCaps.dwTextureBlendCaps,   D3DPTBLENDCAPS_MODULATE           ), <br>    D3CAPDEF("DECALALPHA",      dpcTriCaps.dwTextureBlendCaps,   D3DPTBLENDCAPS_DECALALPHA         ), <br>    D3CAPDEF("MODULATEALPHA",   dpcTriCaps.dwTextureBlendCaps,   D3DPTBLENDCAPS_MODULATEALPHA      ), <br>    D3CAPDEF("DECALMASK",       dpcTriCaps.dwTextureBlendCaps,   D3DPTBLENDCAPS_DECALMASK          ), <br>    D3CAPDEF("MODULATEMASK",    dpcTriCaps.dwTextureBlendCaps,   D3DPTBLENDCAPS_MODULATEMASK       ), <br>    D3CAPDEF("COPY",            dpcTriCaps.dwTextureBlendCaps,   D3DPTBLENDCAPS_COPY               ), <br> <br>    {"",0,0} <br>}; <br> <br>/**************************************************************************** <br> ***************************************************************************/ <br>CAPDEF TriTextureFilter[] = <br>{ <br>    D3CAPDEF("NEAREST",         dpcTriCaps.dwTextureFilterCaps,  D3DPTFILTERCAPS_NEAREST           ), <br>    D3CAPDEF("LINEAR",          dpcTriCaps.dwTextureFilterCaps,  D3DPTFILTERCAPS_LINEAR            ), <br>    D3CAPDEF("MIPNEAREST",      dpcTriCaps.dwTextureFilterCaps,  D3DPTFILTERCAPS_MIPNEAREST        ), <br>    D3CAPDEF("MIPLINEAR",       dpcTriCaps.dwTextureFilterCaps,  D3DPTFILTERCAPS_MIPLINEAR         ), <br>    D3CAPDEF("LINEARMIPNEAREST",dpcTriCaps.dwTextureFilterCaps,  D3DPTFILTERCAPS_LINEARMIPNEAREST  ), <br>    D3CAPDEF("LINEARMIPLINEAR", dpcTriCaps.dwTextureFilterCaps,  D3DPTFILTERCAPS_LINEARMIPLINEAR   ), <br> <br>    {"",0,0} <br>}; <br> <br>/**************************************************************************** <br> ***************************************************************************/ <br>CAPDEF TriTextureCaps[] = <br>{ <br>    D3CAPDEF("PERSPECTIVE",     dpcTriCaps.dwTextureCaps,        D3DPTEXTURECAPS_PERSPECTIVE       ), <br>    D3CAPDEF("POW2",            dpcTriCaps.dwTextureCaps,        D3DPTEXTURECAPS_POW2              ), <br>    D3CAPDEF("ALPHA",           dpcTriCaps.dwTextureCaps,        D3DPTEXTURECAPS_ALPHA             ), <br>    D3CAPDEF("TRANSPARENCY",    dpcTriCaps.dwTextureCaps,        D3DPTEXTURECAPS_TRANSPARENCY      ), <br>    D3CAPDEF("BORDER",          dpcTriCaps.dwTextureCaps,        D3DPTEXTURECAPS_BORDER            ), <br>    D3CAPDEF("SQUAREONLY",      dpcTriCaps.dwTextureCaps,        D3DPTEXTURECAPS_SQUAREONLY        ), <br>     <br>    D3CAPDEF("WRAP",            dpcTriCaps.dwTextureAddressCaps, D3DPTADDRESSCAPS_WRAP             ), <br>    D3CAPDEF("MIRROR",          dpcTriCaps.dwTextureAddressCaps, D3DPTADDRESSCAPS_MIRROR           ), <br>    D3CAPDEF("CLAMP",           dpcTriCaps.dwTextureAddressCaps, D3DPTADDRESSCAPS_CLAMP            ), <br>    D3CAPDEF("BORDER",          dpcTriCaps.dwTextureAddressCaps, D3DPTADDRESSCAPS_BORDER           ), <br>    D3CAPDEF("INDEPENDENTUV",   dpcTriCaps.dwTextureAddressCaps, D3DPTADDRESSCAPS_INDEPENDENTUV    ), <br> <br>    {"",0,0} <br>}; <br> <br>/**************************************************************************** <br> ***************************************************************************/ <br>CAPDEF TriZCmpCaps[] = <br>{ <br>    D3CAPDEF("NEVER",               dpcTriCaps.dwZCmpCaps,           D3DPCMPCAPS_NEVER                 ), <br>    D3CAPDEF("LESS",                dpcTriCaps.dwZCmpCaps,           D3DPCMPCAPS_LESS                  ), <br>    D3CAPDEF("EQUAL",               dpcTriCaps.dwZCmpCaps,           D3DPCMPCAPS_EQUAL                 ), <br>    D3CAPDEF("LESSEQUAL",           dpcTriCaps.dwZCmpCaps,           D3DPCMPCAPS_LESSEQUAL             ), <br>    D3CAPDEF("GREATER",             dpcTriCaps.dwZCmpCaps,           D3DPCMPCAPS_GREATER               ), <br>    D3CAPDEF("NOTEQUAL",            dpcTriCaps.dwZCmpCaps,           D3DPCMPCAPS_NOTEQUAL              ), <br>    D3CAPDEF("GREATEREQUAL",        dpcTriCaps.dwZCmpCaps,           D3DPCMPCAPS_GREATEREQUAL          ), <br>    D3CAPDEF("ALWAYS",              dpcTriCaps.dwZCmpCaps,           D3DPCMPCAPS_ALWAYS                ), <br> <br>    {"",0,0} <br>}; <br> <br> <br>/**************************************************************************** <br> ***************************************************************************/ <br>CAPDEF TriACmpCaps[] = <br>{ <br>    D3CAPDEF("NEVER",                  dpcTriCaps.dwAlphaCmpCaps,       D3DPCMPCAPS_NEVER                 ), <br>    D3CAPDEF("LESS",                   dpcTriCaps.dwAlphaCmpCaps,       D3DPCMPCAPS_LESS                  ), <br>    D3CAPDEF("EQUAL",                  dpcTriCaps.dwAlphaCmpCaps,       D3DPCMPCAPS_EQUAL                 ), <br>    D3CAPDEF("LESSEQUAL",              dpcTriCaps.dwAlphaCmpCaps,       D3DPCMPCAPS_LESSEQUAL             ), <br>    D3CAPDEF("GREATER",                dpcTriCaps.dwAlphaCmpCaps,       D3DPCMPCAPS_GREATER               ), <br>    D3CAPDEF("NOTEQUAL",               dpcTriCaps.dwAlphaCmpCaps,       D3DPCMPCAPS_NOTEQUAL              ), <br>    D3CAPDEF("GREATEREQUAL",           dpcTriCaps.dwAlphaCmpCaps,       D3DPCMPCAPS_GREATEREQUAL          ), <br>    D3CAPDEF("ALWAYS",                 dpcTriCaps.dwAlphaCmpCaps,       D3DPCMPCAPS_ALWAYS                ), <br> <br>    {"",0,0} <br>}; <br> <br>/**************************************************************************** <br> ***************************************************************************/ <br>CAPDEF TriSrcBlendCaps[] = <br>{ <br>    D3CAPDEF("ZERO",                 dpcTriCaps.dwSrcBlendCaps,       D3DPBLENDCAPS_ZERO                ), <br>    D3CAPDEF("ONE",                  dpcTriCaps.dwSrcBlendCaps,       D3DPBLENDCAPS_ONE                 ), <br>    D3CAPDEF("SRCCOLOR",             dpcTriCaps.dwSrcBlendCaps,       D3DPBLENDCAPS_SRCCOLOR            ), <br>    D3CAPDEF("INVSRCCOLOR",          dpcTriCaps.dwSrcBlendCaps,       D3DPBLENDCAPS_INVSRCCOLOR         ), <br>    D3CAPDEF("SRCALPHA",             dpcTriCaps.dwSrcBlendCaps,       D3DPBLENDCAPS_SRCALPHA            ), <br>    D3CAPDEF("INVSRCALPHA",          dpcTriCaps.dwSrcBlendCaps,       D3DPBLENDCAPS_INVSRCALPHA         ), <br>    D3CAPDEF("DESTALPHA",            dpcTriCaps.dwSrcBlendCaps,       D3DPBLENDCAPS_DESTALPHA           ), <br>    D3CAPDEF("INVDESTALPHA",         dpcTriCaps.dwSrcBlendCaps,       D3DPBLENDCAPS_INVDESTALPHA        ), <br>    D3CAPDEF("DESTCOLOR",            dpcTriCaps.dwSrcBlendCaps,       D3DPBLENDCAPS_DESTCOLOR           ), <br>    D3CAPDEF("INVDESTCOLOR",         dpcTriCaps.dwSrcBlendCaps,       D3DPBLENDCAPS_INVDESTCOLOR        ), <br>    D3CAPDEF("SRCALPHASAT",          dpcTriCaps.dwSrcBlendCaps,       D3DPBLENDCAPS_SRCALPHASAT         ), <br>    D3CAPDEF("BOTHSRCALPHA",         dpcTriCaps.dwSrcBlendCaps,       D3DPBLENDCAPS_BOTHSRCALPHA        ), <br>    D3CAPDEF("BOTHINVSRCALPHA",      dpcTriCaps.dwSrcBlendCaps,       D3DPBLENDCAPS_BOTHINVSRCALPHA     ), <br> <br>    {"",0,0} <br>}; <br>     <br>/**************************************************************************** <br> ***************************************************************************/ <br>CAPDEF TriDestBlendCaps[] = <br>{ <br>    D3CAPDEF("ZERO",                 dpcTriCaps.dwDestBlendCaps,      D3DPBLENDCAPS_ZERO                ), <br>    D3CAPDEF("ONE",                  dpcTriCaps.dwDestBlendCaps,      D3DPBLENDCAPS_ONE                 ), <br>    D3CAPDEF("SRCCOLOR",             dpcTriCaps.dwDestBlendCaps,      D3DPBLENDCAPS_SRCCOLOR            ), <br>    D3CAPDEF("INVSRCCOLOR",          dpcTriCaps.dwDestBlendCaps,      D3DPBLENDCAPS_INVSRCCOLOR         ), <br>    D3CAPDEF("SRCALPHA",             dpcTriCaps.dwDestBlendCaps,      D3DPBLENDCAPS_SRCALPHA            ), <br>    D3CAPDEF("INVSRCALPHA",          dpcTriCaps.dwDestBlendCaps,      D3DPBLENDCAPS_INVSRCALPHA         ), <br>    D3CAPDEF("DESTALPHA",            dpcTriCaps.dwDestBlendCaps,      D3DPBLENDCAPS_DESTALPHA           ), <br>    D3CAPDEF("INVDESTALPHA",         dpcTriCaps.dwDestBlendCaps,      D3DPBLENDCAPS_INVDESTALPHA        ), <br>    D3CAPDEF("DESTCOLOR",            dpcTriCaps.dwDestBlendCaps,      D3DPBLENDCAPS_DESTCOLOR           ), <br>    D3CAPDEF("INVDESTCOLOR",         dpcTriCaps.dwDestBlendCaps,      D3DPBLENDCAPS_INVDESTCOLOR        ), <br>    D3CAPDEF("SRCALPHASAT",          dpcTriCaps.dwDestBlendCaps,      D3DPBLENDCAPS_SRCALPHASAT         ), <br>    D3CAPDEF("BOTHSRCALPHA",         dpcTriCaps.dwDestBlendCaps,      D3DPBLENDCAPS_BOTHSRCALPHA        ), <br>    D3CAPDEF("BOTHINVSRCALPHA",      dpcTriCaps.dwDestBlendCaps,      D3DPBLENDCAPS_BOTHINVSRCALPHA     ), <br> <br>    {"",0,0} <br>}; <br>     <br>/**************************************************************************** <br> ***************************************************************************/ <br>CAPDEF TriShadeCaps[] = <br>{ <br>    D3CAPDEF("COLOR FLAT MONO",        dpcTriCaps.dwShadeCaps,          D3DPSHADECAPS_COLORFLATMONO       ), <br>    D3CAPDEF("COLOR FLAT RGB",         dpcTriCaps.dwShadeCaps,          D3DPSHADECAPS_COLORFLATRGB        ), <br>    D3CAPDEF("COLOR GOURAUD MONO",     dpcTriCaps.dwShadeCaps,          D3DPSHADECAPS_COLORGOURAUDMONO    ), <br>    D3CAPDEF("COLOR GOURAUD RGB",      dpcTriCaps.dwShadeCaps,          D3DPSHADECAPS_COLORGOURAUDRGB     ), <br>    D3CAPDEF("COLOR PHONG MONO",       dpcTriCaps.dwShadeCaps,          D3DPSHADECAPS_COLORPHONGMONO      ), <br>    D3CAPDEF("COLOR PHONG RGB",        dpcTriCaps.dwShadeCaps,          D3DPSHADECAPS_COLORPHONGRGB       ), <br>     <br>    D3CAPDEF("SPECULAR FLAT MONO",     dpcTriCaps.dwShadeCaps,          D3DPSHADECAPS_SPECULARFLATMONO    ), <br>    D3CAPDEF("SPECULAR FLAT RGB",      dpcTriCaps.dwShadeCaps,          D3DPSHADECAPS_SPECULARFLATRGB     ), <br>    D3CAPDEF("SPECULAR GOURAUD MONO",  dpcTriCaps.dwShadeCaps,          D3DPSHADECAPS_SPECULARGOURAUDMONO ), <br>    D3CAPDEF("SPECULAR GOURAUD RGB",   dpcTriCaps.dwShadeCaps,          D3DPSHADECAPS_SPECULARGOURAUDRGB  ), <br>    D3CAPDEF("SPECULAR PHONG MONO",    dpcTriCaps.dwShadeCaps,          D3DPSHADECAPS_SPECULARPHONGMONO   ), <br>    D3CAPDEF("SPECULAR PHONG RGB",     dpcTriCaps.dwShadeCaps,          D3DPSHADECAPS_SPECULARPHONGRGB    ), <br>     <br>    D3CAPDEF("ALPHA FLAT BLEND",       dpcTriCaps.dwShadeCaps,          D3DPSHADECAPS_ALPHAFLATBLEND      ), <br>    D3CAPDEF("ALPHA FLAT STIPPLED",    dpcTriCaps.dwShadeCaps,          D3DPSHADECAPS_ALPHAFLATSTIPPLED   ), <br>    D3CAPDEF("ALPHA GOURAUD BLEND",    dpcTriCaps.dwShadeCaps,          D3DPSHADECAPS_ALPHAGOURAUDBLEND   ), <br>    D3CAPDEF("ALPHA GOURAUD STIPPLED", dpcTriCaps.dwShadeCaps,          D3DPSHADECAPS_ALPHAGOURAUDSTIPPLED), <br>    D3CAPDEF("ALPHA PHONG BLEND",      dpcTriCaps.dwShadeCaps,          D3DPSHADECAPS_ALPHAPHONGBLEND     ), <br>    D3CAPDEF("ALPHA PHONG STIPPLED",   dpcTriCaps.dwShadeCaps,          D3DPSHADECAPS_ALPHAPHONGSTIPPLED  ), <br>     <br>    D3CAPDEF("FOG FLAT",               dpcTriCaps.dwShadeCaps,          D3DPSHADECAPS_FOGFLAT             ), <br>    D3CAPDEF("FOG GOURAUD",            dpcTriCaps.dwShadeCaps,          D3DPSHADECAPS_FOGGOURAUD          ), <br>    D3CAPDEF("FOG PHONG",              dpcTriCaps.dwShadeCaps,          D3DPSHADECAPS_FOGPHONG            ), <br>     <br>    {"",0,0} <br>}; <br> <br> <br>/**************************************************************************** <br> ***************************************************************************/ <br>CAPDEF D3dMisc[] = <br>{ <br>    D3CAPDEF("D3DCOLOR_MONO",         dcmColorModel, D3DCOLOR_MONO), <br>    D3CAPDEF("D3DCOLOR_RGB",          dcmColorModel, D3DCOLOR_RGB), <br> <br>    D3CAPDEF("bClipping", bClipping, TRUE), <br>    D3CAPDEF("CLIP",  dtcTransformCaps.dwCaps, D3DTRANSFORMCAPS_CLIP),   <br> <br> <br>    D3VALDEF("MaxBufferSize",         dwMaxBufferSize),         <br>    D3VALDEF("MaxVertexCount",        dwMaxVertexCount),        <br>    D3HEXDEF("DeviceRenderBitDepth",  dwDeviceRenderBitDepth), <br>    D3CAPDEF("  8",                   dwDeviceRenderBitDepth, DDBD_8), <br>    D3CAPDEF("  16",                  dwDeviceRenderBitDepth, DDBD_16), <br>    D3CAPDEF("  24",                  dwDeviceRenderBitDepth, DDBD_24), <br>    D3CAPDEF("  32",                  dwDeviceRenderBitDepth, DDBD_32), <br>    D3HEXDEF("DeviceZBufferBitDepth", dwDeviceZBufferBitDepth), <br>    D3CAPDEF("  8",                   dwDeviceZBufferBitDepth, DDBD_8), <br>    D3CAPDEF("  16",                  dwDeviceZBufferBitDepth, DDBD_16), <br>    D3CAPDEF("  24",                  dwDeviceZBufferBitDepth, DDBD_24), <br>    D3CAPDEF("  32",                  dwDeviceZBufferBitDepth, DDBD_32), <br>    D3VALDEF("MinTextureWidth",       dwMinTextureWidth), <br>    D3VALDEF("MinTextureHeight",      dwMinTextureHeight), <br>    D3VALDEF("MaxTextureWidth",       dwMaxTextureWidth), <br>    D3VALDEF("MaxTextureHeight",      dwMaxTextureHeight), <br>    D3VALDEF("MinStippleWidth",       dwMinStippleWidth), <br>    D3VALDEF("MaxStippleWidth",       dwMaxStippleWidth), <br>    D3VALDEF("MinStippleHeight",      dwMinStippleHeight), <br>    D3VALDEF("MaxStippleHeight",      dwMaxStippleHeight), <br> <br>    {"",0,0} <br>}; <br> <br>/**************************************************************************** <br> ***************************************************************************/ <br>CAPDEFS D3CapDefs[] = <br>{ <br>    {"",                D3AddCaps, (LPARAM)ValidFlags,       D3PrintCaps}, <br>    {"DevCaps",         D3AddCaps, (LPARAM)DevCaps,          D3PrintCaps}, <br>    {"Misc",            D3AddCaps, (LPARAM)D3dMisc,          D3PrintCaps}, <br>//  {"ColorModel",      D3AddCaps, (LPARAM)ColorModel,       D3PrintCaps}, <br>//  {"TransformCaps",   D3AddCaps, (LPARAM)TransformCaps,    D3PrintCaps}, <br>//  {"BClipping",       D3AddCaps, (LPARAM)BClipping,        D3PrintCaps}, <br>    {"LightingCaps",    D3AddCaps, (LPARAM)LightingCaps,     D3PrintCaps}, <br> <br>    {"+Triangle Caps",      NULL,      (LPARAM)0,                NULL}, <br>    {"Z Compare",           D3AddCaps, (LPARAM)TriZCmpCaps,      D3PrintCaps}, <br>    {"Alpha Compare",       D3AddCaps, (LPARAM)TriACmpCaps,      D3PrintCaps}, <br>    {"Misc",                D3AddCaps, (LPARAM)TriMisc,          D3PrintCaps}, <br>    {"Cull",                D3AddCaps, (LPARAM)TriCull,          D3PrintCaps}, <br>    {"Fog",                 D3AddCaps, (LPARAM)TriFog,           D3PrintCaps}, <br>    {"Texture Caps",        D3AddCaps, (LPARAM)TriTextureCaps,   D3PrintCaps}, <br>    {"Texture Filter",      D3AddCaps, (LPARAM)TriTextureFilter, D3PrintCaps}, <br>    {"Texture Blend",       D3AddCaps, (LPARAM)TriTextureBlend,  D3PrintCaps}, <br>    {"Texture Source Blend",D3AddCaps, (LPARAM)TriSrcBlendCaps,  D3PrintCaps}, <br>    {"Texture Dest Blend",  D3AddCaps, (LPARAM)TriDestBlendCaps, D3PrintCaps}, <br>    {"-",                   NULL,      (LPARAM)0,                NULL}, <br> <br>    {"+Line Caps",          NULL,          (LPARAM)0,                NULL}, <br>    {"Z Compare",           D3AddLineCaps, (LPARAM)TriZCmpCaps,      D3PrintCaps}, <br>    {"Alpha Compare",       D3AddLineCaps, (LPARAM)TriACmpCaps,      D3PrintCaps}, <br>    {"Misc",                D3AddLineCaps, (LPARAM)TriMisc,          D3PrintCaps}, <br>    {"Cull",                D3AddLineCaps, (LPARAM)TriCull,          D3PrintCaps}, <br>    {"Fog",                 D3AddLineCaps, (LPARAM)TriFog,           D3PrintCaps}, <br>    {"Texture Caps",        D3AddLineCaps, (LPARAM)TriTextureCaps,   D3PrintCaps}, <br>    {"Texture Filter",      D3AddLineCaps, (LPARAM)TriTextureFilter, D3PrintCaps}, <br>    {"Texture Blend",       D3AddLineCaps, (LPARAM)TriTextureBlend,  D3PrintCaps}, <br>    {"Texture Source Blend",D3AddLineCaps, (LPARAM)TriSrcBlendCaps,  D3PrintCaps}, <br>    {"Texture Dest Blend",  D3AddLineCaps, (LPARAM)TriDestBlendCaps, D3PrintCaps}, <br>    {"-",                   NULL,          (LPARAM)0,                NULL}, <br> <br>    {"Texture Formats",     D3AddTexF, (LPARAM)0,                0}, <br>    {NULL, 0, 0, NULL} <br>}; <br> <br>/**************************************************************************** <br> ***************************************************************************/ <br>CAPDEF DSInfo[] = <br>{ <br>    DSVALDEF("MinSecondarySampleRate",          dwMinSecondarySampleRate), <br>    DSVALDEF("MaxSecondarySampleRate",          dwMaxSecondarySampleRate), <br>    DSVALDEF("PrimaryBuffers",                  dwPrimaryBuffers), <br>    DSVALDEF("MaxHwMixingAllBuffers",           dwMaxHwMixingAllBuffers), <br>    DSVALDEF("MaxHwMixingStaticBuffers",        dwMaxHwMixingStaticBuffers), <br>    DSVALDEF("MaxHwMixingStreamingBuffers",     dwMaxHwMixingStreamingBuffers), <br>    DSVALDEF("FreeHwMixingAllBuffers",          dwFreeHwMixingAllBuffers), <br>    DSVALDEF("FreeHwMixingStaticBuffers",       dwFreeHwMixingStaticBuffers), <br>    DSVALDEF("FreeHwMixingStreamingBuffers",    dwFreeHwMixingStreamingBuffers), <br>    DSVALDEF("MaxHw3DAllBuffers",               dwMaxHw3DAllBuffers), <br>    DSVALDEF("MaxHw3DStaticBuffers",            dwMaxHw3DStaticBuffers), <br>    DSVALDEF("MaxHw3DStreamingBuffers",         dwMaxHw3DStreamingBuffers), <br>    DSVALDEF("FreeHw3DAllBuffers",              dwFreeHw3DAllBuffers), <br>    DSVALDEF("FreeHw3DStaticBuffers",           dwFreeHw3DStaticBuffers), <br>    DSVALDEF("FreeHw3DStreamingBuffers",        dwFreeHw3DStreamingBuffers), <br>    DSVALDEF("TotalHwMemBytes",                 dwTotalHwMemBytes), <br>    DSVALDEF("FreeHwMemBytes",                  dwFreeHwMemBytes), <br>    DSVALDEF("MaxContigFreeHwMemBytes",         dwMaxContigFreeHwMemBytes), <br>    DSVALDEF("UnlockTransferRateHwBuffers",     dwUnlockTransferRateHwBuffers), <br>    DSVALDEF("PlayCpuOverheadSwBuffers",        dwPlayCpuOverheadSwBuffers), <br>    {"", 0, 0} <br>}; <br> <br>/**************************************************************************** <br> ***************************************************************************/ <br>CAPDEF DSGeneralCaps[] = <br>{ <br>    DSCAPDEF("PRIMARYMONO",       dwFlags,    DSCAPS_PRIMARYMONO), <br>    DSCAPDEF("PRIMARYSTEREO",     dwFlags,    DSCAPS_PRIMARYSTEREO), <br>    DSCAPDEF("PRIMARY8BIT",       dwFlags,    DSCAPS_PRIMARY8BIT), <br>    DSCAPDEF("PRIMARY16BIT",      dwFlags,    DSCAPS_PRIMARY16BIT), <br>    DSCAPDEF("CONTINUOUSRATE",    dwFlags,    DSCAPS_CONTINUOUSRATE), <br>    DSCAPDEF("EMULDRIVER",        dwFlags,    DSCAPS_EMULDRIVER), <br>    DSCAPDEF("SECONDARYMONO",     dwFlags,    DSCAPS_SECONDARYMONO), <br>    DSCAPDEF("SECONDARYSTEREO",   dwFlags,    DSCAPS_SECONDARYSTEREO), <br>    DSCAPDEF("SECONDARY8BIT",     dwFlags,    DSCAPS_SECONDARY8BIT), <br>    DSCAPDEF("SECONDARY16BIT",    dwFlags,    DSCAPS_SECONDARY16BIT), <br>    {"", 0, 0} <br>}; <br> <br>/**************************************************************************** <br> ***************************************************************************/ <br>CAPDEFS DSCapDefs[] = <br>{ <br>    {"",                    DSAddCaps,          (LPARAM)DSInfo,         DSPrintCaps}, <br>    {"General",             DSAddCaps,          (LPARAM)DSInfo,         DSPrintCaps}, <br>    {"General Caps",        DSAddCaps,          (LPARAM)DSGeneralCaps,  DSPrintCaps}, <br>    {NULL, 0, 0, NULL} <br>}; <br> <br>/**************************************************************************** <br> ***************************************************************************/ <br>CAPDEF DSCInfo[] = <br>{ <br>    DSCVALDEF("Channels",          dwChannels), <br>    {"", 0, 0} <br>}; <br> <br>/**************************************************************************** <br> ***************************************************************************/ <br>CAPDEF DSCGeneralCaps[] = <br>{ <br>    DSCCAPDEF("EMULDRIVER",        dwFlags,    DSCCAPS_EMULDRIVER), <br>    DSCCAPDEF("WAVE_FORMAT_1M08",  dwFormats,  WAVE_FORMAT_1M08), <br>    DSCCAPDEF("WAVE_FORMAT_1S08",  dwFormats,  WAVE_FORMAT_1S08), <br>    DSCCAPDEF("WAVE_FORMAT_1M16",  dwFormats,  WAVE_FORMAT_1M16), <br>    DSCCAPDEF("WAVE_FORMAT_1S16",  dwFormats,  WAVE_FORMAT_1S16), <br>    DSCCAPDEF("WAVE_FORMAT_2M08",  dwFormats,  WAVE_FORMAT_2M08), <br>    DSCCAPDEF("WAVE_FORMAT_2S08",  dwFormats,  WAVE_FORMAT_2S08), <br>    DSCCAPDEF("WAVE_FORMAT_2M16",  dwFormats,  WAVE_FORMAT_2M16), <br>    DSCCAPDEF("WAVE_FORMAT_2S16",  dwFormats,  WAVE_FORMAT_2S16), <br>    DSCCAPDEF("WAVE_FORMAT_4M08",  dwFormats,  WAVE_FORMAT_4M08), <br>    DSCCAPDEF("WAVE_FORMAT_4S08",  dwFormats,  WAVE_FORMAT_4S08), <br>    DSCCAPDEF("WAVE_FORMAT_4M16",  dwFormats,  WAVE_FORMAT_4M16), <br>    DSCCAPDEF("WAVE_FORMAT_4S16",  dwFormats,  WAVE_FORMAT_4S16), <br>    {"", 0, 0} <br>}; <br> <br>/**************************************************************************** <br> ***************************************************************************/ <br>CAPDEFS DSCCapDefs[] = <br>{ <br>    {"",                    DSCAddCaps,          (LPARAM)DSCInfo,         DSCPrintCaps}, <br>    {"General",             DSCAddCaps,          (LPARAM)DSCInfo,         DSCPrintCaps}, <br>    {"General Caps",        DSCAddCaps,          (LPARAM)DSCGeneralCaps,  DSCPrintCaps}, <br>    {NULL, 0, 0, NULL} <br>}; <br> <br>/**************************************************************************** <br> ***************************************************************************/ <br>CAPDEF DPInfo[] = <br>{ <br>    DPVALDEF("Size",                dwSize), <br>    DPHEXDEF("Flags",               dwFlags), <br>    DPVALDEF("MaxBufferSize",       dwMaxBufferSize), <br>    DPVALDEF("MaxQueueSize",        dwMaxQueueSize), <br>    DPVALDEF("MaxPlayers",          dwMaxPlayers), <br>    DPVALDEF("HundredBaud",         dwHundredBaud), </code></pre>
<p>
</p>
<pre><code>DPVALDEF("Latency",             dwLatency), <br>    DPVALDEF("MaxLocalPlayers",     dwMaxLocalPlayers), <br>    DPVALDEF("HeaderLength",        dwHeaderLength), <br>    DPVALDEF("Timeout",             dwTimeout), <br>    {"", 0, 0} <br>}; <br> <br>/**************************************************************************** <br> ***************************************************************************/ <br>CAPDEFS DPCapDefs[] = <br>{ <br>    {"",                    DPAddCaps,(LPARAM)DPInfo,  DPPrintCaps}, <br>    {"Sessions",            DPAddSessions,      (LPARAM)0,            DPPrintSessions}, <br>    {NULL, 0, 0} <br>}; <br> <br>/**************************************************************************** <br> ***************************************************************************/ <br>CAPDEFS DPLocalAppsDef[] = <br>{ <br>    {"LocalApplications",DPAddLocalApps,(LPARAM)0,DPPrintLocalApps}, <br>    {NULL, 0, 0} <br>}; <br> <br>//================================================================ <br>//  WinMain - entry point <br>//================================================================ <br>int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) <br>{ <br>    MSG msg; <br> <br>    CoInitialize( NULL ); <br>    g_hInstance = hInstance; // Store instance handle in our global variable <br>    g_idTimer = 0;                  //Used by DPlay <br>    g_lpLocalApp = NULL;    //Used by DPLay <br> <br>    // Try to load the dsound.dll <br>    g_hDSoundLib = LoadLibrary("DSOUND.DLL"); <br>    if (g_hDSoundLib == NULL) <br>    {       // couldn't load the library so put up a message and quit. <br>        MessageBox(g_hwndMain, "Could not load DSOUND.DLL", g_szAppName, MB_OK); <br>        CoUninitialize(); <br>        return 0;       // terminate after showing the message. <br>    } <br> <br>    //Create the initial local app list. <br>    DPAddLocalApps(0L, 0); <br> <br>    if (InitInstance(hInstance, lpCmdLine, nCmdShow, DXView_WIDTH, DXView_HEIGHT)) <br>    { <br>        while(GetMessage(&amp;msg, NULL, 0, 0)) <br>        { <br>            TranslateMessage(&amp;msg); <br>            DispatchMessage(&amp;msg); <br>        } <br>    } <br> <br>    if (g_lpLocalApp) <br>        FreeLocalAppList(); <br> <br>    // Unload dsound.dll <br>    FreeLibrary(g_hDSoundLib); <br> <br>    CoUninitialize(); <br>    return(msg.wParam); <br>} <br> <br>//================================================================ <br>//  InitInstance - create main window <br>//================================================================ <br>BOOL InitInstance(HINSTANCE hInstance, LPSTR lpCmdLine, int nCmdShow, int iWidth, int iHeight) <br>{ <br>    WNDCLASS  wc; <br> <br>    wc.style         = CS_HREDRAW | CS_VREDRAW; // Class style(s). <br>    wc.lpfnWndProc   = (WNDPROC)WndProc;        // Window Procedure <br>    wc.cbClsExtra    = 0;                       // No per-class extra data. <br>    wc.cbWndExtra    = 0;                       // No per-window extra data. <br>    wc.hInstance     = hInstance;               // Owner of this class <br>    wc.hIcon         = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_DIRECTX)); // Icon name from .RC <br>    wc.hCursor       = LoadCursor(hInstance, MAKEINTRESOURCE(IDC_SPLIT));// Cursor <br>    wc.hbrBackground = (HBRUSH)(COLOR_3DFACE+1); // Default color <br>    wc.lpszMenuName  = "Menu";                   // Menu name from .RC <br>    wc.lpszClassName = g_szClassName;            // Name to register as <br> <br>    if(!RegisterClass(&amp;wc)) <br>    { <br>        return FALSE; <br>    } <br> <br>    // Create a main window for this application instance. <br>    g_hwndMain = CreateWindowEx( <br>        0, <br>        g_szClassName,   // See RegisterClass() call. <br>        g_szTitle,       // Text for window title bar. <br>        WS_OVERLAPPEDWINDOW,// Window style. <br>        CW_USEDEFAULT, CW_USEDEFAULT, iWidth, iHeight, // Use default positioning <br>        NULL,            // Overlapped windows have no parent. <br>        NULL,            // Use the window class menu. <br>        hInstance,       // This instance owns this window. <br>        NULL); <br> <br>    // If window could not be created, return "failure" <br>    if (! g_hwndMain) <br>    { <br>        return(FALSE); <br>    } <br> <br>    // Make the window visible; update its client area; and return "success" <br>    ShowWindow (g_hwndMain, nCmdShow); // Show the window <br> <br>    return(TRUE);              // We succeeded... <br>} <br> <br>//================================================================ <br>//  WndProc - main window proc <br>//================================================================ <br>LRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>    switch(message) <br>    { <br>        case WM_CREATE: <br>            return DXView_OnCreate(hwnd); <br> <br>        case WM_SIZE: <br>            DXView_OnSize(hwnd); <br>            break; <br> <br>        case WM_LBUTTONDOWN: <br>            g_bSplitMove = TRUE; <br>            SetCapture(hwnd); <br>            break; <br> <br>        case WM_LBUTTONUP: <br>            g_bSplitMove = FALSE; <br>            ReleaseCapture(); <br>            break; <br> <br>        case WM_MOUSEMOVE: <br>            if(g_bSplitMove) <br>            { <br>                RECT    rect; <br>                // change the value from unsigned to signed <br>                int     x = (int)(short)LOWORD(lParam); <br> <br>                GetClientRect(hwnd, &amp;rect); <br>                if (rect.left &gt; x) <br>                { <br>                    x = rect.left; <br>                } <br>                else if (rect.right &lt; x) <br>                { <br>                    x = rect.right; <br>                } <br>                g_xPaneSplit = (x - g_xHalfSplitWidth); <br>                DXView_OnSize(hwnd); <br>            } <br>            break; <br> <br>        case WM_NOTIFY: <br>            if (((NMHDR*)lParam)-&gt;hwndFrom == g_hwndTV) <br>            { <br>                if (((NMHDR*)lParam)-&gt;code == TVN_SELCHANGED) <br>                    DXView_OnTreeSelect(g_hwndTV, (NM_TREEVIEW*)lParam); <br>            } <br> <br>            if (((NMHDR*)lParam)-&gt;hwndFrom == g_hwndLV) <br>            { <br>                if (((NMHDR*)lParam)-&gt;code == NM_RDBLCLK) <br>                    DXView_OnListViewDblClick(g_hwndLV, (NM_LISTVIEW*)lParam); <br>            } <br> <br>            break; <br> <br>       case WM_TIMER: <br>// refresh the session list <br>EnumSessions( lpDP3A ); <br>break; <br> <br>       case WM_COMMAND:  // message: command from application menu <br>            DXView_OnCommand(hwnd, wParam); <br>            break; <br> <br>        case WM_CLOSE: <br>            DestroyWindow(hwnd); <br>            return 0; <br> <br>        case WM_DESTROY:  // message: window being destroyed <br>            DXView_Cleanup();  // Free per item struct for all items <br>            PostQuitMessage(0); <br>            break; <br>    } <br> <br>    return(DefWindowProc(hwnd, message, wParam, lParam)); <br>} <br> <br>//================================================================ <br>//================================================================ <br>BOOL DXView_OnCreate(HWND hwnd) <br>{ <br>    HDC hDC; <br>    int PixelsPerInch; <br>    TEXTMETRIC tm; <br>    static TCHAR szBuf[MAX_PATH]; <br> <br>    hDC = GetDC(hwnd); <br>    PixelsPerInch = GetDeviceCaps(hDC, LOGPIXELSX); <br>    g_hFont = GetStockObject(ANSI_FIXED_FONT); <br>    SelectObject(hDC, g_hFont); <br>    GetTextMetrics(hDC, &amp;tm); <br>    g_tmAveCharWidth = tm.tmAveCharWidth; <br>    ReleaseDC(hwnd, hDC); <br> <br>    // Initialize global data <br>    g_dwViewState = IDM_VIEWAVAIL; <br>    g_xPaneSplit = PixelsPerInch * 12 / 4; <br>    g_xHalfSplitWidth = GetSystemMetrics(SM_CXSIZEFRAME) / 2; <br> <br>    // Make sure that the common control library read to rock <br>    InitCommonControls(); <br> <br>    CheckMenuItem(GetMenu(hwnd), g_dwViewState, MF_BYCOMMAND | MF_CHECKED); <br> <br>    // Create the list view window. <br>    g_hwndLV = CreateWindowEx(WS_EX_CLIENTEDGE, WC_LISTVIEW, "", <br>        WS_VISIBLE | WS_CHILD | WS_BORDER | LVS_REPORT, <br>        0, 0, 0, 0, hwnd, (HMENU)IDC_LV, g_hInstance, NULL); <br> <br>    // create the tree view window. <br>    g_hwndTV = CreateWindowEx(WS_EX_CLIENTEDGE, WC_TREEVIEW, "", <br>        WS_VISIBLE | WS_CHILD | WS_BORDER | TVS_HASLINES | <br>        TVS_HASBUTTONS | TVS_LINESATROOT, <br>        0, 0, 0, 0, hwnd, (HMENU)IDC_TV, g_hInstance, NULL); <br> <br>    // create our image list. <br>    DXView_InitImageList(); <br> <br>    // Initialize the tree view <br>    DXView_FillTree(g_hwndTV); <br> <br>    return(TRUE); <br>} <br> <br>//================================================================ <br>//================================================================ <br>IDirectDraw * DDCreate(GUID *pid) <br>{ <br>    if (lpDD &amp;&amp; pid == ddid) <br>        return lpDD; <br> <br>    if (lp3D) <br>    { <br>        IDirect3D2_Release(lp3D); <br>        lp3D = NULL; <br>    } <br> <br>    if (lpDD) <br>    { <br>        IDirectDraw_Release(lpDD); <br>        lpDD = NULL; <br>    } <br> <br>    // There is no need to create DirectDraw emulation-only just to get <br>    // the HEL caps.  In fact, this will fail if there is another DirectDraw <br>    // app running and using the hardware. <br>    if( pid == (GUID *)DDCREATE_EMULATIONONLY ) <br>    { <br>        pid = NULL; <br>    } <br>    if (DirectDrawCreate(pid, &amp;lpDD, NULL) == DD_OK) <br>    { <br>        IDirectDraw_QueryInterface(lpDD,&amp;IID_IDirect3D2,&amp;lp3D); <br>        ddid = pid; <br>        return lpDD; <br>    } <br>    if(!g_PrintToFile) <br>        MessageBox(g_hwndMain, "DirectDrawCreate failed.", g_szAppName, MB_OK); <br>    return NULL; <br>} <br> <br>//================================================================ <br>//================================================================ <br>IDirectSound * DSCreate(GUID *pid) <br>{ <br>PFN_DSCREATE pfn_DSCreate; <br> <br>    if (lpDS &amp;&amp; pid == dsid) <br>        return lpDS; <br> <br>    if (lpDS) <br>    { <br>        IDirectSound_Release(lpDS); <br>        lpDS = NULL; <br>    } <br> <br>// Call DirectSoundCreate. <br>pfn_DSCreate = (PFN_DSCREATE)GetProcAddress(g_hDSoundLib, "DirectSoundCreate"); <br>if (pfn_DSCreate == NULL) <br>{ <br>        MessageBox(g_hwndMain, "DSOUND.DLL does not implement DirectSoundCreate()", g_szAppName, MB_OK); <br>return NULL; <br>} <br> <br>if ((*pfn_DSCreate)(pid, &amp;lpDS, NULL) == DD_OK) <br>{ <br>dsid = pid; <br>return lpDS; <br>} <br> <br>    if(!g_PrintToFile) <br>        MessageBox(g_hwndMain, "DirectSoundCreate failed.", g_szAppName, MB_OK); <br>    return NULL; <br>} <br> <br>//================================================================ <br>//================================================================ <br>IDirectSoundCapture * DSCCreate(GUID *pid) <br>{ <br>PFN_DSCCREATE pfn_DSCCreate; <br> <br>    if (lpDSC &amp;&amp; pid == dsid) <br>        return lpDSC; <br> <br>    if (lpDSC) <br>    { <br>        IDirectSoundCapture_Release(lpDSC); <br>        lpDSC = NULL; <br>    } <br> <br>pfn_DSCCreate = (PFN_DSCCREATE)GetProcAddress(g_hDSoundLib, "DirectSoundCaptureCreate"); <br>if (pfn_DSCCreate == NULL) <br>{ <br>        MessageBox(g_hwndMain, "DSOUND.DLL does not implement DirectSoundCaptureCreate()", g_szAppName, MB_OK); <br>return NULL; <br>} <br> <br>if ((*pfn_DSCCreate)(pid, &amp;lpDSC, NULL) == DD_OK) <br>{ <br>        dscid = pid; <br>        return lpDSC; <br>} <br> <br>    if(!g_PrintToFile) <br>        MessageBox(g_hwndMain, "DirectSoundCaptureCreate failed.", g_szAppName, MB_OK); <br>    return NULL; <br>} <br> <br>//================================================================ <br>//================================================================ <br>IDirectPlay3 * DPCreate(GUID *pid) <br>{ <br>LPDIRECTPLAYlpDP = NULL; <br>HRESULThr; <br> <br>    if (lpDP3A &amp;&amp; pid == dpid) <br>        return lpDP3A; <br> <br>    if (lpDP3A) <br>{ <br>        lpDP3A-&gt;lpVtbl-&gt;Release(lpDP3A); <br>lpDP3A = NULL; <br>} <br> <br>    if (DirectPlayCreate(pid, &amp;lpDP, NULL) == DD_OK) <br>    { <br>        hr = lpDP-&gt;lpVtbl-&gt;QueryInterface( lpDP, &amp;IID_IDirectPlay3A, (LPVOID *) &amp;lpDP3A ); <br>lpDP-&gt;lpVtbl-&gt;Release(lpDP); <br>dpid = pid; <br>        return lpDP3A; <br>    } <br>    if(!g_PrintToFile) <br>        MessageBox(g_hwndMain, "DirectPlayCreate failed.", g_szAppName, MB_OK); <br>    return NULL; <br>} <br> <br>//================================================================ <br>//================================================================ <br>void AddCapsToTV(HTREEITEM hRoot, CAPDEFS *pcds, LPARAM lParam1) <br>{ <br>    HTREEITEM hTree; <br>    HTREEITEM hParent[20]; <br>    char *name; <br>    int level=0; <br>    BOOL fRoot = TRUE; // the first one is always a root <br> <br>    hParent[0] = hRoot; <br> <br>    while (name = pcds-&gt;szName) <br>    { <br>        if (*name == '-') <br>        { <br>            level--; <br>            name++; <br>        } <br> <br>        if (*name == '+') <br>        { <br>            fRoot = TRUE; <br>            name++; <br>        } <br> <br>        if (*name) <br>        { <br>            hTree = TVAddNode(hParent[level], name, fRoot, IDI_CAPS, <br>                              pcds-&gt;Callback, lParam1, <br>                              pcds-&gt;lParam2, pcds-&gt;printCallback); <br> <br>            if (fRoot) <br>            { <br>                level++; <br>                hParent[level] = hTree; <br>                fRoot = FALSE; <br>            } <br>        } <br> <br>        pcds++;  // Get next Cap bit definition <br>    } <br>} <br> <br>//================================================================ <br>//================================================================ <br>char c_szYes[] = "Yes"; <br>char c_szNo[] = "No"; <br>char c_szCurrentMode[] = "Current Mode"; <br> <br>//================================================================ <br>// AddMoreCapsToLV is like AddCapsToLV, except it doesn't add the <br>// column headers like AddCapsToLV does. <br>//================================================================ <br>void AddMoreCapsToLV(CAPDEF *pcd, LPVOID pv) <br>{ <br>    DWORD dwValue; <br> <br>    while(pcd-&gt;szName &amp;&amp; *pcd-&gt;szName) <br>    { <br>        dwValue = *(DWORD *)(((BYTE *)pv) + pcd-&gt;dwOffset); <br> <br>        if (pcd-&gt;dwFlag == 0) <br>        { <br>            LVAddText(g_hwndLV, 0, "%s", pcd-&gt;szName); <br>            LVAddText(g_hwndLV, 1, "%d", dwValue); <br>        } <br>        else if (pcd-&gt;dwFlag == 0xFFFFFFFF)     // hex <br>        { <br>            LVAddText(g_hwndLV, 0, "%s", pcd-&gt;szName); <br>            LVAddText(g_hwndLV, 1, "0x%08X", dwValue); <br>        } <br>        else <br>        { <br>            if (pcd-&gt;dwFlag &amp; dwValue) <br>            { <br>                LVAddText(g_hwndLV, 0, pcd-&gt;szName); <br>                LVAddText(g_hwndLV, 1, c_szYes); <br>            } <br>            else if (g_dwViewState == IDM_VIEWALL) <br>            { <br>                LVAddText(g_hwndLV, 0, pcd-&gt;szName); <br>                LVAddText(g_hwndLV, 1, c_szNo); <br>            } <br>        } <br> <br>        pcd++;  // Get next Cap bit definition <br>    } <br>} <br> <br> <br>//================================================================ <br>// AddColsToLV adds the column headers but no data. <br>//================================================================ <br>void AddColsToLV(void) <br>{ <br>    LVAddColumn(g_hwndLV, 0, "Name", 24); <br>    LVAddColumn(g_hwndLV, 1, "Value", 10); <br>} <br> <br>//================================================================ <br>//================================================================ <br>void AddCapsToLV(CAPDEF *pcd, LPVOID pv) <br>{ <br>    AddColsToLV(); <br>    AddMoreCapsToLV(pcd, pv); <br>} <br> <br>//================================================================ <br>//================================================================ <br>BOOL PrintCapsToDC(CAPDEF *pcd, LPVOID pv, PRINTCBINFO * lpInfo) <br>{ <br>    DWORD dwValue; <br>    DWORD cchLen; <br>    int   xName, xVal, yLine; <br> <br>    // Check Parameters <br>    if ((! pcd) || (!lpInfo)) <br>        return FALSE; <br> <br>    // Calculate Name and Value column x offsets <br>    xName   = (lpInfo-&gt;dwCurrIndent * DEF_TAB_SIZE * lpInfo-&gt;dwCharWidth); <br>    xVal    = xName + (32 * lpInfo-&gt;dwCharWidth); <br> <br>    while (pcd-&gt;szName &amp;&amp; *pcd-&gt;szName) <br>    { <br>        dwValue = *(DWORD *)(((BYTE *)pv) + pcd-&gt;dwOffset); <br>        yLine = lpInfo-&gt;dwCurrLine * lpInfo-&gt;dwLineHeight; <br> <br>        if (pcd-&gt;dwFlag) <br>        { <br>            if (pcd-&gt;dwFlag &amp; dwValue) <br>            { <br>                // Print Name <br>                cchLen = _tcslen (pcd-&gt;szName); <br>                if (! PrintLine (xName, yLine, pcd-&gt;szName, cchLen, lpInfo)) <br>                    return FALSE; <br> <br>                // Print Yes in value column <br>                cchLen = _tcslen (c_szYes); <br>                if (! PrintLine (xVal, yLine, c_szYes, cchLen, lpInfo)) <br>                    return FALSE; <br>         <br>                // Advance to next line on page <br>                if (! PrintNextLine (lpInfo)) <br>                    return FALSE; <br>            } <br>            else if (g_dwViewState == IDM_VIEWALL) <br>            { <br>                // Print name <br>                cchLen = _tcslen (pcd-&gt;szName); <br>                if (! PrintLine (xName, yLine, pcd-&gt;szName, cchLen, lpInfo)) <br>                    return FALSE; <br> <br>                // Print No in value column <br>                cchLen = _tcslen (c_szNo); <br>                if (! PrintLine (xVal, yLine, c_szNo, cchLen, lpInfo)) <br>                    return FALSE; <br> <br>                // Advance to next line on page <br>                if (! PrintNextLine (lpInfo)) <br>                    return FALSE; <br>            } <br>        } <br>        else <br>        { <br>            char    szBuff[80]; <br> <br>            // Print name <br>            wsprintf (szBuff, pcd-&gt;szName, "test"); <br>            cchLen = _tcslen (pcd-&gt;szName); <br>            if (! PrintLine (xName, yLine, szBuff, cchLen, lpInfo)) <br>                return FALSE; <br> <br>            // Print value <br>            wsprintf (szBuff, "%d", dwValue); <br>            cchLen = _tcslen (szBuff); <br>            if (! PrintLine (xVal, yLine, szBuff, cchLen, lpInfo)) <br>                return FALSE; <br> <br>            // Advance to next line on page <br>            if (! PrintNextLine (lpInfo)) <br>                return FALSE; <br>        } <br> <br>        pcd++;  // Get next Cap bit definition <br>    } <br> <br>    // Success <br>    return TRUE; <br>} // End PrintCapsToDC <br> <br> <br>//================================================================ <br>//================================================================ <br>void DDAddCaps(LPARAM lParam1, LPARAM lParam2) <br>{ <br>    // lParam1 is the GUID for the driver we should open <br>    // lParam2 is the CAPDEF table we should use <br> <br>    if (DDCreate((GUID*)lParam1)) <br>    { <br>        DDCAPS ddcaps; <br> <br>        ddcaps.dwSize = sizeof(ddcaps); <br> <br>        if (lParam1 == DDCREATE_EMULATIONONLY) <br>            IDirectDraw_GetCaps(lpDD, NULL, &amp;ddcaps); <br>        else <br>            IDirectDraw_GetCaps(lpDD, &amp;ddcaps, NULL); <br> <br>        AddCapsToLV((CAPDEF *)lParam2, (LPVOID)&amp;ddcaps); <br>    } <br>} <br> <br> <br>//================================================================ <br>//================================================================ <br>BOOL DDPrintCaps(LPARAM lParam1, LPARAM lParam2, PRINTCBINFO * lpInfo) <br>{ <br>    // lParam1 is the GUID for the driver we should open <br>    // lParam2 is the CAPDEF table we should use <br> <br>    if (DDCreate((GUID*)lParam1)) <br>    { <br>        DDCAPS ddcaps; <br> <br>        ddcaps.dwSize = sizeof(ddcaps); <br> <br>        if (lParam1 == DDCREATE_EMULATIONONLY) <br>            IDirectDraw_GetCaps(lpDD, NULL, &amp;ddcaps); <br>        else <br>            IDirectDraw_GetCaps(lpDD, &amp;ddcaps, NULL); <br> <br>        // Print DirectDraw caps <br>        return PrintCapsToDC((CAPDEF *)lParam2, (LPVOID)&amp;ddcaps, lpInfo); <br>    } <br> <br>    // DDCreate failed but keep printing <br>    return TRUE; <br>} <br> <br>//================================================================ <br>//================================================================ <br>void DSAddCaps(LPARAM lParam1, LPARAM lParam2) <br>{ <br>    // lParam1 is the GUID for the driver we should open <br>    // lParam2 is the CAPDEF table we should use <br> <br>    if (DSCreate((GUID*)lParam1)) <br>    { <br>        DSCAPS dscaps; <br> <br>        dscaps.dwSize = sizeof(dscaps); <br> <br>        IDirectSound_GetCaps(lpDS, &amp;dscaps); <br> <br>        AddCapsToLV((CAPDEF *)lParam2, (LPVOID)&amp;dscaps); <br>    } <br>} <br> <br> <br>//================================================================ <br>//================================================================ <br>BOOL DSPrintCaps(LPARAM lParam1, LPARAM lParam2, PRINTCBINFO * lpInfo) <br>{ <br>    // lParam1 is the GUID for the driver we should open <br>    // lParam2 is the CAPDEF table we should use <br> <br>    if (DSCreate((GUID*)lParam1)) <br>    { <br>        DSCAPS dscaps; <br> <br>        dscaps.dwSize = sizeof(dscaps); <br> <br>        IDirectSound_GetCaps(lpDS, &amp;dscaps); <br> <br>        // Print DirectSound Caps <br>        return PrintCapsToDC((CAPDEF *)lParam2, (LPVOID)&amp;dscaps, lpInfo); <br>    } <br> <br>    // DSCreate failed but keep printing <br>    return TRUE; <br>} <br> <br> <br>//================================================================ <br>//================================================================ <br>void DSCAddCaps(LPARAM lParam1, LPARAM lParam2) <br>{ <br>    // lParam1 is the GUID for the driver we should open <br>    // lParam2 is the CAPDEF table we should use <br> <br>    if (DSCCreate((GUID*)lParam1)) <br>    { <br>        DSCCAPS dsccaps; <br> <br>        dsccaps.dwSize = sizeof(dsccaps); <br> <br>        IDirectSoundCapture_GetCaps(lpDSC, &amp;dsccaps); <br> <br>        AddCapsToLV((CAPDEF *)lParam2, (LPVOID)&amp;dsccaps); <br>    } <br>} <br> <br> <br>//================================================================ <br>//================================================================ <br>BOOL DSCPrintCaps(LPARAM lParam1, LPARAM lParam2, PRINTCBINFO * lpInfo) <br>{ <br>    // lParam1 is the GUID for the driver we should open <br>    // lParam2 is the CAPDEF table we should use <br> <br>    if (DSCCreate((GUID*)lParam1)) <br>    { <br>        DSCCAPS dsccaps; <br> <br>        dsccaps.dwSize = sizeof(dsccaps); <br> <br>        IDirectSoundCapture_GetCaps(lpDSC, &amp;dsccaps); <br> <br>        // Print DirectSound Caps <br>        return PrintCapsToDC((CAPDEF *)lParam2, (LPVOID)&amp;dsccaps, lpInfo); <br>    } <br> <br>    // DSCCreate failed but keep printing <br>    return TRUE; <br>} <br> <br> <br>//================================================================ <br>//================================================================ <br>void DPAddCaps(LPARAM lParam1, LPARAM lParam2) <br>{ <br>    // lParam1 is the GUID for the driver we should open <br>    // lParam2 is the CAPDEF table we should use <br>HRESULT hr = DPERR_GENERIC; <br> <br>CAPDEF * pcd = (CAPDEF *) lParam2; <br> <br>    if ( DPCreate( (GUID*) lParam1) ) <br>    { <br>        DPCAPSdpcaps, <br>dpcapsGuar; <br>DWORDdwValue, <br>dwValueGuar; <br> <br>memset(&amp;dpcaps, 0, sizeof(DPCAPS)); <br>memset(&amp;dpcapsGuar, 0, sizeof(DPCAPS)); <br> <br>        dpcaps.dwSize = sizeof(DPCAPS); <br>        dpcapsGuar.dwSize = sizeof(DPCAPS); <br> <br>        hr = lpDP3A-&gt;lpVtbl-&gt;GetCaps(lpDP3A, &amp;dpcapsGuar, DPGETCAPS_GUARANTEED); <br> <br>if (FAILED(hr)) <br>{ <br>return; <br>} <br> <br>        lpDP3A-&gt;lpVtbl-&gt;GetCaps(lpDP3A, &amp;dpcaps, 0); <br> <br>if (FAILED(hr)) <br>{ <br>return; <br>} <br> <br>LVAddColumn(g_hwndLV, 0, "Name", 24); <br>LVAddColumn(g_hwndLV, 1, "Non-guaranteed", 16); <br>LVAddColumn(g_hwndLV, 2, "Guaranteed", 16); <br> <br>while(pcd-&gt;szName &amp;&amp; *pcd-&gt;szName) <br>{ <br>dwValue = *((DWORD *)((BYTE *)&amp;dpcaps + pcd-&gt;dwOffset)); <br>dwValueGuar = *((DWORD *)((BYTE *)&amp;dpcapsGuar + pcd-&gt;dwOffset)); <br> <br>LVAddText(g_hwndLV, 0, pcd-&gt;szName, "test"); <br>LVAddText(g_hwndLV, 1, "%d", dwValue); <br>LVAddText(g_hwndLV, 2, "%d", dwValueGuar); <br>pcd++;  // Get next Cap bit definition <br>} <br> <br>LVAddText( g_hwndLV, 0, "Group Optimized" ); <br>LVAddText( g_hwndLV, 1, ( dpcaps.dwFlags &amp; DPCAPS_GROUPOPTIMIZED ? c_szYes : c_szNo ) ); <br>LVAddText( g_hwndLV, 2, ( dpcapsGuar.dwFlags &amp; DPCAPS_GROUPOPTIMIZED ? c_szYes : c_szNo ) ); <br> <br>LVAddText( g_hwndLV, 0, "Guaranteed Optimized" ); <br>LVAddText( g_hwndLV, 1, ( dpcaps.dwFlags &amp; DPCAPS_GUARANTEEDOPTIMIZED ? c_szYes : c_szNo ) ); <br>LVAddText( g_hwndLV, 2, ( dpcapsGuar.dwFlags &amp; DPCAPS_GUARANTEEDOPTIMIZED ? c_szYes : c_szNo ) ); <br> <br>LVAddText( g_hwndLV, 0, "Guaranteed Supported" ); <br>LVAddText( g_hwndLV, 1, ( dpcaps.dwFlags &amp; DPCAPS_GUARANTEEDSUPPORTED ? c_szYes : c_szNo ) ); <br>LVAddText( g_hwndLV, 2, ( dpcapsGuar.dwFlags &amp; DPCAPS_GUARANTEEDSUPPORTED ? c_szYes : c_szNo) ); <br> <br>LVAddText( g_hwndLV, 0, "Keep Alive Optimized" ); <br>LVAddText( g_hwndLV, 1, ( dpcaps.dwFlags &amp; DPCAPS_KEEPALIVEOPTIMIZED ? c_szYes : c_szNo ) ); <br>LVAddText( g_hwndLV, 2, ( dpcapsGuar.dwFlags &amp; DPCAPS_KEEPALIVEOPTIMIZED ? c_szYes : c_szNo ) ); <br> <br>lpDP3A-&gt;lpVtbl-&gt;Release(lpDP3A); <br>lpDP3A = NULL; <br> <br>    } <br>} <br> <br>//================================================================ <br>//================================================================ <br>BOOL FAR PASCAL DPEnumLocalAppsCallback( LPCDPLAPPINFO lpAppInfo, LPVOID lpContext, DWORD dwFlags) <br>{ <br>LPLOCALAPP * lp = (LPLOCALAPP *) lpContext; <br>LPLOCALAPP lpTemp = NULL; <br>WCHAR wszBuffer[128]; <br> <br> <br>if (StringFromGUID2( &amp;(lpAppInfo-&gt;guidApplication), wszBuffer, 128 )) <br>{ <br>char szBuffer[128]; <br> <br>    wcstombs(szBuffer, wszBuffer, wcslen(wszBuffer)+1); <br>if (g_hwndLV) <br>{ <br>//when we are called the first time,  <br>//the listview hasn't been created yet. <br>LVAddText(g_hwndLV, 0, lpAppInfo-&gt;lpszAppNameA); <br>LVAddText(g_hwndLV, 1, szBuffer); <br>} <br>} <br> <br>//Add to our local linked list of app names. <br>//This list is used to provide the app names when we <br>//enumerate sessions later. <br>lpTemp = *lp; <br>*lp = (LPLOCALAPP) LocalAlloc( LPTR, sizeof( LOCALAPP )+strlen(lpAppInfo-&gt;lpszAppNameA)+1 ); <br> <br>if (*lp) <br>{ <br>(*lp)-&gt;guidApplication = lpAppInfo-&gt;guidApplication; <br>strcpy( (*lp)-&gt;szAppNameA, lpAppInfo-&gt;lpszAppNameA ); <br>(*lp)-&gt;lpNext = lpTemp; <br>} <br> <br>return TRUE; <br>} <br> <br> <br>//================================================================ <br>//================================================================ <br>void DPAddLocalApps(LPARAM lParam1, LPARAM lParam2) <br>{ <br>    // lParam1 is the GUID for the driver we should open <br>    // lParam2 is the CAPDEF table we should use <br> <br>LPDIRECTPLAYLOBBYAlpDPLA= NULL; <br>HRESULThr= DPERR_GENERIC; <br>    if (g_lpLocalApp) <br>{ <br>FreeLocalAppList(); <br>g_lpLocalApp = NULL; <br>} <br> <br>if ( g_hwndLV) <br>{ <br>//When we are called the first time, <br>//the list view has not been created yet. <br>LVAddColumn(g_hwndLV, 0, "Name", 16); <br>LVAddColumn(g_hwndLV, 1, "guidApplication", 48); <br>} <br> <br>    hr = DirectPlayLobbyCreateA(NULL, &amp;lpDPLA, NULL, NULL, 0 ); <br> <br>if (SUCCEEDED(hr)) <br>{ <br>lpDPLA-&gt;lpVtbl-&gt;EnumLocalApplications(lpDPLA, DPEnumLocalAppsCallback, &amp;g_lpLocalApp, 0 ); <br>lpDPLA-&gt;lpVtbl-&gt;Release(lpDPLA); <br>} <br> <br>} <br> <br> <br>//================================================================ <br>//================================================================ <br>BOOL FAR PASCAL DPEnumLocalAppsPrintCallback( LPCDPLAPPINFO lpAppInfo, LPVOID lpContext, DWORD dwFlags) <br>{ <br>    intxName,  <br>xGuid, <br>yLine; <br>    PRINTCBINFO * lpInfo = (PRINTCBINFO *) lpContext; <br>    DWORD cchLen; <br>WCHAR wszBuffer[128]; <br>char szBuffer[128]; <br> <br>     <br>    if (! lpInfo) <br>        return FALSE; <br> <br>    if (dwFlags &amp; DPESC_TIMEDOUT) <br>    { <br>        // We could reset lpdwTimeOut and return true to continue waiting <br>        // NOTE: This does not tell DirectPlay to query again for hosts. <br>        //       This just gives potentially slow hosts more time to respond <br>        //       to our initial query. <br>        return FALSE;  // Stop waiting for hosts <br>    } <br> <br>    xName   = (lpInfo-&gt;dwCurrIndent * DEF_TAB_SIZE * lpInfo-&gt;dwCharWidth); <br>    xGuid   = xName + (24 * lpInfo-&gt;dwCharWidth); <br>    yLine   = (lpInfo-&gt;dwCurrLine * lpInfo-&gt;dwLineHeight); <br> <br>    // Print AppInfo information <br> <br>cchLen = strlen (lpAppInfo-&gt;lpszAppNameA); <br>if (! PrintLine (xName, yLine, lpAppInfo-&gt;lpszAppNameA, cchLen, lpInfo)) <br>return FALSE; <br> <br>if (StringFromGUID2( &amp;(lpAppInfo-&gt;guidApplication), wszBuffer, 128 )) <br>{ <br>    wcstombs(szBuffer, wszBuffer, wcslen(wszBuffer)+1); <br>  <br>if (! PrintLine (xGuid, yLine, szBuffer, strlen(szBuffer), lpInfo)) <br>return FALSE; <br> <br>// Advance printer one line <br>if (! PrintNextLine (lpInfo)) <br>return FALSE; <br> <br>} <br> <br>return TRUE; <br>} <br> <br> <br>//================================================================ <br>//================================================================ <br>BOOL DPPrintLocalApps(LPARAM lParam1, LPARAM lParam2, PRINTCBINFO * lpInfo) <br>{ <br>    // lParam1 is the GUID for the driver we should open <br>    // lParam2 is the CAPDEF table we should use <br> <br>LPDIRECTPLAYLOBBYAlpDPLA = NULL; <br> <br> <br>    DirectPlayLobbyCreateA(NULL, &amp;lpDPLA, NULL, NULL, 0 ); <br> <br>if (lpDPLA) <br>{ <br>lpDPLA-&gt;lpVtbl-&gt;EnumLocalApplications(lpDPLA,  <br>DPEnumLocalAppsPrintCallback,  <br>(LPVOID)lpInfo,  <br>0 ); <br>lpDPLA-&gt;lpVtbl-&gt;Release(lpDPLA); <br>    } <br> <br>    // DPLobbyCreate failed but keep printing <br>    return TRUE; <br>} <br> <br> <br>//================================================================ <br>//================================================================ <br>BOOL DPPrintCaps(LPARAM lParam1, LPARAM lParam2, PRINTCBINFO * lpInfo) <br>{ <br>    // lParam1 is the GUID for the driver we should open <br>    // lParam2 is the CAPDEF table we should use <br> <br>    if (DPCreate((GUID*)lParam1)) <br>    { <br>        DPCAPS dpcaps; <br>BOOLbKeepPrinting; <br>HRESULThr = DPERR_GENERIC; <br>int xName, <br>xGuid, <br>yLine; <br> <br>        dpcaps.dwSize = sizeof(dpcaps); <br>        hr = lpDP3A-&gt;lpVtbl-&gt;GetCaps(lpDP3A, &amp;dpcaps, 0); <br> <br>if (FAILED(hr)) <br>{ <br>// GetCaps failed but keep printing <br>return TRUE; <br>} <br> <br>// Advance printer one line <br>if (! PrintNextLine (lpInfo)) <br>return FALSE; <br> <br>xName   = (lpInfo-&gt;dwCurrIndent * DEF_TAB_SIZE * lpInfo-&gt;dwCharWidth); <br>xGuid   = xName + (24 * lpInfo-&gt;dwCharWidth); <br>yLine   = (lpInfo-&gt;dwCurrLine * lpInfo-&gt;dwLineHeight); <br> <br>if (! PrintLine (xName, yLine, "Non-guaranteed", 14, lpInfo)) <br>return FALSE; </code></pre>
<p>
</p>
<pre><code><br>// Advance printer one line <br>if (! PrintNextLine (lpInfo)) <br>return FALSE; <br> <br>// Advance printer one line <br>if (! PrintNextLine (lpInfo)) <br>return FALSE; <br> <br>        bKeepPrinting = PrintCapsToDC ((CAPDEF *)lParam2, (LPVOID)&amp;dpcaps, lpInfo); <br> <br>// Advance printer one line <br>if (! PrintNextLine (lpInfo)) <br>return FALSE; <br>// Advance printer one line <br>if (! PrintNextLine (lpInfo)) <br>return FALSE; <br> <br>if (bKeepPrinting) <br>{ <br>        hr = lpDP3A-&gt;lpVtbl-&gt;GetCaps(lpDP3A, &amp;dpcaps, DPGETCAPS_GUARANTEED ); <br>if (FAILED(hr)) <br>{ <br>// GetCaps failed but keep printing <br>return TRUE; <br>} <br> <br>xName   = (lpInfo-&gt;dwCurrIndent * DEF_TAB_SIZE * lpInfo-&gt;dwCharWidth); <br>xGuid   = xName + (24 * lpInfo-&gt;dwCharWidth); <br>yLine   = (lpInfo-&gt;dwCurrLine * lpInfo-&gt;dwLineHeight); <br> <br>if (! PrintLine (xName, yLine, "Guaranteed", 10, lpInfo)) <br>return FALSE; <br> <br>// Advance printer one line <br>if (! PrintNextLine (lpInfo)) <br>return FALSE; <br> <br>// Advance printer one line <br>if (! PrintNextLine (lpInfo)) <br>return FALSE; <br> <br>// Print DirectPlay caps <br>bKeepPrinting = PrintCapsToDC ((CAPDEF *)lParam2, (LPVOID)&amp;dpcaps, lpInfo); <br> <br>// Advance printer one line <br>if (! PrintNextLine (lpInfo)) <br>return FALSE; <br>} <br> <br>return bKeepPrinting; <br>    } <br> <br>    // DPCreate failed but keep printing <br>    return TRUE; <br>} <br> <br>//================================================================ <br>//================================================================ <br>void D3AddCaps(LPARAM lParam1, LPARAM lParam2) <br>{ <br>    // lParam1 is the CAP3DDEVICEDESC Struct <br>    // lParam2 is the CAPDEF table we should use <br> <br>    // Unlike other AddCaps function this info has been prethought for us <br>    // so just print it out. <br>    AddCapsToLV((CAPDEF *)lParam2, (LPVOID)lParam1); <br>} <br> <br>//================================================================ <br>//================================================================ <br>void D3AddLineCaps(LPARAM lParam1, LPARAM lParam2) <br>{ <br>    // lParam1 is the CAP3DDEVICEDESC Struct <br>    // lParam2 is the CAPDEF table we should use <br> <br>    CAP3DDEVICEDESC *p = (CAP3DDEVICEDESC*)lParam1; <br>    D3DPRIMCAPS     save; <br> <br>    // slam the line caps over the triangle caps so we can use the <br>    // same tables <br>    save = p-&gt;d3dDeviceDesc.dpcTriCaps; <br>    p-&gt;d3dDeviceDesc.dpcTriCaps = p-&gt;d3dDeviceDesc.dpcLineCaps; <br>    AddCapsToLV((CAPDEF *)lParam2, (LPVOID)lParam1); <br>    p-&gt;d3dDeviceDesc.dpcTriCaps = save; <br>} <br> <br>//================================================================ <br>//================================================================ <br> <br>int BitCount(DWORD dw) <br>{ <br>    int i; <br> <br>    for (i=0; dw; dw=dw&gt;&gt;1) <br>        i += (dw &amp; 1); <br> <br>    return i; <br>} <br> <br>//================================================================ <br>//================================================================ <br>HRESULT CALLBACK EnumTextureCallback(DDSURFACEDESC *pddsd, LPVOID lParam) <br>{ <br>    DDPIXELFORMAT ddpf = pddsd-&gt;ddpfPixelFormat; <br>    TCHAR ach[80]; <br> <br>    if (ddpf.dwRBitMask == 0 &amp;&amp; ddpf.dwGBitMask == 0 &amp;&amp; ddpf.dwBBitMask == 0) <br>        wsprintf(ach, "%d bit", ddpf.dwRGBBitCount); <br>    else if (BitCount(ddpf.dwRGBAlphaBitMask) == 0) <br>        wsprintf(ach, "%d bit %d%d%d", <br>            ddpf.dwRGBBitCount, <br>            BitCount(ddpf.dwRBitMask), <br>            BitCount(ddpf.dwGBitMask), <br>            BitCount(ddpf.dwBBitMask)); <br>    else <br>        wsprintf(ach, "%d bit %d%d%d%d", <br>            ddpf.dwRGBBitCount, <br>            BitCount(ddpf.dwRBitMask), <br>            BitCount(ddpf.dwGBitMask), <br>            BitCount(ddpf.dwBBitMask), <br>            BitCount(ddpf.dwRGBAlphaBitMask)); <br> <br>    LVAddText(g_hwndLV, 0, ach); <br> <br>    ach[0] = 0; <br> <br>    if (ddpf.dwFlags &amp; DDPF_RGB) <br>        lstrcat(ach,"RGB "); <br>    if (ddpf.dwFlags &amp; DDPF_YUV) <br>        lstrcat(ach,"YUV "); <br>    if (ddpf.dwFlags &amp; DDPF_PALETTEINDEXED8) <br>        lstrcat(ach,"PAL8 "); <br>    if (ddpf.dwFlags &amp; DDPF_PALETTEINDEXED4) <br>        lstrcat(ach,"PAL4 "); <br>    if (ddpf.dwFlags &amp; DDPF_ALPHA) <br>        lstrcat(ach,"ALPHA "); <br>    if (ddpf.dwFlags &amp; DDPF_ALPHAPIXELS) <br>        lstrcat(ach,"ALPHAPIXELS "); <br> <br>    LVAddText(g_hwndLV, 1, ach); <br> <br>    return DDENUMRET_OK; <br>} <br> <br>//================================================================ <br>//================================================================ <br> <br>void D3AddTexF(LPARAM lParam1, LPARAM lParam2) <br>{ <br>    // lParam1 is the CAP3DDEVICEDESC Struct <br>    // lParam2 is 0 <br> <br>    CAP3DDEVICEDESC *p = (CAP3DDEVICEDESC*)lParam1; <br> <br>    // <br>    // this is going to be tricky <br>    // to enum the texture formats we are going to need <br>    // a Direct3DDevice, to get a device we need a surface <br>    // to get a surface we might need to chage the video mode! <br>    // also to create a device we will need a palette in 8 bpp modes! <br>    // mabey we should just use the primary surface? <br>    // <br>    if (DDCreate(p-&gt;device) &amp;&amp; lp3D) <br>    { <br>        IDirectDrawSurface *Surface=NULL; <br>        IDirectDrawPalette *Palette=NULL; <br>        IDirect3DDevice2   *Device=NULL; <br> <br>        DDSURFACEDESC ddsd; <br>        ZeroMemory(&amp;ddsd, sizeof(ddsd)); <br> <br>        ddsd.dwSize = sizeof(ddsd); <br>        ddsd.dwFlags = DDSD_CAPS; <br>        ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE | DDSCAPS_3DDEVICE; // | DDSCAPS_VIDEOMEMORY; <br> <br>        IDirectDraw_SetCooperativeLevel(lpDD, g_hwndMain, DDSCL_FULLSCREEN | DDSCL_EXCLUSIVE | DDSCL_NOWINDOWCHANGES); <br>        IDirectDraw_CreateSurface(lpDD, &amp;ddsd, &amp;Surface, NULL); <br>        IDirectDraw_SetCooperativeLevel(lpDD, g_hwndMain, DDSCL_NORMAL); <br> <br>        if (Surface) <br>        { <br>            // <br>            // before we can create a 3D device, we need to <br>            // attach a palette (8 bpp modes only) <br>            // <br>            IDirectDrawSurface_GetSurfaceDesc(Surface, &amp;ddsd); <br> <br>            if (ddsd.ddpfPixelFormat.dwRGBBitCount == 8) <br>            { <br>                HDC hdc; <br>                PALETTEENTRY ape[256]; <br> <br>                hdc = GetDC(NULL); <br>                GetSystemPaletteEntries(hdc, 0, 256, ape); <br>                ReleaseDC(NULL, hdc); <br> <br>                IDirectDraw_CreatePalette(lpDD, DDPCAPS_8BIT, ape, &amp;Palette, NULL); <br> <br>                if (Palette) <br>                { <br>                    IDirectDrawSurface_SetPalette(Surface, Palette); <br>                } <br>            } <br>        } <br> <br>        if (Surface) <br>        { <br>            IDirect3D2_CreateDevice(lp3D, &amp;p-&gt;driver, Surface, &amp;Device); <br> <br>            if (Device == NULL) <br>            { <br>                IDirectDrawSurface_Release(Surface); <br>                Surface = NULL; <br> <br>                // <br>                // we cant create a 3d device for the primary, create a <br>                // 555 offscreen surface and try that <br>                // <br>                ddsd.dwSize = sizeof(ddsd); <br>                ddsd.dwFlags = DDSD_CAPS | DDSD_PIXELFORMAT | DDSD_HEIGHT | DDSD_WIDTH; <br>                ddsd.dwWidth = 100; <br>                ddsd.dwHeight = 100; <br>                ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN | DDSCAPS_3DDEVICE | DDSCAPS_VIDEOMEMORY; <br>                ddsd.ddpfPixelFormat.dwSize            = sizeof(DDPIXELFORMAT); <br>                ddsd.ddpfPixelFormat.dwFlags           = DDPF_RGB; <br>                ddsd.ddpfPixelFormat.dwFourCC          = 0; <br>                ddsd.ddpfPixelFormat.dwRGBBitCount     = 16; <br>                ddsd.ddpfPixelFormat.dwRBitMask        = 0x7C00; // 0xF800; <br>                ddsd.ddpfPixelFormat.dwGBitMask        = 0x03E0; // 0x07E0; <br>                ddsd.ddpfPixelFormat.dwBBitMask        = 0x001F; // 0x001F; <br>                ddsd.ddpfPixelFormat.dwRGBAlphaBitMask = 0x0000; <br> <br>                IDirectDraw_CreateSurface(lpDD, &amp;ddsd, &amp;Surface, NULL); <br> <br>                if (Surface != NULL) <br>                { <br>                    IDirect3D2_CreateDevice(lp3D, &amp;p-&gt;driver, Surface, &amp;Device); <br>                } <br>            } <br> <br>            if (Device) <br>            { <br>                LVAddColumn(g_hwndLV, 0, "Format", 24); <br>                LVAddColumn(g_hwndLV, 1, "Flags", 24); <br> <br>                IDirect3DDevice2_EnumTextureFormats(Device, EnumTextureCallback, NULL); <br>                IDirect3DDevice2_Release(Device); <br>            } <br>            else <br>            { <br>                LVAddColumn(g_hwndLV, 0, "Message", 50); <br>                LVAddText(g_hwndLV, 0, "Cant create D3D Device, change display mode."); <br>            } <br> <br>            if (Surface) <br>            { <br>                IDirectDrawSurface_Release(Surface); <br>            } <br> <br>            if (Palette) <br>            { <br>                IDirectDrawPalette_Release(Palette); <br>            } <br>        } <br>        else <br>        { <br>            LVAddColumn(g_hwndLV, 0, "Message", 50); <br>            LVAddText(g_hwndLV, 0, "Cant create surface."); <br>        } <br>    } <br>} <br> <br>//================================================================ <br>//================================================================ <br>BOOL D3PrintCaps(LPARAM lParam1, LPARAM lParam2, PRINTCBINFO * lpInfo) <br>{ <br>    // lParam1 is the CAP3DDEVICEDESC Struct <br>    // lParam2 is the CAPDEF table we should use <br> <br>    // Unlike other PrintCaps function this info has been prethought for us <br>    // so just print it out. <br>    return PrintCapsToDC ((CAPDEF *)lParam2, (LPVOID)lParam1, lpInfo); <br>} <br> <br>//================================================================ <br>// EnumSessionsCallback <br>//================================================================ <br>BOOL PASCAL EnumSessionsCallback <br>( <br>LPCDPSESSIONDESC2 lpDesc,         // Pointer to Session Description Struct <br>LPDWORD lpdwTimeOut,          // Used to extend the timeout if hosts aren't responding quickly enough. <br>DWORD dwFlags,                 // Flags (used to notify us when we've timed out). <br>LPVOIDlpContext <br>) <br>{ <br>BOOLbDataAvailable; <br>charszBuffer[128]; <br>DWORDdwSize= 128; <br>LPLV_INSTANCEGUIDSTRUCTlpInstGuidStruct = NULL; <br>LV_ITEMlvi; <br> <br>inti, count; <br>BOOLbGuidNotFound; <br> <br>memset( &amp;lvi, 0, sizeof( LV_ITEM )); <br> <br>    if (dwFlags &amp; DPESC_TIMEDOUT) <br>    { <br>        // We could reset lpdwTimeOut and return true to continue waiting <br>        // NOTE: This does not tell DirectPlay to query again for hosts. <br>        //       This just gives potentially slow hosts more time to respond <br>        //       to our initial query. <br>        return FALSE;  // Stop waiting for hosts <br>    } <br> <br>i = 0; <br>count = ListView_GetItemCount( g_hwndLV ); <br>bGuidNotFound = TRUE; <br> <br>while ((bGuidNotFound) &amp;&amp; ( i &lt; count)) <br>{ <br>lvi.iItem = i; <br>lvi.mask = LVIF_PARAM; <br>lvi.lParam = 0; <br> <br>bDataAvailable =ListView_GetItem( g_hwndLV, &amp;lvi ); <br> <br>if (bDataAvailable) <br>{ <br>lpInstGuidStruct = (LPLV_INSTANCEGUIDSTRUCT) lvi.lParam; <br> <br>if (lpInstGuidStruct) <br>{ <br>if ( IsEqualGUID(&amp;(lpDesc-&gt;guidInstance), <br>&amp;(lpInstGuidStruct-&gt;guidInstance) ) ) <br>{ <br>//This session is already in our list. Mark that it is active, <br>//so it doesn't get deleted when the next timer fires. <br>lpInstGuidStruct-&gt;dwRefresh = TRUE; <br>bGuidNotFound = FALSE; <br>} <br>} <br>else <br>{ <br>//This item has no pointer to a guidInstance, it must be invalid. <br>ListView_DeleteItem( g_hwndLV, i); <br>} <br>} <br>else <br>{ <br>//This item has no data, so it must be invalid. <br>ListView_DeleteItem( g_hwndLV, i); <br>} <br> <br>i++; <br>} <br> <br>    if (bGuidNotFound) <br>{ <br>// This session was in our list view.  <br>// Add new session information to table <br>i = LVAddText(g_hwndLV, 0, ( lpDesc-&gt;lpszSessionNameA ? lpDesc-&gt;lpszSessionNameA : "&lt;NO SESSION NAME&gt;" ) ); <br> <br>GetAppName(szBuffer, &amp;(lpDesc-&gt;guidApplication), dwSize); <br>LVAddText(g_hwndLV, 1, szBuffer); <br> <br>LVAddText(g_hwndLV, 2, "%d", lpDesc-&gt;dwMaxPlayers); <br>LVAddText(g_hwndLV, 3, "%d", lpDesc-&gt;dwCurrentPlayers); <br>LVAddText(g_hwndLV, 4, (lpDesc-&gt;dwFlags&amp;DPSESSION_SECURESERVER ? c_szYes : c_szNo ) ); <br>LVAddText(g_hwndLV, 5, (lpDesc-&gt;dwFlags&amp;DPSESSION_PASSWORDREQUIRED ? c_szYes : c_szNo )); <br> <br>//Keep track of our guidInstance so we'll recognize this session <br>//when we enumerate later <br>lpInstGuidStruct = (LPLV_INSTANCEGUIDSTRUCT) LocalAlloc( LPTR, sizeof(LV_INSTANCEGUIDSTRUCT)); <br> <br>if (lpInstGuidStruct) <br>{ <br>LV_ITEMlvi; <br>memset( &amp;lvi, 0, sizeof( LV_ITEM)); <br>lpInstGuidStruct-&gt;guidInstance = lpDesc-&gt;guidInstance; <br>lpInstGuidStruct-&gt;dwRefresh = TRUE; <br> <br>lvi.iItem = i; <br>lvi.mask = LVIF_PARAM; <br>lvi.lParam = (long) lpInstGuidStruct; <br>   <br>ListView_SetItem( g_hwndLV, (LPARAM)&amp;lvi, );  <br>} <br>} <br> <br>    //Keep enumerating until it times out on its own. <br>return TRUE; <br>} <br> <br> <br>//================================================================ <br>// EnumPrintSessionsCallback <br>//================================================================ <br>BOOL PASCAL EnumPrintSessionsCallback  <br>( <br>    LPCDPSESSIONDESC2 lpDesc,         // Pointer to Session Description Struct <br>    LPDWORD         lpdwTimeOut,    // Used to extend the timeout if hosts aren't responding quickly enough. <br>    DWORD           dwFlags,         // Flags (used to notify us when we've timed out). <br>    LPVOID          lpContext         // User definable data passed in from EnumSessions() call. <br>) <br>{ <br>    int xName,  yLine; <br>    PRINTCBINFO * lpInfo = (PRINTCBINFO *) lpContext; <br>    CHAR szBuff[256], <br> szAppName[128]; <br>    DWORD cchLen; <br>     <br>    if (! lpInfo) <br>        return FALSE; <br> <br>    if (dwFlags &amp; DPESC_TIMEDOUT) <br>    { <br>        // We could reset lpdwTimeOut and return true to continue waiting <br>        // NOTE: This does not tell DirectPlay to query again for hosts. <br>        //       This just gives potentially slow hosts more time to respond <br>        //       to our initial query. <br>        return FALSE;  // Stop waiting for hosts <br>    } <br> <br>    xName   = (lpInfo-&gt;dwCurrIndent * DEF_TAB_SIZE * lpInfo-&gt;dwCharWidth); <br>    yLine   = (lpInfo-&gt;dwCurrLine * lpInfo-&gt;dwLineHeight); <br> <br>    // Print session information <br>    wsprintf (szBuff, "Session Name   : %s", lpDesc-&gt;lpszSessionNameA); <br>    cchLen = strlen (szBuff); <br>    if (! PrintLine (xName, yLine, szBuff, cchLen, lpInfo)) <br>        return FALSE; <br>    if (! PrintNextLine (lpInfo)) <br>        return FALSE; <br> <br>    yLine   = (lpInfo-&gt;dwCurrLine * lpInfo-&gt;dwLineHeight); <br>GetAppName( szAppName, &amp;(lpDesc-&gt;guidApplication), 128 ); <br>    wsprintf (szBuff, "App Name/GUID  : %s", szAppName); <br>cchLen = strlen (szBuff); <br>    if (! PrintLine (xName, yLine, szBuff, cchLen, lpInfo)) <br>        return FALSE; <br>    if (! PrintNextLine (lpInfo)) <br>        return FALSE; <br> <br>    yLine   = (lpInfo-&gt;dwCurrLine * lpInfo-&gt;dwLineHeight); <br>    wsprintf (szBuff, "Max Players    : %d", lpDesc-&gt;dwMaxPlayers); <br>    cchLen = strlen (szBuff); <br>    if (! PrintLine (xName, yLine, szBuff, cchLen, lpInfo)) <br>        return FALSE; <br>    if (! PrintNextLine (lpInfo)) <br>        return FALSE; <br> <br>    yLine   = (lpInfo-&gt;dwCurrLine * lpInfo-&gt;dwLineHeight); <br>    wsprintf (szBuff, "Cur Players    : %d", lpDesc-&gt;dwCurrentPlayers); <br>    cchLen = strlen (szBuff); <br>if (! PrintLine (xName, yLine, szBuff, cchLen, lpInfo)) <br>        return FALSE; <br>    if (! PrintNextLine (lpInfo)) <br>        return FALSE; <br> <br>    yLine   = (lpInfo-&gt;dwCurrLine * lpInfo-&gt;dwLineHeight); <br> wsprintf (szBuff, "Secure Session : %s",(lpDesc-&gt;dwFlags&amp;DPSESSION_SECURESERVER ? c_szYes : c_szNo ) );  <br>    cchLen = strlen (szBuff); <br>if (! PrintLine (xName, yLine, szBuff, cchLen, lpInfo)) <br>        return FALSE; <br>    if (! PrintNextLine (lpInfo)) <br>        return FALSE; <br> <br>   <br>    yLine   = (lpInfo-&gt;dwCurrLine * lpInfo-&gt;dwLineHeight); <br> wsprintf (szBuff, "Password Req'd : %s",(lpDesc-&gt;dwFlags&amp;DPSESSION_PASSWORDREQUIRED  ? c_szYes : c_szNo ) );  <br>    cchLen = strlen (szBuff); <br>if (! PrintLine (xName, yLine, szBuff, cchLen, lpInfo)) <br>        return FALSE; <br>    if (! PrintNextLine (lpInfo)) <br>        return FALSE; <br> <br>// Advance printer one line <br>    if (! PrintNextLine (lpInfo)) <br>        return FALSE; <br> <br>    // Success <br>    return TRUE; <br>} <br> <br>//================================================================ <br>//================================================================ <br>void DPAddSessions(LPARAM lParam1, LPARAM lParam2) <br>{ <br>    // lParam1 is the GUID for the driver we should open <br>    // lParam2 is the CAPDEF table we should use <br>HRESULThr = DPERR_GENERIC; <br> <br>    if (DPCreate((GUID*)lParam1)) <br>    { <br>        LVAddColumn(g_hwndLV, 0, "Session Name", 16); <br>        LVAddColumn(g_hwndLV, 1, "Application Name/GUID", 24); <br>        LVAddColumn(g_hwndLV, 2, "Max", 4); <br>        LVAddColumn(g_hwndLV, 3, "Cur", 4); <br>        LVAddColumn(g_hwndLV, 4, "Sec", 4); <br>        LVAddColumn(g_hwndLV, 5, "Pwd", 5); <br> <br>        hr = EnumSessions(lpDP3A ); <br>if (SUCCEEDED(hr)) <br>{ <br>g_idTimer = SetTimer(g_hwndMain, 1, TIMER_PERIOD, NULL); <br>} <br>    } <br>} <br> <br> <br>//================================================================ <br>//================================================================ <br>BOOL DPPrintSessions(LPARAM lParam1, LPARAM lParam2, PRINTCBINFO * lpInfo) <br>{ <br>    // lParam1 is the GUID for the driver we should open <br>    // lParam2 is the CAPDEF table we should use <br> <br>    DPSESSIONDESC2   dps; <br>    HCURSOR         hCur=NULL; <br>HRESULThr = DPERR_GENERIC; <br> <br>    memset(&amp;dps, 0, sizeof(DPSESSIONDESC2)); <br>    dps.dwSize = sizeof(DPSESSIONDESC2); <br> <br>    hCur=SetCursor(LoadCursor(NULL, IDC_WAIT)); <br> <br>    if (DPCreate((GUID*)lParam1)) <br>    { <br>        hr = lpDP3A-&gt;lpVtbl-&gt;EnumSessions (lpDP3A, &amp;dps, 0, EnumPrintSessionsCallback,  <br>(LPVOID)lpInfo,  <br>DPENUMSESSIONS_ALL| <br>DPENUMSESSIONS_PASSWORDREQUIRED ); <br> <br>    } <br> <br>    if (hCur) <br>        SetCursor(hCur); <br> <br>    return TRUE; <br>} <br> <br>//================================================================ <br>//================================================================ <br>typedef struct LLMode <br>{ <br>    DWORD x,y,bpp; <br>        BOOL IsModeX; <br>        struct LLMode *Next; <br>}LinkMode; <br> <br>static LinkMode *pModesHead = NULL;  <br> <br>void DDFourCCFormat(LPARAM lParam1, LPARAM lParam2) <br>{ <br>    HRESULT ddrval; <br>    int iNumOfCodes,iCount; <br>    DWORD *FourCC; <br>    char szText[5]={0,0,0,0,0}; <br> <br>    if(lpDD != NULL) <br>    { <br>        ddrval = IDirectDraw_GetFourCCCodes(lpDD,&amp;iNumOfCodes, NULL); <br>        LVAddColumn(g_hwndLV, 0, "Codes", 24); <br>        LVAddColumn(g_hwndLV, 1, "", 24); <br>        if( ddrval == DD_OK) <br>        { <br>            FourCC = GlobalAlloc(GPTR,(sizeof(DWORD)*iNumOfCodes)); <br>            if(FourCC) <br>            { <br>                ddrval = IDirectDraw_GetFourCCCodes(lpDD,&amp;iNumOfCodes, FourCC); <br>                // Assume all FourCC values are ascii strings <br>                for(iCount = 0;iCount &lt; iNumOfCodes; iCount++) <br>                { <br>                    memcpy(szText,&amp;FourCC[iCount],4); <br>                    LVAddText(g_hwndLV, 0, "%s", szText); <br>                } <br>            } <br>        } <br>    } <br>} <br> <br> <br>//================================================================ <br>//================================================================ <br>BOOL DDPrintFourCCFormat(LPARAM lParam1, LPARAM lParam2, PRINTCBINFO * lpInfo) <br>{ <br>    HRESULT ddrval; <br>    int iNumOfCodes,iCount; <br>    DWORD *FourCC; <br>    char szText[5]={0,0,0,0,0}; <br>    int  xCode, yLine; <br> <br> <br>    if(lpDD != NULL) <br>    { <br>        ddrval = IDirectDraw_GetFourCCCodes(lpDD,&amp;iNumOfCodes, NULL); <br>        if( ddrval == DD_OK) <br>        { <br>            FourCC = GlobalAlloc(GPTR,(sizeof(DWORD)*iNumOfCodes)); <br>            if(FourCC) <br>            { <br>                xCode  = (lpInfo-&gt;dwCurrIndent * DEF_TAB_SIZE * lpInfo-&gt;dwCharWidth); <br>                ddrval = IDirectDraw_GetFourCCCodes(lpDD,&amp;iNumOfCodes, FourCC); <br>                if (ddrval == DD_OK) <br>                { <br>                    // Assume all FourCC values are ascii strings <br>                    for(iCount = 0;iCount &lt; iNumOfCodes; iCount++) <br>                    { <br>                        yLine  = (lpInfo-&gt;dwCurrLine * lpInfo-&gt;dwLineHeight); <br>     <br>                        memcpy(szText,&amp;FourCC[iCount],4); <br>          <br>                        // Print Code <br>                        if (! PrintLine (xCode, yLine, szText, 4, lpInfo)) <br>                            return FALSE; <br> <br>                        if (! PrintNextLine (lpInfo)) <br>                            return FALSE; <br>                    } <br>                } <br>            } <br>        } <br>    } <br> <br>    // Success <br>    return TRUE; <br>} <br> <br> <br>//================================================================ <br>//================================================================ <br> <br>//================================================================ <br>// DisplayEnumModes <br>//================================================================ <br>HRESULT CALLBACK EnumDisplayModesCallback(LPDDSURFACEDESC pddsd, LPVOID Context) <br>{ <br>    if(pddsd-&gt;ddsCaps.dwCaps &amp; DDSCAPS_STANDARDVGAMODE) <br>    { <br>        LVAddText(g_hwndLV, 0, "%dx%dx%d (StandardVGA)", pddsd-&gt;dwWidth, pddsd-&gt;dwHeight, pddsd-&gt;ddpfPixelFormat.dwRGBBitCount); <br>    }else if(pddsd-&gt;ddsCaps.dwCaps &amp; DDSCAPS_MODEX) <br>    { <br>        LVAddText(g_hwndLV, 0, "%dx%dx%d (ModeX)", pddsd-&gt;dwWidth, pddsd-&gt;dwHeight, pddsd-&gt;ddpfPixelFormat.dwRGBBitCount); <br>    }else <br>    { <br>        LVAddText(g_hwndLV, 0, "%dx%dx%d ", pddsd-&gt;dwWidth, pddsd-&gt;dwHeight, pddsd-&gt;ddpfPixelFormat.dwRGBBitCount); <br>    } <br>    return DDENUMRET_OK; <br>} /* EnumModesCallback */ <br> <br>HRESULT CALLBACK EnumDisplayModesCallbackPrint(LPDDSURFACEDESC pddsd, LPVOID Context) <br>{ <br>    TCHAR szBuff[80]; <br>    DWORD cchLen; <br>    PRINTCBINFO * lpInfo = Context; <br>    int xMode, yLine; <br> <br>    if (! lpInfo) <br>        return FALSE; <br> <br>    xMode = (lpInfo-&gt;dwCurrIndent * DEF_TAB_SIZE * lpInfo-&gt;dwCharWidth); <br>    yLine = (lpInfo-&gt;dwCurrLine * lpInfo-&gt;dwLineHeight); <br> <br>    if(pddsd-&gt;ddsCaps.dwCaps &amp; DDSCAPS_STANDARDVGAMODE) <br>    { <br>        wsprintf(szBuff, TEXT("%dx%dx%d (StandardVGA)"), pddsd-&gt;dwWidth, pddsd-&gt;dwHeight, pddsd-&gt;ddpfPixelFormat.dwRGBBitCount); <br>    }else if(pddsd-&gt;ddsCaps.dwCaps &amp; DDSCAPS_MODEX) <br>    { <br>        wsprintf(szBuff, TEXT("%dx%dx%d (ModeX)"), pddsd-&gt;dwWidth, pddsd-&gt;dwHeight, pddsd-&gt;ddpfPixelFormat.dwRGBBitCount); <br>    }else <br>    { <br>        wsprintf(szBuff, TEXT("%dx%dx%d "), pddsd-&gt;dwWidth, pddsd-&gt;dwHeight, pddsd-&gt;ddpfPixelFormat.dwRGBBitCount); <br>    } <br>    // Print Mode Info <br>    cchLen = _tcslen (szBuff); <br>    if (! PrintLine (xMode, yLine, szBuff, cchLen, lpInfo)) <br>        return DDENUMRET_CANCEL; <br>    // Advance to next line <br>    if (! PrintNextLine (lpInfo)) <br>        return DDENUMRET_CANCEL; <br> <br>return DDENUMRET_OK; <br>} /* EnumModesCallback */ <br> <br>//================================================================ <br>// PrintEnumModes <br>//================================================================ <br>/*BOOL PrintEnumModes () <br>{ <br>    LinkMode *tmp= NULL; <br> <br> <br>    tmp = pModesHead; <br>    while (tmp != NULL) //cycle though all modes since unique modes don't always happen <br>    { <br> <br>        if (tmp-&gt;IsModeX) <br>            wsprintf (szBuff, TEXT("%dx%dx%d (ModeX)"), tmp-&gt;x, tmp-&gt;y, tmp-&gt;bpp); <br>        else <br>            wsprintf (szBuff, TEXT("%dx%dx%d "), tmp-&gt;x, tmp-&gt;y, tmp-&gt;bpp); <br> <br> <br>        tmp = tmp-&gt;Next; <br>    } <br> <br>    // Success <br>    return TRUE; <br>}*/ /* EnumModesCallback */ <br> <br>//================================================================ <br>// Should we hourglass the cursor? this takes a while <br>//================================================================ <br>void DDAddVideoModes(LPARAM lParam1, LPARAM lParam2) <br>{ <br>    DWORD mode; <br>    DDSURFACEDESC ddsd; <br> <br>    LVAddColumn(g_hwndLV, 0, "Mode", 24); <br>    LVAddColumn(g_hwndLV, 1, "", 24); <br> <br>    // lParam1 is the GUID for the driver we should open <br>    // lParam2 is not used <br> <br>    if (DDCreate((GUID*)lParam1)) <br>    { <br>        // Get the current mode mode for this driver <br>        ddsd.dwSize = sizeof(DDSURFACEDESC); <br>        IDirectDraw_GetDisplayMode(lpDD, &amp;ddsd); <br> <br>        mode = MAKEMODE(ddsd.dwWidth, ddsd.dwHeight, ddsd.ddpfPixelFormat.dwRGBBitCount); <br> <br>        // Find all mode for this driver and add them to the listview <br>        //Erase previous list <br>        { <br>            LinkMode *tmp, *tmp1; <br> <br>            tmp = pModesHead; <br>            while(tmp != NULL) <br>            { <br>                tmp1 = tmp; <br>                tmp = tmp-&gt;Next; <br>                GlobalFree(tmp1);  //Note We will exit with a list in place <br>            } <br>            pModesHead = NULL; <br>        } <br>        //Get Modes <br>        IDirectDraw_SetCooperativeLevel(lpDD, g_hwndMain, DDSCL_FULLSCREEN | DDSCL_EXCLUSIVE | DDSCL_ALLOWMODEX | DDSCL_NOWINDOWCHANGES); <br>        IDirectDraw_EnumDisplayModes(lpDD, DDEDM_STANDARDVGAMODES, NULL, (LPVOID)mode, EnumDisplayModesCallback); <br>        IDirectDraw_SetCooperativeLevel(lpDD, g_hwndMain, DDSCL_NORMAL); <br>    } <br>} <br> <br> <br>//================================================================ <br>// Should we hourglass the cursor? this takes a while <br>//================================================================ <br>BOOL DDPrintVideoModes(LPARAM lParam1, LPARAM lParam2, PRINTCBINFO * lpInfo) <br>{ <br>    BOOL  fResult = TRUE;   // Even if we can't enum modes, let's keep on printing other stuff <br>    DWORD mode; <br>    DDSURFACEDESC ddsd; <br> <br>    LVAddColumn(g_hwndLV, 0, "Mode", 24); <br>    LVAddColumn(g_hwndLV, 1, "", 24); <br> <br>    // lParam1 is the GUID for the driver we should open <br>    // lParam2 is not used <br> <br>    if (DDCreate((GUID*)lParam1)) <br>    { <br>        // Get the current mode mode for this driver <br>        ddsd.dwSize = sizeof(DDSURFACEDESC); <br>        IDirectDraw_GetDisplayMode(lpDD, &amp;ddsd); <br> <br>        mode = MAKEMODE(ddsd.dwWidth, ddsd.dwHeight, ddsd.ddpfPixelFormat.dwRGBBitCount); <br> <br>        // Find all mode for this driver and add them to the listview <br>        //Erase previous list <br>        { <br>            LinkMode *tmp, *tmp1; <br> <br>            tmp = pModesHead; <br>            while(tmp != NULL) <br>            { <br>                tmp1 = tmp; <br>                tmp = tmp-&gt;Next; <br>                GlobalFree(tmp1);  //Note We will exit with a list in place <br>            } <br>            pModesHead = NULL; <br>        } <br> <br>        //Get Mode with ModeX <br>        IDirectDraw_SetCooperativeLevel(lpDD, g_hwndMain, DDSCL_FULLSCREEN | DDSCL_EXCLUSIVE | DDSCL_ALLOWMODEX | DDSCL_NOWINDOWCHANGES); <br>        IDirectDraw_EnumDisplayModes(lpDD, DDEDM_STANDARDVGAMODES, NULL, (LPVOID)lpInfo, EnumDisplayModesCallbackPrint); <br>        IDirectDraw_SetCooperativeLevel(lpDD, g_hwndMain, DDSCL_NORMAL); <br>    } <br> <br>    // Success <br>    return fResult; <br>} // End DDPrintVideoModes <br> <br> <br>//================================================================ <br>//================================================================ <br>void DXView_OnTreeSelect(HWND hwndTV, NM_TREEVIEW *ptv) <br>{ <br>    NODEINFO *pni; <br> <br>    SendMessage(g_hwndLV, WM_SETREDRAW, FALSE, 0); <br>    LVDeleteAllItems(g_hwndLV); <br>    LVAddColumn(g_hwndLV, 0, "", 0); <br> <br>    if (ptv == NULL) <br>    { <br>        TV_ITEM tvi; <br>        // get lParam of current tree node <br>        tvi.hItem  = TreeView_GetSelection(g_hwndTV); <br>        tvi.mask   = TVIF_PARAM; <br>        tvi.lParam = 0; <br>        TreeView_GetItem(g_hwndTV, &amp;tvi); <br>        pni = (NODEINFO*)tvi.lParam; <br>    } <br>    else <br>    { <br>        pni = (NODEINFO*)ptv-&gt;itemNew.lParam; <br>    } <br> <br>    if (pni &amp;&amp; pni-&gt;Callback) <br>    { <br>        pni-&gt;Callback(pni-&gt;lParam1, pni-&gt;lParam2); <br>    } <br> <br>    SendMessage(g_hwndLV, WM_SETREDRAW, TRUE, 0); <br>    InvalidateRect(g_hwndLV, NULL, TRUE); <br>} <br> <br>//================================================================ <br>//================================================================ <br>void DXView_OnListViewDblClick(HWND hwndLV, NM_LISTVIEW *plv) <br>{ <br>    LV_ITEM lvi; <br> <br>    lvi.mask   = LVIF_PARAM; <br>    lvi.lParam = 0; <br>    lvi.iItem  = plv-&gt;iItem; <br>    ListView_GetItem(hwndLV, &amp;lvi); <br>} <br> <br> <br>//================================================================ <br>//================================================================ <br>void DXView_OnCommand(HWND hwnd, WPARAM wParam) <br>{ <br>    HMENU hMenu; <br>    BOOL  fPrintAll; <br> <br>    switch(LOWORD(wParam)) <br>    { <br>        case IDM_VIEWAVAIL: <br>        case IDM_VIEWALL: <br>            hMenu = GetMenu(hwnd); <br>            CheckMenuItem(hMenu, g_dwViewState, MF_BYCOMMAND | MF_UNCHECKED); <br>            g_dwViewState = LOWORD(wParam); <br>            CheckMenuItem(hMenu, g_dwViewState, MF_BYCOMMAND | MF_CHECKED); <br>            DXView_OnTreeSelect(g_hwndTV, NULL); <br>            break; <br> <br>        case IDM_PRINT: <br>        case IDM_PRINTALL: <br>            // Print all statistics or just current selection <br>            if (LOWORD(wParam) == IDM_PRINTALL) <br>                fPrintAll = TRUE; <br>            else <br>                fPrintAll = FALSE; <br>            // Print out statistics <br>            DXView_OnPrint (hwnd, g_hwndTV, fPrintAll); <br>            break; <br> <br>        case IDM_PRINTTOFILE: <br>                fPrintAll = TRUE; <br>                g_PrintToFile = TRUE; <br>            // Print out statistics <br>            DXView_OnFile (hwnd, g_hwndTV, fPrintAll); <br>            break; <br> <br>        case IDM_ABOUT: <br>            DialogBox(g_hInstance, "About", hwnd, (DLGPROC)About); <br>            break; <br> <br>        case IDM_EXIT: <br>            PostMessage(hwnd, WM_CLOSE, 0, 0); <br>            break; <br>    } <br>} <br> <br>//================================================================ </code></pre>
<p>
</p>
<pre><code>//================================================================ <br>void DXView_Cleanup() <br>{ <br>    if (lp3D) <br>        IDirect3D2_Release(lp3D); <br> <br>    if (lpDD) <br>        IDirectDraw_Release(lpDD); <br> <br>    if (lpDS) <br>        IDirectSound_Release(lpDS); <br> <br>    if (lpDSC) <br>        IDirectSoundCapture_Release(lpDSC); <br> <br>    if (lpDP3A) <br>{ <br>        lpDP3A-&gt;lpVtbl-&gt;Release(lpDP3A); <br>lpDP3A = NULL; <br>} <br> <br>    if(g_hImageList) <br>        ImageList_Destroy(g_hImageList); <br>} <br> <br>//================================================================ <br>//================================================================ <br>BOOL DXView_InitImageList() <br>{ <br>    int cxSmIcon; <br>    int cySmIcon; <br>    UINT Index; <br>    HICON hIcon; <br> <br>    if (g_hImageList) <br>        return TRUE; <br> <br>    cxSmIcon = GetSystemMetrics(SM_CXSMICON); <br>    cySmIcon = GetSystemMetrics(SM_CYSMICON); <br> <br>    //  First, create the image list that is needed. <br>    if((g_hImageList = ImageList_Create(cxSmIcon, cySmIcon, TRUE, IDI_LASTIMAGE - IDI_FIRSTIMAGE, 10)) == NULL) <br>        return(FALSE); <br> <br>    // <br>    //  Initialize the image list with all of the icons that we'll be using <br>    //  Once set, send its handle to all interested child windows. <br>    // <br>    for (Index = IDI_FIRSTIMAGE; Index &lt;= IDI_LASTIMAGE; Index++) <br>    { <br>        hIcon = LoadImage(g_hInstance, MAKEINTRESOURCE(Index), IMAGE_ICON, cxSmIcon, cySmIcon, 0); <br>        ImageList_AddIcon(g_hImageList, hIcon); <br>        DestroyIcon(hIcon); <br>    } <br> <br>    TreeView_SetImageList(g_hwndTV, g_hImageList, TVSIL_NORMAL); <br> <br>    return(TRUE); <br>} <br> <br>//================================================================ <br>//================================================================ <br>HRESULT CALLBACK DDEnumCallBack(GUID *pid, LPSTR lpDriverDesc, LPSTR lpDriverName, LPVOID lpContext) <br>{ <br>    HTREEITEM hParent = (HTREEITEM)lpContext; <br>    TCHAR szText[256]; <br> <br>    if (HIWORD(pid) != 0) <br>    { <br>        GUID temp = *pid; <br>        pid = (GUID *)LocalAlloc(LPTR, sizeof(GUID)); <br>        *pid = temp; <br>    } <br> <br>    // Add subnode to treeview <br>    if (lpDriverName &amp;&amp; *lpDriverName) <br>        wsprintf(szText, "%s (%s)", lpDriverDesc, lpDriverName); <br>    else <br>        lstrcpy(szText, lpDriverDesc); <br> <br>    DDCapDefs[0].szName = szText; <br>    AddCapsToTV(hParent, DDCapDefs, (LPARAM)pid); <br> <br>    return(DDENUMRET_OK); <br>} <br> <br>//================================================================ <br>//================================================================ <br>HRESULT CALLBACK DSEnumCallBack(const GUID *lpGUID, LPCSTR lpDriverDesc, LPCSTR lpDriverName, LPVOID lpContext) <br>{ <br>    HTREEITEM hParent = (HTREEITEM)lpContext; <br>    TCHAR     szText[256]; <br>    LPGUID    lpTemp = NULL; <br> <br>    if( lpGUID != NULL ) <br>        { <br>        if(( lpTemp = LocalAlloc( LPTR, sizeof(GUID))) == NULL ) <br>        return( TRUE ); <br> <br>        memcpy( lpTemp, lpGUID, sizeof(GUID)); <br>    } <br> <br>    // Add subnode to treeview <br>    if (lpDriverName &amp;&amp; *lpDriverName) <br>        wsprintf(szText, "%s (%s)", lpDriverDesc, lpDriverName); <br>    else <br>        lstrcpy(szText, lpDriverDesc); <br> <br>    DSCapDefs[0].szName = szText; <br>    AddCapsToTV(hParent, DSCapDefs, (LPARAM)lpTemp); <br> <br>    return(DDENUMRET_OK); <br>} <br> <br>//================================================================ <br>//================================================================ <br>HRESULT CALLBACK DSCEnumCallBack(const GUID *lpGUID, LPCSTR lpDriverDesc, LPCSTR lpDriverName, LPVOID lpContext) <br>{ <br>    HTREEITEM hParent = (HTREEITEM)lpContext; <br>    TCHAR     szText[256]; <br>    LPGUID    lpTemp = NULL; <br> <br>    if( lpGUID != NULL ) <br>    { <br>        if(( lpTemp = LocalAlloc( LPTR, sizeof(GUID))) == NULL ) <br>        return( TRUE ); <br> <br>        memcpy( lpTemp, lpGUID, sizeof(GUID)); <br>    } <br> <br>    // Add subnode to treeview <br>    if (lpDriverName &amp;&amp; *lpDriverName) <br>        wsprintf(szText, "%s (%s)", lpDriverDesc, lpDriverName); <br>    else <br>        lstrcpy(szText, lpDriverDesc); <br> <br>    DSCCapDefs[0].szName = szText; <br>    AddCapsToTV(hParent, DSCCapDefs, (LPARAM)lpTemp); <br> <br>    return(DDENUMRET_OK); <br>} <br> <br>//================================================================ <br>//================================================================ <br>BOOL CALLBACK DPEnumCallback(GUID *pid, LPSTR szName, DWORD major_ver, DWORD minor_ver, LPVOID lpContext) <br>{ <br>    HTREEITEM hParent = (HTREEITEM)lpContext; <br>    TCHAR szText[256]; <br> <br>    if (HIWORD(pid) != 0) <br>    { <br>        GUID temp = *pid; <br>        pid = (GUID *)LocalAlloc(LPTR, sizeof(GUID)); <br>        *pid = temp; <br>    } <br> <br>    wsprintf(szText, "%s %d.%d", szName, major_ver, minor_ver); <br> <br>    DPCapDefs[0].szName = szText; <br>    AddCapsToTV(hParent, DPCapDefs, (LPARAM)pid); <br> <br>    return TRUE; <br>} <br> <br>//================================================================ <br>//================================================================ <br>HRESULT CALLBACK D3EnumCallback( <br>            LPGUID pid, <br>            LPSTR lpDriverDesc, <br>            LPSTR lpDriverName,  <br>            LPD3DDEVICEDESC lpD3DDeviceDesc1,  <br>            LPD3DDEVICEDESC lpD3DDeviceDesc2,  <br>            LPVOID lpContext) <br>{ <br>    HTREEITEM hParent = (HTREEITEM)lpContext; <br>    TCHAR szText[256]; <br> <br>    //Store this info now is much easier than recreating it later. <br>    CAP3DDEVICEDESC *temp; <br>    if(lpD3DDeviceDesc1-&gt;dwFlags != 0) <br>    { <br>        temp = LocalAlloc(LPTR, sizeof(CAP3DDEVICEDESC)); <br>        memcpy(temp,lpD3DDeviceDesc1,sizeof(CAP3DDEVICEDESC)); <br>    }else <br>    { <br>        temp = LocalAlloc(LPTR, sizeof(CAP3DDEVICEDESC)); <br>        memcpy(temp,lpD3DDeviceDesc2,sizeof(CAP3DDEVICEDESC)); <br>    } <br>    temp-&gt;device = ddid; <br>    memcpy(&amp;temp-&gt;driver,pid,sizeof(GUID)); <br> <br>    // Add subnode to treeview <br>    if (lpDriverName &amp;&amp; *lpDriverName) <br>        wsprintf(szText, "%s (%s)", lpDriverDesc, lpDriverName); <br>    else <br>        lstrcpy(szText, lpDriverDesc); <br> <br>    D3CapDefs[0].szName = szText; <br>    AddCapsToTV(hParent, D3CapDefs, (LPARAM)temp); <br> <br>    return(DDENUMRET_OK); <br>} <br> <br>HRESULT CALLBACK DDEnumCallBack3D(GUID *pid, LPSTR lpDriverDesc, LPSTR lpDriverName, LPVOID lpContext) <br>{ <br>    HTREEITEM hParent = (HTREEITEM)lpContext; <br>    HTREEITEM hTree; <br>    TCHAR szText[256]; <br> <br>    if (HIWORD(pid) != 0) <br>    { <br>        GUID temp = *pid; <br>        pid = (GUID *)LocalAlloc(LPTR, sizeof(GUID)); <br>        *pid = temp; <br>    } <br> <br>    // Add subnode to treeview <br>    if (lpDriverName &amp;&amp; *lpDriverName) <br>        wsprintf(szText, "%s (%s)", lpDriverDesc, lpDriverName); <br>    else <br>        lstrcpy(szText, lpDriverDesc); <br> <br>    hTree = TVAddNode(hParent,szText,TRUE,IDI_CAPS, NULL, 0, 0, NULL); <br>     <br>    if (DDCreate(pid) &amp;&amp; lp3D) <br>    { <br>        IDirect3D2_EnumDevices(lp3D, D3EnumCallback, hTree); <br>    } <br> <br>    return(DDENUMRET_OK); <br>} <br> <br>//================================================================ <br>//================================================================ <br>void DXView_FillTree(HWND hwndTV) <br>{ <br>    HTREEITEM   hTree, hTreeSubNode; <br> <br>    PFN_DSENUMERATE pfn_DSEnumerate; <br>    PFN_DSCENUMERATE pfn_DSCEnumerate; <br> <br>    // Add direct draw devices <br> <br>    hTree = TVAddNode(TVI_ROOT, "DirectDraw Devices", TRUE, <br>                      IDI_DIRECTX, NULL, 0, 0, NULL); <br> <br>    // Add Display Driver node(s) and capability nodes to treeview <br>    DirectDrawEnumerate(DDEnumCallBack, hTree); <br> <br>    // Add Hardware Emulation Layer node to treeview <br>    DDEnumCallBack((GUID *)DDCREATE_EMULATIONONLY, "Hardware Emulation Layer", NULL, (LPVOID)hTree); <br> <br>    TreeView_Expand(g_hwndTV, hTree, TVE_EXPAND); <br>    TreeView_SelectItem(g_hwndTV, hTree); <br> <br>    // Add direct 3D devices <br>    hTree = TVAddNode(TVI_ROOT, "Direct3D Devices", TRUE, <br>                      IDI_DIRECTX, NULL, 0, 0, NULL); <br>    DirectDrawEnumerate(DDEnumCallBack3D, hTree); <br> <br>    TreeView_Expand(g_hwndTV, hTree, TVE_EXPAND); <br> <br>    pfn_DSEnumerate = (PFN_DSENUMERATE)GetProcAddress(g_hDSoundLib, "DirectSoundEnumerateA"); <br>    if (pfn_DSEnumerate == NULL) <br>    { <br>        MessageBox(g_hwndMain, "DSOUND.DLL does not implement DirectSoundEnumerate()", g_szAppName, MB_OK); <br>    } <br>    else <br>    { <br>        // Add direct sound devices <br>        hTree = TVAddNode(TVI_ROOT, "DirectSound Devices", TRUE, <br>                                          IDI_DIRECTX, NULL, 0, 0, NULL); <br> <br>        (*pfn_DSEnumerate)(DSEnumCallBack, hTree); <br> <br>        TreeView_Expand(g_hwndTV, hTree, TVE_EXPAND); <br>    } <br> <br> <br>    // Get a pointer to the DirectSoundCaptureEnumerate <br>    pfn_DSCEnumerate = (PFN_DSCENUMERATE)GetProcAddress(g_hDSoundLib, "DirectSoundCaptureEnumerateA"); <br>    if (pfn_DSCEnumerate == NULL) <br>    { <br>        MessageBox(g_hwndMain, "DSOUND.DLL does not implement DirectSoundCaptureEnumerate(). The system may not have DirectX 5.0 installed.", g_szAppName, MB_OK); <br>    } <br>    else <br>    { <br>        // Add direct sound capture devices <br>        hTree = TVAddNode(TVI_ROOT, "DirectSoundCapture Devices", TRUE, <br>                                                    IDI_DIRECTX, NULL, 0, 0, NULL); <br>        (*pfn_DSCEnumerate)(DSCEnumCallBack, hTree); <br>        TreeView_Expand(g_hwndTV, hTree, TVE_EXPAND); <br>    } <br> <br>    // Add direct play devices <br> <br>    hTree = TVAddNode(TVI_ROOT, "DirectPlay Devices", TRUE, <br>                      IDI_DIRECTX, NULL, 0, 0, NULL); <br> <br>    hTreeSubNode = TVAddNode(hTree, "Connections", TRUE, <br>                      IDI_CAPS, NULL, 0, 0, NULL); <br>    TreeView_Expand(g_hwndTV, hTree, TVE_EXPAND); <br> <br>    DirectPlayEnumerate(DPEnumCallback, hTreeSubNode); <br>    TreeView_Expand(g_hwndTV, hTree, TVE_EXPAND); <br> <br>    AddCapsToTV(hTree, DPLocalAppsDef, 0); <br>    TreeView_Expand(g_hwndTV, hTree, TVE_EXPAND); <br> <br>    // <br>    //  DirectInput goo is in dinput.c <br>    // <br>    DI_FillTree(); <br>} <br> <br>//================================================================ <br>//  About - process about box <br>//================================================================ <br>LRESULT CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>    switch(message) <br>    { <br>        case WM_INITDIALOG: <br>            return(TRUE); <br> <br>        case WM_COMMAND:                      // message: received a command <br>            if(LOWORD(wParam) == IDOK        // "OK" box selected? <br>            || LOWORD(wParam) == IDCANCEL) {  // System menu close command? <br>                EndDialog(hDlg, TRUE);        // Exit the dialog <br>                return(TRUE); <br>            } <br>            break; <br>    } <br>    return(FALSE); // Didn't process the message <br>} <br> <br>//================================================================ <br>//================================================================ <br>//  DXView_OnSize <br>// <br>//  DESCRIPTION: <br>//     Called whenever the size of the app window has changed or the size <br>//     of its child controls should be adjusted. <br>// <br>//  PARAMETERS: <br>//     hWnd, handle of app window. <br>// <br>//================================================================ <br>//================================================================ <br>void DXView_OnSize(HWND hWnd) <br>{ <br>    HDWP hDWP; <br>    RECT ClientRect; <br>    int Height; <br>    HWND hKeyTreeWnd; <br>    HWND hValueListWnd; <br>    int x; <br>    int dx; <br> <br>    if (IsIconic(hWnd)) <br>        return; <br> <br>    if ((hDWP = BeginDeferWindowPos(2)) != NULL) <br>    { <br>        //  Data structure used when calling GetEffectiveClientRect (which takes into <br>        //  account space taken up by the toolbars/status bars).  First half of the <br>        //  pair is zero when at the end of the list, second half is the control id. <br>        int s_EffectiveClientRectData[] = { <br>            1, 0,                               //  For the menu bar, but is unused <br>            0, 0                                //  First zero marks end of data <br>        }; <br> <br>        GetEffectiveClientRect(hWnd, &amp;ClientRect, s_EffectiveClientRectData); <br>        Height = ClientRect.bottom - ClientRect.top; <br> <br>        hKeyTreeWnd = g_hwndTV; <br> <br>        DeferWindowPos(hDWP, hKeyTreeWnd, NULL, 0, ClientRect.top, g_xPaneSplit, <br>            Height, SWP_NOZORDER | SWP_NOACTIVATE); <br> <br>        x = g_xPaneSplit + GetSystemMetrics(SM_CXSIZEFRAME); <br>        dx = ClientRect.right - ClientRect.left - x; <br> <br>        hValueListWnd = g_hwndLV; <br> <br>        DeferWindowPos(hDWP, hValueListWnd, NULL, x, ClientRect.top, dx, Height, <br>            SWP_NOZORDER | SWP_NOACTIVATE); <br> <br>        EndDeferWindowPos(hDWP); <br>    } <br>} <br>#ifdef _X86_ <br>#pragma optimize("", off) <br>#endif <br>/*----------------------------------------------------------------------------*\ <br>\*----------------------------------------------------------------------------*/ <br> <br>void LVAddColumn(HWND hwndLV, int i, char *name, int width) <br>{ <br>    LV_COLUMN col; <br> <br>    if (i == 0) <br>    { <br>        while(ListView_DeleteColumn(hwndLV, 0)) <br>            ; <br>    } <br> <br>    col.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT; <br>    col.fmt  = LVCFMT_LEFT; <br>    col.pszText = name; <br>    col.cchTextMax = 0; <br>    col.cx = width * g_tmAveCharWidth; <br>    col.iSubItem = 0; <br>    ListView_InsertColumn(hwndLV, i, &amp;col); <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>\*----------------------------------------------------------------------------*/ <br>int LVAddText(HWND hwndLV, int col, const char *sz, ...) <br>{ <br>    LV_ITEM lvi; <br>    char    ach[80]; <br>    va_list vl; <br> <br>    va_start(vl, sz ); <br>    wvsprintf(ach,sz, vl); <br> <br>    lvi.mask        = LVIF_TEXT; <br>    lvi.iSubItem    = 0; <br>    lvi.state       = 0; <br>    lvi.stateMask   = 0; <br>    lvi.pszText     = ach; <br>    lvi.cchTextMax  = 0; <br>    lvi.iImage      = 0; <br>    lvi.lParam      = 0; <br> <br>    if (col == 0) <br>    { <br>            lvi.iItem    = 0x7FFF; <br>            lvi.iSubItem = 0; <br>        return ListView_InsertItem(hwndLV, &amp;lvi); <br>    } <br>    else <br>    { <br>        lvi.iItem    = ListView_GetItemCount(hwndLV)-1; <br>        lvi.iSubItem = col; <br>        return ListView_SetItem(hwndLV, &amp;lvi); <br>    } <br>    va_end(vl); <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>\*----------------------------------------------------------------------------*/ <br>void LVDeleteAllItems( HWND hwndLV ) <br>{ <br> <br>//Used by DPLay asynchronous enum sessions <br>if (g_idTimer) <br>{ <br> <br>BOOLbDataAvailable; <br>LPLV_INSTANCEGUIDSTRUCTlpInstGuidStruct = NULL; <br>LV_ITEMlvi; <br>inti, count; <br> <br>KillTimer(g_hwndMain, g_idTimer );  <br>g_idTimer = 0; <br> <br>memset( &amp;lvi, 0, sizeof( LV_ITEM )); <br> <br>count= ListView_GetItemCount( g_hwndLV ); <br> <br>for ( i = 0; i &lt; count; i++ ) <br>{ <br>lvi.iItem = i; <br>lvi.mask = LVIF_PARAM; <br>lvi.lParam = 0; <br> <br>bDataAvailable =ListView_GetItem( g_hwndLV, &amp;lvi ); <br> <br>if ((bDataAvailable) &amp;&amp; (lvi.lParam)) <br>LocalFree( (LPVOID) lvi.lParam ); <br> <br>} <br> <br>} <br> <br>ListView_DeleteAllItems( hwndLV ); <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>\*----------------------------------------------------------------------------*/ <br>HTREEITEM TVAddNode( <br>    HTREEITEM       hParent,  <br>    LPSTR           szText,  <br>    BOOL            fKids,  <br>    int             iImage,  <br>    SELCALLBACK     Callback,  <br>    LPARAM          lParam1,  <br>    LPARAM          lParam2, <br>    PRINTCALLBACK   printCallback) <br>{ <br>    TV_INSERTSTRUCT tvi; <br>    NODEINFO *pni; <br> <br>    pni = (NODEINFO *)LocalAlloc(LPTR, sizeof(NODEINFO)); <br> <br>    if (pni == NULL) <br>        return NULL; <br> <br>    pni-&gt;lParam1        = lParam1; <br>    pni-&gt;lParam2        = lParam2; <br>    pni-&gt;Callback       = Callback; <br>    pni-&gt;printCallback  = printCallback; <br> <br>    // Add Node to treeview <br>    tvi.hParent             = hParent; <br>    tvi.hInsertAfter        = TVI_LAST; <br>    tvi.item.mask           = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM | TVIF_CHILDREN; <br>    tvi.item.iImage         = iImage - IDI_FIRSTIMAGE; <br>    tvi.item.iSelectedImage = iImage - IDI_FIRSTIMAGE; <br>    tvi.item.lParam         = (LPARAM)pni; <br>    tvi.item.cChildren      = fKids; <br>    tvi.item.pszText        = szText; <br> <br>    return TreeView_InsertItem(g_hwndTV, &amp;tvi); <br>} <br> <br> <br>/*----------------------------------------------------------------------------*\ <br>\*----------------------------------------------------------------------------*/ <br>HRESULT EnumSessions( LPDIRECTPLAY3A lpDP3A ) <br>{ <br> <br>    DPSESSIONDESC2   dps; <br>HRESULThr = DPERR_GENERIC; <br> <br> <br>if (lpDP3A) <br>{ <br>memset(&amp;dps, 0, sizeof(dps)); <br>dps.dwSize = sizeof(dps); <br> <br>ResetListViewRefresh( g_hwndLV ); <br> <br>hr = lpDP3A-&gt;lpVtbl-&gt;EnumSessions(lpDP3A, &amp;dps, 0, EnumSessionsCallback,  <br>NULL,  <br>DPENUMSESSIONS_ALL| <br>DPENUMSESSIONS_PASSWORDREQUIRED| <br>DPENUMSESSIONS_ASYNC); <br>RemoveStaleSessions(); <br>} <br> <br>return hr; <br>} <br> <br> <br>/*----------------------------------------------------------------------------*\ <br>\*----------------------------------------------------------------------------*/ <br>void FreeLocalAppList() <br>{ <br>LOCALAPP * lpTemp; <br> <br>while( g_lpLocalApp ) <br>{ <br>lpTemp = (LPLOCALAPP) g_lpLocalApp-&gt;lpNext; <br>LocalFree( g_lpLocalApp ); <br>g_lpLocalApp = lpTemp; <br>} <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>\*----------------------------------------------------------------------------*/ <br>void GetAppName(LPSTR szNameBuffer, LPCGUID lpguidApplication, DWORD dwBufferSize) <br>{ <br>LPLOCALAPPlpTemp = g_lpLocalApp; <br>WCHARwszBuffer[128]; <br> <br>while (lpTemp) <br>{ <br>if (IsEqualGUID( &amp;(lpTemp-&gt;guidApplication), lpguidApplication )) <br>{ <br>strncpy( szNameBuffer, lpTemp-&gt;szAppNameA, dwBufferSize );  <br>return; <br>} <br>else <br>{ <br>lpTemp = (LPLOCALAPP)lpTemp-&gt;lpNext; <br>} <br>} <br> <br>//If we ended up here, the GUID doesn't match anything we have installed locally. <br>if (StringFromGUID2( lpguidApplication, wszBuffer, 128 )) <br>{ <br>    wcstombs(szNameBuffer, wszBuffer, wcslen(wszBuffer)+1); <br>} <br> <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>\*----------------------------------------------------------------------------*/ <br>void RemoveStaleSessions() <br>{ <br>BOOL bDataAvailable; <br>int i= 0, <br>count= ListView_GetItemCount( g_hwndLV ); <br> <br>LPLV_INSTANCEGUIDSTRUCTlpInstGuidStruct = NULL; <br>LV_ITEMlvi; <br> <br>memset( &amp;lvi, 0, sizeof(LV_ITEM) ); <br> <br>while( i &lt; count) <br>{ <br>lvi.iItem = i; <br>lvi.mask = LVIF_PARAM; <br>lvi.lParam = 0; <br> <br>bDataAvailable =ListView_GetItem( g_hwndLV, &amp;lvi ); <br> <br>if (bDataAvailable) <br>{ <br>lpInstGuidStruct = (LPLV_INSTANCEGUIDSTRUCT) lvi.lParam; <br>if (lpInstGuidStruct) <br>{ <br>if (FALSE == lpInstGuidStruct-&gt;dwRefresh) <br>{ <br>LocalFree( lpInstGuidStruct ); <br>ListView_DeleteItem( g_hwndLV, i); <br>} <br>} <br>} <br>else <br>{ <br>//This item has no data, so it must be invalid. <br>ListView_DeleteItem( g_hwndLV, i); <br>} <br> <br>i++; <br>} <br> <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>\*----------------------------------------------------------------------------*/ <br>void ResetListViewRefresh( HWND hwndLV ) <br>{ <br>BOOL bDataAvailable; <br>int i= 0, <br>count= ListView_GetItemCount( hwndLV ); <br> <br>LPLV_INSTANCEGUIDSTRUCTlpInstGuidStruct = NULL; <br>LV_ITEMlvi; <br> <br>memset( &amp;lvi, 0, sizeof(LV_ITEM) ); <br> <br>while( i &lt; count) <br>{ <br>lvi.iItem = i; <br>lvi.mask = LVIF_PARAM; <br>lvi.lParam = 0; <br> <br>bDataAvailable =ListView_GetItem( hwndLV, &amp;lvi ); <br> <br>if (bDataAvailable) <br>{ <br>lpInstGuidStruct = (LPLV_INSTANCEGUIDSTRUCT) lvi.lParam; <br> <br>if (lpInstGuidStruct) <br>{ <br>//Mark this session to be deleted next time if it does not <br>//respond to this enum request. <br>lpInstGuidStruct-&gt;dwRefresh = FALSE; <br>} <br>} <br>else <br>{ <br>//This item has no data, so it must be invalid. <br>ListView_DeleteItem( hwndLV, i); <br>} <br> <br>i++; <br>} <br> <br>} <br> <br> <br>#ifdef _X86_ <br>#pragma optimize("", on) <br>#endif </code></pre>
<p>&nbsp;</p></body>
</HTML>
