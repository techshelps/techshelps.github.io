<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DXPRINT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3153"></a>DXPRINT.C</h2>
<pre><code>/* <br>**----------------------------------------------------------------------------- <br>** Name:    dxprint.c <br>** Purpose: print's DX Tree View info to selected printer <br>** Notes: <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Includes <br>**----------------------------------------------------------------------------- <br>*/ <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include &lt;commctrl.h&gt; <br>#include &lt;commdlg.h&gt;        // Common Print Dialog <br>#include &lt;tchar.h&gt;          // Unicode string functions and types <br> <br>#include &lt;ddraw.h&gt; <br>#include &lt;dsound.h&gt; <br>#include &lt;dplay.h&gt; <br>#include &lt;d3d.h&gt; <br>#include "dxview.h" <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Local Variables <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>BOOL g_fAbortPrint      = FALSE;       // Did User Abort Print operation ?!? <br>HWND g_hAbortPrintDlg   = NULL;        // Print Abort Dialog handle <br>BOOL g_PrintToFile      = FALSE;       // Don't print to printer print to dxview.log <br>HANDLE g_FileHandle     = NULL;        // Handle to log file <br>                                         <br>/* <br>**----------------------------------------------------------------------------- <br>** Local Prototypes <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>BOOL CALLBACK PrintTreeStats( <br>    HINSTANCE   hInstance, <br>    HWND        hWindow, <br>    HWND        hTreeWnd, <br>    HTREEITEM   hRoot); <br> <br>void DoMessage (DWORD dwTitle, DWORD dwMsg); <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Functions <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    DXView_OnPrint <br>** Purpose: Print user defined stuff <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>BOOL DXView_OnPrint ( <br>    HWND hWindow,  <br>    HWND hTreeWnd, <br>    BOOL fPrintAll) <br>{ <br>    HINSTANCE hInstance; <br>    HTREEITEM hRoot; <br> <br>    // Check Parameters <br>    if ((! hWindow) || (! hTreeWnd)) <br>    { <br>        // Invalid parameters <br>        return FALSE; <br>    } <br> <br>    // Get hInstance <br>    hInstance = (HINSTANCE)GetWindowLong (hWindow, GWL_HINSTANCE); <br>    if (! hInstance) <br>        return FALSE; <br> <br>    if (fPrintAll) <br>    { <br>        hRoot = NULL; <br>    } <br>    else <br>    { <br>        hRoot = TreeView_GetSelection (hTreeWnd); <br>        if (! hRoot) <br>        { <br>            DoMessage (IDS_PRINT_WARNING, IDS_PRINT_NEEDSELECT); <br>        } <br>    } <br>    g_PrintToFile = FALSE; <br>    // Do actual printing <br>    return PrintTreeStats (hInstance, hWindow, hTreeWnd, hRoot); <br> <br>} // End DXView_OnPrint <br> <br>BOOL DXView_OnFile ( <br>    HWND hWindow,  <br>    HWND hTreeWnd, <br>    BOOL fPrintAll) <br>{ <br>    HINSTANCE hInstance; <br>    HTREEITEM hRoot; <br> <br>    // Check Parameters <br>    if ((! hWindow) || (! hTreeWnd)) <br>    { <br>        // Invalid parameters <br>        return FALSE; <br>    } <br> <br>    // Get hInstance <br>    hInstance = (HINSTANCE)GetWindowLong (hWindow, GWL_HINSTANCE); <br>    if (! hInstance) <br>        return FALSE; <br> <br>    if (fPrintAll) <br>    { <br>        hRoot = NULL; <br>    } <br>    else <br>    { <br>        hRoot = TreeView_GetSelection (hTreeWnd); <br>        if (! hRoot) <br>        { <br>            DoMessage (IDS_PRINT_WARNING, IDS_PRINT_NEEDSELECT); <br>        } <br>    } <br>    g_PrintToFile = TRUE; <br>    // Do actual printing <br>    return PrintTreeStats (hInstance, hWindow, hTreeWnd, hRoot); <br> <br>} // End DXView_OnPrint <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    PrintDialogProc <br>** Purpose: Dialog procedure for printing <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>BOOL CALLBACK PrintDialogProc ( <br>    HWND    hDialog, <br>    UINT    uiMsg, <br>    WPARAM  wParam, <br>    LPARAM  lParam) <br>{ <br>    switch (uiMsg) <br>    { <br>    case WM_INITDIALOG: <br>        { <br>        // Disable system menu on dialog <br>        HMENU hSysMenu = GetSystemMenu (hDialog, FALSE); <br>        EnableMenuItem (hSysMenu, SC_CLOSE, MF_GRAYED); <br>        } <br>        return TRUE; <br> <br>    case WM_COMMAND: <br>        { <br>        // User is aborting print operation <br>        g_fAbortPrint = TRUE; <br>        EnableWindow (GetParent (hDialog), TRUE); <br>        DestroyWindow (hDialog); <br>        g_hAbortPrintDlg = NULL; <br>        } <br>        return TRUE; <br>    } // End switch <br> <br>    return FALSE; <br>} // End PrintDialogProc <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    AbortProc <br>** Purpose: Abort procedure for printing <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>BOOL CALLBACK AbortProc (HDC hPrinterDC, int iCode) <br>{ <br>    MSG msg; <br> <br>    while (! g_fAbortPrint &amp;&amp; PeekMessage (&amp;msg, NULL, 0, 0, PM_REMOVE)) <br>    { <br>        if ((! g_hAbortPrintDlg) || ! IsDialogMessage (g_hAbortPrintDlg, &amp;msg)) <br>        { <br>            TranslateMessage (&amp;msg); <br>            DispatchMessage (&amp;msg); <br>        } <br>    } <br> <br>    return !g_fAbortPrint; <br>} // End AbortProc <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    PrintStats <br>** Purpose: Print user defined stuff <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>BOOL CALLBACK PrintTreeStats( <br>    HINSTANCE   hInstance, <br>    HWND        hWindow, <br>    HWND        hTreeWnd, <br>    HTREEITEM   hRoot) <br>{ <br>    static DOCINFO  di; <br>    static PRINTDLG pd; <br> <br>    BOOL        fDone           = FALSE; <br>    BOOL        fFindNext       = FALSE; <br>    BOOL        fResult         = FALSE; <br>    BOOL        fStartDoc       = FALSE; <br>    BOOL        fDisableWindow  = FALSE; <br>    LPTSTR      pstrTitle       = NULL; <br>    LPTSTR      pstrBuff        = NULL; <br>    TEXTMETRIC  tm; <br>    DWORD       dwCurrCopy; <br>    HANDLE      hHeap; <br>    DWORD       cbSize; <br>    DWORD       cchLen; <br>    TV_ITEM     tvi; <br>    HTREEITEM   hStartTree, hTempTree; <br>    PRINTCBINFO pci; <br> <br>    // Check Parameters <br>    if ((! hInstance) || (! hWindow) || (! hTreeWnd)) <br>    { <br>        // Error, invalid parameters <br>        return FALSE; <br>    } <br> <br>    // Get Starting point for tree <br>    if (hRoot) <br>        hStartTree = hRoot; <br>    else <br>        hStartTree = TreeView_GetRoot (hTreeWnd); <br>    if (! hStartTree) <br>    { <br>        // Error, invalid tree <br>        return FALSE; <br>    } <br>     <br>    // Initialize Print Dialog structure <br>    pd.lStructSize          = sizeof (PRINTDLG); <br>    pd.hwndOwner            = hWindow; <br>    pd.hDevMode             = NULL; <br>    pd.hDevNames            = NULL; <br>    pd.hDC                  = NULL; <br>    pd.Flags                = PD_ALLPAGES | PD_RETURNDC; <br>    pd.nFromPage            = 0; <br>    pd.nToPage              = 0; <br>    pd.nMinPage             = 0; <br>    pd.nMaxPage             = 0; <br>    pd.nCopies              = 1; <br>    pd.hInstance            = NULL; <br>    pd.lCustData            = 0L; <br>    pd.lpfnPrintHook        = NULL; <br>    pd.lpfnSetupHook        = NULL; <br>    pd.lpPrintTemplateName  = NULL; <br>    pd.lpSetupTemplateName  = NULL; <br>    pd.hPrintTemplate       = NULL; <br>    pd.hSetupTemplate       = NULL; <br> <br>    if(g_PrintToFile) <br>    { <br>        pci.hdcPrint = NULL; <br>    }else <br>    { <br>        // Call Common Print Dialog to get printer DC <br>        if ((! PrintDlg (&amp;pd)) || (! pd.hDC)) <br>        { <br>            // Error, Print Dialog failed or user canceled <br>            return TRUE; <br>        } <br>        pci.hdcPrint = pd.hDC; <br>        // Get Text metrics for printing <br>        if (! GetTextMetrics (pci.hdcPrint, &amp;tm)) <br>        { <br>            // Error, TextMetrics failed <br>            goto lblCLEANUP; <br>        } <br>    } <br>    if(g_PrintToFile) <br>    { <br>        pci.dwLineHeight   = 1; <br>        pci.dwCharWidth    = 1; <br>        pci.dwCharsPerLine = 80; <br>        pci.dwLinesPerPage = 66; <br>    }else <br>    { <br>        pci.dwLineHeight   = tm.tmHeight + tm.tmExternalLeading; <br>        pci.dwCharWidth    = tm.tmAveCharWidth; <br>        pci.dwCharsPerLine = GetDeviceCaps (pci.hdcPrint, HORZRES) / pci.dwCharWidth; <br>        pci.dwLinesPerPage = GetDeviceCaps (pci.hdcPrint, VERTRES) / pci.dwLineHeight; <br>    } <br>  <br>    // Get Heap <br>    hHeap = GetProcessHeap (); <br>    if (! hHeap) <br>    { <br>        // Error, no heap associated with this process <br>        goto lblCLEANUP; <br>    } <br> <br>    // Create line buffer <br>    cbSize = (pci.dwCharsPerLine + 1) * sizeof(TCHAR); <br>    pstrBuff = (LPTSTR) HeapAlloc (hHeap, HEAP_NO_SERIALIZE, cbSize); <br>    if (! pstrBuff) <br>    { <br>        // Error, not enough memory  <br>        goto lblCLEANUP; <br>    } <br> <br>    // Disable Parent window <br>    EnableWindow (hWindow, FALSE); <br>    fDisableWindow = TRUE; <br> <br>    // Start Printer Abort Dialog <br>    g_fAbortPrint = FALSE; <br>    g_hAbortPrintDlg = CreateDialog (hInstance, MAKEINTRESOURCE (IDD_ABORTPRINTDLG), <br>                                     hWindow, (DLGPROC)PrintDialogProc); <br>    if (! g_hAbortPrintDlg) <br>    { <br>        // Error, unable to create abort dialog <br>        goto lblCLEANUP; <br>    } <br> <br>    // <br>    // Set Document title to Root string <br>    // <br>    tvi.mask            = TVIF_CHILDREN | TVIF_TEXT; <br>    tvi.hItem           = hStartTree; <br>    tvi.pszText         = pstrBuff; <br>    tvi.cchTextMax      = pci.dwCharsPerLine; <br>    if (TreeView_GetItem (hTreeWnd, &amp;tvi)) <br>    { <br>        SetWindowText (g_hAbortPrintDlg, pstrBuff); <br>        SetAbortProc (pd.hDC, AbortProc); <br>        cchLen = _tcsclen (pstrBuff); <br>        cbSize = (cchLen + 1) * sizeof(TCHAR); <br>        pstrTitle = (LPTSTR) HeapAlloc (hHeap, HEAP_NO_SERIALIZE, cbSize); <br>        if (! pstrTitle) <br>        { <br>            // Error, not enough memory  <br>            goto lblCLEANUP; <br>        } <br> <br>        _tcsncpy (pstrTitle, pstrBuff, cchLen); <br>        pstrTitle[cchLen] = 0; <br>    } <br>    else <br>    { <br>        SetWindowText (g_hAbortPrintDlg, TEXT("Unknown")); <br>        SetAbortProc (pd.hDC, AbortProc); <br>        cchLen = _tcsclen (TEXT("Unknown")); <br>        cbSize = (cchLen + 1) * sizeof(TCHAR); <br>        pstrTitle = (LPTSTR) HeapAlloc (hHeap, HEAP_NO_SERIALIZE, cbSize); <br>        if (! pstrTitle) <br>        { <br>            // Error, not enough memory  <br>            goto lblCLEANUP; <br>        } <br> <br>        _tcsncpy (pstrTitle, TEXT("Unknown"), cchLen); <br>        pstrTitle[cchLen] = 0; <br>    } <br> <br>    // Initialize Document Structure <br>    di.cbSize       = sizeof(DOCINFO); <br>    di.lpszDocName  = pstrTitle;  <br>    di.lpszOutput   = NULL;  <br>    di.lpszDatatype = NULL; <br>    di.fwType       = 0; <br> <br>    // Start document <br>    if(g_PrintToFile) <br>    { <br>        g_FileHandle = CreateFile("dxview.log",GENERIC_WRITE,0,NULL,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL); <br>    } else <br>    if (StartDoc (pd.hDC, &amp;di) &lt; 0) <br>    { <br>        // Error, StartDoc failed <br>        goto lblCLEANUP; <br>    } <br>    fStartDoc = TRUE; <br> <br>    // Print requested number of copies <br>    fResult = FALSE; <br>    for (dwCurrCopy = 0; dwCurrCopy &lt; (DWORD)pd.nCopies; dwCurrCopy++) <br>    { <br> <br>        pci.hCurrTree       = hStartTree; <br>        pci.fStartPage      = TRUE; <br>        pci.dwCurrIndent    = 0; <br> <br> <br>        // Note:  We are basically doing an pre-order traversal <br>        //        of the Tree.  Printing the current node <br>        //        before moving on to it's children or siblings <br> <br>        fDone               = FALSE; <br>        while (! fDone) <br>        { <br>            // Check if we need to start a new page <br>            if (! PrintStartPage (&amp;pci)) <br>            { <br>                goto lblCLEANUP; <br>            } <br> <br>            // <br>            // Get Current Item in Tree  <br>            // and print it's text info and associated Node caps <br>            // <br> <br>            tvi.mask            = TVIF_CHILDREN | TVIF_TEXT | TVIF_PARAM; <br>            tvi.hItem           = pci.hCurrTree; <br>            tvi.pszText         = pstrBuff; <br>            tvi.lParam          = 0; <br>            tvi.cchTextMax      = pci.dwCharsPerLine; <br>            if (TreeView_GetItem (hTreeWnd, &amp;tvi)) <br>            { <br>                cchLen = _tcslen (pstrBuff); <br>                if (cchLen &gt; 0) <br>                { <br>                    int xOffset = (int)(pci.dwCurrIndent * DEF_TAB_SIZE * pci.dwCharWidth); <br>                    int yOffset = (int)(pci.dwLineHeight * pci.dwCurrLine); <br> <br>                    // Print this line <br>                    if (! PrintLine (xOffset, yOffset, pstrBuff, cchLen, &amp;pci)) <br>                    { <br>                        goto lblCLEANUP; <br>                    } <br>     <br>                    // Advance to next line in page <br>                    if (! PrintNextLine (&amp;pci)) <br>                    { <br>                        goto lblCLEANUP; <br>                    } <br> <br>                    // Check if there is any additional node info  <br>                    // that needs to be printed <br>                    if (tvi.lParam != 0) <br>                    { <br>                        NODEINFO * pni = (NODEINFO*)tvi.lParam; <br>                     <br>                        if (pni &amp;&amp; pni-&gt;printCallback) <br>                        {                             <br>                            // Force indent to offset node info from tree info <br>                            pci.dwCurrIndent += 2; <br> <br>                            if (! pni-&gt;printCallback(pni-&gt;lParam1, pni-&gt;lParam2, &amp;pci)) <br>                            { <br>                                // Error, callback failed <br>                                goto lblCLEANUP; <br>                            } <br> <br>                            // Recover indent <br>                            pci.dwCurrIndent -= 2; <br>                        } <br>                    } <br>                } <br>            } // End if TreeView_GetItem() <br> <br>             <br>             <br>            //  <br>            // Get Next Item in tree <br>            // <br> <br>            // Get first child, if any <br>            if (tvi.cChildren) <br>            { <br>                // Get First child <br>                hTempTree = TreeView_GetChild (hTreeWnd, pci.hCurrTree); <br>                if (hTempTree) <br>                { <br>                    // Increase Indentation <br>                    pci.dwCurrIndent++; <br> <br>                    pci.hCurrTree = hTempTree; <br>                    continue; <br>                } <br>            } <br>             <br>            // Exit, if we are the root <br>            if (pci.hCurrTree == hRoot) <br>            { <br>                // We have reached the root, so stop <br>                PrintEndPage (&amp;pci); <br>                fDone = TRUE; <br>                continue; <br>            } <br> <br>            // Get next sibling in the chain <br>            hTempTree = TreeView_GetNextSibling (hTreeWnd, pci.hCurrTree); <br>            if (hTempTree) <br>            { <br>                pci.hCurrTree = hTempTree; <br>                continue; <br>            } <br> <br>            // Get next Ancestor yet to be processed <br>            // (uncle, granduncle, etc) <br>            fFindNext = FALSE; <br>            while (! fFindNext) <br>            { <br>                hTempTree = TreeView_GetParent (hTreeWnd, pci.hCurrTree); <br>                if ((! hTempTree) || (hTempTree == hRoot)) <br>                { <br>                    // We have reached the root, so stop <br>                    PrintEndPage (&amp;pci); <br>                    fDone       = TRUE; <br>                    fFindNext   = TRUE; <br>                } <br>                else <br>                { <br>                    // Move up to the parent <br>                    pci.hCurrTree = hTempTree; <br> <br>                    // Decrease Indentation <br>                    pci.dwCurrIndent--; <br> <br>                    // Since we have already processed the parent  <br>                    // we want to get the uncle/aunt node <br>                    hTempTree = TreeView_GetNextSibling (hTreeWnd, pci.hCurrTree); <br>                    if (hTempTree) <br>                    { <br>                        // Found a non-processed node <br>                        pci.hCurrTree = hTempTree; <br>                        fFindNext = TRUE; <br>                    } <br>                } <br>            } <br>        } // End While (! fDone) <br>    } // End for num copies <br> <br>    // Success <br>    fResult = TRUE; <br> <br>lblCLEANUP:     <br>    // End Document <br>    if (fStartDoc) <br>    { <br>        if(g_PrintToFile) <br>        { <br>            CloseHandle(g_FileHandle); <br>        } else <br>        EndDoc (pd.hDC); <br>        fStartDoc = FALSE; <br>    } <br> <br>    // Re-enable main window <br>    // Note:  Do this before destroying abort dialog <br>    //        otherwise the main window loses focus <br>    if (fDisableWindow) <br>    { <br>        EnableWindow (hWindow, TRUE); <br>        fDisableWindow = FALSE; <br>    } <br> <br>    // Destroy Abort Dialog <br>    if (g_hAbortPrintDlg) <br>    { <br>        DestroyWindow (g_hAbortPrintDlg); <br>        g_hAbortPrintDlg = NULL; <br>    } <br> <br>    // Free title memory <br>    if (pstrTitle) <br>    { <br>        HeapFree (hHeap, 0, (LPVOID)pstrTitle); <br>        pstrTitle       = NULL; <br>        di.lpszDocName  = NULL;  <br>    } <br> <br>    // Free buffer memory <br>    if (pstrBuff) <br>    { <br>        HeapFree (hHeap, 0, (LPVOID)pstrBuff); <br>        pstrBuff = NULL; <br>    } <br> <br>    // Cleanup printer DC <br>    if (pd.hDC) <br>    { <br>        DeleteDC (pd.hDC); <br>        pd.hDC = NULL; <br>    } <br> <br>    // Return success/failure <br>    return fResult; <br>} // End PrintTreeStats <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    PrintStartPage <br>** Purpose: check if we need to start a new page <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>BOOL PrintStartPage (PRINTCBINFO * pci) <br>{ <br>    if(g_PrintToFile) <br>        return TRUE; <br>    if (! pci) <br>        return FALSE; <br> <br>    // Check if we need to start a new page <br>    if (pci-&gt;fStartPage) <br>    { <br>        // Check for user abort <br>        if (g_fAbortPrint) <br>        { <br>            // Error, user canceled printing job <br>            return FALSE; <br>        }  <br> <br>        // Start new page <br>        if (StartPage (pci-&gt;hdcPrint) &lt; 0) <br>        { <br>            // Error, StartPage failed <br>            return FALSE; <br>        } <br> <br>        // Reset line count <br>        pci-&gt;fStartPage = FALSE; <br>        pci-&gt;dwCurrLine = 0; <br>    } <br> <br>    // Success <br>    return TRUE; <br>} // End PrintStartPage <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    PrintEndPage <br>** Purpose: check if we need to start a new page <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>BOOL PrintEndPage (PRINTCBINFO * pci) <br>{ <br>    if(g_PrintToFile) <br>        return TRUE; <br>    if (! pci) <br>        return FALSE; <br> <br>    // Check if we need to end this page <br>    if (! pci-&gt;fStartPage) <br>    { <br>        // End page <br>        if (EndPage (pci-&gt;hdcPrint) &lt; 0) <br>        { <br>            // Error, end page failed <br>            return FALSE; <br>        } <br>        pci-&gt;fStartPage = TRUE; <br> <br>        // Check for user abort <br>        if (g_fAbortPrint) <br>        { <br>            // Error, user canceled printing job <br>            return FALSE; <br>        }  <br>    } <br> <br>    // Success <br>    return TRUE; <br>} // End PrintEndPage <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    PrintLine <br>** Purpose: Prints text to page at specified location <br>**----------------------------------------------------------------------------- <br>*/ <br>static DWORD iLastXPos; <br> <br>BOOL PrintLine ( <br>    int xOffset, <br>    int yOffset, <br>    LPCTSTR pszBuff, <br>    DWORD  cchBuff, <br>    PRINTCBINFO * pci) <br>{ <br>    if (! pci) <br>    { <br>        // Programming error <br>        return FALSE; <br>    } <br> <br>    // Check if we need to start a new page <br>    if (! PrintStartPage (pci)) <br>        return FALSE; <br> <br>    if ((! pszBuff) || (! cchBuff)) <br>    { <br>        // Nothing to print <br>        // assume it's OK and just keep printing <br>        return TRUE; <br>    } <br> <br>    // Print text out to buffer current line <br>    if(g_PrintToFile) <br>    { <br>        DWORD Foobar; <br>        TCHAR Temp[80]; <br> <br>        if(((xOffset-iLastXPos)/pci-&gt;dwCharWidth)&gt;80) <br>            return TRUE; <br>        memset(Temp,' ',sizeof(TCHAR)*79); <br>        Temp[(xOffset-iLastXPos)/pci-&gt;dwCharWidth]=0; <br>        WriteFile(g_FileHandle,Temp,(xOffset-iLastXPos)/pci-&gt;dwCharWidth,&amp;Foobar,NULL); <br>        iLastXPos = (xOffset-iLastXPos)+(pci-&gt;dwCharWidth * cchBuff); <br>             <br>        WriteFile(g_FileHandle,pszBuff,cchBuff,&amp;Foobar,NULL); <br>    }else <br>    { <br>        TextOut (pci-&gt;hdcPrint, xOffset, yOffset, pszBuff, cchBuff); <br>    }; <br> <br>    return TRUE; <br>} // End PrintLine <br>     <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    PrintNextLine <br>** Purpose: advance to next line on page <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>BOOL PrintNextLine (PRINTCBINFO * pci) <br>{ <br> <br>    if(g_PrintToFile) <br>    { <br>        DWORD Foobar; <br> <br>        WriteFile(g_FileHandle,"\r\n",2,&amp;Foobar,NULL); <br>        iLastXPos = 0; <br>        return TRUE; <br>    }; <br>    if (! pci) <br>        return FALSE; <br> <br>    pci-&gt;dwCurrLine++; <br> <br>    // Check if we need to end the page <br>    if (pci-&gt;dwCurrLine &gt;= pci-&gt;dwLinesPerPage) <br>    { <br>        return PrintEndPage (pci); <br>    } <br> <br>    // Success <br>    return TRUE; <br>} // End PrintNextLine <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    DoMessage <br>** Purpose: display warning message to user <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>#define MAX_TITLE   64 <br>#define MAX_MESSAGE 256 <br> <br>void DoMessage (DWORD dwTitle, DWORD dwMsg) <br>{ <br>    TCHAR szTitle[MAX_TITLE]; <br>    TCHAR szMsg[MAX_MESSAGE]; <br>    HMODULE hModule; <br> <br>    hModule = GetModuleHandle (NULL); <br> <br>    LoadString (hModule, dwTitle, szTitle, MAX_TITLE); <br>    LoadString (hModule, dwMsg, szMsg, MAX_MESSAGE); <br>    MessageBox (NULL, szMsg, szTitle, MB_OK); <br>} // End DoMessage <br>   <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** End of File <br>**----------------------------------------------------------------------------- <br>*/ </code></pre>
<p>&nbsp;</p></body>
</HTML>
