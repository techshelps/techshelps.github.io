<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DDEX5.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3021"></a>DDEX5.CPP</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1995-1997 Microsoft Corporation. All Rights Reserved. <br> * <br> *  File:ddex5.cpp <br> *  Content:Direct Draw example program 5.Adds functionality to <br> *example program 4.  Uses GetEntries() to read a palette, <br> *modifies the entries, and then uses SetEntries() to update <br> *the palette.  This program requires 1.2 Meg of video ram. <br> * <br> ***************************************************************************/ <br> <br>#define NAME "DDExample5" <br>#define TITLE "Direct Draw Example 5" <br> <br>#define WIN32_LEAN_AND_MEAN <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;ddraw.h&gt; <br>#include "resource.h" <br>#include "ddutil.h" <br> <br>char szBitmap[] = "ALL"; <br> <br>LPDIRECTDRAWlpDD;// DirectDraw object <br>LPDIRECTDRAWSURFACElpDDSPrimary;// DirectDraw primary surface <br>LPDIRECTDRAWSURFACElpDDSBack;// DirectDraw back surface <br>LPDIRECTDRAWSURFACElpDDSOne;// Offscreen surface 1 <br>LPDIRECTDRAWPALETTElpDDPal;// The primary surface palette <br>BOOLbActive;// is application active? <br> <br>BYTE torusColors[256];// Marks the colors used in the torus <br> <br>/* <br> * restoreAll <br> * <br> * restore all lost objects <br> */ <br>HRESULT restoreAll( void ) <br>{ <br>    HRESULTddrval; <br>    DDSURFACEDESCddsd; <br> <br>    ddrval = lpDDSPrimary-&gt;Restore(); <br>    if( ddrval == DD_OK ) <br>    { <br>ddrval = lpDDSOne-&gt;Restore(); <br>if( ddrval == DD_OK ) <br>        { <br>            DDReLoadBitmap(lpDDSOne, szBitmap); <br>} <br>    } <br> <br>    //Loose the old palette <br>    lpDDPal-&gt;Release(); <br>    // create and set the palette (restart cycling from the same place) <br>    lpDDPal = DDLoadPalette(lpDD, szBitmap); <br> <br>    if (lpDDPal) <br>        lpDDSPrimary-&gt;SetPalette(lpDDPal); <br>    // <br>    // Mark the colors used in the torus frames <br>    // <br>    int i,x,y; <br> <br>    // First, set all colors as unused <br>    for(i=0; i&lt;256; i++) <br>    { <br>        torusColors[i] = 0; <br>    } <br> <br>    // lock the surface and scan the lower part (the torus area) <br>    // and remember all the index's we find. <br>    ddsd.dwSize = sizeof(ddsd); <br>    while (lpDDSOne-&gt;Lock(NULL, &amp;ddsd, 0, NULL) == DDERR_WASSTILLDRAWING) <br>        ; <br> <br>    // Now search through the torus frames and mark used colors <br>    for( y=480; y&lt;480+384; y++ ) <br>    { <br>        for( x=0; x&lt;640; x++ ) <br>        { <br>            torusColors[((BYTE *)ddsd.lpSurface)[y*ddsd.lPitch+x]] = 1; <br>        } <br>    } <br> <br>    lpDDSOne-&gt;Unlock(NULL); <br> <br>    return ddrval; <br> <br>} /* restoreAll */ <br> <br>/* <br> * updateFrame <br> *  <br> * Decide what needs to be blitted next, wait for flip to complete, <br> * then flip the buffers. <br> */ <br>void updateFrame( void ) <br>{ <br>    static DWORDlastTickCount[4] = {0,0,0,0}; <br>    static intcurrentFrame[3] = {0,0,0}; <br>    DWORDthisTickCount; <br>    RECTrcRect; <br>    DWORDdelay[4] = {50, 78, 13, 93}; <br>    inti; <br>    intxpos[3] = {288, 190, 416}; <br>    intypos[3] = {128, 300, 256}; <br>    PALETTEENTRYpe[256]; <br>    HRESULTddrval; <br> <br>    // Decide which frame will be blitted next <br>    thisTickCount = GetTickCount(); <br>    for(i=0; i&lt;3; i++) <br>    { <br>if((thisTickCount - lastTickCount[i]) &gt; delay[i]) <br>{ <br>    // Move to next frame; <br>    lastTickCount[i] = thisTickCount; <br>    currentFrame[i]++; <br>    if(currentFrame[i] &gt; 59) <br>currentFrame[i] = 0; <br>} <br>    } <br> <br>    // Blit the stuff for the next frame <br>    rcRect.left = 0; <br>    rcRect.top = 0; <br>    rcRect.right = 640; <br>    rcRect.bottom = 480; <br>    while( 1 ) <br>    { <br>        ddrval = lpDDSBack-&gt;BltFast( 0, 0, lpDDSOne, <br>            &amp;rcRect, DDBLTFAST_NOCOLORKEY ); <br> <br>if( ddrval == DD_OK ) <br>{ <br>    break; <br>} <br>if( ddrval == DDERR_SURFACELOST ) <br>{ <br>    ddrval = restoreAll(); <br>    if( ddrval != DD_OK ) <br>    { <br>return; <br>    } <br>} <br>if( ddrval != DDERR_WASSTILLDRAWING ) <br>{ <br>    return; <br>} <br>    } <br>    if(ddrval != DD_OK) <br>    { <br>    return; <br>    } <br> <br>    for(i=0; i&lt;3; i++) <br>    { <br>        rcRect.left   = currentFrame[i]%10*64; <br>        rcRect.top    = currentFrame[i]/10*64 + 480; <br>        rcRect.right  = currentFrame[i]%10*64 + 64; <br>        rcRect.bottom = currentFrame[i]/10*64 + 64 + 480; <br> <br>while( 1 ) <br>{ <br>    ddrval = lpDDSBack-&gt;BltFast( xpos[i], ypos[i], lpDDSOne, <br>                                 &amp;rcRect, DDBLTFAST_SRCCOLORKEY ); <br> <br>    if( ddrval == DD_OK ) <br>    { <br>break; <br>    } <br>    if( ddrval == DDERR_SURFACELOST ) <br>    { <br>ddrval = restoreAll(); <br>if( ddrval != DD_OK ) <br>{ <br>    return; <br>} <br>    } <br>    if( ddrval != DDERR_WASSTILLDRAWING ) <br>    { <br>return; <br>    } <br>} <br>    } <br> <br>    if( (thisTickCount - lastTickCount[3]) &gt; delay[3] ) <br>    { <br>// Change the palette <br>if(lpDDPal-&gt;GetEntries( 0, 0, 256, pe ) != DD_OK) <br>{ <br>    return; <br>} <br> <br>for(i=1; i&lt;256; i++) <br>{ <br>    if(!torusColors[i]) <br>    { <br>continue; <br>    } <br>    pe[i].peRed = (pe[i].peRed+2) % 256; <br>    pe[i].peGreen = (pe[i].peGreen+1) % 256; <br>    pe[i].peBlue = (pe[i].peBlue+3) % 256; <br>} <br>if(lpDDPal-&gt;SetEntries( 0, 0, 256, pe) != DD_OK) <br>{ <br>    return; <br>} <br>     <br>lastTickCount[3] = thisTickCount; <br>    } <br>     <br>    // Flip the surfaces <br>    while( 1 ) <br>    { <br>ddrval = lpDDSPrimary-&gt;Flip( NULL, 0 ); <br>if( ddrval == DD_OK ) <br>{ <br>    break; <br>} <br>if( ddrval == DDERR_SURFACELOST ) <br>{ <br>    ddrval = restoreAll(); <br>    if( ddrval != DD_OK ) <br>    { <br>break; <br>    } <br>} <br>if( ddrval != DDERR_WASSTILLDRAWING ) <br>{ <br>    break; <br>} <br>    } <br> <br>} /* updateFrame */ <br> <br>/* <br> * finiObjects <br> * <br> * finished with all objects we use; release them <br> */ <br>static void finiObjects( void ) <br>{ <br>    if( lpDD != NULL ) <br>    { <br>if( lpDDSPrimary != NULL ) <br>{ <br>    lpDDSPrimary-&gt;Release(); <br>    lpDDSPrimary = NULL; <br>} <br>if( lpDDSOne != NULL ) <br>{ <br>    lpDDSOne-&gt;Release(); <br>    lpDDSOne = NULL; <br>} <br>if( lpDDPal != NULL ) <br>{ <br>    lpDDPal-&gt;Release(); <br>    lpDDPal = NULL; <br>} <br>lpDD-&gt;Release(); <br>lpDD = NULL; <br>    } <br> <br>} /* finiObjects */ <br> <br>long FAR PASCAL WindowProc( HWND hWnd, UINT message,  <br>    WPARAM wParam, LPARAM lParam ) <br>{ <br>    switch( message ) <br>    { <br>    case WM_ACTIVATEAPP: <br>    bActive = wParam; <br>break; <br> <br>    case WM_SETCURSOR: <br>        SetCursor(NULL); <br>        return TRUE; <br> <br>    case WM_CREATE: <br>break; <br> <br>    case WM_KEYDOWN: <br>switch( wParam ) <br>{ <br>case VK_ESCAPE: <br>        case VK_F12: <br>            PostMessage(hWnd, WM_CLOSE, 0, 0); <br>    break; <br>} <br>break; <br> <br>    case WM_DESTROY: <br>    finiObjects(); <br>PostQuitMessage( 0 ); <br>break; <br>    } <br> <br>    return DefWindowProc(hWnd, message, wParam, lParam); <br> <br>} /* WindowProc */ <br> <br> <br> <br>/* <br> * This function is called if the initialization function fails <br> */ <br>BOOL initFail( HWND hwnd ) <br>{ <br>    finiObjects(); <br>    MessageBox( hwnd, "DirectDraw Init FAILED", TITLE, MB_OK ); <br>    DestroyWindow( hwnd ); <br>    return FALSE; <br> <br>} /* initFail */ <br> <br>/* <br> * doInit - do work required for every instance of the application: <br> *  create the window, initialize data <br> */ <br>static BOOL doInit( HINSTANCE hInstance, int nCmdShow ) <br>{ <br>    HWNDhwnd; <br>    WNDCLASSwc; <br>    DDSURFACEDESCddsd; <br>    DDSCAPSddscaps; <br>    HRESULTddrval; <br> <br>    /* <br>     * set up and register window class <br>     */ <br>    wc.style = CS_HREDRAW | CS_VREDRAW; <br>    wc.lpfnWndProc = WindowProc; <br>    wc.cbClsExtra = 0; <br>    wc.cbWndExtra = 0; <br>    wc.hInstance = hInstance; <br>    wc.hIcon = LoadIcon( hInstance, IDI_APPLICATION ); <br>    wc.hCursor = LoadCursor( NULL, IDC_ARROW ); <br>    wc.hbrBackground = GetStockBrush(BLACK_BRUSH); <br>    wc.lpszMenuName = NAME; <br>    wc.lpszClassName = NAME; <br>    RegisterClass( &amp;wc ); <br> <br>    /* <br>     * create a window <br>     */ <br>    hwnd = CreateWindowEx( <br>        0, <br>NAME, <br>TITLE, <br>WS_POPUP, <br>0, <br>0, <br>        GetSystemMetrics(SM_CXSCREEN), <br>        GetSystemMetrics(SM_CYSCREEN), <br>NULL, <br>NULL, <br>hInstance, <br>        NULL ); <br> <br>    if( !hwnd ) <br>    { <br>return FALSE; <br>    } <br> <br>    ShowWindow( hwnd, nCmdShow ); <br>    UpdateWindow( hwnd ); <br>    SetFocus( hwnd ); <br> <br>    /* <br>     * create the main DirectDraw object <br>     */ <br>    ddrval = DirectDrawCreate( NULL, &amp;lpDD, NULL ); <br>    if( ddrval != DD_OK ) <br>    { <br>return initFail(hwnd); <br>    } <br> <br>    // Get exclusive mode <br>    ddrval = lpDD-&gt;SetCooperativeLevel( hwnd, DDSCL_EXCLUSIVE | DDSCL_FULLSCREEN ); <br>    if( ddrval != DD_OK ) <br>    { <br>return initFail(hwnd); <br>    } <br> <br>    // Set the video mode to 640x480x8 <br>    ddrval = lpDD-&gt;SetDisplayMode( 640, 480, 8); <br>    if(ddrval != DD_OK) <br>    { <br>return initFail(hwnd); <br>    } <br> <br>    // Create the primary surface with 1 back buffer <br>    ddsd.dwSize = sizeof( ddsd ); <br>    ddsd.dwFlags = DDSD_CAPS | DDSD_BACKBUFFERCOUNT; <br>    ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE | <br>  DDSCAPS_FLIP | <br>  DDSCAPS_COMPLEX; <br>    ddsd.dwBackBufferCount = 1; <br>    ddrval = lpDD-&gt;CreateSurface( &amp;ddsd, &amp;lpDDSPrimary, NULL ); <br>    if( ddrval != DD_OK ) <br>    { <br>return initFail(hwnd); <br>    } <br> <br>    ddscaps.dwCaps = DDSCAPS_BACKBUFFER; <br>    ddrval = lpDDSPrimary-&gt;GetAttachedSurface(&amp;ddscaps, &amp;lpDDSBack); <br>    if( ddrval != DD_OK ) <br>    { <br>return initFail(hwnd); <br>    } <br> <br>    // create and set the palette <br>    lpDDPal = DDLoadPalette(lpDD, szBitmap); <br> <br>    if (lpDDPal) <br>        lpDDSPrimary-&gt;SetPalette(lpDDPal); <br> <br>    // Create the offscreen surface, by loading our bitmap. <br>    lpDDSOne = DDLoadBitmap(lpDD, szBitmap, 0, 0); <br> <br>    if( lpDDSOne == NULL ) <br>    { <br>return initFail(hwnd); <br>    } <br> <br>    // set the color key to black <br>    DDSetColorKey(lpDDSOne, RGB(0,0,0)); <br> <br>    // <br>    // Mark the colors used in the torus frames <br>    // <br>    int i,x,y; <br> <br>    // First, set all colors as unused <br>    for(i=0; i&lt;256; i++) <br>    { <br>        torusColors[i] = 0; <br>    } <br> <br>    // lock the surface and scan the lower part (the torus area) <br>    // and remember all the index's we find. <br>    ddsd.dwSize = sizeof(ddsd); <br>    while (lpDDSOne-&gt;Lock(NULL, &amp;ddsd, 0, NULL) == DDERR_WASSTILLDRAWING) <br>        ; <br> <br>    // Now search through the torus frames and mark used colors <br>    for( y=480; y&lt;480+384; y++ ) <br>    { <br>        for( x=0; x&lt;640; x++ ) <br>        { <br>            torusColors[((BYTE *)ddsd.lpSurface)[y*ddsd.lPitch+x]] = 1; <br>        } <br>    } <br> <br>    lpDDSOne-&gt;Unlock(NULL); <br> <br>    return TRUE; <br> <br>} /* doInit */ <br> <br>/* <br> * WinMain - initialization, message loop <br> */ <br>int PASCAL WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, <br>LPSTR lpCmdLine, int nCmdShow) <br>{ <br>    MSGmsg; <br> <br>    lpCmdLine = lpCmdLine; <br>    hPrevInstance = hPrevInstance; <br> <br>    if( !doInit( hInstance, nCmdShow ) ) <br>    { <br>return FALSE; <br>    } <br> <br>    while( 1 ) <br>    { <br>if( PeekMessage( &amp;msg, NULL, 0, 0, PM_NOREMOVE ) ) <br>{ <br>    if( !GetMessage( &amp;msg, NULL, 0, 0 ) ) <br>    { <br>return msg.wParam; <br>    } <br>    TranslateMessage(&amp;msg);  <br>    DispatchMessage(&amp;msg); <br>} <br>else if( bActive ) <br>{ <br>    updateFrame(); <br>        } <br>        else <br>        { <br>            // make sure we go to sleep if we have nothing else to do <br>            WaitMessage(); <br>        } <br>    } <br>} /* WinMain */ </code></pre>
<p>&nbsp;</p></body>
</HTML>
