<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PALETTE.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3273"></a>PALETTE.CPP</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1995-1997 Microsoft Corporation. All Rights Reserved. <br> * <br> *  File:palette.cpp <br> *  Content:Does some basic palette manipulation <br> * <br> ***************************************************************************/ <br>#define WIN32_LEAN_AND_MEAN <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;ddraw.h&gt; <br>#include "resource.h" <br>#include "lbprintf.h" <br> <br>static charszClass[32]="DDTest1Class"; <br>static charszCaption[32]="DirectDraw Palette Test"; <br> <br>/* <br> * DirectDraw objects we will use <br> */ <br>#define MAX_PALETTES4 <br>LPDIRECTDRAWlpDD; <br>LPDIRECTDRAWSURFACElpDDPSurf; <br>LPDIRECTDRAWPALETTElpDDPal[MAX_PALETTES]; <br>LPDIRECTDRAWPALETTElpDDPalCurr; <br> <br>HWNDhWndMain; <br> <br>BOOLbIsExclusive = TRUE; <br>BOOLbActive; <br> <br> <br>/* <br> * doAttach <br> * <br> * attach palette to the primary surface <br> */ <br>static void doAttach( int index ) <br>{ <br>    HRESULTddrval; <br> <br>    ddrval = lpDDPSurf-&gt;SetPalette( lpDDPal[index] ); <br>    if( ddrval == DDERR_SURFACELOST ) <br>    { <br>        lpDDPSurf-&gt;Restore(); <br>        ddrval = lpDDPSurf-&gt;SetPalette( lpDDPal[index] ); <br>    } <br>    if (!FAILED(ddrval)) <br>    { <br>       LBPrintfDDRC( ddrval, "doAttach1: SetPalette" ); <br>       lpDDPalCurr = lpDDPal[index]; <br>    } <br>    else <br>    { <br>LBPrintf( "Could not attach palette" ); <br>lpDDPalCurr = NULL; <br>    } <br> <br>} /* doAttach */ <br> <br>/* <br> * doDetach <br> * <br> * detach the current palette from the primary surface <br> */ <br>static void doDetach( void ) <br>{ <br>    HRESULTddrval; <br> <br>    ddrval = lpDDPSurf-&gt;SetPalette( NULL ); <br>    if( ddrval == DDERR_SURFACELOST ) <br>    { <br>        lpDDPSurf-&gt;Restore(); <br>        ddrval = lpDDPSurf-&gt;SetPalette( NULL ); <br>    } <br>    LBPrintfDDRC( ddrval, "doDetach: SetPalette" ); <br>    lpDDPalCurr = NULL; <br> <br>} /* doDetach */ <br> <br>/* <br> * doCycle <br> * <br> * cycle the current palette's red entries by 10 <br> */ <br>static void doCycle( void ) <br>{ <br>    if( lpDDPalCurr != NULL ) <br>    { <br>#define ENTRIES 10 <br>#define BASE 0 <br>PALETTEENTRYpe[ENTRIES]; <br>HRESULTddrval; <br>inti; <br> <br>/* <br> * display the original entries <br> */ <br>ddrval = lpDDPalCurr-&gt;GetEntries( 0, BASE, ENTRIES, pe ); <br>if( ddrval == DDERR_SURFACELOST ) <br>{ <br>            lpDDPSurf-&gt;Restore(); <br>    ddrval = lpDDPalCurr-&gt;GetEntries( 0, BASE, ENTRIES, pe ); <br>} <br>LBPrintfDDRC( ddrval, "GetEntries" ); <br>LBPrintf( "Old Entries" ); <br>for( i=0;i&lt;ENTRIES;i++ ) <br>{ <br>    LBPrintf( "    pe[%d] (r,g,b) = (%d,%d,%d)", i, pe[i].peRed, <br>pe[i].peGreen, pe[i].peBlue ); <br>} <br> <br>/* <br> * cycle the red values <br> */ <br>for( i=0;i&lt;ENTRIES;i++ ) <br>{ <br>    pe[i].peRed = (BYTE) (((int)pe[i].peRed + 50) % 256); <br>} <br>ddrval = lpDDPalCurr-&gt;SetEntries( 0, BASE, ENTRIES, pe ); <br>if( ddrval == DDERR_SURFACELOST ) <br>{ <br>            lpDDPSurf-&gt;Restore(); <br>    ddrval = lpDDPalCurr-&gt;SetEntries( 0, BASE, ENTRIES, pe ); <br>} <br>LBPrintfDDRC( ddrval, "SetEntries" ); <br> <br>/* <br> * display the new values <br> */ <br>ddrval = lpDDPalCurr-&gt;GetEntries( 0, BASE, ENTRIES, pe ); <br>if( ddrval == DDERR_SURFACELOST ) <br>{ <br>            lpDDPSurf-&gt;Restore(); <br>    ddrval = lpDDPalCurr-&gt;GetEntries( 0, BASE, ENTRIES, pe ); <br>} <br>LBPrintfDDRC( ddrval, "GetEntries" ); <br>LBPrintf( "New Entries" ); <br>for( i=0;i&lt;ENTRIES;i++ ) <br>{ <br>    LBPrintf( "    pe[%d] (r,g,b) = (%d,%d,%d)", i, pe[i].peRed, <br>pe[i].peGreen, pe[i].peBlue ); <br>} <br>    } <br>    else <br>    { <br>LBPrintf( "No palette attached" ); <br>    } <br> <br>} /* doCycle */ <br> <br>/* <br> * resetExclusiveAndPalettes <br> * <br> * Sets exclusive mode to the desired value, and the rebuilds <br> * the palettes. <br> * <br> * Palettes in exclusive mode bypass GDI and go directly to the display <br> * driver, so the performance is much higher. <br> */ <br>static BOOL resetExclusiveAndPalettes( BOOL excl ) <br>{ <br>    LPPALETTEENTRYppe; <br>    inti; <br>    HRESULTddrval; <br> <br>    /* <br>     * create palette entries <br>     */ <br>    ppe = (LPPALETTEENTRY) LocalAlloc( LPTR, sizeof( PALETTEENTRY ) * 256 ); <br>    if( ppe == NULL ) <br>    { <br>return FALSE; <br>    } <br> <br>    /* <br>     * release existing palettes <br>     */ <br>    for( i=0;i&lt;MAX_PALETTES;i++ ) <br>    { <br>if( lpDDPal[i] != NULL ) <br>{ <br>    ddrval = lpDDPal[i]-&gt;Release(); <br>    LBPrintfDDRC( ddrval, "Release" ); <br>    lpDDPal[i] = NULL; <br>} <br>    } <br> <br>    /* <br>     * No current palette any more. <br>     */ <br>    lpDDPalCurr = NULL; <br> <br>    if( excl ) <br>    { <br>ddrval = lpDD-&gt;SetCooperativeLevel( hWndMain, DDSCL_EXCLUSIVE | DDSCL_FULLSCREEN ); <br>    } <br>    else <br>    { <br>ddrval = lpDD-&gt;SetCooperativeLevel( hWndMain, DDSCL_NORMAL ); <br>    } <br>         <br>    LBPrintfDDRC( ddrval, "SetCooperativeLevel" ); <br> <br>    /* <br>     * set up 4 palettes <br>     */ <br>    ppe[0].peRed = 0; <br>    ppe[0].peGreen = 0; <br>    ppe[0].peBlue = 0; <br>    ppe[255].peRed = 255; <br>    ppe[255].peGreen = 255; <br>    ppe[255].peBlue = 255; <br> <br>    for( i=1;i&lt;255;i++ ) <br>    { <br>ppe[i].peRed = 0; <br>ppe[i].peGreen = 0; <br>ppe[i].peBlue = 0; <br>    } <br>    ddrval = lpDD-&gt;CreatePalette( DDPCAPS_8BIT, ppe, &amp;lpDDPal[0], NULL ); <br>    LBPrintfDDRC( ddrval, "CreatePalette" ); <br> <br>    for( i=1;i&lt;255;i++ ) <br>    { <br>ppe[i].peRed = 0; <br>ppe[i].peGreen = 255; <br>ppe[i].peBlue = 255; <br>    } <br>    ddrval = lpDD-&gt;CreatePalette( DDPCAPS_8BIT, ppe, &amp;lpDDPal[1], NULL ); <br>    LBPrintfDDRC( ddrval, "CreatePalette" ); <br> <br>    for( i=1;i&lt;255;i++ ) <br>    { <br>ppe[i].peRed = 255; <br>ppe[i].peGreen = 255; <br>ppe[i].peBlue = 0; <br>    } <br>    ddrval = lpDD-&gt;CreatePalette( DDPCAPS_8BIT, ppe, &amp;lpDDPal[2], NULL ); <br>    LBPrintfDDRC( ddrval, "CreatePalette" ); <br> <br>    for( i=1;i&lt;255;i++ ) <br>    { <br>ppe[i].peRed = 255; <br>ppe[i].peGreen = 0; <br>ppe[i].peBlue = 255; <br>    } <br>    ddrval = lpDD-&gt;CreatePalette( DDPCAPS_8BIT, ppe, &amp;lpDDPal[3], NULL ); <br>    LBPrintfDDRC( ddrval, "CreatePalette" ); <br>    LocalFree( ppe ); <br> <br>    for( i=0;i&lt;MAX_PALETTES;i++ ) <br>    { <br>LBPrintf( "lpDDPal %d = %08lx", i+1, lpDDPal[i] ); <br>    } <br>    return TRUE; <br> <br>} /* resetExclusiveAndPalettes */ <br> <br>/* <br> * WindowProc <br> * <br> * Messages for our window are handled here <br> */ <br>LRESULT CALLBACK WindowProc( HWND hWnd, unsigned uMsg, WPARAM wParam, LPARAM lParam ) <br>{ <br> <br>    switch( uMsg ) <br>    { <br>    case WM_COMMAND: <br>switch( LOWORD( wParam ) ) <br>{ <br>case IDM_EXCLUSIVE: <br>    bIsExclusive = !bIsExclusive; <br>    resetExclusiveAndPalettes( bIsExclusive ); <br>    break; <br>case IDM_ATTACH1: <br>case IDM_ATTACH2: <br>case IDM_ATTACH3: <br>case IDM_ATTACH4: <br>    doAttach( LOWORD( wParam ) - IDM_ATTACH1 ); <br>    break; <br>case IDM_DETACH: <br>    doDetach(); <br>    break; <br>case IDM_CYCLE: <br>    doCycle(); <br>    break; <br>case IDM_CLEAR: <br>    LBClear(); <br>    break; <br>case IDM_EXIT: <br>    DestroyWindow( hWnd ); <br>    break; <br>} <br>break; <br> <br>    case WM_PAINT: <br>    { <br>PAINTSTRUCTps; <br> <br>BeginPaint( hWnd, &amp;ps ); <br>EndPaint( hWnd, &amp;ps ); <br>break; <br>    } <br> <br>    case WM_INITMENU: <br>CheckMenuItem( (HMENU) wParam, IDM_EXCLUSIVE, MF_BYCOMMAND | <br>(bIsExclusive ? MF_CHECKED:MF_UNCHECKED) ); <br>break; <br> <br>    case WM_SIZE: <br>/* <br> * resize our message listbox <br> */ <br>LBSize( LOWORD( lParam ), HIWORD( lParam ) ); <br>break; <br> <br>    case WM_DESTROY: <br>/* <br> * free all DirectDraw objects <br> */ <br>if( lpDD != NULL ) <br>{ <br>    int i; <br> <br>    for( i=0;i&lt;MAX_PALETTES;i++ ) <br>    { <br>if( lpDDPal[i] != NULL ) <br>{ <br>    lpDDPal[i]-&gt;Release(); <br>    lpDDPal[i] = NULL; <br>} <br>    } <br> <br>    if( lpDDPSurf != NULL ) <br>    { <br>lpDDPSurf-&gt;Release(); <br>lpDDPSurf = NULL; <br>    } <br>    lpDD-&gt;Release(); <br>    lpDD = NULL; <br>} <br>PostQuitMessage( 0 ); <br>break; <br> <br>    default: <br>return DefWindowProc( hWnd, uMsg, wParam, lParam ); <br>    } <br>    return 0L; <br> <br>} /* WindowProc */ <br> <br>/* <br> * doInit - do work required for every instance of the application: <br> *  create the window, initialize data <br> */ <br>static BOOL doInit( HINSTANCE hInstance, int nCmdShow ) <br>{ <br>    WNDCLASSwc; <br>    HRESULTddrval; <br>    DDSURFACEDESCddsd; <br> <br>    /* <br>     * set up and register window class <br>     */ <br>    wc.style = CS_HREDRAW | CS_VREDRAW; <br>    wc.lpfnWndProc = (WNDPROC) WindowProc; <br>    wc.cbClsExtra = 0; <br>    wc.cbWndExtra = sizeof( DWORD ); <br>    wc.hInstance = hInstance; <br>    wc.hIcon = LoadIcon( hInstance, IDI_APPLICATION ); <br>    wc.hCursor = LoadCursor( NULL, IDC_ARROW ); <br>    wc.hbrBackground = (HBRUSH)GetStockObject( WHITE_BRUSH ); <br>    wc.lpszMenuName = MAKEINTRESOURCE( IDR_MENU ); <br>    wc.lpszClassName = szClass; <br>    if( !RegisterClass( &amp;wc ) ) <br>    { <br>return FALSE; <br>    } <br>     <br>    /* <br>     * create a window <br>     */ <br>    hWndMain = CreateWindow( <br>szClass,// class <br>szCaption,// caption <br>WS_OVERLAPPEDWINDOW,// style  <br>CW_USEDEFAULT,// x pos <br>CW_USEDEFAULT,// y pos <br>CW_USEDEFAULT,// width <br>CW_USEDEFAULT,// height <br>NULL,// parent window <br>NULL,// menu  <br>hInstance,// instance <br>NULL// parms <br>); <br>     <br>    if( !hWndMain ) <br>    { <br>return FALSE; <br>    } <br> <br>    LBCreate( hWndMain, 100 ); <br> <br>    ShowWindow( hWndMain, nCmdShow ); <br>    UpdateWindow( hWndMain ); <br> <br>    /* <br>     * create the main DirectDraw object <br>     */ <br>    ddrval = DirectDrawCreate( NULL, &amp;lpDD, NULL ); <br>    LBPrintfDDRC( ddrval, "DirectDrawCreate" ); <br>    if( ddrval != DD_OK ) <br>    { <br>DestroyWindow( hWndMain ); <br>return FALSE; <br>    } <br> <br>    ddrval = lpDD-&gt;SetCooperativeLevel( hWndMain, DDSCL_NORMAL ); <br> <br>    /* <br>     * create the primary surface <br>     */ <br>    ddsd.dwSize = sizeof( ddsd ); <br>    ddsd.dwFlags = DDSD_CAPS; <br>    ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE; <br>    ddrval = lpDD-&gt;CreateSurface( &amp;ddsd, &amp;lpDDPSurf, NULL ); <br>    LBPrintfDDRC( ddrval, "CreateSurface" ); <br>    if( ddrval != DD_OK ) <br>    { <br>lpDD-&gt;Release(); <br>DestroyWindow( hWndMain ); <br>return FALSE; <br>    } <br> <br>    /* <br>     * set up palettes <br>     */ <br>    if( !resetExclusiveAndPalettes( bIsExclusive ) ) <br>    { <br>lpDDPSurf-&gt;Release(); <br>lpDD-&gt;Release(); <br>DestroyWindow( hWndMain ); <br>return FALSE; <br>    } <br>     <br>    return TRUE; <br> <br>} /* doInit */ <br> <br>/* <br> * WinMain - initialization, message loop <br> */ <br>int PASCAL WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, <br>LPSTR lpCmdLine, int nCmdShow) <br>{ <br>    MSGmsg; <br> <br>    hPrevInstance = hPrevInstance; <br>    lpCmdLine = lpCmdLine; <br> <br>    if( !doInit( hInstance, nCmdShow ) ) <br>    { <br>return FALSE; <br>    } <br> <br>    while( GetMessage( &amp;msg, NULL, NULL, NULL ) ) <br>    { <br>TranslateMessage( &amp;msg ); <br>DispatchMessage( &amp;msg ); <br>    } <br> <br>    return( msg.wParam ); <br> <br>} /* WinMain */ </code></pre>
<p>&nbsp;</p></body>
</HTML>
