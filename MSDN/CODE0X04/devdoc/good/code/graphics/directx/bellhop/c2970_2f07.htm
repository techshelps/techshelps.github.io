<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>BELLHOP.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2977"></a>BELLHOP.CPP</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved. <br> * <br> *  File:       bellhop.cpp <br> *  Content:Simple lobby program using DirectPlay. <br> * <br> ***************************************************************************/ <br> <br>#define INITGUID <br>#include "bellhop.h" <br>#include "resource.h" <br> <br>enum { <br>WM_USER_ADDSTRING= WM_USER+257,// window message to add string to chat string list <br>WM_USER_UPDATE// window message to update lobby display <br>}; <br> <br>// globals <br>HANDLEghReceiveThread = NULL;// handle of receive thread <br>DWORDgidReceiveThread = 0;// id of receive thread <br>HANDLEghKillReceiveEvent = NULL;// event used to kill receive thread <br>HWNDghMainWnd = NULL;// main window <br>HINSTANCEghInstance;// application instance <br> <br>//EXTERNs <br>BOOL FAR PASCAL DirectPlayEnumConnectionsCallback(LPCGUID lpguidSP, LPVOID lpConnection,  <br>DWORD dwSize, LPCDPNAME lpName,  <br>DWORD dwFlags, LPVOID lpContext); <br>HRESULTGetConnection(HWND hWnd,  int idCombo, LPVOID *lplpConnection); <br>HRESULTGetConnectionSPGuid(HWND hWnd, int idCombo, GUID *lpGuidSP); <br> <br> <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, <br>   LPSTR lpCmdLine, int nCmdShow ) <br>{ <br>DPLAYINFODPInfo; <br>intiResult = 0; <br>HRESULThr; <br> <br>ghInstance = hInstance; <br> <br>// Initialize COM library <br>hr = CoInitialize(NULL); <br>if FAILED(hr) <br>goto FAILURE; <br> <br>// setup the connection <br>hr = SetupConnection(hInstance, &amp;DPInfo); <br>if FAILED(hr) <br>goto FAILURE; <br> <br>// show the chat window <br>iResult = DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_LOBBYDIALOG), NULL, (DLGPROC) LobbyWndProc, (LPARAM) &amp;DPInfo); <br> <br>FAILURE: <br>// shut down the connection <br>hr = ShutdownConnection(&amp;DPInfo); <br> <br>// Uninitialize the COM library <br>CoUninitialize(); <br> <br>return (iResult); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>BOOL CALLBACK LobbyWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) <br>{ <br>static LPDPLAYINFOlpDPInfo; <br>DWORDdwTextLen; <br> <br>    switch(uMsg) <br>    { <br> <br>    case WM_INITDIALOG: <br>{ <br>HDC hDC; <br>int xPixelsPerInch, <br>yPixelsPerInch; <br>RECT rect; <br> <br>// Save the connection info pointer <br>lpDPInfo = (LPDPLAYINFO) lParam; <br> <br>// Get the dialog spacing info <br>hDC = GetDC(hWnd); <br>xPixelsPerInch = GetDeviceCaps(hDC, LOGPIXELSX); <br>yPixelsPerInch = GetDeviceCaps(hDC, LOGPIXELSY); <br>ReleaseDC(hWnd, hDC); <br>lpDPInfo-&gt;xSpacing = xPixelsPerInch / 8; <br>lpDPInfo-&gt;ySpacing = yPixelsPerInch / 8; <br>lpDPInfo-&gt;xHalfSplitWidth = xPixelsPerInch / 12; <br> <br>GetClientRect(hWnd, &amp;rect); <br>            lpDPInfo-&gt;xPaneSplit = ((rect.right - rect.left) - (2 * lpDPInfo-&gt;xSpacing )) / 3  <br>- lpDPInfo-&gt;xHalfSplitWidth; <br> <br>// Create the tree control <br>lpDPInfo-&gt;lpGroupTree = new CGroupTree; <br>lpDPInfo-&gt;lpGroupTree-&gt;Init(GetDlgItem(hWnd, IDT_MESSAGEVIEW),  <br>lpDPInfo-&gt;lpDirectPlay3A, <br>lpDPInfo-&gt;dpidPlayer); <br>lpDPInfo-&gt;lpGroupTree-&gt;Refresh(); <br>lpDPInfo-&gt;lpGroupTree-&gt;CreatePlayer( lpDPInfo-&gt;dpidPlayer, NULL, lpDPInfo-&gt;dwPlayerFlags ); <br> <br>// store global window <br>ghMainWnd = hWnd; <br> <br>// initiallize lobby <br>InitializeLobby(hWnd, lpDPInfo); <br> <br>OnSize( hWnd, lpDPInfo ); <br>} <br>        break; <br> <br>    case WM_DESTROY: <br>ghMainWnd = NULL; <br>        break; <br> <br>    case WM_SIZE: <br>        OnSize(hWnd, lpDPInfo); <br>        break; <br> <br>    case WM_LBUTTONDOWN: <br>        lpDPInfo-&gt;bSplitMove = TRUE; <br>        SetCapture(hWnd); <br>        break; <br> <br>    case WM_LBUTTONUP: <br>if (lpDPInfo-&gt;bSplitMove) <br>{ <br>lpDPInfo-&gt;bSplitMove = FALSE; <br>ReleaseCapture(); <br>} <br>else <br>{ <br>lpDPInfo-&gt;lpGroupTree-&gt;OnLButtonUp(); <br>} <br>        break; <br> <br>    case WM_MOUSEMOVE: <br>        if(lpDPInfo-&gt;bSplitMove) <br>        { <br>// track mouse movement while adjusting the divider <br>            RECT    rect; <br>            // change the value from unsigned to signed <br>            int     x = (int)(short)LOWORD(lParam); <br> <br>            GetClientRect(hWnd, &amp;rect); <br>            if (rect.left &gt; x) <br>            { <br>                x = rect.left; <br>            } <br>            else if (rect.right &lt; x) <br>            { <br>                x = rect.right; <br>            } <br>            lpDPInfo-&gt;xPaneSplit = (x - lpDPInfo-&gt;xHalfSplitWidth - (lpDPInfo-&gt;xSpacing * 2)); <br>            OnSize(hWnd, lpDPInfo); <br>        } <br>else <br>{ <br>lpDPInfo-&gt;lpGroupTree-&gt;OnMouseMove(LOWORD(lParam), HIWORD(lParam) ); <br>} <br>        break; <br> <br> <br>// this is a user-defined message used to add strings to the log window <br>case WM_USER_ADDSTRING: <br>// get length of text in log window <br>dwTextLen = SendDlgItemMessage(hWnd, IDC_LOGEDIT, WM_GETTEXTLENGTH, <br>   (WPARAM) 0, (LPARAM) 0); <br> <br>// put selection at end <br>dwTextLen = SendDlgItemMessage(hWnd, IDC_LOGEDIT, EM_SETSEL, <br>   (WPARAM) dwTextLen, (LPARAM) dwTextLen); <br> <br>// add string in lParam to log window <br>SendDlgItemMessage(hWnd, IDC_LOGEDIT, EM_REPLACESEL, <br>(WPARAM) FALSE, (LPARAM) lParam); <br>GlobalFreePtr((LPVOID) lParam); <br>break; <br> <br> <br>    case WM_COMMAND: <br>        switch(LOWORD(wParam)) <br>        { <br>        case ID_ROOT_CREATEGROUP: <br>DoCreateRoom(hWnd, lpDPInfo); <br>break; <br> <br>        case ID_GROUP_CONNECTIONSETTINGS: <br>DoGroupConnectionSettings(hWnd, lpDPInfo); <br>break; <br> <br>        case ID_DESTROYGROUP: <br>DoDeleteRoom(hWnd, lpDPInfo); <br>break; <br> <br>        case ID_PLAYERINGROUP_DELETEPLAYERFROMGROUP: <br>DoDeletePlayerFromGroup(hWnd, lpDPInfo); <br>break; <br> <br>        case ID_CREATEGROUPINGROUP: <br>DoCreateTable(hWnd, lpDPInfo); <br>break; <br> <br>        case ID_SHORTCUT_DELETEGROUPFROMGROUP: <br>DoDeleteTable(hWnd, lpDPInfo); <br>break; <br> <br>        case ID_GROUP_STARTSESSION: <br>DoLaunch(hWnd, lpDPInfo); <br>break; <br> <br>        case ID_PLAYER_SETPLAYERNAME: <br>case ID_PLAYERINGROUP_SETPLAYERNAME: <br>        case ID_GROUP_SETGROUPNAME: <br>lpDPInfo-&gt;lpGroupTree-&gt;EditLabel(); <br>break; <br> <br>        case IDC_SENDBUTTON: <br>SendChatMessage(hWnd, lpDPInfo); <br>break; <br> <br>        case IDCANCEL: <br>EndDialog(hWnd, FALSE); <br>            break; <br> <br>        case ID_ROOT_ENUMRECURSIVE: <br>lpDPInfo-&gt;lpGroupTree-&gt;Refresh( ); <br> lpDPInfo-&gt;lpGroupTree-&gt;CreatePlayer( lpDPInfo-&gt;dpidPlayer, NULL, lpDPInfo-&gt;dwPlayerFlags ); <br>           break; <br> <br>case ID_ROOT_ENUMGROUPS: <br>lpDPInfo-&gt;lpGroupTree-&gt;Refresh( FALSE ); <br> lpDPInfo-&gt;lpGroupTree-&gt;CreatePlayer( lpDPInfo-&gt;dpidPlayer, NULL, lpDPInfo-&gt;dwPlayerFlags ); <br>           break; <br> <br>} <br>break; <br> <br>case WM_NOTIFY : <br> return lpDPInfo-&gt;lpGroupTree-&gt;OnWM_NOTIFY( wParam, lParam ); <br>break; <br> <br>case WM_MENUSELECT: <br>return FALSE; <br>break; <br>} <br> <br>    // Allow for default processing <br>    return FALSE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>HRESULT SetupConnection(HINSTANCE hInstance, LPDPLAYINFO lpDPInfo) <br>{ <br>HRESULThr; <br> <br>ZeroMemory(lpDPInfo, sizeof(DPLAYINFO)); <br> <br>// create event used by DirectPlay to signal a message has arrived <br>lpDPInfo-&gt;hPlayerEvent = CreateEvent(NULL,// no security <br> FALSE,// auto reset <br> FALSE,// initial event reset <br> NULL);// no name <br>if (lpDPInfo-&gt;hPlayerEvent == NULL) <br>{ <br>hr = DPERR_NOMEMORY; <br>goto FAILURE; <br>} <br> <br>// create event used to signal that the receive thread should exit <br>ghKillReceiveEvent = CreateEvent(NULL,// no security <br> FALSE,// auto reset <br> FALSE,// initial event reset <br> NULL);// no name <br>if (ghKillReceiveEvent == NULL) <br>{ <br>hr = DPERR_NOMEMORY; <br>goto FAILURE; <br>} <br> <br>// create thread to receive player messages <br>ghReceiveThread = CreateThread(NULL,// default security <br>   0,// default stack size <br>   ReceiveThread,// pointer to thread routine <br>   lpDPInfo,// argument for thread <br>   0,// start it right away <br>   &amp;gidReceiveThread); <br>if (ghReceiveThread == NULL) <br>{ <br>hr = DPERR_NOMEMORY; <br>goto FAILURE; <br>} <br> <br>// if there is no lobby connection, ask the user for settings <br>hr = ConnectUsingDialog(hInstance, lpDPInfo); <br>if FAILED(hr) <br>goto FAILURE; <br> <br>return (DP_OK); <br> <br>FAILURE: <br>ShutdownConnection(lpDPInfo); <br> <br>return (hr); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>HRESULT ShutdownConnection(LPDPLAYINFO lpDPInfo) <br>{ <br>if (ghReceiveThread) <br>{ <br>// wake up receive thread and wait for it to quit <br>SetEvent(ghKillReceiveEvent); <br>WaitForSingleObject(ghReceiveThread, INFINITE); <br> <br>CloseHandle(ghReceiveThread); <br>ghReceiveThread = NULL; <br>} <br> <br>if (ghKillReceiveEvent) <br>{ <br>CloseHandle(ghKillReceiveEvent); <br>ghKillReceiveEvent = NULL; <br>} <br> <br>if (lpDPInfo-&gt;lpDirectPlay3A) <br>{ <br>if (lpDPInfo-&gt;dpidPlayer) <br>{ <br>IDirectPlay3_DestroyPlayer(lpDPInfo-&gt;lpDirectPlay3A, lpDPInfo-&gt;dpidPlayer); <br>lpDPInfo-&gt;dpidPlayer = 0; <br>} <br>IDirectPlay3_Close(lpDPInfo-&gt;lpDirectPlay3A); <br>IDirectPlay3_Release(lpDPInfo-&gt;lpDirectPlay3A); <br>lpDPInfo-&gt;lpDirectPlay3A = NULL; <br> <br>IDirectPlayLobby_Release(lpDPInfo-&gt;lpDirectPlayLobby2A); <br>lpDPInfo-&gt;lpDirectPlayLobby2A = NULL; <br> <br>} <br> <br>if (lpDPInfo-&gt;hPlayerEvent) <br>{ <br>CloseHandle(lpDPInfo-&gt;hPlayerEvent); <br>lpDPInfo-&gt;hPlayerEvent = NULL; <br>} <br> <br>if (lpDPInfo-&gt;lpGroupTree) <br>{ <br>delete lpDPInfo-&gt;lpGroupTree; <br>lpDPInfo-&gt;lpGroupTree = NULL; <br>} <br>return (DP_OK); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>DWORD WINAPI ReceiveThread(LPVOID lpThreadParameter) <br>{ <br>    LPDPLAYINFOlpDPInfo = (LPDPLAYINFO) lpThreadParameter; <br>HANDLEeventHandles[2]; <br> <br>eventHandles[0] = lpDPInfo-&gt;hPlayerEvent; <br>eventHandles[1] = ghKillReceiveEvent; <br> <br>// loop waiting for player events. If the kill event is signaled <br>// the thread will exit <br>while (WaitForMultipleObjects(2, eventHandles, FALSE, INFINITE) == WAIT_OBJECT_0) <br>{ <br>// receive any messages in the queue <br>ReceiveMessage(lpDPInfo); <br>} <br> <br>ExitThread(0); <br> <br>return (0); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>HRESULT ReceiveMessage(LPDPLAYINFO lpDPInfo) <br>{ <br>DPIDidFrom, idTo; <br>LPVOIDlpvMsgBuffer; <br>DWORDdwMsgBufferSize; <br>HRESULThr; <br> <br>lpvMsgBuffer = NULL; <br>dwMsgBufferSize = 0; <br> <br>// loop to read all messages in queue <br>do <br>{ <br>// loop until a single message is successfully read <br>do <br>{ <br>// read messages from any player, including system player <br>idFrom = 0; <br>idTo = 0; <br> <br>hr = IDirectPlay3_Receive(lpDPInfo-&gt;lpDirectPlay3A, &amp;idFrom, &amp;idTo, DPRECEIVE_ALL, <br>  lpvMsgBuffer, &amp;dwMsgBufferSize); <br> <br>// not enough room, so resize buffer <br>if (hr == DPERR_BUFFERTOOSMALL) <br>{ <br>if (lpvMsgBuffer) <br>GlobalFreePtr(lpvMsgBuffer); <br> <br>lpvMsgBuffer = GlobalAllocPtr(GHND, dwMsgBufferSize); <br>if (lpvMsgBuffer == NULL) <br>hr = DPERR_OUTOFMEMORY; <br>} <br>} while (hr == DPERR_BUFFERTOOSMALL); <br> <br>if ((SUCCEEDED(hr)) &amp;&amp;// successfully read a message <br>(dwMsgBufferSize &gt;= sizeof(DPMSG_GENERIC)))// and it is big enough <br>{ <br>// update the tree view UI. <br>lpDPInfo-&gt;lpGroupTree-&gt;Update( lpvMsgBuffer ); <br> <br>// check for system message <br>if (idFrom == DPID_SYSMSG) <br>{ <br>HandleSystemMessage(lpDPInfo, (LPDPMSG_GENERIC) lpvMsgBuffer, <br>dwMsgBufferSize, idFrom, idTo); <br>} <br>else <br>{ <br>HandleApplicationMessage(lpDPInfo, (LPDPMSG_GENERIC) lpvMsgBuffer, <br> dwMsgBufferSize, idFrom, idTo); <br>} <br>} <br>} while (SUCCEEDED(hr)); <br> <br>// free any memory we created <br>if (lpvMsgBuffer) <br>GlobalFreePtr(lpvMsgBuffer); <br> <br>return (DP_OK); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>void HandleApplicationMessage(LPDPLAYINFO lpDPInfo, LPDPMSG_GENERIC lpMsg, DWORD dwMsgSize, <br>  DPID idFrom, DPID idTo) <br>{ <br>// Any messages received from the lobby server would be handled here. <br>// In this case, we don't have any <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>void HandleSystemMessage(LPDPLAYINFO lpDPInfo, LPDPMSG_GENERIC lpMsg, DWORD dwMsgSize, <br> DPID idFrom, DPID idTo) <br>{ <br>LPSTRlpszStr = NULL; <br> <br>    // The body of each case is there so you can set a breakpoint and examine <br>    // the contents of the message received. <br>switch (lpMsg-&gt;dwType) <br>{ <br>case DPSYS_STARTSESSION: <br>{ <br>LPDPMSG_STARTSESSIONlp = (LPDPMSG_STARTSESSION) lpMsg; <br> <br>HandleStartSession(lp-&gt;lpConn, lpDPInfo); <br>} <br>break; <br> <br>case DPSYS_CREATEPLAYERORGROUP: <br>        { <br>            LPDPMSG_CREATEPLAYERORGROUPlp = (LPDPMSG_CREATEPLAYERORGROUP) lpMsg; <br>LPSTRlpszName, lpszDisplayFormat; <br>             <br>if (lp-&gt;dwPlayerType == DPPLAYERTYPE_PLAYER) <br>lpszDisplayFormat = "Player \"%s\" created\r\n"; <br>else if (lp-&gt;dwPlayerType == DPPLAYERTYPE_GROUP) <br>lpszDisplayFormat = "Group \"%s\" created\r\n"; <br>else <br>lpszDisplayFormat = "Unknown object \"%s\" created\r\n"; <br> <br>// get pointer to player name <br>if (lp-&gt;dpnName.lpszShortNameA) <br>lpszName = lp-&gt;dpnName.lpszShortNameA; <br>else <br>lpszName = "unknown"; <br> <br>// allocate space for string <br>lpszStr = (LPSTR) GlobalAllocPtr(GHND, lstrlen(lpszDisplayFormat) + <br>   lstrlen(lpszName) + 1); <br>if (lpszStr == NULL) <br>break; <br> <br>// build string <br>wsprintf(lpszStr, lpszDisplayFormat, lpszName); <br>        } <br>break; <br> <br>case DPSYS_DESTROYPLAYERORGROUP: <br>        { <br>            LPDPMSG_DESTROYPLAYERORGROUPlp = (LPDPMSG_DESTROYPLAYERORGROUP)lpMsg; <br>LPSTRlpszName, lpszDisplayFormat; <br>             <br>if (lp-&gt;dwPlayerType == DPPLAYERTYPE_PLAYER) <br>lpszDisplayFormat = "Player \"%s\" destroyed\r\n"; <br>else if (lp-&gt;dwPlayerType == DPPLAYERTYPE_GROUP) <br>lpszDisplayFormat = "Group \"%s\" destroyed\r\n"; <br>else <br>lpszDisplayFormat = "Unknown object \"%s\" destroyed\r\n"; <br> <br>// get pointer to player name <br>if (lp-&gt;dpnName.lpszShortNameA) <br>lpszName = lp-&gt;dpnName.lpszShortNameA; <br>else <br>lpszName = "unknown"; <br> <br>// allocate space for string <br>lpszStr = (LPSTR) GlobalAllocPtr(GHND, lstrlen(lpszDisplayFormat) + <br>   lstrlen(lpszName) + 1); <br>if (lpszStr == NULL) <br>break; <br> <br>// build string <br>wsprintf(lpszStr, lpszDisplayFormat, lpszName); <br>        } <br>break; <br> <br>case DPSYS_ADDPLAYERTOGROUP: <br>case DPSYS_DELETEPLAYERFROMGROUP: <br>        { <br>            LPDPMSG_ADDPLAYERTOGROUPlpAddMsg = (LPDPMSG_ADDPLAYERTOGROUP)lpMsg; <br>            LPDPMSG_DELETEPLAYERFROMGROUPlpDeleteMsg = (LPDPMSG_DELETEPLAYERFROMGROUP)lpMsg; <br>DPIDdpidPlayer, dpidGroup; <br>LPSTRlpszPlayerName, lpszGroupName; <br>LPDPNAMElpPlayerName, lpGroupName; <br>LPSTRlpszDisplayFormat; <br>            HRESULThr; <br> <br>if (lpMsg-&gt;dwType == DPSYS_ADDPLAYERTOGROUP) <br>{ <br>dpidPlayer = lpAddMsg-&gt;dpIdPlayer; <br>dpidGroup = lpAddMsg-&gt;dpIdGroup; <br>lpszDisplayFormat = "Player \"%s\" added to group \"%s\"\r\n"; <br>} <br>else <br>{ <br>dpidPlayer = lpDeleteMsg-&gt;dpIdPlayer; <br>dpidGroup = lpDeleteMsg-&gt;dpIdGroup; <br>lpszDisplayFormat = "Player \"%s\" removed from group \"%s\"\r\n"; <br>} <br> <br>// get pointer to player name <br>hr = GetPlayerName(lpDPInfo-&gt;lpDirectPlay3A, dpidPlayer, &amp;lpPlayerName); <br>if FAILED(hr) <br>{ <br>// A failure may mean that the player has been deleted <br>// since we began processing this message <br>lpPlayerName = NULL; <br>} <br> <br>if ((lpPlayerName) &amp;&amp; (lpPlayerName-&gt;lpszShortNameA)) <br>lpszPlayerName = lpPlayerName-&gt;lpszShortNameA; <br>else <br>lpszPlayerName = "unknown"; <br> <br>// get pointer to group name <br>hr = GetGroupName(lpDPInfo-&gt;lpDirectPlay3A, dpidGroup, &amp;lpGroupName); <br>if FAILED(hr) <br>{ <br>// A failure may mean that the group has been deleted <br>// since we began processing this message <br>lpGroupName = NULL; <br>} <br> <br>if ((lpGroupName) &amp;&amp; (lpGroupName-&gt;lpszShortNameA)) <br>lpszGroupName = lpGroupName-&gt;lpszShortNameA; <br>else <br>lpszGroupName = "unknown"; <br> <br> <br>// allocate space for string <br>lpszStr = (LPSTR) GlobalAllocPtr(GHND, lstrlen(lpszDisplayFormat) + <br>   lstrlen(lpszPlayerName) + <br>   lstrlen(lpszGroupName) + 1); <br>// build string <br>if (lpszStr) <br>wsprintf(lpszStr, lpszDisplayFormat, lpszPlayerName, lpszGroupName); <br> <br>// free data we allocated <br>if (lpPlayerName) <br>GlobalFreePtr(lpPlayerName); <br>if (lpGroupName) <br>GlobalFreePtr(lpGroupName); <br>        } <br>break; <br> <br>case DPSYS_ADDGROUPTOGROUP: <br>case DPSYS_DELETEGROUPFROMGROUP: <br>        { <br>            LPDPMSG_ADDGROUPTOGROUPlpAddMsg = (LPDPMSG_ADDGROUPTOGROUP)lpMsg; <br>            LPDPMSG_DELETEGROUPFROMGROUPlpDeleteMsg = (LPDPMSG_DELETEGROUPFROMGROUP)lpMsg; <br>DPIDdpidParentGroup, dpidGroup; <br>LPSTRlpszParentGroupName, lpszGroupName; <br>LPDPNAMElpParentGroupName, lpGroupName; <br>LPSTRlpszDisplayFormat; <br>            HRESULThr; <br> <br>if (lpMsg-&gt;dwType == DPSYS_ADDGROUPTOGROUP) <br>{ <br>dpidGroup = lpAddMsg-&gt;dpIdGroup; <br>dpidParentGroup = lpAddMsg-&gt;dpIdParentGroup; <br>lpszDisplayFormat = "Group \"%s\" added to group \"%s\"\r\n"; <br>} <br>else <br>{ <br>dpidParentGroup = lpDeleteMsg-&gt;dpIdParentGroup; <br>dpidGroup = lpDeleteMsg-&gt;dpIdGroup; <br>lpszDisplayFormat = "Group \"%s\" removed from group \"%s\"\r\n"; <br>} <br> <br>// get pointer to player name <br>hr = GetGroupName(lpDPInfo-&gt;lpDirectPlay3A, dpidParentGroup, &amp;lpParentGroupName); <br>if FAILED(hr) <br>lpParentGroupName = NULL; <br> <br>if ((lpParentGroupName) &amp;&amp; (lpParentGroupName-&gt;lpszShortNameA)) <br>lpszParentGroupName = lpParentGroupName-&gt;lpszShortNameA; <br>else <br>lpszParentGroupName = "unknown"; <br> <br>// get pointer to group name <br>hr = GetGroupName(lpDPInfo-&gt;lpDirectPlay3A, dpidGroup, &amp;lpGroupName); <br>if FAILED(hr) <br>lpGroupName = NULL; <br> <br>if ((lpGroupName) &amp;&amp; (lpGroupName-&gt;lpszShortNameA)) <br>lpszGroupName = lpGroupName-&gt;lpszShortNameA; <br>else <br>lpszGroupName = "unknown"; <br> <br>// allocate space for string <br>lpszStr = (LPSTR) GlobalAllocPtr(GHND, lstrlen(lpszDisplayFormat) + <br>   lstrlen(lpszParentGroupName) + <br>   lstrlen(lpszGroupName) + 1); <br>// build string <br>if (lpszStr) <br>wsprintf(lpszStr, lpszDisplayFormat, lpszGroupName, lpszParentGroupName ); <br> <br>// free data we allocated <br>if (lpParentGroupName) <br>GlobalFreePtr(lpParentGroupName); <br>if (lpGroupName) <br>GlobalFreePtr(lpGroupName); <br>        } <br>break; <br> <br>case DPSYS_SESSIONLOST: <br>        { <br>            LPDPMSG_SESSIONLOST lp = (LPDPMSG_SESSIONLOST)lpMsg; <br>LPSTRszDisplayFormat = "Session lost.\r\n"; <br> <br>// allocate space for string <br>lpszStr = (LPSTR) GlobalAllocPtr(GHND, lstrlen(szDisplayFormat) + 1); <br>if (lpszStr == NULL) <br>break; <br> <br>// build string <br>lstrcpy(lpszStr, szDisplayFormat); <br>        } <br>break; <br> <br>case DPSYS_HOST: <br>        { <br>            LPDPMSG_HOSTlp = (LPDPMSG_HOST)lpMsg; <br>LPSTRszDisplayFormat = "You have become the host\r\n"; <br> <br>// allocate space for string <br>lpszStr = (LPSTR) GlobalAllocPtr(GHND, lstrlen(szDisplayFormat) + 1); <br>if (lpszStr == NULL) <br>break; <br> <br>// build string <br>lstrcpy(lpszStr, szDisplayFormat); <br> <br>// we are now the host <br>lpDPInfo-&gt;bIsHost = TRUE; <br>        } <br>break; <br> <br>case DPSYS_SETPLAYERORGROUPDATA: <br>        { <br>            LPDPMSG_SETPLAYERORGROUPDATA lp = (LPDPMSG_SETPLAYERORGROUPDATA)lpMsg; <br>        } <br>break; <br> <br>case DPSYS_SETPLAYERORGROUPNAME: <br>        { <br>            LPDPMSG_SETPLAYERORGROUPNAME lp = (LPDPMSG_SETPLAYERORGROUPNAME)lpMsg; <br>        } <br>break; <br> <br>case DPSYS_CHAT: <br>        { <br>            LPDPMSG_CHATlp = (LPDPMSG_CHAT)lpMsg; <br>DWORDdwSize = lstrlen( lp-&gt;lpChat-&gt;lpszMessageA ) + 12; <br>//Allow extra room for "{whisper} ", in case this message <br>//was sent just to me. <br> <br>// allocate space for string <br>lpszStr = (LPSTR) GlobalAllocPtr( GHND, dwSize ); <br> <br>if (lpszStr == NULL) <br>break; <br> <br>if (NULL == lp-&gt;idToGroup) <br>{ <br>//This message was sent just to me, not to a whole group <br>lstrcpy( lpszStr, "{whisper} " ); <br>lstrcat( lpszStr, lp-&gt;lpChat-&gt;lpszMessageA ); <br>} <br>else <br>{ <br>// build string <br>lstrcpy(lpszStr, lp-&gt;lpChat-&gt;lpszMessageA); <br>} <br>        } <br>break; <br> <br>} <br> <br>// post string to chat window <br>if (lpszStr) <br>{ <br>// make sure window is still valid <br>if (ghMainWnd) <br>PostMessage(ghMainWnd, WM_USER_ADDSTRING, (WPARAM) 0, (LPARAM) lpszStr); <br>else <br>GlobalFreePtr(lpszStr); <br>} <br> <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>HRESULT GetPlayerName(LPDIRECTPLAY3A lpDirectPlay3A, DPID dpidPlayer, <br>  LPDPNAME *lplpName) <br>{ <br>LPDPNAMElpName = NULL; <br>DWORDdwNameSize; <br>HRESULThr; <br> <br>// get size of player name data <br>hr = IDirectPlay3_GetPlayerName(lpDirectPlay3A, dpidPlayer, NULL, &amp;dwNameSize); <br>if (hr != DPERR_BUFFERTOOSMALL) <br>goto FAILURE; <br> <br>// make room for it <br>lpName = (LPDPNAME) GlobalAllocPtr(GHND, dwNameSize); <br>if (lpName == NULL) <br>{ <br>hr = DPERR_OUTOFMEMORY; <br>goto FAILURE; <br>} <br> <br>// get player name data <br>hr = IDirectPlay3_GetPlayerName(lpDirectPlay3A, dpidPlayer, lpName, &amp;dwNameSize); <br>if FAILED(hr) <br>goto FAILURE; <br> <br>// return pointer to name structure <br>*lplpName = lpName; <br> <br>return (DP_OK); <br> <br>FAILURE: <br>if (lpName) <br>GlobalFreePtr(lpName); <br> <br>return (hr); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>HRESULT GetGroupName(LPDIRECTPLAY3A lpDirectPlay3A, DPID dpidGroup, <br> LPDPNAME *lplpName) <br>{ <br>LPDPNAMElpName = NULL; <br>DWORDdwNameSize; <br>HRESULThr; <br> <br>// get size of player name data <br>hr = IDirectPlay3_GetGroupName(lpDirectPlay3A, dpidGroup, NULL, &amp;dwNameSize); <br>if (hr != DPERR_BUFFERTOOSMALL) <br>goto FAILURE; <br> <br>// make room for it <br>lpName = (LPDPNAME) GlobalAllocPtr(GHND, dwNameSize); <br>if (lpName == NULL) <br>{ <br>hr = DPERR_OUTOFMEMORY; <br>goto FAILURE; <br>} <br> <br>// get player name data <br>hr = IDirectPlay3_GetGroupName(lpDirectPlay3A, dpidGroup, lpName, &amp;dwNameSize); <br>if FAILED(hr) <br>goto FAILURE; <br> <br>// return pointer to name structure <br>*lplpName = lpName; <br> <br>return (DP_OK); <br> <br>FAILURE: <br>if (lpName) <br>GlobalFreePtr(lpName); <br> <br>return (hr); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>void InitializeLobbyGroupWindow(HWND hWnd, LPLOBBYGROUPCONTEXT lpContext) <br>{ <br>HRESULThr = DPERR_GENERIC; <br>ENUMCONNSTRUCTenStruct; <br> <br>if (lpContext-&gt;dpidRoom == 0) <br>SetWindowText(hWnd, "Create Room"); <br>else <br>SetWindowText(hWnd, "Create Table"); <br> <br>// initialize max players <br>SetDlgItemInt(hWnd, IDC_MAXPLAYERSEDIT, 0, FALSE); <br> <br>// put all the DirectPlay applications in a combo box <br>lpContext-&gt;lpDPInfo-&gt;lpDirectPlayLobby2A-&gt;EnumLocalApplications(EnumApp, hWnd, 0); <br>SendDlgItemMessage(hWnd, IDC_APPCOMBO, CB_SETCURSEL, (WPARAM) 0, (LPARAM) 0); <br> <br>// put all the available connections in a combo box <br>enStruct.hWnd = hWnd; <br>enStruct.idCombo = IDC_GROUPCONNECTIONSPCOMBO; <br> <br>hr = IDirectPlay3_EnumConnections(lpContext-&gt;lpDPInfo-&gt;lpDirectPlay3A,  <br>&amp;BELLHOP_GUID,  <br>DirectPlayEnumConnectionsCallback, <br>&amp;enStruct, DPCONNECTION_DIRECTPLAY ); <br> <br>SendDlgItemMessage(hWnd, IDC_GROUPCONNECTIONSPCOMBO, CB_SETCURSEL, (WPARAM) 0, (LPARAM) 0); <br>return; <br> <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>HRESULT CreateLobbyGroup(HWND hWnd, LPLOBBYGROUPCONTEXT lpContext) <br>{ <br>CHARszShortName[MAXSTRLEN], <br>szLongName[MAXSTRLEN], <br>szPassword[MAXSTRLEN]; <br>DPNAMEdpName; <br>DWORDdwMaxPlayers; <br>DPIDdpID; <br>DPLCONNECTIONdplconn; <br>DPSESSIONDESC2dpsess; <br>HRESULThr; <br>DWORDdwFlags = 0; <br> <br>// get strings from dialog <br>GetDlgItemText(hWnd, IDC_SHORTNAMEEDIT, szShortName, MAXSTRLEN); <br>GetDlgItemText(hWnd, IDC_LONGNAMEEDIT, szLongName, MAXSTRLEN); <br> <br>if (BST_CHECKED == SendDlgItemMessage( hWnd, IDC_STAGINGAREA, BM_GETCHECK, 0, 0 )) <br>{ <br>GetDlgItemText(hWnd, IDC_PASSWORDEDIT, szPassword, MAXSTRLEN); <br>dwMaxPlayers = GetDlgItemInt(hWnd, IDC_MAXPLAYERSEDIT, NULL, FALSE); <br>dwFlags = DPGROUP_STAGINGAREA; <br>} <br> <br>// build a dpname structure <br>ZeroMemory(&amp;dpName, sizeof(DPNAME)); <br>dpName.dwSize = sizeof(DPNAME); <br>dpName.lpszShortNameA = szShortName; <br>dpName.lpszLongNameA = szLongName; <br> <br>// create a root group <br>if (lpContext-&gt;dpidRoom == 0) <br>{ <br>hr = IDirectPlay3_CreateGroup(lpContext-&gt;lpDPInfo-&gt;lpDirectPlay3A, <br>&amp;dpID, &amp;dpName, NULL, 0, dwFlags); <br>} <br> <br>// create the table group <br>else <br>{ <br>hr = IDirectPlay3_CreateGroupInGroup(lpContext-&gt;lpDPInfo-&gt;lpDirectPlay3A, <br>lpContext-&gt;dpidRoom,  <br>&amp;dpID, &amp;dpName,  <br>NULL, 0, dwFlags); <br>} <br> <br>if FAILED(hr) <br>goto FAILURE; <br> <br>if ( DPGROUP_STAGINGAREA &amp; dwFlags ) <br>{ <br> <br>// Fill out the DPSESSIONDESC2 structure <br>ZeroMemory( &amp;dpsess, sizeof(DPSESSIONDESC2) ); <br>dpsess.dwSize = sizeof( DPSESSIONDESC2 ); <br>dpsess.dwFlags = DPSESSION_KEEPALIVE | DPSESSION_MIGRATEHOST; <br> <br>CoCreateGuid(&amp;(dpsess.guidInstance)); <br> <br>GetComboBoxGuid(hWnd, IDC_APPCOMBO, &amp;dpsess.guidApplication); <br> <br>dpsess.dwMaxPlayers = dwMaxPlayers; <br>dpsess.dwCurrentPlayers = 0; <br>dpsess.lpszSessionNameA = dpName.lpszShortNameA; <br>if (lstrlen(szPassword)) <br>dpsess.lpszPasswordA = szPassword; <br> <br>// Fill out the DPLCONNECTION structure <br>ZeroMemory( &amp;dplconn, sizeof(DPLCONNECTION) ); <br>dplconn.dwSize = sizeof( DPLCONNECTION ); <br>dplconn.lpSessionDesc = &amp;dpsess; <br> <br>GetConnectionSPGuid(hWnd, IDC_GROUPCONNECTIONSPCOMBO, &amp;dplconn.guidSP); <br> <br>// The rest of the DPLCONNECTION structure gets  <br>// filled in by the lobby <br> <br>hr = IDirectPlay3_SetGroupConnectionSettings(lpContext-&gt;lpDPInfo-&gt;lpDirectPlay3A, <br> 0, dpID, &amp;dplconn ); <br> <br>if FAILED(hr) <br>goto FAILURE; <br>} <br> <br>FAILURE: <br>return (hr); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>BOOL CALLBACK LobbyGroupWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) <br>{ <br>LPLOBBYGROUPCONTEXTlpContext = (LPLOBBYGROUPCONTEXT) GetWindowLong(hWnd, DWL_USER); <br> <br>    switch(uMsg) <br>    { <br>      case WM_INITDIALOG: <br> <br>// context passed in lParam <br>lpContext = (LPLOBBYGROUPCONTEXT) lParam; <br> <br>            // save the globals with the window <br>SetWindowLong(hWnd, DWL_USER, (LONG) lpContext); <br>             <br>// Initialize dialog with appropriate information <br>InitializeLobbyGroupWindow(hWnd, lpContext); <br>            break; <br> <br>        case WM_DESTROY: <br>{ <br>WPARAMindex; <br>LRESULTlpData; <br> <br>// destroy the GUID's stored with each app name <br>index = 0; <br>while (TRUE) <br>{ <br>lpData = SendDlgItemMessage(hWnd, IDC_APPCOMBO, CB_GETITEMDATA, (WPARAM) index, 0); <br>if ((lpData == CB_ERR) || (lpData == 0)) <br>break; <br> <br>GlobalFreePtr((LPVOID) lpData); <br>index += 1; <br>} <br> <br>// destroy the connection info in the combo box. <br>index = 0; <br>while (TRUE) <br>{ <br>lpData = SendDlgItemMessage(hWnd, IDC_GROUPCONNECTIONSPCOMBO, CB_GETITEMDATA, (WPARAM) index, 0); <br>if ((lpData == CB_ERR) || (lpData == 0)) <br>break; <br> <br>GlobalFreePtr((LPVOID) lpData); <br>index += 1; <br>} <br>} <br>            break; <br> <br>        case WM_COMMAND: <br>            switch(LOWORD(wParam)) <br>            { <br>case IDOK: <br>// save changes they made <br>CreateLobbyGroup(hWnd, lpContext); <br>                    // Return success <br>                    EndDialog(hWnd, TRUE); <br> <br>                    break; <br> <br>case IDCANCEL: <br>                    // Return failure <br>                    EndDialog(hWnd, FALSE); <br> <br>                    break; <br> <br>case IDC_STAGINGAREA: <br>{ <br>int i = SendDlgItemMessage( hWnd, IDC_STAGINGAREA, BM_GETCHECK, 0, 0 ); <br>EnableWindow( GetDlgItem( hWnd, IDC_PASSWORDEDIT ), (BST_CHECKED==i)); <br>EnableWindow( GetDlgItem( hWnd, IDC_APPCOMBO ), (BST_CHECKED==i)); <br>EnableWindow( GetDlgItem( hWnd, IDC_MAXPLAYERSEDIT ), (BST_CHECKED==i)); <br>EnableWindow( GetDlgItem( hWnd, IDC_GROUPCONNECTIONSPCOMBO ), (BST_CHECKED==i)); <br>} <br>break; <br> <br>            } <br> <br>            break; <br>    } <br> <br>    // Allow for default processing <br>    return FALSE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>HRESULT DoGroupConnectionSettings(HWND hWnd, LPDPLAYINFO lpDPInfo) <br>{ <br>LOBBYGROUPCONTEXTcontext; <br> <br>context.lpDPInfo = lpDPInfo; <br>context.dpidRoom = lpDPInfo-&gt;lpGroupTree-&gt;GetDPIDOfCurrentSelection(); </code></pre>
<p>
</p>
<pre><code><br>if (DialogBoxParam(ghInstance, MAKEINTRESOURCE(IDD_CONNECTIONSETTINGSDIALOG), hWnd, <br>  (DLGPROC) ConnectionSettingsDialogProc, (LPARAM) &amp;context)) <br>{ <br>// something changed <br>// We could update a status bar here. <br>} <br> <br>return (DP_OK); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>HRESULT DoCreateRoom(HWND hWnd, LPDPLAYINFO lpDPInfo) <br>{ <br>LOBBYGROUPCONTEXTcontext; <br> <br>context.lpDPInfo = lpDPInfo; <br>context.dpidRoom = (DPID) 0; <br> <br>if (DialogBoxParam(ghInstance, MAKEINTRESOURCE(IDD_LOBBYGROUPDIALOG), hWnd, <br>  (DLGPROC) LobbyGroupWndProc, (LPARAM) &amp;context)) <br>{ <br>// something changed <br>// We could update a status bar here. <br>} <br> <br>return (DP_OK); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>HRESULT DoDeleteRoom(HWND hWnd, LPDPLAYINFO lpDPInfo) <br>{ <br>DPIDdpidRoom; <br>HRESULThr = DP_OK; <br> <br>dpidRoom = lpDPInfo-&gt;lpGroupTree-&gt;GetDPIDOfCurrentSelection(); <br> <br>// delete the group <br>hr = IDirectPlay3_DestroyGroup(lpDPInfo-&gt;lpDirectPlay3A, dpidRoom); <br> <br>return (hr); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>HRESULT DoDeletePlayerFromGroup(HWND hWnd, LPDPLAYINFO lpDPInfo) <br>{ <br>DPIDdpidRoom, <br>dpidPlayer; <br>HRESULThr = DP_OK; <br> <br>dpidRoom = lpDPInfo-&gt;lpGroupTree-&gt;GetDPIDOfCurrentSelectionParent(); <br>dpidPlayer = lpDPInfo-&gt;lpGroupTree-&gt;GetDPIDOfCurrentSelection(); <br> <br>// delete the player from the group <br>hr = IDirectPlay3_DeletePlayerFromGroup(lpDPInfo-&gt;lpDirectPlay3A, dpidRoom, dpidPlayer ); <br> <br>return (hr); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>HRESULT DoCreateTable(HWND hWnd, LPDPLAYINFO lpDPInfo) <br>{ <br>LOBBYGROUPCONTEXTcontext; <br> <br> <br>context.lpDPInfo = lpDPInfo; <br>context.dpidRoom = lpDPInfo-&gt;lpGroupTree-&gt;GetDPIDOfCurrentSelection(); <br> <br>DialogBoxParam(ghInstance, MAKEINTRESOURCE(IDD_LOBBYGROUPDIALOG), hWnd, <br>  (DLGPROC) LobbyGroupWndProc, (LPARAM) &amp;context); <br>return (DP_OK); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>HRESULT DoDeleteTable(HWND hWnd, LPDPLAYINFO lpDPInfo) <br>{ <br>DPIDdpidRoom, <br>dpidShortcut; <br>HRESULThr = DP_OK; <br> <br>dpidRoom = lpDPInfo-&gt;lpGroupTree-&gt;GetDPIDOfCurrentSelectionParent(); <br>dpidShortcut = lpDPInfo-&gt;lpGroupTree-&gt;GetDPIDOfCurrentSelection(); <br> <br>// delete the player from the group <br>hr = IDirectPlay3_DeleteGroupFromGroup(lpDPInfo-&gt;lpDirectPlay3A, dpidRoom, dpidShortcut ); <br>return (hr); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>HRESULT DoLaunch(HWND hWnd, LPDPLAYINFO lpDPInfo) <br>{ <br>DPIDdpidRoom; <br>HRESULThr = DPERR_GENERIC; <br> <br>dpidRoom = lpDPInfo-&gt;lpGroupTree-&gt;GetDPIDOfCurrentSelection(); <br> <br>hr = IDirectPlay3_StartSession(lpDPInfo-&gt;lpDirectPlay3A, 0, dpidRoom);  <br> <br>return (hr); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>HRESULT InitializeLobby(HWND hWnd, LPDPLAYINFO lpDPInfo) <br>{ <br>DPNAMEname; <br>DPIDdpID; <br>HRESULThr = DP_OK; <br> <br>if (lpDPInfo-&gt;bIsHost) <br>{ <br>// add some groups to start with <br>ZeroMemory(&amp;name, sizeof(DPNAME)); <br>name.dwSize = sizeof(DPNAME); <br> <br>name.lpszShortNameA = "Golf Shack"; <br>hr = IDirectPlay3_CreateGroup(lpDPInfo-&gt;lpDirectPlay3A, &amp;dpID, &amp;name, NULL, 0, 0); <br>if FAILED(hr) <br>goto FAILURE; <br> <br>name.lpszShortNameA = "Monster Truck Rally"; <br>hr = IDirectPlay3_CreateGroup(lpDPInfo-&gt;lpDirectPlay3A, &amp;dpID, &amp;name, NULL, 0, 0); <br>if FAILED(hr) <br>goto FAILURE; <br> <br>name.lpszShortNameA = "Club Hellbender"; <br>hr = IDirectPlay3_CreateGroup(lpDPInfo-&gt;lpDirectPlay3A, &amp;dpID, &amp;name, NULL, 0, 0); <br>if FAILED(hr) <br>goto FAILURE; <br>} <br> <br>FAILURE: <br>return (hr); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>void LogString(LPSTR lpszDisplayFormat, LPSTR lpszDataStr) <br>{ <br>LPSTRlpszStr; <br> <br>// allocate space for string <br>lpszStr = (LPSTR) GlobalAllocPtr(GHND, lstrlen(lpszDisplayFormat) + <br>   lstrlen(lpszDataStr) + 1); <br>if (lpszStr == NULL) <br>return; <br> <br>// build string <br>wsprintf(lpszStr, lpszDisplayFormat, lpszDataStr); <br> <br>// post string to chat window <br>// make sure window is still valid <br>if (ghMainWnd) <br>PostMessage(ghMainWnd, WM_USER_ADDSTRING, (WPARAM) 0, (LPARAM) lpszStr); <br>else <br>GlobalFreePtr(lpszStr); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>HRESULT SendChatMessage(HWND hWnd, LPDPLAYINFO lpDPInfo) <br>{ <br>LPSTRlpszChatStr = NULL; <br>LPSTRlpszStr = NULL; <br>LONGlStrLen; <br>HRESULThr; <br>DPCHATdpc; <br>DPIDdpidTarget; <br> <br>// get length of item text <br>lStrLen = SendDlgItemMessage(hWnd, IDC_SENDEDIT, WM_GETTEXTLENGTH, <br>(WPARAM) 0, (LPARAM) 0); <br> <br>// make room for it <br>lpszChatStr = (LPSTR) GlobalAllocPtr(GHND, lStrLen + 1); <br>if (lpszChatStr == NULL) <br>{ <br>hr = DPERR_OUTOFMEMORY; <br>goto FAILURE; <br>} <br> <br>// get item text <br>lStrLen = GetDlgItemText(hWnd, IDC_SENDEDIT, lpszChatStr, lStrLen + 1); <br> <br>// create string to display this text <br>hr = NewChatString(lpDPInfo-&gt;lpDirectPlay3A, lpDPInfo-&gt;dpidPlayer, lpszChatStr, &amp;lpszStr); <br>if FAILED(hr) <br>goto FAILURE; <br> <br>// setup the DPCHAT struct <br>memset(&amp;dpc, 0, sizeof(DPCHAT)); <br>dpc.dwSize = sizeof(DPCHAT); <br>dpc.lpszMessageA = lpszStr; <br>BRANCHSTRUCTbs; <br> <br>dpidTarget = lpDPInfo-&gt;lpGroupTree-&gt;GetDPIDOfCurrentSelection( &amp;bs ); <br> <br>hr = IDirectPlay3_SendChatMessage(lpDPInfo-&gt;lpDirectPlay3A, lpDPInfo-&gt;dpidPlayer, <br>dpidTarget, DPSEND_GUARANTEED, &amp;dpc); <br> <br> <br>if FAILED(hr) <br>goto FAILURE; <br> <br>// display this string <br>PostMessage(hWnd, WM_USER_ADDSTRING, (WPARAM) 0, (LPARAM) lpszStr); <br>lpszStr = NULL;// set to NULL so we don't delete it below <br> <br>FAILURE: <br>if (lpszChatStr) <br>GlobalFreePtr(lpszChatStr); <br> <br>if (lpszStr) <br>GlobalFreePtr(lpszStr); <br> <br>SetDlgItemText(hWnd, IDC_SENDEDIT, ""); <br> <br>return (hr); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>HRESULT NewChatString(LPDIRECTPLAY3A lpDirectPlay3A, DPID dpidPlayer, <br>  LPSTR lpszMsg, LPSTR *lplpszStr) <br>{ <br>LPDPNAMElpName = NULL; <br>LPSTRlpszStr = NULL; <br>LPSTRlpszPlayerName; <br>LPSTRszDisplayFormat = "%s&gt;\t%s\r\n"; <br>HRESULThr; <br> <br>// get name of player <br>hr = GetPlayerName(lpDirectPlay3A, dpidPlayer, &amp;lpName); <br>if FAILED(hr) <br>goto FAILURE; <br> <br>if (lpName-&gt;lpszShortNameA) <br>lpszPlayerName = lpName-&gt;lpszShortNameA; <br>else <br>lpszPlayerName = "unknown"; <br> <br>// allocate space for display string <br>lpszStr = (LPSTR) GlobalAllocPtr(GHND, lstrlen(szDisplayFormat) + <br>   lstrlen(lpszPlayerName) + <br>   lstrlen(lpszMsg) + 1); <br>if (lpszStr == NULL) <br>{ <br>hr = DPERR_OUTOFMEMORY; <br>goto FAILURE; <br>} <br> <br>// build string <br>wsprintf(lpszStr, szDisplayFormat, lpszPlayerName, lpszMsg); <br> <br>*lplpszStr = lpszStr; <br>lpszStr = NULL; <br> <br>FAILURE: <br>if (lpszStr) <br>GlobalFreePtr(lpszStr); <br> <br>if (lpName) <br>GlobalFreePtr(lpName); <br> <br>return (hr); <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>HRESULT WaitForRunMsg( DWORD dwAppId, HANDLE hReceiveEvent, LPDWORD lpdwStatus, LPDPLAYINFO lpDPInfo ) <br>{ <br>LPVOID              lpvMsg          = NULL; <br>    DWORD               dwMsgFlags; <br>DWORDdwMsgSize= 0; <br>BOOLbContinue= TRUE; <br>BOOLbNotFinished= TRUE; <br>    HRESULT             hr= E_FAIL; <br> <br>// For this function, we could have spun a seperate thread or integrated <br>// the app/lobby client messaging into the main receive thread.  <br>// For simplicity sake, the app/lobby client messaging loop is contained below.  <br> <br>// There are seven possible states that get us out of this function:  <br>//1. receive DPLSYS_DPLAYCONNECTSUCCEEDED <br>//  2. receive DPLSYS_DPLAYCONNECTFAILED <br>//  3. (Option) timeout waiting for hReceiveEvent <br>//  4. DPERR_OUTOFMEMORY <br>//  5. We receive an unexpected player-to-player msg. <br>//  6. The app terminated. <br>//  7. We get a system message we don't know about. <br>//  8. We get an error calling receive <br> <br>*lpdwStatus = 0; <br> <br>while (bNotFinished) <br>{ <br>if (hReceiveEvent) <br>{ <br>if (WAIT_TIMEOUT == WaitForSingleObject( hReceiveEvent, 20000 )) <br>{ <br>hr = DPERR_TIMEOUT; <br>bNotFinished = FALSE; <br>break; <br>} <br>} <br> <br>do <br>{ <br>hr =IDirectPlayLobby_ReceiveLobbyMessage(lpDPInfo-&gt;lpDirectPlayLobby2A,  <br>0, dwAppId, &amp;dwMsgFlags,  <br>lpvMsg, &amp;dwMsgSize); <br> <br>switch( hr ) <br>{ <br>case DPERR_BUFFERTOOSMALL: <br>{ <br>if (lpvMsg) <br>{ <br>GlobalFreePtr( lpvMsg ); <br>lpvMsg = NULL; <br>} <br> <br>lpvMsg = GlobalAllocPtr(GHND, dwMsgSize); <br>if(!lpvMsg) <br>{hr = DPERR_OUTOFMEMORY; <br>goto end; <br>} <br>} <br>break; <br> <br>case DP_OK: <br>{ <br>// This better be a system message <br>if(!(dwMsgFlags &amp; DPLAD_SYSTEM)) <br>{ <br>LPDPMSG_GENERIC lp = (LPDPMSG_GENERIC) lpvMsg; <br>hr = DPERR_GENERIC; <br>goto end; <br>} <br> <br>if ( lpvMsg ) <br>{ <br>// Switch on the system message type <br>*lpdwStatus = *(LPDWORD)lpvMsg; <br> <br>switch(*lpdwStatus) <br>{ <br>case DPLSYS_APPTERMINATED: <br>// App shut down <br>bNotFinished = FALSE; <br>bContinue = FALSE; <br>break; <br> <br>case DPLSYS_CONNECTIONSETTINGSREAD: <br>break; <br> <br>case DPLSYS_DPLAYCONNECTSUCCEEDED: <br>case DPLSYS_DPLAYCONNECTFAILED: <br>bNotFinished = FALSE; <br>break; <br> <br>default: <br>// RUNDPMSGLOG: Unexpected system message type <br>hr = DPERR_GENERIC; <br>bContinue = FALSE; <br>bNotFinished = FALSE; <br>break; <br>} <br>} <br>} <br>break; <br> <br>case DPERR_NOMESSAGES: <br>// There are no messages left.  <br>// We need to stop and wait for another <br>bContinue = FALSE; <br>break; <br> <br>default: <br>goto end; <br>break; <br>} <br> <br>} while( bContinue ); <br>} <br> <br>end: <br> <br>// Free resources <br>    GlobalFreePtr( lpvMsg ); <br> <br>    // Return  <br>    return (DPERR_NOMESSAGES == hr ? DP_OK : hr ); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>void HandleStartSession(LPDPLCONNECTION lpConn, LPDPLAYINFO lpDPInfo ) <br>{ <br>DWORDdwAppID; <br>CHARszStr[MAXSTRLEN]; <br>HRESULThr; <br>HANDLEhEvent = CreateEvent( NULL, FALSE, FALSE, NULL ); <br>DWORDdwStatus = 0; <br> <br>if (hEvent) <br>{ <br>// display name of application to launch <br>hr = GetLocalAppName(lpDPInfo-&gt;lpDirectPlayLobby2A,  <br>&amp;lpConn-&gt;lpSessionDesc-&gt;guidApplication, szStr); <br> <br>if FAILED(hr) <br>lstrcpy(szStr, "unknown"); <br> <br>LogString("Launching \"%s\"...\r\n", szStr); <br> <br>// Call RunApplication <br>hr = IDirectPlayLobby_RunApplication(lpDPInfo-&gt;lpDirectPlayLobby2A, 0, &amp;dwAppID, lpConn, hEvent ); <br> <br>if FAILED(hr) <br>{ <br>ErrorBox("Could not launch application because of error 0x%08X", hr); <br>} <br>else <br>{ <br>// Wait for the app to launch <br>hr = WaitForRunMsg( dwAppID, hEvent, &amp;dwStatus, lpDPInfo ); <br>} <br> <br>CloseHandle( hEvent ); <br>} <br> <br>} // HandleStartSession <br> <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>BOOL FAR PASCAL EnumApp(LPCDPLAPPINFO lpAppInfo, LPVOID lpContext, DWORD dwFlags) <br>{ <br>    HWNDhWnd = (HWND)lpContext; <br>    LRESULTiIndex; <br>LPGUIDlpGuid; <br> <br>// store application name in combo box <br>iIndex = SendDlgItemMessage(hWnd, IDC_APPCOMBO, CB_ADDSTRING, 0, (LPARAM) lpAppInfo-&gt;lpszAppNameA); <br>if (iIndex == LB_ERR) <br>goto Failure; <br> <br>// make space for application GUID <br>lpGuid = (LPGUID) GlobalAllocPtr(GHND, sizeof(GUID)); <br>if (lpGuid == NULL) <br>goto Failure; <br> <br>// store pointer to GUID in combo box <br>*lpGuid = lpAppInfo-&gt;guidApplication; <br>SendDlgItemMessage(hWnd, IDC_APPCOMBO, CB_SETITEMDATA, (WPARAM) iIndex, (LPARAM) lpGuid); <br> <br>Failure: <br>    return (TRUE); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>HRESULT GetComboBoxGuid(HWND hWnd, LONG iDialogItem, LPGUID lpguidReturn) <br>{ <br>LONGiIndex; <br> <br>// get index of selected item <br>iIndex = SendDlgItemMessage(hWnd, iDialogItem, CB_GETCURSEL, <br>(WPARAM) 0, (LPARAM) 0); <br>if (iIndex == CB_ERR) <br>return (DPERR_GENERIC); <br> <br>// get data associated with this item <br>iIndex = SendDlgItemMessage(hWnd, iDialogItem, CB_GETITEMDATA, <br>(WPARAM) iIndex, (LPARAM) 0); <br>if ((iIndex == CB_ERR) || (iIndex == 0)) <br>return (DPERR_GENERIC); <br> <br>// data is a pointer to a guid <br>*lpguidReturn = *((LPGUID) iIndex); <br> <br>return (DP_OK); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>BOOL FAR PASCAL GetLocalAppNameCallback(LPCDPLAPPINFO lpAppInfo, LPVOID lpContext, DWORD dwFlags) <br>{ <br>    LPAPPNAMECONTEXTlpAppNameContext = (LPAPPNAMECONTEXT) lpContext; <br> <br>if (IsEqualGUID(lpAppInfo-&gt;guidApplication, lpAppNameContext-&gt;guidApplication)) <br>{ <br>lstrcpy(lpAppNameContext-&gt;szAppName, lpAppInfo-&gt;lpszAppNameA); <br>return (FALSE); <br>} <br> <br>    return (TRUE); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>HRESULT GetLocalAppName(LPDIRECTPLAYLOBBY lpIDPL, <br>LPGUID lpguidApplication, LPSTR lpszAppName) <br>{ <br>HRESULThr; <br>APPNAMECONTEXTAppNameContext; <br> <br>ZeroMemory(&amp;AppNameContext, sizeof(APPNAMECONTEXT)); <br>AppNameContext.guidApplication = *lpguidApplication; <br> <br>// search local apps for matching guid <br>hr = IDirectPlayLobby_EnumLocalApplications(lpIDPL, GetLocalAppNameCallback, &amp;AppNameContext, 0); <br>if FAILED(hr) <br>goto FAILURE; <br> <br>// no local app found matching this guid <br>if (lstrlen(AppNameContext.szAppName) == 0) <br>{ <br>hr = DPERR_GENERIC; <br>goto FAILURE; <br>} <br> <br>// return name <br>lstrcpy(lpszAppName, AppNameContext.szAppName); <br> <br>FAILURE: <br>return (hr); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>void ErrorBox(LPSTR lpszErrorStr, HRESULT hr) <br>{ <br>charszStr[MAXSTRLEN]; <br> <br>wsprintf(szStr, lpszErrorStr, hr); <br> <br>MessageBox(NULL, szStr, "Error", MB_OK); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>void OnSize(HWND hWnd, LPDPLAYINFO lpDPInfo) <br>{ <br>    HDWP hDWP; <br>    RECT ClientRect; <br>    int Height; <br>int xSpacing = lpDPInfo-&gt;xSpacing; <br>int ySpacing = lpDPInfo-&gt;ySpacing; <br>    HWND hKeyTreeWnd; <br>    HWND hValueListWnd; <br>HWND hMsgEditWnd; <br>HWND hSendButtonWnd; <br>    int x; <br>    int dx; <br>RECT SendButtonRect; <br>int sendbuttonwidth; <br>int sendbuttonheight; <br> <br>    if (IsIconic(hWnd)) <br>        return; <br> <br>    if ((hDWP = BeginDeferWindowPos(4)) != NULL) <br>    { <br>        //  Data structure used when calling GetEffectiveClientRect (which takes into <br>        //  account space taken up by the toolbars/status bars).  First half of the <br>        //  pair is zero when at the end of the list, second half is the control id. <br>        int s_EffectiveClientRectData[] = { <br>            1, 0,                               //  For the menu bar, but is unused <br>            0, 0                                //  First zero marks end of data <br>        }; <br> <br>        GetEffectiveClientRect(hWnd, &amp;ClientRect, s_EffectiveClientRectData); <br>        Height = ClientRect.bottom - ClientRect.top - (ySpacing * 5); <br> <br>// Resize the tree control <br>hKeyTreeWnd = GetDlgItem( hWnd, IDT_MESSAGEVIEW ); <br> <br>        DeferWindowPos(hDWP, hKeyTreeWnd, NULL,  <br>xSpacing, ClientRect.top + ySpacing,  <br>lpDPInfo-&gt;xPaneSplit, Height,  <br>SWP_NOZORDER | SWP_NOACTIVATE); <br> <br>        x = lpDPInfo-&gt;xPaneSplit + lpDPInfo-&gt;xHalfSplitWidth * 2; <br>        dx = ClientRect.right - ClientRect.left - x - xSpacing; <br> <br>        // Resize the logging window <br>hValueListWnd = GetDlgItem( hWnd, IDC_LOGEDIT ); <br> <br>        DeferWindowPos(hDWP, hValueListWnd, NULL,  <br>x, ClientRect.top+ySpacing,  <br>dx, Height, <br>            SWP_NOZORDER | SWP_NOACTIVATE); <br> <br>        // move the Send button, its size is constant <br>hSendButtonWnd = GetDlgItem( hWnd, IDC_SENDBUTTON); <br> <br>GetWindowRect( hSendButtonWnd, &amp;SendButtonRect ); <br>sendbuttonwidth = SendButtonRect.right - SendButtonRect.left;  <br>sendbuttonheight = SendButtonRect.bottom - SendButtonRect.top;  <br> <br>        DeferWindowPos(hDWP, hSendButtonWnd, NULL,  <br>ClientRect.right - ( sendbuttonwidth + xSpacing ),  <br>ClientRect.bottom - ( sendbuttonheight + ySpacing ),  <br>sendbuttonwidth,  <br>sendbuttonheight, <br>            SWP_NOZORDER | SWP_NOACTIVATE); <br> <br>        // Resize and move the message edit control <br>hMsgEditWnd = GetDlgItem( hWnd, IDC_SENDEDIT ); <br> <br>        DeferWindowPos(hDWP, hMsgEditWnd, NULL,  <br>ClientRect.left + xSpacing,  <br>ClientRect.bottom - ( sendbuttonheight + ySpacing ),  <br>ClientRect.right - ClientRect.left - (sendbuttonwidth + xSpacing * 3),  <br>sendbuttonheight, <br>            SWP_NOZORDER | SWP_NOACTIVATE); <br> <br>EndDeferWindowPos(hDWP); <br>    } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
