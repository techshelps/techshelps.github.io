<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DIALOG.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2975"></a>DIALOG.CPP</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved. <br> * <br> *  File:       dialog.cpp <br> *  Content:Creates a dialog to query the user for connection settings <br> *and establish a connection. <br> * <br> ***************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;cguid.h&gt; <br> <br>#include "bellhop.h" <br>#include "resource.h" <br> <br>// constants <br>const DWORD MAXNAMELEN= 200;// max size of a session or player name <br>const UINTTIMERID= 1;// timer ID to use <br>const UINTTIMERINTERVAL= 1000;// timer interval <br> <br>// prototypes <br>BOOL CALLBACKConnectWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam); <br>BOOL CALLBACKSecurityCredentialsWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam); <br> <br>HRESULTCreateDirectPlayInterface(LPDIRECTPLAY3A *lplpDirectPlay3A ); <br>HRESULTCreateDirectPlayLobbyInterface(LPDIRECTPLAYLOBBY2A *lplpDirectPlayLobby2A ); <br>BOOL FAR PASCAL DirectPlayEnumConnectionsCallback(LPCGUID lpguidSP, LPVOID lpConnection, DWORD dwSize, LPCDPNAME lpName,  <br>  DWORD dwFlags, LPVOID lpContext); <br>HRESULTDestroyDirectPlayInterface(HWND hWnd, LPDIRECTPLAY3A lpDirectPlay3A); <br>HRESULTDestroyDirectPlayLobbyInterface(HWND hWnd, LPDIRECTPLAYLOBBY2A lpDirectPlayLobby2A); <br>HRESULT JoinSession(HWND hWnd, <br>LPDIRECTPLAY3A lpDirectPlay3A, <br>LPDIRECTPLAYLOBBY2A lpDirectPlayLobby2A, <br>LPGUID lpguidSessionInstance, <br>DWORDdwSessionFlags, <br>LPSTR lpszPlayerName, <br>DWORDdwPlayerFlags, <br>LPDPLAYINFO lpDPInfo); <br> <br>HRESULTEnumSessions(HWND hWnd, LPDIRECTPLAY3A lpDirectPlay3A); <br> <br>HRESULTGetConnection(HWND hWnd,  int idCombo, LPVOID *lplpConnection); <br>HRESULTGetConnectionSPGuid(HWND hWnd, int idCombo, GUID *lpGuidSP); <br>voidDeleteConnectionList(HWND hWnd); <br>HRESULTGetSessionInfo(HWND hWnd, LPGUID lpguidSessionInstance, LPDWORD lpdwFlags); <br>voidSelectSessionInstance(HWND hWnd, LPGUID lpguidSessionInstance); <br>voidDeleteSessionInstanceList(HWND hWnd); <br>voidEnableDlgButton(HWND hDlg, int nIDDlgItem, BOOL bEnable); <br> <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>HRESULT ConnectUsingDialog(HINSTANCE hInstance, LPDPLAYINFO lpDPInfo) <br>{ <br>// ask user for connection settings <br>if (DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_CONNECTDIALOG), <br>   NULL, (DLGPROC) ConnectWndProc, (LPARAM) lpDPInfo)) <br>{ <br>return (DP_OK); <br>} <br>else <br>{ <br>return (DPERR_USERCANCEL); <br>} <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>BOOL CALLBACK ConnectWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) <br>{ <br>static LPDPLAYINFOlpDPInfo; <br>static LPDIRECTPLAY3AlpDirectPlay3A; <br>static LPDIRECTPLAYLOBBY2AlpDirectPlayLobby2A; <br>static UINTidTimer; <br>GUIDguidSessionInstance; <br>charszPlayerName[MAXNAMELEN]; <br>DWORDdwNameSize; <br>HRESULThr; <br>LPVOIDlpConnection = NULL; <br>ENUMCONNSTRUCTenStruct; <br>DWORDdwSessionFlags; <br>DWORDdwPlayerFlags = NULL; <br> <br>    switch(uMsg) <br>    { <br>    case WM_INITDIALOG: <br>        // save the connection info pointer <br>        lpDPInfo = (LPDPLAYINFO) lParam; <br>lpDirectPlay3A = NULL; <br>lpDirectPlayLobby2A = NULL; <br> <br>// Create an IDirectPlay3 interface <br>hr = CreateDirectPlayInterface(&amp;lpDirectPlay3A); <br>if FAILED(hr) <br>goto SETUP_FAILURE; <br> <br>// Create an IDirectLobby2 interface <br>hr = CreateDirectPlayLobbyInterface(&amp;lpDirectPlayLobby2A); <br>if FAILED(hr) <br>goto SETUP_FAILURE; <br> <br>// set first item in the connections combo box <br>SendDlgItemMessage(hWnd, IDC_SPCOMBO, CB_ADDSTRING, (WPARAM) 0, (LPARAM) "&lt;Select a lobby provider&gt;"); <br>SendDlgItemMessage(hWnd, IDC_SPCOMBO, CB_SETITEMDATA, (WPARAM) 0, (LPARAM) 0); <br>SendDlgItemMessage(hWnd, IDC_SPCOMBO, CB_SETCURSEL, (WPARAM) 0, (LPARAM) 0); <br> <br>// put all the available connections in a combo box <br>enStruct.hWnd = hWnd; <br>enStruct.idCombo = IDC_SPCOMBO; <br> <br>IDirectPlay3_EnumConnections(lpDirectPlay3A, &amp;BELLHOP_GUID, DirectPlayEnumConnectionsCallback, <br>&amp;enStruct, DPCONNECTION_DIRECTPLAYLOBBY); <br> <br>// setup initial button state <br>EnableDlgButton(hWnd, IDC_JOINBUTTON, FALSE); <br>EnableDlgButton(hWnd, IDC_SPECTATORBUTTON, FALSE); <br>break; <br> <br>SETUP_FAILURE: <br>ErrorBox("Could not create DirectPlay object because of error 0x%08X", hr); <br>EndDialog(hWnd, FALSE); <br>break; <br> <br>case WM_DESTROY: <br>// delete information stored along with the lists <br>DeleteConnectionList(hWnd); <br>DeleteSessionInstanceList(hWnd); <br>        break; <br> <br>case WM_TIMER: <br>// refresh the session list <br>hr = EnumSessions(hWnd, lpDirectPlay3A); <br>break; <br> <br>    case WM_COMMAND: <br> <br>      switch(LOWORD(wParam)) <br>        { <br>case IDC_SPCOMBO: <br>switch (HIWORD(wParam)) <br>{ <br>case CBN_SELCHANGE: <br>// service provider changed, so rebuild display and <br>// delete any existing DirectPlay interface <br>KillTimer(hWnd, idTimer );  <br>hr = DestroyDirectPlayInterface(hWnd, lpDirectPlay3A); <br>lpDirectPlay3A = NULL; <br> <br>// get pointer to the selected connection <br>hr = GetConnection(hWnd, IDC_SPCOMBO, &amp;lpConnection); <br>if FAILED(hr) <br>goto SP_FAILURE; <br> <br>if (lpConnection) <br>{ <br>  // Create a new DPlay interface. <br>hr = CreateDirectPlayInterface(&amp;lpDirectPlay3A); <br> <br>if ((FAILED(hr)) || (NULL == lpDirectPlay3A)) <br>goto SP_FAILURE; <br> <br>// initialize the connection <br>hr = IDirectPlay3_InitializeConnection(lpDirectPlay3A, lpConnection, 0); <br>if FAILED(hr) <br>goto SP_FAILURE; <br> <br>// start enumerating the sessions <br>hr = EnumSessions(hWnd, lpDirectPlay3A); <br>if FAILED(hr) <br>goto SP_FAILURE; <br> <br>// set a timer to refresh the session list <br>idTimer = SetTimer(hWnd, TIMERID, TIMERINTERVAL, NULL); <br>} <br>else <br>{ <br>// They've selected the generic option "&lt;Select a service provider&gt;" <br>EnableDlgButton(hWnd, IDC_JOINBUTTON, FALSE); <br>EnableDlgButton(hWnd, IDC_SPECTATORBUTTON, FALSE); <br>} <br>break; <br>} <br>break; <br> <br>SP_FAILURE: <br>if (hr != DPERR_USERCANCEL) <br>ErrorBox("Could not select service provider because of error 0x%08X", hr); <br>break; <br> <br> <br>        case IDC_SPECTATORBUTTON: <br>// Joining as a spectator is the same as a regular join <br>// just with different flags. <br>dwPlayerFlags = DPPLAYER_SPECTATOR; <br>// Fall through to case IDC_JOINBUTTON: <br>        case IDC_JOINBUTTON: <br> <br>// should have an interface by now <br>if (lpDirectPlay3A == NULL) <br>break; <br> <br>    KillTimer(hWnd, idTimer );  <br>// get guid of selected session instance <br> <br>hr = GetSessionInfo(hWnd, &amp;guidSessionInstance, &amp;dwSessionFlags); <br>if FAILED(hr) <br>goto JOIN_FAILURE; <br> <br>// use computer name for player name <br>dwNameSize = MAXNAMELEN; <br>if (!GetComputerName(szPlayerName, &amp;dwNameSize)) <br>lstrcpy(szPlayerName, "unknown"); <br>_strlwr(szPlayerName); <br> <br>// join this session <br>hr = JoinSession(hWnd, <br>lpDirectPlay3A, <br> lpDirectPlayLobby2A,  <br> &amp;guidSessionInstance, <br> dwSessionFlags, <br> szPlayerName,  <br> dwPlayerFlags, <br> lpDPInfo); <br> <br>if FAILED(hr) <br>goto JOIN_FAILURE; <br> <br>// dismiss dialog if we succeeded in joining <br>EndDialog(hWnd, TRUE); <br>            break; <br> <br>JOIN_FAILURE: <br>ErrorBox("Could not join session because of error 0x%08X", hr); <br>break; <br> <br> <br>        case IDCANCEL: <br>// delete any interface created if cancelling <br>KillTimer(hWnd, idTimer );  <br>hr = DestroyDirectPlayInterface(hWnd, lpDirectPlay3A); <br>lpDirectPlay3A = NULL; <br> <br>hr = DestroyDirectPlayLobbyInterface(hWnd, lpDirectPlayLobby2A); <br>lpDirectPlayLobby2A = NULL; <br> <br>EndDialog(hWnd, FALSE); <br>            break; <br>        } <br> <br>        break; <br>    } <br> <br>    // Allow for default processing <br>    return FALSE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>BOOL FAR PASCAL DirectPlayEnumConnectionsCallback( <br>LPCGUIDlpguidSP, <br>LPVOIDlpConnection, <br>DWORDdwSize, <br>LPCDPNAMElpName, <br>DWORDdwFlags, <br>LPVOIDlpContext) <br>{ <br>LPENUMCONNSTRUCTlp = (LPENUMCONNSTRUCT) lpContext; <br>    LRESULTiIndex; <br>LPCONNECTIONINFOlpConnectionBuffer = NULL; <br> <br>// store service provider name in combo box <br>iIndex = SendDlgItemMessage(lp-&gt;hWnd, lp-&gt;idCombo, CB_ADDSTRING, 0,  <br>(LPARAM) lpName-&gt;lpszShortNameA); <br>if (iIndex == CB_ERR) <br>goto FAILURE; <br> <br>// make space for Connection Shortcut <br>lpConnectionBuffer = (LPCONNECTIONINFO) GlobalAllocPtr(GHND, dwSize+sizeof(CONNECTIONINFO)); <br>if (lpConnectionBuffer == NULL) <br>goto FAILURE; <br> <br>// store pointer to GUID in combo box <br>memcpy(lpConnectionBuffer-&gt;Connection, lpConnection, dwSize); <br>lpConnectionBuffer-&gt;guidSP = *lpguidSP; <br>SendDlgItemMessage(lp-&gt;hWnd, lp-&gt;idCombo, CB_SETITEMDATA, (WPARAM) iIndex,  <br>(LPARAM) lpConnectionBuffer); <br> <br>FAILURE: <br>    return (TRUE); <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>HRESULT CreateDirectPlayInterface( LPDIRECTPLAY3A *lplpDirectPlay3A ) <br>{ <br>HRESULThr; <br>LPDIRECTPLAY3AlpDirectPlay3A = NULL; <br> <br>// Create an IDirectPlay3 interface <br>hr = CoCreateInstance(CLSID_DirectPlay, NULL, CLSCTX_INPROC_SERVER,  <br>IID_IDirectPlay3A, (LPVOID*)&amp;lpDirectPlay3A); <br> <br>// return interface created <br>*lplpDirectPlay3A = lpDirectPlay3A; <br> <br>return (hr); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>HRESULT CreateDirectPlayLobbyInterface( LPDIRECTPLAYLOBBY2A *lplpDirectPlayLobby2A ) <br>{ <br>HRESULThr; <br>LPDIRECTPLAYLOBBY2AlpDirectPlayLobby2A = NULL; <br> <br>// Create an IDirectPlay3 interface <br>hr = CoCreateInstance(CLSID_DirectPlayLobby, NULL, CLSCTX_INPROC_SERVER,  <br>IID_IDirectPlayLobby2A, (LPVOID*)&amp;lpDirectPlayLobby2A); <br> <br>// return interface created <br>*lplpDirectPlayLobby2A = lpDirectPlayLobby2A; <br> <br>return (hr); <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>HRESULT DestroyDirectPlayInterface(HWND hWnd, LPDIRECTPLAY3A lpDirectPlay3A) <br>{ <br>HRESULThr = DP_OK; <br> <br>if (lpDirectPlay3A) <br>{ <br>DeleteSessionInstanceList(hWnd); <br>EnableDlgButton(hWnd, IDC_JOINBUTTON, FALSE); <br>EnableDlgButton(hWnd, IDC_SPECTATORBUTTON, FALSE); <br> <br>hr = IDirectPlay3_Release(lpDirectPlay3A); <br>} <br> <br>return (hr); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>HRESULT DestroyDirectPlayLobbyInterface(HWND hWnd, LPDIRECTPLAYLOBBY2A lpDirectPlayLobby2A) <br>{ <br>HRESULThr = DP_OK; <br> <br>if (lpDirectPlayLobby2A) <br>{ <br>hr = lpDirectPlayLobby2A-&gt;Release(); <br>} <br> <br>return (hr); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>HRESULT JoinSession(HWND hWnd, <br>LPDIRECTPLAY3A lpDirectPlay3A, <br>LPDIRECTPLAYLOBBY2A lpDirectPlayLobby2A, <br>LPGUID lpguidSessionInstance, <br>DWORDdwSessionFlags, <br>LPSTR lpszPlayerName, <br>DWORDdwPlayerFlags, <br>LPDPLAYINFO lpDPInfo) <br>{ <br>DPIDdpidPlayer; <br>DPNAMEdpName; <br>DPSESSIONDESC2sessionDesc; <br>HRESULThr; <br> <br>// check for valid interface <br>if (lpDirectPlay3A == NULL) <br>return (DPERR_INVALIDOBJECT); <br> <br>// Spectator or regular player <br>lpDPInfo-&gt;dwPlayerFlags = dwPlayerFlags; <br> <br>// prepare a session description <br>ZeroMemory(&amp;sessionDesc, sizeof(DPSESSIONDESC2)); <br>sessionDesc.dwSize = sizeof(DPSESSIONDESC2); <br>    sessionDesc.guidInstance = *lpguidSessionInstance; <br>sessionDesc.dwFlags = dwSessionFlags; <br> <br>if (DPSESSION_SECURESERVER &amp; dwSessionFlags ) <br>{ <br>hr = IDirectPlay3_SecureOpen(lpDirectPlay3A, <br>&amp;sessionDesc, <br>DPOPEN_JOIN, <br>NULL, <br>NULL ); <br> <br>if ( DPERR_LOGONDENIED == hr ) <br>{ <br> <br>// we need to collect security credentials <br>// and try again. <br> <br>if (DialogBoxParam( ghInstance,  <br>MAKEINTRESOURCE(IDD_SECURITYCREDENTIALSDIALOG),  <br>hWnd, <br>(DLGPROC) SecurityCredentialsWndProc,  <br>(LPARAM) &amp;lpDPInfo)) <br>{ <br> <br>DPCREDENTIALS dpcr; <br>dpcr.dwSize = sizeof(DPCREDENTIALS); <br>dpcr.dwFlags = 0; <br>dpcr.lpszUsernameA = lpDPInfo-&gt;szSecureName; <br>dpcr.lpszPasswordA = lpDPInfo-&gt;szSecurePassword; <br>dpcr.lpszDomainA = lpDPInfo-&gt;szSecureDomain; <br> <br>hr = IDirectPlay3_SecureOpen(lpDirectPlay3A, <br>&amp;sessionDesc, <br>DPOPEN_JOIN, <br>NULL, <br>&amp;dpcr ); <br>if (FAILED(hr)) <br>{ <br>// Conceivably, we could cycle back and try to get credentials again <br>// but in this sample, we'll just drop out on the error. <br>goto OPEN_FAILURE; <br>} <br> <br>lpDPInfo-&gt;bSecureSession = TRUE; <br>} <br>else <br>{ <br>// abort. user clicked cancel. <br>goto OPEN_FAILURE; <br>} <br>} <br>} <br>else <br>{ <br>// Session does not require security <br>hr = IDirectPlay3_Open(lpDirectPlay3A, &amp;sessionDesc, DPOPEN_JOIN); <br>if FAILED(hr) <br>goto OPEN_FAILURE; <br>} <br> <br>// fill out name structure <br>ZeroMemory(&amp;dpName, sizeof(DPNAME)); <br>dpName.dwSize = sizeof(DPNAME); <br>dpName.lpszShortNameA = lpszPlayerName; <br>dpName.lpszLongNameA = NULL; <br> <br>// create a player with this name <br>hr = IDirectPlay3_CreatePlayer(lpDirectPlay3A, &amp;dpidPlayer, &amp;dpName,  <br>lpDPInfo-&gt;hPlayerEvent, <br>NULL, 0, dwPlayerFlags ); <br>if FAILED(hr) <br>goto CREATEPLAYER_FAILURE; <br> <br>// return connection info <br>lpDPInfo-&gt;lpDirectPlay3A = lpDirectPlay3A; <br>lpDPInfo-&gt;lpDirectPlayLobby2A = lpDirectPlayLobby2A; <br> <br>lpDPInfo-&gt;dpidPlayer = dpidPlayer; <br>lpDPInfo-&gt;bIsHost = FALSE; <br> <br>return (DP_OK); <br> <br>CREATEPLAYER_FAILURE: <br>OPEN_FAILURE: <br>IDirectPlay3_Close(lpDirectPlay3A); <br>return (hr); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>BOOL FAR PASCAL EnumSessionsCallback( <br>LPCDPSESSIONDESC2lpSessionDesc, <br>LPDWORDlpdwTimeOut, <br>DWORDdwFlags, <br>LPVOIDlpContext) <br>{ <br>HWNDhWnd = (HWND) lpContext; <br>LONGiIndex; <br>charszBuffer[256]; <br>LPSESSIONINFOlpSessionInfo = NULL; <br> <br>// see if last session has been enumerated <br>    if (dwFlags &amp; DPESC_TIMEDOUT) <br>return (FALSE); <br> <br>wsprintf(szBuffer,  <br>(DPSESSION_SECURESERVER &amp; lpSessionDesc-&gt;dwFlags ? "%s (SECURE)" : "%s" ), <br>lpSessionDesc-&gt;lpszSessionNameA ); <br> <br>// store session name in list <br>iIndex = SendDlgItemMessage( hWnd, IDC_SESSIONLIST, LB_ADDSTRING,  <br>(WPARAM) 0, (LPARAM) szBuffer); <br> <br>if (iIndex == LB_ERR) <br>goto FAILURE; <br> <br> <br>// make space for session instance guid <br>lpSessionInfo = (LPSESSIONINFO) GlobalAllocPtr( GHND, sizeof(SESSIONINFO) ); <br>if (lpSessionInfo == NULL) <br>goto FAILURE; <br> <br>// Extract the data we need from the session description <br>lpSessionInfo-&gt;guidInstance = lpSessionDesc-&gt;guidInstance; <br>lpSessionInfo-&gt;dwFlags = lpSessionDesc-&gt;dwFlags; <br> <br>// store pointer to guid in list <br>SendDlgItemMessage( hWnd, IDC_SESSIONLIST, LB_SETITEMDATA, (WPARAM) iIndex, (LPARAM) lpSessionInfo); <br> <br>FAILURE: <br>    return (TRUE); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>HRESULT EnumSessions(HWND hWnd, LPDIRECTPLAY3A lpDirectPlay3A) <br>{ <br>DPSESSIONDESC2sessionDesc; <br>GUIDguidSessionInstance; <br>DWORDdwFlags; <br>LONGiIndex; <br>HRESULThr; <br> <br>// check for valid interface <br>if (lpDirectPlay3A == NULL) <br>return (DPERR_INVALIDOBJECT); <br> <br>// get guid of currently selected session <br>guidSessionInstance = GUID_NULL; <br>hr = GetSessionInfo(hWnd, &amp;guidSessionInstance, &amp;dwFlags); <br> <br>// delete existing session list <br>DeleteSessionInstanceList(hWnd); <br> <br>// add sessions to session list <br>ZeroMemory(&amp;sessionDesc, sizeof(DPSESSIONDESC2)); <br>sessionDesc.dwSize = sizeof(DPSESSIONDESC2); <br>    sessionDesc.guidApplication = BELLHOP_GUID; <br> <br>hr = IDirectPlay3_EnumSessions(lpDirectPlay3A, &amp;sessionDesc, 0, EnumSessionsCallback, <br>  hWnd, DPENUMSESSIONS_AVAILABLE | DPENUMSESSIONS_ASYNC); <br> <br>// select the session that was previously selected <br>SelectSessionInstance(hWnd, &amp;guidSessionInstance); <br> <br>// hilite "Join" button only if there are sessions to join <br>iIndex = SendDlgItemMessage(hWnd, IDC_SESSIONLIST, LB_GETCOUNT, <br>   (WPARAM) 0, (LPARAM) 0); <br> <br>EnableDlgButton(hWnd, IDC_JOINBUTTON, (iIndex &gt; 0) ? TRUE : FALSE); <br>EnableDlgButton(hWnd, IDC_SPECTATORBUTTON, (iIndex &gt; 0) ? TRUE : FALSE); <br> <br>return (hr); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>HRESULT GetConnection(HWND hWnd, int idCombo, LPVOID *lplpConnection) <br>{ <br>LONGiIndex; <br> <br>// get index of the item currently selected in the combobox <br>iIndex = SendDlgItemMessage(hWnd,  idCombo, CB_GETCURSEL, <br>(WPARAM) 0, (LPARAM) 0); <br>if (iIndex == CB_ERR) <br>return (DPERR_GENERIC); <br> <br>// get the pointer to the connection shortcut associated with <br>// the item <br>iIndex = SendDlgItemMessage(hWnd, idCombo, CB_GETITEMDATA, <br>(WPARAM) iIndex, (LPARAM) 0); <br> <br>if ((CB_ERR == iIndex) || ( NULL == iIndex )) <br>return (DPERR_GENERIC); <br> <br>*lplpConnection = &amp;((LPCONNECTIONINFO) iIndex)-&gt;Connection; <br> <br>return (DP_OK); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>HRESULT GetConnectionSPGuid(HWND hWnd, int idCombo, GUID *lpGuidSP) <br>{ <br>LONGiIndex; <br> <br>// get index of the item currently selected in the combobox <br>iIndex = SendDlgItemMessage(hWnd,  idCombo, CB_GETCURSEL, <br>(WPARAM) 0, (LPARAM) 0); <br>if (iIndex == CB_ERR) <br>return (DPERR_GENERIC); <br> <br>// get the pointer to the connection shortcut associated with <br>// the item <br>iIndex = SendDlgItemMessage(hWnd, idCombo, CB_GETITEMDATA, <br>(WPARAM) iIndex, (LPARAM) 0); <br> <br>if ((iIndex == CB_ERR) || (iIndex == NULL )) <br>return (DPERR_GENERIC); <br> <br>*lpGuidSP = ((LPCONNECTIONINFO) iIndex)-&gt;guidSP; <br> <br>return (DP_OK); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>void DeleteConnectionList(HWND hWnd) <br>{ <br>WPARAMi; <br>LONGlpData; <br> <br>// destroy the GUID's stored with each service provider name <br>i = 0; <br>while (TRUE) <br>{ <br>// get data pointer stored with item <br>lpData = SendDlgItemMessage(hWnd, IDC_SPCOMBO, CB_GETITEMDATA, <br>(WPARAM) i, (LPARAM) 0); <br>if (lpData == CB_ERR)// error getting data <br>break; <br> <br>if (lpData != 0)// no data to delete <br>GlobalFreePtr((LPVOID) lpData); <br> <br>i += 1; <br>} <br> <br>// delete all items in combo box <br>SendDlgItemMessage(hWnd, IDC_SPCOMBO, CB_RESETCONTENT, <br>(WPARAM) 0, (LPARAM) 0); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>HRESULT GetSessionInfo(HWND hWnd, LPGUID lpguidSessionInstance, LPDWORD lpdwFlags) <br>{ <br>LONGiIndex; <br>LPSESSIONINFOlp; <br> <br>// get guid for session <br>iIndex = SendDlgItemMessage(hWnd, IDC_SESSIONLIST, LB_GETCURSEL, <br>(WPARAM) 0, (LPARAM) 0); <br>if (iIndex == LB_ERR) <br>return (DPERR_GENERIC); <br> <br>iIndex = SendDlgItemMessage(hWnd, IDC_SESSIONLIST, LB_GETITEMDATA, <br>(WPARAM) iIndex, (LPARAM) 0); <br>if ((iIndex == LB_ERR) || (iIndex == 0)) <br>return (DPERR_GENERIC); <br> <br>lp = (LPSESSIONINFO) iIndex; <br>*lpguidSessionInstance = lp-&gt;guidInstance; <br>*lpdwFlags = lp-&gt;dwFlags; <br> <br>return (DP_OK); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>void DeleteSessionInstanceList(HWND hWnd) <br>{ <br>WPARAMi; <br>LONGlpData; <br> <br>// destroy the GUID's stored with each session name <br>i = 0; <br>while (TRUE) <br>{ <br>// get data pointer stored with item <br>lpData = SendDlgItemMessage(hWnd, IDC_SESSIONLIST, LB_GETITEMDATA, <br>(WPARAM) i, (LPARAM) 0); <br>if (lpData == CB_ERR)// error getting data <br>break; <br> <br>if (lpData == 0)// no data to delete <br>continue; <br> <br>GlobalFreePtr((LPVOID) lpData); <br>i += 1; <br>} <br> <br>// delete all items in list <br>SendDlgItemMessage(hWnd, IDC_SESSIONLIST, LB_RESETCONTENT, <br>(WPARAM) 0, (LPARAM) 0); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>void SelectSessionInstance(HWND hWnd, LPGUID lpguidSessionInstance) <br>{ <br>WPARAMi, iIndex; <br>LONGlpData; <br> <br>// loop over the GUID's stored with each session name <br>// to find the one that matches what was passed in <br>i = 0; <br>iIndex = 0; <br>while (TRUE) <br>{ <br>// get data pointer stored with item <br>lpData = SendDlgItemMessage(hWnd, IDC_SESSIONLIST, LB_GETITEMDATA, <br>(WPARAM) i, (LPARAM) 0); <br>if (lpData == CB_ERR)// error getting data <br>break; <br> <br>if (lpData == 0)// no data to compare to <br>continue; <br> <br>// guid matches <br>if (IsEqualGUID(*lpguidSessionInstance, *((LPGUID) lpData))) <br>{ <br>iIndex = i;// store index of this string <br>break; <br>} <br> <br>i += 1; <br>} <br> <br>// select this item <br>SendDlgItemMessage(hWnd, IDC_SESSIONLIST, LB_SETCURSEL, (WPARAM) iIndex, (LPARAM) 0); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>void EnableDlgButton(HWND hDlg, int nIDDlgItem, BOOL bEnable) <br>{ <br>EnableWindow(GetDlgItem(hDlg, nIDDlgItem), bEnable); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>BOOL CALLBACK SecurityCredentialsWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) <br>{ <br>static LPDPLAYINFOlpDPInfo; <br>HWNDhwndName= NULL, <br>hwndPassword= NULL, <br>hwndDomain= NULL; <br> <br> <br>    switch(uMsg) <br>    { <br>    case WM_INITDIALOG: <br>        lpDPInfo = (LPDPLAYINFO) lParam; <br>break; <br> <br>    case WM_COMMAND: <br> <br>      switch(LOWORD(wParam)) <br>        { <br>case IDOK: <br>hwndName = GetDlgItem( hWnd, IDC_SECURENAME ); <br>hwndPassword = GetDlgItem( hWnd, IDC_SECUREPASSWORD ); <br>hwndDomain = GetDlgItem( hWnd, IDC_SECUREDOMAIN ); <br> <br>Edit_GetText(hwndName, lpDPInfo-&gt;szSecureName, 256); <br>Edit_GetText(hwndPassword, lpDPInfo-&gt;szSecurePassword, 256); <br>Edit_GetText(hwndDomain, lpDPInfo-&gt;szSecureDomain, 256); <br>EndDialog(hWnd, TRUE); <br>break; <br> <br>        case IDCANCEL: <br>EndDialog(hWnd, FALSE); <br>            break; <br>        } <br> <br>        break; <br>    } <br> <br>    // Allow for default processing <br>    return FALSE; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
