<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CGRPTREE.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2972"></a>CGRPTREE.CPP</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved. <br> * <br> *  File:       cGrpTree.cpp <br> *  Content:An abstracted Tree control that knows how to handle <br> *              DirectPlay system messages and enumerations. <br> * <br> ***************************************************************************/ <br> <br>#include "cgrptree.h" <br> <br>WNDPROCgwpOrigEditProc; <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>long FAR PASCAL EditCtrlSubProc(HWND hWnd, WORD wMessage,WORD wParam,LONG lParam) <br>{ <br>  <br>    switch (wMessage) <br>     { <br>  <br>          case WM_GETDLGCODE: <br>            return (DLGC_WANTALLKEYS | <br>                    CallWindowProc( gwpOrigEditProc, hWnd, wMessage, <br>                                   wParam, lParam)); <br>  <br>          case WM_CHAR: <br>          //Process this message to avoid message beeps. <br>if ((wParam == VK_RETURN) || (wParam == VK_TAB)) <br>return 0; <br>break ; <br>  <br>       default: <br>            break; <br>  <br>     } /* end switch */ <br> <br>return (CallWindowProc( gwpOrigEditProc, hWnd, wMessage, <br>                                   wParam, lParam)); <br> <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>BOOL FAR PASCAL TV_EnumPlayersCallback(DPID dpId, <br>DWORD dwPlayerType,  <br>LPCDPNAME lpName, <br>DWORD dwFlags,  <br>LPVOID lpContext) <br>{ <br>LPENUMTREESTRUCT lp = (LPENUMTREESTRUCT) lpContext; <br> <br>if (DPPLAYERTYPE_GROUP == dwPlayerType) <br>{ <br>if (DPENUMGROUPS_SHORTCUT &amp; dwFlags) <br>{ <br>lp-&gt;lpTree-&gt;AddGroupToGroup( lp-&gt;dpidParent, dpId, dwFlags ); <br>} <br>else <br>{ <br>HRESULThr; <br>ENUMTREESTRUCTets; <br> <br>ets.dpidParent = dpId; <br>ets.lpTree = lp-&gt;lpTree; <br>ets.bRecursive = lp-&gt;bRecursive; <br> <br>if (NULL == lp-&gt;dpidParent) <br>{ <br>lp-&gt;lpTree-&gt;CreateGroup( dpId, lpName-&gt;lpszShortNameA, dwFlags ); <br>} <br>else <br>{ <br>lp-&gt;lpTree-&gt;CreateGroupInGroup( lp-&gt;dpidParent, dpId, lpName-&gt;lpszShortNameA, dwFlags ); <br>} <br> <br>if (ets.bRecursive) <br>{ <br>hr = lp-&gt;lpTree-&gt;m_lpDP3A-&gt;EnumGroupsInGroup(dpId, NULL,  <br>TV_EnumPlayersCallback,  <br>&amp;ets, DPENUMPLAYERS_ALL ); <br> <br>hr = lp-&gt;lpTree-&gt;m_lpDP3A-&gt;EnumGroupPlayers(dpId, NULL,  <br>TV_EnumPlayersCallback,  <br>&amp;ets, DPENUMPLAYERS_ALL ); <br>} <br> <br>} <br>} <br>else <br>{ <br>if (lp-&gt;dpidParent) <br>{ <br>lp-&gt;lpTree-&gt;AddPlayerToGroup( lp-&gt;dpidParent, dpId, dwFlags ); <br>} <br>else <br>{ <br>lp-&gt;lpTree-&gt;CreatePlayer( dpId, lpName-&gt;lpszShortNameA, dwFlags ); <br>} <br>} <br> <br>return TRUE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>int CALLBACK CompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort) <br>{ <br>LPBRANCHSTRUCTlp1 = (LPBRANCHSTRUCT) lParam1, <br>lp2 = (LPBRANCHSTRUCT) lParam2; <br> <br>if ( lp1-&gt;btType &lt; lp2-&gt;btType ) <br>{ <br>return -1; <br>} <br> <br>if (lp1-&gt;btType &gt; lp2-&gt;btType ) <br>{ <br>return 1; <br>} <br> <br>//if we got here, they are of the same type <br>//so sort alphabetically <br> <br>LPDPNAMElpdpn1 = NULL, <br>lpdpn2 = NULL; <br>intiRes = 0; <br>HRESULThr = DPERR_GENERIC; <br>CGroupTree *lpgt = (CGroupTree *) lParamSort; <br> <br>if ((lp1-&gt;btType == BT_PLAYER ) || (lp1-&gt;btType == BT_PLAYER_IN_GROUP )) <br>{ <br>hr = lpgt-&gt;GetPlayerName( lp1-&gt;dpid, &amp;lpdpn1 ); <br>} <br>else <br>{ <br>hr = lpgt-&gt;GetGroupName( lp1-&gt;dpid, &amp;lpdpn1 ); <br>} <br> <br>if FAILED(hr) <br>{ <br>goto FAILURE; <br>} <br> <br>if ((lp2-&gt;btType == BT_PLAYER ) || (lp2-&gt;btType == BT_PLAYER_IN_GROUP )) <br>{ <br>hr = lpgt-&gt;GetPlayerName( lp2-&gt;dpid, &amp;lpdpn2 ); <br>} <br>else <br>{ <br>hr = lpgt-&gt;GetGroupName( lp2-&gt;dpid, &amp;lpdpn2 ); <br>} <br> <br>if FAILED(hr) <br>{ <br>goto FAILURE; <br>} <br> <br> <br>iRes = strcmp( lpdpn1-&gt;lpszShortNameA, lpdpn2-&gt;lpszShortNameA ); <br> <br>if ( 0 == iRes ) <br>{ <br>//The groups have the same name. <br>if ( lp1-&gt;dpid &lt;  lp2-&gt;dpid ) <br>{ <br>iRes = -1; <br>} <br>else if ( lp1-&gt;dpid &gt;  lp2-&gt;dpid ) <br>{ <br>iRes = 1; <br>} <br>else <br>{ <br>iRes = -1; <br>} <br>} <br> <br>FAILURE: <br>if (lpdpn1) <br>LocalFree(lpdpn1); <br> <br>if (lpdpn2) <br>LocalFree(lpdpn2); <br> <br> <br>return iRes; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>CGroupTree::CGroupTree() <br>{ <br> <br>m_hInst = GetModuleHandle( NULL ); <br>m_hwndTreeView = NULL; <br>m_hwndParent = NULL; <br>m_lpDP3A = NULL; <br>m_fDragging = FALSE; <br>m_dpidPlayer = 0; <br>m_dpidLastGroup = NULL; <br> <br>// Prepare popup menus <br>m_hMenu = LoadMenu( m_hInst, MAKEINTRESOURCE(IDM_MENU) ); <br>m_hRootMenu = GetSubMenu( m_hMenu, 0 ); <br>m_hGroupMenu = GetSubMenu( m_hMenu, 1 ); <br>m_hPlayerMenu = GetSubMenu( m_hMenu, 2 ); <br>m_hShortcutMenu = GetSubMenu( m_hMenu, 3 ); <br>m_hPlayerInGroupMenu= GetSubMenu( m_hMenu, 4 ); <br> <br>// Prepare tree icons <br>m_hImageList = ImageList_Create(32, 32, 0, 8, 8); <br>ImageList_SetBkColor(m_hImageList, GetSysColor(COLOR_WINDOW)); <br>m_nGroupImg = ImageList_AddIcon(m_hImageList, LoadIcon(m_hInst, MAKEINTRESOURCE(IDI_CLOSEDDOOR))); <br>m_nInGroupImg = ImageList_AddIcon(m_hImageList, LoadIcon(m_hInst, MAKEINTRESOURCE(IDI_OPENDOOR))); <br>m_nPlayerImg = ImageList_AddIcon(m_hImageList, LoadIcon(m_hInst, MAKEINTRESOURCE(IDI_PLAYER))); <br>m_nShortcutInGroupImg = ImageList_AddIcon(m_hImageList, LoadIcon(m_hInst, MAKEINTRESOURCE(IDI_SHORTCUT))); <br>m_nStagingAreaImg = ImageList_AddIcon(m_hImageList, LoadIcon(m_hInst, MAKEINTRESOURCE(IDI_STAGINGAREA))); <br>m_nSpectatorImg = ImageList_AddIcon(m_hImageList, LoadIcon(m_hInst, MAKEINTRESOURCE(IDI_SPECTATOR))); <br>m_nSessionInProgressImg = ImageList_AddIcon(m_hImageList, LoadIcon(m_hInst, MAKEINTRESOURCE(IDI_SESSIONINPROGRESS))); <br> <br>ZeroMemory( &amp;m_bsDragging, sizeof( BRANCHSTRUCT ) ); <br> <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>CGroupTree::~CGroupTree() <br>{ <br>if (m_hImageList) <br>{ <br>ImageList_Destroy( m_hImageList ); <br>m_hImageList = NULL; <br>} <br> <br>DestroyMenu( m_hPlayerInGroupMenu ); <br>DestroyMenu( m_hShortcutMenu ); <br>DestroyMenu( m_hPlayerMenu ); <br>DestroyMenu( m_hGroupMenu ); <br>DestroyMenu( m_hRootMenu ); <br>DestroyMenu( m_hMenu ); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>BOOL CGroupTree::Init( HWND hWnd, LPDIRECTPLAY3A lpDP3A, DPID dpidPlayer ) <br>{ <br>if ( (hWnd) &amp;&amp; (lpDP3A) &amp;&amp; (dpidPlayer) ) <br>{ <br>m_hwndTreeView = hWnd; <br>m_hwndParent = GetParent( m_hwndTreeView ); <br>m_lpDP3A = lpDP3A; <br>m_dpidPlayer = dpidPlayer; <br> <br>TreeView_SetImageList(hWnd, m_hImageList, TVSIL_NORMAL); <br>return TRUE; <br>} <br>else <br>return FALSE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>HRESULT CGroupTree::GetPlayerName( DPID dpidPlayer, LPDPNAME * lplpn) <br>{ <br>HRESULThr= DPERR_GENERIC; <br>LPVOIDlpData= NULL; <br>DWORDdwSize= 0; <br> <br>hr = m_lpDP3A-&gt;GetPlayerName( dpidPlayer, NULL, &amp;dwSize ); <br> <br>if (DPERR_BUFFERTOOSMALL == hr ) <br>{ <br>lpData = LocalAlloc( LPTR, dwSize ); <br> <br>if ( NULL != lpData ) <br>{ <br>hr = m_lpDP3A-&gt;GetPlayerName( dpidPlayer, lpData, &amp;dwSize ); <br> <br>if (FAILED(hr)) <br>{ <br>LocalFree( lpData ); <br>lpData = NULL; <br>} <br>} <br>else <br>{ <br>hr = DPERR_OUTOFMEMORY; <br>} <br>} <br> <br>*lplpn = (LPDPNAME) lpData; <br> <br>return hr; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>HRESULT CGroupTree::GetGroupName( DPID dpidGroup, LPDPNAME * lplpn) <br>{ <br>HRESULThr= DPERR_GENERIC; <br>LPVOIDlpData = NULL; <br> <br>DWORDdwSize= 0; <br> <br>hr = m_lpDP3A-&gt;GetGroupName( dpidGroup, lpData, &amp;dwSize ); <br> <br>if (DPERR_BUFFERTOOSMALL == hr ) <br>{ <br>lpData = LocalAlloc( LPTR,  dwSize ); <br> <br>if ( NULL != lpData ) <br>{ <br>hr = m_lpDP3A-&gt;GetGroupName( dpidGroup, lpData, &amp;dwSize ); <br> <br>if (FAILED(hr)) <br>{ <br>LocalFree( lpData ); <br>lpData = NULL; <br>} <br>} <br>else <br>{ <br>hr = DPERR_OUTOFMEMORY; <br>} <br>} <br> <br> <br>*lplpn = (LPDPNAME) lpData; <br> <br>return hr; <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>HTREEITEM CGroupTree::FindItem( HTREEITEM htiSearchRoot,  <br>DPID dpidTarget,  <br>BRANCH_TYPE bt,  <br>DWORD dwSearch ) <br>{ <br>    TV_ITEM tvi; <br>HTREEITEMhItem, <br>htiSubSearch; <br>LPBRANCHSTRUCT lpbs = NULL; <br> <br>    if(TVI_ROOT == htiSearchRoot) <br>    { <br>        hItem = TreeView_GetRoot(m_hwndTreeView); <br>    } <br>else <br>{ <br>hItem = TreeView_GetChild( m_hwndTreeView, htiSearchRoot ); <br>} <br> <br>    while(hItem) <br>    { <br>        ZeroMemory( &amp;tvi, sizeof(TV_ITEM)); <br>         <br>        tvi.mask            = TVIF_PARAM; <br>        tvi.hItem           = hItem; <br> <br>        TreeView_GetItem(m_hwndTreeView, &amp;tvi); <br>lpbs = (LPBRANCHSTRUCT) tvi.lParam; <br> <br>        if ( (lpbs-&gt;dpid == dpidTarget) &amp;&amp; ( bt == lpbs-&gt;btType)) <br>        { <br>return tvi.hItem; <br>        } <br> <br>        if ( (lpbs-&gt;btType == BT_GROUP) &amp;&amp; (ST_SEARCH_SUBGROUPS &amp; dwSearch) ) <br>{ <br>htiSubSearch = FindItem( hItem, dpidTarget, bt, dwSearch ); <br>if (htiSubSearch) <br>return (htiSubSearch); <br>} <br> <br>hItem = TreeView_GetNextSibling(m_hwndTreeView, hItem); <br>    } <br> <br>    return NULL; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>HTREEITEM CGroupTree::Insert( HTREEITEM htiParent, DPID dpID, LPSTR lpszShortNameA, BRANCH_TYPE bt, DWORD dwFlags ) <br>{ <br>    LPBRANCHSTRUCTlpbs= NULL; <br>HTREEITEMhtrItem= NULL; <br> <br>if ( lpbs = (LPBRANCHSTRUCT) LocalAlloc( LPTR,  sizeof(BRANCHSTRUCT) ) ) <br>{ <br>TV_INSERTSTRUCTtvi; <br>TV_SORTCBtvscb;  <br> <br>ZeroMemory(lpbs, sizeof( BRANCHSTRUCT ) ); <br>ZeroMemory(&amp;tvscb, sizeof(tvscb)); <br>ZeroMemory(&amp;tvi, sizeof(tvi)); <br>tvi.hParent= htiParent; <br>tvi.hInsertAfter= TVI_LAST; <br> <br>tvi.item.mask= TVIF_IMAGE | TVIF_PARAM | TVIF_SELECTEDIMAGE | TVIF_TEXT; <br>tvi.item.pszText= lpszShortNameA; <br>tvi.item.cchTextMax= strlen(lpszShortNameA)+1; <br> <br>switch( bt) <br>{ <br>case BT_PLAYER: <br>case BT_PLAYER_IN_GROUP: <br>tvi.item.iImage = (DPPLAYER_SPECTATOR &amp; dwFlags) ?  m_nSpectatorImg: m_nPlayerImg; <br>tvi.item.iSelectedImage= tvi.item.iImage; <br>break; <br> <br>case BT_GROUP: <br>if (DPGROUP_STAGINGAREA &amp; dwFlags) <br>{ <br>HRESULT hr; <br>LPDPLCONNECTION lp = NULL; <br>DWORDdwSize = 0; <br>BOOLbSessionInProgress = FALSE; <br> <br>// if it is a staging area, check to see if the session is in progress. <br>hr = IDirectPlay3_GetGroupConnectionSettings( m_lpDP3A, 0, dpID, NULL, &amp;dwSize ); <br>if (DPERR_BUFFERTOOSMALL == hr ) <br>{ <br>lp = (LPDPLCONNECTION) GlobalAllocPtr( GHND, dwSize ); <br> <br>if (lp) <br>{ <br>hr = IDirectPlay3_GetGroupConnectionSettings( m_lpDP3A, 0, dpID, lp, &amp;dwSize ); <br> <br>if (!IsEqualGUID(lp-&gt;lpSessionDesc-&gt;guidInstance, GUID_NULL)) <br>{ <br>// If the server has assigned an instance guid  <br>// to our connection structure, the session  <br>// has already started. <br> <br>bSessionInProgress = TRUE; <br>} <br>GlobalFreePtr(lp); <br>} <br>} <br> <br> <br>tvi.item.iImage = (bSessionInProgress)?m_nSessionInProgressImg:m_nStagingAreaImg; <br>tvi.item.iSelectedImage = tvi.item.iImage; <br>} <br>else <br>{ <br>tvi.item.iImage = m_nGroupImg; <br>tvi.item.iSelectedImage = m_nInGroupImg; <br>} <br>break; <br> <br>case BT_SHORTCUT_IN_GROUP: <br>tvi.item.iImage = m_nShortcutInGroupImg; <br>tvi.item.iSelectedImage= tvi.item.iImage; <br>break; <br> <br>default: <br>//Invalid BranchType <br>break; <br>} <br>tvi.item.lParam= (LPARAM) lpbs; <br> <br>lpbs-&gt;dpid= dpID; <br>lpbs-&gt;btType= bt; <br>lpbs-&gt;dwFlags= dwFlags; <br> <br>htrItem = TreeView_InsertItem( m_hwndTreeView, &amp;tvi ); <br> <br>tvscb.hParent = htiParent;  <br>tvscb.lpfnCompare = CompareFunc;  <br>tvscb.lParam = (LPARAM) this;  <br> <br>TreeView_SortChildrenCB( m_hwndTreeView, &amp;tvscb, 0 ); <br> <br>if(TVI_ROOT != htiParent) <br>{ <br>TreeView_Expand(m_hwndTreeView, htiParent, TVE_EXPAND); <br>} <br> <br>Redraw(); <br>} <br> <br>return htrItem; <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>HRESULT CGroupTree::CreatePlayer( DPID dpidPlayer, LPSTR lpszShortNameA, DWORD dwFlags ) <br>{ <br>/* <br>// We currently support only one local player. This section of code would create a <br>// new player at the root for each create player message received. <br> <br>LPDPNAME lpn = NULL; <br> <br>if (NULL == lpszShortNameA) <br>{ <br>GetPlayerName(dpidPlayer, &amp;lpn ); <br>lpszShortNameA = lpn-&gt;lpszShortNameA; <br>} <br> <br>if (lpszShortNameA) <br>{ <br>Insert( TVI_ROOT, dpidPlayer, lpszShortNameA, BT_PLAYER, dwFlags ); <br>} <br> <br>if (lpn) <br>LocalFree(lpn); <br>*/ <br> <br>return DP_OK; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>HRESULT CGroupTree::CreateGroup( DPID dpidGroup, LPSTR lpszShortNameA, DWORD dwFlags  ) <br>{ <br>LPDPNAME lpn = NULL; <br> <br>if (NULL == lpszShortNameA) <br>{ <br>GetGroupName(dpidGroup, &amp;lpn ); <br>lpszShortNameA = lpn-&gt;lpszShortNameA; <br>} <br> <br>if (lpszShortNameA) <br>{ <br>Insert( TVI_ROOT, dpidGroup, lpszShortNameA, BT_GROUP, dwFlags ); <br>} <br> <br>if (lpn) <br>LocalFree(lpn); <br> <br> <br>return DP_OK; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>HRESULT CGroupTree::CreateGroupInGroup( DPID dpidParentGroup, DPID dpidChildGroup, LPSTR lpszShortNameA, DWORD dwFlags   ) <br>{ <br>HTREEITEM hParentItem = NULL; <br> <br>if ( hParentItem = FindItem( TVI_ROOT, dpidParentGroup, BT_GROUP, ST_SEARCH_SUBGROUPS ) ) <br>{ <br>LPDPNAME lpn = NULL; <br> <br>if (NULL == lpszShortNameA) <br>{ <br>GetGroupName(dpidChildGroup, &amp;lpn ); <br>lpszShortNameA = lpn-&gt;lpszShortNameA; <br>} <br> <br>if (lpszShortNameA) <br>{ <br>Insert( hParentItem, dpidChildGroup, lpszShortNameA, BT_GROUP, dwFlags ); <br>} <br> <br>if (lpn) <br>LocalFree(lpn); <br> <br> <br>} <br> <br>return DP_OK; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>HRESULT CGroupTree::AddPlayerToGroup( DPID dpidGroup, DPID dpidPlayer, DWORD dwFlags ) <br>{ <br>HRESULThr = DPERR_GENERIC; <br>LPDPNAME lpPlayerName = NULL; <br> <br>hr = GetPlayerName( dpidPlayer, &amp;lpPlayerName ); <br> <br>if (SUCCEEDED(hr)) <br>{ <br>HTREEITEM hParentItem = NULL; <br> <br>if ( hParentItem = FindItem( TVI_ROOT, dpidGroup, BT_GROUP, ST_SEARCH_SUBGROUPS ) ) <br>{ <br>Insert( hParentItem, dpidPlayer, lpPlayerName-&gt;lpszShortNameA, BT_PLAYER_IN_GROUP, dwFlags ); <br>} <br>} <br> <br>if (lpPlayerName) <br>LocalFree( lpPlayerName); <br> <br>return hr; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>HRESULT CGroupTree::AddGroupToGroup( DPID dpidParentGroup, DPID dpidShortcut, DWORD dwFlags ) <br>{ <br>HRESULThr = DPERR_GENERIC; <br>LPDPNAME lpGroupName = NULL; <br> <br>hr = GetGroupName( dpidShortcut, &amp;lpGroupName ); <br> <br>if (SUCCEEDED(hr)) <br>{ <br>HTREEITEM hParentItem = NULL; <br> <br>if ( hParentItem = FindItem( TVI_ROOT, dpidParentGroup, BT_GROUP, ST_SEARCH_SUBGROUPS ) ) <br>{ <br>Insert( hParentItem, dpidShortcut, lpGroupName-&gt;lpszShortNameA, BT_SHORTCUT_IN_GROUP, dwFlags ); <br>} <br>} <br> <br>if (lpGroupName) <br>LocalFree( lpGroupName); <br> <br>return hr; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>HRESULT CGroupTree::DestroyPlayer(DPID dpidPlayer) <br>{ <br>    /* <br> <br>// We are not currently adding additional players to the tree view. The  <br>// Code below would add a player to the root of the tree control. If you <br>// want that functionality. <br> <br>HTREEITEMhtiPlayer = FindItem( TVI_ROOT, dpidPlayer, BT_PLAYER, ST_NO_SUBGROUPS ); <br> <br>if ( htiPlayer ) <br>    { <br>TreeView_DeleteItem(m_hwndTreeView, htiPlayer); <br>Redraw(); <br>    } <br>*/ <br> <br>return DP_OK; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>HRESULT CGroupTree::DestroyGroup(DPID dpidGroup) <br>{ <br>    HTREEITEMhtiGroup = FindItem( TVI_ROOT, dpidGroup, BT_GROUP, ST_SEARCH_SUBGROUPS ); <br> <br>if ( htiGroup ) <br>    { <br>TreeView_DeleteItem(m_hwndTreeView, htiGroup); <br>Redraw(); <br>} <br> <br>return DP_OK; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>HRESULT CGroupTree::DeletePlayerFromGroup( DPID dpidGroup, DPID dpidPlayer ) <br>{ <br>HRESULThr = DPERR_GENERIC; <br>HTREEITEMhtiParent = NULL, <br>htiPlayer = NULL; <br> <br>if ( htiParent = FindItem( TVI_ROOT, dpidGroup, BT_GROUP, ST_SEARCH_SUBGROUPS ) ) <br>{ <br>if ( htiPlayer = FindItem( htiParent, dpidPlayer, BT_PLAYER_IN_GROUP, ST_NO_SUBGROUPS ) ) <br>{ <br>TreeView_DeleteItem(m_hwndTreeView, htiPlayer); <br>hr = DP_OK; <br> <br>Redraw(); <br>} <br>} <br> <br>return hr; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>HRESULT CGroupTree::DeleteGroupFromGroup( DPID dpidParentGroup, DPID dpidShortcut ) <br>{ <br>HRESULThr = DPERR_GENERIC; <br>HTREEITEMhtiParent = NULL, <br>htiShortcut = NULL; <br> <br>if ( htiParent = FindItem( TVI_ROOT, dpidParentGroup, BT_GROUP, ST_SEARCH_SUBGROUPS ) ) <br>{ <br>if ( htiShortcut = FindItem( htiParent, dpidShortcut, BT_SHORTCUT_IN_GROUP, ST_NO_SUBGROUPS ) ) <br>{ <br>TreeView_DeleteItem(m_hwndTreeView, htiShortcut ); <br>hr = DP_OK; <br> <br>Redraw(); <br>} <br>} <br>return hr; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>HRESULT CGroupTree::SetPlayerName( DPID dpidPlayer, LPSTR lpszShortName ) <br>{ <br>HRESULThr= DPERR_GENERIC; <br> <br>hr = RecursiveRename( TVI_ROOT, dpidPlayer, lpszShortName ); <br> <br>return hr;  <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>HRESULT CGroupTree::SetGroupName( DPID dpidPlayer, LPSTR lpszShortName ) <br>{ <br>HRESULThr= DPERR_GENERIC; <br> <br>hr = RecursiveRename( TVI_ROOT, dpidPlayer, lpszShortName ); <br> <br>return hr;  <br> <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>HRESULT CGroupTree::RecursiveRename(HTREEITEM htiSearchRoot,  <br>DPID dpidTarget,  <br>LPSTR lpszName ) <br>{ <br>    TV_ITEM tvi; <br>HTREEITEMhItem; <br>LPBRANCHSTRUCT lpbs = NULL; <br> <br>    if(TVI_ROOT == htiSearchRoot) <br>    { <br>        hItem = TreeView_GetRoot(m_hwndTreeView); <br>    } <br>else <br>{ <br>hItem = TreeView_GetChild( m_hwndTreeView, htiSearchRoot ); <br>} <br> <br>    while(hItem) <br>    { <br>        ZeroMemory( &amp;tvi, sizeof(TV_ITEM)); <br>         <br>        tvi.mask            = TVIF_PARAM; <br>        tvi.hItem           = hItem; <br> <br>        TreeView_GetItem(m_hwndTreeView, &amp;tvi); <br>lpbs = (LPBRANCHSTRUCT) tvi.lParam; <br> <br>        if (lpbs-&gt;dpid == dpidTarget) <br>        { <br>        ZeroMemory( &amp;tvi, sizeof(TV_ITEM)); <br> <br>            tvi.hItem = hItem; <br>tvi.mask = TVIF_TEXT; <br>tvi.pszText = lpszName; <br>tvi.cchTextMax = strlen(lpszName)+1; <br> <br>TreeView_SetItem( m_hwndTreeView, &amp;tvi ); <br>        } <br> <br>        if (lpbs-&gt;btType == BT_GROUP) <br>{ <br>RecursiveRename( hItem, dpidTarget, lpszName ); <br>} <br> <br>hItem = TreeView_GetNextSibling(m_hwndTreeView, hItem); <br>    } <br> <br>    return DP_OK; <br> <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>HRESULT CGroupTree::Refresh( BOOL bRecursive ) <br>{ <br>HRESULThr = DPERR_GENERIC; <br>ENUMTREESTRUCTets; <br> <br>ets.dpidParent = NULL; <br>ets.lpTree   = this; <br>ets.bRecursive = bRecursive; <br> <br>TreeView_DeleteAllItems( m_hwndTreeView ); <br> <br>if (m_lpDP3A) <br>{ <br> <br>//We don't see other root level players in the lobby world. <br> <br>//hr = m_lpDP3A-&gt;EnumPlayers( NULL, TV_EnumPlayersCallback, &amp;ets, DPENUMPLAYERS_ALL ); <br> <br>//if (SUCCEEDED( hr )) <br>//{ <br>hr = m_lpDP3A-&gt;EnumGroups( NULL, TV_EnumPlayersCallback, &amp;ets, DPENUMPLAYERS_ALL ); <br>//} <br>} <br> <br>return hr; <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>BOOL CGroupTree::Update(LPVOID lpvMsg) <br>{ <br> <br>DWORDdwMsgType= ((LPDPMSG_GENERIC)lpvMsg)-&gt;dwType; <br>LPSTRlpszShortName= NULL; <br>BOOLbReturn= TRUE; <br> <br>// Draws the tree based strictly on system messages. <br>// If you place a call to this method in the area where you process <br>// your system messages, it should give you a good representation <br>// of the DirectPlay group structure as it is created. <br> <br>    switch(dwMsgType) <br>    { <br>case DPSYS_CREATEPLAYERORGROUP: <br>{ <br>LPDPMSG_CREATEPLAYERORGROUP lp = (LPDPMSG_CREATEPLAYERORGROUP)lpvMsg; <br> <br>lpszShortName = lp-&gt;dpnName.lpszShortNameA; <br>if (DPPLAYERTYPE_PLAYER == lp-&gt;dwPlayerType) <br>{ <br>CreatePlayer(lp-&gt;dpId, lpszShortName, lp-&gt;dwFlags ); <br>} <br>else <br>{ <br>if (NULL == lp-&gt;dpIdParent) <br>{ <br>CreateGroup(lp-&gt;dpId, lpszShortName, lp-&gt;dwFlags ); <br>} <br>else <br>{ <br>CreateGroupInGroup(lp-&gt;dpIdParent, lp-&gt;dpId, lpszShortName, lp-&gt;dwFlags ); <br>} <br> <br>} <br>        } <br>break; <br> <br>        case DPSYS_ADDPLAYERTOGROUP: <br>{ <br>LPDPMSG_ADDPLAYERTOGROUP lp = (LPDPMSG_ADDPLAYERTOGROUP)lpvMsg; <br>DWORDdwFlags; <br>HRESULT hr = IDirectPlay3_GetPlayerFlags( m_lpDP3A, lp-&gt;dpIdPlayer, &amp;dwFlags ); <br> <br>if (SUCCEEDED(hr)) <br>{ <br>// If I can't get his flags, he must have deleted himself <br>// by the time I got this message. <br>AddPlayerToGroup(lp-&gt;dpIdGroup, lp-&gt;dpIdPlayer,dwFlags ); <br>} <br> <br>} <br>break; <br> <br>        case DPSYS_ADDGROUPTOGROUP: <br>{ <br>LPDPMSG_ADDGROUPTOGROUP lp = (LPDPMSG_ADDGROUPTOGROUP)lpvMsg; <br>DWORDdwFlags; <br>HRESULT hr = IDirectPlay3_GetGroupFlags( m_lpDP3A, lp-&gt;dpIdGroup, &amp;dwFlags ); <br> <br>if (SUCCEEDED(hr)) <br>{ <br>// If I can't get his flags, he must have deleted himself <br>// by the time I got this message. <br>AddGroupToGroup(lp-&gt;dpIdParentGroup, lp-&gt;dpIdGroup, dwFlags ); <br>} <br>} <br>break; <br> <br>        case DPSYS_DESTROYPLAYERORGROUP: <br>{ <br>LPDPMSG_DESTROYPLAYERORGROUP lp = (LPDPMSG_DESTROYPLAYERORGROUP) lpvMsg; <br> <br>if ( DPPLAYERTYPE_PLAYER == lp-&gt;dwPlayerType ) <br>{ <br>DestroyPlayer( lp-&gt;dpId ); <br>} <br>else <br>{ <br>DestroyGroup( lp-&gt;dpId ); <br>} <br>    <br>        } <br>break; <br> <br>        case DPSYS_DELETEGROUPFROMGROUP: <br>{ <br>LPDPMSG_DELETEGROUPFROMGROUP lp =(LPDPMSG_DELETEGROUPFROMGROUP)lpvMsg; <br> <br>DeleteGroupFromGroup( lp-&gt;dpIdParentGroup, lp-&gt;dpIdGroup ); <br>} <br>        break; <br> <br>        case DPSYS_DELETEPLAYERFROMGROUP: <br>{ <br>LPDPMSG_DELETEPLAYERFROMGROUP lp =(LPDPMSG_DELETEPLAYERFROMGROUP)lpvMsg; <br> <br>DeletePlayerFromGroup( lp-&gt;dpIdGroup, lp-&gt;dpIdPlayer ); <br>} <br>        break; <br> <br>        case DPSYS_SETPLAYERORGROUPDATA: <br>//Nothing for right now. <br>break; <br> <br>        case DPSYS_SETPLAYERORGROUPNAME: <br>{ <br>LPDPMSG_SETPLAYERORGROUPNAME lp = (LPDPMSG_SETPLAYERORGROUPNAME)lpvMsg; <br> <br>    lpszShortName = lp-&gt;dpnName.lpszShortNameA; <br> <br>if ( DPPLAYERTYPE_PLAYER == lp-&gt;dwPlayerType ) <br>{ <br>SetPlayerName(lp-&gt;dpId, lpszShortName ); <br>} <br>else <br>{ <br>SetGroupName(lp-&gt;dpId, lpszShortName ); <br>} <br> <br>} <br>        break; <br> <br>default: <br>//Code a new message... <br>bReturn = FALSE; <br>break; <br>    } <br> <br>    return bReturn; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>DPID CGroupTree::GetDPIDOfCurrentSelection( LPBRANCHSTRUCT lpbt) <br>{ <br> <br>HTREEITEMhtItem; <br>TV_ITEMtvi; <br> <br>ZeroMemory( &amp;tvi, sizeof( TV_ITEM ) ); <br> <br>htItem = TreeView_GetSelection(m_hwndTreeView); <br> <br>if (htItem) <br>{ <br> <br>tvi.mask            = TVIF_PARAM; <br>tvi.hItem           = htItem; <br> <br>TreeView_GetItem(m_hwndTreeView, &amp;tvi); <br> <br>if (lpbt) <br>{ <br>lpbt-&gt;dpid = ((LPBRANCHSTRUCT)(tvi.lParam))-&gt;dpid; <br>lpbt-&gt;btType = ((LPBRANCHSTRUCT)(tvi.lParam))-&gt;btType; <br>} <br> <br>return ((LPBRANCHSTRUCT) (tvi.lParam))-&gt;dpid; <br>} <br> <br>return 0; <br> <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>DPID CGroupTree::GetDPIDOfCurrentSelectionParent( LPBRANCHSTRUCT lpbt) <br>{ <br> <br>HTREEITEMhtChildItem, htItem; <br>TV_ITEMtvi; <br> <br>ZeroMemory( &amp;tvi, sizeof( TV_ITEM ) ); <br> <br>htChildItem = TreeView_GetSelection(m_hwndTreeView); <br> <br>htItem = TreeView_GetParent( m_hwndTreeView, htChildItem ); <br> <br>if (htItem) <br>{ <br> <br>tvi.mask            = TVIF_PARAM; <br>tvi.hItem           = htItem; <br> <br>TreeView_GetItem(m_hwndTreeView, &amp;tvi); <br> <br>if (lpbt) <br>{ <br>lpbt-&gt;dpid = ((LPBRANCHSTRUCT)(tvi.lParam))-&gt;dpid; <br>lpbt-&gt;btType = ((LPBRANCHSTRUCT)(tvi.lParam))-&gt;btType; <br>} <br> <br>return ((LPBRANCHSTRUCT) (tvi.lParam))-&gt;dpid; <br>} <br> <br>return 0; <br> <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>void CGroupTree::OnBeginDrag(NM_TREEVIEW *lpnmtv)  <br>{  <br>    HIMAGELIST himl;    // handle of image list  <br>LPBRANCHSTRUCTlp = NULL; <br>int level = 0; <br>UINTxIndent = 0; <br>HTREEITEM htItem = NULL; <br> <br> lp = (LPBRANCHSTRUCT)lpnmtv-&gt;itemNew.lParam; <br>m_bsDragging = *((LPBRANCHSTRUCT)(lpnmtv-&gt;itemNew.lParam)); <br>GetBranchStructOfParent( lpnmtv-&gt;itemNew.hItem, &amp;m_bsParentOfDragging ); <br> <br>   // Tell the tree-view control to create an image to use  <br>    // for dragging.  <br>    himl = TreeView_CreateDragImage(m_hwndTreeView, lpnmtv-&gt;itemNew.hItem);  <br>  <br>    // Start the drag operation.  <br>RECT rcItem; <br> <br>TreeView_GetItemRect(m_hwndTreeView, lpnmtv-&gt;itemNew.hItem, &amp;rcItem, FALSE); <br> <br>htItem = lpnmtv-&gt;itemNew.hItem; <br> <br>do <br>{ <br>htItem = TreeView_GetParent( m_hwndTreeView, htItem ); <br>level++; <br>} <br>while (htItem);  <br> <br>xIndent = TreeView_GetIndent( m_hwndTreeView ) * level; <br> <br>    BOOL b = ImageList_BeginDrag(himl, 0,  <br>lpnmtv-&gt;ptDrag.x-rcItem.left - xIndent,  <br>lpnmtv-&gt;ptDrag.y-rcItem.top);  <br>   <br>// Hide the mouse cursor, and direct mouse input to the  <br>    // parent window.  <br> <br>    ShowCursor( FALSE ); <br>SetCapture(m_hwndParent);  <br>    m_fDragging = TRUE; <br> <br>ImageList_DragEnter( m_hwndTreeView,  <br>lpnmtv-&gt;ptDrag.x-rcItem.left - xIndent,  <br>lpnmtv-&gt;ptDrag.y); <br>    return;  <br>}  <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>void CGroupTree::OnMouseMove( LONG xCur, LONG yCur)  <br>{  <br>    HTREEITEM htiTarget;  // handle of target item  <br>    TV_HITTESTINFO tvht;  // hit test information  <br>  <br>TV_ITEMtvi; <br> <br>ZeroMemory(&amp;tvi, sizeof(TV_ITEM ) ); <br> <br>    if (m_fDragging)  <br>{  <br>  <br>        // Drag the item to the current position of the mouse cursor.  <br>RECT rcTree, rcParent; <br> <br>GetWindowRect( m_hwndParent, &amp;rcParent ); <br>GetWindowRect( m_hwndTreeView, &amp;rcTree ); <br>ImageList_DragMove(xCur, yCur);  <br>  <br>        // Find out if the cursor is on the item. If it is, highlight  <br>        // the item as a drop target.  <br>        tvht.pt.x = xCur;  <br>        tvht.pt.y = yCur;  <br>        if ((htiTarget = TreeView_HitTest(m_hwndTreeView, &amp;tvht)) != NULL)  <br>{  <br>  ImageList_DragLeave( m_hwndTreeView ); <br>TreeView_SelectDropTarget(m_hwndTreeView, htiTarget); <br>ImageList_DragEnter( m_hwndTreeView, xCur, yCur); <br> <br>tvi.mask            = TVIF_PARAM; <br>tvi.hItem           = htiTarget; <br> <br>TreeView_GetItem(m_hwndTreeView, &amp;tvi); <br> <br>  memcpy( &amp;m_bsDropTarget, (LPBRANCHSTRUCT)(tvi.lParam), sizeof(BRANCHSTRUCT) ); <br> <br>} <br>else <br>{ <br>ZeroMemory( &amp;m_bsDropTarget, sizeof(BRANCHSTRUCT) ); <br>} <br>    }  <br>    return;  <br>}  <br>  <br>/////////////////////////////////////////////////////////////////////////////////////// <br>void CGroupTree::OnLButtonUp(void)  <br>{  <br>    if (m_fDragging)  <br>{  <br>        ImageList_EndDrag();  <br>        ReleaseCapture();  <br>    ShowCursor( TRUE ); <br>        m_fDragging = FALSE; <br>  ImageList_DragLeave( m_hwndTreeView ); <br> <br>if (m_bsDropTarget.dpid) <br>{ <br>switch (m_bsDragging.btType ) <br>{ <br>case BT_PLAYER: <br>m_lpDP3A-&gt;AddPlayerToGroup(m_bsDropTarget.dpid, m_bsDragging.dpid );  <br>break; <br> <br>case BT_GROUP: <br>m_lpDP3A-&gt;AddGroupToGroup(m_bsDropTarget.dpid, m_bsDragging.dpid ); <br>break; <br> <br>case BT_PLAYER_IN_GROUP: <br>if (m_bsDropTarget.dpid != m_bsParentOfDragging.dpid) <br>{ <br>m_lpDP3A-&gt;AddPlayerToGroup(m_bsDropTarget.dpid, m_bsDragging.dpid ); <br>m_lpDP3A-&gt;DeletePlayerFromGroup(m_bsParentOfDragging.dpid, m_bsDragging.dpid );  <br>} <br>break; <br> <br>case BT_SHORTCUT_IN_GROUP: <br>if (m_bsDropTarget.dpid != m_bsParentOfDragging.dpid) <br>{ <br>m_lpDP3A-&gt;AddGroupToGroup(m_bsDropTarget.dpid, m_bsDragging.dpid );  <br>m_lpDP3A-&gt;DeleteGroupFromGroup(m_bsParentOfDragging.dpid, m_bsDragging.dpid );  <br>} <br>break; <br>} <br>} <br> <br>TreeView_SelectDropTarget( m_hwndTreeView, (HTREEITEM) NULL ); <br>    }  <br>    return;  <br>}  <br> <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>void CGroupTree::Redraw(void)  <br>{ <br>RECT r; <br> <br>GetWindowRect(m_hwndTreeView, &amp;r ); <br>InvalidateRect(m_hwndTreeView, &amp;r, TRUE); <br>UpdateWindow(m_hwndParent); <br> <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// </code></pre>
<p>
</p>
<pre><code>void CGroupTree::OnRButtonDown( LONG xCur, LONG yCur)  <br>{  <br>    HTREEITEM htiTarget;  // handle of target item  <br>    TV_HITTESTINFO tvht;  // hit test information  <br>LPBRANCHSTRUCT lpbs = NULL; <br>HMENU hMenu = NULL; <br>  <br>TV_ITEMtvi; <br> <br>ZeroMemory(&amp;tvi, sizeof(TV_ITEM ) ); <br>RECT rc; <br> <br>GetWindowRect( m_hwndTreeView, &amp;rc ); <br> <br>    // Find out if the cursor is on the item. If it is, highlight  <br>    // the item as a drop target.  <br>    tvht.pt.x = xCur - rc.left;  <br>    tvht.pt.y = yCur - rc.top;  <br>    if ((htiTarget = TreeView_HitTest(m_hwndTreeView, &amp;tvht)) != NULL)  <br>{  <br>TreeView_SelectItem(m_hwndTreeView, htiTarget); <br> <br>tvi.mask            = TVIF_PARAM; <br>tvi.hItem           = htiTarget; <br> <br>TreeView_GetItem(m_hwndTreeView, &amp;tvi); <br> <br>if (lpbs = (LPBRANCHSTRUCT)tvi.lParam) <br>{ <br>m_dpidMenuTarget = lpbs-&gt;dpid; <br> <br>switch (lpbs-&gt;btType) <br>{ <br>case BT_GROUP: <br>hMenu = m_hGroupMenu; <br>EnableMenuItem(hMenu,ID_GROUP_STARTSESSION, <br>(DPGROUP_STAGINGAREA &amp; lpbs-&gt;dwFlags)?MF_ENABLED:MF_GRAYED );  <br>EnableMenuItem(hMenu,ID_GROUP_CONNECTIONSETTINGS, <br>(DPGROUP_STAGINGAREA &amp; lpbs-&gt;dwFlags)?MF_ENABLED:MF_GRAYED );  <br>break; <br> <br>case BT_PLAYER: <br>hMenu = m_hPlayerMenu; <br>break; <br> <br>case BT_SHORTCUT_IN_GROUP: <br>hMenu = m_hShortcutMenu; <br>break; <br> <br>case BT_PLAYER_IN_GROUP: <br>hMenu = m_hPlayerInGroupMenu; <br>break; <br> <br>default: <br>hMenu = m_hRootMenu; <br>break; <br>} <br>} <br>} <br>else <br>{ <br>hMenu = m_hRootMenu; <br>} <br> <br>TrackPopupMenuEx(hMenu, <br>TPM_LEFTALIGN|TPM_LEFTBUTTON|TPM_RIGHTBUTTON,  <br>xCur, yCur, m_hwndParent, NULL ); <br>}  <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>void CGroupTree::OnDblClk( LONG xCur, LONG yCur)  <br>{  <br>    HTREEITEM htiTarget;  // handle of target item  <br>    TV_HITTESTINFO tvht;  // hit test information  <br>LPBRANCHSTRUCT lpbs = NULL; <br>HMENU hMenu = NULL; <br>  <br>TV_ITEMtvi; <br> <br>ZeroMemory(&amp;tvi, sizeof(TV_ITEM ) ); <br>RECT rc; <br> <br>GetWindowRect( m_hwndTreeView, &amp;rc ); <br> <br>    // Find out if the cursor is on the item. If it is, highlight  <br>    // the item as a drop target.  <br>    tvht.pt.x = xCur - rc.left;  <br>    tvht.pt.y = yCur - rc.top;  <br>    if ((htiTarget = TreeView_HitTest(m_hwndTreeView, &amp;tvht)) != NULL)  <br>{  <br>TreeView_SelectItem(m_hwndTreeView, htiTarget); <br> <br>tvi.mask            = TVIF_PARAM; <br>tvi.hItem           = htiTarget; <br> <br>TreeView_GetItem(m_hwndTreeView, &amp;tvi); <br> <br>if (lpbs = (LPBRANCHSTRUCT)tvi.lParam) <br>{ <br>m_dpidMenuTarget = lpbs-&gt;dpid; <br> <br>switch (lpbs-&gt;btType) <br>{ <br>case BT_SHORTCUT_IN_GROUP: <br>case BT_GROUP: <br>if (m_dpidLastGroup != lpbs-&gt;dpid) <br>{ <br>m_lpDP3A-&gt;AddPlayerToGroup(lpbs-&gt;dpid, m_dpidPlayer ); <br> <br>m_lpDP3A-&gt;DeletePlayerFromGroup(m_dpidLastGroup, m_dpidPlayer );  <br>m_dpidLastGroup = lpbs-&gt;dpid; <br>} <br>break; <br> <br>default: <br>break; <br>} <br>} <br>} <br>}  <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>HRESULT CGroupTree::BeginLabelEdit()  <br>{ <br>// Workaround for Windows tree control/dialog odd behavior <br>// Retrieve the handle of the edit control.  <br>m_hwndEditCtrl = TreeView_GetEditControl( m_hwndTreeView );  <br> <br>// Subclass the edit control.  <br>gwpOrigEditProc = (WNDPROC) SetWindowLong(m_hwndEditCtrl, GWL_WNDPROC, (LONG) EditCtrlSubProc ); <br> <br>return DP_OK; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>void CGroupTree::EndLabelEdit( TV_DISPINFO FAR * lpTVDisp )  <br>{ <br>HRESULT hr; <br> <br>// Subclass the edit control.  <br>SetWindowLong(m_hwndEditCtrl, GWL_WNDPROC, (LONG) gwpOrigEditProc); <br> <br>if (lpTVDisp-&gt;item.pszText) <br>{ <br>LPBRANCHSTRUCT lpbs = (LPBRANCHSTRUCT) lpTVDisp-&gt;item.lParam; <br> <br>hr = CheckAccessRights(lpTVDisp); <br> <br>if (SUCCEEDED(hr)) <br>{ <br>DPNAME dpn; <br>dpn.dwSize = sizeof(DPNAME); <br>dpn.lpszShortNameA = lpTVDisp-&gt;item.pszText; <br>dpn.lpszLongNameA = lpTVDisp-&gt;item.pszText; <br> <br>switch (lpbs-&gt;btType) <br>{ <br>case  BT_GROUP: <br>m_lpDP3A-&gt;SetGroupName(lpbs-&gt;dpid, &amp;dpn, DPSET_REMOTE ); <br>break; <br> <br>case BT_PLAYER_IN_GROUP: <br>case BT_PLAYER: <br>m_lpDP3A-&gt;SetPlayerName(lpbs-&gt;dpid, &amp;dpn,  DPSET_REMOTE ); <br>break; <br>} <br>} <br>else <br>{ <br>MessageBox( m_hwndParent, "Cannot change the name of remote players or groups", "Error", MB_OK); <br>return; <br>} <br>} <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>DPID CGroupTree::GetBranchStructOfParent( HTREEITEM htChildItem, LPBRANCHSTRUCT lpbt) <br>{ <br> <br>HTREEITEMhtItem; <br>TV_ITEMtvi; <br> <br>ZeroMemory( &amp;tvi, sizeof( TV_ITEM ) ); <br>ZeroMemory( lpbt, sizeof( BRANCHSTRUCT ) ); <br> <br>htItem = TreeView_GetParent( m_hwndTreeView, htChildItem ); <br> <br>if (htItem) <br>{ <br> <br>tvi.mask            = TVIF_PARAM; <br>tvi.hItem           = htItem; <br> <br>TreeView_GetItem(m_hwndTreeView, &amp;tvi); <br> <br>if (lpbt) <br>{ <br>*lpbt = *((LPBRANCHSTRUCT)(tvi.lParam)); <br>} <br> <br>return ((LPBRANCHSTRUCT) (tvi.lParam))-&gt;dpid; <br>} <br> <br>return 0; <br> <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////////////// <br>BOOL CGroupTree::OnWM_NOTIFY( WPARAM wParam, LPARAM lParam ) <br>{ <br>int idCtrl = (int) wParam; <br>LPNMHDR pnmh = (LPNMHDR)lParam; <br>if (NULL == pnmh) <br>return FALSE; <br>  NM_TREEVIEW*nmtv; <br>TV_ITEM*pItemNew = NULL; <br>TV_ITEM*pItemOld = NULL; <br>LPBRANCHSTRUCTlpBranch = NULL; <br>HRESULT hr; <br> <br>switch(pnmh-&gt;code) <br>{ <br>case NM_RCLICK: <br>{ <br>POINT p; <br>GetCursorPos(&amp;p); <br>OnRButtonDown(p.x, p.y ); <br>} <br>break; <br> <br>case NM_DBLCLK: <br>{ <br>POINT p; <br>GetCursorPos(&amp;p); <br>OnDblClk(p.x, p.y ); <br>} <br>break; <br> <br>case TVN_BEGINLABELEDIT: <br>hr = BeginLabelEdit(); <br> <br>if (FAILED(hr)) <br>return TRUE; <br>break; <br> <br>case TVN_ENDLABELEDIT: <br>EndLabelEdit((TV_DISPINFO FAR *) lParam); <br>break; <br> <br>case TVN_SELCHANGING: <br>break; <br> <br>case TVN_DELETEITEM: <br>nmtv= (NM_TREEVIEW *)lParam; <br>pItemOld= &amp;nmtv-&gt;itemOld; <br>LocalFree( (LPVOID) pItemOld-&gt;lParam ); <br>break; <br> <br>case TVN_BEGINDRAG:  <br>OnBeginDrag((NM_TREEVIEW *) lParam);  <br>break;  <br> <br>} <br> <br>return 0; <br>} <br> <br>HRESULTCGroupTree::EditLabel() <br>{ <br>HRESULT hr; // Initialized by call to CheckAccessRights() <br>HTREEITEMhtItem; <br>TV_ITEMtvi; <br> <br>ZeroMemory( &amp;tvi, sizeof( TV_ITEM ) ); <br> <br>htItem = TreeView_GetSelection(m_hwndTreeView); <br> <br>if (htItem) <br>{ <br>HWND hwnd = NULL; <br> <br>hwnd = TreeView_EditLabel( m_hwndTreeView, htItem ); <br>hr = (hwnd ? DP_OK : DPERR_ACCESSDENIED);  <br>} <br>else <br>{ <br>hr = DPERR_ACCESSDENIED; <br>} <br> <br>return hr; <br>} <br> <br> <br>HRESULT CGroupTree::CheckAccessRights(TV_DISPINFO FAR * lpTVDisp) <br>{ <br>HRESULT hr = DPERR_GENERIC; <br>DWORDdwFlags = 0; <br>BRANCHSTRUCT bsCurSel; <br> <br>if (NULL == lpTVDisp) <br>{ <br>GetDPIDOfCurrentSelection( &amp;bsCurSel ); <br>} <br>else <br>{ <br>bsCurSel = *((LPBRANCHSTRUCT) lpTVDisp-&gt;item.lParam); <br>} <br> <br>switch ( bsCurSel.btType ) <br>{ <br>case BT_PLAYER: <br>case BT_PLAYER_IN_GROUP: <br>hr = m_lpDP3A-&gt;GetPlayerFlags( bsCurSel.dpid, &amp;dwFlags ); <br>break; <br> <br>case BT_GROUP: <br>hr = m_lpDP3A-&gt;GetGroupFlags( bsCurSel.dpid, &amp;dwFlags ); <br>break; <br> <br>default: <br>break; <br>} <br> <br>if (FAILED(hr)) <br>return hr; <br> <br>if (dwFlags &amp; DPPLAYER_LOCAL ) <br>{ <br>hr = DP_OK; <br>} <br>else <br>{ <br>hr = DPERR_ACCESSDENIED; <br>} <br> <br>return hr; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
