<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DIEX3.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3027"></a>DIEX3.CPP</h2>
<pre><code>/************************************************************************** <br> <br>    DIEX3.CPP - DirectInput simple sample 3 <br> <br>    Demonstrates an application which receives keyboard data <br>    in non-exclusive mode via a game loop. <br> <br> **************************************************************************/ <br>/************************************************************************** <br> <br>    (C) Copyright 1997 Microsoft Corp.  All rights reserved. <br> <br>    You have a royalty-free right to use, modify, reproduce and <br>    distribute the Sample Files (and/or any modified version) in <br>    any way you find useful, provided that you agree that <br>    Microsoft has no warranty obligations or liability for any <br>    Sample Application Files which are modified. <br> <br> **************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;dinput.h&gt; <br> <br>#include "diex3.h" <br> <br>/**************************************************************************** <br> * <br> *      Global variables <br> * <br> ****************************************************************************/ <br> <br>char c_szClassName[] = "DIEX3"; <br> <br>HINSTANCE       g_hinst;                /* My instance handle */ <br>BOOL            g_fPaused = TRUE;       /* Should I be paused? */ <br> <br>/**************************************************************************** <br> * <br> *      DirectInput globals <br> * <br> ****************************************************************************/ <br> <br>LPDIRECTINPUT           g_pdi; <br>LPDIRECTINPUTDEVICE     g_pKeyboard; <br>char                    g_szText[1024]; /* What we display in client area */ <br> <br>/**************************************************************************** <br> * <br> *      Complain <br> * <br> *      Whine and moan. <br> * <br> ****************************************************************************/ <br> <br>void <br>Complain( <br>    HWND hwndOwner, <br>    HRESULT hr, <br>    LPCSTR pszMessage <br>) <br>{ <br>    MessageBox(hwndOwner, pszMessage, "DirectInput Sample", MB_OK); <br>} <br> <br>/**************************************************************************** <br> * <br> *      DIInit <br> * <br> *      Initialize the DirectInput variables. <br> * <br> *      This entails the following four functions: <br> * <br> *          DirectInputCreate <br> *          IDirectInput::CreateDevice <br> *          IDirectInputDevice::SetDataFormat <br> *          IDirectInputDevice::SetCooperativeLevel <br> * <br> ****************************************************************************/ <br> <br>BOOL <br>DIInit( <br>    HWND hwnd <br>) <br>{ <br>    HRESULT hr; <br> <br>    /* <br>     *  Register with the DirectInput subsystem and get a pointer <br>     *  to a IDirectInput interface we can use. <br>     * <br>     *  Parameters: <br>     * <br>     *      g_hinst <br>     * <br>     *          Instance handle to our application or DLL. <br>     * <br>     *      DIRECTINPUT_VERSION <br>     * <br>     *          The version of DirectInput we were designed for. <br>     *          We take the value from the &lt;dinput.h&gt; header file. <br>     * <br>     *      &amp;g_pdi <br>     * <br>     *          Receives pointer to the IDirectInput interface <br>     *          that was created. <br>     * <br>     *      NULL <br>     * <br>     *          We do not use OLE aggregation, so this parameter <br>     *          must be NULL. <br>     * <br>     */ <br>    hr = DirectInputCreate(g_hinst, DIRECTINPUT_VERSION, &amp;g_pdi, NULL); <br> <br>    if (FAILED(hr)) { <br>        Complain(hwnd, hr, "DirectInputCreate"); <br>        return FALSE; <br>    } <br> <br>    /* <br>     *  Obtain an interface to the system keyboard device. <br>     * <br>     *  Parameters: <br>     * <br>     *      GUID_SysKeyboard <br>     * <br>     *          The instance GUID for the device we wish to access. <br>     *          GUID_SysKeyboard is a predefined instance GUID that <br>     *          always refers to the system keyboard device. <br>     * <br>     *      &amp;g_pKeyboard <br>     * <br>     *          Receives pointer to the IDirectInputDevice interface <br>     *          that was created. <br>     * <br>     *      NULL <br>     * <br>     *          We do not use OLE aggregation, so this parameter <br>     *          must be NULL. <br>     * <br>     */ <br>    hr = g_pdi-&gt;CreateDevice(GUID_SysKeyboard, &amp;g_pKeyboard, NULL); <br> <br>    if (FAILED(hr)) { <br>        Complain(hwnd, hr, "CreateDevice"); <br>        return FALSE; <br>    } <br> <br>    /* <br>     *  Set the data format to "keyboard format". <br>     * <br>     *  A data format specifies which controls on a device we <br>     *  are interested in, and how they should be reported. <br>     * <br>     *  This tells DirectInput that we will be passing an array <br>     *  of 256 bytes to IDirectInputDevice::GetDeviceState. <br>     * <br>     *  Parameters: <br>     * <br>     *      c_dfDIKeyboard <br>     * <br>     *          Predefined data format which describes <br>     *          an array of 256 bytes, one per scancode. <br>     */ <br>    hr = g_pKeyboard-&gt;SetDataFormat(&amp;c_dfDIKeyboard); <br> <br>    if (FAILED(hr)) { <br>        Complain(hwnd, hr, "SetDataFormat"); <br>        return FALSE; <br>    } <br> <br> <br>    /* <br>     *  Set the cooperativity level to let DirectInput know how <br>     *  this device should interact with the system and with other <br>     *  DirectInput applications. <br>     * <br>     *  Parameters: <br>     * <br>     *      DISCL_NONEXCLUSIVE <br>     * <br>     *          Retrieve keyboard data when acquired, not interfering <br>     *          with any other applications which are reading keyboard <br>     *          data. <br>     * <br>     *      DISCL_FOREGROUND <br>     * <br>     *          If the user switches away from our application, <br>     *          automatically release the keyboard back to the system. <br>     * <br>     */ <br>    hr = g_pKeyboard-&gt;SetCooperativeLevel(hwnd, <br>                                       DISCL_NONEXCLUSIVE | DISCL_FOREGROUND); <br> <br>    if (FAILED(hr)) { <br>        Complain(hwnd, hr, "SetCooperativeLevel"); <br>        return FALSE; <br>    } <br> <br>    return TRUE; <br> <br>} <br> <br>/**************************************************************************** <br> * <br> *      DITerm <br> * <br> *      Terminate our usage of DirectInput. <br> * <br> ****************************************************************************/ <br> <br>void <br>DITerm(void) <br>{ <br> <br>    /* <br>     *  Destroy any lingering IDirectInputDevice object. <br>     */ <br>    if (g_pKeyboard) { <br> <br>        /* <br>         *  Cleanliness is next to godliness.  Unacquire the device <br>         *  one last time just in case we got really confused and tried <br>         *  to exit while the device is still acquired. <br>         */ <br>        g_pKeyboard-&gt;Unacquire(); <br> <br>        g_pKeyboard-&gt;Release(); <br>        g_pKeyboard = NULL; <br>    } <br> <br>    /* <br>     *  Destroy any lingering IDirectInput object. <br>     */ <br>    if (g_pdi) { <br>        g_pdi-&gt;Release(); <br>        g_pdi = NULL; <br>    } <br> <br>} <br> <br>/**************************************************************************** <br> * <br> *      Ex_OnPaint <br> * <br> *      Display the current keyboard state. <br> * <br> ****************************************************************************/ <br> <br>LRESULT <br>Ex_OnPaint( <br>    HWND hwnd <br>) <br>{ <br>    PAINTSTRUCT ps; <br>    HDC hdc = BeginPaint(hwnd, &amp;ps); <br> <br>    if (hdc) { <br> <br>        ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &amp;ps.rcPaint, g_szText, <br>                   lstrlen(g_szText), NULL); <br> <br>        EndPaint(hwnd, &amp;ps); <br>    } <br> <br>    return 0; <br>} <br> <br>/**************************************************************************** <br> * <br> *      Ex_OneFrame <br> * <br> *      The game plays here. <br> * <br> *      Our "game" consists entirely of reading keyboard data <br> *      and displaying it. <br> * <br> ****************************************************************************/ <br> <br>void <br>Ex_OneFrame(HWND hwnd) <br>{ <br> <br>    if (g_pKeyboard) { <br> <br>        BYTE diks[256];             /* DirectInput keyboard state buffer */ <br>        HRESULT hr; <br> <br>    again:; <br>        hr = g_pKeyboard-&gt;GetDeviceState(sizeof(diks), &amp;diks); <br>        if (hr == DIERR_INPUTLOST) { <br>            /* <br>             *  DirectInput is telling us that the input stream has <br>             *  been interrupted.  We aren't tracking any state <br>             *  between polls, so we don't have any special reset <br>             *  that needs to be done.  We just re-acquire and <br>             *  try again. <br>             */ <br>            hr = g_pKeyboard-&gt;Acquire(); <br>            if (SUCCEEDED(hr)) { <br>                goto again; <br>            } <br>        } <br> <br>        if (SUCCEEDED(hr)) { <br>            char szBuf[1024]; <br> <br>            /* <br>             *  Build the new status string. <br>             * <br>             *  Display the scan codes of the keys that are down. <br>             */ <br>            int i; <br>            char *psz = szBuf; <br>            for (i = 0; i &lt; 256; i++) { <br>                if (diks[i] &amp; 0x80) { <br>                    psz += wsprintf(psz, "%02x ", i); <br>                } <br>            } <br>            *psz = 0;                   /* Terminate the string */ <br> <br>            /* <br>             *  Trigger a repaint only if the status string changed. <br>             *  This avoids flicker. <br>             */ <br>            if (lstrcmp(g_szText, szBuf)) { <br>                lstrcpy(g_szText, szBuf); <br>                InvalidateRect(hwnd, NULL, TRUE); <br>            } <br>        } <br>    } <br> <br>    /* <br>     *  Sleep for a few milliseconds to simulate a 30fps frame rate. <br>     */ <br>    Sleep(1000 / 30); <br> <br>} <br> <br>/**************************************************************************** <br> * <br> *      Ex_SyncAcquire <br> * <br> *      Acquire or unacquire the keyboard, depending on the the g_fPaused <br> *      flag.  This synchronizes the device with our internal view of <br> *      the world. <br> * <br> ****************************************************************************/ <br> <br>void <br>Ex_SyncAcquire(HWND hwnd) <br>{ <br>    if (g_fPaused) { <br>        if (g_pKeyboard) g_pKeyboard-&gt;Unacquire(); <br>    } else { <br>        if (g_pKeyboard) g_pKeyboard-&gt;Acquire(); <br>    } <br>} <br> <br>/**************************************************************************** <br> * <br> *      Ex_WndProc <br> * <br> *      Window procedure for simple sample. <br> * <br> ****************************************************************************/ <br> <br>LRESULT CALLBACK <br>Ex_WndProc( <br>    HWND hwnd, <br>    UINT msg, <br>    WPARAM wParam, <br>    LPARAM lParam <br>) <br>{ <br> <br>    switch (msg) { <br> <br>    case WM_PAINT:      return Ex_OnPaint(hwnd); <br> <br>    /* <br>     *  WM_ACTIVATE <br>     * <br>     *      Windows sends this message when the window becomes <br>     *      the active window or stops being the active window. <br>     * <br>     *      wParam = WA_INACTIVE if window is no longer active <br>     * <br>     *      wParam = WA_ACTIVE or WA_CLICKACTIVE if window is now active <br>     * <br>     *      If we are losing activation, then pause. <br>     * <br>     *      If we are gaining activation, then unpause. <br>     * <br>     *      After deciding whether we are paused or unpaused, <br>     *      tell DirectInput that we don't (paused) or do (unpaused) <br>     *      want non-exclusive access to the keyboard. <br>     * <br>     */ <br>    case WM_ACTIVATE: <br>        g_fPaused = wParam == WA_INACTIVE; <br>        Ex_SyncAcquire(hwnd); <br>        break; <br> <br>    case WM_DESTROY: <br>        PostQuitMessage(0); <br>        break; <br> <br>    } <br> <br>    return DefWindowProc(hwnd, msg, wParam, lParam); <br>} <br> <br>/**************************************************************************** <br> * <br> *      AppInit <br> * <br> *      Set up everything the application needs to get started. <br> * <br> ****************************************************************************/ <br> <br>HWND <br>AppInit( <br>    HINSTANCE hinst, <br>    int nCmdShow <br>) <br>{ <br> <br>    /* <br>     *  Save instance handle for future reference. <br>     */ <br>    g_hinst = hinst; <br> <br>    /* <br>     *  Set up the window class. <br>     */ <br>    WNDCLASS wc; <br> <br>    wc.hCursor        = LoadCursor(0, IDC_ARROW); <br>    wc.hIcon          = LoadIcon(NULL, MAKEINTRESOURCE(IDI_APPLICATION)); <br>    wc.lpszMenuName   = NULL; <br>    wc.lpszClassName  = c_szClassName; <br>    wc.hbrBackground  = 0; <br>    wc.hInstance      = hinst; <br>    wc.style          = 0; <br>    wc.lpfnWndProc    = Ex_WndProc; <br>    wc.cbClsExtra     = 0; <br>    wc.cbWndExtra     = 0; <br> <br>    if (!RegisterClass(&amp;wc)) { <br>        return NULL; <br>    } <br> <br>    HWND hwnd = CreateWindow( <br>                    c_szClassName,                  // Class name <br>                    "DIEX3 - Alt+F4 to exit",       // Caption <br>                    WS_OVERLAPPEDWINDOW,            // Style <br>                    CW_USEDEFAULT, CW_USEDEFAULT,   // Position <br>                    CW_USEDEFAULT, CW_USEDEFAULT,   // Size <br>                    NULL,                           // No parent <br>                    NULL,                           // No menu <br>                    g_hinst,                        // inst handle <br>                    0                               // no params <br>                    ); <br> <br>    if (!DIInit(hwnd)) { <br>        DestroyWindow(hwnd); <br>        return NULL; <br>    } <br> <br>    ShowWindow(hwnd, nCmdShow); <br> <br>    return hwnd; <br>} <br> <br>/**************************************************************************** <br> * <br> *      WinMain <br> * <br> *      Application entry point. <br> * <br> ****************************************************************************/ <br> <br>int PASCAL <br>WinMain(HINSTANCE hinst, HINSTANCE hinstPrev, LPSTR szCmdLine, int nCmdShow) <br>{ <br>    MSG msg; <br>    msg.wParam = 0;         /* In case something goes horribly wrong */ <br> <br>    HWND hwnd = AppInit(hinst, nCmdShow); <br> <br>    if (hwnd) { <br> <br>        /* <br>         *  Standard game loop. <br>         */ <br>        for (;;) { <br>            if (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) { <br> <br>                /* If it's a quit message, we're outta here */ <br>                if (msg.message == WM_QUIT) { <br>                    break; <br>                } else { <br>                    TranslateMessage(&amp;msg); <br>                    DispatchMessage(&amp;msg); <br>                } <br>            } else if (g_fPaused) { <br>                WaitMessage(); <br>            } else { <br>                Ex_OneFrame(hwnd); <br>            } <br>        } <br>    } <br> <br>    DITerm(); <br> <br>    return msg.wParam; <br> <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
