<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DIEX4.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3029"></a>DIEX4.CPP</h2>
<pre><code>/************************************************************************** <br> <br>    DIEX4.CPP - DirectInput simple sample 4 <br> <br>    Demonstrates an application which retrieves buffered keyboard data <br>    in non-exclusive mode via a game loop. <br> <br> **************************************************************************/ <br>/************************************************************************** <br> <br>    (C) Copyright 1997 Microsoft Corp.  All rights reserved. <br> <br>    You have a royalty-free right to use, modify, reproduce and <br>    distribute the Sample Files (and/or any modified version) in <br>    any way you find useful, provided that you agree that <br>    Microsoft has no warranty obligations or liability for any <br>    Sample Application Files which are modified. <br> <br> **************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;dinput.h&gt; <br> <br>#include "diex4.h" <br> <br>/**************************************************************************** <br> * <br> *      Global Parameters <br> * <br> ****************************************************************************/ <br> <br>#define DINPUT_BUFFERSIZE       16      /* Number of buffer elements */ <br> <br>/**************************************************************************** <br> * <br> *      Global variables <br> * <br> ****************************************************************************/ <br> <br>char c_szClassName[] = "DIEX4"; <br> <br>HINSTANCE       g_hinst;                /* My instance handle */ <br>BOOL            g_fPaused = TRUE;       /* Should I be paused? */ <br> <br>/**************************************************************************** <br> * <br> *      DirectInput globals <br> * <br> ****************************************************************************/ <br> <br>LPDIRECTINPUT           g_pdi; <br>LPDIRECTINPUTDEVICE     g_pKeyboard; <br>char                    g_szText[1024]; /* What we display in client area */ <br> <br>/**************************************************************************** <br> * <br> *      Complain <br> * <br> *      Whine and moan. <br> * <br> ****************************************************************************/ <br> <br>void <br>Complain( <br>    HWND hwndOwner, <br>    HRESULT hr, <br>    LPCSTR pszMessage <br>) <br>{ <br>    MessageBox(hwndOwner, pszMessage, "DirectInput Sample", MB_OK); <br>} <br> <br>/**************************************************************************** <br> * <br> *      DIInit <br> * <br> *      Initialize the DirectInput variables. <br> * <br> *      This entails the following four functions: <br> * <br> *          DirectInputCreate <br> *          IDirectInput::CreateDevice <br> *          IDirectInputDevice::SetDataFormat <br> *          IDirectInputDevice::SetCooperativeLevel <br> * <br> *      Reading buffered data requires another function: <br> * <br> *          IDirectInputDevice::SetProperty(DIPROP_BUFFERSIZE) <br> * <br> ****************************************************************************/ <br> <br>BOOL <br>DIInit( <br>    HWND hwnd <br>) <br>{ <br>    HRESULT hr; <br> <br>    /* <br>     *  Register with the DirectInput subsystem and get a pointer <br>     *  to a IDirectInput interface we can use. <br>     * <br>     *  Parameters: <br>     * <br>     *      g_hinst <br>     * <br>     *          Instance handle to our application or DLL. <br>     * <br>     *      DIRECTINPUT_VERSION <br>     * <br>     *          The version of DirectInput we were designed for. <br>     *          We take the value from the &lt;dinput.h&gt; header file. <br>     * <br>     *      &amp;g_pdi <br>     * <br>     *          Receives pointer to the IDirectInput interface <br>     *          that was created. <br>     * <br>     *      NULL <br>     * <br>     *          We do not use OLE aggregation, so this parameter <br>     *          must be NULL. <br>     * <br>     */ <br>    hr = DirectInputCreate(g_hinst, DIRECTINPUT_VERSION, &amp;g_pdi, NULL); <br> <br>    if (FAILED(hr)) { <br>        Complain(hwnd, hr, "DirectInputCreate"); <br>        return FALSE; <br>    } <br> <br>    /* <br>     *  Obtain an interface to the system keyboard device. <br>     * <br>     *  Parameters: <br>     * <br>     *      GUID_SysKeyboard <br>     * <br>     *          The instance GUID for the device we wish to access. <br>     *          GUID_SysKeyboard is a predefined instance GUID that <br>     *          always refers to the system keyboard device. <br>     * <br>     *      &amp;g_pKeyboard <br>     * <br>     *          Receives pointer to the IDirectInputDevice interface <br>     *          that was created. <br>     * <br>     *      NULL <br>     * <br>     *          We do not use OLE aggregation, so this parameter <br>     *          must be NULL. <br>     * <br>     */ <br>    hr = g_pdi-&gt;CreateDevice(GUID_SysKeyboard, &amp;g_pKeyboard, NULL); <br> <br>    if (FAILED(hr)) { <br>        Complain(hwnd, hr, "CreateDevice"); <br>        return FALSE; <br>    } <br> <br>    /* <br>     *  Set the data format to "keyboard format". <br>     * <br>     *  A data format specifies which controls on a device we <br>     *  are interested in, and how they should be reported. <br>     * <br>     *  This tells DirectInput that we are interested in all keys <br>     *  on the device, and they should be reported as DirectInput <br>     *  DIK_* codes. <br>     * <br>     *  Parameters: <br>     * <br>     *      c_dfDIKeyboard <br>     * <br>     *          Predefined data format which describes <br>     *          an array of 256 bytes, one per scancode. <br>     */ <br>    hr = g_pKeyboard-&gt;SetDataFormat(&amp;c_dfDIKeyboard); <br> <br>    if (FAILED(hr)) { <br>        Complain(hwnd, hr, "SetDataFormat"); <br>        return FALSE; <br>    } <br> <br> <br>    /* <br>     *  Set the cooperativity level to let DirectInput know how <br>     *  this device should interact with the system and with other <br>     *  DirectInput applications. <br>     * <br>     *  Parameters: <br>     * <br>     *      DISCL_NONEXCLUSIVE <br>     * <br>     *          Retrieve keyboard data when acquired, not interfering <br>     *          with any other applications which are reading keyboard <br>     *          data. <br>     * <br>     *      DISCL_FOREGROUND <br>     * <br>     *          If the user switches away from our application, <br>     *          automatically release the keyboard back to the system. <br>     * <br>     */ <br>    hr = g_pKeyboard-&gt;SetCooperativeLevel(hwnd, <br>                                       DISCL_NONEXCLUSIVE | DISCL_FOREGROUND); <br> <br>    if (FAILED(hr)) { <br>        Complain(hwnd, hr, "SetCooperativeLevel"); <br>        return FALSE; <br>    } <br> <br>    /* <br>     *  IMPORTANT STEP IF YOU WANT TO USE BUFFERED DEVICE DATA! <br>     * <br>     *  DirectInput uses unbuffered I/O (buffer size = 0) by default. <br>     *  If you want to read buffered data, you need to set a nonzero <br>     *  buffer size. <br>     * <br>     *  Set the buffer size to DINPUT_BUFFERSIZE (defined above) elements. <br>     * <br>     *  The buffer size is a DWORD property associated with the device. <br>     */ <br>    DIPROPDWORD dipdw = <br>        { <br>            { <br>                sizeof(DIPROPDWORD),        // diph.dwSize <br>                sizeof(DIPROPHEADER),       // diph.dwHeaderSize <br>                0,                          // diph.dwObj <br>                DIPH_DEVICE,                // diph.dwHow <br>            }, <br>            DINPUT_BUFFERSIZE,              // dwData <br>        }; <br> <br>    hr = g_pKeyboard-&gt;SetProperty(DIPROP_BUFFERSIZE, &amp;dipdw.diph); <br> <br>    if (FAILED(hr)) { <br>        Complain(hwnd, hr, "Set buffer size"); <br>        return FALSE; <br>    } <br> <br>    return TRUE; <br> <br>} <br> <br>/**************************************************************************** <br> * <br> *      DITerm <br> * <br> *      Terminate our usage of DirectInput. <br> * <br> ****************************************************************************/ <br> <br>void <br>DITerm(void) <br>{ <br> <br>    /* <br>     *  Destroy any lingering IDirectInputDevice object. <br>     */ <br>    if (g_pKeyboard) { <br> <br>        /* <br>         *  Cleanliness is next to godliness.  Unacquire the device <br>         *  one last time just in case we got really confused and tried <br>         *  to exit while the device is still acquired. <br>         */ <br>        g_pKeyboard-&gt;Unacquire(); <br> <br>        g_pKeyboard-&gt;Release(); <br>        g_pKeyboard = NULL; <br>    } <br> <br>    /* <br>     *  Destroy any lingering IDirectInput object. <br>     */ <br>    if (g_pdi) { <br>        g_pdi-&gt;Release(); <br>        g_pdi = NULL; <br>    } <br> <br>} <br> <br>/**************************************************************************** <br> * <br> *      Ex_OnPaint <br> * <br> *      Display the current keyboard state. <br> * <br> ****************************************************************************/ <br> <br>LRESULT <br>Ex_OnPaint( <br>    HWND hwnd <br>) <br>{ <br>    PAINTSTRUCT ps; <br>    HDC hdc = BeginPaint(hwnd, &amp;ps); <br> <br>    if (hdc) { <br> <br>        ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &amp;ps.rcPaint, g_szText, <br>                   lstrlen(g_szText), NULL); <br> <br>        EndPaint(hwnd, &amp;ps); <br>    } <br> <br>    return 0; <br>} <br> <br>/**************************************************************************** <br> * <br> *      Ex_OneFrame <br> * <br> *      The game plays here. <br> * <br> *      Our "game" consists entirely of reading keyboard data <br> *      and displaying it. <br> * <br> ****************************************************************************/ <br> <br>void <br>Ex_OneFrame(HWND hwnd) <br>{ <br> <br>    if (g_pKeyboard) { <br> <br>        DIDEVICEOBJECTDATA rgod[DINPUT_BUFFERSIZE]; /* Receives buffered data */ <br>        DWORD cod; <br>        HRESULT hr; <br> <br>    again:; <br>        cod = DINPUT_BUFFERSIZE; <br>        hr = g_pKeyboard-&gt;GetDeviceData(sizeof(DIDEVICEOBJECTDATA), <br>                                        rgod, &amp;cod, 0); <br>        if (hr != DI_OK) { <br>            /* <br>             *  We got an error or we got DI_BUFFEROVERFLOW. <br>             * <br>             *  Either way, it means that continuous contact with the <br>             *  device has been lost, either due to an external <br>             *  interruption, or because the buffer overflowed <br>             *  and some events were lost. <br>             * <br>             *  Consequently, if a button was pressed at the time <br>             *  the buffer overflowed or the connection was broken, <br>             *  the corresponding "up" message might have been lost. <br>             * <br>             *  But since our simple sample doesn't actually have <br>             *  any state associated with button up or down events, <br>             *  there is no state to reset.  (In a real game, ignoring <br>             *  the buffer overflow would result in the game thinking <br>             *  a key was held down when in fact it isn't; it's just <br>             *  that the "up" event got lost because the buffer <br>             *  overflowed.) <br>             * <br>             *  If we want to be cleverer, we could do a <br>             *  GetDeviceState() and compare the current state <br>             *  against the state we think the device is in, <br>             *  and process all the states that are currently <br>             *  different from our private state. <br>             * <br>             */ <br> <br>            /* &lt;&lt; insert recovery code here if you need any &gt;&gt; */ <br> <br>            if (hr == DIERR_INPUTLOST) { <br>                hr = g_pKeyboard-&gt;Acquire(); <br>                if (SUCCEEDED(hr)) { <br>                    goto again; <br>                } <br>            } <br>        } <br> <br>        /* <br>         *  In order for it to be worth our while to parse the <br>         *  buffer elements, the GetDeviceData must have succeeded, <br>         *  and we must have received some data at all. <br>         */ <br>        if (SUCCEEDED(hr) &amp;&amp; cod &gt; 0) { <br>            char szBuf[1024]; <br>            DWORD iod; <br> <br>            /* <br>             *  Study each of the buffer elements and process them. <br>             * <br>             *  Since we really don't do anything, our "processing" <br>             *  consists merely of squirting the name into our <br>             *  local buffer. <br>             */ <br>            for (iod = 0; iod &lt; cod; iod++) { <br>                wsprintf(szBuf, "%02x was %s", <br>                         rgod[iod].dwOfs, <br>                         (rgod[iod].dwData &amp; 0x80) ? "pressed" : "released"); <br>            } <br> <br>            /* <br>             *  Trigger a repaint only if the status string changed. <br>             *  This avoids flicker. <br>             */ <br>            if (lstrcmp(g_szText, szBuf)) { <br>                lstrcpy(g_szText, szBuf); <br>                InvalidateRect(hwnd, NULL, TRUE); <br>            } <br>        } <br>    } <br> <br>    /* <br>     *  Sleep for a few milliseconds to simulate a 30fps frame rate. <br>     */ <br>    Sleep(1000 / 30); <br> <br>} <br> <br>/**************************************************************************** <br> * <br> *      Ex_SyncAcquire <br> * <br> *      Acquire or unacquire the keyboard, depending on the the g_fPaused <br> *      flag.  This synchronizes the device with our internal view of <br> *      the world. <br> * <br> ****************************************************************************/ <br> <br>void <br>Ex_SyncAcquire(HWND hwnd) <br>{ <br>    if (g_fPaused) { <br>        if (g_pKeyboard) g_pKeyboard-&gt;Unacquire(); <br>    } else { <br>        if (g_pKeyboard) g_pKeyboard-&gt;Acquire(); <br>    } <br>} <br> <br>/**************************************************************************** <br> * <br> *      Ex_WndProc <br> * <br> *      Window procedure for simple sample. <br> * <br> ****************************************************************************/ <br> <br>LRESULT CALLBACK <br>Ex_WndProc( <br>    HWND hwnd, <br>    UINT msg, <br>    WPARAM wParam, <br>    LPARAM lParam <br>) <br>{ <br> <br>    switch (msg) { <br> <br>    case WM_PAINT:      return Ex_OnPaint(hwnd); <br> <br>    /* <br>     *  WM_ACTIVATE <br>     * <br>     *      Windows sends this message when the window becomes <br>     *      the active window or stops being the active window. <br>     * <br>     *      wParam = WA_INACTIVE if window is no longer active <br>     * <br>     *      wParam = WA_ACTIVE or WA_CLICKACTIVE if window is now active <br>     * <br>     *      If we are losing activation, then pause. <br>     * <br>     *      If we are gaining activation, then unpause. <br>     * <br>     *      After deciding whether we are paused or unpaused, <br>     *      tell DirectInput that we don't (paused) or do (unpaused) <br>     *      want non-exclusive access to the keyboard. <br>     * <br>     */ <br>    case WM_ACTIVATE: <br>        g_fPaused = wParam == WA_INACTIVE; <br>        Ex_SyncAcquire(hwnd); <br>        break; <br> <br>    case WM_DESTROY: <br>        PostQuitMessage(0); <br>        break; <br> <br>    } <br> <br>    return DefWindowProc(hwnd, msg, wParam, lParam); <br>} <br> <br>/**************************************************************************** <br> * <br> *      AppInit <br> * <br> *      Set up everything the application needs to get started. <br> * <br> ****************************************************************************/ <br> <br>HWND <br>AppInit( <br>    HINSTANCE hinst, <br>    int nCmdShow <br>) <br>{ <br> <br>    /* <br>     *  Save instance handle for future reference. <br>     */ <br>    g_hinst = hinst; <br> <br>    /* <br>     *  Set up the window class. <br>     */ <br>    WNDCLASS wc; <br> <br>    wc.hCursor        = LoadCursor(0, IDC_ARROW); <br>    wc.hIcon          = LoadIcon(NULL, MAKEINTRESOURCE(IDI_APPLICATION)); <br>    wc.lpszMenuName   = NULL; <br>    wc.lpszClassName  = c_szClassName; <br>    wc.hbrBackground  = 0; <br>    wc.hInstance      = hinst; <br>    wc.style          = 0; <br>    wc.lpfnWndProc    = Ex_WndProc; <br>    wc.cbClsExtra     = 0; <br>    wc.cbWndExtra     = 0; <br> <br>    if (!RegisterClass(&amp;wc)) { <br>        return NULL; <br>    } <br> <br>    HWND hwnd = CreateWindow( <br>                    c_szClassName,                  // Class name <br>                    "DIEX4 - Alt+F4 to exit",       // Caption <br>                    WS_OVERLAPPEDWINDOW,            // Style <br>                    CW_USEDEFAULT, CW_USEDEFAULT,   // Position <br>                    CW_USEDEFAULT, CW_USEDEFAULT,   // Size <br>                    NULL,                           // No parent <br>                    NULL,                           // No menu <br>                    g_hinst,                        // inst handle <br>                    0                               // no params <br>                    ); <br> <br>    if (!DIInit(hwnd)) { <br>        DestroyWindow(hwnd); <br>        return NULL; <br>    } <br> <br>    ShowWindow(hwnd, nCmdShow); <br> <br>    return hwnd; <br>} <br> <br>/**************************************************************************** <br> * <br> *      WinMain <br> * <br> *      Application entry point. <br> * <br> ****************************************************************************/ <br> <br>int PASCAL <br>WinMain(HINSTANCE hinst, HINSTANCE hinstPrev, LPSTR szCmdLine, int nCmdShow) <br>{ <br>    MSG msg; <br>    msg.wParam = 0;         /* In case something goes horribly wrong */ <br> <br>    HWND hwnd = AppInit(hinst, nCmdShow); <br> <br>    if (hwnd) { <br> <br>        /* <br>         *  Standard game loop. <br>         */ <br>        for (;;) { <br>            if (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) { <br> <br>                /* If it's a quit message, we're outta here */ <br>                if (msg.message == WM_QUIT) { <br>                    break; <br>                } else { <br>                    TranslateMessage(&amp;msg); <br>                    DispatchMessage(&amp;msg); <br>                } <br>            } else if (g_fPaused) { <br>                WaitMessage(); <br>            } else { <br>                Ex_OneFrame(hwnd); <br>            } <br>        } <br>    } <br> <br>    DITerm(); <br> <br>    return msg.wParam; <br> <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
