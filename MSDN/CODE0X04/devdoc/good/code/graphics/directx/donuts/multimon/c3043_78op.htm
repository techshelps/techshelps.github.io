<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MAIN.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3049"></a>MAIN.CPP</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1995-1997 Microsoft Corporation. All Rights Reserved. <br> * <br> *  File:       main.cpp <br> * <br> *@@BEGIN_MSINTERNAL <br> *  History: <br> *   Date       By        Reason <br> *   ====       ==        ====== <br> *   15-sep-97  t-craigs  Created <br> *@@END_MSINTERNAL <br> * <br> ***************************************************************************/ <br> <br>#include "donuts.h" <br> <br>// globals defined elsewhere <br>externCMyMonitorMonitor[9]; <br>externCShipDL; <br>externdoubleDirx[40]; <br>externdoubleDiry[40]; <br> <br>// globals <br>#ifdef DEBUG <br>char                    DebugBuf[256]; <br>#endif <br> <br>BOOL                    bSoundEnabled = FALSE; <br>BOOL                    bPlayIdle = FALSE; <br>BOOL                    bPlayBuzz = FALSE; <br>BOOL                    bPlayRev = FALSE; <br>#ifdef USE_DSOUND <br>LPDIRECTSOUND           lpDS; <br>HSNDOBJ                 hsoBeginLevel     = NULL; <br>HSNDOBJ                 hsoEngineIdle     = NULL; <br>HSNDOBJ                 hsoEngineRev      = NULL; <br>HSNDOBJ                 hsoSkidToStop     = NULL; <br>HSNDOBJ                 hsoShieldBuzz     = NULL; <br>HSNDOBJ                 hsoShipExplode    = NULL; <br>HSNDOBJ                 hsoFireBullet     = NULL; <br>HSNDOBJ                 hsoShipBounce     = NULL; <br>HSNDOBJ                 hsoDonutExplode   = NULL; <br>HSNDOBJ                 hsoPyramidExplode = NULL; <br>HSNDOBJ                 hsoCubeExplode    = NULL; <br>HSNDOBJ                 hsoSphereExplode  = NULL; <br>#endif <br> <br>// global data <br>HWND            hWndMain; <br>HACCEL                  hAccel; <br>HINSTANCE               hInst; <br>BOOL                    bIsActive; <br> <br>BOOL                    bSpecialEffects = FALSE; <br>BOOL                    bWantSound = TRUE; <br>BOOL                    bShowFrameCount=TRUE; <br> <br>BOOL                    lastThrust = FALSE; <br>int                     showDelay = 0; <br>BOOL                    bMouseVisible; <br>DWORD                   dwFrameCount; <br>DWORD                   dwFrameTime; <br>DWORD                   dwFrames; <br>DWORD                   dwFramesLast; <br>DWORD                   lastTickCount; <br>int                     score; <br>int                     ProgramState; <br>int                     level; <br>int                     restCount; <br>DWORD                   ShowLevelCount = 3000; <br>intiForceErase = 0; <br>RECTrcVirtualDesktop; <br> <br> <br>// <br>// FUNCTION:WinMain <br>// <br>// DESCRIPTION:Contains main program loop <br>// <br>// NOTES:- program starts here! <br>// <br>int PASCAL WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <br>                        int nCmdShow ) <br>{ <br>    MSG     msg; <br> <br>// save application instance <br>    hInst = hInstance; <br> <br>    while( lpCmdLine[0] == '-' ) <br>    { <br>        lpCmdLine++; <br> <br>        switch (*lpCmdLine++) <br>        { <br>        case 'S': case 's': <br>            bWantSound = FALSE; <br>            break; <br>        } <br>        while( IS_SPACE(*lpCmdLine) ) <br>        { <br>            lpCmdLine++; <br>        } <br>    } <br> <br>// initialize display system <br>if ( CMyMonitor::Initialize() != DD_OK ) <br>{ <br>CleanupAndExit("Couldn't initialize multimonitor system"); <br>return -1; <br>} <br> <br>rcVirtualDesktop.left = GetSystemMetrics(SM_XVIRTUALSCREEN); <br>rcVirtualDesktop.right = rcVirtualDesktop.left + GetSystemMetrics(SM_CXVIRTUALSCREEN); <br>rcVirtualDesktop.top = GetSystemMetrics(SM_YVIRTUALSCREEN); <br>rcVirtualDesktop.bottom = rcVirtualDesktop.left + GetSystemMetrics(SM_CYVIRTUALSCREEN); <br> <br>if( !InitApplication(hInstance, nCmdShow) ) <br>    { <br>DestroyWindow( hWndMain ); <br>        return FALSE; <br>    } <br> <br>    if( !InitializeGame() ) <br>    { <br>        DestroyWindow( hWndMain ); <br>        return FALSE; <br>    } <br> <br>    dwFrameTime = timeGetTime(); <br> <br>while( 1 ) <br>    { <br>        if( PeekMessage( &amp;msg, NULL, 0, 0, PM_NOREMOVE ) ) <br>        { <br>            if( !GetMessage( &amp;msg, NULL, 0, 0 ) ) <br>            { <br>                return msg.wParam; <br>            } <br>            if ( !TranslateAccelerator( hWndMain, hAccel, &amp;msg ) ) <br>{ <br>                TranslateMessage(&amp;msg); <br>                DispatchMessage(&amp;msg); <br>            } <br>        } <br>        else if ( bIsActive ) <br>        { <br>UpdateFrame(); <br>        } <br>        else <br>        { <br>            WaitMessage(); <br>        } <br>    } <br>} /* WinMain */ <br> <br> <br>// <br>// FUNCTION:MainWndproc <br>// <br>// DESCRIPTION:Window procedure for message handling <br>// <br>// NOTES: <br>// <br>long FAR PASCAL MainWndproc( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam ) <br>{ <br>    UINT        cmd; <br>//PAINTSTRUCT ps; <br> <br>    switch( message ) <br>    { <br>    case WM_ACTIVATEAPP: <br>        bIsActive = (BOOL) wParam; <br>if( bIsActive ) <br>    { <br>bMouseVisible = FALSE; <br>            lastTickCount = GetTickCount(); <br>            bSpecialEffects = FALSE; <br>// we are active, need to reacquire the keyboard <br>            ReacquireInput(); <br>} <br>else <br>{ <br>bMouseVisible = TRUE; <br>   // DirectInput automatically unacquires for us in FOREGROUND mode <br>} <br>        break; <br> <br>    case WM_CREATE: <br>        break; <br> <br>    case WM_SETCURSOR: <br>if( !bMouseVisible ) <br>{ <br>SetCursor(NULL); <br>} <br>else <br>{ <br>SetCursor(LoadCursor( NULL, IDC_ARROW )); <br>} <br>        return TRUE; <br> <br>    case WM_COMMAND: <br>cmd = GET_WM_COMMAND_ID(wParam, lParam); <br> <br>        if (cmd &gt;= IDC_DEVICES &amp;&amp; cmd &lt; IDC_DEVICES + 100) <br>{ <br>            PickInputDevice(cmd - IDC_DEVICES); <br>        } <br>else <br>{ <br>switch (cmd) <br>{ <br>case IDC_FRAMERATE: <br>bShowFrameCount = !bShowFrameCount; <br>if( bShowFrameCount ) <br>{ <br>dwFrameCount = 0; <br>dwFrameTime = timeGetTime(); <br>} <br>break; <br> <br>case IDC_STARTGAME: <br>if( ProgramState == PS_SPLASH ) <br>{ <br>ProgramState = PS_BEGINREST; <br>SetupGame(); <br>} <br>break; <br> <br>case IDC_QUIT: <br>PostMessage( hWnd, WM_CLOSE, 0, 0 ); <br>return 0; <br> <br>case IDC_AUDIO: <br>#ifdef USE_DSOUND <br>if(bWantSound) <br>{ <br>    if( bSoundEnabled ) <br>    { <br>    DestroySound(); <br>    } <br>    else <br>    { <br>    InitializeSound(); <br>    } <br>} <br>#endif <br>break; <br> <br>case IDC_TRAILS: <br>bSpecialEffects = !bSpecialEffects; <br>break; <br>} <br>break; <br>} <br> <br>    case WM_INITMENU: <br>        CheckMenuItems(hWndMain); <br>        break; <br> <br>    case WM_ERASEBKGND: <br>    return 1; <br>/* <br>    case WM_PAINT: <br>        BeginPaint( hWnd, &amp;ps ); <br>        EndPaint( hWnd, &amp;ps ); <br>        return 1; <br>*/ <br>    case WM_DESTROY: <br>        CleanupAndExit(NULL); <br>        PostQuitMessage( 0 ); <br>        break; <br> <br>    case WM_ENTERMENULOOP: <br>AppPause(); <br>break; <br> <br>    case WM_EXITMENULOOP: <br>        AppUnpause(); <br>        break; <br> <br>    default: <br>        break; <br>    } <br>    return DefWindowProc(hWnd, message, wParam, lParam); <br> <br>} /* MainWndproc */ <br> <br> <br> <br>// <br>// FUNCTION:InitApplication <br>// <br>// DESCRIPTION:Perform window creation <br>// <br>// NOTES: <br>// <br>BOOL InitApplication( HANDLE hInstance, int nCmdShow ) <br>{ <br>    WNDCLASS    wc; <br>    BOOL        rc; <br> <br>    wc.style = CS_DBLCLKS; <br>    wc.lpfnWndProc = MainWndproc; <br>    wc.cbClsExtra = 0; <br>    wc.cbWndExtra = 0; <br>    wc.hInstance = hInstance; <br>    wc.hIcon = LoadIcon( hInstance, MAKEINTRESOURCE(DONUTS_ICON)); <br>    wc.hCursor = LoadCursor( NULL, IDC_ARROW ); <br>    wc.hbrBackground = GetStockObject( BLACK_BRUSH ); <br>    wc.lpszMenuName =  MAKEINTRESOURCE(DONUTS_MENU); <br>    wc.lpszClassName = "DonutsClass"; <br>    rc = RegisterClass( &amp;wc ); <br>    if( !rc ) <br>    { <br>        return FALSE; <br>    } <br> <br>    hAccel = LoadAccelerators(hInstance, MAKEINTRESOURCE(DONUTS_ACCEL)); <br>    if ( !hAccel ) <br>    { <br>        return FALSE; <br>    } <br> <br>    hWndMain = CreateWindowEx( <br>0, <br>        "DonutsClass", <br>        "Donuts", <br>        WS_VISIBLE | // so we don't have to call ShowWindow <br>        WS_POPUP |   // non-app window <br>        WS_CAPTION | // so our menu doesn't look ultra-goofy <br>        WS_SYSMENU,  // so we get an icon in the tray <br>        0, <br>        0, <br>        Monitor[0].dwWidth, <br>        Monitor[0].dwHeight, <br>        NULL, <br>        NULL, <br>        hInstance, <br>        NULL ); <br> <br>    if( !hWndMain ) <br>    { <br>        return FALSE; <br>    } <br> <br>    UpdateWindow( hWndMain ); <br> <br>#ifdef USE_DSOUND <br>    /* <br>     *  If sound is globally disabled, then disable the sound menu. <br>     */ <br>    if (!bWantSound) <br>{ <br>        EnableMenuItem(GetMenu(hWndMain), IDC_AUDIO, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED); <br>    } <br>#endif <br>    return TRUE; <br> <br>} /* InitApplication */ <br> <br> <br>// <br>// FUNCTION:MainWndproc <br>// <br>// DESCRIPTION:Initialize DirectX et al <br>// <br>// NOTES: <br>// <br>BOOL InitializeGame( void ) <br>{ <br>HRESULT ddrval; <br>for (int i = 0; i &lt; CMonitor::iNumberOfMonitors; i++) <br>{ <br>ddrval = Monitor[i].DDInit( hWndMain, TRUE ); <br>if ( ddrval != DD_OK ) <br>{ <br>return CleanupAndExit( Monitor[i].szErrMsg, ddrval ); <br>} <br>ddrval = Monitor[i].RestoreSurfaces(); <br>if ( ddrval != DD_OK ) <br>{ <br>return CleanupAndExit("CMyMonitor::RestoreSurfaces failed", ddrval ); <br>} <br>} <br> <br>#ifdef USE_DSOUND <br>    if(bWantSound) <br>    { <br>        InitializeSound(); <br>    } <br>#endif <br> <br>// initialize DirectInput <br>if( !InitInput(hInst, hWndMain) ) <br>{ <br>return CleanupAndExit("DirectInput initialization failed"); <br>} <br> <br>    score = 0; <br> <br>lastTickCount = GetTickCount(); <br> <br>    ProgramState = PS_SPLASH; <br> <br>return TRUE; <br>} <br> <br> <br>// <br>// FUNCTION:AppPause <br>// <br>// DESCRIPTION:Draw menu bar <br>// <br>// NOTES: <br>// <br>void AppPause(void) <br>{ <br>    DrawMenuBar(hWndMain); <br>    RedrawWindow(hWndMain, NULL, NULL, RDW_FRAME); <br>Monitor[0].lpDD-&gt;FlipToGDISurface(); <br>} <br> <br>// <br>// FUNCTION:AppUnpause <br>// <br>// DESCRIPTION:Reset the various time counters so the donuts don't suddenly <br>//jump halfway across the screen and so the frame rate remains accurate. <br>// <br>// NOTES: <br>// <br>void AppUnpause(void) <br>{ <br>iForceErase = 2; <br>lastTickCount = dwFrameTime = timeGetTime(); <br>} <br> <br>// <br>// FUNCTION:CheckOneMenuItem <br>// <br>// DESCRIPTION:Checks a single item in a menu <br>// <br>// NOTES: <br>// <br>void CheckOneMenuItem(HMENU hmenu, UINT idc, BOOL fCheck) <br>{ <br>    CheckMenuItem(hmenu, idc, <br>                  fCheck ? (MF_BYCOMMAND | MF_CHECKED) <br>                         : (MF_BYCOMMAND | MF_UNCHECKED)); <br>} <br> <br>// <br>// FUNCTION:AppUnpause <br>// <br>// DESCRIPTION:Sync menu checkmarks with internal variables <br>// <br>// NOTES: <br>// <br>void CheckMenuItems(HWND hwnd) <br>{ <br>    HMENU hmenu = GetMenu(hwnd); <br> <br>    CheckOneMenuItem(hmenu, IDC_TRAILS, bSpecialEffects); <br> <br>#ifdef USE_DSOUND <br>    CheckOneMenuItem(hmenu, IDC_AUDIO, bWantSound &amp;&amp; bSoundEnabled); <br>#endif <br> <br>    CheckOneMenuItem(hmenu, IDC_FRAMERATE, bShowFrameCount); <br> <br>} <br> <br> <br>// <br>// FUNCTION:DisplayLevel <br>// <br>// DESCRIPTION:Blit "Level ###" <br>// <br>// NOTES: <br>// <br>void DisplayLevel( void ) <br>{ <br>    char buf[10]; <br>int left, top; <br> <br>    EraseScreen(); <br>    buf[0] = 10 + '0'; <br>    buf[1] = 11 + '0'; <br>    buf[2] = 12 + '0'; <br>    buf[3] = 11 + '0'; <br>    buf[4] = 10 + '0'; <br>    buf[5] = '\0'; <br> <br>top = Monitor[DL.iMonitor].dwHeight / 2 - 8; <br>left = (Monitor[DL.iMonitor].dwWidth - 16 * 9) / 2; <br>    BltScore( buf, left, top ); <br> <br>    buf[0] = level / 100 + '0'; <br>    buf[1] = level / 10 + '0'; <br>    buf[2] = level % 10 + '0'; <br>    buf[3] = '\0'; <br> <br>    left += 16 * 6; <br>BltScore( buf, left, top ); <br>    FlipScreen(); <br>} <br> <br> <br>// <br>// FUNCTION:DisplayFrameRate <br>// <br>// DESCRIPTION:Blit the frame rate <br>// <br>// NOTES: <br>// <br>void DisplayFrameRate( void ) <br>{ <br>    DWORDtime2; <br>    char    buff[256]; <br> <br>    dwFrameCount++; <br>    time2 = timeGetTime() - dwFrameTime; <br>    if( time2 &gt; 1000 ) <br>    { <br>        dwFrames = (dwFrameCount*1000)/time2; <br>        dwFrameTime = timeGetTime(); <br>        dwFrameCount = 0; <br>    } <br>    if( dwFrames == 0 ) <br>    { <br>        return; <br>    } <br> <br>    if (dwFrames != dwFramesLast) <br>    { <br>        dwFramesLast = dwFrames; <br>    } <br> <br>    if( dwFrames &gt; 99 ) <br>    { <br>dwFrames = 99; <br>    } <br>    buff[0] = (char)((dwFrames / 10) + '0'); <br>    buff[1] = (char)((dwFrames % 10) + '0'); <br>    buff[2] = '\0'; <br>    BltScore(buff, (int)(0.02 * (double) Monitor[DL.iMonitor].dwWidth), (int)(0.02 * (double) Monitor[DL.iMonitor].dwHeight) ); <br>} <br> <br> <br>// <br>// FUNCTION:BltScore <br>// <br>// DESCRIPTION:Performs letter &amp; number blitting for frame rate, score, and level ### <br>// <br>// NOTES: <br>// <br>void BltScore( char *num, int x, int y ) <br>{ <br>    int     i; <br>    HRESULT ddrval; <br>DDBLTFX ddbltfx; <br>DWORDdwFlag; <br>RECT    src; <br>RECTdst = { x, y, x + 16, y + 16 }; <br> <br>ddbltfx.dwSize = sizeof( ddbltfx ); <br>dwFlag = DDBLT_KEYSRC; <br> <br>    for(char* c=num; *c != '\0'; c++) <br>    { <br>        while( 1 ) <br>        { <br>            i = *c - '0'; <br>            src.left = i*16; <br>            src.top = 0; <br>            src.right = src.left + 16; <br>            src.bottom = src.top + 16; <br>     <br>ddrval = Monitor[DL.iMonitor].lpBackBuffer-&gt;Blt( &amp;dst, Monitor[DL.iMonitor].lpNum, &amp;src, dwFlag, &amp;ddbltfx ); <br>            if( ddrval == DD_OK ) <br>            { <br>                break; <br>            } <br>            if( ddrval == DDERR_SURFACELOST ) <br>            { <br>                ddrval = Monitor[DL.iMonitor].RestoreSurfaces(); <br>if ( ddrval != DD_OK ) <br>{ <br>                    CleanupAndExit("BltScore (CMyMonitor::RestoreSurfaces) failed", ddrval ); <br>return; <br>} <br>            } <br>            if( ddrval != DDERR_WASSTILLDRAWING ) <br>            { <br>                return; <br>            } <br>        } <br>dst.left += 16; <br>dst.right += 16; <br>    } <br>} <br> <br>// <br>// FUNCTION:BltSplash <br>// <br>// DESCRIPTION:Display intro screen on the primary monitor <br>// <br>// NOTES: <br>// <br>void BltSplash( void ) <br>{ <br>    HRESULT     ddrval; <br>    HBITMAP     hbm; <br>intiMonitor; <br> <br>    // set the palette <br>    Monitor[0].lpFrontBuffer-&gt;SetPalette( Monitor[0].lpSplashPalette ); <br> <br>    hbm = (HBITMAP)LoadImage( GetModuleHandle( NULL ), "SPLASH", IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION ); <br>    if ( hbm == NULL ) <br>return; <br> <br>    // if the surface is lost, DDCopyBitmap will fail and the surface will <br>    // be restored in FlipScreen. <br>    ddrval = DDCopyBitmap( Monitor[0].lpBackBuffer, hbm, 0, 0, 0, 0 ); <br> <br>// blank out other monitors <br>for (iMonitor = 1; iMonitor &lt; CMonitor::iNumberOfMonitors; iMonitor++) <br>{ <br>ddrval = Monitor[iMonitor].Blank(); <br>if ( ddrval != DD_OK ) <br>{ <br>CleanupAndExit( "BltSplash (CMyMonitor::Blank) failed", ddrval ); <br>return; <br>} <br>} <br> <br>    DeleteObject( hbm ); <br> <br>    FlipScreen(); <br>} <br> <br> <br>// <br>// FUNCTION:SetupGame <br>// <br>// DESCRIPTION:Perform start time initialization <br>// <br>// NOTES: <br>// <br>void SetupGame(void) <br>{ <br>    restCount = GetTickCount(); <br>    InitLevel( ++level ); <br> <br>    for(int i=0; i&lt; CMonitor::iNumberOfMonitors; i++) <br>    { <br>        Monitor[i].lpFrontBuffer-&gt;SetPalette( Monitor[i].lpArtPalette ); <br>    }; <br>} <br> <br>// <br>// FUNCTION:EraseScreen <br>// <br>// DESCRIPTION:Fill back buffers with background color and draws a border <br>// <br>// NOTES: <br>// <br>BOOL EraseScreen( void ) <br>{ <br>    if ( iForceErase &gt; 0 ) <br>{ <br>--iForceErase; <br>} <br>else if( bSpecialEffects ) <br>{ <br>        return TRUE; <br>} <br> <br>HRESULT ddrval; <br>for(int iMonitor=0;iMonitor&lt;CMonitor::iNumberOfMonitors;iMonitor++) <br>    { <br>ddrval = Monitor[iMonitor].Blank(); <br>if ( ddrval != DD_OK ) <br>{ <br>return CleanupAndExit("EraseScreen (CMyMonitor::Blank) failed", ddrval ); <br>} <br>                 <br>        ddrval = Monitor[iMonitor].DrawBorder(); <br>        if ( ddrval != DD_OK ) <br>{ <br>return CleanupAndExit("EraseScreen (CMyMonitor::DrawBorder) failed", ddrval ); <br>} <br>} <br>return TRUE; <br>} <br> <br>// <br>// FUNCTION:FlipScreen <br>// <br>// DESCRIPTION:Flip back buffers to front buffers <br>// <br>// NOTES: <br>// <br>BOOL FlipScreen( void ) <br>{ <br>HRESULT ddrval; <br>    for(int iMonitor=0;iMonitor&lt;CMonitor::iNumberOfMonitors;iMonitor++) <br>    { <br>ddrval = Monitor[iMonitor].Flip(); <br>if ( ddrval != DD_OK ) <br>{ <br>return CleanupAndExit("FlipScreen (CMyMonitor::Flip) failed", ddrval ); <br>} <br>    } <br>return TRUE; <br>} <br> <br> <br>// <br>// FUNCTION:InitLevel <br>// <br>// DESCRIPTION:Perform new level initialization <br>// <br>// NOTES: <br>// <br>void InitLevel( int level ) <br>{ <br>    int     i; <br>doublestartx, starty; <br> <br>    // clear any stray bullets out of the display list <br>    while( DL.next != &amp;DL ) <br>    { <br>        DL.next-&gt;DeleteFromList(); <br>    } <br> <br>// add some donuts <br>    for(i=0; i&lt;(2*level-1); i++) <br>    { <br>        CObject* pObj = new CDonut; <br>startx = randDouble( Monitor[DL.iMonitor].lpMonitorRect-&gt;left, Monitor[DL.iMonitor].lpMonitorRect-&gt;right - pObj-&gt;km_iSize ); <br>        starty = randDouble( Monitor[DL.iMonitor].lpMonitorRect-&gt;top, Monitor[DL.iMonitor].lpMonitorRect-&gt;bottom - pObj-&gt;km_iSize ); <br> <br>// virtual fct call <br>pObj-&gt;Init( startx, starty ); <br>    } <br>    DL.Init(); <br>   showDelay = DEF_SHOW_DELAY; <br>} <br> <br> <br> <br>// <br>// FUNCTION:UpdateFrame <br>// <br>// DESCRIPTION:Draw the next frame <br>// <br>// NOTES:- depends on program state <br>//- called from main program loop when no messages to process <br>// <br>void UpdateFrame( void ) <br>{ <br>    switch( ProgramState ) <br>    { <br>        case PS_SPLASH: <br>            // display the splash screen <br>            BltSplash(); <br>            return; <br> <br>        case PS_ACTIVE: <br>UpdateDisplayList(); <br>CheckForHits(); <br>DrawDisplayList(); <br> <br>// check if display list is empty <br>if ( DL.next == &amp;DL &amp;&amp; DL.prev == &amp;DL ) <br>            { <br>#ifdef USE_DSOUND <br>                if(bWantSound) <br>                { <br>                    SndObjStop(hsoEngineIdle); <br>                    SndObjStop(hsoEngineRev); <br>                } <br>#endif <br>                bPlayIdle = FALSE; <br>                bPlayRev = FALSE; <br>                lastThrust = DL.lastShield = FALSE; <br>                ProgramState = PS_BEGINREST; <br>                restCount = GetTickCount(); <br>                InitLevel( ++level ); <br>            } <br>            return; <br> <br>        case PS_BEGINREST: <br>#ifdef USE_DSOUND <br>            if(bWantSound) <br>            { <br>                SndObjPlay(hsoBeginLevel, 0); <br>            } <br>#endif <br>            ProgramState = PS_REST; <br>            // <br>            // FALLTHRU <br>            // <br>        case PS_REST: <br>            if( ( GetTickCount() - restCount ) &gt; ShowLevelCount ) <br>            { <br>#ifdef USE_DSOUND <br>                if(bWantSound) <br>                { <br>                    SndObjPlay(hsoEngineIdle, DSBPLAY_LOOPING); <br>                } <br>#endif <br>                bPlayIdle = TRUE; <br>                lastTickCount = GetTickCount(); <br>                ProgramState = PS_ACTIVE; <br>            } <br>            else <br>            { <br>DisplayLevel(); <br>            } <br>            return; <br>    } <br>} <br> <br> <br>// <br>// FUNCTION:UpdateDisplayList <br>// <br>// DESCRIPTION:Add and remove objects from the display list <br>// <br>// NOTES:- reads user input <br>//- adjust position, speed, and animation frame of objects <br>// <br>void UpdateDisplayList( void ) <br>{ <br>    CObject*cur; <br>CObject*save; <br>    DWORD       input; <br>DWORD       thisTickCount = GetTickCount(); <br>    DWORD       tickDiff = thisTickCount - lastTickCount; <br>    BOOL        event = FALSE; <br> <br>    lastTickCount = thisTickCount; <br> <br>input = ReadGameInput(); <br> <br>    if (showDelay) <br>    { <br>        showDelay -= (int)tickDiff; <br>        if (showDelay &lt; 0) <br>        { <br>            showDelay = 0; <br>            DL.lastShield = FALSE; <br>DL.Init(); <br>        } <br>    } <br> <br>event = DL.CheckPosition( tickDiff ); <br> <br>if (event) <br>    { <br>#ifdef USE_DSOUND <br>        if(bWantSound) <br>        { <br>            PlayPanned(hsoShipBounce, DL.posx); <br>} <br>#endif <br>        event = FALSE; <br>    } <br> <br>    if ((event = (showDelay || ((input &amp; KEY_SHIELD) == KEY_SHIELD))) != DL.lastShield) <br>    { <br>        if (event &amp;&amp; !showDelay) <br>{ <br>#ifdef USE_DSOUND <br>        if(bWantSound) <br>        { <br>            SndObjPlay(hsoShieldBuzz, DSBPLAY_LOOPING); <br>} <br>#endif <br>    bPlayBuzz = TRUE; <br>} <br>        else <br>{ <br>#ifdef USE_DSOUND <br>        if(bWantSound) <br>        { <br>                SndObjStop(hsoShieldBuzz); <br>} <br>#endif <br>        bPlayBuzz = FALSE; <br>    } <br>        DL.lastShield = event; <br>    } <br>    if (event) <br>    { <br>        input &amp;= ~(KEY_FIRE); <br>    } <br> <br>    if (input &amp; KEY_FIRE) <br>    { <br>if( !showDelay ) <br>{ <br>            // add a bullet to the scene <br>            --score; <br>            if(score &lt; 0) <br>                score = 0; <br> <br>#ifdef USE_DSOUND <br>        if(bWantSound) <br>        { <br>                SndObjPlay(hsoFireBullet, 0); <br>} <br>#endif <br>            CObject* pObj = new CBullet; <br>// virtual fct. call <br>pObj-&gt;Init( Dirx[(int)DL.frame]*6.0 + 16.0 + DL.posx, Diry[(int)DL.frame]*6.0 + 16.0 + DL.posy ); <br>pObj-&gt;velx = Dirx[(int)DL.frame]*500.0/1000.0; <br>pObj-&gt;vely = Diry[(int)DL.frame]*500.0/1000.0; <br> <br>        } <br>    } <br> <br>    event = FALSE; <br>    if( input &amp; KEY_LEFT ) <br>    { <br>        DL.frame -= 1.0; <br>        if( DL.frame &lt; 0.0 ) <br>            DL.frame += DL.km_iMaxFrame; <br>    } <br>    if( input &amp; KEY_RIGHT ) <br>    { <br>        DL.frame += 1.0; <br>        if( DL.frame &gt;= DL.km_iMaxFrame ) <br>            DL.frame -= DL.km_iMaxFrame; <br>    } <br>    if( input &amp; KEY_UP ) <br>    { <br>        DL.velx += Dirx[(int)DL.frame] * 10.0/1000.0; <br>        DL.vely += Diry[(int)DL.frame] * 10.0/1000.0; <br>    event = TRUE; <br>    } <br>    if( input &amp; KEY_DOWN ) <br>    { <br>        DL.velx -= Dirx[(int)DL.frame] * 10.0/1000.0; <br>        DL.vely -= Diry[(int)DL.frame] * 10.0/1000.0; <br>        event = TRUE; <br>    } <br> <br>    if (event != lastThrust) <br>    { <br>        if (event) <br>        { <br>            input &amp;= ~KEY_STOP; <br>#ifdef USE_DSOUND <br>            if(bWantSound) <br>            { <br>                SndObjStop(hsoSkidToStop); <br>                SndObjPlay(hsoEngineRev, DSBPLAY_LOOPING); <br>} <br>#endif <br>bPlayRev = TRUE; <br>        } <br>        else <br>        { <br>#ifdef USE_DSOUND <br>if(bWantSound) <br>{ <br>    SndObjStop(hsoEngineRev); <br>} <br>#endif <br>    bPlayRev = FALSE; <br>        } <br>        lastThrust = event; <br>    } <br> <br>    if( input &amp; KEY_STOP ) <br>    { <br>#ifdef USE_DSOUND <br>        if(bWantSound) <br>        { <br>        if (DL.velx || DL.vely) <br>            PlayPanned(hsoSkidToStop, DL.posx); <br>} <br>#endif <br>        DL.velx = 0; <br>        DL.vely = 0; <br>    } <br> <br>    cur = DL.next; <br>    do <br>    { <br>cur-&gt;CheckPosition( tickDiff ); <br>cur = cur-&gt;next; <br>    } <br>    while( cur != &amp;DL ); <br> <br>cur = DL.next; <br>do <br>{ <br>// virtual fct. call <br>if ( cur-&gt;CheckFrame() ) <br>{ <br>save = cur; <br>cur = cur-&gt;next; <br>save-&gt;DeleteFromList(); <br>} <br>else <br>{ <br>cur = cur-&gt;next; <br>} <br>} <br>while( cur != &amp;DL ); <br>} <br> <br> <br>// <br>// FUNCTION:CheckForHits <br>// <br>// DESCRIPTION:Handle object collisions <br>// <br>// NOTES:- updates object bounding boxes <br>//- look for intersections of bullet-like objects with target-like objects <br>// <br>void CheckForHits( void ) <br>{ <br>    CObject*bullet, *target, *save; <br>    int         x, y, l ,t; <br>    BOOL        hit; <br> <br>    // update screen rects <br>    target = &amp;DL; <br>    do <br>    { <br>target-&gt;UpdateRect(); <br>        target = target-&gt;next; <br>    } <br>    while( target != &amp;DL ); <br> <br>// look for intersections of bullet-like objects with target-like objects <br>    bullet=&amp;DL; <br>    do <br>    { <br>        hit = FALSE; <br>        if( !bullet-&gt;CanBeBullet() ) <br>        { <br>            bullet = bullet-&gt;next; <br>            continue; <br>        } <br> <br>        x = (bullet-&gt;dst.left + bullet-&gt;dst.right) / 2; <br>        y = (bullet-&gt;dst.top + bullet-&gt;dst.bottom) / 2; <br> <br>        for( target = DL.next; target != &amp;DL; target = target-&gt;next) <br>        { <br>            if( !target-&gt;CanBeTarget() ) <br>                continue; <br> <br>            if( (x &gt;= target-&gt;dst.left) &amp;&amp; <br>                (x &lt;  target-&gt;dst.right) &amp;&amp; <br>                (y &gt;= target-&gt;dst.top) &amp;&amp; <br>                (y &lt;  target-&gt;dst.bottom) ) <br>            { <br>// do we have a bullet or the ship with shields on <br>                if ((bullet != &amp;DL) || !DL.lastShield) <br>                { <br>                    // the bullet hit the target <br>l = target-&gt;dst.left; <br>t = target-&gt;dst.top; <br> <br>// virtual fct call <br>                    score += target-&gt;Hit( l, t ); <br> <br>                    target-&gt;DeleteFromList(); <br>                } <br>                hit = TRUE; <br>            } <br> <br>            if( hit ) <br>            { <br>                if( bullet == &amp;DL ) <br>                { <br>                    hit = FALSE; <br>                    if ( !DL.lastShield &amp;&amp; !showDelay ) <br>                    { <br>score += DL.Hit( l ,t ); <br>        if (score &lt; 0) <br>                            score = 0; <br>showDelay = DEF_SHOW_DELAY; <br>                    } <br>                } <br>                break; <br>            } <br>        } //for <br> <br>        if( hit ) <br>        { <br>// get rid of the bullet <br>            save = bullet; <br>            bullet = bullet-&gt;next; <br> <br>            save-&gt;DeleteFromList(); <br>} <br>        else <br>        { <br>            bullet = bullet-&gt;next; <br>        } <br>    } while (bullet != &amp;DL); <br>} <br> <br> <br>// <br>// FUNCTION:DrawDisplayList <br>// <br>// DESCRIPTION:Blits everything the the screen <br>// <br>// NOTES: <br>// <br>void DrawDisplayList( void ) <br>{ <br>    CObject*cur; <br>CObject*last; <br>    char        scorebuf[11]; <br>    int         rem; <br> <br>    // calculate score string <br>    scorebuf[0] = score/10000000 + '0'; <br>    rem = score % 10000000; <br>    scorebuf[1] = rem/1000000 + '0'; <br>    rem = score % 1000000; <br>    scorebuf[2] = rem/100000 + '0'; <br>    rem = score % 100000; <br>    scorebuf[3] = rem/10000 + '0'; <br>    rem = score % 10000; <br>    scorebuf[4] = rem/1000 + '0'; <br>    rem = score % 1000; <br>    scorebuf[5] = rem/100 + '0'; <br>    rem = score % 100; <br>    scorebuf[6] = rem/10 + '0'; <br>    rem = score % 10; <br>    scorebuf[7] = rem + '0'; <br>#ifdef USE_DSOUND <br>    if( bSoundEnabled ) <br>    { <br>    scorebuf[8] = 14 + '0'; <br>    scorebuf[9] = 13 + '0'; <br>    scorebuf[10] = '\0'; <br>    } <br>    else <br>#endif <br>    { <br>        scorebuf[8] = '\0'; <br>    } <br> <br>    EraseScreen(); <br> <br>cur = &amp;DL;// start with the bottommost bitmap (the ship) <br>last = &amp;DL;// don't blt it twice <br> <br>    if (showDelay) <br>    cur = cur-&gt;prev; <br> <br>    do <br>    { <br>cur-&gt;Blt(); <br>cur = cur-&gt;prev; <br>    } <br>    while( cur != last ); <br> <br>BltScore(scorebuf, (int)(0.05 * Monitor[DL.iMonitor].dwWidth), (int)(0.95 * Monitor[DL.iMonitor].dwHeight)); <br> <br>    if( bShowFrameCount ) <br>DisplayFrameRate(); <br> <br>    FlipScreen(); <br>} <br> <br> <br> <br>// <br>// FUNCTION:CleanupAndExit <br>// <br>// DESCRIPTION:Shut everything down and display a box if an error occured <br>// <br>// NOTES: <br>// <br>BOOL CleanupAndExit( char *err ) <br>{ <br> <br>#ifdef DEBUG <br>    wsprintf(DebugBuf, "CleanupAndExit: %s\n", err ); <br>    OutputDebugString( DebugBuf ); <br>#endif <br> <br>    // make the cursor visible <br>    SetCursor(LoadCursor( NULL, IDC_ARROW )); <br>    bMouseVisible = TRUE; <br>     <br>// release monitors <br>CMyMonitor::Uninit(); <br> <br>    // clean up DirectInput objects <br>    CleanupInput(); <br> <br>    // warn user <br>    if( err ) <br>    { <br>        MessageBox( hWndMain, err, "ERROR", MB_OK ); <br>    } <br>    return FALSE; <br>} <br> <br>BOOL CleanupAndExit( char* err, HRESULT ddrval ) <br>{ <br>char* szText; <br>BOOL  rc; <br> <br>if ( !err ) <br>{ <br>szText = new char[256]; <br>wsprintf( szText, "Err: ddrval = %x", ddrval ); <br>} <br>else <br>{ <br>szText = new char[strlen(err) + 256]; <br>wsprintf( szText, "Err: %s (ddrval = %x)", err, ddrval ); <br>} <br>rc = CleanupAndExit( szText ); <br> <br>delete [] szText; <br>return rc; <br>} <br> <br>#ifdef USE_DSOUND <br> <br>// <br>// FUNCTION:PlayPanned <br>// <br>// DESCRIPTION:Play a sound with left-right relative volume adjusted depending on location <br>//within the virtual desktop. <br>// <br>// NOTES: <br>// <br>void PlayPanned(HSNDOBJ hSO, double posx ) <br>{ <br>static int nMiddle = (rcVirtualDesktop.left + rcVirtualDesktop.right) / 2; <br>static int nWidth = rcVirtualDesktop.right - rcVirtualDesktop.left; <br> <br>    if(!bWantSound) <br>return; <br> <br>IDirectSoundBuffer *pDSB = SndObjGetFreeBuffer(hSO); <br> <br>    if (pDSB) <br>    { <br>LONG pos = (LONG)((posx - nMiddle) / (double) nWidth * 20000.0); <br>pDSB-&gt;SetPan(pos); <br> <br>        pDSB-&gt;Play( 0, 0, 0); <br>    } <br>} <br> <br>// <br>// FUNCTION:InitializeSound <br>// <br>// DESCRIPTION:Initialize DirectSound objects <br>// <br>// NOTES: <br>// <br>void InitializeSound( void ) <br>{ <br>if(!bWantSound) <br>return; <br> <br>    bSoundEnabled = FALSE; <br> <br>    if (SUCCEEDED(DirectSoundCreate(NULL, &amp;lpDS, NULL))) <br>    { <br>        if (SUCCEEDED(lpDS-&gt;SetCooperativeLevel(hWndMain, DSSCL_NORMAL))) </code></pre>
<p>
</p>
<pre><code>{ <br>            hsoBeginLevel     = SndObjCreate(lpDS, "BeginLevel",      1); <br>            hsoEngineIdle     = SndObjCreate(lpDS, "EngineIdle",      1); <br>            hsoEngineRev      = SndObjCreate(lpDS, "EngineRev",       1); <br>            hsoSkidToStop     = SndObjCreate(lpDS, "SkidToStop",      1); <br>            hsoShieldBuzz     = SndObjCreate(lpDS, "ShieldBuzz",      1); <br>            hsoShipExplode    = SndObjCreate(lpDS, "ShipExplode",     1); <br>            hsoFireBullet     = SndObjCreate(lpDS, "Gunfire",        25); <br>            hsoShipBounce     = SndObjCreate(lpDS, "ShipBounce",      4); <br>            hsoDonutExplode   = SndObjCreate(lpDS, "DonutExplode",   10); <br>            hsoPyramidExplode = SndObjCreate(lpDS, "PyramidExplode", 12); <br>            hsoCubeExplode    = SndObjCreate(lpDS, "CubeExplode",    15); <br>            hsoSphereExplode  = SndObjCreate(lpDS, "SphereExplode",  10); <br>            bSoundEnabled = TRUE; <br> <br>//#ifdef USE_DSOUND   this should be dead code Josephc <br>            if( bPlayIdle ) <br>                SndObjPlay(hsoEngineIdle, DSBPLAY_LOOPING); <br> <br>            if( bPlayBuzz ) <br>                SndObjPlay(hsoShieldBuzz, DSBPLAY_LOOPING); <br> <br>            if( bPlayRev ) <br>                SndObjPlay(hsoEngineRev, DSBPLAY_LOOPING); <br> <br>//#endif <br>        } <br>        else <br>        { <br>            lpDS-&gt;Release(); <br>            lpDS = NULL; <br>        } <br>    } <br>} <br> <br>// <br>// FUNCTION:DestroySound <br>// <br>// DESCRIPTION:Release DirectSound objects <br>// <br>// NOTES: <br>// <br>void DestroySound( void ) <br>{ <br>if(!bWantSound) <br>return; <br> <br>    bSoundEnabled = FALSE; <br>    if (lpDS) <br>    { <br>        SndObjDestroy(hsoBeginLevel); <br>        hsoBeginLevel = NULL; <br>        SndObjDestroy(hsoEngineIdle); <br>        hsoEngineIdle = NULL; <br>        SndObjDestroy(hsoEngineRev); <br>        hsoEngineRev = NULL; <br>        SndObjDestroy(hsoSkidToStop); <br>        hsoSkidToStop = NULL; <br>        SndObjDestroy(hsoShieldBuzz); <br>        hsoShieldBuzz = NULL; <br>        SndObjDestroy(hsoShipExplode); <br>        hsoShipExplode = NULL; <br>        SndObjDestroy(hsoFireBullet); <br>        hsoFireBullet = NULL; <br>        SndObjDestroy(hsoShipBounce); <br>        hsoShipBounce = NULL; <br>        SndObjDestroy(hsoDonutExplode); <br>        hsoDonutExplode = NULL; <br>        SndObjDestroy(hsoPyramidExplode); <br>        hsoPyramidExplode = NULL; <br>        SndObjDestroy(hsoCubeExplode); <br>        hsoCubeExplode = NULL; <br>        SndObjDestroy(hsoSphereExplode); <br>        hsoSphereExplode = NULL; <br> <br>        lpDS-&gt;Release(); <br>        lpDS = NULL; <br>    } <br>} <br>#endif </code></pre>
<p>&nbsp;</p></body>
</HTML>
