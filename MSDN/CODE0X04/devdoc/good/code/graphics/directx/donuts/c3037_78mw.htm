<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DONUTS.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3038"></a>DONUTS.C</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1995-1997 Microsoft Corporation. All Rights Reserved. <br> * <br> *  File:       donuts.c <br> *  Content:    Shoot-em-up game <br> * <br> * <br> ***************************************************************************/ <br>#define INITGUID <br> <br>#include "donuts.h" <br> <br> <br>LPDIRECTDRAWSURFACE     lpFrontBuffer; <br>LPDIRECTDRAWSURFACE     lpBackBuffer; <br>LPDIRECTDRAWSURFACE     lpDonut; <br>LPDIRECTDRAWSURFACE     lpPyramid; <br>LPDIRECTDRAWSURFACE     lpCube; <br>LPDIRECTDRAWSURFACE     lpSphere; <br>LPDIRECTDRAWSURFACE     lpShip; <br>LPDIRECTDRAWSURFACE     lpNum; <br>LPDIRECTDRAW            lpDD; <br>LPDIRECTDRAWPALETTE     lpArtPalette; <br>LPDIRECTDRAWPALETTE     lpSplashPalette; <br>BOOL                    bSoundEnabled = FALSE; <br>BOOL                    bPlayIdle = FALSE; <br>BOOL                    bPlayBuzz = FALSE; <br>BOOL                    bPlayRev = FALSE; <br>BOOL                    lastThrust = FALSE; <br>BOOL                    lastShield = FALSE; <br>int                     showDelay = 0; <br>HWND                    hWndMain; <br>HACCEL                  hAccel; <br>HINSTANCE               hInst; <br>BOOL                    bShowFrameCount=TRUE; <br>BOOL                    bIsActive; <br>BOOL                    bMouseVisible; <br>DWORD                   dwFrameCount; <br>DWORD                   dwFrameTime; <br>DWORD                   dwFrames; <br>DWORD                   dwFramesLast; <br>BOOL                    bUseEmulation; <br>BOOL                    bTest=FALSE; <br>BOOL                    bStress=FALSE; <br>DWORD                   dwTransType; <br>RGBQUAD                 SPalette[256]; <br>DWORD                   lastTickCount; <br>int                     score; <br>int                     ProgramState; <br>int                     level; <br>int                     restCount; <br>DWORD                   dwFillColor; <br>BOOL                    bSpecialEffects = FALSE; <br>int                     iForceErase = 0; <br>DWORD                   ShowLevelCount = 3000; <br>DWORD                   ScreenX; <br>DWORD                   ScreenY; <br>DWORD                   ScreenBpp; <br>BOOL                    bWantSound = TRUE;  //global hack to turn off sound <br> <br>int getint(char**p, int def); <br> <br>#ifdef DEBUG <br>char                    DebugBuf[256]; <br>BOOL                    bHELBlt = FALSE; <br>#endif <br> <br>DBLNODE                 DL;             // Display List <br> <br>#ifdef USE_DSOUND <br>LPDIRECTSOUND           lpDS; <br>HSNDOBJ                 hsoBeginLevel     = NULL; <br>HSNDOBJ                 hsoEngineIdle     = NULL; <br>HSNDOBJ                 hsoEngineRev      = NULL; <br>HSNDOBJ                 hsoSkidToStop     = NULL; <br>HSNDOBJ                 hsoShieldBuzz     = NULL; <br>HSNDOBJ                 hsoShipExplode    = NULL; <br>HSNDOBJ                 hsoFireBullet     = NULL; <br>HSNDOBJ                 hsoShipBounce     = NULL; <br>HSNDOBJ                 hsoDonutExplode   = NULL; <br>HSNDOBJ                 hsoPyramidExplode = NULL; <br>HSNDOBJ                 hsoCubeExplode    = NULL; <br>HSNDOBJ                 hsoSphereExplode  = NULL; <br>#endif <br> <br> <br>void setup_game(void) <br>{ <br>    restCount = GetTickCount(); <br>    initLevel( ++level ); <br>    // set the palette <br>    lpFrontBuffer-&gt;lpVtbl-&gt;SetPalette( lpFrontBuffer, lpArtPalette ); <br>} <br> <br>/* <br> * <br> *  AppPause <br> * <br> */ <br>void AppPause(void) <br>{ <br>    lpDD-&gt;lpVtbl-&gt;FlipToGDISurface(lpDD); <br>    DrawMenuBar(hWndMain); <br>    RedrawWindow(hWndMain, NULL, NULL, RDW_FRAME); <br> <br>} <br> <br>/* <br> * <br> *  AppUnpause <br> * <br> *  Reset the various time counters so the donuts don't suddenly <br> *  jump halfways across the screen and so the frame rate remains accurate. <br> * <br> */ <br>void AppUnpause(void) <br>{ <br>    iForceErase = 2; <br>    lastTickCount = dwFrameTime = timeGetTime(); <br>} <br> <br>/* <br> *  CheckOneMenuItem <br> * <br> *  Helper function that checks a single item in a menu. <br> */ <br>void CheckOneMenuItem(HMENU hmenu, UINT idc, BOOL fCheck) <br>{ <br>    CheckMenuItem(hmenu, idc, <br>                  fCheck ? (MF_BYCOMMAND | MF_CHECKED) <br>                         : (MF_BYCOMMAND | MF_UNCHECKED)); <br>} <br> <br>/* <br> *  CheckMenuItems <br> * <br> *  Sync the menu checkmarks with our internal variables <br> */ <br>void CheckMenuItems(HWND hwnd) <br>{ <br>    HMENU hmenu = GetMenu(hwnd); <br> <br>    CheckOneMenuItem(hmenu, IDC_TRAILS, bSpecialEffects); <br>#ifdef USE_DSOUND <br>    CheckOneMenuItem(hmenu, IDC_AUDIO, bWantSound &amp;&amp; bSoundEnabled); <br>#endif <br>    CheckOneMenuItem(hmenu, IDC_FRAMERATE, bShowFrameCount); <br> <br> <br>} <br> <br>/* <br> * MainWndproc <br> * <br> * Callback for all Windows messages <br> */ <br>long FAR PASCAL MainWndproc( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam ) <br>{ <br>    PAINTSTRUCT ps; <br>    HDC         hdc; <br>    UINT        cmd; <br> <br>    switch( message ) <br>    { <br>    case WM_ACTIVATEAPP: <br>        bIsActive = (BOOL) wParam; <br>if( bIsActive ) <br>    { <br>    bMouseVisible = FALSE; <br>            lastTickCount = GetTickCount(); <br>            bSpecialEffects = FALSE; <br>       // we are active, need to reacquire the keyboard <br>            ReacquireInput(); <br>} <br>else <br>{ <br>    bMouseVisible = TRUE; <br>       // DirectInput automatically unacquires for us in FOREGROUND mode <br>} <br>        break; <br> <br>    case WM_CREATE: <br>        break; <br> <br>    case WM_SETCURSOR: <br>if( !bMouseVisible ) <br>{ <br>    SetCursor(NULL); <br>} <br>else <br>{ <br>    SetCursor(LoadCursor( NULL, IDC_ARROW )); <br>} <br>        return TRUE; <br> <br>    case WM_COMMAND: <br>        cmd = GET_WM_COMMAND_ID(wParam, lParam); <br> <br>        if (cmd &gt;= IDC_DEVICES &amp;&amp; cmd &lt; IDC_DEVICES + 100) { <br>            PickInputDevice(cmd - IDC_DEVICES); <br>        } else switch (cmd) { <br> <br>        case IDC_FRAMERATE: <br>            bShowFrameCount = !bShowFrameCount; <br>            if( bShowFrameCount ) <br>            { <br>                dwFrameCount = 0; <br>                dwFrameTime = timeGetTime(); <br>            } <br>            break; <br> <br>        case IDC_STARTGAME: <br>            if( ProgramState == PS_SPLASH ) <br>            { <br>                ProgramState = PS_BEGINREST; <br>                setup_game(); <br>            } <br>            break; <br> <br>        case IDC_QUIT: <br>            PostMessage( hWnd, WM_CLOSE, 0, 0 ); <br>            return 0; <br> <br>        case IDC_AUDIO: <br>#ifdef USE_DSOUND <br>            if(bWantSound) <br>            { <br>        if( bSoundEnabled ) <br>        { <br>            DestroySound(); <br>        } <br>        else <br>        { <br>            InitializeSound(); <br>        } <br>                } <br>#endif <br>            break; <br> <br>        case IDC_TRAILS: <br>            bSpecialEffects = !bSpecialEffects; <br>            break; <br>        } <br>        break; <br> <br>    case WM_INITMENU: <br>        CheckMenuItems(hWndMain); <br>        break; <br> <br>    case WM_ERASEBKGND: <br>    return 1; <br> <br>    case WM_PAINT: <br>        hdc = BeginPaint( hWnd, &amp;ps ); <br>        EndPaint( hWnd, &amp;ps ); <br>        return 1; <br> <br>    case WM_DESTROY: <br>        CleanupInput(); <br>        DestroyGame(); <br>        PostQuitMessage( 0 ); <br>        break; <br> <br>    case WM_ENTERMENULOOP: <br>      AppPause(); <br>      break; <br> <br>    case WM_EXITMENULOOP: <br>      AppUnpause(); <br>      break; <br> <br>    default: <br>        break; <br>    } <br>    return DefWindowProc(hWnd, message, wParam, lParam); <br> <br>} /* MainWndproc */ <br> <br>/* <br> * initApplication <br> * <br> * Do that Windows initialization stuff... <br> */ <br>static BOOL initApplication( HANDLE hInstance, int nCmdShow ) <br>{ <br>    WNDCLASS    wc; <br>    BOOL        rc; <br> <br>    wc.style = CS_DBLCLKS; <br>    wc.lpfnWndProc = MainWndproc; <br>    wc.cbClsExtra = 0; <br>    wc.cbWndExtra = 0; <br>    wc.hInstance = hInstance; <br>    wc.hIcon = LoadIcon( hInstance, MAKEINTRESOURCE(DONUTS_ICON)); <br>    wc.hCursor = LoadCursor( NULL, IDC_ARROW ); <br>    wc.hbrBackground = GetStockObject( BLACK_BRUSH ); <br>    wc.lpszMenuName =  MAKEINTRESOURCE(DONUTS_MENU); <br>    wc.lpszClassName = "DonutsClass"; <br>    rc = RegisterClass( &amp;wc ); <br>    if( !rc ) <br>    { <br>        return FALSE; <br>    } <br> <br>    hAccel = LoadAccelerators(hInstance, MAKEINTRESOURCE(DONUTS_ACCEL)); <br>    if ( !hAccel ) <br>    { <br>        return FALSE; <br>    } <br> <br>    hWndMain = CreateWindowEx(0,  // WS_EX_TOPMOST, <br>        "DonutsClass", <br>        "Donuts", <br>        WS_VISIBLE | // so we don't have to call ShowWindow <br>        WS_POPUP |   // non-app window <br>        WS_CAPTION | // so our menu doesn't look ultra-goofy <br>        WS_SYSMENU,  // so we get an icon in the tray <br>        0, <br>        0, <br>        GetSystemMetrics(SM_CXSCREEN), <br>        GetSystemMetrics(SM_CYSCREEN), <br>        NULL, <br>        NULL, <br>        hInstance, <br>        NULL ); <br> <br>    if( !hWndMain ) <br>    { <br>        return FALSE; <br>    } <br> <br>    UpdateWindow( hWndMain ); <br> <br>#ifdef USE_DSOUND <br>    /* <br>     *  If sound is globally disabled, then disable the sound menu. <br>     */ <br>    if (!bWantSound) { <br>        EnableMenuItem(GetMenu(hWndMain), IDC_AUDIO, <br>                       MF_BYCOMMAND | MF_DISABLED | MF_GRAYED); <br>    } <br>#endif <br> <br>    return TRUE; <br> <br>} /* initApplication */ <br> <br>/* <br> * WinMain <br> */ <br>int PASCAL WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <br>                        int nCmdShow ) <br>{ <br>    MSG     msg; <br> <br>    // save off application instance <br>    hInst = hInstance; <br> <br>    while( lpCmdLine[0] == '-' ) <br>    { <br>        lpCmdLine++; <br> <br>        switch (*lpCmdLine++) <br>        { <br>        case 'e': <br>            bUseEmulation = TRUE; <br>            break; <br>        case 't': <br>            bTest = TRUE; <br>            break; <br>        case 'S': <br>            bWantSound = FALSE; <br>            break; <br>        case 'x': <br>            bStress= TRUE; <br>            bTest = TRUE; <br>            break; <br>        } <br>        while( IS_SPACE(*lpCmdLine) ) <br>        { <br>            lpCmdLine++; <br>        } <br>    } <br> <br>    ScreenX = getint(&amp;lpCmdLine, 640); <br>    ScreenY = getint(&amp;lpCmdLine, 480); <br>    ScreenBpp = getint(&amp;lpCmdLine, 8); <br> <br>    if( !initApplication(hInstance, nCmdShow) ) <br>    { <br>        return FALSE; <br>    } <br> <br>    if( !InitializeGame() ) <br>    { <br>        DestroyWindow( hWndMain ); <br>        return FALSE; <br>    } <br> <br>    dwFrameTime = timeGetTime(); <br> <br>    while( 1 ) <br>    { <br>        if( PeekMessage( &amp;msg, NULL, 0, 0, PM_NOREMOVE ) ) <br>        { <br>            if( !GetMessage( &amp;msg, NULL, 0, 0 ) ) <br>            { <br>                return msg.wParam; <br>            } <br>            if ( !TranslateAccelerator( hWndMain, hAccel, &amp;msg ) ) { <br>                TranslateMessage(&amp;msg); <br>                DispatchMessage(&amp;msg); <br>            } <br>        } <br>        else if ( bIsActive ) <br>        { <br>            UpdateFrame(); <br>        } <br>        else <br>        { <br>            WaitMessage(); <br>        } <br>    } <br> <br>} /* WinMain */ <br> <br> <br>void DestroyGame( void ) <br>{ <br>} <br> <br>BOOL InitializeGame( void ) <br>{ <br>    DDCAPS          ddcaps; <br>    HRESULT         ddrval; <br>    DDSURFACEDESC   ddsd; <br>    DDSCAPS         ddscaps; <br>#ifdef NT_HACK <br>    DDSURFACEDESC DDSurfDesc; <br>#endif <br> <br>    score = 0; <br>    if( bTest ) <br>    ShowLevelCount = 1000; <br> <br>    if( bUseEmulation ) <br>        ddrval = DirectDrawCreate( (LPVOID) DDCREATE_EMULATIONONLY, &amp;lpDD, NULL ); <br>    else <br>        ddrval = DirectDrawCreate( NULL, &amp;lpDD, NULL ); <br> <br>    if( ddrval != DD_OK ) <br>        return CleanupAndExit("DirectDrawCreate Failed!"); <br> <br>    ddrval = lpDD-&gt;lpVtbl-&gt;SetCooperativeLevel( lpDD, hWndMain, <br>                            DDSCL_EXCLUSIVE | DDSCL_FULLSCREEN ); <br>    if( ddrval != DD_OK ) <br>        return CleanupAndExit("SetCooperativeLevel Failed"); <br> <br>    #ifdef NT_HACK <br>DDSurfDesc.dwSize = sizeof(DDSurfDesc); <br>ddrval = lpDD-&gt;lpVtbl-&gt;GetDisplayMode(lpDD,&amp;DDSurfDesc); <br>if(ddrval == DD_OK) <br>ScreenBpp = DDSurfDesc.ddpfPixelFormat.dwRGBBitCount; <br>    #endif <br> <br>    // set the mode <br>    ddrval = lpDD-&gt;lpVtbl-&gt;SetDisplayMode( lpDD, ScreenX, ScreenY, ScreenBpp ); <br>    if( ddrval != DD_OK ) <br>        return CleanupAndExit("SetDisplayMode Failed!"); <br> <br>    // check the color key hardware capabilities <br>    dwTransType = DDBLTFAST_SRCCOLORKEY; <br>    ddcaps.dwSize = sizeof( ddcaps ); <br> <br>#ifdef DEBUG <br>    if( GetProfileInt( "Donuts", "force_dest_blt", 0) ) <br>    { <br>dwTransType = DDBLTFAST_DESTCOLORKEY; <br>    } <br>    bHELBlt = GetProfileInt( "Donuts", "force_HEL_blt", bHELBlt ); <br>#endif <br> <br>    // Create surfaces <br>    memset( &amp;ddsd, 0, sizeof( ddsd ) ); <br>    ddsd.dwSize = sizeof( ddsd ); <br>    ddsd.dwFlags = DDSD_CAPS | DDSD_BACKBUFFERCOUNT; <br>    ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE | <br>                          DDSCAPS_FLIP | <br>                          DDSCAPS_COMPLEX; <br>    ddsd.dwBackBufferCount = 1; <br>    ddrval = lpDD-&gt;lpVtbl-&gt;CreateSurface( lpDD, &amp;ddsd, &amp;lpFrontBuffer, NULL ); <br>    if( ddrval != DD_OK ) <br>        return CleanupAndExit("CreateSurface FrontBuffer Failed!"); <br> <br>    // get a pointer to the back buffer <br>    ddscaps.dwCaps = DDSCAPS_BACKBUFFER; <br>    ddrval = lpFrontBuffer-&gt;lpVtbl-&gt;GetAttachedSurface( <br>                lpFrontBuffer, <br>                &amp;ddscaps, <br>                &amp;lpBackBuffer ); <br>    if( ddrval != DD_OK ) <br>        return CleanupAndExit("GetAttachedDurface Failed!"); <br> <br>    ddsd.dwFlags = DDSD_CAPS | DDSD_WIDTH | DDSD_HEIGHT; <br>    ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN; <br>#ifdef DEBUG <br>    if( bHELBlt ) <br>        ddsd.ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY; <br>#endif <br>    ddsd.dwWidth = 320; <br>    ddsd.dwHeight = 384; <br>    ddrval = lpDD-&gt;lpVtbl-&gt;CreateSurface( lpDD, &amp;ddsd, &amp;lpDonut, NULL ); <br>    if( ddrval != DD_OK ) <br>        return CleanupAndExit("CreateSurface lpDonut Failed!"); <br> <br>    ddsd.dwHeight = 128; <br>    ddrval = lpDD-&gt;lpVtbl-&gt;CreateSurface( lpDD, &amp;ddsd, &amp;lpPyramid, NULL ); <br>    if( ddrval != DD_OK ) <br>        return CleanupAndExit("CreateSurface lpPyramid Failed!"); <br> <br>    ddsd.dwHeight = 32; <br>    ddrval = lpDD-&gt;lpVtbl-&gt;CreateSurface( lpDD, &amp;ddsd, &amp;lpCube, NULL ); <br>    if( ddrval != DD_OK ) <br>        return CleanupAndExit("CreateSurface lpCube Failed!"); <br> <br>    ddsd.dwHeight = 32; <br>    ddrval = lpDD-&gt;lpVtbl-&gt;CreateSurface( lpDD, &amp;ddsd, &amp;lpSphere, NULL ); <br>    if( ddrval != DD_OK ) <br>        return CleanupAndExit("CreateSurface lpSphere Failed!"); <br>    // Set the background color fill color <br> <br>    ddsd.dwHeight = 256; <br>    ddrval = lpDD-&gt;lpVtbl-&gt;CreateSurface( lpDD, &amp;ddsd, &amp;lpShip, NULL ); <br>    if( ddrval != DD_OK ) <br>        return CleanupAndExit("CreateSurface lpShip Failed!"); <br> <br>    ddsd.dwHeight = 16; <br>    ddrval = lpDD-&gt;lpVtbl-&gt;CreateSurface( lpDD, &amp;ddsd, &amp;lpNum, NULL ); <br>    if( ddrval != DD_OK ) <br>        return CleanupAndExit("CreateSurface lpNum Failed!"); <br> <br>    if( !RestoreSurfaces() ) <br>        return CleanupAndExit("RestoreSurfaces Failed!"); <br> <br>    DL.next = DL.prev = &amp;DL;            // null display list <br>    DL.type = OBJ_SHIP; <br>    DL.surf = lpShip; <br>    lastTickCount = GetTickCount(); <br> <br>#ifdef USE_DSOUND <br>    if(bWantSound) <br>    { <br>        InitializeSound(); <br>    } <br>#endif <br> <br>   // initialize DirectInput <br>   if(!InitInput(hInst, hWndMain)) <br>      return CleanupAndExit("DirectInput initialization Failed!"); <br> <br>    if(bTest) <br>    { <br>    ProgramState = PS_ACTIVE; <br>setup_game(); <br>    } <br>    else <br>    { <br>        ProgramState = PS_SPLASH; <br>    } <br>    return TRUE; <br>} <br> <br>BOOL CleanupAndExit( char *err) <br>{ <br>#ifdef DEBUG <br>    wsprintf(DebugBuf, "___CleanupAndExit  err = %s\n", err ); <br>    OutputDebugString( DebugBuf ); <br>#endif <br> <br>    // make the cursor visible <br>    SetCursor(LoadCursor( NULL, IDC_ARROW )); <br>    bMouseVisible = TRUE; <br> <br>    if( lpDonut != NULL ) <br>        lpDonut-&gt;lpVtbl-&gt;Release( lpDonut ); <br> <br>    if( lpPyramid != NULL ) <br>        lpPyramid-&gt;lpVtbl-&gt;Release( lpPyramid ); <br> <br>    if( lpCube != NULL ) <br>        lpCube-&gt;lpVtbl-&gt;Release( lpCube ); <br> <br>    if( lpSphere != NULL ) <br>        lpSphere-&gt;lpVtbl-&gt;Release( lpSphere ); <br> <br>    if( lpShip != NULL ) <br>        lpShip-&gt;lpVtbl-&gt;Release( lpShip ); <br> <br>    if( lpNum != NULL ) <br>        lpNum-&gt;lpVtbl-&gt;Release( lpNum ); <br> <br>    if( lpFrontBuffer != NULL ) <br>        lpFrontBuffer-&gt;lpVtbl-&gt;Release( lpFrontBuffer ); <br> <br>    if( lpArtPalette != NULL ) <br>        lpArtPalette-&gt;lpVtbl-&gt;Release( lpArtPalette ); <br> <br>    if( lpSplashPalette != NULL ) <br>        lpSplashPalette-&gt;lpVtbl-&gt;Release( lpSplashPalette ); <br> <br>    if( lpDD != NULL ) <br>        lpDD-&gt;lpVtbl-&gt;Release( lpDD ); <br> <br>     // clean up DirectInput objects <br>     CleanupInput(); <br> <br>    // <br>    // warn user if there is one <br>    // <br> <br>    if( !bStress ) <br>    { <br>        MessageBox( hWndMain, err, "ERROR", MB_OK ); <br>    } <br>    return FALSE; <br>} <br> <br>void bltSplash( void ) <br>{ <br>    HRESULT     ddrval; <br>    HBITMAP     hbm; <br> <br>    // set the palette before loading the splash screen <br>    lpFrontBuffer-&gt;lpVtbl-&gt;SetPalette( lpFrontBuffer, lpSplashPalette ); <br> <br>    hbm = (HBITMAP)LoadImage( GetModuleHandle( NULL ), "SPLASH", IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION ); <br>    if ( NULL == hbm ) <br>return; <br> <br>    // if the surface is lost, DDCopyBitmap will fail and the surface will <br>    // be restored in FlipScreen. <br>    ddrval = DDCopyBitmap( lpBackBuffer, hbm, 0, 0, 0, 0 ); <br> <br>    DeleteObject( hbm ); <br> <br>    FlipScreen(); <br>} <br> <br>#ifdef USE_DSOUND <br>// <br>// play a sound, but first set the panning according to where the <br>// object is on the screen.  fake 3D sound. <br>// <br>void playPanned(HSNDOBJ hSO, DBLNODE *object) <br>{ <br>    IDirectSoundBuffer *pDSB = SndObjGetFreeBuffer(hSO); <br> <br>if(!bWantSound) <br>return;   // No sound our Work is done <br> <br>    if (pDSB) <br>    { <br>switch(ScreenX) <br>{ <br>case 320: <br>    IDirectSoundBuffer_SetPan(pDSB, (LONG)((20000.0 * <br>((object-&gt;dst.right + object-&gt;dst.left) / 2) / 320.0) - 10000.0)); <br>    break; <br>case 640: <br>    IDirectSoundBuffer_SetPan(pDSB, (LONG)((20000.0 * <br>((object-&gt;dst.right + object-&gt;dst.left) / 2) / 640.0) - 10000.0)); <br>    break; <br>case 1024: <br>    IDirectSoundBuffer_SetPan(pDSB, (LONG)((20000.0 * <br>((object-&gt;dst.right + object-&gt;dst.left) / 2) / 1024.0) - 10000.0)); <br>    break; <br>case 1280: <br>    IDirectSoundBuffer_SetPan(pDSB, (LONG)((20000.0 * <br>((object-&gt;dst.right + object-&gt;dst.left) / 2) / 1280.0) - 10000.0)); <br>    break; <br>} <br> <br>        IDirectSoundBuffer_Play(pDSB, 0, 0, 0); <br>    } <br>} <br>#endif <br> <br>void UpdateFrame( void ) <br>{ <br>    switch( ProgramState ) <br>    { <br>        case PS_SPLASH: <br>            // display the splash screen <br>            bltSplash(); <br>            return; <br>        case PS_ACTIVE: <br>            UpdateDisplayList(); <br>            CheckForHits(); <br>            DrawDisplayList(); <br>            if ( isDisplayListEmpty() ) <br>            { <br>#ifdef USE_DSOUND <br>                if(bWantSound) <br>                { <br>                    SndObjStop(hsoEngineIdle); <br>                    SndObjStop(hsoEngineRev); <br>                } <br>#endif <br>                bPlayIdle = FALSE; <br>                bPlayRev = FALSE; <br>                lastThrust = lastShield = FALSE; <br>                ProgramState = PS_BEGINREST; <br>                restCount = GetTickCount(); <br>                initLevel( ++level ); <br>            } <br>            return; <br>        case PS_BEGINREST: <br>#ifdef USE_DSOUND <br>            if(bWantSound) <br>            { <br>                SndObjPlay(hsoBeginLevel, 0); <br>            } <br>#endif <br>            ProgramState = PS_REST; <br>            // <br>            // FALLTHRU <br>            // <br>        case PS_REST: <br>            if( ( GetTickCount() - restCount ) &gt; ShowLevelCount ) <br>            { <br>#ifdef USE_DSOUND <br>                if(bWantSound) <br>                { <br>                    SndObjPlay(hsoEngineIdle, DSBPLAY_LOOPING); <br>                } <br>#endif <br>                bPlayIdle = TRUE; <br>                lastTickCount = GetTickCount(); <br>                ProgramState = PS_ACTIVE; <br>            } <br>            else <br>            { <br>                DisplayLevel(); <br>            } <br>            return; <br>    } <br>} <br> <br>void DisplayLevel( void ) <br>{ <br>    char buf[10]; <br> <br>    EraseScreen(); <br>    buf[0] = 10 + '0'; <br>    buf[1] = 11 + '0'; <br>    buf[2] = 12 + '0'; <br>    buf[3] = 11 + '0'; <br>    buf[4] = 10 + '0'; <br>    buf[5] = '\0'; <br>    bltScore( buf, ScreenX/2-64, ScreenY/2-8 ); <br>    buf[0] = level / 100 + '0'; <br>    buf[1] = level / 10 + '0'; <br>    buf[2] = level % 10 + '0'; <br>    buf[3] = '\0'; <br>    bltScore( buf, ScreenX/2+22, ScreenY/2-8 ); <br>    FlipScreen(); <br>} <br> <br>void bltScore( char *num, int x, int y ) <br>{ <br>    char *c; <br>    RECT    src; <br>    int     i; <br>    HRESULT ddrval; <br> <br>    for(c=num; *c != '\0'; c++) <br>    { <br>        while( 1 ) <br>        { <br>            i = *c - '0'; <br>            src.left = i*16; <br>            src.top = 0; <br>            src.right = src.left + 16; <br>            src.bottom = src.top + 16; <br>            ddrval = lpBackBuffer-&gt;lpVtbl-&gt;BltFast( lpBackBuffer, x, y, lpNum, &amp;src, dwTransType ); <br>            if( ddrval == DD_OK ) <br>            { <br>                break; <br>            } <br>            if( ddrval == DDERR_SURFACELOST ) <br>            { <br>                if( !RestoreSurfaces() ) <br>                    return; <br>            } <br>            if( ddrval != DDERR_WASSTILLDRAWING ) <br>            { <br>                return; <br>            } <br>        } <br>        x += 16; <br>    } <br>} <br> <br>void CheckForHits( void ) <br>{ <br>    LPDBLNODE   bullet, target, save; <br>    int         frame, x, y, l, t; <br>    BOOL        hit; <br> <br>    // update screen rects <br>    target = &amp;DL; <br>    do <br>    { <br>        frame = (DWORD)target-&gt;frame; <br>        switch( target-&gt;type ) <br>        { <br>            case OBJ_DONUT: <br>                target-&gt;dst.left = (DWORD)target-&gt;posx; <br>                target-&gt;dst.top = (DWORD)target-&gt;posy; <br>                target-&gt;dst.right = target-&gt;dst.left + 64; <br>                target-&gt;dst.bottom = target-&gt;dst.top + 64; <br>                target-&gt;src.left = 64 * (frame % 5); <br>                target-&gt;src.top = 64 * (frame /5); <br>                target-&gt;src.right = target-&gt;src.left + 64; <br>                target-&gt;src.bottom = target-&gt;src.top + 64; <br>                break; <br>            case OBJ_PYRAMID: <br>                target-&gt;dst.left = (DWORD)target-&gt;posx; <br>                target-&gt;dst.top = (DWORD)target-&gt;posy; <br>                target-&gt;dst.right = target-&gt;dst.left + 32; <br>                target-&gt;dst.bottom = target-&gt;dst.top + 32; <br>                target-&gt;src.left = 32 * (frame % 10); <br>                target-&gt;src.top = 32 * (frame /10); <br>                target-&gt;src.right = target-&gt;src.left + 32; <br>                target-&gt;src.bottom = target-&gt;src.top + 32; <br>                break; <br>            case OBJ_SPHERE: <br>                target-&gt;dst.left = (DWORD)target-&gt;posx; <br>                target-&gt;dst.top = (DWORD)target-&gt;posy; <br>                target-&gt;dst.right = target-&gt;dst.left + 16; <br>                target-&gt;dst.bottom = target-&gt;dst.top + 16; <br>                target-&gt;src.left = 16 * (frame % 20); <br>                target-&gt;src.top = 16 * (frame /20); <br>                target-&gt;src.right = target-&gt;src.left + 16; <br>                target-&gt;src.bottom = target-&gt;src.top + 16; <br>                break; <br>            case OBJ_CUBE: <br>                target-&gt;dst.left = (DWORD)target-&gt;posx; <br>                target-&gt;dst.top = (DWORD)target-&gt;posy; <br>                target-&gt;dst.right = target-&gt;dst.left + 16; <br>target-&gt;dst.bottom = target-&gt;dst.top + 16; <br>                target-&gt;src.left = 16 * (frame % 20); <br>target-&gt;src.top = 16 * (frame /20); <br>                target-&gt;src.right = target-&gt;src.left + 16; <br>                target-&gt;src.bottom = target-&gt;src.top + 16; <br>                break; <br>            case OBJ_SHIP: <br>                target-&gt;dst.left = (DWORD)target-&gt;posx; <br>                target-&gt;dst.top = (DWORD)target-&gt;posy; <br>                target-&gt;dst.right = target-&gt;dst.left + 32; <br>                target-&gt;dst.bottom = target-&gt;dst.top + 32; <br>if( lastShield ) <br>    target-&gt;src.top = 32 * (frame / 10) + 128; <br>else <br>                    target-&gt;src.top = 32 * (frame /10); <br>                target-&gt;src.left = 32 * (frame % 10); <br>                target-&gt;src.right = target-&gt;src.left + 32; <br>                target-&gt;src.bottom = target-&gt;src.top + 32; <br>                break; <br>    case OBJ_BULLET: <br>        frame = (DWORD)target-&gt;frame/20 % 4; <br>                target-&gt;dst.left = (DWORD)target-&gt;posx; <br>                target-&gt;dst.top = (DWORD)target-&gt;posy; <br>                target-&gt;dst.right = target-&gt;dst.left + 3; <br>                target-&gt;dst.bottom = target-&gt;dst.top + 3; <br>                target-&gt;src.left = BULLET_X + frame*4; <br>                target-&gt;src.top = BULLET_Y; <br>                target-&gt;src.right = target-&gt;src.left + 3; <br>                target-&gt;src.bottom = target-&gt;src.top + 3; <br>                break; <br>        } <br>        target = target-&gt;next; <br>    } <br>    while( target != &amp;DL ); <br> <br>    bullet=&amp;DL; <br>    do <br>    { <br>        hit = FALSE; <br>        if((bullet-&gt;type != OBJ_BULLET) &amp;&amp; (bullet != &amp;DL)) <br>        { <br>            bullet = bullet-&gt;next; <br>            continue; <br>        } <br> <br>        x = (bullet-&gt;dst.left + bullet-&gt;dst.right) / 2; <br>        y = (bullet-&gt;dst.top + bullet-&gt;dst.bottom) / 2; <br>        for(target=DL.next; target != &amp;DL; target = target-&gt;next) <br>        { <br>            if( ( target-&gt;type != OBJ_DONUT ) &amp;&amp; <br>                ( target-&gt;type != OBJ_PYRAMID ) &amp;&amp; <br>                ( target-&gt;type != OBJ_SPHERE ) &amp;&amp; <br>                ( target-&gt;type != OBJ_CUBE ) ) <br>                continue; <br> <br>            if( (x &gt;= target-&gt;dst.left) &amp;&amp; <br>                (x &lt;  target-&gt;dst.right) &amp;&amp; <br>                (y &gt;= target-&gt;dst.top) &amp;&amp; <br>                (y &lt;  target-&gt;dst.bottom) ) <br>            { <br>                if ((bullet != &amp;DL) || !lastShield) <br>                { <br>                    // the bullet hit the target <br>                    switch( target-&gt;type ) <br>                    { <br>                    case OBJ_DONUT: <br>#ifdef USE_DSOUND <br>            if(bWantSound) <br>            { <br>                        playPanned(hsoDonutExplode, target); <br>} <br>#endif <br>                        addObject( OBJ_PYRAMID, target-&gt;dst.left, <br>                            target-&gt;dst.top, -1.0, -1.0 ); <br>                        addObject( OBJ_PYRAMID, target-&gt;dst.left, <br>                            target-&gt;dst.top, -1.0, -1.0 ); <br>                        addObject( OBJ_PYRAMID, target-&gt;dst.left, <br>                            target-&gt;dst.top, -1.0, -1.0 ); <br>                        score += 10; <br>                        break; <br>                    case OBJ_PYRAMID: <br>#ifdef USE_DSOUND <br>            if(bWantSound) <br>            { <br>                            playPanned(hsoPyramidExplode, target); <br>} <br>#endif <br>                        addObject( OBJ_SPHERE, target-&gt;dst.left, <br>                            target-&gt;dst.top, -1.0, -1.0 ); <br>                        addObject( OBJ_CUBE, target-&gt;dst.left, <br>                            target-&gt;dst.top, -1.0, -1.0 ); <br>                        addObject( OBJ_CUBE, target-&gt;dst.left, <br>                            target-&gt;dst.top, -1.0, -1.0 ); <br>                        score += 20; <br>                        break; <br>                    case OBJ_CUBE: <br>#ifdef USE_DSOUND <br>            if(bWantSound) <br>            { <br>                            playPanned(hsoCubeExplode, target); <br>} <br>#endif <br>                        addObject( OBJ_SPHERE, target-&gt;dst.left, <br>                            target-&gt;dst.top, -1.0, -1.0 ); <br>                        addObject( OBJ_SPHERE, target-&gt;dst.left, <br>                            target-&gt;dst.top, -1.0, -1.0 ); <br>                        break; <br>                        score += 40; <br>                    case OBJ_SPHERE: <br>#ifdef USE_DSOUND <br>            if(bWantSound) <br>            { <br>                            playPanned(hsoSphereExplode, target); <br>} <br>#endif <br>                        score += 20; <br>                    } <br> <br>                    l = target-&gt;dst.left; <br>                    t = target-&gt;dst.top; <br>                    DeleteFromList( target ); <br>                } <br> <br>                hit = TRUE; <br>            } <br> <br>            if( hit ) <br>            { <br>                if( bullet == &amp;DL ) <br>                { <br>                    hit = FALSE; <br>                    if (!lastShield &amp;&amp; !showDelay &amp;&amp; !bTest) <br>                    { <br>#ifdef USE_DSOUND <br>            if(bWantSound) <br>            { <br>                            playPanned(hsoShipExplode, bullet); <br>} <br>#endif <br>                        score -= 150; <br>                        if (score &lt; 0) <br>                            score = 0; <br> <br>                        addObject( OBJ_SPHERE, l, t, -1.0, -1.0 ); <br>                        addObject( OBJ_SPHERE, l, t, -1.0, -1.0 ); <br>                        addObject( OBJ_SPHERE, l, t, -1.0, -1.0 ); <br>addObject( OBJ_SPHERE, l, t, -1.0, -1.0 ); <br>addObject( OBJ_BULLET, l, t, <br>                            randDouble( -0.5, 0.5 ), randDouble( -0.5, 0.5 ) ); <br>addObject( OBJ_BULLET, l, t, <br>                            randDouble( -0.5, 0.5 ), randDouble( -0.5, 0.5 ) ); <br>addObject( OBJ_BULLET, l, t, <br>                            randDouble( -0.5, 0.5 ), randDouble( -0.5, 0.5 ) ); <br>addObject( OBJ_BULLET, l, t, <br>                            randDouble( -0.5, 0.5 ), randDouble( -0.5, 0.5 ) ); <br>addObject( OBJ_BULLET, l, t, <br>                            randDouble( -0.5, 0.5 ), randDouble( -0.5, 0.5 ) ); <br>addObject( OBJ_BULLET, l, t, <br>                            randDouble( -0.5, 0.5 ), randDouble( -0.5, 0.5 ) ); </code></pre>
<p>
</p>
<pre><code>addObject( OBJ_BULLET, l, t, <br>                            randDouble( -0.5, 0.5 ), randDouble( -0.5, 0.5 ) ); <br>addObject( OBJ_BULLET, l, t, <br>                            randDouble( -0.5, 0.5 ), randDouble( -0.5, 0.5 ) ); <br>addObject( OBJ_BULLET, l, t, <br>                            randDouble( -0.5, 0.5 ), randDouble( -0.5, 0.5 ) ); <br>addObject( OBJ_BULLET, l, t, <br>                            randDouble( -0.5, 0.5 ), randDouble( -0.5, 0.5 ) ); <br>initShip(TRUE); <br>                    } <br>                } <br> <br>                break; <br>            } <br>        } <br> <br>        if( hit ) <br>        { <br>            save = bullet; <br>            bullet = bullet-&gt;next; <br> <br>            DeleteFromList( save ); <br>        } <br>        else <br>        { <br>            bullet = bullet-&gt;next; <br>        } <br> <br>    } while (bullet != &amp;DL); <br>} <br> <br>void EraseScreen( void ) <br>{ <br>    DDBLTFX     ddbltfx; <br>    HRESULT     ddrval; <br> <br>    // iForceErase forces us to erase so we can get of stray GDI pixels <br>    if (iForceErase) <br>    { <br>        iForceErase--; <br>    } <br>    else if( bSpecialEffects )   // cool looking screen with no colorfill <br>    { <br>        return; <br>    } <br> <br>    // Erase the background <br>    ddbltfx.dwSize = sizeof( ddbltfx ); <br>    ddbltfx.dwFillColor = dwFillColor; <br>    while( 1 ) <br>    { <br>        ddrval = lpBackBuffer-&gt;lpVtbl-&gt;Blt( lpBackBuffer, NULL, NULL, <br>                 NULL, DDBLT_COLORFILL, &amp;ddbltfx ); <br> <br>        if( ddrval == DD_OK ) <br>        { <br>            break; <br>        } <br>        if( ddrval == DDERR_SURFACELOST ) <br>        { <br>            if( !RestoreSurfaces() ) <br>                return; <br>        } <br>        if( ddrval != DDERR_WASSTILLDRAWING ) <br>        { <br>            return; <br>        } <br>    } <br>} <br> <br>void FlipScreen( void ) <br>{ <br>    HRESULT     ddrval; <br> <br>    // Flip the surfaces <br>    while( 1 ) <br>    { <br>        ddrval = lpFrontBuffer-&gt;lpVtbl-&gt;Flip( lpFrontBuffer, NULL, 0 ); <br>        if( ddrval == DD_OK ) <br>        { <br>            break; <br>        } <br>        if( ddrval == DDERR_SURFACELOST ) <br>        { <br>            if( !RestoreSurfaces() ) <br>            { <br>                return; <br>            } <br>        } <br>        if( ddrval != DDERR_WASSTILLDRAWING ) <br>        { <br>            break; <br>        } <br>    } <br>} <br> <br>void DrawDisplayList( void ) <br>{ <br>    LPDBLNODE   this; <br>    LPDBLNODE   last; <br>    HRESULT     ddrval; <br>    char        scorebuf[11]; <br>    int         rem; <br> <br>    // blt everything in reverse order if we are doing destination transparency <br>    // calculate score string <br>    scorebuf[0] = score/10000000 + '0'; <br>    rem = score % 10000000; <br>    scorebuf[1] = rem/1000000 + '0'; <br>    rem = score % 1000000; <br>    scorebuf[2] = rem/100000 + '0'; <br>    rem = score % 100000; <br>    scorebuf[3] = rem/10000 + '0'; <br>    rem = score % 10000; <br>    scorebuf[4] = rem/1000 + '0'; <br>    rem = score % 1000; <br>    scorebuf[5] = rem/100 + '0'; <br>    rem = score % 100; <br>    scorebuf[6] = rem/10 + '0'; <br>    rem = score % 10; <br>    scorebuf[7] = rem + '0'; <br>#ifdef USE_DSOUND <br>    if( bSoundEnabled ) <br>    { <br>    scorebuf[8] = 14 + '0'; <br>    scorebuf[9] = 13 + '0'; <br>    scorebuf[10] = '\0'; <br>    } <br>    else <br>#endif <br>    { <br>        scorebuf[8] = '\0'; <br>    } <br> <br>    EraseScreen(); <br>    if( dwTransType == DDBLTFAST_DESTCOLORKEY ) <br>    { <br>        bltScore(scorebuf, 10, ScreenY-26); <br> <br>        if( bShowFrameCount ) <br>    DisplayFrameRate(); <br> <br>this = DL.next; // start with the topmost bitmap <br>last = DL.next; // don't blt it twice <br> <br>        if (showDelay) <br>            last = &amp;DL; <br>    } <br>    else <br>    { <br>this = &amp;DL;// start with the bottommost bitmap (the ship) <br>last = &amp;DL;// don't blt it twice <br> <br>        if (showDelay) <br>    this = this-&gt;prev; <br>    } <br> <br>    do <br>    { <br>        while( 1 ) <br>{ <br>    ddrval = lpBackBuffer-&gt;lpVtbl-&gt;BltFast( lpBackBuffer, this-&gt;dst.left, this-&gt;dst.top, this-&gt;surf, &amp;(this-&gt;src), dwTransType ); <br>            if( ddrval == DD_OK ) <br>            { <br>                break; <br>            } <br>            if( ddrval == DDERR_SURFACELOST ) <br>            { <br>                if( !RestoreSurfaces() ) <br>                    return; <br>            } <br>            if( ddrval != DDERR_WASSTILLDRAWING ) <br>            { <br>                return; <br>            } <br>} <br>if( dwTransType != DDBLTFAST_DESTCOLORKEY ) <br>{ <br>    this = this-&gt;prev; <br>} <br>else <br>{ <br>    this = this-&gt;next; <br>} <br>    } <br>    while( this != last ); <br> <br>    if( dwTransType != DDBLTFAST_DESTCOLORKEY ) <br>    { <br>        bltScore(scorebuf, 10, ScreenY-26); <br> <br>        if( bShowFrameCount ) <br>    DisplayFrameRate(); <br>    } <br> <br>    FlipScreen(); <br>} <br> <br>void DisplayFrameRate( void ) <br>{ <br>    DWORD               time2; <br>    char                buff[256]; <br> <br>    dwFrameCount++; <br>    time2 = timeGetTime() - dwFrameTime; <br>    if( time2 &gt; 1000 ) <br>    { <br>        dwFrames = (dwFrameCount*1000)/time2; <br>        dwFrameTime = timeGetTime(); <br>        dwFrameCount = 0; <br>    } <br>    if( dwFrames == 0 ) <br>    { <br>        return; <br>    } <br> <br>    if (dwFrames != dwFramesLast) <br>    { <br>        dwFramesLast = dwFrames; <br>    } <br> <br>    if( dwFrames &gt; 99 ) <br>    { <br>dwFrames = 99; <br>    } <br>    buff[0] = (char)((dwFrames / 10) + '0'); <br>    buff[1] = (char)((dwFrames % 10) + '0'); <br>    buff[2] = '\0'; <br>    bltScore(buff, ScreenX/2-25, 10); <br>} <br> <br>void DeleteFromList( LPDBLNODE this ) <br>{ <br>    this-&gt;next-&gt;prev = this-&gt;prev; <br>    this-&gt;prev-&gt;next = this-&gt;next; <br>    LocalFree( this ); <br>} <br> <br>void UpdateDisplayList( void ) <br>{ <br>    LPDBLNODE   this; <br>    LPDBLNODE   save; <br>    DWORD       thisTickCount = GetTickCount(); <br>    DWORD       tickDiff = thisTickCount - lastTickCount; <br>    double      maxx, maxy; <br>    double      maxframe; <br>    DWORD       input; <br>    BOOL        event = FALSE; <br> <br>    if( bTest ) <br>    { <br>        input |= (KEY_RIGHT | KEY_FIRE); <br>    } <br>    lastTickCount = thisTickCount; <br> <br>    input = ReadGameInput(); <br> <br>    if (showDelay) <br>    { <br>        showDelay -= (int)tickDiff; <br>        if (showDelay &lt; 0) <br>        { <br>            showDelay = 0; <br>            lastShield = FALSE; <br>    initShip( FALSE ); <br>        } <br>    } <br> <br>    // update the ship <br>    if( !showDelay ) <br>    { <br>        DL.posx += DL.velx * (double)tickDiff; <br>        DL.posy += DL.vely * (double)tickDiff; <br>    } <br>    if( DL.posx &gt; MAX_SHIP_X ) <br>    { <br>        DL.posx = MAX_SHIP_X; <br>        DL.velx = -DL.velx; <br>        event = TRUE; <br>    } <br>    else if ( DL.posx &lt; 0 ) <br>    { <br>        DL.posx =0; <br>        DL.velx = -DL.velx; <br>        event = TRUE; <br>    } <br>    if( DL.posy &gt; MAX_SHIP_Y ) <br>    { <br>        DL.posy = MAX_SHIP_Y; <br>        DL.vely = -DL.vely; <br>        event = TRUE; <br>    } <br>    else if ( DL.posy &lt; 0 ) <br>    { <br>        DL.posy =0; <br>        DL.vely = -DL.vely; <br>        event = TRUE; <br>    } <br>    if (event) <br>    { <br>#ifdef USE_DSOUND <br>        if(bWantSound) <br>        { <br>            playPanned(hsoShipBounce, &amp;DL); <br>} <br>#endif <br>        event = FALSE; <br>    } <br> <br>    if ((event = (showDelay || ((input &amp; KEY_SHIELD) == KEY_SHIELD))) != <br>        lastShield) <br>    { <br>        if (event &amp;&amp; !showDelay) <br>{ <br>#ifdef USE_DSOUND <br>        if(bWantSound) <br>        { <br>            SndObjPlay(hsoShieldBuzz, DSBPLAY_LOOPING); <br>} <br>#endif <br>    bPlayBuzz = TRUE; <br>} <br>        else <br>{ <br>#ifdef USE_DSOUND <br>        if(bWantSound) <br>        { <br>                SndObjStop(hsoShieldBuzz); <br>} <br>#endif <br>        bPlayBuzz = FALSE; <br>    } <br>        lastShield = event; <br>    } <br>    if (event) <br>    { <br>        input &amp;= ~(KEY_FIRE); <br>    } <br> <br>    if (input &amp; KEY_FIRE) <br>    { <br>if( !showDelay ) <br>{ <br>            // add a bullet to the scene <br>            score--; <br>            if(score &lt; 0) <br>                score = 0; <br> <br>#ifdef USE_DSOUND <br>        if(bWantSound) <br>        { <br>                SndObjPlay(hsoFireBullet, 0); <br>} <br>#endif <br>            addObject( OBJ_BULLET, Dirx[(int)DL.frame]*6.0 + 16.0 + DL.posx, <br>                                   Diry[(int)DL.frame]*6.0 + 16.0 + DL.posy, <br>                                   Dirx[(int)DL.frame]*500.0/1000.0, <br>   Diry[(int)DL.frame]*500.0/1000.0 ); <br>        } <br>    } <br> <br>    event = FALSE; <br>    if( input &amp; KEY_LEFT ) <br>    { <br>            DL.frame -= 1.0; <br>            if( DL.frame &lt; 0.0 ) <br>                DL.frame += MAX_SHIP_FRAME; <br>    } <br>    if( input &amp; KEY_RIGHT ) <br>    { <br>            DL.frame += 1.0; <br>            if( DL.frame &gt;= MAX_SHIP_FRAME) <br>                DL.frame -= MAX_SHIP_FRAME; <br>    } <br>    if( input &amp; KEY_UP ) <br>    { <br>            DL.velx += Dirx[(int)DL.frame] * 10.0/1000.0; <br>            DL.vely += Diry[(int)DL.frame] * 10.0/1000.0; <br>            event = TRUE; <br>    } <br>    if( input &amp; KEY_DOWN ) <br>    { <br>            DL.velx -= Dirx[(int)DL.frame] * 10.0/1000.0; <br>            DL.vely -= Diry[(int)DL.frame] * 10.0/1000.0; <br>            event = TRUE; <br>    } <br> <br>    if (event != lastThrust) <br>    { <br>        if (event) <br>        { <br>            input &amp;= ~KEY_STOP; <br>#ifdef USE_DSOUND <br>            if(bWantSound) <br>            { <br>                SndObjStop(hsoSkidToStop); <br>                SndObjPlay(hsoEngineRev, DSBPLAY_LOOPING); <br>} <br>#endif <br>    bPlayRev = TRUE; <br>        } <br>        else <br>        { <br>#ifdef USE_DSOUND <br>        if(bWantSound) <br>        { <br>        SndObjStop(hsoEngineRev); <br>} <br>#endif <br>    bPlayRev = FALSE; <br>        } <br> <br>        lastThrust = event; <br>    } <br> <br>    if( input &amp; KEY_STOP ) <br>    { <br>#ifdef USE_DSOUND <br>        if(bWantSound) <br>        { <br>        if (DL.velx || DL.vely) <br>            playPanned(hsoSkidToStop, &amp;DL); <br>} <br>#endif <br> <br>        DL.velx = 0; <br>        DL.vely = 0; <br>    } <br> <br>    this = DL.next; <br>    do <br>    { <br>        this-&gt;posx += this-&gt;velx * (double)tickDiff; <br>        this-&gt;posy += this-&gt;vely * (double)tickDiff; <br>        this-&gt;frame += this-&gt;delay * (double)tickDiff; <br>        switch( this-&gt;type ) <br>        { <br>            case OBJ_DONUT: <br>                maxx = (double)MAX_DONUT_X; <br>                maxy = (double)MAX_DONUT_Y; <br>                maxframe = (double)MAX_DONUT_FRAME; <br>                break; <br>            case OBJ_PYRAMID: <br>                maxx = (double)MAX_PYRAMID_X; <br>                maxy = (double)MAX_PYRAMID_Y; <br>                maxframe = (double)MAX_PYRAMID_FRAME; <br>                break; <br>            case OBJ_SPHERE: <br>                maxx = (double)MAX_SPHERE_X; <br>                maxy = (double)MAX_SPHERE_Y; <br>                maxframe = (double)MAX_SPHERE_FRAME; <br>                break; <br>            case OBJ_CUBE: <br>                maxx = (double)MAX_CUBE_X; <br>                maxy = (double)MAX_CUBE_Y; <br>                maxframe = (double)MAX_CUBE_FRAME; <br>                break; <br>            case OBJ_BULLET: <br>                maxx = (double)MAX_BULLET_X; <br>                maxy = (double)MAX_BULLET_Y; <br>                maxframe = (double)MAX_BULLET_FRAME; <br>                if( this-&gt;frame &gt;= (double)MAX_BULLET_FRAME ) <br>                { <br>                    save = this; <br>                    this = this-&gt;next; <br>                    DeleteFromList( save ); <br>    continue; <br>                } <br>                break; <br>        } <br>        if( this != &amp;DL ) <br>        { <br>            if( this-&gt;posx &gt; maxx ) <br>            { <br>                this-&gt;posx = maxx; <br>                this-&gt;velx = -this-&gt;velx; <br>            } <br>            else if ( this-&gt;posx &lt; 0 ) <br>            { <br>                this-&gt;posx =0; <br>                this-&gt;velx = -this-&gt;velx; <br>            } <br>            if( this-&gt;posy &gt; maxy ) <br>            { <br>                this-&gt;posy = maxy; <br>                this-&gt;vely = -this-&gt;vely; <br>            } <br>            else if ( this-&gt;posy &lt; 0 ) <br>            { <br>                this-&gt;posy =0; <br>                this-&gt;vely = -this-&gt;vely; <br>            } <br>            if( this-&gt;frame &gt;= maxframe ) <br>            { <br>                this-&gt;frame -= maxframe; <br>            } <br>            this = this-&gt;next; <br>        } <br>    } <br>    while( this != &amp;DL ); <br>} <br> <br>BOOL isDisplayListEmpty( void ) <br>{ <br>    LPDBLNODE ptr; <br> <br>    for(ptr=DL.next; ptr != &amp;DL; ptr = ptr-&gt;next) <br>    { <br>        if(ptr-&gt;type != OBJ_BULLET) <br>            return FALSE; <br>    } <br>    return TRUE; <br>} <br> <br>void initShip( BOOL delay ) <br>{ <br>    DL.posx = (double)(ScreenX/2-16);    // center the ship <br>    DL.posy = (double)(ScreenY/2-16); <br>    DL.frame = 0.0; <br>    if( bTest ) <br>    { <br>        DL.velx = 0.25; <br>DL.vely = 0.5; <br>    } <br>    else <br>    { <br>        DL.velx = DL.vely = 0.0;// not moving <br>    } <br>    if( !bTest &amp;&amp; delay ) <br>    showDelay = DEF_SHOW_DELAY; <br>} <br> <br>void initLevel( int level ) <br>{ <br>    int     i; <br> <br>    // clear any stray bullets out of the display list <br>    while( DL.next != &amp;DL ) <br>    { <br>        DeleteFromList( DL.next ); <br>    } <br>    for(i=0; i&lt;(2*level-1); i++) <br>    { <br>        addObject( OBJ_DONUT, -1.0, -1.0, -1.0, -1.0 ); <br>    } <br>    initShip(TRUE); <br>} <br> <br>void addObject( SHORT type, double x, double y, double vx, double vy ) <br>{ <br>    LPDBLNODE   new; <br> <br>    new = (LPDBLNODE) LocalAlloc( LPTR, sizeof( DBLNODE ) ); <br>    if( new == NULL) <br>        return; <br> <br>    new-&gt;type = type; <br>    switch( type ) <br>    { <br>        case OBJ_DONUT: <br>            if( x &lt; 0.0) // no position specified? <br>            { <br>                new-&gt;posx = randDouble( 0.0, (double)MAX_DONUT_X ); <br>                new-&gt;posy = randDouble( 0.0, (double)MAX_DONUT_Y ); <br>            } <br>            else <br>            { <br>                new-&gt;posx = x; <br>                new-&gt;posy = y; <br>            } <br>            new-&gt;velx = randDouble( -50.0/1000.0, 50.0/1000.0 ); <br>            new-&gt;vely = randDouble( -50.0/1000.0, 50.0/1000.0 ); <br>            new-&gt;frame = randDouble( 0, 30 ); <br>            new-&gt;delay = 30.0*randDouble( 0.1, 0.4 )/1000.0; <br>    new-&gt;surf = lpDonut; <br>    linkObject( new ); <br>            break; <br>        case OBJ_PYRAMID: <br>            if( x &lt; 0) // no position specified? <br>            { <br>                new-&gt;posx = randDouble( 0.0, (double)MAX_PYRAMID_X ); <br>                new-&gt;posy = randDouble( 0.0, (double)MAX_PYRAMID_Y ); <br>            } <br>            else <br>            { <br>                new-&gt;posx = x; <br>                new-&gt;posy = y; <br>            } <br>            new-&gt;velx = 1.5*randDouble( -50.0/1000.0, 50.0/1000.0 ); <br>            new-&gt;vely = 1.5*randDouble( -50.0/1000.0, 50.0/1000.0 ); <br>            new-&gt;frame = randDouble( 0, 30 ); <br>            new-&gt;delay = 40.0*randDouble( 0.3, 1.0 )/1000.0; <br>    new-&gt;surf = lpPyramid; <br>            linkObject( new ); <br>            break; <br>        case OBJ_SPHERE: <br>            if( x &lt; 0) // no position specified? <br>            { <br>                new-&gt;posx = randDouble( 0.0, (double)MAX_SPHERE_X ); <br>                new-&gt;posy = randDouble( 0.0, (double)MAX_SPHERE_Y ); <br>            } <br>            else <br>            { <br>                new-&gt;posx = x; <br>                new-&gt;posy = y; <br>            } <br>            new-&gt;velx = 3.0*randDouble( -50.0/1000.0, 50.0/1000.0 ); <br>            new-&gt;vely = 3.0*randDouble( -50.0/1000.0, 50.0/1000.0 ); <br>            new-&gt;frame = randDouble( 0, 30 ); <br>            new-&gt;delay = 40.0*randDouble( 1.5, 2.0 )/1000.0; <br>    new-&gt;surf = lpSphere; <br>            linkObject( new ); <br>            break; <br>        case OBJ_CUBE: <br>            if( x &lt; 0) // no position specified? <br>            { <br>                new-&gt;posx = randDouble( 0.0, (double)MAX_CUBE_X ); <br>                new-&gt;posy = randDouble( 0.0, (double)MAX_CUBE_Y ); <br>            } <br>            else <br>            { <br>                new-&gt;posx = x; <br>                new-&gt;posy = y; <br>            } <br>            new-&gt;velx = 4.0*randDouble( -50.0/1000.0, 50.0/1000.0 ); <br>            new-&gt;vely = 4.0*randDouble( -50.0/1000.0, 50.0/1000.0 ); <br>            new-&gt;frame = randDouble( 0, 30 ); <br>            new-&gt;delay = 40.0*randDouble( 0.8, 2.0 )/1000.0; <br>    new-&gt;surf = lpCube; <br>            linkObject( new ); <br>            break; <br>        case OBJ_BULLET: <br>            new-&gt;posx = x; <br>            new-&gt;posy = y; <br>            new-&gt;velx = vx; <br>            new-&gt;vely = vy; <br>            new-&gt;frame = 0.0; <br>            new-&gt;delay = 1.0; <br>    new-&gt;surf = lpNum; <br>            linkObject( new ); <br>            break; <br>    } <br>} <br> <br>void linkObject( LPDBLNODE new ) <br>{ <br>    new-&gt;next = DL.next; <br>    new-&gt;prev = &amp;DL; <br>    DL.next-&gt;prev = new; <br>    DL.next = new; <br>} <br> <br>void linkLastObject( LPDBLNODE new ) <br>{ <br>    new-&gt;prev = DL.prev; <br>    new-&gt;next = &amp;DL; <br>    DL.prev-&gt;next = new; <br>    DL.prev = new; <br>} <br> <br> <br>BOOL RestoreSurfaces( void ) <br>{ <br>    HRESULTddrval; <br>    HBITMAP     hbm; <br> <br>    ddrval = lpFrontBuffer-&gt;lpVtbl-&gt;Restore(lpFrontBuffer); <br>    if( ddrval != DD_OK ) <br>        return FALSE; <br>    ddrval = lpDonut-&gt;lpVtbl-&gt;Restore(lpDonut); <br>    if( ddrval != DD_OK ) <br>        return FALSE; <br>    ddrval = lpPyramid-&gt;lpVtbl-&gt;Restore(lpPyramid); <br>    if( ddrval != DD_OK ) <br>        return FALSE; <br>    ddrval = lpCube-&gt;lpVtbl-&gt;Restore(lpCube); <br>    if( ddrval != DD_OK ) <br>        return FALSE; <br>    ddrval = lpSphere-&gt;lpVtbl-&gt;Restore(lpSphere); <br>    if( ddrval != DD_OK ) <br>        return FALSE; <br>    ddrval = lpShip-&gt;lpVtbl-&gt;Restore(lpShip); <br>    if( ddrval != DD_OK ) <br>        return FALSE; <br>    ddrval = lpNum-&gt;lpVtbl-&gt;Restore(lpNum); <br>    if( ddrval != DD_OK ) <br>        return FALSE; <br> <br>    // Create and set the palette for the splash bitmap <br>    lpSplashPalette = DDLoadPalette( lpDD, "SPLASH" ); <br>    if( NULL == lpSplashPalette ) <br>        return CleanupAndExit("DDLoadPalette SPLASH"); <br> <br>    // Create and set the palette for the art bitmap <br>    lpArtPalette = DDLoadPalette( lpDD, "DONUTS8" ); <br>    if( NULL == lpArtPalette ) <br>        return CleanupAndExit("DDLoadPalette DONUTS"); <br> <br>    // set the palette before loading the art <br>    lpFrontBuffer-&gt;lpVtbl-&gt;SetPalette( lpFrontBuffer, lpArtPalette ); <br> <br>    hbm = (HBITMAP)LoadImage(GetModuleHandle(NULL), "DONUTS8", IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION ); <br> <br>    if( NULL == hbm ) <br>        return FALSE; <br> <br>    ddrval = DDCopyBitmap( lpDonut, hbm, 0, 0, 320, 384 ); <br>    if( ddrval != DD_OK ) <br>    { <br>        DeleteObject( hbm ); <br>        return FALSE; <br>    } <br> <br>    // NOTE: Why are we calling LoadImage again?  StretchBlt (which is <br>    // called in DDCopyBitmap) does not work properly when performing <br>    // an 8-bpp to 24- or 32-bpp blt multiple times from the same <br>    // bitmap.  The workaround is to call LoadImage before each <br>    // StretchBlt because the first StretchBlt after a LoadImage will <br>    // work. <br>    if(ScreenBpp &gt;= 24) <br>    { <br>DeleteObject( hbm ); <br>hbm = (HBITMAP)LoadImage(GetModuleHandle(NULL), "DONUTS8", IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION ); <br> <br>if( NULL == hbm ) <br>    return FALSE; <br>    } <br> <br>    ddrval = DDCopyBitmap( lpPyramid, hbm, 0, 384, 320, 128 ); <br>    if( ddrval != DD_OK ) <br>    { <br>        DeleteObject( hbm ); <br>        return FALSE; <br>    } <br> <br>    if(ScreenBpp &gt;= 24) <br>    { <br>DeleteObject( hbm ); <br>hbm = (HBITMAP)LoadImage(GetModuleHandle(NULL), "DONUTS8", IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION ); <br> <br>if( NULL == hbm ) <br>    return FALSE; <br>    } <br> <br>    ddrval = DDCopyBitmap( lpSphere, hbm, 0, 512, 320, 32 ); <br>    if( ddrval != DD_OK ) <br>    { <br>        DeleteObject( hbm ); <br>        return FALSE; <br>    } <br> <br>    if(ScreenBpp &gt;= 24) <br>    { <br>DeleteObject( hbm ); <br>hbm = (HBITMAP)LoadImage(GetModuleHandle(NULL), "DONUTS8", IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION ); <br> <br>if( NULL == hbm ) <br>    return FALSE; <br>    } <br> <br>    ddrval = DDCopyBitmap( lpCube, hbm, 0, 544, 320, 32 ); <br>    if( ddrval != DD_OK ) <br>    { <br>        DeleteObject( hbm ); <br>        return FALSE; <br>    } <br> <br>    if(ScreenBpp &gt;= 24) <br>    { <br>DeleteObject( hbm ); <br>hbm = (HBITMAP)LoadImage(GetModuleHandle(NULL), "DONUTS8", IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION ); <br> <br>if( NULL == hbm ) <br>    return FALSE; <br>    } <br> <br>    ddrval = DDCopyBitmap( lpShip, hbm, 0, 576, 320, 256 ); <br>    if( ddrval != DD_OK ) <br>    { <br>        DeleteObject( hbm ); <br>        return FALSE; <br>    } <br> <br>    if(ScreenBpp &gt;= 24) <br>    { <br>DeleteObject( hbm ); <br>hbm = (HBITMAP)LoadImage(GetModuleHandle(NULL), "DONUTS8", IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION ); <br> <br>if( NULL == hbm ) <br>    return FALSE; <br>    } <br> <br>    ddrval = DDCopyBitmap( lpNum, hbm, 0, 832, 320, 16 ); <br>    if( ddrval != DD_OK ) <br>    { <br>        DeleteObject( hbm ); <br>        return FALSE; <br>    } <br> <br>    DeleteObject( hbm ); <br> <br>    // set colorfill colors and color keys according to bitmap contents <br>    dwFillColor = DDColorMatch( lpDonut, CLR_INVALID ); <br> <br>    DDSetColorKey( lpDonut, CLR_INVALID ); <br>    DDSetColorKey( lpPyramid, CLR_INVALID ); <br>    DDSetColorKey( lpCube, CLR_INVALID ); <br>    DDSetColorKey( lpSphere, CLR_INVALID ); <br>    DDSetColorKey( lpShip, CLR_INVALID ); <br>    DDSetColorKey( lpNum, CLR_INVALID ); <br> <br>    return TRUE; <br>} <br> <br> <br>int randInt( int low, int high ) <br>{ <br>    int range = high - low; <br>    int num = rand() % range; <br>    return( num + low ); <br>} <br> <br>double randDouble( double low, double high ) <br>{ <br>    double range = high - low; <br>    double num = range * (double)rand()/(double)RAND_MAX; <br>    return( num + low ); <br>} <br> <br>#ifdef USE_DSOUND <br>void InitializeSound( void ) <br>{ <br>if(!bWantSound) <br>return; // out of here <br>    bSoundEnabled = FALSE; <br>    if (SUCCEEDED(DirectSoundCreate(NULL, &amp;lpDS, NULL))) <br>    { <br>        if (SUCCEEDED(lpDS-&gt;lpVtbl-&gt;SetCooperativeLevel(lpDS, hWndMain, <br>            DSSCL_NORMAL))) <br>        { <br>            hsoBeginLevel     = SndObjCreate(lpDS, "BeginLevel",      1); <br>            hsoEngineIdle     = SndObjCreate(lpDS, "EngineIdle",      1); <br>            hsoEngineRev      = SndObjCreate(lpDS, "EngineRev",       1); <br>            hsoSkidToStop     = SndObjCreate(lpDS, "SkidToStop",      1); <br>            hsoShieldBuzz     = SndObjCreate(lpDS, "ShieldBuzz",      1); <br>            hsoShipExplode    = SndObjCreate(lpDS, "ShipExplode",     1); <br>            hsoFireBullet     = SndObjCreate(lpDS, "Gunfire",        25); <br>            hsoShipBounce     = SndObjCreate(lpDS, "ShipBounce",      4); <br>            hsoDonutExplode   = SndObjCreate(lpDS, "DonutExplode",   10); <br>            hsoPyramidExplode = SndObjCreate(lpDS, "PyramidExplode", 12); <br>            hsoCubeExplode    = SndObjCreate(lpDS, "CubeExplode",    15); <br>            hsoSphereExplode  = SndObjCreate(lpDS, "SphereExplode",  10); <br>            bSoundEnabled = TRUE; <br> <br>//#ifdef USE_DSOUND   this should be dead code Josephc <br>            if( bPlayIdle ) <br>                SndObjPlay(hsoEngineIdle, DSBPLAY_LOOPING); <br> <br>            if( bPlayBuzz ) <br>                SndObjPlay(hsoShieldBuzz, DSBPLAY_LOOPING); <br> <br>            if( bPlayRev ) <br>                SndObjPlay(hsoEngineRev, DSBPLAY_LOOPING); <br>//#endif <br>        } <br>        else <br>        { <br>            lpDS-&gt;lpVtbl-&gt;Release(lpDS); <br>            lpDS = NULL; <br>        } <br>    } <br>} <br> <br>void DestroySound( void ) <br>{ <br>if(!bWantSound) <br>return; //No work to be done <br>    bSoundEnabled = FALSE; <br>    if (lpDS) <br>    { <br>        SndObjDestroy(hsoBeginLevel); <br>        hsoBeginLevel = NULL; <br>        SndObjDestroy(hsoEngineIdle); <br>        hsoEngineIdle = NULL; <br>        SndObjDestroy(hsoEngineRev); <br>        hsoEngineRev = NULL; <br>        SndObjDestroy(hsoSkidToStop); <br>        hsoSkidToStop = NULL; <br>        SndObjDestroy(hsoShieldBuzz); <br>        hsoShieldBuzz = NULL; <br>        SndObjDestroy(hsoShipExplode); <br>        hsoShipExplode = NULL; <br>        SndObjDestroy(hsoFireBullet); <br>        hsoFireBullet = NULL; <br>        SndObjDestroy(hsoShipBounce); <br>        hsoShipBounce = NULL; <br>        SndObjDestroy(hsoDonutExplode); <br>        hsoDonutExplode = NULL; <br>        SndObjDestroy(hsoPyramidExplode); <br>        hsoPyramidExplode = NULL; <br>        SndObjDestroy(hsoCubeExplode); <br>        hsoCubeExplode = NULL; <br>        SndObjDestroy(hsoSphereExplode); <br>        hsoSphereExplode = NULL; <br> <br>        lpDS-&gt;lpVtbl-&gt;Release(lpDS); <br>        lpDS = NULL; <br>    } <br>} <br>#endif <br> <br>int getint(char**p, int def) <br>{ <br>    int i=0; <br> <br> <br>    while (IS_SPACE(**p)) <br>        (*p)++; <br> <br>    if (!IS_NUM(**p)) <br>        return def; <br> <br>    while (IS_NUM(**p)) <br>        i = i*10 + *(*p)++ - '0'; <br> <br>    while (IS_SPACE(**p)) <br>        (*p)++; <br> <br>    return i; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
