<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MONITOR.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3050"></a>MONITOR.CPP</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1995-1997 Microsoft Corporation. All Rights Reserved. <br> * <br> *  File:       monitor.cpp <br> * <br> *@@BEGIN_MSINTERNAL <br> *  History: <br> *   Date       By        Reason <br> *   ====       ==        ====== <br> *   15-sep-97  t-craigs  Created <br> *@@END_MSINTERNAL <br> * <br> ***************************************************************************/ <br> <br> <br>#define COMPILE_MULTIMON_STUBS <br>#include "monitor.h" <br>#include "util.h" <br> <br>// globals defined here <br>CMyMonitor Monitor[9]; <br> <br>// globals defined elsewhere <br>#ifdef DEBUG <br>externchar    DebugBuf[256]; <br>#endif <br> <br>/* <br> * <br> * CMonitor <br> * <br> */ <br> <br>// static class member initialization <br>intCMonitor::iNumberOfMonitors = 0; <br> <br>// constructor <br>CMonitor::CMonitor() : <br>lpMonitorRect( NULL ), <br>hMonitor( NULL ), <br>dwWidth(0), <br>dwHeight(0), <br>ScreenBpp(0), <br>lpDD(NULL), <br>lpFrontBuffer(NULL), <br>lpBackBuffer(NULL) <br>{ <br>szErrMsg[0] = '\0'; <br>} <br> <br>CMonitor::~CMonitor() <br>{ <br>Release(); <br>delete lpGUID; <br>} <br> <br> <br>// <br>// FUNCTION:EnumDeviceCallback <br>// <br>// DESCRIPTION:Initializes common data of consecutive elements in the global Monitor array <br>// <br>// NOTES:- callback fct for DirectDrawEnumerateEx <br>// <br>BOOL CALLBACK EnumDeviceCallback( GUID* lpGUID, LPSTR szName, LPSTR szDevice, LPVOID lParam, HMONITOR hMonitor ) <br>{ <br>if ( hMonitor != NULL &amp;&amp; CMonitor::iNumberOfMonitors &lt; 9) <br>{ <br>CMonitor&amp; curMonitor = Monitor[CMonitor::iNumberOfMonitors]; <br> <br>curMonitor.hMonitor = hMonitor; <br> <br>if ( lpGUID == NULL ) <br>{ <br>curMonitor.lpGUID = NULL; <br>} <br>else <br>{ <br>curMonitor.lpGUID = new GUID; <br>memcpy( curMonitor.lpGUID, lpGUID, sizeof(GUID) ); <br>} <br> <br>curMonitor.MonitorInfo.cbSize = sizeof(MONITORINFOEX); <br>GetMonitorInfo( hMonitor, (LPMONITORINFOEX)(&amp;curMonitor.MonitorInfo) ); <br> <br>curMonitor.lpMonitorRect = &amp;curMonitor.MonitorInfo.rcMonitor; <br> <br>curMonitor.dwWidth = curMonitor.lpMonitorRect-&gt;right - curMonitor.lpMonitorRect-&gt;left; <br>curMonitor.dwHeight = curMonitor.lpMonitorRect-&gt;bottom - curMonitor.lpMonitorRect-&gt;top; <br> <br>++CMonitor::iNumberOfMonitors; <br> <br>#ifdef DEBUG <br>wsprintf( DebugBuf, "monitor %d: left=%d top=%d right=%d bottom=%d\n", <br>CMonitor::iNumberOfMonitors, <br>curMonitor.lpMonitorRect-&gt;left, <br>curMonitor.lpMonitorRect-&gt;top, <br>curMonitor.lpMonitorRect-&gt;right, <br>curMonitor.lpMonitorRect-&gt;bottom ); <br>OutputDebugString( DebugBuf ); <br>#endif <br>} <br> <br>return TRUE; <br>} <br> <br> <br>// <br>// CLASS:CMonitor <br>// <br>// FUNCTION:Initialize <br>// <br>// DESCRIPTION:Initializes the common data of global Monitor array <br>// <br>// NOTES:- all the work is done in EnumMonitorCallback <br>//- static function <br>// <br>HRESULT CMonitor::Initialize() <br>{ <br>HMODULE hModule; <br>LPDIRECTDRAWENUMERATEEX lpDDEnum; <br> <br>hModule = GetModuleHandle( "ddraw.dll" ); <br>lpDDEnum = (LPDIRECTDRAWENUMERATEEX) GetProcAddress( hModule, "DirectDrawEnumerateExA" ); <br> <br>if ( lpDDEnum == NULL ) <br>{ <br>return DDERR_GENERIC; <br>} <br>else <br>{ <br>lpDDEnum( EnumDeviceCallback, (LPVOID) NULL, DDENUM_ATTACHEDSECONDARYDEVICES ); <br>} <br>return DD_OK; <br>} <br> <br> <br>// <br>// CLASS:CMonitor <br>// <br>// FUNCTION:DDInit <br>// <br>// DESCRIPTION:Basic DirectDraw initialization for this monitor <br>// <br>// NOTES:- creates DirectDraw object and a primary surface with one back buffer <br>//- uses new SetCooperativeLevel flags for multimon fullscreen exclusive <br>// <br>HRESULT CMonitor::DDInit( HWND hWnd, BOOL bEnableMultiMon ) <br>{ <br>DDCAPS          ddcaps; <br>    HRESULT         ddrval; <br>    DDSCAPS         ddscaps; <br>DDSURFACEDESC   ddsd; <br> <br>DirectDrawCreate( lpGUID, &amp;lpDD, NULL); <br>if( lpDD == NULL) <br>    { <br>wsprintf( szErrMsg, "DirectDrawCreate failed"); <br>    return DDERR_GENERIC; <br>    } <br> <br>// SetCooperativeLevel <br>if ( bEnableMultiMon ) <br>{ <br>if ( this == &amp;Monitor[0] ) <br>{ <br>// primary monitor, use focus window as device window <br>ddrval = lpDD-&gt;SetCooperativeLevel( hWnd, DDSCL_SETFOCUSWINDOW ); <br>if ( ddrval != DD_OK ) <br>{ <br>wsprintf( szErrMsg, "SetCooperativeLevel failed"); <br>return ddrval; <br>} <br> <br>ddrval = lpDD-&gt;SetCooperativeLevel( hWnd,  <br>DDSCL_SETDEVICEWINDOW | DDSCL_EXCLUSIVE | DDSCL_FULLSCREEN ); <br>} <br>else <br>{ <br>ddrval = lpDD-&gt;SetCooperativeLevel( hWnd, <br>            DDSCL_SETFOCUSWINDOW |  <br>DDSCL_EXCLUSIVE |  <br>DDSCL_FULLSCREEN |  <br>DDSCL_CREATEDEVICEWINDOW); <br>} <br>} <br>else <br>{ <br>ddrval = lpDD-&gt;SetCooperativeLevel( hWnd, DDSCL_EXCLUSIVE | DDSCL_FULLSCREEN ); <br>} <br>if( ddrval != DD_OK ) <br>{ <br>wsprintf( szErrMsg, "SetCooperativeLevel failed"); <br>    return ddrval; <br>} <br> <br>ddcaps.dwSize = sizeof( ddcaps ); <br> <br>// Create surfaces <br>memset( &amp;ddsd, 0, sizeof( ddsd ) ); <br>ddsd.dwSize = sizeof( ddsd ); <br>ddsd.dwFlags = DDSD_CAPS | DDSD_BACKBUFFERCOUNT; <br>ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE | DDSCAPS_FLIP | DDSCAPS_COMPLEX; <br>ddsd.dwBackBufferCount = 1; <br> <br>ddrval = lpDD-&gt;CreateSurface( &amp;ddsd, &amp;lpFrontBuffer, NULL ); <br>if( ddrval != DD_OK ) <br>{ <br>wsprintf( szErrMsg, "CreateSurface FrontBuffer failed"); <br>    return ddrval; <br>} <br> <br>// get a pointer to the back buffer <br>ddscaps.dwCaps = DDSCAPS_BACKBUFFER; <br>ddrval = lpFrontBuffer-&gt;GetAttachedSurface( &amp;ddscaps, &amp;lpBackBuffer ); <br>if( ddrval != DD_OK ) <br>{ <br>wsprintf( szErrMsg, "GetAttachedSurface failed"); <br>    return ddrval; <br>} <br> <br>return DD_OK; <br>} <br> <br>// <br>// CLASS:CMonitor <br>// <br>// FUNCTION:RestoreSurfaces <br>// <br>// DESCRIPTION:Restores the primary surface <br>// <br>// NOTES: <br>// <br>HRESULT CMonitor::RestoreSurfaces() <br>{ <br>return lpFrontBuffer-&gt;Restore(); <br>} <br> <br> <br>// <br>// CLASS:CMonitor <br>// <br>// FUNCTION:Blank <br>// <br>// DESCRIPTION:Fills the back buffer with the specified color <br>// <br>// NOTES: <br>// <br>HRESULT CMonitor::Blank( DWORD dwFillColor ) <br>{ <br>HRESULT ddrval; <br>DDBLTFX ddbltfx; <br> <br>ddbltfx.dwSize = sizeof( ddbltfx ); <br>    ddbltfx.dwFillColor = dwFillColor; <br> <br>while( 1 ) <br>{ <br>ddrval = lpBackBuffer-&gt;Blt( NULL, NULL, NULL, DDBLT_COLORFILL, &amp;ddbltfx ); <br> <br>if( ddrval == DD_OK ) <br>{ <br>break; <br>} <br>if( ddrval != DDERR_WASSTILLDRAWING ) <br>{ <br>return ddrval; <br>} <br>} <br>return DD_OK; <br>} <br> <br>// <br>// CLASS:CMonitor <br>// <br>// FUNCTION:Flip <br>// <br>// DESCRIPTION:Flips the back buffer to the front buffer <br>// <br>// NOTES: <br>// <br>HRESULT CMonitor::Flip() <br>{ <br>HRESULT ddrval; <br> <br>while( 1 ) <br>{ <br>    ddrval = lpFrontBuffer-&gt;Flip( NULL, 0 ); <br>    if( ddrval == DD_OK ) <br>    { <br>        break; <br>    } <br>    if( ddrval == DDERR_SURFACELOST ) <br>    { <br>        // virtual fct call <br>ddrval = RestoreSurfaces(); <br>if ( ddrval != DD_OK ) <br>        { <br>            return ddrval; <br>        } <br>    } <br>    if( ddrval != DDERR_WASSTILLDRAWING ) <br>    { <br>        return ddrval; <br>    } <br>} <br>return DD_OK; <br>} <br> <br>// <br>// CLASS:CMonitor <br>// <br>// FUNCTION:Uninit <br>// <br>// DESCRIPTION:Uninitializes all monitors in the global Monitor array <br>// <br>// NOTES:- calls CMonitor::Release <br>//- static function <br>// <br>void CMonitor::Uninit() <br>{ <br>for (int i = 0; i &lt; iNumberOfMonitors; i++) <br>{ <br>// virtual fct call <br>Monitor[i].Release(); <br>} <br>} <br> <br>// <br>// CLASS:CMonitor <br>// <br>// FUNCTION:Release <br>// <br>// DESCRIPTION:Releases the primary surface and DirectDraw object <br>// <br>// NOTES: <br>// <br>void CMonitor::Release() <br>{ <br>if( lpFrontBuffer != NULL ) <br>{ <br>    lpFrontBuffer-&gt;Release(); <br>lpFrontBuffer = NULL; <br>} <br> <br>if( lpDD != NULL ) <br>{ <br>    lpDD-&gt;Release(); <br>lpDD = NULL; <br>} <br>} <br> <br> <br> <br>/* <br> * <br> * CMyMonitor <br> * <br> */ <br> <br>// static class member initialization <br>DWORD CMyMonitor::dwFillColor = 0; <br> <br>// constructor <br>CMyMonitor::CMyMonitor() : <br>iNumLines(0), <br>lpDonut(NULL), <br>lpPyramid(NULL), <br>lpCube(NULL), <br>lpSphere(NULL), <br>lpShip(NULL), <br>lpNum(NULL), <br>lpArtPalette(NULL), <br>lpSplashPalette(NULL), <br>lpDDClipper(NULL) <br>{} <br> <br> <br>// <br>// CLASS:CMyMonitor <br>// <br>// FUNCTION:Initialize <br>// <br>// DESCRIPTION:Initializes the global Monitor array <br>// <br>// NOTES:- calls CMonitor::Initialize to set up common data for all monitors <br>//- then calculates where monitors touch for border drawing <br>// <br>HRESULT CMyMonitor::Initialize() <br>{ <br>HRESULT ddrval; <br>ddrval = CMonitor::Initialize(); <br>if ( ddrval != DD_OK ) <br>{ <br>return ddrval; <br>} <br> <br>// figure out where monitors touch <br>for(int iMonitor=0; iMonitor&lt; iNumberOfMonitors; iMonitor++) <br>{ <br>CMyMonitor* pMyMon = &amp;Monitor[iMonitor]; <br> <br>for (int i = 0; i &lt; iNumberOfMonitors; i++) <br>{ <br>BOOL hit = FALSE; <br> <br>if (i == iMonitor) <br>continue; <br> <br>if (pMyMon-&gt;lpMonitorRect-&gt;top == Monitor[i].lpMonitorRect-&gt;bottom) <br>{ <br>                if ( pMyMon-&gt;lpMonitorRect-&gt;left &gt;= Monitor[i].lpMonitorRect-&gt;right || <br>                     pMyMon-&gt;lpMonitorRect-&gt;right &lt;= Monitor[i].lpMonitorRect-&gt;left ) <br>                { <br>                        continue; <br>                } <br> <br>pMyMon-&gt;Line[pMyMon-&gt;iNumLines].top = pMyMon-&gt;lpMonitorRect-&gt;top; <br>pMyMon-&gt;Line[pMyMon-&gt;iNumLines].bottom = pMyMon-&gt;Line[pMyMon-&gt;iNumLines].top + 1; <br> <br>if ( pMyMon-&gt;lpMonitorRect-&gt;left &gt; Monitor[i].lpMonitorRect-&gt;left ) <br>{ <br>pMyMon-&gt;Line[pMyMon-&gt;iNumLines].left = pMyMon-&gt;lpMonitorRect-&gt;left; <br>} <br>else <br>{ <br>pMyMon-&gt;Line[pMyMon-&gt;iNumLines].left = Monitor[i].lpMonitorRect-&gt;left; <br>} <br>if ( pMyMon-&gt;lpMonitorRect-&gt;right &lt;= Monitor[i].lpMonitorRect-&gt;right ) <br>{ <br>pMyMon-&gt;Line[pMyMon-&gt;iNumLines].right = pMyMon-&gt;lpMonitorRect-&gt;right - 1; <br>} <br>else <br>{ <br>pMyMon-&gt;Line[pMyMon-&gt;iNumLines].right = Monitor[i].lpMonitorRect-&gt;right; <br>} <br>hit = TRUE; <br>} <br> <br>if (pMyMon-&gt;lpMonitorRect-&gt;bottom == Monitor[i].lpMonitorRect-&gt;top) <br>{ <br>                if ( pMyMon-&gt;lpMonitorRect-&gt;left &gt;= Monitor[i].lpMonitorRect-&gt;right || <br>                     pMyMon-&gt;lpMonitorRect-&gt;right &lt;= Monitor[i].lpMonitorRect-&gt;left ) <br>                { <br>                        continue; <br>                } <br> <br>pMyMon-&gt;Line[pMyMon-&gt;iNumLines].bottom = pMyMon-&gt;lpMonitorRect-&gt;bottom - 1; <br>pMyMon-&gt;Line[pMyMon-&gt;iNumLines].top = pMyMon-&gt;Line[pMyMon-&gt;iNumLines].bottom - 1; <br> <br>if ( pMyMon-&gt;lpMonitorRect-&gt;left &gt; Monitor[i].lpMonitorRect-&gt;left ) <br>{ <br>pMyMon-&gt;Line[pMyMon-&gt;iNumLines].left = pMyMon-&gt;lpMonitorRect-&gt;left; <br>} <br>else <br>{ <br>pMyMon-&gt;Line[pMyMon-&gt;iNumLines].left = Monitor[i].lpMonitorRect-&gt;left; <br>} <br>if ( pMyMon-&gt;lpMonitorRect-&gt;right &lt;= Monitor[i].lpMonitorRect-&gt;right ) <br>{ <br>pMyMon-&gt;Line[pMyMon-&gt;iNumLines].right = pMyMon-&gt;lpMonitorRect-&gt;right - 1; <br>} <br>else <br>{ <br>pMyMon-&gt;Line[pMyMon-&gt;iNumLines].right = Monitor[i].lpMonitorRect-&gt;right; <br>} <br>hit = TRUE; <br>} <br> <br>if (pMyMon-&gt;lpMonitorRect-&gt;left == Monitor[i].lpMonitorRect-&gt;right) <br>{ <br>                if ( pMyMon-&gt;lpMonitorRect-&gt;top &gt;= Monitor[i].lpMonitorRect-&gt;bottom || <br>                     pMyMon-&gt;lpMonitorRect-&gt;bottom &lt;= Monitor[i].lpMonitorRect-&gt;top ) <br>                { <br>                        continue; <br>                } <br> <br>pMyMon-&gt;Line[pMyMon-&gt;iNumLines].left = pMyMon-&gt;lpMonitorRect-&gt;left; <br>pMyMon-&gt;Line[pMyMon-&gt;iNumLines].right = pMyMon-&gt;Line[pMyMon-&gt;iNumLines].left + 1; <br> <br>if ( pMyMon-&gt;lpMonitorRect-&gt;bottom &lt;= Monitor[i].lpMonitorRect-&gt;bottom ) <br>{ <br>pMyMon-&gt;Line[pMyMon-&gt;iNumLines].bottom = pMyMon-&gt;lpMonitorRect-&gt;bottom - 1; <br>} <br>else <br>{ <br>pMyMon-&gt;Line[pMyMon-&gt;iNumLines].bottom = Monitor[i].lpMonitorRect-&gt;bottom; <br>} <br>if ( pMyMon-&gt;lpMonitorRect-&gt;top &gt; Monitor[i].lpMonitorRect-&gt;top ) <br>{ <br>pMyMon-&gt;Line[pMyMon-&gt;iNumLines].top = pMyMon-&gt;lpMonitorRect-&gt;top; <br>} <br>else <br>{ <br>pMyMon-&gt;Line[pMyMon-&gt;iNumLines].top = Monitor[i].lpMonitorRect-&gt;top; <br>} <br>hit = TRUE; <br>} <br> <br>if (pMyMon-&gt;lpMonitorRect-&gt;right == Monitor[i].lpMonitorRect-&gt;left) <br>{ <br>                if ( pMyMon-&gt;lpMonitorRect-&gt;top &gt;= Monitor[i].lpMonitorRect-&gt;bottom || <br>                     pMyMon-&gt;lpMonitorRect-&gt;bottom &lt;= Monitor[i].lpMonitorRect-&gt;top ) <br>                { <br>                        continue; <br>                } <br> <br>pMyMon-&gt;Line[pMyMon-&gt;iNumLines].right = pMyMon-&gt;lpMonitorRect-&gt;right - 1; <br>pMyMon-&gt;Line[pMyMon-&gt;iNumLines].left = pMyMon-&gt;Line[pMyMon-&gt;iNumLines].right - 1; <br> <br>if ( pMyMon-&gt;lpMonitorRect-&gt;bottom &lt;= Monitor[i].lpMonitorRect-&gt;bottom ) <br>{ <br>pMyMon-&gt;Line[pMyMon-&gt;iNumLines].bottom = pMyMon-&gt;lpMonitorRect-&gt;bottom - 1; <br>} <br>else <br>{ <br>pMyMon-&gt;Line[pMyMon-&gt;iNumLines].bottom = Monitor[i].lpMonitorRect-&gt;bottom; <br>} <br>if ( pMyMon-&gt;lpMonitorRect-&gt;top &gt; Monitor[i].lpMonitorRect-&gt;top ) <br>{ <br>pMyMon-&gt;Line[pMyMon-&gt;iNumLines].top = pMyMon-&gt;lpMonitorRect-&gt;top; <br>} <br>else <br>{ <br>pMyMon-&gt;Line[pMyMon-&gt;iNumLines].top = Monitor[i].lpMonitorRect-&gt;top; <br>} <br>hit = TRUE; <br>} <br>if ( hit ) <br>{ <br>pMyMon-&gt;Line[pMyMon-&gt;iNumLines].left -= pMyMon-&gt;lpMonitorRect-&gt;left; <br>pMyMon-&gt;Line[pMyMon-&gt;iNumLines].top -= pMyMon-&gt;lpMonitorRect-&gt;top; <br>pMyMon-&gt;Line[pMyMon-&gt;iNumLines].right -= pMyMon-&gt;lpMonitorRect-&gt;left; <br>pMyMon-&gt;Line[pMyMon-&gt;iNumLines].bottom -= pMyMon-&gt;lpMonitorRect-&gt;top; <br>++pMyMon-&gt;iNumLines; <br>} <br>} <br>} <br>return DD_OK; <br>} <br> <br>// <br>// CLASS:CMyMonitor <br>// <br>// FUNCTION:Uninit <br>// <br>// DESCRIPTION:Uninitializes the global Monitor array <br>// <br>// NOTES:- calls CMonitor::Uninit <br>// <br>void CMyMonitor::Uninit() <br>{ <br>CMonitor::Uninit(); <br>} <br> <br>// <br>// CLASS:CMyMonitor <br>// <br>// FUNCTION:DDInit <br>// <br>// DESCRIPTION:Initializes DirectDraw objects <br>// <br>// NOTES:- calls CMonitor::DDInit for common init <br>//- creates surfaces for game graphics <br>//- creates a clipper <br>// <br>HRESULT CMyMonitor::DDInit( HWND hwnd, BOOL bEnableMultiMon ) <br>{ <br>DDSURFACEDESC   ddsd; <br>HRESULTddrval; <br>    RECTrc; <br> <br>// common init <br>ddrval = CMonitor::DDInit( hwnd, bEnableMultiMon ); <br>if ( ddrval != DD_OK ) <br>{ <br>return ddrval; <br>} <br> <br>// create surfaces for game graphics <br>memset( &amp;ddsd, 0, sizeof( ddsd ) ); <br>ddsd.dwSize = sizeof( ddsd ); <br>ddsd.dwFlags = DDSD_CAPS | DDSD_WIDTH | DDSD_HEIGHT; <br>ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN; <br> <br>ddsd.dwWidth = 320; <br>ddsd.dwHeight = 384; <br> <br>ddrval = lpDD-&gt;CreateSurface( &amp;ddsd, &amp;lpDonut, NULL ); <br>if( ddrval != DD_OK ) <br>{ <br>wsprintf( szErrMsg, "CreateSurface lpDonut failed"); <br>    return ddrval; <br>} <br> <br>ddsd.dwHeight = 128; <br>ddrval = lpDD-&gt;CreateSurface( &amp;ddsd, &amp;lpPyramid, NULL ); <br>if( ddrval != DD_OK ) <br>{ <br>wsprintf( szErrMsg, "CreateSurface lpPyramid failed"); <br>    return ddrval; <br>} <br> <br>ddsd.dwHeight = 32; <br>ddrval = lpDD-&gt;CreateSurface( &amp;ddsd, &amp;lpCube, NULL ); <br>if( ddrval != DD_OK ) <br>{ <br>wsprintf( szErrMsg, "CreateSurface lpCube failed"); <br>    return ddrval; <br>} <br> <br>ddsd.dwHeight = 32; <br>ddrval = lpDD-&gt;CreateSurface( &amp;ddsd, &amp;lpSphere, NULL ); <br>if( ddrval != DD_OK ) <br>{ <br>wsprintf( szErrMsg, "CreateSurface lpShere failed"); <br>    return ddrval; <br>} <br> <br>ddsd.dwHeight = 256; <br>ddrval = lpDD-&gt;CreateSurface( &amp;ddsd, &amp;lpShip, NULL ); <br>if( ddrval != DD_OK ) <br>{ <br>wsprintf( szErrMsg, "CreateSurface lpShip failed"); <br>    return ddrval; <br>} <br> <br>ddsd.dwHeight = 16; <br>ddrval = lpDD-&gt;CreateSurface( &amp;ddsd, &amp;lpNum, NULL ); <br>if( ddrval != DD_OK ) <br>{ <br>wsprintf( szErrMsg, "CreateSurface lpNum failed"); <br>    return ddrval; <br>} <br> <br>//create a clipper <br>ddrval = lpDD-&gt;CreateClipper((DWORD)0,&amp;lpDDClipper,NULL); <br>    if(ddrval != DD_OK) <br>{ <br>wsprintf( szErrMsg, "CreateClipper failed"); <br>return ddrval; <br>} <br> <br>rc.left = rc.top = 0; <br>rc.right = dwWidth; <br>rc.bottom = dwHeight; <br> <br>    ClipList.hdr.dwSize=sizeof(RGNDATAHEADER); <br>    ClipList.hdr.iType=RDH_RECTANGLES; <br>    ClipList.hdr.nCount=1; <br>    ClipList.hdr.nRgnSize=0; <br>    memcpy(&amp;ClipList.hdr.rcBound, &amp;rc, sizeof(RECT)); <br>    memcpy(&amp;ClipList.rgndata, &amp;rc, sizeof(RECT)); <br> <br>    ddrval = lpDDClipper-&gt;SetClipList((LPRGNDATA)&amp;ClipList,0); <br>    if(ddrval != DD_OK) <br>{ <br>wsprintf( szErrMsg, "SetClipList failed"); <br>return ddrval; <br>} <br>     <br>    ddrval = lpBackBuffer-&gt;SetClipper(lpDDClipper);             <br>    if( ddrval != DD_OK ) <br>{ <br>wsprintf( szErrMsg, "SetClipper failed"); <br>        return ddrval; <br>} <br> <br>return DD_OK; <br>} <br> <br>// <br>// CLASS:CMyMonitor <br>// <br>// FUNCTION:RestoreSurfaces <br>// <br>// DESCRIPTION:Initializes DirectDraw objects <br>// <br>// NOTES:- calls CMonitor::RestoreSurfaces <br>//- loads game graphics <br>// <br>HRESULT CMyMonitor::RestoreSurfaces() <br>{ <br>HRESULT ddrval; <br>HBITMAP hbm; <br> <br>ddrval = CMonitor::RestoreSurfaces(); <br>if ( ddrval != DD_OK ) <br>{ <br>return ddrval; <br>} <br> <br>ddrval = lpDonut-&gt;Restore(); <br>if( ddrval != DD_OK ) <br>{ <br>    return ddrval; <br>} <br> <br>ddrval = lpPyramid-&gt;Restore(); <br>if( ddrval != DD_OK ) <br>{ <br>    return ddrval; <br>} <br> <br>ddrval = lpCube-&gt;Restore(); <br>if( ddrval != DD_OK ) <br>{ <br>    return ddrval; <br>} <br> <br>ddrval = lpSphere-&gt;Restore(); <br>if( ddrval != DD_OK ) <br>{ <br>return ddrval; <br>} <br> <br>ddrval = lpShip-&gt;Restore(); <br>if( ddrval != DD_OK ) <br>{ <br>return ddrval; <br>} <br> <br>ddrval = lpNum-&gt;Restore(); <br>if( ddrval != DD_OK ) <br>{ <br>    return ddrval; <br>} <br> <br>// Create and set the palette for the splash bitmap <br>lpSplashPalette = DDLoadPalette( lpDD, "SPLASH" ); <br>if( lpSplashPalette == NULL ) <br>{ <br>wsprintf( szErrMsg, "DDLoadPalette SPLASH failed"); <br>    return DDERR_GENERIC; <br>} <br> <br>// Create and set the palette for the art bitmap <br>lpArtPalette = DDLoadPalette( lpDD, "DONUTS8" ); <br>if( lpArtPalette == NULL ) <br>{ <br>wsprintf( szErrMsg, "DDLoadPalette DONUTS8 failed"); <br>    return DDERR_GENERIC; <br>} <br> <br>// set the palette before loading the art <br>lpFrontBuffer-&gt;SetPalette( lpArtPalette ); <br> <br> <br>hbm = (HBITMAP)LoadImage(GetModuleHandle(NULL), "DONUTS8", IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION ); <br>if( hbm == NULL ) <br>{ <br>wsprintf( szErrMsg, "LoadImage DONUTS8 failed"); <br>    return DDERR_GENERIC; <br>} <br> <br>ddrval = DDCopyBitmap( lpDonut, hbm, 0, 0, 320, 384 ); <br>if( ddrval != DD_OK ) <br>{ <br>    DeleteObject( hbm ); <br>wsprintf( szErrMsg, "DDCopyBitmap lpDonut failed"); <br>    return DDERR_GENERIC; <br>} <br> <br>// NOTE: Why are we calling LoadImage again?  StretchBlt (which is <br>// called in DDCopyBitmap) does not work properly when performing <br>// an 8-bpp to 24- or 32-bpp blt multiple times from the same <br>// bitmap.  The workaround is to call LoadImage before each <br>// StretchBlt because the first StretchBlt after a LoadImage will <br>// work. <br>if(ScreenBpp &gt;= 24) <br>{ <br>DeleteObject( hbm ); <br>hbm = (HBITMAP)LoadImage(GetModuleHandle(NULL), "DONUTS8", IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION ); <br> <br>if( hbm == NULL ) <br>{ <br>wsprintf( szErrMsg, "LoadImage DONUTS8 failed"); <br>return DDERR_GENERIC; <br>} <br>} <br> <br>ddrval = DDCopyBitmap( lpPyramid, hbm, 0, 384, 320, 128 ); <br>if( ddrval != DD_OK ) <br>{ <br>    DeleteObject( hbm ); <br>wsprintf( szErrMsg, "DDCopyBitmap lpPyramid failed"); <br>    return DDERR_GENERIC; <br>} <br> <br>if(ScreenBpp &gt;= 24) <br>{ <br>DeleteObject( hbm ); <br>hbm = (HBITMAP)LoadImage(GetModuleHandle(NULL), "DONUTS8", IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION ); <br> <br>if( hbm == NULL ) <br>{ <br>wsprintf( szErrMsg, "LoadImage DONUTS8 failed"); <br>return DDERR_GENERIC; <br>} <br>} <br> <br>ddrval = DDCopyBitmap( lpSphere, hbm, 0, 512, 320, 32 ); <br>if( ddrval != DD_OK ) <br>{ <br>    DeleteObject( hbm ); <br>wsprintf( szErrMsg, "DDCopyBitmap lpSphere failed"); <br>    return DDERR_GENERIC; <br>} <br> <br>if(ScreenBpp &gt;= 24) <br>{ <br>DeleteObject( hbm ); <br>hbm = (HBITMAP)LoadImage(GetModuleHandle(NULL), "DONUTS8", IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION ); <br> <br>if( hbm == NULL ) <br>{ <br>wsprintf( szErrMsg, "LoadImage DONUTS8 failed"); <br>return DDERR_GENERIC; <br>} <br>} <br> <br>ddrval = DDCopyBitmap( lpCube, hbm, 0, 544, 320, 32 ); <br>if( ddrval != DD_OK ) <br>{ <br>    DeleteObject( hbm ); <br>wsprintf( szErrMsg, "DDCopyBitmap lpCube failed"); <br>    return DDERR_GENERIC; <br>} <br> <br>if(ScreenBpp &gt;= 24) <br>{ <br>DeleteObject( hbm ); <br>hbm = (HBITMAP)LoadImage(GetModuleHandle(NULL), "DONUTS8", IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION ); <br> <br>if( hbm == NULL ) <br>{ <br>wsprintf( szErrMsg, "LoadImage DONUTS8 failed"); <br>return DDERR_GENERIC; <br>} <br>} <br> <br>ddrval = DDCopyBitmap( lpShip, hbm, 0, 576, 320, 256 ); <br>if( ddrval != DD_OK ) <br>{ <br>    DeleteObject( hbm ); <br>wsprintf( szErrMsg, "DDCopyBitmap lpShip failed"); <br>    return DDERR_GENERIC; <br>} <br> <br>if(ScreenBpp &gt;= 24) <br>{ <br>DeleteObject( hbm ); <br>hbm = (HBITMAP)LoadImage(GetModuleHandle(NULL), "DONUTS8", IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION ); <br> <br>if( hbm == NULL ) <br>{ <br>wsprintf( szErrMsg, "LoadImage DONUTS8 failed"); <br>return DDERR_GENERIC; <br>} <br> <br>} <br> <br>ddrval = DDCopyBitmap( lpNum, hbm, 0, 832, 320, 16 ); <br>if( ddrval != DD_OK ) <br>{ <br>    DeleteObject( hbm ); <br>wsprintf( szErrMsg, "DDCopyBitmap lpNum failed"); <br>    return DDERR_GENERIC; <br>} <br> <br>DeleteObject( hbm ); <br> <br>// set colorfill colors and color keys according to bitmap contents <br>dwFillColor = DDColorMatch( lpDonut, CLR_INVALID ); <br> <br>DDSetColorKey( lpDonut, CLR_INVALID ); <br>DDSetColorKey( lpPyramid, CLR_INVALID ); <br>DDSetColorKey( lpCube, CLR_INVALID ); <br>DDSetColorKey( lpSphere, CLR_INVALID ); <br>DDSetColorKey( lpShip, CLR_INVALID ); <br>DDSetColorKey( lpNum, CLR_INVALID ); <br> <br>return DD_OK; <br>} <br> <br>// <br>// CLASS:CMyMonitor <br>// <br>// FUNCTION:Release <br>// <br>// DESCRIPTION:Releases all DirectDraw objects <br>// <br>// NOTES:- releases off-screen surfaces <br>//- calls CMonitor::Release <br>// <br>void CMyMonitor::Release() <br>{ <br>    if( lpDonut != NULL ) <br>{ <br>    lpDonut-&gt;Release(); <br>lpDonut = NULL; <br>} <br> <br>if( lpPyramid != NULL ) <br>{ <br>    lpPyramid-&gt;Release(); <br>lpPyramid = NULL; <br>} <br> <br>if( lpCube != NULL ) <br>{ <br>    lpCube-&gt;Release(); <br>lpCube = NULL; <br>} <br> <br>if( lpSphere != NULL ) <br>{ <br>    lpSphere-&gt;Release(); <br>lpSphere = NULL; <br>} <br> <br>if( lpShip != NULL ) <br>{ <br>    lpShip-&gt;Release(); <br>lpShip = NULL; <br>} <br> <br>if( lpNum != NULL ) <br>{ <br>    lpNum-&gt;Release(); <br>lpNum = NULL; <br>} <br> <br>if( lpArtPalette != NULL ) <br>{ <br>lpArtPalette-&gt;Release(); <br>lpArtPalette = NULL; <br>} <br> <br>if( lpSplashPalette != NULL ) <br>{ <br>    lpSplashPalette-&gt;Release(); <br>lpSplashPalette = NULL; <br>} <br> <br>if( lpDDClipper != NULL ) <br>{ <br>lpDDClipper-&gt;Release(); <br>lpDDClipper = NULL; <br>} <br> <br>CMonitor::Release(); <br>} <br> <br> <br>// <br>// CLASS:CMyMonitor <br>// <br>// FUNCTION:DrawBorder <br>// <br>// DESCRIPTION:Draws a white border around the screen except where another monitor touches <br>// <br>// NOTES: <br>// <br>HRESULT CMyMonitor::DrawBorder() <br>{ <br>HRESULTddrval; <br>RECTrect; <br>DDBLTFXddbltfx; <br> <br>LPDIRECTDRAWSURFACE lpsurf = lpBackBuffer; <br> <br>ddbltfx.dwSize = sizeof( ddbltfx ); <br>ddbltfx.dwFillColor = RGB(255,255,255); <br> <br>for (int i = 0; i &lt; 4; i++) <br>{ <br>switch (i) <br>{ <br>case 0: <br>rect.left = 0; <br>rect.top = 0; <br>rect.right = dwWidth - 1; <br>rect.bottom = 1; <br>break; <br>case 1: <br>rect.left = dwWidth - 2; <br>rect.top = 0; <br>rect.right = dwWidth - 1; <br>rect.bottom = dwHeight - 1; <br>break; <br>case 2: <br>rect.left = 0; <br>rect.top = dwHeight - 2; <br>rect.right = dwWidth - 1; <br>rect.bottom = dwHeight - 1; <br>break; <br>case 3: <br>rect.left = 0; <br>rect.top = 0; <br>rect.right = 1; <br>rect.bottom = dwHeight - 1; <br>break; <br>} <br> <br>while (1) <br>{ <br>ddrval = lpsurf-&gt;Blt( &amp;rect, NULL, NULL, DDBLT_COLORFILL, &amp;ddbltfx ); <br> <br>if( ddrval == DD_OK ) <br>{ <br>break; <br>} <br>if( ddrval != DDERR_WASSTILLDRAWING ) <br>{ <br>return ddrval; <br>} <br>} <br>} <br> <br>ddbltfx.dwFillColor = dwFillColor; <br>for (i = 0; i &lt; iNumLines; i++) <br>    { <br>while (1) <br>{ <br>ddrval = lpsurf-&gt;Blt( &amp;Line[i], NULL, NULL, DDBLT_COLORFILL, &amp;ddbltfx ); <br> <br>if( ddrval == DD_OK ) <br>{ <br>break; <br>} <br>if( ddrval != DDERR_WASSTILLDRAWING ) <br>{ <br>#ifdef DEBUG <br>wsprintf( DebugBuf, "Undraw line: left = %d top = %d right = %d bottom = %d\n",  <br>Line[i].left, Line[i].top, Line[i].right, Line[i].bottom ); <br>OutputDebugString( DebugBuf ); <br>#endif <br>return ddrval; <br>} <br>} <br>} <br>return ddrval; <br>} <br> <br>// <br>// CLASS:CMyMonitor <br>// <br>// FUNCTION:Blank <br>// <br>// DESCRIPTION:Fills the screen with background color <br>// <br>// NOTES:- calls CMonitor::Blank <br>// <br>HRESULT CMyMonitor::Blank() <br>{ <br>return CMonitor::Blank( dwFillColor ); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
