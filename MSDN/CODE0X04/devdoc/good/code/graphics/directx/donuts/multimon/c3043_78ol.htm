<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DSUTIL.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3045"></a>DSUTIL.CPP</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1995 Microsoft Corporation. All Rights Reserved. <br> * <br> *  File:       dsutil.cpp <br> *  Content:    Routines for dealing with sounds from resources <br> * <br> * <br> ***************************************************************************/ <br> <br>#define WIN32_LEAN_AND_MEAN <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include &lt;dsound.h&gt; <br> <br>typedef struct <br>{ <br>    BYTE *pbWaveData;               // pointer into wave resource (for restore) <br>    DWORD cbWaveSize;               // size of wave data (for restore) <br>    int iAlloc;                     // number of buffers. <br>    int iCurrent;                   // current buffer <br>    IDirectSoundBuffer* Buffers[1]; // list of buffers <br> <br>} SNDOBJ, *HSNDOBJ; <br> <br>#define _HSNDOBJ_DEFINED <br>#include "dsutil.h" <br> <br>static const char c_szWAV[] = "WAV"; <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>// DSLoadSoundBuffer <br>// <br>/////////////////////////////////////////////////////////////////////////////// <br> <br>IDirectSoundBuffer *DSLoadSoundBuffer(IDirectSound *pDS, LPCTSTR lpName) <br>{ <br>    IDirectSoundBuffer *pDSB = NULL; <br>    DSBUFFERDESC dsBD = {0}; <br>    BYTE *pbWaveData; <br> <br>    if (DSGetWaveResource(NULL, lpName, &amp;dsBD.lpwfxFormat, &amp;pbWaveData, &amp;dsBD.dwBufferBytes)) <br>    { <br>        dsBD.dwSize = sizeof(dsBD); <br>        dsBD.dwFlags = DSBCAPS_STATIC | DSBCAPS_CTRLDEFAULT | DSBCAPS_GETCURRENTPOSITION2; <br> <br>        if (SUCCEEDED(IDirectSound_CreateSoundBuffer(pDS, &amp;dsBD, &amp;pDSB, NULL))) <br>        { <br>            if (!DSFillSoundBuffer(pDSB, pbWaveData, dsBD.dwBufferBytes)) <br>            { <br>                IDirectSoundBuffer_Release(pDSB); <br>                pDSB = NULL; <br>            } <br>        } <br>        else <br>        { <br>            pDSB = NULL; <br>        } <br>    } <br> <br>    return pDSB; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>// DSReloadSoundBuffer <br>// <br>/////////////////////////////////////////////////////////////////////////////// <br> <br>BOOL DSReloadSoundBuffer(IDirectSoundBuffer *pDSB, LPCTSTR lpName) <br>{ <br>    BOOL result=FALSE; <br>    BYTE *pbWaveData; <br>    DWORD cbWaveSize; <br> <br>    if (DSGetWaveResource(NULL, lpName, NULL, &amp;pbWaveData, &amp;cbWaveSize)) <br>    { <br>        if (SUCCEEDED(IDirectSoundBuffer_Restore(pDSB)) &amp;&amp; <br>            DSFillSoundBuffer(pDSB, pbWaveData, cbWaveSize)) <br>        { <br>            result = TRUE; <br>        } <br>    } <br> <br>    return result; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>// DSGetWaveResource <br>// <br>/////////////////////////////////////////////////////////////////////////////// <br> <br>BOOL DSGetWaveResource(HMODULE hModule, LPCTSTR lpName, <br>    WAVEFORMATEX **ppWaveHeader, BYTE **ppbWaveData, DWORD *pcbWaveSize) <br>{ <br>    HRSRC hResInfo; <br>    HGLOBAL hResData; <br>    void *pvRes; <br> <br>    if (((hResInfo = FindResource(hModule, lpName, c_szWAV)) != NULL) &amp;&amp; <br>        ((hResData = LoadResource(hModule, hResInfo)) != NULL) &amp;&amp; <br>        ((pvRes = LockResource(hResData)) != NULL) &amp;&amp; <br>        DSParseWaveResource(pvRes, ppWaveHeader, ppbWaveData, pcbWaveSize)) <br>    { <br>        return TRUE; <br>    } <br> <br>    return FALSE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// SndObj fns <br>/////////////////////////////////////////////////////////////////////////////// <br> <br>SNDOBJ *SndObjCreate(IDirectSound *pDS, LPCTSTR lpName, int iConcurrent) <br>{ <br>    SNDOBJ *pSO = NULL; <br>    LPWAVEFORMATEX pWaveHeader; <br>    BYTE *pbData; <br>    ULONG cbData; <br> <br>    if (DSGetWaveResource(NULL, lpName, &amp;pWaveHeader, &amp;pbData, &amp;cbData)) <br>    { <br>        if (iConcurrent &lt; 1) <br>            iConcurrent = 1; <br> <br>        if ((pSO = (SNDOBJ *)LocalAlloc(LPTR, sizeof(SNDOBJ) + <br>            (iConcurrent-1) * sizeof(IDirectSoundBuffer *))) != NULL) <br>        { <br>            int i; <br> <br>            pSO-&gt;iAlloc = iConcurrent; <br>            pSO-&gt;pbWaveData = pbData; <br>            pSO-&gt;cbWaveSize = cbData; <br>            pSO-&gt;Buffers[0] = DSLoadSoundBuffer(pDS, lpName); <br> <br>            for (i=1; i&lt;pSO-&gt;iAlloc; i++) <br>            { <br>                if (FAILED(IDirectSound_DuplicateSoundBuffer(pDS, <br>                    pSO-&gt;Buffers[0], &amp;pSO-&gt;Buffers[i]))) <br>                { <br>                    pSO-&gt;Buffers[i] = DSLoadSoundBuffer(pDS, lpName); <br>                    if (!pSO-&gt;Buffers[i]) { <br>                        SndObjDestroy(pSO); <br>                        pSO = NULL; <br>                        break; <br>                    } <br>                } <br>            } <br>        } <br>    } <br> <br>    return pSO; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>/////////////////////////////////////////////////////////////////////////////// <br> <br>void SndObjDestroy(SNDOBJ *pSO) <br>{ <br>    if (pSO) <br>    { <br>        int i; <br> <br>        for (i=0; i&lt;pSO-&gt;iAlloc; i++) <br>        { <br>            if (pSO-&gt;Buffers[i]) <br>            { <br>                IDirectSoundBuffer_Release(pSO-&gt;Buffers[i]); <br>                pSO-&gt;Buffers[i] = NULL; <br>            } <br>        } <br>        LocalFree((HANDLE)pSO); <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>/////////////////////////////////////////////////////////////////////////////// <br> <br>IDirectSoundBuffer *SndObjGetFreeBuffer(SNDOBJ *pSO) <br>{ <br>    IDirectSoundBuffer *pDSB; <br> <br>    if (pSO == NULL) <br>        return NULL; <br> <br>    if (pDSB = pSO-&gt;Buffers[pSO-&gt;iCurrent]) <br>    { <br>        HRESULT hres; <br>        DWORD dwStatus; <br> <br>        hres = IDirectSoundBuffer_GetStatus(pDSB, &amp;dwStatus); <br> <br>        if (FAILED(hres)) <br>            dwStatus = 0; <br> <br>        if ((dwStatus &amp; DSBSTATUS_PLAYING) == DSBSTATUS_PLAYING) <br>        { <br>            if (pSO-&gt;iAlloc &gt; 1) <br>            { <br>                if (++pSO-&gt;iCurrent &gt;= pSO-&gt;iAlloc) <br>                    pSO-&gt;iCurrent = 0; <br> <br>                pDSB = pSO-&gt;Buffers[pSO-&gt;iCurrent]; <br>                hres = IDirectSoundBuffer_GetStatus(pDSB, &amp;dwStatus); <br> <br>                if (SUCCEEDED(hres) &amp;&amp; (dwStatus &amp; DSBSTATUS_PLAYING) == DSBSTATUS_PLAYING) <br>                { <br>                    IDirectSoundBuffer_Stop(pDSB); <br>                    IDirectSoundBuffer_SetCurrentPosition(pDSB, 0); <br>                } <br>            } <br>            else <br>            { <br>                pDSB = NULL; <br>            } <br>        } <br> <br>        if (pDSB &amp;&amp; (dwStatus &amp; DSBSTATUS_BUFFERLOST)) <br>        { <br>            if (FAILED(IDirectSoundBuffer_Restore(pDSB)) || <br>                !DSFillSoundBuffer(pDSB, pSO-&gt;pbWaveData, pSO-&gt;cbWaveSize)) <br>            { <br>                pDSB = NULL; <br>            } <br>        } <br>    } <br> <br>    return pDSB; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>/////////////////////////////////////////////////////////////////////////////// <br> <br>BOOL SndObjPlay(SNDOBJ *pSO, DWORD dwPlayFlags) <br>{ <br>    BOOL result = FALSE; <br> <br>    if (pSO == NULL) <br>        return FALSE; <br> <br>    if ((!(dwPlayFlags &amp; DSBPLAY_LOOPING) || (pSO-&gt;iAlloc == 1))) <br>    { <br>        IDirectSoundBuffer *pDSB = SndObjGetFreeBuffer(pSO); <br>        if (pDSB != NULL) { <br>            result = SUCCEEDED(IDirectSoundBuffer_Play(pDSB, 0, 0, dwPlayFlags)); <br>        } <br>    } <br> <br>    return result; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>/////////////////////////////////////////////////////////////////////////////// <br> <br>BOOL SndObjStop(SNDOBJ *pSO) <br>{ <br>    int i; <br> <br>    if (pSO == NULL) <br>        return FALSE; <br> <br>    for (i=0; i&lt;pSO-&gt;iAlloc; i++) <br>    { <br>        IDirectSoundBuffer_Stop(pSO-&gt;Buffers[i]); <br>        IDirectSoundBuffer_SetCurrentPosition(pSO-&gt;Buffers[i], 0); <br>    } <br> <br>    return TRUE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>/////////////////////////////////////////////////////////////////////////////// <br> <br>BOOL DSFillSoundBuffer(IDirectSoundBuffer *pDSB, BYTE *pbWaveData, DWORD cbWaveSize) <br>{ <br>    if (pDSB &amp;&amp; pbWaveData &amp;&amp; cbWaveSize) <br>    { <br>        LPVOID pMem1, pMem2; <br>        DWORD dwSize1, dwSize2; <br> <br>        if (SUCCEEDED(IDirectSoundBuffer_Lock(pDSB, 0, cbWaveSize, <br>            &amp;pMem1, &amp;dwSize1, &amp;pMem2, &amp;dwSize2, 0))) <br>        { <br>            CopyMemory(pMem1, pbWaveData, dwSize1); <br> <br>            if ( 0 != dwSize2 ) <br>                CopyMemory(pMem2, pbWaveData+dwSize1, dwSize2); <br> <br>            IDirectSoundBuffer_Unlock(pDSB, pMem1, dwSize1, pMem2, dwSize2); <br>            return TRUE; <br>        } <br>    } <br> <br>    return FALSE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>/////////////////////////////////////////////////////////////////////////////// <br> <br>BOOL DSParseWaveResource(void *pvRes, WAVEFORMATEX **ppWaveHeader, BYTE **ppbWaveData,DWORD *pcbWaveSize) <br>{ <br>    DWORD *pdw; <br>    DWORD *pdwEnd; <br>    DWORD dwRiff; <br>    DWORD dwType; <br>    DWORD dwLength; <br> <br>    if (ppWaveHeader) <br>        *ppWaveHeader = NULL; <br> <br>    if (ppbWaveData) <br>        *ppbWaveData = NULL; <br> <br>    if (pcbWaveSize) <br>        *pcbWaveSize = 0; <br> <br>    pdw = (DWORD *)pvRes; <br>    dwRiff = *pdw++; <br>    dwLength = *pdw++; <br>    dwType = *pdw++; <br> <br>    if (dwRiff != mmioFOURCC('R', 'I', 'F', 'F')) <br>        goto exit;      // not even RIFF <br> <br>    if (dwType != mmioFOURCC('W', 'A', 'V', 'E')) <br>        goto exit;      // not a WAV <br> <br>    pdwEnd = (DWORD *)((BYTE *)pdw + dwLength-4); <br> <br>    while (pdw &lt; pdwEnd) <br>    { <br>        dwType = *pdw++; <br>        dwLength = *pdw++; <br> <br>        switch (dwType) <br>        { <br>        case mmioFOURCC('f', 'm', 't', ' '): <br>            if (ppWaveHeader &amp;&amp; !*ppWaveHeader) <br>            { <br>                if (dwLength &lt; sizeof(WAVEFORMAT)) <br>                    goto exit;      // not a WAV <br> <br>                *ppWaveHeader = (WAVEFORMATEX *)pdw; <br> <br>                if ((!ppbWaveData || *ppbWaveData) &amp;&amp; <br>                    (!pcbWaveSize || *pcbWaveSize)) <br>                { <br>                    return TRUE; <br>                } <br>            } <br>            break; <br> <br>        case mmioFOURCC('d', 'a', 't', 'a'): <br>            if ((ppbWaveData &amp;&amp; !*ppbWaveData) || <br>                (pcbWaveSize &amp;&amp; !*pcbWaveSize)) <br>            { <br>                if (ppbWaveData) <br>                    *ppbWaveData = (LPBYTE)pdw; <br> <br>                if (pcbWaveSize) <br>                    *pcbWaveSize = dwLength; <br> <br>                if (!ppWaveHeader || *ppWaveHeader) <br>                    return TRUE; <br>            } <br>            break; <br>        } <br> <br>        pdw = (DWORD *)((BYTE *)pdw + ((dwLength+1)&amp;~1)); <br>    } <br> <br>exit: <br>    return FALSE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
