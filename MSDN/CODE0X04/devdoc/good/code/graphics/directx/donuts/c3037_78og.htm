<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>INPUT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3040"></a>INPUT.C</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1995-1997 Microsoft Corporation. All Rights Reserved. <br> * <br> *  File:       input.c <br> *  Content:    Input routines for Space Donuts game <br> * <br> * <br> ***************************************************************************/ <br> <br>#include &lt;dinput.h&gt; <br>#include "input.h" <br>#include "resource.h" <br> <br>extern HWND hWndMain; <br>extern DWORD ReadKeyboardInput(void); <br>extern DWORD ReadJoystickInput(void); <br> <br>// allocate external variables <br>DWORD (*ReadGameInput)(void) = ReadKeyboardInput; <br> <br>/* <br> *  We'll use up to the first ten input devices. <br> * <br> *  c_cpdiFound is the number of found devices. <br> *  g_rgpdiFound[0] is the array of found devices. <br> *  g_pdevCurrent is the device that we are using for input. <br> */ <br>#define MAX_DINPUT_DEVICES 10 <br>int g_cpdevFound; <br>LPDIRECTINPUTDEVICE2 g_rgpdevFound[MAX_DINPUT_DEVICES]; <br>LPDIRECTINPUTDEVICE2 g_pdevCurrent; <br> <br> <br> <br> <br>/*-------------------------------------------------------------------------- <br>| AddInputDevice <br>| <br>| Records an input device in the array of found devices. <br>| <br>| In addition to stashing it in the array, we also add it to the device <br>| menu so the user can pick it. <br>| <br>*-------------------------------------------------------------------------*/ <br> <br>void AddInputDevice(LPDIRECTINPUTDEVICE pdev, LPCDIDEVICEINSTANCE pdi) <br>{ <br> <br>    if (g_cpdevFound &lt; MAX_DINPUT_DEVICES) { <br> <br>        HRESULT hRes; <br> <br>        /* <br>         *  Convert it to a Device2 so we can Poll() it. <br>         */ <br> <br>        hRes = pdev-&gt;lpVtbl-&gt;QueryInterface( <br>                    pdev, &amp;IID_IDirectInputDevice2, <br>                    (LPVOID *)&amp;g_rgpdevFound[g_cpdevFound]); <br> <br>        if (SUCCEEDED(hRes)) { <br> <br>            HMENU hmenu; <br> <br>            /* <br>             *  Add its description to the menu. <br>             */ <br>            hmenu = GetSubMenu(GetMenu(hWndMain), 0); <br> <br>            InsertMenu(hmenu, g_cpdevFound, MF_BYPOSITION | MF_STRING, <br>                       IDC_DEVICES + g_cpdevFound, <br>                       pdi-&gt;tszInstanceName); <br> <br>            g_cpdevFound++; <br>        } <br>    } <br>} <br> <br>/*-------------------------------------------------------------------------- <br>| <br>| SetDIDwordProperty <br>| <br>| Set a DWORD property on a DirectInputDevice. <br>| <br>*-------------------------------------------------------------------------*/ <br> <br>HRESULT <br>SetDIDwordProperty(LPDIRECTINPUTDEVICE pdev, REFGUID guidProperty, <br>                   DWORD dwObject, DWORD dwHow, DWORD dwValue) <br>{ <br>   DIPROPDWORD dipdw; <br> <br>   dipdw.diph.dwSize       = sizeof(dipdw); <br>   dipdw.diph.dwHeaderSize = sizeof(dipdw.diph); <br>   dipdw.diph.dwObj        = dwObject; <br>   dipdw.diph.dwHow        = dwHow; <br>   dipdw.dwData            = dwValue; <br> <br>   return pdev-&gt;lpVtbl-&gt;SetProperty(pdev, guidProperty, &amp;dipdw.diph); <br> <br>} <br> <br>/*-------------------------------------------------------------------------- <br>| InitKeyboardInput <br>| <br>| Initializes DirectInput for the keyboard.  Creates a keyboard device, <br>| sets the data format to our custom format, sets the cooperative level and <br>| adds it to the menu. <br>| <br>*-------------------------------------------------------------------------*/ <br> <br>BOOL InitKeyboardInput(LPDIRECTINPUT pdi) <br>{ <br>   LPDIRECTINPUTDEVICE pdev; <br>   DIDEVICEINSTANCE di; <br> <br>   // create the DirectInput keyboard device <br>   if(pdi-&gt;lpVtbl-&gt;CreateDevice(pdi, &amp;GUID_SysKeyboard, &amp;pdev, NULL) != DI_OK) <br>   { <br>      OutputDebugString("IDirectInput::CreateDevice FAILED\n"); <br>      return FALSE; <br>   } <br> <br>   // set keyboard data format <br>   if(pdev-&gt;lpVtbl-&gt;SetDataFormat(pdev, &amp;c_dfDIKeyboard) != DI_OK) <br>   { <br>      OutputDebugString("IDirectInputDevice::SetDataFormat FAILED\n"); <br>      pdev-&gt;lpVtbl-&gt;Release(pdev); <br>      return FALSE; <br>   } <br> <br>   // set the cooperative level <br>   if(pdev-&gt;lpVtbl-&gt;SetCooperativeLevel(pdev, hWndMain, <br>      DISCL_NONEXCLUSIVE | DISCL_FOREGROUND) != DI_OK) <br>   { <br>      OutputDebugString("IDirectInputDevice::SetCooperativeLevel FAILED\n"); <br>      pdev-&gt;lpVtbl-&gt;Release(pdev); <br>      return FALSE; <br>   } <br> <br>   // set buffer size <br>   if (SetDIDwordProperty(pdev, DIPROP_BUFFERSIZE, 0, DIPH_DEVICE, KEYBUFSIZE) != DI_OK) <br>   { <br>      OutputDebugString("IDirectInputDevice::SetProperty(DIPH_DEVICE) FAILED\n"); <br>      pdev-&gt;lpVtbl-&gt;Release(pdev); <br>      return FALSE; <br>   } <br> <br>   // <br>   // Get the name of the primary keyboard so we can add it to the menu. <br>   // <br>   di.dwSize = sizeof(di); <br>   if (pdev-&gt;lpVtbl-&gt;GetDeviceInfo(pdev, &amp;di) != DI_OK) <br>   { <br>      OutputDebugString("IDirectInputDevice::GetDeviceInfo FAILED\n"); <br>      pdev-&gt;lpVtbl-&gt;Release(pdev); <br>      return FALSE; <br>   } <br> <br>   // <br>   // Add it to our list of devices.  If AddInputDevice succeeds, <br>   // he will do an AddRef. <br>   // <br>   AddInputDevice(pdev, &amp;di); <br>   pdev-&gt;lpVtbl-&gt;Release(pdev); <br> <br>   return TRUE; <br>} <br> <br>/*-------------------------------------------------------------------------- <br>| InitJoystickInput <br>| <br>| Initializes DirectInput for an enumerated joystick device. <br>| Creates the device, device, sets the standard joystick data format, <br>| sets the cooperative level and adds it to the menu. <br>| <br>| If any step fails, just skip the device and go on to the next one. <br>| <br>*-------------------------------------------------------------------------*/ <br> <br>BOOL FAR PASCAL InitJoystickInput(LPCDIDEVICEINSTANCE pdinst, LPVOID pvRef) <br>{ <br>   LPDIRECTINPUT pdi = pvRef; <br>   LPDIRECTINPUTDEVICE pdev; <br>   DIPROPRANGE diprg; <br> <br>   // create the DirectInput joystick device <br>   if(pdi-&gt;lpVtbl-&gt;CreateDevice(pdi, &amp;pdinst-&gt;guidInstance, &amp;pdev, NULL) != DI_OK) <br>   { <br>      OutputDebugString("IDirectInput::CreateDevice FAILED\n"); <br>      return DIENUM_CONTINUE; <br>   } <br> <br>   // set joystick data format <br>   if(pdev-&gt;lpVtbl-&gt;SetDataFormat(pdev, &amp;c_dfDIJoystick) != DI_OK) <br>   { <br>      OutputDebugString("IDirectInputDevice::SetDataFormat FAILED\n"); <br>      pdev-&gt;lpVtbl-&gt;Release(pdev); <br>      return DIENUM_CONTINUE; <br>   } <br> <br>   // set the cooperative level <br>   if(pdev-&gt;lpVtbl-&gt;SetCooperativeLevel(pdev, hWndMain, <br>      DISCL_NONEXCLUSIVE | DISCL_FOREGROUND) != DI_OK) <br>   { <br>      OutputDebugString("IDirectInputDevice::SetCooperativeLevel FAILED\n"); <br>      pdev-&gt;lpVtbl-&gt;Release(pdev); <br>      return DIENUM_CONTINUE; <br>   } <br> <br>   // set X-axis range to (-1000 ... +1000) <br>   // This lets us test against 0 to see which way the stick is pointed. <br> <br>   diprg.diph.dwSize       = sizeof(diprg); <br>   diprg.diph.dwHeaderSize = sizeof(diprg.diph); <br>   diprg.diph.dwObj        = DIJOFS_X; <br>   diprg.diph.dwHow        = DIPH_BYOFFSET; <br>   diprg.lMin              = -1000; <br>   diprg.lMax              = +1000; <br> <br>   if(pdev-&gt;lpVtbl-&gt;SetProperty(pdev, DIPROP_RANGE, &amp;diprg.diph) != DI_OK) <br>   { <br>      OutputDebugString("IDirectInputDevice::SetProperty(DIPH_RANGE) FAILED\n"); <br>      pdev-&gt;lpVtbl-&gt;Release(pdev); <br>      return FALSE; <br>   } <br> <br>   // <br>   // And again for Y-axis range <br>   // <br>   diprg.diph.dwObj        = DIJOFS_Y; <br> <br>   if(pdev-&gt;lpVtbl-&gt;SetProperty(pdev, DIPROP_RANGE, &amp;diprg.diph) != DI_OK) <br>   { <br>      OutputDebugString("IDirectInputDevice::SetProperty(DIPH_RANGE) FAILED\n"); <br>      pdev-&gt;lpVtbl-&gt;Release(pdev); <br>      return FALSE; <br>   } <br> <br>   // set X axis dead zone to 50% (to avoid accidental turning) <br>   // Units are ten thousandths, so 50% = 5000/10000. <br>   if (SetDIDwordProperty(pdev, DIPROP_DEADZONE, DIJOFS_X, DIPH_BYOFFSET, 5000) != DI_OK) <br>   { <br>      OutputDebugString("IDirectInputDevice::SetProperty(DIPH_DEADZONE) FAILED\n"); <br>      pdev-&gt;lpVtbl-&gt;Release(pdev); <br>      return FALSE; <br>   } <br> <br> <br>   // set Y axis dead zone to 50% (to avoid accidental thrust) <br>   // Units are ten thousandths, so 50% = 5000/10000. <br>   if (SetDIDwordProperty(pdev, DIPROP_DEADZONE, DIJOFS_Y, DIPH_BYOFFSET, 5000) != DI_OK) <br>   { <br>      OutputDebugString("IDirectInputDevice::SetProperty(DIPH_DEADZONE) FAILED\n"); <br>      pdev-&gt;lpVtbl-&gt;Release(pdev); <br>      return FALSE; <br>   } <br> <br> <br>   // <br>   // Add it to our list of devices.  If AddInputDevice succeeds, <br>   // he will do an AddRef. <br>   // <br>   AddInputDevice(pdev, pdinst); <br>   pdev-&gt;lpVtbl-&gt;Release(pdev); <br> <br>   return DIENUM_CONTINUE; <br>} <br> <br>/*-------------------------------------------------------------------------- <br>| InitInput <br>| <br>| Initializes DirectInput for the keyboard and all joysticks. <br>| <br>| For each input device, add it to the menu. <br>| <br>*-------------------------------------------------------------------------*/ <br> <br>BOOL InitInput(HINSTANCE hInst, HWND hWnd) <br>{ <br>   LPDIRECTINPUT pdi; <br>   BOOL fRc; <br> <br>   // Note: Joystick support is a DirectX 5.0 feature. <br>   // Since we also want to run on DirectX 3.0, we will start out <br>   // with DirectX 3.0 to make sure that at least we get the keyboard. <br> <br>   // create the DirectInput interface object <br>   if(DirectInputCreate(hInst, 0x0300, &amp;pdi, NULL) != DI_OK) <br>   { <br>      OutputDebugString("DirectInputCreate 3.0 FAILED\n"); <br>      return FALSE; <br>   } <br> <br>   fRc = InitKeyboardInput(pdi); <br>   pdi-&gt;lpVtbl-&gt;Release(pdi);       // Finished with DX 3.0 <br> <br>   if (!fRc) { <br>      return FALSE; <br>   } <br> <br>   // create the DirectInput 5.0 interface object <br>   if(DirectInputCreate(hInst, DIRECTINPUT_VERSION, &amp;pdi, NULL) == DI_OK) <br>   { <br> <br>      // <br>      // Enumerate the joystick devices.  If it doesn't work, oh well, <br>      // at least we got the keyboard. <br>      // <br> <br>      pdi-&gt;lpVtbl-&gt;EnumDevices(pdi, DIDEVTYPE_JOYSTICK, <br>                               InitJoystickInput, pdi, DIEDFL_ATTACHEDONLY); <br> <br>      pdi-&gt;lpVtbl-&gt;Release(pdi);    // Finished with DX 5.0. <br> <br>   } else { <br>      OutputDebugString("DirectInputCreate 5.0 FAILED - no joystick support\n"); <br>   } <br> <br>   // Default device is the keyboard <br>   PickInputDevice(0); <br> <br>   // if we get here, we were successful <br>   return TRUE; <br>} <br> <br>/*-------------------------------------------------------------------------- <br>| CleanupInput <br>| <br>| Cleans up all DirectInput objects. <br>*-------------------------------------------------------------------------*/ <br>void CleanupInput(void) <br>{ <br>   int idev; <br> <br>   // make sure the device is unacquired <br>   // it doesn't harm to unacquire a device that isn't acquired <br> <br>   if (g_pdevCurrent) <br>   { <br>      IDirectInputDevice_Unacquire(g_pdevCurrent); <br>   } <br> <br>   // release all the devices we created <br>   for (idev = 0; idev &lt; g_cpdevFound; idev++) <br>   { <br>      if (g_rgpdevFound[idev]) { <br>         IDirectInputDevice_Release(g_rgpdevFound[idev]); <br>         g_rgpdevFound[idev] = 0; <br>      } <br>   } <br> <br>} <br> <br> <br>/*-------------------------------------------------------------------------- <br>| ReacquireInput <br>| <br>| Reacquires the current input device.  If Acquire() returns S_FALSE, <br>| that means <br>| that we are already acquired and that DirectInput did nothing. <br>*-------------------------------------------------------------------------*/ <br>BOOL ReacquireInput(void) <br>{ <br>    HRESULT hRes; <br> <br>    // if we have a current device <br>    if(g_pdevCurrent) <br>    { <br>       // acquire the device <br>       hRes = IDirectInputDevice_Acquire(g_pdevCurrent); <br>       if(SUCCEEDED(hRes)) <br>       { <br>          // acquisition successful <br>          return TRUE; <br>       } <br>       else <br>       { <br>          // acquisition failed <br>          return FALSE; <br>       } <br>    } <br>    else <br>    { <br>       // we don't have a current device <br>       return FALSE; <br>    } <br> <br>} <br> <br> <br>/*-------------------------------------------------------------------------- <br>| ReadKeyboardInput <br>| <br>| Requests keyboard data and performs any needed processing. <br>*-------------------------------------------------------------------------*/ <br>DWORD ReadKeyboardInput(void) <br>{ <br>   DIDEVICEOBJECTDATA      rgKeyData[KEYBUFSIZE]; <br>   DWORD                   dwEvents; <br>   DWORD                   dw; <br>   static DWORD            dwKeyState = 0; <br>   HRESULT                 hRes; <br> <br>   // get data from the keyboard <br>   dwEvents = KEYBUFSIZE; <br>   hRes = IDirectInputDevice_GetDeviceData(g_pdevCurrent, <br>                                           sizeof(DIDEVICEOBJECTDATA), <br>                                           rgKeyData, &amp;dwEvents, 0); <br> <br>   if(hRes != DI_OK) <br>   { <br>      // did the read fail because we lost input for some reason? <br>      // if so, then attempt to reacquire.  If the second acquire <br>      // fails, then the error from GetDeviceData will be <br>      // DIERR_NOTACQUIRED, so we won't get stuck an infinite loop. <br>      if(hRes == DIERR_INPUTLOST) <br>         ReacquireInput(); <br> <br>      // return the fact that we did not read any data <br>      return 0; <br>   } <br> <br>      // process the data <br>      for(dw = 0; dw &lt; dwEvents; dw++) <br>      { <br>         switch(rgKeyData[dw].dwOfs) <br>         { <br>         // fire <br>         case DIK_SPACE: <br>            if(rgKeyData[dw].dwData &amp; 0x80) <br>               dwKeyState |= KEY_FIRE; <br>            else <br>               dwKeyState &amp;= (DWORD)~KEY_FIRE; <br>            break; <br> <br>         // stop <br>         case DIK_NUMPAD5: <br>            if(rgKeyData[dw].dwData &amp; 0x80) <br>               dwKeyState |= KEY_STOP; <br>            else <br>               dwKeyState &amp;= ~KEY_STOP; <br>            break; <br> <br>         // shield <br>         case DIK_NUMPAD7: <br>            if(rgKeyData[dw].dwData &amp; 0x80) <br>               dwKeyState |= KEY_SHIELD; <br>            else <br>               dwKeyState &amp;= ~KEY_SHIELD; <br>            break; <br> <br>         // thrust <br>         case DIK_UP: <br>         case DIK_NUMPAD8: <br>            if(rgKeyData[dw].dwData &amp; 0x80) <br>               dwKeyState |= KEY_UP; <br>            else <br>               dwKeyState &amp;= ~KEY_UP; <br>            break; <br> <br>         // reverse thrust <br>         case DIK_DOWN: <br>         case DIK_NUMPAD2: <br>            if(rgKeyData[dw].dwData &amp; 0x80) <br>               dwKeyState |= KEY_DOWN; <br>            else <br>               dwKeyState &amp;= ~KEY_DOWN; <br>            break; <br> <br>         // rotate left <br>         case DIK_LEFT: <br>         case DIK_NUMPAD4: <br>            if(rgKeyData[dw].dwData &amp; 0x80) <br>               dwKeyState |= KEY_LEFT; <br>            else <br>               dwKeyState &amp;= ~KEY_LEFT; <br>            break; <br> <br>         // rotate right <br>         case DIK_RIGHT: <br>         case DIK_NUMPAD6: <br>            if(rgKeyData[dw].dwData &amp; 0x80) <br>               dwKeyState |= KEY_RIGHT; <br>            else <br>               dwKeyState &amp;= ~KEY_RIGHT; <br>            break; <br>         } <br> <br>   } <br> <br>   // return the state of the keys to the caller <br>   return dwKeyState; <br> <br>} <br> <br>/*-------------------------------------------------------------------------- <br>| ReadJoystickInput <br>| <br>| Requests joystick data and performs any needed processing. <br>| <br>*-------------------------------------------------------------------------*/ <br>DWORD ReadJoystickInput(void) <br>{ <br>   DWORD                   dwKeyState; <br>   HRESULT                 hRes; <br>   DIJOYSTATE              js; <br> <br>   // poll the joystick to read the current state <br>   hRes = IDirectInputDevice2_Poll(g_pdevCurrent); <br> <br>   // get data from the joystick <br>   hRes = IDirectInputDevice_GetDeviceState(g_pdevCurrent, <br>                                            sizeof(DIJOYSTATE), &amp;js); <br> <br>   if(hRes != DI_OK) <br>   { <br>      // did the read fail because we lost input for some reason? <br>      // if so, then attempt to reacquire.  If the second acquire <br>      // fails, then the error from GetDeviceData will be <br>      // DIERR_NOTACQUIRED, so we won't get stuck an infinite loop. <br>      if(hRes == DIERR_INPUTLOST) <br>         ReacquireInput(); <br> <br>      // return the fact that we did not read any data <br>      return 0; <br>   } <br> <br>   // <br>   // Now study the position of the stick and the buttons. <br>   // <br> <br>   dwKeyState = 0; <br> <br>   if (js.lX &lt; 0) { <br>      dwKeyState |= KEY_LEFT; <br>   } else if (js.lX &gt; 0) { <br>      dwKeyState |= KEY_RIGHT; <br>   } <br> <br>   if (js.lY &lt; 0) { <br>      dwKeyState |= KEY_UP; <br>   } else if (js.lY &gt; 0) { <br>      dwKeyState |= KEY_DOWN; <br>   } <br> <br>   if (js.rgbButtons[0] &amp; 0x80) { <br>      dwKeyState |= KEY_FIRE; <br>   } <br> <br>   if (js.rgbButtons[1] &amp; 0x80) { <br>      dwKeyState |= KEY_SHIELD; <br>   } <br> <br>   if (js.rgbButtons[2] &amp; 0x80) { <br>      dwKeyState |= KEY_STOP; <br>   } <br> <br>   return dwKeyState; <br> <br>} <br> <br>/*-------------------------------------------------------------------------- <br>| PickInputDevice <br>| <br>| Make the n'th input device the one that we will use for game play. <br>| <br>*-------------------------------------------------------------------------*/ <br> <br>BOOL PickInputDevice(int n) <br>{ <br>    if (n &lt; g_cpdevFound) { <br> <br>        /* <br>         *  Unacquire the old device. <br>         */ <br>        if (g_pdevCurrent) { <br>            IDirectInputDevice_Unacquire(g_pdevCurrent); <br>        } <br> <br>        /* <br>         *  Move to the new device. <br>         */ <br>        g_pdevCurrent = g_rgpdevFound[n]; <br> <br>        /* <br>         *  Set ReadGameInput to the appropriate handler. <br>         */ <br>        if (n == 0) { <br>            ReadGameInput = ReadKeyboardInput; <br>        } else { <br>            ReadGameInput = ReadJoystickInput; <br>        } <br> <br>        CheckMenuRadioItem(GetSubMenu(GetMenu(hWndMain), 0), <br>                           IDC_DEVICES, IDC_DEVICES + g_cpdevFound - 1, <br>                           IDC_DEVICES + n, MF_BYCOMMAND); <br> <br>        ReacquireInput(); <br> <br>        return TRUE; <br>    } else { <br>        return FALSE; <br>    } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
