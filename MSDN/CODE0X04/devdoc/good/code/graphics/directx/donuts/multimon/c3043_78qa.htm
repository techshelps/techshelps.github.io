<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DONUTS.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3052"></a>DONUTS.CPP</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1995-1997 Microsoft Corporation. All Rights Reserved. <br> * <br> *  File:       donuts.cpp <br> * <br> *@@BEGIN_MSINTERNAL <br> *  History: <br> *   Date       By        Reason <br> *   ====       ==        ====== <br> *   15-sep-97  t-craigs  Created <br> *@@END_MSINTERNAL <br> * <br> ***************************************************************************/ <br> <br>#include "donuts.h" <br> <br>// globals defined here <br>CShipDL; // display list <br> <br>// globals defined elsewhere <br>externCMyMonitorMonitor[9]; <br>externBOOLbWantSound; <br> <br>#ifdef DEBUG <br>externchar        DebugBuf[256]; <br>#endif <br> <br>#ifdef USE_DSOUND <br>extern HSNDOBJhsoDonutExplode; <br>extern HSNDOBJhsoPyramidExplode; <br>extern HSNDOBJhsoCubeExplode; <br>extern HSNDOBJhsoSphereExplode; <br>extern HSNDOBJhsoShipExplode; <br>#endif <br> <br> <br>// constructor <br>CObject::CObject( int nMaxFrame, int nSize ) <br>{ <br>// constants <br>km_iMaxFrame = nMaxFrame; <br>km_iSize = nSize; <br> <br>// defaults <br>next = prev = this; <br>posx = posy = velx = vely = frame = delay = 0.0; <br>iMonitor = 0; <br>} <br> <br>// <br>// CLASS:CObject <br>// <br>// FUNCTION:Init <br>// <br>// DESCRIPTION:Initializes object data, links it to the display list <br>// <br>// NOTES: <br>// <br>void CObject::Init( double x, double y ) <br>{ <br>    iMonitor = DL.iMonitor; <br>posx = x; <br>    posy = y; <br>frame = randDouble( 0, 30 ); <br> <br>// link the object to the display list <br>    next = DL.next; <br>    prev = &amp;DL; <br>    DL.next-&gt;prev = this; <br>    DL.next = this; <br>} <br> <br>// <br>// CLASS:CObject <br>// <br>// FUNCTION:DeleteFromList <br>// <br>// DESCRIPTION:Removes this object from the display list <br>// <br>// NOTES: <br>// <br>void CObject::DeleteFromList() <br>{ <br>    next-&gt;prev = prev; <br>    prev-&gt;next = next; <br>    delete this; <br>} <br> <br>// <br>// CLASS:CObject <br>// <br>// FUNCTION:UpdateRect <br>// <br>// DESCRIPTION:Computes new dst and src rects <br>// <br>// NOTES:- src rect calculation performed by pure virtual fct UpdateSrcRect <br>// <br>void CObject::UpdateRect() <br>{ <br>dst.left = (DWORD)posx; <br>    dst.top = (DWORD)posy; <br>    dst.right = dst.left + km_iSize; <br>    dst.bottom = dst.top + km_iSize; <br> <br>// pure virtual fct call <br>UpdateSrcRect(); <br>} <br> <br> <br>// <br>// CLASS:CObject <br>// <br>// FUNCTION:Blt <br>// <br>// DESCRIPTION:Blts the object's bitmap to the back buffer <br>// <br>// NOTES:- surface bitmap determined by pure virtual fct GetSurface() <br>// <br>void CObject::Blt() <br>{ <br>RECTrc; <br>DWORDdwFlag; <br>DDBLTFX ddbltfx; <br>HRESULTddrval; <br> <br>rc.top = dst.top - Monitor[iMonitor].lpMonitorRect-&gt;top; <br>rc.left = dst.left - Monitor[iMonitor].lpMonitorRect-&gt;left; <br>rc.bottom = rc.top + (src.bottom - src.top); <br>rc.right = rc.left + (src.right - src.left); <br> <br>ddbltfx.dwSize = sizeof( ddbltfx ); <br>dwFlag = DDBLT_KEYSRC; <br> <br>while (1) <br>{ <br>ddrval = Monitor[iMonitor].lpBackBuffer-&gt;Blt( &amp;rc, GetSurface(), &amp;src, dwFlag, &amp;ddbltfx ); <br> <br>        if( ddrval == DD_OK ) <br>        { <br>            break; <br>        } <br>        if( ddrval == DDERR_SURFACELOST ) <br>        { <br>            ddrval = Monitor[iMonitor].RestoreSurfaces(); <br>if ( ddrval != DD_OK ) <br>{ <br>                CleanupAndExit("CObject::Blt (CMyMonitor::RestoreSurfaces failed", ddrval ); <br>return; <br>} <br>        } <br>        if( ddrval != DDERR_WASSTILLDRAWING ) <br>        { <br>            return; <br>        } <br>} <br>} <br> <br>// <br>// CLASS:CObject <br>// <br>// FUNCTION:UpdateFrame <br>// <br>// DESCRIPTION:Updates position and frame <br>// <br>// NOTES:- virtual fct <br>// <br>void CObject::UpdateFrame( DWORD tickDiff ) <br>{ <br>posx += velx * (double)tickDiff; <br>    posy += vely * (double)tickDiff; <br>    frame += delay * (double)tickDiff; <br>} <br> <br>// <br>// CLASS:CObject <br>// <br>// FUNCTION:CheckPosition <br>// <br>// DESCRIPTION:Identifies location on virtual desktop (which monitor) <br>// <br>// NOTES:- returns TRUE if the object has bounced off a wall <br>// <br>BOOL CObject::CheckPosition( DWORD tickDiff ) <br>{ <br>intiNewMonitor; <br>doublemaxx, minx, maxy, miny, maxframe; <br>BOOLevent; <br> <br>// virtual fct call <br>UpdateFrame( tickDiff ); <br> <br>maxx = (double) Monitor[iMonitor].lpMonitorRect-&gt;right - km_iSize; <br>minx = (double) Monitor[iMonitor].lpMonitorRect-&gt;left; <br>maxy = (double) Monitor[iMonitor].lpMonitorRect-&gt;bottom - km_iSize; <br>miny = (double) Monitor[iMonitor].lpMonitorRect-&gt;top; <br> <br>    maxframe = (double)km_iMaxFrame; <br> <br>    if( velx &gt; 0 &amp;&amp; posx &gt; maxx ) <br>{ <br>iNewMonitor = GetMonitorX(); <br>if ( iNewMonitor == iMonitor ) <br>{ <br>// bounce off the walls <br>posx = maxx; <br>velx = -velx; <br>event = TRUE; <br>} <br>else <br>{ <br>iMonitor = iNewMonitor; <br>} <br>} <br>else if ( velx &lt; 0 &amp;&amp; posx &lt; minx ) <br>{ <br>iNewMonitor = GetMonitorX(); <br>if ( iNewMonitor == iMonitor ) <br>{ <br>posx = minx; <br>velx = -velx; <br>event = TRUE; <br>} <br>else <br>{ <br>iMonitor = iNewMonitor; <br>} <br>} <br>else if( vely &gt; 0 &amp;&amp; posy &gt; maxy ) <br>{ <br>iNewMonitor = GetMonitorY(); <br>if ( iNewMonitor == iMonitor ) <br>{ <br>posy = maxy; <br>vely = -vely; <br>event = TRUE; <br>} <br>else <br>{ <br>iMonitor = iNewMonitor; <br>} <br>} <br>else if ( vely &lt; 0 &amp;&amp; posy &lt; miny ) <br>{ <br>iNewMonitor = GetMonitorY(); <br>if ( iNewMonitor == iMonitor ) <br>{ <br>posy = miny; <br>vely = -vely; <br>event = TRUE;} <br>else <br>{ <br>iMonitor = iNewMonitor; <br>} <br>} <br> <br>return event; <br>} <br> <br>// <br>// CLASS:CObject <br>// <br>// FUNCTION:CheckFrame <br>// <br>// DESCRIPTION:Checks for frame overflow <br>// <br>// NOTES:- returns TRUE if the object is to be removed from the display list <br>//- in this implementation, FALSE is always returned <br>// <br>BOOL CObject::CheckFrame() <br>{ <br>if( frame &gt;= km_iMaxFrame ) <br>{ <br>frame -= km_iMaxFrame; <br>} <br>return FALSE; <br>} <br> <br>// <br>// CLASS:CObject <br>// <br>// FUNCTION:GetMonitorX <br>// <br>// DESCRIPTION:Checks for object proximity to monitor x boundary <br>// <br>// NOTES:- returns the monitor on which the object is now located <br>// <br>int CObject::GetMonitorX() <br>{ <br>POINT pt; <br> <br>for (int i = 0; i &lt; CMonitor::iNumberOfMonitors; i++) <br>{ <br>// don't check the monitor we're on <br>if ( i == iMonitor ) <br>continue; <br> <br>pt.y = (long) posy; <br>pt.x = (long) posx - km_iSize - 1; <br> <br>if ( PtInRect( Monitor[i].lpMonitorRect, pt )) <br>{ <br>return i; <br>} <br>pt.x = (long) posx + km_iSize + 1; <br>if ( PtInRect(Monitor[i].lpMonitorRect, pt )) <br>{ <br>return i; <br>} <br>} <br>// if we get here, not close to any monitors <br>return iMonitor; <br>} <br> <br>// <br>// CLASS:CObject <br>// <br>// FUNCTION:GetMonitorY <br>// <br>// DESCRIPTION:Checks for object proximity to monitor y boundary <br>// <br>// NOTES:- returns the monitor on which the object is now located <br>// <br>int CObject::GetMonitorY() <br>{ <br>int i; <br>POINT pt; <br> <br>for (i = 0; i &lt; CMonitor::iNumberOfMonitors; i++) <br>{ <br>// don't check the monitor we're on <br>if ( i == iMonitor ) <br>continue; <br> <br>pt.x = (long) posx; <br>pt.y = (long) posy - km_iSize - 1; <br> <br>if ( PtInRect(Monitor[i].lpMonitorRect, pt )) <br>{ <br>return i; <br>} <br>pt.y = (long) posy + km_iSize + 1; <br>if ( PtInRect(Monitor[i].lpMonitorRect, pt )) <br>{ <br>return i; <br>} <br>} <br>// if we get here, not close to any monitors <br>return iMonitor; <br>} <br> <br>/* <br> * <br> * CDonut <br> * <br> */ <br> <br>// constructor <br>CDonut::CDonut() : <br>CObject( 30, 64 ) <br>{ <br>} <br> <br>// <br>// CLASS:CDonut <br>// <br>// FUNCTION:Init <br>// <br>// DESCRIPTION:Initializes donut data <br>// <br>// NOTES:- calls CObject::Init <br>// <br>void CDonut::Init( double x, double y ) <br>{ <br>CObject::Init( x, y ); <br>velx = randDouble( -50.0/1000.0, 50.0/1000.0 ); <br>    vely = randDouble( -50.0/1000.0, 50.0/1000.0 ); <br>    delay = 30.0*randDouble( 0.1, 0.4 )/1000.0; <br>} <br> <br>// <br>// CLASS:CDonut <br>// <br>// FUNCTION:UpdateSrcRect <br>// <br>// DESCRIPTION:Updates the donut src rect <br>// <br>// NOTES: <br>// <br>void CDonut::UpdateSrcRect() <br>{ <br>    DWORD dwframe = (DWORD) frame; <br>src.left = km_iSize * (dwframe % 5); <br>    src.top = km_iSize * (dwframe /5); <br>    src.right = src.left + km_iSize; <br>    src.bottom = src.top + km_iSize; <br>} <br> <br>// <br>// CLASS:CDonut <br>// <br>// FUNCTION:GetSurface <br>// <br>// DESCRIPTION:Returns the DDraw surface to be used for blitting <br>// <br>// NOTES: <br>// <br>LPDIRECTDRAWSURFACE CDonut::GetSurface() <br>{ <br>return Monitor[iMonitor].lpDonut; <br>} <br> <br>// <br>// CLASS:CDonut <br>// <br>// FUNCTION:Hit <br>// <br>// DESCRIPTION:Adds objects to the display list and returns the score bonus <br>// <br>// NOTES: <br>// <br>int CDonut::Hit( double l, double t ) <br>{ <br>#ifdef USE_DSOUND <br>if(bWantSound) <br>{ <br>    PlayPanned(hsoDonutExplode, posx); <br>} <br>#endif <br>CObject* pObj; <br> <br>pObj = new CPyramid; <br>pObj-&gt;Init(dst.left, dst.top); <br> <br>pObj = new CPyramid; <br>pObj-&gt;Init(dst.left, dst.top); <br> <br>pObj = new CPyramid; <br>pObj-&gt;Init(dst.left, dst.top); <br> <br>return 10; <br>} <br> <br> <br>/* <br> * <br> * CPyramid <br> * <br> */ <br> <br>// constructor <br>CPyramid::CPyramid() : <br>CObject( 40, 32 ) <br>{ <br>} <br> <br>// <br>// CLASS:CPyramid <br>// <br>// FUNCTION:Init <br>// <br>// DESCRIPTION:Initializes pyramid data <br>// <br>// NOTES:- calls CObject::Init <br>// <br>void CPyramid::Init( double x, double y ) <br>{ <br>CObject::Init( x, y ); <br>velx = 1.5*randDouble( -50.0/1000.0, 50.0/1000.0 ); <br>    vely = 1.5*randDouble( -50.0/1000.0, 50.0/1000.0 ); <br>    delay = 40.0*randDouble( 0.3, 1.0 )/1000.0; <br>} <br> <br>// <br>// CLASS:CPyramid <br>// <br>// FUNCTION:UpdateSrcRect <br>// <br>// DESCRIPTION:Updates the pyramid src rect <br>// <br>// NOTES: <br>// <br>void CPyramid::UpdateSrcRect() <br>{ <br>    DWORD dwFrame = (DWORD) frame; <br>src.left = km_iSize * (dwFrame % 10); <br>    src.top = km_iSize * (dwFrame /10); <br>    src.right = src.left + km_iSize; <br>    src.bottom = src.top + km_iSize; <br>} <br> <br>// <br>// CLASS:CPyramid <br>// <br>// FUNCTION:GetSurface <br>// <br>// DESCRIPTION:Returns the DDraw surface to be used for blitting <br>// <br>// NOTES: <br>// <br>LPDIRECTDRAWSURFACE CPyramid::GetSurface() <br>{ <br>return Monitor[iMonitor].lpPyramid; <br>} <br> <br>// <br>// CLASS:CPyramid <br>// <br>// FUNCTION:Hit <br>// <br>// DESCRIPTION:Adds objects to the display list and returns the score bonus <br>// <br>// NOTES: <br>// <br>int CPyramid::Hit( double l, double t) <br>{ <br>#ifdef USE_DSOUND <br>if(bWantSound) <br>{ <br>        PlayPanned(hsoPyramidExplode, posx); <br>} <br>#endif <br>CObject* pObj = new CSphere; <br>pObj-&gt;Init( dst.left, dst.top ); <br> <br>pObj = new CCube; <br>pObj-&gt;Init( dst.left, dst.top ); <br> <br>pObj = new CCube; <br>pObj-&gt;Init( dst.left, dst.top ); <br> <br>return 20; <br>} <br> <br>/* <br> * <br> * CCube <br> * <br> */ <br> <br>// constructor <br>CCube::CCube() : <br>CObject( 40, 16 ) <br>{ <br>} <br> <br> <br>// <br>// CLASS:CCube <br>// <br>// FUNCTION:Init <br>// <br>// DESCRIPTION:Initializes cube data <br>// <br>// NOTES:- calls CObject::Init <br>// <br>void CCube::Init( double x, double y ) <br>{ <br>CObject::Init( x, y ); <br>    velx = 4.0*randDouble( -50.0/1000.0, 50.0/1000.0 ); <br>    vely = 4.0*randDouble( -50.0/1000.0, 50.0/1000.0 ); <br>    delay = 40.0*randDouble( 0.8, 2.0 )/1000.0; <br>} <br> <br>// <br>// CLASS:CCube <br>// <br>// FUNCTION:UpdateSrcRect <br>// <br>// DESCRIPTION:Updates the cube src rect <br>// <br>// NOTES: <br>// <br>void CCube::UpdateSrcRect() <br>{ <br>DWORD dwFrame = (DWORD) frame; <br>    src.left = km_iSize * (dwFrame % 20); <br>    src.top = km_iSize * (dwFrame /20); <br>    src.right = src.left + km_iSize; <br>    src.bottom = src.top + km_iSize; <br>} <br> <br> <br>// <br>// CLASS:CCube <br>// <br>// FUNCTION:GetSurface <br>// <br>// DESCRIPTION:Returns the DDraw surface to be used for blitting <br>// <br>// NOTES: <br>// <br>LPDIRECTDRAWSURFACE CCube::GetSurface() <br>{ <br>return Monitor[iMonitor].lpCube; <br>} <br> <br> <br>// <br>// CLASS:CCube <br>// <br>// FUNCTION:Hit <br>// <br>// DESCRIPTION:Adds objects to the display list and returns the score bonus <br>// <br>// NOTES: <br>// <br>int CCube::Hit( double l, double t ) <br>{ <br>#ifdef USE_DSOUND <br>if(bWantSound) <br>{ <br>        PlayPanned(hsoCubeExplode, posx); <br>} <br>#endif <br>CObject* pObj = new CSphere; <br>pObj-&gt;Init( dst.left, dst.top ); <br> <br>pObj = new CSphere; <br>pObj-&gt;Init( dst.left, dst.top ); <br> <br>return 40; <br>} <br> <br> <br>/* <br> * <br> * CSphere <br> * <br> */ <br> <br>// constructor <br>CSphere::CSphere() : <br>CObject( 40, 16 ) <br>{ <br>} <br> <br>// <br>// CLASS:CSphere <br>// <br>// FUNCTION:Init <br>// <br>// DESCRIPTION:Initializes sphere data <br>// <br>// NOTES:- calls CObject::Init <br>// <br>void CSphere::Init( double x, double y ) <br>{ <br>CObject::Init( x, y ); <br>    velx = 3.0*randDouble( -50.0/1000.0, 50.0/1000.0 ); <br>    vely = 3.0*randDouble( -50.0/1000.0, 50.0/1000.0 ); <br>    delay = 40.0*randDouble( 1.5, 2.0 )/1000.0; <br>} <br> <br>// <br>// CLASS:CSphere <br>// <br>// FUNCTION:UpdateSrcRect <br>// <br>// DESCRIPTION:Updates the sphere src rect <br>// <br>// NOTES: <br>// <br>void CSphere::UpdateSrcRect() <br>{ <br>DWORD dwFrame = (DWORD) frame; <br>    src.left = km_iSize * (dwFrame % 20); <br>    src.top = km_iSize * (dwFrame /20); <br>    src.right = src.left + km_iSize; <br>    src.bottom = src.top + km_iSize; <br>} <br> <br> <br>// <br>// CLASS:CSphere <br>// <br>// FUNCTION:GetSurface <br>// <br>// DESCRIPTION:Returns the DDraw surface to be used for blitting <br>// <br>// NOTES: <br>// <br>LPDIRECTDRAWSURFACE CSphere::GetSurface() <br>{ <br>return Monitor[iMonitor].lpSphere; <br>} <br> <br>// <br>// CLASS:CSphere <br>// <br>// FUNCTION:Hit <br>// <br>// DESCRIPTION:Adds objects to the display list and returns the score bonus <br>// <br>// NOTES: <br>// <br>int CSphere::Hit( double l, double t) <br>{ <br>#ifdef USE_DSOUND <br>if(bWantSound) <br>{ <br>        PlayPanned(hsoSphereExplode, posx); <br>} <br>#endif <br>    return 20; <br>} <br> <br> <br>/* <br> * <br> * CShip <br> * <br> */ <br> <br>// constructor <br>CShip::CShip() : <br>CObject( 40, 32 ) <br>{ <br>} <br> <br>// <br>// CLASS:CShip <br>// <br>// FUNCTION:Init <br>// <br>// DESCRIPTION:Initializes ship data <br>// <br>// NOTES: <br>// <br>void CShip::Init() <br>{ <br>LPRECTlprect = Monitor[iMonitor].lpMonitorRect; <br> <br>posx = lprect-&gt;left + (double)(Monitor[iMonitor].dwWidth - km_iSize) /2;    // center the ship <br>    posy = lprect-&gt;top  + (double)(Monitor[iMonitor].dwHeight - km_iSize) /2; <br>    frame = 0.0; <br>    velx = vely = 0.0;// not moving <br>} <br> <br>// <br>// CLASS:CShip <br>// <br>// FUNCTION:UpdateSrcRect <br>// <br>// DESCRIPTION:Updates the ship src rect <br>// <br>// NOTES: <br>// <br>void CShip::UpdateSrcRect() <br>{ <br>DWORD dwFrame = (DWORD) frame; <br>if( lastShield ) <br>src.top = km_iSize * (dwFrame / 10) + 128; <br>else <br>        src.top = km_iSize * (dwFrame /10); <br>    src.left = km_iSize * (dwFrame % 10); <br>    src.right = src.left + km_iSize; <br>    src.bottom = src.top + km_iSize; <br>} <br> <br>// <br>// CLASS:CShip <br>// <br>// FUNCTION:GetSurface <br>// <br>// DESCRIPTION:Returns the DDraw surface to be used for blitting <br>// <br>// NOTES: <br>// <br>LPDIRECTDRAWSURFACE CShip::GetSurface() <br>{ <br>return Monitor[iMonitor].lpShip; <br>} <br> <br>// <br>// CLASS:CShip <br>// <br>// FUNCTION:Hit <br>// <br>// DESCRIPTION:Adds objects to the display list and returns the score bonus <br>// <br>// NOTES: <br>// <br>int CShip::Hit( double l, double t ) <br>{ <br>#ifdef USE_DSOUND <br>if(bWantSound) <br>{ <br>        PlayPanned(hsoShipExplode, posx); <br>} <br>#endif <br> <br>CObject* pObj; <br> <br>for (int i = 0; i &lt; 4; i++) <br>{ <br>pObj = new CSphere; <br>pObj-&gt;Init( l, t ); <br>} <br> <br>for (i = 0; i &lt; 10; i++) <br>{ <br>pObj = new CBullet; <br>pObj-&gt;Init( l, t ); <br>pObj-&gt;velx = randDouble( -0.5, 0.5 ); <br>pObj-&gt;vely = randDouble( -0.5, 0.5 ); <br>} <br> <br>Init(); <br> <br>return -150; <br>} <br> <br>// <br>// CLASS:CShip <br>// <br>// FUNCTION:UpdateFrame <br>// <br>// DESCRIPTION:Updates ship position <br>// <br>// NOTES:- unlike other objects, frame is not time-dependent <br>// <br>void CShip::UpdateFrame( DWORD tickDiff ) <br>{ <br>posx += velx * (double)tickDiff; <br>    posy += vely * (double)tickDiff; <br>// don't change the frame based on time <br>} <br> <br> <br> <br>/* <br> * <br> * CBullet <br> * <br> */ <br> <br>// constructor <br>CBullet::CBullet() : <br>CObject( 400, 3 ) <br>{ <br>} <br> <br>// <br>// CLASS:CBullet <br>// <br>// FUNCTION:Init <br>// <br>// DESCRIPTION:Initializes bullet data <br>// <br>// NOTES: <br>// <br>void CBullet::Init( double x, double y ) <br>{ <br>CObject::Init( x, y ); <br>    frame = 0.0; <br>    delay = 1.0; <br>} <br> <br> <br> <br>// <br>// CLASS:CBullet <br>// <br>// FUNCTION:UpdateSrcRect <br>// <br>// DESCRIPTION:Updates the bullet src rect <br>// <br>// NOTES: <br>// <br>void CBullet::UpdateSrcRect() <br>{ <br>DWORD dwFrame = (DWORD)frame/20 % 4; <br>    src.left = BULLET_X + dwFrame*4; <br>    src.top = BULLET_Y; <br>    src.right = src.left + km_iSize; <br>    src.bottom = src.top + km_iSize; <br>} <br> <br>// <br>// CLASS:CBullet <br>// <br>// FUNCTION:GetSurface <br>// <br>// DESCRIPTION:Returns the DDraw surface to be used for blitting <br>// <br>// NOTES: <br>// <br>LPDIRECTDRAWSURFACE CBullet::GetSurface() <br>{ <br>return Monitor[iMonitor].lpNum; <br>} <br> <br> <br>// <br>// CLASS:CBullet <br>// <br>// FUNCTION:Hit <br>// <br>// DESCRIPTION:Never called, bullets can't be hit <br>// <br>// NOTES:- an implementation must be provided because Hit is declared <br>//  pure virtual in the base class <br>// <br>int CBullet::Hit( double l, double t ) <br>{ <br>return 0; <br>} <br> <br>// <br>// CLASS:CBullet <br>// <br>// FUNCTION:CheckFrame <br>// <br>// DESCRIPTION:Checks for frame overflow <br>// <br>// NOTES:- returns TRUE if the bullet has expired <br>// <br>BOOL CBullet::CheckFrame() <br>{ <br>return ( frame &gt;= km_iMaxFrame); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
