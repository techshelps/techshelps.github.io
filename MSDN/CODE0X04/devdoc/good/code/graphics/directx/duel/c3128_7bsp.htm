<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GFX.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3139"></a>GFX.C</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1995-1997 Microsoft Corporation. All Rights Reserved. <br> * <br> *  File:       gfx.c <br> *  Content:    DirectDraw related code. <br> * <br> * <br> ***************************************************************************/ <br>#include "gfx.h" <br>#include "input.h" <br>#include "ddutil.h" <br> <br>/* <br> * Externals <br> */ <br>extern BOOL             gbUseEmulation;     // user DDHEL or DDHAL ? <br>extern BOOLgbFullscreen;// window or fullscreen mode ? <br>extern HWNDghWndMain;// main window <br>extern DWORDgdwKeys; <br>extern int              gnProgramState;     // current state of program (rest, splash, active, etc.) <br>extern RECTgrcWindow;          // client window rectangle <br>extern BOOLgbFullscreen;// fullscreen or window mode ? <br>extern HINSTANCEghinst;// application instance handle <br>extern TCHARgtszClassName[];// Duel's class name <br> <br> <br>/* <br> * Globals <br> */ <br>LPDIRECTDRAWSURFACE     glpFrontBuffer;// primary surface <br>LPDIRECTDRAWSURFACE     glpBackBuffer;// back buffer for animation <br>LPDIRECTDRAWSURFACEglpSplash;// splash screen <br>LPDIRECTDRAWSURFACE     glpShip0;// ship bitmaps <br>LPDIRECTDRAWSURFACE     glpShip1; <br>LPDIRECTDRAWSURFACE     glpShip2; <br>LPDIRECTDRAWSURFACE     glpShip3; <br>LPDIRECTDRAWSURFACE     glpNum;// Numbers bitmap <br>LPDIRECTDRAW            glpDD;// DirectDraw interface <br>LPDIRECTDRAWPALETTE     glpArtPalette=NULL;// Game screen palette <br>LPDIRECTDRAWPALETTE     glpSplashPalette=NULL;// Splash screen palette <br>LPDIRECTDRAWCLIPPERglpClipper=NULL;// Clipper for front buffer <br>DWORD                   gdwFillColor; <br>intgnGameBPP;// primary surface bit depth <br>#ifdef DEBUG <br>BOOL                    gbHELBlt = FALSE; <br>#endif <br> <br>BOOL InitGraphics( void ) <br>{ <br>    DDCAPS          ddcaps; <br>    HRESULT         ddrval; <br>    DDSURFACEDESC   ddsd; <br>    DDSCAPS         ddscaps; <br>TCHARtszTitle[MAX_WINDOWTITLE]; <br> <br>LoadString(ghinst, IDS_DUEL_TITLE, tszTitle, MAX_WINDOWTITLE); <br> <br>// Create a window <br>    ghWndMain = CreateWindowEx( <br>WS_EX_APPWINDOW,  // WS_EX_TOPMOST, <br>        gtszClassName, <br>        tszTitle, <br> // don't show the window yet  <br>        WS_POPUP |   // non-app window POPUP <br>        WS_SYSMENU,  // so we get an icon in the tray <br>        0, <br>        0, <br>        GetSystemMetrics(SM_CXSCREEN), <br>        GetSystemMetrics(SM_CYSCREEN), <br>        NULL, <br>        NULL, <br>        ghinst, <br>        NULL ); <br> <br>    if( !ghWndMain ) <br>    { <br>        return FALSE; <br>    } <br> <br>    UpdateWindow( ghWndMain ); <br>    SetFocus( ghWndMain ); <br> <br>// ddraw stuff begins here <br>    if( gbUseEmulation ) <br>        ddrval = DirectDrawCreate( (LPVOID) DDCREATE_EMULATIONONLY, &amp;glpDD, NULL ); <br>    else <br>        ddrval = DirectDrawCreate( NULL, &amp;glpDD, NULL ); <br> <br>    if( ddrval != DD_OK ) <br>        return ShowError(IDS_DDRAW_ERROR_DDC); <br> <br>// set access mode based on fullscreen/window <br>if (gbFullscreen)  <br>{ <br>ddrval = glpDD-&gt;lpVtbl-&gt;SetCooperativeLevel( glpDD, ghWndMain, <br>                            DDSCL_EXCLUSIVE | DDSCL_FULLSCREEN ); <br>} <br>else <br>{ <br>ddrval = glpDD-&gt;lpVtbl-&gt;SetCooperativeLevel( glpDD, ghWndMain, <br>                            DDSCL_NORMAL); <br>} <br> <br>    if( ddrval != DD_OK ) <br>        return ShowError(IDS_DDRAW_ERROR_SCL); <br> <br>if (gbFullscreen) <br>{ <br>    // set the mode to 640 by 480 by 8 <br>ddrval = glpDD-&gt;lpVtbl-&gt;SetDisplayMode( glpDD, 640, 480, 8 ); <br>     <br>if( ddrval != DD_OK ) <br>    return ShowError(IDS_DDRAW_ERROR_SDM); <br>} <br>else <br>{ <br>RECT rcWork; <br>RECT rc; <br>HDC hdc; <br>DWORD dwStyle; <br> <br>// <br>//  when in rome (I mean when in windows) we should use the <br>//  current mode <br>// <br>hdc = GetDC(NULL); <br>gnGameBPP = GetDeviceCaps(hdc, PLANES) * GetDeviceCaps(hdc, BITSPIXEL); <br>ReleaseDC(NULL, hdc); <br> <br>// <br>// if we are still a WS_POPUP window we should convert to a <br>// normal app window so we look like a windows app. <br>// <br>dwStyle = GetWindowStyle(ghWndMain); <br>dwStyle &amp;= ~WS_POPUP; <br>dwStyle |= WS_OVERLAPPED | WS_CAPTION | WS_THICKFRAME | WS_MINIMIZEBOX; <br>SetWindowLong(ghWndMain, GWL_STYLE, dwStyle); <br> <br>// set window size <br>SetRect(&amp;rc, 0, 0, MAX_DEFWIN_X, MAX_DEFWIN_Y); <br> <br>AdjustWindowRectEx(&amp;rc, <br>GetWindowStyle(ghWndMain), <br>GetMenu(ghWndMain) != NULL, <br>GetWindowExStyle(ghWndMain)); <br> <br>SetWindowPos(ghWndMain, NULL, 0, 0, rc.right-rc.left, rc.bottom-rc.top, <br>SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE); <br> <br>SetWindowPos(ghWndMain, HWND_NOTOPMOST, 0, 0, 0, 0, <br>SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE); <br> <br>// <br>//  make sure our window does not hang outside of the work area <br>//  this will make people who have the tray on the top or left <br>//  happy. <br>// <br>SystemParametersInfo(SPI_GETWORKAREA, 0, &amp;rcWork, 0); <br>GetWindowRect(ghWndMain, &amp;rc); <br>if (rc.left &lt; rcWork.left) rc.left = rcWork.left; <br>if (rc.top  &lt; rcWork.top)  rc.top  = rcWork.top; <br>SetWindowPos(ghWndMain, NULL, rc.left, rc.top, 0, 0, <br>SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE); <br>} <br> <br>    // check the color key hardware capabilities <br>    ddcaps.dwSize = sizeof( ddcaps ); <br> <br>memset( &amp;ddsd, 0, sizeof( ddsd ) ); <br>ddsd.dwSize = sizeof( ddsd ); <br> <br>if (gbFullscreen) <br>{ <br>// Create surfaces <br>ddsd.dwFlags = DDSD_CAPS | DDSD_BACKBUFFERCOUNT; <br>ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE | <br>  DDSCAPS_FLIP | <br>  DDSCAPS_COMPLEX; <br>ddsd.dwBackBufferCount = 1; <br>ddrval = glpDD-&gt;lpVtbl-&gt;CreateSurface( glpDD, &amp;ddsd, &amp;glpFrontBuffer, NULL ); <br>if( ddrval != DD_OK ) <br>return ShowError(IDS_DDRAW_ERROR_CSFB); <br> <br>// get a pointer to the back buffer <br>ddscaps.dwCaps = DDSCAPS_BACKBUFFER; <br>ddrval = glpFrontBuffer-&gt;lpVtbl-&gt;GetAttachedSurface( <br>glpFrontBuffer, <br>&amp;ddscaps, <br>&amp;glpBackBuffer ); <br>if( ddrval != DD_OK ) <br>return ShowError(IDS_DDRAW_ERROR_GAS); <br>} <br>else <br>{ <br>// window case, create the primary surface <br>// and create a backbuffer in offscreen memory <br>ddsd.dwFlags = DDSD_CAPS; <br>ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE; <br> <br>ddrval = glpDD-&gt;lpVtbl-&gt;CreateSurface( glpDD, &amp;ddsd, &amp;glpFrontBuffer, NULL ); <br>if( ddrval != DD_OK ) <br>return ShowError(IDS_DDRAW_ERROR_CSFB); <br> <br>ddsd.dwFlags = DDSD_CAPS | DDSD_WIDTH | DDSD_HEIGHT; <br>ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN; <br> <br>ddsd.dwWidth = MAX_DEFWIN_X; <br>ddsd.dwHeight = MAX_DEFWIN_Y; <br>ddrval = glpDD-&gt;lpVtbl-&gt;CreateSurface( glpDD, &amp;ddsd, &amp;glpBackBuffer, NULL ); <br>if( ddrval != DD_OK ) <br>return ShowError(IDS_DDRAW_ERROR_CSBB); <br> <br>ddrval = glpDD-&gt;lpVtbl-&gt;CreateClipper(glpDD, 0, &amp;glpClipper, NULL); <br>if( ddrval != DD_OK ) <br>return ShowError(IDS_DDRAW_ERROR_CC); <br> <br>ddrval = glpClipper-&gt;lpVtbl-&gt;SetHWnd(glpClipper, 0, ghWndMain); <br>if( ddrval != DD_OK ) <br>return ShowError(IDS_DDRAW_ERROR_SH); <br> <br>ddrval = glpFrontBuffer-&gt;lpVtbl-&gt;SetClipper(glpFrontBuffer, glpClipper); <br>if( ddrval != DD_OK ) <br>return ShowError(IDS_DDRAW_ERROR_SC); <br>} <br> <br>    ddsd.dwFlags = DDSD_CAPS | DDSD_WIDTH | DDSD_HEIGHT; <br>    ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN; <br>#ifdef DEBUG <br>    if( gbHELBlt ) <br>        ddsd.ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY; <br>#endif <br> <br>    ddsd.dwWidth = 320; <br>    ddsd.dwHeight = 128; <br>    ddrval = glpDD-&gt;lpVtbl-&gt;CreateSurface( glpDD, &amp;ddsd, &amp;glpShip0, NULL ); <br>    if( ddrval != DD_OK ) <br>return ShowError(IDS_DDRAW_ERROR_CSS0); <br> <br>    ddsd.dwWidth = 320; <br>    ddsd.dwHeight = 128; <br>    ddrval = glpDD-&gt;lpVtbl-&gt;CreateSurface( glpDD, &amp;ddsd, &amp;glpShip1, NULL ); <br>    if( ddrval != DD_OK ) <br>return ShowError(IDS_DDRAW_ERROR_CSS1); <br> <br>    ddsd.dwWidth = 320; <br>    ddsd.dwHeight = 128; <br>    ddrval = glpDD-&gt;lpVtbl-&gt;CreateSurface( glpDD, &amp;ddsd, &amp;glpShip2, NULL ); <br>    if( ddrval != DD_OK ) <br>return ShowError(IDS_DDRAW_ERROR_CSS2); <br> <br>    ddsd.dwWidth = 320; <br>    ddsd.dwHeight = 128; <br>    ddrval = glpDD-&gt;lpVtbl-&gt;CreateSurface( glpDD, &amp;ddsd, &amp;glpShip3, NULL ); <br>    if( ddrval != DD_OK ) <br>return ShowError(IDS_DDRAW_ERROR_CSS3); <br> <br>    ddsd.dwHeight = 16; <br>    ddrval = glpDD-&gt;lpVtbl-&gt;CreateSurface( glpDD, &amp;ddsd, &amp;glpNum, NULL ); <br>    if( ddrval != DD_OK ) <br>return ShowError(IDS_DDRAW_ERROR_CSN); <br> <br>    if( !RestoreSurfaces() ) <br>        return ShowError(IDS_DDRAW_ERROR_RS); <br> <br>    gdwKeys = 0; <br>ShowWindow(ghWndMain, SW_SHOW); <br>    return TRUE; <br>} <br> <br>void CleanupGraphics(void) <br>{ <br>    if( glpShip0 != NULL ) <br>glpShip0-&gt;lpVtbl-&gt;Release( glpShip0 ); <br> <br>    if( glpShip1 != NULL ) <br>glpShip1-&gt;lpVtbl-&gt;Release( glpShip1 ); <br> <br>    if( glpShip2 != NULL ) <br>glpShip2-&gt;lpVtbl-&gt;Release( glpShip2 ); <br> <br>    if( glpShip3 != NULL ) <br>glpShip3-&gt;lpVtbl-&gt;Release( glpShip3 ); <br> <br>    if( glpNum != NULL ) <br>glpNum-&gt;lpVtbl-&gt;Release( glpNum ); <br> <br>if (!gbFullscreen &amp;&amp; glpClipper) <br>glpClipper-&gt;lpVtbl-&gt;Release( glpClipper ); <br> <br>    if( glpFrontBuffer != NULL ) <br>glpFrontBuffer-&gt;lpVtbl-&gt;Release( glpFrontBuffer ); <br> <br>     if( glpArtPalette != NULL ) <br>glpArtPalette-&gt;lpVtbl-&gt;Release( glpArtPalette ); <br> <br>    if( glpSplashPalette != NULL ) <br>glpSplashPalette-&gt;lpVtbl-&gt;Release( glpSplashPalette ); <br> <br>   if( !gbFullscreen &amp;&amp; (glpBackBuffer != NULL )) <br>glpBackBuffer-&gt;lpVtbl-&gt;Release( glpBackBuffer ); <br> <br>    if( glpDD != NULL ) <br>        glpDD-&gt;lpVtbl-&gt;Release( glpDD ); <br>} <br> <br>void bltSplash( LPRECT rc) <br>{ <br>    HRESULT     ddrval; <br>    HBITMAP     hbm; <br> <br>    if( ( glpFrontBuffer == NULL ) || <br>        ( glpSplashPalette == NULL ) || <br>( glpBackBuffer == NULL ) ) <br>    { <br>        return; <br>    } <br> <br>    // set the palette before loading the splash screen <br>glpFrontBuffer-&gt;lpVtbl-&gt;SetPalette( glpFrontBuffer, glpSplashPalette ); <br> <br>    hbm = (HBITMAP)LoadImage( GetModuleHandle( NULL ), TEXT("SPLASH"), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION ); <br>    if ( NULL == hbm ) <br>return; <br> <br>    // if the surface is lost, DDCopyBitmap will fail and the surface will <br>    // be restored below. <br>    ddrval = DDCopyBitmap( glpBackBuffer, hbm, 0, 0, 0, 0 ); <br> <br>    DeleteObject( hbm ); <br> <br>    while( 1 ) <br>    { <br>        if( NULL == rc) <br>{ <br>ddrval = glpFrontBuffer-&gt;lpVtbl-&gt;Blt( glpFrontBuffer,  <br>&amp;grcWindow, glpBackBuffer, NULL, DDBLT_WAIT, NULL); <br>} <br>else <br>{ <br>ddrval = glpFrontBuffer-&gt;lpVtbl-&gt;Blt( glpFrontBuffer,  <br>&amp;grcWindow, glpBackBuffer, rc, DDBLT_WAIT, NULL); <br>} <br> <br>        if( ddrval == DD_OK ) <br>    return; <br>        if( ddrval == DDERR_SURFACELOST ) <br>            if( !RestoreSurfaces() ) <br>                return; <br>        if( ddrval != DDERR_WASSTILLDRAWING ) <br>            return; <br>    } <br>} <br> <br>void bltScore( char *num, int x, int y ) <br>{ <br>    char *c; <br>    RECT    src; <br>    int     i; <br> <br>    for(c=num; *c != '\0'; c++) <br>    { <br>        i = *c - '0'; <br>        src.left = i*16; <br>        src.top = 0; <br>        src.right = src.left + 16; <br>        src.bottom = src.top + 16; <br>bltObject( x, y, glpNum, &amp;src, DDBLTFAST_SRCCOLORKEY ); <br>        x += 16; <br>    } <br>} <br> <br>void bltObject( int x, int y, LPDIRECTDRAWSURFACE surf, LPRECT src, DWORD flags ) <br>{ <br>    HRESULT ddrval; <br> <br>    while( 1 ) <br>    { <br>        ddrval = glpBackBuffer-&gt;lpVtbl-&gt;BltFast( glpBackBuffer, x, y, surf, src, flags ); <br>        if( ddrval == DD_OK ) <br>    return; <br>        if( ddrval == DDERR_SURFACELOST ) <br>            if( !RestoreSurfaces() ) <br>                return; <br>        if( ddrval != DDERR_WASSTILLDRAWING ) <br>            return; <br>    } <br>} <br> <br>void EraseScreen( void ) <br>{ <br>    DDBLTFX     ddbltfx; <br>    HRESULT     ddrval; <br> <br>    // Erase the background <br>    ddbltfx.dwSize = sizeof( ddbltfx ); <br>    ddbltfx.dwFillColor = gdwFillColor; <br>    while( 1 ) <br>    { <br>        ddrval = glpBackBuffer-&gt;lpVtbl-&gt;Blt( glpBackBuffer, NULL, NULL, <br>                 NULL, DDBLT_COLORFILL, &amp;ddbltfx ); <br> <br>        if( ddrval == DD_OK ) <br>        { <br>            break; <br>        } <br>        if( ddrval == DDERR_SURFACELOST ) <br>        { <br>            if( !RestoreSurfaces() ) <br>                return; <br>        } <br>        if( ddrval != DDERR_WASSTILLDRAWING ) <br>        { <br>            return; <br>        } <br>    } <br>} <br> <br>void FlipScreen( void ) <br>{ <br>    HRESULT     ddrval; <br> <br>    // Flip the surfaces <br>if (gbFullscreen) <br>{ <br>while( 1 ) <br>{ <br>ddrval = glpFrontBuffer-&gt;lpVtbl-&gt;Flip( glpFrontBuffer, NULL, 0 ); <br>if( ddrval == DD_OK ) <br>{ <br>break; <br>} <br>if( ddrval == DDERR_SURFACELOST ) <br>{ <br>if( !RestoreSurfaces() ) <br>{ <br>return; <br>} <br>} <br>if( ddrval != DDERR_WASSTILLDRAWING ) <br>{ <br>break; <br>} <br>} <br>    } <br>else <br>{ <br>    ddrval = IDirectDrawSurface_Blt( <br>                    glpFrontBuffer,          // dest surface <br>                    &amp;grcWindow,              // dest rect <br>                    glpBackBuffer,           // src surface <br>                    NULL,                   // src rect (all of it) <br>                    DDBLT_WAIT, <br>                    NULL); <br>} <br>} <br> <br>BOOL RestoreSurfaces( void ) <br>{ <br>    HRESULTddrval; <br>    HBITMAP     hbm; <br> <br>    ddrval = glpFrontBuffer-&gt;lpVtbl-&gt;Restore(glpFrontBuffer); <br>    if( ddrval != DD_OK ) <br>        return FALSE; <br>ddrval = glpBackBuffer-&gt;lpVtbl-&gt;Restore(glpBackBuffer); <br>if( ddrval != DD_OK ) <br>return FALSE; <br>    ddrval = glpShip0-&gt;lpVtbl-&gt;Restore(glpShip0); <br>    if( ddrval != DD_OK ) <br>        return FALSE; <br>    ddrval = glpShip1-&gt;lpVtbl-&gt;Restore(glpShip1); <br>    if( ddrval != DD_OK ) <br>        return FALSE; <br>    ddrval = glpShip2-&gt;lpVtbl-&gt;Restore(glpShip2); <br>    if( ddrval != DD_OK ) <br>        return FALSE; <br>    ddrval = glpShip3-&gt;lpVtbl-&gt;Restore(glpShip3); <br>    if( ddrval != DD_OK ) <br>        return FALSE; <br>    ddrval = glpNum-&gt;lpVtbl-&gt;Restore(glpNum); <br>    if( ddrval != DD_OK ) <br>        return FALSE; <br> <br>    // Create and set the palette for the splash bitmap <br>    glpSplashPalette = DDLoadPalette( glpDD, TEXT("SPLASH") ); <br>    if( NULL == glpSplashPalette ) <br>return FALSE; <br> <br>    // Create and set the palette for the art bitmap <br>    glpArtPalette = DDLoadPalette( glpDD, TEXT("Duel8") ); <br>    if( NULL == glpArtPalette ) <br>return FALSE; <br> <br>    // set the palette before loading the art <br>    glpFrontBuffer-&gt;lpVtbl-&gt;SetPalette( glpFrontBuffer, glpArtPalette ); <br> <br>    hbm = (HBITMAP)LoadImage(GetModuleHandle(NULL), TEXT("Duel8"), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION ); <br> <br>    if( NULL == hbm ) <br>        return FALSE; <br> <br>    ddrval = DDCopyBitmap( glpShip0, hbm, 0, 0, 320, 128 ); <br>    if( ddrval != DD_OK ) <br>    { <br>        DeleteObject( hbm ); <br>return FALSE; <br>    } <br> <br>    ddrval = DDCopyBitmap( glpShip1, hbm, 0, 128, 320, 128 ); <br>    if( ddrval != DD_OK ) <br>    { <br>        DeleteObject( hbm ); <br>return FALSE; <br>    } <br> <br>    ddrval = DDCopyBitmap( glpShip2, hbm, 0, 256, 320, 128 ); <br>    if( ddrval != DD_OK ) <br>    { <br>        DeleteObject( hbm ); <br>return FALSE; <br>    } <br> <br>    ddrval = DDCopyBitmap( glpShip3, hbm, 0, 384, 320, 128 ); <br>    if( ddrval != DD_OK ) <br>    { <br>        DeleteObject( hbm ); <br>return FALSE; <br>    } <br> <br>    ddrval = DDCopyBitmap( glpNum, hbm, 0, 512, 320, 16 ); <br>    if( ddrval != DD_OK ) <br>    { <br>        DeleteObject( hbm ); <br>return FALSE; <br>    } <br> <br>    DeleteObject( hbm ); <br> <br>    // set colorfill colors and color gdwKeys according to bitmap contents <br>    gdwFillColor = DDColorMatch( glpShip0, CLR_INVALID ); <br>     <br>    DDSetColorKey( glpShip0, CLR_INVALID ); <br>    DDSetColorKey( glpShip1, CLR_INVALID ); <br>    DDSetColorKey( glpShip2, CLR_INVALID ); <br>    DDSetColorKey( glpShip3, CLR_INVALID ); <br>    DDSetColorKey( glpNum, CLR_INVALID ); <br> <br>    return TRUE; <br>} <br> <br>void SetGamePalette(void) <br>{ <br>if (glpFrontBuffer) <br>glpFrontBuffer-&gt;lpVtbl-&gt;SetPalette( glpFrontBuffer, glpArtPalette ); <br>} <br> <br>void FlipToGDI(void) <br>{ <br>if (glpDD)  <br>glpDD-&gt;lpVtbl-&gt;FlipToGDISurface( glpDD ); <br>} <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
