<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DS3DUTIL.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3133"></a>DS3DUTIL.C</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1995 Microsoft Corporation. All Rights Reserved. <br> * <br> *  File:       ds3dutil.c <br> *  Content:    Routines for dealing with sounds from resources <br> *              The last 3 functions (the wave file parsing code) <br> *              are copied from dsutil.cpp <br> * <br> * <br> ***************************************************************************/ <br>#include &lt;tchar.h&gt; <br>#include &lt;dsound.h&gt; <br>#include "ds3dutil.h" <br>//*************************** FUNCTION PROTOTYPES **************************/ <br>BOOL DSParseWaveResource(void *pvRes, WAVEFORMATEX **ppWaveHeader, <br>                         BYTE **ppbWaveData,DWORD *pcbWaveSize); <br>BOOL DSGetWaveResource ( HMODULE hModule, LPCTSTR lpName, <br>                         WAVEFORMATEX **ppWaveHeader, BYTE **ppbWaveData, <br>                         DWORD *pcbWaveSize); <br>BOOL DSFillSoundBuffer(  IDirectSoundBuffer *pDSB, BYTE *pbWaveData, DWORD cbWaveSize); <br>BOOL DSReloadSoundBuffer(IDirectSoundBuffer *pDSB, LPCTSTR lpName); <br> <br>//*************************** GLOBAL VARIABLES **************************/ <br> <br>_TCHAR gszWaveString[5] = _T("WAVE"); <br> <br>/***************************************************************************** <br>FUNCTION:  WaveInit <br> <br>PURPOSE:   Loads a WAVEDATA struct with the named WAVE resource. <br> <br>PARAMETERS: <br>lplpWD  A pointer to a WAVEDATA struct. <br> <br>lpDS:   A pointer to an IDirectSound object.  This object must be, <br>        initialized BEFORE being passed to this function, and MUST have been <br>        initialized with the DSBCAPS_CTRL3D flag. <br> <br>lpName: A string that contains the name of the .WAV resource. <br>*****************************************************************************/ <br>BOOL WaveInit(LPWAVEDATA *lplpWD, LPDIRECTSOUND lpDS, LPCTSTR lpName)                    <br>{ <br>DSBUFFERDESC dsBD = {0}; <br>BYTE *pbWaveData=NULL; <br>LPWAVEDATA lpWD; <br> <br>    lpWD = (*lplpWD) = (LPWAVEDATA)malloc(sizeof(WAVEDATA)); <br>    lpWD-&gt;lpDirectSoundBuffer = NULL; <br>    lpWD-&gt;lpName = NULL; <br>    lpWD-&gt;lpDS = NULL; <br> <br>    #ifndef UNICODE <br>        lpWD-&gt;lpName = (LPTSTR)malloc(strlen(lpName) + 1); <br>    #else <br>        lpWD-&gt;lpName = (LPTSTR)malloc(2*(wcslen(lpName) + 1)); <br>    #endif <br>    if (lpWD-&gt;lpName != NULL) <br>    { <br>        _tcscpy(lpWD-&gt;lpName, lpName); <br>         <br>        if (DSGetWaveResource(NULL, lpName, &amp;dsBD.lpwfxFormat, &amp;pbWaveData, &amp;dsBD.dwBufferBytes)) <br>        { <br>            dsBD.dwSize = sizeof(DSBUFFERDESC); <br>            dsBD.dwFlags = DSBCAPS_STATIC     | DSBCAPS_GETCURRENTPOSITION2  | DSBCAPS_CTRL3D; <br>            if (DS_OK == IDirectSound_CreateSoundBuffer(lpDS, &amp;dsBD, &amp;lpWD-&gt;lpDirectSoundBuffer, NULL)) <br>            { <br>                if (DSFillSoundBuffer(lpWD-&gt;lpDirectSoundBuffer, pbWaveData, dsBD.dwBufferBytes)) <br>                { <br>                    lpWD-&gt;lpDS = lpDS; //also copy the DirectSoundObject <br>                    return(TRUE); <br>                } <br>                IDirectSoundBuffer_Release(lpWD-&gt;lpDirectSoundBuffer); <br>                lpWD-&gt;lpDirectSoundBuffer = NULL; <br>            } <br>        } <br>        free(lpWD-&gt;lpName);         <br>        lpWD-&gt;lpName = NULL; <br>    } <br>    free(*lplpWD); <br>    *lplpWD = NULL; <br>    return(FALSE); <br>};         <br> <br> <br>/***************************************************************************** <br>FUNCTION:   WaveGetBuffers <br> <br>PARAMS:     lplpWD: <br>                A pointer to a WAVEDATA struct. <br>            lplpDirectSoundBuffer: <br>                The address of a pointer to a DirectSoundBuffer Interface.                 <br>            lplpDirectSound3DBuffer: <br>                The address of a pointer to a DirectSound3DBuffer Interface. <br>            bOurShip: <br>                A Boolean telling whether the ship requesting the sound <br>                buffers is OUR ship.  If it is our ship, then instead of <br>                duplicating sound buffers for it we just copy the global <br>                pointers in.  That way we make sure that the global <br>                pointers are actually being put to good use before we <br>                go allocating more resources. <br>                 <br>             <br>            Both of these must be Release()'d after their use. <br>                 <br>PURPOSE:    Gives the caller back two interface pointers:  one to a regular <br>            DirectSoundBuffer interface and one to a 3D buffer interface.  These <br>            MUST be Released() by the caller. <br> <br>RETURNS:    Should return TRUE, unless something really catastrophic has happened. <br> <br>NOTES:      BOTH of these Interfaces MUST be -&gt;Release()'d when the object <br>            or whatever is done using them.  Otherwise the buffer they point <br>            to will just hang around and waste memory.  This wastes processing time, <br>            since each buffer is checked by the mixer quite frequently to see if it <br>            is playing. <br> <br>            Defaults:  Both Position and Velocity vectors are set to (0,0,0). <br>             <br>**************************************************************************************/  <br>BOOL WaveGetBuffers (LPWAVEDATA lpWD, <br>                    LPDIRECTSOUNDBUFFER   *lplpDirectSoundBuffer, <br>                    LPDIRECTSOUND3DBUFFER *lplpDirectSound3DBuffer, <br>                    BOOL bOurShip) <br>{ <br>DSBCAPS dsbc; //in case there's a problem duplicating hardware buffer <br>DSBUFFERDESC dsBD   ={0}; <br>BYTE *pbWaveData    =NULL; <br> <br>    *lplpDirectSoundBuffer = NULL; <br>    *lplpDirectSound3DBuffer = NULL; <br>    //so if we get to "failed:", we know what worked and what didn't. <br>    if (bOurShip) <br>    {//This is OUR ship, so we'll copy the buffer pointer. <br>        *lplpDirectSoundBuffer   = lpWD-&gt;lpDirectSoundBuffer; <br>    } <br>    else <br>    { <br>        //This is not our ship, so we'll have to dup a buffer or create a new one. <br>        if (DS_OK!=IDirectSound_DuplicateSoundBuffer(lpWD-&gt;lpDS, lpWD-&gt;lpDirectSoundBuffer, lplpDirectSoundBuffer)) <br>        { <br>            //degrading to software <br>            dsbc.dwSize = sizeof(dsbc); <br>            if (DS_OK!=IDirectSoundBuffer_GetCaps(lpWD-&gt;lpDirectSoundBuffer, &amp;dsbc)) <br>            { <br>                goto failed; <br>            } <br>            //was the original one in hardware? <br>            if (DSBCAPS_LOCHARDWARE &amp; dsbc.dwFlags) <br>            { <br>                //It's a HARDWARE buffer? Then we need to create a software sound <br>                //buffer, not duplicate this hardware one. <br>                if (DSGetWaveResource(NULL, lpWD-&gt;lpName, &amp;dsBD.lpwfxFormat, &amp;pbWaveData, &amp;dsBD.dwBufferBytes)) <br>                { <br>                    dsBD.dwSize = sizeof(DSBUFFERDESC); <br>                    dsBD.dwFlags = DSBCAPS_STATIC | DSBCAPS_GETCURRENTPOSITION2  | DSBCAPS_CTRL3D; <br>                    if (DS_OK == IDirectSound_CreateSoundBuffer(lpWD-&gt;lpDS, &amp;dsBD, lplpDirectSoundBuffer, NULL)) <br>                    { <br>                        if (!DSFillSoundBuffer(*lplpDirectSoundBuffer, pbWaveData, dsBD.dwBufferBytes)) <br>                        {//DSFillSoundBuffer failed when creating software buffer for ship.                                    <br>                            goto failed; <br>                        } <br>                    } <br>                    else <br>                    {//CreateSoundBuffer failed when creating software buffer for ship.                         <br>                        goto failed; <br>                    } <br>                } <br>                else  <br>                {//GetWaveResource failed trying to duplicating a SOFTWARE buffer for ship.                     <br>                    goto failed; <br>                } <br>            } <br>            else <br>            {//it wasn't even trying to duplicate a hardware buffer, and <br>             //could not duplicate a software buffer. <br>                goto failed; <br>            } <br>        } //end the duplicate-regular-soundbuffer part. <br>    } <br> <br> <br>    //now we'll try to get a 3D buffer. <br>    if (DS_OK==IDirectSoundBuffer_QueryInterface(*lplpDirectSoundBuffer, &amp;IID_IDirectSound3DBuffer, (void **)lplpDirectSound3DBuffer))  <br>    {             <br>        return TRUE; //buffer was allocated!!!! <br>    } <br>    else <br>    { <br>    //Query for a 3D SoundBuffer Failed!! <br>        goto failed; <br>    } <br> <br> <br>failed: <br>    if (*lplpDirectSoundBuffer!=NULL) <br>    { <br>        if (!bOurShip) <br>            IDirectSoundBuffer_Release(*lplpDirectSoundBuffer); <br>        *lplpDirectSoundBuffer=NULL; <br>    } <br> <br>    if (*lplpDirectSound3DBuffer!=NULL) <br>    { <br>        IDirectSoundBuffer_Release(*lplpDirectSound3DBuffer); <br>        *lplpDirectSound3DBuffer=NULL; <br>    } <br>    return FALSE; <br>}; <br> <br> <br> <br>/***************************************************************************** <br>FUNCTION:  WaveFree <br> <br>PURPOSE:   When this is called, we HOPE that all the buffers <br>           (both the normal and the 3D ones) duplicated from "lpDirectSoundBuffer" <br>           in the function WaveGetBuffers() have been -&gt;Release()'d.  This frees <br>           up the original buffer (lpDirectSoundBuffer) that all the other buffers <br>           have been duplicated from. <br>*****************************************************************************/  <br>void WaveFree(LPWAVEDATA lpWD) <br>{ <br>    if (lpWD!=NULL) <br>    { <br>        if (lpWD-&gt;lpDirectSoundBuffer != NULL) <br>          IDirectSoundBuffer_Release(lpWD-&gt;lpDirectSoundBuffer); <br>        if (lpWD-&gt;lpName != NULL) <br>            free(lpWD-&gt;lpName); <br>        free(lpWD); <br>    } <br>}; <br> <br>/***************************************************************************** <br>FUNCTION:   WaveReload <br> <br>PURPOSE:    This reloads the wave's sound effect. <br>*****************************************************************************/ <br>BOOL WaveReload(LPWAVEDATA lpWD) <br>{ <br>    return DSReloadSoundBuffer(lpWD-&gt;lpDirectSoundBuffer, lpWD-&gt;lpName); <br>}; <br> <br> <br> <br>/***************************************************************************** <br>FUNCTION:  DSGetWaveResource <br> <br>PURPOSE:   Sets the following: <br>            a. A pointer to a WAV file header structure <br>            b. A pointer to the WAV file data. <br>            c. A DWORD which is the length of the data (in bytes, not samples) <br>*****************************************************************************/ <br>BOOL DSGetWaveResource(HMODULE hModule, LPCTSTR lpName, <br>                       WAVEFORMATEX **ppWaveHeader, BYTE **ppbWaveData, <br>                       DWORD *pcbWaveSize) <br>{ <br>    HRSRC hResInfo; <br>    HGLOBAL hResData; <br>    void *pvRes; <br>     <br> <br>    if (((hResInfo = FindResource(hModule, lpName, gszWaveString)) != NULL) &amp;&amp; <br>        ((hResData = LoadResource(hModule, hResInfo)) != NULL) &amp;&amp; <br>        ((pvRes = LockResource(hResData)) != NULL) &amp;&amp;         <br>        DSParseWaveResource(pvRes, ppWaveHeader, ppbWaveData, pcbWaveSize)) <br>    { <br>        return TRUE; <br>    } <br>    return FALSE; <br>} <br> <br> <br> <br> <br>/***************************************************************************** <br>FUNCTION:   DSParseWaveResource <br> <br>PURPOSE:    This does the real meat of the file parsing, and is called by <br>            DSGetWaveResource <br>*****************************************************************************/ <br>BOOL DSParseWaveResource(void *pvRes, WAVEFORMATEX **ppWaveHeader, <br>                         BYTE **ppbWaveData,DWORD *pcbWaveSize) <br>{ <br>    DWORD *pdw; <br>    DWORD *pdwEnd; <br>    DWORD dwRiff; <br>    DWORD dwType; <br>    DWORD dwLength; <br> <br>    if (ppWaveHeader) <br>        *ppWaveHeader = NULL; <br> <br>    if (ppbWaveData) <br>        *ppbWaveData = NULL; <br> <br>    if (pcbWaveSize) <br>        *pcbWaveSize = 0; <br> <br>    pdw = (DWORD *)pvRes; <br>    dwRiff = *pdw++; <br>    dwLength = *pdw++; <br>    dwType = *pdw++; <br> <br>    if (dwRiff != mmioFOURCC('R', 'I', 'F', 'F')) <br>        goto exit;      // not even RIFF <br> <br>    if (dwType != mmioFOURCC('W', 'A', 'V', 'E')) <br>        goto exit;      // not a WAV <br> <br>    pdwEnd = (DWORD *)((BYTE *)pdw + dwLength-4); <br> <br>    while (pdw &lt; pdwEnd) <br>    { <br>        dwType = *pdw++; <br>        dwLength = *pdw++; <br> <br>        switch (dwType) <br>        { <br>        case mmioFOURCC('f', 'm', 't', ' '): <br>            if (ppWaveHeader &amp;&amp; !*ppWaveHeader) <br>            { <br>                if (dwLength &lt; sizeof(WAVEFORMAT)) <br>                    goto exit;      // not a WAV <br> <br>                *ppWaveHeader = (WAVEFORMATEX *)pdw; <br> <br>                if ((!ppbWaveData || *ppbWaveData) &amp;&amp; <br>                    (!pcbWaveSize || *pcbWaveSize)) <br>                { <br>                    return TRUE; <br>                } <br>            } <br>            break; <br> <br>        case mmioFOURCC('d', 'a', 't', 'a'): <br>            if ((ppbWaveData &amp;&amp; !*ppbWaveData) || <br>                (pcbWaveSize &amp;&amp; !*pcbWaveSize)) <br>            { <br>                if (ppbWaveData) <br>                    *ppbWaveData = (LPBYTE)pdw; <br> <br>                if (pcbWaveSize) <br>                    *pcbWaveSize = dwLength; <br> <br>                if (!ppWaveHeader || *ppWaveHeader) <br>                    return TRUE; <br>            } <br>            break; <br>        } <br> <br>        pdw = (DWORD *)((BYTE *)pdw + ((dwLength+1)&amp;~1)); <br>    } <br> <br>exit: <br>    return FALSE; <br>} <br> <br> <br> <br>/***************************************************************************** <br>FUNCTION:   DSFillSoundBuffer <br> <br>PURPOSE:    Given an already-initialized DirectSoundBuffer, and pointer to <br>            some sound data, and the sound data's size, this writes the data <br>            to the DirectSoundBuffer. <br>*****************************************************************************/ <br>BOOL DSFillSoundBuffer(IDirectSoundBuffer *pDSB, BYTE *pbWaveData, DWORD cbWaveSize) <br>{ <br>    if (pDSB &amp;&amp; pbWaveData &amp;&amp; cbWaveSize) <br>    { <br>        LPVOID pMem1, pMem2; <br>        DWORD dwSize1, dwSize2; <br> <br>        if (SUCCEEDED(IDirectSoundBuffer_Lock(pDSB, 0, cbWaveSize, <br>            &amp;pMem1, &amp;dwSize1, &amp;pMem2, &amp;dwSize2, 0))) <br>        { <br>            ZeroMemory(pMem1, dwSize1); <br>            CopyMemory(pMem1, pbWaveData, dwSize1); <br> <br>            if ( 0 != dwSize2 ) <br>                CopyMemory(pMem2, pbWaveData+dwSize1, dwSize2); <br> <br>            IDirectSoundBuffer_Unlock(pDSB, pMem1, dwSize1, pMem2, dwSize2); <br>            return TRUE; <br>        } <br>    } <br>    return FALSE; <br>} <br> <br> <br>/***************************************************************************** <br>FUNCTION:   DSReloadSoundBuffer <br> <br>PURPOSE:    If an application with WRITE_PRIMARY takes the focus from our <br>            humble window, then our secondary sound buffers become "lost" and <br>            we must call restore and re-fill them. <br>*****************************************************************************/ <br>BOOL DSReloadSoundBuffer(IDirectSoundBuffer *pDSB, LPCTSTR lpName) <br>{ <br>    BOOL result=FALSE; <br>    BYTE *pbWaveData; <br>    DWORD cbWaveSize; <br> <br>    if (DSGetWaveResource(NULL, lpName, NULL, &amp;pbWaveData, &amp;cbWaveSize)) <br>    { <br>        if (SUCCEEDED(IDirectSoundBuffer_Restore(pDSB))) <br>    { <br>        if (DSFillSoundBuffer(pDSB, pbWaveData, cbWaveSize)) <br>            { <br>        result = TRUE; <br>            } <br>        } <br> <br>    } <br>    return result; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
