<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>UTIL.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3148"></a>UTIL.C</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1995-1997 Microsoft Corporation. All Rights Reserved. <br> * <br> *  File:       util.c <br> *  Content:    miscellaneous functions <br> * <br> * <br> ***************************************************************************/ <br>#include "util.h" <br> <br>/* <br> * Globals <br> */ <br>static const BYTE GuidMap[] = { 3, 2, 1, 0, '-', 5, 4, '-', 7, 6, '-', <br>                                8, 9, '-', 10, 11, 12, 13, 14, 15 }; <br>static const WCHAR wszDigits[] = L"0123456789ABCDEF"; <br> <br> <br>/* <br> * StringFromGUID <br> *  <br> * Converts a GUID into a wide string <br> */ <br>int StringFromGUID(LPGUID lpguid, LPWSTR lpwsz) <br>{ <br>    int i; <br> <br>    const BYTE * pBytes = (const BYTE *) lpguid; <br> <br>    *lpwsz++ = L'{'; <br> <br>    for (i = 0; i &lt; sizeof(GuidMap); i++) <br>    { <br>        if (GuidMap[i] == '-') <br>        { <br>            *lpwsz++ = L'-'; <br>        } <br>        else <br>        { <br>            *lpwsz++ = wszDigits[ (pBytes[GuidMap[i]] &amp; 0xF0) &gt;&gt; 4 ]; <br>            *lpwsz++ = wszDigits[ (pBytes[GuidMap[i]] &amp; 0x0F) ]; <br>        } <br>    } <br>    *lpwsz++ = L'}'; <br>    *lpwsz   = L'\0'; <br> <br>    return GUIDSTR_MAX; <br>} <br> <br>/* <br> * IsEqualGuid <br> * <br> * Determines if two guids are equal <br> */ <br>BOOL  IsEqualGuid(GUID *lpguid1, GUID *lpguid2) <br>{ <br>   return ( <br>      ((PLONG) lpguid1)[0] == ((PLONG) lpguid2)[0] &amp;&amp; <br>      ((PLONG) lpguid1)[1] == ((PLONG) lpguid2)[1] &amp;&amp; <br>      ((PLONG) lpguid1)[2] == ((PLONG) lpguid2)[2] &amp;&amp; <br>      ((PLONG) lpguid1)[3] == ((PLONG) lpguid2)[3]); <br>} <br> <br> <br>// convert a hex char to an int - used by str to guid conversion <br>// we wrote our own, since the ole one is slow, and requires ole32.dll <br>// we use ansi strings here, since guids won't get internationalized <br>int GetDigit(LPSTR lpstr) <br>{ <br>char ch = *lpstr; <br>     <br>    if (ch &gt;= '0' &amp;&amp; ch &lt;= '9') <br>        return(ch - '0'); <br>    if (ch &gt;= 'a' &amp;&amp; ch &lt;= 'f') <br>        return(ch - 'a' + 10); <br>    if (ch &gt;= 'A' &amp;&amp; ch &lt;= 'F') <br>        return(ch - 'A' + 10); <br>    return(0); <br>} <br>// walk the string, writing pairs of bytes into the byte stream (guid) <br>// we need to write the bytes into the byte stream from right to left <br>// or left to right as indicated by fRightToLeft <br>void ConvertField(LPBYTE lpByte,LPSTR * ppStr,int iFieldSize,BOOL fRightToLeft) <br>{ <br>int i; <br> <br>for (i=0;i&lt;iFieldSize ;i++ ) <br>{ <br>// don't barf on the field separators <br>if ('-' == **ppStr) (*ppStr)++;  <br>if (fRightToLeft == TRUE) <br>{ <br>// work from right to left within the byte stream <br>*(lpByte + iFieldSize - (i+1)) = 16*GetDigit(*ppStr) + GetDigit((*ppStr)+1); <br>}  <br>else  <br>{ <br>// work from  left to right within the byte stream <br>*(lpByte + i) = 16*GetDigit(*ppStr) + GetDigit((*ppStr)+1); <br>} <br>*ppStr+=2; // get next two digit pair <br>} <br>} // ConvertField <br> <br> <br>// convert the passed in string to a real GUID <br>// walk the guid, setting each byte in the guid to the two digit hex pair in the <br>// passed string <br>HRESULT GUIDFromString(LPWSTR lpWStr, GUID * pGuid) <br>{ <br>BYTE * lpByte; // byte index into guid <br>int iFieldSize; // size of current field we're converting <br>// since its a guid, we can do a "brute force" conversion <br>char lpTemp[GUID_STRING_SIZE]; <br>char *lpStr = lpTemp; <br> <br>WideToAnsi(lpStr,lpWStr,GUID_STRING_SIZE); <br> <br>// make sure we have a {xxxx-...} type guid <br>if ('{' !=  *lpStr) return E_FAIL; <br>lpStr++; <br> <br>lpByte = (BYTE *)pGuid; <br>// data 1 <br>iFieldSize = sizeof(unsigned long); <br>ConvertField(lpByte,&amp;lpStr,iFieldSize,TRUE); <br>lpByte += iFieldSize; <br> <br>// data 2 <br>iFieldSize = sizeof(unsigned short); <br>ConvertField(lpByte,&amp;lpStr,iFieldSize,TRUE); <br>lpByte += iFieldSize; <br> <br>// data 3 <br>iFieldSize = sizeof(unsigned short); <br>ConvertField(lpByte,&amp;lpStr,iFieldSize,TRUE); <br>lpByte += iFieldSize; <br> <br>// data 4 <br>iFieldSize = 8*sizeof(unsigned char); <br>ConvertField(lpByte,&amp;lpStr,iFieldSize,FALSE); <br>lpByte += iFieldSize; <br> <br>// make sure we ended in the right place <br>if ('}' != *lpStr)  <br>{ <br>memset(pGuid,0,sizeof(GUID)); <br>return E_FAIL; <br>} <br> <br>return S_OK; <br>}// GUIDFromString <br> <br>/* <br> ** WideToAnsi <br> * <br> *  CALLED BY:everywhere <br> * <br> *  PARAMETERS: lpStr - destination string <br> *lpWStr - string to convert <br> *cchStr - size of dest buffer <br> * <br> *  DESCRIPTION: <br> *converts unicode lpWStr to ansi lpStr. <br> *fills in unconvertable chars w/ DPLAY_DEFAULT_CHAR "-" <br> * <br> * <br> *  RETURNS:  if cchStr is 0, returns the size required to hold the string <br> *otherwise, returns the number of chars converted <br> * <br> */ <br>int WideToAnsi(LPSTR lpStr,LPWSTR lpWStr,int cchStr) <br>{ <br> <br>int rval; <br>BOOL bDefault; <br> <br>// use the default code page (CP_ACP) <br>// -1 indicates WStr must be null terminated <br>rval = WideCharToMultiByte(CP_ACP,0,lpWStr,-1,lpStr,cchStr,"-",&amp;bDefault); <br> <br>return rval; <br> <br>} // WideToAnsi <br> <br>/* <br> ** AnsiToWide <br> * <br> *  CALLED BY: everywhere <br> * <br> *  PARAMETERS: lpWStr - dest string <br> *lpStr  - string to convert <br> *cchWstr - size of dest buffer <br> * <br> *  DESCRIPTION: converts Ansi lpStr to Unicode lpWstr <br> * <br> * <br> *  RETURNS:  if cchStr is 0, returns the size required to hold the string <br> *otherwise, returns the number of chars converted <br> * <br> */ <br>int AnsiToWide(LPWSTR lpWStr,LPSTR lpStr,int cchWStr) <br>{ <br>int rval; <br> <br>rval =  MultiByteToWideChar(CP_ACP,0,lpStr,-1,lpWStr,cchWStr); <br> <br>return rval; <br>}  // AnsiToWide <br> <br> <br>/*  <br> * randInt <br> * <br> * returns a random integer in the specified range <br> */ <br>int randInt( int low, int high ) <br>{ <br>    int range = high - low; <br>    int num = rand() % range; <br>    return( num + low ); <br>} <br> <br>/* <br> * randDouble <br> * <br> * returns a random double in the specified range <br> */ <br>double randDouble( double low, double high ) <br>{ <br>    double range = high - low; <br>    double num = range * (double)rand()/(double)RAND_MAX; <br>    return( num + low ); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
