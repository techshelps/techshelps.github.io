<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DUEL.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3135"></a>DUEL.C</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1995-1997 Microsoft Corporation. All Rights Reserved. <br> * <br> *  File:       duel.c <br> *  Content:    Multi-player duel <br> * <br> * <br> ***************************************************************************/ <br>#define INITGUID <br>#include "duel.h" <br>#include "gameproc.h" <br>#include "gfx.h" <br>#include "comm.h" <br>#include "input.h" <br>#include "lobby.h" <br>#include "wizard.h" <br>#include "util.h" <br>#include "sfx.h" <br> <br>// {33925241-05F8-11d0-8063-00A0C90AE891} <br>DEFINE_GUID(DUEL_GUID,  <br>0x33925241, 0x5f8, 0x11d0, 0x80, 0x63, 0x0, 0xa0, 0xc9, 0xa, 0xe8, 0x91); <br> <br>/* <br> * Externals <br> */ <br>extern DWORDgdwFrameCount; <br>extern DWORDgdwFrameTime; <br>extern intgnProgramState; <br>extern SHIPgOurShip; <br>extern LPDPLCONNECTIONglpdplConnection; <br>extern DPIDgOurID; <br>extern BOOL             gbNoField; <br> <br> <br>/* <br> * Globals <br> */ <br>LPGUID                  glpGuid;// Duel's GUID <br>HWND                    ghWndMain;// Main application window handle <br>HINSTANCEghinst;// Application instance handle <br>BOOL                    gbShowFrameCount=TRUE;// Show FPS ? <br>BOOL                    gbIsActive;// Is the application active ? <br>BOOL                    gbUseEmulation;// DDHEL or DDHAL for Graphics <br>BOOLgbIsHost;// Are we hosting or joining a game <br>DWORD                   gdwKeys;// User keyboard input <br>DWORD                   gdwOldKeys;             // Last frame's keyboard input <br>BOOLgbFullscreen=FALSE;// Window or FullScreen mode ? <br>RECTgrcWindow;// client rectangle of main window <br>HANDLEghThread;// handle to wizard thread <br>TCHARgtszClassName[MAX_CLASSNAME]; // Duel's class name <br>BOOL                    gbReliable;             // sends are reliable <br> <br>/* <br> * Statics <br> */ <br>static BOOLgbReinitialize;// used for switching display modes <br> <br>/* <br> * WinMain <br> */ <br>int WINAPI WinMain( HINSTANCE hinstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <br>                        int nCmdShow ) <br>{ <br>BOOL bHelp=FALSE; <br>    MSG     msg; <br> <br>ghinst = hinstance; <br> <br>CoInitialize( NULL ); <br> <br>// Parse command line <br>    while( lpCmdLine[0] == '-' ) <br>    { <br>        lpCmdLine++; <br> <br>        switch (*lpCmdLine++) <br>        { <br>        case 'e': <br>            gbUseEmulation = TRUE; <br>            break; <br>        case 'd': <br>            gbNoField = TRUE; <br>            break; <br>        case '?': <br>default: <br>            bHelp= TRUE; <br>            gbFullscreen= FALSE;  // give help in windowed mode <br>            break; <br>        } <br> <br>        while( isspace(*lpCmdLine) ) <br>{ <br>lpCmdLine++; <br>} <br>    } <br> <br>    /* <br>     * Give user help if asked for <br>     */ <br> <br>    if( bHelp ) <br>    { <br>TCHAR tszHelpMsg[MAX_HELPMSG]; <br>TCHAR tszTitle[MAX_WINDOWTITLE]; <br> <br>LoadString(ghinst, IDS_DUEL_HELP, tszHelpMsg, MAX_HELPMSG); <br>LoadString(ghinst, IDS_DUEL_TITLE, tszTitle, MAX_WINDOWTITLE); <br>        MessageBox(ghWndMain, tszHelpMsg, tszTitle, MB_OK ); <br>return TRUE; <br>    } <br> <br> <br>    if( !InitApplication(hinstance) ) <br>    { <br>        return FALSE; <br>    } <br> <br>// were we launched by a lobby ? <br>    if (LaunchedByLobby()) <br>    { <br>// start game <br>PostMessage(ghWndMain, UM_LAUNCH, 0, 0); <br>        gbIsActive = TRUE; <br>    } <br> <br>    gdwFrameTime = timeGetTime(); <br> <br>while( TRUE ) <br>    { <br>        if (gbIsActive) <br>        { <br>            // any windows messages ? (returns immediately) <br>            if( PeekMessage( &amp;msg, NULL, 0, 0, PM_NOREMOVE ) ) <br>            { <br>                if( !GetMessage( &amp;msg, NULL, 0, 0 ) ) <br>                { <br>                    return msg.wParam; <br>                } <br>                TranslateMessage(&amp;msg); <br>                DispatchMessage(&amp;msg); <br>            } <br>            else <br>            { <br>                // Poll our receive queue. Polling is used in the sample only for simplicity. <br>                // Receiving messages using an event is the recommended way. <br>        if (gnProgramState != PS_SPLASH) <br>                { <br>                    ReceiveMessages(); <br>                } <br> <br>                // update screen <br>    if (!UpdateFrame()) <br>                { <br>                    ExitGame(); <br>                } <br>    } <br>        } <br>        else <br>        { <br>            // any windows messages ? (blocks until a message arrives) <br>            if( !GetMessage( &amp;msg, NULL, 0, 0 ) ) <br>            { <br>                return msg.wParam; <br>            } <br>            TranslateMessage(&amp;msg); <br>            DispatchMessage(&amp;msg); <br>        } <br>    } <br> <br>CoUninitialize(); <br> <br>} /* WinMain */ <br> <br> <br>/* <br> * MainWndproc <br> * <br> * Callback for all Windows messages <br> */ <br>long WINAPI MainWndproc( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam ) <br>{ <br>    PAINTSTRUCT ps; <br>    HDC         hdc; <br>DWORD dwRetCode; <br>DWORD dwTid; <br> <br>    switch( message ) <br>    { <br>    case WM_SIZE: <br>    case WM_MOVE: <br>// get the client rectangle <br>        if (gbFullscreen) <br>        { <br>            SetRect(&amp;grcWindow, 0, 0, GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN)); <br>        } <br>        else <br>        { <br>            GetClientRect(hWnd, &amp;grcWindow); <br>            ClientToScreen(hWnd, (LPPOINT)&amp;grcWindow); <br>            ClientToScreen(hWnd, (LPPOINT)&amp;grcWindow+1); <br>        } <br>break; <br> <br>    case WM_ACTIVATE: <br>// ignore this message during reinitializing graphics <br>if (gbReinitialize) return 0; <br> <br>        // When we are deactivated, although we don't update our screen, we still need to <br>        // to empty our receive queue periodically as messages will pile up otherwise.  <br>        // Polling the receive queue continuously even when we are deactivated causes our app <br>        // to consume all the CPU time. To avoid hogging the CPU, we block on GetMessage() WIN API <br>        // and setup a timer to wake ourselves up at regular intervals to process our messages. <br> <br>        if (LOWORD(wParam) == WA_INACTIVE) <br>        { <br>            // deactivated <br>            gbIsActive = FALSE; <br>            if (PS_ACTIVE == gnProgramState) <br>            { <br>                SetTimer(hWnd, RECEIVE_TIMER_ID, RECEIVE_TIMEOUT, NULL); <br>            } <br>        } <br>        else <br>        { <br>            // activated <br>            gbIsActive = TRUE; <br>            if (PS_ACTIVE == gnProgramState) <br>            { <br>                KillTimer(hWnd, RECEIVE_TIMER_ID); <br>            } <br>        } <br> <br>        // set game palette, if activated in game mode <br>        if (gbIsActive &amp;&amp; (gnProgramState != PS_SPLASH)) <br>SetGamePalette(); <br> <br>        ReacquireInputDevices(); <br> <br>        return 0; <br> <br>    case WM_CREATE: <br>        break; <br> <br>    case WM_SYSKEYUP: <br>switch( wParam ) <br>        { <br>        // handle ALT+ENTER (fullscreen/window mode) <br>        case VK_RETURN: <br>// mode switch is allowed only during the game <br>if (gnProgramState == PS_ACTIVE) <br>{ <br>gbReinitialize = TRUE; <br>                ReleaseLocalData();  //only sound buffers have to be rels'd anyway. <br>                CleanupSfx(); <br>                CleanupInput(); <br>CleanupGraphics(); <br>DestroyWindow(ghWndMain); <br>gbFullscreen = !gbFullscreen; <br>InitGraphics(); <br>                InitInput(); <br>                InitSfx(); <br>                InitLocalSoundData(); <br>gbReinitialize = FALSE; <br>            } <br>            break; <br>        } <br>        break; <br> <br>    case WM_KEYDOWN: <br>        switch( wParam ) <br>        { <br>        case 'r': <br>        case 'R': <br>// toggle reliable status <br>gbReliable = !gbReliable; <br>UpdateTitle(); <br>            break; <br> <br>case VK_F1: <br>{ <br>TCHAR tszHelpMsg[MAX_HELPMSG]; <br>TCHAR tszTitle[MAX_WINDOWTITLE]; <br> <br>LoadString(ghinst, IDS_DUEL_HELP, tszHelpMsg, MAX_HELPMSG); <br>LoadString(ghinst, IDS_DUEL_TITLE, tszTitle, MAX_WINDOWTITLE); <br>MessageBox(ghWndMain, tszHelpMsg, tszTitle, MB_OK ); <br>} <br>break; <br> <br>        case VK_F5: <br>            gbShowFrameCount = !gbShowFrameCount; <br>            if( gbShowFrameCount ) <br>            { <br>                gdwFrameCount = 0; <br>                gdwFrameTime = timeGetTime(); <br>            } <br>            break; <br> <br>        case VK_RETURN: <br>            if( (gnProgramState == PS_SPLASH) &amp;&amp; !gbFullscreen) <br>{ <br>// get connection settings from user <br>ghThread = CreateThread(NULL, 0, (LPVOID)DoWizard, 0, 0, &amp;dwTid); <br>} <br>            break; <br> <br>        case VK_ESCAPE: <br>        case VK_F12: <br>// adios <br>ExitGame(); <br>            return 0; <br>        } <br>        break; <br> <br>    case WM_ERASEBKGND: <br>    return 1; <br> <br>    case WM_PAINT: <br>        hdc = BeginPaint( hWnd, &amp;ps ); <br>if (gnProgramState == PS_SPLASH) <br>{ <br>            // display the splash screen <br>            bltSplash(NULL); <br>} <br> <br>        EndPaint( hWnd, &amp;ps ); <br>        return 1; <br> <br>case UM_LAUNCH: <br>// cleanup the wizard thread <br>if (ghThread) <br>{ <br>// wait for thread to exit <br>while (!GetExitCodeThread(ghThread, &amp;dwRetCode)); <br>CloseHandle(ghThread); <br>} <br> <br>// start the game in rest mode <br>gnProgramState = PS_REST; <br>LaunchGame(); <br>return 1; <br> <br>case UM_ABORT: <br>// cleanup the wizard thread <br>if (ghThread) <br>{ <br>// wait for thread to exit <br>while (!GetExitCodeThread(ghThread, &amp;dwRetCode)); <br>CloseHandle(ghThread); <br>} <br>        ExitGame(); <br>return 1; <br> <br>    case WM_TIMER: <br>        ReceiveMessages(); <br>        break; <br> <br>    case WM_DESTROY: <br>// if gbReinitialize is TRUE don't quit, we are just switching display modes <br>if (!gbReinitialize) <br>{ <br>CleanupApplication(); <br>        PostQuitMessage( 0 ); <br>} <br>        return 0; <br> <br>    default: <br>        break; <br>    } <br>    return DefWindowProc(hWnd, message, wParam, lParam); <br> <br>} /* MainWndproc */ <br> <br>/* <br> * InitApplication <br> * <br> * Do that initialization stuff... <br> */ <br>BOOL InitApplication( HINSTANCE hinst ) <br>{ <br>    WNDCLASS    wc; <br>    BOOL        rc; <br> <br>    glpGuid = (LPGUID) &amp;DUEL_GUID; <br> <br>LoadString(ghinst, IDS_DUEL_CLASSNAME, gtszClassName, MAX_CLASSNAME); <br> <br>    wc.style = CS_DBLCLKS; <br>    wc.lpfnWndProc = MainWndproc; <br>    wc.cbClsExtra = 0; <br>    wc.cbWndExtra = 0; <br>    wc.hInstance = hinst; <br>    wc.hIcon = LoadIcon( hinst, MAKEINTRESOURCE(DUEL_ICON)); <br>    wc.hCursor = LoadCursor( NULL, IDC_ARROW ); <br>    wc.hbrBackground = GetStockObject( BLACK_BRUSH ); <br>    wc.lpszMenuName =  NULL; <br>    wc.lpszClassName = gtszClassName; <br>    rc = RegisterClass( &amp;wc ); <br>    if( !rc ) <br>    { <br>        return FALSE; <br>    } <br> <br>// Initialize all components <br>if ((!InitGraphics()) || (!InitInput()) || (!InitSfx())) <br>{ <br>return FALSE; <br>} <br> <br>// start in splash mode <br>    gnProgramState = PS_SPLASH; <br> <br>    return TRUE; <br> <br>} /* initApplication */ <br> <br>/* <br> * CleanupApplication <br> * <br> * Calls clean up on all components <br> */ <br>void CleanupApplication( void ) <br>{ <br>CleanupComm(); <br>    CleanupSfx(); <br>CleanupGraphics(); <br>CleanupInput(); <br>} <br> <br>/* <br> * LaunchedByLobby <br> * <br> * Determines if we were launched by a lobby. If so, gets the connection settings <br> * and creates our player using the information from the lobby <br> */ <br>BOOL LaunchedByLobby(void) <br>{ <br>    HRESULT hr; <br>    HWND    hwndStatus; <br> <br>    // create a lobby object <br>    hr = DPLobbyCreate(); <br>    if (FAILED(hr)) <br>    { <br>        ShowError(IDS_DPLOBBY_ERROR_C); <br>        return FALSE; <br>    } <br> <br>    // get connection settings from the lobby (into glpdplConnection) <br>    hr = DPLobbyGetConnectionSettings(); <br>    if (FAILED(hr)) <br>    { <br>        if (DPERR_NOTLOBBIED == hr) <br>        { <br>            // we were not lobbied - start up game normally <br>            hr = DPLobbyRelease(); <br>            if (FAILED(hr)) <br>            { <br>                ShowError(IDS_DPLOBBY_ERROR_R); <br>                goto FAIL; <br>            } <br>            // move on <br>            return FALSE; <br>        } <br>        else <br>        { <br>            ShowError(IDS_DPLOBBY_ERROR_GCS); <br>            goto FAIL; <br>        } <br>    } <br> <br>// are we hosting or joining ? <br>if (glpdplConnection-&gt;dwFlags &amp; DPLCONNECTION_CREATESESSION) <br>{ <br>gbIsHost = TRUE; <br>} <br> <br>    // set our session flags <br>    glpdplConnection-&gt;lpSessionDesc-&gt;dwFlags = DPSESSION_MIGRATEHOST |  <br>                                                 DPSESSION_KEEPALIVE; <br> <br>    // let lobby know our connection flags <br>    hr = DPLobbySetConnectionSettings(); <br>    if (FAILED(hr)) <br>    { <br>        ShowError(IDS_DPLOBBY_ERROR_SCS); <br>        goto FAIL; <br>    } <br> <br>    if ( !gbIsHost )  <br>    { <br>        // show splash screen and  <br>        // connection status if we are joining a game <br>        UpdateWindow(ghWndMain); <br>        hwndStatus = ShowConnectStatus(); <br>    } <br>    else <br>    { <br>        // we are hosting, don't need connection status <br>        hwndStatus = NULL; <br>    } <br> <br>    // connect to the lobby <br>    hr = DPLobbyConnect(); <br> <br>    if ( hwndStatus ) <br>    { <br>        // get rid of the connectino status window <br>        DestroyWindow(hwndStatus); <br>    } <br> <br>    if (FAILED(hr)) <br>    { <br>        ShowError(IDS_DPLOBBY_ERROR_CONNECT); <br>        goto FAIL; <br>    } <br> <br>    // create our player <br>    hr = DPlayCreatePlayer( <br>                            &amp;gOurID, <br>#ifdef UNICODE <br>glpdplConnection-&gt;lpPlayerName-&gt;lpszShortName, <br>#else <br>glpdplConnection-&gt;lpPlayerName-&gt;lpszShortNameA, <br>#endif <br>NULL, <br>NULL, <br>0 <br>                          ); <br> <br>    if (FAILED(hr)) <br>    { <br>ShowError(IDS_DPLAY_ERROR_CP); <br>        goto FAIL; <br>    } <br> <br> <br>    // cleanup <br>    hr = DPLobbyRelease(); <br>    if (FAILED(hr)) <br>    { <br>        ShowError(IDS_DPLOBBY_ERROR_R); <br>        goto FAIL; <br>    } <br> <br>    // we were lobbied <br>    return TRUE; <br> <br>FAIL: <br>// cleanup and exit <br>DPLobbyRelease(); <br>    ExitGame(); <br>    return FALSE; <br>} <br> <br>/* <br> * Displays error to the user <br> */ <br>BOOL ShowError( int iStrID ) <br>{ <br>TCHAR tszMsg[MAX_ERRORMSG]; <br>TCHAR tszTitle[MAX_WINDOWTITLE]; <br> <br>LoadString(ghinst, iStrID, tszMsg, MAX_ERRORMSG); <br>LoadString(ghinst, IDS_DUEL_ERROR_TITLE, tszTitle, MAX_WINDOWTITLE); <br>    MessageBox( ghWndMain, tszMsg, tszTitle, MB_OK ); <br>    return FALSE; <br>} <br> <br>/* <br> * Displays connection status to the user <br> */ <br>HWND ShowConnectStatus(void) <br>{ <br>    HWND hwnd; <br> <br>    hwnd = CreateDialog( ghinst, MAKEINTRESOURCE(IDD_CONNECT_STATUS), ghWndMain, NULL); <br> <br>    return hwnd; <br> <br>} <br> <br>/* <br> * UpdateTitle <br> * <br> * Updates the window title based on application status <br> */ <br>void UpdateTitle(void) <br>{ <br>DWORD dwFeatures; <br>  TCHAR tszTitle[MAX_WINDOWTITLE]; <br>UINT iStringID; <br> <br>// calculate title features <br>dwFeatures = 0; <br>if (gbReliable) <br>dwFeatures |= 1; <br>if (gbIsHost) <br>dwFeatures |= 2; <br> <br>switch (dwFeatures) <br>{ <br>case 0: <br>iStringID = IDS_DUEL_TITLE; <br>break; <br>case 1: <br>iStringID = IDS_DUEL_RELIABLE_TITLE; <br>break; <br>case 2: <br>iStringID = IDS_DUEL_HOST_TITLE; <br>break; <br>case 3: <br>iStringID = IDS_DUEL_HOST_RELIABLE_TITLE; <br>break; <br>} <br> <br>// get appropriate window title for these features <br>LoadString(ghinst, iStringID, tszTitle, MAX_WINDOWTITLE); <br>    // change window title <br>    SetWindowText(ghWndMain, tszTitle);                <br>} <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
