<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WIZARD.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3150"></a>WIZARD.C</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1995-1997 Microsoft Corporation. All Rights Reserved. <br> * <br> *  File:       wizard.c <br> *  Content:    User input (setup wizard) related code <br> * <br> * <br> ***************************************************************************/ <br>#include &lt;windows.h&gt; <br>#include "prsht.h" <br>#include "wizard.h" <br>#include "util.h" <br>#include "comm.h" <br>#include "gameproc.h" <br> <br>/* <br> * Externals <br> */ <br>extern HINSTANCEghinst;// program instance <br>extern HWNDghWndMain;// main window <br>extern BOOLgbIsHost;// is the user hosting/joining a game <br>extern DPIDgOurID;// player id <br>extern LPGUIDglpGuid;// duel's guid <br>extern LPDIRECTPLAY3glpDP3A;// An IDirectPlay3 interface. <br> <br>/* <br> * Globals to this module <br> */ <br>static HFONTghTitleFont;// font for titles on setup wizard <br>static HFONTghHeadingFont;// font for headings on setup wizard <br>static intgnSession,gnPlayer; // indexes for tree view images <br>static HKEYghDuelKey=NULL;// duel registry key handle <br>static DWORDgdwDuelDisp;// key created or opened <br>static HTREEITEMghtiSession;// points to a visible session item in tree control <br>//  used for inserting players into tree control <br>static HWNDghWndSPCtl;// handle to service provider control <br> <br>/* <br> * SetupFonts <br> * <br> * Initializes font structures (used for wizard controls) <br> */ <br>void SetupFonts(HDC hDC) <br>{ <br>LOGFONT lf; <br>TCHAR tszFontName[MAX_FONTNAME]; <br> <br>LoadString(ghinst, IDS_WIZARD_FONTNAME, tszFontName, MAX_FONTNAME); <br> <br>ZeroMemory(&amp;lf,sizeof(lf)); <br>lf.lfHeight = -MulDiv(11,GetDeviceCaps(hDC, LOGPIXELSY),72); <br>lf.lfWeight = 500; <br>lf.lfItalic = TRUE; <br>_tcscpy(lf.lfFaceName,tszFontName); <br>ghTitleFont = CreateFontIndirect(&amp;lf); <br> <br>ZeroMemory(&amp;lf,sizeof(lf)); <br>lf.lfHeight = -MulDiv(11,GetDeviceCaps(hDC, LOGPIXELSY),72); <br>lf.lfWeight = 500; <br>_tcscpy(lf.lfFaceName,tszFontName); <br>ghHeadingFont = CreateFontIndirect(&amp;lf); <br>} <br> <br>/* <br> * CleanupFonts <br> * <br> * Cleans up font structures <br> */ <br>void CleanupFonts(void) <br>{ <br>if (ghTitleFont) DeleteObject(ghTitleFont); <br>if (ghHeadingFont) DeleteObject(ghHeadingFont); <br>} <br> <br>/* <br> * RegSet <br> * <br> * Stores a data value in the registry <br> */ <br>LONG RegSet(LPCTSTR lptszName, CONST BYTE * lpData, DWORD dwSize) <br>{ <br>#ifdef UNICODE <br>dwSize *= 2; // calc number of bytes <br>#endif <br>return RegSetValueEx(ghDuelKey, lptszName, 0, REG_SZ, lpData, dwSize); <br>} <br> <br>/* <br> * RegSetA <br> * <br> * Stores data as an ascii string in the registry <br> */ <br>LONG RegSetA(LPCTSTR lptszName, CONST BYTE * lpData, DWORD dwSize) <br>{ <br>return RegSetValueEx(ghDuelKey, lptszName, 0, REG_SZ, lpData, dwSize); <br>} <br> <br>/* <br> * RegGet <br> * <br> * Queries a value from the registry <br> */ <br>LONG RegGet(LPCTSTR lptszName, LPBYTE lpData, LPDWORD lpdwDataSize) <br>{ <br>DWORD dwType; <br> <br>return RegQueryValueEx(ghDuelKey, lptszName, NULL, &amp;dwType, lpData, lpdwDataSize); <br>} <br> <br>/* <br> * DoWizard <br> * <br> * Creates and launches a wizard (property sheets) for user input <br> */ <br>DWORD WINAPI DoWizard(LPVOID pv) <br>{ <br>PROPSHEETPAGE psp[4]; <br>    PROPSHEETHEADER psh; <br>TCHAR tszTitle1[MAX_WINDOWTITLE]; <br>TCHAR tszTitle2[MAX_WINDOWTITLE]; <br>TCHAR tszTitle3[MAX_WINDOWTITLE]; <br>TCHAR tszTitle4[MAX_WINDOWTITLE]; <br>TCHAR tszTitle5[MAX_WINDOWTITLE]; <br>    HDC hDC; <br> <br>CoInitialize( NULL ); <br> <br>LoadString(ghinst, IDS_WIZARD_TITLE_SP, tszTitle1, MAX_WINDOWTITLE);  <br>LoadString(ghinst, IDS_WIZARD_TITLE_GS, tszTitle2, MAX_WINDOWTITLE);  <br>LoadString(ghinst, IDS_WIZARD_TITLE_JS, tszTitle3, MAX_WINDOWTITLE);  <br>LoadString(ghinst, IDS_WIZARD_TITLE_HS, tszTitle4, MAX_WINDOWTITLE);  <br>LoadString(ghinst, IDS_WIZARD_TITLE, tszTitle5, MAX_WINDOWTITLE);  <br> <br>    psp[0].dwSize = sizeof(PROPSHEETPAGE); <br>    psp[0].dwFlags = PSP_USETITLE; <br>    psp[0].hInstance = ghinst; <br>    psp[0].pszTemplate = MAKEINTRESOURCE(IDD_CHOOSEPROVIDER); <br>    psp[0].pszIcon = NULL;  <br>    psp[0].pfnDlgProc = DlgProcChooseProvider; <br>    psp[0].pszTitle = tszTitle1; <br>    psp[0].lParam = 0; <br>    psp[0].pfnCallback = NULL; <br> <br>    psp[1].dwSize = sizeof(PROPSHEETPAGE); <br>    psp[1].dwFlags = PSP_USETITLE; <br>    psp[1].hInstance = ghinst; <br>    psp[1].pszTemplate = MAKEINTRESOURCE(IDD_GAMESETUP); <br>    psp[1].pszIcon = NULL;  <br>    psp[1].pfnDlgProc = DlgProcGameSetup; <br>    psp[1].pszTitle = tszTitle2; <br>    psp[1].lParam = 0; <br>    psp[1].pfnCallback = NULL; <br> <br>    psp[2].dwSize = sizeof(PROPSHEETPAGE); <br>    psp[2].dwFlags = PSP_USETITLE; <br>    psp[2].hInstance = ghinst; <br>    psp[2].pszTemplate = MAKEINTRESOURCE(IDD_JOINSESSION); <br>    psp[2].pszIcon = NULL;  <br>    psp[2].pfnDlgProc = DlgProcJoinSession; <br>    psp[2].pszTitle = tszTitle3; <br>    psp[2].lParam = 0; <br>    psp[2].pfnCallback = NULL; <br> <br>    psp[3].dwSize = sizeof(PROPSHEETPAGE); <br>    psp[3].dwFlags = PSP_USETITLE; <br>    psp[3].hInstance = ghinst; <br>    psp[3].pszTemplate = MAKEINTRESOURCE(IDD_HOSTSESSION); <br>    psp[3].pszIcon = NULL;  <br>    psp[3].pfnDlgProc = DlgProcHostSession; <br>    psp[3].pszTitle = tszTitle4; <br>    psp[3].lParam = 0; <br>    psp[3].pfnCallback = NULL; <br> <br>psh.dwSize = sizeof(PROPSHEETHEADER); <br>    psh.dwFlags = PSH_PROPSHEETPAGE | PSH_WIZARD; <br>    psh.hwndParent = ghWndMain; <br>    psh.hInstance = ghinst; <br>    psh.pszIcon = NULL; <br>    psh.pszCaption = tszTitle5; <br>    psh.nPages = sizeof(psp) / sizeof(PROPSHEETPAGE); <br>    psh.nStartPage = 0; <br>    psh.ppsp = (LPCPROPSHEETPAGE) &amp;psp; <br>    psh.pfnCallback = NULL; <br> <br>// open/create duel registry key  <br>    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CURRENT_USER, <br>                    DUEL_KEY, <br>                    0, <br>                    NULL, <br>                    REG_OPTION_NON_VOLATILE, <br>                    KEY_ALL_ACCESS, <br>                    NULL, <br>                    &amp;ghDuelKey, <br>                        &amp;gdwDuelDisp <br>                    )) <br>    { <br>        goto ABORT; <br>    } <br> <br>    hDC = GetDC(ghWndMain); <br>    if (!hDC) <br>    { <br>        goto ABORT; <br>    } <br> <br>// setup fonts <br>SetupFonts(hDC); <br> <br>// launch the wizard <br>    PropertySheet(&amp;psh); <br> <br>// was communication initialized correctly ? <br>if (!IsDPlay()) <br>{ <br>        goto ABORT; <br>} <br> <br>// cleanup <br>CleanupFonts(); <br>    ReleaseDC(ghWndMain, hDC); <br> <br>CoUninitialize(); <br>    // success <br>PostMessage( ghWndMain, UM_LAUNCH, 0, 0 ); <br>    return 0; <br> <br>ABORT: <br>    // failure <br>    CleanupFonts(); <br>    if (hDC)  <br>    { <br>        ReleaseDC(ghWndMain, hDC); <br>    } <br>    PostMessage( ghWndMain, UM_ABORT, 0, 0 ); <br>return 1; <br>} <br> <br>/* <br> * DPEnumConnectionsCallback <br> * <br> * creates SP list box entries and associates connection data with them <br> */ <br>BOOL FAR PASCAL DPEnumConnectionsCallback( <br>LPCGUIDlpguidSP, <br>LPVOIDlpConnection, <br>DWORDdwSize, <br>LPCDPNAMElpName, <br>DWORDdwFlags, <br>LPVOIDlpContext) <br>{ <br> <br>    HWNDhWnd = (HWND) lpContext; <br>    LRESULTiIndex; <br>LPVOIDlpConnectionBuffer; <br> <br>// store service provider name in combo box <br>iIndex = SendMessage(hWnd, LB_ADDSTRING, 0, (LPARAM) lpName-&gt;lpszShortNameA); <br> <br>if (iIndex == CB_ERR) <br>goto FAILURE; <br> <br>// make space for Connection Shortcut <br>lpConnectionBuffer = GlobalAllocPtr(GHND, dwSize); <br>if (lpConnectionBuffer == NULL) <br>goto FAILURE; <br> <br>// store pointer to GUID in combo box <br>memcpy(lpConnectionBuffer, lpConnection, dwSize); <br> <br>if (iIndex != LB_ERR) <br>SendMessage(hWnd, LB_SETITEMDATA, iIndex, (LPARAM) lpConnectionBuffer); <br> <br>FAILURE: <br>    return (TRUE); <br>} <br> <br>/* <br> * DlgProcChooseProvider <br> * <br> * Dialog procedure for the choose service provider dialog <br> */ <br>BOOL CALLBACK DlgProcChooseProvider(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>LPVOIDlpCon = NULL; <br>    static  LONG    iIndex; <br>    static  HWND hWndCtl; <br>    HRESULT hr; <br> <br>    switch (msg) <br>    { <br>case WM_NOTIFY: <br>switch (((NMHDR FAR *) lParam)-&gt;code)  <br>{ <br>case PSN_SETACTIVE: <br>PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT); <br>return(TRUE); <br> <br>case PSN_WIZNEXT:  <br>// Release previously selected DPlay object, if any. <br>DPlayRelease(); <br>if (iIndex != LB_ERR) <br>{ <br>lpCon = (LPVOID) SendMessage(hWndCtl, LB_GETITEMDATA, iIndex, 0); <br> <br>if (lpCon) <br>{ <br>// create directplay object <br>if ((hr = DPlayCreate(lpCon)) == DP_OK) <br>                    { <br>    return(TRUE); <br>                    } <br>                    else <br>                    { <br>                        ShowError(IDS_DPLAY_ERROR_IDC); <br>                    } <br>} <br>} <br>SetWindowLong(hDlg, DWL_MSGRESULT, -1); <br>return(TRUE); <br> <br>case PSN_QUERYCANCEL: <br>ReleaseSPData(); <br>DPlayRelease(); <br>return(TRUE); <br>} <br>break; <br> <br>    case WM_INITDIALOG: <br>SendDlgItemMessage(hDlg, IDC_SP_TITLE, WM_SETFONT, (WPARAM)ghTitleFont, MAKELPARAM(TRUE,0)); <br> <br>        hWndCtl = GetDlgItem(hDlg, IDC_SERVICEPROVIDERS); <br>        if (hWndCtl == NULL) return(TRUE); <br> <br>// remember the service provider control. used later in freeing sp information. <br>ghWndSPCtl = hWndCtl; <br> <br>if ((hr = DPlayCreate(lpCon)) != DP_OK) <br>        { <br>// class not available, so tell them to get DirectX 5 or later <br>if ((hr == REGDB_E_CLASSNOTREG) || (hr == REGDB_E_IIDNOTREG)) <br>ShowError(IDS_DPLAY_ERROR_CLSID); <br>else <br>ShowError(IDS_DPLAY_ERROR_IDC); <br>SetWindowLong(hDlg, DWL_MSGRESULT, -1); <br>PostQuitMessage(-1); <br>return(TRUE); <br>        } <br> <br>//Insert all available connections into the connection listbox. <br>        IDirectPlay3_EnumConnections( glpDP3A, glpGuid, DPEnumConnectionsCallback, hWndCtl, 0); <br>        SetFocus(hWndCtl); <br> <br>        SendMessage(hWndCtl, LB_SETCURSEL, iIndex, 0); <br>        iIndex = SendMessage(hWndCtl, LB_GETCURSEL, 0, 0); <br>        return(TRUE); <br> <br>    case WM_COMMAND: <br>        if ( HIWORD(wParam) == LBN_SELCHANGE) <br>        { <br>            iIndex = SendMessage(hWndCtl, LB_GETCURSEL, 0, 0); <br> <br>return(TRUE); <br>        } <br>break; <br>    } <br>    return (FALSE); <br>} <br> <br> <br>/* <br> * DlgProcGameSetup <br> * <br> * Dialog procedure for the Game Setup Dialog. <br> */ <br>BOOL CALLBACK DlgProcGameSetup (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>    switch (msg) <br>    { <br>case WM_NOTIFY: <br>switch (((NMHDR FAR *) lParam)-&gt;code)  <br>{ <br>case PSN_SETACTIVE: <br>PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT); <br>return(TRUE); <br> <br>case PSN_WIZNEXT:  <br>if (gbIsHost) <br>SetWindowLong(hDlg, DWL_MSGRESULT, IDD_HOSTSESSION); <br>return(TRUE); <br> <br>case PSN_QUERYCANCEL: <br>ReleaseSPData(); <br>DPlayRelease(); <br>return(TRUE); <br>} <br>break; <br> <br>    case WM_INITDIALOG: <br>// setup title fonts <br>SendDlgItemMessage(hDlg, IDC_GAMESETUP_TITLE, WM_SETFONT, (WPARAM)ghTitleFont, MAKELPARAM(TRUE,0)); <br>SendDlgItemMessage(hDlg, IDC_JOINSESSION, WM_SETFONT, (WPARAM)ghHeadingFont, MAKELPARAM(TRUE,0)); <br>SendDlgItemMessage(hDlg, IDC_HOSTSESSION, WM_SETFONT, (WPARAM)ghHeadingFont, MAKELPARAM(TRUE,0)); <br>// host by default <br>SendDlgItemMessage(hDlg, IDC_HOSTSESSION, BM_SETCHECK, 1, 0); <br>SendDlgItemMessage(hDlg, IDC_JOINSESSION, BM_SETCHECK, 0, 0); <br>gbIsHost = TRUE; <br>        return(TRUE); <br> <br>    case WM_COMMAND: <br>        if (HIWORD(wParam) == BN_CLICKED) <br>switch (LOWORD(wParam)) <br>{ <br>case IDC_HOSTSESSION: <br>if (SendDlgItemMessage(hDlg, IDC_HOSTSESSION, BM_GETCHECK, 1, 0) == 1) <br>{ <br>gbIsHost = TRUE; <br>} <br>return(TRUE); <br>case IDC_JOINSESSION: <br>if (SendDlgItemMessage(hDlg, IDC_JOINSESSION, BM_GETCHECK, 1, 0) == 1) <br>{ <br>gbIsHost = FALSE; <br>} <br>return(TRUE); <br>} <br>break; <br>} <br>    return(FALSE); <br>} <br> <br>/* <br> * EnumPlayer <br> * <br> * EnumeratePlayer callback. Inserts player information into the passed in tree view control. <br> */ <br>BOOL WINAPI EnumPlayer(DPID pidID, DWORD dwPlayerType, LPCDPNAME lpName, <br>DWORD dwFlags, LPVOID lpContext) <br>{ <br>    HWND hWnd = (HWND) lpContext; <br>HTREEITEM hItem; <br> <br>#ifdef UNICODE <br>hItem = AddItemToTree(hWnd, lpName-&gt;lpszShortName, 0, -1); <br>#else <br>hItem = AddItemToTree(hWnd, lpName-&gt;lpszShortNameA, 0, -1); <br>#endif <br> <br>    return(TRUE); <br>} <br> <br>/* <br> * EnumSession <br> * <br> * EnumSessions callback. Inserts session description information in the passed in  <br> * tree view control. <br> */ <br>BOOL WINAPI EnumSession(LPCDPSESSIONDESC2 lpDPSessionDesc, LPDWORD lpdwTimeOut, DWORD dwFlags,  <br>LPVOID lpContext) <br>{ <br>    HWND hWnd = (HWND) lpContext; <br>HTREEITEM hItem; <br>LPTREEDATA lpdata; <br> <br>    if(dwFlags &amp; DPESC_TIMEDOUT) return FALSE;       // don't try again <br> <br>if (hWnd == NULL) return FALSE; <br> <br>// allocate memory to remember the guid <br>lpdata = (LPTREEDATA) malloc(sizeof(TREEDATA)); <br>if (!lpdata) return FALSE; <br> <br>lpdata-&gt;guid = lpDPSessionDesc-&gt;guidInstance; <br>lpdata-&gt;dwRefresh = 1; <br> <br>#ifdef UNICODE <br>hItem = AddItemToTree(hWnd, lpDPSessionDesc-&gt;lpszSessionName, (DWORD)lpdata, 1); <br>#else <br>hItem = AddItemToTree(hWnd, lpDPSessionDesc-&gt;lpszSessionNameA, (DWORD)lpdata, 1); <br>#endif <br> <br>if (hItem) <br>{ <br>// it was new <br>TreeView_SelectItem(hWnd, hItem); <br>// enumerate players for new session <br>DPlayEnumPlayers((LPGUID)&amp;lpDPSessionDesc-&gt;guidInstance, EnumPlayer, (LPVOID) hWnd, DPENUMPLAYERS_SESSION); <br>} <br>else  <br>{ <br>// it was already in the tree <br>free(lpdata); <br>} <br> <br> <br>    return(TRUE); <br>} <br> <br> <br>void ResetTreeRefresh(HWND hwndTV) <br>{ <br>TV_ITEM item; <br>    HTREEITEM hItem; <br>    LPTREEDATA psearchdata; <br> <br>memset(&amp;item,0,sizeof(item)); <br>     <br>    // get the first app item (child of the running apps item) <br>    hItem = (HTREEITEM)SendMessage( hwndTV, TVM_GETNEXTITEM, TVGN_ROOT,(LPARAM) NULL);     <br> <br>    while (hItem) <br>    { <br>// gets its data <br>    item.mask = TVIF_PARAM; <br>    item.hItem = hItem; <br>SendMessage( hwndTV, TVM_GETITEM, 0, (LPARAM)&amp;item ); <br>// set the dwRefresh to 0 <br>psearchdata = (LPTREEDATA)item.lParam; <br>if (psearchdata) psearchdata-&gt;dwRefresh = 0; <br>    SendMessage( hwndTV, TVM_SETITEM, 0, (LPARAM)&amp;item ); <br> <br>// get the next one <br>    hItem = (HTREEITEM)SendMessage( hwndTV, TVM_GETNEXTITEM, TVGN_NEXT, (LPARAM)hItem );     <br>    }     <br> <br>return ; <br>}  // ResetTreeRefresh   <br> <br>void RemoveStaleSessions(HWND hwndTV) <br>{ <br>TV_ITEM item; <br>    HTREEITEM hItem,hItemNext; <br>    LPTREEDATA psearchdata; <br> <br>memset(&amp;item,0,sizeof(item)); <br>     <br>    // get the first app item (child of the running apps item) <br>    hItem = (HTREEITEM)SendMessage( hwndTV, TVM_GETNEXTITEM, TVGN_ROOT,(LPARAM) NULL);     <br> <br>    while (hItem) <br>    { <br>// get the next one <br>    hItemNext = (HTREEITEM)SendMessage( hwndTV, TVM_GETNEXTITEM, TVGN_NEXT, (LPARAM)hItem );     <br> <br>// gets its data <br>    item.mask = TVIF_PARAM; <br>    item.hItem = hItem; <br>SendMessage( hwndTV, TVM_GETITEM, 0, (LPARAM)&amp;item ); <br> <br>// if dwRefresh is still 0, it wasn't enum'ed <br>psearchdata = (LPTREEDATA)item.lParam; <br>if (psearchdata &amp;&amp; (0 == psearchdata-&gt;dwRefresh)) <br>{ <br>free(psearchdata); <br>SendMessage( hwndTV, TVM_DELETEITEM, 0, (LPARAM)hItem ); <br>} <br> <br>hItem = hItemNext; <br>    }     <br> <br>return ; <br> <br>}  // RemoveStaleSessions   <br> <br>/* <br> * DlgProcJoinSession <br> * <br> * Dialog procedure for Join Session Dialog <br> */ <br>BOOL CALLBACK DlgProcJoinSession (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>    static  NM_TREEVIEW nmtv; <br>    static  HWND hWndCtl; <br>static  TCHAR tszPlayerName[MAX_PLAYERNAME+1]; <br>static  HANDLEdphEvent = NULL; <br>TV_ITEM tvItem; <br>TCHARtszSessionName[MAX_SESSIONNAME+1]; <br>DWORD   dwPNameSize; <br>    HRESULT hr; <br>HTREEITEM htiCur, htiNext; <br>LPGUID  lpGuid; <br> <br>    switch (msg) <br>    { <br>case WM_NOTIFY: <br>switch (((NMHDR FAR *) lParam)-&gt;code)  <br>{ <br>case PSN_SETACTIVE: <br>if (hWndCtl) TreeView_DeleteAllItems(hWndCtl); <br> <br>// enum sessions and let dplay decide the timeout <br>hr = DPlayEnumSessions(0, EnumSession, (LPVOID) hWndCtl, DPENUMSESSIONS_ASYNC); <br> <br>if (FAILED(hr)) <br>{ <br>return (FALSE); <br>} <br> <br>// enumerate players for all sessions <br>ghtiSession = TreeView_GetFirstVisible(hWndCtl); <br> <br>while (ghtiSession) <br>{ <br>// delete previous players from display <br>if ((htiNext = htiCur = TreeView_GetChild(hWndCtl, ghtiSession))  <br>!= (HTREEITEM)0) <br>{ <br>do <br>{ <br>htiNext = TreeView_GetNextSibling(hWndCtl, htiCur); <br>TreeView_DeleteItem(hWndCtl, htiCur); <br>htiCur = htiNext; <br>} while (htiNext); <br>} <br> <br>tvItem.hItem = ghtiSession; <br>tvItem.pszText = tszSessionName; <br>tvItem.cchTextMax = MAX_SESSIONNAME; <br>TreeView_GetItem(hWndCtl, &amp;tvItem); <br>// enumerate players for selected session <br>DPlayEnumPlayers((LPGUID)tvItem.lParam, EnumPlayer, (LPVOID) hWndCtl, DPENUMPLAYERS_SESSION); <br>ghtiSession = TreeView_GetNextItem(hWndCtl, ghtiSession, TVGN_NEXTVISIBLE); <br>} <br> <br>// set Finish button highlite <br>if (GetDlgItemText(hDlg, IDC_JOIN_PLAYERNAME, tszPlayerName, MAX_PLAYERNAME) &amp;&amp;  <br>(htiCur = TreeView_GetSelection(hWndCtl))) <br>{ <br>PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK|PSWIZB_FINISH); <br>} <br>else <br>{ <br>PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_BACK|PSWIZB_DISABLEDFINISH); <br>} <br> <br>SetFocus(hWndCtl); <br> <br>// start up timer <br>                SetTimer(hDlg, ENUM_TIMER_ID, ENUM_TIMEOUT, NULL); <br> <br>return(TRUE); <br> <br>case PSN_WIZFINISH: <br>                KillTimer(hDlg, ENUM_TIMER_ID); <br> <br>// add user selections to registry <br>if (ghDuelKey)  <br>{ <br>RegSet(TEXT("PlayerName"), (CONST BYTE *)tszPlayerName,  <br>sizeof(tszPlayerName)); <br>} <br> <br>// get the session guid <br>if (nmtv.itemNew.lParam) <br>{ <br>// user selected a session item, so just grab its lParam <br>lpGuid = (LPGUID)nmtv.itemNew.lParam; <br>} <br>else <br>{ <br>// user selected a player item, so grab its parent's (session) lParam <br>htiCur = TreeView_GetParent(hWndCtl, nmtv.itemNew.hItem); <br>if (!htiCur) <br>{ <br>// fail finish <br>ShowError(IDS_WIZARD_ERROR_GSG); <br>SetWindowLong(hDlg, DWL_MSGRESULT, -1); <br>return (TRUE); <br>} <br> <br>tvItem.hItem = htiCur; <br>tvItem.pszText = tszSessionName; <br>tvItem.cchTextMax = MAX_SESSIONNAME; <br>TreeView_GetItem(hWndCtl, &amp;tvItem); <br>lpGuid = (LPGUID)tvItem.lParam; <br>} <br> <br>// open session <br>if ((hr = DPlayOpenSession(lpGuid)) != DP_OK) <br>{ <br>// fail finish <br>ShowError(IDS_DPLAY_ERROR_JS); <br>SetWindowLong(hDlg, DWL_MSGRESULT, -1); <br>return (TRUE); <br>} <br> <br>// create player <br>if ((hr = DPlayCreatePlayer(&amp;gOurID, tszPlayerName, NULL, NULL, 0)) != DP_OK) <br>{ <br>// fail finish <br>ShowError(IDS_DPLAY_ERROR_CP); <br>SetWindowLong(hDlg, DWL_MSGRESULT, -1); <br>return (TRUE); <br>} <br> <br>// everything went well, release allocated memory and finish <br>ReleaseSessionData(hWndCtl); <br>ReleaseSPData(); <br>return(TRUE); <br> <br>case PSN_QUERYCANCEL: <br>                KillTimer(hDlg, ENUM_TIMER_ID); <br>ReleaseSPData(); <br>ReleaseSessionData(hWndCtl); <br>DPlayRelease(); <br>return(TRUE); <br> <br>case PSN_WIZBACK: <br>                KillTimer(hDlg, ENUM_TIMER_ID); <br>ReleaseSessionData(hWndCtl); <br>return(TRUE); <br> <br>case TVN_SELCHANGING: <br>nmtv = *((NM_TREEVIEW *) lParam); <br> <br>// set Finish button status  <br>if (GetDlgItemText(hDlg, IDC_JOIN_PLAYERNAME, tszPlayerName, MAX_PLAYERNAME) &amp;&amp;  <br>(htiCur = TreeView_GetSelection(hWndCtl))) <br>{ <br>PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK|PSWIZB_FINISH); <br>} <br>else <br>{ <br>PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_BACK|PSWIZB_DISABLEDFINISH); <br>} <br>return(FALSE); <br> <br>case NM_CLICK: <br>return(FALSE); <br>} <br>break; <br>    case WM_INITDIALOG: <br>// setup title fonts <br>SendDlgItemMessage(hDlg, IDC_JOIN_SESSION_TITLE, WM_SETFONT, (WPARAM)ghHeadingFont, MAKELPARAM(TRUE,0)); <br>SendDlgItemMessage(hDlg, IDC_JOIN_PLAYER_TITLE, WM_SETFONT, (WPARAM)ghHeadingFont, MAKELPARAM(TRUE,0)); <br> <br>// setup user's previous data <br>dwPNameSize = MAX_PLAYERNAME+1; <br>tszPlayerName[0]=0; <br>if (ghDuelKey &amp;&amp; (RegGet(TEXT("PlayerName"),(LPBYTE)tszPlayerName,&amp;dwPNameSize) == ERROR_SUCCESS)) <br>SetDlgItemText(hDlg, IDC_JOIN_PLAYERNAME, tszPlayerName); <br> <br>        hWndCtl = GetDlgItem(hDlg, IDC_JOIN_SESSION); <br>        if (hWndCtl == NULL) return(TRUE); <br>InitTreeViewImageLists(hWndCtl); <br>        return(TRUE); <br> <br>case WM_TIMER: <br> <br>ResetTreeRefresh(hWndCtl); <br>// enum sessions and let dplay decide the timeout <br>DPlayEnumSessions(0, EnumSession, (LPVOID) hWndCtl, DPENUMSESSIONS_ASYNC); <br> <br>RemoveStaleSessions(hWndCtl); <br> <br>// set Finish button highlite <br>if (GetDlgItemText(hDlg, IDC_JOIN_PLAYERNAME, tszPlayerName, MAX_PLAYERNAME) &amp;&amp;  <br>(htiCur = TreeView_GetSelection(hWndCtl))) <br>{ <br>PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK|PSWIZB_FINISH); <br>} <br>else <br>{ <br>PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_BACK|PSWIZB_DISABLEDFINISH); <br>} <br> <br>break; <br> <br>    case WM_COMMAND: <br> <br>switch (LOWORD(wParam)) <br>{ <br>case IDC_JOIN_PLAYERNAME: <br>if (HIWORD(wParam) == EN_CHANGE) <br>{ <br>// set Finish button status  <br>if (GetDlgItemText(hDlg, IDC_JOIN_PLAYERNAME, tszPlayerName, MAX_PLAYERNAME) &amp;&amp;  <br>(htiCur = TreeView_GetSelection(hWndCtl))) <br>{ <br>PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK|PSWIZB_FINISH); <br>} <br>else <br>{ <br>PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK|PSWIZB_DISABLEDFINISH); <br>} <br>} <br>break; <br>} <br>break; <br>    } <br>    return (FALSE); <br>} <br> <br>/* <br> * DlgProcHostSession <br> * <br> * Dialog proc for Host Session Dialog <br> */ <br>BOOL CALLBACK DlgProcHostSession(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>staticTCHAR tszSessionName[MAX_SESSIONNAME+1], tszPlayerName[MAX_PLAYERNAME+1]; <br>HRESULT hr; <br>DWORDdwPNameSize, dwSNameSize; <br> <br>switch (msg) { <br>case WM_NOTIFY: <br>switch (((NMHDR FAR *) lParam)-&gt;code)  <br>{ <br>case PSN_SETACTIVE: <br>if (GetDlgItemText(hDlg, IDC_HOST_SESSIONNAME, tszSessionName, MAX_SESSIONNAME) &amp;&amp;  <br>GetDlgItemText(hDlg, IDC_HOST_PLAYERNAME, tszPlayerName, MAX_PLAYERNAME)) <br>{ <br>PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK|PSWIZB_FINISH); <br>} <br>else <br>{ <br>PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK|PSWIZB_DISABLEDFINISH); <br>} <br>return(TRUE); <br> <br>case PSN_WIZFINISH: <br>// add user selections to registry <br>if (ghDuelKey)  <br>{ <br>RegSet(TEXT("PlayerName"), (CONST BYTE *)tszPlayerName, sizeof(tszPlayerName)); <br>RegSet(TEXT("SessionName"), (CONST BYTE *)tszSessionName, sizeof(tszSessionName)); <br>} <br> <br>// create session <br>if ((hr = DPlayCreateSession(tszSessionName)) != DP_OK) <br>{ <br>// fail finish <br>ShowError(IDS_DPLAY_ERROR_CS); <br>SetWindowLong(hDlg, DWL_MSGRESULT, -1); <br>return (TRUE); <br>} <br> <br>// create player <br>if ((hr = DPlayCreatePlayer(&amp;gOurID, tszPlayerName, NULL, NULL, 0)) != DP_OK) <br>{ <br>ShowError(IDS_DPLAY_ERROR_CP); <br>SetWindowLong(hDlg, DWL_MSGRESULT, -1); <br>return (TRUE); <br>} <br> <br>// everything went well, release allocated memory and finish <br>ReleaseSPData(); <br>return(TRUE); <br> <br>case PSN_WIZBACK: <br>SetWindowLong(hDlg, DWL_MSGRESULT, IDD_GAMESETUP); <br>return(TRUE); <br> <br>case PSN_QUERYCANCEL: <br>// release allocated memory <br>ReleaseSPData(); <br>// release dplay <br>DPlayRelease(); <br>return(TRUE); <br>} <br>break; <br>case WM_INITDIALOG: <br>// setup title font <br>SendDlgItemMessage(hDlg, IDC_HOST_TITLE, WM_SETFONT, (WPARAM)ghTitleFont, MAKELPARAM(TRUE,0)); <br>SendDlgItemMessage(hDlg, IDC_HOST_SESSION_TITLE, WM_SETFONT, (WPARAM)ghHeadingFont, MAKELPARAM(TRUE,0)); <br>SendDlgItemMessage(hDlg, IDC_HOST_PLAYER_TITLE, WM_SETFONT, (WPARAM)ghHeadingFont, MAKELPARAM(TRUE,0)); <br> <br>dwPNameSize = MAX_PLAYERNAME+1; <br>dwSNameSize = MAX_SESSIONNAME+1; <br>tszPlayerName[0]=0; <br>tszSessionName[0]=0; <br>if (ghDuelKey) <br>{ <br>if (RegGet(TEXT("PlayerName"), (LPBYTE)tszPlayerName, &amp;dwPNameSize) == ERROR_SUCCESS) <br>SetDlgItemText(hDlg, IDC_HOST_PLAYERNAME, tszPlayerName); <br>if (RegGet(TEXT("SessionName"), (LPBYTE)tszSessionName, &amp;dwSNameSize) == ERROR_SUCCESS) <br>SetDlgItemText(hDlg, IDC_HOST_SESSIONNAME, tszSessionName); <br>} <br> <br>return(TRUE); <br> <br>    case WM_COMMAND: <br>switch (LOWORD(wParam)) <br>{ <br>case IDC_HOST_SESSIONNAME: <br>if (HIWORD(wParam) == EN_CHANGE) <br>{ <br>if (GetDlgItemText(hDlg, IDC_HOST_SESSIONNAME, tszSessionName, MAX_SESSIONNAME) &amp;&amp;  <br>GetDlgItemText(hDlg, IDC_HOST_PLAYERNAME, tszPlayerName, MAX_PLAYERNAME)) <br>{ <br>PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK|PSWIZB_FINISH); <br>} <br>else <br>{ <br>PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK|PSWIZB_DISABLEDFINISH); <br>} <br> <br>return TRUE; <br>} <br>break; <br> <br>case IDC_HOST_PLAYERNAME: <br>if (HIWORD(wParam) == EN_CHANGE) <br>{ <br>if (GetDlgItemText(hDlg, IDC_HOST_SESSIONNAME, tszSessionName, MAX_SESSIONNAME) &amp;&amp;  <br>GetDlgItemText(hDlg, IDC_HOST_PLAYERNAME, tszPlayerName, MAX_PLAYERNAME)) <br>{ <br>PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK|PSWIZB_FINISH); <br>} <br>else <br>{ <br>PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK|PSWIZB_DISABLEDFINISH); <br>} <br>} <br>break; <br>} <br>break; <br>    } <br> <br>return(FALSE); <br>} <br> <br>/* <br> * InitTreeViewImageLists - creates an image list, adds three bitmaps to  <br> *     it, and associates the image list with a tree-view control.  <br> * Returns TRUE if successful or FALSE otherwise.  <br> * hwndTV - handle of the tree-view control  <br> * <br> * Global variables and constants  <br> *     gnSession, and gnPlayer - integer variables for  <br> *         indexes of the images  <br> *     CX_BITMAP and CY_BITMAP - width and height of an icon  <br> *     NUM_BITMAPS - number of bitmaps to add to the image list  <br> */ <br>BOOL InitTreeViewImageLists(HWND hwndTV)  <br>{  <br>    HIMAGELIST himl;  // handle of image list  <br>    HBITMAP hbmp;     // handle of bitmap  <br>  <br>    // Create the image list.  <br>    if ((himl = ImageList_Create(CX_BITMAP, CY_BITMAP,  <br>            FALSE, NUM_BITMAPS, 0)) == NULL)  <br>        return FALSE;  <br>  <br>    // Add the session and player bitmaps.  <br>    hbmp = LoadBitmap(ghinst, MAKEINTRESOURCE(IDB_CLOSED_SESSION));  <br>    gnSession = ImageList_Add(himl, hbmp, (HBITMAP) NULL);  <br>    DeleteObject(hbmp);  <br>  <br>    hbmp = LoadBitmap(ghinst, MAKEINTRESOURCE(IDB_PLAYER));  <br>    gnPlayer = ImageList_Add(himl, hbmp, (HBITMAP) NULL);  <br>    DeleteObject(hbmp);  <br>  <br>    // Fail if not all of the images were added.  <br>    if (ImageList_GetImageCount(himl) &lt; 2)  <br>        return FALSE;  <br>  <br>    // Associate the image list with the tree-view control.  <br>    TreeView_SetImageList(hwndTV, himl, TVSIL_NORMAL);  <br>  <br>    return TRUE;  <br>}  <br>    <br>HTREEITEM FindItemInTree(HWND hwndTV,LPTREEDATA pdata) <br>{ <br>TV_ITEM item; <br>    HTREEITEM hItem; <br>    LPTREEDATA psearchdata; <br>    <br>    memset(&amp;item,0,sizeof(item)); <br>     <br>    // get the first app item (child of the running apps item) <br>    hItem = (HTREEITEM)SendMessage( hwndTV, TVM_GETNEXTITEM, TVGN_ROOT,(LPARAM) NULL);     <br> <br>    while (hItem) <br>    { <br>// gets its data <br>    item.mask = TVIF_PARAM; <br>    item.hItem = hItem; <br>SendMessage( hwndTV, TVM_GETITEM, 0, (LPARAM)&amp;item ); <br>// is this the one? <br>psearchdata = (LPTREEDATA)item.lParam; <br>if (IsEqualGUID(&amp;(psearchdata-&gt;guid),&amp;(pdata-&gt;guid)))  <br>{ <br>// mark the item as seen <br>psearchdata-&gt;dwRefresh = 1; <br>    SendMessage( hwndTV, TVM_SETITEM, 0, (LPARAM)&amp;item ); <br>return hItem; <br>} <br>// try the next one <br>    hItem = (HTREEITEM)SendMessage( hwndTV, TVM_GETNEXTITEM, TVGN_NEXT, (LPARAM)hItem );     <br>    }     <br> <br>    return NULL; <br>     <br> <br> <br>} // FindItemInTree <br> <br>/* <br> * AddItemToTree - adds items to a tree-view control.  <br> * Returns the handle of the newly added item.  <br> * hwndTV - handle of the tree-view control  <br> * lpszItem - text of the item to add  <br> * nLevel - level at which to add the item  <br> */ <br>HTREEITEM AddItemToTree(HWND hwndTV, LPTSTR lptszItem, DWORD dwData, int nLevel)  <br>{  <br>    TV_ITEM tvi;  <br>    TV_INSERTSTRUCT tvins;  <br>    static HTREEITEM hPrev = (HTREEITEM) TVI_FIRST;  <br>    static HTREEITEM hPrevRootItem = NULL;  <br>    static HTREEITEM hPrevLev2Item = NULL;  <br>HTREEITEM hItem; <br> <br>if (1 == nLevel) <br>{ <br>hItem = FindItemInTree(hwndTV,(LPTREEDATA)dwData); <br>if (hItem) return NULL; <br>} <br>memset(&amp;tvi,0,sizeof(tvi)); <br>memset(&amp;tvins,0,sizeof(tvins)); <br> <br>    tvi.mask = TVIF_TEXT | TVIF_IMAGE  <br>        | TVIF_SELECTEDIMAGE | TVIF_PARAM; <br> <br> // Set the state <br>if (nLevel == 1)  <br>{ <br>tvi.mask |= TVIF_STATE;  <br>tvi.state = TVIS_SELECTED; <br>} <br> <br>    // Set the text of the item.  <br>    tvi.pszText = lptszItem;  <br>  <br>   // Set the image <br>if (nLevel == 1) <br>{ <br>    tvi.iImage = gnSession;  <br>tvi.iSelectedImage = gnSession;  <br>} <br>else <br>{ <br>tvi.iImage = gnPlayer;  <br>tvi.iSelectedImage = gnPlayer;  <br>} <br>  <br> <br>    // Save the heading level in the item's application-defined  </code></pre>
<p>
</p>
<pre><code>// data area.  <br>    tvi.lParam = (LPARAM) dwData;  <br>  <br>    tvins.item = tvi;  <br>    tvins.hInsertAfter = hPrev;  <br>  <br>    // Set the parent item based on the specified level.  <br>    if (nLevel == -1) <br>tvins.hParent = hPrevRootItem; <br>    else if (nLevel == 1)  <br>        tvins.hParent = TVI_ROOT;  <br>    else if (nLevel == 2)  <br>        tvins.hParent = hPrevRootItem;  <br>else <br>        tvins.hParent = hPrevLev2Item;  <br>  <br>    // Add the item to the tree-view control.  <br>    hPrev = (HTREEITEM) SendMessage(hwndTV, TVM_INSERTITEM, 0,  <br>         (LPARAM) (LPTV_INSERTSTRUCT) &amp;tvins);  <br>  <br>    // Save the handle of the item.  <br>    if (nLevel == 1)  <br>        hPrevRootItem = hPrev;  <br>    else if (nLevel == 2)  <br>        hPrevLev2Item = hPrev;  <br>  <br>    return hPrev;  <br>}  <br>  <br>/* <br> * ReleaseSessionData <br> * <br> * Releases the memory allocated for session guids <br> */ <br>void ReleaseSessionData(HWND hWndCtl) <br>{ <br>HTREEITEM htiSession; <br>TV_ITEM tvItem; <br>TCHAR tszSessionName[MAX_SESSIONNAME+1]; <br> <br> <br>htiSession = TreeView_GetRoot(hWndCtl); <br>while (htiSession) <br>{ <br>tvItem.hItem = htiSession; <br>tvItem.pszText = tszSessionName; <br>tvItem.cchTextMax = MAX_SESSIONNAME; <br>TreeView_GetItem(hWndCtl, &amp;tvItem); <br>if (tvItem.lParam) free((LPVOID)tvItem.lParam); <br>htiSession = TreeView_GetNextSibling(hWndCtl, htiSession); <br>} <br>} <br> <br>/* <br> * ReleaseSPData <br> * <br> * Releases the memory allocated for service provider guids <br> * depends on global variable ghWndSPControl <br> */ <br>void ReleaseSPData(void) <br>{ <br>LPVOID lpCon = NULL; <br>int count,index; <br> <br>if (ghWndSPCtl) <br>{ <br>count = SendMessage(ghWndSPCtl, LB_GETCOUNT, 0, 0); <br>for (index = 0; index &lt; count; index++) <br>{ <br>lpCon = (LPVOID) SendMessage(ghWndSPCtl, LB_GETITEMDATA, index, 0); <br>if (lpCon) GlobalFreePtr(lpCon); <br>} <br>} <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
