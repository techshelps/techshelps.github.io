<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GAMEPROC.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3137"></a>GAMEPROC.C</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1995-1997 Microsoft Corporation. All Rights Reserved. <br> * <br> *  File:       gameproc.c <br> *  Content:    Game processing code <br> * <br> * <br> ***************************************************************************/ <br>#include "gameproc.h" <br>#include "util.h" <br>#include "gfx.h" <br>#include "comm.h" <br>#include "input.h" <br>#include "lobby.h" <br>#include "wizard.h" <br>#include "dsound.h" <br>#include "sfx.h" <br>#include "stdio.h" <br> <br>/* <br> * Externals <br> */ <br>extern DWORDgdwKeys; <br>extern LPDIRECTDRAWSURFACEglpShip0; <br>extern LPDIRECTDRAWSURFACEglpShip1; <br>extern LPDIRECTDRAWSURFACEglpShip2; <br>extern LPDIRECTDRAWSURFACEglpShip3; <br>extern BOOLgbShowFrameCount; <br>extern LPDIRECTDRAWSURFACEglpNum; <br>extern BOOLgbIsHost; <br>extern BOOLgbIsActive; <br>extern LPDPSESSIONDESC2glpdpSD; <br>extern HWNDghWndMain; <br>extern HINSTANCEghinst; <br>extern BOOL                     gbReliable; <br> <br>/* <br> * Globals <br> */ <br>FRAGgFrags[64];// ship framents <br>BLOCKSgBlocks;// field layout <br>LPVOID            glpvReceiveBuffer = NULL;// buffer to store received messages <br>DWORD           gdwReceiveBufferSize = 0;// size of buffer <br>DPIDgOurID;// our player id <br>BOOLgbHaveHostInit;// do we need to do host initializaton <br>intgnProgramState;// current state of the game <br>DWORDgdwFrameCount;// used for fps calc <br>DWORDgdwFramesLast;// .. <br>DWORDgdwFrameTime;// .. <br>BOOL                            gbUpdate;                   // TRUE if player data needs to be updated <br>BOOL                            gbNoField;                  // display blocks ? <br>BOOL                            gbSessionLost;              // did we get disconnected ? <br>HOSTMSG                         gHostMsg;                   // message buffer <br>BLOCKHITMSG                     gBlockHitMsg;               // .. <br>SHIPHITMSG                      gShipHitMsg;                // .. <br>ADDBLOCKMSG                     gAddBlockMsg;               // .. <br>CONTROLMSG                      gControlMsg;                // ..  <br>SYNCMSG                         gSyncMsg;                   // .. <br>TCHAR                           gDebugBuff[MAX_ERRORMSG];   // buffer for debug output <br> <br>/* <br> * Statics <br> */ <br> <br>static double      gDirx[40] = <br>{ <br>    0.000000, <br>    0.156434, <br>    0.309017, <br>    0.453991, <br>    0.587785, <br>    0.707107, <br>    0.809017, <br>    0.891007, <br>    0.951057, <br>    0.987688, <br>    1.000000, <br>    0.987688, <br>    0.951057, <br>    0.891007, <br>    0.809017, <br>    0.707107, <br>    0.587785, <br>    0.453990, <br>    0.309017, <br>    0.156434, <br>    0.000000, <br>    -0.156435, <br>    -0.309017, <br>    -0.453991, <br>    -0.587785, <br>    -0.707107, <br>    -0.809017, <br>    -0.891007, <br>    -0.951057, <br>    -0.987688, <br>    -1.000000, <br>    -0.987688, <br>    -0.951056, <br>    -0.891006, <br>    -0.809017, <br>    -0.707107, <br>    -0.587785, <br>    -0.453990, <br>    -0.309017, <br>    -0.156434 <br>}; <br> <br>static double      gDiry[40] = <br>{ <br>    -1.000000, <br>    -0.987688, <br>    -0.951057, <br>    -0.891007, <br>    -0.809017, <br>    -0.707107, <br>    -0.587785, <br>    -0.453990, <br>    -0.309017, <br>    -0.156434, <br>    0.000000, <br>    0.156434, <br>    0.309017, <br>    0.453991, <br>    0.587785, <br>    0.707107, <br>    0.809017, <br>    0.891007, <br>    0.951057, <br>    0.987688, <br>    1.000000, <br>    0.987688, <br>    0.951057, <br>    0.891006, <br>    0.809017, <br>    0.707107, <br>    0.587785, <br>    0.453990, <br>    0.309017, <br>    0.156434, <br>    0.000000, <br>    -0.156435, <br>    -0.309017, <br>    -0.453991, <br>    -0.587785, <br>    -0.707107, <br>    -0.809017, <br>    -0.891007, <br>    -0.951057, <br>    -0.987688 <br>}; <br> <br>/* <br> * InitMessageBuffers <br> * <br> * Sets up buffes used for sending different types of messages <br> */ <br>void InitMessageBuffers(void) <br>{ <br>    gHostMsg.byType        = MSG_HOST; <br>    gBlockHitMsg.byType    = MSG_BLOCKHIT; <br>    gShipHitMsg.byType     = MSG_SHIPHIT;     <br>    gAddBlockMsg.byType    = MSG_ADDBLOCK; <br>    gControlMsg.byType     = MSG_CONTROL;  <br>    gSyncMsg.byType        = MSG_SYNC; <br>} <br> <br>/* <br> * LaunchGame <br> * <br> * Sets up the game layout and launches <br> */ <br>void LaunchGame(void) <br>{ <br>HRESULT hr; <br> <br>// initialize global message buffers <br>    InitMessageBuffers(); <br> <br>// update window title <br>UpdateTitle(); <br> <br>// get current session description (glpdpSD is initialized in here) <br>    hr = DPlayGetSessionDesc(); <br>    if (FAILED(hr) || (!glpdpSD)) <br>{ <br>        ShowError(IDS_DPLAY_ERROR_GSD); <br>        goto ABORT; <br>} <br> <br>// initialize random number seed <br>srand((int)GetTickCount()); <br> <br>// clear front buffer before changing palette <br>EraseScreen(); <br>FlipScreen(); <br> <br>        // Begin collecting input <br>        ReacquireInputDevices(); <br> <br>    // initialize us <br>  hr = InitOurShip(); <br>    if (FAILED(hr)) <br>    { <br>        goto ABORT; <br>    } <br> <br>    // get the field layout <br>if( gbIsHost ) <br>{ <br>        // initialize field (done only by host) <br>        if (!gbNoField) <br>            InitField(); <br> <br>        // we have host initialization <br>gbHaveHostInit = TRUE; <br> <br>        // start updating screen <br>        gbIsActive = TRUE; <br>} <br>else <br>{ <br>        // get it from host, if we are joining <br>gbHaveHostInit = FALSE; <br>} <br> <br>    // success <br>    return; <br> <br>ABORT: <br>    // something went wrong, terminate game <br>    ExitGame(); <br>} <br> <br>/* <br> * ExitGame <br> * <br> * Game termination code <br> */ <br>void ExitGame(void) <br>{ <br>    // shut down app <br>PostMessage( ghWndMain, WM_CLOSE, 0, 0 ); <br>} <br> <br>/* <br> * InitOurShip <br> * <br> * Initializes our ship's initial attributes <br> */ <br>HRESULT InitOurShip(void) <br>{ <br>    int i; <br>    SHIP ship; <br>    HRESULT hr; <br> <br>// wipe out everything <br>ZeroMemory(&amp;ship, sizeof(ship)); <br> <br>// initialize sound buffers, tell function that it's OUR ship <br>    // so that it can use the global sound buffers instead of duplicating <br>    // from them and wasting resources. <br>InitPlayerLocalSoundData(&amp;ship, TRUE); <br> <br>// calculate ship type based on the number of players in the game <br>    // we cycle through four ships (Y,R,G,B) for now. <br> <br>ship.byType = (BYTE) ((glpdpSD-&gt;dwCurrentPlayers-1) % NUM_SHIP_TYPES); <br>    ship.dPosX  = randInt(0,MAX_SHIP_X); <br>    ship.dPosY  = randInt(0,MAX_SHIP_Y); <br>    ship.cFrame = randInt(0, MAX_SHIP_FRAME); <br>ship.bEnable = TRUE; <br> <br>    // set our local data <br>hr = DPlaySetPlayerData(gOurID, &amp;ship, sizeof(ship), DPSET_LOCAL); <br>    if (FAILED(hr)) <br>    { <br>        ShowError(IDS_DPLAY_ERROR_SPLD); <br>        goto FAIL; <br>    } <br> <br>    // no ship fragments <br>    for(i=0; i&lt;64; i++) <br>        gFrags[i].valid = FALSE; <br> <br>    // success <br>    return DP_OK; <br> <br>FAIL: <br>    // failed <br>    return hr; <br>} <br> <br>/* <br> *FUNCTION:   InitPlayerLocalSoundData <br> * <br> * <br> *NOTES:      Takes a ship and initializes ONLY its soundbuffers and sound flags. <br> *            It leaves everything else alone.  Good for when going to <br> *            full-screen mode, when we need to get rid of the sound buffers <br> *            for a bit, but don't want to change the data. <br> */ <br>void InitPlayerLocalSoundData(LPSHIP lpShip, BOOL bOurShip) <br>{ <br>int i; <br>    if (gbSoundInitialized) <br>    { <br>        for (i=0; i&lt;MAX_SOUNDS; i++) <br>        { <br>            if (FALSE == WaveGetBuffers(gSoundEffect[i],&amp;lpShip-&gt;lpDirectSoundBuffer[i], &amp;lpShip-&gt;lpDirectSound3DBuffer[i], bOurShip)) <br>            {//if it didn't work, get rid of all the other sound buffers <br>             //the current ones have already been set NULL by the failed function. <br>                ShowError(IDS_DSOUND_DUPBUF); <br>                for (--i; i&gt;=0; i--) <br>                { <br>                    // if it's our ship then we don't want to release the regular <br>                    // (non-3D) buffer because it's just a copy of a pointer to <br>                    // the corresponding GLOBAL sound buffer. <br>                    IDirectSoundBuffer_Release(lpShip-&gt;lpDirectSound3DBuffer[i]); <br>                    if (!bOurShip) <br>                    { <br>                        IDirectSoundBuffer_Release(lpShip-&gt;lpDirectSoundBuffer  [i]); <br>                    } <br>                    lpShip-&gt;lpDirectSoundBuffer  [i] = NULL; <br>                    lpShip-&gt;lpDirectSound3DBuffer[i] = NULL; <br>                } <br>                return; <br>            } <br>        } <br> <br>        lpShip-&gt;bFiring        = FALSE; <br>        lpShip-&gt;bBounced       = FALSE; <br>        lpShip-&gt;bDeath         = FALSE; <br>        lpShip-&gt;bBlockHit      = FALSE; <br>        lpShip-&gt;bEngineRunning = FALSE; <br>        lpShip-&gt;bMoving        = FALSE; <br>    } <br>    else <br>    { <br>    //if sound initialization has already failed in InitSfx(), then we want the ships' <br>    //sound buffers to be NULL so that we don't try to release them later. <br>        for (i=0; i&lt;MAX_SOUNDS; i++) <br>        { <br>            lpShip-&gt;lpDirectSoundBuffer  [i] = NULL; <br>            lpShip-&gt;lpDirectSound3DBuffer[i] = NULL; <br>        } <br>    } <br>}; <br> <br>/* <br> *FUNCTION:   SetPlayerLocalSoundDataCB (CALLBACK) <br> * <br> *PURPOSE:    Initializes and registers a player's local SOUND data ONLY. <br> */ <br>BOOL WINAPI SetPlayerLocalSoundDataCB(DPID dpId, DWORD dwPlayerType, LPCDPNAME lpName,  <br>                     DWORD dwFlags, LPVOID lpContext) <br>{ <br>SHIP ship; <br>    DWORD dwSize = sizeof(ship); <br>    HRESULT hr; <br>    BOOL bOurShip; <br> <br>    DPlayGetPlayerData(dpId, &amp;ship, &amp;dwSize, DPGET_LOCAL);  <br> <br>// no player data yet <br>if (0 == dwSize) <br>return TRUE; <br> <br>    //we need to know if it's our ship because we use the global sound buffers <br>    //while all the other ships have to DUPLICATE their sound buffers from <br>    //those global buffers.    <br>    bOurShip = (dpId == gOurID); <br>    InitPlayerLocalSoundData(&amp;ship, bOurShip); <br> <br>hr = DPlaySetPlayerData(dpId, &amp;ship, dwSize, DPSET_LOCAL); <br>    return (DP_OK == hr); <br>}; <br> <br>/* <br> *FUNCTION:   InitLocalSoundData <br> * <br> *PURPOSE:    Initializes and registers all players' sound data ONLY <br> */ <br>HRESULT InitLocalSoundData(void) <br>{ <br>    HRESULT hr; <br>hr = DPlayEnumPlayers(&amp;(glpdpSD-&gt;guidInstance), SetPlayerLocalSoundDataCB, NULL, 0); <br>    return hr; <br>} <br> <br>/* <br> *FUNCTION:   ReleaseLocalSoundData <br> * <br> *NOTES:      Releases a single ship's local sound buffers. <br> */ <br>void ReleasePlayerLocalSoundData(LPSHIP lpShip) <br>{ <br>int i; <br> <br>    if (gbSoundInitialized) <br>    { <br>        for (i=0; i&lt;MAX_SOUNDS; i++) <br>        { <br>            if (lpShip-&gt;lpDirectSoundBuffer[i] != NULL) <br>            { <br>                IDirectSoundBuffer_Stop     (lpShip-&gt;lpDirectSoundBuffer[i]); <br>                //only release if it's not just a pointer copy from the global. <br>                if (lpShip-&gt;lpDirectSoundBuffer[i] != gSoundEffect[i]-&gt;lpDirectSoundBuffer) <br>                { <br>                    //This ship's buffer is not identical to its global, we can release it. <br>                    IDirectSoundBuffer_Release  (lpShip-&gt;lpDirectSoundBuffer[i]); <br>                } <br>                lpShip-&gt;lpDirectSoundBuffer[i] = NULL; <br>            } <br> <br>            if (lpShip-&gt;lpDirectSound3DBuffer[i] != NULL) <br>            { <br>                IDirectSound3DBuffer_Release(lpShip-&gt;lpDirectSound3DBuffer[i]); <br>                lpShip-&gt;lpDirectSound3DBuffer[i] = NULL; <br>            } <br>        } <br>    } <br>}; <br> <br>/* <br> *FUNCTION:   ReleasePlayerLocalData  (CALLBACK) <br> * <br> *PURPOSE:    Retrieves and releases a player's local data from dplay. <br> */ <br>BOOL WINAPI ReleasePlayerLocalDataCB(DPID dpId, DWORD dwPlayerType, LPCDPNAME lpName, <br>                 DWORD dwFlags, LPVOID lpContext) <br>{ <br>SHIP ship; <br>    DWORD dwSize = sizeof(SHIP);     <br>    HRESULT hr; <br> <br>    hr = DPlayGetPlayerData(dpId, &amp;ship, &amp;dwSize, DPGET_LOCAL); <br>    if (FAILED(hr)) <br>    { <br>        wsprintf(gDebugBuff, TEXT("Get Player local data failed for id %d\n"), dpId); <br>        DEBUG_OUT(gDebugBuff); <br>        goto FAIL; <br>    } <br> <br>// no player data yet <br>if (0 == dwSize) <br>return TRUE; <br> <br>    ReleasePlayerLocalSoundData(&amp;ship); <br> <br>    hr = DPlaySetPlayerData(dpId, &amp;ship,  dwSize, DPSET_LOCAL); <br>    if (FAILED(hr)) <br>    { <br>        wsprintf(gDebugBuff, TEXT("Set Player local data failed for id %d\n"), dpId); <br>        DEBUG_OUT(gDebugBuff); <br>        goto FAIL; <br>    } <br> <br>    // success <br>return TRUE; <br>FAIL: <br>    // we failed <br>    return FALSE; <br>} <br> <br>/* <br> *FUNCTION:   ReleaseLocalData <br> * <br> *PURPOSE:    Releases local data of ALL players. <br> */ <br>void ReleaseLocalData(void) <br>{ <br>     HRESULT hr; <br> <br>     if (gnProgramState == PS_ACTIVE) <br>     { <br>         hr = DPlayEnumPlayers(&amp;(glpdpSD-&gt;guidInstance), ReleasePlayerLocalDataCB, NULL, 0); <br>         if (FAILED(hr)) <br>         { <br>             ShowError(IDS_DPLAY_ERROR_EP); <br>         } <br>     } <br>}; <br> <br>/* <br> * ProcessUserInput <br> * <br> * Processes any input from the user and updates our ship state <br> */ <br>void ProcessUserInput(LPSHIP lpShip) <br>{ <br>    static dwOldKeys = 0; <br> <br>    gbUpdate = FALSE; <br> <br>    // DSOUND: check if the engine was turned off <br>    if (!(gdwKeys    &amp; (KEY_DOWN | KEY_UP)) &amp;&amp;  <br>(dwOldKeys &amp; (KEY_DOWN | KEY_UP))) <br>    { <br>        gdwKeys |= KEY_ENGINEOFF; <br> <br>        gControlMsg.byState = (BYTE) gdwKeys; <br>        // let everyone know that we just turned our engine off <br>        SendGameMessage((LPGENERICMSG) &amp;gControlMsg, DPID_ALLPLAYERS); <br>    } <br> <br>    // update our ship state <br>    UpdateState(lpShip, gdwKeys); <br> <br>    // remember current keys for next frame <br>    dwOldKeys = gdwKeys; <br>} <br> <br>/* <br> * UpdateState <br> * <br> * Updates the current state of our ship, given user input <br> */ <br>void UpdateState(LPSHIP lpShip, DWORD dwControls) <br>{ <br>    lpShip-&gt;dwKeys = dwControls; <br> <br>    if( dwControls &amp; KEY_LEFT ) <br>    { <br>        gbUpdate = TRUE; <br>        lpShip-&gt;cFrame -= 1; <br>if( lpShip-&gt;cFrame &lt; 0 ) <br>lpShip-&gt;cFrame += MAX_SHIP_FRAME; <br>    } <br>    if( dwControls &amp; KEY_RIGHT ) <br>    { <br>        gbUpdate = TRUE; <br>        lpShip-&gt;cFrame += 1; <br>if( lpShip-&gt;cFrame &gt;= MAX_SHIP_FRAME ) <br>lpShip-&gt;cFrame -= MAX_SHIP_FRAME; <br>    } <br>    if( dwControls &amp; KEY_UP ) <br>    { <br>        gbUpdate = TRUE; <br>        lpShip-&gt;dVelX += gDirx[lpShip-&gt;cFrame] * 10.0 / 1000.0; <br>        lpShip-&gt;dVelY += gDiry[lpShip-&gt;cFrame] * 10.0 / 1000.0; <br>    } <br>    if( dwControls &amp; KEY_DOWN ) <br>    { <br>        gbUpdate = TRUE; <br>        lpShip-&gt;dVelX -= gDirx[lpShip-&gt;cFrame] * 10.0 / 1000.0; <br>        lpShip-&gt;dVelY -= gDiry[lpShip-&gt;cFrame] * 10.0 / 1000.0; <br>    } <br>    if( dwControls &amp; KEY_STOP ) <br>    { <br>        gbUpdate = TRUE; <br>        lpShip-&gt;dVelX = 0.0; <br>        lpShip-&gt;dVelY = 0.0; <br>    } <br>    if( !lpShip-&gt;bBulletEnable &amp;&amp; lpShip-&gt;bEnable ) <br>    { <br>if( dwControls &amp; KEY_FIRE ) <br>{ <br>            gbUpdate = TRUE; <br>// launch a new bullet <br>lpShip-&gt;dBulletPosX = (WORD) (gDirx[lpShip-&gt;cFrame]*6.0 + 16.0 + lpShip-&gt;dPosX); <br>lpShip-&gt;dBulletPosY = (WORD) (gDiry[lpShip-&gt;cFrame]*6.0 + 16.0 + lpShip-&gt;dPosY); <br>lpShip-&gt;dBulletVelX = gDirx[lpShip-&gt;cFrame]*500.0/1000.0; <br>lpShip-&gt;dBulletVelY = gDiry[lpShip-&gt;cFrame]*500.0/1000.0; <br>lpShip-&gt;bBulletEnable = TRUE; <br>lpShip-&gt;dwBulletFrame = 0; <br>} <br>    } <br>} <br> <br>/* <br> * SendSync <br> * <br> * Sends a sync message with the rendevous position. We are using a synchronization technique in <br> * which every player informs everyone else where the player is going to be at the end of the  <br> * next sync interval. Based on this rendezvous position, everyone tries to move their corresponding <br> * ghosts to the rendezvous position by the end of the interval. <br> */ <br>void SendSync(LPSHIP lpShip) <br>{ <br>gSyncMsg.byShipType = lpShip-&gt;byType; <br>    gSyncMsg.cFrame = lpShip-&gt;cFrame; <br>    gSyncMsg.dPosX  = lpShip-&gt;dPosX + lpShip-&gt;dVelX*1000; <br>    gSyncMsg.dPosY  = lpShip-&gt;dPosY + lpShip-&gt;dVelY*1000; <br> <br>    SendGameMessage((LPGENERICMSG) &amp;gSyncMsg, DPID_ALLPLAYERS); <br>} <br> <br>/* <br> * UpdateDisplayStatus <br> * <br> * Updates the disable timeout. Enables the ship if disable timeout has elapsed. <br> */ <br>void UpdateDisplayStatus(LPSHIP lpShip) <br>{ <br>    DWORD dwTickDiff; <br>    DWORD dwTickCount; <br> <br>    // current time <br>    dwTickCount = timeGetTime(); <br> <br>    // time elapsed since last update <br>    dwTickDiff =  dwTickCount - lpShip-&gt;dwLastTick; <br> <br>    // timestamp <br>    lpShip-&gt;dwLastTick = dwTickCount; <br> <br>    // update time-out <br>    lpShip-&gt;iCountDown -= dwTickDiff; <br> <br>    // time-out ? <br>if( lpShip-&gt;iCountDown &lt; 0 ) <br>{ <br>        // get new position and enable our lpShip <br>    lpShip-&gt;dPosX = randInt(0,MAX_SHIP_X); <br>    lpShip-&gt;dPosY = randInt(0,MAX_SHIP_Y); <br>    lpShip-&gt;cFrame = randInt(0, MAX_SHIP_FRAME); <br>lpShip-&gt;bEnable = TRUE; <br>} <br>} <br> <br>/* <br> * UpdatePosition <br> * <br> * Updates our ship's position <br> */ <br>void UpdatePosition(DPID dpId, LPSHIP lpShip ) <br>{ <br>    int     x,y; <br>    BYTE    oldxCell, oldyCell, newxCell, newyCell, mask, col, row; <br>    double  thisTick, totalTick, xtick, ytick; <br>    DWORD   dwTickCount; <br>    DWORD   dwTickDiff; <br> <br>    if( !lpShip-&gt;bEnable ) <br>        return; <br> <br>    // how long has it been since we last updated <br>    dwTickCount = timeGetTime(); <br>    dwTickDiff = dwTickCount - lpShip-&gt;dwLastTick; <br> <br>    // current timestamp <br>    lpShip-&gt;dwLastTick = dwTickCount; <br> <br>oldxCell = (int)(lpShip-&gt;dPosX+16.0) &gt;&gt; 4; <br>oldyCell = (int)(lpShip-&gt;dPosY+16.0) &gt;&gt; 4; <br> <br>    // compute new position <br>    lpShip-&gt;dPosX += lpShip-&gt;dVelX * dwTickDiff; <br>    lpShip-&gt;dPosY += lpShip-&gt;dVelY * dwTickDiff; <br> <br>newxCell = (int)(lpShip-&gt;dPosX+16.0) &gt;&gt; 4; <br>newyCell = (int)(lpShip-&gt;dPosY+16.0) &gt;&gt; 4; <br>if(oldxCell != newxCell) <br>{ <br>        // we allow ghosts to pass through the blocks <br>if( (dpId == gOurID) &amp;&amp; IsHit( newxCell, newyCell ) ) <br>{ <br>if( lpShip-&gt;dVelX &gt; 0.0 ) <br>lpShip-&gt;dPosX = (oldxCell &lt;&lt; 4) + 15 - 16; <br>else <br>lpShip-&gt;dPosX = (oldxCell &lt;&lt; 4) - 16; <br>lpShip-&gt;dVelX = -lpShip-&gt;dVelX*0.9; <br>newxCell = oldxCell; <br>            lpShip-&gt;bBounced = TRUE; <br>} <br>} <br>if(oldyCell != newyCell) <br>{ <br>        // we allow ghosts to pass through the blocks <br>if( (dpId == gOurID) &amp;&amp; IsHit( newxCell, newyCell ) ) <br>{ <br>if( lpShip-&gt;dVelY &gt; 0.0 ) <br>lpShip-&gt;dPosY = (oldyCell &lt;&lt; 4) + 15 - 16; <br>else <br>lpShip-&gt;dPosY = (oldyCell &lt;&lt; 4) - 16; <br> <br>            lpShip-&gt;dVelY = -lpShip-&gt;dVelY*0.9; <br>            lpShip-&gt;bBounced = TRUE; <br>    } <br>} <br> <br>    if( lpShip-&gt;dPosX &gt; MAX_SHIP_X ) <br>    { <br>        lpShip-&gt;dPosX = MAX_SHIP_X; <br>        lpShip-&gt;dVelX = -lpShip-&gt;dVelX*0.9; <br>        lpShip-&gt;bBounced = TRUE; <br>    } <br>    else if ( lpShip-&gt;dPosX &lt; 0 ) <br>    { <br>        lpShip-&gt;dPosX =0; <br>        lpShip-&gt;dVelX = -lpShip-&gt;dVelX*0.9; <br>        lpShip-&gt;bBounced = TRUE; <br>    } <br>    if( lpShip-&gt;dPosY &gt; MAX_SHIP_Y ) <br>    { <br>        lpShip-&gt;dPosY = MAX_SHIP_Y; <br>        lpShip-&gt;dVelY = -lpShip-&gt;dVelY*0.9; <br>        lpShip-&gt;bBounced = TRUE; <br>    } <br>    else if ( lpShip-&gt;dPosY &lt; 0 ) <br>    { <br>        lpShip-&gt;dPosY =0; <br>        lpShip-&gt;dVelY = -lpShip-&gt;dVelY*0.9; <br>        lpShip-&gt;bBounced = TRUE; <br>    }     <br> <br>    if ((dpId == gOurID) &amp;&amp; lpShip-&gt;bBounced) <br>    { <br>        SendSync(lpShip); <br>    } <br> <br>    if( !lpShip-&gt;bBulletEnable ) <br>        return; <br> <br>    // update the active bullet <br>    lpShip-&gt;dwBulletFrame += dwTickDiff; <br>    if( lpShip-&gt;dwBulletFrame &gt;= MAX_BULLET_FRAME ) <br>    { <br>        lpShip-&gt;bFiring = FALSE; <br>        lpShip-&gt;bBulletEnable = FALSE; <br>return; <br>    } <br> <br> <br>    if( lpShip-&gt;dBulletVelX != 0.0 ) <br>xtick = 8.0/lpShip-&gt;dBulletVelX; <br>    else <br>        xtick = 999999.0; <br> <br>    if( lpShip-&gt;dBulletVelY != 0.0 ) <br>ytick = 8.0/lpShip-&gt;dBulletVelY; <br>    else <br>        ytick = 999999.0; <br> <br>    if( xtick &lt; 0.0 ) <br>        xtick = -xtick; <br>    if( ytick &lt; 0.0 ) <br>        ytick = -ytick; <br> <br>    if( xtick &lt; ytick ) <br>        thisTick = xtick; <br>    else <br>        thisTick = ytick; <br> <br>    if( thisTick &gt; dwTickDiff ) <br>        thisTick = dwTickDiff; <br>         <br>    for( totalTick = 0.0; totalTick &lt; dwTickDiff; ) <br>    { <br>        totalTick += thisTick; <br> <br>        lpShip-&gt;dBulletPosX += lpShip-&gt;dBulletVelX * thisTick; <br>        lpShip-&gt;dBulletPosY += lpShip-&gt;dBulletVelY * thisTick; <br> <br>        if( lpShip-&gt;dBulletPosX &gt; MAX_BULLET_X ) <br>        { <br>            lpShip-&gt;dBulletPosX = MAX_BULLET_X; <br>            lpShip-&gt;dBulletVelX = -lpShip-&gt;dBulletVelX*0.9; <br>        } <br>        else if ( lpShip-&gt;dBulletPosX &lt; 0 ) <br>        { <br>            lpShip-&gt;dBulletPosX =0; <br>            lpShip-&gt;dBulletVelX = -lpShip-&gt;dBulletVelX*0.9; <br>        } <br>        if( lpShip-&gt;dBulletPosY &gt; MAX_BULLET_Y ) <br>        { <br>            lpShip-&gt;dBulletPosY = MAX_BULLET_Y; <br>            lpShip-&gt;dBulletVelY = -lpShip-&gt;dBulletVelY*0.9; <br>        } <br>        else if ( lpShip-&gt;dBulletPosY &lt; 0 ) <br>        { <br>            lpShip-&gt;dBulletPosY =0; <br>            lpShip-&gt;dBulletVelY = -lpShip-&gt;dBulletVelY*0.9; <br>        } <br>     <br>        // check to see if it hit anything <br>        x = (int)(lpShip-&gt;dBulletPosX + 0.5) + 1; <br>        y = (int)(lpShip-&gt;dBulletPosY + 0.5) + 1; <br> <br>        row = y &gt;&gt; 4; <br>        col = x &gt;&gt; 4; <br>        mask = 1 &lt;&lt; (col &amp; 0x7); <br>        col = col &gt;&gt; 3; <br>        if( gBlocks.bits[row][col] &amp; mask ) <br>        { <br>// dwScored a block hit <br>            gBlockHitMsg.byRow = row; <br>            gBlockHitMsg.byCol = col; <br>            gBlockHitMsg.byMask = mask; <br>SendGameMessage((LPGENERICMSG) &amp;gBlockHitMsg, DPID_ALLPLAYERS); <br> <br>gBlocks.bits[row][col] &amp;= ~mask; <br>lpShip-&gt;dwScore += 10; <br>lpShip-&gt;bBulletEnable = FALSE; <br>            lpShip-&gt;bBlockHit = TRUE; <br>            lpShip-&gt;bFiring   = FALSE; <br>        } <br>    } <br>} <br> <br> <br>/* <br> * IsHit <br> * <br> * Tells if there is a block at (x,y) location <br> */ <br>BOOL IsHit( int x, int y ) <br>{ <br>    int col, mask; <br>     <br>    // outside screen boundaries? <br>    if( (x &lt; 0) || (y &lt; 0) || (x &gt;= 40) || (y &gt;= 30) ) <br>        return TRUE; <br> <br>    // look at the block bits <br>    mask = 1 &lt;&lt; (x &amp; 0x7); <br>    col = x &gt;&gt; 3; <br>    if( gBlocks.bits[y][col] &amp; mask ) <br>        return TRUE; <br>    else <br>        return FALSE; <br>} <br> <br>/* <br> * InitField <br> * <br> * Initializes block positions on the field <br> */ <br>void InitField(void) <br>{ <br>    int i, x, y; <br>     <br>    // clear all gBlocks <br>    for(x=0; x&lt;5; x++) <br>        for(y=0; y&lt;30; y++) <br>    gBlocks.bits[y][x] = 0; <br> <br>    // set random gBlocks <br>    for(i=0; i&lt;400; i++) <br>    { <br>        x = randInt(0, 40); <br>y = randInt(0, 30); <br>if( !setBlock(x, y) ) i--; <br>    } <br>} <br> <br>/* <br> * AddBlock <br> * <br> * Adds a block to the field <br> */ <br>void AddBlock(void) <br>{ <br>int x,y; <br> <br>    // maybe add a block? <br>if(gbIsHost &amp;&amp; gbIsActive &amp;&amp; ( randInt( 0, 100 ) &gt; 98 )) <br>{ <br>x = randInt( 0, 40); <br>y = randInt( 0, 30); <br>if( setBlock( x, y) ) <br>{ <br>            gAddBlockMsg.byX    = (BYTE) x; <br>            gAddBlockMsg.byY    = (BYTE) y; <br>SendGameMessage((LPGENERICMSG) &amp;gAddBlockMsg, DPID_ALLPLAYERS); <br>} <br>} <br>} <br> <br>/* <br> * setBlock <br> * <br> * Turns on a block <br> */ <br>BOOL setBlock( int x, int y ) <br>{ <br>    BYTE  mask, col; <br> <br>    mask = 1 &lt;&lt; (x &amp; 0x7); <br>    col = x &gt;&gt; 3; <br>     <br>    // is Block already set? <br>    if( gBlocks.bits[y][col] &amp; mask ) <br>        return FALSE; <br> <br>    // set the block and return success <br>    gBlocks.bits[y][col] |= mask; <br>    return TRUE; <br>} <br> <br>/* <br> * AddFrag <br> * <br> * Turns on a fragment <br> */ <br>void AddFrag(LPSHIP lpShip, int offX, int offY) <br>{ <br>    int i; <br>    for(i=0; i&lt;64; i++) // find available fragment <br>    { <br>        if( !gFrags[i].valid ) <br>    break; <br>    } <br>    if( i == 64 ) <br>        return; <br> <br>     <br>    gFrags[i].dPosX = offX + lpShip-&gt;dPosX; <br>    gFrags[i].dPosY = offY + lpShip-&gt;dPosY; <br>    switch( lpShip-&gt;byType ) <br>    { <br>    case 0: gFrags[i].surf = glpShip0;    break; <br>    case 1: gFrags[i].surf = glpShip1;    break; <br>    case 2: gFrags[i].surf = glpShip2;    break; <br>    case 3: gFrags[i].surf = glpShip3;    break; <br>default: DEBUG_OUT(TEXT("Unknown ship type\n")); return; <br>    } <br>    gFrags[i].src.top = 32 * ( (int)lpShip-&gt;cFrame / 10 ) + offX; <br>    gFrags[i].src.left = 32 * ( (int)lpShip-&gt;cFrame % 10 ) + offY; <br>    gFrags[i].src.right = gFrags[i].src.left + 8; <br>    gFrags[i].src.bottom = gFrags[i].src.top + 8; <br>    gFrags[i].dVelX = ((double)offX - 12.0)/24.0; <br>    gFrags[i].dVelY = ((double)offY - 12.0)/24.0; <br>    gFrags[i].valid = TRUE; <br>} <br> <br>/* <br> * UpdateFragment <br> * <br> * Updates the position of a fragment <br> */ <br>void UpdateFragment(int i) <br>{ <br>    DWORD   dwTickCount; <br>    static DWORD   dwTickDiff; <br>    static DWORD dwLastTick; <br> <br>    if( i == 0) <br>    { <br>        dwTickCount = timeGetTime(); <br>        dwTickDiff = dwTickCount - dwLastTick; <br>        dwLastTick = dwTickCount; <br>    } <br>     <br>    if( !gFrags[i].valid ) <br>        return; <br> <br>    gFrags[i].dPosX += (int) (gFrags[i].dVelX * dwTickDiff); <br>    gFrags[i].dPosY += (int) (gFrags[i].dVelY * dwTickDiff); <br>    if( (gFrags[i].dPosX &lt; 0.0) || (gFrags[i].dPosX &gt;= 632.0) || <br>        (gFrags[i].dPosY &lt; 0.0) || (gFrags[i].dPosY &gt;= 472.0) ) <br>    { <br>        gFrags[i].valid = FALSE; <br>    } <br>} <br> <br>/* <br> * DestroyShip <br> * <br> * Renders a bunch of fragments to show that the ship is destroyed <br> */ <br>void DestroyShip( LPSHIP lpShip ) <br>{ <br>// Set flag for explosion sound <br>lpShip-&gt;bDeath  = TRUE; <br> <br>    // add ship fragments <br>    AddFrag(lpShip, 0, 0); <br>    AddFrag(lpShip, 8, 0); <br>    AddFrag(lpShip, 16, 0); <br>    AddFrag(lpShip, 24, 0); <br>    AddFrag(lpShip, 0, 8); <br>    AddFrag(lpShip, 8, 8); <br>    AddFrag(lpShip, 16, 8); <br>    AddFrag(lpShip, 24, 8); <br>    AddFrag(lpShip, 0, 16); <br>    AddFrag(lpShip, 8, 16); <br>    AddFrag(lpShip, 16, 16); <br>    AddFrag(lpShip, 24, 16); <br>    AddFrag(lpShip, 0, 24); <br>    AddFrag(lpShip, 8, 24); <br>    AddFrag(lpShip, 16, 24); <br>    AddFrag(lpShip, 24, 24); <br> <br>    // Play explosion sound <br>    ProcessSoundFlags(lpShip); <br>} <br> <br>/* <br> * UpdateFrame <br> * <br> * Refreshes the screen <br> */ <br>BOOL UpdateFrame( void ) <br>{ <br>    int i; <br>    DWORD dwTickCount; <br>    SHIP  ship; <br>    DWORD dwSize; <br>    HRESULT hr; <br>    static dwSyncLastTick = 0; <br>    static dwUpdateLastTick = 0; <br>     <br>    switch( gnProgramState ) <br>    { <br>    case PS_ACTIVE: <br>        // DINPUT: use DirectInput to read game-play keys <br>    DI_ReadKeys(); <br> <br>        // get our local data <br>        dwSize = sizeof(ship); <br>        hr = DPlayGetPlayerData(gOurID, &amp;ship, &amp;dwSize, DPGET_LOCAL); <br>        if (FAILED(hr)) <br>        { <br>            wsprintf(gDebugBuff, TEXT("Get Player local data failed for id %d\n"), gOurID); <br>            DEBUG_OUT(gDebugBuff); <br>            goto FAIL; <br>        } <br> <br>        if (!ship.bEnable) <br>        { <br>            // update disable timeout and display status <br>            UpdateDisplayStatus(&amp;ship); <br>        } <br>        else <br>        { <br>            // process any change in game controls  <br>            ProcessUserInput(&amp;ship); <br> <br>            dwTickCount = timeGetTime(); <br> <br>            // synchronize if it's time <br>            if (gbIsActive &amp;&amp; ((dwTickCount - dwSyncLastTick) &gt; SYNC_INTERVAL)) <br>            { <br>                SendSync(&amp;ship); <br>                dwSyncLastTick = dwTickCount; <br>            } <br> <br>            // if our player changed any keys, let everyone know <br>            if (gbUpdate) <br>            { <br>                // control the number of packets we send <br>                if ((dwTickCount - dwUpdateLastTick) &gt; UPDATE_INTERVAL) <br>                { <br>            // let others know <br>                    gControlMsg.byState = (BYTE) gdwKeys; <br>                    SendGameMessage((LPGENERICMSG) &amp;gControlMsg, DPID_ALLPLAYERS); <br>                    dwUpdateLastTick = dwTickCount; <br>                } <br>            } <br>        } <br> <br>    // save ship data as RenderPlayerCB reads stored data <br>    hr = DPlaySetPlayerData(gOurID, &amp;ship, sizeof(ship), DPSET_LOCAL); <br>        if (FAILED(hr)) <br>        { <br>            ShowError(IDS_DPLAY_ERROR_SPLD); <br>            goto FAIL; <br>        }    <br> <br>// update fragments <br>for(i=0; i&lt;64; i++) <br>UpdateFragment(i); <br> <br>    // add a block <br>        if (!gbNoField) <br>        AddBlock(); <br> <br>        // render everything <br>        if (!DrawScreen()) <br>        { <br>            goto FAIL; <br>        } <br>        break; <br> <br>    case PS_REST: <br>if( gbHaveHostInit ) <br>{ <br>SetGamePalette(); <br>gnProgramState = PS_ACTIVE; <br>} <br>break; <br>    } <br> <br>    // success <br>    return TRUE; <br> <br>FAIL: <br>    // failed <br>    return FALSE; <br>} <br> <br>/* <br> *FUNCTION:   ProcessSoundFlags <br> * <br> *PARAMETERS: <br> *    lpShip: Points to a ship structure (originally retrieved from <br> *            GetPlayerData) in RenderPlayer. <br> * <br> *NOTES:      All y-coordinates must be made negative, because the <br> *            3D Sound API's use an opposite coordinate system than <br> *            the screen. <br> */ <br>void ProcessSoundFlags(LPSHIP lpShip) <br>{ <br>    int i; <br>    BOOL bStart[MAX_SOUNDS]; //flags, used so we can  <br>    BOOL bStop [MAX_SOUNDS]; <br> <br>    if (!gbSoundInitialized) <br>{ <br>// clear bounce flag so we don't send a message every time through the loop <br>        lpShip-&gt;bBounced = FALSE; <br>        return; <br>} <br> <br>    //if one is NULL, so are the other ones and we aren't initialized yet. <br>    for (i=0; i&lt;MAX_SOUNDS; i++) </code></pre>
<p>
</p>
<pre><code>{ <br>        if (lpShip-&gt;lpDirectSoundBuffer[i]==NULL) <br>            return; <br>    } <br> <br>    //set all our temporary flags to FALSE. <br>    for (i=0; i&lt;MAX_SOUNDS; i++) <br>    { <br>        bStart[i] = FALSE; <br>        bStop[i]  = FALSE; <br>    } <br> <br>    if (lpShip-&gt;dwKeys &amp; KEY_ENGINEOFF) <br>        { <br>        bStop[SENGINE] = TRUE; <br>        lpShip-&gt;bEngineRunning = FALSE; <br>        } <br> <br>    if (lpShip-&gt;dwKeys &amp; (KEY_UP | KEY_DOWN)) <br>        { <br>        if (!lpShip-&gt;bEngineRunning) //turn on engine <br>            { <br>            bStart[SENGINE] = TRUE; <br>            if (!lpShip-&gt;bMoving)   //"fire-up-engine" sound <br>                { <br>                bStart[SSTART] = TRUE; <br>                IDirectSound3DBuffer_SetPosition(lpShip-&gt;lpDirectSound3DBuffer[SSTART], <br>                                                  P2M(lpShip-&gt;dPosX - 320), <br>                                                 -P2M(lpShip-&gt;dPosY - 240), <br>                                                 D3DVAL(0), <br>                                                 DS3D_DEFERRED); <br>                bStart[SSTART] = TRUE; <br>                lpShip-&gt;bMoving = TRUE; <br>                } <br>            lpShip-&gt;bEngineRunning = TRUE; <br>            } <br>        } <br> <br>    if (lpShip-&gt;bMoving) <br>        { <br>        IDirectSound3DBuffer_SetPosition(lpShip-&gt;lpDirectSound3DBuffer[SENGINE], <br>                                         P2M(lpShip-&gt;dPosX - 320), <br>                                        -P2M(lpShip-&gt;dPosY - 240), <br>                                        D3DVAL(0), <br>                                        DS3D_DEFERRED); <br>        IDirectSound3DBuffer_SetVelocity(lpShip-&gt;lpDirectSound3DBuffer[SENGINE], <br>                                         D3DVAL(lpShip-&gt;dVelX * 10), //exagerater vel <br>                                         -D3DVAL(lpShip-&gt;dVelY * 10), <br>                                         D3DVAL(0), <br>                                         DS3D_DEFERRED); <br>        } <br> <br>    if (lpShip-&gt;dwKeys &amp; KEY_STOP) <br>        { <br>        if (lpShip-&gt;bMoving) <br>            { <br>            IDirectSound3DBuffer_SetPosition(lpShip-&gt;lpDirectSound3DBuffer[SSTOP], <br>                                              P2M(lpShip-&gt;dPosX - 320), <br>                                             -P2M(lpShip-&gt;dPosY - 240), <br>                                             D3DVAL(0), <br>                                             DS3D_DEFERRED); <br>            bStart[SSTOP]   = TRUE; <br>            bStop[SENGINE]  = TRUE; <br>            lpShip-&gt;bEngineRunning  = FALSE; <br>            lpShip-&gt;bMoving         = FALSE; <br>            } <br>        } <br> <br>    if (lpShip-&gt;dwKeys &amp; KEY_FIRE) <br>        { <br>        if (!lpShip-&gt;bFiring) <br>            { <br>            IDirectSound3DBuffer_SetPosition(lpShip-&gt;lpDirectSound3DBuffer[BFIRE], <br>                                              P2M(lpShip-&gt;dPosX - 320), <br>                                             -P2M(lpShip-&gt;dPosY - 240), <br>                                             D3DVAL(0), <br>                                             DS3D_DEFERRED); <br>            bStart[BFIRE]   = TRUE; <br>            lpShip-&gt;bFiring = TRUE; <br>            } <br>        } <br> <br>    if (lpShip-&gt;bBlockHit) <br>        { <br>        IDirectSound3DBuffer_SetPosition(lpShip-&gt;lpDirectSound3DBuffer[LBOOM], <br> <br>                                          P2M(lpShip-&gt;dBulletPosX - 320), <br>                                         -P2M(lpShip-&gt;dBulletPosY - 240), <br>                                         D3DVAL(0), <br>                                         DS3D_DEFERRED); <br> <br>        bStart[LBOOM] = TRUE; <br>        lpShip-&gt;bBlockHit = FALSE; <br>        } <br> <br>    if (lpShip-&gt;bBounced) <br>        { <br>        IDirectSound3DBuffer_SetPosition(lpShip-&gt;lpDirectSound3DBuffer[SBOUNCE], <br>                                         P2M(lpShip-&gt;dPosX - 320), <br>                                         -P2M(lpShip-&gt;dPosY - 240), <br>                                         D3DVAL(0), <br>                                         DS3D_DEFERRED); <br> <br>        bStart[SBOUNCE] = TRUE; <br>        lpShip-&gt;bBounced = FALSE; <br>        } <br> <br> <br>    if (lpShip-&gt;bDeath) <br>        { <br>        bStop [BFIRE]   = TRUE; <br>        bStop [SBOUNCE] = TRUE; <br>        bStop [SSTOP]   = TRUE; <br>        bStop [SSTART]  = TRUE; <br>        bStop [SENGINE] = TRUE; <br>        bStart[SBOOM]   = TRUE;  <br>        lpShip-&gt;bDeath  = FALSE;  //turn off sound flag. <br>        } <br> <br>    //stop, update, and start sounds. <br>    for (i=0; i&lt;MAX_SOUNDS; i++) <br>        { <br>        if (bStop[i]) <br>            { <br>            IDirectSoundBuffer_Stop(lpShip-&gt;lpDirectSoundBuffer[i]); <br>            bStart[i] = FALSE; <br>            } <br>        } <br>    IDirectSound3DListener_CommitDeferredSettings(glpDirectSound3DListener); <br> <br>    for (i=0; i&lt;MAX_SOUNDS; i++) <br>        { <br>        if (bStart[i]) <br>            { <br>             IDirectSoundBuffer_SetCurrentPosition(lpShip-&gt;lpDirectSoundBuffer[i], 0); <br> <br>             if (DSERR_BUFFERLOST==IDirectSoundBuffer_Play(lpShip-&gt;lpDirectSoundBuffer[i], <br>                                                           0, <br>                                                           0, <br>                                                           (i==SENGINE) ? DSBPLAY_LOOPING : 0)) <br>                { <br>                WaveReload(gSoundEffect[i]); <br>                } <br>            } <br>        } <br>    lpShip-&gt;dwKeys = 0; <br>}; <br> <br> <br> <br> <br>/* <br> * RenderPlayerCB <br> * <br> * Renders a ship in its current state. Also checks if we hit the ship and informs <br> * the ship that it has been destroyed. <br>  */ <br> <br>BOOL WINAPI RenderPlayerCB(DPID dpId, DWORD dwPlayerType, LPCDPNAME lpName,  <br>DWORD dwFlags, LPVOID lpContext) <br>{ <br>    SHIP ship, ourShip; <br>    DWORD dwSize = sizeof(ship); <br>    BOOL bHit = FALSE; <br>    HRESULT hr; <br>    DWORD dwTickCount; <br>     <br>    // get ship data <br>    hr = DPlayGetPlayerData(dpId, &amp;ship, &amp;dwSize, DPGET_LOCAL); <br> <br>    if (FAILED(hr)) <br>    { <br>        wsprintf(gDebugBuff, TEXT("Get Player local data failed for id %d\n"), dpId); <br>        DEBUG_OUT(gDebugBuff); <br>        goto FAIL; <br>    } <br> <br>// no player data yet <br>if (0 == dwSize) <br>return TRUE;  <br> <br>    // ignore current ship ? <br>    if (ship.bIgnore) <br>    { <br>    // if this ship was being ignored, update ignore time-out <br>    // A time-out is used here to ensure that this ship doesn't get ignored <br>    // forever on our screen in case the destroy message was dropped. <br>        dwTickCount = timeGetTime(); <br>    ship.iCountDown -= dwTickCount - ship.dwLastTick; <br>        ship.dwLastTick = dwTickCount; <br>    if( ship.iCountDown &lt; 0 )  <br>{ <br>            ship.bIgnore = FALSE; <br>} <br> <br>        // save ship data <br>    hr = DPlaySetPlayerData(dpId, &amp;ship, sizeof(ship), DPSET_LOCAL); <br>        if (FAILED(hr)) <br>        { <br>wsprintf(gDebugBuff, TEXT("Set Player local data failed for id %d\n"), dpId); <br>DEBUG_OUT(gDebugBuff); <br>            goto FAIL; <br>        } <br>        // we are ignoring this ship, so just bail <br>        return TRUE; <br>    } <br> <br>    // bail, if ship is disabled <br>    if (!ship.bEnable) return TRUE; <br> <br>// update ship's position <br>UpdatePosition(dpId, &amp;ship); <br> <br>    // get our player data to compare with others <br>    dwSize = sizeof(ship); <br>    hr = DPlayGetPlayerData(gOurID, &amp;ourShip, &amp;dwSize, DPGET_LOCAL); <br>    if (FAILED(hr)) <br>    { <br>        wsprintf(gDebugBuff, TEXT("Get Player local data failed for id %d\n"), dpId); <br>        DEBUG_OUT(gDebugBuff); <br>        goto FAIL; <br>    } <br> <br>// check if our bullet hit the current ship <br>if((dpId != gOurID) &amp;&amp; ourShip.bBulletEnable &amp;&amp; ship.bEnable) <br>{ <br>if( (ourShip.dBulletPosX &gt; ship.dPosX) &amp;&amp; <br>(ourShip.dBulletPosX &lt; (ship.dPosX + 32.0) ) &amp;&amp; <br>(ourShip.dBulletPosY &gt; ship.dPosY) &amp;&amp; <br>(ourShip.dBulletPosY &lt; (ship.dPosY + 32.0) ) ) <br>{ <br>// hasta-la-vista baby <br>DestroyShip(&amp;ship); <br>            // we nailed it <br>            bHit = TRUE; <br>            // turn off ship locally <br>            ship.bEnable = FALSE; <br>// temporarily ignore ship until we get a response <br>ship.bIgnore = TRUE; <br>// set its ignore time-out <br>ship.iCountDown = HIDE_TIMEOUT; <br>            // time-stamp <br>            ship.dwLastTick = timeGetTime(); <br>// turn our bullet off <br>ship.bBulletEnable = FALSE; <br>// update our score <br>            ourShip.dwScore += 1000; <br>        // save our score <br>        hr = DPlaySetPlayerData(gOurID, &amp;ourShip, sizeof(ourShip), DPSET_LOCAL); <br>            if (FAILED(hr)) <br>            { <br>                ShowError(IDS_DPLAY_ERROR_SPLD); <br>                goto FAIL; <br>            } <br>} <br>} <br> <br>// render the ship <br>if (ship.bBulletEnable) DrawBullet(&amp;ship); <br>if (ship.bEnable)       DrawShip(&amp;ship); <br> <br>    ProcessSoundFlags(&amp;ship); <br> <br>// save ship data <br>hr = DPlaySetPlayerData(dpId, &amp;ship, sizeof(ship), DPSET_LOCAL); <br>    if (FAILED(hr)) <br>    { <br>wsprintf(gDebugBuff, TEXT("Set Player local data failed for id %d\n"), dpId); <br>DEBUG_OUT(gDebugBuff); <br>        goto FAIL; <br>    } <br> <br>// inform the player <br>    if (bHit) <br>    { <br>        gShipHitMsg.Id = dpId; <br>        SendGameMessage((LPGENERICMSG) &amp;gShipHitMsg, dpId); <br>    } <br> <br>    // success <br>    return TRUE; <br> <br>FAIL: <br>    // failed <br>    return FALSE; <br>} <br> <br>/* <br> * DrawScreen <br> *  <br> * Renders the current frame <br> */ <br>BOOL DrawScreen( void ) <br>{ <br>    BYTE    mask, col; <br>    int     x, y; <br>    HRESULT hr; <br> <br>// clear screen <br>    EraseScreen(); <br>     <br>// render players <br>    hr = DPlayEnumPlayers(NULL, RenderPlayerCB, NULL, 0); <br>    if (FAILED(hr)) <br>    { <br>        ShowError(IDS_DPLAY_ERROR_EP); <br>        goto FAIL; <br>    } <br> <br>// render field <br>    for( y=0; y&lt;30; y++) <br>    { <br>        for( x=0; x&lt;40; x++) <br>{ <br>mask = 1 &lt;&lt; (x &amp; 0x7); <br>col = x &gt;&gt; 3; <br>if( gBlocks.bits[y][col] &amp; mask ) <br>DrawBlock( x, y ); <br>} <br>    } <br>     <br>// render score <br>    if (!DrawScore()) <br>    { <br>        goto FAIL; <br>    } <br> <br>// render fragments <br>    DrawFragments();     <br> <br>// render frame rate <br>    if( gbShowFrameCount ) <br>        DisplayFrameRate(); <br> <br>// show <br>    FlipScreen(); <br> <br>    // success <br>    return TRUE; <br> <br>FAIL: <br>    return FALSE; <br>} <br> <br>/* <br> * DisplayFrameRate <br> *  <br> * Renders current frame rate <br> */ <br>void DisplayFrameRate( void ) <br>{ <br>    DWORDtime2; <br>    charbuff[256]; <br>static DWORDdwFrames; <br> <br>    gdwFrameCount++; <br>    time2 = timeGetTime() - gdwFrameTime; <br>    if( time2 &gt; 1000 ) <br>    { <br>        dwFrames = (gdwFrameCount*1000)/time2; <br>        gdwFrameTime = timeGetTime(); <br>        gdwFrameCount = 0; <br>    } <br>    if( dwFrames == 0 ) <br>    { <br>        return; <br>    } <br> <br>    if (dwFrames != gdwFramesLast) <br>    { <br>        gdwFramesLast = dwFrames; <br>    } <br> <br>    if( dwFrames &gt; 99 ) <br>    { <br>dwFrames = 99; <br>    } <br>    buff[0] = (char)((dwFrames / 10) + '0'); <br>    buff[1] = (char)((dwFrames % 10) + '0'); <br>    buff[2] = '\0'; <br>    bltScore(buff, 295, 10); <br>} <br> <br>/* <br> * DrawScore <br> * <br> * Renders our current score <br> */ <br>BOOL DrawScore( void ) <br>{ <br>    SHIP        ship; <br>    DWORD       dwSize; <br>    char        dwScorebuf[11]; <br>    int         rem; <br>    HRESULT     hr; <br> <br>    dwSize = sizeof(ship); <br>    hr = DPlayGetPlayerData(gOurID, &amp;ship, &amp;dwSize, DPGET_LOCAL); <br>    if (FAILED(hr)) <br>    { <br>        wsprintf(gDebugBuff, TEXT("Get Player local data failed for id %d\n"), gOurID); <br>        DEBUG_OUT(gDebugBuff); <br>        goto FAIL; <br>    } <br> <br>    // blt everything in reverse order if we are doing destination transparency <br>    // calculate dwScore string <br>    dwScorebuf[0] = (BYTE)ship.dwScore/100000 + '0'; <br>    rem = ship.dwScore % 100000; <br>    dwScorebuf[1] = rem/10000 + '0'; <br>    rem = ship.dwScore % 10000; <br>    dwScorebuf[2] = rem/1000 + '0'; <br>    rem = ship.dwScore % 1000; <br>    dwScorebuf[3] = rem/100 + '0'; <br>    rem = ship.dwScore % 100; <br>    dwScorebuf[4] = rem/10 + '0'; <br>    rem = ship.dwScore % 10; <br>    dwScorebuf[5] = rem + '0'; <br>    dwScorebuf[6] = '\0'; <br> <br>    bltScore(dwScorebuf, 8, 8); <br> <br>// save ship data <br>hr = DPlaySetPlayerData(gOurID, &amp;ship, sizeof(ship), DPSET_LOCAL); <br>    if (FAILED(hr)) <br>    { <br>        ShowError(IDS_DPLAY_ERROR_SPLD); <br>        goto FAIL; <br>    } <br> <br>    return TRUE; <br> <br>FAIL: <br>    // failed <br>    return FALSE; <br>} <br> <br>/* <br> * DrawBlock <br> * <br> * Renders a block <br> */ <br>void DrawBlock( int x, int y ) <br>{ <br>    RECT    src; <br>     <br>    src.top = 0; <br>    src.left = 224; <br>    src.right = src.left + 16; <br>    src.bottom = src.top + 16; <br>    bltObject( x &lt;&lt; 4, y &lt;&lt; 4, glpNum, &amp;src, DDBLTFAST_SRCCOLORKEY ); <br>} <br> <br>/* <br> * DrawShip <br> * <br> * Renders a ship <br> */ <br>void DrawShip( LPSHIP lpShip ) <br>{ <br>    RECT    src; <br>    LPDIRECTDRAWSURFACE surf; <br> <br>    src.top = 32 * (lpShip-&gt;cFrame / 10 ); <br>    src.left = 32 * (lpShip-&gt;cFrame % 10 ); <br>    src.right = src.left + 32; <br>    src.bottom = src.top + 32; <br>    switch( lpShip-&gt;byType ) <br>    { <br>    case 0: surf = glpShip0; break; <br>    case 1: surf = glpShip1; break; <br>    case 2: surf = glpShip2; break; <br>    case 3: surf = glpShip3; break; <br>    default: DEBUG_OUT(TEXT("Ship type not specified\n")); return; <br>    } <br>    bltObject((int)lpShip-&gt;dPosX, (int)lpShip-&gt;dPosY, surf, &amp;src, DDBLTFAST_SRCCOLORKEY ); <br>} <br> <br>/* <br> * DrawBullet <br> * <br> * Renders a bullet  <br> */ <br>void DrawBullet( LPSHIP lpShip ) <br>{ <br>    RECT    src; <br>     <br>    src.top = BULLET_Y; <br>    src.left = BULLET_X + (lpShip-&gt;byType)*4; <br>    src.right = src.left + 3; <br>    src.bottom = src.top + 3; <br>    bltObject((int)lpShip-&gt;dBulletPosX, (int)lpShip-&gt;dBulletPosY, glpNum, &amp;src, DDBLTFAST_SRCCOLORKEY ); <br>} <br> <br>/* <br> * DrawFragments <br> * <br> * Renders the fragments <br> */ <br> <br>void DrawFragments( void ) <br>{ <br>    int     i; <br>     <br>    for(i=0; i&lt;64; i++) <br>    { <br>if( gFrags[i].valid ) <br>{ <br>bltObject((int)gFrags[i].dPosX, (int)gFrags[i].dPosY, gFrags[i].surf, <br>&amp;(gFrags[i].src), DDBLTFAST_SRCCOLORKEY ); <br>} <br>    } <br>} <br> <br>/* <br> * ReceiveGameMessages <br> * <br> * Checks if there are any messages for us and receives them <br> */ <br>HRESULT ReceiveMessages( void ) <br>{ <br>DPIDidFrom, idTo; <br>LPVOIDlpvMsgBuffer; <br>DWORDdwMsgBufferSize; <br>HRESULThr; <br> <br>// read all messages in queue <br>dwMsgBufferSize = gdwReceiveBufferSize; <br>lpvMsgBuffer = glpvReceiveBuffer; <br> <br>while (TRUE) <br>{ <br>// see what's out there <br>idFrom = 0; <br>idTo = 0; <br> <br>hr = DPlayReceive(&amp;idFrom, &amp;idTo, DPRECEIVE_ALL, lpvMsgBuffer, &amp;dwMsgBufferSize); <br>if (hr == DPERR_BUFFERTOOSMALL) <br>{ <br>if (lpvMsgBuffer == NULL) <br>{ <br>lpvMsgBuffer = GlobalAllocPtr(GHND, dwMsgBufferSize); <br>if (lpvMsgBuffer == NULL) <br>return (DPERR_NOMEMORY); <br>glpvReceiveBuffer = lpvMsgBuffer; <br>gdwReceiveBufferSize = dwMsgBufferSize; <br>} <br>else if (dwMsgBufferSize &gt; gdwReceiveBufferSize) <br>{ <br>lpvMsgBuffer = GlobalReAllocPtr(lpvMsgBuffer, dwMsgBufferSize, 0); <br>if (lpvMsgBuffer == NULL) <br>return (DPERR_NOMEMORY); <br>glpvReceiveBuffer = lpvMsgBuffer; <br>gdwReceiveBufferSize = dwMsgBufferSize; <br>} <br>} <br>else if ((hr == DP_OK) &amp;&amp;  <br>                 ((dwMsgBufferSize &gt;= sizeof(GENERICMSG)) ||  <br>                  (dwMsgBufferSize &gt;= sizeof(DPMSG_GENERIC)))) <br>{ <br>if (idFrom == DPID_SYSMSG) <br>            { <br>DoSystemMessage((LPDPMSG_GENERIC) lpvMsgBuffer, dwMsgBufferSize, idFrom, idTo); <br>            } <br>else <br>            { <br>DoApplicationMessage((LPGENERICMSG) lpvMsgBuffer, dwMsgBufferSize, idFrom, idTo); <br>            } <br>} <br>else <br>break; <br>}; <br> <br>    return hr; <br>} <br> <br>/* <br> * DoSystemMessage <br> * <br> * Evaluates system messages and performs appropriate actions <br> */ <br>void DoSystemMessage( LPDPMSG_GENERIC lpMsg, DWORD dwMsgSize, DPID idFrom, DPID idTo ) <br>{ <br>    switch( lpMsg-&gt;dwType) <br>    { <br>    case DPSYS_CREATEPLAYERORGROUP: <br>        { <br>        LPDPMSG_CREATEPLAYERORGROUP lpAddMsg = (LPDPMSG_CREATEPLAYERORGROUP) lpMsg; <br> <br>            if( gbIsHost) <br>    { <br>                gHostMsg.Blocks = gBlocks; <br>    SendGameMessage((LPGENERICMSG) &amp;gHostMsg, lpAddMsg-&gt;dpId); <br>    } <br>        } <br>break; <br> <br>    case DPSYS_DESTROYPLAYERORGROUP: <br>        { <br>            LPSHIP lpShip; <br>        LPDPMSG_DESTROYPLAYERORGROUP lpDestroyMsg = (LPDPMSG_DESTROYPLAYERORGROUP) lpMsg; <br> <br>            if ((sizeof(SHIP) != lpDestroyMsg-&gt;dwLocalDataSize) ||  <br>                (NULL == lpDestroyMsg-&gt;lpLocalData)) <br>                break; <br> <br>            lpShip = lpDestroyMsg-&gt;lpLocalData; <br>            ReleasePlayerLocalSoundData(lpShip); <br>        } <br>break; <br> <br>case DPSYS_HOST: <br>        {     <br>            gbIsHost = TRUE;             <br>UpdateTitle(); <br>        } <br> <br>break; <br> <br>    case DPSYS_SESSIONLOST: <br>        // inform user that session was lost <br>        ShowError(IDS_DPLAY_ERROR_SL); <br>        gbSessionLost = TRUE; <br>        break; <br>    } <br>} <br> <br>/* <br> * DoApplicationMessage <br> * <br> * Evaluates an application message and performs appropriate actions <br> */ <br>void DoApplicationMessage( LPGENERICMSG lpMsg, DWORD dwMsgSize, DPID idFrom, DPID idTo ) <br>{         <br>    HRESULT hr; <br> <br>    switch( lpMsg-&gt;byType ) <br>    { <br>    case MSG_HOST: <br>{ <br>LPHOSTMSG       lpHost; <br> <br>if( !gbIsHost ) <br>{ <br>lpHost = (LPHOSTMSG) lpMsg; <br>                // receive the field layout <br>gBlocks = lpHost-&gt;Blocks; <br> <br>                // have host initializtion at this point <br>gbHaveHostInit = TRUE; <br>                 <br>                // start updating screen <br>                gbIsActive = TRUE; <br>} <br>} <br>break; <br> <br>    case MSG_BLOCKHIT: <br>{ <br>LPBLOCKHITMSG   lpBlockHit; <br> <br>lpBlockHit = (LPBLOCKHITMSG) lpMsg; <br>gBlocks.bits[lpBlockHit-&gt;byRow][lpBlockHit-&gt;byCol] &amp;= ~lpBlockHit-&gt;byMask; <br>} <br>break; <br> <br>    case MSG_ADDBLOCK: <br>{ <br>LPADDBLOCKMSG   lpAddBlock; <br> <br>lpAddBlock = (LPADDBLOCKMSG) lpMsg; <br>setBlock( lpAddBlock-&gt;byX, lpAddBlock-&gt;byY); <br>} <br>break; <br> <br>    case MSG_SHIPHIT: <br>        { <br>    LPSHIPHITMSG    lpShipHit = (LPSHIPHITMSG) lpMsg; <br>            SHIP ship; <br>            DWORD dwSize; <br> <br>            dwSize = sizeof(SHIP); <br> // get player local data <br>hr = DPlayGetPlayerData(lpShipHit-&gt;Id, &amp;ship, &amp;dwSize, DPGET_LOCAL); <br>            if (FAILED(hr)) <br>                return; <br> <br>// no player data yet <br>if (0 == dwSize) <br>return; <br> <br>if (!ship.bIgnore)  <br>            { <br>// explode the ship on our screen <br>DestroyShip(&amp;ship); <br> <br>    // turn it off <br>ship.bEnable = FALSE; <br>ship.bBulletEnable = FALSE; <br> <br>// if it is us <br>if (lpShipHit-&gt;Id == gOurID) <br>{ <br>                    // set our hide time-out <br>    ship.iCountDown = HIDE_TIMEOUT; <br>                    ship.dwLastTick = timeGetTime(); <br>                    // let the world know that we are dead <br>                    gShipHitMsg.Id = gOurID; <br>SendGameMessage((LPGENERICMSG) &amp;gShipHitMsg, DPID_ALLPLAYERS); <br>} <br>} <br>            // update player local data <br>  DPlaySetPlayerData(lpShipHit-&gt;Id, &amp;ship, sizeof(ship), DPSET_LOCAL); <br>        } <br>break; <br> <br>    case MSG_CONTROL: <br>        { <br>            LPCONTROLMSG lpControlMsg; <br>            SHIP ship; <br>            DWORD dwSize; <br> <br>            lpControlMsg = (LPCONTROLMSG) lpMsg; <br>            dwSize = sizeof(SHIP); <br>// get player local data <br>hr = DPlayGetPlayerData(idFrom, &amp;ship, &amp;dwSize, DPGET_LOCAL); <br>            if (FAILED(hr)) <br>                return; <br> <br>// no player data yet <br>if (0 == dwSize) <br>return; <br> <br>            // update its State <br>            UpdateState(&amp;ship, (DWORD)lpControlMsg-&gt;byState); <br> <br>            // save it back <br>   DPlaySetPlayerData(idFrom, &amp;ship, dwSize, DPSET_LOCAL); <br>        } <br>        break; <br> <br>    case MSG_SYNC: <br>        { <br>            LPSYNCMSG lpSyncMsg; <br>            SHIP ship; <br>            DWORD dwSize; <br> <br>            lpSyncMsg = (LPSYNCMSG) lpMsg; <br>            dwSize = sizeof(SHIP); <br>// get player local data <br>hr = DPlayGetPlayerData(idFrom, &amp;ship, &amp;dwSize, DPGET_LOCAL); <br>            if (FAILED(hr)) <br>                return; <br> <br>// we are seeing this player for the first time <br>// so do the initialization <br>if (0 == dwSize) <br>{ <br>ZeroMemory(&amp;ship, sizeof(ship)); <br> <br>// initialize sound buffers (this should never be us)                      <br>                if(gOurID == idFrom)  <br>                { <br>                    MessageBox (NULL, "gOurID == idFrom", "Ack!!!", MB_ICONEXCLAMATION | MB_OK | MB_TASKMODAL); <br>                    _asm int 3 <br>                } <br>InitPlayerLocalSoundData(&amp;ship, FALSE); <br> <br>ship.byType = lpSyncMsg-&gt;byShipType; <br>                ship.dPosX = lpSyncMsg-&gt;dPosX; <br>                ship.dPosY = lpSyncMsg-&gt;dPosY; <br>                ship.cFrame = lpSyncMsg-&gt;cFrame; <br>                ship.dwLastTick = timeGetTime(); <br>                ship.bEnable = TRUE; <br>} <br> <br>if (ship.bEnable) <br>            { <br>                // head towards rendezvous location (accelerate/decelerate as necessary) <br>                ship.dVelX = (lpSyncMsg-&gt;dPosX - ship.dPosX)/1000; <br>                ship.dVelY = (lpSyncMsg-&gt;dPosY - ship.dPosY)/1000; <br>                ship.cFrame = lpSyncMsg-&gt;cFrame; <br>            } <br>            else if (!ship.bIgnore) <br>            // Ship is alive, but we just don't know it. <br>// So, display it at the rendezvous location. <br>            { <br>                ship.dPosX = lpSyncMsg-&gt;dPosX; <br>                ship.dPosY = lpSyncMsg-&gt;dPosY; <br>                ship.cFrame = lpSyncMsg-&gt;cFrame; <br>                ship.dwLastTick = timeGetTime(); <br>                ship.bEnable = TRUE; <br>            } <br> <br>            // save it back <br>   DPlaySetPlayerData(idFrom, &amp;ship, sizeof(ship), DPSET_LOCAL); <br>        } <br>        break; <br> <br>    default: <br>{ <br>            wsprintf(gDebugBuff, TEXT("Unknown message type %d\n"), lpMsg-&gt;byType); <br>DEBUG_OUT( gDebugBuff ); <br>} <br>break; <br>    } <br>} <br> <br>/* <br> * SendGameMessage <br> * <br> * Sends a message to specified player(s) <br> */ <br>void SendGameMessage( LPGENERICMSG lpMsg, DPID idTo ) <br>{ <br>    int             nBytes; <br>DWORDdwFlags = 0; <br> <br>    if (gbSessionLost) <br>    { <br>        // no sends when we are not in the session <br>        return; <br>    } <br> <br>    switch( lpMsg-&gt;byType ) <br>    { <br>    case MSG_HOST: <br>        nBytes = sizeof( HOSTMSG ); <br>dwFlags = DPSEND_GUARANTEED; <br>break; <br> <br>    case MSG_BLOCKHIT: <br>nBytes = sizeof( BLOCKHITMSG ); <br>break; <br> <br>    case MSG_SHIPHIT: <br>nBytes = sizeof( SHIPHITMSG ); <br>break; <br> <br>    case MSG_ADDBLOCK: <br>nBytes = sizeof( ADDBLOCKMSG ); <br>break; <br> <br>    case MSG_CONTROL: <br>nBytes = sizeof( CONTROLMSG ); <br>        break; <br> <br>    case MSG_SYNC: <br>nBytes = sizeof( SYNCMSG ); <br>        break; <br> <br>    default: <br>        return; <br>} <br> <br>    if (gbReliable) <br>    { <br>    dwFlags = DPSEND_GUARANTEED; <br>    } <br> <br>// Send the message to the relevant player(s) <br>DPlaySend(gOurID, idTo, dwFlags, (LPVOID)lpMsg, nBytes); <br>} <br> <br>/* <br> * CleanupComm <br> * <br> * Cleans up communication stuff <br> */ <br>void CleanupComm(void) <br>{ <br>HRESULT hr; <br> <br>//free up all the local sound buffers <br>    ReleaseLocalData(); <br> <br>    // free the receive buffer <br>    if (glpvReceiveBuffer) <br>{ <br>    GlobalFreePtr(glpvReceiveBuffer); <br>glpvReceiveBuffer = NULL; <br>} <br> <br>    // delete our player <br>    if( gOurID )  <br>    { <br>        hr = DPlayDestroyPlayer(gOurID); <br>        if (FAILED(hr)) <br>        { <br>            ShowError(IDS_DPLAY_ERROR_DP); <br>        } <br>gOurID = 0; <br>    } <br> <br>// cleanup directplay objects <br>hr = DPlayClose(); <br>hr = DPlayRelease(); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
