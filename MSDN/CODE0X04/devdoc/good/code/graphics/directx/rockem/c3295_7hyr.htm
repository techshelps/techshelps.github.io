<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>RM.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3303"></a>RM.CPP</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1995-1997 Microsoft Corporation. All Rights Reserved. <br> * <br> *  File: rm.cpp <br> * <br> ***************************************************************************/ <br> <br>// Includes.... <br>#include "rm.h" <br>#include "directx.h" <br>#include "mmsystem.h" <br>#include "stdio.h" <br>#include "control.h" <br> <br>// Globals.... <br>LPDIRECT3DRMFRAMEg_lpScene = NULL;// Scene frame <br>LPDIRECT3DRMFRAMEg_lpCamera = NULL;// Camera frame <br>LPDIRECT3DRMFRAMEg_lpArena = NULL;// Arena frame <br>LPDIRECT3DRMFRAMEg_lpBackground = NULL;// Background frame <br> <br>LPDIRECT3DRMFRAMEg_lpPlayers = NULL;// Encapsulating frame <br>LPDIRECT3DRMFRAMEg_lpPlayer1 = NULL;// Human player <br>LPDIRECT3DRMFRAMEg_lpPlayer1HeadFrame = NULL;// Human player head frame <br>LPDIRECT3DRMANIMATIONSETg_lpPlayer1AnimSet = NULL;// Human player animation set <br>LPDIRECT3DRMFRAMEg_lpPlayer2 = NULL;// Computer player <br>LPDIRECT3DRMFRAMEg_lpPlayer2HeadFrame = NULL;// Computer player head frame <br>LPDIRECT3DRMANIMATIONSETg_lpPlayer2AnimSet = NULL;// Computer player animation set <br> <br>LPDIRECT3DRMFRAMEg_lpTmp = NULL;// Temporary frame <br> <br>LPDIRECT3DRMLIGHTg_lpDir;// Global light frame <br> <br>LPDIRECT3DRMMESHBUILDERg_lpRedDebris = NULL;// Red debris model <br>LPDIRECT3DRMMESHBUILDERg_lpBlueDebris = NULL;// Blue debris model <br>Debrisg_debris[NUM_DEBRIS];// Debris <br> <br>LPDIRECT3DRMANIMATIONg_lpAnim = NULL;// Intro anim <br> <br>// Timing stuff <br>D3DVALUEg_timingDelta = D3DVAL(0.0f); <br> <br>// Frame rate stuff <br>DWORDg_dwLastTime = 0; <br>DWORDg_dwCurTime = 0; <br>DWORDg_dwFpsTime = 0; <br>DWORDg_dwDeltaTime = 0; <br>DWORDg_dwFramesRendered = 0; <br>DWORDg_dwFps = 0; <br> <br>// Externals.... <br>extern BOOLg_bShowStats;// Defined in WINMAIN.CPP <br>extern BOOLg_bHardware3D;// Defined in DIRECTX.CPP <br>extern LPDIRECT3DRMg_lpD3DRM;// Defined in DIRECTX.CPP <br>extern LPDIRECT3DRMVIEWPORTg_lpD3DRMViewport;// Defined in DIRECTX.CPP <br>extern LPDIRECT3DRMDEVICEg_lpD3DRMDevice;// Defined in DIRECTX.CPP <br>extern LPDIRECTDRAWSURFACEg_lpPrimary;// Defined in DIRECTX.CPP <br>extern LPDIRECTDRAWSURFACEg_lpBackBuffer;// Defined in DIRECTX.CPP <br>extern LPDIRECTDRAWSURFACEg_lpZBuffer;// Defined in DIRECTX.CPP <br>extern DWORDg_vidModeX;// Defined in DIRECTX.CPP <br>extern DWORDg_vidModeY;// Defined in DIRECTX.CPP <br>extern DWORDg_vidModeBIT;// Defined in DIRECTX.CPP <br>extern DWORDg_dwFontHeight;// Defined in DIRECTX.CPP <br>extern DWORDg_dwAveCharWidth;// Defined in DIRECTX.CPP <br> <br>extern DWORDg_player1health;// Defined in CONTROL.CPP <br>extern DWORDg_player2health;// Defined in CONTROL.CPP <br> <br>extern DWORDg_lbar1;// Defined in DIRECTX.CPP <br>extern DWORDg_wbar1;// Defined in DIRECTX.CPP <br>extern DWORDg_lbar2;// Defined in DIRECTX.CPP <br>extern DWORDg_wbar2;// Defined in DIRECTX.CPP <br>extern DWORDg_hbar1;// Defined in DIRECTX.CPP <br>extern DWORDg_hbar2;// Defined in DIRECTX.CPP <br> <br>extern AnimArgsg_player1AnimArgs; <br>extern AnimArgsg_player2AnimArgs; <br> <br>//---------------------------------------------------------------------- <br>//  <br>// Function: InitScene <br>// <br>// Purpose: Initialises Direct3D RM objects and loads scene for demo <br>// <br>//---------------------------------------------------------------------- <br> <br>BOOL InitScene() <br>{ <br>    LPDIRECT3DRMLIGHTpAmb; <br>    LPDIRECT3DRMFRAMEpLight; <br>    LPDIRECT3DRMMESHBUILDER pMeshBuilder; <br> <br>    // Create the scene (parent) frame <br>    TRY_D3DRM(g_lpD3DRM-&gt;CreateFrame(NULL, &amp;g_lpScene)) <br> <br>    // Create the camera (child of g_lpScene) <br>    TRY_D3DRM(g_lpD3DRM-&gt;CreateFrame(g_lpScene, &amp;g_lpCamera)) <br> <br>    // Create the arena frame <br>    TRY_D3DRM(g_lpD3DRM-&gt;CreateFrame(g_lpScene, &amp;g_lpArena)) <br> <br>    // Create the frame that encapsulates both players <br>    TRY_D3DRM(g_lpD3DRM-&gt;CreateFrame(g_lpScene, &amp;g_lpPlayers)) <br>     <br>    // Create player frames <br>    TRY_D3DRM(g_lpD3DRM-&gt;CreateFrame(g_lpPlayers, &amp;g_lpPlayer1)) <br> <br>    TRY_D3DRM(g_lpD3DRM-&gt;CreateFrame(g_lpPlayers, &amp;g_lpPlayer2)) <br>     <br>    // Create temporary frame <br>    TRY_D3DRM(g_lpD3DRM-&gt;CreateFrame(g_lpScene, &amp;g_lpTmp)) <br>     <br>    // Create lights and position in world <br>    TRY_D3DRM(g_lpD3DRM-&gt;CreateLightRGB(D3DRMLIGHT_AMBIENT, D3DVAL(0.2), D3DVAL(0.2), D3DVAL(0.2), &amp;pAmb)) <br>     <br>    TRY_D3DRM(g_lpD3DRM-&gt;CreateLightRGB(D3DRMLIGHT_DIRECTIONAL, D3DVAL(0.7), D3DVAL(0.7), D3DVAL(0.7), &amp;g_lpDir)) <br> <br>    // Create ambient light frame <br>    TRY_D3DRM(g_lpD3DRM-&gt;CreateFrame(g_lpScene, &amp;pLight)) <br>     <br>    // Add the light to the frame <br>    TRY_D3DRM(pLight-&gt;AddLight(pAmb)) <br>     <br>    // Release the light frame <br>    pLight-&gt;Release(); <br> <br>    // Create directional light frame <br>    TRY_D3DRM(g_lpD3DRM-&gt;CreateFrame(g_lpScene, &amp;pLight)) <br>     <br>    // Set position and orientation of directional light <br>    pLight-&gt;SetPosition(g_lpScene, D3DVAL(1000), D3DVAL(1000), D3DVAL(1000)); <br>    pLight-&gt;SetOrientation(g_lpScene, D3DVAL(-1.0), D3DVAL(-1.0), D3DVAL(1.0), D3DVAL(0.0), D3DVAL(1.0), D3DVAL(0.0)); <br>     <br>    // Add the light to the frame <br>    TRY_D3DRM(pLight-&gt;AddLight(g_lpDir)) <br>     <br>    // Enable lights only for any object that is a child of g_lpPlayers <br>    TRY_D3DRM(g_lpDir-&gt;SetEnableFrame(g_lpPlayers)) <br> <br>    // Release the light frame <br>    pLight-&gt;Release(); <br> <br>    // Create mesh builder for arena <br>    TRY_D3DRM(g_lpD3DRM-&gt;CreateMeshBuilder(&amp;pMeshBuilder)) <br>     <br>    // Load the arena <br>    TRY_D3DRM(pMeshBuilder-&gt;Load("ARENA.X", NULL, D3DRMLOAD_FROMFILE, LoadTextures, NULL)) <br>     <br>    // Make sure we use perspective correct! <br>    pMeshBuilder-&gt;SetPerspective(TRUE); <br>     <br>    // Add the mesh to the scene <br>    TRY_D3DRM(g_lpArena-&gt;AddVisual(pMeshBuilder)) <br>     <br>    g_lpArena-&gt;SetZbufferMode(D3DRMZBUFFER_DISABLE); <br> <br>    // Release the mesh builder <br>    pMeshBuilder-&gt;Release(); <br> <br>    // Load player 1's model <br>    TRY_D3DRM(g_lpD3DRM-&gt;CreateAnimationSet(&amp;g_lpPlayer1AnimSet)) <br> <br>    // Load the model and animation <br>    TRY_D3DRM(g_lpPlayer1AnimSet-&gt;Load("SKMECH.X", NULL, D3DRMLOAD_FROMFILE, LoadTextures, NULL, g_lpPlayer1)) <br> <br>    // Add animation callback for player 1 <br>    g_player1AnimArgs.lpAnimSet = g_lpPlayer1AnimSet; <br>    g_player1AnimArgs.time= D3DVAL(0); <br>    TRY_D3DRM(g_lpPlayer1-&gt;AddMoveCallback(Player1AnimationCallback, NULL)) <br> <br>    // Setup the initial position of player 1 <br>    g_lpPlayer1-&gt;SetPosition(g_lpScene, D3DVAL(0), D3DVAL(0), D3DVAL(-200)); <br> <br>    // Load player 2's model <br>    TRY_D3DRM(g_lpD3DRM-&gt;CreateAnimationSet(&amp;g_lpPlayer2AnimSet)) <br> <br>    // Load the model and animation <br>    TRY_D3DRM(g_lpPlayer2AnimSet-&gt;Load("DEMECH.X", NULL, D3DRMLOAD_FROMFILE, LoadTextures, NULL, g_lpPlayer2)) <br>     <br>    // Add animation callback for player 2 <br>    g_player2AnimArgs.lpAnimSet = g_lpPlayer2AnimSet; <br>    g_player2AnimArgs.time= D3DVAL(0); <br>    TRY_D3DRM(g_lpPlayer2-&gt;AddMoveCallback(Player2AnimationCallback, NULL)) <br> <br>    for (int i = 0; i &lt; NUM_DEBRIS; i ++) <br>    { <br>TRY_D3DRM(g_lpD3DRM-&gt;CreateFrame(g_lpPlayers, &amp;g_debris[i].m_pFrame)) <br> <br>g_debris[i].m_bInUse = FALSE; <br>    } <br> <br>    // Load the red debris <br>    TRY_D3DRM(g_lpD3DRM-&gt;CreateMeshBuilder(&amp;g_lpRedDebris)) <br> <br>    TRY_D3DRM(g_lpRedDebris-&gt;Load("debris_r.x", NULL, D3DRMLOAD_FROMFILE, NULL, NULL)) <br>     <br>    // Load the blue debris <br>    TRY_D3DRM(g_lpD3DRM-&gt;CreateMeshBuilder(&amp;g_lpBlueDebris)) <br> <br>    TRY_D3DRM(g_lpBlueDebris-&gt;Load("debris_b.x", NULL, D3DRMLOAD_FROMFILE, NULL, NULL)) <br> <br>    // Setup the initial position of player 2 <br>    g_lpPlayer2-&gt;SetPosition(g_lpScene, D3DVAL(0), D3DVAL(0), D3DVAL(200)); <br> <br>    // Create the intro path <br>    TRY_D3DRM(g_lpD3DRM-&gt;CreateAnimation(&amp;g_lpAnim)) <br> <br>    // Setup the animation options <br>    g_lpAnim-&gt;SetOptions(D3DRMANIMATION_OPEN |  <br> D3DRMANIMATION_LINEARPOSITION |  <br> D3DRMANIMATION_POSITION); <br>     <br>    // Add the starting position (as a keyframe) <br>    g_lpAnim-&gt;AddPositionKey(D3DVAL(0), D3DVAL(200), D3DVAL(2000), D3DVAL(0)); <br>     <br>    // Add the ending position (as a keyframe) <br>    g_lpAnim-&gt;AddPositionKey(D3DVAL(1), D3DVAL(700), D3DVAL(100), D3DVAL(0)); <br>     <br>    // Make the camera follow this animation <br>    g_lpAnim-&gt;SetFrame(g_lpCamera); <br> <br>    // Retrieve player 1 and player 2's head frames <br>    LPDIRECT3DRMOBJECT tmp; <br>     <br>    TRY_D3DRM(g_lpD3DRM-&gt;GetNamedObject("x3ds_Head", &amp;tmp)) <br>    g_lpPlayer1HeadFrame = (LPDIRECT3DRMFRAME)tmp; <br> <br>    TRY_D3DRM(g_lpD3DRM-&gt;GetNamedObject("x3ds_xHead", &amp;tmp)) <br>    g_lpPlayer2HeadFrame = (LPDIRECT3DRMFRAME)tmp; <br> <br>    // Yahoo! <br>    return TRUE; <br>} <br> <br>//---------------------------------------------------------------------- <br>//  <br>// Function: TermScene <br>// <br>// Purpose: Destroys scene <br>// <br>//---------------------------------------------------------------------- <br> <br>void TermScene() <br>{ <br>    // Destroy the scene frame <br>    if (g_lpScene) <br>    { <br>g_lpScene-&gt;Release(); <br>g_lpScene = NULL; <br>    } <br> <br>    // Destroy the animation sets <br>    if (g_lpPlayer1AnimSet) <br>    { <br>g_lpPlayer1AnimSet-&gt;Release(); <br>g_lpPlayer1AnimSet = NULL; <br>    } <br> <br>    if (g_lpPlayer2AnimSet) <br>    { <br>g_lpPlayer2AnimSet-&gt;Release(); <br>g_lpPlayer2AnimSet = NULL; <br>    } <br>} <br> <br>//---------------------------------------------------------------------- <br>//  <br>// Function: RenderScene <br>// <br>// Purpose: Renders scene <br>// <br>//---------------------------------------------------------------------- <br> <br>BOOL RenderScene() <br>{ <br>    static BOOL b = FALSE; <br> <br>    // Verify both surfaces <br>    if (!g_lpPrimary) return FALSE; <br> <br>    if (!g_lpZBuffer) return FALSE; <br> <br>    // Perform some timing stuff <br>    g_dwCurTime  = timeGetTime(); <br>    g_dwDeltaTime = g_dwCurTime - g_dwLastTime; <br>    g_dwLastTime  = g_dwCurTime; <br>    g_dwFpsTime  += g_dwDeltaTime; <br> <br>    // Move the scene <br>    g_lpScene-&gt;Move(D3DVAL(g_dwDeltaTime)); <br> <br>    if (b) { <br>b = FALSE; <br>TRY_D3DRM(g_lpD3DRMViewport-&gt;ForceUpdate(0, 0, g_vidModeX, g_vidModeY)) <br>    } <br> <br>    // Restore the primary surface if it has been lost <br>    if (g_lpPrimary-&gt;IsLost()) <br>    { <br>    HRESULT rval = g_lpPrimary-&gt;Restore(); <br>    if (rval != DD_OK) return TRUE; <br>    TRY_D3DRM(g_lpD3DRMViewport-&gt;ForceUpdate(0, 0, g_vidModeX, g_vidModeY)) <br>    b = TRUE; <br>    } <br>     <br>    // Restore the ZBuffer if it has been lost <br>    if (g_lpZBuffer-&gt;IsLost()) <br>    { <br>    HRESULT rval = g_lpZBuffer-&gt;Restore(); <br>    if (rval != DD_OK) return TRUE; <br>    TRY_D3DRM(g_lpD3DRMViewport-&gt;ForceUpdate(0, 0, g_vidModeX, g_vidModeY)) <br>    } <br> <br>    // Clear the viewport ready for rendering <br>    TRY_D3DRM(g_lpD3DRMViewport-&gt;Clear()) <br>     <br>    // Render the scene <br>    TRY_D3DRM(g_lpD3DRMViewport-&gt;Render(g_lpScene)) <br> <br>    g_dwFramesRendered ++; <br> <br>    // Show stats if necessary <br>    if (g_bShowStats) <br>    { <br>// String to hold stats <br>char sStats[256]; <br> <br>// If 2 seconds have elapsed, calculate the frame rate <br>if (g_dwFpsTime &gt; 2000) <br>{ <br>    g_dwFps= g_dwFramesRendered / 2; <br>    g_dwFramesRendered= 0; <br>    g_dwFpsTime= 0; <br>} <br> <br>// Copy info into stat string <br>sprintf(sStats, "SX:%d, SY:%d, SBD:%d FPS:%d, %s", g_vidModeX, g_vidModeY, g_vidModeBIT, g_dwFps, g_bHardware3D ? "(H)" : "(S)"); <br> <br>// Get a DC to the backbuffer (very useful!) <br>HDC hDC; <br>g_lpBackBuffer-&gt;GetDC(&amp;hDC); <br>if (!hDC) return FALSE; <br> <br>// Use TextOut to draw the text onto the surface <br>DWORD dwStringPixelWidth = strlen(sStats) * g_dwAveCharWidth; <br> <br>        SetBkMode( hDC, TRANSPARENT ); <br>        SetTextColor( hDC, RGB(255,255,255) ); <br>TextOut(hDC, (g_vidModeX &gt;&gt; 1) - (dwStringPixelWidth &gt;&gt; 1), g_vidModeY - g_dwFontHeight, sStats, strlen(sStats)); <br> <br>// Must release DC before calling Flip() <br>g_lpBackBuffer-&gt;ReleaseDC(hDC); <br>    } <br> <br>    // Draw the power bars <br>    DDBLTFX ddBltFx; <br>    memset(&amp;ddBltFx, 0, sizeof(DDBLTFX)); <br>    ddBltFx.dwSize = sizeof(DDBLTFX); <br> <br>    RECT rcBar1 = { g_lbar1, g_hbar1, g_lbar1 + g_wbar1, g_hbar1 + g_hbar2 }; <br>    RECT rcBar2 = { g_lbar2, g_hbar1, g_lbar2 + g_wbar2, g_hbar1 + g_hbar2 }; <br> <br>    switch (g_vidModeBIT) <br>    { <br>case 8  : ddBltFx.dwFillColor = 253; break; <br>case 16 : ddBltFx.dwFillColor = 1 &lt;&lt; 4; break; <br>case 24 : ddBltFx.dwFillColor = 1 &lt;&lt; 7; break; <br>    } <br>    if (g_player1health &gt; 0) { <br>TRY_DD(g_lpBackBuffer-&gt;Blt(&amp;rcBar1, NULL, NULL, DDBLT_COLORFILL | DDBLT_WAIT, &amp;ddBltFx)) <br>TRY_D3DRM(g_lpD3DRMViewport-&gt;ForceUpdate(rcBar1.left, rcBar1.top, rcBar1.right, rcBar1.bottom)) <br>    } <br> <br>    switch (g_vidModeBIT) <br>    { <br>case 8  : ddBltFx.dwFillColor = 254; break; <br>case 16 : ddBltFx.dwFillColor = 1 &lt;&lt; 5 &lt;&lt; 5 &lt;&lt; 4; break; <br>case 24 : ddBltFx.dwFillColor = 1 &lt;&lt; 8 &lt;&lt; 8 &lt;&lt; 7; break; <br>    } <br>    if (g_player2health &gt; 0) { <br>TRY_DD(g_lpBackBuffer-&gt;Blt(&amp;rcBar2, NULL, NULL, DDBLT_COLORFILL | DDBLT_WAIT, &amp;ddBltFx)) <br>TRY_D3DRM(g_lpD3DRMViewport-&gt;ForceUpdate(rcBar2.left, rcBar2.top, rcBar2.right, rcBar2.bottom)) <br>    } <br> <br>    // And update the device <br>    TRY_D3DRM(g_lpD3DRMDevice-&gt;Update()) <br> <br>    // Finally, flip the back buffer onto the primary surface, displaying <br>    // the last rendered frame <br>    TRY_DD(g_lpPrimary-&gt;Flip(NULL, DDFLIP_WAIT)) <br> <br>    // Yahoo! <br>    return TRUE; <br>} <br> <br>//------------------------------------------------------------------ <br>//  <br>// Function: LoadTextures <br>// <br>// Purpose: Loads an individual texture <br>// <br>// NOTE: Textures must have a size divisible by 2 (e.g. 128x64, 256x256) <br>// <br>//------------------------------------------------------------------ <br> <br>HRESULT LoadTextures(char *sName, void *pArg, LPDIRECT3DRMTEXTURE *hTexture) <br>{     <br>    char *sTmpName = sName; <br>     <br>    // Find the extension <br>    while(sTmpName[0] != '.') sTmpName ++; <br> <br>    // Add .ppm to the picture file used by 3D Studio (.TGA, .GIF, .CEL etc) <br>    strcpy(sTmpName, ".ppm"); <br>     <br>    // Load the texture <br>    if (FAILED(g_lpD3DRM-&gt;LoadTexture(sName, hTexture))) return -1; <br> <br>    if (!strcmp(sName, "gdk_fill.ppm")) <br>    { <br>(*hTexture)-&gt;SetShades(1); <br>    } <br> <br>    return 0; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
