<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CONTROL.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3296"></a>CONTROL.CPP</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1995-1997 Microsoft Corporation. All Rights Reserved. <br> * <br> *  File: control.cpp <br> * <br> ***************************************************************************/ <br> <br>// Includes.... <br>#include "rm.h" <br>#include "control.h" <br>#include "directx.h" <br> <br>// Defines.... <br>#define MOVE_NORMAL                     D3DVAL(10) <br>#define MOVE_FAST                       D3DVAL(20) <br> <br>#define MIN_DIST_TO_OPPONENT            D3DVAL(100) <br> <br>#define PLAYER_MOVE_FORWARD             VK_UP <br>#define PLAYER_MOVE_BACKWARD            VK_DOWN <br>#define PLAYER_BLOCK                    VK_CONTROL <br>#define PLAYER_ATTACK                   VK_SPACE <br> <br>#define CAM_BOTH_IN_VIEW                VK_F1 <br>#define CAM_OVER_THE_SHOULDER           VK_F2 <br>#define CAM_PILOT                       VK_F3 <br> <br>#define NUM_BOB_FRAMES                  D3DVAL(30) <br>#define NUM_DEAD_FRAMES                 D3DVAL(66) <br>#define NUM_PUNCH_FRAMES                D3DVAL(29) <br>#define NUM_BEEN_HIT_FRAMES             D3DVAL(14) <br>#define NUM_BLOCKING_FRAMES             D3DVAL(16) <br>#define NUM_VICTORY_FRAMES              D3DVAL(55) <br> <br>#define BOB_START                       D3DVAL(1) <br>#define DEAD_START                      D3DVAL(94) <br>#define DEAD_HIT_GROUND                 D3DVAL(115) <br>#define PUNCH_START                     D3DVAL(31) <br>#define PUNCH_ARM_COCKED                D3DVAL(50) <br>#define BLOCK_START                     D3DVAL(77) <br>#define BEEN_HIT_START                  D3DVAL(62) <br>#define HEAD_RETURNING                  D3DVAL(68) <br>#define VICTORY_START                   D3DVAL(161) <br> <br>#define EDGE_LEFT                       D3DVAL(-600) <br>#define EDGE_RIGHT                      D3DVAL(600) <br> <br>// Globals.... <br> <br>// States <br>AppState                g_appState = DOING_INTRO; <br>PlayerState             g_oppState = CAUTIOUS; <br>CameraState             g_camState = BOTH_IN_VIEW; <br> <br>PlayerActionState       g_player1State = BOBBING; <br>PlayerActionState       g_player2State = BOBBING; <br> <br>AnimArgs                g_player1AnimArgs; <br>AnimArgs                g_player2AnimArgs; <br> <br>BOOL                    g_bPlayer1Attacking = FALSE; <br>BOOL                    g_bPlayer1Blocking  = FALSE; <br> <br>DWORD                   g_player1health = 100; <br>DWORD                   g_player2health = 100; <br> <br>// Timed lengths for each animation in milliseconds <br>#define BOB_TIME_MS     D3DVAL(500) <br>#define PUNCH_TIME_MS   D3DVAL(600) <br>#define BLOCK_TIME_MS   D3DVAL(500) <br>#define HIT_TIME_MS     D3DVAL(500) <br>#define DEAD_TIME_MS    D3DVAL(4000) <br>#define VICTORY_TIME_MS D3DVAL(3000) <br> <br>// Timing deltas, used for scaling animation to frame rate <br>D3DVALUE                g_bobDelta     = NUM_BOB_FRAMES / BOB_TIME_MS; <br>D3DVALUE                g_attackDelta  = NUM_PUNCH_FRAMES / PUNCH_TIME_MS; <br>D3DVALUE                g_blockDelta   = NUM_BLOCKING_FRAMES / BLOCK_TIME_MS; <br>D3DVALUE                g_hitDelta     = NUM_BEEN_HIT_FRAMES / HIT_TIME_MS; <br>D3DVALUE                g_deadDelta    = NUM_DEAD_FRAMES / DEAD_TIME_MS; <br>D3DVALUE                g_victoryDelta = NUM_DEAD_FRAMES / DEAD_TIME_MS; <br> <br>// Externals.... <br>extern LPDIRECT3DRM             g_lpD3DRM; <br>extern LPDIRECT3DRMFRAME        g_lpScene; <br>extern LPDIRECT3DRMFRAME        g_lpCamera; <br>extern LPDIRECT3DRMFRAME        g_lpPlayer1; <br>extern LPDIRECT3DRMFRAME        g_lpPlayer1HeadFrame; <br>extern LPDIRECT3DRMFRAME        g_lpPlayer2; <br>extern LPDIRECT3DRMFRAME        g_lpPlayer2HeadFrame; <br>extern LPDIRECT3DRMFRAME        g_lpTmp; <br>extern LPDIRECT3DRMANIMATION    g_lpAnim; <br>extern LPDIRECT3DRMMESHBUILDER  g_lpRedDebris; <br>extern LPDIRECT3DRMMESHBUILDER  g_lpBlueDebris; <br>extern Debris                   g_debris[NUM_DEBRIS]; <br>extern LPDIRECTSOUND3DLISTENER  g_lpDs3dListener; // Defined in DIRECTX.CPP <br> <br> <br>//---------------------------------------------------------------------- <br>//  <br>// Function     : IsKeyDown() <br>// <br>// Purpose      : Returns TRUE if specified key is being pressed <br>// <br>//---------------------------------------------------------------------- <br> <br>BOOL IsKeyDown(int virtKeyCode) <br>{ <br>    if (GetAsyncKeyState(virtKeyCode) &amp; 0x8000) return TRUE; <br> <br>    return FALSE; <br>} <br> <br>//---------------------------------------------------------------------- <br>//  <br>// Function     : Player1AnimationCallback() <br>// <br>// Purpose      : Animation call back for player 1 <br>// <br>//---------------------------------------------------------------------- <br> <br>void CDECL Player1AnimationCallback(LPDIRECT3DRMFRAME obj, void* arg, D3DVALUE delta) <br>{        <br>    D3DVALUE time = g_player1AnimArgs.time; <br>    D3DVECTOR player1pos; <br>    D3DVECTOR player2pos; <br>     <br>    // Booleans to help with sound playing <br>    static BOOL bHitGround              = FALSE; <br>    static BOOL bPlayedWhoosh   = FALSE; <br> <br>    // Get the players positions <br>    g_lpPlayer1-&gt;GetPosition(g_lpScene, &amp;player1pos);    <br>    g_lpPlayer2-&gt;GetPosition(g_lpScene, &amp;player2pos); <br>     <br>    // Compute distance between players <br>    D3DVALUE curDist = player2pos.z - player1pos.z; <br> <br>    // Do something based upon the state of player 1 <br>    switch (g_player1State) <br>    { <br>        case BOBBING : <br>        {        <br>            // Forward the bobbing animation time <br>            g_player1AnimArgs.lpAnimSet-&gt;SetTime(time);                  <br>            time += (g_bobDelta * delta); <br>             <br>            // Reset if animation has ended <br>            if (time &gt; BOB_START + NUM_BOB_FRAMES) time = BOB_START; <br>             <br>            // Record the new time <br>            g_player1AnimArgs.time = time; <br>        } <br>        break; <br> <br>        case PUNCHING : <br>        { <br>            // Forward the punching animation time <br>            g_player1AnimArgs.lpAnimSet-&gt;SetTime(time); <br>            time += (g_attackDelta * delta); <br> <br>            // Play a whoosh sound if player 1's arm has gone back and is about to punch <br>            if ((time &gt; PUNCH_ARM_COCKED) &amp;&amp; (!bPlayedWhoosh)) <br>            { <br>                // Play the whoosh <br>                PlaySoundDS(rand() % 2 == 0 ? WHOOSH1 : WHOOSH2,player1pos);                                <br>                bPlayedWhoosh = TRUE; <br>            } <br> <br>            // If the punch has played, see if we hit the opponent <br>            if (time &gt; PUNCH_START + NUM_PUNCH_FRAMES)  <br>            { <br>                // Reset player 1's state to BOBBING <br>                time               = BOB_START; <br>                g_player1State = BOBBING; <br>                bPlayedWhoosh  = FALSE; <br> <br>                // Play a servo sound <br>                PlaySoundDS(SERVO_DOWN_1,player1pos); <br> <br>                // Now, decide whether we have hit the other player <br>                if (curDist &lt; MIN_DIST_TO_OPPONENT + D3DVAL(20)) <br>                {                <br>                    // The opponent may be blocking <br>                    if ((g_player2State == BLOCKING) &amp;&amp;  <br>                        (g_player2AnimArgs.time &gt; BLOCK_START + (NUM_BLOCKING_FRAMES / D3DVAL(2))))  <br>                    { <br>                        // The opponent blocked the punch, so play the block sound <br>                        PlaySoundDS(BLOCK1 + (rand() % 3),player2pos); <br>                        break; <br>                    } <br> <br>                    // We're within the striking distance <br>                    if (g_player2health == 0) return; <br> <br>                    // Add some debris into the scene to register a hit and play a sound         <br>                    D3DVECTOR debrisOrg = player1pos; <br>                    D3DVECTOR debrisVel = { D3DVAL(0), D3DVAL(0), D3DVAL(-10) }; <br>                     <br>                    debrisOrg.x += D3DVAL(40); <br>                    debrisOrg.y += D3DVAL(40); <br>                    debrisOrg.z += D3DVAL(90); <br>                     <br>                    // Add some debris <br>                    AddDebris(debrisOrg, debrisVel, g_lpRedDebris); <br> <br>                    // Decrease the opponents health <br>                    if (g_player2health &gt; 0) g_player2health -= 10; <br>                                             <br>                    if (g_player2health == 0) <br>                    { <br>                        // The opponent has died! <br>                        g_player2State = DEAD; <br>                        g_player2AnimArgs.time = DEAD_START; <br>                        g_player2AnimArgs.lpAnimSet-&gt;SetTime(DEAD_START); <br>                        PlaySoundDS(HEAD_SPRING,player2pos); <br>                         <br>                        // And the player has victory! <br>                        g_player1State = VICTORY; <br>                        g_player1AnimArgs.time = VICTORY_START; <br>                        g_player1AnimArgs.lpAnimSet-&gt;SetTime(VICTORY_START); <br> <br>                        PlaySoundDS(VICTORY_YEAH,player1pos); <br> <br>                        return; <br>                    } <br> <br>                    // Play a punch sound <br>                    PlaySoundDS(rand() % 2 == 0 ? PLAYER1_PUNCH1 : PLAYER1_PUNCH2,player2pos); <br> <br>                    // Recalculate the power bars <br>                    RecalcPowerBars(g_player1health, g_player2health); <br>                     <br>                    // Make sure we force the camera to the correct place <br>                    PositionCamera(); <br> <br>                    // Setup the opponents animation and state <br>                    g_player2State = BEEN_HIT; <br>                    g_player2AnimArgs.time = BEEN_HIT_START; <br>                    g_player2AnimArgs.lpAnimSet-&gt;SetTime(BEEN_HIT_START); <br>                     <br>                    // What should the opponent do? <br>                    if (rand() % 10 &lt; 2) <br>                    { <br>                        // Make the opponent defensive <br>                        g_oppState = DEFENSIVE; <br>                    } <br> <br>                    // Play the ouch sound <br>                    PlaySoundDS(PLAYER2_OUCH,player1pos); <br>                } <br>            } <br> <br>            // Record the new animation time <br>            g_player1AnimArgs.time = time; <br>        } <br>        break; <br>         <br>        case BLOCKING :  <br>        { <br>            // Forward the blocking animation time <br>            g_player1AnimArgs.lpAnimSet-&gt;SetTime(time); <br>             <br>            // Hold the block up if CTRL is held down <br>            if (GetAsyncKeyState(PLAYER_BLOCK) &amp; 0x8000) <br>            { <br>                if (time &lt; BLOCK_START + (NUM_BLOCKING_FRAMES / 2)) time += (g_blockDelta * delta); <br>            } <br>            else <br>            { <br>                time += (g_blockDelta * delta); <br>            } <br> <br>            // Reset player 1's state to BOBBING if the animation has ended <br>            if (time &gt; BLOCK_START + NUM_BLOCKING_FRAMES)  <br>            { <br>                time            = BOB_START; <br>                g_player1State  = BOBBING; <br>            } <br> <br>            // Record the new animation time <br>            g_player1AnimArgs.time = time; <br>        } <br>        break; <br> <br>        case BEEN_HIT : <br>        { <br>            // Forward the been hit animation time <br>            g_player1AnimArgs.lpAnimSet-&gt;SetTime(time); <br>            time += (g_hitDelta * delta); <br> <br>            if (player1pos.z &gt; EDGE_LEFT) g_lpPlayer1-&gt;SetPosition(g_lpScene, player1pos.x, player1pos.y, player1pos.z - D3DVAL(5)); <br>            PositionCamera(); <br> <br>            // Reset player 1's state to BOBBING if the animation has ended <br>            if (time &gt; BEEN_HIT_START + NUM_BEEN_HIT_FRAMES)  <br>            { <br>                time            = BOB_START; <br>                g_player1State  = BOBBING; <br>            } <br>             <br>            // Record the new animation time <br>            g_player1AnimArgs.time = time; <br>        } <br>        break; <br>         <br>        case DEAD : <br>        { <br>            // Forward the death animation time <br>            g_player1AnimArgs.lpAnimSet-&gt;SetTime(time); <br>            time += (g_deadDelta * delta); <br> <br>            // Play a crash sound if the animation has passes the DEAD_HIT_GROUND frame <br>            if ((time &gt; DEAD_HIT_GROUND) &amp;&amp; (!bHitGround)) <br>            { <br>                bHitGround = TRUE; <br>                PlaySoundDS(BLOCK3,player1pos); <br>            } <br> <br>            // Reset player 1's state to BOBBING if the animation has ended <br>            if (time &gt; DEAD_START + NUM_DEAD_FRAMES)  <br>            { <br>                time            = BOB_START; <br>                g_player1State  = BOBBING; <br>                g_player1health = 100; <br>                bHitGround      = FALSE; <br> <br>                RecalcPowerBars(g_player1health, g_player2health); <br>            } <br>             <br>            // Record the new animation time <br>            g_player1AnimArgs.time = time; <br> <br>            // Position the camera correctly <br>            PositionCamera(); <br>        } <br>        break; <br> <br>        case VICTORY : <br>        { <br>            // Forward the victory animation time <br>            g_player1AnimArgs.lpAnimSet-&gt;SetTime(time); <br>            time += (g_victoryDelta * delta); <br> <br>            if (time &gt; VICTORY_START + NUM_VICTORY_FRAMES)  <br>            { <br>                time            = BOB_START; <br>                g_player1State  = BOBBING; <br>            } <br>            g_player1AnimArgs.time = time; <br> <br>            PositionCamera(); <br>        } <br>        break; <br>    } <br>} <br> <br>//---------------------------------------------------------------------- <br>//  <br>// Function     : Player2AnimationCallback() <br>// <br>// Purpose      : Animation call back for player 2 <br>// <br>//---------------------------------------------------------------------- <br> <br>void CDECL Player2AnimationCallback(LPDIRECT3DRMFRAME obj, void* arg, D3DVALUE delta) <br>{ <br>    D3DVALUE time = g_player2AnimArgs.time; <br>    D3DVECTOR player1pos; <br>    D3DVECTOR player2pos; <br> <br>    // Booleans to help with sound playing <br>    static BOOL bHitGround              = FALSE; <br>    static BOOL bPlayedWhoosh   = FALSE; <br> <br>    // Get the players positions <br>    g_lpPlayer1-&gt;GetPosition(g_lpScene, &amp;player1pos);    <br>    g_lpPlayer2-&gt;GetPosition(g_lpScene, &amp;player2pos); <br> <br>    // Compute distance between players <br>    D3DVALUE curDist = player2pos.z - player1pos.z; <br> <br>    // Do something based upon the state of player 1 <br>    switch (g_player2State) <br>    { <br>        case BOBBING : <br>        {        <br>            // Forward the bobbing animation time <br>            g_player2AnimArgs.lpAnimSet-&gt;SetTime(time); <br>            time += (g_bobDelta * delta); <br> <br>            // Reset if animation has ended <br>            if (time &gt; BOB_START + NUM_BOB_FRAMES) time = BOB_START; <br> <br>            // Record the new time <br>            g_player2AnimArgs.time = time; <br>        } <br>        break; <br> <br>        case PUNCHING : <br>        { <br>            // Forward the punching animation time <br>            g_player2AnimArgs.lpAnimSet-&gt;SetTime(time); <br>            time += (g_attackDelta * delta); <br> <br>            // Play a whoosh sound if player 2's arm has gone back and is about to punch <br>            if ((time &gt; PUNCH_ARM_COCKED) &amp;&amp; (!bPlayedWhoosh)) <br>            { <br>                // Play the whoosh <br>                PlaySoundDS(rand() % 2 == 0 ? WHOOSH1 : WHOOSH2,player2pos);                                <br>                bPlayedWhoosh = TRUE; <br>            } <br>     <br>            // If the punch has played, see if we hit the opponent <br>            if (time &gt; PUNCH_START + NUM_PUNCH_FRAMES)  <br>            { <br>                time = BOB_START; <br>                g_player2State = BOBBING; <br>                bPlayedWhoosh  = FALSE; <br>                 <br>                // Play a servo sound <br>                PlaySoundDS(SERVO_DOWN_2,player2pos); <br> <br>                // Now, decide whether we have hit the other player <br>                if (curDist &lt; MIN_DIST_TO_OPPONENT + D3DVAL(20)) <br>                {                <br>                    // The opponent may be blocking <br>                    if ((g_player1State == BLOCKING) &amp;&amp;  <br>                        (g_player1AnimArgs.time &gt; BLOCK_START + (NUM_BLOCKING_FRAMES / D3DVAL(2))))  <br>                    { <br>                        // The opponent blocked the punch, so play the block sound <br>                        PlaySoundDS(BLOCK1 + (rand() % 3),player1pos); <br>                        break; <br>                    } <br> <br>                    // We're within the striking distance <br>                    if (g_player1health &lt;= 0) return; <br> <br>                    // We're within the striking distance <br>                    // Add some debris into the scene to register a hit and play a sound         <br>                    D3DVECTOR debrisOrg = player1pos; <br>                    D3DVECTOR debrisVel = { D3DVAL(0), D3DVAL(0), D3DVAL(10) }; <br>                     <br>                    debrisOrg.x += D3DVAL(-40); <br>                    debrisOrg.y += D3DVAL(40); <br>                    debrisOrg.z += D3DVAL(-10); <br>                     <br>                    // Add some debris <br>                    AddDebris(debrisOrg, debrisVel, g_lpBlueDebris); <br> <br>                    // Play a punch sound <br>                    PlaySoundDS(rand() % 2 == 0 ? PLAYER2_PUNCH1 : PLAYER2_PUNCH2,player1pos); <br> <br>                    // Decrease the opponents health <br>                    if (g_player1health &gt; 0) g_player1health -= 10; <br> <br>                    if (g_player1health == 0) <br>                    { <br>                        // The player has died! <br>                        g_player1State = DEAD; <br>                        g_player1AnimArgs.time = DEAD_START; <br>                        g_player1AnimArgs.lpAnimSet-&gt;SetTime(DEAD_START); <br>                        PlaySoundDS(HEAD_SPRING,player1pos); <br> <br>                        // And the opponent has victory! <br>                        g_player2State = VICTORY; <br>                        g_player2AnimArgs.time = VICTORY_START; <br>                        g_player2AnimArgs.lpAnimSet-&gt;SetTime(VICTORY_START); <br> <br>                        // The crowd is not happy.... <br>                        PlaySoundDS(VICTORY_BOO,player2pos); <br> <br>                        return; <br>                    } <br> <br>                    // Recalculate the power bars <br>                    RecalcPowerBars(g_player1health, g_player2health); <br>                     <br>                    // Force a camera positional update <br>                    PositionCamera(); <br>                     <br>                    if (g_player1State != BEEN_HIT) <br>                    { <br>                        // Change player 1's state to BEEN_HIT, <br>                        g_player1State = BEEN_HIT; <br> <br>                        // And set the animation time <br>                        g_player1AnimArgs.time = BEEN_HIT_START; <br>                        g_player1AnimArgs.lpAnimSet-&gt;SetTime(BEEN_HIT_START);                                            <br>                    } <br> <br>                    // Play the ouch sound <br>                    PlaySoundDS(PLAYER1_OUCH,player1pos); <br>                } <br>            } <br> <br>            // Record the new animation time <br>            g_player2AnimArgs.time = time; <br>        } <br>        break; <br> <br>        case BEEN_HIT : <br>        { <br>            // Forward the been hit animation time <br>            g_player2AnimArgs.lpAnimSet-&gt;SetTime(time); <br>            time += (g_hitDelta * delta); <br>             <br>            // Move the player <br>            if (player2pos.z &lt; EDGE_RIGHT) g_lpPlayer2-&gt;SetPosition(g_lpScene, player2pos.x, player2pos.y, player2pos.z + D3DVAL(5)); <br>             <br>            // Force a camera position update <br>            PositionCamera(); <br> <br>            // Reset to BOBBING if animation has ended <br>            if (time &gt; BEEN_HIT_START + NUM_BEEN_HIT_FRAMES)  <br>            { <br>                time = BOB_START; <br>                g_player2State = BOBBING; <br>            } <br>             <br>            // Record the new animation time <br>            g_player2AnimArgs.time = time; <br>        } <br>        break; <br> <br>        case BLOCKING :  <br>        { <br>            // Forward the blocking animation time <br>            g_player2AnimArgs.lpAnimSet-&gt;SetTime(time); <br>            time += (g_blockDelta * delta); <br> <br>            // Reset to BOBBING if animation has ended <br>            if (time &gt; BLOCK_START + NUM_BLOCKING_FRAMES)  <br>            { <br>                time            = BOB_START; <br>                g_player2State  = BOBBING; <br>                g_oppState      = AGGRESSIVE; <br>            } <br>             <br>            // Record the new animation time <br>            g_player2AnimArgs.time = time; <br>        } <br>        break; <br> <br>        case DEAD : <br>        { <br>            // Forward the death animation time <br>            g_player2AnimArgs.lpAnimSet-&gt;SetTime(time); <br>            time += (g_deadDelta * delta); <br> <br>            // Play the BLOCK3 sound when the opponent hits the ground <br>            if ((time &gt; DEAD_HIT_GROUND) &amp;&amp; (!bHitGround)) <br>            { <br>                bHitGround = TRUE; <br>                PlaySoundDS(BLOCK3,player2pos); <br>            } <br> <br>            // Reset to BOBBING if the animation has ended <br>            if (time &gt; DEAD_START + NUM_DEAD_FRAMES)  <br>            { <br>                time            = BOB_START; <br>                g_player2State  = BOBBING; <br>                g_player2health = 100; <br>                bHitGround      = FALSE; <br> <br>                // Recalculate the power bars <br>                RecalcPowerBars(g_player1health, g_player2health); <br>            } <br>            // Record the new animation time <br>            g_player2AnimArgs.time = time; <br> <br>            // Force a camera position update <br>            PositionCamera(); <br>        } <br>        break; <br> <br>        case VICTORY : <br>        { <br>            // Forward the victory animation time <br>            g_player2AnimArgs.lpAnimSet-&gt;SetTime(time); <br>            time += (g_victoryDelta * delta); <br> <br>            if (time &gt; VICTORY_START + NUM_VICTORY_FRAMES)  <br>            { <br>                time            = BOB_START; <br>                g_player2State  = BOBBING; <br>            } <br>             <br>            // Record the new animation time <br>            g_player2AnimArgs.time = time; <br> <br>            // Force a camera position update <br>            PositionCamera(); <br>        } <br>        break; <br>    } <br>} <br> <br>//---------------------------------------------------------------------- <br>//  <br>// Function     : CheckInputAndUpdate() <br>// <br>// Purpose      : Checks input, updates scene, moves player(s) <br>// <br>//---------------------------------------------------------------------- <br> <br>void CheckInputAndUpdate() <br>{                <br>    D3DVECTOR player1pos; <br>    D3DVECTOR player2pos; <br>    D3DVECTOR camPos; <br> <br>    // Run intro <br>    if (g_appState == DOING_INTRO) <br>    { <br>            RunIntro(); <br>            return; <br>    } <br> <br>    // Transition camera <br>    if (g_appState == BETWEEN_CAM_VIEWS) <br>    { <br>            TransitionCamera(); <br>            return; <br>    } <br> <br>    // Get the players positions <br>    g_lpPlayer1-&gt;GetPosition(g_lpScene, &amp;player1pos);    <br>    g_lpPlayer2-&gt;GetPosition(g_lpScene, &amp;player2pos); <br> <br>    // Get the camera's position <br>    g_lpCamera-&gt;GetPosition(g_lpScene, &amp;camPos); <br> <br>    // Calculate distance between players <br>    D3DVALUE curDist = player2pos.z - player1pos.z; <br> <br>    // Move player forward <br>    if ((IsKeyDown(PLAYER_MOVE_FORWARD)) &amp;&amp; (g_player1State != VICTORY) &amp;&amp; (g_player1State != DEAD)) <br>    { <br>            // Make sure the player can only move so close to the opponent <br>            if (curDist &gt; MIN_DIST_TO_OPPONENT) <br>            { <br>                    // Move the player <br>                    g_lpPlayer1-&gt;SetPosition(g_lpScene, player1pos.x, player1pos.y, player1pos.z + MOVE_NORMAL); <br> <br>                    // Force a camera position update <br>                    PositionCamera(); <br> <br>                    // Play a servo sound <br>                    PlaySoundDS(SERVO_UP_3,player1pos); <br>                     <br>                    // Play a walk sound <br>                    PlaySoundDS(PLAYER1_WALK,player1pos); <br>            } <br>    } <br> <br>    // Move player backward <br>    if ((IsKeyDown(PLAYER_MOVE_BACKWARD)) &amp;&amp; (g_player1State != VICTORY) &amp;&amp; (g_player1State != DEAD)) <br>    { <br>            // Make sure the player can't run off the arena <br>            if (player1pos.z &gt; EDGE_LEFT) <br>            { <br>                    // Move the player <br>                    g_lpPlayer1-&gt;SetPosition(g_lpScene, player1pos.x, player1pos.y, player1pos.z - MOVE_NORMAL); <br>                     <br>                    // Force a camera position update <br>                    PositionCamera(); <br> <br>                    // Play a servo sound <br>                    PlaySoundDS(SERVO_UP_3,player1pos); <br> <br>                    // Play a walk sound <br>                    PlaySoundDS(PLAYER1_WALK,player1pos); <br>            } <br>    } <br> <br>    // Initiate a player attack <br>    if ((!g_bPlayer1Attacking) &amp;&amp; (!g_bPlayer1Blocking) &amp;&amp; (IsKeyDown(PLAYER_ATTACK))) <br>    { <br>            if ((g_player1State != PUNCHING) &amp;&amp; (g_player1State != DEAD) &amp;&amp; (g_player1State != VICTORY)) <br>            { <br>                    // Set the player state to punching <br>                    g_player1State = PUNCHING; <br>                     <br>                    // Set up the correct time for the animation <br>                    g_player1AnimArgs.time = D3DVAL(PUNCH_START); <br>                    g_player1AnimArgs.lpAnimSet-&gt;SetTime(D3DVAL(PUNCH_START)); <br>                                     <br>                    g_bPlayer1Attacking = TRUE; <br>                     <br>                    // Play a servo sound <br>                    PlaySoundDS(SERVO_UP_1,player1pos); <br>            } <br>    } <br> <br>    // Reset the attacking flag if the PLAYER_ATTACK key is not pressed anymore <br>    if ((g_bPlayer1Attacking) &amp;&amp; (!IsKeyDown(PLAYER_ATTACK))) <br>    { <br>            g_bPlayer1Attacking = FALSE; <br>    } <br> <br>    // Initiate a player block <br>    if ((!g_bPlayer1Blocking) &amp;&amp; (!g_bPlayer1Attacking) &amp;&amp; (IsKeyDown(PLAYER_BLOCK))) <br>    { <br>            if ((g_player1State != BLOCKING) &amp;&amp; (g_player1State != DEAD) &amp;&amp; (g_player1State != VICTORY)) <br>            { <br>                    // Set the player state to blocking <br>                    g_player1State = BLOCKING; <br>                     <br>                    // Set up the correct time for the animation <br>                    g_player1AnimArgs.time = D3DVAL(BLOCK_START); <br>                    g_player1AnimArgs.lpAnimSet-&gt;SetTime(D3DVAL(BLOCK_START)); <br>                             <br>                    // Don't allow any more blocking <br>                    g_bPlayer1Blocking = TRUE; <br>                     <br>                    // Play a servo sound <br>                    PlaySoundDS(SERVO_UP_1,player1pos); <br>            }    <br>    } <br> <br>    // Reset the blocking flag if the PLAYER_BLOCK key is no longer held down <br>    if ((g_bPlayer1Blocking) &amp;&amp; (!IsKeyDown(PLAYER_BLOCK))) <br>    { <br>            g_bPlayer1Blocking = FALSE; <br>    } <br> <br>    // Transition to the BOTH_IN_VIEW camera view <br>    if ((IsKeyDown(CAM_BOTH_IN_VIEW)) &amp;&amp; (g_camState != BOTH_IN_VIEW)) <br>    { <br>            // Create transition animation <br>            if (!FAILED(g_lpD3DRM-&gt;CreateAnimation(&amp;g_lpAnim))) <br>            { <br>                    // Setup the animation options <br>                    g_lpAnim-&gt;SetOptions(D3DRMANIMATION_OPEN |  <br>                                                             D3DRMANIMATION_LINEARPOSITION |  <br>                                                             D3DRMANIMATION_POSITION); <br> <br>                    // Make midway vector between both players, this is what the camera will focus on <br>                    D3DVECTOR vMidPoint; <br>                    vMidPoint.x = 0.0f; <br>                    vMidPoint.y = 0.0f; <br>                    vMidPoint.z = (player1pos.z + player2pos.z) / D3DVAL(2); <br>                     <br>                    // Calculate vector that will keep both players in sight <br>                    D3DVECTOR vNewCam; <br>                    vNewCam.x = (float)abs((int)player2pos.z - (int)player1pos.z) + D3DVAL(300); <br>                    vNewCam.y = camPos.y; <br>                    vNewCam.z = vMidPoint.z; <br>                     <br>                    // Add the keyframes to the animation <br>                    g_lpAnim-&gt;AddPositionKey(D3DVAL(0), camPos.x, camPos.y, camPos.z); <br>                    g_lpAnim-&gt;AddPositionKey(D3DVAL(1), vNewCam.x, vNewCam.y, vNewCam.z); <br>                     <br>                    // Setup the initial position <br>                    g_lpTmp-&gt;SetPosition(g_lpScene, vMidPoint.x, vMidPoint.y, vMidPoint.z); <br>                     <br>                    // And attach the camera to the animation <br>                    g_lpAnim-&gt;SetFrame(g_lpCamera); <br> <br>                    g_appState = BETWEEN_CAM_VIEWS; <br>            } <br>            else <br>            { <br>                    // Create animation failed so just set the camera position <br>                    g_lpCamera-&gt;SetPosition(g_lpScene, D3DVAL(200), D3DVAL(100), player1pos.z + MOVE_NORMAL - D3DVAL(400)); <br>                    g_lpCamera-&gt;LookAt(g_lpPlayer2, g_lpScene, D3DRMCONSTRAIN_Z);                <br>                    PositionCamera();                    <br>            } <br> <br>            g_camState = BOTH_IN_VIEW; <br>    } <br>     <br>    // Transition to the OVER_SHOULDER camera view <br>    if ((IsKeyDown(CAM_OVER_THE_SHOULDER)) &amp;&amp; (g_camState != OVER_SHOULDER)) <br>    { <br>        if (!FAILED(g_lpD3DRM-&gt;CreateAnimation(&amp;g_lpAnim))) <br>        { <br>            // Setup the animation options <br>            g_lpAnim-&gt;SetOptions(D3DRMANIMATION_OPEN |  <br>                                 D3DRMANIMATION_LINEARPOSITION |  <br>                                 D3DRMANIMATION_POSITION); <br> <br>            // Add the keyframes to the animation                        <br>            g_lpAnim-&gt;AddPositionKey(D3DVAL(0), camPos.x, camPos.y, camPos.z); <br>            g_lpAnim-&gt;AddPositionKey(D3DVAL(1), D3DVAL(200), D3DVAL(100), player1pos.z - D3DVAL(300)); <br>             </code></pre>
<p>
</p>
<pre><code>// Setup the initial position <br>            g_lpTmp-&gt;SetPosition(g_lpScene, player2pos.x, player2pos.y, player2pos.z); <br>             <br>            // And attach the camera to the animation <br>            g_lpAnim-&gt;SetFrame(g_lpCamera); <br> <br>            g_appState = BETWEEN_CAM_VIEWS; <br>        } <br>        else <br>        { <br>            // Create animation failed so just set the camera position <br>            PositionCamera(); <br>        } <br>                                 <br>        g_camState = OVER_SHOULDER; <br>    } <br> <br>    // Transition to the PILOT_VIEW camera view <br>    if ((IsKeyDown(CAM_PILOT)) &amp;&amp; (g_camState != PILOT_VIEW)) <br>    { <br>        PositionCamera(); <br>        g_camState = PILOT_VIEW; <br>    } <br> <br>    // Update the opponent <br>    UpdateOpponent(); <br> <br>    // Update any debris in the world <br>    UpdateDebris(); <br>} <br> <br>//---------------------------------------------------------------------- <br>//  <br>// Function     : UpdateOpponent() <br>// <br>// Purpose      : Updates opponent <br>// <br>//---------------------------------------------------------------------- <br> <br>void UpdateOpponent() <br>{ <br>    D3DVECTOR player1pos; <br>    D3DVECTOR player2pos;        <br> <br>    if (g_player2State != BOBBING) return; <br> <br>    // Random value to determine what the opponent should do based upon its state <br>    int r = rand() % 100; <br> <br>    // Get the players positions <br>    g_lpPlayer1-&gt;GetPosition(g_lpScene, &amp;player1pos);    <br>    g_lpPlayer2-&gt;GetPosition(g_lpScene, &amp;player2pos); <br> <br>    // Calculate distance betweens players <br>    D3DVALUE curDist = player2pos.z - player1pos.z; <br>     <br>    // There is always a chance to block the player <br>    if ((r &lt; 15) &amp;&amp; (g_player1State == PUNCHING) &amp;&amp; (g_player2State == BOBBING)) <br>    { <br>        // Set the opponents state to BLOCKING ans start the animation <br>        g_player2State = BLOCKING; <br>        g_player2AnimArgs.time = BLOCK_START; <br>        g_player2AnimArgs.lpAnimSet-&gt;SetTime(BLOCK_START); <br>         <br>        // Play a servo sound <br>        PlaySoundDS(SERVO_UP_2,player2pos); <br>        return; <br>    } <br> <br>    switch (g_oppState) <br>    { <br>        case DEFENSIVE: <br>        {                        <br>            // Decide whether to move opponent backwards <br>            if (r &lt; 25) <br>            { <br>                // Move the opponent backwards <br>                g_lpPlayer2-&gt;SetPosition(g_lpScene, player2pos.x, player2pos.y, player2pos.z + MOVE_NORMAL); <br>                 <br>                // Play a walk sound <br>                PlaySoundDS(PLAYER2_WALK,player2pos); <br>                 <br>                // Play a servo sound <br>                PlaySoundDS(SERVO_DOWN_3,player2pos); <br>            } <br>            PositionCamera();                    <br> <br>            // Decide whether to go from DEFENSIVE to cautious <br>            if (r &lt; 10) g_oppState = CAUTIOUS; <br>        } <br>        break; <br> <br>        case CAUTIOUS: <br>        { <br>            // Decide whether to go from CAUTIOUS to AGGRESSIVE <br>            if (r &lt; 5) <br>            { <br>                // Make the opponent become aggresive <br>                g_oppState = AGGRESSIVE; <br>            } <br>        } <br>        break; <br> <br>        case AGGRESSIVE: <br>        {                        <br>            // Decide whether to move the opponent towards the player <br>            if (r &lt; 50) <br>            { <br>                // Move the opponent towards the player <br>                if (curDist &gt; MIN_DIST_TO_OPPONENT) <br>                { <br>                    g_lpPlayer2-&gt;SetPosition(g_lpScene, player2pos.x, player2pos.y, player2pos.z - MOVE_NORMAL); <br>                    PositionCamera(); <br> <br>                    // Play a walk sound <br>                    PlaySoundDS(PLAYER2_WALK,player2pos); <br>                     <br>                    // Play a servo sound <br>                    PlaySoundDS(SERVO_DOWN_3,player2pos);                           <br>                } <br>            } <br> <br>            // Decide whether or not to attack the player <br>            if ((r &lt; 15) &amp;&amp; (g_player2State == BOBBING) &amp;&amp;  <br>                (g_player1State != DEAD) &amp;&amp; (curDist &lt; MIN_DIST_TO_OPPONENT + D3DVAL(50))) <br>            { <br>                // Set the opponent's state to PUNCHING <br>                g_player2State = PUNCHING; <br>                g_player2AnimArgs.time = PUNCH_START; <br>                g_player2AnimArgs.lpAnimSet-&gt;SetTime(PUNCH_START); <br>                 <br>                // Play a servo sound <br>                PlaySoundDS(SERVO_UP_2,player2pos); <br>            } <br> <br>            // Decide whether or not to move the opponent backwards out of the way if the player <br>            // is punching <br>            if ((g_player1State == PUNCHING) &amp;&amp; (r &gt; 50) &amp;&amp; (g_player2State == BOBBING) &amp;&amp; (curDist &lt; MIN_DIST_TO_OPPONENT + 50)) <br>            { <br>                // Move the opponent out of the way, making sure its still in the arena <br>                if (player2pos.z &lt; EDGE_RIGHT)  <br>                { <br>                    g_lpPlayer2-&gt;SetPosition(g_lpScene, player2pos.x, player2pos.y, player2pos.z + D3DVAL(5)); <br>                     <br>                    // Play a servo sound <br>                    PlaySoundDS(SERVO_DOWN_3,player1pos); <br>                } <br>            } <br>        } <br>        break; <br>    } <br>} <br> <br>//---------------------------------------------------------------------- <br>//  <br>// Function     : RunIntro() <br>// <br>// Purpose      : Moves camera along path <br>// <br>//---------------------------------------------------------------------- <br> <br>void RunIntro() <br>{ <br>    static D3DVALUE time = D3DVAL(0.0f); <br>D3DVECTOR d3dvPos;// D3DVECTOR used for 3D position of sound <br>d3dvPos.x = D3DVAL(0);// set the sound at (0,0,0).. <br>d3dvPos.y = D3DVAL(0); <br>d3dvPos.z = D3DVAL(0); <br> <br>    // Play the intro sound <br>    if (time == D3DVAL(0.0f)) <br>    { <br>        PlaySoundDS(INTRO,d3dvPos); <br>        PlaySoundDS(CROWD_LOOP,d3dvPos, DSBPLAY_LOOPING); <br>                SetTimer(NULL,NULL,10000,(TIMERPROC)PlayRandomWave); <br>    } <br>     <br>    // Foward the intro animation <br>    time += D3DVAL(0.04); <br> <br>    // Set the animation time <br>    g_lpAnim-&gt;SetTime(time); <br>     <br>    // Always look at the origin of the g_lpScene frame <br>    g_lpCamera-&gt;LookAt(g_lpTmp, g_lpScene, D3DRMCONSTRAIN_Z); <br>     <br>    // If time has exceeded 1.0 the intro is done, and we can start the demo <br>    if (time &gt;= D3DVAL(1.0f)) <br>    { <br>        g_appState = PLAYING_DEMO; <br>        g_lpAnim-&gt;Release(); <br>        g_lpAnim = NULL; <br>        PositionCamera(); <br>    } <br>} <br> <br>//---------------------------------------------------------------------- <br>//  <br>// Function     : PostionCamera() <br>// <br>// Purpose      : Positions camera based upon camera state <br>// <br>//---------------------------------------------------------------------- <br> <br>void PositionCamera() <br>{        <br>    D3DVECTOR player1pos; <br>    D3DVECTOR player2pos; <br>    D3DVECTOR camPos; <br> <br>    // Don't position the camera if we are transitioning between camera views <br>    if (g_appState == BETWEEN_CAM_VIEWS) return; <br> <br>    // Get the players positions <br>    g_lpPlayer1-&gt;GetPosition(g_lpScene, &amp;player1pos);    <br>    g_lpPlayer2-&gt;GetPosition(g_lpScene, &amp;player2pos); <br> <br>    // Get the camera's position <br>    g_lpCamera-&gt;GetPosition(g_lpScene, &amp;camPos); <br> <br>    switch (g_camState) <br>    { <br>        case OVER_SHOULDER: <br>        { <br>            // Position the camera such that it looks over the shoulder of the player and <br>            // keeps the opponent in view <br>            g_lpCamera-&gt;SetPosition(g_lpScene, camPos.x, camPos.y, D3DVAL(player1pos.z) + MOVE_NORMAL - 300);                    <br>            g_lpCamera-&gt;LookAt(g_lpPlayer2, g_lpScene, D3DRMCONSTRAIN_Z); <br>    if (g_lpDs3dListener) <br>    { <br>                // Set the listener position to where the camera is <br>g_lpDs3dListener-&gt;SetPosition(camPos.x, camPos.y, D3DVAL(player1pos.z) + MOVE_NORMAL - 300,DS3D_DEFERRED); <br>// Change listener's orientation vector <br>g_lpDs3dListener-&gt;SetOrientation(D3DVAL(0),D3DVAL(0),D3DVAL(1),D3DVAL(0),D3DVAL(1),D3DVAL(0),DS3D_DEFERRED); <br>    } <br>        } <br>        break; <br> <br>        case BOTH_IN_VIEW: <br>        { <br>            // Position the camera such that it looks at both players all the time <br> <br>            // Make midway point, this is what the camera will focus on <br>            D3DVECTOR vMidPoint; <br>            vMidPoint.x = 0.0f; <br>            vMidPoint.y = 0.0f; <br>            vMidPoint.z = (player1pos.z + player2pos.z) / D3DVAL(2); <br>             <br>            // Calculate vector that will keep both players in sight <br>            D3DVECTOR vNewCam; <br>            vNewCam.x = (float)abs((int)player2pos.z - (int)player1pos.z) + D3DVAL(300); <br>            vNewCam.y = camPos.y; <br>            vNewCam.z = vMidPoint.z; <br> <br>            g_lpCamera-&gt;SetPosition(g_lpScene, vNewCam.x, vNewCam.y, vNewCam.z); <br>                             <br>            g_lpTmp-&gt;SetPosition(g_lpScene, vMidPoint.x, vMidPoint.y, vMidPoint.z); <br>            g_lpCamera-&gt;LookAt(g_lpTmp, g_lpScene, D3DRMCONSTRAIN_Z); <br>    if (g_lpDs3dListener) <br>    { <br>                // Set the listener position to where the camera is <br>g_lpDs3dListener-&gt;SetPosition(vNewCam.x, vNewCam.y, vNewCam.z,DS3D_DEFERRED); <br>// Change listener's orientation vector <br>g_lpDs3dListener-&gt;SetOrientation(-D3DVAL(1),D3DVAL(0),D3DVAL(0),D3DVAL(0),D3DVAL(1),D3DVAL(0),DS3D_DEFERRED); <br>    } <br>        } <br>        break; <br> <br>        case PILOT_VIEW: <br>        {                                                <br>            // Position the camera such that it looks through the eyes of the player <br>            // and fixes on the origin of the head frame of the opponent <br> <br>            g_lpCamera-&gt;SetPosition(g_lpPlayer1HeadFrame, D3DVAL(0), D3DVAL(-10), D3DVAL(0)); <br>            g_lpTmp-&gt;SetPosition(g_lpPlayer2HeadFrame, D3DVAL(0), D3DVAL(-10), D3DVAL(0)); <br>            g_lpCamera-&gt;LookAt(g_lpTmp, g_lpScene, D3DRMCONSTRAIN_Z); <br>    if (g_lpDs3dListener) <br>    { <br>                // Set the listener position to where the camera is <br>g_lpDs3dListener-&gt;SetPosition(player1pos.x, D3DVAL(0), player1pos.z,DS3D_DEFERRED); <br>// Change listener's orientation vector <br>g_lpDs3dListener-&gt;SetOrientation(D3DVAL(0),D3DVAL(0),D3DVAL(1),D3DVAL(0),D3DVAL(1),D3DVAL(0),DS3D_DEFERRED); <br>    } <br>        } <br>        break; <br>    } <br>// Commit the changes to the listener's orientation and position.. <br>if (g_lpDs3dListener) <br>    g_lpDs3dListener-&gt;CommitDeferredSettings(); <br>} <br> <br>//---------------------------------------------------------------------- <br>//  <br>// Function     : TransitionCamera() <br>// <br>// Purpose      : Positions camera based upon camera state <br>// <br>//---------------------------------------------------------------------- <br> <br>void TransitionCamera() <br>{ <br>    static D3DVALUE time = D3DVAL(0.0f); <br> <br>    // Forward the transition animation time <br>    time += D3DVAL(0.04); <br> <br>    // Set the time for the transitional animation <br>    g_lpAnim-&gt;SetTime(time); <br> <br>    // Look at the g_lpScene frame <br>    g_lpCamera-&gt;LookAt(g_lpTmp, g_lpScene, D3DRMCONSTRAIN_Z); <br> <br>    // If the animation has ended, run the demo <br>    if (time &gt;= D3DVAL(1.0f)) <br>    { <br>        g_appState = PLAYING_DEMO; <br>        g_lpAnim-&gt;Release(); <br>        g_lpAnim = NULL; <br>        time = D3DVAL(0); <br>        PositionCamera();                <br>    } <br> <br>    // Update debris so any debris in the scene doesn't just sit there doing nothing <br>    UpdateDebris(); <br>} <br> <br>//---------------------------------------------------------------------- <br>//  <br>// Function     : AddDebris() <br>// <br>// Purpose      : Adds some debris to the scene <br>// <br>//---------------------------------------------------------------------- <br> <br>void AddDebris(D3DVECTOR vOrg, D3DVECTOR vVel, LPDIRECT3DRMMESHBUILDER pDebris) <br>{ <br>    // vOrg is the origin of the debris, find first open spot and add 5 bits of debris <br>    int count = 0; <br> <br>    for (int i = 0; i &lt; NUM_DEBRIS; i ++) <br>    { <br>        // Find some debris that is not in use yet <br>        if (!g_debris[i].m_bInUse) <br>        { <br>            // Add some debris  <br>            g_debris[i].m_pFrame-&gt;AddVisual(pDebris); <br>            g_debris[i].m_pFrame-&gt;SetPosition(g_lpScene, vOrg.x, vOrg.y, vOrg.z); <br>            g_debris[i].m_pFrame-&gt;SetRotation(g_lpScene, D3DVAL(0.5), D3DVAL(0.5), D3DVAL(0.5), D3DVAL(0.5)); <br>            g_debris[i].m_life = 0; <br> <br>            // Setup velocity and acceleration <br>            g_debris[i].m_vel.x = D3DVAL(-10 + (rand() % 20)) + vVel.x; <br>            g_debris[i].m_vel.y = D3DVAL(8) + D3DVAL(rand() % 10) + vVel.y; <br>            g_debris[i].m_vel.z = D3DVAL(-10 + (rand() % 20)) + vVel.z; <br> <br>            g_debris[i].m_acc.x = D3DVAL(0); <br>            g_debris[i].m_acc.y = D3DVAL(-2); <br>            g_debris[i].m_acc.z = D3DVAL(0);                     <br> <br>            // This piece of debris is now in use <br>            g_debris[i].m_bInUse = TRUE; <br>            g_debris[i].m_pMeshBuilder = pDebris; <br>             <br>            count ++;                    <br>        } <br> <br>        // Return if we've added NUM_HIT_DEBRIS bits of debris <br>        if (count == NUM_HIT_DEBRIS) return; <br>    }    <br>} <br> <br>//---------------------------------------------------------------------- <br>//  <br>// Function     : UpdateDebris() <br>// <br>// Purpose      : Updates debris <br>// <br>//---------------------------------------------------------------------- <br> <br>void UpdateDebris() <br>{ <br>    D3DVECTOR vPos; <br> <br>    // Go through the array of debris and update any debris that is in use <br> <br>    for (int i = 0; i &lt; NUM_DEBRIS; i ++) <br>    { <br>        if (g_debris[i].m_bInUse) <br>        { <br>            // If the debris's life has not yet expired <br>            if (g_debris[i].m_life &lt; DEBRIS_LIFE) <br>            { <br>                // Move the debris <br>                g_debris[i].m_pFrame-&gt;GetPosition(g_lpScene, &amp;vPos); <br>                 <br>                g_debris[i].m_vel.x += g_debris[i].m_acc.x; <br>                g_debris[i].m_vel.y += g_debris[i].m_acc.y; <br>                g_debris[i].m_vel.z += g_debris[i].m_acc.z; <br> <br>                vPos.x += g_debris[i].m_vel.x; <br>                vPos.y += g_debris[i].m_vel.y; <br>                vPos.z += g_debris[i].m_vel.z; <br> <br>                // Check to see whether the debris is below the floor <br>                if (vPos.y &lt; D3DVAL(-60)) <br>                { <br>                        // Bounce the debris <br>                        vPos.y = D3DVAL(-60); <br>                        g_debris[i].m_vel.y = -g_debris[i].m_vel.y / D3DVAL(1.5); <br>                } <br> <br>                // Update the position of the debris <br>                g_debris[i].m_pFrame-&gt;SetPosition(g_lpScene, vPos.x, vPos.y, vPos.z); <br>            } <br>            else <br>            { <br>                // Remove the debris from the world <br>                g_debris[i].m_pFrame-&gt;DeleteVisual(g_debris[i].m_pMeshBuilder); <br>                g_debris[i].m_bInUse = FALSE; <br>            } <br> <br>            // Age the debris <br>            g_debris[i].m_life ++; <br>        } <br>    } <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
