<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DIRECTX.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3298"></a>DIRECTX.CPP</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1995-1997 Microsoft Corporation. All Rights Reserved. <br> * <br> *  File: directx.cpp <br> * <br> ***************************************************************************/ <br> <br>// N.B. The use of RM denotes the Direct3D retained mode objects <br> <br>// The Macros TRY_DD, TRY_DS, TRY_D3D, TRY_D3DRM are defined in DirectX.h and are for <br>// error checking. <br> <br>#define INITGUID <br>// Includes.... <br>#include "directx.h" <br>#include "mmsystem.h" <br>#include "winmain.h" <br>#include "conio.h" <br> <br>// Globals.... <br>LPDIRECTDRAW            g_lpDD = NULL;          // DirectDraw object <br>LPDIRECT3D              g_lpD3D = NULL;         // Direct3D object <br>LPDIRECTSOUND           g_lpDS = NULL;          // DirectSound object <br>LPDIRECT3DRM            g_lpD3DRM = NULL;       // Direct3D RM object <br>DWORD                   g_dwGDIMem = 0;         // Memory in available from GDI's surface <br> <br>D3DDeviceInfo           g_deviceInfo;           // 3D device info <br>LPGUID                  g_lpD3DDeviceGuid = NULL; // Guid to 3D device <br> <br>VideoMode               g_vidModes[NUM_VID_MODES];// Array of available video modes <br>DWORD                   g_dwCurrMode = 0; <br>DWORD                   g_dwNumModes = 0; <br> <br>BOOL                    g_bSoundPresent = FALSE; // Do we have sound capabilites? <br> <br>LPDIRECTDRAWSURFACE     g_lpPrimary = NULL;     // Primary surface <br>LPDIRECTDRAWSURFACE     g_lpBackBuffer = NULL;  // BackBuffer surface <br>LPDIRECTDRAWSURFACE     g_lpZBuffer = NULL;     // ZBuffer <br>LPDIRECTDRAWPALETTE     g_lpPalette = NULL;     // Palette <br>PALETTEENTRY            g_rPal[768];            // Rockem3D palette <br> <br>LPDIRECTDRAW            g_lpSplashDD = NULL;        // DirectDraw object used for splash screen <br>LPDIRECTDRAWSURFACE     g_lpSplashPrimary = NULL;   // Primary surface <br>LPDIRECTDRAWPALETTE     g_lpSplashPalette = NULL;   // Palette <br> <br>LPDIRECT3DDEVICE        g_lpD3DDevice = NULL;   // Direct3D device <br>LPDIRECT3DRMDEVICE      g_lpD3DRMDevice = NULL; // Direct3D RM Device <br>LPDIRECT3DRMVIEWPORT    g_lpD3DRMViewport = NULL; // Direct3D RM Viewport <br> <br>DDCAPS                  g_driverCaps;           // Driver capabilities <br>DDCAPS                  g_HELcaps;              // HEL capabilities <br> <br>DWORD                   g_dwZBufferBitDepth = 16;// ZBuffer bit depth <br>DWORD                   g_dwZBufferMemType = DDSCAPS_SYSTEMMEMORY;// Type of ZBuffer <br> <br>LPDIRECTSOUNDBUFFER     g_lpSounds[NUM_SOUNDS]; // Sound buffers <br>LPDIRECTSOUND3DLISTENER      g_lpDs3dListener;               // Listener object for Direct 3D Sound <br>LPDIRECTSOUNDBUFFER             g_3DSoundBuffer;                // Direct Sound buffer for the Listener object <br>LPDIRECTSOUND3DBUFFER   g_lp3dSounds[NUM_SOUNDS];//3D Sound Buffers <br> <br> <br>// State booleans <br>BOOL                    g_bHardware3D = FALSE;  // Do we have hardware? <br>BOOLg_bOutOfVideoMemory = FALSE; // Out of video memory, fall back on software <br> <br>float                   g_xratio = 0.0f;        // X ratio used for computing power bars <br>float                   g_yratio = 0.0f;        // Y ratio used for computing power bars <br> <br>// Power bar x,y and width values <br>DWORD                   g_vidModeX;             // Current X video resolution <br>DWORD                   g_vidModeY;             // Current Y video resolution <br>DWORD                   g_vidModeBIT;           // Current video bit depth <br>DWORD                   g_dwFontHeight = 0; <br>DWORD                   g_dwAveCharWidth = 0; <br>DWORD                   g_lbar1 = 0; <br>DWORD                   g_wbar1 = 0; <br>DWORD                   g_lbar2 = 0; <br>DWORD                   g_wbar2 = 0; <br>DWORD                   g_hbar1 = 0; <br>DWORD                   g_hbar2 = 0; <br> <br>// Externals.... <br>extern HWND                     g_hWnd;         // Defined in WINMAIN.CPP <br>extern BOOL                     g_bSoundPaused; // Defined in WINMAIN.CPP <br>extern LPDIRECT3DRMFRAME        g_lpCamera;     // Defined in RM.CPP <br>extern LPDIRECT3DRMFRAME        g_lpScene;      // Defined in RM.CPP <br>extern LPDIRECT3DRMFRAME        g_lpPlayers;    // Defined in RM.CPP <br>extern LPDIRECT3DRMLIGHT        g_lpDir;        // Defined in RM.CPP <br> <br>//---------------------------------------------------------------------- <br>//  <br>// Function     : TraceErrorDD() <br>// <br>// Purpose      : Traces an error (DirectDraw) <br>// <br>//---------------------------------------------------------------------- <br> <br>void TraceErrorDD(HRESULT hErr, char *sFile, int nLine) <br>{        <br>    char dderr[256]; <br>    char err[1024]; <br> <br>    switch (hErr) <br>    { <br>        case DDERR_ALREADYINITIALIZED : sprintf(dderr, "DDERR_ALREADYINITIALIZED"); break; <br>        case DDERR_CANNOTATTACHSURFACE : sprintf(dderr, "DDERR_CANNOTATTACHSURFACE"); break; <br>        case DDERR_CANNOTDETACHSURFACE : sprintf(dderr, "DDERR_CANNOTDETACHSURFACE"); break; <br>        case DDERR_CURRENTLYNOTAVAIL : sprintf(dderr, "DDERR_CURRENTLYNOTAVAIL"); break; <br>        case DDERR_EXCEPTION : sprintf(dderr, "DDERR_EXCEPTION"); break; <br>        case DDERR_GENERIC : sprintf(dderr, "DDERR_GENERIC"); break; <br>        case DDERR_HEIGHTALIGN : sprintf(dderr, "DDERR_HEIGHTALIGN"); break; <br>        case DDERR_INCOMPATIBLEPRIMARY : sprintf(dderr, "DDERR_INCOMPATIBLEPRIMARY"); break; <br>        case DDERR_INVALIDCAPS : sprintf(dderr, "DDERR_INVALIDCAPS"); break; <br>        case DDERR_INVALIDCLIPLIST : sprintf(dderr, "DDERR_INVALIDCLIPLIST"); break; <br>        case DDERR_INVALIDMODE : sprintf(dderr, "DDERR_INVALIDMODE"); break; <br>        case DDERR_INVALIDOBJECT : sprintf(dderr, "DDERR_INVALIDOBJECT"); break; <br>        case DDERR_INVALIDPARAMS : sprintf(dderr, "DDERR_INVALIDPARAMS"); break; <br>        case DDERR_INVALIDPIXELFORMAT : sprintf(dderr, "DDERR_INVALIDPIXELFORMAT"); break; <br>        case DDERR_INVALIDRECT : sprintf(dderr, "DDERR_INVALIDRECT"); break; <br>        case DDERR_LOCKEDSURFACES : sprintf(dderr, "DDERR_LOCKEDSURFACES"); break; <br>        case DDERR_NO3D : sprintf(dderr, "DDERR_NO3D"); break; <br>        case DDERR_NOALPHAHW : sprintf(dderr, "DDERR_NOALPHAHW"); break; <br>        case DDERR_NOCLIPLIST : sprintf(dderr, "DDERR_NOCLIPLIST"); break; <br>        case DDERR_NOCOLORCONVHW : sprintf(dderr, "DDERR_NOCOLORCONVHW"); break; <br>        case DDERR_NOCOOPERATIVELEVELSET : sprintf(dderr, "DDERR_NOCOOPERATIVELEVELSET"); break; <br>        case DDERR_NOCOLORKEY : sprintf(dderr, "DDERR_NOCOLORKEY"); break; <br>        case DDERR_NOCOLORKEYHW : sprintf(dderr, "DDERR_NOCOLORKEYHW"); break; <br>        case DDERR_NODIRECTDRAWSUPPORT : sprintf(dderr, "DDERR_NODIRECTDRAWSUPPORT"); break; <br>        case DDERR_NOEXCLUSIVEMODE : sprintf(dderr, "DDERR_NOEXCLUSIVEMODE"); break; <br>        case DDERR_NOFLIPHW : sprintf(dderr, "DDERR_NOFLIPHW"); break; <br>        case DDERR_NOGDI : sprintf(dderr, "DDERR_NOGDI"); break; <br>        case DDERR_NOMIRRORHW : sprintf(dderr, "DDERR_NOMIRRORHW"); break; <br>        case DDERR_NOTFOUND : sprintf(dderr, "DDERR_NOTFOUND"); break; <br>        case DDERR_NOOVERLAYHW : sprintf(dderr, "DDERR_NOOVERLAYHW"); break; <br>        case DDERR_NORASTEROPHW : sprintf(dderr, "DDERR_NORASTEROPHW"); break; <br>        case DDERR_NOROTATIONHW : sprintf(dderr, "DDERR_NOROTATIONHW"); break; <br>        case DDERR_NOSTRETCHHW : sprintf(dderr, "DDERR_NOSTRETCHHW"); break; <br>        case DDERR_NOT4BITCOLOR : sprintf(dderr, "DDERR_NOT4BITCOLOR"); break; <br>        case DDERR_NOT4BITCOLORINDEX : sprintf(dderr, "DDERR_NOT4BITCOLORINDEX"); break; <br>        case DDERR_NOT8BITCOLOR : sprintf(dderr, "DDERR_NOT8BITCOLOR"); break; <br>        case DDERR_NOTEXTUREHW : sprintf(dderr, "DDERR_NOTEXTUREHW"); break; <br>        case DDERR_NOVSYNCHW : sprintf(dderr, "DDERR_NOVSYNCHW"); break; <br>        case DDERR_NOZBUFFERHW : sprintf(dderr, "DDERR_NOZBUFFERHW"); break; <br>        case DDERR_NOZOVERLAYHW : sprintf(dderr, "DDERR_NOZOVERLAYHW"); break; <br>        case DDERR_OUTOFCAPS : sprintf(dderr, "DDERR_OUTOFCAPS"); break; <br>        case DDERR_OUTOFMEMORY : sprintf(dderr, "DDERR_OUTOFMEMORY"); break; <br>        case DDERR_OUTOFVIDEOMEMORY : sprintf(dderr, "DDERR_OUTOFVIDEOMEMORY"); break; <br>        case DDERR_OVERLAYCANTCLIP : sprintf(dderr, "DDERR_OVERLAYCANTCLIP"); break; <br>        case DDERR_OVERLAYCOLORKEYONLYONEACTIVE : sprintf(dderr, "DDERR_OVERLAYCOLORKEYONLYONEACTIVE"); break; <br>        case DDERR_PALETTEBUSY : sprintf(dderr, "DDERR_PALETTEBUSY"); break; <br>        case DDERR_COLORKEYNOTSET : sprintf(dderr, "DDERR_COLORKEYNOTSET"); break; <br>        case DDERR_SURFACEALREADYATTACHED : sprintf(dderr, "DDERR_SURFACEALREADYATTACHED"); break; <br>        case DDERR_SURFACEALREADYDEPENDENT : sprintf(dderr, "DDERR_SURFACEALREADYDEPENDENT"); break; <br>        case DDERR_SURFACEBUSY : sprintf(dderr, "DDERR_SURFACEBUSY"); break; <br>        case DDERR_CANTLOCKSURFACE : sprintf(dderr, "DDERR_CANTLOCKSURFACE"); break; <br>        case DDERR_SURFACEISOBSCURED : sprintf(dderr, "DDERR_SURFACEISOBSCURED"); break; <br>        case DDERR_SURFACELOST : sprintf(dderr, "DDERR_SURFACELOST"); break; <br>        case DDERR_SURFACENOTATTACHED : sprintf(dderr, "DDERR_SURFACENOTATTACHED"); break; <br>        case DDERR_TOOBIGHEIGHT : sprintf(dderr, "DDERR_TOOBIGHEIGHT"); break; <br>        case DDERR_TOOBIGSIZE : sprintf(dderr, "DDERR_TOOBIGSIZE"); break; <br>        case DDERR_TOOBIGWIDTH : sprintf(dderr, "DDERR_TOOBIGWIDTH"); break; <br>        case DDERR_UNSUPPORTED : sprintf(dderr, "DDERR_UNSUPPORTED"); break; <br>        case DDERR_UNSUPPORTEDFORMAT : sprintf(dderr, "DDERR_UNSUPPORTEDFORMAT"); break; <br>        case DDERR_UNSUPPORTEDMASK : sprintf(dderr, "DDERR_UNSUPPORTEDMASK"); break; <br>        case DDERR_VERTICALBLANKINPROGRESS : sprintf(dderr, "DDERR_VERTICALBLANKINPROGRESS"); break; <br>        case DDERR_WASSTILLDRAWING : sprintf(dderr, "DDERR_WASSTILLDRAWING"); break; <br>        case DDERR_XALIGN : sprintf(dderr, "DDERR_XALIGN"); break; <br>        case DDERR_INVALIDDIRECTDRAWGUID : sprintf(dderr, "DDERR_INVALIDDIRECTDRAWGUID"); break; <br>        case DDERR_DIRECTDRAWALREADYCREATED : sprintf(dderr, "DDERR_DIRECTDRAWALREADYCREATED"); break; <br>        case DDERR_NODIRECTDRAWHW : sprintf(dderr, "DDERR_NODIRECTDRAWHW"); break; <br>        case DDERR_PRIMARYSURFACEALREADYEXISTS : sprintf(dderr, "DDERR_PRIMARYSURFACEALREADYEXISTS"); break; <br>        case DDERR_NOEMULATION : sprintf(dderr, "DDERR_NOEMULATION"); break; <br>        case DDERR_REGIONTOOSMALL : sprintf(dderr, "DDERR_REGIONTOOSMALL"); break; <br>        case DDERR_CLIPPERISUSINGHWND : sprintf(dderr, "DDERR_CLIPPERISUSINGHWND"); break; <br>        case DDERR_NOCLIPPERATTACHED : sprintf(dderr, "DDERR_NOCLIPPERATTACHED"); break; <br>        case DDERR_NOHWND : sprintf(dderr, "DDERR_NOHWND"); break; <br>        case DDERR_HWNDSUBCLASSED : sprintf(dderr, "DDERR_HWNDSUBCLASSED"); break; <br>        case DDERR_HWNDALREADYSET : sprintf(dderr, "DDERR_HWNDALREADYSET"); break; <br>        case DDERR_NOPALETTEATTACHED : sprintf(dderr, "DDERR_NOPALETTEATTACHED"); break; <br>        case DDERR_NOPALETTEHW : sprintf(dderr, "DDERR_NOPALETTEHW"); break; <br>        case DDERR_BLTFASTCANTCLIP : sprintf(dderr, "DDERR_BLTFASTCANTCLIP"); break; <br>        case DDERR_NOBLTHW : sprintf(dderr, "DDERR_NOBLTHW"); break; <br>        case DDERR_NODDROPSHW : sprintf(dderr, "DDERR_NODDROPSHW"); break; <br>        case DDERR_OVERLAYNOTVISIBLE : sprintf(dderr, "DDERR_OVERLAYNOTVISIBLE"); break; <br>        case DDERR_NOOVERLAYDEST : sprintf(dderr, "DDERR_NOOVERLAYDEST"); break; <br>        case DDERR_INVALIDPOSITION : sprintf(dderr, "DDERR_INVALIDPOSITION"); break; <br>        case DDERR_NOTAOVERLAYSURFACE : sprintf(dderr, "DDERR_NOTAOVERLAYSURFACE"); break; <br>        case DDERR_EXCLUSIVEMODEALREADYSET : sprintf(dderr, "DDERR_EXCLUSIVEMODEALREADYSET"); break; <br>        case DDERR_NOTFLIPPABLE : sprintf(dderr, "DDERR_NOTFLIPPABLE"); break; <br>        case DDERR_CANTDUPLICATE : sprintf(dderr, "DDERR_CANTDUPLICATE"); break; <br>        case DDERR_NOTLOCKED : sprintf(dderr, "DDERR_NOTLOCKED"); break; <br>        case DDERR_CANTCREATEDC : sprintf(dderr, "DDERR_CANTCREATEDC"); break; <br>        case DDERR_NODC : sprintf(dderr, "DDERR_NODC"); break; <br>        case DDERR_WRONGMODE : sprintf(dderr, "DDERR_WRONGMODE"); break; <br>        case DDERR_IMPLICITLYCREATED : sprintf(dderr, "DDERR_IMPLICITLYCREATED"); break; <br>        case DDERR_NOTPALETTIZED : sprintf(dderr, "DDERR_NOTPALETTIZED"); break; <br>        case DDERR_UNSUPPORTEDMODE : sprintf(dderr, "DDERR_UNSUPPORTEDMODE"); break; <br>        case DDERR_NOMIPMAPHW : sprintf(dderr, "DDERR_NOMIPMAPHW"); break; <br>        case DDERR_INVALIDSURFACETYPE : sprintf(dderr, "DDERR_INVALIDSURFACETYPE"); break; <br>        case DDERR_DCALREADYCREATED : sprintf(dderr, "DDERR_DCALREADYCREATED"); break; <br>        case DDERR_CANTPAGELOCK : sprintf(dderr, "DDERR_CANTPAGELOCK"); break; <br>        case DDERR_CANTPAGEUNLOCK : sprintf(dderr, "DDERR_CANTPAGEUNLOCK"); break; <br>        case DDERR_NOTPAGELOCKED : sprintf(dderr, "DDERR_NOTPAGELOCKED"); break; <br>        case DDERR_NOTINITIALIZED : sprintf(dderr, "DDERR_NOTINITIALIZED"); break; <br> <br>        default : sprintf(dderr, "Unknown Error"); break; <br>    } <br>    sprintf(err, "DirectDraw Error %s\nin file %s at line %d", dderr, sFile, nLine); <br>    RegError(err); <br>} <br> <br>//---------------------------------------------------------------------- <br>//  <br>// Function     : TraceErrorDS() <br>// <br>// Purpose      : Traces an error (DirectSound) <br>// <br>//---------------------------------------------------------------------- <br> <br>void TraceErrorDS(HRESULT hErr, char *sFile, int nLine) <br>{        <br>    char dserr[256]; <br>    char err[1024]; <br> <br>    switch (hErr) <br>    { <br>        case DSERR_ALLOCATED : sprintf(dserr, "DSERR_ALLOCATED"); break; <br>        case DSERR_CONTROLUNAVAIL : sprintf(dserr, "DSERR_CONTROLUNAVAIL"); break; <br>        case DSERR_INVALIDPARAM : sprintf(dserr, "DSERR_INVALIDPARAM"); break; <br>        case DSERR_INVALIDCALL : sprintf(dserr, "DSERR_INVALIDCALL"); break; <br>        case DSERR_GENERIC : sprintf(dserr, "DSERR_GENERIC"); break; <br>        case DSERR_PRIOLEVELNEEDED : sprintf(dserr, "DSERR_PRIOLEVELNEEDED"); break; <br>        case DSERR_OUTOFMEMORY : sprintf(dserr, "DSERR_OUTOFMEMORY"); break; <br>        case DSERR_BADFORMAT : sprintf(dserr, "DSERR_BADFORMAT"); break; <br>        case DSERR_UNSUPPORTED : sprintf(dserr, "DSERR_UNSUPPORTED"); break; <br>        case DSERR_NODRIVER : sprintf(dserr, "DSERR_NODRIVER"); break; <br>        case DSERR_ALREADYINITIALIZED : sprintf(dserr, "DSERR_ALREADYINITIALIZED"); break; <br>        case DSERR_NOAGGREGATION : sprintf(dserr, "DSERR_NOAGGREGATION"); break; <br>        case DSERR_BUFFERLOST : sprintf(dserr, "DSERR_BUFFERLOST"); break; <br>        case DSERR_OTHERAPPHASPRIO : sprintf(dserr, "DSERR_OTHERAPPHASPRIO"); break; <br>        case DSERR_UNINITIALIZED : sprintf(dserr, "DSERR_UNINITIALIZED"); break; <br> <br>        default : sprintf(dserr, "Unknown Error"); break; <br>    } <br>    sprintf(err, "DirectSound Error %s\nin file %s at line %d", dserr, sFile, nLine); <br>    RegError(err); <br>} <br> <br>//---------------------------------------------------------------------- <br>//  <br>// Function     : TraceErrorD3D() <br>// <br>// Purpose      : Traces an error (Direct3D) <br>// <br>//---------------------------------------------------------------------- <br> <br>void TraceErrorD3D(HRESULT hErr, char *sFile, int nLine) <br>{        <br>    char d3derr[256]; <br>    char err[1024]; <br> <br>    switch (hErr) <br>    { <br>        case D3DERR_BADMAJORVERSION : sprintf(d3derr, "D3DERR_BADMAJORVERSION"); break; <br>        case D3DERR_BADMINORVERSION : sprintf(d3derr, "D3DERR_BADMINORVERSION"); break; <br>        case D3DERR_EXECUTE_CREATE_FAILED : sprintf(d3derr, "D3DERR_EXECUTE_CREATE_FAILED"); break; <br>        case D3DERR_EXECUTE_DESTROY_FAILED : sprintf(d3derr, "D3DERR_EXECUTE_DESTROY_FAILED"); break; <br>        case D3DERR_EXECUTE_LOCK_FAILED : sprintf(d3derr, "D3DERR_EXECUTE_LOCK_FAILED"); break; <br>        case D3DERR_EXECUTE_UNLOCK_FAILED : sprintf(d3derr, "D3DERR_EXECUTE_UNLOCK_FAILED"); break; <br>        case D3DERR_EXECUTE_LOCKED : sprintf(d3derr, "D3DERR_EXECUTE_LOCKED"); break; <br>        case D3DERR_EXECUTE_NOT_LOCKED : sprintf(d3derr, "D3DERR_EXECUTE_NOT_LOCKED"); break; <br>        case D3DERR_EXECUTE_FAILED : sprintf(d3derr, "D3DERR_EXECUTE_FAILED"); break; <br>        case D3DERR_EXECUTE_CLIPPED_FAILED : sprintf(d3derr, "D3DERR_EXECUTE_CLIPPED_FAILED"); break; <br>        case D3DERR_TEXTURE_NO_SUPPORT : sprintf(d3derr, "D3DERR_TEXTURE_NO_SUPPORT"); break; <br>        case D3DERR_TEXTURE_CREATE_FAILED : sprintf(d3derr, "D3DERR_TEXTURE_CREATE_FAILED"); break; <br>        case D3DERR_TEXTURE_DESTROY_FAILED : sprintf(d3derr, "D3DERR_TEXTURE_DESTROY_FAILED"); break; <br>        case D3DERR_TEXTURE_LOCK_FAILED : sprintf(d3derr, "D3DERR_TEXTURE_LOCK_FAILED"); break; <br>        case D3DERR_TEXTURE_UNLOCK_FAILED : sprintf(d3derr, "D3DERR_TEXTURE_UNLOCK_FAILED"); break; <br>        case D3DERR_TEXTURE_LOAD_FAILED : sprintf(d3derr, "D3DERR_TEXTURE_LOAD_FAILED"); break; <br>        case D3DERR_TEXTURE_SWAP_FAILED : sprintf(d3derr, "D3DERR_TEXTURE_SWAP_FAILED"); break; <br>        case D3DERR_TEXTURE_LOCKED : sprintf(d3derr, "D3DERR_TEXTURE_LOCKED"); break; <br>        case D3DERR_TEXTURE_NOT_LOCKED : sprintf(d3derr, "D3DERR_TEXTURE_NOT_LOCKED"); break; <br>        case D3DERR_TEXTURE_GETSURF_FAILED : sprintf(d3derr, "D3DERR_TEXTURE_GETSURF_FAILED"); break; <br>        case D3DERR_MATRIX_CREATE_FAILED : sprintf(d3derr, "D3DERR_MATRIX_CREATE_FAILED"); break; <br>        case D3DERR_MATRIX_DESTROY_FAILED : sprintf(d3derr, "D3DERR_MATRIX_DESTROY_FAILED"); break; <br>        case D3DERR_MATRIX_SETDATA_FAILED : sprintf(d3derr, "D3DERR_MATRIX_SETDATA_FAILED"); break; <br>        case D3DERR_MATRIX_GETDATA_FAILED : sprintf(d3derr, "D3DERR_MATRIX_GETDATA_FAILED"); break; <br>        case D3DERR_SETVIEWPORTDATA_FAILED : sprintf(d3derr, "D3DERR_SETVIEWPORTDATA_FAILED"); break; <br>        case D3DERR_MATERIAL_CREATE_FAILED : sprintf(d3derr, "D3DERR_MATERIAL_CREATE_FAILED"); break; <br>        case D3DERR_MATERIAL_DESTROY_FAILED : sprintf(d3derr, "D3DERR_MATERIAL_DESTROY_FAILED"); break; <br>        case D3DERR_MATERIAL_SETDATA_FAILED : sprintf(d3derr, "D3DERR_MATERIAL_SETDATA_FAILED"); break; <br>        case D3DERR_MATERIAL_GETDATA_FAILED : sprintf(d3derr, "D3DERR_MATERIAL_GETDATA_FAILED"); break; <br>        case D3DERR_LIGHT_SET_FAILED : sprintf(d3derr, "D3DERR_LIGHT_SET_FAILED"); break; <br>        case D3DERR_SCENE_IN_SCENE : sprintf(d3derr, "D3DERR_SCENE_IN_SCENE"); break; <br>        case D3DERR_SCENE_NOT_IN_SCENE : sprintf(d3derr, "D3DERR_SCENE_NOT_IN_SCENE"); break; <br>        case D3DERR_SCENE_BEGIN_FAILED : sprintf(d3derr, "D3DERR_SCENE_BEGIN_FAILED"); break; <br>        case D3DERR_SCENE_END_FAILED : sprintf(d3derr, "D3DERR_SCENE_END_FAILED"); break; <br> <br>        default : sprintf(d3derr, "Unknown Error"); break; <br>    } <br>    sprintf(err, "Direct3D Error %s\nin file %s at line %d", d3derr, sFile, nLine); <br>    RegError(err); <br>} <br> <br>//---------------------------------------------------------------------- <br>//  <br>// Function     : TraceErrorD3DRM() <br>// <br>// Purpose      : Traces an error (Direct3D retained mode) <br>// <br>//---------------------------------------------------------------------- <br> <br>void TraceErrorD3DRM(HRESULT hErr, char *sFile, int nLine) <br>{        <br>    char d3drmerr[256]; <br>    char err[1024]; <br> <br>    switch (hErr) <br>    { <br>        case D3DRMERR_BADOBJECT : sprintf(d3drmerr, "D3DRMERR_BADOBJECT"); break; <br>        case D3DRMERR_BADTYPE : sprintf(d3drmerr, "D3DRMERR_BADTYPE"); break; <br>        case D3DRMERR_BADALLOC : sprintf(d3drmerr, "D3DRMERR_BADALLOC"); break; <br>        case D3DRMERR_FACEUSED : sprintf(d3drmerr, "D3DRMERR_FACEUSED"); break; <br>        case D3DRMERR_NOTFOUND : sprintf(d3drmerr, "D3DRMERR_NOTFOUND"); break; <br>        case D3DRMERR_NOTDONEYET : sprintf(d3drmerr, "D3DRMERR_NOTDONEYET"); break; <br>        case D3DRMERR_FILENOTFOUND : sprintf(d3drmerr, "D3DRMERR_FILENOTFOUND"); break; <br>        case D3DRMERR_BADFILE : sprintf(d3drmerr, "D3DRMERR_BADFILE"); break; <br>        case D3DRMERR_BADDEVICE : sprintf(d3drmerr, "D3DRMERR_BADDEVICE"); break; <br>        case D3DRMERR_BADVALUE : sprintf(d3drmerr, "D3DRMERR_BADVALUE"); break; <br>        case D3DRMERR_BADMAJORVERSION : sprintf(d3drmerr, "D3DRMERR_BADMAJORVERSION"); break; <br>        case D3DRMERR_BADMINORVERSION : sprintf(d3drmerr, "D3DRMERR_BADMINORVERSION"); break; <br>        case D3DRMERR_UNABLETOEXECUTE : sprintf(d3drmerr, "D3DRMERR_UNABLETOEXECUTE"); break; <br> <br>        default : sprintf(d3drmerr, "Unknown Error"); break; <br>    } <br>    sprintf(err, "Direct3D-RM Error : %s\nin file %s at line %d", d3drmerr, sFile, nLine); <br>    RegError(err); <br>} <br> <br>//---------------------------------------------------------------------- <br>//  <br>// Function     : SortDisplayModes() <br>// <br>// Purpose      : Sorts the list of display modes <br>// <br>//---------------------------------------------------------------------- <br> <br>void SortDisplayModes() <br>{ <br>    // Sort by width * height <br>    for (DWORD i = 0; i &lt; g_dwNumModes; i ++) <br>    { <br>        for (DWORD k = 0; k &lt; g_dwNumModes - 1; k ++) <br>        { <br>            int c1 = g_vidModes[k].width * g_vidModes[k].height; <br>            int c2 = g_vidModes[k + 1].width * g_vidModes[k + 1].height; <br> <br>            if (c1 &gt; c2) <br>            { <br>                VideoMode tmp; <br>                 <br>                // Swap the two video modes <br>                tmp                     = g_vidModes[k]; <br>                g_vidModes[k]           = g_vidModes[k + 1]; <br>                g_vidModes[k + 1]       = tmp; <br> <br>                // Keep g_dwCurrMode up to date <br>                if (g_dwCurrMode == k) <br>                { <br>                    g_dwCurrMode = k + 1; <br>                } <br>                else if (g_dwCurrMode == k + 1) <br>                { <br>                    g_dwCurrMode = k; <br>                } <br>            } <br>        } <br>    } <br>} <br> <br>//---------------------------------------------------------------------- <br>//  <br>// Function     : DDEnumCallBack() <br>// <br>// Purpose      : Call back to enumerate installed DirectDraw devices <br>// <br>//---------------------------------------------------------------------- <br> <br>BOOL FAR PASCAL DDEnumCallback(GUID FAR* lpGUID, LPSTR lpDriverDesc, LPSTR lpDriverName, LPVOID lpContext) <br>{ <br>    LPDIRECTDRAW lpDD; <br>    DDCAPS DriverCaps, HELCaps; <br> <br>        // Make sure the guid is valid <br>    if (lpGUID)  <br>    { <br>        // Try to create a DirectDraw object <br>        TRY_DD(DirectDrawCreate(lpGUID, &amp;lpDD, NULL)) <br>         <br>        // Get the DirectDraw capabilities <br>        memset(&amp;DriverCaps, 0, sizeof(DDCAPS)); <br>        DriverCaps.dwSize = sizeof(DDCAPS); <br>         <br>        memset(&amp;HELCaps, 0, sizeof(DDCAPS)); <br>        HELCaps.dwSize = sizeof(DDCAPS); <br>         <br>        TRY_DD(lpDD-&gt;GetCaps(&amp;DriverCaps, &amp;HELCaps)) <br> <br>        // Does this driver have 3D hardware capabilites? <br>        if (DriverCaps.dwCaps &amp; DDCAPS_3D)  <br>        { <br>            *(LPDIRECTDRAW*)lpContext = lpDD; <br>            return DDENUMRET_CANCEL; <br>        } <br> <br>        *(LPDIRECTDRAW*)lpContext = NULL; <br>        lpDD-&gt;Release(); <br>    } <br> <br>        // Yahoo! <br>    return DDENUMRET_OK; <br>} <br> <br>//---------------------------------------------------------------------- <br>//  <br>// Function     : DDEnumDisplayModesCallBack() <br>// <br>// Purpose      : Call back function to receive display mode information <br>// <br>//---------------------------------------------------------------------- <br> <br>HRESULT CALLBACK DDEnumDisplayModesCallback(LPDDSURFACEDESC pddsd, LPVOID Context) <br>{        <br>    // While each mode gets enumerated we have to decide whether  <br>    // the 3D device and mode are compatible <br>    if (g_deviceInfo.lpHWGuid) <br>    {            <br>        // Make sure there is enough video ram to support this mode <br>        //if hardware is in use <br>        DWORD dwBitDepthMultiplier; <br>         <br>        switch(pddsd-&gt;ddpfPixelFormat.dwRGBBitCount) <br>        { <br>            case 8  : dwBitDepthMultiplier = 1; break; <br>            case 16 : dwBitDepthMultiplier = 2; break; <br>            case 24 : dwBitDepthMultiplier = 3; break; <br>            case 32 : dwBitDepthMultiplier = 4; break; <br>        } <br> <br>        DWORD dwVidRamNeeded = ((pddsd-&gt;dwWidth * pddsd-&gt;dwHeight) * dwBitDepthMultiplier) * 3; <br> <br>        if (dwVidRamNeeded &gt; (g_driverCaps.dwVidMemFree + g_dwGDIMem)) <br>          return DDENUMRET_OK; <br> <br>        // Make sure the Direct3D device can render at a given bit depth <br>        switch (pddsd-&gt;ddpfPixelFormat.dwRGBBitCount) <br>        { <br>            case 8 :  <br>            { <br>                if (!(g_deviceInfo.HWDeviceDesc.dwDeviceRenderBitDepth &amp; DDBD_8)) return DDENUMRET_OK; <br>            } <br>            break; <br> <br>            case 16 : <br>            { <br>                if (!(g_deviceInfo.HWDeviceDesc.dwDeviceRenderBitDepth &amp; DDBD_16)) return DDENUMRET_OK; <br>            } <br>            break; <br> <br>            case 24 :  <br>            { <br>                if (!(g_deviceInfo.HWDeviceDesc.dwDeviceRenderBitDepth &amp; DDBD_24)) return DDENUMRET_OK; <br>            } <br>            break; <br> <br>            case 32 : <br>            { <br>                if (!(g_deviceInfo.HWDeviceDesc.dwDeviceRenderBitDepth &amp; DDBD_32)) return DDENUMRET_OK; <br>            } <br>            break; <br>        } <br> <br>        // If we have hardware, start up in 640x480x16 if possible <br>        if ((pddsd-&gt;dwWidth == 640) &amp;&amp; (pddsd-&gt;dwHeight == 480) &amp;&amp; (pddsd-&gt;ddpfPixelFormat.dwRGBBitCount == 16)) <br>        { <br>            g_dwCurrMode = g_dwNumModes; <br>        } <br>    } <br> <br>    // Record the video mode information <br>    g_vidModes[g_dwNumModes].width  = pddsd-&gt;dwWidth; <br>    g_vidModes[g_dwNumModes].height = pddsd-&gt;dwHeight; <br>    g_vidModes[g_dwNumModes].bpp    = pddsd-&gt;ddpfPixelFormat.dwRGBBitCount; <br>     <br>    g_dwNumModes ++; <br>             <br>    return DDENUMRET_OK; <br>} <br> <br>//------------------------------------------------------------------ <br>//  <br>// Function     : D3DEnumDriverCallBack() <br>// <br>// Purpose      : Enumeration Function <br>// <br>//------------------------------------------------------------------ <br> <br>HRESULT WINAPI D3DEnumDeviceCallBack(LPGUID lpGuid,      <br>                                     LPSTR lpDeviceDescription, <br>                                     LPSTR lpDeviceName, <br>                                     LPD3DDEVICEDESC lpHWDesc,  <br>                                     LPD3DDEVICEDESC lpHELDesc,  <br>                                     LPVOID lpContext) <br>{ <br>    static BOOL bFoundHardwareDevice = FALSE;    <br> <br>    // No need to enumerate if we already found the device that supports <br>    if (bFoundHardwareDevice) return D3DENUMRET_OK; <br> <br>    D3DDeviceInfo* pInfo = (D3DDeviceInfo *)lpContext; <br>     <br>    // Is this a hardware device? <br>    if (lpHWDesc-&gt;dcmColorModel &amp; pInfo-&gt;cm) <br>    { <br>        // Driver needs to pass some tests.... <br> <br>        // Make sure the driver has ZBuffering capabilities <br>        if ((lpHWDesc-&gt;dwDeviceZBufferBitDepth &amp; DDBD_16) ||  <br>            (lpHWDesc-&gt;dwDeviceZBufferBitDepth &amp; DDBD_24) || <br>            (lpHWDesc-&gt;dwDeviceZBufferBitDepth &amp; DDBD_32)) <br>        {                                        <br>            // Record the HAL description for later use <br>            memcpy(&amp;pInfo-&gt;HWDeviceDesc, lpHWDesc, sizeof(D3DDEVICEDESC)); <br> <br>            // Record the guid for later use <br>            pInfo-&gt;lpHWGuid = lpGuid; <br>             <br>            // No need to keep looking for any more devices <br>            bFoundHardwareDevice = TRUE; <br>        } <br>         <br>        // Yahoo! <br>        return D3DENUMRET_OK; <br>    } <br> <br>    // Is this a software device? <br>    if (lpHELDesc-&gt;dcmColorModel &amp; pInfo-&gt;cm)  <br>    { <br>        // Record the HEL description for later use <br>        memcpy(&amp;pInfo-&gt;SWDeviceDesc, lpHELDesc, sizeof(D3DDEVICEDESC)); <br>             <br>        // Record the guid for later use <br>        pInfo-&gt;lpSWGuid = lpGuid; <br>             <br>        g_lpD3DDeviceGuid = lpGuid; <br>    } <br> <br>    return D3DENUMRET_OK; <br>} <br> <br>//---------------------------------------------------------------------- <br>//  <br>// Function     : InitD3DDevice() <br>// <br>// Purpose      : Performs initialisation for correct Direct3D device <br>//                        RGB, MONO, HAL etc <br>// <br>//---------------------------------------------------------------------- <br> <br>BOOL InitD3DDevice() <br>{ <br>    memset(&amp;g_deviceInfo, 0, sizeof(D3DDeviceInfo)); <br> <br>    // Use RGB colour if in hardware, RAMP if in software        <br> <br>    // Record the colour model that we wish to search for in the structure passed <br>    // to the enumeration call back <br>    g_deviceInfo.cm = g_bHardware3D ? D3DCOLOR_RGB : D3DCOLOR_MONO;; <br>     <br>    // Enumerate the drivers <br>    TRY_D3D(g_lpD3D-&gt;EnumDevices(D3DEnumDeviceCallBack, &amp;g_deviceInfo))  <br> <br>    // Test to see whether we have hardware or software <br>    if (g_deviceInfo.lpHWGuid) <br>    { <br>        // We have a hardware driver! <br> <br>        // Use a video memory based ZBuffer <br>        g_dwZBufferMemType = DDSCAPS_VIDEOMEMORY; <br> <br>        // Use 16 bit ZBuffering if possible, higher if not <br>        if (g_deviceInfo.HWDeviceDesc.dwDeviceZBufferBitDepth &amp; DDBD_16) <br>        { <br>            g_dwZBufferBitDepth = 16; <br>        } <br>        else if (g_deviceInfo.HWDeviceDesc.dwDeviceZBufferBitDepth &amp; DDBD_24) <br>        { <br>            g_dwZBufferBitDepth = 24; <br>        } <br>        else if (g_deviceInfo.HWDeviceDesc.dwDeviceZBufferBitDepth &amp; DDBD_32) <br>        { <br>            g_dwZBufferBitDepth = 32; <br>        } <br>        else <br>        { <br>            g_dwZBufferBitDepth = 0; <br>        } <br>         <br>        // Use Hardware device <br>        g_lpD3DDeviceGuid = g_deviceInfo.lpHWGuid; <br>    } <br>    else <br>    { <br>        // We have a software driver! <br> <br>        // Use a system memory based ZBuffer <br>        g_dwZBufferMemType = DDSCAPS_SYSTEMMEMORY; <br> <br>        // And force the bit depth to 16 <br>        g_dwZBufferBitDepth = 16; <br> <br>        // Default to the software device <br>        g_lpD3DDeviceGuid = g_deviceInfo.lpSWGuid; <br>    } <br> <br>    // Yahoo! <br>    return TRUE; <br>} <br> <br>//---------------------------------------------------------------------- <br>//  <br>// Function     : InitDirectX() <br>// <br>// Purpose      : Initialises DirectX (DirectDraw, Direct3D, Direct3DRM, DirectSound) <br>// <br>//---------------------------------------------------------------------- <br> <br>BOOL InitDirectX() <br>{ <br>    FILE        *fp; <br>    BYTE        pal[768]; </code></pre>
<p>
</p>
<pre><code>HRESULT     rval; <br>    DDSURFACEDESC ddsd; <br> <br>    // Enumerate DirectDraw drivers to see what is installed, preferring one with <br>    // Hardware 3D capabilities <br>    TRY_DD(DirectDrawEnumerate(DDEnumCallback, &amp;g_lpDD)) <br> <br>    // If g_lpDD is NULL, there isn't a DirectDraw device with hardware 3D capabilities, <br>    // so create a device using the HEL  <br>    if (!g_lpDD) <br>    { <br>            TRY_DD(DirectDrawCreate(NULL, &amp;g_lpDD, NULL)) <br>    } <br> <br>    // NOTE : Exclusive mode would normally be set here but because of the splash <br>    // screen being displayed it isn't. The reason is that the splash screen uses <br>    // 640x480x8 and that mode may not be available if we are using a hardware 3D <br>    // DirectDraw device. <br> <br>    // Zero out caps structures <br>    memset(&amp;g_driverCaps, 0, sizeof(DDCAPS)); <br>    g_driverCaps.dwSize = sizeof(DDCAPS); <br> <br>    memset(&amp;g_HELcaps, 0, sizeof(DDCAPS)); <br>    g_HELcaps.dwSize = sizeof(DDCAPS); <br> <br>    // Get the current display mode as we can use that memory when full <br>    // screen exclusive <br>    memset(&amp;ddsd, 0, sizeof ddsd); <br>    ddsd.dwSize = sizeof ddsd; <br>    TRY_DD(g_lpDD-&gt;GetDisplayMode(&amp;ddsd)); <br>    g_dwGDIMem = ddsd.lPitch * ddsd.dwHeight * <br>      (ddsd.ddpfPixelFormat.dwRGBBitCount / 8); <br> <br>    // Get hardware capabilities <br>    TRY_DD(g_lpDD-&gt;GetCaps(&amp;g_driverCaps, &amp;g_HELcaps)); <br> <br>    // Global to determine whether we have hardware 3D capabilities or not <br>    g_bHardware3D = g_driverCaps.dwCaps &amp; DDCAPS_3D; <br> <br>    // Create Direct3D object <br>    TRY_D3D(g_lpDD-&gt;QueryInterface(IID_IDirect3D, (LPVOID *)&amp;g_lpD3D)); <br> <br>    // Enumerate Direct3D devices, preferring hardware rendering over software <br>    if (!InitD3DDevice()) <br>    { <br>            RegError("Error locating suitable Direct3D driver!"); <br>            return FALSE; <br>    } <br> <br>    // Enumerate all the display modes, this is done after locating the 3D device so <br>    // that any mode that is not compatible with the 3D device does not get added to <br>    // the list of valid modes. <br>    TRY_DD(g_lpDD-&gt;EnumDisplayModes(0, NULL, NULL, DDEnumDisplayModesCallback)) <br> <br>    // Sort display modes into lowest width * height first <br>    SortDisplayModes(); <br> <br>    // Create Direct3D RM object <br>    TRY_D3DRM(Direct3DRMCreate(&amp;g_lpD3DRM)) <br> <br>    // Set default amount of texture colours <br>    g_lpD3DRM-&gt;SetDefaultTextureColors(16); <br>     <br>    // Set default amount of texture shades <br>    g_lpD3DRM-&gt;SetDefaultTextureShades(16); <br> <br>    // Create DirectSound object <br>    rval = DirectSoundCreate(NULL, &amp;g_lpDS, NULL); <br>     <br>    // Determine whether sound is present <br>    g_bSoundPresent = rval == DS_OK ? TRUE : FALSE; <br> <br>    if (g_bSoundPresent) <br>    { <br>        // Set the DirectSound cooperative level <br>        TRY_DS(g_lpDS-&gt;SetCooperativeLevel(g_hWnd, DSSCL_NORMAL)) <br> <br>                // Create the Direct 3D Sound Buffer <br>                g_3DSoundBuffer = CreateSoundBuffer3D(); <br>                if(g_3DSoundBuffer == NULL) <br>                { <br>                        RegError("Not able to create Direct 3D Sound Buffer"); <br>            return FALSE; <br>                } <br>                // Query interface for Direct 3D Sound Listener object <br>                if(DS_OK != g_3DSoundBuffer-&gt;QueryInterface(IID_IDirectSound3DListener, (void**)&amp;g_lpDs3dListener)) <br>                { <br>                        RegError("Not able to create Direct 3D Sound Listener object"); <br>            return FALSE; <br>                } <br>                // Set the Direct 3D Sound Rolloff Factor <br>                g_lpDs3dListener-&gt;SetRolloffFactor((FLOAT).01,DS3D_DEFERRED); <br>                // Change listener's orientation <br>                g_lpDs3dListener-&gt;SetOrientation(-D3DVAL(1), D3DVAL(0), D3DVAL(0), D3DVAL(0), D3DVAL(1), D3DVAL(0),DS3D_DEFERRED); <br>                // Commit the changes to Rolloff Factor and orientation <br>                g_lpDs3dListener-&gt;CommitDeferredSettings(); <br> <br>        // Null out all the sound pointers <br>        for (int i = 0; i &lt; NUM_SOUNDS; i ++) <br>        { <br>            g_lpSounds[i] = NULL; <br>        } <br> <br>        // Load the sounds       <br>        if (!CreateBufferFromWaveFile("INTRO.WAV", INTRO)) <br>        { <br>            RegError("Couldn't load INTRO.WAV!"); <br>            return FALSE; <br>        } <br>         <br>        if (!CreateBufferFromWaveFile("PUNCH1.WAV", PLAYER1_PUNCH1)) <br>        { <br>            RegError("Couldn't load PUNCH1.WAV!"); <br>            return FALSE; <br>        } <br>         <br>        if (!CreateBufferFromWaveFile("PUNCH3.WAV", PLAYER1_PUNCH2)) <br>        { <br>            RegError("Couldn't load PUNCH3.WAV!"); <br>            return FALSE; <br>        } <br>         <br>        if (!CreateBufferFromWaveFile("PUNCH2.WAV", PLAYER2_PUNCH1)) <br>        { <br>            RegError("Couldn't load PUNCH2.WAV!"); <br>            return FALSE; <br>        } <br> <br>        if (!CreateBufferFromWaveFile("PUNCH4.WAV", PLAYER2_PUNCH2))     <br>        { <br>            RegError("Couldn't load PUNCH4.WAV!"); <br>            return FALSE; <br>        } <br>         <br>        if (!CreateBufferFromWaveFile("WALK0.WAV", PLAYER1_WALK)) <br>        { <br>            RegError("Couldn't load WALK0.WAV!"); <br>            return FALSE; <br>        } <br> <br>        if (!CreateBufferFromWaveFile("WALK1.WAV", PLAYER2_WALK)) <br>        { <br>            RegError("Couldn't load WALK1.WAV!"); <br>            return FALSE; <br>        } <br> <br>        if (!CreateBufferFromWaveFile("WHOOSH1.WAV", WHOOSH1))   <br>        { <br>            RegError("Couldn't load WHOOSH1.WAV!"); <br>            return FALSE; <br>        } <br>         <br>        if (!CreateBufferFromWaveFile("WHOOSH2.WAV", WHOOSH2)) <br>        { <br>            RegError("Couldn't load WHOOSH2.WAV!"); <br>            return FALSE; <br>        } <br> <br>        if (!CreateBufferFromWaveFile("DEFEND1.WAV", PLAYER1_OUCH)) <br>        { <br>            RegError("Couldn't load DEFEND1.WAV!"); <br>            return FALSE; <br>        } <br> <br>        if (!CreateBufferFromWaveFile("DEFEND2.WAV", PLAYER2_OUCH)) <br>        { <br>            RegError("Couldn't load DEFEND2.WAV!"); <br>            return FALSE; <br>        } <br>         <br>        if (!CreateBufferFromWaveFile("HEAD.WAV", HEAD_SPRING)) <br>        { <br>            RegError("Couldn't load HEAD.WAV!"); <br>            return FALSE; <br>        } <br> <br>        if (!CreateBufferFromWaveFile("BLOCK1.WAV", BLOCK1)) <br>        { <br>            RegError("Couldn't load BLOCK1.WAV!"); <br>            return FALSE; <br>        } <br> <br>        if (!CreateBufferFromWaveFile("BLOCK2.WAV", BLOCK2)) <br>        { <br>            RegError("Couldn't load BLOCK2.WAV!"); <br>            return FALSE; <br>        } <br>         <br>        if (!CreateBufferFromWaveFile("BLOCK3.WAV", BLOCK3)) <br>        { <br>            RegError("Couldn't load BLOCK3.WAV!"); <br>            return FALSE; <br>        } <br>         <br>        if (!CreateBufferFromWaveFile("CLOOP.WAV", CROWD_LOOP)) <br>        { <br>            RegError("Couldn't load CLOOP.WAV!"); <br>            return FALSE; <br>        } <br>         <br>        if (!CreateBufferFromWaveFile("CBOO.WAV", VICTORY_BOO)) <br>        { <br>            RegError("Couldn't load CBOO.WAV!"); <br>            return FALSE; <br>        } <br>         <br>        if (!CreateBufferFromWaveFile("CYEAH.WAV", VICTORY_YEAH)) <br>        { <br>            RegError("Couldn't load CYEAH.WAV!"); <br>            return FALSE; <br>        } <br> <br>        if (!CreateBufferFromWaveFile("REVUP1.WAV", SERVO_UP_1)) <br>        { <br>            RegError("Couldn't load REVUP1.WAV!"); <br>            return FALSE; <br>        } <br>         <br>        if (!CreateBufferFromWaveFile("REVUP2.WAV", SERVO_UP_2)) <br>        { <br>            RegError("Couldn't load REVUP2.WAV!"); <br>            return FALSE; <br>        } <br>         <br>        if (!CreateBufferFromWaveFile("REVUP3.WAV", SERVO_UP_3)) <br>        { <br>            RegError("Couldn't load REVUP3.WAV!"); <br>            return FALSE; <br>        } <br>         <br>        if (!CreateBufferFromWaveFile("REVDN1.WAV", SERVO_DOWN_1)) <br>        { <br>            RegError("Couldn't load REVDOWN1.WAV!"); <br>            return FALSE; <br>        } <br>         <br>        if (!CreateBufferFromWaveFile("REVDN2.WAV", SERVO_DOWN_2)) <br>        { <br>            RegError("Couldn't load REVDOWN2.WAV!"); <br>            return FALSE; <br>        } <br>         <br>        if (!CreateBufferFromWaveFile("REVDN3.WAV", SERVO_DOWN_3)) <br>        { <br>            RegError("Couldn't load REVDOWN3.WAV!"); <br>            return FALSE; <br>        } <br>                if (!CreateBufferFromWaveFile("RANDOM1.WAV", RANDOM1)) <br>        { <br>            RegError("Couldn't load RANDOM1.WAV!"); <br>            return FALSE; <br>        } <br>                if (!CreateBufferFromWaveFile("RANDOM2.WAV", RANDOM2)) <br>        { <br>            RegError("Couldn't load RANDOM2.WAV!"); <br>            return FALSE; <br>        } <br>                if (!CreateBufferFromWaveFile("RANDOM3.WAV", RANDOM3)) <br>        { <br>            RegError("Couldn't load RANDOM3.WAV!"); <br>            return FALSE; <br>        } <br>                if (!CreateBufferFromWaveFile("RANDOM4.WAV", RANDOM4)) <br>        { <br>            RegError("Couldn't load RANDOM4.WAV!"); <br>            return FALSE; <br>        } <br>                if (!CreateBufferFromWaveFile("RANDOM5.WAV", RANDOM5)) <br>        { <br>            RegError("Couldn't load RANDOM5.WAV!"); <br>            return FALSE; <br>        } <br>                if (!CreateBufferFromWaveFile("RANDOM6.WAV", RANDOM6)) <br>        { <br>            RegError("Couldn't load RANDOM6.WAV!"); <br>            return FALSE; <br>        } <br>    } <br>                             <br>    // Load Rockem3D's palette <br>    fp = fopen("ROCKEM3D.PAL", "rb"); <br>    if (!fp) <br>    { <br>        RegError("Couldn't load ROCKEM3D.PAL!"); <br>        return FALSE; <br>    } <br> <br>    // Read in the raw rgb's <br>    fread(pal, 768, 1, fp); <br>     <br>    // Close the file <br>    fclose(fp);  <br>             <br>    // Set up palette  <br>    g_rPal[0].peFlags   = D3DPAL_READONLY; <br>    g_rPal[253].peFlags = D3DPAL_READONLY; <br>    g_rPal[254].peFlags = D3DPAL_READONLY; <br>    g_rPal[255].peFlags = D3DPAL_READONLY; <br>     <br>    for (int i = 1; i &lt; 253; i++) <br>    { <br>        g_rPal[i].peRed   = pal[i * 3]; <br>        g_rPal[i].peGreen = pal[(i * 3) + 1]; <br>        g_rPal[i].peBlue  = pal[(i * 3) + 2];                    <br>        g_rPal[i].peFlags = D3DPAL_READONLY; <br>    } <br>     <br>    // Set the entries 253 and 254 to a colour for the power bars <br>    g_rPal[253].peRed   = 0; <br>    g_rPal[253].peGreen = 0; <br>    g_rPal[253].peBlue  = 255; <br> <br>    g_rPal[254].peRed   = 255; <br>    g_rPal[254].peGreen = 0; <br>    g_rPal[254].peBlue  = 0; <br> <br>    // Yahoo! <br>    return TRUE; <br>} <br> <br>//---------------------------------------------------------------------- <br>//  <br>// Function     : SetDirectDrawExclusiveMode() <br>// <br>// Purpose      : Sets exclusive mode for DirectDraw <br>// <br>//---------------------------------------------------------------------- <br> <br>BOOL SetDirectDrawExclusiveMode() <br>{ <br>    TRY_DD(g_lpDD-&gt;SetCooperativeLevel(g_hWnd, DDSCL_EXCLUSIVE | DDSCL_FULLSCREEN | DDSCL_ALLOWMODEX)) <br> <br>    // Yahoo! <br>    return TRUE; <br>} <br> <br> <br>//---------------------------------------------------------------------- <br>//  <br>// Function     : TermDirectX() <br>// <br>// Purpose      : Destroys all the DirectX objects <br>// <br>//---------------------------------------------------------------------- <br> <br>void TermDirectX() <br>{ <br>    // Destroy everything in the reverse order in which they were created <br>        int i; <br> <br>    // Destroy rendering device <br>    if (g_lpD3DDevice) <br>    { <br>        g_lpD3DDevice-&gt;Release(); <br>        g_lpD3DDevice = NULL; <br>    } <br> <br>    // Destroy all surfaces <br>    if (g_lpZBuffer) <br>    { <br>        g_lpZBuffer-&gt;Release(); <br>        g_lpZBuffer = NULL; <br>    } <br> <br>    if (g_lpBackBuffer) <br>    { <br>        g_lpBackBuffer-&gt;Release(); <br>        g_lpBackBuffer = NULL; <br>    } <br> <br>    if (g_lpPrimary) <br>    { <br>        g_lpPrimary-&gt;Release(); <br>        g_lpPrimary = NULL; <br>    } <br> <br>    // Restore the original video mode   <br>    if(g_lpDD) <br>        g_lpDD-&gt;RestoreDisplayMode(); <br> <br>    // Destroy sounds <br>    for (i = 0; i &lt; NUM_SOUNDS; i ++) <br>    { <br>        if (g_lpSounds[i]) <br>        {        <br>            g_lpSounds[i]-&gt;Release(); <br>            g_lpSounds[i] = NULL; <br>        } <br>    } <br> <br>        // Destroy DirectSound3D buffers <br>    for (i = 0; i &lt; NUM_SOUNDS; i ++) <br>    { <br>        if (g_lp3dSounds[i]) <br>        {        <br>            g_lp3dSounds[i]-&gt;Release(); <br>            g_lp3dSounds[i] = NULL; <br>        } <br>    } <br>         <br>        // Destroy DirectSound3D Listener object <br>    if (g_lpDs3dListener) <br>    { <br>        g_lpDs3dListener-&gt;Release(); <br>        g_lpDs3dListener = NULL; <br>    } <br>        // Destroy DirectSound3D Primary buffer <br>    if (g_3DSoundBuffer) <br>    { <br>        g_3DSoundBuffer-&gt;Release(); <br>        g_3DSoundBuffer = NULL; <br>    }  <br> <br>    // Destroy DirectSound object <br>    if (g_lpDS) <br>    { <br>        g_lpDS-&gt;Release(); <br>        g_lpDS = NULL; <br>    } <br>     <br>    // Destroy Direct3D RM object <br>    if (g_lpD3DRM) <br>    { <br>        g_lpD3DRM-&gt;Release(); <br>        g_lpD3DRM = NULL; <br>    } <br> <br>    // Destroy Direct3D object <br>    if (g_lpD3D) <br>    { <br>        g_lpD3D-&gt;Release(); <br>        g_lpD3D = NULL; <br>    } <br> <br>    // Destroy DirectDraw object <br>    if (g_lpDD) <br>    { <br>        g_lpDD-&gt;Release(); <br>        g_lpDD = NULL; <br>    } <br>} <br> <br>//---------------------------------------------------------------------- <br>//  <br>// Function     : SoftwareGUID(); <br>// <br>// Purpose      : Returns a pointer to a software driver GUID <br>// <br>//---------------------------------------------------------------------- <br>HRESULT SoftwareGUID(LPGUID* ret_guid) <br>{ <br>    static D3DFINDDEVICERESULT result; <br>    D3DFINDDEVICESEARCH search; <br>    HRESULT err; <br>     <br>    memset(&amp;search, 0, sizeof search); <br>    search.dwSize = sizeof search; <br>    search.dwFlags = D3DFDS_HARDWARE | D3DFDS_COLORMODEL; <br>    search.bHardware = FALSE; <br>    search.dcmColorModel = D3DCOLOR_RGB; <br>    result.dwSize = sizeof(D3DFINDDEVICERESULT); <br> <br>    if (err = g_lpD3D-&gt;FindDevice(&amp;search, &amp;result)) <br>return err; <br>    *ret_guid = &amp;result.guid; <br>    return D3D_OK; <br>} <br> <br> <br>//---------------------------------------------------------------------- <br>//  <br>// Function     : EnterVideoMode() <br>// <br>// Purpose      : Calls EnterVideoModeWHBD with mode information <br>// <br>//---------------------------------------------------------------------- <br> <br>BOOL EnterVideoMode(int mode) <br>{ <br>    int width    = g_vidModes[mode].width; <br>    int height   = g_vidModes[mode].height; <br>    int bitdepth = g_vidModes[mode].bpp; <br>    g_dwCurrMode = mode; <br> <br>    // Try to enter video mode described by width, height and bitdepth <br>    return EnterVideoModeWHBD(width, height, bitdepth); <br>} <br> <br>//---------------------------------------------------------------------- <br>//  <br>// Function     : EnterVideoModeWHBD() <br>// <br>// Purpose      : Switches video mode and creates all neccessary structures <br>//                        required for rendering <br>// <br>//---------------------------------------------------------------------- <br> <br>BOOL EnterVideoModeWHBD(int width, int height, int bitdepth) <br>{ <br>    DDSURFACEDESC ddsd; <br>    DDSCAPS ddscaps; <br> <br>    // Destroy all existing viewports, devices and surfaces      <br>     <br>    // Destroy Direct3D RM viewport <br>    if (g_lpD3DRMViewport) <br>    {    <br>        g_lpD3DRMViewport-&gt;Release(); <br>        g_lpD3DRMViewport = NULL; <br>    } <br> <br>    // Destroy Direct3D RM device <br>    if (g_lpD3DRMDevice) <br>    { <br>        g_lpD3DRMDevice-&gt;Release(); <br>        g_lpD3DRMDevice = NULL; <br>    } <br> <br>    // Destroy Direct3D device <br>    if (g_lpD3DDevice) <br>    { <br>        g_lpD3DDevice-&gt;Release(); <br>        g_lpD3DDevice = NULL; <br>    } <br> <br>    // Destroy ZBuffer <br>    if (g_lpZBuffer) <br>    { <br>        g_lpZBuffer-&gt;Release(); <br>        g_lpZBuffer = NULL; <br>    } <br> <br>    // Destroy Primary surface <br>    if (g_lpPrimary) <br>    { <br>        g_lpPrimary-&gt;Release(); <br>        g_lpPrimary = NULL; <br>    } <br> <br>    // Switch video mode <br>    TRY_DD(g_lpDD-&gt;SetDisplayMode(width, height, bitdepth)) <br> <br>    // First, create complex flipping primary surface <br>     <br>    // Fill out surface description <br>    memset(&amp;ddsd, sizeof(DDSURFACEDESC), 0); <br>    ddsd.dwSize                 = sizeof(DDSURFACEDESC); <br>    ddsd.dwFlags                = DDSD_CAPS | DDSD_BACKBUFFERCOUNT; <br>    ddsd.ddsCaps.dwCaps         = DDSCAPS_PRIMARYSURFACE | DDSCAPS_FLIP | DDSCAPS_COMPLEX | DDSCAPS_3DDEVICE; <br>    ddsd.dwBackBufferCount      = 1; <br> <br>    // Create the primary surface with 1 back buffer <br>    TRY_DD(g_lpDD-&gt;CreateSurface(&amp;ddsd, &amp;g_lpPrimary, NULL)) <br> <br>    // Get pointer to back buffer <br>    ddscaps.dwCaps = DDSCAPS_BACKBUFFER; <br>    TRY_DD(g_lpPrimary-&gt;GetAttachedSurface(&amp;ddscaps, &amp;g_lpBackBuffer)) <br> <br>    // Only create a ZBuffer if g_dwZBufferBitDepth &gt; 0 <br>    if (g_dwZBufferBitDepth) <br>    { <br>HRESULT err; <br> <br>        // Then, create Z-Buffer. The g_dwZBufferMemType and g_dwZBufferBitDepth variables <br>        // are set up when the Direct3D device enumeration is done at runtime <br>        memset(&amp;ddsd, sizeof(DDSURFACEDESC), 0); <br>        ddsd.dwSize             = sizeof(DDSURFACEDESC); <br>        ddsd.dwFlags            = DDSD_WIDTH | DDSD_HEIGHT | DDSD_CAPS | DDSD_ZBUFFERBITDEPTH;; <br>        ddsd.dwWidth            = width; <br>        ddsd.dwHeight           = height; <br>        ddsd.ddsCaps.dwCaps     = DDSCAPS_ZBUFFER | g_dwZBufferMemType; <br>        ddsd.dwZBufferBitDepth  = g_dwZBufferBitDepth; <br> <br>        // Create the ZBuffer <br>if (err = g_lpDD-&gt;CreateSurface(&amp;ddsd, &amp;g_lpZBuffer, NULL)) <br>{ <br>    if (err == DDERR_OUTOFVIDEOMEMORY) <br>    { <br>// Out of video memory - create system memory zbuffer for software renderer <br>memset(&amp;ddsd, sizeof(DDSURFACEDESC), 0); <br>ddsd.dwSize             = sizeof(DDSURFACEDESC); <br>ddsd.dwFlags            = DDSD_WIDTH | DDSD_HEIGHT | DDSD_CAPS | DDSD_ZBUFFERBITDEPTH;; <br>ddsd.dwWidth            = width; <br>ddsd.dwHeight           = height; <br>ddsd.ddsCaps.dwCaps     = DDSCAPS_ZBUFFER | DDSCAPS_SYSTEMMEMORY; <br>ddsd.dwZBufferBitDepth  = 16; <br>if (err = g_lpDD-&gt;CreateSurface(&amp;ddsd, &amp;g_lpZBuffer, NULL)) <br>{ <br>    TRY_DD(err); <br>} <br>else <br>{ <br>    g_bOutOfVideoMemory = TRUE; <br>} <br>    } <br>    else <br>    { <br>TRY_DD(err); <br>    } <br>} <br>else <br>{ <br>    g_bOutOfVideoMemory = FALSE; <br>} <br> <br>        // Attach ZBuffer to the back buffer <br>        TRY_DD(g_lpBackBuffer-&gt;AddAttachedSurface(g_lpZBuffer)) <br>    } <br> <br>    // Retrieve the caps of the primary surface <br>    TRY_DD(g_lpPrimary-&gt;GetCaps(&amp;ddscaps)) <br> <br>    // Create and attach palette (only if we in 8-bit palettized colour modes) <br>    if ((bitdepth == 8) &amp;&amp; (ddscaps.dwCaps &amp; DDCAPS_PALETTE)) <br>    { <br>        // Create the palette <br>        TRY_DD(g_lpDD-&gt;CreatePalette(DDPCAPS_8BIT | DDPCAPS_INITIALIZE, g_rPal, &amp;g_lpPalette, NULL)) <br>         <br>        // Set the back buffer's palette <br>        TRY_DD(g_lpBackBuffer-&gt;SetPalette(g_lpPalette)) <br> <br>        // Set the primary surface's palette <br>        TRY_DD(g_lpPrimary-&gt;SetPalette(g_lpPalette)) <br>    } <br> <br>    // Create Direct3D device <br>    if (!g_bOutOfVideoMemory) <br>    { <br>TRY_D3D(g_lpBackBuffer-&gt;QueryInterface(*g_lpD3DDeviceGuid, (LPVOID *)&amp;g_lpD3DDevice)) <br>    } <br>    else  <br>    { <br>LPGUID guidSoftware; <br>TRY_D3D(SoftwareGUID(&amp;guidSoftware)) <br>TRY_D3D(g_lpBackBuffer-&gt;QueryInterface(*guidSoftware, (LPVOID*)&amp;g_lpD3DDevice)) <br>    } <br> <br>    // Create Direct3D RM Device from Direct3D Device <br>    TRY_D3DRM(g_lpD3DRM-&gt;CreateDeviceFromD3D(g_lpD3D, g_lpD3DDevice, &amp;g_lpD3DRMDevice)) <br> <br>    // Set the buffer count to 2 so D3DRM can keep track of extents for fullscreen flipping surface <br>    TRY_D3DRM(g_lpD3DRMDevice-&gt;SetBufferCount(2)) <br> <br>    // Render using gouraud shading <br>    g_lpD3DRMDevice-&gt;SetQuality(D3DRMRENDER_GOURAUD); <br> <br>    // And no dithering please (NOTE : dithering is for looks not speed!) <br>    g_lpD3DRMDevice-&gt;SetDither(FALSE); <br> <br>    // Set texture quality <br>    g_lpD3DRMDevice-&gt;SetTextureQuality(D3DRMTEXTURE_NEAREST); <br> <br>    // Set the number of shades for lighting <br>    g_lpD3DRMDevice-&gt;SetShades(8); <br>     <br>    // Create RM viewport from device and camera (camera has already been initialised <br>    // by InitScene() in RM.CPP) <br>    TRY_D3DRM(g_lpD3DRM-&gt;CreateViewport(g_lpD3DRMDevice,  <br>                                        g_lpCamera, <br>                                        0, <br>                                        0, <br>                                        width, <br>                                        height, <br>                                        &amp;g_lpD3DRMViewport)) <br> <br>    // Set the back clipping plane to be something fairly large <br>    g_lpD3DRMViewport-&gt;SetBack(D3DVAL(30000.0f)); <br> <br>    // Diddle with the lights depending on what driver we are using <br>    switch (g_deviceInfo.cm) <br>    { <br>        case D3DCOLOR_MONO :  <br>        { <br>            // Enable the directional light only to hit the players, not the arena <br>            g_lpDir-&gt;SetEnableFrame(g_lpPlayers); <br>        } <br>        break; <br> <br>        case D3DCOLOR_RGB : <br>        { <br>            // Enable the directional light to hit all objects <br>            g_lpDir-&gt;SetEnableFrame(g_lpScene); <br>        } <br>        break; <br>    }    <br> <br>    // Record video mode information <br>    g_vidModeX = width; <br>    g_vidModeY = height; <br>    g_vidModeBIT = bitdepth; <br>     <br>    // And calculate values for the power bars <br>    g_xratio = (float)width / 1000.0f; <br>    g_yratio = (float)height / 1000.0f; <br> <br>    g_lbar1 = (DWORD)(float)(50.0f * g_xratio); <br>    g_wbar1 = (DWORD)(float)(400.0f * g_xratio); <br>    g_lbar2 = (DWORD)(float)(550.0f * g_xratio); <br>    g_wbar2 = g_wbar1; <br>    g_hbar1 = (DWORD)(float)(30.0f * g_yratio); <br>    g_hbar2 = (DWORD)(float)(20.0f * g_yratio); <br> <br>    // Finally, calculate the height of the current font <br>    HDC hDC; <br>    hDC = ::GetDC(g_hWnd); <br>     <br>    TEXTMETRIC txtMetric; <br>    GetTextMetrics(hDC, &amp;txtMetric); <br>     <br>    ::ReleaseDC(g_hWnd, hDC); <br> <br>    g_dwFontHeight   = txtMetric.tmHeight; <br>    g_dwAveCharWidth = txtMetric.tmAveCharWidth; <br> <br>    // Yahoo! <br>    return TRUE;         <br>} <br> <br>//---------------------------------------------------------------------- <br>//  <br>// Function     : EnterPrevVideoMode() <br>// <br>// Purpose      : Enters previous mode in vidModes[] <br>// <br>//---------------------------------------------------------------------- <br> <br>BOOL EnterPrevVideoMode() <br>{ <br>    if (g_dwCurrMode &gt; 0) <br>    { <br>        return EnterVideoMode(-- g_dwCurrMode); <br>    } <br>     <br>    return TRUE; <br>} <br> <br>//---------------------------------------------------------------------- <br>//  <br>// Function     : EnterNextVideoMode() <br>// <br>// Purpose      : Enters nextmode in vidModes[] <br>// <br>//---------------------------------------------------------------------- <br> <br>BOOL EnterNextVideoMode() <br>{ <br>    if (g_dwCurrMode &lt; g_dwNumModes - 1) <br>    { <br>        return EnterVideoMode(++ g_dwCurrMode); <br>    } <br>     <br>    return TRUE; <br>} <br> <br>//---------------------------------------------------------------------- <br>//  <br>// Function     : EnterLowestVideoMode() <br>// <br>// Purpose      : Enters lowest mode in vidModes[] <br>// <br>//---------------------------------------------------------------------- <br> <br>BOOL EnterLowestVideoMode() <br>{ <br>    return EnterVideoMode(0);    <br>} <br> <br>//---------------------------------------------------------------------- <br>//  <br>// Function     : EnterHighestVideoMode() <br>// <br>// Purpose      : Enters highest mode in vidModes[] <br>// <br>//---------------------------------------------------------------------- <br> <br>BOOL EnterHighestVideoMode() <br>{ <br>    return EnterVideoMode(g_dwNumModes - 1);     <br>} <br> <br>//---------------------------------------------------------------------- <br>//  <br>// Function     : ReenterVideoMode() <br>// <br>// Purpose      : Re-enters current video mode <br>// <br>//---------------------------------------------------------------------- <br> <br>BOOL ReenterCurrentVideoMode() <br>{ <br>    return EnterVideoMode(g_dwCurrMode); <br>} <br> <br>//---------------------------------------------------------------------- <br>//  <br>// Function     : CleanUp() <br>// <br>// Purpose      : Destroys all surfaces and rendering devices  <br>// <br>//---------------------------------------------------------------------- <br> <br>void CleanUp() <br>{ <br>    // Destroy everything in the reverse order that they were created <br>             <br>    // Destroy viewport <br>    if (g_lpD3DRMViewport) <br>    { <br>        g_lpD3DRMViewport-&gt;Release(); <br>        g_lpD3DRMViewport = NULL; <br>    } <br> <br>    // Destroy rendering devices <br>    if (g_lpD3DRMDevice) <br>    { <br>        g_lpD3DRMDevice-&gt;Release(); <br>        g_lpD3DRMDevice = NULL; <br>    } <br> <br>    if (g_lpD3DDevice) <br>    { <br>        g_lpD3DDevice-&gt;Release(); <br>        g_lpD3DDevice = NULL; <br>    } <br> <br>    // Destroy all surfaces <br>    if (g_lpZBuffer) <br>    { <br>        g_lpZBuffer-&gt;Release(); <br>        g_lpZBuffer = NULL; <br>    } <br> <br>    if (g_lpBackBuffer) <br>    { <br>        g_lpBackBuffer-&gt;Release(); <br>        g_lpBackBuffer = NULL; <br>    } <br> <br>    if (g_lpPrimary) <br>    { <br>        g_lpPrimary-&gt;Release(); <br>        g_lpPrimary = NULL; <br>    }    <br> <br>    // Destroy palette <br>    if (g_lpPalette) <br>    { <br>        g_lpPalette-&gt;Release(); <br>        g_lpPalette = NULL; <br>    } <br>     <br>    // Restore the original video mode <br>    g_lpDD-&gt;RestoreDisplayMode(); <br>} <br> <br>//---------------------------------------------------------------------- <br>//  <br>// Function     : DoSplashScreen() <br>// <br>// Purpose      : Draws splash screen (if possible) <br>// <br>//---------------------------------------------------------------------- <br> <br>BOOL DoSplashScreen(DWORD delay) <br>{ <br>    LPDIRECTDRAWSURFACE backbuffer = NULL; <br>    DDSURFACEDESC       ddsd; <br>    DDSCAPS             ddscaps; <br>    HRESULT             rval; <br>    DWORD               dwStart; <br>    int                 i; <br>    FILE                *fp; <br>    BYTE                rgbs[768], scanbuf[640]; <br>    void                *lpSurf; <br>    BYTE                *pSurf; <br>    DWORD               dummy; <br> <br>    delay; <br>     <br>    // Create a DirectDraw device <br>    rval = DirectDrawCreate(NULL, &amp;g_lpSplashDD, NULL); <br>    if (rval != DD_OK) goto fail; <br> <br>    // Set cooperative level <br>    rval = g_lpSplashDD-&gt;SetCooperativeLevel(g_hWnd, DDSCL_EXCLUSIVE | DDSCL_FULLSCREEN); <br>    if (rval != DD_OK) goto fail; <br> <br>    // Attempt to enter 640x480x8 <br>    // Switch video mode         <br>    rval = g_lpSplashDD-&gt;SetDisplayMode(640, 480, 8); <br>    if (rval != DD_OK) goto fail; <br> <br>    // Create complex flipping primary surface <br> <br>    // Clear surface caps structure <br>    memset(&amp;ddscaps, 0, sizeof(DDSCAPS)); <br>     <br>    // Fill out surface description <br>    memset(&amp;ddsd, sizeof(DDSURFACEDESC), 0); <br>    ddsd.dwSize                 = sizeof(DDSURFACEDESC); <br>    ddsd.dwFlags                = DDSD_CAPS | DDSD_BACKBUFFERCOUNT; <br>    ddsd.ddsCaps.dwCaps         = DDSCAPS_PRIMARYSURFACE | DDSCAPS_FLIP | DDSCAPS_COMPLEX; <br>    ddsd.dwBackBufferCount      = 1; <br> <br>    // Create the primary surface with 1 back buffer <br>    rval = g_lpSplashDD-&gt;CreateSurface(&amp;ddsd, &amp;g_lpSplashPrimary, NULL); <br>    if (rval != DD_OK) goto fail; <br> <br>    // Get pointer to back buffer <br>    ddscaps.dwCaps = DDSCAPS_BACKBUFFER; <br>    rval = g_lpSplashPrimary-&gt;GetAttachedSurface(&amp;ddscaps, &amp;backbuffer); <br>    if (rval != DD_OK) goto fail; <br> <br>    // Open the splash screen file <br>    fp = fopen("ROCKEM3D.BIN", "rb"); <br>    if (!fp) goto fail; <br>     <br>    memset(&amp;ddsd, 0, sizeof(DDSURFACEDESC)); <br>    ddsd.dwSize = sizeof(DDSURFACEDESC); <br> <br>    // Lock the backbuffer to get a pointer to it <br>    rval = backbuffer-&gt;Lock(NULL, &amp;ddsd, DDLOCK_SURFACEMEMORYPTR, NULL); <br>    if (rval != DD_OK) goto fail; <br> <br>    // Read the image into the backbuffer <br>    lpSurf = ddsd.lpSurface; <br> <br>    // Read in lines of image, accounting for pitch <br>    pSurf = (BYTE *)lpSurf; <br> <br>    // Read first dword from .BIN file, that corresponds to WIDTH and HEIGHT (two words) <br>    fread(&amp;dummy, 4, 1, fp); <br> <br>    for (i = 0; i &lt; 480; i ++) <br>    { <br>        fread(scanbuf, 640, 1, fp); <br>        memcpy(pSurf, scanbuf, 640); <br>        pSurf += ddsd.lPitch; <br>    } <br> <br>    // Close the file <br>    fclose(fp); <br> <br>    // Unlock the surface <br>    rval = backbuffer-&gt;Unlock(lpSurf); <br>    if (rval != DD_OK) goto fail; <br> <br>    // Set up the palette                <br>    fp = fopen("SPLASH.PAL", "rb"); <br>    if (!fp) goto fail; <br> <br>    fread(rgbs, 768, 1, fp); <br>    fclose(fp); <br>     <br>    // Set up the PALETTEENTRY's from the 768 byte RGB array <br>    PALETTEENTRY ppe[256]; <br>    for (i = 0; i &lt; 256; i ++) <br>    { <br>        ppe[i].peRed   = rgbs[i * 3]; <br>        ppe[i].peGreen = rgbs[(i * 3) + 1]; <br>        ppe[i].peBlue  = rgbs[(i * 3) + 2]; <br>        ppe[i].peFlags = PC_NOCOLLAPSE; <br>    } <br>     <br>    // Create the palette <br>    //rval = g_lpDD-&gt;CreatePalette(DDPCAPS_8BIT | DDPCAPS_INITIALIZE, ppe, &amp;g_lpPalette, NULL); <br>    rval = g_lpSplashDD-&gt;CreatePalette(DDPCAPS_8BIT | DDPCAPS_INITIALIZE, ppe, &amp;g_lpSplashPalette, NULL); <br>    if (rval != DD_OK) goto fail; <br> <br>    // Set the backbuffer's palette <br>    rval = g_lpSplashPrimary-&gt;SetPalette(g_lpSplashPalette); <br>    if (rval != DD_OK) goto fail; <br> <br>    // And flip the splash screen into view <br>    rval = g_lpSplashPrimary-&gt;Flip(NULL, DDFLIP_WAIT); <br>    if (rval != DD_OK) goto fail; <br> <br>    // Wait for delay milliseconds or a specific keypress <br>    dwStart = timeGetTime(); <br>     <br>    while (timeGetTime() - dwStart &lt; delay) </code></pre>
<p>
</p>
<pre><code>{ <br>        if (GetAsyncKeyState(VK_SPACE) &amp; 0x8000) break; <br>        if (GetAsyncKeyState(VK_RETURN) &amp; 0x8000) break; <br>        if (GetAsyncKeyState(VK_ESCAPE) &amp; 0x8000) break; <br>        if ((GetAsyncKeyState(VK_MENU) &amp; 0x8000) &amp;&amp; (GetAsyncKeyState(VK_F4) &amp; 0x8000)) break; <br>    }    <br> <br>    backbuffer-&gt;Release(); <br> <br>    // Yahoo! <br>    return TRUE; <br> <br>    fail: <br> <br>    // Close file <br>    if (fp) <br>    { <br>        fclose(fp); <br>    } <br>     <br>    // Release palette <br>    if (g_lpSplashPalette) <br>    { <br>        g_lpSplashPalette-&gt;Release(); <br>        g_lpSplashPalette = NULL; <br>    } <br> <br>    // Release primary surface <br>    if (g_lpSplashPrimary) <br>    { <br>        g_lpSplashPrimary-&gt;Release(); <br>        g_lpSplashPrimary = NULL; <br>    } <br> <br>    if (g_lpSplashDD) <br>    { <br>        g_lpSplashDD-&gt;Release(); <br>        g_lpSplashDD = NULL; <br>    } <br> <br>    // Yahoo! <br>    return FALSE; <br>} <br> <br> <br>//---------------------------------------------------------------------- <br>//  <br>// Function     : ReleaseSplashScreen() <br>// <br>// Purpose      : Releases the splash screen <br>// <br>//---------------------------------------------------------------------- <br> <br>void ReleaseSplashScreen() <br>{ <br>    // Release palette <br>    if (g_lpSplashPalette) <br>    { <br>        g_lpSplashPalette-&gt;Release(); <br>        g_lpSplashPalette = NULL; <br>    } <br> <br>    // Release primary surface <br>    if (g_lpSplashPrimary) <br>    { <br>        g_lpSplashPrimary-&gt;Release(); <br>        g_lpSplashPrimary = NULL; <br>    } <br> <br>    if (g_lpSplashDD) <br>    { <br>        g_lpSplashDD-&gt;Release(); <br>        g_lpSplashDD = NULL; <br>    } <br>} <br> <br> <br>//---------------------------------------------------------------------- <br>//  <br>// Function     : RestoreSurfaces() <br>// <br>// Purpose      : Restores all surfaces if they somehow got lost (Alt-Tab) <br>// <br>//---------------------------------------------------------------------- <br> <br>BOOL RestoreSurfaces() <br>{ <br>    // Attempt to restore primary surface <br>    if (g_lpPrimary) <br>    { <br>        if (g_lpPrimary-&gt;IsLost()) TRY_DD(g_lpPrimary-&gt;Restore()) <br>    } <br> <br>    // Attempt to restore zbuffer <br>    if (g_lpZBuffer) <br>    { <br>        if (g_lpZBuffer-&gt;IsLost()) TRY_DD(g_lpZBuffer-&gt;Restore()) <br>    } <br> <br>    // Yahoo! <br>    return TRUE; <br>} <br> <br>//---------------------------------------------------------------------- <br>//  <br>// Function     : CreateSoundBuffer() <br>// <br>// Purpose      : Creates a DirectSound buffer <br>// <br>//---------------------------------------------------------------------- <br> <br>BOOL CreateSoundBuffer(DWORD dwBuf, DWORD dwBufSize, DWORD dwFreq, DWORD dwBitsPerSample, DWORD dwBlkAlign, BOOL bStereo) <br>{ <br>    PCMWAVEFORMAT pcmwf; <br>    DSBUFFERDESC dsbdesc; <br>     <br>    // Set up wave format structure. <br>    memset( &amp;pcmwf, 0, sizeof(PCMWAVEFORMAT) ); <br>    pcmwf.wf.wFormatTag         = WAVE_FORMAT_PCM;       <br>    pcmwf.wf.nChannels          = bStereo ? 2 : 1; <br>    pcmwf.wf.nSamplesPerSec     = dwFreq; <br>    pcmwf.wf.nBlockAlign        = (WORD)dwBlkAlign; <br>    pcmwf.wf.nAvgBytesPerSec    = pcmwf.wf.nSamplesPerSec * pcmwf.wf.nBlockAlign; <br>    pcmwf.wBitsPerSample        = (WORD)dwBitsPerSample; <br> <br>    // Set up DSBUFFERDESC structure. <br>    memset(&amp;dsbdesc, 0, sizeof(DSBUFFERDESC));  // Zero it out.  <br>    dsbdesc.dwSize              = sizeof(DSBUFFERDESC); <br>    dsbdesc.dwFlags             = DSBCAPS_CTRL3D;               // Needed creation flag for Direct 3D Sound <br>        dsbdesc.dwBufferBytes       = dwBufSize;  <br>    dsbdesc.lpwfxFormat         = (LPWAVEFORMATEX)&amp;pcmwf; <br> <br>    TRY_DS(g_lpDS-&gt;CreateSoundBuffer(&amp;dsbdesc, &amp;g_lpSounds[dwBuf], NULL)) <br>     <br>        // Query for the 3D Sound Buffer interface. <br>    TRY_DS(g_lpSounds[dwBuf]-&gt;QueryInterface(IID_IDirectSound3DBuffer, (void**) &amp;g_lp3dSounds[dwBuf])); <br> <br>    // Yahoo! <br>    return TRUE; <br>} <br> <br>//---------------------------------------------------------------------- <br>//  <br>// Function     : ReadData() <br>// <br>// Purpose      : Reads in data from a wave file <br>// <br>//---------------------------------------------------------------------- <br> <br>BOOL ReadData(LPDIRECTSOUNDBUFFER lpDSB, FILE* pFile, DWORD dwSize, DWORD dwPos)  <br>{ <br>    // Seek to correct position in file (if necessary) <br>    if (dwPos != 0xffffffff)  <br>    { <br>        if (fseek(pFile, dwPos, SEEK_SET) != 0)  <br>        { <br>            return FALSE; <br>        } <br>    } <br> <br>    // Lock data in buffer for writing <br>    LPVOID pData1; <br>    DWORD  dwData1Size; <br>    LPVOID pData2; <br>    DWORD  dwData2Size; <br>    HRESULT rval; <br> <br>    rval = lpDSB-&gt;Lock(0, dwSize, &amp;pData1, &amp;dwData1Size, &amp;pData2, &amp;dwData2Size, DSBLOCK_FROMWRITECURSOR); <br>    if (rval != DS_OK) <br>    { <br>        return FALSE; <br>    } <br> <br>    // Read in first chunk of data <br>    if (dwData1Size &gt; 0)  <br>    { <br>        if (fread(pData1, dwData1Size, 1, pFile) != 1)  <br>        {           <br>                        char holder[256]; <br>                        wsprintf(holder,"Data1 : %d, dwdata: %d, pFile: %d",pData1,dwData1Size,pFile); <br>                        OutputDebugString(holder); <br>            return FALSE; <br>        } <br>    } <br> <br>    // read in second chunk if necessary <br>    if (dwData2Size &gt; 0)  <br>    { <br>        if (fread(pData2, dwData2Size, 1, pFile) != 1)  <br>        { <br>            return FALSE; <br>        } <br>    } <br> <br>    // Unlock data in buffer <br>    rval = lpDSB-&gt;Unlock(pData1, dwData1Size, pData2, dwData2Size); <br>    if (rval != DS_OK) <br>    { <br>        return FALSE; <br>    } <br> <br>    // Yahoo! <br>    return TRUE; <br>} <br> <br>//---------------------------------------------------------------------- <br>//  <br>// Function     : CreateSoundBufferFromWaveFile() <br>// <br>// Purpose      : Creates a DirectSound buffer from a wave file <br>// <br>//---------------------------------------------------------------------- <br> <br>BOOL CreateBufferFromWaveFile(char* FileName, DWORD dwBuf) <br>{ <br>    // Open the wave file        <br>    FILE* pFile = fopen(FileName,"rb"); <br>    if (pFile == NULL) return FALSE; <br> <br>    // Read in the wave header           <br>    WaveHeader wavHdr; <br>    if (fread(&amp;wavHdr, sizeof(wavHdr), 1, pFile) != 1)  <br>    { <br>        fclose(pFile); <br>        return NULL; <br>    } <br> <br>    // Figure out the size of the data region <br>    DWORD dwSize = wavHdr.dwDSize; <br> <br>    // Is this a stereo or mono file? <br>    BOOL bStereo = wavHdr.wChnls &gt; 1 ? TRUE : FALSE; <br> <br>    // Create the sound buffer for the wave file <br>    if (!CreateSoundBuffer(dwBuf, dwSize, wavHdr.dwSRate, wavHdr.BitsPerSample, wavHdr.wBlkAlign, bStereo)) <br>    { <br>        // Close the file <br>        fclose(pFile); <br>         <br>        return FALSE; <br>    } <br> <br>    // Read the data for the wave file into the sound buffer <br>    if (!ReadData(g_lpSounds[dwBuf], pFile, dwSize, sizeof(wavHdr)))  <br>    { <br>        fclose(pFile); <br>        return FALSE; <br>    } <br> <br>    // Close out the wave file <br>    fclose(pFile); <br> <br>    // Yahoo! <br>    return TRUE; <br>} <br> <br>//---------------------------------------------------------------------- <br>//  <br>// Function     : StopAllSounds() <br>// <br>// Purpose      : Stops all sounds <br>// <br>//---------------------------------------------------------------------- <br> <br>BOOL StopAllSounds() <br>{ <br>    // Make sure we have a valid sound buffer <br>    for (int i = 0; i &lt; NUM_SOUNDS; i ++) <br>    { <br>        if (g_lpSounds[i]) <br>        { <br>            DWORD dwStatus; <br>            TRY_DS(g_lpSounds[i]-&gt;GetStatus(&amp;dwStatus)); <br> <br>            if ((dwStatus &amp; DSBSTATUS_PLAYING) == DSBSTATUS_PLAYING) <br>            { <br>                // Play the sound <br>                TRY_DS(g_lpSounds[i]-&gt;Stop()) <br>            } <br>        } <br>    } <br> <br>    // Yahoo! <br>    return TRUE; <br>} <br> <br>//---------------------------------------------------------------------- <br>//  <br>// Function     : PlaySoundDS() <br>// <br>// Purpose      : Plays a sound using direct sound <br>//  <br>//                      D3DVECTOR <br>//---------------------------------------------------------------------- <br> <br>BOOL PlaySoundDS(DWORD dwSound,D3DVECTOR d3dvPos, DWORD dwFlags) <br>{ <br> <br>    if (g_bSoundPaused) return TRUE; <br> <br>    if (!g_bSoundPresent) return TRUE; <br> <br>    // Make sure the sound is valid <br>    if (dwSound &gt;= NUM_SOUNDS) return FALSE;     <br> <br>    // Make sure we have a valid sound buffer <br>    if (g_lpSounds[dwSound]) <br>    { <br>        DWORD dwStatus; <br>        TRY_DS(g_lpSounds[dwSound]-&gt;GetStatus(&amp;dwStatus)); <br> <br>        if ((dwStatus &amp; DSBSTATUS_PLAYING) != DSBSTATUS_PLAYING) <br>        { <br>           // Set the 3D position of the sound, using supplied position vector. <br>           TRY_DS(g_lp3dSounds[dwSound]-&gt;SetPosition(d3dvPos.x, d3dvPos.y, d3dvPos.z, DS3D_IMMEDIATE)); <br>            // Play the sound <br>           TRY_DS(g_lpSounds[dwSound]-&gt;Play(0, 0, dwFlags)); <br>        } <br>    } <br> <br>    // Yahoo! <br>    return TRUE; <br>} <br> <br>//---------------------------------------------------------------------- <br>//  <br>// Function     : RecalcPowerBars() <br>// <br>// Purpose      : Calculates width of power bars based upon current  <br>//                        screen resolution <br>// <br>//---------------------------------------------------------------------- <br> <br>void RecalcPowerBars(DWORD player1health, DWORD player2health) <br>{ <br>    g_wbar1 = (DWORD)(float)((400.0f * ((float)player1health / 100.0f)) * g_xratio); <br>    g_wbar2 = (DWORD)(float)((400.0f * ((float)player2health / 100.0f)) * g_xratio); <br>} <br> <br> <br> <br>//---------------------------------------------------------------------- <br>//  <br>// Function     : CreateSoundBuffer3D() <br>// <br>// Purpose      : Creates a 3D sound buffer and returns the sound buffer <br>// <br>//---------------------------------------------------------------------- <br> <br>IDirectSoundBuffer *CreateSoundBuffer3D() <br>{ <br>    IDirectSoundBuffer *pDSB = NULL; <br>    DSBUFFERDESC dsBD = {0}; <br> <br>        ZeroMemory( &amp;dsBD, sizeof(DSBUFFERDESC)); <br>        dsBD.dwSize = sizeof(dsBD); <br>    dsBD.dwFlags = DSBCAPS_CTRL3D | DSBCAPS_PRIMARYBUFFER; <br>        dsBD.dwBufferBytes = 0;  //must be zero for primary buffer.. <br> <br>        if (g_lpDS-&gt;CreateSoundBuffer(&amp;dsBD, &amp;pDSB, NULL) != DS_OK) <br>                pDSB = NULL; <br> <br>    return pDSB; <br>} <br> <br>//---------------------------------------------------------------------- <br>//  <br>// Function     : PlayRandomWave() <br>// <br>// Purpose      : Creates a random wave at a random spot <br>// <br>//---------------------------------------------------------------------- <br> <br>VOID CALLBACK PlayRandomWave( HWND hwnd, UINT uMsg,UINT idEvent, DWORD dwTime ) <br>{ <br>        D3DVECTOR       d3dPosition;    // DSVECTOR used for the positon of the wave... <br>  <br>        int RandomWave[]={RANDOM1,RANDOM2,RANDOM3,RANDOM4,RANDOM5,RANDOM6}; <br> <br>        g_lpCamera-&gt;GetPosition(g_lpScene, &amp;d3dPosition); <br>        // fill in the position generated for the wave file. <br>        d3dPosition.x += (rand() % 2 == 0 ? (rand() % 250) : -(rand() % 250)); <br>        d3dPosition.z += (rand() % 2 == 0 ? (rand() % 250) : -(rand() % 250)); <br> <br>        PlaySoundDS(RandomWave[rand() % (sizeof(RandomWave) / sizeof(RandomWave[0]))],d3dPosition); <br>        return; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
