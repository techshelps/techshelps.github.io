<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FACES.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3160"></a>FACES.C</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1995, 1996 Microsoft Corporation. All Rights Reserved. <br> * <br> *  File: faces.c <br> * <br> ***************************************************************************/ <br> <br>/* <br> * Example program to demonstrate MeshAddFaces <br> */ <br> <br>#include "rmdemo.h" <br> <br>D3DVECTOR cube_vertices[] = {-D3DVAL(0.5), -D3DVAL(0.5), -D3DVAL(0.5), <br>    -D3DVAL(0.5), -D3DVAL(0.5), D3DVAL(0.5), <br>    -D3DVAL(0.5), D3DVAL(0.5), -D3DVAL(0.5), <br>    -D3DVAL(0.5), D3DVAL(0.5), D3DVAL(0.5), <br>    D3DVAL(0.5), -D3DVAL(0.5), -D3DVAL(0.5), <br>    D3DVAL(0.5), -D3DVAL(0.5), D3DVAL(0.5), <br>    D3DVAL(0.5), D3DVAL(0.5), -D3DVAL(0.5), <br>    D3DVAL(0.5), D3DVAL(0.5), D3DVAL(0.5) <br>}; <br> <br>/* <br> * face_data is a vertex count followed by the vertex reference in the <br> * vertices list. If normal_count &gt; 0, then pairs of vectors are <br> * referenced: first the vertex and secondly the normal reference. the <br> * list is terminated by a 0 (vertex count to a face) <br> */ <br> <br> <br>BOOL <br>build_face1(LPDIRECT3DRMMESHBUILDER msh) <br>{ <br>    /* <br>     * add a single face to a mesh. <br>     */ <br> <br>    /* <br>     * Single face with all normals pointing in the same direction. <br>     */ <br> <br>    int vertex_count = 4; <br>    D3DVECTOR vertices[4] = {D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0), <br>D3DVAL(0.0), D3DVAL(0.0), D3DVAL(1.0), <br>D3DVAL(1.0), D3DVAL(0.0), D3DVAL(1.0), <br>D3DVAL(1.0), D3DVAL(0.0), D3DVAL(0.0) <br>    }; <br>    int normal_count = 4; <br>    D3DVECTOR normals[4] = {D3DVAL(0.0), D3DVAL(1.0), D3DVAL(0.0), <br>D3DVAL(0.0), D3DVAL(1.0), D3DVAL(0.0), <br>D3DVAL(0.0), D3DVAL(1.0), D3DVAL(0.0), <br>D3DVAL(0.0), D3DVAL(1.0), D3DVAL(0.0), <br>    }; <br>    int face_data[] = {4, 0, 0, 1, 1, 2, 2, 3, 3, 0}; <br> <br>    if (FAILED(msh-&gt;lpVtbl-&gt;AddFaces(msh, vertex_count, vertices, normal_count,  <br>                          normals, face_data, NULL))) <br>  return FALSE; <br>    return TRUE; <br>} <br> <br>BOOL <br>build_face2(LPDIRECT3DRMMESHBUILDER msh) <br>{ <br>    /* <br>     * Single face with normals pointing in different directions to <br>     * approximate a curved surface. <br>     */ <br>    int vertex_count = 4; <br>    D3DVECTOR vertices[4] = {D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0), <br>D3DVAL(0.0), D3DVAL(0.0), D3DVAL(1.0), <br>D3DVAL(1.0), D3DVAL(0.0), D3DVAL(1.0), <br>D3DVAL(1.0), D3DVAL(0.0), D3DVAL(0.0) <br>    }; <br>    int normal_count = 4; <br>    D3DVECTOR normals[4] = { <br>D3DVAL(0.5), D3DVAL(0.7), D3DVAL(0.5), <br>D3DVAL(0.5), D3DVAL(0.7), -D3DVAL(0.5), <br>-D3DVAL(0.5), D3DVAL(0.7), -D3DVAL(0.5), <br>-D3DVAL(0.5), D3DVAL(0.7), D3DVAL(0.5) <br>    }; <br>    int face_data[] = {4, 0, 0, 1, 1, 2, 2, 3, 3, 0}; <br> <br>    if (FAILED(msh-&gt;lpVtbl-&gt;AddFaces(msh, vertex_count, vertices, normal_count,  <br>                          normals, face_data, NULL))) <br>  return FALSE; <br>    return TRUE; <br>} <br> <br>BOOL <br>build_cube1(LPDIRECT3DRMMESHBUILDER msh) <br>{ <br>    /* <br>     * cube 1 has planar faces, one normal is shared by all vertices of a <br>     * face <br>     */ <br>    int face1_data[] = { <br>4, 1, 0, 5, 1, 7, 2, 3, 3, <br>4, 2, 4, 3, 5, 7, 6, 6, 7, <br>4, 5, 8, 4, 9, 6, 10, 7, 11, <br>4, 0, 12, 2, 13, 6, 14, 4, 15, <br>4, 0, 16, 4, 17, 5, 18, 1, 19, <br>4, 0, 20, 1, 21, 3, 22, 2, 23, <br>    0}; <br> <br>    D3DVECTOR cube1_normals[] = { <br>D3DVAL(0.0), D3DVAL(0.0), D3DVAL(1.0), <br>D3DVAL(0.0), D3DVAL(0.0), D3DVAL(1.0), <br>D3DVAL(0.0), D3DVAL(0.0), D3DVAL(1.0), <br>D3DVAL(0.0), D3DVAL(0.0), D3DVAL(1.0), <br>D3DVAL(0.0), D3DVAL(1.0), D3DVAL(0.0), <br>D3DVAL(0.0), D3DVAL(1.0), D3DVAL(0.0), <br>D3DVAL(0.0), D3DVAL(1.0), D3DVAL(0.0), <br>D3DVAL(0.0), D3DVAL(1.0), D3DVAL(0.0), <br>D3DVAL(1.0), D3DVAL(0.0), D3DVAL(0.0), <br>D3DVAL(1.0), D3DVAL(0.0), D3DVAL(0.0), <br>D3DVAL(1.0), D3DVAL(0.0), D3DVAL(0.0), <br>D3DVAL(1.0), D3DVAL(0.0), D3DVAL(0.0), <br>D3DVAL(0.0), D3DVAL(0.0), -D3DVAL(1.0), <br>D3DVAL(0.0), D3DVAL(0.0), -D3DVAL(1.0), <br>D3DVAL(0.0), D3DVAL(0.0), -D3DVAL(1.0), <br>D3DVAL(0.0), D3DVAL(0.0), -D3DVAL(1.0), <br>D3DVAL(0.0), -D3DVAL(1.0), D3DVAL(0.0), <br>D3DVAL(0.0), -D3DVAL(1.0), D3DVAL(0.0), <br>D3DVAL(0.0), -D3DVAL(1.0), D3DVAL(0.0), <br>D3DVAL(0.0), -D3DVAL(1.0), D3DVAL(0.0), <br>-D3DVAL(1.0), D3DVAL(0.0), D3DVAL(0.0) <br>- D3DVAL(1.0), D3DVAL(0.0), D3DVAL(0.0) <br>- D3DVAL(1.0), D3DVAL(0.0), D3DVAL(0.0) <br>- D3DVAL(1.0), D3DVAL(0.0), D3DVAL(0.0) <br>    }; <br> <br>    if (FAILED(msh-&gt;lpVtbl-&gt;AddFaces(msh, 8, cube_vertices, 6 * 4, cube1_normals, <br>  face1_data, NULL))) <br>  return FALSE; <br>    return TRUE; <br>} <br> <br>BOOL <br>build_cube2(LPDIRECT3DRMMESHBUILDER msh) <br>{ <br>    /* <br>     * cube 2 has rounded faces, the normals radiate out at each vertex, <br>     * one normal to each vertex <br>     */ <br> <br>    int face2_data[] = { <br>4, 1, 1, 5, 5, 7, 7, 3, 3, <br>4, 2, 2, 3, 3, 7, 7, 6, 6, <br>4, 5, 5, 4, 4, 6, 6, 7, 7, <br>4, 0, 0, 2, 2, 6, 6, 4, 4, <br>4, 0, 0, 4, 4, 5, 5, 1, 1, <br>4, 0, 0, 1, 1, 3, 3, 2, 2, <br>    0}; <br> <br>    D3DVECTOR cube2_normals[] = { <br>-D3DVAL(1.0), -D3DVAL(1.0), -D3DVAL(1.0), <br>-D3DVAL(1.0), -D3DVAL(1.0), D3DVAL(1.0), <br>-D3DVAL(1.0), D3DVAL(1.0), -D3DVAL(1.0), <br>-D3DVAL(1.0), D3DVAL(1.0), D3DVAL(1.0), <br>D3DVAL(1.0), -D3DVAL(1.0), -D3DVAL(1.0), <br>D3DVAL(1.0), -D3DVAL(1.0), D3DVAL(1.0), <br>D3DVAL(1.0), D3DVAL(1.0), -D3DVAL(1.0), <br>D3DVAL(1.0), D3DVAL(1.0), D3DVAL(1.0) <br>    }; <br>    if (FAILED(msh-&gt;lpVtbl-&gt;AddFaces(msh, 8, cube_vertices, 8, cube2_normals, <br>  face2_data, NULL))) <br>  return FALSE; <br>    return TRUE; <br>} <br> <br>BOOL <br>BuildScene(LPDIRECT3DRMDEVICE dev, LPDIRECT3DRMVIEWPORT view, <br>   LPDIRECT3DRMFRAME scene, LPDIRECT3DRMFRAME camera) <br>{ <br>    D3DRMRENDERQUALITY quality = D3DRMRENDER_GOURAUD; <br>    LPDIRECT3DRMMESHBUILDER light_builder, face1_builder, face2_builder; <br>    LPDIRECT3DRMMESHBUILDER cube1_builder, cube2_builder; <br>    LPDIRECT3DRMMESH light_mesh, face1_mesh, face2_mesh, cube1_mesh, cube2_mesh; <br>    LPDIRECT3DRMFRAME frame1, frame2, face_frame1, face_frame2, light_frame; <br>    LPDIRECT3DRMFRAME lights; <br>    LPDIRECT3DRMLIGHT light1, light2; <br>    HRESULT rval; <br> <br>    view = view;/* not used */ <br>    light_builder = NULL; face1_builder = NULL; face2_builder = NULL; <br>    cube1_builder = NULL; cube2_builder = NULL; <br>    light_mesh = NULL; face1_mesh = NULL; face2_mesh = NULL; <br>    cube1_mesh = NULL; cube2_mesh = NULL; <br>    frame1 = NULL; frame2 = NULL; face_frame1 = NULL; face_frame2 = NULL; <br>    light_frame = NULL; lights = NULL; light1 = NULL; light2 = NULL; <br> <br>    /* <br>     * This Demo shows the construction of planar faces\n"); with vertex <br>     * normals for realistic modelling of\n"); flat and curved surfaces by <br>     * polygonal approximation.\n"); <br>     */ <br> <br>    if (FAILED(dev-&gt;lpVtbl-&gt;SetQuality(dev, quality))) <br>goto generic_error; <br> <br>    if (FAILED(lpD3DRM-&gt;lpVtbl-&gt;CreateFrame(lpD3DRM, scene, &amp;face_frame1))) <br>goto generic_error; <br>    if (FAILED(lpD3DRM-&gt;lpVtbl-&gt;CreateFrame(lpD3DRM, scene, &amp;face_frame2))) <br>goto generic_error; <br>    if (FAILED(lpD3DRM-&gt;lpVtbl-&gt;CreateFrame(lpD3DRM, scene, &amp;frame1))) <br>goto generic_error; <br>    if (FAILED(lpD3DRM-&gt;lpVtbl-&gt;CreateFrame(lpD3DRM, scene, &amp;frame2))) <br>goto generic_error; <br>    if (FAILED(lpD3DRM-&gt;lpVtbl-&gt;CreateFrame(lpD3DRM, scene, &amp;light_frame))) <br>goto generic_error; <br>    if (FAILED(lpD3DRM-&gt;lpVtbl-&gt;CreateFrame(lpD3DRM, light_frame, &amp;lights))) <br>goto generic_error; <br> <br>    if (FAILED(lights-&gt;lpVtbl-&gt;SetPosition(lights, light_frame, D3DVAL(0.0), D3DVAL(0.0), D3DVAL(2.2)))) <br>goto generic_error; <br>    if (FAILED(light_frame-&gt;lpVtbl-&gt;SetPosition(light_frame, scene, D3DVAL(0.0), D3DVAL(0.4), D3DVAL(0.0)))) <br>goto generic_error; <br> <br>    if (FAILED(lpD3DRM-&gt;lpVtbl-&gt;CreateLightRGB(lpD3DRM, D3DRMLIGHT_POINT, D3DVAL(0.9), <br>                                  D3DVAL(0.8), D3DVAL(0.7), &amp;light1))) <br>  goto generic_error; <br>    if (FAILED(lpD3DRM-&gt;lpVtbl-&gt;CreateLightRGB(lpD3DRM, D3DRMLIGHT_AMBIENT, D3DVAL(0.02), <br>                                  D3DVAL(0.01), D3DVAL(0.01), &amp;light2))) <br>  goto generic_error; <br>    if (FAILED(lights-&gt;lpVtbl-&gt;AddLight(lights, light1))) <br>goto generic_error; <br>    if (FAILED(scene-&gt;lpVtbl-&gt;AddLight(scene, light2))) <br>goto generic_error; <br>    RELEASE(light1); <br>    RELEASE(light2); <br> <br>    if (FAILED(lpD3DRM-&gt;lpVtbl-&gt;CreateMeshBuilder(lpD3DRM, &amp;face1_builder))) <br>goto generic_error; <br>    if (FAILED(lpD3DRM-&gt;lpVtbl-&gt;CreateMeshBuilder(lpD3DRM, &amp;face2_builder))) <br>goto generic_error; <br>    if (FAILED(lpD3DRM-&gt;lpVtbl-&gt;CreateMeshBuilder(lpD3DRM, &amp;cube1_builder))) <br>goto generic_error; <br>    if (FAILED(lpD3DRM-&gt;lpVtbl-&gt;CreateMeshBuilder(lpD3DRM, &amp;cube2_builder))) <br>goto generic_error; <br> <br>    if (!build_face1(face1_builder)) <br>goto generic_error; <br>    if (!build_face2(face2_builder)) <br>goto generic_error; <br>    if (!build_cube1(cube1_builder)) <br>goto generic_error; <br>    if (!build_cube2(cube2_builder)) <br>goto generic_error; <br> <br>    if (FAILED(face1_builder-&gt;lpVtbl-&gt;CreateMesh(face1_builder, &amp;face1_mesh))) <br>goto generic_error; <br>    if (FAILED(face2_builder-&gt;lpVtbl-&gt;CreateMesh(face2_builder, &amp;face2_mesh))) <br>goto generic_error; <br>    if (FAILED(cube1_builder-&gt;lpVtbl-&gt;CreateMesh(cube1_builder, &amp;cube1_mesh))) <br>goto generic_error; <br>    if (FAILED(cube2_builder-&gt;lpVtbl-&gt;CreateMesh(cube2_builder, &amp;cube2_mesh))) <br>goto generic_error; <br> <br>    RELEASE(face1_builder); <br>    RELEASE(face2_builder); <br>    RELEASE(cube1_builder); <br>    RELEASE(cube2_builder); <br> <br>    if (FAILED(face_frame1-&gt;lpVtbl-&gt;AddVisual(face_frame1, (LPDIRECT3DRMVISUAL) face1_mesh))) <br>goto generic_error; <br>    if (FAILED(face_frame2-&gt;lpVtbl-&gt;AddVisual(face_frame2, (LPDIRECT3DRMVISUAL) face2_mesh))) <br>goto generic_error; <br>    if (FAILED(frame1-&gt;lpVtbl-&gt;AddVisual(frame1, (LPDIRECT3DRMVISUAL) cube1_mesh))) <br>goto generic_error; <br>    if (FAILED(frame2-&gt;lpVtbl-&gt;AddVisual(frame2, (LPDIRECT3DRMVISUAL) cube2_mesh))) <br>goto generic_error; <br> <br>    if (FAILED(lpD3DRM-&gt;lpVtbl-&gt;CreateMeshBuilder(lpD3DRM, &amp;light_builder))) <br>goto generic_error; <br>    rval = light_builder-&gt;lpVtbl-&gt;Load(light_builder, "sphere0.x", NULL, <br>    D3DRMLOAD_FROMFILE, NULL, NULL); <br>    if (rval != D3DRM_OK) { <br>        Msg("Failed to load sphere0.x\n"); <br>goto ret_with_error; <br>    } <br>    if (FAILED(light_builder-&gt;lpVtbl-&gt;SetColorRGB(light_builder, D3DVAL(1), D3DVAL(1), <br>                                        D3DVAL(1)))) <br>goto generic_error; <br>    if (FAILED(light_builder-&gt;lpVtbl-&gt;Scale(light_builder, D3DVAL(0.1), D3DVAL(0.1),  <br>                                 D3DVAL(0.1)))) <br> goto generic_error; <br>    if (FAILED(light_builder-&gt;lpVtbl-&gt;SetQuality(light_builder, D3DRMRENDER_UNLITFLAT))) <br>goto generic_error; <br>    if (FAILED(light_builder-&gt;lpVtbl-&gt;CreateMesh(light_builder, &amp;light_mesh))) <br>goto generic_error; <br>    RELEASE(light_builder); <br> <br>    if (FAILED(lights-&gt;lpVtbl-&gt;AddVisual(lights, (LPDIRECT3DRMVISUAL) light_mesh))) <br>goto generic_error; <br> <br>    if (FAILED(camera-&gt;lpVtbl-&gt;SetPosition(camera, scene, D3DVAL(0.0), D3DVAL(2), -D3DVAL(5)))) <br>goto generic_error; <br>    if (FAILED(face_frame1-&gt;lpVtbl-&gt;SetPosition(face_frame1, scene, -D3DVAL(0.5),  <br>                                     D3DVAL(0.5), D3DVAL(2)))) <br>     goto generic_error; <br>    if (FAILED(face_frame2-&gt;lpVtbl-&gt;SetPosition(face_frame2, scene, -D3DVAL(0.5),  <br>                                     -D3DVAL(1.5), D3DVAL(2)))) <br>     goto generic_error; <br>    if (FAILED(frame1-&gt;lpVtbl-&gt;SetPosition(frame1, scene, -D3DVAL(2.0), D3DVAL(0.0), D3DVAL(2)))) <br>goto generic_error; <br>    if (FAILED(frame2-&gt;lpVtbl-&gt;SetPosition(frame2, scene, D3DVAL(1.5), D3DVAL(0.0), D3DVAL(2)))) <br>goto generic_error; <br> <br>    if (FAILED(face_frame1-&gt;lpVtbl-&gt;SetOrientation(face_frame1, scene, D3DVAL(0.0), D3DVAL(1), D3DVAL(0.0), <br>                                        D3DVAL(0.0), D3DVAL(0.0), -D3DVAL(1)))) <br>goto generic_error; <br>    if (FAILED(face_frame2-&gt;lpVtbl-&gt;SetOrientation(face_frame2, scene, D3DVAL(0.0), D3DVAL(1), D3DVAL(0.0), <br>                                        D3DVAL(0.0), D3DVAL(0.0), -D3DVAL(1)))) <br>goto generic_error; <br>    if (FAILED(camera-&gt;lpVtbl-&gt;SetOrientation(camera, scene, D3DVAL(0.0), -D3DVAL(0.2), D3DVAL(1), <br>                                   D3DVAL(0.0), D3DVAL(1), D3DVAL(0.0)))) <br>   goto generic_error; <br>    if (FAILED(frame1-&gt;lpVtbl-&gt;SetRotation(frame1, scene, D3DVAL(1), D3DVAL(0.0), D3DVAL(1), <br>                                -D3DVAL(0.005)))) <br>goto generic_error; <br>    if (FAILED(frame2-&gt;lpVtbl-&gt;SetRotation(frame2, scene, D3DVAL(0.0), D3DVAL(1), D3DVAL(1), <br>                                -D3DVAL(0.005)))) <br>goto generic_error; <br>    if (FAILED(light_frame-&gt;lpVtbl-&gt;SetRotation(light_frame, scene, D3DVAL(0.0), D3DVAL(1), D3DVAL(0.0), <br>                                     -D3DVAL(0.02)))) <br>     goto generic_error; <br> <br>    RELEASE(light_mesh); <br>    RELEASE(face1_mesh); <br>    RELEASE(face2_mesh); <br>    RELEASE(cube1_mesh); <br>    RELEASE(cube2_mesh); <br> <br>    RELEASE(frame1); <br>    RELEASE(frame2); <br>    RELEASE(face_frame1); <br>    RELEASE(face_frame2); <br>    RELEASE(light_frame); <br>    RELEASE(lights); <br>    return TRUE; <br>generic_error: <br>    Msg("An error has occurred while building the scene.\n"); <br>ret_with_error: <br>    RELEASE(light_builder); <br>    RELEASE(face1_builder); <br>    RELEASE(face2_builder); <br>    RELEASE(cube1_builder); <br>    RELEASE(cube2_builder); <br>    RELEASE(light_mesh); <br>    RELEASE(face1_mesh); <br>    RELEASE(face2_mesh); <br>    RELEASE(cube1_mesh); <br>    RELEASE(cube2_mesh); <br>    RELEASE(frame1); <br>    RELEASE(frame2); <br>    RELEASE(face_frame1); <br>    RELEASE(face_frame2); <br>    RELEASE(light_frame); <br>    RELEASE(lights); <br>    RELEASE(light1); <br>    RELEASE(light2); <br>    return FALSE; <br>} <br> <br>void <br>OverrideDefaults(Defaults *defaults) <br>{ <br>    defaults-&gt;bNoTextures = TRUE; <br>    defaults-&gt;bConstRenderQuality = TRUE; <br>    lstrcpy(defaults-&gt;Name, "Faces Direct3DRM Example"); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
