<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>UVIS.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3356"></a>UVIS.CPP</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1995, 1996 Microsoft Corporation. All Rights Reserved. <br> * <br> *  File: uvis.cpp <br> * <br> ***************************************************************************/ <br> <br>#include &lt;math.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;d3d.h&gt; <br>#include "d3dmacs.h" <br>#include "rmdemo.h" <br> <br>typedef struct _Flame { <br>    intvalid; <br>    D3DVECTORvelocity;/* direction the flame is going */ <br>    D3DVECTORorientation;/* random vector normal to velocity */ <br>    D3DVECTORposition;/* current position */ <br>    inttime;/* current time */ <br>    intlifetime;/* time to die */ <br>} Flame; <br> <br>/* <br> * A flame is a diamond shape oriented along its direction vector. <br> * This updates the four vertices of the flame, given its current time. <br> */ <br>void UpdateFlame(Flame* flame, D3DVERTEX v[]) <br>{ <br>    D3DVECTOR dir = flame-&gt;velocity; <br>    D3DVECTOR off = flame-&gt;orientation; <br>    D3DVECTOR norm; <br>    D3DVECTOR start, end, left, right; <br>    double size; <br>    int i; <br> <br>    D3DRMVectorNormalise(&amp;dir); <br> <br>    /* <br>     * Calculate a normal vector to the flame <br>     */ <br>    D3DRMVectorCrossProduct(&amp;norm, &amp;dir, &amp;off); <br>    D3DRMVectorNormalise(&amp;norm); <br> <br>    /* <br>     * The size starts off small, gets bigger towards the middle <br>     * and smaller towards the end. <br>     */ <br>    if (flame-&gt;time &lt; flame-&gt;lifetime / 2) <br>size = (double) flame-&gt;time / (double)(flame-&gt;lifetime / 2); <br>    else <br>size = ((double) (flame-&gt;lifetime - flame-&gt;time) <br>/ (double)(flame-&gt;lifetime / 2)); <br> <br>    /* <br>     * Calculate the four corners of the diamond. <br>     */ <br>    D3DRMVectorScale(&amp;dir, &amp;dir, D3DVAL(size)); <br>    D3DRMVectorScale(&amp;off, &amp;off, D3DVAL(size / 4)); <br>    start = flame-&gt;position; <br>    D3DRMVectorAdd(&amp;end, &amp;start, &amp;dir); <br>    D3DRMVectorScale(&amp;dir, &amp;dir, D3DVAL(0.5)); <br>    D3DRMVectorAdd(&amp;left, &amp;start, &amp;dir); <br>    right = left; <br>    D3DRMVectorAdd(&amp;left, &amp;left, &amp;off); <br>    D3DRMVectorSubtract(&amp;right, &amp;right, &amp;off); <br> <br> <br>    /* <br>     * Update the flame's position. <br>     */ <br>    D3DRMVectorAdd(&amp;flame-&gt;position, &amp;flame-&gt;position, &amp;flame-&gt;velocity); <br>    flame-&gt;time++; <br>    if (flame-&gt;time == flame-&gt;lifetime) <br>flame-&gt;valid = 0; <br> <br>    /* <br>     * And fill in the vertices.  There are eight, four for each side of <br>     * the flame. <br>     */ <br>    i = 0; <br>    v[i].x = start.x; v[i].y = start.y; v[i].z = start.z; <br>    v[i].nx = -norm.x; v[i].ny = -norm.y; v[i].nz = -norm.z; <br>    v[i].tu = D3DVAL(0); v[i].tv = D3DVAL(0); <br>    i++; <br> <br>    v[i].x = left.x; v[i].y = left.y; v[i].z = left.z; <br>    v[i].nx = -norm.x; v[i].ny = -norm.y; v[i].nz = -norm.z; <br>    v[i].tu = D3DVAL(1); v[i].tv = D3DVAL(0); <br>    i++; <br> <br>    v[i].x = end.x; v[i].y = end.y; v[i].z = end.z; <br>    v[i].nx = -norm.x; v[i].ny = -norm.y; v[i].nz = -norm.z; <br>    v[i].tu = D3DVAL(1); v[i].tv = D3DVAL(1); <br>    i++; <br> <br>    v[i].x = right.x; v[i].y = right.y; v[i].z = right.z; <br>    v[i].nx = -norm.x; v[i].ny = -norm.y; v[i].nz = -norm.z; <br>    v[i].tu = D3DVAL(0); v[i].tv = D3DVAL(1); <br>    i++; <br> <br>    v[i].x = start.x; v[i].y = start.y; v[i].z = start.z; <br>    v[i].nx = norm.x; v[i].ny = norm.y; v[i].nz = norm.z; <br>    v[i].tu = D3DVAL(0); v[i].tv = D3DVAL(0); <br>    i++; <br> <br>    v[i].x = right.x; v[i].y = right.y; v[i].z = right.z; <br>    v[i].nx = norm.x; v[i].ny = norm.y; v[i].nz = norm.z; <br>    v[i].tu = D3DVAL(0); v[i].tv = D3DVAL(1); <br>    i++; <br> <br>    v[i].x = end.x; v[i].y = end.y; v[i].z = end.z; <br>    v[i].nx = norm.x; v[i].ny = norm.y; v[i].nz = norm.z; <br>    v[i].tu = D3DVAL(1); v[i].tv = D3DVAL(1); <br>    i++; <br> <br>    v[i].x = left.x; v[i].y = left.y; v[i].z = left.z; <br>    v[i].nx = norm.x; v[i].ny = norm.y; v[i].nz = norm.z; <br>    v[i].tu = D3DVAL(1); v[i].tv = D3DVAL(0); <br>    i++; <br> <br>} <br> <br>void InitFlame(Flame* flame) <br>{ <br>    D3DVECTOR d, u; <br> <br>    flame-&gt;valid = TRUE; <br> <br>    do { <br>      D3DRMVectorRandom(&amp;d); <br>      d.y = d.y * d.y; <br>      d.y = d.y * d.y; <br>    } while (d.y &lt; D3DVAL(0.3)); <br> <br>    /* <br>     * Pick a vector normal to d <br>     */ <br>    if (d.y != D3DVAL(0.0) || d.z != D3DVAL(0.0)) <br>    { <br>u.x = D3DVAL(0.0); <br>if (d.y == D3DVAL(0.0)) <br>{ <br>    u.y = D3DVAL(1.0); <br>    u.z = D3DVAL(0.0); <br>} else { <br>    D3DVALUE n_fix = <br>D3DVAL(1.0) <br>+ D3DDivide(D3DMultiply(d.z, d.z), D3DMultiply(d.y, d.y)); <br>    u.z = D3DVAL(sqrt(D3DDivide(D3DVAL(1.0), D3DVAL(n_fix)))); <br>    u.y = -D3DMultiply(u.z, D3DDivide(d.z, d.y)); <br>} <br>    } else { <br>u.x = D3DVAL(0.0); <br>u.y = D3DVAL(0.0); <br>u.z = D3DVAL(1.0); <br>    } <br> <br>    /* <br>     * Randomize it. <br>     */ <br>    D3DRMVectorRotate(&amp;u, &amp;u, &amp;d, D3DDivide(D3DVAL(6.28 * (rand() % 100)), <br>        D3DVAL(100.0))); <br> <br>    D3DRMVectorScale(&amp;d, &amp;d, D3DVAL(0.1)); <br>    flame-&gt;velocity = d; <br>    flame-&gt;orientation = u; <br>    flame-&gt;position.x = D3DVAL(0); <br>    flame-&gt;position.y = D3DVAL(0); <br>    flame-&gt;position.z = D3DVAL(0); <br>    flame-&gt;time = 0; <br>    do { <br>flame-&gt;lifetime = rand() % 30; <br>    } while (flame-&gt;lifetime &lt; 5); <br>} <br> <br>#define MAX_FLAMES100 <br> <br>typedef struct _Fire { <br>    Flame flames[MAX_FLAMES]; <br>    LPDIRECT3DRMDEVICE dev; <br>    LPDIRECT3DEXECUTEBUFFER eb; <br>    LPDIRECT3DMATERIAL mat; <br>} Fire; <br> <br>void CDECL CleanupFireObjects(LPDIRECT3DRMOBJECT dev, void* arg) <br>{ <br>    Fire* fire = (Fire*) arg; <br> <br>    if (fire-&gt;eb) { <br>fire-&gt;eb-&gt;Release(); <br>fire-&gt;mat-&gt;Release(); <br>fire-&gt;eb = NULL; <br>fire-&gt;dev = NULL; <br>    } <br>} <br> <br>typedef struct _FireExecuteBuffer { <br>    D3DVERTEXv[8 * MAX_FLAMES]; <br>    D3DINSTRUCTIONop_state_light1; <br>    D3DSTATEstate1; <br>    D3DINSTRUCTIONop_set_status; <br>    D3DSTATUSsetstatus1; <br>    D3DINSTRUCTIONop_process_vertices1; <br>    D3DPROCESSVERTICESprocessvertices1; <br>    D3DINSTRUCTIONop_state_render; <br>    D3DSTATEstate2; <br>    D3DSTATEstate3; <br>    D3DSTATEstate4; <br>    D3DINSTRUCTIONop_triangle_list; <br>    D3DTRIANGLEtri[4 * MAX_FLAMES]; <br>    D3DINSTRUCTIONexit1; <br>} FireExecuteBuffer; <br> <br>BOOL CreateFireObjects(Fire* fire, LPDIRECT3DRMDEVICE dev) <br>{ <br>    D3DEXECUTEBUFFERDESC desc; <br>    D3DEXECUTEDATA data; <br>    LPDIRECT3D lpD3D = NULL; <br>    LPDIRECT3DDEVICE lpD3DDev = NULL; <br>    LPDIRECT3DMATERIAL mat = NULL; <br>    LPDIRECT3DEXECUTEBUFFER eb = NULL; <br>    D3DMATERIALHANDLE hMat; <br>    D3DMATERIAL orange; <br>    void* p; <br>    int i; <br> <br>    RELEASE(fire-&gt;eb); <br> <br>    dev-&gt;GetDirect3DDevice(&amp;lpD3DDev); <br>    if (!lpD3DDev) <br>goto generic_error; <br>    if (FAILED(lpD3DDev-&gt;GetDirect3D(&amp;lpD3D))) <br>goto generic_error; <br> <br>    desc.dwSize = sizeof(desc); <br>    desc.dwFlags = D3DDEB_BUFSIZE; <br>    desc.dwBufferSize = sizeof(FireExecuteBuffer); <br>     <br>    if (FAILED(lpD3DDev-&gt;CreateExecuteBuffer(&amp;desc, &amp;eb, NULL))) <br>goto generic_error; <br> <br>    if (FAILED(lpD3D-&gt;CreateMaterial(&amp;mat, NULL))) <br>goto generic_error; <br>    if (FAILED(mat-&gt;GetHandle(lpD3DDev, &amp;hMat))) <br>goto generic_error; <br> <br>    memset(&amp;orange, 0, sizeof(orange)); <br>    orange.dwSize = sizeof(orange); <br>    orange.diffuse.r = D3DVAL(1.0); <br>    orange.diffuse.g = D3DVAL(0.5); <br>    orange.diffuse.b = D3DVAL(0.0); <br>    orange.ambient.r = D3DVAL(1.0); <br>    orange.ambient.g = D3DVAL(0.5); <br>    orange.ambient.b = D3DVAL(0.0); <br>    orange.dwRampSize = 32; <br>    if (FAILED(mat-&gt;SetMaterial(&amp;orange))) <br>goto generic_error; <br> <br>    if (FAILED(eb-&gt;Lock(&amp;desc))) <br>goto generic_error; <br>    p = (void*) ((char*) desc.lpData + 8 * MAX_FLAMES * sizeof(D3DVERTEX)); <br> <br>    OP_STATE_LIGHT(1, p); <br>STATE_DATA(D3DLIGHTSTATE_MATERIAL, hMat, p); <br> <br>    OP_SET_STATUS(D3DSETSTATUS_ALL, D3DSTATUS_DEFAULT, 2048, 2048, 0, 0, p); <br>     <br>    OP_PROCESS_VERTICES(1, p); <br>PROCESSVERTICES_DATA(D3DPROCESSVERTICES_TRANSFORMLIGHT, <br> 0, 8 * MAX_FLAMES, p); <br>    OP_STATE_RENDER(3, p); <br>STATE_DATA(D3DRENDERSTATE_SHADEMODE, D3DSHADE_FLAT, p); <br>STATE_DATA(D3DRENDERSTATE_TEXTUREHANDLE, 0, p); <br>STATE_DATA(D3DRENDERSTATE_BLENDENABLE, FALSE, p); <br> <br>    OP_TRIANGLE_LIST(4 * MAX_FLAMES, p); <br>    for (i = 0; i &lt; MAX_FLAMES; i++) { <br>D3DTRIANGLE* t; <br>int base; <br> <br>t = (D3DTRIANGLE*) p; <br>base = 4 * i; <br> <br>t-&gt;v1 = base + 0; <br>t-&gt;v2 = base + 1; <br>t-&gt;v3 = base + 3; <br>t-&gt;wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE; <br>t++; <br> <br>t-&gt;v1 = base + 1; <br>t-&gt;v2 = base + 2; <br>t-&gt;v3 = base + 3; <br>t-&gt;wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE; <br>t++; <br> <br>t-&gt;v1 = base + 0; <br>t-&gt;v2 = base + 1; <br>t-&gt;v3 = base + 3; <br>t-&gt;wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE; <br>t++; <br> <br>t-&gt;v1 = base + 1; <br>t-&gt;v2 = base + 2; <br>t-&gt;v3 = base + 3; <br>t-&gt;wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE; <br>t++; <br> <br>p = (char*) t; <br>    } <br>    OP_EXIT(p); <br> <br>    if (FAILED(eb-&gt;Unlock())) <br>goto generic_error; <br> <br>    data.dwSize = sizeof(data); <br>    data.dwVertexOffset = 0; <br>    data.dwVertexCount = 8 * MAX_FLAMES; <br>    data.dwInstructionOffset = 8 * MAX_FLAMES * sizeof(D3DVERTEX); <br>    data.dwInstructionLength = sizeof(FireExecuteBuffer) - data.dwInstructionOffset; <br>    data.dwHVertexOffset = 0; <br>    if (FAILED(eb-&gt;SetExecuteData(&amp;data))) <br>goto generic_error; <br> <br>    fire-&gt;eb = eb; <br>    fire-&gt;mat = mat; <br>    fire-&gt;dev = dev; <br>    if (FAILED(dev-&gt;AddDestroyCallback(CleanupFireObjects, fire))) <br>goto generic_error; <br> <br>    RELEASE(lpD3DDev); <br>    RELEASE(lpD3D); <br>    return TRUE; <br>generic_error: <br>    RELEASE(lpD3D); <br>    RELEASE(lpD3DDev); <br>    RELEASE(mat); <br>    RELEASE(eb); <br>    return FALSE; <br>} <br> <br>BOOL RenderFire(Fire* fire, LPDIRECT3DRMDEVICE dev, LPDIRECT3DRMVIEWPORT view) <br>{ <br>    D3DVERTEX* v; <br>    D3DEXECUTEBUFFERDESC desc; <br>    D3DEXECUTEDATA data; <br>    LPDIRECT3DDEVICE lpD3DDev = NULL; <br>    LPDIRECT3DVIEWPORT lpD3DView = NULL; <br>    int i; <br> <br>    if (fire-&gt;dev != dev) { <br>if (!CreateFireObjects(fire, dev)) <br>    return FALSE; <br>    } <br> <br>    dev-&gt;GetDirect3DDevice(&amp;lpD3DDev); <br>    view-&gt;GetDirect3DViewport(&amp;lpD3DView); <br>    if (!lpD3DDev || !lpD3DView) <br>goto ret_with_error; <br> <br>    for (i = 0; i &lt; MAX_FLAMES; i++) <br>if (!fire-&gt;flames[i].valid) <br>    InitFlame(&amp;fire-&gt;flames[i]); <br> <br>    desc.dwSize = sizeof(desc); <br>    desc.dwFlags = 0; <br>     <br>    if (FAILED(fire-&gt;eb-&gt;Lock(&amp;desc))) <br>goto ret_with_error; <br>    v = (D3DVERTEX*) desc.lpData; <br> <br>    for (i = 0; i &lt; MAX_FLAMES; i++) <br>UpdateFlame(&amp;fire-&gt;flames[i], &amp;v[8 * i]); <br> <br>    if (FAILED(fire-&gt;eb-&gt;Unlock())) <br>goto ret_with_error; <br> <br>    if (FAILED(lpD3DDev-&gt;Execute(fire-&gt;eb, lpD3DView, D3DEXECUTE_CLIPPED))) <br>goto ret_with_error; <br> <br>    data.dwSize = sizeof data; <br>    if (FAILED(fire-&gt;eb-&gt;GetExecuteData(&amp;data))) <br>goto ret_with_error; <br>    if (FAILED(view-&gt;ForceUpdate(data.dsStatus.drExtent.x1, <br>      data.dsStatus.drExtent.y1, <br>      data.dsStatus.drExtent.x2, <br>      data.dsStatus.drExtent.y2))) <br>      goto ret_with_error; <br> <br>    RELEASE(lpD3DDev); <br>    RELEASE(lpD3DView); <br>    return TRUE; <br>ret_with_error: <br>    RELEASE(lpD3DDev); <br>    RELEASE(lpD3DView); <br>    return FALSE; <br>} <br> <br>int CDECL FireCallback(LPDIRECT3DRMUSERVISUAL uvis, <br> void* arg, <br> D3DRMUSERVISUALREASON reason, <br> LPDIRECT3DRMDEVICE dev, <br> LPDIRECT3DRMVIEWPORT view) <br>{ <br>    Fire* fire = (Fire*) arg; <br> <br>    if (reason == D3DRMUSERVISUAL_CANSEE) <br>return TRUE; <br> <br>    if (reason == D3DRMUSERVISUAL_RENDER) { <br>if (!RenderFire(fire, dev, view)) <br>    return DDERR_GENERIC; <br>else <br>    return D3D_OK; <br>    } <br> <br>    return 0; <br>} <br> <br>void CDECL DestroyFire(LPDIRECT3DRMOBJECT obj, void* arg) <br>{ <br>    Fire* fire = (Fire*) arg; <br> <br>    if (fire-&gt;dev) <br>fire-&gt;dev-&gt;DeleteDestroyCallback(CleanupFireObjects, arg); <br>    CleanupFireObjects((LPDIRECT3DRMOBJECT)fire-&gt;dev, (void*) fire); <br>    free(fire); <br>} <br> <br>LPDIRECT3DRMUSERVISUAL CreateFire() <br>{ <br>    Fire* fire; <br>    LPDIRECT3DRMUSERVISUAL uvis = NULL; <br> <br>    fire = (Fire*)malloc(sizeof(Fire)); <br>    if (!fire) <br>goto ret_with_error; <br>    memset(fire, 0, sizeof(Fire)); <br> <br>    if (FAILED(lpD3DRM-&gt;CreateUserVisual(FireCallback, (void*) fire, &amp;uvis))) <br>goto ret_with_error; <br>    if (FAILED(uvis-&gt;AddDestroyCallback(DestroyFire, (void*) fire))) <br>goto ret_with_error;    <br>    return uvis; <br>ret_with_error: <br>    if (fire) <br>free(fire); <br>    RELEASE(uvis); <br>    return NULL; <br>} <br> <br>BOOL <br>BuildScene(LPDIRECT3DRMDEVICE dev, LPDIRECT3DRMVIEWPORT view, <br>   LPDIRECT3DRMFRAME scene, LPDIRECT3DRMFRAME camera) <br>{ <br>    D3DRMRENDERQUALITY quality = D3DRMRENDER_GOURAUD; <br>    LPDIRECT3DRMFRAME lights = NULL; <br>    LPDIRECT3DRMFRAME frame = NULL; <br>    LPDIRECT3DRMLIGHT light1 = NULL; <br>    LPDIRECT3DRMLIGHT light2 = NULL; <br>    LPDIRECT3DRMUSERVISUAL uvis = NULL; <br> <br>    view = view;/* not used */ <br> <br>    if (FAILED(dev-&gt;SetQuality(quality))) <br>goto generic_error; <br> <br>    /* <br>     * initialize the lights in the scene <br>     */ <br>    if (FAILED(lpD3DRM-&gt;CreateFrame(scene, &amp;lights))) <br>goto generic_error; <br>    if (FAILED(lights-&gt;SetPosition(scene, D3DVAL(5), D3DVAL(5), -D3DVAL(1)))) <br>goto generic_error; <br>    if(FAILED(lights-&gt;SetOrientation(scene, D3DVAL(0), D3DVAL(0), D3DVAL(1), <br>   D3DVAL(0), D3DVAL(1), D3DVAL(1)))) <br>   goto generic_error; <br>    if(FAILED(lpD3DRM-&gt;CreateLightRGB(D3DRMLIGHT_DIRECTIONAL, D3DVAL(0.9), <br>  D3DVAL(0.8), D3DVAL(0.7), &amp;light1))) <br>  goto generic_error; <br>    if (FAILED(lights-&gt;AddLight(light1))) <br>goto generic_error; <br>    if(FAILED(lpD3DRM-&gt;CreateLightRGB(D3DRMLIGHT_AMBIENT, D3DVAL(0.1), <br>  D3DVAL(0.1), D3DVAL(0.1), &amp;light2))) <br>  goto generic_error; <br>    if (FAILED(scene-&gt;AddLight(light2))) <br>goto generic_error; <br> <br>    /* <br>     * create a frame within the scene <br>     */ <br>    if (FAILED(lpD3DRM-&gt;CreateFrame(scene, &amp;frame))) <br>goto generic_error; <br> <br>    /* <br>     * add the fire into the frame <br>     */ <br>    uvis = CreateFire(); <br>    if (!uvis) <br>goto generic_error; <br>    if (FAILED(frame-&gt;AddVisual(uvis))) <br>goto generic_error; <br> <br>    /* <br>     * set up the frames position, orientation and rotation <br>     */ <br>    if (FAILED(camera-&gt;SetPosition(scene, D3DVAL(0), D3DVAL(0.5), -D3DVAL(10)))) <br>goto generic_error; <br>    if(FAILED(camera-&gt;SetOrientation(scene, D3DVAL(0), D3DVAL(0), D3DVAL(1), D3DVAL(0), <br>   D3DVAL(1), D3DVAL(0)))) <br>   goto generic_error; <br>    if(FAILED(frame-&gt;SetRotation(scene, D3DVAL(0), D3DVAL(1), D3DVAL(0), <br>       D3DVAL(0.02)))) <br>       goto generic_error; <br> <br>    RELEASE(uvis); <br>    RELEASE(frame); <br>    RELEASE(lights); <br>    RELEASE(light1); <br>    RELEASE(light2); <br>    return TRUE; <br>generic_error: <br>    Msg("A failure occurred while building the scene.\n"); <br>    RELEASE(lights); <br>    RELEASE(frame); <br>    RELEASE(light1); <br>    RELEASE(light2); <br>    RELEASE(uvis); <br>    return FALSE; <br>} <br> <br>void <br>OverrideDefaults(Defaults *defaults) <br>{ <br>    defaults-&gt;bConstRenderQuality = TRUE; <br>    defaults-&gt;bNoTextures = TRUE; <br>    lstrcpy(defaults-&gt;Name, "User Visual Direct3DRM Example"); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
