<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GARGLE.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3174"></a>GARGLE.CPP</h2>
<pre><code>#include "fdfilter.h" <br>#include "filter.h" <br> <br>CGargle::CGargle( int nFreq, int nChannels, int nBytesPerSample ) <br>    { <br>    m_nPhase = 0; <br>    m_Shape = SHAPE_TRIANGLE; <br>    m_nGargleRate = 10; <br>    m_nBytesPerSample = nBytesPerSample; <br>    m_nSamplesPerSec = nFreq; <br>    m_nChannels = nChannels; <br>    } <br> <br> <br>//Below resutls in cl error C2600 - the compiler <br>//has already generated a default destructor due <br>//to the abstract delcaration of the CGargle class <br>//in FDFILTER.H <br>//CGargle::~CGargle() <br>//    { <br>//    } <br> <br> <br>// Copy the required information about the new format for the buffer <br>HRESULT CGargle::SetFormat( PWAVEFORMATEX pwfx ) <br>    { <br>    if( NULL == pwfx ) <br>        return ResultFromScode( E_POINTER ); <br> <br>    m_nSamplesPerSec = pwfx-&gt;nSamplesPerSec; <br>    m_nChannels = pwfx-&gt;nChannels; <br>    m_nBytesPerSample = pwfx-&gt;wBitsPerSample / 8; <br> <br>    return NOERROR;     <br>    } <br> <br> <br>// <br>// MessItAbout <br>// <br>// Mess the sound about by modulating it with a waveform. <br>// We know the frequency of the modulation (from the slider setting <br>// which we were told through our internal interface, IGargle, and <br>// which we stored in m_GargleRate).  At the end of the call we <br>// record what part of the waveform we finished at in m_Phase and <br>// we resume at that point next time. <br>// Uses and updates m_Phase <br>// Uses m_SamplesPerSec, m_Channels, m_GargleRate, m_Shape <br>// <br>void CGargle::MessItAbout( PBYTE pbIn, DWORD cb, PBYTE pbOut ) <br>{ <br>    // We know how many samples per sec and how <br>    // many channels so we can calculate the modulation period in samples. <br>    // <br> <br>    int Period = (m_nSamplesPerSec * m_nChannels) / m_nGargleRate; <br> <br>    while( cb &gt; 0 ) { <br>        --cb; <br> <br>        // If m_Shape is 0 (triangle) then we multiply by a triangular waveform <br>        // that runs 0..Period/2..0..Period/2..0... else by a square one that <br>        // is either 0 or Period/2 (same maximum as the triangle) or zero. <br>        // <br>        { <br>            // m_Phase is the number of samples from the start of the period. <br>            // We keep this running from one call to the next, <br>            // but if the period changes so as to make this more <br>            // than Period then we reset to 0 with a bang.  This may cause <br>            // an audible click or pop (but, hey! it's only a sample!) <br>            // <br>            ++m_nPhase; <br>            if( m_nPhase &gt; Period ) <br>                m_nPhase = 0; <br> <br>            int M = m_nPhase;      // m is what we modulate with <br> <br>            if( m_Shape == SHAPE_TRIANGLE ) {   // Triangle <br>                if( M &gt; Period / 2 ) <br>                    M = Period - M;  // handle downslope <br>            } else if( m_Shape == SHAPE_TRIANGLE ) {             // Square wave <br>                if( M &lt;= Period / 2 ) <br>                    M = Period / 2; <br>                else M = 0; <br>            } <br> <br>            if( m_nBytesPerSample == 1 ) { <br>                // 8 bit sound uses 0..255 representing -128..127 <br>                // Any overflow, even by 1, would sound very bad. <br>                // so we clip paranoically after modulating. <br>                // I think it should never clip by more than 1 <br>                // <br>                int i = *pbIn - 128;            // sound sample, zero based <br>                i = (i * M * 2) / Period;       // modulate <br>                if(i &gt; 127)                     // clip <br>                    i = 127; <br>                if(i &lt; -128) <br>                    i = -128; <br> <br>               *pbOut = (unsigned char)(i + 128);       // reset zero offset to 128 <br> <br>            } else if( m_nBytesPerSample == 2 ) { <br>                // 16 bit sound uses 16 bits properly (0 means 0) <br>                // We still clip paranoically <br>                // <br>                short int *psi = (short int *)pbOut; <br>                int i = *((short int *)pbIn);   // in a register, we might hope <br>                i = (i*M*2)/Period;     // modulate <br>                if(i &gt; 32767) <br>                    i = 32767;          // clip <br>                if(i &lt; -32768) <br>                    i = -32768; <br>                *psi = (short)i; <br>                ++pbIn; // nudge it on another 8 bits here to get a 16 bit step <br>                ++pbOut; <br>                --cb;   // and nudge the count too. <br>            } else { <br>//               DbgBreak("Too many bytes per sample"); <br>               // just leave it alone! <br>            } <br>        } <br>        ++pbIn;   // move on 8 bits to next sound sample <br>        ++pbOut; <br>    } <br>} // MessItAbout <br> <br> <br>// <br>// Transform <br>// <br>// <br>HRESULT CGargle::Transform( PBYTE pbIn, int cbWrite, PBYTE pbOut ) <br>{ <br>    // Actually transform the data <br>    // <br>    if( m_nSamplesPerSec &amp;&amp; m_nChannels &amp;&amp; m_nBytesPerSample ) <br>        MessItAbout( pbIn, cbWrite, pbOut ); <br> <br>    return NOERROR; <br> <br>} // Transform </code></pre>
<p>&nbsp;</p></body>
</HTML>
