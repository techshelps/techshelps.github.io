<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FDAUDIO.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3168"></a>FDAUDIO.CPP</h2>
<pre><code>////////////////////////////////////////////////////////////////////////////// <br>// <br>// Copyright (C) 1996-1997 Microsoft Corporation. All Rights Reserved. <br>// <br>// File:FDAUDIO.CPP <br>// Contents:Audio related routines for full-duplex device usage <br>// <br>// Description:This file includes functionality for enumerating devices &amp; <br>//formats, initializing devices and buffers, and the CALLBACK <br>//procedures for dealing with full duplex. <br>// <br> <br> <br>// So we can get the IID_IDirectSoundNotify and GUID_NULL GUID declared <br>#defineINITGUID <br>#include &lt;objbase.h&gt; <br>#include &lt;cguid.h&gt; <br> <br>#include "fdfilter.h" <br>#include "fdaudio.h" <br>#include "filter.h" <br> <br>static BOOL IsDSDeviceInList(LPGUID, PDSDEVICEDESC ); <br>static BOOL EnumDSDevices( void ); <br>static BOOL EnumDSCDevices( void ); <br>static BOOL CALLBACK DSEnumProc( LPGUID, LPCSTR, LPCSTR, LPVOID ); <br>static BOOL InitInputDevice(void); <br>static BOOL InitPrimarySoundBuffer( void ); <br>static void ProcessInput( DWORD ); <br> <br>extern HINSTANCE g_hDSoundLib; <br>typedef HRESULT (WINAPI * PFN_DSCREATE)(LPGUID lpguid, LPDIRECTSOUND * ppDS, IUnknown FAR * pUnkOuter); <br>typedef BOOL (WINAPI * PFN_DSENUMERATE)(LPDSENUMCALLBACK lpDSEnumCallback, LPVOID lpContext); <br>typedef HRESULT (WINAPI * PFN_DSCCREATE)(LPGUID lpGUID,LPDIRECTSOUNDCAPTURE *lplpDSC,LPUNKNOWN pUnkOuter); <br>typedef BOOL (WINAPI * PFN_DSCENUMERATE)(LPDSENUMCALLBACK lpDSEnumCallback,LPVOID lpContext); <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// <br>// <br>// <br>// <br>static BOOL InitSoundData( BOOL fAllowFormatCancel, BOOL fReset ) <br>{ <br>    if( NULL == gpwfxOutput ) <br>{ <br>gpwfxOutput = new WAVEFORMATEX; <br>if( NULL == gpwfxOutput ) <br>    goto ISD_Fail; <br>ZeroMemory( gpwfxOutput, sizeof(WAVEFORMATEX)); <br>gpwfxOutput-&gt;wFormatTag = WAVE_FORMAT_PCM; <br>DPF( 3, "Created gpwfxOutput" ); <br>DPWFX( 3, gpwfxOutput ); <br>} <br> <br>    if( NULL == gpwfxInput ) <br>{ <br>gpwfxInput = new WAVEFORMATEX; <br>if( NULL == gpwfxInput ) <br>    goto ISD_Fail; <br>ZeroMemory( gpwfxInput, sizeof(WAVEFORMATEX)); <br>gpwfxInput-&gt;wFormatTag = WAVE_FORMAT_PCM; <br>DPF( 3, "Created gpwfxInput" ); <br>DPWFX( 3, gpwfxInput ); <br>} <br> <br>    EnumDSDevices(); <br>    if( NULL == gpdsddOutputDevices ) <br>{ <br>MessageBox( ghMainWnd, "No DirectSound devices are available!", gszAppName, MB_OK ); <br>goto ISD_Fail; <br>} <br> <br>    EnumDSCDevices(); <br>if( NULL == gpdsddInputDevices ) <br>{ <br>MessageBox( ghMainWnd, "No DirectSoundCapture devices are available!", gszAppName, MB_OK ); <br>goto ISD_Fail; <br>} <br> <br>    if( !DialogBox( ghInst, MAKEINTRESOURCE(IDD_DEVICES), <br>    ghMainWnd, (DLGPROC)SelectDevicesDlgProc )) <br>goto ISD_Fail; <br> <br>if( fReset ) <br>{ <br>    StopBuffers(); <br>    DestroyBuffers(); <br>    CloseDSCDevice(FALSE); <br>    CloseDSDevice(); <br>} <br> <br>if( !InitPrimarySoundBuffer()) <br>goto ISD_Fail; <br> <br>if( !InitInputDevice() ) <br>goto ISD_Fail; <br> <br>    if( !DialogBoxParam( ghInst, MAKEINTRESOURCE(IDD_FORMATS), <br>    ghMainWnd, (DLGPROC)SelectFormatsDlgProc, <br>    (LPARAM)fAllowFormatCancel )) <br>goto ISD_Fail; <br> <br>    return TRUE; <br> <br>ISD_Fail: <br>    return FALSE; <br>} <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// <br>// <br>// <br>// <br>BOOL InitSoundDevices( BOOL fAllowFormatCancel ) <br>    { <br>inti; <br>DWORDdwThreadID; <br> <br>ZeroMemory(grgEventNotify, sizeof(grgEventNotify)); <br>for( i = 0; i &lt; NUM_EVENTS; i++ ) <br>{ <br>grgEventNotify[i] = CreateEvent(NULL, FALSE, FALSE, NULL); <br>if( NULL == grgEventNotify[i] ) <br>goto ISD_Fail; <br>} <br> <br>ghThread = CreateThread( NULL, 0, ThreadProcessInput, <br> NULL, 0, &amp;dwThreadID ); <br>if( NULL == ghThread ) <br>goto ISD_Fail; <br> <br>return InitSoundData( fAllowFormatCancel, FALSE ); <br> <br>ISD_Fail: <br>    return FALSE; <br>    } <br> <br> <br>BOOL ReOpenSoundDevices( BOOL fAllowFormatCancel ) <br>    { <br>return InitSoundData( fAllowFormatCancel, TRUE ); <br>    } <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// <br>// <br>// <br>// <br>static BOOL IsDSDeviceInList( LPGUID lpguidDevice, PDSDEVICEDESC pdsddList ) <br>    { <br>    PDSDEVICEDESC pdsdd = pdsddList; <br> <br>    while( pdsdd ) <br>{ <br>// This works because operator== is overloaded for GUIDS <br>if( NULL == lpguidDevice ) <br>    { <br>    if( pdsdd-&gt;guDevice == GUID_NULL ) <br>return TRUE; <br>    } <br>else if( pdsdd-&gt;guDevice == *lpguidDevice ) <br>    return TRUE; <br> <br>pdsdd = pdsdd-&gt;pNext; <br>} <br>    return FALSE; <br>    } <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// EnumDSDevices() <br>// <br>//    Enumerates the DirectSound devices with the help of DirectSoundEnumerate <br>// and DSEnumProc.  Adds entries to a global list about each device. <br>// <br>static BOOL EnumDSDevices( void ) <br>    { <br>PFN_DSENUMERATE pfn_DSEnumerate; <br> <br>// Get a pointer to DirectSoundEnumerate() <br>pfn_DSEnumerate = (PFN_DSENUMERATE)GetProcAddress(g_hDSoundLib, "DirectSoundEnumerateA"); <br> <br>if (pfn_DSEnumerate == NULL) <br>{ <br>        MessageBox(ghMainWnd, "DSOUND.DLL does not implement DirectSoundEnumerate()", gszAppName, MB_OK); <br>} <br>else <br>{ <br>(*pfn_DSEnumerate)(DSEnumProc, &amp;gpdsddOutputDevices); <br>} <br> <br>    return TRUE; <br>    } <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// EnumDSCDevices() <br>// <br>//    Enumerates the DirectSoundCapture devices with the help of <br>// DirectSoundCaptureEnumerate and DSEnumProc. <br>// Adds entries to a global list about each device. <br>// <br>static BOOL EnumDSCDevices( void ) <br>    { <br>PFN_DSCENUMERATE pfn_DSCEnumerate; <br> <br>// Get a pointer to DirectSoundEnumerate() <br>pfn_DSCEnumerate = (PFN_DSCENUMERATE)GetProcAddress(g_hDSoundLib, "DirectSoundCaptureEnumerateA"); <br> <br>if (pfn_DSCEnumerate == NULL) <br>{ <br>        MessageBox(ghMainWnd, "DSOUND.DLL does not implement DirectSoundCaptureEnumerate(). The system may not have DirectX 5.0 installed.", gszAppName, MB_OK); <br>} <br>else <br>{ <br>(*pfn_DSCEnumerate)(DSEnumProc, &amp;gpdsddInputDevices); <br>} <br> <br>    return TRUE; <br>    } <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// InitInputDevice() <br>// <br>//    Creates and initializes the input device for the application. <br>// <br>static BOOL InitInputDevice( void ) <br>{ <br>HRESULTdsrval; <br>PFN_DSCCREATEpfn_DSCCreate; <br> <br>// create a DirectSoundCapture object. <br>pfn_DSCCreate = (PFN_DSCCREATE)GetProcAddress(g_hDSoundLib, "DirectSoundCaptureCreate"); <br>if (pfn_DSCCreate == NULL) <br>{ <br>        MessageBox(ghMainWnd, "DSOUND.DLL does not implement DirectSoundCaptureCreate(). The system may not have DirectX 5.0 installed.", gszAppName, MB_OK); <br>goto IID_ExitError; <br>} <br>else <br>{ <br>if (FAILED(dsrval = (*pfn_DSCCreate)(&amp;gpdsddIn-&gt;guDevice, &amp;gpdsc, NULL))) <br>{ <br>DPF( 0, "Couldn't open DirectSoundCapture device (%s)", TranslateDSError(dsrval)); <br>goto IID_ExitError; <br>} <br>} <br>return TRUE; <br> <br>IID_ExitError: <br>return FALSE; <br>} <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// InitPrimarySoundBuffer() <br>// <br>//    Creates and initializes the primary sound buffer for the application. <br>// We need the primary buffer in order to get the 3D listener interface and <br>// also to select output format type. <br>// <br>static BOOL InitPrimarySoundBuffer( void ) <br>    { <br>    HRESULT    dsrval; <br>    DSBUFFERDESC    dsbd; <br>PFN_DSCREATEpfn_DSCreate; <br> <br>    ZeroMemory( &amp;dsbd, sizeof(DSBUFFERDESC)); <br>     <br>    dsbd.dwSize = sizeof(DSBUFFERDESC); <br>    dsbd.dwFlags = DSBCAPS_CTRL3D | DSBCAPS_PRIMARYBUFFER; <br> <br>// Create a directsound object. <br>pfn_DSCreate = (PFN_DSCREATE)GetProcAddress(g_hDSoundLib, "DirectSoundCreate"); <br>if (pfn_DSCreate == NULL) <br>{ <br>MessageBox(ghMainWnd, "DSOUND.DLL does not implement DirectSoundCreate()", gszAppName, MB_OK); <br>goto IPSB_ExitError; <br>} <br>else <br>{ <br>if (FAILED(dsrval = (*pfn_DSCreate)(&amp;gpdsddOut-&gt;guDevice, &amp;gpds, NULL))) <br>{ <br>DPF( 0, "Couldn't open DirectSound device (%s)", TranslateDSError(dsrval)); <br>goto IPSB_ExitError; <br>} <br>} <br> <br>    if( FAILED( dsrval = gpds-&gt;SetCooperativeLevel( ghMainWnd, DSSCL_PRIORITY ))) <br>{ <br>DPF( 0, "Couldn't get PRIORITY cooperative level (%s)", TranslateDSError(dsrval)); <br>goto IPSB_ExitError; <br>} <br> <br>    if( FAILED( dsrval = gpds-&gt;CreateSoundBuffer( &amp;dsbd, &amp;gpdsbPrimary, NULL ))) <br>{ <br>DPF( 0, "Couldn't create primary buffer (%s)", TranslateDSError(dsrval)); <br>goto IPSB_ExitError; <br>} <br> <br>    return TRUE; <br> <br>IPSB_ExitError: <br>    if( NULL != gpdsbPrimary ) <br>{ <br>DPF( 1, "Releasing Primary in InitPrimarySoundBuffer() error cleanup" ); <br>gpdsbPrimary-&gt;Release(); <br>gpdsbPrimary = NULL; <br>} <br>    if( NULL != gpds ) <br>{ <br>DPF( 1, "Releasing DSound object in InitPrimarySoundBuffer() error cleanup" ); <br>gpds-&gt;Release(); <br>gpds= NULL; <br>} <br> <br>    return FALSE; <br>    } <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// DSEnumProc() <br>// <br>//   DirectSoundXXXEnumerate() callback procedure which fills the DSDEVICEDESC list <br>// with data about available devices. <br>// <br>static BOOL CALLBACK DSEnumProc( LPGUID lpguidDevice, LPCSTR lpszDesc, <br>                                LPCSTR lpszDrvName, LPVOID lpContext ) <br>    { <br>    PDSDEVICEDESC   pdsddNew; <br>    PDSDEVICEDESC   *ppdsddList = (PDSDEVICEDESC *)lpContext; <br> <br>    if( !IsDSDeviceInList( lpguidDevice, *ppdsddList )) <br>{ <br>if(( pdsddNew = new DSDEVICEDESC ) == NULL ) <br>    { <br>    return TRUE; <br>    } <br> <br>ZeroMemory( pdsddNew, sizeof(DSDEVICEDESC)); <br> <br>if( NULL != lpguidDevice ) <br>    pdsddNew-&gt;guDevice = *lpguidDevice; <br>else <br>    pdsddNew-&gt;guDevice = GUID_NULL; <br> <br>if(( pdsddNew-&gt;pszDeviceDesc = new char[lstrlen(lpszDesc)+1]) == NULL ) <br>    { <br>    delete pdsddNew; <br>    return TRUE; <br>    } <br>lstrcpy( pdsddNew-&gt;pszDeviceDesc, lpszDesc ); <br> <br>pdsddNew-&gt;pNext = *ppdsddList; <br>*ppdsddList = pdsddNew; <br>} <br> <br>    return TRUE; <br>    } <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// <br>// <br>// <br>// <br>void ClearDSDeviceList( PDSDEVICEDESC *ppdsdd ) <br>    { <br>    PDSDEVICEDESC   pdsddCur, pdsddTemp; <br> <br>    pdsddCur = *ppdsdd; <br> <br>    while( pdsddCur ) <br>{ <br>if( NULL != pdsddCur-&gt;pszDeviceDesc ) <br>    delete[] pdsddCur-&gt;pszDeviceDesc; <br> <br>pdsddTemp = pdsddCur-&gt;pNext; <br>delete pdsddCur; <br>pdsddCur = pdsddTemp; <br>} <br>    *ppdsdd = NULL; <br>    } <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// <br>// <br>// <br>// <br>void FillDeviceCombo( HWND hCombo, PDSDEVICEDESC pdsddDevices ) <br>    { <br>    PDSDEVICEDESC   pdsdd = pdsddDevices; <br>    int    idx; <br> <br>    if( NULL == hCombo ) <br>return; <br> <br>    while( pdsdd ) <br>{ <br>idx = ComboBox_InsertString( hCombo, -1, pdsdd-&gt;pszDeviceDesc ); <br>ComboBox_SetItemData( hCombo, idx, pdsdd ); <br>pdsdd = pdsdd-&gt;pNext; <br>} <br>    if( NULL != pdsddDevices ) <br>ComboBox_SetCurSel( hCombo, 0 ); <br>    } <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// <br>// <br>// <br>// <br>void ScanAvailableDSFormats( void ) <br>    { <br>    WAVEFORMATEX    wfx; <br>    HRESULT    dsrval; <br>    HCURSOR    hCursor; <br>    int    i; <br> <br>    DPF( 3, "Scanning %u DirectSound formats for availability", NUM_FORMATCODES ); <br>    if( NULL == gpds || NULL == gpdsbPrimary ) <br>{ <br>        for( i = 0; i &lt; NUM_FORMATCODES; i++ ) <br>    aOutputFormats[i].fEnabled = FALSE; <br>return; <br>} <br> <br>    // This might take a second or two, so throw up the hourglass <br>    hCursor = GetCursor(); <br>    SetCursor( LoadCursor( NULL, IDC_WAIT )); <br> <br>    ZeroMemory( &amp;wfx, sizeof(wfx)); <br>    wfx.wFormatTag = WAVE_FORMAT_PCM; <br>  <br>    for( i = 0; i &lt; NUM_FORMATCODES; i++ ) <br>{ <br>FormatCodeToWFX( aOutputFormats[i].dwCode, &amp;wfx ); <br> <br>if( FAILED( dsrval = gpdsbPrimary-&gt;SetFormat( &amp;wfx ))) <br>    { <br>    DPF( 5, "Failed with SetFormat() for %u format", aOutputFormats[i].dwCode ); <br>    aOutputFormats[i].fEnabled = FALSE; <br>    } <br>else <br>    { <br>    DPF( 5, "Succeeded with SetFormat() for %u format", aOutputFormats[i].dwCode ); <br>    aOutputFormats[i].fEnabled = TRUE; <br>    } <br>} <br>    SetCursor( hCursor ); <br>    } <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// <br>// <br>// <br>// <br>void ScanAvailableDSCFormats( void ) <br>    { <br>    WAVEFORMATEX    wfx; <br>    HRESULT    dsrval; <br>    HCURSOR    hCursor; <br>    int    i; <br>DSCBUFFERDESCdscbd; <br>LPDIRECTSOUNDCAPTUREBUFFERpdscb; <br> <br>    DPF( 3, "Scanning %u DirectSoundCapture formats for availability", NUM_FORMATCODES ); <br>    if( NULL == gpdsc ) <br>{ <br>        for( i = 0; i &lt; NUM_FORMATCODES; i++ ) <br>    aInputFormats[i].fEnabled = FALSE; <br>return; <br>} <br> <br>    // This might take a second or two, so throw up the hourglass <br>    hCursor = GetCursor(); <br>    SetCursor( LoadCursor( NULL, IDC_WAIT )); <br> <br>    for( i = 0; i &lt; NUM_FORMATCODES; i++ ) <br>aOutputFormats[i].fEnabled = FALSE; <br> <br>    ZeroMemory( &amp;wfx, sizeof(wfx)); <br>    wfx.wFormatTag = WAVE_FORMAT_PCM; <br>  <br>    for( i = 0; i &lt; NUM_FORMATCODES; i++ ) <br>{ <br>FormatCodeToWFX( aInputFormats[i].dwCode, &amp;wfx ); <br> <br>ZeroMemory(&amp;dscbd, sizeof(dscbd)); <br>dscbd.dwSize = sizeof(dscbd); <br>dscbd.dwBufferBytes = wfx.nAvgBytesPerSec; <br>dscbd.lpwfxFormat = &amp;wfx; <br> <br>pdscb = NULL; <br> <br>if ((dsrval = gpdsc-&gt;CreateCaptureBuffer(&amp;dscbd, &amp;pdscb, NULL))) <br>    { <br>    DPF( 5, "Failed with DirectSoundCapture::CreateCaptureBuffer() for %u format", aInputFormats[i].dwCode ); <br>    aInputFormats[i].fEnabled = FALSE; <br>    } <br>else <br>    { <br>    DPF( 5, "Succeeded with DirectSoundCapture::CreateCaptureBuffer() for %u format", aInputFormats[i].dwCode ); <br>    pdscb-&gt;Release(); <br>    aInputFormats[i].fEnabled = TRUE; <br>    } <br>} <br> <br>    SetCursor( hCursor ); <br>    } <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// <br>// <br>// <br>// <br>void CloseDSDevice( void ) <br>    { <br>    if( NULL != gpdsbOutput ) <br>{ <br>gpdsbOutput-&gt;Release(); <br>gpdsbOutput = NULL; <br>} <br>    if( NULL != gpdsbPrimary ) <br>{ <br>gpdsbPrimary-&gt;Release(); <br>gpdsbPrimary = NULL; <br>} <br>    if( NULL != gpds ) <br>{ <br>gpds-&gt;Release(); <br>gpds = NULL; <br>} <br>    } <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// <br>// <br>// <br>// <br>void CloseDSCDevice( BOOL fBufferOnly ) <br>    { <br>if( NULL != gpdscbInput ) <br>{ <br>gpdscbInput-&gt;Release(); <br>gpdscbInput = NULL; <br>} <br>if( (NULL != gpdsc) &amp;&amp; !fBufferOnly ) <br>{ <br>gpdsc-&gt;Release(); <br>gpdsc = NULL; <br>} <br>    } <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// <br>// <br>// <br>// <br>BOOL InitBuffers( void ) <br>    { <br>    HRESULT    dsrval; <br>inti; <br>LPDIRECTSOUNDNOTIFYpdsn; <br> <br>    if( gfBuffersInitialized ) <br>return TRUE; <br>if (NULL == gpdscbInput) <br>return FALSE; <br> <br>    EnterCriticalSection( &amp;gcsBufferData ); <br> <br>ZeroMemory(grgdsbpn, sizeof(grgdsbpn)); <br> <br>for( i = 0; i &lt; NUM_BUFFERS; i++ ) <br>{ <br>grgdsbpn[i].dwOffset = (gcbBufferSize * i) + gcbBufferSize - 1; <br>grgdsbpn[i].hEventNotify = grgEventNotify[i]; <br>} <br>grgdsbpn[i].dwOffset = DSBPN_OFFSETSTOP; <br>grgdsbpn[i].hEventNotify = grgEventNotify[i]; <br> <br>if( FAILED( dsrval = gpdscbInput-&gt;QueryInterface(IID_IDirectSoundNotify, (LPVOID *)&amp;pdsn ) ) ) <br>{ <br>DPF( 0, "Unable to QI for IDirectSoundNotify on input (%s)", TranslateDSError(dsrval)); <br>goto Abort_InitBuffers; <br>} <br>dsrval = pdsn-&gt;SetNotificationPositions(NUM_POSNOTIFS, grgdsbpn); <br>pdsn-&gt;Release(); <br>if( FAILED( dsrval ) ) <br>{ <br>DPF( 0, "Unable to SetNotificationPositions on input (%s)", TranslateDSError(dsrval)); <br>goto Abort_InitBuffers; <br>} <br> <br>ZeroMemory( &amp;gdsbdOutput, sizeof(gdsbdOutput)); <br>    gdsbdOutput.dwSize = sizeof(gdsbdOutput); <br>    gdsbdOutput.dwFlags = DSBCAPS_CTRLVOLUME | DSBCAPS_GLOBALFOCUS; <br>    gdsbdOutput.dwBufferBytes = NUM_BUFFERS * gcbBufferSize / 2; <br>    // We want the format of this secondary to match the format of the input <br>    // data.  This lets us blindly copy the data out and DSound worries about <br>    // matching the bits and channels to our desired primary buffer format. <br>    gdsbdOutput.lpwfxFormat = gpwfxInput; <br> <br>    if( FAILED( dsrval = gpds-&gt;CreateSoundBuffer( &amp;gdsbdOutput, &amp;gpdsbOutput, NULL ))) <br>{ <br>DPF( 0, "Unable to create sound buffer for output (%s)", TranslateDSError(dsrval)); <br>goto Abort_InitBuffers; <br>} <br> <br>    InterlockedExchange( &amp;gfBuffersInitialized, TRUE ); <br>    LeaveCriticalSection( &amp;gcsBufferData ); <br>    return TRUE; <br> <br>Abort_InitBuffers: <br>    // TODO: If there were any buffers put out, we must Reset to get them back <br>    ASSERT( DestroyBuffers()); <br>    LeaveCriticalSection( &amp;gcsBufferData ); <br>    return FALSE; <br>    } <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// <br>// <br>// <br>// <br>BOOL StartBuffers( void ) <br>    { <br>    if( NULL == gpdscbInput || NULL == gpdsbOutput ) <br>return FALSE; <br> <br>    gpdscbInput-&gt;Start( DSCBSTART_LOOPING ); <br>     <br>    // Rewind the output buffer, fill it with silence, and play it <br>    gpdsbOutput-&gt;SetCurrentPosition( 0 ); <br>    WriteSilenceToOutput( 0, gdsbdOutput.dwBufferBytes ); <br>    gpdsbOutput-&gt;Play( 0, 0, DSBPLAY_LOOPING ); <br>    return TRUE; <br>    } <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// <br>// <br>// <br>// <br>BOOL StopBuffers( void ) <br>    { <br>    if( NULL == gpdscbInput || NULL == gpdsbOutput ) <br>return FALSE; <br> <br>    gpdscbInput-&gt;Stop(); <br>    gpdsbOutput-&gt;Stop(); <br> <br>return TRUE; <br>    } <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// <br>// <br>// <br>// <br>BOOL DestroyBuffers( void ) <br>    { <br>ZeroMemory( grgdsbpn, sizeof(grgdsbpn) ); <br>    if( NULL != gpdsbOutput ) <br>{ <br>gpdsbOutput-&gt;Release(); <br>gpdsbOutput = NULL; <br>} <br>    InterlockedExchange( &amp;gfBuffersInitialized, FALSE ); <br>    return TRUE; <br>    } <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// <br>// <br>// <br>// <br>BOOL WriteSilenceToOutput( DWORD dwStart, DWORD cbLength ) <br>    { <br>    PBYTE   pb1, pb2; <br>    DWORD   cb1, cb2; <br> <br>    if(( !dwStart &amp;&amp; !cbLength ) || NULL == gpdsbOutput <br>|| NULL == gdsbdOutput.lpwfxFormat ) <br>return FALSE; <br> <br>    if( SUCCEEDED( gpdsbOutput-&gt;Lock( dwStart, cbLength, (LPVOID*)&amp;pb1, &amp;cb1, (LPVOID*)&amp;pb2, &amp;cb2, 0 ))) <br>{ <br>FillMemory( pb1, cb1, (gdsbdOutput.lpwfxFormat-&gt;wBitsPerSample == 8) ? 128 : 0 ); <br>if( NULL != pb2 &amp;&amp; cb2 ) <br>    FillMemory( pb2, cb2, (gdsbdOutput.lpwfxFormat-&gt;wBitsPerSample == 8) ? 128 : 0 ); <br> <br>gpdsbOutput-&gt;Unlock( pb1, cb1, pb2, cb2 ); <br>return TRUE; <br>} <br> <br>    return FALSE; <br>    } <br> <br> <br>static void ProcessInput( DWORD iEvent ) <br>{ <br>    staticDWORD dwWritePosition = 0xFFFFFFFF; <br>    HRESULTdsrval; <br>PBYTEpb1, pb2; <br>DWORDcb1, cb2; <br>BOOLfRestoredBuffer = FALSE; <br>LPBYTEpbInput1 = NULL; <br>DWORDcbInput1; <br>LPBYTEpbInput2; <br>DWORDcbInput2; <br>DWORDibInputStart; <br>DWORDcbInputEnd; <br> <br>if( NULL == gpdscbInput ) <br>{ <br>return; <br>} <br> <br>EnterCriticalSection( &amp;gcsBufferData ); <br> <br>if( NUM_BUFFERS == iEvent ) <br>{ <br>dwWritePosition = 0xFFFFFFFF; <br>goto WIC_SkipDataProcessing; <br>} <br>else if( iEvent &gt; 0 ) <br>{ <br>ibInputStart = grgdsbpn[iEvent-1].dwOffset+1; <br>} <br>else <br>{ <br>ibInputStart = 0; <br>} <br>cbInputEnd = grgdsbpn[iEvent].dwOffset + 1 - ibInputStart; <br> <br>dsrval = gpdscbInput-&gt;Lock(ibInputStart, cbInputEnd, <br>   (LPVOID *)&amp;pbInput1, &amp;cbInput1, (LPVOID *)&amp;pbInput2, &amp;cbInput2, 0); <br>if( FAILED(dsrval) ) <br>{ <br>DPF( 0, "Couldn't Lock input buffer. (%s)", TranslateDSError(dsrval)); <br>goto WIC_SkipDataProcessing; <br>} <br> <br>if( (NULL != pbInput2) || (0 != cbInput2) ) <br>{ <br>DPF( 0, "Second input buffer pointer is non-NULL"); <br>} <br> <br>if( NULL != gpdsbOutput ) <br>{ <br>DWORD dwStatus; <br>if( FAILED( dsrval = gpdsbOutput-&gt;GetStatus( &amp;dwStatus ))) <br>{ <br>DPF( 0, "Unable to get buffer status. (%s)", TranslateDSError(dsrval)); <br>goto WIC_SkipDataProcessing; <br>} <br>if( dwStatus &amp; DSBSTATUS_BUFFERLOST ) <br>{ <br>if( FAILED( dsrval = gpdsbOutput-&gt;Restore())) <br>{ <br>DPF( 0, "Couldn't Restore output buffer. (%s)", TranslateDSError(dsrval)); <br>goto WIC_SkipDataProcessing; <br>} <br>dwWritePosition = 0; <br>fRestoredBuffer = TRUE; <br>} <br>else <br>{ <br>if( dwWritePosition == 0xFFFFFFFF ) <br>{ <br>DWORDdwPlay, dwWrite; <br> <br>gpdsbOutput-&gt;GetCurrentPosition( &amp;dwPlay, &amp;dwWrite ); <br> <br>// Need to add some extra to make sure we're ahead <br>// of the write cursor <br>dwWritePosition = dwWrite + (2*gcbBufferSize); <br>while( dwWritePosition &gt;= gdsbdOutput.dwBufferBytes ) <br>dwWritePosition -= gdsbdOutput.dwBufferBytes; <br>} <br>} <br> <br>if( SUCCEEDED( gpdsbOutput-&gt;Lock( dwWritePosition, <br>cbInput1, <br>(LPVOID *)&amp;pb1, &amp;cb1, (LPVOID *)&amp;pb2, &amp;cb2, 0 ))) <br>{ <br>if( NULL != pb1 &amp;&amp; NULL != gpFilter ) <br>{ <br>gpFilter-&gt;Transform( pbInput1, cb1, pb1 ); <br>} <br>if( cb2 &amp;&amp; NULL != pb2 &amp;&amp; NULL != gpFilter ) <br>{ <br>gpFilter-&gt;Transform( pbInput1 + cb1, <br>cbInput1 - cb1, pb2 ); <br>} <br>gpdsbOutput-&gt;Unlock( pb1, cb1, pb2, <br>cbInput1 - cb1 ); <br>dwWritePosition += cbInput1; <br>while( dwWritePosition &gt;= gdsbdOutput.dwBufferBytes ) <br>dwWritePosition -= gdsbdOutput.dwBufferBytes; <br>} <br>if( fRestoredBuffer ) <br>{ <br>gpdsbOutput-&gt;SetCurrentPosition( 0 ); <br>if( FAILED( dsrval = gpdsbOutput-&gt;Play( 0, 0, DSBPLAY_LOOPING ))) <br>DPF( 0, "Unable to restart restored buffer. (%s)", TranslateDSError(dsrval)); <br>dwWritePosition = 0xFFFFFFFF; <br>} <br>} <br>WIC_SkipDataProcessing: <br>if( NULL != pbInput1 ) <br>gpdscbInput-&gt;Unlock(pbInput1, cbInput1, pbInput2, cbInput2); <br>LeaveCriticalSection( &amp;gcsBufferData ); <br>} <br> <br>DWORD WINAPI ThreadProcessInput( LPVOID ) <br>{ <br>DWORDdwResult; <br> <br>while( TRUE ) <br>{ <br>dwResult = WaitForMultipleObjects( NUM_EVENTS, grgEventNotify, <br>   FALSE, INFINITE ); <br> <br>// Terminate processing? <br>if( (WAIT_OBJECT_0 + iEventTerminate) == dwResult ) <br>{ <br>break; <br>} <br> <br>if( (WAIT_OBJECT_0 &lt;= dwResult) &amp;&amp; (dwResult &lt;= (WAIT_OBJECT_0 + iEventReset)) ) <br>{ <br>ProcessInput( dwResult - WAIT_OBJECT_0 ); <br>} <br>} <br> <br>return 0; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
