<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FDFILTER.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3170"></a>FDFILTER.CPP</h2>
<pre><code>////////////////////////////////////////////////////////////////////////////// <br>// <br>// Copyright (C) 1996-1997 Microsoft Corporation. All Rights Reserved. <br>// <br>// File:FDFILTER.CPP <br>// Contents:General routines related to the Full-Duplex Filter Sample <br>// <br>// Description:This file includes the window procedures and initialization <br>//and destruction code. <br>// <br> <br>#define __DEFINE_GLOBAL_VARIABLES__ <br>#include "fdfilter.h" <br>#undef __DEFINE_GLOBAL_VARIABLES__ <br>#include "fdaudio.h" <br>#include "filter.h" <br> <br>#include &lt;commctrl.h&gt; <br> <br>static BOOL InitInstance( HINSTANCE, HINSTANCE, LPSTR, int ); <br> <br>static void DestroyInstance( void ); <br> <br>HINSTANCE g_hDSoundLib;// module handle to dsound.dll. <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// DestroyInstance() <br>// <br>//    Does all of the cleanup for an instance of the application. <br>// <br>static void DestroyInstance( void ) <br>    { <br>DestroyBuffers(); <br>CloseDSCDevice(FALSE); <br>CloseDSDevice(); <br>    if( NULL != gpwfxOutput ) <br>{ <br>delete gpwfxOutput; <br>gpwfxOutput = NULL; <br>} <br>    if( NULL != gpFilter ) <br>{ <br>delete gpFilter; <br>gpFilter = NULL; <br>} <br>    if( NULL != gpdsddOutputDevices ) <br>{ <br>ClearDSDeviceList( &amp;gpdsddOutputDevices ); <br>} <br> <br>if( NULL != gpdsddInputDevices ) <br>{ <br>ClearDSDeviceList( &amp;gpdsddInputDevices ); <br>} <br> <br>// wait for the thread to quit <br>if( NULL != ghThread ) <br>{ <br>// Set the Terminate Event so the thread will quit <br>SetEvent( grgEventNotify[iEventTerminate] ); <br> <br>WaitForSingleObject( ghThread, INFINITE ); <br>CloseHandle( ghThread ); <br>} <br> <br>for(int i = 0; i &lt; NUM_EVENTS; i++ ) <br>{ <br>if( NULL != grgEventNotify[i] ) <br>CloseHandle( grgEventNotify[i] ); <br>} <br>    // Get rid of the critical section object <br>    DeleteCriticalSection( &amp;gcsBufferData ); <br>    } <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// InitInstance() <br>// <br>//    This function is responsible for all initialization that must occur <br>// when a new instance of our application is started. <br>// <br>static BOOL InitInstance( HINSTANCE hInstance, LPSTR lpszCommandLine, int cmdShow ) <br>    { <br>    // Used to protect buffer data from multi-threaded access <br>    InitializeCriticalSection( &amp;gcsBufferData ); <br> <br>    if(( ghMainWnd = CreateDialog( ghInst, MAKEINTRESOURCE(IDD_MAIN), NULL, (DLGPROC)MainDlgProc )) == NULL ) <br>{ <br>DPF( 0, "Call to CreateDialog() failed." ); <br>DestroyInstance(); <br>return FALSE; <br>} <br> <br>    HMENU hSysMenu = GetSystemMenu( ghMainWnd, FALSE ); <br>    EnableMenuItem( hSysMenu, SC_MAXIMIZE, MF_BYCOMMAND | MF_GRAYED ); <br>    EnableMenuItem( hSysMenu, SC_SIZE, MF_BYCOMMAND | MF_GRAYED ); <br> <br>    /* Continue doing other initialization stuff */ <br>    if( !InitSoundDevices( TRUE )) <br>{ <br>DPF( 0, "Call to InitSoundDevices() failed." ); <br>goto II_ExitError; <br>} <br> <br>    ShowWindow( ghMainWnd, cmdShow ); <br>    UpdateWindow( ghMainWnd ); <br> <br>    return TRUE;    // TRUE indicates success <br> <br>II_ExitError: <br>    if( NULL != ghMainWnd ) <br>{ <br>DestroyWindow( ghMainWnd ); <br>ghMainWnd = NULL; <br>} <br> <br>    return FALSE;   // FALSE indicates failure on initialization <br>    }// InitInstance() <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// WinMain() <br>// <br>//   Main entry point for this program's execution.  Everything starts here. <br>// <br>int PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, <br>LPSTR lpszCmdLine, int cmdShow) <br>    { <br>    MSG   msg; <br> <br>    DbgInitialize( TRUE ); <br> <br>    InitCommonControls(); <br> <br>    // Save instance handle <br>    ghInst = hInstance; <br> <br>// Load dsound.dll <br>g_hDSoundLib = LoadLibrary("DSOUND.DLL"); <br>if (g_hDSoundLib == NULL) <br>{ <br>MessageBox(ghMainWnd, "Could not load DSOUND.DLL", gszAppName, MB_OK); <br>return 0; <br>} <br> <br>    if (!InitInstance(hInstance, lpszCmdLine, cmdShow)) <br>{ <br>FreeLibrary(g_hDSoundLib); <br>return 0; <br>} <br> <br>    /* Polling messages from event queue */ <br>    while (GetMessage((LPMSG)&amp;msg, NULL, 0, 0)) <br>{ <br>// Only Translate and Dispatch the message if it's not going <br>// to one of our many modeless dialog windows <br>if( !IsDialogMessage( ghMainWnd, &amp;msg )) <br>    { <br>    TranslateMessage((LPMSG)&amp;msg); <br>    DispatchMessage((LPMSG)&amp;msg); <br>    } <br>} <br> <br>FreeLibrary(g_hDSoundLib); <br>    return (int)msg.wParam; <br>    }// WinMain() <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// MainDlgProc() <br>// <br>//    This the equivalent of a main window procedure, except our main window <br>// is really a dialog box. <br>// <br>BOOL CALLBACK MainDlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam ) <br>    { <br>    static HWNDhInputDeviceText, hInputFormatText, hEnableCheck, hFilterCombo; <br>    static HWNDhOutputDeviceText, hPrimaryFormatText, hSecondaryFormatText; <br> <br>    DWORD   dwCode; <br>    int    ndx; <br>     <br>    switch( message ) <br>{ <br>case WM_INITDIALOG: <br>    hInputDeviceText = GetDlgItem( hDlg, IDC_MAIN_INPUTDEVICE_TEXT ); <br>    hInputFormatText = GetDlgItem( hDlg, IDC_MAIN_INPUTFORMAT_TEXT ); <br>    hOutputDeviceText = GetDlgItem( hDlg, IDC_MAIN_OUTPUTDEVICE_TEXT ); <br>    hPrimaryFormatText = GetDlgItem( hDlg, IDC_MAIN_PRIMARYFORMAT_TEXT ); <br>    hSecondaryFormatText = GetDlgItem( hDlg, IDC_MAIN_SECONDARYFORMAT_TEXT ); <br>    hFilterCombo = GetDlgItem( hDlg, IDC_MAIN_FILTER_COMBO ); <br>    hEnableCheck = GetDlgItem( hDlg, IDC_MAIN_ENABLEFILTER_CHECK ); <br> <br>    ndx = ComboBox_AddString( hFilterCombo, "None (pass-through)" ); <br>    ComboBox_SetItemData( hFilterCombo, ndx, 0 ); <br> <br>    ComboBox_SetCurSel( hFilterCombo, ndx ); <br> <br>    ndx = ComboBox_AddString( hFilterCombo, "Gargle" ); <br>    ComboBox_SetItemData( hFilterCombo, ndx, 1 ); <br> <br> <br>    EnterCriticalSection( &amp;gcsBufferData ); <br>    if( NULL != gpFilter ) <br>delete gpFilter; <br>    gpFilter = new CFilter; <br>    LeaveCriticalSection( &amp;gcsBufferData ); <br>    break; <br>     <br>case WM_PAINT: <br>    { <br>    PAINTSTRUCTps; <br>    charszFormat[64]; <br> <br>    BeginPaint( hDlg, &amp;ps ); <br>    if( NULL != gpdsddIn ) <br>Static_SetText( hInputDeviceText, gpdsddIn-&gt;pszDeviceDesc ); <br>    if( NULL != gpdsddOut ) <br>Static_SetText( hOutputDeviceText, gpdsddOut-&gt;pszDeviceDesc ); <br> <br>    FormatCodeToText( gdwInputFormat, szFormat, sizeof(szFormat)); <br>    Static_SetText( hInputFormatText, szFormat ); <br> <br>    FormatCodeToText( gdwOutputFormat, szFormat, sizeof(szFormat)); <br>    Static_SetText( hPrimaryFormatText, szFormat ); <br> <br>    FormatCodeToText( gdwInputFormat, szFormat, sizeof(szFormat)); <br>    Static_SetText( hSecondaryFormatText, szFormat ); <br> <br>    EndPaint( hDlg, &amp;ps ); <br>    } <br>    break; <br> <br>case WM_COMMAND: <br>    switch( LOWORD(wParam)) <br>{ <br>case IDC_MAIN_FILTER_COMBO: <br>    if( HIWORD( wParam ) == CBN_SELCHANGE ) <br>{ <br>if(( ndx = ComboBox_GetCurSel( hFilterCombo )) == -1 ) <br>    break; <br>dwCode = ComboBox_GetItemData( hFilterCombo, ndx ); <br>if( 0 == dwCode ) <br>    { <br>    EnterCriticalSection( &amp;gcsBufferData ); <br>    if( NULL != gpFilter ) <br>delete gpFilter; <br>    gpFilter = new CFilter; <br>    LeaveCriticalSection( &amp;gcsBufferData ); <br>    } <br>if( 1 == dwCode ) <br>    { <br>    EnterCriticalSection( &amp;gcsBufferData ); <br>    if( NULL != gpFilter ) <br>delete gpFilter; <br>    gpFilter = (CFilter *)new CGargle( gpwfxInput-&gt;nSamplesPerSec, <br>gpwfxInput-&gt;nChannels, <br>gpwfxInput-&gt;wBitsPerSample / 8 ); <br>    LeaveCriticalSection( &amp;gcsBufferData ); <br>    } <br>} <br>    break; <br> <br>case IDC_MAIN_ENABLEFILTER_CHECK: <br>if (NULL == gpdscbInput) <br>break; <br>    if( Button_GetCheck( hEnableCheck )) <br>{ <br>// Put our hands over our eyes and hold our breaths, <br>// here comes the data! <br>if( !gfBuffersInitialized ) <br>    InitBuffers(); <br>StartBuffers(); <br>} <br>    else <br>{ <br>StopBuffers(); <br>} <br>    break; <br> <br>case ID_SETTINGS_DEVICES: <br>    if( FAILED( ReOpenSoundDevices( FALSE ))) <br>break; <br> <br>    Button_SetCheck( hEnableCheck, FALSE ); <br> <br>    EnterCriticalSection( &amp;gcsBufferData ); <br>    if( gpFilter ) <br>gpFilter-&gt;SetFormat( gpwfxInput ); <br>    LeaveCriticalSection( &amp;gcsBufferData ); <br>    InvalidateRect( hDlg, NULL, FALSE ); <br>    UpdateWindow( hDlg ); <br>    break; <br> <br>case ID_SETTINGS_FORMATS: <br>    if( Button_GetCheck( hEnableCheck )) <br>{ <br>Button_SetCheck( hEnableCheck, FALSE ); <br>StopBuffers(); <br>} <br>CloseDSCDevice(TRUE); <br>    DestroyBuffers(); <br> <br>DialogBoxParam( ghInst, MAKEINTRESOURCE(IDD_FORMATS), <br>    ghMainWnd, (DLGPROC)SelectFormatsDlgProc, 0L ); <br>    InvalidateRect( hDlg, NULL, FALSE ); <br>    UpdateWindow( hDlg ); <br> <br>    EnterCriticalSection( &amp;gcsBufferData ); <br>    if( gpFilter ) <br>gpFilter-&gt;SetFormat( gpwfxInput ); <br>    LeaveCriticalSection( &amp;gcsBufferData ); <br>    break; <br> <br>case ID_HELP_ABOUT: <br>    DialogBox( ghInst, MAKEINTRESOURCE(IDD_ABOUT), <br>    ghMainWnd, (DLGPROC)AboutDlgProc ); <br>    break; <br> <br>case ID_FILE_EXIT: <br>case IDCANCEL: <br>    // Be sure to stop the buffers when we're done <br>    StopBuffers(); <br>    DestroyWindow( hDlg ); <br>    break; <br>     <br>default: <br>    return FALSE; <br>} <br>    break; <br> <br>case WM_DESTROY: <br>    DestroyInstance(); <br>    PostQuitMessage(0); <br>    break; <br> <br>default: <br>    return FALSE; <br>} <br> <br>    return TRUE; <br>    } <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// AboutDlgProc() <br>// <br>//    Small dialog procedure for the About Box. <br>// <br>BOOL CALLBACK AboutDlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam ) <br>    { <br>    if( message == WM_COMMAND &amp;&amp; LOWORD(wParam) == IDOK ) <br>{ <br>EndDialog( hDlg, FALSE ); <br>return TRUE; <br>} <br>    else <br>return FALSE; <br>    } <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// CancelWarningDlgProc() <br>// <br>//    Small dialog procedure for the Formats DLG's cancel warning box. <br>// <br>BOOL CALLBACK CancelWarningDlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam ) <br>    { <br>    if( message == WM_COMMAND &amp;&amp; LOWORD(wParam) == IDOK ) <br>{ <br>EndDialog( hDlg, TRUE ); <br>return TRUE; <br>} <br>    else if( message == WM_COMMAND &amp;&amp; LOWORD(wParam) == IDCANCEL ) <br>{ <br>EndDialog( hDlg, FALSE ); <br>return TRUE; <br>} <br>    else <br>return FALSE; <br>    } <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// FormatCodeToText() <br>// <br>//    This function reads format codes and puts out a text string for them. <br>// It does not check for invalid codes.  FALSE return means the buffer was <br>// invalid in some way, TRUE means success. <br>// <br>BOOL FormatCodeToText( DWORD dwFormat, LPSTR lpszBuf, int nBufSize ) <br>    { <br>    DWORD   dwFreq; <br> <br>    // The longest string we'll ever put in is 21 characters (including NULL) <br>    if( NULL == lpszBuf || nBufSize &lt; 21 ) <br>return FALSE; <br> <br>    // Extract the sample rate <br>    dwFreq = FC_GETFREQCODE(dwFormat); <br>    dwFreq = ( dwFreq == 8 ? 8000 : (dwFreq / 11) * 11025); <br> <br>    wsprintf( lpszBuf, "%u Hz, %u-bit %s", dwFreq, FC_GETBITS(dwFormat), <br>FC_GETCHANNELS(dwFormat) == 1 ? "Mono" : "Stereo" ); <br> <br>    return TRUE; <br>    } <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// FormatCodeToWFX() <br>// <br>//    This function reads format codes and fills most of the fields of a <br>// WAVEFORMATEX structure based on the values read.  It does not fill the <br>// wFormatTag or cbSize members. <br>// <br>BOOL FormatCodeToWFX( DWORD dwFormat, PWAVEFORMATEX pwfx ) <br>    { <br>    DWORD   dwFreq; <br> <br>    if( NULL == pwfx ) <br>return FALSE; <br> <br>    // Extract the sample rate <br>    dwFreq = FC_GETFREQCODE(dwFormat); <br>    pwfx-&gt;nSamplesPerSec = ( dwFreq == 8 ? 8000 : (dwFreq / 11) * 11025); <br> <br>    pwfx-&gt;wBitsPerSample = (WORD)FC_GETBITS(dwFormat); <br>    pwfx-&gt;nChannels = (WORD)FC_GETCHANNELS(dwFormat); <br> <br>    // The nBlockAlign calculation below only works for whole-byte samples <br>    ASSERT( pwfx-&gt;wBitsPerSample % 8 == 0 ); <br> <br>    pwfx-&gt;nBlockAlign = pwfx-&gt;nChannels * (pwfx-&gt;wBitsPerSample / 8); <br>    pwfx-&gt;nAvgBytesPerSec = pwfx-&gt;nBlockAlign * pwfx-&gt;nSamplesPerSec; <br> <br>    return TRUE; <br>    } <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// DisableFormatCode() <br>// <br>//    Disables the given format code <br>// <br>void DisableFormatCode( PFORMATDATA pfd, DWORD dwCode ) <br>    { <br>    inti; <br> <br>    for( i = 0; i &lt; NUM_FORMATCODES; i++ ) <br>{ <br>if( pfd[i].dwCode == dwCode ) <br>    { <br>    pfd[i].fEnabled = FALSE; <br>    break; <br>    } <br>} <br>    } <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// FillFormatListBox() <br>// <br>//    This little helper function takes an array FORMATDATA structures and <br>// fills the given ListBox with text/data entries that represent all the <br>// formats. <br>// <br>void FillFormatListBox( PFORMATDATA pfd, HWND hList ) <br>    { <br>    char    szFormat[64]; <br> <br>    for( int i = 0; i &lt; NUM_FORMATCODES; i++ ) <br>{ <br>if( pfd[i].fEnabled ) <br>    { <br>    FormatCodeToText( pfd[i].dwCode, szFormat, sizeof(szFormat)); <br>    ListBox_SetItemData( hList, ListBox_AddString( hList, szFormat), <br>    pfd[i].dwCode ); <br>    } <br>} <br>    } <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// SelectDevicesDlgProc() <br>// <br>//    Procedure for the dialog which queries the user for device selection. <br>// <br>BOOL CALLBACK SelectDevicesDlgProc( HWND hDlg, UINT message, <br>    WPARAM wParam, LPARAM lParam ) <br>    { <br>    static HWNDhDirectSoundCaptureCombo, hDirectSoundCombo; <br> <br>    switch( message ) <br>{ <br>case WM_INITDIALOG: <br>    hDirectSoundCaptureCombo = GetDlgItem( hDlg, IDC_DEVICES_DIRECTSOUNDCAPTURE_COMBO ); <br>    hDirectSoundCombo = GetDlgItem( hDlg, IDC_DEVICES_DIRECTSOUND_COMBO ); <br> <br>    FillDeviceCombo( hDirectSoundCaptureCombo, gpdsddInputDevices ); <br>    FillDeviceCombo( hDirectSoundCombo, gpdsddOutputDevices ); <br>    break; <br> <br>case WM_COMMAND: <br>    switch( LOWORD(wParam)) <br>{ <br>case IDOK: <br>    gpdsddIn = (PDSDEVICEDESC)ComboBox_GetItemData( hDirectSoundCaptureCombo, <br>ComboBox_GetCurSel(hDirectSoundCaptureCombo)); <br>    gpdsddOut = (PDSDEVICEDESC)ComboBox_GetItemData( hDirectSoundCombo, <br>ComboBox_GetCurSel(hDirectSoundCombo)); <br>    EndDialog( hDlg, TRUE ); <br>    break; <br>case IDCANCEL: <br>    EndDialog( hDlg, FALSE ); <br>    break; <br>default: <br>    return FALSE; <br>} <br>    break; <br> <br>default: <br>    return FALSE; <br>} <br>    return TRUE; <br>    } <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// SelectFormatsDlgProc() <br>// <br>//   Procedure the format selection dialog. <br>// <br>BOOL CALLBACK SelectFormatsDlgProc( HWND hDlg, UINT message, <br>    WPARAM wParam, LPARAM lParam ) <br>    { <br>    static HWNDhOutputList, hInputList, hOK; <br>    static BOOLfAllowFormatCancel = FALSE; <br>    HRESULTdsrval; <br>    DWORDdwOutFormat, dwInFormat; <br>    intndx; <br> <br>    switch( message ) <br>{ <br>case WM_INITDIALOG: <br>    hOutputList = GetDlgItem( hDlg, IDC_FORMATS_OUTPUT_LISTBOX ); <br>    hInputList = GetDlgItem( hDlg, IDC_FORMATS_INPUT_LISTBOX ); <br>    hOK = GetDlgItem( hDlg, IDOK ); <br> <br>    if( NULL == gpds || NULL == gpdsbPrimary || NULL == gpdsc ) <br>{ <br>EndDialog( hDlg, FALSE ); <br>return FALSE; <br>} <br>    ScanAvailableDSFormats(); <br>    FillFormatListBox( aOutputFormats, hOutputList ); <br>    if( !ListBox_GetCount( hOutputList )) <br>{ <br>MessageBox( ghMainWnd, "Warning: no output formats available", <br>gszAppName, MB_OK ); <br>EndDialog( hDlg, FALSE ); <br>return FALSE; <br>} <br>    // lParam is a BOOL flag, which is TRUE if cancel is "allowed". If <br>    // the app is running and the devices are selected, the user clearly <br>    // must select a set of formats or else end the application. <br>    fAllowFormatCancel = (BOOL)lParam; <br> <br>    break; <br> <br>case WM_COMMAND: <br>    switch( LOWORD(wParam)) <br>{ <br>case IDC_FORMATS_INPUT_LISTBOX: <br>    if( ListBox_GetCurSel( hOutputList ) != -1 &amp;&amp; <br>    ListBox_GetCurSel( hInputList ) != -1 ) <br>Button_Enable( hOK, TRUE ); <br>    else <br>Button_Enable( hOK, FALSE ); <br>    break; <br> <br>case IDC_FORMATS_OUTPUT_LISTBOX: <br>    if( HIWORD(wParam) == LBN_SELCHANGE ) <br>{ <br>dwOutFormat = ListBox_GetItemData( hOutputList, <br>    ListBox_GetCurSel( hOutputList )); <br>FormatCodeToWFX( dwOutFormat, gpwfxOutput ); <br>DPF( 3, "Formats DLG: Setting gpwfxOutput" ); <br>DPWFX( 3, gpwfxOutput ); <br>if( FAILED( dsrval = gpdsbPrimary-&gt;SetFormat( gpwfxOutput ))) <br>    { <br>    DPF( 1, "Formats DLG: Failed to set DSound primary to %lu (%s)", <br>dwOutFormat, TranslateDSError(dsrval)); <br>    FormatCodeToWFX( gdwOutputFormat, gpwfxOutput ); <br>    DPF( 1, "Formats DLG: Attempting to reset gpwfxOutput" ); <br>    DPWFX( 1, gpwfxOutput ); <br>    if( FAILED( dsrval = gpdsbPrimary-&gt;SetFormat( gpwfxOutput ))) <br>{ <br>DPF( 0, "Formats DLG: Failed to set OLD format (%lu) on primary (%s)", <br>    gdwOutputFormat, gpwfxOutput ); <br>// TODO: Finish this handler <br>} <br>    ndx = ListBox_FindItemData( hOutputList, -1, gdwOutputFormat ); <br>    ListBox_SetCurSel( hOutputList, ndx ); <br>    // TODO: Find the item corresponding to the old format <br>    //       and select it back? (without re-entering this code) <br>    } <br>else <br>    { <br>    gdwOutputFormat = dwOutFormat; <br> <br>    ScanAvailableDSCFormats(); <br>    ListBox_ResetContent( hInputList ); <br>    FillFormatListBox( aInputFormats, hInputList ); <br>    } <br>Button_Enable( hOK, FALSE ); <br>} <br>    break; <br> <br>case IDOK: <br>    ndx = ListBox_GetCurSel( hOutputList ); <br>    // OK button should be disabled unless there's a selection <br>    // in both listboxes <br>    ASSERT( ndx != -1 ); <br> <br>    dwOutFormat = ListBox_GetItemData( hOutputList, ndx ); <br>    FormatCodeToWFX( dwOutFormat, gpwfxOutput ); <br>    // We shouldn't get to this dialog if there's no output <br>    ASSERT( NULL != gpds &amp;&amp; NULL != gpdsbPrimary ); <br>    if(( dsrval = gpdsbPrimary-&gt;SetFormat( gpwfxOutput ))) <br>{ <br>DPF( 0, "Can't set format %lu (%s)", <br>dwOutFormat, TranslateDSError(dsrval)); <br>goto Abort_OK; <br>} <br>    else <br>{ <br>gdwOutputFormat = dwOutFormat; <br>} <br> <br>    ndx = ListBox_GetCurSel( hInputList ); <br>    // OK button should be disabled unless there's a selection <br>    // in both listboxes <br>    ASSERT( ndx != -1 ); <br> <br>    dwInFormat = ListBox_GetItemData( hInputList, ndx ); <br>    FormatCodeToWFX( dwInFormat, gpwfxInput ); <br> <br>{ <br>DSCBUFFERDESCdscbd = {0}; <br> <br>gcbBufferSize = max( 4096, gpwfxInput-&gt;nAvgBytesPerSec / 8 ); <br>gcbBufferSize -= gcbBufferSize % gpwfxInput-&gt;nBlockAlign; <br>DPF( 1, "Set input buffer size to %lu bytes", gcbBufferSize ); <br> <br>dscbd.dwSize = sizeof(dscbd); <br>dscbd.dwBufferBytes = gcbBufferSize * NUM_BUFFERS; <br>dscbd.lpwfxFormat = gpwfxInput; <br> <br>if ((dsrval = gpdsc-&gt;CreateCaptureBuffer(&amp;dscbd, &amp;gpdscbInput, NULL))) <br>{ <br>DPF( 0, "Unable to open selected input device! format = %lu, dsrval = %lu", dwInFormat, dsrval ); <br>goto Abort_OK; <br>} <br>else <br>{ <br>gdwInputFormat = dwInFormat; <br>} <br>} <br> <br>    EndDialog( hDlg, TRUE ); <br>    Abort_OK: <br>    break; <br>case IDCANCEL: <br>    if( fAllowFormatCancel ) <br>EndDialog( hDlg, FALSE ); <br>    else <br>{ <br>if( !DialogBox( ghInst, <br>MAKEINTRESOURCE(IDD_CANCELWARNING), <br>ghMainWnd, (DLGPROC)CancelWarningDlgProc )) <br>    { <br>    EndDialog( hDlg, FALSE ); <br>    PostMessage( ghMainWnd, WM_DESTROY, 0, 0 ); <br>    return FALSE; <br>    } <br>} <br>    break; <br> <br>default: <br>    return FALSE; <br>} <br>    break; <br> <br>default: <br>    return FALSE; <br>} <br>    return TRUE; <br>    } <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
