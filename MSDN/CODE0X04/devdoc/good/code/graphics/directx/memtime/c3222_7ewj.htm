<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MEMTIME.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3223"></a>MEMTIME.CPP</h2>
<pre><code>//--------------------------------------------------------------------------; <br>// <br>//  File: memtime.cpp <br>// <br>//  Description: <br>//      This code times various things about system memory and video <br>//      memory. It is intended to show the advantages and disadvantages <br>//      of different drawing methoids. <br>//      Please refer to the documented for a more detailed discriptions of <br>//      what is going on. <br>// <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//--------------------------------------------------------------------------- <br>// <br>//  Copyright (c) 1994 - 1997 Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------- <br> <br>#include&lt;windows.h&gt; <br>#include&lt;windowsx.h&gt; <br>#include&lt;commdlg.h&gt; <br>#include &lt;ddraw.h&gt; <br> <br>#include"memtime.h" <br> <br>/*----------------------------------------------------------------------------*\ <br>|                                                                                                                                                          | <br>|   g l o b a l   v a r i a b l e s                                                                                    | <br>|                                                                                                                                                          | <br>\*----------------------------------------------------------------------------*/ <br>static  char    szAppName[]="Direct Draw video/system memory timing tests"; <br> <br>static HINSTANCE    hInstApp; <br>static HWND         hwndApp; <br>static HACCEL       hAccelApp; <br>static HPALETTE     hpalApp; <br> <br>static DWORD ScreenHeight, ScreenWidth; <br>static PCHAR pSource, pDest; <br> <br>static LPDIRECTDRAW pDirectDrawObj; <br>static LPDIRECTDRAWSURFACE pOnScreenBuf; <br>static LPDIRECTDRAWSURFACE pOffScreenBuf; <br>static LPDIRECTDRAWSURFACE pSysMemBuf; <br> <br>static ULONG ModeXFrameCount; <br>static ULONG ModeYFrameCount; <br>static ULONG StretchFrameCount; <br> <br>/*---------------------------------------------------------------------------- <br> <br>Timers <br> <br>*/ <br> <br>extern "C" MemFunc DwordMemCopy_Pitch; <br>extern "C" MemFunc ByteMemCopy_Pitch; <br> <br>extern "C" MemFunc DwordMemFill_Pitch; <br>extern "C" MemFunc ByteMemFill_Pitch; <br> <br>extern "C" MemFunc VertMemSto_Pitch; <br> <br> <br>TIMING_RESULT SystemTests[]= <br>{ <br>    {0, DwordMemCopy_Pitch, "System to System dword copy"}, <br>    {0, ByteMemCopy_Pitch, "System to System byte copy"}, <br> <br>    {0, DwordMemFill_Pitch, "System dword Fill"}, <br>    {0, ByteMemFill_Pitch, "System byte Fill"}, <br> <br>    {0, VertMemSto_Pitch, "System vertical byte fill"} <br>}; <br> <br> <br>TIMING_RESULT VideoTests[]= <br>{ <br>    {0, DwordMemCopy_Pitch, "System to Video dword Copy"}, <br>    {0, ByteMemCopy_Pitch, "System to Video byte Copy"}, <br> <br>    {0, DwordMemFill_Pitch, "Video dword Fill"}, <br>    {0, ByteMemFill_Pitch, "Video byte Fill"}, <br> <br>    {0, VertMemSto_Pitch, "Video vertical byte fill"} <br>}; <br> <br> <br> <br> <br>/*---------------------------------------------------------------------------- <br> <br>defines <br> <br>*/ <br> <br>#define NUMBER_OF(aa) (sizeof(aa)/sizeof((aa)[0])) <br>         <br> <br>/*----------------------------------------------------------------------------*\ <br>| <br>|   f u n c t i o n   d e f i n i t i o n s <br>| <br>\*----------------------------------------------------------------------------*/ <br> <br>LRESULT CALLBACK AppWndProc(HWND hwnd,UINT msg,WPARAM wParam,LPARAM lParam); <br>int  ErrMsg (LPSTR sz,...); <br>LONG AppCommand (HWND hwnd,UINT msg,WPARAM wParam,LPARAM lParam); <br>void PrintTimingResults( void ); <br> <br>void AppExit(void); <br>BOOL AppIdle(void); <br>BOOL DirectDrawInit(); <br>VOID DoSystemTest( PTIMING_RESULT pTimeObject ); <br>VOID DoVideoTests( PTIMING_RESULT pTimeObject ); <br>ULONG GetFPS( int width, int height ); <br>ULONG GetStretchFPS( int width, int height ); <br> <br>/*----------------------------------------------------------------------------*\ <br>|   AppAbout( hDlg, uiMessage, wParam, lParam )                              <br>| <br>|   Description:                                                             <br>|       This function handles messages belonging to the "About" dialog box. <br>|       The only message that it looks for is WM_COMMAND, indicating the use <br>|       has pressed the "OK" button.  When this happens, it takes down <br>|       the dialog box.                                                <br>|                                                                              <br>|   Arguments:                                                             <br>|       hDlg        window handle of about dialog window   <br>|       uiMessage   message number                         <br>|       wParam      message-dependent                      <br>|       lParam      message-dependent                      <br>|                                                                              <br>|   Returns:                                                               <br>|       TRUE if message has been processed, else FALSE                 <br>|                                                                              <br>\*----------------------------------------------------------------------------*/ <br>BOOL CALLBACK <br>AppAbout( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam ) <br>{ <br>    switch (msg) { <br>        case WM_COMMAND: <br>            if (LOWORD(wParam) == IDOK) { <br>                EndDialog(hwnd,TRUE); <br>            } <br>            break; <br>        case WM_INITDIALOG: <br>            return TRUE; <br>    } <br>    return FALSE; <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>|   AppInit( hInst, hPrev)                                                   <br>| <br>|   Description:                                                             <br>|       This is called when the application is first loaded into         <br>|       memory.  It performs all initialization that doesn't need to be done <br>|       once per instance.                                               <br>|                                                                                <br>|   Arguments:                                                               <br>|       hInstance               instance handle of current instance      <br>|       hPrev                   instance handle of previous instance     <br>|                                                                                <br>|   Returns:                                                                 <br>|       TRUE if successful, FALSE if not                                 <br>|                                                                                <br>\*----------------------------------------------------------------------------*/ <br>BOOL <br>AppInit(HINSTANCE hInst, HINSTANCE hPrev, int sw, LPSTR szCmdLine ) <br>{ <br>    WNDCLASS cls; <br>    HRESULT ddrval; <br>    DDSURFACEDESC ddsd; <br>    BOOL returnValue = FALSE; <br>     <br>    /* Save instance handle for DialogBoxs */ <br>    hInstApp = hInst; <br>     <br>    hAccelApp = LoadAccelerators(hInst, "AppAccel"); <br>     <br>    if (!hPrev) { <br>        /* <br>         *      Register a class for the main application window <br>         */ <br>        cls.hCursor        = LoadCursor(NULL,IDC_ARROW); <br>        cls.hIcon                  = LoadIcon(hInst,"AppIcon"); <br>        cls.lpszMenuName   = "AppMenu"; <br>        cls.lpszClassName  = szAppName; <br>        cls.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1); <br>        cls.hInstance      = hInst; <br>        cls.style                  = CS_BYTEALIGNCLIENT | CS_VREDRAW | CS_HREDRAW | CS_DBLCLKS; <br>        cls.lpfnWndProc    = (WNDPROC)AppWndProc; <br>        cls.cbWndExtra     = 0; <br>        cls.cbClsExtra     = 0; <br>         <br>        if (RegisterClass(&amp;cls)) { <br>            hwndApp = CreateWindow ( <br>                        szAppName,      // Class name <br>                        szAppName,      // Caption <br>                        WS_OVERLAPPEDWINDOW,        // Style bits <br>                        50, 50,         // Position <br>                        400+20,400+75,  // Size <br>                        (HWND)NULL,     // Parent window (no parent) <br>                        (HMENU)NULL,    // use class menu <br>                        hInst,          // handle to window instance <br>                        (LPSTR)NULL);   // no params to pass on <br>            ShowWindow(hwndApp,sw); <br> <br>            // init our direct draw stuff <br>            ddrval = DirectDrawCreate( NULL, &amp;pDirectDrawObj, NULL ); <br>            if( DD_OK == ddrval) { <br>                // clear out the surface desctiptions <br>                ZeroMemory( &amp;ddsd, sizeof( ddsd ) ); <br>                // set the size <br>                ddsd.dwSize = sizeof( ddsd ); <br> <br>                // figure out what display mode we are in now <br>                ddrval = pDirectDrawObj-&gt;GetDisplayMode( &amp;ddsd ); <br>                if( DD_OK == ddrval ) { <br>                    // make sure we're in  a 8-bit mode <br>                    if( ddsd.ddpfPixelFormat.dwRGBBitCount &gt;= 8) { <br>                        ScreenHeight = ddsd.dwHeight; <br>                        ScreenWidth = ddsd.dwWidth; <br>         <br>                        // if we are biger than 800x600 it's to much memory <br>                        // to move around. Clip it <br>                        if(ScreenHeight &gt; 600) ScreenHeight = 600; <br>                        if(ScreenWidth &gt; 800) ScreenWidth = 800; <br> <br>                        if( (ScreenWidth &lt; 800) || (ScreenHeight &lt; 600) ) { <br>                            ErrMsg("Resolutions smaller than 800x600 may yeild different numbers because of L2 cache effects"); <br>                        } <br>                         <br>                        // allocate some memory we are going to play with <br>                        pSource = (PCHAR)GlobalAllocPtr(GHND, ScreenHeight * ScreenWidth); <br>                        pDest = (PCHAR)GlobalAllocPtr(GHND, ScreenHeight * ScreenWidth); <br> <br>                        // make sure the memory worked and it's dword alligned. <br>                        // (we're in Win32, when is not going to be dword alligned?) <br>                        if( pSource &amp;&amp; pDest &amp;&amp; !((DWORD)pSource &amp; 0x3) &amp;&amp; !((DWORD)pDest &amp; 0x3)) { <br>                            returnValue = TRUE; <br>                        } else { <br>                            ErrMsg("Memory allocation failure"); <br>                        } <br>                    } else { <br>                        ErrMsg("You must be in a 8-bit (or better) color mode to run this app"); <br>                    } <br>                } else { <br>                    ErrMsg("DirectDraw failure getting the display mode"); <br>                } <br>            } else { <br>                ErrMsg("DirectDraw create failure"); <br>            } <br>        } else { <br>            ErrMsg("Register Class failure"); <br>        } <br>    } <br>    return returnValue; <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>|   BandwidthTestsSetup <br>| <br>|   Description: <br>|       Setup the surfaces for the bandwidth tests <br>| <br>|   Returns:                                                                 <br>|       TRUE if successful, FALSE if not                                 <br>\*----------------------------------------------------------------------------*/ <br>BOOL <br>BandwidthTestsSetup( VOID ) <br>{ <br>    DDSURFACEDESC ddsd; <br>    BOOL returnValue = FALSE; <br>    HRESULT ddrval; <br> <br>    if( pOnScreenBuf ) pOnScreenBuf-&gt;Release(); <br>    if( pOffScreenBuf ) pOffScreenBuf-&gt;Release(); <br>    if( pSysMemBuf ) pSysMemBuf-&gt;Release(); <br>     <br>    // Tell the world we love it and want to share <br>    ddrval = pDirectDrawObj-&gt;SetCooperativeLevel( hwndApp, DDSCL_NORMAL ); <br>    if( DD_OK == ddrval ) { <br>        // clear out out stuff <br>        ZeroMemory( &amp;ddsd, sizeof( ddsd ) ); <br>        ddsd.dwSize = sizeof( ddsd ); <br> <br>        ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT |DDSD_WIDTH; <br>        ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN; <br> <br>        ddsd.dwHeight = ScreenHeight; <br>        ddsd.dwWidth = ScreenWidth; <br>        // create our off screen video memory. <br>        ddrval = pDirectDrawObj-&gt;CreateSurface( &amp;ddsd, &amp;pOffScreenBuf, NULL ); <br>        if( DD_OK == ddrval ) { <br>            // yay! <br>            returnValue = TRUE; <br>        } else { <br>            ErrMsg("Failure creating video surface"); <br>        } <br>    } else { <br>        ErrMsg("Failure setting Co-op mode"); <br>    } <br>    return returnValue; <br>} <br>/*----------------------------------------------------------------------------*\ <br>|   AppExit() <br>| <br>|   Description: <br>|       app is just about to exit, cleanup <br>| <br>\*----------------------------------------------------------------------------*/ <br>void AppExit() <br>{ <br>    if( pSource ) GlobalFreePtr(pSource); <br>    if( pDest ) GlobalFreePtr(pDest); <br>    if( pOffScreenBuf ) pOffScreenBuf-&gt;Release(); <br>    if( pOnScreenBuf ) pOnScreenBuf-&gt;Release(); <br>    if( pSysMemBuf ) pSysMemBuf-&gt;Release(); <br>    if( pDirectDrawObj ) pDirectDrawObj-&gt;Release(); <br> <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>|   WinMain( hInst, hPrev, lpszCmdLine, cmdShow )                                                      | <br>| <br>|   Description: <br>|       The main procedure for the App.  After initializing, it just goes <br>|       into a message-processing loop until it gets a WM_QUIT message <br>|       (meaning the app was closed).                                                                              | <br>| <br>|   Arguments: <br>|       hInst       instance handle of this instance of the app <br>|       hPrev       instance handle of previous instance, NULL if first <br>|       szCmdLine   -&gt;null-terminated command line <br>|       cmdShow     specifies how the window is initially displayed <br>| <br>|       Returns: <br>|               The exit code as specified in the WM_QUIT message. <br>| <br>\*----------------------------------------------------------------------------*/ <br>int PASCAL WinMain(HINSTANCE hInst, HINSTANCE hPrev, LPSTR szCmdLine, int sw) <br>{ <br>    MSG msg; <br> <br>    /* Call initialization procedure */ <br>    if (!AppInit(hInst,hPrev,sw,szCmdLine)) <br>    return FALSE; <br> <br>    /* <br>     * Polling messages from event queue <br>     */ <br>    for (;;) { <br>        if(!GetMessage(&amp;msg, NULL, 0, 0)) { <br>            return msg.wParam; <br>        } <br>        TranslateMessage(&amp;msg); <br>        DispatchMessage(&amp;msg); <br>    } <br> <br>    return msg.wParam; <br>} <br> <br> <br>/*----------------------------------------------------------------------------*\ <br>|   AppPaint(hwnd, hdc) <br>| <br>|   Description: <br>|       The paint function.  Right now this does nothing. <br>| <br>|   Arguments: <br>|       hwnd    window painting into <br>|       hdc     display context to paint to <br>| <br>|   Returns: <br>|       nothing <br>| <br>\*----------------------------------------------------------------------------*/ <br>AppPaint (HWND hwnd, HDC hdc) <br>{ <br>    TEXTMETRIC tm; <br>    int     x,y; <br>    RECT    rc; <br>     <br>#define PRINT_STUFF(sz) (TextOut(hdc, x, y, sz, lstrlen(sz)), y += tm.tmHeight+1) <br> <br>    SelectObject(hdc, GetStockObject(ANSI_FIXED_FONT)); <br>    GetTextMetrics(hdc, &amp;tm); <br> <br>    GetClientRect(hwnd,&amp;rc); <br>     <br>    SetTextColor(hdc,GetSysColor(COLOR_WINDOWTEXT)); <br>    SetBkColor(hdc,GetSysColor(COLOR_WINDOW)); <br> <br>    // setup start pos <br>    x=4; <br>    y=4; <br> <br>    PRINT_STUFF("Select 'Time All' to run tests"); <br>    y += (tm.tmHeight+1) * 2; <br>    PRINT_STUFF("The screen will go blank during some tests"); <br> <br>    return TRUE; <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>|   AppWndProc( hwnd, uiMessage, wParam, lParam ) <br>| <br>|   Description: <br>|       The window proc for the app's main (tiled) window. <br>|       This processes all of the parent window's messages. <br>| <br>\*----------------------------------------------------------------------------*/ <br>LRESULT CALLBACK AppWndProc(HWND hwnd,UINT msg,WPARAM wParam,LPARAM lParam) <br>{ <br>    PAINTSTRUCT ps; <br>    HDC hdc; <br> <br>    switch (msg) { <br>        case WM_COMMAND: <br>            return AppCommand(hwnd,msg,wParam,lParam); <br>            break; <br> <br>        case WM_PAINT: <br>            hdc = BeginPaint(hwnd,&amp;ps); <br>            AppPaint( hwnd, hdc ); <br>            break; <br> <br>        case WM_DESTROY: <br>            hAccelApp = NULL; <br>            PostQuitMessage(0); <br>            break; <br> <br>    } <br>    return DefWindowProc(hwnd,msg,wParam,lParam); <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>|   AppCommand(hwnd, msg, wParam, lParam ) <br>| <br>|   Description: <br>|       handles WM_COMMAND messages for the main window (hwndApp) <br>|       of the parent window's messages. <br>| <br>\*----------------------------------------------------------------------------*/ <br>LONG AppCommand (HWND hwnd,UINT msg,WPARAM wParam,LPARAM lParam) <br>{ <br>    char achFileName[128] = ""; <br>     <br>    switch(wParam) { <br>        case MENU_ABOUT: <br>            DialogBox(hInstApp,"AppAbout",hwnd,(DLGPROC)AppAbout); <br>            break; <br>         <br> <br>        // do all the timing tests <br>        case MENU_TIMEALL: <br>            { <br>            HCURSOR Arror = SetCursor(LoadCursor(0,IDC_WAIT)); <br> <br>            ShowCursor(FALSE);  //take care of animated Plus! cursors <br> <br>            DWORD PriorityClass = GetPriorityClass(GetCurrentProcess()); <br>            int ThreadPriority = GetThreadPriority(GetCurrentThread()); <br> <br>            if( NUMBER_OF(SystemTests) != NUMBER_OF(VideoTests)) <br>            { <br>                ErrMsg("test number mismatch"); <br>                break; <br>            } <br> <br>            // Jack this thread up to realtime. <br>            // NOTE: This is very bad from for the real world. The rule is <br>            // "The Higher your ptiority, the less work your thread should do". <br>            // We are doing a lot of work. But this is only a test app, so who cares. <br>            SetPriorityClass(GetCurrentProcess(),REALTIME_PRIORITY_CLASS); <br>            SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_TIME_CRITICAL); <br> <br>            // setup the surfaces for the bandwidth tests <br>            BandwidthTestsSetup(); <br>            // Walk through the list of timers, and call them all <br> <br>            for(int Counter = 0;Counter &lt; NUMBER_OF(SystemTests) ;Counter++) { <br> <br>                SetWindowText(hwndApp,SystemTests[Counter].pDescription); <br> <br>                DoSystemTest( &amp;SystemTests[Counter] ); <br> <br>                SetWindowText(hwndApp,VideoTests[Counter].pDescription); <br> <br>                DoVideoTests( &amp;VideoTests[Counter] ); <br>             <br>            } <br> <br>            // do 320x240 frame rate tests <br>            ModeXFrameCount = GetFPS(320,240); <br>            // do 640x480 frame rate tests <br>            ModeYFrameCount = GetFPS(640,480); <br>            // do 320x240 stretch to 640x480 frame rate tests <br>            StretchFrameCount = GetStretchFPS(640,480); <br> <br>            // return ourselves to normal <br>            SetPriorityClass(GetCurrentProcess(),PriorityClass); <br>            SetThreadPriority(GetCurrentThread(),ThreadPriority); <br> <br>            SetCursor(Arror); <br>            SetWindowText(hwndApp,szAppName); <br>             <br>            ShowCursor(TRUE); <br>            PrintTimingResults(); <br>            } <br>            break; <br> <br>        case MENU_EXIT: <br>            PostMessage(hwnd,WM_CLOSE,0,0L); <br>            break; <br>    } <br>    return 0L; <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>|   ErrMsg - Opens a Message box with a error message in it.  The user can <br>|       select the OK button to continue <br>\*----------------------------------------------------------------------------*/ <br>int ErrMsg (LPSTR sz,...) <br>{ <br>        char ach[128]; <br>        va_list va; <br> <br>        va_start( va, sz ); <br>        wvsprintf ( ach, sz, va );       /* Format the string */ <br>        va_end( va ); <br>        MessageBox(hwndApp,ach,szAppName,MB_OK|MB_ICONEXCLAMATION|MB_TASKMODAL); <br>        return FALSE; <br>} <br> <br> <br> <br> <br>/*----------------------------------------------------------------------------*\ <br>|   PrintTimingResults( void ) <br>| <br>|   Description: <br>|       Print the results of the timting tests <br>| <br>\*----------------------------------------------------------------------------*/ <br>#include &lt;stdio.h&gt; <br> <br>VOID <br>PrintTimingResults( void ) <br>{ <br>    double result; <br>    LARGE_INTEGER perfFreq; <br>    char OutputBuffer[2048]; <br>    char TempOutputBuffer[2048]; <br>#define PRINT_DOUBLE(d) {sprintf(TempOutputBuffer,"%12.8f",d);strcat(OutputBuffer,TempOutputBuffer);} <br>#define PRINT_STRING(s) {sprintf(TempOutputBuffer,"%s",s);strcat(OutputBuffer,TempOutputBuffer);} <br> <br>    OutputBuffer[0]=0; <br>    TempOutputBuffer[0]=0; <br> <br>    // get the frequemcy out of timer <br>    QueryPerformanceFrequency( &amp;perfFreq ); <br> <br>    // Turn all the time resutls into MB per second <br>    for(int Counter = 0; Counter &lt; NUMBER_OF(SystemTests) ; Counter++) { <br>        if(SystemTests[Counter].Time) { <br>            result = (double)SystemTests[Counter].Iterations; <br>            result /= (double)SystemTests[Counter].Time / (double)perfFreq.LowPart; <br>            result /= (double)1000000.0; <br>            PRINT_DOUBLE(result); <br>        } else { <br>            PRINT_STRING("N/A"); <br>        } <br>        PRINT_STRING(" MB/sec \t"); <br>        PRINT_STRING(SystemTests[Counter].pDescription); <br>        PRINT_STRING("\n"); <br> <br>        if(VideoTests[Counter].Time) { <br>            result = (double)VideoTests[Counter].Iterations; <br>            result /= (double)VideoTests[Counter].Time / (double)perfFreq.LowPart; <br>            result /= (double)1000000.0; <br>            PRINT_DOUBLE(result); <br>        } else { <br>            PRINT_STRING("N/A"); <br>        } <br>        PRINT_STRING(" MB/sec \t"); <br>        PRINT_STRING(VideoTests[Counter].pDescription); <br>        PRINT_STRING("\n"); <br> <br>    } <br> <br>    if( ModeXFrameCount ) { <br>        PRINT_DOUBLE((double)ModeXFrameCount/5.0); <br>    } else { <br>        PRINT_STRING("N/A"); <br>    } <br>    PRINT_STRING(" FPS \t\t"); <br>    PRINT_STRING("320x240 Frame Rate"); <br>    PRINT_STRING("\n"); <br> <br>    if( ModeYFrameCount ) { <br>        PRINT_DOUBLE((double)ModeYFrameCount/5.0); <br>    } else { <br>        PRINT_STRING("N/A"); <br>    } <br>    PRINT_STRING(" FPS \t\t"); <br>    PRINT_STRING("640x480 Frame Rate"); <br>    PRINT_STRING("\n"); <br> <br>    if( StretchFrameCount ) { <br>        PRINT_DOUBLE((double)StretchFrameCount/5.0); <br>    } else { <br>        PRINT_STRING("N/A"); <br>    } <br>    PRINT_STRING(" FPS \t\t"); <br>    PRINT_STRING("320x240 stretched to 640x480"); <br>    PRINT_STRING("\n"); <br> <br>#ifndef LOR_TESTS <br>    // display the results <br>    MessageBox(0, OutputBuffer ,"Timing Results",MB_OK); <br>#endif <br> <br>} <br> <br>VOID DoSystemTest( PTIMING_RESULT pTimeObject ) <br>{ <br>    LARGE_INTEGER startTime, endTime; <br> <br>    QueryPerformanceCounter( &amp;startTime ); <br> <br>    // do the memory copy <br>    pTimeObject-&gt;Iterations = (*pTimeObject-&gt;pTimer)(pSource, pDest, ScreenHeight, ScreenWidth, ScreenWidth, 100 ); <br>     <br>    QueryPerformanceCounter( &amp;endTime ); <br> <br>    // if it takes more than 32bits of clock ticks <br>    // it's not worth profiling. <br>    pTimeObject-&gt;Time = endTime.LowPart - startTime.LowPart; <br>} <br> <br>VOID DoVideoTests( PTIMING_RESULT pTimeObject ) <br>{ <br>    DDSURFACEDESC ddsd; <br>    HRESULT returnValue; <br>    LARGE_INTEGER startTime, endTime; <br> <br>    ZeroMemory( &amp;ddsd, sizeof( ddsd ) ); <br>    ddsd.dwSize = sizeof( ddsd ); <br> <br> <br>    // lock the video memory surfce <br>    // NOTE: We are about to do a lock for a REALLY long time. <br>    // this is really bad form in the real world. <br>    // <br>    returnValue = pOffScreenBuf-&gt;Lock( NULL, &amp;ddsd, DDLOCK_SURFACEMEMORYPTR, NULL); <br>    if( returnValue == DD_OK ) <br>    { <br>        if( ddsd.lPitch &amp;&amp; ddsd.dwWidth &amp;&amp; ddsd.dwHeight &amp;&amp; ddsd.lpSurface) <br>        { <br>            // get the time, and do the copy <br>            QueryPerformanceCounter( &amp;startTime ); <br> <br>            pTimeObject-&gt;Iterations = (*pTimeObject-&gt;pTimer)( pSource, ddsd.lpSurface, ddsd.dwHeight, ddsd.dwWidth, ddsd.lPitch, 100 ); <br> <br>            QueryPerformanceCounter( &amp;endTime ); <br> <br>            pOffScreenBuf-&gt;Unlock( ddsd.lpSurface ); <br>            // stor the delta time <br>            pTimeObject-&gt;Time = endTime.LowPart - startTime.LowPart; <br>        } <br>        else <br>        { <br>            pOffScreenBuf-&gt;Unlock( ddsd.lpSurface ); <br>            ErrMsg("Lock returned bogus Session Description stuff"); <br>        } <br>    } <br>    else <br>        ErrMsg("Can't lock surface"); <br> <br>    return; <br>} <br> <br>BOOL <br>InitFullScreen( <br>    DWORD Height, <br>    DWORD Width <br>    ) <br>{ <br>    DDSURFACEDESC ddsd; <br>    DDSCAPS ddscaps; <br>    HRESULT ddrval; <br>    ULONG returnValue = FALSE; <br> <br>    // Kill our current offscreen surface. <br>    if( pOffScreenBuf ) { <br>        ddrval = pOffScreenBuf-&gt;Release(); <br>        if( ddrval != DD_OK ) { <br>            ErrMsg("Can't release offscreen buf"); <br>        } <br>    } <br> <br> <br>    // Get exclusive mode <br>    ddrval = pDirectDrawObj-&gt;SetCooperativeLevel( hwndApp, DDSCL_EXCLUSIVE | DDSCL_FULLSCREEN | DDSCL_ALLOWMODEX | DDSCL_NOWINDOWCHANGES ); <br> <br>    if( ddrval == DD_OK ){ <br>        // set the display mode to the requested mode <br>        ddrval = pDirectDrawObj-&gt;SetDisplayMode( Height, Width, 8); <br>        if(ddrval == DD_OK){ <br>            ddsd.dwSize = sizeof( ddsd ); <br>            ddsd.dwFlags = DDSD_CAPS | DDSD_BACKBUFFERCOUNT; <br>            ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE | <br>                          DDSCAPS_FLIP | <br>                          DDSCAPS_COMPLEX; <br>            ddsd.dwBackBufferCount = 1; <br>            // get the primary buffer <br>            ddrval = pDirectDrawObj-&gt;CreateSurface( &amp;ddsd, &amp;pOnScreenBuf, NULL ); <br> <br>            if( ddrval == DD_OK ) { <br>                ddscaps.dwCaps = DDSCAPS_BACKBUFFER; <br>                // the back buffer might be in system memory depending <br>                // on the card and the mode. <br>                ddrval = pOnScreenBuf-&gt;GetAttachedSurface(&amp;ddscaps, &amp;pOffScreenBuf); <br> <br>                if( ddrval == DD_OK ) { <br>                    returnValue = TRUE; <br>                }  <br>            } <br>        } else { <br>            ErrMsg("can't set display mode %d x %d",Width,Height); <br>        } <br>    } <br>    return returnValue; <br>} <br> <br> <br>BOOL <br>CreateSysMemSurface( VOID ) <br>{ <br>    DDSURFACEDESC ddsd; <br>    ULONG returnValue; <br> <br>    // clear out out stuff <br>    ZeroMemory( &amp;ddsd, sizeof( ddsd ) ); <br>    ddsd.dwSize = sizeof( ddsd ); <br> <br>    // build a surface in system memory <br>    ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT |DDSD_WIDTH; <br>    ddsd.ddsCaps.dwCaps = DDSCAPS_SYSTEMMEMORY; <br>     <br>    ddsd.dwHeight = 240; <br>    ddsd.dwWidth = 320; <br>    returnValue = pDirectDrawObj-&gt;CreateSurface( &amp;ddsd, &amp;pSysMemBuf, NULL ); <br>    if( DD_OK == returnValue ) { <br>        return TRUE; <br>    } <br> <br>    return FALSE; <br>} <br> <br>ULONG <br>GetStretchFPS( int width, int height ) <br>{ <br>    ULONG time; <br>    HRESULT ddrval; <br>    DDSURFACEDESC ddsd; <br>    DDBLTFX     ddbltfx; <br>    ULONG FrameCount; <br> <br>    // set the mode (and create the surfaces) <br>    if( InitFullScreen( width, height ) ) { <br>        // get the system memory surface <br>        if( CreateSysMemSurface() ) { <br> <br>            // build the ROP for the blt <br>            ZeroMemory( &amp;ddbltfx, sizeof(ddbltfx) ); <br>            ddbltfx.dwSize = sizeof( ddbltfx ); <br>            ddbltfx.dwROP = SRCCOPY; <br> <br>            time = timeGetTime(); <br>            // wait for a seconds for the mode to settle out <br>            // (I don't need to do this.. I'm just paranoid) <br>            while( (timeGetTime() - time) &lt; 1000); <br>            FrameCount = 0; <br>            time = timeGetTime(); <br> <br>            // Initialize the surface description structure <br>            ZeroMemory(&amp;ddsd, sizeof(ddsd)); <br>            ddsd.dwSize=sizeof(ddsd); <br> <br>            ddrval = 0; <br>            // do this for 5 seconds <br>            while( ((timeGetTime() - time) &lt; 5000) &amp;&amp; (DD_OK == ddrval) ) { <br>                // simluate rendering and off screen frame (with a copy) <br>                ddrval = pSysMemBuf-&gt;Lock( NULL, &amp;ddsd, DDLOCK_SURFACEMEMORYPTR | DDLOCK_WAIT, NULL); <br>                if (FAILED(ddrval)) <br>                { <br>                    FrameCount=0; <br>                    break; <br>                } <br>  <br>                DwordMemCopy_Pitch( pSource, ddsd.lpSurface, ddsd.dwHeight, ddsd.dwWidth, ddsd.lPitch, 1); <br> <br>                ddrval = pSysMemBuf-&gt;Unlock( NULL ); <br>                if (FAILED(ddrval)) <br>                { <br>                    FrameCount=0; <br>                    break; <br>                } <br> <br>                // blt the system buffer into the back buffer <br>                ddrval = pOffScreenBuf-&gt;Blt( NULL, pSysMemBuf, NULL, DDBLT_ROP, &amp;ddbltfx); <br>                if (FAILED(ddrval)) <br>                { <br>                    FrameCount=0; <br>                    break; <br>                } <br> <br>                // flip the back buffer on screen <br>                ddrval = pOnScreenBuf-&gt;Flip( NULL, DDFLIP_WAIT ); <br>                if (FAILED(ddrval)) <br>                { <br>                    FrameCount=0; <br>                    break; <br>                } <br> <br>                FrameCount++; <br>            } <br>        } <br>        pDirectDrawObj-&gt;RestoreDisplayMode(); <br>        if( DD_OK != ddrval ) { <br>            ErrMsg("Test failure %X",ddrval); <br>        } <br> <br>        pOffScreenBuf-&gt;Release(); <br>        pOffScreenBuf = NULL; <br>        pOnScreenBuf-&gt;Release(); <br>        pOnScreenBuf = NULL; <br>        pSysMemBuf-&gt;Release(); <br>        pSysMemBuf = NULL; <br>    } <br>    return FrameCount; <br>} <br> <br>ULONG GetFPS( int width, int height ) <br>{ </code></pre>
<p>
</p>
<pre><code>ULONG time; <br>    DDSURFACEDESC ddsd; <br>    HRESULT ddrval; <br>    ULONG FrameCount; <br> <br>    ZeroMemory( &amp;ddsd, sizeof( ddsd ) ); <br>    ddsd.dwSize = sizeof( ddsd ); <br> <br>    // set the mode (and setup the surfaces)     <br>    if( InitFullScreen( width, height ) ) <br>    { <br>        time = timeGetTime(); <br>        // wait for a seconds for the mode to settle out <br>        // (I don't need to do this, I'm just paranoid) <br>        while( (timeGetTime() - time) &lt; 1000); <br>        ddrval = DD_OK; <br>        FrameCount = 0; <br>        time = timeGetTime(); <br>        while( ((timeGetTime() - time) &lt; 5000) &amp;&amp; (ddrval == DD_OK) ) <br>        { <br>            // simluate a render into the back buffer with a copy <br>            ddrval = pOffScreenBuf-&gt;Lock( NULL, &amp;ddsd, DDLOCK_SURFACEMEMORYPTR | DDLOCK_WAIT, NULL); <br>            if (FAILED(ddrval)) <br>            { <br>                FrameCount=0; <br>                break; <br>            } <br>            // Stuff some Junk into the offscreen surface <br>            DwordMemCopy_Pitch( pSource, ddsd.lpSurface, ddsd.dwHeight, ddsd.dwWidth, ddsd.lPitch, 1 ); <br> <br>            ddrval = pOffScreenBuf-&gt;Unlock( NULL ); <br>            if (FAILED(ddrval)) <br>            { <br>                FrameCount=0; <br>                break; <br>            } <br> <br>            // flip the off screen surface on screen <br>            ddrval = pOnScreenBuf-&gt;Flip( NULL, DDFLIP_WAIT ); <br>            if (FAILED(ddrval)) <br>            { <br>                FrameCount=0; <br>                break; <br>            } <br> <br>            FrameCount++; <br>        } <br>        pDirectDrawObj-&gt;RestoreDisplayMode(); <br>        if( FAILED(ddrval) ) <br>            ErrMsg("Test failure %X",ddrval); <br>        pOffScreenBuf-&gt;Release(); <br>        pOffScreenBuf = NULL; <br>        pOnScreenBuf-&gt;Release(); <br>        pOnScreenBuf = NULL; <br>    } <br> <br>    return FrameCount; <br>} <br> <br>/***************************************************************************** <br> * <br> * dprintf() is called by the DPF macro if DEBUG is defined at compile time. <br> * <br> * The messages will be send to COM1: like any debug message. To <br> * enable debug output, add the following to WIN.INI : <br> * <br> * [debug] <br> * QA=1 <br> * <br> ****************************************************************************/ <br> <br>#ifdef DEBUG <br> <br>#define MODNAME "QA" <br> <br> <br>#define _WINDLL <br>#include &lt;stdarg.h&gt; <br> <br>void FAR CDECL dprintf(LPSTR szFormat, ...) <br>{ <br>    char ach[128]; <br>    va_list va; <br>     <br>    static BOOL fDebug = -1; <br>     <br>    if (fDebug == -1) { <br>        fDebug = GetProfileIntA("Debug", MODNAME, TRUE); <br>    } <br>     <br>    if (!fDebug) return; <br> <br>     <br>     <br>    lstrcpyA(ach, MODNAME ": "); <br>    va_start(va, szFormat); <br>    wvsprintfA(ach+lstrlenA(ach),szFormat,(LPSTR)va); <br>    va_end(va); <br>    lstrcatA(ach, "\r\n"); <br>     <br>    OutputDebugStringA(ach); <br>} <br> <br>#endif </code></pre>
<p>&nbsp;</p></body>
</HTML>
