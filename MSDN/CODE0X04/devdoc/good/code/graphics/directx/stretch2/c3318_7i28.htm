<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>STRETCH.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3320"></a>STRETCH.CPP</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1995-1997 Microsoft Corporation. All Rights Reserved. <br> * <br> *  File:       stretch.cpp <br> * <br> *  stretch with multimonitor support <br> * <br> ***************************************************************************/ <br> <br>#define NAME "Stretch" <br>#define TITLE "Stretch" <br> <br>#define WIN32_LEAN_AND_MEAN <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;ddraw.h&gt; <br>#include "resource.h" <br>#include "ddutil.h" <br>#include "ddmm.h" <br> <br>#define SIZEX64 <br>#define SIZEY64 <br>char *szBitmap = "DONUT"; <br> <br>HWNDhwnd; <br>DWORD           UpdateDelay = 100; <br> <br>LPDIRECTDRAWlpDD;// DirectDraw object <br>LPDIRECTDRAWSURFACElpDDSPrimary;// DirectDraw primary surface <br>LPDIRECTDRAWSURFACElpDDSOne;// Offscreen surface 1 <br>LPDIRECTDRAWCLIPPER     lpClipper;      // clipper for primary <br>LPDIRECTDRAWPALETTElpDDPal;// DirectDraw palette <br>BOOL                    bActive;        // is application active? <br> <br>/* multimon stuff <br>*/ <br>int     MyDevice; <br>char    MyDeviceName[128]; <br>RECT    MyDeviceRect; <br> <br>BOOL ddInit(HWND); <br> <br>/* <br> * restoreAll <br> * <br> * restore all lost objects <br> */ <br>BOOL restoreAll( void ) <br>{ <br>    return lpDDSPrimary-&gt;Restore() == DD_OK &amp;&amp; <br>           lpDDSOne-&gt;Restore()     == DD_OK &amp;&amp; <br>           DDReLoadBitmap(lpDDSOne, szBitmap) == DD_OK; <br> <br>} /* restoreAll */ <br> <br>/* <br> * updateFrame <br> *  <br> * Decide what needs to be blitted next, wait for flip to complete, <br> * then flip the buffers. <br> */ <br>void updateFrame( void ) <br>{ <br>    static DWORDlastTickCount = 0; <br>    static intcurrentFrame = 0; <br>    static BOOL         haveBackground = FALSE; <br>    DWORDthisTickCount; <br>    RECTrcRect; <br>    RECTdestRect; <br>    HRESULTddrval; <br>    POINT               pt; <br> <br>    thisTickCount = GetTickCount(); <br>    if((thisTickCount - lastTickCount) &lt;= UpdateDelay) <br>    { <br>return; <br>    } <br> <br>    // Move to next frame; <br>    lastTickCount = thisTickCount; <br>    currentFrame++; <br>    if(currentFrame &gt; 59) <br>    { <br>        currentFrame = 0; <br>    } <br> <br>    // Blit the stuff for the next frame <br>    rcRect.left   = currentFrame%10*64; <br>    rcRect.top    = currentFrame/10*64; <br>    rcRect.right  = currentFrame%10*64 + 64; <br>    rcRect.bottom = currentFrame/10*64 + 64; <br> <br>    GetClientRect( hwnd, &amp;destRect ); <br>    if (destRect.right  &lt; 64) destRect.right = 64; <br>    if (destRect.bottom &lt; 64)  destRect.bottom = 64; <br> <br>    pt.x = pt.y = 0; <br>    ClientToScreen( hwnd, &amp;pt ); <br>    pt.x -= MyDeviceRect.left; <br>    pt.y -= MyDeviceRect.top; <br>    OffsetRect(&amp;destRect, pt.x, pt.y); <br> <br>    while( 1 ) <br>    { <br>        ddrval = lpDDSPrimary-&gt;Blt( &amp;destRect, lpDDSOne, &amp;rcRect, 0, NULL ); <br> <br>if( ddrval == DD_OK ) <br>{ <br>    break; <br>} <br>if( ddrval == DDERR_SURFACELOST ) <br>{ <br>            if(!restoreAll()) <br>    { <br>return; <br>    } <br>} <br>if( ddrval != DDERR_WASSTILLDRAWING ) <br>{ <br>    return; <br>} <br>    } <br>    if(ddrval != DD_OK) <br>    { <br>return; <br>    } <br>} /* updateFrame */ <br> <br> <br>/* <br> * finiObjects <br> * <br> * finished with all objects we use; release them <br> */ <br>static void finiObjects( BOOL fKillDD ) <br>{ <br>    if( lpDDSPrimary != NULL ) <br>    { <br>        lpDDSPrimary-&gt;Release(); <br>        lpDDSPrimary = NULL; <br>    } <br>    if( lpDDSOne != NULL ) <br>    { <br>        lpDDSOne-&gt;Release(); <br>        lpDDSOne = NULL; <br>    } <br>    if( lpDDPal != NULL ) <br>    { <br>        lpDDPal-&gt;Release(); <br>        lpDDPal = NULL; <br>    } <br>    if( fKillDD &amp;&amp; lpDD != NULL ) <br>    { <br>        lpDD-&gt;Release(); <br>        lpDD = NULL; <br>    } <br>} /* finiObjects */ <br> <br>long FAR PASCAL WindowProc( HWND hWnd, UINT message,  <br>    WPARAM wParam, LPARAM lParam ) <br>{ <br>    RECT  rc; <br> <br>    switch( message ) <br>    { <br>    case WM_ACTIVATEAPP: <br>    bActive = wParam; <br>break; <br> <br>    case WM_DISPLAYCHANGE: <br>        ddInit(hwnd); <br>        break; <br> <br>    case WM_SIZE: <br>    case WM_MOVE: <br>        if (MyDevice != DirectDrawDeviceFromWindow(hwnd,NULL,NULL)) <br>        { <br>            ddInit(hwnd); <br>        } <br>        break; <br> <br>    case WM_PALETTECHANGED: <br>        if ((HWND)wParam == hWnd) <br>            break; <br>        // fall through to WM_QUERYNEWPALETTE <br>    case WM_QUERYNEWPALETTE: <br>        // install our palette here <br>        if (lpDDPal) <br>        { <br>            lpDDSPrimary-&gt;SetPalette(lpDDPal); <br>        } <br>        // reload the bitmap into the surface because the palette <br>        // has changed.. <br>        DDReLoadBitmap(lpDDSOne, szBitmap); <br>        break; <br> <br> <br>    case WM_CREATE: <br>        break; <br> <br>    case WM_GETMINMAXINFO: <br>        ((MINMAXINFO*)lParam)-&gt;ptMinTrackSize.x = SIZEX; <br>        ((MINMAXINFO*)lParam)-&gt;ptMinTrackSize.y = SIZEY; <br>        return 0; <br> <br>    case WM_KEYDOWN: <br>switch( wParam ) <br>{ <br>case VK_ESCAPE: <br>        case VK_F12: <br>            PostMessage(hWnd, WM_CLOSE, 0, 0); <br>    break; <br>} <br>break; <br> <br>    case WM_DESTROY: <br>        finiObjects(TRUE); <br>PostQuitMessage( 0 ); <br>        break; <br> <br>    case WM_KEYUP: <br>        if (wParam &gt;= '1' &amp;&amp; wParam &lt;= '9') <br>        { <br>            SetRect(&amp;rc, 0, 0, SIZEX*(wParam-'0'), SIZEY*(wParam-'0')); <br>            goto size_me; <br>        } <br>        break; <br> <br>    case WM_COMMAND:  <br>    switch(LOWORD(wParam)) <br>{ <br>    case ID_ROTATION_STOP:     <br>UpdateDelay = 0x7fffffff; <br>break; <br>    case ID_ROTATION_SLOW:     <br>UpdateDelay = 200; <br>break; <br>    case ID_ROTATION_FAST:     <br>                UpdateDelay = 100; <br>break; <br>    case ID_FILE_EXIT:     <br>                PostMessage( hWnd, WM_CLOSE, 0, 0L ); <br>        break; <br>     <br>            case ID_SIZE_1X1: SetRect(&amp;rc, 0, 0, SIZEX*1, SIZEY*1); goto size_me; <br>            case ID_SIZE_2X1: SetRect(&amp;rc, 0, 0, SIZEX*2, SIZEY*1); goto size_me; <br>            case ID_SIZE_3X1: SetRect(&amp;rc, 0, 0, SIZEX*3, SIZEY*1); goto size_me; <br>            case ID_SIZE_1X2: SetRect(&amp;rc, 0, 0, SIZEX*1, SIZEY*2); goto size_me; <br>            case ID_SIZE_2X2: SetRect(&amp;rc, 0, 0, SIZEX*2, SIZEY*2); goto size_me; <br>            case ID_SIZE_3X2: SetRect(&amp;rc, 0, 0, SIZEX*3, SIZEY*2); goto size_me; <br>            case ID_SIZE_1X3: SetRect(&amp;rc, 0, 0, SIZEX*1, SIZEY*3); goto size_me; <br>            case ID_SIZE_2X3: SetRect(&amp;rc, 0, 0, SIZEX*2, SIZEY*3); goto size_me; <br>    case ID_SIZE_3X3: SetRect(&amp;rc, 0, 0, SIZEX*3, SIZEY*3); goto size_me; <br>size_me: <br>                AdjustWindowRectEx(&amp;rc, GetWindowLong(hWnd, GWL_STYLE), <br>    GetMenu(hWnd) != NULL, GetWindowLong(hWnd, GWL_EXSTYLE)); <br>SetWindowPos(hWnd, NULL, 0, 0, rc.right-rc.left, rc.bottom-rc.top, <br>                    SWP_NOZORDER|SWP_NOMOVE|SWP_NOACTIVATE); <br>break; <br>    }  <br>    break; <br>    } <br> <br>    return DefWindowProc(hWnd, message, wParam, lParam); <br> <br>} /* WindowProc */ <br> <br>/* <br> * This function is called if the initialization function fails <br> */ <br>BOOL initFail( HWND hwnd ) <br>{ <br>    finiObjects(TRUE); <br>    MessageBox( hwnd, "DirectDraw Init FAILED", TITLE, MB_OK ); <br>    DestroyWindow( hwnd ); <br>    return FALSE; <br> <br>} /* initFail */ <br> <br>/* <br> * ddInit <br> */ <br>BOOL ddInit( HWND hwnd ) <br>{ <br>    DDSURFACEDESCddsd; <br>    HRESULT             ddrval; <br>    char                ach[128]; <br> <br>    /* <br>     * clean up our mess <br>     */ <br>    finiObjects(TRUE); <br> <br>    MyDevice = DirectDrawDeviceFromWindow(hwnd,MyDeviceName,&amp;MyDeviceRect); <br> <br>    if (MyDeviceName[0] == 0) lstrcpy(MyDeviceName, "(none)"); <br>    wsprintf(ach, "%s - %s", TITLE, MyDeviceName); <br>    SetWindowText(hwnd, ach); <br> <br>    /* <br>     * create the main DirectDraw object <br>     */ <br>    lpDD = DirectDrawCreateFromWindow(hwnd); <br> <br>    if( lpDD == NULL ) <br>    { <br>return initFail(hwnd); <br>    } <br>    ddrval = lpDD-&gt;SetCooperativeLevel( hwnd, DDSCL_NORMAL ); <br> <br>    // Create the primary surface <br>    ddsd.dwSize = sizeof( ddsd ); <br>    ddsd.dwFlags = DDSD_CAPS; <br>    ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE; <br> <br>    ddrval = lpDD-&gt;CreateSurface( &amp;ddsd, &amp;lpDDSPrimary, NULL ); <br>    if( ddrval != DD_OK ) <br>    { <br>return initFail(hwnd); <br>    } <br> <br>    // create a clipper for the primary surface <br>    ddrval = lpDD-&gt;CreateClipper( 0, &amp;lpClipper, NULL ); <br>    if( ddrval != DD_OK ) <br>    { <br>        return initFail(hwnd); <br>    } <br> <br>    ddrval = lpClipper-&gt;SetHWnd( 0, hwnd ); <br>    if( ddrval != DD_OK ) <br>    { <br>        return initFail(hwnd); <br>    } <br> <br>    ddrval = lpDDSPrimary-&gt;SetClipper( lpClipper ); <br>    if( ddrval != DD_OK ) <br>    { <br>        return initFail(hwnd); <br>    } <br> <br>    // load our palette <br>    lpDDPal = DDLoadPalette(lpDD, szBitmap); <br> <br>    // make sure to set the palette before loading bitmaps. <br>    if (lpDDPal) <br>lpDDSPrimary-&gt;SetPalette(lpDDPal); <br> <br>    // load our bitmap <br>    lpDDSOne = DDLoadBitmap(lpDD, szBitmap, 0, 0); <br> <br>    if( lpDDSOne == NULL ) <br>    { <br>return initFail(hwnd); <br>    } <br> <br>    return TRUE; <br>} /* doInit */ <br> <br>/* <br> * doInit - do work required for every instance of the application: <br> *  create the window, initialize data <br> */ <br>static BOOL doInit( HINSTANCE hInstance, int nCmdShow ) <br>{ <br>    WNDCLASSwc; <br> <br>    /* <br>     * set up and register window class <br>     */ <br>    wc.style = CS_HREDRAW | CS_VREDRAW; <br>    wc.lpfnWndProc = WindowProc; <br>    wc.cbClsExtra = 0; <br>    wc.cbWndExtra = 0; <br>    wc.hInstance = hInstance; <br>    wc.hIcon = LoadIcon( hInstance, IDI_APPLICATION ); <br>    wc.hCursor = LoadCursor( NULL, IDC_ARROW ); <br>    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); <br>    wc.lpszMenuName = NULL; // MAKEINTRESOURCE(IDR_MENU); <br>    wc.lpszClassName = NAME; <br>    RegisterClass( &amp;wc ); <br>     <br>    /* <br>     * create a window <br>     */ <br>    hwnd = CreateWindowEx( <br>0, <br>NAME, <br>TITLE, <br>        WS_POPUP | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME, <br>CW_USEDEFAULT, <br>CW_USEDEFAULT, <br>128, <br>128, <br>NULL, <br>NULL, <br>hInstance, <br>NULL ); <br> <br>    if( !hwnd ) <br>    { <br>return FALSE; <br>    } <br> <br>    PostMessage(hwnd, WM_COMMAND, ID_SIZE_3X3, 0); <br> <br>    ShowWindow( hwnd, nCmdShow ); <br>    UpdateWindow( hwnd ); <br> <br>    /* <br>     * create the direct draw objects <br>     */ <br>    ddInit(hwnd); <br> <br>    return TRUE; <br> <br>} /* doInit */ <br> <br>/* <br> * WinMain - initialization, message loop <br> */ <br>int PASCAL WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, <br>LPSTR lpCmdLine, int nCmdShow) <br>{ <br>    MSG         msg; <br> <br>    if( !doInit( hInstance, nCmdShow ) ) <br>    { <br>return FALSE; <br>    } <br> <br>    while( 1 ) <br>    { <br>if( PeekMessage( &amp;msg, NULL, 0, 0, PM_NOREMOVE ) ) <br>{ <br>    if( !GetMessage( &amp;msg, NULL, 0, 0 ) ) <br>return msg.wParam; <br>    TranslateMessage(&amp;msg);  <br>    DispatchMessage(&amp;msg); <br>} <br>        else <br>{ <br>    updateFrame(); <br>} <br>    } <br>} /* WinMain */ <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
