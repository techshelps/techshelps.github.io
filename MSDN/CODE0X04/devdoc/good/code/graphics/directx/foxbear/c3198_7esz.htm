<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FOXBEAR.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3203"></a>FOXBEAR.C</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1995-1997 Microsoft Corporation. All Rights Reserved. <br> *  Copyright (C) 1994-1995 ATI Technologies Inc. All Rights Reserved. <br> * <br> *  File:winfox.c <br> *  Content:Windows fox sample game <br> * <br> ***************************************************************************/ <br>#include "foxbear.h" <br>#include "rcids.h"      // for FOX_ICON <br> <br>LPDIRECTDRAWSURFACE     lpFrontBuffer; <br>LPDIRECTDRAWSURFACE     lpBackBuffer; <br>LPDIRECTDRAWCLIPPER     lpClipper; <br>LPDIRECTDRAWSURFACE     lpStretchBuffer; <br>LPDIRECTDRAWSURFACE     lpFrameRate; <br>LPDIRECTDRAWSURFACE     lpInfo; <br>LPDIRECTDRAWPALETTE     lpPalette; <br>LPDIRECTDRAW            lpDD; <br>LPDIRECTDRAW2           lpDD2; <br>SHORT                   lastInput = 0; <br>HWND                    hWndMain; <br>RECT                    rcWindow; <br>BOOL                    bShowFrameCount=TRUE; <br>BOOL                    bIsActive; <br>BOOL                    bPaused; <br> <br>BOOL                    bStretch; <br>BOOL                    bFullscreen=TRUE; <br>BOOL                    bStress=FALSE;     // just keep running if true <br>BOOL                    bHelp=FALSE;       // help requested <br>RECT                    GameRect;          // game rect <br>SIZE                    GameSize;          // game is this size <br>SIZE                    GameMode;          // display mode size <br>UINT                    GameBPP;           // the bpp we want <br>DWORD                   dwColorKey;        // our color key <br>DWORD                   AveFrameRate; <br>DWORD                   AveFrameRateCount; <br>BOOL                    bWantSound = TRUE; <br> <br>extern int              DevIndex; <br>extern int              MaxDevIndex; <br> <br>#define OUR_APP_NAME  "Win Fox Application" <br> <br>#define ODS OutputDebugString <br> <br>BOOL InitGame(void); <br>void ExitGame(void); <br>void initNumSurface(void); <br>#ifndef DEBUG <br>void __cdecl Msg( LPSTR fmt, ... ) { } <br>#endif <br> <br> <br>/* <br> * PauseGame() <br> */ <br>void PauseGame() <br>{ <br>    Msg("**** PAUSE"); <br>    bPaused = TRUE; <br>    InvalidateRect(hWndMain, NULL, TRUE); <br>} <br> <br>/* <br> * UnPauseGame() <br> */ <br>void UnPauseGame() <br>{ <br>    if (GetForegroundWindow() == hWndMain) <br>    { <br>        Msg("**** UNPAUSE"); <br>        bPaused = FALSE; <br>    } <br>} <br> <br>/* <br> * RestoreGame() <br> */ <br>BOOL RestoreGame() <br>{ <br>    if (lpFrontBuffer == NULL || IDirectDrawSurface_Restore(lpFrontBuffer) != DD_OK) <br>    { <br>        Msg("***** cant restore FrontBuffer"); <br>        return FALSE; <br>    } <br> <br>    if (!bFullscreen) <br>    { <br>        if (lpBackBuffer == NULL || IDirectDrawSurface_Restore(lpBackBuffer) != DD_OK) <br>        { <br>            Msg("***** cant restore BackBuffer"); <br>            return FALSE; <br>        } <br>    } <br> <br>    if (lpStretchBuffer &amp;&amp; IDirectDrawSurface_Restore(lpStretchBuffer) != DD_OK) <br>    { <br>        Msg("***** cant restore StretchBuffer"); <br>        return FALSE; <br>    } <br> <br>    if (lpFrameRate == NULL || lpInfo == NULL || <br>        IDirectDrawSurface_Restore(lpFrameRate) != DD_OK || <br>        IDirectDrawSurface_Restore(lpInfo) != DD_OK) <br>    { <br>        Msg("***** cant restore frame rate stuff"); <br>        return FALSE; <br>    } <br>    initNumSurface(); <br> <br>    if (!gfxRestoreAll()) <br>    { <br>        Msg("***** cant restore art"); <br>        return FALSE; <br>    } <br> <br>    return TRUE; <br>} <br> <br>/* <br> * ProcessFox <br> */ <br>BOOL ProcessFox(SHORT sInput) <br>{ <br>    if ((lpFrontBuffer &amp;&amp; IDirectDrawSurface_IsLost(lpFrontBuffer) == DDERR_SURFACELOST) || <br>        (lpBackBuffer &amp;&amp; IDirectDrawSurface_IsLost(lpBackBuffer) == DDERR_SURFACELOST)) <br>    { <br>        if (!RestoreGame()) <br>        { <br>            PauseGame(); <br>            return FALSE; <br>        } <br>    } <br> <br> <br>    ProcessInput(sInput); <br>    NewGameFrame(); <br>    return TRUE; <br> <br>} /* ProcessFox */ <br> <br>static HFONThFont; <br> <br>DWORD   dwFrameCount; <br>DWORDdwFrameTime; <br>DWORDdwFrames; <br>DWORD   dwFramesLast; <br>SIZE    sizeFPS; <br>SIZEsizeINFO; <br>intFrameRateX; <br>charszFPS[]   = "FPS %02d"; <br>char    szINFO[]  = "%dx%dx%d%s     F6=mode F8=x2 ALT+ENTER=Window"; <br>char    szINFOW[] = "%dx%dx%d%s     F6=mode F8=x2 ALT+ENTER=Fullscreen"; <br> <br>charszFrameRate[128]; <br>charszInfo[128]; <br> <br>COLORREF InfoColor      = RGB(0,152,245); <br>COLORREF FrameRateColor = RGB(255,255,0); <br>COLORREF BackColor= RGB(255,255,255); <br> <br>/* <br> * initNumSurface <br> */ <br>void initNumSurface( void ) <br>{ <br>    HDC        hdc; <br>    RECT        rc; <br>    int         len; <br> <br>    dwFramesLast = 0; <br> <br>    len = wsprintf(szFrameRate, szFPS, 0, 0); <br> <br>    if( lpFrameRate &amp;&amp; IDirectDrawSurface_GetDC(lpFrameRate, &amp;hdc ) == DD_OK ) <br>    { <br>        SelectObject(hdc, hFont); <br>        SetTextColor(hdc, FrameRateColor); <br>        SetBkColor(hdc, BackColor); <br>        SetBkMode(hdc, OPAQUE); <br>        SetRect(&amp;rc, 0, 0, 10000, 10000); <br>        ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &amp;rc, szFrameRate, len, NULL); <br>        GetTextExtentPoint(hdc, szFrameRate, 4, &amp;sizeFPS); <br>        FrameRateX = sizeFPS.cx; <br>        GetTextExtentPoint(hdc, szFrameRate, len, &amp;sizeFPS); <br> <br>        IDirectDrawSurface_ReleaseDC(lpFrameRate, hdc); <br>    } <br> <br>    if (bFullscreen) <br>        len = wsprintf(szInfo, szINFO, <br>                       GameSize.cx, GameSize.cy, GameBPP,bStretch ? " x2" : ""); <br>    else <br>        len = wsprintf(szInfo, szINFOW, <br>                       GameSize.cx, GameSize.cy, GameBPP,bStretch ? " x2" : ""); <br> <br>    if( lpInfo &amp;&amp; IDirectDrawSurface_GetDC(lpInfo, &amp;hdc ) == DD_OK ) <br>    { <br>        SelectObject(hdc, hFont); <br>        SetTextColor(hdc, InfoColor); <br>        SetBkColor(hdc, BackColor); <br>        SetBkMode(hdc, OPAQUE); <br>        SetRect(&amp;rc, 0, 0, 10000, 10000); <br>        ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &amp;rc, szInfo, len, NULL); <br>        GetTextExtentPoint(hdc, szInfo, len, &amp;sizeINFO); <br> <br>        IDirectDrawSurface_ReleaseDC(lpInfo, hdc); <br>    } <br> <br>} /* initNumSurface */ <br> <br>/* <br> * makeFontStuff <br> */ <br>static BOOL makeFontStuff( void ) <br>{ <br>    DDCOLORKEY      ddck; <br>    HDC             hdc; <br> <br>    if (hFont != NULL) <br>    { <br>        DeleteObject(hFont); <br>    } <br> <br>    hFont = CreateFont( <br>        GameSize.cx &lt;= 512 ? 12 : 24, <br>        0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE, <br>        ANSI_CHARSET, <br>        OUT_DEFAULT_PRECIS, <br>        CLIP_DEFAULT_PRECIS, <br>        NONANTIALIASED_QUALITY, // DEFAULT_QUALITY, <br>        VARIABLE_PITCH, <br>        "Arial" ); <br> <br>    /* <br>     * make a sample string so we can measure it with the current font. <br>     */ <br>    if( hFont != NULL) <br>    { <br>        initNumSurface(); <br> <br>        hdc = GetDC(NULL); <br>        SelectObject(hdc, hFont); <br>        GetTextExtentPoint(hdc, szFrameRate, lstrlen(szFrameRate), &amp;sizeFPS); <br>        GetTextExtentPoint(hdc, szInfo, lstrlen(szInfo), &amp;sizeINFO); <br>        ReleaseDC(NULL, hdc); <br>    } <br>    /* <br>     * Create a surface to copy our bits to. <br>     */ <br>    lpFrameRate = DDCreateSurface(sizeFPS.cx, sizeFPS.cy, FALSE,TRUE); <br>    lpInfo = DDCreateSurface(sizeINFO.cx, sizeINFO.cy, FALSE,TRUE); <br> <br>    if( lpFrameRate == NULL || lpInfo == NULL ) <br>    { <br> return FALSE; <br>    } <br> <br>    /* <br>     * now set the color key, we use a totaly different color than <br>     * the rest of the app, just to be different so drivers dont always <br>     * get white or black as the color key... <br>     * <br>     * dont forget when running on a dest colorkey device, we need <br>     * to use the same color key as the rest of the app. <br>     */ <br>    if( bTransDest ) <br>        BackColor = RGB(255,255,255); <br>    else <br>        BackColor = RGB(128,64,255); <br> <br>    ddck.dwColorSpaceLowValue  = DDColorMatch(lpInfo, BackColor); <br>    ddck.dwColorSpaceHighValue = ddck.dwColorSpaceLowValue; <br> <br>    IDirectDrawSurface_SetColorKey( lpInfo, DDCKEY_SRCBLT, &amp;ddck); <br>    IDirectDrawSurface_SetColorKey( lpFrameRate, DDCKEY_SRCBLT, &amp;ddck); <br> <br>    /* <br>     * now draw the text for real <br>     */ <br>    initNumSurface(); <br> <br>    return TRUE; <br>} <br> <br>/* <br> * DisplayFrameRate <br> */ <br>void DisplayFrameRate( void ) <br>{ <br>    DWORD               time2; <br>    char                buff[256]; <br>    HDC                 hdc; <br>    HRESULT             ddrval; <br>    RECT                rc; <br>    DWORD               dw; <br> <br>    if( !bShowFrameCount ) <br>    { <br>        return; <br>    } <br> <br>    dwFrameCount++; <br>    time2 = timeGetTime() - dwFrameTime; <br>    if( time2 &gt; 1000 ) <br>    { <br>        dwFrames = (dwFrameCount*1000)/time2; <br>        dwFrameTime = timeGetTime(); <br>        dwFrameCount = 0; <br> <br>        AveFrameRate += dwFrames; <br>        AveFrameRateCount++; <br>    } <br> <br>    if( dwFrames == 0 ) <br>    { <br>        return; <br>    } <br> <br>    if( dwFrames != dwFramesLast ) <br>    { <br>        dwFramesLast = dwFrames; <br> <br>        if( IDirectDrawSurface_GetDC(lpFrameRate, &amp;hdc ) == DD_OK ) <br>        { <br>            buff[0] = (char)((dwFrames / 10) + '0'); <br>            buff[1] = (char)((dwFrames % 10) + '0'); <br>            if(hFont != NULL) <br>            { <br>                SelectObject(hdc, hFont); <br>                SetTextColor(hdc, FrameRateColor); <br>                SetBkColor(hdc, BackColor); <br>                TextOut(hdc, FrameRateX, 0, buff, 2); <br>            } <br>            IDirectDrawSurface_ReleaseDC(lpFrameRate, hdc); <br>        } <br>    } <br> <br>    /* <br>     * put the text on the back buffer. <br>     */ <br>    if (bTransDest) <br>        dw = DDBLTFAST_DESTCOLORKEY | DDBLTFAST_WAIT; <br>    else <br>        dw = DDBLTFAST_SRCCOLORKEY | DDBLTFAST_WAIT; <br> <br>    SetRect(&amp;rc, 0, 0, sizeFPS.cx, sizeFPS.cy); <br>    ddrval = IDirectDrawSurface_BltFast(lpBackBuffer, <br>           GameRect.left + (GameSize.cx - sizeFPS.cx)/2, GameRect.top + 20, <br>           lpFrameRate, &amp;rc, dw); <br> <br>    SetRect(&amp;rc, 0, 0, sizeINFO.cx, sizeINFO.cy); <br>    ddrval = IDirectDrawSurface_BltFast(lpBackBuffer, <br>           GameRect.left + 10, GameRect.bottom - sizeINFO.cy - 10, <br>           lpInfo, &amp;rc, dw); <br> <br>} /* DisplayFrameRate */ <br> <br>/* <br> * MainWndProc <br> * <br> * Callback for all Windows messages <br> */ <br>long FAR PASCAL MainWndProc( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam ) <br>{ <br>    PAINTSTRUCT ps; <br>    HDC         hdc; <br> <br>    switch( message ) <br>    { <br>    case WM_SIZE: <br>    case WM_MOVE: <br>        if (IsIconic(hWnd)) <br>        { <br>            Msg("FoxBear is minimized, pausing"); <br>            PauseGame(); <br>        } <br> <br>        if (bFullscreen) <br>        { <br>            SetRect(&amp;rcWindow, 0, 0, GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN)); <br>        } <br>        else <br>        { <br>            GetClientRect(hWnd, &amp;rcWindow); <br>            ClientToScreen(hWnd, (LPPOINT)&amp;rcWindow); <br>            ClientToScreen(hWnd, (LPPOINT)&amp;rcWindow+1); <br>        } <br>        Msg("WINDOW RECT: [%d,%d,%d,%d]", rcWindow.left, rcWindow.top, rcWindow.right, rcWindow.bottom); <br>        break; <br> <br>    case WM_ACTIVATEAPP: <br>        bIsActive = (BOOL)wParam &amp;&amp; GetForegroundWindow() == hWnd; <br> <br>        if (bIsActive) <br>            Msg("FoxBear is active"); <br>        else <br>            Msg("FoxBear is not active"); <br> <br>        // <br>        // while we were not-active something bad happened that caused us <br>        // to pause, like a surface restore failing or we got a palette <br>        // changed, now that we are active try to fix things <br>        // <br>        if (bPaused &amp;&amp; bIsActive) <br>        { <br>            if (RestoreGame()) <br>            { <br>                UnPauseGame(); <br>            } <br>            else <br>            { <br>               if (GetForegroundWindow() == hWnd) <br>               { <br>                    // <br>                    //  we are unable to restore, this can happen when <br>                    //  the screen resolution or bitdepth has changed <br>                    //  we just reload all the art again and re-create <br>                    //  the front and back buffers.  this is a little <br>                    //  overkill we could handle a screen res change by <br>                    //  just recreating the front and back buffers we dont <br>                    //  need to redo the art, but this is way easier. <br>                    // <br>                    if (InitGame()) <br>                    { <br>                        UnPauseGame(); <br>                    } <br>                } <br>            } <br>        } <br>        break; <br> <br>    case WM_QUERYNEWPALETTE: <br>        // <br>        //  we are getting the palette focus, select our palette <br>        // <br>        if (!bFullscreen &amp;&amp; lpPalette &amp;&amp; lpFrontBuffer) <br>        { <br>            HRESULT ddrval; <br> <br>            ddrval = IDirectDrawSurface_SetPalette(lpFrontBuffer,lpPalette); <br>            if( ddrval == DDERR_SURFACELOST ) <br>            { <br>                IDirectDrawSurface_Restore( lpFrontBuffer ); <br> <br>                ddrval= IDirectDrawSurface_SetPalette(lpFrontBuffer,lpPalette); <br>                if( ddrval == DDERR_SURFACELOST ) <br>                { <br>                   Msg("  Failed to restore palette after second try"); <br>                } <br>            } <br> <br>            // <br>            // Restore normal title if palette is ours <br>            // <br> <br>            if( ddrval == DD_OK ) <br>            { <br>                SetWindowText( hWnd, OUR_APP_NAME ); <br>            } <br>        } <br>        break; <br> <br>    case WM_PALETTECHANGED: <br>        // <br>        //  if another app changed the palette we dont have full control <br>        //  of the palette. NOTE this only applies for FoxBear in a window <br>        //  when we are fullscreen we get all the palette all of the time. <br>        // <br>        if ((HWND)wParam != hWnd) <br>        { <br>            if( !bFullscreen ) <br>            { <br>                if( !bStress )  <br>                { <br>                    Msg("***** PALETTE CHANGED, PAUSING GAME"); <br>                    PauseGame(); <br>                } <br>                else <br>                { <br>                    Msg("Lost palette but continuing"); <br>                    SetWindowText( hWnd, OUR_APP_NAME  <br>                                 " - palette changed COLORS PROBABLY WRONG" ); <br>                } <br>            } <br>        } <br>        break; <br> <br>    case WM_DISPLAYCHANGE: <br>        break; <br> <br>    case WM_CREATE: <br>        break; <br> <br>    case WM_SETCURSOR: <br>        if (bFullscreen &amp;&amp; bIsActive) <br>        { <br>            SetCursor(NULL); <br>            return TRUE; <br>        } <br>        break; <br> <br>    case WM_SYSKEYUP: <br>        switch( wParam ) <br>        { <br>        // handle ALT+ENTER (fullscreen) <br>        case VK_RETURN: <br>            bFullscreen = !bFullscreen; <br>            ExitGame(); <br>            DDDisable(TRUE);        // destroy DirectDraw object <br>            GameMode.cx = 320; <br>            GameMode.cy = 200; <br>            InitGame(); <br>            break; <br>        } <br>        break; <br>  <br>    case WM_KEYDOWN: <br>        switch( wParam ) <br>        { <br>        case VK_NUMPAD5: <br>            lastInput=KEY_STOP; <br>            break; <br>        case VK_DOWN: <br>        case VK_NUMPAD2: <br>            lastInput=KEY_DOWN; <br>            break; <br>        case VK_LEFT: <br>        case VK_NUMPAD4: <br>            lastInput=KEY_LEFT; <br>            break; <br>        case VK_RIGHT: <br>        case VK_NUMPAD6: <br>            lastInput=KEY_RIGHT; <br>            break; <br>        case VK_UP: <br>        case VK_NUMPAD8: <br>            lastInput=KEY_UP; <br>            break; <br>        case VK_HOME: <br>        case VK_NUMPAD7: <br>            lastInput=KEY_JUMP; <br>            break; <br>        case VK_NUMPAD3: <br>            lastInput=KEY_THROW; <br>            break; <br>        case VK_F5: <br>            bShowFrameCount = !bShowFrameCount; <br>            if( bShowFrameCount ) <br>            { <br>              dwFrameCount = 0; <br>              dwFrameTime = timeGetTime(); <br>            } <br>        break; <br> <br>        case VK_F6: <br>            { <br>            static i; <br>            // <br>            // find our current mode in the mode list <br>            // <br>            if(bFullscreen) <br>            { <br>                for (i=0; i&lt;NumModes; i++) <br>                { <br>                    if (ModeList[i].bpp == (int)GameBPP &amp;&amp; <br>                        ModeList[i].w   == GameSize.cx &amp;&amp; <br>                        ModeList[i].h   == GameSize.cy) <br>                    { <br>                        break; <br>                    } <br>                } <br>            }else <br>            { <br>                for (i=0; i&lt;NumModes; i++) <br>                { <br>                    if (ModeList[i].w   == GameSize.cx &amp;&amp; <br>                        ModeList[i].h   == GameSize.cy) <br>                    { <br>                        break; <br>                    } <br>                } <br>            } <br>            // <br>            // now step to the next mode, wrapping to the first one. <br>            // <br>            if (++i &gt;= NumModes) <br>            { <br>                i = 0; <br>            } <br>            Msg("ModeList %d %d",i,NumModes); <br>            GameMode.cx = ModeList[i].w; <br>            GameMode.cy = ModeList[i].h; <br>            GameBPP     = ModeList[i].bpp; <br>            bStretch    = FALSE; <br>            InitGame(); <br>            } <br>            break; <br>        case VK_F7: <br>            GameBPP = GameBPP == 8 ? 16 : 8; <br>            InitGame(); <br>            break; <br> <br>        case VK_F8: <br>            if (bFullscreen) <br>            { <br>                bStretch = !bStretch; <br>                InitGame(); <br>            } <br>            else <br>            { <br>                RECT rc; <br> <br>                GetClientRect(hWnd, &amp;rc); <br> <br>                bStretch = (rc.right  != GameSize.cx) || <br>                           (rc.bottom != GameSize.cy); <br> <br>                if (bStretch = !bStretch) <br>                    SetRect(&amp;rc, 0, 0, GameMode.cx*2, GameMode.cy*2); <br>                else <br>                    SetRect(&amp;rc, 0, 0, GameMode.cx, GameMode.cy); <br> <br>                AdjustWindowRectEx(&amp;rc, <br>                    GetWindowStyle(hWnd), <br>                    GetMenu(hWnd) != NULL, <br>                    GetWindowExStyle(hWnd)); <br> <br>                SetWindowPos(hWnd, NULL, 0, 0, rc.right-rc.left, rc.bottom-rc.top, <br>                    SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE); <br>            } <br>            break; <br>        case VK_F9: <br>            DevIndex ++; <br>            bUseEmulation = FALSE; <br>            if (DevIndex &gt;= MaxDevIndex) <br>                DevIndex = 0; <br> <br>            ExitGame(); <br>            DDDisable(TRUE);        // destroy DirectDraw object <br>            InitGame(); <br>            break; <br>        case VK_F4: <br>            // treat F4 like ALT+ENTER (fullscreen) <br>            PostMessage(hWnd, WM_SYSKEYUP, VK_RETURN, 0); <br>            break; <br> <br>        case VK_F3: <br>            bPaused = !bPaused; <br>            break; <br> <br>        case VK_ESCAPE: <br>        case VK_F12: <br>            PostMessage(hWnd, WM_CLOSE, 0, 0); <br>            return 0; <br>        } <br>        break; <br> <br>    case WM_PAINT: <br>        hdc = BeginPaint( hWnd, &amp;ps ); <br>        if (bPaused) <br>        { <br>            char *sz = "Game is paused, this is not a bug."; <br>            TextOut(ps.hdc, 0, 0, sz, lstrlen(sz)); <br>        } <br>        EndPaint( hWnd, &amp;ps ); <br>        return 1; <br> <br>    case WM_DESTROY: <br>        hWndMain = NULL; <br>        lastInput=0; <br>        DestroyGame();          // end of game <br>        DDDisable(TRUE);        // destroy DirectDraw object <br>        PostQuitMessage( 0 ); <br>        break; <br>    } <br> <br>    return DefWindowProc(hWnd, message, wParam, lParam); <br> <br>} /* MainWndProc */ <br> <br>/* <br> * initApplication <br> * <br> * Do that Windows initialization stuff... <br> */ <br>static BOOL initApplication( HINSTANCE hInstance, int nCmdShow ) <br>{ <br>    WNDCLASS wc; <br>    BOOL     rc; <br> <br>    wc.style = CS_DBLCLKS; <br>    wc.lpfnWndProc = MainWndProc; <br>    wc.cbClsExtra = 0; <br>    wc.cbWndExtra = 0; <br>    wc.hInstance = hInstance; <br>    wc.hIcon = LoadIcon( hInstance, MAKEINTATOM(FOX_ICON)); <br>    wc.hCursor = LoadCursor( NULL, IDC_ARROW ); <br>    wc.hbrBackground = GetStockObject(BLACK_BRUSH); <br>    wc.lpszMenuName =  NULL; <br>    wc.lpszClassName = "WinFoxClass"; <br>    rc = RegisterClass( &amp;wc ); <br>    if( !rc ) <br>    { <br>        return FALSE; <br>    } <br>     <br> <br>    hWndMain = CreateWindowEx( <br>        WS_EX_APPWINDOW, <br>        "WinFoxClass", <br>        OUR_APP_NAME, <br>        WS_VISIBLE |    // so we dont have to call ShowWindow <br>        WS_SYSMENU |    // so we get a icon in in our tray button <br>        WS_POPUP, <br>        0, <br>        0, <br>        GetSystemMetrics(SM_CXSCREEN), <br>        GetSystemMetrics(SM_CYSCREEN), <br>        NULL, <br>        NULL, <br>        hInstance, <br>        NULL ); <br> <br>    if( !hWndMain ) <br>    { <br>        return FALSE; <br>    } <br> <br>    UpdateWindow( hWndMain ); <br>    SetFocus( hWndMain ); <br> <br>    return TRUE; <br> <br>} /* initApplication */ <br> <br>/* <br> * ExitGame <br> * <br> * Exiting current game, clean up <br> */ <br>void ExitGame( void ) <br>{ <br>    if( lpFrameRate ) <br>    { <br>        IDirectDrawSurface_Release(lpFrameRate); <br>        lpFrameRate = NULL; <br>    } <br> <br>    if( lpInfo ) <br>    { <br>        IDirectDrawSurface_Release(lpInfo); <br>        lpInfo = NULL; <br>    } <br> <br>    if( lpPalette ) <br>    { <br>        IDirectDrawSurface_Release(lpPalette); <br>        lpPalette = NULL; <br>    } <br> <br>    DestroyGame(); <br> <br>} /* ExitGame */ <br> <br>/* <br> * InitGame <br> * <br> * Initializing current game <br> */ <br>BOOL InitGame( void ) <br>{ <br>    ExitGame(); <br> <br>    GameSize = GameMode; <br> <br>    /* <br>     * initialize sound <br>     */ <br>    InitSound( hWndMain ); <br> <br>    /* <br>     * init DirectDraw, set mode, ... <br>     * NOTE GameMode might be set to 640x480 if we cant get the asked for mode. <br>     */ <br>    if( !PreInitializeGame() ) <br>    { <br>        return FALSE; <br>    } <br> <br>    if (bStretch &amp;&amp; bFullscreen) <br>    { <br>        GameSize.cx     = GameMode.cx / 2; <br>        GameSize.cy     = GameMode.cy / 2; <br>        GameRect.left   = GameMode.cx - GameSize.cx; <br>        GameRect.top    = GameMode.cy - GameSize.cy; <br>        GameRect.right  = GameMode.cx; <br>        GameRect.bottom = GameMode.cy; <br> <br>        if (lpStretchBuffer) <br>            Msg("Stretching using a system-memory stretch buffer"); <br>        else <br>            Msg("Stretching using a VRAM-&gt;VRAM blt"); <br>    } <br>    else <br>    { <br>        GameRect.left   = (GameMode.cx - GameSize.cx) / 2; <br>        GameRect.top    = (GameMode.cy - GameSize.cy) / 2; <br>        GameRect.right  = GameRect.left + GameSize.cx; <br>        GameRect.bottom = GameRect.top + GameSize.cy; <br>    } <br> <br>    /* <br>     * setup our palette <br>     */ <br>    if( GameBPP == 8 ) <br>    { <br>        lpPalette = ReadPalFile( NULL );        // create a 332 palette <br> <br>        if( lpPalette == NULL ) <br>        { <br>            Msg( "Palette create failed" ); <br>            return FALSE; <br>        } <br> <br>        IDirectDrawSurface_SetPalette( lpFrontBuffer, lpPalette ); <br>    } <br> <br>    /* <br>     *  load all the art and things. <br>     */ <br>    if( !InitializeGame() ) <br>    { <br>        return FALSE; <br>    } <br> <br>    /* <br>     * init our code to draw the FPS <br>     */ <br>    makeFontStuff(); <br> <br>    /* <br>     * spew some stats <br>     */ <br>    { <br>        DDCAPSddcaps; <br>        ddcaps.dwSize = sizeof( ddcaps ); <br>        IDirectDraw_GetCaps( lpDD, &amp;ddcaps, NULL ); <br>        Msg( "Total=%ld, Free VRAM=%ld", ddcaps.dwVidMemTotal, ddcaps.dwVidMemFree ); <br>        Msg( "Used = %ld", ddcaps.dwVidMemTotal- ddcaps.dwVidMemFree ); <br>    } <br> <br>    return TRUE; <br> <br>} /* InitGame */ <br> <br>#define IS_NUM(c)     ((c) &gt;= '0' &amp;&amp; (c) &lt;= '9') <br>#define IS_SPACE(c)   ((c) == ' ' || (c) == '\r' || (c) == '\n' || (c) == '\t' || (c) == 'x') <br> <br>int getint(char**p, int def) <br>{ <br>    int i=0; <br> <br>    while (IS_SPACE(**p)) <br>        (*p)++; <br> <br>    if (!IS_NUM(**p)) <br>        return def; <br> <br>    while (IS_NUM(**p)) <br>        i = i*10 + *(*p)++ - '0'; <br> <br>    while (IS_SPACE(**p)) <br>        (*p)++; <br> <br>    return i; <br>} <br> <br>/* <br> * WinMain <br> */ <br>int PASCAL WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <br>                    int nCmdShow ) <br>{ <br>    MSGmsg; <br> <br>    DDInit(); <br>    while( lpCmdLine[0] == '-' || lpCmdLine[0] == '/') <br>    { <br>        lpCmdLine++; <br> <br>        switch (*lpCmdLine++) <br>        { <br>        case 'e': <br>            bUseEmulation = TRUE; <br>            break; <br>        case 'w': <br>            bFullscreen = FALSE; <br>            break; <br>        case 'f': <br>            bFullscreen = TRUE; <br>            break; <br>        case '1': <br>            CmdLineBufferCount = 1; <br>            break; <br>        case '2': <br>        case 'd': <br>            CmdLineBufferCount = 2; <br>            break; <br>        case '3': <br>            CmdLineBufferCount = 3; <br>            break; <br>        case 's': <br>            bStretch = TRUE; <br>            break; <br>        case 'S': <br>            bWantSound = FALSE; <br>            break; <br>        case 'x': <br>            bStress= TRUE; <br>            break; <br>        case '?': <br>            bHelp= TRUE; <br>            bFullscreen= FALSE;  // give help in windowed mode <br>            break; <br>        } <br> <br>        while( IS_SPACE(*lpCmdLine) ) <br>        { <br>            lpCmdLine++; <br>        } <br>    } <br> <br>    GameMode.cx = getint(&amp;lpCmdLine, 640); <br>    GameMode.cy = getint(&amp;lpCmdLine, 480); <br>    GameBPP = getint(&amp;lpCmdLine, 8); <br> <br>    /* <br>     * create window and other windows things <br>     */ <br>    if( !initApplication(hInstance, nCmdShow) ) <br>    { <br>        return FALSE; <br>    } <br> <br>    /* <br>     * Give user help if asked for <br>     * <br>     * This is ugly for now because the whole screen is black <br>     * except for the popup box.  This could be fixed with some <br>     * work to get the window size right when it was created instead <br>     * of delaying that work. see ddraw.c <br>     * <br>     */ <br> <br>    if( bHelp ) <br>    { <br>        MessageBox(hWndMain, <br>                   "F12 - Quit\n" <br>                   "NUMPAD 2  - crouch\n" <br>                   "NUMPAD 3  - apple\n" <br>                   "NUMPAD 4  - right\n" <br>                   "NUMPAD 5  - stop\n" <br>                   "NUMPAD 6  - left\n" <br>                   "NUMPAD 7  - jump\n" <br>                   "\n" <br>                   "Command line parameters\n" <br>                   "\n" <br>                    "-e   Use emulator\n" <br>                    "-S   No Sound\n" <br>                    "-1   No backbuffer\n" <br>                    "-2   One backbuffer\n" <br>                    "-4   Three backbuffers\n" <br>                    "-s   Use stretch\n" <br>                    "-x   Demo or stress mode\n", <br>                   OUR_APP_NAME, MB_OK ); <br>    } <br> <br>    /* <br>     * initialize for game play <br>     */ <br> <br>    if( !InitGame() ) <br>    { <br>        return FALSE; <br>    } <br>    dwFrameTime = timeGetTime(); <br>    <br>    while( 1 ) <br>    { <br>        if (PeekMessage( &amp;msg, NULL, 0, 0, PM_NOREMOVE)) <br>        { <br>            if (!GetMessage( &amp;msg, NULL, 0, 0)) <br>            {  <br>                break; <br>            } <br>            TranslateMessage(&amp;msg);  <br>            DispatchMessage(&amp;msg); <br>        } <br>        else if (!bPaused &amp;&amp; (bIsActive || !bFullscreen)) <br>        { <br>            ProcessFox(lastInput); <br>            lastInput=0; <br>        } <br>        else <br>        { <br>            WaitMessage(); <br>        } <br>    } <br> <br>    if (AveFrameRateCount) <br>    { <br>        AveFrameRate = AveFrameRate / AveFrameRateCount; <br>        Msg("Average frame rate: %d", AveFrameRate); <br>    } <br> <br>    return msg.wParam; <br> <br>} /* WinMain */ <br> <br>#ifdef DEBUG <br> <br>/* <br> * Msg <br> */ <br>void __cdecl Msg( LPSTR fmt, ... ) <br>{ <br>    char    buff[256]; <br>    va_list  va; <br> <br>    va_start(va, fmt); <br> <br>    // <br>    // format message with header <br>    // <br> <br>    lstrcpy( buff, "FOXBEAR:" ); <br>    wvsprintf( &amp;buff[lstrlen(buff)], fmt, va ); <br>    lstrcat( buff, "\r\n" ); <br> <br>    // <br>    // To the debugger unless we need to be quiet <br>    // <br> <br>    if( !bStress ) <br>    { <br>        OutputDebugString( buff ); <br>    } <br> <br>} /* Msg */ <br> <br>#endif </code></pre>
<p>&nbsp;</p></body>
</HTML>
