<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GFX.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3207"></a>GFX.C</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1995-1997 Microsoft Corporation. All Rights Reserved. <br> *  Copyright (C) 1994-1995 ATI Technologies Inc. All Rights Reserved. <br> * <br> *  File:gfx.c <br> *  Content:graphics API <br> * <br> ***************************************************************************/ <br>#include "foxbear.h" <br> <br>GFX_BITMAP  *lpVRAM; <br> <br>static BOOL fForceRestore = FALSE; <br> <br>/* <br> * gfxBlt <br> */ <br>BOOL gfxBlt(RECT *dst, GFX_HBM bm, POINT *src) <br>{ <br>    GFX_BITMAP* pbm = (GFX_BITMAP*)bm; <br>    HRESULT     ddrval; <br>    DWORD       bltflags; <br>    RECT        rc; <br>    int         x,y,dx,dy; <br> <br>    if( GameSize.cy == C_SCREEN_H ) <br>    { <br>        y         = dst-&gt;top; <br>        dy        = dst-&gt;bottom - dst-&gt;top; <br>        rc.top    = src-&gt;y; <br>        rc.bottom = rc.top  + dy; <br>    } <br>    else <br>    { <br>        y         = MapY(dst-&gt;top); <br>        dy        = MapY(dst-&gt;bottom) - y; <br>        rc.top    = MapDY(src-&gt;y); <br>        rc.bottom = rc.top  + dy; <br>    } <br> <br>    if( GameSize.cx == C_SCREEN_W ) <br>    { <br>        x         = dst-&gt;left; <br>        dx        = dst-&gt;right  - dst-&gt;left; <br>        rc.left   = src-&gt;x; <br>        rc.right  = rc.left + dx; <br>    } <br>    else <br>    { <br>        x         = MapX(dst-&gt;left); <br>        dx        = MapX(dst-&gt;right) - x; <br>        rc.left   = MapDX(src-&gt;x); <br>        rc.right  = rc.left + dx; <br>    } <br> <br> <br>    if( dx == 0 || dy == 0 ) <br>    { <br>        return TRUE; <br>    } <br> <br>    if (pbm-&gt;lpSurface) <br>    { <br>        if( pbm-&gt;bTrans ) <br>            bltflags = bTransDest ? DDBLTFAST_DESTCOLORKEY : DDBLTFAST_SRCCOLORKEY; <br>        else <br>            bltflags = bTransDest ? DDBLTFAST_DESTCOLORKEY : DDBLTFAST_NOCOLORKEY; <br>        ddrval = IDirectDrawSurface_BltFast( <br>                        lpBackBuffer, x, y, <br>                        pbm-&gt;lpSurface, &amp;rc, bltflags | DDBLTFAST_WAIT); <br> <br>        if (ddrval != DD_OK) <br>        { <br>            Msg("BltFast failed err=%d", ddrval); <br>        } <br>    } <br>    else <br>    { <br>        DDBLTFX     ddbltfx; <br> <br>        rc.left   = x; <br>        rc.top    = y; <br>        rc.right  = rc.left + dx; <br>        rc.bottom = rc.top  + dy; <br> <br>        ddbltfx.dwSize = sizeof( ddbltfx ); <br>        ddbltfx.dwFillColor = pbm-&gt;dwColor; <br> <br>        ddrval = IDirectDrawSurface_Blt( <br>                        lpBackBuffer,           // dest surface <br>                        &amp;rc,                    // dest rect <br>                        NULL,                   // src surface <br>                        NULL,                   // src rect <br>                        DDBLT_COLORFILL | DDBLT_WAIT, <br>                        &amp;ddbltfx); <br>    } <br> <br>    return TRUE; <br> <br>} /* gfxBlt */ <br> <br>/* <br> * gfxCreateSolidColorBitmap <br> */ <br>GFX_HBM gfxCreateSolidColorBitmap(COLORREF rgb) <br>{ <br>    GFX_BITMAP *pvram; <br> <br>    pvram = MemAlloc( sizeof( *pvram ) ); <br> <br>    if( pvram == NULL ) <br>    { <br>return NULL; <br>    } <br> <br>    pvram-&gt;dwColor = DDColorMatch(lpBackBuffer, rgb); <br>    pvram-&gt;lpSurface = NULL; <br>    pvram-&gt;lpbi = NULL; <br>    pvram-&gt;bTrans = FALSE; <br> <br>    pvram-&gt;link = lpVRAM; <br>    lpVRAM = pvram; <br> <br>    return (GFX_HBM) pvram; <br> <br>} /* gfxCreateSolidColorBitmap */ <br> <br>/* <br> * gfxCreateBitmap <br> */ <br>GFX_HBM gfxCreateVramBitmap(BITMAPINFOHEADER UNALIGNED *lpbi,BOOL bTrans) <br>{ <br>    GFX_BITMAP *pvram; <br> <br>    pvram = MemAlloc( sizeof( *pvram ) ); <br> <br>    if( pvram == NULL ) <br>    { <br>return NULL; <br>    } <br>    pvram-&gt;lpSurface = DDCreateSurface(MapRX(lpbi-&gt;biWidth), <br>                                       MapRY(lpbi-&gt;biHeight), FALSE, TRUE); <br>    pvram-&gt;lpbi = lpbi; <br>    pvram-&gt;dwColor = 0; <br>    pvram-&gt;bTrans = bTrans; <br> <br>    if( pvram-&gt;lpSurface == NULL ) <br>    { <br>return NULL; <br>    } <br> <br>    pvram-&gt;link = lpVRAM; <br>    lpVRAM = pvram; <br>    gfxRestore((GFX_HBM) pvram); <br> <br>    return (GFX_HBM) pvram; <br> <br>} /* gfxCreateVramBitmap */ <br> <br>/* <br> * gfxDestroyBitmap <br> */ <br>BOOL gfxDestroyBitmap ( GFX_HBM hbm ) <br>{ <br>    GFX_BITMAP *p = (GFX_BITMAP *)hbm; <br> <br>    if (hbm == NULL || hbm == GFX_TRUE) <br>    { <br>return FALSE; <br>    } <br> <br>    if (p-&gt;lpSurface) <br>    { <br>        IDirectDrawSurface_Release(p-&gt;lpSurface); <br>        p-&gt;lpSurface = NULL; <br>    } <br> <br>    if (p-&gt;lpbi) <br>    { <br>        p-&gt;lpbi = NULL; <br>    } <br> <br>    MemFree((VOID *)p); <br> <br>    return TRUE; <br> <br>} /* gfxDestroyBitmap */ <br> <br>/* <br> * gfxStretchBackBuffer() <br> */ <br>BOOL gfxStretchBackbuffer() <br>{ <br>    if (lpStretchBuffer) <br>    { <br>        IDirectDrawSurface_Blt( <br>                            lpStretchBuffer,        // dest surface <br>                            NULL,                   // dest rect (all of it) <br>                            lpBackBuffer,           // src surface <br>                            &amp;GameRect,              // src rect <br>                            DDBLT_WAIT, <br>                            NULL); <br> <br>        IDirectDrawSurface_Blt( <br>                            lpBackBuffer,           // dest surface <br>                            NULL,                   // dest rect (all of it) <br>                            lpStretchBuffer,        // src surface <br>                            NULL,                   // src rect <br>                            DDBLT_WAIT, <br>                            NULL); <br>    } <br>    else <br>    { <br>        IDirectDrawSurface_Blt( <br>                        lpBackBuffer,           // dest surface <br>                        NULL,                   // dest rect (all of it) <br>                        lpBackBuffer,           // src surface <br>                        &amp;GameRect,              // src rect <br>                        DDBLT_WAIT, <br>                        NULL); <br>    } <br> <br>    return TRUE; <br> <br>} /* gfxStretchBackbuffer */ <br> <br>/* <br> * gfxFlip <br> */ <br>BOOL gfxFlip( void ) <br>{ <br>    HRESULT     ddrval; <br> <br>    ddrval = IDirectDrawSurface_Flip( lpFrontBuffer, NULL, DDFLIP_WAIT ); <br>    if( ddrval != DD_OK ) <br>    { <br>Msg( "Flip FAILED, rc=%08lx", ddrval ); <br>return FALSE; <br>    } <br>    return TRUE; <br> <br>} /* gfxFlip */ <br> <br>/* <br> * gfxUpdateWindow <br> */ <br>BOOL gfxUpdateWindow() <br>{ <br>    HRESULT     ddrval; <br> <br>    ddrval = IDirectDrawSurface_Blt( <br>                    lpFrontBuffer,          // dest surface <br>                    &amp;rcWindow,              // dest rect <br>                    lpBackBuffer,           // src surface <br>                    NULL,                   // src rect (all of it) <br>                    DDBLT_WAIT, <br>                    NULL); <br> <br>    return ddrval == DD_OK; <br> <br>} /* gfxUpdateWindow */ <br> <br>/* <br> * gfxSwapBuffers <br> * <br> * this is called when the game loop has rendered a frame into <br> * the backbuffer, its goal is to display something for the user to see. <br> * <br> * there are four cases... <br> * <br> * Fullscreen: <br> *      we just call IDirectDrawSurface::Flip(lpFrontBuffer) <br> *      being careful to handle return code right. <br> * <br> * Fullscreen (stretched): <br> *      the game loop has rendered a frame 1/2 the display <br> *      size, we do a Blt to stretch the frame to the backbuffer <br> *      the we just call IDirectDrawSurface::Flip(lpFrontBuffer) <br> * <br> * Window mode (foreground palette): <br> *      in this case we call IDirectDrawSurface::Blt to copy <br> *      the back buffer to the window. <br> * <br> * Window mode (background palette): <br> *      in this case we are in a window, but we dont own the <br> *      palette. all our art was loaded to a specific palette <br> *      IDirectDrawSurface::Blt does not do color translation <br> *      we have a few options in this case... <br> * <br> *          reload or remap the art to the the current palette <br> *          (we can do this easily with a GetDC, StetchDIBits) <br> *          FoxBear has *alot* of art, so this would be too slow. <br> * <br> *          use GDI to draw the backbuffer, GDI will handle <br> *          the color conversion so things will look correct. <br> * <br> *          pause the game (this is what we do so this function <br> *          will never be called) <br> * <br> */ <br>BOOL gfxSwapBuffers( void ) <br>{ <br>    if( bFullscreen ) <br>    { <br>        if( bStretch ) <br>{ <br>            gfxStretchBackbuffer(); <br>} <br> <br>        if (nBufferCount &gt; 1) <br>            return gfxFlip(); <br>        else <br>            return TRUE; <br>    } <br>    else <br>    { <br>        return gfxUpdateWindow(); <br>    } <br> <br>} /* gfxSwapBuffers */ <br> <br>/* <br> * gfxBegin <br> */ <br>GFX_HBM gfxBegin( void ) <br>{ <br>    if( !DDEnable() ) <br>    { <br>return NULL; <br>    } <br> <br>    if( !DDCreateFlippingSurface() ) <br>    { <br>        DDDisable(TRUE); <br>return NULL; <br>    } <br>    Splash(); <br> <br>    return GFX_TRUE; <br> <br>} /* gfxBegin */ <br> <br>/* <br> * gfxEnd <br> */ <br>BOOL gfxEnd ( GFX_HBM hbm ) <br>{ <br>    GFX_BITMAP  *curr; <br>    GFX_BITMAP  *next; <br> <br>    for( curr = lpVRAM; curr; curr=next ) <br>    { <br>        next = curr-&gt;link; <br>        gfxDestroyBitmap ((GFX_HBM)curr); <br>    } <br> <br>    lpVRAM = NULL; <br> <br>    return DDDisable(FALSE); <br> <br>    return TRUE; <br> <br>} /* gfxEnd */ <br> <br>/* <br> * gfxRestore <br> * <br> * restore the art when one or more surfaces are lost <br> */ <br>BOOL gfxRestore(GFX_HBM bm) <br>{ <br>    GFX_BITMAP *pbm = (GFX_BITMAP*)bm; <br>    HRESULT     ddrval; <br>    HDC hdc; <br>    LPVOID lpBits; <br>    RGBQUAD *prgb; <br>    int i,w,h; <br>    RECT rc; <br> <br>    struct { <br>        BITMAPINFOHEADER bi; <br>        RGBQUAD          ct[256]; <br>    }   dib; <br> <br>    IDirectDrawSurface *pdds = pbm-&gt;lpSurface; <br>    BITMAPINFOHEADER   UNALIGNED *pbi  = pbm-&gt;lpbi; <br> <br>    if (pdds == NULL) <br>        return TRUE; <br> <br>    if (IDirectDrawSurface_Restore(pdds) != DD_OK) <br>        return FALSE; <br> <br>    if (pbi == NULL) <br>        return TRUE; <br> <br>    // <br>    // in 8bbp mode if we get switched away from while loading <br>    // (and palette mapping) our art, the colors will not be correct <br>    // because some app may have changed the system palette. <br>    // <br>    // if we are in stress mode, just keep going.  It is more important <br>    // to make progress than to get the colors right. <br>    // <br> <br>    if (!bFullscreen &amp;&amp; <br>         GameBPP == 8 &amp;&amp;  <br>         GetForegroundWindow() != hWndMain &amp;&amp;  <br>         !bStress ) <br>    { <br>        Msg("gfxRestore: **** foreground window changed while loading art!"); <br>        fForceRestore = TRUE; <br>        PauseGame(); <br>        return FALSE; <br>    } <br> <br>    dib.bi = *pbi; <br> <br>    prgb = (RGBQUAD *)((LPBYTE)pbi + pbi-&gt;biSize); <br>    lpBits = (LPBYTE)(prgb + pbi-&gt;biClrUsed); <br> <br>    if( pbi-&gt;biClrUsed == 0 &amp;&amp; pbi-&gt;biBitCount &lt;= 8 ) <br>    { <br>        lpBits = (LPBYTE)(prgb + (1&lt;&lt;pbi-&gt;biBitCount)); <br>    } <br> <br>    w = MapRX(pbi-&gt;biWidth); <br>    h = MapRY(pbi-&gt;biHeight); <br>    /* <br>     * hack to make sure fox off-white doesn't become <br>     * pure white (which is transparent) <br>     */ <br>    for( i=0; i&lt;256; i++ ) <br>    { <br>        dib.ct[i] = prgb[i]; <br> <br>        if( dib.ct[i].rgbRed   == 0xff &amp;&amp; <br>            dib.ct[i].rgbGreen == 0xff &amp;&amp; <br>            dib.ct[i].rgbBlue  == 224 ) <br>        { <br>            dib.ct[i].rgbBlue = 0x80; <br>        } <br>        else <br>        if( dib.ct[i].rgbRed   == 251 &amp;&amp; <br>            dib.ct[i].rgbGreen == 243 &amp;&amp; <br>            dib.ct[i].rgbBlue  == 234 ) <br>        { <br>            dib.ct[i].rgbBlue = 0x80; <br>        } <br>    } <br> <br>    /* <br>     * if we are in 8bit mode we know the palette is 332 we can <br>     * do the mapping our self. <br>     * <br>     * NOTE we can only do this in fullscreen mode <br>     * in windowed mode, we have to share the palette with <br>     * the window manager and we dont get all of the colors <br>     * in the order we assume. <br>     * <br>     */ <br>    if (bFullscreen &amp;&amp; GameBPP == pbi-&gt;biBitCount &amp;&amp; GameBPP == 8 ) <br>    { <br>        BYTE xlat332[256]; <br>        DDSURFACEDESC ddsd; <br>        int x,y,dib_pitch; <br>        BYTE *src, *dst; <br>        BOOL stretch; <br>        IDirectDrawSurface *pdds1; <br>        HDC hdc1; <br> <br>        stretch = w != pbi-&gt;biWidth || h != pbi-&gt;biHeight; <br> <br>        for( i=0;i&lt;256;i++ ) <br>        { <br>            xlat332[i] = <br>                ((dib.ct[i].rgbRed   &gt;&gt; 0) &amp; 0xE0 ) | <br>                ((dib.ct[i].rgbGreen &gt;&gt; 3) &amp; 0x1C ) | <br>                ((dib.ct[i].rgbBlue  &gt;&gt; 6) &amp; 0x03 ); <br>        } <br> <br>        /* <br>         * if we are stretching copy into the back buffer <br>         * then use GDI to stretch later. <br>         */ <br>        if( stretch ) <br>{ <br>            pdds1 = lpBackBuffer; <br>} <br>        else <br>{ <br>            pdds1 = pdds; <br>} <br> <br>        ddsd.dwSize = sizeof(ddsd); <br>        ddrval = IDirectDrawSurface_Lock( <br>            pdds1, NULL, &amp;ddsd, DDLOCK_WAIT, NULL); <br> <br>        if( ddrval == DD_OK ) <br>        { <br>            dib_pitch = (pbi-&gt;biWidth+3)&amp;~3; <br>            src = (BYTE *)lpBits + dib_pitch * (pbi-&gt;biHeight-1); <br>            dst = (BYTE *)ddsd.lpSurface; <br>            for( y=0; y&lt;(int)pbi-&gt;biHeight; y++ ) <br>            { <br>                for( x=0; x&lt;(int)pbi-&gt;biWidth; x++ ) <br>                { <br>                    dst[x] = xlat332[src[x]]; <br>                } <br>                dst += ddsd.lPitch; <br>                src -= dib_pitch; <br>            } <br>            IDirectDrawSurface_Unlock(pdds1, NULL); <br>        } <br>        else <br>        { <br>            Msg("Lock failed err=%d", ddrval); <br>            return FALSE; <br>        } <br> <br>        if( stretch ) <br>        { <br>            if( IDirectDrawSurface_GetDC(pdds,&amp;hdc) == DD_OK ) <br>            { <br>                if( IDirectDrawSurface_GetDC(pdds1,&amp;hdc1) == DD_OK ) <br>                { <br>    SetStretchBltMode(hdc, COLORONCOLOR); <br>                    StretchBlt(hdc, 0, 0, w, h, <br>                        hdc1, 0, 0, pbi-&gt;biWidth, pbi-&gt;biHeight, SRCCOPY); <br>                    IDirectDrawSurface_ReleaseDC(pdds1,hdc1); <br>                } <br>                IDirectDrawSurface_ReleaseDC(pdds,hdc); <br>            } <br>        } <br>    } <br>    else if( IDirectDrawSurface_GetDC(pdds,&amp;hdc) == DD_OK ) <br>    { <br>        SetStretchBltMode(hdc, COLORONCOLOR); <br>        StretchDIBits(hdc, 0, 0, w, h, <br>            0, 0, pbi-&gt;biWidth, pbi-&gt;biHeight, <br>            lpBits, (BITMAPINFO *)&amp;dib.bi, DIB_RGB_COLORS, SRCCOPY); <br> <br>        IDirectDrawSurface_ReleaseDC(pdds,hdc); <br>    } <br> <br>    /* <br>     * show the art while loading... <br>     */ <br>    rc.left = rcWindow.left, <br>    rc.top  = rcWindow.top + 20; <br>    rc.right = rc.left + w; <br>    rc.bottom = rc.top + h; <br>    IDirectDrawSurface_Blt(lpFrontBuffer, &amp;rc, pdds, NULL, DDBLT_WAIT, NULL); <br> <br>    return TRUE; <br> <br>} /* gfxRestore */ <br> <br>/* <br> * gfxRestoreAll <br> * <br> * restore the art when one or more surfaces are lost <br> */ <br>BOOL gfxRestoreAll() <br>{ <br>    GFX_BITMAP  *curr; <br>    HWND hwndF = GetForegroundWindow(); <br> <br>    Splash(); <br> <br>    for( curr = lpVRAM; curr != NULL; curr = curr-&gt;link) <br>    { <br>if (curr-&gt;lpSurface &amp;&amp; <br>    (fForceRestore || IDirectDrawSurface_IsLost(curr-&gt;lpSurface) == DDERR_SURFACELOST)) <br>        { <br>            if( !gfxRestore(curr) ) <br>            { <br>                Msg( "gfxRestoreAll: ************ Restore FAILED!" ); <br>                return FALSE; <br>            } <br>        } <br>    } <br> <br>    DDClear(); <br>    fForceRestore = FALSE; <br>    return TRUE; <br> <br>} /* gfxRestoreAll */ <br> <br>/* <br> * gfxFillBack <br> */ <br>void gfxFillBack( DWORD dwColor ) <br>{ <br>    DDBLTFXddbltfx; <br> <br>    ddbltfx.dwSize = sizeof( ddbltfx ); <br>    ddbltfx.dwFillColor = dwColor; <br> <br>    IDirectDrawSurface_Blt( <br>lpBackBuffer,// dest surface <br>NULL,// dest rect <br>NULL,// src surface <br>NULL,// src rect <br>                        DDBLT_COLORFILL | DDBLT_WAIT, <br>                        &amp;ddbltfx); <br> <br>} /* gfxFillBack */ </code></pre>
<p>&nbsp;</p></body>
</HTML>
