<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DDRAW.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3200"></a>DDRAW.C</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1995-1997 Microsoft Corporation. All Rights Reserved. <br> *  Copyright (C) 1994-1995 ATI Technologies Inc. All Rights Reserved. <br> * <br> *  File:ddraw.c <br> *  Content:Misc. Direct Draw access routines <br> * <br> ***************************************************************************/ <br>#include "foxbear.h" <br> <br>typedef struct { <br>    GUID *guid; <br>    GUID DriverGUID; <br>    CHAR DriverDesc[128]; <br>    CHAR DriverName[128]; <br>} Devices; <br> <br>Devices aDDDevs[15]; <br>int     MaxDevIndex = 0; <br>int     DevIndex = 0; <br> <br>BOOL    bUseEmulation; <br>BOOL    bUseSysMem; <br>int     nBufferCount; <br>int     CmdLineBufferCount; <br>BOOLbTransDest; <br>BOOL    bColorFill; <br> <br>HRESULT CALLBACK EnumDisplayModesCallback(LPDDSURFACEDESC pddsd, LPVOID Context); <br> <br>HRESULT CALLBACK DDEnumCallback(GUID * lpGUID, LPSTR DRiverDesc, LPSTR DriverName, LPVOID lpContext); <br> <br>/* <br> * DDInit <br> */ <br>BOOL DDInit( void ) <br>{ <br>    DirectDrawEnumerate(&amp;DDEnumCallback,NULL); <br>    DDEnumCallback((GUID *)DDCREATE_EMULATIONONLY, "Hardware Emulation Layer", "", NULL); <br>    return TRUE; <br>} <br>/* <br> * DDEnable <br> */ <br>BOOL DDEnable( void ) <br>{ <br>    LPDIRECTDRAWlpdd; <br>    LPDIRECTDRAW2   lpdd2; <br>    DDCAPS              ddcaps; <br>    HRESULTddrval; <br>    BOOLuse_dest; <br>OSVERSIONINFO osv; <br> <br>osv.dwOSVersionInfoSize = sizeof(OSVERSIONINFO); <br>// <br>//What are we running on ? <br>// <br>GetVersionEx(&amp;osv); <br> <br> <br>    nBufferCount = GetProfileInt( "FoxBear", "buffers", CmdLineBufferCount); <br>    bUseEmulation = GetProfileInt( "FoxBear", "use_emulation", bUseEmulation); <br>    bUseSysMem = GetProfileInt( "FoxBear", "sysmem", 0); <br>    use_dest = GetProfileInt( "FoxBear", "use_dest", 0 ); <br> <br>    if ((lpDD == NULL) || (lpDD2 == NULL)) <br>    { <br>        if( bUseEmulation) <br>            DevIndex = MaxDevIndex-1; <br>        ddrval = DirectDrawCreate(aDDDevs[DevIndex].guid,&amp;lpdd,NULL); <br>        if(ddrval == DD_OK) <br>        { <br>            ddrval = IDirectDraw_QueryInterface(lpdd, &amp;IID_IDirectDraw2, &amp;lpdd2); <br>        } <br>    } <br>    else <br>    { <br>        lpdd = lpDD; <br>        lpdd2 = lpDD2; <br>        ddrval = DD_OK; <br>    } <br> <br>    if( ddrval != DD_OK ) <br>    { <br>        Msg("DirectDrawCreate failed err=%d", ddrval); <br>        goto error; <br>    } <br> <br>    /* <br>     * grab exclusive mode if we are going to run as fullscreen <br>     * otherwise grab normal mode. <br>     */ <br>    if (lpDD == NULL) <br>    { <br>NumModes = 0; <br> <br>        if (bFullscreen) <br>        { <br>            ddrval = IDirectDraw_SetCooperativeLevel( lpdd, hWndMain, <br>                            DDSCL_ALLOWMODEX | <br>                            DDSCL_EXCLUSIVE | <br>    DDSCL_FULLSCREEN ); <br> <br>            ddrval = IDirectDraw_EnumDisplayModes(lpdd, DDEDM_STANDARDVGAMODES, NULL, 0, EnumDisplayModesCallback); <br>            if(ddrval != DD_OK) <br>            { <br>    ddrval = IDirectDraw_EnumDisplayModes(lpdd, 0, NULL, 0, EnumDisplayModesCallback); <br>            }; <br>} <br> <br> <br>        else <br>        { <br>            ddrval = IDirectDraw_SetCooperativeLevel( lpdd, hWndMain, <br>    DDSCL_NORMAL ); <br> <br>    // in normal windowed mode, just add some "stock" window <br>    // sizes <br> <br>    ModeList[NumModes].w = 320; <br>    ModeList[NumModes].h = 200; <br>    NumModes++; <br> <br>    ModeList[NumModes].w = 320; <br>    ModeList[NumModes].h = 240; <br>    NumModes++; <br> <br>    ModeList[NumModes].w = 512; <br>    ModeList[NumModes].h = 384; <br>    NumModes++; <br> <br>    ModeList[NumModes].w = 640; <br>    ModeList[NumModes].h = 400; <br>    NumModes++; <br> <br>    ModeList[NumModes].w = 640; <br>    ModeList[NumModes].h = 480; <br>    NumModes++; <br>        } <br> <br>        if( ddrval != DD_OK ) <br>        { <br>            Msg("SetCooperativeLevel failed err=%d", ddrval); <br>            goto error; <br>        } <br>    } <br> <br>    if (bFullscreen) <br>    { <br>        Msg("SetDisplayMode %d %d %d",GameMode.cx,GameMode.cy, GameBPP); <br>        if((GameMode.cx == 320) &amp;&amp; (GameMode.cy == 200) &amp;&amp; (GameBPP == 8)) <br>        { <br>            ddrval = IDirectDraw2_SetDisplayMode(lpdd2, GameMode.cx, GameMode.cy, GameBPP,0,DDSDM_STANDARDVGAMODE); <br>        } else { <br>            ddrval = IDirectDraw_SetDisplayMode( lpdd, GameMode.cx, GameMode.cy, GameBPP); <br>        } <br> <br>        if (ddrval != DD_OK &amp;&amp; (GameMode.cx != 640 || GameMode.cy != 480)) <br>        { <br>            Msg( "cant set mode trying 640x480" ); <br> <br>            GameMode.cx = 640; <br>            GameMode.cy = 480; <br>    GameSize = GameMode; <br> <br>            ddrval = IDirectDraw_SetDisplayMode( lpdd, <br>                GameMode.cx, GameMode.cy, GameBPP); <br>        } <br> <br>        if (ddrval != DD_OK &amp;&amp; GameBPP != 8) <br>        { <br>            Msg( "cant set mode trying 640x480x8" ); <br> <br>            GameBPP = 8; <br> <br>            ddrval = IDirectDraw_SetDisplayMode( lpdd, <br>                GameMode.cx, GameMode.cy, GameBPP); <br>        } <br> <br>        if (ddrval != DD_OK &amp;&amp; GameBPP != 16) <br>        { <br>            Msg( "cant set mode trying 640x480x16" ); <br> <br>            GameBPP = 16; <br> <br>            ddrval = IDirectDraw_SetDisplayMode( lpdd, <br>                GameMode.cx, GameMode.cy, GameBPP); <br>        } <br> <br>        if( ddrval != DD_OK ) <br>        { <br>            Msg("SetMode failed err=%d", ddrval); <br>            goto error; <br>        } <br>    } <br>    else <br>    { <br>        RECT rcWork; <br>        RECT rc; <br>        HDC hdc; <br>        DWORD dwStyle; <br> <br>        // <br>        //  when in rome (I mean when in windows) we should use the <br>        //  current mode <br>        // <br>        hdc = GetDC(NULL); <br>        GameBPP = GetDeviceCaps(hdc, PLANES) * GetDeviceCaps(hdc, BITSPIXEL); <br>        ReleaseDC(NULL, hdc); <br> <br>        // <br>        // if we are still a WS_POPUP window we should convert to a <br>        // normal app window so we look like a windows app. <br>        // <br>        dwStyle = GetWindowStyle(hWndMain); <br>        dwStyle &amp;= ~WS_POPUP; <br>        dwStyle |= WS_OVERLAPPED | WS_CAPTION | WS_THICKFRAME | WS_MINIMIZEBOX; <br>        SetWindowLong(hWndMain, GWL_STYLE, dwStyle); <br> <br>        if (bStretch) <br>            SetRect(&amp;rc, 0, 0, GameMode.cx*2, GameMode.cy*2); <br>        else <br>            SetRect(&amp;rc, 0, 0, GameMode.cx, GameMode.cy); <br> <br>        AdjustWindowRectEx(&amp;rc, <br>            GetWindowStyle(hWndMain), <br>            GetMenu(hWndMain) != NULL, <br>            GetWindowExStyle(hWndMain)); <br> <br>        SetWindowPos(hWndMain, NULL, 0, 0, rc.right-rc.left, rc.bottom-rc.top, <br>            SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE); <br> <br>        SetWindowPos(hWndMain, HWND_NOTOPMOST, 0, 0, 0, 0, <br>            SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE); <br> <br>        // <br>        //  make sure our window does not hang outside of the work area <br>        //  this will make people who have the tray on the top or left <br>        //  happy. <br>        // <br>        SystemParametersInfo(SPI_GETWORKAREA, 0, &amp;rcWork, 0); <br>        GetWindowRect(hWndMain, &amp;rc); <br>        if (rc.left &lt; rcWork.left) rc.left = rcWork.left; <br>        if (rc.top  &lt; rcWork.top)  rc.top  = rcWork.top; <br>        SetWindowPos(hWndMain, NULL, rc.left, rc.top, 0, 0, <br>            SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE); <br>    } <br> <br>    /* <br>     * check capabilites <br>     */ <br>    ddcaps.dwSize = sizeof( ddcaps ); <br>    ddrval = IDirectDraw_GetCaps( lpdd, &amp;ddcaps, NULL ); <br> <br>    if( ddrval != DD_OK ) <br>    { <br>        Msg("GetCaps failed err=%d", ddrval); <br>        goto error; <br>    } <br> <br>    if( ddcaps.dwCaps &amp; DDCAPS_NOHARDWARE ) <br>    { <br>        Msg( "No hardware support at all" ); <br>    } <br> <br>    if( ddcaps.dwCaps &amp; DDCAPS_BLTCOLORFILL ) <br>    { <br>        bColorFill = TRUE; <br>        Msg( "Device supports color fill" ); <br>    } <br>    else <br>    { <br>        bColorFill = FALSE; <br>        Msg( "Device does not support color fill" ); <br>    } <br> <br>    /* <br>     * default to double buffered on 1mb, triple buffered <br>     * on &gt; 1mb <br>     */ <br>    if (nBufferCount == 0) <br>    { <br>        if( ddcaps.dwVidMemTotal &lt;= 1024L*1024L*(GameBPP/8) || <br>            GameMode.cx &gt; 640 ) <br>        { <br>            Msg("double buffering (not enough memory)"); <br>            nBufferCount = 2; <br>        } <br>        else <br>        { <br>            Msg("triple buffering"); <br>            nBufferCount = 3; <br>        } <br>    } <br> <br>    if( ddcaps.dwCaps &amp; DDCAPS_COLORKEY ) <br>    { <br>        if( ddcaps.dwCKeyCaps &amp; DDCKEYCAPS_SRCBLT ) <br>        { <br>            Msg( "Can do Src colorkey in hardware" ); <br>        } <br> <br>        if( ddcaps.dwCKeyCaps &amp; DDCKEYCAPS_DESTBLT ) <br>        { <br>            Msg( "Can do Dest colorkey in hardware" ); <br>            if( use_dest || !(ddcaps.dwCKeyCaps &amp; DDCKEYCAPS_SRCBLT) ) <br>            { <br>                /* <br>                 * since direct draw doesn't support <br>                 * destination color key in emulation, only <br>                 * use it if there is enough vram ... <br>                 */ <br>                if( ddcaps.dwVidMemTotal &gt;= 2 * 1024L*1024L*(GameBPP/8) ) <br>                { <br>                    Msg( "Using destination color key" ); <br>                    bTransDest = TRUE; <br>                } <br>            } <br>        } <br>    } <br>    else <br>    { <br>        Msg( "Can't do color key in hardware!" ); <br>    } <br> <br>    lpDD = lpdd; <br>    lpDD2 = lpdd2; <br>    return TRUE; <br> <br>error: <br>    return FALSE; <br> <br>} /* DDEnable */ <br> <br>/* <br> * DDDisable <br> */ <br>BOOL DDDisable( BOOL fFinal ) <br>{ <br>    if( lpClipper ) <br>    { <br>        IDirectDrawClipper_Release(lpClipper); <br>        lpClipper = NULL; <br>    } <br> <br>    if( lpBackBuffer ) <br>    { <br>        IDirectDrawSurface_Release(lpBackBuffer); <br>        lpBackBuffer = NULL; <br>    } <br> <br>    if( lpFrontBuffer ) <br>    { <br>        IDirectDrawSurface_Release(lpFrontBuffer); <br>        lpFrontBuffer = NULL; <br>    } <br> <br>    if( lpStretchBuffer ) <br>    { <br>        IDirectDrawSurface_Release(lpStretchBuffer); <br>        lpStretchBuffer = NULL; <br>    } <br> <br>    // <br>    // fFinal is TRUE when the app is exiting, FALSE if we are <br>    // just seting a new game size.. <br>    // <br>    if ( fFinal ) <br>    { <br>        if( lpDD != NULL ) <br>        { <br>            IDirectDraw_Release( lpDD ); <br>            IDirectDraw_Release( lpDD2 ); <br>            lpDD = NULL; <br>        } <br>    } <br> <br>    return TRUE; <br>} <br> <br>/* <br> * DDClear <br> * <br> * clear the front buffer and all backbuffers. <br> */ <br>BOOL DDClear( void ) <br>{ <br>    DDBLTFX     ddbltfx; <br>    inti; <br>    HRESULT     ddrval; <br> <br>    UpdateWindow(hWndMain); <br> <br>    ddbltfx.dwSize = sizeof( ddbltfx ); <br>    ddbltfx.dwFillColor = DDColorMatch(lpBackBuffer, RGB(0, 0, 200)); <br> <br>    if (bFullscreen) <br>    { <br>        /* <br>         * do it for all buffers, we either have 1 or 2 back buffers <br>         * make sure we get them all, 4 is plenty! <br>         */ <br>        for( i=0; i&lt;4; i++ ) <br>        { <br>            ddrval = IDirectDrawSurface_Blt( <br>                            lpBackBuffer,           // dest surface <br>                            NULL,                   // dest rect <br>                            NULL,                   // src surface <br>                            NULL,                   // src rect <br>                            DDBLT_COLORFILL | DDBLT_WAIT, <br>                            &amp;ddbltfx); <br> <br>            if( ddrval != DD_OK ) <br>            { <br>                Msg("Fill failed ddrval =0x%08lX", ddrval); <br>                return FALSE; <br>            } <br> <br>            ddrval = IDirectDrawSurface_Flip(lpFrontBuffer, NULL, DDFLIP_WAIT); <br> <br>            if( ddrval != DD_OK ) <br>            { <br>                Msg("Flip failed ddrval =0x%08lX", ddrval ); <br>                return FALSE; <br>            } <br>        } <br>    } <br>    else <br>    { <br>        ddrval = IDirectDrawSurface_Blt( <br>                        lpFrontBuffer,          // dest surface <br>                        &amp;rcWindow,              // dest rect <br>                        NULL,                   // src surface <br>                        NULL,                   // src rect <br>                        DDBLT_COLORFILL | DDBLT_WAIT, <br>                        &amp;ddbltfx); <br> <br>        if( ddrval != DD_OK ) <br>        { <br>            Msg("Fill failed ddrval =0x%08lX", ddrval); <br>            return FALSE; <br>        } <br>    } <br> <br>    return TRUE; <br> <br>} /* DDClear */ <br> <br>/* <br> * DDCreateFlippingSurface <br> * <br> * create a FrontBuffer and a BackBuffer(s) <br> * <br> */ <br>BOOL DDCreateFlippingSurface( void ) <br>{ <br>    DDPIXELFORMAT       ddpf; <br>    DDSURFACEDESCddsd; <br>    HRESULTddrval; <br>    DDSCAPSddscaps; <br>    DDCAPS              ddcaps; <br> <br>    ddcaps.dwSize = sizeof( ddcaps ); <br> <br>    if( IDirectDraw_GetCaps( lpDD, &amp;ddcaps, NULL ) != DD_OK ) <br>        return FALSE; <br> <br>    /* <br>     * fill in surface desc: <br>     * want a primary surface with 2 back buffers <br>     */ <br>    ZeroMemory( &amp;ddsd, sizeof( ddsd ) ); <br>    ddsd.dwSize = sizeof( ddsd ); <br> <br>    if (bFullscreen &amp;&amp; nBufferCount &gt; 1) <br>    { <br>        // <br>        //  fullscreen case, create a primary (ie front) and <br>        //  either 1  or 2 back buffers <br>        // <br>        ddsd.dwFlags = DDSD_CAPS | DDSD_BACKBUFFERCOUNT; <br>        ddsd.dwBackBufferCount = nBufferCount-1; <br>        ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE | <br>                DDSCAPS_FLIP | DDSCAPS_COMPLEX; <br> <br>        OutputDebugString("Creating multiple backbuffer primary\n\r"); <br>        ddrval = IDirectDraw_CreateSurface( lpDD, &amp;ddsd, &amp;lpFrontBuffer, NULL ); <br> <br>        if( ddrval != DD_OK ) <br>        { <br>            Msg( "CreateSurface FAILED! %08lx", ddrval ); <br>            return FALSE; <br>        } <br> <br>        /* <br>         * go find the back buffer <br>         */ <br>        ddscaps.dwCaps = DDSCAPS_BACKBUFFER; <br>        ddrval = IDirectDrawSurface_GetAttachedSurface( <br>                    lpFrontBuffer, <br>                    &amp;ddscaps, <br>                    &amp;lpBackBuffer ); <br> <br>        if( ddrval != DD_OK ) <br>        { <br>            Msg( "GetAttachedSurface failed! err=%d",ddrval ); <br>            return FALSE; <br>        } <br> <br>        /* <br>         *  if we are stretching create a buffer to stretch into <br>         * <br>         *  NOTE we always make this buffer in system memory because <br>         *  we render to the backbuffer (in VRAM) at half the size <br>         *  now we need to stretch into the backbuffer.  we could just <br>         *  do a VRAM-&gt;VRAM stretch, but this is REAL REAL REAL slow on <br>         *  some cards (banked cards..) <br>         */ <br>        if( bStretch &amp;&amp; (ddcaps.dwCaps &amp; DDCAPS_BANKSWITCHED) ) <br>        { <br>            Msg( "On bank switched hardware, creating stretch buffer" ); <br>            lpStretchBuffer = DDCreateSurface( GameSize.cx, GameSize.cy, <br>    TRUE, FALSE ); <br>        } <br>    } <br>    else if (bFullscreen &amp;&amp; nBufferCount == 1) <br>    { <br>        ddsd.dwFlags = DDSD_CAPS; <br>        ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE; <br> <br>        OutputDebugString("Creating no backbuffer primary\n\r"); <br>        ddrval = IDirectDraw_CreateSurface( lpDD, &amp;ddsd, &amp;lpFrontBuffer, NULL ); <br> <br>        if( ddrval != DD_OK ) <br>        { <br>            Msg( "CreateSurface FAILED! %08lx", ddrval ); <br>            return FALSE; <br>        } <br> <br>        IDirectDrawSurface_AddRef(lpFrontBuffer); <br>        lpBackBuffer = lpFrontBuffer; <br>    } <br>    else <br>    { <br>        // <br>        //  window case, create the primary surface <br>        //  and create a backbuffer in offscreen memory. <br>        // <br>        ddsd.dwFlags = DDSD_CAPS; <br>        ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE; <br> <br>        ddrval = IDirectDraw_CreateSurface( lpDD, &amp;ddsd, &amp;lpFrontBuffer, NULL ); <br> <br>        if( ddrval != DD_OK ) <br>        { <br>            Msg( "CreateSurface FAILED! %08lx", ddrval ); <br>            return FALSE; <br>        } <br> <br>        lpBackBuffer = DDCreateSurface( GameSize.cx, GameSize.cy, FALSE, FALSE ); <br> <br>        if( lpBackBuffer == NULL ) <br>        { <br>            Msg( "Cant create the backbuffer" ); <br>            return FALSE; <br>        } <br> <br>        // <br>        // now create a DirectDrawClipper object. <br>        // <br>        ddrval = IDirectDraw_CreateClipper(lpDD, 0, &amp;lpClipper, NULL); <br> <br>        if( ddrval != DD_OK ) <br>        { <br>            Msg("Cant create clipper"); <br>            return FALSE; <br>        } <br> <br>        ddrval = IDirectDrawClipper_SetHWnd(lpClipper, 0, hWndMain); <br> <br>        if( ddrval != DD_OK ) <br>        { <br>            Msg("Cant set clipper window handle"); <br>            return FALSE; <br>        } <br> <br>        ddrval = IDirectDrawSurface_SetClipper(lpFrontBuffer, lpClipper); <br> <br>        if( ddrval != DD_OK ) <br>        { <br>            Msg("Cant attach clipper to front buffer"); <br>            return FALSE; <br>        } <br>    } <br> <br>    /* <br>     * init the color key <br>     */ <br>    ddpf.dwSize = sizeof(ddpf); <br>    IDirectDrawSurface_GetPixelFormat(lpFrontBuffer, &amp;ddpf); <br> <br>    /* <br>     * we use white as the color key, if we are in a 8bpp mode, we know <br>     * what white is (because we use a 332 palette) if we are not in a <br>     * a 8bpp mode we dont know what white is and we need to figure it <br>     * out from the device (remember 16bpp comes in two common flavors <br>     * 555 and 565).  if we wanted to any random color as the color key <br>     * we would call DDColorMatch (see below) to convert a RGB into a <br>     * physical color. <br>     */ <br>    if (ddpf.dwRGBBitCount == 8) <br>        dwColorKey = 0xff; <br>    else <br>        dwColorKey = ddpf.dwRBitMask | ddpf.dwGBitMask | ddpf.dwBBitMask; <br> <br>    Msg("dwColorKey = 0x%08lX", dwColorKey); <br> <br>    if( bTransDest ) <br>    { <br>DDCOLORKEYddck; <br>        ddck.dwColorSpaceLowValue = dwColorKey; <br>        ddck.dwColorSpaceHighValue = dwColorKey; <br>        IDirectDrawSurface_SetColorKey( lpBackBuffer, DDCKEY_DESTBLT, &amp;ddck); <br>    } <br> <br>    return TRUE; <br> <br>} /* DDCreateFlippingSurface */ <br> <br>/* <br> * DDCreateSurface <br> */ <br>LPDIRECTDRAWSURFACE DDCreateSurface( <br>DWORD width, <br>DWORD height, <br>BOOL sysmem, <br>BOOL trans ) <br>{ <br>    DDSURFACEDESCddsd; <br>    HRESULTddrval; <br>    DDCOLORKEYddck; <br>    LPDIRECTDRAWSURFACEpsurf; <br> <br> <br>    /* <br>     * fill in surface desc <br>     */ <br>    memset( &amp;ddsd, 0, sizeof( ddsd ) ); <br>    ddsd.dwSize = sizeof( ddsd ); <br>    ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT |DDSD_WIDTH; <br> <br>    ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN; <br>    if( sysmem || bUseSysMem ) <br>    { <br>ddsd.ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY; <br>    } <br> <br>    ddsd.dwHeight = height; <br>    ddsd.dwWidth = width; <br> <br>    ddrval = IDirectDraw_CreateSurface( lpDD, &amp;ddsd, &amp;psurf, NULL ); <br> <br>    /* <br>     * set the color key for this bitmap <br>     */ <br>    if( ddrval == DD_OK ) <br>    { <br>if( trans &amp;&amp; !bTransDest ) <br>{ <br>            ddck.dwColorSpaceLowValue = dwColorKey; <br>            ddck.dwColorSpaceHighValue = dwColorKey; <br>            IDirectDrawSurface_SetColorKey( psurf, DDCKEY_SRCBLT, &amp;ddck); <br>} <br>    } <br>    else <br>    { <br>Msg( "CreateSurface FAILED, rc = %ld", (DWORD) LOWORD( ddrval ) ); <br>psurf = NULL; <br>    } <br> <br>     return psurf; <br> <br>} /* DDCreateSurface */ <br> <br>DWORD DDColorMatch(IDirectDrawSurface *pdds, COLORREF rgb) <br>{ <br>    COLORREF rgbT; <br>    HDC hdc; <br>    DWORD dw = CLR_INVALID; <br>    DDSURFACEDESC ddsd; <br>    HRESULT hres; <br> <br>    if (IDirectDrawSurface_GetDC(pdds, &amp;hdc) == DD_OK) <br>    { <br>        rgbT = GetPixel(hdc, 0, 0); <br>        SetPixel(hdc, 0, 0, rgb); <br>        IDirectDrawSurface_ReleaseDC(pdds, hdc); <br>    } <br> <br>    ddsd.dwSize = sizeof(ddsd); <br>    hres = IDirectDrawSurface_Lock( <br>        pdds, NULL, &amp;ddsd, DDLOCK_WAIT, NULL); <br> <br>    if (hres == DD_OK) <br>    { <br>        dw  = *(DWORD *)ddsd.lpSurface; <br>if(ddsd.ddpfPixelFormat.dwRGBBitCount != 32) <br>    dw &amp;= (1 &lt;&lt; ddsd.ddpfPixelFormat.dwRGBBitCount)-1; <br>        IDirectDrawSurface_Unlock(pdds, NULL); <br>    } <br>    else <br>    { <br>IDirectDrawSurface_GetSurfaceDesc(pdds,&amp;ddsd); <br>if(ddsd.ddsCaps.dwCaps &amp; DDSCAPS_PRIMARYSURFACE) <br>    Msg("Failed to lock Primary Surface!"); <br>else <br>    Msg("Failed to lock NON-PRIMARY Surface!"); <br>    } <br> <br>    if (IDirectDrawSurface_GetDC(pdds, &amp;hdc) == DD_OK) <br>    { <br>        SetPixel(hdc, 0, 0, rgbT); <br>        IDirectDrawSurface_ReleaseDC(pdds, hdc); <br>    } <br> <br>    return dw; <br>} <br> <br>/* <br> * ReadPalFile <br> * <br> * Create a DirectDrawPalette from a palette file <br> * <br> * if the palette files cant be found, make a default 332 palette <br> */ <br>LPDIRECTDRAWPALETTE ReadPalFile( char *fname ) <br>{ <br>    int                 i; <br>    intfh; <br>    HRESULTddrval; <br>    IDirectDrawPalette *ppal; <br> <br>    struct  { <br>        DWORD           dwRiff; <br>        DWORD           dwFileSize; <br>        DWORD           dwPal; <br>        DWORD           dwData; <br>        DWORD           dwDataSize; <br>        WORD            palVersion; <br>        WORD            palNumEntries; <br>        PALETTEENTRY    ape[256]; <br>    }   pal; <br> <br>    pal.dwRiff = 0; <br> <br>    if (fname) <br>    { <br>        fh = _lopen( fname, OF_READ); <br> <br>        if (fh != -1) <br>        { <br>            _lread(fh, &amp;pal, sizeof(pal)); <br>            _lclose(fh); <br>        } <br>    } <br> <br>    /* <br>     * if the file is not a palette file, or does not exist <br>     * default to a 332 palette <br>     */ <br>    if (pal.dwRiff != 0x46464952 || // 'RIFF' <br>        pal.dwPal  != 0x204C4150 || // 'PAL ' <br>        pal.dwData != 0x61746164 || // 'data' <br>        pal.palVersion != 0x0300 || <br>        pal.palNumEntries &gt; 256  || <br>        pal.palNumEntries &lt; 1) <br>    { <br>        Msg("Can't open palette file, using default 332."); <br> <br>        for( i=0; i&lt;256; i++ ) <br>        { <br>            pal.ape[i].peRed   = (BYTE)(((i &gt;&gt; 5) &amp; 0x07) * 255 / 7); <br>            pal.ape[i].peGreen = (BYTE)(((i &gt;&gt; 2) &amp; 0x07) * 255 / 7); <br>            pal.ape[i].peBlue  = (BYTE)(((i &gt;&gt; 0) &amp; 0x03) * 255 / 3); <br>            pal.ape[i].peFlags = (BYTE)0; <br>        } <br>    } <br> <br>    ddrval = IDirectDraw_CreatePalette( <br>    lpDD, <br>    DDPCAPS_8BIT, <br>                            pal.ape, <br>    &amp;ppal, <br>    NULL ); <br>    return ppal; <br> <br>} /* ReadPalFile */ <br> <br> <br>/* <br> * Splash <br> * <br> * Draw a splash screen during startup <br> * NOTE the screen has been cleared in DDCreateFlippingSurface <br> */ <br>void Splash( void ) <br>{ <br>    HDC hdc; <br>    HRESULT err = 0; <br> <br>    DDClear(); <br> <br>//    if ((err = IDirectDrawSurface_GetDC(lpFrontBuffer, &amp;hdc)) == DD_OK) <br>    if ((hdc = GetDC(hWndMain)) ) <br>    { <br>        char ach[256]; <br>        int len; <br> <br>        len = wsprintf(ach, <br>            "FoxBear is loading......   Device:%s %s", <br>            aDDDevs[DevIndex].DriverDesc, aDDDevs[DevIndex].DriverName); <br> <br>        SetTextColor(hdc, RGB(255,255,255)); <br>        SetBkMode(hdc, TRANSPARENT); <br>        TextOut(hdc, rcWindow.left, rcWindow.top, ach, len); <br> <br>        //IDirectDrawSurface_ReleaseDC(lpFrontBuffer, hdc); <br>        ReleaseDC(hWndMain,hdc); <br>    } <br>    else <br>    { <br>Msg("GetDC failed! 0x%x",err); <br>    } <br> <br>} /* Splash */ <br> <br>/* <br> * MEMORY ALLOCATION ROUTINES... <br> */ <br> <br>/* <br> * MemAlloc <br> */ <br>LPVOID MemAlloc( UINT size ) <br>{ <br>    LPVOIDptr; <br> <br>    ptr = LocalAlloc( LPTR, size ); <br>    return ptr; <br> <br>} /* MemAlloc */ <br> <br>/* <br> * CMemAlloc <br> */ <br>LPVOID CMemAlloc( UINT cnt, UINT isize ) <br>{ <br>    DWORDsize; <br>    LPVOIDptr; <br> <br>    size = cnt * isize; <br>    ptr = LocalAlloc( LPTR, size ); <br>    return ptr; <br> <br>} /* CMemAlloc */ <br> <br>/* <br> * MemFree <br> */ <br>void MemFree( LPVOID ptr ) <br>{ <br>    if( ptr != NULL ) <br>    { <br>LocalFree( ptr ); <br>    } <br> <br>} /* MemFree */ <br> <br>HRESULT CALLBACK EnumDisplayModesCallback(LPDDSURFACEDESC pddsd, LPVOID Context) <br>{ <br>    int ChkMode; <br> <br>    Msg("Mode: %dx%dx%d", pddsd-&gt;dwWidth, pddsd-&gt;dwHeight,pddsd-&gt;ddpfPixelFormat.dwRGBBitCount); <br> <br>    for(ChkMode = 0;ChkMode &lt; NumModes;ChkMode++) <br>    { <br>        if( <br>            (ModeList[ChkMode].w == (int)pddsd-&gt;dwWidth)&amp;&amp; <br>            (ModeList[ChkMode].h == (int)pddsd-&gt;dwHeight)&amp;&amp; <br>            (ModeList[ChkMode].bpp == (int)pddsd-&gt;ddpfPixelFormat.dwRGBBitCount)&amp;&amp;  <br>            (ModeList[ChkMode].dwFlags == (int)pddsd-&gt;ddsCaps.dwCaps) <br>          ) <br>            return DDENUMRET_OK; <br>    } <br> <br>    ModeList[NumModes].w   = pddsd-&gt;dwWidth; <br>    ModeList[NumModes].h   = pddsd-&gt;dwHeight; <br>    ModeList[NumModes].bpp = pddsd-&gt;ddpfPixelFormat.dwRGBBitCount; <br>    ModeList[NumModes].dwFlags = pddsd-&gt;ddsCaps.dwCaps; <br> <br>    NumModes++; <br> <br>    return DDENUMRET_OK; <br>} <br> <br>HRESULT CALLBACK DDEnumCallback(GUID * lpGUID, LPSTR DriverDesc, LPSTR DriverName, LPVOID lpContext) <br>{ <br>    if(MaxDevIndex &gt;= sizeof(aDDDevs)/sizeof(aDDDevs[0])) <br>        return E_FAIL; <br> <br>    Msg("Device: %s (%s)", DriverDesc, DriverName); <br> <br>    if(lpGUID == NULL || lpGUID == (GUID*)DDCREATE_EMULATIONONLY) <br>    { <br>        aDDDevs[MaxDevIndex].guid = lpGUID; <br>    } <br>    else <br>    { <br>        aDDDevs[MaxDevIndex].DriverGUID = *lpGUID; <br>        aDDDevs[MaxDevIndex].guid = &amp;aDDDevs[MaxDevIndex].DriverGUID; <br>    } <br> <br>    lstrcpyn(aDDDevs[MaxDevIndex].DriverDesc, DriverDesc, 128); <br>    lstrcpyn(aDDDevs[MaxDevIndex].DriverName, DriverName, 128); <br> <br>    MaxDevIndex++; <br>    return DDENUMRET_OK; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
