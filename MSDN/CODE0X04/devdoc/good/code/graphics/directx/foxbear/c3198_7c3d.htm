<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>BMP.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3199"></a>BMP.C</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1995-1997 Microsoft Corporation. All Rights Reserved. <br> *  Copyright (C) 1994-1995 ATI Technologies Inc. All Rights Reserved. <br> * <br> *  File:bmp.c <br> *  Content:Bitmap reader <br> * <br> ***************************************************************************/ <br>#include "foxbear.h" <br> <br>/* <br> * gfxLoadBitmap <br> */ <br>GFX_HBM gfxLoadBitmap(LPSTR szFileName) <br>{ <br>    HFASTFILE                  pfile;    <br>    BITMAPFILEHEADER UNALIGNED *pbf; <br>    BITMAPINFOHEADER UNALIGNED *pbi; <br>    GFX_HBM                    hbm;  <br>    BOOL                       trans = FALSE; <br> <br>    pfile = FastFileOpen( szFileName ); <br> <br>    if( pfile == NULL ) <br>    { <br>return NULL; <br>    } <br> <br>    pbf = (BITMAPFILEHEADER *)FastFileLock(pfile, 0, 0); <br>    pbi = (BITMAPINFOHEADER *)(pbf+1); <br> <br>    if (pbf-&gt;bfType != 0x4d42 || <br>        pbi-&gt;biSize != sizeof(BITMAPINFOHEADER)) <br>    { <br>Msg("Failed to load"); <br>Msg(szFileName); <br>FastFileClose( pfile ); <br>return NULL; <br>    } <br> <br>    /* <br>     * TOTAL HACK for FoxBear, FoxBear does not use any masks, it draws <br>     * sprites with transparent colors, but the code still loads the masks <br>     * if a mask exists the sprite is transparent, else it is not, so <br>     * you cant get rid of the masks or nothing will be transparent!! <br>     * <br>     * if the code tries to load a mask, just return a non-zero value. <br>     */ <br> <br>    if( pbi-&gt;biBitCount == 1 ) <br>    { <br>        Msg("some code is still using masks, stop that!"); <br>FastFileClose( pfile ); <br>        return NULL; <br>    } <br> <br>    /* <br>     * ANOTHER TOTAL HACK for FoxBear, some of the bitmaps in FoxBear <br>     * are a solid color, detect these and dont waste VRAM on them. <br>     */ <br>    if( !bTransDest &amp;&amp; pbi-&gt;biBitCount == 8 ) <br>    { <br>        int x,y; <br>        BYTE c; <br>        BYTE UNALIGNED *pb = (LPBYTE)pbi + pbi-&gt;biSize + 256 * sizeof(COLORREF); <br>        RGBQUAD UNALIGNED *prgb = (RGBQUAD *)((LPBYTE)pbi + pbi-&gt;biSize); <br>        COLORREF rgb; <br> <br>        c = *pb; <br> <br>        for(y=0; y&lt;(int)pbi-&gt;biHeight; y++ ) <br>        { <br>            for( x=0; x&lt;(int)pbi-&gt;biWidth; x++ ) <br>            { <br>                if (c != *pb++) <br>                    goto not_solid; <br>            } <br>            pb += ((pbi-&gt;biWidth + 3) &amp; ~3) - pbi-&gt;biWidth; <br>        } <br> <br>        rgb = RGB(prgb[c].rgbRed,prgb[c].rgbGreen,prgb[c].rgbBlue); <br>        hbm = gfxCreateSolidColorBitmap(rgb); <br> <br>        FastFileClose( pfile ); <br>        return hbm; <br>    } <br>not_solid: <br> <br>    /* <br>     * figure out iff the bitmap has the transparent color in it. <br>     */ <br>    if( pbi-&gt;biBitCount == 8 ) <br>    { <br>        int x,y; <br>        BYTE UNALIGNED *pb = (LPBYTE)pbi + pbi-&gt;biSize + 256 * sizeof(COLORREF); <br>        DWORD UNALIGNED *prgb = (DWORD *)((LPBYTE)pbi + pbi-&gt;biSize); <br> <br>        for(y=0; y&lt;(int)pbi-&gt;biHeight &amp;&amp; !trans; y++ ) <br>        { <br>            for( x=0; x&lt;(int)pbi-&gt;biWidth &amp;&amp; !trans; x++ ) <br>            { <br>                if (prgb[*pb++] == 0x00FFFFFF) <br>                    trans=TRUE; <br>            } <br>            pb += ((pbi-&gt;biWidth + 3) &amp; ~3) - pbi-&gt;biWidth; <br>        } <br>    } <br> <br>    hbm = gfxCreateVramBitmap(pbi, trans); <br> <br>    if( hbm == NULL ) <br>    { <br>FastFileClose( pfile ); <br>        return GFX_FALSE; <br>    } <br> <br>#if 0 <br>    { <br>        DDSCAPS ddscaps; <br> <br>        IDirectDrawSurface_GetCaps(((GFX_BITMAP *)hbm)-&gt;lpSurface, &amp;ddscaps); <br> <br>        if( !(ddscaps.dwCaps &amp; DDSCAPS_VIDEOMEMORY) ) <br>{ <br>    Msg( "%s is in system memory", szFileName ); <br>} <br>    } <br>#endif <br> <br>    FastFileClose( pfile ); <br> <br>    return hbm; <br> <br>} /* gfxLoadBitmap */ </code></pre>
<p>&nbsp;</p></body>
</HTML>
