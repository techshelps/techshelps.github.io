<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>INPUT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3179"></a>INPUT.C</h2>
<pre><code>/*========================================================================== <br> * <br> * Copyright (C) 1995-1997 Microsoft Corporation. All Rights Reserved. <br> * <br> * File:       input.c <br> * Content:    DirectInput functionality for FFDonuts sample <br> * <br> * Functions: <br> * inputInitDirectInput() <br> * inputCleanupDirectInput() <br> * inputEnumDeviceProc(LPDIDEVICEINSTANCE pdidi, LPVOID pv); <br> * inputAcquireDevices(void); <br> * inputCreateEffects(void); <br> * inputProcessDeviceInput(void); <br> * inputPrepareDevice(void); <br> * inputPlayEffect(DWORD dwEffectFlag); <br> * <br> * <br> ***************************************************************************/ <br> <br>#include "input.h" <br>#include "resource.h" <br> <br>// file global variables <br>static BOOL                 fIsFFDevice  = FALSE;   // does our device support <br>                                                    // ForceFeedback <br>static DWORD                dwGain       = FF_ADULT;// gain selection from user <br>static LPDIRECTINPUT        gpdi         = NULL;    // base DirectInput object <br>static LPDIRECTINPUTDEVICE2 gpdiJoystick = NULL;    // DirectInputDevice2 objects <br>                                                    // support ForceFeedback <br>static LPDIRECTINPUTEFFECT  gpdieBounce  = NULL;    // effect used when "bouncing" <br>                                                    // off of the screen edges <br>static LPDIRECTINPUTEFFECT  gpdieExplode = NULL;    // effect used when the ship <br>                                                    // explodes <br>static LPDIRECTINPUTEFFECT  gpdieFire    = NULL;    // effect used when firing <br> <br>//=========================================================================== <br>// inputInitDirectInput <br>// <br>// Creates and initializes DirectInput objects <br>// <br>// Parameters: <br>// <br>// Returns: <br>// <br>//=========================================================================== <br>BOOL inputInitDirectInput(HINSTANCE hInst, HWND hWnd) <br>{ <br>    HRESULT             hRes; <br>    LPDIRECTINPUTDEVICE pdiTempDevice       = NULL; <br>    DIDEVCAPS           didc; <br>    GUID                guidDevice; <br>    TCHAR               tszBuf[256]; <br> <br>    // create the base DirectInput object <br>    hRes = DirectInputCreate(hInst, DIRECTINPUT_VERSION, &amp;gpdi, NULL); <br>    if(FAILED(hRes)) <br>    { <br>        wsprintf(tszBuf, TEXT("DirectInputCreate() failed - %08Xh\n\n") <br>                  TEXT("DirectX 5 or later required."), hRes); <br>        MessageBox(hWnd, tszBuf, TEXT("Space Donuts - Force Feedback"), MB_OK); <br>        return FALSE; <br>    } <br> <br>    // enumerate for joystick devices <br>    hRes = gpdi-&gt;lpVtbl-&gt;EnumDevices(gpdi, DIDEVTYPE_JOYSTICK, <br>                                    (LPDIENUMDEVICESCALLBACK)inputEnumDeviceProc, <br>                                    &amp;guidDevice, <br>                                    DIEDFL_ATTACHEDONLY); <br>    if(FAILED(hRes)) <br>    { <br>        wsprintf(tszBuf, TEXT("EnumDevices() failed - %08Xh"), hRes); <br>        MessageBox(hWnd, tszBuf, TEXT("Space Donuts - Force Feedback"), MB_OK); <br>        return FALSE; <br>    } <br> <br>    // create a temporary "Device 1" object <br>    hRes = gpdi-&gt;lpVtbl-&gt;CreateDevice(gpdi, &amp;guidDevice, &amp;pdiTempDevice, NULL); <br>    if(FAILED(hRes)) <br>    { <br>        wsprintf(tszBuf, TEXT("CreateDevice() failed - %08Xh\n\n") <br>                  TEXT("This version of ""Space Donuts"" requires a JOYSTICK device."), hRes); <br>        MessageBox(hWnd, tszBuf, TEXT("Space Donuts - Force Feedback"), MB_OK); <br>        return FALSE; <br>    } <br> <br>    // get a "Device 2" object <br>    // <br>    // this is needed for access to the ForceFeedback functionality <br>    hRes = pdiTempDevice-&gt;lpVtbl-&gt;QueryInterface(pdiTempDevice, <br>                                                &amp;IID_IDirectInputDevice2, <br>                                                &amp;gpdiJoystick); <br>    if(FAILED(hRes)) <br>    { <br>        wsprintf(tszBuf, TEXT("QueryInterface(IID_IDirectInputDevice2) failed - %08Xh"), hRes); <br>        MessageBox(hWnd, tszBuf, TEXT("Space Donuts - Force Feedback"), MB_OK); <br>        return FALSE; <br>    } <br> <br>    // we no longer need the temporary device, go ahead and release it. <br>    if(pdiTempDevice) <br>    { <br>        pdiTempDevice-&gt;lpVtbl-&gt;Release(pdiTempDevice); <br>        pdiTempDevice = NULL; <br>    } <br> <br>    // set the device's data format <br>    // <br>    // This tells the device object to act like a specific device -- <br>    // in our case, like a joystick <br>    hRes = gpdiJoystick-&gt;lpVtbl-&gt;SetDataFormat(gpdiJoystick, &amp;c_dfDIJoystick); <br>    if(FAILED(hRes)) <br>    { <br>        wsprintf(tszBuf, TEXT("SetDataFormat(Joystick) failed - %08Xh"), hRes); <br>        MessageBox(hWnd, tszBuf, TEXT("Space Donuts - Force Feedback"), MB_OK); <br>        return FALSE; <br>    } <br> <br>    // set the device's cooperative level <br>    // <br>    // ForceFeedback requires Exclusive access to the device. <br>    hRes = gpdiJoystick-&gt;lpVtbl-&gt;SetCooperativeLevel(gpdiJoystick, hWnd, <br>                                                    DISCL_EXCLUSIVE | DISCL_FOREGROUND); <br>    if(FAILED(hRes)) <br>    { <br>        wsprintf(tszBuf, TEXT("SetCooperativeLevel(Exclusive | Foreground) failed - %08Xh"), hRes); <br>        MessageBox(hWnd, tszBuf, TEXT("Space Donuts - Force Feedback"), MB_OK); <br>        return FALSE; <br>    } <br> <br>    // set joystick parameters (deadzone, etc) <br>    if(!inputPrepareDevice()) <br>    { <br>        MessageBox(hWnd, TEXT("Device preparation failed"), <br>                  TEXT("Space Donuts - Force Feedback"), MB_OK); <br>        return FALSE; <br>    } <br> <br>    // get the device capabilities <br>    // <br>    // We're going to check to see if the device we created supports <br>    // ForceFeedback.  If so, we will create effects, if not, we'll <br>    // support standard joystick functionality <br>    fIsFFDevice = FALSE; <br>    didc.dwSize = sizeof(DIDEVCAPS); <br>    hRes = gpdiJoystick-&gt;lpVtbl-&gt;GetCapabilities(gpdiJoystick, &amp;didc); <br>    if(FAILED(hRes)) <br>    { <br>        wsprintf(tszBuf, TEXT("GetCapabilities() failed - %08Xh"), hRes); <br>        MessageBox(hWnd, tszBuf, TEXT("Space Donuts - Force Feedback"), MB_OK); <br>        return FALSE; <br>    } <br>    if(didc.dwFlags &amp; DIDC_FORCEFEEDBACK) <br>    { <br>        OutputDebugString("ForceFeedback device found.\n"); <br> <br>        // get the gain level from the user <br>        DialogBox(hInst, MAKEINTRESOURCE(IDD_FORCE), hWnd, inputForceLevelDlgProc); <br> <br>        // we're supporting ForceFeedback <br>        fIsFFDevice = TRUE; <br>        if(!inputCreateEffect(EF_BOUNCE | EF_FIRE | EF_EXPLODE)) <br>        { <br>            OutputDebugString("inputCreateEffects() failed - ForceFeedback disabled\n"); <br>        } <br>    } //** end if(ForceFeedback device) <br> <br>    // if we get here, we succeeded <br>    return TRUE; <br> <br>} //*** end inputInitDirectInput() <br> <br> <br>//=========================================================================== <br>// inputCleanupDirectInput <br>// <br>// Cleans up DirectInput objects <br>// <br>// Parameters: none <br>// <br>// Returns: nothing <br>// <br>//=========================================================================== <br>void inputCleanupDirectInput(void) <br>{ <br>    OutputDebugString("Cleaning up after DirectInput\n"); <br> <br>    // Release() effect objects <br>    if(gpdieBounce) <br>    { <br>        gpdieBounce-&gt;lpVtbl-&gt;Release(gpdieBounce); <br>        gpdieBounce = NULL; <br>    } <br>    if(gpdieExplode) <br>    { <br>        gpdieExplode-&gt;lpVtbl-&gt;Release(gpdieExplode); <br>        gpdieExplode = NULL; <br>    } <br>    if(gpdieFire) <br>    { <br>        gpdieFire-&gt;lpVtbl-&gt;Release(gpdieFire); <br>        gpdieFire = NULL; <br>    } <br> <br>    // Unacquire() and Release() device objects <br>    // <br>    // It is perfectly safe to call Unacquire() on a device that is not <br>    // currently acquired.  In fact, it is good practice to call <br>    // Unacquire() just prior to Release(). <br>    if(gpdiJoystick) <br>    { <br>        gpdiJoystick-&gt;lpVtbl-&gt;Unacquire(gpdiJoystick); <br>        gpdiJoystick-&gt;lpVtbl-&gt;Release(gpdiJoystick); <br>        gpdiJoystick = NULL; <br>    } <br> <br>    // Release() base object <br>    if(gpdi) <br>    { <br>        gpdi-&gt;lpVtbl-&gt;Release(gpdi); <br>        gpdi = NULL; <br>    } <br> <br>} //*** end inputCleanupDirectInput() <br> <br> <br>//=========================================================================== <br>// inputEnumDeviceProc <br>// <br>// Enumerates DirectInput devices of type specified in call to <br>//  IDirectInput::EnumDevices() <br>// <br>// Parameters: <br>// <br>// Returns: <br>// <br>//=========================================================================== <br>BOOL CALLBACK inputEnumDeviceProc(LPDIDEVICEINSTANCE pdidi, LPVOID pv) <br>{ <br>    GUID *pguidDevice = NULL; <br> <br>    // validate pv <br>    // BUGBUG <br> <br>    // report back the instance guid of the device we enumerated <br>    if(pv) <br>    { <br> <br>        pguidDevice = (GUID *)pv; <br> <br>        *pguidDevice = pdidi-&gt;guidInstance; <br> <br>    } <br> <br>    // BUGBUG for now, stop after the first device has been found <br>    return DIENUM_STOP; <br> <br>} //*** end inputEnumDeviceProc() <br> <br> <br>//=========================================================================== <br>// inputEnumEffectTypeProc <br>// <br>// Enumerates ForceFeedback effect types (ie "Constant Force"). <br>// <br>// Parameters: <br>// <br>// Returns: <br>// <br>//=========================================================================== <br>BOOL CALLBACK inputEnumEffectTypeProc(LPCDIEFFECTINFO pei, LPVOID pv) <br>{ <br>    GUID *pguidEffect = NULL; <br> <br>    // validate pv <br>    // BUGBUG <br> <br>    // report back the guid of the effect we enumerated <br>    if(pv) <br>    { <br> <br>        pguidEffect = (GUID *)pv; <br> <br>        *pguidEffect = pei-&gt;guid; <br> <br>    } <br> <br>    // BUGBUG - look at this some more.... <br>    return DIENUM_STOP; <br> <br>} //*** end inputEnumEffectTypeProc() <br> <br> <br>//=========================================================================== <br>// inputAcquireDevices <br>// <br>// Acquires the input device(s). <br>// <br>// Parameters: <br>// <br>// Returns: <br>// <br>//=========================================================================== <br>BOOL inputAcquireDevices(void) <br>{ <br>    if(!gpdiJoystick) <br>    { <br>        return FALSE; <br>    } <br> <br>    // reacquire the device <br>    if(SUCCEEDED(gpdiJoystick-&gt;lpVtbl-&gt;Acquire(gpdiJoystick))) <br>    { <br> <br> <br>        // DirectInput automatically resets the device whenever <br>        // ownership changes, so we can assume we've got a device <br>        // unsullied by its previous owner. <br>        inputCreateEffect(EF_BOUNCE | EF_FIRE | EF_EXPLODE); <br> <br>        return TRUE; <br>    } <br>    // if we get here, we did &gt;not&lt; acquire the device <br>    return FALSE; <br> <br>} //*** end inputAcquireDevices() <br> <br> <br>//=========================================================================== <br>// inputCreateEffect <br>// <br>// Creates the DirectInputEffect object(s) used by the application <br>// <br>// Parameters: <br>// <br>// Returns: <br>// <br>//=========================================================================== <br>BOOL inputCreateEffect(DWORD dwEffectFlags) <br>{ <br>    HRESULT         hRes; <br>    GUID            guidEffect; <br>    DIEFFECT        diEffect; <br>    DIENVELOPE      diEnvelope; <br>    DWORD           rgdwAxes[2]; <br>    LONG            rglDirections[2]; <br>    DICONSTANTFORCE dicf; <br>    DIPERIODIC      dipf; <br>    TCHAR           tszBuf[256]; <br> <br>    // make sure that we have a non-NULL device object <br>    if(!gpdiJoystick) <br>    { <br>        return FALSE; <br>    } <br> <br>    // initialize DIEFFECT and DIENVELOPE structures <br>    ZeroMemory(&amp;diEffect, sizeof(DIEFFECT)); <br>    ZeroMemory(&amp;diEnvelope, sizeof(DIENVELOPE)); <br> <br>    // these fields are the same for all effects we will be creating <br>    diEffect.dwSize                     = sizeof(DIEFFECT); <br>    diEffect.dwSamplePeriod             = 0; // use default sample period <br>    diEffect.dwTriggerButton            = DIEB_NOTRIGGER; <br>    diEffect.dwTriggerRepeatInterval    = 0; <br>    diEffect.rgdwAxes                   = rgdwAxes; <br>    diEffect.rglDirection               = rglDirections; <br>    diEffect.dwGain                     = dwGain; // gain selected by user <br> <br>    // enumerate for a constant force effect <br>    // <br>    // both the "bounce" and "fire" effects will be based on the first <br>    // constant force effect enumerated <br>    if((dwEffectFlags &amp; EF_BOUNCE) || (dwEffectFlags &amp; EF_FIRE)) <br>    { <br>        hRes = gpdiJoystick-&gt;lpVtbl-&gt;EnumEffects(gpdiJoystick, <br>                                                (LPDIENUMEFFECTSCALLBACK)inputEnumEffectTypeProc, <br>                                                &amp;guidEffect, DIEFT_CONSTANTFORCE); <br>        if(FAILED(hRes)) <br>        { <br>            OutputDebugString("EnumEffects(Constant Force) failed\n"); <br>            return FALSE; <br>        } <br>    } <br> <br>    // create "bounce" effect <br>    if(dwEffectFlags &amp; EF_BOUNCE) <br>    { <br>        // if we have already created this effect... <br>        // <br>        // Call Release() before recreating it <br>        if(gpdieBounce) <br>        { <br>            gpdieBounce-&gt;lpVtbl-&gt;Release(gpdieBounce); <br>            gpdieBounce = NULL; <br>        } <br> <br>        // prepare the DICONSTANTFORCE structure <br>        // <br>        // this is the type-specific data for this force <br>        dicf.lMagnitude                     = 10000; <br> <br>        // what axes and directions to use? <br>        // (directions do not matter at this point, set them to 0) <br>        rgdwAxes[0]                         = DIJOFS_X; <br>        rgdwAxes[1]                         = DIJOFS_Y; <br>        rglDirections[0]                    = 0; <br>        rglDirections[1]                    = 0; <br> <br>        // prepare the DIEFFECT structure <br>        // <br>        // fill in the force-specific values <br>        diEffect.dwFlags                    = DIEFF_OBJECTOFFSETS | DIEFF_POLAR; <br>        diEffect.dwDuration                 = 200000; <br>        diEffect.cAxes                      = 2; <br>        diEffect.lpEnvelope                 = NULL; <br>        diEffect.cbTypeSpecificParams       = sizeof(DICONSTANTFORCE); <br>        diEffect.lpvTypeSpecificParams      = &amp;dicf; <br> <br>        // call CreateEffect() <br>        hRes = gpdiJoystick-&gt;lpVtbl-&gt;CreateEffect(gpdiJoystick, &amp;guidEffect, <br>                                                    &amp;diEffect, &amp;gpdieBounce, <br>                                                    NULL); <br>        if(FAILED(hRes)) <br>        { <br>            wsprintf(tszBuf, "CreateEffect(Bounce) failed - %08Xh\n", hRes); <br>            OutputDebugString(tszBuf); <br>            return FALSE; <br>        } <br> <br>    } //** end if(bounce effect) <br> <br>    // create "fire" effect <br>    if(dwEffectFlags &amp; EF_FIRE) <br>    { <br>        // if we have already created this effect... <br>        // <br>        // Call Release() before recreating it <br>        if(gpdieFire) <br>        { <br>            gpdieFire-&gt;lpVtbl-&gt;Release(gpdieFire); <br>            gpdieFire = NULL; <br>        } <br> <br>        // prepare the DICONSTANTFORCE structure <br>        // <br>        // this is the type-specific data for this force <br>        dicf.lMagnitude                     = 10000; <br> <br>        // what axes and directions to use? <br>        rgdwAxes[0]                         = DIJOFS_Y; <br>        rglDirections[0]                    = 1; <br> <br>        // prepare the DIEFFECT structure <br>        // <br>        // fill in the force-specific values <br>        diEffect.dwFlags                    = DIEFF_OBJECTOFFSETS | DIEFF_CARTESIAN; <br>        diEffect.dwDuration                 = 20000; <br>        diEffect.cAxes                      = 1; <br>        diEffect.lpEnvelope                 = NULL; <br>        diEffect.cbTypeSpecificParams       = sizeof(DICONSTANTFORCE); <br>        diEffect.lpvTypeSpecificParams      = &amp;dicf; <br> <br>        // call CreateEffect() <br>        hRes = gpdiJoystick-&gt;lpVtbl-&gt;CreateEffect(gpdiJoystick, &amp;guidEffect, <br>                                                    &amp;diEffect, &amp;gpdieFire, <br>                                                    NULL); <br>        if(FAILED(hRes)) <br>        { <br>            wsprintf(tszBuf, "CreateEffect(Fire) failed - %08Xh\n", hRes); <br>            OutputDebugString(tszBuf); <br>            return FALSE; <br>        } <br> <br>    } //** end if(fire effect) <br> <br>    // enumerate for a periodic effect <br>    // <br>    // the "explode" effect will be based on the first <br>    // periodic effect enumerated <br>    if((dwEffectFlags &amp; EF_EXPLODE)) <br>    { <br>        hRes = gpdiJoystick-&gt;lpVtbl-&gt;EnumEffects(gpdiJoystick, <br>                                                (LPDIENUMEFFECTSCALLBACK)inputEnumEffectTypeProc, <br>                                                &amp;guidEffect, DIEFT_PERIODIC); <br>        if(FAILED(hRes)) <br>        { <br>            OutputDebugString("EnumEffects(Periodic Force) failed\n"); <br>            return FALSE; <br>        } <br>    } <br>    // create "explode" effect <br>    if(dwEffectFlags &amp; EF_FIRE) <br>    { <br>        // if we have already created this effect... <br>        // <br>        // Call Release() before recreating it <br>        if(gpdieExplode) <br>        { <br>            gpdieExplode-&gt;lpVtbl-&gt;Release(gpdieExplode); <br>            gpdieExplode = NULL; <br>        } <br> <br>        // prepare the DIENVELOPE structure <br>        // <br>        // We want to shape the explode effect so that it starts <br>        // at it's peak and then fades out <br>        diEnvelope.dwSize                   = sizeof(DIENVELOPE); <br>        diEnvelope.dwAttackLevel            = 0; <br>        diEnvelope.dwAttackTime             = 0; <br>        diEnvelope.dwFadeLevel              = 0; <br>        diEnvelope.dwFadeTime               = 1000000; <br> <br>        // prepare the DIPERIODIC structure <br>        // <br>        // this is the type-specific data for this force <br>        dipf.dwMagnitude                    = 10000; <br>        dipf.lOffset                        = 0; <br>        dipf.dwPhase                        = 0; <br>        dipf.dwPeriod                       = 100000; <br> <br>        // what axes and directions to use? <br>        rgdwAxes[0]                         = DIJOFS_X; <br>        rglDirections[0]                    = 0; <br> <br>        // prepare the DIEFFECT structure <br>        // <br>        // fill in the force-specific values <br>        diEffect.dwFlags                    = DIEFF_OBJECTOFFSETS | DIEFF_CARTESIAN; <br>        diEffect.dwDuration                 = 1000000; <br>        diEffect.cAxes                      = 1; <br>        diEffect.lpEnvelope                 = &amp;diEnvelope; <br>        diEffect.cbTypeSpecificParams       = sizeof(DIPERIODIC); <br>        diEffect.lpvTypeSpecificParams      = &amp;dipf; <br> <br>        // call CreateEffect() <br>        hRes = gpdiJoystick-&gt;lpVtbl-&gt;CreateEffect(gpdiJoystick, &amp;guidEffect, <br>                                                    &amp;diEffect, &amp;gpdieExplode, <br>                                                    NULL); <br>        if(FAILED(hRes)) <br>        { <br>            wsprintf(tszBuf, "CreateEffect(Explode) failed - %08Xh\n", hRes); <br>            OutputDebugString(tszBuf); <br>            return FALSE; <br>        } <br> <br>    } //** end if(explode effect) <br> <br>    return TRUE; <br> <br>} //*** end inputCreateEffects() <br> <br> <br>//=========================================================================== <br>// inputProcessDeviceInput <br>// <br>// Processes data from the input device.  Uses GetDeviceState(). <br>// <br>// Parameters: <br>// <br>// Returns: <br>// <br>//=========================================================================== <br>DWORD inputProcessDeviceInput(void) <br>{ <br>    HRESULT     hRes; <br>    DIJOYSTATE  dijs; <br>    DWORD       dwInput = 0; <br> <br>    // poll the joystick to read the current state <br>    hRes = gpdiJoystick-&gt;lpVtbl-&gt;Poll(gpdiJoystick); <br> <br>    // read the device state <br>    hRes = gpdiJoystick-&gt;lpVtbl-&gt;GetDeviceState(gpdiJoystick, sizeof(DIJOYSTATE), <br>                                                &amp;dijs); <br>    if(FAILED(hRes)) <br>    { <br>        if((hRes == DIERR_INPUTLOST)) <br>        { <br>            inputAcquireDevices(); <br>        } <br> <br>        // we did not read anything, return no motion <br>        return 0; <br>    } <br> <br>    // process device state <br>    // <br>    // to preserve as much of the existing input handling code from the <br>    // original space donuts sample, we will be converting the joystick data to <br>    // "keyboard" input <br> <br>    //* x-axis (left) <br>    if(dijs.lX &lt; 0) <br>    { <br>        dwInput |= KEY_LEFT; <br>    } <br>    //* x-axis (right) <br>    if(dijs.lX &gt; 0) <br>    { <br>        dwInput |= KEY_RIGHT; <br>    } <br>    //* y-axis (forward) <br>    if(dijs.lY &lt; 0) <br>    { <br>        dwInput |= KEY_UP; <br>    } <br>    //* y-axis (backward) <br>    if(dijs.lY &gt; 0) <br>    { <br>        dwInput |= KEY_DOWN; <br>    } <br>    //* button 0 (fire) <br>    if(dijs.rgbButtons[0] &amp; 0x80) <br>    { <br>        dwInput |= KEY_FIRE; <br>    } <br>    //* button 1 (shield) <br>    if(dijs.rgbButtons[1] &amp; 0x80) <br>    { <br>        dwInput |= KEY_SHIELD; <br>    } <br>    //* button 2 (stop) - requires a joystick with more than 2 buttons <br>    if(dijs.rgbButtons[2] &amp; 0x80) <br>    { <br>        dwInput |= KEY_STOP; <br>    } <br> <br>    // return the new device state <br>    return dwInput; <br> <br>} //*** end inputProcessDeviceInput() <br> <br> <br>//=========================================================================== <br>// inputPrepareDevice <br>// <br>// Performs device preparation by setting the device's parameters (ie <br>// deadzone). <br>// <br>// Parameters: <br>// <br>// Returns: <br>// <br>//=========================================================================== <br>BOOL inputPrepareDevice(void) <br>{ <br>    HRESULT       hRes; <br>    DIPROPRANGE   dipr; <br>    DIPROPDWORD   dipdw; <br> <br> <br>    // quick check to make sure that the object pointer is non-NULL <br>    if(!gpdiJoystick) <br>    { <br>        return FALSE; <br>    } <br> <br>    // call Unacquire() on the device <br>    // <br>    // SetParameter() will fail if a device is currently acquired, we are <br>    // doing this here in case we get careless and forget to call this <br>    // function either before we call Acquire() or after we call Unacquire(). <br>    gpdiJoystick-&gt;lpVtbl-&gt;Unacquire(gpdiJoystick); <br> <br>    // set the axis ranges for the device <br>    // <br>    // We will use the same range for the X and Y axes.  We are setting them <br>    // fairly low since we are not concerned with anything other than <br>    // "left", "right", "forward", "backward" and "centered" <br>//* prepare DIPROPRANGE structure <br>    dipr.diph.dwSize        = sizeof(DIPROPRANGE); <br>dipr.diph.dwHeaderSize  = sizeof(dipr.diph); <br>dipr.diph.dwHow         = DIPH_BYOFFSET; <br>dipr.lMin               = RANGE_MIN;  // negative to the left/top <br>dipr.lMax               = RANGE_MAX;  // positive to the right/bottom <br>    //* x-axis <br>    dipr.diph.dwObj         = DIJOFS_X; <br>    //* set the x-axis range property <br>    hRes = gpdiJoystick-&gt;lpVtbl-&gt;SetProperty(gpdiJoystick, DIPROP_RANGE, &amp;dipr.diph); <br>    if(FAILED(hRes)) <br>    { <br>        OutputDebugString("SetProperty(RANGE, X-Axis) failed.\n"); <br>        return FALSE; <br>    } <br>    //* y-axis <br>    dipr.diph.dwObj         = DIJOFS_Y; <br>    hRes = gpdiJoystick-&gt;lpVtbl-&gt;SetProperty(gpdiJoystick, DIPROP_RANGE, &amp;dipr.diph); <br>    if(FAILED(hRes)) <br>    { <br>        OutputDebugString("SetProperty(RANGE, Y-Axis) failed.\n"); <br>        return FALSE; <br>    } <br> <br>    // set the deadzone for the device <br>    // <br>    // We will use the same deadzone percentage for the X and Y axes. <br>    // This call uses a symbolic constant for the deadzone percentage so that <br>    // it is easy to change if we decide we don't like it. <br>//* prepare DIPROPDWORD structure <br>dipdw.diph.dwSize       = sizeof(DIPROPDWORD); <br>dipdw.diph.dwHeaderSize = sizeof(dipdw.diph); <br>dipdw.diph.dwHow        = DIPH_BYOFFSET; <br>dipdw.dwData            = DEADZONE; <br>    //* set the x-axis range property <br>    dipdw.diph.dwObj         = DIJOFS_X; <br>    hRes = gpdiJoystick-&gt;lpVtbl-&gt;SetProperty(gpdiJoystick, DIPROP_DEADZONE, &amp;dipdw.diph); <br>    if(FAILED(hRes)) <br>    { <br>        OutputDebugString("SetProperty(DEADZONE, X-Axis) failed.\n"); <br>        return FALSE; <br>    } <br>    //* y-axis <br>    dipdw.diph.dwObj         = DIJOFS_Y; <br>    hRes = gpdiJoystick-&gt;lpVtbl-&gt;SetProperty(gpdiJoystick, DIPROP_DEADZONE, &amp;dipdw.diph); <br>    if(FAILED(hRes)) <br>    { <br>        OutputDebugString("SetProperty(DEADZONE, Y-Axis) failed.\n"); <br>        return FALSE; <br>    } <br> <br>    // set the ForceFeedback gain <br>    // <br>    // If the device supports feedback, use the user selected gain level <br>    // to scale the strength of the forces applied to the stick.  We do this <br>    // so that if a small child is playing the game, the stick does not jerk <br>    // hard enough to hurt them, yet an adult can have a stronger force <br>    // experience <br>    if(fIsFFDevice) <br>    { <br>        // BUGBUG get setting from user (done somewhere else) <br>        dwGain = FF_ADULT; <br>    } <br> <br>    // Acquire the device(s) <br>    // <br>    // This is being done as a convenience since we unacquired earlier in <br>    // this function.  This does not guarantee that the device will be <br>    // acquired at the time we return from the function (in other words, we <br>    // are not going to spin here until we get a succeessful acquisition). <br>    inputAcquireDevices(); <br> <br>    // we've actually done somthing here <br>    return TRUE; <br> <br>} //** end inputPrepareDevice() <br> <br> <br>//=========================================================================== <br>// inputPlayEffect <br>// <br>// Plays specified effect object. <br>// <br>// Parameters: <br>// <br>// Returns: <br>// <br>//=========================================================================== <br>BOOL inputPlayEffect(DWORD dwEffectFlags, LONG lDirection) <br>{ <br>    HRESULT         hRes; <br>    DIEFFECT        diEffect; <br>    LONG            rglDirections[2] = { 0, 0 }; <br> <br>    // initialize DIEFFECT structure <br>    ZeroMemory(&amp;diEffect, sizeof(DIEFFECT)); <br>    diEffect.dwSize = sizeof(DIEFFECT); <br> <br>    // play "bounce" effect? <br>    if(dwEffectFlags &amp; EF_BOUNCE) <br>    { <br>        if(gpdieBounce) <br>        { <br>            // set the direction <br>            // <br>            // since this is a polar coordinate effect, we will pass the angle <br>            // in as the direction relative to the x-axis, and will leave 0 <br>            // for the y-axis direction <br>            // <br>            // Direction is passed in in degrees, we convert to 100ths <br>            // of a degree to make it easier for the caller. <br>            rglDirections[0]        = lDirection * 100; <br>            diEffect.dwFlags        = DIEFF_OBJECTOFFSETS | DIEFF_POLAR; <br>            diEffect.cAxes          = 2; <br>            diEffect.rglDirection   = rglDirections; <br>            hRes = gpdieBounce-&gt;lpVtbl-&gt;SetParameters(gpdieBounce, <br>                                                        &amp;diEffect, <br>                                                        DIEP_DIRECTION); <br>            if(FAILED(hRes)) <br>            { <br>                OutputDebugString("SetParameters(Bounce effect) failed\n"); <br>                return FALSE; <br>            } <br> <br>            // play the effect <br>            hRes = gpdieBounce-&gt;lpVtbl-&gt;Start(gpdieBounce, 1, 0); <br>            if(FAILED(hRes)) <br>            { <br>                OutputDebugString("Start(Bounce effect) failed\n"); <br>                return FALSE; <br>            } <br> <br>        } <br> <br>    } //** end if(play bounce) <br> <br>    // play "fire" effect? <br>    if(dwEffectFlags &amp; EF_FIRE) <br>    { <br>        if(gpdieFire) <br>        { <br>            // play the effect <br>            hRes = gpdieFire-&gt;lpVtbl-&gt;Start(gpdieFire, 1, 0); <br>            if(FAILED(hRes)) <br>            { <br>                OutputDebugString("Start(Fire effect) failed\n"); <br>                return FALSE; <br>            } <br>        } <br>    } //** end if(play fire) <br> <br>    // play "explode" effect? <br>    if(dwEffectFlags &amp; EF_EXPLODE) <br>    { <br>        if(gpdieExplode) <br>        { <br>            // BUGBUG how many iterations of the effect?? <br>            hRes = gpdieExplode-&gt;lpVtbl-&gt;Start(gpdieExplode, 1, 0); <br>            if(FAILED(hRes)) <br>            { <br>                OutputDebugString("Start(Explode effect) failed\n"); <br>                return FALSE; <br>            } <br>        } <br>    } //** end if(play explode) <br> <br>    return TRUE; <br> <br>} //*** end inputPlayEffect() <br> <br> <br>//=========================================================================== <br>// inputForceLevelDlgProc <br>// <br>// Dialog proceedure for handling the Force Level dialog box. <br>// <br>// Parameters: <br>// <br>// Returns: <br>// <br>//=========================================================================== <br>BOOL CALLBACK inputForceLevelDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, <br>                                    LPARAM lParam) <br>{ <br>    int nSelection = 0; <br> <br>    switch(uMsg) <br>    { <br>        case WM_INITDIALOG: <br>             // select default / current setting <br>             switch(dwGain) <br>             { <br>                case FF_CHILD: <br>                     nSelection = IDC_CHILD; <br>                     break; <br> <br>                case FF_BODYBUILDER: <br>                     nSelection = IDC_BODYBUILDER; <br>                     break; <br> <br>                case FF_ADULT: <br>                default: <br>                     nSelection = IDC_ADULT; <br>                     break; <br>             } <br>             CheckRadioButton(hWnd, IDC_CHILD, IDC_BODYBUILDER, nSelection); <br>             return TRUE; <br> <br>        case WM_COMMAND: <br>             { <br>                switch(LOWORD(wParam)) <br>                { <br>                    case IDOK: <br>                         // get user's force level selection <br>                         // BUGBUG <br>                         if(IsDlgButtonChecked(hWnd, IDC_CHILD)) <br>                         { <br>                            OutputDebugString("Child level\n"); <br>                            dwGain = FF_CHILD; <br>                         } <br>                         else if(IsDlgButtonChecked(hWnd, IDC_BODYBUILDER)) <br>                         { <br>                            OutputDebugString("Bodybuilder level\n"); </code></pre>
<p>
</p>
<pre><code>dwGain = FF_BODYBUILDER; <br>                         } <br>                         else <br>                         { <br>                            OutputDebugString("Adult level (Default)\n"); <br>                            dwGain = FF_ADULT; <br>                         } <br>                         EndDialog(hWnd, 0); <br>                         break; <br>                } <br> <br>             } <br>             break; <br> <br>    } <br> <br>    return FALSE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
