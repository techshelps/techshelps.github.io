<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>D3DWIN.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2987"></a>D3DWIN.CPP</h2>
<pre><code>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       D3DWin.cpp <br>**  Purpose:     <br>** <br>**Basic Initialization proceeds as follows: <br>** <br>**1.  Enumerate all Driver, modes, D3D devices (see DrvMgr.cpp for details) <br>**2.  Choose a starting driver, mode, D3D device <br>**- default driver = primary display driver (lpGuidDD = NULL) <br>**- default mode   = current desktop <br>**- default device = D3D device compatible with desktop mode <br>**3.  Validate driver, mode, D3D device <br>**4.  Create interfaces (from DD driver) <br>**  5.  Set window (from associated window handle) <br>**  6.  Create DD/D3D interfaces (lpDD, lpDD2, lpD3D) <br>**  7.  Create Primary surface (primary palette, if necessary) <br>**- Attach a clipper to primary surface <br>**  8.  Create Render surface  <br>**- Render surface (and associated Z-buffer) <br>**- D3D Device  <br>**- D3D Viewport <br>** <br>**  After initialization is complete, we have the <br>**following objects necessary for rendering: <br>** <br>**lpDD2 - DirectDraw interface, used for creating texture surfaces <br>**lpD3D - Direct3D interface, used for creating materials, lights, viewports <br>**lpD3DDevice - D3D device (current material, current viewport, etc.) <br>**lpViewport - current viewport <br>**lpPrimary  - front buffer <br>**lpRender   - render target <br>** <br>**  Copyright (c) 1995 - 1997 by Microsoft, all rights reserved <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Includes <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>#include "D3DWin.h" <br>#include "WinProc.h" <br>#include "D3DScene.h" <br>#include "Debug.h" <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**D3DWindow Methods <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::D3DWindow <br>** Purpose: Default Constructor <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>D3DWindow::D3DWindow (void) <br>{ <br>    ZeroMemory (this, sizeof(D3DWindow)); <br>    this-&gt;dwSize = sizeof(D3DWindow); <br> <br>// Default to creating a z-buffer <br>createZBufferOn (); <br>} // End D3DWindow::D3DWindow () <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::~D3DWindow <br>** Purpose: Destructor <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>D3DWindow::~D3DWindow (void) <br>{ <br>// Destroy all objects <br>    Fini (); <br> <br>// Mark all other pointers as invalid <br>// In case user tries to reuse this object <br>lpCurrDriver = NULL; <br>lpCurrMode = NULL; <br>lpCurrDevice = NULL; <br>hWindow = NULL; <br>lpd3dScene = NULL; <br> <br>} // End D3DWindow::~D3DWindow <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::Create <br>** Purpose: Creates a D3DWindow  <br>** <br>** Basic Algorithm: <br>**- Validate parameters <br>**- Choose (and validate choices) for driver, mode, device <br>**- Create Interfaces <br>**- Set Window <br>**- Set Mode <br>**- Create Primary surface (and palette) <br>**- Create Render surface (and D3D device) <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::Create ( <br>HWND   hWnd,/* In:  Window */ <br>LPGUID lpGuidDD,/* In:  Requested DirectDraw Device */ <br>DWORD  dwW,/* In:Requested Mode */ <br>DWORD  dwH, <br>DWORD  dwBPP, <br>DWORD  dwRefresh, <br>LPGUID lpGuidD3D,/* In:  Requested D3D device */ <br>BOOL   fUseZBuffer) /* In:  Create Z-Buffer */ <br>{ <br>    HRESULT         hResult; <br> <br>    // Check parameters <br>if ((! hWnd) || (! IsWindow (hWnd))) <br>{ <br>// Error, Invalid parameters <br>hResult = APPERR_INVALIDPARAMS; <br>REPORTERR (hResult); <br>return hResult; <br>} <br> <br>// Set Current Window <br>hWindow = hWnd; <br> <br>    // Set Use Z-Buffer On/Off <br>    if (fUseZBuffer) <br>        createZBufferOn (); <br>    else <br>        createZBufferOff (); <br> <br>    // Choose Default Driver, Mode, device  <br>    hResult = ChooseDriverDefaults (lpGuidDD,  <br>dwW, dwH, dwBPP, dwRefresh, <br>lpGuidD3D, <br>TRUE, <br>&amp;lpCurrDriver, <br>&amp;lpCurrMode, <br>&amp;lpCurrDevice); <br>    if (FAILED (hResult)) <br>        return hResult; <br>     <br>    // Create DD/D3D Interface objects <br>    hResult = InitInterfaces (); <br>    if (FAILED (hResult)) <br>        return hResult; <br> <br>// Attach window to DD interface <br>hResult = InitWindow (); <br>if (FAILED (hResult)) <br>goto lblCLEANUP; <br> <br>// Set Fullscreen Mode <br>hResult = InitFullscreenMode (); <br>if (FAILED (hResult)) <br>goto lblCLEANUP; <br> <br>    // Create Primary Surface (and palette) <br>    hResult = InitPrimary (); <br>    if (FAILED (hResult)) <br>        goto lblCLEANUP; <br> <br>// Create the Render Surface (and D3D Device) <br>    hResult = InitRender (); <br>    if (FAILED (hResult)) <br>        goto lblCLEANUP; <br> <br>// Notify the window of a successful initialization <br>SendMessage (hWindow, D3DWIN_INIT, 0, (LPARAM)(void *)this); <br> <br>    // Success <br>    return DD_OK; <br> <br>lblCLEANUP: <br>// Failure <br> <br>    // Cleanup <br>    Fini (); <br> <br>    return hResult; <br>} // End D3DWindow::Create <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::Init <br>** Purpose:  <br>** <br>** Basic Algorithm: <br>**- Validate driver, mode, device <br>**- Create Interfaces <br>**- Attach Window <br>**- Set Fullscreen Mode <br>**- Create Primary surface (and palette) <br>**- Create Render surface (and D3D device) <br>** <br>** Notes: <br>**1.  Assumes that a valid window handle has already <br>**been associated with this D3DWindow <br>**2.  Assumes that driver, mode, device already choosen <br>**- however if not, reasonable defaults will be choosen <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::Init (void) <br>{ <br>    HRESULT         hResult; <br> <br>    // Check parameters <br>if ((! hWindow) || (! IsWindow (hWindow))) <br>{ <br>// Error, Invalid Initialization <br>hResult = APPERR_NOTINITIALIZED; <br>REPORTERR (hResult); <br>return hResult; <br>} <br> <br>    // Validate Curr Driver, mode, device <br>hResult = ValidateDefaults (); <br>if (FAILED (hResult)) <br>return hResult; <br> <br>    // Create DD/D3D Interface objects <br>    hResult = InitInterfaces (); <br>    if (FAILED (hResult)) <br>goto lblCLEANUP; <br> <br>// Attach the window to the DD interface <br>hResult = InitWindow (); <br>if (FAILED (hResult)) <br>goto lblCLEANUP; <br> <br>// Set the Mode <br>hResult = InitFullscreenMode (); <br>if (FAILED (hResult)) <br>goto lblCLEANUP; <br> <br>    // Create Primary Surface (and palette) <br>    hResult = InitPrimary (); <br>    if (FAILED (hResult)) <br>        goto lblCLEANUP; <br> <br>// Create Render surface (and D3D device) <br>    hResult = InitRender (); <br>    if (FAILED (hResult)) <br>        goto lblCLEANUP; <br> <br>// Notify the window of a successful initialization <br>SendMessage (hWindow, D3DWIN_INIT, 0, (LPARAM)(void *)this); <br> <br>    // Success <br>    return DD_OK; <br> <br>lblCLEANUP: <br>// Failure  <br> <br>    // Cleanup <br>    Fini (); <br>    return hResult; <br>} // End D3DWindow::Init <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::Fini <br>** Purpose: Destroys a D3DWindow <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::Fini (void) <br>{ <br>// Notify the window that we are cleaning up <br>SendMessage (hWindow, D3DWIN_FINI, 0, (LPARAM)(void *)this); <br> <br>// Cleanup <br>    FiniRender (); <br>    FiniPrimary (); <br>FiniFullscreenMode (); <br>//FiniWindow (); <br>    FiniInterfaces (); <br> <br>// Success <br>return DD_OK; <br>} // End D3DWindow::Fini <br> <br> <br>   <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::ValidateDefaults <br>** Purpose: Verify's current driver, mode, and device <br>** Notes:    <br>** <br>**1.  Rather than fail completely, this will pick new defaults <br>**      if the current defaults don't work. <br>** <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::ValidateDefaults (void) <br>{ <br>LPGUIDlpGuidDD, lpGuidD3D; <br>HRESULThResult; <br>    LPDDDrvInfolpDrvNew; <br>LPDDModeInfolpModeNew; <br>LPD3DDevInfolpDevNew; <br> <br>// Initialize Driver Manager, if necessary <br>if (! DDDrvMgr::isInitialized ()) <br>{ <br>hResult = DDDrvMgr::Init (); <br>if (FAILED (hResult)) <br>return hResult; <br>} <br>     <br>    // Get DD Guid <br>if (lpCurrDriver) <br>lpGuidDD = lpCurrDriver-&gt;GetGuid (); <br>else <br>lpGuidDD = NULL; <br> <br>// Get D3D Guid <br>if (lpCurrDevice) <br>lpGuidD3D = &amp;(lpCurrDevice-&gt;guid); <br>else <br>lpGuidD3D = NULL; <br> <br>// Get Driver corresponding to DD Guid <br>    lpDrvNew = ValidateDriver (lpGuidDD); <br>if (! lpDrvNew) <br>    { <br>        // Error, invalid DD Guid <br>hResult = APPERR_INVALIDPARAMS; <br>REPORTERR (hResult); <br>        return hResult; <br>    } <br> <br>DWORD w, h, bpp, refresh; <br> <br>// Get Current mode info <br>if (lpCurrMode) <br>lpCurrMode-&gt;GetMode (w, h, bpp, refresh); <br>else <br>{ <br>w = h = bpp = refresh = 0; <br>} <br> <br>// Get Fullscreen D3D device and compatible mode <br>if (! GetFullscreenMode (lpDrvNew, lpGuidD3D, <br> w, h, bpp, refresh, <br> &amp;lpModeNew, &amp;lpDevNew)) <br>{ <br>// Couldn't find a valid mode and/or device <br>hResult = APPERR_GENERIC; <br>REPORTERR (hResult); <br>return APPERR_GENERIC; <br>} <br> <br>// Note:  Instead of complaining let's go ahead <br>//  and use the new defaults <br>// Save new defaults <br>lpCurrDriver = lpDrvNew; <br>lpCurrMode = lpModeNew; <br>lpCurrDevice = lpDevNew; <br> <br>    // Success <br>    return DD_OK; <br>} // End D3DWindow::ValidateDefaults <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::CreateInterfaces <br>** Purpose: Creates DD/D3D interfaces from specified Guid <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::CreateInterfaces (LPGUID lpDDGuid) <br>{ <br>LPDDDrvInfo lpDrvNew; <br>HRESULThResult; <br> <br>// Verify Guid <br>lpDrvNew = ValidateDriver (lpDDGuid); <br>if (! lpDrvNew) <br>{ <br>// Invalid Params <br>hResult = APPERR_INVALIDPARAMS; <br>REPORTERR (hResult); <br>return hResult; <br>} <br> <br>lpCurrDriver = lpDrvNew; <br> <br>hResult = D3DWindow::InitInterfaces (); <br>if (FAILED (hResult)) <br>return hResult; <br> <br>// Success <br>return DD_OK; <br>} // End D3DWindow::CreateInterfaces <br> <br>   <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::InitInterfaces <br>** Purpose: Creates DD/D3D interfaces <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::InitInterfaces (void) <br>{ <br>    HRESULT         hResult; <br>    LPGUID          lpGuid; <br> <br>    // Do we have a current DD Driver <br>    if (! lpCurrDriver) <br>    { <br>// So, Grab the Primary DD driver <br>lpCurrDriver = ValidateDriver (NULL); <br>if (! lpCurrDriver) <br>{ <br>// Error, No current Driver <br>hResult = APPERR_NOTINITIALIZED; <br>REPORTERR (hResult); <br>return hResult; <br>} <br>    } <br> <br>    // Get DD Guid <br>    lpGuid = lpCurrDriver-&gt;GetGuid (); <br>     <br>    // Create DD interface <br>    hResult = DirectDrawCreate (lpGuid, &amp;lpDD, NULL); <br>    if (FAILED (hResult)) <br>    { <br>        // Error <br>REPORTERR (hResult); <br>goto lblCLEANUP; <br>    } <br> <br>    // Get DD2 interface <br>    hResult = lpDD-&gt;QueryInterface ((REFIID)IID_IDirectDraw2, (void **)&amp;lpDD2); <br>    if (FAILED (hResult)) <br>    { <br>        // Error <br>REPORTERR (hResult); <br> <br>// Inform User that they Need DX 5.0 installed <br>        MessageBox (hWindow, TEXT ("This app requires DirectX 5.0"), TEXT("Error"), MB_OK); <br>        goto lblCLEANUP; <br>    } <br> <br>    // Get D3D interface <br>    hResult = lpDD2-&gt;QueryInterface ((REFIID)IID_IDirect3D2, (void **)&amp;lpD3D); <br>    if (FAILED (hResult)) <br>    { <br>        // Error <br>REPORTERR (hResult); <br>        goto lblCLEANUP; <br>    } <br> <br>// Mark this stage as done <br>turnValidInterfaceOn (); <br> <br>    // Success <br>    return DD_OK; <br> <br>lblCLEANUP: <br>    // Failure <br>    FiniInterfaces (); <br> <br>    return hResult; <br>} // End InitInterfaces <br> <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::FiniInterfaces <br>** Purpose: Destroys DD/D3D interfaces <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::FiniInterfaces (void) <br>{ <br>// Mark this stage as invalid <br>turnValidInterfaceOff (); <br> <br>    // Release Direct3D Interface <br>    if (lpD3D) <br>    { <br>        lpD3D-&gt;Release (); <br>        lpD3D = NULL; <br>    } <br> <br>    // Release DirectDraw2 Interface <br>    if (lpDD2) <br>    { <br>        lpDD2-&gt;Release (); <br>        lpDD2 = NULL; <br>    } <br> <br>    // Release DirectDraw Interface <br>    if (lpDD) <br>    { <br>        lpDD-&gt;Release (); <br>        lpDD = NULL; <br>    } <br> <br>// Success <br>return DD_OK; <br>} // End D3DWindow::FiniInterfaces <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::InitWindow <br>** Purpose: Attaches Window to Direct Draw Interface <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::InitWindow (void) <br>{ <br>HRESULT hResult; <br>DWORDdwFlags; <br> <br>// Check Initialization <br>if ((! hWindow) || (! IsWindow (hWindow))) <br>{ <br>// Error, we need a valid window to continue <br>hResult = APPERR_NOTINITIALIZED; <br>REPORTERR (hResult); <br>return hResult; <br>} <br> <br>    // Get Cooperative Flags <br>    dwFlags = DDSCL_EXCLUSIVE | DDSCL_FULLSCREEN; <br> <br>    // Set Cooperative Level <br>    hResult = lpDD2-&gt;SetCooperativeLevel (hWindow, dwFlags); <br>    if (FAILED (hResult)) <br>    { <br>        // Error <br>        REPORTERR (hResult); <br>return hResult; <br>    } <br> <br>// Success <br>return DD_OK; <br>} // End D3DWindow::InitWindow <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::FiniWindow <br>** Purpose: Cleanups window <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::FiniWindow (void) <br>{ <br>// Currently does nothing <br> <br>// Success <br>return DD_OK; <br>} // End D3DWindow::FiniWindow <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**Name:D3DWindow::InitFullscreenMode <br>**Purpose:Switches to requested fullscreen mode <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::InitFullscreenMode (void) <br>{ <br>HRESULT hResult; <br>DWORD   dwFlags = 0; <br> <br>// Check Initialization <br>if ((! lpCurrMode) || (! lpDD2)) <br>{ <br>// Error, we need a valid mode and DirectDraw 2 interface to proceed <br>hResult = APPERR_NOTINITIALIZED; <br>REPORTERR (hResult); <br>return hResult; <br>} <br>         <br>// Calculate Mode info <br>DWORD w, h, bpp, refresh; <br>lpCurrMode-&gt;GetMode (w, h, bpp, refresh); <br> <br>// Special check for mode 320 x 200 x 8 <br>if ((w == 320) &amp;&amp; (h == 200) &amp;&amp; (bpp == 8)) <br>    { <br>// Make sure we use Mode 13 instead of Mode X <br>dwFlags = DDSDM_STANDARDVGAMODE; <br>    }  <br> <br>    // Set Requested Fullscreen mode <br>    hResult = lpDD2-&gt;SetDisplayMode (w, h, bpp, refresh, dwFlags); <br>    if (SUCCEEDED (hResult)) <br>{ <br>// Save Surface Rectangle <br>rSurf.left   = 0; <br>rSurf.top    = 0; <br>rSurf.right  = w; <br>rSurf.bottom = h; <br> <br>// Success <br>turnValidFullscreenOn (); <br>return hResult; <br>} <br> <br>DPF (DEBUG_ERROR, "SetDisplayMode failed (%d x %d x %d), trying (640 x 480 x %d)", w, h, bpp, bpp); <br> <br>// Don't give up! <br>// Try 640 x 480 x bpp mode instead <br>if ((w != 640 || h != 480)) <br>    { <br>w = 640; <br>h = 480; <br> <br>lpCurrMode = ValidateMode (lpCurrDriver, w, h, bpp, 0, lpCurrDevice); <br>if (lpCurrMode) <br>{ <br>hResult = lpDD2-&gt;SetDisplayMode (w, h, bpp, 0, 0); <br>if (SUCCEEDED (hResult)) <br>{ <br>// Save Surface Rectangle <br>rSurf.left   = 0; <br>rSurf.top    = 0; <br>rSurf.right  = w; <br>rSurf.bottom = h; <br> <br>// Success <br>turnValidFullscreenOn (); <br>return hResult; <br>} <br>} <br>} <br> <br>// Keep trying <br>// Try 640 x 480 x 16 mode instead <br>if (bpp != 16) <br>    { <br>DPF (DEBUG_ERROR, "SetDisplayMode failed (640 x 480 x %d), trying (640 x 480 x 16)", bpp); <br>bpp = 16; <br> <br>lpCurrMode = ValidateMode (lpCurrDriver, w, h, bpp, 0, lpCurrDevice); <br>if (lpCurrMode) <br>{ <br>hResult = lpDD2-&gt;SetDisplayMode (w, h, bpp, 0, 0); <br>if (SUCCEEDED (hResult)) <br>{ <br>// Save Surface Rectangle <br>rSurf.left   = 0; <br>rSurf.top    = 0; <br>rSurf.right  = w; <br>rSurf.bottom = h; <br> <br>// Success <br>turnValidFullscreenOn (); <br>return hResult; <br>} <br>} <br>} <br> <br>// Failure <br>REPORTERR (hResult); <br>return hResult; <br>} // End D3DWindow::InitFullscreenMode <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**Name:D3DWindow::FiniFullscreenMode <br>**Purpose:Restores mode to original desktop <br>**Notes:This does nothing if we are windowed <br>**I.E. the user already is restored <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::FiniFullscreenMode (void) <br>{ <br>turnValidFullscreenOff (); <br> <br>// Restore original desktop mode <br>if (lpDD2) <br>lpDD2-&gt;RestoreDisplayMode(); <br> <br>// Success <br>return DD_OK; <br>} // End D3DWindow::FiniFullscreenMode <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::InitPrimary <br>** Purpose: Creates a primary surface (desktop surface) <br>** Notes:   Also creates and attaches palette, if necessary <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::InitPrimary (void) <br>{ <br>    HRESULThResult; <br>    DDSURFACEDESCddsd; <br> <br>    // Check Initialization <br>    if ((! lpCurrMode) || (! lpDD2)) <br>    { <br>        // Error, Need a valid mode and DD interface to proceed <br>hResult = APPERR_NOTINITIALIZED; <br>REPORTERR (hResult); <br>        return hResult; <br>    } <br> <br>// Note:  There is no need to fill in width, height, bpp, etc. <br>//        This was taken care of in the SetDisplayMode call. <br> <br>// Setup Surfaces caps for a front buffer and back buffer <br>    ddsd.dwSize= sizeof(ddsd); <br>    ddsd.dwFlags= DDSD_CAPS | DDSD_BACKBUFFERCOUNT; <br>    ddsd.ddsCaps.dwCaps= DDSCAPS_PRIMARYSURFACE |  <br>  DDSCAPS_FLIP |  <br>  DDSCAPS_COMPLEX | <br>  DDSCAPS_3DDEVICE;// Create a D3D compatible surface <br>    ddsd.dwBackBufferCount= 1; <br> <br>// Create Primary surface <br>    hResult = lpDD2-&gt;CreateSurface (&amp;ddsd, &amp;lpddsPrimary, NULL); <br>    if (FAILED (hResult)) <br>    { <br>        // Error <br>        REPORTERR (hResult); <br>        return hResult; <br>    } <br> <br>// Create and attach palette, if necessary <br>hResult = InitPalette (); <br>if (FAILED (hResult)) <br>return hResult; <br> <br>// Mark as Valid <br>turnValidPrimaryOn (); <br> <br>    // Success <br>    return DD_OK; <br>} // End D3DWindow::InitPrimary <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::FiniPrimary <br>** Purpose: Destroys the Primary Surface <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::FiniPrimary (void) <br>{ <br>// Mark as Invalid <br>turnValidPrimaryOff (); <br> <br>// Cleanup palette <br>FiniPalette (); <br> <br>    // Release Primary Surface Object <br>    if (lpddsPrimary) <br>    { <br>        lpddsPrimary-&gt;Release (); <br>        lpddsPrimary = NULL; <br>    } <br> <br>// Success <br>return DD_OK; <br>} // End D3DWindow::FiniPrimary <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::InitPalette <br>** Purpose: Creates a primary palette if necessary <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::InitPalette () <br>{ <br>    HRESULT             hResult; <br>    HDC                 hdc; <br>    DWORD               ii; <br>    DWORD               cbSize; <br>    DWORD               dwFlags; <br>    DDSURFACEDESC       ddsd; <br> <br>    // Destroy old palette <br>    FiniPalette (); <br> <br>    // Make sure we are properly intialized  <br>    // for this to work <br>    if ((! lpDD2) || (! lpddsPrimary)) <br>    { <br>        // Error, need a valid DD interfac and a primary surface to continue <br>hResult = APPERR_NOTINITIALIZED; <br>REPORTERR (hResult); <br>        return hResult; <br>    } <br> <br>    // Get primary surface caps <br>    ZeroMemory(&amp;ddsd, sizeof(ddsd)); <br>    ddsd.dwSize = sizeof(ddsd); <br>    hResult = lpddsPrimary-&gt;GetSurfaceDesc(&amp;ddsd); <br>    if (FAILED (hResult)) <br>    { <br>        // Error <br>        REPORTERR (hResult); <br>        return hResult; <br>    } <br> <br>    // Make sure it is a palettized surface <br>    if (! isPalettized (&amp;(ddsd.ddpfPixelFormat))) <br>    { <br>        // Success, primary isn't palettized <br>// So we don't need to create a palette <br>        return DD_OK; <br>    } <br> <br>    // Create and save System palette <br>    hdc = GetDC (NULL); <br>    cPalette = GetDeviceCaps (hdc, SIZEPALETTE); <br>    if (cPalette) <br>    { <br>        if (cPalette &gt; 256) <br>            cPalette = 256; <br> <br>        // Get memory for system palette <br>        lppeSystem = new PALETTEENTRY[cPalette]; <br>        if (! lppeSystem) <br>        { <br>ReleaseDC (NULL, hdc); <br> <br>            // Error, not enough memory <br>hResult = APPERR_OUTOFMEMORY; <br>REPORTERR (hResult); <br>goto lblCLEANUP; <br>        } <br> <br>// Get Memory for current palette <br>lppeCurr = new PALETTEENTRY[cPalette]; <br>if (! lppeCurr) <br>{ <br>ReleaseDC (NULL, hdc); <br> <br>            // Error, not enough memory <br>hResult = APPERR_OUTOFMEMORY; <br>REPORTERR (hResult); <br>goto lblCLEANUP; <br> <br>} <br> <br>        // Save system palette <br>        GetSystemPaletteEntries (hdc, 0, cPalette, lppeSystem); <br> <br>        // Copy system palette to temporary values <br>        cbSize = cPalette * sizeof (PALETTEENTRY); <br>        CopyMemory (lppeCurr, lppeSystem, cbSize); <br>    } <br>ReleaseDC (NULL, hdc); <br> <br>    if (ddsd.ddpfPixelFormat.dwFlags &amp; DDPF_PALETTEINDEXED1) <br>    { <br>        dwFlags = DDPCAPS_1BIT; <br> <br>        // Only 2 palette entries, we need them all <br>        for (ii = 0; ii &lt; 2; ii++) <br>            lppeCurr[ii].peFlags = D3DPAL_FREE | PC_RESERVED; <br> <br>    } <br>    else if (ddsd.ddpfPixelFormat.dwFlags &amp; DDPF_PALETTEINDEXED2) <br>    { <br>        // Only 4 palette entries, we need them all <br>        for (ii = 0; ii &lt; 4; ii++) <br>            lppeCurr[ii].peFlags = D3DPAL_FREE | PC_RESERVED; <br> <br>        dwFlags = DDPCAPS_2BIT; <br>    } <br>    else if (ddsd.ddpfPixelFormat.dwFlags &amp; DDPF_PALETTEINDEXED4) <br>    { <br>        // Only 16 palette entries, we will save black and white <br>        // and keep the rest for ourselves. <br> <br>        lppeCurr[0].peFlags = D3DPAL_READONLY; <br>        lppeCurr[15].peFlags = D3DPAL_READONLY; <br> <br>        for (ii = 1; ii &lt; 15; ii++) <br>            lppeCurr[ii].peFlags = D3DPAL_FREE | PC_RESERVED; <br> <br>        dwFlags = DDPCAPS_4BIT; <br>    } <br>    else if (ddsd.ddpfPixelFormat.dwFlags &amp; DDPF_PALETTEINDEXED8) <br>    { <br>        // 256 palette entries, we can afford to be nice <br>        // and save the first 10 and last 10 palette entries <br>        // for system use  <br>        for (ii = 0; ii &lt; 10; ii++) <br>        { <br>            lppeCurr[ii].peFlags = D3DPAL_READONLY; <br>            lppeCurr[246+ii].peFlags = D3DPAL_READONLY; <br>        } <br> <br>        for (ii = 10; ii &lt; 246; ii++) <br>            lppeCurr[ii].peFlags = D3DPAL_FREE | PC_RESERVED; <br> <br>        dwFlags = DDPCAPS_8BIT;         <br>    } <br>    else <br>    { <br>        // Error, programming (unknown palette type) <br>hResult = APPERR_GENERIC; <br>REPORTERR (hResult); <br>goto lblCLEANUP; <br>    } <br> <br>    // Create Primary Palette <br>    hResult = lpDD2-&gt;CreatePalette (dwFlags, <br>                                    lppeCurr, <br>                                    &amp;lpddpPalette, <br>                                    NULL); <br>    if (FAILED (hResult)) <br>    { <br>        REPORTERR (hResult); <br>        goto lblCLEANUP; <br>    } <br> <br>    // Attach palette to primary surface <br>    hResult = lpddsPrimary-&gt;SetPalette (lpddpPalette); <br>    if (FAILED (hResult)) <br>    { <br>        // Error <br>        REPORTERR (hResult); <br>        goto lblCLEANUP; <br>    } <br> <br>    // Success <br>    return DD_OK; <br> <br>lblCLEANUP: <br>// Failure <br> <br>// Cleanup <br>FiniPalette (); <br>return hResult; <br>} // D3DWindow::InitPalette <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::FiniPalette <br>** Purpose: Destroys primary palette <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::FiniPalette (void) <br>{ <br>    // Note:  Should we Detach Palette object from surfaces <br>    // No way to do this that I know of... <br>     <br>    // Cleanup up DD Palette object <br>    if (lpddpPalette) <br>    { <br>        lpddpPalette-&gt;Release (); <br>        lpddpPalette = NULL; <br>    } <br> <br>// Cleanup Current Palette <br>if (lppeCurr) <br>{ <br>delete [] lppeCurr; <br>lppeCurr = NULL; <br>} <br> <br>    // Cleanup System Palette <br>    if (lppeSystem) <br>    { <br>        // Note:  Should we try and restore system palette here ?!? <br> <br>        // Destroy system palette <br>        delete [] lppeSystem; <br>        lppeSystem = NULL; <br>    } <br> <br>cPalette = 0; <br> <br>// Success <br>return DD_OK; <br>} // End FiniPalette <br> <br> <br>     <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::CreateRender <br>** Purpose: Creates the rendering surface and D3D device <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::CreateRender (LPGUID lpD3DGuid) <br>{ <br>HRESULT hResult; <br>LPD3DDevInfo lpDevNew; <br>LPDDModeInfo lpModeNew; <br> <br>// Check Initialization <br>if ((! lpCurrDriver) || (! lpCurrMode)) <br>{ <br>hResult = APPERR_NOTINITIALIZED; <br>REPORTERR (hResult); <br>return hResult; <br>} <br> <br>// Validate D3D Device <br>lpDevNew = ValidateDevice (lpCurrDriver, lpD3DGuid, NULL); <br>if (! lpDevNew) <br>{ <br>hResult = APPERR_INVALIDPARAMS; <br>REPORTERR (hResult); <br>return hResult; <br>} <br> <br>DWORD w, h, bpp, refresh; <br>lpCurrMode-&gt;GetMode (w, h, bpp, refresh); <br> <br>// Validate Mode with this D3D Device <br>lpModeNew = ValidateMode (lpCurrDriver, w, h, bpp, 0, lpDevNew); <br>if (! lpModeNew) <br>{ <br>hResult = APPERR_INVALIDPARAMS; <br>REPORTERR (hResult); <br>return hResult; <br>} <br> <br>// Do we need to Change the Mode as well <br>// to stay in synch with the new D3D device ?!? <br>if (lpModeNew != lpCurrMode) <br>{ <br>// Save old mode <br>LPDDModeInfo lpModeOld = lpCurrMode; <br> <br>// Try to switch modes <br>lpCurrMode = lpModeNew; <br>hResult = InitPrimary (); <br>if (FAILED (hResult)) <br>{ <br>// Try to restore old mode and exit with error <br>lpCurrMode = lpModeOld; <br>InitPrimary (); <br>return hResult; <br>} <br> <br>// Successfully switched modes <br>} <br> <br>// Save new D3D device <br>lpCurrDevice = lpDevNew; <br> <br>// Create new Render surface (using new Device) <br>hResult = InitRender (); <br>if (FAILED (hResult)) <br>return hResult; <br> <br>// Success <br>return DD_OK; <br>} <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::InitRender <br>** Purpose: Creates the rendering surface and D3D device <br>** Notes: <br>** <br>**1.  Catch 22:  To creating a D3D device you need it's render surface <br>**First.  But in order to create a render surface properly you need <br>**      to know the D3D device desc characteristics first.   Fortunately we  <br>**already have this information.  Because we store it awy in the  <br>**Driver Manager. <br>** <br>**  2.  This same catch 22 prevented us from enumerating Texture formats <br>**      easily in the Driver Manager.  So, we do it here once we have a  <br>**valid D3D device. <br>** <br>** Basic Algorithm: <br>**1. Get pointer to back buffer and use as render surface <br>**  2. Create Z-buffer (optional) <br>**3. Create D3D Device (enumerate Texture Formats) <br>**4. Create Viewport <br>**5. InitScene (optional) <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::InitRender (void) <br>{ <br>    HRESULT         hResult; <br>    DWORD           dwMemType; <br>    LPD3DDEVICEDESC lpDeviceDesc; <br>    DDSURFACEDESC   ddsd; <br>    DDSCAPSddscaps; <br>    DWORD           dwWidth, dwHeight, dwBPP; <br> <br>// Check Initialization <br>    if ((! hWindow) || (! IsWindow (hWindow)) || <br>(! lpCurrDevice) || (! lpCurrMode) ||  <br>(! lpDD2) || (! lpD3D) || (! lpddsPrimary)) <br>    { <br>        // Error, Not initialized properly before calling this method <br>hResult = APPERR_NOTINITIALIZED; </code></pre>
<p>
</p>
<pre><code>REPORTERR (hResult); <br>        return hResult; <br>    } <br> <br>//  <br>// Step 1.  Grab the Render surface (back buffer)  <br>//from the Primary surface (front buffer) <br>// <br>   ddscaps.dwCaps = DDSCAPS_BACKBUFFER; <br>hResult = lpddsPrimary-&gt;GetAttachedSurface (&amp;ddscaps, &amp;lpddsRender); <br>   if (FAILED (hResult)) <br>{ <br>REPORTERR (hResult); <br>return hResult; <br>} <br> <br> <br>// <br>// Step 2.Create and attach Z-buffer (optional) <br>// <br> <br>// Get D3D Device description <br>if (lpCurrDevice-&gt;isHardware ()) <br>{ <br>// Hardware device <br>// Z-buffer has to be in Video memory <br>lpDeviceDesc = &amp;(lpCurrDevice-&gt;d3dHalDesc); <br>dwMemType = DDSCAPS_VIDEOMEMORY; <br>} <br>else <br>{ <br>// Software device  <br>// Z-Buffer has to be in System memory <br>lpDeviceDesc = &amp;(lpCurrDevice-&gt;d3dHelDesc); <br>dwMemType = DDSCAPS_SYSTEMMEMORY; <br>} <br> <br>// Should we create a Z-buffer ?!? <br>    if ((isCreateZBuffer ()) &amp;&amp; (lpDeviceDesc) &amp;&amp; <br>        (0L != lpDeviceDesc-&gt;dwDeviceZBufferBitDepth)) <br>    { <br>// Get Z-buffer surface info (w, h, bpp, video vs. system memory) <br>ddsd.dwSize = sizeof(ddsd); <br>hResult = lpddsPrimary-&gt;GetSurfaceDesc (&amp;ddsd); <br>if (FAILED (hResult)) <br>{ <br>REPORTERR (hResult); <br>return hResult; <br>} <br>dwWidth   = ddsd.dwWidth; <br>dwHeight  = ddsd.dwHeight; <br>dwBPP  = FlagsToBitDepth (lpDeviceDesc-&gt;dwDeviceZBufferBitDepth); <br> <br>        // Create the z-buffer. <br>        ZeroMemory (&amp;ddsd, sizeof(ddsd)); <br>        ddsd.dwSize            = sizeof(ddsd); <br>        ddsd.dwFlags           = DDSD_CAPS   | <br>                                 DDSD_WIDTH  | <br>                                 DDSD_HEIGHT | <br>                                 DDSD_ZBUFFERBITDEPTH; <br>        ddsd.ddsCaps.dwCaps    = DDSCAPS_ZBUFFER | dwMemType; <br>        ddsd.dwWidth           = dwWidth; <br>        ddsd.dwHeight          = dwHeight; <br>        ddsd.dwZBufferBitDepth = dwBPP; <br>        hResult = lpDD2-&gt;CreateSurface (&amp;ddsd, &amp;lpddsZBuff, NULL); <br>        if (FAILED(hResult)) <br>        { <br>            REPORTERR (hResult); <br> <br>            // Note: we may be able to continue without a z buffer <br>// So don't exit <br>        } <br>else <br>{ <br>// Attach Z-buffer to rendering surface <br>hResult = lpddsRender-&gt;AddAttachedSurface (lpddsZBuff); <br>if (FAILED (hResult)) <br>{ <br>REPORTERR (hResult); <br> <br>if (lpddsZBuff) <br>{ <br>lpddsZBuff-&gt;Release (); <br>lpddsZBuff = NULL; <br>} <br> <br>// Note: we may be able to continue without a z buffer <br>// So don't exit <br>} <br>//else <br>//{ <br>// Note:  We could actually release the reference to the <br>//        Z-Buffer here, if we don't need a pointer to it anymore. <br>//        The back-buffer has an attachment to it now and it <br>//        won't go away until the Back-buffer does. <br>// lpddsZBuff-&gt;Release (); <br>// lpddsZBuff = NULL; <br>//} <br>} <br>    } <br> <br> <br>    // <br>    // Step 4.  Create the D3D device interface <br>// <br>hResult = lpD3D-&gt;CreateDevice (lpCurrDevice-&gt;guid, <br>    lpddsRender,  <br>    &amp;lpd3dDevice); <br>    if (FAILED (hResult)) <br>    { <br>        REPORTERR (hResult); <br>        return hResult; <br>    } <br> <br>// Enumerate all Texture formats associated with this D3D device <br>hResult = lpCurrDevice-&gt;LoadFormats (lpd3dDevice); <br>if (FAILED (hResult)) <br>{ <br>// Error, no texture formats <br>// Hope we can run OK without textures <br>} <br> <br>// Mark as valid <br>turnValidRenderOn (); <br> <br> <br>// <br>// Step 5.  Create the viewport <br>// <br>hResult = InitViewport (); <br>if (FAILED (hResult)) <br>return hResult; <br> <br> <br>//  <br>// Step 6.Allow Scene to create all objects dependent on us <br>// <br>if (lpd3dScene) <br>hResult = lpd3dScene-&gt;Attach (); <br> <br>    // Success <br>    return DD_OK; <br>} // End D3DWindow::InitRender <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::FiniRender <br>** Purpose: Destroys the Rendering surface <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::FiniRender (void) <br>{ <br>// Allow Scene to cleanup all objects dependent on us <br>if (lpd3dScene) <br>lpd3dScene-&gt;Detach (); <br> <br>// Cleanup viewport <br>FiniViewport (); <br> <br>// Mark as invalid <br>turnValidRenderOff (); <br> <br>    // Release D3D Device <br>    if (lpd3dDevice) <br>    { <br>        lpd3dDevice-&gt;Release (); <br>        lpd3dDevice = NULL; <br>    } <br> <br>    // Release Z Buffer <br>    if (lpddsZBuff) <br>    { <br>// Detach Z-Buffer from back buffer <br>if (lpddsRender) <br>lpddsRender-&gt;DeleteAttachedSurface (0L, lpddsZBuff); <br> <br>// Release Z-Buffer <br>        lpddsZBuff-&gt;Release (); <br>        lpddsZBuff = NULL; <br>    } <br> <br>    // Release rendering surface <br>    if (lpddsRender) <br>    { <br>        lpddsRender-&gt;Release (); <br>        lpddsRender = NULL; <br>    } <br> <br>// Success <br>return DD_OK; <br>} // End D3DWindow::FiniRender <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       D3DWindow::InitViewport <br>**  Purpose:     <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::InitViewport (void) <br>{ <br>HRESULT hResult; <br> <br>// Check Initialization <br>if ((! lpD3D) || (! lpd3dDevice)) <br>{ <br>// Error, Not properly initialized before calling this method <br>hResult = APPERR_NOTINITIALIZED; <br>        REPORTERR (hResult); <br>        return hResult; <br>} <br> <br>// Create Viewport <br>    hResult = lpD3D-&gt;CreateViewport (&amp;lpd3dViewport, NULL); <br>    if (FAILED (hResult)) <br>    { <br>        REPORTERR (hResult); <br>        return hResult; <br>    } <br> <br>// Attach viewport to D3D device <br>    hResult = lpd3dDevice-&gt;AddViewport (lpd3dViewport); <br>    if (FAILED (hResult)) <br>    { <br>lpd3dViewport-&gt;Release (); <br>lpd3dViewport = NULL; <br> <br>        REPORTERR (hResult); <br>        return hResult; <br>    } <br> <br>// Set up Initial Viewport parameters <br>hResult = UpdateViewport (); <br>    if (FAILED (hResult)) <br>{ <br>lpd3dDevice-&gt;DeleteViewport (lpd3dViewport); <br>lpd3dViewport-&gt;Release (); <br>lpd3dViewport = NULL; <br> <br>        return hResult; <br>} <br> <br>// Mark as valid <br>turnValidViewportOn (); <br> <br>/// Success <br>return DD_OK; <br>} // End D3DWindow::InitViewport <br>   <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       D3DWindow::FiniViewport <br>**  Purpose:    Cleanup viewport <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::FiniViewport (void) <br>{ <br>// Mark as invalid <br>turnValidViewportOn (); <br> <br>// Release D3D viewport <br>    if (lpd3dViewport) <br>    { <br>lpd3dDevice-&gt;DeleteViewport (lpd3dViewport); <br>        lpd3dViewport-&gt;Release (); <br>        lpd3dViewport = NULL; <br>    } <br> <br>// Success <br>return DD_OK; <br>} // End D3DWindow::FiniViewport <br> <br>   <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       D3DWindow::UpdateViewport <br>**  Purpose:    Keeps viewport updated with current window size <br>**  Notes: <br>** <br>**1. The viewport construction here assumes that you are rendering  <br>**Triangles using the D3DVERTEX and D3DIM is doing Transform, <br>**lighting, and rasterization for you. <br>** <br>**2. If you are rendering triangles using D3DTLVERTEX and doing your <br>**   own transform and lighting then you need to setup the viewport <br>**   differently.   As follows: <br>** <br>**      // Replace the following values below: <br>**dvClipX= 0.0f; <br>**dvClipY= 0.0f; <br>**dvClipWidth= dwSurfW; <br>**dvClipHeight= dvSurfH; <br>** <br>**  3. This perserves the aspect ratio.  If you don't need or want to <br>**     perserve the aspect ratio then set inv_aspect = 1.0 below and <br>**     work this constant through the rest of the viewport setup. <br>** <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::UpdateViewport (void) <br>{ <br>    HRESULThResult; <br>    D3DVIEWPORT2d3dViewport; <br>DWORDdwSurfW, dwSurfH; <br> <br>    // Check Parameters <br>if ((! lpd3dDevice) || (! lpd3dViewport)) <br>{ <br>// Not properly initialized before calling this method <br>hResult = APPERR_NOTINITIALIZED; <br>REPORTERR (hResult); <br>return hResult; <br>} <br> <br>// Get Surface Width and Height <br>dwSurfW = abs (rSurf.right - rSurf.left); <br>dwSurfH = abs (rSurf.bottom - rSurf.top); <br> <br>float inv_aspect; <br> <br>if (dwSurfW) <br>inv_aspect = (float)dwSurfH/(float)dwSurfW; <br>else <br>                inv_aspect = 1.0f; <br> <br>    // Update Viewport <br>    ZeroMemory (&amp;d3dViewport, sizeof(d3dViewport)); <br>    d3dViewport.dwSize= sizeof(d3dViewport);     // Always set size of structure!!! <br>    d3dViewport.dwX= 0UL; <br>    d3dViewport.dwY= 0UL; <br>    d3dViewport.dwWidth= dwSurfW; <br>    d3dViewport.dwHeight= dwSurfH; <br>    d3dViewport.dvClipX= -1.0f; <br>    d3dViewport.dvClipY= inv_aspect; <br>    d3dViewport.dvClipWidth= 2.0f; <br>    d3dViewport.dvClipHeight = 2.0f * inv_aspect; <br>    d3dViewport.dvMinZ= 0.0f; <br>    d3dViewport.dvMaxZ= 1.0f; <br> <br>// Update Viewport <br>    hResult = lpd3dViewport-&gt;SetViewport2 (&amp;d3dViewport); <br>    if (FAILED (hResult)) <br>    { <br>        REPORTERR (hResult); <br>        return hResult; <br>    } <br> <br>// Update D3D device to use this viewport <br>    hResult = lpd3dDevice-&gt;SetCurrentViewport (lpd3dViewport); <br>    if (FAILED (hResult)) <br>    { <br>        REPORTERR (hResult); <br>        return hResult; <br>    } <br> <br>    // Success <br>    return DD_OK; <br>} // End D3DWindow::UpdateViewport <br> <br>   <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::DrawFrame <br>** Purpose: Paints current surface to window <br>** Notes:    <br>** <br>**1. Full screen mode - we render to the back buffer <br>**   and then flip the front and back buffers to make the <br>**   changes visible <br>** <br>**  2. Windowed mode - We blt the render surface onto the primary surface <br>** <br>**  3. This routine is not written for optimal performance <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::DrawFrame (void) <br>{ <br>    HRESULT hResult = DD_OK; <br> <br>// Check Initialization <br>    if (! isValid ()) <br>    { <br>        // Error, not properly initialized <br>hResult = APPERR_NOTINITIALIZED; <br>//REPORTERR (hResult); <br>        return hResult; <br>    } <br> <br>    if (isPaused ()) <br>    { <br>        // Don't draw, if paused <br>        return DD_OK; <br>    } <br>     <br>    // Paint until we truly succeed or error out <br>    while (TRUE) <br>    { <br>// Render D3D Scene <br>if (lpd3dScene) <br>hResult = lpd3dScene-&gt;Render (); <br> <br>if (SUCCEEDED (hResult)) <br>{ <br>// Flip Front and Back buffers (Primary, Render) <br>    hResult =lpddsPrimary-&gt;Flip (lpddsRender, 1); <br> <br>// Did it work ?!?   <br>if (SUCCEEDED (hResult)) <br>{ <br>// Success, exit <br>return hResult; <br>} <br>} <br> <br>        // Check if busy or drawing <br>        if ((DDERR_SURFACEBUSY == hResult) || <br>            (DDERR_WASSTILLDRAWING == hResult)) <br>        { <br>            // Try again <br>            continue; <br>        } <br> <br>        // Check for lost surfaces <br>        while (DDERR_SURFACELOST == hResult) <br>        { <br>            // Restore surfaces <br>            hResult = Restore (); <br>        } <br> <br>        // Check for real error <br>        if (FAILED (hResult)) <br>        { <br>            // Error, <br>            REPORTERR (hResult); <br>            return hResult; <br>        } <br>    } <br> <br>    // Success <br>    return DD_OK; <br>} // End D3DWindow::DrawFrame <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::Move <br>** Purpose: Moving full-screen windows not supported <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::Move (long x, long y) <br>{ <br>// Do nothing <br> <br>    // Success <br>    return DD_OK; <br>} // D3DWindow::Move <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::Resize <br>** Purpose: Resizes window <br>** Notes:Resizing Fullscreen windows not supported. <br>**I.E. The Back buffer needs to stay the same size as the front <br>**Buffer. <br>** <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::Resize (DWORD dwWidth, DWORD dwHeight) <br>{ <br>// Do nothing <br> <br>// Success <br>return DD_OK; <br>} // End D3DWindow::Resize  <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       D3DWindow::RealizePalette <br>**  Purpose:     <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::RealizePalette (void) <br>{ <br>HRESULT hResult; <br> <br>// <br>    // Realizing the palette using DirectDraw is quite different <br>    // from GDI. To realize the palette we call SetPalette() <br>    // each time our application is activated. <br>    // <br>    // NOTE: DirectDraw spots the fact that the new palette is the <br>    // same as the old one and so does not increase the reference <br>    // count of the palette. <br>    // <br> <br>if ((lpddsPrimary) &amp;&amp; (lpddpPalette)) <br>{ <br>hResult = lpddsPrimary-&gt;SetPalette (lpddpPalette); <br>if (FAILED (hResult)) <br>        { <br>            REPORTERR (hResult); <br>            return hResult; <br>        } <br>} <br> <br>// Success <br>return DD_OK; <br>} // End D3DWindow::RealizePalette <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::toGDI <br>** Purpose: Setups for drawing to GDI surface <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::toGDI (void) <br>{ <br>HRESULT hResult; <br> <br>// Step 1. Restore system palette (optional) <br>if (lpddpPalette)  <br>{ <br>// Save the current palette <br>hResult = lpddpPalette-&gt;GetEntries (0, 0, cPalette, lppeCurr); <br>if (FAILED (hResult)) <br>{ <br>REPORTERR (hResult); <br>return hResult; <br>} <br> <br>// Restore the system palette into our device <br>hResult = lpddpPalette-&gt;SetEntries (0, 0, cPalette, lppeSystem); <br>if (FAILED (hResult)) <br>{ <br>REPORTERR (hResult); <br>return hResult; <br>} <br>} <br> <br>// Step 2. Flip to GDI Surface <br>if (lpDD2)  <br>{ <br>hResult = lpDD2-&gt;FlipToGDISurface (); <br>if (FAILED (hResult)) <br>{ <br>REPORTERR (hResult); <br>return hResult; <br>} <br>} <br> <br>// Step 3.  Force window to redraw itself (on GDI surface) <br>if ((hWindow) &amp;&amp; (IsWindow (hWindow))) <br>{ <br>DrawMenuBar (hWindow); <br>RedrawWindow (hWindow, NULL, NULL, RDW_FRAME); <br>} <br> <br>// Success <br>return DD_OK; <br>} // End D3DWindow::toGDI <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::fromGDI <br>** Purpose: Restores from GDI <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::fromGDI (void) <br>{ <br>HRESULT hResult; <br> <br>// Restore current palette <br>if (lpddpPalette) <br>{ <br>hResult = lpddpPalette-&gt;SetEntries (0, 0, cPalette, lppeCurr); <br>if (FAILED (hResult))  <br>return hResult; <br>} <br> <br>// Success <br>return DD_OK; <br>} // End D3DWindow::fromGDI <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::Pause <br>** Purpose: Pause any work on DD/D3D resources <br>** Notes: <br>** <br>** For Fullscreen apps we need to setup the  <br>** <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::Pause (BOOL fPause) <br>{ <br>HRESULT hResult; <br> <br>    // Turning pausing on/off ?!? <br>    if (fPause) <br>    { <br>// Increment pause semaphore <br>        dwPaused++; <br> <br>// Are we pausing for the first time <br>        if (dwPaused == 1L) <br>        { <br>// Flip to GDI surface <br>hResult = toGDI (); <br>if (FAILED (hResult)) <br>return hResult; <br>        } <br> <br>    } <br>    else <br>    { <br>        if (dwPaused == 0L) <br>        { <br>            // Programmer Error, already unpaused <br>hResult = APPERR_GENERIC; <br>REPORTERR (hResult); <br>            return hResult; <br>        } <br> <br>// Are we unpausing for the last time ?!? <br>        if (dwPaused == 1L) <br>        { <br>// Restore from GDI surface <br>hResult = fromGDI (); <br>if (FAILED (hResult)) <br>return hResult; <br>        } <br> <br>        // Decrement pause semaphore <br>        dwPaused--; <br>    } <br> <br>    // Success <br>    return DD_OK; <br>} // D3DWindow::Pause <br>   <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::AttachScene <br>** Purpose:  <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::AttachScene (LPD3DScene lpNewScene) <br>{ <br>// Check parameters <br>if (! lpNewScene) <br>{ <br>return DDERR_INVALIDPARAMS; <br>} <br> <br>// Save Scene pointer <br>lpd3dScene = lpNewScene; <br> <br>// Inform scene of our existence <br>lpd3dScene-&gt;Init (this); <br> <br>// Allow scene to create any objects dependent on us <br>if (isValid ()) <br>{ <br>lpd3dScene-&gt;Attach (); <br>} <br> <br>// Success <br>return DD_OK; <br>} // End D3DWindow::AttachScene <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::DetachScene <br>** Purpose:  <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::DetachScene (void) <br>{ <br>// Cleanup Scene <br>if (lpd3dScene) <br>{ <br>lpd3dScene-&gt;Detach (); <br>lpd3dScene-&gt;Fini (); <br>lpd3dScene = NULL; <br>} <br> <br>// Success <br>return DD_OK; <br>} // End D3DWindow::DetachScene <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::Restore <br>** Purpose: Restores lost surfaces <br>** Note:    Eventually we should inform the user somehow that <br>**          they need to redraw the surface but for now punt <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::Restore (void) <br>{ <br>    HRESULT hResult; <br> <br>// Check Initialization <br>    if (! isValid ()) <br>{ <br>// Error, not properly initialized before calling this method <br>hResult = APPERR_NOTINITIALIZED; <br>REPORTERR (hResult); <br>        return hResult; <br>} <br> <br>    // Restore Primary Surface <br>    if (lpddsPrimary) <br>    { <br>hResult = lpddsPrimary-&gt;IsLost (); <br>if (hResult != DD_OK) <br>{ <br>hResult = lpddsPrimary-&gt;Restore (); <br>if (FAILED (hResult)) <br>return hResult; <br>} <br>    } <br> <br>    // Restore Z Buffer <br>    if (lpddsZBuff) <br>    { <br>hResult = lpddsZBuff-&gt;IsLost (); <br>if (hResult != DD_OK) <br>{ <br>        hResult = lpddsZBuff-&gt;Restore (); <br>    if (FAILED (hResult)) <br>    return hResult; <br>} <br>    } <br> <br>    // Restore Rendering surface <br>    if (lpddsRender) <br>    { <br>hResult = lpddsRender-&gt;IsLost (); <br>if (hResult != DD_OK) <br>{ <br>        hResult = lpddsRender-&gt;Restore (); <br>    if (FAILED (hResult)) <br>    return hResult; <br>} <br>    } <br> <br>// Allow D3D Scene to restore any surfaces <br>if (lpd3dScene) <br>{ <br>hResult = lpd3dScene-&gt;Restore (); <br>if (FAILED (hResult)) <br>return hResult; <br>} <br> <br>    // Success <br>    return DD_OK; <br>} // End D3DWindow::Restore <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::GetSurfaceRect <br>** Purpose: Get bounding rectangle of surface <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::GetSurfaceRect (RECT &amp; rSurface) <br>{ <br>HRESULT hResult; <br> <br>    if (! isValid ()) <br>    { <br>// Error, not properly initialized before calling this method <br>hResult = APPERR_NOTINITIALIZED; <br>REPORTERR (hResult); <br>        return hResult; <br>    } <br> <br>    // Return Surface rectangle <br>    rSurface = rSurf; <br> <br>    // Success <br>    return DD_OK; <br>} // D3DWindow::GetSurfaceRect <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::GetPrimaryRect <br>** Purpose: Get bounding rectangle of primary surface <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::GetPrimaryRect (RECT &amp; rPrimary) <br>{ <br>HRESULT hResult; <br> <br>    if (! isValid ()) <br>    { <br>// Error, not properly initialized before calling this method <br>hResult = APPERR_NOTINITIALIZED; <br>REPORTERR (hResult); <br>        return hResult; <br>    } <br> <br>    // Return Primary rectangle <br>    rPrimary = rPrim; <br> <br>    // Success <br>    return DD_OK; <br>} // GetPrimaryRect <br>   <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       D3DWindow::ChangeDesktop <br>**  Purpose:    The Primary Desktop has changed Modes <br>**Notes: <br>** <br>**1.  Since we are a fullscreen app, this shouldn't effect us <br>**until we restore the desktop mode.  Since DirectDraw should <br>**be tracking this anyway.  We can just ignore doing anything <br>** <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::ChangeDesktop (void) <br>{ <br>// Do nothing <br> <br>// Success  <br>return DD_OK; <br>} // D3DInfo::ChangeDesktop <br>   <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::ChangeDriver <br>** Purpose:  <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::ChangeDriver ( <br>LPGUID lpGuidDD, <br>LPD3DDevInfo lpDevHint, <br>LPDDModeInfo lpModeHint) <br>{ <br>HRESULT hResult; <br>LPGUID lpGuidD3D; <br>LPDDDrvInfo  lpDrvNew,  lpDrvOld; <br>LPDDModeInfo lpModeNew, lpModeOld; <br>LPD3DDevInfo lpDevNew, lpDevOld; <br>DWORD w, h, bpp, refresh; <br> <br>// Get New Driver <br>lpDrvNew = ValidateDriver (lpGuidDD); <br>if (! lpDrvNew) <br>{ <br>// Error, invalid DD Guid <br>hResult = APPERR_INVALIDPARAMS; <br>REPORTERR (hResult); <br>        return hResult; <br>} <br> <br>// Get requested D3D device <br>if (lpDevHint) <br>lpGuidD3D = &amp;(lpDevHint-&gt;guid); <br>else if (lpCurrDevice) <br>lpGuidD3D = &amp;(lpCurrDevice-&gt;guid); <br>else <br>lpGuidD3D = NULL; <br> <br>// Get requested mode <br>if (lpModeHint) <br>lpModeHint-&gt;GetMode (w, h, bpp, refresh); <br>else <br>{ <br>// Default to 640 x 480 x 16 <br>w= 640; <br>h= 480; <br>bpp= 16; <br>refresh = 0; <br>} <br> <br>// Get new device and mode compatible with this driver <br>if (! GetFullscreenMode (lpDrvNew, lpGuidD3D, w, h, bpp, refresh, <br> &amp;lpModeNew, &amp;lpDevNew)) <br>{ <br>// Error, unable to find a valid D3D Device <br>// and Mode that work with this driver. <br>hResult = APPERR_GENERIC; <br>REPORTERR (hResult); <br>return hResult; <br>} <br> <br>// Save old defaults <br>lpDrvOld= lpCurrDriver; <br>lpModeOld= lpCurrMode; <br>lpDevOld= lpCurrDevice; <br> <br>// Destroy almost everything <br>Fini (); <br> <br>// Set new defaults <br>lpCurrDriver = lpDrvNew; <br>lpCurrMode   = lpModeNew; <br>lpCurrDevice = lpDevNew; <br> <br>// Re-create almost everything based on new driver, device, and mode <br>hResult = Init (); <br>if (FAILED (hResult)) <br>{ <br>// Try to restore old defaults <br>Fini (); <br> <br>lpCurrDriver = lpDrvOld; <br>lpCurrMode   = lpModeOld; <br>lpCurrDevice = lpDevOld; <br> <br>Init (); <br>return hResult; <br>} <br> <br>// Notify the window of a successful change in Driver <br>SendMessage (hWindow, D3DWIN_CHANGED_DRIVER, 0, 0); <br> <br>// Success <br>    return DD_OK; <br>} // End D3DWindow::ChangeDriver <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::ChangeMode <br>** Purpose: Change the mode <br>** <br>**Basic Algorithm: <br>** <br>**  1.  Validate new mode request <br>**  2.  Validate that the D3D device is compatible <br>**  3.  Destroy old mode <br>**  4.  Create new mode <br>** <br>**- This can be complicated by the fact that the new mode is not <br>**    compatible with the current D3D device, in which case we need <br>**    to choose a new D3D device that will work with this mode. <br>** <br>**  - We don't normally allow mode changes for windowed mode. <br>**- However the desktop mode could have changed underneath us, <br>**  So make sure the desktop mode and our current mode match. <br>**  If not, then change to the current desktop mode. <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::ChangeMode ( <br>DWORD w,// Mode Width <br>DWORD h,// Mode Height <br>DWORD bpp,// Mode Bits Per Pixel <br>DWORD refresh)// Optional:  Mode refresh rate <br>{ <br>HRESULT hResult; <br>LPDDDrvInfo  lpOldDrv; <br>LPDDModeInfo lpOldMode, lpNewMode; <br>LPD3DDevInfo lpOldDev, lpNewDev; <br> <br>// Check Initialization <br>if ((! hWindow) || (! IsWindow (hWindow))) <br>{ <br>// Error, Not properly initialized <br>hResult = APPERR_NOTINITIALIZED; <br>REPORTERR (hResult); <br>return hResult; <br>} <br> <br>lpOldDrv  = lpCurrDriver; <br>lpOldMode = lpCurrMode; <br>lpOldDev  = lpCurrDevice; <br> <br> <br>// <br>// Step 1. Get New Mode <br>// <br> <br>// Find new mode corresponding to w, h, bpp <br>lpNewMode = lpOldDrv-&gt;FindMode (w, h, bpp, 0, NULL); <br>if (! lpNewMode) <br>{ <br>// Error, Invalid Mode parameters <br>hResult = APPERR_INVALIDPARAMS; <br>REPORTERR (hResult); <br>return hResult; <br>} <br> <br>//  <br>// Step 2.   Check if Device needs to be changed as well <br>// <br>if (lpNewMode-&gt;ModeSupported (lpOldDev)) <br>{ <br>lpNewDev = NULL; <br>} <br>else <br>{ <br>LPD3DDevInfo lpNextBest; <br>lpNewDev = lpOldDrv-&gt;FindDeviceSupportsMode (&amp;lpOldDev-&gt;guid, <br> lpNewMode, <br> &amp;lpNextBest); <br>if (! lpNewDev) <br>{ <br>if (! lpNextBest) <br>{ <br>// No D3D device is compatible with this new mode <br>hResult = APPERR_GENERIC; <br>REPORTERR (hResult); <br>return hResult; <br>} <br>lpNewDev = lpNextBest; <br>} <br>} <br> <br>//  <br>// Step 3.Destroy current Mode <br>// <br>FiniRender (); <br>FiniPrimary (); <br>//  FiniFullscreenMode ();// Don't do this =&gt; unnecessary mode switch <br> <br>// <br>// Step 4.  Create new mode <br>// <br>lpCurrMode = lpNewMode; <br>if (lpNewDev) <br>lpCurrDevice = lpNewDev; <br> <br>// Change Mode <br>hResult = InitFullscreenMode (); <br>if (FAILED (hResult)) <br>return hResult; <br> <br>// Create Primary Surface <br>hResult = InitPrimary (); <br>if (FAILED (hResult)) <br>{ <br>// Try to restore old mode <br>lpCurrMode = lpOldMode; <br>lpCurrDevice = lpOldDev; <br> <br>InitFullscreenMode (); <br>InitPrimary (); <br>InitRender (); <br> <br>return hResult; <br>} <br> <br>// Create Render surface <br>hResult = InitRender (); <br>if (FAILED (hResult)) <br>{ <br>FiniPrimary (); <br>//  FiniFullscreenMode ();// Unnecessary mode switch <br> <br>// Try to restore old mode <br>lpCurrMode = lpOldMode; <br>lpCurrDevice = lpOldDev; <br> <br>InitFullscreenMode (); <br>InitPrimary (); <br>InitRender (); <br> <br>return hResult; <br>} <br> <br>// Notify the window of a successful change in Mode <br>SendMessage (hWindow, D3DWIN_CHANGED_MODE, 0, 0); <br> <br>// Success <br>    return DD_OK; <br>} // End D3DWindow::ChangeMode <br> <br>   <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    D3DWindow::ChangeDevice <br>** Purpose: Change to a new D3D device (RAMP, RGB, Hardware, etc.) <br>** Notes: <br>** <br>**  Algorithm: <br>**- Destroy the current D3D Device (and associated surfaces) <br>**- Recreate a new D3D device from the new GUID <br>** <br>**  1.The new D3D Device may not be supported by the current DD Device. <br>**  2.  The new D3D Device may not be compatible with the current Mode <br>**- Since we are fullscreen, just pick a new mode that is compatible <br>** <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DWindow::ChangeDevice ( <br>LPGUID lpD3DGuid, <br>LPDDModeInfo lpModeHint) <br>{ <br>    HRESULT         hResult; <br>LPDDDrvInfolpDrvOld; <br>LPDDModeInfo    lpModeNew, lpModeOld; <br>LPD3DDevInfolpDevNew, lpDevOld; <br> <br>// Check Parameters <br>if (! lpD3DGuid) <br>{ <br>hResult = APPERR_INVALIDPARAMS; <br>REPORTERR (hResult); <br>        return hResult; <br>} <br> <br>// Check Initialization <br>    if (! isValid () || (! lpddsRender)) <br>{ <br>hResult = APPERR_NOTINITIALIZED; <br>REPORTERR (hResult); <br>        return hResult; <br>} <br> <br>// Save Original State <br>lpDrvOld= lpCurrDriver; <br>lpModeOld   = lpCurrMode; <br>lpDevOld= lpCurrDevice; <br> <br>// Verify new D3D device belongs to current DD driver <br>lpDevNew = lpDrvOld-&gt;FindDevice (lpD3DGuid, NULL); <br>if (! lpDevNew) <br>{ <br>hResult = APPERR_INVALIDPARAMS; <br>REPORTERR (hResult); <br>        return hResult; <br>} <br> <br>// <br>//Step 1. Verify new D3D device is supported with current mode <br>// <br>if (lpModeHint) <br>lpModeNew = lpModeHint; <br>else <br>lpModeNew = lpModeOld; <br>if (! lpModeNew-&gt;ModeSupported (lpDevNew)) <br>{ <br>// We are a full screen app, so we can do what we want <br>// Pick a new mode that is compatible with this device <br>LPDDModeInfo lpNextBest; <br>DWORD w, h, bpp, refresh; <br> <br>lpModeNew-&gt;GetMode (w, h, bpp, refresh); <br> <br>lpModeNew = lpDrvOld-&gt;FindModeSupportsDevice (w, h, bpp, 0, <br>  lpDevNew, <br>  &amp;lpNextBest); </code></pre>
<p>
</p>
<pre><code>if (! lpModeNew) <br>{ <br>if (! lpNextBest) <br>{ <br>// Error , no compatible mode found!!! <br>hResult = APPERR_GENERIC; <br>REPORTERR (hResult); <br>return hResult; <br>} <br>lpModeNew = lpNextBest; <br>} <br>} <br>if (lpModeNew == lpModeOld) <br>lpModeNew = NULL; <br> <br> <br>// <br>//Step 2.  Destroy Old D3D Device (and mode) <br>// <br>FiniRender (); <br>if (lpModeNew) <br>{ <br>FiniPrimary (); <br>// FiniFullscreenMode ();// Unnecessary mode switch <br>} <br> <br> <br>// <br>//Step 3. Create new D3D Device (new mode optional) <br>// <br> <br>// Set new D3D device (and mode) <br>if (lpModeNew) <br>lpCurrMode = lpModeNew; <br>lpCurrDevice = lpDevNew; <br> <br>// Create new mode, if necessary <br>if (lpModeNew) <br>{ <br>// Change Mode <br>hResult = InitFullscreenMode (); <br>if (FAILED (hResult)) <br>{ <br>// Try to restore original mode and device <br>lpCurrDevice = lpDevOld; <br>lpCurrMode   = lpModeOld; <br> <br>InitFullscreenMode (); <br>InitPrimary (); <br>InitRender (); <br> <br>return hResult; <br>} <br> <br>// Create Primary <br>hResult = InitPrimary (); <br>if (FAILED (hResult)) <br>{ <br>// Try to restore original mode and device <br>lpCurrDevice = lpDevOld; <br>lpCurrMode   = lpModeOld; <br> <br>InitFullscreenMode (); <br>InitPrimary (); <br>InitRender (); <br> <br>return hResult; <br>} <br>} <br> <br>// Create new D3D Device <br>hResult = InitRender (); <br>if (FAILED (hResult)) <br>{ <br>// Try to restore original mode and device <br>if (lpModeNew) <br>lpCurrMode = lpModeOld; <br>lpCurrDevice = lpDevOld; <br> <br>if (lpModeNew) <br>{ <br>FiniPrimary (); <br>InitFullscreenMode (); <br>InitPrimary (); <br>} <br> <br>InitRender (); <br> <br>// Return Error <br>REPORTERR (hResult); <br>return hResult; <br>} <br> <br>// Notify the window of a successful change in device <br>SendMessage (hWindow, D3DWIN_CHANGED_DEVICE, 0, 0); <br> <br>    // Success <br>    return DD_OK; <br>} // End D3DWindow::ChangeDevice <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** End of File <br>**----------------------------------------------------------------------------- <br>*/ </code></pre>
<p>&nbsp;</p></body>
</HTML>
