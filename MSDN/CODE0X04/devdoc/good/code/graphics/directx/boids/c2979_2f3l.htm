<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DRVMGR.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2991"></a>DRVMGR.CPP</h2>
<pre><code>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DrvMgr.cpp <br>**  Purpose:    Implements DD/D3D Driver/Device enumeration <br>** <br>**  Copyright (c) 1995 - 1997 by Microsoft, all rights reserved. <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Includes <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>#include "DrvMgr.h" <br>#include "Debug.h" <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Typedefs <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>// Used with Enumeration Callbacks <br>typedef struct tagDD_CB_INFO  <br>{ <br>    BOOL  fResult;    // Success/Failure <br>    DWORD  cCount;       // Current count <br>    void *    lpExtra;// Current Driver/Device/Etc. <br>} DD_CB_INFO; <br>typedef DD_CB_INFO * LPDD_CB_INFO; <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Global Variables <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>// Global DDDrvMgr data <br>DWORD       DDDrvMgr::g_fFlags= 0L; <br>DWORDDDDrvMgr::g_cDrivers= 0L; <br>LPDDDrvInfo DDDrvMgr::g_lpDriverRoot= NULL; <br>LPDDDrvInfo DDDrvMgr::g_lpDriverTail= NULL; <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Local Prototypes <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>BOOL WINAPI DriverEnumCallback (LPGUID lpGuid, LPTSTR lpDesc,  <br>                                LPTSTR lpName, LPVOID lpExtra); <br> <br>HRESULT WINAPI ModeEnumCallback (LPDDSURFACEDESC lpDDSurfDesc, <br>                                 LPVOID lpExtra); <br> <br>HRESULT WINAPI TextureFormatEnumCallback (LPDDSURFACEDESC lpTexFormatDesc, <br>  LPVOID lpExtra); <br> <br>HRESULT WINAPI DeviceEnumCallback (LPGUID lpGuid,  <br>   LPTSTR lpName,   <br>   LPTSTR lpDesc, <br>                                   LPD3DDEVICEDESC lpHalDevice, <br>                                   LPD3DDEVICEDESC lpHelDevice,  <br>                                   LPVOID lpExtra); <br> <br>     <br>/* <br>**----------------------------------------------------------------------------- <br>**  Functions <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    ValidateDriver <br>** Purpose: Find DD driver matching user choice <br>**or returns the primary driver on failure <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LPDDDrvInfo ValidateDriver (LPGUID lpDDGuid) <br>{ <br>LPDDDrvInfo lpDrvNew, lpDrvNext; <br> <br>    // Find Driver matching specified GUID <br>    lpDrvNew = DDDrvMgr::FindDriver (lpDDGuid, &amp;lpDrvNext); <br>    if (lpDrvNew) <br>{ <br>// Exact match <br>return lpDrvNew; <br>} <br> <br>// Return next best match (or failure) <br>return lpDrvNext; <br>} // End ValidateDriver <br> <br>   <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    ValidateMode <br>** Purpose: Find DD mode matching user choice (w,h,bpp) <br>** Notes:filters modes against device, if specified. <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LPDDModeInfo ValidateMode ( <br>LPDDDrvInfo lpDriver,  /* In:  DD Driver */ <br>DWORD w,/* In:  width, height, bpp */ <br>DWORD h, <br>DWORD bpp, <br>DWORD refresh, <br>LPD3DDevInfo lpFilter)/* In:Device used as filter */ <br>{ <br>LPDDModeInfo lpModeNew, lpModeNext; <br> <br>// Check Parameters <br>if (! lpDriver) <br>return FALSE; <br> <br>if (! lpFilter) <br>lpModeNew = lpDriver-&gt;FindMode (w, h, bpp, refresh, &amp;lpModeNext); <br>else <br>{ <br>// Filter mode against D3D device compatiblity <br>lpModeNew = lpDriver-&gt;FindModeSupportsDevice (w, h, bpp, refresh, <br>  lpFilter, <br>  &amp;lpModeNext); <br>} <br> <br>    if (lpModeNew) <br>{ <br>// Exact match <br>return lpModeNew; <br>} <br> <br>// Return next best match (or failure) <br>return lpModeNext; <br>} // End ValidateMode <br> <br> <br>   <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    ValidateDevice <br>** Purpose: Find D3D device matching user choice <br>** Notes:Filters devices against mode, if specified. <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LPD3DDevInfo ValidateDevice( <br>LPDDDrvInfo lpDriver, <br>LPGUID lpD3DGuid, <br>LPDDModeInfo lpFilter) <br>{ <br>LPD3DDevInfo lpDevNew, lpDevNext; <br> <br>// Check Parameters <br>if (! lpDriver) <br>return FALSE; <br> <br>if (! lpFilter) <br>{ <br>lpDevNew = lpDriver-&gt;FindDevice (lpD3DGuid, &amp;lpDevNext); <br>} <br>else <br>{ <br>// Filter device against mode <br>lpDevNew = lpDriver-&gt;FindDeviceSupportsMode (lpD3DGuid,  <br>       lpFilter, <br> &amp;lpDevNext); <br>} <br> <br>    if (lpDevNew) <br>{ <br>// Exact match <br>return lpDevNew; <br>} <br> <br>// Return next best match (or failure) <br>return lpDevNext; <br>} // End ValidateDevice <br> <br>   <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    ValidateFormat <br>** Purpose: Find texture format matching user choice (ddpfPixelformat) <br>** Notes:filters modes against device, if specified. <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LPDDModeInfo ValidateFormat ( <br>LPD3DDevInfo lpDevice,  /* In:  D3D Device */ <br>DWORD bpp) <br>{ <br>LPDDModeInfo lpFormatNew, lpFormatNext; <br> <br>// Check Parameters <br>if (! lpDevice) <br>return FALSE; <br> <br>lpFormatNew = lpDevice-&gt;FindFormat (bpp, &amp;lpFormatNext); <br> <br>    if (lpFormatNew) <br>{ <br>// Exact match <br>return lpFormatNew; <br>} <br> <br>// Return next best match (or failure) <br>return lpFormatNext; <br>} // End ValidateFormat <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    ValidateFormat <br>** Purpose: Find texture format matching user choice (ddpfPixelformat) <br>** Notes:filters modes against device, if specified. <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LPDDModeInfo ValidateFormat ( <br>LPD3DDevInfo lpDevice,  /* In:  D3D Device */ <br>LPDDPIXELFORMAT lpddpf) <br>{ <br>LPDDModeInfo lpFormatNew, lpFormatNext; <br> <br>// Check Parameters <br>if (! lpDevice) <br>return FALSE; <br> <br>lpFormatNew = lpDevice-&gt;FindFormat (lpddpf, &amp;lpFormatNext); <br> <br>    if (lpFormatNew) <br>{ <br>// Exact match <br>return lpFormatNew; <br>} <br> <br>// Return next best match (or failure) <br>return lpFormatNext; <br>} // End ValidateFormat <br>   <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    GetDesktopMode <br>** Purpose: Find DD mode corresponding to desktop  <br>**and a compatible D3D device. <br>** Notes: <br>** <br>**1.  We have no choice, we are stuck with the current desktop mode. <br>**  2.  Since we can't change the mode, we must choose a D3D device <br>**that is compatible with the current mode. <br>** <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>BOOL GetDesktopMode ( <br>LPDDDrvInfo lpDriver,/* In:   Driver */ <br>LPGUID lpD3DGuid, /* In:   Requested D3D device guid */ <br>LPDDModeInfo * lpMode,/* Out:  Desktop Mode */ <br>LPD3DDevInfo * lpDev)/* Out:  D3D device compatible with mode */ <br>{ <br>HWND hDesktop; <br>HDC hdc; <br>DWORD w, h, bpp; <br>LPDDModeInfo lpModeNew; <br>LPD3DDevInfo lpDevNew, lpDevNext; <br> <br>// Check Parameters <br>if ((! lpDriver) || (! lpMode) || (! lpDev)) <br>return FALSE; <br> <br>// Get Desktop Mode info <br>hDesktop = GetDesktopWindow (); <br>hdc = GetDC (hDesktop); <br> <br>w= GetDeviceCaps (hdc, HORZRES); <br>h= GetDeviceCaps (hdc, VERTRES); <br>bpp= GetDeviceCaps(hdc, PLANES) * GetDeviceCaps (hdc, BITSPIXEL); <br> <br>ReleaseDC (hDesktop, hdc); <br> <br>// Get Mode <br>lpModeNew = lpDriver-&gt;FindMode (w, h, bpp, 0, NULL); <br>if (! lpModeNew) <br>return FALSE; <br> <br>// Get Compatible Device <br>lpDevNew = lpDriver-&gt;FindDeviceSupportsMode (lpD3DGuid, <br>          lpModeNew, <br> &amp;lpDevNext); <br>if (! lpDevNew) <br>{ <br>if (! lpDevNext) <br>return FALSE; <br>lpDevNew = lpDevNext; <br>} <br> <br>// Save results <br>*lpMode = lpModeNew; <br>*lpDev  = lpDevNew; <br> <br>// Success <br>return TRUE; <br>} // End GetDesktopMode <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    GetFullscreenMode <br>** Purpose: Find D3D Device and a compatible mode <br>** Notes: <br>** <br>**  1. Pick the D3D device first <br>**  2. Pick a DD mode that is compatible with our D3D device choice. <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>BOOL GetFullscreenMode ( <br>LPDDDrvInfo lpDriver,/* In:   Driver */ <br>LPGUID lpD3DGuid, /* In:   requested D3D device guid */ <br>DWORD w,/* In: requested mode */ <br>DWORD h, <br>DWORD bpp, <br>DWORD        refresh, <br>LPDDModeInfo * lpMode,/* Out:  Valid Desktop Mode compatible with device */ <br>LPD3DDevInfo * lpDev)/* Out:  Valid D3D device */ <br>{ <br>LPDDModeInfo lpModeNew, lpModeNext; <br>LPD3DDevInfo lpDevNew, lpDevNext; <br> <br>// Check Parameters <br>if ((! lpDriver) || (! lpMode) || (! lpDev)) <br>return FALSE; <br> <br>// Get D3D Device <br>lpDevNew = lpDriver-&gt;FindDevice (lpD3DGuid, &amp;lpDevNext); <br>if (! lpDevNew) <br>{ <br>if (! lpDevNext) <br>return FALSE; <br>lpDevNew = lpDevNext; <br>} <br> <br>// Double check requested mode parameters <br>if ((w == 0) || (h == 0) || (bpp == 0)) <br>{ <br>// Pick a reasonable full screen default <br>// Most Hardware devices support 16 bpp, <br>// many don't support 8 bpp, so pick 16 <br>w   = 640; <br>h= 480; <br>bpp = 16; <br>} <br> <br>// Get Compatible Mode <br>lpModeNew = lpDriver-&gt;FindModeSupportsDevice (w, h, bpp, refresh, <br>      lpDevNew, <br>  &amp;lpModeNext); <br>if (! lpModeNew) <br>{ <br>if (! lpModeNext) <br>return FALSE; <br>lpModeNew = lpModeNext; <br>} <br> <br>// Save results <br>*lpMode = lpModeNew; <br>*lpDev  = lpDevNew; <br> <br>// Success <br>return TRUE; <br>} // End GetFullscreenMode <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    ChooseDriverDefaults <br>** Purpose: Chooses default driver, mode, and device <br>** Notes: <br>** <br>**Windowed:The mode comes from the desktop and can't be changed <br>**so derive the device from the mode. <br>**  FullScreen:Any mode is fine.  Hardware is more interesting than <br>**software, so derive the mode from the device <br>**  <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT ChooseDriverDefaults ( <br>    LPGUID lpGuidDD,// In:Requested DD Guid <br>    DWORD  dwW,// In:Requested Mode (w,h,bpp,refresh) <br>DWORD  dwH, <br>DWORD  dwBPP,  <br>DWORD  dwRefresh, <br>    LPGUID lpGuidD3D,// In:Requested D3D Guid <br>BOOL   fFullScreen,// In:  Fullscreen or Windowed mode <br>LPDDDrvInfo * lpDriver,// Out: Valid Driver <br>LPDDModeInfo * lpMode,// Out: Valid Mode <br>LPD3DDevInfo * lpDevice)// Out: Valid Device <br>{ <br>HRESULThResult; <br>    LPDDDrvInfolpDrvNew; <br>LPDDModeInfolpModeNew; <br>LPD3DDevInfolpDevNew; <br> <br>// Check Parameters <br>if ((! lpDriver) || (! lpMode) || (! lpDevice)) <br>{ <br>hResult = APPERR_INVALIDPARAMS; <br>REPORTERR (hResult); <br>return hResult; <br>} <br> <br>// Initialize Driver Manager, if necessary <br>if (! DDDrvMgr::isInitialized ()) <br>{ <br>hResult = DDDrvMgr::Init (); <br>if (FAILED (hResult)) <br>return hResult; <br>} <br>     <br>    // Find Driver matching specified GUID <br>    lpDrvNew = ValidateDriver (lpGuidDD); <br>if (! lpDrvNew) <br>    { <br>        // Error, invalid DD Guid <br>hResult = APPERR_INVALIDPARAMS; <br>REPORTERR (hResult); <br>        return hResult; <br>    } <br> <br>if (fFullScreen) <br>{ <br>// Get D3D device and compatible mode <br>    if (! GetFullscreenMode (lpDrvNew, lpGuidD3D,  <br> dwW, dwH, dwBPP, dwRefresh, <br> &amp;lpModeNew, &amp;lpDevNew)) <br>{ <br>hResult = APPERR_GENERIC; <br>REPORTERR (hResult); <br>return hResult; <br>} <br>} <br>else <br>{ <br>// Get Desktop mode and compatible D3D device <br>if (! GetDesktopMode (lpDrvNew, lpGuidD3D, &amp;lpModeNew, &amp;lpDevNew)) <br>{ <br>hResult = APPERR_GENERIC; <br>REPORTERR (hResult); <br>return hResult; <br>} <br>} <br> <br>// Return results <br>*lpDriver = lpDrvNew; <br>*lpMode   = lpModeNew; <br>*lpDevice = lpDevNew; <br> <br>    // Success <br>    return DD_OK; <br>} // End ChooseDriverDefaults <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       FlagsToBitDepth <br>**  Purpose:    Gets Bit Depth from DDPF Flags <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>DWORD FlagsToBitDepth (DWORD dwFlags) <br>{ <br>    if (dwFlags &amp; DDBD_1) <br>        return 1L; <br>    else if (dwFlags &amp; DDBD_2) <br>        return 2L; <br>    else if (dwFlags &amp; DDBD_4) <br>        return 4L; <br>    else if (dwFlags &amp; DDBD_8) <br>        return 8L; <br>    else if (dwFlags &amp; DDBD_16) <br>        return 16L; <br>    else if (dwFlags &amp; DDBD_24) <br>        return 24L; <br>    else if (dwFlags &amp; DDBD_32) <br>        return 32L; <br>    else <br>        return 0L;  <br>} // End FlagsToBitDepth <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       BitDepthToFlags <br>**  Purpose:    Converts BPP to corresponding DDPF flag <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>DWORD BitDepthToFlags (DWORD dwBPP) <br>{ <br>    switch (dwBPP)  <br>{ <br>case 1: <br>    return DDBD_1; <br>case 2: <br>    return DDBD_2; <br>case 4: <br>    return DDBD_4; <br>case 8: <br>    return DDBD_8; <br>case 16: <br>    return DDBD_16; <br>case 24: <br>    return DDBD_24; <br>case 32: <br>    return DDBD_32; <br>default: <br>// Error <br>    return (DWORD)0L; <br>    } <br>} // End BitDepthToFlags <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    isPalettized <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>BOOL isPalettized (LPDDPIXELFORMAT lpddpf) <br>{ <br>    if (! lpddpf) <br>    { <br>        // Error,  <br>        return FALSE; <br>    } <br> <br>    if (lpddpf-&gt;dwFlags &amp; DDPF_PALETTEINDEXED1) <br>        return TRUE; <br> <br>    if (lpddpf-&gt;dwFlags &amp; DDPF_PALETTEINDEXED2) <br>        return TRUE; <br> <br>    if (lpddpf-&gt;dwFlags &amp; DDPF_PALETTEINDEXED4) <br>        return TRUE; <br> <br>    if (lpddpf-&gt;dwFlags &amp; DDPF_PALETTEINDEXED8) <br>        return TRUE; <br> <br>    // Not palettized <br>    return FALSE; <br>} // End IsPalettized <br> <br> <br> <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Local Functions <br>**----------------------------------------------------------------------------- <br>*/ <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DriverEnumCallback <br>**  Purpose:    Add this DD driver to global driver list <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>BOOL WINAPI DriverEnumCallback( <br>    GUID FAR *  lpGuid, <br>    LPTSTR      lpDesc,  <br>    LPTSTR      lpName, <br>    LPVOID      lpExtra) <br>{ <br>    HRESULT         hResult; <br>    LPDD_CB_INFO lpInfo; <br>    LPDDDrvInfo     lpDriver; <br>    DWORD           dwIndex; <br> <br>    if (! lpExtra) <br>    { <br>        // Programming error, invalid pointer <br>        return DDENUMRET_OK; <br>    } <br> <br>    lpInfo = (LPDD_CB_INFO)lpExtra; <br>    dwIndex = lpInfo-&gt;cCount; <br> <br>    // Get Pointer to driver info <br>    lpDriver = new DDDrvInfo; <br>    if (! lpDriver) <br>    { <br>        // Error, Not enough memory to create driver <br>        return DDENUMRET_OK; <br>    } <br> <br>    // Initialize driver  <br>// Enumerate modes, D3D devices <br>    hResult = lpDriver-&gt;Create (lpGuid, lpName, lpDesc); <br>    if (FAILED (hResult)) <br>    { <br>        // Error, Driver Create failed <br>        return DDENUMRET_OK; <br>    } <br> <br>// Add To Global Driver List <br>hResult = DDDrvMgr::AddDriver (lpDriver); <br>if (FAILED (hResult)) <br>{ <br>// Error, Driver Create Failed <br>return DDENUMRET_OK; <br>} <br> <br>    // Increment driver count <br>    lpInfo-&gt;cCount++; <br> <br>    // Success <br>    return DDENUMRET_OK; <br>} // End DriverEnumCallback <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       ModeEnumCallback <br>**  Purpose:    Add this mode to the driver <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT WINAPI ModeEnumCallback ( <br>    LPDDSURFACEDESC lpDDSurfDesc, <br>    LPVOID          lpExtra) <br>{ <br>HRESULThResult; <br>LPDDModeInfolpMode; <br>    LPDD_CB_INFO lpInfo; <br>    LPDDDrvInfolpDriver; <br>    DWORD           dwIndex; <br> <br>    if (! lpExtra) <br>    { <br>        // Programming error, invalid pointer <br>        return DDENUMRET_OK; <br>    } <br> <br>    lpInfo   = (LPDD_CB_INFO)lpExtra; <br>    lpDriver = (LPDDDrvInfo) lpInfo-&gt;lpExtra; <br>    dwIndex  = lpInfo-&gt;cCount; <br> <br>    if (! lpDriver) <br>    { <br>        // Programming Error, invalid pointer <br>        return DDENUMRET_OK; <br>    } <br> <br>    if (! lpDDSurfDesc) <br>    { <br>        // Error, invalid pointer <br>        return DDENUMRET_CANCEL; <br>    } <br> <br>    // Double check structure size <br>    if (lpDDSurfDesc-&gt;dwSize != sizeof(DDSURFACEDESC)) <br>    { <br>        // Error, structure is wrong size <br>        return DDENUMRET_CANCEL; <br>    } <br> <br>// Create Mode node <br>lpMode = new DDModeInfo; <br>if (! lpMode) <br>{ <br>        // Error, not enough memory to store mode info <br>        return DDENUMRET_OK; <br>} <br> <br>    // Copy surface description <br>    lpMode-&gt;ddSurfDesc = *lpDDSurfDesc; <br> <br>// Add Mode to Driver Mode List <br>hResult = lpDriver-&gt;AddMode (lpMode); <br>if (FAILED (hResult)) <br>{ <br>        // Error, not enough memory to store mode info <br>        return DDENUMRET_OK; <br>} <br> <br>    // Update mode count <br>    lpInfo-&gt;cCount++; <br>         <br>    return DDENUMRET_OK; <br>} // End ModeEnumCallback <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       TextureFormatEnumCallback <br>**  Purpose:    Add this mode to the driver <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT WINAPI TextureFormatEnumCallback ( <br>    LPDDSURFACEDESC lpTextureFormat, <br>    LPVOID          lpExtra) <br>{ <br>HRESULThResult; <br>LPDDModeInfolpFormat; <br>    LPDD_CB_INFO lpInfo; <br>    LPD3DDevInfolpDevice; <br>    DWORD           dwIndex; <br> <br>    if (! lpExtra) <br>    { <br>        // Programming error, invalid pointer <br>        return DDENUMRET_OK; <br>    } <br> <br>    lpInfo   = (LPDD_CB_INFO)lpExtra; <br>    lpDevice = (LPD3DDevInfo)lpInfo-&gt;lpExtra; <br>    dwIndex  = lpInfo-&gt;cCount; <br> <br>    if (! lpDevice) <br>    { <br>        // Programming error, invalid pointer <br>        return DDENUMRET_OK; <br>    } <br> <br>    if (! lpTextureFormat) <br>    { <br>        // Error, invalid pointer <br>        return DDENUMRET_CANCEL; <br>    } <br> <br>    // Double check structure size <br>    if (lpTextureFormat-&gt;dwSize != sizeof(DDSURFACEDESC)) <br>    { <br>        // Error, structure is wrong size <br>        return DDENUMRET_CANCEL; <br>    } <br> <br>// Create format node <br>lpFormat = new DDModeInfo; <br>if (! lpFormat) <br>{ <br>        // Error, not enough memory to store format info <br>        return DDENUMRET_OK; <br>} <br> <br>    // Copy texture format description <br>    lpFormat-&gt;ddSurfDesc = *lpTextureFormat; <br> <br>// Add format to D3D device format list <br>hResult = lpDevice-&gt;AddFormat (lpFormat); <br>if (FAILED (hResult)) <br>{ <br>        // Error, not enough memory to store mode info <br>        return DDENUMRET_OK; <br>} <br> <br>    // Update format count <br>    lpInfo-&gt;cCount++; <br>         <br>    return DDENUMRET_OK; <br>} // End TextureFormatEnumCallback <br>   <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DeviceEnumCallback <br>**  Purpose:    Add this D3D Device Driver info to the driver <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT WINAPI DeviceEnumCallback ( <br>    LPGUID          lpGuid, <br>    LPTSTR          lpName, <br>    LPTSTR          lpDesc, <br>    LPD3DDEVICEDESC lpHalDevice, <br>    LPD3DDEVICEDESC lpHelDevice, <br>    LPVOID          lpExtra) <br>{ <br>    HRESULT         hResult; <br>    LPDD_CB_INFOlpInfo; <br>    LPDDDrvInfo     lpDriver; <br>LPD3DDevInfolpDevice; <br>    DWORD           dwIndex; <br> <br>    if (! lpExtra) <br>    { <br>        // Programming error, invalid pointer <br>        return DDENUMRET_OK; <br>    } <br> <br>    lpInfo   = (LPDD_CB_INFO) lpExtra; <br>    lpDriver = (LPDDDrvInfo) lpInfo-&gt;lpExtra; <br>    dwIndex  = lpInfo-&gt;cCount; <br> <br>    if (! lpDriver) <br>    { <br>        // Programming Error, invalid pointer <br>        return DDENUMRET_OK; <br>    } <br> <br>// Create D3D Device node <br>lpDevice = new D3DDevInfo; <br>if (! lpDevice) <br>{ <br>        // Not Enough memory to create D3D device node <br>        return DDENUMRET_OK; <br>} <br> <br>    // Initialize D3D Device info <br>    hResult = lpDevice-&gt;Create (lpGuid, lpName, lpDesc, <br>                                lpHalDevice, lpHelDevice); <br>    if (FAILED (hResult)) <br>    { <br>        // Error <br>        return DDENUMRET_OK; <br>    } <br> <br>// Add to Driver D3D Device list <br>hResult = lpDriver-&gt;AddDevice (lpDevice); <br>if (FAILED (hResult)) <br>{ <br>        // Error <br>        return DDENUMRET_OK; <br>} <br> <br>    // Update D3D device Driver count <br>    lpInfo-&gt;cCount++; <br>         <br>    return DDENUMRET_OK; <br>} // End DeviceEnumCallback <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  DDModeInfo Methods <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DDModeInfo::GetWidth <br>**  Purpose:    Gets the Width for this mode <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>DWORD DDModeInfo::GetWidth (void) <br>{ <br>    // Check parameters <br>    if (ddSurfDesc.dwSize != sizeof (DDSURFACEDESC)) <br>        return 0L; <br> <br>// Check that Pixel format is valid <br>if (! (ddSurfDesc.dwFlags &amp; DDSD_WIDTH)) <br>return 0L; <br> <br>// Get Bits Per Pixel <br>return ddSurfDesc.dwWidth; <br>} // DDModeInfo::GetWidth <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DDModeInfo::GetHeight <br>**  Purpose:    Gets the Height for this mode <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>DWORD DDModeInfo::GetHeight (void) <br>{ <br>    // Check parameters <br>    if (ddSurfDesc.dwSize != sizeof (DDSURFACEDESC)) <br>        return 0L; <br> <br>// Check that Pixel format is valid <br>if (! (ddSurfDesc.dwFlags &amp; DDSD_HEIGHT)) <br>return 0L; <br> <br>// Get Bits Per Pixel <br>return ddSurfDesc.dwHeight; <br>} // DDModeInfo::GetHeight <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DDModeInfo::GetBPP <br>**  Purpose:    Gets the Bits per pixel for this mode <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>DWORD DDModeInfo::GetBPP (void) <br>{ <br>    // Check parameters <br>    if (ddSurfDesc.dwSize != sizeof (DDSURFACEDESC)) <br>        return 0L; <br> <br>// Check that Pixel format is valid <br>if (! (ddSurfDesc.dwFlags &amp; DDSD_PIXELFORMAT)) <br>return 0L; <br>if (ddSurfDesc.ddpfPixelFormat.dwSize != sizeof(DDPIXELFORMAT)) <br>return 0L; <br> <br>// Assume it is RGB <br>return ddSurfDesc.ddpfPixelFormat.dwRGBBitCount; <br>} // DDModeInfo::GetBPP <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DDModeInfo::GetMode <br>**  Purpose:    Gets the Mode info (w,h,bpp) for this mode <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT DDModeInfo::GetMode ( <br>DWORD &amp; dwW,  <br>DWORD &amp; dwH,  <br>DWORD &amp; dwBPP, <br>DWORD &amp; dwRefresh) <br>{ <br>    // Check parameters <br>    if (ddSurfDesc.dwSize != sizeof (DDSURFACEDESC)) <br>        return DDERR_GENERIC; <br> <br>// Check that width is valid <br>if (! (ddSurfDesc.dwFlags &amp; DDSD_WIDTH)) <br>return DDERR_GENERIC; <br> <br>// Check that height is valid <br>if (! (ddSurfDesc.dwFlags &amp; DDSD_HEIGHT)) <br>return DDERR_GENERIC; <br> <br>// Check that Pixel format is valid <br>if (! (ddSurfDesc.dwFlags &amp; DDSD_PIXELFORMAT)) <br>return DDERR_GENERIC; <br>if (ddSurfDesc.ddpfPixelFormat.dwSize != sizeof(DDPIXELFORMAT)) <br>return DDERR_GENERIC; <br> <br>// Get Width, height, BPP <br>dwW= ddSurfDesc.dwWidth; <br>dwH= ddSurfDesc.dwHeight; <br>dwBPP= ddSurfDesc.ddpfPixelFormat.dwRGBBitCount; <br>dwRefresh= 0L; <br> <br>// Success <br>return DD_OK; <br>} // DDModeInfo::GetMode <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DDModeInfo::ModeSupportedByDevice <br>**  Purpose:     <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>BOOL DDModeInfo::ModeSupported (LPD3DDevInfo lpDevice) <br>{ <br>// Check Parameters <br>if (! lpDevice) <br>return FALSE; <br> <br>// Make sure D3D device supports this mode <br>DWORD dwBPP    = GetBPP (); <br>DWORD dwFlag   = BitDepthToFlags (dwBPP); <br>DWORD dwDepths = 0L; <br> <br>// Get Supported Bit Depths for this D3D device <br>if (lpDevice-&gt;isHardware ()) <br>dwDepths = lpDevice-&gt;d3dHalDesc.dwDeviceRenderBitDepth; <br>else <br>dwDepths = lpDevice-&gt;d3dHelDesc.dwDeviceRenderBitDepth; <br> <br>if (dwDepths &amp; dwFlag) <br>{ <br>// Supported !!! <br>return TRUE; <br>} <br> <br>// Not Supported !!! <br>return FALSE; <br>} // End DDModeInfo::ModeSupported <br>   <br> <br>   <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DDModeInfo::Match <br>**  Purpose:    Checks if this mode matches (w,h,bpp) <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>BOOL DDModeInfo::Match (DWORD dwW, DWORD dwH, DWORD dwBPP) <br>{ <br>    // Check parameters <br>    if (ddSurfDesc.dwSize != sizeof (DDSURFACEDESC)) <br>        return FALSE; <br> <br>// Check for Match <br>    if ((ddSurfDesc.dwWidth  == dwW) &amp;&amp; <br>        (ddSurfDesc.dwHeight == dwH)) <br>{ <br>if (ddSurfDesc.ddpfPixelFormat.dwRGBBitCount == dwBPP) <br>return TRUE; <br>    } <br> <br>    return FALSE; <br>} // DDModeInfo::Match <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DDDrvInfo::Match <br>**  Purpose:    Checks if this mode matches with this surface desc <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>BOOL DDModeInfo::Match (const DDSURFACEDESC &amp; ddsd) <br>{ <br>    // Check parameters <br>    if (ddsd.dwSize != sizeof (DDSURFACEDESC)) <br>        return FALSE; <br> <br>    // Check Height <br>    if (ddsd.dwFlags &amp; DDSD_HEIGHT) <br>    { <br>        if (ddsd.dwHeight != ddSurfDesc.dwHeight) <br>            return FALSE; <br>    } <br> <br>    // Check Width <br>    if (ddsd.dwFlags &amp; DDSD_WIDTH) <br>    { <br>        if (ddsd.dwWidth != ddSurfDesc.dwWidth) <br>            return FALSE; <br>    } <br> <br>    // Check Pitch <br>    if (ddsd.dwFlags &amp; DDSD_PITCH) <br>    { <br>        if (ddsd.lPitch != ddSurfDesc.lPitch) <br>            return FALSE; <br>    } <br> <br>    // Check Back Buffer count <br>    if (ddsd.dwFlags &amp; DDSD_BACKBUFFERCOUNT) <br>    { <br>        if (ddsd.dwBackBufferCount != ddSurfDesc.dwBackBufferCount) <br>            return FALSE; <br>    } <br> <br>    // Check MipMap count <br>    if (ddsd.dwFlags &amp; DDSD_MIPMAPCOUNT) <br>    { <br>        if (ddsd.dwMipMapCount != ddSurfDesc.dwMipMapCount) <br>            return FALSE; <br>    } <br> <br>    // Check ZBufferBitDepth <br>    if (ddsd.dwFlags &amp; DDSD_ZBUFFERBITDEPTH) <br>    { <br>        if (ddsd.dwZBufferBitDepth != ddSurfDesc.dwZBufferBitDepth) <br>            return FALSE; <br>    } <br> <br>    // Check Refresh Rate <br>    if (ddsd.dwFlags &amp; DDSD_REFRESHRATE) <br>    { <br>        if (ddsd.dwRefreshRate != ddSurfDesc.dwRefreshRate) <br>            return FALSE; <br>    } <br> <br>    // Check Alpha Bit Depth <br>    if (ddsd.dwFlags &amp; DDSD_ALPHABITDEPTH) <br>    { <br>        if (ddsd.dwAlphaBitDepth != ddSurfDesc.dwAlphaBitDepth) <br>            return FALSE; <br>    } <br> <br>    // Check ColorKey Dest Blt <br>    if (ddsd.dwFlags &amp; DDSD_CKDESTBLT) <br>    { <br> <br>        if (ddsd.ddckCKDestBlt.dwColorSpaceLowValue !=  <br>            ddSurfDesc.ddckCKDestBlt.dwColorSpaceLowValue) <br>            return FALSE; <br> <br>        if (ddsd.ddckCKDestBlt.dwColorSpaceHighValue !=  <br>            ddSurfDesc.ddckCKDestBlt.dwColorSpaceHighValue) <br>            return FALSE; <br>    } <br> <br>    // Check ColorKey Dest Overlay <br>    if (ddsd.dwFlags &amp; DDSD_CKDESTBLT) <br>    { <br> <br>        if (ddsd.ddckCKDestOverlay.dwColorSpaceLowValue !=  <br>            ddSurfDesc.ddckCKDestOverlay.dwColorSpaceLowValue) <br>            return FALSE; <br> <br>        if (ddsd.ddckCKDestOverlay.dwColorSpaceHighValue !=  <br>            ddSurfDesc.ddckCKDestOverlay.dwColorSpaceHighValue) <br>            return FALSE; <br>    } <br> <br>     <br>    // Check ColorKey Src Blt </code></pre>
<p>
</p>
<pre><code>if (ddsd.dwFlags &amp; DDSD_CKSRCBLT) <br>    { <br> <br>        if (ddsd.ddckCKSrcBlt.dwColorSpaceLowValue !=  <br>            ddSurfDesc.ddckCKSrcBlt.dwColorSpaceLowValue) <br>            return FALSE; <br> <br>        if (ddsd.ddckCKSrcBlt.dwColorSpaceHighValue !=  <br>            ddSurfDesc.ddckCKSrcBlt.dwColorSpaceHighValue) <br>            return FALSE; <br>    } <br> <br>    // Check ColorKey Src Overlay <br>    if (ddsd.dwFlags &amp; DDSD_CKSRCOVERLAY) <br>    { <br> <br>        if (ddsd.ddckCKSrcOverlay.dwColorSpaceLowValue !=  <br>            ddSurfDesc.ddckCKSrcOverlay.dwColorSpaceLowValue) <br>            return FALSE; <br> <br>        if (ddsd.ddckCKSrcOverlay.dwColorSpaceHighValue !=  <br>            ddSurfDesc.ddckCKSrcOverlay.dwColorSpaceHighValue) <br>            return FALSE; <br>    } <br> <br> <br>    // Check Pixel Format <br>    if (ddsd.dwFlags &amp; DDSD_PIXELFORMAT) <br>    { <br>if (! Match (ddsd.ddpfPixelFormat)) <br>return FALSE; <br>    } <br> <br>    // Check Caps <br>    if (ddsd.dwFlags &amp; DDSD_CAPS) <br>    { <br>        // Superset is OK <br>        if ((ddsd.ddsCaps.dwCaps &amp; ddSurfDesc.ddsCaps.dwCaps) != <br>            ddsd.ddsCaps.dwCaps) <br>            return FALSE; <br>    } <br> <br>    // Success, we have a match <br>    return TRUE; <br>} // DDModeInfo::Match <br>   <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DDModeInfo::Match <br>**  Purpose:    Checks if this mode matches (bpp) <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>BOOL DDModeInfo::Match (DWORD dwBPP) <br>{ <br>    // Check parameters <br>    if (ddSurfDesc.dwSize != sizeof (DDSURFACEDESC)) <br>        return FALSE; <br> <br>// Check for Match <br>if (ddSurfDesc.ddpfPixelFormat.dwRGBBitCount == dwBPP) <br>return TRUE; <br> <br>    return FALSE; <br>} // DDModeInfo::Match <br>   <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DDDrvInfo::Match <br>**  Purpose:    Checks if this mode matches the requested pixel format <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>BOOL DDModeInfo::Match (const DDPIXELFORMAT &amp; ddpf) <br>{ <br>DWORD dwCheck; <br> <br>    // Check parameters <br>if (ddpf.dwSize != sizeof (DDPIXELFORMAT)) <br>return FALSE; <br> <br>// Check Alpha-Only flag <br>    if (ddpf.dwFlags &amp; DDPF_ALPHA) <br>    { <br>// Is this mode alpha only too ?!? <br>        if (! (ddSurfDesc.ddpfPixelFormat.dwFlags &amp; DDPF_ALPHA)) <br>            return FALSE; <br> <br>// Do Alpha bit depths match ?!? <br>if (ddpf.dwAlphaBitDepth != ddSurfDesc.ddpfPixelFormat.dwAlphaBitDepth) <br>return FALSE; <br>    } <br> <br>// Check ZBuffer-Only flag <br>    if (ddpf.dwFlags &amp; DDPF_ZBUFFER) <br>    { <br>// Is this mode Z-buffer only too ?!? <br>        if (! (ddSurfDesc.ddpfPixelFormat.dwFlags &amp; DDPF_ZBUFFER)) <br>            return FALSE; <br> <br>// Do Z-depths match ?!? <br>if (ddpf.dwZBufferBitDepth != ddSurfDesc.ddpfPixelFormat.dwZBufferBitDepth) <br>return FALSE; <br>    } <br> <br>// Check Compressed flag <br>if (ddpf.dwFlags &amp; DDPF_COMPRESSED) <br>{ <br>// Is this mode compressed too ?!? <br>        if (! (ddSurfDesc.ddpfPixelFormat.dwFlags &amp; DDPF_COMPRESSED)) <br>            return FALSE; <br>} <br> <br>// Check FourCC flag <br>if (ddpf.dwFlags &amp; DDPF_FOURCC) <br>{ <br>// Is this mode a fourCC code too ?!? <br>if (! (ddSurfDesc.ddpfPixelFormat.dwFlags &amp; DDPF_FOURCC)) <br>return FALSE; <br> <br>// Do fourCC codes match ?!? <br>if (ddSurfDesc.ddpfPixelFormat.dwFourCC != ddpf.dwFourCC) <br>return FALSE; <br>} <br> <br>    // Check Palette flags <br>dwCheck = DDPF_PALETTEINDEXED1 | DDPF_PALETTEINDEXED2 | <br>      DDPF_PALETTEINDEXED4 | DDPF_PALETTEINDEXED8 | <br>  DDPF_PALETTEINDEXEDTO8; <br>if (ddpf.dwFlags &amp; dwCheck) <br>{ <br>DWORD dwOne = ddpf.dwFlags &amp; dwCheck; <br>DWORD dwTwo = ddSurfDesc.ddpfPixelFormat.dwFlags &amp; dwCheck; <br> <br>// Do palette formats match ?!? <br>if (dwOne != dwTwo) <br>return FALSE; <br>} <br> <br>// Check RGB flags <br>if (ddpf.dwFlags &amp; DDPF_RGB) <br>{ <br>// Does this mode support RGB too ??? <br>if (! (ddSurfDesc.ddpfPixelFormat.dwFlags &amp; DDPF_RGB)) <br>return FALSE; <br> <br>// Check RGBTOYUV flag <br>if (ddpf.dwFlags &amp; DDPF_RGBTOYUV) <br>{ <br>// Does this mode support RGBTOYUV too??? <br>if (! (ddSurfDesc.ddpfPixelFormat.dwFlags &amp; DDPF_RGBTOYUV)) <br>return FALSE; <br>} <br> <br>// Do BPP's match? <br>if (ddpf.dwRGBBitCount != ddSurfDesc.ddpfPixelFormat.dwRGBBitCount) <br>return FALSE; <br> <br>// Do Masks match <br>if (ddpf.dwRBitMask != ddSurfDesc.ddpfPixelFormat.dwRBitMask) <br>return FALSE; <br> <br>if (ddpf.dwGBitMask != ddSurfDesc.ddpfPixelFormat.dwGBitMask) <br>return FALSE; <br> <br>if (ddpf.dwBBitMask != ddSurfDesc.ddpfPixelFormat.dwBBitMask) <br>return FALSE; <br> <br>// Check Alpha Channel <br>if (ddpf.dwFlags &amp; DDPF_ALPHAPIXELS) <br>{ <br>// Does this mode support Alphachannel as well ?!? <br>if (! (ddSurfDesc.ddpfPixelFormat.dwFlags &amp; DDPF_ALPHAPIXELS)) <br>return FALSE; <br> <br>// Do Alpha channel masks match <br>if (ddpf.dwRGBAlphaBitMask != ddSurfDesc.ddpfPixelFormat.dwRGBAlphaBitMask) <br>return FALSE; <br>} <br> <br>// Check Z channel <br>if (ddpf.dwFlags &amp; DDPF_ZPIXELS) <br>{ <br>// Does this mode support Z channel as well ?!? <br>if (! (ddSurfDesc.ddpfPixelFormat.dwFlags &amp; DDPF_ZPIXELS)) <br>return FALSE; <br> <br>// Do Z channel masks match <br>if (ddpf.dwRGBZBitMask != ddSurfDesc.ddpfPixelFormat.dwRGBZBitMask) <br>return FALSE; <br>} <br>} <br> <br>// Check YUV flags <br>if (ddpf.dwFlags &amp; DDPF_YUV) <br>{ <br>// Does this mode support YUV too ??? <br>if (! (ddSurfDesc.ddpfPixelFormat.dwFlags &amp; DDPF_YUV)) <br>return FALSE; <br> <br>// Do BPP's match? <br>if (ddpf.dwYUVBitCount != ddSurfDesc.ddpfPixelFormat.dwYUVBitCount) <br>return FALSE; <br> <br>// Do Masks match <br>if (ddpf.dwYBitMask != ddSurfDesc.ddpfPixelFormat.dwYBitMask) <br>return FALSE; <br> <br>if (ddpf.dwUBitMask != ddSurfDesc.ddpfPixelFormat.dwUBitMask) <br>return FALSE; <br> <br>if (ddpf.dwVBitMask != ddSurfDesc.ddpfPixelFormat.dwVBitMask) <br>return FALSE; <br> <br>// Check Alpha channel <br>if (ddpf.dwFlags &amp; DDPF_ALPHAPIXELS) <br>{ <br>// Does this mode support Alphachannel as well ?!? <br>if (! (ddSurfDesc.ddpfPixelFormat.dwFlags &amp; DDPF_ALPHAPIXELS)) <br>return FALSE; <br> <br>// Do Alpha channel masks match <br>if (ddpf.dwYUVAlphaBitMask != ddSurfDesc.ddpfPixelFormat.dwYUVAlphaBitMask) <br>return FALSE; <br>} <br> <br>// Check Z channel <br>if (ddpf.dwFlags &amp; DDPF_ZPIXELS) <br>{ <br>// Does this mode support Z channel as well ?!? <br>if (! (ddSurfDesc.ddpfPixelFormat.dwFlags &amp; DDPF_ZPIXELS)) <br>return FALSE; <br> <br>// Do Z channel masks match <br>if (ddpf.dwRGBZBitMask != ddSurfDesc.ddpfPixelFormat.dwRGBZBitMask) <br>return FALSE; <br>} <br>} <br> <br>    // Success, we have a match <br>    return TRUE; <br>} // DDModeInfo::Match <br>   <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  D3DDevInfo Methods <br>**----------------------------------------------------------------------------- <br>*/ <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       D3DDevInfo::isHardware <br>**  Purpose:    Checks if this D3D Device is a hardware driver <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>BOOL D3DDevInfo::isHardware (void) <br>{ <br>    // No correct way of doing this, <br>    // but if the hardware caps don't specify a shading <br>    // model then it probably isn't hardware accelerated <br>    DWORD dwColorModel = d3dHalDesc.dcmColorModel; <br>    if (dwColorModel) <br>        return TRUE; <br>    return FALSE; <br>} // End D3DDevInfo::isHardware <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DDDrvInfo::Match <br>**  Purpose:    Checks if this D3D Device matches this guid <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>BOOL D3DDevInfo::Match (LPGUID lpGuid) <br>{ <br>    if (lpGuid == NULL) <br>        return FALSE; <br> <br>    if (! isValid ()) <br>        return FALSE; <br>     <br>    if (guid != *lpGuid) <br>        return FALSE; <br> <br>    // Success <br>    return TRUE; <br>} // End D3DDevInfo::Match <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       D3DDevInfo::Match <br>**  Purpose:    Checks if this D3D Device matches the specified <br>**              hardware and/or software description <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>BOOL D3DDevInfo::Match (LPD3DDEVICEDESC lpHal, LPD3DDEVICEDESC lpHel) <br>{ <br>    if (! isValid ()) <br>        return FALSE; <br> <br>    // Check Parameters <br>    if ((! lpHal) &amp;&amp; (! lpHel)) <br>        return FALSE; <br> <br>    // <br>    // Compare Hal description's <br>    // <br>    if (lpHal) <br>    { <br>        if (lpHal-&gt;dwSize != sizeof (D3DDEVICEDESC)) <br>            return FALSE; <br> <br>        // Check ColorModel <br>        if (lpHal-&gt;dwFlags &amp; D3DDD_COLORMODEL) <br>        { <br>            // If it does more than we are interested in that's OK <br>            if ((lpHal-&gt;dcmColorModel &amp; d3dHalDesc.dcmColorModel) !=  <br>                lpHal-&gt;dcmColorModel) <br>                return FALSE; <br>        } <br> <br>        // Check Device Caps <br>        if (lpHal-&gt;dwFlags &amp; D3DDD_DEVCAPS) <br>        { <br>            // If it does more than we are asking, that's OK <br>            if ((lpHal-&gt;dwDevCaps &amp; d3dHalDesc.dwDevCaps) != <br>                lpHal-&gt;dwDevCaps) <br>                return FALSE; <br>        } <br> <br>        // Check transform caps <br>        if (lpHal-&gt;dwFlags &amp; D3DDD_TRANSFORMCAPS) <br>        { <br>            // Note: Flesh this out later <br>        } <br> <br>        // Check Clipping  <br>        if (lpHal-&gt;dwFlags &amp; D3DDD_BCLIPPING) <br>        { <br>            if (lpHal-&gt;bClipping != d3dHalDesc.bClipping) <br>                return FALSE; <br>        } <br> <br>        // Check lighting caps <br>        if (lpHal-&gt;dwFlags &amp; D3DDD_LIGHTINGCAPS) <br>        { <br>            // Note: Flesh this out later <br>        } <br>         <br>        // Check line caps <br>        if (lpHal-&gt;dwFlags &amp; D3DDD_LINECAPS) <br>        { <br>            // Note: Flesh this out later <br>        } <br> <br>        // Check triangle caps <br>        if (lpHal-&gt;dwFlags &amp; D3DDD_TRICAPS) <br>        { <br>            // Note: Flesh this out later <br>        } <br> <br>        // Check Render Surface bit depth <br>        if (lpHal-&gt;dwDeviceRenderBitDepth) <br>        { <br>             if (lpHal-&gt;dwDeviceRenderBitDepth != d3dHalDesc.dwDeviceRenderBitDepth) <br>                return FALSE; <br>        } <br> <br>        // Check Z-Buffer surface bit depth <br>        if (lpHal-&gt;dwDeviceZBufferBitDepth) <br>        { <br>            if (lpHal-&gt;dwDeviceZBufferBitDepth != d3dHalDesc.dwDeviceZBufferBitDepth) <br>                return FALSE; <br>        } <br> <br>        // Check Max buffer size <br>        if (lpHal-&gt;dwFlags &amp; D3DDD_MAXBUFFERSIZE) <br>        { <br>            // Only worry, if it is smaller than what we want <br>            if (lpHal-&gt;dwMaxBufferSize &gt; d3dHalDesc.dwMaxBufferSize) <br>                return FALSE; <br>        } <br> <br>        // Check Max Vertex count <br>        if (lpHal-&gt;dwFlags &amp; D3DDD_MAXVERTEXCOUNT) <br>        { <br>            // Only worry, if it is smaller than what we want <br>            if (lpHal-&gt;dwMaxVertexCount &gt; d3dHalDesc.dwMaxVertexCount) <br>                return FALSE; <br>        } <br>    } <br> <br>     <br>    // <br>    // Compare Hel description's <br>    // <br>    if (lpHel) <br>    { <br>        if (lpHel-&gt;dwSize != sizeof (D3DDEVICEDESC)) <br>            return FALSE; <br> <br>        // Check ColorModel <br>        if (lpHel-&gt;dwFlags &amp; D3DDD_COLORMODEL) <br>        { <br>            // If it does more than we are interested in that's OK <br>            if ((lpHel-&gt;dcmColorModel &amp; d3dHelDesc.dcmColorModel) !=  <br>                lpHel-&gt;dcmColorModel) <br>                return FALSE; <br>        } <br> <br>        // Check Device Caps <br>        if (lpHel-&gt;dwFlags &amp; D3DDD_DEVCAPS) <br>        { <br>            // If it does more than we are asking, that's OK <br>            if ((lpHel-&gt;dwDevCaps &amp; d3dHelDesc.dwDevCaps) != <br>                lpHel-&gt;dwDevCaps) <br>                return FALSE; <br>        } <br> <br>        // Check transform caps <br>        if (lpHel-&gt;dwFlags &amp; D3DDD_TRANSFORMCAPS) <br>        { <br>            // Note: Flesh this out later <br>        } <br> <br>        // Check Clipping  <br>        if (lpHel-&gt;dwFlags &amp; D3DDD_BCLIPPING) <br>        { <br>            if (lpHel-&gt;bClipping != d3dHelDesc.bClipping) <br>                return FALSE; <br>        } <br> <br>        // Check lighting caps <br>        if (lpHel-&gt;dwFlags &amp; D3DDD_LIGHTINGCAPS) <br>        { <br>            // Note: Flesh this out later <br>        } <br>         <br>        // Check line caps <br>        if (lpHel-&gt;dwFlags &amp; D3DDD_LINECAPS) <br>        { <br>            // Note: Flesh this out later <br>        } <br> <br>        // Check triangle caps <br>        if (lpHel-&gt;dwFlags &amp; D3DDD_TRICAPS) <br>        { <br>            // Note: Flesh this out later <br>        } <br> <br>        // Check Render Surface bit depth <br>        if (lpHel-&gt;dwDeviceRenderBitDepth) <br>        { <br>             if (lpHel-&gt;dwDeviceRenderBitDepth != d3dHelDesc.dwDeviceRenderBitDepth) <br>                return FALSE; <br>        } <br> <br>        // Check Z-Buffer surface bit depth <br>        if (lpHel-&gt;dwDeviceZBufferBitDepth) <br>        { <br>            if (lpHel-&gt;dwDeviceZBufferBitDepth != d3dHelDesc.dwDeviceZBufferBitDepth) <br>                return FALSE; <br>        } <br> <br>        // Check Max buffer size <br>        if (lpHel-&gt;dwFlags &amp; D3DDD_MAXBUFFERSIZE) <br>        { <br>            // Only worry, if it is smaller than what we want <br>            if (lpHel-&gt;dwMaxBufferSize &gt; d3dHelDesc.dwMaxBufferSize) <br>                return FALSE; <br>        } <br> <br>        // Check Max Vertex count <br>        if (lpHel-&gt;dwFlags &amp; D3DDD_MAXVERTEXCOUNT) <br>        { <br>            // Only worry, if it is smaller than what we want <br>            if (lpHel-&gt;dwMaxVertexCount &gt; d3dHelDesc.dwMaxVertexCount) <br>                return FALSE; <br>        } <br>    } <br> <br>    // Success <br>    return TRUE; <br>} // End D3DDevInfo::Match <br>   <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       D3DDevInfo::Create <br>**  Purpose:    Creates a new D3D Device  <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DDevInfo::Create ( <br>    LPGUID          lpD3DGuid, <br>    LPTSTR          lpD3DName,  <br>    LPTSTR          lpD3DDesc,  <br>    LPD3DDEVICEDESC lpD3DHal,  <br>    LPD3DDEVICEDESC lpD3DHel) <br>{ <br>    // Copy GUID <br>    if (! lpD3DGuid) <br>    { <br>        // Error, Invalid device <br>        return DDERR_INVALIDPARAMS; <br>    } <br>    guid = *lpD3DGuid; <br> <br>     <br>// Copy Name <br>LPTSTR szTemp; <br>    if (! lpD3DName) <br>    { <br>szTemp = TEXT("UNKNOWN"); <br>    } <br>    else <br>    { <br>        szTemp = lpD3DName; <br>    } <br> <br>    DWORD cLen = _tcslen (szTemp); <br>DWORD cbSize = (cLen + 1) * sizeof(TCHAR); <br>szName = (LPTSTR) malloc (cbSize); <br>if (szName) <br>{ <br>_tcsncpy (szName, szTemp, cLen); <br>szName[cLen] = 0; <br>} <br> <br>     <br>    // Copy Description <br>    if (! lpD3DDesc) <br>    { <br>szTemp = TEXT("UNKNOWN"); <br>    } <br>    else <br>    { <br>        szTemp = lpD3DDesc; <br>    } <br> <br>    cLen = _tcslen (szTemp); <br>cbSize = (cLen + 1) * sizeof(TCHAR); <br>szDesc = (LPTSTR) malloc (cbSize); <br>if (szDesc) <br>{ <br>_tcsncpy (szDesc, szTemp, cLen); <br>szDesc[cLen] = 0; <br>} <br> <br> <br>    // Copy D3D info <br>    if (lpD3DHal) <br>    { <br>        d3dHalDesc = *lpD3DHal; <br>    } <br> <br>    if (lpD3DHel) <br>    { <br>        d3dHelDesc = *lpD3DHel; <br>    } <br> <br>// Mark Texture format list as not loaded <br>cFormats = 0L; <br>turnFormatsLoadedOff (); <br> <br>// Mark as valid <br>    validOn (); <br> <br>    return DD_OK; <br>} // End D3DDevInfo::Create <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       D3DDevInfo::Destroy <br>**  Purpose:    Cleanup any memory or interfaces <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>void D3DDevInfo::Destroy (void) <br>{ <br>// Destroy Texture Formats <br>DestroyFormats (); <br> <br>// Clean up strings <br>if (szDesc) <br>{ <br>free (szDesc); <br>szDesc = NULL; <br>} <br> <br>if (szName) <br>{ <br>free (szName); <br>szName = NULL; <br>} <br> <br>lpPrev = NULL; <br>lpNext = NULL; <br>} // End D3DDevInfo::Destroy <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       D3DDevInfo::LoadFormats <br>**  Purpose:    Loads texture formats <br>**  Notes: <br>** <br>**In order to load texture formats, we need to have a valid D3D Device <br>**Getting a D3D Device directly complicates the Driver Manager code. <br>** <br>**So we will defer loading texture formats until we have created a valid  <br>**  D3D device in D3DWindow::InitRender and then call this function to  <br>**  Load all the texture formats. <br>** <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DDevInfo::LoadFormats (LPDIRECT3DDEVICE2 lpD3DDevice) <br>{ <br>// Have we already loaded the texture formats <br>if (! formatsLoaded ()) <br>{ <br>HRESULT hResult; <br>    DD_CB_INFOcbInfo; <br> <br>// Check Parameters <br>if (! lpD3DDevice) <br>{ <br>hResult = APPERR_INVALIDPARAMS; <br>REPORTERR (hResult); <br>return hResult; <br>} <br> <br>// Enumerate all Texture Formats for this device <br>cbInfo.fResult  = TRUE; <br>cbInfo.lpExtra  = (void *)this; <br>cbInfo.cCount   = 0L; <br> <br>hResult = lpD3DDevice-&gt;EnumTextureFormats (TextureFormatEnumCallback,  <br>   (void *)&amp;cbInfo); <br>if (FAILED(hResult)) <br>{ <br>// Error <br>REPORTERR (hResult); <br>return hResult; <br>} <br> <br>// Double check count <br>if ((! cbInfo.fResult) || (cbInfo.cCount == 0) || (cFormats != cbInfo.cCount)) <br>{ <br>hResult = APPERR_GENERIC; <br>REPORTERR (hResult); <br>return hResult; <br>} <br> <br>// Mark texture formats as loaded <br>turnFormatsLoadedOn (); <br>} <br> <br>// Success <br>return DD_OK; <br>} // D3DDevInfo::LoadFormats <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       D3DDevInfo::DestroyFormats <br>**  Purpose:    Destroys texture formats <br>**----------------------------------------------------------------------------- <br>*/ <br>   <br>HRESULT D3DDevInfo::DestroyFormats (void) <br>{ <br>if (formatsLoaded ()) <br>{ <br>LPDDModeInfo lpCurr, lpNext, lpPrev; <br> <br>lpCurr = lpFormatRoot; <br> <br>// Walk linked list and destroy all Format nodes <br>while (lpCurr) <br>{ <br>lpNext = lpCurr-&gt;lpNext; <br>lpPrev = lpCurr-&gt;lpPrev; <br> <br>// Remove node from List <br>if (lpPrev) <br>lpPrev-&gt;lpNext = lpNext; <br>else <br>lpFormatRoot = lpNext; <br> <br>if (lpNext) <br>lpNext-&gt;lpPrev = lpPrev; <br>else <br>lpFormatTail = lpPrev; <br> <br>// Destroy this node <br>lpCurr-&gt;lpNext = NULL; <br>lpCurr-&gt;lpPrev = NULL; <br>delete lpCurr; <br> <br>// Move to next node in list <br>lpCurr = lpNext; <br>} <br> <br>cFormats = 0L; <br>lpFormatRoot = NULL; <br>lpFormatTail = NULL; <br> <br>// Mark as unloaded <br>turnFormatsLoadedOff (); <br>} <br> <br>// Success <br>return DD_OK; <br>} // End D3DDevInfo::DestroyFormats  <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       D3DDevInfo::AddFormat <br>**  Purpose:    add new texture format to format list <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DDevInfo::AddFormat (LPDDModeInfo lpFormatNew) <br>{ <br>// Check Parameters <br>if (! lpFormatNew) <br>{ <br>// Error, Invalid parameters <br>return DDERR_INVALIDPARAMS; <br>} <br> <br>// Add to tail of Format List <br>lpFormatNew-&gt;lpPrev = lpFormatTail; <br>lpFormatNew-&gt;lpNext = NULL; <br> <br>// Update tail <br>if (lpFormatTail) <br>lpFormatTail-&gt;lpNext = lpFormatNew; <br>lpFormatTail = lpFormatNew; <br> <br>// Update Root <br>if (! lpFormatRoot) <br>lpFormatRoot = lpFormatNew; <br> <br>// Update count <br>cFormats++; <br> <br>// Success <br>return DD_OK; <br>} // End D3DDevInfo::AddFormat <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       D3DDevInfo::DelFormat <br>**  Purpose:    removes texture format from format list <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DDevInfo::DelFormat (LPDDModeInfo lpFormatDel) <br>{ <br>// Check parameters <br>if (lpFormatDel) <br>{ <br>// Error <br>return DDERR_INVALIDPARAMS; <br>} <br> <br>// Remove this Mode From mode list <br>    LPDDModeInfo lpPrevMode = lpFormatDel-&gt;lpPrev; <br>    LPDDModeInfo lpNextMode = lpFormatDel-&gt;lpNext; <br> <br>    if (lpPrevMode) <br>        lpPrevMode-&gt;lpNext = lpNextMode; <br>    else <br>        lpFormatRoot = lpNextMode; <br> <br>    if (lpNextMode) <br>lpNextMode-&gt;lpPrev = lpPrevMode; <br>else <br>lpFormatTail = lpPrevMode; <br> <br>    // Destroy format node <br>lpFormatDel-&gt;lpPrev = NULL; <br>    lpFormatDel-&gt;lpNext = NULL; <br>    delete lpFormatDel; <br> <br>// Update count <br>cFormats--; <br> <br>// Success <br>return DD_OK; <br>} // End D3DDevInfo::DelFormat <br>   <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       D3DDevInfo::FindFormat <br>**  Purpose:    finds specified texture format <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LPDDModeInfo D3DDevInfo::FindFormat ( <br>LPDDPIXELFORMAT lpddpf,/* In:Texture Format Desc */ <br>LPDDModeInfo *  lpNextBest,/* Out:Second best match */ <br>LPDDModeInfo    lpStart)/* In:start from this node */ <br>{ <br>LPDDModeInfolpCurrFormat, lpNextFormat; <br> <br>// Get Starting node <br>if (! lpStart) <br>lpCurrFormat = lpFormatRoot; <br>else <br>lpCurrFormat = lpStart; <br> <br>if (lpNextBest) <br>*lpNextBest = lpCurrFormat; <br> <br>// Search format list for best match <br>    while (lpCurrFormat) <br>{ <br>lpNextFormat = lpCurrFormat-&gt;lpNext; <br>        if (lpCurrFormat-&gt;Match (*lpddpf)) <br>        { <br>            return lpCurrFormat; <br>        } <br> <br>lpCurrFormat = lpNextFormat; <br>    } <br> <br>    // Failure, user may use lpNextBest instead <br>    return NULL; <br>} // End D3DDevInfo::FindFormat <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       D3DDevInfo::FindFormat <br>**  Purpose:    finds specified texture format from requested BPP <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LPDDModeInfo D3DDevInfo::FindFormat ( <br>DWORDbpp,/* In:requested BPP */ <br>LPDDModeInfo *  lpNextBest,/* Out:Second best match */ <br>LPDDModeInfo    lpStart)/* In:start from this node */ <br>{ <br>LPDDModeInfolpCurrFormat, lpNextFormat; <br> <br>// Get Starting node <br>if (! lpStart) <br>lpCurrFormat = lpFormatRoot; <br>else <br>lpCurrFormat = lpStart; <br> <br>if (lpNextBest) <br>*lpNextBest = lpCurrFormat; <br> <br>// Search format list for best match <br>    while (lpCurrFormat) <br>{ <br>lpNextFormat = lpCurrFormat-&gt;lpNext; <br>        if (lpCurrFormat-&gt;Match (bpp)) <br>        { <br>            return lpCurrFormat; <br>        } <br> <br>lpCurrFormat = lpNextFormat; <br>    } <br> <br>    // Failure, user may use lpNextBest instead <br>    return NULL; <br>} // End D3DDevInfo::FindFormat <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       D3DDevInfo::EnumFormats <br>**  Purpose:    Enumerate Formats in this Device <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>DWORD D3DDevInfo::EnumFormats (const D3DDEV_ENUMINFO &amp; eiInfo) <br>{ <br>    DWORD           dwResult = ENUM_FAILURE; <br>LPDDModeInfolpCurrFormat, lpNextFormat; <br> <br>    // Check Match Callback function <br>    if (! eiInfo.fpcbEnum) <br>    { <br>        // Error, invalid callback <br>        return ENUM_ERROR; <br>    } <br> <br>// Get Starting node <br>if (eiInfo.lpStart) <br>lpCurrFormat = (LPDDModeInfo)(eiInfo.lpStart); <br>else <br>lpCurrFormat = lpFormatRoot; <br> <br>// Do callback on each node in list <br>while (lpCurrFormat) <br>{ <br>lpNextFormat = lpCurrFormat-&gt;lpNext; <br> <br>        // Call Enum Mode Callback <br>        dwResult = (*eiInfo.fpcbEnum)((LPVOID)this, lpCurrFormat, eiInfo.dwExtra); <br> <br>        // Check for early exit <br>        if (dwResult &amp; ENUM_STOP) <br>        { <br>            // Return result code <br>            return (dwResult &amp; ~ENUM_STOP); <br>        } <br>   } <br> <br>    // Failure <br>    return (dwResult &amp; ~ENUM_STOP); <br>} // End D3DDevInfo::EnumFormats <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  DDDrvInfo Methods <br>**----------------------------------------------------------------------------- <br>*/ <br>     <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DDDrvInfo::Create <br>**  Purpose:    Create a new Driver description <br>**  Notes: <br>**1.  If the driver doesn't support D3D we treat it as an invalid driver. <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT DDDrvInfo::Create ( <br>GUID FAR *      lpGuid, <br>    LPTSTR          lpDriverName,  <br>    LPTSTR          lpDriverDesc) <br>{ <br>    HRESULT         hResult; <br>    LPDIRECTDRAW    lpDD  = NULL; <br>    LPDIRECTDRAW2   lpDD2 = NULL; <br>    LPDIRECT3D2     lpD3D = NULL; <br> <br>    if (isValid ()) <br>    { <br>        // Programmer Error, already valid, call Fini to cleanup <br>        return FALSE; <br>    } <br> <br> <br>    // Copy GUID <br>    if (! lpGuid) <br>    { <br>        primaryOn (); <br>    } <br>    else <br>    { <br>        guid = *lpGuid; <br>    } <br> <br>    // Copy Name <br>LPTSTRszTemp; <br>    if (! lpDriverName) <br>{ <br>szTemp = TEXT("UNKNOWN"); <br>} <br>    else <br>    { <br>szTemp = lpDriverName; <br>    } <br> <br>DWORD cLen = _tcslen (szTemp); <br>DWORD cbSize = (cLen + 1) * sizeof(TCHAR); <br>szName = (LPTSTR) malloc (cbSize); <br>if (szName) <br>{ <br>_tcsncpy (szName, szTemp, cLen); <br>szName[cLen] = 0; <br>} <br> <br>    // Copy Desc <br>    if (! lpDriverDesc) <br>{ <br>szTemp = TEXT("UNKNOWN"); <br>} <br>    else <br>    { <br>szTemp = lpDriverDesc; <br>    } <br> <br>cLen = _tcslen (szTemp); <br>cbSize = (cLen + 1) * sizeof(TCHAR); <br>szDesc = (LPTSTR) malloc (cbSize); <br>if (szDesc) <br>{ <br>_tcsncpy (szDesc, szTemp, cLen); <br>szDesc[cLen] = 0; <br>} <br> <br>    // Create DirectDraw Object <br>    hResult = DirectDrawCreate (lpGuid, &amp;lpDD, NULL); <br>    if FAILED (hResult) <br>    { <br>        // Error <br>        REPORTERR (hResult); <br>        goto lblCLEANUP; <br>    } <br>     <br>    // Get The DirectDraw2 Interface <br>    hResult = lpDD-&gt;QueryInterface ((REFIID)IID_IDirectDraw2, (void **)&amp;lpDD2); <br>    if (FAILED(hResult)) <br>    { <br>        // Error <br>        REPORTERR (hResult); <br>        goto lblCLEANUP; <br>    } <br> <br>    // Get The Direct3D Interface <br>    hResult = lpDD-&gt;QueryInterface ((REFIID)IID_IDirect3D2, (void **)&amp;lpD3D); <br>    if (FAILED(hResult)) <br>    { <br>        // Error <br>        REPORTERR (hResult); <br>        goto lblCLEANUP; <br>    } <br> <br>    // Get The Driver Caps <br>    ddHalCaps.dwSize = sizeof(DDCAPS); <br>    ddHelCaps.dwSize = sizeof(DDCAPS); <br>    hResult = lpDD2-&gt;GetCaps (&amp;ddHalCaps, &amp;ddHelCaps); <br>    if (FAILED(hResult)) <br>    { <br>        // Error <br>        REPORTERR (hResult); <br>        goto lblCLEANUP; <br>    } <br> <br> <br>// Enumerate all Modes for this DD Driver <br>cModes = 0L; <br>turnModesLoadedOff (); <br> <br>hResult = LoadModes (lpDD2); <br>if (FAILED (hResult)) <br>goto lblCLEANUP; <br> <br> <br>// Enumerate all D3D Devices for this driver <br>cDevices = 0L; <br>turnDevicesLoadedOff (); <br> <br>hResult = LoadDevices (lpD3D); <br>if (FAILED (hResult)) <br>goto lblCLEANUP; <br>         <br> <br>    // Mark as Valid Driver <br>    validOn (); <br> <br>    // Success <br>    hResult = DD_OK; <br> <br>lblCLEANUP: <br>    // Cleanup the Interfaces before leaving <br>    if (lpD3D)  <br>    { <br>        lpD3D-&gt;Release (); <br>        lpD3D = NULL; <br>    } <br> <br>    if (lpDD2)  <br>    { <br>        lpDD2-&gt;Release (); <br>        lpDD2 = NULL; <br>    } <br> <br>    if (lpDD) <br>    { <br>        lpDD-&gt;Release (); <br>        lpDD = NULL; <br>    } <br> <br>    return hResult; <br>} // End DDDrvInfo::Create <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DDDrvInfo::Destroy <br>**  Purpose:    Cleanup any memory or interfaces <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>void DDDrvInfo::Destroy (void) <br>{ <br>// Destroy all Modes and Devices <br>DestroyDevices (); <br>DestroyModes (); <br> <br>// Clean up strings <br>if (szDesc) <br>{ <br>free (szDesc); <br>szDesc = NULL; <br>} <br> <br>if (szName) <br>{ <br>free (szName); <br>szName = NULL; <br>} <br> <br>lpPrev = NULL; <br>lpNext = NULL; <br> <br>    // Mark as an invalid driver <br>    validOff (); <br>} // End DDDrvInfo::Destroy <br> <br>   <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DDDrvInfo::Match <br>**  Purpose:    checks for match with specified guid <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>BOOL DDDrvInfo::Match (LPGUID lpGuid) <br>{ <br>    if (! isValid()) <br>        return FALSE; <br> <br>    if (! lpGuid) <br>    { <br>        if (isPrimary()) <br>            return TRUE; <br>    } <br>    else <br>    { <br>        if (*lpGuid == guid) <br>            return TRUE; </code></pre>
<p>
</p>
<pre><code>} <br> <br>    return FALSE; <br>} // End DDDrvInfo::Match <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DDDrvInfo::Match <br>**  Purpose:    checks for match with specified hal,hel caps <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>BOOL DDDrvInfo::Match (LPDDCAPS lpHal, LPDDCAPS lpHel) <br>{ <br>    if (! isValid()) <br>        return FALSE; <br> <br>    if ((! lpHal) &amp;&amp; (! lpHel)) <br>        return FALSE; <br> <br>    // Check for match with hal caps <br>    if (lpHal) <br>    { <br>        // Flesh out later <br>    } <br> <br>    if (lpHal) <br>    { <br>        // Flesh out later <br>    } <br> <br>    // Success <br>    return TRUE; <br>} // End DDDrvInfo::Match <br> <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DDDrvInfo::LoadModes <br>**  Purpose:    Load all modes associated with this DD Driver <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT DDDrvInfo::LoadModes (LPDIRECTDRAW2 lpDD2) <br>{ <br>// Have we already loaded the modes <br>if (! modesLoaded ()) <br>{ <br>HRESULT hResult; <br>    DD_CB_INFOcbInfo; <br> <br>// Check Parameters <br>if (! lpDD2) <br>{ <br>hResult = APPERR_INVALIDPARAMS; <br>REPORTERR (hResult); <br>return hResult; <br>} <br> <br>    // Enumerate all modes for this driver <br>cbInfo.fResult  = TRUE; <br>cbInfo.lpExtra  = (void *)this; <br>cbInfo.cCount   = 0L; <br> <br>hResult = lpDD2-&gt;EnumDisplayModes (0L, NULL, &amp;cbInfo,  <br>                                           ModeEnumCallback); <br>if (FAILED(hResult)) <br>{ <br>// Error <br>REPORTERR (hResult); <br>return hResult; <br>} <br> <br>// Double check count <br>if ((! cbInfo.fResult) || (cbInfo.cCount == 0) || (cModes != cbInfo.cCount)) <br>{ <br>hResult = APPERR_GENERIC; <br>REPORTERR (hResult); <br>return hResult; <br>} <br> <br>// Mark Modes as loaded <br>turnModesLoadedOn (); <br>} <br> <br>// Success <br>return DD_OK; <br>} // D3DDevInfo::LoadModes <br> <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DDDrvInfo::DestroyModes <br>**  Purpose:    Destroys all Modes in Mode List <br>**----------------------------------------------------------------------------- <br>*/ <br>   <br>HRESULT DDDrvInfo::DestroyModes (void) <br>{ <br>LPDDModeInfo lpCurr, lpNext, lpPrev; <br> <br>lpCurr = lpModeRoot; <br> <br>// Walk linked list and destroy all Mode nodes <br>while (lpCurr) <br>{ <br>lpNext = lpCurr-&gt;lpNext; <br>lpPrev = lpCurr-&gt;lpPrev; <br> <br>// Remove node from List <br>if (lpPrev) <br>lpPrev-&gt;lpNext = lpNext; <br>else <br>lpModeRoot = lpNext; <br> <br>if (lpNext) <br>lpNext-&gt;lpPrev = lpPrev; <br>else <br>lpModeTail = lpPrev; <br> <br>// Destroy this node <br>lpCurr-&gt;lpNext = NULL; <br>lpCurr-&gt;lpPrev = NULL; <br>delete lpCurr; <br> <br>// Move to next node in list <br>lpCurr = lpNext; <br>} <br> <br>cModes   = 0L; <br>lpModeRoot = NULL; <br>lpModeTail = NULL; <br> <br>turnModesLoadedOff (); <br> <br>// Success <br>return DD_OK; <br>} // End DDDrvInfo::DestroyModes <br>   <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DDDrvInfo::AddMode <br>**  Purpose:    add new mode to mode list <br>**  Notes:1 <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT DDDrvInfo::AddMode (LPDDModeInfo lpModeNew) <br>{ <br>// Check Parameters <br>if (! lpModeNew) <br>{ <br>// Error, Invalid parameters <br>return DDERR_INVALIDPARAMS; <br>} <br> <br>// Add to tail of Mode List <br>lpModeNew-&gt;lpPrev = lpModeTail; <br>lpModeNew-&gt;lpNext = NULL; <br> <br>// Update tail <br>if (lpModeTail) <br>lpModeTail-&gt;lpNext = lpModeNew; <br>lpModeTail = lpModeNew; <br> <br>// Update Root <br>if (! lpModeRoot) <br>lpModeRoot = lpModeNew; <br> <br>// Update count <br>cModes++; <br> <br>// Success <br>return DD_OK; <br>} // End DDDrvInfo::AddMode <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DDDrvInfo::DelMode <br>**  Purpose:    removes mode from mode list <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT DDDrvInfo::DelMode (LPDDModeInfo lpModeDel) <br>{ <br>// Check parameters <br>if (lpModeDel) <br>{ <br>// Error <br>return DDERR_INVALIDPARAMS; <br>} <br> <br>// Remove this Mode From mode list <br>    LPDDModeInfo lpPrevMode = lpModeDel-&gt;lpPrev; <br>    LPDDModeInfo lpNextMode = lpModeDel-&gt;lpNext; <br> <br>    if (lpPrevMode) <br>        lpPrevMode-&gt;lpNext = lpNextMode; <br>    else <br>        lpModeRoot = lpNextMode; <br> <br>    if (lpNextMode) <br>lpNextMode-&gt;lpPrev = lpPrevMode; <br>else <br>lpModeTail = lpPrevMode; <br> <br>lpModeDel-&gt;lpPrev = NULL; <br>    lpModeDel-&gt;lpNext = NULL; <br> <br>    // Destroy mode node <br>    delete lpModeDel; <br> <br>// Update count <br>cModes--; <br> <br>// Success <br>return DD_OK; <br>} // End DDDrvInfo::DelMode <br>   <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DDDrvInfo::FindMode <br>**  Purpose:    finds specified mode <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LPDDModeInfo DDDrvInfo::FindMode ( <br>DWORDdwW,/* In:  Match this width */ <br>DWORDdwH,/* In:  Match this Height */ <br>DWORDdwBPP,/* In:  Match this Bits Per Pixel */ <br>DWORD           dwRefresh,/* In:  Not supported yet... */ <br>LPDDModeInfo *lpNextBest,/* Out: Return next best match */ <br>LPDDModeInfo    lpStart) /* In:  Start search from this mode */ <br>{ <br>LPDDModeInfolpCurrMode, lpNextMode; <br> <br>// Get Starting node <br>if (! lpStart) <br>lpCurrMode = lpModeRoot; <br>else <br>lpCurrMode = lpStart; <br> <br>if (lpNextBest) <br>*lpNextBest = lpCurrMode; <br> <br>// Search mode list for best match <br>    while (lpCurrMode) <br>{ <br>lpNextMode = lpCurrMode-&gt;lpNext; <br>        if (lpCurrMode-&gt;Match (dwW, dwH, dwBPP)) <br>        { <br>return lpCurrMode; <br>        } <br>        else if (lpCurrMode-&gt;Match (640, 480, 8)) <br>        { <br>if (lpNextBest) <br>*lpNextBest = lpCurrMode; <br>        } <br>lpCurrMode = lpNextMode; <br>    } <br> <br>    // Failure, user may use lpNextBest instead <br>    return NULL; <br>} // End DDDrvInfo::FindMode  <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DDDrvInfo::FindMode <br>**  Purpose:    finds specified mode <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LPDDModeInfo DDDrvInfo::FindMode ( <br>LPDDSURFACEDESC lpddsd,/* In:Mode Desc */ <br>LPDDModeInfo *  lpNextBest,/* Out:Second best match */ <br>LPDDModeInfo    lpStart)/* In:start from this node */ <br>{ <br>LPDDModeInfolpCurrMode, lpNextMode; <br> <br>// Get Starting node <br>if (! lpStart) <br>lpCurrMode = lpModeRoot; <br>else <br>lpCurrMode = lpStart; <br> <br>if (lpNextBest) <br>*lpNextBest = lpCurrMode; <br> <br>// Search mode list for best match <br>    while (lpCurrMode) <br>{ <br>lpNextMode = lpCurrMode-&gt;lpNext; <br>        if (lpCurrMode-&gt;Match (*lpddsd)) <br>        { <br>            return lpCurrMode; <br>        } <br>        else if (lpCurrMode-&gt;Match (640, 480, 8)) <br>        { <br>if (lpNextBest) <br>*lpNextBest = lpCurrMode; <br>        } <br>    } <br> <br>    // Failure, user may use lpNextBest instead <br>    return NULL; <br>} // End DDDrvInfo::FindMode  <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DDDrvInfo::EnumModes <br>**  Purpose:    Enumerate modes in this Driver <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>DWORD DDDrvInfo::EnumModes (const DDDRV_ENUMINFO &amp; eiInfo) <br>{ <br>    DWORD           dwResult = ENUM_FAILURE; <br>LPDDModeInfolpCurrMode, lpNextMode; <br> <br>    // Check Match Callback function <br>    if (! eiInfo.fpcbEnum) <br>    { <br>        // Error, invalid callback <br>        return ENUM_ERROR; <br>    } <br> <br>// Get Starting node <br>if (eiInfo.lpStart) <br>lpCurrMode = (LPDDModeInfo)(eiInfo.lpStart); <br>else <br>lpCurrMode = lpModeRoot; <br> <br>// Do callback on each node in list <br>while (lpCurrMode) <br>{ <br>lpNextMode = lpCurrMode-&gt;lpNext; <br> <br>        // Call Enum Mode Callback <br>        dwResult = (*eiInfo.fpcbEnum)((LPVOID)this, lpCurrMode, eiInfo.dwExtra); <br> <br>        // Check for early exit <br>        if (dwResult &amp; ENUM_STOP) <br>        { <br>            // Return result code <br>            return (dwResult &amp; ~ENUM_STOP); <br>        } <br>   } <br> <br>    // Failure <br>    return (dwResult &amp; ~ENUM_STOP); <br>} // End DDDrvInfo::EnumModes <br> <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DDDrvInfo::LoadDevices <br>**  Purpose:    Load all Devices associated with this DD Driver <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT DDDrvInfo::LoadDevices (LPDIRECT3D2 lpD3D2) <br>{ <br>// Have we already loaded the D3D Devices for this driver <br>if (! devicesLoaded ()) <br>{ <br>HRESULT hResult; <br>    DD_CB_INFOcbInfo; <br> <br>// Check Parameters <br>if (! lpD3D2) <br>{ <br>hResult = APPERR_INVALIDPARAMS; <br>REPORTERR (hResult); <br>return hResult; <br>} <br> <br>    cbInfo.fResult  = TRUE; <br>    cbInfo.lpExtra  = (void *)this; <br>cbInfo.cCount   = 0L; <br> <br>hResult = lpD3D2-&gt;EnumDevices (DeviceEnumCallback, &amp;cbInfo); <br>if (FAILED(hResult)) <br>{ <br>REPORTERR (hResult); <br>return hResult; <br>} <br> <br>// Double check count <br>if ((! cbInfo.fResult) || (cbInfo.cCount == 0) || (cDevices != cbInfo.cCount)) <br>{ <br>hResult = APPERR_GENERIC; <br>REPORTERR (hResult); <br>return hResult; <br>} <br> <br>// Mark Devices as loaded <br>turnDevicesLoadedOn (); <br>} <br> <br>// Success <br>return DD_OK; <br>} // DDDrvInfo::LoadDevices <br>   <br> <br>   <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DDDrvInfo::DestroyDevices <br>**  Purpose:    Destroys all Devices in Device List <br>**----------------------------------------------------------------------------- <br>*/ <br>   <br>HRESULT DDDrvInfo::DestroyDevices (void) <br>{ <br>LPD3DDevInfo lpCurr, lpNext, lpPrev; <br> <br>lpCurr = lpDeviceRoot; <br> <br>// Walk linked list and destroy all D3D Device nodes <br>while (lpCurr) <br>{ <br>lpNext = lpCurr-&gt;lpNext; <br>lpPrev = lpCurr-&gt;lpPrev; <br> <br>// Remove node from List <br>if (lpPrev) <br>lpPrev-&gt;lpNext = lpNext; <br>else <br>lpDeviceRoot = lpNext; <br> <br>if (lpNext) <br>lpNext-&gt;lpPrev = lpPrev; <br>else <br>lpDeviceTail = lpPrev; <br> <br>// Destroy this node <br>lpCurr-&gt;lpNext = NULL; <br>lpCurr-&gt;lpPrev = NULL; <br>delete lpCurr; <br> <br>// Move to next node in list <br>lpCurr = lpNext; <br>} <br> <br>cDevices   = 0L; <br>lpDeviceRoot = NULL; <br>lpDeviceTail = NULL; <br> <br>turnDevicesLoadedOff (); <br> <br>// Success <br>return DD_OK; <br>} // End DDDrvInfo::DestroyDevices <br>   <br> <br>   <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DDDrvInfo::AddDevice <br>**  Purpose:    add new D3D device to device list <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT DDDrvInfo::AddDevice (LPD3DDevInfo lpDevNew) <br>{ <br>// Check Parameters <br>if (! lpDevNew) <br>{ <br>// Error, Invalid parameters <br>return DDERR_INVALIDPARAMS; <br>} <br> <br>// Add to tail of Mode List <br>lpDevNew-&gt;lpPrev = lpDeviceTail; <br>lpDevNew-&gt;lpNext = NULL; <br> <br>// Update tail <br>if (lpDeviceTail) <br>lpDeviceTail-&gt;lpNext = lpDevNew; <br>lpDeviceTail = lpDevNew; <br> <br>// Update Root <br>if (! lpDeviceRoot) <br>lpDeviceRoot = lpDevNew; <br> <br>// Update count <br>cDevices++; <br> <br>// Success <br>return DD_OK; <br>} // End DDDrvInfo::AddDevice <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DDDrvInfo::DelDevice <br>**  Purpose:    removes D3D device from Device list <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT DDDrvInfo::DelDevice (LPD3DDevInfo lpDevDel) <br>{ <br>// Check parameters <br>if (lpDevDel) <br>{ <br>// Error <br>return DDERR_INVALIDPARAMS; <br>} <br> <br>// Remove this Mode From mode list <br>    LPD3DDevInfo lpPrevDev = lpDevDel-&gt;lpPrev; <br>    LPD3DDevInfo lpNextDev = lpDevDel-&gt;lpNext; <br> <br>    if (lpPrevDev) <br>        lpPrevDev-&gt;lpNext = lpNextDev; <br>    else <br>        lpDeviceRoot = lpNextDev; <br> <br>    if (lpNextDev) <br>lpNextDev-&gt;lpPrev = lpPrevDev; <br>else <br>lpDeviceTail = lpPrevDev; <br> <br>lpDevDel-&gt;lpPrev = NULL; <br>    lpDevDel-&gt;lpNext = NULL; <br> <br>    // Destroy mode node <br>    delete lpDevDel; <br> <br>// Update count <br>cDevices--; <br> <br>// Success <br>return DD_OK; <br>} // End DDDrvInfo::DelDevice <br>   <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DDDrvInfo::FindDevice <br>**  Purpose:    finds specified D3D Device <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LPD3DDevInfo DDDrvInfo::FindDevice ( <br>LPGUIDlpGuid,  <br>LPD3DDevInfo *  lpNextBest, <br>LPD3DDevInfolpStart) <br>{ <br>LPD3DDevInfolpCurrDev, lpNextDev; <br>LPD3DDevInfo    lpHardware = NULL; <br>LPD3DDevInfolpMMX = NULL; <br>LPD3DDevInfo    lpRGB = NULL; <br>LPD3DDevInfo    lpFirst = NULL; <br> <br>if (lpNextBest) <br>*lpNextBest = NULL; <br> <br>// Get Root <br>if (! lpStart) <br>lpCurrDev = lpDeviceRoot; <br>else <br>lpCurrDev = lpStart; <br> <br>lpFirst = lpCurrDev; <br> <br>// Search mode list for best match <br>    while (lpCurrDev) <br>{ <br>lpNextDev = lpCurrDev-&gt;lpNext; <br>        if (lpCurrDev-&gt;Match (lpGuid)) <br>        { <br>return lpCurrDev; <br>        } <br>         <br>if (lpCurrDev-&gt;isHardware ()) <br>        { <br>if (! lpHardware) <br>lpHardware = lpCurrDev; <br>        } <br> <br>if (lpCurrDev-&gt;guid == IID_IDirect3DRGBDevice) <br>{ <br>if (! lpRGB) <br>lpRGB = lpCurrDev; <br>} <br> <br>if (lpCurrDev-&gt;guid == IID_IDirect3DMMXDevice) <br>{ <br>if (! lpMMX) <br>lpMMX = lpCurrDev; <br>} <br> <br>lpCurrDev = lpNextDev; <br>    } <br> <br>if (lpNextBest) <br>{ <br>if (lpHardware) <br>*lpNextBest = lpHardware; <br>else if (lpRGB) <br>*lpNextBest = lpRGB; <br>else if (lpMMX) <br>*lpNextBest = lpMMX; <br>else if (lpFirst) <br>*lpNextBest = lpFirst; <br>} <br> <br>    // Failure, user may use lpNextBest instead <br>    return NULL; <br>} // End DDDrvInfo::FindDevice <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DDDrvInfo::FindDevice <br>**  Purpose:    finds specified D3D Device <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LPD3DDevInfo DDDrvInfo::FindDevice ( <br>    LPD3DDEVICEDESC lpHal,  <br>    LPD3DDEVICEDESC lpHel, <br>    LPD3DDevInfo *lpNextBest, <br>LPD3DDevInfolpStart) <br>{ <br>LPD3DDevInfolpCurrDev, lpNextDev; <br>LPD3DDevInfo    lpHardware = NULL; <br>LPD3DDevInfolpMMX = NULL; <br>LPD3DDevInfo    lpRGB = NULL; <br>LPD3DDevInfo    lpFirst = NULL; <br> <br>if (lpNextBest) <br>*lpNextBest = NULL; <br> <br>// Get Root <br>if (! lpStart) <br>lpCurrDev = lpDeviceRoot; <br>else <br>lpCurrDev = lpStart; <br> <br>lpFirst = lpCurrDev; <br> <br>// Search mode list for best match <br>    while (lpCurrDev) <br>{ <br>lpNextDev = lpCurrDev-&gt;lpNext; <br>        if (lpCurrDev-&gt;Match (lpHal, lpHel)) <br>        { <br>return lpCurrDev; <br>        } <br>         <br>if (lpCurrDev-&gt;isHardware ()) <br>        { <br>if (! lpHardware) <br>lpHardware = lpCurrDev; <br>        } <br> <br>if (lpCurrDev-&gt;guid == IID_IDirect3DRGBDevice) <br>{ <br>if (! lpRGB) <br>lpRGB = lpCurrDev; <br>} <br> <br>if (lpCurrDev-&gt;guid == IID_IDirect3DMMXDevice) <br>{ <br>if (! lpMMX) <br>lpMMX = lpCurrDev; <br>} <br> <br>lpCurrDev = lpNextDev; <br>    } <br> <br>if (lpNextBest) <br>{ <br>if (lpHardware) <br>*lpNextBest = lpHardware; <br>else if (lpRGB) <br>*lpNextBest = lpRGB; <br>else if (lpMMX) <br>*lpNextBest = lpMMX; <br>else if (lpFirst) <br>*lpNextBest = lpFirst; <br>} <br> <br>    // Failure <br>    return NULL; <br>} // End DDDrvInfo::FindDevice <br> <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DDDrvInfo::FindDeviceSupportsMode <br>**  Purpose:    finds specified D3D Device that is compatible <br>**with specified mode <br>**  Notes; <br>** <br>**1.  First looks for an exact match that is compatible <br>**  2.  Looks for a hardware device that is compatible <br>**3.  Looks for any device that is compatible <br>** <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LPD3DDevInfo DDDrvInfo::FindDeviceSupportsMode ( <br>LPGUIDlpGuid,  <br>    LPDDModeInfolpMode, <br>LPD3DDevInfo *  lpNextBest, <br>LPD3DDevInfolpStart) <br>{ <br>LPD3DDevInfolpCurrDev, lpNextDev; <br> <br> <br>// Check parameters <br>if (! lpMode) <br>{ <br>// Error, Invalid parameters <br>if (lpNextBest) <br>*lpNextBest = NULL; <br>return NULL; <br>} <br> <br>// Get Root <br>if (! lpStart) <br>lpCurrDev = lpDeviceRoot; <br>else <br>lpCurrDev = lpStart; <br> <br>if (lpNextBest) <br>{ <br>if (lpMode-&gt;ModeSupported (lpCurrDev)) <br>*lpNextBest = lpCurrDev; <br>} <br> <br>// Search mode list for best match <br>    while (lpCurrDev) <br>{ <br>lpNextDev = lpCurrDev-&gt;lpNext; <br>        if (lpCurrDev-&gt;Match (lpGuid)) <br>        { <br>if (lpMode-&gt;ModeSupported (lpCurrDev)) <br>return lpCurrDev; <br>        } <br>        else if (lpCurrDev-&gt;isHardware ()) <br>        { <br>if (lpNextBest) <br>{ <br>if (lpMode-&gt;ModeSupported (lpCurrDev)) <br>*lpNextBest = lpCurrDev; <br>} <br>        } <br>else if (lpMode-&gt;ModeSupported (lpCurrDev)) <br>{ <br>if (lpNextBest) <br>*lpNextBest = lpCurrDev; <br>} <br>lpCurrDev = lpNextDev; <br>    } <br> <br>    // Failure, user may use lpNextBest instead <br>    return NULL; <br>} // End DDDrvInfo::FindDeviceSupportsMode <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DDDrvInfo::FindModeSupportsDevice <br>**  Purpose:    finds specified mode that is compatible <br>**with specified D3D device <br>** <br>**1.  First trys for an exact mode, if it is compatible <br>**2.  Then looks for 640, 480, 16, if it is compatible <br>**  3.  Then looks for any mode that is compatible <br>** <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LPDDModeInfo DDDrvInfo::FindModeSupportsDevice ( <br>DWORDdwW,  <br>DWORDdwH,  <br>DWORDdwBPP, <br>DWORDdwRefresh,/* In: Not supported yet ... */ <br>LPD3DDevInfolpDevice, <br>LPDDModeInfo *lpNextBest, <br>LPDDModeInfolpStart) <br>{ <br>LPDDModeInfolpCurrMode, lpNextMode; <br> <br>// Check parameters <br>if (! lpDevice) <br>{ <br>// Error, Invalid parameters <br>if (lpNextBest) <br>*lpNextBest = NULL; <br>return NULL; <br>} <br> <br>// Get Root <br>if (! lpStart) <br>lpCurrMode = lpModeRoot; <br>else <br>lpCurrMode = lpStart; <br> <br>if (lpNextBest) <br>{ <br>if (lpCurrMode-&gt;ModeSupported (lpDevice)) <br>*lpNextBest = lpCurrMode; <br>} <br> <br>// Search mode list for best match <br>    while (lpCurrMode) <br>{ <br>lpNextMode = lpCurrMode-&gt;lpNext; <br>        if (lpCurrMode-&gt;Match (dwW, dwH, dwBPP)) <br>        { <br>if (lpCurrMode-&gt;ModeSupported (lpDevice)) <br>return lpCurrMode; <br>        } <br>        else if (lpCurrMode-&gt;Match (640, 480, 16)) <br>        { <br>if (lpNextBest) <br>{ <br>if (lpCurrMode-&gt;ModeSupported (lpDevice)) <br>*lpNextBest = lpCurrMode; <br>} <br>        } <br>else if (lpCurrMode-&gt;ModeSupported (lpDevice)) <br>{ <br>if (lpNextBest) <br>*lpNextBest = lpCurrMode; <br>} <br>lpCurrMode = lpNextMode; <br>    } <br> <br>    // Failure, user may use lpNextBest instead <br>    return NULL; <br>} // End DDDrvInfo::FindModeSupportsDevice <br> <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DDDrvInfo::EnumDevices <br>**  Purpose:    Enumerate D3D devices in driver <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>DWORD DDDrvInfo::EnumDevices (const DDDRV_ENUMINFO &amp; eiInfo) <br>{ <br>    DWORD           dwResult = ENUM_FAILURE; <br>LPD3DDevInfolpCurrDev, lpNextDev; <br> <br>    // Check Match Callback function <br>    if (! eiInfo.fpcbEnum) <br>    { <br>        // Error, invalid callback <br>        return ENUM_ERROR; <br>    } <br> <br>// Get Starting node <br>if (eiInfo.lpStart) <br>lpCurrDev = (LPD3DDevInfo)(eiInfo.lpStart); <br>else <br>lpCurrDev = lpDeviceRoot; <br> <br>// Do callback on each node in list <br>while (lpCurrDev) <br>{ <br>lpNextDev = lpCurrDev-&gt;lpNext; <br> <br>dwResult = (*eiInfo.fpcbEnum)((LPVOID)this, lpCurrDev, eiInfo.dwExtra); <br> <br>        // Check for early exit <br>        if (dwResult &amp; ENUM_STOP) <br>{ <br>            // Return result code <br>            return (dwResult &amp; ~ENUM_STOP); <br>} <br> <br>lpCurrDev = lpNextDev; <br>} <br> <br>    // Failure <br>    return (dwResult &amp; ~ENUM_STOP); <br>} // End DDDrvInfo::EnumDevices <br> <br>   <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DDDrvInfo::GetGuid <br>**Purpose: <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LPGUID DDDrvInfo::GetGuid (void) <br>{ <br>if (isPrimary ()) <br>return NULL; <br>else <br>return &amp;guid; <br>} // End DDDrvInfo::GetGuid <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  DDDrvMgr Methods <br>**----------------------------------------------------------------------------- <br>*/ <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DDDrvMgr::Init <br>**  Purpose:    Grovel all DD driver info in system  <br>**              and store in global DDInfo structures <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT DDDrvMgr::Init (void) <br>{ <br>    if (! isInitialized ()) <br>    {         <br>        HRESULT         hResult; <br> <br>g_cDrivers = 0L; <br> <br>// Load all drivers in system <br>hResult = LoadDrivers (); <br>if (FAILED (hResult)) <br>return hResult; <br> <br>        // Mark as initialized <br>        initOn (); <br>    } <br> <br>// Success <br>    return DD_OK; <br>} // End DDDrvMgr::Init <br> <br> <br>   <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DDDrvMgr::Fini <br>**  Purpose:    Cleanup all global DDInfo structures <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT DDDrvMgr::Fini (void) <br>{ <br>    if (isInitialized ()) <br>    { <br>DestroyDrivers (); <br> <br>        // Mark as not initialized <br>        initOff (); <br>    } <br> <br>// Success <br>    return DD_OK; <br>} // End DDDrvMgr::Fini <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DDDrvMgr::LoadDrivers <br>**  Purpose:    Load all DD Drivers in system <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT DDDrvMgr::LoadDrivers (void) <br>{ <br>HRESULT hResult; <br>    DD_CB_INFOcbInfo; <br> <br>    // Initialize all valid drivers in system <br>    cbInfo.fResult  = TRUE; <br>    cbInfo.cCount   = 0L; <br>    cbInfo.lpExtra  = (void *)NULL; <br> <br>    hResult = DirectDrawEnumerate (DriverEnumCallback, &amp;cbInfo); <br>if (FAILED(hResult)) <br>{ <br>REPORTERR (hResult); <br>return hResult; <br>} <br> <br>// Double check count <br>if ((! cbInfo.fResult) || (cbInfo.cCount == 0) || (g_cDrivers != cbInfo.cCount)) <br>{ <br>hResult = APPERR_GENERIC; <br>REPORTERR (hResult); <br>return hResult; <br>} <br> <br>// Success <br>return DD_OK; <br>} // DDDrvMgr::LoadDrivers <br>   <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DDDrvMgr::DestroyDrivers <br>**  Purpose:    Destroys all Drivers in Driver List <br>**----------------------------------------------------------------------------- <br>*/ <br>   <br>HRESULT DDDrvMgr::DestroyDrivers (void) <br>{ <br>LPDDDrvInfo lpCurr, lpNext, lpPrev; <br> <br>lpCurr = g_lpDriverRoot; <br> <br>// Walk linked list and destroy all D3D Device nodes <br>while (lpCurr) <br>{ <br>lpNext = lpCurr-&gt;lpNext; <br>lpPrev = lpCurr-&gt;lpPrev; <br> <br>// Remove node from List <br>if (lpPrev) <br>lpPrev-&gt;lpNext = lpNext; <br>else <br>g_lpDriverRoot = lpNext; <br> <br>if (lpNext) <br>lpNext-&gt;lpPrev = lpPrev; <br>else <br>g_lpDriverTail = lpPrev; <br> <br>// Destroy this node <br>lpCurr-&gt;lpNext = NULL; <br>lpCurr-&gt;lpPrev = NULL; <br>delete lpCurr; <br> <br>// Move to next node in list <br>lpCurr = lpNext; <br>} <br> <br>g_cDrivers = 0L; <br>g_lpDriverRoot = NULL; <br>g_lpDriverTail = NULL; <br> <br>// Success <br>return DD_OK; <br>} // End DDDrvMgr::DestroyDrivers <br> <br>   <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DDDrvMgr::DDDrvMgr <br>**  Purpose:    Default constructor <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>DDDrvMgr::DDDrvMgr (void) <br>{ <br>    lpCurrDriver    = NULL; <br>    lpCurrMode= NULL; <br>    lpCurrDevice= NULL; <br>} // End DDDrvMgr::DDDrvMgr <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DDDrvMgr::~DDDrvMgr <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>DDDrvMgr::~DDDrvMgr (void) <br>{ <br>} // End DDDrvMgr::~DDDrvMgr <br> <br> <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DDDrvMgr::AddDriver <br>**  Purpose:    add new driver to driver list <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT DDDrvMgr::AddDriver (LPDDDrvInfo lpDrvNew) <br>{ <br>// Check Parameters <br>if (! lpDrvNew) <br>{ <br>// Error, Invalid parameters <br>return DDERR_INVALIDPARAMS; <br>} <br> <br>// Add to tail of Mode List <br>lpDrvNew-&gt;lpPrev = DDDrvMgr::g_lpDriverTail; <br>lpDrvNew-&gt;lpNext = NULL; <br> <br>// Update tail <br>if (DDDrvMgr::g_lpDriverTail) <br>DDDrvMgr::g_lpDriverTail-&gt;lpNext = lpDrvNew; <br>DDDrvMgr::g_lpDriverTail = lpDrvNew; <br> <br>// Update Root <br>if (! DDDrvMgr::g_lpDriverRoot) <br>DDDrvMgr::g_lpDriverRoot = lpDrvNew; <br> <br>// Update count <br>g_cDrivers++; <br> <br>// Success <br>return DD_OK; <br>} // End DDDrvMgr::AddDriver <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DDDrvMgr::DelDriver <br>**  Purpose:    removes driver from driver list <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT DDDrvMgr::DelDriver (LPDDDrvInfo lpDrvDel) <br>{ <br>// Check parameters <br>if (lpDrvDel) <br>{ <br>// Error <br>return DDERR_INVALIDPARAMS; <br>} <br> <br>// Remove this Mode From mode list <br>    LPDDDrvInfo lpPrevDrv = lpDrvDel-&gt;lpPrev; <br>    LPDDDrvInfo lpNextDrv = lpDrvDel-&gt;lpNext; <br> <br>    if (lpPrevDrv) <br>        lpPrevDrv-&gt;lpNext = lpNextDrv; <br>    else <br>DDDrvMgr::g_lpDriverRoot = lpNextDrv; <br> <br>    if (lpNextDrv) <br>lpNextDrv-&gt;lpPrev = lpPrevDrv; <br>else <br>DDDrvMgr::g_lpDriverTail = lpPrevDrv; <br> <br>lpDrvDel-&gt;lpPrev = NULL; <br>    lpDrvDel-&gt;lpNext = NULL; <br> <br>    // Destroy mode node <br>    delete lpDrvDel; <br> <br>// Update count <br>g_cDrivers--; <br> <br>// Success <br>return DD_OK; <br>} // End DDDrvMgr::DelDriver <br>   <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DDDrvMgr::FindDriver <br>**  Purpose:    Finds driver corresponding to guid <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LPDDDrvInfo DDDrvMgr::FindDriver ( <br>LPGUIDlpGuid,  <br>LPDDDrvInfo *lpNextBest, <br>LPDDDrvInfolpStart) <br>{ <br>    LPDDDrvInfo lpCurrDrv, lpNextDrv; <br>     <br>#ifdef DEBUG <br>    if (! isInitialized ()) <br>    { <br>        // Error, not initialized <br>        return NULL; <br>    } <br>#endif <br> <br>    // Get Start node <br>if (! lpStart) <br>lpCurrDrv = DDDrvMgr::g_lpDriverRoot; <br>else <br>lpCurrDrv = lpStart; <br> <br>if (lpNextBest) <br>*lpNextBest = lpCurrDrv; <br> <br>while (lpCurrDrv) <br>{ <br>lpNextDrv = lpCurrDrv-&gt;lpNext; <br>if (lpCurrDrv-&gt;Match (lpGuid)) <br>{ <br>// Success <br>return lpCurrDrv; <br>} <br>else if (lpCurrDrv-&gt;isPrimary ()) <br>{ <br>if (lpNextBest) <br>*lpNextBest = lpCurrDrv; <br>} <br> <br>lpCurrDrv = lpNextDrv; <br>} <br>     <br>    // Failure, user could use next best instead <br>    return NULL; <br>} // End DDDrvMgr::FindDriver <br>         <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DDDrvMgr::FindDriver <br>**  Purpose:    Finds driver corresponding to specified device caps <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LPDDDrvInfo DDDrvMgr::FindDriver ( <br>    LPDDCAPS  lpHal,  <br>    LPDDCAPS  lpHel,  <br>    LPDDDrvInfo * lpNextBest, <br>LPDDDrvInfo   lpStart) <br>{ <br>    LPDDDrvInfo lpCurrDrv, lpNextDrv; <br>     <br>    // Get Start node <br>if (! lpStart) <br>lpCurrDrv = DDDrvMgr::g_lpDriverRoot; <br>else <br>lpCurrDrv = lpStart; <br> <br>if (lpNextBest) <br>*lpNextBest = lpCurrDrv; <br> <br>while (lpCurrDrv) <br>{ <br>lpNextDrv = lpCurrDrv-&gt;lpNext; <br> <br>if (lpCurrDrv-&gt;Match (lpHal, lpHel)) <br>{ <br>// Success <br>return lpCurrDrv; <br>} </code></pre>
<p>
</p>
<pre><code>else if (lpCurrDrv-&gt;isPrimary ()) <br>{ <br>if (lpNextBest) <br>*lpNextBest = lpCurrDrv; <br>} <br> <br>lpCurrDrv = lpNextDrv; <br>} <br>     <br>    // Failure, user could use next best instead <br>    return NULL; <br>} // End DDDrvMgr::FindDriver <br> <br>   <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DDDrvMgr::EnumDrivers <br>**  Purpose:    Enumerate drivers <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>DWORD DDDrvMgr::EnumDrivers (const DDDRV_ENUMINFO &amp; eiInfo) <br>{ <br>    DWORDdwResult = ENUM_FAILURE; <br>LPDDDrvInfo lpCurrDrv, lpNextDrv; <br> <br>    // Check Match Callback function <br>    if (! eiInfo.fpcbEnum) <br>    { <br>        // Error, invalid callback <br>        return ENUM_ERROR; <br>    } <br> <br>// Get starting node <br>    if (eiInfo.lpStart) <br>lpCurrDrv = (LPDDDrvInfo)(eiInfo.lpStart); <br>else <br>lpCurrDrv = DDDrvMgr::g_lpDriverRoot; <br> <br>    // for each driver, call user defined match callback function <br>while (lpCurrDrv) <br>{ <br>        lpNextDrv = lpCurrDrv-&gt;lpNext; <br> <br>        // Call Enum Drivers Callback <br>        dwResult = (*eiInfo.fpcbEnum)((LPVOID)lpCurrDrv, NULL, eiInfo.dwExtra); <br> <br>        // Check for early exit <br>        if (dwResult &amp; ENUM_STOP) <br>        { <br>            // Return result code <br>            return (dwResult &amp; ~ENUM_STOP); <br>        } <br>   } <br> <br>    // Failure <br>    return (dwResult &amp; ~ENUM_STOP); <br>} // End DDDrvMgr::EnumDrivers <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  End of File <br>**----------------------------------------------------------------------------- <br>*/ <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
