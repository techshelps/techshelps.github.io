<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DEBUG.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2989"></a>DEBUG.CPP</h2>
<pre><code>/* <br>**----------------------------------------------------------------------------- <br>** Name:    Debug.cpp <br>** Purpose: Example debug code for D3D sample <br>** Notes: <br>** <br>** Copyright (C) 199 - 1997 Microsoft Corporation. All Rights Reserved. <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Includes <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>#include "Debug.h" <br>#include "WinMain.h" <br>#include "WinProc.h" <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Global variables <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>#ifdef DEBUG <br>    DWORD   g_dwDebugLevel = DEBUG_ALWAYS; <br>    BOOL    g_fDebug = TRUE; <br>#else <br>    BOOL    g_fDebug = FALSE; <br>#endif <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Local prototypes <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>BOOL GetDDErrorString (HRESULT hResult, LPTSTR lpszError, DWORD cchError); <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Functions <br>**----------------------------------------------------------------------------- <br>*/ <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       dprintf <br>**  Purpose:Printf to debug output <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>#ifdef DEBUG <br>void __cdecl dprintf (DWORD dwDebugLevel, LPCTSTR szFormat, ...) <br>{ <br>    TCHAR   szBuffer[MAX_STRING]; <br>    va_list va; <br> <br>// Check if current debug level <br>    if (dwDebugLevel &lt;= g_dwDebugLevel) <br>    return; <br>     <br>    lstrcpy (szBuffer, START_STR); <br>    va_start(va, szFormat); <br>    wvsprintf (szBuffer+lstrlen (szBuffer), szFormat, va); <br>    va_end(va); <br>    lstrcat (szBuffer, END_STR); <br>    OutputDebugString (szBuffer); <br>} <br>#endif // DEBUG <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    ReportDDError <br>** Purpose:  <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>void _cdecl ReportDDError (HRESULT hResult, LPCTSTR szFormat, ...) <br>{ <br>    TCHAR   szMsg[MAX_STRING]; <br>    TCHAR   szErr[MAX_STRING]; <br>    TCHAR   szUnknown[] = TEXT("Unknown"); <br>    DWORD   cchErr = sizeof(szErr)/sizeof(TCHAR); <br>    va_list va; <br> <br>    // Check for Success Error code <br>    if (hResult == DD_OK) <br>        return; <br> <br>    // Get DD/D3D error string <br>    szErr[0] = 0; <br>    GetDDErrorString (hResult, szErr, cchErr);     <br>    wsprintf (szMsg, TEXT("DD/D3D Error = %s\r\n"), szErr); <br> <br>    // Append the rest of the error message <br>    va_start( va, szFormat ); <br>    wvsprintf (szMsg + lstrlen(szMsg), szFormat, va); <br>    va_end( va ); <br> <br>    // Dump to debugger <br>    DPF (DEBUG_ERROR, TEXT("%s"), szMsg); <br> <br>// <br>// Define the following if you want an in your face Messagebox on errors <br>// <br>#ifdef DEBUG_PROMPTME <br>    HWND    hWindow; <br> <br>    // Pause App <br>if (g_hMainWindow) <br>OnPause (g_hMainWindow, TRUE); <br> <br>    // Display Error Message to user <br>    if (g_hMainWindow) <br>        hWindow = g_hMainWindow; <br>    else <br>        hWindow = NULL; <br> <br>    MessageBox (hWindow, szMsg, g_szMainTitle, MB_OK | MB_APPLMODAL); <br> <br>    // Unpause app <br>if (g_hMainWindow) <br>OnPause (g_hMainWindow, FALSE); <br>#endif <br> <br>} // ReportDDError <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:    GetDDErrorString <br>** Purpose: outputs a debug string to debugger <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>BOOL GetDDErrorString (HRESULT hResult, LPTSTR lpszErrorBuff, DWORD cchError) <br>{ <br>    DWORD  cLen; <br>    LPTSTR lpszError; <br>    TCHAR  szMsg[MAX_STRING]; <br> <br>    // Check parameters <br>    if (!lpszErrorBuff || !cchError) <br>    { <br>        // Error, invalid parameters <br>        return FALSE; <br>    } <br> <br>    switch (hResult) <br>    { <br>    case DD_OK: <br>        // The request completed successfully. <br>        lpszError = TEXT("DD_OK"); <br>        break; <br> <br>    case DDERR_ALREADYINITIALIZED: <br>        // The object has already been initialized. <br>        lpszError = TEXT("DDERR_ALREADYINITIALIZED"); <br>        break; <br> <br>    case DDERR_BLTFASTCANTCLIP: <br>        // A DirectDrawClipper object is attached to a source surface  <br>        // that has passed into a call to the IDirectDrawSurface2::BltFast method.  <br>        lpszError = TEXT("DDERR_BLTFASTCANTCLIP"); <br>        break; <br> <br>    case DDERR_CANNOTATTACHSURFACE: <br>        // A surface cannot be attached to another requested surface.  <br>        lpszError = TEXT("DDERR_CANNOTATTACHSURFACE"); <br>        break; <br> <br>    case DDERR_CANNOTDETACHSURFACE: <br>        // A surface cannot be detached from another requested surface.  <br>        lpszError = TEXT("DDERR_CANNOTDETACHSURFACE"); <br>        break; <br> <br>    case DDERR_CANTCREATEDC: <br>        // Windows cannot create any more device contexts (DCs).  <br>        lpszError = TEXT("DDERR_CANTCREATEDC"); <br>        break; <br> <br>    case DDERR_CANTDUPLICATE: <br>        // Primary and 3D surfaces, or surfaces that are  <br>        // implicitly created, cannot be duplicated.  <br>        lpszError = TEXT("DDERR_CANTDUPLICATE"); <br>        break; <br> <br>    case DDERR_CANTLOCKSURFACE: <br>        // Access to this surface is refused because an  <br>        // attempt was made to lock the primary surface without DCI support.  <br>        lpszError = TEXT("DDERR_CANTLOCKSURFACE");  <br>        break; <br> <br>    case DDERR_CANTPAGELOCK: <br>        // An attempt to page lock a surface failed.  <br>        // Page lock will not work on a display-memory  <br>        // surface or an emulated primary surface. <br>        lpszError = TEXT("DDERR_CANTPAGELOCK");  <br>        break; <br> <br>    case DDERR_CANTPAGEUNLOCK: <br>        // An attempt to page unlock a surface failed.  <br>        // Page unlock will not work on a display-memory  <br>        // surface or an emulated primary surface.  <br>        lpszError = TEXT("DDERR_CANTPAGEUNLOCK"); <br>        break; <br> <br>    case DDERR_CLIPPERISUSINGHWND: <br>        // An attempt was made to set a clip list for a DirectDrawClipper  <br>        // object that is already monitoring a window handle.  <br>        lpszError = TEXT("DDERR_CLIPPERISUSINGHWND"); <br>        break; <br> <br>    case DDERR_COLORKEYNOTSET: <br>        // No source color key is specified for this operation <br>        lpszError = TEXT("DDERR_COLORKEYNOTSET"); <br>        break; <br> <br>    case DDERR_CURRENTLYNOTAVAIL: <br>        // No support is currently available.  <br>        lpszError = TEXT("DDERR_CURRENTLYNOTAVAIL"); <br>        break; <br> <br>    case DDERR_DCALREADYCREATED: <br>        // A device context (DC) has already been returned for this surface.  <br>        // Only one DC can be retrieved for each surface.  <br>        lpszError = TEXT("DDERR_DCALREADYCREATED"); <br>        break; <br> <br>    case DDERR_DIRECTDRAWALREADYCREATED: <br>        // A DirectDraw object representing this driver  <br>        // has already been created for this process.  <br>        lpszError = TEXT("DDERR_DIRECTDRAWALREADYCREATED"); <br>        break; <br> <br>    case DDERR_EXCEPTION: <br>        // An exception was encountered while  <br>        // performing the requested operation.  <br>        lpszError = TEXT("DDERR_EXCEPTION"); <br>        break; <br> <br>    case DDERR_EXCLUSIVEMODEALREADYSET: <br>        // An attempt was made to set the cooperative  <br>        // level when it was already set to exclusive.  <br>        lpszError = TEXT("DDERR_EXCLUSIVEMODEALREADYSET"); <br>        break; <br> <br>    case DDERR_GENERIC: <br>        // There is an undefined error condition.  <br>        lpszError = TEXT("DDERR_GENERIC"); <br>        break; <br> <br>    case DDERR_HEIGHTALIGN: <br>        // The height of the provided rectangle  <br>        // is not a multiple of the required alignment.  <br>        lpszError = TEXT("DDERR_HEIGHTALIGN"); <br>        break; <br> <br>    case DDERR_HWNDALREADYSET: <br>        // The DirectDraw cooperative level window  <br>        // handle has already been set. It cannot  <br>        // be reset while the process has surfaces or palettes created.  <br>        lpszError = TEXT("DDERR_HWNDALREADYSET"); <br>        break; <br> <br>    case DDERR_HWNDSUBCLASSED: <br>        // DirectDraw is prevented from restoring state because the <br>        // DirectDraw cooperative level window handle has been subclassed.  <br>        lpszError = TEXT("DDERR_HWNDSUBCLASSED"); <br>        break; <br> <br>    case DDERR_IMPLICITLYCREATED: <br>        // The surface cannot be restored because  <br>        // it is an implicitly created surface.  <br>        lpszError = TEXT("DDERR_IMPLICITLYCREATED"); <br>        break; <br>  <br>    case DDERR_INCOMPATIBLEPRIMARY: <br>        // The primary surface creation request  <br>        // does not match with the existing primary surface.  <br>        lpszError = TEXT("DDERR_INCOMPATIBLEPRIMARY"); <br>        break; <br> <br>    case DDERR_INVALIDCAPS: <br>        // One or more of the capability bits  <br>        // passed to the callback function are incorrect.  <br>        lpszError = TEXT("DDERR_INVALIDCAPS"); <br>        break; <br> <br>    case DDERR_INVALIDCLIPLIST: <br>        // DirectDraw does not support the provided clip list.   <br>        lpszError = TEXT("DDERR_INVALIDCLIPLIST"); <br>        break; <br> <br>    case DDERR_INVALIDDIRECTDRAWGUID: <br>        // The globally unique identifier (GUID) passed to the <br>        // DirectDrawCreate function is not a valid DirectDraw driver identifier.  <br>        lpszError = TEXT("DDERR_INVALIDDIRECTDRAWGUID"); <br>        break; <br> <br>    case DDERR_INVALIDMODE: <br>        // DirectDraw does not support the requested mode.  <br>        lpszError = TEXT("DDERR_INVALIDMODE"); <br>        break; <br> <br>    case DDERR_INVALIDOBJECT: <br>        // DirectDraw received a pointer that was an invalid DirectDraw object.  <br>        lpszError = TEXT("DDERR_INVALIDOBJECT"); <br>        break; <br> <br>    case DDERR_INVALIDPARAMS: <br>        // One or more of the parameters passed to the method are incorrect.  <br>        lpszError = TEXT("DDERR_INVALIDPARAMS"); <br>        break; <br> <br>    case DDERR_INVALIDPIXELFORMAT: <br>        // The pixel format was invalid as specified.  <br>        lpszError = TEXT("DDERR_INVALIDPIXELFORMAT"); <br>        break; <br> <br>    case DDERR_INVALIDPOSITION: <br>        // The position of the overlay on the destination is no longer legal.  <br>        lpszError = TEXT("DDERR_INVALIDPOSITION"); <br>        break; <br> <br>    case DDERR_INVALIDRECT: <br>        // The provided rectangle was invalid.  <br>        lpszError = TEXT("DDERR_INVALIDRECT"); <br>        break; <br> <br>    case DDERR_INVALIDSURFACETYPE: <br>        // The requested operation could not be performed <br>        // because the surface was of the wrong type.  <br>        lpszError = TEXT("DDERR_INVALIDSURFACETYPE"); <br>        break; <br> <br>    case DDERR_LOCKEDSURFACES: <br>        // One or more surfaces are locked,  <br>        // causing the failure of the requested operation.  <br>        lpszError = TEXT("DDERR_LOCKEDSURFACES"); <br>        break; <br> <br>    case DDERR_MOREDATA: <br>        // There is more data available than the specified  <br>        // buffer size could hold. <br>        lpszError = TEXT("DDERR_MOREDATA"); <br>        break; <br> <br>    case DDERR_NO3D: <br>        // No 3D hardware or emulation is present.  <br>        lpszError = TEXT("DDERR_NO3D"); <br>        break; <br> <br>    case DDERR_NOALPHAHW: <br>        // No alpha acceleration hardware is present or available,  <br>        // causing the failure of the requested operation.  <br>        lpszError = TEXT("DDERR_NOALPHAHW"); <br>        break; <br> <br>    case DDERR_NOBLTHW: <br>        // No blitter hardware is present.  <br>        lpszError = TEXT("DDERR_NOBLTHW"); <br>        break; <br> <br>    case DDERR_NOCLIPLIST: <br>        // No clip list is available.  <br>        lpszError = TEXT("DDERR_NOCLIPLIST"); <br>        break; <br> <br>    case DDERR_NOCLIPPERATTACHED: <br>        // No DirectDrawClipper object is attached to the surface object.  <br>        lpszError = TEXT("DDERR_NOCLIPPERATTACHED"); <br>        break; <br> <br>    case DDERR_NOCOLORCONVHW: <br>        // The operation cannot be carried out because  <br>        // no color-conversion hardware is present or available.  <br>        lpszError = TEXT("DDERR_NOCOLORCONVHW"); <br>        break; <br> <br>    case DDERR_NOCOLORKEY: <br>        // The surface does not currently have a color key.  <br>        lpszError = TEXT("DDERR_NOCOLORKEY"); <br>        break; <br> <br>    case DDERR_NOCOLORKEYHW: <br>        // The operation cannot be carried out because there  <br>        // is no hardware support for the destination color key.  <br>        lpszError = TEXT("DDERR_NOCOLORKEYHW"); <br>        break; <br> <br>    case DDERR_NOCOOPERATIVELEVELSET: <br>        // A create function is called without the  <br>        // IDirectDraw2::SetCooperativeLevel method being called.  <br>        lpszError = TEXT("DDERR_NOCOOPERATIVELEVELSET"); <br>        break; <br> <br>    case DDERR_NODC: <br>        // No DC has ever been created for this surface.  <br>        lpszError = TEXT("DDERR_NODC"); <br>        break; <br> <br>    case DDERR_NODDROPSHW: <br>        // No DirectDraw raster operation (ROP) hardware is available.  <br>        lpszError = TEXT("DDERR_NODDROPSHW"); <br>        break; <br> <br>    case DDERR_NODIRECTDRAWHW: <br>        // Hardware-only DirectDraw object creation is not possible;  <br>        // the driver does not support any hardware.  <br>        lpszError = TEXT("DDERR_NODIRECTDRAWHW"); <br>        break; <br> <br>    case DDERR_NODIRECTDRAWSUPPORT: <br>        // DirectDraw support is not possible with the current display driver.  <br>        lpszError = TEXT("DDERR_NODIRECTDRAWSUPPORT"); <br>        break; <br> <br>    case DDERR_NOEMULATION:  <br>        // Software emulation is not available.  <br>        lpszError = TEXT("DDERR_NOEMULATION"); <br>        break; <br> <br>    case DDERR_NOEXCLUSIVEMODE: <br>        // The operation requires the application to have  <br>        // exclusive mode, but the application does not have exclusive mode.  <br>        lpszError = TEXT("DDERR_NOEXCLUSIVEMODE"); <br>        break; <br> <br>    case DDERR_NOFLIPHW:  <br>        // Flipping visible surfaces is not supported.  <br>        lpszError = TEXT("DDERR_NOFLIPHW"); <br>        break; <br> <br>    case DDERR_NOGDI:  <br>        // No GDI is present.  <br>        lpszError = TEXT("DDERR_NOGDI"); <br>        break; <br> <br>    case DDERR_NOHWND:  <br>        // Clipper notification requires a window handle,  <br>        // or no window handle has been previously set  <br>        // as the cooperative level window handle.  <br>        lpszError = TEXT("DDERR_NOHWND"); <br>        break; <br> <br>    case DDERR_NOMIPMAPHW:  <br>        // The operation cannot be carried out because no  <br>        // mipmap texture mapping hardware is present or available.  <br>        lpszError = TEXT("DDERR_NOMIPMAPHW"); <br>        break; <br> <br>    case DDERR_NOMIRRORHW:  <br>        // The operation cannot be carried out because  <br>        // no mirroring hardware is present or available.  <br>        lpszError = TEXT("DDERR_NOMIRRORHW"); <br>        break; <br> <br>    case DDERR_NONONLOCALVIDMEM:  <br>        // An attempt was made to allocate non-local video memory <br>        // from a device that does not support non-local video memory. <br>        lpszError = TEXT("DDERR_NONONLOCALVIDMEM"); <br>        break; <br>  <br>    case DDERR_NOOVERLAYDEST:  <br>        // The IDirectDrawSurface2::GetOverlayPosition method  <br>        // is called on an overlay that the IDirectDrawSurface2::UpdateOverlay  <br>        // method has not been called on to establish a destination.  <br>        lpszError = TEXT("DDERR_NOOVERLAYDEST"); <br>        break; <br> <br>    case DDERR_NOOVERLAYHW:  <br>        // The operation cannot be carried out because  <br>        // no overlay hardware is present or available.  <br>        lpszError = TEXT("DDERR_NOOVERLAYHW"); <br>        break; <br> <br>    case DDERR_NOPALETTEATTACHED:  <br>        // No palette object is attached to this surface.  <br>        lpszError = TEXT("DDERR_NOPALETTEATTACHED"); <br>        break; <br> <br>    case DDERR_NOPALETTEHW:  <br>        // There is no hardware support for 16- or 256-color palettes.  <br>        lpszError = TEXT("DDERR_NOPALETTEHW"); <br>        break; <br> <br>    case DDERR_NORASTEROPHW:  <br>        // The operation cannot be carried out because  <br>        // no appropriate raster operation hardware is present or available.  <br>        lpszError = TEXT("DDERR_NORASTEROPHW"); <br>        break; <br> <br>    case DDERR_NOROTATIONHW:  <br>        // The operation cannot be carried out because  <br>        // no rotation hardware is present or available.  <br>        lpszError = TEXT("DDERR_NOROTATIONHW"); <br>        break; <br> <br>    case DDERR_NOSTRETCHHW:  <br>        // The operation cannot be carried out because  <br>        // there is no hardware support for stretching.  <br>        lpszError = TEXT("DDERR_NOSTRETCHHW"); <br>        break; <br> <br>    case DDERR_NOT4BITCOLOR:  <br>        // The DirectDrawSurface object is not using a  <br>        // 4-bit color palette and the requested operation  <br>        // requires a 4-bit color palette.  <br>        lpszError = TEXT("DDERR_NOT4BITCOLOR"); <br>        break; <br> <br>    case DDERR_NOT4BITCOLORINDEX:  <br>        // The DirectDrawSurface object is not using a 4-bit  <br>        // color index palette and the requested operation  <br>        // requires a 4-bit color index palette.  <br>        lpszError = TEXT("DDERR_NOT4BITCOLORINDEX"); <br>        break; <br> <br>    case DDERR_NOT8BITCOLOR:  <br>        // The DirectDrawSurface object is not using an 8-bit  <br>        // color palette and the requested operation requires  <br>        // an 8-bit color palette.  <br>        lpszError = TEXT("DDERR_NOT8BITCOLOR"); <br>        break; <br> <br>    case DDERR_NOTAOVERLAYSURFACE:  <br>        // An overlay component is called for a non-overlay surface.  <br>        lpszError = TEXT("DDERR_NOTAOVERLAYSURFACE"); <br>        break; <br> <br>    case DDERR_NOTEXTUREHW:  <br>        // The operation cannot be carried out because no  <br>        // texture-mapping hardware is present or available.  <br>        lpszError = TEXT("DDERR_NOTEXTUREHW"); <br>        break; <br> <br>    case DDERR_NOTFLIPPABLE:  <br>        // An attempt has been made to flip a surface that cannot be flipped.  <br>        lpszError = TEXT("DDERR_NOTFLIPPABLE"); <br>        break; <br> <br>    case DDERR_NOTFOUND:  <br>        // The requested item was not found.  <br>        lpszError = TEXT("DDERR_NOTFOUND"); <br>        break; <br> <br>    case DDERR_NOTINITIALIZED:  <br>        // An attempt was made to call an interface method of a DirectDraw object  <br>        // created by CoCreateInstance before the object was initialized.  <br>        lpszError = TEXT("DDERR_NOTINITIALIZED"); <br>        break; <br> <br>    case DDERR_NOTLOCKED:  <br>        // An attempt is made to unlock a surface that was not locked.  <br>        lpszError = TEXT("DDERR_NOTLOCKED"); <br>        break; <br> <br>    case DDERR_NOTPAGELOCKED:  <br>        // An attempt is made to page unlock a surface  <br>        // with no outstanding page locks.  <br>        lpszError = TEXT("DDERR_NOTPAGELOCKED"); <br>        break; <br> <br>    case DDERR_NOTPALETTIZED:  <br>        // The surface being used is not a palette-based surface.  <br>        lpszError = TEXT("DDERR_NOTPALETTIZED"); <br>        break; <br> <br>    case DDERR_NOVSYNCHW:  <br>        // The operation cannot be carried out because  <br>        // there is no hardware support for vertical blank synchronized operations.  <br>        lpszError = TEXT("DDERR_NOVSYNCHW"); <br>        break; <br> <br>    case DDERR_NOZBUFFERHW:  <br>        // The operation to create a z-buffer in display memory  <br>        // or to perform a blit using a z-buffer cannot be carried  <br>        // out because there is no hardware support for z-buffers.  <br>        lpszError = TEXT("DDERR_NOZBUFFERHW"); <br>        break; <br> <br>    case DDERR_NOZOVERLAYHW:  <br>        // The overlay surfaces cannot be z-layered based  <br>        // on the z-order because the hardware does not  <br>        // support z-ordering of overlays.  <br>        lpszError = TEXT("DDERR_NOZOVERLAYHW"); <br>        break; <br> <br>    case DDERR_OUTOFCAPS:  <br>        // The hardware needed for the requested operation has already been allocated.  <br>        lpszError = TEXT("DDERR_OUTOFCAPS"); <br>        break; <br> <br>    case DDERR_OUTOFMEMORY:  <br>        // DirectDraw does not have enough memory to perform the operation.  <br>        lpszError = TEXT("DDERR_OUTOFMEMORY"); <br>        break; <br> <br>    case DDERR_OUTOFVIDEOMEMORY:  <br>        // DirectDraw does not have enough display memory to perform the operation.  <br>        lpszError = TEXT("DDERR_OUTOFVIDEOMEMORY"); <br>        break; <br> <br>    case DDERR_OVERLAYCANTCLIP:  <br>        // The hardware does not support clipped overlays.  <br>        lpszError = TEXT("DDERR_OVERLAYCANTCLIP"); <br>        break; <br> <br>    case DDERR_OVERLAYCOLORKEYONLYONEACTIVE:  <br>        // An attempt was made to have more than one color key active on an overlay.  <br>        lpszError = TEXT("DDERR_OVERLAYCOLORKEYONLYONEACTIVE"); <br>        break; <br> <br>    case DDERR_OVERLAYNOTVISIBLE:  <br>        // The IDirectDrawSurface2::GetOverlayPosition method is called on a hidden overlay.  <br>        lpszError = TEXT("DDERR_OVERLAYNOTVISIBLE"); <br>        break; <br> <br>    case DDERR_PALETTEBUSY:  <br>        // Access to this palette is refused  <br>        // because the palette is locked by another thread.  <br>        lpszError = TEXT("DDERR_PALETTEBUSY"); <br>        break; <br> <br>    case DDERR_PRIMARYSURFACEALREADYEXISTS:  <br>        // This process has already created a primary surface.  <br>        lpszError = TEXT("DDERR_PRIMARYSURFACEALREADYEXISTS"); <br>        break; <br> <br>    case DDERR_REGIONTOOSMALL:  <br>        // The region passed to the  <br>        // IDirectDrawClipper::GetClipList method is too small.  <br>        lpszError = TEXT("DDERR_REGIONTOOSMALL"); <br>        break; <br> <br>    case DDERR_SURFACEALREADYATTACHED:  <br>        // An attempt was made to attach a surface to  <br>        // another surface to which it is already attached.  <br>        lpszError = TEXT("DDERR_SURFACEALREADYATTACHED"); <br>        break; <br> <br>    case DDERR_SURFACEALREADYDEPENDENT:  <br>        // An attempt was made to make a surface a dependency  <br>        // of another surface to which it is already dependent.  <br>        lpszError = TEXT("DDERR_SURFACEALREADYDEPENDENT"); <br>        break; <br> <br>    case DDERR_SURFACEBUSY:  <br>        // Access to the surface is refused because the  <br>        // surface is locked by another thread.  <br>        lpszError = TEXT("DDERR_SURFACEBUSY"); <br>        break; <br> <br>    case DDERR_SURFACEISOBSCURED:  <br>        // Access to the surface is refused  <br>        // because the surface is obscured.  <br>        lpszError = TEXT("DDERR_SURFACEISOBSCURED"); <br>        break; <br> <br>    case DDERR_SURFACELOST:  <br>        // Access to the surface is refused because the  <br>        // surface memory is gone. The DirectDrawSurface  <br>        // object representing this surface should have  <br>        // the IDirectDrawSurface2::Restore method called on it.  <br>        lpszError = TEXT("DDERR_SURFACELOST"); <br>        break; <br> <br>    case DDERR_SURFACENOTATTACHED:  <br>        // The requested surface is not attached.  <br>        lpszError = TEXT("DDERR_SURFACENOTATTACHED"); <br>        break; <br> <br>    case DDERR_TOOBIGHEIGHT:  <br>        // The height requested by DirectDraw is too large.  <br>        lpszError = TEXT("DDERR_TOOBIGHEIGHT"); <br>        break; <br> <br>    case DDERR_TOOBIGSIZE:  <br>        // The size requested by DirectDraw is too large.  <br>        // However, the individual height and width are OK. <br>        lpszError = TEXT("DDERR_TOOBIGSIZE"); <br>        break; <br> <br>    case DDERR_TOOBIGWIDTH:  <br>        // The width requested by DirectDraw is too large.  <br>        lpszError = TEXT("DDERR_TOOBIGWIDTH"); <br>        break; <br> <br>    case DDERR_UNSUPPORTED:  <br>        // The operation is not supported.  <br>        lpszError = TEXT("DDERR_UNSUPPORTED"); <br>        break; <br> <br>    case DDERR_UNSUPPORTEDFORMAT:  <br>        // The FourCC format requested is not supported by DirectDraw.  <br>        lpszError = TEXT("DDERR_UNSUPPORTEDFORMAT"); <br>        break; <br> <br>    case DDERR_UNSUPPORTEDMASK:  <br>        // The bitmask in the pixel format requested is not supported by DirectDraw.  <br>        lpszError = TEXT("DDERR_UNSUPPORTEDMASK"); <br>        break; <br> <br>    case DDERR_UNSUPPORTEDMODE:  <br>        // The display is currently in an unsupported mode.  <br>        lpszError = TEXT("DDERR_UNSUPPORTEDMODE"); <br>        break; <br> <br>    case DDERR_VERTICALBLANKINPROGRESS:  <br>        // A vertical blank is in progress.  <br>        lpszError = TEXT("DDERR_VERTICALBLANKINPROGRESS"); <br>        break; <br> <br>    case DDERR_WASSTILLDRAWING:  <br>        // The previous blit operation that is transferring  <br>        // information to or from this surface is incomplete.  <br>        lpszError = TEXT("DDERR_WASSTILLDRAWING"); <br>        break; <br> <br>    case DDERR_WRONGMODE: <br>        // This surface cannot be restored because it was created in a different mode.  <br>        lpszError = TEXT("DDERR_WRONGMODE"); <br>        break; <br> <br>    case DDERR_XALIGN: <br>        // The provided rectangle was not horizontally aligned on a required boundary.  <br>        lpszError = TEXT("DDERR_XALIGN"); <br>        break; <br> <br>    case DDERR_VIDEONOTACTIVE: <br>        // The video port is not active <br>        lpszError = TEXT("DDERR_VIDEONOTACTIVE"); <br>        break; <br> <br> <br>        // <br>        // D3D Immediate Mode Errors <br>        // <br> <br>    case D3DERR_BADMAJORVERSION: <br>        // ??? <br>        lpszError = TEXT("D3DERR_BADMAJORVERSION"); <br>        break; <br> <br>    case D3DERR_BADMINORVERSION: <br>        // ??? <br>        lpszError = TEXT("D3DERR_BADMINORVERSION"); <br>        break; <br> <br>    case D3DERR_INVALID_DEVICE: <br>        // ??? <br>        lpszError = TEXT("D3DERR_INVALID_DEVICE"); <br>        break; <br> <br>    case D3DERR_INITFAILED: <br>        // ??? <br>        lpszError = TEXT("D3DERR_INITFAILED"); <br>        break; <br> <br>    case D3DERR_EXECUTE_CREATE_FAILED: <br>        // ??? <br>        lpszError = TEXT("D3DERR_EXECUTE_CREATE_FAILED"); <br>        break; <br> <br>    case D3DERR_EXECUTE_DESTROY_FAILED: <br>        // ??? <br>        lpszError = TEXT("D3DERR_EXECUTE_DESTROY_FAILED"); <br>        break; <br> <br>    case D3DERR_EXECUTE_LOCK_FAILED: <br>        // ??? <br>        lpszError = TEXT("D3DERR_EXECUTE_LOCK_FAILED"); <br>        break; <br> <br>    case D3DERR_EXECUTE_UNLOCK_FAILED: <br>        // ??? <br>        lpszError = TEXT("D3DERR_EXECUTE_UNLOCK_FAILED"); <br>        break; <br> <br>    case D3DERR_EXECUTE_LOCKED: <br>        // ??? <br>        lpszError = TEXT("D3DERR_EXECUTE_LOCKED"); <br>        break; <br> <br>    case D3DERR_EXECUTE_NOT_LOCKED: <br>        // ??? <br>        lpszError = TEXT("D3DERR_EXECUTE_NOT_LOCKED"); <br>        break; <br> <br>    case D3DERR_EXECUTE_FAILED: <br>        // ??? <br>        lpszError = TEXT("D3DERR_EXECUTE_FAILED"); <br>        break; <br> <br>    case D3DERR_EXECUTE_CLIPPED_FAILED: <br>        // ??? <br>        lpszError = TEXT("D3DERR_CLIPPED_FAILED"); <br>        break; <br> <br>    case D3DERR_TEXTURE_NO_SUPPORT: <br>        // ??? <br>        lpszError = TEXT("D3DERR_TEXTURE_NO_SUPPORT"); <br>        break; <br> <br>    case D3DERR_TEXTURE_CREATE_FAILED: <br>        // ??? <br>        lpszError = TEXT("D3DERR_TEXTURE_CREATE_FAILED"); <br>        break; <br> <br>    case D3DERR_TEXTURE_DESTROY_FAILED: <br>        // ??? <br>        lpszError = TEXT("D3DERR_TEXTURE_DESTROY_FAILED"); <br>        break; <br> <br>    case D3DERR_TEXTURE_LOCK_FAILED: <br>        // ??? <br>        lpszError = TEXT("D3DERR_TEXTURE_LOCK_FAILED"); <br>        break; <br> <br>    case D3DERR_TEXTURE_UNLOCK_FAILED: <br>        // ??? <br>        lpszError = TEXT("D3DERR_TEXTURE_UNLOCK_FAILED"); <br>        break; <br> <br>    case D3DERR_TEXTURE_LOAD_FAILED: <br>        // ??? <br>        lpszError = TEXT("D3DERR_LOAD_FAILED"); <br>        break; <br> <br>    case D3DERR_TEXTURE_SWAP_FAILED: <br>        // ??? <br>        lpszError = TEXT("D3DERR_SWAP_FAILED"); <br>        break; <br> <br>    case D3DERR_TEXTURE_LOCKED: <br>        // ??? <br>        lpszError = TEXT("D3DERR_TEXTURE_LOCKED"); <br>        break; <br> <br>    case D3DERR_TEXTURE_NOT_LOCKED: <br>        // ??? <br>        lpszError = TEXT("D3DERR_TEXTURE_NOT_LOCKED"); <br>        break; <br> <br>    case D3DERR_TEXTURE_GETSURF_FAILED: <br>        // ??? <br>        lpszError = TEXT("D3DERR_TEXTURE_GETSURF_FAILED"); <br>        break; <br> <br>    case D3DERR_MATRIX_CREATE_FAILED: <br>        // ??? <br>        lpszError = TEXT("D3DERR_MATRIX_CREATE_FAILED"); <br>        break; <br> <br>    case D3DERR_MATRIX_DESTROY_FAILED: <br>        // ??? <br>        lpszError = TEXT("D3DERR_MATRIX_DESTROY_FAILED"); <br>        break; <br> <br>    case D3DERR_MATRIX_SETDATA_FAILED: <br>        // ??? <br>        lpszError = TEXT("D3DERR_MATRIX_SETDATA_FAILED"); <br>        break; <br> <br>    case D3DERR_MATRIX_GETDATA_FAILED: <br>        // ??? <br>        lpszError = TEXT("D3DERR_MAXTRIX_GETDATA_FAILED"); <br>        break; <br> <br>    case D3DERR_SETVIEWPORTDATA_FAILED: <br>        // ??? <br>        lpszError = TEXT("D3DERR_SETVIEWPORTDATA_FAILED"); <br>        break; <br> <br>    case D3DERR_INVALIDCURRENTVIEWPORT: <br>        // ??? <br>        lpszError = TEXT("D3DERR_INVALIDCURRENTVIEWPORT"); <br>        break; <br> <br>    case D3DERR_INVALIDPRIMITIVETYPE: <br>        // ??? <br>        lpszError = TEXT("D3DERR_INVALIDPRIMITIVETYPE"); <br>        break; <br> <br>    case D3DERR_INVALIDVERTEXTYPE: <br>        // ??? <br>        lpszError = TEXT("D3DERR_INVALIDVERTEXTYPE"); <br>        break; <br> <br>    case D3DERR_TEXTURE_BADSIZE: <br>        // ??? <br>        lpszError = TEXT("D3DERR_TEXTURE_BADSIZE"); <br>        break; <br> <br>    case D3DERR_MATERIAL_CREATE_FAILED: <br>        // ??? <br>        lpszError = TEXT("D3DERR_MATERIAL_CREATE_FAILED"); <br>        break; <br> <br>    case D3DERR_MATERIAL_DESTROY_FAILED: <br>        // ??? <br>        lpszError = TEXT("D3DERR_MATERIAL_DESTROY_FAILED"); </code></pre>
<p>
</p>
<pre><code>break; <br> <br>    case D3DERR_MATERIAL_SETDATA_FAILED: <br>        // ??? <br>        lpszError = TEXT("D3DERR_MATERIAL_SETDATA_FAILED"); <br>        break; <br> <br>    case D3DERR_MATERIAL_GETDATA_FAILED: <br>        // ??? <br>        lpszError = TEXT("D3DERR_MATERIAL_GETDATA_FAILED"); <br>        break; <br> <br>    case D3DERR_INVALIDPALETTE: <br>        // ??? <br>        lpszError = TEXT("D3DERR_INVALIDPALETTE"); <br>        break; <br> <br>    case D3DERR_ZBUFF_NEEDS_SYSTEMMEMORY: <br>        // ??? <br>        lpszError = TEXT("D3DERR_ZBUFF_NEEDS_SYSTEMMEMORY"); <br>        break; <br> <br>    case D3DERR_ZBUFF_NEEDS_VIDEOMEMORY: <br>        // ??? <br>        lpszError = TEXT("D3DERR_ZBUFF_NEEDS_VIDEOMEMORY"); <br>        break; <br> <br>    case D3DERR_SURFACENOTINVIDMEM: <br>        // ??? <br>        lpszError = TEXT("D3DERR_SURFACENOTINVIDMEM"); <br>        break; <br> <br>    case D3DERR_LIGHT_SET_FAILED: <br>        // ??? <br>        lpszError = TEXT("D3DERR_LIGHT_SET_FAILED"); <br>        break; <br> <br>    case D3DERR_LIGHTHASVIEWPORT: <br>        // ??? <br>        lpszError = TEXT("D3DERR_LIGHTHASVIEWPORT"); <br>        break; <br> <br>    case D3DERR_LIGHTNOTINTHISVIEWPORT: <br>        // ??? <br>        lpszError = TEXT("D3DERR_LIGHTNOTINTHISVIEWPORT"); <br>        break; <br> <br>    case D3DERR_SCENE_IN_SCENE: <br>        // ??? <br>        lpszError = TEXT("D3DERR_SCENE_IN_SCENE"); <br>        break; <br> <br>    case D3DERR_SCENE_NOT_IN_SCENE: <br>        // ??? <br>        lpszError = TEXT("D3DERR_SCENE_NOT_IN_SCENE"); <br>        break; <br> <br>    case D3DERR_SCENE_BEGIN_FAILED: <br>        // ??? <br>        lpszError = TEXT("D3DERR_SCENE_BEGIN_FAILED"); <br>        break; <br> <br>    case D3DERR_SCENE_END_FAILED: <br>        // ??? <br>        lpszError = TEXT("D3DERR_SCENE_END_FAILED"); <br>        break; <br> <br>    case D3DERR_INBEGIN: <br>        // ??? <br>        lpszError = TEXT("D3DERR_INBEGIN"); <br>        break; <br> <br>    case D3DERR_NOTINBEGIN: <br>        // ??? <br>        lpszError = TEXT("D3DERR_NOTINBEGIN"); <br>        break; <br> <br>    case D3DERR_NOVIEWPORTS: <br>        // ??? <br>        lpszError = TEXT("D3DERR_NOVIEWPORTS"); <br>        break; <br> <br>    case D3DERR_VIEWPORTDATANOTSET: <br>        // ??? <br>        lpszError = TEXT("D3DERR_VIEWPORTDATANOTSET"); <br>        break; <br> <br>    case D3DERR_VIEWPORTHASNODEVICE: <br>        // ??? <br>        lpszError = TEXT("D3DERR_VIEWPORTHASNODEVICE"); <br>        break; <br> <br>     <br>        // <br>        // D3D Retained Mode Errors <br>        // <br>#if 0     <br>    case D3DRMERR_BADOBJECT: <br>        // ??? <br>        lpszError = TEXT("D3DRMERR_BADOBJECT"); <br>        break; <br> <br>    case D3DRMERR_BADTYPE: <br>        // ??? <br>        lpszError = TEXT("D3DRMERR_BADTYPE"); <br>        break; <br> <br>    case D3DRMERR_BADALLOC: <br>        // ??? <br>        lpszError = TEXT("D3DRMERR_BADALLOC"); <br>        break; <br> <br>    case D3DRMERR_FACEUSED: <br>        // ??? <br>        lpszError = TEXT("D3DRMERR_FACEUSED"); <br>        break; <br> <br>    case D3DRMERR_NOTFOUND: <br>        // ??? <br>        lpszError = TEXT("D3DRMERR_NOTFOUND"); <br>        break; <br> <br>    case D3DRMERR_NOTDONEYET: <br>        // ??? <br>        lpszError = TEXT("D3DRMERR_NOTDONEYET"); <br>        break; <br> <br>    case D3DRMERR_FILENOTFOUND: <br>        // ??? <br>        lpszError = TEXT("D3DRMERR_FILENOTFOUND"); <br>        break; <br> <br>    case D3DRMERR_BADFILE: <br>        // ??? <br>        lpszError = TEXT("D3DRMERR_BADFILE"); <br>        break; <br> <br>    case D3DRMERR_BADDEVICE: <br>        // ??? <br>        lpszError = TEXT("D3DRMERR_BADDEVICE"); <br>        break; <br> <br>    case D3DRMERR_BADVALUE: <br>        // ??? <br>        lpszError = TEXT("D3DRMERR_BADVALUE"); <br>        break; <br> <br>    case D3DRMERR_BADMAJORVERSION: <br>        // ??? <br>        lpszError = TEXT("D3DRMERR_BADMAJORVERSION"); <br>        break; <br> <br>    case D3DRMERR_BADMINORVERSION: <br>        // ??? <br>        lpszError = TEXT("D3DRMERR_BADMINORVERSION"); <br>        break; <br> <br>    case D3DRMERR_UNABLETOEXECUTE: <br>        // ??? <br>        lpszError = TEXT("D3DRMERR_BADMINORVERSION"); <br>        break; <br>#endif // D3DRM_ERRORS <br> <br> <br>// <br>// Application defined errors <br>// <br>case APPERR_GENERIC: <br>        // Generic Error <br>        lpszError = TEXT("APPERR_GENERIC"); <br>        break; <br> <br>case APPERR_INVALIDPARAMS: <br>        // Invalid Parameters passed into function <br>        lpszError = TEXT("APPERR_INVALIDPARAMS"); <br>        break; <br> <br>case APPERR_NOTINITIALIZED: <br>// Programmer error, called function without proper initialization <br>lpszError = TEXT("APPERR_NOT_INITIALIZED"); <br>break; <br> <br>    default: <br>        // Unknown DD/D3D/App Error <br>        wsprintf (szMsg, "Unknown Error #%ld", (DWORD)(hResult &amp; 0x0000FFFFL)); <br>        lpszError = szMsg; <br>        break; <br>    } <br> <br>    // Copy DD/D3D Error string to buff <br>    cLen = strlen (lpszError); <br>    if (cLen &gt;= cchError) <br>    { <br>        cLen = cchError - 1; <br>    } <br> <br>    if (cLen) <br>    { <br>        strncpy (lpszErrorBuff, lpszError, cLen); <br>        lpszErrorBuff[cLen] = 0; <br>    } <br> <br>    return TRUE; <br>} // End GetDDErrorString <br> <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** End of File <br>**----------------------------------------------------------------------------- <br>*/ <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
