<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>BOIDS.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2979"></a>BOIDS.CPP</h2>
<pre><code>/* <br>**---------------------------------------------------------------------------- <br>** <br>**  File:       boids.cpp <br>**  Purpose:     <br>**  Notes: <br>** <br>**Copyright (C) 1995 - 1997 Microsoft Corporation. All Rights Reserved. <br>**---------------------------------------------------------------------------- <br>*/ <br> <br>/* <br>**---------------------------------------------------------------------------- <br>** Includes <br>**---------------------------------------------------------------------------- <br>*/ <br> <br>#include &lt;math.h&gt; <br>#include &lt;time.h&gt; <br> <br>#include "D3DScene.h" <br>#include "Debug.h" <br>#include "D3DWin.h" <br>#include "d3dutils.h" <br>#include "d3dtex.h" <br>#include "boids.h" <br> <br> <br>/* <br>**---------------------------------------------------------------------------- <br>** Defines <br>**---------------------------------------------------------------------------- <br>*/ <br> <br>#define NUM_BOIDS13 <br> <br>// ground pattern <br>D3DVECTOR       grid_color(0.0f, 0.3f, 0.5f); <br>D3DLVERTEXpattern1[24]; <br>D3DLVERTEXpattern2[8]; <br>WORDpat1_indices[25] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,  <br>13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 0 }; <br>WORDpat2_indices[9] = { 0, 1, 2, 3, 4, 5, 6, 7, 0 }; <br> <br>#define MESH_SIZE8 <br>#define SPHERE_VERTICES(2+MESH_SIZE*MESH_SIZE*2) <br>#define SPHERE_INDICES((MESH_SIZE*4 + MESH_SIZE*4*(MESH_SIZE-1))*3) <br> <br>     <br>/* <br>**---------------------------------------------------------------------------- <br>** Local Variables <br>**---------------------------------------------------------------------------- <br>*/ <br> <br>D3DVERTEXsphere[SPHERE_VERTICES]; <br>WORDsphere_indices[SPHERE_INDICES]; <br> <br>Flockflock; <br> <br>D3DVERTEXboid_vertices[16]; <br>WORDboid_indices[30]; <br> <br>D3DMATRIXproj, view, world; <br> <br>Light*lpLight1, <br>*lpLight2; <br> <br>Material*lpBackgroundMat, <br>*lpGridMat, <br>*lpSphereMat, <br>*lpBoidMat; <br> <br>D3DTextureSphereTex; <br> <br>/* <br>**---------------------------------------------------------------------------- <br>** Function definitions <br>**---------------------------------------------------------------------------- <br>*/ <br> <br>/* <br>**---------------------------------------------------------------------------- <br>** Name:        DrawBoid <br>** Purpose: <br>**---------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT <br>Drawboid(LPDIRECT3DDEVICE2 lpDev) <br>{ <br>HRESULT hResult; <br> <br>        hResult = lpDev-&gt;DrawIndexedPrimitive(D3DPT_TRIANGLELIST, D3DVT_VERTEX, (LPVOID)boid_vertices, 16, boid_indices, 30, D3DDP_WAIT); <br> <br>return hResult; <br>} // End DrawBoid <br> <br> <br>/* <br>**---------------------------------------------------------------------------- <br>** Name:        DrawSphere <br>** Purpose: <br>**---------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT <br>DrawSphere(LPDIRECT3DDEVICE2 lpDev) <br>{ <br>HRESULT hResult; <br> <br>        hResult = lpDev-&gt;DrawIndexedPrimitive(D3DPT_TRIANGLELIST, D3DVT_VERTEX, (LPVOID)sphere, SPHERE_VERTICES, sphere_indices, SPHERE_INDICES, D3DDP_WAIT); <br>if (hResult != D3D_OK) <br>return hResult; <br> <br>return D3D_OK; <br>} // End DrawSphere <br> <br> <br>HRESULT <br>DrawPattern(LPDIRECT3DDEVICE2 lpDev) <br>{ <br>HRESULT hResult; <br> <br>for (int dx= -2; dx&lt;3; dx++) { <br>for (int dz= -2; dz&lt;3; dz++) { <br>D3DVECTORoffset(dx*80.0f, 0.0f, dz*80.0f); <br> <br>world = TranslateMatrix(offset); <br>hResult = lpDev-&gt;SetTransform(D3DTRANSFORMSTATE_WORLD, &amp;world); <br>if (hResult != D3D_OK) { <br>REPORTERR(hResult); <br>return hResult; <br>} <br>                        hResult = lpDev-&gt;DrawIndexedPrimitive(D3DPT_LINESTRIP, D3DVT_LVERTEX, (LPVOID)pattern1, 24, pat1_indices, 25, D3DDP_WAIT); <br>if (hResult != D3D_OK) { <br>REPORTERR(hResult); <br>return hResult; <br>} <br>                        hResult = lpDev-&gt;DrawIndexedPrimitive(D3DPT_LINESTRIP, D3DVT_LVERTEX, (LPVOID)pattern2, 8, pat2_indices, 9, D3DDP_WAIT); <br>if (hResult != D3D_OK) { <br>REPORTERR(hResult); <br>return hResult; <br>} <br>} <br>} <br> <br>return D3D_OK; <br>}// end of DrawPattern() <br> <br> <br>/* <br>**---------------------------------------------------------------------------- <br>** D3DScene Methods <br>**---------------------------------------------------------------------------- <br>*/ <br> <br>/* <br>**---------------------------------------------------------------------------- <br>** Name:        D3DScene::D3DScene <br>** Purpose:Default Constructor <br>**---------------------------------------------------------------------------- <br>*/ <br> <br>D3DScene::D3DScene(void) <br>{ <br>lpd3dWindow = NULL; <br>} // End D3DScene::D3DScene <br> <br> <br>   <br>/* <br>**---------------------------------------------------------------------------- <br>** Name:        D3DScene::~D3DScene <br>** Purpose:Default Destructor <br>**---------------------------------------------------------------------------- <br>*/ <br> <br>D3DScene::~D3DScene(void) <br>{ <br>Fini(); <br>lpd3dWindow = NULL; <br>} // End D3DScene::~D3DScene <br> <br> <br> <br>/* <br>**---------------------------------------------------------------------------- <br>** Name:        D3DScene::Init <br>** Purpose:Do all static intialization here <br>** Notes:This means all Scene data that isn't dependent on the <br>**D3D interface, viewport, or D3D device in some manner <br>**---------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT <br>D3DScene::Init(LPD3DWindow lpd3dWin) <br>{ <br>HRESULT hResult; <br>int i, j; <br> <br>// Check Parameters <br>if (! lpd3dWin){ <br>// Need a valid D3D Window object <br>hResult = APPERR_INVALIDPARAMS; <br>REPORTERR(hResult); <br>return hResult; <br>} <br> <br>// Save assocation with D3D Window <br>lpd3dWindow = lpd3dWin; <br> <br>// generate the boid data <br> <br>// top <br>boid_vertices[ 0] = D3DVERTEX(D3DVECTOR(0.0f, 0.0f, 10.0f), Normalize(D3DVECTOR(0.2f, 1.0f, 0.0f)), 0.0f, 0.5f); <br>boid_vertices[ 1] = D3DVERTEX(D3DVECTOR(10.0f, 0.0f, -10.0f), Normalize(D3DVECTOR(0.1f, 1.0f, 0.0f)), 0.5f, 1.0f); <br>boid_vertices[ 2] = D3DVERTEX(D3DVECTOR(3.0f, 3.0f, -7.0f), Normalize(D3DVECTOR(0.0f, 1.0f, 0.0f)), 0.425f, 0.575f); <br>boid_vertices[ 3] = D3DVERTEX(D3DVECTOR(-3.0f, 3.0f, -7.0f), Normalize(D3DVECTOR(-0.1f, 1.0f, 0.0f)), 0.425f, 0.425f); <br>boid_vertices[ 4] = D3DVERTEX(D3DVECTOR(-10.0f, 0.0f, -10.0f), Normalize(D3DVECTOR(-0.2f, 1.0f, 0.0f)), 0.5f, 0.0f); <br> <br>//bottom <br>boid_vertices[ 5] = D3DVERTEX(D3DVECTOR(0.0f, 0.0f, 10.0f), Normalize(D3DVECTOR(0.2f, -1.0f, 0.0f)), 1.0f, 0.5f); <br>boid_vertices[ 6] = D3DVERTEX(D3DVECTOR(10.0f, 0.0f, -10.0f), Normalize(D3DVECTOR(0.1f, -1.0f, 0.0f)), 0.5f, 1.0f); <br>boid_vertices[ 7] = D3DVERTEX(D3DVECTOR(3.0f, -3.0f, -7.0f), Normalize(D3DVECTOR(0.0f, -1.0f, 0.0f)), 0.575f, 0.575f); <br>boid_vertices[ 8] = D3DVERTEX(D3DVECTOR(-3.0f, -3.0f, -7.0f), Normalize(D3DVECTOR(-0.1f, -1.0f, 0.0f)), 0.575f, 0.425f); <br>boid_vertices[ 9] = D3DVERTEX(D3DVECTOR(-10.0f, 0.0f, -10.0f), Normalize(D3DVECTOR(-0.2f, -1.0f, 0.0f)), 0.5f, 0.0f); <br> <br>// rear <br>boid_vertices[10] = D3DVERTEX(D3DVECTOR(10.0f, 0.0f, -10.0f), Normalize(D3DVECTOR(-0.4f, 0.0f, -1.0f)), 0.5f, 1.0f); <br>boid_vertices[11] = D3DVERTEX(D3DVECTOR(3.0f, 3.0f, -7.0f), Normalize(D3DVECTOR(-0.2f, 0.0f, -1.0f)), 0.425f, 0.575f); <br>boid_vertices[12] = D3DVERTEX(D3DVECTOR(-3.0f, 3.0f, -7.0f), Normalize(D3DVECTOR(0.2f, 0.0f, -1.0f)), 0.425f, 0.425f); <br>boid_vertices[13] = D3DVERTEX(D3DVECTOR(-10.0f, 0.0f, -10.0f), Normalize(D3DVECTOR(0.4f, 0.0f, -1.0f)), 0.5f, 0.0f); <br>boid_vertices[14] = D3DVERTEX(D3DVECTOR(-3.0f, -3.0f, -7.0f), Normalize(D3DVECTOR(0.2f, 0.0f, -1.0f)), 0.575f, 0.425f); <br>boid_vertices[15] = D3DVERTEX(D3DVECTOR(3.0f, -3.0f, -7.0f), Normalize(D3DVECTOR(-0.2f, 0.0f, -1.0f)), 0.575f, 0.575f); <br> <br>// top <br>boid_indices[ 0] = 0; <br>boid_indices[ 1] = 1; <br>boid_indices[ 2] = 2; <br>boid_indices[ 3] = 0; <br>boid_indices[ 4] = 2; <br>boid_indices[ 5] = 3; <br>boid_indices[ 6] = 0; <br>boid_indices[ 7] = 3; <br>boid_indices[ 8] = 4; <br> <br>// bottom <br>boid_indices[ 9] = 5; <br>boid_indices[10] = 7; <br>boid_indices[11] = 6; <br>boid_indices[12] = 5; <br>boid_indices[13] = 8; <br>boid_indices[14] = 7; <br>boid_indices[15] = 5; <br>boid_indices[16] = 9; <br>boid_indices[17] = 8; <br> <br>// rear <br>boid_indices[18] = 10; <br>boid_indices[19] = 15; <br>boid_indices[20] = 11; <br>boid_indices[21] = 11; <br>boid_indices[22] = 15; <br>boid_indices[23] = 12; <br>boid_indices[24] = 12; <br>boid_indices[25] = 15; <br>boid_indices[26] = 14; <br>boid_indices[27] = 12; <br>boid_indices[28] = 14; <br>boid_indices[29] = 13; <br> <br>// scale the boid to be unit length <br>for (i=0; i&lt;16; i++) { <br>boid_vertices[i].x /= 20.0f; <br>boid_vertices[i].y /= 20.0f; <br>boid_vertices[i].z /= 20.0f; <br>} <br> <br>// seed the random number generator <br>srand(time(NULL)); <br> <br>// allocate the flock <br>if (!(flock.boids = (Boid *)malloc(NUM_BOIDS * sizeof(Boid)))) { <br>return FALSE; <br>} <br>if (!(flock.dist = (float **)malloc(NUM_BOIDS * sizeof(float *)))) { <br>return FALSE; <br>} <br> <br>flock.num_boids = NUM_BOIDS; <br>flock.goal = D3DVECTOR(0.0f, 0.0f, 0.0f); <br> <br>for (i=0; i&lt;flock.num_boids; i++) { <br>flock.boids[i].loc = D3DVECTOR(100.0f*(rnd()-rnd()), 10.0f*rnd(), 100.0f*(rnd()-rnd())); <br>flock.boids[i].dir = Normalize(D3DVECTOR(rnd()-rnd(), rnd()-rnd(), rnd()-rnd())); <br>flock.boids[i].yaw = flock.boids[i].pitch = flock.boids[i].roll = flock.boids[i].dyaw = 0.0f; <br>flock.boids[i].speed = 0.1f; <br>flock.boids[i].color = D3DVECTOR(rnd(), rnd(), rnd()); <br>flock.boids[i].color -= D3DVECTOR(Min(flock.boids[i].color)); <br>flock.boids[i].color /= Max(flock.boids[i].color); <br>if (!(flock.dist[i] = (float *)malloc(NUM_BOIDS * sizeof(float)))) { <br>return FALSE; <br>} <br>} <br> <br>flock.num_obs = 4; <br>if (!(flock.obs = (Obstacle *)malloc(flock.num_obs * sizeof(Obstacle)))) { <br>return FALSE; <br>} <br>    flock.obs[0].loc = D3DVECTOR(100.0f, 10.0f, 0.0f); <br>    flock.obs[1].loc = D3DVECTOR(-100.0f, 10.0f, 0.0f); <br>    flock.obs[2].loc = D3DVECTOR(0.0f, 10.0f, 100.0f); <br>    flock.obs[3].loc = D3DVECTOR(0.0f, 10.0f, -100.0f); <br>flock.obs[0].radius = 3.0f; <br>flock.obs[1].radius = 3.0f; <br>flock.obs[2].radius = 3.0f; <br>flock.obs[3].radius = 3.0f; <br> <br>D3DCOLORdiffuse = D3DRGB(grid_color[0], grid_color[1], grid_color[2]), <br>specular = D3DRGB(0.0, 0.0, 0.0); <br> <br>pattern1[ 0] = D3DLVERTEX(D3DVECTOR(-25.0f, 0.0f, 35.0f), diffuse, specular, 0.0f, 0.0f); <br>pattern1[ 1] = D3DLVERTEX(D3DVECTOR(-15.0f, 0.0f, 35.0f), diffuse, specular, 0.0f, 0.0f); <br>pattern1[ 2] = D3DLVERTEX(D3DVECTOR(-5.0f, 0.0f, 25.0f), diffuse, specular, 0.0f, 0.0f); <br>pattern1[ 3] = D3DLVERTEX(D3DVECTOR(5.0f, 0.0f, 25.0f), diffuse, specular, 0.0f, 0.0f); <br>pattern1[ 4] = D3DLVERTEX(D3DVECTOR(15.0f, 0.0f, 35.0f), diffuse, specular, 0.0f, 0.0f); <br>pattern1[ 5] = D3DLVERTEX(D3DVECTOR(25.0f, 0.0f, 35.0f), diffuse, specular, 0.0f, 0.0f); <br>pattern1[ 6] = D3DLVERTEX(D3DVECTOR(35.0f, 0.0f, 25.0f), diffuse, specular, 0.0f, 0.0f); <br>pattern1[ 7] = D3DLVERTEX(D3DVECTOR(35.0f, 0.0f, 15.0f), diffuse, specular, 0.0f, 0.0f); <br>pattern1[ 8] = D3DLVERTEX(D3DVECTOR(25.0f, 0.0f, 5.0f), diffuse, specular, 0.0f, 0.0f); <br>pattern1[ 9] = D3DLVERTEX(D3DVECTOR(25.0f, 0.0f, -5.0f), diffuse, specular, 0.0f, 0.0f); <br>pattern1[10] = D3DLVERTEX(D3DVECTOR(35.0f, 0.0f, -15.0f), diffuse, specular, 0.0f, 0.0f); <br>pattern1[11] = D3DLVERTEX(D3DVECTOR(35.0f, 0.0f, -25.0f), diffuse, specular, 0.0f, 0.0f); <br>pattern1[12] = D3DLVERTEX(D3DVECTOR(25.0f, 0.0f, -35.0f), diffuse, specular, 0.0f, 0.0f); <br>pattern1[13] = D3DLVERTEX(D3DVECTOR(15.0f, 0.0f,-35.0f), diffuse, specular, 0.0f, 0.0f); <br>pattern1[14] = D3DLVERTEX(D3DVECTOR(5.0f, 0.0f, -25.0f), diffuse, specular, 0.0f, 0.0f); <br>pattern1[15] = D3DLVERTEX(D3DVECTOR(-5.0f, 0.0f, -25.0f), diffuse, specular, 0.0f, 0.0f); <br>pattern1[16] = D3DLVERTEX(D3DVECTOR(-15.0f, 0.0f,-35.0f), diffuse, specular, 0.0f, 0.0f); <br>pattern1[17] = D3DLVERTEX(D3DVECTOR(-25.0f, 0.0f,-35.0f), diffuse, specular, 0.0f, 0.0f); <br>pattern1[18] = D3DLVERTEX(D3DVECTOR(-35.0f, 0.0f, -25.0f), diffuse, specular, 0.0f, 0.0f); <br>pattern1[19] = D3DLVERTEX(D3DVECTOR(-35.0f, 0.0f, -15.0f), diffuse, specular, 0.0f, 0.0f); <br>pattern1[20] = D3DLVERTEX(D3DVECTOR(-25.0f, 0.0f, -5.0f), diffuse, specular, 0.0f, 0.0f); <br>pattern1[21] = D3DLVERTEX(D3DVECTOR(-25.0f, 0.0f, 5.0f), diffuse, specular, 0.0f, 0.0f); <br>pattern1[22] = D3DLVERTEX(D3DVECTOR(-35.0f, 0.0f, 15.0f), diffuse, specular, 0.0f, 0.0f); <br>pattern1[23] = D3DLVERTEX(D3DVECTOR(-35.0f, 0.0f, 25.0f), diffuse, specular, 0.0f, 0.0f); <br> <br>pattern2[ 0] = D3DLVERTEX(D3DVECTOR(-5.0f, 0.0f, 15.0f), diffuse, specular, 0.0f, 0.0f); <br>pattern2[ 1] = D3DLVERTEX(D3DVECTOR(5.0f, 0.0f, 15.0f), diffuse, specular, 0.0f, 0.0f); <br>pattern2[ 2] = D3DLVERTEX(D3DVECTOR(15.0f, 0.0f, 5.0f), diffuse, specular, 0.0f, 0.0f); <br>pattern2[ 3] = D3DLVERTEX(D3DVECTOR(15.0f, 0.0f, -5.0f), diffuse, specular, 0.0f, 0.0f); <br>pattern2[ 4] = D3DLVERTEX(D3DVECTOR(5.0f, 0.0f, -15.0f), diffuse, specular, 0.0f, 0.0f); <br>pattern2[ 5] = D3DLVERTEX(D3DVECTOR(-5.0f, 0.0f, -15.0f), diffuse, specular, 0.0f, 0.0f); <br>pattern2[ 6] = D3DLVERTEX(D3DVECTOR(-15.0f, 0.0f, -5.0f), diffuse, specular, 0.0f, 0.0f); <br>pattern2[ 7] = D3DLVERTEX(D3DVECTOR(-15.0f, 0.0f, 5.0f), diffuse, specular, 0.0f, 0.0f); <br> <br>float   dj = pi/(MESH_SIZE+1.0f); <br>floatdi = pi/MESH_SIZE; <br> <br>// generate the sphere data, note the random texture coords <br> <br>// vertices 0 and 1 are the north and south poles <br>sphere[0] = D3DVERTEX(D3DVECTOR(0.0f, 1.0f, 0.0f), Normalize(D3DVECTOR(0.0f, 1.0f, 0.0f)), 0.0f, 0.0f); <br>sphere[1] = D3DVERTEX(D3DVECTOR(0.0f, -1.0f, 0.0f), Normalize(D3DVECTOR(0.0f, -1.0f, 0.0f)), 1.0f, 1.0f); <br> <br>for (j=0; j&lt;MESH_SIZE; j++) { <br>for (i=0; i&lt;MESH_SIZE*2; i++) { <br>D3DVECTORp; <br>floatu, v; <br> <br>p.y = (float) cos((j+1) * dj); <br>p.x = (float) sin(i * di) * (float) sin((j+1) * dj); <br>p.z = (float) cos(i * di) * (float) sin((j+1) * dj); <br>u = (float)i/MESH_SIZE; <br>if (u&gt;1.0f)  <br>u -= 1.0f; <br>u = 1.0f - u;// flip so texture is not mirrored <br>v = (float)j/MESH_SIZE; <br>sphere[2+i+j*MESH_SIZE*2] = D3DVERTEX(p, p, u, v); <br>} <br>} <br> <br>// now generate the traingle indices <br>// strip around north pole first <br>for (i=0; i&lt;MESH_SIZE*2; i++) { <br>sphere_indices[3*i] = 0; <br>sphere_indices[3*i+1] = i+2; <br>sphere_indices[3*i+2] = i+3; <br>if (i==MESH_SIZE*2-1) <br>sphere_indices[3*i+2] = 2; <br>} <br> <br>// now all the middle strips <br>intv;// vertex offset <br>int ind;// indices offset <br>for (j=0; j&lt;MESH_SIZE-1; j++) { <br>v = 2+j*MESH_SIZE*2; <br>ind = 3*MESH_SIZE*2 + j*6*MESH_SIZE*2; <br>for (i=0; i&lt;MESH_SIZE*2; i++) { <br>sphere_indices[6*i+ind] = v+i; <br>sphere_indices[6*i+2+ind] = v+i+1; <br>sphere_indices[6*i+1+ind] = v+i+MESH_SIZE*2; <br> <br>sphere_indices[6*i+ind+3] = v+i+MESH_SIZE*2; <br>sphere_indices[6*i+2+ind+3] = v+i+1; <br>sphere_indices[6*i+1+ind+3] = v+i+MESH_SIZE*2+1; <br>if (i==MESH_SIZE*2-1) { <br>sphere_indices[6*i+2+ind] = v+i+1-2*MESH_SIZE; <br>sphere_indices[6*i+2+ind+3] = v+i+1-2*MESH_SIZE; <br>sphere_indices[6*i+1+ind+3] = v+i+MESH_SIZE*2+1-2*MESH_SIZE; <br>} <br>} <br>} <br> <br>// finally strip around south pole <br>v = SPHERE_VERTICES-MESH_SIZE*2; <br>ind = SPHERE_INDICES-3*MESH_SIZE*2; <br>for (i=0; i&lt;MESH_SIZE*2; i++) { <br>sphere_indices[3*i+ind] = 1; <br>sphere_indices[3*i+1+ind] = v+i+1; <br>sphere_indices[3*i+2+ind] = v+i; <br>if (i==MESH_SIZE*2-1) <br>sphere_indices[3*i+1+ind] = v; <br>} <br> <br>// Success <br>    return D3D_OK; <br>} // End D3DScene::Init <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       D3DScene::Fini <br>**  Purpose:Cleanup scene objects <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DScene::Fini(void) <br>{ <br>Detach(); <br>lpd3dWindow = NULL; <br> <br>// Success <br>return D3D_OK; <br>} // End D3DScene::Fini <br> <br> <br> <br>/* <br>**---------------------------------------------------------------------------- <br>** Name:        D3DScene::Attach <br>** Purpose:Attaching to a new D3DWindow object <br>** Notes:Need to create and attach all Scene objects dependent upon <br>**the D3D interface, viewport, and D3D device here.   <br>**For Example:  Textures, Materials, Lights, etc. <br>**---------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DScene::Attach(void) <br>{ <br>HRESULT hResult; <br> <br>// Check Initialization <br>if ((! lpd3dWindow) || (! lpd3dWindow-&gt;isValid())){ <br>// Error, not properly initialized <br>hResult = APPERR_NOTINITIALIZED; <br>REPORTERR(hResult); <br>return hResult; <br>} <br> <br>hResult = AttachViewport(); <br>if (hResult != D3D_OK) { <br>return hResult; <br>} <br> <br>// Success <br>return D3D_OK; <br>} // End D3DScene::Attach <br> <br>   <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       D3DScene::Detach <br>**  Purpose:Cleanup all scene objects dependent upon the  <br>**D3D Interface, viewport, or D3D device  <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DScene::Detach(void) <br>{ <br>// Cleanup Viewport <br>DetachViewport(); <br> <br>// Success <br>return D3D_OK; <br>} // End D3DScene::Fini <br> <br> <br> <br> <br>/* <br>**---------------------------------------------------------------------------- <br>** Name:        D3DScene::Render <br>** Purpose: <br>**---------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DScene::Render(void) <br>{ <br>LPDIRECT3DDEVICE2lpDev; <br>LPDIRECT3DVIEWPORT2 lpView; <br>RECTrSrc; <br>LPD3DRECTlpExtent = NULL; <br>inti; <br>HRESULThResult; <br>D3DCLIPSTATUSstatus; <br>D3DRECTd3dRect; <br>D3DVECTORoffset; <br>static D3DVECTORfrom(0.0f, 30.0f, 100.0f); <br>static D3DVECTORat(0.0f, 0.0f, 50.0f); <br>static D3DVECTORup(0.0f, 1.0f, 0.0f); <br>static floattic = -200.0f * rnd(); <br> <br>// Check Initialization <br>if ((! lpd3dWindow) || (! lpd3dWindow-&gt;isValid ())){ <br>// Error, not properly initialized <br>hResult = APPERR_NOTINITIALIZED; <br>REPORTERR(hResult); <br>return hResult; <br>} <br> <br>lpDev= lpd3dWindow-&gt;lpd3dDevice; <br>lpView  = lpd3dWindow-&gt;lpd3dViewport; <br>lpd3dWindow-&gt;GetSurfaceRect(rSrc); <br> <br>// Double Check <br>#ifdef DEBUG <br>if ((! lpDev) || (! lpView)) <br>{ <br>// Error, not initialized properly <br>hResult = APPERR_NOTINITIALIZED; <br>REPORTERR(hResult); <br>return hResult; <br>} <br>#endif <br> <br> <br>// <br>    // Clear both back and z-buffer. <br>    // <br>    // NOTE: Its safe to specify the z-buffer clear flag even if we <br>    // don't have an attached z-buffer. Direct3D will simply discard <br>    // the flag if no z-buffer is being used. <br>    // <br>    // NOTE: For maximum efficiency we only want to clear those <br>    // regions of the device surface and z-buffer which we actually <br>    // rendered to in the last frame. This is the purpose of the <br>    // array of rectangles and count passed to this function. It is <br>    // possible to query Direct3D for the regions of the device <br>    // surface that were rendered to by that execute. The application <br>    // can then accumulate those rectangles and clear only those <br>    // regions. However this is a very simple sample and so, for <br>    // simplicity, we will just clear the entire device surface and <br>    // z-buffer. Probably not something you wan't to do in a real <br>    // application. <br>    /// <br>d3dRect.lX1 = rSrc.left; <br>d3dRect.lX2 = rSrc.right; <br>d3dRect.lY1 = rSrc.top; <br>d3dRect.lY2 = rSrc.bottom; <br>hResult = lpView-&gt;Clear(1UL, &amp;d3dRect, <br> D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER); <br>if (hResult != D3D_OK) { <br>REPORTERR(hResult); <br>return hResult; <br>} <br> <br> <br>if (lpExtent) { <br>// Calculate exclude region <br>status.dwFlags = D3DCLIPSTATUS_EXTENTS2; <br>status.dwStatus = 0; <br>status.minx = (float)lpExtent-&gt;x1; <br>status.maxx = (float)lpExtent-&gt;x2; <br>status.miny = (float)lpExtent-&gt;y1; <br>status.maxy = (float)lpExtent-&gt;y2; <br>status.minz = 0.0f; <br>status.maxz = 0.0f; <br> <br>hResult = lpDev-&gt;SetClipStatus(&amp;status); <br>if (hResult != D3D_OK) { <br>REPORTERR(hResult); <br>goto lblCLEANUP; <br>} <br>} <br> <br>// Begin Scene <br>// Note:  This is complicated by the need to <br>//  check for lost surfaces and restore <br>hResult = lpDev-&gt;BeginScene(); <br>if (hResult != D3D_OK) { <br>while (hResult == DDERR_SURFACELOST) { <br>// Restore surface <br>while (hResult == DDERR_SURFACELOST) { <br>hResult = lpd3dWindow-&gt;Restore(); <br>} <br> <br>// Try BeginScene again <br>hResult = lpDev-&gt;BeginScene(); <br>} <br> <br>if (hResult != D3D_OK) { <br>REPORTERR(hResult); <br>return hResult; <br>} <br>} <br> <br>    // Turn off specular highlights <br>        hResult = lpDev-&gt;SetRenderState(D3DRENDERSTATE_SPECULARENABLE, FALSE); <br>if (hResult != D3D_OK) { <br>        REPORTERR(hResult); <br>goto lblCLEANUP; <br>} <br> <br>    // Turn on Z-buffering <br>hResult = lpDev-&gt;SetRenderState(D3DRENDERSTATE_ZENABLE, 1); <br>if (hResult != D3D_OK) { <br>        REPORTERR(hResult); <br>goto lblCLEANUP; <br>} <br> <br>// null out the texture handle <br>    hResult = lpDev-&gt;SetRenderState(D3DRENDERSTATE_TEXTUREHANDLE, 0); <br>    if (hResult != D3D_OK) { <br>        REPORTERR(hResult); <br>goto lblCLEANUP; <br>} <br> <br>// turn on dithering <br>    hResult = lpDev-&gt;SetRenderState(D3DRENDERSTATE_DITHERENABLE, TRUE); <br>    if (hResult != D3D_OK) { <br>        REPORTERR(hResult); <br>goto lblCLEANUP; <br>} <br> <br>// turn on some ambient light <br>    hResult = lpDev-&gt;SetLightState(D3DLIGHTSTATE_AMBIENT, RGBA_MAKE(10, 10, 10, 10)); <br>    if (hResult != D3D_OK) { <br>        REPORTERR(hResult); <br>goto lblCLEANUP; <br>} <br> <br>// set the view and projection matrices <br> <br>tic += 0.01f; <br> <br>view = ViewMatrix(from, at, up); <br>proj = ProjectionMatrix(1.0f, 500.0f, pi/4.0f); <br> <br>hResult = lpDev-&gt;SetTransform(D3DTRANSFORMSTATE_VIEW, &amp;view); <br>    if (hResult != D3D_OK) { <br>        REPORTERR(hResult); <br>goto lblCLEANUP; <br>} <br> <br>hResult = lpDev-&gt;SetTransform(D3DTRANSFORMSTATE_PROJECTION, &amp;proj); <br>    if (hResult != D3D_OK) { <br>        REPORTERR(hResult); <br>goto lblCLEANUP; <br>} <br> <br>// draw ground grid <br>lpGridMat-&gt;SetAsCurrent(lpDev); <br>hResult = DrawPattern(lpDev); <br>    if (hResult != D3D_OK) { <br>        REPORTERR(hResult); <br>goto lblCLEANUP; <br>} <br> <br> <br>UpdateFlock(flock); <br> <br>at = D3DVECTOR(0.0f); <br>// draw the boids <br>for (i=0; i&lt;flock.num_boids; i++) { <br>D3DVECTORstep; <br> <br>// build the world matrix for the boid <br>world = MatrixMult(MatrixMult(RotateYMatrix(flock.boids[i].yaw), RotateXMatrix(flock.boids[i].pitch)), RotateZMatrix(flock.boids[i].roll)); <br> <br>// first translate into place, then set orientation, then scale (if needed) <br>world = TranslateMatrix(flock.boids[i].loc); <br>world = MatrixMult(world, MatrixMult(MatrixMult(RotateYMatrix(flock.boids[i].yaw),  <br>RotateXMatrix(flock.boids[i].pitch)), RotateZMatrix(flock.boids[i].roll))); <br> <br>// apply the world matrix <br>hResult = lpDev-&gt;SetTransform(D3DTRANSFORMSTATE_WORLD, &amp;world); <br>if (hResult != D3D_OK) { <br>REPORTERR(hResult); <br>goto lblCLEANUP; <br>} <br> <br>// display the boid <br>lpBoidMat-&gt;SetDiffuse(flock.boids[i].color); <br>lpBoidMat-&gt;SetAsCurrent(lpDev); <br>hResult = Drawboid(lpDev); <br>if (hResult != D3D_OK) { <br>REPORTERR(hResult); <br>goto lblCLEANUP; <br>} <br> <br>flock.boids[i].dir[0] = world(2, 0); <br>flock.boids[i].dir[1] = world(2, 1); <br>flock.boids[i].dir[2] = world(2, 2); <br> <br>flock.boids[i].loc += flock.boids[i].dir * flock.boids[i].speed; <br> <br>at += flock.boids[i].loc; <br>} <br>// find the center of the flock and look there for the next frame <br>at /= (float)(flock.num_boids); <br>from = at + D3DVECTOR(20.0f * (float)sin (tic* 0.223f),  <br>                   16.0f + 15.0f * (float)sin (tic * 0.33f),  <br>   20.0f * (float)cos (tic * 0.31f)); <br> <br>flock.goal = D3DVECTOR(105.0f * (float)sin (tic * 0.1f),  <br>10.0f,  <br>105.0f * (float)cos (tic * 0.1f)); <br> <br> <br> <br>// Finally, draw obstacles last since they're transparent. <br>// Set renderstates to support blending such that the texture <br>// color is added over the background color.  Also turn Z-write <br>// off so when two spheres line up you can always see them both. <br>    if (lpDev-&gt;SetRenderState(D3DRENDERSTATE_BLENDENABLE, TRUE) != D3D_OK) <br>        return FALSE; <br>   if (lpDev-&gt;SetRenderState(D3DRENDERSTATE_SRCBLEND, D3DBLEND_SRCCOLOR) != D3D_OK) <br>        return FALSE; <br>    if (lpDev-&gt;SetRenderState(D3DRENDERSTATE_DESTBLEND, D3DBLEND_ONE) != D3D_OK) <br>return FALSE; <br>    if (lpDev-&gt;SetRenderState(D3DRENDERSTATE_ZWRITEENABLE, FALSE) != D3D_OK) <br>return FALSE; <br>// make sure the texture wraps correctly <br>    if (lpDev-&gt;SetRenderState(D3DRENDERSTATE_WRAPU, TRUE) != D3D_OK) <br>return FALSE; <br> <br>lpSphereMat-&gt;SetAsCurrent(lpDev); <br>for (i=0; i&lt;flock.num_obs; i++) { <br>world = MatrixMult(TranslateMatrix(flock.obs[i].loc), MatrixMult(RotateYMatrix(-tic*pi), ScaleMatrix (flock.obs[i].radius))); <br> <br>hResult = lpDev-&gt;SetTransform(D3DTRANSFORMSTATE_WORLD, &amp;world); <br>if (hResult != D3D_OK) { <br>REPORTERR(hResult); <br>return hResult; <br>} <br> <br>hResult = DrawSphere(lpDev); <br>if (hResult != D3D_OK) { <br>REPORTERR(hResult); <br>goto lblCLEANUP; <br>} <br>} <br> <br>// set renderstates back to default <br>    if (lpDev-&gt;SetRenderState(D3DRENDERSTATE_BLENDENABLE, FALSE) != D3D_OK) <br>        return FALSE; <br>    if (lpDev-&gt;SetRenderState(D3DRENDERSTATE_SRCBLEND, D3DBLEND_ONE) != D3D_OK) <br>        return FALSE; <br>    if (lpDev-&gt;SetRenderState(D3DRENDERSTATE_DESTBLEND, D3DBLEND_ZERO) != D3D_OK) <br>return FALSE; <br>    if (lpDev-&gt;SetRenderState(D3DRENDERSTATE_ZWRITEENABLE, TRUE) != D3D_OK) <br>return FALSE; <br> <br> <br>lblCLEANUP:  <br>// End Scene <br>// Note:  This is complicated by the need to restore lost surfaces <br>    hResult = lpDev-&gt;EndScene(); <br>if (hResult != D3D_OK) { <br>while (hResult == DDERR_SURFACELOST) { <br>// Restore surface <br>while (hResult == DDERR_SURFACELOST) { <br>hResult = lpd3dWindow-&gt;Restore(); <br>} <br> <br>// Try EndScene again <br>hResult = lpDev-&gt;EndScene(); <br>} <br> <br>if (hResult != D3D_OK) { <br>REPORTERR(hResult); <br>return hResult; <br>} <br>} <br> <br>if (lpExtent) { <br>hResult = lpDev-&gt;GetClipStatus(&amp;status); <br>if (hResult != D3D_OK) { <br>REPORTERR(hResult); <br>return hResult; <br>} <br> <br>if (status.dwFlags &amp; D3DCLIPSTATUS_EXTENTS2) { <br>lpExtent-&gt;x1 = (long) floor((double)status.minx); <br>lpExtent-&gt;x2 = (long) ceil((double)status.maxx); <br>lpExtent-&gt;y1 = (long) floor((double)status.miny); <br>lpExtent-&gt;y2 = (long) ceil((double)status.maxy); <br>} <br>} <br> <br>return hResult; <br>} // End D3DScene::Render <br> <br> <br>   <br>/* <br>**---------------------------------------------------------------------------- <br>** Name:        D3DScene::Restore <br>** Purpose:     Restore any scene specific surfaces that might have been <br>**lost on a DDERR_LOSTSURFACE message <br>**---------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DScene::Restore(void) <br>{ <br>// Nothing to do for now <br> <br>// Success <br>return D3D_OK; <br>} // End D3DScene::Restore <br> <br> <br>   <br>/* <br>**---------------------------------------------------------------------------- <br>** Name:        D3DScene::AttachViewport <br>** Purpose: <br>**---------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT <br>D3DScene::AttachViewport(void) <br>{ <br>LPDIRECT3D2lpD3D; <br>LPDIRECT3DDEVICE2lpDev; <br>LPDIRECT3DVIEWPORT2   lpView; <br> <br>// Check Initialization <br>if ((! lpd3dWindow) || (! lpd3dWindow-&gt;isValid())) { <br>// Error, <br>REPORTERR(DDERR_GENERIC); <br>return DDERR_GENERIC; <br>} <br> <br>lpD3D  = lpd3dWindow-&gt;lpD3D; <br>lpDev  = lpd3dWindow-&gt;lpd3dDevice; <br>lpView = lpd3dWindow-&gt;lpd3dViewport; <br> <br>if ((! lpD3D) || (! lpDev) || (! lpView)) { <br>REPORTERR(DDERR_GENERIC); <br>return DDERR_GENERIC; <br>} <br> <br>// Create and set up the background material <br>lpBackgroundMat = new Material(lpD3D, lpDev); <br>lpBackgroundMat-&gt;SetDiffuse(D3DVECTOR(0.0f, 0.05f, 0.1f)); <br>lpBackgroundMat-&gt;SetAsBackground(lpView); <br> <br>// Create and set up the grid material, since we're using LVertices we want <br>// to make sure that ramp mode can actually get the right colors so we set <br>// the emissive value to the color we want and choose a small ramp size <br>lpGridMat = new Material(lpD3D, lpDev); <br>lpGridMat-&gt;SetEmissive(grid_color); <br>lpGridMat-&gt;SetRampSize(2); <br> <br>// Create and set up the sphere material <br>lpSphereMat = new Material(lpD3D, lpDev); <br>lpSphereMat-&gt;SetDiffuse(D3DVECTOR(1.0f)); <br> <br>// Create the sphere texture and attatch it to the material <br>SphereTex.Load(lpDev, "DX5_logo"); <br>lpSphereMat-&gt;SetTextureHandle(SphereTex.GetHandle()); <br> <br>// Create and set up the boid material <br>// note that we'll just change the color for each boid we render <br>lpBoidMat = new Material(lpD3D, lpDev); <br>lpBoidMat-&gt;SetDiffuse(D3DVECTOR(1.0f)); <br> <br>// set up transform matrices <br>D3DVECTORfrom(0.0f, 0.0f, -100.0f); <br>D3DVECTORat(0.0f, 0.0f, 0.0f); <br>D3DVECTORup(0.0f, 1.0f, 0.0f); <br> <br>view = ViewMatrix(from, at, up); <br>proj = ProjectionMatrix(1.0f, 400.0f, pi/4.0f); <br>world = IdentityMatrix(); <br> <br>// create 2 lights <br>D3DVECTORcolor(1.0f, 1.0f, 1.0f); <br>D3DVECTORdirection(-0.5f, -1.0f, -0.3f); <br> <br>lpLight1 = new DirectionalLight(lpD3D, color, Normalize(direction)); <br>if (lpLight1) { <br>lpLight1-&gt;AddToViewport(lpView); <br>} <br> <br>lpLight2 = new DirectionalLight(lpD3D, color/2.0f, -Normalize(direction)); <br>if (lpLight2) { <br>lpLight2-&gt;AddToViewport(lpView); <br>} <br> <br>// Success <br>    return D3D_OK; <br>} // End D3DScene::AttachViewport <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       D3DScene::DetachViewport <br>**  Purpose:Cleanup Viewport <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>HRESULT D3DScene::DetachViewport(void) <br>{ <br>LPDIRECT3DVIEWPORT2 lpViewport = NULL; </code></pre>
<p>
</p>
<pre><code><br>if (lpd3dWindow) { <br>lpViewport = lpd3dWindow-&gt;GetViewport(); <br>} <br> <br>// Cleanup lights <br>if (lpLight1) { <br>if (lpViewport) { <br>lpLight1-&gt;RemoveFromViewport(lpViewport); <br>} <br> <br>    delete lpLight1; <br>lpLight1 = NULL; <br>} <br> <br>if (lpLight2) { <br>if (lpViewport) { <br>lpLight2-&gt;RemoveFromViewport(lpViewport); <br>} <br> <br>delete lpLight2; <br>lpLight2 = NULL; <br>} <br> <br>// Cleanup Materials <br>delete lpBackgroundMat; <br>delete lpGridMat; <br>delete lpSphereMat; <br>delete lpBoidMat; <br> <br>lpBackgroundMat = NULL; <br>lpGridMat = NULL; <br>lpSphereMat = NULL; <br>lpBoidMat = NULL; <br> <br>SphereTex.Release(); <br> <br>// Success <br>return D3D_OK; <br>} // End D3DScene::DetachViewport <br> <br> <br>   <br>/* <br>**---------------------------------------------------------------------------- <br>** End of File <br>**---------------------------------------------------------------------------- <br>*/ <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
