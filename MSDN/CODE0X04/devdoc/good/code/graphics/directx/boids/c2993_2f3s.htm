<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WINPROC.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2998"></a>WINPROC.CPP</h2>
<pre><code>/* <br>**----------------------------------------------------------------------------- <br>**  File:       WinProc.cpp <br>**  Purpose:    A sample windows proc for supporting D3D. <br>**  Notes: <br>** <br>**  Copyright (c) 1995 - 1997 by Microsoft, all rights reserved. <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**Include Files <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>#include "WinProc.h" <br>#include "WinMain.h" <br>#include "Debug.h" <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**Local Typedefs <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>typedef struct tagChangeDDInfo { <br>DDDrvInfo  * lpDrvOrig;// Original Driver <br>DDDrvInfo  * lpDrvNew;// New Driver (user choice) <br> <br>D3DDevInfo * lpDevOrig;// Original D3D device <br>D3DDevInfo * lpDevNew;// New D3D device (user choice) <br> <br>DDModeInfo * lpModeOrig;// Orignal Mode <br>DDModeInfo * lpModeNew;// New Mode (user choice) <br>} ChangeDDInfo; <br>typedef ChangeDDInfo * LPChangeDDInfo; <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**Local Variables <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>BOOL g_fMinimized = FALSE; <br>BOOL g_fMaximized = FALSE; <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**Local function prototypes <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>// About Message proc <br>BOOL FAR PASCAL AboutBoxProc (HWND hWnd, UINT uiMsg, <br>  WPARAM wParam, LPARAM lParam); <br> <br>// Change Dialog <br>BOOL DlgDriversInit (HWND hDlg); <br>BOOL DlgDevicesInit (HWND hDlg); <br>BOOL DlgModesInit (HWND hDlg); <br> <br>int _cdecl CompareModes (const void* element1, const void* element2); <br> <br>LPDDDrvInfo  DlgGetDriver (HWND hDlg); <br>LPD3DDevInfo DlgGetDevice (HWND hDlg); <br>LPDDModeInfo DlgGetMode (HWND hDlg); <br> <br>BOOL FAR PASCAL ChangeDriverProc (HWND hWnd, UINT uiMsg, <br>      WPARAM wParam, LPARAM lParam); <br>void OnChangeDriver (HWND hWindow, int idDialog); <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**Functions <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       D3DWindowProc <br>**  Purpose:    handles windows messages for D3DWindow's <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LRESULT CALLBACK D3DWindowProc ( <br>    HWND    hWindow, <br>    UINT    uiMsg, <br>    WPARAM  wParam, <br>    LPARAM  lParam) <br>{ <br>LONG lResult; <br> <br>    // <br>    // Windows messages <br>    // <br>    switch (uiMsg) <br>    { <br>case WM_ACTIVATE: <br>return OnActivate (hWindow, wParam, lParam); <br> <br>    case WM_ACTIVATEAPP: <br>        return OnActivateApp (hWindow, wParam, lParam); <br> <br>case WM_CLOSE: <br>return OnClose (hWindow); <br> <br>    case WM_COMMAND: <br>        return OnCommand (hWindow, wParam, lParam); <br> <br>    case WM_CREATE: <br>return OnCreate (hWindow); <br> <br>    case WM_DESTROY: <br>return OnDestroy (hWindow); <br> <br>case WM_DISPLAYCHANGE: <br>return OnDisplayChange (hWindow); <br> <br>    case WM_ERASEBKGND: <br>return OnEraseBackground (hWindow, wParam, lParam); <br> <br>case WM_ENTERMENULOOP: <br>return OnEnterMenuLoop (hWindow, wParam, lParam); <br> <br>case WM_EXITMENULOOP: <br>return OnExitMenuLoop (hWindow, wParam, lParam); <br> <br>    case WM_GETMINMAXINFO: <br>return OnGetMinMaxInfo (hWindow, wParam, lParam); <br> <br>    case WM_MOVE: <br>        return OnMove (hWindow, wParam, lParam); <br> <br>    case WM_NCPAINT: <br>return OnNCPaint (hWindow, wParam, lParam); <br> <br>    case WM_PAINT: <br>    { <br>        HDC         hdc; <br>        PAINTSTRUCT ps; <br> <br>        hdc = BeginPaint (hWindow, &amp;ps);             <br>        lResult = OnPaint (hWindow, hdc, &amp;ps); <br>        EndPaint (hWindow, &amp;ps); <br>    } <br>        return lResult; <br> <br>case WM_PALETTECHANGED: <br>// Note:  We need to support this <br>break; <br> <br>case WM_QUERYNEWPALETTE: <br>// Note:  We need to support this <br>break; <br> <br>    case WM_SETCURSOR: <br>return OnSetCursor (hWindow, wParam, lParam); <br> <br>    case WM_SIZE: <br>        return OnSize (hWindow, wParam, lParam); <br> <br>case WM_SYSCOMMAND: <br>return OnSysCommand (hWindow, wParam, lParam); <br>      <br>case WM_WINDOWPOSCHANGING: <br>return OnWindowPosChanging (hWindow, wParam, lParam); <br> <br> // <br>     // D3D Window Query/Notification messages <br>     //   <br>    case D3DWIN_GET_VALID:       // Get valid size <br>{ <br>LPD3DWindow lpd3dWindow; <br> <br>//Get D3DWindow pointer <br>lpd3dWindow =  (LPD3DWindow)GetWindowLong (hWindow, GWL_USERDATA); <br>        if (! lpd3dWindow) <br>            return FALSE; <br>        return lpd3dWindow-&gt;isValid(); <br>} <br> <br>    case D3DWIN_GET_POINTER: <br>//Get D3DWindow pointer <br>return (LRESULT)GetWindowLong (hWindow, GWL_USERDATA); <br> <br>    case D3DWIN_GET_SURFACE: <br>{ <br>LPD3DWindow lpd3dWindow; <br> <br>//Get D3DWindow pointer <br>lpd3dWindow =  (LPD3DWindow)(void *)GetWindowLong (hWindow, GWL_USERDATA); <br>        if (! lpd3dWindow) <br>            return NULL; <br>        return (LPARAM)(lpd3dWindow-&gt;GetRender ()); <br>} <br> <br>case D3DWIN_INIT: <br>return OnD3DInit (hWindow, (LPD3DWindow) lParam); <br> <br>case D3DWIN_FINI: <br>return OnD3DFini (hWindow, (LPD3DWindow) lParam); <br> <br>case D3DWIN_CHANGED_DRIVER: <br>return OnD3DChangeDriver (hWindow); <br> <br>case D3DWIN_CHANGED_MODE: <br>return OnD3DChangeMode (hWindow); <br> <br>case D3DWIN_CHANGED_DEVICE: <br>return OnD3DChangeDevice (hWindow); <br> <br>    } // End Switch <br> <br>   // Do Default window behavior <br>   return DefWindowProc (hWindow, uiMsg, wParam, lParam); <br>} // End D3DWindowProc <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       AboutBoxProc <br>**  Purpose:    handles messages for About Dialog box <br>**----------------------------------------------------------------------------- <br>*/ <br>BOOL <br>FAR PASCAL AboutBoxProc (HWND hWnd, UINT uiMsg, WPARAM wParam, LPARAM lParam) <br>{ <br>switch (uiMsg) <br>{ <br>case WM_COMMAND: <br>if (LOWORD(wParam) == IDOK) <br>EndDialog (hWnd, TRUE); <br>break; <br> <br>    case WM_INITDIALOG: <br>return TRUE; <br>} <br>return FALSE; <br>} // End AboutBoxProc  <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       OnAbout <br>**  Purpose:    Display About Dialog <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LRESULT OnAbout (HWND hWindow) <br>{ <br>HINSTANCE hInstance; <br> <br>if ((! hWindow) || (! IsWindow (hWindow))) <br>return 0L; <br> <br>hInstance = (HINSTANCE) GetWindowLong (hWindow, GWL_HINSTANCE); <br>if (! hInstance) <br>return 0L; <br> <br>    // Pause App <br>    OnPause (hWindow, TRUE); <br> <br>    // Do About Dialog here <br>    DialogBox (hInstance, MAKEINTRESOURCE (IDD_ABOUT), hWindow, (DLGPROC)AboutBoxProc); <br> <br>    // UnPause app <br>    OnPause (hWindow, FALSE); <br> <br>    return 0L; <br>} // End OnAbout <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       OnActivate <br>**  Purpose:    handles WM_ACTIVATE message <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LRESULT OnActivate (HWND hWindow, WPARAM wParam, LPARAM lParam) <br>{ <br>BOOL fActive= (BOOL) LOWORD(wParam); // activation flag  <br>BOOL fMinimized= (BOOL) HIWORD(wParam); // minimized flag  <br>HWND hwndPrevious= (HWND) lParam; // window handl <br> <br>// Do Default Behavior <br>return DefWindowProc (hWindow, WM_ACTIVATE, wParam, lParam); <br>} // End OnActivate <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       OnActivateApp <br>**  Purpose:    handles WM_ACTIVATEAPP message <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LRESULT OnActivateApp (HWND hWindow, WPARAM wParam, LPARAM lParam) <br>{ <br>BOOLfActive= (BOOL) wParam;// Activate or deactivate <br>DWORDdwThreadID= (DWORD) lParam;// thread identifier  <br> <br>// Get D3D Window pointer <br>LPD3DWindow lpd3dWindow =  (LPD3DWindow)GetWindowLong (hWindow, GWL_USERDATA); <br> <br>    if (fActive) <br>    { <br>// Reactivating - Realize current palette <br>if (lpd3dWindow) <br>{ <br>lpd3dWindow-&gt;turnActiveOn (); <br>lpd3dWindow-&gt;Restore (); <br>lpd3dWindow-&gt;RealizePalette (); <br>} <br>    } <br>    else <br>    { <br>        // <br>        //  If we have been deactivated invalidate <br>        //  to show the paused display. <br>        // <br>if (lpd3dWindow) <br>{ <br>lpd3dWindow-&gt;turnActiveOff (); <br>        InvalidateRect (hWindow, NULL, FALSE); <br>} <br> <br>    } <br> <br>    // Do default behavior <br>return DefWindowProc (hWindow, WM_ACTIVATEAPP, wParam, lParam); <br>} // End OnActivateApp <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       OnClose <br>**  Purpose:    handles WM_CLOSE message <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LRESULT OnClose (HWND hWindow) <br>{ <br>// Close down window <br>    DestroyWindow (hWindow); <br>    return 0L; <br>} // End OnClose <br> <br>   <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       OnCommand <br>**  Purpose:    handles WM_COMMAND messages <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LRESULT OnCommand (HWND hWindow, WPARAM wParam, LPARAM lParam) <br>{    <br>HWND  hControl= (HWND)lParam; <br>    DWORD dwNotify= (DWORD)HIWORD(wParam); <br>    DWORD dwID      = (DWORD)LOWORD(wParam); <br> <br>    if (hControl) <br>    { <br>// <br>    // Handle messages from controls here <br>        // <br>    } <br>    else  <br>{ <br>//  <br>// Handle Menu messages here <br>// <br>switch (dwID) <br>{ <br>case IDM_EXIT: <br>// Close down app <br>SendMessage (hWindow, WM_CLOSE, 0, 0); <br>return 0; <br> <br>case IDM_ABOUT: <br>// Bring up the "About" dialog <br>OnAbout (hWindow); <br>break; <br> <br>case IDM_CHANGE_DRIVERS: <br>// Bring up the "Change Driver" dialog <br>OnChangeDriver (hWindow, IDD_CHANGE_DRIVER); <br>break; <br> <br>case IDM_CHANGE_DEVICES: <br>// Bring up the "Change Device" dialog <br>OnChangeDriver (hWindow, IDD_CHANGE_DEVICE); <br>break; <br> <br>case IDM_CHANGE_MODES: <br>// Bring up the "Change Mode" dialog <br>OnChangeDriver (hWindow, IDD_CHANGE_MODE); <br>break; <br> <br>default: <br>// Unknown Menu Command <br>break; <br>} <br>} <br> <br>    // Let Default Window Proc handle it for us. <br>    return DefWindowProc (hWindow, WM_COMMAND, wParam, lParam); <br>} // End OnCommand <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       OnCreate <br>**  Purpose:    Handles WM_CREATE message <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LRESULT OnCreate (HWND hWindow) <br>{ <br>    // Success <br>    return 0L; <br>} // End OnCreate <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       OnDestroy <br>**  Purpose:    Handles WM_DESTROY message <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LRESULT OnDestroy (HWND hWindow) <br>{ <br>    LPD3DWindow lpd3dWindow; <br> <br>    //Delete associated D3DWindow from this window <br>lpd3dWindow =  (LPD3DWindow)GetWindowLong (hWindow, 0L); <br>if (lpd3dWindow) <br>lpd3dWindow-&gt;Fini (); <br>SetWindowLong (hWindow, GWL_USERDATA, 0L); <br> <br>    // Tell windows to QUIT! <br>    PostQuitMessage (0); <br>    return 0L; <br>} // End OnDestroy <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       OnDisplayChange <br>**  Purpose:    Handles WM_DISPLAYCHANGE message <br>**  Notes:This means the desktop mode has changed underneath us <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LRESULT OnDisplayChange (HWND hWindow) <br>{ <br>HRESULThResult; <br>    LPD3DWindow lpd3dWindow; <br> <br>// Get D3D window pointer <br>lpd3dWindow =  (LPD3DWindow)GetWindowLong (hWindow, GWL_USERDATA); <br>if (! lpd3dWindow) <br>return 0L; <br> <br>// Change Primary surface to new desktop <br>hResult = lpd3dWindow-&gt;ChangeDesktop (); <br>if (FAILED (hResult)) <br>return 0L; <br> <br>// Success <br>    return 0L; <br>} // End OnDestroy <br> <br>   <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       OnEraseBackground <br>**  Purpose:    Handles WM_ERASEBKGND message <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LRESULT OnEraseBackground (HWND hWindow, WPARAM wParam, LPARAM lParam) <br>{ <br>    LPD3DWindow lpd3dWindow; <br> <br>// Get D3D window pointer <br>lpd3dWindow =  (LPD3DWindow)GetWindowLong (hWindow, GWL_USERDATA); <br>if ((lpd3dWindow) &amp;&amp; <br>    (lpd3dWindow-&gt;isValid ()) &amp;&amp; <br>(lpd3dWindow-&gt;isActive ()) &amp;&amp; <br>(! lpd3dWindow-&gt;isPaused ())) <br>{ <br>// Tell system we erased background, even though we didn't <br>// It will soon get covered up by a frame from RenderScene <br>return 1L; <br>} <br> <br>// Do the Default behavior (erase the background) <br>return DefWindowProc (hWindow, WM_ERASEBKGND, wParam, lParam); <br>} // End OnEraseBackground <br>   <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       OnEnterMenuLoop <br>**  Purpose:    Handles WM_ENTERMENULOOP messages <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LRESULT OnEnterMenuLoop (HWND hWindow, WPARAM wParam, LPARAM lParam) <br>{ <br>    LPD3DWindow lpd3dWindow; <br> <br>// Get D3D window pointer <br>lpd3dWindow =  (LPD3DWindow)GetWindowLong (hWindow, GWL_USERDATA); <br>if ((lpd3dWindow) &amp;&amp; (lpd3dWindow-&gt;isValid ())) <br>{ <br>// pause app (go into GDI drawing mode) <br>lpd3dWindow-&gt;Pause (TRUE); <br> <br>// Restore cursor  <br>SetCursor (g_hMainCursor); <br>} <br> <br>// Do the Default behavior  <br>return DefWindowProc (hWindow, WM_ENTERMENULOOP, wParam, lParam); <br>} // End OnEnterMenuLoop <br>   <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       OnExitMenuLoop <br>**  Purpose:    Handles WM_EXITMENULOOP messages <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LRESULT OnExitMenuLoop (HWND hWindow, WPARAM wParam, LPARAM lParam) <br>{ <br>    LPD3DWindow lpd3dWindow; <br> <br>// Get D3D window pointer <br>lpd3dWindow =  (LPD3DWindow)GetWindowLong (hWindow, GWL_USERDATA); <br>if ((lpd3dWindow) &amp;&amp; (lpd3dWindow-&gt;isValid ())) <br>{ <br>// Get Rid of cursor again <br>SetCursor (NULL); <br> <br>// Unpause app (return from GDI drawing) <br>lpd3dWindow-&gt;Pause (FALSE); <br>} <br> <br>// Do the Default behavior  <br>return DefWindowProc (hWindow, WM_EXITMENULOOP, wParam, lParam); <br>} // End OnExitMenuLoop <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       OnGetMinMaxInfo <br>**  Purpose:    Handles WM_GETMINMAXINFO message <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LRESULT OnGetMinMaxInfo (HWND hWindow, WPARAM wParam, LPARAM lParam) <br>{ <br>LPMINMAXINFOlpmmi; <br>LPD3DWindowlpd3dWindow; <br>RECTrSurf; <br>DWORDdwWidth; <br>DWORDdwHeight; <br> <br>lpmmi = (LPMINMAXINFO)lParam; <br> <br>// Get D3D window pointer <br>lpd3dWindow =  (LPD3DWindow)GetWindowLong (hWindow, GWL_USERDATA); <br>if ((lpd3dWindow) &amp;&amp;  <br>(lpd3dWindow-&gt;isFullscreen ()) &amp;&amp; <br>(! g_fMinimized)) <br>{ <br>// Get Width and height of current surface <br>lpd3dWindow-&gt;GetSurfaceRect (rSurf); <br> <br>dwWidth  = abs (rSurf.right - rSurf.left); <br>dwHeight = abs (rSurf.bottom - rSurf.top); <br> <br>// Prevent changes in size <br>lpmmi-&gt;ptMaxTrackSize.x = dwWidth; <br>lpmmi-&gt;ptMaxTrackSize.y = dwHeight; <br>lpmmi-&gt;ptMinTrackSize.x = dwWidth; <br>lpmmi-&gt;ptMinTrackSize.y = dwHeight; <br> <br>return 0L; <br>} <br> <br>return DefWindowProc (hWindow, WM_GETMINMAXINFO, wParam, lParam); <br>} // End OnGetMinMaxInfo <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       OnIdle <br>**  Purpose:    Animate while system is idle <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>void OnIdle (HWND hWindow) <br>{ <br>    HRESULT hResult; <br>    LPD3DWindow  lpd3dWindow; <br> <br>// Get D3D window pointer <br>lpd3dWindow =  (LPD3DWindow)GetWindowLong (hWindow, GWL_USERDATA); <br>if (! lpd3dWindow) <br>return; <br> <br>    // <br>    // Only animate if we are the foreground app, we aren't suspended <br>    // and we have completed initialization and we aren't minimized <br>    // <br>if ((! lpd3dWindow-&gt;isActive ()) ||  <br>(lpd3dWindow-&gt;isPaused ()) || <br>(! lpd3dWindow-&gt;isValid ()) || <br>(g_fMinimized)) <br>return; <br> <br>    hResult = lpd3dWindow-&gt;DrawFrame (); <br>    if (FAILED (hResult)) <br>return; <br>} // End OnIdle <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       OnMove <br>**  Purpose:    handles WM_MOVE message <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LRESULT OnMove (HWND hWindow, WPARAM wParam, LPARAM lParam) <br>{ <br>// We don't support moving Full-screen windows <br> <br>    // Do default behavior <br>    return DefWindowProc (hWindow, WM_MOVE, wParam, lParam); <br>} // End OnMove <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       OnNCPaint <br>**  Purpose:    Handles WM_NCPaint message <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LRESULT OnNCPaint (HWND hWindow, WPARAM wParam, LPARAM lParam) <br>{ <br>    LPD3DWindow lpd3dWindow; <br> <br>// Get D3D window pointer <br>lpd3dWindow =  (LPD3DWindow)GetWindowLong (hWindow, GWL_USERDATA); <br>if ((lpd3dWindow) &amp;&amp; <br>    (lpd3dWindow-&gt;isValid ()) &amp;&amp; <br>(lpd3dWindow-&gt;isActive ()) &amp;&amp; <br>(! lpd3dWindow-&gt;isPaused ()) &amp;&amp; <br>(! g_fMinimized)) <br>{ <br>// Prevent the system from drawing the NC frame <br>return 0L; <br>} <br> <br>// Do the Default behavior (Draw the NC Frame) <br>return DefWindowProc (hWindow, WM_NCPAINT, wParam, lParam); <br>} // End OnNCPaint <br>   <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       OnPaint <br>**  Purpose:Handles WM_PAINT messages <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LRESULT OnPaint (HWND hWindow, HDC hdc, LPPAINTSTRUCT lpps) <br>{ <br>    HRESULThResult; <br>LPD3DWindow lpd3dWindow; <br> <br>// Get D3D Window pointer <br>lpd3dWindow =  (LPD3DWindow)GetWindowLong (hWindow, GWL_USERDATA); <br> <br>    if (lpd3dWindow &amp;&amp;  <br>lpd3dWindow-&gt;isActive () &amp;&amp;  <br>!lpd3dWindow-&gt;isPaused () &amp;&amp;  <br>lpd3dWindow-&gt;isValid() &amp;&amp; <br>! g_fMinimized) <br>    { <br>        // <br>        // NOTE: DrawFrame() re-renders the scene as well as blitting the <br>        // result to the primary. As all we really want to do here is <br>        // repaint the client area we don't really need to re-render - <br>        // just re-blit. For this simple sample this inefficiency <br>        // doesn't matter but for real applications not re-rendering <br>        // may be a useful optimization. <br>        // <br>        hResult = lpd3dWindow-&gt;DrawFrame (); <br>        if (FAILED (hResult)) <br>            return 0L; <br>    } <br>    else <br>    { <br>        // <br>        // Show the suspended image if the D3Dwinow is not yet created, <br>// created, the window is inactive, or paused. <br>        // <br>        PaintPaused (hWindow, hdc); <br>    } <br> <br>    return 0L; <br>} // End OnPaint <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:OnPause <br>**  Purpose:Pause/Unpause app <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>void OnPause (HWND hWindow, BOOL fPause) <br>{ <br>LPD3DWindow lpd3dWindow; <br> <br>// Get D3D Window pointer <br>lpd3dWindow =  (LPD3DWindow)GetWindowLong (hWindow, GWL_USERDATA); <br>if (! lpd3dWindow) <br>return; <br> <br>lpd3dWindow-&gt;Pause (fPause); <br>} // End OnPause <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       OnSetCursor <br>**  Purpose:Handles WM_SETCURSOR messages <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LRESULT OnSetCursor (HWND hWindow, WPARAM wParam, LPARAM lParam) <br>{ <br>    LPD3DWindow  lpd3dWindow; <br> <br>// Get D3D window pointer <br>lpd3dWindow =  (LPD3DWindow)GetWindowLong (hWindow, GWL_USERDATA); <br> <br>// Don't show cursor while in fullscreen <br>if ((lpd3dWindow) &amp;&amp; (lpd3dWindow-&gt;isFullscreen ())) <br>{ <br>if ((lpd3dWindow-&gt;isPaused ()) || <br>(! lpd3dWindow-&gt;isActive ())) <br>{ <br>// Restore cursor <br>SetCursor (g_hMainCursor); <br>} <br>else <br>{ <br>// Get rid of cursor <br>SetCursor (NULL); <br>} <br>return TRUE; <br>} <br> <br>// Do Default behavior <br>return DefWindowProc (hWindow, WM_SETCURSOR, wParam, lParam); <br>} // End OnSetCursor <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       OnSize <br>**  Purpose:Handles WM_SIZE messages <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LRESULT OnSize (HWND hWindow, WPARAM wParam, LPARAM lParam) <br>{ <br>DWORDfwSizeType= (DWORD)wParam; <br>    LPD3DWindowlpd3dWindow =  (LPD3DWindow)GetWindowLong (hWindow, GWL_USERDATA); <br> <br>switch (fwSizeType) <br>{ <br>case SIZE_MAXHIDE: <br>// Message is sent to all pop-up windows when some other window is maximized.  <br>break; <br>  <br>case SIZE_MAXIMIZED: <br>// Window has been maximized.  <br>g_fMaximized = TRUE; <br>g_fMinimized = FALSE; <br>break; <br>  <br>case SIZE_MAXSHOW: <br>// Message is sent to all pop-up windows when some other window has been restored to its former size.  <br>break; <br> <br>case SIZE_MINIMIZED: <br>// Window has been minimized.  <br>g_fMinimized = TRUE; <br>g_fMaximized = FALSE; <br>break; <br>  <br>case SIZE_RESTORED:   <br>// Window has been resized but neither minimized nor maximized  <br>if (g_fMinimized) <br>{ <br>// Restore surfaces <br>if (lpd3dWindow) <br>lpd3dWindow-&gt;Restore (); <br> <br>g_fMaximized = FALSE; <br>g_fMinimized = FALSE; <br>} <br>return 0L; <br>} <br> <br>// Do Default Behavior <br>    return DefWindowProc (hWindow, WM_SIZE, wParam, lParam); <br>} // End OnSize <br> <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       OnSysCommand <br>**  Purpose:Handles WM_SYSCOMMAND messages <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LRESULT OnSysCommand (HWND hWindow, WPARAM wParam, LPARAM lParam) <br>{ <br>// Get D3D window pointer <br>    LPD3DWindowlpd3dWindow =  (LPD3DWindow)GetWindowLong (hWindow, GWL_USERDATA); <br>DWORDuCmdType = wParam;        // Type of system command requested  <br>intxPos = LOWORD(lParam);    // horizontal postion, in screen coordinates  <br>intyPos = HIWORD(lParam);    // vertical postion, in screen coordinates  <br> <br>switch (uCmdType) <br>{ <br>case SC_MAXIMIZE: <br>// Maximizes the window.  <br>g_fMaximized = TRUE; <br>g_fMinimized = FALSE; <br> <br>// Not supported <br>return 0L; <br>  <br>case SC_MINIMIZE: <br>// Minimizes the window. <br>g_fMinimized = TRUE; <br>g_fMaximized = FALSE; <br>break; <br> <br>case SC_MOVE: <br>// Moves the window <br> <br>// Not supported <br>return 0L; <br>   <br>case SC_RESTORE: <br>//Restores the window to its normal position and size.  <br>if (g_fMinimized) <br>{ <br>// Restore app <br>if (lpd3dWindow) <br>lpd3dWindow-&gt;Restore (); <br>} <br> <br>g_fMinimized = FALSE; <br>g_fMaximized = FALSE; <br>break; <br>  <br>case SC_SCREENSAVE: <br>// Executes the screen saver application specified in the [boot] section of the SYSTEM.INI file.  <br>break; <br>  <br>case SC_SIZE: <br>// Sizes the window.  <br> <br>// Not supported <br>return 0L;  <br>} <br> <br>// Do Default Behavior <br>    return DefWindowProc (hWindow, WM_SYSCOMMAND, wParam, lParam); <br>} // End OnSysCommand <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       OnWindowPosChanging <br>**  Purpose:    handles WM_WINDOWPOSCHANGING message <br>**  Notes:     <br>** <br>**1. This is where we protect ourselves against unwanted moving <br>**   and resizing of the window.  (We are fullscreen after all) <br>** <br>**  2. First gotcha:  Changing the Display mode causes the window <br>**   to change size and we want to let that happen.  So we will <br>**   compare the current window size to the current surface size. <br>**   If they don't match we will resize the window to match the surface. <br>**   <br>**  3. Second gotcha.  DirectDraw hooks the window procedure and on <br>**   a deactivate app call trys to minimize the window on our behalf. <br>**   We should allow this to happen!!! <br>**   It can do this by either calling ShowWindow or SetWindowPos <br>** <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LRESULT OnWindowPosChanging (HWND hWindow, WPARAM wParam, LPARAM lParam) <br>{ <br>// We don't support moving Full-screen windows <br>// Get D3D Window pointer <br>LPD3DWindow lpd3dWindow =  (LPD3DWindow)GetWindowLong (hWindow, GWL_USERDATA); <br>if (lpd3dWindow &amp;&amp;  <br>(lpd3dWindow-&gt;isFullscreen ()) &amp;&amp; <br>(! g_fMinimized)) <br>{ <br>LPWINDOWPOS lpwp = (LPWINDOWPOS) lParam; <br> <br>if (lpwp) <br>{ <br>// Let minimize commands fall through <br>// Check for minimize by seeing if window is iconic <br>// this state should already be set by the time <br>// we get this window message <br>if (IsIconic (hWindow)) <br>{ <br>// Looks like we are getting minimized <br>g_fMinimized = TRUE; <br>} <br>else <br>{ <br>RECTrWin, rSurf; <br>DWORDdwWinW, dwWinH; <br>DWORDdwSurfW, dwSurfH; <br> <br>GetWindowRect (hWindow, &amp;rWin); <br>dwWinW = abs (rWin.right - rWin.left); <br>dwWinH = abs (rWin.bottom - rWin.top); <br> <br>lpd3dWindow-&gt;GetSurfaceRect (rSurf); <br>dwSurfW = abs (rSurf.right - rSurf.left); <br>dwSurfH = abs (rSurf.bottom - rSurf.top); <br> <br>// Make sure the surface is some reasonable size <br>if (dwSurfW &lt; 320) <br>dwSurfW = 320; <br>if (dwSurfH &lt; 200) <br>dwSurfH = 200; <br> <br>// Is our window the same size as our surface ?!? <br>if ((dwSurfW != dwWinW) || (dwSurfH != dwWinH)) <br>{ <br>// No, then resize it <br>lpwp-&gt;x = rSurf.left; <br>lpwp-&gt;y = rSurf.top; <br>lpwp-&gt;cx = dwSurfW; <br>lpwp-&gt;cy = dwSurfH; <br> <br>// Force resize <br>lpwp-&gt;flags &amp;= ~(SWP_NOMOVE | SWP_NOSIZE); <br>} <br>else <br>{ <br>// Prevent resizing and moving <br>lpwp-&gt;flags |= (SWP_NOMOVE | SWP_NOSIZE); <br>} <br> <br>// Fall through to default window proc <br>} <br>} <br>} <br> <br>    // Do Default Behavior <br>    return DefWindowProc (hWindow, WM_WINDOWPOSCHANGING, wParam, lParam); <br>} // End OnWindowPosChanging <br> <br>   <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       OnD3DInit <br>**  Purpose:Notification that associated D3D Window object <br>**has successfully initialized <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LRESULT OnD3DInit (HWND hWindow, LPD3DWindow lpd3dWindow) <br>{ <br>if ((! lpd3dWindow) || (! lpd3dWindow-&gt;isValid ())) <br>{ <br>// Error, something went wrong <br>return 0L; <br>} <br> <br>// Save the pointer to the D3D Window object <br>SetWindowLong (hWindow, GWL_USERDATA, (long)(void *)lpd3dWindow); <br> <br>// Make sure we are properly marked as active/inactive <br>HWND hActive = GetActiveWindow (); <br>if (hActive == hWindow) <br>lpd3dWindow-&gt;turnActiveOn (); <br>else <br>lpd3dWindow-&gt;turnActiveOff (); <br> <br>// Success <br>return 0L; <br>} // End OnD3DInit <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       OnD3DFini <br>**  Purpose:Notification that the D3D window object <br>**is cleaning up. <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LRESULT OnD3DFini (HWND hWindow, LPD3DWindow lpd3dWindow) <br>{ <br>// Set our window pointer to NULL <br>// so we don't attempt to misuse it later. <br>SetWindowLong (hWindow, GWL_USERDATA, 0L); <br> <br>// Success <br>return 0L; <br>} // End OnD3DFini <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       OnD3DChangeDriver <br>**  Purpose:Notification that our associated D3D Window object <br>**has changed it's DD Driver. <br>**  Notes:This is a good time to update our Menus <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LRESULT OnD3DChangeDriver (HWND hWindow) <br>{ <br>// Success <br>return 0L; <br>} // End OnD3DChangeDriver <br> <br>   <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       OnD3DChangeMode <br>**  Purpose:Notification that our associated D3D Window object <br>**has changed it's mode. <br>**  Notes:This is a good time to update our Menus <br>**----------------------------------------------------------------------------- </code></pre>
<p>
</p>
<pre><code>*/ <br> <br>LRESULT OnD3DChangeMode (HWND hWindow) <br>{ <br>// Success <br>return 0L; <br>} // End OnD3DChangeMode <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       OnD3DChangeDevice <br>**  Purpose:Notification that our associated D3D Window object <br>**has changed it's D3D device. <br>**  Notes:This is a good time to update our Menus <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LRESULT OnD3DChangeDevice (HWND hWindow) <br>{ <br>// Success <br>return 0L; <br>} // End OnD3DChangeDevice <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       PaintPaused <br>**  Purpose:Paint the window as Paused <br>**  Notes:       <br>** <br>**  1.  We show the paused state by drawing a text string <br>**      in the client area of the window. <br>** <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>void PaintPaused (HWND hWindow, HDC hdc) <br>{ <br>    HPEN     hOldPen; <br>    HBRUSH   hOldBrush; <br>    COLORREF crOldTextColor; <br>    INT      oldMode; <br>    INT      x; <br>    INT      y; <br>    SIZE     size; <br>    RECT     rect; <br>    INT      nStrLen; <br> <br>    // <br>    // Black background. <br>    // <br>    hOldPen   = (HPEN)SelectObject (hdc, GetStockObject (NULL_PEN)); <br>    hOldBrush = (HBRUSH)SelectObject (hdc, GetStockObject (BLACK_BRUSH)); <br> <br>    // <br>    // White text. <br>    // <br>    oldMode = SetBkMode (hdc, TRANSPARENT); <br>    crOldTextColor = SetTextColor (hdc, RGB(255, 255, 255)); <br> <br>    //  <br>    GetClientRect (hWindow, &amp;rect); <br> <br>    // <br>    // Clear the client area. <br>    // <br>    Rectangle (hdc, rect.left, rect.top, rect.right + 1, rect.bottom + 1); <br> <br>    // <br>    // Draw the string centered in the client area. <br>    // <br>    nStrLen = strlen (g_szPaused); <br>    GetTextExtentPoint32 (hdc, g_szPaused, nStrLen, &amp;size); <br>    x = (rect.right  - size.cx) / 2; <br>    y = (rect.bottom - size.cy) / 2; <br>    TextOut (hdc, x, y, g_szPaused, nStrLen); <br> <br>    // Cleanup <br>    SetTextColor (hdc, crOldTextColor); <br>    SetBkMode (hdc, oldMode); <br> <br>    SelectObject (hdc, hOldBrush); <br>    SelectObject (hdc, hOldPen); <br>} // End PaintPaused <br> <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**Dialog Functions <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DlgDriversInit <br>**  Purpose:    Set up Drivers for dialog  <br>**  Notes:Shows list of current Drivers <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>BOOL DlgDriversInit (HWND hDlg) <br>{ <br>LPChangeDDInfolpChange; <br>LPDDDrvInfolpDriver; <br>LPDDDrvInfolpCurr, lpNext; <br>DWORDdwIndex; <br>LPGUIDlpGuidDD; <br> <br>// Check Parameters <br>lpChange = (LPChangeDDInfo)(void *)GetWindowLong (hDlg, DWL_USER); <br>if (! lpChange) <br>return FALSE; <br> <br>lpDriver = lpChange-&gt;lpDrvNew; <br> <br>// Validate Driver <br>if (! lpDriver) <br>lpGuidDD = NULL; <br>else <br>lpGuidDD = lpDriver-&gt;GetGuid (); <br>lpDriver = ValidateDriver (lpGuidDD); <br>if (! lpDriver) <br>return FALSE; <br> <br>// Dump Driver list to Combo Box <br>dwIndex = 0; <br>lpCurr = DDDrvMgr::g_lpDriverRoot; <br>while (lpCurr) <br>{ <br>TCHAR szBuff[80]; <br>DWORD dwNew; <br> <br>lpNext = lpCurr-&gt;lpNext; <br> <br>if (lpCurr-&gt;isPrimary ()) <br>wsprintf (szBuff, TEXT("%s (Primary)"), lpCurr-&gt;szName); <br>else <br>wsprintf (szBuff, TEXT("%s"), lpCurr-&gt;szName); <br> <br>// Add String to Combo Box <br>dwNew = SendDlgItemMessage (hDlg, IDC_DRIVERS, CB_ADDSTRING, 0, (LPARAM)(LPCTSTR)szBuff); <br> <br>// Set up pointer to driver for this item <br>SendDlgItemMessage (hDlg, IDC_DRIVERS, CB_SETITEMDATA, (WPARAM)dwNew, (LPARAM)(void *)lpCurr); <br> <br>// Is it the current Driver <br>if (lpDriver == lpCurr) <br>{ <br>// Set as our current selection <br>SendDlgItemMessage (hDlg, IDC_DRIVERS, CB_SETCURSEL, (WPARAM)dwNew, 0L); <br>} <br> <br>lpCurr = lpNext; <br>} <br> <br>// Success <br>return TRUE; <br>} // End DlgDriversInit <br>     <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DlgDevicesInit <br>**  Purpose:    Set up Devices for dialog  <br>**  Notes:Shows list of current Devices <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>BOOL DlgDevicesInit (HWND hDlg) <br>{ <br>LPChangeDDInfolpChange; <br>LPDDDrvInfolpDriver; <br>LPD3DDevInfolpDevice; <br>LPD3DDevInfolpCurr, lpNext; <br>DWORDdwIndex; <br>LPGUIDlpGuidD3D; <br> <br>// Check Parameters <br>lpChange = (LPChangeDDInfo)(void *)GetWindowLong (hDlg, DWL_USER); <br>if (! lpChange) <br>return FALSE; <br> <br>lpDriver = lpChange-&gt;lpDrvNew; <br>if (! lpDriver) <br>return FALSE; <br> <br>lpDevice = lpChange-&gt;lpDevNew; <br> <br>// Validate Device <br>if (! lpDevice) <br>lpGuidD3D = NULL; <br>else <br>lpGuidD3D = &amp;(lpDevice-&gt;guid); <br>lpDevice = ValidateDevice (lpDriver, lpGuidD3D, NULL); <br>if (! lpDevice) <br>return FALSE; <br> <br>// Dump Device list to Combo Box <br>dwIndex = 0; <br>lpCurr = lpDriver-&gt;lpDeviceRoot; <br>while (lpCurr) <br>{ <br>TCHAR szBuff[80]; <br>DWORD dwNew; <br> <br>lpNext = lpCurr-&gt;lpNext; <br> <br>// Get Device String <br>wsprintf (szBuff, TEXT("%s"), lpCurr-&gt;szName); <br> <br>// Add String to Combo Box <br>dwNew = SendDlgItemMessage (hDlg, IDC_DEVICES, CB_ADDSTRING, 0, (LPARAM)(LPCTSTR)szBuff); <br> <br>// Set up pointer to device for this item <br>SendDlgItemMessage (hDlg, IDC_DEVICES, CB_SETITEMDATA, (WPARAM)dwNew, (LPARAM)(void *)lpCurr); <br> <br>// Is it the current device <br>if (lpDevice == lpCurr) <br>{ <br>// Set as our current selection <br>SendDlgItemMessage (hDlg, IDC_DEVICES, CB_SETCURSEL, (WPARAM)dwNew, 0L); <br>} <br> <br>lpCurr = lpNext; <br>} <br> <br>// Success <br>return TRUE; <br>} // End DlgDevicesInit <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       CompareModes <br>**  Purpose:    Comparision function used with Quick sort  <br>**to get sorted list of modes <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>int _cdecl CompareModes (const void * element1, const void * element2)  <br>{ <br>LPDDModeInfo lpMode1; <br>LPDDModeInfo lpMode2; <br>DWORD w1, h1, bpp1, refresh1; <br>DWORD w2, h2, bpp2, refresh2; <br>int   iCompare = 0; <br> <br>    lpMode1 = *((LPDDModeInfo *)element1); <br>    lpMode2 = *((LPDDModeInfo *)element2); <br> <br>// Handle Null pointers <br>if ((! lpMode1) &amp;&amp; (! lpMode2)) <br>return 0; <br>if ((lpMode1) &amp;&amp; (! lpMode2)) <br>return -1; <br>if ((! lpMode2) &amp;&amp; (lpMode2)) <br>return 1; <br> <br>// Get Mode Data <br>lpMode1-&gt;GetMode (w1, h1, bpp1, refresh1); <br>lpMode2-&gt;GetMode (w2, h2, bpp2, refresh2); <br> <br>// Sort first on BPP then width then height <br>    if (bpp1 &lt; bpp2) <br>iCompare = -1; <br>    else if (bpp1 &gt; bpp2) <br>iCompare = 1; <br>    else if (w1 &lt; w2) <br>iCompare = -1; <br>    else if (w1 &gt; w2) <br>iCompare = 1; <br>    else if (h1 &lt; h2) <br>iCompare = -1; <br>    else if (h1 &gt; h2) <br>iCompare = 1; <br> <br>// Equality <br>    return iCompare; <br>} // End CompareModes <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DlgModesInit <br>**  Purpose:    Set up Modes for dialog  <br>**  Notes:Shows list of current modes, compatible with the current  <br>**device.  This list is displayed in sorted order (bpp, w, h) <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>BOOL DlgModesInit (HWND hDlg) <br>{ <br>LPChangeDDInfolpChange; <br>LPDDDrvInfolpDriver; <br>LPD3DDevInfolpDevice; <br>LPDDModeInfolpModeCurr, lpModeRoot, lpCurr, lpNext; <br>DWORDcModes; <br>DWORDcbSize; <br>DWORDdwIndex; <br>LPDDModeInfo *lpModes; <br> <br>// Check Parameters <br>lpChange = (LPChangeDDInfo)(void *)GetWindowLong (hDlg, DWL_USER); <br>if (! lpChange) <br>return FALSE; <br> <br>lpDriver   = lpChange-&gt;lpDrvNew; <br>lpDevice   = lpChange-&gt;lpDevNew; <br>lpModeCurr = lpChange-&gt;lpModeNew; <br> <br>if (! lpDriver) <br>return FALSE; <br> <br>if (! lpDevice) <br>{ <br>lpDevice = ValidateDevice (lpDriver, NULL, NULL); <br>if (! lpDevice) <br>return FALSE; <br>} <br> <br>lpModeRoot = lpDriver-&gt;lpModeRoot; <br>if (! lpModeRoot) <br>return FALSE; <br> <br>cModes = lpDriver-&gt;countModes (); <br>if (! cModes) <br>return FALSE; <br> <br>if (! lpModeCurr) <br>{ <br>lpModeCurr = ValidateMode (lpDriver, 640, 480, 16, 0, lpDevice); <br>} <br> <br>// Get memory for Mode list <br>cbSize = cModes * sizeof (LPDDModeInfo); <br>lpModes = (LPDDModeInfo *) malloc (cbSize); <br>if (! lpModes) <br>return FALSE; <br> <br>// Create Mode List <br>dwIndex = 0; <br>lpCurr = lpModeRoot; <br>while (lpCurr) <br>{ <br>lpNext = lpCurr-&gt;lpNext; <br> <br>lpModes[dwIndex] = lpCurr; <br> <br>dwIndex++; <br> <br>lpCurr = lpNext; <br>} <br> <br>// Sort Mode list <br>    qsort ((void *)lpModes, (size_t)cModes, sizeof(LPDDModeInfo), CompareModes); <br> <br>// Dump Mode list to Combo Box <br>for (dwIndex = 0; dwIndex &lt; cModes; dwIndex++) <br>{ <br>// Make sure mode is supported by D3D device <br>if ((lpModes[dwIndex]) &amp;&amp;  <br>(lpModes[dwIndex]-&gt;ModeSupported (lpDevice))) <br>{ <br>TCHAR szBuff[80]; <br>DWORD w, h, bpp, refresh; <br>DWORD dwNew; <br> <br>lpModes[dwIndex]-&gt;GetMode (w, h, bpp, refresh); <br> <br>// Set up Mode String <br>if (refresh) <br>wsprintf (szBuff, TEXT("%4d x %4d x %4d (%4d Hz)"),  <br>      w, h, bpp, refresh); <br>else <br>wsprintf (szBuff, TEXT("%4d x %4d x %4d"),  <br>      w, h, bpp); <br> <br>// Add String to Combo Box <br>dwNew = SendDlgItemMessage (hDlg, IDC_MODES, CB_ADDSTRING, 0, (LPARAM)(LPCTSTR)szBuff); <br> <br>// Set up pointer to Mode Info for this item <br>SendDlgItemMessage (hDlg, IDC_MODES, CB_SETITEMDATA, (WPARAM)dwNew, (LPARAM)(void *)lpModes[dwIndex]); <br> <br>// Is it the current Mode  <br>if (lpModeCurr == lpModes[dwIndex]) <br>{ <br>// Set as our current selection <br>SendDlgItemMessage (hDlg, IDC_MODES, CB_SETCURSEL, (WPARAM)dwNew, 0L); <br>} <br>} <br>} <br> <br>// Cleanup Memory <br>free (lpModes); <br>lpModes = NULL; <br> <br>// Success <br>return TRUE; <br>} // End DlgModesInit <br> <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DlgGetDriver <br>**  Purpose:    Get current driver selection <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LPDDDrvInfo DlgGetDriver (HWND hDlg) <br>{ <br>DWORD dwIndex = SendDlgItemMessage (hDlg, IDC_DRIVERS, CB_GETCURSEL, 0, 0); <br>if (dwIndex != CB_ERR) <br>{ <br>// Get pointer to driver <br>LPDDDrvInfo lpDriver = (LPDDDrvInfo) SendDlgItemMessage (hDlg,  <br>       IDC_DRIVERS,  <br> CB_GETITEMDATA,  <br> (WPARAM)dwIndex,  <br> (LPARAM)0); <br>return lpDriver; <br>} <br> <br>// Failure <br>return NULL; <br>} // End DlgGetDriver <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DlgGetDevice <br>**  Purpose:    Get current device selection <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LPD3DDevInfo DlgGetDevice (HWND hDlg) <br>{ <br>DWORD dwIndex = SendDlgItemMessage (hDlg, IDC_DEVICES, CB_GETCURSEL, 0, 0); <br>if (dwIndex != CB_ERR) <br>{ <br>// Get pointer to device <br>LPD3DDevInfo lpDevice = (LPD3DDevInfo) SendDlgItemMessage (hDlg,  <br>         IDC_DEVICES,  <br>   CB_GETITEMDATA,  <br>   (WPARAM)dwIndex,  <br>   (LPARAM)0); <br>return lpDevice; <br>} <br> <br>// Failure <br>return NULL; <br>} // End DlgGetDevice <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       DlgGetMode <br>**  Purpose:    Get current mode selection <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>LPDDModeInfo DlgGetMode (HWND hDlg) <br>{ <br>DWORD dwIndex = SendDlgItemMessage (hDlg, IDC_MODES, CB_GETCURSEL, 0, 0); <br>if (dwIndex != CB_ERR) <br>{ <br>// Get pointer to device <br>LPDDModeInfo lpMode = (LPDDModeInfo) SendDlgItemMessage (hDlg,  <br>         IDC_MODES,  <br> CB_GETITEMDATA,  <br> (WPARAM)dwIndex,  <br> (LPARAM)0); <br>return lpMode; <br>} <br> <br>// Failure <br>return NULL; <br>} // End DlgGetMode <br> <br>   <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       OnChangeDriver <br>**  Purpose:    Allows user to choose a new Driver from dialog <br>**Notes:User can also choose a new device and mode <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>void OnChangeDriver (HWND hWindow, int idDialog) <br>{ <br>HINSTANCEhInstance; <br>intfResult; <br>ChangeDDInfochangeInfo; <br>LPD3DWindowlpd3dWindow; <br> <br>// Get application instance <br>hInstance = (HINSTANCE) GetWindowLong (hWindow, GWL_HINSTANCE); <br>if (! hInstance) <br>return; <br> <br>// Get D3D Window pointer <br>lpd3dWindow =  (LPD3DWindow)GetWindowLong (hWindow, GWL_USERDATA); <br>if (! lpd3dWindow) <br>return; <br> <br>// Setup Change info <br>changeInfo.lpDrvOrig= lpd3dWindow-&gt;GetDriverInfo (); <br>changeInfo.lpDrvNew= changeInfo.lpDrvOrig; <br> <br>changeInfo.lpDevOrig= lpd3dWindow-&gt;GetDeviceInfo (); <br>changeInfo.lpDevNew= changeInfo.lpDevOrig; <br> <br>changeInfo.lpModeOrig= lpd3dWindow-&gt;GetModeInfo (); <br>changeInfo.lpModeNew= changeInfo.lpModeOrig; <br> <br> <br>    // Pause App <br>    OnPause (hWindow, TRUE); <br> <br>    // Do Change Mode Dialog here <br>    fResult = DialogBoxParam (hInstance, MAKEINTRESOURCE (idDialog),  <br>  hWindow, (DLGPROC)ChangeDriverProc, <br>  (LPARAM)(void *)&amp;changeInfo); <br> <br>    // UnPause app <br>    OnPause (hWindow, FALSE); <br> <br>// Did user request a change ?!? <br>if (fResult == TRUE) <br>{ <br>LPGUID lpGuidDD, lpGuidD3D; <br>DWORD w, h, bpp, refresh; <br> <br>if (changeInfo.lpDrvOrig != changeInfo.lpDrvNew) <br>{ <br>if (changeInfo.lpDrvNew) <br>lpGuidDD = changeInfo.lpDrvNew-&gt;GetGuid (); <br>else <br>lpGuidDD = NULL; <br> <br>lpd3dWindow-&gt;ChangeDriver (lpGuidDD, <br>   changeInfo.lpDevNew, <br>   changeInfo.lpModeNew); <br>} <br>else if (changeInfo.lpDevOrig != changeInfo.lpDevNew) <br>{ <br>if (changeInfo.lpDevNew) <br>lpGuidD3D = &amp;(changeInfo.lpDevNew-&gt;guid); <br>else <br>lpGuidD3D = NULL; <br> <br>lpd3dWindow-&gt;ChangeDevice (lpGuidD3D, changeInfo.lpModeNew); <br>} <br>else if (changeInfo.lpModeOrig != changeInfo.lpModeNew) <br>{ <br>changeInfo.lpModeNew-&gt;GetMode (w, h, bpp, refresh); <br>lpd3dWindow-&gt;ChangeMode (w, h, bpp, refresh); <br>} <br>} <br>} // End OnChangeDriver <br>   <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>**  Name:       ChangeDriverProc <br>**  Purpose:    handles messages for Change Driver, <br>**D3D device, and mode dialog boxes <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>BOOL CALLBACK ChangeDriverProc( <br>    HWND hDlg,// handle to dialog box <br>    UINT uiMsg,// message <br>    WPARAM wParam,// first message parameter <br>    LPARAM lParam) // second message parameter <br>{ <br>BOOLfChanged; <br>LPChangeDDInfo  lpChange; <br>LPDDDrvInfolpDriver; <br>LPDDModeInfolpMode; <br>LPD3DDevInfolpDevice; <br> <br>switch (uiMsg) <br>{ <br>case WM_COMMAND: <br>switch (LOWORD(wParam)) <br>{ <br>case IDOK: <br>// Get Change Info <br>lpChange = (LPChangeDDInfo) GetWindowLong (hDlg, DWL_USER); <br>if (! lpChange) <br>EndDialog (hDlg, FALSE); <br> <br>fChanged = FALSE; <br> <br>// Get New Driver <br>lpDriver = DlgGetDriver (hDlg); <br>if ((lpDriver) &amp;&amp; (lpDriver != lpChange-&gt;lpDrvOrig)) <br>{ <br>fChanged = TRUE; <br>lpChange-&gt;lpDrvNew = lpDriver; <br>} <br>else <br>lpChange-&gt;lpDrvNew = lpChange-&gt;lpDrvOrig; <br> <br>// Get New Device <br>lpDevice = DlgGetDevice (hDlg); <br>if ((lpDevice) &amp;&amp; (lpDevice != lpChange-&gt;lpDevOrig)) <br>{ <br>fChanged = TRUE; <br>lpChange-&gt;lpDevNew = lpDevice; <br>} <br>else <br>lpChange-&gt;lpDevNew = lpChange-&gt;lpDevOrig; <br> <br>// Get New Mode <br>lpMode = DlgGetMode (hDlg); <br>if ((lpMode) &amp;&amp; (lpMode != lpChange-&gt;lpModeOrig)) <br>{ <br>fChanged = TRUE; <br>lpChange-&gt;lpModeNew = lpMode; <br>} <br>else <br>lpChange-&gt;lpModeNew = lpChange-&gt;lpModeOrig; <br> <br>// Return success/failure <br>EndDialog (hDlg, fChanged); <br>break; <br> <br>case IDCANCEL: <br>EndDialog (hDlg, FALSE); <br>break; <br> <br>case IDC_DRIVERS: <br>switch (HIWORD (wParam)) <br>{ <br>case CBN_SELENDOK: <br>// User has changed the current driver <br>lpChange = (LPChangeDDInfo) GetWindowLong (hDlg, DWL_USER); <br> <br>// Check if user has changed the Driver <br>lpDriver = DlgGetDriver (hDlg); <br>if ((lpDriver) &amp;&amp; (lpDriver != lpChange-&gt;lpDrvNew)) <br>{ <br>lpChange-&gt;lpDrvNew = lpDriver; <br>lpChange-&gt;lpDevNew = NULL;// Pick a new device <br>lpChange-&gt;lpModeNew = NULL;// Pick a new mode <br> <br>// Update the Device list <br>SendDlgItemMessage (hDlg, IDC_DEVICES, CB_RESETCONTENT, 0, 0); <br>DlgDevicesInit (hDlg); <br> <br>// Update the Mode list <br>SendDlgItemMessage (hDlg, IDC_MODES, CB_RESETCONTENT, 0, 0); <br>DlgModesInit (hDlg); <br>} <br>break; <br>} <br>break; <br> <br>case IDC_DEVICES: <br>switch (HIWORD (wParam)) <br>{ <br>case CBN_SELENDOK: <br>// User has changed the current device <br>lpChange = (LPChangeDDInfo) GetWindowLong (hDlg, DWL_USER); <br> <br>// Check if user has changed the device <br>lpDevice = DlgGetDevice (hDlg); <br>if ((lpDevice) &amp;&amp; (lpDevice != lpChange-&gt;lpDevNew)) <br>{ <br>lpChange-&gt;lpDevNew = lpDevice; <br> <br>// Update the Mode list <br>SendDlgItemMessage (hDlg, IDC_MODES, CB_RESETCONTENT, 0, 0); <br>DlgModesInit (hDlg); <br>} <br>break; <br>} <br>break; <br> <br>case IDC_MODES: <br>switch (HIWORD (wParam)) <br>{ <br>case CBN_SELENDOK: <br>// User has changed the current mode <br>lpChange = (LPChangeDDInfo) GetWindowLong (hDlg, DWL_USER); <br> <br>// Check if user has changed the Mode <br>lpMode = DlgGetMode (hDlg); <br>if ((lpMode) &amp;&amp; (lpMode != lpChange-&gt;lpModeNew)) <br>{ <br>lpChange-&gt;lpModeNew = lpMode; <br>} <br>break; <br>} <br>break; <br>} <br>break; <br> <br>    case WM_INITDIALOG: <br>// Save pointer to ChangeInfo <br>SetWindowLong (hDlg, DWL_USER, (long)lParam); <br> <br>// Set up the current driver, device, and mode lists <br>if (GetDlgItem (hDlg, IDC_DRIVERS)) <br>if (! DlgDriversInit (hDlg)) <br>return FALSE; <br> <br>if (GetDlgItem (hDlg, IDC_DEVICES)) <br>if (! DlgDevicesInit (hDlg)) <br>return FALSE; <br> <br>if (GetDlgItem (hDlg, IDC_MODES)) <br>if (! DlgModesInit (hDlg)) <br>return FALSE; <br> <br>// Successful init <br>return TRUE; <br>} <br>return FALSE; <br>} // End ChangeDriverProc  <br> <br> <br> <br>   <br>/* <br>**----------------------------------------------------------------------------- <br>**  End of File <br>**----------------------------------------------------------------------------- <br>*/ <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
