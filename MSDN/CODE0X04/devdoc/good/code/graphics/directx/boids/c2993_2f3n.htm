<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FLOCK.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2993"></a>FLOCK.CPP</h2>
<pre><code>/* <br>**----------------------------------------------------------------------------- <br>**File:flock.cpp  <br>**Purpose:-- where the boids are <br>**Notes: <br>** <br>**  Copyright (c) 1995 - 1997 by Microsoft, all rights reserved. <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Include Files <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>#include "Common.h" <br>#include "Debug.h" <br>#include "d3dutils.h" <br>#include "boids.h" <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Constants <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>const float InfluenceRadius = 20.0f; <br>const float InfluenceRadiusSquared = InfluenceRadius * InfluenceRadius; <br>const float CollisionFraction = 0.8f; <br>const float InvCollisionFraction = 1.0f/(1.0f-CollisionFraction); <br> <br>const float NormalSpeed = 0.1f; <br>const floatAngleTweak = 0.02f; <br>const float PitchToSpeedRatio = 0.002f; <br> <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Functions <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** Name:UpdateFlock <br>** Purpose:Update posiiton of each boid in flock <br>**----------------------------------------------------------------------------- <br>*/ <br> <br>void <br>UpdateFlock (Flock flock) <br>{ <br>inti, j; <br>floatdist; <br> <br>// first update the dist array 0.0..1.0 with 0.0 being furthest away <br>for (i=0; i&lt;flock.num_boids; i++) { <br>for (j=i+1; j&lt;flock.num_boids; j++) { <br>dist = SquareMagnitude(flock.boids[i].loc - flock.boids[j].loc); <br>dist = InfluenceRadiusSquared - dist; <br>if (dist &lt; 0.0f) { <br>dist = 0.0f; <br>} else { <br>dist /= InfluenceRadiusSquared; <br>} <br>flock.dist[i][j] = flock.dist[j][i] = dist; <br>} <br>flock.dist[i][i] = 0.0f; <br>flock.boids[i].delta_dir = D3DVECTOR(0.0f); <br>flock.boids[i].delta_pos = D3DVECTOR(0.0f); <br>flock.boids[i].delta_cnt = 0; <br>} <br> <br>for (i=0; i&lt;flock.num_boids; i++) { <br>for (j=i+1; j&lt;flock.num_boids; j++) { <br>// if i is near j have them influence each other <br>if (flock.dist[i][j] &gt; 0.0) { <br>D3DVECTORdiff = Normalize(flock.boids[i].loc - flock.boids[j].loc); <br>D3DVECTORdelta; <br>floatcol = 0.0f;// collision weighting <br> <br>// only do collision testing against the nearest ones <br>if (flock.dist[i][j] - CollisionFraction &gt; 0.0f) { <br>col = (flock.dist[i][j] - CollisionFraction) * InvCollisionFraction; <br>} <br> <br>// add in a little flock centering <br>if (flock.dist[i][j] - (1.0-CollisionFraction) &gt; 0.0f) { <br>col -= flock.dist[i][j] * (1.0f-col); <br>} <br> <br>delta = col * diff; <br> <br>// add in the collision avoidance <br>flock.boids[i].delta_pos += delta; <br>flock.boids[j].delta_pos -= delta; <br> <br>// add in the velocity influences <br>flock.boids[i].delta_dir += flock.boids[j].dir * flock.dist[i][j]; <br>flock.boids[j].delta_dir += flock.boids[i].dir * flock.dist[i][j]; <br>flock.boids[i].delta_cnt++; <br>flock.boids[j].delta_cnt++; <br>} <br>} <br>} <br> <br>// update the boids <br>for (i=0; i&lt;flock.num_boids; i++) { <br>if (flock.boids[i].delta_cnt) { <br>flock.boids[i].delta_dir /= (float)flock.boids[i].delta_cnt; <br>flock.boids[i].delta_dir -= flock.boids[i].dir; <br>flock.boids[i].delta_dir *= 1.5f; <br>} <br>D3DVECTORdelta = flock.boids[i].delta_dir + flock.boids[i].delta_pos; // + 0.1f * D3DVECTOR(rnd()-rnd(), rnd()-rnd(), rnd()-rnd()); <br>D3DVECTORoffset; <br> <br>//delta = Normalize(delta); <br> <br>// add in the influence of the global goal <br>D3DVECTORgoal = 0.5f * Normalize(flock.goal-flock.boids[i].loc); <br>delta += goal; <br> <br>// add in any obstacles <br>for (j=0; j&lt;flock.num_obs; j++) { <br>D3DVECTORob = flock.boids[i].loc - flock.obs[j].loc; <br>floatradius = flock.obs[j].radius; <br>floatdist = Magnitude(ob); <br> <br>if (dist &gt; 2*radius) <br>continue; <br> <br>ob /= dist;// normalize <br>dist = 1.0f - dist/(2.0f*radius); <br>delta += dist * ob * 5.0f; <br>} <br> <br>// first deal with pitch changes <br>if (delta.y &gt; 0.01) {// we're too low <br>flock.boids[i].pitch += AngleTweak; <br>if (flock.boids[i].pitch &gt; 0.8f) <br>flock.boids[i].pitch = 0.8f; <br>} else if (delta.y &lt; -0.01) {// we're too high <br>flock.boids[i].pitch -= AngleTweak; <br>if (flock.boids[i].pitch &lt; -0.8f) <br>flock.boids[i].pitch = -0.8f; <br>} else { <br>// add damping <br>flock.boids[i].pitch *= 0.98f; <br>} <br> <br>// speed up or slow down depending on angle of attack <br>flock.boids[i].speed -= flock.boids[i].pitch * PitchToSpeedRatio; <br>// damp back to normal <br>flock.boids[i].speed = (flock.boids[i].speed-NormalSpeed)*0.99f + NormalSpeed; <br> <br>if (flock.boids[i].speed &lt; NormalSpeed/2) { <br>flock.boids[i].speed = NormalSpeed/2; <br>} <br>if (flock.boids[i].speed &gt; NormalSpeed*5) { <br>flock.boids[i].speed = NormalSpeed*5; <br>} <br> <br>// now figure out yaw changes <br>offset = delta; <br>offset.y = 0.0f; <br>delta = flock.boids[i].dir; <br>offset = Normalize(offset); <br>floatdot = DotProduct(offset, delta); <br>// speed up slightly if not turning much <br>if (dot &gt; 0.7f) { <br>dot -= 0.7f; <br>flock.boids[i].speed += dot * 0.005f; <br>} <br>offset = CrossProduct(offset, delta); <br>dot = (1.0f-dot)/2.0f * 0.07f; <br>if (offset.y &gt; 0.05f) { <br>flock.boids[i].dyaw = (flock.boids[i].dyaw*19.0f + dot) * 0.05f; <br>} else if (offset.y &lt; -0.05f) { <br>flock.boids[i].dyaw = (flock.boids[i].dyaw*19.0f - dot) * 0.05f; <br>} else { <br>flock.boids[i].dyaw *= 0.98f;// damp it <br>} <br>flock.boids[i].yaw += flock.boids[i].dyaw; <br>flock.boids[i].roll = -flock.boids[i].dyaw * 20.0f; <br> <br> <br>} <br> <br>}// end of UpdateFlock() <br> <br> <br>/* <br>**----------------------------------------------------------------------------- <br>** End of File <br>**----------------------------------------------------------------------------- <br>*/ <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
