<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>RODCONE.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3361"></a>RODCONE.CPP</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1995, 1996 Microsoft Corporation. All Rights Reserved. <br> * <br> *  File: rodcone.cpp <br> * <br> ***************************************************************************/ <br> <br>/* <br> * Sample code for building objects out of rods and cones. <br> */ <br> <br>#include &lt;d3drmwin.h&gt; <br>#include "viewer.h" <br>#include "rodcone.h" <br>#include &lt;math.h&gt; <br> <br>static unsigned long rod_faces[] = <br>{   8, 7, 7, 6, 6, 5, 5, 4, 4, 3, 3, 2, 2, 1, 1, 0, 0, /* end 1 */ <br>    4, 0, 0, 1, 1, 9, 1, 8, 0,/* side 0 */ <br>    4, 1, 1, 2, 2, 10, 2, 9, 1,/* side 1 */ <br>    4, 2, 2, 3, 3, 11, 3, 10, 2, /* side 2 */ <br>    4, 3, 3, 4, 4, 12, 4, 11, 3, /* side 3 */ <br>    4, 4, 4, 5, 5, 13, 5, 12, 4, /* side 4 */ <br>    4, 5, 5, 6, 6, 14, 6, 13, 5, /* side 5 */ <br>    4, 6, 6, 7, 7, 15, 7, 14, 6, /* side 6 */ <br>    4, 7, 7, 0, 0, 8, 0, 15, 7,/* side 7 */ <br>    8, 8, 0, 9, 1, 10, 2, 11, 3, 12, 4, 13, 5, 14, 6, 15, 7, /* end 2 */ <br>    0, <br>}; <br> <br>void AddRod(LPDIRECT3DRMMESHBUILDER mesh, D3DVALUE radius, D3DVECTOR a, D3DVECTOR b) <br>{ <br>    D3DVECTOR d, u, r; <br>    D3DVECTOR v[16]; <br>    D3DVECTOR n[8]; <br>    D3DVALUE f; <br>    int i; <br> <br>    /* <br>     * Find the unit vector along the rod. <br>     */ <br>    d.x = b.x - a.x; <br>    d.y = b.y - a.y; <br>    d.z = b.z - a.z; <br>    D3DRMVectorNormalise(&amp;d); <br> <br>    /* <br>     * Pick a vector normal to d <br>     */ <br>    if (d.y != D3DVAL(0.0) || d.z != D3DVAL(0.0)) <br>    {u.x = D3DVAL(0.0); <br>if (d.y == D3DVAL(0.0)) <br>{   u.y = D3DVAL(1.0); <br>    u.z = D3DVAL(0.0); <br>} else <br>{   D3DVALUE n_fix = <br>D3DVAL(1.0) <br>    +D3DDivide(D3DMultiply(d.z, d.z), D3DMultiply(d.y, d.y)); <br>#ifdef FIXED_POINT_API <br>    double un_val = (double)n_fix / (double)(1&lt;&lt;16); <br>    u.z = D3DVAL(sqrt(1/un_val)); <br>#else <br>    u.z = D3DVAL(sqrt(D3DDivide(D3DVAL(1.0), D3DVAL(n_fix)))); <br>#endif <br>    u.y = -D3DMultiply(u.z, D3DDivide(d.z, d.y)); <br>} <br>    } else <br>    {u.x = D3DVAL(0.0); <br>u.y = D3DVAL(0.0); <br>u.z = D3DVAL(1.0); <br>    } <br> <br>    /* <br>     * Now find a vector normal to them both, to give us a coordinate <br>     * system in the plane normal to the rod. <br>     */ <br>    D3DRMVectorCrossProduct(&amp;r, &amp;d, &amp;u); <br> <br>    /* <br>     * Scale down the coordinates to the radius of the rod. <br>     */ <br>    u.x = D3DMultiply(u.x, radius); <br>    u.y = D3DMultiply(u.y, radius); <br>    u.z = D3DMultiply(u.z, radius); <br>    r.x = D3DMultiply(r.x, radius); <br>    r.y = D3DMultiply(r.y, radius); <br>    r.z = D3DMultiply(r.z, radius); <br> <br>    /* <br>     * Calculate the corners of an octagon. <br>     */ <br>    f = D3DVAL((float)sqrt(2.0) / (2 * (1 + (float)sqrt(2.0) / 2))); <br>    v[0].x = u.x + D3DMultiply(r.x, f); <br>    v[0].y = u.y + D3DMultiply(r.y, f); <br>    v[0].z = u.z + D3DMultiply(r.z, f); <br> <br>    v[1].x = D3DMultiply(u.x, f) + r.x; <br>    v[1].y = D3DMultiply(u.y, f) + r.y; <br>    v[1].z = D3DMultiply(u.z, f) + r.z; <br> <br>    v[2].x = D3DMultiply(-u.x, f) + r.x; <br>    v[2].y = D3DMultiply(-u.y, f) + r.y; <br>    v[2].z = D3DMultiply(-u.z, f) + r.z; <br> <br>    v[3].x = -u.x + D3DMultiply(r.x, f); <br>    v[3].y = -u.y + D3DMultiply(r.y, f); <br>    v[3].z = -u.z + D3DMultiply(r.z, f); <br> <br>    v[4].x = -u.x - D3DMultiply(r.x, f); <br>    v[4].y = -u.y - D3DMultiply(r.y, f); <br>    v[4].z = -u.z - D3DMultiply(r.z, f); <br> <br>    v[5].x = D3DMultiply(-u.x, f) - r.x; <br>    v[5].y = D3DMultiply(-u.y, f) - r.y; <br>    v[5].z = D3DMultiply(-u.z, f) - r.z; <br> <br>    v[6].x = D3DMultiply(u.x, f) - r.x; <br>    v[6].y = D3DMultiply(u.y, f) - r.y; <br>    v[6].z = D3DMultiply(u.z, f) - r.z; <br> <br>    v[7].x = u.x - D3DMultiply(r.x, f); <br>    v[7].y = u.y - D3DMultiply(r.y, f); <br>    v[7].z = u.z - D3DMultiply(r.z, f); <br> <br>    /* <br>     * Add the rod endpoints and calculate the vertex normals. <br>     */ <br>    for (i = 0; i &lt; 8; i++) <br>    {n[i] = v[i]; <br>D3DRMVectorNormalise(&amp;n[i]); <br>v[i + 8].x = v[i].x + b.x; <br>v[i + 8].y = v[i].y + b.y; <br>v[i + 8].z = v[i].z + b.z; <br>v[i].x += a.x; <br>v[i].y += a.y; <br>v[i].z += a.z; <br>    } <br> <br>    /* <br>     * Now add the faces. <br>     */ <br>    mesh-&gt;AddFaces(16, v, 8, n, rod_faces, NULL); <br>} <br> <br>static unsigned long cone_faces[] = <br>{   8, 7, 7, 6, 6, 5, 5, 4, 4, 3, 3, 2, 2, 1, 1, 0, 0, /* end 1 */ <br>    3, 0, 0, 1, 1, 8, 1,/* side 0 */ <br>    3, 1, 1, 2, 2, 8, 1,/* side 1 */ <br>    3, 2, 2, 3, 3, 8, 1, /* side 2 */ <br>    3, 3, 3, 4, 4, 8, 1, /* side 3 */ <br>    3, 4, 4, 5, 5, 8, 1, /* side 4 */ <br>    3, 5, 5, 6, 6, 8, 1, /* side 5 */ <br>    3, 6, 6, 7, 7, 8, 1, /* side 6 */ <br>    3, 7, 7, 0, 0, 8, 1,/* side 7 */ <br>    0, <br>}; <br> <br>void AddCone(LPDIRECT3DRMMESHBUILDER mesh, D3DVALUE radius, D3DVECTOR a, D3DVECTOR b) <br>{ <br>    D3DVECTOR d, u, r; <br>    D3DVECTOR v[16]; <br>    D3DVECTOR n[8]; <br>    D3DVALUE f; <br>    int i; <br> <br>    /* <br>     * Find the unit vector along the rod. <br>     */ <br>    d.x = b.x - a.x; <br>    d.y = b.y - a.y; <br>    d.z = b.z - a.z; <br>    D3DRMVectorNormalise(&amp;d); <br> <br>    /* <br>     * Pick a vector normal to d <br>     */ <br>    if (d.y != D3DVAL(0.0) || d.z != D3DVAL(0.0)) <br>    {u.x = D3DVAL(0.0); <br>if (d.y == D3DVAL(0.0)) <br>{   u.y = D3DVAL(1.0); <br>    u.z = D3DVAL(0.0); <br>} else <br>{   D3DVALUE n_fix = <br>D3DVAL(1.0) <br>    +D3DDivide(D3DMultiply(d.z, d.z), D3DMultiply(d.y, d.y)); <br>#ifdef FIXED_POINT_API <br>    double un_val = (double)n_fix / (double)(1&lt;&lt;16); <br>    u.z = D3DVAL(sqrt(1 / un_val)); <br>#else <br>    u.z = D3DVAL(sqrt(D3DVAL(1.0) / D3DVAL(n_fix))); <br>#endif <br>    u.y = - D3DDivide(D3DMultiply(u.z, d.z), d.y); <br>} <br>    } else <br>    {u.x = D3DVAL(0.0); <br>u.y = D3DVAL(0.0); <br>u.z = D3DVAL(1.0); <br>    } <br> <br>    /* <br>     * Now find a vector normal to them both, to give us a coordinate <br>     * system in the plane normal to the rod. <br>     */ <br>    D3DRMVectorCrossProduct(&amp;r, &amp;d, &amp;u); <br> <br>    /* <br>     * Scale down the coordinates to the radius of the rod. <br>     */ <br>    u.x = D3DMultiply(u.x, radius); <br>    u.y = D3DMultiply(u.y, radius); <br>    u.z = D3DMultiply(u.z, radius); <br>    r.x = D3DMultiply(r.x, radius); <br>    r.y = D3DMultiply(r.y, radius); <br>    r.z = D3DMultiply(r.z, radius); <br> <br>    /* <br>     * Calculate the corners of an octagon. <br>     */ <br>    f = D3DVAL((float)sqrt(2.0) / (2 * (1 + (float)sqrt(2.0) / 2))); <br>    v[0].x = u.x + D3DMultiply(r.x, f); <br>    v[0].y = u.y + D3DMultiply(r.y, f); <br>    v[0].z = u.z + D3DMultiply(r.z, f); <br> <br>    v[1].x = D3DMultiply(u.x, f) + r.x; <br>    v[1].y = D3DMultiply(u.y, f) + r.y; <br>    v[1].z = D3DMultiply(u.z, f) + r.z; <br> <br>    v[2].x = D3DMultiply(-u.x, f) + r.x; <br>    v[2].y = D3DMultiply(-u.y, f) + r.y; <br>    v[2].z = D3DMultiply(-u.z, f) + r.z; <br> <br>    v[3].x = -u.x + D3DMultiply(r.x, f); <br>    v[3].y = -u.y + D3DMultiply(r.y, f); <br>    v[3].z = -u.z + D3DMultiply(r.z, f); <br> <br>    v[4].x = -u.x - D3DMultiply(r.x, f); <br>    v[4].y = -u.y - D3DMultiply(r.y, f); <br>    v[4].z = -u.z - D3DMultiply(r.z, f); <br> <br>    v[5].x = D3DMultiply(-u.x, f) - r.x; <br>    v[5].y = D3DMultiply(-u.y, f) - r.y; <br>    v[5].z = D3DMultiply(-u.z, f) - r.z; <br> <br>    v[6].x = D3DMultiply(u.x, f) - r.x; <br>    v[6].y = D3DMultiply(u.y, f) - r.y; <br>    v[6].z = D3DMultiply(u.z, f) - r.z; <br> <br>    v[7].x = u.x - D3DMultiply(r.x, f); <br>    v[7].y = u.y - D3DMultiply(r.y, f); <br>    v[7].z = u.z - D3DMultiply(r.z, f); <br> <br>    v[8] = b; <br> <br>    /* <br>     * Calculate the vertex normals. <br>     */ <br>    for (i = 0; i &lt; 8; i++) <br>    {n[i] = v[i]; <br>D3DRMVectorNormalise(&amp;n[0]); <br>v[i].x += a.x; <br>v[i].y += a.y; <br>v[i].z += a.z; <br>    } <br> <br>    /* <br>     * Now add the faces. <br>     */ <br>    mesh-&gt;AddFaces(9, v, 8, n, cone_faces, NULL); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
