<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>VIEWER.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3365"></a>VIEWER.CPP</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1995, 1996 Microsoft Corporation. All Rights Reserved. <br> * <br> *  File: viewer.cpp <br> * <br> ***************************************************************************/ <br> <br>#define INITGUID <br>#include &lt;d3drmwin.h&gt; <br>#include "viewer.h" <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdarg.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;malloc.h&gt; <br>#include &lt;math.h&gt; <br>#include &lt;direct.h&gt; <br>#include "sel.h" <br> <br>static char ViewerClass[32] = "ViewerClass"; <br>static BOOL Render(void); <br>HRESULT loadTextures(char *name, void *arg, LPDIRECT3DRMTEXTURE *tex); <br> <br>AppInfo *active_window = NULL; <br> <br>LPDIRECT3DRM lpD3DRM1 = 0; <br>LPDIRECT3DRM2 lpD3DRM = 0; <br>LPDIRECTDRAWCLIPPER lpDDClipper = 0; <br>BOOL bQuit = FALSE; <br> <br>static BOOL FirstInstance(HINSTANCE); <br>static HWND AnyInstance(HINSTANCE this_inst, int cmdshow); <br>long FAR PASCAL WindowProc(HWND, UINT, WPARAM, LPARAM); <br>static BOOL CreateDevice(HWND, AppInfo*); <br>static void Idle(); <br>float gfVal = 1.0F; <br> <br>char* MyErrorToString(HRESULT error); <br> <br>/* Msg <br> * Message output for error notification. <br> */ <br>void __cdecl <br>Msg( LPSTR fmt, ... ) <br>{ <br>    char buff[256]; <br>    va_list args; <br>     <br>    va_start(args, fmt); <br>    wvsprintf(buff, fmt, args); <br>    va_end(args); <br>     <br>    lstrcat(buff, "\r\n"); <br>    MessageBox( NULL, buff, "Viewer Message", MB_OK ); <br>} <br> <br> <br>char* LSTRRCHR( const char* lpString, int bChar ) <br>{ <br>    if( lpString != NULL ) <br>    { <br>const char*lpBegin; <br> <br>lpBegin = lpString; <br> <br>while( *lpString != 0 ) <br>{ <br>    lpString++; <br>} <br> <br>        while( 1 ) <br>{ <br>    if( *lpString == bChar ) <br>    { <br>return (char*)lpString; <br>    } <br>     <br>    if( lpString == lpBegin ) <br>    { <br> break; <br>    } <br> <br>    lpString--; <br>} <br>    } <br> <br>    return NULL; <br>} /* LSTRRCHR */ <br> <br>/* <br> * Initialization, message loop <br> */ <br>int PASCAL WinMain <br>    (HINSTANCE this_inst, HINSTANCE prev_inst, LPSTR cmdline, int cmdshow) <br>{ <br>    MSGmsg; <br>    intidle; <br>    intdone = FALSE; <br>    HACCELaccel; <br>    HRESULTrval; <br>    HWNDhwnd; <br>    DWORDdwDXVersion, dwDXPlatform; <br> <br>    prev_inst = prev_inst; <br>    cmdline = cmdline; <br> <br>    /* <br>     * Need DX5 version for alpha blending and progressive meshes. <br>     */ <br>    GetDXVersion(&amp;dwDXVersion, &amp;dwDXPlatform); <br>    if (dwDXVersion &lt; 0x500) <br>    { <br>Msg("This application requires DirectX version 5 or above."); <br>return 1; <br>    } <br> <br>    rval = Direct3DRMCreate(&amp;lpD3DRM1); <br>    if (rval != D3DRM_OK) { <br>Msg("Failed to create Direct3DRM.\n%s", MyErrorToString(rval)); <br>return 1; <br>    } <br> <br>    rval = lpD3DRM1-&gt;QueryInterface(IID_IDirect3DRM2, (LPVOID*)&amp;lpD3DRM); <br>    if (rval != D3DRM_OK) { <br>Msg("Failed to QI for IID_IDirect3DRM2.\n%s", MyErrorToString(rval)); <br>return 1; <br>    } <br>     <br>    if (!prev_inst) <br>if (!FirstInstance(this_inst)) <br>    return 1; <br> <br>    if (!(hwnd = AnyInstance(this_inst, cmdshow))) <br>return 1; <br>    accel = LoadAccelerators(this_inst, "ViewerAccel"); <br> <br>    while (!done) { <br>idle = TRUE; <br>while (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) { <br>    idle = FALSE; <br>    if (msg.message == WM_QUIT || bQuit) { <br>done = TRUE; <br>break; <br>    } <br>    if (!TranslateAccelerator(msg.hwnd, accel, &amp;msg)) { <br>TranslateMessage(&amp;msg); <br>DispatchMessage(&amp;msg); <br>    } <br>} <br>if (done) { <br>    break; <br>} else if (!active_window-&gt;bMinimized &amp;&amp; !bQuit) { <br>    if (idle) Idle(); <br>    if (!Render()) { <br>Msg("Rendering failed.\n"); <br>done = TRUE; <br>break; <br>    } <br>} else { <br>    WaitMessage(); <br>} <br>    } <br>    SelectPM(NULL); <br>    RELEASE(active_window-&gt;scene); <br>    RELEASE(active_window-&gt;camera); <br>    RELEASE(active_window-&gt;view); <br>    RELEASE(active_window-&gt;dev); <br>    RELEASE(active_window-&gt;dev1); <br>    ClearClipboard(); <br>    RELEASE(lpD3DRM); <br>    RELEASE(lpD3DRM1); <br>    RELEASE(lpDDClipper); <br>    DestroyWindow(hwnd); <br>    return msg.wParam; <br>} <br> <br>/* <br> * Register window class for the application, and do any other <br> * application initialization <br> */ <br>static BOOL FirstInstance(HINSTANCE this_inst) <br>{ <br>    WNDCLASSwc; <br>    BOOLrc; <br> <br>    /* <br>     * set up and register window class <br>     */ <br>    wc.style = CS_HREDRAW | CS_VREDRAW; <br>    wc.lpfnWndProc = WindowProc; <br>    wc.cbClsExtra = 0; <br>    wc.cbWndExtra = sizeof(DWORD); <br>    wc.hInstance = this_inst; <br>    wc.hIcon = LoadIcon(this_inst, "ViewerIcon"); <br>    wc.hCursor = LoadCursor(NULL, IDC_ARROW); <br>    wc.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH); <br>    wc.lpszMenuName = "ViewerMenu"; <br>    wc.lpszClassName = ViewerClass; <br>    rc = RegisterClass(&amp;wc); <br> <br>    return rc; <br>} <br> <br>/* <br> * Do work required for every instance of the application: <br> * create the window, initialize data <br> */ <br>static HWND AnyInstance(HINSTANCE this_inst, int cmdshow) <br>{ <br>    HWND win; <br>    AppInfo *info; <br>    SCROLLINFO si = { sizeof(SCROLLINFO), SIF_ALL, 0, 100, 1, 0}; <br> <br>    /* <br>     * create main window <br>     */ <br>    win = <br>CreateWindow <br>(   ViewerClass,/* class */ <br>    "Direct3D Object Viewer",/* caption */ <br>    WS_OVERLAPPEDWINDOW | WS_VSCROLL,/* style */ <br>    CW_USEDEFAULT,/* init. x pos */ <br>    CW_USEDEFAULT,/* init. y pos */ <br>    400,/* init. x size */ <br>    400,/* init. y size */ <br>    NULL,/* parent window */ <br>    NULL,/* menu handle */ <br>    this_inst,/* program handle */ <br>    NULL/* create parms */ <br>); <br> <br> <br>    if (!win) return FALSE; <br> <br>    EnableScrollBar(win, SB_VERT, ESB_DISABLE_BOTH); <br>    SetScrollInfo(win, SB_VERT, &amp;si, TRUE); <br> <br>    /* <br>     * Create a clipper for this window <br>     */ <br>    if (FAILED(DirectDrawCreateClipper(0, &amp;lpDDClipper, NULL))) { <br>return FALSE; <br>    } <br>    if (FAILED(lpDDClipper-&gt;SetHWnd(0, win))) { <br>RELEASE(lpDDClipper); <br>return FALSE; <br>    } <br>    /* <br>     * set up data associated with this window <br>     */ <br>    info = (AppInfo*) malloc(sizeof(AppInfo)); <br>    memset(info, 0, sizeof(AppInfo)); <br>    info-&gt;win = win; <br>    <br>    SetWindowLong(win, 0, (long) info); <br>    info-&gt;model = D3DCOLOR_MONO; <br>    if (!CreateDevice(win, info)) { <br>return FALSE; <br>    } <br> <br>    /* <br>     * display window <br>     */ <br>    ShowWindow(win, cmdshow); <br>    UpdateWindow(win); <br> <br>    return win; <br>} <br> <br>/* <br> * Processes messages for the about dialog. <br> */ <br>BOOL FAR PASCAL AboutDlgProc <br>    (HWND win, unsigned msg, WORD wparam, LONG lparam) <br>{ <br>    lparam = lparam; <br> <br>    switch (msg) <br>    { <br>    case WM_INITDIALOG: <br>return TRUE; <br> <br>    case WM_COMMAND: <br>if (wparam == IDOK) <br>{   EndDialog(win, TRUE); <br>    return TRUE; <br>} <br>break; <br>    } <br>    return FALSE; <br>} <br> <br>/* <br> * Create a simple scene. <br> */ <br>static BOOL CreateScene(AppInfo* info) <br>{ <br>    LPDIRECT3DRMFRAME2 frame = NULL; <br>    LPDIRECT3DRMFRAME2 light = NULL; <br>    LPDIRECT3DRMMESHBUILDER2 builder = NULL; <br>    LPDIRECT3DRMLIGHT light1 = NULL; <br>    LPDIRECT3DRMLIGHT light2 = NULL; <br>    LPDIRECT3DRMMATERIAL mat = NULL; <br>    HRESULT rval; <br> <br>    if (FAILED(lpD3DRM-&gt;CreateFrame(NULL, &amp;info-&gt;scene))) <br>goto generic_error; <br>    if (FAILED(lpD3DRM-&gt;CreateLightRGB(D3DRMLIGHT_DIRECTIONAL, D3DVAL(1.0), D3DVAL(1.0), D3DVAL(1.0), &amp;light1))) <br>goto generic_error; <br>    if (FAILED(lpD3DRM-&gt;CreateLightRGB(D3DRMLIGHT_AMBIENT, D3DVAL(0.1), D3DVAL(0.1), D3DVAL(0.1), &amp;light2))) <br>goto generic_error; <br> <br>    if (FAILED(lpD3DRM-&gt;CreateFrame(info-&gt;scene, &amp;light))) <br>goto generic_error; <br>    if (FAILED(light-&gt;SetPosition(info-&gt;scene, D3DVAL(2.0), D3DVAL(2.0), D3DVAL(5.0)))) <br>goto generic_error; <br>    if (FAILED(light-&gt;SetOrientation(info-&gt;scene, D3DVAL(-1.0), D3DVAL(-1.0), D3DVAL(1.0), D3DVAL(0.0), D3DVAL(1.0), D3DVAL(0.0)))) <br>goto generic_error; <br>    if (FAILED(light-&gt;AddLight(light1))) <br>goto generic_error; <br>    RELEASE(light1); <br>    if (FAILED(info-&gt;scene-&gt;AddLight(light2))) <br>goto generic_error; <br>    RELEASE(light2); <br>    if (FAILED(lpD3DRM-&gt;CreateMeshBuilder(&amp;builder))) <br>goto generic_error; <br>    rval = builder-&gt;Load("camera.x", NULL, D3DRMLOAD_FROMFILE, NULL, NULL); <br>    if (rval != D3DRM_OK) { <br>Msg("Failed to load camera.x.\n%s", MyErrorToString(rval)); <br>goto ret_with_error; <br>    } <br>    if (FAILED(builder-&gt;SetQuality(D3DRMRENDER_UNLITFLAT))) <br>goto generic_error; <br>    if (FAILED(light-&gt;AddVisual(builder))) <br>goto generic_error; <br>    RELEASE(builder); <br>    RELEASE(light); <br> <br>    if (FAILED(lpD3DRM-&gt;CreateFrame(info-&gt;scene, &amp;frame))) <br>goto generic_error; <br>    if (FAILED(frame-&gt;SetRotation(info-&gt;scene, D3DVAL(0.0), D3DVAL(1.0), D3DVAL(0.0), D3DVAL(-0.02)))) <br>goto generic_error; <br>    if (FAILED(frame-&gt;SetPosition(info-&gt;scene, D3DVAL(0.0), D3DVAL(0.0), D3DVAL(10.0)))) <br>goto generic_error; <br>    if (FAILED(lpD3DRM-&gt;CreateMeshBuilder(&amp;builder))) <br>goto generic_error; <br>    rval = builder-&gt;Load("mslogo.x", NULL, D3DRMLOAD_FROMFILE, <br>loadTextures, NULL); <br>    if (rval != D3DRM_OK) { <br>Msg("Failed to load mslogo.x.\n%s", MyErrorToString(rval)); <br>goto ret_with_error; <br>    } <br>    if (FAILED(builder-&gt;SetColorRGB(D3DVAL(0.8), D3DVAL(0.8), D3DVAL(0.8)))) <br>goto generic_error; <br>    if (FAILED(lpD3DRM-&gt;CreateMaterial(D3DVAL(10.0), &amp;mat))) <br>goto generic_error; <br>    if (FAILED(builder-&gt;SetMaterial(mat))) <br>goto generic_error; <br> <br>    RELEASE(mat); <br>    if (FAILED(frame-&gt;AddVisual(builder))) <br>goto generic_error; <br>    RELEASE(builder); <br>    RELEASE(frame); <br> <br>    if (FAILED(lpD3DRM-&gt;CreateFrame(info-&gt;scene, &amp;info-&gt;camera))) <br>goto generic_error; <br>    if (FAILED(info-&gt;camera-&gt;SetPosition(info-&gt;scene, D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0)))) <br>goto generic_error; <br>    return TRUE; <br>generic_error: <br>    Msg("A failure occurred while creating the scene.\n"); <br>ret_with_error: <br>    RELEASE(frame); <br>    RELEASE(light); <br>    RELEASE(builder); <br>    RELEASE(light1); <br>    RELEASE(light2); <br>    RELEASE(mat); <br>    return FALSE; <br>} <br> <br>static DWORD bppToddbd(int bpp) <br>{ <br>    switch(bpp) { <br>    case 1: <br>return DDBD_1; <br>    case 2: <br>return DDBD_2; <br>    case 4: <br>return DDBD_4; <br>    case 8: <br>return DDBD_8; <br>    case 16: <br>return DDBD_16; <br>    case 24: <br>return DDBD_24; <br>    case 32: <br>return DDBD_32; <br>    } <br>    return 0; <br>} <br> <br> <br>/* <br> * Find a device, preferably hardware, for a particular color model. <br> */ <br>LPGUID <br>FindDevice(D3DCOLORMODEL cm, BOOL bSoftwareOnly) <br>{ <br>    LPDIRECTDRAW lpDD; <br>    LPDIRECT3D lpD3D; <br>    D3DFINDDEVICESEARCH search; <br>    static D3DFINDDEVICERESULT result; <br>    HRESULT error; <br>    HDC hdc; <br>    int bpp; <br> <br>    hdc = GetDC(NULL); <br>    bpp = GetDeviceCaps(hdc, BITSPIXEL); <br>    ReleaseDC(NULL, hdc); <br> <br>    if (DirectDrawCreate(NULL, &amp;lpDD, NULL)) <br>    return NULL; <br> <br>    if (lpDD-&gt;QueryInterface(IID_IDirect3D, (void**) &amp;lpD3D)) { <br>    lpDD-&gt;Release(); <br>return NULL; <br>    } <br>     <br>    memset(&amp;search, 0, sizeof search); <br>    search.dwSize = sizeof search; <br>    search.dwFlags = D3DFDS_COLORMODEL; <br>    search.dcmColorModel = (cm == D3DCOLOR_MONO) ? D3DCOLOR_MONO : D3DCOLOR_RGB; <br>    if (bSoftwareOnly) <br>    { <br>search.dwFlags |= D3DFDS_HARDWARE; <br>search.bHardware = FALSE; <br>    } <br> <br>    memset(&amp;result, 0, sizeof result); <br>    result.dwSize = sizeof result; <br> <br>    error = lpD3D-&gt;FindDevice(&amp;search, &amp;result); <br> <br>    if (error == DD_OK) { <br>/* <br> * If the device found is hardware but cannot support the current <br> * bit depth, then fall back to software rendering. <br> */ <br>if (result.ddHwDesc.dwFlags <br>    &amp;&amp; !(result.ddHwDesc.dwDeviceRenderBitDepth &amp; bppToddbd(bpp))) { <br>     <br>    search.dwFlags |= D3DFDS_HARDWARE; <br>    search.bHardware = FALSE; <br>    memset(&amp;result, 0, sizeof result); <br>    result.dwSize = sizeof result; <br>    error = lpD3D-&gt;FindDevice(&amp;search, &amp;result); <br>} <br>    } <br> <br>    lpD3D-&gt;Release(); <br>    lpDD-&gt;Release(); <br> <br>    if (error) <br>return NULL; <br>    else <br>return &amp;result.guid; <br>} <br> <br>/* <br> * Create the device and viewport. <br> */ <br>static BOOL CreateDevice(HWND win, AppInfo* info) <br>{ <br>    RECT r; <br>    int bpp; <br>    HDC hdc; <br> <br>    GetClientRect(win, &amp;r); <br>    if (FAILED(lpD3DRM-&gt;CreateDeviceFromClipper(lpDDClipper, <br>FindDevice(info-&gt;model, FALSE), <br>r.right, r.bottom, <br>&amp;info-&gt;dev))) <br>    { <br>if (FAILED(lpD3DRM-&gt;CreateDeviceFromClipper(lpDDClipper, <br>    FindDevice(info-&gt;model, TRUE), <br>    r.right, r.bottom, <br>    &amp;info-&gt;dev))) <br>{ <br>    goto generic_error; <br>} <br>    } <br>    info-&gt;dev-&gt;SetRenderMode(D3DRMRENDERMODE_BLENDEDTRANSPARENCY|D3DRMRENDERMODE_SORTEDTRANSPARENCY); <br>    if (FAILED(info-&gt;dev-&gt;QueryInterface(IID_IDirect3DRMDevice, <br> (LPVOID*)&amp;info-&gt;dev1))) <br>goto generic_error; <br>     <br>    hdc = GetDC(win); <br>    bpp = GetDeviceCaps(hdc, BITSPIXEL); <br>    ReleaseDC(win, hdc); <br>    switch (bpp) <br>    { <br>    case 1: <br>if (FAILED(info-&gt;dev-&gt;SetShades(4))) <br>    goto generic_error; <br>if (FAILED(lpD3DRM-&gt;SetDefaultTextureShades(4))) <br>    goto generic_error; <br>break; <br>    case 16: <br>if (FAILED(info-&gt;dev-&gt;SetShades(32))) <br>    goto generic_error; <br>if (FAILED(lpD3DRM-&gt;SetDefaultTextureColors(64))) <br>    goto generic_error; <br>if (FAILED(lpD3DRM-&gt;SetDefaultTextureShades(32))) <br>    goto generic_error; <br>if (FAILED(info-&gt;dev-&gt;SetDither(FALSE))) <br>    goto generic_error; <br>break; <br>    case 24: <br>    case 32: <br>if (FAILED(info-&gt;dev-&gt;SetShades(256))) <br>    goto generic_error; <br>if (FAILED(lpD3DRM-&gt;SetDefaultTextureColors(64))) <br>    goto generic_error; <br>if (FAILED(lpD3DRM-&gt;SetDefaultTextureShades(256))) <br>    goto generic_error; <br>if (FAILED(info-&gt;dev-&gt;SetDither(FALSE))) <br>    goto generic_error; <br>break; <br>    default: <br>if (FAILED(info-&gt;dev-&gt;SetDither(FALSE))) <br>    goto generic_error; <br>    } <br>    if (!CreateScene(info)) <br>goto ret_with_error; <br>    if (FAILED(lpD3DRM-&gt;CreateViewport(info-&gt;dev, info-&gt;camera, 0, 0, <br>info-&gt;dev-&gt;GetWidth(), <br>info-&gt;dev-&gt;GetHeight(), &amp;info-&gt;view))) <br>goto generic_error; <br>    if (FAILED(info-&gt;view-&gt;SetBack(D3DVAL(5000.0)))) <br>goto generic_error; <br> <br>    return TRUE; <br>generic_error: <br>    Msg("An error occurred while creating the device.\n"); <br>ret_with_error: <br>    return FALSE; <br>} <br> <br>/* <br> * Regenerate the device if the color model changes or the window size <br> * changes. <br> */ <br>static BOOL RebuildDevice(HWND win, AppInfo* info, int width, int height) <br>{ <br>    HRESULT rval; <br>    int old_dither = info-&gt;dev-&gt;GetDither(); <br>    D3DRMRENDERQUALITY old_quality = info-&gt;dev-&gt;GetQuality(); <br>    D3DRMTEXTUREQUALITY old_texture_quality = info-&gt;dev-&gt;GetTextureQuality(); <br>    int old_shades = info-&gt;dev-&gt;GetShades(); <br> <br>    RELEASE(info-&gt;view); <br>    RELEASE(info-&gt;dev); <br>    RELEASE(info-&gt;dev1); <br>    if (lpD3DRM-&gt;CreateDeviceFromClipper(lpDDClipper, FindDevice(info-&gt;model, FALSE), <br>width, height, &amp;info-&gt;dev)) <br>    { <br>if (rval = lpD3DRM-&gt;CreateDeviceFromClipper(lpDDClipper, FindDevice(info-&gt;model, TRUE), <br>    width, height, &amp;info-&gt;dev)) <br>{ <br>    Msg("Creating a device from HWND failed while rebuilding device.\n%s", MyErrorToString(rval)); <br>    return FALSE; <br>} <br>    } <br>    info-&gt;dev-&gt;SetRenderMode(D3DRMRENDERMODE_BLENDEDTRANSPARENCY|D3DRMRENDERMODE_SORTEDTRANSPARENCY); <br>    if (FAILED(info-&gt;dev-&gt;QueryInterface(IID_IDirect3DRMDevice, <br> (LPVOID*)&amp;info-&gt;dev1))) <br>goto generic_error; <br> <br>    if (FAILED(info-&gt;dev-&gt;SetDither(old_dither))) <br>goto generic_error; <br>    if (FAILED(info-&gt;dev-&gt;SetQuality(old_quality))) <br>goto generic_error; <br>    if (FAILED(info-&gt;dev-&gt;SetTextureQuality(old_texture_quality))) { <br>goto generic_error; <br>    } <br>    if (FAILED(info-&gt;dev-&gt;SetShades(old_shades))) <br>goto generic_error; <br>    width = info-&gt;dev-&gt;GetWidth(); <br>    height = info-&gt;dev-&gt;GetHeight(); <br>    if (FAILED(lpD3DRM-&gt;CreateViewport(info-&gt;dev, info-&gt;camera, <br>  0, 0, width, height, &amp;info-&gt;view))) <br>  goto generic_error; <br>    if (FAILED(info-&gt;view-&gt;SetBack(D3DVAL(400.0)))) <br>goto generic_error; <br>    return TRUE; <br>generic_error: <br>    Msg("A failure occurred while rebuilding the device.\n"); <br>    return FALSE; <br>} <br> <br>/* <br> * Resize the viewport and device when the window size changes. <br> */ <br>static BOOL ResizeViewport(HWND win, AppInfo* info, int width, int height) <br>{ <br>    int view_width = info-&gt;view-&gt;GetWidth(); <br>    int view_height = info-&gt;view-&gt;GetHeight(); <br>    int dev_width = info-&gt;dev-&gt;GetWidth(); <br>    int dev_height = info-&gt;dev-&gt;GetHeight(); <br> <br>    if (view_width == width &amp;&amp; view_height == height) <br>return TRUE; <br>     <br>    if (width &lt;= dev_width &amp;&amp; height &lt;= dev_height) { <br>RELEASE(info-&gt;view); <br>if (FAILED(lpD3DRM-&gt;CreateViewport(info-&gt;dev, info-&gt;camera, 0, 0, width, height, &amp;info-&gt;view))) <br>    goto generic_error; <br>if (FAILED(info-&gt;view-&gt;SetBack(D3DVAL(400.0)))) <br>    goto generic_error; <br>    } <br> <br>    if (!RebuildDevice(win, info, width, height)) <br>return FALSE; <br>    return TRUE; <br>generic_error: <br>    Msg("A failure occurred while resizing the viewport.\n"); <br>    return FALSE; <br>} <br> <br>/* <br> * Place an object in front of the camera. <br> */ <br>static BOOL PlaceMesh(LPDIRECT3DRMVISUAL mesh, AppInfo *info) <br>{ <br>    LPDIRECT3DRMFRAME2 frame; <br> <br>    if (FAILED(lpD3DRM-&gt;CreateFrame(info-&gt;scene, &amp;frame))) <br>return FALSE; <br>    if (FAILED(frame-&gt;AddVisual(mesh))) <br>return FALSE; <br>    if (FAILED(frame-&gt;SetPosition(info-&gt;camera, D3DVAL(0.0), D3DVAL(0.0), D3DVAL(15.0)))) <br>return FALSE; <br>    frame-&gt;Release(); <br>    return TRUE; <br>} <br> <br>static BOOL ScaleScene(LPDIRECT3DRMFRAME frame, AppInfo *info) <br>{ <br>  /* Some trickery form the RL2 viewer to scale a scene down to <br>     managable proportions */ <br>  LPDIRECT3DRMMESHBUILDER2 mbuilder; <br>  D3DRMBOX box; <br>  D3DVALUE maxDim; <br> <br>  lpD3DRM-&gt;CreateMeshBuilder(&amp;mbuilder); <br>  mbuilder-&gt;AddFrame(frame); <br>  mbuilder-&gt;GetBox(&amp;box); <br>  mbuilder-&gt;Release(); <br> <br>  maxDim = box.max.x - box.min.x; <br>  if (box.max.y - box.min.y &gt; maxDim)  <br>    maxDim = box.max.y - box.min.y; <br>  if (box.max.z - box.min.z &gt; maxDim) <br>    maxDim = box.max.z - box.min.z; <br> <br>  frame-&gt;AddScale(D3DRMCOMBINE_BEFORE, D3DDivide(D3DVAL(8.0), maxDim), <br>  D3DDivide(D3DVAL(8.0), maxDim), <br>  D3DDivide(D3DVAL(8.0), maxDim)); <br> <br>  frame-&gt;SetPosition(info-&gt;scene, D3DVAL(0.0), D3DVAL(0.0), D3DVAL(15.0)); <br> <br>  return TRUE; <br>} <br> <br> <br>typedef struct { <br>    LPDIRECT3DRMANIMATIONSET animset; <br>    D3DVALUE time; <br>} animationCallbackArgs; <br> <br>static void CDECL animationCallback(LPDIRECT3DRMFRAME obj, void* arg, D3DVALUE delta) <br>{ <br>    animationCallbackArgs* cb = (animationCallbackArgs *) arg; <br> <br>    obj = obj; <br>    cb-&gt;animset-&gt;SetTime(cb-&gt;time); <br>    cb-&gt;time += delta; <br>} <br> <br>static BOOL setAnimationCallback(LPDIRECT3DRMFRAME frame,  <br> LPDIRECT3DRMANIMATIONSET animset) <br>{ <br>    animationCallbackArgs *cb; <br> <br>    cb = (animationCallbackArgs*)malloc(sizeof(animationCallbackArgs)); <br>    if (!cb) <br>return FALSE; <br> <br>    cb-&gt;animset = animset; <br>    cb-&gt;time = D3DVAL(0); <br>    if (FAILED(frame-&gt;AddMoveCallback(animationCallback, (void *) cb))) <br>return FALSE; <br>    return TRUE; <br>} <br> <br>static BOOL LoadAnimationSet(const char *filename, AppInfo *info) <br>{ <br>  LPDIRECT3DRMANIMATIONSET lpAnimSet; <br>  LPDIRECT3DRMFRAME2 lpFrame; <br> <br>  /* Create a new parent frame for the animation, load it, and set up the <br>     callback */ <br>   <br>  if (FAILED(lpD3DRM-&gt;CreateFrame(info-&gt;scene, &amp;lpFrame)))  <br>    return FALSE; <br> <br>  if (FAILED(lpD3DRM-&gt;CreateAnimationSet(&amp;lpAnimSet)))  <br>    return FALSE; <br> <br>  if (FAILED(lpAnimSet-&gt;Load((LPVOID)filename, NULL,  <br>     D3DRMLOAD_FROMFILE, loadTextures, <br>     NULL, lpFrame))) <br>    return FALSE; <br> <br>  ScaleScene(lpFrame, info); <br> <br>  setAnimationCallback(lpFrame, lpAnimSet); <br> <br>  return TRUE; <br>} <br>   <br>static BOOL LoadFrameHierarchy(const char *filename, AppInfo *info) <br>{ <br>  LPDIRECT3DRMFRAME2 lpFrame; <br>   <br>  if (FAILED(lpD3DRM-&gt;CreateFrame(info-&gt;scene, &amp;lpFrame))) <br>    return FALSE; <br> <br>  if (FAILED(lpFrame-&gt;Load((LPVOID)filename, NULL, D3DRMLOAD_FROMFILE, <br>   loadTextures, NULL))) <br>    return FALSE; <br> <br>  ScaleScene(lpFrame, info); <br> <br>  return TRUE; <br>} <br> <br> <br>static int <br>    left_drag = FALSE, right_drag = FALSE, <br>    last_x, last_y; <br> <br>/* <br> * Render the scene into the viewport. <br> */ <br>static BOOL Render() { <br>    if (FAILED(active_window-&gt;scene-&gt;Move(D3DVAL(1.0)))) <br>return FALSE; <br>    if (FAILED(active_window-&gt;view-&gt;Clear())) <br>return FALSE; <br>    if (FAILED(active_window-&gt;view-&gt;Render(active_window-&gt;scene))) <br>return FALSE; <br>    if (FAILED(active_window-&gt;dev-&gt;Update())) <br>return FALSE; <br>    return TRUE; <br>} <br> <br>static void Idle() <br>{ <br>    LPDIRECT3DRMFRAME selected = SelectedFrame(); <br> <br>    if (active_window == NULL) return; <br>    if (left_drag &amp;&amp; selected) <br>selected-&gt;SetRotation(active_window-&gt;scene, D3DVAL(0.0), D3DVAL(1.0), D3DVAL(0.0), D3DVAL(0.0)); <br>    if (right_drag &amp;&amp; selected) <br>selected-&gt;SetVelocity(active_window-&gt;scene, D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0), FALSE); <br>} <br> <br>static int FillModeToMenuItem(D3DRMFILLMODE fm) <br>{ <br>    switch (fm) { <br>    case D3DRMFILL_POINTS: <br>return 2; <br> <br>    case D3DRMFILL_WIREFRAME: <br>return 3; <br> <br>    case D3DRMFILL_SOLID: <br>return 4; <br>    } <br>    return -1; <br>} <br> <br>static int ShadeModeToMenuItem(D3DRMSHADEMODE sm) <br>{ <br>    switch (sm) { <br>    case D3DRMSHADE_FLAT: <br>return 6; <br> <br>    case D3DRMSHADE_GOURAUD: <br>return 7; <br> <br>    case D3DRMSHADE_PHONG: <br>return 8; <br>    } <br>    return -1; <br>} <br> <br>static BOOL ToggleLighting(HWND win, AppInfo* info) <br>{ <br>    HMENU menu; <br>    D3DRMRENDERQUALITY quality = info-&gt;dev-&gt;GetQuality(); <br>    D3DRMLIGHTMODE mode = (D3DRMLIGHTMODE)(quality &amp; D3DRMLIGHT_MASK); <br>    HRESULT rval; <br> <br>    if (mode == D3DRMLIGHT_ON) <br>mode = D3DRMLIGHT_OFF; <br>    else <br>mode = D3DRMLIGHT_ON; <br> <br>    menu = GetMenu(win); <br>    menu = GetSubMenu(menu, 2); <br>    CheckMenuItem(menu, 0, (MF_BYPOSITION <br>    | (mode == D3DRMLIGHT_ON <br>       ? MF_CHECKED <br>       : MF_UNCHECKED))); <br> <br>    quality = (quality &amp; ~D3DRMLIGHT_MASK) | mode; <br>    rval = info-&gt;dev-&gt;SetQuality(quality); <br>    if (rval != D3DRM_OK) { <br>Msg("Setting the render quality while toggling lighting failed.\n%s", MyErrorToString(rval)); <br>return FALSE; <br>    } <br>    return TRUE; <br>} <br> <br>static BOOL SetFillMode(HWND win, AppInfo* info, D3DRMFILLMODE fm) <br>{ <br>    HMENU menu; <br>    D3DRMRENDERQUALITY quality = info-&gt;dev-&gt;GetQuality(); <br>    D3DRMFILLMODE oldfm = (D3DRMFILLMODE)(quality &amp; D3DRMFILL_MASK); <br>    HRESULT rval; <br> <br>    menu = GetMenu(win); <br>    menu = GetSubMenu(menu, 2); <br>    CheckMenuItem(menu, FillModeToMenuItem(oldfm), <br>  MF_BYPOSITION|MF_UNCHECKED); <br>    CheckMenuItem(menu, FillModeToMenuItem(fm), <br>  MF_BYPOSITION|MF_CHECKED); <br> <br>    quality = (quality &amp; ~D3DRMFILL_MASK) | fm; <br>    rval = info-&gt;dev-&gt;SetQuality(quality); <br>    if (rval != D3DRM_OK) { <br>Msg("Setting the render quality while changing the fill mode failed.\n%s", MyErrorToString(rval)); <br>return FALSE; <br>    } <br>    return TRUE; <br>} <br> <br>static BOOL SetShadeMode(HWND win, AppInfo* info, D3DRMSHADEMODE sm) <br>{ <br>    HMENU menu; <br>    D3DRMRENDERQUALITY quality = info-&gt;dev-&gt;GetQuality(); <br>    D3DRMSHADEMODE oldsm = (D3DRMSHADEMODE)(quality &amp; D3DRMSHADE_MASK); <br>    HRESULT rval; <br> <br>    menu = GetMenu(win); <br>    menu = GetSubMenu(menu, 2); <br>    CheckMenuItem(menu, ShadeModeToMenuItem(oldsm), <br>  MF_BYPOSITION|MF_UNCHECKED); <br>    CheckMenuItem(menu, ShadeModeToMenuItem(sm), <br>  MF_BYPOSITION|MF_CHECKED); <br> <br>    quality = (quality &amp; ~D3DRMSHADE_MASK) | sm; <br>    rval = info-&gt;dev-&gt;SetQuality(quality); <br>    if (rval != D3DRM_OK) { <br>Msg("Setting the render quality while changing the shade mode failed.\n%s", MyErrorToString(rval)); <br>return FALSE; <br>    } <br>    return TRUE; <br>} <br> <br>static BOOL SetModel(HWND win, AppInfo* info, D3DRMCOLORMODEL model) <br>{ <br>    HMENU menu; <br>    D3DRMCOLORMODEL oldModel = info-&gt;model; <br> <br>    if (oldModel == model) return TRUE; <br> <br>    info-&gt;model = model; <br>    if (!RebuildDevice(win, info, info-&gt;dev-&gt;GetWidth(), info-&gt;dev-&gt;GetHeight())) <br>return FALSE; <br> <br>    menu = GetMenu(win); <br>    menu = GetSubMenu(menu, 2); <br>    CheckMenuItem(menu, 9 + (int) oldModel, MF_BYPOSITION|MF_UNCHECKED); <br>    CheckMenuItem(menu, 9 + (int) model, MF_BYPOSITION|MF_CHECKED); <br>    return TRUE; <br>} <br> <br>static BOOL ToggleDither(HWND win, AppInfo *info) <br>{ <br>    HMENU menu; <br>    int dither = info-&gt;dev-&gt;GetDither(); <br>    int checked; <br>    dither = !dither; <br>    if (FAILED(info-&gt;dev-&gt;SetDither(dither))) { <br>Msg("Toggling dithering failed.\n"); <br>return FALSE; <br>    } <br>    menu = GetMenu(win); <br>    menu = GetSubMenu(menu, 2); <br> <br>    if (dither) checked = MF_CHECKED; <br>    else checked = MF_UNCHECKED; <br> <br>    //CheckMenuItem(menu, MENU_DITHER, MF_BYCOMMAND|checked); <br>    CheckMenuItem(menu, 13, MF_BYPOSITION|checked); <br>    return TRUE; <br>} <br> <br>static BOOL ToggleTextureFiltering(HWND win, AppInfo *info) <br>{ <br>    HMENU menu; <br>    D3DRMTEXTUREQUALITY tq = info-&gt;dev-&gt;GetTextureQuality(); <br>    int checked; <br>    if (tq == D3DRMTEXTURE_NEAREST) <br>tq = D3DRMTEXTURE_LINEAR; <br>    else <br>tq = D3DRMTEXTURE_NEAREST; <br> <br>    if (FAILED(info-&gt;dev-&gt;SetTextureQuality(tq))) { <br>Msg("Setting texture quality failed.\n"); <br>return FALSE; <br>    } <br>    menu = GetMenu(win); <br>    menu = GetSubMenu(menu, 2); <br> <br>    if (tq == D3DRMTEXTURE_LINEAR) checked = MF_CHECKED; <br>    else checked = MF_UNCHECKED; <br> <br>    CheckMenuItem(menu, 14, MF_BYPOSITION|checked); <br>    return TRUE; <br>} <br> <br>static BOOL <br>CreateLight(WPARAM wparam, AppInfo* info) <br>{ <br>    LPDIRECT3DRMMESHBUILDER2 builder = NULL; <br>    LPDIRECT3DRMLIGHT light = NULL; <br>    LPDIRECT3DRMFRAME2 frame = NULL; <br>    HRESULT rval; <br> <br>    if (FAILED(lpD3DRM-&gt;CreateMeshBuilder(&amp;builder))) <br>goto generic_error; <br> <br>    if (wparam == MENU_LIGHT_DIRECTIONAL) { <br>rval = builder-&gt;Load("camera.x", NULL, D3DRMLOAD_FROMFILE, <br>     NULL, NULL); <br>if (rval != D3DRM_OK) { <br>    Msg("Failed to load camera.x.\n%s", MyErrorToString(rval)); <br>    goto ret_with_error; <br>} <br>if (FAILED(builder-&gt;SetQuality(D3DRMRENDER_UNLITFLAT))) <br>    goto generic_error; <br>if (FAILED(lpD3DRM-&gt;CreateLightRGB <br>    (D3DRMLIGHT_DIRECTIONAL, D3DVAL(1.0), D3DVAL(1.0), D3DVAL(1.0), &amp;light))) <br>    goto generic_error; <br>    } else if (wparam == MENU_LIGHT_PARALLEL_POINT) { <br>rval = builder-&gt;Load("sphere2.x", NULL, D3DRMLOAD_FROMFILE, <br>     NULL, NULL); <br>if (rval != D3DRM_OK) { <br>    Msg("Failed to load sphere2.x.\n%s", MyErrorToString(rval)); <br>    goto ret_with_error; <br>} <br>if (FAILED(builder-&gt;SetQuality(D3DRMRENDER_UNLITFLAT))) <br>    goto generic_error; <br>if (FAILED(builder-&gt;Scale(D3DVAL(0.2), D3DVAL(0.2), D3DVAL(0.2)))) <br>    goto generic_error; <br>if (FAILED(lpD3DRM-&gt;CreateLightRGB <br>    (D3DRMLIGHT_PARALLELPOINT, D3DVAL(1.0), D3DVAL(1.0), D3DVAL(1.0), &amp;light))) <br>    goto generic_error; <br>    } else if (wparam == MENU_LIGHT_POINT) { <br>rval = builder-&gt;Load("sphere2.x", NULL, D3DRMLOAD_FROMFILE, <br>     NULL, NULL); <br>if (rval != D3DRM_OK) { <br>    Msg("Failed to load sphere2.x.\n%s", MyErrorToString(rval)); <br>    goto ret_with_error; <br>} <br>if (FAILED(builder-&gt;SetQuality(D3DRMRENDER_UNLITFLAT))) <br>    goto generic_error; <br>if (FAILED(builder-&gt;Scale(D3DVAL(0.2), D3DVAL(0.2), D3DVAL(0.2)))) <br>    goto generic_error; <br>if (FAILED(lpD3DRM-&gt;CreateLightRGB <br>    (D3DRMLIGHT_POINT, D3DVAL(1.0), D3DVAL(1.0), D3DVAL(1.0), &amp;light))) <br>    goto generic_error; <br>    } else if (wparam == MENU_LIGHT_SPOT) { <br>rval = builder-&gt;Load("camera.x", NULL, D3DRMLOAD_FROMFILE, <br>     NULL, NULL); <br>if (rval != D3DRM_OK) { <br>    Msg("Failed to load camera.x.\n%s", MyErrorToString(rval)); <br>    goto ret_with_error; <br>} <br>if (FAILED(builder-&gt;SetQuality(D3DRMRENDER_UNLITFLAT))) <br>    goto generic_error; <br>if (FAILED(lpD3DRM-&gt;CreateLightRGB(D3DRMLIGHT_SPOT, D3DVAL(1.0), D3DVAL(1.0), D3DVAL(1.0), &amp;light))) <br>    goto generic_error; <br>    } <br>    if (FAILED(lpD3DRM-&gt;CreateFrame(info-&gt;scene, &amp;frame))) <br>goto generic_error; <br>    if (FAILED(frame-&gt;SetPosition(info-&gt;camera, D3DVAL(0.0), D3DVAL(0.0), D3DVAL(10.0)))) <br>goto generic_error; <br>    if (FAILED(frame-&gt;AddVisual(builder))) <br>goto generic_error; <br>    if (FAILED(frame-&gt;AddLight(light))) <br>goto generic_error; <br> <br>    builder-&gt;Release(), frame-&gt;Release(), light-&gt;Release(); <br>    return TRUE; <br>generic_error: <br>    Msg("A failure occurred while creating a new light.\n"); <br>ret_with_error: <br>    RELEASE(builder); <br>    RELEASE(light); <br>    RELEASE(frame); <br>    return FALSE; <br>} <br> <br>HRESULT loadTextures(char *name, void *arg, LPDIRECT3DRMTEXTURE *tex) <br>{ <br>    /* IDirect3DRM::LoadTexture checks whether the texture is a PPM or <br>    BMP which it knows how to load. If you want to load other formats  <br>    you could add code to the callback to load the code into an D3DRMIMAGE <br>    structure and call IDirect3DRM::CreateTexture */ <br>     <br>    return lpD3DRM1-&gt;LoadTexture(name, tex); <br>} <br> <br>#define SIGN_EXTEND(w)    ((((int)(w)) &lt;&lt; 16) &gt;&gt; 16) <br> <br>/* <br> * Handle messages for the main application window <br> */ <br>LONG FAR PASCAL WindowProc(HWND win, UINT msg, WPARAM wparam, LPARAM lparam) <br>{ <br>    static HCURSOR oldCursor = NULL; <br>    AppInfo *info; <br>    LPDIRECT3DRMFRAME sFrame = SelectedFrame(); <br>    LPDIRECT3DRMVISUAL sVisual = SelectedVisual(); <br> <br>    info = (AppInfo *) GetWindowLong(win, 0); <br>    active_window = info; <br> <br>    switch (msg) <br>    { <br>    case WM_KEYDOWN: <br>{   D3DVECTOR dir, up, right; </code></pre>
<p>
</p>
<pre><code><br>    info-&gt;camera-&gt;GetOrientation(info-&gt;scene, &amp;dir, &amp;up); <br>    D3DRMVectorCrossProduct(&amp;right, &amp;up, &amp;dir); <br>    up.x /= D3DVAL(4.0); <br>    up.y /= D3DVAL(4.0); <br>    up.z /= D3DVAL(4.0); <br>    right.x /= D3DVAL(4.0); <br>    right.y /= D3DVAL(4.0); <br>    right.z /= D3DVAL(4.0); <br> <br>    switch (wparam) <br>    { <br>    case 'T': <br>info-&gt;camera-&gt;SetVelocity(info-&gt;scene, dir.x, dir.y, dir.z, FALSE); <br>break; <br> <br>    case 'Y': <br>info-&gt;camera-&gt;SetVelocity(info-&gt;scene, D3DVAL(-100.0) * dir.x, <br>  D3DVAL(-100.0) * dir.y,  <br>  D3DVAL(-100.0) * dir.z, FALSE); <br> <br>    case 'R': <br>info-&gt;camera-&gt;SetVelocity(info-&gt;scene, -dir.x, -dir.y, -dir.z, FALSE); <br>break; <br>  <br>    case 'E': <br>info-&gt;camera-&gt;SetVelocity(info-&gt;scene, D3DVAL(100.0) * dir.x, <br>  D3DVAL(100.0) * dir.y,  <br>  D3DVAL(100.0) * dir.z, FALSE); <br>    case VK_UP: <br>info-&gt;camera-&gt;SetVelocity(info-&gt;scene, up.x, up.y, up.z, FALSE); <br>break; <br> <br>    case VK_DOWN: <br>info-&gt;camera-&gt;SetVelocity(info-&gt;scene, -up.x, -up.y, -up.z, FALSE); <br>break; <br> <br>    case VK_RIGHT: <br>info-&gt;camera-&gt;SetVelocity(info-&gt;scene, right.x, right.y, right.z, FALSE); <br>break; <br> <br>    case VK_LEFT: <br>info-&gt;camera-&gt;SetVelocity(info-&gt;scene, -right.x, -right.y, -right.z, FALSE); <br>break; <br> <br>    case 'X': <br>if (sFrame) <br>    sFrame-&gt;SetVelocity(info-&gt;scene, dir.x, dir.y, dir.z, FALSE); <br>break; <br> <br>    case 'Z': <br>if (sFrame) <br>    sFrame-&gt;SetVelocity(info-&gt;scene, -dir.x, -dir.y, -dir.z, FALSE); <br>break; <br> <br>    case VK_SUBTRACT: <br>if (sFrame) <br>{   sFrame-&gt;AddScale(D3DRMCOMBINE_BEFORE, D3DVAL(0.9), D3DVAL(0.9), D3DVAL(0.9)); <br>    SelectVisual(sVisual, sFrame); <br>} <br>break; <br> <br>    case VK_ADD: <br>if (sFrame) <br>{   sFrame-&gt;AddScale(D3DRMCOMBINE_BEFORE, D3DVAL(1.1), D3DVAL(1.1), D3DVAL(1.1)); <br>    SelectVisual(sVisual, sFrame); <br>} <br>break; <br>    } <br>} <br>break; <br> <br>    case WM_KEYUP: <br>switch (wparam) <br>{ <br>case 'T': <br>case 'R': <br>case VK_UP: <br>case VK_DOWN: <br>case VK_LEFT: <br>case VK_RIGHT: <br>    info-&gt;camera-&gt;SetVelocity(info-&gt;scene, D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0), FALSE); <br>    break; <br> <br>case 'Z': <br>case 'X': <br>    if (sFrame) <br>sFrame-&gt;SetVelocity(info-&gt;scene, D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0), FALSE); <br>    break; <br>} <br>break; <br> <br>    case WM_LBUTTONDOWN: <br>{   HCURSOR hCur; <br>    int x = LOWORD(lparam); <br>    int y = HIWORD(lparam); <br>    last_x = x; <br>    last_y = y; <br>    FindAndSelectVisual(info-&gt;view, x, y); <br>    left_drag = TRUE; <br>    SetCapture(win); <br>    /* change to a groovy cursor */ <br>    hCur = LoadCursor(NULL, IDC_ARROW); <br>    if (hCur) oldCursor = SetCursor(hCur); <br>    else oldCursor = NULL; <br>} <br>break; <br> <br>    case WM_LBUTTONUP: <br>ReleaseCapture(); <br>left_drag = FALSE; <br>if (oldCursor) SetCursor(oldCursor); <br>break; <br> <br>    case WM_RBUTTONDOWN: <br>{ <br>    HCURSOR hCur; <br>    int x = LOWORD(lparam); <br>    int y = HIWORD(lparam); <br>    last_x = x; <br>    last_y = y; <br>    FindAndSelectVisual(info-&gt;view, x, y); <br>    right_drag = TRUE; <br>    SetCapture(win); <br>    /* change to a groovy cursor */ <br>    hCur = LoadCursor(NULL, IDC_ARROW); <br>    if (hCur) oldCursor = SetCursor(hCur); <br>    else oldCursor = NULL; <br>} <br>break; <br> <br>    case WM_RBUTTONUP: <br>right_drag = FALSE; <br>ReleaseCapture(); <br>if (oldCursor) SetCursor(oldCursor); <br>break; <br> <br>    case WM_MOUSEMOVE: <br>if ((wparam &amp; MK_LBUTTON) &amp;&amp; sFrame &amp;&amp; left_drag) <br>{   double delta_x, delta_y; <br>    delta_x = SIGN_EXTEND(LOWORD(lparam)) - last_x; <br>    delta_y = -SIGN_EXTEND((HIWORD(lparam)) - last_y); <br>    last_x = SIGN_EXTEND(LOWORD(lparam)); <br>    last_y = SIGN_EXTEND(HIWORD(lparam)); <br>    { <br>double delta_r = sqrt(delta_x * delta_x + delta_y * delta_y); <br>double radius = 50; <br>double denom; <br> <br>denom = sqrt(radius * radius + delta_r * delta_r); <br> <br>if (delta_r == 0 || denom == 0) break; <br>sFrame-&gt;SetRotation <br>(   info-&gt;camera, <br>    D3DDivide(D3DVAL((float) delta_y), D3DVAL((float) delta_r)), <br>    D3DDivide(D3DVAL((float) -delta_x), D3DVAL((float) delta_r)), <br>    D3DVAL(0.0), <br>    D3DDivide(D3DVAL((float) delta_r), D3DVAL((float) denom)) <br>); <br>    } <br>} <br>else if ((wparam &amp; MK_RBUTTON) &amp;&amp; sFrame &amp;&amp; right_drag) <br>{   double delta_x, delta_y; <br>    D3DVECTOR p1; <br>    D3DRMVECTOR4D p2; <br> <br>    delta_x = SIGN_EXTEND(LOWORD(lparam)) - last_x; <br>    delta_y = SIGN_EXTEND(HIWORD(lparam)) - last_y; <br>    last_x = SIGN_EXTEND(LOWORD(lparam)); <br>    last_y = SIGN_EXTEND(HIWORD(lparam)); <br>    sFrame-&gt;GetPosition(info-&gt;scene, &amp;p1); <br>    info-&gt;view-&gt;Transform(&amp;p2, &amp;p1); <br>    p2.x += D3DMultiply(D3DVAL((float)delta_x), p2.w); <br>    p2.y += D3DMultiply(D3DVAL((float)delta_y), p2.w); <br>    info-&gt;view-&gt;InverseTransform(&amp;p1, &amp;p2); <br>    sFrame-&gt;SetPosition(info-&gt;scene, p1.x, p1.y, p1.z); <br>} <br>break; <br> <br>    case WM_VSCROLL: <br>    { <br>if (active_window-&gt;lpPM) <br>{ <br>    HRESULT hres; <br>    float fVal = gfVal; <br>     <br>    switch (LOWORD(wparam)) <br>    { <br>    case SB_THUMBPOSITION: <br>fVal = (1.0F - ((float)HIWORD(wparam) / 100.0F)); <br>break; <br>    case SB_LINEUP: <br>fVal += 0.01F; <br>break; <br>    case SB_LINEDOWN: <br>fVal -= 0.01F; <br>break; <br>    case SB_PAGEUP: <br>fVal += 0.1F; <br>break; <br>    case SB_PAGEDOWN: <br>fVal -= 0.1F; <br>break; <br>    case SB_THUMBTRACK: <br>fVal = (1.0F - ((float)HIWORD(wparam) / 100.0F)); <br>break;  <br>    default: <br>return 0; <br>    } <br> <br>    if (fVal &gt; 1.0F) <br>    { <br>fVal = 1.0F; <br>    } <br>    if (fVal &lt; 0.0F) <br>    { <br>fVal = 0.0F; <br>    } <br>     <br>    hres = active_window-&gt;lpPM-&gt;SetDetail(fVal); <br>    gfVal = fVal; <br> <br>    if (SUCCEEDED(hres)) <br>    { <br>SetScrollPos(win, SB_VERT, (DWORD)(100.0 - (DWORD)(fVal * 100.0)), <br>     TRUE); <br>    } <br>    else <br>    { <br>if (hres != D3DRMERR_NOTENOUGHDATA) <br>{ <br>    Msg("Error setting PM vertex detail"); <br>} <br>    } <br>} <br>return 0; <br>    } <br>    case WM_COMMAND: <br>switch( wparam &amp; 0xffff ) <br>{ <br>case MENU_FILE_ABOUT: <br>            DialogBox((HINSTANCE) GetWindowLong(win, GWL_HINSTANCE),"AboutBox", win, (DLGPROC)AboutDlgProc); <br>    break; <br> <br>case MENU_FILE_OPEN: <br>  {  LPDIRECT3DRMMESHBUILDER2 builder; <br>     HRESULT rval; <br>     char *file = OpenNewFile(win, "Open a Mesh file"); <br>     if (file) <br>       { <br> if (FAILED(lpD3DRM-&gt;CreateMeshBuilder(&amp;builder))) { <br>   Msg("Failed the create a builder for the new mesh.\n"); <br>   break; <br> } <br> rval = builder-&gt;Load(file, NULL, D3DRMLOAD_FROMFILE, <br>      loadTextures, NULL); <br> if (rval != D3DRM_OK) { <br>   Msg("Loading %s failed.\n%s", file, MyErrorToString(rval)); <br>   builder-&gt;Release(); <br>   break; <br> } <br> if (!PlaceMesh((LPDIRECT3DRMVISUAL)builder, info)) { <br>   Msg("Placing the mesh in the scene failed.\n"); <br>   builder-&gt;Release(); <br>   break; <br> } <br> builder-&gt;Release(); <br>       } <br> <br>     /*LoadAnimationSet(file, info);*/ <br>     break; <br>  } <br> <br>case MENU_FILE_OPEN_PMESH: <br>  {  LPDIRECT3DRMPROGRESSIVEMESH lpMesh; <br>     HRESULT rval; <br>     char *file = OpenNewFile(win, "Open a Progressive Mesh file"); <br>     if (file) <br>       { <br> if (FAILED(lpD3DRM-&gt;CreateProgressiveMesh(&amp;lpMesh))) { <br>   Msg("Failed to create a new progressive mesh.\n"); <br>   break; <br> } <br> rval = lpMesh-&gt;Load(file, NULL, <br>     D3DRMLOAD_FROMFILE | <br>     D3DRMLOAD_ASYNCHRONOUS, <br>     NULL, NULL); <br> if (rval != D3DRM_OK) { <br>   Msg("Loading %s failed.\n%s", file, MyErrorToString(rval)); <br>   lpMesh-&gt;Release(); <br>   break; <br> } <br> if (!PlaceMesh((LPDIRECT3DRMVISUAL)lpMesh, info)) { <br>   Msg("Placing the mesh in the scene failed.\n"); <br>   lpMesh-&gt;Release(); <br>   break; <br> } <br> lpMesh-&gt;Release(); <br>       } <br>     break; <br>  } <br> <br>case MENU_FILE_OPEN_ANIMSET: <br>  { <br>    char *file = OpenNewFile(win, "Open Animation ..."); <br>    if (file) { <br>      if (LoadAnimationSet(file, info) == FALSE) { <br>Msg("Loading and placing of %s failed.\n", file); <br>      } <br>    } <br>    break; <br>  } <br> <br>case MENU_FILE_OPEN_FRAME: <br>    { <br>      char *file = OpenNewFile(win, "Open Frame ..."); <br>      if (file) { <br>if (LoadFrameHierarchy(file, info) == FALSE) { <br>  Msg("Loading and placing of %s failed.\n", file); <br>} <br>      } <br>      break; <br>    } <br> <br>case MENU_FILE_EXIT: <br>    PostQuitMessage(0); <br>    break; <br> <br>case MENU_EDIT_CUT: <br>    CutVisual(); <br>    break; <br> <br>case MENU_EDIT_COPY: <br>    CopyVisual(); <br>    break; <br> <br>case MENU_EDIT_PASTE: <br>    PasteVisual(info-&gt;scene); <br>    break; <br> <br>case MENU_EDIT_DELETE: <br>    DeleteVisual(); <br>    break; <br> <br>case MENU_EDIT_COLOR: <br>    if (sFrame) <br>    { <br>LPDIRECT3DRMMESHBUILDER mesh; <br>HRESULT rval; <br> <br>if (FAILED(sVisual-&gt;QueryInterface(IID_IDirect3DRMMeshBuilder, <br>   (void**) &amp;mesh))) <br>    break; <br> <br>if (SelectedLight()) <br>{ <br>    D3DCOLOR c = SelectedLight()-&gt;GetColor(); <br> <br>    if (ChooseNewColor(win, &amp;c)) { <br>mesh-&gt;SetColor(c); <br>SelectedLight()-&gt;SetColor(c); <br>    } <br>} else { <br>    D3DCOLOR c; <br> <br>    if (mesh-&gt;GetFaceCount()) { <br>LPDIRECT3DRMFACEARRAY faces; <br>LPDIRECT3DRMFACE face; <br>mesh-&gt;GetFaces(&amp;faces); <br>faces-&gt;GetElement(0, &amp;face); <br>c = face-&gt;GetColor(); <br>RELEASE(face); <br>RELEASE(faces); <br>    } else <br>c = D3DRMCreateColorRGB(D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0)); <br> <br>    if (ChooseNewColor(win, &amp;c)) { <br>rval = mesh-&gt;SetColor(c); <br>if (rval != D3DRM_OK) <br>    Msg("Failed to set the mesh's color.\n%s", MyErrorToString(rval)); <br>    } <br>} <br> <br>RELEASE(mesh); <br>    } <br>    break; <br> <br>case MENU_EDIT_BOXES: <br>    { <br>HMENU menu; <br>int checked = ToggleBoxes() ? MF_CHECKED : MF_UNCHECKED; <br>menu = GetMenu(win); <br>menu = GetSubMenu(menu, 1); <br>CheckMenuItem(menu, MENU_EDIT_BOXES, MF_BYCOMMAND|checked); <br>    } <br>    break; <br> <br>case MENU_QUALITY_LIGHTING: <br>    ToggleLighting(win, info); <br>    break; <br> <br>case MENU_QUALITY_POINTS: <br>    SetFillMode(win, info, D3DRMFILL_POINTS); <br>    break; <br> <br>case MENU_QUALITY_WIREFRAME: <br>    SetFillMode(win, info, D3DRMFILL_WIREFRAME); <br>    break; <br> <br>case MENU_QUALITY_SOLID: <br>    SetFillMode(win, info, D3DRMFILL_SOLID); <br>    break; <br> <br>case MENU_QUALITY_FLAT: <br>    SetShadeMode(win, info, D3DRMSHADE_FLAT); <br>    break; <br> <br>case MENU_QUALITY_GOURAUD: <br>    SetShadeMode(win, info, D3DRMSHADE_GOURAUD); <br>    break; <br> <br>case MENU_QUALITY_PHONG: <br>    SetShadeMode(win, info, D3DRMSHADE_PHONG); <br>    break; <br> <br>case MENU_MODEL_MONO: <br>    if (!SetModel(win, info, D3DCOLOR_MONO)) <br>bQuit = TRUE; <br>    break; <br> <br>case MENU_MODEL_RGB: <br>    if (!SetModel(win, info, D3DCOLOR_RGB)) <br>bQuit = TRUE; <br>    break; <br> <br>case MENU_DITHER: <br>    ToggleDither(win, info); <br>    break; <br> <br>case MENU_TEXTURE_FILTERING: <br>    ToggleTextureFiltering(win, info); <br>    break; <br> <br>case MENU_LIGHT_DIRECTIONAL: <br>case MENU_LIGHT_PARALLEL_POINT: <br>case MENU_LIGHT_POINT: <br>case MENU_LIGHT_SPOT: <br>    { <br>CreateLight(wparam, info); <br>    } <br>    break; <br>} <br>break; <br> <br>    case WM_DESTROY: <br>PostQuitMessage( 0 ); <br>bQuit = TRUE; <br>break; <br> <br>    case WM_SIZE: <br>{ <br>    int width = LOWORD(lparam); <br>    int height = HIWORD(lparam); <br>if (width &amp;&amp; height) { <br>if (!ResizeViewport(win, info, width, height)) { <br>    bQuit = TRUE; <br>    break; <br>}    <br>active_window-&gt;bMinimized = FALSE; <br>} else { <br>active_window-&gt;bMinimized = TRUE; <br>} <br>} <br>break; <br> <br>    case WM_ACTIVATE: <br>{   LPDIRECT3DRMWINDEVICE windev; <br>    if (!info || !info-&gt;dev) break; <br>    if (SUCCEEDED(info-&gt;dev-&gt;QueryInterface(IID_IDirect3DRMWinDevice, (void **) &amp;windev))) <br>    {if (FAILED(windev-&gt;HandleActivate(wparam))) <br>    Msg("Failed to handle WM_ACTIVATE.\n"); <br>windev-&gt;Release(); <br>    } else { <br>Msg("Failed to create Windows device to handle WM_ACTIVATE.\n"); <br>    } <br>} <br>break; <br> <br>    case WM_PAINT: <br>if (info) <br>{   RECT r; <br>    PAINTSTRUCT ps; <br>    LPDIRECT3DRMWINDEVICE windev; <br> <br>    if (!info || !info-&gt;dev) break; <br>    if (GetUpdateRect(win, &amp;r, FALSE)) <br>    {BeginPaint(win, &amp;ps); <br>    if (SUCCEEDED(info-&gt;dev-&gt;QueryInterface(IID_IDirect3DRMWinDevice, (void **) &amp;windev))) <br>{   if (FAILED(windev-&gt;HandlePaint(ps.hdc))) <br>Msg("Failed to handle WM_PAINT.\n"); <br>    windev-&gt;Release(); <br>} else { <br>    Msg("Failed to create Windows device to handle WM_PAINT.\n"); <br>} <br>EndPaint(win, &amp;ps); <br>    } <br>} <br> <br>else return DefWindowProc(win, msg, wparam, lparam); <br> <br>    default: <br>return DefWindowProc(win, msg, wparam, lparam); <br>    } <br>    return 0L; <br>} <br> <br>/* <br> * MyErrorToString <br> * Returns a pointer to a string describing the given error code. <br> */ <br>char* <br>MyErrorToString(HRESULT error) <br>{ <br>    switch(error) { <br>        case DD_OK: <br>    /* Also includes D3D_OK and D3DRM_OK */ <br>            return "No error.\0"; <br>        case DDERR_ALREADYINITIALIZED: <br>            return "This object is already initialized.\0"; <br>        case DDERR_BLTFASTCANTCLIP: <br>            return "Return if a clipper object is attached to the source surface passed into a BltFast call.\0"; <br>        case DDERR_CANNOTATTACHSURFACE: <br>            return "This surface can not be attached to the requested surface.\0"; <br>        case DDERR_CANNOTDETACHSURFACE: <br>            return "This surface can not be detached from the requested surface.\0"; <br>        case DDERR_CANTCREATEDC: <br>            return "Windows can not create any more DCs.\0"; <br>        case DDERR_CANTDUPLICATE: <br>            return "Can't duplicate primary &amp; 3D surfaces, or surfaces that are implicitly created.\0"; <br>        case DDERR_CLIPPERISUSINGHWND: <br>            return "An attempt was made to set a cliplist for a clipper object that is already monitoring an hwnd.\0"; <br>        case DDERR_COLORKEYNOTSET: <br>            return "No src color key specified for this operation.\0"; <br>        case DDERR_CURRENTLYNOTAVAIL: <br>            return "Support is currently not available.\0"; <br>        case DDERR_DIRECTDRAWALREADYCREATED: <br>            return "A DirectDraw object representing this driver has already been created for this process.\0"; <br>        case DDERR_EXCEPTION: <br>            return "An exception was encountered while performing the requested operation.\0"; <br>        case DDERR_EXCLUSIVEMODEALREADYSET: <br>            return "An attempt was made to set the cooperative level when it was already set to exclusive.\0"; <br>        case DDERR_GENERIC: <br>            return "Generic failure.\0"; <br>        case DDERR_HEIGHTALIGN: <br>            return "Height of rectangle provided is not a multiple of reqd alignment.\0"; <br>        case DDERR_HWNDALREADYSET: <br>            return "The CooperativeLevel HWND has already been set. It can not be reset while the process has surfaces or palettes created.\0"; <br>        case DDERR_HWNDSUBCLASSED: <br>            return "HWND used by DirectDraw CooperativeLevel has been subclassed, this prevents DirectDraw from restoring state.\0"; <br>        case DDERR_IMPLICITLYCREATED: <br>            return "This surface can not be restored because it is an implicitly created surface.\0"; <br>        case DDERR_INCOMPATIBLEPRIMARY: <br>            return "Unable to match primary surface creation request with existing primary surface.\0"; <br>        case DDERR_INVALIDCAPS: <br>            return "One or more of the caps bits passed to the callback are incorrect.\0"; <br>        case DDERR_INVALIDCLIPLIST: <br>            return "DirectDraw does not support the provided cliplist.\0"; <br>        case DDERR_INVALIDDIRECTDRAWGUID: <br>            return "The GUID passed to DirectDrawCreate is not a valid DirectDraw driver identifier.\0"; <br>        case DDERR_INVALIDMODE: <br>            return "DirectDraw does not support the requested mode.\0"; <br>        case DDERR_INVALIDOBJECT: <br>            return "DirectDraw received a pointer that was an invalid DIRECTDRAW object.\0"; <br>        case DDERR_INVALIDPARAMS: <br>            return "One or more of the parameters passed to the function are incorrect.\0"; <br>        case DDERR_INVALIDPIXELFORMAT: <br>            return "The pixel format was invalid as specified.\0"; <br>        case DDERR_INVALIDPOSITION: <br>            return "Returned when the position of the overlay on the destination is no longer legal for that destination.\0"; <br>        case DDERR_INVALIDRECT: <br>            return "Rectangle provided was invalid.\0"; <br>        case DDERR_LOCKEDSURFACES: <br>            return "Operation could not be carried out because one or more surfaces are locked.\0"; <br>        case DDERR_NO3D: <br>            return "There is no 3D present.\0"; <br>        case DDERR_NOALPHAHW: <br>            return "Operation could not be carried out because there is no alpha accleration hardware present or available.\0"; <br>        case DDERR_NOBLTHW: <br>            return "No blitter hardware present.\0"; <br>        case DDERR_NOCLIPLIST: <br>            return "No cliplist available.\0"; <br>        case DDERR_NOCLIPPERATTACHED: <br>            return "No clipper object attached to surface object.\0"; <br>        case DDERR_NOCOLORCONVHW: <br>            return "Operation could not be carried out because there is no color conversion hardware present or available.\0"; <br>        case DDERR_NOCOLORKEY: <br>            return "Surface doesn't currently have a color key\0"; <br>        case DDERR_NOCOLORKEYHW: <br>            return "Operation could not be carried out because there is no hardware support of the destination color key.\0"; <br>        case DDERR_NOCOOPERATIVELEVELSET: <br>            return "Create function called without DirectDraw object method SetCooperativeLevel being called.\0"; <br>        case DDERR_NODC: <br>            return "No DC was ever created for this surface.\0"; <br>        case DDERR_NODDROPSHW: <br>            return "No DirectDraw ROP hardware.\0"; <br>        case DDERR_NODIRECTDRAWHW: <br>            return "A hardware-only DirectDraw object creation was attempted but the driver did not support any hardware.\0"; <br>        case DDERR_NOEMULATION: <br>            return "Software emulation not available.\0"; <br>        case DDERR_NOEXCLUSIVEMODE: <br>            return "Operation requires the application to have exclusive mode but the application does not have exclusive mode.\0"; <br>        case DDERR_NOFLIPHW: <br>            return "Flipping visible surfaces is not supported.\0"; <br>        case DDERR_NOGDI: <br>            return "There is no GDI present.\0"; <br>        case DDERR_NOHWND: <br>            return "Clipper notification requires an HWND or no HWND has previously been set as the CooperativeLevel HWND.\0"; <br>        case DDERR_NOMIRRORHW: <br>            return "Operation could not be carried out because there is no hardware present or available.\0"; <br>        case DDERR_NOOVERLAYDEST: <br>            return "Returned when GetOverlayPosition is called on an overlay that UpdateOverlay has never been called on to establish a destination.\0"; <br>        case DDERR_NOOVERLAYHW: <br>            return "Operation could not be carried out because there is no overlay hardware present or available.\0"; <br>        case DDERR_NOPALETTEATTACHED: <br>            return "No palette object attached to this surface.\0"; <br>        case DDERR_NOPALETTEHW: <br>            return "No hardware support for 16 or 256 color palettes.\0"; <br>        case DDERR_NORASTEROPHW: <br>            return "Operation could not be carried out because there is no appropriate raster op hardware present or available.\0"; <br>        case DDERR_NOROTATIONHW: <br>            return "Operation could not be carried out because there is no rotation hardware present or available.\0"; <br>        case DDERR_NOSTRETCHHW: <br>            return "Operation could not be carried out because there is no hardware support for stretching.\0"; <br>        case DDERR_NOT4BITCOLOR: <br>            return "DirectDrawSurface is not in 4 bit color palette and the requested operation requires 4 bit color palette.\0"; <br>        case DDERR_NOT4BITCOLORINDEX: <br>            return "DirectDrawSurface is not in 4 bit color index palette and the requested operation requires 4 bit color index palette.\0"; <br>        case DDERR_NOT8BITCOLOR: <br>            return "DirectDrawSurface is not in 8 bit color mode and the requested operation requires 8 bit color.\0"; <br>        case DDERR_NOTAOVERLAYSURFACE: <br>            return "Returned when an overlay member is called for a non-overlay surface.\0"; <br>        case DDERR_NOTEXTUREHW: <br>            return "Operation could not be carried out because there is no texture mapping hardware present or available.\0"; <br>        case DDERR_NOTFLIPPABLE: <br>            return "An attempt has been made to flip a surface that is not flippable.\0"; <br>        case DDERR_NOTFOUND: <br>            return "Requested item was not found.\0"; <br>        case DDERR_NOTLOCKED: <br>            return "Surface was not locked.  An attempt to unlock a surface that was not locked at all, or by this process, has been attempted.\0"; <br>        case DDERR_NOTPALETTIZED: <br>            return "The surface being used is not a palette-based surface.\0"; <br>        case DDERR_NOVSYNCHW: <br>            return "Operation could not be carried out because there is no hardware support for vertical blank synchronized operations.\0"; <br>        case DDERR_NOZBUFFERHW: <br>            return "Operation could not be carried out because there is no hardware support for zbuffer blitting.\0"; <br>        case DDERR_NOZOVERLAYHW: <br>            return "Overlay surfaces could not be z layered based on their BltOrder because the hardware does not support z layering of overlays.\0"; <br>        case DDERR_OUTOFCAPS: <br>            return "The hardware needed for the requested operation has already been allocated.\0"; <br>        case DDERR_OUTOFMEMORY: <br>            return "DirectDraw does not have enough memory to perform the operation.\0"; <br>        case DDERR_OUTOFVIDEOMEMORY: <br>            return "DirectDraw does not have enough memory to perform the operation.\0"; <br>        case DDERR_OVERLAYCANTCLIP: <br>            return "The hardware does not support clipped overlays.\0"; <br>        case DDERR_OVERLAYCOLORKEYONLYONEACTIVE: <br>            return "Can only have ony color key active at one time for overlays.\0"; <br>        case DDERR_OVERLAYNOTVISIBLE: <br>            return "Returned when GetOverlayPosition is called on a hidden overlay.\0"; <br>        case DDERR_PALETTEBUSY: <br>            return "Access to this palette is being refused because the palette is already locked by another thread.\0"; <br>        case DDERR_PRIMARYSURFACEALREADYEXISTS: <br>            return "This process already has created a primary surface.\0"; <br>        case DDERR_REGIONTOOSMALL: <br>            return "Region passed to Clipper::GetClipList is too small.\0"; <br>        case DDERR_SURFACEALREADYATTACHED: <br>            return "This surface is already attached to the surface it is being attached to.\0"; <br>        case DDERR_SURFACEALREADYDEPENDENT: <br>            return "This surface is already a dependency of the surface it is being made a dependency of.\0"; <br>        case DDERR_SURFACEBUSY: <br>            return "Access to this surface is being refused because the surface is already locked by another thread.\0"; <br>        case DDERR_SURFACEISOBSCURED: <br>            return "Access to surface refused because the surface is obscured.\0"; <br>        case DDERR_SURFACELOST: <br>            return "Access to this surface is being refused because the surface memory is gone. The DirectDrawSurface object representing this surface should have Restore called on it.\0"; <br>        case DDERR_SURFACENOTATTACHED: <br>            return "The requested surface is not attached.\0"; <br>        case DDERR_TOOBIGHEIGHT: <br>            return "Height requested by DirectDraw is too large.\0"; <br>        case DDERR_TOOBIGSIZE: <br>            return "Size requested by DirectDraw is too large, but the individual height and width are OK.\0"; <br>        case DDERR_TOOBIGWIDTH: <br>            return "Width requested by DirectDraw is too large.\0"; <br>        case DDERR_UNSUPPORTED: <br>            return "Action not supported.\0"; <br>        case DDERR_UNSUPPORTEDFORMAT: <br>            return "FOURCC format requested is unsupported by DirectDraw.\0"; <br>        case DDERR_UNSUPPORTEDMASK: <br>            return "Bitmask in the pixel format requested is unsupported by DirectDraw.\0"; <br>        case DDERR_VERTICALBLANKINPROGRESS: <br>            return "Vertical blank is in progress.\0"; <br>        case DDERR_WASSTILLDRAWING: <br>            return "Informs DirectDraw that the previous Blt which is transfering information to or from this Surface is incomplete.\0"; <br>        case DDERR_WRONGMODE: <br>            return "This surface can not be restored because it was created in a different mode.\0"; <br>        case DDERR_XALIGN: <br>            return "Rectangle provided was not horizontally aligned on required boundary.\0"; <br>        case D3DERR_BADMAJORVERSION: <br>            return "D3DERR_BADMAJORVERSION\0"; <br>        case D3DERR_BADMINORVERSION: <br>            return "D3DERR_BADMINORVERSION\0"; <br>        case D3DERR_EXECUTE_LOCKED: <br>            return "D3DERR_EXECUTE_LOCKED\0"; <br>        case D3DERR_EXECUTE_NOT_LOCKED: <br>            return "D3DERR_EXECUTE_NOT_LOCKED\0"; <br>        case D3DERR_EXECUTE_CREATE_FAILED: <br>            return "D3DERR_EXECUTE_CREATE_FAILED\0"; <br>        case D3DERR_EXECUTE_DESTROY_FAILED: <br>            return "D3DERR_EXECUTE_DESTROY_FAILED\0"; <br>        case D3DERR_EXECUTE_LOCK_FAILED: <br>            return "D3DERR_EXECUTE_LOCK_FAILED\0"; <br>        case D3DERR_EXECUTE_UNLOCK_FAILED: <br>            return "D3DERR_EXECUTE_UNLOCK_FAILED\0"; <br>        case D3DERR_EXECUTE_FAILED: <br>            return "D3DERR_EXECUTE_FAILED\0"; <br>        case D3DERR_EXECUTE_CLIPPED_FAILED: <br>            return "D3DERR_EXECUTE_CLIPPED_FAILED\0"; <br>        case D3DERR_TEXTURE_NO_SUPPORT: <br>            return "D3DERR_TEXTURE_NO_SUPPORT\0"; <br>        case D3DERR_TEXTURE_NOT_LOCKED: <br>            return "D3DERR_TEXTURE_NOT_LOCKED\0"; <br>        case D3DERR_TEXTURE_LOCKED: <br>            return "D3DERR_TEXTURELOCKED\0"; <br>        case D3DERR_TEXTURE_CREATE_FAILED: <br>            return "D3DERR_TEXTURE_CREATE_FAILED\0"; <br>        case D3DERR_TEXTURE_DESTROY_FAILED: <br>            return "D3DERR_TEXTURE_DESTROY_FAILED\0"; <br>        case D3DERR_TEXTURE_LOCK_FAILED: <br>            return "D3DERR_TEXTURE_LOCK_FAILED\0"; <br>        case D3DERR_TEXTURE_UNLOCK_FAILED: <br>            return "D3DERR_TEXTURE_UNLOCK_FAILED\0"; <br>        case D3DERR_TEXTURE_LOAD_FAILED: <br>            return "D3DERR_TEXTURE_LOAD_FAILED\0"; <br>        case D3DERR_MATRIX_CREATE_FAILED: <br>            return "D3DERR_MATRIX_CREATE_FAILED\0"; <br>        case D3DERR_MATRIX_DESTROY_FAILED: <br>            return "D3DERR_MATRIX_DESTROY_FAILED\0"; <br>        case D3DERR_MATRIX_SETDATA_FAILED: <br>            return "D3DERR_MATRIX_SETDATA_FAILED\0"; <br>        case D3DERR_SETVIEWPORTDATA_FAILED: <br>            return "D3DERR_SETVIEWPORTDATA_FAILED\0"; <br>        case D3DERR_MATERIAL_CREATE_FAILED: <br>            return "D3DERR_MATERIAL_CREATE_FAILED\0"; <br>        case D3DERR_MATERIAL_DESTROY_FAILED: <br>            return "D3DERR_MATERIAL_DESTROY_FAILED\0"; <br>        case D3DERR_MATERIAL_SETDATA_FAILED: <br>            return "D3DERR_MATERIAL_SETDATA_FAILED\0"; <br>        case D3DERR_LIGHT_SET_FAILED: <br>            return "D3DERR_LIGHT_SET_FAILED\0"; <br>case D3DRMERR_BADOBJECT: <br>    return "D3DRMERR_BADOBJECT\0"; <br>case D3DRMERR_BADTYPE: <br>    return "D3DRMERR_BADTYPE\0"; <br>case D3DRMERR_BADALLOC: <br>    return "D3DRMERR_BADALLOC\0"; <br>case D3DRMERR_FACEUSED: <br>    return "D3DRMERR_FACEUSED\0"; <br>case D3DRMERR_NOTFOUND: <br>    return "D3DRMERR_NOTFOUND\0"; <br>case D3DRMERR_NOTDONEYET: <br>    return "D3DRMERR_NOTDONEYET\0"; <br>case D3DRMERR_FILENOTFOUND: <br>    return "The file was not found.\0"; <br>case D3DRMERR_BADFILE: <br>    return "D3DRMERR_BADFILE\0"; <br>case D3DRMERR_BADDEVICE: <br>    return "D3DRMERR_BADDEVICE\0"; <br>case D3DRMERR_BADVALUE: <br>    return "D3DRMERR_BADVALUE\0"; <br>case D3DRMERR_BADMAJORVERSION: <br>    return "D3DRMERR_BADMAJORVERSION\0"; <br>case D3DRMERR_BADMINORVERSION: <br>    return "D3DRMERR_BADMINORVERSION\0"; <br>case D3DRMERR_UNABLETOEXECUTE: <br>    return "D3DRMERR_UNABLETOEXECUTE\0"; <br>        default: <br>            return "Unrecognized error value.\0"; <br>    } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
