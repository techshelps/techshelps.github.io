<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>D3DTEX.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3190"></a>D3DTEX.CPP</h2>
<pre><code>/************************************************************************** <br> D3DTexture class <br> <br> **************************************************************************/ <br>#define D3D_OVERLOADS <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;ddraw.h&gt; <br>#include &lt;d3d.h&gt; <br> <br>#include "d3dtex.h" <br> <br>/************************************************************************** <br> DEBUG junk <br> **************************************************************************/ <br>#if defined(DEBUG) || defined(_DEBUG) <br>static void DPF(char *fmt, ...) <br>{ <br>    char ach[128]; <br>    va_list va; <br>    va_start( va, fmt ); <br>    wvsprintf( ach, fmt, va ); <br>    va_end( va ); <br>    OutputDebugString("TEXTURE: "); <br>    OutputDebugString(ach); <br>    OutputDebugString("\r\n"); <br>} <br>#else <br>#define DPF if (0)  <br>#endif <br> <br>/************************************************************************** <br> ChooseTextureFormat <br> **************************************************************************/ <br> <br>typedef struct { <br>    DWORD           bpp;        // we want a texture format of this bpp <br>    DDPIXELFORMAT   ddpf;       // place the format here <br>}   FindTextureData; <br> <br>HRESULT CALLBACK FindTextureCallback(DDSURFACEDESC *DeviceFmt, LPVOID lParam) <br>{ <br>    FindTextureData * FindData = (FindTextureData *)lParam; <br>    DDPIXELFORMAT ddpf = DeviceFmt-&gt;ddpfPixelFormat; <br> <br>    DPF("FindTexture: %d %s%s%s %08X %08X %08X %08X",  <br>ddpf.dwRGBBitCount,  <br>        (ddpf.dwFlags &amp; (DDPF_ALPHA|DDPF_ALPHAPIXELS)) ? "ALPHA " : "",  <br>        (ddpf.dwFlags &amp;(DDPF_RGB)) ? "RGB " : "",  <br>        (ddpf.dwFlags &amp;(DDPF_PALETTEINDEXED8 | DDPF_PALETTEINDEXED4)) ? "PAL " : "",  <br>ddpf.dwRBitMask, <br>ddpf.dwGBitMask, <br>ddpf.dwBBitMask, <br>ddpf.dwRGBAlphaBitMask); <br> <br>    // <br>    // we use GetDC/BitBlt to init textures so we only <br>    // want to use formats that GetDC will support. <br>    // <br>    if (ddpf.dwFlags &amp; (DDPF_ALPHA|DDPF_ALPHAPIXELS)) <br>        return DDENUMRET_OK; <br> <br>    if (ddpf.dwRGBBitCount &lt;= 8 &amp;&amp; <br>        !(ddpf.dwFlags &amp; (DDPF_PALETTEINDEXED8 | DDPF_PALETTEINDEXED4))) <br>        return DDENUMRET_OK; <br> <br>    if (ddpf.dwRGBBitCount &gt; 8 &amp;&amp; !(ddpf.dwFlags &amp; DDPF_RGB)) <br>        return DDENUMRET_OK; <br> <br>    // <br>    // BUGBUG GetDC does not work for 1 or 4bpp YET! <br>    // <br>    if (ddpf.dwRGBBitCount &lt; 8) <br>        return DDENUMRET_OK; <br> <br>    // <br>    // keep the texture format that is nearest to the bitmap we have <br>    // <br>    if (FindData-&gt;ddpf.dwRGBBitCount == 0 || <br>       (ddpf.dwRGBBitCount &gt;= FindData-&gt;bpp &amp;&amp; <br>       (UINT)(ddpf.dwRGBBitCount - FindData-&gt;bpp) &lt; (UINT)(FindData-&gt;ddpf.dwRGBBitCount - FindData-&gt;bpp))) <br>    { <br>        FindData-&gt;ddpf = ddpf; <br>    } <br> <br>    return DDENUMRET_OK; <br>} <br> <br>void ChooseTextureFormat(IDirect3DDevice2 *Device, DWORD bpp, DDPIXELFORMAT *pddpf) <br>{ <br>    FindTextureData FindData; <br>    ZeroMemory(&amp;FindData, sizeof(FindData)); <br>    FindData.bpp = bpp; <br>    Device-&gt;EnumTextureFormats(FindTextureCallback, (LPVOID)&amp;FindData); <br>    *pddpf = FindData.ddpf; <br> <br>    DPF("ChooseTexture: %d %s%s%s %08X %08X %08X %08X",  <br>pddpf-&gt;dwRGBBitCount,  <br>        (pddpf-&gt;dwFlags &amp; (DDPF_ALPHA|DDPF_ALPHAPIXELS)) ? "ALPHA " : "",  <br>        (pddpf-&gt;dwFlags &amp;(DDPF_RGB)) ? "RGB " : "",  <br>        (pddpf-&gt;dwFlags &amp;(DDPF_PALETTEINDEXED8 | DDPF_PALETTEINDEXED4)) ? "PAL " : "",  <br>pddpf-&gt;dwRBitMask, <br>pddpf-&gt;dwGBitMask, <br>pddpf-&gt;dwBBitMask, <br>pddpf-&gt;dwRGBAlphaBitMask); <br>} <br> <br>/************************************************************************** <br> PaletteFromBitmap <br> **************************************************************************/ <br> <br>static IDirectDrawPalette * PaletteFromBitmap(IDirectDraw *DirectDraw, HBITMAP Bitmap) <br>{ <br>    IDirectDrawPalette *    Palette = NULL; <br>    HDC                     BitmapDC; <br>    DWORD                   adw[256]; <br>    int                     colors, i; <br> <br>    // <br>    // get the color table from the DIBSection <br>    // <br>    BitmapDC = CreateCompatibleDC(NULL); <br>    SelectObject(BitmapDC, Bitmap); <br>    colors = GetDIBColorTable(BitmapDC, 0, 256, (RGBQUAD *)adw); <br>    DeleteDC(BitmapDC); <br> <br>    if (colors != 0) <br>    { <br>        // <br>        // convert BGR to RGB (stupid IBM!) <br>        // <br>        for (i=0; i&lt;colors; i++) <br>            adw[i] = RGB(GetBValue(adw[i]),GetGValue(adw[i]),GetRValue(adw[i])); <br> <br>        // <br>        // create a DirectDraw palette for the texture. <br>        // <br>        DirectDraw-&gt;CreatePalette(colors &lt;= 16 ? DDPCAPS_4BIT : DDPCAPS_8BIT, <br>            (PALETTEENTRY *)adw, &amp;Palette, NULL); <br>    } <br> <br>    return Palette; <br>} <br> <br>/************************************************************************** <br> GetDD <br> <br> get the IDirectDraw from a IDirect3DDevice, we need the DD <br> to create surfaces. <br> <br> this function does not do a AddRef on the DirectDraw object <br> (ie you dont need to Release) <br> <br> NOTE if your app has this around as a global you can use <br> the global instead of this code. <br> <br> **************************************************************************/ <br>static IDirectDraw * GetDD(IDirect3DDevice2 *Device) <br>{ <br>    IDirectDraw *       DirectDraw; <br>    IDirectDrawSurface *Target; <br>    IDirectDrawSurface2*Target2; <br> <br>    // <br>    // get the render target (we need it to get the IDirectDraw) <br>    // <br>    if (Device==NULL || Device-&gt;GetRenderTarget(&amp;Target) != DD_OK) <br>        return NULL; <br> <br>    // <br>    // get the DirectDraw object, but first we need a IDirectDrawSurface2 <br>    // <br>    if (Target-&gt;QueryInterface(IID_IDirectDrawSurface2, (void**)&amp;Target2) != DD_OK) <br>        return NULL; <br>    Target-&gt;Release(); <br>    Target2-&gt;GetDDInterface((void**)&amp;DirectDraw); <br>    Target2-&gt;Release(); <br>    DirectDraw-&gt;Release();  // dont up ref count <br> <br>    return DirectDraw; <br>} <br> <br>/************************************************************************** <br> D3DTexture::Load <br> <br> load a bitmap from the resource, or bmp file and create a <br> D3D texture map <br> <br> **************************************************************************/ <br> <br>BOOL D3DTexture::Load(IDirect3DDevice2 *Device, char *BitmapName) <br>{ <br>    BITMAP              bm; <br>    DDSURFACEDESC       ddsd; <br>    HBITMAP             Bitmap; <br>    IDirectDraw *       DirectDraw; <br> <br>    DPF("D3DTexture::Load(%s)", BitmapName); <br> <br>    // <br>    // we need a IDirectDraw so we can create a surface. <br>    // <br>    if ((DirectDraw = GetDD(Device)) == NULL) <br>        return FALSE; <br> <br>    // <br>    // load the bitmap from a resource or file. <br>    // <br>    Bitmap = (HBITMAP)LoadImage(GetModuleHandle(NULL), BitmapName, IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION); <br> <br>    if (Bitmap == NULL) <br>        Bitmap = (HBITMAP)LoadImage(NULL, BitmapName, IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE|LR_CREATEDIBSECTION); <br> <br>    if (Bitmap == NULL) <br>        return FALSE; <br> <br>    // free any existing texture. <br>    Release(); <br> <br>    GetObject(Bitmap, sizeof(bm), &amp;bm);      // get size of bitmap <br> <br>    // <br>    // find the best texture format to use. <br>    // <br>    ZeroMemory(&amp;ddsd, sizeof(ddsd)); <br>    ddsd.dwSize = sizeof(ddsd); <br>    ChooseTextureFormat(Device, bm.bmBitsPixel, &amp;ddsd.ddpfPixelFormat); <br>    ddsd.dwFlags |= DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT; <br>    ddsd.dwWidth = bm.bmWidth; <br>    ddsd.dwHeight = bm.bmHeight; <br> <br>    // <br>    // create a video memory texture <br>    // <br>    // if we are dealing with a HAL create in video memory, else <br>    // create in system memory. <br>    // <br>    D3DDEVICEDESC hal, hel; <br>    ZeroMemory(&amp;hal, sizeof(hal)); <br>    hal.dwSize = sizeof(hal); <br>    ZeroMemory(&amp;hel, sizeof(hel)); <br>    hel.dwSize = sizeof(hel); <br>    Device-&gt;GetCaps(&amp;hal, &amp;hel); <br> <br>    // BUGBUG should we check for texture caps? <br>    if (hal.dcmColorModel) <br>        ddsd.ddsCaps.dwCaps = DDSCAPS_VIDEOMEMORY | DDSCAPS_TEXTURE | DDSCAPS_ALLOCONLOAD; <br>    else <br>        ddsd.ddsCaps.dwCaps = DDSCAPS_SYSTEMMEMORY| DDSCAPS_TEXTURE; <br> <br>    if (DirectDraw-&gt;CreateSurface(&amp;ddsd, &amp;DeviceSurface, NULL) != DD_OK) <br>        goto error; <br> <br>    // <br>    // create a system memory surface for the texture. <br>    // <br>    // we use this system memory surface for the ::Load call <br>    // and this surface does not get lost. <br>    // <br>    if (hal.dcmColorModel) <br>    { <br>        ddsd.ddsCaps.dwCaps = DDSCAPS_SYSTEMMEMORY | DDSCAPS_TEXTURE; <br> <br>        if (DirectDraw-&gt;CreateSurface(&amp;ddsd, &amp;MemorySurface, NULL) != DD_OK) <br>            goto error; <br>    } <br>    else <br>    { <br>        // <br>        // when dealing with a SW rasterizer we dont need to make two <br>        // surfaces. <br>        // <br>        MemorySurface = DeviceSurface; <br>        DeviceSurface-&gt;AddRef(); <br>    } <br> <br>    // <br>    // create a palette for the texture <br>    // <br>    if (ddsd.ddpfPixelFormat.dwRGBBitCount &lt;= 8) <br>    { <br>        Palette = PaletteFromBitmap(DirectDraw, Bitmap); <br> <br>        // <br>        // now we have a palette, attach the palette to the Surface <br>        // and the texture <br>        // <br>        MemorySurface-&gt;SetPalette(Palette); <br>        DeviceSurface-&gt;SetPalette(Palette); <br>    } <br> <br>    // <br>    // copy the bitmap to our surface <br>    // <br>    if (!Copy(Bitmap)) <br>        goto error; <br> <br>    // <br>    // get the texture handle <br>    // <br>    IDirect3DTexture2 *Texture; <br>    DeviceSurface-&gt;QueryInterface(IID_IDirect3DTexture2, (void**)&amp;Texture); <br>    Texture-&gt;GetHandle(Device, &amp;Handle); <br>    Texture-&gt;Release(); <br> <br>    // <br>    // we are done, delete the bitmap (we made a copy) and return. <br>    // <br>    DeleteObject(Bitmap); <br>    return TRUE; <br> <br>error: <br>    if (Bitmap) <br>        DeleteObject(Bitmap); <br>    Release(); <br>    return FALSE; <br>} <br> <br>/************************************************************************** <br> D3DTexture::Copy <br> <br> init the system memory surface from a GDI Bitmap <br> <br> **************************************************************************/ <br> <br>BOOL D3DTexture::Copy(HBITMAP Bitmap) <br>{ <br>    BITMAP  bm; <br>    HDC     BitmapDC; <br>    HDC     SurfaceDC; <br>    BOOL    result = FALSE; <br> <br>    DPF("D3DTexture::Copy"); <br> <br>    GetObject(Bitmap, sizeof(bm), &amp;bm);    // get size of bitmap <br> <br>    BitmapDC = CreateCompatibleDC(NULL); <br>    SelectObject(BitmapDC, Bitmap); <br> <br>    if (MemorySurface-&gt;GetDC(&amp;SurfaceDC) == DD_OK) <br>    { <br>        BitBlt(SurfaceDC, 0, 0, bm.bmWidth, bm.bmHeight, BitmapDC, 0, 0, SRCCOPY); <br>        MemorySurface-&gt;ReleaseDC(SurfaceDC); <br>        result = Restore(); <br>    } <br>    DeleteDC(BitmapDC); <br>    return result; <br>} <br> <br> <br>/************************************************************************** <br> D3DTexture::Restore <br> <br> restore the texture image <br> <br> **************************************************************************/ <br> <br>BOOL D3DTexture::Restore() <br>{ <br>    HRESULT             err; <br>    IDirect3DTexture2  *MemoryTexture; <br>    IDirect3DTexture2  *DeviceTexture; <br> <br>    DPF("D3DTexture::Restore"); <br> <br>    if (DeviceSurface == NULL || MemorySurface == NULL) <br>        return FALSE; <br> <br>    // <br>    // we dont need to do this step for system memory surfaces. <br>    // <br>    if (DeviceSurface == MemorySurface) <br>        return TRUE; <br> <br>    // <br>    // restore the video memory texture. <br>    // <br>    if (DeviceSurface-&gt;Restore() != DD_OK) <br>        return FALSE; <br> <br>    // <br>    // call IDirect3DTexture::Load() to copy the texture to the device. <br>    // <br>    DeviceSurface-&gt;QueryInterface(IID_IDirect3DTexture2, (void**)&amp;DeviceTexture); <br>    MemorySurface-&gt;QueryInterface(IID_IDirect3DTexture2, (void**)&amp;MemoryTexture); <br> <br>    err = DeviceTexture-&gt;Load(MemoryTexture); <br> <br>    DeviceTexture-&gt;Release(); <br>    MemoryTexture-&gt;Release(); <br> <br>    return err == DD_OK; <br>} <br> <br>/************************************************************************** <br> D3DTexture::Release <br> <br> free the texture, free all objects associated with this texture <br> <br> NOTE we cant do this in the destructor because DirectDraw <br> will clean up all the surfaces when the main direct draw object <br> is destroyed, before a static destructor will be called. <br> <br> **************************************************************************/ <br> <br>void D3DTexture::Release() <br>{ <br>    DPF("D3DTexture::Release"); <br> <br>    if (MemorySurface) <br>       MemorySurface-&gt;Release(); <br>    MemorySurface = 0; <br> <br>    if (DeviceSurface) <br>       DeviceSurface-&gt;Release(); <br>    DeviceSurface = 0; <br> <br>    if (Palette) <br>       Palette-&gt;Release(); <br>    Palette = 0; <br> <br>    Handle = 0; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
