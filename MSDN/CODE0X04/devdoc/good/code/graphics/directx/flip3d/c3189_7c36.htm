<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DUMB3D.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3192"></a>DUMB3D.CPP</h2>
<pre><code>/************************************************************************** <br>  dumb3d.cpp - A simple linear algebra library for 3D. <br> <br> **************************************************************************/ <br>/************************************************************************** <br> <br>    (C) Copyright 1995-1996 Microsoft Corp.  All rights reserved. <br> <br>    You have a royalty-free right to use, modify, reproduce and  <br>    distribute the Sample Files (and/or any modified version) in  <br>    any way you find useful, provided that you agree that  <br>    Microsoft has no warranty obligations or liability for any  <br>    Sample Application Files which are modified.  <br> <br> **************************************************************************/ <br> <br>#include&lt;memory.h&gt; <br>#include&lt;math.h&gt; <br>#include"dumb3d.h" <br> <br>/*-------------------------------------------------------------------------- <br> <br>matrix multiplication. <br> <br>*/ <br> <br>matrix_4x4 operator*( matrix_4x4 const &amp;Multiplicand, <br>    matrix_4x4 const &amp;Multiplier ) <br>{ <br>  matrix_4x4 ReturnMatrix; <br> <br>  for(int i = 0;i &lt; 4;i++) <br>  { <br>    for(int j = 0;j &lt; 4;j++) <br>    { <br>      real Value = 0; <br>       <br>      for(int k = 0;k &lt; 4;k++) <br>      { <br>        Value += Multiplicand.GetElement(i,k) * <br>            Multiplier.GetElement(k,j); <br>      } <br> <br>      ReturnMatrix.SetElement(i,j,Value); <br>    } <br>  } <br> <br>  return ReturnMatrix; <br>} <br> <br>vector_4 operator*( matrix_4x4 const &amp;Multiplicand, <br>    vector_4 const &amp;Multiplier ) <br>{ <br>  vector_4 ReturnPoint; <br> <br>  for(int i = 0;i &lt; 4;i++) <br>  { <br>    real Value = 0; <br>     <br>    for(int k = 0;k &lt; 4;k++) <br>    { <br>      Value += Multiplicand.GetElement(i,k) * <br>          Multiplier.GetElement(k); <br>    } <br> <br>    ReturnPoint.SetElement(i,Value); <br>  } <br> <br>  return ReturnPoint; <br>} <br> <br>point_4 operator*( matrix_4x4 const &amp;Multiplicand, <br>    point_4 const &amp;Multiplier ) <br>{ <br>  point_4 ReturnPoint; <br> <br>  for(int i = 0;i &lt; 4;i++) <br>  { <br>    real Value = 0; <br>     <br>    for(int k = 0;k &lt; 4;k++) <br>    { <br>      Value += Multiplicand.GetElement(i,k) * <br>          Multiplier.GetElement(k); <br>    } <br> <br>    ReturnPoint.SetElement(i,Value); <br>  } <br> <br>  return ReturnPoint; <br>} <br> <br> <br>/*-------------------------------------------------------------------------- <br> <br>constructor. <br> <br>*/ <br> <br>matrix_4x4::matrix_4x4( void ) <br>{ <br>  for(int Counter = 0;Counter &lt; 16;Counter++) <br>  { <br>    aElements[0][Counter] = 0; <br>  } <br> <br>  aElements[0][0] = aElements[1][1] = aElements[2][2] = aElements[3][3] = 1; <br>} <br> <br> <br>/*-------------------------------------------------------------------------- <br> <br>Rotations. <br> <br>*/ <br> <br>matrix_4x4 &amp;matrix_4x4::ConcatenateXRotation( real Degrees ) <br>{ <br>  real Temp01, Temp11, Temp21, Temp31; <br>  real Temp02, Temp12, Temp22, Temp32; <br> <br>  real Radians = (Degrees/360) * M_PI * 2; <br> <br>  real Sin = sin(Radians), Cos = cos(Radians); <br> <br>  Temp01 = aElements[0][1] * Cos + aElements[0][2] * Sin; <br>  Temp11 = aElements[1][1] * Cos + aElements[1][2] * Sin; <br>  Temp21 = aElements[2][1] * Cos + aElements[2][2] * Sin; <br>  Temp31 = aElements[3][1] * Cos + aElements[3][2] * Sin; <br> <br>  Temp02 = aElements[0][1] * -Sin + aElements[0][2] * Cos; <br>  Temp12 = aElements[1][1] * -Sin + aElements[1][2] * Cos; <br>  Temp22 = aElements[2][1] * -Sin + aElements[2][2] * Cos; <br>  Temp32 = aElements[3][1] * -Sin + aElements[3][2] * Cos; <br> <br>  aElements[0][1] = Temp01; <br>  aElements[1][1] = Temp11; <br>  aElements[2][1] = Temp21; <br>  aElements[3][1] = Temp31; <br>  aElements[0][2] = Temp02; <br>  aElements[1][2] = Temp12; <br>  aElements[2][2] = Temp22; <br>  aElements[3][2] = Temp32; <br> <br>  return *this; <br>} <br> <br>matrix_4x4 &amp;matrix_4x4::ConcatenateYRotation( real Degrees ) <br>{ <br>  real Temp00, Temp10, Temp20, Temp30; <br>  real Temp02, Temp12, Temp22, Temp32; <br> <br>  real Radians = (Degrees/360) * M_PI * 2; <br> <br>  real Sin = sin(Radians), Cos = cos(Radians); <br> <br>  Temp00 = aElements[0][0] * Cos + aElements[0][2] * -Sin; <br>  Temp10 = aElements[1][0] * Cos + aElements[1][2] * -Sin; <br>  Temp20 = aElements[2][0] * Cos + aElements[2][2] * -Sin; <br>  Temp30 = aElements[3][0] * Cos + aElements[3][2] * -Sin; <br> <br>  Temp02 = aElements[0][0] * Sin + aElements[0][2] * Cos; <br>  Temp12 = aElements[1][0] * Sin + aElements[1][2] * Cos; <br>  Temp22 = aElements[2][0] * Sin + aElements[2][2] * Cos; <br>  Temp32 = aElements[3][0] * Sin + aElements[3][2] * Cos; <br> <br>  aElements[0][0] = Temp00; <br>  aElements[1][0] = Temp10; <br>  aElements[2][0] = Temp20; <br>  aElements[3][0] = Temp30; <br>  aElements[0][2] = Temp02; <br>  aElements[1][2] = Temp12; <br>  aElements[2][2] = Temp22; <br>  aElements[3][2] = Temp32; <br> <br>  return *this; <br>} <br> <br>matrix_4x4 &amp;matrix_4x4::ConcatenateZRotation( real Degrees ) <br>{ <br>  real Temp00, Temp10, Temp20, Temp30; <br>  real Temp01, Temp11, Temp21, Temp31; <br> <br>  real Radians = (Degrees/360) * M_PI * 2; <br> <br>  real Sin = sin(Radians), Cos = cos(Radians); <br> <br>  Temp00 = aElements[0][0] * Cos + aElements[0][1] * Sin; <br>  Temp10 = aElements[1][0] * Cos + aElements[1][1] * Sin; <br>  Temp20 = aElements[2][0] * Cos + aElements[2][1] * Sin; <br>  Temp30 = aElements[3][0] * Cos + aElements[3][1] * Sin; <br> <br>  Temp01 = aElements[0][0] * -Sin + aElements[0][1] * Cos; <br>  Temp11 = aElements[1][0] * -Sin + aElements[1][1] * Cos; <br>  Temp21 = aElements[2][0] * -Sin + aElements[2][1] * Cos; <br>  Temp31 = aElements[3][0] * -Sin + aElements[3][1] * Cos; <br> <br>  aElements[0][0] = Temp00; <br>  aElements[1][0] = Temp10; <br>  aElements[2][0] = Temp20; <br>  aElements[3][0] = Temp30; <br>  aElements[0][1] = Temp01; <br>  aElements[1][1] = Temp11; <br>  aElements[2][1] = Temp21; <br>  aElements[3][1] = Temp31; <br> <br>  return *this; <br>} <br> <br>/*-------------------------------------------------------------------------- <br> <br>Translations. <br> <br>*/ <br> <br>matrix_4x4 &amp;matrix_4x4::ConcatenateXTranslation( real Distance ) <br>{ <br>  aElements[0][3] = aElements[0][0] * Distance + aElements[0][3]; <br>  aElements[1][3] = aElements[1][0] * Distance + aElements[1][3]; <br>  aElements[2][3] = aElements[2][0] * Distance + aElements[2][3]; <br>  aElements[3][3] = aElements[3][0] * Distance + aElements[3][3]; <br> <br>  return *this; <br>} <br> <br>matrix_4x4 &amp;matrix_4x4::ConcatenateYTranslation( real Distance ) <br>{ <br>  aElements[0][3] = aElements[0][1] * Distance + aElements[0][3]; <br>  aElements[1][3] = aElements[1][1] * Distance + aElements[1][3]; <br>  aElements[2][3] = aElements[2][1] * Distance + aElements[2][3]; <br>  aElements[3][3] = aElements[3][1] * Distance + aElements[3][3]; <br> <br>  return *this; <br>} <br> <br>matrix_4x4 &amp;matrix_4x4::ConcatenateZTranslation( real Distance ) <br>{ <br>  aElements[0][3] = aElements[0][2] * Distance + aElements[0][3]; <br>  aElements[1][3] = aElements[1][2] * Distance + aElements[1][3]; <br>  aElements[2][3] = aElements[2][2] * Distance + aElements[2][3]; <br>  aElements[3][3] = aElements[3][2] * Distance + aElements[3][3]; <br> <br>  return *this; <br>} <br> <br>/*-------------------------------------------------------------------------- <br> <br>vector normalize. <br> <br>*/ <br> <br>vector_4 &amp;vector_4::Normalize( void ) <br>{ <br>  real Length = sqrt(GetX()*GetX() + GetY()*GetY() + GetZ()*GetZ()); <br> <br>  SetX(GetX() / Length); <br>  SetY(GetY() / Length); <br>  SetZ(GetZ() / Length); <br> <br>  return *this; <br>} <br>   <br>/*-------------------------------------------------------------------------- <br> <br>view transform ctor. <br> <br>*/ <br> <br>view_transform::view_transform( point_4 const &amp;Viewpoint, <br>  vector_4 const &amp;ViewDirection, vector_4 const &amp;Up ) <br>{ <br>  // translate the viewpoint to the origin <br> <br>  this-&gt;ConcatenateXTranslation(-Viewpoint.GetX()); <br>  this-&gt;ConcatenateYTranslation(-Viewpoint.GetY()); <br>  this-&gt;ConcatenateZTranslation(-Viewpoint.GetZ()); <br> <br>  // get view vectors set up <br> <br>  vector_4 Right = -CrossProduct(ViewDirection,Up); <br>  vector_4 ReallyUp = CrossProduct(Right,ViewDirection); <br>     <br>  matrix_4x4 LookDownZ; <br> <br>  for(int Counter = 0;Counter &lt; 3;Counter++) <br>  { <br>    LookDownZ.SetElement(0,Counter,Right.GetElement(Counter)); <br>  } <br> <br>  for(Counter = 0;Counter &lt; 3;Counter++) <br>  { <br>    LookDownZ.SetElement(1,Counter,ReallyUp.GetElement(Counter)); <br>  } <br> <br>  for(Counter = 0;Counter &lt; 3;Counter++) <br>  { <br>    LookDownZ.SetElement(2,Counter,ViewDirection.GetElement(Counter)); <br>  } <br> <br>  this-&gt;matrix_4x4::operator=(LookDownZ * *this); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
