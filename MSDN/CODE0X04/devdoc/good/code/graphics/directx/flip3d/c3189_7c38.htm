<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FLIPCUBE.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3194"></a>FLIPCUBE.CPP</h2>
<pre><code>/************************************************************************** <br> <br>    FLIP3D.CPP - A spinning cube demo for DirectDraw <br> <br>    using Direct3D imediate mode (RenderPrimitive) for rendering. <br> <br>    uses D3DTLVERTEX, this app does all its own transform and lighting <br>    dumb3d.cpp is our "3d" package. <br> <br>    basic page fliping app, just render to the back buffer and flip <br>    that is all I do. <br> <br> **************************************************************************/ <br>/************************************************************************** <br> <br>    (C) Copyright 1995 - 1998 Microsoft Corp.  All rights reserved. <br> <br>    You have a royalty-free right to use, modify, reproduce and <br>    distribute the Sample Files (and/or any modified version) in <br>    any way you find useful, provided that you agree that <br>    Microsoft has no warranty obligations or liability for any <br>    Sample Application Files which are modified. <br> <br> **************************************************************************/ <br> <br>#define D3D_OVERLOADS <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include &lt;ddraw.h&gt; <br>#include &lt;d3d.h&gt; <br>#include &lt;math.h&gt; <br> <br>#include "flipcube.h" <br>#include "dumb3d.h" <br>#include "d3dtex.h" <br> <br>/************************************************************************** <br>  Global Variables <br> **************************************************************************/ <br> <br>char szAppName[]="Flip3D"; <br> <br>HINSTANCE  hInstApp; <br>BOOL       fAppActive; <br>BOOL       fAppPaused; <br>HWND       hwndApp; <br>HACCEL     hAccelApp; <br>HFONT      AppFont; <br>SIZE   ScreenSize; <br> <br>/************************************************************************** <br>  DirectDraw Globals <br> **************************************************************************/ <br> <br>IDirectDraw            *dd; <br>IDirectDrawSurface     *FrontBuffer; <br>IDirectDrawSurface     *BackBuffer; <br>IDirectDrawPalette     *Palette; <br>char                    DeviceName[128]; <br> <br>/************************************************************************** <br>  Direct3D Globals <br> **************************************************************************/ <br> <br>IDirect3D2             *d3d; <br>IDirect3DDevice2       *d3dDevice; <br>IDirect3DViewport2     *d3dViewport; <br>IDirect3DLight         *d3dLight; <br>char                   *d3dName; <br> <br>D3DCULL                 CullMode = D3DCULL_CCW; <br> <br>D3DTexture              Texture; <br> <br>D3DTEXTUREHANDLE TextureHandle      = 0; <br>BOOL             TexturePerspective = TRUE; <br>BOOL             TextureDither      = FALSE; <br>D3DTEXTUREBLEND  TextureBlend       = D3DTBLEND_MODULATE; <br>D3DMATERIALHANDLE hMat= 0; <br>LPDIRECT3DMATERIAL2 lpMat=NULL; <br> <br>/************************************************************************** <br>  dumb 3D Globals <br> **************************************************************************/ <br> <br>//*** Cube vertices, normals, shades, and modeling transform <br>static point_4 CubeVertices[8] = <br>{ <br>  point_4( -10,  10, -10 ), <br>  point_4( -10,  10,  10 ), <br>  point_4(  10,  10,  10 ), <br>  point_4(  10,  10, -10 ), <br>  point_4(  10, -10, -10 ), <br>  point_4(  10, -10,  10 ), <br>  point_4( -10, -10,  10 ), <br>  point_4( -10, -10, -10 ) <br>}; <br>static vector_4   CubeSurfaceNormals[6]; <br>static real       CubeSurfaceShades[6]; <br>static matrix_4x4 CubeTransform; <br> <br>//*** Cube edges - ordered indices into the vertex array <br>const int CubeFaces[6][4] = <br>{ <br>  0, 1, 2, 3, <br>  2, 1, 6, 5, <br>  3, 2, 5, 4, <br>  0, 3, 4, 7, <br>  1, 0, 7, 6, <br>  4, 5, 6, 7 <br>}; <br> <br>//*** Cube colors - one RGB color per surface <br>const unsigned char CubeColors[6][3] = <br>{ <br>  240,  20,  20,    // Unsaturated Red <br>   20, 240,  20,    // Unsaturated Green <br>   20,  20, 240,    // Unsaturated Blue <br>  128,  64,   0,    // Brown <br>  240,  20, 240,    // Unsaturated Magenta <br>  240, 240,  20     // Unsaturated Yellow <br>}; <br> <br>//*** Lighting <br>vector_4   LightSourceDirection; <br>const real AmbientLight = 0.2; <br> <br>//*** Viewing and perspective <br>static matrix_4x4  ViewPerspective; <br>static point_4     Viewpoint(60, 60, 60); <br>static vector_4    Up(0, 1, 0); <br>static point_4     Origin; <br> <br>//*** Interaction <br>static POINT       Move; <br>static POINT       Last; <br> <br>/************************************************************************** <br>   Internal function declarations <br> **************************************************************************/ <br>LONG  CALLBACK AppWndProc(HWND hwnd,UINT msg,WPARAM wParam,LPARAM lParam); <br>BOOL  AppIdle(void); <br>void  ClearFrame(void); <br>void  RenderFrame(void); <br> <br>void  TransformCube(matrix_4x4 const &amp;Transform); <br> <br>/************************************************************************** <br> **************************************************************************/ <br>BOOL  ProjectAndDrawCube(IDirect3DDevice2 *pd3d, int XOffset, int YOffset); <br> <br>/************************************************************************** <br> **************************************************************************/ <br>void BuildDeviceMenu(void); <br>void BuildModeMenu(void); <br>BOOL DDSetMode(int,int,int); <br> <br>/************************************************************************** <br>  AppAbout <br> <br>  Description: <br>    This function handles messages belonging to the "About" dialog box. <br>  The only message that it looks for is WM_COMMAND, indicating the user <br>  has pressed the "OK" button. <br> **************************************************************************/ <br> <br>BOOL FAR PASCAL AppAbout(HWND hwnd,UINT msg,WPARAM wParam,LPARAM lParam) <br>{ <br>  switch (msg) <br>  { <br>    case WM_COMMAND: <br>      if (LOWORD(wParam) == IDOK) <br>        EndDialog(hwnd, TRUE); <br>      break; <br> <br>    case WM_INITDIALOG: <br>      return TRUE; <br>  } <br>  return FALSE; <br>} <br> <br>/************************************************************************** <br>  DDTerm <br> **************************************************************************/ <br> <br>#define RELEASE(x) if (x) { x-&gt;Release(); x = NULL; } <br> <br>void DDTerm(BOOL fAll=TRUE) <br>{ <br>    RELEASE(d3dDevice); <br>    RELEASE(d3dViewport); <br>    RELEASE(d3dLight); <br> <br>    RELEASE(BackBuffer); <br>    RELEASE(FrontBuffer); <br>    RELEASE(Palette); <br>RELEASE(lpMat); <br> <br>    Texture.Release(); <br> <br>    if (fAll) <br>    { <br>        RELEASE(d3d); <br>        RELEASE(dd); <br>    } <br>} <br> <br>/************************************************************************** <br> * FindDeviceCallback <br> **************************************************************************/ <br> <br>BOOL CALLBACK FindDeviceCallback(GUID* lpGUID, LPSTR szName, LPSTR szDevice, LPVOID lParam) <br>{ <br>    char ach[128]; <br>    char * szFind = (char *)lParam; <br> <br>    wsprintf(ach,"%s (%s)",szName, szDevice); <br> <br>    if (lstrcmpi(szFind, szDevice) == 0 || lstrcmpi(szFind, ach) == 0) <br>    { <br>        DirectDrawCreate(lpGUID, &amp;dd, NULL); <br>        return DDENUMRET_CANCEL; <br>    } <br>    return DDENUMRET_OK; <br>} <br> <br>/************************************************************************** <br>  DDInit <br> <br>  Description: <br>    initialize all the DirectDraw/Direct3D specific stuff <br> **************************************************************************/ <br> <br>BOOL DDInit(char *szDevice=NULL) <br>{ <br>    HRESULT err; <br> <br>    DDTerm(); <br> <br>    if (szDevice &amp;&amp; szDevice[0]) <br>        DirectDrawEnumerate(FindDeviceCallback, (LPVOID)szDevice); <br> <br>    if (dd == NULL) <br>    { <br>        szDevice = NULL; <br>        err = DirectDrawCreate(NULL, &amp;dd, NULL); <br>    } <br> <br>    if (dd == NULL) <br>    { <br>        MessageBox(hwndApp, "This app requires DirectDraw", szAppName, MB_OK); <br>        return FALSE; <br>    } <br> <br>    err = dd-&gt;SetCooperativeLevel(hwndApp, <br>        DDSCL_EXCLUSIVE | DDSCL_FULLSCREEN | DDSCL_ALLOWMODEX); <br> <br>    if (err != DD_OK) <br>        return FALSE; <br> <br>    err = dd-&gt;QueryInterface(IID_IDirect3D2, (void**)&amp;d3d); <br> <br>    if (err != DD_OK) <br>    { <br>        MessageBox(hwndApp, "This app requires DirectX 5.0", szAppName, MB_OK); <br>        return FALSE; <br>    } <br>    // <br>    //Not imp <br>    // <br>    BuildModeMenu(); <br> <br>    if (!DDSetMode(640,480,16) &amp;&amp; <br>        !DDSetMode(640,480,8)) <br>    { <br>        return FALSE; <br>    } <br> <br>    char ach[128]; <br>    wsprintf(ach, "%s - %s %s", szAppName, szDevice ? szDevice : "DISPLAY", d3dName); <br>    SetWindowText(hwndApp, ach); <br> <br>    return TRUE; <br>} <br> <br>/************************************************************************** <br>  Init3DState <br> **************************************************************************/ <br>BOOL Init3DState() <br>{ <br>    D3DMATERIAL mat; <br> <br>    /* <br>     * Set default render state <br>     */ <br>    d3dDevice-&gt;SetRenderState(D3DRENDERSTATE_ZENABLE, 0); <br>    d3dDevice-&gt;SetRenderState(D3DRENDERSTATE_ZWRITEENABLE, 0); <br>    d3dDevice-&gt;SetRenderState(D3DRENDERSTATE_SHADEMODE, D3DSHADE_FLAT); <br> <br>    /* <br>     * load our single texture map from a resource <br>     */ <br>    Texture.Load(d3dDevice, "Win95"); <br>//  Texture.Load(d3dDevice, "Checker"); <br>    TextureHandle = Texture.GetHandle(); <br> <br>    if (d3d-&gt;CreateMaterial(&amp;lpMat, NULL) != D3D_OK) { <br>return FALSE; <br>    } <br>    memset(&amp;mat, 0, sizeof(D3DMATERIAL)); <br>    mat.dwSize = sizeof(D3DMATERIAL); <br>    mat.diffuse.r = (D3DVALUE)1.0; <br>    mat.diffuse.g = (D3DVALUE)1.0; <br>    mat.diffuse.b = (D3DVALUE)1.0; <br>    mat.ambient.r = (D3DVALUE)1.0; <br>    mat.ambient.g = (D3DVALUE)1.0; <br>    mat.ambient.b = (D3DVALUE)1.0; <br>    mat.specular.r = (D3DVALUE)1.0; <br>    mat.specular.g = (D3DVALUE)1.0; <br>    mat.specular.b = (D3DVALUE)1.0; <br>    mat.power = (float)40.0; <br>    mat.hTexture = TextureHandle; <br>    mat.dwRampSize = 1; <br>    lpMat-&gt;SetMaterial(&amp;mat); <br>    lpMat-&gt;GetHandle(d3dDevice, &amp;hMat); <br> <br>    return TRUE; <br>} <br> <br>/************************************************************************** <br>  Init3D <br> **************************************************************************/ <br>BOOL Init3D() <br>{ <br>    HRESULT err = E_FAIL; <br> <br>    // <br>    // create a Direct3D device. <br>    // first try HAL, then RGB, RAMP <br>    // <br>    d3dName = "HAL"; <br>    err = d3d-&gt;CreateDevice(IID_IDirect3DHALDevice, BackBuffer, &amp;d3dDevice); <br>     <br>    if (err != DD_OK) <br>    { <br>        d3dName = "RGB"; <br>        err = d3d-&gt;CreateDevice(IID_IDirect3DRGBDevice, BackBuffer, &amp;d3dDevice); <br>    } <br> <br>    if (err != DD_OK) <br>    { <br>        d3dName = "RAMP"; <br>        err = d3d-&gt;CreateDevice(IID_IDirect3DRampDevice, BackBuffer, &amp;d3dDevice); <br>    } <br> <br>    if (err != DD_OK) <br>        return FALSE; <br> <br>    // <br>    // now make a Viewport <br>    // <br>    err = d3d-&gt;CreateViewport(&amp;d3dViewport, NULL); <br> <br>    if (err != DD_OK) <br>        return FALSE; <br> <br>    err = d3dDevice-&gt;AddViewport(d3dViewport); <br> <br>    /* <br>     * Setup the viewport for a reasonable viewing area <br>     */ <br>    D3DVIEWPORT2 viewData; <br>    memset(&amp;viewData, 0, sizeof(D3DVIEWPORT2)); <br>    viewData.dwSize = sizeof(D3DVIEWPORT2); <br>    viewData.dwX = 0; <br>    viewData.dwY = 0; <br>    viewData.dwWidth  = ScreenSize.cx; <br>    viewData.dwHeight = ScreenSize.cy; <br>    viewData.dvClipX = -1.0f; <br>    viewData.dvClipWidth = 2.0f; <br>    viewData.dvClipHeight = (D3DVALUE)(ScreenSize.cy * 2.0 / ScreenSize.cx); <br>    viewData.dvClipY = viewData.dvClipHeight / 2.0f; <br>    viewData.dvMinZ = 0.0f; <br>    viewData.dvMaxZ = 1.0f; <br>    err = d3dViewport-&gt;SetViewport2(&amp;viewData); <br> <br>    if (err != DD_OK) <br>return FALSE; <br> <br>    err = d3dDevice-&gt;SetCurrentViewport(d3dViewport); <br> <br>    if (err != DD_OK) <br>        return FALSE; <br> <br>    if (!Init3DState()) <br>return FALSE; <br> <br>    return TRUE; <br>} <br> <br>/************************************************************************** <br>  DDSetMode <br> **************************************************************************/ <br> <br>BOOL DDSetMode(int width, int height, int bpp) <br>{ <br>    HRESULT err; <br> <br>    err = dd-&gt;SetDisplayMode(width, height, bpp); <br> <br>    if (err != DD_OK) <br>        return FALSE; <br> <br>    ScreenSize.cx = width; <br>    ScreenSize.cy = height; <br> <br>    // get rid of any previous surfaces. <br>    DDTerm(FALSE); <br> <br>    // <br>    // Create surfaces <br>    // <br>    // what we want is a double buffered surface in video memory <br>    // so we try to create this first. <br>    // <br>    // if we cant get a double buffered surface, we try for a double <br>    // buffered surface not being specific about video memory, we will <br>    // get back a main-memory surface, that wont use HW page flipping <br>    // but at least we run. <br>    // <br>    // NOTE you need to recreate the surfaces for a new display mode <br>    // they wont work when/if the mode is changed. <br>    // <br>    DDSURFACEDESC ddsd; <br> <br>    ZeroMemory(&amp;ddsd, sizeof(ddsd)); <br>    ddsd.dwSize = sizeof(ddsd); <br>    ddsd.dwFlags = DDSD_CAPS | DDSD_BACKBUFFERCOUNT; <br>    ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE | <br>                          DDSCAPS_FLIP | <br>                          DDSCAPS_COMPLEX | <br>                          DDSCAPS_3DDEVICE | <br>                          DDSCAPS_VIDEOMEMORY; <br>#ifdef TRIPLE_BUFFER <br>    ddsd.dwBackBufferCount = 2; <br>#else <br>    ddsd.dwBackBufferCount = 1; <br>#endif <br> <br>    // try to get a triple/double buffered video memory surface. <br>    err = dd-&gt;CreateSurface(&amp;ddsd, &amp;FrontBuffer, NULL); <br> <br>    // try to get a double buffered video memory surface. <br>    if (err != DD_OK &amp;&amp; ddsd.dwBackBufferCount == 2) <br>    { <br>       ddsd.dwBackBufferCount = 1; <br>       err = dd-&gt;CreateSurface(&amp;ddsd, &amp;FrontBuffer, NULL); <br>    } <br> <br>    if (err != DD_OK) <br>    { <br>        // settle for a main memory surface. <br>        ddsd.ddsCaps.dwCaps &amp;= ~DDSCAPS_VIDEOMEMORY; <br>        err = dd-&gt;CreateSurface(&amp;ddsd, &amp;FrontBuffer, NULL); <br>    } <br> <br>    if (err != DD_OK) <br>        return FALSE; <br> <br>    // get a pointer to the back buffer <br>    DDSCAPS caps; <br>    caps.dwCaps = DDSCAPS_BACKBUFFER; <br>    err = FrontBuffer-&gt;GetAttachedSurface(&amp;caps, &amp;BackBuffer); <br> <br>    if (err != DD_OK) <br>        return FALSE; <br> <br>    // create a palette if we are in a paletized display mode. <br>    // <br>    // NOTE because we want to be able to show dialog boxs and <br>    // use our menu, we leave the windows reserved colors as is <br>    // so things dont look ugly. <br>    // <br>    // palette is setup like so: <br>    // <br>    //      10      windows system colors <br>    //      64      red wash <br>    //      64      grn wash <br>    //      64      blu wash <br>    // <br>    if (bpp == 8) <br>    { <br>        PALETTEENTRY ape[256]; <br> <br>        // get the current windows colors. <br>        GetPaletteEntries((HPALETTE)GetStockObject(DEFAULT_PALETTE), 0,  10, &amp;ape[0]); <br>        GetPaletteEntries((HPALETTE)GetStockObject(DEFAULT_PALETTE), 10, 10, &amp;ape[246]); <br> <br>        // make a red, grn, and blu wash for our cube. <br>        for (int i=0; i&lt;64; i++) <br>        { <br>            ape[10+64*0+i].peRed   = i * 255/63; <br>            ape[10+64*0+i].peGreen = 0; <br>            ape[10+64*0+i].peBlue  = 0; <br> <br>            ape[10+64*1+i].peRed   = 0; <br>            ape[10+64*1+i].peGreen = i * 255/63; <br>            ape[10+64*1+i].peBlue  = 0; <br> <br>            ape[10+64*2+i].peRed   = 0; <br>            ape[10+64*2+i].peGreen = 0; <br>            ape[10+64*2+i].peBlue  = i * 255/63; <br>        } <br> <br>        // create the palette. <br>        err = dd-&gt;CreatePalette(DDPCAPS_8BIT, ape, &amp;Palette, NULL); <br> <br>        if (err == DD_OK) <br>        { <br>            FrontBuffer-&gt;SetPalette(Palette); <br>            BackBuffer-&gt;SetPalette(Palette); <br>        } <br>    } <br> <br>    if (!Init3D()) <br>        return FALSE; <br> <br>    if (AppFont) <br>        DeleteObject(AppFont); <br> <br>    AppFont = CreateFont(width &lt; 640 ? 24 : 48, <br>        0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE, <br>        ANSI_CHARSET, <br>        OUT_DEFAULT_PRECIS, <br>        CLIP_DEFAULT_PRECIS, <br>        NONANTIALIASED_QUALITY, <br>        VARIABLE_PITCH, <br>        "Comic Sans MS"); <br> <br>    return TRUE; <br>} <br> <br>/************************************************************************** <br>  BuildModeMenu <br> **************************************************************************/ <br>#define MAKEMENUITEMDATA(width, height, bpp) \ <br>        (width) | ((height) &lt;&lt; 12) | ((bpp) &lt;&lt; 24) <br> <br>HRESULT CALLBACK BuildModeMenuCallback(LPDDSURFACEDESC pdds, LPVOID lParam) <br>{ <br>    HMENU hmenu = (HMENU)lParam; <br>    char ach[80]; <br>    int n; <br>    int width  = pdds-&gt;dwWidth; <br>    int height = pdds-&gt;dwHeight; <br>    int bpp    = pdds-&gt;ddpfPixelFormat.dwRGBBitCount; <br> <br>    n = GetMenuItemCount(hmenu); <br>    wsprintf(ach,"%dx%dx%d",width,height,bpp); <br>    AppendMenu(hmenu,MF_STRING,MENU_MODE+n,ach); <br> <br>    MENUITEMINFO mii; <br> <br>    // pack the mode info into a DWORD and set the extra item data. <br>    mii.cbSize = sizeof(mii); <br>    mii.fMask = MIIM_DATA; <br>    mii.dwItemData = MAKEMENUITEMDATA(width, height, bpp); <br>    SetMenuItemInfo(hmenu, MENU_MODE+n, MF_BYCOMMAND, &amp;mii); <br> <br>    //return S_TRUE to stop enuming modes, S_FALSE to continue <br>    return S_FALSE; <br>} <br> <br>void BuildModeMenu() <br>{ <br>    // Enumerate all posible display modes, and stick them in our menu. <br>    // we use the extra item DWORD of a menu item to store the mode info <br> <br>    DeleteMenu(GetMenu(hwndApp), 2, MF_BYPOSITION); <br> <br>    HMENU hmenu = CreatePopupMenu(); <br>    dd-&gt;EnumDisplayModes(0,NULL,(LPVOID)hmenu,BuildModeMenuCallback); <br>    AppendMenu(GetMenu(hwndApp),MF_POPUP,(UINT)hmenu,"&amp;Modes"); <br>} <br> <br>/************************************************************************** <br> * BuildDeviceMenu <br> **************************************************************************/ <br> <br>BOOL CALLBACK BuildDeviceMenuCallback(GUID* lpGUID, LPSTR szName, LPSTR szDevice, LPVOID lParam) <br>{ <br>    HMENU hmenu = (HMENU)lParam; <br>    char ach[80]; <br>    int n; <br> <br>    n = GetMenuItemCount(hmenu); <br>    wsprintf(ach,"%s (%s)",szName, szDevice); <br>    AppendMenu(hmenu,MF_STRING,MENU_DEVICE+n,ach); <br>    return DDENUMRET_OK; <br>} <br> <br>void BuildDeviceMenu() <br>{ <br>    HMENU hmenu = CreatePopupMenu(); <br>    DirectDrawEnumerate(BuildDeviceMenuCallback, (LPVOID)hmenu); <br>    AppendMenu(GetMenu(hwndApp),MF_POPUP,(UINT)hmenu,"&amp;Device"); <br>} <br> <br>/************************************************************************** <br>  AppInit <br> <br>  Description: <br>    This is called when the application is first loaded. It initializes <br>  all variables, registers the window class, and creates the main app <br>  window. <br> **************************************************************************/ <br> <br>BOOL AppInit(HINSTANCE hInst,HINSTANCE hPrev,int sw,LPSTR szCmdLine) <br>{ <br>  WNDCLASS cls; <br> <br>  /* Save instance handle for DialogBoxes */ <br>  hInstApp = hInst; <br> <br>  if (!hPrev) <br>  { <br>    //***  Register a class for the main application window <br>    cls.hCursor        = LoadCursor(0,IDC_ARROW); <br> <br>    //*** Just for fun, we'll draw our own spinning cube icon. <br>    cls.hIcon          = LoadIcon(hInst, "AppIcon"); <br>    cls.lpszMenuName   = "AppMenu"; <br>    cls.lpszClassName  = szAppName; <br>    cls.hbrBackground  = (HBRUSH)GetStockObject(BLACK_BRUSH); <br>    cls.hInstance      = hInst; <br>    cls.style          = CS_VREDRAW | CS_HREDRAW; <br>    cls.lpfnWndProc    = (WNDPROC)AppWndProc; <br>    cls.cbClsExtra     = 0; <br>    cls.cbWndExtra     = 0; <br> <br>    if (!RegisterClass(&amp;cls)) <br>      return FALSE; <br>  } <br> <br>  hAccelApp = LoadAccelerators(hInst, "AppAccel"); <br> <br>  //*** Set and normalize the light source <br>  LightSourceDirection = vector_4(50, 30, -15); <br>  LightSourceDirection.Normalize(); <br> <br>  //*** Distance to view plane: <br>  ViewPerspective.SetElement(3, 2, 1/300.0); <br>  ViewPerspective.SetElement(3, 3, 0); <br> <br>  //*** Viewport scaling - some arbitrary number like 3.5 will do <br>  ViewPerspective.SetElement(0, 0, 3.5); <br>  ViewPerspective.SetElement(1, 1, 3.5); <br> <br>  //*** Calculate the initial normals and shades <br>  TransformCube(CubeTransform); <br> <br>  //*** Then generate an interesting rotation for the spin <br>  CubeTransform.ConcatenateYRotation(6.0); <br>  CubeTransform.ConcatenateXRotation(3.5); <br>  CubeTransform.ConcatenateZRotation(2.0); <br> <br>  hwndApp = CreateWindowEx( <br>                  WS_EX_APPWINDOW, <br>                  szAppName,           // Class name <br>                  szAppName,           // Caption <br>                  WS_POPUP | <br>                  WS_SYSMENU | <br>                  WS_CAPTION, <br>  0, 0,        // Position <br>  640,480,       // Size <br>                  0,                   // Parent window (no parent) <br>                  0,                   // use class menu <br>                  hInst,               // handle to window instance <br>                  0                    // no params to pass on <br>                  ); <br>  ShowWindow(hwndApp,sw); <br>  UpdateWindow(hwndApp); <br> <br>  BuildDeviceMenu(); <br> <br>  // <br>  // read the device name from WIN.INI so we come up on the last device <br>  // that the user picked. <br>  // <br>  GetProfileString(szAppName, "Device", "", DeviceName, sizeof(DeviceName)); <br> <br>  if (!DDInit(DeviceName)) <br>      return FALSE; <br> <br>  return TRUE; <br>} <br> <br>/************************************************************************** <br>  WinMain <br> <br>  Description: <br>    The main procedure for the App.  After initializing, it just goes <br>  into a message-processing loop until it gets a WM_QUIT message. <br> **************************************************************************/ <br> <br>int PASCAL WinMain(HINSTANCE hInst, HINSTANCE hPrev, LPSTR szCmdLine, int sw) <br>{ <br>  MSG     msg; <br> <br>  //*** Call initialization procedure <br>  if (!AppInit(hInst,hPrev,sw,szCmdLine)) <br>    return FALSE; <br> <br>  //*** Polling messages from event queue until quit <br>  for (;;) <br>  { <br>    if (PeekMessage(&amp;msg, 0, 0, 0, PM_REMOVE)) <br>    { <br>      if (msg.message == WM_QUIT) <br>        break; <br> <br>      if (!hwndApp || !TranslateAccelerator(hwndApp, hAccelApp, &amp;msg)) <br>      { <br>        TranslateMessage(&amp;msg); <br>        DispatchMessage(&amp;msg); <br>      } <br>    } <br>    else <br>    { <br>      if (AppIdle()) <br>        WaitMessage(); <br>    } <br>  } <br> <br>  DDTerm(); <br>  return msg.wParam; <br>} <br> <br>/************************************************************************** <br>  AppPause <br> <br> **************************************************************************/ <br> <br>void AppPause(BOOL f) <br>{ <br>    if (f) <br>    { <br>        DDSCAPS caps; <br>        FrontBuffer-&gt;GetCaps(&amp;caps); <br> <br>        // if we are in ModeX go back to a windows mode <br>        // so we can see the menu or dialog box. <br> <br>        if (caps.dwCaps &amp; DDSCAPS_MODEX) <br>        { <br>            DDSetMode(640,480,8); <br>        } <br> <br>        fAppPaused = TRUE; <br>        dd-&gt;FlipToGDISurface(); <br>        DrawMenuBar(hwndApp); <br>        RedrawWindow(hwndApp, NULL, NULL, RDW_FRAME); <br>    } <br>    else <br>    { <br>        fAppPaused = FALSE; <br>    } <br>} <br> <br>/************************************************************************** <br>  MagnifyCube <br> <br>  Description: <br>    Magnify the cube the indicated number of times.  A negative number <br>    makes it smaller. <br> **************************************************************************/ <br> <br>void MagnifyCube(double times) <br>{ <br>    matrix_4x4 m; <br>    double factor = pow(1.5, times); <br>    m.SetElement(0,0,factor); <br>    m.SetElement(1,1,factor); <br>    m.SetElement(2,2,factor); <br>    TransformCube(m); <br>} <br> <br>/************************************************************************** <br>  AppIdle <br> <br>  return TRUE if the app is idle <br>  return FALSE if the app is not idle. <br> <br>  Description: <br> **************************************************************************/ <br> <br>BOOL AppIdle() <br>{ <br>  //*** Spin while the app is active, lbutton is up, and spinning is on. <br> <br>  //*** Spin while the app is iconized. <br>  if (fAppActive &amp;&amp; !fAppPaused) <br>  { <br>    //*** If the app is active, spin the cube and redraw <br>    if (GetAsyncKeyState(VK_LBUTTON) &lt; 0) <br>    { <br>        if(Move.x || Move.y) <br>        { <br>            matrix_4x4 Movement; <br>            Movement.ConcatenateYRotation(Move.x); <br>            Movement.ConcatenateXRotation(Move.y); <br>            Move.x = Move.y = 0; <br>            TransformCube(Movement); <br>        } <br>    } <br>    else <br>    { <br>        TransformCube(CubeTransform); <br>    } <br>    RenderFrame(); <br>    return FALSE; <br>  } <br>  else <br>  { <br>    //*** Don't do anything when not the active app <br>    return TRUE; <br>  } <br>} <br> <br>/************************************************************************** <br>  RenderFrame <br> <br>  render the frame into the back buffer and do a page flip. <br> <br>  things to NOTE: <br> <br>    we use the blter to clear the backbuffer, this usualy is a big <br>    win blters are real fast. <br> <br>    we use GDI to draw the frame rate, and info text <br> <br> **************************************************************************/ <br> <br>int FrameRate; <br>int FrameCount; <br>int FrameCount0; <br>DWORD FrameTime; <br>DWORD FrameTime0; <br> <br>void RenderFrame() <br>{ <br>  HDC hdc; <br> <br>  //*** always need to handle DDERR_SURFACELOST, this will happen <br>  //*** when we get switched away from. <br> <br>  if (FrontBuffer-&gt;IsLost() == DDERR_SURFACELOST) <br>  { <br>     FrontBuffer-&gt;Restore(); <br>     Texture.Restore(); <br>  } <br> <br>  //*** use the blter to do a color fill to clear the back buffer <br> <br>  DDBLTFX ddbltfx; <br>  ddbltfx.dwSize = sizeof(ddbltfx); <br>  ddbltfx.dwFillColor = 0; <br>  BackBuffer-&gt;Blt(NULL,NULL,NULL,DDBLT_COLORFILL | DDBLT_WAIT,&amp;ddbltfx); <br> <br>  ProjectAndDrawCube(d3dDevice, ScreenSize.cx/2, ScreenSize.cy/2); <br> <br>  if (BackBuffer-&gt;GetDC(&amp;hdc) == DD_OK) <br>  { <br>    //*** draw stats, like frame number and frame rate <br> <br>    char ach[128]; <br>    int len; <br>    static char szHelp[] = "F10=Menu F7=Smaller F8=Larger"; <br> <br>    SetBkMode(hdc, TRANSPARENT); <br>    SelectObject(hdc, AppFont); <br> <br>    len = wsprintf(ach, "FPS %02d Frame %05d (%s)", FrameRate, FrameCount, d3dName); <br> <br>    SetTextColor(hdc, RGB(255, 255, 0)); <br>    TextOut(hdc, 0, 0, ach, len); <br>    TextOut(hdc, 0, ScreenSize.cy-(ScreenSize.cx&lt;640 ? 24:48),szHelp,sizeof(szHelp)-1); <br> <br>    BackBuffer-&gt;ReleaseDC(hdc); <br>  } <br> <br>  //*** we have rendered the backbuffer, call flip so we can see it <br>  FrontBuffer-&gt;Flip(NULL, DDFLIP_WAIT); <br> <br>  FrameCount++; <br>  FrameTime = timeGetTime(); <br> <br>  if (FrameTime - FrameTime0 &gt; 1000) <br>  { <br>    FrameRate = (FrameCount - FrameCount0) * 1000 / (FrameTime - FrameTime0); <br>    FrameTime0 = FrameTime; <br>    FrameCount0 = FrameCount; <br>  } <br>} <br> <br>/************************************************************************** <br>  AppInitMenuPopup <br> <br>    If it's the Cube menu, then check or uncheck the GDI item accordingly. <br> <br>    If it's the mode list popup, then add a MENUBARBREAK as necessary. <br> <br> **************************************************************************/ <br> <br>void AppInitMenuPopup(HWND hwnd, HMENU hmenu, UINT uPos, BOOL fSys) <br>{ <br>    if (fSys) return;       /* Don't mess with the sysmenu */ <br> <br>    switch (uPos) { <br>    case 0:                 /* Cube menu */ <br>        CheckMenuItem(hmenu, MENU_CULL_NONE, CullMode == D3DCULL_NONE ? MF_CHECKED : MF_UNCHECKED); <br>        CheckMenuItem(hmenu, MENU_CULL_CW,   CullMode == D3DCULL_CW   ? MF_CHECKED : MF_UNCHECKED); <br>        CheckMenuItem(hmenu, MENU_CULL_CCW,  CullMode == D3DCULL_CCW  ? MF_CHECKED : MF_UNCHECKED); <br> <br>        CheckMenuItem(hmenu, MENU_TEXTURE,    TextureHandle ? MF_CHECKED : MF_UNCHECKED); <br>        CheckMenuItem(hmenu, MENU_DITHER,     TextureDither ? MF_CHECKED : MF_UNCHECKED); <br>        CheckMenuItem(hmenu, MENU_PERSPECTIVE,TexturePerspective ? MF_CHECKED : MF_UNCHECKED); <br>        CheckMenuItem(hmenu, MENU_MODULATE,   TextureBlend == D3DTBLEND_MODULATE ? MF_CHECKED : MF_UNCHECKED); <br>        CheckMenuItem(hmenu, MENU_COPY,       TextureBlend == D3DTBLEND_COPY ? MF_CHECKED : MF_UNCHECKED); <br>        CheckMenuItem(hmenu, MENU_DECAL,      TextureBlend == D3DTBLEND_DECAL ? MF_CHECKED : MF_UNCHECKED); <br>        break; <br> <br>    case 1:                 /* Device menu */ <br>    case 2:                 /* Mode menu */ <br>        /* <br>         *  Compute how many menu items fit on the screen. <br>         * <br>         *  Note that we use ScreenSize instead of SM_CYSCREEN. <br>         *  This allows us to do the right thing in the face of <br>         *  multiple monitors.  (ScreenSize is the size of our <br>         *  monitor.) <br>         */ <br>        int cmi; <br> <br>        cmi = GetMenuItemCount(hmenu); <br>        if (cmi) { <br> <br>            RECT rcClient; <br>            GetClientRect(hwnd, &amp;rcClient); <br> <br>            RECT rc; <br>            GetMenuItemRect(hwnd, hmenu, 0, &amp;rc); <br> <br>            int dyMenuItem = rc.bottom - rc.top; <br> <br>            /* <br>             *  Aargh.  If the menu has never appeared yet, USER <br>             *  returns an empty rectangle.  DON'T DIVIDE BY ZERO! <br>             * <br>             *  In such case, we use the height of the menu bar. <br>             *  Not perfect, but close enough.  And it happens only <br>             *  once. <br>             */ <br>            if (dyMenuItem == 0) { <br>                dyMenuItem = GetSystemMetrics(SM_CYMENU); <br>            } <br> <br>            /* <br>             *  Aargh.  You can't change MF_MENUBARBREAK without <br>             *  also changing the text, so we have to get the <br>             *  old text and set it back. <br>             * <br>             *  While we're here, we may as well put a check-box <br>             *  next to the item that matches our current screen res. <br>             */ <br> <br>            DDSURFACEDESC ddsd; <br>            ZeroMemory(&amp;ddsd, sizeof(ddsd)); <br>            ddsd.dwSize = sizeof(ddsd); <br>            FrontBuffer-&gt;GetSurfaceDesc(&amp;ddsd); <br>            int width  = ddsd.dwWidth; <br>            int height = ddsd.dwHeight; <br>            int bpp    = ddsd.ddpfPixelFormat.dwRGBBitCount; <br>            DWORD dwItemDataMatch = MAKEMENUITEMDATA(width, height, bpp); </code></pre>
<p>
</p>
<pre><code><br>            MENUITEMINFO mii; <br>            TCHAR tsz[80]; <br> <br>            mii.cbSize = sizeof(mii); <br>            mii.fMask = MIIM_TYPE | MIIM_DATA | MIIM_STATE; <br>            mii.dwTypeData = tsz; <br> <br>            /* <br>             *  Compute the number of MI's that fit in our client area. <br>             *  Note: Client area, not screen size.  This ensures that <br>             *  the menu pops in a reasonable location. <br>             */ <br> <br>            int cmiScreen = rcClient.bottom / dyMenuItem; <br> <br>            for (int imi = 0; imi &lt; cmi; imi++) { <br>                mii.cch = sizeof(tsz) / sizeof(tsz[0]); <br>                if (GetMenuItemInfo(hmenu, imi, MF_BYPOSITION, &amp;mii)) { <br>                    if (imi &gt; 0 &amp;&amp; imi % cmiScreen == 0) { <br>                        mii.fType |= MFT_MENUBARBREAK; <br>                    } else { <br>                        mii.fType &amp;= ~MFT_MENUBARBREAK; <br>                    } <br> <br>                    if (mii.dwItemData == dwItemDataMatch) { <br>                        mii.fState |= MFS_CHECKED; <br>                    } else { <br>                        mii.fState &amp;= ~MFS_CHECKED; <br>                    } <br> <br>                    SetMenuItemInfo(hmenu, imi, MF_BYPOSITION, &amp;mii); <br>                } <br>            } <br> <br>        } <br>        break; <br>    } <br> <br>} <br> <br>/************************************************************************** <br>  AppWndProc <br> <br>  Description: <br>    Main window proc. Standard Windows fare. <br> **************************************************************************/ <br> <br>LONG CALLBACK AppWndProc(HWND hwnd,UINT msg,WPARAM wParam,LPARAM lParam) <br>{ <br>  switch (msg) <br>  { <br>    case WM_CREATE: <br>      break; <br> <br>    case WM_ACTIVATEAPP: <br>      //*** Keep track of whether or not the app is in the foreground <br>      fAppActive = (BOOL)wParam; <br>      break; <br> <br>    case WM_SETCURSOR: <br>      if (fAppActive &amp;&amp; !fAppPaused &amp;&amp; BackBuffer) <br>      { <br>        SetCursor(NULL); <br>        return 1; <br>      } <br>      break; <br> <br>    case WM_ENTERMENULOOP: <br>      AppPause(TRUE); <br>      break; <br> <br>    case WM_EXITMENULOOP: <br>      AppPause(FALSE); <br>      break; <br> <br>    case WM_INITMENUPOPUP: <br>        AppInitMenuPopup(hwnd, (HMENU)wParam, <br>                         (UINT)LOWORD(lParam), (BOOL)HIWORD(lParam)); <br>        break; <br> <br>    case WM_COMMAND: <br>      switch(LOWORD(wParam)) <br>      { <br>        case MENU_ABOUT: <br>          AppPause(TRUE); <br>          DialogBox(hInstApp, "AppAbout", hwnd, (DLGPROC)AppAbout); <br>          AppPause(FALSE); <br>          break; <br> <br>        case MENU_EXIT: <br>          PostMessage(hwnd, WM_CLOSE, 0, 0L); <br>          break; <br> <br>        case MENU_LARGER: <br>          MagnifyCube(+1.0); <br>          break; <br> <br>        case MENU_SMALLER: <br>          MagnifyCube(-1.0); <br>          break; <br> <br>        case MENU_TEXTURE: <br>          TextureHandle = TextureHandle ? 0 : Texture.GetHandle(); <br>          break; <br> <br>        case MENU_PERSPECTIVE:  TexturePerspective = !TexturePerspective; break; <br>        case MENU_DITHER:       TextureDither      = !TextureDither; break; <br> <br>        case MENU_MODULATE:     TextureBlend = D3DTBLEND_MODULATE; break; <br>        case MENU_COPY:         TextureBlend = D3DTBLEND_COPY;     break; <br>        case MENU_DECAL:        TextureBlend = D3DTBLEND_DECAL;    break; <br> <br>        case MENU_CULL_NONE:    CullMode = D3DCULL_NONE; break; <br>        case MENU_CULL_CW:      CullMode = D3DCULL_CW;   break; <br>        case MENU_CULL_CCW:     CullMode = D3DCULL_CCW;  break; <br>      } <br>      if (LOWORD(wParam) &gt;= MENU_DEVICE &amp;&amp; LOWORD(wParam) &lt; MENU_DEVICE+100) <br>      { <br>        GetMenuString(GetMenu(hwnd), LOWORD(wParam), DeviceName, sizeof(DeviceName), MF_BYCOMMAND); <br>        WriteProfileString(szAppName, "Device", DeviceName); <br>        DDInit(DeviceName); <br>      } <br>      if (LOWORD(wParam) &gt;= MENU_MODE &amp;&amp; LOWORD(wParam) &lt; MENU_MODE+100) <br>      { <br>        MENUITEMINFO mii; <br> <br>        mii.cbSize = sizeof(mii); <br>        mii.fMask = MIIM_DATA; <br>        GetMenuItemInfo(GetMenu(hwnd), LOWORD(wParam), MF_BYCOMMAND, &amp;mii); <br> <br>        DDSetMode( <br>            (mii.dwItemData &gt;&gt; 0)  &amp; 0xFFF, <br>            (mii.dwItemData &gt;&gt; 12) &amp; 0xFFF, <br>            (mii.dwItemData &gt;&gt; 24) &amp; 0x0FF); <br>      } <br>      return 0L; <br> <br>    case WM_DESTROY: <br>      hwndApp = NULL; <br>      PostQuitMessage(0); <br>      break; <br> <br>    case WM_PAINT: <br>      break; <br> <br>#if 0   // fullscreen apps dont need to do this! <br>        // and using SM_CYSCREEN is incorrect for other devices. <br>    case WM_MOVE: <br>    case WM_SIZE: <br>    case WM_DISPLAYCHANGE: <br>      if (fAppActive &amp;&amp; !IsIconic(hwnd)) <br>      { <br>RECT Rect; <br>SetRect(&amp;Rect, 0, GetSystemMetrics(SM_CYCAPTION), GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN)); <br>        AdjustWindowRectEx(&amp;Rect, WS_POPUP | WS_CAPTION, FALSE, 0); <br>        SetWindowPos(hwnd, NULL, Rect.left, Rect.top, Rect.right-Rect.left, Rect.bottom-Rect.top, SWP_NOACTIVATE | SWP_NOZORDER); <br>      } <br>      break; <br>#endif <br> <br>    case WM_LBUTTONDOWN: <br>      //*** Get the start location for mouse rotations <br>      Last.x = LOWORD(lParam); <br>      Last.y = HIWORD(lParam); <br>      break; <br> <br>    case WM_MOUSEMOVE: <br>      //*** While the mouse button is down, keep track of movement <br>      //*** to update the eye position <br>      if(GetKeyState(VK_LBUTTON) &lt; 0) <br>      { <br>        Move.x = (int)LOWORD(lParam) - Last.x; <br>        Move.y = (int)HIWORD(lParam) - Last.y; <br>        Last.x = LOWORD(lParam); <br>        Last.y = HIWORD(lParam); <br>      } <br>      break; <br>  } <br> <br>  return DefWindowProc(hwnd,msg,wParam,lParam); <br>} <br> <br>/************************************************************************** <br>  TransformCube <br> <br>  Description: <br>    Transforms the cube vertices by the current rotation matrix. <br>    Recalculates normals and flat shade values for the <br>  directional light source. <br> **************************************************************************/ <br> <br>void TransformCube(matrix_4x4 const &amp;Transform) <br>{ <br>  int i; <br> <br>  //*** Transform the cube by the matrix <br>  for (i = 0; i &lt; 8; ++i) <br>    CubeVertices[i] = Transform * CubeVertices[i]; <br> <br>  //*** Recalculate normals and shades <br>  for (i = 0; i &lt; 6; ++i) <br>  { <br>    //*** Normals are perpendicular to two edges of the cube <br>    vector_4 Edge1, Edge2; <br>    Edge1 = CubeVertices[CubeFaces[i][1]] - CubeVertices[CubeFaces[i][0]]; <br>    Edge2 = CubeVertices[CubeFaces[i][3]] - CubeVertices[CubeFaces[i][0]]; <br>    CubeSurfaceNormals[i] = CrossProduct(Edge1, Edge2); <br>    CubeSurfaceNormals[i].Normalize(); <br> <br>    //*** Cosine shading based on the surface normal, clamped to [0, 1] <br>    real Shade = DotProduct(CubeSurfaceNormals[i], LightSourceDirection); <br> <br>    if (CullMode != D3DCULL_CCW) <br>    { <br>        if (Shade &lt; 0) Shade = -Shade; <br>    } <br> <br>    Shade = Shade + AmbientLight; <br>    if (Shade &lt; 0) Shade = 0; <br>    else if (Shade &gt; 1.0) Shade = 1.0; <br>    CubeSurfaceShades[i] = Shade; <br>  } <br>} <br> <br>/************************************************************************** <br>  ProjectAndDrawCube <br> <br>  Description: <br>    Projects the cube vertices for the current viewpoint then culls <br>  in screen space and draws into the DC via GDI. <br> **************************************************************************/ <br> <br>BOOL ProjectAndDrawCube(IDirect3DDevice2 *dev, int XOffset, int YOffset) <br>{ <br>  HRESULT err; <br> <br>  //*** Create a viewing transform for the current eye position <br>  vector_4 ViewDirection = Origin - Viewpoint; <br>  ViewDirection.Normalize(); <br>  view_transform View(Viewpoint, ViewDirection, Up); <br> <br>  //*** Transform and project the vertices into screen space <br>  int i; <br>  float aScreenVerticesX[8]; <br>  float aScreenVerticesY[8]; <br>  float aScreenVerticesZ[8]; <br>  float aScreenVerticesW[8]; <br> <br>  for (i = 0; i &lt; 8; ++i) <br>  { <br>    point_4 Temp = View * CubeVertices[i]; <br>    Temp = ViewPerspective * Temp; <br>    Temp.Homogenize(); <br> <br>    aScreenVerticesX[i] = (float)Temp.GetX() + XOffset; <br>    aScreenVerticesY[i] = (float)Temp.GetY() + YOffset; <br>    aScreenVerticesZ[i] = (float)Temp.GetZ(); <br>    aScreenVerticesW[i] = (float)Temp.GetW(); <br> <br>  } <br> <br>  err = dev-&gt;BeginScene(); <br> <br>  // <br>  // NOTE NOTE NOTE NOTE NOTE <br>  // dont be as stupid as this sample, dont change the render <br>  // state every frame unless you need to. <br>  // <br>  dev-&gt;SetLightState(D3DLIGHTSTATE_MATERIAL,hMat); <br>  dev-&gt;SetRenderState(D3DRENDERSTATE_CULLMODE,           CullMode); <br>  dev-&gt;SetRenderState(D3DRENDERSTATE_DITHERENABLE,       TextureDither); <br>  dev-&gt;SetRenderState(D3DRENDERSTATE_TEXTUREPERSPECTIVE, TexturePerspective); <br>  dev-&gt;SetRenderState(D3DRENDERSTATE_TEXTUREMAPBLEND,    TextureBlend); <br>  dev-&gt;SetRenderState(D3DRENDERSTATE_TEXTUREHANDLE,      TextureHandle); <br> <br>  for (i = 0; i &lt; 6; ++i) <br>  { <br>    //*** Get the shading colors <br> <br>    int Red, Green, Blue; <br> <br>    Red   = (int)(CubeColors[i][0] * CubeSurfaceShades[i]); <br>    Green = (int)(CubeColors[i][1] * CubeSurfaceShades[i]); <br>    Blue  = (int)(CubeColors[i][2] * CubeSurfaceShades[i]); <br> <br>    //*** Collect the correct points in an array <br>    D3DTLVERTEX TLVertices[6]; <br> <br>    for (int j = 0; j &lt; 4; ++j) <br>    { <br>        TLVertices[j].sx = aScreenVerticesX[CubeFaces[i][j]]; <br>        TLVertices[j].sy = aScreenVerticesY[CubeFaces[i][j]]; <br>        TLVertices[j].sz = aScreenVerticesZ[CubeFaces[i][j]]; <br>        TLVertices[j].rhw = (float)(1.0 / aScreenVerticesW[CubeFaces[i][j]]); <br>        TLVertices[j].color = RGB_MAKE(Red, Green, Blue); <br>        TLVertices[j].specular = RGB_MAKE(0,0,0); <br>    } <br> <br>    TLVertices[0].tu = 0.0f; TLVertices[0].tv = 0.0f; <br>    TLVertices[1].tu = 1.0f; TLVertices[1].tv = 0.0f; <br>    TLVertices[2].tu = 1.0f; TLVertices[2].tv = 1.0f; <br>    TLVertices[3].tu = 0.0f; TLVertices[3].tv = 1.0f; <br> <br>    //*** Use DrawPrim to draw the face <br>    err = dev-&gt;DrawPrimitive(D3DPT_TRIANGLEFAN, D3DVT_TLVERTEX, TLVertices, 4, D3DDP_WAIT); <br>  } <br> <br>  err = dev-&gt;EndScene(); <br> <br>  return TRUE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
