<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FFCREATE.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3163"></a>FFCREATE.C</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved. <br> * <br> *  File:       ffcreate.c <br> *  Content:Fast file I/O for large numbers of files. <br> *Turns all files in a directory into a single file. <br> *This single file contains a directory + all the files. <br> * <br> * THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, <br> * EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED <br> * WARRANTIES OF MERCHANTBILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE. <br> * <br> ***************************************************************************/ <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;ctype.h&gt; <br>#include &lt;sys\types.h&gt; <br>#include &lt;sys\stat.h&gt; <br>#include &lt;fcntl.h&gt; <br>#include &lt;io.h&gt; <br>#include &lt;malloc.h&gt; <br> <br>#ifdef __WATCOMC__ <br>#define _open open <br>#define _close close <br>#define _lseek lseek <br>#define _read read <br>#define _write write <br>#define _stricmp stricmp <br>#define _S_IREAD S_IREAD <br>#define _S_IWRITE S_IWRITE <br>#endif <br> <br>#include "ffent.h" <br> <br>#define BLOCK_SIZE16*1024 <br> <br>/* <br> * Compare <br> * <br> * quicksort comparison routine <br> */ <br>int Compare( const LPFILEENTRY p1, const LPFILEENTRY p2 ) <br>{ <br>    return( _stricmp( (p1)-&gt;name,(p2)-&gt;name ) ); <br>} <br> <br>/* <br> * main <br> */ <br>main( int argc, char *argv[] ) <br>{ <br>    HANDLEdir; <br>    WIN32_FIND_DATAfd; <br>    intout; <br>    intin; <br>    unsigned longcnt; <br>    unsigned longtmp; <br>    LPFILEENTRYpfe; <br>    inti; <br>    intbytes; <br>    intoutbytes; <br>    char*buff; <br>    char*fname; <br>    char*dename; <br>    longpos; <br> <br>    /* <br>     * get i/o buffer <br>     */ <br>    buff = malloc( BLOCK_SIZE ); <br>    if( buff == NULL ) { <br>printf( "Out of memory!\n" ); <br>exit( 1 ); <br>    } <br> <br>    /* <br>     * get fastfile name, open file <br>     */ <br>    if( argc &lt; 2 ) { <br>fname = "\\result.ff"; <br>    } else { <br>fname = argv[1]; <br>    } <br>    printf( "Creating FastFile \"%s\"\n", fname ); <br>    out = _open( fname, O_CREAT | O_TRUNC | O_WRONLY | O_BINARY, <br>    _S_IREAD | _S_IWRITE ); <br>    if( out &lt; 0 ) { <br>printf( "Could not open file \"%s\"", fname ); <br>exit( 1 ); <br>    } <br> <br>    /* <br>     * build a header <br>     */ <br>    cnt = 0; <br>    printf( "Pass 1: building header\n" ); <br>    dir = FindFirstFile( "*.*", &amp;fd ); <br>    if( dir == NULL ) { <br>printf( "Could not open current directory\n" ); <br>_close( out ); <br>exit( 1 ); <br>    } <br>    pfe = NULL; <br>    while( 1 ) { <br>if( !(fd.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) ) { <br>    cnt++; <br>    pfe = realloc( pfe, (cnt+1) * sizeof( FILEENTRY ) ); <br>    memset( &amp;pfe[cnt-1], 0, sizeof( FILEENTRY )*2 ); <br>    if( pfe == NULL ) { <br>printf( "Out of memory!\n" ); <br>_close( out ); <br>exit( 1 ); <br>    } <br>    dename = fd.cAlternateFileName; <br>    if( dename[0] == 0 ) { <br>dename = fd.cFileName; <br>    } <br>    printf( "File %d: %s                 \r", cnt, dename ); <br>    pfe[cnt-1].offset = 0; <br>    strcpy( pfe[cnt-1].name, dename ); <br>} <br>if( !FindNextFile( dir, &amp;fd ) ) { <br>    break; <br>} <br>    } <br>    FindClose( dir ); <br> <br>    if( cnt == 0 ) { <br>printf( "No files found!\n" ); <br>exit( 0 ); <br>    } <br> <br>    /* <br>     * sort the directory <br>     */ <br>    qsort( pfe, cnt, sizeof( FILEENTRY ), (LPVOID) Compare ); <br> <br>    /* <br>     * write the number of directory entries + the directory <br>     */ <br>    tmp = cnt+1; <br>    bytes = _write( out, &amp;tmp, sizeof( tmp ) ); <br>    if( bytes != sizeof( tmp ) ) { <br>printf( "Error writing output file\n" ); <br>_close( out ); <br>exit( 1 ); <br>    } <br>    bytes = _write( out, pfe, tmp * sizeof( FILEENTRY ) ); <br>    if( bytes != (int) (tmp * sizeof( FILEENTRY )) ) { <br>printf( "Error writing output file\n" ); <br>_close( out ); <br>exit( 1 ); <br>    } <br> <br>    /* <br>     * now read all of the files one by one and add them to the fastfile <br>     */ <br>    printf( "Pass 2: adding data files                  \n" ); <br>    for( i=0;i&lt;(int)cnt;i++ ) { <br>/* <br> * save current file position <br> */ <br>pfe[i].offset = _lseek( out, 0, SEEK_CUR ); <br>if( pfe[i].offset &lt; 0 ) { <br>    printf( "\nSeek error on output file\n" ); <br>    _close( out ); <br>    exit( 1 ); <br>} <br> <br>/* <br> * open next file to add <br> */ <br>in = _open( pfe[i].name, O_RDONLY | O_BINARY, 0 ); <br>printf( "File %d: \"%s\", offset=%ld                          \r", <br>i+1, pfe[i].name, pfe[i].offset ); <br>if( in &lt; 0 ) { <br>    printf( "\nError opening file %s\n", pfe[i].name ); <br>    _close( out ); <br>    exit( 1 ); <br>} <br> <br>/* <br> * copy the data in the file <br> */ <br>while( 1 ) { <br>    bytes = _read( in, buff, BLOCK_SIZE ); <br>    if( bytes == 0 ) { <br>break; <br>    } <br>    if( bytes &lt; 0 ) { <br>printf( "\nError reading file %s\n", pfe[i].name ); <br>_close( in ); <br>_close( out ); <br>exit( 1 ); <br>    } <br>    outbytes = _write( out, buff, bytes ); <br>    if( bytes != outbytes ) { <br>printf( "\nError writing output file\n" ); <br>_close( in ); <br>_close( out ); <br>exit( 1 ); <br>    } <br>    if( bytes &lt; BLOCK_SIZE ) { <br>break; <br>    } <br>} <br>_close( in ); <br>    } <br> <br>    /* <br>     * get position of file end <br>     */ <br>    pfe[i].offset = _lseek( out, 0, SEEK_CUR ); <br> <br>    /* <br>     * seek to the start of the directory (right after the # of entries) <br>     */ <br>    pos = _lseek( out, sizeof( tmp ), SEEK_SET ); <br>    if( pos != sizeof( tmp ) ) { <br>printf( "Seek error on output file\n" ); <br>_close( out ); <br>exit( 1 ); <br>    } <br> <br>    /* <br>     * re-write the directory with the offsets setup <br>     */ <br>    bytes = _write( out, pfe, tmp * sizeof( FILEENTRY ) ); <br>    if( bytes != (int) (tmp * sizeof( FILEENTRY )) ) { <br>printf( "Error writing output file\n" ); <br>_close( out ); <br>exit( 1 ); <br>    } <br> <br>    /* <br>     * all done <br>     */ <br>    printf( "FastFile \"%s\" created:                   \n", fname ); <br>    printf( "    %ld files\n", tmp ); <br>    printf( "    %ld total file size\n", pfe[i].offset ); <br> <br>    _close( out ); <br>    return 0; <br> <br>} /* main */ </code></pre>
<p>&nbsp;</p></body>
</HTML>
