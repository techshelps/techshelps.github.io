<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FASTFILE.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3165"></a>FASTFILE.C</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved. <br> * <br> *  File:       fastfile.c <br> *  Content:Fast file I/O for large numbers of files. <br> *Uses a single file built using FFCREATE.EXE; this file <br> *contains a directory + all the files. <br> * <br> * THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, <br> * EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED <br> * WARRANTIES OF MERCHANTBILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE. <br> * <br> ***************************************************************************/ <br>#include &lt;windows.h&gt; <br>#include &lt;io.h&gt; <br>#include &lt;fcntl.h&gt; <br>#include &lt;search.h&gt; <br>#include &lt;stdio.h&gt; <br>#include "fastfile.h" <br>#include "ffent.h" <br> <br>#ifdef DEBUG <br>#define ODS( a ) OutputDebugString( a ) <br>#else <br>#define ODS( a ) <br>#endif <br> <br>#ifdef __WATCOMC__ <br>#define _stricmp stricmp <br>#endif <br> <br>typedef struct { <br>    BOOLinuse; <br>    LONGpos; <br>    LONGsize; <br>    LPFILEENTRYpfe; <br>} FILEHANDLE, FAR *LPFILEHANDLE; <br> <br>static int              LockCount; <br>static HANDLE           hFile; <br>static HANDLEhFileMapping; <br>static LPFILEENTRYpFE; <br>static LPBYTE           pBase; <br>static DWORDdwFECnt; <br>static LPFILEHANDLElpFH; <br>static DWORDdwFHCnt; <br>static longlFileEnd; <br> <br>/* <br> * Compare  <br> * <br> * bsearch comparison routine <br> */ <br>int Compare( LPFILEENTRY p1, LPFILEENTRY p2 ) <br>{ <br>    return( _stricmp( (p1)-&gt;name,(p2)-&gt;name ) ); <br> <br>} /* Compare */ <br> <br>/* <br> * FastFileInit <br> * <br> * Initialize for fast file access. The master file and maximum number <br> * of open "files" are specified. <br> */ <br>BOOL FastFileInit( LPSTR fname, int max_handles ) <br>{ <br>    HRSRC  h; <br> <br>    LockCount = 0; <br>    FastFileFini(); <br> <br>    /* <br>     * get a file handle array <br>     */ <br>    lpFH = LocalAlloc( LPTR, max_handles * sizeof( FILEHANDLE ) ); <br>    if( lpFH == NULL ) { <br>return FALSE; <br>    } <br>    dwFHCnt = max_handles; <br> <br>    /* <br>     * try our resourse file first <br>     */ <br>    if (h = FindResource(NULL, fname, RT_RCDATA)) <br>    { <br>        pBase = LockResource(LoadResource(NULL, h)); <br> <br>        if (pBase == NULL) <br>        { <br>            ODS( "FastFileInit: unable to lock resource\r\n" ); <br>            FastFileFini(); <br>            return FALSE; <br>        } <br> <br>        ODS( "FastFileInit: opened resource: "); ODS(fname); ODS("\r\n"); <br>    } <br>    else    <br>    { <br> <br>        /* <br>         * create a memory mapped file for the master file <br>         */ <br>        hFile = CreateFile( fname, GENERIC_READ, FILE_SHARE_READ, NULL, <br>OPEN_EXISTING, FILE_FLAG_RANDOM_ACCESS, 0 ); <br> <br>        if( hFile == NULL || hFile == (HANDLE)HFILE_ERROR ) <br>{ <br>            ODS( "FastFileInit: CreateFile(" ); ODS( fname ); ODS( ")\r\n" ); <br>            hFile = NULL; <br>            FastFileFini(); <br>            return FALSE; <br>        } <br>        hFileMapping = CreateFileMapping( hFile, NULL, PAGE_READONLY, 0, 0, NULL ); <br>        if( hFileMapping == NULL ) { <br>            ODS( "FastFileInit: CreateFileMapping Failed\r\n" ); <br>            FastFileFini(); <br>            return FALSE; <br>        } <br>        pBase = MapViewOfFile( hFileMapping, FILE_MAP_READ, 0, 0, 0 ); <br>        if( pBase == NULL ) { <br>            ODS( "FastFileInit: MapViewOfFile Failed\r\n" ); <br>            FastFileFini(); <br>            return FALSE; <br>        } <br>    } <br> <br>    /* <br>     * get initial data from the memory mapped file <br>     */ <br>    dwFECnt = *((DWORD *) pBase); <br>    pFE = (LPFILEENTRY) (pBase + 4); <br>    lFileEnd = pFE[dwFECnt-1].offset; <br> <br>    return TRUE; <br> <br>} /* FastFileInit */ <br> <br>/* <br> * FastFileFini <br> * <br> * Clean up resources <br> */ <br>void FastFileFini( void ) <br>{ <br>    // <br>    //  dont unmap things if we have locks out standing <br>    // <br>    if (LockCount != 0) <br>        return; <br> <br>    if( hFileMapping != NULL &amp;&amp; pBase ) { <br>        UnmapViewOfFile( pBase ); <br>    } <br>    if( hFileMapping != NULL ) { <br>CloseHandle( hFileMapping ); <br>hFileMapping = NULL; <br>    } <br>    if( hFile != NULL ) { <br>CloseHandle( hFile ); <br>hFile = NULL; <br>    } <br>    if( lpFH != NULL ) { <br>LocalFree( lpFH ); <br>lpFH = NULL; <br>    } <br>    dwFHCnt = 0; <br>    pBase = NULL; <br>    dwFECnt = 0; <br>    pFE = NULL; <br> <br>} /* FastFileFini */ <br> <br>/* <br> * FastFileOpen <br> * <br> * Search the directory for the file, and return a file handle if found. <br> */ <br>HFASTFILE FastFileOpen( LPSTR name ) <br>{ <br>    FILEENTRYfe; <br>    LPFILEENTRYpfe; <br> <br>    if( pFE == NULL ) { <br>ODS( "FastFileOpen: not initialized\r\n" ); <br>return NULL; <br>    } <br>    if( name == NULL || name[0] == 0 ) { <br>ODS( "FastFileOpen: invalid name\r\n" ); <br>return NULL; <br>    } <br> <br>    strcpy( fe.name, name ); <br>    pfe = bsearch( &amp;fe, pFE, dwFECnt, sizeof( FILEENTRY ), (LPVOID) Compare ); <br>    if( pfe != NULL ) { <br>DWORDi; <br>for( i=0;i&lt;dwFHCnt;i++ ) { <br>    if( !lpFH[i].inuse ) { <br>lpFH[i].inuse = TRUE; <br>lpFH[i].pos = pfe-&gt;offset; <br>lpFH[i].size = (pfe+1)-&gt;offset - pfe-&gt;offset; <br>lpFH[i].pfe = pfe; <br>return &amp;lpFH[i]; <br>    } <br>} <br>ODS( "FastFileOpen: Out of file handles\r\n" ); <br>    } else { <br>ODS( "FastFileOpen: File \"" ); ODS( name ); ODS( "\" not found\r\n" ); <br>    } <br> <br>    return NULL; <br> <br>} /* FastFileOpen */ <br> <br>/* <br> * FastFileClose <br> * <br> * Mark a fast file handle as closed <br> */ <br>BOOL FastFileClose( LPFILEHANDLE pfh ) <br>{ <br>    if( pfh == NULL || pfh-&gt;inuse != TRUE ) { <br>ODS( "FastFileClose: invalid handle\r\n" ); <br>return FALSE; <br>    } <br>    pfh-&gt;inuse = FALSE; <br>    return TRUE; <br> <br>} /* FastFileClose */ <br> <br>/* <br> * FastFileLock <br> * <br> * return a memory pointer into a fast file <br> */ <br>LPVOID FastFileLock( LPFILEHANDLE pfh, int pos, int size ) <br>{ <br>    if( pfh == NULL || pfh-&gt;inuse != TRUE ) { <br>        ODS( "FastFileLock: invalid handle\r\n" ); <br>        return NULL; <br>    } <br>    if( size &lt; 0 ) { <br>        ODS( "FastFileLock: invalid size\r\n" ); <br>        return NULL; <br>    } <br>    if( (pos + size) &gt; ((pfh-&gt;pfe)+1)-&gt;offset ) { <br>        ODS( "FastFileLock: read past end of file\r\n" ); <br>        return NULL; <br>    } <br>    LockCount++; <br>    return pBase + pfh-&gt;pos + pos; <br> <br>} /* FastFileLock */ <br> <br>/* <br> * FastFileUnlock <br> * <br> */ <br>BOOL FastFileUnlock( LPFILEHANDLE pfh, int pos, int size ) <br>{ <br>    if( pfh == NULL || pfh-&gt;inuse != TRUE ) { <br>        ODS( "FastFileUnlock: invalid handle\r\n" ); <br>        return FALSE; <br>    } <br>    if( size &lt; 0 ) { <br>        ODS( "FastFileUnlock: invalid size\r\n" ); <br>        return FALSE; <br>    } <br>    if( (pos + size) &gt; ((pfh-&gt;pfe)+1)-&gt;offset ) { <br>        ODS( "FastFileUnlock: read past end of file\r\n" ); <br>        return FALSE; <br>    } <br> <br>    LockCount--; <br>    return TRUE; <br> <br>} /* FastFileUnlock */ <br> <br>/* <br> * FastFileRead <br> * <br> * read from a fast file (memcpy!) <br> */ <br>BOOL FastFileRead( LPFILEHANDLE pfh, LPVOID ptr, int size ) <br>{ <br>    if( pfh == NULL || pfh-&gt;inuse != TRUE ) { <br>ODS( "FastFileRead: invalid handle\r\n" ); <br>return FALSE; <br>    } <br>    if( size &lt; 0 ) { <br>ODS( "FastFileRead: invalid size\r\n" ); <br>return FALSE; <br>    } <br>    if( (pfh-&gt;pos + size) &gt; ((pfh-&gt;pfe)+1)-&gt;offset ) { <br>ODS( "FastFileRead: read past end of file\r\n" ); <br>return FALSE; <br>    } <br>    memcpy( ptr, pBase + pfh-&gt;pos, size ); <br>    pfh-&gt;pos += size; <br>    return TRUE; <br> <br>} /* FastFileRead */ <br> <br>/* <br> * FastFileSeek <br> * <br> * Set to a new position in a fast file.  Uses standard SEEK_SET, SEEK_CUR, <br> * SEEK_END definitions. <br> */ <br>BOOL FastFileSeek( LPFILEHANDLE pfh, int off, int how ) <br>{ <br>    LPFILEENTRYpfe; <br> <br>    if( pfh == NULL || pfh-&gt;inuse != TRUE ) { <br>ODS( "FastFileSeek: invalid handle\r\n" ); <br>return FALSE; <br>    } <br>    pfe = pfh-&gt;pfe; <br>    if( how == SEEK_SET ) { <br>if( off &lt; 0 || off &gt;= pfh-&gt;size ) { <br>    ODS( "FastFileSeek: Invalid offset\r\n" ); <br>    return FALSE; <br>} <br>off += pfe-&gt;offset; <br>    } else if( how == SEEK_END ) { <br>if( off &lt; 0 || off &gt;= pfh-&gt;size ) { <br>    ODS( "FastFileSeek: Invalid offset\r\n" ); <br>    return FALSE; <br>} <br>off = (pfe+1)-&gt;offset - off; <br>    } else if( how == SEEK_CUR ) { <br>off = pfh-&gt;pos + off; <br>if( off &lt; pfe-&gt;offset || off &gt;= (pfe+1)-&gt;offset ) { <br>    ODS( "FastFileSeek: Invalid offset\r\n" ); <br>    return FALSE; <br>} <br>    } else { <br>ODS( "FastFileSeek: Invalid 'how' field\r\n" ); <br>return FALSE; <br>    } <br>    pfh-&gt;pos = off; <br>    return TRUE; <br> <br>} /* FastFileSeek */ <br> <br>/* <br> * FastFileTell <br> * <br> * Get the current position in a fast file <br> */ <br>long FastFileTell( LPFILEHANDLE pfh ) <br>{ <br>    if( pfh == NULL || pfh-&gt;inuse != TRUE ) { <br>ODS( "FastFileTell: invalid handle\r\n" ); <br>return -1; <br>    } <br>    return pfh-&gt;pos - pfh-&gt;pfe-&gt;offset; <br> <br>} /* FastFileTell */ <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
