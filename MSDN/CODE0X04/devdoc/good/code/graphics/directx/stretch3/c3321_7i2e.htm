<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>STRETCH.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3326"></a>STRETCH.CPP</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1995-1997 Microsoft Corporation. All Rights Reserved. <br> * <br> *  File:       stretch.cpp <br> * <br> *  stretch with multimonitor support <br> * <br> ***************************************************************************/ <br> <br>#define NAME "Stretch" <br>#define TITLE "Stretch" <br> <br>#define WIN32_LEAN_AND_MEAN <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;ddraw.h&gt; <br>#include "resource.h" <br>#include "ddutil2.h" <br>#include "ddmm.h" <br> <br>#define SIZEX64 <br>#define SIZEY64 <br>char *szBitmap = "DONUT"; <br> <br>HWNDhwnd1; <br>HWNDhwnd2; <br>DWORD           UpdateDelay = 100; <br> <br>LPDIRECTDRAW2lpDDArtWork;// DirectDraw object <br>LPDIRECTDRAWSURFACE3lpDDSArtWorkOriginal; <br>LPDIRECTDRAWSURFACE3lpDDSArtWork; <br>LPDIRECTDRAWPALETTElpDDPal = 0;// DirectDraw palette <br> <br>LPDIRECTDRAW2lpDD1;// DirectDraw object <br>LPDIRECTDRAWSURFACE3lpDDSPrimary1;// DirectDraw primary surface <br>LPDIRECTDRAWSURFACE3lpDDSOne1;// Offscreen surface 1 <br>LPDIRECTDRAWCLIPPER     lpClipper1;      // clipper for primary <br>DWORDThdId1; <br> <br>LPDIRECTDRAW2lpDD2;// DirectDraw object <br>LPDIRECTDRAWSURFACE3lpDDSPrimary2;// DirectDraw primary surface <br>LPDIRECTDRAWSURFACE3lpDDSOne2;// Offscreen surface 1 <br>LPDIRECTDRAWCLIPPER     lpClipper2;      // clipper for primary <br>DWORDThdId2; <br> <br>volatile int SpinLock = 0; <br>BOOL                    bActive;        // is application active? <br>VOID *                  lpArtWork;      // shared art work <br> <br>/* multimon stuff <br>*/ <br>int     MyDevice1; <br>char    MyDeviceName1[128]; <br>RECT    MyDeviceRect1; <br>int     MyDevice2; <br>char    MyDeviceName2[128]; <br>RECT    MyDeviceRect2; <br> <br>typedef struct <br>{ <br>    HINSTANCE hInstance; <br>    int nCmdShow; <br>}Thread_Info; <br> <br>Thread_Info ThdInfo; <br> <br>BOOL ddInit(HWND); <br>BOOL ddInit1(HWND); <br> <br>/* <br> * restoreAll <br> * <br> * restore all lost objects <br> */ <br>BOOL restoreAll( void ) <br>{ <br>    return ( <br>           lpDDSPrimary1-&gt;Restore() &amp;&amp; <br>           lpDDSPrimary2-&gt;Restore() &amp;&amp; <br>           lpDDSOne1-&gt;Restore() &amp;&amp; <br>           lpDDSOne2-&gt;Restore()  <br>   ); <br>} /* restoreAll */ <br> <br>/* <br> * updateFrame <br> *  <br> * Decide what needs to be blitted next, wait for flip to complete, <br> * then flip the buffers. <br> */ <br>void updateFrame( void ) <br>{ <br>    static DWORDlastTickCount = 0; <br>    static intcurrentFrame = 0; <br>    static BOOL         haveBackground = FALSE; <br>    DWORDthisTickCount; <br>    RECTrcRect; <br>    RECTdestRect; <br>    HRESULTddrval; <br>    POINT               pt; <br> <br>    thisTickCount = GetTickCount(); <br>    if((thisTickCount - lastTickCount) &lt;= UpdateDelay) <br>    { <br>return; <br>    } <br> <br>    // Move to next frame; <br>    lastTickCount = thisTickCount; <br>    currentFrame++; <br>    if(currentFrame &gt; 59) <br>    { <br>        currentFrame = 0; <br>    } <br> <br>    // Blit the stuff for the next frame <br>    rcRect.left   = currentFrame%10*64; <br>    rcRect.top    = currentFrame/10*64; <br>    rcRect.right  = currentFrame%10*64 + 64; <br>    rcRect.bottom = currentFrame/10*64 + 64; <br> <br>    GetClientRect( hwnd1, &amp;destRect ); <br>    if (destRect.right  &lt; 64) destRect.right = 64; <br>    if (destRect.bottom &lt; 64)  destRect.bottom = 64; <br> <br>    pt.x = pt.y = 0; <br>    ClientToScreen( hwnd1, &amp;pt ); <br>    pt.x -= MyDeviceRect1.left; <br>    pt.y -= MyDeviceRect1.top; <br>    OffsetRect(&amp;destRect, pt.x, pt.y); <br> <br> <br>    while( 1 ) <br>    { <br>        ddrval = lpDDSPrimary1-&gt;Blt( &amp;destRect, lpDDSOne1, &amp;rcRect, 0, NULL ); <br> <br>        if( ddrval == DD_OK ) <br>        { <br>            break; <br>        } <br>        if( ddrval == DDERR_SURFACELOST ) <br>        { <br>            if(!restoreAll()) <br>            { <br>                return; <br>            } <br>     } <br>        if( ddrval != DDERR_WASSTILLDRAWING ) <br>        { <br>            return; <br>        } <br>    }; <br>    if(ddrval != DD_OK) <br>    { <br>        return; <br>    } <br>} /* updateFrame */ <br> <br>/* <br> * updateFrame1 <br> *  <br> * Decide what needs to be blitted next, wait for flip to complete, <br> * then flip the buffers. <br> */ <br>void updateFrame1( void ) <br>{ <br>    static DWORDlastTickCount = 0; <br>    static intcurrentFrame = 0; <br>    static BOOL         haveBackground = FALSE; <br>    DWORDthisTickCount; <br>    RECTrcRect; <br>    RECTdestRect; <br>    HRESULTddrval; <br>    POINT               pt; <br> <br>    thisTickCount = GetTickCount(); <br>    if((thisTickCount - lastTickCount) &lt;= UpdateDelay) <br>    { <br>return; <br>    } <br> <br>    // Move to next frame; <br>    lastTickCount = thisTickCount; <br>    currentFrame++; <br>    if(currentFrame &gt; 59) <br>    { <br>        currentFrame = 0; <br>    } <br> <br>    // Blit the stuff for the next frame <br>    rcRect.left   = currentFrame%10*64; <br>    rcRect.top    = currentFrame/10*64; <br>    rcRect.right  = currentFrame%10*64 + 64; <br>    rcRect.bottom = currentFrame/10*64 + 64; <br> <br>    GetClientRect( hwnd2, &amp;destRect ); <br>    if (destRect.right  &lt; 64) destRect.right = 64; <br>    if (destRect.bottom &lt; 64)  destRect.bottom = 64; <br> <br>    pt.x = pt.y = 0; <br>    ClientToScreen( hwnd2, &amp;pt ); <br>    pt.x -= MyDeviceRect2.left; <br>    pt.y -= MyDeviceRect2.top; <br>    OffsetRect(&amp;destRect, pt.x, pt.y); <br> <br> <br>    while( 1 ) <br>    { <br>        ddrval = lpDDSPrimary2-&gt;Blt( &amp;destRect, lpDDSOne2, &amp;rcRect, 0, NULL ); <br> <br>        if( ddrval == DD_OK ) <br>        { <br>            break; <br>        } <br>        if( ddrval == DDERR_SURFACELOST ) <br>        { <br>            if(!restoreAll()) <br>            { <br>                return; <br>            } <br>     } <br>        if( ddrval != DDERR_WASSTILLDRAWING ) <br>        { <br>            return; <br>        } <br>    } <br> <br>    if(ddrval != DD_OK) <br>    { <br>        return; <br>    } <br>} /* updateFrame1 */ <br> <br> <br>/* <br> * finiObjects <br> * <br> * finished with all objects we use; release them <br> */ <br>static void finiObjects( BOOL fKillDD ) <br>{ <br>    if( lpDDSPrimary1 != NULL ) <br>    { <br>        lpDDSPrimary1-&gt;Release(); <br>        lpDDSPrimary1 = NULL; <br>    } <br>    if( lpDDSOne1 != NULL ) <br>    { <br>        lpDDSOne1-&gt;Release(); <br>        lpDDSOne1 = NULL; <br>    } <br>    if( lpDDPal != NULL ) <br>    { <br>        lpDDPal-&gt;Release(); <br>        lpDDPal = NULL; <br>    } <br>    if( fKillDD &amp;&amp; lpDD1 != NULL ) <br>    { <br>        lpDD1-&gt;Release(); <br>        lpDD1 = NULL; <br>    } <br>} /* finiObjects */ <br>static void finiObjects1( BOOL fKillDD ) <br>{ <br>    if( lpDDSPrimary2 != NULL ) <br>    { <br>        lpDDSPrimary2-&gt;Release(); <br>        lpDDSPrimary2 = NULL; <br>    } <br>    if( lpDDSOne2 != NULL ) <br>    { <br>        lpDDSOne2-&gt;Release(); <br>        lpDDSOne2 = NULL; <br>    } <br>    if( lpDDPal != NULL ) <br>    { <br>        lpDDPal-&gt;Release(); <br>        lpDDPal = NULL; <br>    } <br>    if( fKillDD &amp;&amp; lpDD2 != NULL ) <br>    { <br>        lpDD2-&gt;Release(); <br>        lpDD2 = NULL; <br>    } <br>} /* finiObjects1 */ <br> <br>long FAR PASCAL WindowProc( HWND hWnd, UINT message,  <br>    WPARAM wParam, LPARAM lParam ) <br>{ <br>    RECT  rc; <br> <br>    switch( message ) <br>    { <br>    case WM_ACTIVATEAPP: <br>    bActive = wParam; <br>break; <br> <br>    case WM_SIZE: <br>    case WM_MOVE: <br>        if(hWnd == hwnd1) <br>        { <br>            if (MyDevice1 != DirectDrawDeviceFromWindow(hWnd,NULL,NULL)) <br>            { <br>                ddInit(hwnd1); <br>            } <br>        } <br>        if(hWnd == hwnd2) <br>        { <br>            if (MyDevice2 != DirectDrawDeviceFromWindow(hWnd,NULL,NULL)) <br>            { <br>                ddInit1(hwnd2); <br>            } <br>        } <br>        break; <br> <br>    case WM_PALETTECHANGED: <br>        if ((HWND)wParam == hWnd) <br>            break; <br>        // fall through to WM_QUERYNEWPALETTE <br>    case WM_QUERYNEWPALETTE: <br>/*--------------------------------------------------------** <br>**  Er um, truth is this app is broken on palette change  ** <br>**  see ddInitArtWork to understand why.                  ** <br>**--------------------------------------------------------*/ <br>        break; <br> <br>    case WM_CREATE: <br>        break; <br> <br>    case WM_GETMINMAXINFO: <br>        ((MINMAXINFO*)lParam)-&gt;ptMinTrackSize.x = SIZEX; <br>        ((MINMAXINFO*)lParam)-&gt;ptMinTrackSize.y = SIZEY; <br>        return 0; <br> <br>    case WM_KEYDOWN: <br>switch( wParam ) <br>{ <br>case VK_ESCAPE: <br>        case VK_F12: <br>            PostMessage(hWnd, WM_CLOSE, 0, 0); <br>    break; <br>} <br>break; <br> <br>    case WM_DESTROY: <br>        if(hWnd == hwnd1) <br>        { <br>            finiObjects(TRUE); <br>    } <br>        if(hWnd == hwnd2) <br>        { <br>            finiObjects1(TRUE); <br>} <br>PostQuitMessage( 0 ); <br>        break; <br> <br>    case WM_KEYUP: <br>        if (wParam &gt;= '1' &amp;&amp; wParam &lt;= '9') <br>        { <br>            SetRect(&amp;rc, 0, 0, SIZEX*(wParam-'0'), SIZEY*(wParam-'0')); <br>            goto size_me; <br>        } <br>        break; <br> <br>    case WM_COMMAND:  <br>    switch(LOWORD(wParam)) <br>{ <br>    case ID_ROTATION_STOP:     <br>UpdateDelay = 0x7fffffff; <br>break; <br>    case ID_ROTATION_SLOW:     <br>UpdateDelay = 200; <br>break; <br>    case ID_ROTATION_FAST:     <br>                UpdateDelay = 100; <br>break; <br>    case ID_FILE_EXIT:     <br>                PostMessage( hWnd, WM_CLOSE, 0, 0L ); <br>        break; <br>     <br>            case ID_SIZE_1X1: SetRect(&amp;rc, 0, 0, SIZEX*1, SIZEY*1); goto size_me; <br>            case ID_SIZE_2X1: SetRect(&amp;rc, 0, 0, SIZEX*2, SIZEY*1); goto size_me; <br>            case ID_SIZE_3X1: SetRect(&amp;rc, 0, 0, SIZEX*3, SIZEY*1); goto size_me; <br>            case ID_SIZE_1X2: SetRect(&amp;rc, 0, 0, SIZEX*1, SIZEY*2); goto size_me; <br>            case ID_SIZE_2X2: SetRect(&amp;rc, 0, 0, SIZEX*2, SIZEY*2); goto size_me; <br>            case ID_SIZE_3X2: SetRect(&amp;rc, 0, 0, SIZEX*3, SIZEY*2); goto size_me; <br>            case ID_SIZE_1X3: SetRect(&amp;rc, 0, 0, SIZEX*1, SIZEY*3); goto size_me; <br>            case ID_SIZE_2X3: SetRect(&amp;rc, 0, 0, SIZEX*2, SIZEY*3); goto size_me; <br>    case ID_SIZE_3X3: SetRect(&amp;rc, 0, 0, SIZEX*3, SIZEY*3); goto size_me; <br>size_me: <br>                AdjustWindowRectEx(&amp;rc, GetWindowLong(hWnd, GWL_STYLE), <br>    GetMenu(hWnd) != NULL, GetWindowLong(hWnd, GWL_EXSTYLE)); <br>SetWindowPos(hWnd, NULL, 0, 0, rc.right-rc.left, rc.bottom-rc.top, <br>                    SWP_NOZORDER|SWP_NOMOVE|SWP_NOACTIVATE); <br>break; <br>    }  <br>    break; <br>    } <br> <br>    return DefWindowProc(hWnd, message, wParam, lParam); <br> <br>} /* WindowProc */ <br> <br>/* <br> * This function is called if the initialization function fails <br> */ <br>BOOL initFail( HWND hwnd ) <br>{ <br>    finiObjects(TRUE); <br>    finiObjects1(TRUE); <br>    MessageBox( hwnd, "DirectDraw Init FAILED", TITLE, MB_OK ); <br>    DestroyWindow( hwnd ); <br>    return FALSE; <br> <br>} /* initFail */ <br> <br>/* <br> * ddInit <br> */ <br>BOOL ddInit( HWND hwnd ) <br>{ <br>    DDSURFACEDESCddsd; <br>    HRESULT             ddrval; <br>    char                ach[128]; <br> <br>    /* <br>     * clean up our mess <br>     */ <br>    finiObjects(TRUE); <br> <br>    MyDevice1 = DirectDrawDeviceFromWindow(hwnd,MyDeviceName1,&amp;MyDeviceRect1); <br> <br>    if (MyDeviceName1[0] == 0) lstrcpy(MyDeviceName1, "(none)"); <br>    wsprintf(ach, "%s - %s", TITLE, MyDeviceName1); <br>    SetWindowText(hwnd1, ach); <br> <br>    /* <br>     * create the main DirectDraw object <br>     */ <br>    LPDIRECTDRAW lpDDT; <br>    lpDDT = DirectDrawCreateFromWindow(hwnd); <br>    if( lpDDT == NULL ) <br>    { <br>    return initFail(hwnd); <br>    } <br>    ddrval = lpDDT-&gt;QueryInterface(IID_IDirectDraw2, (void**)&amp;lpDD1); <br> <br>    if( lpDD1 == NULL ) <br>    { <br>    return initFail(hwnd); <br>    } <br>    lpDDT-&gt;Release(); <br>     <br>    ddrval = lpDD1-&gt;SetCooperativeLevel( hwnd, DDSCL_NORMAL ); <br> <br>    // Create the primary surface <br>    ddsd.dwSize = sizeof( ddsd ); <br>    ddsd.dwFlags = DDSD_CAPS; <br>    ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE; <br> <br>    LPDIRECTDRAWSURFACE lpDDSTemp; <br>    ddrval = lpDD1-&gt;CreateSurface( &amp;ddsd, &amp;lpDDSTemp, NULL ); <br>    if( ddrval != DD_OK ) <br>    { <br>        return initFail(hwnd); <br>    } <br>    ddrval = lpDDSTemp-&gt;QueryInterface(IID_IDirectDrawSurface3, (void**)&amp;lpDDSPrimary1); <br>    if( ddrval != DD_OK ) <br>    { <br>        return initFail(hwnd); <br>    } <br>    lpDDSTemp-&gt;Release(); <br> <br>    // create a clipper for the primary surface <br>    ddrval = lpDD1-&gt;CreateClipper( 0, &amp;lpClipper1, NULL ); <br>    if( ddrval != DD_OK ) <br>    { <br>        return initFail(hwnd); <br>    } <br> <br>    ddrval = lpClipper1-&gt;SetHWnd( 0, hwnd ); <br>    if( ddrval != DD_OK ) <br>    { <br>        return initFail(hwnd); <br>    } <br> <br>    ddrval = lpDDSPrimary1-&gt;SetClipper( lpClipper1 ); <br>    if( ddrval != DD_OK ) <br>    { <br>        return initFail(hwnd); <br>    } <br> <br>     // load our palette                                      <br>     lpDDPal = DDLoadPalette2(lpDD1, szBitmap);               <br>                                                              <br>     // make sure to set the palette before loading bitmaps.  <br>     if (lpDDPal)                                             <br>        lpDDSPrimary1-&gt;SetPalette(lpDDPal);                     <br> <br>    // load our bitmap <br>    ZeroMemory(&amp;ddsd, sizeof(ddsd)); <br>    ddsd.dwSize = sizeof(ddsd); <br>    ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT |DDSD_WIDTH; <br>    ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN | DDSCAPS_SYSTEMMEMORY; <br>    ddsd.dwWidth = 2; <br>    ddsd.dwHeight = 2; <br> <br>    if (lpDD1-&gt;CreateSurface(&amp;ddsd, &amp;lpDDSTemp, NULL) != DD_OK) <br>    { <br>        OutputDebugString("CreateSurf failed"); <br>        return initFail(hwnd); <br>    } <br>    //CreateSurface must set SurfaceMemory Flag <br>    ZeroMemory(&amp;ddsd, sizeof(ddsd)); <br>    ddsd.dwSize = sizeof(ddsd); <br>    ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT |DDSD_WIDTH; <br>    ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN | DDSCAPS_SYSTEMMEMORY; <br>    ddsd.dwWidth = 2;  // It's going away anyway <br>    ddsd.dwHeight = 2; <br>    if (lpDD1-&gt;CreateSurface(&amp;ddsd, &amp;lpDDSTemp, NULL) != DD_OK) <br>    { <br>        OutputDebugString("CreateSurf failed"); <br>        return initFail(hwnd); <br>    }; <br> <br>    if (lpDDSTemp-&gt;QueryInterface(IID_IDirectDrawSurface3,(void**)&amp;lpDDSOne1) != DD_OK) <br>    { <br>        OutputDebugString("QueryInterface failed"); <br>        return initFail(hwnd); <br>    } <br>    lpDDSTemp-&gt;Release(); <br> <br>    if( lpDDSOne1 == NULL ) <br>    { <br>    return initFail(hwnd); <br>    } <br> <br>    //Get the size of the surface <br>    DDSURFACEDESC DDSDesc; <br>    memset(&amp;DDSDesc,0,sizeof(DDSURFACEDESC)); <br>    DDSDesc.dwSize = sizeof(DDSURFACEDESC); <br>    DDSDesc.dwFlags =  DDSD_WIDTH | DDSD_HEIGHT | DDSD_PITCH; <br>    ddrval = lpDDSArtWork-&gt;GetSurfaceDesc(&amp;DDSDesc); <br>    if( ddrval != DD_OK ) <br>    { <br>        return initFail(hwnd); <br>    } <br> <br>    //Set the memory into the surface <br>    DDSDesc.dwFlags =  DDSD_LPSURFACE | DDSD_WIDTH | DDSD_HEIGHT | DDSD_PITCH; <br>    DDSDesc.lpSurface = lpArtWork;     <br>     <br>    ddrval = lpDDSOne1-&gt;SetSurfaceDesc(&amp;DDSDesc,0); <br>    if( ddrval != DD_OK ) <br>    { <br>        return initFail(hwnd); <br>    } <br> <br> <br>    return TRUE; <br>} /* doInit */ <br> <br> <br>/* <br> * ddInit1 <br> */ <br>BOOL ddInit1( HWND hwnd ) <br>{ <br>    DDSURFACEDESCddsd; <br>    HRESULT             ddrval; <br>    char                ach[128]; <br> <br>    /* <br>     * clean up our mess <br>     */ <br>    finiObjects1(TRUE); <br> <br>    MyDevice2 = DirectDrawDeviceFromWindow(hwnd,MyDeviceName2,&amp;MyDeviceRect2); <br> <br>    if (MyDeviceName2[0] == 0) lstrcpy(MyDeviceName2, "(none)"); <br>    wsprintf(ach, "%s - %s", TITLE, MyDeviceName2); <br>    SetWindowText(hwnd, ach); <br> <br>    /* <br>     * create the main DirectDraw object <br>     */ <br>    LPDIRECTDRAW lpDDT; <br>    lpDDT = DirectDrawCreateFromWindow(hwnd); <br>    if( lpDDT == NULL ) <br>    { <br>    return initFail(hwnd); <br>    } <br>    ddrval = lpDDT-&gt;QueryInterface(IID_IDirectDraw2, (void**)&amp;lpDD2); <br> <br>    if( lpDD2 == NULL ) <br>    { <br>    return initFail(hwnd); <br>    } <br>    lpDDT-&gt;Release(); <br>    ddrval = lpDD2-&gt;SetCooperativeLevel( hwnd, DDSCL_NORMAL ); <br> <br>    // Create the primary surface <br>    ddsd.dwSize = sizeof( ddsd ); <br>    ddsd.dwFlags = DDSD_CAPS; <br>    ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE; <br> <br>    LPDIRECTDRAWSURFACE lpDDSTemp; <br>    ddrval = lpDD2-&gt;CreateSurface( &amp;ddsd, &amp;lpDDSTemp, NULL ); <br>    if( ddrval != DD_OK ) <br>    { <br>        return initFail(hwnd); <br>    } <br>    ddrval = lpDDSTemp-&gt;QueryInterface(IID_IDirectDrawSurface3, (void**)&amp;lpDDSPrimary2); <br>    if( ddrval != DD_OK ) <br>    { <br>        return initFail(hwnd); <br>    } <br>    lpDDSTemp-&gt;Release(); <br> <br>    // create a clipper for the primary surface <br>    ddrval = lpDD2-&gt;CreateClipper( 0, &amp;lpClipper2, NULL ); <br>    if( ddrval != DD_OK ) <br>    { <br>        return initFail(hwnd); <br>    } <br> <br>    ddrval = lpClipper2-&gt;SetHWnd( 0, hwnd ); <br>    if( ddrval != DD_OK ) <br>    { <br>        return initFail(hwnd); <br>    } <br> <br>    ddrval = lpDDSPrimary2-&gt;SetClipper( lpClipper2 ); <br>    if( ddrval != DD_OK ) <br>    { <br>        return initFail(hwnd); <br>    } <br> <br>    // load our palette                                      <br>    lpDDPal = DDLoadPalette2(lpDD2, szBitmap);               <br>                                                              <br>    // make sure to set the palette before loading bitmaps.  <br>    if (lpDDPal)                                             <br>        lpDDSPrimary2-&gt;SetPalette(lpDDPal);                     <br>                                                              <br> <br>    //CreateSurface must set SurfaceMemory Flag <br>    ZeroMemory(&amp;ddsd, sizeof(ddsd)); <br>    ddsd.dwSize = sizeof(ddsd); <br>    ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT |DDSD_WIDTH; <br>    ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN | DDSCAPS_SYSTEMMEMORY; <br>    ddsd.dwWidth = 2;  // It's going away anyway <br>    ddsd.dwHeight = 2; <br>    if (lpDD2-&gt;CreateSurface(&amp;ddsd, &amp;lpDDSTemp, NULL) != DD_OK) <br>    { <br>        OutputDebugString("CreateSurf failed"); <br>        return initFail(hwnd); <br>    }; <br> <br>    if (lpDDSTemp-&gt;QueryInterface(IID_IDirectDrawSurface3,(void**)&amp;lpDDSOne2) != DD_OK) <br>    { <br>        OutputDebugString("QueryInterface failed"); <br>        return initFail(hwnd); <br>    } <br>    lpDDSTemp-&gt;Release(); <br> <br>    if( lpDDSOne2 == NULL ) <br>    { <br>    return initFail(hwnd); <br>    } <br> <br>    //Get the size of the surface <br>    DDSURFACEDESC DDSDesc; <br>    memset(&amp;DDSDesc,0,sizeof(DDSURFACEDESC)); <br>    DDSDesc.dwSize = sizeof(DDSURFACEDESC); <br>    DDSDesc.dwFlags =  DDSD_WIDTH | DDSD_HEIGHT | DDSD_PITCH; <br>    ddrval = lpDDSArtWork-&gt;GetSurfaceDesc(&amp;DDSDesc); <br>    if( ddrval != DD_OK ) <br>    { <br>        return initFail(hwnd); <br>    } <br> <br>    //Set the memory into the surface <br>    DDSDesc.dwFlags =  DDSD_LPSURFACE | DDSD_WIDTH | DDSD_HEIGHT | DDSD_PITCH; <br>    DDSDesc.lpSurface = lpArtWork;     <br>     <br>    ddrval = lpDDSOne2-&gt;SetSurfaceDesc(&amp;DDSDesc,0); <br>    if( ddrval != DD_OK ) <br>    { <br>        return initFail(hwnd); <br>    } <br> <br>    return TRUE; <br>} /* doInit1 */ <br> <br> <br> <br>/*-------------------------------------------------------** <br>** This code assumes that if more than one monitor exist ** <br>** that they have the same color depth, else sharing     ** <br>** artwork doesn't make sense                            ** <br>**-------------------------------------------------------*/ <br>BOOL ddInitArtWork(void ) <br>{ <br>    DDSURFACEDESCddsd; <br>    HRESULT             ddrval; <br> <br>    /* <br>     * create the main DirectDraw object <br>     */ <br>    LPDIRECTDRAW lpDDT; <br>    ddrval = DirectDrawCreate(NULL,&amp;lpDDT,0); <br>    if( ddrval != DD_OK ) <br>    { <br>    return initFail(NULL); <br>    } <br>    ddrval = lpDDT-&gt;QueryInterface(IID_IDirectDraw2, (void**)&amp;lpDDArtWork); <br>    if( ddrval != DD_OK ) <br>    { <br>    return initFail(NULL); <br>    } <br> <br>    lpDDT-&gt;Release(); <br>    ddrval = lpDDArtWork-&gt;SetCooperativeLevel( NULL, DDSCL_NORMAL ); <br> <br>    //CreateSurface must set SurfaceMemory Flag <br>    LPDIRECTDRAWSURFACE lpDDSTemp; <br>    ZeroMemory(&amp;ddsd, sizeof(ddsd)); <br>    ddsd.dwSize = sizeof(ddsd); <br>    ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT |DDSD_WIDTH; <br>    ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN | DDSCAPS_SYSTEMMEMORY; <br>    ddsd.dwWidth = 2;  // It's going away anyway <br>    ddsd.dwHeight = 2; <br>    if (lpDDArtWork-&gt;CreateSurface(&amp;ddsd, &amp;lpDDSTemp, NULL) != DD_OK) <br>    { <br>        OutputDebugString("CreateSurf failed"); <br>        return initFail(NULL); <br>    }; <br> <br>    if (lpDDSTemp-&gt;QueryInterface(IID_IDirectDrawSurface3,(void**)&amp;lpDDSArtWork) != DD_OK) <br>    { <br>        OutputDebugString("QueryInterface failed"); <br>        return initFail(NULL); <br>    } <br>    lpDDSTemp-&gt;Release(); <br> <br>    if( lpDDSArtWork == NULL ) <br>    { <br>    return initFail(NULL); <br>    } <br> <br>    // load our palette <br>    lpDDPal = DDLoadPalette2(lpDDArtWork, szBitmap); <br> <br>    //copy the preconverted bits to the surface <br>    lpDDSArtWorkOriginal = DDLoadBitmap2(lpDDArtWork, szBitmap, 0, 0); <br>    // make sure to set the palette before loading bitmaps. <br>    if (lpDDPal != 0) <br>lpDDSArtWorkOriginal-&gt;SetPalette(lpDDPal); <br>    //Get the size of the surface <br>    DDSURFACEDESC DDSDesc; <br>    memset(&amp;DDSDesc,0,sizeof(DDSURFACEDESC)); <br>    DDSDesc.dwSize = sizeof(DDSURFACEDESC); <br>    DDSDesc.dwFlags =  DDSD_WIDTH | DDSD_HEIGHT | DDSD_PITCH; <br>    ddrval = lpDDSArtWorkOriginal-&gt;GetSurfaceDesc(&amp;DDSDesc); <br>    if( ddrval != DD_OK ) <br>    { <br>        return initFail(NULL); <br>    } <br> <br>    //Alloc a surface.  The pitch must always be an integral number <br>    // of DWORDs, so we compute the theoretical pitch and then round it up. <br>    DDSDesc.lPitch =  DDSDesc.dwWidth*DDSDesc.ddpfPixelFormat.dwRGBBitCount/8; <br>    DDSDesc.lPitch = (DDSDesc.lPitch + 3) &amp; ~3; <br> <br>    lpArtWork = GlobalAlloc(GPTR, DDSDesc.lPitch * DDSDesc.dwHeight); <br> <br>    //Set the memory into the surface <br>    DDSDesc.dwFlags =  DDSD_LPSURFACE | DDSD_WIDTH | DDSD_HEIGHT | DDSD_PITCH; <br>    DDSDesc.lpSurface = lpArtWork;     <br>     <br>    ddrval = lpDDSArtWork-&gt;SetSurfaceDesc(&amp;DDSDesc,0); <br>    if( ddrval != DD_OK ) <br>    { <br>        return initFail(NULL); <br>    } <br> <br>    //copy the preconverted bits to the surface <br>    ddrval = lpDDSArtWork-&gt;Blt(NULL,lpDDSArtWorkOriginal,NULL,DDBLT_WAIT,NULL); <br>    if( ddrval != DD_OK ) <br>    { <br>        return initFail(NULL); <br>    } <br>    return TRUE; <br>} /* doInitArt */ <br> <br> <br>/* <br> * doInit - do work required for every instance of the application: <br> *  create the window, initialize data <br> */ <br>static BOOL doInit( Thread_Info *thd) <br>//HINSTANCE hInstance, int nCmdShow ) <br>{ <br>    WNDCLASSwc; <br>    MSG         msg; <br> <br>    /* <br>     * set up and register window class <br>     */ <br>    wc.style = CS_HREDRAW | CS_VREDRAW; <br>    wc.lpfnWndProc = WindowProc; <br>    wc.cbClsExtra = 0; <br>    wc.cbWndExtra = 0; <br>    wc.hInstance = thd-&gt;hInstance; <br>    wc.hIcon = LoadIcon( thd-&gt;hInstance, IDI_APPLICATION ); <br>    wc.hCursor = LoadCursor( NULL, IDC_ARROW ); <br>    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); <br>    wc.lpszMenuName = NULL; // MAKEINTRESOURCE(IDR_MENU); <br>    wc.lpszClassName = NAME; <br>    RegisterClass( &amp;wc ); <br>     <br>    /* <br>     * create a window <br>     */ <br>    hwnd1 = CreateWindowEx( <br>0, <br>NAME, <br>TITLE, <br>        WS_POPUP | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME, <br>CW_USEDEFAULT, <br>CW_USEDEFAULT, <br>128, <br>128, <br>NULL, <br>NULL, <br>thd-&gt;hInstance, <br>NULL ); <br> <br>    if( !hwnd1 ) <br>    { <br>return FALSE; <br>    } <br> <br>    PostMessage(hwnd1, WM_COMMAND, ID_SIZE_3X3, 0); <br> <br>    ShowWindow( hwnd1, thd-&gt;nCmdShow ); <br>    UpdateWindow( hwnd1 ); <br> <br>    /* <br>     * create the direct draw objects <br>     */ <br>    ddInit(hwnd1); <br> <br>    // Wait for both window to get ready <br>    SpinLock ++; <br>while(SpinLock &lt;2); <br> <br>    while( 1 ) <br>    { <br>if( PeekMessage( &amp;msg, NULL, 0, 0, PM_NOREMOVE ) ) <br>{ <br>    if( !GetMessage( &amp;msg, NULL, 0, 0 ) ) <br>return msg.wParam; <br>    TranslateMessage(&amp;msg);  <br>    DispatchMessage(&amp;msg); <br>} <br>        else <br>{ <br>    updateFrame(); <br>} <br>    } <br>} <br> <br>static BOOL doInit1(Thread_Info *thd) <br>//HINSTANCE hInstance, int nCmdShow ) <br>{ <br>    WNDCLASSwc; <br>    MSG         msg; <br> <br>    wc.style = CS_HREDRAW | CS_VREDRAW; <br>    wc.lpfnWndProc = WindowProc; <br>    wc.cbClsExtra = 0; <br>    wc.cbWndExtra = 0; <br>    wc.hInstance = thd-&gt;hInstance; <br>    wc.hIcon = LoadIcon( thd-&gt;hInstance, IDI_APPLICATION ); <br>    wc.hCursor = LoadCursor( NULL, IDC_ARROW ); <br>    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); <br>    wc.lpszMenuName = NULL; // MAKEINTRESOURCE(IDR_MENU); <br>    wc.lpszClassName = NAME; <br>    RegisterClass( &amp;wc ); <br> <br> <br>    /* <br>     * create the direct draw objects <br>     */ <br> <br> <br>    hwnd2 = CreateWindowEx( <br>0, <br>NAME, <br>TITLE, <br>        WS_POPUP | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME, <br>CW_USEDEFAULT, <br>CW_USEDEFAULT, <br>128, <br>128, <br>NULL, <br>NULL, <br>thd-&gt;hInstance, <br>NULL ); <br> <br>    if( !hwnd2 ) <br>    { <br>return FALSE; <br>    } <br> <br>    PostMessage(hwnd2, WM_COMMAND, ID_SIZE_3X3, 0); <br> <br>    ShowWindow( hwnd2, thd-&gt;nCmdShow ); <br>    UpdateWindow( hwnd2 ); <br> <br>    /* <br>     * create the direct draw objects <br>     */ <br>    ddInit1(hwnd2); <br> <br>    // Wait for both window to get ready <br>    SpinLock ++; <br>while(SpinLock &lt;2); <br> <br>    while( 1 ) <br>    { <br>if( PeekMessage( &amp;msg, NULL, 0, 0, PM_NOREMOVE ) ) <br>{ <br>    if( !GetMessage( &amp;msg, NULL, 0, 0 ) ) <br>return msg.wParam; <br>    TranslateMessage(&amp;msg);  <br>    DispatchMessage(&amp;msg); <br>} <br>        else <br>{ <br>    updateFrame1(); <br>} <br>    } <br> <br>} /* doInit */ <br> <br>/* <br> * WinMain - initialization, message loop <br> */ <br>int PASCAL WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, <br>LPSTR lpCmdLine, int nCmdShow) <br>{ <br>//    MSG         msg; <br>    HANDLE ThdHnd[2]; <br> <br>    ddInitArtWork(); <br> <br>    ThdInfo.hInstance = hInstance; <br>    ThdInfo.nCmdShow = nCmdShow; <br> <br>    ThdHnd[0] = CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)doInit,&amp;ThdInfo,0,&amp;ThdId1); <br>    ThdHnd[1] = CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)doInit1,&amp;ThdInfo,0,&amp;ThdId2); <br> <br>    WaitForMultipleObjects((DWORD)2,ThdHnd,TRUE,(DWORD)-1); <br>    if( lpDDSArtWork != NULL ) <br>    { <br>        lpDDSArtWork-&gt;Release(); <br>        lpDDSArtWork = NULL; <br>    } <br>    if( lpDDSArtWorkOriginal != NULL ) <br>    { <br>        lpDDSArtWorkOriginal-&gt;Release(); <br>        lpDDSArtWorkOriginal = NULL; <br>    } <br>    if( lpDDPal != NULL ) <br>    { <br>        lpDDPal-&gt;Release(); <br>        lpDDPal = NULL; <br>    } <br>    if( lpDDArtWork != NULL ) <br>    { <br>        lpDDArtWork-&gt;Release(); <br>        lpDDArtWork = NULL; <br>    } <br>   // ExitThread(0); <br>    return TRUE; <br>} /* WinMain */ <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
