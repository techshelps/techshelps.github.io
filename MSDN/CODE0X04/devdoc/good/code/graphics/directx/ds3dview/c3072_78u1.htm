<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>RLDS3D.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3079"></a>RLDS3D.CPP</h2>
<pre><code>/************************************************************************************************************ <br> <br>  Direct3DRM and DirectSound3D interface designed for the Viewer Sample Application <br> <br>  (c) 1996 Microsoft Corporation <br> <br>************************************************************************************************************/ <br> <br> <br>#include "rlds3d.h" <br>#include "ds3dvi.h"     // "Internal" include stuff, like some structures <br> <br>// For resource symbols <br>#include "resource.h" <br> <br>#include "d3drmwin.h" <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;malloc.h&gt; <br>#include &lt;math.h&gt; <br>#include &lt;direct.h&gt; <br> <br>#include &lt;objbase.h&gt; <br>#include &lt;initguid.h&gt; <br> <br>#include "rodcone.h" <br>#include "file.h" <br> <br>#include &lt;mmsystem.h&gt; <br>#include "dsound.h" <br>#include "dsutil3d.h" <br> <br> <br>/* <br>** This is an interface between the viewer and the RL/DS3D APIs which provides the <br>**   functionality required by the viewer in simplified form. <br>** <br>** Note: This is not an object-oriented API since there should only be need for one <br>**   copy at a time and this way C++ to C conversions should be fairly easy <br>** <br>** DESCRIPTION: The user interfaces the 3D world and objects therein by selecting an item <br>**   with the mouse (on the screen) and performing operations on that item.  The user will <br>**   also be able to perform operations on the camera and a few global operations applied <br>**   to all objects. <br>** <br>** USAGE: Create the interface using RLDS3D_Initialize() (returns FALSE if not created) <br>**   and remove it using RLDS3D_Deinitialize().  The Render() functionality draws the world <br>**   on the screen.  Other functionality as described. <br>*/ <br> <br>/* <br>***********************************  GLOBALS  ************************************* <br>*/ <br> <br>/* <br>** VIEWER LPDIRECT3DRMFRAME APPDATA STRUCTURE <br>** <br>** Pointers to this class are placed (as necessary) in the appdata fields for LPDIRECT3DRMFRAMEs.  Any <br>**   necessary data to be attached to frames should be added to this class <br>*/ <br> <br>class FRAMEAPPDATA { <br>public: <br>        // Sound buffer interfaces (the standard one and the 3D interface) <br>        LPDIRECTSOUNDBUFFER Sound; <br>        LPDIRECTSOUND3DBUFFER i3DSound; <br> <br>        // Whether or not this frame is currently in orbit (and thus contained in a temporary frame) <br>        BOOL bOrbiting; <br>        // Whether or not this frame is a bullet (and thus has a bullet callback and dialog) <br>        BOOL bBullet; <br>        // A window handle associated with the orbiting/bullet state which controls speed, etc. <br>        HWND hDlg; <br> <br>        FRAMEAPPDATA() : Sound(NULL), i3DSound(NULL), bOrbiting(FALSE), bBullet(FALSE), hDlg(0) {}; <br>        ~FRAMEAPPDATA() {  <br>                if (i3DSound) i3DSound-&gt;Release(); <br>                if (Sound) Sound-&gt;Release();  <br>        }; <br>}; <br>typedef FRAMEAPPDATA* LPFRAMEAPPDATA; <br> <br>// Interface to the D3DRM functions <br>LPDIRECT3DRM lpD3DRM = NULL; <br> <br>// Pointer to the Directsound API <br>LPDIRECTSOUND lpDS = NULL; <br> <br>// Clipper for the DDraw surface <br>LPDIRECTDRAWCLIPPER lpDDClipper = NULL; <br> <br>// Handle to the API's parent window (passed in Initialize) <br>HWND    hwndParent; <br> <br>// Handle to our instance <br>HINSTANCE hinst; <br> <br>AppInfo* info; <br> <br>/* <br>** Globals used for editing what is in the D3DRM world <br>*/ <br> <br>// Selected frame (contains visual currently selected by user) <br>LPDIRECT3DRMFRAME sFrame = NULL; <br> <br>// Whether or not editing box should be shown around the selected object <br>BOOL showBoxes = FALSE; <br> <br>// Currently selected visual (if one is selected) <br>static LPDIRECT3DRMMESHBUILDER sVisual = NULL; <br> <br>// Currently selected light (if one is selected) <br>static LPDIRECT3DRMLIGHT sLight = NULL; <br> <br>// Box/Speaker cone to go around the selected item (if boxes are on and if there IS a speaker) <br>static LPDIRECT3DRMMESH selectionBox = NULL; <br>static LPDIRECT3DRMMESH selectionSpeaker = NULL; <br> <br>// Clipboard frame and visual allowing cutting and pasting <br>LPDIRECT3DRMFRAME clipboardFrame = NULL; <br>LPDIRECT3DRMVISUAL clipboardVisual = NULL; <br> <br>/* <br>** Globals for DirectSound3D <br>*/ <br> <br>// Listener information (connected to the camera) <br>LPDIRECTSOUND3DLISTENER lp3DListenerInfo; <br> <br>// Primary Buffer (we don't REALLY need a pointer to it but we keep it just in case) <br>LPDIRECTSOUNDBUFFER lpDSBuff; <br> <br>/* <br>************************  Internal function declarations  **************************** <br>*/ <br> <br>// These are not part of the interface and are just used by the RLDS3D functions <br>static BOOL CreateDevice(HWND win, AppInfo* info); <br>HRESULT __cdecl loadTextures(char *name, void *arg, LPDIRECT3DRMTEXTURE *tex); <br>char* LSTRRCHR( const char* lpString, int bChar ); <br>static void PlaceMesh(LPDIRECT3DRMMESHBUILDER mesh, AppInfo *info); <br>static BOOL CreateScene(AppInfo* info); <br>static BOOL RebuildDevice(HWND win, AppInfo* info, int width, int height); <br>static LPDIRECT3DRMMESHBUILDER makeBox(D3DRMBOX*); <br>void SelectVisual(LPDIRECT3DRMMESHBUILDER visual, LPDIRECT3DRMFRAME frame); <br>int ChooseNewColor(HWND, D3DCOLOR*); <br>void RemoveSoundRecord(LPDIRECT3DRMFRAME owner); <br>void releaseSoundCallback(LPDIRECT3DRMFRAME frame); <br>void StopOrbiting(LPDIRECT3DRMFRAME stopme); <br>void UpdateConeVisual(void); <br> <br>/* <br>***********************  Error checker functions  ************************************ <br>*/ <br> <br>/* <br>** These are wrapped around DS or D3DRM calls to appropriately catch errors and handle them. <br>** <br>** The generalized cases are coded, callers can pass forced reactions to errors by using the force_critical variables <br>*/ <br> <br>/* <br>** In this code the general philosophy for when to use the viewer is when requesting anything from something outside the <br>**   program.  Thus, asking a frame which we know exists to accept an added visual doesn't get checked, but trying to create <br>**   a new frame (which tries to allocate memory) is checked in case we've run out of free memory. <br>*/ <br> <br>BOOL D3DRM_SUCCEED(HRESULT result, int force_critical, char* info) { <br>        if (result == D3DRM_OK) return TRUE; <br>        // Could be 0 for non-critical, 1 for non-critical but reports it, or 2 for critical (notify and quit) <br>        int priority = 0; <br>        char* error_string; <br>        switch (result) { <br>                case D3DRMERR_BADALLOC:                 error_string = "Out of memory";                                                         priority = 2; break; <br>                case D3DRMERR_BADDEVICE:                error_string = "Device is not compatible with renderer";        priority = 2; break; <br>                case D3DRMERR_BADFILE:                  error_string = "Data file is corrupt";                                          priority = 2; break; <br>                case D3DRMERR_BADMAJORVERSION:  error_string = "Bad DLL major version";                                         priority = 2; break; <br>                case D3DRMERR_BADMINORVERSION:  error_string = "Bad DLL minor version";                                         priority = 2; break; <br>                case D3DRMERR_BADOBJECT:                error_string = "Object expected in argument";                           priority = 2; break; <br>                case D3DRMERR_BADTYPE:                  error_string = "Bad argument type passed";                                      priority = 1; break; <br>                case D3DRMERR_BADVALUE:                 error_string = "Bad argument value passed";                                     priority = 1; break; <br>                case D3DRMERR_FACEUSED:                 error_string = "Face already used in a mesh";                           priority = 1; break; <br>                case D3DRMERR_FILENOTFOUND:             error_string = "File cannot be opened";                                         priority = 1; break; <br>                case D3DRMERR_NOTDONEYET:               error_string = "Unimplemented function called";                         priority = 1; break; <br>                case D3DRMERR_NOTFOUND:                 error_string = "Object not found in specified place";           priority = 1; break; <br>                case D3DRMERR_UNABLETOEXECUTE:  error_string = "Unable to carry out procedure";                         priority = 2; break; <br>                default:                                                error_string = "D3DRM Error: Unable to continue";                       priority = 2; break; <br>        } <br> <br>        int ret; <br>        if (force_critical &gt;= 0) priority = force_critical; <br>        if (priority == 1) { <br>            ret = MessageBox(hwndParent, error_string, "D3DRM Warning", MB_APPLMODAL|MB_ICONWARNING|MB_OK); <br>        } <br>        else if (priority == 2) { <br>            ret = MessageBox(hwndParent, error_string, "D3DRM Fatal Error", MB_APPLMODAL|MB_ICONSTOP|MB_OK); <br>                PostMessage(hwndParent, WM_CLOSE,0,0); <br>        } <br>        return FALSE; <br>} <br> <br>/* <br>** DS isn't vital for the viewer to run so error messages don't force a quit <br>*/ <br> <br>BOOL DS3D_SUCCEED(HRESULT result, int force_critical, char* info) { <br>        if (result == DS_OK) return TRUE; <br>        // Could be 0 for no message, 1 for non-critical (simply needs to report it), or 2 for critical (notify and quit) <br>        int priority = 0; <br>        char* error_string = NULL; <br>        switch (result) { <br>                case DSERR_ALLOCATED:                   error_string = "Requested resources already in use";                    priority = 1; break; <br>                case DSERR_ALREADYINITIALIZED:  error_string = "Object already initialized";                                    priority = 0; break; <br>                case DSERR_BADFORMAT:                   error_string = "Wave format not supported";                                             priority = 0; break; <br>                case DSERR_BUFFERLOST:                  error_string = "Buffer lost and must be restored";                              priority = 0; break; <br>                case DSERR_CONTROLUNAVAIL:              error_string = "Control requested not available";                               priority = 0; break; <br>                case DSERR_GENERIC:                             error_string = "Undetermined error";                                                    priority = 1; break; <br>                case DSERR_INVALIDCALL:                 error_string = "Invalid call for object's current state";               priority = 0; break; <br>                case DSERR_INVALIDPARAM:                error_string = "Invalid parameters passed to object";                   priority = 0; break; <br>                case DSERR_NOAGGREGATION:               error_string = "Object does not support aggregation";                   priority = 1; break; <br>                case DSERR_NODRIVER:                    error_string = "No sound driver available";                                             priority = 1; break; <br>//              case DSERR_NOINTERFACE:                 error_string = "Requested COM interface not available";                 priority = 0; break; <br>                case DSERR_OUTOFMEMORY:                 error_string = "Out of memory";                                                                 priority = 1; break; <br>                case DSERR_PRIOLEVELNEEDED:             error_string = "Caller does not have required priority level";  priority = 0; break; <br>//              case DSERR_UNINITIALIZED:               error_string = "DirectSound not initialized";                                   priority = 1; break; <br>                case DSERR_UNSUPPORTED:                 error_string = "Unsupported function called";                                   priority = 0; break; <br>                default:                                                error_string = "Undetermined error";                                                    priority = 1; break; <br>        } <br> <br>        int ret; <br>        if (force_critical &gt;= 0) priority = force_critical; <br>        if (priority == 1) { <br>            ret = MessageBox(hwndParent, error_string, "DS3D Warning", MB_APPLMODAL|MB_ICONWARNING|MB_OK); <br>        } <br>        else if (priority == 2) { <br>            ret = MessageBox(hwndParent, error_string, "DS3D Fatal Error", MB_APPLMODAL|MB_ICONSTOP|MB_OK); <br>                PostMessage(hwndParent, WM_CLOSE,0,0); <br>        } <br>        return FALSE; <br>} <br> <br> <br> <br> <br>/* <br>************************  INITIALIZATION/DEINITIALIZATION **************************** <br>*/ <br> <br>/* <br>** Initialize will attach itself to the passed window.  Call initialize after <br>**  getting a handle for your window but before you display it. <br>** <br>** Initialize will initialize the D3DRM API and return false if it fails.  It will <br>**  also attempt to initialize a DirectSound3D API, but failing this does not <br>**  justify a failed Initialize (since the 3D sound isn't a necessary part of <br>**  the viewer) <br>*/ <br> <br>BOOL RLDS3D_Initialize(HWND hwndPW, HINSTANCE this_inst) { <br> <br>        if (!hwndPW) return FALSE; <br> <br>        hinst = this_inst; <br>        hwndParent = hwndPW; <br> <br>        // D3DRM API INIT - we force non-critical warnings here because the initialization returns a boolean for success <br>         <br>        // Call Direct3DRMCreate to try to make a D3DRM object <br>        if (!D3DRM_SUCCEED(Direct3DRMCreate(&amp;lpD3DRM), 1)) return FALSE; <br> <br> <br>if (!D3DRM_SUCCEED(DirectDrawCreateClipper(0, &amp;lpDDClipper, NULL),1)) { <br>lpD3DRM-&gt;Release(); <br>return FALSE; <br>} <br>     <br>        if (!D3DRM_SUCCEED(lpDDClipper-&gt;SetHWnd(0, hwndParent),1)) { <br>                lpDDClipper-&gt;Release(); <br>                lpD3DRM-&gt;Release(); <br>        return FALSE; <br>    } <br> <br> <br>    // Set up D3DRM information structure <br>    info = (AppInfo*) malloc(sizeof(AppInfo)); <br>        if (!info) { <br>                lpDDClipper-&gt;Release(); <br>                lpD3DRM-&gt;Release(); <br>                return FALSE; <br>        } <br> <br>    info-&gt;model = D3DCOLOR_MONO; <br> <br>    // Calls our internal function to create a viewport and device and attach it to the window (CreateDevice in misc. functionality) <br>        // (also fills in the global information structure "info" for what D3DRM can do and is currently doing) <br>        if (CreateDevice(hwndParent, info) == FALSE) { <br>                lpDDClipper-&gt;Release(); <br>                lpD3DRM-&gt;Release(); <br>                return FALSE; <br>        } <br>         <br>        // DIRECTSOUND 3D INIT - note, if this fails the entire initialization is still OK. <br> <br>        // Description for our primary buffer creation <br>        DSBUFFERDESC dsbd; <br> <br>    int ret = IDRETRY; <br> <br>        // Try to create the Directsound objects until we either do it, are told to ignore it, or are told to abort <br>        while (ret == IDRETRY) { <br>                // Create the directsound object <br>                if (DS3D_SUCCEED(DirectSoundCreate(NULL, &amp;lpDS, NULL))) { <br>                        // Set cooperative level <br>                        if (DS3D_SUCCEED(lpDS-&gt;SetCooperativeLevel(hwndParent, DSSCL_PRIORITY))) { <br>                                // Create a primary buffer so we can query for a 3D Listener interface <br>                                memset(&amp;dsbd, 0, sizeof(DSBUFFERDESC)); <br>                                dsbd.dwSize = sizeof(DSBUFFERDESC); <br>                                dsbd.dwFlags = DSBCAPS_PRIMARYBUFFER | DSBCAPS_CTRL3D; <br>                                if (DS3D_SUCCEED(lpDS-&gt;CreateSoundBuffer(&amp;dsbd, &amp;lpDSBuff, NULL))) { <br>                                         <br>                                        // Make the primary 44.1 KHz so that it sounds better <br>                                        WAVEFORMATEX wfx; <br>                                        wfx.wFormatTag = WAVE_FORMAT_PCM; <br>                                        wfx.nChannels = 2; <br>                                        wfx.nSamplesPerSec = 44100; <br>                                        wfx.nAvgBytesPerSec = 44100*2*2; <br>                                        wfx.nBlockAlign = 4; <br>                                        wfx.wBitsPerSample = 16; <br>                                        wfx.cbSize = 0; <br>                                        lpDSBuff-&gt;SetFormat(&amp;wfx); <br> <br>                                        // Get the 3D listener information (error currently ignored) <br>                                        if (DS3D_SUCCEED(lpDSBuff-&gt;QueryInterface(IID_IDirectSound3DListener, (void**) &amp;lp3DListenerInfo))) { <br>                                                lp3DListenerInfo-&gt;SetDopplerFactor(D3DVAL(100.0), DS3D_IMMEDIATE); <br>                                        } <br>                                        else { <br>                                                // Failed to get listener info <br>                                                lpDSBuff-&gt;Release(); <br>                                                lpDS-&gt;Release(); <br>                                                lpDS = NULL; <br>                                        } <br>                                } <br>                                else { <br>                                        // Failed to create a primary buffer <br>                                        lpDS-&gt;Release(); <br>                                        lpDS = NULL; <br>                                } <br>                        } <br>                        else { <br>                                // Failed to set cooperative level <br>                                lpDS-&gt;Release(); <br>                                lpDS = NULL; <br>                        } <br>                } <br> <br>                // Warn that we could create the DirectSound object <br>                if (!lpDS) { <br>                        ret = MessageBox(hwndParent, "DirectSound 3D could not initialize", "Warning", MB_APPLMODAL|MB_ICONWARNING|MB_ABORTRETRYIGNORE); <br>                        if (ret == IDABORT) { <br>                                lpDDClipper-&gt;Release(); <br>                                lpD3DRM-&gt;Release(); <br>                                return FALSE; <br>    } <br>                } <br>                else ret = IDOK; <br>        } <br>        return TRUE; <br>} <br> <br>/* <br>** Deinitializes <br>*/ <br> <br>void RLDS3D_Deinitialize() { <br>        // Releases the DSound interface... this is very important! <br>        if (lpDS != NULL) { <br>                lpDSBuff-&gt;Release(); <br>                lpDS-&gt;Release(); <br>        } <br>        info-&gt;dev-&gt;Release(); <br>        lpDDClipper-&gt;Release(); <br>        lpD3DRM-&gt;Release(); <br>        free(info); <br>} <br> <br>/* <br>********************************************  ADDING/REMOVING/EDITING OBJECTS  ********************************* <br>*/ <br> <br>/* <br>** Loads XOF file into the RL world (with textures) <br>*/ <br> <br>void RLDS3D_LoadXOF(char* file) { <br>    if (!file) return; <br>LPDIRECT3DRMMESHBUILDER builder = NULL; <br>if (D3DRM_SUCCEED(lpD3DRM-&gt;CreateMeshBuilder(&amp;builder))) { <br>if (builder-&gt;Load(file, NULL, D3DRMLOAD_FROMFILE, loadTextures, NULL) != D3DRM_OK) { <br>            MessageBox(hwndParent, "Unable to load file", "D3DRM Fatal Error", MB_APPLMODAL|MB_ICONEXCLAMATION|MB_OK); <br>builder-&gt;Release(); <br>return; <br>} <br>PlaceMesh(builder, info); <br>builder-&gt;Release(); <br>} <br>} <br> <br>/* <br>** Sets/Gets whether or not boxes are shown around selected item <br>*/ <br> <br>BOOL RLDS3D_GetBoxes(void) { <br>        return showBoxes; <br>} <br> <br>void RLDS3D_SetBoxes(BOOL new_val) { <br>        showBoxes = new_val; <br>        // Re-selects the currently selected visual so that the box is generated/destroyed around it <br>        RLDS3D_UpdateSelectionBox(); <br>} <br> <br>/* <br>** Updates the bounding box around the selected visual (this could be done using a render callback function to compare the <br>**   frame's scaling and transform functions instead) <br>*/ <br> <br>void RLDS3D_UpdateSelectionBox(void) { <br>        // When we select this visual, we destroy any existing box and create a new one around it if showBoxes is true. <br>        SelectVisual(sVisual, sFrame); <br>} <br> <br>/* <br>** Deselects the currently selected 3D visual. <br>*/ <br> <br>void RLDS3D_DeselectVisual() <br>{ <br>        // Removes the bounding box from around it if it's there <br>    if (sFrame &amp;&amp; selectionBox) { <br>        sFrame-&gt;DeleteVisual(selectionBox); <br>        sFrame-&gt;DeleteVisual(selectionSpeaker); <br>    } <br>                 <br>         <br>    sFrame = NULL; <br>    sLight = NULL; <br>    sVisual = NULL; <br>    selectionBox = NULL; <br>    selectionSpeaker = NULL; <br>} <br> <br>/* <br>** Given coordinates it selects the first visual under those coordinates in the window's viewport <br>*/ <br> <br>void RLDS3D_FindAndSelectVisual(int x, int y, LPBOOL changed) { <br>    LPDIRECT3DRMVISUAL visual; <br>    LPDIRECT3DRMFRAME frame; <br>    LPDIRECT3DRMPICKEDARRAY picked; <br>    LPDIRECT3DRMFRAMEARRAY frames; <br>    LPDIRECT3DRMMESHBUILDER mesh; <br>    LPDIRECT3DRMVIEWPORT view = info-&gt;view; <br> <br>LPDIRECT3DRMFRAME oldframe = sFrame; <br> <br>    /* <br>     * Make sure we don't try to select the selection box of the current <br>     * selection. <br>     */ <br>    RLDS3D_DeselectVisual(); <br> <br>    view-&gt;Pick(x, y, &amp;picked); <br>    if (picked) <br>    {   if (picked-&gt;GetSize()) <br>        { <br>// Get the top-level visual <br>            picked-&gt;GetPick(0, &amp;visual, &amp;frames, 0); <br>            // The frames that contain the visual are placed into a framearray in heiarchical order, take the <br>            //   last one (the one most closely associated with the visual) <br>            frames-&gt;GetElement(frames-&gt;GetSize() - 1, &amp;frame); <br>            // We can only select meshes so we query the visual to make sure it is one <br>            if (D3DRM_SUCCEED(visual-&gt;QueryInterface(IID_IDirect3DRMMeshBuilder, (void **) &amp;mesh), 0)) <br>            {    <br>                // If we're clicking on an orbiting frame then we need to stop it. <br>                StopOrbiting(frame); <br>                SelectVisual(mesh, frame); <br>                mesh-&gt;Release(); <br>            } <br>            frame-&gt;Release(); <br>            frames-&gt;Release(); <br>            visual-&gt;Release(); <br>        } <br>        picked-&gt;Release(); <br>    } <br>if (changed) { <br>if (sFrame == oldframe) *changed = FALSE; else *changed = TRUE; <br>} <br>} <br> <br>/* <br>** Cuts the current selection to the clipboard <br>*/ <br> <br>void RLDS3D_CutVisual() <br>{ <br>    LPDIRECT3DRMFRAME frame; <br> <br>    if (clipboardFrame) <br>    clipboardFrame-&gt;Release(); <br> <br>    if (sFrame) <br>    {   clipboardFrame = sFrame; <br>        clipboardVisual = sVisual; <br>                 <br>        // If a 3D sound is attached, remove it (sounds not carried to clipboard) <br>RemoveSoundRecord(clipboardFrame); <br>RLDS3D_DeselectVisual(); <br> <br>        clipboardFrame-&gt;AddRef(); <br>        clipboardFrame-&gt;GetParent(&amp;frame); <br>        if (frame) { <br>            frame-&gt;DeleteChild(clipboardFrame); <br>            frame-&gt;Release(); <br>        } <br>    } <br>} <br> <br>/* <br>** Copies the current selection to the clipboard <br>*/ <br> <br>void RLDS3D_CopyVisual() <br>{ <br>    LPDIRECT3DRMFRAME frame; <br> <br>    if (sFrame) <br>    { <br>                // Things could really foul up if the clones aren't created so we make sure they are <br>        if (!D3DRM_SUCCEED(sFrame-&gt;Clone(0, IID_IDirect3DRMFrame, (void **) &amp;clipboardFrame))) { <br>                        // If we've failed, we must make sure the clipboard is empty! <br>                        clipboardVisual-&gt;Release(); <br>                        clipboardVisual = NULL; <br>                        return; <br>                } <br> <br>        if (!D3DRM_SUCCEED(sVisual-&gt;Clone(0, IID_IDirect3DRMVisual, (void **) &amp;clipboardVisual))) { <br>                        // If we've failed, we must make sure the clipboard is empty! <br>                        clipboardFrame-&gt;Release(); <br>                        clipboardFrame = NULL; <br>                        return; <br>                } <br> <br>                // If a 3D sound is attached, remove it (sounds not carried to clipboard) <br>                RemoveSoundRecord(clipboardFrame); <br> <br>        clipboardFrame-&gt;AddVisual(clipboardVisual); <br>                clipboardVisual-&gt;Release(); <br> <br>        clipboardFrame-&gt;GetParent(&amp;frame); <br>        if (frame) { <br>                        frame-&gt;DeleteChild(clipboardFrame); <br>                        frame-&gt;Release(); <br>                } <br>    } <br>} <br> <br>/* <br>** Pastes the current selection to the window <br>*/ <br> <br>void RLDS3D_PasteVisual() <br>{ <br>    if (clipboardFrame) <br>    { <br>        LPDIRECT3DRMFRAME frame; <br>        LPDIRECT3DRMVISUAL visual; <br> <br>        if (!D3DRM_SUCCEED(clipboardFrame-&gt;Clone(0, IID_IDirect3DRMFrame, (void **) &amp;frame))) return; <br>        if (!D3DRM_SUCCEED(clipboardVisual-&gt;Clone(0, IID_IDirect3DRMVisual, (void **) &amp;visual))) { <br>                        frame-&gt;Release(); <br>                        return; <br>                } <br> <br>        frame-&gt;AddVisual(visual); <br>        info-&gt;scene-&gt;AddChild(frame); <br>                visual-&gt;Release(); <br>                frame-&gt;Release(); <br>    } <br>} <br> <br>/* <br>** Deletes the current selection from the world without copying to the clipboard <br>*/ <br> <br>void RLDS3D_DeleteVisual() <br>{ <br>    if (sFrame) { <br>        LPDIRECT3DRMFRAME parent, frame; <br>        // Make a copy of the selected frame ('cause deselecting it will make it inaccessible) <br>        frame = sFrame; <br>        // If a 3D sound is attached, remove it <br>        RemoveSoundRecord(frame); <br> <br>        // Deselect the frame (removes bounding box, etc, also sets sFrame to NULL) <br>        RLDS3D_DeselectVisual();         <br>        if (frame-&gt;GetAppData()) delete (FRAMEAPPDATA*)frame-&gt;GetAppData(); <br>frame-&gt;GetParent(&amp;parent); <br>        if (parent) { <br>                parent-&gt;DeleteChild(frame); <br>                parent-&gt;Release(); <br>        } <br>    } <br>} <br> <br>/* <br>** Add a directional light <br>*/ <br> <br>void RLDS3D_AddDirectionalLight() { <br>    LPDIRECT3DRMMESHBUILDER builder; <br>    LPDIRECT3DRMLIGHT light; <br>    LPDIRECT3DRMFRAME frame; <br> <br>    if (D3DRM_SUCCEED(lpD3DRM-&gt;CreateMeshBuilder(&amp;builder))) { <br>                if (D3DRM_SUCCEED(builder-&gt;Load("camera.x", NULL, D3DRMLOAD_FROMFILE, NULL, NULL))) { <br>                        builder-&gt;SetQuality(D3DRMRENDER_UNLITFLAT); <br>                        if (D3DRM_SUCCEED(lpD3DRM-&gt;CreateLightRGB(D3DRMLIGHT_DIRECTIONAL, D3DVAL(1.0), D3DVAL(1.0), D3DVAL(1.0), &amp;light))) { <br>                                if (D3DRM_SUCCEED(lpD3DRM-&gt;CreateFrame(info-&gt;scene, &amp;frame))) { <br>                                        frame-&gt;SetPosition(info-&gt;camera, D3DVAL(0.0), D3DVAL(0.0), D3DVAL(10.0)); <br>                                        frame-&gt;AddVisual(builder); <br>                                        frame-&gt;AddLight(light); <br>                                        frame-&gt;Release(); <br>                                } <br>                                light-&gt;Release(); <br>                        } <br>                } <br>                builder-&gt;Release(); <br>        } <br>} <br> <br>/* <br>** Add a parallel point light <br>*/ <br> <br>void RLDS3D_AddParallelPointLight() { <br>    LPDIRECT3DRMMESHBUILDER builder; <br>    LPDIRECT3DRMLIGHT light; <br>    LPDIRECT3DRMFRAME frame; <br> <br>    if (D3DRM_SUCCEED(lpD3DRM-&gt;CreateMeshBuilder(&amp;builder))) { <br>            if (D3DRM_SUCCEED(builder-&gt;Load("sphere2.x", NULL, D3DRMLOAD_FROMFILE, NULL, NULL))) { <br>                        builder-&gt;SetQuality(D3DRMRENDER_UNLITFLAT); <br>                        builder-&gt;Scale(D3DVAL(0.2), D3DVAL(0.2), D3DVAL(0.2)); <br>                        if (D3DRM_SUCCEED(lpD3DRM-&gt;CreateLightRGB(D3DRMLIGHT_PARALLELPOINT, D3DVAL(1.0), D3DVAL(1.0), D3DVAL(1.0), &amp;light))) { <br>                                if (D3DRM_SUCCEED(lpD3DRM-&gt;CreateFrame(info-&gt;scene, &amp;frame))) { <br>                                        frame-&gt;SetPosition(info-&gt;camera, D3DVAL(0.0), D3DVAL(0.0), D3DVAL(10.0)); <br>                                        frame-&gt;AddVisual(builder); <br>                                        frame-&gt;AddLight(light); <br>                                        frame-&gt;Release(); <br>                                } <br>                                light-&gt;Release(); <br>                        } <br>                } <br>                builder-&gt;Release(); <br>        } <br>} <br> <br>/* <br>** Add Point Light <br>*/ <br> <br>void RLDS3D_AddPointLight() { <br>    LPDIRECT3DRMMESHBUILDER builder; <br>    LPDIRECT3DRMLIGHT light; <br>    LPDIRECT3DRMFRAME frame; <br> <br>    if (D3DRM_SUCCEED(lpD3DRM-&gt;CreateMeshBuilder(&amp;builder))) { <br>                if (D3DRM_SUCCEED(builder-&gt;Load("sphere2.x", NULL, D3DRMLOAD_FROMFILE, NULL, NULL))) { <br>                        builder-&gt;SetQuality(D3DRMRENDER_UNLITFLAT); <br>                        builder-&gt;Scale(D3DVAL(0.2), D3DVAL(0.2), D3DVAL(0.2)); <br>                        if (D3DRM_SUCCEED(lpD3DRM-&gt;CreateLightRGB(D3DRMLIGHT_POINT, D3DVAL(1.0), D3DVAL(1.0), D3DVAL(1.0), &amp;light))) { <br>                                if (D3DRM_SUCCEED(lpD3DRM-&gt;CreateFrame(info-&gt;scene, &amp;frame))) { <br>                                        frame-&gt;SetPosition(info-&gt;camera, D3DVAL(0.0), D3DVAL(0.0), D3DVAL(10.0)); <br>                                        frame-&gt;AddVisual(builder); <br>                                        frame-&gt;AddLight(light); <br>                                        frame-&gt;Release(); <br>                                } <br>                                light-&gt;Release(); <br>                        } <br>                } <br>                builder-&gt;Release(); <br>        } <br>} <br> <br>/* <br>** Add a spotlight <br>*/ <br> <br>void RLDS3D_AddSpotlight() { <br>    LPDIRECT3DRMMESHBUILDER builder; <br>    LPDIRECT3DRMLIGHT light; <br>    LPDIRECT3DRMFRAME frame; <br> <br>        if (D3DRM_SUCCEED(lpD3DRM-&gt;CreateMeshBuilder(&amp;builder))) { <br>            if (D3DRM_SUCCEED(builder-&gt;Load("camera.x", NULL, D3DRMLOAD_FROMFILE, NULL, NULL))) { <br>                        builder-&gt;SetQuality(D3DRMRENDER_UNLITFLAT); <br>                        if (D3DRM_SUCCEED(lpD3DRM-&gt;CreateLightRGB(D3DRMLIGHT_SPOT, D3DVAL(1.0), D3DVAL(1.0), D3DVAL(1.0), &amp;light))) { <br>                                if (D3DRM_SUCCEED(lpD3DRM-&gt;CreateFrame(info-&gt;scene, &amp;frame))) { <br>                                        frame-&gt;SetPosition(info-&gt;camera, D3DVAL(0.0), D3DVAL(0.0), D3DVAL(10.0)); <br>                                        frame-&gt;AddVisual(builder); <br>                                        frame-&gt;AddLight(light); <br>                                        frame-&gt;Release(); <br>                                } </code></pre>
<p>
</p>
<pre><code>light-&gt;Release(); <br>                        } <br>                } <br>                builder-&gt;Release(); <br>        } <br>} <br> <br> <br>/* <br>***********************************  OBJECT MOTION/SCALING/COLORING  **************************************** <br>*/ <br> <br>/* <br>** Chooses a new color and sets the selected object to it... handles the selection of the color, etc. <br>*/ <br> <br>void RLDS3D_SetSelColour(void) { <br>    if (!sFrame) return; <br>    LPDIRECT3DRMMESHBUILDER mesh; <br> <br>    if (!D3DRM_SUCCEED(sVisual-&gt;QueryInterface(IID_IDirect3DRMMeshBuilder, (void**) &amp;mesh),0)) return; <br> <br>    if (sLight) <br>    { <br>        D3DCOLOR c = sLight-&gt;GetColor(); <br> <br>        if (ChooseNewColor(hwndParent, &amp;c)) { <br>            mesh-&gt;SetColor(c); <br>            sLight-&gt;SetColor(c); <br>        } <br>    } else { <br>        D3DCOLOR c; <br> <br>        if (mesh-&gt;GetFaceCount()) { <br>            LPDIRECT3DRMFACEARRAY faces; <br>            LPDIRECT3DRMFACE face; <br>            mesh-&gt;GetFaces(&amp;faces); <br>            faces-&gt;GetElement(0, &amp;face); <br>            c = face-&gt;GetColor(); <br>            face-&gt;Release(); <br>            faces-&gt;Release(); <br>        } else <br>            c = D3DRMCreateColorRGB(D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0)); <br> <br>        if (ChooseNewColor(hwndParent, &amp;c)) <br>            mesh-&gt;SetColor(c); <br>    } <br> <br>    mesh-&gt;Release(); <br>} <br> <br> <br>/* <br>** Moves the camera relative to itself by providing scalars to multiply against the CAMERA-RELATIVE unit vectors <br>**   forwards/up/right. <br>*/ <br> <br>void RLDS3D_SetCamVelRelToCam(D3DVALUE forward, D3DVALUE up, D3DVALUE right) { <br>        D3DVECTOR vDir, vUp, vRight; <br>        info-&gt;camera-&gt;GetOrientation(info-&gt;scene, &amp;vDir, &amp;vUp); <br>        // Cross the UP vector and the RIGHT vector to get the FORWARDS vector <br>        D3DRMVectorCrossProduct(&amp;vRight, &amp;vUp, &amp;vDir); <br>        info-&gt;camera-&gt;SetVelocity(info-&gt;scene, vDir.x*forward + vUp.x*up + vRight.x*right, <br>                                   vDir.y*forward + vUp.y*up + vRight.y*right, <br>                                   vDir.z*forward + vUp.z*up + vRight.z*right, <br>   TRUE); <br>} <br> <br>/* <br>** Rotates the camera around its three axis <br>** <br>** forward_axis is roll, up_axis is yaw, right_axis is pitch <br>*/ <br> <br>void RLDS3D_SetCamRotForward(D3DVALUE forward_axis) { <br>        info-&gt;camera-&gt;SetRotation(info-&gt;camera, 0.0f, 0.0f, 1.0f, forward_axis); <br>} <br> <br>void RLDS3D_SetCamRotUp(D3DVALUE up_axis) { <br>        info-&gt;camera-&gt;SetRotation(info-&gt;camera, 0.0f, 1.0f, 0.0f, up_axis); <br>} <br> <br>void RLDS3D_SetCamRotRight(D3DVALUE right_axis) { <br>        info-&gt;camera-&gt;SetRotation(info-&gt;camera, 1.0f, 0.0f, 0.0f, right_axis); <br>} <br> <br>/* <br>** Scales the currently selected object by the scale factors... <br>*/ <br> <br>void RLDS3D_ScaleSelected(D3DVALUE sx, D3DVALUE sy, D3DVALUE sz) { <br>        if (!sFrame) return; <br>        if (!sVisual) return; <br>        RLDS3D_StopOrbitSelected(); <br>        sVisual-&gt;Scale(sx, sy, sz); <br>        RLDS3D_UpdateSelectionBox(); <br>} <br> <br>/* <br>** Moves the currently selected object in the 3D world relative to the camera <br>*/ <br> <br>void RLDS3D_SetSelectedVelRelToCam(D3DVALUE forward, D3DVALUE up, D3DVALUE right) { <br>        if (!sFrame) return; <br>        RLDS3D_StopOrbitSelected(); <br>        D3DVECTOR vDir, vUp, vRight; <br>        info-&gt;camera-&gt;GetOrientation(info-&gt;scene, &amp;vDir, &amp;vUp); <br>        D3DRMVectorCrossProduct(&amp;vRight, &amp;vUp, &amp;vDir); <br>        sFrame-&gt;SetVelocity(info-&gt;scene, vDir.x*forward + vUp.x*up + vRight.x*right, <br>   vDir.y*forward + vUp.y*up + vRight.y*right, <br>   vDir.z*forward + vUp.z*up + vRight.z*right, <br>   TRUE); <br>}        <br> <br>/* <br>** Rotates the currently selected object relative to the camera's frame when passed <br>**   a vector for the axis and an angle of rotation. <br>** This is useful because the AXIS which is specified is relative to what appears on the screen with it's origin at the camera <br>**   (ie: (0,0,1) will be an axis straight into the screen and thus things will spin around the centre of the screen) <br>*/ <br> <br>void RLDS3D_SetSelectedRotRelToCam(D3DVALUE AxisX, D3DVALUE AxisY, D3DVALUE AxisZ, D3DVALUE angle) { <br>        if (!sFrame) return; <br>        RLDS3D_StopOrbitSelected(); <br>        sFrame-&gt;SetRotation(info-&gt;camera, AxisX, AxisY, AxisZ, angle); <br>} <br> <br>/* <br>** Moves the currently selected object by x/y pixels on the screen from it's relative position.  Allows a user <br>**   to drag objects around the screen using the mouse.  Assumes that the distance from the frame to the screen <br>**   will remain constant <br>*/ <br> <br>void RLDS3D_MoveSelectedPosByScreenCoords(double delta_x, double delta_y) { <br>        if (!sFrame) return; <br>        RLDS3D_StopOrbitSelected(); <br>        D3DVECTOR p1; <br>    D3DRMVECTOR4D p2; <br>    sFrame-&gt;GetPosition(info-&gt;scene, &amp;p1); <br>        info-&gt;view-&gt;Transform(&amp;p2, &amp;p1); <br>        // returned value is in homogenous coords so we need to multiply by w to get vector coords <br>    p2.x += D3DMultiply(D3DVAL((D3DVALUE)delta_x), p2.w); <br>    p2.y += D3DMultiply(D3DVAL((D3DVALUE)delta_y), p2.w); <br>    info-&gt;view-&gt;InverseTransform(&amp;p1, &amp;p2); <br>    sFrame-&gt;SetPosition(info-&gt;scene, p1.x, p1.y, p1.z); <br>} <br> <br>void RLDS3D_GetDistanceFactor(D3DVALUE *temp) { <br>lp3DListenerInfo-&gt;GetDistanceFactor(temp); <br>} <br> <br>void RLDS3D_GetDopplerFactor(D3DVALUE *temp) { <br>lp3DListenerInfo-&gt;GetDopplerFactor(temp); <br>} <br> <br>void RLDS3D_GetRolloffFactor(D3DVALUE *temp) { <br>lp3DListenerInfo-&gt;GetRolloffFactor(temp); <br>} <br> <br>void RLDS3D_SetDistanceFactor(D3DVALUE temp) { <br>lp3DListenerInfo-&gt;SetDistanceFactor(temp, DS3D_IMMEDIATE); <br>} <br> <br>void RLDS3D_SetDopplerFactor(D3DVALUE temp) { <br>lp3DListenerInfo-&gt;SetDopplerFactor(temp, DS3D_IMMEDIATE); <br>} <br> <br>void RLDS3D_SetRolloffFactor(D3DVALUE temp) { <br>lp3DListenerInfo-&gt;SetRolloffFactor(temp, DS3D_IMMEDIATE); <br>} <br> <br>void RLDS3D_CommitDeferredSettings(void) { <br>lp3DListenerInfo-&gt;CommitDeferredSettings(); <br>} <br> <br>BOOL RLDS3D_SoundSelected(void) { <br>if (!lpDS) return FALSE; <br>if (!sFrame) return FALSE; <br>if (!sFrame-&gt;GetAppData()) return FALSE; <br>if (!((LPFRAMEAPPDATA)(sFrame-&gt;GetAppData()))-&gt;i3DSound) return FALSE; <br>return TRUE; <br>} <br> <br>void RLDS3D_GetSelConeAngles(LPDWORD inner, LPDWORD outer) { <br>if (!RLDS3D_SoundSelected) return; <br>((LPFRAMEAPPDATA)(sFrame-&gt;GetAppData()))-&gt;i3DSound-&gt;GetConeAngles(inner, outer); <br>} <br> <br>void RLDS3D_GetSelConeOutsideVolume(LPLONG temp) { <br>if (!RLDS3D_SoundSelected) return; <br>((LPFRAMEAPPDATA)(sFrame-&gt;GetAppData()))-&gt;i3DSound-&gt;GetConeOutsideVolume(temp); <br>} <br> <br>void RLDS3D_GetSelMinimumDistance(D3DVALUE *temp) { <br>if (!RLDS3D_SoundSelected) return; <br>((LPFRAMEAPPDATA)(sFrame-&gt;GetAppData()))-&gt;i3DSound-&gt;GetMinDistance(temp); <br>} <br> <br>void RLDS3D_GetSelMaximumDistance(D3DVALUE *temp) { <br>if (!RLDS3D_SoundSelected) return; <br>((LPFRAMEAPPDATA)(sFrame-&gt;GetAppData()))-&gt;i3DSound-&gt;GetMaxDistance(temp); <br>} <br> <br>void RLDS3D_SetSelConeAngles(DWORD inner, DWORD outer) { <br>if (!RLDS3D_SoundSelected) return; <br>((LPFRAMEAPPDATA)(sFrame-&gt;GetAppData()))-&gt;i3DSound-&gt;SetConeAngles(inner, outer, DS3D_IMMEDIATE); <br>UpdateConeVisual(); <br>} <br> <br>void RLDS3D_SetSelConeOutsideVolume(LONG temp) { <br>if (!RLDS3D_SoundSelected) return; <br>((LPFRAMEAPPDATA)(sFrame-&gt;GetAppData()))-&gt;i3DSound-&gt;SetConeOutsideVolume(temp, DS3D_IMMEDIATE); <br>} <br> <br>void RLDS3D_SetSelMinimumDistance(D3DVALUE temp) { <br>if (!RLDS3D_SoundSelected) return; <br>((LPFRAMEAPPDATA)(sFrame-&gt;GetAppData()))-&gt;i3DSound-&gt;SetMinDistance(temp, DS3D_IMMEDIATE); <br>} <br> <br>void RLDS3D_SetSelMaximumDistance(D3DVALUE temp) { <br>if (!RLDS3D_SoundSelected) return; <br>((LPFRAMEAPPDATA)(sFrame-&gt;GetAppData()))-&gt;i3DSound-&gt;SetMaxDistance(temp, DS3D_IMMEDIATE); <br>} <br> <br> <br> <br> <br> <br>/* <br>** Orbit control windows have a pointer to the orbiting frame attached to them.  The frame, in return, has the handle of the window in it's <br>** frameappdata.  When the window is used (the value modified/Stop Orbit button hit) the window modifies the frame and itself appropriately. <br>** When the frame is modified (ie: Destroyed) it passes messages to the window appropriately. <br>*/ <br> <br>/* <br>** Structure to store info about an orbit <br>*/ <br> <br>struct ORBITDATA { <br>        LPDIRECT3DRMFRAME orbit_frame; <br>        LPDIRECT3DRMFRAME child_frame; <br>        D3DVECTOR axis; // Axis around which the orbit is going <br>        D3DVALUE speed; // Speed (angles per second) <br>}; <br> <br>typedef ORBITDATA* LPORBITDATA; <br> <br>/* <br>** Structure to store info about a bullet, used by both the dialog box and the callback function <br>*/ <br> <br>struct BULLETDATA { <br>        LPDIRECT3DRMFRAME bullet_frame; <br>        D3DVECTOR vStartPosition; <br>        D3DVECTOR vDirection; <br>        D3DVALUE fSpeed; <br>        D3DVALUE fTime; <br>}; <br> <br>typedef BULLETDATA* LPBULLETDATA; <br> <br>static void CDECL bulletCallback(LPDIRECT3DRMFRAME obj, void* arg, D3DVALUE delta) { <br>        LPBULLETDATA binfo = (LPBULLETDATA)arg; <br>        if (binfo-&gt;fTime &lt;= D3DVAL(0.0)) { <br>                binfo-&gt;fTime = D3DVAL(10.0); // Ten seconds, 5 for before and 5 for after. <br>                D3DVALUE mult = D3DDivide(D3DMultiply(binfo-&gt;fTime, binfo-&gt;fSpeed), D3DVAL(-2.0)); // Calculate the displacement multiplier for calculating starting position <br>                obj-&gt;SetPosition(info-&gt;scene, binfo-&gt;vStartPosition.x + D3DMultiply(mult, binfo-&gt;vDirection.x), <br>                                                  binfo-&gt;vStartPosition.y + D3DMultiply(mult, binfo-&gt;vDirection.y), <br>                                                                          binfo-&gt;vStartPosition.z + D3DMultiply(mult, binfo-&gt;vDirection.z)); <br>        } <br>        else binfo-&gt;fTime -= delta; <br>} <br> <br> <br>/* <br>** Stops the passed frame from orbiting or from bulleting <br>*/ <br> <br>void StopOrbiting(LPDIRECT3DRMFRAME stopme) { <br>        // If it isn't orbiting we don't need to stop it! <br>        if (!stopme) return; <br>        if (!stopme-&gt;GetAppData()) return; <br>        FRAMEAPPDATA* data = (FRAMEAPPDATA*)stopme-&gt;GetAppData(); <br>        if (data-&gt;bOrbiting) { <br>                if (data-&gt;hDlg) { <br>                        // We explicitly call EndDialog on the orbit's control without sending it any message.  As a result we have <br>                        //   to grab it's associated orbitdata and delete it ourselves. <br>                        LPORBITDATA orbit_data = (LPORBITDATA)GetWindowLong(data-&gt;hDlg, DWL_USER); <br>                        if (orbit_data) delete orbit_data; <br>                        EndDialog(data-&gt;hDlg, TRUE); <br>                } <br> <br>                // Get its parent <br>                LPDIRECT3DRMFRAME parent; <br>                stopme-&gt;GetParent(&amp;parent); <br>                 <br>                // Put this frame back into the scene frame (this assumes that's where it came from) <br>                info-&gt;scene-&gt;AddChild(stopme); <br>                 <br>                // The parent frame of an orbiting visual is only around to make the object orbit, so we don't need it <br>                parent-&gt;Release(); <br>                data-&gt;bOrbiting = FALSE; <br>                data-&gt;hDlg = 0; <br>        } <br>        if (data-&gt;bBullet) { <br>                if (data-&gt;hDlg) { <br>                        LPBULLETDATA bullet_data = (LPBULLETDATA)GetWindowLong(data-&gt;hDlg, DWL_USER); <br>                        stopme-&gt;SetPosition(info-&gt;scene, bullet_data-&gt;vStartPosition.x, bullet_data-&gt;vStartPosition.y, bullet_data-&gt;vStartPosition.z); <br>                        if (bullet_data) delete bullet_data; <br>                        EndDialog(data-&gt;hDlg, TRUE); <br>                        stopme-&gt;DeleteMoveCallback(bulletCallback, bullet_data); <br>                } <br>                stopme-&gt;SetVelocity(info-&gt;scene, D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0), TRUE); <br>                data-&gt;bBullet = FALSE; <br>                data-&gt;hDlg = 0; <br>        } <br>} <br> <br>void RLDS3D_StopOrbitSelected() { <br>        StopOrbiting(sFrame); <br>} <br> <br>/* <br>** Windows procedure for the orbit dialog box <br>*/   <br> <br>BOOL CALLBACK OrbitDlgProc(HWND win, UINT msg, WPARAM wparam, LPARAM lparam) <br>{ <br>    lparam = lparam; <br> <br>        LPORBITDATA my_data = (ORBITDATA*)GetWindowLong(win, DWL_USER); <br>        char lpszTS[100]; <br> <br>    switch (msg) <br>    { <br>    case WM_INITDIALOG: <br>                // We've set it up to pass in the pointer to our case-specific data (through WM_INITDIALOG) <br>                // so we tuck it away for later use.  This points to the ORBITDATA structure associated with <br>                // this dialog box <br>                SetWindowLong(win, DWL_USER, lparam); <br>                sprintf(lpszTS, "%f", ((LPORBITDATA)lparam)-&gt;speed); <br>                SendDlgItemMessage(win, IDC_ORBIT, WM_SETTEXT, 0, (LPARAM) lpszTS); <br>                SendDlgItemMessage(win, IDC_ORBIT, EM_SETLIMITTEXT, 100, 0); <br>        return TRUE; <br> <br>    case WM_COMMAND: <br>                { <br>                        if (wparam == IDOK) { <br>                                // Stopping the orbit will end the dialog for us. <br>                                StopOrbiting(my_data-&gt;child_frame); <br>                                return TRUE; <br>                        } <br>                        else if (HIWORD(wparam) == EN_UPDATE &amp;&amp; LOWORD(wparam) == IDC_ORBIT) { <br>                                // Get string length <br>                                int stringlength = SendDlgItemMessage(win, IDC_ORBIT, EM_LINELENGTH, 0, 0); <br>                                // Check to make sure the string isn't too long - atof accepts up to 100 chars <br>                                if (stringlength &gt; 99) return TRUE; <br>                                lpszTS[0] = (char)stringlength; <br>                                // Get string <br>                                SendDlgItemMessage(win, IDC_ORBIT, EM_GETLINE, 0, (LPARAM) lpszTS); <br>                                lpszTS[stringlength] = 0; <br>                                // Store speed and set new rotation <br>                                my_data-&gt;speed = D3DVAL(atof(lpszTS)); <br>                                my_data-&gt;orbit_frame-&gt;SetRotation(info-&gt;scene, my_data-&gt;axis.x, my_data-&gt;axis.y, my_data-&gt;axis.z, my_data-&gt;speed); <br>                                return TRUE; <br>                        } <br>                        else return FALSE; <br>                }                <br>        break; <br>        } <br>        return FALSE; <br>} <br> <br>/* <br>** Windows proc for the bullet dialog box <br>*/ <br> <br>BOOL CALLBACK BulletDlgProc(HWND win, UINT msg, WPARAM wparam, LPARAM lparam) <br>{ <br>    lparam = lparam; <br> <br>        LPBULLETDATA my_data = (BULLETDATA*)GetWindowLong(win, DWL_USER); <br>        char lpszTS[100]; <br> <br>    switch (msg) <br>    { <br>    case WM_INITDIALOG: <br>                // We've set it up to pass in the pointer to our case-specific data (through WM_INITDIALOG) <br>                // so we tuck it away for later use.  This points to the ORBITDATA structure associated with <br>                // this dialog box <br>                SetWindowLong(win, DWL_USER, lparam); <br>                sprintf(lpszTS, "%f", ((LPBULLETDATA)lparam)-&gt;fSpeed); <br>                SendDlgItemMessage(win, IDC_BULLET, WM_SETTEXT, 0, (LPARAM) lpszTS); <br>                SendDlgItemMessage(win, IDC_BULLET, EM_SETLIMITTEXT, 100, 0); <br>        return TRUE; <br> <br>    case WM_COMMAND: <br>                { <br>                        if (wparam == IDOK) { <br>                                // Stopping the orbit will end the dialog for us. <br>                                StopOrbiting(my_data-&gt;bullet_frame); <br>                                return TRUE; <br>                        } <br>                        else if (HIWORD(wparam) == EN_UPDATE &amp;&amp; LOWORD(wparam) == IDC_BULLET) { <br>                                // Get string length <br>                                int stringlength = SendDlgItemMessage(win, IDC_BULLET, EM_LINELENGTH, 0, 0); <br>                                // Check to make sure the string isn't too long - atof accepts up to 100 chars <br>                                if (stringlength &gt; 99) return TRUE; <br>                                lpszTS[0] = (char)stringlength; <br>                                // Get string <br>                                SendDlgItemMessage(win, IDC_BULLET, EM_GETLINE, 0, (LPARAM) lpszTS); <br>                                lpszTS[stringlength] = 0; <br> <br>                                // Store speed and set <br>                                my_data-&gt;fSpeed = D3DVAL(atof(lpszTS)); <br>                                my_data-&gt;bullet_frame-&gt;SetVelocity(info-&gt;scene, D3DMultiply(my_data-&gt;vDirection.x, my_data-&gt;fSpeed), <br>                                                                    D3DMultiply(my_data-&gt;vDirection.y, my_data-&gt;fSpeed),  <br>                                                                    D3DMultiply(my_data-&gt;vDirection.z, my_data-&gt;fSpeed), <br>TRUE); <br>                                return TRUE; <br>                        } <br>                        else return FALSE; <br>                }                <br>        break; <br>        } <br>        return FALSE; <br>} <br> <br> <br> <br>/* <br>** Orbits the currently selected object around the camera... creates a frame which is centred at the camera and contains <br>**   the selected frame, and then rotates that frame around the camera <br>*/ <br> <br>ULONG orbit_num = 1; <br> <br>void RLDS3D_OrbitSelected(void) { <br>        if (!sFrame) return; <br>        StopOrbiting(sFrame); <br>        FRAMEAPPDATA* tempdat; <br>         <br>        // Need to create orbit data, if not then can't orbit <br>        LPORBITDATA orbitdat = new ORBITDATA; <br>        if (!orbitdat) return; <br> <br>        if (!sFrame-&gt;GetAppData()) { <br>                tempdat = new FRAMEAPPDATA(); <br>                if (!tempdat) return; <br>                sFrame-&gt;SetAppData((ULONG)(tempdat)); <br>        } <br>        else { <br>                tempdat = (LPFRAMEAPPDATA)sFrame-&gt;GetAppData(); <br>        } <br> <br>        // Create a frame.  Centre it around the camera.  Add the selected frame.  Rotate it! <br>        LPDIRECT3DRMFRAME orbiting_frame; <br> <br>        if (!D3DRM_SUCCEED(lpD3DRM-&gt;CreateFrame(info-&gt;scene, &amp;orbiting_frame))) return; <br> <br>        orbiting_frame-&gt;SetPosition(info-&gt;camera, D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0)); <br>        orbiting_frame-&gt;SetOrientation(info-&gt;camera, D3DVAL(0.0), D3DVAL(0.0), D3DVAL(1.0), D3DVAL(0.0), D3DVAL(1.0), D3DVAL(0.0)); <br>        orbiting_frame-&gt;AddChild(sFrame); <br> <br>        D3DVECTOR vDir, vUp; <br>        info-&gt;camera-&gt;GetOrientation(info-&gt;scene, &amp;vDir, &amp;vUp); <br> <br>        // Store orbit info <br>        orbitdat-&gt;orbit_frame = orbiting_frame; <br>        orbitdat-&gt;child_frame = sFrame; <br>        orbitdat-&gt;speed = D3DVAL(1.0); <br>        orbitdat-&gt;axis.x = vUp.x; <br>        orbitdat-&gt;axis.y = vUp.y; <br>        orbitdat-&gt;axis.z = vUp.z; <br> <br>        orbiting_frame-&gt;SetRotation(info-&gt;scene, vUp.x, vUp.y, vUp.z, orbitdat-&gt;speed); <br> <br>        // Set the boolean in the frame's appinfo to tell everyone it's orbiting <br>        tempdat-&gt;bOrbiting = TRUE; <br>         <br>        // Create a dialog box and orbitinfo so that this thing has something to control it <br>        HWND mydial = CreateDialogParam(hinst, "OrbitBox", hwndParent, OrbitDlgProc, (LONG)orbitdat); <br>        if (mydial) { <br>                char name_string[50]; <br>                sprintf(name_string, "Orbit #%i", orbit_num++); <br>                SetWindowText(mydial, name_string); <br>                ShowWindow(mydial, SW_SHOW); <br>                UpdateWindow(mydial); <br>                tempdat-&gt;hDlg = mydial; <br>        } <br>} <br> <br>/* <br>** Bullet the currently selected object.  Bullets have two properties: Speed and bullet-time.  The bullet passes through it's original <br>**   position along the path defined by the viewer's original viewpoint (it heads towards the viewer).  It takes 5 seconds to get to the <br>**   viewer and five seconds once past the viewer, and continues doing thus until the bullet is stopped.  Speed is controlled by the user. <br>*/ <br> <br>ULONG bullet_num = 1; <br> <br>void RLDS3D_BulletSelected(void) { <br>        if (!sFrame) return; <br>        StopOrbiting(sFrame); <br> <br>        FRAMEAPPDATA* tempdat; <br>        if (!sFrame-&gt;GetAppData()) { <br>                tempdat = new FRAMEAPPDATA(); <br>                if (!tempdat) return; <br>                sFrame-&gt;SetAppData((ULONG)(tempdat)); <br>        } <br>        else { <br>                tempdat = (LPFRAMEAPPDATA)sFrame-&gt;GetAppData(); <br>        } <br> <br>        // Create a new bullet object and attach our callback to the frame (it will release itself and put itself back <br>        //   into position when it's done!) <br> <br>        LPBULLETDATA bs = new BULLETDATA; <br>        if (!bs) return; <br> <br>        sFrame-&gt;GetPosition(info-&gt;scene, &amp;(bs-&gt;vStartPosition)); <br> <br>        D3DVECTOR vDir, vUp; <br>        info-&gt;camera-&gt;GetOrientation(info-&gt;scene, &amp;vDir, &amp;vUp); <br>        // velocity heading towards camera <br>        bs-&gt;vDirection.x = -vDir.x; <br>        bs-&gt;vDirection.y = -vDir.y; <br>        bs-&gt;vDirection.z = -vDir.z; <br> <br>        bs-&gt;bullet_frame = sFrame; <br>        bs-&gt;fTime = D3DVAL(10.0); // Ten seconds, 5 for before and 5 for after. <br>        bs-&gt;fSpeed = D3DVAL(10.0); <br>         <br>        D3DVALUE mult = D3DDivide(D3DMultiply(bs-&gt;fTime, bs-&gt;fSpeed), D3DVAL(-2.0)); // Calculate the displacement multiplier for calculating starting position <br>         <br>        sFrame-&gt;SetPosition(info-&gt;scene, bs-&gt;vStartPosition.x + D3DMultiply(mult, bs-&gt;vDirection.x), <br>                                             bs-&gt;vStartPosition.y + D3DMultiply(mult, bs-&gt;vDirection.y), <br>                                                                     bs-&gt;vStartPosition.z + D3DMultiply(mult, bs-&gt;vDirection.z)); <br> <br>        sFrame-&gt;SetVelocity(info-&gt;scene, D3DMultiply(bs-&gt;vDirection.x, bs-&gt;fSpeed), <br>                             D3DMultiply(bs-&gt;vDirection.y, bs-&gt;fSpeed), <br>                             D3DMultiply(bs-&gt;vDirection.z, bs-&gt;fSpeed), <br> TRUE); <br> <br>        sFrame-&gt;AddMoveCallback(bulletCallback, (void*)bs); <br>         <br>        // Set the boolean in the frame's appinfo to tell everyone it's orbiting <br>        tempdat-&gt;bBullet = TRUE; <br> <br>        // Create a dialog box and orbitinfo so that this thing has something to control it <br>        HWND mydial = CreateDialogParam(hinst, "BulletBox", hwndParent, BulletDlgProc, (LONG)bs); <br>        if (mydial) { <br>                char name_string[50]; <br>                sprintf(name_string, "Bullet #%i", bullet_num++); <br>                SetWindowText(mydial, name_string); <br>                ShowWindow(mydial, SW_SHOW); <br>                UpdateWindow(mydial); <br>                tempdat-&gt;hDlg = mydial; <br>        } <br>} <br> <br>/* <br>**********************************  DIRECTSOUND 3D FUNCTIONS  ***************************************** <br>*/ <br> <br>/* <br>** The RLDS3D interface allows you to attach sound(s) to the selected object which can then be played and <br>**   whose 3D audio position will update according to the RL object's position <br>** <br>** Some functionality is applied to all sounds, and as a result, the RLDS3D interface keeps a record of <br>**   existing sounds and which frames they are attached to.  Removal of a frame and/or a sound updates these <br>**   records <br>*/ <br> <br>/* <br>** CALLBACKS - update position as 3D objects move around <br>*/ <br> <br> <br>// The listener callback is attached to the camera.  This is done in CreateScene() <br>static void CDECL listenerCallback(LPDIRECT3DRMFRAME obj, void* arg, D3DVALUE delta) <br>{ <br>        arg = arg; <br>        if (!lpDS) return; <br>        D3DVECTOR rlvCameraInfo, rlvCameraUp; <br> <br>        info-&gt;camera-&gt;GetPosition(info-&gt;scene, &amp;rlvCameraInfo); <br>        lp3DListenerInfo-&gt;SetPosition(rlvCameraInfo.x, rlvCameraInfo.y, <br>      rlvCameraInfo.z, DS3D_DEFERRED); <br> <br>        info-&gt;camera-&gt;GetOrientation(info-&gt;scene, &amp;rlvCameraInfo, &amp;rlvCameraUp); <br>        lp3DListenerInfo-&gt;SetOrientation(rlvCameraInfo.x, rlvCameraInfo.y, <br> rlvCameraInfo.z, rlvCameraUp.x, <br> rlvCameraUp.y, rlvCameraUp.z, DS3D_DEFERRED); <br> <br>        info-&gt;camera-&gt;GetVelocity(info-&gt;scene, &amp;rlvCameraInfo, TRUE); <br>        lp3DListenerInfo-&gt;SetVelocity(rlvCameraInfo.x, rlvCameraInfo.y, <br>      rlvCameraInfo.z, DS3D_DEFERRED); <br> <br>lp3DListenerInfo-&gt;CommitDeferredSettings(); <br>} <br> <br> <br>// Sounds are updated whenever their frame moves using Render Callbacks.  This is the callback function. <br>static void CDECL soundCallback(LPDIRECT3DRMFRAME obj, void* arg, D3DVALUE delay) <br>{ <br>        arg = arg; <br>        LPDIRECT3DRMFRAME tFrame = (LPDIRECT3DRMFRAME)obj; <br>        if (!lpDS) return; <br>        // Get the sound from the frame's app data <br>        LPFRAMEAPPDATA lpAppDat = (LPFRAMEAPPDATA)tFrame-&gt;GetAppData(); <br>        if (!lpAppDat) return; <br>        // Get the 3D sound buffer and remove the sound callback if it's NULL since it shouldn't exist <br>        if (!lpAppDat-&gt;Sound || !lpAppDat-&gt;i3DSound) { <br>                releaseSoundCallback(tFrame); <br>                return; <br>        } <br>        D3DVECTOR rlvVisualInfo, rlvVisualUp; <br> <br>        tFrame-&gt;GetPosition(info-&gt;scene, &amp;rlvVisualInfo); <br>        lpAppDat-&gt;i3DSound-&gt;SetPosition(rlvVisualInfo.x, rlvVisualInfo.y, <br>rlvVisualInfo.z, DS3D_DEFERRED); <br> <br>        tFrame-&gt;GetOrientation(info-&gt;scene, &amp;rlvVisualInfo, &amp;rlvVisualUp); <br>        lpAppDat-&gt;i3DSound-&gt;SetConeOrientation(rlvVisualInfo.x, rlvVisualInfo.y, <br>       rlvVisualInfo.z, DS3D_DEFERRED); <br>  <br>        tFrame-&gt;GetVelocity(info-&gt;scene, &amp;rlvVisualInfo, TRUE); <br>        lpAppDat-&gt;i3DSound-&gt;SetVelocity(rlvVisualInfo.x, rlvVisualInfo.y, <br>rlvVisualInfo.z, DS3D_DEFERRED); <br> <br>lp3DListenerInfo-&gt;CommitDeferredSettings(); <br>} <br> <br>// This adds a sound callback function to a frame <br>void setSoundCallback(LPDIRECT3DRMFRAME frame) { <br>        frame-&gt;AddMoveCallback(soundCallback, NULL); <br>} <br> <br>// Removes a sound callback from a frame <br>void releaseSoundCallback(LPDIRECT3DRMFRAME frame) { <br>        frame-&gt;DeleteMoveCallback(soundCallback, NULL); <br>} <br> <br>/* <br>** Sound records - keeps track of which frames have sounds associated with them and <br>**   adds/removes the sounds as required. <br>*/ <br> <br>struct SoundRecord { <br>        LPDIRECT3DRMFRAME  lpFrame; <br>        SoundRecord* next; <br>}; <br> <br>SoundRecord* top = NULL; <br> <br>BOOL Recurse_Remove(LPDIRECT3DRMFRAME owner, SoundRecord* record) { <br>        if (!record) return FALSE; <br>        if (Recurse_Remove(owner, record-&gt;next)) { <br>                SoundRecord* temp = record-&gt;next; <br>                record-&gt;next = temp-&gt;next; <br>                delete temp; <br>        } <br>        if (owner == record-&gt;lpFrame) return TRUE; <br>        return FALSE; <br>} <br> <br>// Removes a frame from the records <br>void RemoveSoundRecord(LPDIRECT3DRMFRAME owner) { <br>        if (!owner) return; <br> <br>        // Don't bother deleting frames without appdata and a sound associated with them <br>        // because they SHOULDN'T be on the list. <br>        if (!owner-&gt;GetAppData()) return; <br>        LPFRAMEAPPDATA data = (LPFRAMEAPPDATA)(owner-&gt;GetAppData()); <br>        if (!data-&gt;Sound) return; <br>         <br>        // Release the sound and remove the soundrecord from the list. <br>        data-&gt;i3DSound-&gt;Release(); <br>        data-&gt;i3DSound = NULL; <br>        data-&gt;Sound-&gt;Release(); <br>        data-&gt;Sound = NULL; <br>        releaseSoundCallback(owner); <br>         <br>        if (Recurse_Remove(owner, top)) { <br>                SoundRecord* temp = top; <br>                top = top-&gt;next; <br>                delete temp; <br>        } <br>} <br> <br>// Adds a frame to the records <br>void AddSoundRecord(LPDIRECT3DRMFRAME owner, char* sound_filename) { <br>        if (!lpDS) return; <br>        if (!owner) return; <br>        if (!sound_filename) return; <br>         <br>        // Removes all previous sounds from this frame <br>        RemoveSoundRecord(owner); <br>         <br>        // Create frame data for this frame if it hasn't already been done <br>        LPFRAMEAPPDATA data = (LPFRAMEAPPDATA)(owner-&gt;GetAppData()); <br>        if (!data) { <br>                data = new FRAMEAPPDATA(); <br>                if (!data) return; <br>                owner-&gt;SetAppData((ULONG)data); <br>        } <br>         <br>        // Create the sound and attach it to the frame <br>        data-&gt;Sound = DSLoad3DSoundBuffer(lpDS, sound_filename); <br>        if (!data-&gt;Sound) return;  <br>         <br>        // Query to get the 3D interface, destroy the sound buffer if it's not available... <br>        data-&gt;Sound-&gt;QueryInterface(IID_IDirectSound3DBuffer, (void**)&amp;data-&gt;i3DSound); <br>        if (!data-&gt;i3DSound) { <br>                data-&gt;Sound-&gt;Release(); <br>                data-&gt;Sound = NULL; <br>                return; <br>        } <br> <br>        // Set the minimum distance at which the sound's amplitude should decay. <br>        data-&gt;i3DSound-&gt;SetMinDistance((D3DVALUE)10.0, DS3D_IMMEDIATE); <br> <br>        setSoundCallback(owner); <br> <br>        SoundRecord* temp = new SoundRecord; <br>        temp-&gt;next = top; <br>        top = temp; <br>        top-&gt;lpFrame = owner; <br>} <br> <br>/* <br>** Functionality for users <br>*/ <br> <br>// Stops all the sounds in the world.  (Actually, only in the local RL world.) <br>// Runs through the records of all the sounds and stops them. <br>void RLDS3D_StopAllSounds() { <br>        if (!lpDS) return; <br>        SoundRecord* temp = top; <br>        while (temp) { <br>                LPFRAMEAPPDATA data = (LPFRAMEAPPDATA)(temp-&gt;lpFrame-&gt;GetAppData()); <br>                if (data) { <br>                        if (data-&gt;Sound) data-&gt;Sound-&gt;Stop(); <br>                } <br>                temp = temp-&gt;next; <br>        } <br>} <br> <br>// Removes all sounds in the world <br>void RLDS3D_RemoveAllSounds() { <br>        if (!lpDS) return; <br>        while (top) RemoveSoundRecord(top-&gt;lpFrame); <br>UpdateConeVisual(); <br>} <br> <br>// Plays the sound associated with the currently selected object <br>void RLDS3D_PlaySound(BOOL bIsLooping) { <br>        if (!sFrame) return; <br>        if (!lpDS) return; <br>        LPFRAMEAPPDATA lpAppDat = (LPFRAMEAPPDATA)sFrame-&gt;GetAppData(); <br>        if (lpAppDat) { <br>                if (lpAppDat-&gt;Sound) { <br>                        lpAppDat-&gt;Sound-&gt;Stop(); <br>                        lpAppDat-&gt;Sound-&gt;SetCurrentPosition(0); <br>                        if (bIsLooping) { <br>                                lpAppDat-&gt;Sound-&gt;Play(0,0,DSBPLAY_LOOPING); <br>                        } <br>                        else { </code></pre>
<p>
</p>
<pre><code>lpAppDat-&gt;Sound-&gt;Play(0,0,0); <br>                        } <br>                } <br>        } <br>} <br> <br>// Stops the sound associated with the currently selected object <br>void RLDS3D_StopSelectedSound() { <br>        if (!sFrame) return; <br>        if (!lpDS) return; <br>        LPFRAMEAPPDATA lpAppDat = (LPFRAMEAPPDATA)sFrame-&gt;GetAppData(); <br>        if (lpAppDat) { <br>                if (lpAppDat-&gt;Sound) { <br>                        lpAppDat-&gt;Sound-&gt;Stop(); <br>                } <br>        } <br>} <br> <br>// Removes the sound from the currently selected object <br>void RLDS3D_RemoveSound() { <br>        RLDS3D_StopSelectedSound(); <br>        if (!sFrame) return; <br>        if (!lpDS) return; <br>        RemoveSoundRecord(sFrame); <br>UpdateConeVisual(); <br>} <br> <br>// Attaches a sound (filename provided) to the selected frame <br>void RLDS3D_AttachSound(char* filename) { <br>        // Removes the sound attached to the currently selected item (if it exists) <br>        RLDS3D_RemoveSound(); <br>        if (!sFrame) return; <br>        if (!lpDS) return; <br>        AddSoundRecord(sFrame, filename); <br>UpdateConeVisual(); <br>} <br> <br>/* <br>*************************************  MISC. MAINTENANCE FUNCTIONS  ************************************** <br>*/ <br> <br>/* <br>** Allows external users access to the RL Device to deal with Windows-related issues <br>**   (See case WM_ACTIVATE: and case WM_PAINT: in viewer source for examples of HandleActivate() and HandlePaint()) <br>** Design note: This was done to save time from the conversion from the old version of the viewer rather than <br>**   having RLDS3D_HandleActivate(), etc. <br>*/ <br> <br>LPDIRECT3DRMDEVICE RLDS3D_WinDevice() { <br>        if (!info) return NULL; <br>        return info-&gt;dev; <br>} <br> <br>/* <br>** Handles activation messages from the window <br>*/ <br> <br>void RLDS3D_HandleActivate(WPARAM wparam) { <br>        if (!info || !info-&gt;dev) return; <br>        LPDIRECT3DRMWINDEVICE windev; <br>        if (D3DRM_SUCCEED(info-&gt;dev-&gt;QueryInterface(IID_IDirect3DRMWinDevice, (void **) &amp;windev))) { <br>                windev-&gt;HandleActivate(wparam); <br>                windev-&gt;Release(); <br>        } <br>} <br> <br>/* <br>** Handles paint messages from the window - the paintstruct which BeginPaint has been called on is <br>**   passed to it <br>*/ <br> <br>void RLDS3D_HandlePaint(PAINTSTRUCT* ps) { <br>        if (!info) return; <br>        LPDIRECT3DRMWINDEVICE windev; <br>        if (D3DRM_SUCCEED(info-&gt;dev-&gt;QueryInterface(IID_IDirect3DRMWinDevice, (void **) &amp;windev))) { <br>                windev-&gt;HandlePaint(ps-&gt;hdc); <br>                windev-&gt;Release(); <br>        } <br>} <br> <br>/* <br>** Tells whether or not sound is initialized <br>*/ <br> <br>BOOL RLDS3D_SoundInitialized() { <br>        if (lpDS) return TRUE; <br>        return FALSE; <br>} <br> <br>/* <br>** Tells whether or not a frame is selected <br>*/ <br> <br>BOOL RLDS3D_FrameSelected() { <br>        if (sFrame) return TRUE; <br>        return FALSE; <br>} <br> <br>/* <br>** Render the scene into the viewport. <br>*/ <br> <br>void RLDS3D_Render(D3DVALUE time_delta) <br>{ <br>    // When the WM_SIZE message passes 0's as size to the ResizeViewport we know that it's minimized, in which case we don't render it. <br>    if (info-&gt;bMinimized == TRUE) return; <br>    D3DRM_SUCCEED(info-&gt;scene-&gt;Move(time_delta)); <br>    D3DRM_SUCCEED(info-&gt;view-&gt;Clear()); <br>    D3DRM_SUCCEED(info-&gt;view-&gt;Render(info-&gt;scene)); <br>    D3DRM_SUCCEED(info-&gt;dev-&gt;Update()); <br>} <br> <br> <br>/* <br> * Resize the viewport and device when the window size changes. <br> */ <br>void RLDS3D_ResizeViewport(int width, int height) <br>{ <br>    int view_width = info-&gt;view-&gt;GetWidth(); <br>    int view_height = info-&gt;view-&gt;GetHeight(); <br>    int dev_width = info-&gt;dev-&gt;GetWidth(); <br>    int dev_height = info-&gt;dev-&gt;GetHeight(); <br> <br>    if (!(width &amp;&amp; height)) { <br>            info-&gt;bMinimized = TRUE; <br>            return; <br> <br>    } <br>    else info-&gt;bMinimized = FALSE; <br> <br>    if (view_width == width &amp;&amp; view_height == height) <br>        return; <br>else info-&gt;bMinimized = FALSE; <br>     <br>    if (width &lt;= dev_width &amp;&amp; height &lt;= dev_height) { <br>        info-&gt;view-&gt;Release(); <br>        D3DRM_SUCCEED(lpD3DRM-&gt;CreateViewport(info-&gt;dev, info-&gt;camera, 0, 0, width, height, &amp;info-&gt;view)); <br>        info-&gt;view-&gt;SetBack(D3DVAL(400.0)); <br>    } <br> <br>    int ret; <br>    if (!RebuildDevice(hwndParent, info, width, height)) { <br>        ret = MessageBox(hwndParent, "Unable to create Direct3D device", "D3DRM Fatal Error", MB_APPLMODAL|MB_ICONSTOP|MB_OK); <br>        PostMessage(hwndParent, WM_CLOSE,0,0); <br>    }; <br>} <br> <br>/* <br>** Sets/Gets the polygon fill mode <br>*/ <br> <br>D3DRMFILLMODE RLDS3D_GetPolygonFillMode(void) { <br>    return (D3DRMFILLMODE)(info-&gt;dev-&gt;GetQuality() &amp; D3DRMFILL_MASK); <br>} <br> <br>void RLDS3D_SetPolygonFillMode(D3DRMFILLMODE quality) { <br>    D3DRMRENDERQUALITY oldq = info-&gt;dev-&gt;GetQuality(); <br>    oldq = (oldq &amp; ~D3DRMFILL_MASK) | quality; <br>    info-&gt;dev-&gt;SetQuality(oldq); <br>} <br> <br>/* <br>** Sets/Gets the polygon shading mode <br>*/ <br> <br>D3DRMSHADEMODE RLDS3D_GetPolygonShadeMode(void) { <br>        return (D3DRMSHADEMODE)(info-&gt;dev-&gt;GetQuality() &amp; D3DRMSHADE_MASK); <br>} <br> <br>void RLDS3D_SetPolygonShadeMode(D3DRMSHADEMODE quality) { <br>        D3DRMRENDERQUALITY oldq = info-&gt;dev-&gt;GetQuality(); <br>        oldq = (oldq &amp; ~D3DRMSHADE_MASK) | quality; <br>        info-&gt;dev-&gt;SetQuality(oldq); <br>} <br> <br> <br>/* <br>** Sets/Gets the color model for the viewport (RGB or mono (256-color-based)) <br>*/ <br> <br>D3DRMCOLORMODEL RLDS3D_GetColourModel(void) { <br>        return info-&gt;model; <br>} <br> <br>void RLDS3D_SetColourModel(D3DRMCOLORMODEL model) { <br>    info-&gt;model = model; <br>    int ret; <br>    if (!RebuildDevice(hwndParent, info, info-&gt;dev-&gt;GetWidth(), info-&gt;dev-&gt;GetHeight())) { <br>        ret = MessageBox(hwndParent, "Unable to selected Direct3D device", "D3DRM Fatal Error", MB_APPLMODAL|MB_ICONSTOP|MB_OK); <br>        PostMessage(hwndParent, WM_CLOSE,0,0); <br>    } <br>} <br> <br>/* <br>** Sets/Gets whether or not lighting is on <br>*/ <br>  <br>BOOL RLDS3D_GetLighting(void) { <br>    D3DRMLIGHTMODE mode = (D3DRMLIGHTMODE)(info-&gt;dev-&gt;GetQuality() &amp; D3DRMLIGHT_MASK); <br>    if (mode == D3DRMLIGHT_ON) return TRUE; <br>    return FALSE; <br>} <br> <br>void RLDS3D_SetLighting(BOOL new_val) { <br>    D3DRMRENDERQUALITY qual = info-&gt;dev-&gt;GetQuality() &amp; ~D3DRMLIGHT_MASK; <br>    if (new_val) qual |= D3DRMLIGHT_ON; else qual |= D3DRMLIGHT_OFF; <br>    info-&gt;dev-&gt;SetQuality(qual); <br>} <br> <br>/* <br>** Sets/Gets whether or not dithering is on <br>*/ <br> <br>BOOL RLDS3D_GetDither(void) { <br>    return info-&gt;dev-&gt;GetDither(); <br>} <br> <br>void RLDS3D_SetDither(BOOL dither) { <br>    info-&gt;dev-&gt;SetDither(dither); <br>} <br> <br>/* <br>** Sets/Gets texture quality (only relevant for RGB modes) <br>*/ <br> <br>D3DRMTEXTUREQUALITY RLDS3D_GetTextureQuality(void) { <br>    return info-&gt;dev-&gt;GetTextureQuality(); <br>} <br> <br>void RLDS3D_SetTextureQuality(D3DRMTEXTUREQUALITY new_quality) { <br>    info-&gt;dev-&gt;SetTextureQuality(new_quality); <br>} <br> <br> <br>/* <br>*************************************  INTERNAL FUNCTIONS (Not part of API)  ******************************** <br>*/ <br> <br>/* <br>** Given a bounding box this generates a visual representation of it using rods and cones <br>*/ <br> <br>static LPDIRECT3DRMMESHBUILDER makeBox(D3DRMBOX* box) <br>{ <br>    LPDIRECT3DRMMESHBUILDER mesh; <br>    static D3DVECTOR zero = {D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0)}; <br>    static D3DVECTOR dir = {D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0)}; <br>    D3DVECTOR a, b; <br> <br>    if (!D3DRM_SUCCEED(lpD3DRM-&gt;CreateMeshBuilder(&amp;mesh))) return NULL; <br> <br>    dir.z = box-&gt;max.z + D3DVAL(1.0); <br>    AddRod(mesh, D3DVAL(0.05), zero, dir); <br>    a = dir; <br>    a.z += D3DVAL(0.6); <br>    AddCone(mesh, D3DVAL(0.2), dir, a); <br>    a = box-&gt;min; <br>    b = a; <br>    b.y = box-&gt;max.y; <br>    AddRod(mesh, D3DVAL(0.05), a, b); <br>    a = b; b.x = box-&gt;max.x; <br>    AddRod(mesh, D3DVAL(0.05), a, b); <br>    a = b; b.y = box-&gt;min.y; <br>    AddRod(mesh, D3DVAL(0.05), a, b); <br>    a = b; b.x = box-&gt;min.x; <br>    AddRod(mesh, D3DVAL(0.05), a, b); <br>    a = b; b.z = box-&gt;max.z; <br>    AddRod(mesh, D3DVAL(0.05), a, b); <br>    a = b; b.x = box-&gt;max.x; <br>    AddRod(mesh, D3DVAL(0.05), a, b); <br>    a = b; b.y = box-&gt;max.y; <br>    AddRod(mesh, D3DVAL(0.05), a, b); <br>    a = b; b.x = box-&gt;min.x; <br>    AddRod(mesh, D3DVAL(0.05), a, b); <br>    a = b; b.y = box-&gt;min.y; <br>    AddRod(mesh, D3DVAL(0.05), a, b); <br>    b.y = box-&gt;max.y; a = b; b.z = box-&gt;min.z; <br>    AddRod(mesh, D3DVAL(0.05), a, b); <br>    a = b = box-&gt;max; b.z = box-&gt;min.z; <br>    AddRod(mesh, D3DVAL(0.05), a, b); <br>    a.y = box-&gt;min.y; b = a; b.z = box-&gt;min.z; <br>    AddRod(mesh, D3DVAL(0.05), a, b); <br>                 <br>    if (!D3DRM_SUCCEED(mesh-&gt;SetColor(D3DRMCreateColorRGB(D3DVAL(1.0), D3DVAL(1.0), D3DVAL(1.0))))) { <br>        mesh-&gt;Release(); <br>        return NULL; <br>    } <br>    return mesh; <br>} <br> <br>/* <br>** Given a box, this creates a mesh in the shape of a 16-sided speaker cone aimed forward with requested angle <br>*/ <br> <br>#define CONE_POINTS 16 <br>#define pi 3.14159 <br> <br>static LPDIRECT3DRMMESHBUILDER makeSpeaker(D3DRMBOX* box, D3DVALUE in_angle) { <br>    if (!box) return NULL; <br>     <br>    D3DVALUE angle = in_angle / D3DVAL(2.0);  <br>DWORD* speaker_faces = new DWORD[CONE_POINTS*4+1]; <br>    if (!speaker_faces) return NULL; <br>    memset(speaker_faces, 0, sizeof(DWORD[CONE_POINTS*4+1])); <br> <br>    LPDIRECT3DRMMESHBUILDER mesh; <br>    if (!D3DRM_SUCCEED(lpD3DRM-&gt;CreateMeshBuilder(&amp;mesh))) { <br>        delete speaker_faces; <br>        return NULL; <br>    } <br>     <br>    static D3DVECTOR zero = {D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0)}; <br> <br>    D3DVECTOR v[CONE_POINTS+1]; <br> <br>    // center of the cone <br>    v[CONE_POINTS] = zero; <br> <br>    int looper; <br> <br>    // Angle along XZ plane which is rotated CONE_POINT times to form cone <br>    D3DVECTOR base_angle; <br>    base_angle.z = (box-&gt;max.z + D3DVAL(2.0)) * (D3DVALUE)cos(angle * pi / 180.0); <br>    base_angle.x = (box-&gt;max.z + D3DVAL(2.0)) * (D3DVALUE)sin(angle * pi / 180.0); <br>    base_angle.y = D3DVAL(0.0); <br>     <br>    for (looper=0; looper&lt;CONE_POINTS; looper++) { <br>        v[looper].z = base_angle.z; <br>        v[looper].x = base_angle.x * (D3DVALUE)cos((looper*2*pi)/CONE_POINTS); <br>        v[looper].y = base_angle.x * (D3DVALUE)sin((looper*2*pi)/CONE_POINTS); <br>        speaker_faces[looper*4] = 3; <br>        speaker_faces[looper*4+1] = looper % CONE_POINTS; <br>        speaker_faces[looper*4+2] = (looper + 1) % CONE_POINTS; <br>        speaker_faces[looper*4+3] = CONE_POINTS; <br>    } <br> <br>    v[CONE_POINTS] = zero; <br> <br>    if (!D3DRM_SUCCEED(mesh-&gt;AddFaces(CONE_POINTS+1, v, 0, NULL, speaker_faces, NULL))) { <br>        delete speaker_faces; <br>        mesh-&gt;Release(); <br>        return NULL; <br>    } <br> <br>    for (looper=0; looper&lt;CONE_POINTS; looper++) { <br>        speaker_faces[looper*4+2] = looper % CONE_POINTS; <br>        speaker_faces[looper*4+1] = (looper + 1) % CONE_POINTS; <br>    } <br> <br>    if (!D3DRM_SUCCEED(mesh-&gt;AddFaces(CONE_POINTS+1, v, 0, NULL, speaker_faces, NULL))) { <br>        delete speaker_faces; <br>        mesh-&gt;Release(); <br>        return NULL; <br>    } <br>     <br>    delete speaker_faces; <br> <br>    if (!D3DRM_SUCCEED(mesh-&gt;SetColor(D3DRMCreateColorRGB(D3DVAL(1.0), D3DVAL(1.0), D3DVAL(1.0))))) { <br>        mesh-&gt;Release(); <br>        return NULL; <br>    } <br> <br>    if (!D3DRM_SUCCEED(mesh-&gt;SetQuality((mesh-&gt;GetQuality() &amp; ~D3DRMSHADE_MASK) | D3DRMSHADE_FLAT))) { <br>        mesh-&gt;Release(); <br>        return NULL; <br>    } <br> <br>    return mesh; <br>} <br> <br>/* <br>** Selects the given visual inside the given frame <br>*/ <br> <br>void UpdateConeVisual(void) { <br>if (!sFrame) return; <br>if (!sFrame-&gt;GetAppData()) return; <br>    LPFRAMEAPPDATA fd = (LPFRAMEAPPDATA)sFrame-&gt;GetAppData(); <br>if (!fd-&gt;i3DSound) return; <br>if (showBoxes &amp;&amp; sVisual) <br>        {   D3DRMBOX box; <br>            LPDIRECT3DRMMESHBUILDER builder; <br>        sFrame-&gt;DeleteVisual(selectionSpeaker); <br>            sVisual-&gt;GetBox(&amp;box); <br>DWORD temp, outer; <br>fd-&gt;i3DSound-&gt;GetConeAngles(&amp;temp, &amp;outer); <br>            builder = makeSpeaker(&amp;box, D3DVAL(temp)); <br>            builder-&gt;CreateMesh(&amp;selectionSpeaker); <br>            sFrame-&gt;AddVisual(selectionSpeaker); <br>            selectionSpeaker-&gt;Release(); <br>builder-&gt;Release(); <br>} <br> <br>} <br> <br>void SelectVisual(LPDIRECT3DRMMESHBUILDER visual, LPDIRECT3DRMFRAME frame) { <br>    RLDS3D_DeselectVisual(); <br>    sVisual = visual; <br>    sFrame = frame; <br> <br>    if (sVisual) <br>    {   LPDIRECT3DRMLIGHTARRAY lights; <br> <br>        sLight = 0; <br>        sFrame-&gt;GetLights(&amp;lights); <br>        if (lights) <br>        {   if (lights-&gt;GetSize()) <br>            {   lights-&gt;GetElement(0, &amp;sLight); <br>                sLight-&gt;Release(); /* reinstate reference count */ <br>            } <br>            lights-&gt;Release(); <br>        } <br> <br>        if (showBoxes &amp;&amp; visual) <br>        {   D3DRMBOX box; <br>            LPDIRECT3DRMMESHBUILDER builder; <br> <br>            sVisual-&gt;GetBox(&amp;box); <br>            builder = makeBox(&amp;box); <br>            builder-&gt;CreateMesh(&amp;selectionBox); <br>            sFrame-&gt;AddVisual(selectionBox); <br>            selectionBox-&gt;Release(); <br>builder-&gt;Release(); <br>UpdateConeVisual(); <br>        } <br>    } <br>} <br> <br>LPGUID <br>FindDevice(D3DCOLORMODEL cm) <br>{ <br>    LPDIRECTDRAW lpDD; <br>    LPDIRECT3D lpD3D; <br>    D3DFINDDEVICESEARCH search; <br>    static D3DFINDDEVICERESULT result; <br>    HRESULT error; <br> <br>    if (DirectDrawCreate(NULL, &amp;lpDD, NULL) != DD_OK) <br>        return NULL; <br> <br>    if (lpDD-&gt;QueryInterface(IID_IDirect3D, (void**) &amp;lpD3D) != DD_OK) { <br>        lpDD-&gt;Release(); <br>        return NULL; <br>    } <br>     <br>    memset(&amp;search, 0, sizeof search); <br>    search.dwSize = sizeof search; <br>    search.dwFlags = D3DFDS_COLORMODEL; <br>    search.dcmColorModel = (cm == D3DCOLOR_MONO) ? D3DCOLOR_MONO : D3DCOLOR_RGB; <br> <br>    memset(&amp;result, 0, sizeof result); <br>    result.dwSize = sizeof result; <br> <br>    error = lpD3D-&gt;FindDevice(&amp;search, &amp;result); <br> <br>    lpD3D-&gt;Release(); <br>    lpDD-&gt;Release(); <br> <br>    if (error != D3D_OK) <br>        return NULL; <br>    else <br>        return &amp;result.guid; <br>} <br> <br>/* <br> * Create the device and viewport. <br> */ <br> <br>static BOOL CreateDevice(HWND win, AppInfo* info) <br>{ <br>    RECT r; <br>    int bpp; <br>    HDC hdc; <br> <br>    GetClientRect(win, &amp;r); <br>    if (!D3DRM_SUCCEED(lpD3DRM-&gt;CreateDeviceFromClipper(lpDDClipper, NULL, r.right, r.bottom, &amp;info-&gt;dev))) return FALSE; <br>         <br>        hdc = GetDC(win); <br>    bpp = GetDeviceCaps(hdc, BITSPIXEL); <br>    ReleaseDC(win, hdc); <br>    switch (bpp) <br>    { <br>    case 1: <br>        info-&gt;dev-&gt;SetShades(4); <br>        lpD3DRM-&gt;SetDefaultTextureShades(4); <br>        break; <br>    case 16: <br>        info-&gt;dev-&gt;SetShades(32); <br>        lpD3DRM-&gt;SetDefaultTextureColors(64); <br>        lpD3DRM-&gt;SetDefaultTextureShades(32); <br>        info-&gt;dev-&gt;SetDither(FALSE); <br>        break; <br>    case 24: <br>        info-&gt;dev-&gt;SetShades(256); <br>        lpD3DRM-&gt;SetDefaultTextureColors(64); <br>        lpD3DRM-&gt;SetDefaultTextureShades(256); <br>        info-&gt;dev-&gt;SetDither(FALSE); <br>        break; <br>    default: <br>        info-&gt;dev-&gt;SetDither(FALSE); <br>    } <br>    if (!CreateScene(info)) { <br>                info-&gt;dev-&gt;Release(); <br>                return FALSE; <br>        } <br>    if (!D3DRM_SUCCEED(lpD3DRM-&gt;CreateViewport(info-&gt;dev, info-&gt;camera, 0, 0, info-&gt;dev-&gt;GetWidth(), info-&gt;dev-&gt;GetHeight(), &amp;info-&gt;view))) { <br>                info-&gt;dev-&gt;Release(); <br>                return FALSE; <br>        } <br>    info-&gt;view-&gt;SetBack(D3DVAL(5000.0)); <br>        return TRUE; <br>} <br> <br>/* <br> * Creates a simple scene and adds it to the main scene <br> */ <br> <br>static BOOL CreateScene(AppInfo* info) <br>{ <br>    LPDIRECT3DRMFRAME light; <br>    LPDIRECT3DRMLIGHT light1, light2; <br> <br>    // Note that if something fails, we don't bother freeing up everything we've created... the caller to CreateScene should destroy <br>    //   the lpD3DRM object and that should happily release everything created with it. <br>    // Also note that, since we're just the viewer, if there's a critical error we pass a quit message with our error message since <br>    //   we'd want to quit if the initialize failed anyways... <br> <br>    if (!D3DRM_SUCCEED(lpD3DRM-&gt;CreateFrame(NULL, &amp;info-&gt;scene))) return FALSE; <br>    if (!D3DRM_SUCCEED(lpD3DRM-&gt;CreateLightRGB(D3DRMLIGHT_DIRECTIONAL, D3DVAL(1.0), D3DVAL(1.0), D3DVAL(1.0), &amp;light1))) return FALSE; <br>    if (!D3DRM_SUCCEED(lpD3DRM-&gt;CreateLightRGB(D3DRMLIGHT_AMBIENT, D3DVAL(0.1), D3DVAL(0.1), D3DVAL(0.1), &amp;light2))) return FALSE; <br>    if (!D3DRM_SUCCEED(lpD3DRM-&gt;CreateFrame(info-&gt;scene, &amp;light))) return FALSE; <br> <br>    light-&gt;SetPosition(info-&gt;scene, D3DVAL(2.0), D3DVAL(2.0), D3DVAL(5.0)); <br>    light-&gt;SetOrientation(info-&gt;scene, D3DVAL(-1.0), D3DVAL(-1.0), D3DVAL(1.0), D3DVAL(0.0), D3DVAL(1.0), D3DVAL(0.0)); <br>    light-&gt;AddLight(light1); <br>    info-&gt;scene-&gt;AddLight(light2); <br> <br>    if (!D3DRM_SUCCEED(lpD3DRM-&gt;CreateFrame(info-&gt;scene, &amp;info-&gt;camera))) return FALSE; <br>    info-&gt;camera-&gt;SetPosition(info-&gt;scene, D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0)); <br>    // Add a callback to the camera's frame so that the listener is updated with the camera <br>    info-&gt;camera-&gt;AddMoveCallback(listenerCallback, NULL); <br> <br>    light-&gt;Release(), light1-&gt;Release(), light2-&gt;Release(); <br>    return TRUE; <br>} <br> <br>/* <br> * Regenerate the device if the color model changes or the window size <br> * changes. <br> */ <br>static BOOL RebuildDevice(HWND win, AppInfo* info, int width, int height) <br>{ <br>    int old_dither = info-&gt;dev-&gt;GetDither(); <br>    D3DRMRENDERQUALITY old_quality = info-&gt;dev-&gt;GetQuality(); <br>    int old_shades = info-&gt;dev-&gt;GetShades(); <br> <br>    info-&gt;view-&gt;Release(); <br>    info-&gt;dev-&gt;Release(); <br>     <br>    LPGUID guid = FindDevice(info-&gt;model); <br> <br>    if (!guid) return FALSE; <br> <br>    if (!D3DRM_SUCCEED(lpD3DRM-&gt;CreateDeviceFromClipper(lpDDClipper, guid, width, height, &amp;info-&gt;dev))) return FALSE; <br> <br>    info-&gt;dev-&gt;SetDither(old_dither); <br>    info-&gt;dev-&gt;SetQuality(old_quality); <br>    info-&gt;dev-&gt;SetShades(old_shades); <br>    width = info-&gt;dev-&gt;GetWidth(); <br>    height = info-&gt;dev-&gt;GetHeight(); <br>    if (!D3DRM_SUCCEED(lpD3DRM-&gt;CreateViewport(info-&gt;dev, info-&gt;camera, 0, 0, width, height, &amp;info-&gt;view))) return FALSE; <br>    info-&gt;view-&gt;SetBack(D3DVAL(400.0)); <br>        return TRUE; <br>} <br> <br>/* <br> * Place an object in front of the camera. <br> */ <br>static void PlaceMesh(LPDIRECT3DRMMESHBUILDER mesh, AppInfo *info) <br>{ <br>    LPDIRECT3DRMFRAME frame; <br> <br>    if (!D3DRM_SUCCEED(lpD3DRM-&gt;CreateFrame(info-&gt;scene, &amp;frame))) return; <br>    frame-&gt;AddVisual(mesh); <br>    frame-&gt;SetPosition(info-&gt;camera, D3DVAL(0.0), D3DVAL(0.0), D3DVAL(15.0)); <br>    frame-&gt;Release(); <br>} <br> <br>HRESULT __cdecl loadTextures(char *name, void *arg, LPDIRECT3DRMTEXTURE *tex) <br>{ <br>    char* ext = LSTRRCHR(name, (int)'.'); <br> <br>    if (ext &amp;&amp; !lstrcmpi(ext, ".ppm")) <br>        if (D3DRM_SUCCEED(lpD3DRM-&gt;LoadTexture(name, tex))) return 0; <br>    return -1; <br>} <br> <br>/* <br>** Finds the last occurance of bChar in a null-terminated string, good for finding a pointer to the extension of a filename <br>*/ <br>char* LSTRRCHR( const char* lpString, int bChar ) <br>{ <br>    if( lpString != NULL ) <br>    { <br>        const char*     lpBegin; <br> <br>        lpBegin = lpString; <br> <br>        while( *lpString != 0 ) <br>        { <br>            lpString++; <br>        } <br> <br>        while( 1 ) <br>        { <br>            if( *lpString == bChar ) <br>            { <br>                return (char*)lpString; <br>            } <br>             <br>            if( lpString == lpBegin ) <br>            { <br>                break; <br>            } <br> <br>            lpString--; <br>        } <br>    } <br> <br>    return NULL; <br>} /* LSTRRCHR */ <br> <br> <br>/* <br>** Strange little function to pick a color from a table using standardized Windows stuff <br>*/ <br> <br>int ChooseNewColor(HWND win, D3DCOLOR* current) <br>{ <br>    CHOOSECOLOR cc; <br>    COLORREF clr; <br>    COLORREF aclrCust[16]; <br>    int i; <br> <br>    for (i = 0; i &lt; 16; i++) <br>        aclrCust[i] = RGB(255, 255, 255); <br> <br>    clr = <br>        RGB <br>        (   (int) (255 * D3DRMColorGetRed(*current)), <br>            (int) (255 * D3DRMColorGetGreen(*current)), <br>            (int) (255 * D3DRMColorGetBlue(*current)) <br>        ); <br> <br>    memset(&amp;cc, 0, sizeof(CHOOSECOLOR)); <br>    cc.lStructSize = sizeof(CHOOSECOLOR); <br>    cc.hwndOwner = win; <br>    cc.rgbResult = clr; <br>    cc.lpCustColors = aclrCust; <br>    cc.Flags = CC_RGBINIT|CC_FULLOPEN; <br> <br>    if (ChooseColor(&amp;cc)) <br>    {   *current = <br>            D3DRMCreateColorRGB <br>            (   D3DVAL(GetRValue(cc.rgbResult) / D3DVAL(255.0)), <br>                D3DVAL(GetGValue(cc.rgbResult) / D3DVAL(255.0)), <br>                D3DVAL(GetBValue(cc.rgbResult) / D3DVAL(255.0)) <br>            ); <br>        return TRUE; <br>    } <br>    else return FALSE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
