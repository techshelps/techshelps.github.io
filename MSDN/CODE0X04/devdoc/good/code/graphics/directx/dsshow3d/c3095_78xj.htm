<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DEBUG.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3097"></a>DEBUG.C</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1995-1997 Microsoft Corporation. All Rights Reserved. <br> * <br> *  File:debug.c <br> *  Content:debug code <br> * <br> ***************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;stdarg.h&gt; <br>#include &lt;dsound.h&gt; <br>#include "debug.h" <br> <br>#if defined(DEBUG) || defined(_DEBUG) <br> <br> <br>// <br>//  since we don't UNICODE our debugging messages, use the ASCII entry <br>//  points regardless of how we are compiled. <br>// <br>#ifdef _WIN32 <br>    #include &lt;wchar.h&gt; <br>#else <br>    #define lstrcatA            lstrcat <br>    #define lstrlenA            lstrlen <br>    #define GetProfileIntA      GetProfileInt <br>    #define OutputDebugStringA  OutputDebugString <br>    #define wsprintfA           wsprintf <br>    #define MessageBoxA         MessageBox <br>#endif <br> <br>// <br>// <br>// <br>BOOL    __gfDbgEnabled          = TRUE;         // master enable <br>UINT    __guDbgLevel            = 0;            // current debug level <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  void DbgVPrintF <br>//   <br>//  Description: <br>//   <br>//   <br>//  Arguments: <br>//      LPSTR szFormat: <br>//   <br>//      va_list va: <br>//   <br>//  Return (void): <br>//      No value is returned. <br>//   <br>//--------------------------------------------------------------------------; <br> <br>void FAR CDECL DbgVPrintF <br>( <br>    LPSTR                   szFormat, <br>    va_list                 va <br>) <br>{ <br>    char                ach[DEBUG_MAX_LINE_LEN]; <br>    BOOL                fDebugBreak = FALSE; <br>    BOOL                fPrefix     = TRUE; <br>    BOOL                fCRLF       = TRUE; <br> <br>    ach[0] = '\0'; <br> <br>    for (;;) <br>    { <br>        switch (*szFormat) <br>        { <br>            case '!': <br>                fDebugBreak = TRUE; <br>                szFormat++; <br>                continue; <br> <br>            case '`': <br>                fPrefix = FALSE; <br>                szFormat++; <br>                continue; <br> <br>            case '~': <br>                fCRLF = FALSE; <br>                szFormat++; <br>                continue; <br>        } <br> <br>        break; <br>    } <br> <br>    if (fDebugBreak) <br>    { <br>        ach[0] = '\007'; <br>        ach[1] = '\0'; <br>    } <br> <br>    if (fPrefix) <br>    { <br>        lstrcatA(ach, DEBUG_MODULE_NAME ": "); <br>    } <br> <br>#ifdef _WIN32 <br>    wvsprintfA(ach + lstrlenA(ach), szFormat, va); <br>#else <br>    wvsprintf(ach + lstrlenA(ach), szFormat, (LPSTR)va); <br>#endif <br> <br>    if (fCRLF) <br>    { <br>        lstrcatA(ach, "\r\n"); <br>    } <br> <br>    OutputDebugStringA(ach); <br> <br>    if (fDebugBreak) <br>    { <br>        DebugBreak(); <br>    } <br>} // DbgVPrintF() <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  void dprintf <br>//   <br>//  Description: <br>//      dprintf() is called by the DPF() macro if DEBUG is defined at compile <br>//      time. It is recommended that you only use the DPF() macro to call <br>//      this function--so you don't have to put #ifdef DEBUG around all <br>//      of your code. <br>//       <br>//  Arguments: <br>//      UINT uDbgLevel: <br>//   <br>//      LPSTR szFormat: <br>//   <br>//  Return (void): <br>//      No value is returned. <br>// <br>//--------------------------------------------------------------------------; <br> <br>void FAR CDECL dprintf <br>( <br>    UINT                    uDbgLevel, <br>    LPSTR                   szFormat, <br>    ... <br>) <br>{ <br>    va_list va; <br> <br>    if (!__gfDbgEnabled || (__guDbgLevel &lt; uDbgLevel)) <br>        return; <br> <br>    va_start(va, szFormat); <br>    DbgVPrintF(szFormat, va); <br>    va_end(va); <br>} // dprintf() <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  BOOL DbgEnable <br>//   <br>//  Description: <br>//   <br>//   <br>//  Arguments: <br>//      BOOL fEnable: <br>//   <br>//  Return (BOOL): <br>//      Returns the previous debugging state. <br>//   <br>//--------------------------------------------------------------------------; <br> <br>BOOL WINAPI DbgEnable <br>( <br>    BOOL                    fEnable <br>) <br>{ <br>    BOOL                fOldState; <br> <br>    fOldState      = __gfDbgEnabled; <br>    __gfDbgEnabled = fEnable; <br> <br>    return (fOldState); <br>} // DbgEnable() <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  UINT DbgSetLevel <br>//   <br>//  Description: <br>//   <br>//   <br>//  Arguments: <br>//      UINT uLevel: <br>//   <br>//  Return (UINT): <br>//      Returns the previous debugging level. <br>//   <br>//--------------------------------------------------------------------------; <br> <br>UINT WINAPI DbgSetLevel <br>( <br>    UINT                    uLevel <br>) <br>{ <br>    UINT                uOldLevel; <br> <br>    uOldLevel    = __guDbgLevel; <br>    __guDbgLevel = uLevel; <br> <br>    return (uOldLevel); <br>} // DbgSetLevel() <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  UINT DbgGetLevel <br>//   <br>//  Description: <br>//   <br>//   <br>//  Arguments: <br>//      None. <br>//   <br>//  Return (UINT): <br>//      Returns the current debugging level. <br>//   <br>//--------------------------------------------------------------------------; <br> <br>UINT WINAPI DbgGetLevel <br>( <br>    void <br>) <br>{ <br>    return (__guDbgLevel); <br>} // DbgGetLevel() <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  UINT DbgInitialize <br>//   <br>//  Description: <br>//   <br>//   <br>//  Arguments: <br>//      BOOL fEnable: <br>//   <br>//  Return (UINT): <br>//      Returns the debugging level that was set. <br>//   <br>//--------------------------------------------------------------------------; <br> <br>UINT WINAPI DbgInitialize <br>( <br>    BOOL                    fEnable <br>) <br>{ <br>    UINT                uLevel; <br> <br>    uLevel = GetProfileIntA(DEBUG_SECTION, DEBUG_MODULE_NAME, (UINT)-1); <br>    if ((UINT)-1 == uLevel) <br>    { <br>        // <br>        //  if the debug key is not present, then force debug output to <br>        //  be disabled. this way running a debug version of a component <br>        //  on a non-debugging machine will not generate output unless <br>        //  the debug key exists. <br>        // <br>        uLevel  = 0; <br>        fEnable = FALSE; <br>    } <br> <br>    DbgSetLevel(uLevel); <br>    DbgEnable(fEnable); <br> <br>    return (__guDbgLevel); <br>} // DbgInitialize() <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  void _Assert <br>//   <br>//  Description: <br>//      This routine is called if the ASSERT macro (defined in debug.h) <br>//      tests and expression that evaluates to FALSE.  This routine  <br>//      displays an "assertion failed" message box allowing the user to <br>//      abort the program, enter the debugger (the "retry" button), or <br>//      ignore the assertion and continue executing.  The message box <br>//      displays the file name and line number of the _Assert() call. <br>//   <br>//  Arguments: <br>//      char *  szFile: Filename where assertion occurred. <br>//      int     iLine:  Line number of assertion. <br>//   <br>//--------------------------------------------------------------------------; <br> <br>#ifndef _WIN32 <br>#pragma warning(disable:4704) <br>#endif <br> <br>void WINAPI _Assert <br>( <br>    char *  szFile, <br>    int     iLine <br>) <br>{ <br>    static char     ach[300];       // debug output (avoid stack overflow) <br>    int            id; <br>#ifndef _WIN32 <br>    int             iExitCode; <br>#endif <br> <br>    wsprintfA(ach, "Assertion failed in file %s, line %d.  [Press RETRY to debug.]", (LPSTR)szFile, iLine); <br> <br>    id = MessageBoxA(NULL, ach, "Assertion Failed", <br>            MB_SYSTEMMODAL | MB_ICONHAND | MB_ABORTRETRYIGNORE ); <br> <br>switch (id) <br>{ <br> <br>case IDABORT:               // Kill the application. <br>#ifndef _WIN32 <br>        iExitCode = 0; <br>        _asm <br>        { <br>        movah, 4Ch <br>        moval, BYTE PTR iExitCode <br>        int     21h <br>        } <br>#else <br>        FatalAppExit(0, TEXT("Good Bye")); <br>#endif // WIN16 <br>break; <br> <br>case IDRETRY:               // Break into the debugger. <br>DebugBreak(); <br>break; <br> <br>case IDIGNORE:              // Ignore assertion, continue executing. <br>break; <br>} <br>} // _Assert <br> <br>#ifndef _WIN32 <br>#pragma warning(default:4704) <br>#endif <br> <br>#endif // #if defined(DEBUG) || defined(_DEBUG) <br> <br>// Silly little function gives meaningful error messages from HRESULT's <br>LPSTR TranslateDSError( HRESULT hr ) <br>    { <br>    switch( hr ) <br>{ <br>case DSERR_ALLOCATED: <br>    return "DSERR_ALLOCATED"; <br> <br>case DSERR_CONTROLUNAVAIL: <br>    return "DSERR_CONTROLUNAVAIL"; <br> <br>case DSERR_INVALIDPARAM: <br>    return "DSERR_INVALIDPARAM"; <br> <br>case DSERR_INVALIDCALL: <br>    return "DSERR_INVALIDCALL"; <br> <br>case DSERR_GENERIC: <br>    return "DSERR_GENERIC"; <br> <br>case DSERR_PRIOLEVELNEEDED: <br>    return "DSERR_PRIOLEVELNEEDED"; <br> <br>case DSERR_OUTOFMEMORY: <br>    return "DSERR_OUTOFMEMORY"; <br> <br>case DSERR_BADFORMAT: <br>    return "DSERR_BADFORMAT"; <br> <br>case DSERR_UNSUPPORTED: <br>    return "DSERR_UNSUPPORTED"; <br> <br>case DSERR_NODRIVER: <br>    return "DSERR_NODRIVER"; <br> <br>case DSERR_ALREADYINITIALIZED: <br>    return "DSERR_ALREADYINITIALIZED"; <br> <br>case DSERR_NOAGGREGATION: <br>    return "DSERR_NOAGGREGATION"; <br> <br>case DSERR_BUFFERLOST: <br>    return "DSERR_BUFFERLOST"; <br> <br>case DSERR_OTHERAPPHASPRIO: <br>    return "DSERR_OTHERAPPHASPRIO"; <br> <br>case DSERR_UNINITIALIZED: <br>    return "DSERR_UNINITIALIZED"; <br> <br>default: <br>    return "Unknown HRESULT"; <br>} <br>    } <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
