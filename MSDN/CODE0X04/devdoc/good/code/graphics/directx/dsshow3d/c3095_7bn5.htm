<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DSSHOW3D.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3101"></a>DSSHOW3D.CPP</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1995-1997 Microsoft Corporation. All Rights Reserved. <br> * <br> *  File:       DSShow3d.c <br> *  Content:    Direct Sound show-off, including 3D Sound. <br> * <br> * <br> ***************************************************************************/ <br> <br>//#pragma warning( disable: 4102 4101 ) <br> <br>#define INITGUID <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;commctrl.h&gt; <br>#include &lt;commdlg.h&gt; <br>#include &lt;cguid.h&gt; <br>#include &lt;shlobj.h&gt; // for browseinfo <br>#include &lt;mmsystem.h&gt; <br>#include &lt;mmreg.h&gt; <br>#include &lt;msacm.h&gt; <br>#include &lt;dsound.h&gt; <br> <br>#include "DSShow3D.h" <br>#define INIT_GVARS <br>#include "GVars.h" <br> <br>#include "MainWnd.h" <br>#include "FileInfo.h" <br> <br>#include "wave.h" <br>#include "debug.h" <br> <br>static TCHAR szOpenStartDir[MAX_PATH]; <br>static BOOL gfDisable3D = FALSE; <br> <br>BOOL IsPentiumOrBetter(void); <br> <br>// Format codes used to compactly represent each possible output format <br>// <br>// The code is: FFCBB where... <br>// <br>//    FF -&gt; Frequency 8=8000, 11=11025, 22=22050, 44=44100 <br>//    C  -&gt; # of channels (1 or 2) <br>//    BB -&gt; Bits 08 is 8-bit, 16 is 16-bit <br>// <br>// Use the FormatCodeToWFX() function to set a WAVEFORMATEX structure <br>// based on a format code, or FormatCodeToText() to get a text string <br>// representing the format. <br>// <br> <br>#define FC_GETFREQCODE(fc)((fc) / 1000) <br>#define FC_GETBITS(fc)((fc) % 100) <br>#define FC_GETCHANNELS(fc)(((fc) % 1000) / 100) <br> <br>// Functions limited in scope to this file <br> <br>static BOOL InitializeDSound( void ); <br>static void FreeDSound( void ); <br>static BOOL InitInstance( HINSTANCE, LPTSTR, int ); <br>static BOOL InitPrimarySoundBuffer( void ); <br>static void GetMediaPath( LPTSTR, int ); <br>static BOOL LoadRegistrySettings( void ); <br>static BOOL SaveRegistrySettings( void ); <br>static BOOL ParseCommandLine( LPTSTR lpszCmdLine ); <br>static BOOL fMatchToken( PSTR pszString, PSTR pszDatum, int cchLen ); <br>static BOOL fGetToken( PSTR pszStart, PSTR *ppszRet, int *pcchRet ); <br> <br> <br>/* InitializeDSound() <br> * <br> *    Initialize the DirectSound object and other stuff we'll use like the <br> * primary buffer and 3D listener object. <br> */ <br>BOOL InitializeDSound( void ) <br>    { <br>    HRESULT hr; <br> <br>    hr = CoCreateInstance( CLSID_DirectSound, NULL, CLSCTX_INPROC_SERVER, <br>IID_IDirectSound, (void**)&amp;gpds ); <br> <br>    if (FAILED(hr) || (NULL == gpds)) <br>{ <br>DPF( 0, "Could not create a DSound object (%s)", TranslateDSError(hr)); <br>MessageBox( AppWnd.GetHwnd(), "Unable to get a DirectSound object", <br>    "COM Failure", MB_OK | MB_ICONSTOP ); <br>goto ID_ExitError; <br>} <br>    DPF( 2, "Got an IDirectSound object" ); <br> <br>    if( grs.fDefaultDevice ) <br>{ <br>DPF( 2, "Using default device as first choice" ); <br>hr = gpds-&gt;Initialize(NULL ); <br>} <br>    else <br>{ <br>if( FAILED( hr = gpds-&gt;Initialize( &amp;grs.guPreferredDevice ))) <br>    { <br>    DPF( 0, "Initialize failed on preferred device, using default" ); <br>    if( IDNO == MessageBox( GetActiveWindow(), <br>"Unable to use preferred device. Use default instead?", <br>gszAppName, MB_YESNO )) <br>{ <br>DPF( 2, "User chose not to use default device instead" ); <br>goto ID_ExitReleaseDS; <br>} <br>    else <br>{ <br>DPF( 2, "Falling back to default device" ); <br>hr = gpds-&gt;Initialize( NULL ); <br>} <br>    } <br>} <br>    if (FAILED(hr)) <br>{ <br>DPF( 0, "Failed Initialize() on IDirectSound object (%s)", TranslateDSError(hr)); <br>MessageBox( AppWnd.GetHwnd(), "Could not initialize DirectSound object", <br>    gszAppName, MB_OK | MB_ICONSTOP ); <br>goto ID_ExitReleaseDS; <br>} <br> <br>    if( grs.fUseExclusiveMode ) <br>{ <br>hr = gpds-&gt;SetCooperativeLevel( AppWnd.GetHwnd(), DSSCL_EXCLUSIVE); <br>        DPF( 3, "Received DSSCL_EXCLUSIVE" ); <br>} <br>    else <br>{ <br>hr = gpds-&gt;SetCooperativeLevel( AppWnd.GetHwnd(), DSSCL_PRIORITY); <br>        DPF( 3, "Received DSSCL_PRIORITY" ); <br>} <br>    if (FAILED(hr)) <br>{ <br>DPF( 0, "Couldn't SetCooperativeLevel() (%s)", TranslateDSError(hr)); <br>MessageBox( AppWnd.GetHwnd(), "Could not SetCooperativeLevel()", <br>    gszAppName, MB_OK | MB_ICONSTOP ); <br>goto ID_ExitReleaseDS; <br>} <br> <br>    DPF( 3, "Creating Primary Buffer" ); <br> <br>    if( !InitPrimarySoundBuffer()) <br>{ <br>DPF( 0, "Failed on call to InitPrimarySoundBuffer()" ); <br>goto ID_ExitReleaseDS; <br>} <br> <br>    // Return SUCCESS <br>    return TRUE; <br> <br>ID_ExitReleaseDS: <br>    // The InitPrimarySoundBuffer() call should have cleaned up <br>    // after itself if it failed <br> <br>    ASSERT( NULL == gp3DListener ); <br>    ASSERT( NULL == gpdsbPrimary ); <br> <br>    if( NULL != gpds ) <br>{ <br>gpds-&gt;Release(); <br>gpds = NULL; <br>} <br> <br>ID_ExitError: <br>    return FALSE; <br>    } <br> <br> <br>void FreeDSound() <br>    { <br>    if( NULL != gpdsbPrimary ) <br>{ <br>gpdsbPrimary-&gt;Stop(); <br>gpdsbPrimary-&gt;Release(); <br>gpdsbPrimary = NULL; <br>} <br>    if( NULL != gp3DListener ) <br>{ <br>gp3DListener-&gt;Release(); <br>gp3DListener = NULL; <br>} <br>    if( NULL != gpds ) <br>{ <br>gpds-&gt;Release(); <br>gpds = NULL; <br>} <br>    } <br> <br> <br>/* InitInstance() <br> * <br> *    This function is responsible for all initialization that must occur <br> * when a new instance of our application is started. <br> */ <br>BOOL InitInstance( HINSTANCE hInstance, LPTSTR lpszCommandLine, int cmdShow ) <br>    { <br>    WNDCLASS    myClass; <br> <br>    myClass.hCursor             = LoadCursor(NULL, IDC_ARROW); <br>    myClass.hIcon               = LoadIcon( hInstance, MAKEINTRESOURCE(IDI_SPEAKER_RGB_3D)); <br>    myClass.lpszMenuName        = MAKEINTRESOURCE(IDR_MAINMENU); <br>    myClass.lpszClassName       = (LPTSTR)gszAppWndClass; <br>    myClass.hbrBackground       = (HBRUSH)(COLOR_APPWORKSPACE + 1); <br>    myClass.hInstance           = hInstance; <br>    myClass.style               = CS_HREDRAW | CS_VREDRAW; <br>    myClass.lpfnWndProc         = MainWndProc; <br>    myClass.cbClsExtra          = 0; <br>    myClass.cbWndExtra          = 0; <br> <br>    if (!RegisterClass( &amp;myClass )) <br>       return FALSE; <br> <br>    // Load the current registry settings <br>    LoadRegistrySettings(); <br>    gdwOutputFormat = grs.dwPreferredFormat; <br> <br>    if( !AppWnd.Create()) <br>goto II_ExitError; <br> <br>    AppWnd.ShowWindow( cmdShow ); <br>    AppWnd.UpdateWindow(); <br> <br>    /* Continue doing other initialization stuff */ <br> <br>    // Setup the timer... <br>    if ((gdwTimer = SetTimer(AppWnd.GetHwnd(), 1, TIMERPERIOD, NULL)) == 0) <br>{ <br>MessageBox(AppWnd.GetHwnd(), "Cannot allocate timer, aborting", gszAppCaption, <br>MB_OK|MB_ICONSTOP); <br>goto II_ExitError; <br>} <br> <br>    // Get the largest waveformatex structure. <br>    if (MMSYSERR_NOERROR != acmMetrics(NULL, ACM_METRIC_MAX_SIZE_FORMAT, <br>    &amp;gcbMaxWaveFormatSize)) <br>        { <br>MessageBox(AppWnd.GetHwnd(), "ACM Metrics failed, aborting", gszAppCaption, <br>   MB_OK|MB_ICONSTOP); <br>goto II_ExitError; <br>} <br> <br>    // Initialize the COM subsystem and create our DirectSound stuff <br> <br>    if (!SUCCEEDED(CoInitialize(NULL))) <br>{ <br>MessageBox( AppWnd.GetHwnd(), "Failed to initialize COM library", <br>gszAppCaption, MB_OK | MB_ICONSTOP); <br>goto II_ExitError; <br>} <br>    else <br>gfCOMInitialized = TRUE; <br> <br>    // Initialize the DirectSound global interfaces <br>    if( !InitializeDSound()) <br>goto II_ExitShutdownCOM; <br> <br>    if( !ParseCommandLine( lpszCommandLine )) <br>goto II_ExitFreeDSound; <br> <br>    return TRUE;    // TRUE indicates success <br> <br> <br>II_ExitFreeDSound: <br>    FreeDSound(); <br> <br>II_ExitShutdownCOM: <br>    if( gfCOMInitialized ) <br>{ <br>DPF( 0, "Calling CoUninitialize from InitInstance error cleanup" ); <br>CoUninitialize(); <br>} <br> <br>II_ExitError: <br> <br>    return FALSE;   // FALSE indicates failure on initialization <br>    }// InitInstance() <br> <br> <br>/* WinMain() <br> * <br> *   Main entry point for this program's execution.  Everything starts here. <br> */ <br>int PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, <br>LPTSTR lpszCmdLine, int cmdShow) <br>    { <br>    MSG   msg; <br> <br>    DbgInitialize( TRUE ); <br> <br>    InitCommonControls(); <br> <br>    // Save instance handle <br>    ghInst = hInstance; <br> <br>    if (!InitInstance(hInstance, lpszCmdLine, cmdShow)) <br>return 0; <br> <br>    /* Polling messages from event queue */ <br>    while (GetMessage((LPMSG)&amp;msg, NULL, 0, 0)) <br>{ <br>// Only Translate and Dispatch the message if it's not going <br>// to one of our many modeless dialog windows <br>if( !IsDialogMessage( ghwndListener, &amp;msg ) <br>    &amp;&amp; (NULL == ghDlgActive || !IsDialogMessage( ghDlgActive, &amp;msg ))) <br>    { <br>    TranslateMessage((LPMSG)&amp;msg); <br>    DispatchMessage((LPMSG)&amp;msg); <br>    } <br>} <br> <br>    UnregisterClass(gszAppWndClass, hInstance); <br>    return (int)msg.wParam; <br>    }// WinMain() <br> <br> <br>/* InitPrimarySoundBuffer() <br> * <br> *    Creates and initializes the primary sound buffer for the application. <br> * We need the primary buffer in order to get the 3D listener interface and <br> * also to select output format type. <br> */ <br>BOOL InitPrimarySoundBuffer( void ) <br>    { <br>    HRESULT    hr; <br>    DSBUFFERDESC    dsbd; <br>    int    nCurFormat; <br> <br>    ZeroMemory( &amp;dsbd, sizeof(DSBUFFERDESC)); <br>     <br>    gpwfxFormat = (LPWAVEFORMATEX)GlobalAlloc(GPTR, sizeof(WAVEFORMATEX)); <br>    if( NULL == gpwfxFormat ) <br>return FALSE; <br> <br>    ZeroMemory( gpwfxFormat, sizeof(WAVEFORMATEX)); <br> <br>    gpwfxFormat-&gt;wFormatTag = WAVE_FORMAT_PCM; <br> <br>    FormatCodeToWFX( gdwOutputFormat, gpwfxFormat ); <br>    DPF( 2, "Initial format code: %lu", gdwOutputFormat ); <br> <br>    dsbd.dwSize = sizeof(DSBUFFERDESC); <br>    dsbd.dwFlags = DSBCAPS_CTRL3D | DSBCAPS_PRIMARYBUFFER; <br> <br>    if( FAILED( hr = gpds-&gt;CreateSoundBuffer( &amp;dsbd, &amp;gpdsbPrimary, NULL ))) <br>{ <br>DPF( 0, "Couldn't create primary buffer (%s)", TranslateDSError(hr)); <br>goto IPSB_ExitError; <br>} <br> <br>    if( FAILED( hr = gpdsbPrimary-&gt;SetFormat( gpwfxFormat ))) <br>{ <br>DisableFormatCode( gdwOutputFormat ); <br> <br>// If we couldn't load the desired format, then try everything starting <br>// at really high quality, and degrading to 8M8. <br>nCurFormat = 0; <br>DPF( 2, "Unable to SetFormat() preferred format to %lu", gdwOutputFormat ); <br> <br>while( FAILED( hr ) &amp;&amp; nCurFormat &lt; NUM_FORMATENTRIES ) <br>{ <br>gdwOutputFormat = aFormatOrder[nCurFormat]; <br>FormatCodeToWFX( gdwOutputFormat, gpwfxFormat ); <br>DPF( 2, "Trying format code: %lu", gdwOutputFormat ); <br> <br>hr = gpdsbPrimary-&gt;SetFormat( gpwfxFormat ); <br>if( FAILED(hr)) <br>{ <br>DisableFormatCode( gdwOutputFormat ); <br>DPF( 2, "Return from SetFormat on primary buffer = %s", TranslateDSError(hr)); <br>} <br>else <br>{ <br>EnableFormatCode( gdwOutputFormat ); <br>DPF( 2, "Succeeded on SetFormat() for code %lu", gdwOutputFormat ); <br>} <br> <br>nCurFormat++; <br>}//while <br>} <br> <br>    if( FAILED( hr )) <br>{ <br>DPF( 0, "Failed SetFormat() on all formats!" ); <br>goto IPSB_ExitError; <br>} <br> <br>    if( FAILED( hr = gpdsbPrimary-&gt;QueryInterface( IID_IDirectSound3DListener, <br>(void**)&amp;gp3DListener))) <br>{ <br>DPF( 0, "Couldn't QI primary buffer for 3D listener interface (%s)", TranslateDSError(hr)); <br>goto IPSB_ExitError; <br>} <br>    if( FAILED( hr = gpdsbPrimary-&gt;Play( 0, 0, DSBPLAY_LOOPING ))) <br>{ <br>DPF( 0, "Couldn't play primary buffer (%s)", TranslateDSError(hr)); <br>goto IPSB_ExitRelease; <br>} <br> <br>    return TRUE; <br> <br>IPSB_ExitRelease: <br>    if( gp3DListener ) <br>{ <br>DPF( 0, "Releasing 3D Listener in InitPrimarySoundBuffer() error cleanup" ); <br>gp3DListener-&gt;Release(); <br>gp3DListener = NULL; <br>} <br>    if( gpdsbPrimary ) <br>{ <br>DPF( 0, "Releasing Primary in InitPrimarySoundBuffer() error cleanup" ); <br>gpdsbPrimary-&gt;Stop(); <br>gpdsbPrimary-&gt;Release(); <br>gpdsbPrimary = NULL; <br>} <br> <br>IPSB_ExitError: <br>    return FALSE; <br>    } <br> <br> <br>/*  This will pop up the open file dialog and allow the user to pick one file. <br> <br>    Input: <br>hWnd        -   Handle of parent window. <br>pszFileName -   String to store filename in, must be &gt;= MAX_PATH long. <br> <br> <br>    Output: <br>TRUE if a file was picked successfully or FALSE if the user didn't <br>pick a file) <br> <br> */ <br>BOOL OpenFileDialog( HWND hWnd, LPTSTR pszFileName, <br>int *nFileName, LPDWORD lpdwFlags ) <br>    { <br>    BOOL            fReturn, <br>    fValid; <br>    OPENFILENAME    ofn; <br> <br>    pszFileName[0]          = 0; <br> <br>    ofn.lStructSize         = sizeof(ofn); <br>    ofn.hwndOwner           = hWnd; <br>    ofn.hInstance           = ghInst; <br>    ofn.lpstrFilter         = "Wave Files\0*.wav\0All Files\0*.*\0\0"; <br>    ofn.lpstrCustomFilter   = NULL; <br>    ofn.nMaxCustFilter      = 0; <br>    ofn.nFilterIndex        = 1; <br>    ofn.lpstrFile           = pszFileName; <br>    ofn.nMaxFile            = MAX_PATH; <br>    ofn.lpstrFileTitle      = NULL; <br>    ofn.nMaxFileTitle       = 0; <br>    ofn.lpstrInitialDir     = grs.szInitialDir; <br>    ofn.lpstrTitle          = "File Open"; <br>    ofn.Flags               = OFN_FILEMUSTEXIST | OFN_EXPLORER <br>                                | OFN_ENABLETEMPLATE | OFN_ENABLEHOOK <br>| OFN_HIDEREADONLY; <br>    ofn.nFileOffset         = 0; <br>    ofn.nFileExtension      = 0; <br>    ofn.lpstrDefExt         = "wav"; <br>    ofn.lCustData           = (LONG)lpdwFlags; <br>    ofn.lpfnHook            = FileOpenCustomTemplateDlgProc; <br>    ofn.lpTemplateName      = MAKEINTRESOURCE(IDD_FILEOPEN_NEST); <br> <br>    fValid = FALSE; <br>    do <br>    { <br>    if( fReturn = GetOpenFileName( &amp;ofn )) <br>{ <br>fValid = IsValidWave( pszFileName ); <br>if( !fValid ) <br>MessageBox( hWnd, "Wave files must be PCM format!", <br>    "Invalid Wave File", MB_OK|MB_ICONSTOP ); <br>else <br>*nFileName = ofn.nFileOffset; <br>} <br>    else <br>fValid = TRUE;         // Force break out of loop. <br>    } while( !fValid ); <br> <br>    return fReturn; <br>    } <br> <br>/* <br> * <br> * <br>This function will determine if the filename passed <br>    in is a valid wave for this <br>    app, that is a PCM wave. <br> <br>    Input: <br>pszFileName -   FileName to check. <br> <br>    Output: <br>FALSE if not a valid wave, TRUE if it is. <br> <br>*/ <br>BOOL IsValidWave( LPTSTR pszFileName ) <br>    { <br>    BOOL    fReturn = FALSE; <br>    int             nError = 0; <br>    HMMIO           hmmio; <br>    MMCKINFO        mmck; <br>    WAVEFORMATEX    *pwfx; <br> <br>    if ((nError = WaveOpenFile(pszFileName, &amp;hmmio, &amp;pwfx, &amp;mmck)) != 0) <br>{ <br>goto ERROR_IN_ROUTINE; <br>} <br> <br>    if (pwfx-&gt;wFormatTag != WAVE_FORMAT_PCM) <br>{ <br>goto ERROR_IN_ROUTINE; <br>} <br> <br>    WaveCloseReadFile(&amp;hmmio, &amp;pwfx); <br> <br>    fReturn = TRUE; <br> <br>ERROR_IN_ROUTINE: <br>    return fReturn; <br>    } <br> <br> <br>/* AboutDlgProc() <br> * <br> *    Standard dialog procedure for the About box.  As simple as can be. <br> */ <br>BOOL CALLBACK AboutDlgProc( HWND hWnd, UINT uMsg, <br>    WPARAM wParam, LPARAM lParam ) <br>    { <br>    switch(uMsg) <br>{ <br>case WM_INITDIALOG: <br>    break; <br> <br>case WM_COMMAND: <br>    switch(wParam) <br>    { <br>    case ID_OK: <br>PostMessage(hWnd, WM_CLOSE, 0, 0); <br>break; <br> <br>    default: <br>break; <br> <br>    } <br>    break; <br> <br>case WM_CLOSE: <br>    EndDialog(hWnd, 0); <br>    break; <br> <br>default: <br>    return FALSE; <br>    break; <br> <br>} <br> <br>    return TRUE; <br>} <br> <br> <br>/* FileOpenCustomTemplateDlgProc() <br> * <br> * This "hook procedure" is called by the common dialog code for certain <br> *   events that may occur during the life of our nested dialog structure. <br> * We nest the Explorer style dialog inside our file open dialog so we <br> *   can add a check box for stick buffers. <br> */ <br>UINT CALLBACK FileOpenCustomTemplateDlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam ) <br>    { <br>    static LPOPENFILENAME   lpofn = NULL; <br>    static HWND    hStickyRadio, h3DCheck, hLocalRadio, hGlobalRadio; <br>    static HWND        hGetPosRadio, hGetPos2Radio, hMuteAtMaxDist, hNotifyCheck; <br> <br>    switch( message ) <br>    { <br>    case WM_INITDIALOG: <br>{ <br>        lpofn = (LPOPENFILENAME)lParam; <br> <br>h3DCheck = GetDlgItem( hDlg, IDC_FONEST_3D ); <br>hLocalRadio = GetDlgItem( hDlg, IDC_FONEST_LOCAL_RADIO ); <br>hStickyRadio = GetDlgItem( hDlg, IDC_FONEST_STICKY_RADIO ); <br>hGlobalRadio = GetDlgItem( hDlg, IDC_FONEST_GLOBAL_RADIO ); <br>hGetPosRadio = GetDlgItem( hDlg, IDC_FONEST_GETPOS_RADIO ); <br>hGetPos2Radio = GetDlgItem( hDlg, IDC_FONEST_GETPOS2_RADIO ); <br>hNotifyCheck = GetDlgItem(hDlg, IDC_FONEST_NOTIFYCHECK); <br>hMuteAtMaxDist = GetDlgItem(hDlg, IDC_FONEST_MUTEATMAX); <br> <br>Button_SetCheck( hGetPos2Radio, TRUE ); <br> <br>if( grs.dwDefaultFocusFlag &amp; DSBCAPS_STICKYFOCUS ) <br>Button_SetCheck( hStickyRadio, TRUE ); <br>else if( grs.dwDefaultFocusFlag &amp; DSBCAPS_GLOBALFOCUS ) <br>Button_SetCheck( hGlobalRadio, TRUE ); <br>else <br>{ <br>ASSERT( grs.dwDefaultFocusFlag == 0 ); <br>Button_SetCheck( hLocalRadio, TRUE ); <br>} <br> <br>if (gfDisable3D) <br>{ <br>grs.fOpen3D = FALSE; <br>} <br> <br>Static_Enable(h3DCheck, !gfDisable3D); <br>Button_SetCheck( h3DCheck, grs.fOpen3D ); <br> <br>Static_Enable(hMuteAtMaxDist, Button_GetCheck(h3DCheck)); <br> <br>*((LPDWORD)lpofn-&gt;lCustData) = 0; <br>} <br>    return TRUE; <br> <br> <br>case WM_COMMAND: <br>if(LOWORD(wParam) == IDC_FONEST_3D) <br>{ <br>Static_Enable(hMuteAtMaxDist, Button_GetCheck(h3DCheck)); <br>} <br>return TRUE; <br> <br> <br>    case WM_NOTIFY: <br>        switch(((LPOFNOTIFY)lParam)-&gt;hdr.code) <br>        { <br>        case CDN_SELCHANGE: <br>            /* Use this area to process anything that must be updated when the <br>             * user changes the selection in the Common Dialog Box. <br>             *   NOTE: Provided only for informational purposes <br>             */ <br>            return FALSE; <br> <br>        case CDN_FILEOK: <br>            /* We can do lots of things in this notification message.  The most <br>             * important is that we can decide whether the Common Dialog call <br>             * will go through or whether it will fail.  I decided to handle <br>             * the checkbox control in this one place versus 4 others... <br>             */ <br>            ASSERT( lpofn != NULL ); <br>    /* Set flags to match the current state of the check box controls */ <br> <br>    /* Use normal GetPosition */ <br>    *((LPDWORD)lpofn-&gt;lCustData) |= <br>Button_GetCheck(hGetPosRadio)? OPENFILENAME_F_GETPOS : 0; <br>    /* Use DSBCAPS_GETCURRENTPOSITION2 */ <br>    *((LPDWORD)lpofn-&gt;lCustData) |= <br>Button_GetCheck(hGetPos2Radio)? OPENFILENAME_F_GETPOS2 : 0; <br> <br>    /* Local buffer focus */ <br>    *((LPDWORD)lpofn-&gt;lCustData) |= <br>Button_GetCheck(hStickyRadio)? OPENFILENAME_F_LOCALFOCUS : 0; <br>    /* Sticky buffer focus */ <br>    *((LPDWORD)lpofn-&gt;lCustData) |= <br>Button_GetCheck(hStickyRadio)? OPENFILENAME_F_STICKYFOCUS : 0; <br>    /* Global sound focus */ <br>    *((LPDWORD)lpofn-&gt;lCustData) |= <br>Button_GetCheck(hGlobalRadio)? OPENFILENAME_F_GLOBALFOCUS : 0; <br>    /* 3D Buffer */ <br>    *((LPDWORD)lpofn-&gt;lCustData) |= <br>    Button_GetCheck(h3DCheck)? OPENFILENAME_F_3D : 0; <br> <br>// Are Notifies On <br>    *((LPDWORD)lpofn-&gt;lCustData) |= <br>    Button_GetCheck(hNotifyCheck)? OPENFILENAME_F_NOTIFY : 0; <br> <br>        /* Mute at max distance */ <br>        *((LPDWORD)lpofn-&gt;lCustData) |= <br>            Button_GetCheck(hMuteAtMaxDist)? OPENFILENAME_F_MUTEMAX : 0; <br>           /* Returning zero signifies that we "approve" of the OK command, <br>             * and allows the common dialog to finish. <br>             */ <br>            return FALSE; <br>        } <br>        /* Let the default dialog do/continue processing */ <br>        return FALSE; <br>    } <br>    return FALSE; <br>} <br> <br> <br>/* SettingsDlgProc() <br> * <br> *    DialogBox procedure for the Settings dialog, which sets a bunch of <br> * the application-global settings stored in our global REGSETTINGS struct. <br> */ <br>BOOL CALLBACK SettingsDlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam ) <br>    { <br>    static BOOL fSettingsSaved; <br>    static HWNDhInitialDirEdit, hDeviceCombo, hDeviceText, hDefaultCheck; <br>    static HWND hFormatCombo, hExclusiveCheck, hOpen3DCheck, hFocusCombo; <br>static BOOL fDefaultDevice, fXMode; <br>static DWORD dwFormat; <br>static BOOL fInited = FALSE; <br>    int    ndx, i, idxLocal, idxSticky, idxGlobal; <br>    TCHAR   szFormat[32]; <br>    LPGUID  lpguTemp; <br> <br>    switch( message ) <br>{ <br>case WM_INITDIALOG: <br>{ <br>WAVEFORMATEX wfx, wfxActual; <br>HRESULT hr = DS_OK; <br>ZeroMemory(&amp;wfx, sizeof(wfx)); <br>ZeroMemory(&amp;wfxActual, sizeof(wfxActual)); <br> <br>hInitialDirEdit = GetDlgItem( hDlg, IDC_SETTINGS_INITIALDIR_EDIT ); <br>hDeviceCombo = GetDlgItem( hDlg, IDC_SETTINGS_DSD_DEVICE_COMBO ); <br>hFormatCombo = GetDlgItem( hDlg, IDC_SETTINGS_DSD_FORMAT_COMBO ); <br>hFocusCombo = GetDlgItem( hDlg, IDC_SETTINGS_FOCUS_COMBO ); <br>hDeviceText = GetDlgItem( hDlg, IDC_SETTINGS_DSD_DEVICE_TEXT ); <br>hDefaultCheck = GetDlgItem( hDlg, IDC_SETTINGS_DSD_DEFAULT_CHECK ); <br>hExclusiveCheck = GetDlgItem( hDlg, IDC_SETTINGS_EXCLUSIVE_CHECK ); <br>hOpen3DCheck = GetDlgItem( hDlg, IDC_SETTINGS_OPEN3D_CHECK ); <br> <br>    // We use this flag to determine the return value from DialogBox() <br>    // FALSE indicates no change, TRUE means a change occurred. <br>    fSettingsSaved = FALSE; <br> <br>    // Add all the format strings to the combo box <br>    for( i = 0; i &lt; NUM_FORMATENTRIES; i ++ ) <br>{ <br>// Only add formats that are available on this card (this will <br>// ignore any formats we couldn't SetFormat() with at startup, <br>// and any we have since found to be unusable as well). <br>if( !fdFormats[i].fEnable ) <br>continue; <br> <br>wfx.wFormatTag = WAVE_FORMAT_PCM; <br>if( FormatCodeToText(fdFormats[i].dwCode, szFormat, sizeof(szFormat))) <br>{ <br>// Do a set and get format to see what the card supports. <br>FormatCodeToWFX(fdFormats[i].dwCode, &amp;wfx); <br>hr = gpdsbPrimary-&gt;SetFormat(&amp;wfx); <br>if (hr != DS_OK) <br>DPF(0, "SettingsDlgProc: SetFormat failed"); <br>hr = gpdsbPrimary-&gt;GetFormat(&amp;wfxActual, sizeof(WAVEFORMATEX), NULL); <br>if (hr != DS_OK) <br>DPF(0, "SettingsDlgProc: GetFormat failed"); <br>if (!IsSameFormat(&amp;wfx, &amp;wfxActual)) <br>{ <br>char szTemp[2] = "*"; <br>strcat(szFormat, szTemp); <br>} <br>ndx = ComboBox_AddString( hFormatCombo, szFormat ); <br>ComboBox_SetItemData( hFormatCombo, ndx, fdFormats[i].dwCode ); <br>} <br>} //for <br> <br>// restore the format. <br>FormatCodeToWFX(gdwOutputFormat, &amp;wfx); <br>hr = gpdsbPrimary-&gt;SetFormat(&amp;wfx); <br>ASSERT(hr == DS_OK); <br> <br>    DirectSoundEnumerate( (LPDSENUMCALLBACK)DSEnumProc, (LPVOID)&amp;hDeviceCombo ); <br> <br>    // Add the three focus choices to the listbox, and set the item data <br>    // for each to the appropriate flag <br>    idxLocal = ComboBox_AddString( hFocusCombo, "Local" ); <br>    ComboBox_SetItemData( hFocusCombo, idxLocal, 0 ); <br>    idxSticky = ComboBox_AddString( hFocusCombo, "Sticky" ); <br>    ComboBox_SetItemData( hFocusCombo, idxSticky, DSBCAPS_STICKYFOCUS ); <br>    idxGlobal = ComboBox_AddString( hFocusCombo, "Global" ); <br>    ComboBox_SetItemData( hFocusCombo, idxGlobal, DSBCAPS_GLOBALFOCUS ); <br> <br>    // Select the proper Drop List item <br>    if( grs.dwDefaultFocusFlag == DSBCAPS_STICKYFOCUS ) <br>ComboBox_SetCurSel( hFocusCombo, idxSticky ); <br>    else if( grs.dwDefaultFocusFlag == DSBCAPS_GLOBALFOCUS ) <br>ComboBox_SetCurSel( hFocusCombo, idxGlobal ); <br>    else <br>ComboBox_SetCurSel( hFocusCombo, idxLocal ); <br> <br>    // Set the states of checkboxes and controls that depend on them <br>    Button_SetCheck( hDefaultCheck, grs.fDefaultDevice ); <br>    Button_SetCheck( hExclusiveCheck, grs.fUseExclusiveMode ); <br>// is 3D on or off? <br>if (gfDisable3D) <br>{ <br>grs.fOpen3D = FALSE; <br>Static_Enable(hOpen3DCheck, FALSE); <br>} <br>    Button_SetCheck( hOpen3DCheck, grs.fOpen3D ); <br>    Static_Enable( hDeviceCombo, !grs.fDefaultDevice ); <br>    Static_Enable( hDeviceText, !grs.fDefaultDevice ); <br> <br>    Edit_LimitText( hInitialDirEdit, sizeof(grs.szInitialDir)); <br>    Edit_SetText( hInitialDirEdit, grs.szInitialDir ); <br> <br>    if (FormatCodeToText(grs.dwPreferredFormat, szFormat, sizeof(szFormat))) <br>{ <br>ComboBox_SetCurSel( hFormatCombo, ComboBox_FindString( hFormatCombo, <br>    -1, szFormat )); <br>} <br>if (!fInited) <br>{// remember the values we started with. <br>fDefaultDevice = grs.fDefaultDevice; <br>fXMode = grs.fUseExclusiveMode; <br>dwFormat = grs.dwPreferredFormat; <br>fInited = TRUE; <br>} <br> <br>return TRUE; <br>} <br> <br>case WM_COMMAND: <br>    switch( LOWORD(wParam)) <br>{ <br>case IDC_SETTINGS_BROWSE_INITIALDIR_BUTTON: <br>    { <br>BROWSEINFO              bi; <br>TCHAR                   szDisplayName[MAX_PATH]; <br>LPITEMIDLIST            pidl; <br>LPMALLOC  pMalloc = NULL; <br> <br>ZeroMemory(&amp;bi, sizeof(bi)); <br>     <br>bi.hwndOwner = GetParent(hDlg); <br>bi.pszDisplayName = szDisplayName; <br>bi.lpszTitle = TEXT("Select folder"); <br>bi.ulFlags = BIF_RETURNONLYFSDIRS; <br> <br>pidl = SHBrowseForFolder(&amp;bi); <br> <br>if(pidl) <br>{ <br>SHGetPathFromIDList(pidl, szDisplayName); <br>// set the directory name. <br>strcpy(grs.szInitialDir, szDisplayName); <br>    Edit_SetText( hInitialDirEdit, grs.szInitialDir ); <br>} <br>// free the pidl using the shell's task allocator. <br>if (SHGetMalloc(&amp;pMalloc) == NOERROR) <br>{ <br>// free it. <br>pMalloc-&gt;Free((void *)pidl); <br>} <br>    } <br>    break; <br> <br>case IDC_SETTINGS_DSD_DEFAULT_CHECK: <br>{ <br>    grs.fDefaultDevice = !grs.fDefaultDevice; <br>    Static_Enable( hDeviceCombo, !grs.fDefaultDevice ); <br>    Static_Enable( hDeviceText, !grs.fDefaultDevice ); <br>    // By selecting the first item, we wipe out the state where <br>    // the user could come in with the box checked, uncheck it, <br>    // and leave without selecting anything <br>    ComboBox_SetCurSel( hDeviceCombo, 0 ); <br>} <br>    break; <br> <br>case IDOK: <br>{ <br>BOOL fDeviceChanged, fXModeChanged, fFormatChanged; <br>fDeviceChanged = fXModeChanged = fFormatChanged = FALSE; <br> <br>grs.fDefaultDevice = Button_GetCheck( hDefaultCheck ); <br>if( !grs.fDefaultDevice ) <br>{ <br>lpguTemp = (LPGUID)ComboBox_GetItemData( hDeviceCombo, <br>ComboBox_GetCurSel( hDeviceCombo )); <br>if( NULL != lpguTemp ) <br>grs.guPreferredDevice = *lpguTemp; <br>else <br>grs.guPreferredDevice = GUID_NULL; <br>} <br>else <br>grs.guPreferredDevice = GUID_NULL; <br> <br>if (!gfDisable3D) <br>{ <br>grs.fOpen3D = Button_GetCheck( hOpen3DCheck ); <br>} <br>grs.fUseExclusiveMode = Button_GetCheck( hExclusiveCheck ); <br> <br>grs.dwPreferredFormat = ComboBox_GetItemData( hFormatCombo,ComboBox_GetCurSel( hFormatCombo )); <br> <br>grs.dwDefaultFocusFlag = ComboBox_GetItemData( hFocusCombo,ComboBox_GetCurSel( hFocusCombo )); <br>Edit_GetText( hInitialDirEdit, grs.szInitialDir,sizeof(grs.szInitialDir)); <br> <br>if (grs.fDefaultDevice != fDefaultDevice) <br>{ <br>fDeviceChanged = TRUE; <br>} <br> <br>if (grs.fUseExclusiveMode != fXMode) <br>{ <br>fXModeChanged = TRUE; <br>} <br> <br>if (dwFormat != grs.dwPreferredFormat) <br>{ <br>fFormatChanged = TRUE; <br>} <br> <br>if (fDeviceChanged | fXModeChanged | fFormatChanged) <br>{ <br>char sz[70] = "Settings will take effect after you restart the app."; <br>MessageBox(hDlg, sz, "", MB_OK|MB_ICONEXCLAMATION); <br>} <br> <br>SaveRegistrySettings(); <br>fSettingsSaved = TRUE; <br>SendMessage( hDlg, WM_CLOSE, 0, 0 ); <br>} <br>break; <br> <br>case IDCANCEL: <br>    fSettingsSaved = FALSE; <br>    SendMessage( hDlg, WM_CLOSE, 0, 0 ); <br>    break; <br> <br>default: <br>    return FALSE; <br>} <br>    return TRUE; <br>    break; <br> <br>case WM_CLOSE: <br>    EndDialog( hDlg, fSettingsSaved ); <br>    return TRUE; <br> <br>case WM_DESTROY: <br>    while( ComboBox_GetCount( hDeviceCombo )) <br>{ <br>lpguTemp = (LPGUID)ComboBox_GetItemData( hDeviceCombo, 0 ); <br>if( NULL != lpguTemp ) <br>    GlobalFree(lpguTemp); <br>ComboBox_DeleteString( hDeviceCombo, 0 ); <br>} <br>    return TRUE; <br> <br>default: <br>    return FALSE; <br>} <br>    ASSERT( FALSE ); <br>    return FALSE; <br>    } <br> <br> <br>/* LoadRegistrySettings() <br> * <br> *    Load application global REGSETTINGS structure values from the registry. <br> */ <br>BOOL LoadRegistrySettings( void ) <br>    { <br>    HKEYhReg; <br>    DWORDdwVal; <br>    DWORDcbValSize; <br>    BOOLfRet = TRUE; <br> <br>    // Load current settings from our registry key <br>    if( ERROR_SUCCESS != RegOpenKeyEx( HKEY_CURRENT_USER, REG_SETTINGS_KEY, <br>0, KEY_READ, &amp;hReg )) <br>{ <br>GetMediaPath( grs.szInitialDir, sizeof(grs.szInitialDir)); <br> <br>grs.fDefaultDevice = TRUE; <br>grs.fUseExclusiveMode = FALSE; <br>grs.fOpen3D = FALSE; <br>if(!IsPentiumOrBetter()) <br>{ <br>gfDisable3D = TRUE;// it's false by default otherwise. <br>} <br>grs.dwDefaultFocusFlag = 0; <br>grs.szInitialDir[0] = '\0';  <br>grs.dwPreferredFormat = aFormatOrder[0]; <br>fRet = TRUE; <br>goto LRS_Return; <br>} <br> <br>    // Load the "Use DirectSound Default Device" flag <br>    cbValSize = sizeof(dwVal); <br>    if( ERROR_SUCCESS != RegQueryValueEx( hReg, REG_SETTING_DEVICE_DEFAULT, <br>    NULL, NULL, (LPBYTE)&amp;dwVal, <br>    &amp;cbValSize )) <br>{ <br>grs.fDefaultDevice = TRUE; <br>fRet = FALSE; <br>} <br>    else <br>{ <br>grs.fDefaultDevice = (BOOL)dwVal; <br> <br>if( !grs.fDefaultDevice ) <br>    { <br>    // Load the GUID for the preferred device (only if it's not the default) <br>    cbValSize = sizeof(grs.guPreferredDevice); <br>    if( ERROR_SUCCESS != RegQueryValueEx( hReg, REG_SETTING_DEVICE_GUID, <br>    NULL, NULL, <br>    (LPBYTE)&amp;grs.guPreferredDevice, <br>    &amp;cbValSize )) <br>{ <br>// Copy GUID_NULL into the guPreferredDevice (only works in C++) <br>grs.guPreferredDevice = GUID_NULL; <br>fRet = FALSE; <br>} <br>    } <br>} <br> <br>    cbValSize = sizeof(dwVal); <br>    if( ERROR_SUCCESS != RegQueryValueEx( hReg, REG_SETTING_USE_EXCLUSIVE, <br>    NULL, NULL, (LPBYTE)&amp;dwVal, </code></pre>
<p>
</p>
<pre><code>&amp;cbValSize )) <br>{ <br>grs.fUseExclusiveMode = FALSE; <br>fRet = FALSE; <br>} <br>    else <br>grs.fUseExclusiveMode = (BOOL)dwVal; <br> <br>    // Load the flag telling us whether to default to 2D or 3D <br>if (!IsPentiumOrBetter()) <br>{ <br>gfDisable3D = TRUE; <br>grs.fOpen3D = FALSE; <br>} <br>else <br>{ <br>gfDisable3D = FALSE; <br>cbValSize = sizeof(dwVal); <br>if( ERROR_SUCCESS != RegQueryValueEx( hReg, REG_SETTING_OPEN3D, <br>NULL, NULL, (LPBYTE)&amp;dwVal, <br>&amp;cbValSize )) <br>{ <br>grs.fOpen3D = FALSE; <br>fRet = FALSE; <br>} <br>else <br>grs.fOpen3D = (BOOL)dwVal; <br>} <br> <br>    // Load the coded version of the preferred output format <br>    cbValSize = sizeof(grs.dwPreferredFormat); <br>    if( ERROR_SUCCESS != RegQueryValueEx( hReg, REG_SETTING_OUTPUT_FORMAT, <br>    NULL, NULL, <br>    (LPBYTE)&amp;grs.dwPreferredFormat, <br>    &amp;cbValSize )) <br>{ <br>grs.dwPreferredFormat = aFormatOrder[0]; <br>fRet = FALSE; <br>} <br> <br>    // Load the default focus DSBCAPS flags <br>    cbValSize = sizeof(grs.dwDefaultFocusFlag); <br>    if( ERROR_SUCCESS != RegQueryValueEx( hReg, REG_SETTING_FOCUS_FLAG, <br>    NULL, NULL, <br>    (LPBYTE)&amp;grs.dwDefaultFocusFlag, <br>    &amp;cbValSize )) <br>{ <br>grs.dwDefaultFocusFlag = 0; <br>fRet = FALSE; <br>} <br> <br>    // Load the initial directory for WAVE files <br>    cbValSize = sizeof(grs.szInitialDir); <br>    if( ERROR_SUCCESS != RegQueryValueEx( hReg, REG_SETTING_INITIAL_DIR, <br>    NULL, NULL, <br>    (LPBYTE)&amp;grs.szInitialDir, <br>    &amp;cbValSize )) <br>{ <br>GetMediaPath( grs.szInitialDir, sizeof(grs.szInitialDir)); <br>fRet = FALSE; <br>} <br> <br>    if( hReg != NULL ) <br>{ <br>RegCloseKey( hReg ); <br>hReg = NULL; <br>} <br> <br>LRS_Return: <br>    return fRet; <br>    } <br> <br> <br>/* SaveRegistrySettings() <br> * <br> *    Write the values in the REGSETTINGS global structure to the registry. <br> */ <br>BOOL SaveRegistrySettings( void ) <br>    { <br>    HKEYhReg; <br>    DWORDdwVal, dwCreateDisposition; <br>    BOOLfRet = TRUE; <br> <br>    // Save current settings to our registry key <br>    if( ERROR_SUCCESS != RegCreateKeyEx( HKEY_CURRENT_USER, REG_SETTINGS_KEY, <br>0, NULL, 0, KEY_WRITE, NULL, &amp;hReg, <br>&amp;dwCreateDisposition )) <br>{ <br>fRet = FALSE; <br>goto SRS_Return; <br>} <br> <br>    // Save the "Use DirectSound Default Device" flag <br>    dwVal = (DWORD)grs.fDefaultDevice; <br>    if( ERROR_SUCCESS != RegSetValueEx( hReg, REG_SETTING_DEVICE_DEFAULT, <br>    0, REG_DWORD, (LPBYTE)&amp;dwVal, <br>    sizeof(DWORD))) <br>{ <br>fRet = FALSE; <br>} <br>    else <br>{ <br>if( !grs.fDefaultDevice ) <br>    { <br>    // Save the GUID for the preferred device (only if it's not the default) <br>    if( ERROR_SUCCESS != RegSetValueEx( hReg, REG_SETTING_DEVICE_GUID, <br>    0, REG_BINARY, <br>    (LPBYTE)&amp;grs.guPreferredDevice, <br>    sizeof(GUID))) <br>{ <br>fRet = FALSE; <br>} <br>    } <br>} <br> <br>    // Use DSSCL_EXCLUSIVE ?? <br>    dwVal = (DWORD)grs.fUseExclusiveMode; <br>    if( ERROR_SUCCESS != RegSetValueEx( hReg, REG_SETTING_USE_EXCLUSIVE, <br>    0, REG_DWORD, (LPBYTE)&amp;dwVal, <br>    sizeof(DWORD))) <br>{ <br>fRet = FALSE; <br>} <br> <br>#ifdef DEBUG <br>if (grs.fOpen3D) <br>{ <br>ASSERT(gfDisable3D == FALSE); <br>} <br>#endif <br> <br>    dwVal = (DWORD)grs.fOpen3D; <br>    if( ERROR_SUCCESS != RegSetValueEx( hReg, REG_SETTING_OPEN3D, <br>    0, REG_DWORD, (LPBYTE)&amp;dwVal, <br>    sizeof(DWORD))) <br>{ <br>fRet = FALSE; <br>} <br> <br>    // Save the coded version of the preferred output format <br>    if( ERROR_SUCCESS != RegSetValueEx( hReg, REG_SETTING_OUTPUT_FORMAT, <br>    0, REG_DWORD, <br>    (LPBYTE)&amp;grs.dwPreferredFormat, <br>    sizeof(DWORD))) <br>{ <br>fRet = FALSE; <br>} <br> <br>    // Save the coded version of the preferred output format <br>    if( ERROR_SUCCESS != RegSetValueEx( hReg, REG_SETTING_FOCUS_FLAG, <br>    0, REG_DWORD, <br>    (LPBYTE)&amp;grs.dwDefaultFocusFlag, <br>    sizeof(DWORD))) <br>{ <br>fRet = FALSE; <br>} <br> <br>    // Save the initial directory for WAVE files <br>    if( ERROR_SUCCESS != RegSetValueEx( hReg, REG_SETTING_INITIAL_DIR, <br>    0, REG_SZ, <br>    (LPBYTE)&amp;grs.szInitialDir, <br>    lstrlen(grs.szInitialDir))) <br>{ <br>fRet = FALSE; <br>} <br> <br>    RegCloseKey( hReg ); <br>    hReg = NULL; <br> <br>SRS_Return: <br>    return fRet; <br>    } <br> <br> <br>/* GetMediaPath() <br> * <br> *    In the absence of a registry value, this function is called to pick a <br> * starting point for the File|Open dialog.  Usually \DXSDK\SDK\MEDIA. <br> */ <br>void GetMediaPath( LPTSTR lpszBuf, int nBuf ) <br>    { <br>    HKEY    hReg; <br>    DWORD   cbStartPathLen; <br> <br>    if( ERROR_SUCCESS != RegOpenKeyEx( HKEY_LOCAL_MACHINE, <br>REG_DIRECT3D_KEY, <br>0, KEY_READ, &amp;hReg )) <br>{ <br>        goto REG_OPEN_FAILED; <br>} <br>    else <br>{ <br>// Query the Registry for the path to the media directory <br>cbStartPathLen = sizeof( szOpenStartDir ); <br>if( ERROR_SUCCESS != RegQueryValueEx( hReg, REG_D3DPATH_VAL, <br>NULL, NULL, <br>(LPBYTE)szOpenStartDir, <br>&amp;cbStartPathLen )) <br>    { <br>    goto REG_OPEN_FAILED; <br>    } <br>RegCloseKey( hReg ); <br>hReg = NULL; <br>} <br> <br>    return; <br> <br>REG_OPEN_FAILED: <br>    // Start off by getting the Windows directory -- we're trying to build a <br>    // file path like "C:\WINDOWS\MEDIA", but the WINDOWS directory could be <br>    // named anything, so we must ask. <br>    GetWindowsDirectory( szOpenStartDir, sizeof(szOpenStartDir)); <br>    // If there's no trailing backslash, append one <br>    if( lstrcmp( &amp;szOpenStartDir[lstrlen(szOpenStartDir)], TEXT("\\") )) <br>lstrcat( szOpenStartDir, TEXT("\\")); <br>    // Now add on the MEDIA part of the path <br>    lstrcat( szOpenStartDir, TEXT("MEDIA")); <br>    } <br> <br> <br>/* FormatCodeToText() <br> * <br> *    This function reads format codes and puts out a text string for them. <br> * It does not check for invalid codes.  FALSE return means the buffer was <br> * invalid in some way, TRUE means success. <br> * <br> */ <br>BOOL FormatCodeToText( DWORD dwFormat, LPTSTR lpszBuf, int nBufSize ) <br>    { <br>    DWORD   dwFreq; <br> <br>    // The longest string we'll ever put in is 21 characters (including NULL) <br>    if( NULL == lpszBuf || nBufSize &lt; 21 ) <br>return FALSE; <br> <br>    // Extract the sample rate <br>    dwFreq = FC_GETFREQCODE(dwFormat); <br>    dwFreq = ( dwFreq == 8 ? 8000 : (dwFreq / 11) * 11025); <br> <br>    wsprintf( lpszBuf, "%u Hz, %u-bit %s", dwFreq, FC_GETBITS(dwFormat), <br>FC_GETCHANNELS(dwFormat) == 1 ? "Mono" : "Stereo" ); <br> <br>    return TRUE; <br>    } <br> <br> <br>/* FormatCodeToWFX() <br> * <br> *    This function reads format codes and fills most of the fields of a <br> * WAVEFORMATEX structure based on the values read.  It does not fill the <br> * wFormatTag or cbSize members. <br> * <br> */ <br>BOOL FormatCodeToWFX( DWORD dwFormat, PWAVEFORMATEX pwfx ) <br>    { <br>    DWORD   dwFreq; <br> <br>    if( NULL == pwfx ) <br>return FALSE; <br> <br>    // Extract the sample rate <br>    dwFreq = FC_GETFREQCODE(dwFormat); <br>    pwfx-&gt;nSamplesPerSec = ( dwFreq == 8 ? 8000 : (dwFreq / 11) * 11025); <br> <br>    pwfx-&gt;wBitsPerSample = (WORD)FC_GETBITS(dwFormat); <br>    pwfx-&gt;nChannels = (WORD)FC_GETCHANNELS(dwFormat); <br> <br>    // The nBlockAlign calculation below only works for whole-byte samples <br>    ASSERT( pwfx-&gt;wBitsPerSample % 8 == 0 ); <br> <br>    pwfx-&gt;nBlockAlign = pwfx-&gt;nChannels * (pwfx-&gt;wBitsPerSample / 8); <br>    pwfx-&gt;nAvgBytesPerSec = pwfx-&gt;nBlockAlign * pwfx-&gt;nSamplesPerSec; <br> <br>    return TRUE; <br>    } <br> <br> <br>/* FormatCodeFromCommandID() <br> * <br> *    Returns the Format Code that matches the given command ID. <br> */ <br>DWORD FormatCodeFromCommandID( WORD wID ) <br>    { <br>    int i; <br> <br>    for( i = 0; i &lt; NUM_FORMATENTRIES; i++ ) <br>{ <br>if( fdFormats[i].wCommandID == wID ) <br>    return fdFormats[i].dwCode; <br>} <br>    return 0; <br>    } <br> <br> <br>/* CommandIDFromFormatCode() <br> * <br> *    Searchs our FORMATDATA array and returns the Command ID corresponding <br> * to the given format code, or 0 if there is no such valid format code. <br> */ <br>WORD CommandIDFromFormatCode( DWORD dwCode ) <br>    { <br>    int i; <br> <br>    for( i = 0; i &lt; NUM_FORMATENTRIES; i++ ) <br>{ <br>if( fdFormats[i].dwCode == dwCode ) <br>    return fdFormats[i].wCommandID; <br>} <br>    return 0; <br>    } <br> <br> <br>void DisableFormatCode( DWORD dwCode ) <br>    { <br>    inti; <br> <br>    for( i = 0; i &lt; NUM_FORMATENTRIES; i++ ) <br>{ <br>if( fdFormats[i].dwCode == dwCode ) <br>    { <br>    fdFormats[i].fEnable = FALSE; <br>    break; <br>    } <br>} <br>    } <br> <br> <br>void EnableFormatCode( DWORD dwCode ) <br>    { <br>    inti; <br> <br>    for( i = 0; i &lt; NUM_FORMATENTRIES; i++ ) <br>{ <br>if( fdFormats[i].dwCode == dwCode ) <br>    { <br>    fdFormats[i].fEnable = TRUE; <br>    break; <br>    } <br>} <br>    } <br> <br> <br>/* DSEnumProc() <br> * <br> *   DirectSoundEnumerate() callback procedure which fills a combo box with <br> * the description strings of all devices and attachs a pointer to a GUID, <br> * which must be freed later by calling delete. <br> */ <br>BOOL CALLBACK DSEnumProc( LPGUID lpguDevice, LPCTSTR lpszDesc, <br>                                LPCTSTR lpszDrvName, LPVOID lpContext ) <br>    { <br>    HWND   hCombo = *(HWND *)lpContext; <br>    LPGUID lpguTemp = NULL; <br>    int    idx; <br> <br>    if( NULL != lpguDevice ) <br>        { <br>        lpguTemp = (LPGUID)GlobalAlloc(GPTR, sizeof(GUID)); <br>// We failed to allocate storage, so continue with next device <br>if( NULL == lpguTemp ) <br>    return( TRUE ); <br> <br>        CopyMemory( lpguTemp, lpguDevice, sizeof(GUID)); <br>} <br> <br>    idx = ComboBox_AddString( hCombo, lpszDesc ); <br>    ComboBox_SetItemData( hCombo, <br>    ComboBox_FindString( hCombo, 0, lpszDesc ), <br>    lpguTemp ); <br> <br>    if( !grs.fDefaultDevice ) <br>{ <br>if( NULL == lpguTemp ) <br>    { <br>    if( grs.guPreferredDevice == GUID_NULL ) <br>ComboBox_SetCurSel( hCombo, idx ); <br>    } <br>else if( *lpguTemp == grs.guPreferredDevice ) <br>    ComboBox_SetCurSel( hCombo, idx ); <br>} <br> <br>    return( TRUE ); <br>    } <br> <br> <br>/* fGetToken() <br> * <br> *    Parses the command-line string "in place" starting at pszStart.  A ptr <br> * to the start of the next token and it's length will be the out parameters, <br> * or NULL and 0 if no token.  Note that *ppszRet will NOT be NULL-terminated <br> * since the string is part of another string.  That's what then length is for. <br> * <br> * Returns: TRUE if a token was retrieved, or FALSE if there was no token. <br> */ <br>BOOL fGetToken( PSTR pszStart, PSTR *ppszRet, int *pcchRet ) <br>    { <br>    PSTR  pszCur = pszStart; <br>    PSTR  pszTokStart; <br> <br>    if( !pszStart || NULL == ppszRet || NULL == pcchRet ) <br>return FALSE; <br> <br>    // Skip leading whitespace <br>    while( *pszCur &amp;&amp; (*pszCur == ' ' || *pszCur == '\t')) <br>pszCur++; <br> <br>    *ppszRet = NULL; <br>    *pcchRet = 0; <br> <br>    if( *pszCur ) <br>{ <br>pszTokStart = pszCur; <br> <br>while( *pszCur &amp;&amp; *pszCur != ' ' &amp;&amp; *pszCur != '\t' ) <br>    pszCur++; <br> <br>*ppszRet = pszTokStart; <br>*pcchRet = (int)(pszCur - pszTokStart); <br>} <br> <br>    if( *pcchRet != 0 ) <br>return TRUE; <br>    else <br>return FALSE; <br>    } <br> <br> <br>/* fMatchToken() <br> * <br> *    Attempts to match the first cchLen characters of pszDatum to the <br> * string at pszString.  The comparison is case-insensitive (this function <br> * is designed for command-line switch matching). <br> * <br> * Returns: TRUE if the first cchLen characters are a match, else FALSE. <br> */ <br>BOOL fMatchToken( PSTR pszString, PSTR pszDatum, int cchLen ) <br>    { <br>    inti; <br> <br>    for( i = 0; i &lt; cchLen; i++ ) <br>{ <br>if( CharLower( (LPTSTR)MAKELONG( pszString[i], 0 )) <br>    != CharLower( (LPTSTR)MAKELONG( pszDatum[i], 0 ))) <br>    return FALSE; <br>} <br>    return TRUE; <br>    } <br> <br> <br>/* ParseCommandLine() <br> * <br> *    Given a command-line string without the module name, this function will <br> * parse the command line and takes action on whatever it finds there. <br> * <br> * Returns: TRUE if successful, or FALSE if there was an error. <br> */ <br>BOOL ParseCommandLine(LPTSTR lpszCmdLine) <br>    { <br>    PSTRpszCur,pszToken; <br>    PSTRppszFiles[MAXCONTROLS]; <br>    BOOLfStartPlaying = FALSE, fStartLooping = FALSE; <br>    intcchTokLen = 0, i, nFilesFound; <br> <br>    pszCur = lpszCmdLine; <br> <br>    // First get all the command line switches <br>    while( fGetToken(pszCur, &amp;pszToken, &amp;cchTokLen) &amp;&amp; <br>   (pszToken[0] == '/' || pszToken[0] == '-' )) <br>{ <br>pszCur = pszToken + cchTokLen; <br>pszToken++; <br> <br>if( fMatchToken( pszToken, "PLAY", 4 )) <br>    { <br>    fStartPlaying = TRUE; <br>    } <br>else if( fMatchToken( pszToken, "LOOP", 4 )) <br>    { <br>    fStartLooping = TRUE; <br>    } <br>else <br>    { <br>    // We don't recognize this mysterious switch, so eat it and move on <br>    } <br>} <br> <br>    // Anything left on the command-line will be treated as a filename and <br>    // we'll attempt to open it after we've found them all <br>    nFilesFound = 0; <br>    while( fGetToken(pszCur, &amp;pszToken, &amp;cchTokLen) &amp;&amp; nFilesFound &lt; MAXCONTROLS ) <br>{ <br>pszCur = pszToken + cchTokLen; <br>ppszFiles[nFilesFound] = (LPTSTR)GlobalAlloc(GPTR, (cchTokLen+1) * sizeof(TCHAR)); <br>// Copy the token out of the command-line string and into our buffer <br>CopyMemory( ppszFiles[nFilesFound], pszToken, cchTokLen*sizeof(TCHAR)); <br>// Append a NULL terminator to what we just copied (to be safe) <br>*(ppszFiles[nFilesFound] + cchTokLen) = 0; <br>nFilesFound++; <br>} <br>    // This function will take the array of strings we've created and open <br>    // each string as a file.  It will obey the global fStartPlaying and <br>    // fStartLooping flags we may have already set above <br>    if( nFilesFound ) <br>AppWnd.BatchOpenFiles( ppszFiles, nFilesFound, fStartPlaying, fStartLooping ); <br> <br>    // Free the space we allocated <br>    for( i = 0; i &lt; nFilesFound; i++ ) <br>{ <br>GlobalFree(ppszFiles[i]); <br>ppszFiles[i] = NULL; <br>} <br> <br>    // Returning TRUE means the caller should continue doing what they <br>    // were doing: we succeeded. <br>    return TRUE; <br>    } <br> <br> <br>// =============================================================== <br>// IsPentiumOrBetter <br>//returns FALSE if the machine is less than a Pentium. <br>// =============================================================== <br>BOOL IsPentiumOrBetter(void) <br>{ <br>BOOL fRet = TRUE; <br>SYSTEM_INFO si; <br> <br>ZeroMemory(&amp;si, sizeof(SYSTEM_INFO)); <br> <br>GetSystemInfo(&amp;si); <br> <br>// should work with pentiums and higher. <br>if (si.dwProcessorType == PROCESSOR_INTEL_386 || <br>si.dwProcessorType == PROCESSOR_INTEL_486) <br>{ <br>fRet = FALSE; <br>} <br> <br>return fRet; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
