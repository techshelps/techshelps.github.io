<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MAINWND.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3110"></a>MAINWND.CPP</h2>
<pre><code>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;commctrl.h&gt; <br>#include &lt;commdlg.h&gt; <br> <br>#include "resource.h" <br>#include "DSShow3D.h" <br>#include "GVars.h" <br> <br>#include "MainWnd.h" <br>#include "FInfo3D.h" <br>#include "FileInfo.h" <br>#include "LsnrInfo.h" <br>#include "wave.h" <br>#include "debug.h" <br> <br>static HWND hMainWndClient; <br> <br>MainWnd::MainWnd() <br>{ <br>    m_fCreated = FALSE; <br>    m_hwnd = NULL; <br>    m_n3DBuffers = 0; <br>    ZeroMemory( &amp;m_dscaps, sizeof(DSCAPS)); <br>    m_dscaps.dwSize = sizeof(m_dscaps); <br>} <br> <br> <br>MainWnd::~MainWnd() <br>{ <br>    // This situation should never really occur, but we should make sure <br>    // that there are no coding errors by asserting that fact. <br>    if( m_hwnd ) <br>    { <br>ASSERT_HWND(m_hwnd); <br>::DestroyWindow( m_hwnd ); <br>m_hwnd = NULL; <br>m_fCreated = FALSE; <br>    } <br>} <br> <br> <br>BOOL MainWnd::Create() <br>{ <br>    if( m_fCreated ) <br>return FALSE; <br> <br>    ASSERT( NULL == m_hwnd ); <br>    m_hwnd = CreateWindowEx( WS_EX_ACCEPTFILES, <br>    gszAppWndClass, <br>    gszAppCaption, <br>    WS_OVERLAPPEDWINDOW, <br>    CW_USEDEFAULT, <br>    CW_USEDEFAULT, <br>    200, <br>    150, <br>    (HWND)NULL, <br>    (HMENU)NULL, <br>    (HINSTANCE)ghInst, <br>    (LPTSTR)NULL ); <br> <br>    if( !m_hwnd ) <br>return FALSE; <br> <br>    SetWindowLong( m_hwnd, GWL_USERDATA, (LONG)this ); <br>    m_fCreated = TRUE; <br> <br>    EnableMenuItem(GetMenu(m_hwnd), 2, MF_BYPOSITION | <br>   (m_dlInfoList.GetElementCount() ? MF_ENABLED : MF_GRAYED)); <br>    DrawMenuBar( m_hwnd ); <br> <br>    UpdateStatus(); <br> <br>    return TRUE; <br>} <br> <br> <br>int MainWnd::MessageBox( LPCSTR lpcszMessage, UINT uType ) <br>{ <br>    return ::MessageBox( m_hwnd, lpcszMessage, gszAppName, uType ); <br>} <br> <br>int MainWnd::MessageBox( UINT uResID, UINT uType ) <br>{ <br>    // TODO Make the 512 some defined constant <br>    TCHARszMessage[512]; <br>    int    nRet; <br> <br>    LoadString( ghInst, uResID, szMessage, 512 ); <br>    nRet = ::MessageBox( m_hwnd, szMessage, gszAppName, uType ); <br> <br>    return nRet; <br>} <br> <br>BOOL MainWnd::OnTimer( WPARAM wParam, LPARAM lParam ) <br>{ <br>    // Move to the Head of the list <br>    m_dlInfoList.SetAtHead(); <br>     <br>    if( NULL != gpListenerInfo ) <br>gpListenerInfo-&gt;UpdateUI(); <br> <br>    // While the current element isn't NULL, call OnTimer on each FileInfo <br>    for( int i = 0; i &lt; m_dlInfoList.GetElementCount(); i++ ) <br>    { <br>m_dlInfoList.GetCurrent()-&gt;UpdateUI(); <br>// Overloaded increment moves to next position in the list <br>m_dlInfoList++; <br>    } <br>    return TRUE; <br>} <br> <br>void MainWnd::OnDestroy() <br>{ <br>    HRESULT     hr = 0; <br> <br>    if( gdwTimer != 0 ) <br>    { <br>KillTimer( m_hwnd, gdwTimer ); <br>gdwTimer = 0; <br>    } <br> <br>    if( NULL != gpwfxFormat ) <br>    { <br>GlobalFree( gpwfxFormat ); <br>gpwfxFormat = NULL; <br>    } <br> <br>    /* Destroy the direct sound object. */ <br>    if( gp3DListener != NULL ) <br>    { <br>DPF( 3, "Releasing 3D Listener in MainWnd::OnDestroy()" ); <br>gp3DListener-&gt;Release(); <br>gp3DListener = NULL; <br>    } <br>    if( gpdsbPrimary ) <br>    { <br>DPF( 3, "Releasing Primary in MainWnd::OnDestroy()" ); <br>gpdsbPrimary-&gt;Stop(); <br>gpdsbPrimary-&gt;Release(); <br>gpdsbPrimary = NULL; <br>    } <br>    if( gpds != NULL ) <br>    { <br>DPF( 3, "Releasing DSound object in MainWnd::OnDestroy()" ); <br>gpds-&gt;Release(); <br>gpds = NULL; <br>    } <br> <br>    if( gfCOMInitialized ) <br>CoUninitialize(); <br> <br>//    WriteProfileString( gszAppName, "EnumDrivers", gfEnumDrivers ? "1" : "0" ); <br> <br>    if( m_hwnd ) <br>m_hwnd = NULL; <br>    return; <br>} <br> <br> <br>/* MainWndProc() <br> * <br> *    Window message handler function for the main application window. <br> * For the most part, this sucker just dispatchs calls to some helper <br> * functions in this module which do the actual handling. <br> */ <br>LRESULT CALLBACK MainWndProc( HWND hWnd, unsigned message, WPARAM wParam, LPARAM lParam ) <br>{ <br>    if( !hWnd ) <br>return 0L; <br> <br>    // This will be a valid pointer to the class object for any message <br>    // after the WM_CREATE <br>    MainWnd *pmw = (MainWnd *)GetWindowLong( hWnd, GWL_USERDATA ); <br>     <br>    switch (message) <br>{ <br>case WM_CREATE: <br>    // If we want to do anything with the class here, we'll have <br>    // to modify the code to pass pmw in LPARAM since there's no <br>    // other way to get it yet: the code that sets the WindowLong <br>    // user data has not yet executed <br>    break; <br> <br>case WM_ACTIVATE: <br>    ASSERT( NULL != pmw ); <br>    pmw-&gt;UpdateStatus(); <br>    break; <br> <br>case WM_TIMER: <br>    ASSERT( NULL != pmw ); <br>    if (!pmw-&gt;OnTimer(wParam, lParam)) <br>return(DefWindowProc(hWnd, message, wParam, lParam)); <br>    break; <br> <br>case WM_DROPFILES: <br>    ASSERT( NULL != pmw ); <br>    if( !pmw-&gt;OnDropFiles( wParam )) <br>return(DefWindowProc(hWnd, message, wParam, lParam)); <br>    break; <br> <br>case WM_PAINT: <br>    ASSERT( NULL != pmw ); <br>    if( !pmw-&gt;OnPaint(wParam, lParam)) <br>return(DefWindowProc(hWnd, message, wParam, lParam)); <br>    break; <br> <br>case WM_INITMENU: <br>    ASSERT( NULL != pmw ); <br>    if((HMENU)wParam != GetMenu( hWnd )) <br>break; <br>    return pmw-&gt;OnInitMenu( wParam ); <br>    break; <br> <br>case WM_INITMENUPOPUP: <br>// we only want to deal with the options sub-menu. <br>    ASSERT( NULL != pmw ); <br>    if((BOOL)HIWORD(lParam) == TRUE) // it's a system menu <br>break; <br>else if ((UINT)LOWORD(lParam) != 1) // it's not the options menu. <br>break; <br>// else handle it. <br>    return pmw-&gt;OnInitMenuPopup( wParam ); <br>    break; <br> <br>case WM_COMMAND: <br>    ASSERT( NULL != pmw ); <br>    if (!pmw-&gt;OnCommand(wParam, lParam)) <br>return DefWindowProc(hWnd, message, wParam, lParam); <br>    break; <br> <br>case WM_DESTROY: <br>    ASSERT( NULL != pmw ); <br>    pmw-&gt;OnDestroy(); <br>    PostQuitMessage(0); <br>    break; <br> <br>default: <br>    return DefWindowProc( hWnd, message, wParam, lParam ); <br>    break; <br>} <br> <br>    return 0L; <br>} <br> <br> <br>BOOL MainWnd::OnInitMenuPopup( WPARAM wParam ) <br>{ <br>    int i; <br>char szFormat[255]; <br>WAVEFORMATEX wfx, wfxActual; <br>BOOL fRet = FALSE; <br>DWORD dwFormatID; <br>char szTemp[25] = "*"; <br>HRESULT hr = DS_OK; <br>HMENU hSubMenu = (HMENU)wParam; <br> <br>ZeroMemory(&amp;wfx, sizeof(WAVEFORMATEX)); <br>ZeroMemory(&amp;wfxActual, sizeof(WAVEFORMATEX)); <br> <br>// Get the handle to the format submenu. <br>hSubMenu = GetSubMenu(hSubMenu,0);  <br>ASSERT(IsMenu(hSubMenu)); <br> <br>for( i = 0; i &lt; NUM_FORMATENTRIES; i++ ) <br>{ <br>dwFormatID = CommandIDFromFormatCode(fdFormats[i].dwCode); <br>// get the string representing this format. <br>fRet = FormatCodeToText(fdFormats[i].dwCode, szFormat, sizeof(szFormat)); <br>ASSERT(fRet); <br>// set this as the format. <br>FormatCodeToWFX( fdFormats[i].dwCode, &amp;wfx); <br>wfx.wFormatTag = WAVE_FORMAT_PCM; <br>hr = gpdsbPrimary-&gt;SetFormat(&amp;wfx); <br>if (hr != DS_OK) <br>{ <br>DPF( 0, "SetFormat failed (%s)", TranslateDSError(hr)); <br>DisableFormatCode(fdFormats[i].dwCode); <br>continue; <br>} <br>else <br>{ <br>EnableFormatCode(fdFormats[i].dwCode); <br>} <br> <br>// now get what is the actual format. <br>hr = gpdsbPrimary-&gt;GetFormat(&amp;wfxActual, sizeof(WAVEFORMATEX), NULL); <br>if (hr != DS_OK) <br>{ <br>DPF(0, "GetFormat failed with hr = %lu", hr); <br>} <br>// are these formats the same. <br>if (!IsSameFormat(&amp;wfx, &amp;wfxActual)) <br>{ <br>strcat(szFormat, szTemp); <br>fRet = ModifyMenu(hSubMenu, dwFormatID, MF_BYCOMMAND | MF_STRING, dwFormatID, szFormat); <br>} <br> <br>if( !fdFormats[i].fEnable ) <br>EnableMenuItem((HMENU)wParam, dwFormatID, MF_BYCOMMAND | MF_GRAYED ); <br>else <br>EnableMenuItem((HMENU)wParam, dwFormatID, MF_BYCOMMAND | MF_ENABLED ); <br>}// for <br> <br>CheckMenuItem( (HMENU)wParam, <br>   CommandIDFromFormatCode( gdwOutputFormat ), <br>   MF_BYCOMMAND | MF_CHECKED ); <br> <br>// set the format back. <br>FormatCodeToWFX(gdwOutputFormat, &amp;wfx); <br>hr = gpdsbPrimary-&gt;SetFormat(&amp;wfx); <br>ASSERT(hr == DS_OK); <br> <br>return TRUE; <br>} <br> <br>BOOL MainWnd::OnInitMenu( WPARAM wParam ) <br>{ <br>    // If there are no buffers open, then disable the buffers menu <br>    EnableMenuItem((HMENU)wParam, 2, MF_BYPOSITION | <br>   (m_dlInfoList.GetElementCount() ? MF_ENABLED : MF_GRAYED)); <br>    return TRUE; <br>} <br> <br> <br>/* OnDropFiles() <br> * <br> *    Handles the WM_DROPFILES message, which is a message sent when someone <br> * drags and drops files onto our application window. <br> */ <br>BOOL MainWnd::OnDropFiles( WPARAM wParam ) <br>{ <br>    WORD    wNumFiles = DragQueryFile((HDROP)wParam, (UINT)-1, NULL, (UINT)0 ); <br>    WORD    nFile, nPathLength; <br>    LPTSTR  lpszFile; <br> <br>    for( nFile = 0; nFile &lt; wNumFiles; nFile++ ) <br>    { <br>nPathLength = DragQueryFile((HDROP)wParam, nFile, NULL, 0 ) + 1; <br>if(( lpszFile = (LPTSTR)GlobalAlloc(GPTR, nPathLength * sizeof(TCHAR))) == NULL ) <br>    continue; <br>DragQueryFile((HDROP)wParam, nFile, lpszFile, nPathLength ); <br> <br>// Open the file <br>OnFileOpen( lpszFile ); <br> <br>GlobalFree(lpszFile); <br>    } <br> <br>    DragFinish((HDROP)wParam); <br>    return TRUE; <br>} <br> <br> <br>/* OnCommand() <br> * <br> *    WM_COMMAND message handler for the main window procedure. <br> */ <br>BOOL MainWnd::OnCommand( WPARAM wParam, LPARAM lParam ) <br>{ <br>    HRESULT hr; <br>    DWORD   dwNewFormat; <br>    int    i = 0; <br> <br>    if(( dwNewFormat = FormatCodeFromCommandID( LOWORD(wParam))) != 0 ) <br>{ <br>CheckMenuItem( GetMenu( m_hwnd ), <br>CommandIDFromFormatCode( gdwOutputFormat ), <br>MF_BYCOMMAND | MF_UNCHECKED ); <br>FormatCodeToWFX( dwNewFormat, gpwfxFormat ); <br>DPF( 2, "Setting output format to code: %lu", dwNewFormat ); <br>hr = gpdsbPrimary-&gt;SetFormat( gpwfxFormat ); <br>if( SUCCEEDED( hr )) <br>    gdwOutputFormat = dwNewFormat; <br>else <br>    { <br>    DisableFormatCode( dwNewFormat ); <br>    EnableMenuItem( GetMenu( m_hwnd ), <br>    CommandIDFromFormatCode( dwNewFormat ), <br>    MF_BYCOMMAND | MF_GRAYED ); <br>    FormatCodeToWFX( gdwOutputFormat, gpwfxFormat ); <br>    gpdsbPrimary-&gt;SetFormat( gpwfxFormat ); <br>    } <br>return TRUE; <br>} <br> <br>    switch( LOWORD(wParam)) <br>    { <br>case IDC_FILE_EXIT: <br>    PostMessage(WM_CLOSE, 0, 0); <br>    break; <br> <br>case IDC_FILE_OPEN: <br>    OnFileOpen( NULL ); <br>    UpdateStatus(); <br>    break; <br> <br>case IDC_OPTIONS_SETTINGS: <br>    DialogBox(ghInst, MAKEINTRESOURCE(IDD_SETTINGS), <br>    m_hwnd, (DLGPROC)SettingsDlgProc); <br>    UpdateStatus(); <br>    break; <br> <br>case IDC_BUFFERS_MINIMIZEALL: <br>    m_dlInfoList.SetAtHead(); <br>    for( i = 0; i &lt; m_dlInfoList.GetElementCount(); i++) <br>{ <br>m_dlInfoList.GetCurrent()-&gt;MinimizeWindow(); <br>m_dlInfoList++; <br>} <br>    break; <br> <br>case IDC_BUFFERS_RESTOREALL: <br>    m_dlInfoList.SetAtHead(); <br>    for( i = 0; i &lt; m_dlInfoList.GetElementCount(); i++) <br>{ <br>m_dlInfoList.GetCurrent()-&gt;RestoreWindow(); <br>m_dlInfoList++; <br>} <br>    break; <br> <br>case IDC_BUFFERS_CLOSEALL: <br>    while( m_dlInfoList.GetElementCount()) <br>{ <br>m_dlInfoList.SetAtHead(); <br>m_dlInfoList.GetCurrent()-&gt;Close(); <br>// Element is removed from the list by processing elsewhere <br>} <br>    EnableMenuItem(GetMenu(m_hwnd), 2, MF_BYPOSITION | <br>   (m_dlInfoList.GetElementCount() ? MF_ENABLED : MF_GRAYED)); <br>    DrawMenuBar( m_hwnd ); <br>    break; <br> <br>case IDC_BUFFERS_CASCADE: <br>    m_dlInfoList.SetAtHead(); <br>    for( i = 0; i &lt; m_dlInfoList.GetElementCount(); i++) <br>{ <br>if( 0 == i ) <br>    m_dlInfoList.GetCurrent()-&gt;ResetCascade(); <br>m_dlInfoList.GetCurrent()-&gt;CascadeWindow(); <br>m_dlInfoList++; <br>} <br>    break; <br> <br>case IDC_HELP_ABOUT: <br>    DialogBox(ghInst, MAKEINTRESOURCE(IDD_ABOUT), <br>    m_hwnd, (DLGPROC)AboutDlgProc); <br>    break; <br> <br>default: <br>    return FALSE; <br>    } <br> <br>    /* If we broke out of the switch, it means we handled the message <br>     * so we return TRUE to indicate this. <br>     */ <br>    return TRUE; <br>} <br> <br> <br>/* DuplicateBuffer() <br> * <br> *    Does the work of duplicating a FileInfo object. <br> */ <br>void MainWnd::DuplicateBuffer( FileInfo *pfiSource ) <br>{ <br>    FileInfo*pfiNew; <br> <br>    if( NULL == pfiSource ) <br>return; <br> <br>    if( m_dlInfoList.GetElementCount() &gt;= MAXCONTROLS ) <br>    { <br>MessageBox( "No more controls allowed" ); <br>        return; <br>    } <br> <br>    if( pfiSource-&gt;Is3D()) <br>{ <br>m_n3DBuffers++; <br>pfiNew = new FileInfo3D( this ); <br>} <br>    else <br>pfiNew = new FileInfo( this ); <br> <br>    if( NULL == pfiNew ) <br>return; <br> <br>    pfiNew-&gt;Duplicate( pfiSource ); <br>    m_dlInfoList.Append( pfiNew ); <br>} <br> <br> <br>/* OnFileOpen() <br> * <br> *    Handles the File|Open menu command. <br> */ <br>FileInfo *MainWnd::OnFileOpen( LPTSTR lpszForcePath ) <br>{ <br>    TCHAR           szFileName[MAX_PATH]; <br>    FileInfo        *pFileInfo = NULL; <br>    LPTSTR    lpszFileTitle; <br>    int             nFileIndex; <br>    DWORD    dwFlags; <br> <br>    if( m_dlInfoList.GetElementCount() &gt;= MAXCONTROLS ) <br>    { <br>MessageBox( "No more controls allowed" ); <br>        return NULL; <br>    } <br> <br>    if( NULL != lpszForcePath ) <br>    { <br>dwFlags = OPENFILENAME_F_GETPOS2; <br>if( grs.dwDefaultFocusFlag &amp; DSBCAPS_STICKYFOCUS ) <br>    dwFlags |= OPENFILENAME_F_STICKYFOCUS; <br>else if( grs.dwDefaultFocusFlag &amp; DSBCAPS_GLOBALFOCUS ) <br>    dwFlags |= OPENFILENAME_F_GLOBALFOCUS; <br> <br>if( grs.fOpen3D ) <br>    dwFlags |= OPENFILENAME_F_3D; <br>lpszFileTitle = strrchr( lpszForcePath, '\\' ); <br>if( NULL == lpszFileTitle ) <br>    nFileIndex = 0; <br>else <br>    nFileIndex =  lpszFileTitle - lpszForcePath + sizeof(TCHAR); <br>lstrcpy( szFileName, lpszForcePath ); <br>    } <br>    else <br>    { <br>// Open the file, and check its format, etc. <br>if( !OpenFileDialog( m_hwnd, szFileName, &amp;nFileIndex, &amp;dwFlags )) <br>    return NULL; <br>    } <br> <br>    // Allocate the memory for the structure. <br>    if( dwFlags &amp; OPENFILENAME_F_3D ) <br>    { <br>pFileInfo = new FileInfo3D( this ); <br>    } <br>    else <br>pFileInfo = new FileInfo( this ); <br> <br>    if( NULL == pFileInfo ) <br>    { <br>MessageBox( "Cannot add this file -- out of memory", <br>    MB_OK|MB_ICONSTOP ); <br>goto ERROR_DONE_ROUTINE; <br>    } <br> <br>    if( m_dlInfoList.GetElementCount() == 0 ) <br>pFileInfo-&gt;ResetCascade(); <br> <br>    m_dlInfoList.Append( pFileInfo ); <br> <br>    pFileInfo-&gt;SetSticky((dwFlags &amp; OPENFILENAME_F_STICKYFOCUS) <br>? TRUE : FALSE ); <br>    pFileInfo-&gt;SetGlobal((dwFlags &amp; OPENFILENAME_F_GLOBALFOCUS) <br>? TRUE : FALSE ); <br>    pFileInfo-&gt;Set3D((dwFlags &amp; OPENFILENAME_F_3D) ? TRUE : FALSE ); <br>    pFileInfo-&gt;SetNotify((dwFlags &amp; OPENFILENAME_F_NOTIFY) ? TRUE : FALSE ); <br>    pFileInfo-&gt;SetUseGetPos2((dwFlags &amp; OPENFILENAME_F_GETPOS2) <br>? TRUE : FALSE ); <br>    pFileInfo-&gt;SetMuteAtMax((dwFlags &amp; OPENFILENAME_F_MUTEMAX) ? TRUE : FALSE ); <br> <br>    if( pFileInfo-&gt;LoadWave( szFileName, nFileIndex ) != 0 ) <br>    { <br>    m_dlInfoList.Remove( pFileInfo ); <br>    goto ERROR_DONE_ROUTINE; <br>    } <br> <br>    // If we fail after this, make sure to update the list!!! <br>    if( pFileInfo-&gt;Is3D()) <br>{ <br>if( m_n3DBuffers++ == 0 ) <br>    { <br>    // We only want to create this dialog once, and if this is the <br>    // first 3D buffer opened, then there should be no listener DLG yet <br>    ASSERT( NULL == ghwndListener ); <br> <br>    gpListenerInfo = new ListenerInfo; <br>    ghwndListener = CreateDialogParam( ghInst, <br>MAKEINTRESOURCE(IDD_3DLISTENER), <br>AppWnd.GetHwnd(), <br>(DLGPROC)ListenerInfoDlgProc, <br>(LPARAM)(gpListenerInfo)); <br>    ::ShowWindow( ghwndListener, SW_SHOW ); <br>    } <br>} <br> <br>    // If there are no buffers open, then disable the buffers menu <br>    EnableMenuItem(GetMenu(m_hwnd), 2, MF_BYPOSITION | <br>   (m_dlInfoList.GetElementCount() ? MF_ENABLED : MF_GRAYED)); <br>    DrawMenuBar( m_hwnd ); <br> <br>    return pFileInfo; <br> <br> <br>ERROR_DONE_ROUTINE: <br>    if( pFileInfo != NULL ) <br>    { <br>delete pFileInfo; <br>pFileInfo = NULL; <br>    } <br>    return NULL; <br>} <br> <br> <br>/* DestroyFileInfo() <br> * <br> *    Destroys a FileInfo structure and removes it from the list. <br> */ <br>void MainWnd::DestroyFileInfo( FileInfo *pfi ) <br>{ <br>    if( NULL == pfi ) <br>return; <br> <br>    if( pfi-&gt;Is3D() ) <br>{ <br>if( --m_n3DBuffers == 0 ) <br>    { <br>    ::DestroyWindow( ghwndListener ); <br>    ghwndListener = NULL; <br>    delete gpListenerInfo; <br>    gpListenerInfo = NULL; <br>    } <br>} <br> <br>    m_dlInfoList.Remove( pfi ); <br>    delete pfi; <br>    UpdateStatus(); <br>} <br> <br> <br>BOOL MainWnd::OnPaint( WPARAM wParam, LPARAM lParam ) <br>    { <br>    PAINTSTRUCTps; <br>    RECTrcClient; <br>    SIZEsizeExtent; <br>    TCHARszText[128]; <br> <br>    if( !BeginPaint( m_hwnd, &amp;ps )) <br>return FALSE; <br> <br>    GetClientRect( m_hwnd, &amp;rcClient ); <br>     <br>    SetBkMode( ps.hdc, TRANSPARENT ); <br> <br>    wsprintf( szText, "Free HW Mem: %luKb", m_dscaps.dwFreeHwMemBytes / 1024 ); <br>    GetTextExtentPoint32( ps.hdc, szText, lstrlen(szText), &amp;sizeExtent ); <br>     <br>    DrawText( ps.hdc, szText, -1, &amp;rcClient, DT_TOP | DT_LEFT ); <br> <br>    wsprintf( szText, "Free HW Buffers: %lu", m_dscaps.dwFreeHwMixingStaticBuffers ); <br>    rcClient.top += sizeExtent.cy; <br>    DrawText( ps.hdc, szText, -1, &amp;rcClient, DT_TOP | DT_LEFT ); <br> <br>    EndPaint( m_hwnd, &amp;ps ); <br>    return TRUE; <br>    } <br> <br> <br>void MainWnd::UpdateStatus( void ) <br>    { <br>    if( gpds ) <br>{ <br>// Get updated statistics on the DSound device <br>gpds-&gt;GetCaps( &amp;m_dscaps ); <br> <br>// Force a window client area repaint <br>InvalidateRect( m_hwnd, NULL, TRUE ); <br>UpdateWindow(); <br>} <br>    } <br> <br>//////////////////////////////////////////////////////////////////////////// <br>// BatchOpenFiles() <br>// <br>//    Takes an array of string pointers and tries to open each as a file to <br>// playback.  If fPlay is TRUE, the files will be played as they are being <br>// opened.  If fLoop is TRUE, they will also be set to loop. <br>// <br>// Returns: FALSE in the event of catastrophic failure, otherwise TRUE. <br>// <br>BOOL MainWnd::BatchOpenFiles( PSTR *ppszFiles, int nFiles, BOOL fPlay, BOOL fLoop ) <br>{ <br>    FileInfo*pfi; <br>    inti; <br> <br>    // Cap the number of files we can load out of the given set if we'd load <br>    // too many otherwise <br>    if( m_dlInfoList.GetElementCount() &gt;= MAXCONTROLS ) <br>    { <br>MessageBox( "No more controls allowed" ); <br>        return FALSE; <br>    } <br> <br>    for( i = 0; i &lt; nFiles; i++ ) <br>    { <br>if(( pfi = OnFileOpen( ppszFiles[i] )) == NULL ) <br>    continue; <br> <br>// LOOP is only obeyed if PLAY was also specified <br>if( fPlay ) <br>{ <br>    if( fLoop ) <br>{ <br>pfi-&gt;SetLooped( TRUE ); <br>} <br>    pfi-&gt;PlayBuffer(); <br>} <br> <br>pfi-&gt;UpdateUI(); <br>    } <br> <br>    return TRUE; <br>} <br> <br>// ===================================== <br>// IsSameFormat <br>// ===================================== <br>BOOL IsSameFormat(LPWAVEFORMATEX pwfx1, LPWAVEFORMATEX pwfx2) <br>{ <br>//if (pwfx1-&gt;wFormatTag != pwfx2-&gt;wFormatTag) <br>//return FALSE; <br>if (pwfx1-&gt;nChannels != pwfx2-&gt;nChannels) <br>return FALSE; <br>if (pwfx1-&gt;nSamplesPerSec != pwfx2-&gt;nSamplesPerSec) <br>return FALSE; <br>if (pwfx1-&gt;wBitsPerSample != pwfx2-&gt;wBitsPerSample) <br>return FALSE; <br> <br>return TRUE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
