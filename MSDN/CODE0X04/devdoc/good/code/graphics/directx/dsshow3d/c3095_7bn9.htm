<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FINFO3D.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3105"></a>FINFO3D.CPP</h2>
<pre><code>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include &lt;commctrl.h&gt; <br>#include &lt;dsound.h&gt; <br>#include &lt;math.h&gt; <br>#include &lt;stdio.h&gt; <br> <br>#include "wave.h" <br>#include "debug.h" <br>#include "DSShow3D.h" <br>#include "FInfo3D.h" <br>#include "lsnrinfo.h" <br>#include "GVars.h" <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// FileInfo3D() <br>// <br>//    Class constructor for the 3D interface/information class. <br>// <br>FileInfo3D::FileInfo3D( MainWnd * pmw ) : FileInfo( pmw ) <br>{ <br>    ZeroMemory( &amp;m_ht3d, sizeof(HWNDTABLE3D)); <br>    ZeroMemory( &amp;m_vPos, sizeof(D3DVECTOR)); <br>    ZeroMemory( &amp;m_vVelo, sizeof(D3DVECTOR)); <br>    m_flMaxDistance = 50.f; <br>    m_flMinDistance = 1.f; <br>    m_pDSB3D = NULL; <br> <br>    m_dwInternalFlags |= FI_INTERNALF_3D; <br> <br>    m_dwInnerAngle = FI3D_DEFAULT_INNER_ANGLE; <br>    m_dwOuterAngle = FI3D_DEFAULT_OUTER_ANGLE; <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// ~FileInfo3D() <br>// <br>//   Virtual destructor for the FileInfo3D class.  Should deallocate any space <br>// allocated by the constructor. <br>// <br>FileInfo3D::~FileInfo3D() <br>{ <br>    // If we do an allocation of memory specific to the FileInfo3D class, <br>    // we should free it here. <br> <br>    // Release the 3D interface <br>    if( m_pDSB3D != NULL ) <br>    { <br>        m_pDSB3D-&gt;Release(); <br>        m_pDSB3D = NULL; <br>    } <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// NewDirectSoundBuffer() <br>//  <br>//    Virtual function which handles opening a new sound buFfer by setting some <br>// flags and calling down to the base class handler, which actually does most <br>// of the work.  Upon return, this function will do a bit more work to get a 3D <br>// interface. <br>// <br>int FileInfo3D::NewDirectSoundBuffer() <br>{ <br>    HRESULThr; <br> <br>    m_dsbd.dwFlags = DSBCAPS_CTRL3D;  <br> <br>    if( !FileInfo::NewDirectSoundBuffer()) <br>    { <br>        // Try to grab the 3D interface pointer <br> <br>        if( FAILED( hr = m_pDSB-&gt;QueryInterface( IID_IDirectSound3DBuffer, <br>                                (void **)&amp;m_pDSB3D ))) <br>        { <br>            DPF( 0, "QI for DS3DBuffer interface: %s", TranslateDSError(hr)); <br>            return -1; <br>        } <br>        return 0; <br>    } <br>    else <br>        return -1; <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>// <br>// <br>// <br>BOOL FileInfo3D::OnInitDialog( HWND hDlg, WPARAM wParam ) <br>{ <br>    HRESULT hr; <br>    TCHAR   szTS[6]; <br> <br>    // Grab some 3D interface HWND's and pass along to the base class <br>    m_ht3d.hXSlider = GetDlgItem( hDlg, IDC_BUFFERDLG_X_SLIDER ); <br>    m_ht3d.hYSlider = GetDlgItem( hDlg, IDC_BUFFERDLG_Y_SLIDER ); <br>    m_ht3d.hZSlider = GetDlgItem( hDlg, IDC_BUFFERDLG_Z_SLIDER ); <br>    m_ht3d.hXText = GetDlgItem( hDlg, IDC_BUFFERDLG_X_TEXT ); <br>    m_ht3d.hYText = GetDlgItem( hDlg, IDC_BUFFERDLG_Y_TEXT ); <br>    m_ht3d.hZText = GetDlgItem( hDlg, IDC_BUFFERDLG_Z_TEXT ); <br> <br>    m_ht3d.hVxSlider = GetDlgItem( hDlg, IDC_BUFFERDLG_VX_SLIDER ); <br>    m_ht3d.hVySlider = GetDlgItem( hDlg, IDC_BUFFERDLG_VY_SLIDER ); <br>    m_ht3d.hVzSlider = GetDlgItem( hDlg, IDC_BUFFERDLG_VZ_SLIDER ); <br>    m_ht3d.hVxText = GetDlgItem( hDlg, IDC_BUFFERDLG_VX_TEXT ); <br>    m_ht3d.hVyText = GetDlgItem( hDlg, IDC_BUFFERDLG_VY_TEXT ); <br>    m_ht3d.hVzText = GetDlgItem( hDlg, IDC_BUFFERDLG_VZ_TEXT ); <br> <br>    m_ht3d.hOuterVolSlider = GetDlgItem( hDlg, IDC_BUFFERDLG_OUTERVOL_SLIDER ); <br>    m_ht3d.hOuterVolText = GetDlgItem( hDlg, IDC_BUFFERDLG_OUTERVOL_TEXT ); <br> <br>    m_ht3d.hInnerAngleEdit = GetDlgItem( hDlg, IDC_BUFFERDLG_INNERANGLE_EDIT ); <br>    m_ht3d.hInnerAngleSpin = GetDlgItem( hDlg, IDC_BUFFERDLG_INNERANGLE_SPIN ); <br>    m_ht3d.hOuterAngleEdit = GetDlgItem( hDlg, IDC_BUFFERDLG_OUTERANGLE_EDIT ); <br>    m_ht3d.hOuterAngleSpin = GetDlgItem( hDlg, IDC_BUFFERDLG_OUTERANGLE_SPIN ); <br> <br>    m_ht3d.hDisable3D = GetDlgItem( hDlg, IDC_BUFFERDLG_DISABLE ); <br> <br>    m_ht3d.hMaxDistSlider = GetDlgItem( hDlg, IDC_BUFFERDLG_MAXMUTE_SLIDER ); <br>    m_ht3d.hMaxDistText = GetDlgItem( hDlg, IDC_BUFFERDLG_MAXMUTE_TEXT ); <br>    m_ht3d.hMinDistSlider = GetDlgItem( hDlg, IDC_BUFFERDLG_MINDIST_SLIDER ); <br>    m_ht3d.hMinDistText = GetDlgItem( hDlg, IDC_BUFFERDLG_MINDIST_TEXT ); <br>    m_ht3d.hCurDistText = GetDlgItem( hDlg, IDC_BUFFERDLG_CURDIST_TEXT ); <br> <br> <br>    // The tab order in the dialog must be such that the spin control is <br>    // immediately after the edit control it is expected to auto-buddy to. <br>    // That case is tested here. <br>    ASSERT( (HWND)SendMessage( m_ht3d.hInnerAngleSpin, <br>                UDM_GETBUDDY, 0, 0 ) == m_ht3d.hInnerAngleEdit ); <br> <br>    // If this fails, the tab order in the dialog resource is wrong (see above) <br>    ASSERT( (HWND)SendMessage( m_ht3d.hOuterAngleSpin, <br>                UDM_GETBUDDY, 0, 0 ) == m_ht3d.hOuterAngleEdit ); <br> <br>    SendMessage( m_ht3d.hInnerAngleSpin, UDM_SETRANGE, 0, MAKELONG( 360, 0 )); <br>    SendMessage( m_ht3d.hOuterAngleSpin, UDM_SETRANGE, 0, MAKELONG( 360, 0 )); <br> <br>    SendMessage( m_ht3d.hInnerAngleSpin, UDM_SETPOS, <br>                 0, MAKELONG(m_dwInnerAngle, 0)); <br>    wsprintf( szTS, "%u", m_dwInnerAngle ); <br>    Edit_SetText( m_ht3d.hInnerAngleEdit, szTS ); <br> <br>    SendMessage( m_ht3d.hOuterAngleSpin, UDM_SETPOS, <br>                 0, MAKELONG(m_dwOuterAngle, 0)); <br>    wsprintf( szTS, "%u", m_dwOuterAngle ); <br>    Edit_SetText( m_ht3d.hOuterAngleEdit, szTS ); <br> <br>    if( m_pDSB3D ) <br>    { <br>        if( FAILED( hr = m_pDSB3D-&gt;SetConeAngles( m_dwInnerAngle, <br>                                                  m_dwOuterAngle, DS3D_IMMEDIATE ))) <br>            DPF( 0, "SetConeAngles: %s", TranslateDSError(hr)); <br> <br>        m_pDSB3D-&gt;GetPosition( &amp;m_vPos ); <br>        m_pDSB3D-&gt;GetVelocity( &amp;m_vVelo ); <br>        m_pDSB3D-&gt;SetMaxDistance( m_flMaxDistance, DS3D_IMMEDIATE ); <br>        m_pDSB3D-&gt;SetMinDistance( m_flMinDistance, DS3D_IMMEDIATE ); <br>    } <br> <br>    return FileInfo::OnInitDialog( hDlg, wParam ); <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>// <br>// <br>// <br>BOOL FileInfo3D::OnCommand( WPARAM wParam, LPARAM lParam ) <br>{ <br>    BOOL fRet = FALSE; <br> <br>    if( HandleOuterVolContext( wParam )  <br>        || HandlePositionContext( wParam ) <br>        || HandleVelocityContext( wParam ) )  <br>        fRet = TRUE; <br>    else if( HandleConeInnerEditNotify( wParam, lParam )) <br>        fRet = TRUE; <br>    else if( HandleConeOuterEditNotify( wParam, lParam )) <br>        fRet = TRUE; <br>    else if( HandleDisableNotify( wParam, lParam )) <br>        fRet = TRUE; <br>    else <br>        fRet = FileInfo::OnCommand( wParam, lParam ); <br> <br>    return fRet; <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// OnHScroll() <br>// <br>// <br>// <br>BOOL FileInfo3D::OnHScroll( WORD wNotification, LONG lPos, HWND hControl ) <br>{ <br>    if( !hControl ) <br>        return FALSE; <br>    if( hControl == m_ht3d.hOuterVolSlider ) <br>        HandleOuterVolSliderScroll( wNotification, lPos ); <br> <br>    else if( hControl == m_ht3d.hXSlider ) <br>        HandleXSliderScroll( wNotification, lPos ); <br>    else if( hControl == m_ht3d.hYSlider ) <br>        HandleYSliderScroll( wNotification, lPos ); <br>    else if( hControl == m_ht3d.hZSlider ) <br>        HandleZSliderScroll( wNotification, lPos ); <br> <br>    else if( hControl == m_ht3d.hVxSlider ) <br>        HandleVxSliderScroll( wNotification, lPos ); <br>    else if( hControl == m_ht3d.hVySlider ) <br>        HandleVySliderScroll( wNotification, lPos ); <br>    else if( hControl == m_ht3d.hVzSlider ) <br>        HandleVzSliderScroll( wNotification, lPos ); <br> <br>    else if( hControl == m_ht3d.hMaxDistSlider ) <br>        HandleMaxDistSliderScroll( wNotification, lPos ); <br>    else if( hControl == m_ht3d.hMinDistSlider ) <br>        HandleMinDistSliderScroll( wNotification, lPos ); <br>     <br>    // All messages we don't handle pass through to the base class <br>    else <br>        return FileInfo::OnHScroll( wNotification, lPos, hControl ); <br>     <br>    return TRUE; <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>// <br>// <br>// <br>void FileInfo3D::HandleOuterVolSliderScroll( WORD wNot, LONG lPos ) <br>{ <br>    HRESULT hr; <br>    BOOL fUpdate = TRUE; <br> <br>    switch( wNot ) <br>    { <br>        case TB_THUMBTRACK: <br>            break; <br> <br>        case TB_ENDTRACK: <br>        case TB_LINEDOWN: <br>        case TB_LINEUP: <br>        case TB_PAGEDOWN: <br>        case TB_PAGEUP: <br>            lPos = SendMessage( m_ht3d.hOuterVolSlider, TBM_GETPOS, 0, 0 ); <br>            break; <br> <br>        default: <br>            fUpdate = FALSE; <br>    } <br>     <br>    if( fUpdate &amp;&amp; NULL != m_pDSB3D ) <br>    { <br>        if( FAILED( hr = m_pDSB3D-&gt;SetConeOutsideVolume(( lPos * VOL_SLIDER_FACTOR ) <br>                        - VOL_SLIDER_SHIFT, DS3D_IMMEDIATE ))) <br>            DPF( 0, "SetConeOutsideVolume: %s", TranslateDSError(hr)); <br>        UpdateOuterVolUI(( lPos * VOL_SLIDER_FACTOR ) - VOL_SLIDER_SHIFT, <br>                                        FALSE ); <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>// <br>// <br>// <br>void FileInfo3D::HandleXSliderScroll( WORD wNot, LONG lPos ) <br>{ <br>    HRESULT hr; <br>    BOOL fUpdate = TRUE; <br> <br>    switch( wNot ) <br>    { <br>        case TB_THUMBTRACK: <br>            break; <br> <br>        case TB_ENDTRACK: <br>        case TB_LINEDOWN: <br>        case TB_LINEUP: <br>        case TB_PAGEDOWN: <br>        case TB_PAGEUP: <br>            lPos = SendMessage( m_ht3d.hXSlider, TBM_GETPOS, 0, 0 ); <br>            break; <br> <br>        default: <br>            fUpdate = FALSE; <br>    } <br>     <br>    if( fUpdate &amp;&amp; NULL != m_pDSB3D ) <br>    { <br>        m_vPos.x = D3DVAL(lPos * X_SLIDER_FACTOR) - POS_SLIDER_SHIFT; <br>        if( FAILED( hr = m_pDSB3D-&gt;SetPosition( m_vPos.x, m_vPos.y, <br>                            m_vPos.z, DS3D_IMMEDIATE ))) <br>            DPF( 0, "SetPosition: %s", TranslateDSError(hr)); <br>        UpdateXSliderUI((lPos * X_SLIDER_FACTOR) - POS_SLIDER_SHIFT, FALSE ); <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>// <br>// <br>// <br>void FileInfo3D::HandleYSliderScroll( WORD wNot, LONG lPos ) <br>{ <br>    HRESULT hr; <br>    BOOL fUpdate = TRUE; <br> <br>    switch( wNot ) <br>    { <br>        case TB_THUMBTRACK: <br>            break; <br> <br>        case TB_ENDTRACK: <br>        case TB_LINEDOWN: <br>        case TB_LINEUP: <br>        case TB_PAGEDOWN: <br>        case TB_PAGEUP: <br>            lPos = SendMessage( m_ht3d.hYSlider, TBM_GETPOS, 0, 0 ); <br>            break; <br> <br>        default: <br>            fUpdate = FALSE; <br>    } <br>     <br>    if( fUpdate &amp;&amp; NULL != m_pDSB3D ) <br>    { <br>        m_vPos.y = D3DVAL(lPos * Y_SLIDER_FACTOR) - POS_SLIDER_SHIFT; <br>        if( FAILED( hr = m_pDSB3D-&gt;SetPosition( m_vPos.x, m_vPos.y, <br>                            m_vPos.z, DS3D_IMMEDIATE ))) <br>            DPF( 0, "SetPosition: %s", TranslateDSError(hr)); <br>        UpdateYSliderUI((lPos * Y_SLIDER_FACTOR) - POS_SLIDER_SHIFT, FALSE ); <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>// <br>// <br>// <br>void FileInfo3D::HandleZSliderScroll( WORD wNot, LONG lPos ) <br>{ <br>    HRESULT hr; <br>    BOOL fUpdate = TRUE; <br> <br>    switch( wNot ) <br>    { <br>        case TB_THUMBTRACK: <br>            break; <br> <br>        case TB_ENDTRACK: <br>        case TB_LINEDOWN: <br>        case TB_LINEUP: <br>        case TB_PAGEDOWN: <br>        case TB_PAGEUP: <br>            lPos = SendMessage( m_ht3d.hZSlider, TBM_GETPOS, 0, 0 ); <br>            break; <br> <br>        default: <br>            fUpdate = FALSE; <br>    } <br>     <br>    if( fUpdate &amp;&amp; NULL != m_pDSB3D ) <br>    { <br>        m_vPos.z = D3DVAL(lPos * Z_SLIDER_FACTOR) - POS_SLIDER_SHIFT; <br>        if( FAILED( hr = m_pDSB3D-&gt;SetPosition( m_vPos.x, m_vPos.y, <br>                                                m_vPos.z, DS3D_IMMEDIATE ))) <br>            DPF( 0, "SetPosition: %s", TranslateDSError(hr)); <br>        UpdateZSliderUI((lPos * Z_SLIDER_FACTOR) - POS_SLIDER_SHIFT, FALSE ); <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>// <br>// <br>// <br>void FileInfo3D::HandleVxSliderScroll( WORD wNot, LONG lPos ) <br>{ <br>    HRESULT hr; <br>    BOOL fUpdate = TRUE; <br> <br>    switch( wNot ) <br>    { <br>        case TB_THUMBTRACK: <br>            break; <br> <br>        case TB_ENDTRACK: <br>        case TB_LINEDOWN: <br>        case TB_LINEUP: <br>        case TB_PAGEDOWN: <br>        case TB_PAGEUP: <br>            lPos = SendMessage( m_ht3d.hVxSlider, TBM_GETPOS, 0, 0 ); <br>            break; <br> <br>        default: <br>            fUpdate = FALSE; <br>    } <br>     <br>    if( fUpdate &amp;&amp; NULL != m_pDSB3D ) <br>    { <br>        m_vVelo.x = D3DVAL(lPos * X_SLIDER_FACTOR) - POS_SLIDER_SHIFT; <br>        if( FAILED( hr = m_pDSB3D-&gt;SetVelocity( m_vVelo.x, m_vVelo.y, <br>                            m_vVelo.z, DS3D_IMMEDIATE ))) <br>            DPF( 0, "SetVelocity: %s", TranslateDSError(hr)); <br>        UpdateVxSliderUI((lPos * X_SLIDER_FACTOR) - POS_SLIDER_SHIFT, FALSE ); <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>// <br>// <br>// <br>void FileInfo3D::HandleVySliderScroll( WORD wNot, LONG lPos ) <br>{ <br>    HRESULT hr; <br>    BOOL fUpdate = TRUE; <br> <br>    switch( wNot ) <br>    { <br>        case TB_THUMBTRACK: <br>            break; <br> <br>        case TB_ENDTRACK: <br>        case TB_LINEDOWN: <br>        case TB_LINEUP: <br>        case TB_PAGEDOWN: <br>        case TB_PAGEUP: <br>            lPos = SendMessage( m_ht3d.hVySlider, TBM_GETPOS, 0, 0 ); <br>            break; <br> <br>        default: <br>            fUpdate = FALSE; <br>    } <br>     <br>    if( fUpdate &amp;&amp; NULL != m_pDSB3D ) <br>    { <br>        m_vVelo.y = D3DVAL(lPos * Y_SLIDER_FACTOR) - POS_SLIDER_SHIFT; <br>        if( FAILED( hr = m_pDSB3D-&gt;SetVelocity( m_vVelo.x, m_vVelo.y, <br>                            m_vVelo.z, DS3D_IMMEDIATE ))) <br>            DPF( 0, "SetVelocity: %s", TranslateDSError(hr)); <br>        UpdateVySliderUI((lPos * Y_SLIDER_FACTOR) - POS_SLIDER_SHIFT, FALSE ); <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>// <br>// <br>// <br>void FileInfo3D::HandleVzSliderScroll( WORD wNot, LONG lPos ) <br>{ <br>    HRESULT hr; <br>    BOOL fUpdate = TRUE; <br> <br>    switch( wNot ) <br>    { <br>        case TB_THUMBTRACK: <br>            break; <br> <br>        case TB_ENDTRACK: <br>        case TB_LINEDOWN: <br>        case TB_LINEUP: <br>        case TB_PAGEDOWN: <br>        case TB_PAGEUP: <br>            lPos = SendMessage( m_ht3d.hVzSlider, TBM_GETPOS, 0, 0 ); <br>            break; <br> <br>        default: <br>            fUpdate = FALSE; <br>    } <br>     <br>    if( fUpdate &amp;&amp; NULL != m_pDSB3D ) <br>    { <br>        m_vVelo.z = D3DVAL(lPos * Z_SLIDER_FACTOR) - POS_SLIDER_SHIFT; <br>        if( FAILED( hr = m_pDSB3D-&gt;SetVelocity( m_vVelo.x, m_vVelo.y, <br>                                                m_vVelo.z, DS3D_IMMEDIATE ))) <br>            DPF( 0, "SetVelocity: %s", TranslateDSError(hr)); <br>        UpdateVzSliderUI((lPos * Z_SLIDER_FACTOR) - POS_SLIDER_SHIFT, FALSE ); <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// HandleMaxDistSliderScroll <br>// function:        handles WM_HSCROLL messages sent on behalf of IDC_BUFFERDLG_MAXMUTE_SLIDER <br>// <br>void FileInfo3D::HandleMaxDistSliderScroll( WORD wNot, LONG lPos ) <br>{ <br>    HRESULT hr; <br>    BOOL fUpdate = TRUE; <br> <br>    switch( wNot ) <br>    { <br>        case TB_THUMBTRACK: <br>            break; <br> <br>        case TB_ENDTRACK: <br>        case TB_LINEDOWN: <br>        case TB_LINEUP: <br>        case TB_PAGEDOWN: <br>        case TB_PAGEUP: <br>            lPos = SendMessage( m_ht3d.hMaxDistSlider, TBM_GETPOS, 0, 0 ); <br>            break; <br> <br>        default: <br>            fUpdate = FALSE; <br>    } <br>     <br>    if( fUpdate &amp;&amp; NULL != m_pDSB3D ) <br>    { <br>        m_flMaxDistance = D3DVAL(lPos * MUTEMAX_SLIDER_FACTOR); <br>        if( FAILED( hr = m_pDSB3D-&gt;SetMaxDistance( m_flMaxDistance, DS3D_IMMEDIATE ))) <br>        { <br>            DPF( 0, "SetPosition: %s", TranslateDSError(hr)); <br>        } <br> <br>        UpdateMuteMaxSliderUI((lPos * MUTEMAX_SLIDER_FACTOR), FALSE ); <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// HandleMinDistSliderScroll <br>// function:        handles WM_HSCROLL messages sent on behalf of IDC_BUFFERDLG_MINDIST_SLIDER <br>// <br>void FileInfo3D::HandleMinDistSliderScroll( WORD wNot, LONG lPos ) <br>{ <br>    HRESULT hr; <br>    BOOL fUpdate = TRUE; <br> <br>    switch( wNot ) <br>    { <br>        case TB_THUMBTRACK: <br>            break; <br> <br>        case TB_ENDTRACK: <br>        case TB_LINEDOWN: <br>        case TB_LINEUP: <br>        case TB_PAGEDOWN: <br>        case TB_PAGEUP: <br>            lPos = SendMessage( m_ht3d.hMinDistSlider, TBM_GETPOS, 0, 0 ); <br>            break; <br> <br>        default: <br>            fUpdate = FALSE; <br>    } <br>     <br>    if( fUpdate &amp;&amp; NULL != m_pDSB3D ) <br>    { <br>        m_flMinDistance = D3DVAL(lPos * MINDIST_SLIDER_FACTOR); <br>        if( FAILED( hr = m_pDSB3D-&gt;SetMinDistance( m_flMinDistance, DS3D_IMMEDIATE ))) <br>        { <br>            DPF( 0, "SetPosition: %s", TranslateDSError(hr)); <br>        } <br> <br>        UpdateMinDistSliderUI((lPos * MINDIST_SLIDER_FACTOR), FALSE ); <br>    } <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// UpdateOuterVolUI() <br>// <br>// <br>// <br>// <br>// <br>void FileInfo3D::UpdateOuterVolUI( LONG lForceVol, BOOL fFromBuffer ) <br>{ <br>    HRESULT hr; <br>    LONG    lVol; <br>    TCHAR   szText[16]; <br> <br>    if( fFromBuffer ) <br>    { <br>        if( NULL != m_pDSB3D ) <br>        { <br>            if( FAILED( hr = m_pDSB3D-&gt;GetConeOutsideVolume( &amp;lVol ))) <br>            DPF( 0, "GetConeOutsideVolume: %s", TranslateDSError(hr)); <br>        } <br>        else <br>            lVol = 0; <br>    } <br>    else <br>        lVol = lForceVol; <br> <br>    SendMessage( m_ht3d.hOuterVolSlider, TBM_SETPOS, (WPARAM)TRUE, <br>                 (LPARAM)(lVol + VOL_SLIDER_SHIFT) / VOL_SLIDER_FACTOR ); <br> <br>    // Print volume in decibels <br>    wsprintf( szText, "%i dB", lVol / 100 ); <br> <br>    Static_SetText( m_ht3d.hOuterVolText, szText ); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>// <br>// <br>// <br>BOOL FileInfo3D::OnContextMenu( HWND hDlg, int x, int y ) <br>{ <br>    HMENU   hm, hSub; <br>    int     nSubMenu = -1; <br>    POINT   pt = { x, y }; <br>    RECT    rectWind1, rectWind2, rectWind3; <br> <br>    // Set the sub-menu to the Outer Volume context menu if we hit the proper <br>    // slider or text control <br>    GetWindowRect( m_ht3d.hOuterVolSlider, &amp;rectWind1 ); <br>    GetWindowRect( m_ht3d.hOuterVolText, &amp;rectWind2 ); <br> <br>    if( PtInRect( &amp;rectWind1, pt ) || PtInRect( &amp;rectWind2, pt )) <br>        nSubMenu = 3; <br> <br>    // Set the POS_CONTEXT submenu if there's a click on the position sliders <br>    // or text controls <br>    GetWindowRect( m_ht3d.hXSlider, &amp;rectWind1 ); <br>    GetWindowRect( m_ht3d.hYSlider, &amp;rectWind2 ); <br>    GetWindowRect( m_ht3d.hZSlider, &amp;rectWind3 ); <br> <br>    if( PtInRect( &amp;rectWind1, pt ) || PtInRect( &amp;rectWind2, pt ) <br>        || PtInRect( &amp;rectWind3, pt )) <br>        nSubMenu = 4; <br> <br>    GetWindowRect( m_ht3d.hXText, &amp;rectWind1 ); <br>    GetWindowRect( m_ht3d.hYText, &amp;rectWind2 ); <br>    GetWindowRect( m_ht3d.hZText, &amp;rectWind3 ); <br> <br>    if( PtInRect( &amp;rectWind1, pt ) || PtInRect( &amp;rectWind2, pt ) <br>        || PtInRect( &amp;rectWind3, pt )) <br>        nSubMenu = 4; <br> <br>    // Set the VELO_CONTEXT submenu if there's a click on the position sliders <br>    // or text controls <br>    GetWindowRect( m_ht3d.hVxSlider, &amp;rectWind1 ); <br>    GetWindowRect( m_ht3d.hVySlider, &amp;rectWind2 ); <br>    GetWindowRect( m_ht3d.hVzSlider, &amp;rectWind3 ); <br> <br>    if( PtInRect( &amp;rectWind1, pt ) || PtInRect( &amp;rectWind2, pt ) <br>        || PtInRect( &amp;rectWind3, pt )) <br>        nSubMenu = 5; <br> <br>    GetWindowRect( m_ht3d.hVxText, &amp;rectWind1 ); <br>    GetWindowRect( m_ht3d.hVyText, &amp;rectWind2 ); <br>    GetWindowRect( m_ht3d.hVzText, &amp;rectWind3 ); <br> <br>    if( PtInRect( &amp;rectWind1, pt ) || PtInRect( &amp;rectWind2, pt ) <br>        || PtInRect( &amp;rectWind3, pt )) <br>        nSubMenu = 5; <br> <br>    // We didn't detect any "interesting" hotspots, so pass along to base class <br>    if( nSubMenu &lt; 0 ) <br>        return FileInfo::OnContextMenu( hDlg, x, y ); <br> <br>    // If we make it here, we're gonna popup a context menu of some sort <br> <br>    // Attempt to load our menu.  If we fail, we still handled the message <br>    // so return TRUE <br>    if(( hm = LoadMenu( ghInst, MAKEINTRESOURCE(IDM_POPUPS))) == NULL ) <br>        return TRUE; <br> <br>    hSub = GetSubMenu( hm, nSubMenu ); <br>    TrackPopupMenu( hSub, TPM_LEFTALIGN | TPM_RIGHTBUTTON, <br>                    pt.x, pt.y, 0, m_hwndInterface, NULL ); <br>     <br>    DestroyMenu( hm ); <br> <br>    return TRUE; <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>// <br>// <br>// <br>void FileInfo3D::OnDestroy() <br>{ <br>    FileInfo::OnDestroy(); <br>    return; <br>} <br> <br> <br>void FileInfo3D::Duplicate( FileInfo *pfiSource ) <br>{ <br>    HRESULThr; <br> <br>    FileInfo::Duplicate( pfiSource ); <br> <br>    if( FAILED( hr = m_pDSB-&gt;QueryInterface( IID_IDirectSound3DBuffer, <br>                                             (void **)&amp;m_pDSB3D ))) <br>    { <br>        DPF( 0, "QI for DS3DBuffer interface: %s", TranslateDSError(hr)); <br>    } <br>    else <br>    { <br>        // Update the UI from the interface we just got <br>        UpdateOuterVolUI( 0, TRUE ); <br>        UpdateXSliderUI( 0, TRUE ); <br>        UpdateYSliderUI( 0, TRUE ); <br>        UpdateZSliderUI( 0, TRUE ); <br>        UpdateVxSliderUI( 0, TRUE ); <br>        UpdateVySliderUI( 0, TRUE ); <br>        UpdateVzSliderUI( 0, TRUE ); <br> <br>        m_pDSB3D-&gt;GetConeAngles( &amp;m_dwInnerAngle, &amp;m_dwOuterAngle ); <br> <br>// update the UI. <br>UpdateMinDistSliderUI( 0, TRUE ); <br>UpdateMuteMaxSliderUI(0, TRUE); <br> <br>        DWORDdwMode; <br>        TCHARszTS[6]; <br> <br>        SendMessage( m_ht3d.hInnerAngleSpin, UDM_SETPOS, <br>                     0, MAKELONG(m_dwInnerAngle, 0)); <br>        wsprintf( szTS, "%u", m_dwInnerAngle ); <br>        Edit_SetText( m_ht3d.hInnerAngleEdit, szTS ); <br> <br>        SendMessage( m_ht3d.hOuterAngleSpin, UDM_SETPOS, <br>                     0, MAKELONG(m_dwOuterAngle, 0)); <br>        wsprintf( szTS, "%u", m_dwOuterAngle ); <br>        Edit_SetText( m_ht3d.hOuterAngleEdit, szTS ); <br> <br>        m_pDSB3D-&gt;GetMode( &amp;dwMode ); <br>        Button_SetCheck( m_ht3d.hDisable3D, dwMode == DS3DMODE_DISABLE ); <br>    } <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// CreateInterface() <br>//  <br>//    Very similar to the interface creation code for 2D objects, but creates a <br>// different dialog.  (Eventually may do more stuff related to D3D display). <br>// <br>BOOL FileInfo3D::CreateInterface( HWND hwndOwner ) <br>{ <br>    m_hwndInterface = CreateDialogParam( ghInst, MAKEINTRESOURCE(IDD_BUFFER3D), <br>                                         hwndOwner, (DLGPROC)FileInfo3DDlgProc, <br>                                         (LPARAM)this ); <br> <br>    if( NULL == m_hwndInterface ) <br>        goto FICI_Fail; <br>    else <br>        UpdateFileName(); <br> <br>    CascadeWindow(); <br>    ShowWindow( m_hwndInterface, SW_SHOW ); <br> <br>    // This flag tells us an interface window was successfully created <br>    m_dwInternalFlags |= FI_INTERNALF_INTERFACE; <br>    return TRUE; <br> <br> <br>FICI_Fail: <br>    if( m_hwndInterface ) <br>    { <br>        DestroyWindow( m_hwndInterface ); <br>        m_hwndInterface = NULL; <br>    } <br>    // Clear the flag that says we have a good interface window created <br>    m_dwInternalFlags &amp;= ~FI_INTERNALF_INTERFACE; <br>    return FALSE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>// <br>// <br>// <br>void FileInfo3D::SetSliders( void ) <br>{ <br>    // Do 3D controls slider initialization <br> <br>    // Intentionally set the range backwards because a large number means <br>    // a smaller value <br>    SendMessage( m_ht3d.hOuterVolSlider, TBM_SETRANGEMIN, FALSE, <br>                 (LPARAM)(VOL_MIN + VOL_SLIDER_SHIFT) / VOL_SLIDER_FACTOR ); <br>    SendMessage( m_ht3d.hOuterVolSlider, TBM_SETRANGEMAX, FALSE, <br>                 (LPARAM)(VOL_MAX + VOL_SLIDER_SHIFT) / VOL_SLIDER_FACTOR ); <br>    SendMessage( m_ht3d.hOuterVolSlider, TBM_SETPAGESIZE, 0, <br>                 VOL_SLIDER_PAGE / VOL_SLIDER_FACTOR ); <br>    // NOTE: No TICs on the cone volume slider <br> <br>    // position sliders <br>    SendMessage( m_ht3d.hXSlider, TBM_SETRANGEMIN, FALSE, <br>                 (LPARAM)(POS_SLIDER_MIN + POS_SLIDER_SHIFT) / X_SLIDER_FACTOR ); <br>    SendMessage( m_ht3d.hXSlider, TBM_SETRANGEMAX, FALSE, <br>                 (LPARAM)(POS_SLIDER_MAX + POS_SLIDER_SHIFT) / X_SLIDER_FACTOR ); <br>    SendMessage( m_ht3d.hXSlider, TBM_SETPAGESIZE, 0, X_SLIDER_FACTOR ); <br> <br>    SendMessage( m_ht3d.hYSlider, TBM_SETRANGEMIN, FALSE, <br>                 (LPARAM)(POS_SLIDER_MIN + POS_SLIDER_SHIFT) / Y_SLIDER_FACTOR ); <br>    SendMessage( m_ht3d.hYSlider, TBM_SETRANGEMAX, FALSE, <br>                 (LPARAM)(POS_SLIDER_MAX + POS_SLIDER_SHIFT) / Y_SLIDER_FACTOR ); <br>    SendMessage( m_ht3d.hYSlider, TBM_SETPAGESIZE, 0, Y_SLIDER_FACTOR ); <br> <br>    SendMessage( m_ht3d.hZSlider, TBM_SETRANGEMIN, FALSE, <br>                 (LPARAM)(POS_SLIDER_MIN + POS_SLIDER_SHIFT) / Z_SLIDER_FACTOR ); <br>    SendMessage( m_ht3d.hZSlider, TBM_SETRANGEMAX, FALSE, <br>                 (LPARAM)(POS_SLIDER_MAX + POS_SLIDER_SHIFT) / Z_SLIDER_FACTOR ); <br>    SendMessage( m_ht3d.hZSlider, TBM_SETPAGESIZE, 0, Z_SLIDER_FACTOR ); <br> <br>    // velocity sliders <br>    SendMessage( m_ht3d.hVxSlider, TBM_SETRANGEMIN, FALSE, <br>                 (LPARAM)(POS_SLIDER_MIN + POS_SLIDER_SHIFT) / X_SLIDER_FACTOR ); <br>    SendMessage( m_ht3d.hVxSlider, TBM_SETRANGEMAX, FALSE, <br>                 (LPARAM)(POS_SLIDER_MAX + POS_SLIDER_SHIFT) / X_SLIDER_FACTOR ); <br>    SendMessage( m_ht3d.hVxSlider, TBM_SETPAGESIZE, 0, X_SLIDER_FACTOR ); <br> <br>    SendMessage( m_ht3d.hVySlider, TBM_SETRANGEMIN, FALSE, <br>                 (LPARAM)(POS_SLIDER_MIN + POS_SLIDER_SHIFT) / Y_SLIDER_FACTOR ); <br>    SendMessage( m_ht3d.hVySlider, TBM_SETRANGEMAX, FALSE, <br>                 (LPARAM)(POS_SLIDER_MAX + POS_SLIDER_SHIFT) / Y_SLIDER_FACTOR ); <br>    SendMessage( m_ht3d.hVySlider, TBM_SETPAGESIZE, 0, Y_SLIDER_FACTOR ); <br> <br>    SendMessage( m_ht3d.hVzSlider, TBM_SETRANGEMIN, FALSE, <br>                 (LPARAM)(POS_SLIDER_MIN + POS_SLIDER_SHIFT) / Z_SLIDER_FACTOR ); <br>    SendMessage( m_ht3d.hVzSlider, TBM_SETRANGEMAX, FALSE, <br>                 (LPARAM)(POS_SLIDER_MAX + POS_SLIDER_SHIFT) / Z_SLIDER_FACTOR ); <br>    SendMessage( m_ht3d.hVzSlider, TBM_SETPAGESIZE, 0, Z_SLIDER_FACTOR ); <br> <br>    // max distance slider <br>    SendMessage( m_ht3d.hMaxDistSlider, TBM_SETRANGEMIN, FALSE, <br>                 (LPARAM)(MUTEMAX_SLIDER_MIN) / MUTEMAX_SLIDER_FACTOR ); <br>    SendMessage( m_ht3d.hMaxDistSlider, TBM_SETRANGEMAX, FALSE, <br>                 (LPARAM)(MUTEMAX_SLIDER_MAX) / MUTEMAX_SLIDER_FACTOR ); <br>    SendMessage( m_ht3d.hMaxDistSlider, TBM_SETPAGESIZE, 0, MUTEMAX_SLIDER_FACTOR ); <br> <br>    // Min distance slider <br>    SendMessage( m_ht3d.hMinDistSlider, TBM_SETRANGEMIN, FALSE, <br>                 (LPARAM)(MINDIST_SLIDER_MIN) / MINDIST_SLIDER_FACTOR ); <br>    SendMessage( m_ht3d.hMinDistSlider, TBM_SETRANGEMAX, FALSE, <br>                 (LPARAM)(MINDIST_SLIDER_MAX) / MINDIST_SLIDER_FACTOR ); <br>    SendMessage( m_ht3d.hMinDistSlider, TBM_SETPAGESIZE, 0, MINDIST_SLIDER_FACTOR ); <br> <br>//    SendMessage( m_ht3d.hOuterVolSlider, TBM_SETPAGESIZE, 0, <br>//            VOL_SLIDER_PAGE / VOL_SLIDER_FACTOR ); <br>    // NOTE: No TICs on the position sliders <br> <br>    // Update the display from the buffer's current settings <br>    UpdateOuterVolUI( 0, TRUE ); <br>    UpdateXSliderUI( 0, TRUE ); <br>    UpdateYSliderUI( 0, TRUE ); <br>    UpdateZSliderUI( 0, TRUE ); <br>    UpdateVxSliderUI( 0, TRUE ); <br>    UpdateVySliderUI( 0, TRUE ); <br>    UpdateVzSliderUI( 0, TRUE ); <br>    UpdateMuteMaxSliderUI( 0, TRUE ); <br>    UpdateMinDistSliderUI( 0, TRUE ); <br> <br>    FileInfo::SetSliders(); <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>// <br>// <br>// <br>void FileInfo3D::UpdateUI( void ) <br>{ <br>    UpdatePosAndVelo(); <br>    UpdateCurrentDistUI(); <br>    UpdateXSliderUI( 0, TRUE ); <br>    UpdateYSliderUI( 0, TRUE ); <br>    UpdateZSliderUI( 0, TRUE ); <br>    FileInfo::UpdateUI(); <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// UpdateFileName() <br>// <br>//    Updates the file name which is displayed in the dialog window caption. <br>// <br>void FileInfo3D::UpdateFileName( void ) <br>{ <br>    TCHAR   szTitle[MAX_PATH + 5]; <br> <br>    if( NULL != m_hwndInterface ) <br>    { <br>        lstrcpy( szTitle, &amp;m_szFileName[m_nFileIndex] ); <br>        lstrcat( szTitle, TEXT(" (3D)")); <br>        SendMessage( m_hwndInterface, WM_SETTEXT, 0L, (LPARAM)szTitle ); <br>    } <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// FileInfo3DDlgProc() <br>// <br>//     <br>// <br>BOOL CALLBACK FileInfo3DDlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam ) <br>{ <br>    FileInfo3D *pfi3d; <br> <br>    switch( message ) <br>    { <br>        // The first step is to stash our class object pointer in the user data <br>        // and Initialize all our controls and internal data members. <br>        case WM_INITDIALOG: <br>            ASSERT( NULL != lParam ); <br>            pfi3d = (FileInfo3D *)lParam; <br>            SetWindowLong( hDlg, DWL_USER, (LONG)pfi3d ); <br> <br>            if( !pfi3d-&gt;OnInitDialog( hDlg, wParam )) <br>            { <br>            DestroyWindow( hDlg ); <br>            } <br>            return TRUE; <br> <br>        case WM_COMMAND: <br>            pfi3d = (FileInfo3D*)GetWindowLong( hDlg, DWL_USER ); </code></pre>
<p>
</p>
<pre><code>// It's possible to get notification messages from child controls <br>            // before we have been given a WM_INITDIALOG message.  This is not <br>            // a good thing for dereferencing the pointer because we won't have <br>            // class info. Specifically, the spin controls in our dialog force <br>            // the edit control to send EN_CHANGE and EN_UPDATE messages when <br>            // they set the text of the edit control they're tied to. <br>            if( NULL == pfi3d || NULL == pfi3d-&gt;m_hwndInterface ) <br>            return FALSE; <br>            return !pfi3d-&gt;OnCommand( wParam, lParam ); <br> <br>        // Handle this to deal with right-clicks on our controls -- we have a <br>        // bunch of different context menus that we can popup <br>        case WM_CONTEXTMENU: <br>            pfi3d = (FileInfo3D*)GetWindowLong( hDlg, DWL_USER ); <br>            ASSERT( NULL != pfi3d ); <br>            return pfi3d-&gt;OnContextMenu( hDlg, LOWORD(lParam), HIWORD(lParam)); <br> <br>        // Trackbar slider notifications come through here <br>        case WM_HSCROLL: <br>            pfi3d = (FileInfo3D*)GetWindowLong( hDlg, DWL_USER ); <br>            ASSERT( NULL != pfi3d ); <br>            return pfi3d-&gt;OnHScroll( LOWORD(wParam), (LONG)HIWORD(wParam), (HWND)lParam ); <br> <br>        case WM_DESTROY: <br>            pfi3d = (FileInfo3D*)GetWindowLong( hDlg, DWL_USER ); <br>            ASSERT( NULL != pfi3d ); <br>            pfi3d-&gt;OnDestroy(); <br>            return TRUE; <br> <br>        default: <br>            return FileInfoDlgProc( hDlg, message, wParam, lParam ); <br>    } <br> <br>    ASSERT( FALSE ); <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// HandleOuterVolContext() <br>// <br>//    Pre-process the parameters to WM_COMMAND messages we get and sees if we <br>// knows how to handle any of them.  We know how to handle any message that <br>// comes from the Outer Volume controls' context menu. <br>// <br>BOOL FileInfo3D::HandleOuterVolContext( WPARAM wParam ) <br>{ <br>    HRESULT hr; <br> <br>    switch( wParam ) <br>    { <br>        case ID_OUTERVOLCONTEXT_0DB: <br>            if( FAILED( hr = m_pDSB3D-&gt;SetConeOutsideVolume( 0, <br>                                    DS3D_IMMEDIATE ))) <br>            DPF( 0, "SetConeOutsideVolume: %s", TranslateDSError(hr)); <br>            UpdateOuterVolUI( 0, TRUE ); <br>            break; <br> <br>        case ID_OUTERVOLCONTEXT_10DB: <br>            if( FAILED( hr = m_pDSB3D-&gt;SetConeOutsideVolume( -1000, <br>                                    DS3D_IMMEDIATE ))) <br>            DPF( 0, "SetConeOutsideVolume: %s", TranslateDSError(hr)); <br>            UpdateOuterVolUI( -1000, TRUE ); <br>            break; <br> <br>        case ID_OUTERVOLCONTEXT_20DB: <br>            if( FAILED( hr = m_pDSB3D-&gt;SetConeOutsideVolume( -2000, <br>                                    DS3D_IMMEDIATE ))) <br>            DPF( 0, "SetConeOutsideVolume: %s", TranslateDSError(hr)); <br>            UpdateOuterVolUI( -2000, TRUE ); <br>            break; <br> <br>        case ID_OUTERVOLCONTEXT_30DB: <br>            if( FAILED( hr = m_pDSB3D-&gt;SetConeOutsideVolume( -3000, <br>                                    DS3D_IMMEDIATE ))) <br>            DPF( 0, "SetConeOutsideVolume: %s", TranslateDSError(hr)); <br>            UpdateOuterVolUI( -3000, TRUE ); <br>            break; <br> <br>        case ID_OUTERVOLCONTEXT_100DB: <br>            if( FAILED( hr = m_pDSB3D-&gt;SetConeOutsideVolume( -10000, <br>                                    DS3D_IMMEDIATE ))) <br>            DPF( 0, "SetConeOutsideVolume: %s", TranslateDSError(hr)); <br>            UpdateOuterVolUI( -10000, TRUE ); <br>            break; <br> <br>        default: <br>            return FALSE; <br>    } <br> <br>    return TRUE; <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// HandlePositionContext() <br>// <br>//    Pre-process the parameters to WM_COMMAND messages we get and sees if we <br>// knows how to handle any of them.  We know how to handle any message that <br>// comes from the Position controls' context menu. <br>// <br>BOOL FileInfo3D::HandlePositionContext( WPARAM wParam ) <br>{ <br>    D3DVECTORd3dListener; <br> <br>    switch( wParam ) <br>    { <br>        case ID_POSCONTEXT_ORIGIN: <br>            ASSERT( NULL != m_pDSB3D ); <br>            m_pDSB3D-&gt;SetPosition( D3DVAL(0), D3DVAL(0), D3DVAL(0), DS3D_IMMEDIATE ); <br>            UpdateXSliderUI( 0, TRUE ); <br>            UpdateYSliderUI( 0, TRUE ); <br>            UpdateZSliderUI( 0, TRUE ); <br>            break; <br> <br>        case ID_POSCONTEXT_LISTENERPOSITION: <br>            ASSERT( NULL != m_pDSB3D ); <br>            ASSERT( NULL != gp3DListener ); <br>            gp3DListener-&gt;GetPosition( &amp;d3dListener ); <br>            m_pDSB3D-&gt;SetPosition( d3dListener.x, d3dListener.y, <br>                        d3dListener.z, DS3D_IMMEDIATE ); <br>            UpdateXSliderUI( (DWORD)d3dListener.x, TRUE ); <br>            UpdateYSliderUI( (DWORD)d3dListener.y, TRUE ); <br>            UpdateZSliderUI( (DWORD)d3dListener.z, TRUE ); <br>            break; <br> <br>        default: <br>            return FALSE; <br>    } <br> <br>    return TRUE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// HandleVelocityContext() <br>// <br>//    Pre-process the parameters to WM_COMMAND messages we get and sees if we <br>// knows how to handle any of them.  We know how to handle any message that <br>// comes from the Position controls' context menu. <br>// <br>BOOL FileInfo3D::HandleVelocityContext( WPARAM wParam ) <br>{ <br>    switch( wParam ) <br>    { <br>        case ID_VELOCONTEXT_ORIGIN: <br>            ASSERT( NULL != m_pDSB3D ); <br>            m_pDSB3D-&gt;SetVelocity( D3DVAL(0), D3DVAL(0), D3DVAL(0), DS3D_IMMEDIATE ); <br>            UpdateVxSliderUI( 0, TRUE ); <br>            UpdateVySliderUI( 0, TRUE ); <br>            UpdateVzSliderUI( 0, TRUE ); <br>            m_vVelo.x = m_vVelo.y = m_vVelo.z = 0.f; <br>            break; <br> <br>        default: <br>            return FALSE; <br>    } <br> <br>    return TRUE; <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// UpdateXSliderUI() <br>// <br>//    Update anything that displays the position of the X slider in some manner <br>// to reflect the new position, either from the buffer or from the parameter. <br>// <br>void FileInfo3D::UpdateXSliderUI( LONG lForcePos, BOOL fFromBuffer ) <br>{ <br>    TCHAR   szText[8]; <br>    LONG    lPos; <br> <br>    if( fFromBuffer ) <br>    { <br>        if( NULL != m_pDSB3D ) <br>        { <br>            m_pDSB3D-&gt;GetPosition( &amp;m_vPos ); <br>            lPos = (LONG)m_vPos.x; <br>        } <br>        else <br>            lPos = 0; <br>    } <br>    else <br>        lPos = lForcePos; <br> <br>    SendMessage( m_ht3d.hXSlider, TBM_SETPOS, (WPARAM)TRUE, <br>                 (LPARAM)(lPos + POS_SLIDER_SHIFT) / X_SLIDER_FACTOR ); <br>    wsprintf( szText, "%i", lPos ); <br>    Static_SetText( m_ht3d.hXText, szText ); <br> <br>    // anything that updates position will change the current distance <br>    UpdateCurrentDistUI(); <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// UpdateYSliderUI() <br>// <br>//    Update anything that displays the position of the Y slider in some manner <br>// to reflect the new position, either from the buffer or from the parameter. <br>// <br>void FileInfo3D::UpdateYSliderUI( LONG lForcePos, BOOL fFromBuffer ) <br>{ <br>    TCHAR   szText[8]; <br>    LONG    lPos; <br> <br>    if( fFromBuffer ) <br>    { <br>        if( NULL != m_pDSB3D ) <br>        { <br>            m_pDSB3D-&gt;GetPosition( &amp;m_vPos ); <br>            lPos = (LONG)m_vPos.y; <br>        } <br>        else <br>            lPos = 0; <br>    } <br>    else <br>        lPos = lForcePos; <br> <br>    SendMessage( m_ht3d.hYSlider, TBM_SETPOS, (WPARAM)TRUE, <br>                 (LPARAM)(lPos + POS_SLIDER_SHIFT) / Y_SLIDER_FACTOR ); <br>    wsprintf( szText, "%i", lPos ); <br>    Static_SetText( m_ht3d.hYText, szText ); <br> <br>    // anything that updates position will change the current distance <br>    UpdateCurrentDistUI(); <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// UpdateZSliderUI() <br>// <br>//    Update anything that displays the position of the Z slider in some manner <br>// to reflect the new position, either from the buffer or from the parameter. <br>// <br>void FileInfo3D::UpdateZSliderUI( LONG lForcePos, BOOL fFromBuffer ) <br>{ <br>    TCHARszText[8]; <br>    LONG    lPos; <br> <br>    if( fFromBuffer ) <br>    { <br>        if( NULL != m_pDSB3D ) <br>        { <br>            m_pDSB3D-&gt;GetPosition( &amp;m_vPos ); <br>            lPos = (LONG)m_vPos.z; <br>        } <br>        else <br>            lPos = 0; <br>    } <br>    else <br>        lPos = lForcePos; <br> <br>    SendMessage( m_ht3d.hZSlider, TBM_SETPOS, (WPARAM)TRUE, <br>            (LPARAM)(lPos + POS_SLIDER_SHIFT) / Z_SLIDER_FACTOR ); <br>    wsprintf( szText, "%i", lPos ); <br>    Static_SetText( m_ht3d.hZText, szText ); <br> <br>    // anything that updates position will change the current distance <br>    UpdateCurrentDistUI(); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// UpdateVxSliderUI() <br>// <br>//    Update anything that displays the position of the Vx slider in some manner <br>// to reflect the new position, either from the buffer or from the parameter. <br>// <br>void FileInfo3D::UpdateVxSliderUI( LONG lForcePos, BOOL fFromBuffer ) <br>{ <br>    TCHAR   szText[8]; <br>    LONG    lPos; <br> <br>    if( fFromBuffer ) <br>    { <br>        if( NULL != m_pDSB3D ) <br>        { <br>            m_pDSB3D-&gt;GetVelocity( &amp;m_vVelo ); <br>            lPos = (LONG)m_vVelo.x; <br>        } <br>        else <br>            lPos = 0; <br>    } <br>    else <br>        lPos = lForcePos; <br> <br>    SendMessage( m_ht3d.hVxSlider, TBM_SETPOS, (WPARAM)TRUE, <br>                 (LPARAM)(lPos + POS_SLIDER_SHIFT) / X_SLIDER_FACTOR ); <br>    wsprintf( szText, "%i", lPos ); <br>    Static_SetText( m_ht3d.hVxText, szText ); <br> <br>    // anything that updates position will change the current distance <br>    UpdateCurrentDistUI(); <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// UpdateVySliderUI() <br>// <br>//    Update anything that displays the position of the Vy slider in some manner <br>// to reflect the new position, either from the buffer or from the parameter. <br>// <br>void FileInfo3D::UpdateVySliderUI( LONG lForcePos, BOOL fFromBuffer ) <br>{ <br>    TCHAR   szText[8]; <br>    LONG    lPos; <br> <br>    if( fFromBuffer ) <br>    { <br>        if( NULL != m_pDSB3D ) <br>        { <br>            m_pDSB3D-&gt;GetVelocity( &amp;m_vVelo ); <br>            lPos = (LONG)m_vVelo.y; <br>        } <br>        else <br>            lPos = 0; <br>    } <br>    else <br>        lPos = lForcePos; <br> <br>    SendMessage( m_ht3d.hVySlider, TBM_SETPOS, (WPARAM)TRUE, <br>                 (LPARAM)(lPos + POS_SLIDER_SHIFT) / Y_SLIDER_FACTOR ); <br>    wsprintf( szText, "%i", lPos ); <br>    Static_SetText( m_ht3d.hVyText, szText ); <br> <br>    // anything that updates position will change the current distance <br>    UpdateCurrentDistUI(); <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// UpdateVzSliderUI() <br>// <br>//    Update anything that displays the position of the Vz slider in some manner <br>// to reflect the new position, either from the buffer or from the parameter. <br>// <br>void FileInfo3D::UpdateVzSliderUI( LONG lForcePos, BOOL fFromBuffer ) <br>{ <br>    TCHARszText[8]; <br>    LONG    lPos; <br> <br>    if( fFromBuffer ) <br>    { <br>        if( NULL != m_pDSB3D ) <br>        { <br>            m_pDSB3D-&gt;GetVelocity( &amp;m_vVelo ); <br>            lPos = (LONG)m_vVelo.z; <br>        } <br>        else <br>            lPos = 0; <br>    } <br>    else <br>        lPos = lForcePos; <br> <br>    SendMessage( m_ht3d.hVzSlider, TBM_SETPOS, (WPARAM)TRUE, <br>            (LPARAM)(lPos + POS_SLIDER_SHIFT) / Z_SLIDER_FACTOR ); <br>    wsprintf( szText, "%i", lPos ); <br>    Static_SetText( m_ht3d.hVzText, szText ); <br> <br>    // anything that updates position will change the current distance <br>    UpdateCurrentDistUI(); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// UpdateMuteMaxSliderUI() <br>// <br>// function:    Update anything that displays the position of the MaxDistance <br>//              slider in some manner to reflect the new position, either from  <br>//              the buffer or from the parameter. <br>// <br>void FileInfo3D::UpdateMuteMaxSliderUI( LONG lForcePos, BOOL fFromBuffer ) <br>{ <br>    TCHARszText[8]; <br>    LONG    lPos; <br> <br>    if( fFromBuffer ) <br>    { <br>        if( NULL != m_pDSB3D ) <br>        { <br>            m_pDSB3D-&gt;GetMaxDistance( &amp;m_flMaxDistance ); <br>            lPos = (LONG)m_flMaxDistance; <br>        } <br>        else <br>        { <br>            lPos = 0; <br>        } <br>    } <br>    else <br>    { <br>        lPos = lForcePos; <br>    } <br> <br>    SendMessage( m_ht3d.hMaxDistSlider, TBM_SETPOS, (WPARAM)TRUE, <br>                 (LPARAM)lPos / MUTEMAX_SLIDER_FACTOR ); <br> <br>    wsprintf( szText, "%i", lPos ); <br>    Static_SetText( m_ht3d.hMaxDistText, szText ); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// UpdateMinDistSliderUI() <br>// <br>// function:    Update anything that displays the position of the MinDistance <br>//              slider in some manner to reflect the new position, either from  <br>//              the buffer or from the parameter. <br>// <br>void FileInfo3D::UpdateMinDistSliderUI( LONG lForcePos, BOOL fFromBuffer ) <br>{ <br>    TCHARszText[8]; <br>    LONG    lPos; <br> <br>    if( fFromBuffer ) <br>    { <br>        if( NULL != m_pDSB3D ) <br>        { <br>            m_pDSB3D-&gt;GetMinDistance( &amp;m_flMinDistance ); <br>            lPos = (LONG)m_flMinDistance; <br>        } <br>        else <br>        { <br>            lPos = 0; <br>        } <br>    } <br>    else <br>    { <br>        lPos = lForcePos; <br>    } <br> <br>    SendMessage( m_ht3d.hMinDistSlider, TBM_SETPOS, (WPARAM)TRUE, <br>                 (LPARAM)lPos / MINDIST_SLIDER_FACTOR ); <br> <br>    wsprintf( szText, "%i", lPos ); <br>    Static_SetText( m_ht3d.hMinDistText, szText ); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// UpdateCurrentDistUI() <br>// <br>// function:    Update Current Distance text box in response to change in either <br>//              buffer or listener position <br>// <br>void FileInfo3D::UpdateCurrentDistUI( void ) <br>{ <br>    TCHAR    szText[24]; <br>    D3DVECTOR   d3dListPos; <br>    D3DVALUE    dx, dy, dz; <br>    doubledist; <br>    HRESULT     hr; <br>    // get current listener position <br>    if(SUCCEEDED (hr = gp3DListener-&gt;GetPosition( &amp;d3dListPos ))) <br>    { <br>        // find distance from listener to buffer <br>        dx = d3dListPos.x - m_vPos.x; <br>        dy = d3dListPos.y - m_vPos.y; <br>        dz = d3dListPos.z - m_vPos.z; <br> <br>        dist = sqrt((dx * dx) + (dy * dy) + (dz * dz)); <br> <br>        // update the text box <br>        sprintf( szText, "%.2f", dist ); <br>        Static_SetText( m_ht3d.hCurDistText, szText ); <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// UpdatePosAndVelo() <br>// <br>// function:    Update position as a function of velocity text box in response  <br>//              to timer click  <br>// <br>UpdatePosAndVelo(); <br>void FileInfo3D::UpdatePosAndVelo( void ) <br>{ <br>    float flTimerPeriod = 100.f / (float)TIMERPERIOD; <br> <br>    m_vPos.x += m_vVelo.x * flTimerPeriod; <br>    m_vPos.y += m_vVelo.y * flTimerPeriod; <br>    m_vPos.z += m_vVelo.z * flTimerPeriod; <br> <br>    if(m_vPos.x &gt; POS_SLIDER_MAX) <br>    { <br>        m_vPos.x = (float)POS_SLIDER_MAX; <br>        m_vVelo.x = -m_vVelo.x; <br>    } <br>    if(m_vPos.x &lt; POS_SLIDER_MIN) <br>    { <br>        m_vPos.x = (float)POS_SLIDER_MIN; <br>        m_vVelo.x = -m_vVelo.x; <br>    } <br>    if(m_vPos.y &gt; POS_SLIDER_MAX) <br>    { <br>        m_vPos.y = (float)POS_SLIDER_MAX; <br>        m_vVelo.y = -m_vVelo.y; <br>    } <br>    if(m_vPos.y &lt; POS_SLIDER_MIN) <br>    { <br>        m_vPos.y = (float)POS_SLIDER_MIN; <br>        m_vVelo.y = -m_vVelo.y; <br>    } <br>    if(m_vPos.z &gt; POS_SLIDER_MAX) <br>    { <br>        m_vPos.z = (float)POS_SLIDER_MAX; <br>        m_vVelo.z = -m_vVelo.z; <br>    } <br>    if(m_vPos.z &lt; POS_SLIDER_MIN) <br>    { <br>        m_vPos.z = (float)POS_SLIDER_MIN; <br>        m_vVelo.z = -m_vVelo.z; <br>    } <br> <br>    if( NULL != m_pDSB3D ) <br>    { <br>        m_pDSB3D-&gt;SetPosition( m_vPos.x, m_vPos.y, m_vPos.z, DS3D_IMMEDIATE ); <br>        m_pDSB3D-&gt;SetVelocity( m_vVelo.x, m_vVelo.y, m_vVelo.z, DS3D_IMMEDIATE ); <br>        UpdateVxSliderUI(0, TRUE); <br>        UpdateVySliderUI(0, TRUE); <br>        UpdateVzSliderUI(0, TRUE); <br>    } <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>BOOL FileInfo3D::HandleConeInnerEditNotify( WPARAM wParam, LPARAM lParam ) <br>{ <br>    HRESULT hr; <br>    BOOL    fRet = FALSE; <br>    LONG    lValue; <br>    TCHAR   szTS[6]; <br> <br>    if( HIWORD( wParam ) == EN_CHANGE ) <br>    { <br>        if( (HWND)lParam == m_ht3d.hInnerAngleEdit ) <br>        { <br>            Edit_GetText( m_ht3d.hInnerAngleEdit, szTS, sizeof(szTS)); <br>            lValue = atol(szTS); <br>            if( lValue &lt; 0 ) <br>            { <br>                Edit_SetText( m_ht3d.hInnerAngleEdit, "0" ); <br>                return TRUE; <br>            } <br>            else <br>                m_dwInnerAngle = (DWORD)lValue; <br> <br>            // Make sure we haven't incremented the inner cone larger than <br>            // the outer cone <br>            if( m_dwInnerAngle &gt; m_dwOuterAngle ) <br>            { <br>                m_dwOuterAngle = m_dwInnerAngle; <br>                SendMessage( m_ht3d.hOuterAngleSpin, UDM_SETPOS, <br>                            0, MAKELONG(m_dwOuterAngle, 0)); <br>                wsprintf( szTS, "%u", m_dwOuterAngle ); <br>                Edit_SetText( m_ht3d.hOuterAngleEdit, szTS ); <br>            } <br>            if( m_pDSB3D ) <br>                if( FAILED( hr = m_pDSB3D-&gt;SetConeAngles( m_dwInnerAngle, <br>                            m_dwOuterAngle, DS3D_IMMEDIATE ))) <br>                    DPF( 0, "SetConeAngles: %s", TranslateDSError(hr)); <br>            fRet = TRUE; <br>        } <br>    } <br> <br>    return fRet; <br>} <br> <br> <br>BOOL FileInfo3D::HandleConeOuterEditNotify( WPARAM wParam, LPARAM lParam ) <br>{ <br>    HRESULT hr; <br>    BOOL    fRet = FALSE; <br>    LONG    lValue; <br>    TCHAR   szTS[6]; <br> <br>    if( HIWORD( wParam ) == EN_CHANGE ) <br>    { <br>        if( (HWND)lParam == m_ht3d.hOuterAngleEdit ) <br>        { <br>            Edit_GetText( m_ht3d.hOuterAngleEdit, szTS, sizeof(szTS)); <br>            lValue = atol(szTS); <br>            if( lValue &lt; 0 ) <br>            { <br>                Edit_SetText( m_ht3d.hOuterAngleEdit, "0" ); <br>                return TRUE; <br>            } <br>            else <br>                m_dwOuterAngle = (DWORD)lValue; <br> <br>            // Make sure we haven't decremented the outer cone smaller than <br>            // the inner cone <br>            if( m_dwInnerAngle &gt; m_dwOuterAngle ) <br>            { <br>                m_dwInnerAngle = m_dwOuterAngle; <br>                SendMessage( m_ht3d.hInnerAngleSpin, UDM_SETPOS, <br>                            0, MAKELONG(m_dwInnerAngle, 0)); <br>                wsprintf( szTS, "%u", m_dwInnerAngle ); <br>                Edit_SetText( m_ht3d.hInnerAngleEdit, szTS ); <br>            } <br>            if( m_pDSB3D ) <br>                if( FAILED( hr = m_pDSB3D-&gt;SetConeAngles( m_dwInnerAngle, <br>                            m_dwOuterAngle, DS3D_IMMEDIATE ))) <br>                    DPF( 0, "SetConeAngles: %s", TranslateDSError(hr)); <br>            fRet = TRUE; <br>        } <br>    } <br> <br>    return fRet; <br>} <br> <br>BOOL FileInfo3D::HandleDisableNotify( WPARAM wParam, LPARAM lParam ) <br>{ <br>    HRESULT hr; <br>    BOOL    fRet = FALSE; <br> <br>    if( (HWND)lParam == m_ht3d.hDisable3D ) <br>    { <br>        if( Button_GetCheck( m_ht3d.hDisable3D )) <br>        { <br>            if( m_pDSB3D ) { <br>            if( FAILED( hr = m_pDSB3D-&gt;SetMode( DS3DMODE_DISABLE, 0 ))) <br>                DPF( 0, "SetMode: %s", TranslateDSError(hr)); <br>            fRet = TRUE; <br>            } <br>        } <br>        else <br>        { <br>            if( m_pDSB3D ) { <br>            if( FAILED( hr = m_pDSB3D-&gt;SetMode( DS3DMODE_NORMAL, 0 ))) <br>                DPF( 0, "SetMode: %s", TranslateDSError(hr)); <br>            fRet = TRUE; <br>            } <br>        } <br>    } <br> <br>    return fRet; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
