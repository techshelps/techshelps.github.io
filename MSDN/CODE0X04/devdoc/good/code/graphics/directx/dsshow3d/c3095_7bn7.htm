<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FILEINFO.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3103"></a>FILEINFO.CPP</h2>
<pre><code>/////////////////////////////////////////////////////////////////////////////// <br>// <br>// FileInfo.cpp <br>// <br>//   Implementation of the FileInfo class, which is the main class used to <br>// data and user interface elements associated with a sound buffer in DSShow3D. <br>// <br>// <br> <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include &lt;dsound.h&gt; <br>#include &lt;commctrl.h&gt; <br> <br>#include "DSShow3D.h" <br>#include "GVars.h" <br>#include "FileInfo.h" <br>#include "wave.h" <br>#include "debug.h" <br> <br> <br>int FileInfo::m_xNextPos = 0; <br>int FileInfo::m_yNextPos = 0; <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// FileInfo() <br>// <br>//    Class constructor -- the pmw parameter defaults to NULL, but it should be <br>// something useful before the class is really used. <br>// <br>FileInfo::FileInfo( MainWnd *pmw ) <br>{ <br>    // create an event to pass to SetNotificationPositions <br>    m_dsbPosNotify.hEventNotify = CreateEvent(NULL, FALSE, FALSE, NULL); <br>    if(!IsValidHandle(m_dsbPosNotify.hEventNotify)) <br>    { <br>        MessageBox(NULL, "CreateEvent Failed!", "Error!", MB_ICONEXCLAMATION | MB_OK | MB_TASKMODAL); <br>        PostQuitMessage(-1); <br>        return; <br>    } <br>    m_dwTimeNotified = 0L; <br> <br>    m_pmwOwner = pmw; <br>    m_pbData = NULL; <br>    m_pwfx = NULL; <br>    ZeroMemory( m_szFileName, sizeof(m_szFileName)); <br>    m_nFileIndex = 0; <br>    m_hwndInterface = NULL; <br>    ZeroMemory( &amp;m_ht, sizeof(HWNDTABLE)); <br>    m_dwInternalFlags = 0; <br>    m_fPlayButtonSaysPlay = TRUE; <br> <br>    ZeroMemory( &amp;m_dsbd, sizeof(DSBUFFERDESC)); <br>    m_pDSB = NULL; <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// ~FileInfo() <br>// <br>//    Class destructor. <br>// <br>FileInfo::~FileInfo() <br>{ <br>    m_pmwOwner = NULL; <br> <br>    if( m_pDSB != NULL ) <br>    { <br>        m_pDSB-&gt;Release(); <br>        m_pDSB = NULL; <br>    } <br>    if( m_pwfx ) <br>    { <br>        GlobalFree( m_pwfx ); <br>        m_pwfx = NULL; <br>    } <br>    if( m_pbData ) <br>    { <br>        GlobalFree( m_pbData ); <br>        m_pbData = NULL; <br>    } <br>    if(m_pDSN) <br>    { <br>        m_pDSN-&gt;Release(); <br>        m_pDSN = NULL; <br>    } <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// SetFileName() <br>// <br>//    Set the internal filename data variable and implicitly update the caption    <br>// to reflect the change. <br>// <br>void FileInfo::SetFileName( LPTSTR lpsz, int nIndx ) <br>{ <br>    lstrcpy( m_szFileName, lpsz ); <br>    m_nFileIndex = nIndx; <br> <br>    // If this Assert fails, then we were handed a bad index value <br>    ASSERT( m_nFileIndex &lt; lstrlen( m_szFileName )); <br> <br>    UpdateFileName(); <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// LoadWave() <br>// <br>//    Given a filename and an index to the partial filename (i.e. an index into <br>// the possibly full pathname where the actual filename begins), this function <br>// will do everything needed to load a file into the FileInfo structure. <br>// <br>// Returns 0 on success, non-zero on failure. <br>// <br>int FileInfo::LoadWave( LPTSTR lpszFile, int nIndx ) <br>{ <br>    SetFileName( lpszFile, nIndx ); <br> <br>    // TODO: Need to add in support for ACM filters here <br> <br>    // TODO: Need to determine what's "too big" to load static and then <br>    //       setup something for streaming the buffer instead. <br>    if( WaveLoadFile( m_szFileName, &amp;m_cbDataSize, &amp;m_pwfx, &amp;m_pbData ) != 0 ) <br>    { <br>    // There had better be a MainWnd object, or something is really messed <br>    ASSERT( m_pmwOwner ); <br>    m_pmwOwner-&gt;MessageBox( "Bad wave file or file too big to fit in memory", <br>                            MB_OK|MB_ICONSTOP ); <br>    goto LW_Error; <br>    } <br> <br>    if( NewDirectSoundBuffer() != 0 ) <br>    { <br>    // There had better be a MainWnd object, or something is really messed <br>    ASSERT( m_pmwOwner ); <br>    m_pmwOwner-&gt;MessageBox( "Cannot create new DirectSoundBuffer object", <br>                            MB_OK|MB_ICONSTOP ); <br>    goto LW_Error; <br>    } <br> <br>    m_dwInternalFlags |= FI_INTERNALF_LOADED; <br> <br>    // If we haven't failed in loading so far, this point will be a valid <br>    // pointer to the wave's data. <br>    ASSERT( NULL != m_pbData ); <br> <br>    // Create the ControlPod interface object <br>    CreateInterface( m_pmwOwner-&gt;GetHwnd()); <br> <br>    return 0; <br> <br>LW_Error: <br>    return -1; <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// NewDirectSoundBuffer() <br>// <br>//    This function does all the work to create a new DirectSound buffer, and <br>// gets the interface pointers for both 2D and 3D (if the buffer is 3D). <br>// <br>int FileInfo::NewDirectSoundBuffer() <br>    { <br>    DSBCAPS         dsbc; <br>    HRESULT         hr; <br>    BYTE            *pbWrite1= NULL; <br>    BYTE            *pbWrite2    = NULL; <br>    DWORD           cbLen1; <br>    DWORD           cbLen2; <br>BOOL fNotify =IsNotifyOn(); // just to avoid making 2 calls to it. <br> <br>    /* Set up the direct sound buffer. */ <br>    m_dsbd.dwSize       = sizeof(DSBUFFERDESC); <br> <br>    // We already set the flags to zero in the constructor.  Don't do it again <br>    // or we might wipe out anything a derived class has setup. <br>if (fNotify) <br>{ <br>    m_dsbd.dwFlags    |= DSBCAPS_STATIC | DSBCAPS_CTRLPOSITIONNOTIFY; <br>} <br>else <br>{ <br>m_dsbd.dwFlags    |= DSBCAPS_STATIC; <br>} <br> <br>    m_dsbd.dwFlags    |= DSBCAPS_CTRLDEFAULT;// !!! default <br>    // The derived class will pick its 3D flags <br>    if( m_dwInternalFlags &amp; IsSticky()) <br>    { <br>        ASSERT( !IsGlobal()); <br>        m_dsbd.dwFlags |= DSBCAPS_STICKYFOCUS; <br>    } <br>    if( m_dwInternalFlags &amp; IsGlobal()) <br>    { <br>        ASSERT( !IsSticky()); <br>        m_dsbd.dwFlags |= DSBCAPS_GLOBALFOCUS; <br>    } <br>    if( m_dwInternalFlags &amp; IsMutedAtMax()) <br>    { <br>        m_dsbd.dwFlags |= DSBCAPS_MUTE3DATMAXDISTANCE; <br>    } <br> <br>    // This flag can only be set if the open dialog detected emulation and <br>    // allowed the proper radio buttons to be enabled <br>    if( m_dwInternalFlags &amp; IsUsingGetPos2()) <br>    m_dsbd.dwFlags |= DSBCAPS_GETCURRENTPOSITION2; <br> <br>    m_dsbd.dwBufferBytes    = m_cbDataSize; <br>    m_dsbd.lpwfxFormat      = m_pwfx; <br> <br>    /* Make sure these are NULL before we start */     <br>    m_pDSB = NULL; <br> <br>    if( FAILED( hr = gpds-&gt;CreateSoundBuffer( &amp;m_dsbd, &amp;m_pDSB, NULL ))) <br>    { <br>    goto ERROR_IN_ROUTINE; <br>    } <br> <br>// now set up notification pointer. <br>if (fNotify) <br>{ <br>if( FAILED(hr = m_pDSB-&gt;QueryInterface(IID_IDirectSoundNotify, (void**)&amp;m_pDSN))) <br>        { <br>            MessageBox(NULL, "Failed to create notification object!", "Error!", MB_ICONEXCLAMATION | MB_OK | MB_TASKMODAL); <br>            goto ERROR_IN_ROUTINE; <br>        } <br>} <br> <br>    /* Ok, lock the sucker down, and copy the memory to it. */ <br>    if( FAILED( hr = m_pDSB-&gt;Lock( 0, m_cbDataSize, (LPVOID *)&amp;pbWrite1, &amp;cbLen1, <br>                        (LPVOID *)&amp;pbWrite2, &amp;cbLen2, 0L ))) <br>    { <br>    goto ERROR_IN_ROUTINE; <br>    } <br> <br>    ASSERT( pbWrite1 != NULL ); <br>    ASSERT( cbLen1 == m_cbDataSize ); <br> <br>    CopyMemory( pbWrite1, m_pbData, m_cbDataSize ); <br> <br>    ASSERT( 0 == cbLen2 ); <br>    ASSERT( NULL == pbWrite2 ); <br> <br>    /* Ok, now unlock the buffer, we don't need it anymore. */ <br>    if( FAILED( hr = m_pDSB-&gt;Unlock( pbWrite1, m_cbDataSize, pbWrite2, 0 ))) <br>    { <br>    goto ERROR_IN_ROUTINE; <br>    } <br> <br>    pbWrite1 = NULL; <br> <br>    if (FAILED(hr = m_pDSB-&gt;SetVolume( MAXVOL_VAL ))) <br>    { <br>    goto ERROR_IN_ROUTINE; <br>    } <br> <br>    if (!Is3D()) { <br>        if( FAILED( hr = m_pDSB-&gt;SetPan( MIDPAN_VAL ))) <br>        { <br>        goto ERROR_IN_ROUTINE; <br>        } <br>    } <br> <br>    dsbc.dwSize = sizeof(dsbc); <br>    if( hr = m_pDSB-&gt;GetCaps( &amp;dsbc )) <br>    { <br>    goto ERROR_IN_ROUTINE; <br>    } <br> <br>    if( dsbc.dwFlags &amp; DSBCAPS_LOCHARDWARE ) <br>    { <br>    m_dwInternalFlags |= FI_INTERNALF_HARDWARE; <br>    } <br>    else <br>    { <br>    m_dwInternalFlags &amp;= ~FI_INTERNALF_HARDWARE; <br>    } <br> <br>    goto DONE_ROUTINE; <br> <br>ERROR_IN_ROUTINE: <br>    if( pbWrite1 != NULL ) <br>    { <br>    hr = m_pDSB-&gt;Unlock( pbWrite1, m_cbDataSize, pbWrite2, 0 ); <br>    pbWrite1 = NULL; <br>    } <br> <br>    if( NULL != m_pDSB ) <br>    { <br>    m_pDSB-&gt;Release(); <br>    m_pDSB = NULL; <br>    } <br> <br>DONE_ROUTINE: <br>    return hr; <br>    } <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// SendDestroyRequest() <br>// <br>//    Ask the owning window object to destroy us and remove any information <br>// it may be keeping about our existence. <br>// <br>void FileInfo::SendDestroyRequest() <br>{ <br>    // We must have an owner to send the request to.  We should never <br>    // have gotten any further than the CreateInterface() without one. <br>    ASSERT( NULL != m_pmwOwner ); <br> <br>    m_pmwOwner-&gt;DestroyFileInfo( this ); <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// SendDestroyRequest() <br>// <br>//    Plays a buffer or updates playback flags according to some class state <br>// variables like our looping flag. <br>// <br>void FileInfo::PlayBuffer( void ) <br>{ <br>    if( m_pDSB ) <br>    { <br>        if( IsLooped()) <br>            m_pDSB-&gt;Play( 0, 0, DSBPLAY_LOOPING ); <br>        else <br>            m_pDSB-&gt;Play( 0, 0, 0 ); <br> <br>        m_dwInternalFlags |= FI_INTERNALF_PLAYING; <br>    } <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// StopBuffer() <br>// <br>//    Stop the buffer and reset it's position to the start. <br>// <br>void FileInfo::StopBuffer( void ) <br>{ <br>    if( m_pDSB ) <br>    { <br>        m_pDSB-&gt;Stop(); <br>        m_pDSB-&gt;SetCurrentPosition( 0 ); <br> <br>        // Clear our internal state bit <br>        m_dwInternalFlags &amp;= ~FI_INTERNALF_PLAYING; <br>    } <br>} <br> <br> <br>void FileInfo::Close( void ) <br>{ <br>    SendMessage( m_hwndInterface, WM_COMMAND, MAKELONG(IDCANCEL, 0), 0L ); <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// DuplicateBuffer() <br>// <br>//    Initializes this FileInfo object by duplicating the given one. <br>// <br>void FileInfo::Duplicate( FileInfo *pfiSource ) <br>{ <br>    if( NULL == pfiSource || NULL == pfiSource-&gt;m_pDSB || <br>        !(pfiSource-&gt;m_dwInternalFlags &amp; FI_INTERNALF_LOADED)) <br>        return; <br> <br>    m_cbDataSize = pfiSource-&gt;m_cbDataSize; <br>    m_nFileIndex = pfiSource-&gt;m_nFileIndex; <br>    m_dwInternalFlags = pfiSource-&gt;m_dwInternalFlags; <br>    m_pmwOwner = pfiSource-&gt;m_pmwOwner; <br> <br>    m_pwfx = (PWAVEFORMATEX)GlobalAlloc(GPTR, sizeof(WAVEFORMATEX) + pfiSource-&gt;m_pwfx-&gt;cbSize); <br>    m_pbData = (LPBYTE)GlobalAlloc(GPTR, pfiSource-&gt;m_cbDataSize); <br> <br>    CopyMemory( m_pbData, pfiSource-&gt;m_pbData, pfiSource-&gt;m_cbDataSize ); <br>    CopyMemory( m_pwfx, pfiSource-&gt;m_pwfx, <br>                sizeof(WAVEFORMATEX) + pfiSource-&gt;m_pwfx-&gt;cbSize); <br>    CopyMemory( &amp;m_dsbd, &amp;pfiSource-&gt;m_dsbd, sizeof(m_dsbd)); <br>    CopyMemory( &amp;m_szFileName, pfiSource-&gt;m_szFileName, sizeof(m_szFileName)); <br> <br>    ASSERT( NULL != pfiSource-&gt;m_pDSB ); <br>    ASSERT( NULL != gpds ); <br> <br>    HRESULThr; <br> <br>    if( FAILED( hr = gpds-&gt;DuplicateSoundBuffer(pfiSource-&gt;m_pDSB, &amp;m_pDSB))) <br>    { <br>        MessageBox(NULL, "Failed to DuplicateSoundBuffer()", "Error!", MB_ICONEXCLAMATION | MB_OK | MB_TASKMODAL); <br>    } <br>    else <br>    { <br>        // now set up notification pointer. <br>    if (IsNotifyOn()) <br>    { <br>    if( FAILED( hr = m_pDSB-&gt;QueryInterface(IID_IDirectSoundNotify, (void**)&amp;m_pDSN))) <br>            { <br>                MessageBox(NULL, "Failed to create notification object!", "Error!", MB_ICONEXCLAMATION | MB_OK | MB_TASKMODAL); <br>                PostQuitMessage(-1); <br>                return; <br>            } <br>    } <br> <br>        CreateInterface( m_pmwOwner-&gt;GetHwnd()); <br>    } <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// CreateInterface() <br>// <br>//    Creates an interface window. A return of TRUE indicates success. <br>// <br>BOOL FileInfo::CreateInterface( HWND hwndOwner ) <br>{ <br>    m_hwndInterface = CreateDialogParam( ghInst, MAKEINTRESOURCE(IDD_BUFFER), <br>                   hwndOwner, (DLGPROC)FileInfoDlgProc, <br>                   (LPARAM)this ); <br> <br>    if( NULL == m_hwndInterface ) <br>        goto FICI_Fail; <br> <br>    UpdateFileName(); <br> <br>    CascadeWindow(); <br> <br>    ShowWindow( m_hwndInterface, SW_SHOW ); <br> <br>    // This flag tells us an interface window was successfully created <br>    m_dwInternalFlags |= FI_INTERNALF_INTERFACE; <br>    return TRUE; <br> <br> <br>FICI_Fail: <br>    if( m_hwndInterface ) <br>    { <br>        DestroyWindow( m_hwndInterface ); <br>        m_hwndInterface = NULL; <br>    } <br>    // Clear the flag that says we have a good interface window created <br>    m_dwInternalFlags &amp;= ~FI_INTERNALF_INTERFACE; <br>    return FALSE; <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// ResetCascade() <br>// <br>// <br>// <br>void FileInfo::ResetCascade( void ) <br>{ <br>    POINT   ptParent; <br> <br>    ptParent.x = ptParent.y = 0; <br>    ClientToScreen( m_pmwOwner-&gt;GetHwnd(), &amp;ptParent ); <br>    m_xNextPos = ptParent.x; <br>    m_yNextPos = ptParent.y; <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// MinimizeWindow() <br>// <br>// <br>// <br>void FileInfo::MinimizeWindow( void ) <br>{ <br>    ShowWindow( m_hwndInterface, SW_MINIMIZE ); <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// RestoreWindow() <br>// <br>// <br>// <br>void FileInfo::RestoreWindow( void ) <br>{ <br>    SendMessage( m_hwndInterface, WM_SYSCOMMAND, SC_RESTORE, 0L ); <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// CascadeWindow() <br>// <br>// <br>// <br>void FileInfo::CascadeWindow( void ) <br>{ <br>    RECT    rcWind; <br>    int     nStep; <br> <br>    // Don't move minimized windows <br>    if( IsIconic( m_hwndInterface )) <br>        return; <br> <br>    GetWindowRect( m_hwndInterface, &amp;rcWind ); <br> <br>    if( m_xNextPos + (rcWind.right - rcWind.left) &gt; GetSystemMetrics(SM_CXSCREEN)) <br>        ResetCascade(); <br>    else if( m_yNextPos + (rcWind.bottom - rcWind.top) &gt; GetSystemMetrics(SM_CYSCREEN)) <br>        ResetCascade(); <br> <br>    SetWindowPos( m_hwndInterface, NULL, m_xNextPos, m_yNextPos, <br>                    0, 0, SWP_NOSIZE | SWP_NOZORDER ); <br>    // Move diagonally by the height of the title bar <br>    nStep = GetSystemMetrics(SM_CYCAPTION); <br>    m_xNextPos += nStep; <br>    m_yNextPos += nStep; <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// FileInfoDlgProc() <br>// <br>//    Window message callback function for all Interface DLGs'.  Route messages <br>// to message handler functions <br>// <br>BOOL CALLBACK FileInfoDlgProc( HWND hDlg, UINT message, <br>                        WPARAM wParam, LPARAM lParam ) <br>{ <br>    FileInfo *pfi; <br> <br>    switch( message ) <br>    { <br>        // The first step is to stash our class object pointer in the user data <br>        // and Initialize all our controls and internal data members. <br>        case WM_INITDIALOG: <br>            ASSERT( NULL != lParam ); <br>            pfi = (FileInfo *)lParam; <br>            SetWindowLong( hDlg, DWL_USER, (LONG)pfi ); <br> <br>            if( !pfi-&gt;OnInitDialog( hDlg, wParam )) <br>            { <br>                DestroyWindow( hDlg ); <br>            } <br>            return TRUE; <br> <br>        // By setting the global variable that tracks the active dialog, <br>        // we can easily dispatch keyboard messages to the proper dialog <br>        // through IsDialogMessage() in our main message pump. <br>        case WM_ACTIVATE: <br>            if( !wParam ) <br>            ghDlgActive = NULL; <br>            else <br>            ghDlgActive = hDlg; <br>            return TRUE; <br> <br>        case WM_INITMENU: <br>            pfi = (FileInfo*)GetWindowLong( hDlg, DWL_USER ); <br>            ASSERT( NULL != pfi ); <br>            return pfi-&gt;OnInitMenu( wParam, lParam ); <br> <br>        case WM_DROPFILES: <br>            pfi = (FileInfo*)GetWindowLong( hDlg, DWL_USER ); <br>            ASSERT( NULL != pfi ); <br>            return pfi-&gt;m_pmwOwner-&gt;SendMessage( WM_DROPFILES, wParam, lParam ); <br> <br>        case WM_COMMAND: <br>            pfi = (FileInfo*)GetWindowLong( hDlg, DWL_USER ); <br>            ASSERT( NULL != pfi ); <br>            return pfi-&gt;OnCommand( wParam, lParam ); <br> <br>        // Handle this to deal with right-clicks on our controls -- we have a <br>        // bunch of different context menus that we can popup <br>        case WM_CONTEXTMENU: <br>            pfi = (FileInfo*)GetWindowLong( hDlg, DWL_USER ); <br>            ASSERT( NULL != pfi ); <br>            return pfi-&gt;OnContextMenu( hDlg, LOWORD(lParam), HIWORD(lParam)); <br> <br>        // Trackbar slider notifications come through here <br>        case WM_HSCROLL: <br>            pfi = (FileInfo*)GetWindowLong( hDlg, DWL_USER ); <br>            ASSERT( NULL != pfi ); <br>            return pfi-&gt;OnHScroll( LOWORD(wParam), (LONG)HIWORD(wParam), (HWND)lParam ); <br> <br>        case WM_DESTROY: <br>            pfi = (FileInfo*)GetWindowLong( hDlg, DWL_USER ); <br>            ASSERT( NULL != pfi ); <br>            pfi-&gt;OnDestroy(); <br>            return TRUE; <br> <br>        default: <br>            return FALSE; <br>    } <br> <br>    ASSERT( FALSE ); <br>} <br> <br> <br>/* OnInitMenu() <br> * <br> *    Updates the state of items on the menus in response to a WM_INITMENU <br> * message, which means the menu is about to be displayed. <br> */ <br>BOOL FileInfo::OnInitMenu( WPARAM wParam, LPARAM lParam ) <br>{ <br>    HMENU   hSys = GetSystemMenu( m_hwndInterface, FALSE ); <br> <br>    EnableMenuItem( hSys, SC_MAXIMIZE, MF_BYCOMMAND | MF_GRAYED ); <br>    EnableMenuItem( hSys, SC_SIZE, MF_BYCOMMAND | MF_GRAYED ); <br>    return TRUE; <br>} <br> <br> <br>/* OnInitDialog() <br> * <br> *    Handles the initialization of the FilInfo interface window, which is <br> * actually a modeless dialog. <br> */ <br>BOOL FileInfo::OnInitDialog( HWND hDlg, WPARAM wParam ) <br>{ <br>    TCHAR   szBuf1[64], tszFmt[64]; <br> <br>    // Grab a bunch of handles and store them for easy access later <br>    m_ht.hPlayButton = GetDlgItem( hDlg, IDC_BUFFERDLG_PLAY_BUTTON ); <br>    m_ht.hLoopedCheck = GetDlgItem( hDlg, IDC_BUFFERDLG_LOOPED_CHECK ); <br>    m_ht.hProgressSlider = GetDlgItem( hDlg, IDC_BUFFERDLG_PROGRESS_SLIDER ); <br>    m_ht.hProgressText = GetDlgItem( hDlg, IDC_BUFFERDLG_PROGRESS_TEXT ); <br>    m_ht.hProgressSpin = GetDlgItem( hDlg, IDC_BUFFERDLG_PROGRESS_SPIN ); <br>    m_ht.hFreqText = GetDlgItem( hDlg, IDC_BUFFERDLG_FREQ_TEXT ); <br>    m_ht.hFreqSlider = GetDlgItem( hDlg, IDC_BUFFERDLG_FREQ_SLIDER ); <br>    m_ht.hVolText = GetDlgItem( hDlg, IDC_BUFFERDLG_VOL_TEXT ); <br>    m_ht.hVolSlider = GetDlgItem( hDlg, IDC_BUFFERDLG_VOL_SLIDER ); <br>    m_ht.hPanText = GetDlgItem( hDlg, IDC_BUFFERDLG_PAN_TEXT ); <br>    m_ht.hPanSlider = GetDlgItem( hDlg, IDC_BUFFERDLG_PAN_SLIDER ); <br>    m_ht.hPlayCursorText = GetDlgItem( hDlg, IDC_BUFFERDLG_PLAYCURSOR_TEXT ); <br>    m_ht.hWriteCursorText = GetDlgItem( hDlg, IDC_BUFFERDLG_WRITECURSOR_TEXT ); <br>    m_ht.hDataFormatText = GetDlgItem( hDlg, IDC_BUFFERDLG_DATAFORMAT_TEXT ); <br>    m_ht.hBufferTypeText = GetDlgItem( hDlg, IDC_BUFFERDLG_BUFFERTYPE_TEXT ); <br>    m_ht.hFocusModeText = GetDlgItem( hDlg, IDC_BUFFERDLG_FOCUS_TEXT ); <br>    m_ht.hGetPosModeText = GetDlgItem( hDlg, IDC_BUFFERDLG_GETPOS_TEXT ); <br>    m_ht.hNotifyText = GetDlgItem( hDlg, IDC_BUFFERDLG_NOTIFY_TEXT ); <br>    m_ht.hNotifySlider = GetDlgItem( hDlg, IDC_BUFFERDLG_NOTIFY_SLIDER ); <br>    m_ht.hNotifyFrame = GetDlgItem( hDlg, IDC_BUFFERDLG_NOTIFY_FRAME ); <br> <br>    // Load, fill in and set the string describing the format of the sound data <br>    if( m_pwfx-&gt;nChannels == 1 ) <br>    LoadString( ghInst, IDS_DATAFORMAT_MONO, tszFmt, sizeof(tszFmt)-1); <br>    else <br>    LoadString( ghInst, IDS_DATAFORMAT_STEREO, tszFmt, sizeof(tszFmt)-1); <br>    wsprintf( szBuf1, tszFmt, m_pwfx-&gt;nSamplesPerSec, m_pwfx-&gt;wBitsPerSample ); <br>                         <br>    Static_SetText( m_ht.hDataFormatText, szBuf1 ); <br> <br>    // Set the Buffer Type text to HARDWARE or SOFTWARE <br>    if( IsHardware()) <br>        LoadString( ghInst, IDS_BUFFERTYPE_HARDWARE, szBuf1, sizeof(szBuf1)-1); <br>    else <br>        LoadString( ghInst, IDS_BUFFERTYPE_SOFTWARE, szBuf1, sizeof(szBuf1)-1); <br>    Static_SetText( m_ht.hBufferTypeText, szBuf1 ); <br> <br>    // Set the focus type to LOCAL, STICKY, or GLOBAL <br>    if( IsSticky()) <br>        LoadString( ghInst, IDS_FOCUSMODE_STICKY, szBuf1, sizeof(szBuf1)-1); <br>    else if( IsGlobal()) <br>        LoadString( ghInst, IDS_FOCUSMODE_GLOBAL, szBuf1, sizeof(szBuf1)-1); <br>    else <br>        LoadString( ghInst, IDS_FOCUSMODE_LOCAL, szBuf1, sizeof(szBuf1)-1); <br>    Static_SetText( m_ht.hFocusModeText, szBuf1 ); <br> <br>    if( Is3D()) <br>    { <br>        Static_Enable( m_ht.hPanText, FALSE ); <br>        Static_Enable( m_ht.hPanSlider, FALSE ); <br>    } <br> <br>if (IsNotifyOn()) <br>{ <br>Static_Enable(m_ht.hNotifySlider, TRUE); <br>Static_Enable(m_ht.hNotifyText, TRUE); <br>Static_Enable(m_ht.hNotifyFrame, TRUE); <br>} <br>else <br>{ <br>Static_Enable(m_ht.hNotifySlider, FALSE); <br>Static_Enable(m_ht.hNotifyText, FALSE); <br>Static_Enable(m_ht.hNotifyFrame, FALSE); <br>} <br> <br>    // Set the range, page size, etc. of our "slider" (trackbar) controls <br>    SetSliders(); <br> <br>    // Update the state of the UI elements that change <br>    UpdateUI(); <br>    return TRUE; <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// OnContextMenu() <br>// <br>//    Handles a right-click in the client area by popping up a menu if we have <br>// one we'd like to display, or returning otherwise. TRUE indicates the message <br>// was "handled" and no further processing is needed.  FALSE means the message <br>// was not handled. <br>// <br>BOOL FileInfo::OnContextMenu( HWND hwnd, int x, int y ) <br>{ <br>    HMENU   hm, hSub; <br>    int     nSubMenu = -1, idFrom = 0; <br>    POINT   pt = { x, y }; <br>    RECT    rectWind1, rectWind2; <br> <br>    // Set the sub-menu to the Frequency context menu if we hit the Freq. Slider <br>    // or text control <br>    GetWindowRect( m_ht.hFreqSlider, &amp;rectWind1 ); <br>    GetWindowRect( m_ht.hFreqText, &amp;rectWind2 ); <br> <br>    if( PtInRect( &amp;rectWind1, pt ) || PtInRect( &amp;rectWind2, pt )) <br>        nSubMenu = 0; <br> <br>    // Set the sub-menu to the Volume context menu if we hit the Vol. Slider <br>    // or text control <br>    GetWindowRect( m_ht.hVolSlider, &amp;rectWind1 ); <br>    GetWindowRect( m_ht.hVolText, &amp;rectWind2 ); <br> <br>    if( PtInRect( &amp;rectWind1, pt ) || PtInRect( &amp;rectWind2, pt )) <br>        nSubMenu = 1; <br> <br>    // Only have pan on non-3D buffers <br>    if (!Is3D()) <br>    { <br>        // Set the sub-menu to the Pan context menu if we hit the Pan Slider <br>        // or text control <br>        GetWindowRect( m_ht.hPanSlider, &amp;rectWind1 ); <br>        GetWindowRect( m_ht.hPanText, &amp;rectWind2 ); <br> <br>        if( PtInRect( &amp;rectWind1, pt ) || PtInRect( &amp;rectWind2, pt )) <br>        nSubMenu = 2; <br>        } <br> <br>    // We didn't detect any "interesting" hotspots, so return as unprocessed. <br>    if( nSubMenu &lt; 0 ) <br>        return FALSE; <br> <br>    // If we make it here, we're gonna popup a context menu of some sort <br> <br>    // Attempt to load our menu.  If we fail, we still handled the message <br>    // so return TRUE <br>    if(( hm = LoadMenu( ghInst, MAKEINTRESOURCE(IDM_POPUPS))) == NULL ) <br>        return TRUE; <br> <br>    hSub = GetSubMenu( hm, nSubMenu ); <br>    TrackPopupMenu( hSub, TPM_LEFTALIGN | TPM_RIGHTBUTTON, <br>            pt.x, pt.y, 0, m_hwndInterface, NULL ); <br>     <br>    DestroyMenu( hm ); <br> <br>    return TRUE; <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// SetSliders() <br>// <br>//    Sets the range, page size, tic frequency, and other parameters of all the <br>// trackbar controls we use in the interface. <br>// <br>void FileInfo::SetSliders( void ) <br>{ <br>    DWORD   dwSampleRateRange, dwMaxFreq, dwMinFreq;  <br>    UDACCEL udAccel; <br>    DSCAPS dsc; <br> <br>// If the buffer is in hardware, query the card for samplerates <br>// else use our default values. <br>if (IsHardware()) <br>{ <br>int hr = DS_OK; <br>// Get the min/max frequency range by querying the card. <br>memset(&amp;dsc, 0, sizeof(DSCAPS)); <br>dsc.dwSize = sizeof(DSCAPS); <br>hr = gpds-&gt;GetCaps(&amp;dsc); <br>ASSERT(hr == DS_OK); <br>        dwMinFreq = dsc.dwMinSecondarySampleRate; <br>        dwMaxFreq = dsc.dwMaxSecondarySampleRate; <br>    } <br>else <br>{ <br>dwMinFreq = DSBFREQUENCY_MIN; <br>dwMaxFreq = DSBFREQUENCY_MAX; <br>} <br> <br>    dwSampleRateRange = dwMaxFreq - dwMinFreq; <br> <br>    // Scale the sample rate range into an acceptable span and keep <br>    // track of the multiplying constant we'll have to use later when <br>    // we want to set positions based on real values <br>    m_dwFreqSliderFactor = 1; <br>         <br>    while( dwSampleRateRange &gt; 10000 ) <br>    { <br>        dwSampleRateRange /= 10; <br>        m_dwFreqSliderFactor *= 10; <br>    } <br> <br>    SendMessage( m_ht.hFreqSlider, TBM_SETRANGEMIN, <br>                 FALSE, (LPARAM)dwMinFreq / m_dwFreqSliderFactor ); <br>    SendMessage( m_ht.hFreqSlider, TBM_SETRANGEMAX, <br>                 FALSE, (LPARAM)dwMaxFreq / m_dwFreqSliderFactor ); <br>    SendMessage( m_ht.hFreqSlider, TBM_SETPAGESIZE, 0, <br>                 FREQ_SLIDER_PAGESIZE_HZ / m_dwFreqSliderFactor ); <br> <br>    SendMessage( m_ht.hProgressSpin, UDM_SETBUDDY, (WPARAM)m_ht.hProgressSlider, 0 ); <br>    SendMessage( m_ht.hProgressSpin, UDM_SETRANGE, 0, MAKELONG(PROGRESS_MAX, PROGRESS_MIN)); <br>    SendMessage( m_ht.hProgressSpin, UDM_SETPOS, 0, MAKELONG(0,0)); <br>    udAccel.nSec = 0; <br>    udAccel.nInc = PROGRESS_MAX / 20; <br>    SendMessage( m_ht.hProgressSpin, UDM_SETACCEL, 1, (LPARAM)&amp;udAccel ); <br> <br>    SendMessage( m_ht.hProgressSlider, TBM_SETRANGEMIN, FALSE, (LPARAM)PROGRESS_MIN ); <br>    SendMessage( m_ht.hProgressSlider, TBM_SETRANGEMAX, FALSE, (LPARAM)PROGRESS_MAX ); <br>    SendMessage( m_ht.hProgressSlider, TBM_SETPAGESIZE, FALSE, (LPARAM)PROGRESS_MAX / 20 ); <br>    SendMessage( m_ht.hProgressSlider, TBM_SETTICFREQ, (WPARAM)PROGRESS_TIC, 0 ); <br> <br>    SendMessage( m_ht.hNotifySlider, TBM_SETRANGEMIN, FALSE, (LPARAM)0 ); <br>    SendMessage( m_ht.hNotifySlider, TBM_SETRANGEMAX, FALSE, (LPARAM)NOTIFY_MAX ); <br>    SendMessage( m_ht.hNotifySlider, TBM_SETPAGESIZE, FALSE, (LPARAM)NOTIFY_MAX / 20 ); <br> <br>    // Intentionally set the range backwards because a large number means <br>    // a smaller value <br>    SendMessage( m_ht.hVolSlider, TBM_SETRANGEMIN, FALSE, <br>                 (LPARAM)(VOL_MIN + VOL_SLIDER_SHIFT) / VOL_SLIDER_FACTOR ); <br>    SendMessage( m_ht.hVolSlider, TBM_SETRANGEMAX, FALSE, <br>                 (LPARAM)(VOL_MAX + VOL_SLIDER_SHIFT) / VOL_SLIDER_FACTOR ); <br>    SendMessage( m_ht.hVolSlider, TBM_SETPAGESIZE, 0, <br>                 VOL_SLIDER_PAGE / VOL_SLIDER_FACTOR ); <br>    // NOTE: No TICs on the volume slider <br> <br>    SendMessage( m_ht.hPanSlider, TBM_SETRANGEMIN, FALSE, <br>                 (LPARAM)(PAN_MIN + PAN_SLIDER_SHIFT) / PAN_SLIDER_FACTOR ); <br>    SendMessage( m_ht.hPanSlider, TBM_SETRANGEMAX, FALSE, <br>                 (LPARAM)(PAN_MAX + PAN_SLIDER_SHIFT) / PAN_SLIDER_FACTOR ); <br>    SendMessage( m_ht.hPanSlider, TBM_SETPAGESIZE, 0, <br>                 PAN_SLIDER_PAGE / PAN_SLIDER_FACTOR ); <br>    // NOTE: No TICs on the pan slider <br> <br>    // Update the display from the buffer's current settings <br>    UpdateFreqUI( 0, TRUE ); <br>    UpdateVolUI( 0, TRUE ); <br>    UpdatePanUI( 0, TRUE ); <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// UpdateUI() <br>// <br>//    This function is normally called from the MainWnd object's timer handler <br>// to refresh the UI elements that are time-dependent.  These are things like <br>// the play and write cursors and the progress. <br>// <br>void FileInfo::UpdateUI( void ) <br>{ <br>    TCHAR   szText[8]; <br>    DWORD   dwStatus, dwPlay, dwWrite; <br> <br>    if( NULL == m_pDSB ) <br>        return; <br> <br>    if( FAILED( m_pDSB-&gt;GetStatus( &amp;dwStatus ))) <br>        return; <br> <br>    if( dwStatus &amp; DSBSTATUS_BUFFERLOST ) <br>    { <br>        LPBYTEpb1, pb2; <br>        DWORDcb1, cb2; <br> <br>        if( SUCCEEDED( m_pDSB-&gt;Restore())) <br>        { <br>            if( SUCCEEDED( m_pDSB-&gt;Lock( 0, m_cbDataSize, (LPVOID *)&amp;pb1, &amp;cb1, (LPVOID *)&amp;pb2, &amp;cb2, 0 ))) <br>            { <br>                ASSERT( m_cbDataSize == cb1 ); <br>                if( NULL != m_pbData ) <br>                    CopyMemory( pb1, m_pbData, m_cbDataSize ); <br>                m_pDSB-&gt;Unlock( pb1, m_cbDataSize, pb2, 0 ); <br> <br>                if(IsPlaying()) <br>                    PlayBuffer(); <br>            } <br>        } <br>    } <br>    else <br>    { <br>        if( dwStatus &amp; DSBSTATUS_PLAYING ) <br>            SetPlaying( TRUE ); <br>        else <br>            SetPlaying( FALSE ); <br>    } <br> <br>    Button_SetCheck( m_ht.hLoopedCheck, IsLooped()); <br> <br>    UpdatePlayButton(); <br> <br>    m_pDSB-&gt;GetCurrentPosition( &amp;dwPlay, &amp;dwWrite ); <br>    wsprintf( szText, "%u", dwPlay ); <br>    Static_SetText( m_ht.hPlayCursorText, szText ); <br>    wsprintf( szText, "%u", dwWrite ); <br>    Static_SetText( m_ht.hWriteCursorText, szText ); <br> <br>    UpdateProgressUI( dwPlay ); <br> <br>    // Check to see if the notification event is signaled <br>    UpdateNotifySignal(); <br> <br>    return; <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// UpdateProgressUI() <br>// <br>// <br>// <br>void FileInfo::UpdateProgressUI( DWORD dwPlayPos ) <br>{ <br>    TCHAR   szText[8]; <br>    FLOAT   fPercentage; <br> <br>    // TODO: Set the progress slider position <br>    fPercentage = ((FLOAT)dwPlayPos / (FLOAT)(m_cbDataSize-1)); <br> <br>    SendMessage( m_ht.hProgressSlider, TBM_SETPOS, TRUE, (LPARAM)(PROGRESS_MAX * fPercentage)); <br>    SendMessage( m_ht.hProgressSpin, UDM_SETPOS, TRUE, MAKELONG((PROGRESS_MAX * fPercentage), 0)); <br> <br>    wsprintf( szText, "%i%%", (int)(100 * fPercentage)); <br>    Static_SetText( m_ht.hProgressText, szText ); </code></pre>
<p>
</p>
<pre><code>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// UpdateVolUI() <br>// <br>//    Updates the position of the volume slider and text. You can specify that <br>// it get the volume from the buffer by passing TRUE to fFromBuffer, or you can <br>// specify a volume by putting it in lForceVol and setting fFromBuffer = FALSE. <br>// <br>void FileInfo::UpdateVolUI( LONG lForceVol, BOOL fFromBuffer ) <br>{ <br>    LONG    lVol; <br>    TCHAR   szText[16]; <br> <br>    if( fFromBuffer ) <br>    { <br>        if( NULL != m_pDSB ) <br>        { <br>            m_pDSB-&gt;GetVolume( &amp;lVol ); <br>        } <br>        else <br>            lVol = 0; <br>    } <br>    else <br>        lVol = lForceVol; <br> <br>    SendMessage( m_ht.hVolSlider, TBM_SETPOS, (WPARAM)TRUE, <br>            (LPARAM)(lVol + VOL_SLIDER_SHIFT) / VOL_SLIDER_FACTOR ); <br> <br>    // Print volume in decibels <br>    wsprintf( szText, "%i dB", lVol / 100 ); <br> <br>    Static_SetText( m_ht.hVolText, szText ); <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// UpdatePanUI() <br>// <br>//    Updates the position of the panning slider and text. You can specify that <br>// it get the pan from the buffer by passing TRUE to fFromBuffer, or you can <br>// specify a pan by putting it in lForcePan and setting fFromBuffer = FALSE. <br>// <br>void FileInfo::UpdatePanUI( LONG lForcePan, BOOL fFromBuffer ) <br>{ <br>    LONG    lPan; <br>    TCHAR   szText[16]; <br> <br>    if ( Is3D()) <br>    { <br>        lForcePan = 0; <br>        fFromBuffer = FALSE; <br>    } <br> <br>    if( fFromBuffer ) <br>    { <br>        if( NULL != m_pDSB ) <br>        { <br>            m_pDSB-&gt;GetPan( &amp;lPan ); <br>        } <br>        else <br>            lPan = 0; <br>    } <br>    else <br>        lPan = lForcePan; <br> <br>    SendMessage( m_ht.hPanSlider, TBM_SETPOS, (WPARAM)TRUE, <br>                 (LPARAM)(lPan + PAN_SLIDER_SHIFT) / PAN_SLIDER_FACTOR ); <br> <br>    // Print pan in decibels <br>    wsprintf( szText, "%i dB", lPan / 100 ); <br> <br>    Static_SetText( m_ht.hPanText, szText ); <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// UpdateFreqUI() <br>// <br>//    Updates the position of the freq slider and text. You can specify that <br>// it get the freq from the buffer by passing TRUE to fFromBuffer, or you can <br>// specify a freq by putting it in dwForceFreq and setting fFromBuffer = FALSE. <br>// <br>void FileInfo::UpdateFreqUI( DWORD dwForceFreq, BOOL fFromBuffer ) <br>{ <br>    DWORD   dwFreq; <br>    TCHAR   szText[16]; <br> <br>    if( fFromBuffer ) <br>    { <br>        if( NULL != m_pDSB ) <br>            m_pDSB-&gt;GetFrequency( &amp;dwFreq ); <br>        else <br>            dwFreq = 0; <br>    } <br>    else <br>        dwFreq = dwForceFreq; <br> <br>    SendMessage( m_ht.hFreqSlider, TBM_SETPOS, <br>                 (WPARAM)TRUE, (LPARAM)dwFreq / m_dwFreqSliderFactor ); <br> <br>    wsprintf( szText, "%u Hz", dwFreq ); <br> <br>    Static_SetText( m_ht.hFreqText, szText ); <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// UpdatePlayButton() <br>// <br>//    Uses an internal state flag and the "IsPlaying" flag to determine and set <br>// the proper text (Play/Stop) for the Play button. <br>// <br>void FileInfo::UpdatePlayButton( void ) <br>{ <br>    if( m_fPlayButtonSaysPlay &amp;&amp; IsPlaying()) <br>    { <br>        // Set to "Stop" <br>        m_fPlayButtonSaysPlay = FALSE; <br>        Button_SetText( m_ht.hPlayButton, TEXT("Stop")); <br>    } <br>    else if( !m_fPlayButtonSaysPlay &amp;&amp; !IsPlaying()) <br>    { <br>        // Set to "Play" <br>        Button_SetText( m_ht.hPlayButton, TEXT("Play")); <br>        m_fPlayButtonSaysPlay = TRUE; <br>    } <br>    else <br>        return; <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// OnHScroll() <br>// <br>//    Main message handler for the WM_HSCROLL message.  this function basically <br>// figures out which horizontal scrolling control is responsible for sending <br>// the message and passes on handling to an appropriate function for handling. <br>// <br>BOOL FileInfo::OnHScroll( WORD wNotification, LONG lPos, HWND hControl ) <br>{ <br>    if( !hControl ) <br>        return FALSE; <br>     <br>    if( hControl == m_ht.hProgressSpin ) <br>    { <br>        HandleProgressSpinScroll( wNotification, lPos ); <br>        return TRUE; <br>    } <br>    else if( hControl == m_ht.hProgressSlider ) <br>    { <br>        HandleProgressSliderScroll( wNotification, lPos ); <br>        return TRUE; <br>    } <br>    else if( hControl == m_ht.hFreqSlider ) <br>    { <br>        HandleFreqSliderScroll( wNotification, lPos ); <br>        return TRUE; <br>    } <br>    else if( hControl == m_ht.hVolSlider ) <br>    { <br>        HandleVolSliderScroll( wNotification, lPos ); <br>        return TRUE; <br>    } <br>    else if( hControl == m_ht.hPanSlider ) <br>    { <br>        HandlePanSliderScroll( wNotification, lPos ); <br>        return TRUE; <br>    } <br>    else if( hControl == m_ht.hNotifySlider ) <br>    { <br>        HandleNotifySliderScroll( wNotification, lPos ); <br>        return TRUE; <br>    } <br>    else <br>    return FALSE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// HandleFreqSliderScroll() <br>// <br>//    Helper function for OnHScroll() which handles the WM_HSCROLL message for <br>// the Frequency slider.  Figures out the next position, sets it, and updates <br>// the UI elements that are affected (text). <br>// <br>void FileInfo::HandleFreqSliderScroll( WORD wNot, LONG lPos ) <br>{ <br>    DWORD dwFreq; <br> <br>    switch( wNot ) <br>    { <br>    case TB_THUMBTRACK: <br>        if( NULL != m_pDSB ) <br>        { <br>            if( SUCCEEDED( m_pDSB-&gt;SetFrequency( lPos * m_dwFreqSliderFactor ))) <br>            { <br>                UpdateFreqUI( lPos * m_dwFreqSliderFactor, FALSE ); <br>            } <br>        } <br>        break; <br> <br>    case TB_ENDTRACK: <br>    case TB_LINEDOWN: <br>    case TB_LINEUP: <br>    case TB_PAGEDOWN: <br>    case TB_PAGEUP: <br>        lPos = SendMessage( m_ht.hFreqSlider, TBM_GETPOS, 0, 0 ); <br>        if( NULL != m_pDSB ) <br>        { <br>            if( SUCCEEDED( m_pDSB-&gt;SetFrequency( lPos * m_dwFreqSliderFactor ))) <br>            { <br>                UpdateFreqUI( lPos * m_dwFreqSliderFactor, FALSE ); <br>            } <br>            else <br>            { <br>                if( SUCCEEDED( m_pDSB-&gt;GetFrequency( &amp;dwFreq ))) <br>                { <br>                    SendMessage( m_ht.hFreqSlider, TBM_SETPOS, <br>                                 TRUE, dwFreq / m_dwFreqSliderFactor ); <br>                } <br>            } <br>        } <br>        break; <br>    } <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// HandleProgressSliderScroll() <br>// <br>// <br>// <br>void FileInfo::HandleProgressSliderScroll( WORD wNot, LONG lPos ) <br>{ <br>    BOOL fUpdate = TRUE; <br> <br>    switch( wNot ) <br>    { <br>        case TB_THUMBTRACK: <br>            if( IsPlaying()) <br>                fUpdate = TRUE; <br>            break; <br> <br>        case TB_ENDTRACK: <br>            fUpdate = FALSE; <br>            break; <br> <br>        case TB_LINEDOWN: <br>        case TB_LINEUP: <br>        case TB_PAGEDOWN: <br>        case TB_PAGEUP: <br>            lPos = SendMessage( m_ht.hProgressSlider, TBM_GETPOS, 0, 0 ); <br>            break; <br> <br>        default: <br>            fUpdate = FALSE; <br>    } <br>     <br>    if( fUpdate &amp;&amp; NULL != m_pDSB ) <br>    { <br>        FLOATfPercentage = ((FLOAT)lPos / 10000); <br> <br>        m_pDSB-&gt;SetCurrentPosition( (DWORD)(fPercentage * (m_cbDataSize-1))); <br>        UpdateUI(); <br>    //UpdateProgressUI(  (DWORD)(fPercentage * (m_cbDataSize-1))); <br>    } <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// HandleProgressSpinScroll() <br>// <br>// <br>// <br>void FileInfo::HandleProgressSpinScroll( WORD wNot, LONG lPos ) <br>{ <br>    BOOL fUpdate = TRUE; <br> <br>    switch( wNot ) <br>    { <br>        case SB_THUMBPOSITION: <br>            lPos = SendMessage( m_ht.hProgressSpin, UDM_GETPOS, 0, 0 ); <br>            break; <br> <br>        default: <br>            fUpdate = FALSE; <br>    } <br>     <br>    if( fUpdate &amp;&amp; NULL != m_pDSB ) <br>    { <br>        FLOATfPercentage = ((FLOAT)lPos / 10000); <br> <br>        m_pDSB-&gt;SetCurrentPosition( (DWORD)(fPercentage * (m_cbDataSize-1))); <br>        UpdateUI(); <br>        UpdateProgressUI(  (DWORD)(fPercentage * (m_cbDataSize-1))); <br>    } <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// HandleVolSliderScroll() <br>// <br>//    Helper function for OnHScroll() which handles the WM_HSCROLL message for <br>// the Volume slider.  Figures out the next position, sets it, and updates <br>// the UI elements that are affected (text). <br>// <br>void FileInfo::HandleVolSliderScroll( WORD wNot, LONG lPos ) <br>{ <br>    BOOL fUpdate = TRUE; <br> <br>    switch( wNot ) <br>    { <br>        case TB_THUMBTRACK: <br>            break; <br> <br>        case TB_ENDTRACK: <br>        case TB_LINEDOWN: <br>        case TB_LINEUP: <br>        case TB_PAGEDOWN: <br>        case TB_PAGEUP: <br>            lPos = SendMessage( m_ht.hVolSlider, TBM_GETPOS, 0, 0 ); <br>            break; <br> <br>        default: <br>            fUpdate = FALSE; <br>    } <br>     <br>    if( fUpdate &amp;&amp; NULL != m_pDSB ) <br>    { <br>        m_pDSB-&gt;SetVolume( (lPos * VOL_SLIDER_FACTOR) - VOL_SLIDER_SHIFT ); <br>        DPF( 1, "SetVolume: %i", (lPos * VOL_SLIDER_FACTOR) - VOL_SLIDER_SHIFT ); <br>        UpdateVolUI( (lPos * VOL_SLIDER_FACTOR) - VOL_SLIDER_SHIFT, FALSE ); <br>    } <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// HandlePanSliderScroll() <br>// <br>//    Helper function for OnHScroll() which handles the WM_HSCROLL message for <br>// the Pan slider.  Figures out the next position, sets it, and updates the UI <br>// elements that are affected (text). <br>// <br>void FileInfo::HandlePanSliderScroll( WORD wNot, LONG lPos ) <br>{ <br>    BOOL fUpdate = TRUE; <br> <br>    switch( wNot ) <br>    { <br>        case TB_THUMBTRACK: <br>            break; <br> <br>        case TB_ENDTRACK: <br>        case TB_LINEDOWN: <br>        case TB_LINEUP: <br>        case TB_PAGEDOWN: <br>        case TB_PAGEUP: <br>            lPos = SendMessage( m_ht.hPanSlider, TBM_GETPOS, 0, 0 ); <br>            break; <br> <br>        default: <br>            fUpdate = FALSE; <br>    } <br>     <br>    if( fUpdate &amp;&amp; NULL != m_pDSB ) <br>    { <br>        m_pDSB-&gt;SetPan( (lPos * PAN_SLIDER_FACTOR) - PAN_SLIDER_SHIFT ); <br>        UpdatePanUI( (lPos * PAN_SLIDER_FACTOR) - PAN_SLIDER_SHIFT, FALSE ); <br>    } <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// HandleNotifySliderScroll() <br>// <br>// function: handles WM_SCROLL messages on behalf of the IDC_BUFFERDLG_NOTIFY_SLIDER <br>//           control <br>// <br>void FileInfo::HandleNotifySliderScroll( WORD wNot, LONG lPos ) <br>{ <br>    BOOL        fUpdate = FALSE; <br>    HRESULThRes    = DS_OK; <br>    float       flPosFactor; <br> <br>    // if notifications are enabled, then pay attention to WM_HSCROLL messages <br>    if(IsNotifyOn()) <br>    { <br>        switch( wNot ) <br>        { <br>            case TB_ENDTRACK: <br>            case TB_LINEDOWN: <br>            case TB_LINEUP: <br>            case TB_PAGEDOWN: <br>            case TB_PAGEUP: <br>                fUpdate = TRUE; <br>                lPos = SendMessage( m_ht.hNotifySlider, TBM_GETPOS, 0, 0 ); <br>                break; <br> <br>            case TB_THUMBTRACK: <br>            default: <br>                fUpdate = FALSE; <br>        } <br>     <br>        // if we actually changed something, then bother with SetPositionNotify <br>        if( (fUpdate))  <br>        { <br>    ASSERT(m_pDSB); <br>    ASSERT(m_pDSN); <br> <br>            // the slider position expressed as a fraction <br>            flPosFactor = (float)lPos / (float)NOTIFY_MAX; <br> <br>            // ... translated into bytes into the buffer <br>            m_dsbPosNotify.dwOffset = (DWORD)((float)m_cbDataSize * flPosFactor); <br> <br>            // you must stop the buffer before you SetNotificationPositions <br>            if(IsPlaying()) <br>            { <br>                m_pDSB-&gt;Stop(); <br>            } <br> <br>            // (re)set the notification <br>            ASSERT(m_pDSN); <br>            hRes = m_pDSN-&gt;SetNotificationPositions(1, &amp;m_dsbPosNotify); <br> <br>            if(FAILED(hRes)) <br>            { <br>                MessageBox(NULL, "SetNotificationPositions Failed!", "", MB_ICONEXCLAMATION | MB_OK | MB_TASKMODAL); <br>            } <br>            else  <br>            {     <br>                if(IsPlaying()) <br>                { <br>                    if( IsLooped()) <br>                    { <br>                        m_pDSB-&gt;Play( 0, 0, DSBPLAY_LOOPING ); <br>                    } <br>                    else <br>                    { <br>                        m_pDSB-&gt;Play( 0, 0, 0 ); <br>                    } <br>                } <br>            } <br>        } <br>    } <br>    // otherwise, set the position to 0 <br>    else <br>    { <br>        lPos = SendMessage( m_ht.hNotifySlider, TBM_SETPOS, TRUE, 0 ); <br>    } <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// UpdateNotifySignal() <br>// <br>// function: Updates the little box next to the 'notify' slider according to the <br>//           state of the notification event m_dsbPosNotify.hEventNotify <br>// <br>void FileInfo::UpdateNotifySignal(void) <br>{ <br>    // if we notifications are enabled <br>    if(IsNotifyOn()) <br>    { <br>        RECT    rect; <br>        HDC     hdc; <br>        HBRUSH  hB, hOB; <br>        HPEN    hOP; <br> <br>        OutputDebugString("UpdateNotifySignal\n"); <br> <br>        // dc and rect for the little box <br>        hdc = GetDC(m_ht.hNotifyFrame); <br>        GetClientRect(m_ht.hNotifyFrame, &amp;rect); <br> <br>        // is the notification event signaled? <br>        if(WAIT_OBJECT_0 == WaitForSingleObject(m_dsbPosNotify.hEventNotify, 0)) <br>        { <br>            // get time of notification <br>            m_dwTimeNotified = timeGetTime(); <br>        } <br> <br>        // if the event was signaled &lt; 1/2 sec ago, make fill the box with red,  <br>        //  otherwise with the panel color <br>        if((timeGetTime() - m_dwTimeNotified) &lt; 500) <br>        { <br>            hB = CreateSolidBrush((COLORREF)0x0000ff); <br>        } <br>        else <br>        { <br>            hB = GetSysColorBrush(COLOR_3DFACE); <br>        } <br> <br>        // fill the box <br>        hOP = (HPEN)SelectObject(hdc, GetStockObject(NULL_PEN)); <br>        hOB = (HBRUSH)SelectObject(hdc, hB); <br>        Rectangle(hdc, rect.left, rect.top, rect.right, rect.bottom); <br> <br>        // clean up GDI objects <br>        SelectObject(hdc, hOB); <br>        SelectObject(hdc, hOP); <br>        DeleteObject(hB); <br>        ReleaseDC(m_ht.hNotifyFrame, hdc); <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// OnDestroy() <br>// <br>void FileInfo::OnDestroy() <br>{ <br>    SendDestroyRequest(); <br>    return; <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// OnCommand() <br>// <br>//    Handles WM_COMMAND messages sent to the dialog interface. <br>// <br>BOOL FileInfo::OnCommand( WPARAM wParam, LPARAM lParam ) <br>{ <br>    ASSERT( NULL != m_hwndInterface ); <br> <br>    // These three functions break out the handling of the WM_COMMAND messages <br>    // that will be sent by various context menus.  There's no real difference <br>    // between these and other messages, but keeping them seperate emphasizes <br>    // where they come from and keeps our switch a bit shorter. <br>    if( HandleFreqContext( wParam ) || HandleVolContext( wParam ) <br>        || HandlePanContext( wParam )) <br>    { <br>        return TRUE; <br>    } <br> <br>    switch( LOWORD( wParam )) <br>    { <br>        case ID_BUFFERDLG_FILE_OPEN: <br>            // For convenience, the File|Open command is on the dialog's menu. <br>            // If we see it, we should reflect it to the parent for processing. <br>            ASSERT( NULL != m_pmwOwner ); <br>            SendMessage( m_pmwOwner-&gt;GetHwnd(), WM_COMMAND, <br>                        MAKEWPARAM( IDC_FILE_OPEN, 0 ), 0L ); <br>            break; <br> <br>        case ID_BUFFERDLG_DUPLICATE: <br>            m_pmwOwner-&gt;DuplicateBuffer( this ); <br>            break; <br> <br>        case IDCANCEL: <br>            // This is what the dialog subsystem will send us when the user <br>            // clicks the Close button from the caption bar or the System menu <br>            DestroyWindow( m_hwndInterface ); <br>            break; <br> <br>            case IDC_BUFFERDLG_PLAY_BUTTON: <br>            // Handle the Play button depending on whether or not the buffer is <br>            // playing or stopped. <br>            if( IsPlaying()) <br>            { <br>            StopBuffer(); <br>            } <br>            else <br>            { <br>            PlayBuffer(); <br>            } <br>            UpdatePlayButton(); <br>            break; <br> <br>        case IDC_BUFFERDLG_LOOPED_CHECK: <br>            // Toggle the state of the looping flag with an XOR <br>            m_dwInternalFlags ^= FI_INTERNALF_LOOPED; <br> <br>            // Calling Play will update the looping state in DSound <br>            if( IsPlaying()) <br>                PlayBuffer(); <br>            break; <br> <br>        default: <br>            // FALSE means we didn't want to deal with the message <br>            return FALSE; <br>    } <br> <br>    // TRUE means we processed the message <br>    return TRUE; <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// UpdateFileName() <br>// <br>//    Updates the file name which is displayed in the dialog window caption. <br>// <br>void FileInfo::UpdateFileName( void ) <br>{ <br>    if( NULL != m_hwndInterface ) <br>    { <br>        SendMessage( m_hwndInterface, WM_SETTEXT, 0L, <br>                     (LPARAM)&amp;m_szFileName[m_nFileIndex] ); <br>    } <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// HandlePanContext() <br>// <br>//    Handle WM_COMMAND messages from the Pan context menu.  Returns TRUE if a <br>// message was handled. <br>// <br>BOOL FileInfo::HandlePanContext( WPARAM wParam ) <br>{ <br>    switch( LOWORD( wParam )) <br>    { <br>        case ID_PANCONTEXT_CENTER: <br>            if( m_pDSB ) <br>            { <br>                m_pDSB-&gt;SetPan(0); <br>                UpdatePanUI( 0, FALSE ); <br>            } <br>            break; <br>        case ID_PANCONTEXT_10DB_LEFT: <br>            if( m_pDSB ) <br>            { <br>                m_pDSB-&gt;SetPan(-1000); <br>                UpdatePanUI( -1000, FALSE ); <br>            } <br>            break; <br>        case ID_PANCONTEXT_10DB_RIGHT: <br>            if( m_pDSB ) <br>            { <br>                m_pDSB-&gt;SetPan(1000); <br>                UpdatePanUI( 1000, FALSE ); <br>            } <br>            break; <br>        case ID_PANCONTEXT_FULL_LEFT: <br>            if( m_pDSB ) <br>            { <br>                m_pDSB-&gt;SetPan(-10000); <br>                UpdatePanUI( -10000, FALSE ); <br>            } <br>            break; <br>        case ID_PANCONTEXT_FULL_RIGHT: <br>            if( m_pDSB ) <br>            { <br>                m_pDSB-&gt;SetPan(10000); <br>                UpdatePanUI( 10000, FALSE ); <br>            } <br>            break; <br> <br>        default: <br>            return FALSE; <br>    } <br> <br>    return TRUE; <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// HandleVolContext() <br>// <br>//    Handle WM_COMMAND messages from the Vol context menu.  Returns TRUE if a <br>// message was handled. <br>// <br>BOOL FileInfo::HandleVolContext( WPARAM wParam ) <br>{ <br>    switch( LOWORD( wParam )) <br>    { <br>        case ID_VOLCONTEXT_0DB: <br>            if( m_pDSB ) <br>            { <br>                m_pDSB-&gt;SetVolume(0); <br>                UpdateVolUI( 0, FALSE ); <br>            } <br>            break; <br>        case ID_VOLCONTEXT_10DB: <br>            if( m_pDSB ) <br>            { <br>                m_pDSB-&gt;SetVolume(-1000); <br>                UpdateVolUI( -1000, FALSE ); <br>            } <br>            break; <br>        case ID_VOLCONTEXT_20DB: <br>            if( m_pDSB ) <br>            { <br>                m_pDSB-&gt;SetVolume(-2000); <br>                UpdateVolUI( -2000, FALSE ); <br>            } <br>            break; <br>        case ID_VOLCONTEXT_30DB: <br>            if( m_pDSB ) <br>            { <br>                m_pDSB-&gt;SetVolume(-3000); <br>                UpdateVolUI( -3000, FALSE ); <br>            } <br>            break; <br>        case ID_VOLCONTEXT_100DB: <br>            if( m_pDSB ) <br>            { <br>                m_pDSB-&gt;SetVolume(-10000); <br>                UpdateVolUI( -10000, FALSE ); <br>            } <br>            break; <br> <br>        default: <br>            return FALSE; <br>    } <br> <br>    return TRUE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// HandleFreqContext() <br>// <br>//    Handle WM_COMMAND messages from the Freq context menu.  Returns TRUE if a <br>// message was handled. <br>// <br>BOOL FileInfo::HandleFreqContext( WPARAM wParam ) <br>{ <br>    switch( LOWORD( wParam )) <br>    { <br>        case ID_FREQCONTEXT_FILEDEFAULT: <br>            if( m_pDSB ) <br>            { <br>                if( SUCCEEDED( m_pDSB-&gt;SetFrequency(m_pwfx-&gt;nSamplesPerSec))) <br>                    UpdateFreqUI( m_pwfx-&gt;nSamplesPerSec, FALSE ); <br>            } <br>            break; <br> <br>        case ID_FREQCONTEXT_8000HZ: <br>            if( m_pDSB ) <br>            { <br>                if( SUCCEEDED( m_pDSB-&gt;SetFrequency(8000))) <br>                    UpdateFreqUI( 8000, FALSE ); <br>            } <br>            break; <br> <br>        case ID_FREQCONTEXT_11025HZ: <br>            if( m_pDSB ) <br>            { <br>                if( SUCCEEDED( m_pDSB-&gt;SetFrequency(11025))) <br>                    UpdateFreqUI( 11025, FALSE ); <br>            } <br>            break; <br> <br>        case ID_FREQCONTEXT_22050HZ: <br>            if( m_pDSB ) <br>            { <br>                if( SUCCEEDED( m_pDSB-&gt;SetFrequency(22050))) <br>                    UpdateFreqUI( 22050, FALSE ); <br>            } <br>            break; <br> <br>        case ID_FREQCONTEXT_44100HZ: <br>            if( m_pDSB ) <br>            { <br>                if( SUCCEEDED( m_pDSB-&gt;SetFrequency(44100))) <br>                    UpdateFreqUI( 44100, FALSE ); <br>            } <br>            break; <br> <br>        default: <br>            return FALSE; <br>    } <br>    return TRUE; <br>} <br> <br>//////////////////////////////////////////////////////////// <br>BOOL IsValidHandle(HANDLE h) <br>{ <br>    if((h == NULL) || (h == INVALID_HANDLE_VALUE)) <br>        return FALSE; <br>     <br>    return TRUE; <br>} <br> <br>void SafeCloseHandle(HANDLE* pH) <br>{ <br>    // if handle looks valid, close it <br>    if((*pH != NULL) &amp;&amp; (*pH != INVALID_HANDLE_VALUE)) <br>    { <br>        CloseHandle(*pH); <br>    } <br> <br>    *pH = INVALID_HANDLE_VALUE; <br>    return; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
