<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WAVE.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3115"></a>WAVE.C</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1995-1996 Microsoft Corporation. All Rights Reserved. <br> * <br> *  File:               wave.c <br> *  Content:    Wave library routines. <br> *      This file is used for loading/saving waves, and reading and <br> *      writing waves in smaller blocks. <br> *      Uses WaveOpenFile, WaveReadFile and WaveCloseReadFile for <br> *      single block access to reading wave files. <br> *      Uses WaveCreateFile, WaveWriteFile, WaveCloseWriteFile for <br> *      single block access for writing  wave files. <br> *      Uses WaveLoadFile to load a whole wave file into memory. <br> *      Uses WaveSaveFile to save a whole wave file into memory. <br> * <br> ***************************************************************************/ <br> <br>/* PROTOTYPES */ <br>#include &lt;windows.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include "wave.h" <br>#include "debug.h" <br>#include "windowsx.h" <br> <br> <br>/* ROUTINES */ <br>/* -------------------------------------------------------*/ <br> <br>/* This function will open a wave input file and prepare it for reading, <br> * so the data can be easily <br> * read with WaveReadFile. Returns 0 if successful, the error code if not. <br> *      pszFileName - Input filename to load. <br> *      phmmioIn    - Pointer to handle which will be used <br> *          for further mmio routines. <br> *      ppwfxInfo   - Ptr to ptr to WaveFormatEx structure <br> *          with all info about the file.                         <br> *       <br>*/ <br>int WaveOpenFile( <br>TCHAR*pszFileName,                              // (IN) <br>HMMIO *phmmioIn,                                // (OUT) <br>WAVEFORMATEX **ppwfxInfo,                       // (OUT) <br>MMCKINFO *pckInRIFF                             // (OUT) <br>) <br>{ <br>HMMIO           hmmioIn; <br>MMCKINFO        ckIn;           // chunk info. for general use. <br>PCMWAVEFORMAT   pcmWaveFormat;  // Temp PCM structure to load in.        <br>WORD            cbExtraAlloc;   // Extra bytes for waveformatex  <br>int             nError;         // Return value. <br> <br> <br>// Initialization... <br>*ppwfxInfo = NULL; <br>nError = 0; <br>hmmioIn = NULL; <br> <br>if ((hmmioIn = mmioOpen(pszFileName, NULL, MMIO_ALLOCBUF | MMIO_READ)) == NULL) <br>{ <br>nError = ER_CANNOTOPEN; <br>goto ERROR_READING_WAVE; <br>} <br> <br>if ((nError = (int)mmioDescend(hmmioIn, pckInRIFF, NULL, 0)) != 0) <br>{ <br>goto ERROR_READING_WAVE; <br>} <br> <br> <br>if ((pckInRIFF-&gt;ckid != FOURCC_RIFF) || (pckInRIFF-&gt;fccType != mmioFOURCC('W', 'A', 'V', 'E'))) <br>{ <br>nError = ER_NOTWAVEFILE; <br>goto ERROR_READING_WAVE; <br>} <br> <br>/* Search the input file for for the 'fmt ' chunk.     */ <br>    ckIn.ckid = mmioFOURCC('f', 'm', 't', ' '); <br>    if ((nError = (int)mmioDescend(hmmioIn, &amp;ckIn, pckInRIFF, MMIO_FINDCHUNK)) != 0) <br>{ <br>goto ERROR_READING_WAVE;                 <br>} <br> <br>/* Expect the 'fmt' chunk to be at least as large as &lt;PCMWAVEFORMAT&gt;; <br>    * if there are extra parameters at the end, we'll ignore them */ <br>     <br>    if (ckIn.cksize &lt; (long) sizeof(PCMWAVEFORMAT)) <br>{ <br>nError = ER_NOTWAVEFILE; <br>goto ERROR_READING_WAVE; <br>} <br> <br>/* Read the 'fmt ' chunk into &lt;pcmWaveFormat&gt;.*/      <br>    if (mmioRead(hmmioIn, (HPSTR) &amp;pcmWaveFormat, (long) sizeof(pcmWaveFormat)) != (long) sizeof(pcmWaveFormat)) <br>{ <br>nError = ER_CANNOTREAD; <br>goto ERROR_READING_WAVE; <br>} <br> <br> <br>// Ok, allocate the waveformatex, but if its not pcm <br>// format, read the next word, and thats how many extra <br>// bytes to allocate. <br>if (pcmWaveFormat.wf.wFormatTag == WAVE_FORMAT_PCM) <br>cbExtraAlloc = 0;                                <br> <br>else <br>{ <br>// Read in length of extra bytes. <br>if (mmioRead(hmmioIn, (LPTSTR) &amp;cbExtraAlloc, <br>(long) sizeof(cbExtraAlloc)) != (long) sizeof(cbExtraAlloc)) <br>{ <br>nError = ER_CANNOTREAD; <br>goto ERROR_READING_WAVE; <br>} <br> <br>} <br> <br>// Ok, now allocate that waveformatex structure. <br>if ((*ppwfxInfo = GlobalAlloc(GMEM_FIXED, sizeof(WAVEFORMATEX)+cbExtraAlloc)) == NULL) <br>{ <br>nError = ER_MEM; <br>goto ERROR_READING_WAVE; <br>} <br> <br>// Copy the bytes from the pcm structure to the waveformatex structure <br>memcpy(*ppwfxInfo, &amp;pcmWaveFormat, sizeof(pcmWaveFormat)); <br>(*ppwfxInfo)-&gt;cbSize = cbExtraAlloc; <br> <br>// Now, read those extra bytes into the structure, if cbExtraAlloc != 0. <br>if (cbExtraAlloc != 0) <br>{ <br>if (mmioRead(hmmioIn, (LPTSTR) (((BYTE*)&amp;((*ppwfxInfo)-&gt;cbSize))+sizeof(cbExtraAlloc)), <br>(long) (cbExtraAlloc)) != (long) (cbExtraAlloc)) <br>{ <br>nError = ER_NOTWAVEFILE; <br>goto ERROR_READING_WAVE; <br>} <br>} <br> <br>/* Ascend the input file out of the 'fmt ' chunk. */                                                             <br>if ((nError = mmioAscend(hmmioIn, &amp;ckIn, 0)) != 0) <br>{ <br>goto ERROR_READING_WAVE; <br> <br>} <br> <br> <br>goto TEMPCLEANUP;                <br> <br>ERROR_READING_WAVE: <br>if (*ppwfxInfo != NULL) <br>{ <br>GlobalFree(*ppwfxInfo); <br>*ppwfxInfo = NULL; <br>}                <br> <br>if (hmmioIn != NULL) <br>{ <br>mmioClose(hmmioIn, 0); <br>hmmioIn = NULL; <br>} <br> <br>TEMPCLEANUP: <br>*phmmioIn = hmmioIn; <br> <br>return(nError); <br> <br>} <br> <br>/*      This routine has to be called before WaveReadFile as it searchs for the chunk to descend into for <br>reading, that is, the 'data' chunk.  For simplicity, this used to be in the open routine, but was <br>taken out and moved to a separate routine so there was more control on the chunks that are before <br>the data chunk, such as 'fact', etc... */ <br> <br>int WaveStartDataRead( <br>HMMIO *phmmioIn, <br>MMCKINFO *pckIn, <br>MMCKINFO *pckInRIFF <br>) <br>{ <br>int                     nError; <br> <br>nError = 0; <br> <br>// Do a nice little seek... <br>if ((nError = mmioSeek(*phmmioIn, pckInRIFF-&gt;dwDataOffset + sizeof(FOURCC), SEEK_SET)) == -1) <br>{ <br>ASSERT(FALSE); <br>} <br> <br>nError = 0; <br>//      Search the input file for for the 'data' chunk. <br>pckIn-&gt;ckid = mmioFOURCC('d', 'a', 't', 'a'); <br>if ((nError = mmioDescend(*phmmioIn, pckIn, pckInRIFF, MMIO_FINDCHUNK)) != 0) <br>{ <br>goto ERROR_READING_WAVE; <br>} <br> <br>goto CLEANUP; <br> <br>ERROR_READING_WAVE: <br> <br>CLEANUP:         <br>return(nError); <br>} <br> <br> <br>/*      This will read wave data from the wave file.  Makre sure we're descended into <br>the data chunk, else this will fail bigtime! <br>hmmioIn         - Handle to mmio. <br>cbRead          - # of bytes to read.    <br>pbDest          - Destination buffer to put bytes. <br>cbActualRead- # of bytes actually read. <br> <br> <br> <br>*/ <br> <br> <br>int WaveReadFile( <br>HMMIO hmmioIn,                          // IN <br>UINT cbRead,                            // IN            <br>BYTE *pbDest,                           // IN <br>MMCKINFO *pckIn,                        // IN. <br>UINT *cbActualRead                      // OUT. <br> <br>) <br>{ <br> <br>MMIOINFO    mmioinfoIn;         // current status of &lt;hmmioIn&gt; <br>int                     nError; <br>UINT            cT, cbDataIn; <br> <br>nError = 0; <br> <br>if (nError = mmioGetInfo(hmmioIn, &amp;mmioinfoIn, 0) != 0) <br>{ <br>goto ERROR_CANNOT_READ; <br>} <br> <br>cbDataIn = cbRead; <br>if (cbDataIn &gt; pckIn-&gt;cksize)  <br>cbDataIn = pckIn-&gt;cksize;        <br> <br>pckIn-&gt;cksize -= cbDataIn; <br> <br>for (cT = 0; cT &lt; cbDataIn; cT++) <br>{ <br>/* Copy the bytes from the io to the buffer. */ <br>if (mmioinfoIn.pchNext == mmioinfoIn.pchEndRead) <br>{ <br>    if ((nError = mmioAdvance(hmmioIn, &amp;mmioinfoIn, MMIO_READ)) != 0) <br>{ <br>goto ERROR_CANNOT_READ; <br>}  <br>    if (mmioinfoIn.pchNext == mmioinfoIn.pchEndRead) <br>{ <br>nError = ER_CORRUPTWAVEFILE; <br>goto ERROR_CANNOT_READ; <br>} <br>} <br> <br>// Actual copy. <br>*((BYTE*)pbDest+cT) = *((BYTE*)mmioinfoIn.pchNext)++;                                                                                                    <br>} <br> <br>if ((nError = mmioSetInfo(hmmioIn, &amp;mmioinfoIn, 0)) != 0) <br>{ <br>goto ERROR_CANNOT_READ; <br>} <br> <br>*cbActualRead = cbDataIn; <br>goto FINISHED_READING; <br> <br>ERROR_CANNOT_READ: <br>*cbActualRead = 0; <br> <br>FINISHED_READING: <br>return(nError); <br> <br>} <br> <br>/*      This will close the wave file openned with WaveOpenFile.   <br>phmmioIn - Pointer to the handle to input MMIO. <br>ppwfxSrc - Pointer to pointer to WaveFormatEx structure. <br> <br>Returns 0 if successful, non-zero if there was a warning. <br> <br>*/ <br>int WaveCloseReadFile( <br>HMMIO *phmmio,                                  // IN <br>WAVEFORMATEX **ppwfxSrc                 // IN <br>) <br>{ <br> <br>if (*ppwfxSrc != NULL) <br>{ <br>GlobalFree(*ppwfxSrc); <br>*ppwfxSrc = NULL; <br>} <br> <br>if (*phmmio != NULL) <br>{ <br>mmioClose(*phmmio, 0); <br>*phmmio = NULL; <br>} <br> <br>return(0); <br> <br>} <br> <br>/*      This routine will create a wave file for writing.  This will automatically overwrite any <br>existing file with the same name, so be careful and check before hand!!! <br>pszFileName     - Pointer to filename to write. <br>phmmioOut               - Pointer to HMMIO handle that is used for further writes <br>pwfxDest                - Valid waveformatex destination structure. <br>pckOut                  - Pointer to be set with the MMCKINFO. <br>pckOutRIFF              - Pointer to be set with the RIFF info. <br> <br>*/ <br>int WaveCreateFile( <br>TCHAR*pszFileName,                              // (IN) <br>HMMIO *phmmioOut,                               // (OUT) <br>WAVEFORMATEX *pwfxDest,                 // (IN) <br>MMCKINFO *pckOut,                               // (OUT) <br>MMCKINFO *pckOutRIFF                    // (OUT) <br> <br>) <br>{ <br>     <br>int             nError;                         // Return value. <br>DWORD           dwFactChunk;            // Contains the actual fact chunk. Garbage until WaveCloseWriteFile. <br>MMCKINFO        ckOut1; <br> <br>dwFactChunk = (DWORD)-1; <br>nError = 0; <br> <br>*phmmioOut = mmioOpen(pszFileName, NULL, <br>MMIO_ALLOCBUF | MMIO_READWRITE|MMIO_CREATE); <br> <br>    if (*phmmioOut == NULL) <br>{ <br>nError = ER_CANNOTWRITE; <br>goto ERROR_CANNOT_WRITE;    // cannot save WAVE file <br>} <br> <br>    /* Create the output file RIFF chunk of form type 'WAVE'. <br>     */ <br>    pckOutRIFF-&gt;fccType = mmioFOURCC('W', 'A', 'V', 'E');        <br>pckOutRIFF-&gt;cksize = 0;  <br>    if ((nError = mmioCreateChunk(*phmmioOut, pckOutRIFF, MMIO_CREATERIFF)) != 0) <br>{ <br>goto ERROR_CANNOT_WRITE;    // cannot write file, probably <br>} <br> <br>    /* We are now descended into the 'RIFF' chunk we just created. <br>     * Now create the 'fmt ' chunk. Since we know the size of this chunk, <br>     * specify it in the MMCKINFO structure so MMIO doesn't have to seek <br>     * back and set the chunk size after ascending from the chunk. <br>     */ <br>    pckOut-&gt;ckid = mmioFOURCC('f', 'm', 't', ' '); <br>    pckOut-&gt;cksize = sizeof(PCMWAVEFORMAT);   // we know the size of this ck. <br>    if ((nError = mmioCreateChunk(*phmmioOut, pckOut, 0)) != 0) <br>{ <br>goto ERROR_CANNOT_WRITE;    // cannot write file, probably <br>} <br> <br>    /* Write the PCMWAVEFORMAT structure to the 'fmt ' chunk if its that type. */ <br>    if (pwfxDest-&gt;wFormatTag == WAVE_FORMAT_PCM) <br>{ <br>    if (mmioWrite(*phmmioOut, (HPSTR) pwfxDest, sizeof(PCMWAVEFORMAT)) <br>!= sizeof(PCMWAVEFORMAT)) <br>{ <br>nError = ER_CANNOTWRITE; <br>goto ERROR_CANNOT_WRITE;    // cannot write file, probably <br>} <br>} <br> <br>else  <br>{ <br>// Write the variable length size. <br>if ((UINT)mmioWrite(*phmmioOut, (HPSTR) pwfxDest, sizeof(*pwfxDest)+pwfxDest-&gt;cbSize) <br>!= (sizeof(*pwfxDest)+pwfxDest-&gt;cbSize)) <br>{ <br>nError = ER_CANNOTWRITE; <br>goto ERROR_CANNOT_WRITE;    // cannot write file, probably <br>}  <br> <br>}   <br> <br>    /* Ascend out of the 'fmt ' chunk, back into the 'RIFF' chunk. <br>     */ <br>    if ((nError = mmioAscend(*phmmioOut, pckOut, 0)) != 0) <br>{ <br>goto ERROR_CANNOT_WRITE;    // cannot write file, probably <br>} <br> <br>// Now create the fact chunk, not required for PCM but nice to have.  This is filled <br>// in when the close routine is called. <br>ckOut1.ckid = mmioFOURCC('f', 'a', 'c', 't'); <br>ckOut1.cksize = 0; <br>    if ((nError = mmioCreateChunk(*phmmioOut, &amp;ckOut1, 0)) != 0) <br>{ <br>goto ERROR_CANNOT_WRITE;    // cannot write file, probably <br>} <br> <br>if (mmioWrite(*phmmioOut, (HPSTR)&amp;dwFactChunk, sizeof(dwFactChunk)) != sizeof(dwFactChunk)) <br>{ <br>nError = ER_CANNOTWRITE; <br>goto ERROR_CANNOT_WRITE; <br>} <br> <br>// Now ascend out of the fact chunk... <br>    if ((nError = mmioAscend(*phmmioOut, &amp;ckOut1, 0)) != 0) <br>{ <br>nError = ER_CANNOTWRITE;        // cannot write file, probably <br>goto ERROR_CANNOT_WRITE; <br>} <br> <br>  <br>    <br>goto DONE_CREATE; <br> <br>ERROR_CANNOT_WRITE: <br>// Maybe delete the half-written file?  Ah forget it for now, its good to leave the <br>// file there for debugging... <br> <br>DONE_CREATE: <br>return(nError); <br> <br>} <br> <br>/*      This routine has to be called before any data is written to the wave output file, via wavewritefile.  This <br>sets up the data to write, and creates the data chunk. <br>*/ <br> <br>int WaveStartDataWrite( <br>HMMIO *phmmioOut,                               // (IN) <br>MMCKINFO *pckOut,                               // (IN) <br>MMIOINFO *pmmioinfoOut                  // (OUT) <br>) <br>{ <br> <br>int             nError; <br> <br>nError = 0; <br> /* Create the 'data' chunk that holds the waveform samples.  */ <br>    pckOut-&gt;ckid = mmioFOURCC('d', 'a', 't', 'a'); <br>pckOut-&gt;cksize = 0; <br>    if ((nError = mmioCreateChunk(*phmmioOut, pckOut, 0)) != 0) <br>{ <br>goto ERROR_CANNOT_WRITE;    // cannot write file, probably <br>} <br> <br>if ((nError = mmioGetInfo(*phmmioOut, pmmioinfoOut, 0)) != 0) <br>{ <br>goto ERROR_CANNOT_WRITE; <br>} <br> <br>goto CLEANUP; <br>ERROR_CANNOT_WRITE:      <br> <br>CLEANUP: <br>return(nError); <br>} <br> <br>/* This routine will write out data to a wave file.  <br>hmmioOut                - Handle to hmmioOut filled by WaveCreateFile <br>cbWrite                 - # of bytes to write out. <br>pbSrc                   - Pointer to source. <br>pckOut                  - pointer to ckOut filled by WaveCreateFile <br>cbActualWrite   - # of actual bytes written. <br>pmmioinfoOut    - Pointer to mmioinfoOut filled by WaveCreateFile. <br> <br>Returns 0 if successful, else the error code. <br> <br> */ <br> <br> <br>int WaveWriteFile( <br>HMMIO hmmioOut,                         // (IN) <br>UINT cbWrite,                           // (IN) <br>BYTE *pbSrc,                            // (IN) <br>MMCKINFO *pckOut,                       // (IN) <br>UINT *cbActualWrite,            // (OUT) <br>MMIOINFO *pmmioinfoOut          // (IN) <br>) <br>{ <br> <br> <br>int                     nError; <br>UINT            cT; <br> <br>nError = 0; <br> <br>*cbActualWrite = 0; <br> <br>for (cT=0; cT &lt; cbWrite; cT++) <br>{        <br>if (pmmioinfoOut-&gt;pchNext == pmmioinfoOut-&gt;pchEndWrite) <br>{ <br>pmmioinfoOut-&gt;dwFlags |= MMIO_DIRTY; <br>if ((nError = mmioAdvance(hmmioOut, pmmioinfoOut, MMIO_WRITE)) != 0) <br>{ <br>    goto ERROR_CANNOT_WRITE; <br>} <br>} <br>*((BYTE*)pmmioinfoOut-&gt;pchNext)++ = *((BYTE*)pbSrc+cT); <br>(*cbActualWrite)++; <br>} <br> <br> <br>ERROR_CANNOT_WRITE: <br>// What to do here?  Well, for now, nothing, just return that error.  (maybe delete the <br>// file later? <br> <br>return(nError); <br> <br>} <br> <br> <br> <br>/*      This routine will close a wave file used for writing.  Returns 0 if successful, else <br>the error code. <br>phmmioOut       - Pointer to mmio handle for saving. <br>pckOut          - Pointer to the MMCKINFO for saving. <br>pckOutRiff      - Pointer to the riff MMCKINFO for saving. <br>pmmioinfoOut- Pointer to mmioinfo for saving. <br>cSamples        - # of samples saved, for the fact chunk.  For PCM, this isn't used but <br>  will be written anyway, so this can be zero as long as programs ignore <br>  this field when they load PCM formats. <br> <br> <br> <br>*/ <br>int WaveCloseWriteFile( <br>HMMIO *phmmioOut,               // (IN) <br>MMCKINFO *pckOut,               // (IN) <br>MMCKINFO *pckOutRIFF,   // (IN) <br>MMIOINFO *pmmioinfoOut, // (IN) <br>DWORD cSamples                  // (IN) <br>) <br>{ <br> <br>int                     nError;                          <br> <br>nError = 0; <br> <br>if (*phmmioOut == NULL) <br>return(0); <br> <br>pmmioinfoOut-&gt;dwFlags |= MMIO_DIRTY; <br>    if ((nError = mmioSetInfo(*phmmioOut, pmmioinfoOut, 0)) != 0) <br>{ <br>// cannot flush, probably... <br>goto ERROR_CANNOT_WRITE;                                 <br>} <br> <br> /* Ascend the output file out of the 'data' chunk -- this will cause <br>     * the chunk size of the 'data' chunk to be written. <br>     */ <br>    if ((nError = mmioAscend(*phmmioOut, pckOut, 0)) != 0) <br>goto ERROR_CANNOT_WRITE;    // cannot write file, probably <br> <br> <br>// Do this here instead... <br>if ((nError = mmioAscend(*phmmioOut, pckOutRIFF, 0)) != 0) <br>goto ERROR_CANNOT_WRITE;    // cannot write file, probably <br> <br> <br>nError = mmioSeek(*phmmioOut, 0, SEEK_SET); <br>if ((nError = (int)mmioDescend(*phmmioOut, pckOutRIFF, NULL, 0)) != 0) <br>{ <br>goto ERROR_CANNOT_WRITE; <br>} <br> <br>nError = 0; <br>pckOut-&gt;ckid = mmioFOURCC('f', 'a', 'c', 't'); <br>if ((nError = mmioDescend(*phmmioOut, pckOut, pckOutRIFF, MMIO_FINDCHUNK)) == 0) <br>{ <br>// If it didn't fail, write the fact chunk out, if it failed, not critical, just <br>// assert (below). <br>    nError = mmioWrite(*phmmioOut, (HPSTR)&amp;cSamples, sizeof(DWORD)); <br>nError = mmioAscend(*phmmioOut, pckOut, 0);  <br>nError = 0; <br>} <br>else  <br>{ <br>nError = 0; <br>ASSERT(FALSE); <br>} <br> <br>// CANTWRITEFACT: <br>    /* Ascend the output file out of the 'RIFF' chunk -- this will cause <br>     * the chunk size of the 'RIFF' chunk to be written. <br>     */ <br>    if ((nError = mmioAscend(*phmmioOut, pckOutRIFF, 0)) != 0) <br>goto ERROR_CANNOT_WRITE;    // cannot write file, probably <br> <br> <br> <br>ERROR_CANNOT_WRITE: <br>if (*phmmioOut != NULL) <br>{ <br>mmioClose(*phmmioOut, 0); <br>*phmmioOut = NULL; <br>} <br> <br>return(nError); <br> <br>} <br> <br>/*      This routine will copy from a source wave file to a destination wave file all those useless chunks <br>(well, the ones useless to conversions, etc --&gt; apparently people use them!).  The source will be <br>seeked to the begining, but the destination has to be at a current pointer to put the new chunks. <br>This will also seek     back to the start of the wave riff header at the end of the routine. <br> <br>phmmioIn                - Pointer to input mmio file handle. <br>pckIn                   - Pointer to a nice ckIn to use. <br>pckInRiff               - Pointer to the main riff. <br>phmmioOut               - Pointer to output mmio file handle. <br>pckOut                  - Pointer to nice ckOut to use. <br>pckOutRiff              - Pointer to the main riff. <br> <br> <br>Returns 0 if successful, else the error code.  If this routine fails, it still attemps to seek back to <br>the start of the wave riff header, though this too could be unsuccessful. <br>*/ <br> <br>int WaveCopyUselessChunks( <br>HMMIO *phmmioIn,  <br>MMCKINFO *pckIn,  <br>MMCKINFO *pckInRiff,  <br>HMMIO *phmmioOut,  <br>MMCKINFO *pckOut,  <br>MMCKINFO *pckOutRiff) <br>{ <br> <br>int                             nError; <br> <br>nError = 0; <br>// First seek to the stinking start of the file, not including the riff header... <br>if ((nError = mmioSeek(*phmmioIn, pckInRiff-&gt;dwDataOffset + sizeof(FOURCC), SEEK_SET)) == -1) <br>{ <br>nError = ER_CANNOTREAD; <br>goto ERROR_IN_PROC; <br>} <br> <br>nError = 0;                      <br> <br>    while (mmioDescend(*phmmioIn, pckIn, pckInRiff, 0) == 0) <br>    { <br> <br>//  quickly check for corrupt RIFF file--don't ascend past end!         <br>if ((pckIn-&gt;dwDataOffset + pckIn-&gt;cksize) &gt; (pckInRiff-&gt;dwDataOffset + pckInRiff-&gt;cksize)) <br>    goto ERROR_IN_PROC; <br> <br>switch (pckIn-&gt;ckid) <br>{                    <br>    //  explicitly skip these...             <br>    case mmioFOURCC('f', 'm', 't', ' '): <br>break; <br> <br>    case mmioFOURCC('d', 'a', 't', 'a'): <br>break; <br> <br>    case mmioFOURCC('f', 'a', 'c', 't'): <br>break; <br> <br>    case mmioFOURCC('J', 'U', 'N', 'K'): <br>break; <br> <br>    case mmioFOURCC('P', 'A', 'D', ' '): <br>break; <br> <br>    case mmioFOURCC('c', 'u', 'e', ' '): <br>break;                                                   <br>     <br>    //  copy chunks that are OK to copy             <br>    case mmioFOURCC('p', 'l', 's', 't'): <br>// although without the 'cue' chunk, it doesn't make much sense <br>riffCopyChunk(*phmmioIn, *phmmioOut, pckIn); <br>break; <br> <br>    case mmioFOURCC('D', 'I', 'S', 'P'): <br>riffCopyChunk(*phmmioIn, *phmmioOut, pckIn); <br>break; <br> <br> <br>    //  don't copy unknown chunks <br>    default: <br>break; <br>} <br> <br> <br>//  step up to prepare for next chunk..         <br>mmioAscend(*phmmioIn, pckIn, 0); <br>    } <br> <br>ERROR_IN_PROC:   <br>{ <br>int nErrorT; <br>// Seek back to riff header      <br>nErrorT = mmioSeek(*phmmioIn, pckInRiff-&gt;dwDataOffset + sizeof(FOURCC), SEEK_SET); <br>} <br> <br>return(nError); <br>} <br> <br>/** BOOL RIFFAPI riffCopyChunk(HMMIO hmmioSrc, HMMIO hmmioDst, const LPMMCKINFO lpck) <br> * <br> *  DESCRIPTION: <br> *       <br> * <br> *  ARGUMENTS: <br> *      (LPWAVECONVCB lpwc, LPMMCKINFO lpck) <br> * <br> *  RETURN (BOOL NEAR PASCAL): <br> * <br> * <br> *  NOTES: <br> * <br> **  */ <br> <br>BOOL riffCopyChunk(HMMIO hmmioSrc, HMMIO hmmioDst, const LPMMCKINFO lpck) <br>{ <br>    MMCKINFO    ck; <br>    HPSTR       hpBuf; <br> <br>    // <br>    // <br>    // <br>    hpBuf = (HPSTR)GlobalAllocPtr(GHND, lpck-&gt;cksize); <br>    if (!hpBuf) <br>return (FALSE); <br> <br>    ck.ckid   = lpck-&gt;ckid; <br>    ck.cksize = lpck-&gt;cksize; <br>    if (mmioCreateChunk(hmmioDst, &amp;ck, 0)) <br>goto rscc_Error; <br> <br>    if (mmioRead(hmmioSrc, hpBuf, lpck-&gt;cksize) != (LONG)lpck-&gt;cksize) <br>goto rscc_Error; <br> <br>    if (mmioWrite(hmmioDst, hpBuf, lpck-&gt;cksize) != (LONG)lpck-&gt;cksize) <br>goto rscc_Error; <br> <br>    if (mmioAscend(hmmioDst, &amp;ck, 0)) <br>goto rscc_Error; <br> <br>    if (hpBuf) <br>GlobalFreePtr(hpBuf); <br> <br>    return (TRUE); <br> <br>rscc_Error: <br> <br>    if (hpBuf) <br>GlobalFreePtr(hpBuf); <br> <br>    return (FALSE); <br>} /* RIFFSupCopyChunk() */ <br> <br> <br> <br>/*      This routine loads a full wave file into memory.  Be careful, wave files can get <br>pretty big these days :).   <br>szFileName      -       sz Filename <br>cbSize          -       Size of loaded wave (returned) <br>cSamples        -       # of samples loaded. <br>ppwfxInfo       -       Pointer to pointer to waveformatex structure.  The wfx structure <br>IS ALLOCATED by this routine!  Make sure to free it! <br>ppbData         -       Pointer to a byte pointer (globalalloc) which is allocated by this  <br>routine.  Make sure to free it! <br> <br>Returns 0 if successful, else the error code. <br>*/ <br> <br>int WaveLoadFile( <br>TCHAR*pszFileName,                      // (IN) <br>UINT *cbSize,                           // (OUT) <br>WAVEFORMATEX **ppwfxInfo,       // (OUT) <br>BYTE **ppbData                          // (OUT) <br>) <br>{ <br> <br>HMMIO                           hmmioIn;         <br>MMCKINFO                        ckInRiff; <br>MMCKINFO                        ckIn; <br>int                                     nError; <br>UINT                            cbActualRead; <br> <br>*ppbData = NULL; <br>*ppwfxInfo = NULL; <br>*cbSize = 0; <br> <br>if ((nError = WaveOpenFile(pszFileName, &amp;hmmioIn, ppwfxInfo, &amp;ckInRiff)) != 0) <br>{ <br>goto ERROR_LOADING; <br>} <br> <br>if ((nError = WaveStartDataRead(&amp;hmmioIn, &amp;ckIn, &amp;ckInRiff)) != 0) <br>{ <br>goto ERROR_LOADING; <br>} <br> <br>// Ok, size of wave data is in ckIn, allocate that buffer. <br>if ((*ppbData = (BYTE *)GlobalAlloc(GMEM_FIXED, ckIn.cksize)) == NULL) <br>{ <br>nError = ER_MEM; <br>goto ERROR_LOADING; <br>} <br> <br>if ((nError = WaveReadFile(hmmioIn, ckIn.cksize, *ppbData, &amp;ckIn, &amp;cbActualRead)) != 0) <br>{ <br>goto ERROR_LOADING; <br>}         <br> <br>*cbSize = cbActualRead; <br>goto DONE_LOADING; <br> <br>ERROR_LOADING: <br>if (*ppbData != NULL) <br>{ <br>GlobalFree(*ppbData); <br>*ppbData = NULL; <br>} <br>if (*ppwfxInfo != NULL) <br>{ <br>GlobalFree(*ppwfxInfo); <br>*ppwfxInfo = NULL; <br>} <br> <br>DONE_LOADING: <br>// Close the wave file.  <br>if (hmmioIn != NULL) <br>{ <br>mmioClose(hmmioIn, 0); <br>hmmioIn = NULL; <br>} <br> <br>return(nError); <br> <br>} <br> <br>/*      This routine saves a wave file in currently in memory. <br>pszFileName -   FileName to save to.  Automatically overwritten, be careful! <br>cbSize          -       Size in bytes to write. <br>cSamples        -       # of samples to write, used to make the fact chunk. (if !PCM) <br>pwfxDest        -       Pointer to waveformatex structure. <br>pbData          -       Pointer to the data. <br>*/       <br> <br>int WaveSaveFile( <br>TCHAR*pszFileName,                      // (IN) <br>UINT cbSize,                            // (IN) <br>DWORD cSamples,                         // (IN)  <br>WAVEFORMATEX *pwfxDest,         // (IN) <br>BYTE *pbData                            // (IN) <br>) <br>{ <br> <br>HMMIO           hmmioOut; <br>MMCKINFO        ckOut; <br>MMCKINFO        ckOutRIFF; <br>MMIOINFO        mmioinfoOut; <br>UINT            cbActualWrite; <br>int                     nError; <br> <br>if ((nError = WaveCreateFile(pszFileName, &amp;hmmioOut, pwfxDest, &amp;ckOut, &amp;ckOutRIFF)) != 0) <br>{ <br>goto ERROR_SAVING; <br>} <br> <br>if ((nError = WaveStartDataWrite(&amp;hmmioOut, &amp;ckOut, &amp;mmioinfoOut)) != 0) <br>{ <br>goto ERROR_SAVING; <br>} <br> <br>if ((nError = WaveWriteFile(hmmioOut, cbSize, pbData, &amp;ckOut, &amp;cbActualWrite, &amp;mmioinfoOut)) != 0) <br>{ <br>goto ERROR_SAVING; <br>} <br> <br>if ((nError = WaveCloseWriteFile(&amp;hmmioOut, &amp;ckOut, &amp;ckOutRIFF, &amp;mmioinfoOut, cSamples)) != 0) <br>{ <br>goto ERROR_SAVING; <br>}        <br> <br>ERROR_SAVING: <br> <br>return(nError);          <br> <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
