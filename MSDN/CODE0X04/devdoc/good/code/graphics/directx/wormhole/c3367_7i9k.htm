<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WORMHOLE.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3368"></a>WORMHOLE.CPP</h2>
<pre><code>/*************************************************************************** <br> *  Copyright (C) 1995-1997 Microsoft Corporation. All Rights Reserved. <br> ***************************************************************************/ <br>#include &lt;windows.h&gt; <br>#include &lt;ddraw.h&gt; <br> <br>HWND            hWnd; <br>PALETTEENTRY    pe[256]; <br>BOOL            bActive;                                             <br>BOOL            bIsInitialized=FALSE; <br> <br>LPDIRECTDRAW            lpDD = NULL;            <br>LPDIRECTDRAWSURFACE     lpDDSPrimary = NULL;    <br>LPDIRECTDRAWSURFACE     lpDDSOne = NULL;        <br>LPDIRECTDRAWCLIPPER     lpClipper = NULL;       <br>LPDIRECTDRAWPALETTE     lpDDPal = NULL;         <br> <br>BOOL restoreAll(); <br>void updateFrame(); <br>static void finiObjects(); <br>long FAR PASCAL WindowProc(HWND,UINT,WPARAM,LPARAM); <br>BOOL initFail(HWND); <br>static BOOL doInit(HINSTANCE, int); <br>void CyclePalette(); <br>BOOL readBMPIntoSurfaces(); <br>int PASCAL WinMain(HINSTANCE,HINSTANCE,LPSTR,int); <br> <br>BOOL restoreAll() <br>{ <br>    BOOL bResult; <br> <br>    bResult=lpDDSPrimary-&gt;Restore() == DD_OK &amp;&amp; <br>            lpDDSOne-&gt;Restore()     == DD_OK; <br> <br>    readBMPIntoSurfaces(); <br> <br>    return(bResult); <br>}  <br> <br>void updateFrame() <br>{ <br>    RECT                rcRect; <br>    RECT                destRect; <br>    HRESULT             ddrval; <br>    POINT               pt; <br> <br>    rcRect.left=0; <br>    rcRect.top=0; <br>    rcRect.right=640; <br>    rcRect.bottom=480; <br> <br>    GetClientRect(hWnd,&amp;destRect); <br> <br>    pt.x=pt.y=0; <br>    ClientToScreen(hWnd,&amp;pt); <br>    OffsetRect(&amp;destRect,pt.x,pt.y); <br> <br>    while(1) <br>    { <br>        ddrval=lpDDSPrimary-&gt;Blt(&amp;destRect,lpDDSOne,&amp;rcRect,0,NULL); <br> <br>        if(ddrval==DD_OK) <br>        { <br>            break; <br>        } <br>        if(ddrval==DDERR_SURFACELOST) <br>        { <br>            if(!restoreAll()) <br>            { <br>                return; <br>            } <br>            continue; <br>        } <br>        if(ddrval!=DDERR_WASSTILLDRAWING) <br>        { <br>            return; <br>        } <br>    } <br>}  <br> <br>static void finiObjects() <br>{ <br>    if(lpDD!=NULL) <br>    { <br>        if(lpDDSPrimary!=NULL) <br>        { <br>            lpDDSPrimary-&gt;Release(); <br>            lpDDSPrimary=NULL; <br>        } <br>        if(lpDDSOne!=NULL) <br>        { <br>            lpDDSOne-&gt;Release(); <br>            lpDDSOne=NULL; <br>        } <br>        if(lpDDPal!=NULL) <br>        { <br>            lpDDPal-&gt;Release(); <br>            lpDDPal=NULL; <br>        } <br>        lpDD-&gt;Release(); <br>        lpDD=NULL; <br>    } <br>}  <br> <br>long FAR PASCAL WindowProc(HWND hWnd,UINT message,  <br>                           WPARAM wParam,LPARAM lParam ) <br>{ <br>    switch(message) <br>    { <br>        case WM_ACTIVATE: <br>            bActive = wParam; <br>            break; <br> <br>        case WM_CREATE: <br> <br>            break; <br> <br>        case WM_SETCURSOR: <br> <br>            SetCursor(NULL); <br>    if( bIsInitialized ) <br>    { <br>                updateFrame(); <br>                lpDDPal-&gt;GetEntries(0,0,256,pe); <br>    } <br>            break; <br> <br>        case WM_KEYDOWN: <br> <br>            switch(wParam) <br>            { <br>                case VK_ESCAPE: <br>                 <br>                case VK_F12: <br>                     <br>                    PostMessage(hWnd,WM_CLOSE,0,0); <br>                    break; <br>            } <br>            break; <br>   <br>        case WM_DESTROY: <br> <br>            finiObjects(); <br>            PostQuitMessage(0); <br>            break; <br>    } <br>    return DefWindowProc(hWnd,message,wParam,lParam); <br>}  <br> <br>BOOL initFail(HWND hWnd) <br>{ <br>    finiObjects(); <br>    MessageBox(hWnd,"DirectDraw Init FAILED","WormHole",MB_OK); <br>    DestroyWindow(hWnd); <br>    return FALSE; <br>}  <br> <br>static BOOL doInit(HINSTANCE hInstance,int nCmdShow) <br>{ <br>    WNDCLASS            wc; <br>    DDSURFACEDESC       ddsd; <br>    HRESULT             ddrval; <br> <br>    wc.style=          CS_HREDRAW|CS_VREDRAW; <br>    wc.lpfnWndProc=    WindowProc; <br>    wc.cbClsExtra=     0; <br>    wc.cbWndExtra=     0; <br>    wc.hInstance=      hInstance; <br>    wc.hIcon=          LoadIcon(hInstance,IDI_APPLICATION); <br>    wc.hCursor=        LoadCursor(NULL,IDC_ARROW); <br>    wc.hbrBackground=  NULL; <br>    wc.lpszMenuName=   NULL; <br>    wc.lpszClassName=  "WormHole"; <br>    RegisterClass(&amp;wc); <br>     <br>    hWnd=CreateWindowEx( <br>        0, <br>        "WormHole", <br>        "WormHole", <br>        WS_POPUP, <br>        0, <br>        0, <br>        GetSystemMetrics(SM_CXSCREEN), <br>        GetSystemMetrics(SM_CYSCREEN), <br>        NULL, <br>        NULL, <br>        hInstance, <br>        NULL ); <br> <br>    if(!hWnd) <br>    { <br>        return FALSE; <br>    } <br> <br>    ShowWindow(hWnd,nCmdShow); <br>    UpdateWindow(hWnd); <br> <br>    ddrval=DirectDrawCreate(NULL,&amp;lpDD,NULL); <br> <br>    if(ddrval!=DD_OK) <br>    { <br>        return initFail(hWnd); <br>    } <br> <br>    ddrval=lpDD-&gt;SetCooperativeLevel(hWnd,DDSCL_EXCLUSIVE|DDSCL_FULLSCREEN); <br>    ddrval=lpDD-&gt;SetDisplayMode(640,480,8); <br> <br>    if(ddrval!=DD_OK) <br>    { <br>        return initFail(hWnd); <br>    } <br> <br>    ddsd.dwSize=sizeof(ddsd); <br>    ddsd.dwFlags=DDSD_CAPS; <br>    ddsd.ddsCaps.dwCaps=DDSCAPS_PRIMARYSURFACE; <br> <br>    ddrval=lpDD-&gt;CreateSurface(&amp;ddsd,&amp;lpDDSPrimary,NULL); <br> <br>    if(ddrval!=DD_OK) <br>    { <br>        return initFail(hWnd); <br>    } <br> <br>    ddsd.dwSize=sizeof(ddsd); <br>    ddsd.dwFlags=DDSD_CAPS|DDSD_HEIGHT|DDSD_WIDTH; <br>    ddsd.ddsCaps.dwCaps=DDSCAPS_OFFSCREENPLAIN; <br>    ddsd.dwWidth=640; <br>    ddsd.dwHeight=480; <br> <br>    lpDD-&gt;CreateSurface(&amp;ddsd,&amp;lpDDSOne,NULL);     <br>    if(lpDDSOne==NULL) <br>    { <br>        return initFail(hWnd); <br>    } <br> <br>    bIsInitialized = TRUE; <br>    return TRUE; <br>}  <br> <br>void CyclePalette() <br>{ <br>    int                 reg[15]; <br>    int                 k; <br>        <br>    for(k=0;k&lt;15;k++) <br>    { <br>        reg[k]=pe[k+30].peRed; <br>    } <br>    for(k=45;k&lt;255;k++) <br>    {                                                             <br>        pe[k-15].peRed=pe[k].peRed; <br>    } <br>    for(k=0;k&lt;15;k++) <br>    { <br>        pe[k+240].peRed=reg[k]; <br>    } <br>    for(k=0;k&lt;15;k++) <br>    { <br>        reg[k]=pe[k+30].peGreen; <br>    } <br>    for(k=45;k&lt;255;k++) <br>    { <br>        pe[k-15].peGreen=pe[k].peGreen; <br>    } <br>    for(k=0;k&lt;15;k++) <br>    { <br>        pe[k+240].peGreen=reg[k]; <br>    } <br>    for(k=0;k&lt;15;k++) <br>    { <br>        reg[k]=pe[k+30].peBlue; <br>    } <br>    for(k=45;k&lt;255;k++) <br>    { <br>        pe[k-15].peBlue=pe[k].peBlue; <br>    } <br>    for(k=0;k&lt;15;k++) <br>    { <br>        pe[k+240].peBlue=reg[k]; <br>    } <br> <br>    for(k=2;k&lt;17;k++) <br>    { <br>        reg[k-2]=pe[15*k+14].peRed; <br>        pe[15*k+14].peRed=pe[15*k+13].peRed; <br>        pe[15*k+13].peRed=pe[15*k+12].peRed; <br>        pe[15*k+12].peRed=pe[15*k+11].peRed; <br>        pe[15*k+11].peRed=pe[15*k+10].peRed; <br>        pe[15*k+10].peRed=pe[15*k+9].peRed; <br>        pe[15*k+9].peRed=pe[15*k+8].peRed; <br>        pe[15*k+8].peRed=pe[15*k+7].peRed; <br>        pe[15*k+7].peRed=pe[15*k+6].peRed; <br>        pe[15*k+6].peRed=pe[15*k+5].peRed; <br>        pe[15*k+5].peRed=pe[15*k+4].peRed; <br>        pe[15*k+4].peRed=pe[15*k+3].peRed; <br>        pe[15*k+3].peRed=pe[15*k+2].peRed; <br>        pe[15*k+2].peRed=pe[15*k+1].peRed; <br>        pe[15*k+1].peRed=pe[15*k].peRed; <br>        pe[15*k].peRed=reg[k-2]; <br>        reg[k-2]=pe[15*k+14].peGreen; <br>        pe[15*k+14].peGreen=pe[15*k+13].peGreen; <br>        pe[15*k+13].peGreen=pe[15*k+12].peGreen; <br>        pe[15*k+12].peGreen=pe[15*k+11].peGreen; <br>        pe[15*k+11].peGreen=pe[15*k+10].peGreen; <br>        pe[15*k+10].peGreen=pe[15*k+9].peGreen; <br>        pe[15*k+9].peGreen=pe[15*k+8].peGreen; <br>        pe[15*k+8].peGreen=pe[15*k+7].peGreen; <br>        pe[15*k+7].peGreen=pe[15*k+6].peGreen; <br>        pe[15*k+6].peGreen=pe[15*k+5].peGreen; <br>        pe[15*k+5].peGreen=pe[15*k+4].peGreen; <br>        pe[15*k+4].peGreen=pe[15*k+3].peGreen; <br>        pe[15*k+3].peGreen=pe[15*k+2].peGreen; <br>        pe[15*k+2].peGreen=pe[15*k+1].peGreen; <br>        pe[15*k+1].peGreen=pe[15*k].peGreen; <br>        pe[15*k].peGreen=reg[k-2]; <br>        reg[k-2]=pe[15*k+14].peBlue; <br>        pe[15*k+14].peBlue=pe[15*k+13].peBlue; <br>        pe[15*k+13].peBlue=pe[15*k+12].peBlue; <br>        pe[15*k+12].peBlue=pe[15*k+11].peBlue; <br>        pe[15*k+11].peBlue=pe[15*k+10].peBlue; <br>        pe[15*k+10].peBlue=pe[15*k+9].peBlue; <br>        pe[15*k+9].peBlue=pe[15*k+8].peBlue; <br>        pe[15*k+8].peBlue=pe[15*k+7].peBlue; <br>        pe[15*k+7].peBlue=pe[15*k+6].peBlue; <br>        pe[15*k+6].peBlue=pe[15*k+5].peBlue; <br>        pe[15*k+5].peBlue=pe[15*k+4].peBlue; <br>        pe[15*k+4].peBlue=pe[15*k+3].peBlue; <br>        pe[15*k+3].peBlue=pe[15*k+2].peBlue; <br>        pe[15*k+2].peBlue=pe[15*k+1].peBlue; <br>        pe[15*k+1].peBlue=pe[15*k].peBlue; <br>        pe[15*k].peBlue=reg[k-2]; <br>    } <br>             <br>    lpDD-&gt;WaitForVerticalBlank(DDWAITVB_BLOCKBEGIN,NULL); <br> <br>    if(lpDDPal-&gt;SetEntries(0,0,256,pe)!=DD_OK) <br>    { <br>        return; <br>    } <br>} <br> <br>BOOL readBMPIntoSurfaces() <br>{ <br>    HRESULT             ddrval; <br>    HRSRC               hBMP; <br>    RGBQUAD             Palette[256]; <br>    PALETTEENTRY        pe[256]; <br>    DDSURFACEDESC       DDSDesc; <br>    LPSTR               lpBits; <br>    LPSTR               lpSrc; <br>    BYTE                *lpBMP; <br>    int                 i; <br> <br>    hBMP=FindResource(NULL,"wormhole_bmp",RT_BITMAP);     <br>    if( hBMP == NULL ) <br>    { <br>        return FALSE; <br>    } <br> <br>    lpBMP=(BYTE *)LockResource(LoadResource(NULL, hBMP)); <br>     <br>    memcpy(Palette,&amp;lpBMP[sizeof(BITMAPINFOHEADER)],sizeof(Palette)); <br> <br>    FreeResource(hBMP); <br> <br>    for(i=0;i&lt;256;i++) <br>    { <br>        pe[i].peRed=Palette[i].rgbRed; <br>        pe[i].peGreen=Palette[i].rgbGreen; <br>        pe[i].peBlue=Palette[i].rgbBlue; <br>    }    <br> <br>    if (NULL == lpDDPal) { <br> <br>      ddrval=lpDD-&gt;CreatePalette(DDPCAPS_8BIT,pe,&amp;lpDDPal,NULL); <br> <br>      if(ddrval!=DD_OK) <br>      { <br>          return FALSE; <br>      } <br>    } <br> <br>    lpDDSPrimary-&gt;SetPalette(lpDDPal); <br> <br>    DDSDesc.dwSize=sizeof(DDSDesc); <br>    ddrval=lpDDSOne-&gt;Lock(NULL,&amp;DDSDesc,0,NULL); <br>    if(ddrval!=DD_OK) <br>    { <br>        return FALSE; <br>    } <br> <br>    lpBits=(LPSTR)DDSDesc.lpSurface; <br>    lpSrc=(LPSTR) <br>          (&amp;lpBMP[sizeof(BITMAPINFOHEADER)+sizeof(Palette)+(640*480)]); <br>    for(i=0;i&lt;480;i++) <br>    { <br>        memcpy(lpBits,lpSrc,640); <br>        lpBits+=DDSDesc.lPitch; <br>        lpSrc-=640; <br>    } <br>    lpDDSOne-&gt;Unlock(NULL); <br> <br>    return TRUE; <br>} <br> <br>int PASCAL WinMain(HINSTANCE hInstance,HINSTANCE hPrevInstance, <br>                   LPSTR lpCmdLine,int nCmdShow) <br>{ <br>    MSG         msg; <br> <br>    if(!doInit(hInstance,nCmdShow)) <br>    { <br>        return FALSE; <br>    } <br> <br>    readBMPIntoSurfaces();     <br>    updateFrame(); <br> <br>    while(1) <br>    { <br>        if(PeekMessage(&amp;msg,NULL,0,0,PM_NOREMOVE)) <br>        { <br>            if(!GetMessage(&amp;msg,NULL,0,0)) <br>            { <br>                return msg.wParam; <br>            } <br>            TranslateMessage(&amp;msg); <br>            DispatchMessage(&amp;msg); <br>        } <br>        else if(bActive) <br>        { <br>            CyclePalette(); <br>        } <br>        else <br>        { <br>            WaitMessage(); <br>        } <br>    } <br>}  <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
