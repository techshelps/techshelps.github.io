<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SCRAWL.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3308"></a>SCRAWL.CPP</h2>
<pre><code>/************************************************************************** <br> <br>    SCRAWL.CPP - A dumb drawing app demo for DirectInput <br> <br>    Collects mouse data in various modes to demonstrate how it's done. <br> <br> **************************************************************************/ <br>/************************************************************************** <br> <br>    (C) Copyright 1995 - 1998 Microsoft Corp.  All rights reserved. <br> <br>    You have a royalty-free right to use, modify, reproduce and <br>    distribute the Sample Files (and/or any modified version) in <br>    any way you find useful, provided that you agree that <br>    Microsoft has no warranty obligations or liability for any <br>    Sample Application Files which are modified. <br> <br> **************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;stdarg.h&gt; <br> <br>#define DIRECTINPUT_VERSION 0x0300      /* Remain DX3-compatible */ <br>#include &lt;dinput.h&gt; <br> <br>#include "scrawl.h" <br> <br>/**************************************************************************** <br> * <br> *      This is an incredibly dump app.  It just lets you "draw" on <br> *      a monochrome bitmap via DirectInput.  The purpose is not to <br> *      dazzle you with mind-altering brilliance.  It's just to show <br> *      how to use the DirectInput mouse interface. <br> * <br> ****************************************************************************/ <br> <br>/**************************************************************************** <br> * <br> *      Manifest constants <br> * <br> ****************************************************************************/ <br> <br>#define DINPUT_BUFFERSIZE           16 <br> <br>#define DINPUT_CXBITMAP             512 <br>#define DINPUT_CYBITMAP             300 <br> <br>/**************************************************************************** <br> * <br> *      Global variables <br> * <br> ****************************************************************************/ <br> <br>const char c_szAppName[] = "Scrawl";    /* My name */ <br> <br>HINSTANCE  g_hinst;                     /* My instance handle */ <br>BOOL       g_fActive;                   /* Am I the active window? */ <br> <br>int        g_x = DINPUT_CXBITMAP / 2;   /* Virtual x-coordinate */ <br>int        g_y = DINPUT_CYBITMAP / 2;   /* Virtual y-coordinate */ <br> <br>int        g_dxFuzz;                    /* Leftover x-fuzz from scaling */ <br>int        g_dyFuzz;                    /* Leftover y-fuzz from scaling */ <br>int        g_iSensitivity;              /* Mouse sensitivity */ <br> <br>HDC        g_hdc;                       /* Memory DC our picture lives in */ <br>HBITMAP    g_hbm;                       /* Our picture */ <br>HBITMAP    g_hbmDeselect;               /* Stock bitmap for deselecting */ <br> <br>HCURSOR    g_hcurCross;                 /* Crosshairs */ <br>int        g_cxCross;                   /* Width of crosshairs cursor */ <br>int        g_cyCross;                   /* Height of crosshairs cursor */ <br>int        g_dxCrossHot;                /* Hotspot location of crosshairs */ <br>int        g_dyCrossHot;                /* Hotspot location of crosshairs */ <br>int        g_fShowCursor = 1;           /* Should the cursor be shown? */ <br> <br>/**************************************************************************** <br> * <br> *      DirectInput globals <br> * <br> ****************************************************************************/ <br> <br>LPDIRECTINPUT          g_pdi; <br>LPDIRECTINPUTDEVICE    g_pMouse; <br> <br>HANDLE                 g_hevtMouse; <br> <br>/**************************************************************************** <br> * <br> *      Complain <br> * <br> *      Whine and moan. <br> * <br> ****************************************************************************/ <br> <br>void CDECL <br>Complain(HWND hwndOwner, HRESULT hr, LPCSTR pszFormat, ...) <br>{ <br>    va_list ap; <br>    char szBuf[1024]; <br>    char *pszBuf; <br> <br>    va_start(ap, pszFormat); <br> <br>    pszBuf = szBuf + wsprintf(szBuf, pszFormat, ap); <br> <br>    va_end(ap); <br> <br>    wsprintf(pszBuf, "\n\nError = %08x", hr); <br> <br>    MessageBox(hwndOwner, szBuf, c_szAppName, MB_OK); <br>} <br> <br>/**************************************************************************** <br> * <br> *      DIInit <br> * <br> *      Initialize the DirectInput variables. <br> * <br> ****************************************************************************/ <br> <br>BOOL DIInit(HWND hwnd) <br>{ <br>    HRESULT hr; <br> <br>    /* <br>     *  Register with DirectInput and get an IDirectInput to play with. <br>     */ <br>    hr = DirectInputCreate(g_hinst, DIRECTINPUT_VERSION, &amp;g_pdi, NULL); <br> <br>    if (FAILED(hr)) { <br>        Complain(hwnd, hr, "DirectInputCreate"); <br>        return FALSE; <br>    } <br> <br>    /* <br>     *  Obtain an interface to the system mouse device. <br>     */ <br>    hr = g_pdi-&gt;CreateDevice(GUID_SysMouse, &amp;g_pMouse, NULL); <br> <br>    if (FAILED(hr)) { <br>        Complain(hwnd, hr, "CreateDevice(SysMouse)"); <br>        return FALSE; <br>    } <br> <br>    /* <br>     *  Set the data format to "mouse format". <br>     */ <br>    hr = g_pMouse-&gt;SetDataFormat(&amp;c_dfDIMouse); <br> <br>    if (FAILED(hr)) { <br>        Complain(hwnd, hr, "SetDataFormat(SysMouse, dfDIMouse)"); <br>        return FALSE; <br>    } <br> <br> <br>    /* <br>     *  Set the cooperativity level. <br>     */ <br>    hr = g_pMouse-&gt;SetCooperativeLevel(hwnd, <br>                                       DISCL_EXCLUSIVE | DISCL_FOREGROUND); <br> <br>    if (FAILED(hr)) { <br>        Complain(hwnd, hr, "SetCooperativeLevel(SysMouse)"); <br>        return FALSE; <br>    } <br> <br> <br>    /* <br>     *  Create the handle that tells us new data is available. <br>     */ <br>    g_hevtMouse = CreateEvent(0, 0, 0, 0); <br> <br>    if (g_hevtMouse == NULL) { <br>        Complain(hwnd, GetLastError(), "CreateEvent"); <br>        return FALSE; <br>    } <br> <br>    /* <br>     *  Associate the event with the device. <br>     */ <br>    hr = g_pMouse-&gt;SetEventNotification(g_hevtMouse); <br> <br>    if (FAILED(hr)) { <br>        Complain(hwnd, hr, "SetEventNotification(SysMouse)"); <br>        return FALSE; <br>    } <br> <br>    /* <br>     *  Set the buffer size to DINPUT_BUFFERSIZE elements. <br>     *  The buffer size is a DWORD property associated with the device. <br>     */ <br>    DIPROPDWORD dipdw = <br>        { <br>            { <br>                sizeof(DIPROPDWORD),        // diph.dwSize <br>                sizeof(DIPROPHEADER),       // diph.dwHeaderSize <br>                0,                          // diph.dwObj <br>                DIPH_DEVICE,                // diph.dwHow <br>            }, <br>            DINPUT_BUFFERSIZE,              // dwData <br>        }; <br> <br>    hr = g_pMouse-&gt;SetProperty(DIPROP_BUFFERSIZE, &amp;dipdw.diph); <br> <br>    if (FAILED(hr)) { <br>        Complain(hwnd, hr, "Set buffer size(SysMouse)"); <br>        return FALSE; <br>    } <br> <br>    return TRUE; <br> <br>} <br> <br>/**************************************************************************** <br> * <br> *      DITerm <br> * <br> *      Terminate our usage of DirectInput. <br> * <br> ****************************************************************************/ <br> <br>void DITerm(void) <br>{ <br>    if (g_pdi)      g_pdi   -&gt;Release(), g_pdi    = NULL; <br>    if (g_pMouse)   g_pMouse-&gt;Release(), g_pMouse = NULL; <br> <br>    if (g_hevtMouse) CloseHandle(g_hevtMouse), g_hevtMouse = NULL; <br>} <br> <br>/**************************************************************************** <br> * <br> *      InvalidateCursorRect <br> * <br> *      Invalidate the rectangle that contains the cursor. <br> * <br> *      The coordinates are in client coordinates. <br> * <br> ****************************************************************************/ <br> <br>void InvalidateCursorRect(HWND hwnd) <br>{ <br>    RECT rc = { g_x - g_dxCrossHot,             g_y - g_dyCrossHot, <br>                g_x - g_dxCrossHot + g_cxCross, g_y - g_dyCrossHot + g_cyCross }; <br> <br>    InvalidateRect(hwnd, &amp;rc, 0); <br>} <br> <br>/**************************************************************************** <br> * <br> *      UpdateCursorPosition <br> * <br> *      Move our private cursor in the requested direction, subject <br> *      to clipping, scaling, and all that other stuff. <br> * <br> *      This does not redraw the cursor.  You need to do that yourself. <br> * <br> ****************************************************************************/ <br> <br>void UpdateCursorPosition(int dx, int dy) <br>{ <br> <br>    /* <br>     *  Pick up any leftover fuzz from last time.  This is important <br>     *  when scaling down mouse motions.  Otherwise, the user can <br>     *  drag to the right extremely slow for the length of the table <br>     *  and not get anywhere. <br>     */ <br>    dx += g_dxFuzz;     g_dxFuzz = 0; <br>    dy += g_dyFuzz;     g_dyFuzz = 0; <br> <br>    switch (g_iSensitivity) { <br> <br>    case 1:                             /* High sensitivity: Magnify! */ <br>        dx *= 2; <br>        dy *= 2; <br>        break; <br> <br>    case -1:                            /* Low sensitivity: Scale down */ <br>        g_dxFuzz = dx % 2;              /* remember the fuzz for next time */ <br>        g_dyFuzz = dy % 2; <br>        dx /= 2; <br>        dy /= 2; <br>        break; <br> <br>    default: <br>    case 0:                             /* No sensitivity */ <br>        ;                               /* No adjustments needed */ <br>    } <br> <br>    g_x += dx; <br>    g_y += dy; <br> <br>    /* Clip the cursor to our client area */ <br>    if (g_x &lt; 0)                g_x = 0; <br>    if (g_x &gt;= DINPUT_CXBITMAP) g_x = DINPUT_CXBITMAP - 1; <br> <br>    if (g_y &lt; 0)                g_y = 0; <br>    if (g_y &gt;= DINPUT_CYBITMAP) g_y = DINPUT_CYBITMAP - 1; <br> <br>} <br> <br>/**************************************************************************** <br> * <br> *      Scrawl_SyncAcquire <br> * <br> *      Acquire or unacquire the devices, depending on the the g_fActive <br> *      flag.  This synchronizes the devices with our internal view of <br> *      the world. <br> * <br> *      Also repaint the cursor so that it hides/shows in sync with <br> *      acquisition. <br> * <br> ****************************************************************************/ <br> <br>void <br>Scrawl_SyncAcquire(HWND hwnd) <br>{ <br>    if (g_fActive) { <br>        if (g_pMouse) g_pMouse-&gt;Acquire(); <br>    } else { <br>        if (g_pMouse) g_pMouse-&gt;Unacquire(); <br>    } <br> <br>    InvalidateCursorRect(hwnd); <br>} <br> <br>/**************************************************************************** <br> * <br> *      Private messages <br> * <br> *      WM_SYNCACQUIRE forces us to re-synchronize our acquisition <br> *      with the world. <br> * <br> ****************************************************************************/ <br> <br>#define WM_SYNCACQUIRE      (WM_USER + 0) <br> <br>/**************************************************************************** <br> * <br> *      Scrawl_OnClear <br> * <br> *      Wipe out the bitmap. <br> * <br> ****************************************************************************/ <br> <br>void Scrawl_OnClear(HWND hwnd) <br>{ <br>    /* <br>     *  Start out all white. <br>     */ <br>    PatBlt(g_hdc, 0, 0, DINPUT_CXBITMAP, DINPUT_CYBITMAP, WHITENESS); <br> <br>    if (hwnd) { <br>        InvalidateRect(hwnd, 0, 0); <br>    } <br>} <br> <br>/**************************************************************************** <br> * <br> *      Scrawl_OnCreate <br> * <br> *      Set up the window by appending our custom commands to the System <br> *      menu. <br> * <br> *      Also disable the menu items we don't want to see. <br> * <br> ****************************************************************************/ <br> <br>BOOL Scrawl_OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct) <br>{ <br>    HMENU hmenu = GetSystemMenu(hwnd, FALSE); <br> <br>    EnableMenuItem(hmenu, SC_SIZE,     MF_BYCOMMAND | MF_DISABLED | MF_GRAYED); <br>    EnableMenuItem(hmenu, SC_MAXIMIZE, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED); <br> <br>    AppendMenu(hmenu, MF_ENABLED | MF_STRING, IDC_CLEAR, "C&amp;lear\tDel"); <br>    AppendMenu(hmenu, MF_ENABLED | MF_STRING, IDC_ABOUT, "&amp;About\tF1"); <br> <br>    AppendMenu(hmenu, MF_ENABLED | MF_STRING | MF_POPUP, <br>                      (UINT)LoadMenu(g_hinst, <br>                                     MAKEINTRESOURCE(IDM_SENSITIVITY)), <br>                     "Sensitivit&amp;y"); <br> <br>    return 1; <br>} <br> <br>/**************************************************************************** <br> * <br> *      Scrawl_OnInitMenuPopup <br> * <br> *      Initialize the sensitivity item accordingly. <br> * <br> ****************************************************************************/ <br> <br>void <br>Scrawl_OnInitMenuPopup(HWND hwnd, HMENU hmenu, UINT item, BOOL fSystemMenu) <br>{ <br>    int iSensitivity; <br>    for (iSensitivity = -1; iSensitivity &lt;= 1; iSensitivity++) { <br>        if (g_iSensitivity == iSensitivity) { <br>            CheckMenuItem(hmenu, IDC_SENSITIVITY_NORMAL + iSensitivity, <br>                          MF_BYCOMMAND | MF_CHECKED); <br>        } else { <br>            CheckMenuItem(hmenu, IDC_SENSITIVITY_NORMAL + iSensitivity, <br>                          MF_BYCOMMAND | MF_UNCHECKED); <br>        } <br>    } <br> <br>} <br> <br>/**************************************************************************** <br> * <br> *      Scrawl_OnKeyDown <br> * <br> *      See if it's one of our accelerators. <br> * <br> ****************************************************************************/ <br> <br>void Scrawl_OnKeyDown(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags) <br>{ <br>    switch (vk) { <br>    case '1': <br>    case '2': <br>    case '3': <br>        PostMessage(hwnd, WM_SYSCOMMAND, IDC_SENSITIVITY_NORMAL + <br>                                         vk - '2', 0); <br>        break; <br> <br>    case VK_DELETE: <br>        PostMessage(hwnd, WM_SYSCOMMAND, IDC_CLEAR, 0); <br>        break; <br> <br>    case VK_F1: <br>        PostMessage(hwnd, WM_SYSCOMMAND, IDC_ABOUT, 0); <br>        break; <br> <br>    } <br>} <br> <br>/**************************************************************************** <br> * <br> *      Scrawl_OnPaint <br> * <br> *      Blt out our bitmap and draw our cursor on top of it. <br> * <br> ****************************************************************************/ <br> <br>void <br>Scrawl_OnPaint(HWND hwnd) <br>{ <br>    PAINTSTRUCT ps; <br>    HDC hdc = BeginPaint(hwnd, &amp;ps); <br> <br>    if (hdc) { <br> <br>        BitBlt(hdc, <br>               ps.rcPaint.left, <br>               ps.rcPaint.top, <br>               ps.rcPaint.right - ps.rcPaint.left, <br>               ps.rcPaint.bottom - ps.rcPaint.top, <br>               g_hdc, <br>               ps.rcPaint.left, <br>               ps.rcPaint.top, <br>               SRCCOPY); <br> <br>        if (g_fActive &amp;&amp; g_fShowCursor) { <br>            DrawIcon(hdc, g_x - g_dxCrossHot, <br>                          g_y - g_dyCrossHot, g_hcurCross); <br>        } <br> <br>        EndPaint(hwnd, &amp;ps); <br>    } <br>} <br> <br>/**************************************************************************** <br> * <br> *      Scrawl_OnButton0Down_FlushMotion <br> * <br> *      Flush out any motion that we are holding. <br> * <br> ****************************************************************************/ <br> <br>typedef struct BUTTON0INFO { <br> <br>    HDC hdcWindow; <br>    BOOL fMoved; <br>    DWORD dwSeqLastSeen; <br> <br>} BUTTON0INFO, *PBUTTON0INFO; <br> <br>void Scrawl_OnButton0Down_FlushMotion(PBUTTON0INFO pb0i) <br>{ <br>    if (pb0i-&gt;fMoved) { <br>        pb0i-&gt;fMoved = 0; <br>        pb0i-&gt;dwSeqLastSeen = 0; <br>        LineTo(pb0i-&gt;hdcWindow, g_x, g_y); <br>        LineTo(g_hdc, g_x, g_y); <br>    } <br> <br>} <br> <br>/**************************************************************************** <br> * <br> *      Scrawl_OnButton0Down <br> * <br> *      Enter draw mode. <br> * <br> *      If we are drawing a curve, then read buffered data and draw <br> *      lines from point to point.  By reading buffered data, we can <br> *      track the motion of the mouse accurately without coalescing. <br> * <br> *      This function illustrates how a non-message-based program can <br> *      process buffered data directly from a device, processing <br> *      messages only occasionally (as required by Windows). <br> * <br> *      This function also illustrates how an application can piece <br> *      together buffered data elements based on the sequence number. <br> *      A single mouse action (e.g., moving diagonally) is reported <br> *      as a series of events, all with the same sequence number. <br> *      Zero is never a valid DirectInput sequence number, so it is <br> *      safe to use it as a sentinel value. <br> * <br> ****************************************************************************/ <br> <br>void Scrawl_OnButton0Down(HWND hwnd) <br>{ <br>    BUTTON0INFO b0i; <br> <br>    /* Hide the cursor while scrawling */ <br>    g_fShowCursor = FALSE; <br>    InvalidateCursorRect(hwnd); <br>    UpdateWindow(hwnd); <br> <br>    /* <br>     *  For performance, draw directly onto the window's DC instead of <br>     *  invalidating and waiting for the WM_PAINT message.  Of course, <br>     *  we always draw onto our bitmap, too, since that's what really <br>     *  counts. <br>     */ <br> <br>    /* BUGBUG -- select a decent pen, too */ <br>    b0i.hdcWindow = GetDC(hwnd); <br>    MoveToEx(b0i.hdcWindow, g_x, g_y, 0); <br>    MoveToEx(g_hdc, g_x, g_y, 0); <br> <br>    /* BUGBUG -- save old pen */ <br>    SelectObject(b0i.hdcWindow, GetStockObject(BLACK_PEN)); <br>    SelectObject(g_hdc, GetStockObject(BLACK_PEN)); <br> <br>    b0i.fMoved = 0; <br>    b0i.dwSeqLastSeen = 0; <br> <br>    /* <br>     *  Keep reading data elements until we see a "mouse button up" event. <br>     */ <br>    BOOL fDone = 0; <br>    while (!fDone) { <br>        DIDEVICEOBJECTDATA od; <br> <br>        DWORD dwElements = 1; <br> <br>        HRESULT hr = g_pMouse-&gt;GetDeviceData( <br>                             sizeof(DIDEVICEOBJECTDATA), &amp;od, <br>                             &amp;dwElements, 0); <br> <br>        /* Unable to read data */ <br>        if (FAILED(hr)) { <br>            break; <br>        } <br> <br>        /* <br>         *  If no data available, finish the element we had been <br>         *  collecting, and then process our message queue so <br>         * the system don't think we're hung. <br>         */ <br>        if (dwElements == 0) { <br> <br>            /* If there is a partial motion, flush it out */ <br>            Scrawl_OnButton0Down_FlushMotion(&amp;b0i); <br> <br>            MSG msg; <br>            while (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) { <br>                /* If it's a quit message, we're outta here */ <br>                if (msg.message == WM_QUIT) { <br>                    fDone = TRUE; <br>                    /* <br>                     * Re-post the quit message so the <br>                     * outer loop will see it and exit. <br>                     */ <br>                    PostQuitMessage(msg.wParam); <br>                    break; <br>                } else { <br>                    TranslateMessage(&amp;msg); <br>                    DispatchMessage(&amp;msg); <br>                } <br>            } <br>            continue; <br>        } <br> <br>        /* If this is the start of a new event, flush out the old one */ <br>        if (od.dwSequence != b0i.dwSeqLastSeen) { <br>            Scrawl_OnButton0Down_FlushMotion(&amp;b0i); <br>            b0i.dwSeqLastSeen = od.dwSequence; <br>        } <br> <br>        /* Look at the element to see what happened */ <br> <br>        switch (od.dwOfs) { <br> <br>        /* DIMOFS_X: Mouse horizontal motion */ <br>        case DIMOFS_X: <br>            UpdateCursorPosition(od.dwData, 0); <br>            b0i.fMoved = 1; <br>            break; <br> <br> <br>        /* DIMOFS_Y: Mouse vertical motion */ <br>        case DIMOFS_Y: <br>            UpdateCursorPosition(0, od.dwData); <br>            b0i.fMoved = 1; <br>            break; <br> <br>        /* DIMOFS_BUTTON0: Button 0 pressed or released */ <br>        case DIMOFS_BUTTON0: <br> <br>            if (!(od.dwData &amp; 0x80)) { /* Button released */ <br>                fDone = 1; <br>                Scrawl_OnButton0Down_FlushMotion(&amp;b0i); /* Flush out dregs */ <br>            } <br>            break; <br> <br>        } <br>    } <br> <br>    ReleaseDC(hwnd, b0i.hdcWindow); <br> <br>    /* Re-show the cursor now that scrawling is finished */ <br>    g_fShowCursor = TRUE; <br>    InvalidateCursorRect(hwnd); <br>} <br> <br> <br>/**************************************************************************** <br> * <br> *      Scrawl_OnButton1Up <br> * <br> *      Pop up a context menu. <br> * <br> ****************************************************************************/ <br> <br>void Scrawl_OnButton1Up(HWND hwnd) <br>{ <br>    POINT pt = { g_x, g_y }; <br>    ClientToScreen(hwnd, &amp;pt); <br> <br>    /* <br>     *  Unacquire the devices so the user can interact with the menu. <br>     * <br>     *  Put the Windows cursor at the same location as our virtual cursor. <br>     * <br>     *  Hide the cursor while moving it so you don't get annoying flicker. <br>     */ <br> <br>    ShowCursor(FALSE); <br>    g_fActive = FALSE; <br>    Scrawl_SyncAcquire(hwnd); <br>    SetCursorPos(pt.x, pt.y); <br>    ShowCursor(TRUE); <br> <br>    HMENU hmenuPopup = GetSystemMenu(hwnd, FALSE); <br> <br>    UINT idc = TrackPopupMenuEx(hmenuPopup, <br>                                TPM_RIGHTBUTTON | TPM_RETURNCMD, <br>                                pt.x, pt.y, hwnd, 0); <br> <br>    PostMessage(hwnd, WM_SYSCOMMAND, idc, 0L); <br> <br>} <br> <br>/**************************************************************************** <br> * <br> *      Scrawl_OnMouseInput <br> * <br> *      The mouse moved while nothing was happening.  Walk the event list <br> *      and update the mouse position for each event.  If we see a button <br> *      event, then stop pulling events and leave the elements in the <br> *      input buffer for the drawing handler to pull. <br> * <br> * <br> ****************************************************************************/ <br> <br>void <br>Scrawl_OnMouseInput(HWND hwnd) <br>{ <br>    /* Invalidate the old cursor so it will be erased */ <br>    InvalidateCursorRect(hwnd); <br> <br>    /* <br>     *  Attempt to read one data element.  Continue as long as <br>     *  device data is available. <br>     */ <br>    BOOL fDone = 0; <br>    while (!fDone) { <br>        DIDEVICEOBJECTDATA od; <br> <br>        DWORD dwElements = 1; <br> <br>        HRESULT hr = g_pMouse-&gt;GetDeviceData( <br>                             sizeof(DIDEVICEOBJECTDATA), &amp;od, <br>                             &amp;dwElements, 0); <br> <br>        if (hr == DIERR_INPUTLOST) { <br>            /* <br>             *  We had acquisition, but lost it.  Try to reacquire it. <br>             * <br>             *  WARNING!  DO NOT ATTEMPT TO REACQUIRE IF YOU GET <br>             *  DIERR_NOTACQUIRED!  Otherwise, you're extremely likely <br>             *  to get caught in an infinite loop:  The acquire will fail, <br>             *  and you'll get another DIERR_NOTACQUIRED so you'll <br>             *  try to aquire again, and that'll fail, etc. <br>             */ <br>            PostMessage(hwnd, WM_SYNCACQUIRE, 0, 0L); <br>            break; <br>        } <br> <br>        /* Unable to read data or no data available */ <br>        if (FAILED(hr) || dwElements == 0) { <br>            break; <br>        } <br> <br>        /* Look at the element to see what happened */ <br> <br>        switch (od.dwOfs) { <br> <br>        /* DIMOFS_X: Mouse horizontal motion */ <br>        case DIMOFS_X: UpdateCursorPosition(od.dwData, 0); break; <br> <br> <br>        /* DIMOFS_Y: Mouse vertical motion */ <br>        case DIMOFS_Y: UpdateCursorPosition(0, od.dwData); break; <br> <br>        /* DIMOFS_BUTTON0: Button 0 pressed or released */ <br>        case DIMOFS_BUTTON0: <br> <br>            if (od.dwData &amp; 0x80) { /* Button pressed */ <br>                fDone = 1; <br>                Scrawl_OnButton0Down(hwnd); /* Go into button-down mode */ <br>            } <br>            break; <br> <br>        /* DIMOFS_BUTTON1: Button 1 pressed or released */ <br>        case DIMOFS_BUTTON1: <br> <br>            if (!(od.dwData &amp; 0x80)) {  /* Button released */ <br>                fDone = 1; <br>                Scrawl_OnButton1Up(hwnd); /* Context menu time */ <br>            } <br>        } <br> <br>    } <br> <br>    /* Invalidate the new cursor so it will be drawn */ <br>    InvalidateCursorRect(hwnd); <br> <br>} <br> <br>/**************************************************************************** <br> * <br> *      ScrawlWndProc <br> * <br> *      Application window procedure. <br> * <br> ****************************************************************************/ <br> <br>LONG CALLBACK ScrawlWndProc(HWND hwnd,UINT msg,WPARAM wParam,LPARAM lParam) <br>{ <br>    switch (msg) { <br> <br>    HANDLE_MSG(hwnd, WM_CREATE, Scrawl_OnCreate); <br> <br>    HANDLE_MSG(hwnd, WM_PAINT, Scrawl_OnPaint); <br> <br>    HANDLE_MSG(hwnd, WM_INITMENUPOPUP, Scrawl_OnInitMenuPopup); <br> <br>    HANDLE_MSG(hwnd, WM_KEYDOWN, Scrawl_OnKeyDown); <br> <br>    /* <br>     *  Reacquire the mouse and keyboard when we are the active window. <br>     *  Unacquire them when we stop being the active window. <br>     */ <br>    case WM_ACTIVATE: <br>        g_fActive = wParam == WA_ACTIVE || wParam == WA_CLICKACTIVE; <br>        Scrawl_SyncAcquire(hwnd); <br>        break; <br> <br>    /* <br>     *  Unacquire the devices if a menu appears, so that the user can <br>     *  interact with the menu in the normal manner. <br>     * <br>     *  From Windows' point of view, we are still the active window <br>     *  when a menu appears, but we want to act like the menu deactivated <br>     *  us. <br>     */ <br>    case WM_ENTERMENULOOP: <br>    case WM_ENTERSIZEMOVE: <br>        g_fActive = FALSE; <br>        Scrawl_SyncAcquire(hwnd); <br>        break; <br> <br>    /* <br>     *  Reacquire the devices when the menu goes away. <br>     * <br>     *  SUBTLETY 1:  Windows actually sends the WM_EXITMENULOOP message <br>     *  before all the menu-related stuff is finished, so post ourselves <br>     *  a private message to reacquire after the menu has been torn <br>     *  down for real. <br>     * <br>     *  SUBTLETY 2:  Don't assume that just because the menu is going <br>     *  away that you are still the active window.  You might not be. <br>     * <br>     *  SUBTLETY 3:  Don't assume that just because you're the active <br>     *  window that you are restored and ready for action.  You might <br>     *  just be a taskbar button. <br>     */ <br>    case WM_EXITMENULOOP: <br>    case WM_EXITSIZEMOVE: <br>        g_fActive = GetActiveWindow() == hwnd &amp;&amp; !IsIconic(hwnd); <br>        PostMessage(hwnd, WM_SYNCACQUIRE, 0, 0L); <br>        break; <br> <br>    case WM_SYNCACQUIRE: <br>        Scrawl_SyncAcquire(hwnd); <br>        break; <br> <br>    case WM_SYSCOMMAND: <br> <br>        LRESULT lRc; <br>        switch (GET_WM_COMMAND_ID(wParam, lParam)) { <br>        case IDC_CLEAR: <br>            Scrawl_OnClear(hwnd); <br>            lRc = 0; <br>            break; <br> <br>        case IDC_ABOUT: <br>            MessageBox(hwnd, "Scrawl DirectInput Sample v1.0", <br>                    c_szAppName, MB_OK); <br>            lRc = 0; <br>            break; <br> <br>        /* <br>         *  Eat the screen-saver notification. <br>         */ <br>        case SC_SCREENSAVE: <br>            lRc = 0; <br>            break; <br> <br>        case IDC_SENSITIVITY_LOW: <br>        case IDC_SENSITIVITY_NORMAL: <br>        case IDC_SENSITIVITY_HIGH: <br>            g_iSensitivity = (signed short)GET_WM_COMMAND_ID(wParam, lParam) <br>                                - IDC_SENSITIVITY_NORMAL; <br>            lRc = 0; <br>            break; <br> <br>        default: <br>            lRc = DefWindowProc(hwnd, msg, wParam, lParam); <br>            break; <br>        } <br> <br>        /* <br>         * The WM_SYSCOMMAND might've been a WM_CLOSE, in which case <br>         * our window no longer exists.  So be careful. <br>         */ <br>        if (IsWindow(hwnd)) { <br>            Scrawl_SyncAcquire(hwnd); <br>        } <br>        return lRc; <br> <br> <br>    case WM_DESTROY: <br>        PostQuitMessage(0); <br>        break; <br> <br>    } <br> <br>    return DefWindowProc(hwnd, msg, wParam, lParam); <br>} <br> <br>/**************************************************************************** <br> * <br> *      AppInit <br> * <br> *      Set up everything the application needs to get started. <br> * <br> ****************************************************************************/ <br> <br>HWND AppInit(HINSTANCE hinst, int nCmdShow) <br>{ <br> <br>    /* Save instance handle for people who care */ <br>    g_hinst = hinst; <br> <br>    /* <br>     *  Get our crosshairs cursor and extract the the width and <br>     *  hotspot location so we can draw it manually. <br>     */ <br>    g_hcurCross = LoadCursor(NULL, IDC_CROSS); <br> <br>    ICONINFO ii; <br> <br>    GetIconInfo(g_hcurCross, &amp;ii); <br> <br>    BITMAP bm; <br> <br>    GetObject(ii.hbmMask, sizeof(BITMAP), &amp;bm); <br> <br>    if (ii.hbmMask)  DeleteObject(ii.hbmMask); <br>    if (ii.hbmColor) DeleteObject(ii.hbmColor); <br> <br>    g_dxCrossHot = ii.xHotspot; <br>    g_dyCrossHot = ii.yHotspot; <br> <br>    g_cxCross = bm.bmWidth; <br>    g_cyCross = bm.bmHeight; <br> <br>    /* <br>     *  Create our scrawl bitmap and set it up. <br>     */ <br>    HDC hdc = GetDC(0); <br>    g_hdc = CreateCompatibleDC(hdc); <br>    ReleaseDC(0, hdc); <br> <br>    if (!g_hdc) return NULL; <br> <br>    g_hbm = CreateBitmap(DINPUT_CXBITMAP, DINPUT_CYBITMAP, 1, 1, 0); <br> <br>    if (!g_hbm) return NULL; <br> <br>    g_hbmDeselect = (HBITMAP) SelectObject(g_hdc, g_hbm); <br> <br>    Scrawl_OnClear(0); <br> <br>    /* <br>     *  Set up the window class. <br>     */ <br>    WNDCLASS wc; <br> <br>    wc.hCursor        = LoadCursor(0, IDC_ARROW); <br>    wc.hIcon          = LoadIcon(hinst, MAKEINTRESOURCE(IDI_MAIN)); <br>    wc.lpszMenuName   = NULL; <br>    wc.lpszClassName  = c_szAppName; <br>    wc.hbrBackground  = 0; <br>    wc.hInstance      = hinst; <br>    wc.style          = 0; <br>    wc.lpfnWndProc    = ScrawlWndProc; <br>    wc.cbClsExtra     = 0; <br>    wc.cbWndExtra     = 0; <br> <br>    if (!RegisterClass(&amp;wc)) { <br>        return NULL; <br>    } <br> <br>    DWORD dwStyle = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX; <br>    DWORD dwExStyle = WS_EX_APPWINDOW; <br> <br>    RECT rc = { 0, 0, DINPUT_CXBITMAP, DINPUT_CYBITMAP }; <br> <br>    AdjustWindowRectEx(&amp;rc, dwStyle, FALSE, dwExStyle); <br> <br>    HWND hwnd = CreateWindowEx( <br>                    dwExStyle,          // ExStyle <br>                    c_szAppName,        // Class name <br>                    c_szAppName,        // Caption <br>                    dwStyle,            // Style <br>                    CW_USEDEFAULT, CW_USEDEFAULT,  // Position <br>                    rc.right - rc.left, // cx <br>                    rc.bottom - rc.top, // cy </code></pre>
<p>
</p>
<pre><code>0,                  // Parent window (no parent) <br>                    0,                  // use class menu <br>                    g_hinst,            // handle to module instance <br>                    0                   // no params to pass on <br>                    ); <br> <br>    if (!DIInit(hwnd)) { <br>        DestroyWindow(hwnd); <br>        return NULL; <br>    } <br> <br>    ShowWindow(hwnd, nCmdShow); <br> <br>    return hwnd; <br>} <br> <br>/**************************************************************************** <br> * <br> *      WinMain <br> * <br> *      Application entry point. <br> * <br> *      The main message loop illustrates how a message-driven program <br> *      can use event notifications to be signalled when new data is <br> *      available from a device. <br> * <br> ****************************************************************************/ <br> <br>int PASCAL <br>WinMain(HINSTANCE hinst, HINSTANCE hinstPrev, LPSTR szCmdLine, int nCmdShow) <br>{ <br>    MSG msg; <br>    msg.wParam = 0;         /* In case something goes horribly wrong */ <br> <br>    HWND hwnd = AppInit(hinst, nCmdShow); <br> <br>    if (hwnd) { <br> <br>        /* <br>         *  Since we use notification handles, we need to use <br>         *  MsgWaitForMultipleObjects to wait for the event or <br>         *  a message, whichever comes first. <br>         */ <br> <br>        BOOL fDone = FALSE; <br> <br>        while (!fDone) { <br> <br>            DWORD dw = MsgWaitForMultipleObjects(1, &amp;g_hevtMouse, 0, INFINITE, <br>                                                 QS_ALLINPUT); <br> <br>            switch (dw) { <br> <br>            /* WAIT_OBJECT_0 + 0 means that g_hevtMouse was signalled */ <br>            case WAIT_OBJECT_0 + 0: <br>                Scrawl_OnMouseInput(hwnd); <br>                break; <br> <br>            /* WAIT_OBJECT_0 + 1 means that we have messages to process */ <br>            case WAIT_OBJECT_0 + 1: <br> <br>                while (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) { <br> <br>                    /* If it's a quit message, we're outta here */ <br>                    if (msg.message == WM_QUIT) { <br>                        fDone = TRUE; <br>                    } else { <br>                        TranslateMessage(&amp;msg); <br>                        DispatchMessage(&amp;msg); <br>                    } <br>                } <br>                break; <br>            } <br>        } <br>    } <br> <br>    DITerm(); <br> <br>    if (g_hdc) { <br>        if (g_hbmDeselect) { <br>            SelectObject(g_hdc, g_hbmDeselect); <br>        } <br>        DeleteDC(g_hdc); <br>    } <br> <br>    if (g_hbm) { <br>        DeleteObject(g_hbm); <br>    } <br> <br>  return msg.wParam; <br> <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
