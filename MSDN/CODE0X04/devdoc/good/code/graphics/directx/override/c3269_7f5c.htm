<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OVERRIDE.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3270"></a>OVERRIDE.C</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved. <br> * <br> *  File:       override.c <br> *  Content:Implementation of a DirectPlay launching utility <br> * <br> ***************************************************************************/ <br> <br>#define INITGUID <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;objbase.h&gt; <br>#include &lt;cguid.h&gt; <br> <br>#include "dplay.h" <br>#include "dplobby.h" <br> <br>#include "resource.h" <br> <br>#define NAMEMAX200// string size <br>#define TIMERID1// timer ID to use <br>#define TIMERINTERVAL1000// timer interval <br> <br>typedef struct { <br>LPDIRECTPLAY3AlpDPlay; <br>GUIDguidInstance; <br>} STATUSCONTEXT, *LPSTATUSCONTEXT; <br> <br>// guid for this application <br>// {126E6180-D307-11d0-9C4F-00A0C905425E} <br>DEFINE_GUID(OVERRIDE_GUID,  <br>0x126e6180, 0xd307, 0x11d0, 0x9c, 0x4f, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e); <br> <br>// prototypes <br>BOOL CALLBACKOverrideWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam); <br>BOOL CALLBACKSessionsWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam); <br> <br>HRESULTInitializeOverrideWindow(HWND hWnd, LPDIRECTPLAYLOBBY2A *lplpDPlayLobby); <br>voidDestroyOverrideWindow(HWND hWnd, LPDIRECTPLAY3A lpDPlay, LPDIRECTPLAYLOBBY2A lpDPlayLobby); <br>HRESULTUpdateAddressInfo(HWND hWnd, LPDIRECTPLAYLOBBY2A lpDPlayLobby2A); <br>HRESULTDoHostOrJoin(HINSTANCE hInstance, HWND hWnd, LPDIRECTPLAYLOBBY2A lpDPlayLobby, BOOL bHost, LPDIRECTPLAY3A *lplpDPlay); <br>BOOL FAR PASCALDirectPlayEnumerateCallback(LPGUID lpSPGuid, LPTSTR lpszSPName, <br>DWORD dwMajorVersion, DWORD dwMinorVersion, LPVOID lpContext); <br>HRESULTGetServiceProviderGuid(HWND hWnd, LPGUID lpguidServiceProvider); <br>voidDeleteServiceProviderCombo(HWND hWnd); <br>HRESULTFillModemComboBox(HWND hWnd, LPDIRECTPLAYLOBBY2A lpDPlayLobby); <br>BOOLDlgItemIsChecked(HWND hDlg, int nIDDlgItem); <br>voidEnableDlgButton(HWND hDlg, int nIDDlgItem, BOOL bEnable); <br> <br>// --------------------------------------------------------------------------- <br>// WinMain <br>// --------------------------------------------------------------------------- <br>// Description:             Main windows entry point. <br>// Arguments: <br>//  HINSTANCE               [in] Standard windows stuff <br>//  HINSTANCE               [in] <br>//  LPSTR                   [in] <br>//  int                     [in] <br>// Returns: <br>//  int <br>int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, <br>    LPSTR lpCmdLine, int nCmdShow ) <br>{ <br>HRESULThr; <br>intiResult = 0; <br> <br>// initialize COM library <br>hr = CoInitialize(NULL); <br>if FAILED(hr) <br>goto FAILURE; <br> <br>    iResult = DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_OVERRIDEDIALOG), NULL, OverrideWndProc, (LPARAM) hInstance); <br> <br>FAILURE: <br>// Uninitialize the COM library <br>CoUninitialize(); <br> <br>return (iResult); <br>} <br> <br> <br>// --------------------------------------------------------------------------- <br>// OverrideWndProc <br>// --------------------------------------------------------------------------- <br>// Description:             Message callback function for Override dialog. <br>// Arguments: <br>//  HWND                    [in] Dialog window handle. <br>//  UINT                    [in] Window message identifier. <br>//  WPARAM                  [in] Depends on message. <br>//  LPARAM                  [in] Depends on message. <br>// Returns: <br>//  BOOL                    TRUE if message was processed internally. <br>BOOL CALLBACK OverrideWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) <br>{ <br>    static HINSTANCEhInstance; <br>static LPDIRECTPLAY3AlpDPlay; <br>static LPDIRECTPLAYLOBBY2AlpDPlayLobby; <br>HRESULThr; <br> <br>    switch(uMsg) <br>    { <br>        case WM_INITDIALOG: <br>            // Save the instance handle <br>            hInstance = (HINSTANCE)lParam; <br>                         <br>// Initialize dialog with launcher information <br>lpDPlay = NULL; <br>lpDPlayLobby = NULL; <br>hr = InitializeOverrideWindow(hWnd, &amp;lpDPlayLobby); <br>if FAILED(hr) <br>SetDlgItemText(hWnd, IDC_STATUSEDIT, "Could not initialize DirectPlay"); <br>            break; <br> <br>        case WM_DESTROY: <br>// Destroy launcher information in dialog <br>DestroyOverrideWindow(hWnd, lpDPlay, lpDPlayLobby); <br>            break; <br> <br>        case WM_COMMAND: <br>            switch(LOWORD(wParam)) <br>            { <br>case IDC_SPCOMBO: <br> <br>switch (HIWORD(wParam)) <br>{ <br>case CBN_SELCHANGE: <br>UpdateAddressInfo(hWnd, lpDPlayLobby); <br>break; <br>} <br>break; <br> <br>case IDC_MODEMCOMBO: <br> <br>switch (HIWORD(wParam)) <br>{ <br>case CBN_SELCHANGE: <br>break; <br>} <br>break; <br> <br>                case IDC_HOSTBUTTON: <br> <br>SetDlgItemText(hWnd, IDC_STATUSEDIT, "Hosting..."); <br>hr = DoHostOrJoin(hInstance, hWnd, lpDPlayLobby, TRUE, &amp;lpDPlay); <br>if FAILED(hr) <br>SetDlgItemText(hWnd, IDC_STATUSEDIT, "Failed to host"); <br>else <br>SetDlgItemText(hWnd, IDC_STATUSEDIT, "Host successfull"); <br>                    break; <br> <br>                case IDC_JOINBUTTON: <br> <br>SetDlgItemText(hWnd, IDC_STATUSEDIT, "Joining..."); <br>hr = DoHostOrJoin(hInstance, hWnd, lpDPlayLobby, FALSE, &amp;lpDPlay); <br>if FAILED(hr) <br>SetDlgItemText(hWnd, IDC_STATUSEDIT, "Failed to join"); <br>else <br>SetDlgItemText(hWnd, IDC_STATUSEDIT, "Join successfull"); <br>                    break; <br> <br>                case IDCANCEL: <br>                    // Return failure <br>                    EndDialog(hWnd, TRUE); <br> <br>                    break; <br>            } <br> <br>            break; <br>    } <br> <br>    // Allow for default processing <br>    return FALSE; <br>} <br> <br>HRESULT InitializeOverrideWindow(HWND hWnd, LPDIRECTPLAYLOBBY2A *lplpDPlayLobby) <br>{ <br>LPDIRECTPLAYLOBBYAlpDPlayLobbyA = NULL; <br>LPDIRECTPLAYLOBBY2AlpDPlayLobby2A = NULL; <br>HRESULThr; <br> <br>// get ANSI DirectPlayLobby interface <br>hr = DirectPlayLobbyCreate(NULL, &amp;lpDPlayLobbyA, NULL, NULL, 0); <br>if FAILED(hr) <br>goto FAILURE; <br> <br>// get ANSI DirectPlayLobby2 interface <br>hr = lpDPlayLobbyA-&gt;lpVtbl-&gt;QueryInterface(lpDPlayLobbyA, <br>&amp;IID_IDirectPlayLobby2A, (LPVOID *) &amp;lpDPlayLobby2A); <br>if FAILED(hr) <br>goto FAILURE; <br> <br>// don't need DirectPlayLobby interface anymore <br>lpDPlayLobbyA-&gt;lpVtbl-&gt;Release(lpDPlayLobbyA); <br>lpDPlayLobbyA = NULL; <br> <br>// put all the service providers in combo box <br>DirectPlayEnumerate(DirectPlayEnumerateCallback, hWnd); <br>SendDlgItemMessage(hWnd, IDC_SPCOMBO, CB_SETCURSEL, (WPARAM) 0, (LPARAM) 0); <br> <br>// fill modem combo box with available modems <br>FillModemComboBox(hWnd, lpDPlayLobby2A); <br> <br>// update display first service provider <br>UpdateAddressInfo(hWnd, lpDPlayLobby2A); <br> <br>// return the ANSI lobby interface <br>*lplpDPlayLobby = lpDPlayLobby2A; <br> <br>return (DP_OK); <br> <br>FAILURE: <br>if (lpDPlayLobbyA) <br>lpDPlayLobbyA-&gt;lpVtbl-&gt;Release(lpDPlayLobbyA); <br>if (lpDPlayLobby2A) <br>lpDPlayLobby2A-&gt;lpVtbl-&gt;Release(lpDPlayLobby2A); <br> <br>return (hr); <br>} <br> <br>void DestroyOverrideWindow(HWND hWnd, LPDIRECTPLAY3A lpDPlay, LPDIRECTPLAYLOBBY2A lpDPlayLobby) <br>{ <br>// delete combo box data items <br>DeleteServiceProviderCombo(hWnd); <br> <br>// release the dplay interface <br>if (lpDPlay) <br>lpDPlay-&gt;lpVtbl-&gt;Release(lpDPlay); <br> <br>// release the lobby interface <br>if (lpDPlayLobby) <br>lpDPlayLobby-&gt;lpVtbl-&gt;Release(lpDPlayLobby); <br>} <br> <br>// --------------------------------------------------------------------------- <br>// DirectPlayEnumerateCallback <br>// --------------------------------------------------------------------------- <br>// Description:             Enumeration callback called by DirectPlay. <br>//Enumerates service providers registered with DirectPlay. <br>// Arguments: <br>//  LPGUID[in] GUID of service provider <br>//  LPTSTR[in] name of service provider <br>//  DWORD[in] major version of DirectPlay <br>//  DWORD[in] minor version of DirectPlay <br>//  LPVOID    [in] user-defined context <br>// Returns: <br>//  BOOLTRUE to continue enumerating <br>BOOL FAR PASCAL DirectPlayEnumerateCallback( <br>LPGUIDlpSPGuid, <br>LPTSTRlpszSPName, <br>DWORDdwMajorVersion, <br>DWORDdwMinorVersion, <br>LPVOIDlpContext) <br>{ <br>    HWNDhWnd = lpContext; <br>    LRESULTiIndex; <br>LPGUIDlpGuid; <br> <br>// store service provider name in combo box <br>iIndex = SendDlgItemMessage(hWnd, IDC_SPCOMBO, CB_ADDSTRING, 0, (LPARAM) lpszSPName); <br>if (iIndex == CB_ERR) <br>goto FAILURE; <br> <br>// make space for application GUID <br>lpGuid = (LPGUID) GlobalAllocPtr(GHND, sizeof(GUID)); <br>if (lpGuid == NULL) <br>goto FAILURE; <br> <br>// store pointer to GUID in combo box <br>*lpGuid = *lpSPGuid; <br>SendDlgItemMessage(hWnd, IDC_SPCOMBO, CB_SETITEMDATA, (WPARAM) iIndex, (LPARAM) lpGuid); <br> <br>FAILURE: <br>    return (TRUE); <br>} <br> <br>HRESULT GetServiceProviderGuid(HWND hWnd, LPGUID lpguidServiceProvider) <br>{ <br>LONGiIndex; <br> <br>// get guid for service provider <br>iIndex = SendDlgItemMessage(hWnd, IDC_SPCOMBO, CB_GETCURSEL, <br>(WPARAM) 0, (LPARAM) 0); <br>if (iIndex == CB_ERR) <br>return (DPERR_GENERIC); <br> <br>iIndex = SendDlgItemMessage(hWnd, IDC_SPCOMBO, CB_GETITEMDATA, <br>(WPARAM) iIndex, (LPARAM) 0); <br>if ((iIndex == CB_ERR) || (iIndex == 0)) <br>return (DPERR_GENERIC); <br> <br>*lpguidServiceProvider = *((LPGUID) iIndex); <br> <br>return (DP_OK); <br>} <br> <br>void DeleteServiceProviderCombo(HWND hWnd) <br>{ <br>WPARAMi; <br>LONGlpData; <br> <br>// destroy the data stored with each combo box item <br>i = 0; <br>while (TRUE) <br>{ <br>// get data pointer stored with item <br>lpData = SendDlgItemMessage(hWnd, IDC_SPCOMBO, CB_GETITEMDATA, <br>(WPARAM) i, (LPARAM) 0); <br>if (lpData == CB_ERR)// error getting data <br>break; <br> <br>if (lpData)// data to delete <br>GlobalFreePtr((LPVOID) lpData); <br> <br>i += 1; <br>} <br> <br>// delete all items in list <br>SendDlgItemMessage(hWnd, IDC_SPCOMBO, CB_RESETCONTENT, <br>(WPARAM) 0, (LPARAM) 0); <br>} <br> <br>void DeleteSessionInstanceList(HWND hWnd) <br>{ <br>WPARAMi; <br>LONGlpData; <br> <br>// destroy the GUID's stored with each session name <br>i = 0; <br>while (TRUE) <br>{ <br>// get data pointer stored with item <br>lpData = SendDlgItemMessage(hWnd, IDC_SESSIONLIST, LB_GETITEMDATA, <br>(WPARAM) i, (LPARAM) 0); <br>if (lpData == CB_ERR)// error getting data <br>break; <br> <br>if (lpData)// data to delete <br>GlobalFreePtr((LPVOID) lpData); <br> <br>i += 1; <br>} <br> <br>// delete all items in list <br>SendDlgItemMessage(hWnd, IDC_SESSIONLIST, LB_RESETCONTENT, <br>(WPARAM) 0, (LPARAM) 0); <br>} <br> <br>void SelectSessionInstance(HWND hWnd, LPGUID lpguidSessionInstance) <br>{ <br>WPARAMi, iIndex; <br>LONGlpData; <br> <br>// loop over the GUID's stored with each session name <br>// to find the one that matches what was passed in <br>i = 0; <br>iIndex = 0; <br>while (TRUE) <br>{ <br>// get data pointer stored with item <br>lpData = SendDlgItemMessage(hWnd, IDC_SESSIONLIST, LB_GETITEMDATA, <br>(WPARAM) i, (LPARAM) 0); <br>if (lpData == CB_ERR)// error getting data <br>break; <br> <br>if (lpData == 0)// no data to compare to <br>continue; <br> <br>// guid matches <br>if (IsEqualGUID(lpguidSessionInstance, (LPGUID) lpData)) <br>{ <br>iIndex = i;// store index of this string <br>break; <br>} <br> <br>i += 1; <br>} <br> <br>// select this item <br>SendDlgItemMessage(hWnd, IDC_SESSIONLIST, LB_SETCURSEL, (WPARAM) iIndex, (LPARAM) 0); <br>} <br> <br>HRESULT GetSessionInstanceGuid(HWND hWnd, LPGUID lpguidSessionInstance) <br>{ <br>LONGiIndex; <br> <br>// get guid for session <br>iIndex = SendDlgItemMessage(hWnd, IDC_SESSIONLIST, LB_GETCURSEL, <br>(WPARAM) 0, (LPARAM) 0); <br>if (iIndex == LB_ERR) <br>return (DPERR_GENERIC); <br> <br>iIndex = SendDlgItemMessage(hWnd, IDC_SESSIONLIST, LB_GETITEMDATA, <br>(WPARAM) iIndex, (LPARAM) 0); <br>if ((iIndex == LB_ERR) || (iIndex == 0)) <br>return (DPERR_GENERIC); <br> <br>*lpguidSessionInstance = *((LPGUID) iIndex); <br> <br>return (DP_OK); <br>} <br> <br>BOOL FAR PASCAL EnumSessionsCallback( <br>LPCDPSESSIONDESC2lpSessionDesc, <br>LPDWORDlpdwTimeOut, <br>DWORDdwFlags, <br>LPVOIDlpContext) <br>{ <br>HWNDhWnd = (HWND) lpContext; <br>LPGUIDlpGuid; <br>LONGiIndex; <br> <br>// see if last session has been enumerated <br>    if (dwFlags &amp; DPESC_TIMEDOUT) <br>return (FALSE); <br> <br>// store session name in list <br>iIndex = SendDlgItemMessage( hWnd, IDC_SESSIONLIST, LB_ADDSTRING,  <br>(WPARAM) 0, (LPARAM) lpSessionDesc-&gt;lpszSessionNameA); <br> <br>if (iIndex == LB_ERR) <br>goto FAILURE; <br> <br> <br>// make space for session instance guid <br>lpGuid = (LPGUID) GlobalAllocPtr( GHND, sizeof(GUID) ); <br>if (lpGuid == NULL) <br>goto FAILURE; <br> <br>// store pointer to guid in list <br>*lpGuid = lpSessionDesc-&gt;guidInstance; <br>SendDlgItemMessage( hWnd, IDC_SESSIONLIST, LB_SETITEMDATA, (WPARAM) iIndex, (LPARAM) lpGuid); <br> <br>FAILURE: <br>    return (TRUE); <br>} <br> <br>BOOL CALLBACK SessionsWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) <br>{ <br>static LPSTATUSCONTEXTlpContext; <br>static LPDIRECTPLAY3AlpDPlay; <br>static UINTidTimer; <br>static BOOLbInsideEnumSessions; <br>DPSESSIONDESC2sessionDesc; <br>GUIDguidSessionInstance; <br>LONGiIndex; <br>HRESULThr; <br> <br>    switch(uMsg) <br>    { <br>        case WM_INITDIALOG: <br>lpContext = (LPSTATUSCONTEXT) lParam; <br>lpDPlay = lpContext-&gt;lpDPlay; <br>bInsideEnumSessions = FALSE; <br> <br>// can't join until there is a session <br>EnableDlgButton(hWnd, IDC_JOINSESSIONBUTTON, FALSE); <br> <br>// set a timer to refresh the session list <br>idTimer = SetTimer(hWnd, TIMERID, TIMERINTERVAL, NULL); <br>            break; <br> <br>        case WM_DESTROY: <br>if (idTimer) <br>{ <br>KillTimer(hWnd, idTimer);  <br>idTimer = 0; <br>} <br>DeleteSessionInstanceList(hWnd); <br>            break; <br> <br>case WM_TIMER: <br>// make sure we don't re-enter EnumSessions <br>if (bInsideEnumSessions) <br>break; <br> <br>// get guid of currently selected session <br>guidSessionInstance = GUID_NULL; <br>hr = GetSessionInstanceGuid(hWnd, &amp;guidSessionInstance); <br> <br>// delete existing session list <br>DeleteSessionInstanceList(hWnd); <br> <br>// enum sessions <br>ZeroMemory(&amp;sessionDesc, sizeof(DPSESSIONDESC2)); <br>sessionDesc.dwSize = sizeof(DPSESSIONDESC2); <br>sessionDesc.guidApplication = OVERRIDE_GUID; <br> <br>bInsideEnumSessions = TRUE; <br>hr = lpDPlay-&gt;lpVtbl-&gt;EnumSessions(lpDPlay, &amp;sessionDesc, 0, <br>EnumSessionsCallback, hWnd, <br>DPENUMSESSIONS_AVAILABLE | <br>DPENUMSESSIONS_ASYNC | <br>DPENUMSESSIONS_RETURNSTATUS); <br>bInsideEnumSessions = FALSE; <br> <br>// select the session that was previously selected <br>SelectSessionInstance(hWnd, &amp;guidSessionInstance); <br> <br>// hilite "Join" button only if there are sessions to join <br>iIndex = SendDlgItemMessage(hWnd, IDC_SESSIONLIST, LB_GETCOUNT, <br>   (WPARAM) 0, (LPARAM) 0); <br> <br>EnableDlgButton(hWnd, IDC_JOINSESSIONBUTTON, (iIndex &gt; 0) ? TRUE : FALSE); <br> <br>switch (hr) <br>{ <br>case DP_OK: <br>SetDlgItemText(hWnd, IDC_SESSIONSTATUSEDIT, "Searching for sessions..."); <br>break; <br> <br>case DPERR_CONNECTING: <br>SetDlgItemText(hWnd, IDC_SESSIONSTATUSEDIT, "Making connection..."); <br>break; <br> <br>case DPERR_NOCONNECTION: <br>SetDlgItemText(hWnd, IDC_SESSIONSTATUSEDIT, "Connection failed"); <br>KillTimer(hWnd, idTimer);  <br>idTimer = 0; <br>break; <br> <br>default: <br>SetDlgItemText(hWnd, IDC_SESSIONSTATUSEDIT, "Error making connection"); <br>KillTimer(hWnd, idTimer);  <br>idTimer = 0; <br>break; <br>} <br>break; <br>         <br>case WM_COMMAND: <br>            switch(LOWORD(wParam)) <br>            { <br>                case IDC_JOINSESSIONBUTTON: <br>                    // Return guid of session to join <br>hr = GetSessionInstanceGuid(hWnd, &amp;lpContext-&gt;guidInstance); <br>if SUCCEEDED(hr) <br>EndDialog(hWnd, TRUE); <br>                    break; <br> <br>                case IDCANCEL: <br>                    // Return failure <br>                    EndDialog(hWnd, FALSE); <br>                    break; <br>            } <br> <br>            break; <br>    } <br> <br>    // Allow for default processing <br>    return FALSE; <br>} <br> <br>// --------------------------------------------------------------------------- <br>// UpdateAddressInfo <br>// --------------------------------------------------------------------------- <br>// Description:             Updates address information elements in dialog. <br>//Calls EnumAddressTypes() to determine what address <br>//information should be displayed and arranges dialog <br>//to display and collect the needed information. <br>// Arguments: <br>//  HWND[in] window handle <br>//  LPDIRECTPLAYLOBBY2A[in] DirectPlay Lobby interface to use <br>// Returns: <br>//  HRESULTDP_OK if it succeedes, otherwise the error <br>HRESULT UpdateAddressInfo(HWND hWnd, LPDIRECTPLAYLOBBY2A lpDPlayLobby2A) <br>{ <br>GUIDguidServiceProvider; <br>HRESULThr; <br> <br>// clear and hide address dialog items <br>ShowWindow(GetDlgItem(hWnd, IDC_PHONEEDIT), SW_HIDE); <br>ShowWindow(GetDlgItem(hWnd, IDC_PHONEEDITLABEL), SW_HIDE); <br> <br>ShowWindow(GetDlgItem(hWnd, IDC_MODEMCOMBO), SW_HIDE); <br>ShowWindow(GetDlgItem(hWnd, IDC_MODEMCOMBOLABEL), SW_HIDE); <br> <br>ShowWindow(GetDlgItem(hWnd, IDC_TCPEDIT), SW_HIDE); <br>ShowWindow(GetDlgItem(hWnd, IDC_TCPEDITLABEL), SW_HIDE); <br> <br>ShowWindow(GetDlgItem(hWnd, IDC_IPXLABEL), SW_HIDE); <br> <br>ShowWindow(GetDlgItem(hWnd, IDC_SERVICEPROVIDERLABEL), SW_HIDE); <br> <br>// get currently selected service provider <br>hr = GetServiceProviderGuid(hWnd, &amp;guidServiceProvider); <br>if FAILED(hr) <br>goto FAILURE; <br> <br>// modem service provider <br>if (IsEqualGUID(&amp;guidServiceProvider, &amp;DPSPGUID_MODEM)) <br>{ <br>// show edit control to collect phone number <br>ShowWindow(GetDlgItem(hWnd, IDC_PHONEEDIT), SW_SHOW); <br>ShowWindow(GetDlgItem(hWnd, IDC_PHONEEDITLABEL), SW_SHOW); <br> <br>// show combo box to collect modem <br>ShowWindow(GetDlgItem(hWnd, IDC_MODEMCOMBO), SW_SHOW); <br>ShowWindow(GetDlgItem(hWnd, IDC_MODEMCOMBOLABEL), SW_SHOW); <br>} <br> <br>// internet TCP/IP service provider <br>else if (IsEqualGUID(&amp;guidServiceProvider, &amp;DPSPGUID_TCPIP)) <br>{ <br>// show edit control to collect IP address <br>ShowWindow(GetDlgItem(hWnd, IDC_TCPEDIT), SW_SHOW); <br>ShowWindow(GetDlgItem(hWnd, IDC_TCPEDITLABEL), SW_SHOW); <br>} <br> <br>// IPX service provider <br>else if (IsEqualGUID(&amp;guidServiceProvider, &amp;DPSPGUID_IPX)) <br>{ <br>// no address info is needed, so just display a string <br>ShowWindow(GetDlgItem(hWnd, IDC_IPXLABEL), SW_SHOW); <br>} <br> <br>// anything else, let service provider collect settings, if any <br>else <br>{ <br>ShowWindow(GetDlgItem(hWnd, IDC_SERVICEPROVIDERLABEL), SW_SHOW); <br>} <br> <br>FAILURE: <br>return (hr); <br>} <br> <br>HRESULTCreateServiceProviderAddress(HWND hWnd, LPDIRECTPLAYLOBBY2A lpDPlayLobby, <br> LPVOID *lplpAddress, LPDWORD lpdwAddressSize) <br>{ <br>DPCOMPOUNDADDRESSELEMENTaddressElements[3]; <br>CHARszIPAddressString[NAMEMAX]; <br>CHARszPhoneNumberString[NAMEMAX]; <br>CHARszModemString[NAMEMAX]; <br>LPVOIDlpAddress = NULL; <br>DWORDdwAddressSize = 0; <br>DWORDdwElementCount; <br>GUIDguidServiceProvider; <br>HRESULThr; <br> <br>// get currently selected service provider <br>hr = GetServiceProviderGuid(hWnd, &amp;guidServiceProvider); <br>if FAILED(hr) <br>goto FAILURE; <br> <br>dwElementCount = 0; <br> <br>if (IsEqualGUID(&amp;guidServiceProvider, &amp;DPSPGUID_MODEM)) <br>{ <br>// Modem needs a service provider, a phone number string and a modem string <br> <br>// service provider <br>addressElements[dwElementCount].guidDataType = DPAID_ServiceProvider; <br>addressElements[dwElementCount].dwDataSize = sizeof(GUID); <br>addressElements[dwElementCount].lpData = (LPVOID) &amp;DPSPGUID_MODEM; <br>dwElementCount++; <br> <br>// add a modem string if available <br>lstrcpy(szModemString, ""); <br>if (GetDlgItemText(hWnd, IDC_MODEMCOMBO, szModemString, NAMEMAX)) <br>{ <br>addressElements[dwElementCount].guidDataType = DPAID_Modem; <br>addressElements[dwElementCount].dwDataSize = lstrlen(szModemString) + 1; <br>addressElements[dwElementCount].lpData = szModemString; <br>dwElementCount++; <br>} <br> <br>// add phone number string <br>lstrcpy(szPhoneNumberString, ""); <br>GetDlgItemText(hWnd, IDC_PHONEEDIT, szPhoneNumberString, NAMEMAX); <br>addressElements[dwElementCount].guidDataType = DPAID_Phone; <br>addressElements[dwElementCount].dwDataSize = lstrlen(szPhoneNumberString) + 1; <br>addressElements[dwElementCount].lpData = szPhoneNumberString; <br>dwElementCount++; <br>} <br> <br>// internet TCP/IP service provider <br>else if (IsEqualGUID(&amp;guidServiceProvider, &amp;DPSPGUID_TCPIP)) <br>{ <br>// TCP/IP needs a service provider and an IP address <br> <br>// service provider <br>addressElements[dwElementCount].guidDataType = DPAID_ServiceProvider; <br>addressElements[dwElementCount].dwDataSize = sizeof(GUID); <br>addressElements[dwElementCount].lpData = (LPVOID) &amp;DPSPGUID_TCPIP; <br>dwElementCount++; <br> <br>// IP address string <br>lstrcpy(szIPAddressString, ""); <br>GetDlgItemText(hWnd, IDC_TCPEDIT, szIPAddressString, NAMEMAX); <br>addressElements[dwElementCount].guidDataType = DPAID_INet; <br>addressElements[dwElementCount].dwDataSize = lstrlen(szIPAddressString) + 1; <br>addressElements[dwElementCount].lpData = szIPAddressString; <br>dwElementCount++; <br>} <br> <br>// IPX service provider <br>else if (IsEqualGUID(&amp;guidServiceProvider, &amp;DPSPGUID_IPX)) <br>{ <br>// IPX just needs a service provider <br> <br>// service provider <br>addressElements[dwElementCount].guidDataType = DPAID_ServiceProvider; <br>addressElements[dwElementCount].dwDataSize = sizeof(GUID); <br>addressElements[dwElementCount].lpData = (LPVOID) &amp;DPSPGUID_IPX; <br>dwElementCount++; <br>} <br> <br>// anything else, let service provider collect settings, if any <br>else <br>{ <br>// service provider <br>addressElements[dwElementCount].guidDataType = DPAID_ServiceProvider; <br>addressElements[dwElementCount].dwDataSize = sizeof(GUID); <br>addressElements[dwElementCount].lpData = (LPVOID) &amp;guidServiceProvider; <br>dwElementCount++; <br>} <br> <br>// see how much room is needed to store this address <br>hr = lpDPlayLobby-&gt;lpVtbl-&gt;CreateCompoundAddress(lpDPlayLobby, <br>addressElements, dwElementCount, <br>NULL, &amp;dwAddressSize); <br>if (hr != DPERR_BUFFERTOOSMALL) <br>goto FAILURE; <br> <br>// allocate space <br>lpAddress = GlobalAllocPtr(GHND, dwAddressSize); <br>if (lpAddress == NULL) <br>{ <br>hr = DPERR_NOMEMORY; <br>goto FAILURE; <br>} <br> <br>// create the address <br>hr = lpDPlayLobby-&gt;lpVtbl-&gt;CreateCompoundAddress(lpDPlayLobby, <br>addressElements, dwElementCount, <br>lpAddress, &amp;dwAddressSize); <br>if FAILED(hr) <br>goto FAILURE; <br> <br>// return the address info <br>*lplpAddress = lpAddress; <br>*lpdwAddressSize = dwAddressSize; <br> <br>return (DP_OK); <br> <br>FAILURE: <br>if (lpAddress) <br>GlobalFreePtr(lpAddress); <br> <br>return (hr); <br>} <br> <br>HRESULTDoHostOrJoin(HINSTANCE hInstance, HWND hWnd, LPDIRECTPLAYLOBBY2A lpDPlayLobby, BOOL bHost, LPDIRECTPLAY3A *lplpDPlay) <br>{ <br>LPDIRECTPLAY3AlpDPlay = NULL; <br>LPVOIDlpAddress = NULL; <br>DWORDdwAddressSize = 0; <br>DPSESSIONDESC2sessionDesc; <br>STATUSCONTEXTstatusContext; <br>HRESULThr; <br> <br>// bail if we don't have a lobby interface <br>if (lpDPlayLobby == NULL) <br>return (DPERR_INVALIDOBJECT); <br> <br>// get service provider address from information in dialog <br>hr = CreateServiceProviderAddress(hWnd, lpDPlayLobby, &amp;lpAddress, &amp;dwAddressSize); <br>if FAILED(hr) <br>goto FAILURE; <br> <br>// interface already exists, so release it <br>if (*lplpDPlay) <br>{ <br>(*lplpDPlay)-&gt;lpVtbl-&gt;Release(*lplpDPlay); <br>*lplpDPlay = NULL; <br>} <br> <br>// create an ANSI DirectPlay3 interface <br>hr = CoCreateInstance(&amp;CLSID_DirectPlay, NULL, CLSCTX_INPROC_SERVER,  <br>  &amp;IID_IDirectPlay3A, (LPVOID*)&amp;lpDPlay); <br>if FAILED(hr) <br>goto FAILURE; <br> <br>// initialize the connection using the address <br>hr = lpDPlay-&gt;lpVtbl-&gt;InitializeConnection(lpDPlay, lpAddress, 0); <br>if FAILED(hr) <br>goto FAILURE; <br> <br>if (bHost) <br>{ <br>// host a new session <br>ZeroMemory(&amp;sessionDesc, sizeof(DPSESSIONDESC2)); <br>sessionDesc.dwSize = sizeof(DPSESSIONDESC2); <br>sessionDesc.dwFlags = DPSESSION_MIGRATEHOST | DPSESSION_KEEPALIVE; <br>sessionDesc.guidApplication = OVERRIDE_GUID; <br>sessionDesc.dwMaxPlayers = 0; <br>sessionDesc.lpszSessionNameA = "Override"; <br> <br>// open it <br>hr = lpDPlay-&gt;lpVtbl-&gt;Open(lpDPlay, &amp;sessionDesc, DPOPEN_CREATE); <br>} <br> <br>// enumerate the sessions <br>else <br>{ <br>// display status dialog and enumerate until we find a session <br>statusContext.lpDPlay = lpDPlay; <br>statusContext.guidInstance = GUID_NULL; <br> <br>if (!DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_SESSIONSDIALOG), hWnd, SessionsWndProc, (LPARAM) &amp;statusContext)) <br>{ <br>hr = DPERR_USERCANCEL; <br>goto FAILURE; <br>} <br> <br>// open the session selected by the use <br>ZeroMemory(&amp;sessionDesc, sizeof(DPSESSIONDESC2)); <br>sessionDesc.dwSize = sizeof(DPSESSIONDESC2); <br>sessionDesc.guidApplication = OVERRIDE_GUID; <br>sessionDesc.guidInstance = statusContext.guidInstance; <br> <br>// open it <br>hr = lpDPlay-&gt;lpVtbl-&gt;Open(lpDPlay, &amp;sessionDesc, DPOPEN_JOIN); <br>} <br> <br>if FAILED(hr) <br>goto FAILURE; <br> <br>// return the connected interface <br>*lplpDPlay = lpDPlay; <br> <br>// set to NULL so we don't release it below <br>lpDPlay = NULL; <br> <br>FAILURE: <br>if (lpDPlay) <br>{ <br>lpDPlay-&gt;lpVtbl-&gt;Close(lpDPlay); <br>lpDPlay-&gt;lpVtbl-&gt;Release(lpDPlay); <br>} <br> <br>if (lpAddress) <br>GlobalFreePtr(lpAddress); <br> <br>return (hr); <br>} <br> <br>// --------------------------------------------------------------------------- <br>// EnumModemAddress <br>// --------------------------------------------------------------------------- <br>// Description:             Enumeration callback called by DirectPlayLobby. <br>//Enumerates the DirectPlay address chunks. If the <br>//chunk contains modem strings, add them to the control. <br>// Arguments: <br>//  REFGUID                 [in] GUID of the address type <br>//  DWORD[in] size of chunk <br>//  LPVOID    [in] pointer to chunk <br>//  LPVOID    [in] user-defined context <br>// Returns: <br>//  BOOLFALSE to stop enumerating after the first callback <br>BOOL FAR PASCAL EnumModemAddress(REFGUID lpguidDataType, DWORD dwDataSize, <br>LPCVOID lpData, LPVOID lpContext) <br>{ <br>HWNDhWnd = (HWND) lpContext; <br>LPSTRlpszStr = (LPSTR) lpData; <br> <br>// modem <br>if (IsEqualGUID(lpguidDataType, &amp;DPAID_Modem)) <br>{ <br>// loop over all strings in list <br>while (lstrlen(lpszStr)) <br>{ <br>// store modem name in combo box <br>SendDlgItemMessage(hWnd, IDC_MODEMCOMBO, CB_ADDSTRING, 0, (LPARAM) lpszStr); <br> <br>// skip to next string <br>lpszStr += lstrlen(lpszStr) + 1; <br>} <br>} <br> <br>return (TRUE); <br>} <br> <br>// --------------------------------------------------------------------------- <br>// FillModemComboBox <br>// --------------------------------------------------------------------------- <br>// Description:             Fills combo box with modem names <br>// Arguments: <br>//  HWND                    [in]  Window handle. <br>//  LPDIRECTPLAYLOBBY2A     [in]  DirectPlay Lobby interface to use <br>//  LPGUID[out] GUID of service provider to use <br>// Returns: <br>//  HRESULTany error <br>HRESULT FillModemComboBox(HWND hWnd, LPDIRECTPLAYLOBBY2A lpDPlayLobby) <br>{ <br>LPDIRECTPLAYlpDPlay1 = NULL; <br>LPDIRECTPLAY3AlpDPlay3A = NULL; <br>LPVOIDlpAddress = NULL; <br>DWORDdwAddressSize = 0; <br>GUIDguidServiceProvider = DPSPGUID_MODEM; <br>HRESULThr; <br> <br>// get a DirectPlay interface for this service provider <br>hr = DirectPlayCreate(&amp;guidServiceProvider, &amp;lpDPlay1, NULL); <br>if FAILED(hr) <br>goto FAILURE; <br> <br>// query for an ANSI DirectPlay3 interface <br>hr = lpDPlay1-&gt;lpVtbl-&gt;QueryInterface(lpDPlay1, &amp;IID_IDirectPlay3A, (LPVOID *) &amp;lpDPlay3A); <br>if FAILED(hr) <br>goto FAILURE; <br> <br>// get size of player address for player zero <br>hr = lpDPlay3A-&gt;lpVtbl-&gt;GetPlayerAddress(lpDPlay3A, DPID_ALLPLAYERS, NULL, &amp;dwAddressSize); <br>if (hr != DPERR_BUFFERTOOSMALL) <br>goto FAILURE; <br> <br>// make room for it <br>lpAddress = GlobalAllocPtr(GHND, dwAddressSize); <br>if (lpAddress == NULL) <br>{ <br>hr = DPERR_NOMEMORY; <br>goto FAILURE; <br>} <br> <br>// get the address <br>hr = lpDPlay3A-&gt;lpVtbl-&gt;GetPlayerAddress(lpDPlay3A, DPID_ALLPLAYERS, lpAddress, &amp;dwAddressSize); <br>if FAILED(hr) <br>goto FAILURE; <br> <br>// get modem strings from address and put them in the combo box <br>hr = lpDPlayLobby-&gt;lpVtbl-&gt;EnumAddress(lpDPlayLobby, EnumModemAddress,  <br> lpAddress, dwAddressSize, hWnd); <br>if FAILED(hr) <br>goto FAILURE; <br> <br>// select first item in list <br>SendDlgItemMessage(hWnd, IDC_MODEMCOMBO, CB_SETCURSEL, (WPARAM) 0, 0); <br> <br>FAILURE: <br>if (lpDPlay1) <br>lpDPlay1-&gt;lpVtbl-&gt;Release(lpDPlay1); <br>if (lpDPlay3A) <br>lpDPlay3A-&gt;lpVtbl-&gt;Release(lpDPlay3A); <br>if (lpAddress) <br>GlobalFreePtr(lpAddress); <br> <br>return (hr); <br>} <br> <br>BOOL DlgItemIsChecked(HWND hDlg, int nIDDlgItem) <br>{ <br>return ((SendDlgItemMessage(hDlg, nIDDlgItem, BM_GETCHECK, (WPARAM) 0, (LPARAM) 0) == BST_CHECKED) ? TRUE : FALSE); <br>} <br> <br>void EnableDlgButton(HWND hDlg, int nIDDlgItem, BOOL bEnable) <br>{ <br>EnableWindow(GetDlgItem(hDlg, nIDDlgItem), bEnable); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
