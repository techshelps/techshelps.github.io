<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>JOYTOY.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3516"></a>JOYTOY.C</h2>
<pre><code>/* joytoy.c - WinMain() and WndProc() for JOYTOY, along with <br> *      initialization and support code. <br> * <br> * JOYTOY is a Windows with Multimedia application that illustrates <br> *  how to use the joystick services. When run, it presents the user <br> *  with a crosshair cursor. When the joystick or the mouse is moved, <br> *  the cursor follows. When a joystick button is pressed, JOYTOY <br> *  produces a sound and draws a bullet hole icon onto the screen. <br> * <br> * <br> *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br> *  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED <br> *  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR <br> *  A PARTICULAR PURPOSE. <br> * <br> *  Copyright 1993 - 1998 Microsoft Corporation. All Rights Reserved. <br> */ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include "joytoy.h" <br> <br> <br>char szAppName[] = "JoyToy";      <br>HANDLE hSound1, hSound2; <br>HANDLE hHole; <br>LPSTR lpSound1, lpSound2; <br> <br> <br>/* WinMain - Entry point for JOYTOY. <br> */ <br>int PASCAL WinMain(hInstance,hPrevInstance,lpszCmdLine,cmdShow) <br>HINSTANCE hInstance,hPrevInstance; <br>LPSTR lpszCmdLine; <br>int cmdShow; <br>{ <br>    MSG msg; <br> <br>    /* Initialize the application. <br>     */ <br>    if(! InitJoyToy(hInstance,hPrevInstance)) <br>        return FALSE; <br> <br>    /* Standard Windows message processing loop.  We don't drop out of <br>     * this loop until the user quits the application. <br>     */ <br>    while(GetMessage(&amp;msg, NULL, 0, 0)) <br>    { <br>        TranslateMessage(&amp;msg); <br>        DispatchMessage(&amp;msg); <br>    } <br> <br>    /* Unlock and free resources allocated by InitJoyToy(). <br>     */ <br>    UnlockResource(hSound1); <br>    UnlockResource(hSound2); <br>    FreeResource(hSound1); <br>    FreeResource(hSound2); <br>    FreeResource(hHole); <br> <br>    return (msg.wParam); <br>} <br> <br>/* DrawSight - Takes the new joystick position and moves the  <br> *  mouse cursor accordingly. <br> * <br> * Params:  lParam - Specifies the new joystick position. The <br> *  high-order word is the y position and the low-order word is <br> *  the x position. <br> * <br> * Returns: void <br> */ <br>void DrawSight(DWORD lParam) <br>{ <br>    WORD x, y; <br>    POINT pt; <br> <br>    /* Get the current cursor position in screen coordinates. <br>     */ <br>    GetCursorPos(&amp;pt); <br> <br>    /* Joystick positions are expressed in a coordinate system with the <br>     * origin in the upper left corner and with coordinate ranges from <br>     * 0 to 65535. Take the 5 most significant bits, so the position is  <br>     * expressed in the range of 0 to 31. <br>     */ <br>    x = LOWORD(lParam) &gt;&gt; 11; <br>    y = HIWORD(lParam) &gt;&gt; 11; <br> <br>    /* If the joystick is to the left of the center position, then move <br>     * the cursor position to the left. Otherwise, if the joystick is to  <br>     * the right of the center position, then move the cursor position  <br>     * to the right. <br>     */ <br>    if(x &lt;= 12) <br>        pt.x = pt.x + x - 17; <br>    else if(x &gt;= 20) <br>        pt.x = pt.x + x - 15; <br> <br>    /* If the joystick is below the center position, then move the cursor  <br>     * position down. Otherwise, if the joystick is above the center  <br>     * position, then move the cursor position up. <br>     */ <br>    if(y &lt;= 12) <br>        pt.y = pt.y + y - 17; <br>    else if(y &gt;= 20) <br>        pt.y = pt.y + y - 15; <br> <br>    /* Set the new cursor position. <br>     */ <br>    SetCursorPos(pt.x, pt.y); <br>} <br> <br>/* DrawHole - Draws an icon representing a hole in the given window at the  <br> * current cursor position. <br> * <br> * Params:  hWnd - Specifies the handle to the window to draw in. <br> * <br> * Returns: void <br> */ <br>void DrawHole(HWND hWnd) <br>{ <br>    HDC hDC; <br>    POINT pt; <br> <br>    /* Get the current cursor position. <br>     */ <br>    GetCursorPos(&amp;pt); <br>     <br>    /* Get a DC, draw the icon, release DC. <br>     */ <br>    hDC = GetDC(hWnd); <br>    DrawIcon(hDC, pt.x - 16, pt.y - 16, hHole); <br>    ReleaseDC(hWnd, hDC); <br>} <br> <br> <br>/* WndProc - Main window procedure function. <br> */ <br>LRESULT FAR PASCAL WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>    switch(message) <br>    { <br>        case WM_CREATE: <br>            /* Capture the joystick. If this fails, beep and display <br>             * error, then quit. <br>             */ <br>            if(joySetCapture(hWnd, JOYSTICKID1, 0, FALSE)) <br>            { <br>                MessageBeep(MB_ICONEXCLAMATION); <br>                MessageBox(hWnd, "Couldn't capture the joystick", NULL,  <br>                           MB_OK | MB_ICONEXCLAMATION); <br>                return -1; <br>            }             <br>            break; <br> <br>        case WM_ACTIVATE: <br>        case WM_ACTIVATEAPP: <br>            /* If app becomes inactive (wParam == 0), then we want to quit. <br>             */ <br>            if(wParam) <br>                break; <br> <br>        case WM_LBUTTONDOWN: <br>        case WM_MBUTTONDOWN: <br>        case WM_RBUTTONDOWN: <br>        case WM_KEYDOWN: <br>        case WM_CHAR: <br>            /* Also, any keystrokes or mouse buttons cause us to quit. <br>             */ <br>            PostMessage(hWnd,WM_CLOSE,0,0L); <br>            break; <br> <br>        case WM_ERASEBKGND: <br>            /* Process this message to keep Windows from erasing background. <br>             */ <br>            return 0l; <br>  <br>        case MM_JOY1BUTTONDOWN : <br>            /* Joystick button pressed. Detect which button, play appropriate <br>             * sound, then draw bullet hole. To play sound, pass  <br>             * sndPlaySound() a pointer to an in-memory WAVE file and  <br>             * specify the SND_MEMORY flag. Specify SND_LOOP and SND_ASYNC <br>             * so that sound keeps playing until it's turned off after  <br>             * joystick button is released. <br>             */ <br>            if (wParam &amp; JOY_BUTTON1CHG) <br>            { <br>                sndPlaySound(lpSound1, SND_LOOP | SND_ASYNC | SND_MEMORY); <br>                DrawHole(hWnd); <br>            } <br>            else if (wParam &amp; JOY_BUTTON2CHG) <br>            { <br>                sndPlaySound(lpSound2, SND_LOOP | SND_ASYNC | SND_MEMORY); <br>                DrawHole(hWnd); <br>            } <br>            break; <br> <br>        case MM_JOY1BUTTONUP : <br>            /* Stop playing looped sound. <br>             */ <br>            if (wParam &amp; JOY_BUTTON1) <br>                sndPlaySound(lpSound1, SND_LOOP | SND_ASYNC | SND_MEMORY); <br>            else if (wParam &amp; JOY_BUTTON2) <br>                sndPlaySound(lpSound2, SND_LOOP | SND_ASYNC | SND_MEMORY); <br>            else <br>                sndPlaySound(NULL, 0); <br>            break; <br> <br>        case MM_JOY1MOVE : <br>            /* If joystick buttons are pressed, draw bullet holes <br>             * while joystick is moved. <br>             */ <br>            if(wParam &amp; (JOY_BUTTON1 | JOY_BUTTON2)) <br>                DrawHole(hWnd); <br> <br>            /* Redraw the crosshair in its new position. <br>             */ <br>            DrawSight(lParam); <br>            break; <br> <br> <br>        case WM_DESTROY: <br>            /* We're shutting down. Release capture on the joystick,  <br>             * make sure any sounds that are playing are stopped. <br>             */ <br>            joyReleaseCapture(JOYSTICKID1); <br>            sndPlaySound(NULL, 0); <br>            PostQuitMessage(0); <br>            break; <br>    } <br>    return DefWindowProc(hWnd, message, wParam, lParam); <br>} <br> <br> <br>/* InitJoyToy - Application initialization routine. <br> * <br> * Params:  hInstance - App's instance handle. <br> * <br> * Returns: TRUE if initialization is successful, FALSE otherwise. <br> */ <br>BOOL InitJoyToy(HANDLE hInstance, HANDLE hPrevInstance) <br>{ <br>    WNDCLASS wc; <br>    HWND     hWnd; <br> <br>    /* Make sure there is a joystick device installed. <br>     */ <br>    if (!joyGetNumDevs()) <br>    { <br>        MessageBox(NULL, "There are no joystick devices installed. Exiting.", <br>                   NULL, MB_OK | MB_ICONEXCLAMATION); <br>        return FALSE; <br>    } <br>    <br>    /* Load bullet hole icon. <br>     */ <br>    hHole = LoadIcon(hInstance, "HoleIcon"); <br> <br>    if (hPrevInstance == NULL) { <br>        /* Setup and register a window class for our main window. <br>         */ <br>        wc.hCursor          = LoadCursor(NULL, IDC_CROSS); <br>        wc.hIcon            = NULL; <br>        wc.lpszMenuName     = NULL; <br>        wc.lpszClassName    = szAppName; <br>        wc.hbrBackground    = GetStockObject(BLACK_BRUSH); <br>        wc.hInstance        = hInstance; <br>        wc.style            = CS_HREDRAW | CS_VREDRAW; <br>        wc.lpfnWndProc      = WndProc; <br>        wc.cbClsExtra       = 0; <br>        wc.cbWndExtra       = 0; <br>     <br>        if(! RegisterClass(&amp;wc)) <br>            return FALSE;    <br>    } <br> <br>    /* Create a full-screen window with no title bar or scroll bars. <br>     */ <br>    hWnd = CreateWindow(szAppName, szAppName, WS_POPUP | WS_VISIBLE, 0, 0, <br>        GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN), <br>        NULL, NULL, hInstance, NULL); <br> <br>    if (hWnd != NULL) { <br>        /* Load and lock sound resources. <br>         */ <br>        hSound1 = LoadResource(hInstance, FindResource(hInstance, "SOUND1", "WAVE")); <br>        hSound2 = LoadResource(hInstance, FindResource(hInstance, "SOUND2", "WAVE")); <br>        lpSound1 = LockResource(hSound1); <br>        lpSound2 = LockResource(hSound2); <br>    } <br>    return hWnd != NULL; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
