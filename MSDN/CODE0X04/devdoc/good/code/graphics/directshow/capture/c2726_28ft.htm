<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>AMCAP.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2729"></a>AMCAP.CPP</h2>
<pre><code>/************************************************************************** <br> * <br> *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br> *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br> *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br> *  PURPOSE. <br> * <br> *  Copyright (c) 1993 - 1997  Microsoft Corporation.  All Rights Reserved. <br> * <br> **************************************************************************/ <br> <br>#include &lt;streams.h&gt; <br>#include &lt;mmreg.h&gt; <br>#include &lt;msacm.h&gt; <br>#include "fcntl.h" <br>#include "io.h" <br>#include "stdio.h" <br>#include "amcap.h" <br>#include "status.h" <br> <br>HINSTANCE ghInstApp; <br>HACCEL ghAccel; <br>HFONT  ghfontApp; <br>TEXTMETRIC gtm; <br>TCHAR gszAppName[]=TEXT("AMCAP"); <br>HWND ghwndApp, ghwndStatus; <br> <br>// forgive me for using global variables <br>struct _capstuff { <br>    char szCaptureFile[_MAX_PATH]; <br>    WORD wCapFileSize;  // size in Meg <br>    ICaptureGraphBuilder *pBuilder; <br>    IVideoWindow *pVW; <br>    IMediaEventEx *pME; <br>    IAMDroppedFrames *pDF; <br>    IAMVideoCompression *pVC; <br>    IAMVfwCaptureDialogs *pDlg; <br>    IAMStreamConfig *pASC;      // for audio cap <br>    IAMStreamConfig *pVSC;      // for video cap <br>    IBaseFilter *pRender; <br>    IBaseFilter *pVCap, *pACap; <br>    IGraphBuilder *pFg; <br>    IFileSinkFilter *pSink; <br>    IConfigAviMux *pConfigAviMux; <br>    int  iMasterStream; <br>    BOOL fCaptureGraphBuilt; <br>    BOOL fPreviewGraphBuilt; <br>    BOOL fCapturing; <br>    BOOL fPreviewing; <br>    BOOL fCapAudio; <br>    int  iVideoDevice; <br>    int  iAudioDevice; <br>    double FrameRate; <br>    BOOL fWantPreview; <br>    long lCapStartTime; <br>    long lCapStopTime; <br>    char achFriendlyName[120]; <br>    BOOL fUseTimeLimit; <br>    DWORD dwTimeLimit; <br>    int iFormatDialogPos; <br>    int iSourceDialogPos; <br>    int iDisplayDialogPos; <br>    int iVCapDialogPos; <br>    int iVCrossbarDialogPos; <br>    int iTVTunerDialogPos; <br>    int iACapDialogPos; <br>    int iACrossbarDialogPos; <br>    int iTVAudioDialogPos; <br>    int iVCapCapturePinDialogPos; <br>    int iVCapPreviewPinDialogPos; <br>    int iACapCapturePinDialogPos; <br>} gcap; <br> <br>typedef LONG (PASCAL *LPWNDPROC)(HWND, UINT, WPARAM, LPARAM); // pointer to a window procedure <br> <br>/*----------------------------------------------------------------------------*\ <br>\*----------------------------------------------------------------------------*/ <br>LONG WINAPI AppWndProc(HWND hwnd, UINT uiMessage, WPARAM wParam, LPARAM lParam); <br>LONG PASCAL AppCommand(HWND hwnd, unsigned msg, WPARAM wParam, LPARAM lParam); <br>BOOL CALLBACK AboutDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam); <br>int ErrMsg (LPTSTR sz,...); <br>BOOL SetCaptureFile(HWND hWnd); <br>BOOL SaveCaptureFile(HWND hWnd); <br>BOOL AllocCaptureFile(HWND hWnd); <br>int DoDialog(HWND hwndParent, int DialogID, DLGPROC fnDialog, long lParam); <br>int FAR PASCAL AllocCapFileProc(HWND hDlg, UINT Message, UINT wParam, LONG lParam); <br>int FAR PASCAL FrameRateProc(HWND hDlg, UINT Message, UINT wParam, LONG lParam); <br>int FAR PASCAL TimeLimitProc(HWND hDlg, UINT Message, UINT wParam, LONG lParam); <br>int FAR PASCAL PressAKeyProc(HWND hDlg, UINT Message, UINT wParam, LONG lParam); <br>void TearDownGraph(void); <br>BOOL BuildCaptureGraph(); <br>BOOL BuildPreviewGraph(); <br>void UpdateStatus(BOOL fAllStats); <br>void AddDevicesToMenu(); <br>void ChooseDevices(int idV, int idA); <br>void ChooseFrameRate(); <br>BOOL InitCapFilters(); <br>void FreeCapFilters(); <br>BOOL StopPreview(); <br>BOOL StartPreview(); <br>BOOL StopCapture(); <br>DWORDLONG GetSize(LPCSTR ach); <br>void MakeMenuOptions(); <br>/*----------------------------------------------------------------------------*\ <br>\*----------------------------------------------------------------------------*/ <br> <br>// set our app's caption to be our app name followed by the capture file name <br>// <br>void SetAppCaption() <br>{ <br>    char ach[_MAX_PATH + 80]; <br>    lstrcpy(ach, gszAppName); <br>    if (gcap.szCaptureFile[0] != 0) { <br>lstrcat(ach, " - "); <br>lstrcat(ach, gcap.szCaptureFile); <br>    } <br>    SetWindowText(ghwndApp, ach); <br>} <br> <br> <br>/*----------------------------------------------------------------------------*\ <br>|   AppInit( hInst, hPrev)                                                     | <br>|                                                                              | <br>|   Description:                                                               | <br>|       This is called when the application is first loaded into               | <br>|       memory.  It performs all initialization that doesn't need to be done   | <br>|       once per instance.                                                     | <br>|                                                                              | <br>|   Arguments:                                                                 | <br>|       hInstance       instance handle of current instance                    | <br>|       hPrev           instance handle of previous instance                   | <br>|                                                                              | <br>|   Returns:                                                                   | <br>|       TRUE if successful, FALSE if not                                       | <br>|                                                                              | <br>\*----------------------------------------------------------------------------*/ <br>BOOL AppInit(HINSTANCE hInst, HINSTANCE hPrev, int sw,LPSTR szCmdLine) <br>{ <br>    WNDCLASS    cls; <br>    HDC         hdc; <br> <br>    const DWORD  dwExStyle = 0; <br> <br>    CoInitialize(NULL); <br>    DbgInitialise(hInst); <br> <br>    /* Save instance handle for DialogBoxs */ <br>    ghInstApp = hInst; <br> <br>    ghAccel = LoadAccelerators(hInst, MAKEINTATOM(ID_APP)); <br> <br>    if (!hPrev) { <br>/* <br> *  Register a class for the main application window <br> */ <br>cls.hCursor        = LoadCursor(NULL,IDC_ARROW); <br>cls.hIcon          = LoadIcon(hInst, TEXT("AMCapIcon")); <br>cls.lpszMenuName   = MAKEINTATOM(ID_APP); <br>cls.lpszClassName  = MAKEINTATOM(ID_APP); <br>cls.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1); <br>cls.hInstance      = hInst; <br>cls.style          = CS_BYTEALIGNCLIENT | CS_VREDRAW | CS_HREDRAW | CS_DBLCLKS; <br>cls.lpfnWndProc    = (LPWNDPROC)AppWndProc; <br>cls.cbWndExtra     = 0; <br>cls.cbClsExtra     = 0; <br> <br>if (!RegisterClass(&amp;cls)) <br>    return FALSE; <br>    } <br> <br>    // Is this necessary? <br>    ghfontApp = (HFONT)GetStockObject(ANSI_VAR_FONT); <br>    hdc = GetDC(NULL); <br>    SelectObject(hdc, ghfontApp); <br>    GetTextMetrics(hdc, &amp;gtm); <br>    ReleaseDC(NULL, hdc); <br> <br>    ghwndApp=CreateWindowEx(dwExStyle, <br>    MAKEINTATOM(ID_APP),    // Class name <br>    gszAppName,             // Caption <br>    // Style bits <br>    WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN, <br>    CW_USEDEFAULT, 0,       // Position <br>    320,300,                // Size <br>    (HWND)NULL,             // Parent window (no parent) <br>    (HMENU)NULL,            // use class menu <br>    hInst,                  // handle to window instance <br>    (LPSTR)NULL             // no params to pass on <br>   ); <br> <br>    // create the status bar <br>    statusInit(hInst, hPrev); <br>    ghwndStatus = CreateWindowEx( <br>    0, <br>    szStatusClass, <br>    NULL, <br>    WS_CHILD|WS_BORDER|WS_VISIBLE|WS_CLIPSIBLINGS, <br>    0, 0, <br>    0, 0, <br>    ghwndApp, <br>    NULL, <br>    hInst, <br>    NULL); <br>    if (ghwndStatus == NULL) { <br>return(FALSE); <br>    } <br>    ShowWindow(ghwndApp,sw); <br> <br>    // get the capture file name from win.ini <br>    GetProfileString("annie", "CaptureFile", "", gcap.szCaptureFile, <br>sizeof(gcap.szCaptureFile)); <br> <br>    // get which devices to use from win.ini <br>    gcap.iVideoDevice = -1;     // force update <br>    gcap.iAudioDevice = -1;     // force update <br>    int idV = GetProfileInt("annie", "VideoDevice", 0); <br>    int idA = GetProfileInt("annie", "AudioDevice", 0); <br>    AddDevicesToMenu(); // list all capture devices in the system as menu items <br> <br>    // do we want audio? <br>    gcap.fCapAudio = GetProfileInt("annie", "CaptureAudio", TRUE); <br>    // do we want preview? <br>    gcap.fWantPreview = GetProfileInt("annie", "WantPreview", FALSE); <br>    // which stream should be the master? NONE(-1) means nothing special happens <br>    // AUDIO(1) means the video frame rate is changed before written out to keep <br>    // the movie in sync when the audio and video capture crystals are not the <br>    // same (and therefore drift out of sync after a few minutes).  VIDEO(0) <br>    // means the audio sample rate is changed before written out <br>    gcap.iMasterStream = GetProfileInt("annie", "MasterStream", -1); <br> <br> <br>    // get the frame rate from win.ini before making the graph <br>    int units_per_frame = GetProfileInt("annie", "FrameRate", 666667);  // 15fps <br>    gcap.FrameRate = 10000000. / units_per_frame; <br>    gcap.FrameRate = (int)(gcap.FrameRate * 100) / 100.; <br>    // reasonable default <br>    if (gcap.FrameRate &lt;= 0.) <br>gcap.FrameRate = 15.0; <br>  <br>    // instantiate the capture filters we need to do the menu items <br>    // this will start previewing, if wanted <br>    ChooseDevices(idV, idA);    // make these the official devices we're using <br>    InitCapFilters();           // creates the capture filters we will use <br>    ChooseDevices(idV, idA);    // puts video capture device name in title bar <br> <br>    SetAppCaption(); <br>    return TRUE; <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>|   WinMain( hInst, hPrev, lpszCmdLine, cmdShow )                              | <br>|                                                                              | <br>|   Description:                                                               | <br>|       The main procedure for the App.  After initializing, it just goes      | <br>|       into a message-processing loop until it gets a WM_QUIT message         | <br>|       (meaning the app was closed).                                          | <br>|                                                                              | <br>|   Arguments:                                                                 | <br>|       hInst           instance handle of this instance of the app            | <br>|       hPrev           instance handle of previous instance, NULL if first    | <br>|       szCmdLine       -&gt;null-terminated command line                         | <br>|       cmdShow         specifies how the window is initially displayed        | <br>|                                                                              | <br>|   Returns:                                                                   | <br>|       The exit code as specified in the WM_QUIT message.                     | <br>|                                                                              | <br>\*----------------------------------------------------------------------------*/ <br>int PASCAL WinMain(HINSTANCE hInst, HINSTANCE hPrev, LPSTR szCmdLine, int sw) <br>{ <br>    MSG     msg; <br> <br>    /* Call initialization procedure */ <br>    if (!AppInit(hInst,hPrev,sw,szCmdLine)) <br>return FALSE; <br> <br>    /* <br>     * Polling messages from event queue <br>     */ <br>    for (;;) <br>    { <br>while (PeekMessage(&amp;msg, NULL, 0, 0,PM_REMOVE)) <br>{ <br>    if (msg.message == WM_QUIT) <br>return msg.wParam; <br> <br>    if (TranslateAccelerator(ghwndApp, ghAccel, &amp;msg)) <br>continue; <br> <br>    TranslateMessage(&amp;msg); <br>    DispatchMessage(&amp;msg); <br>} <br> <br>WaitMessage(); <br>    } <br> <br>    // not reached <br>    return msg.wParam; <br>} <br> <br> <br>/*----------------------------------------------------------------------------*\ <br>|   AppWndProc( hwnd, uiMessage, wParam, lParam )                              | <br>|                                                                              | <br>|   Description:                                                               | <br>|       The window proc for the app's main (tiled) window.  This processes all | <br>|       of the parent window's messages.                                       | <br>|                                                                              | <br>|   Arguments:                                                                 | <br>|       hwnd            window handle for the window                           | <br>|       msg             message number                                         | <br>|       wParam          message-dependent                                      | <br>|       lParam          message-dependent                                      | <br>|                                                                              | <br>|   Returns:                                                                   | <br>|       0 if processed, nonzero if ignored                                     | <br>|                                                                              | <br>\*----------------------------------------------------------------------------*/ <br>LONG WINAPI  AppWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>    PAINTSTRUCT ps; <br>    HDC hdc; <br>    RECT rc; <br>    int cxBorder, cyBorder, cy; <br> <br>    switch (msg) { <br> <br>// <br>// <br>case WM_CREATE: <br>    break; <br> <br>case WM_COMMAND: <br>    return AppCommand(hwnd,msg,wParam,lParam); <br> <br>case WM_INITMENU: <br>    // we can start capture if not capturing already <br>    EnableMenuItem((HMENU)wParam, MENU_START_CAP,  <br>(!gcap.fCapturing) ? MF_ENABLED : <br>MF_GRAYED); <br>    // we can stop capture if it's currently capturing <br>    EnableMenuItem((HMENU)wParam, MENU_STOP_CAP,  <br>(gcap.fCapturing) ? MF_ENABLED : MF_GRAYED); <br> <br>    // We can bring up a dialog if the graph is stopped <br>    EnableMenuItem((HMENU)wParam, MENU_DIALOG0, !gcap.fCapturing ? <br>MF_ENABLED : MF_GRAYED); <br>    EnableMenuItem((HMENU)wParam, MENU_DIALOG1, !gcap.fCapturing ? <br>MF_ENABLED : MF_GRAYED); <br>    EnableMenuItem((HMENU)wParam, MENU_DIALOG2, !gcap.fCapturing ? <br>MF_ENABLED : MF_GRAYED); <br>    EnableMenuItem((HMENU)wParam, MENU_DIALOG3, !gcap.fCapturing ? <br>MF_ENABLED : MF_GRAYED); <br>    EnableMenuItem((HMENU)wParam, MENU_DIALOG4, !gcap.fCapturing ? <br>MF_ENABLED : MF_GRAYED); <br>    EnableMenuItem((HMENU)wParam, MENU_DIALOG5, !gcap.fCapturing ? <br>MF_ENABLED : MF_GRAYED); <br>    EnableMenuItem((HMENU)wParam, MENU_DIALOG6, !gcap.fCapturing ? <br>MF_ENABLED : MF_GRAYED); <br>    EnableMenuItem((HMENU)wParam, MENU_DIALOG7, !gcap.fCapturing ? <br>MF_ENABLED : MF_GRAYED); <br>    EnableMenuItem((HMENU)wParam, MENU_DIALOG8, !gcap.fCapturing ? <br>MF_ENABLED : MF_GRAYED); <br>    EnableMenuItem((HMENU)wParam, MENU_DIALOG9, !gcap.fCapturing ? <br>MF_ENABLED : MF_GRAYED); <br> <br>    // toggles capturing audio or not - can't be capturing right now <br>    // and we must have an audio capture device created <br>    EnableMenuItem((HMENU)wParam, MENU_CAP_AUDIO,  <br>    (!gcap.fCapturing &amp;&amp; gcap.pACap) ? MF_ENABLED : MF_GRAYED); <br>    // are we capturing audio? <br>    CheckMenuItem((HMENU)wParam, MENU_CAP_AUDIO,  <br>    (gcap.fCapAudio) ? MF_CHECKED : MF_UNCHECKED); <br>    // change audio formats when not capturing <br>    EnableMenuItem((HMENU)wParam, MENU_AUDIOFORMAT, (gcap.fCapAudio &amp;&amp; <br>!gcap.fCapturing) ? MF_ENABLED : MF_GRAYED); <br>    // change frame rate when not capturing <br>    EnableMenuItem((HMENU)wParam, MENU_FRAMERATE, <br>!gcap.fCapturing ? MF_ENABLED : MF_GRAYED); <br>    // change time limit when not capturing <br>    EnableMenuItem((HMENU)wParam, MENU_TIMELIMIT, <br>!gcap.fCapturing ? MF_ENABLED : MF_GRAYED); <br>    // change capture file name when not capturing <br>    EnableMenuItem((HMENU)wParam, MENU_SET_CAP_FILE, <br>!gcap.fCapturing ? MF_ENABLED : MF_GRAYED); <br>    // pre-allocate capture file when not capturing <br>    EnableMenuItem((HMENU)wParam, MENU_ALLOC_CAP_FILE, <br>!gcap.fCapturing ? MF_ENABLED : MF_GRAYED); <br>    // can save capture file when not capturing <br>    EnableMenuItem((HMENU)wParam, MENU_SAVE_CAP_FILE, <br>!gcap.fCapturing ? MF_ENABLED : MF_GRAYED); <br>    // do we want preview? <br>    CheckMenuItem((HMENU)wParam, MENU_PREVIEW,  <br>(gcap.fWantPreview) ? MF_CHECKED : MF_UNCHECKED); <br>    // can toggle preview if not capturing <br>    EnableMenuItem((HMENU)wParam, MENU_PREVIEW, <br>!gcap.fCapturing ? MF_ENABLED : MF_GRAYED); <br> <br>    // which is the master stream? <br>    EnableMenuItem((HMENU)wParam, MENU_NOMASTER, <br>!gcap.fCapturing ? MF_ENABLED : MF_GRAYED); <br>    CheckMenuItem((HMENU)wParam, MENU_NOMASTER,  <br>    (gcap.iMasterStream == -1) ? MF_CHECKED : MF_UNCHECKED); <br>    EnableMenuItem((HMENU)wParam, MENU_AUDIOMASTER, <br>!gcap.fCapturing ? MF_ENABLED : MF_GRAYED); <br>    CheckMenuItem((HMENU)wParam, MENU_AUDIOMASTER,  <br>    (gcap.iMasterStream == 1) ? MF_CHECKED : MF_UNCHECKED); <br>    EnableMenuItem((HMENU)wParam, MENU_VIDEOMASTER, <br>!gcap.fCapturing ? MF_ENABLED : MF_GRAYED); <br>    CheckMenuItem((HMENU)wParam, MENU_VIDEOMASTER,  <br>    (gcap.iMasterStream == 0) ? MF_CHECKED : MF_UNCHECKED); <br> <br>    // can't select a new capture device when capturing <br>    EnableMenuItem((HMENU)wParam, MENU_VDEVICE0, <br>!gcap.fCapturing ? MF_ENABLED : MF_GRAYED); <br>    EnableMenuItem((HMENU)wParam, MENU_VDEVICE1, <br>!gcap.fCapturing ? MF_ENABLED : MF_GRAYED); <br>    EnableMenuItem((HMENU)wParam, MENU_VDEVICE2, <br>!gcap.fCapturing ? MF_ENABLED : MF_GRAYED); <br>    EnableMenuItem((HMENU)wParam, MENU_VDEVICE3, <br>!gcap.fCapturing ? MF_ENABLED : MF_GRAYED); <br>    EnableMenuItem((HMENU)wParam, MENU_VDEVICE4, <br>!gcap.fCapturing ? MF_ENABLED : MF_GRAYED); <br>    EnableMenuItem((HMENU)wParam, MENU_VDEVICE5, <br>!gcap.fCapturing ? MF_ENABLED : MF_GRAYED); <br>    EnableMenuItem((HMENU)wParam, MENU_VDEVICE6, <br>!gcap.fCapturing ? MF_ENABLED : MF_GRAYED); <br>    EnableMenuItem((HMENU)wParam, MENU_VDEVICE7, <br>!gcap.fCapturing ? MF_ENABLED : MF_GRAYED); <br>    EnableMenuItem((HMENU)wParam, MENU_VDEVICE8, <br>!gcap.fCapturing ? MF_ENABLED : MF_GRAYED); <br>    EnableMenuItem((HMENU)wParam, MENU_VDEVICE9, <br>!gcap.fCapturing ? MF_ENABLED : MF_GRAYED); <br>    EnableMenuItem((HMENU)wParam, MENU_ADEVICE0, <br>!gcap.fCapturing ? MF_ENABLED : MF_GRAYED); <br>    EnableMenuItem((HMENU)wParam, MENU_ADEVICE1, <br>!gcap.fCapturing ? MF_ENABLED : MF_GRAYED); <br>    EnableMenuItem((HMENU)wParam, MENU_ADEVICE2, <br>!gcap.fCapturing ? MF_ENABLED : MF_GRAYED); <br>    EnableMenuItem((HMENU)wParam, MENU_ADEVICE3, <br>!gcap.fCapturing ? MF_ENABLED : MF_GRAYED); <br>    EnableMenuItem((HMENU)wParam, MENU_ADEVICE4, <br>!gcap.fCapturing ? MF_ENABLED : MF_GRAYED); <br>    EnableMenuItem((HMENU)wParam, MENU_ADEVICE5, <br>!gcap.fCapturing ? MF_ENABLED : MF_GRAYED); <br>    EnableMenuItem((HMENU)wParam, MENU_ADEVICE6, <br>!gcap.fCapturing ? MF_ENABLED : MF_GRAYED); <br>    EnableMenuItem((HMENU)wParam, MENU_ADEVICE7, <br>!gcap.fCapturing ? MF_ENABLED : MF_GRAYED); <br>    EnableMenuItem((HMENU)wParam, MENU_ADEVICE8, <br>!gcap.fCapturing ? MF_ENABLED : MF_GRAYED); <br>    EnableMenuItem((HMENU)wParam, MENU_ADEVICE9, <br>!gcap.fCapturing ? MF_ENABLED : MF_GRAYED); <br>     <br>    break; <br> <br>// <br>// We're out of here! <br>// <br>case WM_DESTROY: <br>    DbgTerminate(); <br>    CoUninitialize(); <br>    PostQuitMessage(0); <br>    break; <br> <br>// <br>// <br>case WM_CLOSE: <br>    StopPreview(); <br>    StopCapture(); <br>    TearDownGraph(); <br>    FreeCapFilters(); <br>    // store current settings in win.ini for next time <br>    WriteProfileString("annie", "CaptureFile", gcap.szCaptureFile); <br>    char ach[10]; <br>    wsprintf(ach, "%d", gcap.iVideoDevice); <br>    WriteProfileString("annie", "VideoDevice", ach); <br>    wsprintf(ach, "%d", gcap.iAudioDevice); <br>    WriteProfileString("annie", "AudioDevice", ach); <br>    wsprintf(ach, "%d", (int)(10000000 / gcap.FrameRate)); <br>    WriteProfileString("annie", "FrameRate", ach); <br>    wsprintf(ach, "%d", gcap.fCapAudio); <br>    WriteProfileString("annie", "CaptureAudio", ach); <br>    wsprintf(ach, "%d", gcap.fWantPreview); <br>    WriteProfileString("annie", "WantPreview", ach); <br>    wsprintf(ach, "%d", gcap.iMasterStream); <br>    WriteProfileString("annie", "MasterStream", ach); <br>    break; <br> <br>case WM_ERASEBKGND: <br>    break; <br> <br>// ESC will stop capture <br>case WM_KEYDOWN: <br>    if ((GetAsyncKeyState(VK_ESCAPE) &amp; 0x01) &amp;&amp; <br>gcap.fCapturing) <br>StopCapture(); <br>if (gcap.fWantPreview) { <br>    BuildPreviewGraph(); <br>    StartPreview(); <br>} <br>    break; <br> <br>case WM_PAINT: <br>    hdc = BeginPaint(hwnd,&amp;ps); <br> <br>    // nothing to do <br> <br>    EndPaint(hwnd,&amp;ps); <br>    break; <br> <br>case WM_TIMER: <br>    // update our status bar with #captured, #dropped <br>    UpdateStatus(FALSE); <br> <br>    // is our time limit up? <br>    if (gcap.fUseTimeLimit) { <br>if ((timeGetTime() - gcap.lCapStartTime) / 1000 &gt;= <br>gcap.dwTimeLimit) { <br>    StopCapture(); <br>    if (gcap.fWantPreview) { <br>BuildPreviewGraph(); <br>StartPreview(); <br>    } <br>} <br>    } <br>    break; <br> <br>case WM_SIZE: <br>    // make the preview window fit inside our window, taking up <br>    // all of our client area except for the status window at the <br>    // bottom <br>    GetClientRect(ghwndApp, &amp;rc); <br>    cxBorder = GetSystemMetrics(SM_CXBORDER); <br>    cyBorder = GetSystemMetrics(SM_CYBORDER); <br>    cy = statusGetHeight() + cyBorder; <br>    MoveWindow(ghwndStatus, -cxBorder, rc.bottom - cy, <br>rc.right + (2 * cxBorder), cy + cyBorder, TRUE); <br>    rc.bottom -= cy; <br>    // this is the video renderer window showing the preview <br>    if (gcap.pVW) <br>gcap.pVW-&gt;SetWindowPosition(0, 0, rc.right, rc.bottom); <br>    break; <br> <br>case WM_FGNOTIFY: <br>    // uh-oh, something went wrong while capturing - the filtergraph <br>    // will send us events like EC_COMPLETE, EC_USERABORT and the one <br>    // we care about, EC_ERRORABORT. <br>    if (gcap.pME &amp;&amp; gcap.fCapturing) { <br>    LONG event, l1, l2; <br>    while (gcap.pME-&gt;GetEvent(&amp;event, &amp;l1, &amp;l2, 0) == S_OK) { <br>if (event == EC_ERRORABORT) { <br>    // pME will go away in BuildPreviewGraph <br>    gcap.pME-&gt;FreeEventParams(event, l1, l2); <br>    StopCapture(); <br>    if (gcap.fWantPreview) { <br>BuildPreviewGraph(); <br>StartPreview(); <br>    } <br>    ErrMsg("ERROR during capture - disk possibly full"); <br>    break; <br>} <br>gcap.pME-&gt;FreeEventParams(event, l1, l2); <br>    } <br>    } <br>    break; <br> <br>    } <br>    return DefWindowProc(hwnd,msg,wParam,lParam); <br>} <br> <br> <br>// Make a graph builder object we can use for capture graph building <br>// <br>BOOL MakeBuilder() <br>{ <br>    // we have one already <br>    if (gcap.pBuilder) <br>return TRUE; <br> <br>    HRESULT hr = CoCreateInstance((REFCLSID)CLSID_CaptureGraphBuilder, <br>NULL, CLSCTX_INPROC, (REFIID)IID_ICaptureGraphBuilder, <br>(void **)&amp;gcap.pBuilder); <br>    return (hr == NOERROR) ? TRUE : FALSE; <br>} <br> <br> <br>// Make a graph object we can use for capture graph building <br>// <br>BOOL MakeGraph() <br>{ <br>    // we have one already <br>    if (gcap.pFg) <br>return TRUE; <br> <br>    HRESULT hr = CoCreateInstance(CLSID_FilterGraph, NULL, CLSCTX_INPROC, <br>       IID_IGraphBuilder, (LPVOID *)&amp;gcap.pFg); <br>    return (hr == NOERROR) ? TRUE : FALSE; <br>} <br> <br> <br>// make sure the preview window inside our window is as big as the <br>// dimensions of captured video, or some capture cards won't show a preview. <br>// (Also, it helps people tell what size video they're capturing) <br>// We will resize our app's window big enough so that once the status bar <br>// is positioned at the bottom there will be enough room for the preview <br>// window to be w x h <br>// <br>void ResizeWindow(int w, int h) <br>{ <br>    RECT rcW, rcC; <br>    int xExtra, yExtra; <br>    int cyBorder = GetSystemMetrics(SM_CYBORDER); <br> <br>    GetWindowRect(ghwndApp, &amp;rcW); <br>    GetClientRect(ghwndApp, &amp;rcC); <br>    xExtra = rcW.right - rcW.left - rcC.right; <br>    yExtra = rcW.bottom - rcW.top - rcC.bottom + cyBorder + statusGetHeight(); <br>     <br>    rcC.right = w; <br>    rcC.bottom = h; <br>    SetWindowPos(ghwndApp, NULL, 0, 0, rcC.right + xExtra, <br>rcC.bottom + yExtra, SWP_NOZORDER | SWP_NOMOVE); <br>} <br> <br> <br>// Free all the reference counts we have so the graph can go away <br>// <br>void TearDownGraph() <br>{ <br>    if (gcap.pBuilder) <br>gcap.pBuilder-&gt;Release(); <br>    gcap.pBuilder = NULL; <br>    if (gcap.pSink) <br>gcap.pSink-&gt;Release(); <br>    gcap.pSink = NULL; <br>    if (gcap.pConfigAviMux) <br>gcap.pConfigAviMux-&gt;Release(); <br>    gcap.pConfigAviMux = NULL; <br>    if (gcap.pRender) <br>gcap.pRender-&gt;Release(); <br>    gcap.pRender = NULL; <br>    if (gcap.pVW) <br>gcap.pVW-&gt;Release(); <br>    gcap.pVW = NULL; <br>    if (gcap.pME) <br>gcap.pME-&gt;Release(); <br>    gcap.pME = NULL; <br>    if (gcap.pFg) <br>gcap.pFg-&gt;Release(); <br>    gcap.pFg = NULL; <br>    gcap.fCaptureGraphBuilt = FALSE; <br>    gcap.fPreviewGraphBuilt = FALSE; <br>} <br> <br> <br>// create the capture filters.  We need to talk to the video capture filter <br>// to bring up the format, source and display dialogs <br>// <br>BOOL InitCapFilters() <br>{ <br>    HRESULT hr; <br>    BOOL f; <br>    UINT uIndex = 0; <br> <br>    f = MakeBuilder(); <br>    if (!f) { <br>ErrMsg("Cannot instantiate graph builder"); <br>return FALSE; <br>    } <br> <br>// <br>// First, we need a Video Capture filter, and some interfaces <br>// <br> <br>    // we already have a video capture filter <br>    if (gcap.pVCap) <br>goto MakeAudio; <br> <br>    // !!! There's got to be a way to cache these from building the menu <br>    // Enumerate all the video devices.  We want #gcap.iVideoDevice <br>    ICreateDevEnum *pCreateDevEnum; <br>    hr = CoCreateInstance(CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER, <br>  IID_ICreateDevEnum, (void**)&amp;pCreateDevEnum); <br>    if (hr != NOERROR) <br>return FALSE; <br>    IEnumMoniker *pEm; <br>    hr = pCreateDevEnum-&gt;CreateClassEnumerator(CLSID_VideoInputDeviceCategory, <br>&amp;pEm, 0); <br>    pCreateDevEnum-&gt;Release(); <br>    if (hr != NOERROR) <br>return FALSE; <br>    pEm-&gt;Reset(); <br>    ULONG cFetched; <br>    IMoniker *pM; <br>    gcap.pVCap = NULL; <br>    while(hr = pEm-&gt;Next(1, &amp;pM, &amp;cFetched), hr==S_OK) <br>    { <br>// this is the one we want.  Get its name, and instantiate it. <br>if ((int)uIndex == gcap.iVideoDevice) { <br>    IPropertyBag *pBag; <br>    gcap.achFriendlyName[0] = 0; <br>    hr = pM-&gt;BindToStorage(0, 0, IID_IPropertyBag, (void **)&amp;pBag); <br>    if(SUCCEEDED(hr)) { <br>VARIANT var; <br>var.vt = VT_BSTR; <br>hr = pBag-&gt;Read(L"FriendlyName", &amp;var, NULL); <br>if (hr == NOERROR) { <br>    WideCharToMultiByte(CP_ACP, 0, var.bstrVal, -1, <br>gcap.achFriendlyName, 80, NULL, NULL); <br>    SysFreeString(var.bstrVal); <br>} <br>pBag-&gt;Release(); <br>    } <br>    hr = pM-&gt;BindToObject(0, 0, IID_IBaseFilter, (void**)&amp;gcap.pVCap); <br>    pM-&gt;Release(); <br>    break; <br>} <br>pM-&gt;Release(); <br>uIndex++; <br>    } <br>    pEm-&gt;Release(); <br>    if (gcap.pVCap == NULL) { <br>ErrMsg("Error %x: Cannot create video capture filter", hr); <br>goto InitCapFiltersFail; <br>    } <br> <br>    // we use this interface to get the name of the driver <br>    // Don't worry if it doesn't work:  This interface may not be available <br>    // until the pin is connected, or it may not be available at all. <br>    hr = gcap.pBuilder-&gt;FindInterface(&amp;PIN_CATEGORY_CAPTURE, gcap.pVCap, <br>IID_IAMVideoCompression, (void **)&amp;gcap.pVC); <br> <br>    // !!! What if this interface isn't supported? <br>    // we use this interface to set the frame rate and get the capture size <br>    hr = gcap.pBuilder-&gt;FindInterface(&amp;PIN_CATEGORY_CAPTURE, gcap.pVCap, <br>IID_IAMStreamConfig, (void **)&amp;gcap.pVSC); <br>    if (hr != NOERROR) { <br>ErrMsg("Error %x: Cannot find VCapture:IAMStreamConfig", hr); <br>    } else { <br>AM_MEDIA_TYPE *pmt; <br>hr = gcap.pVSC-&gt;GetFormat(&amp;pmt);        // current capture format <br>if (hr == NOERROR) { <br>    // resize our window to the new capture size <br>    ResizeWindow(HEADER(pmt-&gt;pbFormat)-&gt;biWidth, <br>HEADER(pmt-&gt;pbFormat)-&gt;biHeight); <br>    DeleteMediaType(pmt); <br>} <br>    } <br> <br>    // we use this interface to bring up the 3 dialogs <br>    // NOTE:  Only the VfW capture filter supports this.  This app only brings <br>    // up dialogs for legacy VfW capture drivers, since only those have dialogs <br>    hr = gcap.pBuilder-&gt;FindInterface(&amp;PIN_CATEGORY_CAPTURE, gcap.pVCap, <br>IID_IAMVfwCaptureDialogs, (void **)&amp;gcap.pDlg); <br> <br>MakeAudio: <br> <br>    // we have a filter made already <br>    if (gcap.pACap != NULL) <br>return TRUE; <br> <br>// <br>// We want an audio capture filter and some interfaces <br>// <br> <br>    // !!! There's got to be a way to cache these from building the menu <br>    // Enumerate all the audio devices.  We want #gcap.iAudioDevice <br>    hr = CoCreateInstance(CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER, <br>  IID_ICreateDevEnum, (void**)&amp;pCreateDevEnum); <br>    if (hr != NOERROR) <br>return FALSE; <br>    uIndex = 0; <br>    hr = pCreateDevEnum-&gt;CreateClassEnumerator(CLSID_AudioInputDeviceCategory, <br>&amp;pEm, 0); <br>    pCreateDevEnum-&gt;Release(); <br>    if (hr != NOERROR) { <br>gcap.fCapAudio = FALSE; // better not try <br>return FALSE; <br>    } <br>    pEm-&gt;Reset(); <br>    gcap.pACap = NULL; <br>    while(hr = pEm-&gt;Next(1, &amp;pM, &amp;cFetched), hr==S_OK) <br>    { <br>// this is the one we want! <br>if ((int)uIndex == gcap.iAudioDevice) { <br>    hr = pM-&gt;BindToObject(0, 0, IID_IBaseFilter, (void**)&amp;gcap.pACap); <br>    pM-&gt;Release(); <br>    break; <br>} <br>pM-&gt;Release(); <br>uIndex++; <br>    } <br>    pEm-&gt;Release(); <br>    if (gcap.pACap == NULL) { <br>gcap.fCapAudio = FALSE; // better not try <br>ErrMsg("Cannot create audio capture filter"); <br>goto InitCapFiltersFail; <br>    } <br> <br>    // !!! What if this interface isn't supported? <br>    // we use this interface to set the captured wave format <br>    hr = gcap.pBuilder-&gt;FindInterface(&amp;PIN_CATEGORY_CAPTURE, gcap.pACap, <br>IID_IAMStreamConfig, (void **)&amp;gcap.pASC); <br>    if (hr != NOERROR) { <br>    ErrMsg("Cannot find ACapture:IAMStreamConfig"); <br>    } <br> <br>    return TRUE; <br> <br>InitCapFiltersFail: <br>    FreeCapFilters(); <br>    return FALSE; <br>} <br> <br> <br>// all done with the capture filters and the graph builder <br>// <br>void FreeCapFilters() <br>{ <br>    if (gcap.pBuilder) <br>gcap.pBuilder-&gt;Release(); <br>    gcap.pBuilder = NULL; <br>    if (gcap.pVCap) </code></pre>
<p>
</p>
<pre><code>gcap.pVCap-&gt;Release(); <br>    gcap.pVCap = NULL; <br>    if (gcap.pACap) <br>gcap.pACap-&gt;Release(); <br>    gcap.pACap = NULL; <br>    if (gcap.pASC) <br>gcap.pASC-&gt;Release(); <br>    gcap.pASC = NULL; <br>    if (gcap.pVSC) <br>gcap.pVSC-&gt;Release(); <br>    gcap.pVSC = NULL; <br>    if (gcap.pDF) <br>gcap.pDF-&gt;Release(); <br>    gcap.pDF = NULL; <br>    if (gcap.pVC) <br>gcap.pVC-&gt;Release(); <br>    gcap.pVC = NULL; <br>    if (gcap.pDlg) <br>gcap.pDlg-&gt;Release(); <br>    gcap.pDlg = NULL; <br>} <br> <br> <br>// build the capture graph! <br>// <br>BOOL BuildCaptureGraph() <br>{ <br>    int cy, cyBorder; <br>    HRESULT hr; <br>    BOOL f; <br>    AM_MEDIA_TYPE *pmt; <br> <br>    // we have one already <br>    if (gcap.fCaptureGraphBuilt) <br>return TRUE; <br> <br>    // No rebuilding while we're running <br>    if (gcap.fCapturing || gcap.fPreviewing) <br>return FALSE; <br> <br>    // We don't have the necessary capture filters <br>    if (gcap.pVCap == NULL) <br>return FALSE; <br>    if (gcap.pACap == NULL &amp;&amp; gcap.fCapAudio) <br>return FALSE; <br> <br>    // no capture file name yet... we need one first <br>    if (gcap.szCaptureFile[0] == 0) { <br>f = SetCaptureFile(ghwndApp); <br>if (!f) <br>    return f; <br>    } <br> <br>    // we already have another graph built... tear down the old one <br>    if (gcap.fPreviewGraphBuilt) <br>TearDownGraph(); <br> <br>    f = MakeBuilder(); <br>    if (!f) { <br>ErrMsg("Cannot instantiate graph builder"); <br>return FALSE; <br>    } <br> <br>// <br>// We need a rendering section that will write the capture file out in AVI <br>// file format <br>// <br> <br>    WCHAR wach[_MAX_PATH]; <br>    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, gcap.szCaptureFile, -1, wach, <br>_MAX_PATH); <br>    GUID guid = MEDIASUBTYPE_Avi; <br>    hr = gcap.pBuilder-&gt;SetOutputFileName(&amp;guid, wach, &amp;gcap.pRender, <br>&amp;gcap.pSink); <br>    if (hr != NOERROR) { <br>ErrMsg("Cannot set output file"); <br>goto SetupCaptureFail; <br>    } <br> <br>// Now tell the AVIMUX to write out AVI files that old apps can read properly. <br>// If we don't, most apps won't be able to tell where the keyframes are, <br>// slowing down editing considerably <br>// Doing this will cause one seek (over the area the index will go) when <br>// you capture past 1 Gig, but that's no big deal. <br>// NOTE: This is on by default, so it's not necessary to turn it on <br> <br>// Also, set the proper MASTER STREAM <br> <br>    hr = gcap.pRender-&gt;QueryInterface(IID_IConfigAviMux, <br>(void **)&amp;gcap.pConfigAviMux); <br>    if (hr == NOERROR &amp;&amp; gcap.pConfigAviMux) { <br>gcap.pConfigAviMux-&gt;SetOutputCompatibilityIndex(TRUE); <br>if (gcap.fCapAudio) { <br>    hr = gcap.pConfigAviMux-&gt;SetMasterStream(gcap.iMasterStream); <br>    if (hr != NOERROR) <br>ErrMsg("SetMasterStream failed!"); <br>} <br>    } <br> <br>// <br>// The graph builder created a filtergraph to do that.  Find out what it is, <br>// and put the video capture filter in the graph too. <br>// <br> <br>    hr = gcap.pBuilder-&gt;GetFiltergraph(&amp;gcap.pFg); <br>    if (hr != NOERROR) { <br>ErrMsg("Cannot get filtergraph"); <br>goto SetupCaptureFail; <br>    } <br> <br>    hr = gcap.pFg-&gt;AddFilter(gcap.pVCap, NULL); <br>    if (hr != NOERROR) { <br>ErrMsg("Cannot add vidcap to filtergraph"); <br>goto SetupCaptureFail; <br>    } <br> <br>// <br>// Now, add the audio capture filter to the graph? <br>// <br> <br>    if (gcap.fCapAudio) { <br>hr = gcap.pFg-&gt;AddFilter(gcap.pACap, NULL); <br>if (hr != NOERROR) { <br>    ErrMsg("Cannot add audcap to filtergraph"); <br>    goto SetupCaptureFail; <br>} <br>    } <br> <br>// <br>// Render the video capture and preview pins - we may not have preview, so <br>// don't worry if it doesn't work <br>// <br> <br>    hr = gcap.pBuilder-&gt;RenderStream(&amp;PIN_CATEGORY_CAPTURE, gcap.pVCap, <br>NULL, gcap.pRender); <br>    if (hr != NOERROR) { <br>ErrMsg("Cannot render video capture stream"); <br>goto SetupCaptureFail; <br>    } <br> <br>    hr = gcap.pBuilder-&gt;RenderStream(&amp;PIN_CATEGORY_PREVIEW, gcap.pVCap, <br>NULL, NULL); <br> <br>// <br>// Render the audio capture pin? <br>// <br> <br>    if (gcap.fCapAudio) { <br>hr = gcap.pBuilder-&gt;RenderStream(&amp;PIN_CATEGORY_CAPTURE, <br>gcap.pACap, NULL, gcap.pRender); <br>if (hr != NOERROR) { <br>    ErrMsg("Cannot render audio capture stream"); <br>    goto SetupCaptureFail; <br>} <br>    } <br> <br>// <br>// Get the preview window to be a child of our app's window <br>// <br> <br>    // this will go through a possible decoder, find the video renderer it's <br>    // connected to, and get the IVideoWindow interface on it <br>    hr = gcap.pBuilder-&gt;FindInterface(&amp;PIN_CATEGORY_PREVIEW, gcap.pVCap, <br>IID_IVideoWindow, (void **)&amp;gcap.pVW); <br>    if (hr != NOERROR) { <br>ErrMsg("This graph cannot preview"); <br>    } else { <br>RECT rc; <br>gcap.pVW-&gt;put_Owner((long)ghwndApp);    // We own the window now <br>gcap.pVW-&gt;put_WindowStyle(WS_CHILD);    // you are now a child <br>// give the preview window all our space but where the status bar is <br>GetClientRect(ghwndApp, &amp;rc); <br>cyBorder = GetSystemMetrics(SM_CYBORDER); <br>cy = statusGetHeight() + cyBorder; <br>rc.bottom -= cy; <br>gcap.pVW-&gt;SetWindowPosition(0, 0, rc.right, rc.bottom); // be this big <br>gcap.pVW-&gt;put_Visible(OATRUE); <br>    } <br> <br>    // now tell it what frame rate to capture at.  Just find the format it <br>    // is capturing with, and leave everything alone but change the frame rate <br>    hr = E_FAIL; <br>    if (gcap.pVSC) { <br>hr = gcap.pVSC-&gt;GetFormat(&amp;pmt); <br>if (hr == NOERROR) { <br>    VIDEOINFOHEADER *pvi = (VIDEOINFOHEADER *)pmt-&gt;pbFormat; <br>    pvi-&gt;AvgTimePerFrame = (LONGLONG)(10000000 / gcap.FrameRate); <br>    hr = gcap.pVSC-&gt;SetFormat(pmt); <br>    DeleteMediaType(pmt); <br>} <br>    } <br>    if (hr != NOERROR) <br>ErrMsg("Cannot set frame rate for capture"); <br> <br>    // now ask the filtergraph to tell us when something is completed or aborted <br>    // (EC_COMPLETE, EC_USERABORT, EC_ERRORABORT).  This is how we will find out <br>    // if the disk gets full while capturing <br>    hr = gcap.pFg-&gt;QueryInterface(IID_IMediaEventEx, (void **)&amp;gcap.pME); <br>    if (hr == NOERROR) { <br>gcap.pME-&gt;SetNotifyWindow((LONG)ghwndApp, WM_FGNOTIFY, 0); <br>    } <br> <br>// All done. <br> <br>    // potential debug output - what the graph looks like <br>    // DumpGraph(gcap.pFg, 1); <br> <br>    gcap.fCaptureGraphBuilt = TRUE; <br>    return TRUE; <br> <br>SetupCaptureFail: <br>    TearDownGraph(); <br>    return FALSE; <br>} <br> <br> <br> <br>// build the preview graph! <br>// <br>// !!! PLEASE NOTE !!!  Some new WDM devices have totally separate capture <br>// and preview settings.  An application that wishes to preview and then  <br>// capture may have to set the preview pin format using IAMStreamConfig on the <br>// preview pin, and then again on the capture pin to capture with that format. <br>// In this sample app, there is a separate page to set the settings on the  <br>// capture pin and one for the preview pin.  To avoid the user <br>// having to enter the same settings in 2 dialog boxes, an app can have its own <br>// UI for choosing a format (the possible formats can be enumerated using <br>// IAMStreamConfig) and then the app can programmatically call IAMStreamConfig <br>// to set the format on both pins. <br>// <br>BOOL BuildPreviewGraph() <br>{ <br>    int cy, cyBorder; <br>    HRESULT hr; <br>    BOOL f; <br>    AM_MEDIA_TYPE *pmt; <br>    BOOL fPreviewUsingCapturePin = FALSE; <br> <br>    // we have one already <br>    if (gcap.fPreviewGraphBuilt) <br>return TRUE; <br> <br>    // No rebuilding while we're running <br>    if (gcap.fCapturing || gcap.fPreviewing) <br>return FALSE; <br> <br>    // We don't have the necessary capture filters <br>    if (gcap.pVCap == NULL) <br>return FALSE; <br>    if (gcap.pACap == NULL &amp;&amp; gcap.fCapAudio) <br>return FALSE; <br> <br>    // we already have another graph built... tear down the old one <br>    if (gcap.fCaptureGraphBuilt) <br>TearDownGraph(); <br> <br>    f = MakeBuilder(); <br>    if (!f) { <br>ErrMsg("Cannot instantiate graph builder"); <br>return FALSE; <br>    } <br> <br>// <br>// make a filtergraph, give it to the graph builder and put the capture filter <br>// in the graph <br>// <br> <br>    f = MakeGraph(); <br>    if (!f) { <br>ErrMsg("Cannot instantiate filtergraph"); <br>goto SetupPreviewFail; <br>    } <br>    hr = gcap.pBuilder-&gt;SetFiltergraph(gcap.pFg); <br>    if (hr != NOERROR) { <br>ErrMsg("Cannot give graph to builder"); <br>goto SetupPreviewFail; <br>    } <br>     <br> <br>    hr = gcap.pFg-&gt;AddFilter(gcap.pVCap, NULL); <br>    if (hr != NOERROR) { <br>ErrMsg("Error %x: Cannot add vidcap to filtergraph", hr); <br>goto SetupPreviewFail; <br>    } <br> <br>// <br>// Render the preview pin - it may not work if there is no preview pin <br>// <br>// !!! So use the capture pin - what about latency/buffer issues? <br> <br>    hr = gcap.pBuilder-&gt;RenderStream(&amp;PIN_CATEGORY_PREVIEW, gcap.pVCap, <br>NULL, NULL); <br>    if (hr != S_OK) { <br>gcap.pBuilder-&gt;RenderStream(&amp;PIN_CATEGORY_CAPTURE, gcap.pVCap, <br>NULL, NULL); <br>fPreviewUsingCapturePin = TRUE; <br> <br>// !!! Since we are using the capture pin to preview, we should probably <br>// make the graph have no clock, so that the time stamps on the captured <br>// frames don't make the renderer drop any frames. <br> <br>    } <br> <br>// <br>// Get the preview window to be a child of our app's window <br>// <br> <br>    // this will go through a possible decoder, find the video renderer it's <br>    // connected to, and get the IVideoWindow interface on it <br>    hr = gcap.pBuilder-&gt;FindInterface( <br>fPreviewUsingCapturePin ? &amp;PIN_CATEGORY_CAPTURE : <br>&amp;PIN_CATEGORY_PREVIEW, <br>gcap.pVCap, IID_IVideoWindow, (void **)&amp;gcap.pVW); <br>    if (hr != NOERROR) { <br>ErrMsg("This graph cannot preview properly"); <br>    } else { <br>RECT rc; <br>gcap.pVW-&gt;put_Owner((long)ghwndApp);    // We own the window now <br>gcap.pVW-&gt;put_WindowStyle(WS_CHILD);    // you are now a child <br>// give the preview window all our space but where the status bar is <br>GetClientRect(ghwndApp, &amp;rc); <br>cyBorder = GetSystemMetrics(SM_CYBORDER); <br>cy = statusGetHeight() + cyBorder; <br>rc.bottom -= cy; <br>gcap.pVW-&gt;SetWindowPosition(0, 0, rc.right, rc.bottom); // be this big <br>gcap.pVW-&gt;put_Visible(OATRUE); <br>    } <br> <br>    // now tell it what frame rate to capture at.  Just find the format it <br>    // is capturing with, and leave everything alone but change the frame rate <br>    // No big deal if it fails.  It's just for preview <br>    if (gcap.pVSC) { <br>hr = gcap.pVSC-&gt;GetFormat(&amp;pmt); <br>if (hr == NOERROR) { <br>    VIDEOINFOHEADER *pvi = (VIDEOINFOHEADER *)pmt-&gt;pbFormat; <br>    pvi-&gt;AvgTimePerFrame = (LONGLONG)(10000000 / gcap.FrameRate); <br>    gcap.pVSC-&gt;SetFormat(pmt); <br>    DeleteMediaType(pmt); <br>} <br>    } <br> <br>// All done. <br> <br>    // potential debug output - what the graph looks like <br>    // DumpGraph(gcap.pFg, 1); <br> <br>    gcap.fPreviewGraphBuilt = TRUE; <br>    return TRUE; <br> <br>SetupPreviewFail: <br>    TearDownGraph(); <br>    return FALSE; <br>} <br> <br> <br>// Start previewing <br>// <br>BOOL StartPreview() <br>{ <br>    BOOL f = TRUE; <br> <br>    // way ahead of you <br>    if (gcap.fPreviewing) <br>return TRUE; <br> <br>    if (!gcap.fPreviewGraphBuilt) <br>return FALSE; <br> <br>    // run the graph <br>    IMediaControl *pMC = NULL; <br>    HRESULT hr = gcap.pFg-&gt;QueryInterface(IID_IMediaControl, (void **)&amp;pMC); <br>    if (SUCCEEDED(hr)) { <br>hr = pMC-&gt;Run(); <br>if (FAILED(hr)) { <br>    // stop parts that ran <br>    pMC-&gt;Stop(); <br>} <br>pMC-&gt;Release(); <br>    } <br>    if (FAILED(hr)) { <br>ErrMsg("Error %x: Cannot run preview graph", hr); <br>return FALSE; <br>    } <br> <br>    gcap.fPreviewing = TRUE; <br>    return TRUE; <br>} <br> <br> <br>// stop the preview graph <br>// <br>BOOL StopPreview() <br>{ <br>    // way ahead of you <br>    if (!gcap.fPreviewing) { <br>return FALSE; <br>    } <br> <br>    // stop the graph <br>    IMediaControl *pMC = NULL; <br>    HRESULT hr = gcap.pFg-&gt;QueryInterface(IID_IMediaControl, (void **)&amp;pMC); <br>    if (SUCCEEDED(hr)) { <br>hr = pMC-&gt;Stop(); <br>pMC-&gt;Release(); <br>    } <br>    if (FAILED(hr)) { <br>ErrMsg("Error %x: Cannot stop preview graph", hr); <br>return FALSE; <br>    } <br> <br>    gcap.fPreviewing = FALSE; <br> <br>    // !!! get rid of menu garbage <br>    InvalidateRect(ghwndApp, NULL, TRUE); <br> <br>    return TRUE; <br>} <br> <br> <br>// start the capture graph <br>// <br>BOOL StartCapture() <br>{ <br>    BOOL f, fHasStreamControl; <br>    HRESULT hr; <br> <br>    // way ahead of you <br>    if (gcap.fCapturing) <br>return TRUE; <br> <br>    // or we'll get confused <br>    if (gcap.fPreviewing) <br>StopPreview(); <br> <br>    // or we'll crash <br>    if (!gcap.fCaptureGraphBuilt) <br>return FALSE; <br> <br>    REFERENCE_TIME start = MAX_TIME, stop = MAX_TIME; <br>    // show us a preview first? but don't capture quite yet... <br>    hr = gcap.pBuilder-&gt;ControlStream(&amp;PIN_CATEGORY_PREVIEW, NULL, <br>gcap.fWantPreview ? NULL : &amp;start, <br>gcap.fWantPreview ? &amp;stop : NULL, 0, 0); <br>    if (SUCCEEDED(hr)) <br>hr = gcap.pBuilder-&gt;ControlStream(&amp;PIN_CATEGORY_CAPTURE, NULL, &amp;start, <br>NULL, 0, 0); <br> <br>    // Do we have the ability to control capture and preview separately? <br>    fHasStreamControl = SUCCEEDED(hr); <br> <br>    // prepare to run the graph <br>    IMediaControl *pMC = NULL; <br>    hr = gcap.pFg-&gt;QueryInterface(IID_IMediaControl, (void **)&amp;pMC); <br>    if (FAILED(hr)) { <br>ErrMsg("Error %x: Cannot get IMediaControl", hr); <br>return FALSE; <br>    } <br> <br>    // If we were able to turn preview on yet keep capture off, then we can <br>    // run the graph now for frame accurate start later yet still showing a <br>    // preview.   Otherwise, we can't run the graph yet without capture <br>    // starting too, so we'll pause it so the latency between when they <br>    // press a key and when capture begins is still small (but they won't have <br>    // a preview while they wait to press a key) <br> <br>    if (fHasStreamControl) <br>hr = pMC-&gt;Run(); <br>    else <br>hr = pMC-&gt;Pause(); <br>    if (FAILED(hr)) { <br>// stop parts that started <br>pMC-&gt;Stop(); <br>pMC-&gt;Release(); <br>ErrMsg("Error %x: Cannot start graph", hr); <br>return FALSE; <br>    } <br> <br>    // press a key to start capture <br>    f = DoDialog(ghwndApp, IDD_PressAKeyDialog, (DLGPROC)PressAKeyProc, 0); <br>    if (!f) { <br>pMC-&gt;Stop(); <br>pMC-&gt;Release(); <br>if (gcap.fWantPreview) { <br>    BuildPreviewGraph(); <br>    StartPreview(); <br>} <br>return f; <br>    } <br> <br>    // Start capture NOW! <br>    if (fHasStreamControl) { <br>gcap.pBuilder-&gt;ControlStream(&amp;PIN_CATEGORY_CAPTURE, NULL, NULL, &amp;stop, <br>0, 0); <br>    } else { <br>hr = pMC-&gt;Run(); <br>if (FAILED(hr)) { <br>    // stop parts that started <br>    pMC-&gt;Stop(); <br>    pMC-&gt;Release(); <br>    ErrMsg("Error %x: Cannot run graph", hr); <br>    return FALSE; <br>} <br>    } <br> <br>    pMC-&gt;Release(); <br> <br>    // when did we start capture? <br>    gcap.lCapStartTime = timeGetTime(); <br> <br>    // 30 times a second I want to update my status bar - #captured, #dropped <br>    SetTimer(ghwndApp, 1, 33, NULL); <br> <br>    gcap.fCapturing = TRUE; <br>    return TRUE; <br>} <br> <br> <br>// stop the capture graph <br>// <br>BOOL StopCapture() <br>{ <br>    // way ahead of you <br>    if (!gcap.fCapturing) { <br>return FALSE; <br>    } <br> <br>    // stop the graph <br>    IMediaControl *pMC = NULL; <br>    HRESULT hr = gcap.pFg-&gt;QueryInterface(IID_IMediaControl, (void **)&amp;pMC); <br>    if (SUCCEEDED(hr)) { <br>hr = pMC-&gt;Stop(); <br>pMC-&gt;Release(); <br>    } <br>    if (FAILED(hr)) { <br>ErrMsg("Error %x: Cannot stop graph", hr); <br>return FALSE; <br>    } <br> <br>    // when the graph was stopped <br>    gcap.lCapStopTime = timeGetTime(); <br> <br>    // no more status bar updates <br>    KillTimer(ghwndApp, 1); <br> <br>    // one last time for the final count and all the stats <br>    UpdateStatus(TRUE); <br> <br>    gcap.fCapturing = FALSE; <br> <br>    // !!! get rid of menu garbage <br>    InvalidateRect(ghwndApp, NULL, TRUE); <br> <br>    return TRUE; <br>} <br> <br> <br>// Let's talk about UI for a minute.  There are many programmatic interfaces <br>// you can use to program a capture filter or related filter to capture the <br>// way you want it to.... eg:  IAMStreamConfig, IAMVideoCompression, <br>// IAMCrossbar, IAMTVTuner, IAMTVAudio, IAMAnalogVideoDecoder, IAMCameraControl, <br>// IAMVideoProcAmp, etc. <br>// <br>// But you probably want some UI to let the user play with all these settings. <br>// For new WDM-style capture devices, we offer some default UI you can use. <br>// The code below shows how to bring up all of the dialog boxes supported  <br>// by any capture filters. <br>// <br>// The following code shows you how you can bring up all of the <br>// dialogs supported by a particular object at once on a big page with lots <br>// of thumb tabs.  You do this by starting with an interface on the object that <br>// you want, and using ISpecifyPropertyPages to get the whole list, and <br>// OleCreatePropertyFrame to bring them all up.  This way you will get custom <br>// property pages a filter has, too, that are not one of the standard pages that <br>// you know about.  There are at least 9 objects that may have property pages. <br>// Your app already has 2 of the object pointers, the video capture filter and <br>// the audio capture filter (let's call them pVCap and pACap) <br>// 1.  The video capture filter - pVCap <br>// 2.  The video capture filter's capture pin - get this by calling <br>//     FindInterface(&amp;PIN_CATEGORY_CAPTURE, pVCap, IID_IPin, &amp;pX); <br>// 3.  The video capture filter's preview pin - get this by calling <br>//     FindInterface(&amp;PIN_CATEGORY_PREVIEW, pVCap, IID_IPin, &amp;pX); <br>// 4.  The audio capture filter - pACap <br>// 5.  The audio capture filter's capture pin - get this by calling <br>//     FindInterface(&amp;PIN_CATEGORY_CAPTURE, pACap, IID_IPin, &amp;pX); <br>// 6.  The crossbar connected to the video capture filter - get this by calling <br>//     FindInterface(NULL, pVCap, IID_IAMCrossbar, &amp;pX); <br>// 7.  The crossbar connected to the audio capture filter - get this by calling <br>//     FindInterface(NULL, pACap, IID_IAMCrossbar, &amp;pX); <br>//     NOTE:  may be the same as object #6.  Compare IUnknowns to find out. <br>// 8.  The TV Tuner connected to the video capture filter - get this by calling <br>//     FindInterface(NULL, pVCap, IID_IAMTVTuner, &amp;pX); <br>// 9.  The TV Audio connected to the audio capture filter - get this by calling <br>//     FindInterface(NULL, pACap, IID_IAMTVAudio, &amp;pX); <br>// <br>// Your last choice for UI is to make your own pages, and use the results of  <br>// your custom page to call the interfaces programmatically. <br> <br> <br>void MakeMenuOptions() <br>{ <br>    HRESULT hr; <br>    HMENU hMenuSub = GetSubMenu(GetMenu(ghwndApp), 2); // Options menu <br> <br>    // remove any old choices from the last device <br>    RemoveMenu(hMenuSub, 4, MF_BYPOSITION); <br>    RemoveMenu(hMenuSub, 4, MF_BYPOSITION); <br>    RemoveMenu(hMenuSub, 4, MF_BYPOSITION); <br>    RemoveMenu(hMenuSub, 4, MF_BYPOSITION); <br>    RemoveMenu(hMenuSub, 4, MF_BYPOSITION); <br>    RemoveMenu(hMenuSub, 4, MF_BYPOSITION); <br>    RemoveMenu(hMenuSub, 4, MF_BYPOSITION); <br>    RemoveMenu(hMenuSub, 4, MF_BYPOSITION); <br>    RemoveMenu(hMenuSub, 4, MF_BYPOSITION); <br>    RemoveMenu(hMenuSub, 4, MF_BYPOSITION); <br> <br>    int zz = 0; <br>    gcap.iFormatDialogPos = -1; <br>    gcap.iSourceDialogPos = -1; <br>    gcap.iDisplayDialogPos = -1; <br>    gcap.iVCapDialogPos = -1; <br>    gcap.iVCrossbarDialogPos = -1; <br>    gcap.iTVTunerDialogPos = -1; <br>    gcap.iACapDialogPos = -1; <br>    gcap.iACrossbarDialogPos = -1; <br>    gcap.iTVAudioDialogPos = -1; <br>    gcap.iVCapCapturePinDialogPos = -1; <br>    gcap.iVCapPreviewPinDialogPos = -1; <br>    gcap.iACapCapturePinDialogPos = -1; <br> <br>    // If this device supports the old legacy UI dialogs, offer them <br> <br>    if (gcap.pDlg &amp;&amp; !gcap.pDlg-&gt;HasDialog(VfwCaptureDialog_Format)) { <br>AppendMenuA(hMenuSub, MF_STRING, MENU_DIALOG0 + zz, "Video Format..."); <br>gcap.iFormatDialogPos = zz++; <br>    } <br>    if (gcap.pDlg &amp;&amp; !gcap.pDlg-&gt;HasDialog(VfwCaptureDialog_Source)) { <br>AppendMenuA(hMenuSub, MF_STRING, MENU_DIALOG0 + zz, "Video Source..."); <br>gcap.iSourceDialogPos = zz++; <br>    } <br>    if (gcap.pDlg &amp;&amp; !gcap.pDlg-&gt;HasDialog(VfwCaptureDialog_Display)) { <br>AppendMenuA(hMenuSub, MF_STRING, MENU_DIALOG0 + zz, "Video Display..."); <br>gcap.iDisplayDialogPos = zz++; <br>    } <br> <br>    // don't bother looking for new property pages if the old ones are supported <br>    // or if we don't have a capture filter <br>    if (gcap.pVCap == NULL || gcap.iFormatDialogPos != -1) <br>return; <br> <br>    // New WDM devices support new UI and new interfaces. <br>    // Your app can use some default property <br>    // pages for UI if you'd like (like we do here) or if you don't like our <br>    // dialog boxes, feel free to make your own and programmatically set  <br>    // the capture options through interfaces like IAMCrossbar, IAMCameraControl <br>    // etc. <br> <br>    // There are 9 objects that might support property pages.  Let's go through <br>    // them. <br> <br>    ISpecifyPropertyPages *pSpec; <br>    CAUUID cauuid; <br> <br>    // 1. the video capture filter itself <br> <br>    hr = gcap.pVCap-&gt;QueryInterface(IID_ISpecifyPropertyPages, (void **)&amp;pSpec); <br>    if (hr == S_OK) { <br>        hr = pSpec-&gt;GetPages(&amp;cauuid); <br>        if (hr == S_OK &amp;&amp; cauuid.cElems &gt; 0) { <br>    AppendMenuA(hMenuSub,MF_STRING,MENU_DIALOG0+zz,"Video Capture Filter..."); <br>    gcap.iVCapDialogPos = zz++; <br>    CoTaskMemFree(cauuid.pElems); <br>} <br>pSpec-&gt;Release(); <br>    } <br> <br>    // 2.  The video capture capture pin <br> <br>    IAMStreamConfig *pSC; <br>    hr = gcap.pBuilder-&gt;FindInterface(&amp;PIN_CATEGORY_CAPTURE, gcap.pVCap, <br>IID_IAMStreamConfig, (void **)&amp;pSC); <br>    if (hr == S_OK) { <br>        hr = pSC-&gt;QueryInterface(IID_ISpecifyPropertyPages, (void **)&amp;pSpec); <br>        if (hr == S_OK) { <br>            hr = pSpec-&gt;GetPages(&amp;cauuid); <br>            if (hr == S_OK &amp;&amp; cauuid.cElems &gt; 0) { <br>        AppendMenuA(hMenuSub,MF_STRING,MENU_DIALOG0+zz,"Video Capture Pin..."); <br>        gcap.iVCapCapturePinDialogPos = zz++; <br>        CoTaskMemFree(cauuid.pElems); <br>    } <br>    pSpec-&gt;Release(); <br>        } <br>pSC-&gt;Release(); <br>    } <br> <br>    // 3.  The video capture preview pin. <br>    // This basically sets the format being previewed.  Typically, you <br>    // want to capture and preview using the SAME format, instead of having to <br>    // enter the same value in 2 dialog boxes.  For a discussion on this, see <br>    // the comment above the MakePreviewGraph function. <br> <br>    hr = gcap.pBuilder-&gt;FindInterface(&amp;PIN_CATEGORY_PREVIEW, gcap.pVCap, <br>IID_IAMStreamConfig, (void **)&amp;pSC); <br>    if (hr == S_OK) { <br>        hr = pSC-&gt;QueryInterface(IID_ISpecifyPropertyPages, (void **)&amp;pSpec); <br>        if (hr == S_OK) { <br>            hr = pSpec-&gt;GetPages(&amp;cauuid); <br>            if (hr == S_OK &amp;&amp; cauuid.cElems &gt; 0) { <br>        AppendMenuA(hMenuSub,MF_STRING,MENU_DIALOG0+zz,"Video Preview Pin..."); <br>        gcap.iVCapPreviewPinDialogPos = zz++; <br>CoTaskMemFree(cauuid.pElems); <br>    } <br>    pSpec-&gt;Release(); <br>        } <br>pSC-&gt;Release(); <br>    } <br> <br>    // 4.  The video crossbar <br> <br>    IAMCrossbar *pX; <br>    hr = gcap.pBuilder-&gt;FindInterface(&amp;PIN_CATEGORY_CAPTURE, gcap.pVCap, <br>IID_IAMCrossbar, (void **)&amp;pX); <br>    if (hr == S_OK) { <br>        hr = pX-&gt;QueryInterface(IID_ISpecifyPropertyPages, (void **)&amp;pSpec); <br>        if (hr == S_OK) { <br>            hr = pSpec-&gt;GetPages(&amp;cauuid); <br>            if (hr == S_OK &amp;&amp; cauuid.cElems &gt; 0) { <br>        AppendMenuA(hMenuSub,MF_STRING,MENU_DIALOG0+zz,"Video Crossbar..."); <br>        gcap.iVCrossbarDialogPos = zz++; <br>CoTaskMemFree(cauuid.pElems); <br>    } <br>    pSpec-&gt;Release(); <br>        } <br> pX-&gt;Release(); <br>    } <br> <br>    // 5.  The TVTuner <br> <br>    IAMTVTuner *pTV; <br>    hr = gcap.pBuilder-&gt;FindInterface(&amp;PIN_CATEGORY_CAPTURE, gcap.pVCap, <br>IID_IAMTVTuner, (void **)&amp;pTV); <br>    if (hr == S_OK) { <br>        hr = pTV-&gt;QueryInterface(IID_ISpecifyPropertyPages, (void **)&amp;pSpec); <br>        if (hr == S_OK) { <br>            hr = pSpec-&gt;GetPages(&amp;cauuid); <br>            if (hr == S_OK &amp;&amp; cauuid.cElems &gt; 0) { <br>        AppendMenuA(hMenuSub,MF_STRING,MENU_DIALOG0+zz,"TV Tuner..."); <br>        gcap.iTVTunerDialogPos = zz++; <br>CoTaskMemFree(cauuid.pElems); <br>    } <br>    pSpec-&gt;Release(); <br>        } <br> pTV-&gt;Release(); <br>    } <br> <br>    // no audio capture, we're done <br>    if (gcap.pACap == NULL) <br>return; <br> <br>    // 6.  The Audio capture filter itself <br> <br>    hr = gcap.pACap-&gt;QueryInterface(IID_ISpecifyPropertyPages, (void **)&amp;pSpec); <br>    if (hr == S_OK) { <br>        hr = pSpec-&gt;GetPages(&amp;cauuid); <br>        if (hr == S_OK &amp;&amp; cauuid.cElems &gt; 0) { <br>            AppendMenuA(hMenuSub,MF_STRING,MENU_DIALOG0+zz,"Audio Capture Filter..."); <br>            gcap.iACapDialogPos = zz++; <br>    CoTaskMemFree(cauuid.pElems); <br>        } <br>        pSpec-&gt;Release(); <br>    } <br> <br>    // 7.  The Audio capture pin <br> <br>    hr = gcap.pBuilder-&gt;FindInterface(&amp;PIN_CATEGORY_CAPTURE, gcap.pACap, <br>IID_IAMStreamConfig, (void **)&amp;pSC); <br>    if (hr == S_OK) { <br>        hr = pSC-&gt;QueryInterface(IID_ISpecifyPropertyPages, (void **)&amp;pSpec); <br>        if (hr == S_OK) { <br>            hr = pSpec-&gt;GetPages(&amp;cauuid); <br>            if (hr == S_OK &amp;&amp; cauuid.cElems &gt; 0) { <br>        AppendMenuA(hMenuSub,MF_STRING,MENU_DIALOG0+zz,"Audio Capture Pin..."); <br>        gcap.iACapCapturePinDialogPos = zz++; <br>CoTaskMemFree(cauuid.pElems); <br>    } <br>    pSpec-&gt;Release(); <br>        } <br> pSC-&gt;Release(); <br>    } <br> <br>    // 8.  The Audio Crossbar, but only if it's different than the video <br>    // crossbar <br> <br>    IAMCrossbar *pXV; <br>    hr = gcap.pBuilder-&gt;FindInterface(&amp;PIN_CATEGORY_CAPTURE, gcap.pACap, <br>IID_IAMCrossbar, (void **)&amp;pX); <br>    if (hr == S_OK) { <br>        BOOL fUse = TRUE; <br>IUnknown *pUnk1, *pUnk2; <br>        hr = gcap.pBuilder-&gt;FindInterface(&amp;PIN_CATEGORY_CAPTURE, gcap.pVCap, <br>IID_IAMCrossbar, (void **)&amp;pXV); <br>        if (hr == S_OK) { <br>    if (pX-&gt;QueryInterface(IID_IUnknown, (void **)&amp;pUnk1) == S_OK) { <br>        if (pXV-&gt;QueryInterface(IID_IUnknown, (void **)&amp;pUnk2) <br>== S_OK) { <br>    if (pUnk1 == pUnk2) <br>        fUse = FALSE; <br>    pUnk2-&gt;Release(); <br>} <br>        pUnk1-&gt;Release(); <br>    } <br>    pXV-&gt;Release(); <br>} <br>hr = E_FAIL; <br>if (fUse) <br>            hr =pX-&gt;QueryInterface(IID_ISpecifyPropertyPages, (void **)&amp;pSpec); <br>        if (hr == S_OK) { <br>            hr = pSpec-&gt;GetPages(&amp;cauuid); <br>            if (hr == S_OK &amp;&amp; cauuid.cElems &gt; 0) { <br>        AppendMenuA(hMenuSub,MF_STRING,MENU_DIALOG0+zz,"Audio Crossbar..."); <br>        gcap.iACrossbarDialogPos = zz++; <br>CoTaskMemFree(cauuid.pElems); <br>    } <br>    pSpec-&gt;Release(); <br>        } <br> pX-&gt;Release(); <br>    } <br> <br>    // 9.  The TV Audio filter <br> <br>    IAMTVAudio *pTVA; <br>    hr = gcap.pBuilder-&gt;FindInterface(&amp;PIN_CATEGORY_CAPTURE, gcap.pACap, <br>IID_IAMTVAudio, (void **)&amp;pTVA); <br>    if (hr == S_OK) { <br>        hr = pTVA-&gt;QueryInterface(IID_ISpecifyPropertyPages, (void **)&amp;pSpec); <br>        if (hr == S_OK) { <br>            hr = pSpec-&gt;GetPages(&amp;cauuid); <br>            if (hr == S_OK &amp;&amp; cauuid.cElems &gt; 0) { <br>        AppendMenuA(hMenuSub,MF_STRING,MENU_DIALOG0+zz,"TV Audio..."); <br>        gcap.iTVAudioDialogPos = zz++; <br>CoTaskMemFree(cauuid.pElems); <br>    } <br>    pSpec-&gt;Release(); <br>        } <br> pTVA-&gt;Release(); <br>    } <br>} <br> <br> <br>// how many captured/dropped so far <br>// <br>void UpdateStatus(BOOL fAllStats) <br>{ <br>    HRESULT hr; <br>    LONG lDropped, lNot, lAvgFrameSize; <br>    char ach[160]; <br> <br>    // we use this interface to get the number of captured and dropped frames <br>    // NOTE:  We cannot query for this interface earlier, as it may not be <br>    // available until the pin is connected <br>    if (!gcap.pDF) { <br>hr = gcap.pBuilder-&gt;FindInterface(&amp;PIN_CATEGORY_CAPTURE, gcap.pVCap, <br>IID_IAMDroppedFrames, (void **)&amp;gcap.pDF); <br>    } <br> <br>    // this filter can't tell us dropped frame info. <br>    if (!gcap.pDF) { <br>statusUpdateStatus(ghwndStatus, <br>"Filter cannot report capture information"); <br>return; <br>    } <br> <br>    hr = gcap.pDF-&gt;GetNumDropped(&amp;lDropped); <br>    if (hr == S_OK) <br>hr = gcap.pDF-&gt;GetNumNotDropped(&amp;lNot); <br>    if (hr != S_OK) <br>return; <br> <br>    if (!fAllStats) { <br>LONG lTime = timeGetTime() - gcap.lCapStartTime; <br>wsprintf(ach, "Captured %d frames (%d dropped) %d.%dsec", lNot, <br>lDropped, lTime / 1000,  <br>lTime / 100 - lTime / 1000 * 10); <br>statusUpdateStatus(ghwndStatus, ach); <br>return; <br>    } <br> <br>    // we want all possible stats, including capture time and actual acheived <br>    // frame rate and data rate (as opposed to what we tried to get).  These <br>    // numbers are an indication that though we dropped frames just now, if we <br>    // chose a data rate and frame rate equal to the numbers I'm about to <br>    // print, we probably wouldn't drop any frames. <br>     <br>    // average size of frame captured <br>    hr = gcap.pDF-&gt;GetAverageFrameSize(&amp;lAvgFrameSize); <br>    if (hr != S_OK) <br>return; <br> <br>    // how long capture lasted <br>    LONG lDurMS = gcap.lCapStopTime - gcap.lCapStartTime; <br>    double flFrame;     // acheived frame rate <br>    LONG lData;         // acheived data rate <br> <br>    if (lDurMS &gt; 0) { <br>flFrame = (double)(LONGLONG)lNot * 1000. / <br>(double)(LONGLONG)lDurMS; <br>lData = (LONG)(LONGLONG)(lNot / (double)(LONGLONG)lDurMS * <br>1000. * (double)(LONGLONG)lAvgFrameSize); <br>    } else { <br>flFrame = 0.; <br>lData = 0; <br>    } <br> <br>    wsprintf(ach, "Captured %d frames in %d.%d sec (%d dropped): %d.%d fps %d.%d Meg/sec", <br>lNot, lDurMS / 1000, lDurMS / 100 - lDurMS / 1000 * 10, <br>lDropped, (int)flFrame, <br>(int)(flFrame * 10.) - (int)flFrame * 10, <br>lData / 1000000, <br>lData / 1000 - (lData / 1000000 * 1000)); <br>    statusUpdateStatus(ghwndStatus, ach); <br>} <br> <br> <br>// Check the devices we're currently using and make filters for them <br>// <br>void ChooseDevices(int idV, int idA) <br>{ <br>    #define VERSIZE 40 <br>    #define DESCSIZE 80 <br>    int versize = VERSIZE; <br>    int descsize = DESCSIZE; <br>    WCHAR wachVer[VERSIZE], wachDesc[DESCSIZE]; <br>    char achStatus[VERSIZE + DESCSIZE + 5], achDesc[DESCSIZE], achVer[VERSIZE]; <br> <br>    if (idV != gcap.iVideoDevice) { <br>// uncheck the old, check the new <br>if (gcap.iVideoDevice &gt;= 0)     // might be uninitialized <br>    CheckMenuItem(GetMenu(ghwndApp), MENU_VDEVICE0 + gcap.iVideoDevice, </code></pre>
<p>
</p>
<pre><code>MF_UNCHECKED);  <br>CheckMenuItem(GetMenu(ghwndApp), MENU_VDEVICE0 + idV, MF_CHECKED);  <br>    } <br> <br>    if (idA != gcap.iAudioDevice) { <br>// uncheck the old, check the new <br>if (gcap.iAudioDevice &gt;= 0)     // might be uninitialized <br>    CheckMenuItem(GetMenu(ghwndApp), MENU_ADEVICE0 + gcap.iAudioDevice, <br>MF_UNCHECKED);  <br>CheckMenuItem(GetMenu(ghwndApp), MENU_ADEVICE0 + idA, MF_CHECKED);  <br>    } <br> <br>    // they chose a new device. rebuild the graphs <br>    if (gcap.iVideoDevice != idV || gcap.iAudioDevice != idA) { <br>gcap.iVideoDevice = idV; <br>gcap.iAudioDevice = idA; <br>if (gcap.fPreviewing) <br>    StopPreview(); <br>if (gcap.fCaptureGraphBuilt || gcap.fPreviewGraphBuilt) <br>    TearDownGraph(); <br>FreeCapFilters(); <br>InitCapFilters(); <br>if (gcap.fWantPreview) { // were we previewing? <br>    BuildPreviewGraph(); <br>    StartPreview(); <br>} <br>MakeMenuOptions();// the UI choices change per device <br>    } <br> <br>    gcap.iVideoDevice = idV; <br>    gcap.iAudioDevice = idA; <br> <br>    // Put the video driver name in the status bar - if the filter supports <br>    // IAMVideoCompression::GetInfo, that's the best way to get the name and <br>    // the version.  Otherwise use the name we got from device enumeration <br>    // as a fallback. <br>    if (gcap.pVC) { <br>HRESULT hr = gcap.pVC-&gt;GetInfo(wachVer, &amp;versize, wachDesc, &amp;descsize, <br>NULL, NULL, NULL, NULL); <br>if (hr == S_OK) { <br>    WideCharToMultiByte(CP_ACP, 0, wachVer, -1, achVer, VERSIZE, NULL, <br>NULL); <br>    WideCharToMultiByte(CP_ACP, 0, wachDesc, -1, achDesc, DESCSIZE, <br>NULL, NULL); <br>    wsprintf(achStatus, "%s - %s", achDesc, achVer); <br>    statusUpdateStatus(ghwndStatus, achStatus); <br>    return; <br>} <br>    } <br>    statusUpdateStatus(ghwndStatus, gcap.achFriendlyName); <br>} <br> <br> <br>// put all installed video and audio devices in the menus <br>// <br>void AddDevicesToMenu() <br>{ <br>    UINT    uIndex = 0; <br>    HMENU   hMenuSub; <br>    HRESULT hr; <br> <br>    hMenuSub = GetSubMenu(GetMenu(ghwndApp), 1);        // Devices menu <br> <br>    // remove the bogus separator <br>    RemoveMenu(hMenuSub, 0, 0); <br> <br>    // enumerate all video capture devices <br>    ICreateDevEnum *pCreateDevEnum; <br>    hr = CoCreateInstance(CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER, <br>  IID_ICreateDevEnum, (void**)&amp;pCreateDevEnum); <br>    if (hr != NOERROR) <br>goto EnumAudio; <br>    IEnumMoniker *pEm; <br>    hr = pCreateDevEnum-&gt;CreateClassEnumerator(CLSID_VideoInputDeviceCategory, <br>&amp;pEm, 0); <br>    pCreateDevEnum-&gt;Release(); <br>    if (hr != NOERROR) { <br>ErrMsg("Sorry, you have no video capture hardware"); <br>goto EnumAudio; <br>    } <br>    pEm-&gt;Reset(); <br>    ULONG cFetched; <br>    IMoniker *pM; <br>    while(hr = pEm-&gt;Next(1, &amp;pM, &amp;cFetched), hr==S_OK) <br>    { <br>IPropertyBag *pBag; <br>hr = pM-&gt;BindToStorage(0, 0, IID_IPropertyBag, (void **)&amp;pBag); <br>if(SUCCEEDED(hr)) { <br>    VARIANT var; <br>    var.vt = VT_BSTR; <br>    hr = pBag-&gt;Read(L"FriendlyName", &amp;var, NULL); <br>    if (hr == NOERROR) { <br>char achName[80]; <br>WideCharToMultiByte(CP_ACP, 0, var.bstrVal, -1, achName, 80, <br>NULL, NULL); <br>AppendMenuA(hMenuSub, MF_STRING, MENU_VDEVICE0 + uIndex, <br>achName); <br>SysFreeString(var.bstrVal); <br>    } <br>    pBag-&gt;Release(); <br>} <br>pM-&gt;Release(); <br>uIndex++; <br>    } <br>    pEm-&gt;Release(); <br> <br>    // separate the video and audio devices <br>    AppendMenuA(hMenuSub, MF_SEPARATOR, 0, NULL); <br> <br>EnumAudio: <br> <br>    // enumerate all audio capture devices <br>    uIndex = 0; <br>    hr = CoCreateInstance(CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER, <br>  IID_ICreateDevEnum, (void**)&amp;pCreateDevEnum); <br>    if (hr != NOERROR) <br>return; <br>    hr = pCreateDevEnum-&gt;CreateClassEnumerator(CLSID_AudioInputDeviceCategory, <br>&amp;pEm, 0); <br>    pCreateDevEnum-&gt;Release(); <br>    if (hr != NOERROR) <br>return; <br>    pEm-&gt;Reset(); <br>    while(hr = pEm-&gt;Next(1, &amp;pM, &amp;cFetched), hr==S_OK) <br>    { <br>IPropertyBag *pBag; <br>hr = pM-&gt;BindToStorage(0, 0, IID_IPropertyBag, (void **)&amp;pBag); <br>if(SUCCEEDED(hr)) { <br>    VARIANT var; <br>    var.vt = VT_BSTR; <br>    hr = pBag-&gt;Read(L"FriendlyName", &amp;var, NULL); <br>    if (hr == NOERROR) { <br>char achName[80]; <br>WideCharToMultiByte(CP_ACP, 0, var.bstrVal, -1, achName, 80, <br>NULL, NULL); <br>AppendMenuA(hMenuSub, MF_STRING, MENU_ADEVICE0 + uIndex, <br>achName); <br>SysFreeString(var.bstrVal); <br>    } <br>    pBag-&gt;Release(); <br>} <br>pM-&gt;Release(); <br>uIndex++; <br>    } <br>    pEm-&gt;Release(); <br>} <br> <br> <br>// let them pick a frame rate <br>// <br>void ChooseFrameRate() <br>{ <br>    HRESULT hr; <br>    double rate = gcap.FrameRate; <br> <br>    DoDialog(ghwndApp, IDD_FrameRateDialog, (DLGPROC)FrameRateProc, 0); <br> <br>    // new frame rate? <br>    if (gcap.FrameRate != rate) { <br>if (gcap.fPreviewing) <br>    StopPreview(); <br>// now tell it what frame rate to capture at.  Just find the format it <br>// is capturing with, and leave everything else alone <br>if (gcap.pVSC) { <br>    AM_MEDIA_TYPE *pmt; <br>    hr = gcap.pVSC-&gt;GetFormat(&amp;pmt); <br>    if (hr == NOERROR) { <br>VIDEOINFOHEADER *pvi = (VIDEOINFOHEADER *)pmt-&gt;pbFormat; <br>pvi-&gt;AvgTimePerFrame = (LONGLONG)(10000000 / gcap.FrameRate); <br>gcap.pVSC-&gt;SetFormat(pmt); <br>DeleteMediaType(pmt); <br>    } <br>} <br>if (gcap.fWantPreview)  // we were previewing <br>    StartPreview(); <br>    } <br>} <br> <br> <br>// let them set a capture time limit <br>// <br>void ChooseTimeLimit() <br>{ <br>    DoDialog(ghwndApp, IDD_TimeLimitDialog, (DLGPROC)TimeLimitProc, 0); <br>} <br> <br> <br>// choose an audio capture format using ACM <br>// <br>void ChooseAudioFormat() <br>{ <br>    ACMFORMATCHOOSE cfmt; <br>    DWORD dwSize; <br>    LPWAVEFORMATEX lpwfx; <br>    AM_MEDIA_TYPE *pmt; <br> <br>    // there's no point if we can't set a new format <br>    if (gcap.pASC == NULL) <br>return; <br> <br>    // What's the largest format size around? <br>    acmMetrics(NULL, ACM_METRIC_MAX_SIZE_FORMAT, &amp;dwSize); <br>    HRESULT hr = gcap.pASC-&gt;GetFormat(&amp;pmt); <br>    if (hr != NOERROR) <br>return; <br>    lpwfx = (LPWAVEFORMATEX)pmt-&gt;pbFormat; <br>    dwSize = max(dwSize, lpwfx-&gt;cbSize + sizeof(WAVEFORMATEX)); <br> <br>    // !!! This doesn't really map to the supported formats of the filter. <br>    // We should be using a property page based on IAMStreamConfig <br> <br>    // Put up a dialog box initialized with the current format <br>    if (lpwfx = (LPWAVEFORMATEX)GlobalAllocPtr(GHND, dwSize)) { <br>CopyMemory(lpwfx, pmt-&gt;pbFormat, pmt-&gt;cbFormat); <br>_fmemset(&amp;cfmt, 0, sizeof(ACMFORMATCHOOSE)); <br>cfmt.cbStruct = sizeof(ACMFORMATCHOOSE); <br>cfmt.fdwStyle = ACMFORMATCHOOSE_STYLEF_INITTOWFXSTRUCT; <br>// show only formats we can capture <br>cfmt.fdwEnum = ACM_FORMATENUMF_HARDWARE | ACM_FORMATENUMF_INPUT; <br>cfmt.hwndOwner = ghwndApp; <br>cfmt.pwfx = lpwfx; <br>cfmt.cbwfx = dwSize; <br> <br>// we chose a new format... so give it to the capture filter <br>if (!acmFormatChoose(&amp;cfmt)) { <br>    if (gcap.fPreviewing) <br>StopPreview();  // can't call IAMStreamConfig::SetFormat <br>// while streaming <br>    ((CMediaType *)pmt)-&gt;SetFormat((LPBYTE)lpwfx, <br>lpwfx-&gt;cbSize + sizeof(WAVEFORMATEX)); <br>    gcap.pASC-&gt;SetFormat(pmt);  // filter will reconnect <br>    if (gcap.fWantPreview) <br>StartPreview(); <br>} <br>GlobalFreePtr(lpwfx) ; <br>    } <br>    DeleteMediaType(pmt); <br>} <br> <br> <br>/*----------------------------------------------------------------------------*\ <br>|    AppCommand() <br>| <br>|    Process all of our WM_COMMAND messages. <br>\*----------------------------------------------------------------------------*/ <br>LONG PASCAL AppCommand (HWND hwnd, unsigned msg, WPARAM wParam, LPARAM lParam) <br>{ <br>    HRESULT hr; <br>    int id = GET_WM_COMMAND_ID(wParam, lParam); <br>    switch(id) <br>    { <br>// <br>// Our about box <br>// <br>case MENU_ABOUT: <br>    DialogBox(ghInstApp, MAKEINTRESOURCE(IDD_ABOUT), hwnd,  <br>(DLGPROC)AboutDlgProc); <br>    break; <br> <br>// <br>// We want out of here! <br>// <br>case MENU_EXIT: <br>    PostMessage(hwnd,WM_CLOSE,0,0L); <br>    break; <br> <br>// choose a capture file <br>// <br>case MENU_SET_CAP_FILE: <br>    SetCaptureFile(hwnd); <br>    break; <br> <br>// pre-allocate the capture file <br>// <br>case MENU_ALLOC_CAP_FILE: <br>    AllocCaptureFile(hwnd); <br>    break; <br> <br>// save the capture file <br>// <br>case MENU_SAVE_CAP_FILE: <br>    SaveCaptureFile(hwnd); <br>    break; <br> <br>// start capturing <br>// <br>case MENU_START_CAP: <br>    if (gcap.fPreviewing) <br>StopPreview(); <br>    if (gcap.fPreviewGraphBuilt) <br>TearDownGraph(); <br>    BuildCaptureGraph(); <br>    StartCapture(); <br>    break; <br> <br>// toggle preview <br>//  <br>case MENU_PREVIEW: <br>    gcap.fWantPreview = !gcap.fWantPreview; <br>    if (gcap.fWantPreview) { <br>BuildPreviewGraph(); <br>StartPreview(); <br>    } else <br>StopPreview(); <br>    break; <br> <br>// stop capture <br>// <br>case MENU_STOP_CAP: <br>    StopCapture(); <br>    if (gcap.fWantPreview) { <br>BuildPreviewGraph(); <br>StartPreview(); <br>    } <br>    break; <br> <br>// select the master stream <br>// <br>case MENU_NOMASTER: <br>    gcap.iMasterStream = -1; <br>    if (gcap.pConfigAviMux) { <br>hr = gcap.pConfigAviMux-&gt;SetMasterStream(gcap.iMasterStream); <br>if (hr != NOERROR) <br>    ErrMsg("SetMasterStream failed!"); <br>    } <br>    break; <br>case MENU_AUDIOMASTER: <br>    gcap.iMasterStream = 1; <br>    if (gcap.pConfigAviMux) { <br>hr = gcap.pConfigAviMux-&gt;SetMasterStream(gcap.iMasterStream); <br>if (hr != NOERROR) <br>    ErrMsg("SetMasterStream failed!"); <br>    } <br>    break; <br>case MENU_VIDEOMASTER: <br>    gcap.iMasterStream = 0; <br>    if (gcap.pConfigAviMux) { <br>hr = gcap.pConfigAviMux-&gt;SetMasterStream(gcap.iMasterStream); <br>if (hr != NOERROR) <br>    ErrMsg("SetMasterStream failed!"); <br>    } <br>    break; <br> <br>// toggle capturing audio <br>case MENU_CAP_AUDIO: <br>    if (gcap.fPreviewing) <br>StopPreview(); <br>    gcap.fCapAudio = !gcap.fCapAudio; <br>    // when we capture we'll need a different graph now <br>    if (gcap.fCaptureGraphBuilt || gcap.fPreviewGraphBuilt) <br>TearDownGraph(); <br>    if (gcap.fWantPreview) { <br>BuildPreviewGraph(); <br>StartPreview(); <br>    } <br>    break; <br> <br>// choose the audio capture format <br>// <br>case MENU_AUDIOFORMAT: <br>    ChooseAudioFormat(); <br>    break; <br> <br>// pick a frame rate <br>// <br>case MENU_FRAMERATE: <br>    ChooseFrameRate(); <br>    break; <br> <br>// pick a time limit <br>// <br>case MENU_TIMELIMIT: <br>    ChooseTimeLimit(); <br>    break; <br> <br>// pick which video capture device to use <br>// pick which video capture device to use <br>// <br>case MENU_VDEVICE0: <br>case MENU_VDEVICE1: <br>case MENU_VDEVICE2: <br>case MENU_VDEVICE3: <br>case MENU_VDEVICE4: <br>case MENU_VDEVICE5: <br>case MENU_VDEVICE6: <br>case MENU_VDEVICE7: <br>case MENU_VDEVICE8: <br>case MENU_VDEVICE9: <br>    ChooseDevices(id - MENU_VDEVICE0, gcap.iAudioDevice); <br>    break; <br> <br>// pick which audio capture device to use <br>// <br>case MENU_ADEVICE0: <br>case MENU_ADEVICE1: <br>case MENU_ADEVICE2: <br>case MENU_ADEVICE3: <br>case MENU_ADEVICE4: <br>case MENU_ADEVICE5: <br>case MENU_ADEVICE6: <br>case MENU_ADEVICE7: <br>case MENU_ADEVICE8: <br>case MENU_ADEVICE9: <br>    ChooseDevices(gcap.iVideoDevice, id - MENU_ADEVICE0); <br>    break; <br> <br>// video format dialog <br>// <br>case MENU_DIALOG0: <br>case MENU_DIALOG1: <br>case MENU_DIALOG2: <br>case MENU_DIALOG3: <br>case MENU_DIALOG4: <br>case MENU_DIALOG5: <br>case MENU_DIALOG6: <br>case MENU_DIALOG7: <br>case MENU_DIALOG8: <br>case MENU_DIALOG9: <br> <br>     // they want the VfW format dialog <br>    if (id - MENU_DIALOG0 == gcap.iFormatDialogPos) { <br>        hr = gcap.pDlg-&gt;ShowDialog(VfwCaptureDialog_Format, ghwndApp); <br>// this dialog might not work while previewing <br>if (hr != S_OK &amp;&amp; gcap.fWantPreview) { <br>    StopPreview(); <br>            gcap.pDlg-&gt;ShowDialog(VfwCaptureDialog_Format, ghwndApp); <br>} <br>        if (gcap.pVSC) { <br>    AM_MEDIA_TYPE *pmt; <br>    // current capture format <br>    hr = gcap.pVSC-&gt;GetFormat(&amp;pmt); <br>    if (hr == NOERROR) { <br>        // resize our window to the new capture size <br>        ResizeWindow(HEADER(pmt-&gt;pbFormat)-&gt;biWidth, <br>HEADER(pmt-&gt;pbFormat)-&gt;biHeight); <br>        DeleteMediaType(pmt); <br>    } <br>        } <br>        if (gcap.fWantPreview) <br>    StartPreview(); <br>    } else if (id - MENU_DIALOG0 == gcap.iSourceDialogPos) { <br>        hr = gcap.pDlg-&gt;ShowDialog(VfwCaptureDialog_Source, ghwndApp); <br>// this dialog might not work while previewing <br>if (hr != S_OK &amp;&amp; gcap.fWantPreview) { <br>    StopPreview(); <br>            gcap.pDlg-&gt;ShowDialog(VfwCaptureDialog_Source, ghwndApp); <br>} <br>        if (gcap.fWantPreview) <br>    StartPreview(); <br>    } else if (id - MENU_DIALOG0 == gcap.iDisplayDialogPos) { <br>        hr = gcap.pDlg-&gt;ShowDialog(VfwCaptureDialog_Display, ghwndApp); <br>// this dialog might not work while previewing <br>if (hr != S_OK &amp;&amp; gcap.fWantPreview) { <br>    StopPreview(); <br>            gcap.pDlg-&gt;ShowDialog(VfwCaptureDialog_Display, ghwndApp); <br>} <br>        if (gcap.fWantPreview) <br>    StartPreview(); <br> <br>    // now the code for the new dialogs <br> <br>    } else if (id - MENU_DIALOG0 == gcap.iVCapDialogPos) { <br>ISpecifyPropertyPages *pSpec; <br>CAUUID cauuid; <br>            hr = gcap.pVCap-&gt;QueryInterface(IID_ISpecifyPropertyPages, <br>(void **)&amp;pSpec); <br>    if (hr == S_OK) { <br>            hr = pSpec-&gt;GetPages(&amp;cauuid); <br>                    hr = OleCreatePropertyFrame(ghwndApp, 30, 30, NULL, 1, <br>                    (IUnknown **)&amp;gcap.pVCap, cauuid.cElems, <br>    (GUID *)cauuid.pElems, 0, 0, NULL); <br>    CoTaskMemFree(cauuid.pElems); <br>    pSpec-&gt;Release(); <br>} <br> <br>    } else if (id - MENU_DIALOG0 == gcap.iVCapCapturePinDialogPos) { <br>    IAMStreamConfig *pSC; <br>    hr = gcap.pBuilder-&gt;FindInterface(&amp;PIN_CATEGORY_CAPTURE, <br>gcap.pVCap, IID_IAMStreamConfig, (void **)&amp;pSC); <br>ISpecifyPropertyPages *pSpec; <br>CAUUID cauuid; <br>            hr = pSC-&gt;QueryInterface(IID_ISpecifyPropertyPages, <br>(void **)&amp;pSpec); <br>    if (hr == S_OK) { <br>            hr = pSpec-&gt;GetPages(&amp;cauuid); <br>                    hr = OleCreatePropertyFrame(ghwndApp, 30, 30, NULL, 1, <br>                    (IUnknown **)&amp;pSC, cauuid.cElems, <br>    (GUID *)cauuid.pElems, 0, 0, NULL); <br>    CoTaskMemFree(cauuid.pElems); <br>    pSpec-&gt;Release(); <br>} <br>pSC-&gt;Release(); <br> <br>    } else if (id - MENU_DIALOG0 == gcap.iVCapPreviewPinDialogPos) { <br>    IAMStreamConfig *pSC; <br>    hr = gcap.pBuilder-&gt;FindInterface(&amp;PIN_CATEGORY_PREVIEW, <br>gcap.pVCap, IID_IAMStreamConfig, (void **)&amp;pSC); <br>ISpecifyPropertyPages *pSpec; <br>CAUUID cauuid; <br>            hr = pSC-&gt;QueryInterface(IID_ISpecifyPropertyPages, <br>(void **)&amp;pSpec); <br>    if (hr == S_OK) { <br>            hr = pSpec-&gt;GetPages(&amp;cauuid); <br>                    hr = OleCreatePropertyFrame(ghwndApp, 30, 30, NULL, 1, <br>                    (IUnknown **)&amp;pSC, cauuid.cElems, <br>    (GUID *)cauuid.pElems, 0, 0, NULL); <br>    CoTaskMemFree(cauuid.pElems); <br>    pSpec-&gt;Release(); <br>} <br>pSC-&gt;Release(); <br> <br>    } else if (id - MENU_DIALOG0 == gcap.iVCrossbarDialogPos) { <br>    IAMCrossbar *pX; <br>    hr = gcap.pBuilder-&gt;FindInterface(&amp;PIN_CATEGORY_CAPTURE, <br>gcap.pVCap, IID_IAMCrossbar, (void **)&amp;pX); <br>ISpecifyPropertyPages *pSpec; <br>CAUUID cauuid; <br>            hr = pX-&gt;QueryInterface(IID_ISpecifyPropertyPages, <br>(void **)&amp;pSpec); <br>    if (hr == S_OK) { <br>            hr = pSpec-&gt;GetPages(&amp;cauuid); <br>                    hr = OleCreatePropertyFrame(ghwndApp, 30, 30, NULL, 1, <br>                    (IUnknown **)&amp;pX, cauuid.cElems, <br>    (GUID *)cauuid.pElems, 0, 0, NULL); <br>    CoTaskMemFree(cauuid.pElems); <br>    pSpec-&gt;Release(); <br>} <br>pX-&gt;Release(); <br> <br>    } else if (id - MENU_DIALOG0 == gcap.iTVTunerDialogPos) { <br>    IAMTVTuner *pTV; <br>    hr = gcap.pBuilder-&gt;FindInterface(&amp;PIN_CATEGORY_CAPTURE, <br>gcap.pVCap, IID_IAMTVTuner, (void **)&amp;pTV); <br>ISpecifyPropertyPages *pSpec; <br>CAUUID cauuid; <br>            hr = pTV-&gt;QueryInterface(IID_ISpecifyPropertyPages, <br>(void **)&amp;pSpec); <br>    if (hr == S_OK) { <br>            hr = pSpec-&gt;GetPages(&amp;cauuid); <br>                    hr = OleCreatePropertyFrame(ghwndApp, 30, 30, NULL, 1, <br>                    (IUnknown **)&amp;pTV, cauuid.cElems, <br>    (GUID *)cauuid.pElems, 0, 0, NULL); <br>    CoTaskMemFree(cauuid.pElems); <br>    pSpec-&gt;Release(); <br>} <br>pTV-&gt;Release(); <br> <br>    } else if (id - MENU_DIALOG0 == gcap.iACapDialogPos) { <br>ISpecifyPropertyPages *pSpec; <br>CAUUID cauuid; <br>            hr = gcap.pACap-&gt;QueryInterface(IID_ISpecifyPropertyPages, <br>(void **)&amp;pSpec); <br>    if (hr == S_OK) { <br>            hr = pSpec-&gt;GetPages(&amp;cauuid); <br>                    hr = OleCreatePropertyFrame(ghwndApp, 30, 30, NULL, 1, <br>                    (IUnknown **)&amp;gcap.pACap, cauuid.cElems, <br>    (GUID *)cauuid.pElems, 0, 0, NULL); <br>    CoTaskMemFree(cauuid.pElems); <br>    pSpec-&gt;Release(); <br>} <br> <br>    } else if (id - MENU_DIALOG0 == gcap.iACapCapturePinDialogPos) { <br>    IAMStreamConfig *pSC; <br>    hr = gcap.pBuilder-&gt;FindInterface(&amp;PIN_CATEGORY_CAPTURE, <br>gcap.pACap, IID_IAMStreamConfig, (void **)&amp;pSC); <br>ISpecifyPropertyPages *pSpec; <br>CAUUID cauuid; <br>            hr = pSC-&gt;QueryInterface(IID_ISpecifyPropertyPages, <br>(void **)&amp;pSpec); <br>    if (hr == S_OK) { <br>            hr = pSpec-&gt;GetPages(&amp;cauuid); <br>                    hr = OleCreatePropertyFrame(ghwndApp, 30, 30, NULL, 1, <br>                    (IUnknown **)&amp;pSC, cauuid.cElems, <br>    (GUID *)cauuid.pElems, 0, 0, NULL); <br>    CoTaskMemFree(cauuid.pElems); <br>    pSpec-&gt;Release(); <br>} <br>pSC-&gt;Release(); <br> <br>    } else if (id - MENU_DIALOG0 == gcap.iACrossbarDialogPos) { <br>    IAMCrossbar *pX; <br>    hr = gcap.pBuilder-&gt;FindInterface(&amp;PIN_CATEGORY_CAPTURE, <br>gcap.pACap, IID_IAMCrossbar, (void **)&amp;pX); <br>ISpecifyPropertyPages *pSpec; <br>CAUUID cauuid; <br>            hr = pX-&gt;QueryInterface(IID_ISpecifyPropertyPages, <br>(void **)&amp;pSpec); <br>    if (hr == S_OK) { <br>            hr = pSpec-&gt;GetPages(&amp;cauuid); <br>                    hr = OleCreatePropertyFrame(ghwndApp, 30, 30, NULL, 1, <br>                    (IUnknown **)&amp;pX, cauuid.cElems, <br>    (GUID *)cauuid.pElems, 0, 0, NULL); <br>    CoTaskMemFree(cauuid.pElems); <br>    pSpec-&gt;Release(); <br>} <br>pX-&gt;Release(); <br> <br>    } else if (id - MENU_DIALOG0 == gcap.iTVAudioDialogPos) { <br>    IAMTVAudio *pTVA; <br>    hr = gcap.pBuilder-&gt;FindInterface(&amp;PIN_CATEGORY_CAPTURE, <br>gcap.pACap, IID_IAMTVAudio, (void **)&amp;pTVA); <br>ISpecifyPropertyPages *pSpec; <br>CAUUID cauuid; <br>            hr = pTVA-&gt;QueryInterface(IID_ISpecifyPropertyPages, <br>(void **)&amp;pSpec); <br>    if (hr == S_OK) { <br>            hr = pSpec-&gt;GetPages(&amp;cauuid); <br>                    hr = OleCreatePropertyFrame(ghwndApp, 30, 30, NULL, 1, <br>                    (IUnknown **)&amp;pTVA, cauuid.cElems, <br>    (GUID *)cauuid.pElems, 0, 0, NULL); <br>    CoTaskMemFree(cauuid.pElems); <br>    pSpec-&gt;Release(); <br>} <br>pTVA-&gt;Release(); <br>    } <br> <br>    break; <br> <br>    } <br>    return 0L; <br>} <br> <br> <br>/*----------------------------------------------------------------------------*\ <br>|   ErrMsg - Opens a Message box with a error message in it.  The user can     | <br>|            select the OK button to continue                                  | <br>\*----------------------------------------------------------------------------*/ <br>int ErrMsg (LPTSTR sz,...) <br>{ <br>    static TCHAR ach[2000]; <br>    va_list va; <br> <br>    va_start(va, sz); <br>    wvsprintf (ach,sz, va); <br>    va_end(va); <br>    MessageBox(ghwndApp,ach,NULL, MB_OK|MB_ICONEXCLAMATION|MB_TASKMODAL); <br>    return FALSE; <br>} <br> <br> <br>/* AboutDlgProc() <br> * <br> * Dialog Procedure for the "about" dialog box. <br> * <br> */ <br> <br>BOOL CALLBACK AboutDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>switch (msg) { <br>case WM_COMMAND: <br>EndDialog(hwnd, TRUE); <br>return TRUE; <br>case WM_INITDIALOG: <br>return TRUE; <br>} <br>return FALSE; <br>} <br> <br> <br>// pre-allocate the capture file <br>// <br>BOOL AllocCaptureFile(HWND hWnd) <br>{ <br>    // we'll get into an infinite loop in the dlg proc setting a value <br>    if (gcap.szCaptureFile[0] == 0) <br>return FALSE; <br> <br>    /* <br>     * show the allocate file space dialog to encourage <br>     * the user to pre-allocate space <br>     */ <br>    if (DoDialog(hWnd, IDD_AllocCapFileSpace, (DLGPROC)AllocCapFileProc, 0)) { <br> <br>// ensure repaint after dismissing dialog before <br>// possibly lengthy operation <br>UpdateWindow(ghwndApp); <br> <br>// User has hit OK. Alloc requested capture file space <br>BOOL f = MakeBuilder(); <br>if (!f) <br>    return FALSE; <br>WCHAR wach[_MAX_PATH]; <br>MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, gcap.szCaptureFile, -1, <br>wach, _MAX_PATH); <br>if (gcap.pBuilder-&gt;AllocCapFile(wach, <br>(DWORDLONG)gcap.wCapFileSize * 1024L * 1024L) != NOERROR) { <br>    MessageBoxA(ghwndApp, "Error", <br>"Failed to pre-allocate capture file space", <br>MB_OK | MB_ICONEXCLAMATION); <br>    return FALSE; <br>} <br>return TRUE; <br>    } else { <br>return FALSE; <br>    } <br>} <br> <br> <br>/* <br> * Put up the open file dialog <br> */ <br>BOOL OpenFileDialog(HWND hWnd, LPSTR lpName, int cb) <br>{ <br>    OPENFILENAMEA ofn; <br>    LPSTR p; <br>    char         achFileName[_MAX_PATH]; <br>    char         achBuffer[_MAX_PATH] ; <br> <br>    if (lpName == NULL || cb &lt;= 0) <br>return FALSE; <br> <br>    // start with capture file as current file name <br>    achFileName[0] = 0; <br>    lstrcpy(achFileName, gcap.szCaptureFile); <br> <br>    // Get just the path info <br>    // Terminate the full path at the last backslash <br>    lstrcpy(achBuffer, achFileName); <br>    for (p = achBuffer + lstrlen(achBuffer); p &gt; achBuffer; p--) { <br>if (*p == '\\') { <br>    *(p+1) = '\0'; <br>    break; <br>} <br>    } <br> <br>    _fmemset(&amp;ofn, 0, sizeof(OPENFILENAME)) ; <br>    ofn.lStructSize = sizeof(OPENFILENAME) ; <br>    ofn.hwndOwner = hWnd ; <br>    ofn.lpstrFilter = "Microsoft AVI\0*.avi\0\0"; <br>    ofn.nFilterIndex = 0 ; <br>    ofn.lpstrFile = achFileName; <br>    ofn.nMaxFile = sizeof(achFileName) ; <br>    ofn.lpstrFileTitle = NULL; <br>    ofn.lpstrTitle = "Set Capture File"; <br>    ofn.nMaxFileTitle = 0 ; <br>    ofn.lpstrInitialDir = achBuffer; <br>    ofn.Flags = OFN_HIDEREADONLY | OFN_NOREADONLYRETURN | OFN_PATHMUSTEXIST ; <br> <br>    if (GetOpenFileNameA(&amp;ofn)) { <br>// We have a capture file name <br>lstrcpyn(lpName, achFileName, cb); <br>return TRUE; <br>    } else { <br>return FALSE; <br>    } <br>} <br> <br> <br>/* <br> * Put up a dialog to allow the user to select a capture file. <br> */ <br>BOOL SetCaptureFile(HWND hWnd) <br>{ <br>    if (OpenFileDialog(hWnd, gcap.szCaptureFile, _MAX_PATH)) { <br>OFSTRUCT os; <br> <br>// We have a capture file name <br> <br>/* <br> * if this is a new file, then invite the user to <br> * allocate some space <br> */ <br>if (OpenFile(gcap.szCaptureFile, &amp;os, OF_EXIST) == HFILE_ERROR) { <br> <br>    // bring up dialog, and set new file size <br>    BOOL f = AllocCaptureFile(hWnd); <br>    if (!f) <br>return FALSE; <br>} <br>    } else { <br>return FALSE; <br>    } <br> <br>    SetAppCaption();    // new a new app caption <br> <br>    // tell the file writer to use the new filename <br>    if (gcap.pSink) { <br>WCHAR wach[_MAX_PATH]; <br>MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, gcap.szCaptureFile, -1, <br>wach, _MAX_PATH); <br>gcap.pSink-&gt;SetFileName(wach, NULL); <br>    } <br> <br>    return TRUE; <br>} <br> <br> <br>/* <br> * Put up a dialog to allow the user to save the contents of the capture file <br> * elsewhere <br> */ <br>BOOL SaveCaptureFile(HWND hWnd) <br>{ <br>    HRESULT hr; <br>    char achDstFile[_MAX_PATH]; <br>    WCHAR wachDstFile[_MAX_PATH]; <br>    WCHAR wachSrcFile[_MAX_PATH]; <br> <br>    if (gcap.pBuilder == NULL) <br>return FALSE; <br> <br>    if (OpenFileDialog(hWnd, achDstFile, _MAX_PATH)) { <br> <br>// We have a capture file name <br>MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, gcap.szCaptureFile, -1, <br>wachSrcFile, _MAX_PATH); <br>MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, achDstFile, -1, <br>wachDstFile, _MAX_PATH); <br>statusUpdateStatus(ghwndStatus, "Saving capture file - please wait..."); <br> <br>// we need our own graph builder because the main one might not exist <br>ICaptureGraphBuilder *pBuilder; <br>hr = CoCreateInstance((REFCLSID)CLSID_CaptureGraphBuilder, <br>NULL, CLSCTX_INPROC, (REFIID)IID_ICaptureGraphBuilder, <br>(void **)&amp;pBuilder); <br>if (hr == NOERROR) { <br>    // allow the user to press ESC to abort... don't ask for progress <br>    hr = pBuilder-&gt;CopyCaptureFile(wachSrcFile, wachDstFile,TRUE,NULL); <br>    pBuilder-&gt;Release(); <br>} <br>if (hr == S_OK) <br>    statusUpdateStatus(ghwndStatus, "Capture file saved"); <br>else if (hr == S_FALSE) <br>    statusUpdateStatus(ghwndStatus, "Capture file save aborted"); <br>else <br>    statusUpdateStatus(ghwndStatus, "Capture file save ERROR"); <br>return (hr == NOERROR ? TRUE : FALSE);  <br> <br>    } else { <br>return TRUE;    // they cancelled or something <br>    } <br>} <br> <br>// brings up a dialog box <br>// <br>int DoDialog(HWND hwndParent, int DialogID, DLGPROC fnDialog, long lParam) <br>{ <br>    DLGPROC fn; <br>    int result; <br> <br>    fn = (DLGPROC)MakeProcInstance(fnDialog, ghInstApp); <br>    result = DialogBoxParam( <br>ghInstApp, <br>MAKEINTRESOURCE(DialogID), <br>hwndParent, <br>fn, <br>lParam); <br>    FreeProcInstance(fn); <br> <br>    return result; <br>} <br> <br> <br>// <br>// GetFreeDiskSpace: Function to Measure Available Disk Space <br>// <br>static long GetFreeDiskSpaceInKB(LPSTR pFile) <br>{ <br>    DWORD dwFreeClusters, dwBytesPerSector, dwSectorsPerCluster, dwClusters; <br>    char RootName[MAX_PATH]; <br>    LPSTR ptmp;    //required arg <br>    ULARGE_INTEGER ulA, ulB, ulFreeBytes; <br> <br>    // need to find path for root directory on drive containing <br>    // this file. <br> <br>    GetFullPathName(pFile, sizeof(RootName), RootName, &amp;ptmp); <br> <br>    // truncate this to the name of the root directory (god how tedious) <br>    if (RootName[0] == '\\' &amp;&amp; RootName[1] == '\\') { <br> <br>// path begins with  \\server\share\path so skip the first <br>// three backslashes <br>ptmp = &amp;RootName[2]; <br>while (*ptmp &amp;&amp; (*ptmp != '\\')) { <br>    ptmp++; <br>} <br>if (*ptmp) { <br>    // advance past the third backslash <br>    ptmp++; <br>} <br>    } else { <br>// path must be drv:\path <br>ptmp = RootName; <br>    } <br> <br>    // find next backslash and put a null after it <br>    while (*ptmp &amp;&amp; (*ptmp != '\\')) { <br>ptmp++; <br>    } <br>    // found a backslash ? <br>    if (*ptmp) { <br>// skip it and insert null <br>ptmp++; <br>*ptmp = '\0'; <br>    } <br> <br>    // the only real way of finding out free disk space is calling <br>    // GetDiskFreeSpaceExA, but it doesn't exist on Win95 <br> <br>    HINSTANCE h = LoadLibraryA("kernel32.dll"); <br>    if (h) { <br>typedef BOOL (WINAPI *MyFunc)(LPCSTR RootName, PULARGE_INTEGER pulA, PULARGE_INTEGER pulB, PULARGE_INTEGER pulFreeBytes); <br>MyFunc pfnGetDiskFreeSpaceEx = (MyFunc)GetProcAddress(h, <br>"GetDiskFreeSpaceExA"); <br>FreeLibrary(h); <br>if (pfnGetDiskFreeSpaceEx) { <br>    if (!pfnGetDiskFreeSpaceEx(RootName, &amp;ulA, &amp;ulB, &amp;ulFreeBytes)) <br>return -1; <br>    return (long)(ulFreeBytes.QuadPart / 1024); <br>} <br>    } <br> <br>    if (!GetDiskFreeSpace(RootName, &amp;dwSectorsPerCluster, &amp;dwBytesPerSector, <br>&amp;dwFreeClusters, &amp;dwClusters)) <br>return (-1); <br>    return(MulDiv(dwSectorsPerCluster * dwBytesPerSector, <br>   dwFreeClusters, <br>   1024)); <br>} <br> <br> <br> <br>// AllocCapFileProc: Capture file Space Allocation Dialog Box Procedure <br>// <br>int FAR PASCAL AllocCapFileProc(HWND hDlg, UINT Message, UINT wParam, LONG lParam) <br>{ <br>    static int      nFreeMBs = 0 ; <br> <br>    switch (Message) { <br>case WM_INITDIALOG: <br>{ <br>    DWORDLONG        dwlFileSize = 0; <br>    long             lFreeSpaceInKB; <br> <br>    // Get current capture file name and measure its size <br>    dwlFileSize = GetSize(gcap.szCaptureFile); <br> <br>    // Get free disk space and add current capture file size to that. <br>    // Convert the available space to MBs. <br>    if ((lFreeSpaceInKB = <br>GetFreeDiskSpaceInKB(gcap.szCaptureFile)) != -1L) { <br>lFreeSpaceInKB += (long)(dwlFileSize / 1024); <br>nFreeMBs = lFreeSpaceInKB / 1024 ; <br>SetDlgItemInt(hDlg, IDD_SetCapFileFree, nFreeMBs, TRUE) ; <br>    } else { <br>EnableWindow(GetDlgItem(hDlg, IDD_SetCapFileFree), FALSE); <br>    } <br> <br>    gcap.wCapFileSize = (WORD) (dwlFileSize / (1024L * 1024L)); <br> <br>    SetDlgItemInt(hDlg, IDD_SetCapFileSize, gcap.wCapFileSize, TRUE) ; <br>    return TRUE ; <br>} <br> <br>case WM_COMMAND : <br>    switch (GET_WM_COMMAND_ID(wParam, lParam)) { <br>case IDOK : <br>{ <br>    int         iCapFileSize ; <br> <br>    iCapFileSize = (int) GetDlgItemInt(hDlg, IDD_SetCapFileSize, NULL, TRUE) ; <br>    if (iCapFileSize &lt;= 0 || iCapFileSize &gt; nFreeMBs) { <br>// You are asking for more than we have !! Sorry, ... <br>SetDlgItemInt(hDlg, IDD_SetCapFileSize, iCapFileSize, TRUE) ; <br>SetFocus(GetDlgItem(hDlg, IDD_SetCapFileSize)) ; <br>MessageBeep(MB_ICONEXCLAMATION) ; <br>return FALSE ; <br>    } <br>    gcap.wCapFileSize = iCapFileSize ; <br> <br>    EndDialog(hDlg, TRUE) ; <br>    return TRUE ; <br>} <br> <br>case IDCANCEL : <br>    EndDialog(hDlg, FALSE) ; <br>    return TRUE ; <br> <br>case IDD_SetCapFileSize: <br>{ <br>    long l; <br>    BOOL bchanged; <br>    char achBuffer[21]; <br> <br>    // check that entered size is a valid number <br>    GetDlgItemText(hDlg, IDD_SetCapFileSize, achBuffer, sizeof(achBuffer)); <br>    l = atol(achBuffer); <br>    bchanged = FALSE; <br>    if (l &lt; 1) { <br>l = 1; <br>bchanged = TRUE; <br>    // don't infinite loop if there's &lt; 1 Meg free <br>    } else if (l &gt; nFreeMBs &amp;&amp; nFreeMBs &gt; 0) { <br>l = nFreeMBs; <br>bchanged = TRUE; <br>    } else { <br>// make sure there are no non-digit chars <br>// atol() will ignore trailing non-digit characters <br>int c = 0; <br>while (achBuffer[c]) { </code></pre>
<p>
</p>
<pre><code>if (IsCharAlpha(achBuffer[c]) || <br>!IsCharAlphaNumeric(achBuffer[c])) { <br> <br>// string contains non-digit chars - reset <br>l = 1; <br>bchanged = TRUE; <br>break; <br>    } <br>    c++; <br>} <br>    } <br>    if (bchanged) { <br>wsprintf(achBuffer, "%ld", l); <br>SetDlgItemText(hDlg, IDD_SetCapFileSize, achBuffer); <br>    } <br>    break; <br>} <br>    } <br>    break ; <br>    } <br> <br>    return FALSE ; <br>} <br> <br> <br>// <br>// FrameRateProc: Choose a frame rate <br>// <br>int FAR PASCAL FrameRateProc(HWND hwnd, UINT msg, UINT wParam, LONG lParam) <br>{ <br>  char  ach[32]; <br>   <br>  switch (msg) { <br>    case WM_INITDIALOG: <br>/* put the current frame rate in the box */ <br>sprintf(ach, "%f", gcap.FrameRate, ach); <br>SetDlgItemText(hwnd, IDC_FRAMERATE, ach); <br>break; <br> <br>    case WM_COMMAND: <br>switch(wParam){ <br>    case IDCANCEL: <br>EndDialog(hwnd, FALSE); <br>break; <br> <br>    case IDOK: <br>/* get the new frame rate */ <br>GetDlgItemText(hwnd, IDC_FRAMERATE, ach, sizeof(ach)); <br>if (atof(ach) &lt;= 0.) { <br>    ErrMsg("Invalid frame rate."); <br>    break; <br>} <br>gcap.FrameRate = atof(ach); <br>EndDialog(hwnd, TRUE); <br>break; <br>} <br>break; <br> <br>    default: <br>return FALSE; <br>  } <br>  return TRUE; <br>} <br> <br> <br>// <br>// TimeLimitProc: Choose a capture time limit <br>// <br>int FAR PASCAL TimeLimitProc(HWND hwnd, UINT msg, UINT wParam, LONG lParam) <br>{ <br>  char  ach[32]; <br>  DWORD   dwTimeLimit; <br>   <br>  switch (msg) { <br>    case WM_INITDIALOG: <br>/* put the current time limit info in the boxes */ <br>sprintf(ach, "%d", gcap.dwTimeLimit, ach); <br>SetDlgItemText(hwnd, IDC_TIMELIMIT, ach); <br>CheckDlgButton(hwnd, IDC_USETIMELIMIT, gcap.fUseTimeLimit); <br>break; <br> <br>    case WM_COMMAND: <br>switch(wParam){ <br>    case IDCANCEL: <br>EndDialog(hwnd, FALSE); <br>break; <br> <br>    case IDOK: <br>/* get the new time limit */ <br>dwTimeLimit = GetDlgItemInt(hwnd, IDC_TIMELIMIT, NULL, FALSE); <br>gcap.dwTimeLimit = dwTimeLimit; <br>gcap.fUseTimeLimit = IsDlgButtonChecked(hwnd, IDC_USETIMELIMIT); <br>EndDialog(hwnd, TRUE); <br>break; <br>} <br>break; <br> <br>    default: <br>return FALSE; <br>  } <br>  return TRUE; <br>} <br> <br> <br>// <br>// PressAKeyProc: Press OK to capture <br>// <br>int FAR PASCAL PressAKeyProc(HWND hwnd, UINT msg, UINT wParam, LONG lParam) <br>{ <br>  char ach[_MAX_PATH]; <br> <br>  switch (msg) { <br>    case WM_INITDIALOG: <br>/* set the current file name in the box */ <br>wsprintf(ach, "%s", gcap.szCaptureFile); <br>SetDlgItemText(hwnd, IDC_CAPFILENAME, ach); <br>break; <br> <br>    case WM_COMMAND: <br>switch(wParam){ <br>    case IDCANCEL: <br>EndDialog(hwnd, FALSE); <br>break; <br> <br>    case IDOK: <br>EndDialog(hwnd, TRUE); <br>break; <br>} <br>break; <br> <br>    default: <br>return FALSE; <br>  } <br>  return TRUE; <br>} <br> <br>DWORDLONG GetSize(LPCSTR ach) <br>{ <br>    HANDLE hFile = CreateFileA(ach, GENERIC_READ, FILE_SHARE_READ, 0, <br>OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0); <br> <br>    if (hFile == INVALID_HANDLE_VALUE) { <br>return 0; <br>    } <br> <br>    DWORD dwSizeHigh; <br>    DWORD dwSizeLow = GetFileSize(hFile, &amp;dwSizeHigh); <br> <br>    DWORDLONG dwlSize = dwSizeLow + ((DWORDLONG)dwSizeHigh &lt;&lt; 32); <br> <br>    if (!CloseHandle(hFile)) { <br>dwlSize = 0; <br>    } <br> <br>    return dwlSize; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
