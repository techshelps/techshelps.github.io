<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TEXTOUT.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2934"></a>TEXTOUT.CPP</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//==========================================================================; <br> <br>#include &lt;streams.h&gt; <br>#include &lt;initguid.h&gt; <br>#include "textout.h" <br> <br>// <br>// <br>// What this sample illustates <br>// <br>// A simple text renderer - we draw samples from a text stream into a window <br>// We use the CBaseRenderer class to manage a filter with a single input pin <br>// and CBaseWindow to look after the construction, management and destruction <br>// of a window. The window object creates itself a separate worker thread. <br>// <br>// <br>// Summary <br>// <br>// This is a text renderer - we have authored a specially AVI file (called <br>// CLOCKTXT.AVI) which has an additional stream containing buffers of null <br>// termimated text. The AVI parser reads these and sends us them packaged <br>// up as ActiveMovie media samples. We get the buffer from these and cast <br>// them to strings ready to be passed to ExtTextOut (from DoRenderSample). <br>// <br>// <br>// Implementation <br>// <br>// We create a simple window (the default size of 320x240) which is displayed <br>// each time the filter is paused. Into this window we will ExtTextOut each <br>// strings that are sent to us. The renderer is based on the CBaseRenderer <br>// SDK base class which handles all the synchronisation and seeking although <br>// it doesn't have any quality management implementation (to get the quality <br>// management we would inherit from CBaseVideoRenderer base class instead). <br>// <br>// From the base renderer class we override the virtual OnReceiveFirstSample <br>// method so that when we are paused we will show a poster frame. The filter <br>// also supports IVideoWindow which is done fairly simply by inheriting a <br>// class from CBaseControlWindow, this base class implements most of that <br>// interface although we also override OnClose, OnReceiveMessage (which is a <br>// generic message handler) and GetClassWindowStyles. GetClassWindowStyles <br>// is called by the base window class (CBaseWindow) during window creation <br>// when it wants to know what window and class styles it should register. <br>// <br>// <br>// Demonstration instructions <br>// <br>// Start GRAPHEDT available in the ActiveMovie SDK tools. Drag and drop the <br>// CLOCKTXT.AVI movie into the tool and it will be rendered. Click on Pause <br>// and then Run on the GRAPHEDT frame and you will see the video in one <br>// window on the desktop and another video with text being drawn into it... <br>// The words being displayed are "One", "Two". "Three" etc and the point at <br>// which they are displayed should match with the images in the other window <br>// <br>// <br>// Files <br>// <br>// textout.cpp          The filter and window class implementations <br>// textout.def          What we import and export from this DLL <br>// textout.h            Window and filter class definitions <br>// textout.rc           Version and title resource information <br>// textout.reg          What goes in the registry to make us work <br>// makefile             How we build it... <br>// <br>// <br>// Base classes we use <br>// <br>// CBaseWindow          Manages a window on a separate worker thread <br>// CBaseRenderer        The simple renderer filter base class <br>// <br>// <br> <br> <br>// Setup data <br> <br>const AMOVIESETUP_MEDIATYPE sudIpPinTypes = <br>{ <br>    &amp;MEDIATYPE_Text,              // MajorType <br>    &amp;MEDIASUBTYPE_NULL            // MinorType <br>}; <br> <br>const AMOVIESETUP_PIN sudIpPin = <br>{ <br>    L"Input",                     // The Pins name <br>    FALSE,                        // Is rendered <br>    FALSE,                        // Is an output pin <br>    FALSE,                        // Allowed none <br>    FALSE,                        // Allowed many <br>    &amp;CLSID_NULL,                  // Connects to filter <br>    NULL,                         // Connects to pin <br>    1,                            // Number of types <br>    &amp;sudIpPinTypes                // Pin details <br>}; <br> <br>const AMOVIESETUP_FILTER sudTextoutAx = <br>{ <br>    &amp;CLSID_TextRender,            // Filter CLSID <br>    L"Text Display",              // String name <br>    MERIT_NORMAL,                 // Filter merit <br>    1,                            // Number of pins <br>    &amp;sudIpPin                     // Pin details <br>}; <br> <br> <br>// List of class IDs and creator functions for the class factory. This <br>// provides the link between the OLE entry point in the DLL and an object <br>// being created. The class factory will call the static CreateInstance <br>// function when it is asked to create a CLSID_VideoRenderer object <br> <br>CFactoryTemplate g_Templates[] = { <br>    { L"Text Display" <br>    , &amp;CLSID_TextRender <br>    , CTextOutFilter::CreateInstance <br>    , NULL <br>    , &amp;sudTextoutAx }, <br>}; <br>int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]); <br> <br> <br>// <br>// DllRegisterServer <br>// <br>// Used to register and unregister the filter <br>// <br>STDAPI DllRegisterServer() <br>{ <br>    return AMovieDllRegisterServer2( TRUE ); <br> <br>} // DllRegisterServer <br> <br> <br>// <br>// DllUnregisterServer <br>// <br>STDAPI DllUnregisterServer() <br>{ <br>    return AMovieDllRegisterServer2( FALSE ); <br> <br>} // DllUnregisterServer <br> <br> <br>// <br>// Constructor <br>// <br>// Constructor for the text out renderer filter. After initialising the base <br>// renderer class and our nested window handling class we have to pass our <br>// input pin we have to the window class. The base class uses this to check <br>// that the filter has a valid pin connection before allowing IVideoWindow <br>// methods to be called (this is a stipulation of the interface set mainly <br>// because most filters can't do anything before they know what data they <br>// will be dealing with - an example being video renderers who can't really <br>// support IVideoWindow fully until they know the size/format of the video) <br>// <br>#pragma warning(disable:4355) <br>// <br>CTextOutFilter::CTextOutFilter(LPUNKNOWN pUnk,HRESULT *phr) : <br>    CBaseRenderer(CLSID_TextRender, NAME("TextOut Filter"), pUnk, phr), <br>    m_TextWindow(NAME("Text properties"),GetOwner(),phr,&amp;m_InterfaceLock,this) <br>{ <br>    m_TextWindow.SetControlWindowPin( GetPin(0) ); <br> <br>} // (Constructor) <br> <br> <br>// <br>// Destructor <br>// <br>CTextOutFilter::~CTextOutFilter() <br>{ <br>} <br> <br> <br>// <br>// CreateInstance <br>// <br>// This goes in the factory template table to create new instances <br>// <br>CUnknown * WINAPI CTextOutFilter::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr) <br>{ <br>    CTextOutFilter *pTextOutFilter = new CTextOutFilter(pUnk,phr); <br>    if (pTextOutFilter == NULL) { <br>        return NULL; <br>    } <br>    return (CBaseMediaFilter *) pTextOutFilter; <br> <br>} // CreateInstance <br> <br> <br>// <br>// NonDelegatingQueryInterface <br>// <br>// Overriden to say what interfaces we support and where <br>// <br>STDMETHODIMP <br>CTextOutFilter::NonDelegatingQueryInterface(REFIID riid,void **ppv) <br>{ <br>    CheckPointer(ppv,E_POINTER); <br>    if (riid == IID_IVideoWindow) { <br>        return m_TextWindow.NonDelegatingQueryInterface(riid,ppv); <br>    } <br>    return CBaseRenderer::NonDelegatingQueryInterface(riid,ppv); <br> <br>} // NonDelegatingQueryInterface <br> <br> <br>// <br>// Pause <br>// <br>// Overriden to show the text renderer window <br>// <br>STDMETHODIMP CTextOutFilter::Pause() <br>{ <br>    BOOL fStopToPause = (m_State == State_Stopped); <br> <br>    HRESULT hr = CBaseRenderer::Pause(); <br>    if(FAILED(hr)) { <br>        return hr; <br>    } <br> <br>    if(fStopToPause) <br>    { <br>        m_TextWindow.ActivateWindow(); <br>        m_TextWindow.DoShowWindow(SW_SHOWNORMAL); <br>    } <br>    return hr; <br> <br>} // Pause <br> <br> <br>// <br>// BreakConnect <br>// <br>// Deactivate the text out rendering window <br>// <br>HRESULT CTextOutFilter::BreakConnect() <br>{ <br>    m_TextWindow.InactivateWindow(); <br>    m_TextWindow.DoShowWindow(SW_HIDE); <br>    return NOERROR; <br> <br>} // BreakConnect <br> <br> <br>// <br>// CheckMediaType <br>// <br>// Check that we can support a given proposed type <br>// <br>HRESULT CTextOutFilter::CheckMediaType(const CMediaType *pmt) <br>{ <br>    // Reject non-Text type <br> <br>    if (pmt-&gt;majortype != MEDIATYPE_Text) { <br>return E_INVALIDARG; <br>    } <br>    return NOERROR; <br> <br>} // CheckMediaType <br> <br> <br>// <br>// OnPaint <br>// <br>// This is called when the window thread receives a WM_PAINT message <br>// <br>BOOL CTextOutFilter::OnPaint(COLORREF WindowColour) <br>{ <br>    CAutoLock cAutoLock(&amp;m_RendererLock); <br>    RECT ClientRect; <br>    PAINTSTRUCT ps; <br> <br>    BeginPaint(m_TextWindow.GetWindowHWND(),&amp;ps); <br>    EndPaint(m_TextWindow.GetWindowHWND(),&amp;ps); <br> <br>    // Display the text if we have a sample <br> <br>    if (m_pMediaSample) { <br>        DrawText(m_pMediaSample); <br>        return TRUE; <br>    } <br> <br>    // Create a coloured brush to paint the window <br> <br>    HBRUSH hBrush = CreateSolidBrush(WindowColour); <br>    EXECUTE_ASSERT(GetClientRect(m_TextWindow.GetWindowHWND(),&amp;ClientRect)); <br>    EXECUTE_ASSERT(FillRect(m_TextWindow.GetWindowHDC(),&amp;ClientRect,hBrush)); <br>    EXECUTE_ASSERT(DeleteObject(hBrush)); <br>    return TRUE; <br> <br>} // OnPaint <br> <br> <br>// <br>// DoRenderSample <br>// <br>// This is called when a sample is ready for rendering <br>// <br>HRESULT CTextOutFilter::DoRenderSample(IMediaSample *pMediaSample) <br>{ <br>    ASSERT(pMediaSample); <br>    DrawText(pMediaSample); <br>    return NOERROR; <br> <br>} // DoRenderSample <br> <br> <br>// <br>// OnReceiveFirstSample <br>// <br>// Display an image if not streaming <br>// <br>void CTextOutFilter::OnReceiveFirstSample(IMediaSample *pMediaSample) <br>{ <br>    if(IsStreaming() == FALSE) <br>    { <br>        ASSERT(pMediaSample); <br>        DrawText(pMediaSample); <br>    } <br> <br>} // OnReceiveFirstSample <br> <br> <br>// <br>// DrawText <br>// <br>// This is called with an IMediaSample interface on the image to be drawn. We <br>// are called from two separate code paths. The first is when we're signalled <br>// that an image has become due for rendering, the second is when we need to <br>// refresh a static window image. NOTE it is safe to check the type of buffer <br>// allocator as to change it we must be inactive, which by definition means <br>// we cannot have any samples available to render so we cannot be here <br>// <br>void CTextOutFilter::DrawText(IMediaSample *pMediaSample) <br>{ <br>    BYTE *pText;        // Pointer to image data <br>    RECT rcClip;        // window rectangle <br> <br>    SetRect(&amp;rcClip, (LONG) 0, (LONG) 0, <br>            m_TextWindow.GetWindowWidth(), <br>            m_TextWindow.GetWindowHeight()); <br> <br>    pMediaSample-&gt;GetPointer(&amp;pText); <br>    ASSERT(pText != NULL); <br> <br>    // Ignore zero length samples <br> <br>    if (pMediaSample-&gt;GetActualDataLength() == 0) { <br>        return; <br>    } <br> <br>    // Remove trailing NULL from the text data <br> <br>    ExtTextOut(m_TextWindow.GetWindowHDC(), <br>       0, 0, <br>       ETO_OPAQUE | ETO_CLIPPED, <br>       &amp;rcClip, <br>       (char *) pText, <br>       pMediaSample-&gt;GetActualDataLength() - 1, <br>       NULL); <br> <br>    GdiFlush(); <br> <br>} // DrawText <br> <br> <br>// <br>// Constructor <br>// <br>// Derived class handling window interactions. We did have the main renderer <br>// object inheriting from CBaseControlWindow so that we didn't have to have <br>// a separate class but that means there are two many classes derived from <br>// CUnknown, so when in the final text out filter class you call something <br>// like GetOwner it gets really confusing to know who is actually going to <br>// be called. So in the end we made it a separate class for the window. We <br>// have to specialise the base class to provide the PURE virtual method that <br>// returns the class and window information (GetClassWindowStyles). We are <br>// also interested in certain window messages like WM_PAINT and WM_NCHITTEST <br>// <br>CTextOutWindow::CTextOutWindow(TCHAR *pName,                // Object string <br>                               LPUNKNOWN pUnk,              // COM ownership <br>                               HRESULT *phr,                // OLE code <br>                               CCritSec *pLock,             // Interface lock <br>                               CTextOutFilter *pRenderer) : // Main filter <br> <br>    CBaseControlWindow(pRenderer,pLock,pName,pUnk,phr), <br>    m_pRenderer(pRenderer) <br>{ <br>    PrepareWindow(); <br> <br>} // Constructor <br> <br> <br>// <br>// Destructor <br>// <br>CTextOutWindow::~CTextOutWindow() <br>{ <br>    DoneWithWindow(); <br> <br>} // Destructor <br> <br> <br>// <br>// OnReceiveMessage <br>// <br>// This is a virtual method that does our derived class message handling <br>// We should process the messages we are interested in and then call the <br>// base class as appropriate - some messages we may not pass forward <br>// <br>LRESULT CTextOutWindow::OnReceiveMessage(HWND hwnd,         // Window handle <br>                                         UINT uMsg,         // Message ID <br>                                         WPARAM wParam,     // First parameter <br>                                         LPARAM lParam)     // Other parameter <br>{ <br>    switch (uMsg) { <br> <br>        // This tells us some of the window's client area has become exposed <br>        // If our connected filter is doing overlay work then we repaint the <br>        // background so that it will pick up the window clipping changes <br> <br>        case WM_PAINT: <br> <br>            m_pRenderer-&gt;OnPaint(RGB(0,0,0)); <br>            return (LRESULT) 1; <br> <br>    } <br>    return CBaseControlWindow::OnReceiveMessage(hwnd,uMsg,wParam,lParam); <br> <br>} // OnReceiveMessage <br> <br> <br>// <br>// OnClose <br>// <br>// Overriding the WM_CLOSE handling to also signal EC_USERABORT <br>// <br>BOOL CTextOutWindow::OnClose() <br>{ <br>    CBaseControlWindow::OnClose(); <br>    m_pRenderer-&gt;NotifyEvent(EC_USERABORT,0,0); <br>    return TRUE; <br> <br>} // OnClose <br> <br> <br>// <br>// GetClassWindowStyles <br>// <br>// When we call PrepareWindow in our constructor it will call this method as <br>// it is going to create the window to get our window and class styles. The <br>// return code is the class name and must be allocated in static storage. We <br>// specify a normal window during creation although the window styles as well <br>// as the extended styles may be changed by the application via IVideoWindow <br>// <br>LPTSTR CTextOutWindow::GetClassWindowStyles(DWORD *pClassStyles, <br>                                            DWORD *pWindowStyles, <br>                                            DWORD *pWindowStylesEx) <br>{ <br>    *pClassStyles = TextClassStyles; <br>    *pWindowStyles = TextWindowStyles; <br>    *pWindowStylesEx = (DWORD) 0; <br>    return TextClassName; <br> <br>} // GetClassWindowStyles <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
