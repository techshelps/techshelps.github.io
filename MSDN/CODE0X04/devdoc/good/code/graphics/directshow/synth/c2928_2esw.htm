<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SYNTH.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2930"></a>SYNTH.CPP</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br>// <br>// synth.cpp <br>// <br>// Audio Signal Generator Source Filter <br> <br> <br>#include &lt;windows.h&gt; <br>#include &lt;streams.h&gt; <br>#include &lt;math.h&gt; <br> <br>#include &lt;initguid.h&gt; <br>#if (1100 &gt; _MSC_VER) <br>#include &lt;olectlid.h&gt; <br>#else <br>#include &lt;olectl.h&gt; <br>#endif <br> <br> <br>#define _AUDIOSYNTH_IMPLEMENTATION_ <br> <br>#include "isynth.h" <br>#include "synth.h" <br>#include "synthprp.h" <br> <br>// setup data <br> <br>const AMOVIESETUP_MEDIATYPE sudOpPinTypes = <br>{ &amp;MEDIATYPE_Audio      // clsMajorType <br>, &amp;MEDIASUBTYPE_NULL }; // clsMinorType <br> <br>const AMOVIESETUP_PIN sudOpPin = <br>{ L"Output"          // strName <br>, FALSE              // bRendered <br>, TRUE               // bOutput <br>, FALSE              // bZero <br>, FALSE              // bMany <br>, &amp;CLSID_NULL        // clsConnectsToFilter <br>, L"Input"           // strConnectsToPin <br>, 1                  // nTypes <br>, &amp;sudOpPinTypes };  // lpTypes <br> <br>const AMOVIESETUP_FILTER sudSynth = <br>{ &amp;CLSID_SynthFilter     // clsID <br>, L"Audio Synthesizer" // strName <br>, MERIT_UNLIKELY       // dwMerit <br>, 1                    // nPins <br>, &amp;sudOpPin };         // lpPin <br> <br>// ------------------------------------------------------------------------- <br>// g_Templates <br>// ------------------------------------------------------------------------- <br>// COM global table of objects in this dll <br> <br>CFactoryTemplate g_Templates[] = { <br> <br>    { L"Audio Synthesizer" <br>    , &amp;CLSID_SynthFilter <br>    , CSynthFilter::CreateInstance <br>    , NULL <br>    , &amp;sudSynth } <br>  , <br>    { L"Audio Synthesizer Property Page" <br>    , &amp;CLSID_SynthPropertyPage <br>    , CSynthProperties::CreateInstance } <br> <br>}; <br>int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]); <br> <br>// ------------------------------------------------------------------------- <br>// CSynthFilter, the main filter object <br>// ------------------------------------------------------------------------- <br>// <br>// CreateInstance <br>// <br>// The only allowed way to create Synthesizers <br> <br>CUnknown * WINAPI CSynthFilter::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr) { <br> <br>    CUnknown *punk = new CSynthFilter(lpunk, phr); <br>    if (punk == NULL) { <br>        *phr = E_OUTOFMEMORY; <br>    } <br> <br>    return punk; <br>} <br> <br>// <br>// CSynthFilter::Constructor <br>// <br>// initialise a CSynthStream object so that we have a pin. <br> <br>CSynthFilter::CSynthFilter(LPUNKNOWN lpunk, HRESULT *phr) <br>    : CSource(NAME("Audio Synthesizer Filter"),lpunk, CLSID_SynthFilter) <br>    , CPersistStream(lpunk, phr) <br>{ <br>    CAutoLock l(&amp;m_cStateLock); <br> <br>    m_paStreams    = (CSourceStream **) new CSynthStream*[1]; <br>    if (m_paStreams == NULL) { <br>        *phr = E_OUTOFMEMORY; <br>        return; <br>    } <br> <br>    m_paStreams[0] = new CSynthStream(phr, this, L"Audio Synth Stream"); <br>    if (m_paStreams[0] == NULL) { <br>        *phr = E_OUTOFMEMORY; <br>        return; <br>    } <br> <br>    if (SUCCEEDED(*phr)) { <br>ASSERT(m_Synth); <br>m_Channels = 1; <br>m_SamplesPerSec = 11025; <br>m_BitsPerSample = 8; <br>m_Synth-&gt;put_SynthFormat(m_Channels, m_BitsPerSample, m_SamplesPerSec); <br>    } <br>} <br> <br>// <br>// CSynthFilter::Destructor <br>// <br>CSynthFilter::~CSynthFilter(void) { <br> <br>    // <br>    //  Base class will free our pins <br>    // <br>} <br> <br>// <br>// NonDelegatingQueryInterface <br>// <br>// Reveal our property page, persistance, and control interfaces <br> <br>STDMETHODIMP CSynthFilter::NonDelegatingQueryInterface(REFIID riid, void **ppv) <br>{ <br>    CAutoLock l(&amp;m_cStateLock); <br> <br>    if (riid == IID_ISynth) { <br>        return GetInterface((ISynth *) this, ppv); <br>    } <br>    else if (riid == IID_IPersistStream) { <br>        return GetInterface((IPersistStream *) this, ppv); <br>    } <br>    else if (riid == IID_ISpecifyPropertyPages) { <br>        return GetInterface((ISpecifyPropertyPages *) this, ppv); <br>    } else { <br>        return CSource::NonDelegatingQueryInterface(riid, ppv); <br>    } <br>} <br> <br> <br>// <br>// GetPages <br>// <br>STDMETHODIMP CSynthFilter::GetPages(CAUUID * pPages) { <br> <br>    CAutoLock l(&amp;m_cStateLock); <br> <br>    pPages-&gt;cElems = 1; <br>    pPages-&gt;pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID)); <br>    if (pPages-&gt;pElems == NULL) { <br>        return E_OUTOFMEMORY; <br>    } <br>    *(pPages-&gt;pElems) = CLSID_SynthPropertyPage; <br> <br>    return NOERROR; <br> <br>} <br> <br>// ------------------------------------------------------------------------- <br>// --- IPersistStream --- <br>// ------------------------------------------------------------------------- <br> <br>#define WRITEOUT(var)   hr = pStream-&gt;Write(&amp;var, sizeof(var), NULL); \ <br>                        if (FAILED(hr)) return hr; <br> <br>#define READIN(var)     hr = pStream-&gt;Read(&amp;var, sizeof(var), NULL); \ <br>                        if (FAILED(hr)) return hr; <br> <br>STDMETHODIMP CSynthFilter::GetClassID(CLSID *pClsid) <br>{ <br>    return CBaseFilter::GetClassID(pClsid); <br>} <br> <br>int CSynthFilter::SizeMax () <br>{ <br>    return sizeof (int) * 8; <br>} <br> <br>HRESULT CSynthFilter::WriteToStream(IStream *pStream) <br>{ <br>    HRESULT hr; <br>    int i, k; <br> <br>    get_Frequency (&amp;i);  // don't we wish we'd used a structure, now? <br>    WRITEOUT(i); <br>    get_Waveform (&amp;i); <br>    WRITEOUT(i); <br>    get_Channels (&amp;i); <br>    WRITEOUT(i); <br>    get_BitsPerSample (&amp;i); <br>    WRITEOUT(i); <br>    get_SamplesPerSec (&amp;i); <br>    WRITEOUT(i); <br>    get_Amplitude (&amp;i); <br>    WRITEOUT(i); <br>    get_SweepRange (&amp;i, &amp;k); <br>    WRITEOUT(i); <br>    WRITEOUT(k); <br> <br>    return hr; <br>} <br> <br> <br>HRESULT CSynthFilter::ReadFromStream(IStream *pStream) <br>{ <br>    HRESULT hr; <br>    int i, k; <br> <br>    READIN(i); <br>    put_Frequency(i); <br>    READIN(i); <br>    put_Waveform (i); <br>    READIN(i); <br>    put_Channels (i); <br>    READIN(i); <br>    put_BitsPerSample (i); <br>    READIN(i); <br>    put_SamplesPerSec (i); <br>    READIN(i); <br>    put_Amplitude (i); <br>    READIN(i); <br>    READIN(k); <br>    put_SweepRange (i, k); <br> <br>    return hr; <br>} <br> <br>// ------------------------------------------------------------------------- <br>// ISynth, the control interface for the synthesizer <br>// ------------------------------------------------------------------------- <br> <br>// <br>// get_Frequency <br>// <br>STDMETHODIMP CSynthFilter::get_Frequency(int *Frequency) { <br> <br>    m_Synth-&gt;get_Frequency(Frequency); <br> <br>    DbgLog((LOG_TRACE, 3, TEXT("get_Frequency: %d"), *Frequency)); <br> <br>    return NOERROR; <br>} <br> <br> <br>// <br>// put_Frequency <br>// <br>STDMETHODIMP CSynthFilter::put_Frequency(int Frequency) { <br> <br>    m_Synth-&gt;put_Frequency (Frequency); <br> <br>    DbgLog((LOG_TRACE, 3, TEXT("put_Frequency: %d"), Frequency)); <br> <br>    return NOERROR; <br>} <br> <br>// <br>// get_Waveform <br>// <br>STDMETHODIMP CSynthFilter::get_Waveform(int *Waveform) { <br> <br>    m_Synth-&gt;get_Waveform (Waveform); <br> <br>    DbgLog((LOG_TRACE, 3, TEXT("get_Waveform: %d"), *Waveform)); <br> <br>    return NOERROR; <br>} <br> <br> <br>// <br>// put_Waveform <br>// <br>STDMETHODIMP CSynthFilter::put_Waveform(int Waveform) { <br> <br>    m_Synth-&gt;put_Waveform (Waveform); <br> <br>    DbgLog((LOG_TRACE, 3, TEXT("put_Waveform: %d"), Waveform)); <br> <br>    return NOERROR; <br>} <br> <br>// <br>// get_Channels <br>// <br>STDMETHODIMP CSynthFilter::get_Channels(int *Channels) { <br> <br>    *Channels = m_Channels; <br> <br>    DbgLog((LOG_TRACE, 3, TEXT("get_Channels: %d"), *Channels)); <br> <br>    return NOERROR; <br>} <br> <br>// <br>// If the format changes, we need to reconnect <br>// <br>void CSynthFilter::ReconnectWithNewFormat(void) { <br> <br>//    CAutoLock l(&amp;m_SynthLock); <br> <br>    HRESULT hr; <br>    FILTER_STATE  State; <br> <br>    CBasePin *pPin = GetPin(0); <br> <br>    // Get the state and confirm that the graph is stopped <br>    GetState (0, &amp;State); <br>    if (State != State_Stopped &amp;&amp; pPin-&gt;GetConnected()) { <br>// let's attempt a dynamic connection <br>CMediaType mtNew; <br> <br>// !!! better way to get back to a CSynthStream??? <br>CSynthStream * pStream = (CSynthStream *) pPin; <br>pStream-&gt;GetMediaType(&amp;mtNew); <br> <br>// !!! does this really mean they'll accept a dynamic format change? <br>hr = pPin-&gt;GetConnected()-&gt;QueryAccept(&amp;mtNew); <br> <br>DbgLog((LOG_TRACE,2,TEXT("Attempting format change: queryAccept returned %x"), hr)); <br> <br>if (hr == S_OK) { <br>    // actually change what's being pushed <br>    m_Synth-&gt;put_SynthFormat(m_Channels, m_BitsPerSample, m_SamplesPerSec); <br>} else { <br>    // !!! couldn't change right now, we should really schedule a reconnect <br>    // for the next time the graph is stopped. <br>} <br> <br>        return; <br>    } <br> <br>    if (!m_pGraph) <br>        return; <br> <br>    hr = GetFilterGraph()-&gt;Reconnect (pPin);       // Renegotiate the format <br>    if (FAILED(hr)) { <br>        DbgLog((LOG_TRACE, 1, TEXT("Reconnect failed, err=%x"), hr)); <br>        return; <br>    } <br>} <br> <br> <br>// <br>// put_Channels <br>// <br>STDMETHODIMP CSynthFilter::put_Channels(int Channels) { <br> <br>    m_Channels = Channels; <br> <br>    ReconnectWithNewFormat (); <br> <br>    DbgLog((LOG_TRACE, 3, TEXT("put_Channels: %d"), Channels)); <br> <br>    return NOERROR; <br>} <br> <br>// <br>// get_BitsPerSample <br>// <br>STDMETHODIMP CSynthFilter::get_BitsPerSample(int *BitsPerSample) { <br> <br>    *BitsPerSample = m_BitsPerSample; <br> <br>    DbgLog((LOG_TRACE, 3, TEXT("get_BitsPerSample: %d"), *BitsPerSample)); <br> <br>    return NOERROR; <br>} <br> <br> <br>// <br>// put_BitsPerSample <br>// <br>STDMETHODIMP CSynthFilter::put_BitsPerSample(int BitsPerSample) { <br> <br>    m_BitsPerSample = BitsPerSample; <br> <br>    ReconnectWithNewFormat (); <br> <br>    DbgLog((LOG_TRACE, 3, TEXT("put_BitsPerSample: %d"), BitsPerSample)); <br> <br>    return NOERROR; <br>} <br> <br>// <br>// get_SamplesPerSec <br>// <br>STDMETHODIMP CSynthFilter::get_SamplesPerSec(int *SamplesPerSec) { <br> <br>    *SamplesPerSec = m_SamplesPerSec; <br> <br>    DbgLog((LOG_TRACE, 3, TEXT("get_SamplesPerSec: %d"), *SamplesPerSec)); <br> <br>    return NOERROR; <br>} <br> <br> <br>// <br>// put_SamplesPerSec <br>// <br>STDMETHODIMP CSynthFilter::put_SamplesPerSec(int SamplesPerSec) { <br> <br>    m_SamplesPerSec = SamplesPerSec; <br> <br>    ReconnectWithNewFormat (); <br> <br>    DbgLog((LOG_TRACE, 3, TEXT("put_SamplesPerSec: %d"), SamplesPerSec)); <br> <br>    return NOERROR; <br>} <br> <br>// <br>// get_Amplitude <br>// <br>STDMETHODIMP CSynthFilter::get_Amplitude(int *Amplitude) { <br> <br>    m_Synth-&gt;get_Amplitude (Amplitude); <br> <br>    DbgLog((LOG_TRACE, 3, TEXT("get_Amplitude: %d"), *Amplitude)); <br> <br>    return NOERROR; <br>} <br> <br> <br>// <br>// put_Amplitude <br>// <br>STDMETHODIMP CSynthFilter::put_Amplitude(int Amplitude) { <br> <br>    m_Synth-&gt;put_Amplitude (Amplitude); <br> <br>    DbgLog((LOG_TRACE, 3, TEXT("put_Amplitude: %d"), Amplitude)); <br> <br>    return NOERROR; <br>} <br> <br> <br>// <br>// get_SweepRange <br>// <br>STDMETHODIMP CSynthFilter::get_SweepRange(int *SweepStart, int *SweepEnd) { <br> <br>    m_Synth-&gt;get_SweepRange (SweepStart, SweepEnd); <br> <br>    DbgLog((LOG_TRACE, 3, TEXT("get_SweepStart: %d %d"), *SweepStart, *SweepEnd)); <br> <br>    return NOERROR; <br>} <br> <br> <br>// <br>// put_SweepRange <br>// <br>STDMETHODIMP CSynthFilter::put_SweepRange(int SweepStart, int SweepEnd) { <br> <br>    m_Synth-&gt;put_SweepRange (SweepStart, SweepEnd); <br> <br>    DbgLog((LOG_TRACE, 3, TEXT("put_SweepRange: %d %d"), SweepStart, SweepEnd)); <br> <br>    return NOERROR; <br>} <br> <br> <br>// ------------------------------------------------------------------------- <br>// CSynthStream, the output pin <br>// ------------------------------------------------------------------------- <br> <br>// <br>// CSynthStream::Constructor <br>// <br> <br>CSynthStream::CSynthStream(HRESULT *phr, CSynthFilter *pParent, LPCWSTR pName) <br>    : CSourceStream(NAME("Audio Synth output pin"),phr, pParent, pName) { <br> <br>    CAutoLock l(m_pFilter-&gt;pStateLock()); <br> <br>    { <br>        CAutoLock l(&amp;m_cSharedState); <br> <br>        m_Synth = new CAudioSynth( ); <br>        pParent-&gt;m_Synth = m_Synth; <br>        if (m_Synth == NULL) { <br>            *phr = E_OUTOFMEMORY; <br>            return; <br>        } <br>m_pParent = pParent; <br>    } <br>} <br> <br> <br>// <br>// CSynthStream::Destructor <br>// <br>CSynthStream::~CSynthStream(void) { <br> <br>    CAutoLock l(&amp;m_cSharedState); <br> <br>    delete m_Synth; <br>} <br> <br> <br>// <br>// FillBuffer <br>// <br>// Stuffs the buffer with data <br>HRESULT CSynthStream::FillBuffer(IMediaSample *pms) { <br> <br>    BYTE *pData; <br>    long lDataLen; <br>    int nSamplesPerSec; <br>    int nBitsPerSample; <br>    int nChannels; <br>    BOOL fNewFormat = FALSE; <br> <br>    pms-&gt;GetPointer(&amp;pData); <br>    lDataLen = pms-&gt;GetSize(); <br> <br>    CAutoLock lShared(&amp;m_cSharedState); <br>    m_Synth-&gt;FillAudioBuffer (pData, lDataLen, &amp;fNewFormat); <br> <br>    if (fNewFormat) { <br>CMediaType mtNew; <br>GetMediaType(&amp;mtNew); <br> <br>pms-&gt;SetMediaType(&amp;mtNew); <br> <br>DbgLog((LOG_TRACE,2,TEXT("Sending buffer with new media type"))); <br>    } <br> <br>    CRefTime rtStart  = m_rtSampleTime;  // the current time is the sample's start <br> <br>    m_Synth-&gt;get_SamplesPerSec (&amp;nSamplesPerSec); <br>    m_Synth-&gt;get_BitsPerSample (&amp;nBitsPerSample); <br>    m_Synth-&gt;get_Channels (&amp;nChannels); <br> <br>    m_rtSampleTime += (UNITS * lDataLen / <br>            (nSamplesPerSec * nChannels * nBitsPerSample / 8)); <br> <br>    pms-&gt;SetTime((REFERENCE_TIME*)&amp;rtStart, <br>                 (REFERENCE_TIME*)&amp;m_rtSampleTime); <br> <br>    return NOERROR; <br>} <br> <br> <br>// <br>// Format Support <br>// <br> <br>// <br>// GetMediaType <br>// <br>HRESULT CSynthStream::GetMediaType(CMediaType *pmt) { <br> <br>    CAutoLock l(m_pFilter-&gt;pStateLock()); <br> <br>    WAVEFORMATEX *pwf = (WAVEFORMATEX *) pmt-&gt;AllocFormatBuffer(sizeof(WAVEFORMATEX)); <br> <br>    pwf-&gt;wFormatTag = WAVE_FORMAT_PCM; <br>    pwf-&gt;nChannels = (WORD) m_pParent-&gt;m_Channels; <br>    pwf-&gt;nSamplesPerSec = (DWORD) m_pParent-&gt;m_SamplesPerSec; <br>    pwf-&gt;wBitsPerSample = (WORD) m_pParent-&gt;m_BitsPerSample; <br>    pwf-&gt;nBlockAlign = pwf-&gt;wBitsPerSample * pwf-&gt;nChannels / 8; <br>    pwf-&gt;nAvgBytesPerSec = (int) ((DWORD) pwf-&gt;nBlockAlign * <br>                           pwf-&gt;nSamplesPerSec); <br>    pwf-&gt;cbSize = 0; <br> <br>    return CreateAudioMediaType(pwf, pmt, FALSE); <br>} <br> <br> <br>// <br>// CheckMediaType <br>// <br>// Returns E_INVALIDARG if the mediatype is not acceptable, S_OK if it is <br>HRESULT CSynthStream::CheckMediaType(const CMediaType *pMediaType) { <br> <br>    CAutoLock l(m_pFilter-&gt;pStateLock()); <br> <br>    //  Check that's Audio and that the format block <br>    //  has the WAVEFORMATEX structure (indicated by a format type <br>    //  GUID of FORMAT_WaveFormatEx) <br> <br>    if ((*pMediaType-&gt;Type() != MEDIATYPE_Audio) || <br>        (*pMediaType-&gt;FormatType() != FORMAT_WaveFormatEx)) <br>        return E_INVALIDARG; <br> <br>    WAVEFORMATEX * pwfx  = (WAVEFORMATEX *)pMediaType-&gt;Format(); <br> <br>    if (pwfx-&gt;wFormatTag != WAVE_FORMAT_PCM) <br>return E_INVALIDARG; <br> <br>    // !!! check 8/16, 1/2 channel <br> <br>    // Check for the subtypes we support <br> <br>    // Get the format area of the media type <br> <br>    // !!! if we're going to allow arbitrary media types here, we have to actually <br>    // look at SetMediaType to see what we've agreed on! <br> <br>    return S_OK;  // This format is acceptable. <br>} <br> <br>// <br>// DecideBufferSize <br>// <br>// This will always be called after the format has been sucessfully <br>// negotiated. So we have a look at m_mt to see what format we agreed to. <br>// Then we can ask for buffers of the correct size to contain them. <br>HRESULT CSynthStream::DecideBufferSize(IMemAllocator *pAlloc, <br>                                       ALLOCATOR_PROPERTIES *pProperties) <br>{ <br>    CAutoLock l(m_pFilter-&gt;pStateLock()); <br>    ASSERT(pAlloc); <br>    ASSERT(pProperties); <br>    HRESULT hr = NOERROR; <br> <br>    pProperties-&gt;cbBuffer = WaveBufferSize; <br> <br>    int nBitsPerSample; <br>    int nSamplesPerSec; <br>    int nChannels; <br> <br>    m_Synth-&gt;get_SamplesPerSec (&amp;nSamplesPerSec); <br>    m_Synth-&gt;get_BitsPerSample (&amp;nBitsPerSample); <br>    m_Synth-&gt;get_Channels (&amp;nChannels); <br> <br>    pProperties-&gt;cBuffers = nChannels * (nSamplesPerSec / pProperties-&gt;cbBuffer) * (nBitsPerSample / 8); <br>    // Get 1/2 second worth of buffers <br>    pProperties-&gt;cBuffers /= 2; <br>    if (pProperties-&gt;cBuffers &lt; 1) <br>        pProperties-&gt;cBuffers = 1 ; <br> <br>    // Ask the allocator to reserve us the memory <br> <br>    ALLOCATOR_PROPERTIES Actual; <br>    hr = pAlloc-&gt;SetProperties(pProperties,&amp;Actual); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br> <br>    // Is this allocator unsuitable <br> <br>    if (Actual.cbBuffer &lt; pProperties-&gt;cbBuffer) { <br>        return E_FAIL; <br>    } <br>    return NOERROR; <br>} <br> <br> <br>// <br>// SetMediaType <br>// <br>// Overriden from CBasePin. <br>HRESULT CSynthStream::SetMediaType(const CMediaType *pMediaType) { <br> <br>    CAutoLock l(m_pFilter-&gt;pStateLock()); <br> <br>    HRESULT hr;         // return code from base class calls <br> <br>    // Pass the call up to my base class <br>    hr = CSourceStream::SetMediaType(pMediaType); <br>    if (SUCCEEDED(hr)) <br>        return NOERROR; <br>    else <br>        return hr; <br> <br>} <br> <br> <br>// <br>// OnThreadCreate <br>// <br>// as we go active reset the stream time to zero <br>HRESULT CSynthStream::OnThreadCreate(void) { <br> <br>    CAutoLock lShared(&amp;m_cSharedState); <br> <br>    m_rtSampleTime = 0; <br> <br>    return NOERROR; <br>} <br> <br>// <br>// Active <br>// <br>// Send a message to the property page telling it to disable <br>// buttons which change the format when the graph starts running <br>HRESULT CSynthStream::Active  (void) { <br>    m_Synth-&gt;AllocWaveCache(); <br> <br>    return CSourceStream::Active(); <br>} <br> <br> <br>// <br>// Inactive <br>// <br>// Send a message to the property page telling it to enable <br>// buttons which change the format when the graph stops running <br>HRESULT CSynthStream::Inactive  (void) { <br>    return CSourceStream::Inactive(); <br>} <br> <br>// ------------------------------------------------------------------------- <br>// CAudioSynth <br>// ------------------------------------------------------------------------- <br>// Object that knows nothing about ActiveMovie, but just synthesizes <br>// waveforms <br> <br>CAudioSynth::CAudioSynth( <br>                int Frequency, <br>                int Waveform, <br>                int iBitsPerSample, <br>                int iChannels, <br>                int iSamplesPerSec, <br>                int iAmplitude <br>                ) <br>    : m_bWaveCache(NULL), <br>      m_wWaveCache(NULL) <br>{ <br> <br>    ASSERT(Waveform &gt;= WAVE_SINE); <br>    ASSERT(Waveform &lt;  WAVE_LAST); <br> <br>    m_iFrequency = Frequency; <br>    m_iWaveform = Waveform; <br>    m_iAmplitude = iAmplitude; <br>    m_iSweepStart = DefaultSweepStart; <br>    m_iSweepEnd = DefaultSweepEnd; <br> <br>    // init our WAVEFORMATEX structure <br>    wfex.wFormatTag = WAVE_FORMAT_PCM; <br>    wfex.wBitsPerSample = iBitsPerSample; <br>    wfex.nChannels = iChannels; <br>    wfex.nSamplesPerSec = iSamplesPerSec; <br>    wfex.nBlockAlign = wfex.wBitsPerSample * wfex.nChannels / 8; <br>    wfex.nAvgBytesPerSec = ((DWORD) wfex.nBlockAlign * <br>                           wfex.nSamplesPerSec); <br>    wfex.cbSize = 0; <br>} <br> <br>CAudioSynth::~CAudioSynth() <br>{ <br>    if (m_bWaveCache) { <br>        delete[] m_bWaveCache; <br>    } <br> <br>    if (m_wWaveCache) { <br>        delete[] m_wWaveCache; <br>    } <br>} <br> <br>// <br>// AllocWaveCache <br>// <br>// <br>void CAudioSynth::AllocWaveCache (void) { <br>    wfexLast = wfex; <br> <br>    m_iWaveCacheCycles = m_iFrequency; <br>    m_iWaveCacheSize = (int) wfex.nSamplesPerSec; <br> <br>    m_iFrequencyLast = 0;// force cache contents invalid <br> <br>    if (m_bWaveCache) { <br>        delete[] m_bWaveCache; <br>        m_bWaveCache = NULL; <br>    } <br>    if (m_wWaveCache) { <br>        delete[] m_wWaveCache; <br>        m_wWaveCache = NULL; <br>    } <br> <br>    if (wfex.wBitsPerSample == 8) <br>        m_bWaveCache = new BYTE [m_iWaveCacheSize]; <br>    else <br>        m_wWaveCache = new WORD [m_iWaveCacheSize]; <br>} <br> <br>// <br>// FillAudioBuffer <br>// <br>// <br>// <br>void CAudioSynth::FillAudioBuffer (BYTE pBuf[], int iSize, BOOL *pfNewFormat) { <br>    BOOL fCalcCache = FALSE; <br> <br>    CAutoLock l(&amp;m_SynthLock); <br> <br>    // Only realloc the cache if the format has changed ! <br> <br>    if ((wfex.nChannels != wfexLast.nChannels) || <br>        (wfex.wBitsPerSample != wfexLast.wBitsPerSample) || <br>        (wfex.nSamplesPerSec != wfexLast.nSamplesPerSec)) { <br>    *pfNewFormat = TRUE; <br>            fCalcCache = TRUE; <br>    AllocWaveCache(); <br>    } <br> <br>    if (m_iFrequency != m_iFrequencyLast) { <br>fCalcCache = TRUE; <br>m_iFrequencyLast = m_iFrequency; <br>    } <br>    if (m_iWaveform != m_iWaveformLast) { <br>fCalcCache = TRUE; <br>m_iWaveformLast = m_iWaveform; <br>    } <br>    if (m_iAmplitude != m_iAmplitudeLast) { <br>fCalcCache = TRUE; <br>m_iAmplitudeLast = m_iAmplitude; <br>    } <br> <br>    if (fCalcCache) { <br>        switch (m_iWaveform) { <br> <br>        case WAVE_SINE: <br>                CalcCacheSine (); <br>                break; <br> <br>        case WAVE_SQUARE: <br>                CalcCacheSquare (); <br>                break; <br> <br>        case WAVE_SAWTOOTH: <br>                CalcCacheSawtooth (); <br>                break; <br> <br>        case WAVE_SINESWEEP: <br>                CalcCacheSweep (); <br>                break; <br> <br>        } <br>    } <br> <br>    // Copy cache to output buffers <br>    if (wfex.wBitsPerSample == 8 &amp;&amp; wfex.nChannels == 1) { <br>        while (iSize--) { <br>            *pBuf++ = m_bWaveCache[m_iWaveCacheIndex++]; <br>            if (m_iWaveCacheIndex &gt;= m_iWaveCacheSize) <br>                m_iWaveCacheIndex = 0; <br>        } <br>    } <br>    else if (wfex.wBitsPerSample == 8 &amp;&amp; wfex.nChannels == 2) { <br>        iSize /= 2; <br>        while (iSize--) { <br>            *pBuf++ = m_bWaveCache[m_iWaveCacheIndex]; <br>            *pBuf++ = m_bWaveCache[m_iWaveCacheIndex++]; <br>            if (m_iWaveCacheIndex &gt;= m_iWaveCacheSize) <br>                m_iWaveCacheIndex = 0; <br>        } <br>    } <br>    else if (wfex.wBitsPerSample == 16 &amp;&amp; wfex.nChannels == 1) { <br>        WORD * pW = (WORD *) pBuf; <br>        iSize /= 2; <br>        while (iSize--) { <br>            *pW++ = m_wWaveCache[m_iWaveCacheIndex++]; <br>            if (m_iWaveCacheIndex &gt;= m_iWaveCacheSize) <br>                m_iWaveCacheIndex = 0; <br>        } <br>    } <br>    else if (wfex.wBitsPerSample == 16 &amp;&amp; wfex.nChannels == 2) { <br>        WORD * pW = (WORD *) pBuf; <br>        iSize /= 4; <br>        while (iSize--) { <br>            *pW++ = m_wWaveCache[m_iWaveCacheIndex]; <br>            *pW++ = m_wWaveCache[m_iWaveCacheIndex++]; <br>            if (m_iWaveCacheIndex &gt;= m_iWaveCacheSize) <br>                m_iWaveCacheIndex = 0; <br>        } <br>    } <br> <br>} <br> <br>// <br>// CalcCacheSine <br>// <br>// <br>void CAudioSynth::CalcCacheSine (void) { <br> <br>    int i; <br>    double d; <br>    double amplitude; <br>    double FTwoPIDivSpS; <br> <br>    amplitude = ((wfex.wBitsPerSample == 8) ? 127 : 32767 ) <br>                    * m_iAmplitude / 100; <br> <br>    FTwoPIDivSpS = m_iFrequency * TWOPI / wfex.nSamplesPerSec; <br> <br>    m_iWaveCacheIndex = 0; <br>    m_iCurrentSample = 0; <br> <br>    if (wfex.wBitsPerSample == 8) { <br>        BYTE * pB = m_bWaveCache; <br> <br>        for (i = 0; i &lt; m_iWaveCacheSize; i++) { <br>            d = FTwoPIDivSpS * i; <br>            *pB++ = (BYTE) (sin (d) * amplitude) + 128; <br>        } <br>    } <br>    else { <br>        PWORD pW = (PWORD) m_wWaveCache; <br> <br>        for (i = 0; i &lt; m_iWaveCacheSize; i++) { <br>            d = FTwoPIDivSpS * i; <br>            *pW++ = (WORD) (sin (d) * amplitude); <br>        } <br>    } <br> <br>} <br> <br>// <br>// CalcCacheSquare <br>// <br>// <br>void CAudioSynth::CalcCacheSquare (void) { <br> <br>    int i; <br>    double d; <br>    double FTwoPIDivSpS; <br>    BYTE b0, b1; <br>    WORD w0, w1; <br> <br>    b0 = (BYTE) 128 - (127 * m_iAmplitude / 100); <br>    b1 = (BYTE) 128 + (127 * m_iAmplitude / 100); <br>    w0 = (WORD) (32767. * m_iAmplitude / 100); <br>    w1 = (WORD) - (32767. * m_iAmplitude / 100); <br> <br>    FTwoPIDivSpS = m_iFrequency * TWOPI / wfex.nSamplesPerSec; <br> <br>    m_iWaveCacheIndex = 0; <br>    m_iCurrentSample = 0; <br> <br>    if (wfex.wBitsPerSample == 8) { <br>        BYTE * pB = m_bWaveCache; <br> <br>        for (i = 0; i &lt; m_iWaveCacheSize; i++) { <br>            d = FTwoPIDivSpS * i; <br>            *pB++ = (BYTE) ((sin (d) &gt;= 0) ? b1 : b0); <br>        } <br>    } <br>    else { <br>        PWORD pW = (PWORD) m_wWaveCache; <br> <br>        for (i = 0; i &lt; m_iWaveCacheSize; i++) { <br>            d = FTwoPIDivSpS * i; <br>            *pW++ = (WORD) ((sin (d) &gt;= 0) ? w1 : w0); <br>        } <br>    } <br>} <br> <br>// <br>// CalcCacheSawtooth <br>// <br>void CAudioSynth::CalcCacheSawtooth (void) { <br> <br>    int i; <br>    double d; <br>    double amplitude; <br>    double FTwoPIDivSpS; <br>    double step; <br>    double curstep; <br>    BOOL fLastWasNeg = TRUE; <br>    BOOL fPositive; <br> <br>    amplitude = ((wfex.wBitsPerSample == 8) ? 255 : 65535 ) <br>                    * m_iAmplitude / 100; <br> <br>    FTwoPIDivSpS = m_iFrequency * TWOPI / wfex.nSamplesPerSec; <br>    step = amplitude * m_iFrequency / wfex.nSamplesPerSec; <br> <br>    m_iWaveCacheIndex = 0; <br>    m_iCurrentSample = 0; <br> <br>    BYTE * pB = m_bWaveCache; <br>    PWORD pW = (PWORD) m_wWaveCache; <br> <br>    for (i = 0; i &lt; m_iWaveCacheSize; i++) { <br>        d = FTwoPIDivSpS * i; <br> <br>        // OneShot triggered on positive zero crossing <br>        fPositive = (sin (d) &gt;= 0); <br> <br>        if (fLastWasNeg &amp;&amp; fPositive) { <br>            if (wfex.wBitsPerSample == 8) <br>                curstep = 128 - amplitude / 2; <br>            else <br>                curstep = 32768 - amplitude / 2; <br>        } <br>        fLastWasNeg = !fPositive; <br> <br>        if (wfex.wBitsPerSample == 8) <br>            *pB++ = (BYTE) curstep; <br>        else <br>            *pW++ = (WORD) (-32767 + curstep); <br> <br>        curstep += step; <br>    } <br>} <br> <br>// <br>// CalcCacheSweep <br>// <br>void CAudioSynth::CalcCacheSweep (void) { <br> <br>    int i; <br>    double d; <br>    double amplitude; <br>    double FTwoPIDivSpS; <br>    double CurrentFreq; <br>    double DeltaFreq; <br> <br>    amplitude = ((wfex.wBitsPerSample == 8) ? 127 : 32767 ) <br>                    * m_iAmplitude / 100; <br> <br>    DeltaFreq = ((double) m_iSweepEnd - m_iSweepStart) / m_iWaveCacheSize; <br>    CurrentFreq = m_iSweepStart; <br> <br>    m_iWaveCacheIndex = 0; <br>    m_iCurrentSample = 0; <br> <br>    if (wfex.wBitsPerSample == 8) { <br>        BYTE * pB = m_bWaveCache; <br>        d = 0.0; <br> <br>        for (i = 0; i &lt; m_iWaveCacheSize; i++) { <br>            FTwoPIDivSpS = (int) CurrentFreq * TWOPI / wfex.nSamplesPerSec; <br>            CurrentFreq += DeltaFreq; <br>            d += FTwoPIDivSpS; <br>            *pB++ = (BYTE) (sin (d) * amplitude) + 128; <br>        } <br>    } <br>    else { <br>        PWORD pW = (PWORD) m_wWaveCache; <br>        d = 0.0; <br> <br>        for (i = 0; i &lt; m_iWaveCacheSize; i++) { <br>            FTwoPIDivSpS = (int) CurrentFreq * TWOPI / wfex.nSamplesPerSec; <br>            CurrentFreq += DeltaFreq; <br>            d += FTwoPIDivSpS; <br>            *pW++ = (WORD) (sin (d) * amplitude); <br>        } <br>    } <br>} <br> <br>// <br>// get_Frequency <br>// <br>STDMETHODIMP CAudioSynth::get_Frequency(int *Frequency) { <br> <br>    *Frequency = m_iFrequency; <br> <br>    DbgLog((LOG_TRACE, 3, TEXT("get_Frequency: %d"), *Frequency)); <br> <br>    return NOERROR; <br>} <br> <br> <br>// <br>// put_Frequency <br>// <br>STDMETHODIMP CAudioSynth::put_Frequency(int Frequency) { <br> <br>    CAutoLock l(&amp;m_SynthLock); <br> <br>    m_iFrequency = Frequency; <br> <br>    DbgLog((LOG_TRACE, 3, TEXT("put_Frequency: %d"), Frequency)); <br> <br>    return NOERROR; <br>} <br> <br>// <br>// get_Waveform <br>// <br>STDMETHODIMP CAudioSynth::get_Waveform(int *Waveform) { <br> <br>    *Waveform = m_iWaveform; <br> <br>    DbgLog((LOG_TRACE, 3, TEXT("get_Waveform: %d"), *Waveform)); <br> <br>    return NOERROR; <br>} <br> <br> <br>// <br>// put_Waveform <br>// <br>STDMETHODIMP CAudioSynth::put_Waveform(int Waveform) { <br> <br>    CAutoLock l(&amp;m_SynthLock); <br> <br>    m_iWaveform = Waveform; <br> <br>    DbgLog((LOG_TRACE, 3, TEXT("put_Waveform: %d"), Waveform)); <br> <br>    return NOERROR; <br>} <br> <br>// <br>// get_Channels <br>// <br>STDMETHODIMP CAudioSynth::get_Channels(int *Channels) { <br> <br>    *Channels = wfex.nChannels; <br> <br>    DbgLog((LOG_TRACE, 3, TEXT("get_Channels: %d"), *Channels)); <br> <br>    return NOERROR; <br>} <br> <br> <br>// <br>// get_BitsPerSample <br>// <br>STDMETHODIMP CAudioSynth::get_BitsPerSample(int *BitsPerSample) { <br> <br>    *BitsPerSample = wfex.wBitsPerSample; <br> <br>    DbgLog((LOG_TRACE, 3, TEXT("get_BitsPerSample: %d"), *BitsPerSample)); <br> <br>    return NOERROR; <br>} <br> <br> <br>// <br>// get_SamplesPerSec <br>// <br>STDMETHODIMP CAudioSynth::get_SamplesPerSec(int *SamplesPerSec) { <br> <br>    *SamplesPerSec = wfex.nSamplesPerSec; <br> <br>    DbgLog((LOG_TRACE, 3, TEXT("get_SamplesPerSec: %d"), *SamplesPerSec)); <br> <br>    return NOERROR; <br>} <br> <br>// <br>// put_SynthFormat <br>// <br>STDMETHODIMP CAudioSynth::put_SynthFormat(int Channels, int BitsPerSample, <br>  int SamplesPerSec) { <br> <br>    CAutoLock l(&amp;m_SynthLock); <br> <br>    wfex.nChannels = Channels; <br> <br>    wfex.wBitsPerSample = BitsPerSample; <br> <br>    wfex.nSamplesPerSec = SamplesPerSec; <br> <br>    DbgLog((LOG_TRACE, 1, TEXT("put_SynthFormat: %d-bit %d-channel %dHz"), <br>    BitsPerSample, Channels, SamplesPerSec)); <br> <br>    return NOERROR; <br>} <br> <br> <br>// <br>// get_Amplitude <br>// <br>STDMETHODIMP CAudioSynth::get_Amplitude(int *Amplitude) { <br> <br>    *Amplitude =  m_iAmplitude; <br> <br>    DbgLog((LOG_TRACE, 3, TEXT("get_Amplitude: %d"), *Amplitude)); <br> <br>    return NOERROR; <br>} <br> <br> <br>// <br>// put_Amplitude </code></pre>
<p>
</p>
<pre><code>// <br>STDMETHODIMP CAudioSynth::put_Amplitude(int Amplitude) { <br> <br>    CAutoLock l(&amp;m_SynthLock); <br> <br>    if (Amplitude &gt; MaxAmplitude || Amplitude &lt; MinAmplitude) <br>        return E_INVALIDARG; <br> <br>    m_iAmplitude = Amplitude; <br> <br>    DbgLog((LOG_TRACE, 3, TEXT("put_Amplitude: %d"), Amplitude)); <br> <br>    return NOERROR; <br>} <br> <br> <br>// <br>// get_SweepRange <br>// <br>STDMETHODIMP CAudioSynth::get_SweepRange(int *SweepStart, int *SweepEnd) { <br> <br>    *SweepStart = m_iSweepStart; <br>    *SweepEnd = m_iSweepEnd; <br> <br>    DbgLog((LOG_TRACE, 3, TEXT("get_SweepStart: %d %d"), *SweepStart, *SweepEnd)); <br> <br>    return NOERROR; <br>} <br> <br> <br>// <br>// put_SweepRange <br>// <br>STDMETHODIMP CAudioSynth::put_SweepRange(int SweepStart, int SweepEnd) { <br> <br>    CAutoLock l(&amp;m_SynthLock); <br> <br>    m_iSweepStart = SweepStart; <br>    m_iSweepEnd = SweepEnd; <br> <br>    DbgLog((LOG_TRACE, 3, TEXT("put_SweepRange: %d %d"), SweepStart, SweepEnd)); <br> <br>    return NOERROR; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* exported entry points for registration and <br>* unregistration (in this case they only call <br>* through to default implmentations). <br>* <br>* <br>* <br>* History: <br>* <br>\**************************************************************************/ <br>STDAPI <br>DllRegisterServer() <br>{ <br>  return AMovieDllRegisterServer2( TRUE ); <br>} <br> <br>STDAPI <br>DllUnregisterServer() <br>{ <br>  return AMovieDllRegisterServer2( FALSE ); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
