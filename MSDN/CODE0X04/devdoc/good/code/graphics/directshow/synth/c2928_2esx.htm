<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SYNTH.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2931"></a>SYNTH.H</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br>// <br>//  synth.h <br>// <br>//  Audio Signal Generator <br> <br>#ifndef __AUDIOSYNTH__ <br>#define __AUDIOSYNTH__ <br> <br>//CLSID_SynthFilter <br>//{79A98DE0-BC00-11ce-AC2E-444553540000} <br>DEFINE_GUID(CLSID_SynthFilter, <br>0x79a98de0, 0xbc00, 0x11ce, 0xac, 0x2e, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0); <br> <br>//CLSID_SynthFilterPropertyPage <br>//{79A98DE1-BC00-11ce-AC2E-444553540000} <br>DEFINE_GUID(CLSID_SynthPropertyPage, <br>0x79a98de1, 0xbc00, 0x11ce, 0xac, 0x2e, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0); <br> <br>const double TWOPI = 6.283185308; <br>const int MaxFrequency = 20000; <br>const int MinFrequency = 0; <br>const int DefaultFrequency = 440;       // A-440 <br>const int MaxAmplitude = 100; <br>const int MinAmplitude = 0; <br>const int DefaultSweepStart = DefaultFrequency; <br>const int DefaultSweepEnd = 5000; <br>const int WaveBufferSize = 16*1024;     // Size of each allocated buffer <br>                                        // Originally used to be 2K, but at <br>                                        // 44khz/16bit/stereo you would get <br>                                        // audio breaks with a transform in the <br>                                        // middle. <br> <br>enum Waveforms { <br>    WAVE_SINE = 0, <br>    WAVE_SQUARE, <br>    WAVE_SAWTOOTH, <br>    WAVE_SINESWEEP, <br>    WAVE_LAST           // Always keep this guy last <br>}; <br> <br>#define WM_PROPERTYPAGE_ENABLE  (WM_USER + 100) <br> <br>// below stuff is implementation-only.... <br>#ifdef _AUDIOSYNTH_IMPLEMENTATION_ <br> <br>class CSynthStream; <br> <br>// ------------------------------------------------------------------------- <br>// CAudioSynth <br>// ------------------------------------------------------------------------- <br> <br>class CAudioSynth { <br> <br>public: <br> <br>    CAudioSynth( <br>                int Frequency = DefaultFrequency, <br>                int Waveform = WAVE_SINE, <br>                int iBitsPerSample = 8, <br>                int iChannels = 1, <br>                int iSamplesPerSec = 11025, <br>                int iAmplitude = 100 <br>                ); <br> <br>    ~CAudioSynth(); <br> <br>    // Load the buffer with the current waveform <br>    void FillAudioBuffer (BYTE pBuf[], int iSize, BOOL * fNewFormat); <br> <br>    // Set the "current" format and allocate temporary memory <br>    void AllocWaveCache    (void) ; <br> <br>    STDMETHODIMP get_Frequency(int *Frequency); <br>    STDMETHODIMP put_Frequency(int  Frequency); <br>    STDMETHODIMP get_Waveform(int *Waveform); <br>    STDMETHODIMP put_Waveform(int  Waveform); <br>    STDMETHODIMP get_Channels(int *Channels); <br>    STDMETHODIMP get_BitsPerSample(int *BitsPerSample); <br>    STDMETHODIMP get_SamplesPerSec(int *SamplesPerSec); <br>    STDMETHODIMP put_SynthFormat(int Channels, int BitsPerSample, int SamplesPerSec); <br>    STDMETHODIMP get_Amplitude(int *Amplitude); <br>    STDMETHODIMP put_Amplitude(int  Amplitude); <br>    STDMETHODIMP get_SweepRange(int *SweepStart, int *SweepEnd); <br>    STDMETHODIMP put_SweepRange(int  SweepStart, int  SweepEnd); <br> <br>private: <br>    CCritSec m_SynthLock; <br> <br>    WAVEFORMATEX wfex;          // the current format <br>    WAVEFORMATEX wfexLast;      // last known waveformat <br> <br>    int m_iWaveform;            // WAVE_SINE ... <br>    int m_iFrequency;           // if not using sweep, this is the frequency <br>    int m_iAmplitude;           // 0 to 100 <br> <br>    int m_iWaveformLast;        // keep track of the last known format <br>    int m_iFrequencyLast;       // so we can flush the cache if necessary <br>    int m_iAmplitudeLast; <br> <br>    int m_iCurrentSample;       // 0 to iSamplesPerSec-1 <br>    BYTE * m_bWaveCache;        // Wave Cache as BYTEs <br>    WORD * m_wWaveCache;        // Wave Cache as WORDs <br>    int m_iWaveCacheSize;       // how big is the cache? <br>    int m_iWaveCacheCycles;     // how many cycles are in the cache <br>    int m_iWaveCacheIndex; <br> <br>    int m_iSweepStart;           // start of sweep <br>    int m_iSweepEnd;             // end of sweep <br>//    double m_SweepDuration;     // how long the sweep lasts <br> <br>    void CalcCacheSine     (void) ; <br>    void CalcCacheSquare   (void) ; <br>    void CalcCacheSawtooth (void) ; <br>    void CalcCacheSweep    (void) ; <br> <br>}; <br> <br> <br> <br>// ------------------------------------------------------------------------- <br>// CSynthFilter <br>// ------------------------------------------------------------------------- <br>// CSynthFilter manages filter level stuff <br> <br>class CSynthFilter :    public ISynth, <br>                        public CPersistStream, <br>                        public ISpecifyPropertyPages, <br>                        public CSource { <br> <br>public: <br> <br>    static CUnknown * WINAPI CreateInstance(LPUNKNOWN lpunk, HRESULT *phr); <br>    ~CSynthFilter(); <br> <br>    DECLARE_IUNKNOWN; <br> <br>    // override this to reveal our property interface <br>    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv); <br> <br>    // --- ISpecifyPropertyPages --- <br> <br>    // return our property pages <br>    STDMETHODIMP GetPages(CAUUID * pPages); <br> <br>    // --- IPersistStream Interface <br> <br>    STDMETHODIMP GetClassID(CLSID *pClsid); <br>    int SizeMax(); <br>    HRESULT WriteToStream(IStream *pStream); <br>    HRESULT ReadFromStream(IStream *pStream); <br> <br>    // <br>    // --- ISynth --- <br>    // <br> <br>    STDMETHODIMP get_Frequency(int *Frequency); <br>    STDMETHODIMP put_Frequency(int Frequency); <br>    STDMETHODIMP get_Waveform(int *Waveform); <br>    STDMETHODIMP put_Waveform(int Waveform); <br>    STDMETHODIMP get_Channels(int *Channels); <br>    STDMETHODIMP get_BitsPerSample(int *BitsPerSample); <br>    STDMETHODIMP get_SamplesPerSec(int *SamplesPerSec); <br>    STDMETHODIMP put_Channels(int Channels); <br>    STDMETHODIMP put_BitsPerSample(int BitsPersample); <br>    STDMETHODIMP put_SamplesPerSec(int SamplesPerSec); <br>    STDMETHODIMP get_Amplitude(int *Amplitude); <br>    STDMETHODIMP put_Amplitude(int Amplitude); <br>    STDMETHODIMP get_SweepRange(int *SweepStart, int *SweepEnd); <br>    STDMETHODIMP put_SweepRange(int  SweepStart, int  SweepEnd); <br> <br>    CAudioSynth *m_Synth;           // the current synthesizer <br>    intm_Channels; <br>    intm_BitsPerSample; <br>    intm_SamplesPerSec; <br> <br>private: <br> <br>    // it is only allowed to to create these objects with CreateInstance <br>    CSynthFilter(LPUNKNOWN lpunk, HRESULT *phr); <br> <br>    // When the format changes, reconnect... <br>    void CSynthFilter::ReconnectWithNewFormat(void); <br> <br>}; <br> <br> <br>// ------------------------------------------------------------------------- <br>// CSynthStream <br>// ------------------------------------------------------------------------- <br>// CSynthStream manages the data flow from the output pin. <br> <br>class CSynthStream : public CSourceStream { <br> <br>public: <br> <br>    CSynthStream(HRESULT *phr, CSynthFilter *pParent, LPCWSTR pPinName); <br>    ~CSynthStream(); <br> <br>    BOOL ReadyToStop(void) {return FALSE;} <br> <br>    // stuff an audio buffer with the current format <br>    HRESULT FillBuffer(IMediaSample *pms); <br> <br>    // ask for buffers of the size appropriate to the agreed media type. <br>    HRESULT DecideBufferSize(IMemAllocator *pIMemAlloc, <br>                             ALLOCATOR_PROPERTIES *pProperties); <br> <br>    // verify we can handle this format <br>    HRESULT CheckMediaType(const CMediaType *pMediaType); <br> <br>    // set the agreed media type <br>    HRESULT SetMediaType(const CMediaType *pMediaType); <br> <br>    HRESULT GetMediaType(CMediaType *pmt); <br> <br>    // resets the stream time to zero. <br>    HRESULT OnThreadCreate(void); <br> <br>    HRESULT Active   (void); <br>    HRESULT Inactive (void); <br> <br>private: <br> <br>    // Access to this state information should be serialized with the filters <br>    // critical section (m_pFilter-&gt;pStateLock()) <br> <br>    CCritSec    m_cSharedState;     // use this to lock access to m_rtSampleTime and m_Synth <br>                                    // which are shared with the worker thread. <br> <br>    CRefTime     m_rtSampleTime;    // The time to be stamped on each sample <br>    CAudioSynth *m_Synth;           // the current synthesizer <br> <br>    CSynthFilter *m_pParent; <br>}; <br> <br> <br> <br>#endif // _AUDIOSYNTH_IMPLEMENTATION_ implementation only.... <br> <br>#endif /* __AUDIOSYNTH__ */ <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
