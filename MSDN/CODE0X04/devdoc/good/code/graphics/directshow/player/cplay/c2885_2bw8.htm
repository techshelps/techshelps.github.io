<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CPLAY.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2888"></a>CPLAY.C</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>#include "stdwin.h" <br>#include "cplay.h" <br>#include "about.h" <br>#include "file.h" <br>#include "media.h" <br>#include "toolbar.h" <br>#include "resource.h" <br> <br>// <br>// <br>// What this sample illustrates <br>// <br>// A simple ActiveMovie application written in C. <br>// <br>// <br>// Summary <br>// <br>// This is an ActiveMovie application that is written in C. We create a window <br>// that has a simple menu allowing files to be opened and closed. The window <br>// also has three buttons for stopping, pausing and running the media. We are <br>// written to call the standard filtergraph interfaces. The only complication <br>// we have added is two UI alternatives. The filter can either be compiled to <br>// rewind to the start of the media when it is stopped, or alternatively it <br>// can leave the current position (and therefore frame) wherever it is stopped <br>// <br>// Files <br>// <br>// about.c          Run of the mill about box <br>// about.h          Header file for about box <br>// assert.c         Display a message box <br>// cplay.c          Main application code <br>// cplay.h          And its function protoypes <br>// file.c           Looks after file open dialogs <br>// file.h           And its two function prototypes <br>// makefile         How we build it <br>// media.c          Functions that call the graph <br>// media.h          And their prototypes <br>// player.rc        Visual C++ resource file <br>// resource.h       Header file for resources <br>// stdwin.c         Precompiled header file <br>// stdwin.h         Precompiled header file <br>// toolbar.c        Looks after the app toolbar <br>// toolbar.h        Public function prototypes <br>// <br>// <br> <br> <br>#define UNTITLED_STRING " - Untitled" <br>#define nMaxResourceStrSize 128 <br> <br>AppVars appVars; <br> <br> <br>// <br>// PlayerMessageBox <br>// <br>// Load and display an error message <br>// <br>void PlayerMessageBox( UINT nResource ) <br>{ <br>    char szStr[ nMaxResourceStrSize ]; <br> <br>    LoadString( appVars.hInstance, nResource, szStr, nMaxResourceStrSize ); <br>    MessageBox( appVars.hwndMainFrame, szStr, appVars.szAppName, <br>                MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION ); <br> <br>} // PlayerMessageBox <br> <br> <br>// <br>// ProcessCommand <br>// <br>// Process a WM_COMMAND message to the main window <br>// <br>long ProcessCommand( HWND hwnd, UINT wParam, LONG lParam ) <br>{ <br>    switch( wParam ){ <br>        case ID_FILE_EXIT: <br>            PostQuitMessage( 0 ); <br>            break; <br> <br>        case ID_HELP_ABOUT: <br>            DoAboutDialog( appVars.hInstance,hwnd ); <br>            break; <br> <br>        case ID_FILE_OPEN: <br>            OpenMediaFile( hwnd, NULL ); <br>            break; <br> <br>        case ID_MEDIA_PLAY: <br>            OnMediaPlay( ); <br>            break; <br> <br>        case ID_MEDIA_PAUSE: <br>            OnMediaPause( ); <br>            break; <br> <br>        case ID_MEDIA_STOP: <br>            OnMediaStop( ); <br>            break; <br> <br>        default: <br>            return DefWindowProc( hwnd, WM_COMMAND, wParam, lParam ); <br>    } <br>    return (LRESULT) 0; <br> <br>} // ProcessCommand <br> <br> <br>// <br>// OnGetMinMaxInfo <br>// <br>// Sets the minimum size of the main window and the maximum height <br>// <br>void OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI) <br>{ <br>    RECT rectRequired; <br>    SIZE sizeToolbar; <br> <br>    // Our client area is going to be the toolbar, so find our its size <br>    CalcRequiredSize( &amp;sizeToolbar ); <br> <br>    rectRequired.left = rectRequired.top = 0; <br>    rectRequired.right = sizeToolbar.cx; <br>    rectRequired.bottom = sizeToolbar.cy; <br> <br>    // Take into account the menu, caption and thick frame <br>    AdjustWindowRect( &amp;rectRequired, WS_CAPTION|WS_THICKFRAME, TRUE ); <br> <br>    // Set the min/max sizes <br>    lpMMI-&gt;ptMinTrackSize.x = rectRequired.right - rectRequired.left; <br>    lpMMI-&gt;ptMinTrackSize.y = lpMMI-&gt;ptMaxTrackSize.y = <br>            rectRequired.bottom - rectRequired.top; <br> <br>} // OnGetMinMaxInfo <br> <br> <br>// <br>// MainFrameProc <br>// <br>// Handles the message sent to the main window <br>// <br>long FAR PASCAL MainFrameProc( HWND hwnd, UINT message, UINT wParam, LONG lParam) <br>{ <br>    switch( message ){ <br>        case WM_DESTROY: <br>            PostQuitMessage( 0 ); <br>            break; <br> <br>        case WM_GETMINMAXINFO: <br>            OnGetMinMaxInfo( (MINMAXINFO FAR *) lParam ); <br>            break; <br> <br>        case WM_DRAWITEM: <br>            DrawButton( appVars.hInstance, (DRAWITEMSTRUCT FAR *) lParam ); <br>            break; <br> <br>        case WM_INITMENUPOPUP: <br>            if( lParam == 1 ){          // Media popup menu <br>                EnableMenuItem( (HMENU) wParam, ID_MEDIA_PLAY,  CanPlay()  ? MF_ENABLED : MF_GRAYED ); <br>                EnableMenuItem( (HMENU) wParam, ID_MEDIA_PAUSE, CanPause() ? MF_ENABLED : MF_GRAYED ); <br>                EnableMenuItem( (HMENU) wParam, ID_MEDIA_STOP,  CanStop()  ? MF_ENABLED : MF_GRAYED ); <br>            } else <br>                return DefWindowProc( hwnd, message, wParam, lParam ); <br>            break; <br> <br>        case WM_COMMAND: <br>            return ProcessCommand( hwnd, wParam, lParam ); <br> <br>        default: <br>            return DefWindowProc( hwnd, message, wParam, lParam ); <br>    } <br>    return (LRESULT) 0; <br> <br>} // MainFrameProc <br> <br> <br>// <br>// InitApplication <br>// <br>BOOL InitApplication() <br>{ <br>    strcpy( appVars.szAppName, APP_NAME ); <br> <br>    // Filter interface initialize? <br>    if( SUCCEEDED( CoInitialize( NULL ))) <br>return TRUE; <br> <br>    return FALSE; <br>} <br> <br> <br>// <br>// UnInitApplication <br>// <br>void UnInitApplication() <br>{ <br>    CoUninitialize( ); <br>} <br> <br> <br>// <br>// InitInstance <br>// <br>// Set the specific instance data and register our main <br>// window class if it has not been registered already <br>// <br>BOOL InitInstance( HANDLE hInstance, HANDLE hPrevInstance ) <br>{ <br>    appVars.hInstance = hInstance; <br> <br>    if(!hPrevInstance){ <br>        WNDCLASS wndClass; <br> <br>        wndClass.style          = CS_HREDRAW | CS_VREDRAW; <br>        wndClass.lpfnWndProc    = MainFrameProc; <br>        wndClass.cbClsExtra     = 0; <br>        wndClass.cbWndExtra     = 0; <br>        wndClass.hInstance      = appVars.hInstance; <br>        wndClass.hIcon          = LoadIcon( appVars.hInstance, MAKEINTRESOURCE( IDR_MAINFRAME )); <br>        wndClass.hCursor        = LoadCursor( NULL, IDC_ARROW ); <br>        wndClass.hbrBackground  = GetStockObject( LTGRAY_BRUSH ); <br>        wndClass.lpszMenuName   = MAKEINTRESOURCE( IDR_MAINFRAME ); <br>        wndClass.lpszClassName  = appVars.szAppName; <br> <br>        RegisterClass( &amp;wndClass ); <br>    } <br> <br>    return TRUE; <br> <br>} // InitInstance <br> <br> <br>// <br>// InitMainFrame <br>// <br>// Create our main window <br>// <br>BOOL InitMainFrame( int nCmdShow ) <br>{ <br>    const DWORD Styles = WS_OVERLAPPEDWINDOW &amp;~ WS_MAXIMIZEBOX; <br>    char szTitle[ 30 ]; <br> <br>    strcpy( szTitle, APP_NAME ); <br>    strcat( szTitle, UNTITLED_STRING ); <br> <br>    appVars.hwndMainFrame = <br>        CreateWindow( appVars.szAppName,    // Our class name <br>                      szTitle,              // Window title <br>                      Styles,               // It's styles <br>                      CW_USEDEFAULT,        // No x position <br>                      CW_USEDEFAULT,        // And no y either <br>                      0, 65,                // Initial sizes <br>                      NULL,                 // No parent window <br>                      NULL,                 // And no menu <br>                      appVars.hInstance,    // App instance <br>                      NULL);                // Creation data <br> <br>    ShowWindow( appVars.hwndMainFrame, nCmdShow ); <br>    UpdateWindow( appVars.hwndMainFrame ); <br>    return TRUE; <br> <br>} // InitMainFrame <br> <br> <br>// <br>// DoMainLoop <br>// <br>// Main message loop <br>// <br>UINT DoMainLoop() <br>{ <br>    MSG msg; <br>    HANDLE  ahObjects[1];       // Handles that need to be waited on <br>    const int cObjects = 1;     // Number of objects that we have <br> <br>    // Message loop lasts until we get a WM_QUIT message <br>    // Upon which we shall return from the function <br> <br>    while (TRUE) { <br>        if( (ahObjects[ 0 ] = GetGraphEventHandle()) == NULL ) { <br>            WaitMessage(); <br>        } else { <br> <br>            // Wait for any message or a graph notification <br> <br>            DWORD Result = MsgWaitForMultipleObjects( cObjects, <br>                                                      ahObjects, <br>                                                      FALSE, <br>                                                      INFINITE, <br>                                                      QS_ALLINPUT); <br> <br>            // Have we received an event notification <br> <br>            if( Result != (WAIT_OBJECT_0 + cObjects) ) <br>            { <br>                if( Result == WAIT_OBJECT_0 ) { <br>                    OnGraphNotify(); <br>                } <br>                continue; <br>            } <br>        } <br> <br>        // Read all of the messages in this next loop <br>        // removing each message as we read it <br> <br>        while (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) <br>        { <br>            if (msg.message == WM_QUIT) <br>                return msg.wParam; <br> <br>            TranslateMessage(&amp;msg); <br>            DispatchMessage(&amp;msg); <br>        } <br>    } <br> <br>} // DoMainLoop <br> <br> <br>// <br>// WinMain <br>// <br>// Application entry point <br>// <br>int PASCAL WinMain( HINSTANCE hInstance, <br>                    HINSTANCE hPrevInstance, <br>                    LPSTR lpszCmdParam, <br>                    int nCmdShow ) <br>{ <br>    UINT nReturn; <br> <br>    // Initialise COM and the application <br>    if ( InitApplication() == FALSE ) return 0; <br> <br>    if( InitInstance( hInstance, hPrevInstance ) &amp;&amp; <br>        InitMainFrame( nCmdShow ) &amp;&amp; <br>        InitToolbar( hInstance, appVars.hwndMainFrame ) &amp;&amp; <br>        InitMedia( ) &amp;&amp; <br>        InitFileOpenDialog( appVars.hwndMainFrame )) <br>    { <br>        if( lpszCmdParam[0] != '\0' ) { <br>    OpenMediaFile( appVars.hwndMainFrame, lpszCmdParam ); <br>        } <br> <br>        nReturn = DoMainLoop(); <br> <br>// Stop the graph if we can <br>if( CanStop() ) <br>            OnMediaStop(); <br> <br>        // Release the filter graph <br>DeleteContents(); <br>    } <br> <br>    UnInitApplication(); <br>    return nReturn; <br> <br>} // WinMain <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
