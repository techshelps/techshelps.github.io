<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MFCDOC.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2903"></a>MFCDOC.CPP</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br>// <br>// playdoc.cpp : implementation of the CPlayerDoc class <br>// <br> <br>#include "stdafx.h" <br>#include &lt;reftime.h&gt; <br>#include "mfcplay.h" <br> <br>#include "mfcdoc.h" <br> <br>#ifdef _DEBUG <br>#undef THIS_FILE <br>static char BASED_CODE THIS_FILE[] = __FILE__; <br>#endif <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CPlayerDoc <br> <br>IMPLEMENT_DYNCREATE(CPlayerDoc, CDocument) <br> <br>BEGIN_MESSAGE_MAP(CPlayerDoc, CDocument) <br>//{{AFX_MSG_MAP(CPlayerDoc) <br>ON_UPDATE_COMMAND_UI(ID_MEDIA_PLAY, OnUpdateMediaPlay) <br>ON_UPDATE_COMMAND_UI(ID_MEDIA_PAUSE, OnUpdateMediaPause) <br>ON_UPDATE_COMMAND_UI(ID_MEDIA_STOP, OnUpdateMediaStop) <br>ON_COMMAND(ID_MEDIA_PLAY, OnMediaPlay) <br>ON_COMMAND(ID_MEDIA_PAUSE, OnMediaPause) <br>ON_COMMAND(ID_MEDIA_STOP, OnMediaStop) <br>//}}AFX_MSG_MAP <br>END_MESSAGE_MAP() <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CPlayerDoc construction/destruction <br> <br>CPlayerDoc::CPlayerDoc() <br>{ <br>// TODO: add one-time construction code here <br>    m_pGraph = NULL; <br>    m_State = Uninitialized; <br>    m_hGraphNotifyEvent = NULL; <br> <br>    ((CPlayerApp *) AfxGetApp())-&gt;OnDocumentCreated( this ); <br>} <br> <br>BOOL CPlayerDoc::CreateFilterGraph(void) { <br>    HRESULT hr;// return code <br> <br>    ASSERT(m_pGraph == NULL); <br> <br>    hr = CoCreateInstance(CLSID_FilterGraph, // get this documents graph object <br>                          NULL, <br>                          CLSCTX_INPROC_SERVER, <br>                          IID_IGraphBuilder, <br>                          (void **) &amp;m_pGraph); <br>    if (FAILED(hr)){ <br>    m_pGraph = NULL; <br>        return FALSE; <br>    } <br> <br>    // get hold of the event notification handle so we can wait for <br>    // completion <br>    IMediaEvent *pME; <br>    hr = m_pGraph-&gt;QueryInterface(IID_IMediaEvent, (void **) &amp;pME); <br>    if (FAILED(hr)) { <br>        DeleteContents(); <br>        return FALSE; <br>    } <br> <br>    hr = pME-&gt;GetEventHandle((OAEVENT*) &amp;m_hGraphNotifyEvent); <br> <br>    pME-&gt;Release(); <br> <br>    if (FAILED(hr)) { <br>        DeleteContents(); <br>        return FALSE; <br>    } <br> <br>    return TRUE; <br>} <br> <br>void CPlayerDoc::DeleteContents( void ){ <br> <br>    if (m_pGraph != NULL) { <br>        m_pGraph-&gt;Release(); <br>        m_pGraph = NULL; <br>    } <br> <br> <br>    // this event is owned by the filtergraph and thus is no longer valid <br>    m_hGraphNotifyEvent = NULL; <br> <br>    m_State = Uninitialized; <br>} <br> <br>CPlayerDoc::~CPlayerDoc() <br>{ <br>    DeleteContents(); <br> <br>    ((CPlayerApp *) AfxGetApp())-&gt;OnDocumentDestroyed( this ); <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CPlayerDoc diagnostics <br> <br>#ifdef _DEBUG <br>void CPlayerDoc::AssertValid() const <br>{ <br>CDocument::AssertValid(); <br>} <br> <br>void CPlayerDoc::Dump(CDumpContext&amp; dc) const <br>{ <br>CDocument::Dump(dc); <br>} <br>#endif //_DEBUG <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CPlayerDoc commands <br> <br>void CPlayerDoc::OnUpdateMediaPlay(CCmdUI* pCmdUI) <br>{ <br>    pCmdUI-&gt;Enable( CanPlay() ); <br> <br>} <br> <br>void CPlayerDoc::OnUpdateMediaPause(CCmdUI* pCmdUI) <br>{ <br>    pCmdUI-&gt;Enable( CanPause() ); <br> <br>} <br> <br>void CPlayerDoc::OnUpdateMediaStop(CCmdUI* pCmdUI) <br>{ <br>    pCmdUI-&gt;Enable( CanStop() ); <br> <br>} <br> <br>void CPlayerDoc::OnMediaPlay() <br>{ <br>    if( CanPlay() ){ <br>        HRESULThr; <br>        IMediaControl *pMC; <br> <br>        // Obtain the interface to our filter graph <br>        hr = m_pGraph-&gt;QueryInterface(IID_IMediaControl, (void **) &amp;pMC); <br> <br>        if( SUCCEEDED(hr) ){ <br>            // Ask the filter graph to play and release the interface <br> <br>            // default behaviour is to carry on from where we stopped last <br>            // time. <br>            // <br>            // if you want it to do this, but rewind at the end then <br>            // define REWIND. <br>            // Otherwise you probably want to always start from the <br>            // beginning -&gt; define FROM_START (in OnMediaStop) <br>#undef REWIND <br>#define FROM_START <br> <br>#ifdef REWIND <br>            IMediaPosition * pMP; <br>            hr = m_pGraph-&gt;QueryInterface(IID_IMediaPosition, (void**) &amp;pMP); <br>            if (SUCCEEDED(hr)) { <br>                // start from last position, but rewind if near the <br>                // end <br>                REFTIME tCurrent, tLength; <br>                hr = pMP-&gt;get_Duration(&amp;tLength); <br>                if (SUCCEEDED(hr)) { <br>                    hr = pMP-&gt;get_CurrentPosition(&amp;tCurrent); <br>                    if (SUCCEEDED(hr)) { <br>                        // within 1sec of end? (or past end?) <br>                        if ((tLength - tCurrent) &lt; 1) { <br>                            pMP-&gt;put_CurrentPosition(0); <br>                        } <br>                    } <br>                } <br>                pMP-&gt;Release(); <br>            } <br>#endif <br> <br> <br>            hr = pMC-&gt;Run(); <br>            pMC-&gt;Release(); <br> <br>            if( SUCCEEDED(hr) ){ <br>                m_State=Playing; <br>                return; <br>            } <br>        } <br> <br>        // Inform the user that an error occurred <br>        AfxMessageBox(IDS_CANT_PLAY); <br> <br>    } <br>} <br> <br>void CPlayerDoc::OnMediaPause() <br>{ <br>if( CanPause() ){ <br>        HRESULThr; <br>        IMediaControl *pMC; <br> <br>        // Obtain the interface to our filter graph <br>        hr = m_pGraph-&gt;QueryInterface(IID_IMediaControl, (void **) &amp;pMC); <br> <br>        if( SUCCEEDED(hr) ){ <br>            // Ask the filter graph to pause and release the interface <br>            hr = pMC-&gt;Pause(); <br>            pMC-&gt;Release(); <br> <br>            if( SUCCEEDED(hr) ){ <br>                m_State = Paused; <br>                return; <br>            } <br>        } <br> <br>        // Inform the user that an error occurred <br>        AfxMessageBox(IDS_CANT_PAUSE); <br>    } <br> <br>} <br> <br>// stop the graph without rewinding <br>void CPlayerDoc::OnAbortStop() <br>{ <br>if( CanStop() ){ <br>        HRESULThr; <br>        IMediaControl *pMC; <br> <br>        // Obtain the interface to our filter graph <br>        hr = m_pGraph-&gt;QueryInterface(IID_IMediaControl, (void **) &amp;pMC); <br> <br>        if( SUCCEEDED(hr) ){ <br>            // Ask the filter graph to stop and release the interface <br>            hr = pMC-&gt;Stop(); <br>#ifdef FROM_START <br>            // if we want always to play from the beginning <br>            // then we should seek back to the start here <br>            // (on app or user stop request, and also after EC_COMPLETE). <br>            IMediaPosition * pMP; <br>            hr = m_pGraph-&gt;QueryInterface(IID_IMediaPosition, (void**) &amp;pMP); <br>            if (SUCCEEDED(hr)) { <br>                pMP-&gt;put_CurrentPosition(0); <br>                pMP-&gt;Release(); <br>            } <br> <br>            // no visible rewind or we will re-show the window! <br> <br>#endif <br> <br>            pMC-&gt;Release(); <br> <br>            if( SUCCEEDED(hr) ){ <br>                m_State = Stopped; <br>                return; <br>            } <br>        } <br> <br>        // Inform the user that an error occurred <br>        AfxMessageBox(IDS_CANT_STOP); <br>} <br>} <br> <br>// There are two different ways to stop a graph. We can stop and then when we <br>// are later paused or run continue from the same position. Alternatively the <br>// graph can be set back to the start of the media when it is stopped to have <br>// a more CDPLAYER style interface. These are both offered here conditionally <br>// compiled using the FROM_START definition. The main difference is that in <br>// the latter case we put the current position to zero while we change states <br> <br>void CPlayerDoc::OnMediaStop() <br>{ <br>    if( CanStop() ){ <br>        HRESULThr; <br>        IMediaControl *pMC; <br> <br>        // Obtain the interface to our filter graph <br>        hr = m_pGraph-&gt;QueryInterface(IID_IMediaControl, (void **) &amp;pMC); <br>        if( SUCCEEDED(hr) ){ <br> <br>#ifdef FROM_START <br>            IMediaPosition * pMP; <br>            OAFilterState state; <br> <br>            // Ask the filter graph to pause <br>            hr = pMC-&gt;Pause(); <br> <br>            // if we want always to play from the beginning <br>            // then we should seek back to the start here <br>            // (on app or user stop request, and also after EC_COMPLETE). <br>            hr = m_pGraph-&gt;QueryInterface(IID_IMediaPosition, <br>                                          (void**) &amp;pMP); <br>            if (SUCCEEDED(hr)) { <br>                pMP-&gt;put_CurrentPosition(0); <br>                pMP-&gt;Release(); <br>            } <br> <br>            // wait for pause to complete <br>            pMC-&gt;GetState(INFINITE, &amp;state); <br>#endif <br>            // now really do the stop <br>            pMC-&gt;Stop(); <br>            pMC-&gt;Release(); <br>            m_State = Stopped; <br>            return; <br>        } <br>        // Inform the user that an error occurred <br>        AfxMessageBox(IDS_CANT_STOP); <br>    } <br>} <br> <br> <br>BOOL CPlayerDoc::OnOpenDocument(LPCTSTR lpszPathName) <br>{ <br>    WCHARwPath[MAX_PATH]; <br> <br>    DeleteContents(); <br> <br>    if ( !CreateFilterGraph() ) { <br>        AfxMessageBox(IDS_CANT_INIT_QUARTZ); <br>        return FALSE; <br>    } <br> <br>    MultiByteToWideChar( CP_ACP, 0, lpszPathName, <br>                         -1, wPath, MAX_PATH ); <br> <br> <br>    if (FAILED( m_pGraph-&gt;RenderFile(wPath, NULL) )) { <br>        AfxMessageBox(IDS_CANT_RENDER_FILE); <br>        return FALSE; <br>    } <br> <br>    m_State = Stopped; <br> <br>    return TRUE; <br>} <br> <br>// <br>// If the event handle is valid, ask the graph <br>// if anything has happened. eg the graph has stopped... <br>void CPlayerDoc::OnGraphNotify(void) { <br>    IMediaEvent *pME; <br>    long lEventCode, lParam1, lParam2; <br> <br>    ASSERT( m_hGraphNotifyEvent != NULL ); <br> <br>    if( SUCCEEDED(m_pGraph-&gt;QueryInterface(IID_IMediaEvent, (void **) &amp;pME))) { <br>        if( SUCCEEDED(pME-&gt;GetEvent(&amp;lEventCode, &amp;lParam1, &amp;lParam2, 0))) { <br> <br>            // if this is a normal stop, then we do a rewind as <br>            // we would if the user pressed stop. For an abort, <br>            // we don't touch this. <br>            if (lEventCode == EC_COMPLETE) { <br>                OnMediaStop(); <br>            } else if ((lEventCode == EC_ERRORABORT) || <br>                       (lEventCode == EC_USERABORT)) { <br> <br>                // put the graph into stop mode but don't mess with it. <br>                OnAbortStop(); <br>            } <br>        } <br>    pME-&gt;Release(); <br>} <br> <br>    // The toolbar will only be updated after a message has been received, <br>    // so send a dummy message <br>    PostMessage( AfxGetMainWnd()-&gt;m_hWnd, WM_WAKEUP, 0, 0 ); <br> <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
