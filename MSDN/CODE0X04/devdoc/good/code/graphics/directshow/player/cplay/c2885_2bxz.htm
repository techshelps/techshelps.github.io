<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TOOLBAR.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2897"></a>TOOLBAR.C</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>// In the C++ versions of Player the MFC class CToolbar handles all of the <br>// toolbar implementation, including creating a 'disabled' bitmap from the <br>// toolbar bitmap. In this app, the pure C version, of Player we insist on <br>// a seperate disabled bitmap being supplied by the programmer. This <br>// drastically reduces the amount of code required to maintain the toolbar. <br>// The buttons in this app are controls with the owner draw attribute set. <br> <br>#include "stdwin.h" <br>#include "media.h" <br>#include "resource.h" <br> <br>// Constants for the bitmap <br>const int nButtonImageWidth = 32; <br>const int nButtonImageHeight = 32; <br> <br>// Constants for the toolbar implementation <br>const int nButtonBorder = 8; <br>const int nSeperatorGap = 6; <br>const int nToolbarBorderWidth = 5; <br>const int nToolbarBorderHeight = 3; <br> <br>// The window for each button <br>struct{ <br>    HWND hwndPlayButton; <br>    HWND hwndPauseButton; <br>    HWND hwndStopButton; <br>} toolbar; <br> <br> <br>// <br>// CalcRequiredSize <br>// <br>void CalcRequiredSize( SIZE *pSize ) <br>{ <br>    // Calculate the area required for this toolbar <br> <br>    // size for 3 buttons, 2 borders and a seperator <br>    // ...but we'll add on a some extra seperators for good measure <br>    pSize-&gt;cx = (nButtonImageWidth + nButtonBorder) * 3 <br>                    + nToolbarBorderWidth * 2 + nSeperatorGap*5; <br> <br>    // size for 1 button and 2 borders <br>    pSize-&gt;cy = nButtonImageHeight + nButtonBorder <br>                    + nToolbarBorderHeight * 2; <br> <br>} // CalcRequiredSize <br> <br> <br>// <br>// UpdateToolbar <br>// <br>// Maintains the enabled/disabled state of the buttons - we should be <br>// called periodically and/or whenever there is a change of graph state <br>// <br>void UpdateToolbar() <br>{ <br>    EnableWindow( toolbar.hwndPlayButton, CanPlay() ); <br>    EnableWindow( toolbar.hwndPauseButton, CanPause() ); <br>    EnableWindow( toolbar.hwndStopButton, CanStop() ); <br> <br>} // UpdateToolbar <br> <br> <br>// <br>// InitToolbar <br>// <br>// Create the controls for the buttons <br>// <br>BOOL InitToolbar( HINSTANCE hInstance, HWND hwnd ) <br>{ <br>    int x;      // Position of the next button <br> <br>    x = nToolbarBorderWidth; <br> <br>    // The 'Play' button <br>    toolbar.hwndPlayButton = CreateWindow( "BUTTON", <br>                                           NULL, <br>                                           BS_OWNERDRAW | WS_VISIBLE | WS_CHILD, <br>                                           x, <br>                                           nToolbarBorderHeight, <br>                                           nButtonImageWidth + nButtonBorder, <br>                                           nButtonImageHeight + nButtonBorder, <br>                                           hwnd, <br>                                           (HMENU) ID_MEDIA_PLAY, <br>                                           hInstance, <br>                                           NULL); <br> <br>    x += nButtonImageWidth + nButtonBorder; <br> <br>    // The 'Pause' button <br>    toolbar.hwndPauseButton = CreateWindow( "BUTTON", <br>                                            NULL, <br>                                            BS_OWNERDRAW | WS_VISIBLE | WS_CHILD, <br>                                            x, <br>                                            nToolbarBorderHeight, <br>                                            nButtonImageWidth + nButtonBorder, <br>                                            nButtonImageHeight + nButtonBorder, <br>                                            hwnd, <br>                                            (HMENU) ID_MEDIA_PAUSE, <br>                                            hInstance, <br>                                            NULL); <br> <br>    x += nButtonImageWidth + nButtonBorder + nSeperatorGap; <br> <br>    // The 'Stop' button <br>    toolbar.hwndStopButton = CreateWindow( "BUTTON", <br>                                           NULL, <br>                                           BS_OWNERDRAW | WS_VISIBLE | WS_CHILD, <br>                                           x, <br>                                           nToolbarBorderHeight, <br>                                           nButtonImageWidth + nButtonBorder, <br>                                           nButtonImageHeight + nButtonBorder, <br>                                           hwnd, <br>                                           (HMENU) ID_MEDIA_STOP, <br>                                           hInstance, <br>                                           NULL); <br> <br>    // We don't call UpdateToolbar to set the button states as <br>    // the multimedia variables may not have been initialized yet <br>    return TRUE; <br> <br>} // InitToolbar <br> <br> <br>// <br>// DrawRect <br>// <br>// Draws a filled rectangle using the given stock object. <br>// The rectangle starts at left,top and includes right,bottom <br>// <br>void DrawRect( HDC hDC, int left, int top, int right, int bottom, UINT nStockObject ) <br>{ <br>    RECT rect; <br> <br>    rect.left = left; <br>    rect.top = top; <br>    rect.bottom = bottom+1; <br>    rect.right = right+1; <br> <br>    FillRect( hDC, &amp;rect, GetStockObject( nStockObject ) ); <br> <br>} // DrawRect <br> <br> <br>// <br>// DrawButton <br>// <br>// Called by the main window whenever a button needs to be redrawn <br>// <br>void DrawButton( HINSTANCE hInstance, DRAWITEMSTRUCT FAR * lpDrawItem ) <br>{ <br>    HDC hSourceDC = CreateCompatibleDC( NULL ); <br>    HGDIOBJ hgdiOldBitmap; <br>    int nIndex; <br>    UINT nUpperBrush, nLowerBrush; <br> <br>    int lFrame = lpDrawItem-&gt;rcItem.left; <br>    int tFrame = lpDrawItem-&gt;rcItem.top; <br>    int rFrame = lpDrawItem-&gt;rcItem.right -1; <br>    int bFrame = lpDrawItem-&gt;rcItem.bottom - 1; <br> <br>    // Draw a black, rounded frame around the bottom top and bottom lines <br>    DrawRect( lpDrawItem-&gt;hDC, lFrame+1, tFrame, rFrame-1, tFrame, BLACK_BRUSH ); <br>    DrawRect( lpDrawItem-&gt;hDC, lFrame+1, bFrame, rFrame-1, bFrame, BLACK_BRUSH ); <br> <br>    // left and right lines <br>    DrawRect( lpDrawItem-&gt;hDC, lFrame, tFrame+1, lFrame, bFrame-1, BLACK_BRUSH ); <br>    DrawRect( lpDrawItem-&gt;hDC, rFrame, tFrame+1, rFrame, bFrame-1, BLACK_BRUSH ); <br> <br>    // Adjust the pointers to point to the inside of the rectangle <br>    lFrame++; rFrame--; <br>    tFrame++; bFrame--; <br> <br>    // The left and top will be highlighted and the right and bottom will <br>    // be in shadow if the button is raised (ie, not selected). <br>    // Otherwise the left and top will be in shadow and the right and bottom <br>    // will be their normal light gray <br> <br>    if( lpDrawItem-&gt;itemState &amp; ODS_SELECTED ){ <br>        nUpperBrush = GRAY_BRUSH; <br>        nLowerBrush = LTGRAY_BRUSH; <br>    } else { <br>        nUpperBrush = WHITE_BRUSH; <br>        nLowerBrush = GRAY_BRUSH; <br>    } <br> <br>    // Draw top &amp; left border highlight/shadow <br>    DrawRect( lpDrawItem-&gt;hDC, lFrame, tFrame, rFrame, tFrame, nUpperBrush ); <br>    DrawRect( lpDrawItem-&gt;hDC, lFrame, tFrame, lFrame, bFrame, nUpperBrush ); <br> <br>    // Draw bottom &amp; right border highlight/shadow <br>    DrawRect( lpDrawItem-&gt;hDC, rFrame, tFrame+1, rFrame, bFrame, nLowerBrush ); <br>    DrawRect( lpDrawItem-&gt;hDC, lFrame+1, bFrame, rFrame, bFrame, nLowerBrush ); <br> <br>    // Load the IDR_DISABLED_MAINFRAME bitmap into our source hDC if the <br>    // button is disabled otherwise load the IDR_MAINFRAME bitmap <br>    if( lpDrawItem-&gt;itemState &amp; ODS_DISABLED ) <br>        hgdiOldBitmap = SelectObject( hSourceDC, <br>            (HGDIOBJ) LoadBitmap( hInstance, MAKEINTRESOURCE( IDR_DISABLED_MAINFRAME ) )); <br>    else <br>        hgdiOldBitmap = <br>        hgdiOldBitmap = SelectObject( hSourceDC, <br>            (HGDIOBJ) LoadBitmap( hInstance, MAKEINTRESOURCE( IDR_MAINFRAME ) )); <br> <br>    // Decide which button to blit to the display <br>    switch( lpDrawItem-&gt;CtlID ){ <br>        case ID_MEDIA_PLAY: <br>            nIndex = 0; <br>            break; <br> <br>        case ID_MEDIA_PAUSE: <br>            nIndex = 1; <br>            break; <br> <br>        case ID_MEDIA_STOP: <br>            nIndex = 2; <br>            break; <br>    } <br> <br>    // ..and blit it <br>    BitBlt( lpDrawItem-&gt;hDC, <br>            lpDrawItem-&gt;rcItem.left + nButtonBorder/2, <br>            lpDrawItem-&gt;rcItem.top  + nButtonBorder/2, <br>            nButtonImageWidth, <br>            nButtonImageHeight, <br>            hSourceDC, <br>            nIndex * nButtonImageWidth, <br>            0, <br>            SRCCOPY <br>          ); <br> <br>    // Restore the original bitmap <br>    SelectObject( hSourceDC, hgdiOldBitmap ); <br> <br>} // DrawButton <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
