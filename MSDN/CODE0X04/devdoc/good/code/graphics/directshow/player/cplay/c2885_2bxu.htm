<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MEDIA.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2892"></a>MEDIA.C</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>#include "stdwin.h" <br>#include &lt;evcode.h&gt; <br>#include "cplay.h" <br>#include "file.h" <br>#include "media.h" <br>#include "toolbar.h" <br>#include "resource.h" <br> <br>// Current multimedia variables <br>static Media media; <br> <br> <br>// <br>// CanPlay <br>// <br>// Return true if we can go to a playing state from our current state <br>// <br>BOOL CanPlay() <br>{ <br>    return (media.state == Stopped || media.state == Paused); <br>} <br> <br> <br>// <br>// CanStop <br>// <br>// Return true if we can go to a stopped state from our current state <br>// <br>BOOL CanStop() <br>{ <br>    return (media.state == Playing || media.state == Paused); <br>} <br> <br> <br>// <br>// CanPause <br>// <br>// Return true if we can go to a paused state from our current state <br>// <br>BOOL CanPause() <br>{ <br>    return (media.state == Playing || media.state == Stopped); <br>} <br> <br> <br>// <br>// IsInitialized <br>// <br>// Return true if we have loaded and initialized a multimedia file <br>// <br>BOOL IsInitialized() <br>{ <br>    return (media.state != Uninitialized); <br>} <br> <br> <br>// <br>// ChangeStateTo <br>// <br>void ChangeStateTo( State newState ) <br>{ <br>    media.state = newState; <br> <br>    // update the toolbar <br>    UpdateToolbar(); <br>} <br> <br> <br>// <br>// InitMedia <br>// <br>// Initialization <br>// <br>BOOL InitMedia() <br>{ <br>    ChangeStateTo( Uninitialized ); <br> <br>    media.hGraphNotifyEvent = NULL; <br>    media.pGraph = NULL; <br> <br>    return TRUE; <br>} <br> <br> <br>// <br>// CreateFilterGraph <br>// <br>BOOL CreateFilterGraph() <br>{ <br>    IMediaEvent *pME; <br>    HRESULT hr; <br> <br>    ASSERT(media.pGraph == NULL); <br> <br>    hr = CoCreateInstance(&amp;CLSID_FilterGraph,           // CLSID of object <br>  NULL,                         // Outer unknown <br>  CLSCTX_INPROC_SERVER,         // Type of server <br>  &amp;IID_IGraphBuilder,           // Interface wanted <br>  (void **) &amp;media.pGraph);     // Returned object <br>    if (FAILED(hr)){ <br>media.pGraph = NULL; <br>return FALSE; <br>    } <br> <br>    // We use this to find out events sent by the filtergraph <br> <br>    hr = media.pGraph-&gt;lpVtbl-&gt;QueryInterface(media.pGraph, &amp;IID_IMediaEvent, (void **) &amp;pME); <br>    if (FAILED(hr)) { <br>DeleteContents(); <br>return FALSE; <br>    } <br> <br>    hr = pME-&gt;lpVtbl-&gt;GetEventHandle(pME, (OAEVENT*) &amp;media.hGraphNotifyEvent); <br>    pME-&gt;lpVtbl-&gt;Release( pME ); <br> <br>    if (FAILED(hr)) { <br>DeleteContents(); <br>return FALSE; <br>    } <br> <br>    return TRUE; <br> <br>} // CreateFilterGraph <br> <br> <br>// Destruction <br>// <br>// DeleteContents <br>// <br>void DeleteContents() <br>{ <br>    if (media.pGraph != NULL) { <br>media.pGraph-&gt;lpVtbl-&gt;Release( media.pGraph ); <br>media.pGraph = NULL; <br>    } <br> <br>    // this event is owned by the filter graph and is thus invalid <br>    media.hGraphNotifyEvent = NULL; <br> <br>    ChangeStateTo( Uninitialized ); <br>} <br> <br> <br>// <br>// RenderFile <br>// <br>BOOL RenderFile( LPSTR szFileName ) <br>{ <br>    HRESULT hr; <br>    WCHAR wPath[MAX_PATH]; <br> <br>    DeleteContents(); <br> <br>    if ( !CreateFilterGraph() ) { <br>PlayerMessageBox( IDS_CANT_INIT_QUARTZ ); <br>return FALSE; <br>    } <br> <br>    MultiByteToWideChar( CP_ACP, 0, szFileName, -1, wPath, MAX_PATH ); <br> <br>    SetCursor( LoadCursor( NULL, IDC_WAIT ) ); <br>    hr = media.pGraph-&gt;lpVtbl-&gt;RenderFile(media.pGraph, wPath, NULL); <br>    SetCursor( LoadCursor( NULL, IDC_ARROW ) ); <br> <br>    if (FAILED( hr )) { <br>PlayerMessageBox( IDS_CANT_RENDER_FILE ); <br>return FALSE; <br>    } <br>    return TRUE; <br> <br>} // RenderFile <br> <br> <br>// <br>// SetTitle <br>// <br>// Update the title of the video renderer to "Player - szFile" <br>// <br>void SetTitle( HWND hwnd, char *szFile ) <br>{ <br>    char szNewTitle[ _MAX_FNAME + _MAX_EXT  + 20 ]; <br> <br>    strcpy( szNewTitle, APP_NAME ); <br>    strcat( szNewTitle, " - " ); <br>    strcat( szNewTitle, szFile ); <br> <br>    // Update the window's title <br>    SetWindowText( hwnd, szNewTitle ); <br> <br>} // SetTitle <br> <br> <br>// <br>// OpenMediaFile <br>// <br>// File..Open has been selected <br>// <br>void OpenMediaFile( HWND hwnd, LPSTR szFile ) <br>{ <br>    static char szFileName[ _MAX_PATH ]; <br>    static char szTitleName[ _MAX_FNAME + _MAX_EXT ]; <br> <br>    if( szFile != NULL &amp;&amp; RenderFile( szFile )) <br>    { <br>LPSTR szTitle; <br> <br>// Work out the full path name and the file name from the <br>// specified file <br>GetFullPathName( szFile, _MAX_PATH, szFileName, &amp;szTitle ); <br>strncpy( szTitleName, szTitle, _MAX_FNAME + _MAX_EXT ); <br>szTitleName[ _MAX_FNAME + _MAX_EXT -1 ] = '\0'; <br> <br>// Set the main window title and update the state <br>SetTitle( hwnd, szTitleName ); <br>ChangeStateTo( Stopped ); <br> <br>    } else if( DoFileOpenDialog( hwnd, szFileName, szTitleName ) <br>       &amp;&amp; RenderFile( szFileName ) ){ <br> <br>// Set the main window title and update the state <br>SetTitle( hwnd, szTitleName ); <br>ChangeStateTo( Stopped ); <br>    } <br> <br>} // OpenMediaFile <br> <br> <br>// <br>// OnMediaPlay <br>// <br>// There are two possible UI strategies for an application: you either play <br>// from the start each time you stop, or you play from the current position, <br>// in which case you have to explicitly rewind at the end. If you want the <br>// play from current and rewind at end, enable this code, if you want the <br>// other option, then enable FROM_START in both OnMediaStop and OnAbortStop. <br> <br>#undef REWIND <br>#define FROM_START <br> <br>void OnMediaPlay() <br>{ <br>    if( CanPlay() ){ <br>HRESULT hr; <br>IMediaControl *pMC; <br> <br>// Obtain the interface to our filter graph <br>hr = media.pGraph-&gt;lpVtbl-&gt;QueryInterface(media.pGraph, &amp;IID_IMediaControl, (void **) &amp;pMC); <br> <br>if( SUCCEEDED(hr) ){ <br>#ifdef REWIND <br>    IMediaPosition * pMP; <br>    hr = media.pGraph-&gt;lpVtbl-&gt;QueryInterface(media.pGraph, <br>                                      &amp;IID_IMediaPosition, <br>                                      (void**) &amp;pMP); <br>    if (SUCCEEDED(hr)) { <br>// start from last position, but rewind if near the end <br>REFTIME tCurrent, tLength; <br>hr = pMP-&gt;lpVtbl-&gt;get_Duration(pMP, &amp;tLength); <br>if (SUCCEEDED(hr)) { <br>    hr = pMP-&gt;lpVtbl-&gt;get_CurrentPosition(pMP, &amp;tCurrent); <br>    if (SUCCEEDED(hr)) { <br>// within 1sec of end? (or past end?) <br>if ((tLength - tCurrent) &lt; 1) { <br>    pMP-&gt;lpVtbl-&gt;put_CurrentPosition(pMP, 0); <br>} <br>    } <br>} <br>pMP-&gt;lpVtbl-&gt;Release(pMP); <br>    } <br>#endif <br>    // Ask the filter graph to play and release the interface <br>    hr = pMC-&gt;lpVtbl-&gt;Run( pMC ); <br>    pMC-&gt;lpVtbl-&gt;Release( pMC ); <br> <br>    if( SUCCEEDED(hr) ){ <br>ChangeStateTo( Playing ); <br>return; <br>    } <br>} <br> <br>// Inform the user that an error occurred <br>PlayerMessageBox( IDS_CANT_PLAY ); <br> <br>    } <br> <br>} // OnMediaPlay <br> <br> <br>// <br>// OnMediaPause <br>// <br>void OnMediaPause() <br>{ <br>    if( CanPause() ){ <br>HRESULT hr; <br>IMediaControl *pMC; <br> <br>// Obtain the interface to our filter graph <br>hr = media.pGraph-&gt;lpVtbl-&gt;QueryInterface(media.pGraph, &amp;IID_IMediaControl, (void **) &amp;pMC); <br> <br>if( SUCCEEDED(hr) ){ <br>    // Ask the filter graph to pause and release the interface <br>    hr = pMC-&gt;lpVtbl-&gt;Pause( pMC ); <br>    pMC-&gt;lpVtbl-&gt;Release( pMC ); <br> <br>    if( SUCCEEDED(hr) ){ <br>ChangeStateTo( Paused ); <br>return; <br>    } <br>} <br> <br>// Inform the user that an error occurred <br>PlayerMessageBox( IDS_CANT_PAUSE ); <br>    } <br> <br>} // OnMediaPause <br> <br> <br>// <br>// OnMediaAbortStop <br>// <br>// Called when we get an EC_USER_ABORT or EC_ERROR_ABORT event <br>// <br>void OnMediaAbortStop(void) <br>{ <br>    if(CanStop()) <br>    { <br>HRESULT hr; <br>IMediaControl *pMC; <br> <br>// Obtain the interface to our filter graph <br>hr = media.pGraph-&gt;lpVtbl-&gt;QueryInterface(media.pGraph, &amp;IID_IMediaControl, (void **) &amp;pMC); <br> <br>if( SUCCEEDED(hr) ){ <br>#ifdef FROM_START <br>    IMediaPosition * pMP; <br>#endif <br>    // Ask the filter graph to stop and release the interface <br>    hr = pMC-&gt;lpVtbl-&gt;Stop( pMC ); <br>    pMC-&gt;lpVtbl-&gt;Release( pMC ); <br> <br>#ifdef FROM_START <br> <br>    // if we want always to play from the beginning <br>    // then we should seek back to the start here <br>    // (on app or user stop request, and also after EC_COMPLETE). <br>    hr = media.pGraph-&gt;lpVtbl-&gt;QueryInterface( <br>media.pGraph, <br>&amp;IID_IMediaPosition, <br>(void**) &amp;pMP); <br>    if (SUCCEEDED(hr)) { <br>pMP-&gt;lpVtbl-&gt;put_CurrentPosition(pMP, 0); <br>pMP-&gt;lpVtbl-&gt;Release(pMP); <br>    } <br> <br>    // no visible rewind or we will re-show the window! <br> <br>#endif <br> <br>    if( SUCCEEDED(hr) ){ <br>ChangeStateTo( Stopped ); <br>return; <br>    } <br>} <br>// Inform the user that an error occurred <br>PlayerMessageBox( IDS_CANT_STOP ); <br>    } <br> <br>} // OnMediaAbortStop <br> <br> <br>// <br>// OnMediaStop <br>// <br>// There are two different ways to stop a graph. We can stop and then when we <br>// are later paused or run continue from the same position. Alternatively the <br>// graph can be set back to the start of the media when it is stopped to have <br>// a more CDPLAYER style interface. These are both offered here conditionally <br>// compiled using the FROM_START definition. The main difference is that in <br>// the latter case we put the current position to zero while we change states <br>// <br>void OnMediaStop() <br>{ <br>    if( CanStop() ){ <br>HRESULT hr; <br>IMediaControl *pMC; <br> <br>// Obtain the interface to our filter graph <br>hr = media.pGraph-&gt;lpVtbl-&gt;QueryInterface(media.pGraph, &amp;IID_IMediaControl, (void **) &amp;pMC); <br>if( SUCCEEDED(hr) ){ <br> <br>#ifdef FROM_START <br>    IMediaPosition * pMP; <br>    OAFilterState state; <br> <br>    // Ask the filter graph to pause <br>    hr = pMC-&gt;lpVtbl-&gt;Pause( pMC ); <br> <br>    // if we want always to play from the beginning <br>    // then we should seek back to the start here <br>    // (on app or user stop request, and also after EC_COMPLETE). <br>    hr = media.pGraph-&gt;lpVtbl-&gt;QueryInterface(media.pGraph, <br>      &amp;IID_IMediaPosition, <br>      (void**) &amp;pMP); <br>    if (SUCCEEDED(hr)) { <br>pMP-&gt;lpVtbl-&gt;put_CurrentPosition(pMP, 0); <br>pMP-&gt;lpVtbl-&gt;Release(pMP); <br>    } <br> <br>    // wait for pause to complete <br>    pMC-&gt;lpVtbl-&gt;GetState(pMC, INFINITE, &amp;state); <br>#endif <br> <br>    // now really do the stop <br>    pMC-&gt;lpVtbl-&gt;Stop( pMC ); <br>    pMC-&gt;lpVtbl-&gt;Release( pMC ); <br>    ChangeStateTo( Stopped ); <br>    return; <br>} <br> <br>// Inform the user that an error occurred <br>PlayerMessageBox( IDS_CANT_STOP ); <br>    } <br> <br>} // OnMediaStop <br> <br> <br>// <br>// GetGraphEventHandle <br>// <br>// We use this to check for graph events <br>// <br>HANDLE GetGraphEventHandle() <br>{ <br>    return media.hGraphNotifyEvent; <br> <br>} // GetGraphEventHandle <br> <br> <br>// <br>// OnGraphNotify <br>// <br>// If the event handle is valid, then ask the graph if <br>// anything has happened (eg the graph has stopped...) <br>// <br>void OnGraphNotify() <br>{ <br>    IMediaEvent *pME; <br>    long lEventCode, lParam1, lParam2; <br> <br>    ASSERT( media.hGraphNotifyEvent != NULL ); <br> <br>    if( SUCCEEDED(media.pGraph-&gt;lpVtbl-&gt;QueryInterface(media.pGraph, &amp;IID_IMediaEvent, (void **) &amp;pME))){ <br>if( SUCCEEDED(pME-&gt;lpVtbl-&gt;GetEvent(pME, &amp;lEventCode, &amp;lParam1, &amp;lParam2, 0))) { <br>    if (lEventCode == EC_COMPLETE) { <br>OnMediaStop(); <br>    } else if ((lEventCode == EC_USERABORT) || <br>       (lEventCode == EC_ERRORABORT)) { <br>OnMediaAbortStop(); <br>    } <br>} <br>pME-&gt;lpVtbl-&gt;Release( pME ); <br>    } <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
