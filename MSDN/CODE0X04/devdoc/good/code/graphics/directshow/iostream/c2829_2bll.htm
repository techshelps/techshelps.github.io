<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SAMPIOS.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2829"></a>SAMPIOS.CPP</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>/* <br>See SampIOS.h for descriptions of these functions <br> <br>This file is built into SampIOS.lib, which may be linked into your <br>executables to supply the various output functions. <br>*/ <br> <br>#include &lt;streams.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;iostream.h&gt; <br>#include "SampIOS.h" <br> <br>ostream &amp; operator &lt;&lt;( ostream &amp; out, LPCWSTR pwStr ) <br>{ <br>    const int WideStrLen = lstrlenW(pwStr); <br>    char *const buffer = new char[WideStrLen+1]; <br>    const int bytes_used = <br>        WideCharToMultiByte ( CP_ACP, 0, pwStr, WideStrLen <br>                            , buffer, WideStrLen+1, 0, 0); <br>    ASSERT( bytes_used != FALSE ); <br>    buffer[bytes_used] = '\0'; <br>    out &lt;&lt; buffer; <br>    delete [] buffer; <br>    return out; <br>} <br> <br>ostream &amp; operator &lt;&lt;( ostream &amp; out, const GUID &amp; clsid ) <br>{ <br>    OLECHAR sz_clsid[CHARS_IN_GUID] = L"{Unknown}"; <br>    StringFromGUID2( clsid, sz_clsid, sizeof(sz_clsid)/sizeof(sz_clsid[0]) ); <br>    out &lt;&lt; sz_clsid; <br>    return out; <br>} <br> <br>ostream &amp; operator &lt;&lt;( ostream &amp; out, const IBaseFilter *const pIFilter ) <br>{ <br>    HRESULT hr; <br>    { <br>        FILTER_INFO filter_info; <br>        filter_info.pGraph = 0; <br>        hr = const_cast&lt;IBaseFilter *&gt;(pIFilter)-&gt;QueryFilterInfo( &amp;filter_info ); <br>        ASSERT( SUCCEEDED(hr) ); <br>        out &lt;&lt; '"' &lt;&lt; filter_info.achName &lt;&lt; '"'; <br>if (filter_info.pGraph) { <br>            filter_info.pGraph-&gt;Release(); <br>} <br>    } <br>    { <br>        CLSID clsid; <br>        hr = const_cast&lt;IBaseFilter *&gt;(pIFilter)-&gt;GetClassID( &amp;clsid ); <br>        ASSERT( SUCCEEDED(hr) ); <br>        out &lt;&lt; clsid; <br>    } <br>    return out; <br>} <br> <br>ostream &amp; operator &lt;&lt;( ostream &amp; out, const IEnumFilters *const pIEnumFilters ) <br>{ <br>    IBaseFilter * pIFilter; <br>    ULONG count; <br> <br>    while ( SUCCEEDED(const_cast&lt;IEnumFilters*&gt;(pIEnumFilters)-&gt;Next( 1, &amp;pIFilter, &amp;count )) &amp;&amp; (count &gt; 0)) <br>    { <br>        out &lt;&lt; pIFilter &lt;&lt; '\n'; <br>        pIFilter-&gt;Release(); <br>    } <br>    return out; <br>} <br> <br>ostream &amp; operator &lt;&lt;( ostream &amp; out, const IPin *const pIPin ) <br>{ <br>    LPWSTR      pin_id; <br>    PIN_INFO    pin_info; <br>    const IPin *p_connected_to; <br>    pin_info.pFilter = 0; <br> <br>    const_cast&lt;IPin*&gt;(pIPin)-&gt;QueryPinInfo( &amp;pin_info ); <br>    const_cast&lt;IPin*&gt;(pIPin)-&gt;QueryId( &amp;pin_id ); <br>    out &lt;&lt; pin_info.pFilter &lt;&lt; ':' &lt;&lt; pin_id &lt;&lt; '(' &lt;&lt; pin_info.achName &lt;&lt; ')'; <br>    if (pin_info.pFilter) { <br>        pin_info.pFilter-&gt;Release(); <br>pin_info.pFilter = 0; <br>    } <br>    CoTaskMemFree( pin_id ); <br> <br>    const_cast&lt;IPin*&gt;(pIPin)-&gt;ConnectedTo( const_cast&lt;IPin**&gt;(&amp;p_connected_to) ); <br>    if ( p_connected_to ) <br>    { <br>        out &lt;&lt; (pin_info.dir == PINDIR_OUTPUT ? "--&gt;" : "&lt;--"); <br>        const_cast&lt;IPin*&gt;(p_connected_to)-&gt;QueryPinInfo( &amp;pin_info ); <br>        const_cast&lt;IPin*&gt;(p_connected_to)-&gt;QueryId( &amp;pin_id ); <br>        out &lt;&lt; pin_info.pFilter &lt;&lt; ':' &lt;&lt; pin_id &lt;&lt; '(' &lt;&lt; pin_info.achName &lt;&lt; ')'; <br>        CoTaskMemFree( pin_id ); <br>        if (pin_info.pFilter) { <br>            pin_info.pFilter-&gt;Release(); <br>        } <br>        const_cast&lt;IPin*&gt;(p_connected_to)-&gt;Release(); <br>    } <br>    return out; <br>} <br> <br> <br>ostream &amp; operator &lt;&lt;( ostream &amp; out, const IEnumPins *const pIEnumPins ) <br>{ <br>    IPin * pIPin; <br>    ULONG count; <br> <br>    while ( SUCCEEDED(const_cast&lt;IEnumPins*&gt;(pIEnumPins)-&gt;Next( 1, &amp;pIPin, &amp;count )) &amp;&amp; (count &gt; 0)) <br>    { <br>        out &lt;&lt; pIPin &lt;&lt; '\n'; <br>        pIPin-&gt;Release(); <br>    } <br>    return out; <br>} <br> <br>ostream &amp; WriteAllPins( ostream &amp; out, const IBaseFilter *const piFilter ) <br>{ <br>    HRESULT hr; <br>    IEnumPins * pIEnumPins; <br>    hr = const_cast&lt;IBaseFilter*&gt;(piFilter)-&gt;EnumPins( &amp;pIEnumPins ); <br>    ASSERT( SUCCEEDED(hr) ); <br>    out &lt;&lt; pIEnumPins &lt;&lt; flush; <br>    pIEnumPins-&gt;Release(); <br>    return out; <br>} <br> <br>ostream &amp; operator &lt;&lt;( ostream &amp; out, const IFilterGraph *const piFilterGraph ) <br>{ <br>    IEnumFilters * pIEnumFilters; <br>    HRESULT hr = const_cast&lt;IFilterGraph*&gt;(piFilterGraph)-&gt;EnumFilters( &amp;pIEnumFilters ); <br>    ASSERT( SUCCEEDED(hr) ); <br> <br>    IBaseFilter * pIFilter; <br>    ULONG count; <br> <br>    while ( SUCCEEDED(const_cast&lt;IEnumFilters*&gt;(pIEnumFilters)-&gt;Next( 1, &amp;pIFilter, &amp;count )) &amp;&amp; (count &gt; 0)) <br>    { <br>        out &lt;&lt; pIFilter &lt;&lt; '\n'; <br>        WriteAllPins( out, pIFilter ); <br>        pIFilter-&gt;Release(); <br>    } <br>    pIEnumFilters-&gt;Release(); <br> <br>    return out &lt;&lt; endl; <br>} <br> <br>extern "C" void DumpFilterInfo( const IBaseFilter * pIFilter ) <br>{ <br>    cout &lt;&lt; pIFilter &lt;&lt; endl; <br>} <br> <br>extern "C" void DumpAllFilters( const IFilterGraph * piFilterGraph ) <br>{ <br>    HRESULT hr; <br>    IEnumFilters * pIEnumFilters; <br>    hr = const_cast&lt;IFilterGraph*&gt;(piFilterGraph)-&gt;EnumFilters( &amp;pIEnumFilters ); <br>    ASSERT( SUCCEEDED(hr) ); <br>    cout &lt;&lt; pIEnumFilters &lt;&lt; flush; <br>    pIEnumFilters-&gt;Release(); <br>} <br> <br>extern "C" void DumpPinInfo( const IPin * pIPin ) <br>{ <br>    cout &lt;&lt; pIPin &lt;&lt; endl; <br>} <br> <br>extern "C" void DumpAllPins( const IBaseFilter * piFilter ) <br>{ <br>    WriteAllPins( cout, piFilter ); <br>} <br> <br>extern "C" void DumpFilterGraph( const IFilterGraph * piFilterGraph ) <br>{ <br>    cout &lt;&lt; piFilterGraph &lt;&lt; flush; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
