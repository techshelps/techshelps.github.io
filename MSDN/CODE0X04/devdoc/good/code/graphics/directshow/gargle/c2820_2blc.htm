<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GARGLE.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2820"></a>GARGLE.CPP</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br>// <br>// Gargle Filter - A Transform filter that turns humans into daleks!!! <br>// <br>//     What This Sample Illustrates <br>// <br>// An in-place transform filter. <br>// Saving and restoring properties in a saved graph. <br>// Handling decompressed sound. <br>// Use of debug macros ASSERT, DbgBreak, DbgLog, DbgBreakPoint <br>// <br>// <br>//     Summary <br>// <br>// A simple, in-place transform, audio effect which modifies the data <br>// in the samples that pass through it.  The effect is an amplitude <br>// modulation with a synthesised secondary wave function. <br>// The secondary wave can be a triangular or square wave.  A properties <br>// sheet allows the shape and frequency of the secondary wave to be chosen. <br>// <br>// At low modulation frequencies it sounds like a tremolo, at higher <br>// modulation frequencies it sounds like a distortion, adding extra <br>// frequencies above and below the original unmodulated sound. <br>// <br>// <br>//     Demonstration instructions <br>// <br>// First build the sample and get it registered (see gargle.reg) <br>// Start GRAPHEDT available in the ActiveMovie SDK tools. Drag and drop into <br>// the tool any WAV file or any MPEG, AVI or MOV file which has a sound track. <br>// A graph will be built to render the file.  From the Graph menu select <br>// Insert filters and insert Gargle.  (If it is not on the list then you <br>// failed to register it properly.  If it fails to load then you either <br>// didn't build it properly or the registration does not correctly point to <br>// the path where gargle.ax is now found.) <br>// In the graph displayed, find the audio renderer.  Disconnect it (click on <br>// the incoming arrow and then press the Delete key). <br>// Create a connection between the same two filters via gargle.  (Drag from <br>// previos arrow tail pin to gargle input pin.  Drag from Gargle output pin to <br>// audio renderer input pin). <br>// Right click on the Gargle box to bring up the property page.  Click on <br>// the GraphEdt Play button and experiment with different properties. <br>// <br>// <br>//     Implementation <br>// <br>// This filter has one input pin, one output pin and <br>// does its transform in-place (i.e. without copying the data) <br>// on the push thread (i.e. it is called with a buffer, which it <br>// transforms and gives to the next filter downstream.  It is <br>// then blocked until that filter returns.  It then returns <br>// to its own caller.) <br>// <br>// The filter modulates sound by multiplying the value of each sample <br>// by the value of triangular or square waveform.  Depending on <br>// the frequency of the modulation it will sound like recurent fading, <br>// like a tremolo or like a sort of distortion. <br>// <br>// It has a properties page which allows control of two properties <br>// (the frequency and shape of the modulating waveform).  It exports a <br>// private interface (IGargle) which the properties page uses to get or <br>// set the frequency and/or shape. <br>// <br>// As far as possible the properties page code has been separated and <br>// is implemented in the files GargProp.* whereas the basic filter <br>// code is in this file and its header gargle.h. <br>// <br>// The word "sample" is used in two senses.  It means either a sound sample <br>// which is 8 or 16 bits of data representing the instantaneous sound pressure <br>// or else it means an ActiveMovie sample which is the unit of data that is <br>// passed between filters, i.e. a buffer full of sound samples. <br>// <br>// <br>//    Known problems ("features NOT illustrated by this sample"): <br>// <br>// 1. The properties sheet does NOT give real-time control. <br>//    Moving the knob immediately changes the modulation being applied <br>//    to the samples being processed by the filter, but there can then <br>//    be a long latency before those data are rendered.  (To avoid audio <br>//    break-up the audio renderer typically keeps a sizeable queue of <br>//    samples ready to be played). <br>// 2. Because it operates by alterating the data in the samples <br>//    it cannot work on a read-only stream.  As defined here <br>//    it refuses such a connection (e.g. it cannot connect directly <br>//    to the output of the "infinite tee" filter). <br>//    In such a case the intelligent graph-building code will often <br>//    make the connection by inserting an "ACM wrapper" filter. <br>//    This works but is rather inefficient. <br>// <br>// <br>//      Files <br>// <br>// gargle.cpp    This file - main implementation <br>// gargprop.h    Class definition of properties class (used in gargle.cpp) <br>// gargprop.cpp  Implementation of the properties sheet <br>// gargprop.rc   Defines the property page dialog <br>// resource.h    constants shared between gargprop.rc and gargprop.cpp <br>// igargle.h     Interface between gargle and gargprop <br>// garguids.h    The public class ids (only referred to in gargle.cpp) <br>// gargle.reg    What goes in the registry <br>// gargle.def    Imports and exports <br>// makefile      How to build it <br>// <br>// <br>//     Base classes used (refer to docs for diagram of what they inherit): <br>// <br>// CTransInPlaceFilter <br>// CPersistStream <br>// CBasePropertyPage <br> <br>//============================================================================= <br>//============================================================================= <br> <br>#include &lt;streams.h&gt;              // ActiveMovie, includes windows <br> <br>// Eliminate two expected level 4 warnings from the Microsoft compiler. <br>// The class does not have an assignment or copy operator, and so cannot <br>// be passed by value.  This is normal.  This file compiles clean at the <br>// highest (most picky) warning level (-W4). <br>#pragma warning(disable: 4511 4512) <br> <br> <br>#include &lt;initguid.h&gt; <br>#if (1100 &gt; _MSC_VER) <br>#include &lt;olectlid.h&gt; <br>#else <br>#include &lt;olectl.h&gt; <br>#endif <br>#include "garguids.h"             // Our own uuids <br>#include "igargle.h"              // IGargle (properties) <br>#include "gargprop.h"             // CGargleProperties <br> <br> <br>//------------------------------------------------------------------------ <br>// CGargle - the gargle filter class <br>//------------------------------------------------------------------------ <br> <br>class CGargle <br>    // Inherited classes <br>    : public CTransInPlaceFilter       // Main ActiveMovie interfaces <br> <br>    , public ISpecifyPropertyPages     // Needed for properties only <br> <br>    , public IGargle                   // Needed for properties only. <br>                                       // Without this the PURE virtual <br>                                       // functions in IGargle will not <br>                                       // be implemented.  (If they ever <br>                                       // got called the entire app would <br>                                       // silently ExitProcess!!). <br> <br>    , public CPersistStream            // Implements IPersistStream <br>                                       // to alow saving of properties <br>                                       // in a saved graph. <br>{ <br> <br>public: <br> <br>    static CUnknown * WINAPI CreateInstance(LPUNKNOWN punk, HRESULT *phr); <br> <br>    DECLARE_IUNKNOWN; <br> <br>    // <br>    // --- CTransInPlaceFilter Overrides -- <br>    // <br> <br>    HRESULT CheckInputType(const CMediaType *mtIn); <br> <br>    // Basic COM - used here to reveal our property interface. <br>    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv); <br> <br>    // CPersistStream overrides <br>    HRESULT WriteToStream(IStream *pStream); <br>    HRESULT ReadFromStream(IStream *pStream); <br>    int SizeMax(); <br>    STDMETHODIMP GetClassID(CLSID *pClsid); <br> <br>    // --- ISpecifyPropertyPages --- <br> <br>    // return our property pages <br>    STDMETHODIMP GetPages(CAUUID * pPages); <br> <br>    // IGargle - private interface to put/set properties <br>    STDMETHODIMP get_GargleRate(int *GargleRate); <br>    STDMETHODIMP put_GargleRate(int GargleRate); <br>    STDMETHODIMP put_DefaultGargleRate(void); <br>    STDMETHODIMP put_GargleShape(int iGargleShape); <br>    STDMETHODIMP get_GargleShape(int *GargleShape); <br> <br>private: <br> <br>    // Constructor <br>    CGargle(TCHAR *tszName, LPUNKNOWN punk, HRESULT *phr); <br> <br>    // Overrides the PURE virtual Transform of CTransInPlaceFilter base class <br>    // This is where the "real work" is done. <br>    HRESULT Transform(IMediaSample *pSample); <br> <br>    // This is where the real work is really done (called from Transform) <br>    void MessItAbout(PBYTE pb, int cb); <br> <br>    // Overrides a CTransformInPlace function.  Called as part of connecting. <br>    virtual HRESULT SetMediaType(PIN_DIRECTION direction, const CMediaType *pmt); <br> <br>    // If there are multiple instances of this filter active, it's <br>    // useful for debug messages etc. to know which one this is. <br>    // This variable has no other purpose. <br>    static m_nInstanceCount;                   // total instances <br>    int m_nThisInstance; <br> <br>    const int           m_DefaultGargleRate;   // The default rate (Hz) <br>    int                 m_GargleRate;          // The current rate (Hz) <br>    int                 m_Shape;               // 0==triangle, 1==square <br>    int                 m_SamplesPerSec;       // Current sample format <br>    int                 m_BytesPerSample;      // Current sample format <br>    int                 m_Channels;            // Current sample format <br>    int                 m_Phase;               // See MessItAbout in gargle.cpp <br>    CCritSec            m_GargleLock;          // To serialise access. <br> <br>}; // class CGargle <br> <br> <br>//------------------------------------------------------------------------ <br>// Implementation <br>//------------------------------------------------------------------------ <br> <br> <br>// Put out the name of a function and instance on the debugger. <br>// Invoke this at the start of functions to allow a trace. <br>#define DbgFunc(a) DbgLog(( LOG_TRACE                        \ <br>                          , 2                                \ <br>                          , TEXT("CGargle(Instance %d)::%s") \ <br>                          , m_nThisInstance                  \ <br>                          , TEXT(a)                          \ <br>                         )); <br> <br> <br>// Self-registration data structures <br> <br>const AMOVIESETUP_MEDIATYPE <br>sudPinTypes =   { &amp;MEDIATYPE_Audio        // clsMajorType <br>                , &amp;MEDIASUBTYPE_NULL };   // clsMinorType <br> <br>const AMOVIESETUP_PIN <br>psudPins[] = { { L"Input"            // strName <br>               , FALSE               // bRendered <br>               , FALSE               // bOutput <br>               , FALSE               // bZero <br>               , FALSE               // bMany <br>               , &amp;CLSID_NULL         // clsConnectsToFilter <br>               , L"Output"           // strConnectsToPin <br>               , 1                   // nTypes <br>               , &amp;sudPinTypes        // lpTypes <br>               } <br>             , { L"Output"           // strName <br>               , FALSE               // bRendered <br>               , TRUE                // bOutput <br>               , FALSE               // bZero <br>               , FALSE               // bMany <br>               , &amp;CLSID_NULL         // clsConnectsToFilter <br>               , L"Input"            // strConnectsToPin <br>               , 1                   // nTypes <br>               , &amp;sudPinTypes        // lpTypes <br>               } <br>             }; <br> <br>const AMOVIESETUP_FILTER <br>sudGargle = { &amp;CLSID_Gargle                   // class id <br>            , L"Gargle"                       // strName <br>            , MERIT_DO_NOT_USE                // dwMerit <br>            , 2                               // nPins <br>            , psudPins                        // lpPin <br>            }; <br> <br>// Needed for the CreateInstance mechanism <br>CFactoryTemplate g_Templates[2]= { { L"Gargle" <br>                                   , &amp;CLSID_Gargle <br>                                   , CGargle::CreateInstance <br>                                   , NULL <br>                                   , &amp;sudGargle <br>                                   } <br>                                 , { L"Gargle Property Page" <br>                                   , &amp;CLSID_GargProp <br>                                   , CGargleProperties::CreateInstance <br>                                   } <br>                                 }; <br> <br>int g_cTemplates = sizeof(g_Templates)/sizeof(g_Templates[0]); <br> <br>// initialise the static instance count. <br>int CGargle::m_nInstanceCount = 0; <br> <br> <br> <br>// <br>// CGargle::Constructor <br>// <br>// Construct a CGargle object. <br>// <br>CGargle::CGargle(TCHAR *tszName, LPUNKNOWN punk, HRESULT *phr) <br>    : CTransInPlaceFilter (tszName, punk, CLSID_Gargle, phr) <br>    , CPersistStream(punk, phr) <br>    , m_DefaultGargleRate (DefaultGargleRate) <br>    , m_GargleRate        (DefaultGargleRate) <br>    , m_SamplesPerSec     (0) <br>    , m_BytesPerSample    (0) <br>    , m_Channels          (0) <br>    , m_Phase             (0) <br>    , m_Shape             (0) <br>{ <br>    m_nThisInstance = ++m_nInstanceCount; // Useful for debug, no other purpose <br> <br>    DbgFunc("CGargle"); <br> <br>} // (CGargle constructor) <br> <br> <br>// <br>// CreateInstance <br>// <br>// Override CClassFactory method. <br>// Provide the way for COM to create a CGargle object. <br>// <br>CUnknown * WINAPI CGargle::CreateInstance(LPUNKNOWN punk, HRESULT *phr) <br>{ <br> <br>    CGargle *pNewObject = new CGargle(NAME("Gargle Filter"), punk, phr); <br>    if (pNewObject == NULL) { <br>        *phr = E_OUTOFMEMORY; <br>    } <br> <br>    return pNewObject; <br> <br>} // CreateInstance <br> <br> <br> <br>// <br>// NonDelegatingQueryInterface <br>// <br>// Override CUnknown method. <br>// Reveal our persistent stream, property pages and IGargle interfaces. <br>// Anyone can call our private interface so long as they know the secret UUID. <br>// <br>STDMETHODIMP CGargle::NonDelegatingQueryInterface(REFIID riid, void **ppv) <br>{ <br>    CheckPointer(ppv,E_POINTER); <br> <br>    if (riid == IID_IGargle) { <br>        return GetInterface((IGargle *) this, ppv); <br>    } else if (riid == IID_ISpecifyPropertyPages) { <br> <br>        return GetInterface((ISpecifyPropertyPages *) this, ppv); <br>    } else if (riid == IID_IPersistStream) { <br>        return GetInterface((IPersistStream *) this, ppv); <br>    } else { <br>        // Pass the buck <br>        return CTransInPlaceFilter::NonDelegatingQueryInterface(riid, ppv); <br>    } <br> <br>} // NonDelegatingQueryInterface <br> <br> <br>// GetClassID <br>// <br>// Override CBaseMediaFilter method for interface IPersist <br>// Part of the persistent file support.  We must supply our class id <br>// which can be saved in a graph file and used on loading a graph with <br>// a gargle in it to instantiate this filter via CoCreateInstance. <br>// <br>STDMETHODIMP CGargle::GetClassID(CLSID *pClsid) <br>{ <br>    if (pClsid==NULL) { <br>        return E_POINTER; <br>    } <br>    *pClsid = CLSID_Gargle; <br>    return NOERROR; <br> <br>} // GetClassID <br> <br> <br>// <br>// SizeMax <br>// <br>// Override CPersistStream method. <br>// State the maximum number of bytes we would ever write in a file <br>// to save our properties. <br>// <br>int CGargle::SizeMax() <br>{ <br>    // When an int is expanded as characters it takes at most 12 characters <br>    // including a trailing delimiter. <br>    // Wide chars doubles this and we want two ints. <br>    // <br>    return 48; <br> <br>}  // SizeMax <br> <br> <br>// <br>// WriteToStream <br>// <br>// Override CPersistStream method. <br>// Write our properties to the stream. <br>// <br>HRESULT CGargle::WriteToStream(IStream *pStream) <br>{ <br>    HRESULT hr; <br>    hr = WriteInt(pStream, m_GargleRate); <br>    if (FAILED(hr)) return hr; <br>    hr = WriteInt(pStream, m_Shape); <br>    if (FAILED(hr)) return hr; <br>    return NOERROR; <br>} // WriteToStream <br> <br> <br>// <br>// ReadFromStream <br>// <br>// Override CPersistStream method. <br>// Read our properties from the stream. <br>// <br>HRESULT CGargle::ReadFromStream(IStream *pStream) <br>{ <br>    HRESULT hr; <br>    m_GargleRate = ReadInt(pStream, hr); <br>    if (FAILED(hr)) return hr; <br>    m_Shape = ReadInt(pStream, hr); <br>    if (FAILED(hr)) return hr; <br>    return NOERROR; <br>} // ReadFromStream <br> <br> <br>// <br>// MessItabout <br>// <br>// Mess the sound about by modulating it with a waveform. <br>// We know the frequency of the modulation (from the slider setting <br>// which we were told through our internal interface, IGargle, and <br>// which we stored in m_GargleRate).  At the end of the call we <br>// record what part of the waveform we finished at in m_Phase and <br>// we resume at that point next time. <br>// Uses and updates m_Phase <br>// Uses m_SamplesPerSec, m_Channels, m_GargleRate, m_Shape <br>// <br>void CGargle::MessItAbout(PBYTE pb, int cb) <br>{ <br>    CAutoLock foo(&amp;m_GargleLock); <br> <br>    // We know how many samples per sec and how <br>    // many channels so we can calculate the modulation period in samples. <br>    // <br>    int Period = (m_SamplesPerSec * m_Channels) / m_GargleRate; <br> <br>    while (cb&gt;0) { <br>       --cb; <br> <br>       // If m_Shape is 0 (triangle) then we multiply by a triangular waveform <br>       // that runs 0..Period/2..0..Period/2..0... else by a square one that <br>       // is either 0 or Period/2 (same maximum as the triangle) or zero. <br>       // <br>       { <br>           // m_Phase is the number of samples from the start of the period. <br>           // We keep this running from one call to the next, <br>           // but if the period changes so as to make this more <br>           // than Period then we reset to 0 with a bang.  This may cause <br>           // an audible click or pop (but, hey! it's only a sample!) <br>           // <br>           ++m_Phase; <br>           if (m_Phase&gt;Period) m_Phase = 0; <br> <br>           int M = m_Phase;      // m is what we modulate with <br> <br>           if (m_Shape ==0 ) {   // Triangle <br>               if (M&gt;Period/2) M = Period-M;  // handle downslope <br>           } else {             // Square wave <br>               if (M&lt;=Period/2) M = Period/2; else M = 0; <br>           } <br> <br>           if (m_BytesPerSample==1) { <br> <br>               // 8 bit sound uses 0..255 representing -128..127 <br>               // Any overflow, even by 1, would sound very bad. <br>               // so we clip paranoically after modulating. <br>               // I think it should never clip by more than 1 <br>               // <br>               int i = *pb-128;               // sound sample, zero based <br>               i = (i*M*2)/Period;            // modulate <br>               if (i&gt;127) i = 127;            // clip <br>               if (i&lt;-128) i = -128; <br> <br>               *pb = (unsigned char)(i+128);  // reset zero offset to 128 <br> <br>           } else if (m_BytesPerSample==2) { <br> <br>               // 16 bit sound uses 16 bits properly (0 means 0) <br>               // We still clip paranoically <br>               // <br>               short int *psi = (short int *)pb; <br>               int i = *psi;                  // in a register, we might hope <br>               i = (i*M*2)/Period;            // modulate <br>               if (i&gt;32767) i = 32767;        // clip <br>               if (i&lt;-32768) i = -32768; <br>               *psi = (short)i; <br>               ++pb;  // nudge it on another 8 bits here to get a 16 bit step <br>               --cb;  // and nudge the count too. <br> <br>           } else { <br> <br>               DbgBreak("Too many bytes per sample"); <br>               // just leave it alone! <br> <br>           } <br>       } <br>       ++pb;   // move on 8 bits to next sound sample <br>    } <br>} // MessItAbout <br> <br> <br>// <br>// Transform <br>// <br>// Override CTransInPlaceFilter method. <br>// Convert the input ActiveMovie sample into the output ActiveMovie sample. <br>// <br>HRESULT CGargle::Transform(IMediaSample *pSample) <br>{ <br> <br>    DbgFunc("Transform"); <br> <br>    // Get the details of the data (address, length) <br>    // <br>    BYTE *pSampleBuffer; <br>    int iSize = pSample-&gt;GetActualDataLength(); <br>    pSample-&gt;GetPointer(&amp;pSampleBuffer); <br> <br> <br>    // Actually transform the data <br>    // <br>    MessItAbout(pSampleBuffer, iSize ); <br> <br>    return NOERROR; <br> <br>} // Transform <br> <br> <br>// <br>// CheckInputType <br>// <br>// Override CTransformFilter method. <br>// Part of the Connect process. <br>// Ensure that we do not get connected to formats that we can't handle. <br>// We only work for wave audio, 8 or 16 bit, uncompressed. <br>// <br>HRESULT CGargle::CheckInputType(const CMediaType *pmt) <br>{ <br> <br>    DisplayType("CheckInputType", pmt); <br> <br>    WAVEFORMATEX *pwfx = (WAVEFORMATEX *) pmt-&gt;pbFormat; <br> <br>    // Reject non-Audio types. <br>    // <br>    if (pmt-&gt;majortype != MEDIATYPE_Audio) { <br>        return VFW_E_TYPE_NOT_ACCEPTED; <br>    } <br> <br> <br>    // Reject invalid format blocks <br>    // <br>    if (pmt-&gt;formattype != FORMAT_WaveFormatEx) <br>        return VFW_E_TYPE_NOT_ACCEPTED; <br> <br>    // Reject compressed audio <br>    // <br>    if (pwfx-&gt;wFormatTag != WAVE_FORMAT_PCM) { <br>        return VFW_E_TYPE_NOT_ACCEPTED; <br>    } <br> <br>    // Accept only 8 or 16 bit <br>    // <br>    if (pwfx-&gt;wBitsPerSample!=8 &amp;&amp; pwfx-&gt;wBitsPerSample!=16) { <br>        return VFW_E_TYPE_NOT_ACCEPTED; <br>    } <br> <br>    return NOERROR; <br> <br>} // CheckInputType <br> <br> <br>// <br>// SetMediaType <br>// <br>// Override CTransformFilter method. <br>// Called when a connection attempt has succeeded. If the output pin <br>// is being connected and the input pin's media type does not agree then we <br>// reconnect the input (thus allowing its media type to change,) and vice versa. <br>// <br>HRESULT CGargle::SetMediaType(PIN_DIRECTION direction,const CMediaType *pmt) <br>{ <br> <br>    DbgFunc("SetMediaType"); <br> <br>    // Record what we need for doing the actual transform <br> <br>    WAVEFORMATEX *pwfx = (WAVEFORMATEX *) pmt-&gt;Format(); <br>    m_Channels =  pwfx-&gt;nChannels; <br>    m_SamplesPerSec = pwfx-&gt;nSamplesPerSec; <br>    // Ignored: pwfx-&gt;nAvgBytesPerSec; <br>    // Ignored: pwfx-&gt;nBlockAlign; <br>    m_BytesPerSample = pwfx-&gt;wBitsPerSample/8; <br> <br>    // Call the base class to do its thing <br>    CTransInPlaceFilter::SetMediaType(direction, pmt); <br> <br>    // Reconnect where necessary. <br>    if( m_pInput-&gt;IsConnected() &amp;&amp; m_pOutput-&gt;IsConnected() ){ <br>        FILTER_INFO fInfo; <br> <br>        QueryFilterInfo( &amp;fInfo ); <br> <br>        if (direction == PINDIR_OUTPUT &amp;&amp; *pmt != m_pInput-&gt;CurrentMediaType() ) <br>            fInfo.pGraph-&gt;Reconnect( m_pInput ); <br> <br>        QueryFilterInfoReleaseGraph( fInfo ); <br> <br>        ASSERT(!(direction == PINDIR_INPUT &amp;&amp; *pmt != m_pOutput-&gt;CurrentMediaType())); <br>    } <br> <br>    return NOERROR; <br> <br>} // SetMediaType <br> <br> <br>// ==============Implementation of the private IGargle interface ========== <br>// ==================== needed to support the property page =============== <br> <br> <br>// <br>// get_GargleRate <br>// <br>// Set *GargleRate to our current rate (Hz) <br>// <br>STDMETHODIMP CGargle::get_GargleRate(int *GargleRate) <br>{ <br> <br>    CAutoLock foo(&amp;m_GargleLock); <br> <br>    *GargleRate = m_GargleRate; <br> <br>    DbgLog((LOG_TRACE, 1, TEXT("get_GargleRate: %d"), *GargleRate)); <br> <br>    return NOERROR; <br> <br>} // get_GargleRate <br> <br> <br> <br> <br>// <br>// put_GargleRate <br>// <br>// Set the current rate from GargleRate. <br>// <br>STDMETHODIMP CGargle::put_GargleRate(int GargleRate) <br>{ <br> <br>    CAutoLock foo(&amp;m_GargleLock); <br> <br>    m_GargleRate = GargleRate; <br>    CPersistStream::SetDirty(TRUE);             // Need to scribble <br> <br>    DbgLog((LOG_TRACE, 1, TEXT("put_GargleRate: %x"), m_GargleRate)); <br> <br>    return NOERROR; <br> <br>} // put_GargleRate <br> <br> <br>// <br>// put_DefaultGargleRate <br>// <br>// Set the current gargle rate to the default <br>// <br>STDMETHODIMP CGargle::put_DefaultGargleRate(void) <br>{ <br> <br>    CAutoLock foo(&amp;m_GargleLock); <br> <br>    DbgLog((LOG_TRACE, 1, TEXT("put_DefaultGargleRate"))); <br> <br>    m_GargleRate = m_DefaultGargleRate; <br>    CPersistStream::SetDirty(TRUE);                     // Need to scribble <br> <br>    return NOERROR; <br> <br>} // put_DefaultGargleRate <br> <br> <br>// <br>// put_GargleShape <br>// <br>// Alter the waveform between triangle and square <br>// <br>STDMETHODIMP CGargle::put_GargleShape(int iGargleShape) <br>{ <br>    if (iGargleShape&lt;0 || iGargleShape&gt;1) <br>        return E_INVALIDARG; <br>    m_Shape = iGargleShape; <br>    CPersistStream::SetDirty(TRUE);                     // Need to scribble <br>    return NOERROR; <br>} // put_GargleShape <br> <br> <br>// <br>// get_GargleShape <br>// <br>// Return 0 if the current shape is triangle, 1 if it's square <br>// <br>STDMETHODIMP CGargle::get_GargleShape(int *GargleShape) <br>{ <br> <br>    *GargleShape = m_Shape; <br>    return NOERROR; <br> <br>} // get_GargleShape <br> <br> <br>// ==============Implementation of the IPropertypages Interface =========== <br> <br>// <br>// GetPages <br>// <br>STDMETHODIMP CGargle::GetPages(CAUUID * pPages) <br>{ <br> <br>    pPages-&gt;cElems = 1; <br>    pPages-&gt;pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID)); <br>    if (pPages-&gt;pElems == NULL) { <br>        return E_OUTOFMEMORY; <br>    } <br>    *(pPages-&gt;pElems) = CLSID_GargProp; <br> <br>    return NOERROR; <br> <br>} // GetPages <br> <br> <br>/******************************Public*Routine******************************\ <br>* exported entry points for registration and <br>* unregistration (in this case they only call <br>* through to default implmentations). <br>\**************************************************************************/ <br> <br>STDAPI <br>DllRegisterServer() <br>{ <br>  return AMovieDllRegisterServer2( TRUE ); <br>} <br> <br> <br>STDAPI <br>DllUnregisterServer() <br>{ <br>  return AMovieDllRegisterServer2( FALSE ); <br>} <br> <br>#pragma warning(disable: 4514) // "unreferenced inline function has been removed" <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
