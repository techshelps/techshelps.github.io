<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TRPROP.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2952"></a>TRPROP.CPP</h2>
<pre><code>//========================================================================== <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//-------------------------------------------------------------------------- <br>// <br>// trprop.cpp - IAMExtTransport Property Page for External Device (VCR) Filter <br>// <br> <br>#include &lt;streams.h&gt; <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;commctrl.h&gt; <br>#include &lt;olectl.h&gt; <br>#include &lt;memory.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;tchar.h&gt; <br> <br>#include "ctimecod.h" <br>#include "cdevcom.h" <br>#include "cvcrutil.h" <br>#include "vcruids.h" <br> <br>#include "resource.h" <br>#include "fvcrctrl.h" <br>#include "trprop.h" <br> <br>// see vcrprop.cpp for a description of how these tables work <br>typedef struct tagPARMVALUEINFO{ <br>int ValueType;// ED_STR || ED_NUM <br>int StringID; <br>int DevCap; <br>} PARMVALUEINFO; <br> <br>#define ED_STR 1 <br>#define ED_NUM 2 <br>#define ED_VAL 3 <br>#define ED_DBL 4 <br> <br>static PARMVALUEINFO ModeTable[] = { <br>{ ED_STR, IDS_EDSTAT_MODE, ED_MODE } <br>}; <br>const int MaxModeParm = sizeof(ModeTable) / sizeof(ModeTable[0]); <br> <br>// this table is for matching modes to the list box.  We comment <br>// out the modes not supported by the sample machine <br>static long ModeValueTable[][2] = { <br>//{ IDS_MODE_EDIT_CUE, ED_MODE_EDIT_CUE }, <br>{ IDS_MODE_FF, ED_MODE_FF },  <br>{ IDS_MODE_FREEZE, ED_MODE_FREEZE },  <br>{ IDS_MODE_PLAY, ED_MODE_PLAY }, <br>{ IDS_MODE_RECORD, ED_MODE_RECORD },  <br>//{ IDS_MODE_RECORD_STROBE, ED_MODE_RECORD_STROBE },  <br>{ IDS_MODE_REW, ED_MODE_REW }, <br>//{ IDS_MODE_SHUTTLE, ED_MODE_SHUTTLE }, <br>//{ IDS_MODE_STEP, ED_MODE_STEP },  <br>{ IDS_MODE_STOP, ED_MODE_STOP },  <br>{ IDS_MODE_THAW, ED_MODE_THAW } <br>}; <br>const int MaxModeValue = sizeof(ModeValueTable)/(sizeof(ModeValueTable[0][0]) + <br>   sizeof(ModeValueTable[0][1]) );  <br> <br>// * <br>// * CExtTranProperties - A few selected properties in IAMExtTransport <br>// * <br> <br>//--------------------------------------------------------- <br>// <br>// CreateInstance <br>// <br>//--------------------------------------------------------- <br>CUnknown *CExtTransProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr) <br>{ <br>    CUnknown *punk = new CExtTransProperties(lpunk, phr); <br>    if (punk == NULL) { <br>*phr = E_OUTOFMEMORY; <br>    } <br> <br>    return punk; <br>} <br> <br>//--------------------------------------------------------- <br>// <br>// CExtTransProperties::Constructor <br>// <br>//--------------------------------------------------------- <br>CExtTransProperties::CExtTransProperties(LPUNKNOWN lpunk, HRESULT *phr) <br>    : CBasePropertyPage(NAME("VCR Transport Property Page"),lpunk, <br>        IDD_DIALOG2, IDS_PROP_TRANS), <br>m_pExtDevice(NULL), <br>m_pExtTransport(NULL), <br>    m_bIsInitialized(FALSE), <br>m_bSetHourGlass(FALSE) <br>{ <br> <br>} <br>//--------------------------------------------------------- <br>// <br>// Message handler <br>// <br>//--------------------------------------------------------- <br>BOOL CExtTransProperties::OnReceiveMessage(HWND hwnd, <br>                                        UINT uMsg, <br>                                        WPARAM wParam, <br>                                        LPARAM lParam) <br>{ <br>// need a pointer to this object <br>CExtTransProperties *pThis =  <br>(CExtTransProperties *) GetWindowLong(m_Dlg, DWL_USER); <br> <br>    switch (uMsg) <br>    { <br>        case WM_INITDIALOG: <br>        { <br>OnInitDialog(); <br>break; <br>        } <br> <br>        case WM_COMMAND: <br>        { <br>            if (m_bIsInitialized) { <br>if (HIWORD(wParam) == LBN_SELCHANGE) <br>                SetDirty(); <br>  OnCommand( (int) LOWORD( wParam ), (int) HIWORD( wParam ) ); <br>} <br>break; <br>        } <br>} <br>    return CBasePropertyPage::OnReceiveMessage(hwnd,uMsg,wParam,lParam); <br>} <br>//--------------------------------------------------------- <br>// <br>// Property page initialization <br>// <br>//--------------------------------------------------------- <br>HRESULT CExtTransProperties::OnConnect(IUnknown *pUnknown) <br>{ <br>// Get the objects on which properties we want to set <br>    ASSERT(m_pExtDevice == NULL); <br> <br>HRESULT hr = pUnknown-&gt;QueryInterface( IID_IAMExtDevice, <br>(void **) &amp;m_pExtDevice ); <br>if( FAILED( hr ) ) <br>    return hr; <br>ASSERT( m_pExtDevice != NULL ); <br>ASSERT(m_pExtTransport == NULL); <br>hr = pUnknown-&gt;QueryInterface( IID_IAMExtTransport,  <br>(void **) &amp;m_pExtTransport ); <br>if( FAILED( hr ) ) <br>    return hr; <br>ASSERT( m_pExtTransport != NULL ); <br>    m_bIsInitialized = FALSE ; <br>    return NOERROR; <br>} <br>//--------------------------------------------------------- <br>// <br>// Property page shutdown <br>// <br>//--------------------------------------------------------- <br>HRESULT CExtTransProperties::OnDisconnect() <br>{ <br>    if (m_pExtDevice == NULL){ <br>        return E_UNEXPECTED; <br>    } <br>m_pExtDevice-&gt;Release(); <br>m_pExtDevice = NULL; <br> <br>if (m_pExtTransport == NULL){ <br>        return E_UNEXPECTED; <br>    } <br> <br>m_pExtTransport-&gt;Release(); <br>m_pExtTransport = NULL; <br> <br>    return NOERROR; <br>} <br>//--------------------------------------------------------- <br>// <br>// Property page activation <br>// <br>//--------------------------------------------------------- <br>HRESULT CExtTransProperties::OnActivate() <br>{ <br>    m_bIsInitialized = TRUE; <br>    return NOERROR; <br>} <br>//--------------------------------------------------------- <br>// <br>// The real initialization work is done here <br>// <br>//--------------------------------------------------------- <br>BOOL CExtTransProperties::OnInitDialog( void ) <br>{ <br>int i; <br>TCHAR buf[64]; <br> <br>    InitCommonControls(); <br>     <br>// get the window handle <br>m_hwndModeList = GetDlgItem(m_Dlg, IDC_TRMODE_VALUE); <br>ASSERT(m_hwndModeList); <br> <br>SendMessage(m_hwndModeList, WM_SETREDRAW, TRUE, 0L); <br>// fill the mode list box <br>for (i = 0; i &lt; MaxModeValue; i++) { <br>LoadString(g_hInst, ModeValueTable[i][0], (LPSTR)buf, 64 ); <br>    SendMessage(m_hwndModeList, LB_ADDSTRING, 0, (LPARAM)(LPSTR)buf); <br>    } <br> <br>// set media state and local control radio buttons, and mode listbox <br>UpdateControls(); <br> <br>m_hHourGlass = LoadCursor(NULL, IDC_WAIT); <br>m_hCurrentCursor = GetCursor(); <br>    return (LRESULT) 1; <br>} <br>//--------------------------------------------------------- <br>// <br>// Handle the property page commands <br>// <br>//--------------------------------------------------------- <br>BOOL CExtTransProperties::OnCommand( int iButton, int iNotify ) <br>{ <br>CExtTransProperties *pThis =  <br>(CExtTransProperties *) GetWindowLong(m_Dlg, DWL_USER); <br>    ASSERT(pThis); <br>    switch( iButton ){ <br>case IDC_MS_SPINUP: <br>pThis-&gt;m_CurMediaState = ED_MEDIA_SPIN_UP; <br>break; <br>case IDC_MS_SD: <br>pThis-&gt;m_CurMediaState = ED_MEDIA_SPIN_DOWN; <br>break; <br>case IDC_MS_UL: <br>pThis-&gt;m_CurMediaState = ED_MEDIA_UNLOAD; <br>pThis-&gt;m_bSetHourGlass = TRUE; <br>break; <br>case IDC_TRLOC_ON: <br>pThis-&gt;m_CurLocalState = OATRUE; <br>break; <br>case IDC_TRLOCAL_OFF: <br>pThis-&gt;m_CurLocalState = OAFALSE; <br>break; <br>} <br> <br>    SetDirty(); <br>    return (LRESULT) 1; <br>} <br>//--------------------------------------------------------- <br>// <br>//Apply user-requested changes <br>// <br>//--------------------------------------------------------- <br>HRESULT CExtTransProperties::OnApplyChanges() <br>{ <br>int temp; <br> <br>// we might want to set an hourglass cursor here <br> <br>if (m_bSetHourGlass) { <br>SetCursor(m_hHourGlass); <br>m_pExtTransport-&gt;put_MediaState(m_CurMediaState); <br>SetCursor(m_hCurrentCursor); <br>} <br>m_pExtTransport-&gt;put_LocalControl(m_CurLocalState); <br> <br>temp = SendMessage(m_hwndModeList, LB_GETCURSEL, 0, 0L); <br>if ( temp != m_CurModeSel ) { <br>m_CurModeSel = temp; <br>m_pExtTransport-&gt;put_Mode(ModeValueTable[m_CurModeSel][1]); <br>} <br> <br>UpdateControls(); <br>return(NOERROR); <br> <br>} <br> <br>//--------------------------------------------------------- <br>// <br>// Sets m_bDirty and notifies the property page site of the change <br>// <br>//--------------------------------------------------------- <br>void CExtTransProperties::SetDirty() <br>{ <br>    m_bDirty = TRUE; <br>    if (m_pPageSite) <br>    { <br>        m_pPageSite-&gt;OnStatusChange(PROPPAGESTATUS_DIRTY); <br>    } <br>} <br> <br>//--------------------------------------------------------- <br>// <br>// UpdateControls - sets non-listbox controls to current values <br>// <br>//--------------------------------------------------------- <br>void CExtTransProperties::UpdateControls() <br>{ <br>int temp; <br> <br>m_pExtTransport-&gt;get_MediaState(&amp;m_CurMediaState); <br>switch (m_CurMediaState) { <br>case ED_MEDIA_SPIN_UP: <br>temp = IDC_MS_SPINUP; <br>break; <br>case ED_MEDIA_SPIN_DOWN: <br>temp = IDC_MS_SD; <br>break; <br>case ED_MEDIA_UNLOAD: <br>temp = IDC_MS_UL; <br>break; <br>}; <br>CheckRadioButton(m_Dlg, IDC_MS_SPINUP, IDC_MS_UL, temp); <br> <br>m_pExtTransport-&gt;get_LocalControl(&amp;m_CurLocalState);  <br>switch (m_CurLocalState) { <br>case OATRUE: <br>temp = IDC_TRLOC_ON; <br>break; <br>case OAFALSE: <br>temp = IDC_TRLOCAL_OFF; <br>break; <br>} <br>CheckRadioButton(m_Dlg, IDC_TRLOC_ON, IDC_TRLOCAL_OFF, temp); <br> <br>m_pExtTransport-&gt;get_Mode(&amp;m_CurMode); <br>// convert to listbox index <br>m_CurModeSel = FindModeIndex(m_CurMode); <br>SendMessage(m_hwndModeList, LB_SETCURSEL, m_CurModeSel, 0L); <br> <br>return; <br>} <br> <br>//--------------------------------------------------------- <br>// <br>// FindModeIndex - given a mode, get its index into the  <br>// string/mode table <br>// <br>//--------------------------------------------------------- <br>intCExtTransProperties::FindModeIndex(long Value){ <br> <br>int i; <br> <br>for (i = 0; i &lt;MaxModeValue; i++) { <br>if ( ModeValueTable[i][1] == Value ) <br>return i;// found it <br>} <br>return -1; <br>} <br> <br>// eof trprop.cpp </code></pre>
<p>&nbsp;</p></body>
</HTML>
