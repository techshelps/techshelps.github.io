<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CDEVCOM.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2943"></a>CDEVCOM.CPP</h2>
<pre><code>//=========================================================================== <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>// PURPOSE. <br>// <br>// Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//=========================================================================== <br>// <br>//   filename: cdevcom.c <br>// <br>//     External Device Communication Functions <br>// <br>//--------------------------------------------------------- <br>// <br>//NOTES: <br>// 1. Code is un-optimized for clarity <br>// 2. Minimal error checking. <br>// 3. Protocol is tested with SVO-5800 (RS-422) and SVBK-10 (RS-232) machines <br>// 4. Timecode reading is supported, but dealing with multiple <br>//calling threads is nasty, so be sure you know what you're <br>//doing before you change anything. <br>//  <br>// <br>//--------------------------------------------------------- <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdarg.h&gt; <br>#include &lt;streams.h&gt; <br>#include &lt;mmsystem.h&gt; <br> <br>#include "ctimecod.h" <br>#include "cdevcom.h"  <br> <br>//---------------------------------------------------------- <br>// structures <br> <br>// SVO-5800/SVBK-1 Command Structure <br>typedef struct tagSV_CMD{ <br>BYTE bCmd1;// Command byte 1 - lo nybble has data byte <br>//  count <br>BYTE bCmd2;// Command byte 2 <br>BYTE bCmd3;// Data if required by command, or checksum if none <br>BYTE bCmd4;// Checksum if 1 data byte <br>BYTE bByteCnt;// How many bytes in the command (including checksum) <br>int iRespCnt;// How many bytes in the response <br>} SV_CMD; <br> <br>// SVO Commands - this is the command table.   <br>// ***IT MUST BE IN THE SAME ORDER AS THE COMMAND LIST IN CDEVCOM.H!!!!! <br>static SV_CMD SvoCmdTbl[] = { <br>{0x20,1,0x21,0,3,3},// Play <br>{0x20,0,0x20,0,3,3},// Stop <br>{0x61,0x0c,0x11,0x7e,4,11},// Request LTC <br>{0x41,0x36,1,0x78,4,3},// Timer Mode Select: LTC <br>{0x20,0x20,0x40,0,3,3},   // Rewind <br>{0x20,0x6b,0x8b,0,3,3},// Freeze on <br>{0x20,0x6a,0x8a,0,3,3},// Freeze off <br>{0x20,0x04,0x24,0,3,3},// Standby off <br>{0x20,0x05,0x25,0,3,3},// Standby on <br>{0x00,0x11,0x11,0,3,5},// Device Type Request <br>{0x61,0x20,0x08,0x89,4,11},// Status Request - 8 bytes <br>{0x20,0x0f,0x2f,0,3,3},// Eject <br>{0x00,0x0c,0x0c,0,3,3},// Local On <br>{0x00,0x1d,0x1d,0,3,3},// Local Off <br>{0x20,0x10,0x30,0,3,3},// Fast Forward <br>{0x20,0x02,0x22,0,3,3},// Record <br>{0xFF,0,0,0,0,0}// Device Clear <br>}; <br> <br>// device type request table <br>typedef struct tagSVO_DEVTYPE{ <br>BYTE bData1;// 1st data byte of response <br>BYTE bData2;// 2nd data byte of response <br>} SVO_DEVTYPE; <br> <br>static SVO_DEVTYPE SvoDevTbl[] = { <br>{0x80, 0x0c}, <br>{0x81, 0x0c}, <br>{0x80, 0x08}, <br>{0x80, 0x08}, <br>{0x81, 0x08}, <br>{0x10, 0x2c}, <br>{0x11, 0x2c}, <br>{0x10, 0x28}, <br>{0x11, 0x28}, <br>{0x10, 0x20}, <br>{0x11, 0x20}, <br>{0x10, 0x21}, <br>{0x11, 0x21}, <br>{0x20, 0x51} <br>}; <br> <br>const int DevTypeCnt = sizeof(SvoDevTbl); <br> <br>const TCHAR *strSvoDevID[] = { <br>"EVO-9850", <br>"EVO-9850P", <br>"EVO-9800", <br>"EVO-9800A", <br>"EVO-9800P", <br>"SVO-9600", <br>"SVO-9620", <br>"SVP-9000", <br>"SVP-9020", <br>"SVO-5800", <br>"SVO-5800P", <br>"SVO-5600", <br>"SVO-5600P", <br>"UVW-1800", <br>}; <br>const TCHAR *strUnknownDevID = <br>{"Unknown Device"}; <br> <br>// SVBK Command Table <br>// ***IT MUST BE IN THE SAME ORDER AS THE COMMAND LIST IN CDEVCOM.H!!!!! <br>static SV_CMD SvbkCmdTbl[] = { <br>{0x3A,0,0,0,1,1},// Play <br>{0x3F,0,0,0,1,1},// Stop <br>{0xA0,0,0,0,1,9},// Request LTC <br>{0xFF,0,0,0,0,0},// Timer Mode Select: LTC <br>{0xAC,0,0,0,1,1},   // Rewind <br>{0x4F,0,0,0,1,1},// Freeze on <br>{0x3A,0,0,0,1,1},// Freeze off <br>{0xFF,0,0,0,0,0},// Standby off <br>{0xFF,0,0,0,0,0},// Standby on <br>{0x8F,0,0,0,1,1},// Device Type Request <br>{0xD7,0,0,0,1,5},// Status Request - 5 bytes <br>{0x2A,0,0,0,1,2},// Eject <br>{0xFF,0,0,0,0,0},// Local On <br>{0xFF,0,0,0,0,0},// Local Off <br>{0xAB,0,0,0,1,1},// Fast Forward <br>{0xFA,0xFA,0xCA,0,3,1},// Record <br>{0x56,0,0,0,1,1}// Device Clear <br>}; <br> <br>const TCHAR *strSvbkDevID = <br>{"SVBK-1"}; <br>const int SvbkDevType = 0x80; <br> <br>// which machine's command table are we using? <br>SV_CMD *pVcrCmdTable = SvbkCmdTbl; <br>int VcrType;// 0 for SVO, 1 for SVBK <br>static TCHAR SvbkBuf[16];// for multi-byte commands <br> <br>// for simulation mode <br>static BYTE SvoAck[] = { <br>0x10,0x01,0x11}; <br>static DWORD SvoAckCount = 3L; <br>static BYTE SvbkAck[] = { <br>0x0A}; <br>static DWORD SvbkAckCount = 1L; <br>static TCHAR strDevID[] = "Pretend Machine"; <br> <br>static DWORD SimulatedFramecount = 0L; <br>static long lNDFTable[] = {1080000L,108000L,18000L,1800L,300L,30L,10L,1L}; <br> <br>// COM port stuff <br>#define COMM_TIMEOUT_MS = 60; <br> <br>static TCHAR DevPortCom1[] = "COM1"; <br>static TCHAR DevPortCom2[] = "COM2"; <br>static TCHAR DevPortCom3[] = "COM3"; <br>static TCHAR DevPortCom4[] = "COM4"; <br>static TCHAR buf[20]; <br> <br>// init static members <br>HANDLE CDevCom::m_hDevPort = 0; <br>TCHAR * CDevCom::m_pcDevPort = NULL; <br>BYTE CDevCom::m_bLastCmd = 0;           <br>BYTE CDevCom::m_LastMotionCmd = 0; <br>int CDevCom::m_CurCmdCookie = 1; <br>int CDevCom::m_LastSentCmdCookie = -1; <br>DCB CDevCom::m_dcb = { <br>0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, <br>0,0,0,0,0,0,0,0,0,0,0,0,0}; <br> <br>int CDevCom::m_PendingResponseCnt = 0; <br>BOOL CDevCom::m_bSimulateHardware = FALSE; <br>COMMTIMEOUTS CDevCom::m_ctmoTimeout = { <br>0,0,0,0,0}; <br>COMSTAT CDevCom::m_csCommStat = { <br>0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,}; <br>// Command Queue stuff to deal with multi-threading <br>#define COMMANDLISTSIZE 10 <br>#define RESPONSE_SLEEP_TIME 5// in milliseconds <br>#define RESPONSE_RETRY_MAX20// should never have to wait for more than this <br>// numer of sleep times <br>// Use Generic list template class to build command queue. Use of <br>// such a queue will allow the communications class to be thread safe. <br>static CGenericList&lt;COMMANDOBJECT&gt; CommandList("List of Pending Commands"); <br> <br>//intialize an empty array of command objects <br>COMMANDOBJECT CommandObjects[] = { <br>{-1,-1, 0xffff}, <br>{-1,-1, 0xffff}, <br>{-1,-1, 0xffff}, <br>{-1,-1, 0xffff}, <br>{-1,-1, 0xffff}, <br>{-1,-1, 0xffff}, <br>{-1,-1, 0xffff}, <br>{-1,-1, 0xffff}, <br>{-1,-1, 0xffff}, <br>{-1,-1, 0xffff} <br>}; <br> <br>// initialize an empty array of response objects - we don't create a linked  <br>// list of these because we don't expect to every have more that two or three <br>// buffered responses <br>RESPONSEOBJECT ResponseObject[] = { <br>{ -1, -1, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, <br>{ -1, -1, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, <br>{ -1, -1, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0} <br>}; <br>#define MAX_RESPONSE_OBJECTS 3 <br> <br>//--------------------------------------------------------- <br>// <br>// CDevCom constructor <br>// <br>//--------------------------------------------------------- <br>CDevCom::CDevCom(CBaseFilter *pFilter, HRESULT *phr) <br>{ <br>m_pFilter = pFilter; <br>// need some help with timecode <br>m_pTimecode = new CTimecode(); <br>if (m_pTimecode == NULL) { <br>        *phr = E_OUTOFMEMORY; <br>       return; <br>} <br>*phr = S_OK; <br>return; <br> <br>} <br>//--------------------------------------------------------- <br>// <br>// Destructor <br>// <br>//--------------------------------------------------------- <br>CDevCom::~CDevCom() <br>{ <br> <br>} <br> <br>//--------------------------------------------------------- <br>// <br>//OpenDevPort  <br>// <br>//Tries to open the requested port.  If port is not available, <br>//enters "simulation" mode <br>// <br>//--------------------------------------------------------- <br>DWORD  <br>CDevCom::OpenDevPort( int Port ) <br>{ <br>TCHAR resp[20]; <br>DWORD LastError; <br>DWORD dwCommError; <br>int Cookie; <br> <br>timeBeginPeriod(1);// setup 1ms timer for timestamping <br>m_bSimulateHardware = FALSE;// this may have been set TRUE previously <br>// get the port <br>switch (Port){ <br>case DEV_PORT_COM1: <br>m_pcDevPort = DevPortCom1; <br>break; <br>case DEV_PORT_COM2: <br>m_pcDevPort = DevPortCom2; <br>break; <br>case DEV_PORT_COM3: <br>m_pcDevPort = DevPortCom3; <br>break; <br>case DEV_PORT_COM4: <br>m_pcDevPort = DevPortCom4; <br>break; <br>case DEV_PORT_SIM: <br>case DEV_PORT_DIAQ: <br>case DEV_PORT_ARTI: <br>default: <br>if (m_hDevPort) <br>CloseDevPort(); <br>m_bSimulateHardware = TRUE; <br>return 0L; <br>} <br>// open the port <br>if ( (m_hDevPort = CreateFile( m_pcDevPort,GENERIC_READ | GENERIC_WRITE, <br>    0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <br>    NULL )) == (HANDLE) -1 ){ <br>// we're in simulation mode <br>DWORD dwTemp = GetLastError(); <br>m_bSimulateHardware = TRUE; <br>return 1L; <br>} <br> <br>// get the Device Control Block <br>if ( !GetCommState( m_hDevPort, &amp;m_dcb ) ) { <br>CloseDevPort(); <br>m_bSimulateHardware = TRUE; <br>   return 1L; <br>} <br> <br>// put in our values <br>m_dcb.BaudRate = 38400; <br>    m_dcb.fDtrControl = DTR_CONTROL_ENABLE; <br>    m_dcb.fDsrSensitivity = FALSE; <br>    m_dcb.fOutX = FALSE; <br>    m_dcb.fInX = FALSE; <br>    m_dcb.fNull = FALSE; <br>    m_dcb.fRtsControl = RTS_CONTROL_ENABLE; <br>    m_dcb.fAbortOnError = TRUE; <br>  m_dcb.ByteSize = 8; <br>    m_dcb.Parity = ODDPARITY; <br>    m_dcb.StopBits = ONESTOPBIT; <br> <br>if ( !SetCommState(m_hDevPort, &amp;m_dcb) ){ <br>// failure forces simulation mode <br>m_bSimulateHardware = TRUE; <br>return 1L; <br>} <br> <br>// set the comm timeout <br>if ( !GetCommTimeouts(m_hDevPort, &amp;m_ctmoTimeout) ){ <br>CloseDevPort(); <br>m_bSimulateHardware = TRUE; <br>   return 1L; <br>} <br>// timeout after COMM_TIMEOUT_MS milliseconds <br>m_ctmoTimeout.ReadIntervalTimeout = 15L; <br>m_ctmoTimeout.ReadTotalTimeoutMultiplier = 10L; <br>m_ctmoTimeout.ReadTotalTimeoutConstant = 60L; <br>m_ctmoTimeout.WriteTotalTimeoutMultiplier = 1L; <br>m_ctmoTimeout.WriteTotalTimeoutConstant = 60L; <br>if ( !SetCommTimeouts(m_hDevPort, &amp;m_ctmoTimeout) ){ <br>CloseDevPort(); <br>m_bSimulateHardware = TRUE; <br>   return 1L; <br>} <br> <br>// now let's see if there is some hardware there <br>// try an SVO type machine first <br>pVcrCmdTable = SvoCmdTbl; <br>VcrType = 0; <br>if (SendDevCmd(DEVICE_TYPE_REQUEST, &amp;Cookie) != 0L){ <br>GetDevResponse(resp, Cookie);//cleanup <br>CloseDevPort(); <br>m_bSimulateHardware = TRUE; <br>m_PendingResponseCnt = 0; <br>   return 1L; <br>} <br> <br>if ( GetDevResponse(resp, Cookie) != 0L){ <br>// try the SVBK now <br>pVcrCmdTable = SvbkCmdTbl; <br>VcrType = 1; <br>FlushDevResponseBuffer();// clean out the UART <br>ClearCommError( m_hDevPort, &amp;dwCommError, &amp;m_csCommStat ); <br>// need to change the baud rate among other things <br>m_dcb.BaudRate = 9600; <br>m_dcb.Parity = NOPARITY; <br>    if ( !SetCommState(m_hDevPort, &amp;m_dcb) ){ <br>// set simulation mode <br>LastError = GetLastError(); <br>m_bSimulateHardware = TRUE; <br>return 1L; <br>} <br>Sleep(30L);// give the machine time to recover <br>SendDevCmd(DEVICE_CLEAR, &amp;Cookie); <br>GetDevResponse(resp, Cookie); <br>// DEVICE_CLEAR puts the machine in pause, so put it in stop <br>SendDevCmd(STOP, &amp;Cookie); <br>GetDevResponse(resp, Cookie); <br>Sleep(30L);// give the machine time to recover <br>FlushDevResponseBuffer();// clean out the UART <br>ClearCommError( m_hDevPort, &amp;dwCommError, &amp;m_csCommStat ); <br>if (SendDevCmd(DEVICE_TYPE_REQUEST, &amp;Cookie) != 0L){ <br>GetDevResponse(resp, Cookie);//cleanup <br>CloseDevPort(); <br>m_bSimulateHardware = TRUE; <br>m_PendingResponseCnt = 0; <br>   return 1L; <br>} <br>// we don't actually check the response value here because <br>// it is not always consistant. <br>if ( GetDevResponse(resp, Cookie) != 0L){ <br>CloseDevPort(); <br>m_bSimulateHardware = TRUE; <br>return 1L; <br>} <br>// cleanup <br>ClearCommError( m_hDevPort, &amp;dwCommError, &amp;m_csCommStat ); <br>FlushDevResponseBuffer();// clean out the UART <br>return 0L; <br>} <br> return 0L; <br>} <br> <br>//--------------------------------------------------------- <br>// <br>//CloseDevPort <br>// <br>//Shuts things down <br>// <br>//--------------------------------------------------------- <br>DWORD  <br>CDevCom::CloseDevPort( void ) <br>{ <br>DWORD LastError; <br> <br>timeEndPeriod(1);// restore timer period <br> <br>if ( m_hDevPort &amp;&amp; !m_bSimulateHardware ) <br>{// close the port <br>if (DeleteFile(m_pcDevPort)) { <br>LastError = GetLastError(); <br>return DEV_COMM_ERR_COMMUNICATION_ERROR; <br>} <br>m_pcDevPort = NULL; <br>if ( !CloseHandle( m_hDevPort ) ) { <br>LastError = GetLastError(); <br>return DEV_COMM_ERR_COMMUNICATION_ERROR; <br>} <br>m_hDevPort = 0; <br>return 0L; <br>} <br>m_bSimulateHardware = FALSE; <br>return 0L; <br>} <br> <br>//--------------------------------------------------------- <br>// <br>//FlushDevResponseBuffer <br>// <br>//A cleanup method <br>// <br>//--------------------------------------------------------- <br>DWORD  <br>CDevCom::FlushDevResponseBuffer( void ) <br>{ <br>DWORD LastError; <br>DWORD dwRetByteCnt; <br>DWORD dwCommError; <br>char buf[16]; <br> <br>if (m_bSimulateHardware) <br>return 0L; <br>m_PendingResponseCnt = 0; <br>if (PurgeComm(m_hDevPort, PURGE_RXCLEAR)) { <br>LastError = GetLastError(); <br>return DEV_COMM_ERR_COMMUNICATION_ERROR; <br>} <br>ClearCommError( m_hDevPort, &amp;dwCommError, &amp;m_csCommStat ); <br>if (m_csCommStat.cbInQue) { <br>if ( !ReadFile( m_hDevPort, buf, (DWORD)m_csCommStat.cbInQue, <br> (LPDWORD)&amp;dwRetByteCnt, (LPOVERLAPPED)NULL ) ){ <br>LastError = GetLastError(); <br>// could stand a bit better error handling here <br>return DEV_COMM_ERR_COMMUNICATION_ERROR; <br>} <br>} <br> <br>return 0L; <br>} <br> <br>//--------------------------------------------------------- <br>// <br>//SendDevCmd <br>// <br>//Sends command to device (or queues it up for xmission). <br>//Returned a Cookie so the caller can find the <br>//correct response <br>// <br>//--------------------------------------------------------- <br>DWORD <br>CDevCom::SendDevCmd( int Cmd, int *pCookie) <br>{ <br>CAutoLock lock(this); <br>PCOMMANDOBJECT pCmdObj; <br>DWORD dwret; <br> <br>// return immediately if command is not supported <br>if (pVcrCmdTable[Cmd].bCmd1 == 0xFF) <br>return DEV_COMM_ERR_COMMAND_NOT_SUPPORTED; <br> <br>// get a new cookie <br>if (m_CurCmdCookie++ == 0) <br>m_CurCmdCookie++; <br>// queue the command if the response has not yet been <br>// pulled for the previously sent command <br>if (m_PendingResponseCnt){ <br>// some extra instructions here for debugging <br>pCmdObj = AddCommand(Cmd, m_CurCmdCookie); <br>if (pCmdObj == NULL){ <br>ASSERT(pCmdObj); <br>return DEV_COMM_ERR_QUEUE_OVERFLOW; <br>} <br>*pCookie = m_CurCmdCookie; <br>return 0L; <br>} <br>dwret = ReallySendDevCmd( Cmd, m_CurCmdCookie); <br>*pCookie = m_CurCmdCookie; <br>return dwret; <br>} <br> <br>//--------------------------------------------------------- <br>// <br>//ReallySendDevCmd <br>// <br>//This does the actual sending of queued commands <br>// <br>//--------------------------------------------------------- <br>DWORD <br>CDevCom::ReallySendDevCmd( int Cmd, int Cookie ) <br>{ <br>SV_CMD *svCommand; <br>BYTE bCmdSequenceCnt; <br>DWORD dwBytesWritten; <br>DWORD LastError; <br>DWORD dwret = 0L; <br>TCHAR *pCmd; <br>int i; <br> <br>m_bLastCmd = Cmd; <br>if ( m_isMotionCmd(Cmd) )// do we still need to know this? <br>m_LastMotionCmd = Cmd; <br> <br>if (!m_bSimulateHardware) { <br>// get the command from the table and shoot it out <br>svCommand = &amp;pVcrCmdTable[Cmd]; <br>// we handle the two machine types differently because the SVBK <br>// machine might have multiple command/response pair sequences <br>if (VcrType == 0) {// SVO has one sequence and can send multiple bytes <br>i = (int)svCommand-&gt;bByteCnt; <br>bCmdSequenceCnt = 1; <br>} <br>else {// SVBK only sends out one byte per sequence <br>i = 1; <br>bCmdSequenceCnt = svCommand-&gt;bByteCnt; <br>} <br>pCmd = (TCHAR *)svCommand; <br>while (bCmdSequenceCnt) {// do this loop for each sequence <br>// send out the command <br>if ( !WriteFile( m_hDevPort, (TCHAR *)pCmd, i, <br>(LPDWORD)&amp;dwBytesWritten, NULL ) ) { <br>LastError = GetLastError(); <br>dwret = DEV_COMM_ERR_COMMUNICATION_ERROR; <br>} <br>if (VcrType == 1 &amp;&amp; bCmdSequenceCnt &gt; 1) { <br>// must pick up response byte if another sequence is pending <br>m_PendingResponseCnt++; <br>ReallyGetDevResponse(SvbkBuf,1); <br>// point to the next command byte in the sequence <br>pCmd++; <br>// special handling for SVBK's Eject command <br>if (svCommand-&gt;bCmd1 == 0x2a) <br>Sleep(1000);// wait while EJECT completes <br>} <br>bCmdSequenceCnt--; <br>} <br>} <br>m_LastSentCmdCookie = Cookie; <br>m_PendingResponseCnt++; <br>return dwret; <br>} <br> <br>//--------------------------------------------------------- <br>// <br>//GetDevResponse <br>// <br>//Returns device response to command.  If command <br>//hasn't really been sent yet (still in queue), error <br>//is returned in the DWORD <br>// <br>//--------------------------------------------------------- <br>DWORD  <br>CDevCom::GetDevResponse( TCHAR *buf, int Cookie ) <br>{ <br>CAutoLock lock(this); <br> <br>DWORD dwret = 0L; <br>int temp; <br>PCOMMANDOBJECT ptemp; <br>POSITION posNextCommand; <br>BOOL bNeedCommand = FALSE; <br> <br>// is this command's response buffered? <br>if ( IsResponseBuffered(Cookie, &amp;temp) ) { <br>GetBufferedResponse( buf, Cookie ); <br>// don't send another command out since <br>// a response wasn't cleared out of the COMM port <br>return dwret; <br>} <br> <br>// was this the last command sent? <br>if (Cookie == m_LastSentCmdCookie) { <br>// get the response <br>dwret = ReallyGetDevResponse( buf, pVcrCmdTable[m_bLastCmd].iRespCnt ); <br>if (dwret) <br>return dwret; <br>} <br>else { <br>// since it wasn't, is a response pending? <br>if (m_PendingResponseCnt) { <br>dwret = BufferResponse(); <br>if (dwret) <br>return dwret; <br>} <br>bNeedCommand = TRUE; <br>} <br> <br>// since the command hasn't been sent it must be in the queue,  <br>// so send something <br>temp = CommandList.GetCount(); <br>if (temp) { <br>posNextCommand = CommandList.GetHeadPosition(); <br>ptemp = CommandList.Get(posNextCommand); <br>dwret = ReallySendDevCmd( ptemp-&gt;Command, ptemp-&gt;Cookie ); <br>ptemp = CommandList.RemoveHead(); <br>RemoveCommand(ptemp); <br>return DEV_COMM_ERR_COMMAND_NOT_SENT_YET; <br>} <br>else  <br>if (bNeedCommand) <br>return DEV_COMM_ERR_COMMAND_MISSING; <br> <br>return dwret; <br>} <br>//--------------------------------------------------------- <br>// <br>//ReallyGetDevResponse <br>// <br>//Actually handles communications to get device response <br>// <br>//--------------------------------------------------------- <br>DWORD  <br>CDevCom::ReallyGetDevResponse( TCHAR *buf, int bytecnt ) <br>{ <br>DWORD dwRetByteCnt;  <br>DWORD LastError; <br> <br>m_PendingResponseCnt--; <br>if (m_bSimulateHardware) { <br>(GetSimulatedResponse(buf)); <br>} <br>else { <br>if ( !ReadFile( m_hDevPort, buf, (DWORD)bytecnt, <br> (LPDWORD)&amp;dwRetByteCnt, (LPOVERLAPPED)NULL ) ){ <br>LastError = GetLastError(); <br>// could stand a bit better error handling here <br>return DEV_COMM_ERR_COMMUNICATION_ERROR; <br>} <br>if ( dwRetByteCnt != (DWORD)bytecnt ) { <br>return DEV_COMM_ERR_RESPONSE_MISMATCH; <br>} <br>// SVBK doesn't use checksums and its timecode reading  <br>// is a bit unpredictable <br>if (VcrType == 0) { <br>if ( TestResponse(buf, dwRetByteCnt) ) <br>return DEV_COMM_ERR_RESPONSE_CHECKSUM; <br>} <br>else { <br>// sometimes an extra wierd character is sent <br>// during timecode reading, so we need to watch for it <br>if (bytecnt == pVcrCmdTable[READ_TC].iRespCnt) { <br>// this was a timecode response, so check for multiple <br>// 0xA1's at the beginning of the buffer.  If we have <br>// more than one, we need to get another byte out of <br>// the receive buffer <br>if (buf[1] == (TCHAR)0xA1) { <br>if ( !ReadFile( m_hDevPort,  <br>&amp;buf[pVcrCmdTable[READ_TC].iRespCnt], <br>1L,(LPDWORD)&amp;dwRetByteCnt, (LPOVERLAPPED)NULL ) ){ <br>LastError = GetLastError(); <br>// could stand a bit better error handling here <br>return DEV_COMM_ERR_COMMUNICATION_ERROR; <br>} <br>if ( dwRetByteCnt != 1L ) <br>return DEV_COMM_ERR_RESPONSE_MISMATCH; <br>} <br>} <br>} <br>} <br>return S_OK; <br>} <br>//--------------------------------------------------------- <br>// <br>//BufferResponse <br>// <br>//Pulls a response out of the COMM device for the most <br>//recently send command <br>// <br>//--------------------------------------------------------- <br>DWORD  <br>CDevCom::BufferResponse(void) <br>{ <br>int i;  <br>// get an available slot in the array <br>for (i=0; i&lt;MAX_RESPONSE_OBJECTS; i++) { <br>if (ResponseObject[i].Cookie == -1) <br>break; <br>} <br>if (i&gt;=MAX_RESPONSE_OBJECTS) <br>return DEV_COMM_ERR_RESPONSE_OVERFLOW; <br>// put in the cookie and response byte count <br>ResponseObject[i].Cookie = m_LastSentCmdCookie; <br>ResponseObject[i].ResponseByteCount = pVcrCmdTable[m_bLastCmd].iRespCnt; <br>// get the response <br>return ReallyGetDevResponse( ResponseObject[i].buf, <br>ResponseObject[i].ResponseByteCount ); <br>} <br>//--------------------------------------------------------- <br>// <br>//GetBufferedResponse <br>// <br>//Pulls a response out of the response array <br>// <br>//--------------------------------------------------------- <br>DWORD  <br>CDevCom::GetBufferedResponse( TCHAR *buf, int Cookie) <br>{ <br>int i;  <br> <br>if ( !IsResponseBuffered( Cookie, &amp;i ) ) <br>return DEV_COMM_ERR_RESPONSE_MISSING; <br> <br>// copy the response into the return buffer <br>memcpy( buf, ResponseObject[i].buf, ResponseObject[i].ResponseByteCount); <br> <br>// Clear the entry <br>ResponseObject[i].Cookie = -1; <br>ResponseObject[i].ResponseByteCount = -1; <br>// get the response <br>return S_OK; <br>} <br> <br>//--------------------------------------------------------- <br>// <br>//IsResponseBuffered <br>// <br>//Searches the response array for the given cookie <br>// <br>//--------------------------------------------------------- <br>BOOL <br>CDevCom::IsResponseBuffered( int Cookie, int *index) <br>{ <br>int i;  <br>// find the response in the array <br>for (i=0; i&lt;MAX_RESPONSE_OBJECTS; i++) { <br>if (ResponseObject[i].Cookie == Cookie) { <br>*index = i; <br>return TRUE; <br>} <br>} <br>return FALSE; <br>} <br> <br>//--------------------------------------------------------- <br>// <br>//Wait4DevResponse <br>// <br>//Wrapper method that handles retries <br>// <br>//--------------------------------------------------------- <br>DWORD <br>CDevCom::Wait4DevResponse( TCHAR *buf, int Cookie ) <br>{ <br>DWORD dwret; <br>int i = 0; <br>do { <br>if (i &gt; RESPONSE_RETRY_MAX) <br>return DEV_COMM_ERR_RESPONSE_TIMEOUT; <br>dwret = GetDevResponse(buf, Cookie); <br>if (dwret != 0L &amp;&amp; dwret != DEV_COMM_ERR_COMMAND_NOT_SENT_YET) <br>return dwret; <br>if (dwret)  <br>Sleep(RESPONSE_SLEEP_TIME); <br>}while (dwret); <br>return dwret; <br>} <br>//--------------------------------------------------------- <br>// <br>//GetSimulatedResponse <br>// <br>//Used for simulation mode <br>// <br>//--------------------------------------------------------- <br>DWORD  <br>CDevCom::GetSimulatedResponse( TCHAR *buf ) <br>{ <br>switch (m_bLastCmd){ <br>case READ_TC: <br>if (m_LastMotionCmd == PLAY || m_LastMotionCmd == FREEZE_OFF) { <br>SimulatedFramecount++; <br>if ( SimulatedFramecount &gt; 2591999L ) <br>SimulatedFramecount = 0; <br>} <br>else if (m_LastMotionCmd == REWIND){ <br>if (SimulatedFramecount &gt;2591999L) <br>SimulatedFramecount = 2591999L; <br>else <br>SimulatedFramecount-=10; <br>} <br>GetSimulatedTimecode(buf, SimulatedFramecount); <br>return 0L; <br> <br>case DEVICE_TYPE_REQUEST: <br>strcpy(buf, strDevID); <br>return 0L; <br> <br>case PLAY: <br> case STOP: <br>case TIMER_MODE_SELECT_LTC: <br>case REWIND: <br>case FREEZE_ON: <br>case FREEZE_OFF: <br>case STANDBY_OFF: <br>default: <br>if (VcrType == 0) <br>strncpy(buf, (TCHAR *)SvoAck, SvoAckCount); <br>else <br>strncpy(buf, (TCHAR *)SvbkAck, SvbkAckCount); <br>return 0L; <br>} <br>return 0L; <br>} <br>//--------------------------------------------------------- <br>// <br>//m_isMotionCmd <br>// <br>//private helper method to differentiate Motion commands <br>//from things like Timecode requests (sometimes timecode <br>//requests need to be handled differently) <br>// <br>//--------------------------------------------------------- <br>BOOL <br>CDevCom::m_isMotionCmd( BYTE Cmd ) { <br> switch (Cmd) { <br>case READ_TC: <br>case TIMER_MODE_SELECT_LTC: <br>return FALSE; <br>case PLAY: <br>case STOP: <br>case REWIND: <br>case FFWD: <br>case RECORD: <br>case FREEZE_ON: <br>case FREEZE_OFF: <br>case STANDBY_OFF: <br>case EJECT: <br>return TRUE; <br>default: <br>return FALSE; <br>} <br>} <br>//--------------------------------------------------------- <br>// <br>//ProcessDeviceTypeResponse <br>// <br>// Convert response to device type request to string if possible <br>// <br>//--------------------------------------------------------- <br>void <br>CDevCom::ProcessDeviceTypeResponse( TCHAR *bufin, TCHAR *bufout) <br>{ <br>int i; <br>if (m_bSimulateHardware) { <br>strcpy( bufout, bufin ); <br>return; <br>} <br> <br>// handle the two machine types differently <br>if (VcrType == 0) { <br>// compare the 2 data bytes of the response to the list of known <br>// machine types.  If we find a match, return the corresponding  <br>// device type string <br>for (i=0; i&lt;DevTypeCnt; i++) { <br>if ( bufin[2] != SvoDevTbl[i].bData1 ) <br>continue; <br>if ( bufin[3] != SvoDevTbl[i].bData2 ) <br>continue; <br>strcpy( bufout, strSvoDevID[i] ); <br>return; <br>} <br>// unknown machine <br>strcpy( bufout, strUnknownDevID ); <br>} <br>else <br>if (bufin[0] &amp; (TCHAR)SvbkDevType) <br>strcpy( bufout, strSvbkDevID ); <br>else <br>// unknown machine <br>strcpy( bufout, strUnknownDevID ); <br>return; <br>} <br> <br>//--------------------------------------------------------- <br>// <br>//ProcessDeviceStatusResponse <br>// <br>// Stuff status structure with response to status request <br>//returns FALSE if SVBK returns a NAK <br>// <br>//--------------------------------------------------------- <br>BOOL <br>CDevCom::ProcessDeviceStatusResponse( TCHAR *bufin, PVCRSTATUS pStatus ) <br>{ <br>if (m_bSimulateHardware) { <br>pStatus-&gt;bCassetteOut = OAFALSE; <br>pStatus-&gt;bLocal = OAFALSE; <br>return FALSE; <br>} <br> <br>// we only process two bits of information right now, and  <br>// it's hardcoded for clarity and simplicity <br>if (VcrType == 0) {// SVO <br>if (bufin[2] &amp; 0x20) <br>pStatus-&gt;bCassetteOut = OATRUE; <br>else <br>pStatus-&gt;bCassetteOut = OAFALSE; <br> <br>if (bufin[2] &amp; 0x01) <br>pStatus-&gt;bLocal = OATRUE; <br>else <br>pStatus-&gt;bLocal = OAFALSE; <br>} <br>else { // SVBK <br>if (bufin[0] == 0x0b)// machine can send a NAK if not ready <br>return TRUE; <br>if (bufin[0] &amp; 0x08) <br>pStatus-&gt;bCassetteOut = OATRUE; <br>else  <br>pStatus-&gt;bCassetteOut = OAFALSE; <br>// dummy response for remote/local because that  <br>// info is not available <br>pStatus-&gt;bLocal = OAFALSE; <br>} <br>return FALSE; <br>} <br>//--------------------------------------------------------- <br>// <br>//AddCommand <br>// <br>// Insert pending command in empty space in array <br>// <br>//--------------------------------------------------------- <br>PCOMMANDOBJECT <br>CDevCom::AddCommand( int Cmd, int Cookie ){ <br> <br>int i; <br>POSITION pos; <br> <br>for (i=0; i&lt;COMMANDLISTSIZE; i++) { <br>if (CommandObjects[i].Command == -1) { <br>CommandObjects[i].Command = Cmd; <br>CommandObjects[i].Cookie = Cookie; <br>CommandObjects[i].Timestamp = timeGetTime(); <br>pos = CommandList.AddTail( &amp;CommandObjects[i] ); <br>return &amp;CommandObjects[i]; <br>} <br>} <br>return NULL; //Null means no more space <br>} <br>//--------------------------------------------------------- <br>// <br>//RemoveCommand <br>// <br>// Clear entry in command array <br>// <br>//--------------------------------------------------------- <br>void <br>CDevCom::RemoveCommand( PCOMMANDOBJECT pCmdObj ) <br>{ <br>pCmdObj-&gt;Command = -1; <br>pCmdObj-&gt;Cookie = -1; <br>return; <br>} <br>//--------------------------------------------------------- <br>// <br>//TestResponse <br>// <br>// Calculates checksum on response and compares it to embedded <br>// checksum.  Returns FALSE if OK, TRUE if not <br>// <br>//--------------------------------------------------------- <br>BOOL <br>CDevCom::TestResponse( TCHAR *buf, int Count ) <br>{ <br>BYTE CalcCheckSum = 0; <br>int i; <br> <br>for ( i=0; i&lt;(Count-1); i++) { <br>CalcCheckSum += (BYTE)buf[i]; <br>} <br>if ( CalcCheckSum != (BYTE)buf[(Count-1)] ) <br>return TRUE; <br>return FALSE; <br>} <br>//--------------------------------------------------------- <br>// <br>//ProcessVcrTC - converts the timecode response to a binary <br>//framecount.  Handles both SVO and SVBK timecode formats <br>// <br>//--------------------------------------------------------- <br>DWORD <br>CDevCom::ProcessVcrTC( TCHAR *inbuf, DWORD *dwFCM, long *ptimecode,  <br>  long *puserbits) <br>{ <br>BYTE btemp; <br>WORD wtemp; <br>static TCHAR outbuf[12]; <br>static TIMECODE_SAMPLE tcsTimecode; <br>int i=0; <br>TCHAR *ptemp; <br> <br>// look at first byte to determine SVO or SVBK <br>if ((inbuf[0] &amp; 0x70) != 0x70 ) { // SVO's command value <br>// SVBK timecode format is 8 byte ASCII, Hx10 first <br>// hours.  Can't tell whether it's drop or nondrop,  <br>// so we'll stay nondrop SVBK also has an unpredictable  <br>// number of 0xA1's at the head of the buffer, so we must correct. <br>while ( inbuf[i] == (TCHAR)0xA1 || inbuf[i] == (TCHAR)0xA2 ) { <br>i++; <br>} <br>ptemp =&amp;inbuf[i]; <br> <br>wtemp = AM_TIMECODE_30NONDROP; <br>// hours <br>outbuf[0] = ptemp[0]; <br>outbuf[1] = ptemp[1]; <br>outbuf[2] = ':'; <br> <br>// minutes <br>outbuf[3] = ptemp[2]; <br>outbuf[4] = ptemp[3]; <br>outbuf[5] = ':'; <br> <br>// seconds <br>outbuf[6] = ptemp[4]; <br>outbuf[7] = ptemp[5]; <br>outbuf[8] = ':'; <br> <br>// frames <br>outbuf[9] = ptemp[6]; <br>outbuf[10] = ptemp[7]; <br> <br>// terminate </code></pre>
<p>
</p>
<pre><code>outbuf[11] = 0; <br> <br>// convert to binary <br>tcsTimecode.timecode.wFrameRate = wtemp; <br>m_pTimecode-&gt;ConvertStringToTimecode(outbuf, &amp;tcsTimecode);  <br>*ptimecode = tcsTimecode.timecode.dwFrames; <br>*dwFCM = (DWORD)wtemp; <br>*puserbits = (DWORD)0L; // forget userbits <br>} <br>else { // SVO <br>// SVO t/c format is this: <br>// BIT7 BIT6 BIT5 BIT4 BIT3 BIT2 BIT1 BIT0 <br>//DATA1 x  DF 10F   | 1F <br>//DATA2 x 10S   | 1S <br>//DATA3 x 10M   | 1M <br>//DATA4 x  x 10H   | 1H <br>// <br>// It lives in bytes 2 thru 5 in the response from the machine, and <br>// userbits live in bytes 6 thru 9 <br> <br>// just yank em out and put em in the output buffer <br>// get the dropframe flag <br>if ( inbuf[2] &amp; 0x40 ) <br>wtemp = AM_TIMECODE_30DROP; <br>else <br>wtemp = AM_TIMECODE_30NONDROP; <br> <br>// hours <br>btemp = inbuf[5] &amp; 0x30; <br>btemp = btemp&gt;&gt;(4*sizeof(TCHAR)); <br>btemp += '0'; <br>outbuf[0] = btemp; <br>outbuf[1] = (inbuf[5] &amp; 0x0f) + '0'; <br>outbuf[2] = ':'; <br> <br>// minutes <br>btemp = inbuf[4] &amp; 0x70; <br>btemp = btemp&gt;&gt;(4*sizeof(TCHAR)); <br>outbuf[3] = btemp + '0'; <br>outbuf[4] = (inbuf[4] &amp; 0x0f) + '0'; <br>outbuf[5] = ':'; <br> <br>// seconds <br>btemp = inbuf[3] &amp; 0x70; <br>btemp = btemp&gt;&gt;(4*sizeof(TCHAR)); <br>outbuf[6] = btemp + '0'; <br>outbuf[7] = (inbuf[3] &amp; 0x0f) + '0'; <br>if ( AM_TIMECODE_30DROP == wtemp ) <br>outbuf[8] = ';'; <br>else <br>outbuf[8] = ':'; <br> <br>// frames <br>btemp = inbuf[2] &amp; 0x30; <br>btemp = btemp&gt;&gt;(4*sizeof(TCHAR)); <br>outbuf[9] = btemp + '0'; <br>outbuf[10] = (inbuf[2] &amp; 0x0f) + '0'; <br> <br>// terminate <br>outbuf[11] = 0; <br> <br>// convert to binary <br>tcsTimecode.timecode.wFrameRate = wtemp; <br>m_pTimecode-&gt;ConvertStringToTimecode(outbuf, &amp;tcsTimecode);  <br>*ptimecode = tcsTimecode.timecode.dwFrames; <br>*dwFCM = (DWORD)wtemp; <br>*puserbits = (DWORD)inbuf[6]; <br>} <br>return 0; <br>} <br> <br>//--------------------------------------------------------- <br>// <br>//For no-hardware mode <br>// <br>//--------------------------------------------------------- <br>void <br>CDevCom::GetSimulatedTimecode( TCHAR * timecode, long framecount ) <br>{ <br>long temp; <br>int i; <br> <br>if (VcrType == 0) { <br>// SVO t/c format is this: <br>// BIT7 BIT6 BIT5 BIT4 BIT3 BIT2 BIT1 BIT0 <br>//DATA1 x  DF 10F   | 1F <br>//DATA2 x 10S   | 1S <br>//DATA3 x 10M   | 1M <br>//DATA4 x  x 10H   | 1H <br>// <br>// It lives in bytes 2 thru 5 in the response from the machine <br>// Bytes 6 thru 9 are user bits, and 10 is the checksum <br> <br>// put in the command <br>timecode[0] = 0x74; <br>timecode[1] = 0x04; <br> <br>// convert the frame count to Svo t/c format <br>temp = framecount / lNDFTable[0];// hours <br>framecount -= temp * lNDFTable[0]; <br>timecode[5] = (TCHAR)temp &lt;&lt; (4*sizeof(TCHAR)); <br>temp = framecount / lNDFTable[1]; <br>framecount -= temp * lNDFTable[1]; <br>timecode[5] |= temp; <br> <br>temp = framecount / lNDFTable[2];// minutes <br>framecount -= temp * lNDFTable[2]; <br>timecode[4] = (TCHAR)temp &lt;&lt; (4*sizeof(TCHAR)); <br>temp = framecount / lNDFTable[3]; <br>framecount -= temp * lNDFTable[3]; <br>timecode[4] |= temp; <br> <br>temp = framecount / lNDFTable[4];// seconds <br>framecount -= temp * lNDFTable[4]; <br>timecode[3] = (TCHAR)temp &lt;&lt; (4*sizeof(TCHAR)); <br>temp = framecount / lNDFTable[5]; <br>framecount -= temp * lNDFTable[5]; <br>timecode[3] |= temp; <br> <br>temp = framecount / lNDFTable[6];// frames <br>framecount -= temp * lNDFTable[6]; <br>timecode[2] = (TCHAR)temp &lt;&lt; (4*sizeof(TCHAR)); <br>timecode[2] |= framecount; <br> <br>// do the checksum <br>timecode[10] = 0; <br>for (i=0; i&lt;11; i++) <br>{ <br>timecode[10] +=timecode[i]; <br>} <br>} <br>else { <br>// SVBK timecode format is 8 byte ASCII, Hx10 first <br>// hours.  Can't tell whether it's drop or nondrop, so we'll stay  <br>// nondrop <br>temp = framecount / lNDFTable[0];// hours <br>framecount -= temp * lNDFTable[0]; <br>timecode[0] = (TCHAR)temp | 0x30; <br>temp = framecount / lNDFTable[1]; <br>framecount -= temp * lNDFTable[1]; <br>timecode[1] = temp | 0x30; <br> <br>temp = framecount / lNDFTable[2];// minutes <br>framecount -= temp * lNDFTable[2]; <br>timecode[2] = (TCHAR)temp | 0x30; <br>temp = framecount / lNDFTable[3]; <br>framecount -= temp * lNDFTable[3]; <br>timecode[3] = temp | 0x30; <br> <br>temp = framecount / lNDFTable[4];// seconds <br>framecount -= temp * lNDFTable[4]; <br>timecode[4] = (TCHAR)temp | 0x30; <br>temp = framecount / lNDFTable[5]; <br>framecount -= temp * lNDFTable[5]; <br>timecode[5] = temp | 0x30; <br> <br>temp = framecount / lNDFTable[6];// frames <br>framecount -= temp * lNDFTable[6]; <br>timecode[6] = (TCHAR)temp | 0x30; <br>timecode[7] = framecount | 0x30; <br>} <br>return; <br>} <br> <br>// eof cdevcom.cpp </code></pre>
<p>&nbsp;</p></body>
</HTML>
