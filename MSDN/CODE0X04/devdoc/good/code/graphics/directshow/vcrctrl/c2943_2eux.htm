<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FVCRCTRL.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2949"></a>FVCRCTRL.CPP</h2>
<pre><code>//=========================================================================== <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>// PURPOSE. <br>// <br>// Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//=========================================================================== <br>// <br>//filename: fvcrctrl.cpp <br>// <br>// Sample VCR Control Filter <br>//    This filter is CBaseFilter derived.  <br>// <br>// Responds to run/pause/stop.  An app would probably want to override the  <br>// default operation of this filter and "disconnect" the PLAY, STOP and  <br>// PAUSE mode commands from the filter's ::Run(), ::Stop() and ::Pause()  <br>// methods using the "link" property. <br>// <br>// <br> <br>#include &lt;windows.h&gt; <br>#include &lt;streams.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;math.h&gt; <br> <br>#include &lt;initguid.h&gt; <br>#include &lt;olectl.h&gt; <br>#include &lt;winbase.h&gt; <br> <br>#include "vcruids.h" <br>#include "ctimecod.h" <br>#include "cdevcom.h" <br>#include "cvcrutil.h" <br>#include "fvcrctrl.h" <br>#include "vcrprop.h" <br>#include "trprop.h" <br> <br>#define DbgFunc(a) DbgLog(( LOG_TRACE, \ <br>                            2, \ <br>                            TEXT("CVcrFilter::%s"), \ <br>                            TEXT(a) \ <br>                         )); <br> <br>// IPersistStream macros <br>#define WRITEOUT(var)   hr = pStream-&gt;Write(&amp;var, sizeof(var), NULL); \ <br>                        if (FAILED(hr)) return hr; <br> <br>#define READIN(var)     hr = pStream-&gt;Read(&amp;var, sizeof(var), NULL); \ <br>                        if (FAILED(hr)) return hr; <br> <br>// some local storage <br>LONGLONG CVcrTCOut::m_llLastTime = 0L; <br> <br>const int textbufsize = 12*sizeof(TCHAR); <br>static TIMECODE_SAMPLE tcsTimecode = { <br>0L,{0,0,0L},0L,0L <br>}; <br>// we will ask for timecode samples this often <br>const REFERENCE_TIME rtPeriodTime = 3333 * (UNITS / (100*MILLISECONDS)); <br> <br>// Physical Pin data <br>const TCHAR *strSVO = {"SVO-5800"}; <br>const TCHAR *strPhysConn_Video_Composite = {"Composite"}; <br>const TCHAR *strPhysConn_Video_SVideo = {"S-Video"}; <br>const TCHAR *strPhysConn_Video_Black = {"Black"}; <br>const TCHAR *strPhysConn_Audio_Mic = {"Microphone"}; <br>const TCHAR *strPhysConn_Audio_Line = {"Line"}; <br> <br>// Setup data <br>const AMOVIESETUP_MEDIATYPE sudTcOpPinTypes[] = <br>{ <br>    {&amp;MEDIATYPE_Text,       // Major type <br>    &amp;MEDIASUBTYPE_NULL},    // Minor type <br>{&amp;MEDIATYPE_Timecode,// Major type <br>    &amp;MEDIASUBTYPE_NULL}// Minor type <br>}; <br> <br>const AMOVIESETUP_MEDIATYPE sudAudOpPinType[] = <br>{ <br>    &amp;MEDIATYPE_AnalogAudio,// Major type <br>    &amp;MEDIASUBTYPE_NULL// Minor type <br>}; <br> <br>const AMOVIESETUP_MEDIATYPE sudVidIpPinType[] = <br>{ <br>    &amp;MEDIATYPE_AnalogVideo,// Major type <br>    &amp;MEDIASUBTYPE_AnalogVideo_NTSC_M,// Minor type <br>&amp;MEDIATYPE_AnalogVideo,// Major type <br>    &amp;MEDIASUBTYPE_AnalogVideo_NTSC_M// Minor type <br>}; <br> <br>const AMOVIESETUP_MEDIATYPE sudAudIpPinType[] = <br>{ <br>    &amp;MEDIATYPE_AnalogAudio,// Major type <br>    &amp;MEDIASUBTYPE_NULL,// Minor type <br>&amp;MEDIATYPE_AnalogAudio,// Major type <br>    &amp;MEDIASUBTYPE_NULL// Minor type <br>}; <br> <br>const AMOVIESETUP_PIN sudPins[] = <br>{ <br>   {L"Timecode Out",        // Pin string name <br>    FALSE,                  // Is it rendered <br>    TRUE,                   // Is it an output <br>    FALSE,                  // Can we have none <br>    FALSE,                  // Can we have many <br>    &amp;CLSID_NULL,            // Connects to filter <br>    NULL,                   // Connects to pin <br>    2,                      // Number of types <br>    sudTcOpPinTypes},       // Pin details <br>   {L"Analog Composite Video In",     // Pin string name <br>    FALSE,                  // Is it rendered <br>    FALSE,                  // Is it an output <br>    FALSE,                  // Can we have none <br>    FALSE,                  // Can we have many <br>    &amp;CLSID_NULL,            // Connects to filter <br>    NULL,                   // Connects to pin <br>    1,                      // Number of types <br>    sudVidIpPinType} // Pin details <br>}; <br> <br>const AMOVIESETUP_FILTER sudVcrctrlax = <br>{ <br>    &amp;CLSID_VCRControlFilter, // Filter CLSID <br>    L"VCR Control Filter",   // String name <br>    MERIT_DO_NOT_USE,    // Filter merit <br>    1,                      // Number of pins (that we know about) <br>    sudPins// Pin details <br>}; <br> <br>CFactoryTemplate g_Templates[]= { <br>{L"VCR Control Filter", <br>&amp;CLSID_VCRControlFilter,  <br>CVcrFilter::CreateInstance,  <br>NULL,  <br>&amp;sudVcrctrlax}, <br>{L"VCR Control General Property Page",  <br>&amp;CLSID_VCRControlPropertyPage,  <br>CVcrProperties::CreateInstance,  <br>NULL,  <br>NULL}, <br>{L"VCR Control Transport Property Page",  <br>&amp;CLSID_VCRTransPropertyPage,  <br>CExtTransProperties::CreateInstance,  <br>NULL,  <br>NULL} <br>}; <br>int g_cTemplates = sizeof(g_Templates)/sizeof(g_Templates[0]); <br> <br>//------------------------------------------ <br>// <br>// exported entry points for registration and <br>// unregistration (in this case they only call <br>// through to default implmentations). <br>// <br>//------------------------------------------ <br> <br>//------------------------------------------ <br>// <br>// DllRegisterServer <br>// <br>// Exported entry points for registration and unregistration <br>// <br>STDAPI DllRegisterServer() <br>{ <br>    return AMovieDllRegisterServer2( TRUE ); <br> <br>} // DllRegisterServer <br> <br>//------------------------------------------ <br>// <br>// DllUnregisterServer <br>// <br>//------------------------------------------ <br>STDAPI DllUnregisterServer() <br>{ <br>    return AMovieDllRegisterServer2( FALSE ); <br> <br>} // DllUnregisterServer <br>//------------------------------------------ <br> <br> <br>//------------------------------------------ <br>// <br>// CVcrFilter::Constructor <br>// <br>//------------------------------------------ <br>CVcrFilter::CVcrFilter(TCHAR *tszName, LPUNKNOWN punk, CLSID clsid, <br>HRESULT *phr) <br>    : CBaseFilter(tszName, punk, &amp;m_StateLock, clsid, phr), <br>CAMExtDevice(phr, tszName), <br>CAMExtTransport(phr, tszName), <br>CAMTcr(phr, tszName), <br>CPersistStream(punk, phr), <br>m_iPins(0), <br>m_paStreams(NULL) <br>{ <br>    DbgFunc("CVcrFilter"); <br>     <br>CAutoLock cObjectLock(&amp;m_StateLock); <br>LPOLESTR pName = NULL; <br> <br>// we use a single CDevCom object to make the filter thread-safe <br>CAMTcr::SetCommunicationObject(m_devcom); <br>CAMExtTransport::SetCommunicationObject(m_devcom); <br> <br>// create the pins - reserve space for 6, but we might only make 5 <br>    m_paStreams    = (CBasePin **) new COutStream*[6]; <br>    if (m_paStreams == NULL) { <br>        *phr = E_OUTOFMEMORY; <br>return; <br>    } <br> <br>    // our only output pin <br>m_paStreams[0] = new CVcrTCOut(phr, this, L"Timecode Out"); <br>    if (m_paStreams[0] == NULL) { <br>        *phr = E_OUTOFMEMORY; <br>return; <br>    } <br> <br>// Create the input pins <br>m_paStreams[1] = new CVcrAudioLineInputPin(NAME("VCR Audio Line"),this,  <br>phr, L"Audio Line In"); <br>    if (m_paStreams[1] == NULL) { <br>        *phr = E_OUTOFMEMORY; <br>return; <br>    } <br> <br>m_paStreams[2] = new CVcrAudioMicInputPin(NAME("VCR Audio Line"),this, <br>phr, L"Audio Mic In"); <br>    if (m_paStreams[2] == NULL) { <br>        *phr = E_OUTOFMEMORY; <br>return; <br>    } <br> <br>m_paStreams[3] = new CVcrVideoCompInputPin(NAME("VCR Video Input"),this, <br>phr, L"Composite Video In"); <br>    if (m_paStreams[3] == NULL) { <br>        *phr = E_OUTOFMEMORY; <br>return; <br>    } <br> <br>    m_paStreams[4] = new CVcrVideoSInputPin(NAME("VCR Video Input"),this, <br>phr, L"S-Video In"); <br>    if (m_paStreams[4] == NULL) { <br>        *phr = E_OUTOFMEMORY; <br>return; <br>    } <br> <br>// if this is an SVO-5800, then it has an additional input pin <br>get_ExternalDeviceID( &amp;pName ); <br>if ( strcmp(strSVO, (const char *)(LPSTR)pName) == 0 ) { <br>m_paStreams[5] = new CVcrVideoBlackInputPin(NAME("VCR Video Input"),this, <br>phr, L"Video Black"); <br>if (m_paStreams[5] == NULL) { <br>        *phr = E_OUTOFMEMORY; <br>return; <br>} <br>} <br>QzTaskMemFree(pName);// must release the memory <br>pName = NULL; <br> <br>put_Mode( ED_MODE_STOP ); <br> <br>// configure tc reader <br>SetTCRMode(ED_TCR_SOURCE, ED_TCR_LTC); <br>CPersistStream::SetDirty(TRUE);// always write out the state <br>} <br> <br>//------------------------------------------ <br>// <br>// CreateInstance <br>// <br>// Provide the way for COM to create a CVcrFilter object.  Also <br>// initialize a CVcrTCOut object so that we have a pin. <br>//------------------------------------------ <br>CUnknown * <br>CVcrFilter::CreateInstance(LPUNKNOWN punk, HRESULT *phr) <br>{ <br>    CVcrFilter *pNewObject = new CVcrFilter(NAME("VCR Control Filter"), <br>punk, CLSID_VCRControlFilter, phr); <br>    if (pNewObject == NULL) { <br>        *phr = E_OUTOFMEMORY; <br>    } <br> <br>    return (CSource *)pNewObject; <br>} <br> <br>//------------------------------------------ <br>// <br>// The Destructor <br>// <br>//------------------------------------------ <br>CVcrFilter::~CVcrFilter( void ) <br>{ <br>//  Free our pins and pin array  <br>    while (m_iPins != 0) { <br>// deleting the pins causes them to be removed from the array... <br>delete m_paStreams[m_iPins - 1]; <br>    } <br> <br>    ASSERT(m_paStreams == NULL); <br>} <br> <br>//------------------------------------------ <br>// <br>// NonDelegatingQueryInterface <br>// <br>// Reveal our property pages and IAMExtDev/ <br>//  IAMExtTransport/etc. interfaces <br>//------------------------------------------ <br>STDMETHODIMP <br>CVcrFilter::NonDelegatingQueryInterface(REFIID riid, void **ppv) <br>{ <br>CAutoLock cObjectLock(&amp;m_StateLock); <br> <br>    if (riid == IID_ISpecifyPropertyPages) { <br>        return GetInterface((ISpecifyPropertyPages *) this, ppv); <br>    } else if (riid == IID_IAMExtDevice) { <br>        return GetInterface((IAMExtDevice *) this, ppv); <br>    } else if (riid == IID_IAMExtTransport) { <br>        return GetInterface((IAMExtTransport *) this, ppv); <br>} else if (riid == IID_IAMTimecodeReader) { <br>        return GetInterface((IAMTimecodeReader *) this, ppv); <br>} else if (riid == IID_IPersistStream) { <br>        return GetInterface((IPersistStream *) this, ppv); <br>    }else { <br>        return CBaseFilter::NonDelegatingQueryInterface(riid, ppv); <br>} <br>}  <br> <br>//------------------------------------------ <br>// <br>// GetClassID <br>// <br>// Override CBaseMediaFilter method for interface IPersist <br>// Part of the persistent file support.  We must supply our class id <br>// which can be saved in a graph file and used on loading a graph with <br>// an external device in it to instantiate this filter via CoCreateInstance. <br>// <br>//------------------------------------------ <br>STDMETHODIMP  <br>CVcrFilter::GetClassID(CLSID *pClsid) <br>{ <br>    if (pClsid==NULL) { <br>        return E_POINTER; <br>    } <br>    *pClsid = CLSID_VCRControlFilter; <br>    return NOERROR; <br>} <br> <br>//------------------------------------------ <br>// <br>// SizeMax <br>// <br>// Override CPersistStream method. <br>// State the maximum number of bytes we would ever write in a file <br>// to save our properties. <br>// <br>//------------------------------------------ <br>int <br>CVcrFilter::SizeMax() <br>{ <br>    // When an int is expanded as characters it takes at most 12 characters <br>    // including a trailing delimiter. <br>    // Wide chars doubles this and we want 16 ints. <br>    // <br>    return 384; <br>}  <br> <br>//------------------------------------------ <br>// <br>// WriteToStream <br>// <br>// Override CPersistStream method. <br>// Write our properties to the stream. <br>// <br>//We only write a few of the important properties <br>//to demonstrate the process. <br>// <br>//------------------------------------------ <br>HRESULT <br>CVcrFilter::WriteToStream(IStream *pStream) <br>{ <br>long temp; <br>    HRESULT hr; <br> <br>GetTransportVideoParameters(ED_TRANSVIDEO_SET_SOURCE, &amp;temp); <br>    hr = WRITEOUT(temp); <br>    if (FAILED(hr)) return hr; <br> <br>GetTransportAudioParameters(ED_TRANSAUDIO_SET_SOURCE, &amp;temp); <br>    hr = WRITEOUT(temp); <br>    if (FAILED(hr)) return hr; <br> <br>GetStatus(ED_LINK_MODE, &amp;temp); <br>    hr = WRITEOUT(temp); <br>    if (FAILED(hr)) return hr; <br> <br>get_DevicePort(&amp;temp); <br>    hr = WRITEOUT(temp); <br>    if (FAILED(hr)) return hr; <br> <br>    return NOERROR; <br>} <br> <br>//------------------------------------------ <br>// <br>// ReadFromStream <br>// <br>// Override CPersistStream method. <br>// Read our properties from the stream. <br>// <br>//------------------------------------------ <br>HRESULT <br>CVcrFilter::ReadFromStream(IStream *pStream) <br>{ <br>long temp; <br>    HRESULT hr; <br> <br>hr = READIN(temp); <br>SetTransportVideoParameters(ED_TRANSVIDEO_SET_SOURCE, temp); <br>    if (FAILED(hr)) return hr; <br> <br>hr = READIN(temp); <br>SetTransportAudioParameters(ED_TRANSAUDIO_SET_SOURCE, temp); <br>    if (FAILED(hr)) return hr; <br> <br>hr = READIN(temp); <br>put_Mode(temp);// this will set the link mode <br>    if (FAILED(hr)) return hr; <br> <br>hr = READIN(temp); <br>put_DevicePort(temp);// this will set the active communications <br>    if (FAILED(hr)) return hr;// port <br> <br>    return NOERROR; <br>} <br> <br>//------------------------------------------ <br>// <br>//  Add a new pin <br>// <br>//------------------------------------------ <br>HRESULT <br>CVcrFilter::AddPin(CBasePin *pPin) <br>{ <br>    CAutoLock lock(&amp;m_StateLock); <br> <br>    /*  Allocate space for this pin and the old ones */ <br>    CBasePin **paStreams = new CBasePin *[m_iPins + 1]; <br>    if (paStreams == NULL) { <br>        return E_OUTOFMEMORY; <br>    } <br>    if (m_paStreams != NULL) { <br>        CopyMemory((PVOID)paStreams, (PVOID)m_paStreams, <br>                   m_iPins * sizeof(m_paStreams[0])); <br>        paStreams[m_iPins] = pPin; <br>        delete [] m_paStreams; <br>    } <br>    m_paStreams = (CBasePin **)paStreams; <br>    m_paStreams[m_iPins] = pPin; <br>    m_iPins++; <br>return S_OK; <br>} <br> <br>//------------------------------------------ <br>// <br>//  Remove a pin - pStream is NOT deleted <br>// <br>//------------------------------------------ <br>HRESULT <br>CVcrFilter::RemovePin(CBasePin *pStream) <br>{ <br>    int i; <br>    for (i = 0; i &lt; m_iPins; i++) { <br>        if (m_paStreams[i] == pStream) { <br>            if (m_iPins == 1) { <br>                delete [] m_paStreams; <br>                m_paStreams = NULL; <br>            } else { <br>                /*  no need to reallocate */ <br>while (++i &lt; m_iPins) <br>m_paStreams[i - 1] = m_paStreams[i]; <br>            } <br>            m_iPins--; <br>return S_OK; <br>        } <br>    } <br>    return S_FALSE; <br>} <br> <br>//------------------------------------------ <br>// <br>// GetPinCount <br>// <br>// Returns the number of pins this filter has <br>// <br>//------------------------------------------ <br>int <br>CVcrFilter::GetPinCount(void) <br>{ <br>    CAutoLock lock(&amp;m_StateLock); <br>    return m_iPins; <br>} <br> <br>//------------------------------------------ <br>// <br>// GetPin <br>// <br>// Return a non-addref'd pointer to pin n <br>// needed by CBaseFilter <br>// <br>//------------------------------------------ <br>CBasePin * <br>CVcrFilter::GetPin(int n) <br>{ <br>    CAutoLock lock(&amp;m_StateLock); <br> <br>    if ((m_iPins &gt; 0) &amp;&amp; (n &lt; m_iPins)) { <br> <br>        ASSERT(m_paStreams[n]); <br>return m_paStreams[n]; <br>    } <br>    return NULL; <br>} <br> <br>//------------------------------------------ <br>// <br>// IMediaControl Overrides <br>// <br>//------------------------------------------ <br>HRESULT  <br>CVcrFilter::Run(REFERENCE_TIME tStart) <br>{ <br>long Mode; <br>long LinkMode; <br> <br>DbgFunc("Run"); <br>GetStatus(ED_LINK_MODE, &amp;LinkMode); <br>if (LinkMode == OATRUE) { <br>get_Mode( &amp;Mode ); <br>if (Mode == ED_MODE_FREEZE) <br>put_Mode(ED_MODE_THAW); <br>else <br>put_Mode(ED_MODE_PLAY); <br>} <br> <br>// use the base Run method for the state transition <br>CBaseFilter::Run(tStart); <br>return NOERROR; <br>} <br> <br>HRESULT  <br>CVcrFilter::Pause() { <br>long LinkMode; <br> <br>DbgFunc("Pause"); <br>GetStatus(ED_LINK_MODE, &amp;LinkMode); <br>if (LinkMode == OATRUE) <br>put_Mode(ED_MODE_FREEZE); <br> <br>// use the base Run method for the state transition <br>CBaseFilter::Pause(); <br>return NOERROR; <br>} <br> <br>HRESULT  <br>CVcrFilter::Stop() <br>{ <br>long LinkMode; <br> <br>DbgFunc("Stop"); <br>GetStatus(ED_LINK_MODE, &amp;LinkMode); <br>if (LinkMode == OATRUE) <br>put_Mode(ED_MODE_STOP); <br> <br>// use the base Run method for the state transition <br>CBaseFilter::Stop(); <br>return NOERROR; <br>} <br> <br>// ==============Implementation of the IPropertypages Interface =========== <br>//------------------------------------------ <br>// <br>// GetPages - return the CLSIDs for the property pages we support <br>// <br>//------------------------------------------ <br>STDMETHODIMP  <br>CVcrFilter::GetPages(CAUUID * pPages) <br>{ <br>CAutoLock l(&amp;m_StateLock); <br> <br>CheckPointer(pPages,E_POINTER); <br>     <br>pPages-&gt;cElems = 2; <br>    pPages-&gt;pElems = (GUID *) QzTaskMemAlloc(2 * sizeof(GUID)); <br>    if (pPages-&gt;pElems == NULL) { <br>        return E_OUTOFMEMORY; <br>    } <br> <br>    pPages-&gt;pElems[0] = CLSID_VCRControlPropertyPage; <br>    pPages-&gt;pElems[1] = CLSID_VCRTransPropertyPage; <br> <br>    return NOERROR; <br>} <br> <br>//------------------------------------------ <br>//------------------------------------------ <br>//------------------------------------------ <br>// * <br>// * --- COutStream ---- <br>// * <br>//------------------------------------------ <br>//------------------------------------------ <br>//------------------------------------------ <br>// <br>//------------------------------------------ <br>// <br>// COutStream::Constructor <br>// <br>// increments the number of pins present on the filter <br>// <br>//------------------------------------------ <br>COutStream::COutStream( <br>    TCHAR *pObjectName, <br>    HRESULT *phr, <br>    CVcrFilter *pParent, <br>    LPCWSTR pPinName) <br>    : CBaseOutputPin(pObjectName, pParent, pParent-&gt;pLock(), phr, pPinName), <br>    m_pFilter(pParent), <br>m_pRefClock(NULL), <br>m_hAdviseEvent(NULL) <br>{ <br>     *phr = m_pFilter-&gt;AddPin(this); <br>} <br> <br>//------------------------------------------ <br>// <br>// COutStream::Destructor <br>// <br>// Decrements the number of pins on this filter <br>//------------------------------------------ <br>COutStream::~COutStream(void) <br>{ <br>m_pFilter-&gt;RemovePin(this); <br>} <br>//------------------------------------------ <br>// <br>// Active <br>// <br>// The pin is active - start up the worker thread <br>// <br>//------------------------------------------ <br>HRESULT  <br>COutStream::Active(void) <br>{ <br>    CAutoLock lock(m_pFilter-&gt;pLock()); <br> <br>    HRESULT hr; <br> <br>    if (m_pFilter-&gt;IsActive()) { <br>return S_FALSE;// succeeded, but did not allocate resources  <br>//  (they already exist...) <br>    } <br> <br>    // do nothing if not connected - its ok not to connect to <br>    // all pins of an external device filter <br>    if (!IsConnected()) { <br>        return NOERROR; <br>    } <br> <br>    hr = CBaseOutputPin::Active(); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br> <br>    ASSERT(!ThreadExists()); <br> <br>    // start the thread <br>    if (!Create()) { <br>        return E_FAIL; <br>    } <br> <br>    // Tell thread to initialize. If OnThreadCreate Fails, so does this. <br>    hr = Init(); <br>    if (FAILED(hr)) <br>return hr; <br> <br>    return Pause(); <br>} <br> <br>//------------------------------------------ <br>// <br>// Inactive <br>// <br>// Pin is inactive - shut down the worker thread <br>// Waits for the worker to exit before returning. <br>// <br>//------------------------------------------ <br>HRESULT  <br>COutStream::Inactive(void) <br>{ <br>    CAutoLock lock(m_pFilter-&gt;pLock()); <br> <br>    HRESULT hr; <br> <br>    // do nothing if not connected - its ok not to connect to <br>    // all pins of an external device filter <br>    if (!IsConnected()) <br>        return NOERROR; <br> <br>    // !!! need to do this before trying to stop the thread, because <br>    // we may be stuck waiting for our own allocator!!! <br> <br>    hr = CBaseOutputPin::Inactive();// call this first to decommit  <br>//  the allocator <br>    if (FAILED(hr)) <br>return hr; <br>     <br>    if (ThreadExists()) { <br>hr = Stop(); <br>if (FAILED(hr)) { <br>return hr; <br>} <br>hr = Exit(); <br>if (FAILED(hr)) { <br>return hr; <br>} <br>Close();// Wait for the thread to exit, then tidy up. <br>    } <br>    return NOERROR; <br>} <br> <br>//------------------------------------------ <br>// <br>// ThreadProc <br>// <br>// When this returns the thread exits <br>// Return codes &gt; 0 indicate an error occured <br>// <br>//------------------------------------------ <br>DWORD  <br>COutStream::ThreadProc(void) <br>{ <br>    HRESULT hr;  // the return code from calls <br>    Command com; <br>REFERENCE_TIME rtNow; <br>DWORD    dwAdviseToken; <br> <br>    do { <br>com = GetRequest(); <br>if (com != CMD_INIT) { <br>DbgLog((LOG_ERROR, 1, TEXT("Thread expected init command"))); <br>Reply(E_UNEXPECTED); <br>} <br>    } while (com != CMD_INIT); <br> <br>    DbgLog((LOG_TRACE, 1, TEXT("COutStream worker thread initializing"))); <br> <br>    hr = OnThreadCreate(); // perform set up tasks <br>    if (FAILED(hr)) { <br>        DbgLog((LOG_ERROR, 1, <br>TEXT("COutStream::OnThreadCreate failed. Aborting thread."))); <br>        OnThreadDestroy(); <br>Reply(hr);// send failed return code from OnThreadCreate <br>        return 1; <br>    } <br> <br>    // Initialisation suceeded <br>    Reply(NOERROR); <br> <br>    Command cmd; <br>    do { <br>cmd = GetRequest(); <br> <br>switch (cmd) { <br> <br>case CMD_EXIT: <br>Reply(NOERROR); <br>break; <br> <br>case CMD_RUN: <br>DbgLog((LOG_ERROR, 1,  <br>TEXT("CMD_RUN received before a CMD_PAUSE???"))); <br>// !!! fall through??? <br>case CMD_PAUSE: <br>Reply(NOERROR); <br>// we pick up the reference clock here <br>if ( m_pFilter-&gt;GetSyncSource(&amp;m_pRefClock) ) <br>return (DWORD) VFW_E_NO_CLOCK; <br>ASSERT(m_pRefClock); <br>// and set the tick to 33.33ms (an NTSC video frame).  We use a <br>// "one-shot" event instead of a periodic notification because <br>// we don't want events to stack up due to system latencies. <br>m_hAdviseEvent = CreateEvent(NULL, FALSE, FALSE, NULL); <br>m_pRefClock-&gt;GetTime(&amp;rtNow); <br>m_pRefClock-&gt;AdviseTime(m_tStart, rtNow+rtPeriodTime, <br>(unsigned long)m_hAdviseEvent, &amp;dwAdviseToken); <br> <br>DoBufferProcessingLoop(); <br>break; <br> <br>case CMD_STOP: <br>// release our reference clock <br>m_pRefClock-&gt;Release(); <br>m_pRefClock = NULL; <br>m_hAdviseEvent = NULL; <br>Reply(NOERROR); <br>break; <br> <br>default: <br>DbgLog((LOG_ERROR, 1, TEXT("Unknown command %d received!"), cmd)); <br>Reply(E_NOTIMPL); <br>break; <br>} <br>    } while (cmd != CMD_EXIT); <br> <br>    hr = OnThreadDestroy();// tidy up. <br>    if (FAILED(hr)) { <br>        DbgLog((LOG_ERROR, 1, <br>TEXT("COutStream::OnThreadDestroy failed. Exiting thread."))); <br>        return 1; <br>    } <br> <br>    DbgLog((LOG_TRACE, 1, TEXT("COutStream worker thread exiting"))); <br>    return 0; <br>} <br> <br>//------------------------------------------ <br>// <br>// DoBufferProcessingLoop <br>// <br>// Grabs a buffer and waits for a frame time to pass <br>// <br>//------------------------------------------ <br>HRESULT  <br>COutStream::DoBufferProcessingLoop(void) <br>{ <br>    Command com; <br>REFERENCE_TIME rtNow = 0L; <br>REFERENCE_TIME rtAdvise = 0L; <br>DWORD    dwAdviseToken; <br> <br>    OnThreadStartPlay(); <br> <br>    do { <br>while (!CheckRequest(&amp;com)) { <br> <br>    IMediaSample *pSample; <br> <br>    HRESULT hr = GetDeliveryBuffer(&amp;pSample,NULL,NULL,FALSE); <br>    if (FAILED(hr)) { <br>continue;// go round again. Perhaps the error will go away <br>    // or the allocator is decommited &amp; we will be asked to <br>    // exit soon. <br>    } <br> <br>    // Virtual function user will override. <br>    hr = FillBuffer(pSample); <br>    // !!! shouldn't we check for errors here??? <br> <br>    if (hr == S_OK) { <br>Deliver(pSample); <br>    } else if (hr == S_FALSE) { <br>pSample-&gt;Release(); <br>DeliverEndOfStream(); <br>return S_OK; <br>    } else { <br>DbgLog((LOG_ERROR, 1, TEXT("Error %08lX from FillBuffer!!!"), hr)); <br>    } <br> <br>    pSample-&gt;Release(); <br>// and block here for a frame - <br>// but only do this if an event has been set <br>if (m_hAdviseEvent) { <br>WaitForSingleObject(m_hAdviseEvent, 1000L); <br>// woke up - show the time <br>m_pRefClock-&gt;GetTime(&amp;rtNow); <br>rtAdvise = rtNow + rtPeriodTime; <br>// reset the clock <br>m_pRefClock-&gt;AdviseTime(m_tStart, rtAdvise, <br>(unsigned long)m_hAdviseEvent, &amp;dwAdviseToken); <br>} <br>} <br> <br>if (com == CMD_RUN || com == CMD_PAUSE) <br>    com = GetRequest(); // throw command away <br>else if (com != CMD_STOP) { <br>    DbgLog((LOG_ERROR, 1, TEXT("Unexpected command!!!"))); <br>} <br>    } while (com != CMD_STOP); <br> <br>    return S_FALSE; <br>} <br> <br>//------------------------------------------ <br>//------------------------------------------ <br>//------------------------------------------ <br>// * <br>// * CVcrTCOut <br>// * <br>//------------------------------------------ <br>//------------------------------------------ <br>//------------------------------------------ <br> <br>//------------------------------------------ <br>// <br>// CVcrTCOut::Constructor <br>// <br>// Create a default stream <br>// <br>//------------------------------------------ <br>CVcrTCOut::CVcrTCOut(HRESULT *phr, CVcrFilter *pParent, LPCWSTR pName) <br>    : COutStream(NAME("VCR Timecode output pin"),phr, pParent, pName), <br>    m_pFilter(pParent) <br>{ <br>    CAutoLock l(m_pFilter-&gt;pLock()); <br> <br>m_ctc = new CTimecode(); <br>} <br> <br>//------------------------------------------ <br>// <br>// CVcrTCOut::Destructor <br>// <br>//------------------------------------------ <br>CVcrTCOut::~CVcrTCOut(void) <br>{ <br>    CAutoLock l(m_pFilter-&gt;pLock()); <br> <br>    delete m_ctc; <br> <br>} <br> <br>//------------------------------------------ <br>// <br>// FillBuffer <br>// <br>// Stuffs the buffer with data <br>// <br>//------------------------------------------ <br>HRESULT  <br>CVcrTCOut::FillBuffer(IMediaSample *pms) <br>{ <br>    BYTE*pData; <br>    long mode; <br>DWORDdwresult; <br> <br>    TIMECODE_SAMPLE tcsTimecode ; <br> <br>    pms-&gt;GetPointer(&amp;pData); <br>     <br>//what time is it? <br>CRefTime rtStart  = m_rtSampleTime;// the current time is  <br>//  the sample's start <br>    m_rtSampleTime += (LONG)(1000L*1001L)/30000L;// 29.97 fps for  <br>//  now in 100 ns units <br>    pms-&gt;SetTime((REFERENCE_TIME*)&amp;rtStart, <br>                 (REFERENCE_TIME*)&amp;m_rtSampleTime); <br> <br>if ( *(m_mt.Type()) == MEDIATYPE_Text) <br>            pms-&gt;SetActualDataLength(textbufsize); <br>else <br>            pms-&gt;SetActualDataLength(sizeof(TIMECODE_SAMPLE)); <br> <br> <br>// should we update the display (only when in PLAY)? <br>m_pFilter-&gt;get_Mode(&amp;mode); <br>if ( mode == ED_MODE_PLAY ) { <br>// get a new timecode <br>if ( (dwresult = m_pFilter-&gt;GetTimecode(&amp;tcsTimecode)) ) <br>tcsTimecode.timecode.dwFrames = -1; <br>if ( m_mtype == 0) { <br>// we need to output text - make the timecode displayable <br>m_ctc-&gt;ConvertTimecodeToString(&amp;tcsTimecode, (TCHAR *)pData); <br>} <br>else { <br>// dummy out unused members <br>tcsTimecode.qwTick = m_rtSampleTime; <br>tcsTimecode.timecode.wFrameFract = 0; <br>tcsTimecode.dwUser = 0L; <br>tcsTimecode.dwFlags = 0x0000;// make it non-drop for now <br>memcpy((TCHAR *)pData, &amp;tcsTimecode, sizeof(TIMECODE_SAMPLE)); <br>} <br>} <br>    return NOERROR; <br>} <br> <br>//------------------------------------------ <br>// <br>// GetMediaType <br>// <br>//------------------------------------------ <br>HRESULT  <br>CVcrTCOut::GetMediaType(int iPosition, CMediaType *pmt) <br>{ <br>    CAutoLock l(m_pFilter-&gt;pLock()); <br> <br>    if (iPosition&lt;0) { <br>        return E_INVALIDARG; <br>    } <br>// we support 2 media types now <br>if (iPosition == 0) { <br>pmt-&gt;SetType(&amp;MEDIATYPE_Text); <br>pmt-&gt;SetSubtype(&amp;GUID_NULL); <br>} <br>else if (iPosition == 1) { <br>pmt-&gt;SetType(&amp;MEDIATYPE_Timecode); <br>pmt-&gt;SetSubtype(&amp;MEDIASUBTYPE_NULL); <br>} <br>else if (iPosition&gt;1) { <br>        return VFW_S_NO_MORE_ITEMS; <br>    } <br> <br>    // no temporal compression in both cases <br>    pmt-&gt;SetTemporalCompression(FALSE); <br>         <br>    return NOERROR; <br>} <br> <br>//------------------------------------------ <br>// <br>// CheckMediaType <br>// <br>// Returns E_INVALIDARG if the mediatype is not  <br>//acceptable, S_OK if it is <br>// <br>//------------------------------------------ <br>HRESULT  <br>CVcrTCOut::CheckMediaType(const CMediaType *pMediaType) <br>{ <br>    CAutoLock l(m_pFilter-&gt;pLock()); <br> <br>    if (*(pMediaType-&gt;Type()) != MEDIATYPE_Text &amp;&amp; <br>*(pMediaType-&gt;Type()) != MEDIATYPE_Timecode)//Text or timecode only <br>       return E_INVALIDARG; <br>     <br>    return S_OK;  // This format is acceptable. <br>} <br> <br>//------------------------------------------ <br>// <br>// DecideBufferSize <br>// <br>// This will always be called after the format has been sucessfully <br>// negotiated. So we have a look at m_mt to see what size media sample <br>// we agreed. Then we can ask for buffers of the correct size to contain them. <br>// <br>//------------------------------------------ <br>HRESULT  <br>CVcrTCOut::DecideBufferSize(IMemAllocator *pAlloc, <br>ALLOCATOR_PROPERTIES *pRequest) <br>{ <br>    CAutoLock l(m_pFilter-&gt;pLock()); <br> <br>if ( *(m_mt.Type()) == MEDIATYPE_Text) <br>pRequest-&gt;cbBuffer = textbufsize;//the size we will request <br>else <br>pRequest-&gt;cbBuffer = sizeof(TIMECODE_SAMPLE);//the size we will request <br> <br>pRequest-&gt;cBuffers = 5;           //the number of buffers to use. <br>    ALLOCATOR_PROPERTIES  Actual; <br>    pAlloc-&gt;SetProperties(pRequest, &amp;Actual); <br> <br>    if ((Actual.cbBuffer &lt; pRequest-&gt;cbBuffer) ) // this allocator is unsuitable <br>        return E_FAIL; <br>     <br>    return NOERROR; <br>} <br> <br>//------------------------------------------ <br>// <br>// OnThreadCreate <br>// <br>// as we go active reset the stream time to zero <br>// <br>//------------------------------------------ <br>HRESULT  <br>CVcrTCOut::OnThreadCreate(void) <br>{ <br>// save a local copy of the currently selected media type </code></pre>
<p>
</p>
<pre><code>// for this pin: 0 for text, 1 for timecode <br>if (*(m_mt.Type()) == MEDIATYPE_Text) <br>m_mtype = 0; <br>else <br>m_mtype = 1; <br> <br>    m_rtSampleTime = 0; <br>tcsTimecode.timecode.dwFrames = 0L; <br> <br>    return NOERROR; <br>} <br> <br>//------------------------------------------ <br>//------------------------------------------ <br>//------------------------------------------ <br>// * <br>// * CVcrInputPin  <br>// * <br>// <br>// Base class for hardware input pins <br>//------------------------------------------ <br>//------------------------------------------ <br>//------------------------------------------ <br> <br>//------------------------------------------ <br>// <br>// CVcrInputPin Constructor <br>// <br>//------------------------------------------ <br>CVcrInputPin::CVcrInputPin(TCHAR *pObjectName, CVcrFilter *pFilter, <br>HRESULT * phr, LPCWSTR pName) <br>: <br>CBaseInputPin(pObjectName, pFilter, pFilter-&gt;pLock(), phr, pName), <br>CAMPhysicalPinInfo(phr, (TCHAR *)pName), <br>m_pFilter(pFilter) <br>{ <br>   DbgLog((LOG_TRACE,1,TEXT("CVcrInputPin constructor"))); <br>    ASSERT(pFilter); <br>*phr = m_pFilter-&gt;AddPin(this); <br>} <br> <br>//------------------------------------------ <br>// <br>//CVcrInputPin Destructor <br>// <br>//------------------------------------------ <br>CVcrInputPin::~CVcrInputPin(void)  <br>{ <br>DbgLog((LOG_TRACE,1,TEXT("*Destroying an input pin"))); <br>m_pFilter-&gt;RemovePin(this); <br>} <br> <br>//------------------------------------------ <br>// <br>// NonDelegatingQueryInterface <br>// <br>// Reveal our Interfaces <br>//------------------------------------------ <br>STDMETHODIMP <br>CVcrInputPin::NonDelegatingQueryInterface(REFIID riid, void **ppv) <br>{ <br>CAutoLock cObjectLock(&amp;m_StateLock); <br> <br>    if (riid == IID_IAMPhysicalPinInfo) <br>        return GetInterface((IAMPhysicalPinInfo *) this, ppv); <br>    else <br>        return CBaseInputPin::NonDelegatingQueryInterface(riid, ppv); <br>}  <br> <br>//------------------------------------------ <br>//------------------------------------------ <br>//------------------------------------------ <br>// * <br>// * CVcrVideoCompInputPin <br>// * <br>//------------------------------------------ <br>//------------------------------------------ <br>//------------------------------------------ <br> <br>//------------------------------------------ <br>// <br>// CVcrVideoCompInputPin Constructor <br>// <br>//------------------------------------------ <br>CVcrVideoCompInputPin::CVcrVideoCompInputPin(TCHAR *pObjectName, <br> CVcrFilter *pFilter, <br>HRESULT * phr, LPCWSTR pName) <br>: <br>CVcrInputPin(pObjectName, pFilter, phr, pName) <br>{ <br> <br>} <br> <br>//------------------------------------------ <br>// <br>//CVcrVideoCompInputPin Destructor <br>// <br>//------------------------------------------ <br>CVcrVideoCompInputPin::~CVcrVideoCompInputPin(void)  <br>{ <br>} <br> <br>//------------------------------------------ <br>// <br>// GetPhysicalType <br>// <br>// Returns physical connection info <br>// <br>//------------------------------------------ <br> <br>HRESULT <br>CVcrVideoCompInputPin::GetPhysicalType( long *pType, LPOLESTR * ppszType) <br>{ <br>    *pType = PhysConn_Video_Composite; <br>CheckPointer(ppszType, E_POINTER); <br>*ppszType = NULL; <br>// query the device <br>*ppszType = (LPOLESTR) <br>QzTaskMemAlloc(sizeof(WCHAR) * \ <br>(1+lstrlenW((LPOLESTR)strPhysConn_Video_Composite))); <br>if (*ppszType !=NULL) <br>lstrcpyW(*ppszType, (LPOLESTR)strPhysConn_Video_Composite); <br> <br>return S_OK; <br>} <br> <br>//------------------------------------------ <br>//------------------------------------------ <br>//------------------------------------------ <br>// * <br>// * CVcrVideoSInputPin <br>// * <br>//------------------------------------------ <br>//------------------------------------------ <br>//------------------------------------------ <br> <br>//------------------------------------------ <br>// <br>// CVcrVideoSInputPin Constructor <br>// <br>//------------------------------------------ <br>CVcrVideoSInputPin::CVcrVideoSInputPin(TCHAR *pObjectName, CVcrFilter *pFilter, <br>HRESULT * phr, LPCWSTR pName) <br>: <br>CVcrInputPin(pObjectName, pFilter, phr, pName) <br>{ <br> <br>} <br> <br>//------------------------------------------ <br>// <br>//CVcrVideoSInputPin Destructor <br>// <br>//------------------------------------------ <br>CVcrVideoSInputPin::~CVcrVideoSInputPin(void)  <br>{ <br> <br>} <br> <br>//------------------------------------------ <br>// <br>// GetPhysicalType <br>// <br>// Returns physical connection info <br>// <br>//------------------------------------------ <br> <br>HRESULT <br>CVcrVideoSInputPin::GetPhysicalType( long *pType, LPOLESTR * ppszType) <br>{ <br>    *pType = PhysConn_Video_SVideo; <br>CheckPointer(ppszType, E_POINTER); <br>*ppszType = NULL; <br>// query the device <br>*ppszType = (LPOLESTR) <br>QzTaskMemAlloc(sizeof(WCHAR) * \ <br>(1+lstrlenW((LPOLESTR)strPhysConn_Video_SVideo))); <br>if (*ppszType !=NULL) <br>lstrcpyW(*ppszType, (LPOLESTR)strPhysConn_Video_SVideo); <br> <br>return S_OK; <br>} <br> <br>//------------------------------------------ <br>//------------------------------------------ <br>//------------------------------------------ <br>// * <br>// * CVcrVideoBlackInputPin <br>// * <br>//------------------------------------------ <br>//------------------------------------------ <br>//------------------------------------------ <br> <br>//------------------------------------------ <br>// <br>// CVcrVideoBlackInputPin Constructor <br>// <br>//------------------------------------------ <br>CVcrVideoBlackInputPin::CVcrVideoBlackInputPin(TCHAR *pObjectName, <br>   CVcrFilter *pFilter, <br>HRESULT * phr, LPCWSTR pName) <br>: <br>CVcrInputPin(pObjectName, pFilter, phr, pName) <br>{ <br> <br>} <br> <br>//------------------------------------------ <br>// <br>//CVcrVideoBlackInputPin Destructor <br>// <br>//------------------------------------------ <br>CVcrVideoBlackInputPin::~CVcrVideoBlackInputPin(void)  <br>{ <br> <br>} <br> <br>//------------------------------------------ <br>// <br>// GetPhysicalType <br>// <br>// Returns physical connection info <br>// <br>//------------------------------------------ <br> <br>HRESULT <br>CVcrVideoBlackInputPin::GetPhysicalType( long *pType, LPOLESTR * ppszType) <br>{ <br>*pType = PhysConn_Video_Black; <br>CheckPointer(ppszType, E_POINTER); <br>*ppszType = NULL; <br>// query the device <br>*ppszType = (LPOLESTR) <br>QzTaskMemAlloc(sizeof(WCHAR) * \ <br>(1+lstrlenW((LPOLESTR)strPhysConn_Video_Black))); <br>if (*ppszType !=NULL) <br>lstrcpyW(*ppszType, (LPOLESTR)strPhysConn_Video_Black); <br> <br>    return S_OK; <br>} <br> <br> <br>//------------------------------------------ <br>//------------------------------------------ <br>//------------------------------------------ <br>// * <br>// * CVcrAudioLineInputPin <br>// * <br>//------------------------------------------ <br>//------------------------------------------ <br>//------------------------------------------ <br> <br>//------------------------------------------ <br>// <br>// CVcrAudioLineInputPin Constructor <br>// <br>//------------------------------------------ <br>CVcrAudioLineInputPin::CVcrAudioLineInputPin(TCHAR *pObjectName, <br> CVcrFilter *pFilter, <br>HRESULT * phr, LPCWSTR pName) <br>: <br>CVcrInputPin(pObjectName, pFilter, phr, pName) <br>{ <br> <br>} <br> <br>//------------------------------------------ <br>// <br>//CVcrAudioLineInputPin Destructor <br>// <br>//------------------------------------------ <br>CVcrAudioLineInputPin::~CVcrAudioLineInputPin(void)  <br>{ <br> <br>} <br> <br>//------------------------------------------ <br>// <br>// GetPhysicalType <br>// <br>// Returns physical connection info <br>// <br>//------------------------------------------ <br> <br>HRESULT <br>CVcrAudioLineInputPin::GetPhysicalType( long *pType, LPOLESTR * ppszType) <br>{ <br>*pType = PhysConn_Audio_Line; <br>CheckPointer(ppszType, E_POINTER); <br>*ppszType = NULL; <br>// query the device <br>*ppszType = (LPOLESTR) <br>QzTaskMemAlloc(sizeof(WCHAR) *  <br>(1+lstrlenW((LPOLESTR)strPhysConn_Audio_Line))); <br>if (*ppszType !=NULL) <br>lstrcpyW(*ppszType, (LPOLESTR)strPhysConn_Audio_Line); <br> <br>return S_OK; <br>} <br> <br>//------------------------------------------ <br>//------------------------------------------ <br>//------------------------------------------ <br>// * <br>// * CVcrAudioMicInputPin <br>// * <br>//------------------------------------------ <br>//------------------------------------------ <br>//------------------------------------------ <br> <br>//------------------------------------------ <br>// <br>// CVcrAudioMicInputPin Constructor <br>// <br>//------------------------------------------ <br>CVcrAudioMicInputPin::CVcrAudioMicInputPin(TCHAR *pObjectName, <br>   CVcrFilter *pFilter, <br>HRESULT * phr, <br>LPCWSTR pName) <br>: <br>CVcrInputPin(pObjectName, pFilter, phr, pName) <br>{ <br> <br>} <br> <br>//------------------------------------------ <br>// <br>//CVcrAudioMicInputPin Destructor <br>// <br>//------------------------------------------ <br>CVcrAudioMicInputPin::~CVcrAudioMicInputPin(void)  <br>{ <br> <br>} <br> <br>//------------------------------------------ <br>// <br>// GetPhysicalType <br>// <br>// Returns physical connection info <br>// <br>//------------------------------------------ <br> <br>HRESULT <br>CVcrAudioMicInputPin::GetPhysicalType( long *pType, LPOLESTR * ppszType) <br>{ <br>*pType = PhysConn_Audio_Mic; <br>CheckPointer(ppszType, E_POINTER); <br>*ppszType = NULL; <br>// query the device <br>*ppszType = (LPOLESTR) <br>QzTaskMemAlloc(sizeof(WCHAR) * \ <br>(1+lstrlenW((LPOLESTR)strPhysConn_Audio_Mic))); <br>if (*ppszType !=NULL) <br>lstrcpyW(*ppszType, (LPOLESTR)strPhysConn_Audio_Mic); <br> <br>    return S_OK; <br>} <br> <br>//eof fvcrctrl.cpp <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
