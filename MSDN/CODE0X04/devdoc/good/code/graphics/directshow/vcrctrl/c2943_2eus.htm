<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CDEVCOM.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2944"></a>CDEVCOM.H</h2>
<pre><code>//=========================================================================== <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>// PURPOSE. <br>// <br>// Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//=========================================================================== <br>// <br>//filename: cdevcom.h <br>// <br>//header for devcom.cpp - External Device Communications Class <br>//for an SVO-type RS-422 Controlled Tape Machine and <br>//SVBK-type RS-232 Controlled machines <br>// <br>// <br>#ifndef CDEVCOM_H <br>#defineCDEVCOM_H1 <br> <br>//---------------------------------------------------------- <br>// <br>// Structures and definitions for this implementation <br>// <br>// communications and low-level protocol defines <br>// device ports <br>#define DEV_PORT_SIM1 <br>#define DEV_PORT_COM12// standard serial ports <br>#define DEV_PORT_COM23 <br>#define DEV_PORT_COM34 <br>#define DEV_PORT_COM45 <br>#define DEV_PORT_DIAQ6// Diaquest driver <br>#define DEV_PORT_ARTI7// ARTI driver <br>#define DEV_PORT_13948// IEEE 1394 Bus <br>#define DEV_PORT_USB9// Universal Serial Bus <br>#define DEV_PORT_MINDEV_PORT_SIM <br>#define DEV_PORT_MAXDEV_PORT_USB <br> <br>// machine commands - ****The order of these must match the order <br>// of the commands in the command list in devcom.cpp!!! <br>#define PLAY0 <br>#define STOP1 <br>#define READ_TC2 <br>#define TIMER_MODE_SELECT_LTC 3 <br>#define REWIND4 <br>#define FREEZE_ON 5 <br>#define FREEZE_OFF 6 <br>#define STANDBY_OFF 7 <br>#define STANDBY_ON 8 <br>#define DEVICE_TYPE_REQUEST 9 <br>#define REQUEST_STATUS 10 <br>#define EJECT 11 <br>#define LOCAL_ON 12 <br>#define LOCAL_OFF 13 <br>#define FFWD 14 <br>#define RECORD 15 <br>#define DEVICE_CLEAR 16 <br> <br>// error values <br>#define DEV_COMM_ERR_COMMAND_NOT_SENT_YET1L <br>#define DEV_COMM_ERR_QUEUE_OVERFLOW2L <br>#define DEV_COMM_ERR_COMMUNICATION_ERROR3L <br>#define DEV_COMM_ERR_RESPONSE_MISMATCH4L <br>#define DEV_COMM_ERR_RESPONSE_TIMEOUT5L <br>#define DEV_COMM_ERR_RESPONSE_CHECKSUM6L <br>#define DEV_COMM_ERR_COMMAND_MISSING7L <br>#define DEV_COMM_ERR_RESPONSE_OVERFLOW8L <br>#define DEV_COMM_ERR_RESPONSE_MISSING9L <br>#define DEV_COMM_ERR_COMMAND_NOT_SUPPORTED10L <br> <br>// low level machine status structure filled in after <br>// REQUEST_STATUS command from above.  This structure would <br>// grow in a full implementation <br>typedef struct tagVCRSTATUS{ <br>BOOL bCassetteOut;// OATRUE means no cassette <br>BOOL bLocal;// OATRUE means front panel switch in local <br>} VCRSTATUS; <br> <br>typedef VCRSTATUS far *PVCRSTATUS; <br> <br>typedef struct tagCOMMANDOBJECT { <br>int Command; <br>int Cookie; <br>DWORD Timestamp; <br>} COMMANDOBJECT; <br>typedef COMMANDOBJECT far *PCOMMANDOBJECT; <br> <br>typedef struct tagRESPONSEOBJECT { <br>int Cookie; <br>int ResponseByteCount; <br>TCHAR buf[16]; <br>} RESPONSEOBJECT; <br>typedef RESPONSEOBJECT far *PRESPONSEOBJECT; <br> <br>//---------------------------------------------------------- <br>// <br>//The communications object <br>// <br>//---------------------------------------------------------- <br>class CDevCom : public CCritSec{ <br>public: <br>// constructor <br>CDevCom(CBaseFilter *pFilter, HRESULT *phr); <br> <br>~CDevCom(); <br> <br>// all of these methods return 0 for success <br>// Initialize Device Port accepts the following: <br>//DEV_PORT_COM1 | DEV_PORT_COM2 |DEV_PORT_COM3 |  <br>//DEV_PORT_COM3 | DEV_PORT_DIAQ | DEV_PORT_ARTI etc. <br>DWORD OpenDevPort(int port); <br> <br>// Close Device Port <br>DWORD CloseDevPort(void); <br> <br>// Flush Device Response Buffer <br>DWORD FlushDevResponseBuffer(void); <br> <br>// Send command to device. <br>DWORD SendDevCmd(int, int *); <br> <br>// Read response from device - accepts pointer to response buffer <br>// Must pass cookie in to get proper command.  If command hasn't <br>// actually been sent, method returns with and error value <br>DWORD GetDevResponse(TCHAR *, int); <br>// this one sits around (by sleeping) until either the proper <br>// response comes back, a timeout occurs, or an error happens. <br>DWORD Wait4DevResponse(TCHAR *, int); <br> <br>// convert response to device type request to a string <br>void ProcessDeviceTypeResponse( TCHAR *bufin, TCHAR *bufout); <br> <br>// convert status request response to something meaningful <br>BOOL ProcessDeviceStatusResponse( TCHAR *bufin, PVCRSTATUS pStatus ); <br> <br>// convert raw machine timecode to something usable <br>DWORD ProcessVcrTC(TCHAR * RawTC, DWORD * pdwFCM, long * ptimecode,  <br>long * puserbits); <br> <br>protected: <br>CCritSec  *m_pCritSec;// Object we use for locking <br> <br>private: <br>CTimecode *m_pTimecode; <br>CBaseFilter *m_pFilter;// our filter <br> <br>static HANDLEm_hDevPort;// handle of opened comm port <br>static TCHAR *m_pcDevPort;// name of opened comm port <br>static BYTEm_bLastCmd; <br>static BYTEm_LastMotionCmd;// need this for effective  <br>//  simulation <br>static DCB m_dcb;// initialize this with  <br>//   GetCommState <br>static int m_PendingResponseCnt;// for synchronizing responses <br>static BOOLm_bSimulateHardware;// TRUE if no VCR connected <br>static COMMTIMEOUTS m_ctmoTimeout;// communications timeout structure <br>static COMSTATm_csCommStat;// communications status structure <br>static intm_CurCmdCookie;// used for command queueing <br>static intm_LastSentCmdCookie;// so we know immediately which  <br>//   command was just sent <br> <br>DWORD GetSimulatedResponse( TCHAR *buf );// for the big fake out <br>BOOL m_isMotionCmd( BYTE Cmd ); <br>PCOMMANDOBJECT AddCommand(int Cmd, int Cookie); <br>void RemoveCommand(PCOMMANDOBJECT pCmd); <br>DWORD ReallySendDevCmd(int, int); <br>DWORD ReallyGetDevResponse( TCHAR *buf, int bytecnt ); <br>BOOL TestResponse( TCHAR *buf, int Count ); <br>DWORD BufferResponse(void); <br>DWORD GetBufferedResponse( TCHAR *buf, int Cookie); <br>BOOL IsResponseBuffered( int Cookie, int *index); <br>void GetSimulatedTimecode(TCHAR * timecode, long framecount); <br>}; <br> <br>#endif// #ifndef CDEVCOM_H <br>// eof cdevcom.h </code></pre>
<p>&nbsp;</p></body>
</HTML>
