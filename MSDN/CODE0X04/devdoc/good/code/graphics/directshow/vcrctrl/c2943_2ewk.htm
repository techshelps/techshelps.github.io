<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>VCRPROP.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2954"></a>VCRPROP.CPP</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br>// <br>// vcrprop.cpp - IAMExtDevice Property Page for VCR Control Filter <br>// <br> <br>#include &lt;streams.h&gt; <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;commctrl.h&gt; <br>#include &lt;olectl.h&gt; <br>#include &lt;memory.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;tchar.h&gt; <br> <br>#include "ctimecod.h" <br>#include "cdevcom.h" <br>#include "cvcrutil.h" <br>#include "vcruids.h" <br> <br>#include "resource.h" <br>#include "fvcrctrl.h" <br>#include "vcrprop.h" <br> <br>// initialize some data for device capabilities.  Each entry has 3 data items <br>//the first item describes whether the capability value is text or numerical, <br>//  (we know they are all returned in "Value" parm of the capability method). <br>//The 2nd is the string ID, and the last is the parameter itself <br>typedef struct tagDEVCAPINFO{ <br>int ValueType;// ED_STR || ED_NUM <br>int StringID; <br>int DevCap; <br>} DEVCAPINFO; <br> <br>#define ED_STR 1 <br>#define ED_NUM 2 <br>#define ED_VAL 3 <br>#define ED_DBL 4 <br> <br>static DEVCAPINFO DevCapTable[] = { <br>{ ED_STR, IDS_DEVCAP_CAN_RECORD, ED_DEVCAP_CAN_RECORD }, <br>{ ED_STR, IDS_DEVCAP_CAN_RECORD_STROBE, ED_DEVCAP_CAN_RECORD_STROBE }, <br>{ ED_STR, IDS_DEVCAP_HAS_AUDIO, ED_DEVCAP_HAS_AUDIO }, <br>{ ED_STR, IDS_DEVCAP_HAS_VIDEO, ED_DEVCAP_HAS_VIDEO }, <br>{ ED_STR, IDS_DEVCAP_USES_FILES, ED_DEVCAP_USES_FILES },          <br>{ ED_STR, IDS_DEVCAP_CAN_SAVE, ED_DEVCAP_CAN_SAVE },            <br>{ ED_STR, IDS_DEVCAP_DEVICE_TYPE, ED_DEVCAP_DEVICE_TYPE },         <br>{ ED_STR, IDS_DEVCAP_TIMECODE_READ, ED_DEVCAP_TIMECODE_READ },       <br>{ ED_STR, IDS_DEVCAP_TIMECODE_WRITE, ED_DEVCAP_TIMECODE_WRITE },      <br>{ ED_STR, IDS_DEVCAP_CTLTRK_READ, ED_DEVCAP_CTLTRK_READ },         <br>{ ED_STR, IDS_DEVCAP_INDEX_READ, ED_DEVCAP_INDEX_READ },          <br>{ ED_NUM, IDS_DEVCAP_PREROLL, ED_DEVCAP_PREROLL },             <br>{ ED_NUM, IDS_DEVCAP_POSTROLL, ED_DEVCAP_POSTROLL },            <br>{ ED_STR, IDS_DEVCAP_SYNCACC, ED_DEVCAP_SYNC_ACCURACY },             <br>{ ED_STR, IDS_DEVCAP_NORMAL_RATE, ED_DEVCAP_NORMAL_RATE },         <br>{ ED_STR, IDS_DEVCAP_CAN_PREVIEW, ED_DEVCAP_CAN_PREVIEW },         <br>{ ED_STR, IDS_DEVCAP_CAN_MONITOR_SOURCES, ED_DEVCAP_CAN_MONITOR_SOURCES }, <br>{ ED_STR, IDS_DEVCAP_CAN_TEST, ED_DEVCAP_CAN_TEST },                   <br>{ ED_STR, IDS_DEVCAP_VIDEO_INPUTS, ED_DEVCAP_VIDEO_INPUTS },        <br>{ ED_STR, IDS_DEVCAP_AUDIO_INPUTS, ED_DEVCAP_AUDIO_INPUTS },       <br>{ ED_STR, IDS_DEVCAP_NEEDS_CALIBRATING, ED_DEVCAP_NEEDS_CALIBRATING },   <br>{ ED_STR, IDS_DEVCAP_SEEK_TYPE, ED_DEVCAP_SEEK_TYPE },    <br>}; <br>const int MaxDevCaps = sizeof(DevCapTable) / sizeof(DevCapTable[0]); <br> <br>// this table is for getting the string ID's of the responses <br>static long DevValueTable[][2] = { <br>{ IDS_DEVTYPE_VCR,         ED_DEVTYPE_VCR }, <br>{ IDS_DEVTYPE_LASERDISK,   ED_DEVTYPE_LASERDISK }, <br>{ IDS_DEVTYPE_ATR,         ED_DEVTYPE_ATR }, <br>{ IDS_DEVTYPE_DDR,         ED_DEVTYPE_DDR }, <br>{ IDS_DEVTYPE_ROUTER,      ED_DEVTYPE_ROUTER }, <br>{ IDS_DEVTYPE_KEYER,       ED_DEVTYPE_KEYER }, <br>{ IDS_DEVTYPE_MIXER_VIDEO, ED_DEVTYPE_MIXER_VIDEO }, <br>{ IDS_DEVTYPE_DVE,         ED_DEVTYPE_DVE }, <br>{ IDS_DEVTYPE_WIPEGEN,     ED_DEVTYPE_WIPEGEN }, <br>{ IDS_DEVTYPE_MIXER_AUDIO, ED_DEVTYPE_MIXER_AUDIO }, <br>{ IDS_DEVTYPE_CG,          ED_DEVTYPE_CG }, <br>{ IDS_DEVTYPE_TBC,         ED_DEVTYPE_TBC }, <br>{ IDS_DEVTYPE_TCG,         ED_DEVTYPE_TCG }, <br>{ IDS_DEVTYPE_GPI,         ED_DEVTYPE_GPI }, <br>{ IDS_DEVTYPE_JOYSTICK,    ED_DEVTYPE_JOYSTICK }, <br>{ IDS_DEVTYPE_KEYBOARD,    ED_DEVTYPE_KEYBOARD}, <br>{ IDS_SYNCACC_PRECISE, ED_SYNCACC_PRECISE}, <br>{ IDS_SYNCACC_FRAME,   ED_SYNCACC_FRAME }, <br>{ IDS_SYNCACC_ROUGH,   ED_SYNCACC_ROUGH }, <br>{ IDS_RATE_24,         ED_RATE_24 }, <br>{ IDS_RATE_25,         ED_RATE_25 }, <br>{ IDS_RATE_2997,       ED_RATE_2997 }, <br>{ IDS_RATE_30,         ED_RATE_30 }, <br>{ IDS_SEEK_PERFECT,    ED_SEEK_PERFECT}, <br>{ IDS_SEEK_FAST,       ED_SEEK_FAST }, <br>{ IDS_SEEK_SLOW,       ED_SEEK_SLOW }, <br>{ IDS_ON,              ED_POWER_ON}, <br>{ IDS_OFF,             ED_POWER_OFF }, <br>{ IDS_STANDBY,         ED_POWER_STANDBY }, <br>{ IDS_ACTIVE,          ED_ACTIVE }, <br>{ IDS_INACTIVE,        ED_INACTIVE}, <br>{ IDS_ALL,             ED_ALL }, <br>{ IDS_TRUE,OATRUE }, <br>{ IDS_FALSE,OAFALSE } <br>}; <br>const int MaxDevValue = sizeof(DevValueTable) / (sizeof(DevValueTable[0][0]) + <br> sizeof(DevValueTable[0][1])); <br> <br>static UINT CBasePropertyPages = 1; <br>static const CLSID *pPropertyPageClsids[] = <br>{ <br>    &amp;CLSID_VCRControlPropertyPage <br>}; <br>static const dwTimeout = 1000L; <br> <br>// * <br>// * CVcrProperties - Properties in IAMExtDevice <br>// * <br> <br>//--------------------------------------------------------- <br>// <br>// CreateInstance <br>// <br>//--------------------------------------------------------- <br>CUnknown *CVcrProperties::CreateInstance( LPUNKNOWN punk, HRESULT *phr ) <br>{ <br>    CVcrProperties *pNewObject <br>        = new CVcrProperties( punk, phr); <br> <br>    if( pNewObject == NULL ) <br>        *phr = E_OUTOFMEMORY; <br> <br>    return pNewObject; <br>} <br>//--------------------------------------------------------- <br>// <br>// CVcrProperties::Constructor <br>// <br>//--------------------------------------------------------- <br>CVcrProperties::CVcrProperties( LPUNKNOWN pUnk, HRESULT *phr) <br>    : CBasePropertyPage(NAME("VCR Property Page"),pUnk, <br>        IDD_DIALOG1, IDS_PROP_GENERAL), <br>m_pExtDevice(NULL), <br>m_pExtTransport(NULL), <br>    m_bIsInitialized(FALSE), <br>m_hwndCapList(NULL), <br>m_hwndCapValue(NULL), <br>m_hwndVidInList(NULL), <br>m_hwndAudInList(NULL), <br>m_hPortButton1(NULL), <br>m_hPortButton2(NULL), <br>m_hPortButton3(NULL), <br>m_hPortButton4(NULL), <br>m_hPortButton5(NULL) <br>{ <br> <br>} <br> <br>//--------------------------------------------------------- <br>// <br>// Message handler <br>// <br>//--------------------------------------------------------- <br>BOOL CVcrProperties::OnReceiveMessage(HWND hwnd, <br>                                        UINT uMsg, <br>                                        WPARAM wParam, <br>                                        LPARAM lParam) <br>{ <br>HRESULT hr; <br>FILTER_STATE fsState; <br> <br>// need a pointer to this object <br>CVcrProperties *pThis = (CVcrProperties *) GetWindowLong(m_Dlg, DWL_USER); <br> <br>    switch (uMsg) <br>    { <br>        case WM_INITDIALOG: <br>        { <br>OnInitDialog(); <br>break; <br>        } <br> <br>        case WM_COMMAND: <br>        { <br>if (m_bIsInitialized) { <br>OnCommand( (int) LOWORD( wParam ), (int) HIWORD( wParam ) ); <br>break; <br>} <br>        } <br>default: <br>if (m_bIsInitialized) { <br>OnCapListNotification(); <br>// test graph state and enable/disable port selection <br>//controls as appropriate <br>hr = m_pFilter-&gt;GetState(dwTimeout, &amp;fsState); <br>if ( fsState != State_Stopped) <br>EnablePortSelection(FALSE); <br>else <br>EnablePortSelection(TRUE); <br>} <br>    } <br>    return CBasePropertyPage::OnReceiveMessage(hwnd,uMsg,wParam,lParam); <br>} <br> <br>//--------------------------------------------------------- <br>// <br>// Property page initialization <br>// <br>//--------------------------------------------------------- <br>HRESULT CVcrProperties::OnConnect(IUnknown *pUnknown) <br>{ <br>// Get the objects on which properties we want to set <br>    ASSERT(m_pExtDevice == NULL); <br> <br>HRESULT hr = pUnknown-&gt;QueryInterface( IID_IAMExtDevice, <br>(void **) &amp;m_pExtDevice ); <br>if( FAILED( hr ) ) <br>    return hr; <br>ASSERT( m_pExtDevice != NULL ); <br>ASSERT(m_pExtTransport == NULL); <br> <br>hr = pUnknown-&gt;QueryInterface( IID_IAMExtTransport, <br>(void **) &amp;m_pExtTransport ); <br>if( FAILED( hr ) ) <br>    return hr; <br>ASSERT( m_pExtTransport != NULL ); <br> <br>hr = pUnknown-&gt;QueryInterface( IID_IBaseFilter, (void **) &amp;m_pFilter ); <br>if( FAILED( hr ) ) <br>    return hr; <br>ASSERT( m_pFilter != NULL ); <br> <br>m_bIsInitialized = FALSE ; <br>    return NOERROR; <br>} <br>//--------------------------------------------------------- <br>// <br>// Property page shutdown <br>// <br>//--------------------------------------------------------- <br>HRESULT CVcrProperties::OnDisconnect() <br>{ <br>    if (m_pExtDevice == NULL) <br>return E_UNEXPECTED; <br>     <br>m_pExtDevice-&gt;Release(); <br>m_pExtDevice = NULL; <br> <br>if (m_pExtTransport == NULL) <br>        return E_UNEXPECTED; <br> <br>m_pExtTransport-&gt;Release(); <br>m_pExtTransport = NULL; <br> <br>if (m_pFilter == NULL) <br>        return E_UNEXPECTED; <br> <br>m_pFilter-&gt;Release(); <br>m_pFilter = NULL; <br>    return NOERROR; <br>} <br>//--------------------------------------------------------- <br>// <br>// Property page activation <br>// <br>//--------------------------------------------------------- <br>HRESULT CVcrProperties::OnActivate() <br>{ <br>    m_bIsInitialized = TRUE; <br>    return NOERROR; <br>} <br>//--------------------------------------------------------- <br>// <br>// The real initialization work is done here <br>// <br>//--------------------------------------------------------- <br>BOOL CVcrProperties::OnInitDialog( void ) <br>{ <br>int i; <br>TCHAR buf[64]; <br>int temp; <br>IPin *pPin; <br>IAMPhysicalPinInfo *pIAMPhys; <br>IEnumPins *pEnumPins; <br>ULONG cFetched; <br>LPOLESTR pName = NULL; <br>PIN_INFO PinInfo; <br>long Type; <br>HRESULT hr; <br>DWORD dwTimeout; <br>FILTER_STATE fsState; <br> <br> <br>    InitCommonControls(); <br>     <br>// get the window and control handles <br>m_hwndCapList = GetDlgItem(m_Dlg, IDC_DEVCAPS); <br>ASSERT(m_hwndCapList); <br>m_hwndCapValue = GetDlgItem(m_Dlg, IDC_DCTEXT); <br>ASSERT(m_hwndCapValue); <br>m_hwndVidInList = GetDlgItem(m_Dlg, IDC_VIDSEL); <br>ASSERT(m_hwndVidInList); <br>m_hwndAudInList = GetDlgItem(m_Dlg, IDC_AUDSEL); <br>ASSERT(m_hwndAudInList); <br>m_hPortButton1 = GetDlgItem(m_Dlg, IDC_COM1); <br>ASSERT(m_hPortButton1); <br>m_hPortButton2 = GetDlgItem(m_Dlg, IDC_COM2); <br>ASSERT(m_hPortButton2); <br>m_hPortButton3 = GetDlgItem(m_Dlg, IDC_COM3); <br>ASSERT(m_hPortButton3); <br>m_hPortButton4 = GetDlgItem(m_Dlg, IDC_COM4); <br>ASSERT(m_hPortButton4); <br>m_hPortButton5 = GetDlgItem(m_Dlg, IDC_COMSIM); <br>ASSERT(m_hPortButton5); <br> <br>// Decide if Device Port selection should be enabled or not <br>dwTimeout = 1000L; <br>hr = m_pFilter-&gt;GetState(dwTimeout, &amp;fsState); <br>if ( fsState != State_Stopped) <br>EnablePortSelection(FALSE); <br>else <br>EnablePortSelection(TRUE); <br> <br>temp = SendMessage(m_hwndCapList, WM_SETREDRAW, TRUE, 0L); <br>// fill the device cap list box <br>for (i = 0; i &lt; MaxDevCaps; i++) { <br>temp = LoadString(g_hInst, DevCapTable[i].StringID, (LPSTR)buf, 64 ); <br>    temp = SendMessage(m_hwndCapList, LB_ADDSTRING, 0, (LPARAM)(LPSTR)buf); <br>    } <br> <br>// put the displayed capability value up <br>m_CurCapSel = SendMessage(m_hwndCapList, LB_GETTOPINDEX, 0, 0L); <br>ShowCapabilityValue(m_CurCapSel, m_hwndCapValue); <br> <br>//put up the device ID <br>m_pExtDevice-&gt;get_ExternalDeviceID( &amp;pName ); <br>temp = SetDlgItemText(m_Dlg, IDC_DCDEVID, (LPCTSTR)pName); <br>QzTaskMemFree(pName); <br>pName = NULL; <br> <br>//put up the device version <br>m_pExtDevice-&gt;get_ExternalDeviceVersion( &amp;pName ); <br>temp = SetDlgItemText(m_Dlg, IDC_DCDV, (LPCTSTR)pName); <br>pName = NULL; <br> <br>// are we linked to the graph's controls or not? <br>m_pExtTransport-&gt;GetStatus(ED_LINK_MODE, &amp;m_bLink); <br> <br>// set power status, comm port radio buttons, etc. <br>UpdateControls(); <br> <br>// do the video input list <br>temp = SendMessage(m_hwndVidInList, WM_SETREDRAW, TRUE, 0L); <br>temp = SendMessage(m_hwndAudInList, WM_SETREDRAW, TRUE, 0L); <br>// use the filter's pin enumeration interface for this <br> <br>m_pFilter-&gt;EnumPins( &amp;pEnumPins ); <br> <br>do {// do 1 pin at a time <br>pEnumPins-&gt;Next( 1, &amp;pPin, &amp;cFetched ); <br>if ( cFetched &gt; 0 ) { <br>// we only deal with input pins here <br>pPin-&gt;QueryPinInfo( &amp;PinInfo ); <br>if ( PinInfo.dir == PINDIR_INPUT ) { <br>// get our IAMPhysicalPinInfo <br>hr = pPin-&gt;QueryInterface( IID_IAMPhysicalPinInfo, <br>(void **) &amp;pIAMPhys ); <br>if( FAILED( hr ) ) <br>return 0; <br>ASSERT( pIAMPhys != NULL ); <br>// is it video pin? <br>pIAMPhys-&gt;GetPhysicalType( &amp;Type, &amp;pName ); <br>if (Type &lt; PhysConn_Audio_Tuner ) <br>// yup - put up the name in the video input list box <br>temp = SendMessage(m_hwndVidInList, LB_ADDSTRING, 0, <br>(LPARAM)(LPSTR)pName); <br>else <br>temp = SendMessage(m_hwndAudInList, LB_ADDSTRING, 0, <br>(LPARAM)(LPSTR)pName); <br>QzTaskMemFree(pName); <br>pName = NULL; <br>} <br>// release the pin whose info we just requested and the <br>// pin we just enumerated <br>QueryPinInfoReleaseFilter(PinInfo); <br>pPin-&gt;Release(); <br>} <br>else// no more pins <br>break; <br>} while (TRUE); <br> <br>// lose the enumerator <br>pEnumPins-&gt;Release(); <br> <br>    return (LRESULT) 1; <br>} <br>//--------------------------------------------------------- <br>// <br>// Handle the property page commands <br>// <br>//--------------------------------------------------------- <br>BOOL CVcrProperties::OnCommand( int iButton, int iNotify ) <br>{ <br>CVcrProperties *pThis = (CVcrProperties *) GetWindowLong(m_Dlg, DWL_USER); <br>    ASSERT(pThis); <br>    switch( iButton ){ <br>case IDC_COM1: <br>pThis-&gt;m_CurDevPort = DEV_PORT_COM1; <br>break; <br>case IDC_COM2: <br>pThis-&gt;m_CurDevPort = DEV_PORT_COM2; <br>break; <br>case IDC_COM3: <br>pThis-&gt;m_CurDevPort = DEV_PORT_COM3; <br>break; <br>case IDC_COM4: <br>pThis-&gt;m_CurDevPort = DEV_PORT_COM4; <br>break; <br>case IDC_COMSIM: <br>pThis-&gt;m_CurDevPort = DEV_PORT_SIM; <br>break; <br>case IDC_DCPWR_ON: <br>pThis-&gt;m_CurPowerMode = ED_POWER_ON; <br>break; <br>case IDC_DCPWR_OFF: <br>pThis-&gt;m_CurPowerMode = ED_POWER_OFF; <br>break; <br>case IDC_DCPWR_STBY: <br>pThis-&gt;m_CurPowerMode = ED_POWER_STANDBY; <br>break; <br>case IDC_LINK: <br>if (IsDlgButtonChecked(m_Dlg, IDC_LINK)) <br>pThis-&gt;m_bLink = OATRUE; <br>else <br>pThis-&gt;m_bLink = OAFALSE; <br>break; <br>} <br> <br>    SetDirty(); <br>    return (LRESULT) 1; <br>} <br>//--------------------------------------------------------- <br>// <br>//Apply user-requested changes <br>// <br>//--------------------------------------------------------- <br>HRESULT CVcrProperties::OnApplyChanges() <br>{ <br>if (m_bDevPortEnabled) <br>m_pExtDevice-&gt;put_DevicePort(m_CurDevPort); <br>m_pExtDevice-&gt;put_DevicePower(m_CurPowerMode); <br>m_pExtTransport-&gt;SetTransportVideoParameters(ED_TRANSVIDEO_SET_SOURCE, <br>m_CurVidInSel); <br>    m_pExtTransport-&gt;SetTransportAudioParameters(ED_TRANSAUDIO_SET_SOURCE, <br>m_CurAudInSel); <br>UpdateControls(); <br>return(NOERROR); <br> <br>} <br>//--------------------------------------------------------- <br>//  <br>// <br>// Sets m_bDirty and notifies the property page site of the change <br>// <br>//--------------------------------------------------------- <br>void CVcrProperties::SetDirty() <br>{ <br>    m_bDirty = TRUE; <br>    if (m_pPageSite) <br>        m_pPageSite-&gt;OnStatusChange(PROPPAGESTATUS_DIRTY); <br>} <br> <br>//--------------------------------------------------------- <br>// <br>// UpdateControls - sets non-listbox controls to current values <br>// <br>//--------------------------------------------------------- <br>void CVcrProperties::UpdateControls() <br>{ <br>int temp; <br>LPOLESTR pName = NULL; <br> <br>m_pExtDevice-&gt;get_DevicePower(&amp;m_CurPowerMode); <br>switch (m_CurPowerMode) { <br>case ED_POWER_ON: <br>temp = IDC_DCPWR_ON; <br>break; <br>case ED_POWER_OFF: <br>temp = IDC_DCPWR_OFF; <br>break; <br>case ED_POWER_STANDBY: <br>temp = IDC_DCPWR_STBY; <br>break; <br>}; <br>CheckRadioButton(m_Dlg, IDC_DCPWR_ON, IDC_DCPWR_STBY, temp); <br>m_pExtDevice-&gt;get_DevicePort(&amp;m_CurDevPort);  <br>switch (m_CurDevPort) { <br>case DEV_PORT_COM1: <br>temp = IDC_COM1; <br>break; <br>case DEV_PORT_COM2: <br>temp = IDC_COM2; <br>break; <br>case DEV_PORT_COM3: <br>temp = IDC_COM3; <br>break; <br>case DEV_PORT_COM4: <br>temp = IDC_COM4; <br>break; <br>case DEV_PORT_SIM: <br>temp = IDC_COMSIM; <br>break; <br>default: <br>// can add support for ARTI or VLAN here <br>temp = NULL; <br>} <br>CheckRadioButton(m_Dlg, IDC_COM1, IDC_COMSIM, temp); <br> <br>if (m_bLink == OATRUE) { <br>m_pExtTransport-&gt;put_Mode(ED_MODE_LINK_ON); <br>CheckDlgButton(m_Dlg, IDC_LINK, TRUE); <br>} <br>else { <br>m_pExtTransport-&gt;put_Mode(ED_MODE_LINK_OFF); <br>CheckDlgButton(m_Dlg, IDC_LINK, FALSE); <br>} <br> <br>//put up the device ID <br>m_pExtDevice-&gt;get_ExternalDeviceID( &amp;pName ); <br>temp = SetDlgItemText(m_Dlg, IDC_DCDEVID, (LPCTSTR)pName); <br>QzTaskMemFree(pName); <br>pName = NULL; <br> <br>} <br>//--------------------------------------------------------- <br>// <br>// OnCapListNotification <br>// <br>// Handle the notification messages from the Capabilities control <br>// <br>//--------------------------------------------------------- <br>void CVcrProperties::OnCapListNotification() <br>{ <br>long temp; <br>// fake-out because can't get scroll messages from listbox <br>// update the value control if the selection changed <br>temp = SendMessage(m_hwndCapList, LB_GETTOPINDEX, 0, 0L); <br>if ( temp != m_CurCapSel ) { <br>m_CurCapSel = temp; <br>ShowCapabilityValue(m_CurCapSel, m_hwndCapValue); <br>} <br>} <br>//--------------------------------------------------------- <br>// <br>// FindStringID - given a Capability Value that is known to be a  <br>//string, pluck the StringID from the local table <br>// <br>//--------------------------------------------------------- <br>intCVcrProperties::FindStringID(long Value) <br>{ <br>int i; <br> <br>for (i = 0; i &lt;MaxDevValue; i++) { <br>if ( DevValueTable[i][1] == Value ) <br>return DevValueTable[i][0];// found it <br>} <br>return -1; <br>} <br>//--------------------------------------------------------- <br>// <br>// ShowCapabilityValue - uses index into DevCapTable to put this up <br>// <br>//--------------------------------------------------------- <br>void CVcrProperties::ShowCapabilityValue(int index, HWND hwndValue) <br>{ <br>long Value; <br>double dblValue; <br>int temp; <br>int StringID; <br>TCHAR buf[64]; <br> <br>m_pExtDevice-&gt;GetCapability(DevCapTable[index].DevCap, &amp;Value, &amp;dblValue); <br>// figure out how to display it <br>if ( DevCapTable[index].ValueType == ED_STR ) { <br>StringID = FindStringID(Value); <br>temp = LoadString(g_hInst, StringID, (LPSTR)buf, 64 ); <br>} <br>else // it's a number <br>_ultoa( (unsigned long) Value, (LPSTR)buf, 10 ); <br>// put it up <br>temp = SetWindowText( hwndValue,(LPSTR)buf); <br>} <br>//--------------------------------------------------------- <br>// <br>// EnablePortSelection - enables/disables the radio buttons to <br>//keep the machine from blowing up <br>// <br>//--------------------------------------------------------- <br>void CVcrProperties::EnablePortSelection(BOOL bEnable) <br>{ <br>if (bEnable) { <br>EnableWindow(m_hPortButton1, TRUE); <br>EnableWindow(m_hPortButton2, TRUE); <br>EnableWindow(m_hPortButton3, TRUE); <br>EnableWindow(m_hPortButton4, TRUE); <br>EnableWindow(m_hPortButton5, TRUE); <br>m_bDevPortEnabled = TRUE; <br>} <br>else { <br>EnableWindow(m_hPortButton1, FALSE); <br>EnableWindow(m_hPortButton2, FALSE); <br>EnableWindow(m_hPortButton3, FALSE); <br>EnableWindow(m_hPortButton4, FALSE); <br>EnableWindow(m_hPortButton5, FALSE); <br>m_bDevPortEnabled = FALSE; <br>} <br>} <br>// eof vcrprop.cpp </code></pre>
<p>&nbsp;</p></body>
</HTML>
