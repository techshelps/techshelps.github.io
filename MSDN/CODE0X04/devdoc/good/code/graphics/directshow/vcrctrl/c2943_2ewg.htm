<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FVCRCTRL.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2950"></a>FVCRCTRL.H</h2>
<pre><code>//=========================================================================== <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>// PURPOSE. <br>// <br>// Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//=========================================================================== <br>// <br>// filename: fvcrctrl.h  <br>// <br>// VCR Control filter - CBaseFilter Derived <br>// <br>// This is a prototype "VCR" filter.  Depending on the detected VCR,  <br>// It has 5 or 6 pins - 2 or 3 Video inputs, 2 Audio inputs <br>// and one Timecode outout (a timecode input pin would be useless). <br>// It's a bit different than the standard source, transform, <br>// and rendering filters because it has both input and output <br>// pins with fairly unrelated behaviors. <br>// <br>// It implements the following External Device interfaces: <br>// <br>//IAMExtDevice <br>//IAMPhysicalPinInfo <br>//IAMExtTransport <br>//IAMTimecodeReader <br>// <br>// The filter also has a couple of property pages that put a simple <br>// user interface on many of the methods and properties of <br>// the supported interfaces. <br> <br>class COutStream;// The class that will handle the timecode output pin <br>//*************************************************/ <br>// CVcrFilter <br>// <br>class CVcrFilter : public CBaseFilter, public CAMExtDevice, <br> public CAMExtTransport, public CAMTcr, public CPersistStream, <br> public ISpecifyPropertyPages  <br>{ <br>friend class COutStream;// so they can lock <br>friend class CVcrTCOut; <br>public: <br> <br>    static CUnknown *CreateInstance(LPUNKNOWN punk, HRESULT *phr); <br> <br>// we replace the DECLARE_IUNKNOWN macro so we can resolve <br>// ambiguous references due to multiple CUnknowns <br>STDMETHODIMP QueryInterface(REFIID riid, void **ppv) { <br>        return CBaseFilter::GetOwner()-&gt;QueryInterface(riid,ppv);       <br>    };                                                    <br>    STDMETHODIMP_(ULONG) AddRef() {                       <br>        return CBaseFilter::GetOwner()-&gt;AddRef();                      <br>    };                                                    <br>    STDMETHODIMP_(ULONG) Release() {                      <br>        return CBaseFilter::GetOwner()-&gt;Release();                     <br>    }; <br>HINSTANCELoadOLEAut32(); <br> <br>    // <br>    // --- CBaseFilter Overrides -- <br>    // <br> <br>    int GetPinCount(); <br>    CBasePin * GetPin(int n); <br> <br>// CPersistStream overrides <br>    HRESULT WriteToStream(IStream *pStream); <br>    HRESULT ReadFromStream(IStream *pStream); <br>    int SizeMax(); <br>    STDMETHODIMP GetClassID(CLSID *pClsid); <br> <br>// Utilities <br>HRESULT     AddPin(CBasePin *); <br>    HRESULT     RemovePin(CBasePin *); <br>CCritSec*pLock(void) { return &amp;m_StateLock; }// provide our  <br>//  critical section <br> <br>// override state changes to allow derived Device Control filter <br>    // to control its own start/stop <br>    STDMETHODIMP Stop(); <br>    STDMETHODIMP Pause(); <br>    STDMETHODIMP Run(REFERENCE_TIME tStart); <br> <br>// Basic COM - used here to reveal our property interface. <br>    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv); <br> <br>// --- ISpecifyPropertyPages --- <br>// return our property pages <br>    STDMETHODIMP GetPages(CAUUID * pPages); <br>     <br>private: <br> <br>    CVcrFilter(TCHAR *tszName, LPUNKNOWN punk, CLSID clsid, HRESULT *phr); <br>~CVcrFilter(); <br> <br>int m_iPins;// The number of pins on this filter.  <br>//  Updated by COutStream and CVcrInputPin  <br>//  constructors &amp; destructors. <br>protected: <br> <br>    CBasePin **m_paStreams;// the pins on this filter. <br>CCritSec m_StateLock;// Lock this to serialize function accesses  <br>//  to the filter state <br>}; <br> <br>//*************************************************/ <br>// COutStream <br>// <br>// Use this class to manage a stream of data that comes <br>// from a derived pin. <br>// Uses a worker thread to put data on the pin. <br>// <br>class COutStream : public CAMThread, public CBaseOutputPin <br>{ <br>public: <br> <br>    COutStream(TCHAR *pObjectName, <br>                  HRESULT *phr, <br>                  CVcrFilter *pParent, <br>                  LPCWSTR pName); <br> <br>    virtual ~COutStream(void);  // virtual destructor ensures derived class  <br>//  destructors are called too. <br> <br>// thread commands <br>    virtual enum Command {CMD_INIT, CMD_PAUSE, CMD_RUN, CMD_STOP, CMD_EXIT}; <br>    HRESULT Init(void) { return CallWorker(CMD_INIT); } <br>    HRESULT Exit(void) { return CallWorker(CMD_EXIT); } <br>    HRESULT Run(void) { return CallWorker(CMD_RUN); } <br>    HRESULT Pause(void) { return CallWorker(CMD_PAUSE); } <br>    HRESULT Stop(void) { return CallWorker(CMD_STOP); } <br> <br>protected: <br> <br>    CVcrFilter *m_pFilter;// The parent of this stream <br>HANDLE m_hAdviseEvent;// for an advise event <br>IReferenceClock *m_pRefClock;// this graph's sync source <br> <br>    // * <br>    // * Data Source <br>    // * <br>    // * The following three functions: FillBuffer, OnThreadCreate/Destroy, are <br>    // * called from within the ThreadProc. They are used in the creation of <br>    // * the media samples this pin will provide <br>    // * <br> <br>    // Override this to provide the worker thread a means <br>    // of processing a buffer <br>    virtual HRESULT FillBuffer(IMediaSample *pSamp) PURE; <br> <br>    // Called as the thread is created/destroyed - use to perform <br>    // jobs such as start/stop streaming mode <br>    // If OnThreadCreate returns an error the thread will exit. <br>    virtual HRESULT OnThreadCreate(void) {return NOERROR;}; <br>    virtual HRESULT OnThreadDestroy(void) {return NOERROR;}; <br>    virtual HRESULT OnThreadStartPlay(void) {return NOERROR;}; <br> <br>    // * <br>    // * Worker Thread <br>    // * <br> <br>    HRESULT Active(void);    // Starts up the worker thread <br>    HRESULT Inactive(void);  // Exits the worker thread. <br> <br>    Command GetRequest(void) { return (Command) CAMThread::GetRequest(); } <br>    BOOL    CheckRequest(Command *pCom) { <br>return CAMThread::CheckRequest( (DWORD *) pCom); } <br> <br>    // override these if you want to add thread commands  <br>// (and the T/C stream will) <br>    virtual DWORD ThreadProc(void);  // the thread function <br>    virtual HRESULT DoBufferProcessingLoop(void);   // the loop executed  <br>//  whilst running <br> <br> <br>    // * <br>    // * MEDIA_TYPE support <br>    // * <br> <br>    // Override this - we support multiple media types <br>    virtual HRESULT CheckMediaType( const CMediaType *pMediaType) PURE; <br>}; <br> <br>//*************************************************/ <br>// CVcrTCOut <br>// <br>// This filter has an output pin which can output timecode samples <br>// as either a binary sample or as displayable text. <br>// <br>class CVcrTCOut : public COutStream <br>{ <br>private: <br> <br>CVcrFilter *m_pFilter;// the external device filter that owns us <br>    CCritSec    m_cSharedState;     // use this to lock access to  <br>//  m_rtSampleTime and m_pFilter which are  <br>//  shared with the worker thread. <br>    CRefTime    m_rtSampleTime;// The time to be stamped on each sample <br>CTimecode*m_ctc;// need this for data conversions <br>static LONGLONG m_llLastTime;// the last time timecode was updated <br>int m_mtype;// 0 for text, 1 for Aux Data <br> <br>public: <br> <br>CVcrTCOut( <br>HRESULT *phr, <br>CVcrFilter *pParent, <br>LPCWSTR pPinName); <br> <br>~CVcrTCOut(); <br> <br>BOOL ReadyToStop(void) {return FALSE;} <br> <br>    // stuff a text buffer with the current format <br>    HRESULT FillBuffer(IMediaSample *pms); <br> <br>    // ask for buffers of the size appropriate to the agreed media type. <br>    HRESULT DecideBufferSize(IMemAllocator *pIMemAlloc, <br>ALLOCATOR_PROPERTIES *pRequest); <br> <br>    // verify we can handle this format <br>    HRESULT CheckMediaType(const CMediaType *pMediaType); <br> <br>// we handle multiple media types <br>    HRESULT GetMediaType(int iPosition, CMediaType *pmt); <br> <br>    // resets the stream time to zero. <br>    HRESULT OnThreadCreate(void); <br>}; <br>//*************************************************/ <br>// <br>//Base Hardware Input Pin Class <br>// <br>// It might be desirable to add hardware output pins in a similar manner <br>// as the following input pins if, for example, an external device <br>// has switchable outputs. <br>//  <br>class CVcrInputPin : public CBaseInputPin, public CAMPhysicalPinInfo <br>{ <br>public: <br>    CVcrInputPin( <br>        TCHAR *pObjectName, <br>        CVcrFilter *pFilter, <br>    HRESULT * phr, <br>        LPCWSTR pName); <br> <br>    virtual ~CVcrInputPin(); <br> <br>    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** pv); <br> <br>    // we aren't supposed to connect to anybody <br>    HRESULT CheckMediaType(const CMediaType*) { <br>return E_FAIL; <br>    } <br>     <br>// CAMPhysicalPinInfo's method - the derived input pins must implement <br>STDMETHODIMP GetPhysicalType(long *pType, LPOLESTR * ppszType){ <br>return E_NOTIMPL;} <br> <br>private: <br>    CVcrFilter * m_pFilter;// parent <br>CCritSec m_StateLock;// Lock this to serialize function accesses <br>}; <br> <br>//*************************************************/ <br>// <br>//1st of 4 (or 5) input pins <br>// <br>class CVcrVideoCompInputPin : public CVcrInputPin <br>{ <br>public: <br>    CVcrVideoCompInputPin( <br>        TCHAR *pObjectName, <br>        CVcrFilter *pFilter, <br>    HRESULT * phr, <br>        LPCWSTR pName); <br> <br>    virtual ~CVcrVideoCompInputPin(); <br>       <br>// CAMPhysicalPinInfo's method - we must return our physical pin info <br>STDMETHODIMP GetPhysicalType(long *pType, LPOLESTR * ppszType); <br>}; <br> <br>//*************************************************/ <br>// <br>//2nd of 4 (or 5) input pins <br>// <br>class CVcrVideoSInputPin : public CVcrInputPin <br>{ <br>public: <br>    CVcrVideoSInputPin( <br>        TCHAR *pObjectName, <br>        CVcrFilter *pFilter, <br>    HRESULT * phr, <br>        LPCWSTR pName); <br> <br>    virtual ~CVcrVideoSInputPin(); <br>       <br>// CAMPhysicalPinInfo's method - we must return our physical pin info <br>STDMETHODIMP GetPhysicalType(long *pType, LPOLESTR * ppszType); <br>}; <br> <br>//*************************************************/ <br>// <br>//3rd of 4 (or 5) input pins <br>// <br>class CVcrAudioLineInputPin : public CVcrInputPin <br>{ <br>public: <br>    CVcrAudioLineInputPin( <br>        TCHAR *pObjectName, <br>        CVcrFilter *pFilter, <br>    HRESULT * phr, <br>        LPCWSTR pName); <br> <br>    virtual ~CVcrAudioLineInputPin(); <br>       <br>// CAMPhysicalPinInfo's method - we must return our physical pin info <br>STDMETHODIMP GetPhysicalType(long *pType, LPOLESTR * ppszType); <br>}; <br> <br>//*************************************************/ <br>// <br>//4th of 4 (or 5) input pins <br>// <br>class CVcrAudioMicInputPin : public CVcrInputPin <br>{ <br>public: <br>    CVcrAudioMicInputPin( <br>        TCHAR *pObjectName, <br>        CVcrFilter *pFilter, <br>    HRESULT * phr, <br>        LPCWSTR pName); <br> <br>    virtual ~CVcrAudioMicInputPin(); <br>       <br>// CAMPhysicalPinInfo's method - we must return our physical pin info <br>STDMETHODIMP GetPhysicalType(long *pType, LPOLESTR * ppszType); <br>}; <br> <br>//*************************************************/ <br>// <br>//Optional 5th input pin <br>// <br>class CVcrVideoBlackInputPin : public CVcrInputPin <br>{ <br>public: <br>    CVcrVideoBlackInputPin( <br>        TCHAR *pObjectName, <br>        CVcrFilter *pFilter, <br>    HRESULT * phr, <br>        LPCWSTR pName); <br> <br>    virtual ~CVcrVideoBlackInputPin(); <br>       <br>// CAMPhysicalPinInfo's method - we must return our physical pin info <br>STDMETHODIMP GetPhysicalType(long *pType, LPOLESTR * ppszType); <br>}; <br> <br>// eof fvcrctrl.h </code></pre>
<p>&nbsp;</p></body>
</HTML>
