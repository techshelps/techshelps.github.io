<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CVCRUTIL.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2947"></a>CVCRUTIL.CPP</h2>
<pre><code>//=========================================================================== <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>// PURPOSE. <br>// <br>// Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//=========================================================================== <br>// <br>//filename: cvcrutil.cpp <br>// <br>// Base classes implementing external device control (VCR) interfaces. <br>// Derive from these and implement just the custom method and property <br>// methods. <br>// <br> <br>#include &lt;windows.h&gt; <br>#include &lt;streams.h&gt; <br>#include &lt;limits.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdarg.h&gt; <br>#include &lt;vfw.h&gt; <br> <br>#include "vcruids.h" <br>#include &lt;initguid.h&gt; <br>#include &lt;olectl.h&gt; <br> <br>#include "ctimecod.h" <br>#include "cdevcom.h" <br>#include "cvcrutil.h" <br> <br>#define DbgFunc(a) DbgLog(( LOG_TRACE, \ <br>                            2, \ <br>                            TEXT("VCRTC::%16hu"), \ <br>                            TEXT(a) \ <br>                         )); <br> <br>const long ExtVidConnType[] = { <br>PhysConn_Video_Tuner, <br>PhysConn_Video_Composite, <br>PhysConn_Video_SVideo, <br>PhysConn_Video_RGB, <br>PhysConn_Video_YRYBY, <br>PhysConn_Video_SerialDigital, <br>PhysConn_Video_ParallelDigital, <br>PhysConn_Video_SCSI, <br>PhysConn_Video_AUX, <br>PhysConn_Video_1394, <br>PhysConn_Video_USB <br>}; <br>const int ExtVidConnCnt = sizeof(ExtVidConnType); <br> <br>const TCHAR *strExtVidConnType[] = { <br>TEXT("Tuner"), <br>TEXT("Composite"), <br>TEXT("S-Video"), <br>TEXT("RGB"), <br>TEXT("Y//R-Y//B-Y"), <br>TEXT("Serial Digital"), <br>TEXT("Parallel Digital"), <br>TEXT("SCSI"), <br>TEXT("AUX"), <br>TEXT("1394"), <br>TEXT("USB") <br>}; <br> <br>const long ExtAudConnType[] = { <br>PhysConn_Audio_Tuner, <br>PhysConn_Audio_Line, <br>PhysConn_Audio_Mic, <br>PhysConn_Audio_AESDigital, <br>PhysConn_Audio_SPDIFDigital, <br>PhysConn_Audio_SCSI, <br>PhysConn_Audio_AUX, <br>PhysConn_Audio_1394, <br>PhysConn_Audio_USB <br>}; <br>const int ExtAudConnCnt = sizeof(ExtAudConnType); <br> <br>const TCHAR *strExtAudConnType[] = { <br>TEXT("Tuner"), <br>TEXT("Line"), <br>TEXT("Mic"), <br>TEXT("AES Digital"), <br>TEXT("SPDIF Digital"), <br>TEXT("SCSI"), <br>TEXT("AUX"), <br>TEXT("1394"), <br>TEXT("USB") <br>}; <br>static TCHAR buf[32]; <br>static TCHAR buf1[32]; <br>const TCHAR strDummyDeviceVersion[] = TEXT("1.0"); <br> <br>//------------------------------------------ <br>// <br>//CAMPhysicalPinInfo Implementation <br>// <br>//------------------------------------------ <br>CAMPhysicalPinInfo::CAMPhysicalPinInfo(HRESULT * phr, TCHAR *tszName) : <br>CUnknown( tszName, NULL ) <br>{ <br> <br>} <br> <br>//------------------------------------------ <br>// <br>//Destructor <br>// <br>//------------------------------------------ <br>CAMPhysicalPinInfo::~CAMPhysicalPinInfo() <br>{ <br>  <br>} <br> <br>//------------------------------------------ <br>// <br>// NonDelegatingQueryInterface <br>// <br>// Reveal our Interface <br>//------------------------------------------ <br>STDMETHODIMP <br>CAMPhysicalPinInfo::NonDelegatingQueryInterface(REFIID riid, void **ppv) { <br> <br>CAutoLock cObjectLock(&amp;m_StateLock); <br> <br>    if (riid == IID_IAMPhysicalPinInfo) <br>        return GetInterface((IAMPhysicalPinInfo *) this, ppv); <br>    else <br>        return CUnknown::NonDelegatingQueryInterface(riid, ppv); <br>}  <br> <br>//------------------------------------------ <br>// <br>// CAMExtDevice implementation <br>// <br>//------------------------------------------ <br>CAMExtDevice::CAMExtDevice(HRESULT * phr, TCHAR *tszName) : <br>CUnknown( tszName, NULL ), <br>m_CurDevicePort(NULL) <br>{ <br>HRESULT Result; <br>// must have a way to talk to a machine <br>m_devcom = new CDevCom((CBaseFilter *)this, &amp;Result); <br>    if (m_devcom == NULL || Result) { <br>        *phr = E_OUTOFMEMORY; <br>        return; <br>} <br> <br>// initialize the capabilities structures - we default to a test VCR, <br>// in this case a simple SVHS recorder such as the SVO-5800 (RS-422) <br>// or other machine with an SVBK-10 RS-232 interface <br>m_DevCaps.CanRecord = OATRUE; <br>m_DevCaps.CanRecordStrobe = OAFALSE; <br>m_DevCaps.HasAudio = OATRUE; <br>m_DevCaps.HasVideo = OATRUE;           <br>m_DevCaps.UsesFiles = OAFALSE;          <br>m_DevCaps.CanSave = OAFALSE;            <br>m_DevCaps.DeviceType = ED_DEVTYPE_VCR;         <br>m_DevCaps.TCRead = OATRUE;             <br>m_DevCaps.TCWrite = OAFALSE;            <br>m_DevCaps.CTLRead = OATRUE;            <br>m_DevCaps.IndexRead = OAFALSE;          <br>m_DevCaps.Preroll = 150L;            <br>m_DevCaps.Postroll = 30L;;           <br>m_DevCaps.SyncAcc = ED_SYNCACC_PRECISE;            <br>m_DevCaps.NormRate = ED_RATE_2997;           <br>m_DevCaps.CanPreview = OATRUE;         <br>m_DevCaps.CanMonitorSrc = OATRUE;     <br>m_DevCaps.CanTest = OATRUE;            <br>m_DevCaps.VideoIn = OATRUE;            <br>m_DevCaps.AudioIn = OATRUE;            <br>m_DevCaps.Calibrate = OAFALSE; <br>m_DevCaps.SeekType = ED_SEEK_SLOW;           <br> <br>// default comm port and power state <br>put_DevicePort(DEV_PORT_COM2); <br>put_DevicePower(ED_POWER_ON); <br>} <br> <br>//------------------------------------------ <br>// <br>//Destructor <br>// <br>//------------------------------------------ <br>CAMExtDevice::~CAMExtDevice() <br>{ <br> m_devcom-&gt;CloseDevPort(); <br>} <br> <br>//------------------------------------------ <br>// <br>// NonDelegatingQueryInterface <br>// <br>// Reveal our Interface <br>//------------------------------------------ <br>STDMETHODIMP <br>CAMExtDevice::NonDelegatingQueryInterface(REFIID riid, void **ppv) <br>{ <br>CAutoLock cObjectLock(&amp;m_StateLock); <br> <br>    if (riid == IID_IAMExtDevice) <br>        return GetInterface((IAMExtDevice *) this, ppv); <br>    else <br>        return CUnknown::NonDelegatingQueryInterface(riid, ppv); <br>}  <br> <br>//------------------------------------------ <br>// <br>//GetCapability <br>// <br>// General device capabilities property <br>//------------------------------------------ <br>HRESULT  <br>CAMExtDevice::GetCapability(long Capability, long *pValue, double *pdblValue ) <br>{ <br>HRESULT result = S_OK; <br> <br>switch (Capability){ <br>  <br>case ED_DEVCAP_CAN_RECORD: <br>*pValue = m_DevCaps.CanRecord; <br>break; <br>case ED_DEVCAP_CAN_RECORD_STROBE: <br>*pValue = m_DevCaps.CanRecordStrobe; <br>break; <br>case ED_DEVCAP_HAS_AUDIO: <br>*pValue = m_DevCaps.HasAudio; <br>break; <br>case ED_DEVCAP_HAS_VIDEO: <br>*pValue = m_DevCaps.HasVideo; <br>break; <br>case ED_DEVCAP_USES_FILES: <br>*pValue = m_DevCaps.UsesFiles; <br>break; <br>case ED_DEVCAP_CAN_SAVE: <br>*pValue = m_DevCaps.CanSave; <br>break; <br>case ED_DEVCAP_DEVICE_TYPE: <br>*pValue = m_DevCaps.DeviceType; <br>break; <br>case ED_DEVCAP_TIMECODE_READ: <br>*pValue = m_DevCaps.TCRead; <br>break; <br>case ED_DEVCAP_TIMECODE_WRITE: <br>*pValue = m_DevCaps.TCWrite; <br>break; <br>case ED_DEVCAP_CTLTRK_READ:  <br>*pValue = m_DevCaps.CTLRead; <br>break; <br>case ED_DEVCAP_INDEX_READ: <br>*pValue = m_DevCaps.IndexRead; <br>break; <br>case ED_DEVCAP_PREROLL:  <br>*pValue = m_DevCaps.Preroll; <br>break; <br>case ED_DEVCAP_POSTROLL:  <br>*pValue = m_DevCaps.Postroll; <br>break; <br>case ED_DEVCAP_SYNC_ACCURACY:  <br>*pValue = m_DevCaps.SyncAcc; <br>break; <br>case ED_DEVCAP_NORMAL_RATE: <br>*pValue = m_DevCaps.NormRate; <br>break; <br>case ED_DEVCAP_CAN_PREVIEW:  <br>*pValue = m_DevCaps.CanPreview; <br>break; <br>case ED_DEVCAP_CAN_MONITOR_SOURCES:  <br>*pValue = m_DevCaps.CanMonitorSrc; <br>break; <br>case ED_DEVCAP_CAN_TEST: <br>*pValue = m_DevCaps.CanTest; <br>break; <br>case ED_DEVCAP_VIDEO_INPUTS:  <br>*pValue = m_DevCaps.VideoIn; <br>break; <br>case ED_DEVCAP_AUDIO_INPUTS:  <br>*pValue = m_DevCaps.AudioIn; <br>break; <br>case ED_DEVCAP_NEEDS_CALIBRATING: <br>*pValue = m_DevCaps.Calibrate; <br>break; <br>case ED_DEVCAP_SEEK_TYPE: <br>*pValue = m_DevCaps.SeekType; <br>break; <br>default: <br>result = VFW_E_NOT_FOUND; <br>}                            <br>return S_OK; <br>}         <br> <br>//------------------------------------------ <br>// <br>//get_ExternalDeviceID <br>// <br>// Get external device identification string <br>//------------------------------------------ <br>HRESULT <br>CAMExtDevice::get_ExternalDeviceID(LPOLESTR * ppszData) <br>{ <br>int Cookie; <br> <br>CheckPointer(ppszData, E_POINTER); <br>*ppszData = NULL; <br>// query the device <br>if (m_devcom-&gt;SendDevCmd(DEVICE_TYPE_REQUEST, &amp;Cookie) ) <br>return E_FAIL; <br>if (m_devcom-&gt;Wait4DevResponse(buf, Cookie)) <br>return E_FAIL; <br>m_devcom-&gt;ProcessDeviceTypeResponse(buf, buf1); <br>if (buf1 !=NULL) { <br>*ppszData = (LPOLESTR) <br>QzTaskMemAlloc(sizeof(WCHAR) * (1+lstrlenW((LPOLESTR)buf1))); <br>if (*ppszData !=NULL) <br>lstrcpyW(*ppszData, (LPOLESTR)buf1); <br>} <br>return S_OK; <br>} <br> <br>//------------------------------------------ <br>// <br>//get_ExternalDeviceVersion <br>// <br>//------------------------------------------ <br>HRESULT <br>CAMExtDevice::get_ExternalDeviceVersion(LPOLESTR * ppszData) <br>{ <br>// The sample machine doesn't support this, so send <br>// a dummy response <br>CheckPointer(ppszData, E_POINTER); <br>*ppszData = NULL; <br>// query the device <br>*ppszData = (LPOLESTR) <br>QzTaskMemAlloc(sizeof(WCHAR) * \ <br>(1+lstrlenW((LPOLESTR)strDummyDeviceVersion))); <br>if (*ppszData !=NULL) <br>lstrcpyW(*ppszData, (LPOLESTR)strDummyDeviceVersion); <br> <br>return S_OK; <br>} <br> <br>//------------------------------------------ <br>// <br>//put_DevicePower <br>// <br>// Controls the external device's power mode. <br>// Unfortunately, the sample machine doesn't support this <br>//------------------------------------------ <br>HRESULT <br>CAMExtDevice::put_DevicePower(long PowerMode) <br>{ <br>TESTFLAG(PowerMode, OAFALSE); <br>return E_NOTIMPL; <br>} <br> <br>//------------------------------------------ <br>// <br>//get_DevicePower <br>// <br>//------------------------------------------ <br>HRESULT  <br>CAMExtDevice::get_DevicePower(long *pPowerMode) <br>{ <br>// if the device port is being simulated, assume power off <br>if (m_CurDevicePort == DEV_PORT_SIM) <br>m_PowerMode = ED_POWER_OFF; <br>else <br>m_PowerMode = ED_POWER_ON; <br>*pPowerMode = m_PowerMode; <br>return S_OK; <br>} <br> <br>//------------------------------------------ <br>// <br>//Calibrate <br>// <br>//------------------------------------------ <br>HRESULT <br>CAMExtDevice::Calibrate(HEVENT hEvent, long Mode, long *pStatus) <br>{ <br>TESTFLAG( Mode , OAFALSE); <br>return E_NOTIMPL; <br>} <br> <br>//------------------------------------------ <br>// <br>//get_DevicePort <br>// <br>//------------------------------------------ <br>HRESULT <br>CAMExtDevice::get_DevicePort(long *pDevicePort) <br>{ <br>*pDevicePort = m_CurDevicePort; <br>return S_OK; <br>} <br> <br>//------------------------------------------ <br>// <br>//put_DevicePort <br>// <br>//------------------------------------------ <br>HRESULT <br>CAMExtDevice::put_DevicePort(long DevicePort) <br>{ <br>TESTFLAG( DevicePort, OATRUE); <br> <br>if ( DevicePort != m_CurDevicePort ) { <br>// range check <br>if ((DevicePort &lt; DEV_PORT_MIN) || <br>(DevicePort &gt; DEV_PORT_MAX)) <br>return VFW_E_NOT_FOUND;// find correct error code <br>if ( (m_CurDevicePort != NULL) &amp; (m_CurDevicePort !=DEV_PORT_SIM) ) <br>m_devcom-&gt;CloseDevPort(); <br>if (m_devcom-&gt;OpenDevPort(DevicePort)) <br>m_CurDevicePort = DEV_PORT_SIM; <br>else <br>m_CurDevicePort = DevicePort; <br>} <br>return S_OK; <br>} <br> <br>//------------------------------------------ <br>// <br>// CAMExtTransport implementation <br>// <br>//------------------------------------------ <br>CAMExtTransport::CAMExtTransport(HRESULT * phr, TCHAR *tszName) : <br>CUnknown( tszName, NULL ) <br>{ <br>// initialize the video parms <br>m_TranVidParms.OutputMode = ED_PLAYBACK; <br>m_TranVidParms.Input = 0;// use the first (zeroth) input as the default <br> <br>m_TranAudParms.EnableOutput = ED_AUDIO_ALL; <br>m_TranAudParms.EnableRecord = 0L; <br>m_TranAudParms.Input = 0; <br>m_TranAudParms.MonitorSource = 0; <br> <br>m_TranStatus.Mode = ED_MODE_STOP; <br>m_TranStatus.LastError = 0L; <br>m_TranStatus.RecordInhibit = OAFALSE; <br>m_TranStatus.ServoLock = OAFALSE; <br>m_TranStatus.MediaPresent = OAFALSE; <br>m_TranStatus.MediaLength =  <br>m_TranStatus.MediaSize =  <br>m_TranStatus.MediaTrackCount =  <br>m_TranStatus.MediaTrackLength = <br>m_TranStatus.MediaTrackSide = <br>m_TranStatus.MediaType = 0L; <br>m_TranStatus.LinkMode = OATRUE;// default to "linked" <br> <br>m_localcontrol = FALSE; <br>} <br> <br>//------------------------------------------ <br>// <br>//Destructor <br>// <br>//------------------------------------------ <br>CAMExtTransport::~CAMExtTransport() <br>{ <br> <br>} <br> <br>//------------------------------------------ <br>// <br>// NonDelegatingQueryInterface <br>// <br>// Reveal our Interface <br>//------------------------------------------ <br>STDMETHODIMP <br>CAMExtTransport::NonDelegatingQueryInterface(REFIID riid, void **ppv) <br>{ <br>CAutoLock cObjectLock(&amp;m_StateLock); <br> <br>    if (riid == IID_IAMExtTransport) <br>        return GetInterface((IAMExtTransport *) this, ppv); <br>    else <br>        return CUnknown::NonDelegatingQueryInterface(riid, ppv); <br>}  <br> <br>//------------------------------------------ <br>// <br>//SetCommunicationObject <br>// <br>//------------------------------------------ <br>HRESULT  <br>CAMExtTransport::SetCommunicationObject(CDevCom *pCDevCom) <br>{ <br>m_pTDevCom = pCDevCom; <br>return S_OK; <br>} <br> <br>//------------------------------------------ <br>// <br>//GetCapability <br>// <br>// Transport capabilities property <br>//------------------------------------------ <br>HRESULT  <br>CAMExtTransport::GetCapability(long Capability, long *pValue, <br>   double *pdblValue ) <br>{ <br>return E_NOTIMPL; <br>} <br> <br>//------------------------------------------ <br>// <br>//put_MediaState <br>// <br>//------------------------------------------ <br>HRESULT <br>CAMExtTransport::put_MediaState(long State) <br>{ <br>TESTFLAG(State, OATRUE); <br>int Cookie; <br>// the only thing we'll do here is eject - all others imply <br>// a bigger state change (like STOP-&gt;FREEZE) that we'd like to  <br>// do here <br>if (State == ED_MEDIA_UNLOAD) { <br>if (m_TranStatus.Mode != ED_MODE_STOP) <br>CAMExtTransport::put_Mode(ED_MODE_STOP); <br>if (m_pTDevCom-&gt;SendDevCmd(EJECT, &amp;Cookie)) <br>return E_FAIL; <br>if (m_pTDevCom-&gt;Wait4DevResponse(buf, Cookie)) <br>return E_FAIL; <br>Sleep(4000);// wait a bit until the machine completes <br>m_mediastate = State; <br>return S_OK; <br>} <br>return E_NOTIMPL; <br>} <br> <br>//------------------------------------------ <br>// <br>//get_MediaState <br>// <br>//------------------------------------------ <br>HRESULT <br>CAMExtTransport::get_MediaState(long FAR* pState) <br>{ <br>int Cookie; <br>BOOL bStatusRet; <br> <br>// This might be different for a device other than a VCR, but: <br>// ED_MEDIA_SPIN_UP: media inserted and not stopped <br>// ED_MEDIA_SPIN_DOWN: media inserted and stopped <br>// ED_MEDIA_UNLOAD: media ejected <br>if (m_TranStatus.Mode == ED_MODE_STOP) { <br>// check device for presence of media <br>do { <br>if (m_pTDevCom-&gt;SendDevCmd(REQUEST_STATUS, &amp;Cookie)) <br>return E_FAIL; <br>if (m_pTDevCom-&gt;Wait4DevResponse(buf, Cookie)) <br>return E_FAIL; <br>bStatusRet = m_pTDevCom-&gt;ProcessDeviceStatusResponse(buf, <br>&amp;m_VcrStatus); <br>} while (bStatusRet); <br>if (m_VcrStatus.bCassetteOut == OATRUE) <br>*pState = ED_MEDIA_UNLOAD; <br>else <br>*pState = ED_MEDIA_SPIN_DOWN; <br>} <br>else <br>*pState = ED_MEDIA_SPIN_UP; <br> <br>m_mediastate = *pState; <br>return S_OK; <br>} <br> <br>//------------------------------------------ <br>// <br>//put_LocalControl <br>// <br>//------------------------------------------ <br>HRESULT <br>CAMExtTransport::put_LocalControl(long State) <br>{ <br>TESTFLAG(State, OATRUE); <br>long temp; <br>int Cookie; <br>DWORD dwResult; <br> <br>if (State == OATRUE) <br>temp = LOCAL_ON; <br>else <br>temp = LOCAL_OFF; <br>dwResult = m_pTDevCom-&gt;SendDevCmd(temp, &amp;Cookie); <br>if (dwResult == DEV_COMM_ERR_COMMAND_NOT_SUPPORTED) <br>return E_NOTIMPL; <br>if (dwResult) <br>return E_FAIL; <br>if (m_pTDevCom-&gt;Wait4DevResponse(buf, Cookie)) <br>return E_FAIL; <br>return S_OK; <br>} <br> <br>//------------------------------------------ <br>// <br>//get_LocalControl <br>// <br>//------------------------------------------ <br>HRESULT <br>CAMExtTransport::get_LocalControl(long FAR* pState) <br>{ <br>int Cookie; <br> <br>if (m_pTDevCom-&gt;SendDevCmd(REQUEST_STATUS, &amp;Cookie)) <br>return E_FAIL; <br>if (m_pTDevCom-&gt;Wait4DevResponse(buf, Cookie)) <br>return E_FAIL; <br>m_pTDevCom-&gt;ProcessDeviceStatusResponse(buf, &amp;m_VcrStatus); <br>*pState = m_VcrStatus.bLocal; <br>return S_OK; <br>} <br> <br>//------------------------------------------ <br>// <br>//GetStatus <br>// <br>//------------------------------------------ <br>HRESULT <br>CAMExtTransport::GetStatus(long StatusItem, long FAR* pValue) <br>{ <br>switch (StatusItem) { <br>case ED_LINK_MODE: <br>*pValue = m_TranStatus.LinkMode; <br>return S_OK; <br>default: <br>return E_NOTIMPL; <br>} <br>} <br> <br>//------------------------------------------ <br>// <br>//GetTransportBasicParameters <br>// <br>//------------------------------------------ <br>HRESULT <br>CAMExtTransport::GetTransportBasicParameters(long Param, long FAR* pValue, <br> LPOLESTR * ppszData) <br>{ <br>return E_NOTIMPL; <br>} <br> <br>//------------------------------------------ <br>// <br>//SetTransportBasicParameters <br>// <br>//------------------------------------------ <br>HRESULT <br>CAMExtTransport::SetTransportBasicParameters(long Param, long Value, <br> LPCOLESTR pszData) <br>{ <br>// we test false because this is not implemented <br>TESTFLAG(Param, OAFALSE); <br>return E_NOTIMPL; <br>} <br> <br>//------------------------------------------ <br>// <br>//GetTransportVideoParameters <br>// <br>//------------------------------------------ <br>HRESULT <br>CAMExtTransport::GetTransportVideoParameters(long Param, long FAR* pValue) <br>{ <br>HRESULT hr = S_OK; <br> <br>switch (Param) { <br>case ED_TRANSVIDEO_SET_OUTPUT: <br>*pValue = m_TranVidParms.OutputMode; <br>break; <br>case ED_TRANSVIDEO_SET_SOURCE: <br>*pValue = m_TranVidParms.Input; <br>break; <br>default: <br>hr = VFW_E_NOT_FOUND; <br>} <br>return hr; <br>} <br> <br>//------------------------------------------ <br>// <br>//SetTransportVideoParameters <br>// <br>//------------------------------------------ <br>HRESULT <br>CAMExtTransport::SetTransportVideoParameters(long Param, long Value) <br>{ <br>// we test false because this is not implemented <br>TESTFLAG(Param, OAFALSE); <br>return E_NOTIMPL; <br>} <br> <br>//------------------------------------------ <br>// <br>//GetTransportAudioParameters <br>// <br>//------------------------------------------ <br>HRESULT <br>CAMExtTransport::GetTransportAudioParameters(long Param, long FAR* pValue) <br>{ <br>HRESULT hr = S_OK; <br> <br>switch (Param) { <br>case ED_TRANSAUDIO_ENABLE_OUTPUT: <br>*pValue = m_TranAudParms.EnableOutput; <br>break; <br>case ED_TRANSAUDIO_ENABLE_RECORD: <br>*pValue = m_TranAudParms.EnableRecord; <br>break; <br>case ED_TRANSAUDIO_SET_SOURCE: <br>*pValue = m_TranAudParms.Input; <br>break; <br>case ED_TRANSAUDIO_SET_MONITOR: <br>*pValue = m_TranAudParms.MonitorSource; <br>break; <br>default: <br>hr = VFW_E_NOT_FOUND; <br>} <br>return hr; <br>} <br> <br>//------------------------------------------ <br>// <br>//SetTransportAudioParameters <br>// <br>//------------------------------------------ <br>HRESULT <br>CAMExtTransport::SetTransportAudioParameters(long Param, long Value) <br>{ <br>// we test false because this is not implemented <br>TESTFLAG(Param, OAFALSE); <br>return E_NOTIMPL; <br>} <br> <br>//------------------------------------------ <br>// <br>//put_Mode <br>// <br>//------------------------------------------ <br>HRESULT <br>CAMExtTransport::put_Mode(long Mode) <br>{ <br>HRESULT result = S_OK; <br>DWORD cmdresult; <br>static TCHAR buf[32]; <br>int Cookie; <br> <br>TESTFLAG(Mode, OATRUE); <br>if ( Mode == m_TranStatus.Mode ) <br>return S_OK;// don't repeat commands <br>if ( m_localcontrol == TRUE ) <br>return ED_ERR_DEVICE_NOT_READY; <br> <br>switch (Mode) { <br>case ED_MODE_PLAY: <br>cmdresult = m_pTDevCom-&gt;SendDevCmd(PLAY, &amp;Cookie); <br>ASSERT(cmdresult == 0L); <br>if (cmdresult == 0L) <br>if (m_pTDevCom-&gt;Wait4DevResponse(buf, Cookie)) <br>return E_FAIL; <br>m_lastmode = m_TranStatus.Mode; <br>m_TranStatus.Mode = ED_MODE_PLAY; <br>break; <br>case ED_MODE_STOP: <br>cmdresult = m_pTDevCom-&gt;SendDevCmd(STOP, &amp;Cookie); <br>ASSERT(cmdresult == 0L); <br>if (m_pTDevCom-&gt;Wait4DevResponse(buf, Cookie)) <br>return E_FAIL; <br>cmdresult = m_pTDevCom-&gt;SendDevCmd(STANDBY_OFF, &amp;Cookie); <br>// we know that some machines don't support STANDBY_OFF <br>if (cmdresult != 0 &amp;&amp; <br>cmdresult != DEV_COMM_ERR_COMMAND_NOT_SUPPORTED ) <br>ASSERT(cmdresult == 0L); <br>if (cmdresult == 0L) <br>if (m_pTDevCom-&gt;Wait4DevResponse(buf, Cookie)) <br>return E_FAIL; <br>m_lastmode = m_TranStatus.Mode; <br>m_TranStatus.Mode = ED_MODE_STOP; <br>break; <br>case ED_MODE_FREEZE: <br>if (m_TranStatus.Mode == ED_MODE_STOP) { <br>return result; <br>} <br>cmdresult = m_pTDevCom-&gt;SendDevCmd(FREEZE_ON, &amp;Cookie); <br>ASSERT(cmdresult == 0L); <br>if (cmdresult == 0L) <br>if (m_pTDevCom-&gt;Wait4DevResponse(buf, Cookie)) <br>return E_FAIL; <br>m_lastmode = m_TranStatus.Mode; <br>m_TranStatus.Mode = ED_MODE_FREEZE; <br>break; <br>case ED_MODE_THAW: <br>cmdresult = m_pTDevCom-&gt;SendDevCmd(FREEZE_OFF, &amp;Cookie); <br>ASSERT(cmdresult == 0L); <br>if (cmdresult == 0L) <br>if (m_pTDevCom-&gt;Wait4DevResponse(buf, Cookie)) <br>return E_FAIL; <br>m_TranStatus.Mode = m_lastmode; <br>break; <br> <br>case ED_MODE_FF: <br>cmdresult = m_pTDevCom-&gt;SendDevCmd(FFWD, &amp;Cookie); <br>ASSERT(cmdresult == 0L); <br>if (cmdresult == 0L) <br>if (m_pTDevCom-&gt;Wait4DevResponse(buf, Cookie)) <br>return E_FAIL; <br>m_lastmode = m_TranStatus.Mode; <br>m_TranStatus.Mode = ED_MODE_FF; <br>break; <br>case ED_MODE_REW: <br>cmdresult = m_pTDevCom-&gt;SendDevCmd(REWIND, &amp;Cookie); <br>ASSERT(cmdresult == 0L); <br>if (cmdresult == 0L) <br>if (m_pTDevCom-&gt;Wait4DevResponse(buf, Cookie)) <br>return E_FAIL; <br>m_lastmode = m_TranStatus.Mode; <br>m_TranStatus.Mode = ED_MODE_REW; <br>break; <br>case ED_MODE_RECORD: <br>cmdresult = m_pTDevCom-&gt;SendDevCmd(RECORD, &amp;Cookie); <br>ASSERT(cmdresult == 0L); <br>if (cmdresult == 0L) <br>if (m_pTDevCom-&gt;Wait4DevResponse(buf, Cookie)) <br>return E_FAIL; <br>m_lastmode = m_TranStatus.Mode; <br>m_TranStatus.Mode = ED_MODE_RECORD; <br>break; <br>case ED_MODE_RECORD_STROBE: <br>result = E_NOTIMPL; <br>break; <br>case ED_MODE_STEP: <br>result = E_NOTIMPL; <br>break; <br>case ED_MODE_SHUTTLE: <br>result = E_NOTIMPL; <br>break; <br>case ED_MODE_LINK_ON: <br>m_TranStatus.LinkMode = OATRUE; <br>break; <br>case ED_MODE_LINK_OFF: <br>m_TranStatus.LinkMode = OAFALSE; <br>break; <br>default: <br>result = E_NOTIMPL; <br>} <br>// clean up if things went well <br>return result; <br>} <br> <br>//------------------------------------------ <br>// <br>//get_Mode <br>// <br>//------------------------------------------ <br>HRESULT <br>CAMExtTransport::get_Mode(long FAR* pMode) <br>{ <br>*pMode = m_TranStatus.Mode; <br>return S_OK; <br>} <br> <br>//------------------------------------------ <br>// <br>//put_Rate <br>// <br>//------------------------------------------ <br>HRESULT <br>CAMExtTransport::put_Rate(double dblRate) <br>{ <br>// add Test flag support <br>return E_NOTIMPL; <br>} <br> <br>//------------------------------------------ <br>// <br>//get_Rate <br>// <br>//------------------------------------------ <br>HRESULT <br>CAMExtTransport::get_Rate(double FAR* pdblRate) <br>{ <br>return E_NOTIMPL; <br>} <br> <br>//------------------------------------------ <br>// <br>//GetChase <br>// <br>//------------------------------------------ <br>HRESULT <br>CAMExtTransport::GetChase(long FAR* pEnabled, long FAR* pOffset, <br>  HEVENT FAR* phEvent) <br>{ <br>return E_NOTIMPL; <br>} <br> <br>//------------------------------------------ <br>// <br>//SetChase <br>// <br>//------------------------------------------ <br>HRESULT <br>CAMExtTransport::SetChase(long Enable, long Offset, HEVENT hEvent) <br>{ <br>return E_NOTIMPL; <br>} <br> <br>//------------------------------------------ <br>// <br>//GetBump <br>// <br>//------------------------------------------ <br>HRESULT <br>CAMExtTransport::GetBump(long FAR* pSpeed, long FAR* pDuration) <br>{ <br>return E_NOTIMPL; <br>} <br> <br>//------------------------------------------ <br>// <br>//SetBump <br>// <br>//------------------------------------------ <br>HRESULT <br>CAMExtTransport::SetBump(long Speed, long Duration) <br>{ <br>return E_NOTIMPL; <br>} <br> <br>//------------------------------------------ <br>// <br>//get_AntiClogControl <br>// <br>//------------------------------------------ <br>HRESULT <br>CAMExtTransport::get_AntiClogControl(long FAR* pEnabled) <br>{ <br>return E_NOTIMPL; <br>} <br> <br>//------------------------------------------ <br>// <br>//put_AntiClogControl <br>// <br>//------------------------------------------ <br>HRESULT <br>CAMExtTransport::put_AntiClogControl(long Enable) <br>{ <br>TESTFLAG(Enable, OAFALSE); <br>return E_NOTIMPL; <br>} <br> <br>//------------------------------------------ <br>// <br>//GetEditPropertySet <br>// <br>//------------------------------------------ <br>HRESULT <br>CAMExtTransport::GetEditPropertySet(long EditID, long FAR* pState) <br>{ <br>return E_NOTIMPL; <br>} <br> <br>//------------------------------------------ <br>// <br>//SetEditPropertySet <br>// <br>//------------------------------------------ <br>HRESULT <br>CAMExtTransport::SetEditPropertySet(long FAR* pEditID, long State) <br>{ <br>TESTFLAG(State, OAFALSE); <br>return E_NOTIMPL; <br>} <br> <br>//------------------------------------------ <br>// <br>//GetEditProperty <br>// <br>//------------------------------------------ <br>HRESULT <br>CAMExtTransport::GetEditProperty(long EditID, long Param, long FAR* pValue) <br>{ <br>return E_NOTIMPL; <br>} <br> <br>//------------------------------------------ <br>// <br>//SetEditProperty <br>// <br>//------------------------------------------ <br>HRESULT <br>CAMExtTransport::SetEditProperty(long EditID, long Param, long Value) <br>{ <br>return E_NOTIMPL; <br>} <br> <br>//------------------------------------------ <br>// <br>//get_EditStart <br>// <br>//------------------------------------------ <br>HRESULT <br>CAMExtTransport::get_EditStart(long FAR* pValue) <br>{ <br>return E_NOTIMPL; <br>} <br> <br>//------------------------------------------ <br>// <br>//put_EditStart <br>// <br>//------------------------------------------ <br>HRESULT <br>CAMExtTransport::put_EditStart(long Value) <br>{ <br>TESTFLAG(Value, OAFALSE); <br>return E_NOTIMPL; <br>} <br> <br>//------------------------------------------ <br>// <br>// CAMTcr implementation <br>// <br>//------------------------------------------ <br>CAMTcr::CAMTcr(HRESULT * phr, TCHAR *tszName) : <br>CUnknown( tszName, NULL ) <br>{ <br>// need some help with timecode <br>m_timecode = new CTimecode(); <br>} <br> <br>//------------------------------------------ <br>// <br>//Destructor <br>// <br>//------------------------------------------ <br>CAMTcr::~CAMTcr() <br>{ <br> <br>} <br>//------------------------------------------ <br>// <br>// NonDelegatingQueryInterface <br>// <br>// Reveal our Interface <br>//------------------------------------------ <br>STDMETHODIMP <br>CAMTcr::NonDelegatingQueryInterface(REFIID riid, void **ppv) { <br> <br>CAutoLock cObjectLock(&amp;m_StateLock); <br> <br>    if (riid == IID_IAMTimecodeReader) <br>        return GetInterface((IAMTimecodeReader *) this, ppv); <br>    else <br>        return CUnknown::NonDelegatingQueryInterface(riid, ppv); <br>}  <br> <br>//------------------------------------------ <br>// <br>//SetCommunicationObject <br>// <br>//------------------------------------------ <br>HRESULT  <br>CAMTcr::SetCommunicationObject(CDevCom *pCDevCom) <br>{ <br>m_pTCDevCom = pCDevCom; <br>return S_OK; <br>} <br> <br>//------------------------------------------ <br>// <br>//GetTCRMode <br>// <br>//------------------------------------------ <br>HRESULT  <br>CAMTcr::GetTCRMode(long Param, long FAR* pValue) <br>{ <br>return E_NOTIMPL; <br>} <br> <br>//------------------------------------------ <br>// <br>//get_VITCLine <br>// <br>//------------------------------------------ <br>HRESULT  <br>CAMTcr::get_VITCLine(long * pLine) <br>{ <br>return E_NOTIMPL; <br>} <br> <br>//------------------------------------------ <br>// <br>//put_VITCLine <br>// <br>//------------------------------------------ <br>HRESULT  <br>CAMTcr::put_VITCLine(long Line) <br>{ <br>return E_NOTIMPL; <br>} <br> <br>//------------------------------------------ <br>// <br>//SetTCRMode <br>// <br>//------------------------------------------ <br>HRESULT  <br>CAMTcr::SetTCRMode(long Param, long Value) <br>{ <br>TCHAR buf[20]; <br>int Cookie; <br>DWORD dwResult; <br> <br>TESTFLAG(Param, OATRUE); <br>// the real implementation will use a table instead <br>//of a switch.  This seriously partial implementation <br>//is just to get basic timecode reading right <br>switch (Param) <br>{ <br>case ED_TCR_SOURCE: <br>if ( Value == ED_TCR_LTC ) { <br>dwResult = m_pTCDevCom-&gt;SendDevCmd(TIMER_MODE_SELECT_LTC, <br>&amp;Cookie); <br>// we know that some machines don't support this command <br>// and don't even ask for an answer <br>if ( dwResult == DEV_COMM_ERR_COMMAND_NOT_SUPPORTED) <br>return E_NOTIMPL; <br>if ( dwResult )// fail on all other result codes <br>return E_FAIL; <br>if (m_pTCDevCom-&gt;Wait4DevResponse(buf, Cookie)) <br>return E_FAIL; <br>} <br>return S_OK; <br>default: <br>return E_NOTIMPL; <br>} <br>return E_NOTIMPL; <br>} <br> <br>//------------------------------------------ <br>// <br>//GetTimecode <br>// <br>//------------------------------------------ <br>HRESULT  <br>CAMTcr::GetTimecode( PTIMECODE_SAMPLE pTimecodeSample) <br>{ <br>DWORD cmdresult; <br>static TCHAR buf[32]; <br>DWORD fcm; <br>int Cookie; <br>       LONG lFrame, lUser ; <br> <br>cmdresult = m_pTCDevCom-&gt;SendDevCmd(READ_TC, &amp;Cookie); <br>if ( cmdresult == 0L ) <br>{// commands might get refused <br>if ( (cmdresult = m_pTCDevCom-&gt;Wait4DevResponse(buf, Cookie)) ) </code></pre>
<p>
</p>
<pre><code>return cmdresult;//E_FAIL; <br>DbgLog((LOG_TRACE, 1, buf)); <br>m_pTCDevCom-&gt;ProcessVcrTC(buf, &amp;fcm, &amp;lFrame, &amp;lUser); <br>pTimecodeSample-&gt;timecode.wFrameRate = (WORD)fcm; <br>pTimecodeSample-&gt;timecode.dwFrames = (DWORD) lFrame ; <br>pTimecodeSample-&gt;dwUser = (DWORD) lUser ; <br>pTimecodeSample-&gt;dwFlags = 0L; <br>return S_OK; <br>} <br>// leave the reference time alone for now  <br>// (to be filled in by calling filter) <br>return S_FALSE; <br>} <br> <br>//eof  cvcrutil.cpp </code></pre>
<p>&nbsp;</p></body>
</HTML>
