<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CVCRUTIL.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2948"></a>CVCRUTIL.H</h2>
<pre><code>//=========================================================================== <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>// PURPOSE. <br>// <br>// Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//=========================================================================== <br>// <br>// filename: cvcrutil.h <br>// <br>// base abstract classes implementing the device control interfaces <br>// derive your filter (or an embedded class) from one of these and implement <br>// the pure virtual property and method functions <br>// <br> <br>#ifndef __CVCRUTIL__ <br>#define __CVCRUTIL__ <br> <br> <br>// a macro to screen for the "Test" flag <br>#define TESTFLAG(a,b) if( a &amp; 0x8000 ) return b <br> <br> <br>//--------------------------------------------------------- <br>// <br>// Structures for this implementation <br>// <br>//--------------------------------------------------------- <br> <br>// someplace to put our properties <br>typedef struct tagDEVCAPS{ <br>long CanRecord; <br>long CanRecordStrobe; <br>long HasAudio; <br>long HasVideo; <br>long UsesFiles; <br>long CanSave; <br>long DeviceType; <br>long TCRead; <br>long TCWrite; <br>long CTLRead; <br>long IndexRead; <br>long Preroll; <br>long Postroll; <br>long SyncAcc; <br>long NormRate; <br>long CanPreview; <br>long CanMonitorSrc; <br>long CanTest; <br>long VideoIn; <br>long AudioIn; <br>long Calibrate; <br>long SeekType; <br>long SimulatedHardware;// private <br>} DEVCAPS; <br> <br>typedef DEVCAPS far *PDEVCAPS; <br> <br>// transport status <br>typedef struct tagTRANSPORTSTATUS{ <br>long Mode; <br>long LastError; <br>long RecordInhibit; <br>long ServoLock; <br>long MediaPresent; <br>long MediaLength; <br>long MediaSize; <br>long MediaTrackCount; <br>long MediaTrackLength; <br>long MediaTrackSide; <br>long MediaType; <br>long LinkMode; <br>} TRANSPORTSTATUS; <br>typedef TRANSPORTSTATUS far *PTRANSPORTSTATUS; <br> <br>// transport basic parameters <br>typedef struct tagTRANSPORTBASICPARMS{ <br>long TimeFormat; <br>long TimeReference; <br>long Superimpose; <br>long EndStopAction; <br>long RecordFormat; <br>long StepFrames; <br>long SetpField; <br>long Preroll; <br>long RecPreroll; <br>long Postroll; <br>long EditDelay; <br>long PlayTCDelay; <br>long RecTCDelay; <br>long EditField; <br>long FrameServo; <br>long ColorFrameServo; <br>long ServoRef; <br>long WarnGenlock; <br>long SetTracking; <br>TCHAR VolumeName[40]; <br>long Ballistic[20]; <br>long Speed; <br>long CounterFormat; <br>long TunerChannel; <br>long TunerNumber; <br>long TimerEvent; <br>long TimerStartDay; <br>long TimerStartTime; <br>long TimerStopDay; <br>long TimerStopTime; <br>} TRANSPORTBASICPARMS; <br>typedef TRANSPORTBASICPARMS far *PTRANSPORTBASICPARMS; <br> <br>// transport video parameters <br>typedef struct tagTRANSPORTVIDEOPARMS{ <br>long OutputMode; <br>long Input; <br>} TRANSPORTVIDEOPARMS; <br>typedef TRANSPORTVIDEOPARMS far *PTRANSPORTVIDEOPARMS; <br> <br>// transport audio parameters <br>typedef struct tagTRANSPORTAUDIOPARMS{ <br>long EnableOutput; <br>long EnableRecord; <br>long EnableSelsync; <br>long Input; <br>long MonitorSource; <br>} TRANSPORTAUDIOPARMS; <br>typedef TRANSPORTAUDIOPARMS far *PTRANSPORTAUDIOPARMS; <br> <br> <br>//--------------------------------------------------------- <br>// <br>// Here's the temporary CAMPhysicalPinInfo class to be used with the input pins <br>// <br>//--------------------------------------------------------- <br>class CAMPhysicalPinInfo : public CUnknown, public IAMPhysicalPinInfo <br>{ <br>public: <br> <br>CAMPhysicalPinInfo(HRESULT * phr, TCHAR *tszName); <br>    virtual ~CAMPhysicalPinInfo(); <br> <br>DECLARE_IUNKNOWN <br>// override this to say what interfaces we support where <br>    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv); <br> <br>/* IAMPhysicalPinInfo method  - to be implemented by derived class */ <br>virtual STDMETHODIMP GetPhysicalType(long *pType, LPOLESTR * ppszType) PURE; <br> <br>protected: <br>CCritSec m_StateLock;// Lock this to serialize function accesses to the  <br>//  filter state <br> <br>private: <br>CCritSec  *m_pCritSec;// Object we use for locking <br> <br>}; <br> <br>//--------------------------------------------------------- <br>// <br>//IAMExtDevice Implementation <br>// <br>//--------------------------------------------------------- <br> <br>class CAMExtDevice : public CUnknown, public IAMExtDevice <br>{ <br>public: <br> <br>CAMExtDevice(HRESULT * phr, TCHAR *tszName); <br>    virtual ~CAMExtDevice(); <br> <br>DECLARE_IUNKNOWN <br>// override this to say what interfaces we support where <br>    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);     <br> <br>/* IAMExtDevice methods */ <br>STDMETHODIMP GetCapability (long Capability, long FAR* pValue, <br>double FAR* pdblValue); <br>    STDMETHODIMP get_ExternalDeviceID(LPOLESTR * ppszData); <br>    STDMETHODIMP get_ExternalDeviceVersion(LPOLESTR * ppszData); <br>    STDMETHODIMP put_DevicePower(long PowerMode); <br>    STDMETHODIMP get_DevicePower(long FAR* pPowerMode); <br>    STDMETHODIMP Calibrate(HEVENT hEvent, long Mode, long FAR* pStatus); <br>STDMETHODIMP get_DevicePort(long FAR * pDevicePort); <br>STDMETHODIMP put_DevicePort(long DevicePort); <br> <br>protected: <br>CDevCom *m_devcom;// how to talk to the machine <br>CCritSec m_StateLock;// Lock this to serialize function accesses  <br>//  to the filter state <br> <br>private: <br>CCritSec  *m_pCritSec;// Object we use for locking <br>DEVCAPS m_DevCaps;// external device capabilities <br> <br>int m_CurDevicePort;// how we are talking to the machine <br>int m_PowerMode;// on, off or standby <br>}; <br> <br>//--------------------------------------------------------- <br>// <br>// IAMExtTransport implementation <br>// <br>// Transport Class - VCRs, ATRs, DDRs, etc. <br>// <br>//--------------------------------------------------------- <br>class CAMExtTransport : public CUnknown, public IAMExtTransport <br>{ <br>public: <br> <br>CAMExtTransport(HRESULT * phr, TCHAR *tszName); <br>    virtual ~CAMExtTransport(); <br> <br>   DECLARE_IUNKNOWN <br>    // override this to say what interfaces we support where <br>    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv); <br> <br>/* IAMExtTransport methods */ <br>STDMETHODIMP GetCapability (long Capability, long FAR* pValue, <br>double FAR* pdblValue); <br>    STDMETHODIMP put_MediaState(long State); <br>    STDMETHODIMP get_MediaState(long FAR* pState); <br>    STDMETHODIMP put_LocalControl(long State); <br>    STDMETHODIMP get_LocalControl(long FAR* pState); <br>    STDMETHODIMP GetStatus(long StatusItem, long FAR* pValue); <br>    STDMETHODIMP GetTransportBasicParameters(long Param, long FAR* pValue, <br>LPOLESTR * ppszData); <br>    STDMETHODIMP SetTransportBasicParameters(long Param, long Value, <br>LPCOLESTR pszData); <br>    STDMETHODIMP GetTransportVideoParameters(long Param, long FAR* pValue); <br>    STDMETHODIMP SetTransportVideoParameters(long Param, long Value); <br>    STDMETHODIMP GetTransportAudioParameters(long Param, long FAR* pValue); <br>    STDMETHODIMP SetTransportAudioParameters(long Param, long Value); <br>    STDMETHODIMP put_Mode(long Mode); <br>    STDMETHODIMP get_Mode(long FAR* pMode); <br>    STDMETHODIMP put_Rate(double dblRate); <br>    STDMETHODIMP get_Rate(double FAR* pdblRate); <br>    STDMETHODIMP GetChase(long FAR* pEnabled, long FAR* pOffset, <br>HEVENT FAR* phEvent); <br>    STDMETHODIMP SetChase(long Enable, long Offset, HEVENT hEvent); <br>    STDMETHODIMP GetBump(long FAR* pSpeed, long FAR* pDuration); <br>    STDMETHODIMP SetBump(long Speed, long Duration); <br>    STDMETHODIMP get_AntiClogControl(long FAR* pEnabled); <br>    STDMETHODIMP put_AntiClogControl(long Enable); <br>    STDMETHODIMP GetEditPropertySet(long EditID, long FAR* pState); <br>    STDMETHODIMP SetEditPropertySet(long FAR* pEditID, long State); <br>    STDMETHODIMP GetEditProperty(long EditID, long Param, long FAR* pValue); <br>    STDMETHODIMP SetEditProperty(long EditID, long Param, long Value); <br>    STDMETHODIMP get_EditStart(long FAR* pValue); <br>    STDMETHODIMP put_EditStart(long Value); <br> <br>// The communications object can change depending on the low-level <br>// protocol and/or hardware connection <br>HRESULT SetCommunicationObject(CDevCom *); <br> <br>protected: <br>CCritSec m_StateLock;// Lock this to serialize function accesses  <br>//  to the filter state <br> <br>private: <br>CDevCom *m_pTDevCom;// how to talk to the machine <br>TRANSPORTSTATUSm_TranStatus;// current status <br>TRANSPORTVIDEOPARMS m_TranVidParms;// keep all capabilities, etc. here <br>TRANSPORTAUDIOPARMS m_TranAudParms; <br>TRANSPORTBASICPARMS m_TranBasicParms; <br> <br>// a bunch of properties we want to remember <br>long m_lastmode; <br>long m_mediastate; <br>long m_localcontrol; <br>VCRSTATUS m_VcrStatus;// raw status from VCR <br> <br>}; <br> <br>//--------------------------------------------------------- <br>// <br>// IAMTimecodeReader implementation <br>// <br>//--------------------------------------------------------- <br> <br>// Timecode Reader class <br>class CAMTcr : public CUnknown, public IAMTimecodeReader <br>{ <br>public: <br> <br>CAMTcr(HRESULT * phr, TCHAR *tszName); <br>    virtual ~CAMTcr(); <br> <br>   DECLARE_IUNKNOWN <br>// override this to say what interfaces we support where <br>    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv); <br> <br>    /* IAMTimecodeReader methods */ <br>    STDMETHODIMP GetTCRMode( long Param, long FAR* pValue); <br>    STDMETHODIMP SetTCRMode( long Param, long Value); <br>    STDMETHODIMP put_VITCLine( long Line); <br>    STDMETHODIMP get_VITCLine( long FAR* pLine); <br>    STDMETHODIMP GetTimecode( PTIMECODE_SAMPLE pTimecodeSample); <br> <br>// helper to connect to the communications object.  This <br>// is an implementation-specific method <br>HRESULT SetCommunicationObject(CDevCom *); <br> <br>protected: <br>CCritSec m_StateLock;// Lock this to serialize function accesses <br>//  to the filter state <br> <br>private: <br>CDevCom *m_pTCDevCom;// how to talk to the device <br>CTimecode *m_timecode; <br>}; <br> <br>#endif // __CVCRUTIL__ <br> <br>// eof cvcrutil.h </code></pre>
<p>&nbsp;</p></body>
</HTML>
