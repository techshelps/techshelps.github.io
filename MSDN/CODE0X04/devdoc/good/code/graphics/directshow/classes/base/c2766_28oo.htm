<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TRANSFRM.H</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2778"></a>TRANSFRM.H</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>// <br>// base class from which you can derive a simple transform codec. <br>// <br>// It assumes the codec has one input and one output stream, and has no <br>// interest in memory management, interface negotiation or anything else. <br>// <br>// derive your class from this, and supply Transform and the media type/format <br>// negotiation functions. Implement that class, compile and link and <br>// you're done. <br> <br> <br>#ifndef __TRANSFRM__ <br>#define __TRANSFRM__ <br> <br>// ====================================================================== <br>// This is the com object that represents a simple transform filter. It <br>// supports IBaseFilter, IMediaFilter and two pins through nested interfaces <br>// ====================================================================== <br> <br>class CTransformFilter; <br> <br>// ================================================== <br>// Implements the input pin <br>// ================================================== <br> <br>class CTransformInputPin : public CBaseInputPin <br>{ <br>    friend class CTransformFilter; <br> <br>protected: <br>    CTransformFilter *m_pTransformFilter; <br> <br> <br>public: <br> <br>    CTransformInputPin( <br>        TCHAR *pObjectName, <br>        CTransformFilter *pTransformFilter, <br>        HRESULT * phr, <br>        LPCWSTR pName); <br> <br>    STDMETHODIMP QueryId(LPWSTR * Id) <br>    { <br>        return AMGetWideString(L"In", Id); <br>    } <br> <br>    // Grab and release extra interfaces if required <br> <br>    HRESULT CheckConnect(IPin *pPin); <br>    HRESULT BreakConnect(); <br>    HRESULT CompleteConnect(IPin *pReceivePin); <br> <br>    // check that we can support this output type <br>    HRESULT CheckMediaType(const CMediaType* mtIn); <br> <br>    // set the connection media type <br>    HRESULT SetMediaType(const CMediaType* mt); <br> <br>    // --- IMemInputPin ----- <br> <br>    // here's the next block of data from the stream. <br>    // AddRef it yourself if you need to hold it beyond the end <br>    // of this call. <br>    STDMETHODIMP Receive(IMediaSample * pSample); <br> <br>    // provide EndOfStream that passes straight downstream <br>    // (there is no queued data) <br>    STDMETHODIMP EndOfStream(void); <br> <br>    // passes it to CTransformFilter::BeginFlush <br>    STDMETHODIMP BeginFlush(void); <br> <br>    // passes it to CTransformFilter::EndFlush <br>    STDMETHODIMP EndFlush(void); <br> <br>    STDMETHODIMP NewSegment( <br>                        REFERENCE_TIME tStart, <br>                        REFERENCE_TIME tStop, <br>                        double dRate); <br> <br>    // Check if it's OK to process samples <br>    virtual HRESULT CheckStreaming(); <br> <br>    // Media type <br>public: <br>    CMediaType&amp; CurrentMediaType() { return m_mt; }; <br> <br>}; <br> <br>// ================================================== <br>// Implements the output pin <br>// ================================================== <br> <br>class CTransformOutputPin : public CBaseOutputPin <br>{ <br>    friend class CTransformFilter; <br> <br>protected: <br>    CTransformFilter *m_pTransformFilter; <br> <br>public: <br> <br>    // implement IMediaPosition by passing upstream <br>    IUnknown * m_pPosition; <br> <br>    CTransformOutputPin( <br>        TCHAR *pObjectName, <br>        CTransformFilter *pTransformFilter, <br>        HRESULT * phr, <br>        LPCWSTR pName); <br> <br>    ~CTransformOutputPin(); <br> <br>    // override to expose IMediaPosition <br>    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv); <br> <br>    // --- CBaseOutputPin ------------ <br> <br>    STDMETHODIMP QueryId(LPWSTR * Id) <br>    { <br>        return AMGetWideString(L"Out", Id); <br>    } <br> <br>    // Grab and release extra interfaces if required <br> <br>    HRESULT CheckConnect(IPin *pPin); <br>    HRESULT BreakConnect(); <br>    HRESULT CompleteConnect(IPin *pReceivePin); <br> <br>    // check that we can support this output type <br>    HRESULT CheckMediaType(const CMediaType* mtOut); <br> <br>    // set the connection media type <br>    HRESULT SetMediaType(const CMediaType *pmt); <br> <br>    // called from CBaseOutputPin during connection to ask for <br>    // the count and size of buffers we need. <br>    HRESULT DecideBufferSize( <br>                IMemAllocator * pAlloc, <br>                ALLOCATOR_PROPERTIES *pProp); <br> <br>    // returns the preferred formats for a pin <br>    HRESULT GetMediaType(int iPosition,CMediaType *pMediaType); <br> <br>    // inherited from IQualityControl via CBasePin <br>    STDMETHODIMP Notify(IBaseFilter * pSender, Quality q); <br> <br>    // Media type <br>public: <br>    CMediaType&amp; CurrentMediaType() { return m_mt; }; <br>}; <br> <br> <br>class AM_NOVTABLE CTransformFilter : public CBaseFilter <br>{ <br> <br>public: <br> <br>    // map getpin/getpincount for base enum of pins to owner <br>    // override this to return more specialised pin objects <br> <br>    virtual int GetPinCount(); <br>    virtual CBasePin * GetPin(int n); <br>    STDMETHODIMP FindPin(LPCWSTR Id, IPin **ppPin); <br> <br>    // override state changes to allow derived transform filter <br>    // to control streaming start/stop <br>    STDMETHODIMP Stop(); <br>    STDMETHODIMP Pause(); <br> <br>public: <br> <br>    CTransformFilter(TCHAR *, LPUNKNOWN, REFCLSID clsid); <br>    ~CTransformFilter(); <br> <br>    // ================================================================= <br>    // ----- override these bits --------------------------------------- <br>    // ================================================================= <br> <br>    // These must be supplied in a derived class <br> <br>    virtual HRESULT Transform(IMediaSample * pIn, IMediaSample *pOut); <br> <br>    // check if you can support mtIn <br>    virtual HRESULT CheckInputType(const CMediaType* mtIn) PURE; <br> <br>    // check if you can support the transform from this input to this output <br>    virtual HRESULT CheckTransform(const CMediaType* mtIn, const CMediaType* mtOut) PURE; <br> <br>    // this goes in the factory template table to create new instances <br>    // static CCOMObject * CreateInstance(LPUNKNOWN, HRESULT *); <br> <br>    // call the SetProperties function with appropriate arguments <br>    virtual HRESULT DecideBufferSize( <br>                        IMemAllocator * pAllocator, <br>                        ALLOCATOR_PROPERTIES *pprop) PURE; <br> <br>    // override to suggest OUTPUT pin media types <br>    virtual HRESULT GetMediaType(int iPosition, CMediaType *pMediaType) PURE; <br> <br> <br> <br>    // ================================================================= <br>    // ----- Optional Override Methods           ----------------------- <br>    // ================================================================= <br> <br>    // you can also override these if you want to know about streaming <br>    virtual HRESULT StartStreaming(); <br>    virtual HRESULT StopStreaming(); <br> <br>    // override if you can do anything constructive with quality notifications <br>    virtual HRESULT AlterQuality(Quality q); <br> <br>    // override this to know when the media type is actually set <br>    virtual HRESULT SetMediaType(PIN_DIRECTION direction,const CMediaType *pmt); <br> <br>    // chance to grab extra interfaces on connection <br>    virtual HRESULT CheckConnect(PIN_DIRECTION dir,IPin *pPin); <br>    virtual HRESULT BreakConnect(PIN_DIRECTION dir); <br>    virtual HRESULT CompleteConnect(PIN_DIRECTION direction,IPin *pReceivePin); <br> <br>    // chance to customize the transform process <br>    virtual HRESULT Receive(IMediaSample *pSample); <br> <br>    // Standard setup for output sample <br>    HRESULT InitializeOutputSample(IMediaSample *pSample, IMediaSample **ppOutSample); <br> <br>    // if you override Receive, you may need to override these three too <br>    virtual HRESULT EndOfStream(void); <br>    virtual HRESULT BeginFlush(void); <br>    virtual HRESULT EndFlush(void); <br>    virtual HRESULT NewSegment( <br>                        REFERENCE_TIME tStart, <br>                        REFERENCE_TIME tStop, <br>                        double dRate); <br> <br>#ifdef PERF <br>    // Override to register performance measurement with a less generic string <br>    // You should do this to avoid confusion with other filters <br>    virtual void RegisterPerfId() <br>         {m_idTransform = MSR_REGISTER(TEXT("Transform"));} <br>#endif // PERF <br> <br> <br>// implementation details <br> <br>protected: <br> <br>#ifdef PERF <br>    int m_idTransform;                 // performance measuring id <br>#endif <br>    BOOL m_bEOSDelivered;              // have we sent EndOfStream <br>    BOOL m_bSampleSkipped;             // Did we just skip a frame <br>    BOOL m_bQualityChanged;            // Have we degraded? <br> <br>    // critical section protecting filter state. <br> <br>    CCritSec m_csFilter; <br> <br>    // critical section stopping state changes (ie Stop) while we're <br>    // processing a sample. <br>    // <br>    // This critical section is held when processing <br>    // events that occur on the receive thread - Receive() and EndOfStream(). <br>    // <br>    // If you want to hold both m_csReceive and m_csFilter then grab <br>    // m_csFilter FIRST - like CTransformFilter::Stop() does. <br> <br>    CCritSec m_csReceive; <br> <br>    // these hold our input and output pins <br> <br>    friend class CTransformInputPin; <br>    friend class CTransformOutputPin; <br>    CTransformInputPin *m_pInput; <br>    CTransformOutputPin *m_pOutput; <br>}; <br> <br>#endif /* __TRANSFRM__ */ <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
