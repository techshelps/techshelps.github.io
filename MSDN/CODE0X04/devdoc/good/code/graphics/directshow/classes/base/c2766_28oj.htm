<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>STRMCTL.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2773"></a>STRMCTL.CPP</h2>
<pre><code>//==========================================================================; <br>// <br>//  Copyright (c) 1997Microsoft Corporation.All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>#include &lt;streams.h&gt; <br>#include &lt;strmctl.h&gt; <br> <br>CBaseStreamControl::CBaseStreamControl() <br>: m_StreamState(STREAM_FLOWING) <br>, m_StreamStateOnStop(STREAM_FLOWING) // means no pending stop <br>, m_tStartTime(MAX_TIME) <br>, m_tStopTime(MAX_TIME) <br>, m_dwStartCookie(0) <br>, m_dwStopCookie(0) <br>, m_pRefClock(NULL) <br>, m_FilterState(State_Stopped) <br>, m_bIsFlushing(FALSE) <br>, m_bStopSendExtra(FALSE) <br>{} <br> <br>CBaseStreamControl::~CBaseStreamControl() <br>{ <br>    // Make sure we release the clock. <br>    SetSyncSource(NULL); <br>    return; <br>} <br> <br> <br>STDMETHODIMP CBaseStreamControl::StopAt(const REFERENCE_TIME * ptStop, BOOL bSendExtra, DWORD dwCookie) <br>{ <br>    CAutoLock lck(&amp;m_CritSec); <br>    m_bStopSendExtra = FALSE;// reset <br>    m_bStopExtraSent = FALSE; <br>    if (ptStop) <br>    { <br>        if (*ptStop == MAX_TIME) <br>        { <br>            DbgLog((LOG_TRACE,2,TEXT("StopAt: Cancel stop"))); <br>            CancelStop(); <br>    // If there's now a command to start in the future, we assume <br>    // they want to be stopped when the graph is first run <br>    if (m_FilterState == State_Stopped &amp;&amp; m_tStartTime &lt; MAX_TIME) { <br>        m_StreamState = STREAM_DISCARDING; <br>                DbgLog((LOG_TRACE,2,TEXT("graph will begin by DISCARDING"))); <br>    } <br>            return NOERROR; <br>        } <br>        DbgLog((LOG_TRACE,2,TEXT("StopAt: %dms extra=%d"), <br>(int)(*ptStop/10000), bSendExtra)); <br>// if the first command is to stop in the future, then we assume they <br>        // want to be started when the graph is first run <br>if (m_FilterState == State_Stopped &amp;&amp; m_tStartTime &gt; *ptStop) { <br>    m_StreamState = STREAM_FLOWING; <br>            DbgLog((LOG_TRACE,2,TEXT("graph will begin by FLOWING"))); <br>} <br>        m_bStopSendExtra = bSendExtra; <br>        m_tStopTime = *ptStop; <br>        m_dwStopCookie = dwCookie; <br>        m_StreamStateOnStop = STREAM_DISCARDING; <br>    } <br>    else <br>    { <br>        DbgLog((LOG_TRACE,2,TEXT("StopAt: now"))); <br>// sending an extra frame when told to stop now would screw people up <br>        m_bStopSendExtra = FALSE; <br>        m_tStopTime = MAX_TIME; <br>        m_dwStopCookie = 0; <br>        m_StreamState = STREAM_DISCARDING; <br>        m_StreamStateOnStop = STREAM_FLOWING;// no pending stop <br>    } <br>    // we might change our mind what to do with a sample we're blocking <br>    m_StreamEvent.Set(); <br>    return NOERROR; <br>} <br> <br>STDMETHODIMP CBaseStreamControl::StartAt <br>( const REFERENCE_TIME *ptStart, DWORD dwCookie ) <br>{ <br>    CAutoLock lck(&amp;m_CritSec); <br>    if (ptStart) <br>    { <br>        if (*ptStart == MAX_TIME) <br>        { <br>            DbgLog((LOG_TRACE,2,TEXT("StartAt: Cancel start"))); <br>            CancelStart(); <br>    // If there's now a command to stop in the future, we assume <br>    // they want to be started when the graph is first run <br>    if (m_FilterState == State_Stopped &amp;&amp; m_tStopTime &lt; MAX_TIME) { <br>                DbgLog((LOG_TRACE,2,TEXT("graph will begin by FLOWING"))); <br>        m_StreamState = STREAM_FLOWING; <br>    } <br>            return NOERROR; <br>        } <br>        DbgLog((LOG_TRACE,2,TEXT("StartAt: %dms"), (int)(*ptStart/10000))); <br>// if the first command is to start in the future, then we assume they <br>        // want to be stopped when the graph is first run <br>if (m_FilterState == State_Stopped &amp;&amp; m_tStopTime &gt;= *ptStart) { <br>            DbgLog((LOG_TRACE,2,TEXT("graph will begin by DISCARDING"))); <br>    m_StreamState = STREAM_DISCARDING; <br>} <br>        m_tStartTime = *ptStart; <br>        m_dwStartCookie = dwCookie; <br>        // if (m_tStopTime == m_tStartTime) CancelStop(); <br>    } <br>    else <br>    { <br>        DbgLog((LOG_TRACE,2,TEXT("StartAt: now"))); <br>        m_tStartTime = MAX_TIME; <br>        m_dwStartCookie = 0; <br>        m_StreamState = STREAM_FLOWING; <br>    } <br>    // we might change our mind what to do with a sample we're blocking <br>    m_StreamEvent.Set(); <br>    return NOERROR; <br>} <br> <br>//  Retrieve information about current settings <br>STDMETHODIMP CBaseStreamControl::GetInfo(AM_STREAM_INFO *pInfo) <br>{ <br>    if (pInfo == NULL) <br>return E_POINTER; <br> <br>    pInfo-&gt;tStart = m_tStartTime; <br>    pInfo-&gt;tStop  = m_tStopTime; <br>    pInfo-&gt;dwStartCookie = m_dwStartCookie; <br>    pInfo-&gt;dwStopCookie  = m_dwStopCookie; <br>    pInfo-&gt;dwFlags = m_bStopSendExtra ? AM_STREAM_INFO_STOP_SEND_EXTRA : 0; <br>    pInfo-&gt;dwFlags |= m_tStartTime == MAX_TIME ? 0 : AM_STREAM_INFO_START_DEFINED; <br>    pInfo-&gt;dwFlags |= m_tStopTime == MAX_TIME ? 0 : AM_STREAM_INFO_STOP_DEFINED; <br>    switch (m_StreamState) { <br>    default: <br>        DbgBreak("Invalid stream state"); <br>    case STREAM_FLOWING: <br>        break; <br>    case STREAM_DISCARDING: <br>        pInfo-&gt;dwFlags |= AM_STREAM_INFO_DISCARDING; <br>        break; <br>    } <br>    return S_OK; <br>} <br> <br> <br>void CBaseStreamControl::ExecuteStop() <br>{ <br>    ASSERT(CritCheckIn(&amp;m_CritSec)); <br>    m_StreamState = m_StreamStateOnStop; <br>    if (m_dwStopCookie &amp;&amp; m_pSink) { <br>DbgLog((LOG_TRACE,2,TEXT("*sending EC_STREAM_CONTROL_STOPPED (%d)"), <br>m_dwStopCookie)); <br>        m_pSink-&gt;Notify(EC_STREAM_CONTROL_STOPPED, (long)this, m_dwStopCookie); <br>    } <br>    CancelStop(); // This will do the tidy up <br>} <br> <br>void CBaseStreamControl::ExecuteStart() <br>{ <br>    ASSERT(CritCheckIn(&amp;m_CritSec)); <br>    m_StreamState = STREAM_FLOWING; <br>    if (m_dwStartCookie) { <br>DbgLog((LOG_TRACE,2,TEXT("*sending EC_STREAM_CONTROL_STARTED (%d)"), <br>m_dwStartCookie)); <br>        m_pSink-&gt;Notify(EC_STREAM_CONTROL_STARTED, (long)this, m_dwStartCookie); <br>    } <br>    CancelStart(); // This will do the tidy up <br>} <br> <br>void CBaseStreamControl::CancelStop() <br>{ <br>    ASSERT(CritCheckIn(&amp;m_CritSec)); <br>    m_tStopTime = MAX_TIME; <br>    m_dwStopCookie = 0; <br>    m_StreamStateOnStop = STREAM_FLOWING; <br>} <br> <br>void CBaseStreamControl::CancelStart() <br>{ <br>    ASSERT(CritCheckIn(&amp;m_CritSec)); <br>    m_tStartTime = MAX_TIME; <br>    m_dwStartCookie = 0; <br>} <br> <br> <br>// This guy will return one of the three StreamControlState's.  Here's what the caller <br>// should do for each one: <br>// <br>// STREAM_FLOWING:      Proceed as usual (render or pass the sample on) <br>// STREAM_DISCARDING:   Calculate the time 'til *pSampleStart and wait that long <br>//                      for the event handle (GetStreamEventHandle()).  If the <br>//                      wait expires, throw the sample away.  If the event <br>//fires, call me back, I've changed my mind. <br>//I use pSampleStart (not Stop) so that live sources don't <br>// block for the duration of their samples, since the clock <br>//will always read approximately pSampleStart when called <br> <br> <br>// All through this code, you'll notice the following rules: <br>// - When start and stop time are the same, it's as if start was first <br>// - An event is considered inside the sample when it's &gt;= sample start time <br>//   but &lt; sample stop time <br>// - if any part of the sample is supposed to be sent, we'll send the whole <br>//   thing since we don't break it into smaller pieces <br>// - If we skip over a start or stop without doing it, we still signal the event <br>//   and reset ourselves in case somebody's waiting for the event, and to make <br>//   sure we notice that the event is past and should be forgotten <br>// Here are the 19 cases that have to be handled (x=start o=stop &lt;--&gt;=sample): <br>// <br>// 1.xo&lt;--&gt;start then stop <br>// 2.ox&lt;--&gt;stop then start <br>// 3. x&lt;o-&gt;start <br>// 4. o&lt;x-&gt;stop then start <br>// 5. x&lt;--&gt;ostart <br>// 6. o&lt;--&gt;xstop <br>// 7.  &lt;x-&gt;ostart <br>// 8.  &lt;o-&gt;xno change <br>// 9.  &lt;xo&gt;start <br>// 10.  &lt;ox&gt;stop then start <br>// 11.  &lt;--&gt;xono change <br>// 12.  &lt;--&gt;oxno change <br>// 13. x&lt;--&gt;start <br>// 14.    &lt;x-&gt;start <br>// 15.    &lt;--&gt;xno change <br>// 16.   o&lt;--&gt;stop <br>// 17.  &lt;o-&gt;no change <br>// 18.  &lt;--&gt;ono change <br>// 19.    &lt;--&gt;no change <br> <br> <br>enum CBaseStreamControl::StreamControlState CBaseStreamControl::CheckSampleTimes <br>( const REFERENCE_TIME * pSampleStart, const REFERENCE_TIME * pSampleStop ) <br>{ <br>    CAutoLock lck(&amp;m_CritSec); <br> <br>    ASSERT(!m_bIsFlushing); <br>    ASSERT(pSampleStart &amp;&amp; pSampleStop); <br> <br>    // Don't ask me how I came up with the code below to handle all 19 cases <br>    // - DannyMi <br> <br>    if (m_tStopTime &gt;= *pSampleStart) <br>    { <br>        if (m_tStartTime &gt;= *pSampleStop) <br>    return m_StreamState;// cases  8 11 12 15 17 18 19 <br>if (m_tStopTime &lt; m_tStartTime) <br>    ExecuteStop();// case 10 <br>ExecuteStart();                         // cases 3 5 7 9 13 14 <br>return m_StreamState; <br>    } <br> <br>    if (m_tStartTime &gt;= *pSampleStop) <br>    { <br>        ExecuteStop();                          // cases 6 16 <br>        return m_StreamState; <br>    } <br> <br>    if (m_tStartTime &lt;= m_tStopTime) <br>    { <br>ExecuteStart(); <br>ExecuteStop(); <br>        return m_StreamState;// case 1 <br>    } <br>    else <br>    { <br>ExecuteStop(); <br>ExecuteStart(); <br>        return m_StreamState;// cases 2 4 <br>    } <br>} <br> <br> <br>enum CBaseStreamControl::StreamControlState CBaseStreamControl::CheckStreamState( IMediaSample * pSample ) <br>{ <br> <br>    REFERENCE_TIME rtBufferStart, rtBufferStop; <br>    const BOOL bNoBufferTimes = <br>              pSample == NULL || <br>              FAILED(pSample-&gt;GetTime(&amp;rtBufferStart, &amp;rtBufferStop)); <br> <br>    StreamControlState state; <br>    LONG lWait; <br> <br>    do <br>        { <br>     // something has to break out of the blocking <br>            if (m_bIsFlushing || m_FilterState == State_Stopped) <br>return STREAM_DISCARDING; <br> <br>            if (bNoBufferTimes) { <br>                //  Can't do anything until we get a time stamp <br>                state = m_StreamState; <br>                break; <br>            } else { <br>                state = CheckSampleTimes( &amp;rtBufferStart, &amp;rtBufferStop ); <br>                if (state == STREAM_FLOWING) <br>    break; <br> <br>// we aren't supposed to send this, but we've been <br>// told to send one more than we were supposed to <br>// (and the stop isn't still pending and we're streaming) <br>if (m_bStopSendExtra &amp;&amp; !m_bStopExtraSent &amp;&amp; <br>m_tStopTime == MAX_TIME &amp;&amp; <br>m_FilterState != State_Stopped) { <br>    m_bStopExtraSent = TRUE; <br>    DbgLog((LOG_TRACE,2,TEXT("%d sending an EXTRA frame"), <br>    m_dwStopCookie)); <br>    state = STREAM_FLOWING; <br>    break; <br>} <br>            } <br> <br>            // We're in discarding mode <br> <br>            // If we've no clock, discard as fast as we can <br>            if (!m_pRefClock) { <br>break; <br> <br>    // If we're paused, we can't discard in a timely manner because <br>    // there's no such thing as stream times.  We must block until <br>    // we run or stop, or we'll end up throwing the whole stream away <br>    // as quickly as possible <br>    } else if (m_FilterState == State_Paused) { <br>lWait = INFINITE; <br> <br>    } else { <br>        // wait until it's time for the sample until we say "discard" <br>        // ("discard in a timely fashion") <br>        REFERENCE_TIME rtNow; <br>                EXECUTE_ASSERT(SUCCEEDED(m_pRefClock-&gt;GetTime(&amp;rtNow))); <br>                rtNow -= m_tRunStart;   // Into relative ref-time <br>                lWait = LONG((rtBufferStart - rtNow)/10000); // 100ns -&gt; ms <br>                if (lWait &lt; 10) break; // Not worth waiting - discard early <br>    } <br> <br>    } while(WaitForSingleObject(GetStreamEventHandle(), lWait) != WAIT_TIMEOUT); <br> <br>    return state; <br>} <br> <br> <br>void CBaseStreamControl::NotifyFilterState( FILTER_STATE new_state, REFERENCE_TIME tStart ) <br>{ <br>    CAutoLock lck(&amp;m_CritSec); <br> <br>    // or we will get confused <br>    if (m_FilterState == new_state) <br>return; <br> <br>    switch (new_state) <br>    { <br>        case State_Stopped: <br> <br>            DbgLog((LOG_TRACE,2,TEXT("Filter is STOPPED"))); <br> <br>    // execute any pending starts and stops in the right order, <br>    // to make sure all notifications get sent, and we end up <br>    // in the right state to begin next time (??? why not?) <br> <br>    if (m_tStartTime != MAX_TIME &amp;&amp; m_tStopTime == MAX_TIME) { <br>ExecuteStart(); <br>    } else if (m_tStopTime != MAX_TIME &amp;&amp; m_tStartTime == MAX_TIME) { <br>ExecuteStop(); <br>    } else if (m_tStopTime != MAX_TIME &amp;&amp; m_tStartTime != MAX_TIME) { <br>if (m_tStartTime &lt;= m_tStopTime) { <br>    ExecuteStart(); <br>    ExecuteStop(); <br>} else { <br>    ExecuteStop(); <br>    ExecuteStart(); <br>} <br>    } <br>    // always start off flowing when the graph starts streaming <br>    // unless told otherwise <br>    m_StreamState = STREAM_FLOWING; <br>            m_FilterState = new_state; <br>            break; <br> <br>        case State_Running: <br> <br>            DbgLog((LOG_TRACE,2,TEXT("Filter is RUNNING"))); <br> <br>            m_tRunStart = tStart; <br>            // fall-through <br> <br>        default: // case State_Paused: <br>            m_FilterState = new_state; <br>    } <br>    // unblock! <br>    m_StreamEvent.Set(); <br>} <br> <br> <br>void CBaseStreamControl::Flushing(BOOL bInProgress) <br>{ <br>    CAutoLock lck(&amp;m_CritSec); <br>    m_bIsFlushing = bInProgress; <br>    m_StreamEvent.Set(); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
