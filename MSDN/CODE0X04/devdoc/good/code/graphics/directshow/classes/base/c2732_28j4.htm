<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>COMBASE.H</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2740"></a>COMBASE.H</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>// Base class hierachy for creating COM objects, December 1994 <br> <br>/* <br> <br>a. Derive your COM object from CUnknown <br> <br>b. Make a static CreateInstance function that takes an LPUNKNOWN, an HRESULT * <br>   and a TCHAR *. The LPUNKNOWN defines the object to delegate IUnknown calls <br>   to. The HRESULT * allows error codes to be passed around constructors and <br>   the TCHAR * is a descriptive name that can be printed on the debugger. <br> <br>   It is important that constructors only change the HRESULT * if they have <br>   to set an ERROR code, if it was successful then leave it alone or you may <br>   overwrite an error code from an object previously created. <br> <br>   When you call a constructor the descriptive name should be in static store <br>   as we do not copy the string. To stop large amounts of memory being used <br>   in retail builds by all these static strings use the NAME macro, <br> <br>   CMyFilter = new CImplFilter(NAME("My filter"),pUnknown,phr); <br>   if (FAILED(hr)) { <br>       return hr; <br>   } <br> <br>   In retail builds NAME(_x_) compiles to NULL, the base CBaseObject class <br>   knows not to do anything with objects that don't have a name. <br> <br>c. Have a constructor for your object that passes the LPUNKNOWN, HRESULT * and <br>   TCHAR * to the CUnknown constructor. You can set the HRESULT if you have an <br>   error, or just simply pass it through to the constructor. <br> <br>   The object creation will fail in the class factory if the HRESULT indicates <br>   an error (ie FAILED(HRESULT) == TRUE) <br> <br>d. Create a FactoryTemplate with your object's class id and CreateInstance <br>   function. <br> <br>Then (for each interface) either <br> <br>Multiple inheritance <br> <br>1. Also derive it from ISomeInterface <br>2. Include DECLARE_IUNKNOWN in your class definition to declare <br>   implementations of QueryInterface, AddRef and Release that <br>   call the outer unknown <br>3. Override NonDelegatingQueryInterface to expose ISomeInterface by <br>   code something like <br> <br>     if (riid == IID_ISomeInterface) { <br>         return GetInterface((ISomeInterface *) this, ppv); <br>     } else { <br>         return CUnknown::NonDelegatingQueryInterface(riid, ppv); <br>     } <br> <br>4. Declare and implement the member functions of ISomeInterface. <br> <br>or: Nested interfaces <br> <br>1. Declare a class derived from CUnknown <br>2. Include DECLARE_IUNKNOWN in your class definition <br>3. Override NonDelegatingQueryInterface to expose ISomeInterface by <br>   code something like <br> <br>     if (riid == IID_ISomeInterface) { <br>         return GetInterface((ISomeInterface *) this, ppv); <br>     } else { <br>         return CUnknown::NonDelegatingQueryInterface(riid, ppv); <br>     } <br> <br>4. Implement the member functions of ISomeInterface. Use GetOwner() to <br>   access the COM object class. <br> <br>And in your COM object class: <br> <br>5. Make the nested class a friend of the COM object class, and declare <br>   an instance of the nested class as a member of the COM object class. <br> <br>   NOTE that because you must always pass the outer unknown and an hResult <br>   to the CUnknown constructor you cannot use a default constructor, in <br>   other words you will have to make the member variable a pointer to the <br>   class and make a NEW call in your constructor to actually create it. <br> <br>6. override the NonDelegatingQueryInterface with code like this: <br> <br>     if (riid == IID_ISomeInterface) { <br>         return m_pImplFilter-&gt; <br>            NonDelegatingQueryInterface(IID_ISomeInterface, ppv); <br>     } else { <br>         return CUnknown::NonDelegatingQueryInterface(riid, ppv); <br>     } <br> <br>You can have mixed classes which support some interfaces via multiple <br>inheritance and some via nested classes <br> <br>*/ <br> <br>#ifndef __COMBASE__ <br>#define __COMBASE__ <br> <br>// Filter Setup data structures no defined in axextend.idl <br> <br>typedef REGPINTYPES <br>AMOVIESETUP_MEDIATYPE, * PAMOVIESETUP_MEDIATYPE, * FAR LPAMOVIESETUP_MEDIATYPE; <br> <br>typedef REGFILTERPINS <br>AMOVIESETUP_PIN, * PAMOVIESETUP_PIN, * FAR LPAMOVIESETUP_PIN; <br> <br>typedef struct _AMOVIESETUP_FILTER <br>{ <br>  const CLSID * clsID; <br>  const WCHAR * strName; <br>  DWORD      dwMerit; <br>  UINT       nPins; <br>  const AMOVIESETUP_PIN * lpPin; <br>} <br>AMOVIESETUP_FILTER, * PAMOVIESETUP_FILTER, * FAR LPAMOVIESETUP_FILTER; <br> <br>/* The DLLENTRY module initialises the module handle on loading */ <br> <br>extern HINSTANCE g_hInst; <br> <br>/* On DLL load remember which platform we are running on */ <br> <br>extern DWORD g_amPlatform; <br>extern OSVERSIONINFO g_osInfo;     // Filled in by GetVersionEx <br> <br>/* Version of IUnknown that is renamed to allow a class to support both <br>   non delegating and delegating IUnknowns in the same COM object */ <br> <br>#ifndef INONDELEGATINGUNKNOWN_DEFINED <br>DECLARE_INTERFACE(INonDelegatingUnknown) <br>{ <br>    STDMETHOD(NonDelegatingQueryInterface) (THIS_ REFIID, LPVOID *) PURE; <br>    STDMETHOD_(ULONG, NonDelegatingAddRef)(THIS) PURE; <br>    STDMETHOD_(ULONG, NonDelegatingRelease)(THIS) PURE; <br>}; <br>#define INONDELEGATINGUNKNOWN_DEFINED <br>#endif <br> <br>typedef INonDelegatingUnknown *PNDUNKNOWN; <br> <br> <br>/* This is the base object class that supports active object counting. As <br>   part of the debug facilities we trace every time a C++ object is created <br>   or destroyed. The name of the object has to be passed up through the class <br>   derivation list during construction as you cannot call virtual functions <br>   in the constructor. The downside of all this is that every single object <br>   constructor has to take an object name parameter that describes it */ <br> <br>class CBaseObject <br>{ <br> <br>private: <br> <br>    // Disable the copy constructor and assignment by default so you will get <br>    //   compiler errors instead of unexpected behaviour if you pass objects <br>    //   by value or assign objects. <br>    CBaseObject(const CBaseObject&amp; objectSrc);          // no implementation <br>    void operator=(const CBaseObject&amp; objectSrc);       // no implementation <br> <br>private: <br>    static LONG m_cObjects;     /* Total number of objects active */ <br> <br>protected: <br>#ifdef DEBUG <br>    DWORD m_dwCookie;           /* Cookie identifying this object */ <br>#endif <br> <br> <br>public: <br> <br>    /* These increment and decrement the number of active objects */ <br> <br>    CBaseObject(const TCHAR *pName); <br>    ~CBaseObject(); <br> <br>    /* Call this to find if there are any CUnknown derived objects active */ <br> <br>    static LONG ObjectsActive() { <br>        return m_cObjects; <br>    }; <br>}; <br> <br> <br>/* An object that supports one or more COM interfaces will be based on <br>   this class. It supports counting of total objects for DLLCanUnloadNow <br>   support, and an implementation of the core non delegating IUnknown */ <br> <br>class AM_NOVTABLE CUnknown : public INonDelegatingUnknown, <br>                 public CBaseObject <br>{ <br>private: <br>    const LPUNKNOWN m_pUnknown; /* Owner of this object */ <br> <br>protected:                      /* So we can override NonDelegatingRelease() */ <br>    volatile LONG m_cRef;       /* Number of reference counts */ <br> <br>public: <br> <br>    CUnknown(const TCHAR *pName, LPUNKNOWN pUnk); <br>    virtual ~CUnknown() {}; <br> <br>    // This is redundant, just use the other constructor <br>    //   as we never touch the HRESULT in this anyway <br>    CUnknown(TCHAR *pName, LPUNKNOWN pUnk,HRESULT *phr); <br> <br>    /* Return the owner of this object */ <br> <br>    LPUNKNOWN GetOwner() const { <br>        return m_pUnknown; <br>    }; <br> <br>    /* Called from the class factory to create a new instance, it is <br>       pure virtual so it must be overriden in your derived class */ <br> <br>    /* static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *) */ <br> <br>    /* Non delegating unknown implementation */ <br> <br>    STDMETHODIMP NonDelegatingQueryInterface(REFIID, void **); <br>    STDMETHODIMP_(ULONG) NonDelegatingAddRef(); <br>    STDMETHODIMP_(ULONG) NonDelegatingRelease(); <br>}; <br> <br>/* Return an interface pointer to a requesting client <br>   performing a thread safe AddRef as necessary */ <br> <br>STDAPI GetInterface(LPUNKNOWN pUnk, void **ppv); <br> <br>/* The standard InterlockedXXX functions won't take volatiles */ <br>static inline LONG WINAPI InterlockedIncrement( volatile LONG * plong ) <br>{ return InterlockedIncrement( const_cast&lt;LONG*&gt;( plong ) ); } <br> <br>static inline LONG WINAPI InterlockedDecrement( volatile LONG * plong ) <br>{ return InterlockedDecrement( const_cast&lt;LONG*&gt;( plong ) ); } <br> <br>static inline LONG InterlockedExchange( volatile LONG * plong, LONG new_value ) <br>{ return InterlockedExchange( const_cast&lt;LONG*&gt;( plong ), new_value ); } <br> <br> <br>/* A function that can create a new COM object */ <br> <br>typedef CUnknown *(CALLBACK *LPFNNewCOMObject)(LPUNKNOWN pUnkOuter, HRESULT *phr); <br> <br>/*  A function (can be NULL) which is called from the DLL entrypoint <br>    routine for each factory template: <br> <br>    bLoading - TRUE on DLL load, FALSE on DLL unload <br>    rclsid   - the m_ClsID of the entry <br>*/ <br>typedef void (CALLBACK *LPFNInitRoutine)(BOOL bLoading, const CLSID *rclsid); <br> <br>/* Create one of these per object class in an array so that <br>   the default class factory code can create new instances */ <br> <br>class CFactoryTemplate { <br> <br>public: <br> <br>    const WCHAR *              m_Name; <br>    const CLSID *              m_ClsID; <br>    LPFNNewCOMObject           m_lpfnNew; <br>    LPFNInitRoutine            m_lpfnInit; <br>    const AMOVIESETUP_FILTER * m_pAMovieSetup_Filter; <br> <br>    BOOL IsClassID(REFCLSID rclsid) const { <br>        return (IsEqualCLSID(*m_ClsID,rclsid)); <br>    }; <br> <br>    CUnknown *CreateInstance(LPUNKNOWN pUnk, HRESULT *phr) const { <br>        CheckPointer(phr,NULL); <br>        return m_lpfnNew(pUnk, phr); <br>    }; <br>}; <br> <br> <br>/* You must override the (pure virtual) NonDelegatingQueryInterface to return <br>   interface pointers (using GetInterface) to the interfaces your derived <br>   class supports (the default implementation only supports IUnknown) */ <br> <br>#define DECLARE_IUNKNOWN                                        \ <br>    STDMETHODIMP QueryInterface(REFIID riid, void **ppv) {      \ <br>        return GetOwner()-&gt;QueryInterface(riid,ppv);            \ <br>    };                                                          \ <br>    STDMETHODIMP_(ULONG) AddRef() {                             \ <br>        return GetOwner()-&gt;AddRef();                            \ <br>    };                                                          \ <br>    STDMETHODIMP_(ULONG) Release() {                            \ <br>        return GetOwner()-&gt;Release();                           \ <br>    }; <br> <br> <br> <br>HINSTANCELoadOLEAut32(); <br> <br> <br>#endif /* __COMBASE__ */ <br> <br> <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
