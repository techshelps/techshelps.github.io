<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SCHEDULE.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2766"></a>SCHEDULE.CPP</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1996 - 1997 Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br>//  SCHEDULE.CPP <br> <br>#include &lt;streams.h&gt; <br> <br>// DbgLog values (all on LOG_TIMING): <br>// <br>// 2 for schedulting, firing and shunting of events <br>// 3 for wait delays and wake-up times of event thread <br>// 4 for details of whats on the list when the thread awakes <br> <br>/* Construct &amp; destructors */ <br> <br>CAMSchedule::CAMSchedule( HANDLE ev ) <br>: CBaseObject(TEXT("CAMSchedule")) <br>, head(&amp;z, 0), z(0, MAX_TIME) <br>, m_dwNextCookie(0), m_dwAdviseCount(0) <br>, m_pAdviseCache(0), m_dwCacheCount(0) <br>, m_ev( ev ) <br>{ <br>    head.m_dwAdviseCookie = z.m_dwAdviseCookie = 0; <br>} <br> <br>CAMSchedule::~CAMSchedule() <br>{ <br>    m_Serialize.Lock(); <br> <br>    // Delete cache <br>    CAdvisePacket * p = m_pAdviseCache; <br>    while (p) <br>    { <br>        CAdvisePacket *const p_next = p-&gt;m_next; <br>        delete p; <br>        p = p_next; <br>    } <br> <br>    ASSERT( m_dwAdviseCount == 0 ); <br>    // Better to be safe than sorry <br>    if ( m_dwAdviseCount &gt; 0 ) <br>    { <br>        DumpLinkedList(); <br>        while ( !head.m_next-&gt;IsZ() ) <br>        { <br>            head.DeleteNext(); <br>            --m_dwAdviseCount; <br>        } <br>    } <br> <br>    // If, in the debug version, we assert twice, it means, not only <br>    // did we have left over advises, but we have also let m_dwAdviseCount <br>    // get out of sync. with the number of advises actually on the list. <br>    ASSERT( m_dwAdviseCount == 0 ); <br> <br>    m_Serialize.Unlock(); <br>} <br> <br>/* Public methods */ <br> <br>DWORD CAMSchedule::GetAdviseCount() <br>{ <br>    // No need to lock, m_dwAdviseCount is 32bits &amp; declared volatile <br>    return m_dwAdviseCount; <br>} <br> <br>REFERENCE_TIME CAMSchedule::GetNextAdviseTime() <br>{ <br>    CAutoLock lck(&amp;m_Serialize); // Need to stop the linked list from changing <br>    return head.m_next-&gt;m_rtEventTime; <br>} <br> <br>DWORD CAMSchedule::AddAdvisePacket <br>( const REFERENCE_TIME &amp; time1 <br>, const REFERENCE_TIME &amp; time2 <br>, HANDLE h, BOOL periodic <br>) <br>{ <br>    // Since we use MAX_TIME as a sentry, we can't afford to <br>    // schedule a notification at MAX_TIME <br>    ASSERT( time1 &lt; MAX_TIME ); <br>    DWORD Result; <br>    CAdvisePacket * p; <br> <br>    m_Serialize.Lock(); <br> <br>    if (m_pAdviseCache) <br>    { <br>        p = m_pAdviseCache; <br>        m_pAdviseCache = p-&gt;m_next; <br>        --m_dwCacheCount; <br>    } <br>    else <br>    { <br>        p = new CAdvisePacket(); <br>    } <br>    if (p) <br>    { <br>        p-&gt;m_rtEventTime = time1; p-&gt;m_rtPeriod = time2; <br>        p-&gt;m_hNotify = h; p-&gt;m_bPeriodic = periodic; <br>        Result = AddAdvisePacket( p ); <br>    } <br>    else Result = 0; <br> <br>    m_Serialize.Unlock(); <br> <br>    return Result; <br>} <br> <br>HRESULT CAMSchedule::Unadvise(DWORD dwAdviseCookie) <br>{ <br>    HRESULT hr = S_FALSE; <br>    CAdvisePacket * p_prev = &amp;head; <br>    CAdvisePacket * p_n; <br>    m_Serialize.Lock(); <br>    while ( p_n = p_prev-&gt;Next() ) // The Next() method returns NULL when it hits z <br>    { <br>        if ( p_n-&gt;m_dwAdviseCookie == dwAdviseCookie ) <br>        { <br>            Delete( p_prev-&gt;RemoveNext() ); <br>            --m_dwAdviseCount; <br>            hr = S_OK; <br>    // Having found one cookie that matches, there should be no more <br>            #ifdef DEBUG <br>       while (p_n = p_prev-&gt;Next()) <br>               { <br>                   ASSERT(p_n-&gt;m_dwAdviseCookie != dwAdviseCookie); <br>                   p_prev = p_n; <br>               } <br>            #endif <br>            break; <br>        } <br>        p_prev = p_n; <br>    }; <br>    m_Serialize.Unlock(); <br>    return hr; <br>} <br> <br>REFERENCE_TIME CAMSchedule::Advise( const REFERENCE_TIME &amp; rtTime ) <br>{ <br>    REFERENCE_TIME  rtNextTime; <br>    CAdvisePacket * pAdvise; <br> <br>    DbgLog((LOG_TIMING, 2, <br>        TEXT("CAMSchedule::Advise( %lu ms )"), ULONG(rtTime / (UNITS / MILLISECONDS)))); <br> <br>    m_Serialize.Lock(); <br> <br>    #ifdef DEBUG <br>        if (DbgCheckModuleLevel(LOG_TIMING, 4)) DumpLinkedList(); <br>    #endif <br> <br>    REFERENCE_TIME rtLate, rtPrevLate = MAX_TIME; <br>    while ( (rtLate = rtTime - (rtNextTime = (pAdvise=head.m_next)-&gt;m_rtEventTime)) &gt;= 0 ) <br>    { <br>        ASSERT(pAdvise-&gt;m_dwAdviseCookie); // If this is zero, its the head or the tail!! <br>        ASSERT( rtLate &lt;= rtPrevLate );    // If we dispatch several, the later ones should <br>                                           // not be as late as the earlier ones.  The ASSERT <br>                                           // therefore is checking that our sheduling logic <br>                                           // placed the packet in the right place. <br>rtPrevLate = rtLate; <br>        rtLate /= 10000; <br>        DbgLog((LOG_TIMING, 2, <br>            TEXT("CAMSchedule::Advise() Dispatching advise %lu for time stamp: %lu ms (%lu ms late)"), <br>      pAdvise-&gt;m_dwAdviseCookie, ULONG(pAdvise-&gt;m_rtEventTime / (UNITS / MILLISECONDS)), ULONG(rtLate) )); <br> <br>        ASSERT(pAdvise-&gt;m_hNotify != INVALID_HANDLE_VALUE); <br> <br>        if (pAdvise-&gt;m_bPeriodic == TRUE) <br>        { <br>            EXECUTE_ASSERT(ReleaseSemaphore(pAdvise-&gt;m_hNotify,1,NULL)); <br>            pAdvise-&gt;m_rtEventTime += pAdvise-&gt;m_rtPeriod; <br>            ShuntHead(); <br>        } <br>        else <br>        { <br>            ASSERT( pAdvise-&gt;m_bPeriodic == FALSE ); <br>            EXECUTE_ASSERT(SetEvent(pAdvise-&gt;m_hNotify)); <br>            --m_dwAdviseCount; <br>            Delete( head.RemoveNext() ); <br>        } <br> <br>    } <br> <br>    DbgLog((LOG_TIMING, 3, <br>            TEXT("CAMSchedule::Advise() Next time stamp: %lu ms, for advise %lu."), <br>            DWORD(rtNextTime / (UNITS / MILLISECONDS)), pAdvise-&gt;m_dwAdviseCookie )); <br> <br>    m_Serialize.Unlock(); <br> <br>    return rtNextTime; <br>} <br> <br>/* Private methods */ <br> <br>DWORD CAMSchedule::AddAdvisePacket( CAdvisePacket * pPacket ) <br>{ <br>    ASSERT(pPacket-&gt;m_rtEventTime &gt;= 0 &amp;&amp; pPacket-&gt;m_rtEventTime &lt; MAX_TIME); <br>    ASSERT(CritCheckIn(&amp;m_Serialize)); <br> <br>    CAdvisePacket * p_prev = &amp;head; <br>    CAdvisePacket * p_n; <br> <br>    const DWORD Result = pPacket-&gt;m_dwAdviseCookie = ++m_dwNextCookie; <br>    // This relies on the fact that z is a sentry with a maximal m_rtEventTime <br>    for(;;p_prev = p_n) <br>    { <br>        p_n = p_prev-&gt;m_next; <br>        if ( p_n-&gt;m_rtEventTime &gt;= pPacket-&gt;m_rtEventTime ) break; <br>    } <br>    p_prev-&gt;InsertAfter( pPacket ); <br>    ++m_dwAdviseCount; <br> <br>    DbgLog((LOG_TIMING, 2, TEXT("Added advise %lu, for thread 0x%02X, scheduled at %lu"), <br>    pPacket-&gt;m_dwAdviseCookie, GetCurrentThreadId(), (pPacket-&gt;m_rtEventTime / (UNITS / MILLISECONDS)) )); <br> <br>    // If packet added at the head, then clock needs to re-evaluate wait time. <br>    if ( p_prev == &amp;head ) SetEvent( m_ev ); <br> <br>    return Result; <br>} <br> <br>void CAMSchedule::Delete( CAdvisePacket * pPacket ) <br>{ <br>    if ( m_dwCacheCount &gt;= dwCacheMax ) delete pPacket; <br>    else <br>    { <br>        m_Serialize.Lock(); <br>        pPacket-&gt;m_next = m_pAdviseCache; <br>        m_pAdviseCache = pPacket; <br>        ++m_dwCacheCount; <br>        m_Serialize.Unlock(); <br>    } <br>} <br> <br> <br>// Takes the head of the list &amp; repositions it <br>void CAMSchedule::ShuntHead() <br>{ <br>    CAdvisePacket * p_prev = &amp;head; <br>    CAdvisePacket * p_n; <br> <br>    m_Serialize.Lock(); <br>    CAdvisePacket *const pPacket = head.m_next; <br> <br>    // This will catch both an empty list, <br>    // and if somehow a MAX_TIME time gets into the list <br>    // (which would also break this method). <br>    ASSERT( pPacket-&gt;m_rtEventTime &lt; MAX_TIME ); <br> <br>    // This relies on the fact that z is a sentry with a maximal m_rtEventTime <br>    for(;;p_prev = p_n) <br>    { <br>        p_n = p_prev-&gt;m_next; <br>        if ( p_n-&gt;m_rtEventTime &gt; pPacket-&gt;m_rtEventTime ) break; <br>    } <br>    // If p_prev == pPacket then we're already in the right place <br>    if (p_prev != pPacket) <br>    { <br>        head.m_next = pPacket-&gt;m_next; <br>        (p_prev-&gt;m_next = pPacket)-&gt;m_next = p_n; <br>    } <br>    #ifdef DEBUG <br>        DbgLog((LOG_TIMING, 2, TEXT("Periodic advise %lu, shunted to %lu"), <br>        pPacket-&gt;m_dwAdviseCookie, (pPacket-&gt;m_rtEventTime / (UNITS / MILLISECONDS)) )); <br>    #endif <br>    m_Serialize.Unlock(); <br>} <br> <br> <br>#ifdef DEBUG <br>void CAMSchedule::DumpLinkedList() <br>{ <br>    m_Serialize.Lock(); <br>    int i=0; <br>    DbgLog((LOG_TIMING, 1, TEXT("CAMSchedule::DumpLinkedList() this = %08X"), DWORD(this) )); <br>    for ( CAdvisePacket * p = &amp;head <br>        ; p <br>        ; p = p-&gt;m_next         , i++ <br>        ) <br>    { <br>        DbgLog((LOG_TIMING, 1, TEXT("Advise List # %lu, Cookie %d,  RefTime %lu"), <br>            i, <br>    p-&gt;m_dwAdviseCookie, <br>    p-&gt;m_rtEventTime / (UNITS / MILLISECONDS) <br>            )); <br>    } <br>    m_Serialize.Unlock(); <br>} <br>#endif </code></pre>
<p>&nbsp;</p></body>
</HTML>
