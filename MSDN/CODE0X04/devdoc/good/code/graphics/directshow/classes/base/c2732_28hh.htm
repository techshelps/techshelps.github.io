<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>AMFILTER.H</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2735"></a>AMFILTER.H</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>// Base class hierarchy for streams architecture, December 1994 <br> <br>#ifndef __FILTER__ <br>#define __FILTER__ <br> <br>/* The following classes are declared in this header: */ <br> <br>class CBaseMediaFilter;     // IMediaFilter support <br>class CBaseFilter;          // IBaseFilter,IMediaFilter support <br>class CBasePin;             // Abstract base class for IPin interface <br>class CEnumPins;            // Enumerate input and output pins <br>class CEnumMediaTypes;      // Enumerate the pin's preferred formats <br>class CBaseOutputPin;       // Adds data provider member functions <br>class CBaseInputPin;        // Implements IMemInputPin interface <br>class CMediaSample;         // Basic transport unit for IMemInputPin <br>class CBaseAllocator;       // General list guff for most allocators <br>class CMemAllocator;        // Implements memory buffer allocation <br> <br> <br>//===================================================================== <br>//===================================================================== <br>// <br>// QueryFilterInfo and QueryPinInfo AddRef the interface pointers <br>// they return.  You can use the macro below to release the interface. <br>// <br>//===================================================================== <br>//===================================================================== <br> <br>#define QueryFilterInfoReleaseGraph(fi) if ((fi).pGraph) (fi).pGraph-&gt;Release(); <br> <br>#define QueryPinInfoReleaseFilter(pi) if ((pi).pFilter) (pi).pFilter-&gt;Release(); <br> <br>//===================================================================== <br>//===================================================================== <br>// Defines CBaseMediaFilter <br>// <br>// Abstract base class implementing IMediaFilter. <br>// <br>// Typically you will derive your filter from CBaseFilter rather than <br>// this,  unless you are implementing an object such as a plug-in <br>// distributor that needs to support IMediaFilter but not IBaseFilter. <br>// <br>// Note that IMediaFilter is derived from IPersist to allow query of <br>// class id. <br>//===================================================================== <br>//===================================================================== <br> <br>class AM_NOVTABLE CBaseMediaFilter : public CUnknown, <br>                                     public IMediaFilter <br>{ <br> <br>protected: <br> <br>    FILTER_STATE    m_State;            // current state: running, paused <br>    IReferenceClock *m_pClock;          // this filter's reference clock <br>    // note: all filters in a filter graph use the same clock <br> <br>    // offset from stream time to reference time <br>    CRefTime        m_tStart; <br> <br>    CLSID    m_clsid;            // This filters clsid <br>                                        // used for serialization <br>    CCritSec        *m_pLock;           // Object we use for locking <br> <br>public: <br> <br>    CBaseMediaFilter( <br>        const TCHAR     *pName, <br>        LPUNKNOWN pUnk, <br>        CCritSec  *pLock, <br>REFCLSID   clsid); <br> <br>    virtual ~CBaseMediaFilter(); <br> <br>    DECLARE_IUNKNOWN <br> <br>    // override this to say what interfaces we support where <br>    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv); <br> <br>    // <br>    // --- IPersist method --- <br>    // <br> <br>    STDMETHODIMP GetClassID(CLSID *pClsID); <br> <br>    // --- IMediaFilter methods --- <br> <br>    STDMETHODIMP GetState(DWORD dwMSecs, FILTER_STATE *State); <br> <br>    STDMETHODIMP SetSyncSource(IReferenceClock *pClock); <br> <br>    STDMETHODIMP GetSyncSource(IReferenceClock **pClock); <br> <br>    // default implementation of Stop and Pause just record the <br>    // state. Override to activate or de-activate your filter. <br>    // Note that Run when called from Stopped state will call Pause <br>    // to ensure activation, so if you are a source or transform <br>    // you will probably not need to override Run. <br>    STDMETHODIMP Stop(); <br>    STDMETHODIMP Pause(); <br> <br> <br>    // the start parameter is the difference to be added to the <br>    // sample's stream time to get the reference time for <br>    // its presentation <br>    STDMETHODIMP Run(REFERENCE_TIME tStart); <br> <br>    // --- helper methods --- <br> <br>    // return the current stream time - ie find out what <br>    // stream time should be appearing now <br>    virtual HRESULT StreamTime(CRefTime&amp; rtStream); <br> <br>    // Is the filter currently active? (running or paused) <br>    BOOL IsActive() { <br>        CAutoLock cObjectLock(m_pLock); <br>        return ((m_State == State_Paused) || (m_State == State_Running)); <br>    }; <br>}; <br> <br>//===================================================================== <br>//===================================================================== <br>// Defines CBaseFilter <br>// <br>// An abstract class providing basic IBaseFilter support for pin <br>// enumeration and filter information reading. <br>// <br>// We cannot derive from CBaseMediaFilter since methods in IMediaFilter <br>// are also in IBaseFilter and would be ambiguous. Since much of the code <br>// assumes that they derive from a class that has m_State and other state <br>// directly available, we duplicate code from CBaseMediaFilter rather than <br>// having a member variable. <br>// <br>// Derive your filter from this, or from a derived object such as <br>// CTransformFilter. <br>//===================================================================== <br>//===================================================================== <br> <br> <br>class AM_NOVTABLE CBaseFilter : public CUnknown,        // Handles an IUnknown <br>                    public IBaseFilter,     // The Filter Interface <br>                    public IAMovieSetup     // For un/registration <br>{ <br> <br>friend class CBasePin; <br> <br>protected: <br>    FILTER_STATE    m_State;            // current state: running, paused <br>    IReferenceClock *m_pClock;          // this graph's ref clock <br>    CRefTime        m_tStart;           // offset from stream time to reference time <br>    CLSID    m_clsid;            // This filters clsid <br>                                        // used for serialization <br>    CCritSec        *m_pLock;           // Object we use for locking <br> <br>    WCHAR           *m_pName;           // Full filter name <br>    IFilterGraph    *m_pGraph;          // Graph we belong to <br>    IMediaEventSink *m_pSink;           // Called with notify events <br>    LONG            m_PinVersion;       // Current pin version <br> <br>public: <br> <br>    CBaseFilter( <br>        const TCHAR *pName,     // Object description <br>        LPUNKNOWN pUnk,         // IUnknown of delegating object <br>        CCritSec  *pLock,       // Object who maintains lock <br>REFCLSID   clsid);      // The clsid to be used to serialize this filter <br> <br>    CBaseFilter( <br>        TCHAR     *pName,       // Object description <br>        LPUNKNOWN pUnk,         // IUnknown of delegating object <br>        CCritSec  *pLock,       // Object who maintains lock <br>REFCLSID   clsid,       // The clsid to be used to serialize this filter <br>        HRESULT   *phr);        // General OLE return code <br> <br>    ~CBaseFilter(); <br> <br>    DECLARE_IUNKNOWN <br> <br>    // override this to say what interfaces we support where <br>    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv); <br>#ifdef DEBUG <br>    STDMETHODIMP_(ULONG) NonDelegatingRelease(); <br>#endif <br> <br>    // <br>    // --- IPersist method --- <br>    // <br> <br>    STDMETHODIMP GetClassID(CLSID *pClsID); <br> <br>    // --- IMediaFilter methods --- <br> <br>    STDMETHODIMP GetState(DWORD dwMSecs, FILTER_STATE *State); <br> <br>    STDMETHODIMP SetSyncSource(IReferenceClock *pClock); <br> <br>    STDMETHODIMP GetSyncSource(IReferenceClock **pClock); <br> <br> <br>    // override Stop and Pause so we can activate the pins. <br>    // Note that Run will call Pause first if activation needed. <br>    // Override these if you want to activate your filter rather than <br>    // your pins. <br>    STDMETHODIMP Stop(); <br>    STDMETHODIMP Pause(); <br> <br>    // the start parameter is the difference to be added to the <br>    // sample's stream time to get the reference time for <br>    // its presentation <br>    STDMETHODIMP Run(REFERENCE_TIME tStart); <br> <br>    // --- helper methods --- <br> <br>    // return the current stream time - ie find out what <br>    // stream time should be appearing now <br>    virtual HRESULT StreamTime(CRefTime&amp; rtStream); <br> <br>    // Is the filter currently active? <br>    BOOL IsActive() { <br>        CAutoLock cObjectLock(m_pLock); <br>        return ((m_State == State_Paused) || (m_State == State_Running)); <br>    }; <br> <br>    // Is this filter stopped (without locking) <br>    BOOL IsStopped() { <br>        return (m_State == State_Stopped); <br>    }; <br> <br>    // <br>    // --- IBaseFilter methods --- <br>    // <br> <br>    // pin enumerator <br>    STDMETHODIMP EnumPins( <br>                    IEnumPins ** ppEnum); <br> <br> <br>    // default behaviour of FindPin assumes pin ids are their names <br>    STDMETHODIMP FindPin( <br>        LPCWSTR Id, <br>        IPin ** ppPin <br>    ); <br> <br>    STDMETHODIMP QueryFilterInfo( <br>                    FILTER_INFO * pInfo); <br> <br>    STDMETHODIMP JoinFilterGraph( <br>                    IFilterGraph * pGraph, <br>                    LPCWSTR pName); <br> <br>    // return a Vendor information string. Optional - may return E_NOTIMPL. <br>    // memory returned should be freed using CoTaskMemFree <br>    // default implementation returns E_NOTIMPL <br>    STDMETHODIMP QueryVendorInfo( <br>                    LPWSTR* pVendorInfo <br>            ); <br> <br>    // --- helper methods --- <br> <br>    // send an event notification to the filter graph if we know about it. <br>    // returns S_OK if delivered, S_FALSE if the filter graph does not sink <br>    // events, or an error otherwise. <br>    HRESULT NotifyEvent( <br>        long EventCode, <br>        long EventParam1, <br>        long EventParam2); <br> <br>    // return the filter graph we belong to <br>    IFilterGraph *GetFilterGraph() { <br>        return m_pGraph; <br>    } <br> <br>    // Request reconnect <br>    // pPin is the pin to reconnect <br>    // pmt is the type to reconnect with - can be NULL <br>    // Calls ReconnectEx on the filter graph <br>    HRESULT ReconnectPin(IPin *pPin, AM_MEDIA_TYPE const *pmt); <br> <br>    // find out the current pin version (used by enumerators) <br>    virtual LONG GetPinVersion(); <br>    void IncrementPinVersion(); <br> <br>    // you need to supply these to access the pins from the enumerator <br>    // and for default Stop and Pause/Run activation. <br>    virtual int GetPinCount() PURE; <br>    virtual CBasePin *GetPin(int n) PURE; <br> <br>    // --- IAMovieSetup methods --- <br> <br>    STDMETHODIMP Register();    // ask filter to register itself <br>    STDMETHODIMP Unregister();  // and unregister itself <br> <br>    // --- setup helper methods --- <br>    // (override to return filters setup data) <br> <br>    virtual LPAMOVIESETUP_FILTER GetSetupData(){ return NULL; } <br> <br>}; <br> <br> <br>//===================================================================== <br>//===================================================================== <br>// Defines CBasePin <br>// <br>// Abstract class that supports the basics of IPin <br>//===================================================================== <br>//===================================================================== <br> <br>class  AM_NOVTABLE CBasePin : public CUnknown, public IPin, public IQualityControl <br>{ <br> <br>protected: <br> <br>    WCHAR *         m_pName;        // This pin's name <br>    IPin            *m_Connected;               // Pin we have connected to <br>    CMediaType      m_mt;                       // Media type of connection <br>    PIN_DIRECTION   m_dir;                      // Direction of this pin <br>    CCritSec        *m_pLock;                   // Object we use for locking <br>    BOOL            m_bRunTimeError;            // Run time error generated <br>    CBaseFilter    *m_pFilter;                  // Filter we were created by <br>    IQualityControl *m_pQSink;                  // Target for Quality messages <br>    LONG            m_TypeVersion;              // Holds current type version <br> <br>    CRefTime        m_tStart;                   // time from NewSegment call <br>    CRefTime        m_tStop;                    // time from NewSegment <br>    double          m_dRate;                    // rate from NewSegment <br> <br>#ifdef DEBUG <br>    LONG            m_cRef;                     // Ref count tracing <br>#endif <br> <br>    // displays pin connection information <br> <br>#ifdef DEBUG <br>    void DisplayPinInfo(IPin *pReceivePin); <br>    void DisplayTypeInfo(IPin *pPin, const CMediaType *pmt); <br>#else <br>    void DisplayPinInfo(IPin *pReceivePin) {}; <br>    void DisplayTypeInfo(IPin *pPin, const CMediaType *pmt) {}; <br>#endif <br> <br>    // used to agree a media type for a pin connection <br> <br>    // given a specific media type, attempt a connection (includes <br>    // checking that the type is acceptable to this pin) <br>    HRESULT <br>    AttemptConnection( <br>        IPin* pReceivePin,      // connect to this pin <br>        const CMediaType* pmt   // using this type <br>    ); <br> <br>    // try all the media types in this enumerator - for each that <br>    // we accept, try to connect using ReceiveConnection. <br>    HRESULT TryMediaTypes( <br>                        IPin *pReceivePin,      // connect to this pin <br>                        const CMediaType *pmt,        // proposed type from Connect <br>                        IEnumMediaTypes *pEnum);    // try this enumerator <br> <br>    // establish a connection with a suitable mediatype. Needs to <br>    // propose a media type if the pmt pointer is null or partially <br>    // specified - use TryMediaTypes on both our and then the other pin's <br>    // enumerator until we find one that works. <br>    HRESULT AgreeMediaType( <br>                        IPin *pReceivePin,      // connect to this pin <br>                        const CMediaType *pmt);       // proposed type from Connect <br> <br>public: <br> <br>    CBasePin( <br>        TCHAR *pObjectName,         // Object description <br>        CBaseFilter *pFilter,       // Owning filter who knows about pins <br>        CCritSec *pLock,            // Object who implements the lock <br>        HRESULT *phr,               // General OLE return code <br>        LPCWSTR pName,              // Pin name for us <br>        PIN_DIRECTION dir);         // Either PINDIR_INPUT or PINDIR_OUTPUT <br> <br>    virtual ~CBasePin(); <br> <br>    DECLARE_IUNKNOWN <br> <br>    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv); <br>    STDMETHODIMP_(ULONG) NonDelegatingRelease(); <br>    STDMETHODIMP_(ULONG) NonDelegatingAddRef(); <br> <br>    // --- IPin methods --- <br> <br>    // take lead role in establishing a connection. Media type pointer <br>    // may be null, or may point to partially-specified mediatype <br>    // (subtype or format type may be GUID_NULL). <br>    STDMETHODIMP Connect( <br>        IPin * pReceivePin, <br>        const AM_MEDIA_TYPE *pmt   // optional media type <br>    ); <br> <br>    // (passive) accept a connection from another pin <br>    STDMETHODIMP ReceiveConnection( <br>        IPin * pConnector,      // this is the initiating connecting pin <br>        const AM_MEDIA_TYPE *pmt   // this is the media type we will exchange <br>    ); <br> <br>    STDMETHODIMP Disconnect(); <br> <br>    STDMETHODIMP ConnectedTo(IPin **pPin); <br> <br>    STDMETHODIMP ConnectionMediaType(AM_MEDIA_TYPE *pmt); <br> <br>    STDMETHODIMP QueryPinInfo( <br>        PIN_INFO * pInfo <br>    ); <br> <br>    STDMETHODIMP QueryDirection( <br>    PIN_DIRECTION * pPinDir <br>    ); <br> <br>    STDMETHODIMP QueryId( <br>        LPWSTR * Id <br>    ); <br> <br>    // does the pin support this media type <br>    STDMETHODIMP QueryAccept( <br>        const AM_MEDIA_TYPE *pmt <br>    ); <br> <br>    // return an enumerator for this pins preferred media types <br>    STDMETHODIMP EnumMediaTypes( <br>        IEnumMediaTypes **ppEnum <br>    ); <br> <br>    // return an array of IPin* - the pins that this pin internally connects to <br>    // All pins put in the array must be AddReffed (but no others) <br>    // Errors: "Can't say" - FAIL, not enough slots - return S_FALSE <br>    // Default: return E_NOTIMPL <br>    // The filter graph will interpret NOT_IMPL as any input pin connects to <br>    // all visible output pins and vice versa. <br>    // apPin can be NULL if nPin==0 (not otherwise). <br>    STDMETHODIMP QueryInternalConnections( <br>        IPin* *apPin,     // array of IPin* <br>        ULONG *nPin       // on input, the number of slots <br>                          // on output  the number of pins <br>    ) { return E_NOTIMPL; } <br> <br>    // Called when no more data will be sent <br>    STDMETHODIMP EndOfStream(void); <br> <br>    // Begin/EndFlush still PURE <br> <br>    // NewSegment notifies of the start/stop/rate applying to the data <br>    // about to be received. Default implementation records data and <br>    // returns S_OK. <br>    // Override this to pass downstream. <br>    STDMETHODIMP NewSegment( <br>                    REFERENCE_TIME tStart, <br>                    REFERENCE_TIME tStop, <br>                    double dRate); <br> <br>    //================================================================================ <br>    // IQualityControl methods <br>    //================================================================================ <br> <br>    STDMETHODIMP Notify(IBaseFilter * pSender, Quality q); <br> <br>    STDMETHODIMP SetSink(IQualityControl * piqc); <br> <br>    // --- helper methods --- <br> <br>    // Returns true if the pin is connected. false otherwise. <br>    BOOL IsConnected(void) {return (m_Connected != NULL); }; <br>    // Return the pin this is connected to (if any) <br>    IPin * GetConnected() { return m_Connected; }; <br> <br>    // Check if our filter is currently stopped <br>    BOOL IsStopped() { <br>        return (m_pFilter-&gt;m_State == State_Stopped); <br>    }; <br> <br>    // find out the current type version (used by enumerators) <br>    virtual LONG GetMediaTypeVersion(); <br>    void IncrementTypeVersion(); <br> <br>    // switch the pin to active (paused or running) mode <br>    // not an error to call this if already active <br>    virtual HRESULT Active(void); <br> <br>    // switch the pin to inactive state - may already be inactive <br>    virtual HRESULT Inactive(void); <br> <br>    // Notify of Run() from filter <br>    virtual HRESULT Run(REFERENCE_TIME tStart); <br> <br>    // check if the pin can support this specific proposed type and format <br>    virtual HRESULT CheckMediaType(const CMediaType *) PURE; <br> <br>    // set the connection to use this format (previously agreed) <br>    virtual HRESULT SetMediaType(const CMediaType *); <br> <br>    // check that the connection is ok before verifying it <br>    // can be overridden eg to check what interfaces will be supported. <br>    virtual HRESULT CheckConnect(IPin *); <br> <br>    // Set and release resources required for a connection <br>    virtual HRESULT BreakConnect(); <br>    virtual HRESULT CompleteConnect(IPin *pReceivePin); <br> <br>    // returns the preferred formats for a pin <br>    virtual HRESULT GetMediaType(int iPosition,CMediaType *pMediaType); <br> <br>    // access to NewSegment values <br>    REFERENCE_TIME CurrentStopTime() { <br>        return m_tStop; <br>    } <br>    REFERENCE_TIME CurrentStartTime() { <br>        return m_tStart; <br>    } <br>    double CurrentRate() { <br>        return m_dRate; <br>    } <br> <br>    //  Access name <br>    LPWSTR Name() { return m_pName; }; <br> <br>}; <br> <br> <br>//===================================================================== <br>//===================================================================== <br>// Defines CEnumPins <br>// <br>// Pin enumerator class that works by calling CBaseFilter. This interface <br>// is provided by CBaseFilter::EnumPins and calls GetPinCount() and <br>// GetPin() to enumerate existing pins. Needs to be a separate object so <br>// that it can be cloned (creating an existing object at the same <br>// position in the enumeration) <br>// <br>// NOTE It overrides the non delegating IUnknown so that it can not <br>// only keep it's own reference counting lifetime but it will also still <br>// delegate to the outer owner. This ensures the owner is around all the <br>// time we are <br>//===================================================================== <br>//===================================================================== <br> <br>class CEnumPins : public IEnumPins      // The interface we support <br>{ <br>    int m_Position;                 // Current ordinal position <br>    int m_PinCount;                 // Number of pins available <br>    CBaseFilter *m_pFilter;         // The filter who owns us <br>    LONG m_Version;                 // Pin version information <br>    LONG m_cRef; <br> <br>    typedef CGenericList&lt;CBasePin&gt; CPinList; <br> <br>    CPinList m_PinCache;    // These pointers have not been AddRef'ed and <br>    // so they should not be dereferenced.  They are <br>    // merely kept to ID which pins have been enumerated. <br> <br>#ifdef DEBUG <br>    DWORD m_dwCookie; <br>#endif <br> <br>    /* If while we are retrieving a pin for example from the filter an error <br>       occurs we assume that our internal state is stale with respect to the <br>       filter (someone may have deleted all the pins). We can check before <br>       starting whether or not the operation is likely to fail by asking the <br>       filter what it's current version number is. If the filter has not <br>       overriden the GetPinVersion method then this will always match */ <br> <br>    BOOL AreWeOutOfSync() { <br>        return (m_pFilter-&gt;GetPinVersion() == m_Version ? FALSE : TRUE); <br>    }; <br> <br>    /* This method performs the same operations as Reset, except is does not clear <br>       the cache of pins already enumerated. */ <br> <br>    STDMETHODIMP Refresh(); <br> <br>public: <br> <br>    CEnumPins( <br>        CBaseFilter *pFilter, <br>        CEnumPins *pEnumPins); <br> <br>    virtual ~CEnumPins(); <br> <br>    // IUnknown <br>    STDMETHODIMP QueryInterface(REFIID riid, void **ppv); <br>    STDMETHODIMP_(ULONG) AddRef(); <br>    STDMETHODIMP_(ULONG) Release(); <br> <br>    // IEnumPins <br>    STDMETHODIMP Next( <br>        ULONG cPins,         // place this many pins... <br>        IPin ** ppPins,      // ...in this array of IPin* <br>        ULONG * pcFetched    // actual count passed returned here <br>    ); <br> <br>    STDMETHODIMP Skip(ULONG cPins); <br>    STDMETHODIMP Reset(); <br>    STDMETHODIMP Clone(IEnumPins **ppEnum); <br> <br> <br>}; <br> <br> <br>//===================================================================== <br>//===================================================================== <br>// Defines CEnumMediaTypes <br>// <br>// Enumerates the preferred formats for input and output pins <br>//===================================================================== <br>//===================================================================== <br> <br>class CEnumMediaTypes : public IEnumMediaTypes    // The interface we support <br>{ <br>    int m_Position;           // Current ordinal position <br>    CBasePin *m_pPin;         // The pin who owns us <br>    LONG m_Version;           // Media type version value <br>    LONG m_cRef; <br>#ifdef DEBUG <br>    DWORD m_dwCookie; <br>#endif <br> <br>    /* The media types a filter supports can be quite dynamic so we add to <br>       the general IEnumXXXX interface the ability to be signaled when they <br>       change via an event handle the connected filter supplies. Until the <br>       Reset method is called after the state changes all further calls to <br>       the enumerator (except Reset) will return E_UNEXPECTED error code */ <br> <br>    BOOL AreWeOutOfSync() { <br>        return (m_pPin-&gt;GetMediaTypeVersion() == m_Version ? FALSE : TRUE); <br>    }; <br> <br>public: <br> <br>    CEnumMediaTypes( <br>        CBasePin *pPin, <br>        CEnumMediaTypes *pEnumMediaTypes); <br> <br>    virtual ~CEnumMediaTypes(); <br> <br>    // IUnknown <br>    STDMETHODIMP QueryInterface(REFIID riid, void **ppv); <br>    STDMETHODIMP_(ULONG) AddRef(); <br>    STDMETHODIMP_(ULONG) Release(); <br> <br>    // IEnumMediaTypes <br>    STDMETHODIMP Next( <br>        ULONG cMediaTypes,          // place this many pins... <br>        AM_MEDIA_TYPE ** ppMediaTypes,  // ...in this array <br>        ULONG * pcFetched           // actual count passed <br>    ); <br> <br>    STDMETHODIMP Skip(ULONG cMediaTypes); <br>    STDMETHODIMP Reset(); <br>    STDMETHODIMP Clone(IEnumMediaTypes **ppEnum); <br>}; <br> <br> <br> <br> <br>//===================================================================== <br>//===================================================================== <br>// Defines CBaseOutputPin <br>// <br>// class derived from CBasePin that can pass buffers to a connected pin <br>// that supports IMemInputPin. Supports IPin. <br>// <br>// Derive your output pin from this. <br>// <br>//===================================================================== <br>//===================================================================== <br> <br>class  AM_NOVTABLE CBaseOutputPin : public CBasePin <br>{ <br> <br>protected: <br> <br>    IMemAllocator *m_pAllocator; <br>    IMemInputPin *m_pInputPin;        // interface on the downstreaminput pin <br>                                      // set up in CheckConnect when we connect. <br> <br>public: <br> <br>    CBaseOutputPin( <br>        TCHAR *pObjectName, <br>        CBaseFilter *pFilter, <br>        CCritSec *pLock, <br>        HRESULT *phr, <br>        LPCWSTR pName); <br> <br>    // override CompleteConnect() so we can negotiate an allocator <br>    virtual HRESULT CompleteConnect(IPin *pReceivePin); <br> <br>    // negotiate the allocator and its buffer size/count and other properties <br>    // Calls DecideBufferSize to set properties <br>    virtual HRESULT DecideAllocator(IMemInputPin * pPin, IMemAllocator ** pAlloc); <br> <br>    // override this to set the buffer size and count. Return an error <br>    // if the size/count is not to your liking. <br>    // The allocator properties passed in are those requested by the <br>    // input pin - use eg the alignment and prefix members if you have <br>    // no preference on these. <br>    virtual HRESULT DecideBufferSize( <br>        IMemAllocator * pAlloc, <br>        ALLOCATOR_PROPERTIES * ppropInputRequest <br>    ) PURE; <br> <br>    // returns an empty sample buffer from the allocator <br>    virtual HRESULT GetDeliveryBuffer(IMediaSample ** ppSample, <br>                                      REFERENCE_TIME * pStartTime, <br>                                      REFERENCE_TIME * pEndTime, <br>                                      DWORD dwFlags); <br> <br>    // deliver a filled-in sample to the connected input pin <br>    // note - you need to release it after calling this. The receiving <br>    // pin will addref the sample if it needs to hold it beyond the <br>    // call. <br>    virtual HRESULT Deliver(IMediaSample *); <br> <br>    // override this to control the connection <br>    virtual HRESULT InitAllocator(IMemAllocator **ppAlloc); <br>    HRESULT CheckConnect(IPin *pPin); <br>    HRESULT BreakConnect(); <br> <br>    // override to call Commit and Decommit <br>    HRESULT Active(void); <br>    HRESULT Inactive(void); <br> <br>    // we have a default handling of EndOfStream which is to return <br>    // an error, since this should be called on input pins only <br>    STDMETHODIMP EndOfStream(void); <br> <br>    // called from elsewhere in our filter to pass EOS downstream to <br>    // our connected input pin <br>    virtual HRESULT DeliverEndOfStream(void); <br> <br>    // same for Begin/EndFlush - we handle Begin/EndFlush since it <br>    // is an error on an output pin, and we have Deliver methods to <br>    // call the methods on the connected pin <br>    STDMETHODIMP BeginFlush(void); <br>    STDMETHODIMP EndFlush(void); <br>    virtual HRESULT DeliverBeginFlush(void); <br>    virtual HRESULT DeliverEndFlush(void); <br> <br>    // deliver NewSegment to connected pin - you will need to <br>    // override this if you queue any data in your output pin. <br>    virtual HRESULT DeliverNewSegment( <br>                        REFERENCE_TIME tStart, <br>                        REFERENCE_TIME tStop, <br>                        double dRate); <br> <br>    //================================================================================ <br>    // IQualityControl methods <br>    //================================================================================ <br> <br>    // All inherited from CBasePin and not overridden here. <br>    // STDMETHODIMP Notify(IBaseFilter * pSender, Quality q); <br>    // STDMETHODIMP SetSink(IQualityControl * piqc); <br>}; <br> <br> <br>//===================================================================== <br>//===================================================================== <br>// Defines CBaseInputPin <br>// <br>// derive your standard input pin from this. <br>// you need to supply GetMediaType and CheckConnect etc (see CBasePin), <br>// and you need to supply Receive to do something more useful. <br>// <br>//===================================================================== <br>//===================================================================== <br> <br>class AM_NOVTABLE CBaseInputPin : public CBasePin, <br>                                  public IMemInputPin <br>{ <br> <br>protected: <br> <br>    IMemAllocator *m_pAllocator;    // Default memory allocator <br> <br>    // allocator is read-only, so received samples <br>    // cannot be modified (probably only relevant to in-place <br>    // transforms <br>    BYTE m_bReadOnly; <br> <br>//private:  this should really be private... only the MPEG code <br>// currently looks at it directly and it should use IsFlushing(). <br>    // in flushing state (between BeginFlush and EndFlush) <br>    // if TRUE, all Receives are returned with S_FALSE <br>    BYTE m_bFlushing; <br> <br>    // Sample properties - initalized in Receive <br>    AM_SAMPLE2_PROPERTIES m_SampleProps; <br> <br>public: <br> <br>    CBaseInputPin( <br>        TCHAR *pObjectName, <br>        CBaseFilter *pFilter, <br>        CCritSec *pLock, <br>        HRESULT *phr, <br>        LPCWSTR pName); <br> <br>    virtual ~CBaseInputPin(); <br> <br>    DECLARE_IUNKNOWN <br> <br>    // override this to publicise our interfaces <br>    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv); <br> <br>    // return the allocator interface that this input pin </code></pre>
<p>
</p>
<pre><code>// would like the output pin to use <br>    STDMETHODIMP GetAllocator(IMemAllocator ** ppAllocator); <br> <br>    // tell the input pin which allocator the output pin is actually <br>    // going to use. <br>    STDMETHODIMP NotifyAllocator( <br>                    IMemAllocator * pAllocator, <br>                    BOOL bReadOnly); <br> <br>    // override to release our stored allocator <br>    STDMETHODIMP Disconnect(); <br> <br>    // do something with this media sample <br>    STDMETHODIMP Receive(IMediaSample *pSample); <br> <br>    // do something with these media samples <br>    STDMETHODIMP ReceiveMultiple ( <br>        IMediaSample **pSamples, <br>        long nSamples, <br>        long *nSamplesProcessed); <br> <br>    // See if Receive() blocks <br>    STDMETHODIMP ReceiveCanBlock(); <br> <br>    // Default handling for BeginFlush - call at the beginning <br>    // of your implementation (makes sure that all Receive calls <br>    // fail). After calling this, you need to free any queued data <br>    // and then call downstream. <br>    STDMETHODIMP BeginFlush(void); <br> <br>    // default handling for EndFlush - call at end of your implementation <br>    // - before calling this, ensure that there is no queued data and no thread <br>    // pushing any more without a further receive, then call downstream, <br>    // then call this method to clear the m_bFlushing flag and re-enable <br>    // receives <br>    STDMETHODIMP EndFlush(void); <br> <br>    // this method is optional (can return E_NOTIMPL). <br>    // default implementation returns E_NOTIMPL. Override if you have <br>    // specific alignment or prefix needs, but could use an upstream <br>    // allocator <br>    STDMETHODIMP GetAllocatorRequirements(ALLOCATOR_PROPERTIES*pProps); <br> <br>    // helper method to check the read-only flag <br>    BOOL IsReadOnly() { <br>        return m_bReadOnly; <br>    }; <br> <br>    // helper method to see if we are flushing <br>    BOOL IsFlushing() { <br>        return m_bFlushing; <br>    }; <br> <br>    //  Override this for checking whether it's OK to process samples <br>    //  Also call this from EndOfStream. <br>    virtual HRESULT CheckStreaming(); <br> <br>    // Pass a Quality notification on to the appropriate sink <br>    HRESULT PassNotify(Quality&amp; q); <br> <br> <br>    //================================================================================ <br>    // IQualityControl methods (from CBasePin) <br>    //================================================================================ <br> <br>    STDMETHODIMP Notify(IBaseFilter * pSender, Quality q); <br> <br>    // no need to override: <br>    // STDMETHODIMP SetSink(IQualityControl * piqc); <br> <br> <br>    // switch the pin to inactive state - may already be inactive <br>    virtual HRESULT Inactive(void); <br> <br>    // Return sample properties pointer <br>    AM_SAMPLE2_PROPERTIES * SampleProps() { <br>        ASSERT(m_SampleProps.cbData != 0); <br>        return &amp;m_SampleProps; <br>    } <br>}; <br> <br> <br> <br>//===================================================================== <br>//===================================================================== <br>// Memory allocators <br>// <br>// the shared memory transport between pins requires the input pin <br>// to provide a memory allocator that can provide sample objects. A <br>// sample object supports the IMediaSample interface. <br>// <br>// CBaseAllocator handles the management of free and busy samples. It <br>// allocates CMediaSample objects. CBaseAllocator is an abstract class: <br>// in particular it has no method of initializing the list of free <br>// samples. CMemAllocator is derived from CBaseAllocator and initializes <br>// the list of samples using memory from the standard IMalloc interface. <br>// <br>// If you want your buffers to live in some special area of memory, <br>// derive your allocator object from CBaseAllocator. If you derive your <br>// IMemInputPin interface object from CBaseMemInputPin, you will get <br>// CMemAllocator-based allocation etc for free and will just need to <br>// supply the Receive handling, and media type / format negotiation. <br>//===================================================================== <br>//===================================================================== <br> <br> <br>//===================================================================== <br>//===================================================================== <br>// Defines CMediaSample <br>// <br>// an object of this class supports IMediaSample and represents a buffer <br>// for media data with some associated properties. Releasing it returns <br>// it to a freelist managed by a CBaseAllocator derived object. <br>//===================================================================== <br>//===================================================================== <br> <br>class CMediaSample : public IMediaSample2    // The interface we support <br>{ <br> <br>protected: <br> <br>    friend class CBaseAllocator; <br> <br>    /*  Values for dwFlags - these are used for backward compatiblity <br>        only now - use AM_SAMPLE_xxx <br>    */ <br>    enum { Sample_SyncPoint       = 0x01,   /* Is this a sync point */ <br>           Sample_Preroll         = 0x02,   /* Is this a preroll sample */ <br>           Sample_Discontinuity   = 0x04,   /* Set if start of new segment */ <br>           Sample_TypeChanged     = 0x08,   /* Has the type changed */ <br>           Sample_TimeValid       = 0x10,   /* Set if time is valid */ <br>           Sample_MediaTimeValid  = 0x20,   /* Is the media time valid */ <br>           Sample_TimeDiscontinuity = 0x40, /* Time discontinuity */ <br>           Sample_StopValid       = 0x100,  /* Stop time valid */ <br>           Sample_ValidFlags      = 0x1FF <br>         }; <br> <br>    /* Properties, the media sample class can be a container for a format <br>       change in which case we take a copy of a type through the SetMediaType <br>       interface function and then return it when GetMediaType is called. As <br>       we do no internal processing on it we leave it as a pointer */ <br> <br>    DWORD            m_dwFlags;         /* Flags for this sample */ <br>                                        /* Type specific flags are packed <br>                                           into the top word <br>                                        */ <br>    DWORD            m_dwTypeSpecificFlags; /* Media type specific flags */ <br>    LPBYTE           m_pBuffer;         /* Pointer to the complete buffer */ <br>    LONG             m_lActual;         /* Length of data in this sample */ <br>    LONG             m_cbBuffer;        /* Size of the buffer */ <br>    CBaseAllocator  *m_pAllocator;      /* The allocator who owns us */ <br>    CMediaSample     *m_pNext;          /* Chaining in free list */ <br>    REFERENCE_TIME   m_Start;           /* Start sample time */ <br>    REFERENCE_TIME   m_End;             /* End sample time */ <br>    LONGLONG         m_MediaStart;      /* Real media start position */ <br>    LONG             m_MediaEnd;        /* A difference to get the end */ <br>    AM_MEDIA_TYPE    *m_pMediaType;     /* Media type change data */ <br>    DWORD            m_dwStreamId;      /* Stream id */ <br>public: <br>    LONG             m_cRef;            /* Reference count */ <br> <br> <br>public: <br> <br>    CMediaSample( <br>        TCHAR *pName, <br>        CBaseAllocator *pAllocator, <br>        HRESULT *phr, <br>        LPBYTE pBuffer = NULL, <br>        LONG length = 0); <br> <br>    virtual ~CMediaSample(); <br> <br>    /* Note the media sample does not delegate to its owner */ <br> <br>    STDMETHODIMP QueryInterface(REFIID riid, void **ppv); <br>    STDMETHODIMP_(ULONG) AddRef(); <br>    STDMETHODIMP_(ULONG) Release(); <br> <br>    // set the buffer pointer and length. Used by allocators that <br>    // want variable sized pointers or pointers into already-read data. <br>    // This is only available through a CMediaSample* not an IMediaSample* <br>    // and so cannot be changed by clients. <br>    HRESULT SetPointer(BYTE * ptr, LONG cBytes); <br> <br>    // Get me a read/write pointer to this buffer's memory. <br>    STDMETHODIMP GetPointer(BYTE ** ppBuffer); <br> <br>    STDMETHODIMP_(LONG) GetSize(void); <br> <br>    // get the stream time at which this sample should start and finish. <br>    STDMETHODIMP GetTime( <br>        REFERENCE_TIME * pTimeStart,     // put time here <br>        REFERENCE_TIME * pTimeEnd <br>    ); <br> <br>    // Set the stream time at which this sample should start and finish. <br>    STDMETHODIMP SetTime( <br>        REFERENCE_TIME * pTimeStart,     // put time here <br>        REFERENCE_TIME * pTimeEnd <br>    ); <br>    STDMETHODIMP IsSyncPoint(void); <br>    STDMETHODIMP SetSyncPoint(BOOL bIsSyncPoint); <br>    STDMETHODIMP IsPreroll(void); <br>    STDMETHODIMP SetPreroll(BOOL bIsPreroll); <br> <br>    STDMETHODIMP_(LONG) GetActualDataLength(void); <br>    STDMETHODIMP SetActualDataLength(LONG lActual); <br> <br>    // these allow for limited format changes in band <br> <br>    STDMETHODIMP GetMediaType(AM_MEDIA_TYPE **ppMediaType); <br>    STDMETHODIMP SetMediaType(AM_MEDIA_TYPE *pMediaType); <br> <br>    // returns S_OK if there is a discontinuity in the data (this same is <br>    // not a continuation of the previous stream of data <br>    // - there has been a seek). <br>    STDMETHODIMP IsDiscontinuity(void); <br>    // set the discontinuity property - TRUE if this sample is not a <br>    // continuation, but a new sample after a seek. <br>    STDMETHODIMP SetDiscontinuity(BOOL bDiscontinuity); <br> <br>    // get the media times for this sample <br>    STDMETHODIMP GetMediaTime( <br>    LONGLONG * pTimeStart, <br>LONGLONG * pTimeEnd <br>    ); <br> <br>    // Set the media times for this sample <br>    STDMETHODIMP SetMediaTime( <br>    LONGLONG * pTimeStart, <br>LONGLONG * pTimeEnd <br>    ); <br> <br>    // Set and get properties (IMediaSample2) <br>    STDMETHODIMP GetProperties( <br>        DWORD cbProperties, <br>        BYTE * pbProperties <br>    ); <br> <br>    STDMETHODIMP SetProperties( <br>        DWORD cbProperties, <br>        const BYTE * pbProperties <br>    ); <br>}; <br> <br> <br>//===================================================================== <br>//===================================================================== <br>// Defines CBaseAllocator <br>// <br>// Abstract base class that manages a list of media samples <br>// <br>// This class provides support for getting buffers from the free list, <br>// including handling of commit and (asynchronous) decommit. <br>// <br>// Derive from this class and override the Alloc and Free functions to <br>// allocate your CMediaSample (or derived) objects and add them to the <br>// free list, preparing them as necessary. <br>//===================================================================== <br>//===================================================================== <br> <br>class AM_NOVTABLE CBaseAllocator : public CUnknown,         // A non delegating IUnknown <br>                       public IMemAllocator,    // The interface we support <br>                       public CCritSec          // Provides object locking <br>{ <br>    class CSampleList; <br>    friend class CSampleList; <br> <br>    /*  Hack to get at protected member in CMediaSample */ <br>    static CMediaSample * &amp;NextSample(CMediaSample *pSample) <br>    { <br>        return pSample-&gt;m_pNext; <br>    }; <br> <br>    /*  Mini list class for the free list */ <br>    class CSampleList <br>    { <br>    public: <br>        CSampleList() : m_List(NULL), m_nOnList(0) {}; <br>#ifdef DEBUG <br>        ~CSampleList() <br>        { <br>            ASSERT(m_nOnList == 0); <br>        }; <br>#endif <br>        CMediaSample *Head() const { return m_List; }; <br>        CMediaSample *Next(CMediaSample *pSample) const { return CBaseAllocator::NextSample(pSample); }; <br>        int GetCount() const { return m_nOnList; }; <br>        void Add(CMediaSample *pSample) <br>        { <br>            ASSERT(pSample != NULL); <br>            CBaseAllocator::NextSample(pSample) = m_List; <br>            m_List = pSample; <br>            m_nOnList++; <br>        }; <br>        CMediaSample *RemoveHead() <br>        { <br>            CMediaSample *pSample = m_List; <br>            if (pSample != NULL) { <br>                m_List = CBaseAllocator::NextSample(m_List); <br>                m_nOnList--; <br>            } <br>            return pSample; <br>        }; <br>        void Remove(CMediaSample *pSample); <br> <br>    public: <br>        CMediaSample *m_List; <br>        int           m_nOnList; <br>    }; <br>protected: <br> <br>    CSampleList m_lFree;        // Free list <br> <br>    /*  Note to overriders of CBaseAllocator. <br> <br>        We use a lazy signalling mechanism for waiting for samples. <br>        This means we don't call the OS if no waits occur. <br> <br>        In order to implement this: <br> <br>        1. When a new sample is added to m_lFree call NotifySample() which <br>           calls ReleaseSemaphore on m_hSem with a count of m_lWaiting and <br>           sets m_lWaiting to 0. <br>           This must all be done holding the allocator's critical section. <br> <br>        2. When waiting for a sample call SetWaiting() which increments <br>           m_lWaiting BEFORE leaving the allocator's critical section. <br> <br>        3. Actually wait by calling WaitForSingleObject(m_hSem, INFINITE) <br>           having left the allocator's critical section.  The effect of <br>           this is to remove 1 from the semaphore's count.  You MUST call <br>           this once having incremented m_lWaiting. <br> <br>        The following are then true when the critical section is not held : <br>            (let nWaiting = number about to wait or waiting) <br> <br>            (1) if (m_lFree.GetCount() != 0) then (m_lWaiting == 0) <br>            (2) m_lWaiting + Semaphore count == nWaiting <br> <br>        We would deadlock if <br>           nWaiting != 0 &amp;&amp; <br>           m_lFree.GetCount() != 0 &amp;&amp; <br>           Semaphore count == 0 <br> <br>           But from (1) if m_lFree.GetCount() != 0 then m_lWaiting == 0 so <br>           from (2) Semaphore count == nWaiting (which is non-0) so the <br>           deadlock can't happen. <br>    */ <br> <br>    HANDLE m_hSem;              // For signalling <br>    long m_lWaiting;            // Waiting for a free element <br>    long m_lCount;              // how many buffers we have agreed to provide <br>    long m_lAllocated;          // how many buffers are currently allocated <br>    long m_lSize;               // agreed size of each buffer <br>    long m_lAlignment;          // agreed alignment <br>    long m_lPrefix;             // agreed prefix (preceeds GetPointer() value) <br>    BOOL m_bChanged;            // Have the buffer requirements changed <br> <br>    // if true, we are decommitted and can't allocate memory <br>    BOOL m_bCommitted; <br>    // if true, the decommit has happened, but we haven't called Free yet <br>    // as there are still outstanding buffers <br>    BOOL m_bDecommitInProgress; <br> <br>    // called to decommit the memory when the last buffer is freed <br>    // pure virtual - need to override this <br>    virtual void Free(void) PURE; <br> <br>    // override to allocate the memory when commit called <br>    virtual HRESULT Alloc(void); <br> <br>public: <br> <br>    CBaseAllocator(TCHAR *, LPUNKNOWN, HRESULT *, BOOL bEvent = TRUE); <br>    virtual ~CBaseAllocator(); <br> <br>    DECLARE_IUNKNOWN <br> <br>    // override this to publicise our interfaces <br>    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv); <br> <br>    STDMETHODIMP SetProperties( <br>    ALLOCATOR_PROPERTIES* pRequest, <br>    ALLOCATOR_PROPERTIES* pActual); <br> <br>    // return the properties actually being used on this allocator <br>    STDMETHODIMP GetProperties( <br>    ALLOCATOR_PROPERTIES* pProps); <br> <br>    // override Commit to allocate memory. We handle the GetBuffer <br>    //state changes <br>    STDMETHODIMP Commit(); <br> <br>    // override this to handle the memory freeing. We handle any outstanding <br>    // GetBuffer calls <br>    STDMETHODIMP Decommit(); <br> <br>    // get container for a sample. Blocking, synchronous call to get the <br>    // next free buffer (as represented by an IMediaSample interface). <br>    // on return, the time etc properties will be invalid, but the buffer <br>    // pointer and size will be correct. The two time parameters are <br>    // optional and either may be NULL, they may alternatively be set to <br>    // the start and end times the sample will have attached to it <br>    // bPrevFramesSkipped is not used (used only by the video renderer's <br>    // allocator where it affects quality management in direct draw). <br> <br>    STDMETHODIMP GetBuffer(IMediaSample **ppBuffer, <br>                           REFERENCE_TIME * pStartTime, <br>                           REFERENCE_TIME * pEndTime, <br>                           DWORD dwFlags); <br> <br>    // final release of a CMediaSample will call this <br>    STDMETHODIMP ReleaseBuffer(IMediaSample *pBuffer); <br>    // obsolete:: virtual void PutOnFreeList(CMediaSample * pSample); <br> <br>    // Notify that a sample is available <br>    void NotifySample(); <br> <br>    // Notify that we're waiting for a sample <br>    void SetWaiting() { m_lWaiting++; }; <br>}; <br> <br> <br>//===================================================================== <br>//===================================================================== <br>// Defines CMemAllocator <br>// <br>// this is an allocator based on CBaseAllocator that allocates sample <br>// buffers in main memory (from 'new'). You must call SetProperties <br>// before calling Commit. <br>// <br>// we don't free the memory when going into Decommit state. The simplest <br>// way to implement this without complicating CBaseAllocator is to <br>// have a Free() function, called to go into decommit state, that does <br>// nothing and a ReallyFree function called from our destructor that <br>// actually frees the memory. <br>//===================================================================== <br>//===================================================================== <br> <br>//  Make me one from quartz.dll <br>STDAPI CreateMemoryAllocator(IMemAllocator **ppAllocator); <br> <br>class CMemAllocator : public CBaseAllocator <br>{ <br> <br>protected: <br> <br>    LPBYTE m_pBuffer;   // combined memory for all buffers <br> <br>    // override to free the memory when decommit completes <br>    // - we actually do nothing, and save the memory until deletion. <br>    void Free(void); <br> <br>    // called from the destructor (and from Alloc if changing size/count) to <br>    // actually free up the memory <br>    void ReallyFree(void); <br> <br>    // overriden to allocate the memory when commit called <br>    HRESULT Alloc(void); <br> <br>public: <br>    /* This goes in the factory template table to create new instances */ <br>    static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *); <br> <br>    STDMETHODIMP SetProperties( <br>    ALLOCATOR_PROPERTIES* pRequest, <br>    ALLOCATOR_PROPERTIES* pActual); <br> <br>    CMemAllocator(TCHAR *, LPUNKNOWN, HRESULT *); <br>    ~CMemAllocator(); <br>}; <br> <br>// helper used by IAMovieSetup implementation <br>STDAPI <br>AMovieSetupRegisterFilter( const AMOVIESETUP_FILTER * const psetupdata <br>                         , IFilterMapper *                  pIFM <br>                         , BOOL                             bRegister  ); <br> <br> <br>#endif /* __FILTER__ */ <br> <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
