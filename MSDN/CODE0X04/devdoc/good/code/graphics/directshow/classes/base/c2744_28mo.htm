<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PULLPIN.H</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2760"></a>PULLPIN.H</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>#ifndef __PULLPIN_H__ <br>#define __PULLPIN_H__ <br> <br>// <br>// CPullPin <br>// <br>// object supporting pulling data from an IAsyncReader interface. <br>// Given a start/stop position, calls a pure Receive method with each <br>// IMediaSample received. <br>// <br>// This is essentially for use in a MemInputPin when it finds itself <br>// connected to an IAsyncReader pin instead of a pushing pin. <br>// <br> <br>class CPullPin : public CAMThread <br>{ <br>    IAsyncReader*       m_pReader; <br>    REFERENCE_TIME      m_tStart; <br>    REFERENCE_TIME      m_tStop; <br>    REFERENCE_TIME      m_tDuration; <br>    BOOL                m_bSync; <br> <br>    enum ThreadMsg { <br>TM_Pause,       // stop pulling and wait for next message <br>TM_Start,       // start pulling <br>TM_Exit,        // stop and exit <br>    }; <br> <br>    ThreadMsg m_State; <br> <br>    // override pure thread proc from CAMThread <br>    DWORD ThreadProc(void); <br> <br>    // running pull method (check m_bSync) <br>    void Process(void); <br> <br>    // clean up any cancelled i/o after a flush <br>    void CleanupCancelled(void); <br> <br>    // suspend thread from pulling, eg during seek <br>    HRESULT PauseThread(); <br> <br>    // start thread pulling - create thread if necy <br>    HRESULT StartThread(); <br> <br>    // stop and close thread <br>    HRESULT StopThread(); <br> <br>    // called from ProcessAsync to queue and collect requests <br>    HRESULT QueueSample( <br>REFERENCE_TIME&amp; tCurrent, <br>REFERENCE_TIME tAlignStop, <br>BOOL bDiscontinuity); <br> <br>    HRESULT CollectAndDeliver( <br>REFERENCE_TIME tStart, <br>REFERENCE_TIME tStop); <br> <br>    HRESULT DeliverSample( <br>IMediaSample* pSample, <br>REFERENCE_TIME tStart, <br>REFERENCE_TIME tStop); <br> <br>protected: <br>    IMemAllocator *     m_pAlloc; <br> <br>public: <br>    CPullPin(); <br>    virtual ~CPullPin(); <br> <br>    // returns S_OK if successfully connected to an IAsyncReader interface <br>    // from this object <br>    // Optional allocator should be proposed as a preferred allocator if <br>    // necessary <br>    // bSync is TRUE if we are to use sync reads instead of the <br>    // async methods. <br>    HRESULT Connect(IUnknown* pUnk, IMemAllocator* pAlloc, BOOL bSync); <br> <br>    // disconnect any connection made in Connect <br>    HRESULT Disconnect(); <br> <br>    // agree an allocator using RequestAllocator - optional <br>    // props param specifies your requirements (non-zero fields). <br>    // returns an error code if fail to match requirements. <br>    // optional IMemAllocator interface is offered as a preferred allocator <br>    // but no error occurs if it can't be met. <br>    virtual HRESULT DecideAllocator( <br>IMemAllocator* pAlloc, <br>ALLOCATOR_PROPERTIES * pProps); <br> <br>    // set start and stop position. if active, will start immediately at <br>    // the new position. Default is 0 to duration <br>    HRESULT Seek(REFERENCE_TIME tStart, REFERENCE_TIME tStop); <br> <br>    // return the total duration <br>    HRESULT Duration(REFERENCE_TIME* ptDuration); <br> <br>    // start pulling data <br>    HRESULT Active(void); <br> <br>    // stop pulling data <br>    HRESULT Inactive(void); <br> <br>    // helper functions <br>    LONGLONG AlignDown(LONGLONG ll, LONG lAlign) { <br>// aligning downwards is just truncation <br>return ll &amp; ~(lAlign-1); <br>    }; <br> <br>    LONGLONG AlignUp(LONGLONG ll, LONG lAlign) { <br>// align up: round up to next boundary <br>return (ll + (lAlign -1)) &amp; ~(lAlign -1); <br>    }; <br> <br>    // GetReader returns the (addrefed) IAsyncReader interface <br>    // for SyncRead etc <br>    IAsyncReader* GetReader() { <br>m_pReader-&gt;AddRef(); <br>return m_pReader; <br>    }; <br> <br>    // -- pure -- <br> <br>    // override this to handle data arrival <br>    // return value other than S_OK will stop data <br>    virtual HRESULT Receive(IMediaSample*) PURE; <br> <br>    // override this to handle end-of-stream <br>    virtual HRESULT EndOfStream(void) PURE; <br> <br>    // called on runtime errors that will have caused pulling <br>    // to stop <br>    // these errors are all returned from the upstream filter, who <br>    // will have already reported any errors to the filtergraph. <br>    virtual void OnError(HRESULT hr) PURE; <br> <br>    // flush this pin and all downstream <br>    virtual HRESULT BeginFlush() PURE; <br>    virtual HRESULT EndFlush() PURE; <br> <br>}; <br> <br>#endif //__PULLPIN_H__ </code></pre>
<p>&nbsp;</p></body>
</HTML>
