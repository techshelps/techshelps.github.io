<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OUTPUTQ.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2755"></a>OUTPUTQ.CPP</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>/* <br>    outputq.cpp <br> <br>    COutputQueue class <br> <br>    This is a class used by an output pin which may sometimes want <br>    to queue output samples on a separate thread and sometimes <br>    call Receive() directly on the input pin <br>*/ <br> <br>#include &lt;streams.h&gt; <br> <br> <br>// <br>//  COutputQueue Constructor : <br>// <br>//  Determines if a thread is to be created and creates resources <br>// <br>//     pInputPin  - the downstream input pin we're queueing samples to <br>// <br>//     phr        - changed to a failure code if this function fails <br>//                  (otherwise unchanges) <br>// <br>//     bAuto      - Ask pInputPin if it can block in Receive by calling <br>//                  its ReceiveCanBlock method and create a thread if <br>//                  it can block, otherwise not. <br>// <br>//     bQueue     - if bAuto == FALSE then we create a thread if and only <br>//                  if bQueue == TRUE <br>// <br>//     lBatchSize - work in batches of lBatchSize <br>// <br>//     bBatchEact - Use exact batch sizes so don't send until the <br>//                  batch is full or SendAnyway() is called <br>// <br>//     lListSize  - If we create a thread make the list of samples queued <br>//                  to the thread have this size cache <br>// <br>//     dwPriority - If we create a thread set its priority to this <br>// <br>COutputQueue::COutputQueue( <br>             IPin         *pInputPin,          //  Pin to send stuff to <br>             HRESULT      *phr,                //  'Return code' <br>             BOOL          bAuto,              //  Ask pin if queue or not <br>             BOOL          bQueue,             //  Send through queue <br>             LONG          lBatchSize,         //  Batch <br>             BOOL          bBatchExact,        //  Batch exactly to BatchSize <br>             LONG          lListSize, <br>             DWORD         dwPriority <br>            ) : m_lBatchSize(lBatchSize), <br>                m_bBatchExact(bBatchExact &amp;&amp; (lBatchSize &gt; 1)), <br>                m_hThread(NULL), <br>                m_hSem(NULL), <br>                m_List(NULL), <br>                m_pPin(pInputPin), <br>                m_ppSamples(NULL), <br>                m_lWaiting(0), <br>                m_pInputPin(NULL), <br>                m_bSendAnyway(FALSE), <br>                m_nBatched(0), <br>                m_bFlushing(FALSE), <br>                m_bFlushed(TRUE), <br>                m_bTerminate(FALSE), <br>                m_hr(S_OK) <br>{ <br>    ASSERT(m_lBatchSize &gt; 0); <br> <br> <br>    if (FAILED(*phr)) { <br>        return; <br>    } <br> <br>    //  Check the input pin is OK and cache its IMemInputPin interface <br> <br>    *phr = pInputPin-&gt;QueryInterface(IID_IMemInputPin, (void **)&amp;m_pInputPin); <br>    if (FAILED(*phr)) { <br>        return; <br>    } <br> <br>    // See if we should ask the downstream pin <br> <br>    if (bAuto) { <br>        HRESULT hr = m_pInputPin-&gt;ReceiveCanBlock(); <br>        if (SUCCEEDED(hr)) { <br>            bQueue = hr == S_OK; <br>        } <br>    } <br> <br>    //  Create our sample batch <br> <br>    m_ppSamples = new PMEDIASAMPLE[m_lBatchSize]; <br>    if (m_ppSamples == NULL) { <br>        *phr = E_OUTOFMEMORY; <br>        return; <br>    } <br> <br>    //  If we're queueing allocate resources <br> <br>    if (bQueue) { <br>        DbgLog((LOG_TRACE, 2, TEXT("Creating thread for output pin"))); <br>        m_hSem = CreateSemaphore(NULL, 0, 0x7FFFFFFF, NULL); <br>        if (m_hSem == NULL) { <br>            DWORD dwError = GetLastError(); <br>            *phr = HRESULT_FROM_WIN32(dwError); <br>            return; <br>        } <br>        m_List = new CSampleList(NAME("Sample Queue List"), <br>                                 lListSize, <br>                                 FALSE         // No lock <br>                                ); <br>        if (m_List == NULL) { <br>            *phr = E_OUTOFMEMORY; <br>            return; <br>        } <br> <br> <br>        DWORD dwThreadId; <br>        m_hThread = CreateThread(NULL, <br>                                 0, <br>                                 InitialThreadProc, <br>                                 (LPVOID)this, <br>                                 0, <br>                                 &amp;dwThreadId); <br>        if (m_hThread == NULL) { <br>            DWORD dwError = GetLastError(); <br>            *phr = HRESULT_FROM_WIN32(dwError); <br>            return; <br>        } <br>        SetThreadPriority(m_hThread, dwPriority); <br>    } else { <br>        DbgLog((LOG_TRACE, 2, TEXT("Calling input pin directly - no thread"))); <br>    } <br>} <br> <br>// <br>//  COutputQueuee Destructor : <br>// <br>//  Free all resources - <br>// <br>//      Thread, <br>//      Batched samples <br>// <br>COutputQueue::~COutputQueue() <br>{ <br>    DbgLog((LOG_TRACE, 3, TEXT("COutputQueue::~COutputQueue"))); <br>    /*  Free our pointer */ <br>    if (m_pInputPin != NULL) { <br>        m_pInputPin-&gt;Release(); <br>    } <br>    if (m_hThread != NULL) { <br>        { <br>            CAutoLock lck(this); <br>            m_bTerminate = TRUE; <br>            m_hr = S_FALSE; <br>            NotifyThread(); <br>        } <br>        DbgWaitForSingleObject(m_hThread); <br>        EXECUTE_ASSERT(CloseHandle(m_hThread)); <br> <br>        //  The thread frees the samples when asked to terminate <br> <br>        ASSERT(m_List-&gt;GetCount() == 0); <br>        delete m_List; <br>    } else { <br>        FreeSamples(); <br>    } <br>    if (m_hSem != NULL) { <br>        EXECUTE_ASSERT(CloseHandle(m_hSem)); <br>    } <br>    delete [] m_ppSamples; <br>} <br> <br>// <br>//  Call the real thread proc as a member function <br>// <br>DWORD WINAPI COutputQueue::InitialThreadProc(LPVOID pv) <br>{ <br>    COutputQueue *pSampleQueue = (COutputQueue *)pv; <br>    CoInitialize(NULL); <br>    DWORD dwReturn = pSampleQueue-&gt;ThreadProc(); <br>    CoUninitialize(); <br>    return dwReturn; <br>} <br> <br>// <br>//  Thread sending the samples downstream : <br>// <br>//  When there is nothing to do the thread sets m_lWaiting (while <br>//  holding the critical section) and then waits for m_hSem to be <br>//  set (not holding the critical section) <br>// <br>DWORD COutputQueue::ThreadProc() <br>{ <br>    while (TRUE) { <br>        BOOL          bWait = FALSE; <br>        IMediaSample *pSample; <br>        LONG          lNumberToSend; // Local copy <br>        NewSegmentPacket* ppacket; <br> <br>        // <br>        //  Get a batch of samples and send it if possible <br>        //  In any case exit the loop if there is a control action <br>        //  requested <br>        // <br>        { <br>            CAutoLock lck(this); <br>            while (TRUE) { <br> <br>                if (m_bTerminate) { <br>                    FreeSamples(); <br>                    return 0; <br>                } <br>                if (m_bFlushing) { <br>                    FreeSamples(); <br>                    SetEvent(m_evFlushComplete); <br>                } <br> <br>                //  Get a sample off the list <br> <br>                pSample = m_List-&gt;RemoveHead(); <br> <br>                if (pSample != NULL &amp;&amp; <br>                    !IsSpecialSample(pSample)) { <br> <br>                    //  If its just a regular sample just add it to the batch <br>                    //  and exit the loop if the batch is full <br> <br>                    m_ppSamples[m_nBatched++] = pSample; <br>                    if (m_nBatched == m_lBatchSize) { <br>                        break; <br>                    } <br>                } else { <br> <br>                    //  If there was nothing in the queue and there's nothing <br>                    //  to send (either because there's nothing or the batch <br>                    //  isn't full) then prepare to wait <br> <br>                    if (pSample == NULL &amp;&amp; <br>                        (m_bBatchExact || m_nBatched == 0)) { <br> <br>                        //  Tell other thread to set the event when there's <br>                        //  something do to <br> <br>                        ASSERT(m_lWaiting == 0); <br>                        m_lWaiting++; <br>                        bWait      = TRUE; <br>                    } else { <br> <br>                        //  We break out of the loop on SEND_PACKET unless <br>                        //  there's nothing to send <br> <br>                        if (pSample == SEND_PACKET &amp;&amp; m_nBatched == 0) { <br>                            continue; <br>                        } <br> <br>                        if (pSample == NEW_SEGMENT) { <br>                            // now we need the parameters - we are <br>                            // guaranteed that the next packet contains them <br>                            ppacket = (NewSegmentPacket *) m_List-&gt;RemoveHead(); <br>                            ASSERT(ppacket); <br>                        } <br>                        //  EOS_PACKET falls through here and we exit the loop <br>                        //  In this way it acts like SEND_PACKET <br>                    } <br>                    break; <br>                } <br>            } <br>            if (!bWait) { <br>                // We look at m_nBatched from the client side so keep <br>                // it up to date inside the critical section <br>                lNumberToSend = m_nBatched;  // Local copy <br>                m_nBatched = 0; <br>            } <br>        } <br> <br>        //  Wait for some more data <br> <br>        if (bWait) { <br>            DbgWaitForSingleObject(m_hSem); <br>            continue; <br>        } <br> <br> <br> <br>        //  OK - send it if there's anything to send <br>        //  We DON'T check m_bBatchExact here because either we've got <br>        //  a full batch or we dropped through because we got <br>        //  SEND_PACKET or EOS_PACKET - both of which imply we should <br>        //  flush our batch <br> <br>        if (lNumberToSend != 0) { <br>            long nProcessed; <br>            if (m_hr == S_OK) { <br>                ASSERT(!m_bFlushed); <br>                HRESULT hr = m_pInputPin-&gt;ReceiveMultiple(m_ppSamples, <br>                                                          lNumberToSend, <br>                                                          &amp;nProcessed); <br>                /*  Don't overwrite a flushing state HRESULT */ <br>                CAutoLock lck(this); <br>                if (m_hr == S_OK) { <br>                    m_hr = hr; <br>                } <br>                ASSERT(!m_bFlushed); <br>            } <br>            while (lNumberToSend != 0) { <br>                m_ppSamples[--lNumberToSend]-&gt;Release(); <br>            } <br>            if (m_hr != S_OK) { <br> <br>                //  In any case wait for more data - S_OK just <br>                //  means there wasn't an error <br> <br>                DbgLog((LOG_ERROR, 2, TEXT("ReceiveMultiple returned %8.8X"), <br>                       m_hr)); <br>            } <br>        } <br> <br>        //  Check for end of stream <br> <br>        if (pSample == EOS_PACKET) { <br> <br>            //  We don't send even end of stream on if we've previously <br>            //  returned something other than S_OK <br>            //  This is because in that case the pin which returned <br>            //  something other than S_OK should have either sent <br>            //  EndOfStream() or notified the filter graph <br> <br>            if (m_hr == S_OK) { <br>                DbgLog((LOG_TRACE, 2, TEXT("COutputQueue sending EndOfStream()"))); <br>                HRESULT hr = m_pPin-&gt;EndOfStream(); <br>                if (FAILED(hr)) { <br>                    DbgLog((LOG_ERROR, 2, TEXT("COutputQueue got code 0x%8.8X from EndOfStream()"))); <br>                } <br>            } <br>        } <br> <br>        //  Data from a new source <br> <br>        if (pSample == RESET_PACKET) { <br>            m_hr = S_OK; <br>            SetEvent(m_evFlushComplete); <br>        } <br> <br>        if (pSample == NEW_SEGMENT) { <br>            m_pPin-&gt;NewSegment(ppacket-&gt;tStart, ppacket-&gt;tStop, ppacket-&gt;dRate); <br>            delete ppacket; <br>        } <br>    } <br>} <br> <br>//  Send batched stuff anyway <br>void COutputQueue::SendAnyway() <br>{ <br>    if (!IsQueued()) { <br> <br>        //  m_bSendAnyway is a secret hack parameter to ReceiveMultiple <br> <br>        m_bSendAnyway = TRUE; <br>        LONG nProcessed; <br>        ReceiveMultiple(NULL, 0, &amp;nProcessed); <br>        m_bSendAnyway = FALSE; <br> <br>    } else { <br>        CAutoLock lck(this); <br>        QueueSample(SEND_PACKET); <br>        NotifyThread(); <br>    } <br>} <br> <br>void <br>COutputQueue::NewSegment( <br>    REFERENCE_TIME tStart, <br>    REFERENCE_TIME tStop, <br>    double dRate) <br>{ <br>    if (!IsQueued()) { <br>        if (S_OK == m_hr) { <br>            if (m_bBatchExact) { <br>                SendAnyway(); <br>            } <br>            m_pPin-&gt;NewSegment(tStart, tStop, dRate); <br>        } <br>    } else { <br>        if (m_hr == S_OK) { <br>            // <br>            // we need to queue the new segment to appear in order in the <br>            // data, but we need to pass parameters to it. Rather than <br>            // take the hit of wrapping every single sample so we can tell <br>            // special ones apart, we queue special pointers to indicate <br>            // special packets, and we guarantee (by holding the <br>            // critical section) that the packet immediately following a <br>            // NEW_SEGMENT value is a NewSegmentPacket containing the <br>            // parameters. <br>            NewSegmentPacket * ppack = new NewSegmentPacket; <br>            if (ppack == NULL) { <br>                return; <br>            } <br>            ppack-&gt;tStart = tStart; <br>            ppack-&gt;tStop = tStop; <br>            ppack-&gt;dRate = dRate; <br> <br>            CAutoLock lck(this); <br>            QueueSample(NEW_SEGMENT); <br>            QueueSample( (IMediaSample*) ppack); <br>            NotifyThread(); <br>        } <br>    } <br>} <br> <br> <br>// <br>//  End of Stream is queued to output device <br>// <br>void COutputQueue::EOS() <br>{ <br>    CAutoLock lck(this); <br>    if (!IsQueued()) { <br>        if (m_bBatchExact) { <br>            SendAnyway(); <br>        } <br>        if (m_hr == S_OK) { <br>            DbgLog((LOG_TRACE, 2, TEXT("COutputQueue sending EndOfStream()"))); <br>            m_bFlushed = FALSE; <br>            HRESULT hr = m_pPin-&gt;EndOfStream(); <br>            if (FAILED(hr)) { <br>                DbgLog((LOG_ERROR, 2, TEXT("COutputQueue got code 0x%8.8X from EndOfStream()"))); <br>            } <br>        } <br>    } else { <br>        if (m_hr == S_OK) { <br>            m_bFlushed = FALSE; <br>            QueueSample(EOS_PACKET); <br>            NotifyThread(); <br>        } <br>    } <br>} <br> <br>// <br>//  Flush all the samples in the queue <br>// <br>void COutputQueue::BeginFlush() <br>{ <br>    if (IsQueued()) { <br>        { <br>            CAutoLock lck(this); <br> <br>            // block receives -- we assume this is done by the <br>            // filter in which we are a component <br> <br>            // discard all queued data <br> <br>            m_bFlushing = TRUE; <br> <br>            //  Make sure we discard all samples from now on <br> <br>            if (m_hr == S_OK) { <br>                m_hr = S_FALSE; <br>            } <br> <br>            // Optimize so we don't keep calling downstream all the time <br> <br>            if (m_bFlushed) { <br>                return; <br>            } <br> <br>            // Make sure we really wait for the flush to complete <br>            m_evFlushComplete.Reset(); <br> <br>            NotifyThread(); <br>        } <br> <br>        // pass this downstream <br> <br>        m_pPin-&gt;BeginFlush(); <br>    } else { <br>        // pass downstream first to avoid deadlocks <br>        m_pPin-&gt;BeginFlush(); <br>        CAutoLock lck(this); <br>        // discard all queued data <br> <br>        m_bFlushing = TRUE; <br> <br>        //  Make sure we discard all samples from now on <br> <br>        if (m_hr == S_OK) { <br>            m_hr = S_FALSE; <br>        } <br>    } <br> <br>} <br> <br>// <br>// leave flush mode - pass this downstream <br>void COutputQueue::EndFlush() <br>{ <br>    { <br>        CAutoLock lck(this); <br>        ASSERT(m_bFlushing); <br>        if (m_bFlushed &amp;&amp; IsQueued()) { <br>            m_bFlushing = FALSE; <br>            m_hr = S_OK; <br>            return; <br>        } <br>    } <br> <br>    // sync with pushing thread -- done in BeginFlush <br>    // ensure no more data to go downstream -- done in BeginFlush <br>    // <br>    // Because we are synching here there is no need to hold the critical <br>    // section (in fact we'd deadlock if we did!) <br> <br>    if (IsQueued()) { <br>        m_evFlushComplete.Wait(); <br>    } else { <br>        FreeSamples(); <br>    } <br> <br>    //  Be daring - the caller has guaranteed no samples will arrive <br>    //  before EndFlush() returns <br> <br>    m_bFlushing = FALSE; <br>    m_bFlushed  = TRUE; <br> <br>    // call EndFlush on downstream pins <br> <br>    m_pPin-&gt;EndFlush(); <br> <br>    m_hr = S_OK; <br>} <br> <br>//  COutputQueue::QueueSample <br>// <br>//  private method to Send a sample to the output queue <br>//  The critical section MUST be held when this is called <br> <br>void COutputQueue::QueueSample(IMediaSample *pSample) <br>{ <br>    if (NULL == m_List-&gt;AddTail(pSample)) { <br>        if (!IsSpecialSample(pSample)) { <br>            pSample-&gt;Release(); <br>        } <br>    } <br>} <br> <br>// <br>//  COutputQueue::Receive() <br>// <br>//  Send a single sample by the multiple sample route <br>//  (NOTE - this could be optimized if necessary) <br>// <br>//  On return the sample will have been Release()'d <br>// <br> <br>HRESULT COutputQueue::Receive(IMediaSample *pSample) <br>{ <br>    LONG nProcessed; <br>    return ReceiveMultiple(&amp;pSample, 1, &amp;nProcessed); <br>} <br> <br>// <br>//  COutputQueue::ReceiveMultiple() <br>// <br>//  Send a set of samples to the downstream pin <br>// <br>//      ppSamples           - array of samples <br>//      nSamples            - how many <br>//      nSamplesProcessed   - How many were processed <br>// <br>//  On return all samples will have been Release()'d <br>// <br> <br>HRESULT COutputQueue::ReceiveMultiple ( <br>    IMediaSample **ppSamples, <br>    long nSamples, <br>    long *nSamplesProcessed) <br>{ <br>    CAutoLock lck(this); <br>    //  Either call directly or queue up the samples <br> <br>    if (!IsQueued()) { <br> <br>        //  If we already had a bad return code then just return <br> <br>        if (S_OK != m_hr) { <br> <br>            //  If we've never received anything since the last Flush() <br>            //  and the sticky return code is not S_OK we must be <br>            //  flushing <br>            //  ((!A || B) is equivalent to A implies B) <br>            ASSERT(!m_bFlushed || m_bFlushing); <br> <br>            //  We're supposed to Release() them anyway! <br>            *nSamplesProcessed = 0; <br>            for (int i = 0; i &lt; nSamples; i++) { <br>                DbgLog((LOG_TRACE, 3, TEXT("COutputQueue (direct) : Discarding %d samples code 0x%8.8X"), <br>                        nSamples, m_hr)); <br>                ppSamples[i]-&gt;Release(); <br>            } <br> <br>            return m_hr; <br>        } <br>        // <br>        //  If we're flushing the sticky return code should be S_FALSE <br>        // <br>        ASSERT(!m_bFlushing); <br>        m_bFlushed = FALSE; <br> <br>        ASSERT(m_nBatched &lt; m_lBatchSize); <br>        ASSERT(m_nBatched == 0 || m_bBatchExact); <br> <br>        //  Loop processing the samples in batches <br> <br>        LONG iLost = 0; <br>        for (long iDone = 0; <br>             iDone &lt; nSamples || (m_nBatched != 0 &amp;&amp; m_bSendAnyway); <br>            ) { <br> <br>//pragma message (REMIND("Implement threshold scheme")) <br>            ASSERT(m_nBatched &lt; m_lBatchSize); <br>            if (iDone &lt; nSamples) { <br>                m_ppSamples[m_nBatched++] = ppSamples[iDone++]; <br>            } <br>            if (m_nBatched == m_lBatchSize || <br>                nSamples == 0 &amp;&amp; (m_bSendAnyway || !m_bBatchExact)) { <br>                LONG nDone; <br>                DbgLog((LOG_TRACE, 4, TEXT("Batching %d samples"), <br>                       m_nBatched)); <br> <br>                if (m_hr == S_OK) { <br>                    m_hr = m_pInputPin-&gt;ReceiveMultiple(m_ppSamples, <br>                                                        m_nBatched, <br>                                                        &amp;nDone); <br>                } else { <br>                    nDone = 0; <br>                } <br>                iLost += m_nBatched - nDone; <br>                for (LONG i = 0; i &lt; m_nBatched; i++) { <br>                    m_ppSamples[i]-&gt;Release(); <br>                } <br>                m_nBatched = 0; <br>            } <br>        } <br>        *nSamplesProcessed = iDone - iLost; <br>        if (*nSamplesProcessed &lt; 0) { <br>            *nSamplesProcessed = 0; <br>        } <br>        return m_hr; <br>    } else { <br>        /*  We're sending to our thread */ <br> <br>        if (m_hr != S_OK) { <br>            *nSamplesProcessed = 0; <br>            DbgLog((LOG_TRACE, 3, TEXT("COutputQueue (queued) : Discarding %d samples code 0x%8.8X"), <br>                    nSamples, m_hr)); <br>            for (int i = 0; i &lt; nSamples; i++) { <br>                ppSamples[i]-&gt;Release(); <br>            } <br>            return m_hr; <br>        } <br>        m_bFlushed = FALSE; <br>        for (long i = 0; i &lt; nSamples; i++) { <br>            QueueSample(ppSamples[i]); <br>        } <br>        *nSamplesProcessed = nSamples; <br>        if (!m_bBatchExact || <br>            m_nBatched + m_List-&gt;GetCount() &gt;= m_lBatchSize) { <br>            NotifyThread(); <br>        } <br>        return S_OK; <br>    } <br>} <br> <br>//  Get ready for new data - cancels sticky m_hr <br>void COutputQueue::Reset() <br>{ <br>    if (!IsQueued()) { <br>        m_hr = S_OK; <br>    } else { <br>        CAutoLock lck(this); <br>        QueueSample(RESET_PACKET); <br>        NotifyThread(); <br>        m_evFlushComplete.Wait(); <br>    } <br>} <br> <br>//  Remove and Release() all queued and Batched samples <br>void COutputQueue::FreeSamples() <br>{ <br>    CAutoLock lck(this); <br>    if (IsQueued()) { <br>        while (TRUE) { <br>            IMediaSample *pSample = m_List-&gt;RemoveHead(); <br>            if (pSample == NULL) { <br>                break; <br>            } <br>            if (!IsSpecialSample(pSample)) { <br>                pSample-&gt;Release(); <br>            } else { <br>                if (pSample == NEW_SEGMENT) { <br>                    //  Free NEW_SEGMENT packet <br>                    NewSegmentPacket *ppacket = <br>                        (NewSegmentPacket *) m_List-&gt;RemoveHead(); <br>                    ASSERT(ppacket != NULL); <br>                    delete ppacket; <br>                } <br>            } <br>        } <br>    } <br>    for (int i = 0; i &lt; m_nBatched; i++) { <br>        m_ppSamples[i]-&gt;Release(); <br>    } <br>    m_nBatched = 0; <br>} <br> <br>//  Notify the thread if there is something to do <br>// <br>//  The critical section MUST be held when this is called <br>void COutputQueue::NotifyThread() <br>{ <br>    //  Optimize - no need to signal if it's not waiting <br>    ASSERT(IsQueued()); <br>    if (m_lWaiting) { <br>        ReleaseSemaphore(m_hSem, m_lWaiting, NULL); <br>        m_lWaiting = 0; <br>    } <br>} <br> <br>//  See if there's any work to do <br>//  Returns <br>//      TRUE  if there is nothing on the queue and nothing in the batch <br>//            and all data has been sent <br>//      FALSE otherwise <br>// <br>BOOL COutputQueue::IsIdle() <br>{ <br>    CAutoLock lck(this); <br> <br>    //  We're idle if <br>    //      there is no thread (!IsQueued()) OR <br>    //      the thread is waiting for more work  (m_lWaiting != 0) <br>    //  AND <br>    //      there's nothing in the current batch (m_nBatched == 0) <br> <br>    if (IsQueued() &amp;&amp; m_lWaiting == 0 || m_nBatched != 0) { <br>        return FALSE; <br>    } else { <br> <br>        //  If we're idle it shouldn't be possible for there <br>        //  to be anything on the work queue <br> <br>        ASSERT(!IsQueued() || m_List-&gt;GetCount() == 0); <br>        return TRUE; <br>    } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
