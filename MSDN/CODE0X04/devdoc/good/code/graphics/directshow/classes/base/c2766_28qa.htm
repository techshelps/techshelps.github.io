<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>VIDEOCTL.H</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2782"></a>VIDEOCTL.H</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>#ifndef __VIDEOCTL__ <br>#define __VIDEOCTL__ <br> <br>// These help with property page implementations. The first can be used to <br>// load any string from a resource file. The buffer to load into is passed <br>// as an input parameter. The same buffer is the return value if the string <br>// was found otherwise it returns TEXT(""). The GetDialogSize is passed the <br>// resource ID of a dialog box and returns the size of it in screen pixels <br> <br>#define STR_MAX_LENGTH 256 <br>TCHAR * WINAPI StringFromResource(TCHAR *pBuffer, int iResourceID); <br> <br>#ifdef UNICODE <br>#define WideStringFromResource StringFromResource <br>#else <br>WCHAR * WINAPI WideStringFromResource(WCHAR *pBuffer, int iResourceID); <br>#endif <br> <br> <br>BOOL WINAPI GetDialogSize(int iResourceID,     // Dialog box resource identifier <br>                          DLGPROC pDlgProc,    // Pointer to dialog procedure <br>                          LPARAM lParam,       // Any user data wanted in pDlgProc <br>                          SIZE *pResult);      // Returns the size of dialog box <br> <br>// Class that aggregates an IDirectDraw interface <br> <br>class CAggDirectDraw : public IDirectDraw, public CUnknown <br>{ <br>protected: <br> <br>    LPDIRECTDRAW m_pDirectDraw; <br> <br>public: <br> <br>    DECLARE_IUNKNOWN <br>    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv); <br> <br>    // Constructor and destructor <br> <br>    CAggDirectDraw(TCHAR *pName,LPUNKNOWN pUnk) : <br>        CUnknown(pName,pUnk), <br>        m_pDirectDraw(NULL) { }; <br> <br>    virtual CAggDirectDraw::~CAggDirectDraw() { }; <br> <br>    // Set the object we should be aggregating <br>    void SetDirectDraw(LPDIRECTDRAW pDirectDraw) { <br>        m_pDirectDraw = pDirectDraw; <br>    } <br> <br>    // IDirectDraw methods <br> <br>    STDMETHODIMP Compact(); <br>    STDMETHODIMP CreateClipper(DWORD dwFlags,LPDIRECTDRAWCLIPPER *lplpDDClipper,IUnknown *pUnkOuter); <br>    STDMETHODIMP CreatePalette(DWORD dwFlags,LPPALETTEENTRY lpColorTable,LPDIRECTDRAWPALETTE *lplpDDPalette,IUnknown *pUnkOuter); <br>    STDMETHODIMP CreateSurface(LPDDSURFACEDESC lpDDSurfaceDesc,LPDIRECTDRAWSURFACE *lplpDDSurface,IUnknown *pUnkOuter); <br>    STDMETHODIMP DuplicateSurface(LPDIRECTDRAWSURFACE lpDDSurface,LPDIRECTDRAWSURFACE *lplpDupDDSurface); <br>    STDMETHODIMP EnumDisplayModes(DWORD dwSurfaceDescCount,LPDDSURFACEDESC lplpDDSurfaceDescList,LPVOID lpContext,LPDDENUMMODESCALLBACK lpEnumCallback); <br>    STDMETHODIMP EnumSurfaces(DWORD dwFlags,LPDDSURFACEDESC lpDDSD,LPVOID lpContext,LPDDENUMSURFACESCALLBACK lpEnumCallback); <br>    STDMETHODIMP FlipToGDISurface(); <br>    STDMETHODIMP GetCaps(LPDDCAPS lpDDDriverCaps,LPDDCAPS lpDDHELCaps); <br>    STDMETHODIMP GetDisplayMode(LPDDSURFACEDESC lpDDSurfaceDesc); <br>    STDMETHODIMP GetFourCCCodes(LPDWORD lpNumCodes,LPDWORD lpCodes); <br>    STDMETHODIMP GetGDISurface(LPDIRECTDRAWSURFACE *lplpGDIDDSurface); <br>    STDMETHODIMP GetMonitorFrequency(LPDWORD lpdwFrequency); <br>    STDMETHODIMP GetScanLine(LPDWORD lpdwScanLine); <br>    STDMETHODIMP GetVerticalBlankStatus(LPBOOL lpblsInVB); <br>    STDMETHODIMP Initialize(GUID *lpGUID); <br>    STDMETHODIMP RestoreDisplayMode(); <br>    STDMETHODIMP SetCooperativeLevel(HWND hWnd,DWORD dwFlags); <br>    STDMETHODIMP SetDisplayMode(DWORD dwWidth,DWORD dwHeight,DWORD dwBpp); <br>    STDMETHODIMP WaitForVerticalBlank(DWORD dwFlags,HANDLE hEvent); <br>}; <br> <br> <br>// Class that aggregates an IDirectDrawSurface interface <br> <br>class CAggDrawSurface : public IDirectDrawSurface, public CUnknown <br>{ <br>protected: <br> <br>    LPDIRECTDRAWSURFACE m_pDirectDrawSurface; <br> <br>public: <br> <br>    DECLARE_IUNKNOWN <br>    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv); <br> <br>    // Constructor and destructor <br> <br>    CAggDrawSurface(TCHAR *pName,LPUNKNOWN pUnk) : <br>        CUnknown(pName,pUnk), <br>        m_pDirectDrawSurface(NULL) { }; <br> <br>    virtual ~CAggDrawSurface() { }; <br> <br>    // Set the object we should be aggregating <br>    void SetDirectDrawSurface(LPDIRECTDRAWSURFACE pDirectDrawSurface) { <br>        m_pDirectDrawSurface = pDirectDrawSurface; <br>    } <br> <br>    // IDirectDrawSurface methods <br> <br>    STDMETHODIMP AddAttachedSurface(LPDIRECTDRAWSURFACE lpDDSAttachedSurface); <br>    STDMETHODIMP AddOverlayDirtyRect(LPRECT lpRect); <br>    STDMETHODIMP Blt(LPRECT lpDestRect,LPDIRECTDRAWSURFACE lpDDSrcSurface,LPRECT lpSrcRect,DWORD dwFlags,LPDDBLTFX lpDDBltFx); <br>    STDMETHODIMP BltBatch(LPDDBLTBATCH lpDDBltBatch,DWORD dwCount,DWORD dwFlags); <br>    STDMETHODIMP BltFast(DWORD dwX,DWORD dwY,LPDIRECTDRAWSURFACE lpDDSrcSurface,LPRECT lpSrcRect,DWORD dwTrans); <br>    STDMETHODIMP DeleteAttachedSurface(DWORD dwFlags,LPDIRECTDRAWSURFACE lpDDSAttachedSurface); <br>    STDMETHODIMP EnumAttachedSurfaces(LPVOID lpContext,LPDDENUMSURFACESCALLBACK lpEnumSurfacesCallback); <br>    STDMETHODIMP EnumOverlayZOrders(DWORD dwFlags,LPVOID lpContext,LPDDENUMSURFACESCALLBACK lpfnCallback); <br>    STDMETHODIMP Flip(LPDIRECTDRAWSURFACE lpDDSurfaceTargetOverride,DWORD dwFlags); <br>    STDMETHODIMP GetAttachedSurface(LPDDSCAPS lpDDSCaps,LPDIRECTDRAWSURFACE *lplpDDAttachedSurface); <br>    STDMETHODIMP GetBltStatus(DWORD dwFlags); <br>    STDMETHODIMP GetCaps(LPDDSCAPS lpDDSCaps); <br>    STDMETHODIMP GetClipper(LPDIRECTDRAWCLIPPER *lplpDDClipper); <br>    STDMETHODIMP GetColorKey(DWORD dwFlags,LPDDCOLORKEY lpDDColorKey); <br>    STDMETHODIMP GetDC(HDC *lphDC); <br>    STDMETHODIMP GetFlipStatus(DWORD dwFlags); <br>    STDMETHODIMP GetOverlayPosition(LPLONG lpdwX,LPLONG lpdwY); <br>    STDMETHODIMP GetPalette(LPDIRECTDRAWPALETTE *lplpDDPalette); <br>    STDMETHODIMP GetPixelFormat(LPDDPIXELFORMAT lpDDPixelFormat); <br>    STDMETHODIMP GetSurfaceDesc(LPDDSURFACEDESC lpDDSurfaceDesc); <br>    STDMETHODIMP Initialize(LPDIRECTDRAW lpDD,LPDDSURFACEDESC lpDDSurfaceDesc); <br>    STDMETHODIMP IsLost(); <br>    STDMETHODIMP Lock(LPRECT lpDestRect,LPDDSURFACEDESC lpDDSurfaceDesc,DWORD dwFlags,HANDLE hEvent); <br>    STDMETHODIMP ReleaseDC(HDC hDC); <br>    STDMETHODIMP Restore(); <br>    STDMETHODIMP SetClipper(LPDIRECTDRAWCLIPPER lpDDClipper); <br>    STDMETHODIMP SetColorKey(DWORD dwFlags,LPDDCOLORKEY lpDDColorKey); <br>    STDMETHODIMP SetOverlayPosition(LONG dwX,LONG dwY); <br>    STDMETHODIMP SetPalette(LPDIRECTDRAWPALETTE lpDDPalette); <br>    STDMETHODIMP Unlock(LPVOID lpSurfaceData); <br>    STDMETHODIMP UpdateOverlay(LPRECT lpSrcRect,LPDIRECTDRAWSURFACE lpDDDestSurface,LPRECT lpDestRect,DWORD dwFlags,LPDDOVERLAYFX lpDDOverlayFX); <br>    STDMETHODIMP UpdateOverlayDisplay(DWORD dwFlags); <br>    STDMETHODIMP UpdateOverlayZOrder(DWORD dwFlags,LPDIRECTDRAWSURFACE lpDDSReference); <br>}; <br> <br> <br>// ActiveMovie must work on multiple platforms, in particular it also runs on <br>// Windows NT 3.51 which does not have DirectDraw capabilities. The filters <br>// cannot therefore link statically to the DirectDraw library. To make their <br>// lives that little bit easier we provide this class that manages loading <br>// and unloading the library and creating the initial IDirectDraw interface <br> <br>typedef DWORD (WINAPI *PGETFILEVERSIONINFOSIZE)(LPTSTR,LPDWORD); <br>typedef BOOL (WINAPI *PGETFILEVERSIONINFO)(LPTSTR,DWORD,DWORD,LPVOID); <br>typedef BOOL (WINAPI *PVERQUERYVALUE)(LPVOID,LPTSTR,LPVOID,PUINT); <br> <br>class CLoadDirectDraw <br>{ <br>    LPDIRECTDRAW m_pDirectDraw;     // The DirectDraw driver instance <br>    HINSTANCE m_hDirectDraw;        // Handle to the loaded library <br> <br>public: <br> <br>    CLoadDirectDraw(); <br>    ~CLoadDirectDraw(); <br> <br>    HRESULT LoadDirectDraw(LPSTR szDevice); <br>    void ReleaseDirectDraw(); <br>    HRESULT IsDirectDrawLoaded(); <br>    LPDIRECTDRAW GetDirectDraw(); <br>    BOOL IsDirectDrawVersion1(); <br>}; <br> <br>#endif // __VIDEOCTL__ <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
