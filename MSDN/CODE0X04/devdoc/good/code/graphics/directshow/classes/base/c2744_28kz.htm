<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MTYPE.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2753"></a>MTYPE.CPP</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>// Class that holds and manages media type information, December 1994 <br> <br>// helper class that derived pin objects can use to compare media <br>// types etc. Has same data members as the struct AM_MEDIA_TYPE defined <br>// in the streams IDL file, but also has (non-virtual) functions <br> <br>#include &lt;streams.h&gt; <br> <br>CMediaType::~CMediaType(){ <br>    FreeMediaType(*this); <br>} <br> <br> <br>CMediaType::CMediaType() <br>{ <br>    InitMediaType(); <br>} <br> <br> <br>CMediaType::CMediaType(const GUID * type) <br>{ <br>    InitMediaType(); <br>    majortype = *type; <br>} <br> <br> <br>// copy constructor does a deep copy of the format block <br> <br>CMediaType::CMediaType(const AM_MEDIA_TYPE&amp; rt) <br>{ <br>    CopyMediaType(this, &amp;rt); <br>} <br> <br>CMediaType::CMediaType(const CMediaType&amp; rt) <br>{ <br>    CopyMediaType(this, &amp;rt); <br>} <br> <br>// this class inherits publicly from AM_MEDIA_TYPE so the compiler could generate <br>// the following assignment operator itself, however it could introduce some <br>// memory conflicts and leaks in the process because the structure contains <br>// a dynamically allocated block (pbFormat) which it will not copy correctly <br> <br>CMediaType&amp; <br>CMediaType::operator=(const AM_MEDIA_TYPE&amp; rt) <br>{ <br>    FreeMediaType(*this); <br>    CopyMediaType(this, &amp;rt); <br>    return *this; <br>} <br> <br> <br>CMediaType&amp; <br>CMediaType::operator=(const CMediaType&amp; rt) <br>{ <br>    *this = (AM_MEDIA_TYPE &amp;) rt; <br>    return *this; <br>} <br> <br>BOOL <br>CMediaType::operator == (const CMediaType&amp; rt) const <br>{ <br>    // I don't believe we need to check sample size or <br>    // temporal compression flags, since I think these must <br>    // be represented in the type, subtype and format somehow. They <br>    // are pulled out as separate flags so that people who don't understand <br>    // the particular format representation can still see them, but <br>    // they should duplicate information in the format block. <br> <br>    return ((IsEqualGUID(majortype,rt.majortype) == TRUE) &amp;&amp; <br>        (IsEqualGUID(subtype,rt.subtype) == TRUE) &amp;&amp; <br>        (IsEqualGUID(formattype,rt.formattype) == TRUE) &amp;&amp; <br>        (cbFormat == rt.cbFormat) &amp;&amp; <br>        ( (cbFormat == 0) || <br>          (memcmp(pbFormat, rt.pbFormat, cbFormat) == 0))); <br>} <br> <br> <br>BOOL <br>CMediaType::operator != (const CMediaType&amp; rt) const <br>{ <br>    /* Check to see if they are equal */ <br> <br>    if (*this == rt) { <br>        return FALSE; <br>    } <br>    return TRUE; <br>} <br> <br> <br>BOOL <br>CMediaType::IsValid() const <br>{ <br>    return (!IsEqualGUID(majortype,GUID_NULL)); <br>} <br> <br> <br>void <br>CMediaType::SetType(const GUID* ptype) <br>{ <br>    majortype = *ptype; <br>} <br> <br> <br>void <br>CMediaType::SetSubtype(const GUID* ptype) <br>{ <br>    subtype = *ptype; <br>} <br> <br> <br>ULONG <br>CMediaType::GetSampleSize() const { <br>    if (IsFixedSize()) { <br>        return lSampleSize; <br>    } else { <br>        return 0; <br>    } <br>} <br> <br> <br>void <br>CMediaType::SetSampleSize(ULONG sz) { <br>    if (sz == 0) { <br>        SetVariableSize(); <br>    } else { <br>        bFixedSizeSamples = TRUE; <br>        lSampleSize = sz; <br>    } <br>} <br> <br> <br>void <br>CMediaType::SetVariableSize() { <br>    bFixedSizeSamples = FALSE; <br>} <br> <br> <br>void <br>CMediaType::SetTemporalCompression(BOOL bCompressed) { <br>    bTemporalCompression = bCompressed; <br>} <br> <br>BOOL <br>CMediaType::SetFormat(BYTE * pformat, ULONG cb) <br>{ <br>    if (NULL == AllocFormatBuffer(cb)) <br>return(FALSE); <br> <br>    ASSERT(pbFormat); <br>    memcpy(pbFormat, pformat, cb); <br>    return(TRUE); <br>} <br> <br> <br>// set the type of the media type format block, this type defines what you <br>// will actually find in the format pointer. For example FORMAT_VideoInfo or <br>// FORMAT_WaveFormatEx. In the future this may be an interface pointer to a <br>// property set. Before sending out media types this should be filled in. <br> <br>void <br>CMediaType::SetFormatType(const GUID *pformattype) <br>{ <br>    formattype = *pformattype; <br>} <br> <br> <br>// reset the format buffer <br> <br>void CMediaType::ResetFormatBuffer() <br>{ <br>    if (cbFormat) { <br>        CoTaskMemFree((PVOID)pbFormat); <br>    } <br>    cbFormat = 0; <br>    pbFormat = NULL; <br>} <br> <br> <br>// allocate length bytes for the format and return a read/write pointer <br>// If we cannot allocate the new block of memory we return NULL leaving <br>// the original block of memory untouched (as does ReallocFormatBuffer) <br> <br>BYTE* <br>CMediaType::AllocFormatBuffer(ULONG length) <br>{ <br>    ASSERT(length); <br> <br>    // do the types have the same buffer size <br> <br>    if (cbFormat == length) { <br>        return pbFormat; <br>    } <br> <br>    // allocate the new format buffer <br> <br>    BYTE *pNewFormat = (PBYTE)CoTaskMemAlloc(length); <br>    if (pNewFormat == NULL) { <br>        if (length &lt;= cbFormat) return pbFormat; //reuse the old block anyway. <br>        return NULL; <br>    } <br> <br>    // delete the old format <br> <br>    if (cbFormat != 0) { <br>        ASSERT(pbFormat); <br>        CoTaskMemFree((PVOID)pbFormat); <br>    } <br> <br>    cbFormat = length; <br>    pbFormat = pNewFormat; <br>    return pbFormat; <br>} <br> <br> <br>// reallocate length bytes for the format and return a read/write pointer <br>// to it. We keep as much information as we can given the new buffer size <br>// if this fails the original format buffer is left untouched. The caller <br>// is responsible for ensuring the size of memory required is non zero <br> <br>BYTE* <br>CMediaType::ReallocFormatBuffer(ULONG length) <br>{ <br>    ASSERT(length); <br> <br>    // do the types have the same buffer size <br> <br>    if (cbFormat == length) { <br>        return pbFormat; <br>    } <br> <br>    // allocate the new format buffer <br> <br>    BYTE *pNewFormat = (PBYTE)CoTaskMemAlloc(length); <br>    if (pNewFormat == NULL) { <br>        if (length &lt;= cbFormat) return pbFormat; //reuse the old block anyway. <br>        return NULL; <br>    } <br> <br>    // copy any previous format (or part of if new is smaller) <br>    // delete the old format and replace with the new one <br> <br>    if (cbFormat != 0) { <br>        ASSERT(pbFormat); <br>        memcpy(pNewFormat,pbFormat,min(length,cbFormat)); <br>        CoTaskMemFree((PVOID)pbFormat); <br>    } <br> <br>    cbFormat = length; <br>    pbFormat = pNewFormat; <br>    return pNewFormat; <br>} <br> <br>// initialise a media type structure <br> <br>void CMediaType::InitMediaType() <br>{ <br>    ZeroMemory((PVOID)this, sizeof(*this)); <br>    lSampleSize = 1; <br>    bFixedSizeSamples = TRUE; <br>} <br> <br> <br>// a partially specified media type can be passed to IPin::Connect <br>// as a constraint on the media type used in the connection. <br>// the type, subtype or format type can be null. <br>BOOL <br>CMediaType::IsPartiallySpecified(void) const <br>{ <br>    if ((majortype == GUID_NULL) || <br>        (formattype == GUID_NULL)) { <br>            return TRUE; <br>    } else { <br>        return FALSE; <br>    } <br>} <br> <br>BOOL <br>CMediaType::MatchesPartial(const CMediaType* ppartial) const <br>{ <br>    if ((ppartial-&gt;majortype != GUID_NULL) &amp;&amp; <br>        (majortype != ppartial-&gt;majortype)) { <br>            return FALSE; <br>    } <br>    if ((ppartial-&gt;subtype != GUID_NULL) &amp;&amp; <br>        (subtype != ppartial-&gt;subtype)) { <br>            return FALSE; <br>    } <br> <br>    if (ppartial-&gt;formattype != GUID_NULL) { <br>        // if the format block is specified then it must match exactly <br>        if (formattype != ppartial-&gt;formattype) { <br>            return FALSE; <br>        } <br>        if (cbFormat != ppartial-&gt;cbFormat) { <br>            return FALSE; <br>        } <br>        if ((cbFormat != 0) &amp;&amp; <br>            (memcmp(pbFormat, ppartial-&gt;pbFormat, cbFormat) != 0)) { <br>                return FALSE; <br>        } <br>    } <br> <br>    return TRUE; <br> <br>} <br> <br> <br> <br>// general purpose function to delete a heap allocated AM_MEDIA_TYPE structure <br>// which is useful when calling IEnumMediaTypes::Next as the interface <br>// implementation allocates the structures which you must later delete <br>// the format block may also be a pointer to an interface to release <br> <br>void WINAPI DeleteMediaType(AM_MEDIA_TYPE *pmt) <br>{ <br>    // allow NULL pointers for coding simplicity <br> <br>    if (pmt == NULL) { <br>        return; <br>    } <br> <br>    FreeMediaType(*pmt); <br>    CoTaskMemFree((PVOID)pmt); <br>} <br> <br> <br>// this also comes in useful when using the IEnumMediaTypes interface so <br>// that you can copy a media type, you can do nearly the same by creating <br>// a CMediaType object but as soon as it goes out of scope the destructor <br>// will delete the memory it allocated (this takes a copy of the memory) <br> <br>AM_MEDIA_TYPE * WINAPI CreateMediaType(AM_MEDIA_TYPE const *pSrc) <br>{ <br>    ASSERT(pSrc); <br> <br>    // Allocate a block of memory for the media type <br> <br>    AM_MEDIA_TYPE *pMediaType = <br>        (AM_MEDIA_TYPE *)CoTaskMemAlloc(sizeof(AM_MEDIA_TYPE)); <br> <br>    if (pMediaType == NULL) { <br>        return NULL; <br>    } <br>    // Copy the variable length format block <br> <br>    CopyMediaType(pMediaType,pSrc); <br> <br>    return pMediaType; <br>} <br> <br> <br>//  Copy 1 media type to another <br> <br>void WINAPI CopyMediaType(AM_MEDIA_TYPE *pmtTarget, const AM_MEDIA_TYPE *pmtSource) <br>{ <br>    *pmtTarget = *pmtSource; <br>    if (pmtSource-&gt;cbFormat != 0) { <br>        ASSERT(pmtSource-&gt;pbFormat != NULL); <br>        pmtTarget-&gt;pbFormat = (PBYTE)CoTaskMemAlloc(pmtSource-&gt;cbFormat); <br>        if (pmtTarget-&gt;pbFormat == NULL) { <br>            pmtTarget-&gt;cbFormat = 0; <br>        } else { <br>            CopyMemory((PVOID)pmtTarget-&gt;pbFormat, (PVOID)pmtSource-&gt;pbFormat, <br>                       pmtTarget-&gt;cbFormat); <br>        } <br>    } <br>    if (pmtTarget-&gt;pUnk != NULL) { <br>        pmtTarget-&gt;pUnk-&gt;AddRef(); <br>    } <br>} <br> <br>//  Free an existing media type (ie free resources it holds) <br> <br>void WINAPI FreeMediaType(AM_MEDIA_TYPE&amp; mt) <br>{ <br>    if (mt.cbFormat != 0) { <br>        CoTaskMemFree((PVOID)mt.pbFormat); <br> <br>        // Strictly unnecessary but tidier <br>        mt.cbFormat = 0; <br>        mt.pbFormat = NULL; <br>    } <br>    if (mt.pUnk != NULL) { <br>        mt.pUnk-&gt;Release(); <br>        mt.pUnk = NULL; <br>    } <br>} <br> <br>//  Initialize a media type from a WAVEFORMATEX <br> <br>STDAPI CreateAudioMediaType( <br>    const WAVEFORMATEX *pwfx, <br>    AM_MEDIA_TYPE *pmt, <br>    BOOL bSetFormat <br>) <br>{ <br>    pmt-&gt;majortype            = MEDIATYPE_Audio; <br>    pmt-&gt;subtype              = FOURCCMap(pwfx-&gt;wFormatTag); <br>    pmt-&gt;formattype           = FORMAT_WaveFormatEx; <br>    pmt-&gt;bFixedSizeSamples    = TRUE; <br>    pmt-&gt;bTemporalCompression = FALSE; <br>    pmt-&gt;lSampleSize          = pwfx-&gt;nBlockAlign; <br>    pmt-&gt;pUnk                 = NULL; <br>    if (bSetFormat) { <br>        if (pwfx-&gt;wFormatTag == WAVE_FORMAT_PCM) { <br>            pmt-&gt;cbFormat         = sizeof(WAVEFORMATEX); <br>        } else { <br>            pmt-&gt;cbFormat         = sizeof(WAVEFORMATEX) + pwfx-&gt;cbSize; <br>        } <br>        pmt-&gt;pbFormat             = (PBYTE)CoTaskMemAlloc(pmt-&gt;cbFormat); <br>        if (pmt-&gt;pbFormat == NULL) { <br>            return E_OUTOFMEMORY; <br>        } <br>        if (pwfx-&gt;wFormatTag == WAVE_FORMAT_PCM) { <br>            CopyMemory(pmt-&gt;pbFormat, pwfx, sizeof(PCMWAVEFORMAT)); <br>            ((WAVEFORMATEX *)pmt-&gt;pbFormat)-&gt;cbSize = 0; <br>        } else { <br>            CopyMemory(pmt-&gt;pbFormat, pwfx, pmt-&gt;cbFormat); <br>        } <br>    } <br>    return S_OK; <br>} <br> <br>// eliminate very many spurious warnings from MS compiler <br>#pragma warning(disable:4514) </code></pre>
<p>&nbsp;</p></body>
</HTML>
