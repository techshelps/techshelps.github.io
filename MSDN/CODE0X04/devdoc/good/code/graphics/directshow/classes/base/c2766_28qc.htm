<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>VTRANS.H</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2784"></a>VTRANS.H</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>// Video transform base class. <br>// This class is derived from CTransformFilter, but is specialised to handle <br>// the requirements of video quality control by frame dropping. <br>// This is a non-in-place transform, (i.e. it copies the data) such as a decoder. <br> <br>class CVideoTransformFilter : public CTransformFilter <br>{ <br>  public: <br> <br>    CVideoTransformFilter(TCHAR *, LPUNKNOWN, REFCLSID clsid); <br>    ~CVideoTransformFilter(); <br>    HRESULT EndFlush(); <br> <br>    // ================================================================= <br>    // ----- override these bits --------------------------------------- <br>    // ================================================================= <br>    // The following methods are in CTransformFilter which is inherited. <br>    // They are mentioned here for completeness <br>    // <br>    // These MUST be supplied in a derived class <br>    // <br>    // NOTE: <br>    // virtual HRESULT Transform(IMediaSample * pIn, IMediaSample *pOut); <br>    // virtual HRESULT CheckInputType(const CMediaType* mtIn) PURE; <br>    // virtual HRESULT CheckTransform <br>    //     (const CMediaType* mtIn, const CMediaType* mtOut) PURE; <br>    // static CCOMObject * CreateInstance(LPUNKNOWN, HRESULT *); <br>    // virtual HRESULT DecideBufferSize <br>    //     (IMemAllocator * pAllocator, ALLOCATOR_PROPERTIES *pprop) PURE; <br>    // virtual HRESULT GetMediaType(int iPosition, CMediaType *pMediaType) PURE; <br>    // <br>    // These MAY also be overridden <br>    // <br>    // virtual HRESULT StopStreaming(); <br>    // virtual HRESULT SetMediaType(PIN_DIRECTION direction,const CMediaType *pmt); <br>    // virtual HRESULT CheckConnect(PIN_DIRECTION dir,IPin *pPin); <br>    // virtual HRESULT BreakConnect(PIN_DIRECTION dir); <br>    // virtual HRESULT CompleteConnect(PIN_DIRECTION direction,IPin *pReceivePin); <br>    // virtual HRESULT EndOfStream(void); <br>    // virtual HRESULT BeginFlush(void); <br>    // virtual HRESULT EndFlush(void); <br>    // virtual HRESULT NewSegment <br>    //     (REFERENCE_TIME tStart,REFERENCE_TIME tStop,double dRate); <br>#ifdef PERF <br> <br>    // If you override this - ensure that you register all these ids <br>    // as well as any of your own, <br>    virtual void RegisterPerfId() { <br>        m_idSkip        = MSR_REGISTER("Video Transform Skip frame"); <br>        m_idFrameType   = MSR_REGISTER("Video transform frame type"); <br>        m_idLate        = MSR_REGISTER("Video Transform Lateness"); <br>        m_idTimeTillKey = MSR_REGISTER("Video Transform Estd. time to next key"); <br>        CTransformFilter::RegisterPerfId(); <br>    } <br>#endif <br> <br>  protected: <br> <br>    // =========== QUALITY MANAGEMENT IMPLEMENTATION ======================== <br>    // Frames are assumed to come in three types: <br>    // Type 1: an AVI key frame or an MPEG I frame. <br>    //        This frame can be decoded with no history. <br>    //        Dropping this frame means that no further frame can be decoded <br>    //        until the next type 1 frame. <br>    //        Type 1 frames are sync points. <br>    // Type 2: an AVI non-key frame or an MPEG P frame. <br>    //        This frame cannot be decoded unless the previous type 1 frame was <br>    //        decoded and all type 2 frames since have been decoded. <br>    //        Dropping this frame means that no further frame can be decoded <br>    //        until the next type 1 frame. <br>    // Type 3: An MPEG B frame. <br>    //        This frame cannot be decoded unless the previous type 1 or 2 frame <br>    //        has been decoded AND the subsequent type 1 or 2 frame has also <br>    //        been decoded.  (This requires decoding the frames out of sequence). <br>    //        Dropping this frame affects no other frames.  This implementation <br>    //        does not allow for these.  All non-sync-point frames are treated <br>    //        as being type 2. <br>    // <br>    // The spacing of frames of type 1 in a file is not guaranteed.  There MUST <br>    // be a type 1 frame at (well, near) the start of the file in order to start <br>    // decoding at all.  After that there could be one every half second or so, <br>    // there could be one at the start of each scene (aka "cut", "shot") or <br>    // there could be no more at all. <br>    // If there is only a single type 1 frame then NO FRAMES CAN BE DROPPED <br>    // without losing all the rest of the movie.  There is no way to tell whether <br>    // this is the case, so we find that we are in the gambling business. <br>    // To try to improve the odds, we record the greatest interval between type 1s <br>    // that we have seen and we bet on things being no worse than this in the <br>    // future.  This is of course a poor show, but it's "the only show in town". <br> <br>    // You can tell if it's a type 1 frame by calling IsSyncPoint(). <br>    // there is no architected way to test for a type 3, so you should override <br>    // the quality management here if you have B-frames. <br> <br>    int m_nKeyFramePeriod; // the largest observed interval between type 1 frames <br>                           // 1 means every frame is type 1, 2 means every other. <br> <br>    int m_nFramesSinceKeyFrame; // Used to count frames since the last type 1. <br>                                // becomes the new m_nKeyFramePeriod if greater. <br> <br>    BOOL m_bSkipping;           // we are skipping to the next type 1 frame <br> <br>#ifdef PERF <br>    int m_idFrameType;          // MSR id Frame type.  1=Key, 2="non-key" <br>    int m_idSkip;               // MSR id skipping <br>    int m_idLate;               // MSR id lateness <br>    int m_idTimeTillKey;        // MSR id for guessed time till next key frame. <br>#endif <br> <br>    virtual HRESULT StartStreaming(); <br> <br>    HRESULT Receive(IMediaSample *pSample); <br> <br>    HRESULT AlterQuality(Quality q); <br> <br>    BOOL ShouldSkipFrame(IMediaSample * pIn); <br> <br>    int m_itrLate;              // lateness from last Quality message <br>                                // (this overflows at 214 secs late). <br>    int m_tDecodeStart;         // timeGetTime when decode started. <br>    int m_itrAvgDecode;         // Average decode time in reference units. <br> <br>    BOOL m_bNoSkip;             // debug - no skipping. <br> <br>    // We send an EC_QUALITY_CHANGE notification to the app if we have to degrade. <br>    // We send one when we start degrading, not one for every frame, this means <br>    // we track whether we've sent one yet. <br>    BOOL m_bQualityChanged; <br> <br>    // When non-zero, don't pass anything to renderer until next keyframe <br>    // If there are few keys, give up and eventually draw something <br>    int m_nWaitForKey; <br>}; </code></pre>
<p>&nbsp;</p></body>
</HTML>
