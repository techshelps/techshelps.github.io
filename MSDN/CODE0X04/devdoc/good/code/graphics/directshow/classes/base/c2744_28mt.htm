<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>RENBASE.H</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2765"></a>RENBASE.H</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>// Generic ActiveX base renderer class, December 1995 <br> <br>#ifndef __RENBASE__ <br>#define __RENBASE__ <br> <br>// Forward class declarations <br> <br>class CBaseRenderer; <br>class CBaseVideoRenderer; <br>class CRendererInputPin; <br> <br>// This is our input pin class that channels calls to the renderer <br> <br>class CRendererInputPin : public CBaseInputPin <br>{ <br>protected: <br> <br>    CBaseRenderer *m_pRenderer; <br> <br>public: <br> <br>    CRendererInputPin(CBaseRenderer *pRenderer, <br>                      HRESULT *phr, <br>                      LPCWSTR Name); <br> <br>    // Overriden from the base pin classes <br> <br>    HRESULT BreakConnect(); <br>    HRESULT CompleteConnect(IPin *pReceivePin); <br>    HRESULT SetMediaType(const CMediaType *pmt); <br>    HRESULT CheckMediaType(const CMediaType *pmt); <br>    HRESULT Active(); <br>    HRESULT Inactive(); <br> <br>    // Add rendering behaviour to interface functions <br> <br>    STDMETHODIMP QueryId(LPWSTR *Id); <br>    STDMETHODIMP EndOfStream(); <br>    STDMETHODIMP BeginFlush(); <br>    STDMETHODIMP EndFlush(); <br>    STDMETHODIMP Receive(IMediaSample *pMediaSample); <br> <br>    // Helper <br>    IMemAllocator inline *Allocator() const <br>    { <br>        return m_pAllocator; <br>    } <br>}; <br> <br>// Main renderer class that handles synchronisation and state changes <br> <br>class CBaseRenderer : public CBaseFilter <br>{ <br>protected: <br> <br>    friend class CRendererInputPin; <br> <br>    friend void CALLBACK EndOfStreamTimer(UINT uID,      // Timer identifier <br>                                          UINT uMsg,     // Not currently used <br>                                          DWORD dwUser,  // User information <br>                                          DWORD dw1,     // Windows reserved <br>                                          DWORD dw2);    // Is also reserved <br> <br>    CRendererPosPassThru *m_pPosition;  // Media seeking pass by object <br>    CAMEvent m_RenderEvent;             // Used to signal timer events <br>    CAMEvent m_ThreadSignal;            // Signalled to release worker thread <br>    CAMEvent m_evComplete;              // Signalled when state complete <br>    BOOL m_bAbort;                      // Stop us from rendering more data <br>    BOOL m_bStreaming;                  // Are we currently streaming <br>    DWORD m_dwAdvise;                   // Timer advise cookie <br>    IMediaSample *m_pMediaSample;       // Current image media sample <br>    BOOL m_bEOS;                        // Any more samples in the stream <br>    BOOL m_bEOSDelivered;               // Have we delivered an EC_COMPLETE <br>    CRendererInputPin *m_pInputPin;     // Our renderer input pin object <br>    CCritSec m_InterfaceLock;           // Critical section for interfaces <br>    CCritSec m_RendererLock;            // Controls access to internals <br>    IQualityControl * m_pQSink;         // QualityControl sink <br>    BOOL m_bRepaintStatus;              // Can we signal an EC_REPAINT <br>    //  Avoid some deadlocks by tracking filter during stop <br>    volatile BOOL  m_bInReceive;        // Inside Receive between PrepareReceive <br>                                        // And actually processing the sample <br>    REFERENCE_TIME m_SignalTime;        // Time when we signal EC_COMPLETE <br>    UINT m_EndOfStreamTimer;            // Used to signal end of stream <br> <br>public: <br> <br>    CBaseRenderer(REFCLSID RenderClass, // CLSID for this renderer <br>                  TCHAR *pName,         // Debug ONLY description <br>                  LPUNKNOWN pUnk,       // Aggregated owner object <br>                  HRESULT *phr);        // General OLE return code <br> <br>    ~CBaseRenderer(); <br> <br>    // Overriden to say what interfaces we support and where <br> <br>    virtual HRESULT GetMediaPositionInterface(REFIID riid,void **ppv); <br>    STDMETHODIMP NonDelegatingQueryInterface(REFIID, void **); <br> <br>    virtual HRESULT SourceThreadCanWait(BOOL bCanWait); <br> <br>#ifdef DEBUG <br>    // Debug only dump of the renderer state <br>    void DisplayRendererState(); <br>#endif <br>    virtual HRESULT WaitForRenderTime(); <br>    virtual HRESULT CompleteStateChange(FILTER_STATE OldState); <br> <br>    // Return internal information about this filter <br> <br>    BOOL IsEndOfStream() { return m_bEOS; }; <br>    BOOL IsEndOfStreamDelivered() { return m_bEOSDelivered; }; <br>    BOOL IsStreaming() { return m_bStreaming; }; <br>    void SetAbortSignal(BOOL bAbort) { m_bAbort = bAbort; }; <br>    virtual void OnReceiveFirstSample(IMediaSample *pMediaSample) { }; <br>    CAMEvent *GetRenderEvent() { return &amp;m_RenderEvent; }; <br> <br>    // Permit access to the transition state <br> <br>    void Ready() { m_evComplete.Set(); }; <br>    void NotReady() { m_evComplete.Reset(); }; <br>    BOOL CheckReady() { return m_evComplete.Check(); }; <br> <br>    virtual int GetPinCount(); <br>    virtual CBasePin *GetPin(int n); <br>    FILTER_STATE GetRealState(); <br>    void SendRepaint(); <br>    void SendNotifyWindow(IPin *pPin,HWND hwnd); <br>    BOOL OnDisplayChange(); <br>    void SetRepaintStatus(BOOL bRepaint); <br> <br>    // Override the filter and pin interface functions <br> <br>    STDMETHODIMP Stop(); <br>    STDMETHODIMP Pause(); <br>    STDMETHODIMP Run(REFERENCE_TIME StartTime); <br>    STDMETHODIMP GetState(DWORD dwMSecs,FILTER_STATE *State); <br>    STDMETHODIMP FindPin(LPCWSTR Id, IPin **ppPin); <br> <br>    // These are available for a quality management implementation <br> <br>    virtual void OnRenderStart(IMediaSample *pMediaSample); <br>    virtual void OnRenderEnd(IMediaSample *pMediaSample); <br>    virtual HRESULT OnStartStreaming() { return NOERROR; }; <br>    virtual HRESULT OnStopStreaming() { return NOERROR; }; <br>    virtual void OnWaitStart() { }; <br>    virtual void OnWaitEnd() { }; <br>    virtual void PrepareRender() { }; <br> <br>#ifdef PERF <br>    REFERENCE_TIME m_trRenderStart; // Just before we started drawing <br>                                    // Set in OnRenderStart, Used in OnRenderEnd <br>    int m_idBaseStamp;              // MSR_id for frame time stamp <br>    int m_idBaseRenderTime;         // MSR_id for true wait time <br>    int m_idBaseAccuracy;           // MSR_id for time frame is late (int) <br>#endif <br> <br>    // Quality management implementation for scheduling rendering <br> <br>    virtual BOOL ScheduleSample(IMediaSample *pMediaSample); <br>    virtual HRESULT GetSampleTimes(IMediaSample *pMediaSample, <br>                                   REFERENCE_TIME *pStartTime, <br>                                   REFERENCE_TIME *pEndTime); <br> <br>    virtual HRESULT ShouldDrawSampleNow(IMediaSample *pMediaSample, <br>                                        REFERENCE_TIME *ptrStart, <br>                                        REFERENCE_TIME *ptrEnd); <br> <br>    // Lots of end of stream complexities <br> <br>    void TimerCallback(); <br>    void ResetEndOfStreamTimer(); <br>    HRESULT NotifyEndOfStream(); <br>    virtual HRESULT SendEndOfStream(); <br>    virtual HRESULT ResetEndOfStream(); <br>    virtual HRESULT EndOfStream(); <br> <br>    // Rendering is based around the clock <br> <br>    void SignalTimerFired(); <br>    virtual HRESULT CancelNotification(); <br>    virtual HRESULT ClearPendingSample(); <br> <br>    // Called when the filter changes state <br> <br>    virtual HRESULT Active(); <br>    virtual HRESULT Inactive(); <br>    virtual HRESULT StartStreaming(); <br>    virtual HRESULT StopStreaming(); <br>    virtual HRESULT BeginFlush(); <br>    virtual HRESULT EndFlush(); <br> <br>    // Deal with connections and type changes <br> <br>    virtual HRESULT BreakConnect(); <br>    virtual HRESULT SetMediaType(const CMediaType *pmt); <br>    virtual HRESULT CompleteConnect(IPin *pReceivePin); <br> <br>    // These look after the handling of data samples <br> <br>    virtual HRESULT PrepareReceive(IMediaSample *pMediaSample); <br>    virtual HRESULT Receive(IMediaSample *pMediaSample); <br>    virtual BOOL HaveCurrentSample(); <br>    virtual IMediaSample *GetCurrentSample(); <br>    virtual HRESULT Render(IMediaSample *pMediaSample); <br> <br>    // Derived classes MUST override these <br>    virtual HRESULT DoRenderSample(IMediaSample *pMediaSample) PURE; <br>    virtual HRESULT CheckMediaType(const CMediaType *) PURE; <br> <br>    // Helper <br>    void WaitForReceiveToComplete(); <br>}; <br> <br> <br>// CBaseVideoRenderer is a renderer class (see its ancestor class) and <br>// it handles scheduling of media samples so that they are drawn at the <br>// correct time by the reference clock.  It implements a degradation <br>// strategy.  Possible degradation modes are: <br>//    Drop frames here (only useful if the drawing takes significant time) <br>//    Signal supplier (upstream) to drop some frame(s) - i.e. one-off skip. <br>//    Signal supplier to change the frame rate - i.e. ongoing skipping. <br>//    Or any combination of the above. <br>// In order to determine what's useful to try we need to know what's going <br>// on.  This is done by timing various operations (including the supplier). <br>// This timing is done by using timeGetTime as it is accurate enough and <br>// usually cheaper than calling the reference clock.  It also tells the <br>// truth if there is an audio break and the reference clock stops. <br>// We provide a number of public entry points (named OnXxxStart, OnXxxEnd) <br>// which the rest of the renderer calls at significant moments.  These do <br>// the timing. <br> <br>// the number of frames that the sliding averages are averaged over. <br>// the rule is (1024*NewObservation + (AVGPERIOD-1) * PreviousAverage)/AVGPERIOD <br>#define AVGPERIOD 4 <br>#define DO_MOVING_AVG(avg,obs) (avg = (1024*obs + (AVGPERIOD-1)*avg)/AVGPERIOD) <br>// Spot the bug in this macro - I can't. but it doesn't work! <br> <br>class CBaseVideoRenderer : public CBaseRenderer,    // Base renderer class <br>                           public IQualProp,        // Property page guff <br>                           public IQualityControl   // Allow throttling <br>{ <br>protected: <br> <br>    // Hungarian: <br>    //     tFoo is the time Foo in mSec (beware m_tStart from filter.h) <br>    //     trBar is the time Bar by the reference clock <br> <br>    //****************************************************************** <br>    // State variables to control synchronisation <br>    //****************************************************************** <br> <br>    // Control of sending Quality messages.  We need to know whether <br>    // we are in trouble (e.g. frames being dropped) and where the time <br>    // is being spent. <br> <br>    // When we drop a frame we play the next one early. <br>    // The frame after that is likely to wait before drawing and counting this <br>    // wait as spare time is unfair, so we count it as a zero wait. <br>    // We therefore need to know whether we are playing frames early or not. <br> <br>    int m_nNormal;                  // The number of consecutive frames <br>                                    // drawn at their normal time (not early) <br>                                    // -1 means we just dropped a frame. <br> <br>#ifdef PERF <br>    BOOL m_bDrawLateFrames;         // Don't drop any frames (debug and I'm <br>                                    // not keen on people using it!) <br>#endif <br> <br>    BOOL m_bSupplierHandlingQuality;// The response to Quality messages says <br>                                    // our supplier is handling things. <br>                                    // We will allow things to go extra late <br>                                    // before dropping frames.  We will play <br>                                    // very early after he has dropped one. <br> <br>    // Control of scheduling, frame dropping etc. <br>    // We need to know where the time is being spent so as to tell whether <br>    // we should be taking action here, signalling supplier or what. <br>    // The variables are initialised to a mode of NOT dropping frames. <br>    // They will tell the truth after a few frames. <br>    // We typically record a start time for an event, later we get the time <br>    // again and subtract to get the elapsed time, and we average this over <br>    // a few frames.  The average is used to tell what mode we are in. <br> <br>    // Although these are reference times (64 bit) they are all DIFFERENCES <br>    // between times which are small.  An int will go up to 214 secs before <br>    // overflow.  Avoiding 64 bit multiplications and divisions seems <br>    // worth while. <br> <br> <br> <br>    // Audio-video throttling.  If the user has turned up audio quality <br>    // very high (in principle it could be any other stream, not just audio) <br>    // then we can receive cries for help via the graph manager.  In this case <br>    // we put in a wait for some time after rendering each frame. <br>    int m_trThrottle; <br> <br>    // The time taken to render (i.e. BitBlt) frames controls which component <br>    // needs to degrade.  If the blt is expensive, the renderer degrades. <br>    // If the blt is cheap it's done anyway and the supplier degrades. <br>    int m_trRenderAvg;              // Time frames are taking to blt <br>    int m_trRenderLast;             // Time for last frame blt <br>    int m_tRenderStart;             // Just before we started drawing (mSec) <br>                                    // derived from timeGetTime. <br> <br>    // When frames are dropped we will play the next frame as early as we can. <br>    // If it was a false alarm and the machine is fast we slide gently back to <br>    // normal timing.  To do this, we record the offset showing just how early <br>    // we really are.  This will normally be negative meaning early or zero. <br>    int m_trEarliness; <br> <br>    // Target provides slow long-term feedback to try to reduce the <br>    // average sync offset to zero.  Whenever a frame is actually rendered <br>    // early we add a msec or two, whenever late we take off a few. <br>    // We add or take off 1/32 of the error time. <br>    // Eventually we should be hovering around zero.  For a really bad case <br>    // where we were (say) 300mSec off, it might take 100 odd frames to <br>    // settle down.  The rate of change of this is intended to be slower <br>    // than any other mechanism in Quartz, thereby avoiding hunting. <br>    int m_trTarget; <br> <br>    // The proportion of time spent waiting for the right moment to blt <br>    // controls whether we bother to drop a frame or whether we reckon that <br>    // we're doing well enough that we can stand a one-frame glitch. <br>    int m_trWaitAvg;                // Average of last few wait times <br>                                    // (actually we just average how early <br>                                    // we were).  Negative here means LATE. <br> <br>    // The average inter-frame time. <br>    // This is used to calculate the proportion of the time used by the <br>    // three operations (supplying us, waiting, rendering) <br>    int m_trFrameAvg;               // Average inter-frame time <br>    int m_trDuration;               // duration of last frame. <br> <br>#ifdef PERF <br>    // Performance logging identifiers <br>    int m_idTimeStamp;              // MSR_id for frame time stamp <br>    int m_idEarliness;              // MSR_id for earliness fudge <br>    int m_idTarget;                 // MSR_id for Target fudge <br>    int m_idWaitReal;               // MSR_id for true wait time <br>    int m_idWait;                   // MSR_id for wait time recorded <br>    int m_idFrameAccuracy;          // MSR_id for time frame is late (int) <br>    int m_idRenderAvg;              // MSR_id for Render time recorded (int) <br>    int m_idSchLateTime;            // MSR_id for lateness at scheduler <br>    int m_idQualityRate;            // MSR_id for Quality rate requested <br>    int m_idQualityTime;            // MSR_id for Quality time requested <br>    int m_idDecision;               // MSR_id for decision code <br>    int m_idDuration;               // MSR_id for duration of a frame <br>    int m_idThrottle;               // MSR_id for audio-video throttling <br>    //int m_idDebug;                  // MSR_id for trace style debugging <br>    //int m_idSendQuality;          // MSR_id for timing the notifications per se <br>#endif // PERF <br>    REFERENCE_TIME m_trRememberStampForPerf;  // original time stamp of frame <br>                                              // with no earliness fudges etc. <br>#ifdef PERF <br>    REFERENCE_TIME m_trRememberFrameForPerf;  // time when previous frame rendered <br> <br>    // debug... <br>    int m_idFrameAvg; <br>    int m_idWaitAvg; <br>#endif <br> <br>    // PROPERTY PAGE <br>    // This has edit fields that show the user what's happening <br>    // These member variables hold these counts. <br> <br>    int m_cFramesDropped;           // cumulative frames dropped IN THE RENDERER <br>    int m_cFramesDrawn;             // Frames since streaming started seen BY THE <br>                                    // RENDERER (some may be dropped upstream) <br> <br>    // Next two support average sync offset and standard deviation of sync offset. <br>    LONGLONG m_iTotAcc;                  // Sum of accuracies in mSec <br>    LONGLONG m_iSumSqAcc;           // Sum of squares of (accuracies in mSec) <br> <br>    // Next two allow jitter calculation.  Jitter is std deviation of frame time. <br>    REFERENCE_TIME m_trLastDraw;    // Time of prev frame (for inter-frame times) <br>    LONGLONG m_iSumSqFrameTime;     // Sum of squares of (inter-frame time in mSec) <br>    LONGLONG m_iSumFrameTime;            // Sum of inter-frame times in mSec <br> <br>    // To get performance statistics on frame rate, jitter etc, we need <br>    // to record the lateness and inter-frame time.  What we actually need are the <br>    // data above (sum, sum of squares and number of entries for each) but the data <br>    // is generated just ahead of time and only later do we discover whether the <br>    // frame was actually drawn or not.  So we have to hang on to the data <br>    int m_trLate;                   // hold onto frame lateness <br>    int m_trFrame;                  // hold onto inter-frame time <br> <br>    int m_tStreamingStart;          // if streaming then time streaming started <br>                                    // else time of last streaming session <br>                                    // used for property page statistics <br>#ifdef PERF <br>    LONGLONG m_llTimeOffset;        // timeGetTime()*10000+m_llTimeOffset==ref time <br>#endif <br> <br>public: <br> <br> <br>    CBaseVideoRenderer(REFCLSID RenderClass, // CLSID for this renderer <br>                       TCHAR *pName,         // Debug ONLY description <br>                       LPUNKNOWN pUnk,       // Aggregated owner object <br>                       HRESULT *phr);        // General OLE return code <br> <br>    ~CBaseVideoRenderer(); <br> <br>    // IQualityControl methods - Notify allows audio-video throttling <br> <br>    STDMETHODIMP SetSink( IQualityControl * piqc); <br>    STDMETHODIMP Notify( IBaseFilter * pSelf, Quality q); <br> <br>    // These provide a full video quality management implementation <br> <br>    void OnRenderStart(IMediaSample *pMediaSample); <br>    void OnRenderEnd(IMediaSample *pMediaSample); <br>    void OnWaitStart(); <br>    void OnWaitEnd(); <br>    HRESULT OnStartStreaming(); <br>    HRESULT OnStopStreaming(); <br>    void ThrottleWait(); <br> <br>    // Handle the statistics gathering for our quality management <br> <br>    void PreparePerformanceData(int trLate, int trFrame); <br>    virtual void RecordFrameLateness(int trLate, int trFrame); <br>    virtual void OnDirectRender(IMediaSample *pMediaSample); <br>    virtual HRESULT ResetStreamingTimes(); <br>    BOOL ScheduleSample(IMediaSample *pMediaSample); <br>    HRESULT ShouldDrawSampleNow(IMediaSample *pMediaSample, <br>                                REFERENCE_TIME *ptrStart, <br>                                REFERENCE_TIME *ptrEnd); <br> <br>    virtual HRESULT SendQuality(REFERENCE_TIME trLate, REFERENCE_TIME trRealStream); <br>    STDMETHODIMP JoinFilterGraph(IFilterGraph * pGraph, LPCWSTR pName); <br> <br>    // <br>    //  Do estimates for standard deviations for per-frame <br>    //  statistics <br>    // <br>    //  *piResult = (llSumSq - iTot * iTot / m_cFramesDrawn - 1) / <br>    //                            (m_cFramesDrawn - 2) <br>    //  or 0 if m_cFramesDrawn &lt;= 3 <br>    // <br>    HRESULT GetStdDev( <br>        int nSamples, <br>        int *piResult, <br>        LONGLONG llSumSq, <br>        LONGLONG iTot <br>    ); <br>public: <br> <br>    // IQualProp property page support <br> <br>    STDMETHODIMP get_FramesDroppedInRenderer(int *cFramesDropped); <br>    STDMETHODIMP get_FramesDrawn(int *pcFramesDrawn); <br>    STDMETHODIMP get_AvgFrameRate(int *piAvgFrameRate); <br>    STDMETHODIMP get_Jitter(int *piJitter); <br>    STDMETHODIMP get_AvgSyncOffset(int *piAvg); <br>    STDMETHODIMP get_DevSyncOffset(int *piDev); <br> <br>    // Implement an IUnknown interface and expose IQualProp <br> <br>    DECLARE_IUNKNOWN <br>    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,VOID **ppv); <br>}; <br> <br>#endif // __RENBASE__ <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
