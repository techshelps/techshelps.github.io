<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SOURCE.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2770"></a>SOURCE.CPP</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>// Implements CSource. A Quartz source filter 'template', March 1995 <br> <br>// Locking Strategy. <br>// <br>// Hold the filter critical section (m_pFilter-&gt;pStateLock()) to serialise <br>// access to functions. Note that, in general, this lock may be held <br>// by a function when the worker thread may want to hold it. Therefore <br>// if you wish to access shared state from the worker thread you will <br>// need to add another critical section object. The execption is during <br>// the threads processing loop, when it is safe to get the filter critical <br>// section from within FillBuffer(). <br> <br>#include &lt;streams.h&gt; <br> <br> <br>// <br>// CSource::Constructor <br>// <br>// Initialise the pin count for the filter. The user will create the pins in <br>// the derived class. <br>CSource::CSource(TCHAR *pName, LPUNKNOWN lpunk, CLSID clsid) <br>    : CBaseFilter(pName, lpunk, &amp;m_cStateLock, clsid), <br>      m_iPins(0), <br>      m_paStreams(NULL) <br>{ <br>} <br> <br>CSource::CSource(TCHAR *pName, LPUNKNOWN lpunk, CLSID clsid, HRESULT *phr) <br>    : CBaseFilter(pName, lpunk, &amp;m_cStateLock, clsid), <br>      m_iPins(0), <br>      m_paStreams(NULL) <br>{ <br>    UNREFERENCED_PARAMETER(phr); <br>} <br> <br>// <br>// CSource::Destructor <br>// <br>CSource::~CSource() <br>{ <br>    /*  Free our pins and pin array */ <br>    while (m_iPins != 0) { <br>// deleting the pins causes them to be removed from the array... <br>delete m_paStreams[m_iPins - 1]; <br>    } <br> <br>    ASSERT(m_paStreams == NULL); <br>} <br> <br> <br>// <br>//  Add a new pin <br>// <br>HRESULT CSource::AddPin(CSourceStream *pStream) <br>{ <br>    CAutoLock lock(&amp;m_cStateLock); <br> <br>    /*  Allocate space for this pin and the old ones */ <br>    CSourceStream **paStreams = new CSourceStream *[m_iPins + 1]; <br>    if (paStreams == NULL) { <br>        return E_OUTOFMEMORY; <br>    } <br>    if (m_paStreams != NULL) { <br>        CopyMemory((PVOID)paStreams, (PVOID)m_paStreams, <br>                   m_iPins * sizeof(m_paStreams[0])); <br>        paStreams[m_iPins] = pStream; <br>        delete [] m_paStreams; <br>    } <br>    m_paStreams = paStreams; <br>    m_paStreams[m_iPins] = pStream; <br>    m_iPins++; <br>    return S_OK; <br>} <br> <br>// <br>//  Remove a pin - pStream is NOT deleted <br>// <br>HRESULT CSource::RemovePin(CSourceStream *pStream) <br>{ <br>    int i; <br>    for (i = 0; i &lt; m_iPins; i++) { <br>        if (m_paStreams[i] == pStream) { <br>            if (m_iPins == 1) { <br>                delete [] m_paStreams; <br>                m_paStreams = NULL; <br>            } else { <br>                /*  no need to reallocate */ <br>while (++i &lt; m_iPins) <br>    m_paStreams[i - 1] = m_paStreams[i]; <br>            } <br>            m_iPins--; <br>            return S_OK; <br>        } <br>    } <br>    return S_FALSE; <br>} <br> <br>// <br>// FindPin <br>// <br>// Set *ppPin to the IPin* that has the id Id. <br>// or to NULL if the Id cannot be matched. <br>STDMETHODIMP CSource::FindPin(LPCWSTR Id, IPin **ppPin) <br>{ <br>    CheckPointer(ppPin,E_POINTER); <br>    ValidateReadWritePtr(ppPin,sizeof(IPin *)); <br>    // The -1 undoes the +1 in QueryId and ensures that totally bogus <br>    // strings (for which WstrToInt delivers 0) give a deliver a NULL pin. <br>    int i = WstrToInt(Id) -1; <br>    *ppPin = GetPin(i); <br>    if (*ppPin!=NULL){ <br>        (*ppPin)-&gt;AddRef(); <br>        return NOERROR; <br>    } else { <br>        return VFW_E_NOT_FOUND; <br>    } <br>} <br> <br>// <br>// FindPinNumber <br>// <br>// return the number of the pin with this IPin* or -1 if none <br>int CSource::FindPinNumber(IPin *iPin) { <br>    int i; <br>    for (i=0; i&lt;m_iPins; ++i) { <br>        if ((IPin *)(m_paStreams[i])==iPin) { <br>            return i; <br>        } <br>    } <br>    return -1; <br>} <br> <br>// <br>// GetPinCount <br>// <br>// Returns the number of pins this filter has <br>int CSource::GetPinCount(void) { <br> <br>    CAutoLock lock(&amp;m_cStateLock); <br>    return m_iPins; <br>} <br> <br> <br>// <br>// GetPin <br>// <br>// Return a non-addref'd pointer to pin n <br>// needed by CBaseFilter <br>CBasePin *CSource::GetPin(int n) { <br> <br>    CAutoLock lock(&amp;m_cStateLock); <br> <br>    // n must be in the range 0..m_iPins-1 <br>    // if m_iPins&gt;n  &amp;&amp; n&gt;=0 it follows that m_iPins&gt;0 <br>    // which is what used to be checked (i.e. checking that we have a pin) <br>    if ((n &gt;= 0) &amp;&amp; (n &lt; m_iPins)) { <br> <br>        ASSERT(m_paStreams[n]); <br>return m_paStreams[n]; <br>    } <br>    return NULL; <br>} <br> <br> <br>// <br> <br> <br>// * <br>// * --- CSourceStream ---- <br>// * <br> <br>// <br>// Set Id to point to a CoTaskMemAlloc'd <br>STDMETHODIMP CSourceStream::QueryId(LPWSTR *Id) { <br>    CheckPointer(Id,E_POINTER); <br>    ValidateReadWritePtr(Id,sizeof(LPWSTR)); <br> <br>    // We give the pins id's which are 1,2,... <br>    // FindPinNumber returns -1 for a bogus pin <br>    int i = 1+ m_pFilter-&gt;FindPinNumber(this); <br>    if (i&lt;1) return VFW_E_NOT_FOUND; <br>    *Id = (LPWSTR)CoTaskMemAlloc(8); <br>    if (*Id==NULL) { <br>       return E_OUTOFMEMORY; <br>    } <br>    IntToWstr(i, *Id); <br>    return NOERROR; <br>} <br> <br> <br> <br>// <br>// CSourceStream::Constructor <br>// <br>// increments the number of pins present on the filter <br>CSourceStream::CSourceStream( <br>    TCHAR *pObjectName, <br>    HRESULT *phr, <br>    CSource *ps, <br>    LPCWSTR pPinName) <br>    : CBaseOutputPin(pObjectName, ps, ps-&gt;pStateLock(), phr, pPinName), <br>      m_pFilter(ps) { <br> <br>     *phr = m_pFilter-&gt;AddPin(this); <br>} <br> <br> <br>// <br>// CSourceStream::Destructor <br>// <br>// Decrements the number of pins on this filter <br>CSourceStream::~CSourceStream(void) { <br> <br>     m_pFilter-&gt;RemovePin(this); <br>} <br> <br> <br>// <br>// CheckMediaType <br>// <br>// Do we support this type? Provides the default support for 1 type. <br>HRESULT CSourceStream::CheckMediaType(const CMediaType *pMediaType) { <br> <br>    CAutoLock lock(m_pFilter-&gt;pStateLock()); <br> <br>    CMediaType mt; <br>    GetMediaType(&amp;mt); <br> <br>    if (mt == *pMediaType) { <br>        return NOERROR; <br>    } <br> <br>    return E_FAIL; <br>} <br> <br> <br>// <br>// GetMediaType/3 <br>// <br>// By default we support only one type <br>// iPosition indexes are 0-n <br>HRESULT CSourceStream::GetMediaType(int iPosition, CMediaType *pMediaType) { <br> <br>    CAutoLock lock(m_pFilter-&gt;pStateLock()); <br> <br>    if (iPosition&lt;0) { <br>        return E_INVALIDARG; <br>    } <br>    if (iPosition&gt;0) { <br>        return VFW_S_NO_MORE_ITEMS; <br>    } <br>    return GetMediaType(pMediaType); <br>} <br> <br> <br>// <br>// Active <br>// <br>// The pin is active - start up the worker thread <br>HRESULT CSourceStream::Active(void) { <br> <br>    CAutoLock lock(m_pFilter-&gt;pStateLock()); <br> <br>    HRESULT hr; <br> <br>    if (m_pFilter-&gt;IsActive()) { <br>return S_FALSE;// succeeded, but did not allocate resources (they already exist...) <br>    } <br> <br>    // do nothing if not connected - its ok not to connect to <br>    // all pins of a source filter <br>    if (!IsConnected()) { <br>        return NOERROR; <br>    } <br> <br>    hr = CBaseOutputPin::Active(); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br> <br>    ASSERT(!ThreadExists()); <br> <br>    // start the thread <br>    if (!Create()) { <br>        return E_FAIL; <br>    } <br> <br>    // Tell thread to initialize. If OnThreadCreate Fails, so does this. <br>    hr = Init(); <br>    if (FAILED(hr)) <br>return hr; <br> <br>    return Pause(); <br>} <br> <br> <br>// <br>// Inactive <br>// <br>// Pin is inactive - shut down the worker thread <br>// Waits for the worker to exit before returning. <br>HRESULT CSourceStream::Inactive(void) { <br> <br>    CAutoLock lock(m_pFilter-&gt;pStateLock()); <br> <br>    HRESULT hr; <br> <br>    // do nothing if not connected - its ok not to connect to <br>    // all pins of a source filter <br>    if (!IsConnected()) { <br>        return NOERROR; <br>    } <br> <br>    // !!! need to do this before trying to stop the thread, because <br>    // we may be stuck waiting for our own allocator!!! <br> <br>    hr = CBaseOutputPin::Inactive();  // call this first to Decommit the allocator <br>    if (FAILED(hr)) { <br>return hr; <br>    } <br> <br>    if (ThreadExists()) { <br>hr = Stop(); <br> <br>if (FAILED(hr)) { <br>    return hr; <br>} <br> <br>hr = Exit(); <br>if (FAILED(hr)) { <br>    return hr; <br>} <br> <br>Close();// Wait for the thread to exit, then tidy up. <br>    } <br> <br>    // hr = CBaseOutputPin::Inactive();  // call this first to Decommit the allocator <br>    //if (FAILED(hr)) { <br>    //return hr; <br>    //} <br> <br>    return NOERROR; <br>} <br> <br> <br>// <br>// ThreadProc <br>// <br>// When this returns the thread exits <br>// Return codes &gt; 0 indicate an error occured <br>DWORD CSourceStream::ThreadProc(void) { <br> <br>    HRESULT hr;  // the return code from calls <br>    Command com; <br> <br>    do { <br>com = GetRequest(); <br>if (com != CMD_INIT) { <br>    DbgLog((LOG_ERROR, 1, TEXT("Thread expected init command"))); <br>    Reply((DWORD) E_UNEXPECTED); <br>} <br>    } while (com != CMD_INIT); <br> <br>    DbgLog((LOG_TRACE, 1, TEXT("CSourceStream worker thread initializing"))); <br> <br>    hr = OnThreadCreate(); // perform set up tasks <br>    if (FAILED(hr)) { <br>        DbgLog((LOG_ERROR, 1, TEXT("CSourceStream::OnThreadCreate failed. Aborting thread."))); <br>        OnThreadDestroy(); <br>Reply(hr);// send failed return code from OnThreadCreate <br>        return 1; <br>    } <br> <br>    // Initialisation suceeded <br>    Reply(NOERROR); <br> <br>    Command cmd; <br>    do { <br>cmd = GetRequest(); <br> <br>switch (cmd) { <br> <br>case CMD_EXIT: <br>    Reply(NOERROR); <br>    break; <br> <br>case CMD_RUN: <br>    DbgLog((LOG_ERROR, 1, TEXT("CMD_RUN received before a CMD_PAUSE???"))); <br>    // !!! fall through??? <br> <br>case CMD_PAUSE: <br>    Reply(NOERROR); <br>    DoBufferProcessingLoop(); <br>    break; <br> <br>case CMD_STOP: <br>    Reply(NOERROR); <br>    break; <br> <br>default: <br>    DbgLog((LOG_ERROR, 1, TEXT("Unknown command %d received!"), cmd)); <br>    Reply((DWORD) E_NOTIMPL); <br>    break; <br>} <br>    } while (cmd != CMD_EXIT); <br> <br>    hr = OnThreadDestroy();// tidy up. <br>    if (FAILED(hr)) { <br>        DbgLog((LOG_ERROR, 1, TEXT("CSourceStream::OnThreadDestroy failed. Exiting thread."))); <br>        return 1; <br>    } <br> <br>    DbgLog((LOG_TRACE, 1, TEXT("CSourceStream worker thread exiting"))); <br>    return 0; <br>} <br> <br> <br>// <br>// DoBufferProcessingLoop <br>// <br>// Grabs a buffer and calls the users processing function. <br>// Overridable, so that different delivery styles can be catered for. <br>HRESULT CSourceStream::DoBufferProcessingLoop(void) { <br> <br>    Command com; <br> <br>    OnThreadStartPlay(); <br> <br>    do { <br>while (!CheckRequest(&amp;com)) { <br> <br>    IMediaSample *pSample; <br> <br>    HRESULT hr = GetDeliveryBuffer(&amp;pSample,NULL,NULL,0); <br>    if (FAILED(hr)) { <br>                Sleep(1); <br>continue;// go round again. Perhaps the error will go away <br>    // or the allocator is decommited &amp; we will be asked to <br>    // exit soon. <br>    } <br> <br>    // Virtual function user will override. <br>    hr = FillBuffer(pSample); <br> <br>    if (hr == S_OK) { <br>hr = Deliver(pSample); <br>                pSample-&gt;Release(); <br> <br>                // downstream filter returns S_FALSE if it wants us to <br>                // stop or an error if it's reporting an error. <br>                if(hr != S_OK) <br>                { <br>                  DbgLog((LOG_TRACE, 2, TEXT("Deliver() returned %08x; stopping"), hr)); <br>                  return S_OK; <br>                } <br> <br>    } else if (hr == S_FALSE) { <br>                // derived class wants us to stop pushing data <br>pSample-&gt;Release(); <br>DeliverEndOfStream(); <br>return S_OK; <br>    } else { <br>                // derived class encountered an error <br>                pSample-&gt;Release(); <br>DbgLog((LOG_ERROR, 1, TEXT("Error %08lX from FillBuffer!!!"), hr)); <br>                DeliverEndOfStream(); <br>                m_pFilter-&gt;NotifyEvent(EC_ERRORABORT, hr, 0); <br>                return hr; <br>    } <br> <br>            // all paths release the sample <br>} <br> <br>        // For all commands sent to us there must be a Reply call! <br> <br>if (com == CMD_RUN || com == CMD_PAUSE) { <br>    Reply(NOERROR); <br>} else if (com != CMD_STOP) { <br>    Reply((DWORD) E_UNEXPECTED); <br>    DbgLog((LOG_ERROR, 1, TEXT("Unexpected command!!!"))); <br>} <br>    } while (com != CMD_STOP); <br> <br>    return S_FALSE; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
