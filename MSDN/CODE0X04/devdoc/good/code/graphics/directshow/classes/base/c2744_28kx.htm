<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MEASURE.H</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2751"></a>MEASURE.H</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>/* <br>   The idea is to pepper the source code with interesting measurements and <br>   have the last few thousand of these recorded in a circular buffer that <br>   can be post-processed to give interesting numbers. <br> <br>   WHAT THE LOG LOOKS LIKE: <br> <br>  Time (sec)   Type        Delta  Incident_Name <br>    0.055,41  NOTE      -.       Incident Nine  - Another note <br>    0.055,42  NOTE      0.000,01 Incident Nine  - Another note <br>    0.055,44  NOTE      0.000,02 Incident Nine  - Another note <br>    0.055,45  STOP      -.       Incident Eight - Also random <br>    0.055,47  START     -.       Incident Seven - Random <br>    0.055,49  NOTE      0.000,05 Incident Nine  - Another note <br>    ------- &lt;etc.  there is a lot of this&gt; ---------------- <br>    0.125,60  STOP      0.000,03 Msr_Stop <br>    0.125,62  START     -.       Msr_Start <br>    0.125,63  START     -.       Incident Two   - Start/Stop <br>    0.125,65  STOP      0.000,03 Msr_Start <br>    0.125,66  START     -.       Msr_Stop <br>    0.125,68  STOP      0.000,05 Incident Two   - Start/Stop <br>    0.125,70  STOP      0.000,04 Msr_Stop <br>    0.125,72  START     -.       Msr_Start <br>    0.125,73  START     -.       Incident Two   - Start/Stop <br>    0.125,75  STOP      0.000,03 Msr_Start <br>    0.125,77  START     -.       Msr_Stop <br>    0.125,78  STOP      0.000,05 Incident Two   - Start/Stop <br>    0.125,80  STOP      0.000,03 Msr_Stop <br>    0.125,81  NOTE      -.       Incident Three - single Note <br>    0.125,83  START     -.       Incident Four  - Start, no stop <br>    0.125,85  START     -.       Incident Five  - Single Start/Stop <br>    0.125,87  STOP      0.000,02 Incident Five  - Single Start/Stop <br> <br>Number      Average       StdDev     Smallest      Largest Incident_Name <br>    10     0.000,58     0.000,10     0.000,55     0.000,85 Incident One   - Note <br>    50     0.000,05     0.000,00     0.000,05     0.000,05 Incident Two   - Start/Stop <br>     1     -.           -.           -.           -.       Incident Three - single Note <br>     0     -.           -.           -.           -.       Incident Four  - Start, no stop <br>     1     0.000,02     -.           0.000,02     0.000,02 Incident Five  - Single Start/Stop <br>     0     -.           -.           -.           -.       Incident Six   - zero occurrences <br>   100     0.000,25     0.000,12     0.000,02     0.000,62 Incident Seven - Random <br>   100     0.000,79     0.000,48     0.000,02     0.001,92 Incident Eight - Also random <br>  5895     0.000,01     0.000,01     0.000,01     0.000,56 Incident Nine  - Another note <br>    10     0.000,03     0.000,00     0.000,03     0.000,04 Msr_Note <br>    50     0.000,03     0.000,00     0.000,03     0.000,04 Msr_Start <br>    50     0.000,04     0.000,03     0.000,03     0.000,31 Msr_Stop <br> <br>  WHAT IT MEANS: <br>    The log shows what happened and when.  Each line shows the time at which <br>    something happened (see WHAT YOU CODE below) what it was that happened <br>    and (if approporate) the time since the corresponding previous event <br>    (that's the delta column). <br> <br>    The statistics show how many times each event occurred, what the average <br>    delta time was, also the standard deviation, largest and smalles delta. <br> <br>   WHAT YOU CODE: <br> <br>   Before anything else executes: - register your ids <br> <br>    int id1     = Msr_Register("Incident One   - Note"); <br>    int id2     = Msr_Register("Incident Two   - Start/Stop"); <br>    int id3     = Msr_Register("Incident Three - single Note"); <br>    etc. <br> <br>   At interesting moments: <br> <br>       // To measure a repetitive event - e.g. end of bitblt to screen <br>       Msr_Note(Id9);             // e.g. "video frame hiting the screen NOW!" <br> <br>           or <br> <br>       // To measure an elapsed time e.g. time taken to decode an MPEG B-frame <br>       Msr_Start(Id2);            // e.g. "Starting to decode MPEG B-frame" <br>         . . . <br>       MsrStop(Id2);              //      "Finished MPEG decode" <br> <br>   At the end: <br> <br>       HANDLE hFile; <br>       hFile = CreateFile("Perf.log", GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL); <br>       Msr_Dump(hFile);           // This writes the log out to the file <br>       CloseHandle(hFile); <br> <br>           or <br> <br>       Msr_Dump(NULL);            // This writes it to DbgLog((LOG_TRACE,0, ... )); <br>                                  // but if you are writing it out to the debugger <br>                                  // then the times are probably all garbage because <br>                                  // the debugger can make things run awfully slow. <br> <br>    A given id should be used either for start / stop or Note calls.  If Notes <br>    are mixed in with Starts and Stops their statistics will be gibberish. <br> <br>    If you code the calls in upper case i.e. MSR_START(idMunge); then you get <br>    macros which will turn into nothing unless PERF is defined. <br> <br>    You can reset the statistical counts for a given id by calling Reset(Id). <br>    They are reset by default at the start. <br>    It logs Reset as a special incident, so you can see it in the log. <br> <br>    The log is a circular buffer in storage (to try to minimise disk I/O). <br>    It overwrites the oldest entries once full.  The statistics include ALL <br>    incidents since the last Reset, whether still visible in the log or not. <br>*/ <br> <br>#ifndef __MEASURE__ <br>#define __MEASURE__ <br> <br>#ifdef PERF <br>#define MSR_INIT() Msr_Init() <br>#define MSR_TERMINATE() Msr_Terminate() <br>#define MSR_REGISTER(a) Msr_Register(a) <br>#define MSR_RESET(a) Msr_Reset(a) <br>#define MSR_CONTROL(a) Msr_Control(a) <br>#define MSR_START(a) Msr_Start(a) <br>#define MSR_STOP(a) Msr_Stop(a) <br>#define MSR_NOTE(a) Msr_Note(a) <br>#define MSR_INTEGER(a,b) Msr_Integer(a,b) <br>#define MSR_DUMP(a) Msr_Dump(a) <br>#define MSR_DUMPSTATS(a) Msr_DumpStats(a) <br>#else <br>#define MSR_INIT() <br>#define MSR_TERMINATE() <br>#define MSR_REGISTER(a) 0 <br>#define MSR_RESET(a) <br>#define MSR_CONTROL(a) <br>#define MSR_START(a) <br>#define MSR_STOP(a) <br>#define MSR_NOTE(a) <br>#define MSR_INTEGER(a,b) <br>#define MSR_DUMP(a) <br>#define MSR_DUMPSTATS(a) <br>#endif <br> <br>#ifdef __cplusplus <br>extern "C" { <br>#endif <br> <br>// This must be called first - (called by the DllEntry) <br> <br>void WINAPI Msr_Init(void); <br> <br> <br>// Call this last to clean up (or just let it fall off the end - who cares?) <br> <br>void WINAPI Msr_Terminate(void); <br> <br> <br>// Call this to get an Id for an "incident" that you can pass to Start, Stop or Note <br>// everything that's logged is called an "incident". <br> <br>int  WINAPI Msr_Register(LPTSTR Incident); <br> <br> <br>// Reset the statistical counts for an incident <br> <br>void WINAPI Msr_Reset(int Id); <br> <br> <br>// Reset all the counts for all incidents <br>#define MSR_RESET_ALL 0 <br>#define MSR_PAUSE 1 <br>#define MSR_RUN 2 <br> <br>void WINAPI Msr_Control(int iAction); <br> <br> <br>// log the start of an operation <br> <br>void WINAPI Msr_Start(int Id); <br> <br> <br>// log the end of an operation <br> <br>void WINAPI Msr_Stop(int Id); <br> <br> <br>// log a one-off or repetitive operation <br> <br>void WINAPI Msr_Note(int Id); <br> <br> <br>// log an integer (on which we can see statistics later) <br>void WINAPI Msr_Integer(int Id, int n); <br> <br> <br>// print out all the vaialable log (it may have wrapped) and then the statistics. <br>// When the log wraps you lose log but the statistics are still complete. <br>// hFIle==NULL =&gt; use DbgLog <br>// otherwise hFile must have come from CreateFile or OpenFile. <br> <br>void WINAPI Msr_Dump(HANDLE hFile); <br> <br> <br>// just dump the statistics - never mind the log <br> <br>void WINAPI Msr_DumpStats(HANDLE hFile); <br> <br>// Type definitions in case you want to declare a pointer to the dump functions <br>// (makes it a trifle easier to do dynamic linking <br>// i.e. LoadModule, GetProcAddress and call that) <br> <br>// Typedefs so can declare MSR_DUMPPROC *MsrDumpStats; or whatever <br>typedef void WINAPI MSR_DUMPPROC(HANDLE hFile); <br>typedef void WINAPI MSR_CONTROLPROC(int iAction); <br> <br> <br>#ifdef __cplusplus <br>} <br>#endif <br> <br>#endif // __MEASURE__ </code></pre>
<p>&nbsp;</p></body>
</HTML>
