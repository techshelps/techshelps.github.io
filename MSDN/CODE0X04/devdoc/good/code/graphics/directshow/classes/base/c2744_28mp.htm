<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>REFCLOCK.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2761"></a>REFCLOCK.CPP</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br>//  REFCLOCK.CPP <br>//    Implements the IReferenceClock interface <br> <br>#include &lt;streams.h&gt; <br>#include &lt;limits.h&gt; <br> <br>// 'this' used in constructor list <br>#pragma warning(disable:4355) <br> <br> <br>STDMETHODIMP CBaseReferenceClock::NonDelegatingQueryInterface( <br>    REFIID riid, <br>    void ** ppv) <br>{ <br>    HRESULT hr; <br> <br>    if (riid == IID_IReferenceClock) <br>    { <br>        hr = GetInterface((IReferenceClock *) this, ppv); <br>    } <br>    else <br>    { <br>        hr = CUnknown::NonDelegatingQueryInterface(riid, ppv); <br>    } <br>    return hr; <br>} <br> <br>CBaseReferenceClock::~CBaseReferenceClock() <br>{ <br>    if (m_TimerResolution) timeEndPeriod(m_TimerResolution); <br> <br>    m_pSchedule-&gt;DumpLinkedList(); <br> <br>    if (m_hThread) <br>    { <br>        m_bAbort = TRUE; <br>        TriggerThread(); <br>        WaitForSingleObject( m_hThread, INFINITE ); <br>        EXECUTE_ASSERT( CloseHandle(m_hThread) ); <br>        m_hThread = 0; <br>        EXECUTE_ASSERT( CloseHandle(m_pSchedule-&gt;GetEvent()) ); <br>delete m_pSchedule; <br>    } <br>} <br> <br>// A derived class may supply a hThreadEvent if it has its own thread that will take care <br>// of calling the schedulers Advise method.  (Refere to CBaseReferenceClock::AdviseThread() <br>// to see what such a thread has to do.) <br>CBaseReferenceClock::CBaseReferenceClock( TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr, CAMSchedule * pShed ) <br>: CUnknown( pName, pUnk ) <br>, m_rtLastGotTime(0) <br>, m_TimerResolution(0) <br>, m_bAbort( FALSE ) <br>, m_pSchedule( pShed ? pShed : new CAMSchedule(CreateEvent(NULL, FALSE, FALSE, NULL)) ) <br>, m_hThread(0) <br>{ <br>    ASSERT(m_pSchedule); <br>    if (!m_pSchedule) <br>    { <br>*phr = E_OUTOFMEMORY; <br>    } <br>    else <br>    { <br>// Set up the highest resolution timer we can manage <br>TIMECAPS tc; <br>m_TimerResolution = (TIMERR_NOERROR == timeGetDevCaps(&amp;tc, sizeof(tc))) <br>    ? tc.wPeriodMin <br>    : 1; <br> <br>timeBeginPeriod(m_TimerResolution); <br> <br>/* Initialise our system times - the derived clock should set the right values */ <br>m_dwPrevSystemTime = timeGetTime(); <br>m_rtPrivateTime = (UNITS / MILLISECONDS) * m_dwPrevSystemTime; <br> <br>#ifdef PERF <br>    m_idGetSystemTime = MSR_REGISTER("CBaseReferenceClock::GetTime"); <br>#endif <br> <br>if ( !pShed ) <br>{ <br>    DWORD ThreadID; <br>    m_hThread = ::CreateThread(NULL,                  // Security attributes <br>       (DWORD) 0,             // Initial stack size <br>       AdviseThreadFunction,  // Thread start address <br>       (LPVOID) this,         // Thread parameter <br>       (DWORD) 0,             // Creation flags <br>       &amp;ThreadID);            // Thread identifier <br> <br>    if (m_hThread) <br>    { <br>SetThreadPriority( m_hThread, THREAD_PRIORITY_TIME_CRITICAL ); <br>    } <br>    else <br>    { <br>*phr = E_FAIL; <br>EXECUTE_ASSERT( CloseHandle(m_pSchedule-&gt;GetEvent()) ); <br>delete m_pSchedule; <br>    } <br>} <br>    } <br>} <br> <br>STDMETHODIMP CBaseReferenceClock::GetTime(REFERENCE_TIME *pTime) <br>{ <br>    HRESULT hr; <br>    if (pTime) <br>    { <br>        REFERENCE_TIME rtNow; <br>        Lock(); <br>        rtNow = GetPrivateTime(); <br>        if (rtNow &gt; m_rtLastGotTime) <br>        { <br>            m_rtLastGotTime = rtNow; <br>            hr = S_OK; <br>        } <br>        else <br>        { <br>            hr = S_FALSE; <br>        } <br>        *pTime = m_rtLastGotTime; <br>        Unlock(); <br>        MSR_INTEGER(m_idGetSystemTime, LONG((*pTime) / (UNITS/MILLISECONDS)) ); <br>    } <br>    else hr = E_POINTER; <br> <br>    return hr; <br>} <br> <br>/* Ask for an async notification that a time has elapsed */ <br> <br>STDMETHODIMP CBaseReferenceClock::AdviseTime( <br>    REFERENCE_TIME baseTime,         // base reference time <br>    REFERENCE_TIME streamTime,       // stream offset time <br>    HEVENT hEvent,                  // advise via this event <br>    DWORD *pdwAdviseCookie)         // where your cookie goes <br>{ <br>    CheckPointer(pdwAdviseCookie, E_POINTER); <br>    *pdwAdviseCookie = 0; <br> <br>    // Check that the event is not already set <br>    ASSERT(WAIT_TIMEOUT == WaitForSingleObject(HANDLE(hEvent),0)); <br> <br>    HRESULT hr; <br> <br>    const REFERENCE_TIME lRefTime = baseTime + streamTime; <br>    if ( lRefTime &lt;= 0 || lRefTime == MAX_TIME ) <br>    { <br>        hr = E_INVALIDARG; <br>    } <br>    else <br>    { <br>        *pdwAdviseCookie = m_pSchedule-&gt;AddAdvisePacket( lRefTime, 0, HANDLE(hEvent), FALSE ); <br>        hr = *pdwAdviseCookie ? NOERROR : E_OUTOFMEMORY; <br>    } <br>    return hr; <br>} <br> <br> <br>/* Ask for an asynchronous periodic notification that a time has elapsed */ <br> <br>STDMETHODIMP CBaseReferenceClock::AdvisePeriodic( <br>    REFERENCE_TIME StartTime,         // starting at this time <br>    REFERENCE_TIME PeriodTime,        // time between notifications <br>    HSEMAPHORE hSemaphore,           // advise via a semaphore <br>    DWORD *pdwAdviseCookie)          // where your cookie goes <br>{ <br>    CheckPointer(pdwAdviseCookie, E_POINTER); <br>    *pdwAdviseCookie = 0; <br> <br>    HRESULT hr; <br>    if (StartTime &gt; 0 &amp;&amp; PeriodTime &gt; 0 &amp;&amp; StartTime != MAX_TIME ) <br>    { <br>        *pdwAdviseCookie = m_pSchedule-&gt;AddAdvisePacket( StartTime, PeriodTime, HANDLE(hSemaphore), TRUE ); <br>        hr = *pdwAdviseCookie ? NOERROR : E_OUTOFMEMORY; <br>    } <br>    else hr = E_INVALIDARG; <br> <br>    return hr; <br>} <br> <br> <br>STDMETHODIMP CBaseReferenceClock::Unadvise(DWORD dwAdviseCookie) <br>{ <br>    return m_pSchedule-&gt;Unadvise(dwAdviseCookie); <br>} <br> <br> <br>REFERENCE_TIME CBaseReferenceClock::GetPrivateTime() <br>{ <br>    CAutoLock cObjectLock(this); <br> <br> <br>    /* If the clock has wrapped then the current time will be less than <br>     * the last time we were notified so add on the extra milliseconds <br>     * <br>     * The time period is long enough so that the likelihood of <br>     * successive calls spanning the clock cycle is not considered. <br>     */ <br> <br>    DWORD dwTime = timeGetTime(); <br>    { <br>        m_rtPrivateTime += Int32x32To64(UNITS / MILLISECONDS, (DWORD)(dwTime - m_dwPrevSystemTime)); <br>        m_dwPrevSystemTime = dwTime; <br>    } <br> <br>    return m_rtPrivateTime; <br>} <br> <br> <br>/* Adjust the current time by the input value.  This allows an <br>   external time source to work out some of the latency of the clock <br>   system and adjust the "current" time accordingly.  The intent is <br>   that the time returned to the user is synchronised to a clock <br>   source and allows drift to be catered for. <br> <br>   For example: if the clock source detects a drift it can pass a delta <br>   to the current time rather than having to set an explicit time. <br>*/ <br> <br>STDMETHODIMP CBaseReferenceClock::SetTimeDelta(const REFERENCE_TIME &amp; TimeDelta) <br>{ <br>#ifdef DEBUG <br> <br>    // Just break if it's a really dumb value <br>    LONGLONG llDelta = TimeDelta &gt; 0 ? TimeDelta : -TimeDelta; <br>    if (llDelta &gt; UNITS * 1000) { <br>        DbgLog((LOG_TRACE, 0, TEXT("Bad Time Delta"))); <br>        DebugBreak(); <br>    } <br> <br>    // We're going to calculate a "severity" for the time change. Max -1 <br>    // min 8.  We'll then use this as the debug logging level for a <br>    // debug log message. <br>    const LONG usDelta = LONG(TimeDelta/10);      // Delta in micro-secs <br> <br>    DWORD delta        = abs(usDelta);            // varying delta <br>    // Severity == 8 - ceil(log&lt;base 8&gt;(abs( micro-secs delta))) <br>    int   Severity     = 8; <br>    while ( delta &gt; 0 ) <br>    { <br>        delta &gt;&gt;= 3;                              // div 8 <br>        Severity--; <br>    } <br> <br>    // Sev == 0 =&gt; &gt; 2 second delta! <br>    DbgLog((LOG_TIMING, Severity &lt; 0 ? 0 : Severity, <br>        TEXT("Sev %2i: CSystemClock::SetTimeDelta(%8ld us) %lu -&gt; %lu ms."), <br>        Severity, usDelta, DWORD(ConvertToMilliseconds(m_rtPrivateTime)), <br>        DWORD(ConvertToMilliseconds(TimeDelta+m_rtPrivateTime)) )); <br> <br>    // Don't want the DbgBreak to fire when running stress on debug-builds. <br>    #ifdef BREAK_ON_SEVERE_TIME_DELTA <br>        if (Severity &lt; 0) <br>            DbgBreakPoint(TEXT("SetTimeDelta &gt; 16 seconds!"), <br>                          TEXT(__FILE__),__LINE__); <br>    #endif <br> <br>#endif <br> <br>    CAutoLock cObjectLock(this); <br>    m_rtPrivateTime += TimeDelta; <br>    // If time goes forwards, and we have advises, then we need to <br>    // trigger the thread so that it can re-evaluate its wait time. <br>    // Since we don't want the cost of the thread switches if the change <br>    // is really small, only do it if clock goes forward by more than <br>    // 0.5 millisecond.  If the time goes backwards, the thread will <br>    // wake up "early" (relativly speaking) and will re-evaluate at <br>    // that time. <br>    if ( TimeDelta &gt; 5000 &amp;&amp; m_pSchedule-&gt;GetAdviseCount() &gt; 0 ) TriggerThread(); <br>    return NOERROR; <br>} <br> <br>// Thread stuff <br> <br>DWORD __stdcall CBaseReferenceClock::AdviseThreadFunction(LPVOID p) <br>{ <br>    return DWORD(reinterpret_cast&lt;CBaseReferenceClock*&gt;(p)-&gt;AdviseThread()); <br>} <br> <br>HRESULT CBaseReferenceClock::AdviseThread() <br>{ <br>    DWORD dwWait = INFINITE; <br> <br>    // The first thing we do is wait until something interesting happens <br>    // (meaning a first advise or shutdown).  This prevents us calling <br>    // GetPrivateTime immediately which is goodness as that is a virtual <br>    // routine and the derived class may not yet be constructed.  (This <br>    // thread is created in the base class constructor.) <br> <br>    while ( !m_bAbort ) <br>    { <br>        // Wait for an interesting event to happen <br>        DbgLog((LOG_TIMING, 3, TEXT("CBaseRefClock::AdviseThread() Delay: %lu ms"), dwWait )); <br>        WaitForSingleObject(m_pSchedule-&gt;GetEvent(), dwWait); <br>        if (m_bAbort) break; <br> <br>        // There are several reasons why we need to work from the internal <br>        // time, mainly to do with what happens when time goes backwards. <br>        // Mainly, it stop us looping madly if an event is just about to <br>        // expire when the clock goes backward (i.e. GetTime stop for a <br>        // while). <br>        const REFERENCE_TIME  rtNow = GetPrivateTime(); <br> <br>        DbgLog((LOG_TIMING, 3, <br>              TEXT("CBaseRefClock::AdviseThread() Woke at = %lu ms"), <br>              ConvertToMilliseconds(rtNow) )); <br> <br>        // We must add in a millisecond, since this is the resolution of our <br>        // WaitForSingleObject timer.  Failure to do so will cause us to loop <br>        // franticly for (approx) 1 a millisecond. <br>        m_rtNextAdvise = m_pSchedule-&gt;Advise( 10000 + rtNow ); <br>        LONGLONG llWait = m_rtNextAdvise - rtNow; <br> <br>        ASSERT( llWait &gt; 0 ); <br> <br>        llWait = ConvertToMilliseconds(llWait); <br>        // DON'T replace this with a max!! (The type's of these things is VERY important) <br>        dwWait = (llWait &gt; REFERENCE_TIME(UINT_MAX)) ? UINT_MAX : DWORD(llWait); <br>    }; <br>    return NOERROR; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
