<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>COMBASE.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2739"></a>COMBASE.CPP</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>// Base class hierachy for creating COM objects, December 1994 <br> <br>#include &lt;streams.h&gt; <br>#pragma warning( disable : 4514 )   // Disable warnings re unused inline functions <br> <br> <br>/* Define the static member variable */ <br> <br>LONG CBaseObject::m_cObjects = 0; <br> <br> <br>/* Constructor */ <br> <br>CBaseObject::CBaseObject(const TCHAR *pName) <br>{ <br>    /* Increment the number of active objects */ <br>    InterlockedIncrement(&amp;m_cObjects); <br> <br>#ifdef DEBUG <br>    m_dwCookie = DbgRegisterObjectCreation(pName); <br>#endif <br>} <br> <br> <br>HINSTANCEhlibOLEAut32; <br> <br>/* Destructor */ <br> <br>CBaseObject::~CBaseObject() <br>{ <br>    /* Decrement the number of objects active */ <br>    if (InterlockedDecrement(&amp;m_cObjects) == 0) { <br>if (hlibOLEAut32) { <br>    FreeLibrary(hlibOLEAut32); <br> <br>    hlibOLEAut32 = 0; <br>} <br>    }; <br> <br>     <br>#ifdef DEBUG <br>    DbgRegisterObjectDestruction(m_dwCookie); <br>#endif <br>} <br> <br>static const TCHAR szOle32Aut[]   = TEXT("OleAut32.dll"); <br> <br>HINSTANCE LoadOLEAut32() <br>{ <br>    if (hlibOLEAut32 == 0) { <br> <br>hlibOLEAut32 = LoadLibrary(szOle32Aut); <br>    } <br> <br>    return hlibOLEAut32; <br>} <br> <br> <br>/* Constructor */ <br> <br>// We know we use "this" in the initialization list, we also know we don't modify *phr. <br>#pragma warning( disable : 4355 4100 ) <br>CUnknown::CUnknown(const TCHAR *pName, LPUNKNOWN pUnk) <br>: CBaseObject(pName) <br>/* Start the object with a reference count of zero - when the      */ <br>/* object is queried for it's first interface this may be          */ <br>/* incremented depending on whether or not this object is          */ <br>/* currently being aggregated upon                                 */ <br>, m_cRef(0) <br>/* Set our pointer to our IUnknown interface.                      */ <br>/* If we have an outer, use its, otherwise use ours.               */ <br>/* This pointer effectivly points to the owner of                  */ <br>/* this object and can be accessed by the GetOwner() method.       */ <br>, m_pUnknown( pUnk != 0 ? pUnk : reinterpret_cast&lt;LPUNKNOWN&gt;( static_cast&lt;PNDUNKNOWN&gt;(this) ) ) <br> /* Why the double cast?  Well, the inner cast is a type-safe cast */ <br> /* to pointer to a type from which we inherit.  The second is     */ <br> /* type-unsafe but works because INonDelegatingUnknown "behaves   */ <br> /* like" IUnknown. (Only the names on the methods change.)        */ <br>{ <br>    // Everything we need to do has been done in the initializer list <br>} <br> <br>// This does the same as above except it has a useless HRESULT argument <br>// use the previous constructor, this is just left for compatibility... <br>CUnknown::CUnknown(TCHAR *pName, LPUNKNOWN pUnk,HRESULT *phr) : <br>    CBaseObject(pName), <br>    m_cRef(0), <br>    m_pUnknown( pUnk != 0 ? pUnk : reinterpret_cast&lt;LPUNKNOWN&gt;( static_cast&lt;PNDUNKNOWN&gt;(this) ) ) <br>{ <br>} <br>#pragma warning( default : 4355 4100 ) <br> <br> <br>/* QueryInterface */ <br> <br>STDMETHODIMP CUnknown::NonDelegatingQueryInterface(REFIID riid, void ** ppv) <br>{ <br>    CheckPointer(ppv,E_POINTER); <br>    ValidateReadWritePtr(ppv,sizeof(PVOID)); <br> <br>    /* We know only about IUnknown */ <br> <br>    if (riid == IID_IUnknown) { <br>        GetInterface((LPUNKNOWN) (PNDUNKNOWN) this, ppv); <br>        return NOERROR; <br>    } else { <br>        *ppv = NULL; <br>        return E_NOINTERFACE; <br>    } <br>} <br> <br>/* We have to ensure that we DON'T use a max macro, since these will typically   */ <br>/* lead to one of the parameters being evaluated twice.  Since we are worried    */ <br>/* about concurrency, we can't afford to access the m_cRef twice since we can't  */ <br>/* afford to run the risk that its value having changed between accesses.        */ <br>#ifdef max <br>    #undef max <br>#endif <br> <br>template&lt;class T&gt; inline static T max( const T &amp; a, const T &amp; b ) <br>{ <br>    return a &gt; b ? a : b; <br>} <br> <br>/* AddRef */ <br> <br>STDMETHODIMP_(ULONG) CUnknown::NonDelegatingAddRef() <br>{ <br>    LONG lRef = InterlockedIncrement( &amp;m_cRef ); <br>    ASSERT(lRef &gt; 0); <br>    DbgLog((LOG_MEMORY,3,TEXT("    Obj %d ref++ = %d"), <br>           m_dwCookie, m_cRef)); <br>    return max(ULONG(m_cRef), 1ul); <br>} <br> <br> <br>/* Release */ <br> <br>STDMETHODIMP_(ULONG) CUnknown::NonDelegatingRelease() <br>{ <br>    /* If the reference count drops to zero delete ourselves */ <br> <br>    LONG lRef = InterlockedDecrement( &amp;m_cRef ); <br>    ASSERT(lRef &gt;= 0); <br> <br>    DbgLog((LOG_MEMORY,3,TEXT("    Object %d ref-- = %d"), <br>    m_dwCookie, m_cRef)); <br>    if (lRef == 0) { <br> <br>        // COM rules say we must protect against re-entrancy. <br>        // If we are an aggregator and we hold our own interfaces <br>        // on the aggregatee, the QI for these interfaces will <br>        // addref ourselves. So after doing the QI we must release <br>        // a ref count on ourselves. Then, before releasing the <br>        // private interface, we must addref ourselves. When we do <br>        // this from the destructor here it will result in the ref <br>        // count going to 1 and then back to 0 causing us to <br>        // re-enter the destructor. Hence we add an extra refcount here <br>        // once we know we will delete the object. <br>        // for an example aggregator see filgraph\distrib.cpp. <br> <br>        m_cRef++; <br> <br>        delete this; <br>        return ULONG(0); <br>    } else { <br>        return max(ULONG(m_cRef), 1ul); <br>    } <br>} <br> <br> <br>/* Return an interface pointer to a requesting client <br>   performing a thread safe AddRef as necessary */ <br> <br>STDAPI GetInterface(LPUNKNOWN pUnk, void **ppv) <br>{ <br>    CheckPointer(ppv, E_POINTER); <br>    *ppv = pUnk; <br>    pUnk-&gt;AddRef(); <br>    return NOERROR; <br>} <br> <br> <br>/* Compares two interfaces and returns TRUE if they are on the same object */ <br> <br>BOOL WINAPI IsEqualObject(IUnknown *pFirst, IUnknown *pSecond) <br>{ <br>    /*  Different objects can't have the same interface pointer for <br>        any interface <br>    */ <br>    if (pFirst == pSecond) { <br>        return TRUE; <br>    } <br>    /*  OK - do it the hard way - check if they have the same <br>        IUnknown pointers - a single object can only have one of these <br>    */ <br>    LPUNKNOWN pUnknown1;     // Retrieve the IUnknown interface <br>    LPUNKNOWN pUnknown2;     // Retrieve the other IUnknown interface <br>    HRESULT hr;              // General OLE return code <br> <br>    ASSERT(pFirst); <br>    ASSERT(pSecond); <br> <br>    /* See if the IUnknown pointers match */ <br> <br>    hr = pFirst-&gt;QueryInterface(IID_IUnknown,(void **) &amp;pUnknown1); <br>    ASSERT(SUCCEEDED(hr)); <br>    ASSERT(pUnknown1); <br> <br>    hr = pSecond-&gt;QueryInterface(IID_IUnknown,(void **) &amp;pUnknown2); <br>    ASSERT(SUCCEEDED(hr)); <br>    ASSERT(pUnknown2); <br> <br>    /* Release the extra interfaces we hold */ <br> <br>    pUnknown1-&gt;Release(); <br>    pUnknown2-&gt;Release(); <br>    return (pUnknown1 == pUnknown2); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
