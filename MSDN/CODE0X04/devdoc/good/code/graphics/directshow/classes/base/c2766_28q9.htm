<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>VIDEOCTL.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2781"></a>VIDEOCTL.CPP</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>#include &lt;streams.h&gt; <br>#include "ddmm.h" <br> <br>// Load a string from the resource file string table. The buffer must be at <br>// least STR_MAX_LENGTH bytes. The easiest way to use this is to declare a <br>// buffer in the property page class and use it for all string loading. It <br>// cannot be static as multiple property pages may be active simultaneously <br> <br>TCHAR *WINAPI StringFromResource(TCHAR *pBuffer, int iResourceID) <br>{ <br>    if (LoadString(g_hInst,iResourceID,pBuffer,STR_MAX_LENGTH) == 0) { <br>        return TEXT(""); <br>    } <br>    return pBuffer; <br>} <br> <br> <br>// Property pages typically are called through their OLE interfaces. These <br>// use UNICODE strings regardless of how the binary is built. So when we <br>// load strings from the resource file we sometimes want to convert them <br>// to UNICODE. This method is passed the target UNICODE buffer and does a <br>// convert after loading the string (if built UNICODE this is not needed) <br>// On WinNT we can explicitly call LoadStringW which saves two conversions <br> <br>#ifndef UNICODE <br> <br>WCHAR * WINAPI WideStringFromResource(WCHAR *pBuffer, int iResourceID) <br>{ <br>    *pBuffer = 0; <br> <br>    if (g_amPlatform == VER_PLATFORM_WIN32_NT) { <br>LoadStringW(g_hInst,iResourceID,pBuffer,STR_MAX_LENGTH); <br>    } else { <br> <br>CHAR szBuffer[STR_MAX_LENGTH]; <br>DWORD dwStringLength = LoadString(g_hInst,iResourceID,szBuffer,STR_MAX_LENGTH); <br>// if we loaded a string convert it to wide characters, ensuring <br>// that we also null terminate the result. <br>if (dwStringLength++) { <br>    MultiByteToWideChar(CP_ACP,0,szBuffer,dwStringLength,pBuffer,STR_MAX_LENGTH); <br>} <br>    } <br>    return pBuffer; <br>} <br> <br>#endif <br> <br> <br>// Helper function to calculate the size of the dialog <br> <br>BOOL WINAPI GetDialogSize(int iResourceID, <br>                          DLGPROC pDlgProc, <br>                          LPARAM lParam, <br>                          SIZE *pResult) <br>{ <br>    RECT rc; <br>    HWND hwnd; <br> <br>    // Create a temporary property page <br> <br>    hwnd = CreateDialogParam(g_hInst, <br>                             MAKEINTRESOURCE(iResourceID), <br>                             GetDesktopWindow(), <br>                             pDlgProc, <br>                             lParam); <br>    if (hwnd == NULL) { <br>        return FALSE; <br>    } <br> <br>    GetWindowRect(hwnd, &amp;rc); <br>    pResult-&gt;cx = rc.right - rc.left; <br>    pResult-&gt;cy = rc.bottom - rc.top; <br> <br>    DestroyWindow(hwnd); <br>    return TRUE; <br>} <br> <br> <br>// Class that aggregates on the IDirectDraw interface. Although DirectDraw <br>// has the ability in its interfaces to be aggregated they're not currently <br>// implemented. This makes it difficult for various parts of Quartz that want <br>// to aggregate these interfaces. In particular the video renderer passes out <br>// media samples that expose IDirectDraw and IDirectDrawSurface. The filter <br>// graph manager also exposes IDirectDraw as a plug in distributor. For these <br>// objects we provide these aggregation classes that republish the interfaces <br> <br>STDMETHODIMP CAggDirectDraw::NonDelegatingQueryInterface(REFIID riid, void **ppv) <br>{ <br>    ASSERT(m_pDirectDraw); <br> <br>    // Do we have this interface <br> <br>    if (riid == IID_IDirectDraw) { <br>        return GetInterface((IDirectDraw *)this,ppv); <br>    } else { <br>        return CUnknown::NonDelegatingQueryInterface(riid,ppv); <br>    } <br>} <br> <br> <br>STDMETHODIMP CAggDirectDraw::Compact() <br>{ <br>    ASSERT(m_pDirectDraw); <br>    return m_pDirectDraw-&gt;Compact(); <br>} <br> <br> <br>STDMETHODIMP CAggDirectDraw::CreateClipper(DWORD dwFlags,LPDIRECTDRAWCLIPPER *lplpDDClipper,IUnknown *pUnkOuter) <br>{ <br>    ASSERT(m_pDirectDraw); <br>    return m_pDirectDraw-&gt;CreateClipper(dwFlags,lplpDDClipper,pUnkOuter); <br>} <br> <br> <br>STDMETHODIMP CAggDirectDraw::CreatePalette(DWORD dwFlags,LPPALETTEENTRY lpColorTable,LPDIRECTDRAWPALETTE *lplpDDPalette,IUnknown *pUnkOuter) <br>{ <br>    ASSERT(m_pDirectDraw); <br>    return m_pDirectDraw-&gt;CreatePalette(dwFlags,lpColorTable,lplpDDPalette,pUnkOuter); <br>} <br> <br> <br>STDMETHODIMP CAggDirectDraw::CreateSurface(LPDDSURFACEDESC lpDDSurfaceDesc,LPDIRECTDRAWSURFACE *lplpDDSurface,IUnknown *pUnkOuter) <br>{ <br>    ASSERT(m_pDirectDraw); <br>    return m_pDirectDraw-&gt;CreateSurface(lpDDSurfaceDesc,lplpDDSurface,pUnkOuter); <br>} <br> <br> <br>STDMETHODIMP CAggDirectDraw::DuplicateSurface(LPDIRECTDRAWSURFACE lpDDSurface,LPDIRECTDRAWSURFACE *lplpDupDDSurface) <br>{ <br>    ASSERT(m_pDirectDraw); <br>    return m_pDirectDraw-&gt;DuplicateSurface(lpDDSurface,lplpDupDDSurface); <br>} <br> <br> <br>STDMETHODIMP CAggDirectDraw::EnumDisplayModes(DWORD dwSurfaceDescCount,LPDDSURFACEDESC lplpDDSurfaceDescList,LPVOID lpContext,LPDDENUMMODESCALLBACK lpEnumCallback) <br>{ <br>    ASSERT(m_pDirectDraw); <br>    return m_pDirectDraw-&gt;EnumDisplayModes(dwSurfaceDescCount,lplpDDSurfaceDescList,lpContext,lpEnumCallback); <br>} <br> <br> <br>STDMETHODIMP CAggDirectDraw::EnumSurfaces(DWORD dwFlags,LPDDSURFACEDESC lpDDSD,LPVOID lpContext,LPDDENUMSURFACESCALLBACK lpEnumCallback) <br>{ <br>    ASSERT(m_pDirectDraw); <br>    return m_pDirectDraw-&gt;EnumSurfaces(dwFlags,lpDDSD,lpContext,lpEnumCallback); <br>} <br> <br> <br>STDMETHODIMP CAggDirectDraw::FlipToGDISurface() <br>{ <br>    ASSERT(m_pDirectDraw); <br>    return m_pDirectDraw-&gt;FlipToGDISurface(); <br>} <br> <br> <br>STDMETHODIMP CAggDirectDraw::GetCaps(LPDDCAPS lpDDDriverCaps,LPDDCAPS lpDDHELCaps) <br>{ <br>    ASSERT(m_pDirectDraw); <br>    return m_pDirectDraw-&gt;GetCaps(lpDDDriverCaps,lpDDHELCaps); <br>} <br> <br> <br>STDMETHODIMP CAggDirectDraw::GetDisplayMode(LPDDSURFACEDESC lpDDSurfaceDesc) <br>{ <br>    ASSERT(m_pDirectDraw); <br>    return m_pDirectDraw-&gt;GetDisplayMode(lpDDSurfaceDesc); <br>} <br> <br> <br>STDMETHODIMP CAggDirectDraw::GetFourCCCodes(LPDWORD lpNumCodes,LPDWORD lpCodes) <br>{ <br>    ASSERT(m_pDirectDraw); <br>    return m_pDirectDraw-&gt;GetFourCCCodes(lpNumCodes,lpCodes); <br>} <br> <br> <br>STDMETHODIMP CAggDirectDraw::GetGDISurface(LPDIRECTDRAWSURFACE *lplpGDIDDSurface) <br>{ <br>    ASSERT(m_pDirectDraw); <br>    return m_pDirectDraw-&gt;GetGDISurface(lplpGDIDDSurface); <br>} <br> <br> <br>STDMETHODIMP CAggDirectDraw::GetMonitorFrequency(LPDWORD lpdwFrequency) <br>{ <br>    ASSERT(m_pDirectDraw); <br>    return m_pDirectDraw-&gt;GetMonitorFrequency(lpdwFrequency); <br>} <br> <br> <br>STDMETHODIMP CAggDirectDraw::GetScanLine(LPDWORD lpdwScanLine) <br>{ <br>    ASSERT(m_pDirectDraw); <br>    return m_pDirectDraw-&gt;GetScanLine(lpdwScanLine); <br>} <br> <br> <br>STDMETHODIMP CAggDirectDraw::GetVerticalBlankStatus(LPBOOL lpblsInVB) <br>{ <br>    ASSERT(m_pDirectDraw); <br>    return m_pDirectDraw-&gt;GetVerticalBlankStatus(lpblsInVB); <br>} <br> <br> <br>STDMETHODIMP CAggDirectDraw::Initialize(GUID *lpGUID) <br>{ <br>    ASSERT(m_pDirectDraw); <br>    return m_pDirectDraw-&gt;Initialize(lpGUID); <br>} <br> <br> <br>STDMETHODIMP CAggDirectDraw::RestoreDisplayMode() <br>{ <br>    ASSERT(m_pDirectDraw); <br>    return m_pDirectDraw-&gt;RestoreDisplayMode(); <br>} <br> <br> <br>STDMETHODIMP CAggDirectDraw::SetCooperativeLevel(HWND hWnd,DWORD dwFlags) <br>{ <br>    ASSERT(m_pDirectDraw); <br>    return m_pDirectDraw-&gt;SetCooperativeLevel(hWnd,dwFlags); <br>} <br> <br> <br>STDMETHODIMP CAggDirectDraw::SetDisplayMode(DWORD dwWidth,DWORD dwHeight,DWORD dwBpp) <br>{ <br>    ASSERT(m_pDirectDraw); <br>    return m_pDirectDraw-&gt;SetDisplayMode(dwWidth,dwHeight,dwBpp); <br>} <br> <br> <br>STDMETHODIMP CAggDirectDraw::WaitForVerticalBlank(DWORD dwFlags,HANDLE hEvent) <br>{ <br>    ASSERT(m_pDirectDraw); <br>    return m_pDirectDraw-&gt;WaitForVerticalBlank(dwFlags,hEvent); <br>} <br> <br> <br>// Class that aggregates an IDirectDrawSurface interface. Although DirectDraw <br>// has the ability in its interfaces to be aggregated they're not currently <br>// implemented. This makes it difficult for various parts of Quartz that want <br>// to aggregate these interfaces. In particular the video renderer passes out <br>// media samples that expose IDirectDraw and IDirectDrawSurface. The filter <br>// graph manager also exposes IDirectDraw as a plug in distributor. For these <br>// objects we provide these aggregation classes that republish the interfaces <br> <br>STDMETHODIMP CAggDrawSurface::NonDelegatingQueryInterface(REFIID riid, void **ppv) <br>{ <br>    ASSERT(m_pDirectDrawSurface); <br> <br>    // Do we have this interface <br> <br>    if (riid == IID_IDirectDrawSurface) { <br>        return GetInterface((IDirectDrawSurface *)this,ppv); <br>    } else { <br>        return CUnknown::NonDelegatingQueryInterface(riid,ppv); <br>    } <br>} <br> <br> <br>STDMETHODIMP CAggDrawSurface::AddAttachedSurface(LPDIRECTDRAWSURFACE lpDDSAttachedSurface) <br>{ <br>    ASSERT(m_pDirectDrawSurface); <br>    return m_pDirectDrawSurface-&gt;AddAttachedSurface(lpDDSAttachedSurface); <br>} <br> <br> <br>STDMETHODIMP CAggDrawSurface::AddOverlayDirtyRect(LPRECT lpRect) <br>{ <br>    ASSERT(m_pDirectDrawSurface); <br>    return m_pDirectDrawSurface-&gt;AddOverlayDirtyRect(lpRect); <br>} <br> <br> <br>STDMETHODIMP CAggDrawSurface::Blt(LPRECT lpDestRect,LPDIRECTDRAWSURFACE lpDDSrcSurface,LPRECT lpSrcRect,DWORD dwFlags,LPDDBLTFX lpDDBltFx) <br>{ <br>    ASSERT(m_pDirectDrawSurface); <br>    return m_pDirectDrawSurface-&gt;Blt(lpDestRect,lpDDSrcSurface,lpSrcRect,dwFlags,lpDDBltFx); <br>} <br> <br> <br>STDMETHODIMP CAggDrawSurface::BltBatch(LPDDBLTBATCH lpDDBltBatch,DWORD dwCount,DWORD dwFlags) <br>{ <br>    ASSERT(m_pDirectDrawSurface); <br>    return m_pDirectDrawSurface-&gt;BltBatch(lpDDBltBatch,dwCount,dwFlags); <br>} <br> <br> <br>STDMETHODIMP CAggDrawSurface::BltFast(DWORD dwX,DWORD dwY,LPDIRECTDRAWSURFACE lpDDSrcSurface,LPRECT lpSrcRect,DWORD dwTrans) <br>{ <br>    ASSERT(m_pDirectDrawSurface); <br>    return m_pDirectDrawSurface-&gt;BltFast(dwX,dwY,lpDDSrcSurface,lpSrcRect,dwTrans); <br>} <br> <br> <br>STDMETHODIMP CAggDrawSurface::DeleteAttachedSurface(DWORD dwFlags,LPDIRECTDRAWSURFACE lpDDSAttachedSurface) <br>{ <br>    ASSERT(m_pDirectDrawSurface); <br>    return m_pDirectDrawSurface-&gt;DeleteAttachedSurface(dwFlags,lpDDSAttachedSurface); <br>} <br> <br> <br>STDMETHODIMP CAggDrawSurface::EnumAttachedSurfaces(LPVOID lpContext,LPDDENUMSURFACESCALLBACK lpEnumSurfacesCallback) <br>{ <br>    ASSERT(m_pDirectDrawSurface); <br>    return m_pDirectDrawSurface-&gt;EnumAttachedSurfaces(lpContext,lpEnumSurfacesCallback); <br>} <br> <br> <br>STDMETHODIMP CAggDrawSurface::EnumOverlayZOrders(DWORD dwFlags,LPVOID lpContext,LPDDENUMSURFACESCALLBACK lpfnCallback) <br>{ <br>    ASSERT(m_pDirectDrawSurface); <br>    return m_pDirectDrawSurface-&gt;EnumOverlayZOrders(dwFlags,lpContext,lpfnCallback); <br>} <br> <br> <br>STDMETHODIMP CAggDrawSurface::Flip(LPDIRECTDRAWSURFACE lpDDSurfaceTargetOverride,DWORD dwFlags) <br>{ <br>    ASSERT(m_pDirectDrawSurface); <br>    return m_pDirectDrawSurface-&gt;Flip(lpDDSurfaceTargetOverride,dwFlags); <br>} <br> <br> <br>STDMETHODIMP CAggDrawSurface::GetAttachedSurface(LPDDSCAPS lpDDSCaps,LPDIRECTDRAWSURFACE *lplpDDAttachedSurface) <br>{ <br>    ASSERT(m_pDirectDrawSurface); <br>    return m_pDirectDrawSurface-&gt;GetAttachedSurface(lpDDSCaps,lplpDDAttachedSurface); <br>} <br> <br> <br>STDMETHODIMP CAggDrawSurface::GetBltStatus(DWORD dwFlags) <br>{ <br>    ASSERT(m_pDirectDrawSurface); <br>    return m_pDirectDrawSurface-&gt;GetBltStatus(dwFlags); <br>} <br> <br> <br>STDMETHODIMP CAggDrawSurface::GetCaps(LPDDSCAPS lpDDSCaps) <br>{ <br>    ASSERT(m_pDirectDrawSurface); <br>    return m_pDirectDrawSurface-&gt;GetCaps(lpDDSCaps); <br>} <br> <br> <br>STDMETHODIMP CAggDrawSurface::GetClipper(LPDIRECTDRAWCLIPPER *lplpDDClipper) <br>{ <br>    ASSERT(m_pDirectDrawSurface); <br>    return m_pDirectDrawSurface-&gt;GetClipper(lplpDDClipper); <br>} <br> <br> <br>STDMETHODIMP CAggDrawSurface::GetColorKey(DWORD dwFlags,LPDDCOLORKEY lpDDColorKey) <br>{ <br>    ASSERT(m_pDirectDrawSurface); <br>    return m_pDirectDrawSurface-&gt;GetColorKey(dwFlags,lpDDColorKey); <br>} <br> <br> <br>STDMETHODIMP CAggDrawSurface::GetDC(HDC *lphDC) <br>{ <br>    ASSERT(m_pDirectDrawSurface); <br>    return m_pDirectDrawSurface-&gt;GetDC(lphDC); <br>} <br> <br> <br>STDMETHODIMP CAggDrawSurface::GetFlipStatus(DWORD dwFlags) <br>{ <br>    ASSERT(m_pDirectDrawSurface); <br>    return m_pDirectDrawSurface-&gt;GetFlipStatus(dwFlags); <br>} <br> <br> <br>STDMETHODIMP CAggDrawSurface::GetOverlayPosition(LPLONG lpdwX,LPLONG lpdwY) <br>{ <br>    ASSERT(m_pDirectDrawSurface); <br>    return m_pDirectDrawSurface-&gt;GetOverlayPosition(lpdwX,lpdwY); <br>} <br> <br> <br>STDMETHODIMP CAggDrawSurface::GetPalette(LPDIRECTDRAWPALETTE *lplpDDPalette) <br>{ <br>    ASSERT(m_pDirectDrawSurface); <br>    return m_pDirectDrawSurface-&gt;GetPalette(lplpDDPalette); <br>} <br> <br> <br>STDMETHODIMP CAggDrawSurface::GetPixelFormat(LPDDPIXELFORMAT lpDDPixelFormat) <br>{ <br>    ASSERT(m_pDirectDrawSurface); <br>    return m_pDirectDrawSurface-&gt;GetPixelFormat(lpDDPixelFormat); <br>} <br> <br> <br>// A bit of a hack alert here. Our media samples in ActiveMovie aggregate on <br>// IDirectDraw and IDirectDrawSurface (ie are available through IMediaSample <br>// by QueryInterface). Unfortunately the underlying DirectDraw code cannot <br>// be aggregated so we have to use these classes. The snag is that when we <br>// call a different surface and pass in this interface as perhaps the source <br>// surface the call will fail because DirectDraw dereferences the pointer to <br>// get at its private data structures. Therefore we supply this hack to give <br>// access to the real IDirectDraw surface. A filter can call GetSurfaceDesc <br>// and we will fill in the lpSurface pointer with the real underlying surface <br> <br>STDMETHODIMP CAggDrawSurface::GetSurfaceDesc(LPDDSURFACEDESC lpDDSurfaceDesc) <br>{ <br>    ASSERT(m_pDirectDrawSurface); <br> <br>    // First call down to the underlying DirectDraw <br> <br>    HRESULT hr = m_pDirectDrawSurface-&gt;GetSurfaceDesc(lpDDSurfaceDesc); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br> <br>    // Store the real DirectDrawSurface interface <br>    lpDDSurfaceDesc-&gt;lpSurface = m_pDirectDrawSurface; <br>    return hr; <br>} <br> <br> <br>STDMETHODIMP CAggDrawSurface::Initialize(LPDIRECTDRAW lpDD,LPDDSURFACEDESC lpDDSurfaceDesc) <br>{ <br>    ASSERT(m_pDirectDrawSurface); <br>    return m_pDirectDrawSurface-&gt;Initialize(lpDD,lpDDSurfaceDesc); <br>} <br> <br> <br>STDMETHODIMP CAggDrawSurface::IsLost() <br>{ <br>    ASSERT(m_pDirectDrawSurface); <br>    return m_pDirectDrawSurface-&gt;IsLost(); <br>} <br> <br> <br>STDMETHODIMP CAggDrawSurface::Lock(LPRECT lpDestRect,LPDDSURFACEDESC lpDDSurfaceDesc,DWORD dwFlags,HANDLE hEvent) <br>{ <br>    ASSERT(m_pDirectDrawSurface); <br>    return m_pDirectDrawSurface-&gt;Lock(lpDestRect,lpDDSurfaceDesc,dwFlags,hEvent); <br>} <br> <br> <br>STDMETHODIMP CAggDrawSurface::ReleaseDC(HDC hDC) <br>{ <br>    ASSERT(m_pDirectDrawSurface); <br>    return m_pDirectDrawSurface-&gt;ReleaseDC(hDC); <br>} <br> <br> <br>STDMETHODIMP CAggDrawSurface::Restore() <br>{ <br>    ASSERT(m_pDirectDrawSurface); <br>    return m_pDirectDrawSurface-&gt;Restore(); <br>} <br> <br> <br>STDMETHODIMP CAggDrawSurface::SetClipper(LPDIRECTDRAWCLIPPER lpDDClipper) <br>{ <br>    ASSERT(m_pDirectDrawSurface); <br>    return m_pDirectDrawSurface-&gt;SetClipper(lpDDClipper); <br>} <br> <br> <br>STDMETHODIMP CAggDrawSurface::SetColorKey(DWORD dwFlags,LPDDCOLORKEY lpDDColorKey) <br>{ <br>    ASSERT(m_pDirectDrawSurface); <br>    return m_pDirectDrawSurface-&gt;SetColorKey(dwFlags,lpDDColorKey); <br>} <br> <br> <br>STDMETHODIMP CAggDrawSurface::SetOverlayPosition(LONG dwX,LONG dwY) <br>{ <br>    ASSERT(m_pDirectDrawSurface); <br>    return m_pDirectDrawSurface-&gt;SetOverlayPosition(dwX,dwY); <br>} <br> <br> <br>STDMETHODIMP CAggDrawSurface::SetPalette(LPDIRECTDRAWPALETTE lpDDPalette) <br>{ <br>    ASSERT(m_pDirectDrawSurface); <br>    return m_pDirectDrawSurface-&gt;SetPalette(lpDDPalette); <br>} <br> <br> <br>STDMETHODIMP CAggDrawSurface::Unlock(LPVOID lpSurfaceData) <br>{ <br>    ASSERT(m_pDirectDrawSurface); <br>    return m_pDirectDrawSurface-&gt;Unlock(lpSurfaceData); <br>} <br> <br> <br>STDMETHODIMP CAggDrawSurface::UpdateOverlay(LPRECT lpSrcRect,LPDIRECTDRAWSURFACE lpDDDestSurface,LPRECT lpDestRect,DWORD dwFlags,LPDDOVERLAYFX lpDDOverlayFX) <br>{ <br>    ASSERT(m_pDirectDrawSurface); <br>    return m_pDirectDrawSurface-&gt;UpdateOverlay(lpSrcRect,lpDDDestSurface,lpDestRect,dwFlags,lpDDOverlayFX); <br>} <br> <br> <br>STDMETHODIMP CAggDrawSurface::UpdateOverlayDisplay(DWORD dwFlags) <br>{ <br>    ASSERT(m_pDirectDrawSurface); <br>    return m_pDirectDrawSurface-&gt;UpdateOverlayDisplay(dwFlags); <br>} <br> <br> <br>STDMETHODIMP CAggDrawSurface::UpdateOverlayZOrder(DWORD dwFlags,LPDIRECTDRAWSURFACE lpDDSReference) <br>{ <br>    ASSERT(m_pDirectDrawSurface); <br>    return m_pDirectDrawSurface-&gt;UpdateOverlayZOrder(dwFlags,lpDDSReference); <br>} <br> <br> <br>// ActiveMovie must work on multiple platforms, in particular it also runs on <br>// Windows NT 3.51 which does not have DirectDraw capabilities. The filters <br>// cannot therefore link statically to the DirectDraw library. To make their <br>// lives that little bit easier we provide this class that manages loading <br>// and unloading the library and creating the initial IDirectDraw interface <br> <br>CLoadDirectDraw::CLoadDirectDraw() : <br>    m_pDirectDraw(NULL), <br>    m_hDirectDraw(NULL) <br>{ <br>} <br> <br> <br>// Destructor forces unload <br> <br>CLoadDirectDraw::~CLoadDirectDraw() <br>{ <br>    ReleaseDirectDraw(); <br>} <br> <br> <br>// We can't be sure that DirectDraw is always available so we can't statically <br>// link to the library. Therefore we load the library, get the function entry <br>// point addresses and call them to create the driver objects. We return S_OK <br>// if we manage to load DirectDraw correctly otherwise we return E_NOINTERFACE <br>// We initialise a DirectDraw instance by explicitely loading the library and <br>// calling GetProcAddress on the DirectDrawCreate entry point that it exports <br> <br>// On a multi monitor system, we can get the DirectDraw object for any <br>// monitor (device) with the optional szDevice parameter <br> <br>HRESULT CLoadDirectDraw::LoadDirectDraw(LPSTR szDevice) <br>{ <br>    PDRAWCREATE pDrawCreate; <br>    PDRAWENUM pDrawEnum; <br>    LPDIRECTDRAWENUMERATEEXA pDrawEnumEx; <br>    HRESULT hr = NOERROR; <br> <br>    NOTE("Entering DoLoadDirectDraw"); <br> <br>    // Is DirectDraw already loaded <br> <br>    if (m_pDirectDraw) { <br>        NOTE("Already loaded"); <br>        ASSERT(m_hDirectDraw); <br>        return NOERROR; <br>    } <br> <br>    // Make sure the library is available <br> <br>    UINT ErrorMode = SetErrorMode(SEM_NOOPENFILEERRORBOX); <br>    m_hDirectDraw = LoadLibrary(TEXT("DDRAW.DLL")); <br>    SetErrorMode(ErrorMode); <br> <br>    if (m_hDirectDraw == NULL) { <br>        DbgLog((LOG_ERROR,1,TEXT("Can't load DDRAW.DLL"))); <br>        NOTE("No library"); <br>        return E_NOINTERFACE; <br>    } <br> <br>    // Get the DLL address for the creator function <br> <br>    pDrawCreate = (PDRAWCREATE)GetProcAddress(m_hDirectDraw,"DirectDrawCreate"); <br>    // force ANSI, we assume it <br>    pDrawEnum = (PDRAWENUM)GetProcAddress(m_hDirectDraw,"DirectDrawEnumerateA"); <br>    pDrawEnumEx = (LPDIRECTDRAWENUMERATEEXA)GetProcAddress(m_hDirectDraw, <br>"DirectDrawEnumerateExA"); <br> <br>    // We don't NEED DirectDrawEnumerateEx, that's just for multimon stuff <br>    if (pDrawCreate == NULL || pDrawEnum == NULL) { <br>        DbgLog((LOG_ERROR,1,TEXT("Can't get functions: Create=%x Enum=%x"), <br>pDrawCreate, pDrawEnum)); <br>        NOTE("No entry point"); <br>        ReleaseDirectDraw(); <br>        return E_NOINTERFACE; <br>    } <br> <br>    DbgLog((LOG_TRACE,3,TEXT("Creating DDraw for device %s"), <br>szDevice ? szDevice : "&lt;NULL&gt;")); <br> <br>    // Create a DirectDraw display provider for this device, using the fancy <br>    // multimon-aware version, if it exists <br>    if (pDrawEnumEx) <br>        m_pDirectDraw = DirectDrawCreateFromDeviceEx(szDevice, pDrawCreate, <br>pDrawEnumEx); <br>    else <br>        m_pDirectDraw = DirectDrawCreateFromDevice(szDevice, pDrawCreate, <br>pDrawEnum); <br> <br>    if (m_pDirectDraw == NULL) { <br>            DbgLog((LOG_ERROR,1,TEXT("Can't create DDraw"))); <br>            NOTE("No instance"); <br>            ReleaseDirectDraw(); <br>            return E_NOINTERFACE; <br>    } <br>    return NOERROR; <br>} <br> <br> <br>// Called to release any DirectDraw provider we previously loaded. We may be <br>// called at any time especially when something goes horribly wrong and when <br>// we need to clean up before returning so we can't guarantee that all state <br>// variables are consistent so free only those really allocated allocated <br>// This should only be called once all reference counts have been released <br> <br>void CLoadDirectDraw::ReleaseDirectDraw() <br>{ <br>    NOTE("Releasing DirectDraw driver"); <br> <br>    // Release any DirectDraw provider interface <br> <br>    if (m_pDirectDraw) { <br>        NOTE("Releasing instance"); <br>        m_pDirectDraw-&gt;Release(); <br>        m_pDirectDraw = NULL; <br>    } <br> <br>    // Decrement module load count <br> <br>    if (m_hDirectDraw) { <br>        NOTE("Unloading library"); <br>        FreeLibrary(m_hDirectDraw); <br>        m_hDirectDraw = NULL; <br>    } <br>} <br> <br> <br>// Return NOERROR (S_OK) if DirectDraw has been loaded by this object <br> <br>HRESULT CLoadDirectDraw::IsDirectDrawLoaded() <br>{ <br>    NOTE("Entering IsDirectDrawLoaded"); <br> <br>    if (m_pDirectDraw == NULL) { <br>        NOTE("DirectDraw not loaded"); <br>        return S_FALSE; <br>    } <br>    return NOERROR; <br>} <br> <br> <br>// Return the IDirectDraw interface we look after <br> <br>LPDIRECTDRAW CLoadDirectDraw::GetDirectDraw() <br>{ <br>    NOTE("Entering GetDirectDraw"); <br> <br>    if (m_pDirectDraw == NULL) { <br>        NOTE("No DirectDraw"); <br>        return NULL; <br>    } <br> <br>    NOTE("Returning DirectDraw"); <br>    m_pDirectDraw-&gt;AddRef(); <br>    return m_pDirectDraw; <br>} <br> <br> <br>// Are we running on Direct Draw version 1?  We need to find out as <br>// we rely on specific bug fixes in DirectDraw 2 for fullscreen playback. To <br>// find out, we simply see if it supports IDirectDraw2.  Only version 2 and <br>// higher support this. <br> <br>BOOL CLoadDirectDraw::IsDirectDrawVersion1() <br>{ <br> <br>    if (m_pDirectDraw == NULL) <br>return FALSE; <br> <br>    IDirectDraw2 *p = NULL; <br>    HRESULT hr = m_pDirectDraw-&gt;QueryInterface(IID_IDirectDraw2, (void **)&amp;p); <br>    if (p) <br>p-&gt;Release(); <br>    if (hr == NOERROR) { <br>        DbgLog((LOG_TRACE,3,TEXT("Direct Draw Version 2 or greater"))); <br>return FALSE; <br>    } else { <br>        DbgLog((LOG_TRACE,3,TEXT("Direct Draw Version 1"))); <br>return TRUE; <br>    } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
