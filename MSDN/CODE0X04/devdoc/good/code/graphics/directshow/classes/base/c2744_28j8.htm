<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CTLUTIL.H</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2744"></a>CTLUTIL.H</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>// Base classes implementing IDispatch parsing for the basic control dual <br>// interfaces. Derive from these and implement just the custom method and <br>// property methods. We also implement CPosPassThru that can be used by <br>// renderers and transforms to pass by IMediaPosition and IMediaSeeking <br> <br>#ifndef __CTLUTIL__ <br>#define __CTLUTIL__ <br> <br>// OLE Automation has different ideas of TRUE and FALSE <br> <br>#define OATRUE (-1) <br>#define OAFALSE (0) <br> <br> <br>// It's possible that we could replace this class with CreateStdDispatch <br> <br>class CBaseDispatch <br>{ <br>    ITypeInfo * m_pti; <br> <br>public: <br> <br>    CBaseDispatch() : m_pti(NULL) {} <br>    ~CBaseDispatch(); <br> <br>    /* IDispatch methods */ <br>    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo); <br> <br>    STDMETHODIMP GetTypeInfo( <br>      REFIID riid, <br>      UINT itinfo, <br>      LCID lcid, <br>      ITypeInfo ** pptinfo); <br> <br>    STDMETHODIMP GetIDsOfNames( <br>      REFIID riid, <br>      OLECHAR  ** rgszNames, <br>      UINT cNames, <br>      LCID lcid, <br>      DISPID * rgdispid); <br>}; <br> <br> <br>class AM_NOVTABLE CMediaControl : <br>    public IMediaControl, <br>    public CUnknown <br>{ <br>    CBaseDispatch m_basedisp; <br> <br>public: <br> <br>    CMediaControl(const TCHAR *, LPUNKNOWN); <br> <br>    DECLARE_IUNKNOWN <br> <br>    // override this to publicise our interfaces <br>    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv); <br> <br>    /* IDispatch methods */ <br>    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo); <br> <br>    STDMETHODIMP GetTypeInfo( <br>      UINT itinfo, <br>      LCID lcid, <br>      ITypeInfo ** pptinfo); <br> <br>    STDMETHODIMP GetIDsOfNames( <br>      REFIID riid, <br>      OLECHAR  ** rgszNames, <br>      UINT cNames, <br>      LCID lcid, <br>      DISPID * rgdispid); <br> <br>    STDMETHODIMP Invoke( <br>      DISPID dispidMember, <br>      REFIID riid, <br>      LCID lcid, <br>      WORD wFlags, <br>      DISPPARAMS * pdispparams, <br>      VARIANT * pvarResult, <br>      EXCEPINFO * pexcepinfo, <br>      UINT * puArgErr); <br>}; <br> <br> <br>class AM_NOVTABLE CMediaEvent : <br>    public IMediaEventEx, <br>    public CUnknown <br>{ <br>    CBaseDispatch m_basedisp; <br> <br>public: <br> <br>    CMediaEvent(const TCHAR *, LPUNKNOWN); <br> <br>    DECLARE_IUNKNOWN <br> <br>    // override this to publicise our interfaces <br>    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv); <br> <br>    /* IDispatch methods */ <br>    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo); <br> <br>    STDMETHODIMP GetTypeInfo( <br>      UINT itinfo, <br>      LCID lcid, <br>      ITypeInfo ** pptinfo); <br> <br>    STDMETHODIMP GetIDsOfNames( <br>      REFIID riid, <br>      OLECHAR  ** rgszNames, <br>      UINT cNames, <br>      LCID lcid, <br>      DISPID * rgdispid); <br> <br>    STDMETHODIMP Invoke( <br>      DISPID dispidMember, <br>      REFIID riid, <br>      LCID lcid, <br>      WORD wFlags, <br>      DISPPARAMS * pdispparams, <br>      VARIANT * pvarResult, <br>      EXCEPINFO * pexcepinfo, <br>      UINT * puArgErr); <br>}; <br> <br> <br>class AM_NOVTABLE CMediaPosition : <br>    public IMediaPosition, <br>    public CUnknown <br>{ <br>    CBaseDispatch m_basedisp; <br> <br> <br>public: <br> <br>    CMediaPosition(const TCHAR *, LPUNKNOWN); <br>    CMediaPosition(const TCHAR *, LPUNKNOWN, HRESULT *phr); <br> <br>    DECLARE_IUNKNOWN <br> <br>    // override this to publicise our interfaces <br>    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv); <br> <br>    /* IDispatch methods */ <br>    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo); <br> <br>    STDMETHODIMP GetTypeInfo( <br>      UINT itinfo, <br>      LCID lcid, <br>      ITypeInfo ** pptinfo); <br> <br>    STDMETHODIMP GetIDsOfNames( <br>      REFIID riid, <br>      OLECHAR  ** rgszNames, <br>      UINT cNames, <br>      LCID lcid, <br>      DISPID * rgdispid); <br> <br>    STDMETHODIMP Invoke( <br>      DISPID dispidMember, <br>      REFIID riid, <br>      LCID lcid, <br>      WORD wFlags, <br>      DISPPARAMS * pdispparams, <br>      VARIANT * pvarResult, <br>      EXCEPINFO * pexcepinfo, <br>      UINT * puArgErr); <br> <br>}; <br> <br> <br>// OA-compatibility means that we must use double as the RefTime value, <br>// and REFERENCE_TIME (essentially a LONGLONG) within filters. <br>// this class converts between the two <br> <br>class COARefTime : public CRefTime { <br>public: <br> <br>    COARefTime() { <br>    }; <br> <br>    COARefTime(CRefTime t) <br>        : CRefTime(t) <br>    { <br>    }; <br> <br>    COARefTime(REFERENCE_TIME t) <br>        : CRefTime(t) <br>    { <br>    }; <br> <br>    COARefTime(double d) { <br>        m_time = (LONGLONG) (d * 10000000); <br>    }; <br> <br>    operator double() { <br>        return double(m_time) / 10000000; <br>    }; <br> <br>    operator REFERENCE_TIME() { <br>        return m_time; <br>    }; <br> <br>    COARefTime&amp; operator=(const double&amp; rd)  { <br>        m_time = (LONGLONG) (rd * 10000000); <br>        return *this; <br>    } <br> <br>    COARefTime&amp; operator=(const REFERENCE_TIME&amp; rt)  { <br>        m_time = rt; <br>        return *this; <br>    } <br> <br>    inline BOOL operator==(const COARefTime&amp; rt) <br>    { <br>        return m_time == rt.m_time; <br>    }; <br> <br>    inline BOOL operator!=(const COARefTime&amp; rt) <br>    { <br>        return m_time != rt.m_time; <br>    }; <br> <br>    inline BOOL operator &lt; (const COARefTime&amp; rt) <br>    { <br>        return m_time &lt; rt.m_time; <br>    }; <br> <br>    inline BOOL operator &gt; (const COARefTime&amp; rt) <br>    { <br>        return m_time &gt; rt.m_time; <br>    }; <br> <br>    inline BOOL operator &gt;= (const COARefTime&amp; rt) <br>    { <br>        return m_time &gt;= rt.m_time; <br>    }; <br> <br>    inline BOOL operator &lt;= (const COARefTime&amp; rt) <br>    { <br>        return m_time &lt;= rt.m_time; <br>    }; <br> <br>    inline COARefTime operator+(const COARefTime&amp; rt) <br>    { <br>        return COARefTime(m_time + rt.m_time); <br>    }; <br> <br>    inline COARefTime operator-(const COARefTime&amp; rt) <br>    { <br>        return COARefTime(m_time - rt.m_time); <br>    }; <br> <br>    inline COARefTime operator*(LONG l) <br>    { <br>        return COARefTime(m_time * l); <br>    }; <br> <br>    inline COARefTime operator/(LONG l) <br>    { <br>        return COARefTime(m_time / l); <br>    }; <br> <br>private: <br>    //  Prevent bugs from constructing from LONG (which gets <br>    //  converted to double and then multiplied by 10000000 <br>    COARefTime(LONG); <br>    operator=(LONG); <br>}; <br> <br> <br>// A utility class that handles IMediaPosition and IMediaSeeking on behalf <br>// of single-input pin renderers, or transform filters. <br>// <br>// Renderers will expose this from the filter; transform filters will <br>// expose it from the output pin and not the renderer. <br>// <br>// Create one of these, giving it your IPin* for your input pin, and delegate <br>// all IMediaPosition methods to it. It will query the input pin for <br>// IMediaPosition and respond appropriately. <br>// <br>// Call ForceRefresh if the pin connection changes. <br>// <br>// This class no longer caches the upstream IMediaPosition or IMediaSeeking <br>// it acquires it on each method call. This means ForceRefresh is not needed. <br>// The method is kept for source compatibility and to minimise the changes <br>// if we need to put it back later for performance reasons. <br> <br>class CPosPassThru : public IMediaSeeking, public CMediaPosition <br>{ <br>    IPin *m_pPin; <br> <br>    HRESULT GetPeer(IMediaPosition **ppMP); <br>    HRESULT GetPeerSeeking(IMediaSeeking **ppMS); <br> <br>public: <br> <br>    CPosPassThru(const TCHAR *, LPUNKNOWN, HRESULT*, IPin *); <br>    DECLARE_IUNKNOWN <br> <br>    HRESULT ForceRefresh() { <br>        return S_OK; <br>    }; <br> <br>    // override to return an accurate current position <br>    virtual HRESULT GetMediaTime(LONGLONG *pStartTime,LONGLONG *pEndTime) { <br>        return E_FAIL; <br>    } <br> <br>    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv); <br> <br>    // IMediaSeeking methods <br>    STDMETHODIMP GetCapabilities( DWORD * pCapabilities ); <br>    STDMETHODIMP CheckCapabilities( DWORD * pCapabilities ); <br>    STDMETHODIMP SetTimeFormat(const GUID * pFormat); <br>    STDMETHODIMP GetTimeFormat(GUID *pFormat); <br>    STDMETHODIMP IsUsingTimeFormat(const GUID * pFormat); <br>    STDMETHODIMP IsFormatSupported( const GUID * pFormat); <br>    STDMETHODIMP QueryPreferredFormat( GUID *pFormat); <br>    STDMETHODIMP ConvertTimeFormat(LONGLONG * pTarget, const GUID * pTargetFormat, <br>                                   LONGLONG    Source, const GUID * pSourceFormat ); <br>    STDMETHODIMP SetPositions( LONGLONG * pCurrent, DWORD CurrentFlags <br>                             , LONGLONG * pStop, DWORD StopFlags ); <br> <br>    STDMETHODIMP GetPositions( LONGLONG * pCurrent, LONGLONG * pStop ); <br>    STDMETHODIMP GetCurrentPosition( LONGLONG * pCurrent ); <br>    STDMETHODIMP GetStopPosition( LONGLONG * pStop ); <br>    STDMETHODIMP SetRate( double dRate); <br>    STDMETHODIMP GetRate( double * pdRate); <br>    STDMETHODIMP GetDuration( LONGLONG *pDuration); <br>    STDMETHODIMP GetAvailable( LONGLONG *pEarliest, LONGLONG *pLatest ); <br>    STDMETHODIMP GetPreroll( LONGLONG *pllPreroll ); <br> <br>    // IMediaPosition properties <br>    STDMETHODIMP get_Duration(REFTIME * plength); <br>    STDMETHODIMP put_CurrentPosition(REFTIME llTime); <br>    STDMETHODIMP get_StopTime(REFTIME * pllTime); <br>    STDMETHODIMP put_StopTime(REFTIME llTime); <br>    STDMETHODIMP get_PrerollTime(REFTIME * pllTime); <br>    STDMETHODIMP put_PrerollTime(REFTIME llTime); <br>    STDMETHODIMP get_Rate(double * pdRate); <br>    STDMETHODIMP put_Rate(double dRate); <br>    STDMETHODIMP get_CurrentPosition(REFTIME * pllTime); <br>    STDMETHODIMP CanSeekForward(LONG *pCanSeekForward); <br>    STDMETHODIMP CanSeekBackward(LONG *pCanSeekBackward); <br> <br>private: <br>    HRESULT GetSeekingLongLong( HRESULT (__stdcall IMediaSeeking::*pMethod)( LONGLONG * ), <br>                                LONGLONG * pll ); <br>}; <br> <br> <br>// Adds the ability to return a current position <br> <br>class CRendererPosPassThru : public CPosPassThru <br>{ <br>    CCritSec m_PositionLock;    // Locks access to our position <br>    LONGLONG m_StartMedia;      // Start media time last seen <br>    LONGLONG m_EndMedia;        // And likewise the end media <br>    BOOL m_bReset;              // Have media times been set <br> <br>public: <br> <br>    // Used to help with passing media times through graph <br> <br>    CRendererPosPassThru(const TCHAR *, LPUNKNOWN, HRESULT*, IPin *); <br>    HRESULT RegisterMediaTime(IMediaSample *pMediaSample); <br>    HRESULT RegisterMediaTime(LONGLONG StartTime,LONGLONG EndTime); <br>    HRESULT GetMediaTime(LONGLONG *pStartTime,LONGLONG *pEndTime); <br>    HRESULT ResetMediaTime(); <br>    HRESULT EOS(); <br>}; <br> <br>STDAPI CreatePosPassThru( <br>    LPUNKNOWN pAgg, <br>    BOOL bRenderer, <br>    IPin *pPin, <br>    IUnknown **ppPassThru <br>); <br> <br>// A class that handles the IDispatch part of IBasicAudio and leaves the <br>// properties and methods themselves pure virtual. <br> <br>class AM_NOVTABLE CBasicAudio : public IBasicAudio, public CUnknown <br>{ <br>    CBaseDispatch m_basedisp; <br> <br>public: <br> <br>    CBasicAudio(const TCHAR *, LPUNKNOWN); <br> <br>    DECLARE_IUNKNOWN <br> <br>    // override this to publicise our interfaces <br>    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv); <br> <br>    /* IDispatch methods */ <br>    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo); <br> <br>    STDMETHODIMP GetTypeInfo( <br>      UINT itinfo, <br>      LCID lcid, <br>      ITypeInfo ** pptinfo); <br> <br>    STDMETHODIMP GetIDsOfNames( <br>      REFIID riid, <br>      OLECHAR  ** rgszNames, <br>      UINT cNames, <br>      LCID lcid, <br>      DISPID * rgdispid); <br> <br>    STDMETHODIMP Invoke( <br>      DISPID dispidMember, <br>      REFIID riid, <br>      LCID lcid, <br>      WORD wFlags, <br>      DISPPARAMS * pdispparams, <br>      VARIANT * pvarResult, <br>      EXCEPINFO * pexcepinfo, <br>      UINT * puArgErr); <br>}; <br> <br> <br>// A class that handles the IDispatch part of IBasicVideo and leaves the <br>// properties and methods themselves pure virtual. <br> <br>class AM_NOVTABLE CBaseBasicVideo : public IBasicVideo, public CUnknown <br>{ <br>    CBaseDispatch m_basedisp; <br> <br>public: <br> <br>    CBaseBasicVideo(const TCHAR *, LPUNKNOWN); <br> <br>    DECLARE_IUNKNOWN <br> <br>    // override this to publicise our interfaces <br>    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv); <br> <br>    /* IDispatch methods */ <br>    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo); <br> <br>    STDMETHODIMP GetTypeInfo( <br>      UINT itinfo, <br>      LCID lcid, <br>      ITypeInfo ** pptinfo); <br> <br>    STDMETHODIMP GetIDsOfNames( <br>      REFIID riid, <br>      OLECHAR  ** rgszNames, <br>      UINT cNames, <br>      LCID lcid, <br>      DISPID * rgdispid); <br> <br>    STDMETHODIMP Invoke( <br>      DISPID dispidMember, <br>      REFIID riid, <br>      LCID lcid, <br>      WORD wFlags, <br>      DISPPARAMS * pdispparams, <br>      VARIANT * pvarResult, <br>      EXCEPINFO * pexcepinfo, <br>      UINT * puArgErr); <br>}; <br> <br> <br>// A class that handles the IDispatch part of IVideoWindow and leaves the <br>// properties and methods themselves pure virtual. <br> <br>class AM_NOVTABLE CBaseVideoWindow : public IVideoWindow, public CUnknown <br>{ <br>    CBaseDispatch m_basedisp; <br> <br>public: <br> <br>    CBaseVideoWindow(const TCHAR *, LPUNKNOWN); <br> <br>    DECLARE_IUNKNOWN <br> <br>    // override this to publicise our interfaces <br>    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv); <br> <br>    /* IDispatch methods */ <br>    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo); <br> <br>    STDMETHODIMP GetTypeInfo( <br>      UINT itinfo, <br>      LCID lcid, <br>      ITypeInfo ** pptinfo); <br> <br>    STDMETHODIMP GetIDsOfNames( <br>      REFIID riid, <br>      OLECHAR  ** rgszNames, <br>      UINT cNames, <br>      LCID lcid, <br>      DISPID * rgdispid); <br> <br>    STDMETHODIMP Invoke( <br>      DISPID dispidMember, <br>      REFIID riid, <br>      LCID lcid, <br>      WORD wFlags, <br>      DISPPARAMS * pdispparams, <br>      VARIANT * pvarResult, <br>      EXCEPINFO * pexcepinfo, <br>      UINT * puArgErr); <br>}; <br> <br> <br>// abstract class to help source filters with their implementation <br>// of IMediaPosition. Derive from this and set the duration (and stop <br>// position). Also override NotifyChange to do something when the properties <br>// change. <br> <br>class AM_NOVTABLE CSourcePosition : public CMediaPosition <br>{ <br> <br>public: <br>    CSourcePosition(const TCHAR *, LPUNKNOWN, HRESULT*, CCritSec *); <br> <br>    // IMediaPosition methods <br>    STDMETHODIMP get_Duration(REFTIME * plength); <br>    STDMETHODIMP put_CurrentPosition(REFTIME llTime); <br>    STDMETHODIMP get_StopTime(REFTIME * pllTime); <br>    STDMETHODIMP put_StopTime(REFTIME llTime); <br>    STDMETHODIMP get_PrerollTime(REFTIME * pllTime); <br>    STDMETHODIMP put_PrerollTime(REFTIME llTime); <br>    STDMETHODIMP get_Rate(double * pdRate); <br>    STDMETHODIMP put_Rate(double dRate); <br>    STDMETHODIMP CanSeekForward(LONG *pCanSeekForward); <br>    STDMETHODIMP CanSeekBackward(LONG *pCanSeekBackward); <br> <br>    // override if you can return the data you are actually working on <br>    STDMETHODIMP get_CurrentPosition(REFTIME * pllTime) { <br>        return E_NOTIMPL; <br>    }; <br> <br>protected: <br> <br>    // we call this to notify changes. Override to handle them <br>    virtual HRESULT ChangeStart() PURE; <br>    virtual HRESULT ChangeStop() PURE; <br>    virtual HRESULT ChangeRate() PURE; <br> <br>    COARefTime m_Duration; <br>    COARefTime m_Start; <br>    COARefTime m_Stop; <br>    double m_Rate; <br> <br>    CCritSec * m_pLock; <br>}; <br> <br>class AM_NOVTABLE CSourceSeeking : <br>    public IMediaSeeking, <br>    public CUnknown <br>{ <br> <br>public: <br> <br>    DECLARE_IUNKNOWN; <br>    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv); <br>     <br>    // IMediaSeeking methods <br> <br>    STDMETHODIMP IsFormatSupported(const GUID * pFormat); <br>    STDMETHODIMP QueryPreferredFormat(GUID *pFormat); <br>    STDMETHODIMP SetTimeFormat(const GUID * pFormat); <br>    STDMETHODIMP IsUsingTimeFormat(const GUID * pFormat); <br>    STDMETHODIMP GetTimeFormat(GUID *pFormat); <br>    STDMETHODIMP GetDuration(LONGLONG *pDuration); <br>    STDMETHODIMP GetStopPosition(LONGLONG *pStop); <br>    STDMETHODIMP GetCurrentPosition(LONGLONG *pCurrent); <br>    STDMETHODIMP GetCapabilities( DWORD * pCapabilities ); <br>    STDMETHODIMP CheckCapabilities( DWORD * pCapabilities ); <br>    STDMETHODIMP ConvertTimeFormat( LONGLONG * pTarget, const GUID * pTargetFormat, <br>                                    LONGLONG    Source, const GUID * pSourceFormat ); <br> <br>    STDMETHODIMP SetPositions( LONGLONG * pCurrent,  DWORD CurrentFlags <br>     , LONGLONG * pStop,  DWORD StopFlags ); <br> <br>    STDMETHODIMP GetPositions( LONGLONG * pCurrent, LONGLONG * pStop ); <br> <br>    STDMETHODIMP GetAvailable( LONGLONG * pEarliest, LONGLONG * pLatest ); <br>    STDMETHODIMP SetRate( double dRate); <br>    STDMETHODIMP GetRate( double * pdRate); <br>    STDMETHODIMP GetPreroll(LONGLONG *pPreroll); <br> <br>     <br>protected: <br> <br>    // ctor <br>    CSourceSeeking(const TCHAR *, LPUNKNOWN, HRESULT*, CCritSec *); <br>     <br>    // we call this to notify changes. Override to handle them <br>    virtual HRESULT ChangeStart() PURE; <br>    virtual HRESULT ChangeStop() PURE; <br>    virtual HRESULT ChangeRate() PURE; <br> <br>    CRefTime m_rtDuration;      // length of stream <br>    CRefTime m_rtStart;         // source will start here <br>    CRefTime m_rtStop;          // source will stop here <br>    double m_dRateSeeking; <br> <br>    // seeking capabilities  <br>    DWORD m_dwSeekingCaps; <br> <br>    CCritSec * m_pLock; <br>}; <br> <br> <br>// Base classes supporting Deferred commands. <br> <br>// Deferred commands are queued by calls to methods on the IQueueCommand <br>// interface, exposed by the filtergraph and by some filters. A successful <br>// call to one of these methods will return an IDeferredCommand interface <br>// representing the queued command. <br>// <br>// A CDeferredCommand object represents a single deferred command, and exposes <br>// the IDeferredCommand interface as well as other methods permitting time <br>// checks and actual execution. It contains a reference to the CCommandQueue <br>// object on which it is queued. <br>// <br>// CCommandQueue is a base class providing a queue of CDeferredCommand <br>// objects, and methods to add, remove, check status and invoke the queued <br>// commands. A CCommandQueue object would be part of an object that <br>// implemented IQueueCommand. <br> <br>class CCmdQueue; <br> <br>// take a copy of the params and store them. Release any allocated <br>// memory in destructor <br> <br>class CDispParams : public DISPPARAMS <br>{ <br>public: <br>    CDispParams(UINT nArgs, VARIANT* pArgs); <br>    ~CDispParams(); <br>}; <br> <br> <br>// CDeferredCommand lifetime is controlled by refcounts. Caller of <br>// InvokeAt.. gets a refcounted interface pointer, and the CCmdQueue <br>// object also holds a refcount on us. Calling Cancel or Invoke takes <br>// us off the CCmdQueue and thus reduces the refcount by 1. Once taken <br>// off the queue we cannot be put back on the queue. <br> <br>class CDeferredCommand <br>    : public CUnknown, <br>      public IDeferredCommand <br>{ <br>public: <br> <br>    CDeferredCommand( <br>        CCmdQueue * pQ, <br>        LPUNKNOWN   pUnk,               // aggregation outer unk <br>        HRESULT *   phr, <br>        LPUNKNOWN   pUnkExecutor,       // object that will execute this cmd <br>        REFTIME     time, <br>        GUID*       iid, <br>        long        dispidMethod, <br>        short       wFlags, <br>        long        cArgs, <br>        VARIANT*    pDispParams, <br>        VARIANT*    pvarResult, <br>        short*      puArgErr, <br>        BOOL        bStream <br>        ); <br> <br>    DECLARE_IUNKNOWN <br> <br>    // override this to publicise our interfaces <br>    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv); <br> <br>    // IDeferredCommand methods <br>    STDMETHODIMP Cancel(); <br>    STDMETHODIMP Confidence( <br>                    LONG* pConfidence); <br>    STDMETHODIMP Postpone( <br>                    REFTIME newtime); <br>    STDMETHODIMP GetHResult( <br>                    HRESULT* phrResult); <br> <br>    // other public methods <br> <br>    HRESULT Invoke(); <br> <br>    // access methods <br> <br>    // returns TRUE if streamtime, FALSE if presentation time <br>    BOOL IsStreamTime() { <br>       return m_bStream; <br>    }; <br> <br>    CRefTime GetTime() { <br>        return m_time; <br>    }; <br> <br>    REFIID GetIID() { <br>        return *m_iid; <br>    }; <br> <br>    long GetMethod() { <br>        return m_dispidMethod; <br>    }; <br> <br>    short GetFlags() { <br>        return m_wFlags; <br>    }; <br> <br>    DISPPARAMS* GetParams() { <br>        return &amp;m_DispParams; <br>    }; <br> <br>    VARIANT* GetResult() { <br>        return m_pvarResult; <br>    }; <br> <br>protected: <br> <br>    CCmdQueue* m_pQueue; <br> <br>    // pUnk for the interface that we will execute the command on <br>    LPUNKNOWN   m_pUnk; <br> <br>    // stored command data <br>    REFERENCE_TIME     m_time; <br>    GUID*       m_iid; <br>    long        m_dispidMethod; <br>    short       m_wFlags; <br>    VARIANT*    m_pvarResult; <br>    BOOL        m_bStream; <br>    CDispParams m_DispParams; <br>    DISPID      m_DispId;         //  For get and put <br> <br>    // we use this for ITypeInfo access <br>    CBaseDispatch   m_Dispatch; <br> <br>    // save retval here <br>    HRESULT     m_hrResult; <br>}; <br> <br> <br>// a list of CDeferredCommand objects. this is a base class providing <br>// the basics of access to the list. If you want to use CDeferredCommand <br>// objects then your queue needs to be derived from this class. <br> <br>class AM_NOVTABLE CCmdQueue <br>{ <br>public: <br>    CCmdQueue(); <br>    virtual ~CCmdQueue(); <br> <br>    // returns a new CDeferredCommand object that will be initialised with <br>    // the parameters and will be added to the queue during construction. <br>    // returns S_OK if successfully created otherwise an error and <br>    // no object has been queued. <br>    virtual HRESULT  New( <br>        CDeferredCommand **ppCmd, <br>        LPUNKNOWN   pUnk, <br>        REFTIME     time, <br>        GUID*       iid, <br>        long        dispidMethod, <br>        short       wFlags, <br>        long        cArgs, <br>        VARIANT*    pDispParams, <br>        VARIANT*    pvarResult, <br>        short*      puArgErr, <br>        BOOL        bStream <br>    ); <br> <br>    // called by the CDeferredCommand object to add and remove itself <br>    // from the queue <br>    virtual HRESULT Insert(CDeferredCommand* pCmd); <br>    virtual HRESULT Remove(CDeferredCommand* pCmd); <br> <br>    // Command-Due Checking <br>    // <br>    // There are two schemes of synchronisation: coarse and accurate. In <br>    // coarse mode, you wait till the time arrives and then execute the cmd. <br>    // In accurate mode, you wait until you are processing the sample that <br>    // will appear at the time, and then execute the command. It's up to the <br>    // filter which one it will implement. The filtergraph will always <br>    // implement coarse mode for commands queued at the filtergraph. <br>    // <br>    // If you want coarse sync, you probably want to wait until there is a <br>    // command due, and then execute it. You can do this by calling <br>    // GetDueCommand. If you have several things to wait for, get the <br>    // event handle from GetDueHandle() and when this is signalled then call <br>    // GetDueCommand. Stream time will only advance between calls to Run and <br>    // EndRun. Note that to avoid an extra thread there is no guarantee that <br>    // if the handle is set there will be a command ready. Each time the <br>    // event is signalled, call GetDueCommand (probably with a 0 timeout); <br>    // This may return E_ABORT. <br>    // <br>    // If you want accurate sync, you must call GetCommandDueFor, passing <br>    // as a parameter the stream time of the samples you are about to process. <br>    // This will return: <br>    //   -- a stream-time command due at or before that stream time <br>    //   -- a presentation-time command due at or before the <br>    //      time that stream time will be presented (only between Run <br>    //      and EndRun calls, since outside of this, the mapping from <br>    //      stream time to presentation time is not known. <br>    //   -- any presentation-time command due now. <br>    // This means that if you want accurate synchronisation on samples that <br>    // might be processed during Paused mode, you need to use <br>    // stream-time commands. <br>    // <br>    // In all cases, commands remain queued until Invoked or Cancelled. The <br>    // setting and resetting of the event handle is managed entirely by this <br>    // queue object. <br> <br>    // set the clock used for timing <br>    virtual HRESULT SetSyncSource(IReferenceClock*); <br> <br>    // switch to run mode. Streamtime to Presentation time mapping known. <br>    virtual HRESULT Run(REFERENCE_TIME tStreamTimeOffset); <br> <br>    // switch to Stopped or Paused mode. Time mapping not known. <br>    virtual HRESULT EndRun(); <br> <br>    // return a pointer to the next due command. Blocks for msTimeout <br>    // milliseconds until there is a due command. <br>    // Stream-time commands will only become due between Run and Endrun calls. <br>    // The command remains queued until invoked or cancelled. <br>    // Returns E_ABORT if timeout occurs, otherwise S_OK (or other error). <br>    // Returns an AddRef-ed object <br>    virtual HRESULT GetDueCommand(CDeferredCommand ** ppCmd, long msTimeout); <br> <br>    // return the event handle that will be signalled whenever <br>    // there are deferred commands due for execution (when GetDueCommand <br>    // will not block). <br>    HANDLE GetDueHandle() { <br>        return HANDLE(m_evDue); <br>    }; <br> <br>    // return a pointer to a command that will be due for a given time. <br>    // Pass in a stream time here. The stream time offset will be passed <br>    // in via the Run method. <br>    // Commands remain queued until invoked or cancelled. <br>    // This method will not block. It will report VFW_E_NOT_FOUND if there <br>    // are no commands due yet. <br>    // Returns an AddRef-ed object <br>    virtual HRESULT GetCommandDueFor(REFERENCE_TIME tStream, CDeferredCommand**ppCmd); <br> <br>    // check if a given time is due (TRUE if it is due yet) <br>    BOOL CheckTime(CRefTime time, BOOL bStream) { <br> <br>        // if no clock, nothing is due! <br>        if (!m_pClock) { <br>            return FALSE; <br>        } <br> <br>        // stream time <br>        if (bStream) { <br> <br>            // not valid if not running <br>            if (!m_bRunning) { <br>                return FALSE; <br>            } <br>            // add on known stream time offset to get presentation time <br>            time += m_StreamTimeOffset; <br>        } <br> <br>        CRefTime Now; <br>        m_pClock-&gt;GetTime((REFERENCE_TIME*)&amp;Now); <br>        return (time &lt;= Now); <br>    }; <br> <br>protected: <br> <br>    // protect access to lists etc <br>    CCritSec m_Lock; <br> <br>    // commands queued in presentation time are stored here <br>    CGenericList&lt;CDeferredCommand&gt; m_listPresentation; <br> <br>    // commands queued in stream time are stored here <br>    CGenericList&lt;CDeferredCommand&gt; m_listStream; <br> <br>    // set when any commands are due <br>    CAMEvent m_evDue; <br> <br>    // creates an advise for the earliest time required, if any <br>    void SetTimeAdvise(void); <br> <br>    // advise id from reference clock (0 if no outstanding advise) <br>    DWORD m_dwAdvise; <br> <br>    // advise time is for this presentation time <br>    CRefTime m_tCurrentAdvise; <br> <br>    // the reference clock we are using (addrefed) <br>    IReferenceClock* m_pClock; <br> <br>    // true when running <br>    BOOL m_bRunning; <br> <br>    // contains stream time offset when m_bRunning is true <br>    CRefTime m_StreamTimeOffset; <br>}; <br> <br>#endif // __CTLUTIL__ </code></pre>
<p>&nbsp;</p></body>
</HTML>
