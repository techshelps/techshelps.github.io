<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SOURCE.H</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2771"></a>SOURCE.H</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>// Classes to simplify creation of ActiveX source filters that support <br>// continuous generation of data. It provides no support for IMediaControl <br>// or IMediaPosition <br>// <br>// Derive your source filter from CSource. <br>// During construction either: <br>//    Create some CSourceStream objects to manage your pins <br>//    Provide the user with a means of doing so eg, an IPersistFile interface. <br>// <br>// CSource provides: <br>//    IBaseFilter interface management <br>//    IMediaFilter interface management, via CBaseFilter <br>//    Pin counting for CBaseFilter <br>// <br>// Derive a class from CSourceStream to manage your output pin types <br>//  Implement GetMediaType/1 to return the type you support. If you support multiple <br>//   types then overide GetMediaType/3, CheckMediaType and GetMediaTypeCount. <br>//  Implement Fillbuffer() to put data into one buffer. <br>// <br>// CSourceStream provides: <br>//    IPin management via CBaseOutputPin <br>//    Worker thread management <br> <br>#ifndef __CSOURCE__ <br>#define __CSOURCE__ <br> <br>class CSourceStream;  // The class that will handle each pin <br> <br> <br>// <br>// CSource <br>// <br>// Override construction to provide a means of creating <br>// CSourceStream derived objects - ie a way of creating pins. <br>class CSource : public CBaseFilter { <br>public: <br> <br>    CSource(TCHAR *pName, LPUNKNOWN lpunk, CLSID clsid, HRESULT *phr); <br>    CSource(TCHAR *pName, LPUNKNOWN lpunk, CLSID clsid); <br>    ~CSource(); <br> <br>    int       GetPinCount(void); <br>    CBasePin *GetPin(int n); <br> <br>    // -- Utilities -- <br> <br>    CCritSec*pStateLock(void) { return &amp;m_cStateLock; }// provide our critical section <br> <br>    HRESULT     AddPin(CSourceStream *); <br>    HRESULT     RemovePin(CSourceStream *); <br> <br>    STDMETHODIMP FindPin( <br>        LPCWSTR Id, <br>        IPin ** ppPin <br>    ); <br> <br>    int FindPinNumber(IPin *iPin); <br>     <br>protected: <br> <br>    int             m_iPins;       // The number of pins on this filter. Updated by CSourceStream <br>          // constructors &amp; destructors. <br>    CSourceStream **m_paStreams;   // the pins on this filter. <br> <br>    CCritSec m_cStateLock;// Lock this to serialize function accesses to the filter state <br> <br>}; <br> <br> <br>// <br>// CSourceStream <br>// <br>// Use this class to manage a stream of data that comes from a <br>// pin. <br>// Uses a worker thread to put data on the pin. <br>class CSourceStream : public CAMThread, public CBaseOutputPin { <br>public: <br> <br>    CSourceStream(TCHAR *pObjectName, <br>                  HRESULT *phr, <br>                  CSource *pms, <br>                  LPCWSTR pName); <br> <br>    virtual ~CSourceStream(void);  // virtual destructor ensures derived class destructors are called too. <br> <br>protected: <br> <br>    CSource *m_pFilter;// The parent of this stream <br> <br>    // * <br>    // * Data Source <br>    // * <br>    // * The following three functions: FillBuffer, OnThreadCreate/Destroy, are <br>    // * called from within the ThreadProc. They are used in the creation of <br>    // * the media samples this pin will provide <br>    // * <br> <br>    // Override this to provide the worker thread a means <br>    // of processing a buffer <br>    virtual HRESULT FillBuffer(IMediaSample *pSamp) PURE; <br> <br>    // Called as the thread is created/destroyed - use to perform <br>    // jobs such as start/stop streaming mode <br>    // If OnThreadCreate returns an error the thread will exit. <br>    virtual HRESULT OnThreadCreate(void) {return NOERROR;}; <br>    virtual HRESULT OnThreadDestroy(void) {return NOERROR;}; <br>    virtual HRESULT OnThreadStartPlay(void) {return NOERROR;}; <br> <br>    // * <br>    // * Worker Thread <br>    // * <br> <br>    HRESULT Active(void);    // Starts up the worker thread <br>    HRESULT Inactive(void);  // Exits the worker thread. <br> <br>public: <br>    // thread commands <br>    enum Command {CMD_INIT, CMD_PAUSE, CMD_RUN, CMD_STOP, CMD_EXIT}; <br>    HRESULT Init(void) { return CallWorker(CMD_INIT); } <br>    HRESULT Exit(void) { return CallWorker(CMD_EXIT); } <br>    HRESULT Run(void) { return CallWorker(CMD_RUN); } <br>    HRESULT Pause(void) { return CallWorker(CMD_PAUSE); } <br>    HRESULT Stop(void) { return CallWorker(CMD_STOP); } <br> <br>protected: <br>    Command GetRequest(void) { return (Command) CAMThread::GetRequest(); } <br>    BOOL    CheckRequest(Command *pCom) { return CAMThread::CheckRequest( (DWORD *) pCom); } <br> <br>    // override these if you want to add thread commands <br>    virtual DWORD ThreadProc(void);  // the thread function <br> <br>    virtual HRESULT DoBufferProcessingLoop(void);    // the loop executed whilst running <br> <br> <br>    // * <br>    // * AM_MEDIA_TYPE support <br>    // * <br> <br>    // If you support more than one media type then override these 2 functions <br>    virtual HRESULT CheckMediaType(const CMediaType *pMediaType); <br>    virtual HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);  // List pos. 0-n <br> <br>    // If you support only one type then override this fn. <br>    // This will only be called by the default implementations <br>    // of CheckMediaType and GetMediaType(int, CMediaType*) <br>    // You must override this fn. or the above 2! <br>    virtual HRESULT GetMediaType(CMediaType *pMediaType) {return E_UNEXPECTED;} <br> <br>    STDMETHODIMP QueryId( <br>        LPWSTR * Id <br>    ); <br>}; <br> <br>#endif // __CSOURCE__ <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
