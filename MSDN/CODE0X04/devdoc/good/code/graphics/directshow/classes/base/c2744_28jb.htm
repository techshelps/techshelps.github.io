<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DLLENTRY.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2747"></a>DLLENTRY.CPP</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>// <br>// classes used to support dll entrypoints for COM objects. <br>// <br>#include &lt;streams.h&gt; <br> <br>#ifdef DEBUG <br>#ifdef UNICODE <br>#ifndef _UNICODE <br>#define _UNICODE <br>#endif // _UNICODE <br>#endif // UNICODE <br> <br>#include &lt;tchar.h&gt; <br>#endif // DEBUG <br> <br>extern CFactoryTemplate g_Templates[]; <br>extern int g_cTemplates; <br> <br>HINSTANCE g_hInst; <br>DWORD  g_amPlatform;// VER_PLATFORM_WIN32_WINDOWS etc... (from GetVersionEx) <br>OSVERSIONINFO g_osInfo; <br> <br>// <br>// an instance of this is created by the DLLGetClassObject entrypoint <br>// it uses the CFactoryTemplate object it is given to support the <br>// IClassFactory interface <br> <br>class CClassFactory : public IClassFactory, public CBaseObject <br>{ <br> <br>private: <br>    const CFactoryTemplate *const m_pTemplate; <br> <br>    ULONG m_cRef; <br> <br>    static int m_cLocked; <br>public: <br>    CClassFactory(const CFactoryTemplate *); <br> <br>    // IUnknown <br>    STDMETHODIMP QueryInterface(REFIID riid, void ** ppv); <br>    STDMETHODIMP_(ULONG)AddRef(); <br>    STDMETHODIMP_(ULONG)Release(); <br> <br>    // IClassFactory <br>    STDMETHODIMP CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, void **pv); <br>    STDMETHODIMP LockServer(BOOL fLock); <br> <br>    // allow DLLGetClassObject to know about global server lock status <br>    static BOOL IsLocked() { <br>        return (m_cLocked &gt; 0); <br>    }; <br>}; <br> <br>// process-wide dll locked state <br>int CClassFactory::m_cLocked = 0; <br> <br>CClassFactory::CClassFactory(const CFactoryTemplate *pTemplate) <br>: CBaseObject(NAME("Class Factory")) <br>, m_cRef(0) <br>, m_pTemplate(pTemplate) <br>{ <br>} <br> <br> <br>STDMETHODIMP <br>CClassFactory::QueryInterface(REFIID riid,void **ppv) <br>{ <br>    CheckPointer(ppv,E_POINTER) <br>    ValidateReadWritePtr(ppv,sizeof(PVOID)); <br>    *ppv = NULL; <br> <br>    // any interface on this object is the object pointer. <br>    if ((riid == IID_IUnknown) || (riid == IID_IClassFactory)) { <br>        *ppv = (LPVOID) this; <br>// AddRef returned interface pointer <br>        ((LPUNKNOWN) *ppv)-&gt;AddRef(); <br>        return NOERROR; <br>    } <br> <br>    return ResultFromScode(E_NOINTERFACE); <br>} <br> <br> <br>STDMETHODIMP_(ULONG) <br>CClassFactory::AddRef() <br>{ <br>    return ++m_cRef; <br>} <br> <br>STDMETHODIMP_(ULONG) <br>CClassFactory::Release() <br>{ <br>    if (--m_cRef == 0) { <br>        delete this; <br>        return 0; <br>    } else { <br>        return m_cRef; <br>    } <br>} <br> <br>STDMETHODIMP <br>CClassFactory::CreateInstance( <br>    LPUNKNOWN pUnkOuter, <br>    REFIID riid, <br>    void **pv) <br>{ <br>    CheckPointer(pv,E_POINTER) <br>    ValidateReadWritePtr(pv,sizeof(void *)); <br> <br>    /* Enforce the normal OLE rules regarding interfaces and delegation */ <br> <br>    if (pUnkOuter != NULL) { <br>        if (IsEqualIID(riid,IID_IUnknown) == FALSE) { <br>            return ResultFromScode(E_NOINTERFACE); <br>        } <br>    } <br> <br>    /* Create the new object through the derived class's create function */ <br> <br>    HRESULT hr = NOERROR; <br>    CUnknown *pObj = m_pTemplate-&gt;CreateInstance(pUnkOuter, &amp;hr); <br> <br>    if (pObj == NULL) { <br>if (SUCCEEDED(hr)) { <br>    hr = E_OUTOFMEMORY; <br>} <br>return hr; <br>    } <br> <br>    /* Delete the object if we got a construction error */ <br> <br>    if (FAILED(hr)) { <br>        delete pObj; <br>        return hr; <br>    } <br> <br>    /* Get a reference counted interface on the object */ <br> <br>    /* We wrap the non-delegating QI with NDAddRef &amp; NDRelease. */ <br>    /* This protects any outer object from being prematurely    */ <br>    /* released by an inner object that may have to be created  */ <br>    /* in order to supply the requested interface.              */ <br>    pObj-&gt;NonDelegatingAddRef(); <br>    hr = pObj-&gt;NonDelegatingQueryInterface(riid, pv); <br>    pObj-&gt;NonDelegatingRelease(); <br>    /* Note that if NonDelegatingQueryInterface fails, it will  */ <br>    /* not increment the ref count, so the NonDelegatingRelease */ <br>    /* will drop the ref back to zero and the object will "self-*/ <br>    /* destruct".  Hence we don't need additional tidy-up code  */ <br>    /* to cope with NonDelegatingQueryInterface failing.        */ <br> <br>    if (SUCCEEDED(hr)) { <br>        ASSERT(*pv); <br>    } <br> <br>    return hr; <br>} <br> <br>STDMETHODIMP <br>CClassFactory::LockServer(BOOL fLock) <br>{ <br>    if (fLock) { <br>        m_cLocked++; <br>    } else { <br>        m_cLocked--; <br>    } <br>    return NOERROR; <br>} <br> <br> <br>// --- COM entrypoints ----------------------------------------- <br> <br>//called by COM to get the class factory object for a given class <br>STDAPI <br>DllGetClassObject( <br>    REFCLSID rClsID, <br>    REFIID riid, <br>    void **pv) <br>{ <br>    if (!(riid == IID_IUnknown) &amp;&amp; !(riid == IID_IClassFactory)) { <br>            return E_NOINTERFACE; <br>    } <br> <br>    // traverse the array of templates looking for one with this <br>    // class id <br>    for (int i = 0; i &lt; g_cTemplates; i++) { <br>        const CFactoryTemplate * pT = &amp;g_Templates[i]; <br>        if (pT-&gt;IsClassID(rClsID)) { <br> <br>            // found a template - make a class factory based on this <br>            // template <br> <br>            *pv = (LPVOID) (LPUNKNOWN) new CClassFactory(pT); <br>            if (*pv == NULL) { <br>                return E_OUTOFMEMORY; <br>            } <br>            ((LPUNKNOWN)*pv)-&gt;AddRef(); <br>            return NOERROR; <br>        } <br>    } <br>    return CLASS_E_CLASSNOTAVAILABLE; <br>} <br> <br>// <br>//  Call any initialization routines <br>// <br>void <br>DllInitClasses(BOOL bLoading) <br>{ <br>    int i; <br> <br>    // traverse the array of templates calling the init routine <br>    // if they have one <br>    for (i = 0; i &lt; g_cTemplates; i++) { <br>        const CFactoryTemplate * pT = &amp;g_Templates[i]; <br>        if (pT-&gt;m_lpfnInit != NULL) { <br>            (*pT-&gt;m_lpfnInit)(bLoading, pT-&gt;m_ClsID); <br>        } <br>    } <br> <br>} <br> <br>// called by COM to determine if this dll can be unloaded <br>// return ok unless there are outstanding objects or a lock requested <br>// by IClassFactory::LockServer <br>// <br>// CClassFactory has a static function that can tell us about the locks, <br>// and CCOMObject has a static function that can tell us about the active <br>// object count <br>STDAPI <br>DllCanUnloadNow() <br>{ <br>    DbgLog((LOG_MEMORY,2,TEXT("DLLCanUnloadNow called - IsLocked = %d, Active objects = %d"), <br>        CClassFactory::IsLocked(), <br>        CBaseObject::ObjectsActive())); <br> <br>    if (CClassFactory::IsLocked() || CBaseObject::ObjectsActive()) { <br>return S_FALSE; <br>    } else { <br>        return S_OK; <br>    } <br>} <br> <br> <br>// --- standard WIN32 entrypoints -------------------------------------- <br> <br> <br>extern "C" BOOL WINAPI DllEntryPoint(HINSTANCE, ULONG, LPVOID); <br> <br>BOOL WINAPI <br>DllEntryPoint(HINSTANCE hInstance, ULONG ulReason, LPVOID pv) <br>{ <br> <br>    switch (ulReason) <br>    { <br> <br>    case DLL_PROCESS_ATTACH: <br>        DisableThreadLibraryCalls(hInstance); <br>        DbgInitialise(hInstance); <br>{ <br>    // The platform identifier is used to work out whether <br>    // full unicode support is available or not.  Hence the <br>    // default will be the lowest common denominator - i.e. N/A <br>            g_amPlatform = VER_PLATFORM_WIN32_WINDOWS; // win95 assumed in case GetVersionEx fails <br> <br>            g_osInfo.dwOSVersionInfoSize = sizeof(g_osInfo); <br>            if (GetVersionEx(&amp;g_osInfo)) { <br>        g_amPlatform = g_osInfo.dwPlatformId; <br>    } else { <br>DbgLog((LOG_ERROR, 1, TEXT("Failed to get the OS platform, assuming Win95"))); <br>    } <br>} <br>        g_hInst = hInstance; <br>        DllInitClasses(TRUE); <br>        break; <br> <br>    case DLL_PROCESS_DETACH: <br>        DllInitClasses(FALSE); <br> <br>#ifdef DEBUG <br>        if (CBaseObject::ObjectsActive()) { <br>            DbgSetModuleLevel(LOG_MEMORY, 2); <br>            TCHAR szInfo[512]; <br>            extern TCHAR m_ModuleName[];     // Cut down module name <br> <br>            TCHAR FullName[_MAX_PATH];      // Load the full path and module name <br>            TCHAR *pName;                   // Searches from the end for a backslash <br> <br>            GetModuleFileName(NULL,FullName,_MAX_PATH); <br>            pName = _tcsrchr(FullName,'\\'); <br>            if (pName == NULL) { <br>                pName = FullName; <br>            } else { <br>                pName++; <br>            } <br> <br>    DWORD cch = wsprintf(szInfo, TEXT("Executable: %s  Pid %x  Tid %x. "), <br>    pName, GetCurrentProcessId(), GetCurrentThreadId()); <br> <br>            wsprintf(szInfo+cch, TEXT("Module %s, %d objects left active!"), <br>                     m_ModuleName, CBaseObject::ObjectsActive()); <br>            DbgAssert(szInfo, TEXT(__FILE__),__LINE__); <br> <br>    // If running remotely wait for the Assert to be acknowledged <br>    // before dumping out the object register <br>            DbgDumpObjectRegister(); <br>        } <br>        DbgTerminate(); <br>#endif <br>        break; <br>    } <br>    return TRUE; <br>} <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
