<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TRANSIP.H</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2780"></a>TRANSIP.H</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>// <br>// base class from which you can derive a simple Transform-In-Place filter. <br>// The difference between this and Transfrm.h is that Transfrm copies the data. <br>// <br>// It assumes the filter has one input and one output stream, and has no <br>// interest in memory management, interface negotiation or anything else. <br>// <br>// Derive your class from this, and supply Transform and the media type/format <br>// negotiation functions. Implement that class, compile and link and <br>// you're done. <br> <br> <br>#ifndef __TRANSIP__ <br>#define __TRANSIP__ <br> <br>// ====================================================================== <br>// This is the com object that represents a simple transform filter. It <br>// supports IBaseFilter, IMediaFilter and two pins through nested interfaces <br>// ====================================================================== <br> <br>class CTransInPlaceFilter; <br> <br>// Several of the pin functions call filter functions to do the work, <br>// so you can often use the pin classes unaltered, just overriding the <br>// functions in CTransInPlaceFilter.  If that's not enough and you want <br>// to derive your own pin class, override GetPin in the filter to supply <br>// your own pin classes to the filter. <br> <br>// ================================================== <br>// Implements the input pin <br>// ================================================== <br> <br>class CTransInPlaceInputPin : public CTransformInputPin <br>{ <br> <br>protected: <br>    CTransInPlaceFilter *m_pTIPFilter;    // our filter <br>    BOOL                 m_bReadOnly;     // incoming stream is read only <br> <br>public: <br> <br>    CTransInPlaceInputPin( <br>        TCHAR               *pObjectName, <br>        CTransInPlaceFilter *pFilter, <br>        HRESULT             *phr, <br>        LPCWSTR              pName); <br> <br>    // --- IMemInputPin ----- <br> <br>    // Provide an enumerator for media types by getting one from downstream <br>    STDMETHODIMP EnumMediaTypes( IEnumMediaTypes **ppEnum ); <br> <br>    // Say whether media type is acceptable. <br>    HRESULT CheckMediaType(const CMediaType* pmt); <br> <br>    // Return our upstream allocator <br>    STDMETHODIMP GetAllocator(IMemAllocator ** ppAllocator); <br> <br>    // get told which allocator the upstream output pin is actually <br>    // going to use. <br>    STDMETHODIMP NotifyAllocator(IMemAllocator * pAllocator, <br>                                 BOOL bReadOnly); <br> <br>    // Allow the filter to see what allocator we have <br>    // N.B. This does NOT AddRef <br>    IMemAllocator * PeekAllocator() <br>        {  return m_pAllocator; } <br> <br>    // Pass this on downstream if it ever gets called. <br>    STDMETHODIMP <br>    CTransInPlaceInputPin::GetAllocatorRequirements(ALLOCATOR_PROPERTIES *pProps); <br> <br>    inline const BOOL ReadOnly() { return m_bReadOnly; } <br> <br> <br>};  // CTransInPlaceInputPin <br> <br>// ================================================== <br>// Implements the output pin <br>// ================================================== <br> <br>class CTransInPlaceOutputPin : public CTransformOutputPin <br>{ <br> <br>protected: <br>    // m_pFilter points to our CBaseFilter <br>    CTransInPlaceFilter *m_pTIPFilter; <br> <br>public: <br> <br>    CTransInPlaceOutputPin( <br>        TCHAR               *pObjectName, <br>        CTransInPlaceFilter *pFilter, <br>        HRESULT             *phr, <br>        LPCWSTR              pName); <br> <br> <br>    // --- CBaseOutputPin ------------ <br> <br>    // negotiate the allocator and its buffer size/count <br>    // Insists on using our own allocator.  (Actually the one upstream of us). <br>    virtual HRESULT DecideAllocator(IMemInputPin * pPin, IMemAllocator ** pAlloc); <br> <br>    // Provide a media type enumerator.  Get it from upstream. <br>    STDMETHODIMP EnumMediaTypes( IEnumMediaTypes **ppEnum ); <br> <br>    // Say whether media type is acceptable. <br>    HRESULT CheckMediaType(const CMediaType* pmt); <br> <br>    // This is like NotifyAllocator - only output pins do not normally have those <br>    // This is only called internally by our own input pin to propagate <br>    // allocator decisions downstream.  ReadOnly allocators are not propagated <br>    // but we check the properties and propagate those. <br>    HRESULT ReceiveAllocator(IMemAllocator * pAllocator, BOOL bReadONly); <br> <br>    IMemInputPin * ConnectedIMemInputPin() <br>        { return m_pInputPin; } <br> <br>    // Allow the filter to see what allocator we have <br>    // N.B. This does NOT AddRef <br>    IMemAllocator * PeekAllocator() <br>        {  return m_pAllocator; } <br>};  // CTransInPlaceOutputPin <br> <br> <br>class AM_NOVTABLE CTransInPlaceFilter : public CTransformFilter <br>{ <br> <br>public: <br> <br>    // map getpin/getpincount for base enum of pins to owner <br>    // override this to return more specialised pin objects <br> <br>    virtual CBasePin *GetPin(int n); <br> <br>public: <br> <br>    CTransInPlaceFilter(TCHAR *, LPUNKNOWN, REFCLSID clsid, HRESULT *); <br> <br>    // The following are defined to avoid undefined pure virtuals. <br>    // Even if they are never called, they will give linkage warnings/errors <br> <br>    // We override EnumMediaTypes to bypass the transform class enumerator <br>    // which would otherwise call this. <br>    HRESULT GetMediaType(int iPosition, CMediaType *pMediaType) <br>        {   DbgBreak("CTransInPlaceFilter::GetMediaType should never be called"); <br>            return E_UNEXPECTED; <br>        } <br> <br>    // This is called when we actually have to provide out own allocator. <br>    HRESULT DecideBufferSize(IMemAllocator*, ALLOCATOR_PROPERTIES *); <br> <br>    // The functions which call this in CTransform are overridden in this <br>    // class to call CheckInputType with the assumption that the type <br>    // does not change.  In Debug builds some calls will be made and <br>    // we just ensure that they do not assert. <br>    HRESULT CheckTransform(const CMediaType *mtIn, const CMediaType *mtOut) <br>    { <br>        return S_OK; <br>    }; <br> <br> <br>    // ================================================================= <br>    // ----- You may want to override this ----------------------------- <br>    // ================================================================= <br> <br>    HRESULT CompleteConnect(PIN_DIRECTION dir,IPin *pReceivePin); <br> <br>    // chance to customize the transform process <br>    virtual HRESULT Receive(IMediaSample *pSample); <br> <br>    // ================================================================= <br>    // ----- You MUST override these ----------------------------------- <br>    // ================================================================= <br> <br>    virtual HRESULT Transform(IMediaSample *pSample) PURE; <br> <br>    // this goes in the factory template table to create new instances <br>    // static CCOMObject * CreateInstance(LPUNKNOWN, HRESULT *); <br> <br> <br>#ifdef PERF <br>    // Override to register performance measurement with a less generic string <br>    // You should do this to avoid confusion with other filters <br>    virtual void RegisterPerfId() <br>         {m_idTransInPlace = MSR_REGISTER(TEXT("TransInPlace"));} <br>#endif // PERF <br> <br> <br>// implementation details <br> <br>protected: <br> <br>    IMediaSample * CTransInPlaceFilter::Copy(IMediaSample *pSource); <br> <br>    int m_idTransInPlace;                 // performance measuring id <br> <br>    // these hold our input and output pins <br> <br>    friend class CTransInPlaceInputPin; <br>    friend class CTransInPlaceOutputPin; <br> <br>    CTransInPlaceInputPin  *InputPin() <br>    { <br>        return (CTransInPlaceInputPin *)m_pInput; <br>    }; <br>    CTransInPlaceOutputPin *OutputPin() <br>    { <br>        return (CTransInPlaceOutputPin *)m_pOutput; <br>    }; <br>}; // CTransInPlaceFilter <br> <br>#endif /* __TRANSIP__ */ <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
