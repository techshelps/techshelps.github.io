<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>STRMCTL.H</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2774"></a>STRMCTL.H</h2>
<pre><code>//==========================================================================; <br>// <br>//  Copyright (c) 1997Microsoft Corporation.All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>#ifndef __strmctl_h__ <br>#define __strmctl_h__ <br> <br>class CBaseStreamControl : public IAMStreamControl <br>{ <br>public: <br>    // Used by the implementation <br>    enum StreamControlState <br>    { STREAM_FLOWING = 0x1000, <br>      STREAM_DISCARDING <br>    }; <br> <br>private: <br>    enum StreamControlStatem_StreamState;// Current stream state <br>    enum StreamControlStatem_StreamStateOnStop;// State after next stop <br>// (i.e.Blocking or Discarding) <br> <br>    REFERENCE_TIMEm_tStartTime;    // MAX_TIME implies none <br>    REFERENCE_TIMEm_tStopTime;    // MAX_TIME implies none <br>    DWORDm_dwStartCookie;    // Cookie for notification to app <br>    DWORDm_dwStopCookie;    // Cookie for notification to app <br>    volatile BOOL       m_bIsFlushing;        // No optimization pls! <br>    volatile BOOLm_bStopSendExtra;   // bSendExtra was set <br>    volatile BOOLm_bStopExtraSent;   // the extra one was sent <br> <br>    CCritSecm_CritSec;    // CritSec to guard above attributes <br> <br>    // Event to fire when we can come <br>    // out of blocking, or to come out of waiting <br>    // to discard if we change our minds. <br>    // <br>    CAMEventm_StreamEvent; <br> <br>    // All of these methods execute immediately.  Helpers for others. <br>    // <br>    void ExecuteStop(); <br>    void ExecuteStart(); <br>    void CancelStop(); <br>    void CancelStart(); <br> <br>    // Some things we need to be told by our owning filter <br>    // Your pin must also expose IAMStreamControl when QI'd for it! <br>    // <br>    IReferenceClock *m_pRefClock;    // Need it to set advises <br>    // Filter must tell us via <br>    // SetSyncSource <br>    IMediaEventSink *   m_pSink;            // Event sink <br>    // Filter must tell us after it <br>    // creates it in JoinFilterGraph() <br>    FILTER_STATEm_FilterState;    // Just need it! <br>    // Filter must tell us via <br>    // NotifyFilterState <br>    REFERENCE_TIMEm_tRunStart;    // Per the Run call to the filter <br> <br>    // This guy will return one of the three StreamControlState's.  Here's what <br>    // the caller should do for each one: <br>    // <br>    // STREAM_FLOWING:Proceed as usual (render or pass the sample on) <br>    // STREAM_DISCARDING:Calculate the time 'til *pSampleStop and wait <br>    //that long for the event handle <br>    //(GetStreamEventHandle()).  If the wait <br>    //expires, throw the sample away.  If the event <br>    //fires, call me back - I've changed my mind. <br>    // <br>    enum StreamControlState CheckSampleTimes( const REFERENCE_TIME * pSampleStart, <br>      const REFERENCE_TIME * pSampleStop ); <br> <br>public: <br>    // You don't have to tell us much when we're created, but there are other <br>    // obligations that must be met.  See SetSyncSource &amp; NotifyFilterState <br>    // below. <br>    // <br>    CBaseStreamControl(); <br>    ~CBaseStreamControl(); <br> <br>    // If you want this class to work properly, there are thing you need to <br>    // (keep) telling it.  Filters with pins that use this class <br>    // should ensure that they pass through to this method any calls they <br>    // receive on their SetSyncSource. <br> <br>    // We need a clock to see what time it is.  This is for the <br>    // "discard in a timely fashion" logic.  If we discard everything as <br>    // quick as possible, a whole 60 minute file could get discarded in the <br>    // first 10 seconds, and if somebody wants to turn streaming on at 30  <br>    // minutes into the file, and they make the call more than a few seconds <br>    // after the graph is run, it may be too late!  That would be silly. <br>    // So we hold every sample until it's time has gone, then we discard it. <br>    // The filter should call this when it gets a SetSyncSource <br>    // <br>    void SetSyncSource( IReferenceClock * pRefClock ) <br>    { <br>CAutoLock lck(&amp;m_CritSec); <br>if (m_pRefClock) m_pRefClock-&gt;Release(); <br>m_pRefClock = pRefClock; <br>if (m_pRefClock) m_pRefClock-&gt;AddRef(); <br>    } <br> <br>    // Set event sink for notifications <br>    // The filter should call this in its JoinFilterGraph after it creates the <br>    // IMediaEventSink <br>    // <br>    void SetFilterGraph( IMediaEventSink *pSink ) { <br>        m_pSink = pSink; <br>    } <br> <br>    // Since we schedule in stream time, we need the tStart and must track the <br>    // state of our owning filter. <br>    // The app should call this ever state change <br>    // <br>    void NotifyFilterState( FILTER_STATE new_state, REFERENCE_TIME tStart = 0 ); <br> <br>    // Filter should call Flushing(TRUE) in BeginFlush, <br>    // and Flushing(FALSE) in EndFlush. <br>    // <br>    void Flushing( BOOL bInProgress ); <br> <br> <br>    // The two main methods of IAMStreamControl <br> <br>    // Class adds default values suitable for immediate <br>    // muting and unmuting of the stream. <br> <br>    STDMETHODIMP StopAt( const REFERENCE_TIME * ptStop = NULL, <br> BOOL bSendExtra = FALSE, <br> DWORD dwCookie = 0 ); <br>    STDMETHODIMP StartAt( const REFERENCE_TIME * ptStart = NULL, <br>      DWORD dwCookie = 0 ); <br>    STDMETHODIMP GetInfo( AM_STREAM_INFO *pInfo); <br> <br>    // Helper function for pin's receive method.  Call this with <br>    // the sample and we'll tell you what to do with it.  We'll do a <br>    // WaitForSingleObject within this call if one is required.  This is <br>    // a "What should I do with this sample?" kind of call. We'll tell the <br>    // caller to either flow it or discard it. <br>    // If pSample is NULL we evaluate based on the current state <br>    // settings <br>    enum StreamControlState CheckStreamState( IMediaSample * pSample ); <br> <br>private: <br>    // These don't require locking, but we are relying on the fact that <br>    // m_StreamState can be retrieved with integrity, and is a snap shot that <br>    // may have just been, or may be just about to be, changed. <br>    HANDLE GetStreamEventHandle() const { return m_StreamEvent; } <br>    enum StreamControlState GetStreamState() const { return m_StreamState; } <br>    BOOL IsStreaming() const { return m_StreamState == STREAM_FLOWING; } <br>}; <br> <br>#endif </code></pre>
<p>&nbsp;</p></body>
</HTML>
