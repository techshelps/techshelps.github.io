<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TRANSFRM.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2777"></a>TRANSFRM.CPP</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>// Base class for simple transform filters such as video decompressors <br> <br>#include &lt;streams.h&gt; <br>#include &lt;measure.h&gt; <br> <br> <br>// ================================================================= <br>// Implements the CTransformFilter class <br>// ================================================================= <br> <br>CTransformFilter::CTransformFilter(TCHAR     *pName, <br>                                   LPUNKNOWN pUnk, <br>                                   REFCLSID  clsid) : <br>    CBaseFilter(pName,pUnk,&amp;m_csFilter, clsid), <br>    m_pInput(NULL), <br>    m_pOutput(NULL), <br>    m_bEOSDelivered(FALSE), <br>    m_bQualityChanged(FALSE), <br>    m_bSampleSkipped(FALSE) <br>{ <br>#ifdef PERF <br>    RegisterPerfId(); <br>#endif //  PERF <br>} <br> <br> <br>// destructor <br> <br>CTransformFilter::~CTransformFilter() <br>{ <br>    // Delete the pins <br> <br>    delete m_pInput; <br>    delete m_pOutput; <br>} <br> <br> <br>// Transform place holder - should never be called <br>HRESULT CTransformFilter::Transform(IMediaSample * pIn, IMediaSample *pOut) <br>{ <br>    UNREFERENCED_PARAMETER(pIn); <br>    UNREFERENCED_PARAMETER(pOut); <br>    DbgBreak("CTransformFilter::Transform() should never be called"); <br>    return E_UNEXPECTED; <br>} <br> <br> <br>// return the number of pins we provide <br> <br>int CTransformFilter::GetPinCount() <br>{ <br>    return 2; <br>} <br> <br> <br>// return a non-addrefed CBasePin * for the user to addref if he holds onto it <br>// for longer than his pointer to us. We create the pins dynamically when they <br>// are asked for rather than in the constructor. This is because we want to <br>// give the derived class an oppportunity to return different pin objects <br> <br>// We return the objects as and when they are needed. If either of these fails <br>// then we return NULL, the assumption being that the caller will realise the <br>// whole deal is off and destroy us - which in turn will delete everything. <br> <br>CBasePin * <br>CTransformFilter::GetPin(int n) <br>{ <br>    HRESULT hr = S_OK; <br> <br>    // Create an input pin if necessary <br> <br>    if (m_pInput == NULL) { <br> <br>        m_pInput = new CTransformInputPin(NAME("Transform input pin"), <br>                                          this,              // Owner filter <br>                                          &amp;hr,               // Result code <br>                                          L"XForm In");      // Pin name <br> <br> <br>        //  Can't fail <br>        ASSERT(SUCCEEDED(hr)); <br>        if (m_pInput == NULL) { <br>            return NULL; <br>        } <br>        m_pOutput = (CTransformOutputPin *) <br>   new CTransformOutputPin(NAME("Transform output pin"), <br>                                            this,            // Owner filter <br>                                            &amp;hr,             // Result code <br>                                            L"XForm Out");   // Pin name <br> <br> <br>        // Can't fail <br>        ASSERT(SUCCEEDED(hr)); <br>        if (m_pOutput == NULL) { <br>            delete m_pInput; <br>            m_pInput = NULL; <br>        } <br>    } <br> <br>    // Return the appropriate pin <br> <br>    if (n == 0) { <br>        return m_pInput; <br>    } else <br>    if (n == 1) { <br>        return m_pOutput; <br>    } else { <br>        return NULL; <br>    } <br>} <br> <br> <br>// <br>// FindPin <br>// <br>// If Id is In or Out then return the IPin* for that pin <br>// creating the pin if need be.  Otherwise return NULL with an error. <br> <br>STDMETHODIMP CTransformFilter::FindPin(LPCWSTR Id, IPin **ppPin) <br>{ <br>    CheckPointer(ppPin,E_POINTER); <br>    ValidateReadWritePtr(ppPin,sizeof(IPin *)); <br> <br>    if (0==lstrcmpW(Id,L"In")) { <br>        *ppPin = GetPin(0); <br>    } else if (0==lstrcmpW(Id,L"Out")) { <br>        *ppPin = GetPin(1); <br>    } else { <br>        *ppPin = NULL; <br>        return VFW_E_NOT_FOUND; <br>    } <br> <br>    HRESULT hr = NOERROR; <br>    //  AddRef() returned pointer - but GetPin could fail if memory is low. <br>    if (*ppPin) { <br>        (*ppPin)-&gt;AddRef(); <br>    } else { <br>        hr = E_OUTOFMEMORY;  // probably.  There's no pin anyway. <br>    } <br>    return hr; <br>} <br> <br> <br>// override these two functions if you want to inform something <br>// about entry to or exit from streaming state. <br> <br>HRESULT <br>CTransformFilter::StartStreaming() <br>{ <br>    return NOERROR; <br>} <br> <br> <br>HRESULT <br>CTransformFilter::StopStreaming() <br>{ <br>    return NOERROR; <br>} <br> <br> <br>// override this to grab extra interfaces on connection <br> <br>HRESULT <br>CTransformFilter::CheckConnect(PIN_DIRECTION dir,IPin *pPin) <br>{ <br>    UNREFERENCED_PARAMETER(dir); <br>    UNREFERENCED_PARAMETER(pPin); <br>    return NOERROR; <br>} <br> <br> <br>// place holder to allow derived classes to release any extra interfaces <br> <br>HRESULT <br>CTransformFilter::BreakConnect(PIN_DIRECTION dir) <br>{ <br>    UNREFERENCED_PARAMETER(dir); <br>    return NOERROR; <br>} <br> <br> <br>// Let derived classes know about connection completion <br> <br>HRESULT <br>CTransformFilter::CompleteConnect(PIN_DIRECTION direction,IPin *pReceivePin) <br>{ <br>    UNREFERENCED_PARAMETER(direction); <br>    UNREFERENCED_PARAMETER(pReceivePin); <br>    return NOERROR; <br>} <br> <br> <br>// override this to know when the media type is really set <br> <br>HRESULT <br>CTransformFilter::SetMediaType(PIN_DIRECTION direction,const CMediaType *pmt) <br>{ <br>    UNREFERENCED_PARAMETER(direction); <br>    UNREFERENCED_PARAMETER(pmt); <br>    return NOERROR; <br>} <br> <br> <br>// Set up our output sample <br>HRESULT <br>CTransformFilter::InitializeOutputSample(IMediaSample *pSample, IMediaSample **ppOutSample) <br>{ <br>    IMediaSample *pOutSample; <br> <br>    // default - times are the same <br> <br>    AM_SAMPLE2_PROPERTIES * const pProps = m_pInput-&gt;SampleProps(); <br>    DWORD dwFlags = m_bSampleSkipped ? AM_GBF_PREVFRAMESKIPPED : 0; <br> <br>    // This will prevent the image renderer from switching us to DirectDraw <br>    // when we can't do it without skipping frames because we're not on a <br>    // keyframe.  If it really has to switch us, it still will, but then we <br>    // will have to wait for the next keyframe <br>    if (!(pProps-&gt;dwSampleFlags &amp; AM_SAMPLE_SPLICEPOINT)) { <br>dwFlags |= AM_GBF_NOTASYNCPOINT; <br>    } <br> <br>    ASSERT(m_pOutput-&gt;m_pAllocator != NULL); <br>    HRESULT hr = m_pOutput-&gt;m_pAllocator-&gt;GetBuffer( <br>             &amp;pOutSample <br>             , pProps-&gt;dwSampleFlags &amp; AM_SAMPLE_TIMEVALID ? <br>                   &amp;pProps-&gt;tStart : NULL <br>             , pProps-&gt;dwSampleFlags &amp; AM_SAMPLE_STOPVALID ? <br>                   &amp;pProps-&gt;tStop : NULL <br>             , dwFlags <br>         ); <br>    *ppOutSample = pOutSample; <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br> <br>    ASSERT(pOutSample); <br>    IMediaSample2 *pOutSample2; <br>    if (SUCCEEDED(pOutSample-&gt;QueryInterface(IID_IMediaSample2, <br>                                             (void **)&amp;pOutSample2))) { <br>        /*  Modify it */ <br>        AM_SAMPLE2_PROPERTIES OutProps; <br>        EXECUTE_ASSERT(SUCCEEDED(pOutSample2-&gt;GetProperties( <br>            FIELD_OFFSET(AM_SAMPLE2_PROPERTIES, tStart), (PBYTE)&amp;OutProps) <br>        )); <br>        OutProps.dwTypeSpecificFlags = pProps-&gt;dwTypeSpecificFlags; <br>        OutProps.dwSampleFlags = <br>            (OutProps.dwSampleFlags &amp; AM_SAMPLE_TYPECHANGED) | <br>            (pProps-&gt;dwSampleFlags &amp; ~AM_SAMPLE_TYPECHANGED); <br>        OutProps.tStart = pProps-&gt;tStart; <br>        OutProps.tStop  = pProps-&gt;tStop; <br>        OutProps.cbData = FIELD_OFFSET(AM_SAMPLE2_PROPERTIES, dwStreamId); <br>        hr = pOutSample2-&gt;SetProperties( <br>            FIELD_OFFSET(AM_SAMPLE2_PROPERTIES, dwStreamId), <br>            (PBYTE)&amp;OutProps <br>        ); <br>        if (pProps-&gt;dwSampleFlags &amp; AM_SAMPLE_DATADISCONTINUITY) { <br>            m_bSampleSkipped = FALSE; <br>        } <br>        pOutSample2-&gt;Release(); <br>    } else { <br>        if (pProps-&gt;dwSampleFlags &amp; AM_SAMPLE_TIMEVALID) { <br>            pOutSample-&gt;SetTime(&amp;pProps-&gt;tStart, <br>                                &amp;pProps-&gt;tStop); <br>        } <br>        if (pProps-&gt;dwSampleFlags &amp; AM_SAMPLE_SPLICEPOINT) { <br>            pOutSample-&gt;SetSyncPoint(TRUE); <br>        } <br>        if (pProps-&gt;dwSampleFlags &amp; AM_SAMPLE_DATADISCONTINUITY) { <br>            pOutSample-&gt;SetDiscontinuity(TRUE); <br>            m_bSampleSkipped = FALSE; <br>        } <br>        // Copy the media times <br> <br>        LONGLONG MediaStart, MediaEnd; <br>        if (pSample-&gt;GetMediaTime(&amp;MediaStart,&amp;MediaEnd) == NOERROR) { <br>            pOutSample-&gt;SetMediaTime(&amp;MediaStart,&amp;MediaEnd); <br>        } <br>    } <br>    return S_OK; <br>} <br> <br>// override this to customize the transform process <br> <br>HRESULT <br>CTransformFilter::Receive(IMediaSample *pSample) <br>{ <br>    /*  Check for other streams and pass them on */ <br>    AM_SAMPLE2_PROPERTIES * const pProps = m_pInput-&gt;SampleProps(); <br>    if (pProps-&gt;dwStreamId != AM_STREAM_MEDIA) { <br>        return m_pOutput-&gt;m_pInputPin-&gt;Receive(pSample); <br>    } <br>    HRESULT hr; <br>    ASSERT(pSample); <br>    IMediaSample * pOutSample; <br> <br>    // If no output to deliver to then no point sending us data <br> <br>    ASSERT (m_pOutput != NULL) ; <br> <br>    // Set up the output sample <br>    hr = InitializeOutputSample(pSample, &amp;pOutSample); <br> <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br> <br>    // Start timing the transform (if PERF is defined) <br>    MSR_START(m_idTransform); <br> <br>    // have the derived class transform the data <br> <br>    hr = Transform(pSample, pOutSample); <br> <br>    // Stop the clock and log it (if PERF is defined) <br>    MSR_STOP(m_idTransform); <br> <br>    if (FAILED(hr)) { <br>DbgLog((LOG_TRACE,1,TEXT("Error from transform"))); <br>    } else { <br>        // the Transform() function can return S_FALSE to indicate that the <br>        // sample should not be delivered; we only deliver the sample if it's <br>        // really S_OK (same as NOERROR, of course.) <br>        if (hr == NOERROR) { <br>        hr = m_pOutput-&gt;m_pInputPin-&gt;Receive(pOutSample); <br>        } else { <br>            // S_FALSE returned from Transform is a PRIVATE agreement <br>            // We should return NOERROR from Receive() in this cause because returning S_FALSE <br>            // from Receive() means that this is the end of the stream and no more data should <br>            // be sent. <br>            if (S_FALSE == hr) { <br> <br>                //  Release the sample before calling notify to avoid <br>                //  deadlocks if the sample holds a lock on the system <br>                //  such as DirectDraw buffers do <br>                pOutSample-&gt;Release(); <br>                m_bSampleSkipped = TRUE; <br>                if (!m_bQualityChanged) { <br>                    NotifyEvent(EC_QUALITY_CHANGE,0,0); <br>                    m_bQualityChanged = TRUE; <br>                } <br>                return NOERROR; <br>            } <br>        } <br>    } <br> <br>    // release the output buffer. If the connected pin still needs it, <br>    // it will have addrefed it itself. <br>    pOutSample-&gt;Release(); <br> <br>    return hr; <br>} <br> <br> <br>// Return S_FALSE to mean "pass the note on upstream" <br>// Return NOERROR (Same as S_OK) <br>// to mean "I've done something about it, don't pass it on" <br>HRESULT CTransformFilter::AlterQuality(Quality q) <br>{ <br>    UNREFERENCED_PARAMETER(q); <br>    return S_FALSE; <br>} <br> <br> <br>// EndOfStream received. Default behaviour is to deliver straight <br>// downstream, since we have no queued data. If you overrode Receive <br>// and have queue data, then you need to handle this and deliver EOS after <br>// all queued data is sent <br>HRESULT <br>CTransformFilter::EndOfStream(void) <br>{ <br>    HRESULT hr = NOERROR; <br>    if (m_pOutput != NULL) { <br>        hr = m_pOutput-&gt;DeliverEndOfStream(); <br>    } <br> <br>    return hr; <br>} <br> <br> <br>// enter flush state. Receives already blocked <br>// must override this if you have queued data or a worker thread <br>HRESULT <br>CTransformFilter::BeginFlush(void) <br>{ <br>    HRESULT hr = NOERROR; <br>    if (m_pOutput != NULL) { <br>// block receives -- done by caller (CBaseInputPin::BeginFlush) <br> <br>// discard queued data -- we have no queued data <br> <br>// free anyone blocked on receive - not possible in this filter <br> <br>// call downstream <br>hr = m_pOutput-&gt;DeliverBeginFlush(); <br>    } <br>    return hr; <br>} <br> <br> <br>// leave flush state. must override this if you have queued data <br>// or a worker thread <br>HRESULT <br>CTransformFilter::EndFlush(void) <br>{ <br>    // sync with pushing thread -- we have no worker thread <br> <br>    // ensure no more data to go downstream -- we have no queued data <br> <br>    // call EndFlush on downstream pins <br>    ASSERT (m_pOutput != NULL); <br>    return m_pOutput-&gt;DeliverEndFlush(); <br> <br>    // caller (the input pin's method) will unblock Receives <br>} <br> <br> <br>// override these so that the derived filter can catch them <br> <br>STDMETHODIMP <br>CTransformFilter::Stop() <br>{ <br>    CAutoLock lck1(&amp;m_csFilter); <br>    if (m_State == State_Stopped) { <br>        return NOERROR; <br>    } <br> <br>    // Succeed the Stop if we are not completely connected <br> <br>    ASSERT(m_pInput == NULL || m_pOutput != NULL); <br>    if (m_pInput == NULL || m_pInput-&gt;IsConnected() == FALSE || <br>        m_pOutput-&gt;IsConnected() == FALSE) { <br>                m_State = State_Stopped; <br>                m_bEOSDelivered = FALSE; <br>                return NOERROR; <br>    } <br> <br>    ASSERT(m_pInput); <br>    ASSERT(m_pOutput); <br> <br>    // decommit the input pin before locking or we can deadlock <br>    m_pInput-&gt;Inactive(); <br> <br>    // synchronize with Receive calls <br> <br>    CAutoLock lck2(&amp;m_csReceive); <br>    m_pOutput-&gt;Inactive(); <br> <br>    // allow a class derived from CTransformFilter <br>    // to know about starting and stopping streaming <br> <br>    HRESULT hr = StopStreaming(); <br>    if (SUCCEEDED(hr)) { <br>// complete the state transition <br>m_State = State_Stopped; <br>m_bEOSDelivered = FALSE; <br>    } <br>    return hr; <br>} <br> <br> <br>STDMETHODIMP <br>CTransformFilter::Pause() <br>{ <br>    CAutoLock lck(&amp;m_csFilter); <br>    HRESULT hr = NOERROR; <br> <br>    if (m_State == State_Paused) { <br>        // (This space left deliberately blank) <br>    } <br> <br>    // If we have no input pin or it isn't yet connected then when we are <br>    // asked to pause we deliver an end of stream to the downstream filter. <br>    // This makes sure that it doesn't sit there forever waiting for <br>    // samples which we cannot ever deliver without an input connection. <br> <br>    else if (m_pInput == NULL || m_pInput-&gt;IsConnected() == FALSE) { <br>        if (m_pOutput &amp;&amp; m_bEOSDelivered == FALSE) { <br>            m_pOutput-&gt;DeliverEndOfStream(); <br>            m_bEOSDelivered = TRUE; <br>        } <br>        m_State = State_Paused; <br>    } <br> <br>    // We may have an input connection but no output connection <br>    // However, if we have an input pin we do have an output pin <br> <br>    else if (m_pOutput-&gt;IsConnected() == FALSE) { <br>        m_State = State_Paused; <br>    } <br> <br>    else { <br>if (m_State == State_Stopped) { <br>    // allow a class derived from CTransformFilter <br>    // to know about starting and stopping streaming <br>            CAutoLock lck2(&amp;m_csReceive); <br>    hr = StartStreaming(); <br>} <br>if (SUCCEEDED(hr)) { <br>    hr = CBaseFilter::Pause(); <br>} <br>    } <br> <br>    m_bSampleSkipped = FALSE; <br>    m_bQualityChanged = FALSE; <br>    return hr; <br>} <br> <br>HRESULT <br>CTransformFilter::NewSegment( <br>    REFERENCE_TIME tStart, <br>    REFERENCE_TIME tStop, <br>    double dRate) <br>{ <br>    if (m_pOutput != NULL) { <br>        return m_pOutput-&gt;DeliverNewSegment(tStart, tStop, dRate); <br>    } <br>    return S_OK; <br>} <br> <br>// Check streaming status <br>HRESULT <br>CTransformInputPin::CheckStreaming() <br>{ <br>    ASSERT(m_pTransformFilter-&gt;m_pOutput != NULL); <br>    if (!m_pTransformFilter-&gt;m_pOutput-&gt;IsConnected()) { <br>        return VFW_E_NOT_CONNECTED; <br>    } else { <br>        //  Shouldn't be able to get any data if we're not connected! <br>        ASSERT(IsConnected()); <br> <br>        //  Don't process stuff in Stopped state <br>        if (IsStopped()) { <br>            return VFW_E_WRONG_STATE; <br>        } <br>        if (m_bRunTimeError) { <br>        return VFW_E_RUNTIME_ERROR; <br>        } <br>        return S_OK; <br>    } <br>} <br> <br> <br>// ================================================================= <br>// Implements the CTransformInputPin class <br>// ================================================================= <br> <br> <br>// constructor <br> <br>CTransformInputPin::CTransformInputPin( <br>    TCHAR *pObjectName, <br>    CTransformFilter *pTransformFilter, <br>    HRESULT * phr, <br>    LPCWSTR pName) <br>    : CBaseInputPin(pObjectName, pTransformFilter, &amp;pTransformFilter-&gt;m_csFilter, phr, pName) <br>{ <br>    DbgLog((LOG_TRACE,2,TEXT("CTransformInputPin::CTransformInputPin"))); <br>    m_pTransformFilter = pTransformFilter; <br>} <br> <br> <br>// provides derived filter a chance to grab extra interfaces <br> <br>HRESULT <br>CTransformInputPin::CheckConnect(IPin *pPin) <br>{ <br>    HRESULT hr = m_pTransformFilter-&gt;CheckConnect(PINDIR_INPUT,pPin); <br>    if (FAILED(hr)) { <br>    return hr; <br>    } <br>    return CBaseInputPin::CheckConnect(pPin); <br>} <br> <br> <br>// provides derived filter a chance to release it's extra interfaces <br> <br>HRESULT <br>CTransformInputPin::BreakConnect() <br>{ <br>    //  Can't disconnect unless stopped <br>    ASSERT(IsStopped()); <br>    m_pTransformFilter-&gt;BreakConnect(PINDIR_INPUT); <br>    return CBaseInputPin::BreakConnect(); <br>} <br> <br> <br>// Let derived class know when the input pin is connected <br> <br>HRESULT <br>CTransformInputPin::CompleteConnect(IPin *pReceivePin) <br>{ <br>    HRESULT hr = m_pTransformFilter-&gt;CompleteConnect(PINDIR_INPUT,pReceivePin); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br>    return CBaseInputPin::CompleteConnect(pReceivePin); <br>} <br> <br> <br>// check that we can support a given media type <br> <br>HRESULT <br>CTransformInputPin::CheckMediaType(const CMediaType* pmt) <br>{ <br>    // Check the input type <br> <br>    HRESULT hr = m_pTransformFilter-&gt;CheckInputType(pmt); <br>    if (S_OK != hr) { <br>        return hr; <br>    } <br> <br>    // if the output pin is still connected, then we have <br>    // to check the transform not just the input format <br> <br>    if ((m_pTransformFilter-&gt;m_pOutput != NULL) &amp;&amp; <br>        (m_pTransformFilter-&gt;m_pOutput-&gt;IsConnected())) { <br>            return m_pTransformFilter-&gt;CheckTransform( <br>                      pmt, <br>      &amp;m_pTransformFilter-&gt;m_pOutput-&gt;CurrentMediaType()); <br>    } else { <br>        return hr; <br>    } <br>} <br> <br> <br>// set the media type for this connection <br> <br>HRESULT <br>CTransformInputPin::SetMediaType(const CMediaType* mtIn) <br>{ <br>    // Set the base class media type (should always succeed) <br>    HRESULT hr = CBasePin::SetMediaType(mtIn); <br>    ASSERT(SUCCEEDED(hr)); <br> <br>    // check the transform can be done (should always succeed) <br>    ASSERT(SUCCEEDED(m_pTransformFilter-&gt;CheckInputType(mtIn))); <br> <br>    m_pTransformFilter-&gt;SetMediaType(PINDIR_INPUT,mtIn); <br>    return NOERROR; <br>} <br> <br> <br>// ================================================================= <br>// Implements IMemInputPin interface <br>// ================================================================= <br> <br> <br>// provide EndOfStream that passes straight downstream <br>// (there is no queued data) <br>STDMETHODIMP <br>CTransformInputPin::EndOfStream(void) <br>{ <br>    CAutoLock lck(&amp;m_pTransformFilter-&gt;m_csReceive); <br>    HRESULT hr = CheckStreaming(); <br>    if (S_OK == hr) { <br>       hr = m_pTransformFilter-&gt;EndOfStream(); <br>    } <br>    return hr; <br>} <br> <br> <br>// enter flushing state. Call default handler to block Receives, then <br>// pass to overridable method in filter <br>STDMETHODIMP <br>CTransformInputPin::BeginFlush(void) <br>{ <br>    CAutoLock lck(&amp;m_pTransformFilter-&gt;m_csFilter); <br>    //  Are we actually doing anything? <br>    ASSERT(m_pTransformFilter-&gt;m_pOutput != NULL); <br>    if (!IsConnected() || <br>        !m_pTransformFilter-&gt;m_pOutput-&gt;IsConnected()) { <br>        return VFW_E_NOT_CONNECTED; <br>    } <br>    HRESULT hr = CBaseInputPin::BeginFlush(); <br>    if (FAILED(hr)) { <br>    return hr; <br>    } <br> <br>    return m_pTransformFilter-&gt;BeginFlush(); <br>} <br> <br> <br>// leave flushing state. <br>// Pass to overridable method in filter, then call base class <br>// to unblock receives (finally) <br>STDMETHODIMP <br>CTransformInputPin::EndFlush(void) <br>{ <br>    CAutoLock lck(&amp;m_pTransformFilter-&gt;m_csFilter); <br>    //  Are we actually doing anything? <br>    ASSERT(m_pTransformFilter-&gt;m_pOutput != NULL); <br>    if (!IsConnected() || <br>        !m_pTransformFilter-&gt;m_pOutput-&gt;IsConnected()) { <br>        return VFW_E_NOT_CONNECTED; <br>    } <br> <br>    HRESULT hr = m_pTransformFilter-&gt;EndFlush(); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br> <br>    return CBaseInputPin::EndFlush(); <br>} <br> <br> <br>// here's the next block of data from the stream. <br>// AddRef it yourself if you need to hold it beyond the end <br>// of this call. <br> <br>HRESULT <br>CTransformInputPin::Receive(IMediaSample * pSample) <br>{ <br>    HRESULT hr; <br>    CAutoLock lck(&amp;m_pTransformFilter-&gt;m_csReceive); <br>    ASSERT(pSample); <br> <br>    // check all is well with the base class <br>    hr = CBaseInputPin::Receive(pSample); <br>    if (S_OK == hr) { <br>        hr = m_pTransformFilter-&gt;Receive(pSample); <br>    } <br>    return hr; <br>} <br> <br> <br> <br> <br>// override to pass downstream <br>STDMETHODIMP <br>CTransformInputPin::NewSegment( <br>    REFERENCE_TIME tStart, <br>    REFERENCE_TIME tStop, <br>    double dRate) <br>{ <br>    //  Save the values in the pin <br>    CBasePin::NewSegment(tStart, tStop, dRate); <br>    return m_pTransformFilter-&gt;NewSegment(tStart, tStop, dRate); <br>} <br> <br> <br> <br> <br>// ================================================================= <br>// Implements the CTransformOutputPin class <br>// ================================================================= <br> <br> <br>// constructor <br> <br>CTransformOutputPin::CTransformOutputPin( <br>    TCHAR *pObjectName, <br>    CTransformFilter *pTransformFilter, <br>    HRESULT * phr, <br>    LPCWSTR pPinName) <br>    : CBaseOutputPin(pObjectName, pTransformFilter, &amp;pTransformFilter-&gt;m_csFilter, phr, pPinName), <br>      m_pPosition(NULL) <br>{ <br>    DbgLog((LOG_TRACE,2,TEXT("CTransformOutputPin::CTransformOutputPin"))); <br>    m_pTransformFilter = pTransformFilter; <br> <br>} <br> <br> <br>// destructor <br> <br>CTransformOutputPin::~CTransformOutputPin() <br>{ <br>    DbgLog((LOG_TRACE,2,TEXT("CTransformOutputPin::~CTransformOutputPin"))); <br> <br>    if (m_pPosition) m_pPosition-&gt;Release(); <br>} <br> <br> <br>// overriden to expose IMediaPosition and IMediaSeeking control interfaces <br> <br>STDMETHODIMP <br>CTransformOutputPin::NonDelegatingQueryInterface(REFIID riid, void **ppv) <br>{ <br>    CheckPointer(ppv,E_POINTER); <br>    ValidateReadWritePtr(ppv,sizeof(PVOID)); <br>    *ppv = NULL; <br> <br>    if (riid == IID_IMediaPosition || riid == IID_IMediaSeeking) { <br> <br>        // we should have an input pin by now <br> <br>        ASSERT(m_pTransformFilter-&gt;m_pInput != NULL); <br> <br>        if (m_pPosition == NULL) { <br> <br>            HRESULT hr = CreatePosPassThru( <br>                             GetOwner(), <br>                             FALSE, <br>                             (IPin *)m_pTransformFilter-&gt;m_pInput, <br>                             &amp;m_pPosition); <br>            if (FAILED(hr)) { <br>                return hr; <br>            } <br>        } <br>        return m_pPosition-&gt;QueryInterface(riid, ppv); <br>    } else { <br>        return CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv); <br>    } <br>} <br> <br> <br>// provides derived filter a chance to grab extra interfaces <br> <br>HRESULT <br>CTransformOutputPin::CheckConnect(IPin *pPin) <br>{ <br>    // we should have an input connection first <br> <br>    ASSERT(m_pTransformFilter-&gt;m_pInput != NULL); <br>    if ((m_pTransformFilter-&gt;m_pInput-&gt;IsConnected() == FALSE)) { <br>    return E_UNEXPECTED; <br>    } <br> <br>    HRESULT hr = m_pTransformFilter-&gt;CheckConnect(PINDIR_OUTPUT,pPin); <br>    if (FAILED(hr)) { <br>    return hr; <br>    } <br>    return CBaseOutputPin::CheckConnect(pPin); <br>} <br> <br> <br>// provides derived filter a chance to release it's extra interfaces <br> <br>HRESULT <br>CTransformOutputPin::BreakConnect() <br>{ <br>    //  Can't disconnect unless stopped <br>    ASSERT(IsStopped()); <br>    m_pTransformFilter-&gt;BreakConnect(PINDIR_OUTPUT); <br>    return CBaseOutputPin::BreakConnect(); <br>} <br> <br> <br>// Let derived class know when the output pin is connected <br> <br>HRESULT <br>CTransformOutputPin::CompleteConnect(IPin *pReceivePin) <br>{ <br>    HRESULT hr = m_pTransformFilter-&gt;CompleteConnect(PINDIR_OUTPUT,pReceivePin); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br>    return CBaseOutputPin::CompleteConnect(pReceivePin); <br>} <br> <br> <br>// check a given transform - must have selected input type first <br> <br>HRESULT <br>CTransformOutputPin::CheckMediaType(const CMediaType* pmtOut) <br>{ <br>    // must have selected input first <br>    ASSERT(m_pTransformFilter-&gt;m_pInput != NULL); <br>    if ((m_pTransformFilter-&gt;m_pInput-&gt;IsConnected() == FALSE)) { <br>        return E_INVALIDARG; <br>    } <br> <br>    return m_pTransformFilter-&gt;CheckTransform( <br>    &amp;m_pTransformFilter-&gt;m_pInput-&gt;CurrentMediaType(), <br>    pmtOut); <br>} <br> <br> <br>// called after we have agreed a media type to actually set it in which case <br>// we run the CheckTransform function to get the output format type again <br> <br>HRESULT <br>CTransformOutputPin::SetMediaType(const CMediaType* pmtOut) <br>{ <br>    HRESULT hr = NOERROR; <br>    ASSERT(m_pTransformFilter-&gt;m_pInput != NULL); <br> <br>    ASSERT(m_pTransformFilter-&gt;m_pInput-&gt;CurrentMediaType().IsValid()); <br> <br>    // Set the base class media type (should always succeed) <br>    hr = CBasePin::SetMediaType(pmtOut); <br>    ASSERT(SUCCEEDED(hr)); <br> <br>#ifdef DEBUG <br>    if (FAILED(m_pTransformFilter-&gt;CheckTransform(&amp;m_pTransformFilter-&gt; <br>m_pInput-&gt;CurrentMediaType(),pmtOut))) { <br>DbgLog((LOG_ERROR,0,TEXT("*** This filter is accepting an output media type"))); <br>DbgLog((LOG_ERROR,0,TEXT("    that it can't currently transform to.  I hope"))); <br>DbgLog((LOG_ERROR,0,TEXT("    it's smart enough to reconnect its input."))); <br>    } <br>#endif <br> <br>    m_pTransformFilter-&gt;SetMediaType(PINDIR_OUTPUT,pmtOut); <br>    return NOERROR; <br>} <br> <br> <br>// pass the buffer size decision through to the main transform class <br> <br>HRESULT <br>CTransformOutputPin::DecideBufferSize( <br>    IMemAllocator * pAllocator, <br>    ALLOCATOR_PROPERTIES* pProp) <br>{ <br>    return m_pTransformFilter-&gt;DecideBufferSize(pAllocator, pProp); <br>} <br> <br> <br> <br>// return a specific media type indexed by iPosition <br> <br>HRESULT <br>CTransformOutputPin::GetMediaType( <br>    int iPosition, <br>    CMediaType *pMediaType) <br>{ <br>    CAutoLock lck(&amp;m_pTransformFilter-&gt;m_csFilter); <br>    ASSERT(m_pTransformFilter-&gt;m_pInput != NULL); <br> <br>    //  We don't have any media types if our input is not connected <br> <br>    if (m_pTransformFilter-&gt;m_pInput-&gt;IsConnected()) { <br>        return m_pTransformFilter-&gt;GetMediaType(iPosition,pMediaType); <br>    } else { <br>        return VFW_S_NO_MORE_ITEMS; <br>    } <br>} <br> <br> <br>// Override this if you can do something constructive to act on the <br>// quality message.  Consider passing it upstream as well <br> <br>// Pass the quality mesage on upstream. <br> <br>STDMETHODIMP <br>CTransformOutputPin::Notify(IBaseFilter * pSender, Quality q) <br>{ <br>    UNREFERENCED_PARAMETER(pSender); <br>    ValidateReadPtr(pSender,sizeof(IBaseFilter)); <br> <br>    // First see if we want to handle this ourselves <br>    HRESULT hr = m_pTransformFilter-&gt;AlterQuality(q); <br>    if (hr!=S_FALSE) { <br>        return hr;        // either S_OK or a failure <br>    } <br> <br>    // S_FALSE means we pass the message on. <br>    // Find the quality sink for our input pin and send it there <br> <br>    ASSERT(m_pTransformFilter-&gt;m_pInput != NULL); <br> <br>    return m_pTransformFilter-&gt;m_pInput-&gt;PassNotify(q); <br> <br>} // Notify <br> <br> <br>// the following removes a very large number of level 4 warnings from the microsoft <br>// compiler output, which are not useful at all in this case. <br>#pragma warning(disable:4514) </code></pre>
<p>&nbsp;</p></body>
</HTML>
