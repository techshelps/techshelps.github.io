<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WXLIST.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2791"></a>WXLIST.CPP</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>// Non MFC based generic list template class, December 1994 <br> <br>/* A generic list of pointers to objects. <br>   Objectives: avoid using MFC libraries in ndm kernel mode and <br>   provide a really useful list type. <br> <br>   The class is thread safe in that separate threads may add and <br>   delete items in the list concurrently although the application <br>   must ensure that constructor and destructor access is suitably <br>   synchronised. <br> <br>   The list name must not conflict with MFC classes as an <br>   application may use both <br> <br>   The nodes form a doubly linked, NULL terminated chain with an anchor <br>   block (the list object per se) holding pointers to the first and last <br>   nodes and a count of the nodes. <br>   There is a node cache to reduce the allocation and freeing overhead. <br>   It optionally (determined at construction time) has an Event which is <br>   set whenever the list becomes non-empty and reset whenever it becomes <br>   empty. <br>   It optionally (determined at construction time) has a Critical Section <br>   which is entered during the important part of each operation.  (About <br>   all you can do outside it is some parameter checking). <br> <br>   The node cache is a repository of nodes that are NOT in the list to speed <br>   up storage allocation.  Each list has its own cache to reduce locking and <br>   serialising.  The list accesses are serialised anyway for a given list - a <br>   common cache would mean that we would have to separately serialise access <br>   of all lists within the cache.  Because the cache only stores nodes that are <br>   not in the list, releasing the cache does not release any list nodes.  This <br>   means that list nodes can be copied or rechained from one list to another <br>   without danger of creating a dangling reference if the original cache goes <br>   away. <br> <br>   Questionable design decisions: <br>   1. Retaining the warts for compatibility <br>   2. Keeping an element count -i.e. counting whenever we do anything <br>      instead of only when we want the count. <br>   3. Making the chain pointers NULL terminated.  If the list object <br>      itself looks just like a node and the list is kept as a ring then <br>      it reduces the number of special cases.  All inserts look the same. <br>*/ <br> <br> <br>#include &lt;streams.h&gt; <br> <br>/* set cursor to the position of each element of list in turn  */ <br>#define INTERNALTRAVERSELIST(list, cursor)               \ <br>for ( cursor = (list).GetHeadPositionI()           \ <br>    ; cursor!=NULL                               \ <br>    ; cursor = (list).Next(cursor)                \ <br>    ) <br> <br> <br>/* set cursor to the position of each element of list in turn <br>   in reverse order <br>*/ <br>#define INTERNALREVERSETRAVERSELIST(list, cursor)        \ <br>for ( cursor = (list).GetTailPositionI()           \ <br>    ; cursor!=NULL                               \ <br>    ; cursor = (list).Prev(cursor)                \ <br>    ) <br> <br>/* Constructor calls a separate initialisation function that <br>   creates a node cache, optionally creates a lock object <br>   and optionally creates a signaling object. <br> <br>   By default we create a locking object, a DEFAULTCACHE sized <br>   cache but no event object so the list cannot be used in calls <br>   to WaitForSingleObject <br>*/ <br>CBaseList::CBaseList(TCHAR *pName,    // Descriptive list name <br>                     INT iItems) :    // Node cache size <br>#ifdef DEBUG <br>    CBaseObject(pName), <br>#endif <br>    m_pFirst(NULL), <br>    m_pLast(NULL), <br>    m_Count(0), <br>    m_Cache(iItems) <br>{ <br>} // constructor <br> <br>CBaseList::CBaseList(TCHAR *pName) :  // Descriptive list name <br>#ifdef DEBUG <br>    CBaseObject(pName), <br>#endif <br>    m_pFirst(NULL), <br>    m_pLast(NULL), <br>    m_Count(0), <br>    m_Cache(DEFAULTCACHE) <br>{ <br>} // constructor <br> <br> <br>/* The destructor enumerates all the node objects in the list and <br>   in the cache deleting each in turn. We do not do any processing <br>   on the objects that the list holds (i.e. points to) so if they <br>   represent interfaces for example the creator of the list should <br>   ensure that each of them is released before deleting us <br>*/ <br>CBaseList::~CBaseList() <br>{ <br>    /* Delete all our list nodes */ <br> <br>    RemoveAll(); <br> <br>} // destructor <br> <br>/* Remove all the nodes from the list but don't do anything <br>   with the objects that each node looks after (this is the <br>   responsibility of the creator). <br>   Aa a last act we reset the signalling event <br>   (if available) to indicate to clients that the list <br>   does not have any entries in it. <br>*/ <br>void CBaseList::RemoveAll() <br>{ <br>    /* Free up all the CNode objects NOTE we don't bother putting the <br>       deleted nodes into the cache as this method is only really called <br>       in serious times of change such as when we are being deleted at <br>       which point the cache will be deleted anway */ <br> <br>    CNode *pn = m_pFirst; <br>    while (pn) { <br>        CNode *op = pn; <br>        pn = pn-&gt;Next(); <br>        delete op; <br>    } <br> <br>    /* Reset the object count and the list pointers */ <br> <br>    m_Count = 0; <br>    m_pFirst = m_pLast = NULL; <br> <br>} // RemoveAll <br> <br> <br> <br>/* Return a position enumerator for the entire list. <br>   A position enumerator is a pointer to a node object cast to a <br>   transparent type so all we do is return the head/tail node <br>   pointer in the list. <br>   WARNING because the position is a pointer to a node there is <br>   an implicit assumption for users a the list class that after <br>   deleting an object from the list that any other position <br>   enumerators that you have may be invalid (since the node <br>   may be gone). <br>*/ <br>POSITION CBaseList::GetHeadPositionI() const <br>{ <br>    return (POSITION) m_pFirst; <br>} // GetHeadPosition <br> <br> <br> <br>POSITION CBaseList::GetTailPositionI() const <br>{ <br>    return (POSITION) m_pLast; <br>} // GetTailPosition <br> <br> <br> <br>/* Get the number of objects in the list, <br>   Get the lock before accessing the count. <br>   Locking may not be entirely necessary but it has the side effect <br>   of making sure that all operations are complete before we get it. <br>   So for example if a list is being added to this list then that <br>   will have completed in full before we continue rather than seeing <br>   an intermediate albeit valid state <br>*/ <br>int CBaseList::GetCountI() const <br>{ <br>    return m_Count; <br>} // GetCount <br> <br> <br> <br>/* Return the object at rp, update rp to the next object from <br>   the list or NULL if you have moved over the last object. <br>   You may still call this function once we return NULL but <br>   we will continue to return a NULL position value <br>*/ <br>void *CBaseList::GetNextI(POSITION&amp; rp) const <br>{ <br>    /* have we reached the end of the list */ <br> <br>    if (rp == NULL) { <br>        return NULL; <br>    } <br> <br>    /* Lock the object before continuing */ <br> <br>    void *pObject; <br> <br>    /* Copy the original position then step on */ <br> <br>    CNode *pn = (CNode *) rp; <br>    ASSERT(pn != NULL); <br>    rp = (POSITION) pn-&gt;Next(); <br> <br>    /* Get the object at the original position from the list */ <br> <br>    pObject = pn-&gt;GetData(); <br>    // ASSERT(pObject != NULL);    // NULL pointers in the list are allowed. <br>    return pObject; <br>} //GetNext <br> <br> <br> <br>/* Return the object at p. <br>   Asking for the object at NULL ASSERTs then returns NULL <br>   The object is NOT locked.  The list is not being changed <br>   in any way.  If another thread is busy deleting the object <br>   then locking would only result in a change from one bad <br>   behaviour to another. <br>*/ <br>void *CBaseList::GetI(POSITION p) const <br>{ <br>    if (p == NULL) { <br>        return NULL; <br>    } <br> <br>    CNode * pn = (CNode *) p; <br>    void *pObject = pn-&gt;GetData(); <br>    // ASSERT(pObject != NULL);    // NULL pointers in the list are allowed. <br>    return pObject; <br>} //Get <br> <br> <br> <br>/* Return the first position in the list which holds the given pointer. <br>   Return NULL if it's not found. <br>*/ <br>POSITION CBaseList::FindI( void * pObj) const <br>{ <br>    POSITION pn; <br>    INTERNALTRAVERSELIST(*this, pn){ <br>        if (GetI(pn)==pObj) { <br>            return pn; <br>        } <br>    } <br>    return NULL; <br>} // Find <br> <br> <br> <br>/* Remove the first node in the list (deletes the pointer to its object <br>   from the list, does not free the object itself). <br>   Return the pointer to its object or NULL if empty <br>*/ <br>void *CBaseList::RemoveHeadI() <br>{ <br>    /* All we do is get the head position and ask for that to be deleted. <br>       We could special case this since some of the code path checking <br>       in Remove() is redundant as we know there is no previous <br>       node for example but it seems to gain little over the <br>       added complexity <br>    */ <br> <br>    return RemoveI((POSITION)m_pFirst); <br>} // RemoveHead <br> <br> <br> <br>/* Remove the last node in the list (deletes the pointer to its object <br>   from the list, does not free the object itself). <br>   Return the pointer to its object or NULL if empty <br>*/ <br>void *CBaseList::RemoveTailI() <br>{ <br>    /* All we do is get the tail position and ask for that to be deleted. <br>       We could special case this since some of the code path checking <br>       in Remove() is redundant as we know there is no previous <br>       node for example but it seems to gain little over the <br>       added complexity <br>    */ <br> <br>    return RemoveI((POSITION)m_pLast); <br>} // RemoveTail <br> <br> <br> <br>/* Remove the pointer to the object in this position from the list. <br>   Deal with all the chain pointers <br>   Return a pointer to the object removed from the list. <br>   The node object that is freed as a result <br>   of this operation is added to the node cache where <br>   it can be used again. <br>   Remove(NULL) is a harmless no-op - but probably is a wart. <br>*/ <br>void *CBaseList::RemoveI(POSITION pos) <br>{ <br>    /* Lock the critical section before continuing */ <br> <br>    // ASSERT (pos!=NULL);     // Removing NULL is to be harmless! <br>    if (pos==NULL) return NULL; <br> <br> <br>    CNode *pCurrent = (CNode *) pos; <br>    ASSERT(pCurrent != NULL); <br> <br>    /* Update the previous node */ <br> <br>    CNode *pNode = pCurrent-&gt;Prev(); <br>    if (pNode == NULL) { <br>        m_pFirst = pCurrent-&gt;Next(); <br>    } else { <br>        pNode-&gt;SetNext(pCurrent-&gt;Next()); <br>    } <br> <br>    /* Update the following node */ <br> <br>    pNode = pCurrent-&gt;Next(); <br>    if (pNode == NULL) { <br>        m_pLast = pCurrent-&gt;Prev(); <br>    } else { <br>        pNode-&gt;SetPrev(pCurrent-&gt;Prev()); <br>    } <br> <br>    /* Get the object this node was looking after */ <br> <br>    void *pObject = pCurrent-&gt;GetData(); <br> <br>    // ASSERT(pObject != NULL);    // NULL pointers in the list are allowed. <br> <br>    /* Try and add the node object to the cache - <br>       a NULL return code from the cache means we ran out of room. <br>       The cache size is fixed by a constructor argument when the <br>       list is created and defaults to DEFAULTCACHE. <br>       This means that the cache will have room for this many <br>       node objects. So if you have a list of media samples <br>       and you know there will never be more than five active at <br>       any given time of them for example then override the default <br>       constructor <br>    */ <br> <br>    m_Cache.AddToCache(pCurrent); <br> <br>    /* If the list is empty then reset the list event */ <br> <br>    --m_Count; <br>    ASSERT(m_Count &gt;= 0); <br>    return pObject; <br>} // Remove <br> <br> <br> <br>/* Add this object to the tail end of our list <br>   Return the new tail position. <br>*/ <br> <br>POSITION CBaseList::AddTailI(void *pObject) <br>{ <br>    /* Lock the critical section before continuing */ <br> <br>    CNode *pNode; <br>    // ASSERT(pObject);   // NULL pointers in the list are allowed. <br> <br>    /* If there is a node objects in the cache then use <br>       that otherwise we will have to create a new one */ <br> <br>    pNode = (CNode *) m_Cache.RemoveFromCache(); <br>    if (pNode == NULL) { <br>        pNode = new CNode; <br>    } <br> <br>    /* Check we have a valid object */ <br> <br>    ASSERT(pNode != NULL); <br>    if (pNode == NULL) { <br>        return NULL; <br>    } <br> <br>    /* Initialise all the CNode object <br>       just in case it came from the cache <br>    */ <br> <br>    pNode-&gt;SetData(pObject); <br>    pNode-&gt;SetNext(NULL); <br>    pNode-&gt;SetPrev(m_pLast); <br> <br>    if (m_pLast == NULL) { <br>        m_pFirst = pNode; <br>    } else { <br>        m_pLast-&gt;SetNext(pNode); <br>    } <br> <br>    /* Set the new last node pointer and also increment the number <br>       of list entries, the critical section is unlocked when we <br>       exit the function <br>    */ <br> <br>    m_pLast = pNode; <br>    ++m_Count; <br> <br>    return (POSITION) pNode; <br>} // AddTail(object) <br> <br> <br> <br>/* Add this object to the head end of our list <br>   Return the new head position. <br>*/ <br>POSITION CBaseList::AddHeadI(void *pObject) <br>{ <br>    CNode *pNode; <br>    // ASSERT(pObject);  // NULL pointers in the list are allowed. <br> <br>    /* If there is a node objects in the cache then use <br>       that otherwise we will have to create a new one */ <br> <br>    pNode = (CNode *) m_Cache.RemoveFromCache(); <br>    if (pNode == NULL) { <br>        pNode = new CNode; <br>    } <br> <br>    /* Check we have a valid object */ <br> <br>    ASSERT(pNode != NULL); <br>    if (pNode == NULL) { <br>        return NULL; <br>    } <br> <br>    /* Initialise all the CNode object <br>       just in case it came from the cache <br>    */ <br> <br>    pNode-&gt;SetData(pObject); <br> <br>    /* chain it in (set four pointers) */ <br>    pNode-&gt;SetPrev(NULL); <br>    pNode-&gt;SetNext(m_pFirst); <br> <br>    if (m_pFirst == NULL) { <br>        m_pLast = pNode; <br>    } else { <br>        m_pFirst-&gt;SetPrev(pNode); <br>    } <br>    m_pFirst = pNode; <br> <br>    ++m_Count; <br> <br>    return (POSITION) pNode; <br>} // AddHead(object) <br> <br> <br> <br>/* Add all the elements in *pList to the tail of this list. <br>   Return TRUE if it all worked, FALSE if it didn't. <br>   If it fails some elements may have been added. <br>*/ <br>BOOL CBaseList::AddTail(CBaseList *pList) <br>{ <br>    /* lock the object before starting then enumerate <br>       each entry in the source list and add them one by one to <br>       our list (while still holding the object lock) <br>       Lock the other list too. <br>    */ <br>    POSITION pos = pList-&gt;GetHeadPositionI(); <br> <br>    while (pos) { <br>       if (NULL == AddTailI(pList-&gt;GetNextI(pos))) { <br>           return FALSE; <br>       } <br>    } <br>    return TRUE; <br>} // AddTail(list) <br> <br> <br> <br>/* Add all the elements in *pList to the head of this list. <br>   Return TRUE if it all worked, FALSE if it didn't. <br>   If it fails some elements may have been added. <br>*/ <br>BOOL CBaseList::AddHead(CBaseList *pList) <br>{ <br>    /* lock the object before starting then enumerate <br>       each entry in the source list and add them one by one to <br>       our list (while still holding the object lock) <br>       Lock the other list too. <br> <br>       To avoid reversing the list, traverse it backwards. <br>    */ <br> <br>    POSITION pos; <br> <br>    INTERNALREVERSETRAVERSELIST(*pList, pos) { <br>        if (NULL== AddHeadI(pList-&gt;GetI(pos))){ <br>            return FALSE; <br>        } <br>    } <br>    return TRUE; <br>} // AddHead(list) <br> <br> <br> <br>/* Add the object after position p <br>   p is still valid after the operation. <br>   AddAfter(NULL,x) adds x to the start - same as AddHead <br>   Return the position of the new object, NULL if it failed <br>*/ <br>POSITION  CBaseList::AddAfterI(POSITION pos, void * pObj) <br>{ <br>    if (pos==NULL) <br>        return AddHeadI(pObj); <br> <br>    /* As someone else might be furkling with the list - <br>       Lock the critical section before continuing <br>    */ <br>    CNode *pAfter = (CNode *) pos; <br>    ASSERT(pAfter != NULL); <br>    if (pAfter==m_pLast) <br>        return AddTailI(pObj); <br> <br>    /* set pnode to point to a new node, preferably from the cache */ <br> <br>    CNode *pNode = (CNode *) m_Cache.RemoveFromCache(); <br>    if (pNode == NULL) { <br>        pNode = new CNode; <br>    } <br> <br>    /* Check we have a valid object */ <br> <br>    ASSERT(pNode != NULL); <br>    if (pNode == NULL) { <br>        return NULL; <br>    } <br> <br>    /* Initialise all the CNode object <br>       just in case it came from the cache <br>    */ <br> <br>    pNode-&gt;SetData(pObj); <br> <br>    /* It is to be added to the middle of the list - there is a before <br>       and after node.  Chain it after pAfter, before pBefore. <br>    */ <br>    CNode * pBefore = pAfter-&gt;Next(); <br>    ASSERT(pBefore != NULL); <br> <br>    /* chain it in (set four pointers) */ <br>    pNode-&gt;SetPrev(pAfter); <br>    pNode-&gt;SetNext(pBefore); <br>    pBefore-&gt;SetPrev(pNode); <br>    pAfter-&gt;SetNext(pNode); <br> <br>    ++m_Count; <br> <br>    return (POSITION) pNode; <br> <br>} // AddAfter(object) <br> <br> <br> <br>BOOL CBaseList::AddAfter(POSITION p, CBaseList *pList) <br>{ <br>    POSITION pos; <br>    INTERNALTRAVERSELIST(*pList, pos) { <br>        /* p follows along the elements being added */ <br>        p = AddAfterI(p, pList-&gt;GetI(pos)); <br>        if (p==NULL) return FALSE; <br>    } <br>    return TRUE; <br>} // AddAfter(list) <br> <br> <br> <br>/* Mirror images: <br>   Add the element or list after position p. <br>   p is still valid after the operation. <br>   AddBefore(NULL,x) adds x to the end - same as AddTail <br>*/ <br>POSITION CBaseList::AddBeforeI(POSITION pos, void * pObj) <br>{ <br>    if (pos==NULL) <br>        return AddTailI(pObj); <br> <br>    /* set pnode to point to a new node, preferably from the cache */ <br> <br>    CNode *pBefore = (CNode *) pos; <br>    ASSERT(pBefore != NULL); <br>    if (pBefore==m_pFirst) <br>        return AddHeadI(pObj); <br> <br>    CNode * pNode = (CNode *) m_Cache.RemoveFromCache(); <br>    if (pNode == NULL) { <br>        pNode = new CNode; <br>    } <br> <br>    /* Check we have a valid object */ <br> <br>    ASSERT(pNode != NULL); <br>    if (pNode == NULL) { <br>        return NULL; <br>    } <br> <br>    /* Initialise all the CNode object <br>       just in case it came from the cache <br>    */ <br> <br>    pNode-&gt;SetData(pObj); <br> <br>    /* It is to be added to the middle of the list - there is a before <br>       and after node.  Chain it after pAfter, before pBefore. <br>    */ <br> <br>    CNode * pAfter = pBefore-&gt;Prev(); <br>    ASSERT(pAfter != NULL); <br> <br>    /* chain it in (set four pointers) */ <br>    pNode-&gt;SetPrev(pAfter); <br>    pNode-&gt;SetNext(pBefore); <br>    pBefore-&gt;SetPrev(pNode); <br>    pAfter-&gt;SetNext(pNode); <br> <br>    ++m_Count; <br> <br>    return (POSITION) pNode; <br> <br>} // Addbefore(object) <br> <br> <br> <br>BOOL CBaseList::AddBefore(POSITION p, CBaseList *pList) <br>{ <br>    POSITION pos; <br>    INTERNALREVERSETRAVERSELIST(*pList, pos) { <br>        /* p follows along the elements being added */ <br>        p = AddBeforeI(p, pList-&gt;GetI(pos)); <br>        if (p==NULL) return FALSE; <br>    } <br>    return TRUE; <br>} // AddBefore(list) <br> <br> <br> <br>/* Split *this after position p in *this <br>   Retain as *this the tail portion of the original *this <br>   Add the head portion to the tail end of *pList <br>   Return TRUE if it all worked, FALSE if it didn't. <br> <br>   e.g. <br>      foo-&gt;MoveToTail(foo-&gt;GetHeadPosition(), bar); <br>          moves one element from the head of foo to the tail of bar <br>      foo-&gt;MoveToTail(NULL, bar); <br>          is a no-op <br>      foo-&gt;MoveToTail(foo-&gt;GetTailPosition, bar); <br>          concatenates foo onto the end of bar and empties foo. <br> <br>   A better, except excessively long name might be <br>       MoveElementsFromHeadThroughPositionToOtherTail <br>*/ <br>BOOL CBaseList::MoveToTail <br>        (POSITION pos, CBaseList *pList) <br>{ <br>    /* Algorithm: <br>       Note that the elements (including their order) in the concatenation <br>       of *pList to the head of *this is invariant. <br>       1. Count elements to be moved <br>       2. Join *pList onto the head of this to make one long chain <br>       3. Set first/Last pointers in *this and *pList <br>       4. Break the chain at the new place <br>       5. Adjust counts <br>       6. Set/Reset any events <br>    */ <br> <br>    if (pos==NULL) return TRUE;  // no-op.  Eliminates special cases later. <br> <br> <br>    /* Make cMove the number of nodes to move */ <br>    CNode * p = (CNode *)pos; <br>    int cMove = 0;            // number of nodes to move <br>    while(p!=NULL) { <br>       p = p-&gt;Prev(); <br>       ++cMove; <br>    } <br> <br> <br>    /* Join the two chains together */ <br>    if (pList-&gt;m_pLast!=NULL) <br>        pList-&gt;m_pLast-&gt;SetNext(m_pFirst); <br>    if (m_pFirst!=NULL) <br>        m_pFirst-&gt;SetPrev(pList-&gt;m_pLast); <br> <br> <br>    /* set first and last pointers */ <br>    p = (CNode *)pos; <br> <br>    if (pList-&gt;m_pFirst==NULL) <br>        pList-&gt;m_pFirst = m_pFirst; <br>    m_pFirst = p-&gt;Next(); <br>    if (m_pFirst==NULL) <br>        m_pLast = NULL; <br>    pList-&gt;m_pLast = p; <br> <br> <br>    /* Break the chain after p to create the new pieces */ <br>    if (m_pFirst!=NULL) <br>        m_pFirst-&gt;SetPrev(NULL); <br>    p-&gt;SetNext(NULL); <br> <br> <br>    /* Adjust the counts */ <br>    m_Count -= cMove; <br>    pList-&gt;m_Count += cMove; <br> <br>    return TRUE; <br> <br>} // MoveToTail <br> <br> <br> <br>/* Mirror image of MoveToTail: <br>   Split *this before position p in *this. <br>   Retain in *this the head portion of the original *this <br>   Add the tail portion to the start (i.e. head) of *pList <br>   Return TRUE if it all worked, FALSE if it didn't. <br> <br>   e.g. <br>      foo-&gt;MoveToHead(foo-&gt;GetTailPosition(), bar); <br>          moves one element from the tail of foo to the head of bar <br>      foo-&gt;MoveToHead(NULL, bar); <br>          is a no-op <br>      foo-&gt;MoveToHead(foo-&gt;GetHeadPosition, bar); <br>          concatenates foo onto the start of bar and empties foo. <br>*/ <br>BOOL CBaseList::MoveToHead <br>        (POSITION pos, CBaseList *pList) <br>{ <br> <br>    /* See the comments on the algorithm in MoveToTail */ <br> <br>    if (pos==NULL) return TRUE;  // no-op.  Eliminates special cases later. <br> <br>    /* Make cMove the number of nodes to move */ <br>    CNode * p = (CNode *)pos; <br>    int cMove = 0;            // number of nodes to move <br>    while(p!=NULL) { <br>       p = p-&gt;Next(); <br>       ++cMove; <br>    } <br> <br> <br>    /* Join the two chains together */ <br>    if (pList-&gt;m_pFirst!=NULL) <br>        pList-&gt;m_pFirst-&gt;SetPrev(m_pLast); <br>    if (m_pLast!=NULL) <br>        m_pLast-&gt;SetNext(pList-&gt;m_pFirst); <br> <br> <br>    /* set first and last pointers */ <br>    p = (CNode *)pos; <br> <br> <br>    if (pList-&gt;m_pLast==NULL) <br>        pList-&gt;m_pLast = m_pLast; <br> <br>    m_pLast = p-&gt;Prev(); <br>    if (m_pLast==NULL) <br>        m_pFirst = NULL; <br>    pList-&gt;m_pFirst = p; <br> <br> <br>    /* Break the chain after p to create the new pieces */ <br>    if (m_pLast!=NULL) <br>        m_pLast-&gt;SetNext(NULL); <br>    p-&gt;SetPrev(NULL); <br> <br> <br>    /* Adjust the counts */ <br>    m_Count -= cMove; <br>    pList-&gt;m_Count += cMove; <br> <br>    return TRUE; <br> <br>} // MoveToHead <br> <br> <br> <br>/* Reverse the order of the [pointers to] objects in *this <br>*/ <br>void CBaseList::Reverse() <br>{ <br>    /* algorithm: <br>       The obvious booby trap is that you flip pointers around and lose <br>       addressability to the node that you are going to process next. <br>       The easy way to avoid this is do do one chain at a time. <br> <br>       Run along the forward chain, <br>       For each node, set the reverse pointer to the one ahead of us. <br>       The reverse chain is now a copy of the old forward chain, including <br>       the NULL termination. <br> <br>       Run along the reverse chain (i.e. old forward chain again) <br>       For each node set the forward pointer of the node ahead to point back <br>       to the one we're standing on. <br>       The first node needs special treatment, <br>       it's new forward pointer is NULL. <br>       Finally set the First/Last pointers <br> <br>    */ <br>    CNode * p; <br> <br>    // Yes we COULD use a traverse, but it would look funny! <br>    p = m_pFirst; <br>    while (p!=NULL) { <br>        CNode * q; <br>        q = p-&gt;Next(); <br>        p-&gt;SetNext(p-&gt;Prev()); <br>        p-&gt;SetPrev(q); <br>        p = q; <br>    } <br> <br>    p = m_pFirst; <br>    m_pFirst = m_pLast; <br>    m_pLast = p; <br> <br> <br>#if 0     // old version <br> <br>    if (m_pFirst==NULL) return;          // empty list <br>    if (m_pFirst-&gt;Next()==NULL) return;  // single node list <br> <br> <br>    /* run along forward chain */ <br>    for ( p = m_pFirst <br>        ; p!=NULL <br>        ; p = p-&gt;Next() <br>        ){ <br>        p-&gt;SetPrev(p-&gt;Next()); <br>    } <br> <br> <br>    /* special case first element */ <br>    m_pFirst-&gt;SetNext(NULL);     // fix the old first element <br> <br> <br>    /* run along new reverse chain i.e. old forward chain again */ <br>    for ( p = m_pFirst           // start at the old first element <br>        ; p-&gt;Prev()!=NULL        // while there's a node still to be set <br>        ; p = p-&gt;Prev()          // work in the same direction as before <br>        ){ <br>        p-&gt;Prev()-&gt;SetNext(p); <br>    } <br> <br> <br>    /* fix forward and reverse pointers <br>       - the triple XOR swap would work but all the casts look hideous */ <br>    p = m_pFirst; <br>    m_pFirst = m_pLast; <br>    m_pLast = p; <br>#endif <br> <br>} // Reverse </code></pre>
<p>&nbsp;</p></body>
</HTML>
