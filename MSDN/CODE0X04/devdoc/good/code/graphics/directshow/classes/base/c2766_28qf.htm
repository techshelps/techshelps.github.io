<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WINUTIL.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2787"></a>WINUTIL.CPP</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>// Generic window handler base class, December 1995 <br> <br>#include &lt;streams.h&gt; <br>#include &lt;limits.h&gt; <br> <br>static UINT MsgDestroy; <br> <br>// Constructor <br> <br>CBaseWindow::CBaseWindow(BOOL bDoGetDC) : <br>    m_hInstance(g_hInst), <br>    m_hwnd(NULL), <br>    m_hdc(NULL), <br>    m_bActivated(FALSE), <br>    m_pClassName(NULL), <br>    m_ClassStyles(0), <br>    m_WindowStyles(0), <br>    m_WindowStylesEx(0), <br>    m_ShowStageMessage(0), <br>    m_ShowStageTop(0), <br>    m_MemoryDC(NULL), <br>    m_hPalette(NULL), <br>    m_bBackground(FALSE), <br>#ifdef DEBUG <br>    m_bRealizing(FALSE), <br>#endif <br>    m_bNoRealize(FALSE) <br>{ <br>    m_bDoGetDC = bDoGetDC; <br>} <br> <br> <br>// Prepare a window by spinning off a worker thread to do the creation and <br>// also poll the message input queue. We leave this to be called by derived <br>// classes because they might want to override methods like MessageLoop and <br>// InitialiseWindow, if we do this during construction they'll ALWAYS call <br>// this base class methods. We make the worker thread create the window so <br>// it owns it rather than the filter graph thread which is constructing us <br> <br>HRESULT CBaseWindow::PrepareWindow() <br>{ <br>    if (m_hwnd) return NOERROR; <br>    ASSERT(m_hwnd == NULL); <br>    ASSERT(m_hdc == NULL); <br> <br>    // Get the derived object's window and class styles <br> <br>    m_pClassName = GetClassWindowStyles(&amp;m_ClassStyles, <br>                                        &amp;m_WindowStyles, <br>                                        &amp;m_WindowStylesEx); <br>    if (m_pClassName == NULL) { <br>        return E_FAIL; <br>    } <br> <br>    // Register our special private messages <br>    m_ShowStageMessage = RegisterWindowMessage(SHOWSTAGE); <br>    m_ShowStageTop = RegisterWindowMessage(SHOWSTAGETOP); <br>    m_RealizePalette = RegisterWindowMessage(REALIZEPALETTE); <br> <br>    return DoCreateWindow(); <br>} <br> <br> <br>// Destructor just a placeholder so that we know it becomes virtual <br>// Derived classes MUST call DoneWithWindow in their destructors so <br>// that no messages arrive after the derived class constructor ends <br> <br>#ifdef DEBUG <br>CBaseWindow::~CBaseWindow() <br>{ <br>    ASSERT(m_hwnd == NULL); <br>    ASSERT(m_hdc == NULL); <br>} <br>#endif <br> <br> <br>// We use the sync worker event to have the window destroyed. All we do is <br>// signal the event and wait on the window thread handle. Trying to send it <br>// messages causes too many problems, furthermore to be on the safe side we <br>// just wait on the thread handle while it returns WAIT_TIMEOUT or there is <br>// a sent message to process on this thread. If the constructor failed to <br>// create the thread in the first place then the loop will get terminated <br> <br>HRESULT CBaseWindow::DoneWithWindow() <br>{ <br>    if (GetWindowThreadProcessId(m_hwnd, NULL) != GetCurrentThreadId()) { <br>        MsgDestroy = RegisterWindowMessage(TEXT("AM_DESTROY")); <br>        SendMessage(m_hwnd, MsgDestroy, 0, 0); <br>        return NOERROR; <br>    } <br>    const HWND hwnd = m_hwnd; <br>    if (hwnd == NULL) { <br>        return NOERROR; <br>    } <br> <br>    InactivateWindow(); <br>    NOTE("Inactivated"); <br> <br>    // Reset the window styles before destruction <br> <br>    SetWindowLong(hwnd,GWL_STYLE,m_WindowStyles); <br>    ASSERT(GetParent(hwnd) == NULL); <br>    NOTE1("Reset window styles %d",m_WindowStyles); <br> <br>    //  UnintialiseWindow sets m_hwnd to NULL so save a copy <br>    UninitialiseWindow(); <br>    DbgLog((LOG_TRACE, 2, TEXT("Destroying 0x%8.8X"), hwnd)); <br>    if (!DestroyWindow(hwnd)) { <br>        DbgLog((LOG_TRACE, 0, TEXT("DestroyWindow %8.8X failed code %d"), <br>                hwnd, GetLastError())); <br>        DbgBreak(""); <br>    } <br> <br>    // Reset our state so we can be prepared again <br> <br>    m_pClassName = NULL; <br>    m_ClassStyles = 0; <br>    m_WindowStyles = 0; <br>    m_WindowStylesEx = 0; <br>    m_ShowStageMessage = 0; <br>    m_ShowStageTop = 0; <br> <br>    return NOERROR; <br>} <br> <br> <br>// Called at the end to put the window in an inactive state. The pending list <br>// will always have been cleared by this time so event if the worker thread <br>// gets has been signaled and gets in to render something it will find both <br>// the state has been changed and that there are no available sample images <br>// Since we wait on the window thread to complete we don't lock the object <br> <br>HRESULT CBaseWindow::InactivateWindow() <br>{ <br>    // Has the window been activated <br>    if (m_bActivated == FALSE) { <br>        return S_FALSE; <br>    } <br> <br>    m_bActivated = FALSE; <br>    ShowWindow(m_hwnd,SW_HIDE); <br>    return NOERROR; <br>} <br> <br> <br>// This displays a normal window. We ask the base window class for default <br>// sizes which unless overriden will return DEFWIDTH and DEFHEIGHT. We go <br>// through a couple of extra hoops to get the client area the right size <br>// as the object specifies which accounts for the AdjustWindowRectEx calls <br>// We also DWORD align the left and top coordinates of the window here to <br>// maximise the chance of being able to use DCI/DirectDraw primary surface <br> <br>HRESULT CBaseWindow::ActivateWindow() <br>{ <br>    // Has the window been sized and positioned already <br> <br>    if (m_bActivated == TRUE || GetParent(m_hwnd) != NULL) { <br> <br>        SetWindowPos(m_hwnd,            // Our window handle <br>                     HWND_TOP,          // Put it at the top <br>                     0, 0, 0, 0,        // Leave in current position <br>                     SWP_NOMOVE |       // Don't change it's place <br>                     SWP_NOSIZE);       // Change Z-order only <br> <br>        return S_FALSE; <br>    } <br> <br>    // Calculate the desired client rectangle <br> <br>    RECT WindowRect, ClientRect = GetDefaultRect(); <br>    GetWindowRect(m_hwnd,&amp;WindowRect); <br>    AdjustWindowRectEx(&amp;ClientRect,GetWindowLong(m_hwnd,GWL_STYLE), <br>                       FALSE,GetWindowLong(m_hwnd,GWL_EXSTYLE)); <br> <br>    // Align left and top edges on DWORD boundaries <br> <br>    UINT WindowFlags = (SWP_NOACTIVATE | SWP_FRAMECHANGED); <br>    WindowRect.left -= (WindowRect.left &amp; 3); <br>    WindowRect.top -= (WindowRect.top &amp; 3); <br> <br>    SetWindowPos(m_hwnd,                // Window handle <br>                 HWND_TOP,              // Put it at the top <br>                 WindowRect.left,       // Align left edge <br>                 WindowRect.top,        // And also top place <br>                 WIDTH(&amp;ClientRect),    // Horizontal size <br>                 HEIGHT(&amp;ClientRect),   // Vertical size <br>                 WindowFlags);          // Don't show window <br> <br>    m_bActivated = TRUE; <br>    return NOERROR; <br>} <br> <br> <br>// This can be used to DWORD align the window for maximum performance <br> <br>HRESULT CBaseWindow::PerformanceAlignWindow() <br>{ <br>    RECT ClientRect,WindowRect; <br>    GetWindowRect(m_hwnd,&amp;WindowRect); <br>    ASSERT(m_bActivated == TRUE); <br> <br>    // Don't do this if we're owned <br> <br>    if (GetParent(m_hwnd)) { <br>        return NOERROR; <br>    } <br> <br>    // Align left and top edges on DWORD boundaries <br> <br>    GetClientRect(m_hwnd, &amp;ClientRect); <br>    MapWindowPoints(m_hwnd, HWND_DESKTOP, (LPPOINT) &amp;ClientRect, 2); <br>    WindowRect.left -= (ClientRect.left &amp; 3); <br>    WindowRect.top  -= (ClientRect.top  &amp; 3); <br>    UINT WindowFlags = (SWP_NOACTIVATE | SWP_NOSIZE); <br> <br>    SetWindowPos(m_hwnd,                // Window handle <br>                 HWND_TOP,              // Put it at the top <br>                 WindowRect.left,       // Align left edge <br>                 WindowRect.top,        // And also top place <br>                 (int) 0,(int) 0,       // Ignore these sizes <br>                 WindowFlags);          // Don't show window <br> <br>    return NOERROR; <br>} <br> <br> <br>// Install a palette into the base window - we may be called by a different <br>// thread to the one that owns the window. We have to be careful how we do <br>// the palette realisation as we could be a different thread to the window <br>// which would cause an inter thread send message. Therefore we realise the <br>// palette by sending it a special message but without the window locked <br> <br>HRESULT CBaseWindow::SetPalette(HPALETTE hPalette) <br>{ <br>    // We must own the window lock during the change <br>    { <br>        CAutoLock cWindowLock(&amp;m_WindowLock); <br>        ASSERT(hPalette); <br>        m_hPalette = hPalette; <br>    } <br>    return SetPalette(); <br>} <br> <br>HRESULT CBaseWindow::SetPalette() <br>{ <br>    if (!m_bNoRealize) { <br>        SendMessage(m_hwnd, m_RealizePalette, 0, 0); <br>        // Make sure the device's palette is flushed <br>        return (GdiFlush() == FALSE ? S_FALSE : S_OK); <br>    } else { <br>        // Just select the palette <br>        ASSERT(m_hdc); <br>        ASSERT(m_MemoryDC); <br>        SelectPalette(m_hdc,m_hPalette,m_bBackground); <br>        SelectPalette(m_MemoryDC,m_hPalette,m_bBackground); <br>        return S_OK; <br>    } <br>} <br> <br>// Realise our palettes in the window and device contexts <br> <br>HRESULT CBaseWindow::DoRealisePalette(BOOL bForceBackground) <br>{ <br>    //  If we grab a critical section here we can deadlock <br>    //  with the window thread because one of the side effects <br>    //  of RealizePalette is to send a WM_PALETTECHANGED message <br>    //  to every window in the system.  In our handling <br>    //  of WM_PALETTECHANGED we used to grab this CS too. <br>    //  The really bad case is when our renderer calls DoRealisePalette() <br>    //  while we're in the middle of processing a palette change <br>    //  for another window. <br>    //  So don't hold the critical section while actually realising <br>    //  the palette.  In any case USER is meant to manage palette <br>    //  handling - we shouldn't have to serialize everything as well <br>    if (m_hPalette == NULL) { <br> <br>        return NOERROR; <br>    } <br> <br>    // Realize the palette on the window thread <br>    ASSERT(m_hdc); <br>    ASSERT(m_MemoryDC); <br>    SelectPalette(m_hdc,m_hPalette,m_bBackground || bForceBackground); <br>    EXECUTE_ASSERT(RealizePalette(m_hdc) != GDI_ERROR); <br>    SelectPalette(m_MemoryDC,m_hPalette,m_bBackground); <br>    EXECUTE_ASSERT(RealizePalette(m_MemoryDC) != GDI_ERROR); <br> <br>    return (GdiFlush() == FALSE ? S_FALSE : S_OK); <br>} <br> <br> <br>// This is the global window procedure <br> <br>LRESULT CALLBACK WndProc(HWND hwnd,         // Window handle <br>                         UINT uMsg,         // Message ID <br>                         WPARAM wParam,     // First parameter <br>                         LPARAM lParam)     // Other parameter <br>{ <br> <br>    // Get the window long that holds our window object pointer <br>    // If it is NULL then we are initialising the window in which <br>    // case the object pointer has been passed in the window creation <br>    // structure.  IF we get any messages before WM_NCCREATE we will <br>    // pass them to DefWindowProc. <br> <br>    CBaseWindow *pBaseWindow = (CBaseWindow *)GetWindowLong(hwnd,0); <br>    if (pBaseWindow == NULL) { <br> <br>// Get the structure pointer from the create struct. <br>// We can only do this for WM_NCCREATE which should be one of <br>// the first messages we receive.  Anything before this will <br>// have to be passed to DefWindowProc (i.e. WM_GETMINMAXINFO) <br> <br>// If the message is WM_NCCREATE we set our pBaseWindow pointer <br>// and will then place it in the window structure <br> <br>if ((uMsg != WM_NCCREATE) <br>    || (NULL == (pBaseWindow = *(CBaseWindow**) ((LPCREATESTRUCT)lParam)-&gt;lpCreateParams))) <br>{ <br>    return(DefWindowProc(hwnd, uMsg, wParam, lParam)); <br>} <br> <br>        // Set the window LONG to be the object who created us <br>#ifdef DEBUG <br>SetLastError(0);  // because of the way SetWindowLong works <br>#endif <br>        BOOL rc = SetWindowLong(hwnd, (DWORD) 0, (LONG) pBaseWindow); <br>#ifdef DEBUG <br>if (0 == rc) { <br>    // SetWindowLong MIGHT have failed.  (Read the docs which admit <br>    // that it is awkward to work out if you have had an error.) <br>    LONG lasterror = GetLastError(); <br>    ASSERT(0 == lasterror); <br>    // If this is not the case we have not set the pBaseWindow pointer <br>    // into the window structure and we will blow up. <br>} <br>#endif <br> <br>    } <br>    // See if this is the packet of death <br>    if (uMsg == MsgDestroy &amp;&amp; uMsg != 0) { <br>        pBaseWindow-&gt;DoneWithWindow(); <br>        return 0; <br>    } <br>    return pBaseWindow-&gt;OnReceiveMessage(hwnd,uMsg,wParam,lParam); <br>} <br> <br> <br>// When the window size changes we adjust our member variables that <br>// contain the dimensions of the client rectangle for our window so <br>// that we come to render an image we will know whether to stretch <br> <br>BOOL CBaseWindow::OnSize(LONG Width, LONG Height) <br>{ <br>    m_Width = Width; <br>    m_Height = Height; <br>    return TRUE; <br>} <br> <br> <br>// This function handles the WM_CLOSE message <br> <br>BOOL CBaseWindow::OnClose() <br>{ <br>    ShowWindow(m_hwnd,SW_HIDE); <br>    return TRUE; <br>} <br> <br> <br>// This is called by the worker window thread when it receives a terminate <br>// message from the window object destructor to delete all the resources we <br>// allocated during initialisation. By the time the worker thread exits all <br>// processing will have been completed as the source filter disconnection <br>// flushes the image pending sample, therefore the GdiFlush should succeed <br> <br>HRESULT CBaseWindow::UninitialiseWindow() <br>{ <br>    // Have we already cleaned up <br> <br>    if (m_hwnd == NULL) { <br>        ASSERT(m_hdc == NULL); <br>        ASSERT(m_MemoryDC == NULL); <br>        return NOERROR; <br>    } <br> <br>    // Release the window resources <br> <br>    EXECUTE_ASSERT(GdiFlush()); <br> <br>    if (m_hdc) <br>    { <br>        EXECUTE_ASSERT(ReleaseDC(m_hwnd,m_hdc)); <br>        m_hdc = NULL; <br>    } <br> <br>    if (m_MemoryDC) <br>    { <br>        EXECUTE_ASSERT(DeleteDC(m_MemoryDC)); <br>        m_MemoryDC = NULL; <br>    } <br> <br>    // Reset the window variables <br>    m_hwnd = NULL; <br> <br>    return NOERROR; <br>} <br> <br> <br>// This is called by the worker window thread after it has created the main <br>// window and it wants to initialise the rest of the owner objects window <br>// variables such as the device contexts. We execute this function with the <br>// critical section still locked. Nothing in this function must generate any <br>// SendMessage calls to the window because this is executing on the window <br>// thread so the message will never be processed and we will deadlock <br> <br>HRESULT CBaseWindow::InitialiseWindow(HWND hwnd) <br>{ <br>    // Initialise the window variables <br> <br>    ASSERT(IsWindow(hwnd)); <br>    m_hwnd = hwnd; <br> <br>    if (m_bDoGetDC) <br>    { <br>        EXECUTE_ASSERT(m_hdc = GetDC(hwnd)); <br>        EXECUTE_ASSERT(m_MemoryDC = CreateCompatibleDC(m_hdc)); <br> <br>        EXECUTE_ASSERT(SetStretchBltMode(m_hdc,COLORONCOLOR)); <br>        EXECUTE_ASSERT(SetStretchBltMode(m_MemoryDC,COLORONCOLOR)); <br>    } <br> <br>    return NOERROR; <br>} <br> <br>HRESULT CBaseWindow::DoCreateWindow() <br>{ <br>    WNDCLASS wndclass;                  // Used to register classes <br>    BOOL bRegistered;                   // Is this class registered <br>    HWND hwnd;                          // Handle to our window <br> <br>    bRegistered = GetClassInfo(m_hInstance,   // Module instance <br>                               m_pClassName,  // Window class <br>                               &amp;wndclass);                 // Info structure <br> <br>    // if the window is to be used for drawing puposes and we are getting a DC <br>    // for the entire lifetime of the window then changes the class style to do <br>    // say so. If we don't set this flag then the DC comes from the cache and is <br>    // really bad. <br>    if (m_bDoGetDC) <br>    { <br>        m_ClassStyles |= CS_OWNDC; <br>    } <br> <br>    if (bRegistered == FALSE) { <br> <br>        // Register the renderer window class <br> <br>        wndclass.lpszClassName = m_pClassName; <br>        wndclass.style         = m_ClassStyles; <br>        wndclass.lpfnWndProc   = (WNDPROC) WndProc; <br>        wndclass.cbClsExtra    = 0; <br>        wndclass.cbWndExtra    = sizeof(CBaseWindow *); <br>        wndclass.hInstance     = m_hInstance; <br>        wndclass.hIcon         = NULL; <br>        wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW); <br>        wndclass.hbrBackground = (HBRUSH) NULL; <br>        wndclass.lpszMenuName  = NULL; <br> <br>        RegisterClass(&amp;wndclass); <br>    } <br> <br>    // Create the frame window.  Pass the pBaseWindow information in the <br>    // CreateStruct which allows our message handling loop to get hold of <br>    // the pBaseWindow pointer. <br> <br>    CBaseWindow *pBaseWindow = this;           // The owner window object <br>    hwnd = CreateWindowEx(m_WindowStylesEx,  // Extended styles <br>                          m_pClassName,      // Registered name <br>                          TEXT("ActiveMovie Window"),     // Window title <br>                          m_WindowStyles,    // Window styles <br>                          CW_USEDEFAULT,                  // Start x position <br>                          CW_USEDEFAULT,                  // Start y position <br>                          DEFWIDTH,                       // Window width <br>                          DEFHEIGHT,                      // Window height <br>                          NULL,                           // Parent handle <br>                          NULL,                           // Menu handle <br>                          m_hInstance,       // Instance handle <br>                          &amp;pBaseWindow);                  // Creation data <br> <br>    // If we failed signal an error to the object constructor (based on the <br>    // last Win32 error on this thread) then signal the constructor thread <br>    // to continue, release the mutex to let others have a go and exit <br> <br>    if (hwnd == NULL) { <br>        DWORD Error = GetLastError(); <br>        return HRESULT_FROM_WIN32(Error); <br>    } <br> <br>    // Check the window LONG is the object who created us <br>    ASSERT(GetWindowLong(hwnd, 0) == (LONG)this); <br> <br>    // Initialise the window and then signal the constructor so that it can <br>    // continue and then finally unlock the object's critical section. The <br>    // window class is left registered even after we terminate the thread <br>    // as we don't know when the last window has been closed. So we allow <br>    // the operating system to free the class resources as appropriate <br> <br>    InitialiseWindow(hwnd); <br> <br>    DbgLog((LOG_TRACE, 2, TEXT("Created window class (%s) HWND(%8.8X)"), <br>            m_pClassName, hwnd)); <br> <br>    return S_OK; <br>} <br> <br> <br>// The base class provides some default handling and calls DefWindowProc <br> <br>LRESULT CBaseWindow::OnReceiveMessage(HWND hwnd,         // Window handle <br>                                      UINT uMsg,         // Message ID <br>                                      WPARAM wParam,     // First parameter <br>                                      LPARAM lParam)     // Other parameter <br>{ <br>    ASSERT(IsWindow(hwnd)); <br> <br>    if (PossiblyEatMessage(uMsg, wParam, lParam)) <br>return 0; <br> <br>    // This is sent by the IVideoWindow SetWindowForeground method. If the <br>    // window is invisible we will show it and make it topmost without the <br>    // foreground focus. If the window is visible it will also be made the <br>    // topmost window without the foreground focus. If wParam is TRUE then <br>    // for both cases the window will be forced into the foreground focus <br> <br>    if (uMsg == m_ShowStageMessage) { <br> <br>        BOOL bVisible = IsWindowVisible(hwnd); <br>        SetWindowPos(hwnd, HWND_TOP, 0, 0, 0, 0, <br>                     SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW | <br>                     (bVisible ? SWP_NOACTIVATE : 0)); <br> <br>        // Should we bring the window to the foreground <br>        if (wParam == TRUE) { <br>            SetForegroundWindow(hwnd); <br>        } <br>        return (LRESULT) 1; <br>    } <br> <br>    // When we go fullscreen we have to add the WS_EX_TOPMOST style to the <br>    // video window so that it comes out above any task bar (this is more <br>    // relevant to WindowsNT than Windows95). However the SetWindowPos call <br>    // must be on the same thread as that which created the window. The <br>    // wParam parameter can be TRUE or FALSE to set and reset the topmost <br> <br>    if (uMsg == m_ShowStageTop) { <br>        HWND HwndTop = (wParam == TRUE ? HWND_TOPMOST : HWND_NOTOPMOST); <br>        BOOL bVisible = IsWindowVisible(hwnd); <br>        SetWindowPos(hwnd, HwndTop, 0, 0, 0, 0, <br>                     SWP_NOMOVE | SWP_NOSIZE | <br>                     (wParam == TRUE ? SWP_SHOWWINDOW : 0) | <br>                     (bVisible ? SWP_NOACTIVATE : 0)); <br>        return (LRESULT) 1; <br>    } <br> <br>    // New palette stuff <br>    if (uMsg == m_RealizePalette) { <br>        ASSERT(m_hwnd == hwnd); <br>        return OnPaletteChange(m_hwnd,WM_QUERYNEWPALETTE); <br>    } <br> <br>    switch (uMsg) { <br> <br>        // Repaint the window if the system colours change <br> <br>        case WM_SYSCOLORCHANGE: <br> <br>            InvalidateRect(hwnd,NULL,FALSE); <br>            return (LRESULT) 1; <br> <br>        // Somebody has changed the palette <br>        case WM_PALETTECHANGED: <br> <br>            OnPaletteChange((HWND)wParam,uMsg); <br>            return (LRESULT) 0; <br> <br>        // We are about to receive the keyboard focus so we ask GDI to realise <br>        // our logical palette again and hopefully it will be fully installed <br>        // without any mapping having to be done during any picture rendering <br> <br>case WM_QUERYNEWPALETTE: <br>    ASSERT(m_hwnd == hwnd); <br>            return OnPaletteChange(m_hwnd,uMsg); <br> <br>        // Store the width and height as useful base class members <br> <br>        case WM_SIZE: <br> <br>    OnSize(LOWORD(lParam), HIWORD(lParam)); <br>            return (LRESULT) 0; <br> <br>        // Intercept the WM_CLOSE messages to hide the window <br> <br>        case WM_CLOSE: <br> <br>            OnClose(); <br>            return (LRESULT) 0; <br>    } <br>    return DefWindowProc(hwnd,uMsg,wParam,lParam); <br>} <br> <br> <br>// This handles the Windows palette change messages - if we do realise our <br>// palette then we return TRUE otherwise we return FALSE. If our window is <br>// foreground application then we should get first choice of colours in the <br>// system palette entries. We get best performance when our logical palette <br>// includes the standard VGA colours (at the beginning and end) otherwise <br>// GDI may have to map from our palette to the device palette while drawing <br> <br>LRESULT CBaseWindow::OnPaletteChange(HWND hwnd,UINT Message) <br>{ <br>    // First check we are not changing the palette during closedown <br> <br>    if (m_hwnd == NULL || hwnd == NULL) { <br>        return (LRESULT) 0; <br>    } <br>    ASSERT(!m_bRealizing); <br> <br>    // Should we realise our palette again <br> <br>    if ((Message == WM_QUERYNEWPALETTE || hwnd != m_hwnd)) { <br>        //  It seems that even if we're invisible that we can get asked <br>        //  to realize our palette and this can cause really ugly side-effects <br>        //  Seems like there's another bug but this masks it a least for the <br>        //  shutting down case. <br>        if (!IsWindowVisible(m_hwnd)) { <br>            DbgLog((LOG_TRACE, 1, TEXT("Realizing when invisible!"))); <br>            return (LRESULT) 0; <br>        } <br> <br>        // Avoid recursion with multiple graphs in the same app <br>#ifdef DEBUG <br>        m_bRealizing = TRUE; <br>#endif <br>        DoRealisePalette(Message != WM_QUERYNEWPALETTE); <br>#ifdef DEBUG <br>        m_bRealizing = FALSE; <br>#endif <br> <br>        // Should we redraw the window with the new palette <br>        if (Message == WM_PALETTECHANGED) { <br>            InvalidateRect(m_hwnd,NULL,FALSE); <br>        } <br>    } <br> <br>    return (LRESULT) 1; <br>} <br> <br> <br>// Return the default window rectangle <br> <br>RECT CBaseWindow::GetDefaultRect() <br>{ <br>    RECT DefaultRect = {0,0,DEFWIDTH,DEFHEIGHT}; <br>    ASSERT(m_hwnd); <br>    // ASSERT(m_hdc); <br>    return DefaultRect; <br>} <br> <br> <br>// Return the current window width <br> <br>LONG CBaseWindow::GetWindowWidth() <br>{ <br>    ASSERT(m_hwnd); <br>    // ASSERT(m_hdc); <br>    return m_Width; <br>} <br> <br> <br>// Return the current window height <br> <br>LONG CBaseWindow::GetWindowHeight() <br>{ <br>    ASSERT(m_hwnd); <br>    // ASSERT(m_hdc); <br>    return m_Height; <br>} <br> <br> <br>// Return the window handle <br> <br>HWND CBaseWindow::GetWindowHWND() <br>{ <br>    ASSERT(m_hwnd); <br>    // ASSERT(m_hdc); <br>    return m_hwnd; <br>} <br> <br> <br>// Return the window drawing device context <br> <br>HDC CBaseWindow::GetWindowHDC() <br>{ <br>    ASSERT(m_hwnd); <br>    ASSERT(m_hdc); <br>    return m_hdc; <br>} <br> <br> <br>// Return the offscreen window drawing device context <br> <br>HDC CBaseWindow::GetMemoryHDC() <br>{ <br>    ASSERT(m_hwnd); <br>    ASSERT(m_MemoryDC); <br>    return m_MemoryDC; <br>} <br> <br> <br>// This is available to clients who want to change the window visiblity. It's <br>// little more than an indirection to the Win32 ShowWindow although these is <br>// some benefit in going through here as this function may change sometime <br> <br>HRESULT CBaseWindow::DoShowWindow(LONG ShowCmd) <br>{ <br>    ShowWindow(m_hwnd,ShowCmd); <br>    return NOERROR; <br>} <br> <br> <br>// Generate a WM_PAINT message for the video window <br> <br>void CBaseWindow::PaintWindow(BOOL bErase) <br>{ <br>    InvalidateRect(m_hwnd,NULL,bErase); <br>} <br> <br> <br>// Allow an application to have us set the video window in the foreground. We <br>// have this because it is difficult for one thread to do do this to a window <br>// owned by another thread. Rather than expose the message we use to execute <br>// the inter thread send message we provide the interface function. All we do <br>// is to SendMessage to the video window renderer thread with a WM_SHOWSTAGE <br> <br>void CBaseWindow::DoSetWindowForeground(BOOL bFocus) <br>{ <br>    SendMessage(m_hwnd,m_ShowStageMessage,(WPARAM) bFocus,(LPARAM) 0); <br>} <br> <br> <br>// Constructor initialises the owning object pointer. Since we are a worker <br>// class for the main window object we have relatively few state variables to <br>// look after. We are given device context handles to use later on as well as <br>// the source and destination rectangles (but reset them here just in case) <br> <br>CDrawImage::CDrawImage(CBaseWindow *pBaseWindow) : <br>    m_pBaseWindow(pBaseWindow), <br>    m_hdc(NULL), <br>    m_MemoryDC(NULL), <br>    m_bStretch(FALSE), <br>    m_pMediaType(NULL), <br>    m_bUsingImageAllocator(FALSE) <br>{ <br>    ASSERT(pBaseWindow); <br>    ResetPaletteVersion(); <br>    SetRectEmpty(&amp;m_TargetRect); <br>    SetRectEmpty(&amp;m_SourceRect); <br> <br>    m_perfidRenderTime = MSR_REGISTER("Single Blt time"); <br>} <br> <br> <br>// Overlay the image time stamps on the picture. Access to this method is <br>// serialised by the caller. We display the sample start and end times on <br>// top of the video using TextOut on the device context we are handed. If <br>// there isn't enough room in the window for the times we don't show them <br> <br>void CDrawImage::DisplaySampleTimes(IMediaSample *pSample) <br>{ <br>    TCHAR szTimes[TIMELENGTH];      // Time stamp strings <br>    ASSERT(pSample);                // Quick sanity check <br>    RECT ClientRect;                // Client window size <br>    SIZE Size;                      // Size of text output <br> <br>    // Get the time stamps and window size <br> <br>    pSample-&gt;GetTime((REFERENCE_TIME*)&amp;m_StartSample, (REFERENCE_TIME*)&amp;m_EndSample); <br>    HWND hwnd = m_pBaseWindow-&gt;GetWindowHWND(); <br>    EXECUTE_ASSERT(GetClientRect(hwnd,&amp;ClientRect)); <br> <br>    // Format the sample time stamps <br> <br>    wsprintf(szTimes,TEXT("%08d : %08d"), <br>             m_StartSample.Millisecs(), <br>             m_EndSample.Millisecs()); <br> <br>    ASSERT(lstrlen(szTimes) &lt; TIMELENGTH); <br> <br>    // Put the times in the middle at the bottom of the window <br> <br>    GetTextExtentPoint32(m_hdc,szTimes,lstrlen(szTimes),&amp;Size); <br>    INT XPos = ((ClientRect.right - ClientRect.left) - Size.cx) / 2; <br>    INT YPos = ((ClientRect.bottom - ClientRect.top) - Size.cy) * 4 / 5; <br> <br>    // Check the window is big enough to have sample times displayed <br> <br>    if ((XPos &gt; 0) &amp;&amp; (YPos &gt; 0)) { <br>        TextOut(m_hdc,XPos,YPos,szTimes,lstrlen(szTimes)); <br>    } <br>} <br> <br> <br>// This is called when the drawing code sees that the image has a down level <br>// palette cookie. We simply call the SetDIBColorTable Windows API with the <br>// palette that is found after the BITMAPINFOHEADER - we return no errors <br> <br>void CDrawImage::UpdateColourTable(HDC hdc,BITMAPINFOHEADER *pbmi) <br>{ <br>    ASSERT(pbmi-&gt;biClrUsed); <br>    RGBQUAD *pColourTable = (RGBQUAD *)(pbmi+1); <br> <br>    // Set the new palette in the device context <br> <br>    UINT uiReturn = SetDIBColorTable(hdc,(UINT) 0, <br>                                     pbmi-&gt;biClrUsed, <br>                                     pColourTable); <br> <br>    // Should always succeed but check in debug builds <br>    ASSERT(uiReturn == pbmi-&gt;biClrUsed); <br>} <br> <br> <br>// No source rectangle scaling is done by the base class <br> <br>RECT CDrawImage::ScaleSourceRect(const RECT *pSource) <br>{ <br>    ASSERT(pSource); <br>    return *pSource; <br>} <br> <br> <br>// This is called when the funky output pin uses our allocator. The samples we <br>// allocate are special because the memory is shared between us and GDI thus <br>// removing one copy when we ask for the image to be rendered. The source type <br>// information is in the main renderer m_mtIn field which is initialised when <br>// the media type is agreed in SetMediaType, the media type may be changed on <br>// the fly if, for example, the source filter needs to change the palette <br> <br>void CDrawImage::FastRender(IMediaSample *pMediaSample) <br>{ <br>    BITMAPINFOHEADER *pbmi;     // Image format data <br>    DIBDATA *pDibData;          // Stores DIB information <br>    BYTE *pImage;               // Pointer to image data <br>    HBITMAP hOldBitmap;         // Store the old bitmap <br>    CImageSample *pSample;      // Pointer to C++ object <br> <br>    ASSERT(m_pMediaType); <br> <br>    // From the untyped source format block get the VIDEOINFO and subsequently </code></pre>
<p>
</p>
<pre><code>// the BITMAPINFOHEADER structure. We can cast the IMediaSample interface <br>    // to a CImageSample object so we can retrieve it's DIBSECTION details <br> <br>    pbmi = HEADER(m_pMediaType-&gt;Format()); <br>    pSample = (CImageSample *) pMediaSample; <br>    pDibData = pSample-&gt;GetDIBData(); <br>    hOldBitmap = (HBITMAP) SelectObject(m_MemoryDC,pDibData-&gt;hBitmap); <br> <br>    // Get a pointer to the real image data <br> <br>    HRESULT hr = pMediaSample-&gt;GetPointer(&amp;pImage); <br>    if (FAILED(hr)) { <br>        return; <br>    } <br> <br>    // Do we need to update the colour table, we increment our palette cookie <br>    // each time we get a dynamic format change. The sample palette cookie is <br>    // stored in the DIBDATA structure so we try to keep the fields in sync <br>    // By the time we get to draw the images the format change will be done <br>    // so all we do is ask the renderer for what it's palette version is <br> <br>    if (pDibData-&gt;PaletteVersion &lt; GetPaletteVersion()) { <br>        ASSERT(pbmi-&gt;biBitCount &lt;= iPALETTE); <br>        UpdateColourTable(m_MemoryDC,pbmi); <br>        pDibData-&gt;PaletteVersion = GetPaletteVersion(); <br>    } <br> <br>    // This allows derived classes to change the source rectangle that we do <br>    // the drawing with. For example a renderer may ask a codec to stretch <br>    // the video from 320x240 to 640x480, in which case the source we see in <br>    // here will still be 320x240, although the source we want to draw with <br>    // should be scaled up to 640x480. The base class implementation of this <br>    // method does nothing but return the same rectangle as we are passed in <br> <br>    RECT SourceRect = ScaleSourceRect(&amp;m_SourceRect); <br> <br>    // Is the window the same size as the video <br> <br>    if (m_bStretch == FALSE) { <br> <br>        // Put the image straight into the window <br> <br>        BitBlt( <br>            (HDC) m_hdc,                            // Target device HDC <br>            m_TargetRect.left,                      // X sink position <br>            m_TargetRect.top,                       // Y sink position <br>            m_TargetRect.right - m_TargetRect.left, // Destination width <br>            m_TargetRect.bottom - m_TargetRect.top, // Destination height <br>            m_MemoryDC,                             // Source device context <br>            SourceRect.left,                        // X source position <br>            SourceRect.top,                         // Y source position <br>            SRCCOPY);                               // Simple copy <br> <br>    } else { <br> <br>        // Stretch the image when copying to the window <br> <br>        StretchBlt( <br>            (HDC) m_hdc,                            // Target device HDC <br>            m_TargetRect.left,                      // X sink position <br>            m_TargetRect.top,                       // Y sink position <br>            m_TargetRect.right - m_TargetRect.left, // Destination width <br>            m_TargetRect.bottom - m_TargetRect.top, // Destination height <br>            m_MemoryDC,                             // Source device HDC <br>            SourceRect.left,                        // X source position <br>            SourceRect.top,                         // Y source position <br>            SourceRect.right - SourceRect.left,     // Source width <br>            SourceRect.bottom - SourceRect.top,     // Source height <br>            SRCCOPY);                               // Simple copy <br>    } <br> <br>    // This displays the sample times over the top of the image. This used to <br>    // draw the times into the offscreen device context however that actually <br>    // writes the text into the image data buffer which may not be writable <br> <br>    #ifdef DEBUG <br>    DisplaySampleTimes(pMediaSample); <br>    #endif <br> <br>    // Put the old bitmap back into the device context so we don't leak <br>    SelectObject(m_MemoryDC,hOldBitmap); <br>} <br> <br> <br>// This is called when there is a sample ready to be drawn, unfortunately the <br>// output pin was being rotten and didn't choose our super excellent shared <br>// memory DIB allocator so we have to do this slow render using boring old GDI <br>// SetDIBitsToDevice and StretchDIBits. The down side of using these GDI <br>// functions is that the image data has to be copied across from our address <br>// space into theirs before going to the screen (although in reality the cost <br>// is small because all they do is to map the buffer into their address space) <br> <br>void CDrawImage::SlowRender(IMediaSample *pMediaSample) <br>{ <br>    // Get the BITMAPINFOHEADER for the connection <br> <br>    ASSERT(m_pMediaType); <br>    BITMAPINFOHEADER *pbmi = HEADER(m_pMediaType-&gt;Format()); <br>    BYTE *pImage; <br> <br>    // Get the image data buffer <br> <br>    HRESULT hr = pMediaSample-&gt;GetPointer(&amp;pImage); <br>    if (FAILED(hr)) { <br>        return; <br>    } <br> <br>    // This allows derived classes to change the source rectangle that we do <br>    // the drawing with. For example a renderer may ask a codec to stretch <br>    // the video from 320x240 to 640x480, in which case the source we see in <br>    // here will still be 320x240, although the source we want to draw with <br>    // should be scaled up to 640x480. The base class implementation of this <br>    // method does nothing but return the same rectangle as we are passed in <br> <br>    RECT SourceRect = ScaleSourceRect(&amp;m_SourceRect); <br> <br>    LONG lAdjustedSourceTop = SourceRect.top; <br>    // if the origin of bitmap is bottom-left, adjust soruce_rect_top <br>    // to be the bottom-left corner instead of the top-left. <br>    if (pbmi-&gt;biHeight &gt; 0) { <br>       lAdjustedSourceTop = pbmi-&gt;biHeight - SourceRect.bottom; <br>    } <br>    // Is the window the same size as the video <br> <br>    if (m_bStretch == FALSE) { <br> <br>        // Put the image straight into the window <br> <br>        SetDIBitsToDevice( <br>            (HDC) m_hdc,                            // Target device HDC <br>            m_TargetRect.left,                      // X sink position <br>            m_TargetRect.top,                       // Y sink position <br>            m_TargetRect.right - m_TargetRect.left, // Destination width <br>            m_TargetRect.bottom - m_TargetRect.top, // Destination height <br>            SourceRect.left,                        // X source position <br>            lAdjustedSourceTop,                     // Adjusted Y source position <br>            (UINT) 0,                               // Start scan line <br>            pbmi-&gt;biHeight,                         // Scan lines present <br>            pImage,                                 // Image data <br>            (BITMAPINFO *) pbmi,                    // DIB header <br>            DIB_RGB_COLORS);                        // Type of palette <br> <br>    } else { <br> <br>        // Stretch the image when copying to the window <br> <br>        StretchDIBits( <br>            (HDC) m_hdc,                            // Target device HDC <br>            m_TargetRect.left,                      // X sink position <br>            m_TargetRect.top,                       // Y sink position <br>            m_TargetRect.right - m_TargetRect.left, // Destination width <br>            m_TargetRect.bottom - m_TargetRect.top, // Destination height <br>            SourceRect.left,                        // X source position <br>            lAdjustedSourceTop,                     // Adjusted Y source position <br>            SourceRect.right - SourceRect.left,     // Source width <br>            SourceRect.bottom - SourceRect.top,     // Source height <br>            pImage,                                 // Image data <br>            (BITMAPINFO *) pbmi,                    // DIB header <br>            DIB_RGB_COLORS,                         // Type of palette <br>            SRCCOPY);                               // Simple image copy <br>    } <br> <br>    // This shows the sample reference times over the top of the image which <br>    // looks a little flickery. I tried using GdiSetBatchLimit and GdiFlush to <br>    // control the screen updates but it doesn't quite work as expected and <br>    // only partially reduces the flicker. I also tried using a memory context <br>    // and combining the two in that before doing a final BitBlt operation to <br>    // the screen, unfortunately this has considerable performance penalties <br>    // and also means that this code is not executed when compiled retail <br> <br>    #ifdef DEBUG <br>    DisplaySampleTimes(pMediaSample); <br>    #endif <br>} <br> <br> <br>// This is called with an IMediaSample interface on the image to be drawn. We <br>// decide on the drawing mechanism based on who's allocator we are using. We <br>// may be called when the window wants an image painted by WM_PAINT messages <br>// We can't realise the palette here because we have the renderer lock, any <br>// call to realise may cause an interthread send message to the window thread <br>// which may in turn be waiting to get the renderer lock before servicing it <br> <br>BOOL CDrawImage::DrawImage(IMediaSample *pMediaSample) <br>{ <br>    ASSERT(m_hdc); <br>    ASSERT(m_MemoryDC); <br>    NotifyStartDraw(); <br> <br>    // If the output pin used our allocator then the samples passed are in <br>    // fact CVideoSample objects that contain CreateDIBSection data that we <br>    // use to do faster image rendering, they may optionally also contain a <br>    // DirectDraw surface pointer in which case we do not do the drawing <br> <br>    if (m_bUsingImageAllocator == FALSE) { <br>        SlowRender(pMediaSample); <br>        EXECUTE_ASSERT(GdiFlush()); <br>        NotifyEndDraw(); <br>        return TRUE; <br>    } <br> <br>    // This is a DIBSECTION buffer <br> <br>    FastRender(pMediaSample); <br>    EXECUTE_ASSERT(GdiFlush()); <br>    NotifyEndDraw(); <br>    return TRUE; <br>} <br> <br> <br>// This is called by the owning window object after it has created the window <br>// and it's drawing contexts. We are constructed with the base window we'll <br>// be drawing into so when given the notification we retrive the device HDCs <br>// to draw with. We cannot call these in our constructor as they are virtual <br> <br>void CDrawImage::SetDrawContext() <br>{ <br>    m_MemoryDC = m_pBaseWindow-&gt;GetMemoryHDC(); <br>    m_hdc = m_pBaseWindow-&gt;GetWindowHDC(); <br>} <br> <br> <br>// This is called to set the target rectangle in the video window, it will be <br>// called whenever a WM_SIZE message is retrieved from the message queue. We <br>// simply store the rectangle and use it later when we do the drawing calls <br> <br>void CDrawImage::SetTargetRect(RECT *pTargetRect) <br>{ <br>    ASSERT(pTargetRect); <br>    m_TargetRect = *pTargetRect; <br>    SetStretchMode(); <br>} <br> <br> <br>// Return the current target rectangle <br> <br>void CDrawImage::GetTargetRect(RECT *pTargetRect) <br>{ <br>    ASSERT(pTargetRect); <br>    *pTargetRect = m_TargetRect; <br>} <br> <br> <br>// This is called when we want to change the section of the image to draw. We <br>// use this information in the drawing operation calls later on. We must also <br>// see if the source and destination rectangles have the same dimensions. If <br>// not we must stretch during the drawing rather than a direct pixel copy <br> <br>void CDrawImage::SetSourceRect(RECT *pSourceRect) <br>{ <br>    ASSERT(pSourceRect); <br>    m_SourceRect = *pSourceRect; <br>    SetStretchMode(); <br>} <br> <br> <br>// Return the current source rectangle <br> <br>void CDrawImage::GetSourceRect(RECT *pSourceRect) <br>{ <br>    ASSERT(pSourceRect); <br>    *pSourceRect = m_SourceRect; <br>} <br> <br> <br>// This is called when either the source or destination rectanges change so we <br>// can update the stretch flag. If the rectangles don't match we stretch the <br>// video during the drawing otherwise we call the fast pixel copy functions <br>// NOTE the source and/or the destination rectangle may be completely empty <br> <br>void CDrawImage::SetStretchMode() <br>{ <br>    // Calculate the overall rectangle dimensions <br> <br>    LONG SourceWidth = m_SourceRect.right - m_SourceRect.left; <br>    LONG SinkWidth = m_TargetRect.right - m_TargetRect.left; <br>    LONG SourceHeight = m_SourceRect.bottom - m_SourceRect.top; <br>    LONG SinkHeight = m_TargetRect.bottom - m_TargetRect.top; <br> <br>    m_bStretch = TRUE; <br>    if (SourceWidth == SinkWidth) { <br>        if (SourceHeight == SinkHeight) { <br>            m_bStretch = FALSE; <br>        } <br>    } <br>} <br> <br> <br>// Tell us whose allocator we are using. This should be called with TRUE if <br>// the filter agrees to use an allocator based around the CImageAllocator <br>// SDK base class - whose image buffers are made through CreateDIBSection. <br>// Otherwise this should be called with FALSE and we will draw the images <br>// using SetDIBitsToDevice and StretchDIBitsToDevice. None of these calls <br>// can handle buffers which have non zero strides (like DirectDraw uses) <br> <br>void CDrawImage::NotifyAllocator(BOOL bUsingImageAllocator) <br>{ <br>    m_bUsingImageAllocator = bUsingImageAllocator; <br>} <br> <br> <br>// Are we using the image DIBSECTION allocator <br> <br>BOOL CDrawImage::UsingImageAllocator() <br>{ <br>    return m_bUsingImageAllocator; <br>} <br> <br> <br>// We need the media type of the connection so that we can get the BITMAPINFO <br>// from it. We use that in the calls to draw the image such as StretchDIBits <br>// and also when updating the colour table held in shared memory DIBSECTIONs <br> <br>void CDrawImage::NotifyMediaType(CMediaType *pMediaType) <br>{ <br>    m_pMediaType = pMediaType; <br>} <br> <br> <br>// We store in this object a cookie maintaining the current palette version. <br>// Each time a palettised format is changed we increment this value so that <br>// when we come to draw the images we look at the colour table value they <br>// have and if less than the current we know to update it. This version is <br>// only needed and indeed used when working with shared memory DIBSECTIONs <br> <br>LONG CDrawImage::GetPaletteVersion() <br>{ <br>    return m_PaletteVersion; <br>} <br> <br> <br>// Resets the current palette version number <br> <br>void CDrawImage::ResetPaletteVersion() <br>{ <br>    m_PaletteVersion = PALETTE_VERSION; <br>} <br> <br> <br>// Increment the current palette version <br> <br>void CDrawImage::IncrementPaletteVersion() <br>{ <br>    m_PaletteVersion++; <br>} <br> <br> <br>// Constructor must initialise the base allocator. Each sample we create has a <br>// palette version cookie on board. When the source filter changes the palette <br>// during streaming the window object increments an internal cookie counter it <br>// keeps as well. When it comes to render the samples it looks at the cookie <br>// values and if they don't match then it knows to update the sample's colour <br>// table. However we always create samples with a cookie of PALETTE_VERSION <br>// If there have been multiple format changes and we disconnect and reconnect <br>// thereby causing the samples to be reallocated we will create them with a <br>// cookie much lower than the current version, this isn't a problem since it <br>// will be seen by the window object and the versions will then be updated <br> <br>CImageAllocator::CImageAllocator(CBaseFilter *pFilter, <br>                                 TCHAR *pName, <br>                                 HRESULT *phr) : <br>    CBaseAllocator(pName,NULL,phr), <br>    m_pFilter(pFilter) <br>{ <br>    ASSERT(phr); <br>    ASSERT(pFilter); <br>} <br> <br> <br>// Check our DIB buffers have been released <br> <br>#ifdef DEBUG <br>CImageAllocator::~CImageAllocator() <br>{ <br>    ASSERT(m_bCommitted == FALSE); <br>} <br>#endif <br> <br> <br>// Called from destructor and also from base class to free resources. We work <br>// our way through the list of media samples deleting the DIBSECTION created <br>// for each. All samples should be back in our list so there is no chance a <br>// filter is still using one to write on the display or hold on a pending list <br> <br>void CImageAllocator::Free() <br>{ <br>    ASSERT(m_lAllocated == m_lFree.GetCount()); <br>    EXECUTE_ASSERT(GdiFlush()); <br>    CImageSample *pSample; <br>    DIBDATA *pDibData; <br> <br>    while (m_lFree.GetCount() != 0) { <br>        pSample = (CImageSample *) m_lFree.RemoveHead(); <br>        pDibData = pSample-&gt;GetDIBData(); <br>        EXECUTE_ASSERT(DeleteObject(pDibData-&gt;hBitmap)); <br>        EXECUTE_ASSERT(CloseHandle(pDibData-&gt;hMapping)); <br>        delete pSample; <br>    } <br> <br>    m_lAllocated = 0; <br>} <br> <br> <br>// Prepare the allocator by checking all the input parameters <br> <br>STDMETHODIMP CImageAllocator::CheckSizes(ALLOCATOR_PROPERTIES *pRequest) <br>{ <br>    // Check we have a valid connection <br> <br>    if (m_pMediaType == NULL) { <br>        return VFW_E_NOT_CONNECTED; <br>    } <br> <br>    // NOTE We always create a DIB section with the source format type which <br>    // may contain a source palette. When we do the BitBlt drawing operation <br>    // the target display device may contain a different palette (we may not <br>    // have the focus) in which case GDI will do after the palette mapping <br> <br>    VIDEOINFOHEADER *pVideoInfo = (VIDEOINFOHEADER *) m_pMediaType-&gt;Format(); <br> <br>    // When we call CreateDIBSection it implicitly maps only enough memory <br>    // for the image as defined by thee BITMAPINFOHEADER. If the user asks <br>    // for an image smaller than this then we reject the call, if they ask <br>    // for an image larger than this then we return what they can have <br> <br>    if ((DWORD) pRequest-&gt;cbBuffer &lt; pVideoInfo-&gt;bmiHeader.biSizeImage) { <br>        return E_INVALIDARG; <br>    } <br> <br>    // Reject buffer prefixes <br> <br>    if (pRequest-&gt;cbPrefix &gt; 0) { <br>        return E_INVALIDARG; <br>    } <br> <br>    pRequest-&gt;cbBuffer = pVideoInfo-&gt;bmiHeader.biSizeImage; <br>    return NOERROR; <br>} <br> <br> <br>// Agree the number of media sample buffers and their sizes. The base class <br>// this allocator is derived from allows samples to be aligned only on byte <br>// boundaries NOTE the buffers are not allocated until the Commit call <br> <br>STDMETHODIMP CImageAllocator::SetProperties( <br>    ALLOCATOR_PROPERTIES * pRequest, <br>    ALLOCATOR_PROPERTIES * pActual) <br>{ <br>    ALLOCATOR_PROPERTIES Adjusted = *pRequest; <br> <br>    // Check the parameters fit with the current connection <br> <br>    HRESULT hr = CheckSizes(&amp;Adjusted); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br>    return CBaseAllocator::SetProperties(&amp;Adjusted, pActual); <br>} <br> <br> <br>// Commit the memory by allocating the agreed number of media samples. For <br>// each sample we are committed to creating we have a CImageSample object <br>// that we use to manage it's resources. This is initialised with a DIBDATA <br>// structure that contains amongst other things the GDI DIBSECTION handle <br>// We will access the renderer media type during this so we must have locked <br>// (to prevent the format changing for example). The class overrides Commit <br>// and Decommit to do this locking (base class Commit in turn calls Alloc) <br> <br>HRESULT CImageAllocator::Alloc(void) <br>{ <br>    ASSERT(m_pMediaType); <br>    CImageSample *pSample; <br>    DIBDATA DibData; <br> <br>    // Check the base allocator says it's ok to continue <br> <br>    HRESULT hr = CBaseAllocator::Alloc(); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br> <br>    // We create a new memory mapped object although we don't map it into our <br>    // address space because GDI does that in CreateDIBSection. It is possible <br>    // that we run out of resources before creating all the samples in which <br>    // case the available sample list is left with those already created <br> <br>    ASSERT(m_lAllocated == 0); <br>    while (m_lAllocated &lt; m_lCount) { <br> <br>        // Create and initialise a shared memory GDI buffer <br> <br>        HRESULT hr = CreateDIB(m_lSize,DibData); <br>        if (FAILED(hr)) { <br>            return hr; <br>        } <br> <br>        // Create the sample object and pass it the DIBDATA <br> <br>        pSample = CreateImageSample(DibData.pBase,m_lSize); <br>        if (pSample == NULL) { <br>            EXECUTE_ASSERT(DeleteObject(DibData.hBitmap)); <br>            EXECUTE_ASSERT(CloseHandle(DibData.hMapping)); <br>            return E_OUTOFMEMORY; <br>        } <br> <br>        // Add the completed sample to the available list <br> <br>        pSample-&gt;SetDIBData(&amp;DibData); <br>        m_lFree.Add(pSample); <br>        m_lAllocated++; <br>    } <br>    return NOERROR; <br>} <br> <br> <br>// We have a virtual method that allocates the samples so that a derived class <br>// may override it and allocate more specialised sample objects. So long as it <br>// derives its samples from CImageSample then all this code will still work ok <br> <br>CImageSample *CImageAllocator::CreateImageSample(LPBYTE pData,LONG Length) <br>{ <br>    HRESULT hr = NOERROR; <br>    CImageSample *pSample; <br> <br>    // Allocate the new sample and check the return codes <br> <br>    pSample = new CImageSample((CBaseAllocator *) this,   // Base class <br>                               NAME("Video sample"),      // DEBUG name <br>                               (HRESULT *) &amp;hr,           // Return code <br>                               (LPBYTE) pData,            // DIB address <br>                               (LONG) Length);            // Size of DIB <br> <br>    if (pSample == NULL || FAILED(hr)) { <br>        delete pSample; <br>        return NULL; <br>    } <br>    return pSample; <br>} <br> <br> <br>// This function allocates a shared memory block for use by the source filter <br>// generating DIBs for us to render. The memory block is created in shared <br>// memory so that GDI doesn't have to copy the memory when we do a BitBlt <br> <br>HRESULT CImageAllocator::CreateDIB(LONG InSize,DIBDATA &amp;DibData) <br>{ <br>    BITMAPINFO *pbmi;       // Format information for pin <br>    BYTE *pBase;            // Pointer to the actual image <br>    HANDLE hMapping;        // Handle to mapped object <br>    HBITMAP hBitmap;        // DIB section bitmap handle <br> <br>    // Create a file mapping object and map into our address space <br> <br>    hMapping = CreateFileMapping(hMEMORY,         // Use system page file <br>                                 NULL,            // No security attributes <br>                                 PAGE_READWRITE,  // Full access to memory <br>                                 (DWORD) 0,       // Less than 4Gb in size <br>                                 InSize,          // Size of buffer <br>                                 NULL);           // No name to section <br>    if (hMapping == NULL) { <br>        DWORD Error = GetLastError(); <br>        return HRESULT_FROM_WIN32(Error); <br>    } <br> <br>    // NOTE We always create a DIB section with the source format type which <br>    // may contain a source palette. When we do the BitBlt drawing operation <br>    // the target display device may contain a different palette (we may not <br>    // have the focus) in which case GDI will do after the palette mapping <br> <br>    pbmi = (BITMAPINFO *) HEADER(m_pMediaType-&gt;Format()); <br>    if (m_pMediaType == NULL) { <br>        DbgBreak("Invalid media type"); <br>    } <br> <br>    hBitmap = CreateDIBSection((HDC) NULL,          // NO device context <br>                               pbmi,                // Format information <br>                               DIB_RGB_COLORS,      // Use the palette <br>                               (VOID **) &amp;pBase,    // Pointer to image data <br>                               hMapping,            // Mapped memory handle <br>                               (DWORD) 0);          // Offset into memory <br> <br>    if (hBitmap == NULL || pBase == NULL) { <br>        EXECUTE_ASSERT(CloseHandle(hMapping)); <br>        DWORD Error = GetLastError(); <br>        return HRESULT_FROM_WIN32(Error); <br>    } <br> <br>    // Initialise the DIB information structure <br> <br>    DibData.hBitmap = hBitmap; <br>    DibData.hMapping = hMapping; <br>    DibData.pBase = pBase; <br>    DibData.PaletteVersion = PALETTE_VERSION; <br>    GetObject(hBitmap,sizeof(DIBSECTION),(VOID *)&amp;DibData.DibSection); <br> <br>    return NOERROR; <br>} <br> <br> <br>// We use the media type during the DIBSECTION creation <br> <br>void CImageAllocator::NotifyMediaType(CMediaType *pMediaType) <br>{ <br>    m_pMediaType = pMediaType; <br>} <br> <br> <br>// Overriden to increment the owning object's reference count <br> <br>STDMETHODIMP_(ULONG) CImageAllocator::NonDelegatingAddRef() <br>{ <br>    return m_pFilter-&gt;AddRef(); <br>} <br> <br> <br>// Overriden to decrement the owning object's reference count <br> <br>STDMETHODIMP_(ULONG) CImageAllocator::NonDelegatingRelease() <br>{ <br>    return m_pFilter-&gt;Release(); <br>} <br> <br> <br>// If you derive a class from CMediaSample that has to transport specialised <br>// member variables and entry points then there are three alternate solutions <br>// The first is to create a memory buffer larger than actually required by the <br>// sample and store your information either at the beginning of it or at the <br>// end, the former being moderately safer allowing for misbehaving transform <br>// filters. You then adjust the buffer address when you create the base media <br>// sample. This has the disadvantage of breaking up the memory allocated to <br>// the samples into separate blocks. The second solution is to implement a <br>// class derived from CMediaSample and support additional interface(s) that <br>// convey your private data. This means defining a custom interface. The final <br>// alternative is to create a class that inherits from CMediaSample and adds <br>// the private data structures, when you get an IMediaSample in your Receive() <br>// call check to see if your allocator is being used, and if it is then cast <br>// the IMediaSample into one of your objects. Additional checks can be made <br>// to ensure the sample's this pointer is known to be one of your own objects <br> <br>CImageSample::CImageSample(CBaseAllocator *pAllocator, <br>                           TCHAR *pName, <br>                           HRESULT *phr, <br>                           LPBYTE pBuffer, <br>                           LONG length) : <br>    CMediaSample(pName,pAllocator,phr,pBuffer,length), <br>    m_bInit(FALSE) <br>{ <br>    ASSERT(pAllocator); <br>    ASSERT(pBuffer); <br>} <br> <br> <br>// Set the shared memory DIB information <br> <br>void CImageSample::SetDIBData(DIBDATA *pDibData) <br>{ <br>    ASSERT(pDibData); <br>    m_DibData = *pDibData; <br>    m_bInit = TRUE; <br>} <br> <br> <br>// Retrieve the shared memory DIB data <br> <br>DIBDATA *CImageSample::GetDIBData() <br>{ <br>    ASSERT(m_bInit == TRUE); <br>    return &amp;m_DibData; <br>} <br> <br> <br>// This class handles the creation of a palette. It is fairly specialist and <br>// is intended to simplify palette management for video renderer filters. It <br>// is for this reason that the constructor requires three other objects with <br>// which it interacts, namely a base media filter, a base window and a base <br>// drawing object although the base window or the draw object may be NULL to <br>// ignore that part of us. We try not to create and install palettes unless <br>// absolutely necessary as they typically require WM_PALETTECHANGED messages <br>// to be sent to every window thread in the system which is very expensive <br> <br>CImagePalette::CImagePalette(CBaseFilter *pBaseFilter, <br>                             CBaseWindow *pBaseWindow, <br>                             CDrawImage *pDrawImage) : <br>    m_pBaseWindow(pBaseWindow), <br>    m_pFilter(pBaseFilter), <br>    m_pDrawImage(pDrawImage), <br>    m_hPalette(NULL) <br>{ <br>    ASSERT(m_pFilter); <br>} <br> <br> <br>// Destructor <br> <br>#ifdef DEBUG <br>CImagePalette::~CImagePalette() <br>{ <br>    ASSERT(m_hPalette == NULL); <br>} <br>#endif <br> <br> <br>// We allow dynamic format changes of the palette but rather than change the <br>// palette every time we call this to work out whether an update is required. <br>// If the original type didn't use a palette and the new one does (or vica <br>// versa) then we return TRUE. If neither formats use a palette we'll return <br>// FALSE. If both formats use a palette we compare their colours and return <br>// FALSE if they match. This therefore short circuits palette creation unless <br>// absolutely necessary since installing palettes is an expensive operation <br> <br>BOOL CImagePalette::ShouldUpdate(const VIDEOINFOHEADER *pNewInfo, <br>                                 const VIDEOINFOHEADER *pOldInfo) <br>{ <br>    // We may not have a current format yet <br> <br>    if (pOldInfo == NULL) { <br>        return TRUE; <br>    } <br> <br>    // Do both formats not require a palette <br> <br>    if (ContainsPalette(pNewInfo) == FALSE) { <br>        if (ContainsPalette(pOldInfo) == FALSE) { <br>            return FALSE; <br>        } <br>    } <br> <br>    // Compare the colours to see if they match <br> <br>    DWORD VideoEntries = pNewInfo-&gt;bmiHeader.biClrUsed; <br>    if (ContainsPalette(pNewInfo) == TRUE) <br>        if (ContainsPalette(pOldInfo) == TRUE) <br>            if (pOldInfo-&gt;bmiHeader.biClrUsed == VideoEntries) <br>                if (pOldInfo-&gt;bmiHeader.biClrUsed &gt; 0) <br>                    if (memcmp((PVOID) GetBitmapPalette(pNewInfo), <br>                               (PVOID) GetBitmapPalette(pOldInfo), <br>                               VideoEntries * sizeof(RGBQUAD)) == 0) { <br> <br>                        return FALSE; <br>                    } <br>    return TRUE; <br>} <br> <br> <br>// This is normally called when the input pin type is set to install a palette <br>// We will typically be called from two different places. The first is when we <br>// have negotiated a palettised media type after connection, the other is when <br>// we receive a new type during processing with an updated palette in which <br>// case we must remove and release the resources held by the current palette <br> <br>// We can be passed an optional device name if we wish to prepare a palette <br>// for a specific monitor on a multi monitor system <br> <br>HRESULT CImagePalette::PreparePalette(const CMediaType *pmtNew, <br>                                      const CMediaType *pmtOld, <br>      LPSTR szDevice) <br>{ <br>    const VIDEOINFOHEADER *pNewInfo = (VIDEOINFOHEADER *) pmtNew-&gt;Format(); <br>    const VIDEOINFOHEADER *pOldInfo = (VIDEOINFOHEADER *) pmtOld-&gt;Format(); <br>    ASSERT(pNewInfo); <br> <br>    // This is an performance optimisation, when we get a media type we check <br>    // to see if the format requires a palette change. If either we need one <br>    // when previously we didn't or vica versa then this returns TRUE, if we <br>    // previously needed a palette and we do now it compares their colours <br> <br>    if (ShouldUpdate(pNewInfo,pOldInfo) == FALSE) { <br>        NOTE("No update needed"); <br>        return S_FALSE; <br>    } <br> <br>    // We must notify the filter graph that the application may have changed <br>    // the palette although in practice we don't bother checking to see if it <br>    // is really different. If it tries to get the palette either the window <br>    // or renderer lock will ensure it doesn't get in until we are finished </code></pre>
<p>
</p>
<pre><code><br>    RemovePalette(); <br>    m_pFilter-&gt;NotifyEvent(EC_PALETTE_CHANGED,0,0); <br> <br>    // Do we need a palette for the new format <br> <br>    if (ContainsPalette(pNewInfo) == FALSE) { <br>        NOTE("New has no palette"); <br>        return S_FALSE; <br>    } <br> <br>    // If we're changing the palette on the fly then we increment our palette <br>    // cookie which is compared against the cookie also stored in all of our <br>    // DIBSECTION media samples. If they don't match when we come to draw it <br>    // then we know the sample is out of date and we'll update it's palette <br> <br>    NOTE("Making new colour palette"); <br>    m_hPalette = MakePalette(pNewInfo, szDevice); <br>    ASSERT(m_hPalette != NULL); <br> <br>    // The window in which the new palette is to be realised may be a NULL <br>    // pointer to signal that no window is in use, if so we don't call it <br>    // Some filters just want to use this object to create/manage palettes <br> <br>    if (m_pBaseWindow) m_pBaseWindow-&gt;SetPalette(m_hPalette); <br> <br>    // This is the only time where we need access to the draw object to say <br>    // to it that a new palette will be arriving on a sample real soon. The <br>    // constructor may take a NULL pointer in which case we don't call this <br> <br>    if (m_pDrawImage) m_pDrawImage-&gt;IncrementPaletteVersion(); <br>    return NOERROR; <br>} <br> <br> <br>// Helper function to copy a palette out of any kind of VIDEOINFO (ie it may <br>// be YUV or true colour) into a palettised VIDEOINFO. We use this changing <br>// palettes on DirectDraw samples as a source filter can attach a palette to <br>// any buffer (eg YUV) and hand it back. We make a new palette out of that <br>// format and then copy the palette colours into the current connection type <br> <br>HRESULT CImagePalette::CopyPalette(const CMediaType *pSrc,CMediaType *pDest) <br>{ <br>    // Reset the destination palette before starting <br> <br>    VIDEOINFOHEADER *pDestInfo = (VIDEOINFOHEADER *) pDest-&gt;Format(); <br>    pDestInfo-&gt;bmiHeader.biClrUsed = 0; <br>    pDestInfo-&gt;bmiHeader.biClrImportant = 0; <br> <br>    // Does the destination have a palette <br> <br>    if (PALETTISED(pDestInfo) == FALSE) { <br>        NOTE("No destination palette"); <br>        return S_FALSE; <br>    } <br> <br>    // Does the source contain a palette <br> <br>    const VIDEOINFOHEADER *pSrcInfo = (VIDEOINFOHEADER *) pSrc-&gt;Format(); <br>    if (ContainsPalette(pSrcInfo) == FALSE) { <br>        NOTE("No source palette"); <br>        return S_FALSE; <br>    } <br> <br>    // The number of colours may be zero filled <br> <br>    DWORD PaletteEntries = pSrcInfo-&gt;bmiHeader.biClrUsed; <br>    if (PaletteEntries == 0) { <br>        DWORD Maximum  = (1 &lt;&lt; pSrcInfo-&gt;bmiHeader.biBitCount); <br>        NOTE1("Setting maximum colours (%d)",Maximum); <br>        PaletteEntries = Maximum; <br>    } <br> <br>    // Make sure the destination has enough room for the palette <br> <br>    ASSERT(pSrcInfo-&gt;bmiHeader.biClrUsed &lt;= iPALETTE_COLORS); <br>    ASSERT(pSrcInfo-&gt;bmiHeader.biClrImportant &lt;= PaletteEntries); <br>    ASSERT(COLORS(pDestInfo) == GetBitmapPalette(pDestInfo)); <br>    pDestInfo-&gt;bmiHeader.biClrUsed = PaletteEntries; <br>    pDestInfo-&gt;bmiHeader.biClrImportant = pSrcInfo-&gt;bmiHeader.biClrImportant; <br>    ULONG BitmapSize = GetBitmapFormatSize(HEADER(pSrcInfo)); <br> <br>    if (pDest-&gt;FormatLength() &lt; BitmapSize) { <br>        NOTE("Reallocating destination"); <br>        pDest-&gt;ReallocFormatBuffer(BitmapSize); <br>    } <br> <br>    // Now copy the palette colours across <br> <br>    CopyMemory((PVOID) COLORS(pDestInfo), <br>               (PVOID) GetBitmapPalette(pSrcInfo), <br>               PaletteEntries * sizeof(RGBQUAD)); <br> <br>    return NOERROR; <br>} <br> <br> <br>// This is normally called when the palette is changed (typically during a <br>// dynamic format change) to remove any palette we previously installed. We <br>// replace it (if necessary) in the video window with a standard VGA palette <br>// that should always be available even if this is a true colour display <br> <br>HRESULT CImagePalette::RemovePalette() <br>{ <br>    // Do we have a palette to remove <br> <br>    if (m_hPalette == NULL) { <br>        return NOERROR; <br>    } <br> <br>    // Get a standard VGA colour palette <br> <br>    HPALETTE hPalette = (HPALETTE) GetStockObject(DEFAULT_PALETTE); <br>    ASSERT(hPalette); <br>    const HPALETTE hPalOurs = m_hPalette; <br> <br>    // Install the standard palette and delete ours. As in the previous method <br>    // we may not have been given a window in the constructor to use and if we <br>    // didn't then don't try to install the stock palette in it. This is used <br>    // by filters that have to create palettes but who do not draw using GDI <br> <br>    if (m_pBaseWindow) { <br>        SelectPalette(m_pBaseWindow-&gt;GetWindowHDC(), hPalette, TRUE); <br>        SelectPalette(m_pBaseWindow-&gt;GetMemoryHDC(), hPalette, TRUE); <br>    } <br> <br>    EXECUTE_ASSERT(DeleteObject(hPalOurs)); <br>    m_hPalette = NULL; <br>    return NOERROR; <br>} <br> <br> <br>// Called to create a palette for the object, the data structure used by GDI <br>// to describe a palette is a LOGPALETTE, this includes a variable number of <br>// PALETTEENTRY fields which are the colours, we have to convert the RGBQUAD <br>// colour fields we are handed in a BITMAPINFO from the media type into these <br>// This handles extraction of palettes from true colour and YUV media formats <br> <br>// We can be passed an optional device name if we wish to prepare a palette <br>// for a specific monitor on a multi monitor system <br> <br>HPALETTE CImagePalette::MakePalette(const VIDEOINFOHEADER *pVideoInfo, LPSTR szDevice) <br>{ <br>    ASSERT(ContainsPalette(pVideoInfo) == TRUE); <br>    ASSERT(pVideoInfo-&gt;bmiHeader.biClrUsed &gt;= 0); <br>    ASSERT(pVideoInfo-&gt;bmiHeader.biClrUsed &lt;= iPALETTE_COLORS); <br>    BITMAPINFOHEADER *pHeader = HEADER(pVideoInfo); <br> <br>    const RGBQUAD *pColours;            // Pointer to the palette <br>    LOGPALETTE *lp;                     // Used to create a palette <br>    HPALETTE hPalette;                  // Logical palette object <br> <br>    lp = (LOGPALETTE *) new BYTE[sizeof(LOGPALETTE) + SIZE_PALETTE]; <br>    if (lp == NULL) { <br>        return NULL; <br>    } <br> <br>    // Unfortunately for some hare brained reason a GDI palette entry (a <br>    // PALETTEENTRY structure) is different to a palette entry from a DIB <br>    // format (a RGBQUAD structure) so we have to do the field conversion <br>    // The VIDEOINFO containing the palette may be a true colour type so <br>    // we use GetBitmapPalette to skip over any bit fields if they exist <br> <br>    lp-&gt;palVersion = PALVERSION; <br>    lp-&gt;palNumEntries = (USHORT) pHeader-&gt;biClrUsed; <br>    if (lp-&gt;palNumEntries == 0) lp-&gt;palNumEntries = (1 &lt;&lt; pHeader-&gt;biBitCount); <br>    pColours = GetBitmapPalette(pVideoInfo); <br> <br>    for (DWORD dwCount = 0;dwCount &lt; lp-&gt;palNumEntries;dwCount++) { <br>        lp-&gt;palPalEntry[dwCount].peRed = pColours[dwCount].rgbRed; <br>        lp-&gt;palPalEntry[dwCount].peGreen = pColours[dwCount].rgbGreen; <br>        lp-&gt;palPalEntry[dwCount].peBlue = pColours[dwCount].rgbBlue; <br>        lp-&gt;palPalEntry[dwCount].peFlags = 0; <br>    } <br> <br>    MakeIdentityPalette(lp-&gt;palPalEntry, lp-&gt;palNumEntries, szDevice); <br> <br>    // Create a logical palette <br> <br>    hPalette = CreatePalette(lp); <br>    ASSERT(hPalette != NULL); <br>    delete[] lp; <br>    return hPalette; <br>} <br> <br> <br>// GDI does a fair job of compressing the palette entries you give it, so for <br>// example if you have five entries with an RGB colour (0,0,0) it will remove <br>// all but one of them. When you subsequently draw an image it will map from <br>// your logical palette to the compressed device palette. This function looks <br>// to see if it is trying to be an identity palette and if so sets the flags <br>// field in the PALETTEENTRYs so they remain expanded to boost performance <br> <br>// We can be passed an optional device name if we wish to prepare a palette <br>// for a specific monitor on a multi monitor system <br> <br>HRESULT CImagePalette::MakeIdentityPalette(PALETTEENTRY *pEntry,INT iColours, LPSTR szDevice) <br>{ <br>    PALETTEENTRY SystemEntries[10];         // System palette entries <br>    BOOL bIdentityPalette = TRUE;           // Is an identity palette <br>    ASSERT(iColours &lt;= iPALETTE_COLORS);    // Should have a palette <br>    const int PalLoCount = 10;              // First ten reserved colours <br>    const int PalHiStart = 246;             // Last VGA palette entries <br> <br>    // Does this have the full colour range <br> <br>    if (iColours &lt; 10) { <br>        return S_FALSE; <br>    } <br> <br>    // Apparently some displays have odd numbers of system colours <br> <br>    // Get a DC on the right monitor - it's ugly, but this is the way you have <br>    // to do it <br>    HDC hdc; <br>    if (szDevice == NULL || lstrcmpiA(szDevice, "DISPLAY") == 0) <br>        hdc = CreateDCA("DISPLAY", NULL, NULL, NULL); <br>    else <br>        hdc = CreateDCA(NULL, szDevice, NULL, NULL); <br>    ASSERT(hdc); <br>    INT Reserved = GetDeviceCaps(hdc,NUMRESERVED); <br>    if (Reserved != 20) { <br>        DeleteDC(hdc); <br>        return S_FALSE; <br>    } <br> <br>    // Compare our palette against the first ten system entries. The reason I <br>    // don't do a memory compare between our two arrays of colours is because <br>    // I am not sure what will be in the flags fields for the system entries <br> <br>    UINT Result = GetSystemPaletteEntries(hdc,0,PalLoCount,SystemEntries); <br>    for (UINT Count = 0;Count &lt; Result;Count++) { <br>        if (SystemEntries[Count].peRed != pEntry[Count].peRed || <br>                SystemEntries[Count].peGreen != pEntry[Count].peGreen || <br>                    SystemEntries[Count].peBlue != pEntry[Count].peBlue) { <br>                        bIdentityPalette = FALSE; <br>        } <br>    } <br> <br>    // And likewise compare against the last ten entries <br> <br>    Result = GetSystemPaletteEntries(hdc,PalHiStart,PalLoCount,SystemEntries); <br>    for (Count = 0;Count &lt; Result;Count++) { <br>        if (INT(Count) + PalHiStart &lt; iColours) { <br>            if (SystemEntries[Count].peRed != pEntry[PalHiStart + Count].peRed || <br>                    SystemEntries[Count].peGreen != pEntry[PalHiStart + Count].peGreen || <br>                        SystemEntries[Count].peBlue != pEntry[PalHiStart + Count].peBlue) { <br>                            bIdentityPalette = FALSE; <br>            } <br>        } <br>    } <br> <br>    // If not an identity palette then return S_FALSE <br> <br>    DeleteDC(hdc); <br>    if (bIdentityPalette == FALSE) { <br>        return S_FALSE; <br>    } <br> <br>    // Set the non VGA entries so that GDI doesn't map them <br> <br>    for (Count = PalLoCount;INT(Count) &lt; min(PalHiStart,iColours);Count++) { <br>        pEntry[Count].peFlags = PC_NOCOLLAPSE; <br>    } <br>    return NOERROR; <br>} <br> <br> <br>// Constructor initialises the VIDEOINFO we keep storing the current display <br>// format. The format can be changed at any time, to reset the format held <br>// by us call the RefreshDisplayType directly (it's a public method). Since <br>// more than one thread will typically call us (ie window threads resetting <br>// the type and source threads in the type checking methods) we have a lock <br> <br>CImageDisplay::CImageDisplay() <br>{ <br>    RefreshDisplayType(NULL); <br>} <br> <br> <br> <br>// This initialises the format we hold which contains the display device type <br>// We do a conversion on the display device type in here so that when we start <br>// type checking input formats we can assume that certain fields have been set <br>// correctly, an example is when we make the 16 bit mask fields explicit. This <br>// is normally called when we receive WM_DEVMODECHANGED device change messages <br> <br>// The optional szDeviceName parameter tells us which monitor we are interested <br>// in for a multi monitor system <br> <br>HRESULT CImageDisplay::RefreshDisplayType(LPSTR szDeviceName) <br>{ <br>    CAutoLock cDisplayLock(this); <br> <br>    // Set the preferred format type <br> <br>    ZeroMemory((PVOID)&amp;m_Display,sizeof(VIDEOINFOHEADER)+sizeof(TRUECOLORINFO)); <br>    m_Display.bmiHeader.biSize = sizeof(BITMAPINFOHEADER); <br>    m_Display.bmiHeader.biBitCount = FALSE; <br> <br>    // Get the bit depth of a device compatible bitmap <br> <br>    // get caps of whichever monitor they are interested in (multi monitor) <br>    HDC hdcDisplay; <br>    // it's ugly, but this is the way you have to do it <br>    if (szDeviceName == NULL || lstrcmpiA(szDeviceName, "DISPLAY") == 0) <br>        hdcDisplay = CreateDCA("DISPLAY", NULL, NULL, NULL); <br>    else <br>        hdcDisplay = CreateDCA(NULL, szDeviceName, NULL, NULL); <br>    if (hdcDisplay == NULL) { <br>ASSERT(FALSE); <br>DbgLog((LOG_ERROR,1,TEXT("ACK! Can't get a DC for %s"), <br>szDeviceName ? szDeviceName : "&lt;NULL&gt;")); <br>return E_FAIL; <br>    } else { <br>DbgLog((LOG_TRACE,3,TEXT("Created a DC for %s"), <br>szDeviceName ? szDeviceName : "&lt;NULL&gt;")); <br>    } <br>    HBITMAP hbm = CreateCompatibleBitmap(hdcDisplay,1,1); <br>    GetDIBits(hdcDisplay,hbm,0,1,NULL,(BITMAPINFO *)&amp;m_Display.bmiHeader,DIB_RGB_COLORS); <br> <br>    // This call will get the colour table or the proper bitfields <br>    GetDIBits(hdcDisplay,hbm,0,1,NULL,(BITMAPINFO *)&amp;m_Display.bmiHeader,DIB_RGB_COLORS); <br>    DeleteObject(hbm); <br>    DeleteDC(hdcDisplay); <br> <br>    // Complete the display type initialisation <br> <br>    ASSERT(CheckHeaderValidity(&amp;m_Display)); <br>    UpdateFormat(&amp;m_Display); <br>    DbgLog((LOG_TRACE,3,TEXT("New DISPLAY bit depth =%d"), <br>m_Display.bmiHeader.biBitCount)); <br>    return NOERROR; <br>} <br> <br> <br>// We assume throughout this code that any bitfields masks are allowed no <br>// more than eight bits to store a colour component. This checks that the <br>// bit count assumption is enforced and also makes sure that all the bits <br>// set are contiguous. We return a boolean TRUE if the field checks out ok <br> <br>BOOL CImageDisplay::CheckBitFields(const VIDEOINFO *pInput) <br>{ <br>    DWORD *pBitFields = (DWORD *) BITMASKS(pInput); <br> <br>    for (INT iColour = iRED;iColour &lt;= iBLUE;iColour++) { <br> <br>        // First of all work out how many bits are set <br> <br>        DWORD SetBits = CountSetBits(pBitFields[iColour]); <br>        if (SetBits &gt; iMAXBITS || SetBits == 0) { <br>            NOTE1("Bit fields for component %d invalid",iColour); <br>            return FALSE; <br>        } <br> <br>        // Next work out the number of zero bits prefix <br>        DWORD PrefixBits = CountPrefixBits(pBitFields[iColour]); <br> <br>        // This is going to see if all the bits set are contiguous (as they <br>        // should be). We know how much to shift them right by from the <br>        // count of prefix bits. The number of bits set defines a mask, we <br>        // invert this (ones complement) and AND it with the shifted bit <br>        // fields. If the result is NON zero then there are bit(s) sticking <br>        // out the left hand end which means they are not contiguous <br> <br>        DWORD TestField = pBitFields[iColour] &gt;&gt; PrefixBits; <br>        DWORD Mask = ULONG_MAX &lt;&lt; SetBits; <br>        if (TestField &amp; Mask) { <br>            NOTE1("Bit fields for component %d not contiguous",iColour); <br>            return FALSE; <br>        } <br>    } <br>    return TRUE; <br>} <br> <br> <br>// This counts the number of bits set in the input field <br> <br>DWORD CImageDisplay::CountSetBits(DWORD Field) <br>{ <br>    // This is a relatively well known bit counting algorithm <br> <br>    DWORD Count = 0; <br>    DWORD init = Field; <br> <br>    // Until the input is exhausted, count the number of bits <br> <br>    while (init) { <br>        init = init &amp; (init - 1);  // Turn off the bottommost bit <br>        Count++; <br>    } <br>    return Count; <br>} <br> <br> <br>// This counts the number of zero bits upto the first one set NOTE the input <br>// field should have been previously checked to ensure there is at least one <br>// set although if we don't find one set we return the impossible value 32 <br> <br>DWORD CImageDisplay::CountPrefixBits(DWORD Field) <br>{ <br>    DWORD Mask = 1; <br>    DWORD Count = 0; <br> <br>    while (TRUE) { <br>        if (Field &amp; Mask) { <br>            return Count; <br>        } <br>        Count++; <br> <br>        ASSERT(Mask != 0x80000000); <br>        if (Mask == 0x80000000) { <br>            return Count; <br>        } <br>        Mask &lt;&lt;= 1; <br>    } <br>} <br> <br> <br>// This is called to check the BITMAPINFOHEADER for the input type. There are <br>// many implicit dependancies between the fields in a header structure which <br>// if we validate now make for easier manipulation in subsequent handling. We <br>// also check that the BITMAPINFOHEADER matches it's specification such that <br>// fields likes the number of planes is one, that it's structure size is set <br>// correctly and that the bitmap dimensions have not been set as negative <br> <br>BOOL CImageDisplay::CheckHeaderValidity(const VIDEOINFO *pInput) <br>{ <br>    // Check the bitmap width and height are not negative. <br> <br>    if (pInput-&gt;bmiHeader.biWidth &lt;= 0 || <br>pInput-&gt;bmiHeader.biHeight &lt;= 0) { <br>        NOTE("Invalid bitmap dimensions"); <br>        return FALSE; <br>    } <br> <br>    // Check the compression is either BI_RGB or BI_BITFIELDS <br> <br>    if (pInput-&gt;bmiHeader.biCompression != BI_RGB) { <br>        if (pInput-&gt;bmiHeader.biCompression != BI_BITFIELDS) { <br>            NOTE("Invalid compression format"); <br>            return FALSE; <br>        } <br>    } <br> <br>    // If BI_BITFIELDS compression format check the colour depth <br> <br>    if (pInput-&gt;bmiHeader.biCompression == BI_BITFIELDS) { <br>        if (pInput-&gt;bmiHeader.biBitCount != 16) { <br>            if (pInput-&gt;bmiHeader.biBitCount != 32) { <br>                NOTE("BI_BITFIELDS not 16/32 bit depth"); <br>                return FALSE; <br>            } <br>        } <br>    } <br> <br>    // Check the assumptions about the layout of the bit fields <br> <br>    if (pInput-&gt;bmiHeader.biCompression == BI_BITFIELDS) { <br>        if (CheckBitFields(pInput) == FALSE) { <br>            NOTE("Bit fields are not valid"); <br>            return FALSE; <br>        } <br>    } <br> <br>    // Are the number of planes equal to one <br> <br>    if (pInput-&gt;bmiHeader.biPlanes != 1) { <br>        NOTE("Number of planes not one"); <br>        return FALSE; <br>    } <br> <br>    // Check the image size is consistent (it can be zero) <br> <br>    if (pInput-&gt;bmiHeader.biSizeImage != GetBitmapSize(&amp;pInput-&gt;bmiHeader)) { <br>        if (pInput-&gt;bmiHeader.biSizeImage) { <br>            NOTE("Image size incorrectly set"); <br>            return FALSE; <br>        } <br>    } <br> <br>    // Check the size of the structure <br> <br>    if (pInput-&gt;bmiHeader.biSize != sizeof(BITMAPINFOHEADER)) { <br>        NOTE("Size of BITMAPINFOHEADER wrong"); <br>        return FALSE; <br>    } <br>    return CheckPaletteHeader(pInput); <br>} <br> <br> <br>// This runs a few simple tests against the palette fields in the input to <br>// see if it looks vaguely correct. The tests look at the number of palette <br>// colours present, the number considered important and the biCompression <br>// field which should always be BI_RGB as no other formats are meaningful <br> <br>BOOL CImageDisplay::CheckPaletteHeader(const VIDEOINFO *pInput) <br>{ <br>    // The checks here are for palettised videos only <br> <br>    if (PALETTISED(pInput) == FALSE) { <br>        if (pInput-&gt;bmiHeader.biClrUsed) { <br>            NOTE("Invalid palette entries"); <br>            return FALSE; <br>        } <br>        return TRUE; <br>    } <br> <br>    // Compression type of BI_BITFIELDS is meaningless for palette video <br> <br>    if (pInput-&gt;bmiHeader.biCompression != BI_RGB) { <br>        NOTE("Palettised video must be BI_RGB"); <br>        return FALSE; <br>    } <br> <br>    // Check the number of palette colours is correct <br> <br>    if (pInput-&gt;bmiHeader.biClrUsed &gt; PALETTE_ENTRIES(pInput)) { <br>        NOTE("Too many colours in palette"); <br>        return FALSE; <br>    } <br> <br>    // The number of important colours shouldn't exceed the number used <br> <br>    if (pInput-&gt;bmiHeader.biClrImportant &gt; pInput-&gt;bmiHeader.biClrUsed) { <br>        NOTE("Too many important colours"); <br>        return FALSE; <br>    } <br>    return TRUE; <br>} <br> <br> <br>// Return the format of the video display <br> <br>const VIDEOINFO *CImageDisplay::GetDisplayFormat() <br>{ <br>    return &amp;m_Display; <br>} <br> <br> <br>// Return TRUE if the display uses a palette <br> <br>BOOL CImageDisplay::IsPalettised() <br>{ <br>    return PALETTISED(&amp;m_Display); <br>} <br> <br> <br>// Return the bit depth of the current display setting <br> <br>WORD CImageDisplay::GetDisplayDepth() <br>{ <br>    return m_Display.bmiHeader.biBitCount; <br>} <br> <br> <br>// Initialise the optional fields in a VIDEOINFO. These are mainly to do with <br>// the source and destination rectangles and palette information such as the <br>// number of colours present. It simplifies our code just a little if we don't <br>// have to keep checking for all the different valid permutations in a header <br>// every time we want to do anything with it (an example would be creating a <br>// palette). We set the base class media type before calling this function so <br>// that the media types between the pins match after a connection is made <br> <br>HRESULT CImageDisplay::UpdateFormat(VIDEOINFO *pVideoInfo) <br>{ <br>    ASSERT(pVideoInfo); <br> <br>    BITMAPINFOHEADER *pbmi = HEADER(pVideoInfo); <br>    SetRectEmpty(&amp;pVideoInfo-&gt;rcSource); <br>    SetRectEmpty(&amp;pVideoInfo-&gt;rcTarget); <br> <br>    // Set the number of colours explicitly <br> <br>    if (PALETTISED(pVideoInfo)) { <br>        if (pVideoInfo-&gt;bmiHeader.biClrUsed == 0) { <br>            pVideoInfo-&gt;bmiHeader.biClrUsed = PALETTE_ENTRIES(pVideoInfo); <br>        } <br>    } <br> <br>    // The number of important colours shouldn't exceed the number used, on <br>    // some displays the number of important colours is not initialised when <br>    // retrieving the display type so we set the colours used correctly <br> <br>    if (pVideoInfo-&gt;bmiHeader.biClrImportant &gt; pVideoInfo-&gt;bmiHeader.biClrUsed) { <br>        pVideoInfo-&gt;bmiHeader.biClrImportant = PALETTE_ENTRIES(pVideoInfo); <br>    } <br> <br>    // Change the image size field to be explicit <br> <br>    if (pVideoInfo-&gt;bmiHeader.biSizeImage == 0) { <br>        pVideoInfo-&gt;bmiHeader.biSizeImage = GetBitmapSize(&amp;pVideoInfo-&gt;bmiHeader); <br>    } <br>    return NOERROR; <br>} <br> <br> <br>// Lots of video rendering filters want code to check proposed formats are ok <br>// This checks the VIDEOINFO we are passed as a media type. If the media type <br>// is a valid media type then we return NOERROR otherwise E_INVALIDARG. Note <br>// however we only accept formats that can be easily displayed in the display <br>// so if we are on a 16 bit device we will not accept 24 bit images. The one <br>// complexity is that most displays draw 8 bit palettised images efficiently <br>// Also if the input format is less colour bits per pixel then we also accept <br> <br>HRESULT CImageDisplay::CheckVideoType(const VIDEOINFO *pInput) <br>{ <br>    // First of all check the VIDEOINFOHEADER looks correct <br> <br>    if (CheckHeaderValidity(pInput) == FALSE) { <br>        return E_INVALIDARG; <br>    } <br> <br>    // Virtually all devices support palettised images efficiently <br> <br>    if (m_Display.bmiHeader.biBitCount == pInput-&gt;bmiHeader.biBitCount) { <br>        if (PALETTISED(pInput) == TRUE) { <br>            ASSERT(PALETTISED(&amp;m_Display) == TRUE); <br>            NOTE("(Video) Type connection ACCEPTED"); <br>            return NOERROR; <br>        } <br>    } <br> <br>    // Is the display depth greater than the input format <br> <br>    if (m_Display.bmiHeader.biBitCount &gt; pInput-&gt;bmiHeader.biBitCount) { <br>        NOTE("(Video) Mismatch agreed"); <br>        return NOERROR; <br>    } <br> <br>    // Is the display depth less than the input format <br> <br>    if (m_Display.bmiHeader.biBitCount &lt; pInput-&gt;bmiHeader.biBitCount) { <br>        NOTE("(Video) Format mismatch"); <br>        return E_INVALIDARG; <br>    } <br> <br>    // Both input and display formats are either BI_RGB or BI_BITFIELDS <br> <br>    ASSERT(m_Display.bmiHeader.biBitCount == pInput-&gt;bmiHeader.biBitCount); <br>    ASSERT(PALETTISED(pInput) == FALSE); <br>    ASSERT(PALETTISED(&amp;m_Display) == FALSE); <br> <br>    // BI_RGB 16 bit representation is implicitly RGB555, and likewise BI_RGB <br>    // 24 bit representation is RGB888. So we initialise a pointer to the bit <br>    // fields they really mean and check against the display device format <br>    // This is only going to be called when both formats are equal bits pixel <br> <br>    const DWORD *pInputMask = GetBitMasks(pInput); <br>    const DWORD *pDisplayMask = GetBitMasks((VIDEOINFO *)&amp;m_Display); <br> <br>    if (pInputMask[iRED] != pDisplayMask[iRED] || <br>            pInputMask[iGREEN] != pDisplayMask[iGREEN] || <br>                pInputMask[iBLUE] != pDisplayMask[iBLUE]) { <br> <br>        NOTE("(Video) Bit field mismatch"); <br>        return E_INVALIDARG; <br>    } <br> <br>    NOTE("(Video) Type connection ACCEPTED"); <br>    return NOERROR; <br>} <br> <br> <br>// Return the bit masks for the true colour VIDEOINFO provided <br> <br>const DWORD *CImageDisplay::GetBitMasks(const VIDEOINFO *pVideoInfo) <br>{ <br>    static const DWORD FailMasks[] = {0,0,0}; <br> <br>    if (pVideoInfo-&gt;bmiHeader.biCompression == BI_BITFIELDS) { <br>        return BITMASKS(pVideoInfo); <br>    } <br> <br>    ASSERT(pVideoInfo-&gt;bmiHeader.biCompression == BI_RGB); <br> <br>    switch (pVideoInfo-&gt;bmiHeader.biBitCount) { <br>        case 16: return bits555; <br>        case 24: return bits888; <br>        case 32: return bits888; <br>        default: return FailMasks; <br>    } <br>} <br> <br> <br>// Check to see if we can support media type pmtIn as proposed by the output <br>// pin - We first check that the major media type is video and also identify <br>// the media sub type. Then we thoroughly check the VIDEOINFO type provided <br>// As well as the contained VIDEOINFO being correct the major type must be <br>// video, the subtype a recognised video format and the type GUID correct <br> <br>HRESULT CImageDisplay::CheckMediaType(const CMediaType *pmtIn) <br>{ <br>    // Does this have a VIDEOINFOHEADER format block <br> <br>    const GUID *pFormatType = pmtIn-&gt;FormatType(); <br>    if (*pFormatType != FORMAT_VideoInfo) { <br>        NOTE("Format GUID not a VIDEOINFOHEADER"); <br>        return E_INVALIDARG; <br>    } <br>    ASSERT(pmtIn-&gt;Format()); <br> <br>    // Check the format looks reasonably ok <br> <br>    ULONG Length = pmtIn-&gt;FormatLength(); <br>    if (Length &lt; SIZE_VIDEOHEADER) { <br>        NOTE("Format smaller than a VIDEOHEADER"); <br>        return E_FAIL; <br>    } <br> <br>    VIDEOINFO *pInput = (VIDEOINFO *) pmtIn-&gt;Format(); <br> <br>    // Check the major type is MEDIATYPE_Video <br> <br>    const GUID *pMajorType = pmtIn-&gt;Type(); <br>    if (*pMajorType != MEDIATYPE_Video) { <br>        NOTE("Major type not MEDIATYPE_Video"); <br>        return E_INVALIDARG; <br>    } <br> <br>    // Check we can identify the media subtype <br> <br>    const GUID *pSubType = pmtIn-&gt;Subtype(); <br>    if (GetBitCount(pSubType) == USHRT_MAX) { <br>        NOTE("Invalid video media subtype"); <br>        return E_INVALIDARG; <br>    } <br>    return CheckVideoType(pInput); <br>} <br> <br> <br>// Given a video format described by a VIDEOINFO structure we return the mask <br>// that is used to obtain the range of acceptable colours for this type, for <br>// example, the mask for a 24 bit true colour format is 0xFF in all cases. A <br>// 16 bit 5:6:5 display format uses 0xF8, 0xFC and 0xF8, therefore given any <br>// RGB triplets we can AND them with these fields to find one that is valid <br> <br>BOOL CImageDisplay::GetColourMask(DWORD *pMaskRed, <br>                                  DWORD *pMaskGreen, <br>                                  DWORD *pMaskBlue) <br>{ <br>    CAutoLock cDisplayLock(this); <br>    *pMaskRed = 0xFF; <br>    *pMaskGreen = 0xFF; <br>    *pMaskBlue = 0xFF; <br> <br>    // If this format is palettised then it doesn't have bit fields <br> <br>    if (m_Display.bmiHeader.biBitCount &lt; 16) { <br>        return FALSE; <br>    } <br> <br>    // If this is a 24 bit true colour display then it can handle all the <br>    // possible colour component ranges described by a byte. It is never <br>    // allowed for a 24 bit colour depth image to have BI_BITFIELDS set <br> <br>    if (m_Display.bmiHeader.biBitCount == 24) { <br>        ASSERT(m_Display.bmiHeader.biCompression == BI_RGB); <br>        return TRUE; <br>    } <br> <br>    // Calculate the mask based on the format's bit fields <br> <br>    const DWORD *pBitFields = (DWORD *) GetBitMasks((VIDEOINFO *)&amp;m_Display); <br>    DWORD *pOutputMask[] = { pMaskRed, pMaskGreen, pMaskBlue }; <br> <br>    // We know from earlier testing that there are no more than iMAXBITS <br>    // bits set in the mask and that they are all contiguous. All that <br>    // therefore remains is to shift them into the correct position <br> <br>    for (INT iColour = iRED;iColour &lt;= iBLUE;iColour++) { <br> <br>        // This works out how many bits there are and where they live <br> <br>        DWORD PrefixBits = CountPrefixBits(pBitFields[iColour]); <br>        DWORD SetBits = CountSetBits(pBitFields[iColour]); <br> <br>        // The first shift moves the bit field so that it is right justified <br>        // in the DWORD, after which we then shift it back left which then <br>        // puts the leading bit in the bytes most significant bit position <br> <br>        *(pOutputMask[iColour]) = pBitFields[iColour] &gt;&gt; PrefixBits; <br>        *(pOutputMask[iColour]) &lt;&lt;= (iMAXBITS - SetBits); <br>    } <br>    return TRUE; <br>} <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
