<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WXDEBUG.H</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2790"></a>WXDEBUG.H</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>// Debugging facilities, January 1995 <br> <br>#ifndef __WXDEBUG__ <br>#define __WXDEBUG__ <br> <br>// This library provides fairly straight forward debugging functionality, this <br>// is split into two main sections. The first is assertion handling, there are <br>// three types of assertions provided here. The most commonly used one is the <br>// ASSERT(condition) macro which will pop up a message box including the file <br>// and line number if the condition evaluates to FALSE. Then there is the <br>// EXECUTE_ASSERT macro which is the same as ASSERT except the condition will <br>// still be executed in NON debug builds. The final type of assertion is the <br>// KASSERT macro which is more suitable for pure (perhaps kernel) filters as <br>// the condition is printed onto the debugger rather than in a message box. <br>// <br>// The other part of the debug module facilties is general purpose logging. <br>// This is accessed by calling DbgLog(). The function takes a type and level <br>// field which define the type of informational string you are presenting and <br>// it's relative importance. The type field can be a combination (one or more) <br>// of LOG_TIMING, LOG_TRACE, LOG_MEMORY, LOG_LOCKING and LOG_ERROR. The level <br>// is a DWORD value where zero defines highest important. Use of zero as the <br>// debug logging level is to be encouraged ONLY for major errors or events as <br>// they will ALWAYS be displayed on the debugger. Other debug output has it's <br>// level matched against the current debug output level stored in the registry <br>// for this module and if less than the current setting it will be displayed. <br>// <br>// Each module or executable has it's own debug output level for each of the <br>// five types. These are read in when the DbgInitialise function is called <br>// for DLLs linking to STRMBASE.LIB this is done automatically when the DLL <br>// is loaded, executables must call it explicitely with the module instance <br>// handle given to them through the WINMAIN entry point. An executable must <br>// also call DbgTerminate when they have finished to clean up the resources <br>// the debug library uses, once again this is done automatically for DLLs <br> <br>// These are the five different categories of logging information <br> <br>enum {  LOG_TIMING = 0x01,    // Timing and performance measurements <br>        LOG_TRACE = 0x02,     // General step point call tracing <br>        LOG_MEMORY =  0x04,   // Memory and object allocation/destruction <br>        LOG_LOCKING = 0x08,   // Locking/unlocking of critical sections <br>        LOG_ERROR = 0x10 };   // Debug error notification <br> <br>enum {  CDISP_HEX = 0x01, <br>        CDISP_DEC = 0x02}; <br> <br>// For each object created derived from CBaseObject (in debug builds) we <br>// create a descriptor that holds it's name (statically allocated memory) <br>// and a cookie we assign it. We keep a list of all the active objects <br>// we have registered so that we can dump a list of remaining objects <br> <br>typedef struct tag_ObjectDesc { <br>    const TCHAR *m_pName; <br>    DWORD m_dwCookie; <br>    tag_ObjectDesc *m_pNext; <br>} ObjectDesc; <br> <br>#define DLLIMPORT __declspec(dllimport) <br>#define DLLEXPORT __declspec(dllexport) <br> <br>#ifdef DEBUG <br> <br>    #define NAME(x) TEXT(x) <br> <br>    // These are used internally by the debug library (PRIVATE) <br> <br>    void WINAPI DbgInitKeyLevels(HKEY hKey); <br>    void WINAPI DbgInitGlobalSettings(); <br>    void WINAPI DbgInitModuleSettings(); <br>    void WINAPI DbgInitModuleName(); <br>    DWORD WINAPI DbgRegisterObjectCreation(const TCHAR *pObjectName); <br>    BOOL WINAPI DbgRegisterObjectDestruction(DWORD dwCookie); <br> <br>    // These are the PUBLIC entry points <br> <br>    BOOL WINAPI DbgCheckModuleLevel(DWORD Type,DWORD Level); <br>    void WINAPI DbgSetModuleLevel(DWORD Type,DWORD Level); <br> <br>    // Initialise the library with the module handle <br> <br>    void WINAPI DbgInitialise(HINSTANCE hInst); <br>    void WINAPI DbgTerminate(); <br> <br>    void WINAPI DbgDumpObjectRegister(); <br> <br>    // Display error and logging to the user <br> <br>    void WINAPI DbgAssert(const TCHAR *pCondition,const TCHAR *pFileName,INT iLine); <br>    void WINAPI DbgBreakPoint(const TCHAR *pCondition,const TCHAR *pFileName,INT iLine); <br>    void WINAPI DbgKernelAssert(const TCHAR *pCondition,const TCHAR *pFileName,INT iLine); <br>    void WINAPI DbgLogInfo(DWORD Type,DWORD Level,const TCHAR *pFormat,...); <br>    void WINAPI DbgOutString(LPCTSTR psz); <br> <br>    //  Debug infinite wait stuff <br>    DWORD WINAPI DbgWaitForSingleObject(HANDLE h); <br>    DWORD WINAPI DbgWaitForMultipleObjects(DWORD nCount, <br>                                    CONST HANDLE *lpHandles, <br>                                    BOOL bWaitAll); <br>    void WINAPI DbgSetWaitTimeout(DWORD dwTimeout); <br> <br>#ifdef __strmif_h__ <br>    // Display a media type: Terse at level 2, verbose at level 5 <br>    void WINAPI DisplayType(LPSTR label, const AM_MEDIA_TYPE *pmtIn); <br> <br>    // Dump lots of information about a filter graph <br>    void WINAPI DumpGraph(IFilterGraph *pGraph, DWORD dwLevel); <br>#endif <br> <br>    #define KASSERT(_x_) if (!(_x_))         \ <br>        DbgKernelAssert(TEXT(#_x_),TEXT(__FILE__),__LINE__) <br> <br>    //  Break on the debugger without putting up a message box <br>    //  message goes to debugger instead <br> <br>    #define KDbgBreak(_x_)                   \ <br>        DbgKernelAssert(TEXT(#_x_),TEXT(__FILE__),__LINE__) <br> <br>    // We chose a common name for our ASSERT macro, MFC also uses this name <br>    // So long as the implementation evaluates the condition and handles it <br>    // then we will be ok. Rather than override the behaviour expected we <br>    // will leave whatever first defines ASSERT as the handler (i.e. MFC) <br>    #ifndef ASSERT <br>        #define ASSERT(_x_) if (!(_x_))         \ <br>            DbgAssert(TEXT(#_x_),TEXT(__FILE__),__LINE__) <br>    #endif <br> <br>    //  Put up a message box informing the user of a halt <br>    //  condition in the program <br> <br>    #define DbgBreak(_x_)                   \ <br>        DbgBreakPoint(TEXT(#_x_),TEXT(__FILE__),__LINE__) <br> <br>    #define EXECUTE_ASSERT(_x_) ASSERT(_x_) <br>    #define DbgLog(_x_) DbgLogInfo _x_ <br> <br>    // MFC style trace macros <br> <br>    #define NOTE(_x_)             DbgLog((LOG_TRACE,5,TEXT(_x_))); <br>    #define NOTE1(_x_,a)          DbgLog((LOG_TRACE,5,TEXT(_x_),a)); <br>    #define NOTE2(_x_,a,b)        DbgLog((LOG_TRACE,5,TEXT(_x_),a,b)); <br>    #define NOTE3(_x_,a,b,c)      DbgLog((LOG_TRACE,5,TEXT(_x_),a,b,c)); <br>    #define NOTE4(_x_,a,b,c,d)    DbgLog((LOG_TRACE,5,TEXT(_x_),a,b,c,d)); <br>    #define NOTE5(_x_,a,b,c,d,e)  DbgLog((LOG_TRACE,5,TEXT(_x_),a,b,c,d,e)); <br> <br>#else <br> <br>    // Retail builds make public debug functions inert  - WARNING the source <br>    // files do not define or build any of the entry points in debug builds <br>    // (public entry points compile to nothing) so if you go trying to call <br>    // any of the private entry points in your source they won't compile <br> <br>    #define NAME(_x_) NULL <br> <br>    #define DbgInitialise(hInst) <br>    #define DbgTerminate() <br>    #define DbgLog(_x_) <br>    #define DbgOutString(psz) <br> <br>    #define DbgRegisterObjectCreation(pObjectName) <br>    #define DbgRegisterObjectDestruction(dwCookie) <br>    #define DbgDumpObjectRegister() <br> <br>    #define DbgCheckModuleLevel(Type,Level) <br>    #define DbgSetModuleLevel(Type,Level) <br> <br>    #define DbgWaitForSingleObject(h)  WaitForSingleObject(h, INFINITE) <br>    #define DbgWaitForMultipleObjects(nCount, lpHandles, bWaitAll)     \ <br>               WaitForMultipleObjects(nCount, lpHandles, bWaitAll, INFINITE) <br>    #define DbgSetWaitTimeout(dwTimeout) <br> <br>    #define KDbgBreak(_x_) <br>    #define DbgBreak(_x_) <br> <br>    #define KASSERT(_x_) <br>    #ifndef ASSERT <br>#define ASSERT(_x_) <br>    #endif <br>    #define EXECUTE_ASSERT(_x_) _x_ <br> <br>    // MFC style trace macros <br> <br>    #define NOTE(_x_) <br>    #define NOTE1(_x_,a) <br>    #define NOTE2(_x_,a,b) <br>    #define NOTE3(_x_,a,b,c) <br>    #define NOTE4(_x_,a,b,c,d) <br>    #define NOTE5(_x_,a,b,c,d,e) <br> <br>    #define DisplayType(label, pmtIn) <br>    #define DumpGraph(pGraph, label) <br>#endif <br> <br> <br>// Checks a pointer which should be non NULL - can be used as follows. <br> <br>#define CheckPointer(p,ret) {if((p)==NULL) return (ret);} <br> <br>//   HRESULT Foo(VOID *pBar) <br>//   { <br>//       CheckPointer(pBar,E_INVALIDARG) <br>//   } <br>// <br>//   Or if the function returns a boolean <br>// <br>//   BOOL Foo(VOID *pBar) <br>//   { <br>//       CheckPointer(pBar,FALSE) <br>//   } <br> <br>// These validate pointers when symbol VFWROBUST is defined <br>// This will normally be defined in debug not retail builds <br> <br>#ifdef DEBUG <br>    #define VFWROBUST <br>#endif <br> <br>#ifdef VFWROBUST <br> <br>    #define ValidateReadPtr(p,cb) \ <br>        {if(IsBadReadPtr((PVOID)p,cb) == TRUE) \ <br>            DbgBreak("Invalid read pointer");} <br> <br>    #define ValidateWritePtr(p,cb) \ <br>        {if(IsBadWritePtr((PVOID)p,cb) == TRUE) \ <br>            DbgBreak("Invalid write pointer");} <br> <br>    #define ValidateReadWritePtr(p,cb) \ <br>        {ValidateReadPtr(p,cb) ValidateWritePtr(p,cb)} <br> <br>    #define ValidateStringPtr(p) \ <br>        {if(IsBadStringPtr((LPCTSTR)p,INFINITE) == TRUE) \ <br>            DbgBreak("Invalid string pointer");} <br> <br>    #define ValidateStringPtrA(p) \ <br>        {if(IsBadStringPtrA((LPCSTR)p,INFINITE) == TRUE) \ <br>            DbgBreak("Invalid ANSII string pointer");} <br> <br>    #define ValidateStringPtrW(p) \ <br>        {if(IsBadStringPtrW((LPCWSTR)p,INFINITE) == TRUE) \ <br>            DbgBreak("Invalid UNICODE string pointer");} <br> <br>#else <br>    #define ValidateReadPtr(p,cb) <br>    #define ValidateWritePtr(p,cb) <br>    #define ValidateReadWritePtr(p,cb) <br>    #define ValidateStringPtr(p) <br>    #define ValidateStringPtrA(p) <br>    #define ValidateStringPtrW(p) <br>#endif <br> <br> <br>#ifdef _OBJBASE_H_ <br> <br>    //  Outputting GUID names.  If you want to include the name <br>    //  associated with a GUID (eg CLSID_...) then <br>    // <br>    //      GuidNames[yourGUID] <br>    // <br>    //  Returns the name defined in uuids.h as a string <br> <br>    typedef struct { <br>        TCHAR   *szName; <br>        GUID    guid; <br>    } GUID_STRING_ENTRY; <br> <br>    class CGuidNameList { <br>    public: <br>        TCHAR *operator [] (const GUID&amp; guid); <br>    }; <br> <br>    extern CGuidNameList GuidNames; <br> <br>#endif <br> <br>#ifndef REMIND <br>    //  REMIND macro - generates warning as reminder to complete coding <br>    //  (eg) usage: <br>    // <br>    //  #pragma message (REMIND("Add automation support")) <br> <br> <br>    #define QUOTE(x) #x <br>    #define QQUOTE(y) QUOTE(y) <br>    #define REMIND(str) __FILE__ "(" QQUOTE(__LINE__) ") :  " str <br>#endif <br> <br>//  Hack to display objects in a useful format <br>// <br>//  eg If you want to display a LONGLONG ll in a debug string do (eg) <br>// <br>//  DbgLog((LOG_TRACE, n, TEXT("Value is %s"), (LPCTSTR)CDisp(ll, CDISP_HEX))); <br> <br> <br>class CDispBasic <br>{ <br>public: <br>    CDispBasic() { m_pString = m_String; }; <br>    ~CDispBasic(); <br>protected: <br>    PTCHAR m_pString;  // normally points to m_String... unless too much data <br>    TCHAR m_String[50]; <br>}; <br>class CDisp : public CDispBasic <br>{ <br>public: <br>    CDisp(LONGLONG ll, int Format = CDISP_HEX); // Display a LONGLONG in CDISP_HEX or CDISP_DEC form <br>    CDisp(REFCLSID clsid);      // Display a GUID <br>    CDisp(double d);            // Display a floating point number <br>#ifdef __strmif_h__ <br>#ifdef __STREAMS__ <br>    CDisp(CRefTime t);          // Display a Reference Time <br>#endif <br>    CDisp(IPin *pPin);          // Display a pin as {filter clsid}(pin name) <br>#endif // __strmif_h__ <br>    ~CDisp(); <br> <br>    //  Implement cast to (LPCTSTR) as parameter to logger <br>    operator LPCTSTR() <br>    { <br>        return (LPCTSTR)m_pString; <br>    }; <br>}; <br> <br>#endif // __WXDEBUG__ <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
