<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DLLSETUP.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2748"></a>DLLSETUP.CPP</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>#include &lt;streams.h&gt; <br> <br>//--------------------------------------------------------------------------- <br>// defines <br> <br>#define MAX_KEY_LEN  260 <br> <br> <br>//--------------------------------------------------------------------------- <br>// externally defined functions/variable <br> <br>extern int g_cTemplates; <br>extern CFactoryTemplate g_Templates[]; <br> <br>//--------------------------------------------------------------------------- <br>// <br>// EliminateSubKey <br>// <br>// Try to enumerate all keys under this one. <br>// if we find anything, delete it completely. <br>// Otherwise just delete it. <br>// <br>// note - this was pinched/duplicated from <br>// Filgraph\Mapper.cpp - so should it be in <br>// a lib somewhere? <br>// <br>//--------------------------------------------------------------------------- <br> <br>STDAPI <br>EliminateSubKey( HKEY hkey, LPTSTR strSubKey ) <br>{ <br>  HKEY hk; <br>  if (0 == lstrlen(strSubKey) ) { <br>      // defensive approach <br>      return E_FAIL; <br>  } <br> <br>  LONG lreturn = RegOpenKeyEx( hkey <br>                             , strSubKey <br>                             , 0 <br>                             , MAXIMUM_ALLOWED <br>                             , &amp;hk ); <br> <br>  ASSERT(    lreturn == ERROR_SUCCESS <br>          || lreturn == ERROR_FILE_NOT_FOUND <br>          || lreturn == ERROR_INVALID_HANDLE ); <br> <br>  if( ERROR_SUCCESS == lreturn ) <br>  { <br>    // Keep on enumerating the first (zero-th) <br>    // key and deleting that <br> <br>    for( ; ; ) <br>    { <br>      TCHAR Buffer[MAX_KEY_LEN]; <br>      DWORD dw = MAX_KEY_LEN; <br>      FILETIME ft; <br> <br>      lreturn = RegEnumKeyEx( hk <br>                            , 0 <br>                            , Buffer <br>                            , &amp;dw <br>                            , NULL <br>                            , NULL <br>                            , NULL <br>                            , &amp;ft); <br> <br>      ASSERT(    lreturn == ERROR_SUCCESS <br>              || lreturn == ERROR_NO_MORE_ITEMS ); <br> <br>      if( ERROR_SUCCESS == lreturn ) <br>      { <br>        EliminateSubKey(hk, Buffer); <br>      } <br>      else <br>      { <br>        break; <br>      } <br>    } <br> <br>    RegCloseKey(hk); <br>    RegDeleteKey(hkey, strSubKey); <br>  } <br> <br>  return NOERROR; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>// AMovieSetupRegisterServer() <br>// <br>// registers specfied file "szFileName" as server for <br>// CLSID "clsServer".  A description is also required. <br>// The ThreadingModel and ServerType are optional, as <br>// they default to InprocServer32 (i.e. dll) and Both. <br>// <br>//--------------------------------------------------------------------------- <br> <br>STDAPI <br>AMovieSetupRegisterServer( CLSID   clsServer <br>                         , LPCWSTR szDescription <br>                         , LPCWSTR szFileName <br>                         , LPCWSTR szThreadingModel = L"Both" <br>                         , LPCWSTR szServerType     = L"InprocServer32" ) <br>{ <br>  // temp buffer <br>  // <br>  TCHAR achTemp[MAX_PATH]; <br> <br>  // convert CLSID uuid to string and write <br>  // out subkey as string - CLSID\{} <br>  // <br>  OLECHAR szCLSID[CHARS_IN_GUID]; <br>  HRESULT hr = StringFromGUID2( clsServer <br>                              , szCLSID <br>                              , CHARS_IN_GUID ); <br>  ASSERT( SUCCEEDED(hr) ); <br> <br>  // create key <br>  // <br>  HKEY hkey; <br>  wsprintf( achTemp, TEXT("CLSID\\%ls"), szCLSID ); <br>  LONG lreturn = RegCreateKey( HKEY_CLASSES_ROOT <br>                             , (LPCTSTR)achTemp <br>                             , &amp;hkey              ); <br>  if( ERROR_SUCCESS != lreturn ) <br>  { <br>    return HRESULT_FROM_WIN32(lreturn); <br>  } <br> <br>  // set description string <br>  // <br> <br>  wsprintf( achTemp, TEXT("%ls"), szDescription ); <br>  lreturn = RegSetValue( hkey <br>                       , (LPCTSTR)NULL <br>                       , REG_SZ <br>                       , achTemp <br>                       , sizeof(achTemp) ); <br>  if( ERROR_SUCCESS != lreturn ) <br>  { <br>    RegCloseKey( hkey ); <br>    return HRESULT_FROM_WIN32(lreturn); <br>  } <br> <br>  // create CLSID\\{"CLSID"}\\"ServerType" key, <br>  // using key to CLSID\\{"CLSID"} passed back by <br>  // last call to RegCreateKey(). <br>  // <br>  HKEY hsubkey; <br> <br>  wsprintf( achTemp, TEXT("%ls"), szServerType ); <br>  lreturn = RegCreateKey( hkey <br>                        , achTemp <br>                        , &amp;hsubkey     ); <br>  if( ERROR_SUCCESS != lreturn ) <br>  { <br>    RegCloseKey( hkey ); <br>    return HRESULT_FROM_WIN32(lreturn); <br>  } <br> <br>  // set Server string <br>  // <br>  wsprintf( achTemp, TEXT("%ls"), szFileName ); <br>  lreturn = RegSetValue( hsubkey <br>                       , (LPCTSTR)NULL <br>                       , REG_SZ <br>                       , (LPCTSTR)achTemp <br>                       , sizeof(TCHAR) * (lstrlen(achTemp)+1) ); <br>  if( ERROR_SUCCESS != lreturn ) <br>  { <br>    RegCloseKey( hkey ); <br>    RegCloseKey( hsubkey ); <br>    return HRESULT_FROM_WIN32(lreturn); <br>  } <br> <br>  wsprintf( achTemp, TEXT("%ls"), szThreadingModel ); <br>  lreturn = RegSetValueEx( hsubkey <br>                         , TEXT("ThreadingModel") <br>                         , 0L <br>                         , REG_SZ <br>                         , (CONST BYTE *)achTemp <br>                         , sizeof(TCHAR) * (lstrlen(achTemp)+1) ); <br> <br>  // close hkeys <br>  // <br>  RegCloseKey( hkey ); <br>  RegCloseKey( hsubkey ); <br> <br>  // and return <br>  // <br>  return HRESULT_FROM_WIN32(lreturn); <br> <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>// AMovieSetupUnregisterServer() <br>// <br>// default ActiveMovie dll setup function <br>// - to use must be called from an exported <br>//   function named DllRegisterServer() <br>// <br>//--------------------------------------------------------------------------- <br> <br>STDAPI <br>AMovieSetupUnregisterServer( CLSID clsServer ) <br>{ <br>  // convert CLSID uuid to string and write <br>  // out subkey CLSID\{} <br>  // <br>  OLECHAR szCLSID[CHARS_IN_GUID]; <br>  HRESULT hr = StringFromGUID2( clsServer <br>                              , szCLSID <br>                              , CHARS_IN_GUID ); <br>  ASSERT( SUCCEEDED(hr) ); <br> <br>  TCHAR achBuffer[MAX_KEY_LEN]; <br>  wsprintf( achBuffer, TEXT("CLSID\\%ls"), szCLSID ); <br> <br>  // delete subkey <br>  // <br> <br>  hr = EliminateSubKey( HKEY_CLASSES_ROOT, achBuffer ); <br>  ASSERT( SUCCEEDED(hr) ); <br> <br>  // return <br>  // <br>  return NOERROR; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>// AMovieSetupRegisterFilter through IFilterMapper2 <br>// <br>//--------------------------------------------------------------------------- <br> <br>STDAPI <br>AMovieSetupRegisterFilter2( const AMOVIESETUP_FILTER * const psetupdata <br>                          , IFilterMapper2 *                 pIFM2 <br>                          , BOOL                             bRegister  ) <br>{ <br>  DbgLog((LOG_TRACE, 3, TEXT("= AMovieSetupRegisterFilter"))); <br> <br>  // check we've got data <br>  // <br>  if( NULL == psetupdata ) return S_FALSE; <br> <br> <br>  // unregister filter <br>  // (as pins are subkeys of filter's CLSID key <br>  // they do not need to be removed separately). <br>  // <br>  DbgLog((LOG_TRACE, 3, TEXT("= = unregister filter"))); <br>  HRESULT hr = pIFM2-&gt;UnregisterFilter( <br>      0,                        // default category <br>      0,                        // default instance name <br>      *psetupdata-&gt;clsID ); <br> <br> <br>  if( bRegister ) <br>  { <br>    REGFILTER2 rf2; <br>    rf2.dwVersion = 1; <br>    rf2.dwMerit = psetupdata-&gt;dwMerit; <br>    rf2.cPins = psetupdata-&gt;nPins; <br>    rf2.rgPins = psetupdata-&gt;lpPin; <br>     <br>    // register filter <br>    // <br>    DbgLog((LOG_TRACE, 3, TEXT("= = register filter"))); <br>    hr = pIFM2-&gt;RegisterFilter(*psetupdata-&gt;clsID <br>                             , psetupdata-&gt;strName <br>                             , 0 // moniker <br>                             , 0 // category <br>                             , NULL // instance <br>                             , &amp;rf2); <br>  } <br> <br>  // handle one acceptable "error" - that <br>  // of filter not being registered! <br>  // (couldn't find a suitable #define'd <br>  // name for the error!) <br>  // <br>  if( 0x80070002 == hr) <br>    return NOERROR; <br>  else <br>    return hr; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>// RegisterAllServers() <br>// <br>//--------------------------------------------------------------------------- <br> <br>STDAPI <br>RegisterAllServers( LPCWSTR szFileName, BOOL bRegister ) <br>{ <br>  HRESULT hr = NOERROR; <br> <br>  for( int i = 0; i &lt; g_cTemplates; i++ ) <br>  { <br>    // get i'th template <br>    // <br>    const CFactoryTemplate *pT = &amp;g_Templates[i]; <br> <br>    DbgLog((LOG_TRACE, 2, TEXT("- - register %ls"), <br>           (LPCWSTR)pT-&gt;m_Name )); <br> <br>    // register CLSID and InprocServer32 <br>    // <br>    if( bRegister ) <br>    { <br>      hr = AMovieSetupRegisterServer( *(pT-&gt;m_ClsID) <br>                                    , (LPCWSTR)pT-&gt;m_Name <br>                                    , szFileName ); <br>    } <br>    else <br>    { <br>      hr = AMovieSetupUnregisterServer( *(pT-&gt;m_ClsID) ); <br>    } <br> <br>    // check final error for this pass <br>    // and break loop if we failed <br>    // <br>    if( FAILED(hr) ) <br>      break; <br>  } <br> <br>  return hr; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>// AMovieDllRegisterServer2() <br>// <br>// default ActiveMovie dll setup function <br>// - to use must be called from an exported <br>//   function named DllRegisterServer() <br>// <br>// this function is table driven using the <br>// static members of the CFactoryTemplate <br>// class defined in the dll. <br>// <br>// it registers the Dll as the InprocServer32 <br>// and then calls the IAMovieSetup.Register <br>// method. <br>// <br>//--------------------------------------------------------------------------- <br> <br>STDAPI <br>AMovieDllRegisterServer2( BOOL bRegister ) <br>{ <br>  HRESULT hr = NOERROR; <br> <br>  DbgLog((LOG_TRACE, 2, TEXT("AMovieDllRegisterServer2()"))); <br> <br>  // get file name (where g_hInst is the <br>  // instance handle of the filter dll) <br>  // <br>  WCHAR achFileName[MAX_PATH]; <br> <br>  // WIN95 doesn't support GetModuleFileNameW <br>  // <br>  { <br>    char achTemp[MAX_PATH]; <br> <br>    DbgLog((LOG_TRACE, 2, TEXT("- get module file name"))); <br> <br>    if( 0 == GetModuleFileNameA( g_hInst <br>                              , achTemp <br>                              , sizeof(achTemp) ) ) <br>    { <br>      // we've failed! <br>      DWORD dwerr = GetLastError(); <br>      return HRESULT_FROM_WIN32(dwerr); <br>    } <br> <br>    MultiByteToWideChar( CP_ACP <br>                       , 0L <br>                       , achTemp <br>                       , lstrlenA(achTemp) + 1 <br>                       , achFileName <br>                       , sizeof(achFileName) ); <br>  } <br> <br>  // <br>  // first registering, register all OLE servers <br>  // <br>  if( bRegister ) <br>  { <br>    DbgLog((LOG_TRACE, 2, TEXT("- register OLE Servers"))); <br>    hr = RegisterAllServers( achFileName, TRUE ); <br>  } <br> <br>  // <br>  // next, register/unregister all filters <br>  // <br> <br>  if( SUCCEEDED(hr) ) <br>  { <br>    // init is ref counted so call just in case <br>    // we're being called cold. <br>    // <br>    DbgLog((LOG_TRACE, 2, TEXT("- CoInitialize"))); <br>    hr = CoInitialize( (LPVOID)NULL ); <br>    ASSERT( SUCCEEDED(hr) ); <br> <br>    // get hold of IFilterMapper2 <br>    // <br>    DbgLog((LOG_TRACE, 2, TEXT("- obtain IFilterMapper2"))); <br>    IFilterMapper2 *pIFM2 = 0; <br>    IFilterMapper *pIFM = 0; <br>    hr = CoCreateInstance( CLSID_FilterMapper2 <br>                         , NULL <br>                         , CLSCTX_INPROC_SERVER <br>                         , IID_IFilterMapper2 <br>                         , (void **)&amp;pIFM2       ); <br>    if(FAILED(hr)) <br>    { <br>        DbgLog((LOG_TRACE, 2, TEXT("- trying IFilterMapper instead"))); <br> <br>        hr = CoCreateInstance( <br>            CLSID_FilterMapper, <br>            NULL, <br>            CLSCTX_INPROC_SERVER, <br>            IID_IFilterMapper, <br>            (void **)&amp;pIFM); <br>    } <br>    if( SUCCEEDED(hr) ) <br>    { <br>      // scan through array of CFactoryTemplates <br>      // registering servers and filters. <br>      // <br>      DbgLog((LOG_TRACE, 2, TEXT("- register Filters"))); <br>      for( int i = 0; i &lt; g_cTemplates; i++ ) <br>      { <br>        // get i'th template <br>        // <br>        const CFactoryTemplate *pT = &amp;g_Templates[i]; <br> <br>        if( NULL != pT-&gt;m_pAMovieSetup_Filter ) <br>        { <br>          DbgLog((LOG_TRACE, 2, TEXT("- - register %ls"), (LPCWSTR)pT-&gt;m_Name )); <br> <br>          if(pIFM2) <br>          { <br>              hr = AMovieSetupRegisterFilter2( pT-&gt;m_pAMovieSetup_Filter, pIFM2, bRegister ); <br>          } <br>          else <br>          { <br>              hr = AMovieSetupRegisterFilter( pT-&gt;m_pAMovieSetup_Filter, pIFM, bRegister ); <br>          } <br>        } <br> <br>        // check final error for this pass <br>        // and break loop if we failed <br>        // <br>        if( FAILED(hr) ) <br>          break; <br>      } <br> <br>      // release interface <br>      // <br>      if(pIFM2) <br>          pIFM2-&gt;Release(); <br>      else <br>          pIFM-&gt;Release(); <br> <br>    } <br> <br>    // and clear up <br>    // <br>    CoFreeUnusedLibraries(); <br>    CoUninitialize(); <br>  } <br> <br>  // <br>  // if unregistering, unregister all OLE servers <br>  // <br>  if( SUCCEEDED(hr) &amp;&amp; !bRegister ) <br>  { <br>    DbgLog((LOG_TRACE, 2, TEXT("- register OLE Servers"))); <br>    hr = RegisterAllServers( achFileName, FALSE ); <br>  } <br> <br>  DbgLog((LOG_TRACE, 2, TEXT("- return %0x"), hr)); <br>  return hr; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>// AMovieDllRegisterServer() <br>// <br>// default ActiveMovie dll setup function <br>// - to use must be called from an exported <br>//   function named DllRegisterServer() <br>// <br>// this function is table driven using the <br>// static members of the CFactoryTemplate <br>// class defined in the dll. <br>// <br>// it registers the Dll as the InprocServer32 <br>// and then calls the IAMovieSetup.Register <br>// method. <br>// <br>//--------------------------------------------------------------------------- <br> <br> <br>STDAPI <br>AMovieDllRegisterServer( void ) <br>{ <br>  HRESULT hr = NOERROR; <br> <br>  // get file name (where g_hInst is the <br>  // instance handle of the filter dll) <br>  // <br>  WCHAR achFileName[MAX_PATH]; <br> <br>  { <br>    // WIN95 doesn't support GetModuleFileNameW <br>    // <br>    char achTemp[MAX_PATH]; <br> <br>    if( 0 == GetModuleFileNameA( g_hInst <br>                              , achTemp <br>                              , sizeof(achTemp) ) ) <br>    { <br>      // we've failed! <br>      DWORD dwerr = GetLastError(); <br>      return HRESULT_FROM_WIN32(dwerr); <br>    } <br> <br>    MultiByteToWideChar( CP_ACP <br>                       , 0L <br>                       , achTemp <br>                       , lstrlenA(achTemp) + 1 <br>                       , achFileName <br>                       , sizeof(achFileName) ); <br>  } <br> <br>  // scan through array of CFactoryTemplates <br>  // registering servers and filters. <br>  // <br>  for( int i = 0; i &lt; g_cTemplates; i++ ) <br>  { <br>    // get i'th template <br>    // <br>    const CFactoryTemplate *pT = &amp;g_Templates[i]; <br> <br>    // register CLSID and InprocServer32 <br>    // <br>    hr = AMovieSetupRegisterServer( *(pT-&gt;m_ClsID) <br>                                  , (LPCWSTR)pT-&gt;m_Name <br>                                  , achFileName ); <br> <br>    // instantiate all servers and get hold of <br>    // IAMovieSetup, if implemented, and call <br>    // IAMovieSetup.Register() method <br>    // <br>    if( SUCCEEDED(hr) &amp;&amp; (NULL != pT-&gt;m_lpfnNew) ) <br>    { <br>      // instantiate object <br>      // <br>      PAMOVIESETUP psetup; <br>      hr = CoCreateInstance( *(pT-&gt;m_ClsID) <br>                           , 0 <br>                           , CLSCTX_INPROC_SERVER <br>                           , IID_IAMovieSetup <br>                           , reinterpret_cast&lt;void**&gt;(&amp;psetup) ); <br>      if( SUCCEEDED(hr) ) <br>      { <br>        hr = psetup-&gt;Unregister(); <br>        if( SUCCEEDED(hr) ) <br>          hr = psetup-&gt;Register(); <br>        psetup-&gt;Release(); <br>      } <br>      else <br>      { <br>        if(    (E_NOINTERFACE      == hr ) <br>            || (VFW_E_NEED_OWNER == hr ) ) <br>          hr = NOERROR; <br>      } <br>    } <br> <br>    // check final error for this pass <br>    // and break loop if we failed <br>    // <br>    if( FAILED(hr) ) <br>      break; <br> <br>  } // end-for <br> <br>  return hr; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>// AMovieDllUnregisterServer() <br>// <br>// default ActiveMovie dll uninstall function <br>// - to use must be called from an exported <br>//   function named DllRegisterServer() <br>// <br>// this function is table driven using the <br>// static members of the CFactoryTemplate <br>// class defined in the dll. <br>// <br>// it calls the IAMovieSetup.Unregister <br>// method and then unregisters the Dll <br>// as the InprocServer32 <br>// <br>//--------------------------------------------------------------------------- <br> <br>STDAPI <br>AMovieDllUnregisterServer() <br>{ <br>  // initialize return code <br>  // <br>  HRESULT hr = NOERROR; <br> <br>  // scan through CFactory template and unregister <br>  // all OLE servers and filters. <br>  // <br>  for( int i = g_cTemplates; i--; ) <br>  { <br>    // get i'th template <br>    // <br>    const CFactoryTemplate *pT = &amp;g_Templates[i]; <br> <br>    // check method exists <br>    // <br>    if( NULL != pT-&gt;m_lpfnNew ) <br>    { <br>      // instantiate object <br>      // <br>      PAMOVIESETUP psetup; <br>      hr = CoCreateInstance( *(pT-&gt;m_ClsID) <br>                           , 0 <br>                           , CLSCTX_INPROC_SERVER <br>                           , IID_IAMovieSetup <br>                           , reinterpret_cast&lt;void**&gt;(&amp;psetup) ); <br>      if( SUCCEEDED(hr) ) <br>      { <br>        hr = psetup-&gt;Unregister(); <br>        psetup-&gt;Release(); <br>      } <br>      else <br>      { <br>        if(    (E_NOINTERFACE      == hr ) <br>            || (VFW_E_NEED_OWNER == hr ) ) <br>           hr = NOERROR; <br>      } <br>    } <br> <br>    // unregister CLSID and InprocServer32 <br>    // <br>    if( SUCCEEDED(hr) ) <br>    { <br>      hr = AMovieSetupUnregisterServer( *(pT-&gt;m_ClsID) ); <br>    } <br> <br>    // check final error for this pass <br>    // and break loop if we failed <br>    // <br>    if( FAILED(hr) ) <br>      break; <br>  } <br> <br>  return hr; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
