<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WXUTIL.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2793"></a>WXUTIL.CPP</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>// <br>// helper classes for building multimedia filters <br>// <br> <br>#include &lt;streams.h&gt; <br> <br>// <br>//  Declare function from largeint.h we need so that PPC can build <br>// <br> <br>// <br>// Enlarged integer divide - 64-bits / 32-bits &gt; 32-bits <br>// <br> <br>#ifndef _X86_ <br> <br>#define LLtoU64(x) (*(unsigned __int64*)(void*)(&amp;(x))) <br> <br>__inline <br>ULONG <br>WINAPI <br>EnlargedUnsignedDivide ( <br>    IN ULARGE_INTEGER Dividend, <br>    IN ULONG Divisor, <br>    IN PULONG Remainder <br>    ) <br>{ <br>        // return remainder if necessary <br>        if (Remainder != NULL) <br>                *Remainder = (ULONG)(LLtoU64(Dividend) % Divisor); <br>        return (ULONG)(LLtoU64(Dividend) / Divisor); <br>} <br> <br>#else <br>__inline <br>ULONG <br>WINAPI <br>EnlargedUnsignedDivide ( <br>    IN ULARGE_INTEGER Dividend, <br>    IN ULONG Divisor, <br>    IN PULONG Remainder <br>    ) <br>{ <br>    ULONG ulResult; <br>    _asm { <br>        mov eax,Dividend.LowPart <br>        mov edx,Dividend.HighPart <br>        mov ecx,Remainder <br>        div Divisor <br>        or  ecx,ecx <br>        jz  short label <br>        mov [ecx],edx <br>label: <br>        mov ulResult,eax <br>    } <br>    return ulResult; <br>} <br>#endif <br> <br>// --- CAMEvent ----------------------- <br>CAMEvent::CAMEvent(BOOL fManualReset) <br>{ <br>    m_hEvent = CreateEvent(NULL, fManualReset, FALSE, NULL); <br>    ASSERT(m_hEvent); <br>} <br> <br>CAMEvent::~CAMEvent() <br>{ <br>    if (m_hEvent) { <br>EXECUTE_ASSERT(CloseHandle(m_hEvent)); <br>    } <br>} <br> <br> <br>// --- CAMMsgEvent ----------------------- <br>// One routine.  The rest is handled in CAMEvent <br> <br>BOOL CAMMsgEvent::WaitMsg(DWORD dwTimeout) <br>{ <br>    // wait for the event to be signalled, or for the <br>    // timeout (in MS) to expire.  allow SENT messages <br>    // to be processed while we wait <br>    DWORD dwWait; <br>    DWORD dwStartTime; <br> <br>    // set the waiting period. <br>    DWORD dwWaitTime = dwTimeout; <br> <br>    // the timeout will eventually run down as we iterate <br>    // processing messages.  grab the start time so that <br>    // we can calculate elapsed times. <br>    if (dwWaitTime != INFINITE) { <br>        dwStartTime = timeGetTime(); <br>    } <br> <br>    do { <br>        dwWait = MsgWaitForMultipleObjects(1,&amp;m_hEvent,FALSE, dwWaitTime, QS_SENDMESSAGE); <br>        if (dwWait == WAIT_OBJECT_0 + 1) { <br>    MSG Message; <br>            PeekMessage(&amp;Message,NULL,0,0,PM_NOREMOVE); <br> <br>    // If we have an explicit length of time to wait calculate <br>    // the next wake up point - which might be now. <br>    // If dwTimeout is INFINITE, it stays INFINITE <br>    if (dwWaitTime != INFINITE) { <br> <br>DWORD dwElapsed = timeGetTime()-dwStartTime; <br> <br>dwWaitTime = <br>    (dwElapsed &gt;= dwTimeout) <br>? 0  // wake up with WAIT_TIMEOUT <br>: dwTimeout-dwElapsed; <br>    } <br>        } <br>    } while (dwWait == WAIT_OBJECT_0 + 1); <br> <br>    // return TRUE if we woke on the event handle, <br>    //        FALSE if we timed out. <br>    return (dwWait == WAIT_OBJECT_0); <br>} <br> <br>// --- CAMThread ---------------------- <br> <br> <br>CAMThread::CAMThread() <br>    : m_EventSend(TRUE)     // must be manual-reset for CheckRequest() <br>{ <br>    m_hThread = NULL; <br>} <br> <br>CAMThread::~CAMThread() { <br>    Close(); <br>} <br> <br> <br>// when the thread starts, it calls this function. We unwrap the 'this' <br>//pointer and call ThreadProc. <br>DWORD WINAPI <br>CAMThread::InitialThreadProc(LPVOID pv) <br>{ <br>    CAMThread * pThread = (CAMThread *) pv; <br> <br>    return pThread-&gt;ThreadProc(); <br>} <br> <br>BOOL <br>CAMThread::Create() <br>{ <br>    DWORD threadid; <br> <br>    CAutoLock lock(&amp;m_AccessLock); <br> <br>    if (ThreadExists()) { <br>return FALSE; <br>    } <br> <br>    m_hThread = CreateThread( <br>    NULL, <br>    0, <br>    CAMThread::InitialThreadProc, <br>    this, <br>    0, <br>    &amp;threadid); <br> <br>    if (!m_hThread) { <br>return FALSE; <br>    } <br> <br>    return TRUE; <br>} <br> <br>DWORD <br>CAMThread::CallWorker(DWORD dwParam) <br>{ <br>    // lock access to the worker thread for scope of this object <br>    CAutoLock lock(&amp;m_AccessLock); <br> <br>    if (!ThreadExists()) { <br>return (DWORD) E_FAIL; <br>    } <br> <br>    // set the parameter <br>    m_dwParam = dwParam; <br> <br>    // signal the worker thread <br>    m_EventSend.Set(); <br> <br>    // wait for the completion to be signalled <br>    m_EventComplete.Wait(); <br> <br>    // done - this is the thread's return value <br>    return m_dwReturnVal; <br>} <br> <br>// Wait for a request from the client <br>DWORD <br>CAMThread::GetRequest() <br>{ <br>    m_EventSend.Wait(); <br>    return m_dwParam; <br>} <br> <br>// is there a request? <br>BOOL <br>CAMThread::CheckRequest(DWORD * pParam) <br>{ <br>    if (!m_EventSend.Check()) { <br>return FALSE; <br>    } else { <br>if (pParam) { <br>    *pParam = m_dwParam; <br>} <br>return TRUE; <br>    } <br>} <br> <br>// reply to the request <br>void <br>CAMThread::Reply(DWORD dw) <br>{ <br>    m_dwReturnVal = dw; <br> <br>    // The request is now complete so CheckRequest should fail from <br>    // now on <br>    // <br>    // This event should be reset BEFORE we signal the client or <br>    // the client may Set it before we reset it and we'll then <br>    // reset it (!) <br> <br>    m_EventSend.Reset(); <br> <br>    // Tell the client we're finished <br> <br>    m_EventComplete.Set(); <br>} <br> <br> <br>// destructor for CMsgThread  - cleans up any messages left in the <br>// queue when the thread exited <br>CMsgThread::~CMsgThread() <br>{ <br>    if (m_hThread != NULL) { <br>        WaitForSingleObject(m_hThread, INFINITE); <br>        EXECUTE_ASSERT(CloseHandle(m_hThread)); <br>    } <br> <br>    POSITION pos = m_ThreadQueue.GetHeadPosition(); <br>    while (pos) { <br>        CMsg * pMsg = m_ThreadQueue.GetNext(pos); <br>        delete pMsg; <br>    } <br>    m_ThreadQueue.RemoveAll(); <br> <br>    if (m_hSem != NULL) { <br>        EXECUTE_ASSERT(CloseHandle(m_hSem)); <br>    } <br>} <br> <br>BOOL <br>CMsgThread::CreateThread( <br>    ) <br>{ <br>    m_hSem = CreateSemaphore(NULL, 0, 0x7FFFFFFF, NULL); <br>    if (m_hSem == NULL) { <br>        return FALSE; <br>    } <br> <br>    m_hThread = ::CreateThread(NULL, 0, DefaultThreadProc, <br>       (LPVOID)this, 0, &amp;m_ThreadId); <br>    return m_hThread != NULL; <br>} <br> <br> <br>// This is the threads message pump.  Here we get and dispatch messages to <br>// clients thread proc until the client refuses to process a message. <br>// The client returns a non-zero value to stop the message pump, this <br>// value becomes the threads exit code. <br> <br>DWORD WINAPI <br>CMsgThread::DefaultThreadProc( <br>    LPVOID lpParam <br>    ) <br>{ <br>    CMsgThread *lpThis = (CMsgThread *)lpParam; <br>    CMsg msg; <br>    LRESULT lResult; <br> <br>    // !!! <br>    CoInitialize(NULL); <br> <br>    // allow a derived class to handle thread startup <br>    lpThis-&gt;OnThreadInit(); <br> <br>    do { <br>lpThis-&gt;GetThreadMsg(&amp;msg); <br>lResult = lpThis-&gt;ThreadMessageProc(msg.uMsg,msg.dwFlags, <br>    msg.lpParam, msg.pEvent); <br>    } while (lResult == 0L); <br> <br>    // !!! <br>    CoUninitialize(); <br> <br>    return (DWORD)lResult; <br>} <br> <br> <br>// Block until the next message is placed on the list m_ThreadQueue. <br>// copies the message to the message pointed to by *pmsg <br>void <br>CMsgThread::GetThreadMsg(CMsg *msg) <br>{ <br>    CMsg * pmsg = NULL; <br> <br>    // keep trying until a message appears <br>    while (TRUE) { <br>        { <br>            CAutoLock lck(&amp;m_Lock); <br>            pmsg = m_ThreadQueue.RemoveHead(); <br>            if (pmsg == NULL) { <br>                m_lWaiting++; <br>            } else { <br>                break; <br>            } <br>        } <br>        // the semaphore will be signalled when it is non-empty <br>        WaitForSingleObject(m_hSem, INFINITE); <br>    } <br>    // copy fields to caller's CMsg <br>    *msg = *pmsg; <br> <br>    // this CMsg was allocated by the 'new' in PutThreadMsg <br>    delete pmsg; <br> <br>} <br> <br> <br>#ifndef UNICODE <br>// NOTE: as we need to use the same binaries on Win95 as on NT this code should <br>// be compiled WITHOUT unicode being defined.  Otherwise we will not pick up <br>// these internal routines and the binary will not run on Win95. <br> <br>// Windows 95 doesn't implement this, so we provide an implementation. <br>LPWSTR <br>WINAPI <br>lstrcpyWInternal( <br>    LPWSTR lpString1, <br>    LPCWSTR lpString2 <br>    ) <br>{ <br>    LPWSTR  lpReturn = lpString1; <br>    while (*lpString1++ = *lpString2++); <br> <br>    return lpReturn; <br>} <br> <br>// Windows 95 doesn't implement this, so we provide an implementation. <br>LPWSTR <br>WINAPI <br>lstrcpynWInternal( <br>    LPWSTR lpString1, <br>    LPCWSTR lpString2, <br>    int     iMaxLength <br>    ) <br>{ <br>    ASSERT(iMaxLength); <br>    LPWSTR  lpReturn = lpString1; <br>    if (iMaxLength) { <br>        while (--iMaxLength &amp;&amp; (*lpString1++ = *lpString2++)); <br> <br>        // If we ran out of room (which will be the case if <br>        // iMaxLength is now 0) we still need to terminate the <br>        // string. <br>        if (!iMaxLength) *lpString1 = L'\0'; <br>    } <br>    return lpReturn; <br>} <br> <br>int <br>WINAPI <br>lstrcmpWInternal( <br>    LPCWSTR lpString1, <br>    LPCWSTR lpString2 <br>    ) <br>{ <br>    do { <br>WCHAR c1 = *lpString1; <br>WCHAR c2 = *lpString2; <br>if (c1 != c2) <br>    return (int) c1 - (int) c2; <br>    } while (*lpString1++ &amp;&amp; *lpString2++); <br>    return 0; <br>} <br> <br> <br>int <br>WINAPI <br>lstrcmpiWInternal( <br>    LPCWSTR lpString1, <br>    LPCWSTR lpString2 <br>    ) <br>{ <br>    do { <br>WCHAR c1 = *lpString1; <br>WCHAR c2 = *lpString2; <br>if (c1 &gt;= L'A' &amp;&amp; c1 &lt;= L'Z') <br>    c1 -= (WCHAR) (L'A' - L'a'); <br>if (c2 &gt;= L'A' &amp;&amp; c2 &lt;= L'Z') <br>    c2 -= (WCHAR) (L'A' - L'a'); <br> <br>if (c1 != c2) <br>    return (int) c1 - (int) c2; <br>    } while (*lpString1++ &amp;&amp; *lpString2++); <br> <br>    return 0; <br>} <br> <br> <br>int <br>WINAPI <br>lstrlenWInternal( <br>    LPCWSTR lpString <br>    ) <br>{ <br>    int i = -1; <br>    while (*(lpString+(++i))) <br>        ; <br>    return i; <br>} <br> <br>#endif // NOT UNICODE <br> <br> <br>#ifndef UNICODE <br>int WINAPIV wsprintfWInternal(LPWSTR wszOut, LPCWSTR pszFmt, ...) <br>{ <br>    char fmt[256]; // !!! <br>    char ach[256]; // !!! <br>    int i; <br> <br>    va_list va; <br>    va_start(va, pszFmt); <br>    WideCharToMultiByte(GetACP(), 0, pszFmt, -1, fmt, 256, NULL, NULL); <br>    i = wvsprintf(ach, fmt, va); <br>    va_end(va); <br> <br>    MultiByteToWideChar(CP_ACP, 0, ach, -1, wszOut, i+1); <br> <br>    return i; <br>} <br>#endif <br> <br>// Helper function - convert int to WSTR <br>void WINAPI IntToWstr(int i, LPWSTR wstr) <br>{ <br>#ifdef UNICODE <br>    wsprintf(wstr, L"%d", i); <br>#else <br>    TCHAR temp[32]; <br>    wsprintf(temp, "%d", i); <br>    MultiByteToWideChar(CP_ACP, 0, temp, -1, wstr, 32); <br>#endif <br>} // IntToWstr <br> <br> <br>#if 0 <br>void * memchrInternal(const void *pv, int c, size_t sz) <br>{ <br>    BYTE *pb = (BYTE *) pv; <br>    while (sz--) { <br>if (*pb == c) <br>    return (void *) pb; <br>pb++; <br>    } <br>    return NULL; <br>} <br>#endif <br> <br> <br>#define MEMORY_ALIGNMENT        4 <br>#define MEMORY_ALIGNMENT_LOG2   2 <br>#define MEMORY_ALIGNMENT_MASK   MEMORY_ALIGNMENT - 1 <br> <br>void * __stdcall memmoveInternal(void * dst, const void * src, size_t count) <br>{ <br>    void * ret = dst; <br> <br>#ifdef _X86_ <br>    if (dst &lt;= src || (char *)dst &gt;= ((char *)src + count)) { <br> <br>        /* <br>         * Non-Overlapping Buffers <br>         * copy from lower addresses to higher addresses <br>         */ <br>        _asm { <br>            mov     esi,src <br>            mov     edi,dst <br>            mov     ecx,count <br>            cld <br>            mov     edx,ecx <br>            and     edx,MEMORY_ALIGNMENT_MASK <br>            shr     ecx,MEMORY_ALIGNMENT_LOG2 <br>            rep     movsd <br>            or      ecx,edx <br>            jz      memmove_done <br>            rep     movsb <br>memmove_done: <br>        } <br>    } <br>    else { <br> <br>        /* <br>         * Overlapping Buffers <br>         * copy from higher addresses to lower addresses <br>         */ <br>        _asm { <br>            mov     esi,src <br>            mov     edi,dst <br>            mov     ecx,count <br>            std <br>            add     esi,ecx <br>            add     edi,ecx <br>            dec     esi <br>            dec     edi <br>            rep     movsb <br>            cld <br>        } <br>    } <br>#else <br>    MoveMemory(dst, src, count); <br>#endif <br> <br>    return ret; <br>} <br> <br>/*  Arithmetic functions to help with time format conversions <br>*/ <br> <br>/*   Compute (a * b + d) / c */ <br>LONGLONG WINAPI llMulDiv(LONGLONG a, LONGLONG b, LONGLONG c, LONGLONG d) <br>{ <br>    /*  Compute the absolute values to avoid signed arithmetic problems */ <br>    ULARGE_INTEGER ua, ub; <br>    DWORDLONG uc; <br> <br>    ua.QuadPart = (DWORDLONG)(a &gt;= 0 ? a : -a); <br>    ub.QuadPart = (DWORDLONG)(b &gt;= 0 ? b : -b); <br>    uc          = (DWORDLONG)(c &gt;= 0 ? c : -c); <br>    BOOL bSign = (a &lt; 0) ^ (b &lt; 0); <br> <br>    /*  Do long multiplication */ <br>    ULARGE_INTEGER p[2]; <br>    p[0].QuadPart  = UInt32x32To64(ua.LowPart, ub.LowPart); <br> <br>    /*  This next computation cannot overflow into p[1].HighPart because <br>        the max number we can compute here is: <br> <br>                 (2 ** 32 - 1) * (2 ** 32 - 1) +  // ua.LowPart * ub.LowPart <br>    (2 ** 32) *  (2 ** 31) * (2 ** 32 - 1) * 2    // x.LowPart * y.HighPart * 2 <br> <br>    == 2 ** 96 - 2 ** 64 + (2 ** 64 - 2 ** 33 + 1) <br>    == 2 ** 96 - 2 ** 33 + 1 <br>    &lt; 2 ** 96 <br>    */ <br> <br>    ULARGE_INTEGER x; <br>    x.QuadPart     = UInt32x32To64(ua.LowPart, ub.HighPart) + <br>                     UInt32x32To64(ua.HighPart, ub.LowPart) + <br>                     p[0].HighPart; <br>    p[0].HighPart  = x.LowPart; <br>    p[1].QuadPart  = UInt32x32To64(ua.HighPart, ub.HighPart) + x.HighPart; <br> <br>    if (d != 0) { <br>        ULARGE_INTEGER ud[2]; <br>        if (bSign) { <br>            ud[0].QuadPart = (DWORDLONG)(-d); <br>            if (d &gt; 0) { <br>                /*  -d &lt; 0 */ <br>                ud[1].QuadPart = (DWORDLONG)(LONGLONG)-1; <br>            } else { <br>                ud[1].QuadPart = (DWORDLONG)0; <br>            } <br>        } else { <br>            ud[0].QuadPart = (DWORDLONG)d; <br>            if (d &lt; 0) { <br>                ud[1].QuadPart = (DWORDLONG)(LONGLONG)-1; <br>            } else { <br>                ud[1].QuadPart = (DWORDLONG)0; <br>            } <br>        } <br>        /*  Now do extended addition */ <br>        ULARGE_INTEGER uliTotal; <br> <br>        /*  Add ls DWORDs */ <br>        uliTotal.QuadPart  = (DWORDLONG)ud[0].LowPart + p[0].LowPart; <br>        p[0].LowPart       = uliTotal.LowPart; <br> <br>        /*  Propagate carry */ <br>        uliTotal.LowPart   = uliTotal.HighPart; <br>        uliTotal.HighPart  = 0; <br> <br>        /*  Add 2nd most ls DWORDs */ <br>        uliTotal.QuadPart += (DWORDLONG)ud[0].HighPart + p[0].HighPart; <br>        p[0].HighPart      = uliTotal.LowPart; <br> <br>        /*  Propagate carry */ <br>        uliTotal.LowPart   = uliTotal.HighPart; <br>        uliTotal.HighPart  = 0; <br> <br>        /*  Add MS DWORDLONGs - no carry expected */ <br>        p[1].QuadPart     += ud[1].QuadPart + uliTotal.QuadPart; <br> <br>        /*  Now see if we got a sign change from the addition */ <br>        if ((LONG)p[1].HighPart &lt; 0) { <br>            bSign = !bSign; <br> <br>            /*  Negate the current value (ugh!) */ <br>            p[0].QuadPart  = ~p[0].QuadPart; <br>            p[1].QuadPart  = ~p[1].QuadPart; <br>            p[0].QuadPart += 1; <br>            p[1].QuadPart += (p[0].QuadPart == 0); <br>        } <br>    } <br> <br>    /*  Now for the division */ <br>    if (c &lt; 0) { <br>        bSign = !bSign; <br>    } <br> <br> <br>    /*  This will catch c == 0 and overflow */ <br>    if (uc &lt;= p[1].QuadPart) { <br>        return bSign ? (LONGLONG)0x8000000000000000 : <br>                       (LONGLONG)0x7FFFFFFFFFFFFFFF; <br>    } <br> <br>    DWORDLONG ullResult; <br> <br>    /*  Do the division */ <br>    /*  If the dividend is a DWORD_LONG use the compiler */ <br>    if (p[1].QuadPart == 0) { <br>        ullResult = p[0].QuadPart / uc; <br>        return bSign ? -(LONGLONG)ullResult : (LONGLONG)ullResult; <br>    } <br> <br>    /*  If the divisor is a DWORD then its simpler */ <br>    ULARGE_INTEGER ulic; <br>    ulic.QuadPart = uc; <br>    if (ulic.HighPart == 0) { <br>        ULARGE_INTEGER uliDividend; <br>        ULARGE_INTEGER uliResult; <br>        DWORD dwDivisor = (DWORD)uc; <br>        // ASSERT(p[1].HighPart == 0 &amp;&amp; p[1].LowPart &lt; dwDivisor); <br>        uliDividend.HighPart = p[1].LowPart; <br>        uliDividend.LowPart = p[0].HighPart; <br>#ifndef USE_LARGEINT <br>        uliResult.HighPart = (DWORD)(uliDividend.QuadPart / dwDivisor); <br>        p[0].HighPart = (DWORD)(uliDividend.QuadPart % dwDivisor); <br>        uliResult.LowPart = 0; <br>        uliResult.QuadPart = p[0].QuadPart / dwDivisor + uliResult.QuadPart; <br>#else <br>        /*  NOTE - this routine will take exceptions if <br>            the result does not fit in a DWORD <br>        */ <br>        if (uliDividend.QuadPart &gt;= (DWORDLONG)dwDivisor) { <br>            uliResult.HighPart = EnlargedUnsignedDivide( <br>                                     uliDividend, <br>                                     dwDivisor, <br>                                     &amp;p[0].HighPart); <br>        } else { <br>            uliResult.HighPart = 0; <br>        } <br>        uliResult.LowPart = EnlargedUnsignedDivide( <br>                                 p[0], <br>                                 dwDivisor, <br>                                 NULL); <br>#endif <br>        return bSign ? -(LONGLONG)uliResult.QuadPart : <br>                        (LONGLONG)uliResult.QuadPart; <br>    } <br> <br> <br>    ullResult = 0; <br> <br>    /*  OK - do long division */ <br>    for (int i = 0; i &lt; 64; i++) { <br>        ullResult &lt;&lt;= 1; <br> <br>        /*  Shift 128 bit p left 1 */ <br>        p[1].QuadPart &lt;&lt;= 1; <br>        if ((p[0].HighPart &amp; 0x80000000) != 0) { <br>            p[1].LowPart++; <br>        } <br>        p[0].QuadPart &lt;&lt;= 1; <br> <br>        /*  Compare */ <br>        if (uc &lt;= p[1].QuadPart) { <br>            p[1].QuadPart -= uc; <br>            ullResult += 1; <br>        } <br>    } <br> <br>    return bSign ? - (LONGLONG)ullResult : (LONGLONG)ullResult; <br>} <br> <br> <br>LONGLONG WINAPI Int64x32Div32(LONGLONG a, LONG b, LONG c, LONG d) <br>{ <br>    ULARGE_INTEGER ua; <br>    DWORD ub; <br>    DWORD uc; <br> <br>    /*  Compute the absolute values to avoid signed arithmetic problems */ <br>    ua.QuadPart = (DWORDLONG)(a &gt;= 0 ? a : -a); <br>    ub = (DWORD)(b &gt;= 0 ? b : -b); <br>    uc = (DWORD)(c &gt;= 0 ? c : -c); <br>    BOOL bSign = (a &lt; 0) ^ (b &lt; 0); <br> <br>    /*  Do long multiplication */ <br>    ULARGE_INTEGER p0; <br>    DWORD p1; <br>    p0.QuadPart  = UInt32x32To64(ua.LowPart, ub); <br> <br>    if (ua.HighPart != 0) { <br>        ULARGE_INTEGER x; <br>        x.QuadPart     = UInt32x32To64(ua.HighPart, ub) + p0.HighPart; <br>        p0.HighPart  = x.LowPart; <br>        p1   = x.HighPart; <br>    } else { <br>        p1 = 0; <br>    } <br> <br>    if (d != 0) { <br>        ULARGE_INTEGER ud0; <br>        DWORD ud1; <br> <br>        if (bSign) { <br>            // <br>            //  Cast d to LONGLONG first otherwise -0x80000000 sign extends <br>            //  incorrectly <br>            // <br>            ud0.QuadPart = (DWORDLONG)(-(LONGLONG)d); <br>            if (d &gt; 0) { <br>                /*  -d &lt; 0 */ <br>                ud1 = (DWORD)-1; <br>            } else { <br>                ud1 = (DWORD)0; <br>            } <br>        } else { <br>            ud0.QuadPart = (DWORDLONG)d; <br>            if (d &lt; 0) { <br>                ud1 = (DWORD)-1; <br>            } else { <br>                ud1 = (DWORD)0; <br>            } <br>        } <br>        /*  Now do extended addition */ <br>        ULARGE_INTEGER uliTotal; <br> <br>        /*  Add ls DWORDs */ <br>        uliTotal.QuadPart  = (DWORDLONG)ud0.LowPart + p0.LowPart; <br>        p0.LowPart       = uliTotal.LowPart; <br> <br>        /*  Propagate carry */ <br>        uliTotal.LowPart   = uliTotal.HighPart; <br>        uliTotal.HighPart  = 0; <br> <br>        /*  Add 2nd most ls DWORDs */ <br>        uliTotal.QuadPart += (DWORDLONG)ud0.HighPart + p0.HighPart; <br>        p0.HighPart      = uliTotal.LowPart; <br> <br>        /*  Add MS DWORDLONGs - no carry expected */ <br>        p1 += ud1 + uliTotal.HighPart; <br> <br>        /*  Now see if we got a sign change from the addition */ <br>        if ((LONG)p1 &lt; 0) { <br>            bSign = !bSign; <br> <br>            /*  Negate the current value (ugh!) */ <br>            p0.QuadPart  = ~p0.QuadPart; <br>            p1 = ~p1; <br>            p0.QuadPart += 1; <br>            p1 += (p0.QuadPart == 0); <br>        } <br>    } <br> <br>    /*  Now for the division */ <br>    if (c &lt; 0) { <br>        bSign = !bSign; <br>    } <br> <br> <br>    /*  This will catch c == 0 and overflow */ <br>    if (uc &lt;= p1) { <br>        return bSign ? (LONGLONG)0x8000000000000000 : <br>                       (LONGLONG)0x7FFFFFFFFFFFFFFF; <br>    } <br> <br>    /*  Do the division */ <br> <br>    /*  If the divisor is a DWORD then its simpler */ <br>    ULARGE_INTEGER uliDividend; <br>    ULARGE_INTEGER uliResult; <br>    DWORD dwDivisor = uc; <br>    uliDividend.HighPart = p1; <br>    uliDividend.LowPart = p0.HighPart; <br>    /*  NOTE - this routine will take exceptions if <br>        the result does not fit in a DWORD <br>    */ <br>    if (uliDividend.QuadPart &gt;= (DWORDLONG)dwDivisor) { <br>        uliResult.HighPart = EnlargedUnsignedDivide( <br>                                 uliDividend, <br>                                 dwDivisor, <br>                                 &amp;p0.HighPart); <br>    } else { <br>        uliResult.HighPart = 0; <br>    } <br>    uliResult.LowPart = EnlargedUnsignedDivide( <br>                             p0, <br>                             dwDivisor, <br>                             NULL); <br>    return bSign ? -(LONGLONG)uliResult.QuadPart : <br>                    (LONGLONG)uliResult.QuadPart; <br>} <br> <br>#ifdef DEBUG <br>/******************************Public*Routine******************************\ <br>* Debug CCritSec helpers <br>* <br>* We provide debug versions of the Constructor, destructor, Lock and Unlock <br>* routines.  The debug code tracks who owns each critical section by <br>* maintaining a depth count. <br>* <br>* History: <br>* <br>\**************************************************************************/ <br> <br>CCritSec::CCritSec() <br>{ <br>    InitializeCriticalSection(&amp;m_CritSec); <br>    m_currentOwner = m_lockCount = 0; <br>    m_fTrace = FALSE; <br>} <br> <br>CCritSec::~CCritSec() <br>{ <br>    DeleteCriticalSection(&amp;m_CritSec); <br>} <br> <br>void CCritSec::Lock() <br>{ <br>    UINT tracelevel=3; <br>    DWORD us = GetCurrentThreadId(); <br>    DWORD currentOwner = m_currentOwner; <br>    if (currentOwner &amp;&amp; (currentOwner != us)) { <br>        // already owned, but not by us <br>        if (m_fTrace) { <br>            DbgLog((LOG_LOCKING, 2, TEXT("Thread %d about to wait for lock %x owned by %d"), <br>                GetCurrentThreadId(), &amp;m_CritSec, currentOwner)); <br>            tracelevel=2; <br>    // if we saw the message about waiting for the critical <br>    // section we ensure we see the message when we get the <br>    // critical section <br>        } <br>    } <br>    EnterCriticalSection(&amp;m_CritSec); <br>    if (0 == m_lockCount++) { <br>        // we now own it for the first time.  Set owner information <br>        m_currentOwner = us; <br>//ASSERT(((PRTL_CRITICAL_SECTION)&amp;m_CritSec)-&gt;OwningThread == (HANDLE)m_currentOwner); <br>// only valid on NT <br>        if (m_fTrace) { <br>            DbgLog((LOG_LOCKING, tracelevel, TEXT("Thread %d now owns lock %x"), m_currentOwner, &amp;m_CritSec)); <br>        } <br>    } <br>} <br> <br>void CCritSec::Unlock() { <br>    if (0 == --m_lockCount) { <br>        // about to be unowned <br>        if (m_fTrace) { <br>            DbgLog((LOG_LOCKING, 3, TEXT("Thread %d releasing lock %x"), m_currentOwner, &amp;m_CritSec)); <br>    //ASSERT(((PRTL_CRITICAL_SECTION)&amp;m_CritSec)-&gt;OwningThread == (HANDLE)m_currentOwner); <br>    // only valid on NT <br>        } <br>        m_currentOwner = 0; <br>    } <br>    LeaveCriticalSection(&amp;m_CritSec); <br>} <br> <br>void WINAPI DbgLockTrace(CCritSec * pcCrit, BOOL fTrace) <br>{ <br>    pcCrit-&gt;m_fTrace = fTrace; <br>} <br> <br>BOOL WINAPI CritCheckIn(CCritSec * pcCrit) <br>{ <br>    return (GetCurrentThreadId() == pcCrit-&gt;m_currentOwner); <br>} <br> <br>BOOL WINAPI CritCheckOut(CCritSec * pcCrit) <br>{ <br>    return (GetCurrentThreadId() != pcCrit-&gt;m_currentOwner); <br>} <br>#endif <br> <br> <br>typedef BSTR (STDAPICALLTYPE *LPSYSALLOCSTRING)(const OLECHAR FAR *); <br> <br>// Dyna-link to SysAllocString to copy BSTR strings <br> <br>STDAPI WriteBSTR(BSTR *pstrDest, LPCWSTR szSrc) <br>{ <br>    LPSYSALLOCSTRINGlpfnSysAllocString; <br>    HINSTANCEhInst; <br>    static const charszSysAllocString[]  = "SysAllocString"; <br> <br>    // <br>    // Try to get the Ole32Aut.dll module handle. <br>    // <br> <br>    hInst = LoadOLEAut32(); <br>    if (hInst == NULL) { <br>DWORD dwError = GetLastError(); <br>return HRESULT_FROM_WIN32(dwError); <br>    } <br>    lpfnSysAllocString = (LPSYSALLOCSTRING)GetProcAddress(hInst, <br>  szSysAllocString); <br>    if (lpfnSysAllocString == NULL) { <br>DWORD dwError = GetLastError(); <br>return HRESULT_FROM_WIN32(dwError); <br>    } <br> <br>    *pstrDest = (*lpfnSysAllocString)(szSrc); <br> <br>    return S_OK; <br>} <br> <br> <br>// Free an OLE BSTR through the task allocator <br> <br>STDAPI FreeBSTR(BSTR* pstr) <br>{ <br>    if (*pstr != NULL) { <br>        // get pointer to string <br>        DWORD* p = (DWORD*) (*pstr); <br> <br>        // back up to point at DWORD length <br>        p--; <br> <br>        // set pointer to null <br>        *pstr = NULL; <br> <br>        // and free this <br>        CoTaskMemFree(p); <br> <br>        return S_OK; <br>    } else { <br>        return S_FALSE; <br>    } <br>} <br> <br> <br>// Return a wide string - allocating memory for it <br>// Returns: <br>//    S_OK          - no error <br>//    E_POINTER     - ppszReturn == NULL <br>//    E_OUTOFMEMORY - can't allocate memory for returned string <br>STDAPI AMGetWideString(LPCWSTR psz, LPWSTR *ppszReturn) <br>{ <br>    CheckPointer(ppszReturn, E_POINTER); <br>    ValidateReadWritePtr(ppszReturn, sizeof(LPWSTR)); <br>    DWORD nameLen = sizeof(WCHAR) * (lstrlenW(psz)+1); <br>    *ppszReturn = (LPWSTR)CoTaskMemAlloc(nameLen); <br>    if (*ppszReturn == NULL) { <br>       return E_OUTOFMEMORY; <br>    } <br>    CopyMemory(*ppszReturn, psz, nameLen); <br>    return NOERROR; <br>} <br> <br>// Waits for the HANDLE hObject.  While waiting messages sent <br>// to windows on our thread by SendMessage will be processed. <br>// Using this function to do waits and mutual exclusion <br>// avoids some deadlocks in objects with windows. <br>// Return codes are the same as for WaitForSingleObject <br>DWORD WINAPI WaitDispatchingMessages(HANDLE hObject, DWORD dwWait, HWND hwnd, UINT uMsg) <br>{ <br>    BOOL bPeeked = FALSE; <br>    DWORD dwResult; <br>    DWORD dwStart; <br>    DWORD dwThreadPriority; <br>    if (dwWait != INFINITE &amp;&amp; dwWait != 0) { <br>        dwStart = GetTickCount(); <br>    } <br>    for (; ; ) { <br>        DWORD dwTimeOut = dwWait; <br>        if (dwTimeOut &gt; 10) { <br>            dwTimeOut = 10; <br>        } <br>        dwResult = MsgWaitForMultipleObjects( <br>                             1, <br>                             &amp;hObject, <br>                             FALSE, <br>                             dwTimeOut, <br>                             hwnd == NULL ? QS_SENDMESSAGE : <br>                                            QS_SENDMESSAGE + QS_POSTMESSAGE); <br>        if (dwResult == WAIT_OBJECT_0 + 1 || <br>            dwResult == WAIT_TIMEOUT &amp;&amp; dwTimeOut != dwWait) { <br>            MSG msg; <br>            if (hwnd != NULL) { <br>                while (PeekMessage(&amp;msg, hwnd, uMsg, uMsg, PM_REMOVE)) { <br>                    DispatchMessage(&amp;msg); <br>                } <br>            } <br>            // Do this anyway - the previous peek doesn't flush out the <br>            // messages <br>            PeekMessage(&amp;msg, NULL, 0, 0, PM_NOREMOVE); <br> <br>            if (dwWait != INFINITE &amp;&amp; dwWait != 0) { <br>                DWORD dwNow = GetTickCount(); <br> <br>                // Working with differences handles wrap-around <br>                DWORD dwDiff = dwNow - dwStart; <br>                if (dwDiff &gt; dwWait) { <br>                    dwWait = 0; <br>                } else { <br>                    dwWait -= dwDiff; <br>                } <br>                dwStart = dwNow; <br>            } <br>            if (!bPeeked) { <br>                //  Raise our priority to prevent our message queue <br>                //  building up <br>                dwThreadPriority = GetThreadPriority(GetCurrentThread()); <br>                if (dwThreadPriority &lt; THREAD_PRIORITY_HIGHEST) { <br>                    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST); <br>                } <br>                bPeeked = TRUE; <br>            } <br>        } else { <br>            break; <br>        } <br>    } <br>    if (bPeeked) { <br>        SetThreadPriority(GetCurrentThread(), dwThreadPriority); <br>        if (HIWORD(GetQueueStatus(QS_POSTMESSAGE)) &amp; QS_POSTMESSAGE) { <br>            //  Send dummy message <br>            PostThreadMessage(GetCurrentThreadId(), WM_NULL, 0, 0); <br>        } <br>    } <br>    return dwResult; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
