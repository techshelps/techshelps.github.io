<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WINCTRL.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2785"></a>WINCTRL.CPP</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>// Video control interface base classes, December 1995 <br> <br>#include &lt;streams.h&gt; <br> <br>// The control interface methods require us to be connected <br> <br>#define CheckConnected(pin,code)                    \ <br>{                                                   \ <br>    if (pin == NULL) {                              \ <br>        ASSERT(!TEXT("Pin not set"));               \ <br>    } else if (pin-&gt;IsConnected() == FALSE) {       \ <br>        return (code);                              \ <br>    }                                               \ <br>} <br> <br>// This checks to see whether the window has a drain. An application can in <br>// most environments set the owner/parent of windows so that they appear in <br>// a compound document context (for example). In this case, the application <br>// would probably like to be told of any keyboard/mouse messages. Therefore <br>// we pass these messages on untranslated, returning TRUE if we're successful <br> <br>BOOL WINAPI PossiblyEatMessage(HWND hwndDrain, UINT uMsg, WPARAM wParam, LPARAM lParam) <br>{ <br>    if (hwndDrain != NULL &amp;&amp; !InSendMessage()) <br>    { <br>        switch (uMsg) <br>        { <br>            case WM_CHAR: <br>            case WM_DEADCHAR: <br>            case WM_KEYDOWN: <br>            case WM_KEYUP: <br>            case WM_LBUTTONDBLCLK: <br>            case WM_LBUTTONDOWN: <br>            case WM_LBUTTONUP: <br>            case WM_MBUTTONDBLCLK: <br>            case WM_MBUTTONDOWN: <br>            case WM_MBUTTONUP: <br>            case WM_MOUSEACTIVATE: <br>            case WM_MOUSEMOVE: <br>            // If we pass this on we don't get any mouse clicks <br>            //case WM_NCHITTEST: <br>            case WM_NCLBUTTONDBLCLK: <br>            case WM_NCLBUTTONDOWN: <br>            case WM_NCLBUTTONUP: <br>            case WM_NCMBUTTONDBLCLK: <br>            case WM_NCMBUTTONDOWN: <br>            case WM_NCMBUTTONUP: <br>            case WM_NCMOUSEMOVE: <br>            case WM_NCRBUTTONDBLCLK: <br>            case WM_NCRBUTTONDOWN: <br>            case WM_NCRBUTTONUP: <br>            case WM_RBUTTONDBLCLK: <br>            case WM_RBUTTONDOWN: <br>            case WM_RBUTTONUP: <br>            case WM_SYSCHAR: <br>            case WM_SYSDEADCHAR: <br>            case WM_SYSKEYDOWN: <br>            case WM_SYSKEYUP: <br> <br>                DbgLog((LOG_TRACE, 2, TEXT("Forwarding %x to drain"))); <br>                PostMessage(hwndDrain, uMsg, wParam, lParam); <br> <br>                return TRUE; <br>        } <br>    } <br>    return FALSE; <br>} <br> <br> <br>// This class implements the IVideoWindow control functions (dual interface) <br>// we support a large number of properties and methods designed to allow the <br>// client (whether it be an automation controller or a C/C++ application) to <br>// set and get a number of window related properties such as it's position. <br>// We also support some methods that duplicate the properties but provide a <br>// more direct and efficient mechanism as many values may be changed in one <br> <br>CBaseControlWindow::CBaseControlWindow( <br>                        CBaseFilter *pFilter,        // Owning filter <br>                        CCritSec *pInterfaceLock,    // Locking object <br>                        TCHAR *pName,                // Object description <br>                        LPUNKNOWN pUnk,              // Normal COM ownership <br>                        HRESULT *phr) :              // OLE return code <br> <br>    CBaseVideoWindow(pName,pUnk), <br>    m_pInterfaceLock(pInterfaceLock), <br>    m_hwndOwner(NULL), <br>    m_hwndDrain(NULL), <br>    m_bAutoShow(TRUE), <br>    m_pFilter(pFilter), <br>    m_bCursorHidden(FALSE), <br>    m_pPin(NULL) <br>{ <br>    ASSERT(m_pFilter); <br>    ASSERT(m_pInterfaceLock); <br>    ASSERT(phr); <br>    m_BorderColour = VIDEO_COLOUR; <br>} <br> <br> <br>// Set the title caption on the base window, we don't do any field checking <br>// as we really don't care what title they intend to have. We can always get <br>// it back again later with GetWindowText. The only other complication is to <br>// do the necessary string conversions between ANSI and OLE Unicode strings <br> <br>STDMETHODIMP CBaseControlWindow::put_Caption(BSTR strCaption) <br>{ <br>    CheckPointer(strCaption,E_POINTER); <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>#ifdef UNICODE <br>    SetWindowText(m_hwnd, strCaption); <br>#else <br>    CHAR Caption[CAPTION]; <br> <br>    WideCharToMultiByte(CP_ACP,0,strCaption,-1,Caption,CAPTION,NULL,NULL); <br>    SetWindowText(m_hwnd, Caption); <br>#endif <br>    return NOERROR; <br>} <br> <br> <br>// Get the current base window title caption, once again we do no real field <br>// checking. We allocate a string for the window title to be filled in with <br>// which ensures the interface doesn't fiddle around with getting memory. A <br>// BSTR is a normal C string with the length at position (-1), we use the <br>// WriteBSTR helper function to create the caption to try and avoid OLE32 <br> <br>STDMETHODIMP CBaseControlWindow::get_Caption(BSTR *pstrCaption) <br>{ <br>    CheckPointer(pstrCaption,E_POINTER); <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    WCHAR WideCaption[CAPTION]; <br> <br>#ifdef UNICODE <br>    GetWindowText(m_hwnd,WideCaption,CAPTION); <br>#else <br>    // Convert the ASCII caption to a UNICODE string <br> <br>    TCHAR Caption[CAPTION]; <br>    GetWindowText(m_hwnd,Caption,CAPTION); <br>    MultiByteToWideChar(CP_ACP,0,Caption,-1,WideCaption,CAPTION); <br>#endif <br>    return WriteBSTR(pstrCaption,WideCaption); <br>} <br> <br> <br>// Set the window style using GWL_EXSTYLE <br> <br>STDMETHODIMP CBaseControlWindow::put_WindowStyleEx(long WindowStyleEx) <br>{ <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br> <br>    // Should we be taking off WS_EX_TOPMOST <br> <br>    if (GetWindowLong(m_hwnd,GWL_EXSTYLE) &amp; WS_EX_TOPMOST) { <br>        if ((WindowStyleEx &amp; WS_EX_TOPMOST) == 0) { <br>            SendMessage(m_hwnd,m_ShowStageTop,(WPARAM) FALSE,(LPARAM) 0); <br>        } <br>    } <br> <br>    // Likewise should we be adding WS_EX_TOPMOST <br> <br>    if (WindowStyleEx &amp; WS_EX_TOPMOST) { <br>        SendMessage(m_hwnd,m_ShowStageTop,(WPARAM) TRUE,(LPARAM) 0); <br>        WindowStyleEx &amp;= (~WS_EX_TOPMOST); <br>        if (WindowStyleEx == 0) return NOERROR; <br>    } <br>    return DoSetWindowStyle(WindowStyleEx,GWL_EXSTYLE); <br>} <br> <br> <br>// Gets the current GWL_EXSTYLE base window style <br> <br>STDMETHODIMP CBaseControlWindow::get_WindowStyleEx(long *pWindowStyleEx) <br>{ <br>    CheckPointer(pWindowStyleEx,E_POINTER); <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    return DoGetWindowStyle(pWindowStyleEx,GWL_EXSTYLE); <br>} <br> <br> <br>// Set the window style using GWL_STYLE <br> <br>STDMETHODIMP CBaseControlWindow::put_WindowStyle(long WindowStyle) <br>{ <br>    // These styles cannot be changed dynamically <br> <br>    if ((WindowStyle &amp; WS_DISABLED) || <br>        (WindowStyle &amp; WS_ICONIC) || <br>        (WindowStyle &amp; WS_MAXIMIZE) || <br>        (WindowStyle &amp; WS_MINIMIZE) || <br>        (WindowStyle &amp; WS_HSCROLL) || <br>        (WindowStyle &amp; WS_VSCROLL)) { <br> <br>            return E_INVALIDARG; <br>    } <br> <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    return DoSetWindowStyle(WindowStyle,GWL_STYLE); <br>} <br> <br> <br>// Get the current GWL_STYLE base window style <br> <br>STDMETHODIMP CBaseControlWindow::get_WindowStyle(long *pWindowStyle) <br>{ <br>    CheckPointer(pWindowStyle,E_POINTER); <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    return DoGetWindowStyle(pWindowStyle,GWL_STYLE); <br>} <br> <br> <br>// Change the base window style or the extended styles depending on whether <br>// WindowLong is GWL_STYLE or GWL_EXSTYLE. We must call SetWindowPos to have <br>// the window displayed in it's new style after the change which is a little <br>// tricky if the window is not currently visible as we realise it offscreen. <br>// In most cases the client will call get_WindowStyle before they call this <br>// and then AND and OR in extra bit settings according to the requirements <br> <br>HRESULT CBaseControlWindow::DoSetWindowStyle(long Style,long WindowLong) <br>{ <br>    RECT WindowRect; <br> <br>    // Get the window's visibility before setting the style <br>    BOOL bVisible = IsWindowVisible(m_hwnd); <br>    EXECUTE_ASSERT(GetWindowRect(m_hwnd,&amp;WindowRect)); <br> <br>    // Set the new style flags for the window <br>    SetWindowLong(m_hwnd,WindowLong,Style); <br>    UINT WindowFlags = SWP_SHOWWINDOW | SWP_FRAMECHANGED | SWP_NOACTIVATE; <br>    WindowFlags |= SWP_NOZORDER | SWP_NOSIZE | SWP_NOMOVE; <br> <br>    // Show the window again in the current position <br> <br>    if (bVisible == TRUE) { <br> <br>        SetWindowPos(m_hwnd,            // Base window handle <br>                     HWND_TOP,          // Just a place holder <br>                     0,0,0,0,           // Leave size and position <br>                     WindowFlags);      // Just draw it again <br> <br>        return NOERROR; <br>    } <br> <br>    // Move the window offscreen so the user doesn't see the changes <br> <br>    MoveWindow((HWND) m_hwnd,                     // Base window handle <br>               GetSystemMetrics(SM_CXSCREEN),     // Current desktop width <br>               GetSystemMetrics(SM_CYSCREEN),     // Likewise it's height <br>               WIDTH(&amp;WindowRect),                // Use the same width <br>               HEIGHT(&amp;WindowRect),               // Keep height same to <br>               TRUE);                             // May as well repaint <br> <br>    // Now show the previously hidden window <br> <br>    SetWindowPos(m_hwnd,            // Base window handle <br>                 HWND_TOP,          // Just a place holder <br>                 0,0,0,0,           // Leave size and position <br>                 WindowFlags);      // Just draw it again <br> <br>    EXECUTE_ASSERT(ShowWindow(m_hwnd,SW_HIDE)); <br> <br>    if (GetParent(m_hwnd)) { <br> <br>        MapWindowPoints(HWND_DESKTOP, GetParent(m_hwnd), (LPPOINT)&amp;WindowRect, 2); <br>    } <br> <br>    MoveWindow((HWND) m_hwnd,        // Base window handle <br>               WindowRect.left,      // Existing x coordinate <br>               WindowRect.top,       // Existing y coordinate <br>               WIDTH(&amp;WindowRect),   // Use the same width <br>               HEIGHT(&amp;WindowRect),  // Keep height same to <br>               TRUE);                // May as well repaint <br> <br>    return NOERROR; <br>} <br> <br> <br>// Get the current base window style (either GWL_STYLE or GWL_EXSTYLE) <br> <br>HRESULT CBaseControlWindow::DoGetWindowStyle(long *pStyle,long WindowLong) <br>{ <br>    *pStyle = GetWindowLong(m_hwnd,WindowLong); <br>    return NOERROR; <br>} <br> <br> <br>// Change the visibility of the base window, this takes the same parameters <br>// as the ShowWindow Win32 API does, so the client can have the window hidden <br>// or shown, minimised to an icon, or maximised to play in full screen mode <br>// We pass the request on to the base window to actually make the change <br> <br>STDMETHODIMP CBaseControlWindow::put_WindowState(long WindowState) <br>{ <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    DoShowWindow(WindowState); <br>    return NOERROR; <br>} <br> <br> <br>// Get the current window state, this function returns a subset of the SW bit <br>// settings available in ShowWindow, if the window is visible then SW_SHOW is <br>// set, if it is hidden then the SW_HIDDEN is set, if it is either minimised <br>// or maximised then the SW_MINIMIZE or SW_MAXIMIZE is set respectively. The <br>// other SW bit settings are really set commands not readable output values <br> <br>STDMETHODIMP CBaseControlWindow::get_WindowState(long *pWindowState) <br>{ <br>    CheckPointer(pWindowState,E_POINTER); <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    ASSERT(pWindowState); <br>    *pWindowState = FALSE; <br> <br>    // Is the base window iconic <br> <br>    if (IsIconic(m_hwnd) == TRUE) { <br>        *pWindowState |= SW_MINIMIZE; <br>    } <br> <br>    // Has the window been maximised <br> <br>    if (IsZoomed(m_hwnd) == TRUE) { <br>        *pWindowState |= SW_MAXIMIZE; <br>    } <br> <br>    // Is the window visible, a window is termed visible if it is somewhere on <br>    // the current desktop even if it is completely obscured by other windows <br>    // so the flag is a style for each window set with the WS_VISIBLE bit <br> <br>    if (IsWindowVisible(m_hwnd) == TRUE) { <br>        *pWindowState |= SW_SHOW; <br>    } else { <br>        *pWindowState |= SW_HIDE; <br>    } <br>    return NOERROR; <br>} <br> <br> <br>// This makes sure that any palette we realise in the base window (through a <br>// media type or through the overlay interface) is done in the background and <br>// is therefore mapped to existing device entries rather than taking it over <br>// as it will do when we this window gets the keyboard focus. An application <br>// uses this to make sure it doesn't have it's palette removed by the window <br> <br>STDMETHODIMP CBaseControlWindow::put_BackgroundPalette(long BackgroundPalette) <br>{ <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    CAutoLock cWindowLock(&amp;m_WindowLock); <br> <br>    // Check this is a valid automation boolean type <br> <br>    if (BackgroundPalette != OATRUE) { <br>        if (BackgroundPalette != OAFALSE) { <br>            return E_INVALIDARG; <br>        } <br>    } <br> <br>    // Make sure the window realises any palette it has again <br> <br>    m_bBackground = (BackgroundPalette == OATRUE ? TRUE : FALSE); <br>    PostMessage(m_hwnd,m_RealizePalette,0,0); <br>    PaintWindow(FALSE); <br> <br>    return NOERROR; <br>} <br> <br> <br>// This returns the current background realisation setting <br> <br>STDMETHODIMP <br>CBaseControlWindow::get_BackgroundPalette(long *pBackgroundPalette) <br>{ <br>    CheckPointer(pBackgroundPalette,E_POINTER); <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    CAutoLock cWindowLock(&amp;m_WindowLock); <br> <br>    // Get the current background palette setting <br> <br>    *pBackgroundPalette = (m_bBackground == TRUE ? OATRUE : OAFALSE); <br>    return NOERROR; <br>} <br> <br> <br>// Change the visibility of the base window <br> <br>STDMETHODIMP CBaseControlWindow::put_Visible(long Visible) <br>{ <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br> <br>    // Check this is a valid automation boolean type <br> <br>    if (Visible != OATRUE) { <br>        if (Visible != OAFALSE) { <br>            return E_INVALIDARG; <br>        } <br>    } <br> <br>    // Convert the boolean visibility into SW_SHOW and SW_HIDE <br> <br>    INT Mode = (Visible == OATRUE ? SW_SHOWNORMAL : SW_HIDE); <br>    DoShowWindow(Mode); <br>    return NOERROR; <br>} <br> <br> <br>// Return OATRUE if the window is currently visible otherwise OAFALSE <br> <br>STDMETHODIMP CBaseControlWindow::get_Visible(long *pVisible) <br>{ <br>    CheckPointer(pVisible,E_POINTER); <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br> <br>    // See if the base window has a WS_VISIBLE style - this will return TRUE <br>    // even if the window is completely obscured by other desktop windows, we <br>    // return FALSE if the window is not showing because of earlier calls <br> <br>    BOOL Mode = IsWindowVisible(m_hwnd); <br>    *pVisible = (Mode == TRUE ? OATRUE : OAFALSE); <br>    return NOERROR; <br>} <br> <br> <br>// Change the left position of the base window. This keeps the window width <br>// and height properties the same so it effectively shunts the window left or <br>// right accordingly - there is the Width property to change that dimension <br> <br>STDMETHODIMP CBaseControlWindow::put_Left(long Left) <br>{ <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    BOOL bSuccess; <br>    RECT WindowRect; <br> <br>    // Get the current window position in a RECT <br>    EXECUTE_ASSERT(GetWindowRect(m_hwnd,&amp;WindowRect)); <br> <br>    if (GetParent(m_hwnd)) { <br> <br>        MapWindowPoints(HWND_DESKTOP, GetParent(m_hwnd), (LPPOINT)&amp;WindowRect, 2); <br>    } <br> <br>    // Adjust the coordinates ready for SetWindowPos, the window rectangle we <br>    // get back from GetWindowRect is in left,top,right and bottom while the <br>    // coordinates SetWindowPos wants are left,top,width and height values <br> <br>    WindowRect.bottom = WindowRect.bottom - WindowRect.top; <br>    WindowRect.right = WindowRect.right - WindowRect.left; <br>    UINT WindowFlags = SWP_NOZORDER | SWP_FRAMECHANGED | SWP_NOACTIVATE; <br> <br>    bSuccess = SetWindowPos(m_hwnd,                // Window handle <br>                            HWND_TOP,              // Put it at the top <br>                            Left,                  // New left position <br>                            WindowRect.top,        // Leave top alone <br>                            WindowRect.right,      // The WIDTH (not right) <br>                            WindowRect.bottom,     // The HEIGHT (not bottom) <br>                            WindowFlags);          // Show window options <br> <br>    if (bSuccess == FALSE) { <br>        return E_INVALIDARG; <br>    } <br>    return NOERROR; <br>} <br> <br> <br>// Return the current base window left position <br> <br>STDMETHODIMP CBaseControlWindow::get_Left(long *pLeft) <br>{ <br>    CheckPointer(pLeft,E_POINTER); <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    RECT WindowRect; <br> <br>    EXECUTE_ASSERT(GetWindowRect(m_hwnd,&amp;WindowRect)); <br>    *pLeft = WindowRect.left; <br>    return NOERROR; <br>} <br> <br> <br>// Change the current width of the base window. This property complements the <br>// left position property so we must keep the left edge constant and expand or <br>// contract to the right, the alternative would be to change the left edge so <br>// keeping the right edge constant but this is maybe a little more intuitive <br> <br>STDMETHODIMP CBaseControlWindow::put_Width(long Width) <br>{ <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    BOOL bSuccess; <br>    RECT WindowRect; <br> <br>    // Adjust the coordinates ready for SetWindowPos, the window rectangle we <br>    // get back from GetWindowRect is in left,top,right and bottom while the <br>    // coordinates SetWindowPos wants are left,top,width and height values <br> <br>    EXECUTE_ASSERT(GetWindowRect(m_hwnd,&amp;WindowRect)); <br> <br>    if (GetParent(m_hwnd)) { <br> <br>        MapWindowPoints(HWND_DESKTOP, GetParent(m_hwnd), (LPPOINT)&amp;WindowRect, 2); <br>    } <br> <br>    WindowRect.bottom = WindowRect.bottom - WindowRect.top; <br>    UINT WindowFlags = SWP_NOZORDER | SWP_FRAMECHANGED | SWP_NOACTIVATE; <br> <br>    // This seems to have a bug in that calling SetWindowPos on a window with <br>    // just the width changing causes it to ignore the width that you pass in <br>    // and sets it to a mimimum value of 110 pixels wide (Windows NT 3.51) <br> <br>    bSuccess = SetWindowPos(m_hwnd,                // Window handle <br>                            HWND_TOP,              // Put it at the top <br>                            WindowRect.left,       // Leave left alone <br>                            WindowRect.top,        // Leave top alone <br>                            Width,                 // New WIDTH dimension <br>                            WindowRect.bottom,     // The HEIGHT (not bottom) <br>                            WindowFlags);          // Show window options <br> <br>    if (bSuccess == FALSE) { <br>        return E_INVALIDARG; <br>    } <br>    return NOERROR; <br>} <br> <br> <br>// Return the current base window width <br> <br>STDMETHODIMP CBaseControlWindow::get_Width(long *pWidth) <br>{ <br>    CheckPointer(pWidth,E_POINTER); <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    RECT WindowRect; <br> <br>    EXECUTE_ASSERT(GetWindowRect(m_hwnd,&amp;WindowRect)); <br>    *pWidth = WindowRect.right - WindowRect.left; <br>    return NOERROR; <br>} <br> <br> <br>// This allows the client program to change the top position for the window in <br>// the same way that changing the left position does not affect the width of <br>// the image so changing the top position does not affect the window height <br> <br>STDMETHODIMP CBaseControlWindow::put_Top(long Top) <br>{ <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    BOOL bSuccess; <br>    RECT WindowRect; <br> <br>    // Get the current window position in a RECT <br>    EXECUTE_ASSERT(GetWindowRect(m_hwnd,&amp;WindowRect)); <br> <br>    if (GetParent(m_hwnd)) { <br> <br>        MapWindowPoints(HWND_DESKTOP, GetParent(m_hwnd), (LPPOINT)&amp;WindowRect, 2); <br>    } <br> <br>    // Adjust the coordinates ready for SetWindowPos, the window rectangle we <br>    // get back from GetWindowRect is in left,top,right and bottom while the <br>    // coordinates SetWindowPos wants are left,top,width and height values <br> <br>    WindowRect.bottom = WindowRect.bottom - WindowRect.top; <br>    WindowRect.right = WindowRect.right - WindowRect.left; <br>    UINT WindowFlags = SWP_NOZORDER | SWP_FRAMECHANGED | SWP_NOACTIVATE; <br> <br>    bSuccess = SetWindowPos(m_hwnd,                // Window handle <br>                            HWND_TOP,              // Put it at the top <br>                            WindowRect.left,       // Leave left alone <br>                            Top,                   // New top position <br>                            WindowRect.right,      // The WIDTH (not right) <br>                            WindowRect.bottom,     // The HEIGHT (not bottom) <br>                            WindowFlags);          // Show window flags <br> <br>    if (bSuccess == FALSE) { <br>        return E_INVALIDARG; <br>    } <br>    return NOERROR; <br>} <br> <br> <br>// Return the current base window top position <br> <br>STDMETHODIMP CBaseControlWindow::get_Top(long *pTop) <br>{ <br>    CheckPointer(pTop,E_POINTER); <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    RECT WindowRect; <br> <br>    EXECUTE_ASSERT(GetWindowRect(m_hwnd,&amp;WindowRect)); <br>    *pTop = WindowRect.top; <br>    return NOERROR; <br>} <br> <br> <br>// Change the height of the window, this complements the top property so when <br>// we change this we must keep the top position for the base window, as said <br>// before we could keep the bottom and grow upwards although this is perhaps <br>// a little more intuitive since we already have a top position property <br> <br>STDMETHODIMP CBaseControlWindow::put_Height(long Height) <br>{ <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    BOOL bSuccess; <br>    RECT WindowRect; <br> <br>    // Adjust the coordinates ready for SetWindowPos, the window rectangle we <br>    // get back from GetWindowRect is in left,top,right and bottom while the <br>    // coordinates SetWindowPos wants are left,top,width and height values <br> <br>    EXECUTE_ASSERT(GetWindowRect(m_hwnd,&amp;WindowRect)); <br> <br>    if (GetParent(m_hwnd)) { <br> <br>        MapWindowPoints(HWND_DESKTOP, GetParent(m_hwnd), (LPPOINT)&amp;WindowRect, 2); <br>    } <br> <br>    WindowRect.right = WindowRect.right - WindowRect.left; <br>    UINT WindowFlags = SWP_NOZORDER | SWP_FRAMECHANGED | SWP_NOACTIVATE; <br> <br>    bSuccess = SetWindowPos(m_hwnd,                // Window handle <br>                            HWND_TOP,              // Put it at the top <br>                            WindowRect.left,       // Leave left alone <br>                            WindowRect.top,        // Leave top alone <br>                            WindowRect.right,      // The WIDTH (not right) <br>                            Height,                // New height dimension <br>                            WindowFlags);          // Show window flags <br> <br>    if (bSuccess == FALSE) { <br>        return E_INVALIDARG; <br>    } <br>    return NOERROR; <br>} <br> <br> <br>// Return the current base window height <br> <br>STDMETHODIMP CBaseControlWindow::get_Height(long *pHeight) <br>{ <br>    CheckPointer(pHeight,E_POINTER); <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    RECT WindowRect; <br> <br>    EXECUTE_ASSERT(GetWindowRect(m_hwnd,&amp;WindowRect)); <br>    *pHeight = WindowRect.bottom - WindowRect.top; <br>    return NOERROR; <br>} <br> <br> <br>// This can be called to change the owning window. Setting the owner is done <br>// through this function, however to make the window a true child window the <br>// style must also be set to WS_CHILD. After resetting the owner to NULL an <br>// application should also set the style to WS_OVERLAPPED | WS_CLIPCHILDREN. <br> <br>// We cannot lock the object here because the SetParent causes an interthread <br>// SendMessage to the owner window. If they are in GetState we will sit here <br>// incomplete with the critical section locked therefore blocking out source <br>// filter threads from accessing us. Because the source thread can't enter us <br>// it can't get buffers or call EndOfStream so the GetState will not complete <br> <br>STDMETHODIMP CBaseControlWindow::put_Owner(OAHWND Owner) <br>{ <br>    // Check we are connected otherwise reject the call <br> <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    m_hwndOwner = (HWND) Owner; <br>    HWND hwndParent = m_hwndOwner; <br> <br>    // Add or remove WS_CHILD as appropriate <br> <br>    LONG Style = GetWindowLong(m_hwnd,GWL_STYLE); <br>    if (Owner == NULL) { <br>        Style &amp;= (~WS_CHILD); <br>    } else { <br>        Style |= (WS_CHILD); <br>    } <br>    SetWindowLong(m_hwnd,GWL_STYLE,Style); <br> <br>    // Don't call this with the filter locked <br> <br>    SetParent(m_hwnd,hwndParent); <br> <br>    PaintWindow(TRUE); <br>    NOTE1("Changed parent %lx",hwndParent); <br> <br>    return NOERROR; <br>} <br> <br> <br>// This complements the put_Owner to get the current owning window property <br>// we always return NOERROR although the returned window handle may be NULL <br>// to indicate no owning window (the desktop window doesn't qualify as one) <br>// If an application sets the owner we call SetParent, however that returns <br>// NULL until the WS_CHILD bit is set on, so we store the owner internally <br> <br>STDMETHODIMP CBaseControlWindow::get_Owner(OAHWND *Owner) <br>{ <br>    CheckPointer(Owner,E_POINTER); <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    *Owner = (OAHWND) m_hwndOwner; <br>    return NOERROR; <br>} <br> <br> <br>// And renderer supporting IVideoWindow may have an HWND set who will get any <br>// keyboard and mouse messages we receive posted on to them. This is separate <br>// from setting an owning window. By separating the two, applications may get <br>// messages sent on even when they have set no owner (perhaps it's maximised) <br> <br>STDMETHODIMP CBaseControlWindow::put_MessageDrain(OAHWND Drain) <br>{ <br>    // Check we are connected otherwise reject the call <br> <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    m_hwndDrain = (HWND) Drain; <br>    return NOERROR; <br>} <br> <br> <br>// Return the current message drain <br> <br>STDMETHODIMP CBaseControlWindow::get_MessageDrain(OAHWND *Drain) <br>{ <br>    CheckPointer(Drain,E_POINTER); <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    *Drain = (OAHWND) m_hwndDrain; <br>    return NOERROR; <br>} <br> <br> <br>// This is called by the filter graph to inform us of a message we should know <br>// is being sent to our owning window. We have this because as a child window <br>// we do not get certain messages that are only sent to top level windows. We <br>// must see the palette changed/changing/query messages so that we know if we <br>// have the foreground palette or not. We pass the message on to our window <br>// using SendMessage - this will cause an interthread send message to occur <br> <br>STDMETHODIMP <br>CBaseControlWindow::NotifyOwnerMessage(long hwnd,    // Window handle <br>                                       long uMsg,    // Message ID <br>                                       long wParam,  // Parameters <br>                                       long lParam)  // for message <br>{ <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br> <br>    // Only interested in these Windows messages <br> <br>    switch (uMsg) { <br> <br>        case WM_SYSCOLORCHANGE: <br>        case WM_PALETTECHANGED: <br>        case WM_PALETTEISCHANGING: <br>        case WM_QUERYNEWPALETTE: <br>        case WM_DEVMODECHANGE: <br>        case WM_DISPLAYCHANGE: <br>        case WM_ACTIVATEAPP: <br> <br>            // If we do not have an owner then ignore <br> <br>            if (m_hwndOwner == NULL) { <br>                return NOERROR; <br>            } <br>            SendMessage(m_hwnd,uMsg,(WPARAM)wParam,(LPARAM)lParam); <br>    } <br>    return NOERROR; <br>} <br> <br> <br>// Allow an application to have us set the base window in the foreground. We <br>// have this because it is difficult for one thread to do do this to a window <br>// owned by another thread. We ask the base window class to do the real work <br> <br>STDMETHODIMP CBaseControlWindow::SetWindowForeground(long Focus) <br>{ <br>    // Check this is a valid automation boolean type <br> <br>    if (Focus != OATRUE) { <br>        if (Focus != OAFALSE) { <br>            return E_INVALIDARG; <br>        } <br>    } <br> <br>    // We shouldn't lock as this sends a message <br> <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    BOOL bFocus = (Focus == OATRUE ? TRUE : FALSE); <br>    DoSetWindowForeground(bFocus); <br> <br>    return NOERROR; <br>} <br> <br> <br>// This allows a client to set the complete window size and position in one <br>// atomic operation. The same affect can be had by changing each dimension <br>// in turn through their individual properties although some flashing will <br>// occur as each of them gets updated (they are better set at design time) <br> <br>STDMETHODIMP <br>CBaseControlWindow::SetWindowPosition(long Left,long Top,long Width,long Height) <br>{ <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    BOOL bSuccess; <br> <br>    // Set the new size and position <br>    UINT WindowFlags = SWP_NOZORDER | SWP_FRAMECHANGED | SWP_NOACTIVATE; <br> <br>    ASSERT(IsWindow(m_hwnd)); <br>    bSuccess = SetWindowPos(m_hwnd,         // Window handle <br>                            HWND_TOP,       // Put it at the top <br>                            Left,           // Left position <br>                            Top,            // Top position <br>                            Width,          // Window width <br>                            Height,         // Window height <br>                            WindowFlags);   // Show window flags <br>    ASSERT(bSuccess); <br>#ifdef DEBUG <br>    DbgLog((LOG_TRACE, 1, TEXT("SWP failed error %d"), GetLastError())); <br>#endif <br>    if (bSuccess == FALSE) { <br>        return E_INVALIDARG; <br>    } <br>    return NOERROR; <br>} <br> <br> <br>// This complements the SetWindowPosition to return the current window place <br>// in device coordinates. As before the same information can be retrived by <br>// calling the property get functions individually but this is atomic and is </code></pre>
<p>
</p>
<pre><code>// therefore more suitable to a live environment rather than design time <br> <br>STDMETHODIMP <br>CBaseControlWindow::GetWindowPosition(long *pLeft,long *pTop,long *pWidth,long *pHeight) <br>{ <br>    // Should check the pointers are not NULL <br> <br>    CheckPointer(pLeft,E_POINTER); <br>    CheckPointer(pTop,E_POINTER); <br>    CheckPointer(pWidth,E_POINTER); <br>    CheckPointer(pHeight,E_POINTER); <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    RECT WindowRect; <br> <br>    // Get the current window coordinates <br> <br>    EXECUTE_ASSERT(GetWindowRect(m_hwnd,&amp;WindowRect)); <br> <br>    // Convert the RECT into left,top,width and height values <br> <br>    *pLeft = WindowRect.left; <br>    *pTop = WindowRect.top; <br>    *pWidth = WindowRect.right - WindowRect.left; <br>    *pHeight = WindowRect.bottom - WindowRect.top; <br> <br>    return NOERROR; <br>} <br> <br> <br>// When a window is maximised or iconic calling GetWindowPosition will return <br>// the current window position (likewise for the properties). However if the <br>// restored size (ie the size we'll return to when normally shown) is needed <br>// then this should be used. When in a normal position (neither iconic nor <br>// maximised) then this returns the same coordinates as GetWindowPosition <br> <br>STDMETHODIMP <br>CBaseControlWindow::GetRestorePosition(long *pLeft,long *pTop,long *pWidth,long *pHeight) <br>{ <br>    // Should check the pointers are not NULL <br> <br>    CheckPointer(pLeft,E_POINTER); <br>    CheckPointer(pTop,E_POINTER); <br>    CheckPointer(pWidth,E_POINTER); <br>    CheckPointer(pHeight,E_POINTER); <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br> <br>    // Use GetWindowPlacement to find the restore position <br> <br>    WINDOWPLACEMENT Place; <br>    Place.length = sizeof(WINDOWPLACEMENT); <br>    EXECUTE_ASSERT(GetWindowPlacement(m_hwnd,&amp;Place)); <br> <br>    RECT WorkArea; <br> <br>    // We must take into account any task bar present <br> <br>    if (SystemParametersInfo(SPI_GETWORKAREA,0,&amp;WorkArea,FALSE) == TRUE) { <br>        if (GetParent(m_hwnd) == NULL) { <br>            Place.rcNormalPosition.top += WorkArea.top; <br>            Place.rcNormalPosition.bottom += WorkArea.top; <br>            Place.rcNormalPosition.left += WorkArea.left; <br>            Place.rcNormalPosition.right += WorkArea.left; <br>        } <br>    } <br> <br>    // Convert the RECT into left,top,width and height values <br> <br>    *pLeft = Place.rcNormalPosition.left; <br>    *pTop = Place.rcNormalPosition.top; <br>    *pWidth = Place.rcNormalPosition.right - Place.rcNormalPosition.left; <br>    *pHeight = Place.rcNormalPosition.bottom - Place.rcNormalPosition.top; <br> <br>    return NOERROR; <br>} <br> <br> <br>// Return the current border colour, if we are playing something to a subset <br>// of the base window display there is an outside area exposed. The default <br>// action is to paint this colour in the Windows background colour (defined <br>// as value COLOR_WINDOW) We reset to this default when we're disconnected <br> <br>STDMETHODIMP CBaseControlWindow::get_BorderColor(long *Color) <br>{ <br>    CheckPointer(Color,E_POINTER); <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    *Color = (long) m_BorderColour; <br>    return NOERROR; <br>} <br> <br> <br>// This can be called to set the current border colour <br> <br>STDMETHODIMP CBaseControlWindow::put_BorderColor(long Color) <br>{ <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br> <br>    // Have the window repainted with the new border colour <br> <br>    m_BorderColour = (COLORREF) Color; <br>    PaintWindow(TRUE); <br>    return NOERROR; <br>} <br> <br> <br>// Delegate fullscreen handling to plug in distributor <br> <br>STDMETHODIMP CBaseControlWindow::get_FullScreenMode(long *FullScreenMode) <br>{ <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    CheckPointer(FullScreenMode,E_POINTER); <br>    return E_NOTIMPL; <br>} <br> <br> <br>// Delegate fullscreen handling to plug in distributor <br> <br>STDMETHODIMP CBaseControlWindow::put_FullScreenMode(long FullScreenMode) <br>{ <br>    return E_NOTIMPL; <br>} <br> <br> <br>// This sets the auto show property, this property causes the base window to <br>// be displayed whenever we change state. This allows an application to have <br>// to do nothing to have the window appear but still allow them to change the <br>// default behaviour if for example they want to keep it hidden for longer <br> <br>STDMETHODIMP CBaseControlWindow::put_AutoShow(long AutoShow) <br>{ <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br> <br>    // Check this is a valid automation boolean type <br> <br>    if (AutoShow != OATRUE) { <br>        if (AutoShow != OAFALSE) { <br>            return E_INVALIDARG; <br>        } <br>    } <br> <br>    m_bAutoShow = (AutoShow == OATRUE ? TRUE : FALSE); <br>    return NOERROR; <br>} <br> <br> <br>// This can be called to get the current auto show flag. The flag is updated <br>// when we connect and disconnect and through this interface all of which are <br>// controlled and serialised by means of the main renderer critical section <br> <br>STDMETHODIMP CBaseControlWindow::get_AutoShow(long *AutoShow) <br>{ <br>    CheckPointer(AutoShow,E_POINTER); <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    *AutoShow = (m_bAutoShow == TRUE ? OATRUE : OAFALSE); <br>    return NOERROR; <br>} <br> <br> <br>// Return the minimum ideal image size for the current video. This may differ <br>// to the actual video dimensions because we may be using DirectDraw hardware <br>// that has specific stretching requirements. For example the Cirrus Logic <br>// cards have a minimum stretch factor depending on the overlay surface size <br> <br>STDMETHODIMP <br>CBaseControlWindow::GetMinIdealImageSize(long *pWidth,long *pHeight) <br>{ <br>    CheckPointer(pWidth,E_POINTER); <br>    CheckPointer(pHeight,E_POINTER); <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    FILTER_STATE State; <br> <br>    // Must not be stopped for this to work correctly <br> <br>    m_pFilter-&gt;GetState(0,&amp;State); <br>    if (State == State_Stopped) { <br>        return VFW_E_WRONG_STATE; <br>    } <br> <br>    RECT DefaultRect = GetDefaultRect(); <br>    *pWidth = WIDTH(&amp;DefaultRect); <br>    *pHeight = HEIGHT(&amp;DefaultRect); <br>    return NOERROR; <br>} <br> <br> <br>// Return the maximum ideal image size for the current video. This may differ <br>// to the actual video dimensions because we may be using DirectDraw hardware <br>// that has specific stretching requirements. For example the Cirrus Logic <br>// cards have a maximum stretch factor depending on the overlay surface size <br> <br>STDMETHODIMP <br>CBaseControlWindow::GetMaxIdealImageSize(long *pWidth,long *pHeight) <br>{ <br>    CheckPointer(pWidth,E_POINTER); <br>    CheckPointer(pHeight,E_POINTER); <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    FILTER_STATE State; <br> <br>    // Must not be stopped for this to work correctly <br> <br>    m_pFilter-&gt;GetState(0,&amp;State); <br>    if (State == State_Stopped) { <br>        return VFW_E_WRONG_STATE; <br>    } <br> <br>    RECT DefaultRect = GetDefaultRect(); <br>    *pWidth = WIDTH(&amp;DefaultRect); <br>    *pHeight = HEIGHT(&amp;DefaultRect); <br>    return NOERROR; <br>} <br> <br> <br>// Allow an application to hide the cursor on our window <br> <br>STDMETHODIMP <br>CBaseControlWindow::HideCursor(long HideCursor) <br>{ <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br> <br>    // Check this is a valid automation boolean type <br> <br>    if (HideCursor != OATRUE) { <br>        if (HideCursor != OAFALSE) { <br>            return E_INVALIDARG; <br>        } <br>    } <br> <br>    m_bCursorHidden = (HideCursor == OATRUE ? TRUE : FALSE); <br>    return NOERROR; <br>} <br> <br> <br>// Returns whether we have the cursor hidden or not <br> <br>STDMETHODIMP CBaseControlWindow::IsCursorHidden(long *CursorHidden) <br>{ <br>    CheckPointer(CursorHidden,E_POINTER); <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    *CursorHidden = (m_bCursorHidden == TRUE ? OATRUE : OAFALSE); <br>    return NOERROR; <br>} <br> <br> <br>// This class implements the IBasicVideo control functions (dual interface) <br>// we support a large number of properties and methods designed to allow the <br>// client (whether it be an automation controller or a C/C++ application) to <br>// set and get a number of video related properties such as the native video <br>// size. We support some methods that duplicate the properties but provide a <br>// more direct and efficient mechanism as many values may be changed in one <br> <br>CBaseControlVideo::CBaseControlVideo( <br>                        CBaseFilter *pFilter,        // Owning filter <br>                        CCritSec *pInterfaceLock,    // Locking object <br>                        TCHAR *pName,                // Object description <br>                        LPUNKNOWN pUnk,              // Normal COM ownership <br>                        HRESULT *phr) :              // OLE return code <br> <br>    CBaseBasicVideo(pName,pUnk), <br>    m_pFilter(pFilter), <br>    m_pInterfaceLock(pInterfaceLock), <br>    m_pPin(NULL) <br>{ <br>    ASSERT(m_pFilter); <br>    ASSERT(m_pInterfaceLock); <br>    ASSERT(phr); <br>} <br> <br>// Return an approximate average time per frame <br> <br>STDMETHODIMP CBaseControlVideo::get_AvgTimePerFrame(REFTIME *pAvgTimePerFrame) <br>{ <br>    CheckPointer(pAvgTimePerFrame,E_POINTER); <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    CAutoLock cInterfaceLock(m_pInterfaceLock); <br> <br>    VIDEOINFOHEADER *pVideoInfo = GetVideoFormat(); <br>    if (pVideoInfo == NULL) <br>    return E_OUTOFMEMORY; <br>    COARefTime AvgTime(pVideoInfo-&gt;AvgTimePerFrame); <br>    *pAvgTimePerFrame = (REFTIME) AvgTime; <br> <br>    return NOERROR; <br>} <br> <br> <br>// Return an approximate bit rate for the video <br> <br>STDMETHODIMP CBaseControlVideo::get_BitRate(long *pBitRate) <br>{ <br>    CheckPointer(pBitRate,E_POINTER); <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    CAutoLock cInterfaceLock(m_pInterfaceLock); <br> <br>    VIDEOINFOHEADER *pVideoInfo = GetVideoFormat(); <br>    if (pVideoInfo == NULL) <br>    return E_OUTOFMEMORY; <br>    *pBitRate = pVideoInfo-&gt;dwBitRate; <br>    return NOERROR; <br>} <br> <br> <br>// Return an approximate bit error rate <br> <br>STDMETHODIMP CBaseControlVideo::get_BitErrorRate(long *pBitErrorRate) <br>{ <br>    CheckPointer(pBitErrorRate,E_POINTER); <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    CAutoLock cInterfaceLock(m_pInterfaceLock); <br> <br>    VIDEOINFOHEADER *pVideoInfo = GetVideoFormat(); <br>    if (pVideoInfo == NULL) <br>    return E_OUTOFMEMORY; <br>    *pBitErrorRate = pVideoInfo-&gt;dwBitErrorRate; <br>    return NOERROR; <br>} <br> <br> <br>// This returns the current video width <br> <br>STDMETHODIMP CBaseControlVideo::get_VideoWidth(long *pVideoWidth) <br>{ <br>    CheckPointer(pVideoWidth,E_POINTER); <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    CAutoLock cInterfaceLock(m_pInterfaceLock); <br> <br>    VIDEOINFOHEADER *pVideoInfo = GetVideoFormat(); <br>    if (pVideoInfo == NULL) <br>    return E_OUTOFMEMORY; <br>    *pVideoWidth = pVideoInfo-&gt;bmiHeader.biWidth; <br>    return NOERROR; <br>} <br> <br> <br>// This returns the current video height <br> <br>STDMETHODIMP CBaseControlVideo::get_VideoHeight(long *pVideoHeight) <br>{ <br>    CheckPointer(pVideoHeight,E_POINTER); <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    CAutoLock cInterfaceLock(m_pInterfaceLock); <br> <br>    VIDEOINFOHEADER *pVideoInfo = GetVideoFormat(); <br>    if (pVideoInfo == NULL) <br>    return E_OUTOFMEMORY; <br>    *pVideoHeight = pVideoInfo-&gt;bmiHeader.biHeight; <br>    return NOERROR; <br>} <br> <br> <br>// This returns the current palette the video is using as an array allocated <br>// by the user. To remain consistent we use PALETTEENTRY fields to return the <br>// colours in rather than RGBQUADs that multimedia decided to use. The memory <br>// is allocated by the user so we simple copy each in turn. We check that the <br>// number of entries requested and the start position offset are both valid <br>// If the number of entries evaluates to zero then we return an S_FALSE code <br> <br>STDMETHODIMP CBaseControlVideo::GetVideoPaletteEntries(long StartIndex, <br>                                                       long Entries, <br>                                                       long *pRetrieved, <br>                                                       long *pPalette) <br>{ <br>    CheckPointer(pRetrieved,E_POINTER); <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    CAutoLock cInterfaceLock(m_pInterfaceLock); <br>    CMediaType MediaType; <br> <br>    // Get the video format from the derived class <br> <br>    VIDEOINFOHEADER *pVideoInfo = GetVideoFormat(); <br>    if (pVideoInfo == NULL) <br>    return E_OUTOFMEMORY; <br>    BITMAPINFOHEADER *pHeader = HEADER(pVideoInfo); <br> <br>    // Is the current format palettised <br> <br>    if (PALETTISED(pVideoInfo) == FALSE) { <br>        *pRetrieved = 0; <br>        return VFW_E_NO_PALETTE_AVAILABLE; <br>    } <br> <br>    // Do they just want to know how many are available <br> <br>    if (pPalette == NULL) { <br>        *pRetrieved = pHeader-&gt;biClrUsed; <br>        return NOERROR; <br>    } <br> <br>    // Make sure the start position is a valid offset <br> <br>    if (StartIndex &gt;= (LONG) pHeader-&gt;biClrUsed || StartIndex &lt; 0) { <br>        *pRetrieved = 0; <br>        return E_INVALIDARG; <br>    } <br> <br>    // Correct the number we can retrieve <br> <br>    LONG Available = (LONG) pHeader-&gt;biClrUsed - StartIndex; <br>    *pRetrieved = max(0,min(Available,Entries)); <br>    if (*pRetrieved == 0) { <br>        return S_FALSE; <br>    } <br> <br>    // Copy the palette entries to the output buffer <br> <br>    PALETTEENTRY *pEntries = (PALETTEENTRY *) pPalette; <br>    RGBQUAD *pColours = COLORS(pVideoInfo) + StartIndex; <br> <br>    for (LONG Count = 0;Count &lt; *pRetrieved;Count++) { <br>        pEntries[Count].peRed = pColours[Count].rgbRed; <br>        pEntries[Count].peGreen = pColours[Count].rgbGreen; <br>        pEntries[Count].peBlue = pColours[Count].rgbBlue; <br>        pEntries[Count].peFlags = 0; <br>    } <br>    return NOERROR; <br>} <br> <br> <br>// This returns the current video dimensions as a method rather than a number <br>// of individual property get calls. For the same reasons as said before we <br>// cannot access the renderer media type directly as the window object thread <br>// may be updating it since dynamic format changes may change these values <br> <br>STDMETHODIMP CBaseControlVideo::GetVideoSize(long *pWidth,long *pHeight) <br>{ <br>    CheckPointer(pWidth,E_POINTER); <br>    CheckPointer(pHeight,E_POINTER); <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    CAutoLock cInterfaceLock(m_pInterfaceLock); <br> <br>    // Get the video format from the derived class <br>    VIDEOINFOHEADER *pVideoInfo = GetVideoFormat(); <br>    if (pVideoInfo == NULL) <br>    return E_OUTOFMEMORY; <br>    *pWidth = pVideoInfo-&gt;bmiHeader.biWidth; <br>    *pHeight = pVideoInfo-&gt;bmiHeader.biHeight; <br>    return NOERROR; <br>} <br> <br> <br>// Set the source video rectangle as left,top,right and bottom coordinates <br>// rather than left,top,width and height as per OLE automation interfaces <br>// Then pass the rectangle on to the window object to set the source <br> <br>STDMETHODIMP <br>CBaseControlVideo::SetSourcePosition(long Left,long Top,long Width,long Height) <br>{ <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    CAutoLock cInterfaceLock(m_pInterfaceLock); <br>    RECT SourceRect; <br>    SourceRect.left = Left; <br>    SourceRect.top = Top; <br>    SourceRect.right = Left + Width; <br>    SourceRect.bottom = Top + Height; <br> <br>    // Check the source rectangle is valid <br> <br>    HRESULT hr = CheckSourceRect(&amp;SourceRect); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br> <br>    // Now set the source rectangle <br> <br>    hr = SetSourceRect(&amp;SourceRect); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br>    return OnUpdateRectangles(); <br>} <br> <br> <br>// Return the source rectangle in left,top,width and height rather than the <br>// left,top,right and bottom values that RECT uses (and which the window <br>// object returns through GetSourceRect) which requires a little work <br> <br>STDMETHODIMP <br>CBaseControlVideo::GetSourcePosition(long *pLeft,long *pTop,long *pWidth,long *pHeight) <br>{ <br>    // Should check the pointers are non NULL <br> <br>    CheckPointer(pLeft,E_POINTER); <br>    CheckPointer(pTop,E_POINTER); <br>    CheckPointer(pWidth,E_POINTER); <br>    CheckPointer(pHeight,E_POINTER); <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    RECT SourceRect; <br> <br>    CAutoLock cInterfaceLock(m_pInterfaceLock); <br>    GetSourceRect(&amp;SourceRect); <br> <br>    *pLeft = SourceRect.left; <br>    *pTop = SourceRect.top; <br>    *pWidth = WIDTH(&amp;SourceRect); <br>    *pHeight = HEIGHT(&amp;SourceRect); <br> <br>    return NOERROR; <br>} <br> <br> <br>// Set the video destination as left,top,right and bottom coordinates rather <br>// than the left,top,width and height uses as per OLE automation interfaces <br>// Then pass the rectangle on to the window object to set the destination <br> <br>STDMETHODIMP <br>CBaseControlVideo::SetDestinationPosition(long Left,long Top,long Width,long Height) <br>{ <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    CAutoLock cInterfaceLock(m_pInterfaceLock); <br>    RECT DestinationRect; <br> <br>    DestinationRect.left = Left; <br>    DestinationRect.top = Top; <br>    DestinationRect.right = Left + Width; <br>    DestinationRect.bottom = Top + Height; <br> <br>    // Check the target rectangle is valid <br> <br>    HRESULT hr = CheckTargetRect(&amp;DestinationRect); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br> <br>    // Now set the new target rectangle <br> <br>    hr = SetTargetRect(&amp;DestinationRect); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br>    return OnUpdateRectangles(); <br>} <br> <br> <br>// Return the destination rectangle in left,top,width and height rather than <br>// the left,top,right and bottom values that RECT uses (and which the window <br>// object returns through GetDestinationRect) which requires a little work <br> <br>STDMETHODIMP <br>CBaseControlVideo::GetDestinationPosition(long *pLeft,long *pTop,long *pWidth,long *pHeight) <br>{ <br>    // Should check the pointers are not NULL <br> <br>    CheckPointer(pLeft,E_POINTER); <br>    CheckPointer(pTop,E_POINTER); <br>    CheckPointer(pWidth,E_POINTER); <br>    CheckPointer(pHeight,E_POINTER); <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    RECT DestinationRect; <br> <br>    CAutoLock cInterfaceLock(m_pInterfaceLock); <br>    GetTargetRect(&amp;DestinationRect); <br> <br>    *pLeft = DestinationRect.left; <br>    *pTop = DestinationRect.top; <br>    *pWidth = WIDTH(&amp;DestinationRect); <br>    *pHeight = HEIGHT(&amp;DestinationRect); <br> <br>    return NOERROR; <br>} <br> <br> <br>// Set the source left position, the source rectangle we get back from the <br>// window object is a true rectangle in left,top,right and bottom positions <br>// so all we have to do is to update the left position and pass it back. We <br>// must keep the current width constant when we're updating this property <br> <br>STDMETHODIMP CBaseControlVideo::put_SourceLeft(long SourceLeft) <br>{ <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    CAutoLock cInterfaceLock(m_pInterfaceLock); <br>    RECT SourceRect; <br>    GetSourceRect(&amp;SourceRect); <br>    SourceRect.right = SourceLeft + WIDTH(&amp;SourceRect); <br>    SourceRect.left = SourceLeft; <br> <br>    // Check the source rectangle is valid <br> <br>    HRESULT hr = CheckSourceRect(&amp;SourceRect); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br> <br>    // Now set the source rectangle <br> <br>    hr = SetSourceRect(&amp;SourceRect); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br>    return OnUpdateRectangles(); <br>} <br> <br> <br>// Return the current left source video position <br> <br>STDMETHODIMP CBaseControlVideo::get_SourceLeft(long *pSourceLeft) <br>{ <br>    CheckPointer(pSourceLeft,E_POINTER); <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    CAutoLock cInterfaceLock(m_pInterfaceLock); <br>    RECT SourceRect; <br> <br>    GetSourceRect(&amp;SourceRect); <br>    *pSourceLeft = SourceRect.left; <br>    return NOERROR; <br>} <br> <br> <br>// Set the source width, we get the current source rectangle and then update <br>// the right position to be the left position (thereby keeping it constant) <br>// plus the new source width we are passed in (it expands to the right) <br> <br>STDMETHODIMP CBaseControlVideo::put_SourceWidth(long SourceWidth) <br>{ <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    CAutoLock cInterfaceLock(m_pInterfaceLock); <br>    RECT SourceRect; <br>    GetSourceRect(&amp;SourceRect); <br>    SourceRect.right = SourceRect.left + SourceWidth; <br> <br>    // Check the source rectangle is valid <br> <br>    HRESULT hr = CheckSourceRect(&amp;SourceRect); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br> <br>    // Now set the source rectangle <br> <br>    hr = SetSourceRect(&amp;SourceRect); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br>    return OnUpdateRectangles(); <br>} <br> <br> <br>// Return the current source width <br> <br>STDMETHODIMP CBaseControlVideo::get_SourceWidth(long *pSourceWidth) <br>{ <br>    CheckPointer(pSourceWidth,E_POINTER); <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    CAutoLock cInterfaceLock(m_pInterfaceLock); <br>    RECT SourceRect; <br> <br>    GetSourceRect(&amp;SourceRect); <br>    *pSourceWidth = WIDTH(&amp;SourceRect); <br>    return NOERROR; <br>} <br> <br> <br>// Set the source top position - changing this property does not affect the <br>// current source height. So changing this shunts the source rectangle up and <br>// down appropriately. Changing the height complements this functionality by <br>// keeping the top position constant and simply changing the source height <br> <br>STDMETHODIMP CBaseControlVideo::put_SourceTop(long SourceTop) <br>{ <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    CAutoLock cInterfaceLock(m_pInterfaceLock); <br>    RECT SourceRect; <br>    GetSourceRect(&amp;SourceRect); <br>    SourceRect.bottom = SourceTop + HEIGHT(&amp;SourceRect); <br>    SourceRect.top = SourceTop; <br> <br>    // Check the source rectangle is valid <br> <br>    HRESULT hr = CheckSourceRect(&amp;SourceRect); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br> <br>    // Now set the source rectangle <br> <br>    hr = SetSourceRect(&amp;SourceRect); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br>    return OnUpdateRectangles(); <br>} <br> <br> <br>// Return the current top position <br> <br>STDMETHODIMP CBaseControlVideo::get_SourceTop(long *pSourceTop) <br>{ <br>    CheckPointer(pSourceTop,E_POINTER); <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    CAutoLock cInterfaceLock(m_pInterfaceLock); <br>    RECT SourceRect; <br> <br>    GetSourceRect(&amp;SourceRect); <br>    *pSourceTop = SourceRect.top; <br>    return NOERROR; <br>} <br> <br> <br>// Set the source height <br> <br>STDMETHODIMP CBaseControlVideo::put_SourceHeight(long SourceHeight) <br>{ <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    CAutoLock cInterfaceLock(m_pInterfaceLock); <br>    RECT SourceRect; <br>    GetSourceRect(&amp;SourceRect); <br>    SourceRect.bottom = SourceRect.top + SourceHeight; <br> <br>    // Check the source rectangle is valid <br> <br>    HRESULT hr = CheckSourceRect(&amp;SourceRect); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br> <br>    // Now set the source rectangle <br> <br>    hr = SetSourceRect(&amp;SourceRect); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br>    return OnUpdateRectangles(); <br>} <br> <br> <br>// Return the current source height <br> <br>STDMETHODIMP CBaseControlVideo::get_SourceHeight(long *pSourceHeight) <br>{ <br>    CheckPointer(pSourceHeight,E_POINTER); <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    CAutoLock cInterfaceLock(m_pInterfaceLock); <br>    RECT SourceRect; <br> <br>    GetSourceRect(&amp;SourceRect); <br>    *pSourceHeight = HEIGHT(&amp;SourceRect); <br>    return NOERROR; <br>} <br> <br> <br>// Set the target left position, the target rectangle we get back from the <br>// window object is a true rectangle in left,top,right and bottom positions <br>// so all we have to do is to update the left position and pass it back. We <br>// must keep the current width constant when we're updating this property <br> <br>STDMETHODIMP CBaseControlVideo::put_DestinationLeft(long DestinationLeft) <br>{ <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    CAutoLock cInterfaceLock(m_pInterfaceLock); <br>    RECT DestinationRect; <br>    GetTargetRect(&amp;DestinationRect); <br>    DestinationRect.right = DestinationLeft + WIDTH(&amp;DestinationRect); <br>    DestinationRect.left = DestinationLeft; <br> <br>    // Check the target rectangle is valid <br> <br>    HRESULT hr = CheckTargetRect(&amp;DestinationRect); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br> <br>    // Now set the new target rectangle <br> <br>    hr = SetTargetRect(&amp;DestinationRect); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br>    return OnUpdateRectangles(); <br>} <br> <br> <br>// Return the left position for the destination rectangle <br> <br>STDMETHODIMP CBaseControlVideo::get_DestinationLeft(long *pDestinationLeft) <br>{ <br>    CheckPointer(pDestinationLeft,E_POINTER); <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    CAutoLock cInterfaceLock(m_pInterfaceLock); <br>    RECT DestinationRect; <br> <br>    GetTargetRect(&amp;DestinationRect); <br>    *pDestinationLeft = DestinationRect.left; <br>    return NOERROR; <br>} <br> <br> <br>// Set the destination width <br> <br>STDMETHODIMP CBaseControlVideo::put_DestinationWidth(long DestinationWidth) <br>{ <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    CAutoLock cInterfaceLock(m_pInterfaceLock); <br>    RECT DestinationRect; <br>    GetTargetRect(&amp;DestinationRect); <br>    DestinationRect.right = DestinationRect.left + DestinationWidth; <br> <br>    // Check the target rectangle is valid <br> <br>    HRESULT hr = CheckTargetRect(&amp;DestinationRect); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br> <br>    // Now set the new target rectangle <br> <br>    hr = SetTargetRect(&amp;DestinationRect); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br>    return OnUpdateRectangles(); <br>} <br> <br> <br>// Return the width for the destination rectangle <br> <br>STDMETHODIMP CBaseControlVideo::get_DestinationWidth(long *pDestinationWidth) <br>{ <br>    CheckPointer(pDestinationWidth,E_POINTER); <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    CAutoLock cInterfaceLock(m_pInterfaceLock); <br>    RECT DestinationRect; <br> <br>    GetTargetRect(&amp;DestinationRect); <br>    *pDestinationWidth = WIDTH(&amp;DestinationRect); <br>    return NOERROR; <br>} <br> <br> <br>// Set the target top position - changing this property does not affect the <br>// current target height. So changing this shunts the target rectangle up and <br>// down appropriately. Changing the height complements this functionality by <br>// keeping the top position constant and simply changing the target height <br> <br>STDMETHODIMP CBaseControlVideo::put_DestinationTop(long DestinationTop) <br>{ <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    CAutoLock cInterfaceLock(m_pInterfaceLock); <br>    RECT DestinationRect; <br>    GetTargetRect(&amp;DestinationRect); <br>    DestinationRect.bottom = DestinationTop + HEIGHT(&amp;DestinationRect); <br>    DestinationRect.top = DestinationTop; <br> <br>    // Check the target rectangle is valid <br> <br>    HRESULT hr = CheckTargetRect(&amp;DestinationRect); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br> <br>    // Now set the new target rectangle <br> <br>    hr = SetTargetRect(&amp;DestinationRect); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br>    return OnUpdateRectangles(); <br>} <br> <br> <br>// Return the top position for the destination rectangle <br> <br>STDMETHODIMP CBaseControlVideo::get_DestinationTop(long *pDestinationTop) <br>{ <br>    CheckPointer(pDestinationTop,E_POINTER); <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    CAutoLock cInterfaceLock(m_pInterfaceLock); <br>    RECT DestinationRect; <br> <br>    GetTargetRect(&amp;DestinationRect); <br>    *pDestinationTop = DestinationRect.top; <br>    return NOERROR; <br>} <br> <br> <br>// Set the destination height <br> <br>STDMETHODIMP CBaseControlVideo::put_DestinationHeight(long DestinationHeight) <br>{ <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    CAutoLock cInterfaceLock(m_pInterfaceLock); <br>    RECT DestinationRect; <br>    GetTargetRect(&amp;DestinationRect); <br>    DestinationRect.bottom = DestinationRect.top + DestinationHeight; <br> <br>    // Check the target rectangle is valid <br> <br>    HRESULT hr = CheckTargetRect(&amp;DestinationRect); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br> <br>    // Now set the new target rectangle <br> <br>    hr = SetTargetRect(&amp;DestinationRect); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br>    return OnUpdateRectangles(); <br>} <br> <br> <br>// Return the height for the destination rectangle <br> <br>STDMETHODIMP CBaseControlVideo::get_DestinationHeight(long *pDestinationHeight) <br>{ <br>    CheckPointer(pDestinationHeight,E_POINTER); <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    CAutoLock cInterfaceLock(m_pInterfaceLock); <br>    RECT DestinationRect; <br> <br>    GetTargetRect(&amp;DestinationRect); <br>    *pDestinationHeight = HEIGHT(&amp;DestinationRect); <br>    return NOERROR; <br>} <br> <br> <br>// Reset the source rectangle to the full video dimensions <br> <br>STDMETHODIMP CBaseControlVideo::SetDefaultSourcePosition() <br>{ <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    CAutoLock cInterfaceLock(m_pInterfaceLock); <br>    HRESULT hr = SetDefaultSourceRect(); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br>    return OnUpdateRectangles(); <br>} <br> <br> <br>// Return S_OK if we're using the default source otherwise S_FALSE <br> <br>STDMETHODIMP CBaseControlVideo::IsUsingDefaultSource() <br>{ <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    CAutoLock cInterfaceLock(m_pInterfaceLock); <br>    return IsDefaultSourceRect(); <br>} <br> <br> <br>// Reset the video renderer to use the entire playback area <br> <br>STDMETHODIMP CBaseControlVideo::SetDefaultDestinationPosition() <br>{ <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    CAutoLock cInterfaceLock(m_pInterfaceLock); <br>    HRESULT hr = SetDefaultTargetRect(); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br>    return OnUpdateRectangles(); <br>} <br> <br> <br>// Return S_OK if we're using the default target otherwise S_FALSE <br> <br>STDMETHODIMP CBaseControlVideo::IsUsingDefaultDestination() <br>{ <br>    CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    CAutoLock cInterfaceLock(m_pInterfaceLock); <br>    return IsDefaultTargetRect(); <br>} <br> <br> <br>// Return a copy of the current image in the video renderer <br> <br>STDMETHODIMP <br>CBaseControlVideo::GetCurrentImage(long *pBufferSize,long *pVideoImage) <br>{ <br>    CheckPointer(pBufferSize,E_POINTER); </code></pre>
<p>
</p>
<pre><code>CheckConnected(m_pPin,VFW_E_NOT_CONNECTED); <br>    CAutoLock cInterfaceLock(m_pInterfaceLock); <br>    FILTER_STATE State; <br> <br>    // Make sure we are in a paused state <br> <br>    if (pVideoImage != NULL) { <br>        m_pFilter-&gt;GetState(0,&amp;State); <br>        if (State != State_Paused) { <br>            return VFW_E_NOT_PAUSED; <br>        } <br>        return GetStaticImage(pBufferSize,pVideoImage); <br>    } <br> <br>    // Just return the memory required <br> <br>    VIDEOINFOHEADER *pVideoInfo = GetVideoFormat(); <br>    if (pVideoInfo == NULL) <br>    return E_OUTOFMEMORY; <br>    RECT SourceRect; <br>    GetSourceRect(&amp;SourceRect); <br>    return GetImageSize(pVideoInfo,pBufferSize,&amp;SourceRect); <br>} <br> <br> <br>// An application has two ways of using GetCurrentImage, one is to pass a real <br>// buffer which should be filled with the current image. The other is to pass <br>// a NULL buffer pointer which is interpreted as asking us to return how much <br>// memory is required for the image. The constraints for when the latter can <br>// be called are much looser. To calculate the memory required we synthesize <br>// a VIDEOINFO that takes into account the source rectangle that's being used <br> <br>HRESULT CBaseControlVideo::GetImageSize(VIDEOINFOHEADER *pVideoInfo, <br>                                        LONG *pBufferSize, <br>                                        RECT *pSourceRect) <br>{ <br>    NOTE("Entering GetImageSize"); <br>    ASSERT(pSourceRect); <br> <br>    // Check we have the correct input parameters <br> <br>    if (pSourceRect == NULL || <br>            pVideoInfo == NULL || <br>            pBufferSize == NULL) { <br> <br>        return E_UNEXPECTED; <br>    } <br> <br>    // Is the data format compatible <br> <br>    if (pVideoInfo-&gt;bmiHeader.biCompression != BI_RGB) { <br>        if (pVideoInfo-&gt;bmiHeader.biCompression != BI_BITFIELDS) { <br>            return E_INVALIDARG; <br>        } <br>    } <br> <br>    ASSERT(IsRectEmpty(pSourceRect) == FALSE); <br> <br>    BITMAPINFOHEADER bih; <br>    bih.biWidth = WIDTH(pSourceRect); <br>    bih.biHeight = HEIGHT(pSourceRect); <br>    bih.biBitCount = pVideoInfo-&gt;bmiHeader.biBitCount; <br>    LONG Size = DIBSIZE(bih); <br>    Size += GetBitmapFormatSize(HEADER(pVideoInfo)) - SIZE_PREHEADER; <br>    *pBufferSize = Size; <br> <br>    return NOERROR; <br>} <br> <br> <br>// Given an IMediaSample containing a linear buffer with an image and a type <br>// describing the bitmap make a rendering of the image into the output buffer <br>// This may be called by derived classes who render typical video images to <br>// handle the IBasicVideo GetCurrentImage method. The pVideoImage pointer may <br>// be NULL when passed to GetCurrentImage in which case GetImageSize will be <br>// called instead, which will just do the calculation of the memory required <br> <br>HRESULT CBaseControlVideo::CopyImage(IMediaSample *pMediaSample, <br>                                     VIDEOINFOHEADER *pVideoInfo, <br>                                     LONG *pBufferSize, <br>                                     BYTE *pVideoImage, <br>                                     RECT *pSourceRect) <br>{ <br>    NOTE("Entering CopyImage"); <br>    ASSERT(pSourceRect); <br>    BYTE *pCurrentImage; <br> <br>    // Check we have an image to copy <br> <br>    if (pMediaSample == NULL || pSourceRect == NULL || <br>            pVideoInfo == NULL || pVideoImage == NULL || <br>            pBufferSize == NULL) { <br> <br>        return E_UNEXPECTED; <br>    } <br> <br>    // Is the data format compatible <br> <br>    if (pVideoInfo-&gt;bmiHeader.biCompression != BI_RGB) { <br>        if (pVideoInfo-&gt;bmiHeader.biCompression != BI_BITFIELDS) { <br>            return E_INVALIDARG; <br>        } <br>    } <br> <br>    ASSERT(IsRectEmpty(pSourceRect) == FALSE); <br> <br>    BITMAPINFOHEADER bih; <br>    bih.biWidth = WIDTH(pSourceRect); <br>    bih.biHeight = HEIGHT(pSourceRect); <br>    bih.biBitCount = pVideoInfo-&gt;bmiHeader.biBitCount; <br>    LONG Size = GetBitmapFormatSize(HEADER(pVideoInfo)) - SIZE_PREHEADER; <br>    LONG Total = Size + DIBSIZE(bih); <br> <br>    // Make sure we have a large enough buffer <br> <br>    if (*pBufferSize &lt; Total) { <br>        return E_OUTOFMEMORY; <br>    } <br> <br>    // Copy the BITMAPINFO <br> <br>    CopyMemory((PVOID)pVideoImage, (PVOID)&amp;pVideoInfo-&gt;bmiHeader, Size); <br>    ((BITMAPINFOHEADER *)pVideoImage)-&gt;biWidth = WIDTH(pSourceRect); <br>    ((BITMAPINFOHEADER *)pVideoImage)-&gt;biHeight = HEIGHT(pSourceRect); <br>    ((BITMAPINFOHEADER *)pVideoImage)-&gt;biSizeImage = DIBSIZE(bih); <br>    BYTE *pImageData = pVideoImage + Size; <br> <br>    // Get the pointer to it's image data <br> <br>    HRESULT hr = pMediaSample-&gt;GetPointer(&amp;pCurrentImage); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br> <br>    // Now we are ready to start copying the source scan lines <br> <br>    LONG ScanLine = (pVideoInfo-&gt;bmiHeader.biBitCount / 8) * WIDTH(pSourceRect); <br>    LONG LinesToSkip = pVideoInfo-&gt;bmiHeader.biHeight; <br>    LinesToSkip -= pSourceRect-&gt;top + HEIGHT(pSourceRect); <br>    pCurrentImage += LinesToSkip * DIBWIDTHBYTES(pVideoInfo-&gt;bmiHeader); <br>    pCurrentImage += pSourceRect-&gt;left * (pVideoInfo-&gt;bmiHeader.biBitCount / 8); <br> <br>    // Even money on this GP faulting sometime... <br> <br>    for (LONG Line = 0;Line &lt; HEIGHT(pSourceRect);Line++) { <br>        CopyMemory((PVOID)pImageData, (PVOID)pCurrentImage, ScanLine); <br>        pImageData += DIBWIDTHBYTES(*(BITMAPINFOHEADER *)pVideoImage); <br>        pCurrentImage += DIBWIDTHBYTES(pVideoInfo-&gt;bmiHeader); <br>    } <br>    return NOERROR; <br>} <br> <br> <br>// Called when we change media types either during connection or dynamically <br>// We inform the filter graph and therefore the application that the video <br>// size may have changed, we don't bother looking to see if it really has as <br>// we leave that to the application - the dimensions are the event parameters <br> <br>HRESULT CBaseControlVideo::OnVideoSizeChange() <br>{ <br>    // Get the video format from the derived class <br> <br>    VIDEOINFOHEADER *pVideoInfo = GetVideoFormat(); <br>    if (pVideoInfo == NULL) <br>    return E_OUTOFMEMORY; <br>    WORD Width = (WORD) pVideoInfo-&gt;bmiHeader.biWidth; <br>    WORD Height = (WORD) pVideoInfo-&gt;bmiHeader.biHeight; <br> <br>    return m_pFilter-&gt;NotifyEvent(EC_VIDEO_SIZE_CHANGED, <br>                                  MAKELPARAM(Width,Height), <br>                                  MAKEWPARAM(0,0)); <br>} <br> <br> <br>// Set the video source rectangle. We must check the source rectangle against <br>// the actual video dimensions otherwise when we come to draw the pictures we <br>// get access violations as GDI tries to touch data outside of the image data <br>// Although we store the rectangle in left, top, right and bottom coordinates <br>// instead of left, top, width and height as OLE uses we do take into account <br>// that the rectangle is used up to, but not including, the right column and <br>// bottom row of pixels, see the Win32 documentation on RECT for more details <br> <br>HRESULT CBaseControlVideo::CheckSourceRect(RECT *pSourceRect) <br>{ <br>    CheckPointer(pSourceRect,E_POINTER); <br>    LONG Width,Height; <br>    GetVideoSize(&amp;Width,&amp;Height); <br> <br>    // Check the coordinates are greater than zero <br>    // and that the rectangle is valid (left&lt;right, top&lt;bottom) <br> <br>    if ((pSourceRect-&gt;left &gt;= pSourceRect-&gt;right) || <br>       (pSourceRect-&gt;left &lt; 0) || <br>       (pSourceRect-&gt;top &gt;= pSourceRect-&gt;bottom) || <br>       (pSourceRect-&gt;top &lt; 0)) { <br> <br>        return E_INVALIDARG; <br>    } <br> <br>    // Check the coordinates are less than the extents <br> <br>    if ((pSourceRect-&gt;right &gt; Width) || <br>        (pSourceRect-&gt;bottom &gt; Height)) { <br> <br>        return E_INVALIDARG; <br>    } <br>    return NOERROR; <br>} <br> <br> <br>// Check the target rectangle has some valid coordinates, which amounts to <br>// little more than checking the destination rectangle isn't empty. Derived <br>// classes may call this when they have their SetTargetRect method called to <br>// check the rectangle validity, we do not update the rectangles passed in <br>// Although we store the rectangle in left, top, right and bottom coordinates <br>// instead of left, top, width and height as OLE uses we do take into account <br>// that the rectangle is used up to, but not including, the right column and <br>// bottom row of pixels, see the Win32 documentation on RECT for more details <br> <br>HRESULT CBaseControlVideo::CheckTargetRect(RECT *pTargetRect) <br>{ <br>    // Check the pointer is valid <br> <br>    if (pTargetRect == NULL) { <br>        return E_POINTER; <br>    } <br> <br>    // These overflow the WIDTH and HEIGHT checks <br> <br>    if (pTargetRect-&gt;left &gt; pTargetRect-&gt;right || <br>            pTargetRect-&gt;top &gt; pTargetRect-&gt;bottom) { <br>                return E_INVALIDARG; <br>    } <br> <br>    // Check the rectangle has valid coordinates <br> <br>    if (WIDTH(pTargetRect) &lt;= 0 || HEIGHT(pTargetRect) &lt;= 0) { <br>        return E_INVALIDARG; <br>    } <br> <br>    ASSERT(IsRectEmpty(pTargetRect) == FALSE); <br>    return NOERROR; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
