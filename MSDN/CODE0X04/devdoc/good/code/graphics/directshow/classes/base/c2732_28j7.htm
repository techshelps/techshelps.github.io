<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CTLUTIL.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2743"></a>CTLUTIL.CPP</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>// Base classes implementing IDispatch parsing for the basic control dual <br>// interfaces. Derive from these and implement just the custom method and <br>// property methods. We also implement CPosPassThru that can be used by <br>// renderers and transforms to pass by IMediaPosition and IMediaSeeking <br> <br> <br>#include &lt;streams.h&gt; <br>#include &lt;limits.h&gt; <br>#include "seekpt.h" <br> <br>// 'bool' non standard reserved word <br>#pragma warning(disable:4237) <br> <br> <br>// --- CBaseDispatch implementation ---------- <br>CBaseDispatch::~CBaseDispatch() <br>{ <br>    if (m_pti) { <br>m_pti-&gt;Release(); <br>    } <br>} <br> <br> <br>// return 1 if we support GetTypeInfo <br> <br>STDMETHODIMP <br>CBaseDispatch::GetTypeInfoCount(UINT * pctinfo) <br>{ <br>    CheckPointer(pctinfo,E_POINTER); <br>    ValidateReadWritePtr(pctinfo,sizeof(UINT *)); <br>    *pctinfo = 1; <br>    return S_OK; <br>} <br> <br> <br>typedef HRESULT (STDAPICALLTYPE *LPLOADTYPELIB)( <br>    const OLECHAR FAR *szFile, <br>    ITypeLib FAR* FAR* pptlib); <br> <br>typedef HRESULT (STDAPICALLTYPE *LPLOADREGTYPELIB)(REFGUID rguid, <br>    WORD wVerMajor, <br>    WORD wVerMinor, <br>    LCID lcid, <br>    ITypeLib FAR* FAR* pptlib); <br> <br>// attempt to find our type library <br> <br>STDMETHODIMP <br>CBaseDispatch::GetTypeInfo( <br>  REFIID riid, <br>  UINT itinfo, <br>  LCID lcid, <br>  ITypeInfo ** pptinfo) <br>{ <br>    CheckPointer(pptinfo,E_POINTER); <br>    ValidateReadWritePtr(pptinfo,sizeof(ITypeInfo *)); <br>    HRESULT hr; <br> <br>    *pptinfo = NULL; <br> <br>    // we only support one type element <br>    if (0 != itinfo) { <br>return TYPE_E_ELEMENTNOTFOUND; <br>    } <br> <br>    if (NULL == pptinfo) { <br>return E_POINTER; <br>    } <br> <br>    // always look for neutral <br>    if (NULL == m_pti) { <br> <br>LPLOADTYPELIB    lpfnLoadTypeLib; <br>LPLOADREGTYPELIB    lpfnLoadRegTypeLib; <br>ITypeLib    *ptlib; <br>HINSTANCE    hInst; <br> <br>static const char  szTypeLib[]  = "LoadTypeLib"; <br>static const char  szRegTypeLib[] = "LoadRegTypeLib"; <br>static const WCHAR szControl[]  = L"control.tlb"; <br> <br>// <br>// Try to get the Ole32Aut.dll module handle. <br>// <br> <br>hInst = LoadOLEAut32(); <br>if (hInst == NULL) { <br>    DWORD dwError = GetLastError(); <br>    return HRESULT_FROM_WIN32(dwError); <br>} <br>lpfnLoadRegTypeLib = (LPLOADREGTYPELIB)GetProcAddress(hInst, <br>      szRegTypeLib); <br>if (lpfnLoadRegTypeLib == NULL) { <br>    DWORD dwError = GetLastError(); <br>    return HRESULT_FROM_WIN32(dwError); <br>} <br> <br>hr = (*lpfnLoadRegTypeLib)(LIBID_QuartzTypeLib, 1, 0, // version 1.0 <br>   lcid, &amp;ptlib); <br> <br>if (FAILED(hr)) { <br> <br>    // attempt to load directly - this will fill the <br>    // registry in if it finds it <br> <br>    lpfnLoadTypeLib = (LPLOADTYPELIB)GetProcAddress(hInst, szTypeLib); <br>    if (lpfnLoadTypeLib == NULL) { <br>DWORD dwError = GetLastError(); <br>return HRESULT_FROM_WIN32(dwError); <br>    } <br> <br>    hr = (*lpfnLoadTypeLib)(szControl, &amp;ptlib); <br>    if (FAILED(hr)) { <br>return hr; <br>    } <br>} <br> <br>hr = ptlib-&gt;GetTypeInfoOfGuid( <br>    riid, <br>    &amp;m_pti); <br> <br>ptlib-&gt;Release(); <br> <br>if (FAILED(hr)) { <br>    return hr; <br>} <br>    } <br> <br>    *pptinfo = m_pti; <br>    m_pti-&gt;AddRef(); <br>    return S_OK; <br>} <br> <br> <br>STDMETHODIMP <br>CBaseDispatch::GetIDsOfNames( <br>  REFIID riid, <br>  OLECHAR  ** rgszNames, <br>  UINT cNames, <br>  LCID lcid, <br>  DISPID * rgdispid) <br>{ <br>    // although the IDispatch riid is dead, we use this to pass from <br>    // the interface implementation class to us the iid we are talking about. <br> <br>    ITypeInfo * pti; <br>    HRESULT hr = GetTypeInfo(riid, 0, lcid, &amp;pti); <br> <br>    if (SUCCEEDED(hr)) { <br>hr = pti-&gt;GetIDsOfNames(rgszNames, cNames, rgdispid); <br> <br>pti-&gt;Release(); <br>    } <br>    return hr; <br>} <br> <br> <br>// --- CMediaControl implementation --------- <br> <br>CMediaControl::CMediaControl(const TCHAR * name,LPUNKNOWN pUnk) : <br>    CUnknown(name, pUnk) <br>{ <br>} <br> <br>// expose our interfaces IMediaControl and IUnknown <br> <br>STDMETHODIMP <br>CMediaControl::NonDelegatingQueryInterface(REFIID riid, void **ppv) <br>{ <br>    ValidateReadWritePtr(ppv,sizeof(PVOID)); <br>    if (riid == IID_IMediaControl) { <br>return GetInterface( (IMediaControl *) this, ppv); <br>    } else { <br>return CUnknown::NonDelegatingQueryInterface(riid, ppv); <br>    } <br>} <br> <br> <br>// return 1 if we support GetTypeInfo <br> <br>STDMETHODIMP <br>CMediaControl::GetTypeInfoCount(UINT * pctinfo) <br>{ <br>    return m_basedisp.GetTypeInfoCount(pctinfo); <br>} <br> <br> <br>// attempt to find our type library <br> <br>STDMETHODIMP <br>CMediaControl::GetTypeInfo( <br>  UINT itinfo, <br>  LCID lcid, <br>  ITypeInfo ** pptinfo) <br>{ <br>    return m_basedisp.GetTypeInfo( <br>IID_IMediaControl, <br>itinfo, <br>lcid, <br>pptinfo); <br>} <br> <br> <br>STDMETHODIMP <br>CMediaControl::GetIDsOfNames( <br>  REFIID riid, <br>  OLECHAR  ** rgszNames, <br>  UINT cNames, <br>  LCID lcid, <br>  DISPID * rgdispid) <br>{ <br>    return m_basedisp.GetIDsOfNames( <br>IID_IMediaControl, <br>rgszNames, <br>cNames, <br>lcid, <br>rgdispid); <br>} <br> <br> <br>STDMETHODIMP <br>CMediaControl::Invoke( <br>  DISPID dispidMember, <br>  REFIID riid, <br>  LCID lcid, <br>  WORD wFlags, <br>  DISPPARAMS * pdispparams, <br>  VARIANT * pvarResult, <br>  EXCEPINFO * pexcepinfo, <br>  UINT * puArgErr) <br>{ <br>    // this parameter is a dead leftover from an earlier interface <br>    if (IID_NULL != riid) { <br>return DISP_E_UNKNOWNINTERFACE; <br>    } <br> <br>    ITypeInfo * pti; <br>    HRESULT hr = GetTypeInfo(0, lcid, &amp;pti); <br> <br>    if (FAILED(hr)) { <br>return hr; <br>    } <br> <br>    hr = pti-&gt;Invoke( <br>    (IMediaControl *)this, <br>    dispidMember, <br>    wFlags, <br>    pdispparams, <br>    pvarResult, <br>    pexcepinfo, <br>    puArgErr); <br> <br>    pti-&gt;Release(); <br>    return hr; <br>} <br> <br> <br>// --- CMediaEvent implementation ---------- <br> <br> <br>CMediaEvent::CMediaEvent(const TCHAR * name,LPUNKNOWN pUnk) : <br>    CUnknown(name, pUnk) <br>{ <br>} <br> <br> <br>// expose our interfaces IMediaEvent and IUnknown <br> <br>STDMETHODIMP <br>CMediaEvent::NonDelegatingQueryInterface(REFIID riid, void **ppv) <br>{ <br>    ValidateReadWritePtr(ppv,sizeof(PVOID)); <br>    if (riid == IID_IMediaEvent || riid == IID_IMediaEventEx) { <br>return GetInterface( (IMediaEventEx *) this, ppv); <br>    } else { <br>return CUnknown::NonDelegatingQueryInterface(riid, ppv); <br>    } <br>} <br> <br> <br>// return 1 if we support GetTypeInfo <br> <br>STDMETHODIMP <br>CMediaEvent::GetTypeInfoCount(UINT * pctinfo) <br>{ <br>    return m_basedisp.GetTypeInfoCount(pctinfo); <br>} <br> <br> <br>// attempt to find our type library <br> <br>STDMETHODIMP <br>CMediaEvent::GetTypeInfo( <br>  UINT itinfo, <br>  LCID lcid, <br>  ITypeInfo ** pptinfo) <br>{ <br>    return m_basedisp.GetTypeInfo( <br>IID_IMediaEvent, <br>itinfo, <br>lcid, <br>pptinfo); <br>} <br> <br> <br>STDMETHODIMP <br>CMediaEvent::GetIDsOfNames( <br>  REFIID riid, <br>  OLECHAR  ** rgszNames, <br>  UINT cNames, <br>  LCID lcid, <br>  DISPID * rgdispid) <br>{ <br>    return m_basedisp.GetIDsOfNames( <br>IID_IMediaEvent, <br>rgszNames, <br>cNames, <br>lcid, <br>rgdispid); <br>} <br> <br> <br>STDMETHODIMP <br>CMediaEvent::Invoke( <br>  DISPID dispidMember, <br>  REFIID riid, <br>  LCID lcid, <br>  WORD wFlags, <br>  DISPPARAMS * pdispparams, <br>  VARIANT * pvarResult, <br>  EXCEPINFO * pexcepinfo, <br>  UINT * puArgErr) <br>{ <br>    // this parameter is a dead leftover from an earlier interface <br>    if (IID_NULL != riid) { <br>return DISP_E_UNKNOWNINTERFACE; <br>    } <br> <br>    ITypeInfo * pti; <br>    HRESULT hr = GetTypeInfo(0, lcid, &amp;pti); <br> <br>    if (FAILED(hr)) { <br>return hr; <br>    } <br> <br>    hr = pti-&gt;Invoke( <br>    (IMediaEvent *)this, <br>    dispidMember, <br>    wFlags, <br>    pdispparams, <br>    pvarResult, <br>    pexcepinfo, <br>    puArgErr); <br> <br>    pti-&gt;Release(); <br>    return hr; <br>} <br> <br> <br>// --- CMediaPosition implementation ---------- <br> <br> <br>CMediaPosition::CMediaPosition(const TCHAR * name,LPUNKNOWN pUnk) : <br>    CUnknown(name, pUnk) <br>{ <br>} <br> <br>CMediaPosition::CMediaPosition(const TCHAR * name, <br>                               LPUNKNOWN pUnk, <br>                               HRESULT * phr) : <br>    CUnknown(name, pUnk) <br>{ <br>    UNREFERENCED_PARAMETER(phr); <br>} <br> <br> <br>// expose our interfaces IMediaPosition and IUnknown <br> <br>STDMETHODIMP <br>CMediaPosition::NonDelegatingQueryInterface(REFIID riid, void **ppv) <br>{ <br>    ValidateReadWritePtr(ppv,sizeof(PVOID)); <br>    if (riid == IID_IMediaPosition) { <br>return GetInterface( (IMediaPosition *) this, ppv); <br>    } else { <br>return CUnknown::NonDelegatingQueryInterface(riid, ppv); <br>    } <br>} <br> <br> <br>// return 1 if we support GetTypeInfo <br> <br>STDMETHODIMP <br>CMediaPosition::GetTypeInfoCount(UINT * pctinfo) <br>{ <br>    return m_basedisp.GetTypeInfoCount(pctinfo); <br>} <br> <br> <br>// attempt to find our type library <br> <br>STDMETHODIMP <br>CMediaPosition::GetTypeInfo( <br>  UINT itinfo, <br>  LCID lcid, <br>  ITypeInfo ** pptinfo) <br>{ <br>    return m_basedisp.GetTypeInfo( <br>IID_IMediaPosition, <br>itinfo, <br>lcid, <br>pptinfo); <br>} <br> <br> <br>STDMETHODIMP <br>CMediaPosition::GetIDsOfNames( <br>  REFIID riid, <br>  OLECHAR  ** rgszNames, <br>  UINT cNames, <br>  LCID lcid, <br>  DISPID * rgdispid) <br>{ <br>    return m_basedisp.GetIDsOfNames( <br>IID_IMediaPosition, <br>rgszNames, <br>cNames, <br>lcid, <br>rgdispid); <br>} <br> <br> <br>STDMETHODIMP <br>CMediaPosition::Invoke( <br>  DISPID dispidMember, <br>  REFIID riid, <br>  LCID lcid, <br>  WORD wFlags, <br>  DISPPARAMS * pdispparams, <br>  VARIANT * pvarResult, <br>  EXCEPINFO * pexcepinfo, <br>  UINT * puArgErr) <br>{ <br>    // this parameter is a dead leftover from an earlier interface <br>    if (IID_NULL != riid) { <br>return DISP_E_UNKNOWNINTERFACE; <br>    } <br> <br>    ITypeInfo * pti; <br>    HRESULT hr = GetTypeInfo(0, lcid, &amp;pti); <br> <br>    if (FAILED(hr)) { <br>return hr; <br>    } <br> <br>    hr = pti-&gt;Invoke( <br>    (IMediaPosition *)this, <br>    dispidMember, <br>    wFlags, <br>    pdispparams, <br>    pvarResult, <br>    pexcepinfo, <br>    puArgErr); <br> <br>    pti-&gt;Release(); <br>    return hr; <br>} <br> <br> <br>// --- IMediaPosition and IMediaSeeking pass through class ---------- <br> <br> <br>CPosPassThru::CPosPassThru(const TCHAR *pName, <br>   LPUNKNOWN pUnk, <br>   HRESULT *phr, <br>   IPin *pPin) : <br>    CMediaPosition(pName,pUnk), <br>    m_pPin(pPin) <br>{ <br>    if (pPin == NULL) { <br>*phr = E_POINTER; <br>return; <br>    } <br>} <br> <br> <br>// Expose our IMediaSeeking and IMediaPosition interfaces <br> <br>STDMETHODIMP <br>CPosPassThru::NonDelegatingQueryInterface(REFIID riid,void **ppv) <br>{ <br>    CheckPointer(ppv,E_POINTER); <br>    *ppv = NULL; <br> <br>    if (riid == IID_IMediaSeeking) { <br>return GetInterface( static_cast&lt;IMediaSeeking *&gt;(this), ppv); <br>    } <br>    return CMediaPosition::NonDelegatingQueryInterface(riid,ppv); <br>} <br> <br> <br>// Return the IMediaPosition interface from our peer <br> <br>HRESULT <br>CPosPassThru::GetPeer(IMediaPosition ** ppMP) <br>{ <br>    *ppMP = NULL; <br> <br>    IPin *pConnected; <br>    HRESULT hr = m_pPin-&gt;ConnectedTo(&amp;pConnected); <br>    if (FAILED(hr)) { <br>return E_NOTIMPL; <br>    } <br>    IMediaPosition * pMP; <br>    hr = pConnected-&gt;QueryInterface(IID_IMediaPosition, (void **) &amp;pMP); <br>    pConnected-&gt;Release(); <br>    if (FAILED(hr)) { <br>return E_NOTIMPL; <br>    } <br> <br>    *ppMP = pMP; <br>    return S_OK; <br>} <br> <br> <br>// Return the IMediaSeeking interface from our peer <br> <br>HRESULT <br>CPosPassThru::GetPeerSeeking(IMediaSeeking ** ppMS) <br>{ <br>    *ppMS = NULL; <br> <br>    IPin *pConnected; <br>    HRESULT hr = m_pPin-&gt;ConnectedTo(&amp;pConnected); <br>    if (FAILED(hr)) { <br>return E_NOTIMPL; <br>    } <br>    IMediaSeeking * pMS; <br>    hr = pConnected-&gt;QueryInterface(IID_IMediaSeeking, (void **) &amp;pMS); <br>    pConnected-&gt;Release(); <br>    if (FAILED(hr)) { <br>return E_NOTIMPL; <br>    } <br> <br>    *ppMS = pMS; <br>    return S_OK; <br>} <br> <br> <br>// --- IMediaSeeking methods ---------- <br> <br> <br>STDMETHODIMP <br>CPosPassThru::GetCapabilities(DWORD * pCaps) <br>{ <br>    IMediaSeeking* pMS; <br>    HRESULT hr = GetPeerSeeking(&amp;pMS); <br>    if (FAILED(hr)) { <br>return hr; <br>    } <br> <br>    hr = pMS-&gt;GetCapabilities(pCaps); <br>    pMS-&gt;Release(); <br>    return hr; <br>} <br> <br>STDMETHODIMP <br>CPosPassThru::CheckCapabilities(DWORD * pCaps) <br>{ <br>    IMediaSeeking* pMS; <br>    HRESULT hr = GetPeerSeeking(&amp;pMS); <br>    if (FAILED(hr)) { <br>return hr; <br>    } <br> <br>    hr = pMS-&gt;CheckCapabilities(pCaps); <br>    pMS-&gt;Release(); <br>    return hr; <br>} <br> <br>STDMETHODIMP <br>CPosPassThru::IsFormatSupported(const GUID * pFormat) <br>{ <br>    IMediaSeeking* pMS; <br>    HRESULT hr = GetPeerSeeking(&amp;pMS); <br>    if (FAILED(hr)) { <br>return hr; <br>    } <br> <br>    hr = pMS-&gt;IsFormatSupported(pFormat); <br>    pMS-&gt;Release(); <br>    return hr; <br>} <br> <br> <br>STDMETHODIMP <br>CPosPassThru::QueryPreferredFormat(GUID *pFormat) <br>{ <br>    IMediaSeeking* pMS; <br>    HRESULT hr = GetPeerSeeking(&amp;pMS); <br>    if (FAILED(hr)) { <br>return hr; <br>    } <br> <br>    hr = pMS-&gt;QueryPreferredFormat(pFormat); <br>    pMS-&gt;Release(); <br>    return hr; <br>} <br> <br> <br>STDMETHODIMP <br>CPosPassThru::SetTimeFormat(const GUID * pFormat) <br>{ <br>    IMediaSeeking* pMS; <br>    HRESULT hr = GetPeerSeeking(&amp;pMS); <br>    if (FAILED(hr)) { <br>return hr; <br>    } <br> <br>    hr = pMS-&gt;SetTimeFormat(pFormat); <br>    pMS-&gt;Release(); <br>    return hr; <br>} <br> <br> <br>STDMETHODIMP <br>CPosPassThru::GetTimeFormat(GUID *pFormat) <br>{ <br>    IMediaSeeking* pMS; <br>    HRESULT hr = GetPeerSeeking(&amp;pMS); <br>    if (FAILED(hr)) { <br>return hr; <br>    } <br> <br>    hr = pMS-&gt;GetTimeFormat(pFormat); <br>    pMS-&gt;Release(); <br>    return hr; <br>} <br> <br> <br>STDMETHODIMP <br>CPosPassThru::IsUsingTimeFormat(const GUID * pFormat) <br>{ <br>    IMediaSeeking* pMS; <br>    HRESULT hr = GetPeerSeeking(&amp;pMS); <br>    if (FAILED(hr)) { <br>return hr; <br>    } <br> <br>    hr = pMS-&gt;IsUsingTimeFormat(pFormat); <br>    pMS-&gt;Release(); <br>    return hr; <br>} <br> <br> <br>STDMETHODIMP <br>CPosPassThru::ConvertTimeFormat(LONGLONG * pTarget, const GUID * pTargetFormat, <br>LONGLONG    Source, const GUID * pSourceFormat ) <br>{ <br>    IMediaSeeking* pMS; <br>    HRESULT hr = GetPeerSeeking(&amp;pMS); <br>    if (FAILED(hr)) { <br>return hr; <br>    } <br> <br>    hr = pMS-&gt;ConvertTimeFormat(pTarget, pTargetFormat, Source, pSourceFormat ); <br>    pMS-&gt;Release(); <br>    return hr; <br>} <br> <br> <br>STDMETHODIMP <br>CPosPassThru::SetPositions( LONGLONG * pCurrent, DWORD CurrentFlags <br>  , LONGLONG * pStop, DWORD StopFlags ) <br>{ <br>    IMediaSeeking* pMS; <br>    HRESULT hr = GetPeerSeeking(&amp;pMS); <br>    if (FAILED(hr)) { <br>return hr; <br>    } <br> <br>    hr = pMS-&gt;SetPositions(pCurrent, CurrentFlags, pStop, StopFlags ); <br>    pMS-&gt;Release(); <br>    return hr; <br>} <br> <br>STDMETHODIMP <br>CPosPassThru::GetPositions(LONGLONG *pCurrent, LONGLONG * pStop) <br>{ <br>    IMediaSeeking* pMS; <br>    HRESULT hr = GetPeerSeeking(&amp;pMS); <br>    if (FAILED(hr)) { <br>return hr; <br>    } <br> <br>    hr = pMS-&gt;GetPositions(pCurrent,pStop); <br>    pMS-&gt;Release(); <br>    return hr; <br>} <br> <br>HRESULT <br>CPosPassThru::GetSeekingLongLong <br>( HRESULT (__stdcall IMediaSeeking::*pMethod)( LONGLONG * ) <br>, LONGLONG * pll <br>) <br>{ <br>    IMediaSeeking* pMS; <br>    HRESULT hr = GetPeerSeeking(&amp;pMS); <br>    if (SUCCEEDED(hr)) <br>    { <br>hr = (pMS-&gt;*pMethod)(pll); <br>pMS-&gt;Release(); <br>    } <br>    return hr; <br>} <br> <br>// If we don't have a current position then ask upstream <br> <br>STDMETHODIMP <br>CPosPassThru::GetCurrentPosition(LONGLONG *pCurrent) <br>{ <br>    // Can we report the current position <br>    HRESULT hr = GetMediaTime(pCurrent,NULL); <br>    if (SUCCEEDED(hr)) hr = NOERROR; <br>    else hr = GetSeekingLongLong( &amp;IMediaSeeking::GetCurrentPosition, pCurrent ); <br>    return hr; <br>} <br> <br> <br>STDMETHODIMP <br>CPosPassThru::GetStopPosition(LONGLONG *pStop) <br>{ <br>    return GetSeekingLongLong( &amp;IMediaSeeking::GetStopPosition, pStop );; <br>} <br> <br>STDMETHODIMP <br>CPosPassThru::GetDuration(LONGLONG *pDuration) <br>{ <br>    return GetSeekingLongLong( &amp;IMediaSeeking::GetDuration, pDuration );; <br>} <br> <br> <br>STDMETHODIMP <br>CPosPassThru::GetPreroll(LONGLONG *pllPreroll) <br>{ <br>    return GetSeekingLongLong( &amp;IMediaSeeking::GetPreroll, pllPreroll );; <br>} <br> <br> <br>STDMETHODIMP <br>CPosPassThru::GetAvailable( LONGLONG *pEarliest, LONGLONG *pLatest ) <br>{ <br>    IMediaSeeking* pMS; <br>    HRESULT hr = GetPeerSeeking(&amp;pMS); <br>    if (FAILED(hr)) { <br>return hr; <br>    } <br> <br>    hr = pMS-&gt;GetAvailable( pEarliest, pLatest ); <br>    pMS-&gt;Release(); <br>    return hr; <br>} <br> <br> <br>STDMETHODIMP <br>CPosPassThru::GetRate(double * pdRate) <br>{ <br>    IMediaSeeking* pMS; <br>    HRESULT hr = GetPeerSeeking(&amp;pMS); <br>    if (FAILED(hr)) { <br>return hr; <br>    } <br>    hr = pMS-&gt;GetRate(pdRate); <br>    pMS-&gt;Release(); <br>    return hr; <br>} <br> <br> <br>STDMETHODIMP <br>CPosPassThru::SetRate(double dRate) <br>{ <br>    if (0.0 == dRate) { <br>return E_INVALIDARG; <br>    } <br> <br>    IMediaSeeking* pMS; <br>    HRESULT hr = GetPeerSeeking(&amp;pMS); <br>    if (FAILED(hr)) { <br>return hr; <br>    } <br>    hr = pMS-&gt;SetRate(dRate); <br>    pMS-&gt;Release(); <br>    return hr; <br>} <br> <br> <br> <br> <br>// --- IMediaPosition methods ---------- <br> <br> <br>STDMETHODIMP <br>CPosPassThru::get_Duration(REFTIME * plength) <br>{ <br>    IMediaPosition* pMP; <br>    HRESULT hr = GetPeer(&amp;pMP); <br>    if (FAILED(hr)) { <br>return hr; <br>    } <br> <br>    hr = pMP-&gt;get_Duration(plength); <br>    pMP-&gt;Release(); <br>    return hr; <br>} <br> <br> <br>STDMETHODIMP <br>CPosPassThru::get_CurrentPosition(REFTIME * pllTime) <br>{ <br>    IMediaPosition* pMP; <br>    HRESULT hr = GetPeer(&amp;pMP); <br>    if (FAILED(hr)) { <br>return hr; <br>    } <br>    hr = pMP-&gt;get_CurrentPosition(pllTime); <br>    pMP-&gt;Release(); <br>    return hr; <br>} <br> <br> <br>STDMETHODIMP <br>CPosPassThru::put_CurrentPosition(REFTIME llTime) <br>{ <br>    IMediaPosition* pMP; <br>    HRESULT hr = GetPeer(&amp;pMP); <br>    if (FAILED(hr)) { <br>return hr; <br>    } <br>    hr = pMP-&gt;put_CurrentPosition(llTime); <br>    pMP-&gt;Release(); <br>    return hr; <br>} <br> <br> <br>STDMETHODIMP <br>CPosPassThru::get_StopTime(REFTIME * pllTime) <br>{ <br>    IMediaPosition* pMP; <br>    HRESULT hr = GetPeer(&amp;pMP); <br>    if (FAILED(hr)) { <br>return hr; <br>    } <br>    hr = pMP-&gt;get_StopTime(pllTime); <br>    pMP-&gt;Release(); <br>    return hr; <br>} <br> <br> <br>STDMETHODIMP <br>CPosPassThru::put_StopTime(REFTIME llTime) <br>{ <br>    IMediaPosition* pMP; <br>    HRESULT hr = GetPeer(&amp;pMP); <br>    if (FAILED(hr)) { <br>return hr; <br>    } <br>    hr = pMP-&gt;put_StopTime(llTime); <br>    pMP-&gt;Release(); <br>    return hr; <br>} <br> <br> <br>STDMETHODIMP <br>CPosPassThru::get_PrerollTime(REFTIME * pllTime) <br>{ <br>    IMediaPosition* pMP; <br>    HRESULT hr = GetPeer(&amp;pMP); <br>    if (FAILED(hr)) { <br>return hr; <br>    } <br>    hr = pMP-&gt;get_PrerollTime(pllTime); <br>    pMP-&gt;Release(); <br>    return hr; <br>} <br> <br> <br>STDMETHODIMP <br>CPosPassThru::put_PrerollTime(REFTIME llTime) <br>{ <br>    IMediaPosition* pMP; <br>    HRESULT hr = GetPeer(&amp;pMP); <br>    if (FAILED(hr)) { <br>return hr; <br>    } <br>    hr = pMP-&gt;put_PrerollTime(llTime); <br>    pMP-&gt;Release(); <br>    return hr; <br>} <br> <br> <br>STDMETHODIMP <br>CPosPassThru::get_Rate(double * pdRate) <br>{ <br>    IMediaPosition* pMP; <br>    HRESULT hr = GetPeer(&amp;pMP); <br>    if (FAILED(hr)) { <br>return hr; <br>    } <br>    hr = pMP-&gt;get_Rate(pdRate); <br>    pMP-&gt;Release(); <br>    return hr; <br>} <br> <br> <br>STDMETHODIMP <br>CPosPassThru::put_Rate(double dRate) <br>{ <br>    if (0.0 == dRate) { <br>return E_INVALIDARG; <br>    } <br> <br>    IMediaPosition* pMP; <br>    HRESULT hr = GetPeer(&amp;pMP); <br>    if (FAILED(hr)) { <br>return hr; <br>    } <br>    hr = pMP-&gt;put_Rate(dRate); <br>    pMP-&gt;Release(); <br>    return hr; <br>} <br> <br> <br>STDMETHODIMP <br>CPosPassThru::CanSeekForward(LONG *pCanSeekForward) <br>{ <br>    IMediaPosition* pMP; <br>    HRESULT hr = GetPeer(&amp;pMP); <br>    if (FAILED(hr)) { <br>return hr; <br>    } <br>    hr = pMP-&gt;CanSeekForward(pCanSeekForward); <br>    pMP-&gt;Release(); <br>    return hr; <br>} <br> <br> <br>STDMETHODIMP <br>CPosPassThru::CanSeekBackward(LONG *pCanSeekBackward) <br>{ <br>    IMediaPosition* pMP; <br>    HRESULT hr = GetPeer(&amp;pMP); <br>    if (FAILED(hr)) { <br>return hr; <br>    } <br>    hr = pMP-&gt;CanSeekBackward(pCanSeekBackward); <br>    pMP-&gt;Release(); <br>    return hr; <br>} <br> <br> <br>// --- Implements the CRendererPosPassThru class ---------- <br> <br> <br>// Media times (eg current frame, field, sample etc) are passed through the <br>// filtergraph in media samples. When a renderer gets a sample with media <br>// times in it, it will call one of the RegisterMediaTime methods we expose <br>// (one takes an IMediaSample, the other takes the media times direct). We <br>// store the media times internally and return them in GetCurrentPosition. <br> <br>CRendererPosPassThru::CRendererPosPassThru(const TCHAR *pName, <br>   LPUNKNOWN pUnk, <br>   HRESULT *phr, <br>   IPin *pPin) : <br>    CPosPassThru(pName,pUnk,phr,pPin), <br>    m_StartMedia(0), <br>    m_EndMedia(0), <br>    m_bReset(TRUE) <br>{ <br>} <br> <br> <br>// Sets the media times the object should report <br> <br>HRESULT <br>CRendererPosPassThru::RegisterMediaTime(IMediaSample *pMediaSample) <br>{ <br>    ASSERT(pMediaSample); <br>    LONGLONG StartMedia; <br>    LONGLONG EndMedia; <br> <br>    CAutoLock cAutoLock(&amp;m_PositionLock); <br> <br>    // Get the media times from the sample <br> <br>    HRESULT hr = pMediaSample-&gt;GetTime(&amp;StartMedia,&amp;EndMedia); <br>    if (FAILED(hr)) <br>    { <br>ASSERT(hr == VFW_E_SAMPLE_TIME_NOT_SET); <br>return hr; <br>    } <br> <br>    m_StartMedia = StartMedia; <br>    m_EndMedia = EndMedia; <br>    m_bReset = FALSE; <br>    return NOERROR; <br>} <br> <br> <br>// Sets the media times the object should report <br> <br>HRESULT <br>CRendererPosPassThru::RegisterMediaTime(LONGLONG StartTime,LONGLONG EndTime) <br>{ <br>    CAutoLock cAutoLock(&amp;m_PositionLock); <br>    m_StartMedia = StartTime; <br>    m_EndMedia = EndTime; <br>    m_bReset = FALSE; <br>    return NOERROR; <br>} <br> <br> <br>// Return the current media times registered in the object <br> <br>HRESULT <br>CRendererPosPassThru::GetMediaTime(LONGLONG *pStartTime,LONGLONG *pEndTime) <br>{ <br>    ASSERT(pStartTime); <br> <br>    CAutoLock cAutoLock(&amp;m_PositionLock); <br>    if (m_bReset == TRUE) { <br>return E_FAIL; <br>    } <br> <br>    // We don't have to return the end time <br> <br>    HRESULT hr = ConvertTimeFormat( pStartTime, 0, m_StartMedia, &amp;TIME_FORMAT_MEDIA_TIME ); <br>    if (pEndTime &amp;&amp; SUCCEEDED(hr)) { <br>hr = ConvertTimeFormat( pEndTime, 0, m_EndMedia, &amp;TIME_FORMAT_MEDIA_TIME ); <br>    } <br>    return hr; <br>} <br> <br> <br>// Resets the media times we hold <br> <br>HRESULT <br>CRendererPosPassThru::ResetMediaTime() <br>{ <br>    CAutoLock cAutoLock(&amp;m_PositionLock); <br>    m_StartMedia = 0; <br>    m_EndMedia = 0; <br>    m_bReset = TRUE; <br>    return NOERROR; <br>} <br> <br>// Intended to be called by the owing filter during EOS processing so <br>// that the media times can be adjusted to the stop time.  This ensures <br>// that the GetCurrentPosition will actully get to the stop position. <br>HRESULT <br>CRendererPosPassThru::EOS() <br>{ <br>    HRESULT hr; <br> <br>    if ( m_bReset == TRUE ) hr = E_FAIL; <br>    else <br>    { <br>LONGLONG llStop; <br>if SUCCEEDED(hr=GetStopPosition(&amp;llStop)) <br>{ <br>    CAutoLock cAutoLock(&amp;m_PositionLock); <br>    m_StartMedia = <br>    m_EndMedia = llStop; <br>} <br>    } <br>    return hr; <br>} <br> <br>// -- CSourceSeeking implementation ------------ <br> <br>CSourceSeeking::CSourceSeeking( <br>    const TCHAR * pName, <br>    LPUNKNOWN pUnk, <br>    HRESULT* phr, <br>    CCritSec * pLock) : <br>        CUnknown(pName, pUnk), <br>        m_pLock(pLock), <br>        m_rtStart((long)0) <br>{ <br>    m_rtStop = _I64_MAX / 2; <br>    m_rtDuration = m_rtStop; <br>    m_dRateSeeking = 1.0; <br> <br>    m_dwSeekingCaps = AM_SEEKING_CanSeekForwards <br>        | AM_SEEKING_CanSeekBackwards <br>        | AM_SEEKING_CanSeekAbsolute <br>        | AM_SEEKING_CanGetStopPos <br>        | AM_SEEKING_CanGetDuration; <br>} <br> <br>HRESULT CSourceSeeking::NonDelegatingQueryInterface(REFIID riid, void **ppv) <br>{ <br>    if(riid == IID_IMediaSeeking) { <br>        CheckPointer(ppv, E_POINTER); <br>        return GetInterface(static_cast&lt;IMediaSeeking *&gt;(this), ppv); <br>    } <br>    else { <br>        return CUnknown::NonDelegatingQueryInterface(riid, ppv); <br>    } <br>} <br>     <br> <br>HRESULT CSourceSeeking::IsFormatSupported(const GUID * pFormat) <br>{ <br>    CheckPointer(pFormat, E_POINTER); <br>    // only seeking in time (REFERENCE_TIME units) is supported <br>    return *pFormat == TIME_FORMAT_MEDIA_TIME ? S_OK : S_FALSE; <br>} <br> <br>HRESULT CSourceSeeking::QueryPreferredFormat(GUID *pFormat) <br>{ <br>    CheckPointer(pFormat, E_POINTER); <br>    *pFormat = TIME_FORMAT_MEDIA_TIME; <br>    return S_OK; <br>} <br> <br>HRESULT CSourceSeeking::SetTimeFormat(const GUID * pFormat) <br>{ <br>    CheckPointer(pFormat, E_POINTER); <br> <br>    // nothing to set; just check that it's TIME_FORMAT_TIME <br>    return *pFormat == TIME_FORMAT_MEDIA_TIME ? S_OK : E_INVALIDARG; <br>} <br> <br>HRESULT CSourceSeeking::IsUsingTimeFormat(const GUID * pFormat) <br>{ <br>    CheckPointer(pFormat, E_POINTER); <br>    return *pFormat == TIME_FORMAT_MEDIA_TIME ? S_OK : S_FALSE; <br>} <br> <br>HRESULT CSourceSeeking::GetTimeFormat(GUID *pFormat) <br>{ <br>    CheckPointer(pFormat, E_POINTER); <br>    *pFormat = TIME_FORMAT_MEDIA_TIME; <br>    return S_OK; <br>} <br> <br>HRESULT CSourceSeeking::GetDuration(LONGLONG *pDuration) <br>{ <br>    CheckPointer(pDuration, E_POINTER); <br>    CAutoLock lock(m_pLock); <br>    *pDuration = m_rtDuration; <br>    return S_OK; <br>} <br> <br>HRESULT CSourceSeeking::GetStopPosition(LONGLONG *pStop) <br>{ <br>    CheckPointer(pStop, E_POINTER); <br>    CAutoLock lock(m_pLock); <br>    *pStop = m_rtStop; <br>    return S_OK; <br>} <br> <br>HRESULT CSourceSeeking::GetCurrentPosition(LONGLONG *pCurrent) <br>{ <br>    // GetCurrentPosition is typically supported only in renderers and <br>    // not in source filters. <br>    return E_NOTIMPL; <br>} <br> <br>HRESULT CSourceSeeking::GetCapabilities( DWORD * pCapabilities ) <br>{ <br>    CheckPointer(pCapabilities, E_POINTER); <br>    *pCapabilities = m_dwSeekingCaps; <br>    return S_OK; <br>} <br> <br>HRESULT CSourceSeeking::CheckCapabilities( DWORD * pCapabilities ) <br>{ <br>    CheckPointer(pCapabilities, E_POINTER); <br> <br>    // make sure all requested capabilities are in our mask <br>    return (~m_dwSeekingCaps &amp; *pCapabilities) ? S_FALSE : S_OK; <br>} <br> <br>HRESULT CSourceSeeking::ConvertTimeFormat( LONGLONG * pTarget, const GUID * pTargetFormat, <br>                           LONGLONG    Source, const GUID * pSourceFormat ) <br>{ <br>    CheckPointer(pTarget, E_POINTER); <br>    // format guids can be null to indicate current format <br> <br>    // since we only support TIME_FORMAT_MEDIA_TIME, we don't really <br>    // offer any conversions. <br>    if(pTargetFormat == 0 || *pTargetFormat == TIME_FORMAT_MEDIA_TIME) <br>    { <br>        if(pSourceFormat == 0 || *pSourceFormat == TIME_FORMAT_MEDIA_TIME) <br>        { <br>            *pTarget = Source; <br>            return S_OK; <br>        } <br>    } <br>     <br>    return E_INVALIDARG; <br>} <br> <br> <br>HRESULT CSourceSeeking::SetPositions( LONGLONG * pCurrent,  DWORD CurrentFlags <br>                      , LONGLONG * pStop,  DWORD StopFlags ) <br>{ <br>    DWORD StopPosBits = StopFlags &amp; AM_SEEKING_PositioningBitsMask; <br>    DWORD StartPosBits = CurrentFlags &amp; AM_SEEKING_PositioningBitsMask; <br> <br>    if(StopFlags) { <br>        CheckPointer(pStop, E_POINTER); <br> <br>        // accept only relative, incremental, or absolute positioning <br>        if(StopPosBits != StopFlags) { <br>            return E_INVALIDARG; <br>        } <br>    } <br> <br>    if(CurrentFlags) { <br>        CheckPointer(pCurrent, E_POINTER); <br>        if(StartPosBits != AM_SEEKING_AbsolutePositioning &amp;&amp; <br>           StartPosBits != AM_SEEKING_RelativePositioning) { <br>            return E_INVALIDARG; <br>        } <br>    } <br> <br> <br>    // scope for autolock <br>    { <br>        CAutoLock lock(m_pLock); <br> <br>        // set start position <br>        if(StartPosBits == AM_SEEKING_AbsolutePositioning) <br>        { <br>            m_rtStart = *pCurrent; <br>        } <br>        else if(StartPosBits == AM_SEEKING_RelativePositioning) <br>        { <br>            m_rtStart += *pCurrent; <br>        } <br> <br>        // set stop position <br>        if(StopPosBits == AM_SEEKING_AbsolutePositioning) <br>        { <br>            m_rtStop = *pStop; <br>        } <br>        else if(StopPosBits == AM_SEEKING_IncrementalPositioning) <br>        { <br>            m_rtStop = m_rtStart + *pStop; <br>        } <br>        else if(StopPosBits == AM_SEEKING_RelativePositioning) <br>        { <br>            m_rtStop = m_rtStop + *pStop; <br>        } <br>    } <br> <br> <br>    HRESULT hr = S_OK; <br>    if(SUCCEEDED(hr) &amp;&amp; StopPosBits) { <br>        hr = ChangeStop(); <br>    } <br>    if(StartPosBits) { <br>        hr = ChangeStart(); <br>    } <br> <br>    return hr; <br>} <br> <br> <br>HRESULT CSourceSeeking::GetPositions( LONGLONG * pCurrent, LONGLONG * pStop ) <br>{ <br>    if(pCurrent) { <br>        *pCurrent = m_rtStart; <br>    } <br>    if(pStop) { <br>        *pStop = m_rtStop; <br>    } <br>     <br>    return S_OK;; <br>} <br> <br> <br>HRESULT CSourceSeeking::GetAvailable( LONGLONG * pEarliest, LONGLONG * pLatest ) <br>{ <br>    if(pEarliest) { <br>        *pEarliest = 0; <br>    } <br>    if(pLatest) { <br>        CAutoLock lock(m_pLock); <br>        *pLatest = m_rtDuration; <br>    } <br>    return S_OK; <br>} </code></pre>
<p>
</p>
<pre><code><br>HRESULT CSourceSeeking::SetRate( double dRate) <br>{ <br>    { <br>        CAutoLock lock(m_pLock); <br>        m_dRateSeeking = dRate; <br>    } <br>    return ChangeRate(); <br>} <br> <br>HRESULT CSourceSeeking::GetRate( double * pdRate) <br>{ <br>    CheckPointer(pdRate, E_POINTER); <br>    CAutoLock lock(m_pLock); <br>    *pdRate = m_dRateSeeking; <br>    return S_OK; <br>} <br> <br>HRESULT CSourceSeeking::GetPreroll(LONGLONG *pPreroll)  <br>{ <br>    CheckPointer(pPreroll, E_POINTER); <br>    *pPreroll = 0; <br>    return S_OK; <br>} <br> <br> <br> <br> <br> <br>// --- CSourcePosition implementation ---------- <br> <br> <br>CSourcePosition::CSourcePosition(const TCHAR * pName, <br> LPUNKNOWN pUnk, <br> HRESULT* phr, <br> CCritSec * pLock) : <br>    CMediaPosition(pName, pUnk), <br>    m_pLock(pLock), <br>    m_Start(CRefTime((LONGLONG)0)) <br>{ <br>    m_Stop = _I64_MAX; <br>    m_Rate = 1.0; <br>} <br> <br> <br>STDMETHODIMP <br>CSourcePosition::get_Duration(REFTIME * plength) <br>{ <br>    CheckPointer(plength,E_POINTER); <br>    ValidateReadWritePtr(plength,sizeof(REFTIME)); <br>    CAutoLock lock(m_pLock); <br> <br>    *plength = m_Duration; <br>    return S_OK; <br>} <br> <br> <br>STDMETHODIMP <br>CSourcePosition::put_CurrentPosition(REFTIME llTime) <br>{ <br>    m_pLock-&gt;Lock(); <br>    m_Start = llTime; <br>    m_pLock-&gt;Unlock(); <br> <br>    return ChangeStart(); <br>} <br> <br> <br>STDMETHODIMP <br>CSourcePosition::get_StopTime(REFTIME * pllTime) <br>{ <br>    CheckPointer(pllTime,E_POINTER); <br>    ValidateReadWritePtr(pllTime,sizeof(REFTIME)); <br>    CAutoLock lock(m_pLock); <br> <br>    *pllTime = m_Stop; <br>    return S_OK; <br>} <br> <br> <br>STDMETHODIMP <br>CSourcePosition::put_StopTime(REFTIME llTime) <br>{ <br>    m_pLock-&gt;Lock(); <br>    m_Stop = llTime; <br>    m_pLock-&gt;Unlock(); <br> <br>    return ChangeStop(); <br>} <br> <br> <br>STDMETHODIMP <br>CSourcePosition::get_PrerollTime(REFTIME * pllTime) <br>{ <br>    CheckPointer(pllTime,E_POINTER); <br>    ValidateReadWritePtr(pllTime,sizeof(REFTIME)); <br>    return E_NOTIMPL; <br>} <br> <br> <br>STDMETHODIMP <br>CSourcePosition::put_PrerollTime(REFTIME llTime) <br>{ <br>    return E_NOTIMPL; <br>} <br> <br> <br>STDMETHODIMP <br>CSourcePosition::get_Rate(double * pdRate) <br>{ <br>    CheckPointer(pdRate,E_POINTER); <br>    ValidateReadWritePtr(pdRate,sizeof(double)); <br>    CAutoLock lock(m_pLock); <br> <br>    *pdRate = m_Rate; <br>    return S_OK; <br>} <br> <br> <br>STDMETHODIMP <br>CSourcePosition::put_Rate(double dRate) <br>{ <br>    m_pLock-&gt;Lock(); <br>    m_Rate = dRate; <br>    m_pLock-&gt;Unlock(); <br> <br>    return ChangeRate(); <br>} <br> <br> <br>// By default we can seek forwards <br> <br>STDMETHODIMP <br>CSourcePosition::CanSeekForward(LONG *pCanSeekForward) <br>{ <br>    CheckPointer(pCanSeekForward,E_POINTER); <br>    *pCanSeekForward = OATRUE; <br>    return S_OK; <br>} <br> <br> <br>// By default we can seek backwards <br> <br>STDMETHODIMP <br>CSourcePosition::CanSeekBackward(LONG *pCanSeekBackward) <br>{ <br>    CheckPointer(pCanSeekBackward,E_POINTER); <br>    *pCanSeekBackward = OATRUE; <br>    return S_OK; <br>} <br> <br> <br>// --- Implementation of CBasicAudio class ---------- <br> <br> <br>CBasicAudio::CBasicAudio(const TCHAR * pName,LPUNKNOWN punk) : <br>    CUnknown(pName, punk) <br>{ <br>} <br> <br>// overriden to publicise our interfaces <br> <br>STDMETHODIMP <br>CBasicAudio::NonDelegatingQueryInterface(REFIID riid, void **ppv) <br>{ <br>    ValidateReadWritePtr(ppv,sizeof(PVOID)); <br>    if (riid == IID_IBasicAudio) { <br>return GetInterface( (IBasicAudio *) this, ppv); <br>    } else { <br>return CUnknown::NonDelegatingQueryInterface(riid, ppv); <br>    } <br>} <br> <br> <br>STDMETHODIMP <br>CBasicAudio::GetTypeInfoCount(UINT * pctinfo) <br>{ <br>    return m_basedisp.GetTypeInfoCount(pctinfo); <br>} <br> <br> <br>STDMETHODIMP <br>CBasicAudio::GetTypeInfo( <br>  UINT itinfo, <br>  LCID lcid, <br>  ITypeInfo ** pptinfo) <br>{ <br>    return m_basedisp.GetTypeInfo( <br>IID_IBasicAudio, <br>itinfo, <br>lcid, <br>pptinfo); <br>} <br> <br> <br>STDMETHODIMP <br>CBasicAudio::GetIDsOfNames( <br>  REFIID riid, <br>  OLECHAR  ** rgszNames, <br>  UINT cNames, <br>  LCID lcid, <br>  DISPID * rgdispid) <br>{ <br>    return m_basedisp.GetIDsOfNames( <br>IID_IBasicAudio, <br>rgszNames, <br>cNames, <br>lcid, <br>rgdispid); <br>} <br> <br> <br>STDMETHODIMP <br>CBasicAudio::Invoke( <br>  DISPID dispidMember, <br>  REFIID riid, <br>  LCID lcid, <br>  WORD wFlags, <br>  DISPPARAMS * pdispparams, <br>  VARIANT * pvarResult, <br>  EXCEPINFO * pexcepinfo, <br>  UINT * puArgErr) <br>{ <br>    // this parameter is a dead leftover from an earlier interface <br>    if (IID_NULL != riid) { <br>return DISP_E_UNKNOWNINTERFACE; <br>    } <br> <br>    ITypeInfo * pti; <br>    HRESULT hr = GetTypeInfo(0, lcid, &amp;pti); <br> <br>    if (FAILED(hr)) { <br>return hr; <br>    } <br> <br>    hr = pti-&gt;Invoke( <br>    (IBasicAudio *)this, <br>    dispidMember, <br>    wFlags, <br>    pdispparams, <br>    pvarResult, <br>    pexcepinfo, <br>    puArgErr); <br> <br>    pti-&gt;Release(); <br>    return hr; <br>} <br> <br> <br>// --- IVideoWindow implementation ---------- <br> <br>CBaseVideoWindow::CBaseVideoWindow(const TCHAR * pName,LPUNKNOWN punk) : <br>    CUnknown(pName, punk) <br>{ <br>} <br> <br> <br>// overriden to publicise our interfaces <br> <br>STDMETHODIMP <br>CBaseVideoWindow::NonDelegatingQueryInterface(REFIID riid, void **ppv) <br>{ <br>    ValidateReadWritePtr(ppv,sizeof(PVOID)); <br>    if (riid == IID_IVideoWindow) { <br>return GetInterface( (IVideoWindow *) this, ppv); <br>    } else { <br>return CUnknown::NonDelegatingQueryInterface(riid, ppv); <br>    } <br>} <br> <br> <br>STDMETHODIMP <br>CBaseVideoWindow::GetTypeInfoCount(UINT * pctinfo) <br>{ <br>    return m_basedisp.GetTypeInfoCount(pctinfo); <br>} <br> <br> <br>STDMETHODIMP <br>CBaseVideoWindow::GetTypeInfo( <br>  UINT itinfo, <br>  LCID lcid, <br>  ITypeInfo ** pptinfo) <br>{ <br>    return m_basedisp.GetTypeInfo( <br>IID_IVideoWindow, <br>itinfo, <br>lcid, <br>pptinfo); <br>} <br> <br> <br>STDMETHODIMP <br>CBaseVideoWindow::GetIDsOfNames( <br>  REFIID riid, <br>  OLECHAR  ** rgszNames, <br>  UINT cNames, <br>  LCID lcid, <br>  DISPID * rgdispid) <br>{ <br>    return m_basedisp.GetIDsOfNames( <br>IID_IVideoWindow, <br>rgszNames, <br>cNames, <br>lcid, <br>rgdispid); <br>} <br> <br> <br>STDMETHODIMP <br>CBaseVideoWindow::Invoke( <br>  DISPID dispidMember, <br>  REFIID riid, <br>  LCID lcid, <br>  WORD wFlags, <br>  DISPPARAMS * pdispparams, <br>  VARIANT * pvarResult, <br>  EXCEPINFO * pexcepinfo, <br>  UINT * puArgErr) <br>{ <br>    // this parameter is a dead leftover from an earlier interface <br>    if (IID_NULL != riid) { <br>return DISP_E_UNKNOWNINTERFACE; <br>    } <br> <br>    ITypeInfo * pti; <br>    HRESULT hr = GetTypeInfo(0, lcid, &amp;pti); <br> <br>    if (FAILED(hr)) { <br>return hr; <br>    } <br> <br>    hr = pti-&gt;Invoke( <br>    (IVideoWindow *)this, <br>    dispidMember, <br>    wFlags, <br>    pdispparams, <br>    pvarResult, <br>    pexcepinfo, <br>    puArgErr); <br> <br>    pti-&gt;Release(); <br>    return hr; <br>} <br> <br> <br>// --- IBasicVideo implementation ---------- <br> <br> <br>CBaseBasicVideo::CBaseBasicVideo(const TCHAR * pName,LPUNKNOWN punk) : <br>    CUnknown(pName, punk) <br>{ <br>} <br> <br> <br>// overriden to publicise our interfaces <br> <br>STDMETHODIMP <br>CBaseBasicVideo::NonDelegatingQueryInterface(REFIID riid, void **ppv) <br>{ <br>    ValidateReadWritePtr(ppv,sizeof(PVOID)); <br>    if (riid == IID_IBasicVideo) { <br>return GetInterface( (IBasicVideo *) this, ppv); <br>    } else { <br>return CUnknown::NonDelegatingQueryInterface(riid, ppv); <br>    } <br>} <br> <br> <br>STDMETHODIMP <br>CBaseBasicVideo::GetTypeInfoCount(UINT * pctinfo) <br>{ <br>    return m_basedisp.GetTypeInfoCount(pctinfo); <br>} <br> <br> <br>STDMETHODIMP <br>CBaseBasicVideo::GetTypeInfo( <br>  UINT itinfo, <br>  LCID lcid, <br>  ITypeInfo ** pptinfo) <br>{ <br>    return m_basedisp.GetTypeInfo( <br>IID_IBasicVideo, <br>itinfo, <br>lcid, <br>pptinfo); <br>} <br> <br> <br>STDMETHODIMP <br>CBaseBasicVideo::GetIDsOfNames( <br>  REFIID riid, <br>  OLECHAR  ** rgszNames, <br>  UINT cNames, <br>  LCID lcid, <br>  DISPID * rgdispid) <br>{ <br>    return m_basedisp.GetIDsOfNames( <br>IID_IBasicVideo, <br>rgszNames, <br>cNames, <br>lcid, <br>rgdispid); <br>} <br> <br> <br>STDMETHODIMP <br>CBaseBasicVideo::Invoke( <br>  DISPID dispidMember, <br>  REFIID riid, <br>  LCID lcid, <br>  WORD wFlags, <br>  DISPPARAMS * pdispparams, <br>  VARIANT * pvarResult, <br>  EXCEPINFO * pexcepinfo, <br>  UINT * puArgErr) <br>{ <br>    // this parameter is a dead leftover from an earlier interface <br>    if (IID_NULL != riid) { <br>return DISP_E_UNKNOWNINTERFACE; <br>    } <br> <br>    ITypeInfo * pti; <br>    HRESULT hr = GetTypeInfo(0, lcid, &amp;pti); <br> <br>    if (FAILED(hr)) { <br>return hr; <br>    } <br> <br>    hr = pti-&gt;Invoke( <br>    (IBasicVideo *)this, <br>    dispidMember, <br>    wFlags, <br>    pdispparams, <br>    pvarResult, <br>    pexcepinfo, <br>    puArgErr); <br> <br>    pti-&gt;Release(); <br>    return hr; <br>} <br> <br> <br>// --- Implementation of Deferred Commands ---------- <br> <br> <br>CDispParams::CDispParams(UINT nArgs, VARIANT* pArgs) <br>{ <br>   cNamedArgs = 0; <br>   rgdispidNamedArgs = NULL; <br>   cArgs = nArgs; <br> <br>    if (cArgs) { <br>rgvarg = new VARIANT[cArgs]; <br> <br>for (UINT i = 0; i &lt; cArgs; i++) { <br> <br>    VARIANT * pDest = &amp;rgvarg[i]; <br>    VARIANT * pSrc = &amp;pArgs[i]; <br> <br>    pDest-&gt;vt = pSrc-&gt;vt; <br>    switch(pDest-&gt;vt) { <br> <br>    case VT_I4: <br>pDest-&gt;lVal = pSrc-&gt;lVal; <br>break; <br> <br>    case VT_UI1: <br>pDest-&gt;bVal = pSrc-&gt;bVal; <br>break; <br> <br>    case VT_I2: <br>pDest-&gt;iVal = pSrc-&gt;iVal; <br>break; <br> <br>    case VT_R4: <br>pDest-&gt;fltVal = pSrc-&gt;fltVal; <br>break; <br> <br>    case VT_R8: <br>pDest-&gt;dblVal = pSrc-&gt;dblVal; <br>break; <br> <br>    case VT_BOOL: <br>pDest-&gt;boolVal = pSrc-&gt;boolVal; <br>break; <br> <br>    case VT_ERROR: <br>pDest-&gt;scode = pSrc-&gt;scode; <br>break; <br> <br>    case VT_CY: <br>pDest-&gt;cyVal = pSrc-&gt;cyVal; <br>break; <br> <br>    case VT_DATE: <br>pDest-&gt;date = pSrc-&gt;date; <br>break; <br> <br>    case VT_BSTR: <br>if (pSrc-&gt;bstrVal == NULL) { <br>    pDest-&gt;bstrVal = NULL; <br>} else { <br> <br>    // a BSTR is a WORD followed by a UNICODE string. <br>    // the pointer points just after the WORD <br> <br>    WORD len = * (WORD*) (pSrc-&gt;bstrVal - (sizeof(WORD) / sizeof(OLECHAR))); <br>    OLECHAR* pch = new OLECHAR[len + (sizeof(WORD)/sizeof(OLECHAR))]; <br>    WORD *pui = (WORD*)pch; <br>    *pui = len; <br>    pDest-&gt;bstrVal = pch + (sizeof(WORD)/sizeof(OLECHAR)); <br>    CopyMemory(pDest-&gt;bstrVal, pSrc-&gt;bstrVal, len*sizeof(OLECHAR)); <br>} <br>pDest-&gt;bstrVal = pSrc-&gt;bstrVal; <br>break; <br> <br>    case VT_UNKNOWN: <br>pDest-&gt;punkVal = pSrc-&gt;punkVal; <br>pDest-&gt;punkVal-&gt;AddRef(); <br>break; <br> <br>    case VT_DISPATCH: <br>pDest-&gt;pdispVal = pSrc-&gt;pdispVal; <br>pDest-&gt;pdispVal-&gt;AddRef(); <br>break; <br> <br>    default: <br>// a type we haven't got round to adding yet! <br>ASSERT(0); <br>break; <br>    } <br>} <br> <br>    } else { <br>rgvarg = NULL; <br>    } <br> <br>} <br> <br> <br>CDispParams::~CDispParams() <br>{ <br>    for (UINT i = 0; i &lt; cArgs; i++) { <br>switch(rgvarg[i].vt) { <br>case VT_BSTR: <br>    if (rgvarg[i].bstrVal != NULL) { <br>OLECHAR * pch = rgvarg[i].bstrVal - (sizeof(WORD)/sizeof(OLECHAR)); <br>delete pch; <br>    } <br>    break; <br> <br>case VT_UNKNOWN: <br>    rgvarg[i].punkVal-&gt;Release(); <br>    break; <br> <br>case VT_DISPATCH: <br>    rgvarg[i].pdispVal-&gt;Release(); <br>    break; <br>} <br>    } <br>    delete[] rgvarg; <br>} <br> <br> <br>// lifetime is controlled by refcounts (see defer.h) <br> <br>CDeferredCommand::CDeferredCommand( <br>    CCmdQueue * pQ, <br>    LPUNKNOWNpUnk, <br>    HRESULT *phr, <br>    LPUNKNOWNpUnkExecutor, <br>    REFTIMEtime, <br>    GUID*iid, <br>    longdispidMethod, <br>    shortwFlags, <br>    longnArgs, <br>    VARIANT*pDispParams, <br>    VARIANT*pvarResult, <br>    short*puArgErr, <br>    BOOLbStream <br>    ) : <br>CUnknown(NAME("DeferredCommand"), pUnk), <br>m_pQueue(pQ), <br>m_pUnk(pUnkExecutor), <br>m_iid(iid), <br>m_dispidMethod(dispidMethod), <br>m_wFlags(wFlags), <br>m_DispParams(nArgs, pDispParams), <br>m_pvarResult(pvarResult), <br>m_bStream(bStream), <br>m_hrResult(E_ABORT) <br> <br>{ <br>    // convert REFTIME to REFERENCE_TIME <br>    COARefTime convertor(time); <br>    m_time = convertor; <br> <br>    // no check of time validity - it's ok to queue a command that's <br>    // already late <br> <br>    // check iid is supportable on pUnk by QueryInterface for it <br>    IUnknown * pInterface; <br>    HRESULT hr = m_pUnk-&gt;QueryInterface(GetIID(), (void**) &amp;pInterface); <br>    if (FAILED(hr)) { <br>*phr = hr; <br>return; <br>    } <br>    pInterface-&gt;Release(); <br> <br> <br>    // !!! check dispidMethod and param/return types using typelib <br>    ITypeInfo *pti; <br>    hr = m_Dispatch.GetTypeInfo(*iid, 0, 0, &amp;pti); <br>    if (FAILED(hr)) { <br>*phr = hr; <br>return; <br>    } <br>    // !!! some sort of ITypeInfo validity check here <br>    pti-&gt;Release(); <br> <br> <br>    // Fix up the dispid for put and get <br>    if (wFlags == DISPATCH_PROPERTYPUT) { <br>        m_DispParams.cNamedArgs = 1; <br>        m_DispId = DISPID_PROPERTYPUT; <br>        m_DispParams.rgdispidNamedArgs = &amp;m_DispId; <br>    } <br> <br>    // all checks ok - add to queue <br>    hr = pQ-&gt;Insert(this); <br>    if (FAILED(hr)) { <br>*phr = hr; <br>    } <br>} <br> <br> <br>// refcounts are held by caller of InvokeAt... and by list. So if <br>// we get here, we can't be on the list <br> <br>#if 0 <br>CDeferredCommand::~CDeferredCommand() <br>{ <br>    // this assert is invalid since if the queue is deleted while we are <br>    // still on the queue, we will have been removed by the queue and this <br>    // m_pQueue will not have been modified. <br>    // ASSERT(m_pQueue == NULL); <br> <br>    // we don't hold a ref count on pUnk, which is the object that should <br>    // execute the command. <br>    // This is because there would otherwise be a circular refcount problem <br>    // since pUnk probably owns the CmdQueue object that has a refcount <br>    // on us. <br>    // The lifetime of pUnk is guaranteed by it being part of, or lifetime <br>    // controlled by, our parent object. As long as we are on the list, pUnk <br>    // must be valid. Once we are off the list, we do not use pUnk. <br> <br>} <br>#endif <br> <br> <br>// overriden to publicise our interfaces <br> <br>STDMETHODIMP <br>CDeferredCommand::NonDelegatingQueryInterface(REFIID riid, void **ppv) <br>{ <br>    ValidateReadWritePtr(ppv,sizeof(PVOID)); <br>    if (riid == IID_IDeferredCommand) { <br>return GetInterface( (IDeferredCommand *) this, ppv); <br>    } else { <br>return CUnknown::NonDelegatingQueryInterface(riid, ppv); <br>    } <br>} <br> <br> <br>// remove from q. this will reduce the refcount by one (since the q <br>// holds a count) but can't make us go away since he must have a <br>// refcount in order to call this method. <br> <br>STDMETHODIMP <br>CDeferredCommand::Cancel() <br>{ <br>    if (m_pQueue == NULL) { <br>return VFW_E_ALREADY_CANCELLED; <br>    } <br> <br>    HRESULT hr = m_pQueue-&gt;Remove(this); <br>    if (FAILED(hr)) { <br>return hr; <br>    } <br> <br>    m_pQueue = NULL; <br>    return S_OK; <br>} <br> <br> <br>STDMETHODIMP <br>CDeferredCommand::Confidence(LONG* pConfidence) <br>{ <br>    return E_NOTIMPL; <br>} <br> <br> <br>STDMETHODIMP <br>CDeferredCommand::GetHResult(HRESULT * phrResult) <br>{ <br>    CheckPointer(phrResult,E_POINTER); <br>    ValidateReadWritePtr(phrResult,sizeof(HRESULT)); <br> <br>    if (m_pQueue != NULL) { <br>return E_ABORT; <br>    } <br>    *phrResult = m_hrResult; <br>    return S_OK; <br>} <br> <br> <br>// set the time to be a new time (checking that it is valid) and <br>// then requeue <br> <br>STDMETHODIMP <br>CDeferredCommand::Postpone(REFTIME newtime) <br>{ <br> <br>    // check that this time is not past <br>    // convert REFTIME to REFERENCE_TIME <br>    COARefTime convertor(newtime); <br> <br>    // check that the time has not passed <br>    if (m_pQueue-&gt;CheckTime(convertor, IsStreamTime())) { <br>return VFW_E_TIME_ALREADY_PASSED; <br>    } <br> <br>    // extract from list <br>    HRESULT hr = m_pQueue-&gt;Remove(this); <br>    if (FAILED(hr)) { <br>return hr; <br>    } <br> <br>    // change time <br>    m_time = convertor; <br> <br>    // requeue <br>    hr = m_pQueue-&gt;Insert(this); <br> <br>    return hr; <br>} <br> <br> <br>HRESULT <br>CDeferredCommand::Invoke() <br>{ <br>    // check that we are still outstanding <br>    if (m_pQueue == NULL) { <br>return VFW_E_ALREADY_CANCELLED; <br>    } <br> <br>    // get the type info <br>    ITypeInfo* pti; <br>    HRESULT hr = m_Dispatch.GetTypeInfo(GetIID(), 0, 0, &amp;pti); <br>    if (FAILED(hr)) { <br>return hr; <br>    } <br> <br>    // qi for the expected interface and then invoke it. Note that we have to <br>    // treat the returned interface as IUnknown since we don't know its type. <br>    IUnknown* pInterface; <br> <br>    hr = m_pUnk-&gt;QueryInterface(GetIID(), (void**) &amp;pInterface); <br>    if (FAILED(hr)) { <br>pti-&gt;Release(); <br>return hr; <br>    } <br> <br>    EXCEPINFO expinfo; <br>    UINT uArgErr; <br>    m_hrResult = pti-&gt;Invoke( <br>pInterface, <br>GetMethod(), <br>GetFlags(), <br>GetParams(), <br>GetResult(), <br>&amp;expinfo, <br>&amp;uArgErr); <br> <br>    // release the interface we QI'd for <br>    pInterface-&gt;Release(); <br>    pti-&gt;Release(); <br> <br> <br>    // remove from list whether or not successful <br>    // or we loop indefinitely <br>    hr = m_pQueue-&gt;Remove(this); <br>    m_pQueue = NULL; <br>    return hr; <br>} <br> <br> <br> <br>// --- CCmdQueue methods ---------- <br> <br> <br>CCmdQueue::CCmdQueue() : <br>    m_listPresentation(NAME("Presentation time command list")), <br>    m_listStream(NAME("Stream time command list")), <br>    m_evDue(TRUE),    // manual reset <br>    m_dwAdvise(0), <br>    m_pClock(NULL), <br>    m_bRunning(FALSE) <br>{ <br>} <br> <br> <br>CCmdQueue::~CCmdQueue() <br>{ <br>    // empty all our lists <br> <br>    // we hold a refcount on each, so traverse and Release each <br>    // entry then RemoveAll to empty the list <br>    POSITION pos = m_listPresentation.GetHeadPosition(); <br> <br>    while(pos) { <br>CDeferredCommand* pCmd = m_listPresentation.GetNext(pos); <br>pCmd-&gt;Release(); <br>    } <br>    m_listPresentation.RemoveAll(); <br> <br>    pos = m_listStream.GetHeadPosition(); <br> <br>    while(pos) { <br>CDeferredCommand* pCmd = m_listStream.GetNext(pos); <br>pCmd-&gt;Release(); <br>    } <br>    m_listStream.RemoveAll(); <br> <br>    if (m_pClock) { <br>if (m_dwAdvise) { <br>    m_pClock-&gt;Unadvise(m_dwAdvise); <br>    m_dwAdvise = 0; <br>} <br>m_pClock-&gt;Release(); <br>    } <br>} <br> <br> <br>// returns a new CDeferredCommand object that will be initialised with <br>// the parameters and will be added to the queue during construction. <br>// returns S_OK if successfully created otherwise an error and <br>// no object has been queued. <br> <br>HRESULT <br>CCmdQueue::New( <br>    CDeferredCommand **ppCmd, <br>    LPUNKNOWNpUnk,// this object will execute command <br>    REFTIMEtime, <br>    GUID*iid, <br>    longdispidMethod, <br>    shortwFlags, <br>    longcArgs, <br>    VARIANT*pDispParams, <br>    VARIANT*pvarResult, <br>    short*puArgErr, <br>    BOOLbStream <br>) <br>{ <br>    CAutoLock lock(&amp;m_Lock); <br> <br>    HRESULT hr = S_OK; <br>    *ppCmd = NULL; <br> <br>    CDeferredCommand* pCmd; <br>    pCmd = new CDeferredCommand( <br>    this, <br>    NULL,    // not aggregated <br>    &amp;hr, <br>    pUnk,    // this guy will execute <br>    time, <br>    iid, <br>    dispidMethod, <br>    wFlags, <br>    cArgs, <br>    pDispParams, <br>    pvarResult, <br>    puArgErr, <br>    bStream); <br> <br>    if (pCmd == NULL) { <br>hr = E_OUTOFMEMORY; <br>    } else { <br>*ppCmd = pCmd; <br>    } <br>    return hr; <br>} <br> <br> <br>HRESULT <br>CCmdQueue::Insert(CDeferredCommand* pCmd) <br>{ <br>    CAutoLock lock(&amp;m_Lock); <br> <br>    // addref the item <br>    pCmd-&gt;AddRef(); <br> <br>    CGenericList&lt;CDeferredCommand&gt; * pList; <br>    if (pCmd-&gt;IsStreamTime()) { <br>pList = &amp;m_listStream; <br>    } else { <br>pList = &amp;m_listPresentation; <br>    } <br>    POSITION pos = pList-&gt;GetHeadPosition(); <br> <br>    // seek past all items that are before us <br>    while (pos &amp;&amp; <br>(pList-&gt;Get(pos)-&gt;GetTime() &lt;= pCmd-&gt;GetTime())) { <br> <br>pList-&gt;GetNext(pos); <br>    } <br> <br>    // now at end of list or in front of items that come later <br>    if (!pos) { <br>pList-&gt;AddTail(pCmd); <br>    } else { <br>pList-&gt;AddBefore(pos, pCmd); <br>    } <br> <br>    SetTimeAdvise(); <br>    return S_OK; <br>} <br> <br> <br>HRESULT <br>CCmdQueue::Remove(CDeferredCommand* pCmd) <br>{ <br>    CAutoLock lock(&amp;m_Lock); <br>    HRESULT hr = S_OK; <br> <br>    CGenericList&lt;CDeferredCommand&gt; * pList; <br>    if (pCmd-&gt;IsStreamTime()) { <br>pList = &amp;m_listStream; <br>    } else { <br>pList = &amp;m_listPresentation; <br>    } <br>    POSITION pos = pList-&gt;GetHeadPosition(); <br> <br>    // traverse the list <br>    while (pos &amp;&amp; (pList-&gt;Get(pos) != pCmd)) { <br>pList-&gt;GetNext(pos); <br>    } <br> <br>    // did we drop off the end? <br>    if (!pos) { <br>hr = VFW_E_NOT_FOUND; <br>    } else { <br> <br>// found it - now take off list <br>pList-&gt;Remove(pos); <br> <br>// Insert did an AddRef, so release it <br>pCmd-&gt;Release(); <br> <br>// check that timer request is still for earliest time <br>SetTimeAdvise(); <br>    } <br>    return hr; <br>} <br> <br> <br>// set the clock used for timing <br> <br>HRESULT <br>CCmdQueue::SetSyncSource(IReferenceClock* pClock) <br>{ <br>    CAutoLock lock(&amp;m_Lock); <br> <br>    // addref the new clock first in case they are the same <br>    if (pClock) { <br>pClock-&gt;AddRef(); <br>    } <br> <br>    // kill any advise on the old clock <br>    if (m_pClock) { <br>if (m_dwAdvise) { <br>    m_pClock-&gt;Unadvise(m_dwAdvise); <br>    m_dwAdvise = 0; <br>} <br>m_pClock-&gt;Release(); <br>    } <br>    m_pClock = pClock; <br> <br>    // set up a new advise <br>    SetTimeAdvise(); <br>    return S_OK; <br>} <br> <br> <br>// set up a timer event with the reference clock <br> <br>void <br>CCmdQueue::SetTimeAdvise(void) <br>{ <br>    // make sure we have a clock to use <br>    if (!m_pClock) { <br>return; <br>    } <br> <br>    // reset the event whenever we are requesting a new signal <br>    m_evDue.Reset(); <br> <br>    // time 0 is earliest <br>    CRefTime current; <br> <br>    // find the earliest presentation time <br>    if (m_listPresentation.GetCount() &gt; 0) { <br> <br>POSITION pos = m_listPresentation.GetHeadPosition(); <br>current = m_listPresentation.Get(pos)-&gt;GetTime(); <br>    } <br> <br>    // if we're running, check the stream times too <br>    if (m_bRunning) { <br> <br>CRefTime t; <br> <br>if (m_listStream.GetCount() &gt; 0) { <br> <br>    POSITION pos = m_listStream.GetHeadPosition(); <br>    t = m_listStream.Get(pos)-&gt;GetTime(); <br> <br>    // add on stream time offset to get presentation time <br>    t += m_StreamTimeOffset; <br> <br>    // is this earlier? <br>    if ((current == TimeZero) || (t &lt; current)) { <br>current = t; <br>    } <br>} <br>    } <br> <br>    // need to change? <br>    if ((current &gt; TimeZero) &amp;&amp; (current != m_tCurrentAdvise)) { <br>if (m_dwAdvise) { <br>    m_pClock-&gt;Unadvise(m_dwAdvise); <br>    // reset the event whenever we are requesting a new signal <br>    m_evDue.Reset(); <br>} <br> <br>// ask for time advice - the first two params are either <br>// stream time offset and stream time or <br>// presentation time and 0. we always use the latter <br>HRESULT hr = m_pClock-&gt;AdviseTime( <br>    (REFERENCE_TIME)current, <br>    TimeZero, <br>    (HEVENT) HANDLE(m_evDue), <br>    &amp;m_dwAdvise); <br> <br>ASSERT(SUCCEEDED(hr)); <br>m_tCurrentAdvise = current; <br>    } <br>} <br> <br> <br>// switch to run mode. Streamtime to Presentation time mapping known. <br> <br>HRESULT <br>CCmdQueue::Run(REFERENCE_TIME tStreamTimeOffset) <br>{ <br>    CAutoLock lock(&amp;m_Lock); <br> <br>    m_StreamTimeOffset = tStreamTimeOffset; <br>    m_bRunning = TRUE; <br> <br>    // ensure advise is accurate <br>    SetTimeAdvise(); <br>    return S_OK; <br>} <br> <br> <br>// switch to Stopped or Paused mode. Time mapping not known. <br> <br>HRESULT <br>CCmdQueue::EndRun() <br>{ <br>    CAutoLock lock(&amp;m_Lock); <br> <br>    m_bRunning = FALSE; <br> <br>    // check timer setting - stream times <br>    SetTimeAdvise(); <br>    return S_OK; <br>} <br> <br> <br>// return a pointer to the next due command. Blocks for msTimeout <br>// milliseconds until there is a due command. <br>// Stream-time commands will only become due between Run and Endrun calls. <br>// The command remains queued until invoked or cancelled. <br>// Returns E_ABORT if timeout occurs, otherwise S_OK (or other error). <br>// <br>// returns an AddRef'd object <br> <br>HRESULT <br>CCmdQueue::GetDueCommand(CDeferredCommand ** ppCmd, long msTimeout) <br>{ <br>    // loop until we timeout or find a due command <br>    for (;;) { <br> <br>{ <br>    CAutoLock lock(&amp;m_Lock); <br> <br> <br>    // find the earliest command <br>    CDeferredCommand * pCmd = NULL; <br> <br>    // check the presentation time and the <br>    // stream time list to find the earliest <br> <br>    if (m_listPresentation.GetCount() &gt; 0) { <br>POSITION pos = m_listPresentation.GetHeadPosition(); <br>pCmd = m_listPresentation.Get(pos); <br>    } <br> <br>    if (m_bRunning &amp;&amp; (m_listStream.GetCount() &gt; 0)) { <br>POSITION pos = m_listStream.GetHeadPosition(); <br>CDeferredCommand* pStrm = m_listStream.Get(pos); <br> <br>CRefTime t = pStrm-&gt;GetTime() + m_StreamTimeOffset; <br>if (!pCmd || (t &lt; pCmd-&gt;GetTime())) { <br>    pCmd = pStrm; <br>} <br>    } <br> <br>    //if we have found one, is it due? <br>    if (pCmd) { <br>if (CheckTime(pCmd-&gt;GetTime(), pCmd-&gt;IsStreamTime())) { <br> <br>    // yes it's due - addref it <br>    pCmd-&gt;AddRef(); <br>    *ppCmd = pCmd; <br>    return S_OK; <br>} <br>    } <br>} <br> <br>// block until the advise is signalled <br>if (WaitForSingleObject(m_evDue, msTimeout) != WAIT_OBJECT_0) { <br>    return E_ABORT; <br>} <br>    } <br>} <br> <br> <br>// return a pointer to a command that will be due for a given time. <br>// Pass in a stream time here. The stream time offset will be passed <br>// in via the Run method. <br>// Commands remain queued until invoked or cancelled. <br>// This method will not block. It will report E_ABORT if there are no <br>// commands due yet. <br>// <br>// returns an AddRef'd object <br> <br>HRESULT <br>CCmdQueue::GetCommandDueFor(REFERENCE_TIME rtStream, CDeferredCommand**ppCmd) <br>{ <br>    CAutoLock lock(&amp;m_Lock); <br> <br>    CRefTime tStream(rtStream); <br> <br>    // find the earliest stream and presentation time commands <br>    CDeferredCommand* pStream = NULL; <br>    if (m_listStream.GetCount() &gt; 0) { <br>POSITION pos = m_listStream.GetHeadPosition(); <br>pStream = m_listStream.Get(pos); <br>    } <br>    CDeferredCommand* pPresent = NULL; <br>    if (m_listPresentation.GetCount() &gt; 0) { <br>POSITION pos = m_listPresentation.GetHeadPosition(); <br>pPresent = m_listPresentation.Get(pos); <br>    } <br> <br>    // is there a presentation time that has passed already <br>    if (pPresent &amp;&amp; CheckTime(pPresent-&gt;GetTime(), FALSE)) { <br>pPresent-&gt;AddRef(); <br>*ppCmd = pPresent; <br>return S_OK; <br>    } <br> <br>    // is there a stream time command due before this stream time <br>    if (pStream &amp;&amp; (pStream-&gt;GetTime() &lt;= tStream)) { <br>pPresent-&gt;AddRef(); <br>*ppCmd = pStream; <br>return S_OK; <br>    } <br> <br>    // if we are running, we can map presentation times to <br>    // stream time. In this case, is there a presentation time command <br>    // that will be due before this stream time is presented? <br>    if (m_bRunning &amp;&amp; pPresent) { <br> <br>// this stream time will appear at... <br>tStream += m_StreamTimeOffset; <br> <br>// due before that? <br>if (pPresent-&gt;GetTime() &lt;= tStream) { <br>    *ppCmd = pPresent; <br>    return S_OK; <br>} <br>    } <br> <br>    // no commands due yet <br>    return VFW_E_NOT_FOUND; <br>} <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
