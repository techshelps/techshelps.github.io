<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WXUTIL.H</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2794"></a>WXUTIL.H</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>// <br>// helper classes and functions for building multimedia filters <br>// <br> <br>#ifndef __WXUTIL__ <br>#define __WXUTIL__ <br> <br>// eliminate spurious "statement has no effect" warnings. <br>#pragma warning(disable: 4705) <br> <br>// wrapper for whatever critical section we have <br>class CCritSec { <br> <br>    // make copy constructor and assignment operator inaccessible <br> <br>    CCritSec(const CCritSec &amp;refCritSec); <br>    CCritSec &amp;operator=(const CCritSec &amp;refCritSec); <br> <br>    CRITICAL_SECTION m_CritSec; <br> <br>#ifdef DEBUG <br>public: <br>    DWORD   m_currentOwner; <br>    DWORD   m_lockCount; <br>    BOOL    m_fTrace;        // Trace this one <br>public: <br>    CCritSec(); <br>    ~CCritSec(); <br>    void Lock(); <br>    void Unlock(); <br>#else <br> <br>public: <br>    CCritSec() { <br>InitializeCriticalSection(&amp;m_CritSec); <br>    }; <br> <br>    ~CCritSec() { <br>DeleteCriticalSection(&amp;m_CritSec); <br>    }; <br> <br>    void Lock() { <br>EnterCriticalSection(&amp;m_CritSec); <br>    }; <br> <br>    void Unlock() { <br>LeaveCriticalSection(&amp;m_CritSec); <br>    }; <br>#endif <br>}; <br> <br>// <br>// To make deadlocks easier to track it is useful to insert in the <br>// code an assertion that says whether we own a critical section or <br>// not.  We make the routines that do the checking globals to avoid <br>// having different numbers of member functions in the debug and <br>// retail class implementations of CCritSec.  In addition we provide <br>// a routine that allows usage of specific critical sections to be <br>// traced.  This is NOT on by default - there are far too many. <br>// <br> <br>#ifdef DEBUG <br>    BOOL WINAPI CritCheckIn(CCritSec * pcCrit); <br>    BOOL WINAPI CritCheckOut(CCritSec * pcCrit); <br>    void WINAPI DbgLockTrace(BOOL fTrace); <br>#else <br>    #define CritCheckIn(x) TRUE <br>    #define CritCheckOut(x) TRUE <br>    #define DbgLockTrace(pc, fT) <br>#endif <br> <br> <br>// locks a critical section, and unlocks it automatically <br>// when the lock goes out of scope <br>class CAutoLock { <br> <br>    // make copy constructor and assignment operator inaccessible <br> <br>    CAutoLock(const CAutoLock &amp;refAutoLock); <br>    CAutoLock &amp;operator=(const CAutoLock &amp;refAutoLock); <br> <br>protected: <br>    CCritSec * m_pLock; <br> <br>public: <br>    CAutoLock(CCritSec * plock) <br>    { <br>        m_pLock = plock; <br>        m_pLock-&gt;Lock(); <br>    }; <br> <br>    ~CAutoLock() { <br>        m_pLock-&gt;Unlock(); <br>    }; <br>}; <br> <br> <br> <br>// wrapper for event objects <br>class CAMEvent <br>{ <br> <br>    // make copy constructor and assignment operator inaccessible <br> <br>    CAMEvent(const CAMEvent &amp;refEvent); <br>    CAMEvent &amp;operator=(const CAMEvent &amp;refEvent); <br> <br>protected: <br>    HANDLE m_hEvent; <br>public: <br>    CAMEvent(BOOL fManualReset = FALSE); <br>    ~CAMEvent(); <br> <br>    // Cast to HANDLE - we don't support this as an lvalue <br>    operator HANDLE () const { return m_hEvent; }; <br> <br>    void Set() { SetEvent(m_hEvent); }; <br>    BOOL Wait(DWORD dwTimeout = INFINITE) { <br>return (WaitForSingleObject(m_hEvent, dwTimeout) == WAIT_OBJECT_0); <br>    }; <br>    void Reset() { ResetEvent(m_hEvent); }; <br>    BOOL Check() { return Wait(0); }; <br>}; <br> <br> <br>// wrapper for event objects that do message processing <br>// This adds ONE method to the CAMEvent object to allow sent <br>// messages to be processed while waiting <br> <br>class CAMMsgEvent : public CAMEvent <br>{ <br> <br>public: <br> <br>    // Allow SEND messages to be processed while waiting <br>    BOOL WaitMsg(DWORD dwTimeout = INFINITE); <br>}; <br> <br>// old name supported for the time being <br>#define CTimeoutEvent CAMEvent <br> <br>// support for a worker thread <br> <br>// simple thread class supports creation of worker thread, synchronization <br>// and communication. Can be derived to simplify parameter passing <br>class AM_NOVTABLE CAMThread { <br> <br>    // make copy constructor and assignment operator inaccessible <br> <br>    CAMThread(const CAMThread &amp;refThread); <br>    CAMThread &amp;operator=(const CAMThread &amp;refThread); <br> <br>    CAMEvent m_EventSend; <br>    CAMEvent m_EventComplete; <br> <br>    DWORD m_dwParam; <br>    DWORD m_dwReturnVal; <br> <br>protected: <br>    HANDLE m_hThread; <br> <br>    // thread will run this function on startup <br>    // must be supplied by derived class <br>    virtual DWORD ThreadProc() = 0; <br> <br> <br>public: <br>    CAMThread(); <br>    ~CAMThread(); <br> <br>    CCritSec m_AccessLock;// locks access by client threads <br>    CCritSec m_WorkerLock;// locks access to shared objects <br> <br>    // thread initially runs this. param is actually 'this'. function <br>    // just gets this and calls ThreadProc <br>    static DWORD WINAPI InitialThreadProc(LPVOID pv); <br> <br>    // start thread running  - error if already running <br>    BOOL Create(); <br> <br>    // signal the thread, and block for a response <br>    // <br>    DWORD CallWorker(DWORD); <br> <br>    // accessor thread calls this when done with thread (having told thread <br>    // to exit) <br>    void Close() { <br>        HANDLE hThread = (HANDLE)InterlockedExchange((LONG *)&amp;m_hThread, 0); <br>        if (hThread) { <br>            WaitForSingleObject(hThread, INFINITE); <br>            CloseHandle(hThread); <br>        } <br>    }; <br> <br>    // ThreadExists <br>    // Return TRUE if the thread exists. FALSE otherwise <br>    BOOL ThreadExists(void) const <br>    { <br>        if (m_hThread == 0) { <br>            return FALSE; <br>        } else { <br>            return TRUE; <br>        } <br>    } <br> <br>    // wait for the next request <br>    DWORD GetRequest(); <br> <br>    // is there a request? <br>    BOOL CheckRequest(DWORD * pParam); <br> <br>    // reply to the request <br>    void Reply(DWORD); <br> <br>    // If you want to do WaitForMultipleObjects you'll need to include <br>    // this handle in your wait list or you won't be responsive <br>    HANDLE GetRequestHandle() const { return m_EventSend; }; <br> <br>    // Find out what the request was <br>    DWORD GetRequestParam() const { return m_dwParam; }; <br>}; <br> <br> <br>// CQueue <br>// <br>// Implements a simple Queue ADT.  The queue contains a finite number of <br>// objects, access to which is controlled by a semaphore.  The semaphore <br>// is created with an initial count (N).  Each time an object is added <br>// a call to WaitForSingleObject is made on the semaphore's handle.  When <br>// this function returns a slot has been reserved in the queue for the new <br>// object.  If no slots are available the function blocks until one becomes <br>// available.  Each time an object is removed from the queue ReleaseSemaphore <br>// is called on the semaphore's handle, thus freeing a slot in the queue. <br>// If no objects are present in the queue the function blocks until an <br>// object has been added. <br> <br>#define DEFAULT_QUEUESIZE   2 <br> <br>template &lt;class T&gt; class CQueue { <br>private: <br>    HANDLE          hSemPut;        // Semaphore controlling queue "putting" <br>    HANDLE          hSemGet;        // Semaphore controlling queue "getting" <br>    CRITICAL_SECTION CritSect;      // Thread seriallization <br>    int             nMax;           // Max objects allowed in queue <br>    int             iNextPut;       // Array index of next "PutMsg" <br>    int             iNextGet;       // Array index of next "GetMsg" <br>    T              *QueueObjects;   // Array of objects (ptr's to void) <br> <br>    void Initialize(int n) { <br>        iNextPut = iNextGet = 0; <br>        nMax = n; <br>        InitializeCriticalSection(&amp;CritSect); <br>        hSemPut = CreateSemaphore(NULL, n, n, NULL); <br>        hSemGet = CreateSemaphore(NULL, 0, n, NULL); <br>        QueueObjects = new T[n]; <br>    } <br> <br> <br>public: <br>    CQueue(int n) { <br>        Initialize(n); <br>    } <br> <br>    CQueue() { <br>        Initialize(DEFAULT_QUEUESIZE); <br>    } <br> <br>    ~CQueue() { <br>        delete [] QueueObjects; <br>        DeleteCriticalSection(&amp;CritSect); <br>        CloseHandle(hSemPut); <br>        CloseHandle(hSemGet); <br>    } <br> <br>    T GetQueueObject() { <br>        int iSlot; <br>        T Object; <br>        LONG lPrevious; <br> <br>        // Wait for someone to put something on our queue, returns straight <br>        // away is there is already an object on the queue. <br>        // <br>        WaitForSingleObject(hSemGet, INFINITE); <br> <br>        EnterCriticalSection(&amp;CritSect); <br>        iSlot = iNextGet++ % nMax; <br>        Object = QueueObjects[iSlot]; <br>        LeaveCriticalSection(&amp;CritSect); <br> <br>        // Release anyone waiting to put an object onto our queue as there <br>        // is now space available in the queue. <br>        // <br>        ReleaseSemaphore(hSemPut, 1L, &amp;lPrevious); <br>        return Object; <br>    } <br> <br>    void PutQueueObject(T Object) { <br>        int iSlot; <br>        LONG lPrevious; <br> <br>        // Wait for someone to get something from our queue, returns straight <br>        // away is there is already an empty slot on the queue. <br>        // <br>        WaitForSingleObject(hSemPut, INFINITE); <br> <br>        EnterCriticalSection(&amp;CritSect); <br>        iSlot = iNextPut++ % nMax; <br>        QueueObjects[iSlot] = Object; <br>        LeaveCriticalSection(&amp;CritSect); <br> <br>        // Release anyone waiting to remove an object from our queue as there <br>        // is now an object available to be removed. <br>        // <br>        ReleaseSemaphore(hSemGet, 1L, &amp;lPrevious); <br>    } <br>}; <br> <br>// miscellaneous string conversion functions <br>// NOTE: as we need to use the same binaries on Win95 as on NT this code should <br>// be compiled WITHOUT unicode being defined.  Otherwise we will not pick up <br>// these internal routines and the binary will not run on Win95. <br> <br>#ifndef UNICODE <br>#define wsprintfW wsprintfWInternal <br>int WINAPIV wsprintfWInternal(LPWSTR, LPCWSTR, ...); <br> <br>#define lstrcpyW lstrcpyWInternal <br>LPWSTR <br>WINAPI <br>lstrcpyWInternal( <br>    LPWSTR lpString1, <br>    LPCWSTR lpString2 <br>    ); <br>#define lstrcpynW lstrcpynWInternal <br>LPWSTR <br>WINAPI <br>lstrcpynWInternal( <br>    LPWSTR lpString1, <br>    LPCWSTR lpString2, <br>    int     iMaxLength <br>    ); <br>#define lstrcmpW lstrcmpWInternal <br>int <br>WINAPI <br>lstrcmpWInternal( <br>    LPCWSTR lpString1, <br>    LPCWSTR lpString2 <br>    ); <br>#define lstrcmpiW lstrcmpiWInternal <br>int <br>WINAPI <br>lstrcmpiWInternal( <br>    LPCWSTR lpString1, <br>    LPCWSTR lpString2 <br>    ); <br>#define lstrlenW lstrlenWInternal <br>int <br>WINAPI <br>lstrlenWInternal( <br>    LPCWSTR lpString <br>    ); <br>#endif <br> <br>extern "C" <br>void * __stdcall memmoveInternal(void *, const void *, size_t); <br> <br>inline void * __cdecl memchrInternal(const void *buf, int chr, size_t cnt) <br>{ <br>#ifdef _X86_ <br>    void *pRet = NULL; <br> <br>    _asm { <br>        cld                 // make sure we get the direction right <br>        mov     ecx, cnt    // num of bytes to scan <br>        mov     edi, buf    // pointer byte stream <br>        mov     eax, chr    // byte to scan for <br>        repne   scasb       // look for the byte in the byte stream <br>        jnz     exit_memchr // Z flag set if byte found <br>        dec     edi         // scasb always increments edi even when it <br>                            // finds the required byte <br>        mov     pRet, edi <br>exit_memchr: <br>    } <br>    return pRet; <br> <br>#else <br>    while ( cnt &amp;&amp; (*(unsigned char *)buf != (unsigned char)chr) ) { <br>        buf = (unsigned char *)buf + 1; <br>        cnt--; <br>    } <br> <br>    return(cnt ? (void *)buf : NULL); <br>#endif <br>} <br> <br>void WINAPI IntToWstr(int i, LPWSTR wstr); <br> <br>#define WstrToInt(sz) atoiW(sz) <br> <br>inline int atoiW(const WCHAR *sz) <br>{ <br>    int i = 0; <br> <br>    while (*sz &amp;&amp; *sz &gt;= L'0' &amp;&amp; *sz &lt;= L'9') <br>    i = i*10 + *sz++ - L'0'; <br>     <br>    return i;     <br>} <br> <br>inline int WINAPI atoiA(const CHAR *sz) <br>{ <br>    int i = 0; <br> <br>    while (*sz &amp;&amp; *sz &gt;= '0' &amp;&amp; *sz &lt;= '9') <br>    i = i*10 + *sz++ - '0'; <br>     <br>    return i;     <br>} <br> <br>#ifdef UNICODE <br>#define atoi    atoiW <br>#else <br>#define atoi    atoiA <br>#endif <br> <br> <br> <br>// These are available to help managing bitmap VIDEOINFOHEADER media structures <br> <br>extern const DWORD bits555[3]; <br>extern const DWORD bits565[3]; <br>extern const DWORD bits888[3]; <br> <br>// These help convert between VIDEOINFOHEADER and BITMAPINFO structures <br> <br>STDAPI_(const GUID) GetTrueColorType(const BITMAPINFOHEADER *pbmiHeader); <br>STDAPI_(const GUID) GetBitmapSubtype(const BITMAPINFOHEADER *pbmiHeader); <br>STDAPI_(WORD) GetBitCount(const GUID *pSubtype); <br>STDAPI_(TCHAR *) GetSubtypeName(const GUID *pSubtype); <br>STDAPI_(LONG) GetBitmapFormatSize(const BITMAPINFOHEADER *pHeader); <br>STDAPI_(DWORD) GetBitmapSize(const BITMAPINFOHEADER *pHeader); <br>STDAPI_(BOOL) ContainsPalette(const VIDEOINFOHEADER *pVideoInfo); <br>STDAPI_(const RGBQUAD *) GetBitmapPalette(const VIDEOINFOHEADER *pVideoInfo); <br> <br> <br>// Compares two interfaces and returns TRUE if they are on the same object <br>BOOL WINAPI IsEqualObject(IUnknown *pFirst, IUnknown *pSecond); <br> <br>// This is for comparing pins <br>#define EqualPins(pPin1, pPin2) IsEqualObject(pPin1, pPin2) <br> <br> <br>// Arithmetic helper functions <br> <br>// Compute (a * b + rnd) / c <br>LONGLONG WINAPI llMulDiv(LONGLONG a, LONGLONG b, LONGLONG c, LONGLONG rnd); <br>LONGLONG WINAPI Int64x32Div32(LONGLONG a, LONG b, LONG c, LONG rnd); <br> <br> <br>// Avoids us dyna-linking to SysAllocString to copy BSTR strings <br>STDAPI WriteBSTR(BSTR * pstrDest, LPCWSTR szSrc); <br>STDAPI FreeBSTR(BSTR* pstr); <br> <br>// Return a wide string - allocating memory for it <br>// Returns: <br>//    S_OK          - no error <br>//    E_POINTER     - ppszReturn == NULL <br>//    E_OUTOFMEMORY - can't allocate memory for returned string <br>STDAPI AMGetWideString(LPCWSTR pszString, LPWSTR *ppszReturn); <br> <br>// Special wait for objects owning windows <br>DWORD WINAPI WaitDispatchingMessages(HANDLE hObject, DWORD dwWait, HWND hwnd = NULL, UINT uMsg = 0); <br>#endif /* __WXUTIL__ */ <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
