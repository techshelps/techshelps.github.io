<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WXDEBUG.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2789"></a>WXDEBUG.CPP</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>// ActiveX system debugging facilities <br> <br>#define _WINDLL <br> <br>#include &lt;streams.h&gt; <br>#include &lt;stdarg.h&gt; <br>#include &lt;stdio.h&gt; <br> <br>#ifdef DEBUG <br>#ifdef UNICODE <br>#ifndef _UNICODE <br>#define _UNICODE <br>#endif // _UNICODE <br>#endif // UNICODE <br>#endif // DEBUG <br> <br>#include &lt;tchar.h&gt; <br> <br>#ifdef DEBUG <br> <br>const INT iDEBUGINFO = 512;                 // Used to format strings <br>const INT iMAXLEVELS = 5;                   // Maximum debug categories <br> <br>HINSTANCE m_hInst;                          // Module instance handle <br>TCHAR m_ModuleName[iDEBUGINFO];             // Cut down module name <br>DWORD m_Levels[iMAXLEVELS];                 // Debug level per category <br>CRITICAL_SECTION m_CSDebug;                 // Controls access to list <br>DWORD m_dwNextCookie;                       // Next active object ID <br>ObjectDesc *pListHead = NULL;               // First active object <br>DWORD m_dwObjectCount;                      // Active object count <br>BOOL m_bInit = FALSE;                       // Have we been initialised <br>HANDLE m_hOutput = INVALID_HANDLE_VALUE;    // Optional output written here <br>DWORD dwWaitTimeout = INFINITE;             // Default timeout value <br>DWORD dwTimeOffset;    // Time of first DbgLog call <br> <br>const TCHAR *pBaseKey = TEXT("SOFTWARE\\Debug"); <br>const TCHAR *pGlobalKey = TEXT("GLOBAL"); <br>static TCHAR *pUnknownName = TEXT("UNKNOWN"); <br> <br>/* For every module and executable we store a debugging level for each of <br>   the five categories (eg LOG_ERROR and LOG_TIMING). This makes it easy <br>   to isolate and debug individual modules without seeing everybody elses <br>   spurious debug output. The keys are stored in the registry under the <br>   HKEY_LOCAL_MACHINE\SOFTWARE\Debug\&lt;Module Name&gt;\&lt;KeyName&gt; key values <br>   NOTE these must be in the same order as their enumeration definition */ <br> <br>TCHAR *pKeyNames[] = { <br>    TEXT("TIMING"),      // Timing and performance measurements <br>    TEXT("TRACE"),       // General step point call tracing <br>    TEXT("MEMORY"),      // Memory and object allocation/destruction <br>    TEXT("LOCKING"),     // Locking/unlocking of critical sections <br>    TEXT("ERROR")        // Debug error notification <br>    }; <br> <br>TCHAR *TimeoutName = TEXT("TIMEOUT"); <br> <br>/* This sets the instance handle that the debug library uses to find <br>   the module's file name from the Win32 GetModuleFileName function */ <br> <br>void WINAPI DbgInitialise(HINSTANCE hInst) <br>{ <br>    InitializeCriticalSection(&amp;m_CSDebug); <br>    m_bInit = TRUE; <br> <br>    m_hInst = hInst; <br>    DbgInitModuleName(); <br>    if (GetProfileInt(m_ModuleName, TEXT("BreakOnLoad"), 0)) <br>       DebugBreak(); <br>    DbgInitModuleSettings(); <br>    DbgInitGlobalSettings(); <br>    dwTimeOffset = timeGetTime(); <br>} <br> <br> <br>/* This is called to clear up any resources the debug library uses - at the <br>   moment we delete our critical section and the object list. The values we <br>   retrieve from the registry are all done during initialisation but we don't <br>   go looking for update notifications while we are running, if the values <br>   are changed then the application has to be restarted to pick them up */ <br> <br>void WINAPI DbgTerminate() <br>{ <br>    if (m_hOutput != INVALID_HANDLE_VALUE) { <br>       EXECUTE_ASSERT(CloseHandle(m_hOutput)); <br>       m_hOutput = INVALID_HANDLE_VALUE; <br>    } <br>    DeleteCriticalSection(&amp;m_CSDebug); <br>    m_bInit = FALSE; <br>} <br> <br> <br>/* This is called by DbgInitLogLevels to read the debug settings <br>   for each logging category for this module from the registry */ <br> <br>void WINAPI DbgInitKeyLevels(HKEY hKey) <br>{ <br>    LONG lReturn;               // Create key return value <br>    LONG lKeyPos;               // Current key category <br>    DWORD dwKeySize;            // Size of the key value <br>    DWORD dwKeyType;            // Receives it's type <br>    DWORD dwKeyValue;           // This fields value <br> <br>    /* Try and read a value for each key position in turn */ <br>    for (lKeyPos = 0;lKeyPos &lt; iMAXLEVELS;lKeyPos++) { <br> <br>        dwKeySize = sizeof(DWORD); <br>        lReturn = RegQueryValueEx( <br>            hKey,                       // Handle to an open key <br>            pKeyNames[lKeyPos],         // Subkey name derivation <br>            NULL,                       // Reserved field <br>            &amp;dwKeyType,                 // Returns the field type <br>            (LPBYTE) &amp;dwKeyValue,       // Returns the field's value <br>            &amp;dwKeySize );               // Number of bytes transferred <br> <br>        /* If either the key was not available or it was not a DWORD value <br>           then we ensure only the high priority debug logging is output <br>           but we try and update the field to a zero filled DWORD value */ <br> <br>        if (lReturn != ERROR_SUCCESS || dwKeyType != REG_DWORD)  { <br> <br>            dwKeyValue = 0; <br>            lReturn = RegSetValueEx( <br>                hKey,                   // Handle of an open key <br>                pKeyNames[lKeyPos],     // Address of subkey name <br>                (DWORD) 0,              // Reserved field <br>                REG_DWORD,              // Type of the key field <br>                (PBYTE) &amp;dwKeyValue,    // Value for the field <br>                sizeof(DWORD));         // Size of the field buffer <br> <br>            if (lReturn != ERROR_SUCCESS) { <br>                DbgLog((LOG_ERROR,0,TEXT("Could not create subkey %s"),pKeyNames[lKeyPos])); <br>                dwKeyValue = 0; <br>            } <br>        } <br>        m_Levels[lKeyPos] = max(dwKeyValue,m_Levels[lKeyPos]); <br>    } <br> <br>    /*  Read the timeout value for catching hangs */ <br>    dwKeySize = sizeof(DWORD); <br>    lReturn = RegQueryValueEx( <br>        hKey,                       // Handle to an open key <br>        TimeoutName,                // Subkey name derivation <br>        NULL,                       // Reserved field <br>        &amp;dwKeyType,                 // Returns the field type <br>        (LPBYTE) &amp;dwWaitTimeout,    // Returns the field's value <br>        &amp;dwKeySize );               // Number of bytes transferred <br> <br>    /* If either the key was not available or it was not a DWORD value <br>       then we ensure only the high priority debug logging is output <br>       but we try and update the field to a zero filled DWORD value */ <br> <br>    if (lReturn != ERROR_SUCCESS || dwKeyType != REG_DWORD)  { <br> <br>        dwWaitTimeout = INFINITE; <br>        lReturn = RegSetValueEx( <br>            hKey,                   // Handle of an open key <br>            TimeoutName,            // Address of subkey name <br>            (DWORD) 0,              // Reserved field <br>            REG_DWORD,              // Type of the key field <br>            (PBYTE) &amp;dwWaitTimeout, // Value for the field <br>            sizeof(DWORD));         // Size of the field buffer <br> <br>        if (lReturn != ERROR_SUCCESS) { <br>            DbgLog((LOG_ERROR,0,TEXT("Could not create subkey %s"),pKeyNames[lKeyPos])); <br>            dwWaitTimeout = INFINITE; <br>        } <br>    } <br>} <br> <br>void WINAPI DbgOutString(LPCTSTR psz) <br>{ <br>    if (m_hOutput != INVALID_HANDLE_VALUE) { <br>        UINT  cb = lstrlen(psz); <br>        DWORD dw; <br>        WriteFile (m_hOutput, psz, cb, &amp;dw, NULL); <br>    } else { <br>        OutputDebugString (psz); <br>    } <br>} <br> <br>/* Called by DbgInitGlobalSettings to setup alternate logging destinations <br> */ <br> <br>void WINAPI DbgInitLogTo ( <br>    HKEY hKey) <br>{ <br>    LONG  lReturn; <br>    DWORD dwKeyType; <br>    DWORD dwKeySize; <br>    TCHAR szFile[MAX_PATH] = {0}; <br>    static const TCHAR cszKey[] = TEXT("LogToFile"); <br> <br>    dwKeySize = MAX_PATH; <br>    lReturn = RegQueryValueEx( <br>        hKey,                       // Handle to an open key <br>        cszKey,                     // Subkey name derivation <br>        NULL,                       // Reserved field <br>        &amp;dwKeyType,                 // Returns the field type <br>        (LPBYTE) szFile,            // Returns the field's value <br>        &amp;dwKeySize);                // Number of bytes transferred <br> <br>    // create an empty key if it does not already exist <br>    // <br>    if (lReturn != ERROR_SUCCESS || dwKeyType != REG_SZ) <br>       { <br>       dwKeySize = 1; <br>       lReturn = RegSetValueEx( <br>            hKey,                   // Handle of an open key <br>            cszKey,                 // Address of subkey name <br>            (DWORD) 0,              // Reserved field <br>            REG_SZ,                 // Type of the key field <br>            (PBYTE)szFile,          // Value for the field <br>            dwKeySize);            // Size of the field buffer <br>       } <br> <br>    // if an output-to was specified.  try to open it. <br>    // <br>    if (m_hOutput != INVALID_HANDLE_VALUE) { <br>       EXECUTE_ASSERT(CloseHandle (m_hOutput)); <br>       m_hOutput = INVALID_HANDLE_VALUE; <br>    } <br>    if (szFile[0] != 0) <br>       { <br>       if (!lstrcmpi(szFile, TEXT("Console"))) { <br>          m_hOutput = GetStdHandle (STD_OUTPUT_HANDLE); <br>          if (m_hOutput == INVALID_HANDLE_VALUE) { <br>             AllocConsole (); <br>             m_hOutput = GetStdHandle (STD_OUTPUT_HANDLE); <br>          } <br>          SetConsoleTitle (TEXT("ActiveX Debug Output")); <br>       } else if (szFile[0] &amp;&amp; <br>                lstrcmpi(szFile, TEXT("Debug")) &amp;&amp; <br>                lstrcmpi(szFile, TEXT("Debugger")) &amp;&amp; <br>                lstrcmpi(szFile, TEXT("Deb"))) <br>          { <br>          m_hOutput = CreateFile(szFile, GENERIC_WRITE, <br>                                 FILE_SHARE_READ, <br>                                 NULL, OPEN_ALWAYS, <br>                                 FILE_ATTRIBUTE_NORMAL, <br>                                 NULL); <br>          if (INVALID_HANDLE_VALUE != m_hOutput) <br>              { <br>              static const TCHAR cszBar[] = TEXT("\r\n\r\n=====DbgInitialize()=====\r\n\r\n"); <br>              SetFilePointer (m_hOutput, 0, NULL, FILE_END); <br>              DbgOutString (cszBar); <br>              } <br>          } <br>       } <br>} <br> <br> <br> <br>/* This is called by DbgInitLogLevels to read the global debug settings for <br>   each logging category for this module from the registry. Normally each <br>   module has it's own values set for it's different debug categories but <br>   setting the global SOFTWARE\Debug\Global applies them to ALL modules */ <br> <br>void WINAPI DbgInitGlobalSettings() <br>{ <br>    LONG lReturn;               // Create key return value <br>    TCHAR szInfo[iDEBUGINFO];   // Constructs key names <br>    HKEY hGlobalKey;            // Global override key <br> <br>    /* Construct the global base key name */ <br>    wsprintf(szInfo,TEXT("%s\\%s"),pBaseKey,pGlobalKey); <br> <br>    /* Create or open the key for this module */ <br>    lReturn = RegCreateKeyEx(HKEY_LOCAL_MACHINE,   // Handle of an open key <br>                             szInfo,               // Address of subkey name <br>                             (DWORD) 0,            // Reserved value <br>                             NULL,                 // Address of class name <br>                             (DWORD) 0,            // Special options flags <br>                             KEY_ALL_ACCESS,       // Desired security access <br>                             NULL,                 // Key security descriptor <br>                             &amp;hGlobalKey,          // Opened handle buffer <br>                             NULL);                // What really happened <br> <br>    if (lReturn != ERROR_SUCCESS) { <br>        DbgLog((LOG_ERROR,0,TEXT("Could not access GLOBAL module key"))); <br>        return; <br>    } <br> <br>    DbgInitKeyLevels(hGlobalKey); <br>    RegCloseKey(hGlobalKey); <br>} <br> <br> <br>/* This sets the debugging log levels for the different categories. We start <br>   by opening (or creating if not already available) the SOFTWARE\Debug key <br>   that all these settings live under. We then look at the global values <br>   set under SOFTWARE\Debug\Global which apply on top of the individual <br>   module settings. We then load the individual module registry settings */ <br> <br>void WINAPI DbgInitModuleSettings() <br>{ <br>    LONG lReturn;               // Create key return value <br>    TCHAR szInfo[iDEBUGINFO];   // Constructs key names <br>    HKEY hModuleKey;            // Module key handle <br> <br>    /* Construct the base key name */ <br>    wsprintf(szInfo,TEXT("%s\\%s"),pBaseKey,m_ModuleName); <br> <br>    /* Create or open the key for this module */ <br>    lReturn = RegCreateKeyEx(HKEY_LOCAL_MACHINE,   // Handle of an open key <br>                             szInfo,               // Address of subkey name <br>                             (DWORD) 0,            // Reserved value <br>                             NULL,                 // Address of class name <br>                             (DWORD) 0,            // Special options flags <br>                             KEY_ALL_ACCESS,       // Desired security access <br>                             NULL,                 // Key security descriptor <br>                             &amp;hModuleKey,          // Opened handle buffer <br>                             NULL);                // What really happened <br> <br>    if (lReturn != ERROR_SUCCESS) { <br>        DbgLog((LOG_ERROR,0,TEXT("Could not access module key"))); <br>        return; <br>    } <br> <br>    DbgInitLogTo(hModuleKey); <br>    DbgInitKeyLevels(hModuleKey); <br>    RegCloseKey(hModuleKey); <br>} <br> <br> <br>/* Initialise the module file name */ <br> <br>void WINAPI DbgInitModuleName() <br>{ <br>    TCHAR FullName[iDEBUGINFO];     // Load the full path and module name <br>    TCHAR *pName;                   // Searches from the end for a backslash <br> <br>    GetModuleFileName(m_hInst,FullName,iDEBUGINFO); <br>    pName = _tcsrchr(FullName,'\\'); <br>    if (pName == NULL) { <br>        pName = FullName; <br>    } else { <br>        pName++; <br>    } <br>    lstrcpy(m_ModuleName,pName); <br>} <br> <br> <br>/* Displays a message box if the condition evaluated to FALSE */ <br> <br>void WINAPI DbgAssert(const TCHAR *pCondition,const TCHAR *pFileName,INT iLine) <br>{ <br>    TCHAR szInfo[iDEBUGINFO]; <br> <br>    wsprintf(szInfo, TEXT("%s \nAt line %d of %s\nContinue? (Cancel to debug)"), <br>             pCondition, iLine, pFileName); <br> <br>    INT MsgId = MessageBox(NULL,szInfo,TEXT("ASSERT Failed"), <br>                           MB_SYSTEMMODAL | <br>                           MB_ICONHAND | <br>                           MB_YESNOCANCEL | <br>                           MB_SETFOREGROUND); <br>    switch (MsgId) <br>    { <br>        case IDNO:              /* Kill the application */ <br> <br>            FatalAppExit(FALSE, TEXT("Application terminated")); <br>            break; <br> <br>        case IDCANCEL:          /* Break into the debugger */ <br> <br>            DebugBreak(); <br>            break; <br> <br>        case IDYES:             /* Ignore assertion continue execution */ <br>            break; <br>    } <br>} <br> <br>/* Displays a message box at a break point */ <br> <br>void WINAPI DbgBreakPoint(const TCHAR *pCondition,const TCHAR *pFileName,INT iLine) <br>{ <br>    TCHAR szInfo[iDEBUGINFO]; <br> <br>    wsprintf(szInfo, TEXT("%s \nAt line %d of %s\nContinue? (Cancel to debug)"), <br>             pCondition, iLine, pFileName); <br> <br>    INT MsgId = MessageBox(NULL,szInfo,TEXT("Hard coded break point"), <br>                           MB_SYSTEMMODAL | <br>                           MB_ICONHAND | <br>                           MB_YESNOCANCEL | <br>                           MB_SETFOREGROUND); <br>    switch (MsgId) <br>    { <br>        case IDNO:              /* Kill the application */ <br> <br>            FatalAppExit(FALSE, TEXT("Application terminated")); <br>            break; <br> <br>        case IDCANCEL:          /* Break into the debugger */ <br> <br>            DebugBreak(); <br>            break; <br> <br>        case IDYES:             /* Ignore break point continue execution */ <br>            break; <br>    } <br>} <br> <br> <br>/* When we initialised the library we stored in the m_Levels array the current <br>   debug output level for this module for each of the five categories. When <br>   some debug logging is sent to us it can be sent with a combination of the <br>   categories (if it is applicable to many for example) in which case we map <br>   the type's categories into their current debug levels and see if any of <br>   them can be accepted. The function looks at each bit position in turn from <br>   the input type field and then compares it's debug level with the modules. <br> <br>   A level of 0 means that output is always sent to the debugger.  This is <br>   due to producing output if the input level is &lt;= m_Levels. <br>*/ <br> <br> <br>BOOL WINAPI DbgCheckModuleLevel(DWORD Type,DWORD Level) <br>{ <br>    DWORD Mask = 0x01; <br> <br>    // If no valid bits are set return FALSE <br>    if ((Type &amp; ((1&lt;&lt;iMAXLEVELS)-1))) { <br> <br>// speed up unconditional output. <br>if (0==Level) <br>    return(TRUE); <br> <br>        for (LONG lKeyPos = 0;lKeyPos &lt; iMAXLEVELS;lKeyPos++) { <br>            if (Type &amp; Mask) { <br>                if (Level &lt;= m_Levels[lKeyPos]) { <br>                    return TRUE; <br>                } <br>            } <br>            Mask &lt;&lt;= 1; <br>        } <br>    } <br>    return FALSE; <br>} <br> <br> <br>/* Set debug levels to a given value */ <br> <br>void WINAPI DbgSetModuleLevel(DWORD Type, DWORD Level) <br>{ <br>    DWORD Mask = 0x01; <br> <br>    for (LONG lKeyPos = 0;lKeyPos &lt; iMAXLEVELS;lKeyPos++) { <br>        if (Type &amp; Mask) { <br>            m_Levels[lKeyPos] = Level; <br>        } <br>        Mask &lt;&lt;= 1; <br>    } <br>} <br> <br>/* Print a formatted string to the debugger prefixed with this module's name <br>   Because the COMBASE classes are linked statically every module loaded will <br>   have their own copy of this code. It therefore helps if the module name is <br>   included on the output so that the offending code can be easily found */ <br> <br>void WINAPI DbgLogInfo(DWORD Type,DWORD Level,const TCHAR *pFormat,...) <br>{ <br>    /* Check the current level for this type combination */ <br> <br>    BOOL bAccept = DbgCheckModuleLevel(Type,Level); <br>    if (bAccept == FALSE) { <br>        return; <br>    } <br> <br>    TCHAR szInfo[2000]; <br> <br>    /* Format the variable length parameter list */ <br> <br>    va_list va; <br>    va_start(va, pFormat); <br> <br>    lstrcpy(szInfo,m_ModuleName); <br>    wsprintf(szInfo + lstrlen(szInfo), <br>             TEXT("(tid %x) %8d : "), <br>             GetCurrentThreadId(), timeGetTime() - dwTimeOffset); <br> <br>    wvsprintf(szInfo + lstrlen(szInfo), pFormat, va); <br>    lstrcat(szInfo, TEXT("\r\n")); <br>    DbgOutString(szInfo); <br> <br>    va_end(va); <br>} <br> <br> <br>/* If we are executing as a pure kernel filter we cannot display message <br>   boxes to the user, this provides an alternative which puts the error <br>   condition on the debugger output with a suitable eye catching message */ <br> <br>void WINAPI DbgKernelAssert(const TCHAR *pCondition,const TCHAR *pFileName,INT iLine) <br>{ <br>    DbgLog((LOG_ERROR,0,TEXT("Assertion FAILED (%s) at line %d in file %s"), <br>           pCondition, iLine, pFileName)); <br>    DebugBreak(); <br>} <br> <br> <br> <br>/* Each time we create an object derived from CBaseObject the constructor will <br>   call us to register the creation of the new object. We are passed a string <br>   description which we store away. We return a cookie that the constructor <br>   uses to identify the object when it is destroyed later on. We update the <br>   total number of active objects in the DLL mainly for debugging purposes */ <br> <br>DWORD WINAPI DbgRegisterObjectCreation(const TCHAR *pObjectName) <br>{ <br>    /* If this fires you have a mixed DEBUG/RETAIL build */ <br> <br>    ASSERT(pObjectName); <br> <br>    /* Create a place holder for this object description */ <br> <br>    ObjectDesc *pObject = new ObjectDesc; <br>    ASSERT(pObject); <br> <br>    /* It is valid to pass a NULL object name */ <br>    if (pObject == NULL) { <br>        return FALSE; <br>    } <br> <br>    /* Check we have been initialised - we may not be initialised when we are <br>       being pulled in from an executable which has globally defined objects <br>       as they are created by the C++ run time before WinMain is called */ <br> <br>    if (m_bInit == FALSE) { <br>        DbgInitialise(GetModuleHandle(NULL)); <br>    } <br> <br>    /* Grab the list critical section */ <br>    EnterCriticalSection(&amp;m_CSDebug); <br> <br>    /* If no name then default to UNKNOWN */ <br>    if (pObjectName == NULL) { <br>        pObjectName = pUnknownName; <br>    } <br> <br>    /* Put the new description at the head of the list */ <br> <br>    pObject-&gt;m_pName = pObjectName; <br>    pObject-&gt;m_dwCookie = ++m_dwNextCookie; <br>    pObject-&gt;m_pNext = pListHead; <br> <br>    pListHead = pObject; <br>    m_dwObjectCount++; <br> <br>    DWORD ObjectCookie = pObject-&gt;m_dwCookie; <br>    ASSERT(ObjectCookie); <br> <br>    DbgLog((LOG_MEMORY,2,TEXT("Object created   %d (%s) %d Active"), <br>            pObject-&gt;m_dwCookie, pObjectName, m_dwObjectCount)); <br> <br>    LeaveCriticalSection(&amp;m_CSDebug); <br>    return ObjectCookie; <br>} <br> <br> <br>/* This is called by the CBaseObject destructor when an object is about to be <br>   destroyed, we are passed the cookie we returned during construction that <br>   identifies this object. We scan the object list for a matching cookie and <br>   remove the object if successful. We also update the active object count */ <br> <br>BOOL WINAPI DbgRegisterObjectDestruction(DWORD dwCookie) <br>{ <br>    /* Grab the list critical section */ <br>    EnterCriticalSection(&amp;m_CSDebug); <br> <br>    ObjectDesc *pObject = pListHead; <br>    ObjectDesc *pPrevious = NULL; <br> <br>    /* Scan the object list looking for a cookie match */ <br> <br>    while (pObject) { <br>        if (pObject-&gt;m_dwCookie == dwCookie) { <br>            break; <br>        } <br>        pPrevious = pObject; <br>        pObject = pObject-&gt;m_pNext; <br>    } <br> <br>    if (pObject == NULL) { <br>        DbgBreak("Apparently destroying a bogus object"); <br>        LeaveCriticalSection(&amp;m_CSDebug); <br>        return FALSE; <br>    } <br> <br>    /* Is the object at the head of the list */ <br> <br>    if (pPrevious == NULL) { <br>        pListHead = pObject-&gt;m_pNext; <br>    } else { <br>        pPrevious-&gt;m_pNext = pObject-&gt;m_pNext; <br>    } <br> <br>    /* Delete the object and update the housekeeping information */ <br> <br>    m_dwObjectCount--; <br>    DbgLog((LOG_MEMORY,2,TEXT("Object destroyed %d (%s) %d Active"), <br>            pObject-&gt;m_dwCookie, pObject-&gt;m_pName, m_dwObjectCount)); <br> <br>    delete pObject; <br>    LeaveCriticalSection(&amp;m_CSDebug); <br>    return TRUE; <br>} <br> <br> <br>/* This runs through the active object list displaying their details */ <br> <br>void WINAPI DbgDumpObjectRegister() <br>{ <br>    TCHAR szInfo[iDEBUGINFO]; <br> <br>    /* Grab the list critical section */ <br> <br>    EnterCriticalSection(&amp;m_CSDebug); <br>    ObjectDesc *pObject = pListHead; <br> <br>    /* Scan the object list displaying the name and cookie */ <br> <br>    DbgLog((LOG_MEMORY,2,TEXT(""))); <br>    DbgLog((LOG_MEMORY,2,TEXT("   ID             Object Description"))); <br>    DbgLog((LOG_MEMORY,2,TEXT(""))); <br> <br>    while (pObject) { <br>        wsprintf(szInfo,TEXT("%5d (%8x) %30s"),pObject-&gt;m_dwCookie, &amp;pObject, pObject-&gt;m_pName); <br>        DbgLog((LOG_MEMORY,2,szInfo)); <br>        pObject = pObject-&gt;m_pNext; <br>    } <br> <br>    wsprintf(szInfo,TEXT("Total object count %5d"),m_dwObjectCount); <br>    DbgLog((LOG_MEMORY,2,TEXT(""))); <br>    DbgLog((LOG_MEMORY,1,szInfo)); <br>    LeaveCriticalSection(&amp;m_CSDebug); <br>} <br> <br>/*  Debug infinite wait stuff */ <br>DWORD WINAPI DbgWaitForSingleObject(HANDLE h) <br>{ <br>    DWORD dwWaitResult; <br>    do { <br>        dwWaitResult = WaitForSingleObject(h, dwWaitTimeout); <br>        ASSERT(dwWaitResult == WAIT_OBJECT_0); <br>    } while (dwWaitResult == WAIT_TIMEOUT); <br>    return dwWaitResult; <br>} <br>DWORD WINAPI DbgWaitForMultipleObjects(DWORD nCount, <br>                                CONST HANDLE *lpHandles, <br>                                BOOL bWaitAll) <br>{ <br>    DWORD dwWaitResult; <br>    do { <br>        dwWaitResult = WaitForMultipleObjects(nCount, <br>                                              lpHandles, <br>                                              bWaitAll, <br>                                              dwWaitTimeout); <br>        ASSERT((DWORD)(dwWaitResult - WAIT_OBJECT_0) &lt; MAXIMUM_WAIT_OBJECTS); <br>    } while (dwWaitResult == WAIT_TIMEOUT); <br>    return dwWaitResult; <br>} <br> <br>void WINAPI DbgSetWaitTimeout(DWORD dwTimeout) <br>{ <br>    dwWaitTimeout = dwTimeout; <br>} <br> <br>#endif /* DEBUG */ <br> <br>#ifdef _OBJBASE_H_ <br> <br>    /*  Stuff for printing out our GUID names */ <br> <br>    GUID_STRING_ENTRY g_GuidNames[] = { <br>    #define OUR_GUID_ENTRY(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \ <br>    { TEXT(#name), { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } } }, <br>        #include &lt;uuids.h&gt; <br>    }; <br> <br>    CGuidNameList GuidNames; <br>    int g_cGuidNames = sizeof(g_GuidNames) / sizeof(g_GuidNames[0]); <br> <br>    TCHAR *CGuidNameList::operator [] (const GUID &amp;guid) <br>    { <br>        for (int i = 0; i &lt; g_cGuidNames; i++) { <br>            if (g_GuidNames[i].guid == guid) { <br>                return g_GuidNames[i].szName; <br>            } <br>        } <br>        if (guid == GUID_NULL) { <br>            return TEXT("GUID_NULL"); <br>        } <br> <br>// !!! add something to print FOURCC guids? <br> <br>// shouldn't this print the hex CLSID? <br>        return TEXT("Unknown GUID Name"); <br>    } <br> <br>#endif /* _OBJBASE_H_ */ <br> <br>/*  CDisp class - display our data types */ <br> <br>// clashes with REFERENCE_TIME <br>CDisp::CDisp(LONGLONG ll, int Format) <br>{ <br>    // note: this could be combined with CDisp(LONGLONG) by <br>    // introducing a default format of CDISP_REFTIME <br>    LARGE_INTEGER li; <br>    li.QuadPart = ll; <br>    switch (Format) { <br>case CDISP_DEC: <br>{ <br>    TCHAR  temp[20]; <br>    int pos=20; <br>    temp[--pos] = 0; <br>    int digit; <br>    // always output at least one digit <br>    do { <br>// Get the rightmost digit - we only need the low word <br>        digit = li.LowPart % 10; <br>li.QuadPart /= 10; <br>temp[--pos] = (TCHAR) digit+L'0'; <br>    } while (li.QuadPart); <br>    wsprintf(m_String, TEXT("%s"), temp+pos); <br>    break; <br>} <br>case CDISP_HEX: <br>default: <br>    wsprintf(m_String, TEXT("0x%X%8.8X"), li.HighPart, li.LowPart); <br>    } <br>}; <br> <br>CDisp::CDisp(REFCLSID clsid) <br>{ <br>    WCHAR strClass[CHARS_IN_GUID+1]; <br>    StringFromGUID2(clsid, strClass, sizeof(strClass) / sizeof(strClass[0])); <br>    ASSERT(sizeof(m_String)/sizeof(m_String[0]) &gt;= CHARS_IN_GUID+1); <br>    wsprintf(m_String, TEXT("%ls"), strClass); <br>}; <br> <br>/*  Display stuff */ <br>CDisp::CDisp(CRefTime llTime) <br>{ <br>    LPTSTR lpsz = m_String; <br>    LONGLONG llDiv; <br>    if (llTime &lt; 0) { <br>        llTime = -llTime; <br>        lpsz += wsprintf(lpsz, TEXT("-")); <br>    } <br>    llDiv = (LONGLONG)24 * 3600 * 10000000; <br>    if (llTime &gt;= llDiv) { <br>        lpsz += wsprintf(lpsz, TEXT("%d days "), (LONG)(llTime / llDiv)); <br>        llTime = llTime % llDiv; <br>    } <br>    llDiv = (LONGLONG)3600 * 10000000; <br>    if (llTime &gt;= llDiv) { <br>        lpsz += wsprintf(lpsz, TEXT("%d hrs "), (LONG)(llTime / llDiv)); <br>        llTime = llTime % llDiv; <br>    } <br>    llDiv = (LONGLONG)60 * 10000000; <br>    if (llTime &gt;= llDiv) { <br>        lpsz += wsprintf(lpsz, TEXT("%d mins "), (LONG)(llTime / llDiv)); <br>        llTime = llTime % llDiv; <br>    } <br>    wsprintf(lpsz, TEXT("%d.%3.3d sec"), <br>             (LONG)llTime / 10000000, <br>             (LONG)((llTime % 10000000) / 10000)); <br>}; <br> <br>/*  Display pin */ <br>CDisp::CDisp(IPin *pPin) <br>{ <br>    PIN_INFO pi; <br>    TCHAR str[MAX_PIN_NAME]; <br>    if (pPin) { <br>       pPin-&gt;QueryPinInfo(&amp;pi); <br>       QueryPinInfoReleaseFilter(pi); <br>      #ifndef UNICODE <br>       WideCharToMultiByte(GetACP(), 0, pi.achName, lstrlenW(pi.achName) + 1, <br>                           str, MAX_PIN_NAME, NULL, NULL); <br>      #else <br>       lstrcpy(str, pi.achName); <br>      #endif <br>    } else { <br>       lstrcpy(str, TEXT("NULL IPin")); <br>    } <br> <br>    m_pString = (PTCHAR) new TCHAR[lstrlen(str)+64]; <br>    if (!m_pString) { <br>return; <br>    } <br> <br>    CLSID clsid; <br>    pi.pFilter-&gt;GetClassID(&amp;clsid); <br>    wsprintf(m_pString, TEXT("%s(%s)"), GuidNames[clsid], str); <br>} <br> <br>CDisp::~CDisp() <br>{ <br>} <br> <br>CDispBasic::~CDispBasic() <br>{ <br>    if (m_pString != m_String) { <br>delete [] m_pString; <br>    } <br>} <br> <br>CDisp::CDisp(double d) <br>{ <br>#ifdef DEBUG <br>    _stprintf(m_String, TEXT("%.16g"), d); <br>#else <br>    wsprintf(m_String, TEXT("%d.%03d"), (int) d, (int) ((d - (int) d) * 1000)); <br>#endif <br>} <br> <br> <br>/* If built for debug this will display the media type details. We convert the <br>   major and subtypes into strings and also ask the base classes for a string <br>   description of the subtype, so MEDIASUBTYPE_RGB565 becomes RGB 565 16 bit <br>   We also display the fields in the BITMAPINFOHEADER structure, this should <br>   succeed as we do not accept input types unless the format is big enough */ <br> <br>#ifdef DEBUG <br>void WINAPI DisplayType(LPSTR label, const AM_MEDIA_TYPE *pmtIn) <br>{ <br> <br>    /* Dump the GUID types and a short description */ <br> <br>    DbgLog((LOG_TRACE,5,TEXT(""))); <br>    DbgLog((LOG_TRACE,2,TEXT("%hs  M type %s  S type %s"), label, <br>    GuidNames[pmtIn-&gt;majortype], <br>    GuidNames[pmtIn-&gt;subtype])); <br>    DbgLog((LOG_TRACE,5,TEXT("Subtype description %s"),GetSubtypeName(&amp;pmtIn-&gt;subtype))); <br> <br>    /* Dump the generic media types */ <br> <br>    if (pmtIn-&gt;bTemporalCompression) { <br>DbgLog((LOG_TRACE,5,TEXT("Temporally compressed"))); <br>    } else { <br>DbgLog((LOG_TRACE,5,TEXT("Not temporally compressed"))); <br>    } <br> <br>    if (pmtIn-&gt;bFixedSizeSamples) { <br>DbgLog((LOG_TRACE,5,TEXT("Sample size %d"),pmtIn-&gt;lSampleSize)); <br>    } else { <br>DbgLog((LOG_TRACE,5,TEXT("Variable size samples"))); <br>    } <br> <br>    if (pmtIn-&gt;formattype == FORMAT_VideoInfo) { <br>/* Dump the contents of the BITMAPINFOHEADER structure */ </code></pre>
<p>
</p>
<pre><code>BITMAPINFOHEADER *pbmi = HEADER(pmtIn-&gt;pbFormat); <br>VIDEOINFOHEADER *pVideoInfo = (VIDEOINFOHEADER *)pmtIn-&gt;pbFormat; <br> <br>DbgLog((LOG_TRACE,5,TEXT("Source rectangle (Left %d Top %d Right %d Bottom %d)"), <br>       pVideoInfo-&gt;rcSource.left, <br>       pVideoInfo-&gt;rcSource.top, <br>       pVideoInfo-&gt;rcSource.right, <br>       pVideoInfo-&gt;rcSource.bottom)); <br> <br>DbgLog((LOG_TRACE,5,TEXT("Target rectangle (Left %d Top %d Right %d Bottom %d)"), <br>       pVideoInfo-&gt;rcTarget.left, <br>       pVideoInfo-&gt;rcTarget.top, <br>       pVideoInfo-&gt;rcTarget.right, <br>       pVideoInfo-&gt;rcTarget.bottom)); <br> <br>DbgLog((LOG_TRACE,5,TEXT("Size of BITMAPINFO structure %d"),pbmi-&gt;biSize)); <br>if (pbmi-&gt;biCompression &lt; 256) { <br>    DbgLog((LOG_TRACE,2,TEXT("%dx%dx%d bit  (%d)"), <br>    pbmi-&gt;biWidth, pbmi-&gt;biHeight, <br>    pbmi-&gt;biBitCount, pbmi-&gt;biCompression)); <br>} else { <br>    DbgLog((LOG_TRACE,2,TEXT("%dx%dx%d bit '%4.4hs'"), <br>    pbmi-&gt;biWidth, pbmi-&gt;biHeight, <br>    pbmi-&gt;biBitCount, &amp;pbmi-&gt;biCompression)); <br>} <br> <br>DbgLog((LOG_TRACE,2,TEXT("Image size %d"),pbmi-&gt;biSizeImage)); <br>DbgLog((LOG_TRACE,5,TEXT("Planes %d"),pbmi-&gt;biPlanes)); <br>DbgLog((LOG_TRACE,5,TEXT("X Pels per metre %d"),pbmi-&gt;biXPelsPerMeter)); <br>DbgLog((LOG_TRACE,5,TEXT("Y Pels per metre %d"),pbmi-&gt;biYPelsPerMeter)); <br>DbgLog((LOG_TRACE,5,TEXT("Colours used %d"),pbmi-&gt;biClrUsed)); <br> <br>    } else if (pmtIn-&gt;majortype == MEDIATYPE_Audio) { <br>DbgLog((LOG_TRACE,2,TEXT("     Format type %s"), <br>    GuidNames[pmtIn-&gt;formattype])); <br>DbgLog((LOG_TRACE,2,TEXT("     Subtype %s"), <br>    GuidNames[pmtIn-&gt;subtype])); <br> <br>if ((pmtIn-&gt;subtype != MEDIASUBTYPE_MPEG1Packet) <br>  &amp;&amp; (pmtIn-&gt;cbFormat &gt;= sizeof(PCMWAVEFORMAT))) <br>{ <br>    /* Dump the contents of the WAVEFORMATEX type-specific format structure */ <br> <br>    WAVEFORMATEX *pwfx = (WAVEFORMATEX *) pmtIn-&gt;pbFormat; <br>            DbgLog((LOG_TRACE,2,TEXT("wFormatTag %u"), pwfx-&gt;wFormatTag)); <br>            DbgLog((LOG_TRACE,2,TEXT("nChannels %u"), pwfx-&gt;nChannels)); <br>            DbgLog((LOG_TRACE,2,TEXT("nSamplesPerSec %lu"), pwfx-&gt;nSamplesPerSec)); <br>            DbgLog((LOG_TRACE,2,TEXT("nAvgBytesPerSec %lu"), pwfx-&gt;nAvgBytesPerSec)); <br>            DbgLog((LOG_TRACE,2,TEXT("nBlockAlign %u"), pwfx-&gt;nBlockAlign)); <br>            DbgLog((LOG_TRACE,2,TEXT("wBitsPerSample %u"), pwfx-&gt;wBitsPerSample)); <br> <br>            /* PCM uses a WAVEFORMAT and does not have the extra size field */ <br> <br>            if (pmtIn-&gt;cbFormat &gt;= sizeof(WAVEFORMATEX)) { <br>                DbgLog((LOG_TRACE,2,TEXT("cbSize %u"), pwfx-&gt;cbSize)); <br>            } <br>} else { <br>} <br> <br>    } else { <br>DbgLog((LOG_TRACE,2,TEXT("     Format type %s"), <br>    GuidNames[pmtIn-&gt;formattype])); <br>// !!!! should add code to dump wave format, others <br>    } <br>} <br> <br> <br>void WINAPI DumpGraph(IFilterGraph *pGraph, DWORD dwLevel) <br>{ <br>    IEnumFilters *pFilters; <br> <br>    DbgLog((LOG_TRACE,dwLevel,TEXT("DumpGraph [%x]"), pGraph)); <br> <br>    if (FAILED(pGraph-&gt;EnumFilters(&amp;pFilters))) { <br>DbgLog((LOG_TRACE,dwLevel,TEXT("EnumFilters failed!"))); <br>    } <br> <br>    IBaseFilter *pFilter; <br>    ULONGn; <br>    while (pFilters-&gt;Next(1, &amp;pFilter, &amp;n) == S_OK) { <br>FILTER_INFOinfo; <br> <br>if (FAILED(pFilter-&gt;QueryFilterInfo(&amp;info))) { <br>    DbgLog((LOG_TRACE,dwLevel,TEXT("    Filter [%x]  -- failed QueryFilterInfo"), pFilter)); <br>} else { <br>    QueryFilterInfoReleaseGraph(info); <br> <br>    // !!! should QueryVendorInfo here! <br> <br>    DbgLog((LOG_TRACE,dwLevel,TEXT("    Filter [%x]  '%ls'"), pFilter, info.achName)); <br> <br>    IEnumPins *pins; <br> <br>    if (FAILED(pFilter-&gt;EnumPins(&amp;pins))) { <br>DbgLog((LOG_TRACE,dwLevel,TEXT("EnumPins failed!"))); <br>    } else { <br> <br>IPin *pPin; <br>while (pins-&gt;Next(1, &amp;pPin, &amp;n) == S_OK) { <br>    PIN_INFOinfo; <br> <br>    if (FAILED(pPin-&gt;QueryPinInfo(&amp;info))) { <br>DbgLog((LOG_TRACE,dwLevel,TEXT("          Pin [%x]  -- failed QueryPinInfo"), pPin)); <br>    } else { <br>QueryPinInfoReleaseFilter(info); <br> <br>IPin *pPinConnected = NULL; <br> <br>HRESULT hr = pPin-&gt;ConnectedTo(&amp;pPinConnected); <br> <br>if (pPinConnected) { <br>    DbgLog((LOG_TRACE,dwLevel,TEXT("          Pin [%x]  '%ls' [%sput]") <br>   TEXT("  Connected to pin [%x]"), <br>    pPin, info.achName, <br>    info.dir == PINDIR_INPUT ? TEXT("In") : TEXT("Out"), <br>    pPinConnected)); <br> <br>    pPinConnected-&gt;Release(); <br> <br>    // perhaps we should really dump the type both ways as a sanity <br>    // check? <br>    if (info.dir == PINDIR_OUTPUT) { <br>AM_MEDIA_TYPE mt; <br> <br>hr = pPin-&gt;ConnectionMediaType(&amp;mt); <br> <br>if (SUCCEEDED(hr)) { <br>    DisplayType("Connection type", &amp;mt); <br> <br>    FreeMediaType(mt); <br>} <br>    } <br>} else { <br>    DbgLog((LOG_TRACE,dwLevel, <br>    TEXT("          Pin [%x]  '%ls' [%sput]"), <br>    pPin, info.achName, <br>    info.dir == PINDIR_INPUT ? TEXT("In") : TEXT("Out"))); <br> <br>} <br>    } <br> <br>    pPin-&gt;Release(); <br> <br>} <br> <br>pins-&gt;Release(); <br>    } <br> <br>} <br> <br>pFilter-&gt;Release(); <br>    } <br> <br>    pFilters-&gt;Release(); <br> <br>} <br> <br>#endif <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
