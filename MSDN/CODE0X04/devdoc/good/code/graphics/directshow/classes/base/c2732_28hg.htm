<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>AMFILTER.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2734"></a>AMFILTER.CPP</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>// Base class hierachy for streams architecture, December 1994 <br> <br>//===================================================================== <br>//===================================================================== <br>// The following classes are declared in this header: <br>// <br>// <br>// CBaseMediaFilter            Basic IMediaFilter support (abstract class) <br>// CBaseFilter                 Support for IBaseFilter (incl. IMediaFilter) <br>// CEnumPins                   Enumerate input and output pins <br>// CEnumMediaTypes             Enumerate the preferred pin formats <br>// CBasePin                    Abstract base class for IPin interface <br>//    CBaseOutputPin           Adds data provider member functions <br>//    CBaseInputPin            Implements IMemInputPin interface <br>// CMediaSample                Basic transport unit for IMemInputPin <br>// CBaseAllocator              General list guff for most allocators <br>//    CMemAllocator            Implements memory buffer allocation <br>// <br>//===================================================================== <br>//===================================================================== <br> <br>#include &lt;streams.h&gt; <br> <br>//===================================================================== <br>// Helpers <br>//===================================================================== <br>STDAPI CreateMemoryAllocator(IMemAllocator **ppAllocator) <br>{ <br>    return CoCreateInstance(CLSID_MemoryAllocator, <br>                            0, <br>                            CLSCTX_INPROC_SERVER, <br>                            IID_IMemAllocator, <br>                            (void **)ppAllocator); <br>} <br> <br>//  Put this one here rather than in ctlutil.cpp to avoid linking <br>//  anything brought in by ctlutil.cpp <br>STDAPI CreatePosPassThru( <br>    LPUNKNOWN pAgg, <br>    BOOL bRenderer, <br>    IPin *pPin, <br>    IUnknown **ppPassThru <br>) <br>{ <br>    *ppPassThru = NULL; <br>    IUnknown *pUnkSeek; <br>    HRESULT hr = CoCreateInstance(CLSID_SeekingPassThru, <br>                                  pAgg, <br>                                  CLSCTX_INPROC_SERVER, <br>                                  IID_IUnknown, <br>                                  (void **)&amp;pUnkSeek <br>                                 ); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br> <br>    ISeekingPassThru *pPassThru; <br>    hr = pUnkSeek-&gt;QueryInterface(IID_ISeekingPassThru, (void**)&amp;pPassThru); <br>    if (FAILED(hr)) { <br>        pUnkSeek-&gt;Release(); <br>        return hr; <br>    } <br>    hr = pPassThru-&gt;Init(bRenderer, pPin); <br>    pPassThru-&gt;Release(); <br>    if (FAILED(hr)) { <br>        pUnkSeek-&gt;Release(); <br>        return hr; <br>    } <br>    *ppPassThru = pUnkSeek; <br>    return S_OK; <br>} <br> <br>#define CONNECT_TRACE_LEVEL 3 <br> <br>//===================================================================== <br>//===================================================================== <br>// Implements CBaseMediaFilter <br>//===================================================================== <br>//===================================================================== <br> <br> <br>/* Constructor */ <br> <br>CBaseMediaFilter::CBaseMediaFilter(const TCHAR*pName, <br>   LPUNKNOWNpUnk, <br>   CCritSec*pLock, <br>   REFCLSIDclsid) : <br>    CUnknown(pName, pUnk), <br>    m_pLock(pLock), <br>    m_clsid(clsid), <br>    m_State(State_Stopped), <br>    m_pClock(NULL) <br>{ <br>} <br> <br> <br>/* Destructor */ <br> <br>CBaseMediaFilter::~CBaseMediaFilter() <br>{ <br>    // must be stopped, but can't call Stop here since <br>    // our critsec has been destroyed. <br> <br>    /* Release any clock we were using */ <br> <br>    if (m_pClock) { <br>m_pClock-&gt;Release(); <br>m_pClock = NULL; <br>    } <br>} <br> <br> <br>/* Override this to say what interfaces we support and where */ <br> <br>STDMETHODIMP <br>CBaseMediaFilter::NonDelegatingQueryInterface( <br>    REFIID riid, <br>    void ** ppv) <br>{ <br>    if (riid == IID_IMediaFilter) { <br>    return GetInterface((IMediaFilter *) this, ppv); <br>    } else if (riid == IID_IPersist) { <br>    return GetInterface((IPersist *) this, ppv); <br>    } else { <br>    return CUnknown::NonDelegatingQueryInterface(riid, ppv); <br>    } <br>} <br> <br>/* Return the filter's clsid */ <br>STDMETHODIMP <br>CBaseMediaFilter::GetClassID(CLSID *pClsID) <br>{ <br>    CheckPointer(pClsID,E_POINTER); <br>    ValidateReadWritePtr(pClsID,sizeof(CLSID)); <br>    *pClsID = m_clsid; <br>    return NOERROR; <br>} <br> <br>/* Override this if your state changes are not done synchronously */ <br> <br>STDMETHODIMP <br>CBaseMediaFilter::GetState(DWORD dwMSecs, FILTER_STATE *State) <br>{ <br>    UNREFERENCED_PARAMETER(dwMSecs); <br>    CheckPointer(State,E_POINTER); <br>    ValidateReadWritePtr(State,sizeof(FILTER_STATE)); <br> <br>    *State = m_State; <br>    return S_OK; <br>} <br> <br> <br>/* Set the clock we will use for synchronisation */ <br> <br>STDMETHODIMP <br>CBaseMediaFilter::SetSyncSource(IReferenceClock *pClock) <br>{ <br>    CAutoLock cObjectLock(m_pLock); <br> <br>    // Ensure the new one does not go away - even if the same as the old <br>    if (pClock) { <br>pClock-&gt;AddRef(); <br>    } <br> <br>    // if we have a clock, release it <br>    if (m_pClock) { <br>m_pClock-&gt;Release(); <br>    } <br> <br>    // Set the new reference clock (might be NULL) <br>    // Should we query it to ensure it is a clock?  Consider for a debug build. <br>    m_pClock = pClock; <br> <br>    return NOERROR; <br>} <br> <br>/* Return the clock we are using for synchronisation */ <br>STDMETHODIMP <br>CBaseMediaFilter::GetSyncSource(IReferenceClock **pClock) <br>{ <br>    CheckPointer(pClock,E_POINTER); <br>    ValidateReadWritePtr(pClock,sizeof(IReferenceClock *)); <br>    CAutoLock cObjectLock(m_pLock); <br> <br>    if (m_pClock) { <br>// returning an interface... addref it... <br>m_pClock-&gt;AddRef(); <br>    } <br>    *pClock = (IReferenceClock*)m_pClock; <br>    return NOERROR; <br>} <br> <br> <br>/* Put the filter into a stopped state */ <br> <br>STDMETHODIMP <br>CBaseMediaFilter::Stop() <br>{ <br>    CAutoLock cObjectLock(m_pLock); <br> <br>    m_State = State_Stopped; <br>    return S_OK; <br>} <br> <br> <br>/* Put the filter into a paused state */ <br> <br>STDMETHODIMP <br>CBaseMediaFilter::Pause() <br>{ <br>    CAutoLock cObjectLock(m_pLock); <br> <br>    m_State = State_Paused; <br>    return S_OK; <br>} <br> <br> <br>// Put the filter into a running state. <br> <br>// The time parameter is the offset to be added to the samples' <br>// stream time to get the reference time at which they should be presented. <br>// <br>// you can either add these two and compare it against the reference clock, <br>// or you can call CBaseMediaFilter::StreamTime and compare that against <br>// the sample timestamp. <br> <br>STDMETHODIMP <br>CBaseMediaFilter::Run(REFERENCE_TIME tStart) <br>{ <br>    CAutoLock cObjectLock(m_pLock); <br> <br>    // remember the stream time offset <br>    m_tStart = tStart; <br> <br>    if (m_State == State_Stopped){ <br>HRESULT hr = Pause(); <br> <br>if (FAILED(hr)) { <br>    return hr; <br>} <br>    } <br>    m_State = State_Running; <br>    return S_OK; <br>} <br> <br> <br>// <br>// return the current stream time - samples with start timestamps of this <br>// time or before should be rendered by now <br>HRESULT <br>CBaseMediaFilter::StreamTime(CRefTime&amp; rtStream) <br>{ <br>    // Caller must lock for synchronization <br>    // We can't grab the filter lock because we want to be able to call <br>    // this from worker threads without deadlocking <br> <br>    if (m_pClock == NULL) { <br>return VFW_E_NO_CLOCK; <br>    } <br> <br>    // get the current reference time <br>    HRESULT hr = m_pClock-&gt;GetTime((REFERENCE_TIME*)&amp;rtStream); <br>    if (FAILED(hr)) { <br>return hr; <br>    } <br> <br>    // subtract the stream offset to get stream time <br>    rtStream -= m_tStart; <br> <br>    return S_OK; <br>} <br> <br> <br>//===================================================================== <br>//===================================================================== <br>// Implements CBaseFilter <br>//===================================================================== <br>//===================================================================== <br> <br> <br>/* Override this to say what interfaces we support and where */ <br> <br>STDMETHODIMP CBaseFilter::NonDelegatingQueryInterface(REFIID riid, <br>                                                      void **ppv) <br>{ <br>    /* Do we have this interface */ <br> <br>    if (riid == IID_IBaseFilter) { <br>return GetInterface((IBaseFilter *) this, ppv); <br>    } else if (riid == IID_IMediaFilter) { <br>return GetInterface((IMediaFilter *) this, ppv); <br>    } else if (riid == IID_IPersist) { <br>return GetInterface((IPersist *) this, ppv); <br>    } else if (riid == IID_IAMovieSetup) { <br>return GetInterface((IAMovieSetup *) this, ppv); <br>    } else { <br>return CUnknown::NonDelegatingQueryInterface(riid, ppv); <br>    } <br>} <br> <br>#ifdef DEBUG <br>STDMETHODIMP_(ULONG) CBaseFilter::NonDelegatingRelease() <br>{ <br>    if (m_cRef == 1) { <br>        KASSERT(m_pGraph == NULL); <br>    } <br>    return CUnknown::NonDelegatingRelease(); <br>} <br>#endif <br> <br> <br>/* Constructor */ <br> <br>CBaseFilter::CBaseFilter(const TCHAR*pName, <br> LPUNKNOWNpUnk, <br> CCritSec*pLock, <br> REFCLSIDclsid) : <br>    CUnknown( pName, pUnk ), <br>    m_pLock(pLock), <br>    m_clsid(clsid), <br>    m_State(State_Stopped), <br>    m_pClock(NULL), <br>    m_pGraph(NULL), <br>    m_pSink(NULL), <br>    m_pName(NULL), <br>    m_PinVersion(1) <br>{ <br>    ASSERT(pLock != NULL); <br>} <br> <br>/* Passes in a redundant HRESULT argument */ <br> <br>CBaseFilter::CBaseFilter(TCHAR     *pName, <br>                         LPUNKNOWN  pUnk, <br>                         CCritSec  *pLock, <br>                         REFCLSID   clsid, <br>                         HRESULT   *phr) : <br>    CUnknown( pName, pUnk ), <br>    m_pLock(pLock), <br>    m_clsid(clsid), <br>    m_State(State_Stopped), <br>    m_pClock(NULL), <br>    m_pGraph(NULL), <br>    m_pSink(NULL), <br>    m_pName(NULL), <br>    m_PinVersion(1) <br>{ <br>    ASSERT(pLock != NULL); <br>    UNREFERENCED_PARAMETER(phr); <br>} <br> <br> <br>/* Destructor */ <br> <br>CBaseFilter::~CBaseFilter() <br>{ <br>// NOTE we do NOT hold references on the filtergraph for m_pGraph or m_pSink <br>// When we did we had the circular reference problem.  Nothing would go away. <br> <br>    if (m_pName) <br>delete[] m_pName; <br> <br>    // must be stopped, but can't call Stop here since <br>    // our critsec has been destroyed. <br> <br>    /* Release any clock we were using */ <br>    if (m_pClock) { <br>m_pClock-&gt;Release(); <br>m_pClock = NULL; <br>    } <br>} <br> <br>/* Return the filter's clsid */ <br>STDMETHODIMP <br>CBaseFilter::GetClassID(CLSID *pClsID) <br>{ <br>    CheckPointer(pClsID,E_POINTER); <br>    ValidateReadWritePtr(pClsID,sizeof(CLSID)); <br>    *pClsID = m_clsid; <br>    return NOERROR; <br>} <br> <br>/* Override this if your state changes are not done synchronously */ <br>STDMETHODIMP <br>CBaseFilter::GetState(DWORD dwMSecs, FILTER_STATE *State) <br>{ <br>    UNREFERENCED_PARAMETER(dwMSecs); <br>    CheckPointer(State,E_POINTER); <br>    ValidateReadWritePtr(State,sizeof(FILTER_STATE)); <br> <br>    *State = m_State; <br>    return S_OK; <br>} <br> <br> <br>/* Set the clock we will use for synchronisation */ <br> <br>STDMETHODIMP <br>CBaseFilter::SetSyncSource(IReferenceClock *pClock) <br>{ <br>    CAutoLock cObjectLock(m_pLock); <br> <br>    // Ensure the new one does not go away - even if the same as the old <br>    if (pClock) { <br>pClock-&gt;AddRef(); <br>    } <br> <br>    // if we have a clock, release it <br>    if (m_pClock) { <br>m_pClock-&gt;Release(); <br>    } <br> <br>    // Set the new reference clock (might be NULL) <br>    // Should we query it to ensure it is a clock?  Consider for a debug build. <br>    m_pClock = pClock; <br> <br>    return NOERROR; <br>} <br> <br>/* Return the clock we are using for synchronisation */ <br>STDMETHODIMP <br>CBaseFilter::GetSyncSource(IReferenceClock **pClock) <br>{ <br>    CheckPointer(pClock,E_POINTER); <br>    ValidateReadWritePtr(pClock,sizeof(IReferenceClock *)); <br>    CAutoLock cObjectLock(m_pLock); <br> <br>    if (m_pClock) { <br>// returning an interface... addref it... <br>m_pClock-&gt;AddRef(); <br>    } <br>    *pClock = (IReferenceClock*)m_pClock; <br>    return NOERROR; <br>} <br> <br> <br> <br>// override CBaseMediaFilter Stop method, to deactivate any pins this <br>// filter has. <br>STDMETHODIMP <br>CBaseFilter::Stop() <br>{ <br>    CAutoLock cObjectLock(m_pLock); <br>    HRESULT hr = NOERROR; <br> <br>    // notify all pins of the state change <br>    if (m_State != State_Stopped) { <br>int cPins = GetPinCount(); <br>for (int c = 0; c &lt; cPins; c++) { <br> <br>    CBasePin *pPin = GetPin(c); <br> <br>            // Disconnected pins are not activated - this saves pins worrying <br>            // about this state themselves. We ignore the return code to make <br>            // sure everyone is inactivated regardless. The base input pin <br>            // class can return an error if it has no allocator but Stop can <br>            // be used to resync the graph state after something has gone bad <br> <br>            if (pPin-&gt;IsConnected()) { <br>                HRESULT hrTmp = pPin-&gt;Inactive(); <br>                if (FAILED(hrTmp) &amp;&amp; SUCCEEDED(hr)) { <br>                    hr = hrTmp; <br>                } <br>            } <br>} <br>    } <br>    m_State = State_Stopped; <br>    return hr; <br>} <br> <br> <br>// override CBaseMediaFilter Pause method to activate any pins <br>// this filter has (also called from Run) <br> <br>STDMETHODIMP <br>CBaseFilter::Pause() <br>{ <br>    CAutoLock cObjectLock(m_pLock); <br> <br>    // notify all pins of the change to active state <br>    if (m_State == State_Stopped) { <br>int cPins = GetPinCount(); <br>for (int c = 0; c &lt; cPins; c++) { <br> <br>    CBasePin *pPin = GetPin(c); <br> <br>            // Disconnected pins are not activated - this saves pins <br>            // worrying about this state themselves <br> <br>            if (pPin-&gt;IsConnected()) { <br>        HRESULT hr = pPin-&gt;Active(); <br>        if (FAILED(hr)) { <br>    return hr; <br>        } <br>            } <br>} <br>    } <br>    m_State = State_Paused; <br>    return S_OK; <br>} <br> <br>// Put the filter into a running state. <br> <br>// The time parameter is the offset to be added to the samples' <br>// stream time to get the reference time at which they should be presented. <br>// <br>// you can either add these two and compare it against the reference clock, <br>// or you can call CBaseFilter::StreamTime and compare that against <br>// the sample timestamp. <br> <br>STDMETHODIMP <br>CBaseFilter::Run(REFERENCE_TIME tStart) <br>{ <br>    CAutoLock cObjectLock(m_pLock); <br> <br>    // remember the stream time offset <br>    m_tStart = tStart; <br> <br>    if (m_State == State_Stopped){ <br>HRESULT hr = Pause(); <br> <br>if (FAILED(hr)) { <br>    return hr; <br>} <br>    } <br>    // notify all pins of the change to active state <br>    if (m_State != State_Running) { <br>int cPins = GetPinCount(); <br>for (int c = 0; c &lt; cPins; c++) { <br> <br>    CBasePin *pPin = GetPin(c); <br> <br>            // Disconnected pins are not activated - this saves pins <br>            // worrying about this state themselves <br> <br>            if (pPin-&gt;IsConnected()) { <br>        HRESULT hr = pPin-&gt;Run(tStart); <br>        if (FAILED(hr)) { <br>    return hr; <br>        } <br>            } <br>} <br>    } <br>    m_State = State_Running; <br>    return S_OK; <br>} <br> <br>// <br>// return the current stream time - samples with start timestamps of this <br>// time or before should be rendered by now <br>HRESULT <br>CBaseFilter::StreamTime(CRefTime&amp; rtStream) <br>{ <br>    // Caller must lock for synchronization <br>    // We can't grab the filter lock because we want to be able to call <br>    // this from worker threads without deadlocking <br> <br>    if (m_pClock == NULL) { <br>return VFW_E_NO_CLOCK; <br>    } <br> <br>    // get the current reference time <br>    HRESULT hr = m_pClock-&gt;GetTime((REFERENCE_TIME*)&amp;rtStream); <br>    if (FAILED(hr)) { <br>return hr; <br>    } <br> <br>    // subtract the stream offset to get stream time <br>    rtStream -= m_tStart; <br> <br>    return S_OK; <br>} <br> <br> <br>/* Create an enumerator for the pins attached to this filter */ <br> <br>STDMETHODIMP <br>CBaseFilter::EnumPins(IEnumPins **ppEnum) <br>{ <br>    CheckPointer(ppEnum,E_POINTER); <br>    ValidateReadWritePtr(ppEnum,sizeof(IEnumPins *)); <br> <br>    /* Create a new ref counted enumerator */ <br> <br>    *ppEnum = new CEnumPins(this, <br>                    NULL); <br> <br>    return *ppEnum == NULL ? E_OUTOFMEMORY : NOERROR; <br>} <br> <br> <br>// default behaviour of FindPin is to assume pins are named <br>// by their pin names <br>STDMETHODIMP <br>CBaseFilter::FindPin( <br>    LPCWSTR Id, <br>    IPin ** ppPin <br>) <br>{ <br>    CheckPointer(ppPin,E_POINTER); <br>    ValidateReadWritePtr(ppPin,sizeof(IPin *)); <br> <br>    //  We're going to search the pin list so maintain integrity <br>    CAutoLock lck(m_pLock); <br>    int iCount = GetPinCount(); <br>    for (int i = 0; i &lt; iCount; i++) { <br>        CBasePin *pPin = GetPin(i); <br>        ASSERT(pPin != NULL); <br> <br>        if (0 == lstrcmpW(pPin-&gt;Name(), Id)) { <br>            //  Found one that matches <br>            // <br>            //  AddRef() and return it <br>            *ppPin = pPin; <br>            pPin-&gt;AddRef(); <br>            return S_OK; <br>        } <br>    } <br>    *ppPin = NULL; <br>    return VFW_E_NOT_FOUND; <br>} <br> <br>/* Return information about this filter */ <br> <br>STDMETHODIMP <br>CBaseFilter::QueryFilterInfo(FILTER_INFO * pInfo) <br>{ <br>    CheckPointer(pInfo,E_POINTER); <br>    ValidateReadWritePtr(pInfo,sizeof(FILTER_INFO)); <br> <br>    if (m_pName) { <br>    lstrcpynW(pInfo-&gt;achName, m_pName, sizeof(pInfo-&gt;achName)/sizeof(WCHAR)); <br>    } else { <br>pInfo-&gt;achName[0] = L'\0'; <br>    } <br>    pInfo-&gt;pGraph = m_pGraph; <br>    if (m_pGraph) <br>m_pGraph-&gt;AddRef(); <br>    return NOERROR; <br>} <br> <br> <br>/* Provide the filter with a filter graph */ <br> <br>STDMETHODIMP <br>CBaseFilter::JoinFilterGraph( <br>    IFilterGraph * pGraph, <br>    LPCWSTR pName) <br>{ <br>    CAutoLock cObjectLock(m_pLock); <br> <br>    // NOTE: we no longer hold references on the graph (m_pGraph, m_pSink) <br> <br>    m_pGraph = pGraph; <br>    if (m_pGraph) { <br>HRESULT hr = m_pGraph-&gt;QueryInterface(IID_IMediaEventSink, <br>(void**) &amp;m_pSink); <br>if (FAILED(hr)) { <br>    ASSERT(m_pSink == NULL); <br>} <br>        else m_pSink-&gt;Release();        // we do NOT keep a reference on it. <br>    } else { <br>        // if graph pointer is null, then we should <br>        // also release the IMediaEventSink on the same object - we don't <br>        // refcount it, so just set it to null <br>        m_pSink = NULL; <br>    } <br> <br> <br>    if (m_pName) { <br>        delete[] m_pName; <br>m_pName = NULL; <br>    } <br> <br>    if (pName) { <br>DWORD nameLen = lstrlenW(pName)+1; <br>m_pName = new WCHAR[nameLen]; <br>if (m_pName) { <br>    CopyMemory(m_pName, pName, nameLen*sizeof(WCHAR)); <br>} else { <br>    // !!! error here? <br>} <br>    } <br>    return NOERROR; <br>} <br> <br> <br>// return a Vendor information string. Optional - may return E_NOTIMPL. <br>// memory returned should be freed using CoTaskMemFree <br>// default implementation returns E_NOTIMPL <br>STDMETHODIMP <br>CBaseFilter::QueryVendorInfo( <br>    LPWSTR* pVendorInfo) <br>{ <br>    UNREFERENCED_PARAMETER(pVendorInfo); <br>    return E_NOTIMPL; <br>} <br> <br> <br>// send an event notification to the filter graph if we know about it. <br>// returns S_OK if delivered, S_FALSE if the filter graph does not sink <br>// events, or an error otherwise. <br>HRESULT <br>CBaseFilter::NotifyEvent( <br>    long EventCode, <br>    long EventParam1, <br>    long EventParam2) <br>{ <br>    // Snapshot so we don't have to lock up <br>    IMediaEventSink *pSink = m_pSink; <br>    if (pSink) { <br>return pSink-&gt;Notify(EventCode, EventParam1, EventParam2); <br>    } else { <br>return E_NOTIMPL; <br>    } <br>} <br> <br>// Request reconnect <br>// pPin is the pin to reconnect <br>// pmt is the type to reconnect with - can be NULL <br>// Calls ReconnectEx on the filter graph <br>HRESULT <br>CBaseFilter::ReconnectPin( <br>    IPin *pPin, <br>    AM_MEDIA_TYPE const *pmt <br>) <br>{ <br>    IFilterGraph2 *pGraph2; <br>    if (m_pGraph != NULL) { <br>        HRESULT hr = m_pGraph-&gt;QueryInterface(IID_IFilterGraph2, (void **)&amp;pGraph2); <br>        if (SUCCEEDED(hr)) { <br>            hr = pGraph2-&gt;ReconnectEx(pPin, pmt); <br>            pGraph2-&gt;Release(); <br>            return hr; <br>        } else { <br>            return m_pGraph-&gt;Reconnect(pPin); <br>        } <br>    } else { <br>        return E_NOINTERFACE; <br>    } <br>} <br> <br> <br> <br>/* This is the same idea as the media type version does for type enumeration <br>   on pins but for the list of pins available. So if the list of pins you <br>   provide changes dynamically then either override this virtual function <br>   to provide the version number, or more simply call IncrementPinVersion */ <br> <br>LONG CBaseFilter::GetPinVersion() <br>{ <br>    return m_PinVersion; <br>} <br> <br> <br>/* Increment the current pin version cookie */ <br> <br>void CBaseFilter::IncrementPinVersion() <br>{ <br>    InterlockedIncrement(&amp;m_PinVersion); <br>} <br> <br>/* register filter */ <br> <br>STDMETHODIMP CBaseFilter::Register() <br>{ <br>    // get setup data, if it exists <br>    // <br>    LPAMOVIESETUP_FILTER psetupdata = GetSetupData(); <br> <br>    // check we've got data <br>    // <br>    if( NULL == psetupdata ) return S_FALSE; <br> <br>    // init is ref counted so call just in case <br>    // we're being called cold. <br>    // <br>    HRESULT hr = CoInitialize( (LPVOID)NULL ); <br>    ASSERT( SUCCEEDED(hr) ); <br> <br>    // get hold of IFilterMapper <br>    // <br>    IFilterMapper *pIFM; <br>    hr = CoCreateInstance( CLSID_FilterMapper <br>                             , NULL <br>                             , CLSCTX_INPROC_SERVER <br>                             , IID_IFilterMapper <br>                             , (void **)&amp;pIFM       ); <br>    if( SUCCEEDED(hr) ) <br>    { <br>        hr = AMovieSetupRegisterFilter( psetupdata, pIFM, TRUE ); <br>        pIFM-&gt;Release(); <br>    } <br> <br>    // and clear up <br>    // <br>    CoFreeUnusedLibraries(); <br>    CoUninitialize(); <br> <br>    return NOERROR; <br>} <br> <br> <br>/* unregister filter */ <br> <br>STDMETHODIMP CBaseFilter::Unregister() <br>{ <br>    // get setup data, if it exists <br>    // <br>    LPAMOVIESETUP_FILTER psetupdata = GetSetupData(); <br> <br>    // check we've got data <br>    // <br>    if( NULL == psetupdata ) return S_FALSE; <br> <br>    // OLE init is ref counted so call <br>    // just in case we're being called cold. <br>    // <br>    HRESULT hr = CoInitialize( (LPVOID)NULL ); <br>    ASSERT( SUCCEEDED(hr) ); <br> <br>    // get hold of IFilterMapper <br>    // <br>    IFilterMapper *pIFM; <br>    hr = CoCreateInstance( CLSID_FilterMapper <br>                             , NULL <br>                             , CLSCTX_INPROC_SERVER <br>                             , IID_IFilterMapper <br>                             , (void **)&amp;pIFM       ); <br>    if( SUCCEEDED(hr) ) <br>    { <br>        hr = AMovieSetupRegisterFilter( psetupdata, pIFM, FALSE ); <br> <br>        // release interface <br>        // <br>        pIFM-&gt;Release(); <br>    } <br> <br>    // clear up <br>    // <br>    CoFreeUnusedLibraries(); <br>    CoUninitialize(); <br> <br>    // handle one acceptable "error" - that <br>    // of filter not being registered! <br>    // (couldn't find a suitable #define'd <br>    // name for the error!) <br>    // <br>    if( 0x80070002 == hr) <br>      return NOERROR; <br>    else <br>      return hr; <br>} <br> <br> <br>//===================================================================== <br>//===================================================================== <br>// Implements CEnumPins <br>//===================================================================== <br>//===================================================================== <br> <br> <br>/* NOTE The implementation of this class calls the CUnknown constructor <br>   with a NULL unknown pointer. This has the effect of making us a self <br>   contained class, ie any QueryInterface, AddRef or Release calls will be <br>   routed to the class's NonDelegatingUnknown methods. You will typically <br>   find that the classes that do this then override one or more of these <br>   virtual functions to provide more specialised behaviour. A good example <br>   of this is where a class wants to keep the QueryInterface internal but <br>   still wants it's lifetime controlled by the external object */ <br> <br>CEnumPins::CEnumPins(CBaseFilter *pFilter, <br>     CEnumPins *pEnumPins) : <br>    m_Position(0), <br>    m_PinCount(0), <br>    m_pFilter(pFilter), <br>    m_cRef(1),               // Already ref counted <br>    m_PinCache(NAME("Pin Cache")) <br>{ <br> <br>#ifdef DEBUG <br>    m_dwCookie = DbgRegisterObjectCreation(TEXT("CEnumPins")); <br>#endif <br> <br>    /* We must be owned by a filter derived from CBaseFilter */ <br> <br>    ASSERT(pFilter != NULL); <br> <br>    /* Hold a reference count on our filter */ <br>    m_pFilter-&gt;AddRef(); <br> <br>    /* Are we creating a new enumerator */ <br> <br>    if (pEnumPins == NULL) { <br>m_Version = m_pFilter-&gt;GetPinVersion(); <br>m_PinCount = m_pFilter-&gt;GetPinCount(); <br>    } else { <br>        ASSERT(m_Position &lt;= m_PinCount); <br>        m_Position = pEnumPins-&gt;m_Position; <br>        m_PinCount = pEnumPins-&gt;m_PinCount; <br>        m_Version = pEnumPins-&gt;m_Version; <br>m_PinCache.AddTail(&amp;(pEnumPins-&gt;m_PinCache)); <br>    } <br>} <br> <br> <br>/* Destructor releases the reference count on our filter NOTE since we hold <br>   a reference count on the filter who created us we know it is safe to <br>   release it, no access can be made to it afterwards though as we have just <br>   caused the last reference count to go and the object to be deleted */ <br> <br>CEnumPins::~CEnumPins() <br>{ <br>    m_pFilter-&gt;Release(); <br> <br>#ifdef DEBUG <br>    DbgRegisterObjectDestruction(m_dwCookie); <br>#endif <br>} <br> <br> <br>/* Override this to say what interfaces we support where */ <br> <br>STDMETHODIMP <br>CEnumPins::QueryInterface(REFIID riid,void **ppv) <br>{ <br>    CheckPointer(ppv, E_POINTER); <br> <br>    /* Do we have this interface */ <br> <br>    if (riid == IID_IEnumPins || riid == IID_IUnknown) { <br>return GetInterface((IEnumPins *) this, ppv); <br>    } else { <br>return E_NOINTERFACE; <br>    } <br>} <br> <br>STDMETHODIMP_(ULONG) <br>CEnumPins::AddRef() <br>{ <br>    return InterlockedIncrement(&amp;m_cRef); <br>} <br> <br>STDMETHODIMP_(ULONG) <br>CEnumPins::Release() <br>{ <br>    ULONG cRef = InterlockedDecrement(&amp;m_cRef); <br>    if (cRef == 0) { <br>        delete this; <br>    } <br>    return cRef; <br>} <br> <br>/* One of an enumerator's basic member functions allows us to create a cloned <br>   interface that initially has the same state. Since we are taking a snapshot <br>   of an object (current position and all) we must lock access at the start */ <br> <br>STDMETHODIMP <br>CEnumPins::Clone(IEnumPins **ppEnum) <br>{ <br>    CheckPointer(ppEnum,E_POINTER); <br>    ValidateReadWritePtr(ppEnum,sizeof(IEnumPins *)); <br>    HRESULT hr = NOERROR; <br> <br>    /* Check we are still in sync with the filter */ <br>    if (AreWeOutOfSync() == TRUE) { <br>        *ppEnum = NULL; <br>        hr =  VFW_E_ENUM_OUT_OF_SYNC; <br>    } else { <br> <br>        *ppEnum = new CEnumPins(m_pFilter, <br>                            this); <br>        if (*ppEnum == NULL) { <br>        hr = E_OUTOFMEMORY; <br>        } <br>    } <br>    return hr; <br>} <br> <br> <br>/* Return the next pin after the current position */ <br> <br>STDMETHODIMP <br>CEnumPins::Next(ULONG cPins,        // place this many pins... <br>IPin **ppPins,      // ...in this array <br>ULONG *pcFetched)   // actual count passed returned here <br>{ <br>    CheckPointer(ppPins,E_POINTER); <br>    ValidateReadWritePtr(ppPins,cPins * sizeof(IPin *)); <br> <br>    ASSERT(ppPins); <br> <br>    if (pcFetched!=NULL) { <br>        ValidateWritePtr(pcFetched, sizeof(ULONG)); <br>        *pcFetched = 0;           // default unless we succeed <br>    } <br>    // now check that the parameter is valid <br>    else if (cPins&gt;1) {  // pcFetched == NULL <br>        return E_INVALIDARG; <br>    } <br>    ULONG cFetched = 0;           // increment as we get each one. <br> <br>    /* Check we are still in sync with the filter */ <br>    if (AreWeOutOfSync() == TRUE) { <br>// If we are out of sync, we should refresh the enumerator. <br>// This will reset the position and update the other members, but <br>// will not clear cache of pins we have already returned. <br>Refresh(); <br>    } <br> <br>    /* Calculate the number of available pins */ <br> <br>    int cRealPins = min(m_PinCount - m_Position, (int) cPins); <br>    if (cRealPins == 0) { <br>return S_FALSE; <br>    } <br> <br>    /* Return each pin interface NOTE GetPin returns CBasePin * not addrefed <br>       so we must QI for the IPin (which increments its reference count) <br>       If while we are retrieving a pin from the filter an error occurs we <br>       assume that our internal state is stale with respect to the filter <br>       (for example someone has deleted a pin) so we <br>       return VFW_E_ENUM_OUT_OF_SYNC                            */ <br> <br>    while (cRealPins &amp;&amp; (m_PinCount - m_Position)) { <br> <br>/* Get the next pin object from the filter */ <br> <br>CBasePin *pPin = m_pFilter-&gt;GetPin(m_Position++); <br>if (pPin == NULL) { <br>            // If this happend, and it's not the first time through, then we've got a problem, <br>            // since we should really go back and release the iPins, which we have previously <br>            // AddRef'ed. <br>            ASSERT( cFetched==0 ); <br>            return VFW_E_ENUM_OUT_OF_SYNC; <br>} <br> <br>/* We only want to return this pin, if it is not in our cache */ <br>if (0 == m_PinCache.Find(pPin)) <br>{ <br>    /* From the object get an IPin interface */ <br> <br>    *ppPins = pPin; <br>    pPin-&gt;AddRef(); <br> <br>    cFetched++; <br>    ppPins++; <br> <br>    m_PinCache.AddTail(pPin); <br> <br>    cRealPins--; <br> <br>} <br>    } <br> <br>    if (pcFetched!=NULL) { </code></pre>
<p>
</p>
<pre><code>*pcFetched = cFetched; <br>    } <br> <br>    return (cPins==cFetched ? NOERROR : S_FALSE); <br>} <br> <br> <br>/* Skip over one or more entries in the enumerator */ <br> <br>STDMETHODIMP <br>CEnumPins::Skip(ULONG cPins) <br>{ <br>    /* Check we are still in sync with the filter */ <br>    if (AreWeOutOfSync() == TRUE) { <br>        return VFW_E_ENUM_OUT_OF_SYNC; <br>    } <br> <br>    /* Work out how many pins are left to skip over */ <br>    /* We could position at the end if we are asked to skip too many... */ <br>    /* ..which would match the base implementation for CEnumMediaTypes::Skip */ <br> <br>    ULONG PinsLeft = m_PinCount - m_Position; <br>    if (cPins &gt; PinsLeft) { <br>return S_FALSE; <br>    } <br>    m_Position += cPins; <br>    return NOERROR; <br>} <br> <br> <br>/* Set the current position back to the start */ <br>/* Reset has 4 simple steps: <br> * <br> * Set position to head of list <br> * Sync enumerator with object being enumerated <br> * Clear the cache of pins already returned <br> * return S_OK <br> */ <br> <br>STDMETHODIMP <br>CEnumPins::Reset() <br>{ <br>    m_Version = m_pFilter-&gt;GetPinVersion(); <br>    m_PinCount = m_pFilter-&gt;GetPinCount(); <br> <br>    m_Position = 0; <br> <br>    // Clear the cache <br>    m_PinCache.RemoveAll(); <br> <br>    return S_OK; <br>} <br> <br> <br>/* Set the current position back to the start */ <br>/* Refresh has 3 simple steps: <br> * <br> * Set position to head of list <br> * Sync enumerator with object being enumerated <br> * return S_OK <br> */ <br> <br>STDMETHODIMP <br>CEnumPins::Refresh() <br>{ <br>    m_Version = m_pFilter-&gt;GetPinVersion(); <br>    m_PinCount = m_pFilter-&gt;GetPinCount(); <br> <br>    m_Position = 0; <br>    return S_OK; <br>} <br> <br> <br>//===================================================================== <br>//===================================================================== <br>// Implements CEnumMediaTypes <br>//===================================================================== <br>//===================================================================== <br> <br> <br>/* NOTE The implementation of this class calls the CUnknown constructor <br>   with a NULL unknown pointer. This has the effect of making us a self <br>   contained class, ie any QueryInterface, AddRef or Release calls will be <br>   routed to the class's NonDelegatingUnknown methods. You will typically <br>   find that the classes that do this then override one or more of these <br>   virtual functions to provide more specialised behaviour. A good example <br>   of this is where a class wants to keep the QueryInterface internal but <br>   still wants it's lifetime controlled by the external object */ <br> <br>CEnumMediaTypes::CEnumMediaTypes(CBasePin *pPin, <br> CEnumMediaTypes *pEnumMediaTypes) : <br>    m_Position(0), <br>    m_pPin(pPin), <br>    m_cRef(1) <br>{ <br> <br>#ifdef DEBUG <br>    m_dwCookie = DbgRegisterObjectCreation(TEXT("CEnumMediaTypes")); <br>#endif <br> <br>    /* We must be owned by a pin derived from CBasePin */ <br> <br>    ASSERT(pPin != NULL); <br> <br>    /* Hold a reference count on our pin */ <br>    m_pPin-&gt;AddRef(); <br> <br>    /* Are we creating a new enumerator */ <br> <br>    if (pEnumMediaTypes == NULL) { <br>m_Version = m_pPin-&gt;GetMediaTypeVersion(); <br>return; <br>    } <br> <br>    m_Position = pEnumMediaTypes-&gt;m_Position; <br>    m_Version = pEnumMediaTypes-&gt;m_Version; <br>} <br> <br> <br>/* Destructor releases the reference count on our base pin. NOTE since we hold <br>   a reference count on the pin who created us we know it is safe to release <br>   it, no access can be made to it afterwards though as we might have just <br>   caused the last reference count to go and the object to be deleted */ <br> <br>CEnumMediaTypes::~CEnumMediaTypes() <br>{ <br>#ifdef DEBUG <br>    DbgRegisterObjectDestruction(m_dwCookie); <br>#endif <br>    m_pPin-&gt;Release(); <br>} <br> <br> <br>/* Override this to say what interfaces we support where */ <br> <br>STDMETHODIMP <br>CEnumMediaTypes::QueryInterface(REFIID riid,void **ppv) <br>{ <br>    CheckPointer(ppv, E_POINTER); <br> <br>    /* Do we have this interface */ <br> <br>    if (riid == IID_IEnumMediaTypes || riid == IID_IUnknown) { <br>return GetInterface((IEnumMediaTypes *) this, ppv); <br>    } else { <br>        return E_NOINTERFACE; <br>    } <br>} <br> <br>STDMETHODIMP_(ULONG) <br>CEnumMediaTypes::AddRef() <br>{ <br>    return InterlockedIncrement(&amp;m_cRef); <br>} <br> <br>STDMETHODIMP_(ULONG) <br>CEnumMediaTypes::Release() <br>{ <br>    ULONG cRef = InterlockedDecrement(&amp;m_cRef); <br>    if (cRef == 0) { <br>        delete this; <br>    } <br>    return cRef; <br>} <br> <br>/* One of an enumerator's basic member functions allows us to create a cloned <br>   interface that initially has the same state. Since we are taking a snapshot <br>   of an object (current position and all) we must lock access at the start */ <br> <br>STDMETHODIMP <br>CEnumMediaTypes::Clone(IEnumMediaTypes **ppEnum) <br>{ <br>    CheckPointer(ppEnum,E_POINTER); <br>    ValidateReadWritePtr(ppEnum,sizeof(IEnumMediaTypes *)); <br>    HRESULT hr = NOERROR; <br> <br>    /* Check we are still in sync with the pin */ <br>    if (AreWeOutOfSync() == TRUE) { <br>        *ppEnum = NULL; <br>        hr = VFW_E_ENUM_OUT_OF_SYNC; <br>    } else { <br> <br>        *ppEnum = new CEnumMediaTypes(m_pPin, <br>                                  this); <br> <br>        if (*ppEnum == NULL) { <br>        hr =  E_OUTOFMEMORY; <br>        } <br>    } <br>    return hr; <br>} <br> <br> <br>/* Enumerate the next pin(s) after the current position. The client using this <br>   interface passes in a pointer to an array of pointers each of which will <br>   be filled in with a pointer to a fully initialised media type format <br>   Return NOERROR if it all works, <br>          S_FALSE if fewer than cMediaTypes were enumerated. <br>          VFW_E_ENUM_OUT_OF_SYNC if the enumerator has been broken by <br>                                 state changes in the filter <br>   The actual count always correctly reflects the number of types in the array. <br>*/ <br> <br>STDMETHODIMP <br>CEnumMediaTypes::Next(ULONG cMediaTypes,          // place this many types... <br>      AM_MEDIA_TYPE **ppMediaTypes,   // ...in this array <br>      ULONG *pcFetched)           // actual count passed <br>{ <br>    CheckPointer(ppMediaTypes,E_POINTER); <br>    ValidateReadWritePtr(ppMediaTypes,cMediaTypes * sizeof(AM_MEDIA_TYPE *)); <br>    /* Check we are still in sync with the pin */ <br>    if (AreWeOutOfSync() == TRUE) { <br>        return VFW_E_ENUM_OUT_OF_SYNC; <br>    } <br> <br>    if (pcFetched!=NULL) { <br>        ValidateWritePtr(pcFetched, sizeof(ULONG)); <br>        *pcFetched = 0;           // default unless we succeed <br>    } <br>    // now check that the parameter is valid <br>    else if (cMediaTypes&gt;1) {  // pcFetched == NULL <br>        return E_INVALIDARG; <br>    } <br>    ULONG cFetched = 0;           // increment as we get each one. <br> <br>    /* Return each media type by asking the filter for them in turn - If we <br>       have an error code retured to us while we are retrieving a media type <br>       we assume that our internal state is stale with respect to the filter <br>       (for example the window size changing) so we return <br>       VFW_E_ENUM_OUT_OF_SYNC */ <br> <br>    while (cMediaTypes) { <br> <br>    CMediaType cmt; <br> <br>HRESULT hr = m_pPin-&gt;GetMediaType(m_Position++, &amp;cmt); <br>        if (S_OK != hr) { <br>            break; <br>        } <br> <br>    /* We now have a CMediaType object that contains the next media type <br>       but when we assign it to the array position we CANNOT just assign <br>       the AM_MEDIA_TYPE structure because as soon as the object goes out of <br>       scope it will delete the memory we have just copied. The function <br>       we use is CreateMediaType which allocates a task memory block */ <br> <br>        /*  Transfer across the format block manually to save an allocate <br>            and free on the format block and generally go faster */ <br> <br>    *ppMediaTypes = (AM_MEDIA_TYPE *)CoTaskMemAlloc(sizeof(AM_MEDIA_TYPE)); <br>    if (*ppMediaTypes == NULL) { <br>            break; <br>    } <br> <br>        /*  Do a regular copy */ <br>        **ppMediaTypes = (AM_MEDIA_TYPE)cmt; <br> <br>        /*  Make sure the destructor doesn't free these */ <br>        cmt.pbFormat = NULL; <br>        cmt.cbFormat = NULL; <br>        cmt.pUnk     = NULL; <br> <br> <br>    ppMediaTypes++; <br>    cFetched++; <br>    cMediaTypes--; <br>    } <br> <br>    if (pcFetched!=NULL) { <br>        *pcFetched = cFetched; <br>    } <br> <br>    return ( cMediaTypes==0 ? NOERROR : S_FALSE ); <br>} <br> <br> <br>/* Skip over one or more entries in the enumerator */ <br> <br>STDMETHODIMP <br>CEnumMediaTypes::Skip(ULONG cMediaTypes) <br>{ <br>    /* Check we are still in sync with the pin */ <br>    if (AreWeOutOfSync() == TRUE) { <br>        return VFW_E_ENUM_OUT_OF_SYNC; <br>    } <br> <br>    m_Position += cMediaTypes; <br> <br>    /*  See if we're over the end */ <br>    CMediaType cmt; <br>    return S_OK == m_pPin-&gt;GetMediaType(m_Position - 1, &amp;cmt) ? S_OK : S_FALSE; <br>} <br> <br> <br>/* Set the current position back to the start */ <br>/* Reset has 3 simple steps: <br> * <br> * set position to head of list <br> * sync enumerator with object being enumerated <br> * return S_OK <br> */ <br> <br>STDMETHODIMP <br>CEnumMediaTypes::Reset() <br>{ <br>    m_Position = 0; <br> <br>    // Bring the enumerator back into step with the current state.  This <br>    // may be a noop but ensures that the enumerator will be valid on the <br>    // next call. <br>    m_Version = m_pPin-&gt;GetMediaTypeVersion(); <br>    return NOERROR; <br>} <br> <br> <br>//===================================================================== <br>//===================================================================== <br>// Implements CBasePin <br>//===================================================================== <br>//===================================================================== <br> <br> <br>/* NOTE The implementation of this class calls the CUnknown constructor with <br>   a NULL outer unknown pointer. This has the effect of making us a self <br>   contained class, ie any QueryInterface, AddRef or Release calls will be <br>   routed to the class's NonDelegatingUnknown methods. You will typically <br>   find that the classes that do this then override one or more of these <br>   virtual functions to provide more specialised behaviour. A good example <br>   of this is where a class wants to keep the QueryInterface internal but <br>   still wants its lifetime controlled by the external object */ <br> <br>/* Constructor */ <br> <br>CBasePin::CBasePin(TCHAR *pObjectName, <br>   CBaseFilter *pFilter, <br>   CCritSec *pLock, <br>   HRESULT *phr, <br>   LPCWSTR pName, <br>   PIN_DIRECTION dir) : <br>    CUnknown( pObjectName, NULL ), <br>    m_pFilter(pFilter), <br>    m_pLock(pLock), <br>    m_pName(NULL), <br>    m_Connected(NULL), <br>    m_dir(dir), <br>    m_bRunTimeError(FALSE), <br>    m_pQSink(NULL), <br>    m_TypeVersion(1), <br>    m_tStart(), <br>    m_tStop(MAX_TIME), <br>    m_dRate(1.0) <br>{ <br>    /*  WARNING - pFilter is often not a properly constituted object at <br>        this state (in particular QueryInterface may not work) - this <br>        is because its owner is often its containing object and we <br>        have been called from the containing object's constructor so <br>        the filter's owner has not yet had its CUnknown constructor <br>        called <br>    */ <br>    ASSERT(pFilter != NULL); <br>    ASSERT(pLock != NULL); <br> <br>    if (pName) { <br>DWORD nameLen = lstrlenW(pName)+1; <br>m_pName = new WCHAR[nameLen]; <br>if (m_pName) { <br>    CopyMemory(m_pName, pName, nameLen*sizeof(WCHAR)); <br>} <br>    } <br> <br>#ifdef DEBUG <br>    m_cRef = 0; <br>#endif <br>} <br> <br> <br>/* Destructor since a connected pin holds a reference count on us there is <br>   no way that we can be deleted unless we are not currently connected */ <br> <br>CBasePin::~CBasePin() <br>{ <br>    //  We don't call disconnect because if the filter is going away <br>    //  all the pins must have a reference count of zero so they must <br>    //  have been disconnected anyway - (but check the assumption) <br>    ASSERT(m_Connected == FALSE); <br> <br>    if (m_pName) <br>delete[] m_pName; <br> <br>    // check the internal reference count is consistent <br>    ASSERT(m_cRef == 0); <br>} <br> <br> <br>/* Override this to say what interfaces we support and where */ <br> <br>STDMETHODIMP <br>CBasePin::NonDelegatingQueryInterface(REFIID riid, void ** ppv) <br>{ <br>    /* Do we have this interface */ <br> <br>    if (riid == IID_IPin) { <br>return GetInterface((IPin *) this, ppv); <br>    } else if (riid == IID_IQualityControl) { <br>        return GetInterface((IQualityControl *) this, ppv); <br>    } else { <br>return CUnknown::NonDelegatingQueryInterface(riid, ppv); <br>    } <br>} <br> <br> <br>/* Override to increment the owning filter's reference count */ <br> <br>STDMETHODIMP_(ULONG) <br>CBasePin::NonDelegatingAddRef() <br>{ <br>    ASSERT(InterlockedIncrement(&amp;m_cRef) &gt; 0); <br>    return m_pFilter-&gt;AddRef(); <br>} <br> <br> <br>/* Override to decrement the owning filter's reference count */ <br> <br>STDMETHODIMP_(ULONG) <br>CBasePin::NonDelegatingRelease() <br>{ <br>    ASSERT(InterlockedDecrement(&amp;m_cRef) &gt;= 0); <br>    return m_pFilter-&gt;Release(); <br>} <br> <br> <br>/* Displays pin connection information */ <br> <br>#ifdef DEBUG <br>void <br>CBasePin::DisplayPinInfo(IPin *pReceivePin) <br>{ <br> <br>    if (DbgCheckModuleLevel(LOG_TRACE, CONNECT_TRACE_LEVEL)) { <br>PIN_INFO ConnectPinInfo; <br>PIN_INFO ReceivePinInfo; <br> <br>if (FAILED(QueryPinInfo(&amp;ConnectPinInfo))) { <br>    lstrcpyW(ConnectPinInfo.achName, L"Bad Pin"); <br>} else { <br>    QueryPinInfoReleaseFilter(ConnectPinInfo); <br>} <br> <br>if (FAILED(pReceivePin-&gt;QueryPinInfo(&amp;ReceivePinInfo))) { <br>    lstrcpyW(ReceivePinInfo.achName, L"Bad Pin"); <br>} else { <br>    QueryPinInfoReleaseFilter(ReceivePinInfo); <br>} <br> <br>DbgLog((LOG_TRACE, CONNECT_TRACE_LEVEL, TEXT("Trying to connect Pins :"))); <br>DbgLog((LOG_TRACE, CONNECT_TRACE_LEVEL, TEXT("    &lt;%ls&gt;"), ConnectPinInfo.achName)); <br>DbgLog((LOG_TRACE, CONNECT_TRACE_LEVEL, TEXT("    &lt;%ls&gt;"), ReceivePinInfo.achName)); <br>    } <br>} <br>#endif <br> <br> <br>/* Displays general information on the pin media type */ <br> <br>#ifdef DEBUG <br>void CBasePin::DisplayTypeInfo(IPin *pPin, const CMediaType *pmt) <br>{ <br>    UNREFERENCED_PARAMETER(pPin); <br>    if (DbgCheckModuleLevel(LOG_TRACE, CONNECT_TRACE_LEVEL)) { <br>DbgLog((LOG_TRACE, CONNECT_TRACE_LEVEL, TEXT("Trying media type:"))); <br>DbgLog((LOG_TRACE, CONNECT_TRACE_LEVEL, TEXT("    major type:  %s"), <br>       GuidNames[*pmt-&gt;Type()])); <br>DbgLog((LOG_TRACE, CONNECT_TRACE_LEVEL, TEXT("    sub type  :  %s"), <br>       GuidNames[*pmt-&gt;Subtype()])); <br>    } <br>} <br>#endif <br> <br>/* Asked to connect to a pin. A pin is always attached to an owning filter <br>   object so we always delegate our locking to that object. We first of all <br>   retrieve a media type enumerator for the input pin and see if we accept <br>   any of the formats that it would ideally like, failing that we retrieve <br>   our enumerator and see if it will accept any of our preferred types */ <br> <br>STDMETHODIMP <br>CBasePin::Connect( <br>    IPin * pReceivePin, <br>    const AM_MEDIA_TYPE *pmt   // optional media type <br>) <br>{ <br>    CheckPointer(pReceivePin,E_POINTER); <br>    ValidateReadPtr(pReceivePin,sizeof(IPin)); <br>    CAutoLock cObjectLock(m_pLock); <br>    DisplayPinInfo(pReceivePin); <br> <br>    /* See if we are already connected */ <br> <br>    if (m_Connected) { <br>DbgLog((LOG_TRACE, CONNECT_TRACE_LEVEL, TEXT("Already connected"))); <br>return VFW_E_ALREADY_CONNECTED; <br>    } <br> <br>    /* See if the filter is active */ <br>    if (!IsStopped()) { <br>        return VFW_E_NOT_STOPPED; <br>    } <br> <br> <br>    // Find a mutually agreeable media type - <br>    // Pass in the template media type. If this is partially specified, <br>    // each of the enumerated media types will need to be checked against <br>    // it. If it is non-null and fully specified, we will just try to connect <br>    // with this. <br> <br>    const CMediaType * ptype = (CMediaType*)pmt; <br>    HRESULT hr = AgreeMediaType(pReceivePin, ptype); <br>    if (FAILED(hr)) { <br>DbgLog((LOG_TRACE, CONNECT_TRACE_LEVEL, TEXT("Failed to agree type"))); <br>BreakConnect(); <br>return hr; <br>    } <br> <br>    DbgLog((LOG_TRACE, CONNECT_TRACE_LEVEL, TEXT("Connection succeeded"))); <br>    return NOERROR; <br>} <br> <br>// given a specific media type, attempt a connection (includes <br>// checking that the type is acceptable to this pin) <br>HRESULT <br>CBasePin::AttemptConnection( <br>    IPin* pReceivePin,      // connect to this pin <br>    const CMediaType* pmt   // using this type <br>) <br>{ <br>    // Check that the connection is valid  -- need to do this for every <br>    // connect attempt since BreakConnect will undo it. <br>    HRESULT hr = CheckConnect(pReceivePin); <br>    if (FAILED(hr)) { <br>DbgLog((LOG_TRACE, CONNECT_TRACE_LEVEL, TEXT("CheckConnect failed"))); <br>BreakConnect(); <br>return hr; <br>    } <br> <br>    DisplayTypeInfo(pReceivePin, pmt); <br> <br>    /* Check we will accept this media type */ <br> <br>    hr = CheckMediaType(pmt); <br>    if (hr == NOERROR) { <br> <br>        /*  Make ourselves look connected otherwise ReceiveConnection <br>            may not be able to complete the connection <br>        */ <br>        m_Connected = pReceivePin; <br>        m_Connected-&gt;AddRef(); <br>        SetMediaType(pmt); <br> <br>        /* See if the other pin will accept this type */ <br> <br>        hr = pReceivePin-&gt;ReceiveConnection((IPin *)this, pmt); <br>        if (SUCCEEDED(hr)) { <br>            /* Complete the connection */ <br> <br>            hr = CompleteConnect(pReceivePin); <br>            if (SUCCEEDED(hr)) { <br>                return hr; <br>            } else { <br>                DbgLog((LOG_TRACE, <br>                        CONNECT_TRACE_LEVEL, <br>                        TEXT("Failed to complete connection"))); <br>                pReceivePin-&gt;Disconnect(); <br>            } <br>        } <br>    } else { <br>// we cannot use this media type <br> <br>// return a specific media type error if there is one <br>// or map a general failure code to something more helpful <br>// (in particular S_FALSE gets changed to an error code) <br>if (SUCCEEDED(hr) || <br>    (hr == E_FAIL) || <br>    (hr == E_INVALIDARG)) { <br>hr = VFW_E_TYPE_NOT_ACCEPTED; <br>} <br>    } <br> <br>    // BreakConnect and release any connection here in case CheckMediaType <br>    // failed, or if we set anything up during a call back during <br>    // ReceiveConnection. <br>    BreakConnect(); <br> <br>    /*  If failed then undo our state */ <br>    if (m_Connected) { <br>        m_Connected-&gt;Release(); <br>        m_Connected = NULL; <br>    } <br> <br>    return hr; <br>} <br> <br>/* Given an enumerator we cycle through all the media types it proposes and <br>   firstly suggest them to our derived pin class and if that succeeds try <br>   them with the pin in a ReceiveConnection call. This means that if our pin <br>   proposes a media type we still check in here that we can support it. This <br>   is deliberate so that in simple cases the enumerator can hold all of the <br>   media types even if some of them are not really currently available */ <br> <br>HRESULT CBasePin::TryMediaTypes( <br>    IPin *pReceivePin, <br>    const CMediaType *pmt, <br>    IEnumMediaTypes *pEnum) <br>{ <br>    /* Reset the current enumerator position */ <br> <br>    HRESULT hr = pEnum-&gt;Reset(); <br>    if (FAILED(hr)) { <br>return hr; <br>    } <br> <br>    CMediaType *pMediaType = NULL; <br>    ULONG ulMediaCount = 0; <br> <br>    // attempt to remember a specific error code if there is one <br>    HRESULT hrFailure = S_OK; <br> <br>    for (;;) { <br> <br>/* Retrieve the next media type NOTE each time round the loop the <br>   enumerator interface will allocate another AM_MEDIA_TYPE structure <br>   If we are successful then we copy it into our output object, if <br>   not then we must delete the memory allocated before returning */ <br> <br>hr = pEnum-&gt;Next(1, (AM_MEDIA_TYPE**)&amp;pMediaType,&amp;ulMediaCount); <br>if (hr != S_OK) { <br>    if (S_OK == hrFailure) { <br>hrFailure = VFW_E_NO_ACCEPTABLE_TYPES; <br>    } <br>    return hrFailure; <br>} <br> <br> <br>ASSERT(ulMediaCount == 1); <br>ASSERT(pMediaType); <br> <br>        // check that this matches the partial type (if any) <br> <br>        if ((pmt == NULL) || <br>            pMediaType-&gt;MatchesPartial(pmt)) { <br> <br>            hr = AttemptConnection(pReceivePin, pMediaType); <br> <br>    // attempt to remember a specific error code <br>    if (FAILED(hr) &amp;&amp; <br>SUCCEEDED(hrFailure) &amp;&amp; <br>(hr != E_FAIL) &amp;&amp; <br>(hr != E_INVALIDARG) &amp;&amp; <br>(hr != VFW_E_TYPE_NOT_ACCEPTED)) { <br>    hrFailure = hr; <br>    } <br>        } else { <br>            hr = VFW_E_NO_ACCEPTABLE_TYPES; <br>        } <br> <br>        DeleteMediaType(pMediaType); <br> <br>        if (S_OK == hr) { <br>            return hr; <br>        } <br>    } <br>} <br> <br> <br>/* This is called to make the connection, including the taask of finding <br>   a media type for the pin connection. pmt is the proposed media type <br>   from the Connect call: if this is fully specified, we will try that. <br>   Otherwise we enumerate and try all the input pin's types first and <br>   if that fails we then enumerate and try all our preferred media types. <br>   For each media type we check it against pmt (if non-null and partially <br>   specified) as well as checking that both pins will accept it. <br> */ <br> <br>HRESULT CBasePin::AgreeMediaType( <br>    IPin *pReceivePin, <br>    const CMediaType *pmt) <br>{ <br>    ASSERT(pReceivePin); <br>    IEnumMediaTypes *pEnumMediaTypes = NULL; <br> <br>    // if the media type is fully specified then use that <br>    if ( (pmt != NULL) &amp;&amp; (!pmt-&gt;IsPartiallySpecified())) { <br> <br>        // if this media type fails, then we must fail the connection <br>        // since if pmt is nonnull we are only allowed to connect <br>        // using a type that matches it. <br> <br>        return AttemptConnection(pReceivePin, pmt); <br>    } <br> <br> <br>    /* Try the other pin's enumerator */ <br> <br>    HRESULT hrFailure = VFW_E_NO_ACCEPTABLE_TYPES; <br> <br>    HRESULT hr = pReceivePin-&gt;EnumMediaTypes(&amp;pEnumMediaTypes); <br>    if (SUCCEEDED(hr)) { <br>ASSERT(pEnumMediaTypes); <br>hr = TryMediaTypes(pReceivePin,pmt,pEnumMediaTypes); <br>pEnumMediaTypes-&gt;Release(); <br>if (SUCCEEDED(hr)) { <br>    return NOERROR; <br>} else { <br>    // try to remember specific error codes if there are any <br>    if ((hr != E_FAIL) &amp;&amp; <br>(hr != E_INVALIDARG) &amp;&amp; <br>(hr != VFW_E_TYPE_NOT_ACCEPTED)) { <br>    hrFailure = hr; <br>    } <br>} <br>    } <br> <br>    /* Having failed with that try our enumerator */ <br> <br>    hr = EnumMediaTypes(&amp;pEnumMediaTypes); <br>    if (SUCCEEDED(hr)) { <br>ASSERT(pEnumMediaTypes); <br>hr = TryMediaTypes(pReceivePin,pmt,pEnumMediaTypes); <br>pEnumMediaTypes-&gt;Release(); <br>if (SUCCEEDED(hr)) { <br>    return NOERROR; <br>} else { <br>    // try to remember specific error codes if there are any <br>    if ((hr != E_FAIL) &amp;&amp; <br>(hr != E_INVALIDARG) &amp;&amp; <br>(hr != VFW_E_TYPE_NOT_ACCEPTED)) { <br>    hrFailure = hr; <br>    } <br>} <br>    } <br>    return hrFailure; <br>} <br> <br> <br>/* Called when we want to complete a connection to another filter. Failing <br>   this will also fail the connection and disconnect the other pin as well */ <br> <br>HRESULT <br>CBasePin::CompleteConnect(IPin *pReceivePin) <br>{ <br>    UNREFERENCED_PARAMETER(pReceivePin); <br>    return NOERROR; <br>} <br> <br> <br>/* This is called to set the format for a pin connection - CheckMediaType <br>   will have been called to check the connection format and if it didn't <br>   return an error code then this (virtual) function will be invoked */ <br> <br>HRESULT <br>CBasePin::SetMediaType(const CMediaType *pmt) <br>{ <br>    m_mt = *pmt; <br>    return NOERROR; <br>} <br> <br> <br>/* This is called during Connect() to provide a virtual method that can do <br>   any specific check needed for connection such as QueryInterface. This <br>   base class method just checks that the pin directions don't match */ <br> <br>HRESULT <br>CBasePin::CheckConnect(IPin * pPin) <br>{ <br>    /* Check that pin directions DONT match */ <br> <br>    PIN_DIRECTION pd; <br>    pPin-&gt;QueryDirection(&amp;pd); <br> <br>    ASSERT((pd == PINDIR_OUTPUT) || (pd == PINDIR_INPUT)); <br>    ASSERT((m_dir == PINDIR_OUTPUT) || (m_dir == PINDIR_INPUT)); <br> <br>    // we should allow for non-input and non-output connections? <br>    if (pd == m_dir) { <br>return VFW_E_INVALID_DIRECTION; <br>    } <br>    return NOERROR; <br>} <br> <br> <br>/* This is called when we realise we can't make a connection to the pin and <br>   must undo anything we did in CheckConnect - override to release QIs done */ <br> <br>HRESULT <br>CBasePin::BreakConnect() <br>{ <br>    return NOERROR; <br>} <br> <br> <br>/* Called normally by an output pin on an input pin to try and establish a <br>   connection. <br>*/ <br> <br>STDMETHODIMP <br>CBasePin::ReceiveConnection( <br>    IPin * pConnector,      // this is the pin who we will connect to <br>    const AM_MEDIA_TYPE *pmt    // this is the media type we will exchange <br>) <br>{ <br>    CheckPointer(pConnector,E_POINTER); <br>    CheckPointer(pmt,E_POINTER); <br>    ValidateReadPtr(pConnector,sizeof(IPin)); <br>    ValidateReadPtr(pmt,sizeof(AM_MEDIA_TYPE)); <br>    CAutoLock cObjectLock(m_pLock); <br> <br>    /* Are we already connected */ <br>    if (m_Connected) { <br>return VFW_E_ALREADY_CONNECTED; <br>    } <br> <br>    /* See if the filter is active */ <br>    if (!IsStopped()) { <br>        return VFW_E_NOT_STOPPED; <br>    } <br> <br>    HRESULT hr = CheckConnect(pConnector); <br>    if (FAILED(hr)) { <br>BreakConnect(); <br>return hr; <br>    } <br> <br>    /* Ask derived class if this media type is ok */ <br> <br>    CMediaType * pcmt = (CMediaType*) pmt; <br>    hr = CheckMediaType(pcmt); <br>    if (hr != NOERROR) { <br>// no -we don't support this media type <br>BreakConnect(); <br> <br>// return a specific media type error if there is one <br>// or map a general failure code to something more helpful <br>// (in particular S_FALSE gets changed to an error code) <br>if (SUCCEEDED(hr) || <br>    (hr == E_FAIL) || <br>    (hr == E_INVALIDARG)) { <br>hr = VFW_E_TYPE_NOT_ACCEPTED; <br>} <br>return hr; <br>    } <br> <br>    /* Complete the connection */ <br> <br>    m_Connected = pConnector; <br>    m_Connected-&gt;AddRef(); <br>    SetMediaType(pcmt); <br> <br>    hr = CompleteConnect(pConnector); <br>    if (FAILED(hr)) { <br>        DbgLog((LOG_TRACE, CONNECT_TRACE_LEVEL, TEXT("Failed to complete connection"))); <br>        m_Connected-&gt;Release(); <br>        m_Connected = NULL; <br>        BreakConnect(); <br>        return hr; <br>    } <br>    return NOERROR; <br>} <br> <br> <br>/* Called when we want to terminate a pin connection */ <br> <br>STDMETHODIMP <br>CBasePin::Disconnect() <br>{ <br>    CAutoLock cObjectLock(m_pLock); <br> <br>    /* See if the filter is active */ <br>    if (!IsStopped()) { <br>        return VFW_E_NOT_STOPPED; <br>    } <br> <br>    if (m_Connected) { <br>BreakConnect(); <br>m_Connected-&gt;Release(); <br>m_Connected = NULL; <br>return S_OK; <br>    } else { <br>// no connection - not an error <br>return S_FALSE; <br>    } <br>} <br> <br> <br>/* Return an AddRef()'d pointer to the connected pin if there is one */ <br>STDMETHODIMP <br>CBasePin::ConnectedTo( <br>    IPin **ppPin <br>) <br>{ <br>    CheckPointer(ppPin,E_POINTER); <br>    ValidateReadWritePtr(ppPin,sizeof(IPin *)); <br>    // <br>    //  It's pointless to lock here. <br>    //  The caller should ensure integrity. <br>    // <br> <br>    IPin *pPin = m_Connected; <br>    *ppPin = pPin; <br>    if (pPin != NULL) { <br>        pPin-&gt;AddRef(); <br>        return S_OK; <br>    } else { <br>        ASSERT(*ppPin == NULL); <br>        return VFW_E_NOT_CONNECTED; <br>    } <br>} <br> <br>/* Return the media type of the connection */ <br>STDMETHODIMP <br>CBasePin::ConnectionMediaType( <br>    AM_MEDIA_TYPE *pmt <br>) <br>{ <br>    CheckPointer(pmt,E_POINTER); <br>    ValidateReadWritePtr(pmt,sizeof(AM_MEDIA_TYPE)); <br>    CAutoLock cObjectLock(m_pLock); <br> <br>    /*  Copy constructor of m_mt allocates the memory */ <br>    if (IsConnected()) { <br>        CopyMediaType( pmt, &amp;m_mt ); <br>        return S_OK; <br>    } else { <br>        ((CMediaType *)pmt)-&gt;InitMediaType(); <br>        return VFW_E_NOT_CONNECTED; <br>    } <br>} <br> <br>/* Return information about the filter we are connect to */ <br> <br>STDMETHODIMP <br>CBasePin::QueryPinInfo( <br>    PIN_INFO * pInfo <br>) <br>{ <br>    CheckPointer(pInfo,E_POINTER); <br>    ValidateReadWritePtr(pInfo,sizeof(PIN_INFO)); <br> <br>    pInfo-&gt;pFilter = m_pFilter; <br>    if (m_pFilter) { <br>m_pFilter-&gt;AddRef(); <br>    } <br> <br>    if (m_pName) { <br>lstrcpyW(pInfo-&gt;achName, m_pName); <br>    } else { <br>pInfo-&gt;achName[0] = L'\0'; <br>    } <br> <br>    pInfo-&gt;dir = m_dir; <br> <br>    return NOERROR; <br>} <br> <br>STDMETHODIMP <br>CBasePin::QueryDirection( <br>    PIN_DIRECTION * pPinDir <br>) <br>{ <br>    CheckPointer(pPinDir,E_POINTER); <br>    ValidateReadWritePtr(pPinDir,sizeof(PIN_DIRECTION)); <br> <br>    *pPinDir = m_dir; <br>    return NOERROR; <br>} <br> <br>// Default QueryId to return the pin's name <br>STDMETHODIMP <br>CBasePin::QueryId( <br>    LPWSTR * Id <br>) <br>{ <br>    //  We're not going away because someone's got a pointer to us <br>    //  so there's no need to lock <br> <br>    return AMGetWideString(Name(), Id); <br>} <br> <br>/* Does this pin support this media type WARNING this interface function does <br>   not lock the main object as it is meant to be asynchronous by nature - if <br>   the media types you support depend on some internal state that is updated <br>   dynamically then you will need to implement locking in a derived class */ <br> <br>STDMETHODIMP <br>CBasePin::QueryAccept( <br>    const AM_MEDIA_TYPE *pmt <br>) <br>{ <br>    CheckPointer(pmt,E_POINTER); <br>    ValidateReadPtr(pmt,sizeof(AM_MEDIA_TYPE)); <br> <br>    /* The CheckMediaType method is valid to return error codes if the media <br>       type is horrible, an example might be E_INVALIDARG. What we do here <br>       is map all the error codes into either S_OK or S_FALSE regardless */ <br> <br>    HRESULT hr = CheckMediaType((CMediaType*)pmt); <br>    if (FAILED(hr)) { <br>        return S_FALSE; <br>    } <br>    // note that the only defined success codes should be S_OK and S_FALSE... <br>    return hr; <br>} <br> <br> <br>/* This can be called to return an enumerator for the pin's list of preferred <br>   media types. An input pin is not obliged to have any preferred formats <br>   although it can do. For example, the window renderer has a preferred type <br>   which describes a video image that matches the current window size. All <br>   output pins should expose at least one preferred format otherwise it is </code></pre>
<p>
</p>
<pre><code>possible that neither pin has any types and so no connection is possible */ <br> <br>STDMETHODIMP <br>CBasePin::EnumMediaTypes( <br>    IEnumMediaTypes **ppEnum <br>) <br>{ <br>    CheckPointer(ppEnum,E_POINTER); <br>    ValidateReadWritePtr(ppEnum,sizeof(IEnumMediaTypes *)); <br> <br>    /* Create a new ref counted enumerator */ <br> <br>    *ppEnum = new CEnumMediaTypes(this, <br>                          NULL); <br> <br>    if (*ppEnum == NULL) { <br>return E_OUTOFMEMORY; <br>    } <br> <br>    return NOERROR; <br>} <br> <br> <br> <br>/* This is a virtual function that returns a media type corresponding with <br>   place iPosition in the list. This base class simply returns an error as <br>   we support no media types by default but derived classes should override */ <br> <br>HRESULT CBasePin::GetMediaType(int iPosition, CMediaType *pMediaType) <br>{ <br>    UNREFERENCED_PARAMETER(iPosition); <br>    UNREFERENCED_PARAMETER(pMediaType); <br>    return E_UNEXPECTED; <br>} <br> <br> <br>/* This is a virtual function that returns the current media type version. <br>   The base class initialises the media type enumerators with the value 1 <br>   By default we always returns that same value. A Derived class may change <br>   the list of media types available and after doing so it should increment <br>   the version either in a method derived from this, or more simply by just <br>   incrementing the m_TypeVersion base pin variable. The type enumerators <br>   call this when they want to see if their enumerations are out of date */ <br> <br>LONG CBasePin::GetMediaTypeVersion() <br>{ <br>    return m_TypeVersion; <br>} <br> <br> <br>/* Increment the cookie representing the current media type version */ <br> <br>void CBasePin::IncrementTypeVersion() <br>{ <br>    InterlockedIncrement(&amp;m_TypeVersion); <br>} <br> <br> <br>/* Called by IMediaFilter implementation when the state changes from Stopped <br>   to either paused or running and in derived classes could do things like <br>   commit memory and grab hardware resource (the default is to do nothing) */ <br> <br>HRESULT <br>CBasePin::Active(void) <br>{ <br>    return NOERROR; <br>} <br> <br>/* Called by IMediaFilter implementation when the state changes from <br>   to either paused to running and in derived classes could do things like <br>   commit memory and grab hardware resource (the default is to do nothing) */ <br> <br>HRESULT <br>CBasePin::Run(REFERENCE_TIME tStart) <br>{ <br>    UNREFERENCED_PARAMETER(tStart); <br>    return NOERROR; <br>} <br> <br> <br>/* Also called by the IMediaFilter implementation when the state changes to <br>   Stopped at which point you should decommit allocators and free hardware <br>   resources you grabbed in the Active call (default is also to do nothing) */ <br> <br>HRESULT <br>CBasePin::Inactive(void) <br>{ <br>    m_bRunTimeError = FALSE; <br>    return NOERROR; <br>} <br> <br> <br>// Called when no more data will arrive <br>STDMETHODIMP <br>CBasePin::EndOfStream(void) <br>{ <br>    return S_FALSE; <br>} <br> <br> <br>STDMETHODIMP <br>CBasePin::SetSink(IQualityControl * piqc) <br>{ <br>    CAutoLock cObjectLock(m_pLock); <br>    if (piqc) ValidateReadPtr(piqc,sizeof(IQualityControl)); <br>    m_pQSink = piqc; <br>    return NOERROR; <br>} // SetSink <br> <br> <br>STDMETHODIMP <br>CBasePin::Notify(IBaseFilter * pSender, Quality q) <br>{ <br>    UNREFERENCED_PARAMETER(q); <br>    UNREFERENCED_PARAMETER(pSender); <br>    DbgBreak("IQualityControl::Notify not over-ridden from CBasePin.  (IGNORE is OK)"); <br>    return E_NOTIMPL; <br>} //Notify <br> <br> <br>// NewSegment notifies of the start/stop/rate applying to the data <br>// about to be received. Default implementation records data and <br>// returns S_OK. <br>// Override this to pass downstream. <br>STDMETHODIMP <br>CBasePin::NewSegment( <br>                REFERENCE_TIME tStart, <br>                REFERENCE_TIME tStop, <br>                double dRate) <br>{ <br>    m_tStart = tStart; <br>    m_tStop = tStop; <br>    m_dRate = dRate; <br> <br>    return S_OK; <br>} <br> <br> <br>//===================================================================== <br>//===================================================================== <br>// Implements CBaseOutputPin <br>//===================================================================== <br>//===================================================================== <br> <br> <br>CBaseOutputPin::CBaseOutputPin(TCHAR *pObjectName, <br>       CBaseFilter *pFilter, <br>       CCritSec *pLock, <br>       HRESULT *phr, <br>       LPCWSTR pName) : <br>    CBasePin(pObjectName, pFilter, pLock, phr, pName, PINDIR_OUTPUT), <br>    m_pAllocator(NULL), <br>    m_pInputPin(NULL) <br>{ <br>    ASSERT(pFilter); <br>} <br> <br> <br>/* Since an input pin connected to us holds a reference count on us we will <br>   never be deleted unless all connections have already been terminated */ <br> <br>#if 0 <br>CBaseOutputPin::~CBaseOutputPin() <br>{ <br>} <br>#endif <br> <br>/*   This is called after a media type has been proposed <br> <br>     Try to complete the connection by agreeing the allocator <br>*/ <br>HRESULT <br>CBaseOutputPin::CompleteConnect(IPin *pReceivePin) <br>{ <br>    UNREFERENCED_PARAMETER(pReceivePin); <br>    return DecideAllocator(m_pInputPin, &amp;m_pAllocator); <br>} <br> <br> <br>/* This method is called when the output pin is about to try and connect to <br>   an input pin. It is at this point that you should try and grab any extra <br>   interfaces that you need, in this case IMemInputPin. Because this is <br>   only called if we are not currently connected we do NOT need to call <br>   BreakConnect. This also makes it easier to derive classes from us as <br>   BreakConnect is only called when we actually have to break a connection <br>   (or a partly made connection) and not when we are checking a connection */ <br> <br>/* Overriden from CBasePin */ <br> <br>HRESULT <br>CBaseOutputPin::CheckConnect(IPin * pPin) <br>{ <br>    HRESULT hr = CBasePin::CheckConnect(pPin); <br>    if (FAILED(hr)) { <br>return hr; <br>    } <br> <br>    // get an input pin and an allocator interface <br>    hr = pPin-&gt;QueryInterface(IID_IMemInputPin, (void **) &amp;m_pInputPin); <br>    if (FAILED(hr)) { <br>return hr; <br>    } <br>    return NOERROR; <br>} <br> <br> <br>/* Overriden from CBasePin */ <br> <br>HRESULT <br>CBaseOutputPin::BreakConnect() <br>{ <br>    /* Release any allocator we hold */ <br> <br>    if (m_pAllocator) { <br>m_pAllocator-&gt;Release(); <br>m_pAllocator = NULL; <br>    } <br> <br>    /* Release any input pin interface we hold */ <br> <br>    if (m_pInputPin) { <br>m_pInputPin-&gt;Release(); <br>m_pInputPin = NULL; <br>    } <br>    return NOERROR; <br>} <br> <br> <br>/* This is called when the input pin didn't give us a valid allocator */ <br> <br>HRESULT <br>CBaseOutputPin::InitAllocator(IMemAllocator **ppAlloc) <br>{ <br>#if 0 <br>    HRESULT hr = NOERROR; <br>    *ppAlloc = NULL; <br>    CMemAllocator *pMemObject = NULL; <br> <br>    /* Create a default memory allocator */ <br> <br>    pMemObject = new CMemAllocator(NAME("Base memory allocator"),NULL, &amp;hr); <br>    if (pMemObject == NULL) { <br>return E_OUTOFMEMORY; <br>    } <br> <br>    if (FAILED(hr)) { <br>delete pMemObject; <br>return hr; <br>    } <br> <br>    /* Get a reference counted IID_IMemAllocator interface */ <br> <br>    EXECUTE_ASSERT(SUCCEEDED(pMemObject-&gt;QueryInterface(IID_IMemAllocator,(void **)ppAlloc))); <br> <br>    ASSERT(*ppAlloc != NULL); <br>    return NOERROR; <br>#else <br>    return CreateMemoryAllocator(ppAlloc); <br>#endif <br>} <br> <br> <br>/* Decide on an allocator, override this if you want to use your own allocator <br>   Override DecideBufferSize to call SetProperties. If the input pin fails <br>   the GetAllocator call then this will construct a CMemAllocator and call <br>   DecideBufferSize on that, and if that fails then we are completely hosed. <br>   If the you succeed the DecideBufferSize call, we will notify the input <br>   pin of the selected allocator. NOTE this is called during Connect() which <br>   therefore looks after grabbing and locking the object's critical section */ <br> <br>// We query the input pin for its requested properties and pass this to <br>// DecideBufferSize to allow it to fulfill requests that it is happy <br>// with (eg most people don't care about alignment and are thus happy to <br>// use the downstream pin's alignment request). <br> <br>HRESULT <br>CBaseOutputPin::DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc) <br>{ <br>    HRESULT hr = NOERROR; <br>    *ppAlloc = NULL; <br> <br>    // get downstream prop request <br>    // the derived class may modify this in DecideBufferSize, but <br>    // we assume that he will consistently modify it the same way, <br>    // so we only get it once <br>    ALLOCATOR_PROPERTIES prop; <br>    ZeroMemory(&amp;prop, sizeof(prop)); <br> <br>    // whatever he returns, we assume prop is either all zeros <br>    // or he has filled it out. <br>    pPin-&gt;GetAllocatorRequirements(&amp;prop); <br> <br>    // if he doesn't care about alignment, then set it to 1 <br>    if (prop.cbAlign == 0) { <br>        prop.cbAlign = 1; <br>    } <br> <br>    /* Try the allocator provided by the input pin */ <br> <br>    hr = pPin-&gt;GetAllocator(ppAlloc); <br>    if (SUCCEEDED(hr)) { <br> <br>hr = DecideBufferSize(*ppAlloc, &amp;prop); <br>if (SUCCEEDED(hr)) { <br>    hr = pPin-&gt;NotifyAllocator(*ppAlloc, FALSE); <br>    if (SUCCEEDED(hr)) { <br>return NOERROR; <br>    } <br>} <br>    } <br> <br>    /* If the GetAllocator failed we may not have an interface */ <br> <br>    if (*ppAlloc) { <br>(*ppAlloc)-&gt;Release(); <br>*ppAlloc = NULL; <br>    } <br> <br>    /* Try the output pin's allocator by the same method */ <br> <br>    hr = InitAllocator(ppAlloc); <br>    if (SUCCEEDED(hr)) { <br> <br>        // note - the properties passed here are in the same <br>        // structure as above and may have been modified by <br>        // the previous call to DecideBufferSize <br>hr = DecideBufferSize(*ppAlloc, &amp;prop); <br>if (SUCCEEDED(hr)) { <br>    hr = pPin-&gt;NotifyAllocator(*ppAlloc, FALSE); <br>    if (SUCCEEDED(hr)) { <br>return NOERROR; <br>    } <br>} <br>    } <br> <br>    /* Likewise we may not have an interface to release */ <br> <br>    if (*ppAlloc) { <br>(*ppAlloc)-&gt;Release(); <br>*ppAlloc = NULL; <br>    } <br>    return hr; <br>} <br> <br> <br>/* This returns an empty sample buffer from the allocator WARNING the same <br>   dangers and restrictions apply here as described below for Deliver() */ <br> <br>HRESULT <br>CBaseOutputPin::GetDeliveryBuffer(IMediaSample ** ppSample, <br>                                  REFERENCE_TIME * pStartTime, <br>                                  REFERENCE_TIME * pEndTime, <br>                                  DWORD dwFlags) <br>{ <br>    if (m_pAllocator != NULL) { <br>        return m_pAllocator-&gt;GetBuffer(ppSample,pStartTime,pEndTime,dwFlags); <br>    } else { <br>        return E_NOINTERFACE; <br>    } <br>} <br> <br> <br>/* Deliver a filled-in sample to the connected input pin. NOTE the object must <br>   have locked itself before calling us otherwise we may get halfway through <br>   executing this method only to find the filter graph has got in and <br>   disconnected us from the input pin. If the filter has no worker threads <br>   then the lock is best applied on Receive(), otherwise it should be done <br>   when the worker thread is ready to deliver. There is a wee snag to worker <br>   threads that this shows up. The worker thread must lock the object when <br>   it is ready to deliver a sample, but it may have to wait until a state <br>   change has completed, but that may never complete because the state change <br>   is waiting for the worker thread to complete. The way to handle this is for <br>   the state change code to grab the critical section, then set an abort event <br>   for the worker thread, then release the critical section and wait for the <br>   worker thread to see the event we set and then signal that it has finished <br>   (with another event). At which point the state change code can complete */ <br> <br>// note (if you've still got any breath left after reading that) that you <br>// need to release the sample yourself after this call. if the connected <br>// input pin needs to hold onto the sample beyond the call, it will addref <br>// the sample itself. <br> <br>// of course you must release this one and call GetDeliveryBuffer for the <br>// next. You cannot reuse it directly. <br> <br>HRESULT <br>CBaseOutputPin::Deliver(IMediaSample * pSample) <br>{ <br>    if (m_pInputPin == NULL) { <br>return VFW_E_NOT_CONNECTED; <br>    } <br>    return m_pInputPin-&gt;Receive(pSample); <br>} <br> <br> <br>// called from elsewhere in our filter to pass EOS downstream to <br>// our connected input pin <br>HRESULT <br>CBaseOutputPin::DeliverEndOfStream(void) <br>{ <br>    // remember this is on IPin not IMemInputPin <br>    if (m_Connected == NULL) { <br>        return VFW_E_NOT_CONNECTED; <br>    } <br>    return m_Connected-&gt;EndOfStream(); <br>} <br> <br> <br>/* Commit the allocator's memory, this is called through IMediaFilter <br>   which is responsible for locking the object before calling us */ <br> <br>HRESULT <br>CBaseOutputPin::Active(void) <br>{ <br>    if (m_pAllocator == NULL) { <br>return VFW_E_NO_ALLOCATOR; <br>    } <br>    return m_pAllocator-&gt;Commit(); <br>} <br> <br> <br>/* Free up or unprepare allocator's memory, this is called through <br>   IMediaFilter which is responsible for locking the object first */ <br> <br>HRESULT <br>CBaseOutputPin::Inactive(void) <br>{ <br>    m_bRunTimeError = FALSE; <br>    if (m_pAllocator == NULL) { <br>return VFW_E_NO_ALLOCATOR; <br>    } <br>    return m_pAllocator-&gt;Decommit(); <br>} <br> <br>// we have a default handling of EndOfStream which is to return <br>// an error, since this should be called on input pins only <br>STDMETHODIMP <br>CBaseOutputPin::EndOfStream(void) <br>{ <br>    return E_UNEXPECTED; <br>} <br> <br> <br>// BeginFlush should be called on input pins only <br>STDMETHODIMP <br>CBaseOutputPin::BeginFlush(void) <br>{ <br>    return E_UNEXPECTED; <br>} <br> <br>// EndFlush should be called on input pins only <br>STDMETHODIMP <br>CBaseOutputPin::EndFlush(void) <br>{ <br>    return E_UNEXPECTED; <br>} <br> <br>// call BeginFlush on the connected input pin <br>HRESULT <br>CBaseOutputPin::DeliverBeginFlush(void) <br>{ <br>    // remember this is on IPin not IMemInputPin <br>    if (m_Connected == NULL) { <br>        return VFW_E_NOT_CONNECTED; <br>    } <br>    return m_Connected-&gt;BeginFlush(); <br>} <br> <br>// call EndFlush on the connected input pin <br>HRESULT <br>CBaseOutputPin::DeliverEndFlush(void) <br>{ <br>    // remember this is on IPin not IMemInputPin <br>    if (m_Connected == NULL) { <br>        return VFW_E_NOT_CONNECTED; <br>    } <br>    return m_Connected-&gt;EndFlush(); <br>} <br>// deliver NewSegment to connected pin <br>HRESULT <br>CBaseOutputPin::DeliverNewSegment( <br>    REFERENCE_TIME tStart, <br>    REFERENCE_TIME tStop, <br>    double dRate) <br>{ <br>    if (m_Connected == NULL) { <br>        return VFW_E_NOT_CONNECTED; <br>    } <br>    return m_Connected-&gt;NewSegment(tStart, tStop, dRate); <br>} <br> <br> <br>//===================================================================== <br>//===================================================================== <br>// Implements CBaseInputPin <br>//===================================================================== <br>//===================================================================== <br> <br> <br>/* Constructor creates a default allocator object */ <br> <br>CBaseInputPin::CBaseInputPin(TCHAR *pObjectName, <br>     CBaseFilter *pFilter, <br>     CCritSec *pLock, <br>     HRESULT *phr, <br>     LPCWSTR pPinName) : <br>    CBasePin(pObjectName, pFilter, pLock, phr, pPinName, PINDIR_INPUT), <br>    m_pAllocator(NULL), <br>    m_bReadOnly(FALSE), <br>    m_bFlushing(FALSE) <br>{ <br>    ZeroMemory(&amp;m_SampleProps, sizeof(m_SampleProps)); <br>} <br> <br>/* Destructor releases it's reference count on the default allocator */ <br> <br>CBaseInputPin::~CBaseInputPin() <br>{ <br>    if (m_pAllocator != NULL) { <br>m_pAllocator-&gt;Release(); <br>m_pAllocator = NULL; <br>    } <br>} <br> <br> <br>// override this to publicise our interfaces <br>STDMETHODIMP <br>CBaseInputPin::NonDelegatingQueryInterface(REFIID riid, void **ppv) <br>{ <br>    /* Do we know about this interface */ <br> <br>    if (riid == IID_IMemInputPin) { <br>return GetInterface((IMemInputPin *) this, ppv); <br>    } else { <br>return CBasePin::NonDelegatingQueryInterface(riid, ppv); <br>    } <br>} <br> <br> <br>/* Return the allocator interface that this input pin would like the output <br>   pin to use. NOTE subsequent calls to GetAllocator should all return an <br>   interface onto the SAME object so we create one object at the start <br> <br>   Note: <br>       The allocator is Release()'d on disconnect and replaced on <br>       NotifyAllocator(). <br> <br>   Override this to provide your own allocator. <br>*/ <br> <br>STDMETHODIMP <br>CBaseInputPin::GetAllocator( <br>    IMemAllocator **ppAllocator) <br>{ <br>    CheckPointer(ppAllocator,E_POINTER); <br>    ValidateReadWritePtr(ppAllocator,sizeof(IMemAllocator *)); <br>    CAutoLock cObjectLock(m_pLock); <br> <br>    if (m_pAllocator == NULL) { <br>#if 0 <br>HRESULT hr = S_OK; <br> <br>/* Create the new allocator object */ <br> <br>CMemAllocator *pMemObject = new CMemAllocator(NAME("Default memory allocator"), <br>      NULL, &amp;hr); <br>if (pMemObject == NULL) { <br>    return E_OUTOFMEMORY; <br>} <br> <br>if (FAILED(hr)) { <br>    ASSERT(pMemObject); <br>    delete pMemObject; <br>    return hr; <br>} <br> <br>        m_pAllocator = pMemObject; <br> <br>        /*  We AddRef() our own allocator */ <br>        m_pAllocator-&gt;AddRef(); <br>#else <br>        HRESULT hr = CreateMemoryAllocator(&amp;m_pAllocator); <br>        if (FAILED(hr)) { <br>            return hr; <br>        } <br>#endif <br>    } <br>    ASSERT(m_pAllocator != NULL); <br>    *ppAllocator = m_pAllocator; <br>    m_pAllocator-&gt;AddRef(); <br>    return NOERROR; <br>} <br> <br> <br>/* Tell the input pin which allocator the output pin is actually going to use <br>   Override this if you care - NOTE the locking we do both here and also in <br>   GetAllocator is unnecessary but derived classes that do something useful <br>   will undoubtedly have to lock the object so this might help remind people */ <br> <br>STDMETHODIMP <br>CBaseInputPin::NotifyAllocator( <br>    IMemAllocator * pAllocator, <br>    BOOL bReadOnly) <br>{ <br>    CheckPointer(pAllocator,E_POINTER); <br>    ValidateReadPtr(pAllocator,sizeof(IMemAllocator)); <br>    CAutoLock cObjectLock(m_pLock); <br> <br>    IMemAllocator *pOldAllocator = m_pAllocator; <br>    pAllocator-&gt;AddRef(); <br>    m_pAllocator = pAllocator; <br> <br>    if (pOldAllocator != NULL) { <br>pOldAllocator-&gt;Release(); <br>    } <br> <br>    // the readonly flag indicates whether samples from this allocator should <br>    // be regarded as readonly - if true, then inplace transforms will not be <br>    // allowed. <br>    m_bReadOnly = bReadOnly; <br>    return NOERROR; <br>} <br> <br> <br>/*  Disconnect */ <br> <br>STDMETHODIMP CBaseInputPin::Disconnect() <br>{ <br>    CAutoLock cObjectLock(m_pLock); <br> <br>    /*  Call base class first because it calls Inactive() for us */ <br>    HRESULT hr = CBasePin::Disconnect(); <br> <br>    if (S_OK == hr) { <br>        /* We don't need our allocator any more */ <br>        if (m_pAllocator) { <br>            m_pAllocator-&gt;Release(); <br>            m_pAllocator = NULL; <br>        } <br>    } <br>    return hr; <br>} <br> <br> <br>/* Do something with this media sample - this base class checks to see if the <br>   format has changed with this media sample and if so checks that the filter <br>   will accept it, generating a run time error if not. Once we have raised a <br>   run time error we set a flag so that no more samples will be accepted <br> <br>   It is important that any filter should override this method and implement <br>   synchronization so that samples are not processed when the pin is <br>   disconnected etc <br>*/ <br> <br>STDMETHODIMP <br>CBaseInputPin::Receive(IMediaSample *pSample) <br>{ <br>    CheckPointer(pSample,E_POINTER); <br>    ValidateReadPtr(pSample,sizeof(IMediaSample)); <br>    AM_MEDIA_TYPE *pmt = NULL; <br>    ASSERT(pSample); <br> <br>    HRESULT hr = CheckStreaming(); <br>    if (S_OK != hr) { <br>        return hr; <br>    } <br> <br>    /* Check for IMediaSample2 */ <br>    IMediaSample2 *pSample2; <br>    if (SUCCEEDED(pSample-&gt;QueryInterface(IID_IMediaSample2, (void **)&amp;pSample2))) { <br>        hr = pSample2-&gt;GetProperties(sizeof(m_SampleProps), (PBYTE)&amp;m_SampleProps); <br>        pSample2-&gt;Release(); <br>        if (FAILED(hr)) { <br>            return hr; <br>        } <br>    } else { <br>        /*  Get the properties the hard way */ <br>        m_SampleProps.cbData = sizeof(m_SampleProps); <br>        m_SampleProps.dwTypeSpecificFlags = 0; <br>        m_SampleProps.dwStreamId = AM_STREAM_MEDIA; <br>        m_SampleProps.dwSampleFlags = 0; <br>        if (S_OK == pSample-&gt;IsDiscontinuity()) { <br>            m_SampleProps.dwSampleFlags |= AM_SAMPLE_DATADISCONTINUITY; <br>        } <br>        if (S_OK == pSample-&gt;IsPreroll()) { <br>            m_SampleProps.dwSampleFlags |= AM_SAMPLE_PREROLL; <br>        } <br>        if (S_OK == pSample-&gt;IsSyncPoint()) { <br>            m_SampleProps.dwSampleFlags |= AM_SAMPLE_SPLICEPOINT; <br>        } <br>        if (SUCCEEDED(pSample-&gt;GetTime(&amp;m_SampleProps.tStart, <br>                                       &amp;m_SampleProps.tStop))) { <br>            m_SampleProps.dwSampleFlags |= AM_SAMPLE_TIMEVALID | <br>                                           AM_SAMPLE_STOPVALID; <br>        } <br>        if (S_OK == pSample-&gt;GetMediaType(&amp;m_SampleProps.pMediaType)) { <br>            m_SampleProps.dwSampleFlags |= AM_SAMPLE_TYPECHANGED; <br>        } <br>        pSample-&gt;GetPointer(&amp;m_SampleProps.pbBuffer); <br>        m_SampleProps.lActual = pSample-&gt;GetActualDataLength(); <br>        m_SampleProps.cbBuffer = pSample-&gt;GetSize(); <br>    } <br> <br>    /* Has the format changed in this sample */ <br> <br>    if (!(m_SampleProps.dwSampleFlags &amp; AM_SAMPLE_TYPECHANGED)) { <br>return NOERROR; <br>    } <br> <br>    /* Check the derived class accepts this format */ <br>    /* This shouldn't fail as the source must call QueryAccept first */ <br> <br>    hr = CheckMediaType((CMediaType *)m_SampleProps.pMediaType); <br> <br>    if (hr == NOERROR) { <br>        return NOERROR; <br>    } <br> <br>    /* Raise a runtime error if we fail the media type */ <br> <br>    m_bRunTimeError = TRUE; <br>    EndOfStream(); <br>    m_pFilter-&gt;NotifyEvent(EC_ERRORABORT,VFW_E_TYPE_NOT_ACCEPTED,0); <br>    return VFW_E_INVALIDMEDIATYPE; <br>} <br> <br> <br>/*  Receive multiple samples */ <br>STDMETHODIMP <br>CBaseInputPin::ReceiveMultiple ( <br>    IMediaSample **pSamples, <br>    long nSamples, <br>    long *nSamplesProcessed) <br>{ <br>    CheckPointer(pSamples,E_POINTER); <br>    ValidateReadPtr(pSamples,nSamples * sizeof(IMediaSample *)); <br> <br>    HRESULT hr = S_OK; <br>    *nSamplesProcessed = 0; <br>    while (nSamples-- &gt; 0) { <br>         hr = Receive(pSamples[*nSamplesProcessed]); <br> <br>         /*  S_FALSE means don't send any more */ <br>         if (hr != S_OK) { <br>             break; <br>         } <br>         (*nSamplesProcessed)++; <br>    } <br>    return hr; <br>} <br> <br>/*  See if Receive() might block */ <br>STDMETHODIMP <br>CBaseInputPin::ReceiveCanBlock() <br>{ <br>    /*  Ask all the output pins if they block <br>        If there are no output pin assume we do block <br>    */ <br>    int cPins = m_pFilter-&gt;GetPinCount(); <br>    int cOutputPins = 0; <br>    for (int c = 0; c &lt; cPins; c++) { <br>        CBasePin *pPin = m_pFilter-&gt;GetPin(c); <br>        PIN_DIRECTION pd; <br>        HRESULT hr = pPin-&gt;QueryDirection(&amp;pd); <br>        if (FAILED(hr)) { <br>            return hr; <br>        } <br> <br>        if (pd == PINDIR_OUTPUT) { <br>            IPin *pConnected; <br>            hr = pPin-&gt;ConnectedTo(&amp;pConnected); <br>            if (SUCCEEDED(hr)) { <br>                ASSERT(pConnected != NULL); <br>                cOutputPins++; <br>                IMemInputPin *pInputPin; <br>                hr = pConnected-&gt;QueryInterface( <br>                                              IID_IMemInputPin, <br>                                              (void **)&amp;pInputPin); <br>                pConnected-&gt;Release(); <br>                if (SUCCEEDED(hr)) { <br>                    hr = pInputPin-&gt;ReceiveCanBlock(); <br>                    pInputPin-&gt;Release(); <br>                    if (hr != S_FALSE) { <br>                        return S_OK; <br>                    } <br>                } else { <br>                    /*  There's a transport we don't understand here */ <br>                    return S_OK; <br>                } <br>            } <br>        } <br>    } <br>    return cOutputPins == 0 ? S_OK : S_FALSE; <br>} <br> <br>// Default handling for BeginFlush - call at the beginning <br>// of your implementation (makes sure that all Receive calls <br>// fail). After calling this, you need to free any queued data <br>// and then call downstream. <br>STDMETHODIMP <br>CBaseInputPin::BeginFlush(void) <br>{ <br>    //  BeginFlush is NOT synchronized with streaming but is part of <br>    //  a control action - hence we synchronize with the filter <br>    CAutoLock lck(m_pLock); <br> <br>    // if we are already in mid-flush, this is probably a mistake <br>    // though not harmful - try to pick it up for now so I can think about it <br>    ASSERT(!m_bFlushing); <br> <br>    // first thing to do is ensure that no further Receive calls succeed <br>    m_bFlushing = TRUE; <br> <br>    // now discard any data and call downstream - must do that <br>    // in derived classes <br>    return S_OK; <br>} <br> <br>// default handling for EndFlush - call at end of your implementation <br>// - before calling this, ensure that there is no queued data and no thread <br>// pushing any more without a further receive, then call downstream, <br>// then call this method to clear the m_bFlushing flag and re-enable <br>// receives <br>STDMETHODIMP <br>CBaseInputPin::EndFlush(void) <br>{ <br>    //  Endlush is NOT synchronized with streaming but is part of <br>    //  a control action - hence we synchronize with the filter <br>    CAutoLock lck(m_pLock); <br> <br>    // almost certainly a mistake if we are not in mid-flush <br>    ASSERT(m_bFlushing); <br> <br>    // before calling, sync with pushing thread and ensure <br>    // no more data is going downstream, then call EndFlush on <br>    // downstream pins. <br> <br>    // now re-enable Receives <br>    m_bFlushing = FALSE; <br> <br>    return S_OK; <br>} <br> <br> <br>STDMETHODIMP <br>CBaseInputPin::Notify(IBaseFilter * pSender, Quality q) <br>{ <br>    UNREFERENCED_PARAMETER(q); <br>    CheckPointer(pSender,E_POINTER); <br>    ValidateReadPtr(pSender,sizeof(IBaseFilter)); <br>    DbgBreak("IQuality::Notify called on an input pin"); <br>    return NOERROR; <br>} // Notify <br> <br>/* Free up or unprepare allocator's memory, this is called through <br>   IMediaFilter which is responsible for locking the object first */ <br> <br>HRESULT <br>CBaseInputPin::Inactive(void) <br>{ <br>    m_bRunTimeError = FALSE; <br>    if (m_pAllocator == NULL) { <br>return VFW_E_NO_ALLOCATOR; <br>    } <br> <br>    m_bFlushing = FALSE; <br> <br>    return m_pAllocator-&gt;Decommit(); <br>} <br> <br>// what requirements do we have of the allocator - override if you want <br>// to support other people's allocators but need a specific alignment <br>// or prefix. <br>STDMETHODIMP <br>CBaseInputPin::GetAllocatorRequirements(ALLOCATOR_PROPERTIES*pProps) <br>{ <br>    UNREFERENCED_PARAMETER(pProps); <br>    return E_NOTIMPL; <br>} <br> <br>//  Check if it's OK to process data <br>// <br>HRESULT <br>CBaseInputPin::CheckStreaming() <br>{ <br>    //  Shouldn't be able to get any data if we're not connected! <br>    ASSERT(IsConnected()); <br> <br>    //  Don't process stuff in Stopped state <br>    if (IsStopped()) { <br>        return VFW_E_WRONG_STATE; <br>    } <br>    if (m_bFlushing) { <br>        return S_FALSE; <br>    } <br>    if (m_bRunTimeError) { <br>return VFW_E_RUNTIME_ERROR; <br>    } <br>    return S_OK; <br>} <br> <br>// Pass on the Quality notification q to <br>// a. Our QualityControl sink (if we have one) or else <br>// b. to our upstream filter <br>// and if that doesn't work, throw it away with a bad return code <br>HRESULT <br>CBaseInputPin::PassNotify(Quality&amp; q) <br>{ <br>    // We pass the message on, which means that we find the quality sink <br>    // for our input pin and send it there <br> <br>    DbgLog((LOG_TRACE,3,TEXT("Passing Quality notification through transform"))); <br>    if (m_pQSink!=NULL) { <br>        return m_pQSink-&gt;Notify(m_pFilter, q); <br>    } else { <br>        // no sink set, so pass it upstream <br>        HRESULT hr; <br>        IQualityControl * pIQC; <br> <br>        hr = VFW_E_NOT_FOUND;                   // default <br>        if (m_Connected) { <br>            m_Connected-&gt;QueryInterface(IID_IQualityControl, (void**)&amp;pIQC); <br> <br>            if (pIQC!=NULL) { <br>                hr = pIQC-&gt;Notify(m_pFilter, q); <br>                pIQC-&gt;Release(); <br>            } <br>        } <br>        return hr; <br>    } <br> <br>} // PassNotify <br> <br>//===================================================================== <br>//===================================================================== <br>// Memory allocation class, implements CMediaSample <br>//===================================================================== <br>//===================================================================== <br> <br> <br>/* NOTE The implementation of this class calls the CUnknown constructor with <br>   a NULL outer unknown pointer. This has the effect of making us a self <br>   contained class, ie any QueryInterface, AddRef or Release calls will be <br>   routed to the class's NonDelegatingUnknown methods. You will typically <br>   find that the classes that do this then override one or more of these <br>   virtual functions to provide more specialised behaviour. A good example <br>   of this is where a class wants to keep the QueryInterface internal but <br>   still wants it's lifetime controlled by the external object */ <br> <br>/* The last two parameters have default values of NULL and zero */ <br> <br>CMediaSample::CMediaSample(TCHAR *pName, <br>   CBaseAllocator *pAllocator, <br>   HRESULT *phr, <br>   LPBYTE pBuffer, <br>   LONG length) : <br>    m_pBuffer(pBuffer),             // Initialise the buffer <br>    m_cbBuffer(length),             // And it's length <br>    m_lActual(length),              // By default, actual = length <br>    m_pMediaType(NULL),             // No media type change <br>    m_dwFlags(0),                   // Nothing set <br>    m_cRef(0),                      // 0 ref count <br>    m_dwTypeSpecificFlags(0),       // Type specific flags <br>    m_dwStreamId(AM_STREAM_MEDIA),  // Stream id <br>    m_pAllocator(pAllocator)        // Allocator <br>{ <br>    /* We must have an owner and it must also be derived from class <br>       CBaseAllocator BUT we do not hold a reference count on it */ </code></pre>
<p>
</p>
<pre><code><br>    ASSERT(pAllocator); <br>} <br> <br> <br>/* Destructor deletes the media type memory */ <br> <br>CMediaSample::~CMediaSample() <br>{ <br>    if (m_pMediaType) { <br>DeleteMediaType(m_pMediaType); <br>    } <br>} <br> <br>/* Override this to publicise our interfaces */ <br> <br>STDMETHODIMP <br>CMediaSample::QueryInterface(REFIID riid, void **ppv) <br>{ <br>    if (riid == IID_IMediaSample || <br>        riid == IID_IMediaSample2 || <br>        riid == IID_IUnknown) { <br>return GetInterface((IMediaSample *) this, ppv); <br>    } else { <br>return E_NOINTERFACE; <br>    } <br>} <br> <br>STDMETHODIMP_(ULONG) <br>CMediaSample::AddRef() <br>{ <br>    return InterlockedIncrement(&amp;m_cRef); <br>} <br> <br> <br>// --  CMediaSample lifetimes -- <br>// <br>// On final release of this sample buffer it is not deleted but <br>// returned to the freelist of the owning memory allocator <br>// <br>// The allocator may be waiting for the last buffer to be placed on the free <br>// list in order to decommit all the memory, so the ReleaseBuffer() call may <br>// result in this sample being deleted. We also need to hold a refcount on <br>// the allocator to stop that going away until we have finished with this. <br>// However, we cannot release the allocator before the ReleaseBuffer, as the <br>// release may cause us to be deleted. Similarly we can't do it afterwards. <br>// <br>// Thus we must leave it to the allocator to hold an addref on our behalf. <br>// When he issues us in GetBuffer, he addref's himself. When ReleaseBuffer <br>// is called, he releases himself, possibly causing us and him to be deleted. <br> <br> <br>STDMETHODIMP_(ULONG) <br>CMediaSample::Release() <br>{ <br>    /* Decrement our own private reference count */ <br>    LONG lRef; <br>    if (m_cRef == 1) { <br>        lRef = 0; <br>        m_cRef = 0; <br>    } else { <br>        lRef = InterlockedDecrement(&amp;m_cRef); <br>    } <br>    ASSERT(lRef &gt;= 0); <br> <br>    DbgLog((LOG_MEMORY,3,TEXT("    Unknown %X ref-- = %d"), <br>    this, m_cRef)); <br> <br>    /* Did we release our final reference count */ <br>    if (lRef == 0) { <br>        /* Free all resources */ <br>        if (m_dwFlags &amp; Sample_TypeChanged) { <br>            SetMediaType(NULL); <br>        } <br>        ASSERT(m_pMediaType == NULL); <br>        m_dwFlags = 0; <br>        m_dwTypeSpecificFlags = 0; <br>        m_dwStreamId = AM_STREAM_MEDIA; <br> <br>        /* This may cause us to be deleted */ <br>        // Our refcount is reliably 0 thus no-one will mess with us <br>        m_pAllocator-&gt;ReleaseBuffer(this); <br>    } <br>    return (ULONG)lRef; <br>} <br> <br> <br>// set the buffer pointer and length. Used by allocators that <br>// want variable sized pointers or pointers into already-read data. <br>// This is only available through a CMediaSample* not an IMediaSample* <br>// and so cannot be changed by clients. <br>HRESULT <br>CMediaSample::SetPointer(BYTE * ptr, LONG cBytes) <br>{ <br>    m_pBuffer = ptr;            // new buffer area (could be null) <br>    m_cbBuffer = cBytes;        // length of buffer <br>    m_lActual = cBytes;         // length of data in buffer (assume full) <br> <br>    return S_OK; <br>} <br> <br> <br>// get me a read/write pointer to this buffer's memory. I will actually <br>// want to use sizeUsed bytes. <br>STDMETHODIMP <br>CMediaSample::GetPointer(BYTE ** ppBuffer) <br>{ <br>    ValidateReadWritePtr(ppBuffer,sizeof(BYTE *)); <br> <br>    // creator must have set pointer either during <br>    // constructor or by SetPointer <br>    ASSERT(m_pBuffer); <br> <br>    *ppBuffer = m_pBuffer; <br>    return NOERROR; <br>} <br> <br> <br>// return the size in bytes of this buffer <br>STDMETHODIMP_(LONG) <br>CMediaSample::GetSize(void) <br>{ <br>    return m_cbBuffer; <br>} <br> <br> <br>// get the stream time at which this sample should start and finish. <br>STDMETHODIMP <br>CMediaSample::GetTime( <br>    REFERENCE_TIME * pTimeStart,     // put time here <br>    REFERENCE_TIME * pTimeEnd <br>) <br>{ <br>    ValidateReadWritePtr(pTimeStart,sizeof(REFERENCE_TIME)); <br>    ValidateReadWritePtr(pTimeEnd,sizeof(REFERENCE_TIME)); <br> <br>    if (!(m_dwFlags &amp; Sample_StopValid)) { <br>        if (!(m_dwFlags &amp; Sample_TimeValid)) { <br>            return VFW_E_SAMPLE_TIME_NOT_SET; <br>        } else { <br>            *pTimeStart = m_Start; <br> <br>            //  Make sure old stuff works <br>            *pTimeEnd = m_Start + 1; <br>            return VFW_S_NO_STOP_TIME; <br>        } <br>    } <br> <br>    *pTimeStart = m_Start; <br>    *pTimeEnd = m_End; <br>    return NOERROR; <br>} <br> <br> <br>// Set the stream time at which this sample should start and finish. <br>// NULL pointers means the time is reset <br>STDMETHODIMP <br>CMediaSample::SetTime( <br>    REFERENCE_TIME * pTimeStart, <br>    REFERENCE_TIME * pTimeEnd <br>) <br>{ <br>    if (pTimeStart == NULL) { <br>        ASSERT(pTimeEnd == NULL); <br>        m_dwFlags &amp;= ~(Sample_TimeValid | Sample_StopValid); <br>    } else { <br>        if (pTimeEnd == NULL) { <br>            m_Start = *pTimeStart; <br>            m_dwFlags |= Sample_TimeValid; <br>            m_dwFlags &amp;= ~Sample_StopValid; <br>        } else { <br>            ValidateReadPtr(pTimeStart,sizeof(REFERENCE_TIME)); <br>            ValidateReadPtr(pTimeEnd,sizeof(REFERENCE_TIME)); <br>            ASSERT(*pTimeEnd &gt;= *pTimeStart); <br> <br>            m_Start = *pTimeStart; <br>            m_End = *pTimeEnd; <br>            m_dwFlags |= Sample_TimeValid | Sample_StopValid; <br>        } <br>    } <br>    return NOERROR; <br>} <br> <br> <br>// get the media times (eg bytes) for this sample <br>STDMETHODIMP <br>CMediaSample::GetMediaTime( <br>    LONGLONG * pTimeStart, <br>    LONGLONG * pTimeEnd <br>) <br>{ <br>    ValidateReadWritePtr(pTimeStart,sizeof(LONGLONG)); <br>    ValidateReadWritePtr(pTimeEnd,sizeof(LONGLONG)); <br> <br>    if (!(m_dwFlags &amp; Sample_MediaTimeValid)) { <br>        return VFW_E_MEDIA_TIME_NOT_SET; <br>    } <br> <br>    *pTimeStart = m_MediaStart; <br>    *pTimeEnd = (m_MediaStart + m_MediaEnd); <br>    return NOERROR; <br>} <br> <br> <br>// Set the media times for this sample <br>STDMETHODIMP <br>CMediaSample::SetMediaTime( <br>    LONGLONG * pTimeStart, <br>    LONGLONG * pTimeEnd <br>) <br>{ <br>    if (pTimeStart == NULL) { <br>        ASSERT(pTimeEnd == NULL); <br>        m_dwFlags &amp;= ~Sample_MediaTimeValid; <br>    } else { <br>        ValidateReadPtr(pTimeStart,sizeof(LONGLONG)); <br>        ValidateReadPtr(pTimeEnd,sizeof(LONGLONG)); <br>ASSERT(*pTimeEnd &gt;= *pTimeStart); <br> <br>        m_MediaStart = *pTimeStart; <br>        m_MediaEnd = (LONG)(*pTimeEnd - *pTimeStart); <br>        m_dwFlags |= Sample_MediaTimeValid; <br>    } <br>    return NOERROR; <br>} <br> <br> <br>STDMETHODIMP <br>CMediaSample::IsSyncPoint(void) <br>{ <br>    if (m_dwFlags &amp; Sample_SyncPoint) { <br>return S_OK; <br>    } else { <br>return S_FALSE; <br>    } <br>} <br> <br> <br>STDMETHODIMP <br>CMediaSample::SetSyncPoint(BOOL bIsSyncPoint) <br>{ <br>    if (bIsSyncPoint) { <br>        m_dwFlags |= Sample_SyncPoint; <br>    } else { <br>        m_dwFlags &amp;= ~Sample_SyncPoint; <br>    } <br>    return NOERROR; <br>} <br> <br>// returns S_OK if there is a discontinuity in the data (this same is <br>// not a continuation of the previous stream of data <br>// - there has been a seek). <br>STDMETHODIMP <br>CMediaSample::IsDiscontinuity(void) <br>{ <br>    if (m_dwFlags &amp; Sample_Discontinuity) { <br>return S_OK; <br>    } else { <br>return S_FALSE; <br>    } <br>} <br> <br>// set the discontinuity property - TRUE if this sample is not a <br>// continuation, but a new sample after a seek. <br>STDMETHODIMP <br>CMediaSample::SetDiscontinuity(BOOL bDiscont) <br>{ <br>    // should be TRUE or FALSE <br>    if (bDiscont) { <br>        m_dwFlags |= Sample_Discontinuity; <br>    } else { <br>        m_dwFlags &amp;= ~Sample_Discontinuity; <br>    } <br>    return S_OK; <br>} <br> <br>STDMETHODIMP <br>CMediaSample::IsPreroll(void) <br>{ <br>    if (m_dwFlags &amp; Sample_Preroll) { <br>return S_OK; <br>    } else { <br>return S_FALSE; <br>    } <br>} <br> <br> <br>STDMETHODIMP <br>CMediaSample::SetPreroll(BOOL bIsPreroll) <br>{ <br>    if (bIsPreroll) { <br>        m_dwFlags |= Sample_Preroll; <br>    } else { <br>        m_dwFlags &amp;= ~Sample_Preroll; <br>    } <br>    return NOERROR; <br>} <br> <br>STDMETHODIMP_(LONG) <br>CMediaSample::GetActualDataLength(void) <br>{ <br>    return m_lActual; <br>} <br> <br> <br>STDMETHODIMP <br>CMediaSample::SetActualDataLength(LONG lActual) <br>{ <br>    if (lActual &gt; m_cbBuffer) { <br>        ASSERT(lActual &lt;= GetSize()); <br>return VFW_E_BUFFER_OVERFLOW; <br>    } <br>    m_lActual = lActual; <br>    return NOERROR; <br>} <br> <br> <br>/* These allow for limited format changes in band */ <br> <br>STDMETHODIMP <br>CMediaSample::GetMediaType(AM_MEDIA_TYPE **ppMediaType) <br>{ <br>    ValidateReadWritePtr(ppMediaType,sizeof(AM_MEDIA_TYPE *)); <br>    ASSERT(ppMediaType); <br> <br>    /* Do we have a new media type for them */ <br> <br>    if (!(m_dwFlags &amp; Sample_TypeChanged)) { <br>ASSERT(m_pMediaType == NULL); <br>*ppMediaType = NULL; <br>return S_FALSE; <br>    } <br> <br>    ASSERT(m_pMediaType); <br> <br>    /* Create a copy of our media type */ <br> <br>    *ppMediaType = CreateMediaType(m_pMediaType); <br>    if (*ppMediaType == NULL) { <br>return E_OUTOFMEMORY; <br>    } <br>    return NOERROR; <br>} <br> <br> <br>/* Mark this sample as having a different format type */ <br> <br>STDMETHODIMP <br>CMediaSample::SetMediaType(AM_MEDIA_TYPE *pMediaType) <br>{ <br>    /* Delete the current media type */ <br> <br>    if (m_pMediaType) { <br>DeleteMediaType(m_pMediaType); <br>m_pMediaType = NULL; <br>    } <br> <br>    /* Mechanism for resetting the format type */ <br> <br>    if (pMediaType == NULL) { <br>        m_dwFlags &amp;= ~Sample_TypeChanged; <br>return NOERROR; <br>    } <br> <br>    ASSERT(pMediaType); <br>    ValidateReadPtr(pMediaType,sizeof(AM_MEDIA_TYPE)); <br> <br>    /* Take a copy of the media type */ <br> <br>    m_pMediaType = CreateMediaType(pMediaType); <br>    if (m_pMediaType == NULL) { <br>        m_dwFlags &amp;= ~Sample_TypeChanged; <br>return E_OUTOFMEMORY; <br>    } <br> <br>    m_dwFlags |= Sample_TypeChanged; <br>    return NOERROR; <br>} <br> <br>// Set and get properties (IMediaSample2) <br>STDMETHODIMP CMediaSample::GetProperties( <br>    DWORD cbProperties, <br>    BYTE * pbProperties <br>) <br>{ <br>    if (0 != cbProperties) { <br>        CheckPointer(pbProperties, E_POINTER); <br>        //  Return generic stuff up to the length <br>        AM_SAMPLE2_PROPERTIES Props; <br>        Props.cbData     = min(cbProperties, sizeof(Props)); <br>        Props.dwSampleFlags = m_dwFlags &amp; ~Sample_MediaTimeValid; <br>        Props.dwTypeSpecificFlags = m_dwTypeSpecificFlags; <br>        Props.pbBuffer   = m_pBuffer; <br>        Props.cbBuffer   = m_cbBuffer; <br>        Props.lActual    = m_lActual; <br>        Props.tStart     = m_Start; <br>        Props.tStop      = m_End; <br>        Props.dwStreamId = m_dwStreamId; <br>        if (m_dwFlags &amp; AM_SAMPLE_TYPECHANGED) { <br>            Props.pMediaType = m_pMediaType; <br>        } else { <br>            Props.pMediaType = NULL; <br>        } <br>        CopyMemory(pbProperties, &amp;Props, Props.cbData); <br>    } <br>    return S_OK; <br>} <br> <br>#define CONTAINS_FIELD(type, field, offset) \ <br>    ((FIELD_OFFSET(type, field) + sizeof(((type *)0)-&gt;field)) &lt;= offset) <br> <br>HRESULT CMediaSample::SetProperties( <br>    DWORD cbProperties, <br>    const BYTE * pbProperties <br>) <br>{ <br> <br>    /*  Generic properties */ <br>    AM_MEDIA_TYPE *pMediaType = NULL; <br> <br>    if (CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, cbData, cbProperties)) { <br>        CheckPointer(pbProperties, E_POINTER); <br>        AM_SAMPLE2_PROPERTIES *pProps = <br>            (AM_SAMPLE2_PROPERTIES *)pbProperties; <br> <br>        /*  Don't use more data than is actually there */ <br>        if (pProps-&gt;cbData &lt; cbProperties) { <br>            cbProperties = pProps-&gt;cbData; <br>        } <br>        /*  We only handle IMediaSample2 */ <br>        if (cbProperties &gt; sizeof(*pProps) || <br>            pProps-&gt;cbData &gt; sizeof(*pProps)) { <br>            return E_INVALIDARG; <br>        } <br>        /*  Do checks first, the assignments (for backout) */ <br>        if (CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, dwSampleFlags, cbProperties)) { <br>            /*  Check the flags */ <br>            if (pProps-&gt;dwSampleFlags &amp; <br>                    (~Sample_ValidFlags | Sample_MediaTimeValid)) { <br>                return E_INVALIDARG; <br>            } <br>            /*  Check a flag isn't being set for a property <br>                not being provided <br>            */ <br>            if ((pProps-&gt;dwSampleFlags &amp; AM_SAMPLE_TIMEVALID) &amp;&amp; <br>                 !(m_dwFlags &amp; AM_SAMPLE_TIMEVALID) &amp;&amp; <br>                 !CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, tStop, cbProperties)) { <br>                 return E_INVALIDARG; <br>            } <br>        } <br>        /*  NB - can't SET the pointer or size */ <br>        if (CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, pbBuffer, cbProperties)) { <br> <br>            /*  Check pbBuffer */ <br>            if (pProps-&gt;pbBuffer != 0 &amp;&amp; pProps-&gt;pbBuffer != m_pBuffer) { <br>                return E_INVALIDARG; <br>            } <br>        } <br>        if (CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, cbBuffer, cbProperties)) { <br> <br>            /*  Check cbBuffer */ <br>            if (pProps-&gt;cbBuffer != 0 &amp;&amp; pProps-&gt;cbBuffer != m_cbBuffer) { <br>                return E_INVALIDARG; <br>            } <br>        } <br>        if (CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, cbBuffer, cbProperties) &amp;&amp; <br>            CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, lActual, cbProperties)) { <br> <br>            /*  Check lActual */ <br>            if (pProps-&gt;cbBuffer &lt; pProps-&gt;lActual) { <br>                return E_INVALIDARG; <br>            } <br>        } <br> <br>        if (CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, pMediaType, cbProperties)) { <br> <br>            /*  Check pMediaType */ <br>            if (pProps-&gt;dwSampleFlags &amp; AM_SAMPLE_TYPECHANGED) { <br>                CheckPointer(pProps-&gt;pMediaType, E_POINTER); <br>                pMediaType = CreateMediaType(pProps-&gt;pMediaType); <br>                if (pMediaType == NULL) { <br>                    return E_OUTOFMEMORY; <br>                } <br>            } <br>        } <br> <br>        /*  Now do the assignments */ <br>        if (CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, dwStreamId, cbProperties)) { <br>            m_dwStreamId = pProps-&gt;dwStreamId; <br>        } <br>        if (CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, dwSampleFlags, cbProperties)) { <br>            /*  Set the flags */ <br>            m_dwFlags = pProps-&gt;dwSampleFlags | <br>                                (m_dwFlags &amp; Sample_MediaTimeValid); <br>            m_dwTypeSpecificFlags = pProps-&gt;dwTypeSpecificFlags; <br>        } else { <br>            if (CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, dwTypeSpecificFlags, cbProperties)) { <br>                m_dwTypeSpecificFlags = pProps-&gt;dwTypeSpecificFlags; <br>            } <br>        } <br> <br>        if (CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, lActual, cbProperties)) { <br>            /*  Set lActual */ <br>            m_lActual = pProps-&gt;lActual; <br>        } <br> <br>        if (CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, tStop, cbProperties)) { <br> <br>            /*  Set the times */ <br>            m_End   = pProps-&gt;tStop; <br>        } <br>        if (CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, tStart, cbProperties)) { <br> <br>            /*  Set the times */ <br>            m_Start = pProps-&gt;tStart; <br>        } <br> <br>        if (CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, pMediaType, cbProperties)) { <br>            /*  Set pMediaType */ <br>            if (pProps-&gt;dwSampleFlags &amp; AM_SAMPLE_TYPECHANGED) { <br>                if (m_pMediaType != NULL) { <br>                    DeleteMediaType(m_pMediaType); <br>                } <br>                m_pMediaType = pMediaType; <br>            } <br>        } <br>    } <br> <br>    return S_OK; <br>} <br> <br>//===================================================================== <br>//===================================================================== <br>// Implements CBaseAllocator <br>//===================================================================== <br>//===================================================================== <br> <br> <br>/* Constructor overrides the default settings for the free list to request <br>   that it be alertable (ie the list can be cast to a handle which can be <br>   passed to WaitForSingleObject). Both of the allocator lists also ask for <br>   object locking, the all list matches the object default settings but I <br>   have included them here just so it is obvious what kind of list it is */ <br> <br>CBaseAllocator::CBaseAllocator(TCHAR *pName, <br>       LPUNKNOWN pUnk, <br>       HRESULT *phr, <br>                               BOOL bEvent) : <br>    CUnknown(pName, pUnk), <br>    m_lAllocated(0), <br>    m_bChanged(FALSE), <br>    m_bCommitted(FALSE), <br>    m_bDecommitInProgress(FALSE), <br>    m_lSize(0), <br>    m_lCount(0), <br>    m_lAlignment(0), <br>    m_lPrefix(0), <br>    m_hSem(NULL), <br>    m_lWaiting(0) <br>{ <br>    if (bEvent) { <br>        m_hSem = CreateSemaphore(NULL, 0, 0x7FFFFFFF, NULL); <br>        if (m_hSem == NULL) { <br>            *phr = E_OUTOFMEMORY; <br>            return; <br>        } <br>    } <br>} <br> <br> <br>/* Destructor */ <br> <br>CBaseAllocator::~CBaseAllocator() <br>{ <br>    // we can't call Decommit here since that would mean a call to a <br>    // pure virtual in destructor. <br>    // We must assume that the derived class has gone into decommit state in <br>    // its destructor. <br>    ASSERT(!m_bCommitted); <br>    if (m_hSem != NULL) { <br>        EXECUTE_ASSERT(CloseHandle(m_hSem)); <br>    } <br>} <br> <br> <br>/* Override this to publicise our interfaces */ <br> <br>STDMETHODIMP <br>CBaseAllocator::NonDelegatingQueryInterface(REFIID riid, void **ppv) <br>{ <br>    /* Do we know about this interface */ <br> <br>    if (riid == IID_IMemAllocator) { <br>        return GetInterface((IMemAllocator *) this, ppv); <br>    } else { <br>        return CUnknown::NonDelegatingQueryInterface(riid, ppv); <br>    } <br>} <br> <br> <br>/* This sets the size and count of the required samples. The memory isn't <br>   actually allocated until Commit() is called, if memory has already been <br>   allocated then assuming no samples are outstanding the user may call us <br>   to change the buffering, the memory will be released in Commit() */ <br> <br>STDMETHODIMP <br>CBaseAllocator::SetProperties( <br>                ALLOCATOR_PROPERTIES* pRequest, <br>                ALLOCATOR_PROPERTIES* pActual) <br>{ <br>    CheckPointer(pRequest, E_POINTER); <br>    CheckPointer(pActual, E_POINTER); <br>    ValidateReadWritePtr(pActual, sizeof(ALLOCATOR_PROPERTIES)); <br>    CAutoLock cObjectLock(this); <br> <br>    ZeroMemory(pActual, sizeof(ALLOCATOR_PROPERTIES)); <br> <br>    ASSERT(pRequest-&gt;cbBuffer &gt; 0); <br> <br>    /*  Check the alignment requested */ <br>    if (pRequest-&gt;cbAlign != 1) { <br>DbgLog((LOG_ERROR, 2, TEXT("Alignment requested was 0x%x, not 1"), <br>       pRequest-&gt;cbAlign)); <br>return VFW_E_BADALIGN; <br>    } <br> <br>    /* Can't do this if already committed, there is an argument that says we <br>       should not reject the SetProperties call if there are buffers still <br>       active. However this is called by the source filter, which is the same <br>       person who is holding the samples. Therefore it is not unreasonable <br>       for them to free all their samples before changing the requirements */ <br> <br>    if (m_bCommitted) { <br>return VFW_E_ALREADY_COMMITTED; <br>    } <br> <br>    /* Must be no outstanding buffers */ <br> <br>    if (m_lAllocated != m_lFree.GetCount()) { <br>return VFW_E_BUFFERS_OUTSTANDING; <br>    } <br> <br>    /* There isn't any real need to check the parameters as they <br>       will just be rejected when the user finally calls Commit */ <br> <br>    pActual-&gt;cbBuffer = m_lSize = pRequest-&gt;cbBuffer; <br>    pActual-&gt;cBuffers = m_lCount = pRequest-&gt;cBuffers; <br>    pActual-&gt;cbAlign = m_lAlignment = pRequest-&gt;cbAlign; <br>    pActual-&gt;cbPrefix = m_lPrefix = pRequest-&gt;cbPrefix; <br> <br>    m_bChanged = TRUE; <br>    return NOERROR; <br>} <br> <br>STDMETHODIMP <br>CBaseAllocator::GetProperties( <br>    ALLOCATOR_PROPERTIES * pActual) <br>{ <br>    CheckPointer(pActual,E_POINTER); <br>    ValidateReadWritePtr(pActual,sizeof(ALLOCATOR_PROPERTIES)); <br> <br>    CAutoLock cObjectLock(this); <br>    pActual-&gt;cbBuffer = m_lSize; <br>    pActual-&gt;cBuffers = m_lCount; <br>    pActual-&gt;cbAlign = m_lAlignment; <br>    pActual-&gt;cbPrefix = m_lPrefix; <br>    return NOERROR; <br>} <br> <br>// get container for a sample. Blocking, synchronous call to get the <br>// next free buffer (as represented by an IMediaSample interface). <br>// on return, the time etc properties will be invalid, but the buffer <br>// pointer and size will be correct. <br> <br>HRESULT CBaseAllocator::GetBuffer(IMediaSample **ppBuffer, <br>                                  REFERENCE_TIME *pStartTime, <br>                                  REFERENCE_TIME *pEndTime, <br>                                  DWORD dwFlags <br>                                  ) <br>{ <br>    UNREFERENCED_PARAMETER(pStartTime); <br>    UNREFERENCED_PARAMETER(pEndTime); <br>    UNREFERENCED_PARAMETER(dwFlags); <br>    CMediaSample *pSample; <br> <br>    *ppBuffer = NULL; <br>    for (;;) <br>    { <br>        {  // scope for lock <br>            CAutoLock cObjectLock(this); <br> <br>            /* Check we are committed */ <br>            if (!m_bCommitted) { <br>                return VFW_E_NOT_COMMITTED; <br>            } <br>            pSample = (CMediaSample *) m_lFree.RemoveHead(); <br>            if (pSample == NULL) { <br>                SetWaiting(); <br>            } <br>        } <br> <br>        /* If we didn't get a sample then wait for the list to signal */ <br> <br>        if (pSample) { <br>            break; <br>        } <br>        if (dwFlags &amp; AM_GBF_NOWAIT) { <br>            return VFW_E_TIMEOUT; <br>        } <br>        ASSERT(m_hSem != NULL); <br>        WaitForSingleObject(m_hSem, INFINITE); <br>    } <br> <br>    /* Addref the buffer up to one. On release <br>       back to zero instead of being deleted, it will requeue itself by <br>       calling the ReleaseBuffer member function. NOTE the owner of a <br>       media sample must always be derived from CBaseAllocator */ <br> <br> <br>    ASSERT(pSample-&gt;m_cRef == 0); <br>    pSample-&gt;m_cRef = 1; <br>    *ppBuffer = pSample; <br> <br>    return NOERROR; <br>} <br> <br> <br>/* Final release of a CMediaSample will call this */ <br> <br>STDMETHODIMP <br>CBaseAllocator::ReleaseBuffer(IMediaSample * pSample) <br>{ <br>    CheckPointer(pSample,E_POINTER); <br>    ValidateReadPtr(pSample,sizeof(IMediaSample)); <br>    BOOL bRelease = FALSE; <br>    { <br>        CAutoLock cal(this); <br> <br>        /* Put back on the free list */ <br> <br>        m_lFree.Add((CMediaSample *)pSample); <br>        if (m_lWaiting != 0) { <br>            NotifySample(); <br>        } <br> <br>        // if there is a pending Decommit, then we need to complete it by <br>        // calling Free() when the last buffer is placed on the free list <br> <br>    LONG l1 = m_lFree.GetCount(); <br>    if (m_bDecommitInProgress &amp;&amp; (l1 == m_lAllocated)) { <br>        Free(); <br>        m_bDecommitInProgress = FALSE; <br>            bRelease = TRUE; <br>    } <br>    } <br> <br>    /* For each buffer there is one AddRef, made in GetBuffer and released <br>       here. This may cause the allocator and all samples to be deleted */ <br> <br>    if (bRelease) { <br>        Release(); <br>    } <br>    return NOERROR; <br>} <br> <br>void <br>CBaseAllocator::NotifySample() <br>{ <br>    if (m_lWaiting != 0) { <br>        ASSERT(m_hSem != NULL); <br>        ReleaseSemaphore(m_hSem, m_lWaiting, 0); <br>        m_lWaiting = 0; <br>    } <br>} <br> <br>STDMETHODIMP <br>CBaseAllocator::Commit() <br>{ <br>    /* Check we are not decommitted */ <br>    CAutoLock cObjectLock(this); <br> <br>    // cannot need to alloc or re-alloc if we are committed <br>    if (m_bCommitted) { <br>        return NOERROR; <br>    } <br> <br>    /* Allow GetBuffer calls */ <br> <br>    m_bCommitted = TRUE; <br> <br>    // is there a pending decommit ? if so, just cancel it <br>    if (m_bDecommitInProgress) { <br>        m_bDecommitInProgress = FALSE; <br> <br>        // don't call Alloc at this point. He cannot allow SetProperties <br>        // between Decommit and the last free, so the buffer size cannot have <br>        // changed. And because some of the buffers are not free yet, he <br>        // cannot re-alloc anyway. <br>        return NOERROR; <br>    } <br> <br>    DbgLog((LOG_MEMORY, 1, TEXT("Allocating: %ldx%ld"), m_lCount, m_lSize)); <br> <br>    // actually need to allocate the samples <br>    HRESULT hr = Alloc(); <br>    if (FAILED(hr)) { <br>        m_bCommitted = FALSE; <br>        return hr; <br>    } <br>    AddRef(); <br>    return NOERROR; <br>} <br> <br> <br>STDMETHODIMP <br>CBaseAllocator::Decommit() <br>{ <br>    BOOL bRelease = FALSE; <br>    { <br>        /* Check we are not already decommitted */ <br>        CAutoLock cObjectLock(this); <br>        if (m_bCommitted == FALSE) { <br>            if (m_bDecommitInProgress == FALSE) { <br>                return NOERROR; <br>            } <br>        } <br> <br>        /* No more GetBuffer calls will succeed */ <br>        m_bCommitted = FALSE; <br> <br>        // are any buffers outstanding? <br>        if (m_lFree.GetCount() &lt; m_lAllocated) { <br>            // please complete the decommit when last buffer is freed <br>            m_bDecommitInProgress = TRUE; <br>        } else { <br>            m_bDecommitInProgress = FALSE; <br> <br>            // need to complete the decommit here as there are no <br>            // outstanding buffers <br> <br>            Free(); <br>            bRelease = TRUE; <br>        } <br> <br>        // Tell anyone waiting that they can go now so we can <br>        // reject their call <br>        NotifySample(); <br>    } <br> <br>    if (bRelease) { <br>        Release(); <br>    } <br>    return NOERROR; <br>} <br> <br> <br>/* Base definition of allocation which checks we are ok to go ahead and do <br>   the full allocation. We return S_FALSE if the requirements are the same */ <br> <br>HRESULT <br>CBaseAllocator::Alloc(void) <br>{ <br>    /* Error if he hasn't set the size yet */ <br>    if (m_lCount &lt;= 0 || m_lSize &lt;= 0 || m_lAlignment &lt;= 0) { <br>return VFW_E_SIZENOTSET; <br>    } <br> <br>    /* should never get here while buffers outstanding */ <br>    ASSERT(m_lFree.GetCount() == m_lAllocated); <br> <br>    /* If the requirements haven't changed then don't reallocate */ <br>    if (m_bChanged == FALSE) { <br>return S_FALSE; <br>    } <br> <br>    return NOERROR; <br>} <br> <br>/*  Implement CBaseAllocator::CSampleList::Remove(pSample) <br>    Removes pSample from the list <br>*/ <br>void <br>CBaseAllocator::CSampleList::Remove(CMediaSample * pSample) <br>{ <br>    CMediaSample **pSearch; <br>    for (pSearch = &amp;m_List; <br>         *pSearch != NULL; <br>         pSearch = &amp;(CBaseAllocator::NextSample(*pSearch))) { <br>       if (*pSearch == pSample) { <br>           *pSearch = CBaseAllocator::NextSample(pSample); <br>           CBaseAllocator::NextSample(pSample) = NULL; <br>           m_nOnList--; <br>           return; <br>       } <br>    } <br>    DbgBreak("Couldn't find sample in list"); <br>} <br> <br>//===================================================================== <br>//===================================================================== <br>// Implements CMemAllocator <br>//===================================================================== <br>//===================================================================== <br> <br> <br>/* This goes in the factory template table to create new instances */ <br>CUnknown *CMemAllocator::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr) <br>{ <br>    CUnknown *pUnkRet = new CMemAllocator(NAME("CMemAllocator"), pUnk, phr); <br>    return pUnkRet; <br>} <br> <br>CMemAllocator::CMemAllocator( <br>    TCHAR *pName, <br>    LPUNKNOWN pUnk, <br>    HRESULT *phr) <br>    : CBaseAllocator(pName, pUnk, phr), <br>    m_pBuffer(NULL) <br>{ <br>} <br> <br>/* This sets the size and count of the required samples. The memory isn't <br>   actually allocated until Commit() is called, if memory has already been <br>   allocated then assuming no samples are outstanding the user may call us <br>   to change the buffering, the memory will be released in Commit() */ <br>STDMETHODIMP <br>CMemAllocator::SetProperties( <br>                ALLOCATOR_PROPERTIES* pRequest, <br>                ALLOCATOR_PROPERTIES* pActual) <br>{ <br>    CheckPointer(pActual,E_POINTER); <br>    ValidateReadWritePtr(pActual,sizeof(ALLOCATOR_PROPERTIES)); <br>    CAutoLock cObjectLock(this); <br> <br>    ZeroMemory(pActual, sizeof(ALLOCATOR_PROPERTIES)); <br> <br>    ASSERT(pRequest-&gt;cbBuffer &gt; 0); <br> <br>    SYSTEM_INFO SysInfo; <br>    GetSystemInfo(&amp;SysInfo); <br> <br>    /*  Check the alignment request is a power of 2 */ <br>    if ((-pRequest-&gt;cbAlign &amp; pRequest-&gt;cbAlign) != pRequest-&gt;cbAlign) { <br>DbgLog((LOG_ERROR, 1, TEXT("Alignment requested 0x%x not a power of 2!"), <br>       pRequest-&gt;cbAlign)); <br>    } <br>    /*  Check the alignment requested */ <br>    if (pRequest-&gt;cbAlign == 0 || <br>SysInfo.dwAllocationGranularity &amp; (pRequest-&gt;cbAlign - 1) != 0) { <br>DbgLog((LOG_ERROR, 1, TEXT("Invalid alignment 0x%x requested - granularity = 0x%x"), <br>       pRequest-&gt;cbAlign, SysInfo.dwAllocationGranularity)); <br>return VFW_E_BADALIGN; <br>    } <br> <br>    /* Can't do this if already committed, there is an argument that says we <br>       should not reject the SetProperties call if there are buffers still <br>       active. However this is called by the source filter, which is the same <br>       person who is holding the samples. Therefore it is not unreasonable <br>       for them to free all their samples before changing the requirements */ <br> <br>    if (m_bCommitted == TRUE) { <br>return VFW_E_ALREADY_COMMITTED; <br>    } <br> <br>    /* Must be no outstanding buffers */ <br> <br>    if (m_lFree.GetCount() &lt; m_lAllocated) { <br>return VFW_E_BUFFERS_OUTSTANDING; <br>    } <br> <br>    /* There isn't any real need to check the parameters as they <br>       will just be rejected when the user finally calls Commit */ <br> <br>    // round length up to alignment - remember that prefix is included in <br>    // the alignment <br>    LONG lSize = pRequest-&gt;cbBuffer + pRequest-&gt;cbPrefix; <br>    LONG lRemainder = lSize % pRequest-&gt;cbAlign; <br>    if (lRemainder != 0) { <br>lSize = lSize - lRemainder + pRequest-&gt;cbAlign; <br>    } <br>    pActual-&gt;cbBuffer = m_lSize = (lSize - pRequest-&gt;cbPrefix); <br> <br>    pActual-&gt;cBuffers = m_lCount = pRequest-&gt;cBuffers; <br>    pActual-&gt;cbAlign = m_lAlignment = pRequest-&gt;cbAlign; <br>    pActual-&gt;cbPrefix = m_lPrefix = pRequest-&gt;cbPrefix; <br> <br>    m_bChanged = TRUE; <br>    return NOERROR; <br>} <br> <br>// override this to allocate our resources when Commit is called. </code></pre>
<p>
</p>
<pre><code>// <br>// note that our resources may be already allocated when this is called, <br>// since we don't free them on Decommit. We will only be called when in <br>// decommit state with all buffers free. <br>// <br>// object locked by caller <br>HRESULT <br>CMemAllocator::Alloc(void) <br>{ <br>    CAutoLock lck(this); <br> <br>    /* Check he has called SetProperties */ <br>    HRESULT hr = CBaseAllocator::Alloc(); <br>    if (FAILED(hr)) { <br>return hr; <br>    } <br> <br>    /* If the requirements haven't changed then don't reallocate */ <br>    if (hr == S_FALSE) { <br>ASSERT(m_pBuffer); <br>return NOERROR; <br>    } <br>    ASSERT(hr == S_OK); // we use this fact in the loop below <br> <br>    /* Free the old resources */ <br>    if (m_pBuffer) { <br>ReallyFree(); <br>    } <br> <br>    /* Create the contiguous memory block for the samples <br>       making sure it's properly aligned (64K should be enough!) <br>    */ <br>    ASSERT(m_lAlignment != 0 &amp;&amp; <br>   (m_lSize + m_lPrefix) % m_lAlignment == 0); <br> <br>    m_pBuffer = (PBYTE)VirtualAlloc(NULL, <br>    m_lCount * (m_lSize + m_lPrefix), <br>    MEM_COMMIT, <br>    PAGE_READWRITE); <br> <br>    if (m_pBuffer == NULL) { <br>return E_OUTOFMEMORY; <br>    } <br> <br>    LPBYTE pNext = m_pBuffer; <br>    CMediaSample *pSample; <br> <br>    ASSERT(m_lAllocated == 0); <br> <br>    // Create the new samples - we have allocated m_lSize bytes for each sample <br>    // plus m_lPrefix bytes per sample as a prefix. We set the pointer to <br>    // the memory after the prefix - so that GetPointer() will return a pointer <br>    // to m_lSize bytes. <br>    for (; m_lAllocated &lt; m_lCount; m_lAllocated++, pNext += (m_lSize + m_lPrefix)) { <br> <br> <br>pSample = new CMediaSample( <br>                        NAME("Default memory media sample"), <br>this, <br>                        &amp;hr, <br>                        pNext + m_lPrefix,      // GetPointer() value <br>                        m_lSize);               // not including prefix <br> <br>        ASSERT(SUCCEEDED(hr)); <br>if (pSample == NULL) { <br>    return E_OUTOFMEMORY; <br>} <br> <br>// This CANNOT fail <br>m_lFree.Add(pSample); <br>    } <br> <br>    m_bChanged = FALSE; <br>    return NOERROR; <br>} <br> <br> <br>// override this to free up any resources we have allocated. <br>// called from the base class on Decommit when all buffers have been <br>// returned to the free list. <br>// <br>// caller has already locked the object. <br> <br>// in our case, we keep the memory until we are deleted, so <br>// we do nothing here. The memory is deleted in the destructor by <br>// calling ReallyFree() <br>void <br>CMemAllocator::Free(void) <br>{ <br>    return; <br>} <br> <br> <br>// called from the destructor (and from Alloc if changing size/count) to <br>// actually free up the memory <br>void <br>CMemAllocator::ReallyFree(void) <br>{ <br>    /* Should never be deleting this unless all buffers are freed */ <br> <br>    ASSERT(m_lAllocated == m_lFree.GetCount()); <br> <br>    /* Free up all the CMediaSamples */ <br> <br>    CMediaSample *pSample; <br>    for (;;) { <br>        pSample = m_lFree.RemoveHead(); <br>        if (pSample != NULL) { <br>            delete pSample; <br>        } else { <br>            break; <br>        } <br>    } <br> <br>    m_lAllocated = 0; <br> <br>    // free the block of buffer memory <br>    if (m_pBuffer) { <br>EXECUTE_ASSERT(VirtualFree(m_pBuffer, 0, MEM_RELEASE)); <br>m_pBuffer = NULL; <br>    } <br>} <br> <br> <br>/* Destructor frees our memory resources */ <br> <br>CMemAllocator::~CMemAllocator() <br>{ <br>    Decommit(); <br>    ReallyFree(); <br>} <br> <br>// ------------------------------------------------------------------------ <br>// filter registration through IFilterMapper. used if IFilterMapper is <br>// not found (Quartz 1.0 install) <br> <br>STDAPI <br>AMovieSetupRegisterFilter( const AMOVIESETUP_FILTER * const psetupdata <br>                         , IFilterMapper *                  pIFM <br>                         , BOOL                             bRegister  ) <br>{ <br>  DbgLog((LOG_TRACE, 3, TEXT("= AMovieSetupRegisterFilter"))); <br> <br>  // check we've got data <br>  // <br>  if( NULL == psetupdata ) return S_FALSE; <br> <br> <br>  // unregister filter <br>  // (as pins are subkeys of filter's CLSID key <br>  // they do not need to be removed separately). <br>  // <br>  DbgLog((LOG_TRACE, 3, TEXT("= = unregister filter"))); <br>  HRESULT hr = pIFM-&gt;UnregisterFilter( *(psetupdata-&gt;clsID) ); <br> <br> <br>  if( bRegister ) <br>  { <br>    // register filter <br>    // <br>    DbgLog((LOG_TRACE, 3, TEXT("= = register filter"))); <br>    hr = pIFM-&gt;RegisterFilter( *(psetupdata-&gt;clsID) <br>                             , psetupdata-&gt;strName <br>                             , psetupdata-&gt;dwMerit    ); <br>    if( SUCCEEDED(hr) ) <br>    { <br>      // all its pins <br>      // <br>      DbgLog((LOG_TRACE, 3, TEXT("= = register filter pins"))); <br>      for( UINT m1=0; m1 &lt; psetupdata-&gt;nPins; m1++ ) <br>      { <br>        hr = pIFM-&gt;RegisterPin( *(psetupdata-&gt;clsID) <br>                              , psetupdata-&gt;lpPin[m1].strName <br>                              , psetupdata-&gt;lpPin[m1].bRendered <br>                              , psetupdata-&gt;lpPin[m1].bOutput <br>                              , psetupdata-&gt;lpPin[m1].bZero <br>                              , psetupdata-&gt;lpPin[m1].bMany <br>                              , *(psetupdata-&gt;lpPin[m1].clsConnectsToFilter) <br>                              , psetupdata-&gt;lpPin[m1].strConnectsToPin ); <br> <br>        if( SUCCEEDED(hr) ) <br>        { <br>          // and each pin's media types <br>          // <br>          DbgLog((LOG_TRACE, 3, TEXT("= = register filter pin types"))); <br>          for( UINT m2=0; m2 &lt; psetupdata-&gt;lpPin[m1].nMediaTypes; m2++ ) <br>          { <br>            hr = pIFM-&gt;RegisterPinType( *(psetupdata-&gt;clsID) <br>                                      , psetupdata-&gt;lpPin[m1].strName <br>                                      , *(psetupdata-&gt;lpPin[m1].lpMediaType[m2].clsMajorType) <br>                                      , *(psetupdata-&gt;lpPin[m1].lpMediaType[m2].clsMinorType) ); <br>            if( FAILED(hr) ) break; <br>          } <br>          if( FAILED(hr) ) break; <br>        } <br>        if( FAILED(hr) ) break; <br>      } <br>    } <br>  } <br> <br>  // handle one acceptable "error" - that <br>  // of filter not being registered! <br>  // (couldn't find a suitable #define'd <br>  // name for the error!) <br>  // <br>  if( 0x80070002 == hr) <br>    return NOERROR; <br>  else <br>    return hr; <br>} <br> <br> <br>//  Remove warnings about unreferenced inline functions <br>#pragma warning(disable:4514) <br> <br> <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
