<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PULLPIN.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2759"></a>PULLPIN.CPP</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>// implementation of CPullPin class - pulls data from IAsyncReader <br> <br>#include &lt;streams.h&gt; <br>#include "pullpin.h" <br> <br> <br> <br>CPullPin::CPullPin() <br>  : m_pReader(NULL), <br>    m_pAlloc(NULL), <br>    m_State(TM_Exit) <br>{ <br> <br>} <br> <br>CPullPin::~CPullPin() <br>{ <br>    Disconnect(); <br>} <br> <br>// returns S_OK if successfully connected to an IAsyncReader interface <br>// from this object <br>// Optional allocator should be proposed as a preferred allocator if <br>// necessary <br>HRESULT <br>CPullPin::Connect(IUnknown* pUnk, IMemAllocator* pAlloc, BOOL bSync) <br>{ <br>    CAutoLock lock(&amp;m_AccessLock); <br> <br>    if (m_pReader) { <br>return VFW_E_ALREADY_CONNECTED; <br>    } <br> <br>    HRESULT hr = pUnk-&gt;QueryInterface(IID_IAsyncReader, (void**)&amp;m_pReader); <br>    if (FAILED(hr)) { <br>return(hr); <br>    } <br> <br>    hr = DecideAllocator(pAlloc, NULL); <br>    if (FAILED(hr)) { <br>Disconnect(); <br>return hr; <br>    } <br> <br>    LONGLONG llTotal, llAvail; <br>    hr = m_pReader-&gt;Length(&amp;llTotal, &amp;llAvail); <br>    if (FAILED(hr)) { <br>Disconnect(); <br>return hr; <br>    } <br> <br>    // convert from file position to reference time <br>    m_tDuration = llTotal * UNITS; <br>    m_tStop = m_tDuration; <br>    m_tStart = 0; <br> <br>    m_bSync = bSync; <br> <br>    return S_OK; <br>} <br> <br>// disconnect any connection made in Connect <br>HRESULT <br>CPullPin::Disconnect() <br>{ <br>    CAutoLock lock(&amp;m_AccessLock); <br> <br>    StopThread(); <br> <br>    if (m_pReader) { <br>m_pReader-&gt;Release(); <br>m_pReader = NULL; <br>    } <br> <br>    if (m_pAlloc) { <br>m_pAlloc-&gt;Release(); <br>m_pAlloc = NULL; <br>    } <br>    return S_OK; <br>} <br> <br>// agree an allocator using RequestAllocator - optional <br>// props param specifies your requirements (non-zero fields). <br>// returns an error code if fail to match requirements. <br>// optional IMemAllocator interface is offered as a preferred allocator <br>// but no error occurs if it can't be met. <br>HRESULT <br>CPullPin::DecideAllocator( <br>    IMemAllocator * pAlloc, <br>    ALLOCATOR_PROPERTIES * pProps) <br>{ <br>    ALLOCATOR_PROPERTIES *pRequest; <br>    ALLOCATOR_PROPERTIES Request; <br>    if (pProps == NULL) { <br>Request.cBuffers = 3; <br>Request.cbBuffer = 64*1024; <br>Request.cbAlign = 0; <br>Request.cbPrefix = 0; <br>pRequest = &amp;Request; <br>    } else { <br>pRequest = pProps; <br>    } <br>    HRESULT hr = m_pReader-&gt;RequestAllocator( <br>    pAlloc, <br>    pRequest, <br>    &amp;m_pAlloc); <br>    return hr; <br>} <br> <br>// start pulling data <br>HRESULT <br>CPullPin::Active(void) <br>{ <br>    ASSERT(!ThreadExists()); <br>    return StartThread(); <br>} <br> <br>// stop pulling data <br>HRESULT <br>CPullPin::Inactive(void) <br>{ <br>    StopThread(); <br> <br>    return S_OK; <br>} <br> <br>HRESULT <br>CPullPin::Seek(REFERENCE_TIME tStart, REFERENCE_TIME tStop) <br>{ <br>    CAutoLock lock(&amp;m_AccessLock); <br> <br>    ThreadMsg AtStart = m_State; <br> <br>    if (AtStart == TM_Start) { <br>BeginFlush(); <br>PauseThread(); <br>EndFlush(); <br>    } <br> <br>    m_tStart = tStart; <br>    m_tStop = tStop; <br> <br>    HRESULT hr = S_OK; <br>    if (AtStart == TM_Start) { <br>hr = StartThread(); <br>    } <br> <br>    return hr; <br>} <br> <br>HRESULT <br>CPullPin::Duration(REFERENCE_TIME* ptDuration) <br>{ <br>    *ptDuration = m_tDuration; <br>    return S_OK; <br>} <br> <br> <br>HRESULT <br>CPullPin::StartThread() <br>{ <br>    CAutoLock lock(&amp;m_AccessLock); <br> <br>    if (!m_pAlloc || !m_pReader) { <br>return E_UNEXPECTED; <br>    } <br> <br>    HRESULT hr; <br>    if (!ThreadExists()) { <br> <br>// commit allocator <br>hr = m_pAlloc-&gt;Commit(); <br>if (FAILED(hr)) { <br>    return hr; <br>} <br> <br>// start thread <br>if (!Create()) { <br>    return E_FAIL; <br>} <br>    } <br> <br>    m_State = TM_Start; <br>    hr = (HRESULT) CallWorker(m_State); <br>    return hr; <br>} <br> <br>HRESULT <br>CPullPin::PauseThread() <br>{ <br>    CAutoLock lock(&amp;m_AccessLock); <br> <br>    if (!ThreadExists()) { <br>return E_UNEXPECTED; <br>    } <br> <br>    // need to flush to ensure the thread is not blocked <br>    // in WaitForNext <br>    HRESULT hr = m_pReader-&gt;BeginFlush(); <br>    if (FAILED(hr)) { <br>return hr; <br>    } <br> <br>    m_State = TM_Pause; <br>    hr = CallWorker(TM_Pause); <br> <br>    m_pReader-&gt;EndFlush(); <br>    return hr; <br>} <br> <br>HRESULT <br>CPullPin::StopThread() <br>{ <br>    CAutoLock lock(&amp;m_AccessLock); <br> <br>    if (!ThreadExists()) { <br>return S_FALSE; <br>    } <br> <br>    // need to flush to ensure the thread is not blocked <br>    // in WaitForNext <br>    HRESULT hr = m_pReader-&gt;BeginFlush(); <br>    if (FAILED(hr)) { <br>return hr; <br>    } <br> <br>    m_State = TM_Exit; <br>    hr = CallWorker(TM_Exit); <br> <br>    m_pReader-&gt;EndFlush(); <br> <br>    // wait for thread to completely exit <br>    Close(); <br> <br>    // decommit allocator <br>    if (m_pAlloc) { <br>m_pAlloc-&gt;Decommit(); <br>    } <br> <br>    return S_OK; <br>} <br> <br> <br>DWORD <br>CPullPin::ThreadProc(void) <br>{ <br>    while(1) { <br>DWORD cmd = GetRequest(); <br>switch(cmd) { <br>case TM_Exit: <br>    Reply(S_OK); <br>    return 0; <br> <br>case TM_Pause: <br>    // we are paused already <br>    Reply(S_OK); <br>    break; <br> <br>case TM_Start: <br>    Reply(S_OK); <br>    Process(); <br>    break; <br>} <br> <br>// at this point, there should be no outstanding requests on the <br>// upstream filter. <br>// We should force begin/endflush to ensure that this is true. <br>// !!!Note that we may currently be inside a BeginFlush/EndFlush pair <br>// on another thread, but the premature EndFlush will do no harm now <br>// that we are idle. <br>m_pReader-&gt;BeginFlush(); <br>CleanupCancelled(); <br>m_pReader-&gt;EndFlush(); <br>    } <br>} <br> <br>HRESULT <br>CPullPin::QueueSample( <br>    REFERENCE_TIME&amp; tCurrent, <br>    REFERENCE_TIME tAlignStop, <br>    BOOL bDiscontinuity <br>    ) <br>{ <br>    IMediaSample* pSample; <br> <br>    HRESULT hr = m_pAlloc-&gt;GetBuffer(&amp;pSample, NULL, NULL, 0); <br>    if (FAILED(hr)) { <br>return hr; <br>    } <br> <br>    LONGLONG tStopThis = tCurrent + (pSample-&gt;GetSize() * UNITS); <br>    if (tStopThis &gt; tAlignStop) { <br>tStopThis = tAlignStop; <br>    } <br>    pSample-&gt;SetTime(&amp;tCurrent, &amp;tStopThis); <br>    tCurrent = tStopThis; <br> <br>    pSample-&gt;SetDiscontinuity(bDiscontinuity); <br> <br>    hr = m_pReader-&gt;Request( <br>pSample, <br>0); <br>    if (FAILED(hr)) { <br>pSample-&gt;Release(); <br> <br>CleanupCancelled(); <br>OnError(hr); <br>    } <br>    return hr; <br>} <br> <br>HRESULT <br>CPullPin::CollectAndDeliver( <br>    REFERENCE_TIME tStart, <br>    REFERENCE_TIME tStop) <br>{ <br>    IMediaSample* pSample = NULL;   // better be sure pSample is set <br>    DWORD dwUnused; <br>    HRESULT hr = m_pReader-&gt;WaitForNext( <br>INFINITE, <br>&amp;pSample, <br>&amp;dwUnused); <br>    if (FAILED(hr)) { <br>if (pSample) { <br>    pSample-&gt;Release(); <br>} <br>    } else { <br>hr = DeliverSample(pSample, tStart, tStop); <br>    } <br>    if (FAILED(hr)) { <br>CleanupCancelled(); <br>OnError(hr); <br>    } <br>    return hr; <br> <br>} <br> <br>HRESULT <br>CPullPin::DeliverSample( <br>    IMediaSample* pSample, <br>    REFERENCE_TIME tStart, <br>    REFERENCE_TIME tStop <br>    ) <br>{ <br>    // fix up sample if past actual stop (for sector alignment) <br>    REFERENCE_TIME t1, t2; <br>    pSample-&gt;GetTime(&amp;t1, &amp;t2); <br>    if (t2 &gt; tStop) { <br>t2 = tStop; <br>    } <br> <br>    // adjust times to be relative to (aligned) start time <br>    t1 -= tStart; <br>    t2 -= tStart; <br>    pSample-&gt;SetTime(&amp;t1, &amp;t2); <br> <br>    HRESULT hr = Receive(pSample); <br>    pSample-&gt;Release(); <br>    return hr; <br>} <br> <br>void <br>CPullPin::Process(void) <br>{ <br>    // is there anything to do? <br>    if (m_tStop &lt;= m_tStart) { <br>EndOfStream(); <br>return; <br>    } <br> <br>    BOOL bDiscontinuity = TRUE; <br> <br>    // if there is more than one sample at the allocator, <br>    // then try to queue 2 at once in order to overlap. <br>    // -- get buffer count and required alignment <br>    ALLOCATOR_PROPERTIES Actual; <br>    HRESULT hr = m_pAlloc-&gt;GetProperties(&amp;Actual); <br> <br>    // align the start position downwards <br>    REFERENCE_TIME tStart = AlignDown(m_tStart / UNITS, Actual.cbAlign) * UNITS; <br>    REFERENCE_TIME tCurrent = tStart; <br> <br>    REFERENCE_TIME tStop = m_tStop; <br>    if (tStop &gt; m_tDuration) { <br>tStop = m_tDuration; <br>    } <br> <br>    // align the stop position - may be past stop, but that <br>    // doesn't matter <br>    REFERENCE_TIME tAlignStop = AlignUp(tStop / UNITS, Actual.cbAlign) * UNITS; <br> <br> <br>    DWORD dwRequest; <br> <br>    if (!m_bSync) { <br> <br>//  Break out of the loop either if we get to the end or we're asked <br>//  to do something else <br>while (tCurrent &lt; tAlignStop) { <br> <br>    // Break out without calling EndOfStream if we're asked to <br>    // do something different <br>    if (CheckRequest(&amp;dwRequest)) { <br>return; <br>    } <br> <br>    // queue a first sample <br>    if (Actual.cBuffers &gt; 1) { <br> <br>hr = QueueSample(tCurrent, tAlignStop, TRUE); <br>bDiscontinuity = FALSE; <br> <br>if (FAILED(hr)) { <br>    return; <br>} <br>    } <br> <br> <br> <br>    // loop queueing second and waiting for first.. <br>    while (tCurrent &lt; tAlignStop) { <br> <br>hr = QueueSample(tCurrent, tAlignStop, bDiscontinuity); <br>bDiscontinuity = FALSE; <br> <br>if (FAILED(hr)) { <br>    return; <br>} <br> <br>hr = CollectAndDeliver(tStart, tStop); <br>if (S_OK != hr) { <br> <br>    // stop if error, or if downstream filter said <br>    // to stop. <br>    return; <br>} <br>    } <br> <br>    if (Actual.cBuffers &gt; 1) { <br>hr = CollectAndDeliver(tStart, tStop); <br>if (FAILED(hr)) { <br>    return; <br>} <br>    } <br>} <br>    } else { <br> <br>// sync version of above loop <br>while (tCurrent &lt; tAlignStop) { <br> <br>    // Break out without calling EndOfStream if we're asked to <br>    // do something different <br>    if (CheckRequest(&amp;dwRequest)) { <br>return; <br>    } <br> <br>    IMediaSample* pSample; <br> <br>    hr = m_pAlloc-&gt;GetBuffer(&amp;pSample, NULL, NULL, 0); <br>    if (FAILED(hr)) { <br>OnError(hr); <br>return; <br>    } <br> <br>    LONGLONG tStopThis = tCurrent + (pSample-&gt;GetSize() * UNITS); <br>    if (tStopThis &gt; tAlignStop) { <br>tStopThis = tAlignStop; <br>    } <br>    pSample-&gt;SetTime(&amp;tCurrent, &amp;tStopThis); <br>    tCurrent = tStopThis; <br> <br>    if (bDiscontinuity) { <br>pSample-&gt;SetDiscontinuity(TRUE); <br>bDiscontinuity = FALSE; <br>    } <br> <br>    hr = m_pReader-&gt;SyncReadAligned(pSample); <br> <br>    if (FAILED(hr)) { <br>pSample-&gt;Release(); <br>OnError(hr); <br>return; <br>    } <br> <br>    hr = DeliverSample(pSample, tStart, tStop); <br>    if (hr != S_OK) { <br>if (FAILED(hr)) { <br>    OnError(hr); <br>} <br>return; <br>    } <br>} <br>    } <br> <br>    EndOfStream(); <br>} <br> <br>// after a flush, cancelled i/o will be waiting for collection <br>// and release <br>void <br>CPullPin::CleanupCancelled(void) <br>{ <br>    while (1) { <br>IMediaSample * pSample; <br>DWORD dwUnused; <br> <br>HRESULT hr = m_pReader-&gt;WaitForNext( <br>    0,          // no wait <br>    &amp;pSample, <br>    &amp;dwUnused); <br>if(pSample) { <br>    pSample-&gt;Release(); <br>} else { <br>    // no more samples <br>    return; <br>} <br>    } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
