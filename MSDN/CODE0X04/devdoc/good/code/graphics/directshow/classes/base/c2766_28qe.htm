<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WINCTRL.H</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2786"></a>WINCTRL.H</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>// Video control interface base classes, December 1995 <br> <br>#ifndef __WINCTRL__ <br>#define __WINCTRL__ <br> <br>#define ABSOL(x) (x &lt; 0 ? -x : x) <br>#define NEGAT(x) (x &gt; 0 ? -x : x) <br> <br>//  Helper <br>BOOL WINAPI PossiblyEatMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam); <br> <br>class CBaseControlWindow : public CBaseVideoWindow, public CBaseWindow <br>{ <br>protected: <br> <br>    CBaseFilter *m_pFilter;            // Pointer to owning media filter <br>    CBasePin *m_pPin;                  // Controls media types for connection <br>    CCritSec *m_pInterfaceLock;        // Externally defined critical section <br>    COLORREF m_BorderColour;           // Current window border colour <br>    BOOL m_bAutoShow;                  // What happens when the state changes <br>    HWND m_hwndOwner;                  // Owner window that we optionally have <br>    HWND m_hwndDrain;                  // HWND to post any messages received <br>    BOOL m_bCursorHidden;              // Should we hide the window cursor <br> <br>public: <br> <br>    // Internal methods for other objects to get information out <br> <br>    HRESULT DoSetWindowStyle(long Style,long WindowLong); <br>    HRESULT DoGetWindowStyle(long *pStyle,long WindowLong); <br>    BOOL IsAutoShowEnabled() { return m_bAutoShow; }; <br>    COLORREF GetBorderColour() { return m_BorderColour; }; <br>    HWND GetOwnerWindow() { return m_hwndOwner; }; <br>    BOOL IsCursorHidden() { return m_bCursorHidden; }; <br> <br>    inline BOOL PossiblyEatMessage(UINT uMsg, WPARAM wParam, LPARAM lParam) <br>    { <br>        return ::PossiblyEatMessage(m_hwndDrain, uMsg, wParam, lParam); <br>    } <br> <br>    // Derived classes must call this to set the pin the filter is using <br>    // We don't have the pin passed in to the constructor (as we do with <br>    // the CBaseFilter object) because filters typically create the <br>    // pins dynamically when requested in CBaseFilter::GetPin. This can <br>    // not be called from our constructor because is is a virtual method <br> <br>    void SetControlWindowPin(CBasePin *pPin) { <br>        m_pPin = pPin; <br>    } <br> <br>public: <br> <br>    CBaseControlWindow(CBaseFilter *pFilter,   // Owning media filter <br>                       CCritSec *pInterfaceLock,    // Locking object <br>                       TCHAR *pName,                // Object description <br>                       LPUNKNOWN pUnk,              // Normal COM ownership <br>                       HRESULT *phr);               // OLE return code <br> <br>    // These are the properties we support <br> <br>    STDMETHODIMP put_Caption(BSTR strCaption); <br>    STDMETHODIMP get_Caption(BSTR *pstrCaption); <br>    STDMETHODIMP put_AutoShow(long AutoShow); <br>    STDMETHODIMP get_AutoShow(long *AutoShow); <br>    STDMETHODIMP put_WindowStyle(long WindowStyle); <br>    STDMETHODIMP get_WindowStyle(long *pWindowStyle); <br>    STDMETHODIMP put_WindowStyleEx(long WindowStyleEx); <br>    STDMETHODIMP get_WindowStyleEx(long *pWindowStyleEx); <br>    STDMETHODIMP put_WindowState(long WindowState); <br>    STDMETHODIMP get_WindowState(long *pWindowState); <br>    STDMETHODIMP put_BackgroundPalette(long BackgroundPalette); <br>    STDMETHODIMP get_BackgroundPalette(long *pBackgroundPalette); <br>    STDMETHODIMP put_Visible(long Visible); <br>    STDMETHODIMP get_Visible(long *pVisible); <br>    STDMETHODIMP put_Left(long Left); <br>    STDMETHODIMP get_Left(long *pLeft); <br>    STDMETHODIMP put_Width(long Width); <br>    STDMETHODIMP get_Width(long *pWidth); <br>    STDMETHODIMP put_Top(long Top); <br>    STDMETHODIMP get_Top(long *pTop); <br>    STDMETHODIMP put_Height(long Height); <br>    STDMETHODIMP get_Height(long *pHeight); <br>    STDMETHODIMP put_Owner(OAHWND Owner); <br>    STDMETHODIMP get_Owner(OAHWND *Owner); <br>    STDMETHODIMP put_MessageDrain(OAHWND Drain); <br>    STDMETHODIMP get_MessageDrain(OAHWND *Drain); <br>    STDMETHODIMP get_BorderColor(long *Color); <br>    STDMETHODIMP put_BorderColor(long Color); <br>    STDMETHODIMP get_FullScreenMode(long *FullScreenMode); <br>    STDMETHODIMP put_FullScreenMode(long FullScreenMode); <br> <br>    // And these are the methods <br> <br>    STDMETHODIMP SetWindowForeground(long Focus); <br>    STDMETHODIMP NotifyOwnerMessage(long hwnd,long uMsg,long wParam,long lParam); <br>    STDMETHODIMP GetMinIdealImageSize(long *pWidth,long *pHeight); <br>    STDMETHODIMP GetMaxIdealImageSize(long *pWidth,long *pHeight); <br>    STDMETHODIMP SetWindowPosition(long Left,long Top,long Width,long Height); <br>    STDMETHODIMP GetWindowPosition(long *pLeft,long *pTop,long *pWidth,long *pHeight); <br>    STDMETHODIMP GetRestorePosition(long *pLeft,long *pTop,long *pWidth,long *pHeight); <br>STDMETHODIMP HideCursor(long HideCursor); <br>    STDMETHODIMP IsCursorHidden(long *CursorHidden); <br>}; <br> <br>// This class implements the IBasicVideo interface <br> <br>class CBaseControlVideo : public CBaseBasicVideo <br>{ <br>protected: <br> <br>    CBaseFilter *m_pFilter;   // Pointer to owning media filter <br>    CBasePin *m_pPin;                   // Controls media types for connection <br>    CCritSec *m_pInterfaceLock;         // Externally defined critical section <br> <br>public: <br> <br>    // Derived classes must provide these for the implementation <br> <br>    virtual HRESULT IsDefaultTargetRect() PURE; <br>    virtual HRESULT SetDefaultTargetRect() PURE; <br>    virtual HRESULT SetTargetRect(RECT *pTargetRect) PURE; <br>    virtual HRESULT GetTargetRect(RECT *pTargetRect) PURE; <br>    virtual HRESULT IsDefaultSourceRect() PURE; <br>    virtual HRESULT SetDefaultSourceRect() PURE; <br>    virtual HRESULT SetSourceRect(RECT *pSourceRect) PURE; <br>    virtual HRESULT GetSourceRect(RECT *pSourceRect) PURE; <br>    virtual HRESULT GetStaticImage(long *pBufferSize,long *pDIBImage) PURE; <br> <br>    // Derived classes must override this to return a VIDEOINFO representing <br>    // the video format. We cannot call IPin ConnectionMediaType to get this <br>    // format because various filters dynamically change the type when using <br>    // DirectDraw such that the format shows the position of the logical <br>    // bitmap in a frame buffer surface, so the size might be returned as <br>    // 1024x768 pixels instead of 320x240 which is the real video dimensions <br> <br>    virtual VIDEOINFOHEADER *GetVideoFormat() PURE; <br> <br>    // Helper functions for creating memory renderings of a DIB image <br> <br>    HRESULT GetImageSize(VIDEOINFOHEADER *pVideoInfo, <br>                         LONG *pBufferSize, <br>                         RECT *pSourceRect); <br> <br>    HRESULT CopyImage(IMediaSample *pMediaSample, <br>                      VIDEOINFOHEADER *pVideoInfo, <br>                      LONG *pBufferSize, <br>                      BYTE *pVideoImage, <br>                      RECT *pSourceRect); <br> <br>    // Override this if you want notifying when the rectangles change <br>    virtual HRESULT OnUpdateRectangles() { return NOERROR; }; <br>    virtual HRESULT OnVideoSizeChange(); <br> <br>    // Derived classes must call this to set the pin the filter is using <br>    // We don't have the pin passed in to the constructor (as we do with <br>    // the CBaseFilter object) because filters typically create the <br>    // pins dynamically when requested in CBaseFilter::GetPin. This can <br>    // not be called from our constructor because is is a virtual method <br> <br>    void SetControlVideoPin(CBasePin *pPin) { <br>        m_pPin = pPin; <br>    } <br> <br>    // Helper methods for checking rectangles <br>    virtual HRESULT CheckSourceRect(RECT *pSourceRect); <br>    virtual HRESULT CheckTargetRect(RECT *pTargetRect); <br> <br>public: <br> <br>    CBaseControlVideo(CBaseFilter *pFilter,    // Owning media filter <br>                      CCritSec *pInterfaceLock,     // Serialise interface <br>                      TCHAR *pName,                 // Object description <br>                      LPUNKNOWN pUnk,               // Normal COM ownership <br>                      HRESULT *phr);                // OLE return code <br> <br>    // These are the properties we support <br> <br>    STDMETHODIMP get_AvgTimePerFrame(REFTIME *pAvgTimePerFrame); <br>    STDMETHODIMP get_BitRate(long *pBitRate); <br>    STDMETHODIMP get_BitErrorRate(long *pBitErrorRate); <br>    STDMETHODIMP get_VideoWidth(long *pVideoWidth); <br>    STDMETHODIMP get_VideoHeight(long *pVideoHeight); <br>    STDMETHODIMP put_SourceLeft(long SourceLeft); <br>    STDMETHODIMP get_SourceLeft(long *pSourceLeft); <br>    STDMETHODIMP put_SourceWidth(long SourceWidth); <br>    STDMETHODIMP get_SourceWidth(long *pSourceWidth); <br>    STDMETHODIMP put_SourceTop(long SourceTop); <br>    STDMETHODIMP get_SourceTop(long *pSourceTop); <br>    STDMETHODIMP put_SourceHeight(long SourceHeight); <br>    STDMETHODIMP get_SourceHeight(long *pSourceHeight); <br>    STDMETHODIMP put_DestinationLeft(long DestinationLeft); <br>    STDMETHODIMP get_DestinationLeft(long *pDestinationLeft); <br>    STDMETHODIMP put_DestinationWidth(long DestinationWidth); <br>    STDMETHODIMP get_DestinationWidth(long *pDestinationWidth); <br>    STDMETHODIMP put_DestinationTop(long DestinationTop); <br>    STDMETHODIMP get_DestinationTop(long *pDestinationTop); <br>    STDMETHODIMP put_DestinationHeight(long DestinationHeight); <br>    STDMETHODIMP get_DestinationHeight(long *pDestinationHeight); <br> <br>    // And these are the methods <br> <br>    STDMETHODIMP GetVideoSize(long *pWidth,long *pHeight); <br>    STDMETHODIMP SetSourcePosition(long Left,long Top,long Width,long Height); <br>    STDMETHODIMP GetSourcePosition(long *pLeft,long *pTop,long *pWidth,long *pHeight); <br>    STDMETHODIMP GetVideoPaletteEntries(long StartIndex,long Entries,long *pRetrieved,long *pPalette); <br>    STDMETHODIMP SetDefaultSourcePosition(); <br>    STDMETHODIMP IsUsingDefaultSource(); <br>    STDMETHODIMP SetDestinationPosition(long Left,long Top,long Width,long Height); <br>    STDMETHODIMP GetDestinationPosition(long *pLeft,long *pTop,long *pWidth,long *pHeight); <br>    STDMETHODIMP SetDefaultDestinationPosition(); <br>    STDMETHODIMP IsUsingDefaultDestination(); <br>    STDMETHODIMP GetCurrentImage(long *pBufferSize,long *pVideoImage); <br>}; <br> <br>#endif // __WINCTRL__ <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
