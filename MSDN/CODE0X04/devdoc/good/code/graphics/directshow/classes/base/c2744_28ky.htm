<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MSGTHRD.H</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2752"></a>MSGTHRD.H</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>// support for a worker thread class to which you can asynchronously post <br>// messages <br> <br> <br>// Message class - really just a structure. <br>// <br>class CMsg { <br>public: <br>    UINT uMsg; <br>    DWORD dwFlags; <br>    LPVOID lpParam; <br>    CAMEvent *pEvent; <br> <br>    CMsg(UINT u, DWORD dw, LPVOID lp, CAMEvent *pEvnt) <br>        : uMsg(u), dwFlags(dw), lpParam(lp), pEvent(pEvnt) {} <br> <br>    CMsg() <br>        : uMsg(0), dwFlags(0L), lpParam(NULL), pEvent(NULL) {} <br>}; <br> <br>// This is the actual thread class.  It exports all the usual thread control <br>// functions.  The created thread is different from a normal WIN32 thread in <br>// that it is prompted to perform particaular tasks by responding to messages <br>// posted to its message queue. <br>// <br>class AM_NOVTABLE CMsgThread { <br>private: <br>    static DWORD WINAPI DefaultThreadProc(LPVOID lpParam); <br>    DWORD               m_ThreadId; <br>    HANDLE              m_hThread; <br> <br>protected: <br> <br>    // if you want to override GetThreadMsg to block on other things <br>    // as well as this queue, you need access to this <br>    CGenericList&lt;CMsg&gt;        m_ThreadQueue; <br>    CCritSec                  m_Lock; <br>    HANDLE                    m_hSem; <br>    LONG                      m_lWaiting; <br> <br>public: <br>    CMsgThread() <br>        : m_ThreadId(0), <br>        m_hThread(NULL), <br>        m_lWaiting(0), <br>        m_hSem(NULL), <br>        // make a list with a cache of 5 items <br>        m_ThreadQueue(NAME("MsgThread list"), 5) <br>        { <br>        } <br> <br>    ~CMsgThread(); <br>    // override this if you want to block on other things as well <br>    // as the message loop <br>    void virtual GetThreadMsg(CMsg *msg); <br> <br>    // override this if you want to do something on thread startup <br>    virtual void OnThreadInit() { <br>    }; <br> <br>    BOOL CreateThread(); <br> <br>    BOOL WaitForThreadExit(LPDWORD lpdwExitCode) { <br>        if (m_hThread != NULL) { <br>            WaitForSingleObject(m_hThread, INFINITE); <br>            return GetExitCodeThread(m_hThread, lpdwExitCode); <br>        } <br>        return FALSE; <br>    } <br> <br>    DWORD ResumeThread() { <br>        return ::ResumeThread(m_hThread); <br>    } <br> <br>    DWORD SuspendThread() { <br>        return ::SuspendThread(m_hThread); <br>    } <br> <br>    int GetThreadPriority() { <br>        return ::GetThreadPriority(m_hThread); <br>    } <br> <br>    BOOL SetThreadPriority(int nPriority) { <br>        return ::SetThreadPriority(m_hThread, nPriority); <br>    } <br> <br>    HANDLE GetThreadHandle() { <br>        return m_hThread; <br>    } <br> <br>    DWORD GetThreadId() { <br>        return m_ThreadId; <br>    } <br> <br> <br>    void PutThreadMsg(UINT uMsg, DWORD dwMsgFlags, <br>                      LPVOID lpMsgParam, CAMEvent *pEvent = NULL) { <br>        CAutoLock lck(&amp;m_Lock); <br>        CMsg* pMsg = new CMsg(uMsg, dwMsgFlags, lpMsgParam, pEvent); <br>        m_ThreadQueue.AddTail(pMsg); <br>        if (m_lWaiting != 0) { <br>            ReleaseSemaphore(m_hSem, m_lWaiting, 0); <br>            m_lWaiting = 0; <br>        } <br>    } <br> <br>    // This is the function prototype of the function that the client <br>    // supplies.  It is always called on the created thread, never on <br>    // the creator thread. <br>    // <br>    virtual LRESULT ThreadMessageProc( <br>        UINT uMsg, DWORD dwFlags, LPVOID lpParam, CAMEvent *pEvent) = 0; <br>}; <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
