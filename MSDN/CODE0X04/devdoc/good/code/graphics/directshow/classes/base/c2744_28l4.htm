<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PSTREAM.H</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2758"></a>PSTREAM.H</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>#ifndef __PSTREAM__ <br>#define __PSTREAM__ <br> <br>// Base class for persistent properties of filters <br>// (i.e. filter properties in saved graphs) <br> <br>// The simplest way to use this is: <br>// 1. Arrange for your filter to inherit this class <br>// 2. Implement in your class WriteToStream and ReadFromStream <br>//    These will override the "do nothing" functions here. <br>// 3. Change your NonDelegatingQueryInterface to handle IPersistStream <br>// 4. Implement SizeMax to return the number of bytes of data you save. <br>//    If you save UNICODE data, don't forget a char is 2 bytes. <br>// 5. Whenever your data changes, call SetDirty() <br>// <br>// At some point you may decide to alter, or extend the format of your data. <br>// At that point you will wish that you had a version number in all the old <br>// saved graphs, so that you can tell, when you read them, whether they <br>// represent the old or new form.  To assist you in this, this class <br>// writes and reads a version number. <br>// When it writes, it calls GetSoftwareVersion()  to enquire what version <br>// of the software we have at the moment.  (In effect this is a version number <br>// of the data layout in the file).  It writes this as the first thing in the data. <br>// If you want to change the version, implement (override) GetSoftwareVersion(). <br>// It reads this from the file into mPS_dwFileVersion before calling ReadFromStream, <br>// so in ReadFromStream you can check mPS_dwFileVersion to see if you are reading <br>// an old version file. <br>// Normally you should accept files whose version is no newer than the software <br>// version that's reading them. <br> <br> <br>// CPersistStream <br>// <br>// Implements IPersistStream. <br>// See 'OLE Programmers Reference (Vol 1):Structured Storage Overview' for <br>// more implementation information. <br>class CPersistStream : public IPersistStream { <br>    private: <br> <br>        // Internal state: <br> <br>    protected: <br>        DWORD     mPS_dwFileVersion;         // version number of file (being read) <br>        BOOL      mPS_fDirty; <br> <br>    public: <br> <br>        // IPersistStream methods <br> <br>        STDMETHODIMP IsDirty() <br>            {return (mPS_fDirty ? S_OK : S_FALSE);}  // note FALSE means clean <br>        STDMETHODIMP Load(LPSTREAM pStm); <br>        STDMETHODIMP Save(LPSTREAM pStm, BOOL fClearDirty); <br>        STDMETHODIMP GetSizeMax(ULARGE_INTEGER * pcbSize) <br>                         // Allow 24 bytes for version. <br>                         { pcbSize-&gt;QuadPart = 12*sizeof(WCHAR)+SizeMax(); return NOERROR; } <br> <br>        // implementation <br> <br>        CPersistStream(IUnknown *punk, HRESULT *phr); <br>        ~CPersistStream(); <br> <br>        HRESULT SetDirty(BOOL fDirty) <br>            { mPS_fDirty = fDirty; return NOERROR;} <br> <br> <br>        // override to reveal IPersist &amp; IPersistStream <br>        // STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv); <br> <br>        // --- IPersist --- <br> <br>        // You must override this to provide your own class id <br>        STDMETHODIMP GetClassID(CLSID *pClsid) PURE; <br> <br>        // overrideable if you want <br>        // file version number.  Override it if you ever change format <br>        virtual DWORD GetSoftwareVersion(void) { return 0; } <br> <br> <br>        //========================================================================= <br>        // OVERRIDE THESE to read and write your data <br>        // OVERRIDE THESE to read and write your data <br>        // OVERRIDE THESE to read and write your data <br> <br>        virtual int SizeMax() {return 0;} <br>        virtual HRESULT WriteToStream(IStream *pStream); <br>        virtual HRESULT ReadFromStream(IStream *pStream); <br>        //========================================================================= <br> <br>    private: <br> <br>}; <br> <br> <br>// --- Useful helpers --- <br> <br> <br>// Writes an int to an IStream as UNICODE. <br>STDAPI WriteInt(IStream *pIStream, int n); <br> <br>// inverse of WriteInt <br>STDAPI_(int) ReadInt(IStream *pIStream, HRESULT &amp;hr); <br> <br>#endif // __PSTREAM__ </code></pre>
<p>&nbsp;</p></body>
</HTML>
