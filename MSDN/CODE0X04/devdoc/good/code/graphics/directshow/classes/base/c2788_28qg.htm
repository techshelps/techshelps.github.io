<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WINUTIL.H</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2788"></a>WINUTIL.H</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>// Generic window handler base classes, December 1995 <br> <br>// Make sure that you call PrepareWindow to initialise the window after <br>// the object has been constructed. It is a separate method so that <br>// derived classes can override useful methods like MessageLoop. Also <br>// any derived class must call DoneWithWindow in its destructor. If it <br>// doesn't a message may be retrieved and call a derived class member <br>// function while a thread is executing the base class destructor code <br> <br>#ifndef __WINUTIL__ <br>#define __WINUTIL__ <br> <br>const int DEFWIDTH = 320;                    // Initial window width <br>const int DEFHEIGHT = 240;                   // Initial window height <br>const int CAPTION = 256;                     // Maximum length of caption <br>const int TIMELENGTH = 50;                   // Maximum length of times <br>const int PROFILESTR = 128;                  // Normal profile string <br>const WORD PALVERSION = 0x300;               // GDI palette version <br>const LONG PALETTE_VERSION = (LONG) 1;       // Initial palette version <br>const COLORREF VIDEO_COLOUR = 0;             // Defaults to black background <br>const HANDLE hMEMORY = (HANDLE) 0xFFFFFFFF;  // Says to open as memory file <br> <br>#define WIDTH(x) ((*(x)).right - (*(x)).left) <br>#define HEIGHT(x) ((*(x)).bottom - (*(x)).top) <br>#define SHOWSTAGE TEXT("WM_SHOWSTAGE") <br>#define SHOWSTAGETOP TEXT("WM_SHOWSTAGETOP") <br>#define REALIZEPALETTE TEXT("WM_REALIZEPALETTE") <br> <br>class AM_NOVTABLE CBaseWindow <br>{ <br>protected: <br> <br>    HINSTANCE m_hInstance;          // Global module instance handle <br>    HWND m_hwnd;                    // Handle for our window <br>    HDC m_hdc;                      // Device context for the window <br>    LONG m_Width;                   // Client window width <br>    LONG m_Height;                  // Client window height <br>    BOOL m_bActivated;              // Has the window been activated <br>    LPTSTR m_pClassName;            // Static string holding class name <br>    DWORD m_ClassStyles;            // Passed in to our constructor <br>    DWORD m_WindowStyles;           // Likewise the initial window styles <br>    DWORD m_WindowStylesEx;         // And the extended window styles <br>    UINT m_ShowStageMessage;        // Have the window shown with focus <br>    UINT m_ShowStageTop;            // Makes the window WS_EX_TOPMOST <br>    UINT m_RealizePalette;          // Makes us realize our new palette <br>    HDC m_MemoryDC;                 // Used for fast BitBlt operations <br>    HPALETTE m_hPalette;            // Handle to any palette we may have <br>    BYTE m_bNoRealize;              // Don't realize palette now <br>    BYTE m_bBackground;             // Should we realise in background <br>    BYTE m_bRealizing;              // already realizing the palette <br>    CCritSec m_WindowLock;          // Serialise window object access <br>    BOOL m_bDoGetDC;                // Should this window get a DC <br> <br> <br>    // Maps windows message procedure into C++ methods <br>    friend LRESULT CALLBACK WndProc(HWND hwnd,      // Window handle <br>                                    UINT uMsg,      // Message ID <br>                                    WPARAM wParam,  // First parameter <br>                                    LPARAM lParam); // Other parameter <br> <br>    virtual LRESULT OnPaletteChange(HWND hwnd, UINT Message); <br> <br>public: <br> <br>    CBaseWindow(BOOL bDoGetDC = TRUE); <br> <br>#ifdef DEBUG <br>    virtual ~CBaseWindow(); <br>#endif <br> <br>    virtual HRESULT DoneWithWindow(); <br>    virtual HRESULT PrepareWindow(); <br>    virtual HRESULT InactivateWindow(); <br>    virtual HRESULT ActivateWindow(); <br>    virtual BOOL OnSize(LONG Width, LONG Height); <br>    virtual BOOL OnClose(); <br>    virtual RECT GetDefaultRect(); <br>    virtual HRESULT UninitialiseWindow(); <br>    virtual HRESULT InitialiseWindow(HWND hwnd); <br> <br>    HRESULT DoCreateWindow(); <br> <br>    HRESULT PerformanceAlignWindow(); <br>    HRESULT DoShowWindow(LONG ShowCmd); <br>    void PaintWindow(BOOL bErase); <br>    void DoSetWindowForeground(BOOL bFocus); <br>    virtual HRESULT SetPalette(HPALETTE hPalette); <br>    void SetRealize(BOOL bRealize) <br>    { <br>        m_bNoRealize = !bRealize; <br>    } <br> <br>    //  Jump over to the window thread to set the current palette <br>    HRESULT SetPalette(); <br> <br>    virtual HRESULT DoRealisePalette(BOOL bForceBackground = FALSE); <br> <br>    virtual BOOL PossiblyEatMessage(UINT uMsg, WPARAM wParam, LPARAM lParam) <br>    { return FALSE; }; <br> <br>    // Access our window information <br> <br>    LONG GetWindowWidth(); <br>    LONG GetWindowHeight(); <br>    HWND GetWindowHWND(); <br>    HDC GetMemoryHDC(); <br>    HDC GetWindowHDC(); <br> <br>    // This is the window procedure the derived object should override <br> <br>    virtual LRESULT OnReceiveMessage(HWND hwnd,          // Window handle <br>                                     UINT uMsg,          // Message ID <br>                                     WPARAM wParam,      // First parameter <br>                                     LPARAM lParam);     // Other parameter <br> <br>    // Must be overriden to return class and window styles <br> <br>    virtual LPTSTR GetClassWindowStyles( <br>                            DWORD *pClassStyles,          // Class styles <br>                            DWORD *pWindowStyles,         // Window styles <br>                            DWORD *pWindowStylesEx) PURE; // Extended styles <br>}; <br> <br> <br>// This helper class is entirely subservient to the owning CBaseWindow object <br>// All this object does is to split out the actual drawing operation from the <br>// main object (because it was becoming too large). We have a number of entry <br>// points to set things like the draw device contexts, to implement the actual <br>// drawing and to set the destination rectangle in the client window. We have <br>// no critical section locking in this class because we are used exclusively <br>// by the owning window object which looks after serialising calls into us <br> <br>// If you want to use this class make sure you call NotifyAllocator once the <br>// allocate has been agreed, also call NotifyMediaType with a pointer to a <br>// NON stack based CMediaType once that has been set (we keep a pointer to <br>// the original rather than taking a copy). When the palette changes call <br>// IncrementPaletteVersion (easiest thing to do is to also call this method <br>// in the SetMediaType method most filters implement). Finally before you <br>// start rendering anything call SetDrawContext so that we can get the HDCs <br>// for drawing from the CBaseWindow object we are given during construction <br> <br>class CDrawImage <br>{ <br>protected: <br> <br>    CBaseWindow *m_pBaseWindow;     // Owning video window object <br>    CRefTime m_StartSample;         // Start time for the current sample <br>    CRefTime m_EndSample;           // And likewise it's end sample time <br>    HDC m_hdc;                      // Main window device context <br>    HDC m_MemoryDC;                 // Offscreen draw device context <br>    RECT m_TargetRect;              // Target destination rectangle <br>    RECT m_SourceRect;              // Source image rectangle <br>    BOOL m_bStretch;                // Do we have to stretch the images <br>    BOOL m_bUsingImageAllocator;    // Are the samples shared DIBSECTIONs <br>    CMediaType *m_pMediaType;       // Pointer to the current format <br>    int m_perfidRenderTime;         // Time taken to render an image <br>    LONG m_PaletteVersion;          // Current palette version cookie <br> <br>    // Draw the video images in the window <br> <br>    void SlowRender(IMediaSample *pMediaSample); <br>    void FastRender(IMediaSample *pMediaSample); <br>    void DisplaySampleTimes(IMediaSample *pSample); <br>    void UpdateColourTable(HDC hdc,BITMAPINFOHEADER *pbmi); <br>    void SetStretchMode(); <br> <br>public: <br> <br>    // Used to control the image drawing <br> <br>    CDrawImage(CBaseWindow *pBaseWindow); <br>    BOOL DrawImage(IMediaSample *pMediaSample); <br>    void SetDrawContext(); <br>    void SetTargetRect(RECT *pTargetRect); <br>    void SetSourceRect(RECT *pSourceRect); <br>    void GetTargetRect(RECT *pTargetRect); <br>    void GetSourceRect(RECT *pSourceRect); <br>    virtual RECT ScaleSourceRect(const RECT *pSource); <br> <br>    // Handle updating palettes as they change <br> <br>    LONG GetPaletteVersion(); <br>    void ResetPaletteVersion(); <br>    void IncrementPaletteVersion(); <br> <br>    // Tell us media types and allocator assignments <br> <br>    void NotifyAllocator(BOOL bUsingImageAllocator); <br>    void NotifyMediaType(CMediaType *pMediaType); <br>    BOOL UsingImageAllocator(); <br> <br>    // Called when we are about to draw an image <br> <br>    void NotifyStartDraw() { <br>        MSR_START(m_perfidRenderTime); <br>    }; <br> <br>    // Called when we complete an image rendering <br> <br>    void NotifyEndDraw() { <br>        MSR_STOP(m_perfidRenderTime); <br>    }; <br>}; <br> <br> <br>// This is the structure used to keep information about each GDI DIB. All the <br>// samples we create from our allocator will have a DIBSECTION allocated to <br>// them. When we receive the sample we know we can BitBlt straight to an HDC <br> <br>typedef struct tagDIBDATA { <br> <br>    LONG        PaletteVersion;     // Current palette version in use <br>    DIBSECTION  DibSection;         // Details of DIB section allocated <br>    HBITMAP     hBitmap;            // Handle to bitmap for drawing <br>    HANDLE      hMapping;           // Handle to shared memory block <br>    BYTE        *pBase;             // Pointer to base memory address <br> <br>} DIBDATA; <br> <br> <br>// This class inherits from CMediaSample and uses all of it's methods but it <br>// overrides the constructor to initialise itself with the DIBDATA structure <br>// When we come to render an IMediaSample we will know if we are using our own <br>// allocator, and if we are, we can cast the IMediaSample to a pointer to one <br>// of these are retrieve the DIB section information and hence the HBITMAP <br> <br>class CImageSample : public CMediaSample <br>{ <br>protected: <br> <br>    DIBDATA m_DibData;      // Information about the DIBSECTION <br>    BOOL m_bInit;           // Is the DIB information setup <br> <br>public: <br> <br>    // Constructor <br> <br>    CImageSample(CBaseAllocator *pAllocator, <br>                 TCHAR *pName, <br>                 HRESULT *phr, <br>                 LPBYTE pBuffer, <br>                 LONG length); <br> <br>    // Maintain the DIB/DirectDraw state <br> <br>    void SetDIBData(DIBDATA *pDibData); <br>    DIBDATA *GetDIBData(); <br>}; <br> <br> <br>// This is an allocator based on the abstract CBaseAllocator base class that <br>// allocates sample buffers in shared memory. The number and size of these <br>// are determined when the output pin calls Prepare on us. The shared memory <br>// blocks are used in subsequent calls to GDI CreateDIBSection, once that <br>// has been done the output pin can fill the buffers with data which will <br>// then be handed to GDI through BitBlt calls and thereby remove one copy <br> <br>class CImageAllocator : public CBaseAllocator <br>{ <br>protected: <br> <br>    CBaseFilter *m_pFilter;   // Delegate reference counts to <br>    CMediaType *m_pMediaType;           // Pointer to the current format <br> <br>    // Used to create and delete samples <br> <br>    HRESULT Alloc(); <br>    void Free(); <br> <br>    // Manage the shared DIBSECTION and DCI/DirectDraw buffers <br> <br>    HRESULT CreateDIB(LONG InSize,DIBDATA &amp;DibData); <br>    STDMETHODIMP CheckSizes(ALLOCATOR_PROPERTIES *pRequest); <br>    virtual CImageSample *CreateImageSample(LPBYTE pData,LONG Length); <br> <br>public: <br> <br>    // Constructor and destructor <br> <br>    CImageAllocator(CBaseFilter *pFilter,TCHAR *pName,HRESULT *phr); <br>#ifdef DEBUG <br>    ~CImageAllocator(); <br>#endif <br> <br>    STDMETHODIMP_(ULONG) NonDelegatingAddRef(); <br>    STDMETHODIMP_(ULONG) NonDelegatingRelease(); <br>    void NotifyMediaType(CMediaType *pMediaType); <br> <br>    // Agree the number of buffers to be used and their size <br> <br>    STDMETHODIMP SetProperties( <br>        ALLOCATOR_PROPERTIES *pRequest, <br>        ALLOCATOR_PROPERTIES *pActual); <br>}; <br> <br> <br>// This class is a fairly specialised helper class for image renderers that <br>// have to create and manage palettes. The CBaseWindow class looks after <br>// realising palettes once they have been installed. This class can be used <br>// to create the palette handles from a media format (which must contain a <br>// VIDEOINFO structure in the format block). We try to make the palette an <br>// identity palette to maximise performance and also only change palettes <br>// if actually required to (we compare palette colours before updating). <br>// All the methods are virtual so that they can be overriden if so required <br> <br>class CImagePalette <br>{ <br>protected: <br> <br>    CBaseWindow *m_pBaseWindow;             // Window to realise palette in <br>    CBaseFilter *m_pFilter;       // Media filter to send events <br>    CDrawImage *m_pDrawImage;               // Object who will be drawing <br>    HPALETTE m_hPalette;                    // The palette handle we own <br> <br>public: <br> <br>    CImagePalette(CBaseFilter *pBaseFilter, <br>                  CBaseWindow *pBaseWindow, <br>                  CDrawImage *pDrawImage); <br> <br>#ifdef DEBUG <br>    virtual ~CImagePalette(); <br>#endif <br> <br>    static HPALETTE MakePalette(const VIDEOINFOHEADER *pVideoInfo, LPSTR szDevice); <br>    HRESULT RemovePalette(); <br>    static HRESULT MakeIdentityPalette(PALETTEENTRY *pEntry,INT iColours, LPSTR szDevice); <br>    HRESULT CopyPalette(const CMediaType *pSrc,CMediaType *pDest); <br>    BOOL ShouldUpdate(const VIDEOINFOHEADER *pNewInfo,const VIDEOINFOHEADER *pOldInfo); <br>    HRESULT PreparePalette(const CMediaType *pmtNew,const CMediaType *pmtOld,LPSTR szDevice); <br>}; <br> <br> <br>// Another helper class really for video based renderers. Most such renderers <br>// need to know what the display format is to some degree or another. This <br>// class initialises itself with the display format. The format can be asked <br>// for through GetDisplayFormat and various other accessor functions. If a <br>// filter detects a display format change (perhaps it gets a WM_DEVMODECHANGE <br>// message then it can call RefreshDisplayType to reset that format). Also <br>// many video renderers will want to check formats as they are proposed by <br>// source filters. This class provides methods to check formats and only <br>// accept those video formats that can be efficiently drawn using GDI calls <br> <br>class CImageDisplay : public CCritSec <br>{ <br>protected: <br> <br>    // This holds the display format; biSize should not be too big, so we can <br>    // safely use the VIDEOINFO structure <br>    VIDEOINFO m_Display; <br> <br>    static DWORD CountSetBits(const DWORD Field); <br>    static DWORD CountPrefixBits(const DWORD Field); <br>    static BOOL CheckBitFields(const VIDEOINFO *pInput); <br> <br>public: <br> <br>    // Constructor and destructor <br> <br>    CImageDisplay(); <br> <br>    // Used to manage BITMAPINFOHEADERs and the display format <br> <br>    const VIDEOINFO *GetDisplayFormat(); <br>    HRESULT RefreshDisplayType(LPSTR szDeviceName); <br>    static BOOL CheckHeaderValidity(const VIDEOINFO *pInput); <br>    static BOOL CheckPaletteHeader(const VIDEOINFO *pInput); <br>    BOOL IsPalettised(); <br>    WORD GetDisplayDepth(); <br> <br>    // Provide simple video format type checking <br> <br>    HRESULT CheckMediaType(const CMediaType *pmtIn); <br>    HRESULT CheckVideoType(const VIDEOINFO *pInput); <br>    HRESULT UpdateFormat(VIDEOINFO *pVideoInfo); <br>    const DWORD *GetBitMasks(const VIDEOINFO *pVideoInfo); <br> <br>    BOOL GetColourMask(DWORD *pMaskRed, <br>                       DWORD *pMaskGreen, <br>                       DWORD *pMaskBlue); <br>}; <br> <br>#endif // __WINUTIL__ <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
