<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TRANSIP.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2779"></a>TRANSIP.CPP</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright 1992 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>// Base class for simple Transform-In-Place filters such as audio <br> <br> <br>// How allocators are decided. <br>// <br>// An in-place transform tries to do its work in someone else's buffers. <br>// It tries to persuade the filters on either side to use the same allocator <br>// (and for that matter the same media type).  In desperation, if the downstream <br>// filter refuses to supply an allocator and the upstream filter offers only <br>// a read-only one then it will provide an allocator. <br>// if the upstream filter insists on a read-only allocator then the transform <br>// filter will (reluctantly) copy the data before transforming it. <br>// <br>// In order to pass an allocator through it needs to remember the one it got <br>// from the first connection to pass it on to the second one. <br>// <br>// It is good if we can avoid insisting on a particular order of connection <br>// (There is a precedent for insisting on the input <br>// being connected first.  Insisting on the output being connected first is <br>// not allowed.  That would break RenderFile.) <br>// <br>// The base pin classes (CBaseOutputPin and CBaseInputPin) both have a <br>// m_pAllocator member which is used in places like <br>// CBaseOutputPin::GetDeliveryBuffer and CBaseInputPin::Inactive. <br>// To avoid lots of extra overriding, we should keep these happy <br>// by using these pointers. <br>// <br>// When each pin is connected, it will set the corresponding m_pAllocator <br>// and will have a single ref-count on that allocator. <br>// <br>// Refcounts are acquired by GetAllocator calls which return AddReffed <br>// allocators and are released in one of: <br>//     CBaseInputPin::Disconnect <br>//     CBaseOutputPin::BreakConect <br>// In each case m_pAllocator is set to NULL after the release, so this <br>// is the last chance to ever release it.  If there should ever be <br>// multiple refcounts associated with the same pointer, this had better <br>// be cleared up before that happens.  To avoid such problems, we'll <br>// stick with one per pointer. <br> <br> <br> <br>// RECONNECTING and STATE CHANGES <br>// <br>// Each pin could be disconnected, connected with a read-only allocator, <br>// connected with an upstream read/write allocator, connected with an <br>// allocator from downstream or connected with its own allocator. <br>// Five states for each pin gives a data space of 25 states. <br>// <br>// Notation: <br>// <br>// R/W == read/write <br>// R-O == read-only <br>// <br>// &lt;input pin state&gt; &lt;output pin state&gt; &lt;comments&gt; <br>// <br>// 00 means an unconnected pin. <br>// &lt;- means using a R/W allocator from the upstream filter <br>// &lt;= means using a R-O allocator from an upstream filter <br>// || means using our own (R/W) allocator. <br>// -&gt; means using a R/W allocator from a downstream filter <br>//    (a R-O allocator from downstream is nonsense, it can't ever work). <br>// <br>// <br>// That makes 25 possible states.  Some states are nonsense (two different <br>// allocators from the same place).  These are just an artifact of the notation. <br>//        &lt;=  &lt;-  Nonsense. <br>//        &lt;-  &lt;=  Nonsense <br>// Some states are illegal (the output pin never accepts a R-O allocator): <br>//        00  &lt;=  !! Error !! <br>//        &lt;=  &lt;=  !! Error !! <br>//        ||  &lt;=  !! Error !! <br>//        -&gt;  &lt;=  !! Error !! <br>// Three states appears to be inaccessible: <br>//        -&gt;  ||  Inaccessible <br>//        ||  -&gt;  Inaccessible <br>//        ||  &lt;-  Inaccessible <br>// Some states only ever occur as intermediates with a pending reconnect which <br>// is guaranteed to finish in another state. <br>//        -&gt;  00  ?? unstable goes to || 00 <br>//        00  &lt;-  ?? unstable goes to 00 || <br>//        -&gt;  &lt;-  ?? unstable goes to -&gt; -&gt; <br>//        &lt;-  ||  ?? unstable goes to &lt;- &lt;- <br>//        &lt;-  -&gt;  ?? unstable goes to &lt;- &lt;- <br>// And that leaves 11 possible resting states: <br>// 1      00  00  Nothing connected. <br>// 2      &lt;-  00  Input pin connected. <br>// 3      &lt;=  00  Input pin connected using R-O allocator. <br>// 4      ||  00  Needs several state changes to get here. <br>// 5      00  ||  Output pin connected using our allocator <br>// 6      00  -&gt;  Downstream only connected <br>// 7      ||  ||  Undesirable but can be forced upon us. <br>// 8      &lt;=  ||  Copy forced.  &lt;=  -&gt; is preferable <br>// 9      &lt;=  -&gt;  OK - forced to copy. <br>// 10     &lt;-  &lt;-  Transform in place (ideal) <br>// 11     -&gt;  -&gt;  Transform in place (ideal) <br>// <br>// The object of the exercise is to ensure that we finish up in states <br>// 10 or 11 whenever possible.  State 10 is only possible if the upstream <br>// filter has a R/W allocator (the AVI splitter notoriously <br>// doesn't) and state 11 is only possible if the downstream filter does <br>// offer an allocator. <br>// <br>// The transition table (entries marked * go via a reconnect) <br>// <br>// There are 8 possible transitions: <br>// A: Connect upstream to filter with R-O allocator that insists on using it. <br>// B: Connect upstream to filter with R-O allocator but chooses not to use it. <br>// C: Connect upstream to filter with R/W allocator and insists on using it. <br>// D: Connect upstream to filter with R/W allocator but chooses not to use it. <br>// E: Connect downstream to a filter that offers an allocator <br>// F: Connect downstream to a filter that does not offer an allocator <br>// G: disconnect upstream <br>// H: Disconnect downstream <br>// <br>//            A      B      C      D      E      F      G      H <br>//           --------------------------------------------------------- <br>// 00  00 1 | 3      3      2      2      6      5      .      .      |1  00  00 <br>// &lt;-  00 2 | .      .      .      .      *10/11 10     1      .      |2  &lt;-  00 <br>// &lt;=  00 3 | .      .      .      .      *9/11  *7/8   1      .      |3  &lt;=  00 <br>// ||  00 4 | .      .      .      .      *8     *7     1      .      |4  ||  00 <br>// 00  || 5 | 8      7      *10    7      .      .      .      1      |5  00  || <br>// 00  -&gt; 6 | 9      11     *10    11     .      .      .      1      |6  00  -&gt; <br>// ||  || 7 | .      .      .      .      .      .      5      4      |7  ||  || <br>// &lt;=  || 8 | .      .      .      .      .      .      5      3      |8  &lt;=  || <br>// &lt;=  -&gt; 9 | .      .      .      .      .      .      6      3      |9  &lt;=  -&gt; <br>// &lt;-  &lt;- 10| .      .      .      .      .      .      *5/6   2      |10 &lt;-  &lt;- <br>// -&gt;  -&gt; 11| .      .      .      .      .      .      6      *2/3   |11 -&gt;  -&gt; <br>//           --------------------------------------------------------- <br>//            A      B      C      D      E      F      G      H <br>// <br>// All these states are accessible without requiring any filter to <br>// change its behaviour but not all transitions are accessible, for <br>// instance a transition from state 4 to anywhere other than <br>// state 8 requires that the upstream filter first offer a R-O allocator <br>// and then changes its mind and offer R/W.  This is NOT allowable - it <br>// leads to things like the output pin getting a R/W allocator from <br>// upstream and then the input pin being told it can only have a R-O one. <br>// Note that you CAN change (say) the upstream filter for a different one, but <br>// only as a disconnect / connect, not as a Reconnect.  (Exercise for <br>// the reader is to see how you get into state 4). <br>// <br>// The reconnection stuff goes as follows (some of the cases shown here as <br>// "no reconnect" may get one to finalise media type - an old story). <br>// If there is a reconnect where it says "no reconnect" here then the <br>// reconnection must not change the allocator choice. <br>// <br>// state 2: &lt;- 00 transition E &lt;- &lt;- case C &lt;- &lt;- (no change) <br>//                                   case D -&gt; &lt;- and then to -&gt; -&gt; <br>// <br>// state 2: &lt;- 00 transition F &lt;- &lt;- (no reconnect) <br>// <br>// state 3: &lt;= 00 transition E &lt;= -&gt; case A &lt;= -&gt; (no change) <br>//                                   case B -&gt; -&gt; <br>//                transition F &lt;= || case A &lt;= || (no change) <br>//                                   case B || || <br>// <br>// state 4: || 00 transition E || || case B -&gt; || and then all cases to -&gt; -&gt; <br>//                           F || || case B || || (no change) <br>// <br>// state 5: 00 || transition A &lt;= || (no reconnect) <br>//                           B || || (no reconnect) <br>//                           C &lt;- || all cases     &lt;- &lt;- <br>//                           D || || (unfortunate, but upstream's choice) <br>// <br>// state 6: 00 -&gt; transition A &lt;= -&gt; (no reconnect) <br>//                           B -&gt; -&gt; (no reconnect) <br>//                           C &lt;- -&gt; all cases &lt;- &lt;- <br>//                           D -&gt; -&gt; (no reconnect) <br>// <br>// state 10:&lt;- &lt;- transition G 00 &lt;- case E 00 -&gt; <br>//                                   case F 00 || <br>// <br>// state 11:-&gt; -&gt; transition H -&gt; 00 case A &lt;= 00 (schizo) <br>//                                   case B &lt;= 00 <br>//                                   case C &lt;- 00 (schizo) <br>//                                   case D &lt;- 00 <br>// <br>// The Rules: <br>// To sort out media types: <br>// The input is reconnected <br>//    if the input pin is connected and the output pin connects <br>// The output is reconnected <br>//    If the output pin is connected <br>//    and the input pin connects to a different media type <br>// <br>// To sort out allocators: <br>// The input is reconnected <br>//    if the output disconnects and the input was using a downstream allocator <br>// The output pin calls SetAllocator to pass on a new allocator <br>//    if the output is connected and <br>//       if the input disconnects and the output was using an upstream allocator <br>//       if the input acquires an allocator different from the output one <br>//          and that new allocator is not R-O <br>// <br>// Data is copied (i.e. call getbuffer and copy the data before transforming it) <br>//    if the two allocators are different. <br> <br> <br> <br>// CHAINS of filters: <br>// <br>// We sit between two filters (call them A and Z).  We should finish up <br>// with the same allocator on both of our pins and that should be the <br>// same one that A and Z would have agreed on if we hadn't been in the <br>// way.  Furthermore, it should not matter how many in-place transforms <br>// are in the way.  Let B, C, D... be in-place transforms ("us"). <br>// Here's how it goes: <br>// <br>// 1. <br>// A connects to B.  They agree on A's allocator. <br>//   A-a-&gt;B <br>// <br>// 2. <br>// B connects to C.  Same story. There is no point in a reconnect, but <br>// B will request an input reconnect anyway. <br>//   A-a-&gt;B-a-&gt;C <br>// <br>// 3. <br>// C connects to Z. <br>// C insists on using A's allocator, but compromises by requesting a reconnect. <br>// of C's input. <br>//   A-a-&gt;B-?-&gt;C-a-&gt;Z <br>// <br>// We now have pending reconnects on both A---&gt;B and B---&gt;C <br>// <br>// 4. <br>// The A---&gt;B link is reconnected. <br>// A asks B for an allocator.  B sees that it has a downstream connection so <br>// asks its downstream input pin i.e. C's input pin for an allocator.  C sees <br>// that it too has a downstream connection so asks Z for an allocator. <br>// <br>// Even though Z's input pin is connected, it is being asked for an allocator. <br>// It could refuse, in which case the chain is done and will use A's allocator <br>// Alternatively, Z may supply one.  A chooses either Z's or A's own one. <br>// B's input pin gets NotifyAllocator called to tell it the decision and it <br>// propagates this downstream by calling ReceiveAllocator on its output pin <br>// which calls NotifyAllocator on the next input pin downstream etc. <br>// If the choice is Z then it goes: <br>//   A-z-&gt;B-a-&gt;C-a-&gt;Z <br>//   A-z-&gt;B-z-&gt;C-a-&gt;Z <br>//   A-z-&gt;B-z-&gt;C-z-&gt;Z <br>// <br>// And that's IT!!  Any further (essentially spurious) reconnects peter out <br>// with no change in the chain. <br> <br>#include &lt;streams.h&gt; <br>#include &lt;measure.h&gt; <br>#include &lt;transip.h&gt; <br> <br> <br>// ================================================================= <br>// Implements the CTransInPlaceFilter class <br>// ================================================================= <br> <br>CTransInPlaceFilter::CTransInPlaceFilter <br>   ( TCHAR     *pName, <br>     LPUNKNOWN  pUnk, <br>     REFCLSID   clsid, <br>     HRESULT   *phr <br>   ) <br>   : CTransformFilter(pName, pUnk, clsid) <br>{ <br>#ifdef PERF <br>    RegisterPerfId(); <br>#endif //  PERF <br> <br>} // constructor <br> <br> <br>// return a non-addrefed CBasePin * for the user to addref if he holds onto it <br>// for longer than his pointer to us. We create the pins dynamically when they <br>// are asked for rather than in the constructor. This is because we want to <br>// give the derived class an oppportunity to return different pin objects <br> <br>// As soon as any pin is needed we create both (this is different from the <br>// usual transform filter) because enumerators, allocators etc are passed <br>// through from one pin to another and it becomes very painful if the other <br>// pin isn't there.  If we fail to create either pin we ensure we fail both. <br> <br>CBasePin * <br>CTransInPlaceFilter::GetPin(int n) <br>{ <br>    HRESULT hr = S_OK; <br> <br>    // Create an input pin if not already done <br> <br>    if (m_pInput == NULL) { <br> <br>        m_pInput = new CTransInPlaceInputPin( NAME("TransInPlace input pin") <br>                                            , this        // Owner filter <br>                                            , &amp;hr         // Result code <br>                                            , L"Input"    // Pin name <br>                                            ); <br> <br>        // Constructor for CTransInPlaceInputPin can't fail <br>        ASSERT(SUCCEEDED(hr)); <br>    } <br> <br>    // Create an output pin if not already done <br> <br>    if (m_pInput!=NULL &amp;&amp; m_pOutput == NULL) { <br> <br>        m_pOutput = new CTransInPlaceOutputPin( NAME("TransInPlace output pin") <br>                                              , this       // Owner filter <br>                                              , &amp;hr        // Result code <br>                                              , L"Output"  // Pin name <br>                                              ); <br> <br>        // a failed return code should delete the object <br> <br>        ASSERT(SUCCEEDED(hr)); <br>        if (m_pOutput == NULL) { <br>            delete m_pInput; <br>            m_pInput = NULL; <br>        } <br>    } <br> <br>    // Return the appropriate pin <br> <br>    ASSERT (n&gt;=0 &amp;&amp; n&lt;=1); <br>    if (n == 0) { <br>        return m_pInput; <br>    } else if (n==1) { <br>        return m_pOutput; <br>    } else { <br>        return NULL; <br>    } <br> <br>} // GetPin <br> <br> <br> <br>// dir is the direction of our pin. <br>// pReceivePin is the pin we are connecting to. <br>HRESULT CTransInPlaceFilter::CompleteConnect(PIN_DIRECTION dir,IPin *pReceivePin) <br>{ <br>    UNREFERENCED_PARAMETER(pReceivePin); <br>    ASSERT(m_pInput); <br>    ASSERT(m_pOutput); <br> <br>    // if we are not part of a graph, then don't indirect the pointer <br>    // this probably prevents use of the filter without a filtergraph <br>    if (!m_pGraph) { <br>        return VFW_E_NOT_IN_GRAPH; <br>    } <br> <br>    // Always reconnect the input to account for buffering changes <br>    // <br>    // Because we don't get to suggest a type on ReceiveConnection <br>    // we need another way of making sure the right type gets used. <br>    // <br>    // One way would be to have our EnumMediaTypes return our output <br>    // connection type first but more deterministic and simple is to <br>    // call ReconnectEx passing the type we want to reconnect with <br>    // via the base class ReconeectPin method. <br> <br>    if (dir == PINDIR_OUTPUT) { <br>        if( m_pInput-&gt;IsConnected() ) { <br>            return ReconnectPin( m_pInput, &amp;m_pOutput-&gt;CurrentMediaType() ); <br>        } <br>        return NOERROR; <br>    } <br> <br>    ASSERT(dir == PINDIR_INPUT); <br> <br>    // Reconnect output if necessary <br> <br>    if( m_pOutput-&gt;IsConnected() ) { <br> <br>        if (  m_pInput-&gt;CurrentMediaType() <br>           != m_pOutput-&gt;CurrentMediaType() <br>           ) { <br>            return ReconnectPin( m_pOutput, &amp;m_pInput-&gt;CurrentMediaType() ); <br>        } <br>    } <br>    return NOERROR; <br> <br>} // ComnpleteConnect <br> <br> <br>// <br>// DecideBufferSize <br>// <br>// Tell the output pin's allocator what size buffers we require. <br>// *pAlloc will be the allocator our output pin is using. <br> <br>HRESULT CTransInPlaceFilter::DecideBufferSize <br>            ( IMemAllocator *pAlloc <br>            , ALLOCATOR_PROPERTIES *pProperties <br>            ) <br>{ <br>    ALLOCATOR_PROPERTIES Request, Actual; <br>    HRESULT hr; <br> <br>    // If we are connected upstream, get his views <br>    if (m_pInput-&gt;IsConnected()) { <br>        // Get the input pin allocator, and get its size and count. <br>        // we don't care about his alignment and prefix. <br>         <br>        hr = InputPin()-&gt;PeekAllocator()-&gt;GetProperties(&amp;Request); <br>        if (FAILED(hr)) { <br>            // Input connected but with a secretive allocator - enough! <br>            return hr; <br>        } <br>    } else { <br>        // We're reduced to blind guessing.  Let's guess one byte and if <br>        // this isn't enough then when the other pin does get connected <br>        // we can revise it. <br>        ZeroMemory(&amp;Request, sizeof(Request)); <br>        Request.cBuffers = 1; <br>        Request.cbBuffer = 1; <br>    } <br> <br> <br>    DbgLog((LOG_MEMORY,1,TEXT("Setting Allocator Requirements"))); <br>    DbgLog((LOG_MEMORY,1,TEXT("Count %d, Size %d"), <br>           Request.cBuffers, Request.cbBuffer)); <br> <br>    // Pass the allocator requirements to our output side <br>    // but do a little sanity checking first or we'll just hit <br>    // asserts in the allocator. <br> <br>    pProperties-&gt;cBuffers = Request.cBuffers; <br>    pProperties-&gt;cbBuffer = Request.cbBuffer; <br>    if (pProperties-&gt;cBuffers&lt;=0) {pProperties-&gt;cBuffers = 1; } <br>    if (pProperties-&gt;cbBuffer&lt;=0) {pProperties-&gt;cbBuffer = 1; } <br>    hr = pAlloc-&gt;SetProperties(pProperties, &amp;Actual); <br> <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br> <br>    DbgLog((LOG_MEMORY,1,TEXT("Obtained Allocator Requirements"))); <br>    DbgLog((LOG_MEMORY,1,TEXT("Count %d, Size %d, Alignment %d"), <br>           Actual.cBuffers, Actual.cbBuffer, Actual.cbAlign)); <br> <br>    // Make sure we got the right alignment and at least the minimum required <br> <br>    if (  (Request.cBuffers &gt; Actual.cBuffers) <br>       || (Request.cbBuffer &gt; Actual.cbBuffer) <br>       || (Request.cbAlign  &gt; Actual.cbAlign) <br>       ) { <br>        return E_FAIL; <br>    } <br>    return NOERROR; <br> <br>} // DecideBufferSize <br> <br> <br> <br>// <br>// Copy <br>// <br>// return a pointer to an identical copy of pSample <br>IMediaSample * CTransInPlaceFilter::Copy(IMediaSample *pSource) <br>{ <br>    IMediaSample * pDest; <br> <br>    HRESULT hr; <br>    REFERENCE_TIME tStart, tStop; <br>    const BOOL bTime = S_OK == pSource-&gt;GetTime( &amp;tStart, &amp;tStop); <br> <br>    // this may block for an indeterminate amount of time <br>    hr = OutputPin()-&gt;PeekAllocator()-&gt;GetBuffer( <br>              &amp;pDest <br>              , bTime ? &amp;tStart : NULL <br>              , bTime ? &amp;tStop : NULL <br>              , m_bSampleSkipped ? AM_GBF_PREVFRAMESKIPPED : 0 <br>              ); <br> <br>    if (FAILED(hr)) { <br>        return NULL; <br>    } <br> <br>    ASSERT(pDest); <br>    IMediaSample2 *pSample2; <br>    if (SUCCEEDED(pDest-&gt;QueryInterface(IID_IMediaSample2, (void **)&amp;pSample2))) { <br>        HRESULT hr = pSample2-&gt;SetProperties( <br>            FIELD_OFFSET(AM_SAMPLE2_PROPERTIES, pbBuffer), <br>            (PBYTE)m_pInput-&gt;SampleProps()); <br>        pSample2-&gt;Release(); <br>        if (FAILED(hr)) { <br>            pDest-&gt;Release(); <br>            return NULL; <br>        } <br>    } else { <br>        if (bTime) { <br>            pDest-&gt;SetTime(&amp;tStart, &amp;tStop); <br>        } <br> <br>        if (S_OK == pSource-&gt;IsSyncPoint()) { <br>            pDest-&gt;SetSyncPoint(TRUE); <br>        } <br>        if (S_OK == pSource-&gt;IsDiscontinuity() || m_bSampleSkipped) { <br>            pDest-&gt;SetDiscontinuity(TRUE); <br>        } <br>        if (S_OK == pSource-&gt;IsPreroll()) { <br>            pDest-&gt;SetPreroll(TRUE); <br>        } <br> <br>        // Copy the media type <br>        AM_MEDIA_TYPE *pMediaType; <br>        if (S_OK == pSource-&gt;GetMediaType(&amp;pMediaType)) { <br>            pDest-&gt;SetMediaType(pMediaType); <br>            DeleteMediaType( pMediaType ); <br>        } <br> <br>    } <br> <br>    m_bSampleSkipped = FALSE; <br> <br>    // Copy the sample media times <br>    REFERENCE_TIME TimeStart, TimeEnd; <br>    if (pSource-&gt;GetMediaTime(&amp;TimeStart,&amp;TimeEnd) == NOERROR) { <br>        pDest-&gt;SetMediaTime(&amp;TimeStart,&amp;TimeEnd); <br>    } <br> <br>    // Copy the actual data length and the actual data. <br>    { <br>        const long lDataLength = pSource-&gt;GetActualDataLength(); <br>        pDest-&gt;SetActualDataLength(lDataLength); <br> <br>        // Copy the sample data <br>        { <br>            BYTE *pSourceBuffer, *pDestBuffer; <br>            long lSourceSize  = pSource-&gt;GetSize(); <br>            long lDestSize = pDest-&gt;GetSize(); <br> <br>            ASSERT(lDestSize &gt;= lSourceSize &amp;&amp; lDestSize &gt;= lDataLength); <br> <br>            pSource-&gt;GetPointer(&amp;pSourceBuffer); <br>            pDest-&gt;GetPointer(&amp;pDestBuffer); <br>            ASSERT(lDestSize == 0 || pSourceBuffer != NULL &amp;&amp; pDestBuffer != NULL); <br> <br>            CopyMemory( (PVOID) pDestBuffer, (PVOID) pSourceBuffer, lDataLength ); <br>        } <br>    } <br> <br>    return pDest; <br> <br>} // Copy <br> <br> <br>// override this to customize the transform process <br> <br>HRESULT <br>CTransInPlaceFilter::Receive(IMediaSample *pSample) <br>{ <br>    /*  Check for other streams and pass them on */ <br>    AM_SAMPLE2_PROPERTIES * const pProps = m_pInput-&gt;SampleProps(); <br>    if (pProps-&gt;dwStreamId != AM_STREAM_MEDIA) { <br>        return m_pOutput-&gt;Deliver(pSample); <br>    } <br>    HRESULT hr; <br> <br>    // Start timing the TransInPlace (if PERF is defined) <br>    MSR_START(m_idTransInPlace); <br> <br>    if (InputPin()-&gt;PeekAllocator() != OutputPin()-&gt;PeekAllocator()) { <br> <br>        // We have to copy the data. <br> <br>        pSample = Copy(pSample); <br> <br>        if (pSample==NULL) { <br>            MSR_STOP(m_idTransInPlace); <br>            return E_UNEXPECTED; <br>        } <br>    } <br> <br>    // have the derived class transform the data <br>    hr = Transform(pSample); <br> <br>    // Stop the clock and log it (if PERF is defined) <br>    MSR_STOP(m_idTransInPlace); <br> <br>    if (FAILED(hr)) { <br>        DbgLog((LOG_TRACE, 1, TEXT("Error from TransInPlace"))); <br>        if (InputPin()-&gt;PeekAllocator() != OutputPin()-&gt;PeekAllocator()) { <br>            pSample-&gt;Release(); <br>        } <br>        return hr; <br>    } <br> <br>    // the Transform() function can return S_FALSE to indicate that the <br>    // sample should not be delivered; we only deliver the sample if it's <br>    // really S_OK (same as NOERROR, of course.) <br>    if (hr == NOERROR) { <br>        hr = m_pOutput-&gt;Deliver(pSample); <br>    } else { <br>        //  But it would be an error to return this private hack <br>        //  to the caller ... <br>        if (S_FALSE == hr) { <br>            // S_FALSE returned from Transform is a PRIVATE agreement <br>            // We should return NOERROR from Receive() in this cause because returning S_FALSE <br>            // from Receive() means that this is the end of the stream and no more data should <br>            // be sent. <br>            m_bSampleSkipped = TRUE; <br>            if (!m_bQualityChanged) { <br>                NotifyEvent(EC_QUALITY_CHANGE,0,0); <br>                m_bQualityChanged = TRUE; <br>            } <br>            hr = NOERROR; <br>        } <br>    } <br> <br>    // release the output buffer. If the connected pin still needs it, <br>    // it will have addrefed it itself. <br>    if (InputPin()-&gt;PeekAllocator() != OutputPin()-&gt;PeekAllocator()) { <br>        pSample-&gt;Release(); <br>    } <br> <br>    return hr; <br> <br>} // Receive <br> <br> <br> <br>// ================================================================= <br>// Implements the CTransInPlaceInputPin class <br>// ================================================================= <br> <br> <br>// constructor <br> <br>CTransInPlaceInputPin::CTransInPlaceInputPin <br>    ( TCHAR               *pObjectName <br>    , CTransInPlaceFilter *pFilter <br>    , HRESULT             *phr <br>    , LPCWSTR              pName <br>    ) <br>    : CTransformInputPin(pObjectName, <br>                         pFilter, <br>                         phr, <br>                         pName) <br>    , m_bReadOnly(FALSE) <br>{ <br>    DbgLog((LOG_TRACE, 2 <br>           , TEXT("CTransInPlaceInputPin::CTransInPlaceInputPin"))); <br>    m_pTIPFilter = pFilter; <br> <br>} // constructor <br> <br> <br>// ================================================================= <br>// Implements IMemInputPin interface <br>// ================================================================= <br> <br> <br>// If the downstream filter has one then offer that (even if our own output <br>// pin is not using it yet.  If the upstream filter chooses it then we will <br>// tell our output pin to ReceiveAllocator). <br>// Else if our output pin is using an allocator then offer that. <br>//     ( This could mean offering the upstream filter his own allocator, <br>//       it could mean offerring our own <br>//     ) or it could mean offering the one from downstream <br>// Else fail to offer any allocator at all. <br> <br>STDMETHODIMP CTransInPlaceInputPin::GetAllocator(IMemAllocator ** ppAllocator) <br>{ <br>    CheckPointer(ppAllocator,E_POINTER); <br>    ValidateReadWritePtr(ppAllocator,sizeof(IMemAllocator *)); <br>    CAutoLock cObjectLock(m_pLock); <br> <br>    if ( m_pTIPFilter-&gt;m_pOutput-&gt;IsConnected() ){ <br>        HRESULT hr = m_pTIPFilter-&gt;OutputPin()-&gt;ConnectedIMemInputPin() <br>                                               -&gt;GetAllocator( ppAllocator ); <br>        if( SUCCEEDED( hr ) ){ <br>            // the downstream GetAllocator will have done AddRef on it <br>            return hr; <br>        } <br>        else { <br>            *ppAllocator = m_pTIPFilter-&gt;OutputPin()-&gt;PeekAllocator(); <br>            (*ppAllocator)-&gt;AddRef(); <br>            return S_OK; <br>        } <br> <br>    } <br> <br>    return VFW_E_NO_ALLOCATOR; <br> <br>} // GetAllocator <br> <br> <br> <br>/* Get told which allocator the upstream output pin is actually going to use */ <br> <br>STDMETHODIMP <br>CTransInPlaceInputPin::NotifyAllocator( <br>    IMemAllocator * pAllocator, <br>    BOOL bReadOnly) <br>{ <br>    HRESULT hr; <br>    CheckPointer(pAllocator,E_POINTER); <br>    ValidateReadPtr(pAllocator,sizeof(IMemAllocator)); <br> <br>    m_bReadOnly = bReadOnly; <br>    // we are an in-place transform.  We scribble on the buffer. <br>    // But if it's ReadOnly we're going to have to copy it first. <br> <br>    CAutoLock cObjectLock(m_pLock); <br> <br>    // It's possible that the old and the new are the same thing. <br>    // AddRef before release ensures that we don't unload it. <br>    pAllocator-&gt;AddRef(); <br> <br>    if( m_pAllocator != NULL ) <br>        m_pAllocator-&gt;Release(); <br> <br>    m_pAllocator = pAllocator;    // We have an allocator for the input pin <br> <br>    // Propagate the decision downstream - do this always, even if it's <br>    // a read-only allocator.  The Receive function will take what it can. <br>    if ( m_pTIPFilter-&gt;OutputPin()-&gt;IsConnected() ) { <br>        hr = m_pTIPFilter-&gt;OutputPin()-&gt;ReceiveAllocator(pAllocator, bReadOnly); <br>        if (FAILED(hr)) { <br>            // The output connection would be screwed by this input connection <br>            // so refuse it! <br>            return hr; <br>        } <br>    } <br> <br>    return NOERROR; <br> <br>} // NotifyAllocator <br> <br> <br>// EnumMediaTypes <br>// - pass through to our downstream filter <br>STDMETHODIMP CTransInPlaceInputPin::EnumMediaTypes( IEnumMediaTypes **ppEnum ) <br>{ <br>    // Can only pass through if connected <br>    if( !m_pTIPFilter-&gt;m_pOutput-&gt;IsConnected() ) <br>        return VFW_E_NOT_CONNECTED; <br> <br>    return m_pTIPFilter-&gt;m_pOutput-&gt;GetConnected()-&gt;EnumMediaTypes( ppEnum ); <br> <br>} // EnumMediaTypes <br> <br> <br>// CheckMediaType <br>// - agree to anything if not connected, <br>// otherwise pass through to the downstream filter. <br>// This assumes that the filter does not change the media type. <br> <br>HRESULT CTransInPlaceInputPin::CheckMediaType(const CMediaType *pmt ) <br>{ <br>    HRESULT hr = m_pTIPFilter-&gt;CheckInputType(pmt); <br>    if (hr!=S_OK) return hr; <br> <br>    if( m_pTIPFilter-&gt;m_pOutput-&gt;IsConnected() ) <br>        return m_pTIPFilter-&gt;m_pOutput-&gt;GetConnected()-&gt;QueryAccept( pmt ); <br>    else <br>        return S_OK; <br> <br>} // CheckMediaType <br> <br> <br>// If upstream asks us what our requirements are, we will try to ask downstream <br>// if that doesn't work, we'll just take the defaults. <br>STDMETHODIMP <br>CTransInPlaceInputPin::GetAllocatorRequirements(ALLOCATOR_PROPERTIES *pProps) <br>{ <br> <br>    if( m_pTIPFilter-&gt;m_pOutput-&gt;IsConnected() ) <br>        return m_pTIPFilter-&gt;OutputPin() <br>               -&gt;ConnectedIMemInputPin()-&gt;GetAllocatorRequirements( pProps ); <br>    else <br>        return E_NOTIMPL; <br> <br>} // GetAllocatorRequirements <br> <br> <br> <br>// ================================================================= <br>// Implements the CTransInPlaceOutputPin class <br>// ================================================================= <br> <br> <br>// constructor <br> <br>CTransInPlaceOutputPin::CTransInPlaceOutputPin( <br>    TCHAR *pObjectName, <br>    CTransInPlaceFilter *pFilter, <br>    HRESULT * phr, <br>    LPCWSTR pPinName) <br>    : CTransformOutputPin( pObjectName <br>                         , pFilter <br>                         , phr <br>                         , pPinName) <br>{ <br>    DbgLog(( LOG_TRACE, 2 <br>           , TEXT("CTransInPlaceOutputPin::CTransInPlaceOutputPin"))); <br>    m_pTIPFilter = pFilter; <br> <br>} // constructor <br> <br> <br>// EnumMediaTypes <br>// - pass through to our upstream filter <br>STDMETHODIMP CTransInPlaceOutputPin::EnumMediaTypes( IEnumMediaTypes **ppEnum ) <br>{ <br>    // Can only pass through if connected. <br>    if( ! m_pTIPFilter-&gt;m_pInput-&gt;IsConnected() ) <br>        return VFW_E_NOT_CONNECTED; <br> <br>    return m_pTIPFilter-&gt;m_pInput-&gt;GetConnected()-&gt;EnumMediaTypes( ppEnum ); <br> <br>} // EnumMediaTypes <br> <br> <br> <br>// CheckMediaType <br>// - agree to anything if not connected, <br>// otherwise pass through to the upstream filter. </code></pre>
<p>
</p>
<pre><code><br>HRESULT CTransInPlaceOutputPin::CheckMediaType(const CMediaType *pmt ) <br>{ <br> <br>    // Assumes the type does not change.  That's why we're calling <br>    // CheckINPUTType here on the OUTPUT pin. <br>    HRESULT hr = m_pTIPFilter-&gt;CheckInputType(pmt); <br>    if (hr!=S_OK) return hr; <br> <br>    if( m_pTIPFilter-&gt;m_pInput-&gt;IsConnected() ) <br>        return m_pTIPFilter-&gt;m_pInput-&gt;GetConnected()-&gt;QueryAccept( pmt ); <br>    else <br>        return S_OK; <br> <br>} //CheckMediaType <br> <br> <br>// Decide on an allocator, override this if you want to use your own allocator <br>// Override DecideBufferSize to call SetProperties. <br>// NOTE this is called during Connect() which <br>// therefore looks after grabbing and locking the object's critical section <br>// <br>// pPin is our downstream peer <br>// ppAlloc is where we return the allocator (Note: if called from filter.cpp in <br>// the usual way this is in fact a pointer to our own output pin's m_pAllocator) <br>// <br>HRESULT <br>CTransInPlaceOutputPin::DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc) <br>{ <br>    // Note that *ppAlloc is almost certainly identical to m_Allocator <br> <br>    HRESULT hr = NOERROR; <br> <br>    // If our input pin has an allocator and it's read/write then we use it. <br>    // Failing that we try to get one from downstream. <br>    *ppAlloc = NULL; <br> <br>    bool fNeedToConfigureAllocator = false; <br> <br>    if (m_pTIPFilter-&gt;InputPin()) { <br>        if (!m_pTIPFilter-&gt;InputPin()-&gt;ReadOnly()) { <br>            *ppAlloc = m_pTIPFilter-&gt;InputPin()-&gt;PeekAllocator(); <br>        } <br>    } <br> <br> <br>    if (*ppAlloc!=NULL) { <br>        // don't need to configure allocator -- upstream filter has <br>        // already configured it <br>        (*ppAlloc)-&gt;AddRef(); <br>    } else { <br>        hr = VFW_E_NO_ALLOCATOR; <br>        if ( IsConnected() ) { <br>            // Get an addreffed allocator from the downstream input pin. <br>            hr = m_pInputPin-&gt;GetAllocator( ppAlloc ); <br>            fNeedToConfigureAllocator = true; <br>        } <br>    } <br> <br> <br>    if (*ppAlloc==NULL) { <br>        // Can't get one from upstream or downstream, so must use our own. <br> <br>        hr = InitAllocator(ppAlloc); <br>        fNeedToConfigureAllocator = true; <br>    } <br> <br>    if(FAILED(hr)) <br>        return hr; <br> <br>    ASSERT( *ppAlloc != NULL ); <br> <br>    if (fNeedToConfigureAllocator) { <br> <br>        ALLOCATOR_PROPERTIES prop; <br>        ZeroMemory(&amp;prop, sizeof(prop)); <br> <br>        // Try to get requirements from downstream <br>        pPin-&gt;GetAllocatorRequirements(&amp;prop); <br> <br>        // if he doesn't care about alignment, then set it to 1 <br>        if (prop.cbAlign == 0) { <br>            prop.cbAlign = 1; <br>        } <br> <br>        hr = DecideBufferSize(*ppAlloc, &amp;prop); <br> <br>        if (FAILED(hr)) { <br>            (*ppAlloc)-&gt;Release(); <br>            *ppAlloc = NULL; <br>        } <br>    }     <br> <br>    // Tell the downstream input pin <br>    return pPin-&gt;NotifyAllocator(*ppAlloc, FALSE); <br> <br>} // DecideAllocator <br> <br> <br>/* Receive notifications from our own input pin as to which allocator we <br>   are actually going to use.  Only call if we are connected downstream. <br>   Propagate the choice to any connected downstream input pin. <br>*/ <br>HRESULT <br>CTransInPlaceOutputPin::ReceiveAllocator(IMemAllocator * pAllocator, BOOL bReadOnly) <br>{ <br>    ASSERT( IsConnected() ); <br>    ALLOCATOR_PROPERTIES Props, Actual; <br> <br>    if (bReadOnly) { <br> <br>        // We cannot use a read-only allocator, but we must check that the allocator <br>        // we have matches the properties that we need. <br> <br>        HRESULT hr; <br>        hr = pAllocator-&gt;GetProperties(&amp;Props); <br>        if (FAILED(hr)) { <br>            return hr; <br>        } <br>        hr = m_pAllocator-&gt;SetProperties(&amp;Props, &amp;Actual); <br>        if (FAILED(hr)) { <br>            return hr; <br>        } <br>        if (  (Props.cBuffers &gt; Actual.cBuffers) <br>           || (Props.cbBuffer &gt; Actual.cbBuffer) <br>           || (Props.cbAlign  &gt; Actual.cbAlign) <br>           ) { <br>            return E_FAIL; <br>        } <br>        return S_OK; <br> <br>    } else { <br> <br>        // Propagate the allocator. <br>        // It's possible that the old and the new are the same thing. <br>        // AddRef before release ensures that we don't unload it. <br>        pAllocator-&gt;AddRef(); <br>        if (m_pAllocator != NULL) <br>             m_pAllocator-&gt;Release(); <br> <br>        m_pAllocator = pAllocator; <br> <br>        // Propagate the allocator downstream <br>        return m_pInputPin-&gt;NotifyAllocator( pAllocator, FALSE ); <br>    } <br> <br> <br>} // receiveAllocator </code></pre>
<p>&nbsp;</p></body>
</HTML>
