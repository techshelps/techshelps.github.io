<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OUTPUTQ.H</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2756"></a>OUTPUTQ.H</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>// <br>//  outputq.h <br>// <br>//  Defines the COutputQueue class <br>// <br>//  Makes a queue of samples and sends them <br>//  to an output pin <br>// <br>//  The class will optionally send the samples to the pin directly <br>// <br>// <br> <br>typedef CGenericList&lt;IMediaSample&gt; CSampleList; <br> <br>class COutputQueue : public CCritSec <br>{ <br>public: <br>    //  Constructor <br>    COutputQueue(IPin      *pInputPin,          //  Pin to send stuff to <br>                 HRESULT   *phr,                //  'Return code' <br>                 BOOL       bAuto = TRUE,       //  Ask pin if blocks <br>                 BOOL       bQueue = TRUE,      //  Send through queue (ignored if <br>                                                //  bAuto set) <br>                 LONG       lBatchSize = 1,     //  Batch <br>                 BOOL       bBatchExact = FALSE,//  Batch exactly to BatchSize <br>                 LONG       lListSize =         //  Likely number in the list <br>                                DEFAULTCACHE, <br>                 DWORD      dwPriority =        //  Priority of thread to create <br>                                THREAD_PRIORITY_NORMAL <br>                ); <br>    ~COutputQueue(); <br> <br>    // enter flush state - discard all data <br>    void BeginFlush();      // Begin flushing samples <br> <br>    // re-enable receives (pass this downstream) <br>    void EndFlush();        // Complete flush of samples - downstream <br>                            // pin guaranteed not to block at this stage <br> <br>    void EOS();             // Call this on End of stream <br> <br>    void SendAnyway();      // Send batched samples anyway (if bBatchExact set) <br> <br>    void NewSegment( <br>            REFERENCE_TIME tStart, <br>            REFERENCE_TIME tStop, <br>            double dRate); <br> <br>    HRESULT Receive(IMediaSample *pSample); <br> <br>    // do something with these media samples <br>    HRESULT ReceiveMultiple ( <br>        IMediaSample **pSamples, <br>        long nSamples, <br>        long *nSamplesProcessed); <br> <br>    void Reset();           // Reset m_hr ready for more data <br> <br>    //  See if its idle or not <br>    BOOL IsIdle(); <br> <br>protected: <br>    static DWORD WINAPI InitialThreadProc(LPVOID pv); <br>    DWORD ThreadProc(); <br>    BOOL  IsQueued() <br>    { <br>        return m_List != NULL; <br>    }; <br> <br>    //  The critical section MUST be held when this is called <br>    void QueueSample(IMediaSample *pSample); <br> <br>    BOOL IsSpecialSample(IMediaSample *pSample) <br>    { <br>        return (DWORD)pSample &gt; 0xFFFFFFF0; <br>    }; <br> <br>    //  Remove and Release() batched and queued samples <br>    void FreeSamples(); <br> <br>    //  Notify the thread there is something to do <br>    void NotifyThread(); <br> <br> <br>protected: <br>    //  Queue 'messages' <br>    #define SEND_PACKET      ((IMediaSample *)0xFFFFFFFE)  // Send batch <br>    #define EOS_PACKET       ((IMediaSample *)0xFFFFFFFD)  // End of stream <br>    #define RESET_PACKET     ((IMediaSample *)0xFFFFFFFC)  // Reset m_hr <br>    #define NEW_SEGMENT      ((IMediaSample *)0xFFFFFFFB)  // send NewSegment <br> <br>    // new segment packet is always followed by one of these <br>    struct NewSegmentPacket { <br>        REFERENCE_TIME tStart; <br>        REFERENCE_TIME tStop; <br>        double dRate; <br>    }; <br> <br>    // Remember input stuff <br>    IPin          * const m_pPin; <br>    IMemInputPin  *       m_pInputPin; <br>    BOOL            const m_bBatchExact; <br>    LONG            const m_lBatchSize; <br> <br>    CSampleList   *       m_List; <br>    HANDLE                m_hSem; <br>    CAMEvent                m_evFlushComplete; <br>    HANDLE                m_hThread; <br>    IMediaSample  **      m_ppSamples; <br>    LONG                  m_nBatched; <br> <br>    //  Wait optimization <br>    LONG                  m_lWaiting; <br>    //  Flush synchronization <br>    BOOL                  m_bFlushing; <br>    BOOL                  m_bFlushed; <br> <br>    //  Terminate now <br>    BOOL                  m_bTerminate; <br> <br>    //  Send anyway flag for batching <br>    BOOL                  m_bSendAnyway; <br> <br>    //  Deferred 'return code' <br>    BOOL volatile         m_hr; <br>}; <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
