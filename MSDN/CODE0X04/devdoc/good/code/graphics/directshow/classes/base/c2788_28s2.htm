<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WXLIST.H</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2792"></a>WXLIST.H</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>// Non MFC based generic template list class, December 1994 <br> <br>/* A generic list of pointers to objects. <br>   No storage management or copying is done on the objects pointed to. <br>   Objectives: avoid using MFC libraries in ndm kernel mode and <br>   provide a really useful list type. <br> <br>   The class is thread safe in that separate threads may add and <br>   delete items in the list concurrently although the application <br>   must ensure that constructor and destructor access is suitably <br>   synchronised. An application can cause deadlock with operations <br>   which use two lists by simultaneously calling <br>   list1-&gt;Operation(list2) and list2-&gt;Operation(list1).  So don't! <br> <br>   The names must not conflict with MFC classes as an application <br>   may use both. <br>   */ <br> <br>#ifndef __WXLIST__ <br>#define __WXLIST__ <br> <br>   /* A POSITION represents (in some fashion that's opaque) a cursor <br>      on the list that can be set to identify any element.  NULL is <br>      a valid value and several operations regard NULL as the position <br>      "one step off the end of the list".  (In an n element list there <br>      are n+1 places to insert and NULL is that "n+1-th" value). <br>      The POSITION of an element in the list is only invalidated if <br>      that element is deleted.  Move operations may mean that what <br>      was a valid POSITION in one list is now a valid POSITION in <br>      a different list. <br> <br>      Some operations which at first sight are illegal are allowed as <br>      harmless no-ops.  For instance RemoveHead is legal on an empty <br>      list and it returns NULL.  This allows an atomic way to test if <br>      there is an element there, and if so, get it.  The two operations <br>      AddTail and RemoveHead thus implement a MONITOR (See Hoare's paper). <br> <br>      Single element operations return POSITIONs, non-NULL means it worked. <br>      whole list operations return a BOOL.  TRUE means it all worked. <br> <br>      This definition is the same as the POSITION type for MFCs, so we must <br>      avoid defining it twice. <br>   */ <br>#ifndef __AFX_H__ <br>struct __POSITION { int unused; }; <br>typedef __POSITION* POSITION; <br>#endif <br> <br>const int DEFAULTCACHE = 10;    /* Default node object cache size */ <br> <br>/* A class representing one node in a list. <br>   Each node knows a pointer to it's adjacent nodes and also a pointer <br>   to the object that it looks after. <br>   All of these pointers can be retrieved or set through member functions. <br>*/ <br>class CBaseList  <br>#ifdef DEBUG <br>    : public CBaseObject <br>#endif <br>{ <br>    /* Making these classes inherit from CBaseObject does nothing <br>       functionally but it allows us to check there are no memory <br>       leaks in debug builds.  <br>    */ <br> <br>public: <br> <br>#ifdef DEBUG <br>    class CNode : public CBaseObject { <br>#else <br>    class CNode { <br>#endif <br> <br>        CNode *m_pPrev;         /* Previous node in the list */ <br>        CNode *m_pNext;         /* Next node in the list */ <br>        void *m_pObject;      /* Pointer to the object */ <br> <br>    public: <br> <br>        /* Constructor - initialise the object's pointers */ <br>        CNode() <br>#ifdef DEBUG <br>            : CBaseObject(NAME("List node")) <br>#endif <br>        { <br>        }; <br> <br> <br>        /* Return the previous node before this one */ <br>        CNode *Prev() const { return m_pPrev; }; <br> <br> <br>        /* Return the next node after this one */ <br>        CNode *Next() const { return m_pNext; }; <br> <br> <br>        /* Set the previous node before this one */ <br>        void SetPrev(CNode *p) { m_pPrev = p; }; <br> <br> <br>        /* Set the next node after this one */ <br>        void SetNext(CNode *p) { m_pNext = p; }; <br> <br> <br>        /* Get the pointer to the object for this node */ <br>        void *GetData() const { return m_pObject; }; <br> <br> <br>        /* Set the pointer to the object for this node */ <br>        void SetData(void *p) { m_pObject = p; }; <br>    }; <br> <br>    class CNodeCache <br>    { <br>    public: <br>        CNodeCache(INT iCacheSize) : m_iCacheSize(iCacheSize), <br>                                     m_pHead(NULL), <br>                                     m_iUsed(0) <br>                                     {}; <br>        ~CNodeCache() { <br>            CNode *pNode = m_pHead; <br>            while (pNode) { <br>                CNode *pCurrent = pNode; <br>                pNode = pNode-&gt;Next(); <br>                delete pCurrent; <br>            } <br>        }; <br>        void AddToCache(CNode *pNode) <br>        { <br>            if (m_iUsed &lt; m_iCacheSize) { <br>                pNode-&gt;SetNext(m_pHead); <br>                m_pHead = pNode; <br>                m_iUsed++; <br>            } else { <br>                delete pNode; <br>            } <br>        }; <br>        CNode *RemoveFromCache() <br>        { <br>            CNode *pNode = m_pHead; <br>            if (pNode != NULL) { <br>                m_pHead = pNode-&gt;Next(); <br>                m_iUsed--; <br>                ASSERT(m_iUsed &gt;= 0); <br>            } else { <br>                ASSERT(m_iUsed == 0); <br>            } <br>            return pNode; <br>        }; <br>    private: <br>        INT m_iCacheSize; <br>        INT m_iUsed; <br>        CNode *m_pHead; <br>    }; <br> <br>protected: <br> <br>    CNode* m_pFirst;    /* Pointer to first node in the list */ <br>    CNode* m_pLast;     /* Pointer to the last node in the list */ <br>    LONG m_Count;       /* Number of nodes currently in the list */ <br> <br>private: <br> <br>    CNodeCache m_Cache; /* Cache of unused node pointers */ <br> <br>private: <br> <br>    /* These override the default copy constructor and assignment <br>       operator for all list classes. They are in the private class <br>       declaration section so that anybody trying to pass a list <br>       object by value will generate a compile time error of <br>       "cannot access the private member function". If these were <br>       not here then the compiler will create default constructors <br>       and assignment operators which when executed first take a <br>       copy of all member variables and then during destruction <br>       delete them all. This must not be done for any heap <br>       allocated data. <br>    */ <br>    CBaseList(const CBaseList &amp;refList); <br>    CBaseList &amp;operator=(const CBaseList &amp;refList); <br> <br>public: <br> <br>    CBaseList(TCHAR *pName, <br>              INT iItems); <br> <br>    CBaseList(TCHAR *pName); <br> <br>    ~CBaseList(); <br> <br>    /* Remove all the nodes from *this i.e. make the list empty */ <br>    void RemoveAll(); <br> <br> <br>    /* Return a cursor which identifies the first element of *this */ <br>    POSITION GetHeadPositionI() const; <br> <br> <br>    /* Return a cursor which identifies the last element of *this */ <br>    POSITION GetTailPositionI() const; <br> <br> <br>    /* Return the number of objects in *this */ <br>    int GetCountI() const; <br> <br>protected: <br>    /* Return the pointer to the object at rp, <br>       Update rp to the next node in *this <br>       but make it NULL if it was at the end of *this. <br>       This is a wart retained for backwards compatibility. <br>       GetPrev is not implemented. <br>       Use Next, Prev and Get separately. <br>    */ <br>    void *GetNextI(POSITION&amp; rp) const; <br> <br> <br>    /* Return a pointer to the object at p <br>       Asking for the object at NULL will return NULL harmlessly. <br>    */ <br>    void *GetI(POSITION p) const; <br> <br>public: <br>    /* return the next / prev position in *this <br>       return NULL when going past the end/start. <br>       Next(NULL) is same as GetHeadPosition() <br>       Prev(NULL) is same as GetTailPosition() <br>       An n element list therefore behaves like a n+1 element <br>       cycle with NULL at the start/end. <br> <br>       !!WARNING!! - This handling of NULL is DIFFERENT from GetNext. <br> <br>       Some reasons are: <br>       1. For a list of n items there are n+1 positions to insert <br>          These are conveniently encoded as the n POSITIONs and NULL. <br>       2. If you are keeping a list sorted (fairly common) and you <br>          search forward for an element to insert before and don't <br>          find it you finish up with NULL as the element before which <br>          to insert.  You then want that NULL to be a valid POSITION <br>          so that you can insert before it and you want that insertion <br>          point to mean the (n+1)-th one that doesn't have a POSITION. <br>          (symmetrically if you are working backwards through the list). <br>       3. It simplifies the algebra which the methods generate. <br>          e.g. AddBefore(p,x) is identical to AddAfter(Prev(p),x) <br>          in ALL cases.  All the other arguments probably are reflections <br>          of the algebraic point. <br>    */ <br>    POSITION Next(POSITION pos) const <br>    { <br>        if (pos == NULL) { <br>            return (POSITION) m_pFirst; <br>        } <br>        CNode *pn = (CNode *) pos; <br>        return (POSITION) pn-&gt;Next(); <br>    } //Next <br> <br>    // See Next <br>    POSITION Prev(POSITION pos) const <br>    { <br>        if (pos == NULL) { <br>            return (POSITION) m_pLast; <br>        } <br>        CNode *pn = (CNode *) pos; <br>        return (POSITION) pn-&gt;Prev(); <br>    } //Prev <br> <br> <br>    /* Return the first position in *this which holds the given <br>       pointer.  Return NULL if the pointer was not not found. <br>    */ <br>protected: <br>    POSITION FindI( void * pObj) const; <br> <br>    // ??? Should there be (or even should there be only) <br>    // ??? POSITION FindNextAfter(void * pObj, POSITION p) <br>    // ??? And of course FindPrevBefore too. <br>    // ??? List.Find(&amp;Obj) then becomes List.FindNextAfter(&amp;Obj, NULL) <br> <br> <br>    /* Remove the first node in *this (deletes the pointer to its <br>       object from the list, does not free the object itself). <br>       Return the pointer to its object. <br>       If *this was already empty it will harmlessly return NULL. <br>    */ <br>    void *RemoveHeadI(); <br> <br> <br>    /* Remove the last node in *this (deletes the pointer to its <br>       object from the list, does not free the object itself). <br>       Return the pointer to its object. <br>       If *this was already empty it will harmlessly return NULL. <br>    */ <br>    void *RemoveTailI(); <br> <br> <br>    /* Remove the node identified by p from the list (deletes the pointer <br>       to its object from the list, does not free the object itself). <br>       Asking to Remove the object at NULL will harmlessly return NULL. <br>       Return the pointer to the object removed. <br>    */ <br>    void *RemoveI(POSITION p); <br> <br>    /* Add single object *pObj to become a new last element of the list. <br>       Return the new tail position, NULL if it fails. <br>       If you are adding a COM objects, you might want AddRef it first. <br>       Other existing POSITIONs in *this are still valid <br>    */ <br>    POSITION AddTailI(void * pObj); <br>public: <br> <br> <br>    /* Add all the elements in *pList to the tail of *this. <br>       This duplicates all the nodes in *pList (i.e. duplicates <br>       all its pointers to objects).  It does not duplicate the objects. <br>       If you are adding a list of pointers to a COM object into the list <br>       it's a good idea to AddRef them all  it when you AddTail it. <br>       Return TRUE if it all worked, FALSE if it didn't. <br>       If it fails some elements may have been added. <br>       Existing POSITIONs in *this are still valid <br> <br>       If you actually want to MOVE the elements, use MoveToTail instead. <br>    */ <br>    BOOL AddTail(CBaseList *pList); <br> <br> <br>    /* Mirror images of AddHead: */ <br> <br>    /* Add single object to become a new first element of the list. <br>       Return the new head position, NULL if it fails. <br>       Existing POSITIONs in *this are still valid <br>    */ <br>protected: <br>    POSITION AddHeadI(void * pObj); <br>public: <br> <br>    /* Add all the elements in *pList to the head of *this. <br>       Same warnings apply as for AddTail. <br>       Return TRUE if it all worked, FALSE if it didn't. <br>       If it fails some of the objects may have been added. <br> <br>       If you actually want to MOVE the elements, use MoveToHead instead. <br>    */ <br>    BOOL AddHead(CBaseList *pList); <br> <br> <br>    /* Add the object *pObj to *this after position p in *this. <br>       AddAfter(NULL,x) adds x to the start - equivalent to AddHead <br>       Return the position of the object added, NULL if it failed. <br>       Existing POSITIONs in *this are undisturbed, including p. <br>    */ <br>protected: <br>    POSITION AddAfterI(POSITION p, void * pObj); <br>public: <br> <br>    /* Add the list *pList to *this after position p in *this <br>       AddAfter(NULL,x) adds x to the start - equivalent to AddHead <br>       Return TRUE if it all worked, FALSE if it didn't. <br>       If it fails, some of the objects may be added <br>       Existing POSITIONs in *this are undisturbed, including p. <br>    */ <br>    BOOL AddAfter(POSITION p, CBaseList *pList); <br> <br> <br>    /* Mirror images: <br>       Add the object *pObj to this-List after position p in *this. <br>       AddBefore(NULL,x) adds x to the end - equivalent to AddTail <br>       Return the position of the new object, NULL if it fails <br>       Existing POSITIONs in *this are undisturbed, including p. <br>    */ <br>    protected: <br>    POSITION AddBeforeI(POSITION p, void * pObj); <br>    public: <br> <br>    /* Add the list *pList to *this before position p in *this <br>       AddAfter(NULL,x) adds x to the start - equivalent to AddHead <br>       Return TRUE if it all worked, FALSE if it didn't. <br>       If it fails, some of the objects may be added <br>       Existing POSITIONs in *this are undisturbed, including p. <br>    */ <br>    BOOL AddBefore(POSITION p, CBaseList *pList); <br> <br> <br>    /* Note that AddAfter(p,x) is equivalent to AddBefore(Next(p),x) <br>       even in cases where p is NULL or Next(p) is NULL. <br>       Similarly for mirror images etc. <br>       This may make it easier to argue about programs. <br>    */ <br> <br> <br> <br>    /* The following operations do not copy any elements. <br>       They move existing blocks of elements around by switching pointers. <br>       They are fairly efficient for long lists as for short lists. <br>       (Alas, the Count slows things down). <br> <br>       They split the list into two parts. <br>       One part remains as the original list, the other part <br>       is appended to the second list.  There are eight possible <br>       variations: <br>       Split the list {after/before} a given element <br>       keep the {head/tail} portion in the original list <br>       append the rest to the {head/tail} of the new list. <br> <br>       Since After is strictly equivalent to Before Next <br>       we are not in serious need of the Before/After variants. <br>       That leaves only four. <br> <br>       If you are processing a list left to right and dumping <br>       the bits that you have processed into another list as <br>       you go, the Tail/Tail variant gives the most natural result. <br>       If you are processing in reverse order, Head/Head is best. <br> <br>       By using NULL positions and empty lists judiciously either <br>       of the other two can be built up in two operations. <br> <br>       The definition of NULL (see Next/Prev etc) means that <br>       degenerate cases include <br>          "move all elements to new list" <br>          "Split a list into two lists" <br>          "Concatenate two lists" <br>          (and quite a few no-ops) <br> <br>       !!WARNING!! The type checking won't buy you much if you get list <br>       positions muddled up - e.g. use a POSITION that's in a different <br>       list and see what a mess you get! <br>    */ <br> <br>    /* Split *this after position p in *this <br>       Retain as *this the tail portion of the original *this <br>       Add the head portion to the tail end of *pList <br>       Return TRUE if it all worked, FALSE if it didn't. <br> <br>       e.g. <br>          foo-&gt;MoveToTail(foo-&gt;GetHeadPosition(), bar); <br>              moves one element from the head of foo to the tail of bar <br>          foo-&gt;MoveToTail(NULL, bar); <br>              is a no-op, returns NULL <br>          foo-&gt;MoveToTail(foo-&gt;GetTailPosition, bar); <br>              concatenates foo onto the end of bar and empties foo. <br> <br>       A better, except excessively long name might be <br>           MoveElementsFromHeadThroughPositionToOtherTail <br>    */ <br>    BOOL MoveToTail(POSITION pos, CBaseList *pList); <br> <br> <br>    /* Mirror image: <br>       Split *this before position p in *this. <br>       Retain in *this the head portion of the original *this <br>       Add the tail portion to the start (i.e. head) of *pList <br> <br>       e.g. <br>          foo-&gt;MoveToHead(foo-&gt;GetTailPosition(), bar); <br>              moves one element from the tail of foo to the head of bar <br>          foo-&gt;MoveToHead(NULL, bar); <br>              is a no-op, returns NULL <br>          foo-&gt;MoveToHead(foo-&gt;GetHeadPosition, bar); <br>              concatenates foo onto the start of bar and empties foo. <br>    */ <br>    BOOL MoveToHead(POSITION pos, CBaseList *pList); <br> <br> <br>    /* Reverse the order of the [pointers to] objects in *this <br>    */ <br>    void Reverse(); <br> <br> <br>    /* set cursor to the position of each element of list in turn  */ <br>    #define TRAVERSELIST(list, cursor)               \ <br>    for ( cursor = (list).GetHeadPosition()           \ <br>        ; cursor!=NULL                               \ <br>        ; cursor = (list).Next(cursor)                \ <br>        ) <br> <br> <br>    /* set cursor to the position of each element of list in turn <br>       in reverse order <br>    */ <br>    #define REVERSETRAVERSELIST(list, cursor)        \ <br>    for ( cursor = (list).GetTailPosition()           \ <br>        ; cursor!=NULL                               \ <br>        ; cursor = (list).Prev(cursor)                \ <br>        ) <br> <br>}; // end of class declaration <br> <br>template&lt;class OBJECT&gt; class CGenericList : public CBaseList <br>{ <br>public: <br>    CGenericList(TCHAR *pName, <br>                 INT iItems, <br>                 BOOL bLock = TRUE, <br>                 BOOL bAlert = FALSE) : <br>                     CBaseList(pName, iItems) { <br>        UNREFERENCED_PARAMETER(bAlert); <br>        UNREFERENCED_PARAMETER(bLock); <br>    }; <br>    CGenericList(TCHAR *pName) : <br>                     CBaseList(pName) { <br>    }; <br> <br>    POSITION GetHeadPosition() const { return (POSITION)m_pFirst; } <br>    POSITION GetTailPosition() const { return (POSITION)m_pLast; } <br>    int GetCount() const { return m_Count; } <br> <br>    OBJECT *GetNext(POSITION&amp; rp) const { return (OBJECT *) GetNextI(rp); } <br> <br>    OBJECT *Get(POSITION p) const { return (OBJECT *) GetI(p); } <br>    OBJECT *GetHead() const  { return Get(GetHeadPosition()); } <br> <br>    OBJECT *RemoveHead() { return (OBJECT *) RemoveHeadI(); } <br> <br>    OBJECT *RemoveTail() { return (OBJECT *) RemoveTailI(); } <br> <br>    OBJECT *Remove(POSITION p) { return (OBJECT *) RemoveI(p); } <br>    POSITION AddBefore(POSITION p, OBJECT * pObj) { return AddBeforeI(p, pObj); } <br>    POSITION AddAfter(POSITION p, OBJECT * pObj)  { return AddAfterI(p, pObj); } <br>    POSITION AddHead(OBJECT * pObj) { return AddHeadI(pObj); } <br>    POSITION AddTail(OBJECT * pObj)  { return AddTailI(pObj); } <br>    BOOL AddTail(CGenericList&lt;OBJECT&gt; *pList) <br>            { return CBaseList::AddTail((CBaseList *) pList); } <br>    BOOL AddHead(CGenericList&lt;OBJECT&gt; *pList) <br>            { return CBaseList::AddHead((CBaseList *) pList); } <br>    BOOL AddAfter(POSITION p, CGenericList&lt;OBJECT&gt; *pList) <br>            { return CBaseList::AddAfter(p, (CBaseList *) pList); }; <br>    BOOL AddBefore(POSITION p, CGenericList&lt;OBJECT&gt; *pList) <br>            { return CBaseList::AddBefore(p, (CBaseList *) pList); }; <br>    POSITION Find( OBJECT * pObj) const { return FindI(pObj); } <br>}; // end of class declaration <br> <br> <br> <br>/* These define the standard list types */ <br> <br>typedef CGenericList&lt;CBaseObject&gt; CBaseObjectList; <br>typedef CGenericList&lt;IUnknown&gt; CBaseInterfaceList; <br> <br>#endif /* __WXLIST__ */ <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
