<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>RENBASE.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2764"></a>RENBASE.CPP</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>#include &lt;streams.h&gt;        // ActiveMovie base class definitions <br>#include &lt;mmsystem.h&gt;       // Needed for definition of timeGetTime <br>#include &lt;limits.h&gt;         // Standard data type limit definitions <br>#include &lt;measure.h&gt;        // Used for time critical log functions <br> <br>#pragma warning(disable:4355) <br> <br>//  Helper function for clamping time differences <br>int inline TimeDiff(REFERENCE_TIME rt) <br>{ <br>    if (rt &lt; - (50 * UNITS)) { <br>        return -(50 * UNITS); <br>    } else <br>    if (rt &gt; 50 * UNITS) { <br>        return 50 * UNITS; <br>    } else return (int)rt; <br>} <br> <br>// Implements the CBaseRenderer class <br> <br>CBaseRenderer::CBaseRenderer(REFCLSID RenderClass, // CLSID for this renderer <br>     TCHAR *pName,         // Debug ONLY description <br>     LPUNKNOWN pUnk,       // Aggregated owner object <br>     HRESULT *phr) :       // General OLE return code <br> <br>    CBaseFilter(pName,pUnk,&amp;m_InterfaceLock,RenderClass), <br>    m_evComplete(TRUE), <br>    m_bAbort(FALSE), <br>    m_pPosition(NULL), <br>    m_ThreadSignal(TRUE), <br>    m_bStreaming(FALSE), <br>    m_bEOS(FALSE), <br>    m_bEOSDelivered(FALSE), <br>    m_pMediaSample(NULL), <br>    m_dwAdvise(0), <br>    m_pQSink(NULL), <br>    m_pInputPin(NULL), <br>    m_bRepaintStatus(TRUE), <br>    m_SignalTime(0), <br>    m_bInReceive(FALSE), <br>    m_EndOfStreamTimer(0) <br>{ <br>    Ready(); <br>#ifdef PERF <br>    m_idBaseStamp = MSR_REGISTER("BaseRenderer: sample time stamp"); <br>    m_idBaseRenderTime = MSR_REGISTER("BaseRenderer: draw time (msec)"); <br>    m_idBaseAccuracy = MSR_REGISTER("BaseRenderer: Accuracy (msec)"); <br>#endif <br>} <br> <br> <br>// Delete the dynamically allocated IMediaPosition and IMediaSeeking helper <br>// object. The object is created when somebody queries us. These are standard <br>// control interfaces for seeking and setting start/stop positions and rates. <br>// We will probably also have made an input pin based on CRendererInputPin <br>// that has to be deleted, it's created when an enumerator calls our GetPin <br> <br>CBaseRenderer::~CBaseRenderer() <br>{ <br>    ASSERT(m_bStreaming == FALSE); <br>    ASSERT(m_EndOfStreamTimer == 0); <br>    StopStreaming(); <br>    ClearPendingSample(); <br> <br>    // Delete any IMediaPosition implementation <br> <br>    if (m_pPosition) { <br>delete m_pPosition; <br>m_pPosition = NULL; <br>    } <br> <br>    // Delete any input pin created <br> <br>    if (m_pInputPin) { <br>delete m_pInputPin; <br>m_pInputPin = NULL; <br>    } <br> <br>    // Release any Quality sink <br> <br>    ASSERT(m_pQSink == NULL); <br>} <br> <br> <br>// This returns the IMediaPosition and IMediaSeeking interfaces <br> <br>HRESULT CBaseRenderer::GetMediaPositionInterface(REFIID riid,void **ppv) <br>{ <br>    CAutoLock cRendererLock(&amp;m_InterfaceLock); <br>    if (m_pPosition) { <br>return m_pPosition-&gt;NonDelegatingQueryInterface(riid,ppv); <br>    } <br> <br>    HRESULT hr = NOERROR; <br> <br>    // Create implementation of this dynamically since sometimes we may <br>    // never try and do a seek. The helper object implements a position <br>    // control interface (IMediaPosition) which in fact simply takes the <br>    // calls normally from the filter graph and passes them upstream <br> <br>    m_pPosition = new CRendererPosPassThru(NAME("Renderer CPosPassThru"), <br>   CBaseFilter::GetOwner(), <br>   (HRESULT *) &amp;hr, <br>   GetPin(0)); <br>    if (m_pPosition == NULL) { <br>return E_OUTOFMEMORY; <br>    } <br> <br>    if (FAILED(hr)) { <br>delete m_pPosition; <br>m_pPosition = NULL; <br>return E_NOINTERFACE; <br>    } <br>    return GetMediaPositionInterface(riid,ppv); <br>} <br> <br> <br>// Overriden to say what interfaces we support and where <br> <br>STDMETHODIMP CBaseRenderer::NonDelegatingQueryInterface(REFIID riid,void **ppv) <br>{ <br>    // Do we have this interface <br> <br>    if (riid == IID_IMediaPosition || riid == IID_IMediaSeeking) { <br>return GetMediaPositionInterface(riid,ppv); <br>    } else { <br>return CBaseFilter::NonDelegatingQueryInterface(riid,ppv); <br>    } <br>} <br> <br> <br>// This is called whenever we change states, we have a manual reset event that <br>// is signalled whenever we don't won't the source filter thread to wait in us <br>// (such as in a stopped state) and likewise is not signalled whenever it can <br>// wait (during paused and running) this function sets or resets the thread <br>// event. The event is used to stop source filter threads waiting in Receive <br> <br>HRESULT CBaseRenderer::SourceThreadCanWait(BOOL bCanWait) <br>{ <br>    if (bCanWait == TRUE) { <br>m_ThreadSignal.Reset(); <br>    } else { <br>m_ThreadSignal.Set(); <br>    } <br>    return NOERROR; <br>} <br> <br> <br>#ifdef DEBUG <br>// Dump the current renderer state to the debug terminal. The hardest part of <br>// the renderer is the window where we unlock everything to wait for a clock <br>// to signal it is time to draw or for the application to cancel everything <br>// by stopping the filter. If we get things wrong we can leave the thread in <br>// WaitForRenderTime with no way for it to ever get out and we will deadlock <br> <br>void CBaseRenderer::DisplayRendererState() <br>{ <br>    TCHAR DebugString[128]; <br>    wsprintf(DebugString,TEXT("\n\nTimed out in WaitForRenderTime\n")); <br>    OutputDebugString(DebugString); <br> <br>    // No way should this be signalled at this point <br> <br>    BOOL bSignalled = m_ThreadSignal.Check(); <br>    wsprintf(DebugString,TEXT("Signal sanity check %d\n"),bSignalled); <br>    OutputDebugString(DebugString); <br> <br>    // Now output the current renderer state variables <br> <br>    wsprintf(DebugString,TEXT("Filter state %d\n"),m_State); <br>    OutputDebugString(DebugString); <br>    wsprintf(DebugString,TEXT("Abort flag %d\n"),m_bAbort); <br>    OutputDebugString(DebugString); <br>    wsprintf(DebugString,TEXT("Streaming flag %d\n"),m_bStreaming); <br>    OutputDebugString(DebugString); <br>    wsprintf(DebugString,TEXT("Clock advise link %d\n"),m_dwAdvise); <br>    OutputDebugString(DebugString); <br>    wsprintf(DebugString,TEXT("Current media sample %x\n"),m_pMediaSample); <br>    OutputDebugString(DebugString); <br>    wsprintf(DebugString,TEXT("EOS signalled %d\n"),m_bEOS); <br>    OutputDebugString(DebugString); <br>    wsprintf(DebugString,TEXT("EOS delivered %d\n"),m_bEOSDelivered); <br>    OutputDebugString(DebugString); <br>    wsprintf(DebugString,TEXT("Repaint status %d\n"),m_bRepaintStatus); <br>    OutputDebugString(DebugString); <br> <br>    // Output the delayed end of stream timer information <br> <br>    wsprintf(DebugString,TEXT("End of stream timer %x\n"),m_EndOfStreamTimer); <br>    OutputDebugString(DebugString); <br>    wsprintf(DebugString,TEXT("Deliver time %s\n"),CDisp((LONGLONG)m_SignalTime)); <br>    OutputDebugString(DebugString); <br> <br>    // Should never timeout during a flushing state <br> <br>    BOOL bFlushing = m_pInputPin-&gt;IsFlushing(); <br>    wsprintf(DebugString,TEXT("Flushing sanity check %d\n"),bFlushing); <br>    OutputDebugString(DebugString); <br> <br>    // Display the time we were told to start at <br>    wsprintf(DebugString,TEXT("Last run time %s\n"),CDisp((LONGLONG)m_tStart.m_time)); <br>    OutputDebugString(DebugString); <br> <br>    // Have we got a reference clock <br>    if (m_pClock == NULL) return; <br> <br>    // Get the current time from the wall clock <br> <br>    CRefTime CurrentTime,StartTime,EndTime; <br>    m_pClock-&gt;GetTime((REFERENCE_TIME*) &amp;CurrentTime); <br>    CRefTime Offset = CurrentTime - m_tStart; <br> <br>    // Display the current time from the clock <br> <br>    wsprintf(DebugString,TEXT("Clock time %s\n"),CDisp((LONGLONG)CurrentTime.m_time)); <br>    OutputDebugString(DebugString); <br>    wsprintf(DebugString,TEXT("Time difference %dms\n"),Offset.Millisecs()); <br>    OutputDebugString(DebugString); <br> <br>    // Do we have a sample ready to render <br>    if (m_pMediaSample == NULL) return; <br> <br>    m_pMediaSample-&gt;GetTime((REFERENCE_TIME*)&amp;StartTime, (REFERENCE_TIME*)&amp;EndTime); <br>    wsprintf(DebugString,TEXT("Next sample stream times (Start %d End %d ms)\n"), <br>   StartTime.Millisecs(),EndTime.Millisecs()); <br>    OutputDebugString(DebugString); <br> <br>    // Calculate how long it is until it is due for rendering <br>    CRefTime Wait = (m_tStart + StartTime) - CurrentTime; <br>    wsprintf(DebugString,TEXT("Wait required %d ms\n"),Wait.Millisecs()); <br>    OutputDebugString(DebugString); <br>} <br>#endif <br> <br> <br>// Wait until the clock sets the timer event or we're otherwise signalled. We <br>// set an arbitrary timeout for this wait and if it fires then we display the <br>// current renderer state on the debugger. It will often fire if the filter's <br>// left paused in an application however it may also fire during stress tests <br>// if the synchronisation with application seeks and state changes is faulty <br> <br>#define RENDER_TIMEOUT 10000 <br> <br>HRESULT CBaseRenderer::WaitForRenderTime() <br>{ <br>    HANDLE WaitObjects[] = { m_ThreadSignal, m_RenderEvent }; <br>    DWORD Result = WAIT_TIMEOUT; <br> <br>    // Wait for either the time to arrive or for us to be stopped <br> <br>    OnWaitStart(); <br>    while (Result == WAIT_TIMEOUT) { <br>Result = WaitForMultipleObjects(2,WaitObjects,FALSE,RENDER_TIMEOUT); <br> <br>#ifdef DEBUG <br>if (Result == WAIT_TIMEOUT) DisplayRendererState(); <br>#endif <br> <br>    } <br>    OnWaitEnd(); <br> <br>    // We may have been awoken without the timer firing <br> <br>    if (Result == WAIT_OBJECT_0) { <br>return VFW_E_STATE_CHANGED; <br>    } <br> <br>    SignalTimerFired(); <br>    return NOERROR; <br>} <br> <br> <br>// Poll waiting for Receive to complete.  This really matters when <br>// Receive may set the palette and cause window messages <br>// The problem is that if we don't really wait for a renderer to <br>// stop processing we can deadlock waiting for a transform which <br>// is calling the renderer's Receive() method because the transform's <br>// Stop method doesn't know to process window messages to unblock <br>// the renderer's Receive processing <br>void CBaseRenderer::WaitForReceiveToComplete() <br>{ <br>    for (;;) { <br>if (!m_bInReceive) { <br>    break; <br>} <br> <br>MSG msg; <br>//  Receive all interthread snedmessages <br>PeekMessage(&amp;msg, NULL, WM_NULL, WM_NULL, PM_NOREMOVE); <br> <br>Sleep(1); <br>    } <br> <br>    // If the wakebit for QS_POSTMESSAGE is set, the PeekMessage call <br>    // above just cleared the changebit which will cause some messaging <br>    // calls to block (waitMessage, MsgWaitFor...) now. <br>    // Post a dummy message to set the QS_POSTMESSAGE bit again <br>    if (HIWORD(GetQueueStatus(QS_POSTMESSAGE)) &amp; QS_POSTMESSAGE) { <br>//  Send dummy message <br>PostThreadMessage(GetCurrentThreadId(), WM_NULL, 0, 0); <br>    } <br>} <br> <br>// A filter can have four discrete states, namely Stopped, Running, Paused, <br>// Intermediate. We are in an intermediate state if we are currently trying <br>// to pause but haven't yet got the first sample (or if we have been flushed <br>// in paused state and therefore still have to wait for a sample to arrive) <br> <br>// This class contains an event called m_evComplete which is signalled when <br>// the current state is completed and is not signalled when we are waiting to <br>// complete the last state transition. As mentioned above the only time we <br>// use this at the moment is when we wait for a media sample in paused state <br>// If while we are waiting we receive an end of stream notification from the <br>// source filter then we know no data is imminent so we can reset the event <br>// This means that when we transition to paused the source filter must call <br>// end of stream on us or send us an image otherwise we'll hang indefinately <br> <br> <br>// Simple internal way of getting the real state <br> <br>FILTER_STATE CBaseRenderer::GetRealState() { <br>    return m_State; <br>} <br> <br> <br>// The renderer doesn't complete the full transition to paused states until <br>// it has got one media sample to render. If you ask it for its state while <br>// it's waiting it will return the state along with VFW_S_STATE_INTERMEDIATE <br> <br>STDMETHODIMP CBaseRenderer::GetState(DWORD dwMSecs,FILTER_STATE *State) <br>{ <br>    CheckPointer(State,E_POINTER); <br> <br>    if (WaitDispatchingMessages(m_evComplete, dwMSecs) == WAIT_TIMEOUT) { <br>*State = m_State; <br>return VFW_S_STATE_INTERMEDIATE; <br>    } <br>    *State = m_State; <br>    return NOERROR; <br>} <br> <br> <br>// If we're pausing and we have no samples we don't complete the transition <br>// to State_Paused and we return S_FALSE. However if the m_bAbort flag has <br>// been set then all samples are rejected so there is no point waiting for <br>// one. If we do have a sample then return NOERROR. We will only ever return <br>// VFW_S_STATE_INTERMEDIATE from GetState after being paused with no sample <br>// (calling GetState after either being stopped or Run will NOT return this) <br> <br>HRESULT CBaseRenderer::CompleteStateChange(FILTER_STATE OldState) <br>{ <br>    // Allow us to be paused when disconnected <br> <br>    if (m_pInputPin-&gt;IsConnected() == FALSE) { <br>Ready(); <br>return S_OK; <br>    } <br> <br>    // Have we run off the end of stream <br> <br>    if (IsEndOfStream() == TRUE) { <br>Ready(); <br>return S_OK; <br>    } <br> <br>    // Make sure we get fresh data after being stopped <br> <br>    if (HaveCurrentSample() == TRUE) { <br>if (OldState != State_Stopped) { <br>    Ready(); <br>    return S_OK; <br>} <br>    } <br>    NotReady(); <br>    return S_FALSE; <br>} <br> <br> <br>// When we stop the filter the things we do are:- <br> <br>//      Decommit the allocator being used in the connection <br>//      Release the source filter if it's waiting in Receive <br>//      Cancel any advise link we set up with the clock <br>//      Any end of stream signalled is now obsolete so reset <br>//      Allow us to be stopped when we are not connected <br> <br>STDMETHODIMP CBaseRenderer::Stop() <br>{ <br>    CAutoLock cRendererLock(&amp;m_InterfaceLock); <br> <br>    // Make sure there really is a state change <br> <br>    if (m_State == State_Stopped) { <br>return NOERROR; <br>    } <br> <br>    // Is our input pin connected <br> <br>    if (m_pInputPin-&gt;IsConnected() == FALSE) { <br>NOTE("Input pin is not connected"); <br>m_State = State_Stopped; <br>return NOERROR; <br>    } <br> <br>    CBaseFilter::Stop(); <br> <br>    // If we are going into a stopped state then we must decommit whatever <br>    // allocator we are using it so that any source filter waiting in the <br>    // GetBuffer can be released and unlock themselves for a state change <br> <br>    if (m_pInputPin-&gt;Allocator()) { <br>m_pInputPin-&gt;Allocator()-&gt;Decommit(); <br>    } <br> <br>    // Cancel any scheduled rendering <br> <br>    SetRepaintStatus(TRUE); <br>    StopStreaming(); <br>    SourceThreadCanWait(FALSE); <br>    ResetEndOfStream(); <br>    CancelNotification(); <br> <br>    // There should be no outstanding clock advise <br>    ASSERT(CancelNotification() == S_FALSE); <br>    ASSERT(WAIT_TIMEOUT == WaitForSingleObject((HANDLE)m_RenderEvent,0)); <br>    ASSERT(m_EndOfStreamTimer == 0); <br> <br>    Ready(); <br>    WaitForReceiveToComplete(); <br>    m_bAbort = FALSE; <br>    return NOERROR; <br>} <br> <br> <br>// When we pause the filter the things we do are:- <br> <br>//      Commit the allocator being used in the connection <br>//      Allow a source filter thread to wait in Receive <br>//      Cancel any clock advise link (we may be running) <br>//      Possibly complete the state change if we have data <br>//      Allow us to be paused when we are not connected <br> <br>STDMETHODIMP CBaseRenderer::Pause() <br>{ <br>    CAutoLock cRendererLock(&amp;m_InterfaceLock); <br>    FILTER_STATE OldState = m_State; <br>    ASSERT(m_pInputPin-&gt;IsFlushing() == FALSE); <br> <br>    // Make sure there really is a state change <br> <br>    if (m_State == State_Paused) { <br>return CompleteStateChange(State_Paused); <br>    } <br> <br>    // Has our input pin been connected <br> <br>    if (m_pInputPin-&gt;IsConnected() == FALSE) { <br>NOTE("Input pin is not connected"); <br>m_State = State_Paused; <br>return CompleteStateChange(State_Paused); <br>    } <br> <br>    // Pause the base filter class <br> <br>    HRESULT hr = CBaseFilter::Pause(); <br>    if (FAILED(hr)) { <br>NOTE("Pause failed"); <br>return hr; <br>    } <br> <br>    // Enable EC_REPAINT events again <br> <br>    SetRepaintStatus(TRUE); <br>    StopStreaming(); <br>    SourceThreadCanWait(TRUE); <br>    CancelNotification(); <br>    ResetEndOfStreamTimer(); <br> <br>    // If we are going into a paused state then we must commit whatever <br>    // allocator we are using it so that any source filter can call the <br>    // GetBuffer and expect to get a buffer without returning an error <br> <br>    if (m_pInputPin-&gt;Allocator()) { <br>m_pInputPin-&gt;Allocator()-&gt;Commit(); <br>    } <br> <br>    // There should be no outstanding advise <br>    ASSERT(CancelNotification() == S_FALSE); <br>    ASSERT(WAIT_TIMEOUT == WaitForSingleObject((HANDLE)m_RenderEvent,0)); <br>    ASSERT(m_EndOfStreamTimer == 0); <br>    ASSERT(m_pInputPin-&gt;IsFlushing() == FALSE); <br> <br>    // When we come out of a stopped state we must clear any image we were <br>    // holding onto for frame refreshing. Since renderers see state changes <br>    // first we can reset ourselves ready to accept the source thread data <br>    // Paused or running after being stopped causes the current position to <br>    // be reset so we're not interested in passing end of stream signals <br> <br>    if (OldState == State_Stopped) { <br>m_bAbort = FALSE; <br>ClearPendingSample(); <br>    } <br>    return CompleteStateChange(OldState); <br>} <br> <br> <br>// When we run the filter the things we do are:- <br> <br>//      Commit the allocator being used in the connection <br>//      Allow a source filter thread to wait in Receive <br>//      Signal the render event just to get us going <br>//      Start the base class by calling StartStreaming <br>//      Allow us to be run when we are not connected <br>//      Signal EC_COMPLETE if we are not connected <br> <br>STDMETHODIMP CBaseRenderer::Run(REFERENCE_TIME StartTime) <br>{ <br>    CAutoLock cRendererLock(&amp;m_InterfaceLock); <br>    FILTER_STATE OldState = m_State; <br> <br>    // Make sure there really is a state change <br> <br>    if (m_State == State_Running) { <br>return NOERROR; <br>    } <br> <br>    // Send EC_COMPLETE if we're not connected <br> <br>    if (m_pInputPin-&gt;IsConnected() == FALSE) { <br>NotifyEvent(EC_COMPLETE,S_OK,0); <br>m_State = State_Running; <br>return NOERROR; <br>    } <br> <br>    Ready(); <br> <br>    // Pause the base filter class <br> <br>    HRESULT hr = CBaseFilter::Run(StartTime); <br>    if (FAILED(hr)) { <br>NOTE("Run failed"); <br>return hr; <br>    } <br> <br>    // Allow the source thread to wait <br>    ASSERT(m_pInputPin-&gt;IsFlushing() == FALSE); <br>    SourceThreadCanWait(TRUE); <br>    SetRepaintStatus(FALSE); <br> <br>    // There should be no outstanding advise <br>    ASSERT(CancelNotification() == S_FALSE); <br>    ASSERT(WAIT_TIMEOUT == WaitForSingleObject((HANDLE)m_RenderEvent,0)); <br>    ASSERT(m_EndOfStreamTimer == 0); <br>    ASSERT(m_pInputPin-&gt;IsFlushing() == FALSE); <br> <br>    // If we are going into a running state then we must commit whatever <br>    // allocator we are using it so that any source filter can call the <br>    // GetBuffer and expect to get a buffer without returning an error <br> <br>    if (m_pInputPin-&gt;Allocator()) { <br>m_pInputPin-&gt;Allocator()-&gt;Commit(); <br>    } <br> <br>    // When we come out of a stopped state we must clear any image we were <br>    // holding onto for frame refreshing. Since renderers see state changes <br>    // first we can reset ourselves ready to accept the source thread data <br>    // Paused or running after being stopped causes the current position to <br>    // be reset so we're not interested in passing end of stream signals <br> <br>    if (OldState == State_Stopped) { <br>m_bAbort = FALSE; <br>ClearPendingSample(); <br>    } <br>    return StartStreaming(); <br>} <br> <br> <br>// Return the number of input pins we support <br> <br>int CBaseRenderer::GetPinCount() <br>{ <br>    return 1; <br>} <br> <br> <br>// We only support one input pin and it is numbered zero <br> <br>CBasePin *CBaseRenderer::GetPin(int n) <br>{ <br>    CAutoLock cRendererLock(&amp;m_InterfaceLock); <br>    HRESULT hr = NOERROR; <br>    ASSERT(n == 0); <br> <br>    // Should only ever be called with zero <br> <br>    if (n != 0) { <br>return NULL; <br>    } <br> <br>    // Create the input pin if not already done so <br> <br>    if (m_pInputPin == NULL) { <br>m_pInputPin = new CRendererInputPin(this,&amp;hr,L"In"); <br>    } <br>    return m_pInputPin; <br>} <br> <br> <br>// If "In" then return the IPin for our input pin, otherwise NULL and error <br> <br>STDMETHODIMP CBaseRenderer::FindPin(LPCWSTR Id, IPin **ppPin) <br>{ <br>    CheckPointer(ppPin,E_POINTER); <br> <br>    if (0==lstrcmpW(Id,L"In")) { <br>*ppPin = GetPin(0); <br>ASSERT(*ppPin); <br>(*ppPin)-&gt;AddRef(); <br>    } else { <br>*ppPin = NULL; <br>return VFW_E_NOT_FOUND; <br>    } <br>    return NOERROR; <br>} <br> <br> <br>// Called when the input pin receives an EndOfStream notification. If we have <br>// not got a sample, then notify EC_COMPLETE now. If we have samples, then set <br>// m_bEOS and check for this on completing samples. If we're waiting to pause <br>// then complete the transition to paused state by setting the state event <br> <br>HRESULT CBaseRenderer::EndOfStream() <br>{ <br>    // Ignore these calls if we are stopped <br> <br>    if (m_State == State_Stopped) { <br>return NOERROR; <br>    } <br> <br>    // If we have a sample then wait for it to be rendered <br> <br>    m_bEOS = TRUE; <br>    if (m_pMediaSample) { <br>return NOERROR; <br>    } <br> <br>    // If we are waiting for pause then we are now ready since we cannot now <br>    // carry on waiting for a sample to arrive since we are being told there <br>    // won't be any. This sets an event that the GetState function picks up <br> <br>    Ready(); <br> <br>    // Only signal completion now if we are running otherwise queue it until <br>    // we do run in StartStreaming. This is used when we seek because a seek <br>    // causes a pause where early notification of completion is misleading <br> <br>    if (m_bStreaming) { <br>SendEndOfStream(); <br>    } <br>    return NOERROR; <br>} <br> <br> <br>// When we are told to flush we should release the source thread <br> <br>HRESULT CBaseRenderer::BeginFlush() <br>{ <br>    // If paused then report state intermediate until we get some data <br> <br>    if (m_State == State_Paused) { <br>NotReady(); <br>    } <br> <br>    SourceThreadCanWait(FALSE); <br>    CancelNotification(); <br>    ClearPendingSample(); <br>    //  Wait for Receive to complete <br>    WaitForReceiveToComplete(); <br>    return NOERROR; <br>} <br> <br> <br>// After flushing the source thread can wait in Receive again <br> <br>HRESULT CBaseRenderer::EndFlush() <br>{ <br>    // Reset the current sample media time <br>    if (m_pPosition) m_pPosition-&gt;ResetMediaTime(); <br> <br>    // There should be no outstanding advise <br> <br>    ASSERT(CancelNotification() == S_FALSE); <br>    SourceThreadCanWait(TRUE); <br>    return NOERROR; <br>} <br> <br> <br>// We can now send EC_REPAINTs if so required <br> <br>HRESULT CBaseRenderer::CompleteConnect(IPin *pReceivePin) <br>{ <br>    SetRepaintStatus(TRUE); <br>    m_bAbort = FALSE; <br>    return NOERROR; <br>} <br> <br> <br>// Called when we go paused or running <br> <br>HRESULT CBaseRenderer::Active() <br>{ <br>    return NOERROR; <br>} <br> <br> <br>// Called when we go into a stopped state <br> <br>HRESULT CBaseRenderer::Inactive() <br>{ <br>    if (m_pPosition) { <br>m_pPosition-&gt;ResetMediaTime(); <br>    } <br>    //  People who derive from this may want to override this behaviour <br>    //  to keep hold of the sample in some circumstances <br>    ClearPendingSample(); <br>    return NOERROR; <br>} <br> <br> <br>// Tell derived classes about the media type agreed <br> <br>HRESULT CBaseRenderer::SetMediaType(const CMediaType *pmt) <br>{ <br>    return NOERROR; <br>} <br> <br> <br>// When we break the input pin connection we should reset the EOS flags. When <br>// we are asked for either IMediaPosition or IMediaSeeking we will create a <br>// CPosPassThru object to handles media time pass through. When we're handed <br>// samples we store (by calling CPosPassThru::RegisterMediaTime) their media <br>// times so we can then return a real current position of data being rendered <br> <br>HRESULT CBaseRenderer::BreakConnect() <br>{ <br>    // Do we have a quality management sink <br> <br>    if (m_pQSink) { <br>m_pQSink-&gt;Release(); <br>m_pQSink = NULL; <br>    } <br> <br>    // Check we have a valid connection <br> <br>    if (m_pInputPin-&gt;IsConnected() == FALSE) { <br>return S_FALSE; <br>    } <br> <br>    // Check we are stopped before disconnecting <br> <br>    if (m_State != State_Stopped) { <br>return VFW_E_NOT_STOPPED; <br>    } <br> <br>    SetRepaintStatus(FALSE); <br>    ResetEndOfStream(); <br>    ClearPendingSample(); <br>    m_bAbort = FALSE; <br>    return NOERROR; <br>} <br> <br> <br>// Retrieves the sample times for this samples (note the sample times are <br>// passed in by reference not value). We return S_FALSE to say schedule this <br>// sample according to the times on the sample. We also return S_OK in <br>// which case the object should simply render the sample data immediately <br> <br>HRESULT CBaseRenderer::GetSampleTimes(IMediaSample *pMediaSample, <br>      REFERENCE_TIME *pStartTime, <br>      REFERENCE_TIME *pEndTime) <br>{ <br>    ASSERT(m_dwAdvise == 0); <br>    ASSERT(pMediaSample); <br> <br>    // If the stop time for this sample is before or the same as start time, <br>    // then just ignore it (release it) and schedule the next one in line <br>    // Source filters should always fill in the start and end times properly! <br> <br>    if (SUCCEEDED(pMediaSample-&gt;GetTime(pStartTime, pEndTime))) { <br>if (*pEndTime &lt; *pStartTime) { <br>    return VFW_E_START_TIME_AFTER_END; <br>} <br>    } else { <br>// no time set in the sample... draw it now? <br>return S_OK; <br>    } <br> <br>    // Can't synchronise without a clock so we return S_OK which tells the <br>    // caller that the sample should be rendered immediately without going <br>    // through the overhead of setting a timer advise link with the clock <br> <br>    if (m_pClock == NULL) { <br>return S_OK; <br>    } <br>    return ShouldDrawSampleNow(pMediaSample,pStartTime,pEndTime); <br>} <br> <br> <br>// By default all samples are drawn according to their time stamps so we <br>// return S_FALSE. Returning S_OK means draw immediately, this is used <br>// by the derived video renderer class in its quality management. <br> <br>HRESULT CBaseRenderer::ShouldDrawSampleNow(IMediaSample *pMediaSample, <br>   REFERENCE_TIME *ptrStart, <br>   REFERENCE_TIME *ptrEnd) <br>{ <br>    return S_FALSE; <br>} <br> <br> <br>// We must always reset the current advise time to zero after a timer fires <br>// because there are several possible ways which lead us not to do any more <br>// scheduling such as the pending image being cleared after state changes <br> <br>void CBaseRenderer::SignalTimerFired() <br>{ <br>    m_dwAdvise = 0; <br>} <br> <br> <br>// Cancel any notification currently scheduled. This is called by the owning <br>// window object when it is told to stop streaming. If there is no timer link <br>// outstanding then calling this is benign otherwise we go ahead and cancel <br>// We must always reset the render event as the quality management code can <br>// signal immediate rendering by setting the event without setting an advise <br>// link. If we're subsequently stopped and run the first attempt to setup an <br>// advise link with the reference clock will find the event still signalled <br> <br>HRESULT CBaseRenderer::CancelNotification() <br>{ <br>    ASSERT(m_dwAdvise == 0 || m_pClock); <br>    DWORD dwAdvise = m_dwAdvise; <br> <br>    // Have we a live advise link <br> <br>    if (m_dwAdvise) { <br>m_pClock-&gt;Unadvise(m_dwAdvise); <br>SignalTimerFired(); <br>ASSERT(m_dwAdvise == 0); <br>    } <br> <br>    // Clear the event and return our status <br> <br>    m_RenderEvent.Reset(); <br>    return (dwAdvise ? S_OK : S_FALSE); <br>} <br> <br> <br>// Responsible for setting up one shot advise links with the clock <br>// Return FALSE if the sample is to be dropped (not drawn at all) <br>// Return TRUE if the sample is to be drawn and in this case also <br>// arrange for m_RenderEvent to be set at the appropriate time <br> <br>BOOL CBaseRenderer::ScheduleSample(IMediaSample *pMediaSample) <br>{ <br>    REFERENCE_TIME StartSample, EndSample; <br> <br>    // Is someone pulling our leg <br> <br>    if (pMediaSample == NULL) { <br>return FALSE; <br>    } <br> <br>    // Get the next sample due up for rendering.  If there aren't any ready <br>    // then GetNextSampleTimes returns an error.  If there is one to be done <br>    // then it succeeds and yields the sample times. If it is due now then <br>    // it returns S_OK other if it's to be done when due it returns S_FALSE <br> <br>    HRESULT hr = GetSampleTimes(pMediaSample, &amp;StartSample, &amp;EndSample); <br>    if (FAILED(hr)) { <br>return FALSE; <br>    } <br> <br>    // If we don't have a reference clock then we cannot set up the advise <br>    // time so we simply set the event indicating an image to render. This <br>    // will cause us to run flat out without any timing or synchronisation <br> <br>    if (hr == S_OK) { <br>EXECUTE_ASSERT(SetEvent((HANDLE) m_RenderEvent)); <br>return TRUE; <br>    } <br> <br>    ASSERT(m_dwAdvise == 0); <br>    ASSERT(m_pClock); <br>    ASSERT(WAIT_TIMEOUT == WaitForSingleObject((HANDLE)m_RenderEvent,0)); <br> <br>    // We do have a valid reference clock interface so we can ask it to <br>    // set an event when the image comes due for rendering. We pass in <br>    // the reference time we were told to start at and also the current <br>    // stream time which is the offset from the start reference time <br> <br>    hr = m_pClock-&gt;AdviseTime( <br>    (REFERENCE_TIME) m_tStart,          // Start run time <br>    StartSample,                        // Stream time <br>    (HEVENT)(HANDLE) m_RenderEvent,     // Render notification <br>    &amp;m_dwAdvise);                       // Advise cookie <br> <br>    if (SUCCEEDED(hr)) { <br>return TRUE; <br>    } <br> <br>    // We could not schedule the next sample for rendering despite the fact <br>    // we have a valid sample here. This is a fair indication that either <br>    // the system clock is wrong or the time stamp for the sample is duff </code></pre>
<p>
</p>
<pre><code><br>    ASSERT(m_dwAdvise == 0); <br>    return FALSE; <br>} <br> <br> <br>// This is called when a sample comes due for rendering. We pass the sample <br>// on to the derived class. After rendering we will initialise the timer for <br>// the next sample, NOTE signal that the last one fired first, if we don't <br>// do this it thinks there is still one outstanding that hasn't completed <br> <br>HRESULT CBaseRenderer::Render(IMediaSample *pMediaSample) <br>{ <br>    // If the media sample is NULL then we will have been notified by the <br>    // clock that another sample is ready but in the mean time someone has <br>    // stopped us streaming which causes the next sample to be released <br> <br>    if (pMediaSample == NULL) { <br>return S_FALSE; <br>    } <br> <br>    // If we have stopped streaming then don't render any more samples, the <br>    // thread that got in and locked us and then reset this flag does not <br>    // clear the pending sample as we can use it to refresh any output device <br> <br>    if (m_bStreaming == FALSE) { <br>return S_FALSE; <br>    } <br> <br>    // Time how long the rendering takes <br> <br>    OnRenderStart(pMediaSample); <br>    DoRenderSample(pMediaSample); <br>    OnRenderEnd(pMediaSample); <br> <br>    return NOERROR; <br>} <br> <br> <br>// Checks if there is a sample waiting at the renderer <br> <br>BOOL CBaseRenderer::HaveCurrentSample() <br>{ <br>    CAutoLock cRendererLock(&amp;m_RendererLock); <br>    return (m_pMediaSample == NULL ? FALSE : TRUE); <br>} <br> <br> <br>// Returns the current sample waiting at the video renderer. We AddRef the <br>// sample before returning so that should it come due for rendering the <br>// person who called this method will hold the remaining reference count <br>// that will stop the sample being added back onto the allocator free list <br> <br>IMediaSample *CBaseRenderer::GetCurrentSample() <br>{ <br>    CAutoLock cRendererLock(&amp;m_RendererLock); <br>    if (m_pMediaSample) { <br>m_pMediaSample-&gt;AddRef(); <br>    } <br>    return m_pMediaSample; <br>} <br> <br> <br>// Called when the source delivers us a sample. We go through a few checks to <br>// make sure the sample can be rendered. If we are running (streaming) then we <br>// have the sample scheduled with the reference clock, if we are not streaming <br>// then we have received an sample in paused mode so we can complete any state <br>// transition. On leaving this function everything will be unlocked so an app <br>// thread may get in and change our state to stopped (for example) in which <br>// case it will also signal the thread event so that our wait call is stopped <br> <br>HRESULT CBaseRenderer::PrepareReceive(IMediaSample *pMediaSample) <br>{ <br>    CAutoLock cRendererLock(&amp;m_InterfaceLock); <br>    m_bInReceive = TRUE; <br> <br>    // Check our flushing and filter state <br> <br>    HRESULT hr = m_pInputPin-&gt;CBaseInputPin::Receive(pMediaSample); <br> <br>    if (hr != NOERROR) { <br>m_bInReceive = FALSE; <br>return E_FAIL; <br>    } <br> <br>    // Has the type changed on a media sample. We do all rendering <br>    // synchronously on the source thread, which has a side effect <br>    // that only one buffer is ever outstanding. Therefore when we <br>    // have Receive called we can go ahead and change the format <br>    // Since the format change can cause a SendMessage we just don't <br>    // lock <br>    if (m_pInputPin-&gt;SampleProps()-&gt;pMediaType) { <br>m_pInputPin-&gt;SetMediaType( <br>    (CMediaType *)m_pInputPin-&gt;SampleProps()-&gt;pMediaType); <br>    } <br> <br> <br>    CAutoLock cSampleLock(&amp;m_RendererLock); <br> <br>    ASSERT(IsActive() == TRUE); <br>    ASSERT(m_pInputPin-&gt;IsFlushing() == FALSE); <br>    ASSERT(m_pInputPin-&gt;IsConnected() == TRUE); <br>    ASSERT(m_pMediaSample == NULL); <br> <br>    // Return an error if we already have a sample waiting for rendering <br>    // source pins must serialise the Receive calls - we also check that <br>    // no data is being sent after the source signalled an end of stream <br> <br>    if (m_pMediaSample || m_bEOS || m_bAbort) { <br>Ready(); <br>m_bInReceive = FALSE; <br>return E_UNEXPECTED; <br>    } <br> <br>    // Store the media times from this sample <br>    if (m_pPosition) m_pPosition-&gt;RegisterMediaTime(pMediaSample); <br> <br>    // Schedule the next sample if we are streaming <br> <br>    if ((m_bStreaming == TRUE) &amp;&amp; (ScheduleSample(pMediaSample) == FALSE)) { <br>ASSERT(WAIT_TIMEOUT == WaitForSingleObject((HANDLE)m_RenderEvent,0)); <br>ASSERT(CancelNotification() == S_FALSE); <br>m_bInReceive = FALSE; <br>return VFW_E_SAMPLE_REJECTED; <br>    } <br> <br>    // Store the sample end time for EC_COMPLETE handling <br>    m_SignalTime = m_pInputPin-&gt;SampleProps()-&gt;tStop; <br> <br>    // BEWARE we sometimes keep the sample even after returning the thread to <br>    // the source filter such as when we go into a stopped state (we keep it <br>    // to refresh the device with) so we must AddRef it to keep it safely. If <br>    // we start flushing the source thread is released and any sample waiting <br>    // will be released otherwise GetBuffer may never return (see BeginFlush) <br> <br>    m_pMediaSample = pMediaSample; <br>    m_pMediaSample-&gt;AddRef(); <br> <br>    if (m_bStreaming == FALSE) { <br>SetRepaintStatus(TRUE); <br>    } <br>    return NOERROR; <br>} <br> <br> <br>// Called by the source filter when we have a sample to render. Under normal <br>// circumstances we set an advise link with the clock, wait for the time to <br>// arrive and then render the data using the PURE virtual DoRenderSample that <br>// the derived class will have overriden. After rendering the sample we may <br>// also signal EOS if it was the last one sent before EndOfStream was called <br> <br>HRESULT CBaseRenderer::Receive(IMediaSample *pSample) <br>{ <br>    ASSERT(pSample); <br> <br>    // It may return VFW_E_SAMPLE_REJECTED code to say don't bother <br> <br>    HRESULT hr = PrepareReceive(pSample); <br>    ASSERT(m_bInReceive == SUCCEEDED(hr)); <br>    if (FAILED(hr)) { <br>if (hr == VFW_E_SAMPLE_REJECTED) { <br>    return NOERROR; <br>} <br>return hr; <br>    } <br> <br>    // We realize the palette in "PrepareRender()" so we have to give away the <br>    // filter lock here. <br>    if (m_State == State_Paused) { <br>PrepareRender(); <br>// no need to use InterlockedExchange <br>m_bInReceive = FALSE; <br>{ <br>    // We must hold both these locks <br>    CAutoLock cRendererLock(&amp;m_InterfaceLock); <br>    if (m_State == State_Stopped) <br>return NOERROR; <br>    m_bInReceive = TRUE; <br>    CAutoLock cSampleLock(&amp;m_RendererLock); <br>    OnReceiveFirstSample(pSample); <br>} <br>Ready(); <br>    } <br>    // Having set an advise link with the clock we sit and wait. We may be <br>    // awoken by the clock firing or by a state change. The rendering call <br>    // will lock the critical section and check we can still render the data <br> <br>    hr = WaitForRenderTime(); <br>    if (FAILED(hr)) { <br>m_bInReceive = FALSE; <br>return NOERROR; <br>    } <br> <br>    PrepareRender(); <br> <br>    //  Set this here and poll it until we work out the locking correctly <br>    //  It can't be right that the streaming stuff grabs the interface <br>    //  lock - after all we want to be able to wait for this stuff <br>    //  to complete <br>    m_bInReceive = FALSE; <br> <br>    // We must hold both these locks <br>    CAutoLock cRendererLock(&amp;m_InterfaceLock); <br> <br>    // since we gave away the filter wide lock, the sate of the filter could <br>    // have chnaged to Stopped <br>    if (m_State == State_Stopped) <br>return NOERROR; <br> <br>    CAutoLock cSampleLock(&amp;m_RendererLock); <br> <br>    // Deal with this sample <br> <br>    Render(m_pMediaSample); <br>    ClearPendingSample(); <br>    SendEndOfStream(); <br>    CancelNotification(); <br>    return NOERROR; <br>} <br> <br> <br>// This is called when we stop or are inactivated to clear the pending sample <br>// We release the media sample interface so that they can be allocated to the <br>// source filter again, unless of course we are changing state to inactive in <br>// which case GetBuffer will return an error. We must also reset the current <br>// media sample to NULL so that we know we do not currently have an image <br> <br>HRESULT CBaseRenderer::ClearPendingSample() <br>{ <br>    CAutoLock cRendererLock(&amp;m_RendererLock); <br>    if (m_pMediaSample) { <br>m_pMediaSample-&gt;Release(); <br>m_pMediaSample = NULL; <br>    } <br>    return NOERROR; <br>} <br> <br> <br>// Used to signal end of stream according to the sample end time <br> <br>void CALLBACK EndOfStreamTimer(UINT uID,        // Timer identifier <br>       UINT uMsg,       // Not currently used <br>       DWORD dwUser,    // User information <br>       DWORD dw1,       // Windows reserved <br>       DWORD dw2)       // is also reserved <br>{ <br>    CBaseRenderer *pRenderer = (CBaseRenderer *) dwUser; <br>    NOTE1("EndOfStreamTimer called (%d)",uID); <br>    pRenderer-&gt;TimerCallback(); <br>} <br> <br>//  Do the timer callback work <br>void CBaseRenderer::TimerCallback() <br>{ <br>    //  Lock for synchronization (but don't hold this lock when calling <br>    //  timeKillEvent) <br>    CAutoLock cRendererLock(&amp;m_RendererLock); <br> <br>    // See if we should signal end of stream now <br> <br>    if (m_EndOfStreamTimer) { <br>m_EndOfStreamTimer = 0; <br>SendEndOfStream(); <br>    } <br>} <br> <br> <br>// If we are at the end of the stream signal the filter graph but do not set <br>// the state flag back to FALSE. Once we drop off the end of the stream we <br>// leave the flag set (until a subsequent ResetEndOfStream). Each sample we <br>// get delivered will update m_SignalTime to be the last sample's end time. <br>// We must wait this long before signalling end of stream to the filtergraph <br> <br>#define TIMEOUT_DELIVERYWAIT 50 <br>#define TIMEOUT_RESOLUTION 10 <br> <br>HRESULT CBaseRenderer::SendEndOfStream() <br>{ <br>    ASSERT(CritCheckIn(&amp;m_RendererLock)); <br>    if (m_bEOS == FALSE || m_bEOSDelivered || m_EndOfStreamTimer) { <br>return NOERROR; <br>    } <br> <br>    // If there is no clock then signal immediately <br>    if (m_pClock == NULL) { <br>return NotifyEndOfStream(); <br>    } <br> <br>    // How long into the future is the delivery time <br> <br>    REFERENCE_TIME Signal = m_tStart + m_SignalTime; <br>    REFERENCE_TIME CurrentTime; <br>    m_pClock-&gt;GetTime(&amp;CurrentTime); <br>    LONG Delay = LONG((Signal - CurrentTime) / 10000); <br> <br>    // Dump the timing information to the debugger <br> <br>    NOTE1("Delay until end of stream delivery %d",Delay); <br>    NOTE1("Current %s",(LPCTSTR)CDisp((LONGLONG)CurrentTime)); <br>    NOTE1("Signal %s",(LPCTSTR)CDisp((LONGLONG)Signal)); <br> <br>    // Wait for the delivery time to arrive <br> <br>    if (Delay &lt; TIMEOUT_DELIVERYWAIT) { <br>return NotifyEndOfStream(); <br>    } <br> <br>    // Signal a timer callback on another worker thread <br> <br>    m_EndOfStreamTimer = timeSetEvent((UINT) Delay,       // Period of timer <br>      TIMEOUT_RESOLUTION, // Timer resolution <br>      EndOfStreamTimer,   // Callback function <br>      DWORD(this),        // Used information <br>      TIME_ONESHOT);      // Type of callback <br>    if (m_EndOfStreamTimer == 0) { <br>return NotifyEndOfStream(); <br>    } <br>    return NOERROR; <br>} <br> <br> <br>// Signals EC_COMPLETE to the filtergraph manager <br> <br>HRESULT CBaseRenderer::NotifyEndOfStream() <br>{ <br>    CAutoLock cRendererLock(&amp;m_RendererLock); <br>    ASSERT(m_bEOS == TRUE); <br>    ASSERT(m_bEOSDelivered == FALSE); <br>    ASSERT(m_EndOfStreamTimer == 0); <br> <br>    // Has the filter changed state <br> <br>    if (m_bStreaming == FALSE) { <br>ASSERT(m_EndOfStreamTimer == 0); <br>return NOERROR; <br>    } <br> <br>    // Reset the end of stream timer <br>    m_EndOfStreamTimer = 0; <br> <br>    // If we've been using the IMediaPosition interface, set it's start <br>    // and end media "times" to the stop position by hand.  This ensures <br>    // that we actually get to the end, even if the MPEG guestimate has <br>    // been bad or if the quality management dropped the last few frames <br> <br>    if (m_pPosition) m_pPosition-&gt;EOS(); <br>    m_bEOSDelivered = TRUE; <br>    NOTE("Sending EC_COMPLETE..."); <br>    return NotifyEvent(EC_COMPLETE,S_OK,0); <br>} <br> <br> <br>// Reset the end of stream flag, this is typically called when we transfer to <br>// stopped states since that resets the current position back to the start so <br>// we will receive more samples or another EndOfStream if there aren't any. We <br>// keep two separate flags one to say we have run off the end of the stream <br>// (this is the m_bEOS flag) and another to say we have delivered EC_COMPLETE <br>// to the filter graph. We need the latter otherwise we can end up sending an <br>// EC_COMPLETE every time the source changes state and calls our EndOfStream <br> <br>HRESULT CBaseRenderer::ResetEndOfStream() <br>{ <br>    ResetEndOfStreamTimer(); <br>    CAutoLock cRendererLock(&amp;m_RendererLock); <br> <br>    m_bEOS = FALSE; <br>    m_bEOSDelivered = FALSE; <br>    m_SignalTime = 0; <br> <br>    return NOERROR; <br>} <br> <br> <br>// Kills any outstanding end of stream timer <br> <br>void CBaseRenderer::ResetEndOfStreamTimer() <br>{ <br>    ASSERT(CritCheckOut(&amp;m_RendererLock)); <br>    if (m_EndOfStreamTimer) { <br>timeKillEvent(m_EndOfStreamTimer); <br>m_EndOfStreamTimer = 0; <br>    } <br>} <br> <br> <br>// This is called when we start running so that we can schedule any pending <br>// image we have with the clock and display any timing information. If we <br>// don't have any sample but we have queued an EOS flag then we send it. If <br>// we do have a sample then we wait until that has been rendered before we <br>// signal the filter graph otherwise we may change state before it's done <br> <br>HRESULT CBaseRenderer::StartStreaming() <br>{ <br>    CAutoLock cRendererLock(&amp;m_RendererLock); <br>    if (m_bStreaming == TRUE) { <br>return NOERROR; <br>    } <br> <br>    // Reset the streaming times ready for running <br> <br>    m_bStreaming = TRUE; <br>    timeBeginPeriod(1); <br>    OnStartStreaming(); <br> <br>    // There should be no outstanding advise <br>    ASSERT(WAIT_TIMEOUT == WaitForSingleObject((HANDLE)m_RenderEvent,0)); <br>    ASSERT(CancelNotification() == S_FALSE); <br> <br>    // If we have an EOS and no data then deliver it now <br> <br>    if (m_pMediaSample == NULL) { <br>return SendEndOfStream(); <br>    } <br> <br>    // Have the data rendered <br> <br>    ASSERT(m_pMediaSample); <br>    m_RenderEvent.Set(); <br>    return NOERROR; <br>} <br> <br> <br>// This is called when we stop streaming so that we can set our internal flag <br>// indicating we are not now to schedule any more samples arriving. The state <br>// change methods in the filter implementation take care of cancelling any <br>// clock advise link we have set up and clearing any pending sample we have <br> <br>HRESULT CBaseRenderer::StopStreaming() <br>{ <br>    CAutoLock cRendererLock(&amp;m_RendererLock); <br>    m_bEOSDelivered = FALSE; <br> <br>    if (m_bStreaming == TRUE) { <br>m_bStreaming = FALSE; <br>OnStopStreaming(); <br>timeEndPeriod(1); <br>    } <br>    return NOERROR; <br>} <br> <br> <br>// We have a boolean flag that is reset when we have signalled EC_REPAINT to <br>// the filter graph. We set this when we receive an image so that should any <br>// conditions arise again we can send another one. By having a flag we ensure <br>// we don't flood the filter graph with redundant calls. We do not set the <br>// event when we receive an EndOfStream call since there is no point in us <br>// sending further EC_REPAINTs. In particular the AutoShowWindow method and <br>// the DirectDraw object use this method to control the window repainting <br> <br>void CBaseRenderer::SetRepaintStatus(BOOL bRepaint) <br>{ <br>    CAutoLock cSampleLock(&amp;m_RendererLock); <br>    m_bRepaintStatus = bRepaint; <br>} <br> <br> <br>// Pass the window handle to the upstream filter <br> <br>void CBaseRenderer::SendNotifyWindow(IPin *pPin,HWND hwnd) <br>{ <br>    IMediaEventSink *pSink; <br> <br>    // Does the pin support IMediaEventSink <br>    HRESULT hr = pPin-&gt;QueryInterface(IID_IMediaEventSink,(void **)&amp;pSink); <br>    if (SUCCEEDED(hr)) { <br>pSink-&gt;Notify(EC_NOTIFY_WINDOW,LONG(hwnd),0); <br>pSink-&gt;Release(); <br>    } <br>    NotifyEvent(EC_NOTIFY_WINDOW,LONG(hwnd),0); <br>} <br> <br> <br>// Signal an EC_REPAINT to the filter graph. This can be used to have data <br>// sent to us. For example when a video window is first displayed it may <br>// not have an image to display, at which point it signals EC_REPAINT. The <br>// filtergraph will either pause the graph if stopped or if already paused <br>// it will call put_CurrentPosition of the current position. Setting the <br>// current position to itself has the stream flushed and the image resent <br> <br>#define RLOG(_x_) DbgLog((LOG_TRACE,1,TEXT(_x_))); <br> <br>void CBaseRenderer::SendRepaint() <br>{ <br>    CAutoLock cSampleLock(&amp;m_RendererLock); <br>    ASSERT(m_pInputPin); <br> <br>    // We should not send repaint notifications when... <br>    //    - An end of stream has been notified <br>    //    - Our input pin is being flushed <br>    //    - The input pin is not connected <br>    //    - We have aborted a video playback <br>    //    - There is a repaint already sent <br> <br>    if (m_bAbort == FALSE) { <br>if (m_pInputPin-&gt;IsConnected() == TRUE) { <br>    if (m_pInputPin-&gt;IsFlushing() == FALSE) { <br>if (IsEndOfStream() == FALSE) { <br>    if (m_bRepaintStatus == TRUE) { <br>IPin *pPin = (IPin *) m_pInputPin; <br>NotifyEvent(EC_REPAINT,(long) pPin,0); <br>SetRepaintStatus(FALSE); <br>RLOG("Sending repaint"); <br>    } <br>} <br>    } <br>} <br>    } <br>} <br> <br> <br>// When a video window detects a display change (WM_DISPLAYCHANGE message) it <br>// can send an EC_DISPLAY_CHANGED event code along with the renderer pin. The <br>// filtergraph will stop everyone and reconnect our input pin. As we're then <br>// reconnected we can accept the media type that matches the new display mode <br>// since we may no longer be able to draw the current image type efficiently <br> <br>BOOL CBaseRenderer::OnDisplayChange() <br>{ <br>    // Ignore if we are not connected yet <br> <br>    CAutoLock cSampleLock(&amp;m_RendererLock); <br>    if (m_pInputPin-&gt;IsConnected() == FALSE) { <br>return FALSE; <br>    } <br> <br>    RLOG("Notification of EC_DISPLAY_CHANGE"); <br> <br>    // Pass our input pin as parameter on the event <br> <br>    IPin *pPin = (IPin *) m_pInputPin; <br>    m_pInputPin-&gt;AddRef(); <br>    NotifyEvent(EC_DISPLAY_CHANGED,(long) pPin,0); <br>    SetAbortSignal(TRUE); <br>    ClearPendingSample(); <br>    m_pInputPin-&gt;Release(); <br> <br>    return TRUE; <br>} <br> <br> <br>// Called just before we start drawing. <br>// Store the current time in m_trRenderStart to allow the rendering time to be <br>// logged.  Log the time stamp of the sample and how late it is (neg is early) <br> <br>void CBaseRenderer::OnRenderStart(IMediaSample *pMediaSample) <br>{ <br>#ifdef PERF <br>    REFERENCE_TIME trStart, trEnd; <br>    pMediaSample-&gt;GetTime(&amp;trStart, &amp;trEnd); <br> <br>    MSR_INTEGER(m_idBaseStamp, (int)trStart);     // dump low order 32 bits <br> <br>    m_pClock-&gt;GetTime(&amp;m_trRenderStart); <br>    MSR_INTEGER(0, (int)m_trRenderStart); <br>    REFERENCE_TIME trStream; <br>    trStream = m_trRenderStart-m_tStart;     // convert reftime to stream time <br>    MSR_INTEGER(0,(int)trStream); <br> <br>    const int trLate = (int)(trStream - trStart); <br>    MSR_INTEGER(m_idBaseAccuracy, trLate/10000);  // dump in mSec <br>#endif <br> <br>} // OnRenderStart <br> <br> <br>// Called directly after drawing an image. <br>// calculate the time spent drawing and log it. <br> <br>void CBaseRenderer::OnRenderEnd(IMediaSample *pMediaSample) <br>{ <br>#ifdef PERF <br>    REFERENCE_TIME trNow; <br>    m_pClock-&gt;GetTime(&amp;trNow); <br>    MSR_INTEGER(0,(int)trNow); <br>    int t = (int)((trNow - m_trRenderStart)/10000);   // convert UNITS-&gt;msec <br>    MSR_INTEGER(m_idBaseRenderTime, t); <br>#endif <br>} // OnRenderEnd <br> <br> <br> <br> <br>// Constructor must be passed the base renderer object <br> <br>CRendererInputPin::CRendererInputPin(CBaseRenderer *pRenderer, <br>     HRESULT *phr, <br>     LPCWSTR pPinName) : <br>    CBaseInputPin(NAME("Renderer pin"), <br>  pRenderer, <br>  &amp;pRenderer-&gt;m_InterfaceLock, <br>  (HRESULT *) phr, <br>  pPinName) <br>{ <br>    m_pRenderer = pRenderer; <br>    ASSERT(m_pRenderer); <br>} <br> <br> <br>// Signals end of data stream on the input pin <br> <br>STDMETHODIMP CRendererInputPin::EndOfStream() <br>{ <br>    CAutoLock cRendererLock(&amp;m_pRenderer-&gt;m_InterfaceLock); <br>    CAutoLock cSampleLock(&amp;m_pRenderer-&gt;m_RendererLock); <br> <br>    // Make sure we're streaming ok <br> <br>    HRESULT hr = CheckStreaming(); <br>    if (hr != NOERROR) { <br>return hr; <br>    } <br> <br>    // Pass it onto the renderer <br> <br>    hr = m_pRenderer-&gt;EndOfStream(); <br>    if (SUCCEEDED(hr)) { <br>hr = CBaseInputPin::EndOfStream(); <br>    } <br>    return hr; <br>} <br> <br> <br>// Signals start of flushing on the input pin - we do the final reset end of <br>// stream with the renderer lock unlocked but with the interface lock locked <br>// We must do this because we call timeKillEvent, our timer callback method <br>// has to take the renderer lock to serialise our state. Therefore holding a <br>// renderer lock when calling timeKillEvent could cause a deadlock condition <br> <br>STDMETHODIMP CRendererInputPin::BeginFlush() <br>{ <br>    CAutoLock cRendererLock(&amp;m_pRenderer-&gt;m_InterfaceLock); <br>    { <br>CAutoLock cSampleLock(&amp;m_pRenderer-&gt;m_RendererLock); <br>CBaseInputPin::BeginFlush(); <br>m_pRenderer-&gt;BeginFlush(); <br>    } <br>    return m_pRenderer-&gt;ResetEndOfStream(); <br>} <br> <br> <br>// Signals end of flushing on the input pin <br> <br>STDMETHODIMP CRendererInputPin::EndFlush() <br>{ <br>    CAutoLock cRendererLock(&amp;m_pRenderer-&gt;m_InterfaceLock); <br>    CAutoLock cSampleLock(&amp;m_pRenderer-&gt;m_RendererLock); <br> <br>    HRESULT hr = m_pRenderer-&gt;EndFlush(); <br>    if (SUCCEEDED(hr)) { <br>hr = CBaseInputPin::EndFlush(); <br>    } <br>    return hr; <br>} <br> <br> <br>// Pass the sample straight through to the renderer object <br> <br>STDMETHODIMP CRendererInputPin::Receive(IMediaSample *pSample) <br>{ <br>    return m_pRenderer-&gt;Receive(pSample); <br>} <br> <br> <br>// Called when the input pin is disconnected <br> <br>HRESULT CRendererInputPin::BreakConnect() <br>{ <br>    HRESULT hr = m_pRenderer-&gt;BreakConnect(); <br>    if (FAILED(hr)) { <br>return hr; <br>    } <br>    return CBaseInputPin::BreakConnect(); <br>} <br> <br> <br>// Called when the input pin is connected <br> <br>HRESULT CRendererInputPin::CompleteConnect(IPin *pReceivePin) <br>{ <br>    HRESULT hr = m_pRenderer-&gt;CompleteConnect(pReceivePin); <br>    if (FAILED(hr)) { <br>return hr; <br>    } <br>    return CBaseInputPin::CompleteConnect(pReceivePin); <br>} <br> <br> <br>// Give the pin id of our one and only pin <br> <br>STDMETHODIMP CRendererInputPin::QueryId(LPWSTR *Id) <br>{ <br>    CheckPointer(Id,E_POINTER); <br> <br>    *Id = (LPWSTR)CoTaskMemAlloc(8); <br>    if (*Id == NULL) { <br>       return E_OUTOFMEMORY; <br>    } <br>    lstrcpyW(*Id, L"In"); <br>    return NOERROR; <br>} <br> <br> <br>// Will the filter accept this media type <br> <br>HRESULT CRendererInputPin::CheckMediaType(const CMediaType *pmt) <br>{ <br>    return m_pRenderer-&gt;CheckMediaType(pmt); <br>} <br> <br> <br>// Called when we go paused or running <br> <br>HRESULT CRendererInputPin::Active() <br>{ <br>    return m_pRenderer-&gt;Active(); <br>} <br> <br> <br>// Called when we go into a stopped state <br> <br>HRESULT CRendererInputPin::Inactive() <br>{ <br>    return m_pRenderer-&gt;Inactive(); <br>} <br> <br> <br>// Tell derived classes about the media type agreed <br> <br>HRESULT CRendererInputPin::SetMediaType(const CMediaType *pmt) <br>{ <br>    HRESULT hr = CBaseInputPin::SetMediaType(pmt); <br>    if (FAILED(hr)) { <br>return hr; <br>    } <br>    return m_pRenderer-&gt;SetMediaType(pmt); <br>} <br> <br> <br>// We do not keep an event object to use when setting up a timer link with <br>// the clock but are given a pointer to one by the owning object through the <br>// SetNotificationObject method - this must be initialised before starting <br>// We can override the default quality management process to have it always <br>// draw late frames, this is currently done by having the following registry <br>// key (actually an INI key) called DrawLateFrames set to 1 (default is 0) <br> <br>const TCHAR AMQUALITY[] = TEXT("ActiveMovie"); <br>const TCHAR DRAWLATEFRAMES[] = TEXT("DrawLateFrames"); <br> <br>CBaseVideoRenderer::CBaseVideoRenderer( <br>      REFCLSID RenderClass, // CLSID for this renderer <br>      TCHAR *pName,         // Debug ONLY description <br>      LPUNKNOWN pUnk,       // Aggregated owner object <br>      HRESULT *phr) :       // General OLE return code <br> <br>    CBaseRenderer(RenderClass,pName,pUnk,phr), <br>    m_cFramesDropped(0), <br>    m_cFramesDrawn(0), <br>    m_bSupplierHandlingQuality(FALSE) <br>{ <br>    ResetStreamingTimes(); <br> <br>#ifdef PERF <br>    m_idTimeStamp       = MSR_REGISTER("Frame time stamp"); <br>    m_idEarliness       = MSR_REGISTER("Earliness fudge"); <br>    m_idTarget          = MSR_REGISTER("Target (mSec)"); <br>    m_idSchLateTime     = MSR_REGISTER("mSec late when scheduled"); <br>    m_idDecision        = MSR_REGISTER("Scheduler decision code"); <br>    m_idQualityRate     = MSR_REGISTER("Quality rate sent"); <br>    m_idQualityTime     = MSR_REGISTER("Quality time sent"); <br>    m_idWaitReal        = MSR_REGISTER("Render wait"); <br>    // m_idWait            = MSR_REGISTER("wait time recorded (msec)"); <br>    m_idFrameAccuracy   = MSR_REGISTER("Frame accuracy (msecs)"); <br>    m_bDrawLateFrames = GetProfileInt(AMQUALITY, DRAWLATEFRAMES, FALSE); <br>    //m_idSendQuality      = MSR_REGISTER("Processing Quality message"); <br> <br>    m_idRenderAvg       = MSR_REGISTER("Render draw time Avg"); <br>    m_idFrameAvg        = MSR_REGISTER("FrameAvg"); <br>    m_idWaitAvg         = MSR_REGISTER("WaitAvg"); <br>    m_idDuration        = MSR_REGISTER("Duration"); <br>    m_idThrottle        = MSR_REGISTER("Audio-video throttle wait"); <br>    // m_idDebug           = MSR_REGISTER("Debug stuff"); <br>#endif // PERF <br>} // Constructor <br> <br> <br>// Destructor is just a placeholder <br> <br>CBaseVideoRenderer::~CBaseVideoRenderer() <br>{ <br>    ASSERT(m_dwAdvise == 0); <br>} <br> <br> <br>// The timing functions in this class are called by the window object and by <br>// the renderer's allocator. <br>// The windows object calls timing functions as it receives media sample <br>// images for drawing using GDI. <br>// The allocator calls timing functions when it starts passing DCI/DirectDraw <br>// surfaces which are not rendered in the same way; The decompressor writes <br>// directly to the surface with no separate rendering, so those code paths <br>// call direct into us.  Since we only ever hand out DCI/DirectDraw surfaces <br>// when we have allocated one and only one image we know there cannot be any <br>// conflict between the two. <br>// <br>// We use timeGetTime to return the timing counts we use (since it's relative <br>// performance we are interested in rather than absolute compared to a clock) <br>// The window object sets the accuracy of the system clock (normally 1ms) by <br>// calling timeBeginPeriod/timeEndPeriod when it changes streaming states <br> <br> <br>// Reset all times controlling streaming. <br>// Set them so that <br>// 1. Frames will not initially be dropped <br>// 2. The first frame will definitely be drawn (achieved by saying that there <br>//    has not ben a frame drawn for a long time). <br> <br>HRESULT CBaseVideoRenderer::ResetStreamingTimes() <br>{ <br>    m_trLastDraw = -1000;     // set up as first frame since ages (1 sec) ago <br>    m_tStreamingStart = timeGetTime(); <br>    m_trRenderAvg = 0; <br>    m_trFrameAvg = -1;        // -1000 fps == "unset" <br>    m_trDuration = 0;         // 0 - silly value <br>    m_trRenderLast = 0; <br>    m_trWaitAvg = 0; <br>    m_tRenderStart = 0; <br>    m_cFramesDrawn = 0; <br>    m_cFramesDropped = 0; <br>    m_iTotAcc = 0; <br>    m_iSumSqAcc = 0; <br>    m_iSumSqFrameTime = 0; <br>    m_trFrame = 0;          // hygeine - not really needed <br>    m_trLate = 0;           // hygeine - not really needed <br>    m_iSumFrameTime = 0; <br>    m_nNormal = 0; <br>    m_trEarliness = 0; <br>    m_trTarget = -300000;  // 30mSec early <br>    m_trThrottle = 0; <br>    m_trRememberStampForPerf = 0; <br> <br>#ifdef PERF <br>    m_trRememberFrameForPerf = 0; <br>#endif <br> <br>    return NOERROR; <br>} // ResetStreamingTimes <br> <br> <br>// Reset all times controlling streaming. Note that we're now streaming. We <br>// don't need to set the rendering event to have the source filter released <br>// as it is done during the Run processing. When we are run we immediately <br>// release the source filter thread and draw any image waiting (that image <br>// may already have been drawn once as a poster frame while we were paused) <br> <br>HRESULT CBaseVideoRenderer::OnStartStreaming() <br>{ <br>    ResetStreamingTimes(); <br>    return NOERROR; <br>} // OnStartStreaming <br> <br> <br>// Called at end of streaming.  Fixes times for property page report <br> <br>HRESULT CBaseVideoRenderer::OnStopStreaming() <br>{ <br>    m_tStreamingStart = timeGetTime()-m_tStreamingStart; <br>    return NOERROR; <br>} // OnStopStreaming <br> <br> <br>// Called when we start waiting for a rendering event. <br>// Used to update times spent waiting and not waiting. <br> <br>void CBaseVideoRenderer::OnWaitStart() <br>{ <br>    MSR_START(m_idWaitReal); <br>} // OnWaitStart <br> <br> <br>// Called when we are awoken from the wait in the window OR by our allocator <br>// when it is hanging around until the next sample is due for rendering on a <br>// DCI/DirectDraw surface. We add the wait time into our rolling average. <br>// We grab the interface lock so that we're serialised with the application <br>// thread going through the run code - which in due course ends up calling <br>// ResetStreaming times - possibly as we run through this section of code <br> <br>void CBaseVideoRenderer::OnWaitEnd() <br>{ <br>#ifdef PERF <br>    MSR_STOP(m_idWaitReal); <br>    // for a perf build we want to know just exactly how late we REALLY are. <br>    // even if this means that we have to look at the clock again. <br> <br>    REFERENCE_TIME trRealStream;     // the real time now expressed as stream time. <br>#if 0 <br>    m_pClock-&gt;GetTime(&amp;trRealStream); // Calling clock here causes W95 deadlock! <br>#else <br>    // We will be discarding overflows like mad here! <br>    // This is wrong really because timeGetTime() can wrap but it's <br>    // only for PERF <br>    REFERENCE_TIME tr = timeGetTime()*10000; <br>    trRealStream = tr + m_llTimeOffset; <br>#endif <br>    trRealStream -= m_tStart;     // convert to stream time (this is a reftime) <br> <br>    if (m_trRememberStampForPerf==0) { <br>// This is probably the poster frame at the start, and it is not scheduled <br>// in the usual way at all.  Just count it.  The rememberstamp gets set <br>// in ShouldDrawSampleNow, so this does bogus frame recording until we <br>// actually start playing. </code></pre>
<p>
</p>
<pre><code>PreparePerformanceData(0, 0); <br>    } else { <br>int trLate = (int)(trRealStream - m_trRememberStampForPerf); <br>int trFrame = (int)(tr - m_trRememberFrameForPerf); <br>PreparePerformanceData(trLate, trFrame); <br>    } <br>    m_trRememberFrameForPerf = tr; <br>#endif //PERF <br>} // OnWaitEnd <br> <br> <br>// Put data on one side that describes the lateness of the current frame. <br>// We don't yet know whether it will actually be drawn.  In direct draw mode, <br>// this decision is up to the filter upstream, and it could change its mind. <br>// The rules say that if it did draw it must call Receive().  One way or <br>// another we eventually get into either OnRenderStart or OnDirectRender and <br>// these both call RecordFrameLateness to update the statistics. <br> <br>void CBaseVideoRenderer::PreparePerformanceData(int trLate, int trFrame) <br>{ <br>    m_trLate = trLate; <br>    m_trFrame = trFrame; <br>} // PreparePerformanceData <br> <br> <br>// update the statistics: <br>// m_iTotAcc, m_iSumSqAcc, m_iSumSqFrameTime, m_iSumFrameTime, m_cFramesDrawn <br>// Note that because the properties page reports using these variables, <br>// 1. We need to be inside a critical section <br>// 2. They must all be updated together.  Updating the sums here and the count <br>// elsewhere can result in imaginary jitter (i.e. attempts to find square roots <br>// of negative numbers) in the property page code. <br> <br>void CBaseVideoRenderer::RecordFrameLateness(int trLate, int trFrame) <br>{ <br>    // Record how timely we are. <br>    int tLate = trLate/10000; <br> <br>    // Best estimate of moment of appearing on the screen is average of <br>    // start and end draw times.  Here we have only the end time.  This may <br>    // tend to show us as spuriously late by up to 1/2 frame rate achieved. <br>    // Decoder probably monitors draw time.  We don't bother. <br>    MSR_INTEGER( m_idFrameAccuracy, tLate ); <br> <br>    // This is a hack - we can get frames that are ridiculously late <br>    // especially (at start-up) and they sod up the statistics. <br>    // So ignore things that are more than 1 sec off. <br>    if (tLate&gt;1000 || tLate&lt;-1000) { <br>if (m_cFramesDrawn&lt;=1) { <br>    tLate = 0; <br>} else if (tLate&gt;0) { <br>    tLate = 1000; <br>} else { <br>    tLate = -1000; <br>} <br>    } <br>    // The very first frame often has a bogus time, so I'm just <br>    // not going to count it into the statistics.   ??? <br>    if (m_cFramesDrawn&gt;1) { <br>m_iTotAcc += tLate; <br>m_iSumSqAcc += (tLate*tLate); <br>    } <br> <br>    // calculate inter-frame time.  Doesn't make sense for first frame <br>    // second frame suffers from bogus first frame stamp. <br>    if (m_cFramesDrawn&gt;2) { <br>int tFrame = trFrame/10000;    // convert to mSec else it overflows <br>// This is a hack.  It can overflow anyway (a pause can cause <br>// a very long inter-frame time) and it overflows at 2**31/10**7 <br>// or about 215 seconds i.e. 3min 35sec <br>if (tFrame&gt;1000||tFrame&lt;0) tFrame = 1000; <br>m_iSumSqFrameTime += tFrame*tFrame; <br>ASSERT(m_iSumSqFrameTime&gt;=0); <br>m_iSumFrameTime += tFrame; <br>    } <br>    ++m_cFramesDrawn; <br> <br>} // RecordFrameLateness <br> <br> <br>void CBaseVideoRenderer::ThrottleWait() <br>{ <br>    if (m_trThrottle&gt;0) { <br>int iThrottle = m_trThrottle/10000;    // convert to mSec <br>MSR_INTEGER( m_idThrottle, iThrottle); <br>        DbgLog((LOG_TRACE, 0, TEXT("Throttle %d ms"), iThrottle)); <br>Sleep(iThrottle); <br>    } else { <br>        Sleep(0); <br>    } <br>} // ThrottleWait <br> <br> <br>// Whenever a frame is rendered it goes though either OnRenderStart <br>// or OnDirectRender.  Data that are generated during ShouldDrawSample <br>// are added to the statistics by calling RecordFrameLateness from both <br>// these two places. <br> <br>// Called in place of OnRenderStart..OnRenderEnd <br>// When a DirectDraw image is drawn <br>void CBaseVideoRenderer::OnDirectRender(IMediaSample *pMediaSample) <br>{ <br>    int time = 0; <br>    m_trRenderAvg = 0; <br>    m_trRenderLast = 5000000;  // If we mode switch, we do NOT want this <br>       // to inhibit the new average getting going! <br>       // so we set it to half a second <br>    // MSR_INTEGER(m_idRenderAvg, m_trRenderAvg/10000); <br>    RecordFrameLateness(m_trLate, m_trFrame); <br>    ThrottleWait(); <br>} // OnDirectRender <br> <br> <br>// Called just before we start drawing.  All we do is to get the current clock <br>// time (from the system) and return.  We have to store the start render time <br>// in a member variable because it isn't used until we complete the drawing <br>// The rest is just performance logging. <br> <br>void CBaseVideoRenderer::OnRenderStart(IMediaSample *pMediaSample) <br>{ <br>    RecordFrameLateness(m_trLate, m_trFrame); <br>    m_tRenderStart = timeGetTime(); <br>} // OnRenderStart <br> <br> <br>// Called directly after drawing an image.  We calculate the time spent in the <br>// drawing code and if this doesn't appear to have any odd looking spikes in <br>// it then we add it to the current average draw time.  Measurement spikes may <br>// occur if the drawing thread is interrupted and switched to somewhere else. <br> <br>void CBaseVideoRenderer::OnRenderEnd(IMediaSample *pMediaSample) <br>{ <br>    // The renderer time can vary erratically if we are interrupted so we do <br>    // some smoothing to help get more sensible figures out but even that is <br>    // not enough as figures can go 9,10,9,9,83,9 and we must disregard 83 <br> <br>    int tr = (timeGetTime() - m_tRenderStart)*10000;   // convert mSec-&gt;UNITS <br>    if (tr &lt; m_trRenderAvg*2 || tr &lt; 2 * m_trRenderLast) { <br>// DO_MOVING_AVG(m_trRenderAvg, tr); <br>m_trRenderAvg = (tr + (AVGPERIOD-1)*m_trRenderAvg)/AVGPERIOD; <br>    } <br>    m_trRenderLast = tr; <br>    ThrottleWait(); <br>} // OnRenderEnd <br> <br> <br>STDMETHODIMP CBaseVideoRenderer::SetSink( IQualityControl * piqc) <br>{ <br> <br>    m_pQSink = piqc; <br> <br>    return NOERROR; <br>} // SetSink <br> <br> <br>STDMETHODIMP CBaseVideoRenderer::Notify( IBaseFilter * pSelf, Quality q) <br>{ <br>    // NOTE:  We are NOT getting any locks here.  We could be called <br>    // asynchronously and possibly even on a time critical thread of <br>    // someone else's - so we do the minumum.  We only set one state <br>    // variable (an integer) and if that happens to be in the middle <br>    // of another thread reading it they will just get either the new <br>    // or the old value.  Locking would achieve no more than this. <br> <br>    // It might be nice to check that we are being called from m_pGraph, but <br>    // it turns out to be a millisecond or so per throw! <br> <br>    // This is heuristics, these numbers are aimed at being "what works" <br>    // rather than anything based on some theory. <br>    // We use a hyperbola because it's easy to calculate and it includes <br>    // a panic button asymptote (which we push off just to the left) <br>    // The throttling fits the following table (roughly) <br>    // Proportion   Throttle (msec) <br>    //     &gt;=1000         0 <br>    //        900         3 <br>    //        800         7 <br>    //        700        11 <br>    //        600        17 <br>    //        500        25 <br>    //        400        35 <br>    //        300        50 <br>    //        200        72 <br>    //        125       100 <br>    //        100       112 <br>    //         50       146 <br>    //          0       200 <br> <br>    // (some evidence that we could go for a sharper kink - e.g. no throttling <br>    // until below the 750 mark - might give fractionally more frames on a <br>    // P60-ish machine).  The easy way to get these coefficients is to use <br>    // Renbase.xls follow the instructions therein using excel solver. <br> <br>    if (q.Proportion&gt;=1000) { m_trThrottle = 0; } <br>    else { <br>// The DWORD is to make quite sure I get unsigned arithmetic <br>// as the constant is between 2**31 and 2**32 <br>m_trThrottle = -330000 + (388880000/(q.Proportion+167)); <br>    } <br>    return NOERROR; <br>} // Notify <br> <br> <br>// Send a message to indicate what our supplier should do about quality. <br>// Theory: <br>// What a supplier wants to know is "is the frame I'm working on NOW <br>// going to be late?". <br>// F1 is the frame at the supplier (as above) <br>// Tf1 is the due time for F1 <br>// T1 is the time at that point (NOW!) <br>// Tr1 is the time that f1 WILL actually be rendered <br>// L1 is the latency of the graph for frame F1 = Tr1-T1 <br>// D1 (for delay) is how late F1 will be beyond its due time i.e. <br>// D1 = (Tr1-Tf1) which is what the supplier really wants to know. <br>// Unfortunately Tr1 is in the future and is unknown, so is L1 <br>// <br>// We could estimate L1 by its value for a previous frame, <br>// L0 = Tr0-T0 and work off <br>// D1' = ((T1+L0)-Tf1) = (T1 + (Tr0-T0) -Tf1) <br>// Rearranging terms: <br>// D1' = (T1-T0) + (Tr0-Tf1) <br>//       adding (Tf0-Tf0) and rearranging again: <br>//     = (T1-T0) + (Tr0-Tf0) + (Tf0-Tf1) <br>//     = (T1-T0) - (Tf1-Tf0) + (Tr0-Tf0) <br>// But (Tr0-Tf0) is just D0 - how late frame zero was, and this is the <br>// Late field in the quality message that we send. <br>// The other two terms just state what correction should be applied before <br>// using the lateness of F0 to predict the lateness of F1. <br>// (T1-T0) says how much time has actually passed (we have lost this much) <br>// (Tf1-Tf0) says how much time should have passed if we were keeping pace <br>// (we have gained this much). <br>// <br>// Suppliers should therefore work off: <br>//    Quality.Late + (T1-T0)  - (Tf1-Tf0) <br>// and see if this is "acceptably late" or even early (i.e. negative). <br>// They get T1 and T0 by polling the clock, they get Tf1 and Tf0 from <br>// the time stamps in the frames.  They get Quality.Late from us. <br>// <br> <br>HRESULT CBaseVideoRenderer::SendQuality(REFERENCE_TIME trLate, <br>REFERENCE_TIME trRealStream) <br>{ <br>    Quality q; <br>    HRESULT hr; <br> <br>    // If we are the main user of time, then report this as Flood/Dry. <br>    // If our suppliers are, then report it as Famine/Glut. <br>    // <br>    // We need to take action, but avoid hunting.  Hunting is caused by <br>    // 1. Taking too much action too soon and overshooting <br>    // 2. Taking too long to react (so averaging can CAUSE hunting). <br>    // <br>    // The reason why we use trLate as well as Wait is to reduce hunting; <br>    // if the wait time is coming down and about to go into the red, we do <br>    // NOT want to rely on some average which is only telling is that it used <br>    // to be OK once. <br> <br>    q.TimeStamp = (REFERENCE_TIME)trRealStream; <br> <br>    if (m_trFrameAvg&lt;0) { <br>q.Type = Famine;      // guess <br>    } <br>    // Is the greater part of the time taken bltting or something else <br>    else if (m_trFrameAvg &gt; 2*m_trRenderAvg) { <br>q.Type = Famine;                        // mainly other <br>    } else { <br>q.Type = Flood;                         // mainly bltting <br>    } <br> <br>    q.Proportion = 1000;               // default <br> <br>    if (m_trFrameAvg&lt;0) { <br>// leave it alone - we don't know enough <br>    } <br>    else if ( trLate&gt; 0 ) { <br>// try to catch up over the next second <br>// We could be Really, REALLY late, but rendering all the frames <br>// anyway, just because it's so cheap. <br> <br>q.Proportion = 1000 - (int)((trLate)/(UNITS/1000)); <br>if (q.Proportion&lt;500) { <br>   q.Proportion = 500;      // don't go daft. (could've been negative!) <br>} else { <br>} <br> <br>    } else if (  m_trWaitAvg&gt;20000 <br>      &amp;&amp; trLate&lt;-20000 <br>      ){ <br>// Go cautiously faster - aim at 2mSec wait. <br>if (m_trWaitAvg&gt;=m_trFrameAvg) { <br>    // This can happen because of some fudges. <br>    // The waitAvg is how long we originally planned to wait <br>    // The frameAvg is more honest. <br>    // It means that we are spending a LOT of time waiting <br>    q.Proportion = 2000;    // double. <br>} else { <br>    if (m_trFrameAvg+20000 &gt; m_trWaitAvg) { <br>q.Proportion <br>    = 1000 * (m_trFrameAvg / (m_trFrameAvg + 20000 - m_trWaitAvg)); <br>    } else { <br>// We're apparently spending more than the whole frame time waiting. <br>// Assume that the averages are slightly out of kilter, but that we <br>// are indeed doing a lot of waiting.  (This leg probably never <br>// happens, but the code avoids any potential divide by zero). <br>q.Proportion = 2000; <br>    } <br>} <br> <br>if (q.Proportion&gt;2000) { <br>    q.Proportion = 2000;    // don't go crazy. <br>} <br>    } <br> <br>    // Tell the supplier how late frames are when they get rendered <br>    // That's how late we are now. <br>    // If we are in directdraw mode then the guy upstream can see the drawing <br>    // times and we'll just report on the start time.  He can figure out any <br>    // offset to apply.  If we are in DIB Section mode then we will apply an <br>    // extra offset which is half of our drawing time.  This is usually small <br>    // but can sometimes be the dominant effect.  For this we will use the <br>    // average drawing time rather than the last frame.  If the last frame took <br>    // a long time to draw and made us late, that's already in the lateness <br>    // figure.  We should not add it in again unless we expect the next frame <br>    // to be the same.  We don't, we expect the average to be a better shot. <br>    // In direct draw mode the RenderAvg will be zero. <br> <br>    q.Late = trLate + m_trRenderAvg/2; <br> <br>    // log what we're doing <br>    MSR_INTEGER(m_idQualityRate, q.Proportion); <br>    MSR_INTEGER( m_idQualityTime, (int)q.Late / 10000 ); <br> <br>    // A specific sink interface may be set through IPin <br> <br>    if (m_pQSink==NULL) { <br>// Get our input pin's peer.  We send quality management messages <br>// to any nominated receiver of these things (set in the IPin <br>// interface), or else to our source filter. <br> <br>IQualityControl *pQC = NULL; <br>IPin *pOutputPin = m_pInputPin-&gt;GetConnected(); <br>ASSERT(pOutputPin != NULL); <br> <br>// And get an AddRef'd quality control interface <br> <br>hr = pOutputPin-&gt;QueryInterface(IID_IQualityControl,(void**) &amp;pQC); <br>if (SUCCEEDED(hr)) { <br>    m_pQSink = pQC; <br>} <br>    } <br>    if (m_pQSink) { <br>return m_pQSink-&gt;Notify(this,q); <br>    } <br> <br>    return S_FALSE; <br> <br>} // SendQuality <br> <br> <br>// We are called with a valid IMediaSample image to decide whether this is to <br>// be drawn or not.  There must be a reference clock in operation. <br>// Return S_OK if it is to be drawn Now (as soon as possible) <br>// Return S_FALSE if it is to be drawn when it's due <br>// Return an error if we want to drop it <br>// m_nNormal=-1 indicates that we dropped the previous frame and so this <br>// one should be drawn early.  Respect it and update it. <br>// Use current stream time plus a number of heuristics (detailed below) <br>// to make the decision <br> <br>HRESULT CBaseVideoRenderer::ShouldDrawSampleNow(IMediaSample *pMediaSample, <br>REFERENCE_TIME *ptrStart, <br>REFERENCE_TIME *ptrEnd) <br>{ <br> <br>    // Don't call us unless there's a clock interface to synchronise with <br>    ASSERT(m_pClock); <br> <br>    MSR_INTEGER(m_idTimeStamp, (int)((*ptrStart)&gt;&gt;32));   // high order 32 bits <br>    MSR_INTEGER(m_idTimeStamp, (int)(*ptrStart));         // low order 32 bits <br> <br>    // We lose a bit of time depending on the monitor type waiting for the next <br>    // screen refresh.  On average this might be about 8mSec - so it will be <br>    // later than we think when the picture appears.  To compensate a bit <br>    // we bias the media samples by -8mSec i.e. 80000 UNITs. <br>    // We don't ever make a stream time negative (call it paranoia) <br>    if (*ptrStart&gt;=80000) { <br>*ptrStart -= 80000; <br>*ptrEnd -= 80000;       // bias stop to to retain valid frame duration <br>    } <br> <br>    // Cache the time stamp now.  We will want to compare what we did with what <br>    // we started with (after making the monitor allowance). <br>    m_trRememberStampForPerf = *ptrStart; <br> <br>    // Get reference times (current and late) <br>    REFERENCE_TIME trRealStream;     // the real time now expressed as stream time. <br>    m_pClock-&gt;GetTime(&amp;trRealStream); <br>#ifdef PERF <br>    // While the reference clock is expensive: <br>    // Remember the offset from timeGetTime and use that. <br>    // This overflows all over the place, but when we subtract to get <br>    // differences the overflows all cancel out. <br>    m_llTimeOffset = trRealStream-timeGetTime()*10000; <br>#endif <br>    trRealStream -= m_tStart;     // convert to stream time (this is a reftime) <br> <br>    // We have to wory about two versions of "lateness".  The truth, which we <br>    // try to work out here and the one measured against m_trTarget which <br>    // includes long term feedback.  We report statistics against the truth <br>    // but for operational decisions we work to the target. <br>    // We use TimeDiff to make sure we get an integer because we <br>    // may actually be late (or more likely early if there is a big time <br>    // gap) by a very long time. <br>    const int trTrueLate = TimeDiff(trRealStream - *ptrStart); <br>    const int trLate = trTrueLate; <br> <br>    MSR_INTEGER(m_idSchLateTime, trTrueLate/10000); <br> <br>    // Send quality control messages upstream, measured against target <br>    HRESULT hr = SendQuality(trLate, trRealStream); <br>    // Note: the filter upstream is allowed to this FAIL meaning "you do it". <br>    m_bSupplierHandlingQuality = (hr==S_OK); <br> <br>    // Decision time!  Do we drop, draw when ready or draw immediately? <br> <br>    const int trDuration = (int)(*ptrEnd - *ptrStart); <br>    { <br>// We need to see if the frame rate of the file has just changed. <br>// This would make comparing our previous frame rate with the current <br>// frame rate silly.  Hang on a moment though.  I've seen files <br>// where the frames vary between 33 and 34 mSec so as to average <br>// 30fps.  A minor variation like that won't hurt us. <br>int t = m_trDuration/32; <br>if (  trDuration &gt; m_trDuration+t <br>   || trDuration &lt; m_trDuration-t <br>   ) { <br>    // There's a major variation.  Reset the average frame rate to <br>    // exactly the current rate to disable decision 9002 for this frame, <br>    // and remember the new rate. <br>    m_trFrameAvg = trDuration; <br>    m_trDuration = trDuration; <br>} <br>    } <br> <br>    MSR_INTEGER(m_idEarliness, m_trEarliness/10000); <br>    MSR_INTEGER(m_idRenderAvg, m_trRenderAvg/10000); <br>    MSR_INTEGER(m_idFrameAvg, m_trFrameAvg/10000); <br>    MSR_INTEGER(m_idWaitAvg, m_trWaitAvg/10000); <br>    MSR_INTEGER(m_idDuration, trDuration/10000); <br> <br>#ifdef PERF <br>    if (S_OK==pMediaSample-&gt;IsDiscontinuity()) { <br>MSR_INTEGER(m_idDecision, 9000); <br>    } <br>#endif <br> <br>    // Control the graceful slide back from slow to fast machine mode. <br>    // After a frame drop accept an early frame and set the earliness to here <br>    // If this frame is already later than the earliness then slide it to here <br>    // otherwise do the standard slide (reduce by about 12% per frame). <br>    // Note: earliness is normally NEGATIVE <br>    BOOL bJustDroppedFrame <br>= (  m_bSupplierHandlingQuality <br>  //  Can't use the pin sample properties because we might <br>  //  not be in Receive when we call this <br>  &amp;&amp; (S_OK == pMediaSample-&gt;IsDiscontinuity())          // he just dropped one <br>  ) <br>       || (m_nNormal==-1);                          // we just dropped one <br> <br> <br>    // Set m_trEarliness (slide back from slow to fast machine mode) <br>    if (trLate&gt;0) { <br>m_trEarliness = 0;   // we are no longer in fast machine mode at all! <br>    } else if (  (trLate&gt;=m_trEarliness) || bJustDroppedFrame) { <br>m_trEarliness = trLate;  // Things have slipped of their own accord <br>    } else { <br>m_trEarliness = m_trEarliness - m_trEarliness/8;  // graceful slide <br>    } <br> <br>    // prepare the new wait average - but don't pollute the old one until <br>    // we have finished with it. <br>    int trWaitAvg; <br>    { <br>// We never mix in a negative wait.  This causes us to believe in fast machines <br>// slightly more. <br>int trL = trLate&lt;0 ? -trLate : 0; <br>trWaitAvg = (trL + m_trWaitAvg*(AVGPERIOD-1))/AVGPERIOD; <br>    } <br> <br> <br>    int trFrame; <br>    { <br>REFERENCE_TIME tr = trRealStream - m_trLastDraw; // Cd be large - 4 min pause! <br>if (tr&gt;10000000) { <br>    tr = 10000000;   // 1 second - arbitrarily. <br>} <br>trFrame = int(tr); <br>    } <br> <br>    // We will DRAW this frame IF... <br>    if ( <br>  // ...the time we are spending drawing is a small fraction of the total <br>  // observed inter-frame time so that dropping it won't help much. <br>  (3*m_trRenderAvg &lt;= m_trFrameAvg) <br> <br> // ...or our supplier is NOT handling things and the next frame would <br> // be less timely than this one or our supplier CLAIMS to be handling <br> // things, and is now less than a full FOUR frames late. <br>       || ( m_bSupplierHandlingQuality <br>  ? (trLate &lt;= trDuration*4) <br>  : (trLate+trLate &lt; trDuration) <br>  ) <br> <br>  // ...or we are on average waiting for over eight milliseconds then <br>  // this may be just a glitch.  Draw it and we'll hope to catch up. <br>       || (m_trWaitAvg &gt; 80000) <br> <br>  // ...or we haven't drawn an image for over a second.  We will update <br>  // the display, which stops the video looking hung. <br>  // Do this regardless of how late this media sample is. <br>       || ((trRealStream - m_trLastDraw) &gt; UNITS) <br> <br>    ) { <br>HRESULT Result; <br> <br>// We are going to play this frame.  We may want to play it early. <br>// We will play it early if we think we are in slow machine mode. <br>// If we think we are NOT in slow machine mode, we will still play <br>// it early by m_trEarliness as this controls the graceful slide back. <br>// and in addition we aim at being m_trTarget late rather than "on time". <br> <br>BOOL bPlayASAP = FALSE; <br> <br>// we will play it AT ONCE (slow machine mode) if... <br> <br>    // ...we are playing catch-up <br>if ( bJustDroppedFrame) { <br>    bPlayASAP = TRUE; <br>    MSR_INTEGER(m_idDecision, 9001); <br>} <br> <br>    // ...or if we are running below the true frame rate <br>    // exact comparisons are glitchy, for these measurements, <br>    // so add an extra 5% or so <br>else if (  (m_trFrameAvg &gt; trDuration + trDuration/16) <br> <br>   // It's possible to get into a state where we are losing ground, but <br>   // are a very long way ahead.  To avoid this or recover from it <br>   // we refuse to play early by more than 10 frames. <br>&amp;&amp; (trLate &gt; - trDuration*10) <br>){ <br>    bPlayASAP = TRUE; <br>    MSR_INTEGER(m_idDecision, 9002); <br>} <br>#if 0 <br>    // ...or if we have been late and are less than one frame early <br>else if (  (trLate + trDuration &gt; 0) <br>&amp;&amp; (m_trWaitAvg&lt;=20000) <br>) { <br>    bPlayASAP = TRUE; <br>    MSR_INTEGER(m_idDecision, 9003); <br>} <br>#endif <br>// We will NOT play it at once if we are grossly early.  On very slow frame <br>// rate movies - e.g. clock.avi - it is not a good idea to leap ahead just <br>// because we got starved (for instance by the net) and dropped one frame <br>// some time or other.  If we are more than 900mSec early, then wait. <br>if (trLate&lt;-9000000) { <br>    bPlayASAP = FALSE; <br>} <br> <br>if (bPlayASAP) { <br> <br>    m_nNormal = 0; <br>    MSR_INTEGER(m_idDecision, 0); <br>    // When we are here, we are in slow-machine mode.  trLate may well <br>    // oscillate between negative and positive when the supplier is <br>    // dropping frames to keep sync.  We should not let that mislead <br>    // us into thinking that we have as much as zero spare time! <br>    // We just update with a zero wait. <br>    m_trWaitAvg = (m_trWaitAvg*(AVGPERIOD-1))/AVGPERIOD; <br> <br>    // Assume that we draw it immediately.  Update inter-frame stats <br>    m_trFrameAvg = (trFrame + m_trFrameAvg*(AVGPERIOD-1))/AVGPERIOD; <br>#ifndef PERF <br>    // if this is NOT a perf build, then report what we know so far <br>    // without looking at the clock any more.  This assumes that we <br>    // actually wait for exactly the time we hope to.  it also reports <br>    // how close we get to the hacked up time stamps that we now have <br>    // rather than the ones we originally started with.  It will <br>    // therefore be a little optimistic.  However it's fast. <br>    PreparePerformanceData(trTrueLate, trFrame); <br>#endif <br>    m_trLastDraw = trRealStream; <br>    if (m_trEarliness &gt; trLate) { <br>m_trEarliness = trLate;  // if we are actually early, this is neg <br>    } <br>    Result = S_OK;                   // Draw it now <br> <br>} else { <br>    ++m_nNormal; <br>    // Set the average frame rate to EXACTLY the ideal rate. <br>    // If we are exiting slow-machine mode then we will have caught up <br>    // and be running ahead, so as we slide back to exact timing we will <br>    // have a longer than usual gap at this point.  If we record this <br>    // real gap then we'll think that we're running slow and go back <br>    // into slow-machine mode and vever get it straight. <br>    m_trFrameAvg = trDuration; <br>    MSR_INTEGER(m_idDecision, 1); <br> <br>    // Play it early by m_trEarliness and by m_trTarget <br> <br>    { <br>int trE = m_trEarliness; <br>                if (trE &lt; -m_trFrameAvg) { <br>                    trE = -m_trFrameAvg; <br>                } <br>*ptrStart += trE;           // N.B. earliness is negative <br>    } <br> <br>    int Delay = -trTrueLate; <br>    Result = Delay&lt;=0 ? S_OK : S_FALSE;     // OK = draw now, FALSE = wait <br> <br>    m_trWaitAvg = trWaitAvg; <br> <br>    // Predict when it will actually be drawn and update frame stats <br> <br>    if (Result==S_FALSE) {   // We are going to wait <br>trFrame = TimeDiff(*ptrStart-m_trLastDraw); <br>m_trLastDraw = *ptrStart; <br>    } else { <br>// trFrame is already = trRealStream-m_trLastDraw; <br>m_trLastDraw = trRealStream; <br>    } <br>#ifndef PERF <br>    int iAccuracy; <br>    if (Delay&gt;0) { <br>// Report lateness based on when we intend to play it <br>iAccuracy = TimeDiff(*ptrStart-m_trRememberStampForPerf); <br>    } else { <br>// Report lateness based on playing it *now*. <br>iAccuracy = trTrueLate;     // trRealStream-RememberStampForPerf; <br>    } <br>    PreparePerformanceData(iAccuracy, trFrame); <br>#endif <br>} <br>return Result; <br>    } <br> <br>    // We are going to drop this frame! <br>    // Of course in DirectDraw mode the guy upstream may draw it anyway. <br> <br>    // This will probably give a large negative wack to the wait avg. <br>    m_trWaitAvg = trWaitAvg; <br> <br>#ifdef PERF <br>    // Respect registry setting - debug only! <br>    if (m_bDrawLateFrames) { <br>       return S_OK;                        // draw it when it's ready <br>    }                                      // even though it's late. <br>#endif <br> <br>    // We are going to drop this frame so draw the next one early <br>    // n.b. if the supplier is doing direct draw then he may draw it anyway <br>    // but he's doing something funny to arrive here in that case. <br> <br>    MSR_INTEGER(m_idDecision, 2); <br>    m_nNormal = -1; <br>    return E_FAIL;                         // drop it <br> <br>} // ShouldDrawSampleNow <br> <br> <br>// NOTE we're called by both the window thread and the source filter thread <br>// so we have to be protected by a critical section (locked before called) <br>// Also, when the window thread gets signalled to render an image, it always <br>// does so regardless of how late it is. All the degradation is done when we <br>// are scheduling the next sample to be drawn. Hence when we start an advise <br>// link to draw a sample, that sample's time will always become the last one <br>// drawn - unless of course we stop streaming in which case we cancel links <br> <br>BOOL CBaseVideoRenderer::ScheduleSample(IMediaSample *pMediaSample) <br>{ <br>    // We override ShouldDrawSampleNow to add quality management <br> <br>    BOOL bDrawImage = CBaseRenderer::ScheduleSample(pMediaSample); <br>    if (bDrawImage == FALSE) { <br>++m_cFramesDropped; <br>return FALSE; <br>    } <br> <br>    // m_cFramesDrawn must NOT be updated here.  It has to be updated <br>    // in RecordFrameLateness at the same time as the other statistics. <br>    return TRUE; <br>} <br> <br> <br>// Implementation of IQualProp interface needed to support the property page <br>// This is how the property page gets the data out of the scheduler. We are <br>// passed into the constructor the owning object in the COM sense, this will <br>// either be the video renderer or an external IUnknown if we're aggregated. <br>// We initialise our CUnknown base class with this interface pointer. Then <br>// all we have to do is to override NonDelegatingQueryInterface to expose <br>// our IQualProp interface. The AddRef and Release are handled automatically <br>// by the base class and will be passed on to the appropriate outer object <br> <br>STDMETHODIMP CBaseVideoRenderer::get_FramesDroppedInRenderer(int *pcFramesDropped) <br>{ <br>    CheckPointer(pcFramesDropped,E_POINTER); <br>    CAutoLock cVideoLock(&amp;m_InterfaceLock); <br>    *pcFramesDropped = m_cFramesDropped; <br>    return NOERROR; <br>} // get_FramesDroppedInRenderer <br> <br> <br>// Set *pcFramesDrawn to the number of frames drawn since <br>// streaming started. <br> <br>STDMETHODIMP CBaseVideoRenderer::get_FramesDrawn( int *pcFramesDrawn) <br>{ <br>    CheckPointer(pcFramesDrawn,E_POINTER); <br>    CAutoLock cVideoLock(&amp;m_InterfaceLock); <br>    *pcFramesDrawn = m_cFramesDrawn; <br>    return NOERROR; <br>} // get_FramesDrawn <br> <br> <br>// Set iAvgFrameRate to the frames per hundred secs since <br>// streaming started.  0 otherwise. <br> <br>STDMETHODIMP CBaseVideoRenderer::get_AvgFrameRate( int *piAvgFrameRate) <br>{ <br>    CheckPointer(piAvgFrameRate,E_POINTER); <br>    CAutoLock cVideoLock(&amp;m_InterfaceLock); <br> <br>    int t; <br>    if (m_bStreaming) { <br>t = timeGetTime()-m_tStreamingStart; <br>    } else { <br>t = m_tStreamingStart; <br>    } <br> <br>    if (t&lt;=0) { <br>*piAvgFrameRate = 0; <br>ASSERT(m_cFramesDrawn == 0); <br>    } else { <br>// i is frames per hundred seconds <br>*piAvgFrameRate = MulDiv(100000, m_cFramesDrawn, t); <br>    } <br>    return NOERROR; <br>} // get_AvgFrameRate <br> <br> <br>// Set *piAvg to the average sync offset since streaming started <br>// in mSec.  The sync offset is the time in mSec between when the frame <br>// should have been drawn and when the frame was actually drawn. <br> <br>STDMETHODIMP CBaseVideoRenderer::get_AvgSyncOffset( int *piAvg) <br>{ <br>    CheckPointer(piAvg,E_POINTER); <br>    CAutoLock cVideoLock(&amp;m_InterfaceLock); <br> <br>    if (NULL==m_pClock) { <br>*piAvg = 0; <br>return NOERROR; <br>    } <br> <br>    // Note that we didn't gather the stats on the first frame <br>    // so we use m_cFramesDrawn-1 here <br>    if (m_cFramesDrawn&lt;=1) { <br>*piAvg = 0; <br>    } else { <br>*piAvg = (int)(m_iTotAcc / (m_cFramesDrawn-1)); <br>    } <br>    return NOERROR; <br>} // get_AvgSyncOffset <br> <br> <br>// To avoid dragging in the maths library - a cheap <br>// approximate integer square root. </code></pre>
<p>
</p>
<pre><code>// We do this by getting a starting guess which is between 1 <br>// and 2 times too large, followed by THREE iterations of <br>// Newton Raphson.  (That will give accuracy to the nearest mSec <br>// for the range in question - roughly 0..1000) <br>// <br>// It would be faster to use a linear interpolation and ONE NR, but <br>// who cares.  If anyone does - the best linear interpolation is <br>// to approximates sqrt(x) by <br>// y = x * (sqrt(2)-1) + 1 - 1/sqrt(2) + 1/(8*(sqrt(2)-1)) <br>// 0r y = x*0.41421 + 0.59467 <br>// This minimises the maximal error in the range in question. <br>// (error is about +0.008883 and then one NR will give error .0000something <br>// (Of course these are integers, so you can't just multiply by 0.41421 <br>// you'd have to do some sort of MulDiv). <br>// Anyone wanna check my maths?  (This is only for a property display!) <br> <br>int isqrt(int x) <br>{ <br>    int s = 1; <br>    // Make s an initial guess for sqrt(x) <br>    if (x &gt; 0x40000000) { <br>       s = 0x8000;     // prevent any conceivable closed loop <br>    } else { <br>while (s*s&lt;x) {    // loop cannot possible go more than 31 times <br>    s = 2*s;       // normally it goes about 6 times <br>} <br>// Three NR iterations. <br>if (x==0) { <br>   s= 0; // Wouldn't it be tragic to divide by zero whenever our <br> // accuracy was perfect! <br>} else { <br>    s = (s*s+x)/(2*s); <br>    if (s&gt;=0) s = (s*s+x)/(2*s); <br>    if (s&gt;=0) s = (s*s+x)/(2*s); <br>} <br>    } <br>    return s; <br>} <br> <br>// <br>//  Do estimates for standard deviations for per-frame <br>//  statistics <br>// <br>HRESULT CBaseVideoRenderer::GetStdDev( <br>    int nSamples, <br>    int *piResult, <br>    LONGLONG llSumSq, <br>    LONGLONG iTot <br>) <br>{ <br>    CheckPointer(piResult,E_POINTER); <br>    CAutoLock cVideoLock(&amp;m_InterfaceLock); <br> <br>    if (NULL==m_pClock) { <br>*piResult = 0; <br>return NOERROR; <br>    } <br> <br>    // If S is the Sum of the Squares of observations and <br>    //    T the Total (i.e. sum) of the observations and there were <br>    //    N observations, then an estimate of the standard deviation is <br>    //      sqrt( (S - T**2/N) / (N-1) ) <br> <br>    if (nSamples&lt;=1) { <br>*piResult = 0; <br>    } else { <br>LONGLONG x; <br>// First frames have bogus stamps, so we get no stats for them <br>// So we need 2 frames to get 1 datum, so N is cFramesDrawn-1 <br> <br>// so we use m_cFramesDrawn-1 here <br>x = llSumSq - llMulDiv(iTot, iTot, nSamples, 0); <br>x = x / (nSamples-1); <br>ASSERT(x&gt;=0); <br>*piResult = isqrt((LONG)x); <br>    } <br>    return NOERROR; <br>} <br> <br>// Set *piDev to the standard deviation in mSec of the sync offset <br>// of each frame since streaming started. <br> <br>STDMETHODIMP CBaseVideoRenderer::get_DevSyncOffset( int *piDev) <br>{ <br>    // First frames have bogus stamps, so we get no stats for them <br>    // So we need 2 frames to get 1 datum, so N is cFramesDrawn-1 <br>    return GetStdDev(m_cFramesDrawn - 1, <br>     piDev, <br>     m_iSumSqAcc, <br>     m_iTotAcc); <br>} // get_DevSyncOffset <br> <br> <br>// Set *piJitter to the standard deviation in mSec of the inter-frame time <br>// of frames since streaming started. <br> <br>STDMETHODIMP CBaseVideoRenderer::get_Jitter( int *piJitter) <br>{ <br>    // First frames have bogus stamps, so we get no stats for them <br>    // So second frame gives bogus inter-frame time <br>    // So we need 3 frames to get 1 datum, so N is cFramesDrawn-2 <br>    return GetStdDev(m_cFramesDrawn - 2, <br>     piJitter, <br>     m_iSumSqFrameTime, <br>     m_iSumFrameTime); <br>} // get_Jitter <br> <br> <br>// Overidden to return our IQualProp interface <br> <br>STDMETHODIMP <br>CBaseVideoRenderer::NonDelegatingQueryInterface(REFIID riid,VOID **ppv) <br>{ <br>    // We return IQualProp and delegate everything else <br> <br>    if (riid == IID_IQualProp) { <br>return GetInterface( (IQualProp *)this, ppv); <br>    } else if (riid == IID_IQualityControl) { <br>return GetInterface( (IQualityControl *)this, ppv); <br>    } <br>    return CBaseRenderer::NonDelegatingQueryInterface(riid,ppv); <br>} <br> <br> <br>// Override JoinFilterGraph so that, just before leaving <br>// the graph we can send an EC_WINDOW_DESTROYED event <br> <br>STDMETHODIMP <br>CBaseVideoRenderer::JoinFilterGraph(IFilterGraph *pGraph,LPCWSTR pName) <br>{ <br>    // Since we send EC_ACTIVATE, we also need to ensure <br>    // we send EC_WINDOW_DESTROYED or the resource manager may be <br>    // holding us as a focus object <br>    if (!pGraph &amp;&amp; m_pGraph) { <br> <br>// We were in a graph and now we're not <br>// Do this properly in case we are aggregated <br>IBaseFilter* pFilter; <br>QueryInterface(IID_IBaseFilter,(void **) &amp;pFilter); <br>NotifyEvent(EC_WINDOW_DESTROYED, (LPARAM) pFilter, 0); <br>pFilter-&gt;Release(); <br>    } <br>    return CBaseFilter::JoinFilterGraph(pGraph, pName); <br>} <br> <br> <br>// This removes a large number of level 4 warnings from the <br>// Microsoft compiler which in this case are not very useful <br>#pragma warning(disable: 4514) <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
