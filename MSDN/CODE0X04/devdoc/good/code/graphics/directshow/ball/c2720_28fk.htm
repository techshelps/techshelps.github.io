<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>BALL.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2720"></a>BALL.CPP</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>#include &lt;streams.h&gt; <br>#include "ball.h" <br> <br>// <br>// <br>// What this samples illustrates <br>// <br>// A simple source filter that produces decompressed images showing a ball <br>// bouncing around. Each movement of the ball is done by generating a new <br>// image. We use the CSource and CSourceStream base classes to manage a <br>// source filter - we are a live source and so do not support any seeking. <br>// <br>// <br>// Summary <br>// <br>// This is a sample source filter - we produce a never ending stream of images <br>// that show a coloured ball bouncing around the window. Depending on the bit <br>// depth of the current display device we colour the ball differently. As we <br>// are effectively a live video stream we do not offer any seeking interfaces. <br>// We can supply 32,24,16 (555 and 565) as well as eight bit palettised types <br>// <br>// <br>// Implementation <br>// <br>// We use the CSource and CSourceStream base classes from the SDK which look <br>// after some of the grunge associated with source filters, in particular the <br>// starting the stopping of workers threads as we're activated and stopped. <br>// The worker thread sits in a loop asking for buffers and then calling the <br>// PURE virtual FillBuffer method when it has a buffer for us to fill up. <br>// <br>// For an example we also have a simple quality management implementation in <br>// this filter, quality management of everyone except renderers (who are the <br>// ones normally to initiate it) is controlled through IQualityControl. This <br>// is called on each frame to say how we are getting on, because this filter <br>// is pretty straightforward we can control the spacing of samples we send <br>// downstream so that we always run flat out with whatever CPU is available <br>// <br>// <br>// Demonstration instructions <br>// <br>// Start GRAPHEDT available in the ActiveMovie SDK tools. Click on the Graph <br>// menu and select "Insert Filters". From the dialog box double click on <br>// "Bouncing ball" and then dismiss the dialog. Go to the right hand pin of <br>// the filter box and right click, select Render. A video renderer will be <br>// inserted and connected up (on some displays there may be a colour space <br>// convertor put between them to get the pictures into a suitable format). <br>// Then click run on GRAPHEDT and see the ball bounce around the window... <br>// <br>// <br>// Files <br>// <br>// ball.cpp         Looks after drawing a moving bouncing ball <br>// ball.def         What APIs the DLL imports and exports <br>// ball.h           Class definition for the ball drawing object <br>// ball.rc          Version and title information resources <br>// ball.reg         What goes in the registry to make us work <br>// balluids.h       The CLSIDs for the bouncing ball filter <br>// fball.cpp        The real filter class implementation <br>// fball.h          Class definition for the main filter object <br>// makefile         How to build it... <br>// resource.h       A couple of identifiers for our resources <br>// <br>// <br>// Base classes used <br>// <br>// CSource          Base class for a generic source filter <br>// CSourceStream    A base class for a source filters stream <br>// <br>// <br> <br> <br>// <br>// Constructor <br>// <br>// The default arguments provide a reasonable image and ball size <br>// <br>CBall::CBall(int iImageWidth, int iImageHeight, int iBallSize) : <br>    m_iImageWidth(iImageWidth), <br>    m_iImageHeight(iImageHeight), <br>    m_iBallSize(iBallSize), <br>    m_iAvailableWidth(iImageWidth - iBallSize), <br>    m_iAvailableHeight(iImageHeight - iBallSize), <br>    m_x(0), <br>    m_y(0), <br>    m_xDir(RIGHT), <br>    m_yDir(UP) <br>{ <br>    // Check we have some (arbitrary) space to bounce in. <br>    ASSERT(iImageWidth &gt; 2*iBallSize); <br>    ASSERT(iImageHeight &gt; 2*iBallSize); <br> <br>    // Random position for showing off a video mixer <br>    m_iRandX = rand(); <br>    m_iRandY = rand(); <br> <br>} // (Constructor) <br> <br> <br>// <br>// PlotBall <br>// <br>// Assumes the image buffer is arranged row 1,row 2,...,row n <br>//      in memory and that the data is contiguous. <br>// <br>void CBall::PlotBall(BYTE pFrame[], BYTE BallPixel[], int iPixelSize) <br>{ <br>    ASSERT(m_x &gt;= 0); <br>    ASSERT(m_x &lt;= m_iAvailableWidth); <br>    ASSERT(m_y &gt;= 0); <br>    ASSERT(m_y &lt;= m_iAvailableHeight); <br> <br>    // The current byte of interest in the frame <br>    BYTE *pBack =   pFrame; <br> <br>    // Plot the ball into the correct location <br>    BYTE *pBall = pFrame + ( m_y * m_iImageWidth * iPixelSize) + m_x * iPixelSize; <br> <br>    for (int row = 0; row &lt; m_iBallSize; row++) { <br> <br>        for (int col = 0; col &lt; m_iBallSize; col++) { <br> <br>            // For each byte fill its value from BallPixel[] <br>            for (int i = 0; i &lt; iPixelSize; i++) { <br>                if (WithinCircle(col, row)) { <br>                    *pBall = BallPixel[i]; <br>                } <br>                pBall++; <br>    } <br>} <br>pBall += m_iAvailableWidth * iPixelSize; <br>    } <br> <br>} // PlotBall <br> <br> <br>// <br>// BallPosition <br>// <br>// Return the 1-dimensional position of the ball at time t millisecs <br>//      (note that millisecs runs out after about a month!) <br>// <br>int CBall::BallPosition(int iPixelTime, // Millisecs per pixel <br>                        int iLength,    // Distance between the bounce points <br>                        int time,       // Time in millisecs <br>                        int iOffset)    // For a bit of randomness <br>{ <br>    // Calculate the position of an unconstrained ball (no walls) <br>    // then fold it back and forth to calculate the actual position <br> <br>    int x = time / iPixelTime; <br>    x += iOffset; <br>    x %= 2*iLength; <br> <br>    // check it is still in bounds <br>    if (x&gt;iLength) { <br>        x = 2*iLength - x; <br>    } <br>    return x; <br> <br>} // BallPosition <br> <br> <br>// <br>// MoveBall <br>// <br>// Set (m_x, m_y) to the new position of the ball.  move diagonally <br>// with speed m_v in each of x and y directions. <br>// Guarantees to keep the ball in valid areas of the frame. <br>// When it hits an edge the ball bounces in the traditional manner!. <br>// The boundaries are (0..m_iAvailableWidth, 0..m_iAvailableHeight) <br>// <br>void CBall::MoveBall(CRefTime rt) <br>{ <br>    m_x = BallPosition( 10, m_iAvailableWidth, rt.Millisecs(), m_iRandX ); <br>    m_y = BallPosition( 10, m_iAvailableHeight, rt.Millisecs(), m_iRandY ); <br> <br>} // MoveBall <br> <br> <br>// <br>// WithinCircle <br>// <br>// Return TRUE if (x,y) is within a circle radius S/2, centre (S/2, S/2) <br>//      where S is m_iBallSize else return FALSE <br>// <br>inline BOOL CBall::WithinCircle(int x, int y) <br>{ <br>    unsigned int r = m_iBallSize / 2; <br> <br>    if ( (x-r)*(x-r) + (y-r)*(y-r)  &lt; r*r) { <br>        return TRUE; <br>    } else { <br>        return FALSE; <br>    } <br> <br>} // WithinCircle <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
