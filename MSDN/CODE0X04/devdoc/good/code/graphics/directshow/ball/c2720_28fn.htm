<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FBALL.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2723"></a>FBALL.CPP</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>#include &lt;streams.h&gt; <br>#include &lt;olectl.h&gt; <br>#include &lt;initguid.h&gt; <br>#include "balluids.h" <br>#include "ball.h" <br>#include "fball.h" <br> <br> <br>// Setup data <br> <br>const AMOVIESETUP_MEDIATYPE sudOpPinTypes = <br>{ <br>    &amp;MEDIATYPE_Video,       // Major type <br>    &amp;MEDIASUBTYPE_NULL      // Minor type <br>}; <br> <br>const AMOVIESETUP_PIN sudOpPin = <br>{ <br>    L"Output",              // Pin string name <br>    FALSE,                  // Is it rendered <br>    TRUE,                   // Is it an output <br>    FALSE,                  // Can we have none <br>    FALSE,                  // Can we have many <br>    &amp;CLSID_NULL,            // Connects to filter <br>    NULL,                   // Connects to pin <br>    1,                      // Number of types <br>    &amp;sudOpPinTypes };       // Pin details <br> <br>const AMOVIESETUP_FILTER sudBallax = <br>{ <br>    &amp;CLSID_BouncingBall,    // Filter CLSID <br>    L"Bouncing Ball",       // String name <br>    MERIT_DO_NOT_USE,       // Filter merit <br>    1,                      // Number pins <br>    &amp;sudOpPin               // Pin details <br>}; <br> <br> <br>// COM global table of objects in this dll <br> <br>CFactoryTemplate g_Templates[] = { <br>  { L"Bouncing Ball" <br>  , &amp;CLSID_BouncingBall <br>  , CBouncingBall::CreateInstance <br>  , NULL <br>  , &amp;sudBallax } <br>}; <br>int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]); <br> <br> <br>// <br>// DllRegisterServer <br>// <br>// Exported entry points for registration and unregistration <br>// <br>STDAPI DllRegisterServer() <br>{ <br>    return AMovieDllRegisterServer2( TRUE ); <br> <br>} // DllRegisterServer <br> <br> <br>// <br>// DllUnregisterServer <br>// <br>STDAPI DllUnregisterServer() <br>{ <br>    return AMovieDllRegisterServer2( FALSE ); <br> <br>} // DllUnregisterServer <br> <br> <br>// <br>// CreateInstance <br>// <br>// The only allowed way to create Bouncing balls! <br>// <br>CUnknown * WINAPI CBouncingBall::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr) <br>{ <br>    CUnknown *punk = new CBouncingBall(lpunk, phr); <br>    if (punk == NULL) { <br>        *phr = E_OUTOFMEMORY; <br>    } <br>    return punk; <br> <br>} // CreateInstance <br> <br> <br>// <br>// Constructor <br>// <br>// Initialise a CBallStream object so that we have a pin. <br>// <br>CBouncingBall::CBouncingBall(LPUNKNOWN lpunk, HRESULT *phr) : <br>    CSource(NAME("Bouncing ball"), <br>            lpunk, <br>            CLSID_BouncingBall) <br>{ <br>    CAutoLock cAutoLock(&amp;m_cStateLock); <br> <br>    m_paStreams    = (CSourceStream **) new CBallStream*[1]; <br>    if (m_paStreams == NULL) { <br>        *phr = E_OUTOFMEMORY; <br>return; <br>    } <br> <br>    m_paStreams[0] = new CBallStream(phr, this, L"A Bouncing Ball!"); <br>    if (m_paStreams[0] == NULL) { <br>        *phr = E_OUTOFMEMORY; <br>return; <br>    } <br> <br>} // (Constructor) <br> <br> <br>// <br>// Constructor <br>// <br>CBallStream::CBallStream(HRESULT *phr, <br>                         CBouncingBall *pParent, <br>                         LPCWSTR pPinName) : <br>    CSourceStream(NAME("Bouncing Ball"),phr, pParent, pPinName), <br>    m_iImageWidth(320), <br>    m_iImageHeight(240), <br>    m_iDefaultRepeatTime(20) <br>{ <br>    CAutoLock cAutoLock(&amp;m_cSharedState); <br> <br>    m_Ball = new CBall(m_iImageWidth, m_iImageHeight); <br>    if (m_Ball == NULL) { <br>        *phr = E_OUTOFMEMORY; <br>    } <br> <br>} // (Constructor) <br> <br> <br>// <br>// Destructor <br>// <br>CBallStream::~CBallStream() <br>{ <br>    CAutoLock cAutoLock(&amp;m_cSharedState); <br>    if( m_Ball ) <br>        delete m_Ball; <br> <br>} // (Destructor) <br> <br> <br>// <br>// FillBuffer <br>// <br>// Plots a ball into the supplied video buffer <br>// <br>HRESULT CBallStream::FillBuffer(IMediaSample *pms) <br>{ <br>    BYTE *pData; <br>    long lDataLen; <br> <br>    pms-&gt;GetPointer(&amp;pData); <br>    lDataLen = pms-&gt;GetSize(); <br> <br>    // If true then we clear the output buffer and don't attempt to <br>    // erase a previous drawing of the ball - this will be the case <br>    // when we start running as the buffer will be full of rubbish <br>    if( m_bZeroMemory ) { <br>        ZeroMemory( pData, lDataLen ); <br>    } <br> <br>    { <br>        CAutoLock cAutoLockShared(&amp;m_cSharedState); <br> <br>        // If we haven't just cleared the buffer delete the old <br>        // ball and move the ball on <br> <br>        if( !m_bZeroMemory ){ <br>            BYTE aZeroes[ 4 ] = { 0, 0, 0, 0 }; <br>            m_Ball-&gt;PlotBall(pData, aZeroes, m_iPixelSize); <br>            m_Ball-&gt;MoveBall(m_rtSampleTime - (LONG) m_iRepeatTime); <br>        } <br> <br>        m_Ball-&gt;PlotBall(pData, m_BallPixel, m_iPixelSize); <br> <br>        // The current time is the sample's start <br>        CRefTime rtStart = m_rtSampleTime; <br> <br>        // Increment to find the finish time <br>        m_rtSampleTime += (LONG)m_iRepeatTime; <br> <br>        pms-&gt;SetTime((REFERENCE_TIME *) &amp;rtStart,(REFERENCE_TIME *) &amp;m_rtSampleTime); <br>    } <br> <br>    m_bZeroMemory = FALSE; <br>    pms-&gt;SetSyncPoint(TRUE); <br>    return NOERROR; <br> <br>} // FillBuffer <br> <br> <br>// <br>// Notify <br>// <br>// Alter the repeat rate according to quality management messages sent from <br>// the downstream filter (often the renderer).  Wind it up or down according <br>// to the flooding level - also skip forward if we are notified of Late-ness <br>// <br>STDMETHODIMP CBallStream::Notify(IBaseFilter * pSender, Quality q) <br>{ <br>    // Adjust the repeat rate. <br>    if (q.Proportion&lt;=0) { <br>        m_iRepeatTime = 1000;        // We don't go slower than 1 per second <br>    } else { <br>        m_iRepeatTime = m_iRepeatTime*1000/q.Proportion; <br>        if (m_iRepeatTime&gt;1000) { <br>            m_iRepeatTime = 1000;    // We don't go slower than 1 per second <br>        } else if (m_iRepeatTime&lt;10) { <br>            m_iRepeatTime = 10;      // We don't go faster than 100/sec <br>        } <br>    } <br> <br>    // skip forwards <br>    if (q.Late &gt; 0) { <br>        m_rtSampleTime += q.Late; <br>    } <br>    return NOERROR; <br> <br>} // Notify <br> <br> <br>// <br>// GetMediaType <br>// <br>// I _prefer_ 5 formats - 8, 16 (*2), 24 or 32 bits per pixel and <br>// I will suggest these with an image size of 320x240. However <br>// I can accept any image size which gives me some space to bounce. <br>// <br>// A bit of fun: <br>//      8 bit displays get red balls <br>//      16 bit displays get blue <br>//      24 bit see green <br>//      And 32 bit see yellow <br>// <br>// Prefered types should be ordered by quality, zero as highest quality <br>// Therefore iPosition = <br>// 0return a 32bit mediatype <br>// 1return a 24bit mediatype <br>// 2return 16bit RGB565 <br>// 3return a 16bit mediatype (rgb555) <br>// 4return 8 bit palettised format <br>// (iPosition &gt; 4 is invalid) <br>// <br>HRESULT CBallStream::GetMediaType(int iPosition, CMediaType *pmt) <br>{ <br>    CAutoLock cAutoLock(m_pFilter-&gt;pStateLock()); <br>    if (iPosition &lt; 0) { <br>        return E_INVALIDARG; <br>    } <br> <br>    // Have we run off the end of types <br> <br>    if (iPosition &gt; 4) { <br>        return VFW_S_NO_MORE_ITEMS; <br>    } <br> <br>    VIDEOINFO *pvi = (VIDEOINFO *) pmt-&gt;AllocFormatBuffer(sizeof(VIDEOINFO)); <br>    if (NULL == pvi) { <br>return(E_OUTOFMEMORY); <br>    } <br>    ZeroMemory(pvi, sizeof(VIDEOINFO)); <br> <br>    switch (iPosition) { <br>   case 0: {// Return our highest quality 32bit format <br> <br>            // Place the RGB masks as the first 3 doublewords in the palette area <br>            for (int i = 0; i &lt; 3; i++) <br>                pvi-&gt;TrueColorInfo.dwBitMasks[i] = bits888[i]; <br> <br>            SetPaletteEntries(Yellow); <br>        pvi-&gt;bmiHeader.biCompression = BI_BITFIELDS; <br>        pvi-&gt;bmiHeader.biBitCount    = 32; <br>    } <br>    break; <br> <br>        case 1: {// Return our 24bit format <br> <br>            SetPaletteEntries(Green); <br>        pvi-&gt;bmiHeader.biCompression = BI_RGB; <br>        pvi-&gt;bmiHeader.biBitCount    = 24; <br>        } <br>    break; <br> <br>        case 2: {       // 16 bit per pixel RGB565 <br> <br>            // Place the RGB masks as the first 3 doublewords in the palette area <br>            for (int i = 0; i &lt; 3; i++) <br>                pvi-&gt;TrueColorInfo.dwBitMasks[i] = bits565[i]; <br> <br>            SetPaletteEntries(Blue); <br>            pvi-&gt;bmiHeader.biCompression = BI_BITFIELDS; <br>        pvi-&gt;bmiHeader.biBitCount    = 16; <br>    } <br>        break; <br> <br>        case 3: {// 16 bits per pixel RGB555 <br> <br>            // Place the RGB masks as the first 3 doublewords in the palette area <br>            for (int i = 0; i &lt; 3; i++) <br>            pvi-&gt;TrueColorInfo.dwBitMasks[i] = bits555[i]; <br> <br>            SetPaletteEntries(Blue); <br>        pvi-&gt;bmiHeader.biCompression = BI_BITFIELDS; <br>        pvi-&gt;bmiHeader.biBitCount    = 16; <br> <br>        } <br>    break; <br> <br>        case 4: {// 8 bit palettised <br> <br>            SetPaletteEntries(Red); <br>            pvi-&gt;bmiHeader.biCompression = BI_RGB; <br>            pvi-&gt;bmiHeader.biBitCount    = 8; <br>pvi-&gt;bmiHeader.biClrUsed= iPALETTE_COLORS; <br>    } <br>    break; <br>    } <br> <br>    // (Adjust the parameters common to all formats...) <br> <br>    // put the optimal palette in place <br>    for (int i = 0; i &lt; iPALETTE_COLORS; i++) { <br>        pvi-&gt;TrueColorInfo.bmiColors[i].rgbRed      = m_Palette[i].peRed; <br>        pvi-&gt;TrueColorInfo.bmiColors[i].rgbBlue     = m_Palette[i].peBlue; <br>        pvi-&gt;TrueColorInfo.bmiColors[i].rgbGreen    = m_Palette[i].peGreen; <br>        pvi-&gt;TrueColorInfo.bmiColors[i].rgbReserved = 0; <br>    } <br> <br>    pvi-&gt;bmiHeader.biSize= sizeof(BITMAPINFOHEADER); <br>    pvi-&gt;bmiHeader.biWidth= m_iImageWidth; <br>    pvi-&gt;bmiHeader.biHeight= m_iImageHeight; <br>    pvi-&gt;bmiHeader.biPlanes= 1; <br>    pvi-&gt;bmiHeader.biSizeImage= GetBitmapSize(&amp;pvi-&gt;bmiHeader); <br>    pvi-&gt;bmiHeader.biClrImportant= 0; <br> <br>    SetRectEmpty(&amp;(pvi-&gt;rcSource));// we want the whole image area rendered. <br>    SetRectEmpty(&amp;(pvi-&gt;rcTarget));// no particular destination rectangle <br> <br>    pmt-&gt;SetType(&amp;MEDIATYPE_Video); <br>    pmt-&gt;SetFormatType(&amp;FORMAT_VideoInfo); <br>    pmt-&gt;SetTemporalCompression(FALSE); <br> <br>    // Work out the GUID for the subtype from the header info. <br>    const GUID SubTypeGUID = GetBitmapSubtype(&amp;pvi-&gt;bmiHeader); <br>    pmt-&gt;SetSubtype(&amp;SubTypeGUID); <br>    pmt-&gt;SetSampleSize(pvi-&gt;bmiHeader.biSizeImage); <br> <br>    return NOERROR; <br> <br>} // GetMediaType <br> <br> <br>// <br>// CheckMediaType <br>// <br>// We will accept 8, 16, 24 or 32 bit video formats, in any <br>// image size that gives room to bounce. <br>// Returns E_INVALIDARG if the mediatype is not acceptable <br>// <br>HRESULT CBallStream::CheckMediaType(const CMediaType *pMediaType) <br>{ <br>    CAutoLock cAutoLock(m_pFilter-&gt;pStateLock()); <br> <br>    if ((*(pMediaType-&gt;Type()) != MEDIATYPE_Video)// we only output video! <br>    || !(pMediaType-&gt;IsFixedSize()) ) {// ...in fixed size samples <br>                return E_INVALIDARG; <br>    } <br> <br>    // Check for the subtypes we support <br>    const GUID *SubType = pMediaType-&gt;Subtype(); <br>    if ((*SubType != MEDIASUBTYPE_RGB8) <br>            &amp;&amp; (*SubType != MEDIASUBTYPE_RGB565) <br>    &amp;&amp; (*SubType != MEDIASUBTYPE_RGB555) <br>     &amp;&amp; (*SubType != MEDIASUBTYPE_RGB24) <br>    &amp;&amp; (*SubType != MEDIASUBTYPE_RGB32)) { <br>                return E_INVALIDARG; <br>    } <br> <br>    // Get the format area of the media type <br>    VIDEOINFO *pvi = (VIDEOINFO *) pMediaType-&gt;Format(); <br> <br>    if (pvi == NULL) <br>return E_INVALIDARG; <br> <br>    // Check the image size. As my default ball is 10 pixels big <br>    // look for at least a 20x20 image. This is an arbitary size constraint, <br>    // but it avoids balls that are bigger than the picture... <br> <br>    if ((pvi-&gt;bmiHeader.biWidth &lt; 20) || (pvi-&gt;bmiHeader.biHeight &lt; 20) ) { <br>return E_INVALIDARG; <br>    } <br> <br>    return S_OK;  // This format is acceptable. <br> <br>} // CheckMediaType <br> <br> <br>// <br>// DecideBufferSize <br>// <br>// This will always be called after the format has been sucessfully <br>// negotiated. So we have a look at m_mt to see what size image we agreed. <br>// Then we can ask for buffers of the correct size to contain them. <br>// <br>HRESULT CBallStream::DecideBufferSize(IMemAllocator *pAlloc,ALLOCATOR_PROPERTIES *pProperties) <br>{ <br>    CAutoLock cAutoLock(m_pFilter-&gt;pStateLock()); <br>    ASSERT(pAlloc); <br>    ASSERT(pProperties); <br>    HRESULT hr = NOERROR; <br> <br>    VIDEOINFO *pvi = (VIDEOINFO *) m_mt.Format(); <br>    pProperties-&gt;cBuffers = 1; <br>    pProperties-&gt;cbBuffer = pvi-&gt;bmiHeader.biSizeImage; <br> <br>    ASSERT(pProperties-&gt;cbBuffer); <br> <br>    // Ask the allocator to reserve us some sample memory, NOTE the function <br>    // can succeed (that is return NOERROR) but still not have allocated the <br>    // memory that we requested, so we must check we got whatever we wanted <br> <br>    ALLOCATOR_PROPERTIES Actual; <br>    hr = pAlloc-&gt;SetProperties(pProperties,&amp;Actual); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br> <br>    // Is this allocator unsuitable <br> <br>    if (Actual.cbBuffer &lt; pProperties-&gt;cbBuffer) { <br>        return E_FAIL; <br>    } <br> <br>    // Make sure that we have only 1 buffer (we erase the ball in the <br>    // old buffer to save having to zero a 200k+ buffer every time <br>    // we draw a frame) <br> <br>    ASSERT( Actual.cBuffers == 1 ); <br>    return NOERROR; <br> <br>} // DecideBufferSize <br> <br> <br>// <br>// SetMediaType <br>// <br>// Called when a media type is agreed between filters <br>// <br>HRESULT CBallStream::SetMediaType(const CMediaType *pMediaType) <br>{ <br>    CAutoLock cAutoLock(m_pFilter-&gt;pStateLock()); <br> <br>    // Pass the call up to my base class <br> <br>    HRESULT hr = CSourceStream::SetMediaType(pMediaType); <br>    if (SUCCEEDED(hr)) { <br> <br>        VIDEOINFO * pvi = (VIDEOINFO *) m_mt.Format(); <br>        switch (pvi-&gt;bmiHeader.biBitCount) { <br>        case 8:// Make a red pixel <br> <br>            m_BallPixel[0] = 10;// 0 is palette index of red <br>    m_iPixelSize   = 1; <br>    SetPaletteEntries(Red); <br>    break; <br> <br>        case 16:// Make a blue pixel <br> <br>            m_BallPixel[0] = 0xf8;// 00000000 00011111 is blue in rgb555 or rgb565 <br>    m_BallPixel[1] = 0x0;// don't forget the byte ordering within the mask word. <br>    m_iPixelSize   = 2; <br>    SetPaletteEntries(Blue); <br>    break; <br> <br>        case 24:// Make a green pixel <br> <br>            m_BallPixel[0] = 0x0; <br>    m_BallPixel[1] = 0xff; <br>    m_BallPixel[2] = 0x0; <br>    m_iPixelSize   = 3; <br>    SetPaletteEntries(Green); <br>    break; <br> <br>case 32:// Make a yellow pixel <br> <br>            m_BallPixel[0] = 0x0; <br>    m_BallPixel[1] = 0x0; <br>    m_BallPixel[2] = 0xff; <br>    m_BallPixel[3] = 0xff; <br>    m_iPixelSize   = 4; <br>            SetPaletteEntries(Yellow); <br>    break; <br> <br>        default: <br>            // We should never agree any other pixel sizes <br>    ASSERT("Tried to agree inappropriate format"); <br>        } <br> <br>         CBall *pNewBall = new CBall(pvi-&gt;bmiHeader.biWidth, pvi-&gt;bmiHeader.biHeight); <br> <br>         if( pNewBall ){ <br>             delete m_Ball; <br>             m_Ball = pNewBall; <br>         } else <br>             hr = E_OUTOFMEMORY; <br> <br>         return NOERROR; <br>    } else { <br>        return hr; <br>    } <br> <br>} // SetMediaType <br> <br> <br>// <br>// OnThreadCreate <br>// <br>// As we go active reset the stream time to zero <br>// <br>HRESULT CBallStream::OnThreadCreate() <br>{ <br>    CAutoLock cAutoLockShared(&amp;m_cSharedState); <br>    m_rtSampleTime = 0; <br> <br>    // we need to also reset the repeat time in case the system <br>    // clock is turned off after m_iRepeatTime gets very big <br>    m_iRepeatTime = m_iDefaultRepeatTime; <br> <br>    // Zero the output buffer on the first frame. <br>    m_bZeroMemory = TRUE; <br> <br>    return NOERROR; <br> <br>} // OnThreadCreate <br> <br> <br>// <br>// SetPaletteEntries <br>// <br>// If we set our palette to the current system palette + the colours we want <br>// the system has the least amount of work to do whilst plotting our images, <br>// if this stream is rendered to the current display. The first non reserved <br>// palette slot is at m_Palette[10], so put our first colour there. Also <br>// guarantees that black is always represented by zero in the frame buffer <br>// <br>HRESULT CBallStream::SetPaletteEntries(Colour colour) <br>{ <br>    CAutoLock cAutoLock(m_pFilter-&gt;pStateLock()); <br> <br>    HDC hdc = GetDC(NULL);// hdc for the current display. <br>    UINT res = GetSystemPaletteEntries(hdc, 0, iPALETTE_COLORS, (LPPALETTEENTRY) &amp;m_Palette); <br>    ReleaseDC(NULL, hdc); <br> <br>    if (res == 0) { <br>        return E_FAIL; <br>    } <br> <br>    switch (colour) { <br>        case Red: <br>            m_Palette[10].peBlue  = 0; <br>            m_Palette[10].peGreen = 0; <br>            m_Palette[10].peRed   = 0xff; <br>            break; <br>        case Yellow: <br>            m_Palette[10].peBlue  = 0; <br>            m_Palette[10].peGreen = 0xff; <br>            m_Palette[10].peRed   = 0xff; <br>            break; <br>        case Blue: <br>            m_Palette[10].peBlue  = 0xff; <br>            m_Palette[10].peGreen = 0; <br>            m_Palette[10].peRed   = 0; <br>            break; <br>        case Green: <br>            m_Palette[10].peBlue  = 0; <br>            m_Palette[10].peGreen = 0xff; <br>            m_Palette[10].peRed   = 0; <br>            break; <br>    } <br> <br>    m_Palette[10].peFlags = 0; <br>    return NOERROR; <br> <br>} // SetPaletteEntries <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
