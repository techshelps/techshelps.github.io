<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FBALL.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2724"></a>FBALL.H</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>// Generates a movie on the fly of a bouncing ball... <br> <br>// The class managing the output pin <br>class CBallStream; <br> <br>// Main object for a bouncing ball filter <br>class CBouncingBall : public CSource <br>{ <br> <br>public: <br> <br>    // The only allowed way to create Bouncing balls! <br>    static CUnknown * WINAPI CreateInstance(LPUNKNOWN lpunk, HRESULT *phr); <br> <br>private: <br> <br>    // It is only allowed to to create these objects with CreateInstance <br>    CBouncingBall(LPUNKNOWN lpunk, HRESULT *phr); <br> <br>}; // CBouncingBall <br> <br> <br>// CBallStream manages the data flow from the output pin. <br>class CBallStream : public CSourceStream <br>{ <br> <br>public: <br> <br>    CBallStream(HRESULT *phr, CBouncingBall *pParent, LPCWSTR pPinName); <br>    ~CBallStream(); <br> <br>    // plots a ball into the supplied video frame <br>    HRESULT FillBuffer(IMediaSample *pms); <br> <br>    // Ask for buffers of the size appropriate to the agreed media type <br>    HRESULT DecideBufferSize(IMemAllocator *pIMemAlloc, <br>                             ALLOCATOR_PROPERTIES *pProperties); <br> <br>    // Set the agreed media type, and set up the necessary ball parameters <br>    HRESULT SetMediaType(const CMediaType *pMediaType); <br> <br>    // Because we calculate the ball there is no reason why we <br>    // can't calculate it in any one of a set of formats... <br>    HRESULT CheckMediaType(const CMediaType *pMediaType); <br>    HRESULT GetMediaType(int iPosition, CMediaType *pmt); <br> <br>    // Resets the stream time to zero <br>    HRESULT OnThreadCreate(void); <br> <br>    // Quality control notifications sent to us <br>    STDMETHODIMP Notify(IBaseFilter * pSender, Quality q); <br> <br>private: <br> <br>    int m_iImageHeight;                // The current image height <br>    int m_iImageWidth;                // And current image width <br>    int m_iRepeatTime;                  // Time in msec between frames <br>    const int m_iDefaultRepeatTime;     // Initial m_iRepeatTime <br>    BYTE m_BallPixel[4];        // Represents one coloured ball <br>    intm_iPixelSize;                // The pixel size in bytes <br>    PALETTEENTRY m_Palette[256];// The optimal palette for the image <br>    CCritSec m_cSharedState;        // Lock on m_rtSampleTime and m_Ball <br>    BOOL m_bZeroMemory;                 // Do we need to clear the buffer <br>    CRefTime m_rtSampleTime;        // The time stamp for each sample <br>    CBall *m_Ball;                // The current ball object <br> <br>    // set up the palette appropriately <br>    enum Colour {Red, Blue, Green, Yellow}; <br>    HRESULT SetPaletteEntries(Colour colour); <br> <br>}; // CBallStream <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
