<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DUMP.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2808"></a>DUMP.CPP</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>// <br>// <br>// What this sample illustrates <br>// <br>// A renderer that dumps the samples it gets into a text file <br>// <br>// <br>// Summary <br>// <br>// We are a generic renderer that can be attached to any data stream that <br>// uses IMemInputPin data transport. For each sample we receive we write <br>// it's contents including it's properties into a dump file. The file we <br>// will write into is specified when the dump filter is created. Graphedt <br>// creates a file open dialog automatically when it sees a filter being <br>// created that supports the ActiveMovie defined IFileSinkFilter interface <br>// <br>// <br>// Implementation <br>// <br>// Pretty straightforward really, we have our own input pin class so that <br>// we can override Receive, all that does is to write the properties and <br>// data into a raw data file (using the Write function). We don't keep <br>// the file open when we are stopped so the flags to the open function <br>// ensure that we open a file if already there otherwise we create it. <br>// <br>// <br>// Demonstration instructions <br>// <br>// Start GRAPHEDT available in the ActiveMovie SDK tools. Drag and drop any <br>// MPEG, AVI or MOV file into the tool and it will be rendered. Then go to <br>// the filters in the graph and find the filter (box) titled "Video Renderer" <br>// This is the filter we will be replacing with the dump renderer. Then click <br>// on the box and hit DELETE. After that go to the Graph menu and select the <br>// "Insert Filters", from the dialog box find and select the "Dump Filter". <br>// <br>// You will be asked to supply a filename where you would like to have the <br>// data dumped, the data we receive in this filter is dumped in text form. <br>// Then dismiss the dialog. Back in the graph layout find the output pin of <br>// the filter that used to be connected to the input of the video renderer <br>// you just deleted, right click and do "Render". You should see it being <br>// connected to the input pin of the dump filter you just inserted. <br>// <br>// Click Pause and Run and then a little later stop on the GRAPHEDT frame and <br>// the data being passed to the renderer will be dumped into a file. Stop the <br>// graph and dump the filename that you entered when inserting the filter into <br>// the graph, the data supplied to the renderer will be displayed as raw data <br>// <br>// <br>// Files <br>// <br>// dump.cpp             Main implementation of the dump renderer <br>// dump.def             What APIs the DLL will import and export <br>// dump.h               Class definition of the derived renderer <br>// dump.rc              Version information for the sample DLL <br>// dump.reg             What goes in the registry to make us work <br>// dumpuids.h           CLSID for the dump filter <br>// makefile             How to build it... <br>// <br>// <br>// Base classes used <br>// <br>// CBaseFilter          Base filter class supporting IMediaFilter <br>// CRenderedInputPin    An input pin attached to a renderer <br>// CUnknown             Handle IUnknown for our IFileSinkFilter <br>// CPosPassThru         Passes seeking interfaces upstream <br>// CCritSec             Helper class that wraps a critical section <br>// <br>// <br> <br>#include &lt;windows.h&gt; <br>#include &lt;commdlg.h&gt; <br>#include &lt;streams.h&gt; <br>#include &lt;initguid.h&gt; <br>#include "dumpuids.h" <br>#include "dump.h" <br> <br> <br>// Setup data <br> <br>const AMOVIESETUP_MEDIATYPE sudPinTypes = <br>{ <br>    &amp;MEDIATYPE_NULL,            // Major type <br>    &amp;MEDIASUBTYPE_NULL          // Minor type <br>}; <br> <br>const AMOVIESETUP_PIN sudPins = <br>{ <br>    L"Input",                   // Pin string name <br>    FALSE,                      // Is it rendered <br>    FALSE,                      // Is it an output <br>    FALSE,                      // Allowed none <br>    FALSE,                      // Likewise many <br>    &amp;CLSID_NULL,                // Connects to filter <br>    L"Output",                  // Connects to pin <br>    1,                          // Number of types <br>    &amp;sudPinTypes                // Pin information <br>}; <br> <br>const AMOVIESETUP_FILTER sudDump = <br>{ <br>    &amp;CLSID_Dump,                // Filter CLSID <br>    L"Dump",                    // String name <br>    MERIT_DO_NOT_USE,           // Filter merit <br>    1,                          // Number pins <br>    &amp;sudPins                    // Pin details <br>}; <br> <br> <br>// <br>//  Object creation stuff <br>// <br>CFactoryTemplate g_Templates[]= { <br>    L"Dump", &amp;CLSID_Dump, CDump::CreateInstance, NULL, &amp;sudDump <br>}; <br>int g_cTemplates = 1; <br> <br> <br>// Constructor <br> <br>CDumpFilter::CDumpFilter(CDump *pDump, <br>                         LPUNKNOWN pUnk, <br>                         CCritSec *pLock, <br>                         HRESULT *phr) : <br>    CBaseFilter(NAME("CDumpFilter"), pUnk, pLock, CLSID_Dump), <br>    m_pDump(pDump) <br>{ <br>} <br> <br> <br>// <br>// GetPin <br>// <br>CBasePin * CDumpFilter::GetPin(int n) <br>{ <br>    if (n == 0) { <br>        return m_pDump-&gt;m_pPin; <br>    } else { <br>        return NULL; <br>    } <br>} <br> <br> <br>// <br>// GetPinCount <br>// <br>int CDumpFilter::GetPinCount() <br>{ <br>    return 1; <br>} <br> <br> <br>// <br>// Stop <br>// <br>// Overriden to close the dump file <br>// <br>STDMETHODIMP CDumpFilter::Stop() <br>{ <br>    CAutoLock cObjectLock(m_pLock); <br>    m_pDump-&gt;CloseFile(); <br>    return CBaseFilter::Stop(); <br>} <br> <br> <br>// <br>// Pause <br>// <br>// Overriden to open the dump file <br>// <br>STDMETHODIMP CDumpFilter::Pause() <br>{ <br>    CAutoLock cObjectLock(m_pLock); <br>    m_pDump-&gt;OpenFile(); <br>    return CBaseFilter::Pause(); <br>} <br> <br> <br>// <br>// Run <br>// <br>// Overriden to open the dump file <br>// <br>STDMETHODIMP CDumpFilter::Run(REFERENCE_TIME tStart) <br>{ <br>    CAutoLock cObjectLock(m_pLock); <br>    m_pDump-&gt;OpenFile(); <br>    return CBaseFilter::Run(tStart); <br>} <br> <br> <br>// <br>//  Definition of CDumpInputPin <br>// <br>CDumpInputPin::CDumpInputPin(CDump *pDump, <br>                             LPUNKNOWN pUnk, <br>                             CBaseFilter *pFilter, <br>                             CCritSec *pLock, <br>                             CCritSec *pReceiveLock, <br>                             HRESULT *phr) : <br> <br>    CRenderedInputPin(NAME("CDumpInputPin"), <br>                  pFilter,                   // Filter <br>                  pLock,                     // Locking <br>                  phr,                       // Return code <br>                  L"Input"),                 // Pin name <br>    m_pReceiveLock(pReceiveLock), <br>    m_pDump(pDump), <br>    m_tLast(0) <br>{ <br>} <br> <br> <br>// <br>// CheckMediaType <br>// <br>// Check if the pin can support this specific proposed type and format <br>// <br>HRESULT CDumpInputPin::CheckMediaType(const CMediaType *) <br>{ <br>    return S_OK; <br>} <br> <br> <br>// <br>// BreakConnect <br>// <br>// Break a connection <br>// <br>HRESULT CDumpInputPin::BreakConnect() <br>{ <br>    if (m_pDump-&gt;m_pPosition != NULL) { <br>        m_pDump-&gt;m_pPosition-&gt;ForceRefresh(); <br>    } <br>    return CRenderedInputPin::BreakConnect(); <br>} <br> <br> <br>// <br>// ReceiveCanBlock <br>// <br>// We don't hold up source threads on Receive <br>// <br>STDMETHODIMP CDumpInputPin::ReceiveCanBlock() <br>{ <br>    return S_FALSE; <br>} <br> <br> <br>// <br>// Receive <br>// <br>// Do something with this media sample <br>// <br>STDMETHODIMP CDumpInputPin::Receive(IMediaSample *pSample) <br>{ <br>    CAutoLock lock(m_pReceiveLock); <br>    PBYTE pbData; <br> <br>    // Has the filter been stopped yet <br>    if (m_pDump-&gt;m_hFile == INVALID_HANDLE_VALUE) { <br>        return NOERROR; <br>    } <br> <br>    REFERENCE_TIME tStart, tStop; <br>    pSample-&gt;GetTime(&amp;tStart, &amp;tStop); <br>    DbgLog((LOG_TRACE, 1, TEXT("tStart(%s), tStop(%s), Diff(%d ms), Bytes(%d)"), <br>           (LPCTSTR) CDisp(tStart), <br>           (LPCTSTR) CDisp(tStop), <br>           (LONG)((tStart - m_tLast) / 10000), <br>           pSample-&gt;GetActualDataLength())); <br> <br>    m_tLast = tStart; <br> <br>    // Copy the data to the file <br> <br>    HRESULT hr = pSample-&gt;GetPointer(&amp;pbData); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br>    return m_pDump-&gt;Write(pbData,pSample-&gt;GetActualDataLength()); <br>} <br> <br> <br>// <br>// DumpStringInfo <br>// <br>// Write to the file as text form <br>// <br>HRESULT CDumpInputPin::WriteStringInfo(IMediaSample *pSample) <br>{ <br>    TCHAR TempString[256],FileString[256]; <br>    PBYTE pbData; <br> <br>    // Retrieve the time stamps from this sample <br> <br>    REFERENCE_TIME tStart, tStop; <br>    pSample-&gt;GetTime(&amp;tStart, &amp;tStop); <br>    m_tLast = tStart; <br> <br>    // Write the sample time stamps out <br> <br>    wsprintf(FileString,"\r\nRenderer received sample (%dms)",timeGetTime()); <br>    m_pDump-&gt;WriteString(FileString); <br>    wsprintf(FileString,"   Start time (%s)",CDisp(tStart)); <br>    m_pDump-&gt;WriteString(FileString); <br>    wsprintf(FileString,"   End time (%s)",CDisp(tStop)); <br>    m_pDump-&gt;WriteString(FileString); <br> <br>    // Display the media times for this sample <br> <br>    HRESULT hr = pSample-&gt;GetMediaTime(&amp;tStart, &amp;tStop); <br>    if (hr == NOERROR) { <br>        wsprintf(FileString,"   Start media time (%s)",CDisp(tStart)); <br>        m_pDump-&gt;WriteString(FileString); <br>        wsprintf(FileString,"   End media time (%s)",CDisp(tStop)); <br>        m_pDump-&gt;WriteString(FileString); <br>    } <br> <br>    // Is this a sync point sample <br> <br>    hr = pSample-&gt;IsSyncPoint(); <br>    wsprintf(FileString,"   Sync point (%d)",(hr == S_OK)); <br>    m_pDump-&gt;WriteString(FileString); <br> <br>    // Is this a preroll sample <br> <br>    hr = pSample-&gt;IsPreroll(); <br>    wsprintf(FileString,"   Preroll (%d)",(hr == S_OK)); <br>    m_pDump-&gt;WriteString(FileString); <br> <br>    // Is this a discontinuity sample <br> <br>    hr = pSample-&gt;IsDiscontinuity(); <br>    wsprintf(FileString,"   Discontinuity (%d)",(hr == S_OK)); <br>    m_pDump-&gt;WriteString(FileString); <br> <br>    // Write the actual data length <br> <br>    LONG DataLength = pSample-&gt;GetActualDataLength(); <br>    wsprintf(FileString,"   Actual data length (%d)",DataLength); <br>    m_pDump-&gt;WriteString(FileString); <br> <br>    // Does the sample have a type change aboard <br> <br>    AM_MEDIA_TYPE *pMediaType; <br>    pSample-&gt;GetMediaType(&amp;pMediaType); <br>    wsprintf(FileString,"   Type changed (%d)", <br>        (pMediaType ? TRUE : FALSE)); <br>    m_pDump-&gt;WriteString(FileString); <br>    DeleteMediaType(pMediaType); <br> <br>    // Copy the data to the file <br> <br>    hr = pSample-&gt;GetPointer(&amp;pbData); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br> <br>    // Write each complete line out in BYTES_PER_LINES groups <br> <br>    for (int Loop = 0;Loop &lt; (DataLength / BYTES_PER_LINE);Loop++) { <br>        wsprintf(FileString,FIRST_HALF_LINE,pbData[0],pbData[1],pbData[2], <br>                 pbData[3],pbData[4],pbData[5],pbData[6], <br>                    pbData[7],pbData[8],pbData[9]); <br>        wsprintf(TempString,SECOND_HALF_LINE,pbData[10],pbData[11],pbData[12], <br>                 pbData[13],pbData[14],pbData[15],pbData[16], <br>                    pbData[17],pbData[18],pbData[19]); <br>        lstrcat(FileString,TempString); <br>        m_pDump-&gt;WriteString(FileString); <br>        pbData += BYTES_PER_LINE; <br>    } <br> <br>    // Write the last few bytes out afterwards <br> <br>    wsprintf(FileString,"   "); <br>    for (Loop = 0;Loop &lt; (DataLength % BYTES_PER_LINE);Loop++) { <br>        wsprintf(TempString,"%x ",pbData[Loop]); <br>        lstrcat(FileString,TempString); <br>    } <br>    m_pDump-&gt;WriteString(FileString); <br>    return NOERROR; <br>} <br> <br> <br>// <br>// EndOfStream <br>// <br>STDMETHODIMP CDumpInputPin::EndOfStream(void) <br>{ <br>    CAutoLock lock(m_pReceiveLock); <br>    return CRenderedInputPin::EndOfStream(); <br> <br>} // EndOfStream <br> <br> <br>// <br>// NewSegment <br>// <br>// Called when we are seeked <br>// <br>STDMETHODIMP CDumpInputPin::NewSegment(REFERENCE_TIME tStart, <br>                                       REFERENCE_TIME tStop, <br>                                       double dRate) <br>{ <br>    m_tLast = 0; <br>    return S_OK; <br> <br>} // NewSegment <br> <br> <br>// <br>//  CDump class <br>// <br>CDump::CDump(LPUNKNOWN pUnk, HRESULT *phr) : <br>    CUnknown(NAME("CDump"), pUnk), <br>    m_pFilter(NULL), <br>    m_pPin(NULL), <br>    m_pPosition(NULL), <br>    m_hFile(INVALID_HANDLE_VALUE), <br>    m_pFileName(0) <br>{ <br>    m_pFilter = new CDumpFilter(this, GetOwner(), &amp;m_Lock, phr); <br>    if (m_pFilter == NULL) { <br>        *phr = E_OUTOFMEMORY; <br>        return; <br>    } <br> <br>    m_pPin = new CDumpInputPin(this,GetOwner(), <br>                               m_pFilter, <br>                               &amp;m_Lock, <br>                               &amp;m_ReceiveLock, <br>                               phr); <br>    if (m_pPin == NULL) { <br>        *phr = E_OUTOFMEMORY; <br>        return; <br>    } <br>} <br> <br> <br>// <br>// SetFileName <br>// <br>// Implemented for IFileSinkFilter support <br>// <br>STDMETHODIMP CDump::SetFileName(LPCOLESTR pszFileName,const AM_MEDIA_TYPE *pmt) <br>{ <br>    // Is this a valid filename supplied <br> <br>    CheckPointer(pszFileName,E_POINTER); <br>    if(wcslen(pszFileName) &gt; MAX_PATH) <br>        return ERROR_FILENAME_EXCED_RANGE; <br> <br>    // Take a copy of the filename <br> <br>    m_pFileName = new WCHAR[1+lstrlenW(pszFileName)]; <br>    if (m_pFileName == 0) <br>        return E_OUTOFMEMORY; <br>    lstrcpyW(m_pFileName,pszFileName); <br> <br>    // Create the file then close it <br> <br>    HRESULT hr = OpenFile(); <br>    CloseFile(); <br>    return hr; <br> <br>} // SetFileName <br> <br> <br>// <br>// GetCurFile <br>// <br>// Implemented for IFileSinkFilter support <br>// <br>STDMETHODIMP CDump::GetCurFile(LPOLESTR * ppszFileName,AM_MEDIA_TYPE *pmt) <br>{ <br>    CheckPointer(ppszFileName, E_POINTER); <br>    *ppszFileName = NULL; <br>    if (m_pFileName != NULL) { <br>        *ppszFileName = (LPOLESTR) <br>        QzTaskMemAlloc(sizeof(WCHAR) * (1+lstrlenW(m_pFileName))); <br>        if (*ppszFileName != NULL) { <br>            lstrcpyW(*ppszFileName, m_pFileName); <br>        } <br>    } <br> <br>    if(pmt) { <br>        ZeroMemory(pmt, sizeof(*pmt)); <br>        pmt-&gt;majortype = MEDIATYPE_NULL; <br>        pmt-&gt;subtype = MEDIASUBTYPE_NULL; <br>    } <br>    return S_OK; <br> <br>} // GetCurFile <br> <br> <br>// Destructor <br> <br>CDump::~CDump() <br>{ <br>    CloseFile(); <br>    delete m_pPin; <br>    delete m_pFilter; <br>    delete m_pPosition; <br>    delete m_pFileName; <br>} <br> <br> <br>// <br>// CreateInstance <br>// <br>// Provide the way for COM to create a dump filter <br>// <br>CUnknown * WINAPI CDump::CreateInstance(LPUNKNOWN punk, HRESULT *phr) <br>{ <br>    CDump *pNewObject = new CDump(punk, phr); <br>    if (pNewObject == NULL) { <br>        *phr = E_OUTOFMEMORY; <br>    } <br>    return pNewObject; <br> <br>} // CreateInstance <br> <br> <br>// <br>// NonDelegatingQueryInterface <br>// <br>// Override this to say what interfaces we support where <br>// <br>STDMETHODIMP CDump::NonDelegatingQueryInterface(REFIID riid, void ** ppv) <br>{ <br>    CheckPointer(ppv,E_POINTER); <br>    CAutoLock lock(&amp;m_Lock); <br> <br>    // Do we have this interface <br> <br>    if (riid == IID_IFileSinkFilter) { <br>        return GetInterface((IFileSinkFilter *) this, ppv); <br>    } else if (riid == IID_IBaseFilter || riid == IID_IMediaFilter || riid == IID_IPersist) { <br>return m_pFilter-&gt;NonDelegatingQueryInterface(riid, ppv); <br>    } else if (riid == IID_IMediaPosition || riid == IID_IMediaSeeking) { <br>        if (m_pPosition == NULL) { <br> <br>            HRESULT hr = S_OK; <br>            m_pPosition = new CPosPassThru(NAME("Dump Pass Through"), <br>                                           (IUnknown *) GetOwner(), <br>                                           (HRESULT *) &amp;hr, m_pPin); <br>            if (m_pPosition == NULL) { <br>                return E_OUTOFMEMORY; <br>            } <br> <br>            if (FAILED(hr)) { <br>                delete m_pPosition; <br>                m_pPosition = NULL; <br>                return hr; <br>            } <br>        } <br>        return m_pPosition-&gt;NonDelegatingQueryInterface(riid, ppv); <br>    } else { <br>return CUnknown::NonDelegatingQueryInterface(riid, ppv); <br>    } <br> <br>} // NonDelegatingQueryInterface <br> <br> <br>// <br>// OpenFile <br>// <br>// Opens the file ready for dumping <br>// <br>HRESULT CDump::OpenFile() <br>{ <br>    TCHAR *pFileName = NULL; <br> <br>    // Is the file already opened <br>    if (m_hFile != INVALID_HANDLE_VALUE) { <br>        return NOERROR; <br>    } <br> <br>    // Has a filename been set yet <br>    if (m_pFileName == NULL) { <br>        return ERROR_INVALID_NAME; <br>    } <br> <br>    // Convert the UNICODE filename if necessary <br> <br>#if defined(WIN32) &amp;&amp; !defined(UNICODE) <br>    char convert[MAX_PATH]; <br>    if(!WideCharToMultiByte(CP_ACP,0,m_pFileName,-1,convert,MAX_PATH,0,0)) <br>        return ERROR_INVALID_NAME; <br>    pFileName = convert; <br>#else <br>    pFileName = m_pFileName; <br>#endif <br> <br>    // Try to open the file <br> <br>    m_hFile = CreateFile((LPCTSTR) pFileName,   // The filename <br>                         GENERIC_WRITE,         // File access <br>                         (DWORD) 0,             // Share access <br>                         NULL,                  // Security <br>                         CREATE_ALWAYS,         // Open flags <br>                         (DWORD) 0,             // More flags <br>                         NULL);                 // Template <br> <br>    if (m_hFile == INVALID_HANDLE_VALUE) { <br>        DWORD dwErr = GetLastError(); <br>        return HRESULT_FROM_WIN32(dwErr); <br>    } <br>    return S_OK; <br> <br>} // Open <br> <br> <br>// <br>// CloseFile <br>// <br>// Closes any dump file we have opened <br>// <br>HRESULT CDump::CloseFile() <br>{ <br>    if (m_hFile == INVALID_HANDLE_VALUE) { <br>        return NOERROR; <br>    } <br> <br>    CloseHandle(m_hFile); <br>    m_hFile = INVALID_HANDLE_VALUE; <br>    return NOERROR; <br> <br>} // Open <br> <br> <br>// <br>// Write <br>// <br>// Write stuff to the file <br>// <br>HRESULT CDump::Write(PBYTE pbData,LONG lData) <br>{ <br>    DWORD dwWritten; <br> <br>    if (!WriteFile(m_hFile,(PVOID)pbData,(DWORD)lData,&amp;dwWritten,NULL)) { <br>        DWORD dwErr = GetLastError(); <br>        return HRESULT_FROM_WIN32(dwErr); <br>    } <br>    return S_OK; <br>} <br> <br> <br>// <br>// WriteString <br>// <br>// Writes the given string into the file <br>// <br>void CDump::WriteString(TCHAR *pString) <br>{ <br>    DWORD dwWritten = lstrlen(pString); <br>    const TCHAR *pEndOfLine = "\r\n"; <br> <br>    WriteFile((HANDLE) m_hFile, <br>              (PVOID) pString, <br>              (DWORD) dwWritten, <br>              &amp;dwWritten, NULL); <br> <br>    dwWritten = lstrlen(pEndOfLine); <br>    WriteFile((HANDLE) m_hFile, <br>              (PVOID) pEndOfLine, <br>              (DWORD) dwWritten, <br>              &amp;dwWritten, NULL); <br> <br>} // WriteString <br> <br> <br>// <br>// DllRegisterSever <br>// <br>// Handle the registration of this filter <br>// <br>STDAPI DllRegisterServer() <br>{ <br>    return AMovieDllRegisterServer2( TRUE ); <br> <br>} // DllRegisterServer <br> <br> <br>// <br>// DllUnregisterServer <br>// <br>STDAPI DllUnregisterServer() <br>{ <br>    return AMovieDllRegisterServer2( FALSE ); <br> <br>} // DllUnregisterServer </code></pre>
<p>&nbsp;</p></body>
</HTML>
