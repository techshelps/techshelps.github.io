<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>INFTEE.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2828"></a>INFTEE.CPP</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>#include &lt;streams.h&gt; <br>#include &lt;initguid.h&gt; <br>#include &lt;inftee.h&gt; <br>#include &lt;tchar.h&gt; <br>#include &lt;stdio.h&gt; <br> <br>// <br>// <br>// What this sample illustrates <br>// <br>// A pass through filter splits a data stream into many output channels <br>// <br>// Summary <br>// <br>// This is a sample ActiveMovie pass through filter. We have a single input <br>// pin and can have many output pins. We start with one output pin and each <br>// time we connect an output pin we spawn another, although we could keep <br>// doing this ad infinitum we have a top level maximum of INFTEE_MAX_PINS. <br>// Any data samples our input pin receives will be sent down each output <br>// pin in turn. Each output pin has a separate thread if necessary (see <br>// the output queue class in the SDK) to avoid delivery blocking our thread <br>// <br>// Demonstration instructions <br>// <br>// Start GRAPHEDT available in the ActiveMovie SDK tools. Drag and drop any <br>// MPEG, AVI or MOV file into the tool and it will be rendered. Then go to <br>// the filters in the graph and find the filter (box) titled "Video Renderer" <br>// Then click on the box and hit DELETE. After that go to the Graph menu and <br>// select "Insert Filters", from the dialog box find and select the "Infinite <br>// Tee Filter" and then dismiss the dialog. Back in the graph layout find the <br>// output pin of the filter that was connected to the input of the video <br>// renderer you just deleted, right click and select "Render". You should <br>// see it being connected to the input pin of the filter you just inserted <br>// <br>// The infinite tee filter will have one output pin connected and will have <br>// spawned another, right click on this and select Render. A new renderer <br>// will pop up fo the stream. Do this once or twice more and then click on <br>// the Pause and Run on the GRAPHEDT frame and you will see the video... <br>//      .. many times over in different windows <br>// <br>// Files <br>// <br>// inftee.cpp           Main implementation of the infinite tee <br>// inftee.def           What APIs the DLL will import and export <br>// inftee.h             Class definition of the infinite tee <br>// inftee.rc            Not much, just our version information <br>// inftee.reg           What goes in the registry to make us work <br>// makefile             How to build it... <br>// <br>// <br>// Base classes used <br>// <br>// CBaseInputPin        Basic IMemInputPin based input pin <br>// CBaseOutputPin       Used for basic connection stuff <br>// CBaseFilter          Well we need a filter don't we <br>// CCritSec             Controls access to output pin list <br>// COutputQueue         Delivers data on a separate thread <br>// <br>// <br> <br>#define INFTEE_MAX_PINS 1000 <br> <br>// Using this pointer in constructor <br>#pragma warning(disable:4355) <br> <br>// Setup data <br> <br>const AMOVIESETUP_MEDIATYPE sudPinTypes = <br>{ <br>    &amp;MEDIATYPE_NULL,         // Major CLSID <br>    &amp;MEDIASUBTYPE_NULL       // Minor type <br>}; <br> <br>const AMOVIESETUP_PIN psudPins[] = <br>{ <br>    { L"Input",             // Pin's string name <br>      FALSE,                // Is it rendered <br>      FALSE,                // Is it an output <br>      FALSE,                // Allowed none <br>      FALSE,                // Allowed many <br>      &amp;CLSID_NULL,          // Connects to filter <br>      L"Output",            // Connects to pin <br>      1,                    // Number of types <br>      &amp;sudPinTypes },       // Pin information <br>    { L"Output",            // Pin's string name <br>      FALSE,                // Is it rendered <br>      TRUE,                 // Is it an output <br>      FALSE,                // Allowed none <br>      FALSE,                // Allowed many <br>      &amp;CLSID_NULL,          // Connects to filter <br>      L"Input",             // Connects to pin <br>      1,                    // Number of types <br>      &amp;sudPinTypes }        // Pin information <br>}; <br> <br>const AMOVIESETUP_FILTER sudInfTee = <br>{ <br>    &amp;CLSID_Tee,             // CLSID of filter <br>    L"Infinite Pin Tee",    // Filter's name <br>    MERIT_DO_NOT_USE,       // Filter merit <br>    2,                      // Number of pins <br>    psudPins                // Pin information <br>}; <br> <br> <br>CFactoryTemplate g_Templates [1] = { <br>    { L"Infinite Pin Tee" <br>    , &amp;CLSID_Tee <br>    , CTee::CreateInstance <br>    , NULL <br>    , &amp;sudInfTee } <br>}; <br>int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]); <br> <br> <br>// <br>// CreateInstance <br>// <br>// Creator function for the class ID <br>// <br>CUnknown * WINAPI CTee::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr) <br>{ <br>    return new CTee(NAME("Infinite Tee Filter"), pUnk, phr); <br>} <br> <br> <br>// <br>// Constructor <br>// <br>CTee::CTee(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr) : <br>    m_OutputPinsList(NAME("Tee Output Pins list")), <br>    m_lCanSeek(TRUE), <br>    m_pAllocator(NULL), <br>    m_NumOutputPins(0), <br>    m_NextOutputPinNumber(0), <br>    m_Input(NAME("Input Pin"), this, phr, L"Input"), <br>    CBaseFilter(NAME("Tee filter"), pUnk, this, CLSID_Tee) <br>{ <br>    ASSERT(phr); <br> <br>    // Create a single output pin at this time <br>    InitOutputPinsList(); <br> <br>    CTeeOutputPin *pOutputPin = CreateNextOutputPin(this); <br> <br>    if (pOutputPin != NULL ) <br>    { <br>        m_NumOutputPins++; <br>        m_OutputPinsList.AddTail(pOutputPin); <br>    } <br>} <br> <br> <br>// <br>// Destructor <br>// <br>CTee::~CTee() <br>{ <br>    InitOutputPinsList(); <br>} <br> <br> <br>// <br>// GetPinCount <br>// <br>int CTee::GetPinCount() <br>{ <br>    return (1 + m_NumOutputPins); <br>} <br> <br> <br>// <br>// GetPin <br>// <br>CBasePin *CTee::GetPin(int n) <br>{ <br>    if (n &lt; 0) <br>        return NULL ; <br> <br>    // Pin zero is the one and only input pin <br>    if (n == 0) <br>        return &amp;m_Input; <br> <br>    // return the output pin at position(n - 1) (zero based) <br>    return GetPinNFromList(n - 1); <br>} <br> <br> <br>// <br>// InitOutputPinsList <br>// <br>void CTee::InitOutputPinsList() <br>{ <br>    POSITION pos = m_OutputPinsList.GetHeadPosition(); <br>    while(pos) <br>    { <br>        CTeeOutputPin *pOutputPin = m_OutputPinsList.GetNext(pos); <br>        ASSERT(pOutputPin-&gt;m_pOutputQueue == NULL); <br>        pOutputPin-&gt;Release(); <br>    } <br>    m_NumOutputPins = 0; <br>    m_OutputPinsList.RemoveAll(); <br> <br>} // InitOutputPinsList <br> <br> <br>// <br>// CreateNextOutputPin <br>// <br>CTeeOutputPin *CTee::CreateNextOutputPin(CTee *pTee) <br>{ <br>    WCHAR szbuf[20];             // Temporary scratch buffer <br>    m_NextOutputPinNumber++;     // Next number to use for pin <br>    HRESULT hr = NOERROR; <br> <br>    swprintf(szbuf, L"Output%d", m_NextOutputPinNumber); <br> <br>    CTeeOutputPin *pPin = new CTeeOutputPin(NAME("Tee Output"), pTee, <br>    &amp;hr, szbuf, <br>    m_NextOutputPinNumber); <br> <br>    if (FAILED(hr) || pPin == NULL) { <br>        delete pPin; <br>        return NULL; <br>    } <br> <br>    pPin-&gt;AddRef(); <br>    return pPin; <br> <br>} // CreateNextOutputPin <br> <br> <br>// <br>// DeleteOutputPin <br>// <br>void CTee::DeleteOutputPin(CTeeOutputPin *pPin) <br>{ <br>    POSITION pos = m_OutputPinsList.GetHeadPosition(); <br>    while(pos) { <br>        POSITION posold = pos;         // Remember this position <br>        CTeeOutputPin *pOutputPin = m_OutputPinsList.GetNext(pos); <br>        if (pOutputPin == pPin) { <br>            // If this pin holds the seek interface release it <br>            if (pPin-&gt;m_bHoldsSeek) { <br>                InterlockedExchange(&amp;m_lCanSeek, FALSE); <br>                pPin-&gt;m_bHoldsSeek = FALSE; <br>                pPin-&gt;m_pPosition-&gt;Release(); <br>            } <br> <br>            m_OutputPinsList.Remove(posold); <br>            ASSERT(pOutputPin-&gt;m_pOutputQueue == NULL); <br>            delete pPin; <br>            m_NumOutputPins--; <br>    IncrementPinVersion(); <br>            break; <br>        } <br>    } <br> <br>} // DeleteOutputPin <br> <br> <br>// <br>// GetNumFreePins <br>// <br>int CTee::GetNumFreePins() <br>{ <br>    int n = 0; <br>    POSITION pos = m_OutputPinsList.GetHeadPosition(); <br>    while(pos) { <br>        CTeeOutputPin *pOutputPin = m_OutputPinsList.GetNext(pos); <br>        if (pOutputPin-&gt;m_Connected == NULL) <br>            n++; <br>    } <br>    return n; <br> <br>} // GetNumFreePins <br> <br> <br>// <br>// GetPinNFromList <br>// <br>CTeeOutputPin *CTee::GetPinNFromList(int n) <br>{ <br>    // Validate the position being asked for <br>    if (n &gt;= m_NumOutputPins) <br>        return NULL; <br> <br>    // Get the head of the list <br>    POSITION pos = m_OutputPinsList.GetHeadPosition(); <br> <br>    n++;       // Make the number 1 based <br> <br>    CTeeOutputPin *pOutputPin; <br>    while(n) { <br>        pOutputPin = m_OutputPinsList.GetNext(pos); <br>        n--; <br>    } <br>    return pOutputPin; <br> <br>} // GetPinNFromList <br> <br> <br>// <br>// Stop <br>// <br>// Overriden to handle no input connections <br>// <br>STDMETHODIMP CTee::Stop() <br>{ <br>    CBaseFilter::Stop(); <br>    m_State = State_Stopped; <br>    return NOERROR; <br>} <br> <br> <br>// <br>// Pause <br>// <br>// Overriden to handle no input connections <br>// <br>STDMETHODIMP CTee::Pause() <br>{ <br>    CAutoLock cObjectLock(m_pLock); <br>    HRESULT hr = CBaseFilter::Pause(); <br>    if (m_Input.IsConnected() == FALSE) { <br>        m_Input.EndOfStream(); <br>    } <br>    return hr; <br>} <br> <br> <br>// <br>// Run <br>// <br>// Overriden to handle no input connections <br>// <br>STDMETHODIMP CTee::Run(REFERENCE_TIME tStart) <br>{ <br>    CAutoLock cObjectLock(m_pLock); <br>    HRESULT hr = CBaseFilter::Run(tStart); <br>    if (m_Input.IsConnected() == FALSE) { <br>        m_Input.EndOfStream(); <br>    } <br>    return hr; <br>} <br> <br>// <br>// CTeeInputPin constructor <br>// <br>CTeeInputPin::CTeeInputPin(TCHAR *pName, <br>                           CTee *pTee, <br>                           HRESULT *phr, <br>                           LPCWSTR pPinName) : <br>    CBaseInputPin(pName, pTee, pTee, phr, pPinName), <br>    m_pTee(pTee), <br>    m_bInsideCheckMediaType(FALSE) <br>{ <br>    ASSERT(pTee); <br>} <br> <br> <br>#ifdef DEBUG <br>// <br>// CTeeInputPin destructor <br>// <br>CTeeInputPin::~CTeeInputPin() <br>{ <br>    DbgLog((LOG_TRACE,2,TEXT("CTeeInputPin destructor"))); <br>    ASSERT(m_pTee-&gt;m_pAllocator == NULL); <br>} <br>#endif <br> <br> <br>#ifdef DEBUG <br>// <br>// DisplayMediaType -- (DEBUG ONLY) <br>// <br>void DisplayMediaType(TCHAR *pDescription,const CMediaType *pmt) <br>{ <br> <br>    // Dump the GUID types and a short description <br> <br>    DbgLog((LOG_TRACE,2,TEXT(""))); <br>    DbgLog((LOG_TRACE,2,TEXT("%s"),pDescription)); <br>    DbgLog((LOG_TRACE,2,TEXT(""))); <br>    DbgLog((LOG_TRACE,2,TEXT("Media Type Description"))); <br>    DbgLog((LOG_TRACE,2,TEXT("Major type %s"),GuidNames[*pmt-&gt;Type()])); <br>    DbgLog((LOG_TRACE,2,TEXT("Subtype %s"),GuidNames[*pmt-&gt;Subtype()])); <br>    DbgLog((LOG_TRACE,2,TEXT("Subtype description %s"),GetSubtypeName(pmt-&gt;Subtype()))); <br>    DbgLog((LOG_TRACE,2,TEXT("Format size %d"),pmt-&gt;cbFormat)); <br> <br>    // Dump the generic media types */ <br> <br>    DbgLog((LOG_TRACE,2,TEXT("Fixed size sample %d"),pmt-&gt;IsFixedSize())); <br>    DbgLog((LOG_TRACE,2,TEXT("Temporal compression %d"),pmt-&gt;IsTemporalCompressed())); <br>    DbgLog((LOG_TRACE,2,TEXT("Sample size %d"),pmt-&gt;GetSampleSize())); <br> <br> <br>} // DisplayMediaType <br>#endif <br> <br> <br>// <br>// CheckMediaType <br>// <br>HRESULT CTeeInputPin::CheckMediaType(const CMediaType *pmt) <br>{ <br>    CAutoLock lock_it(m_pLock); <br> <br>    // If we are already inside checkmedia type for this pin, return NOERROR <br>    // It is possble to hookup two of the tee filters and some other filter <br>    // like the video effects sample to get into this situation. If we don't <br>    // detect this situation, we will carry on looping till we blow the stack <br> <br>    if (m_bInsideCheckMediaType == TRUE) <br>        return NOERROR; <br> <br>    m_bInsideCheckMediaType = TRUE; <br>    HRESULT hr = NOERROR; <br> <br>#ifdef DEBUG <br>    // Display the type of the media for debugging perposes <br>    DisplayMediaType(TEXT("Input Pin Checking"), pmt); <br>#endif <br> <br>    // The media types that we can support are entirely dependent on the <br>    // downstream connections. If we have downstream connections, we should <br>    // check with them - walk through the list calling each output pin <br> <br>    int n = m_pTee-&gt;m_NumOutputPins; <br>    POSITION pos = m_pTee-&gt;m_OutputPinsList.GetHeadPosition(); <br> <br>    while(n) { <br>        CTeeOutputPin *pOutputPin = m_pTee-&gt;m_OutputPinsList.GetNext(pos); <br>        if (pOutputPin != NULL) { <br>            if (pOutputPin-&gt;m_Connected != NULL) { <br>                // The pin is connected, check its peer <br>                hr = pOutputPin-&gt;m_Connected-&gt;QueryAccept(pmt); <br>                if (hr != NOERROR) { <br>                    m_bInsideCheckMediaType = FALSE; <br>                    return VFW_E_TYPE_NOT_ACCEPTED; <br>                } <br>            } <br>        } else { <br>            // We should have as many pins as the count says we have <br>            ASSERT(FALSE); <br>        } <br>        n--; <br>    } <br> <br>    // Either all the downstream pins have accepted or there are none. <br>    m_bInsideCheckMediaType = FALSE; <br>    return NOERROR; <br> <br>} // CheckMediaType <br> <br> <br>// <br>// SetMediaType <br>// <br>HRESULT CTeeInputPin::SetMediaType(const CMediaType *pmt) <br>{ <br>    CAutoLock lock_it(m_pLock); <br>    HRESULT hr = NOERROR; <br> <br>    // Make sure that the base class likes it <br>    hr = CBaseInputPin::SetMediaType(pmt); <br>    if (FAILED(hr)) <br>        return hr; <br> <br>    ASSERT(m_Connected != NULL); <br>    return NOERROR; <br> <br>} // SetMediaType <br> <br> <br>// <br>// BreakConnect <br>// <br>HRESULT CTeeInputPin::BreakConnect() <br>{ <br>    // Release any allocator that we are holding <br>    if (m_pTee-&gt;m_pAllocator) <br>    { <br>        m_pTee-&gt;m_pAllocator-&gt;Release(); <br>        m_pTee-&gt;m_pAllocator = NULL; <br>    } <br>    return NOERROR; <br> <br>} // BreakConnect <br> <br> <br>// <br>// NotifyAllocator <br>// <br>STDMETHODIMP <br>CTeeInputPin::NotifyAllocator(IMemAllocator *pAllocator, BOOL bReadOnly) <br>{ <br>    CAutoLock lock_it(m_pLock); <br>    if (pAllocator == NULL) <br>        return E_FAIL; <br> <br>    // Free the old allocator if any <br>    if (m_pTee-&gt;m_pAllocator) <br>        m_pTee-&gt;m_pAllocator-&gt;Release(); <br> <br>    // Store away the new allocator <br>    pAllocator-&gt;AddRef(); <br>    m_pTee-&gt;m_pAllocator = pAllocator; <br> <br>    // Notify the base class about the allocator <br>    return CBaseInputPin::NotifyAllocator(pAllocator,bReadOnly); <br> <br>} // NotifyAllocator <br> <br> <br>// <br>// EndOfStream <br>// <br>HRESULT CTeeInputPin::EndOfStream() <br>{ <br>    CAutoLock lock_it(m_pLock); <br>    ASSERT(m_pTee-&gt;m_NumOutputPins); <br>    HRESULT hr = NOERROR; <br> <br>    // Walk through the output pins list, sending the message downstream <br> <br>    int n = m_pTee-&gt;m_NumOutputPins; <br>    POSITION pos = m_pTee-&gt;m_OutputPinsList.GetHeadPosition(); <br>    while(n) { <br>        CTeeOutputPin *pOutputPin = m_pTee-&gt;m_OutputPinsList.GetNext(pos); <br>        if (pOutputPin != NULL) { <br>            hr = pOutputPin-&gt;DeliverEndOfStream(); <br>            if (FAILED(hr)) <br>                return hr; <br>        } else { <br>            // We should have as many pins as the count says we have <br>            ASSERT(FALSE); <br>        } <br>        n--; <br>    } <br>    return(NOERROR); <br> <br>} // EndOfStream <br> <br> <br>// <br>// BeginFlush <br>// <br>HRESULT CTeeInputPin::BeginFlush() <br>{ <br>    CAutoLock lock_it(m_pLock); <br>    ASSERT(m_pTee-&gt;m_NumOutputPins); <br>    HRESULT hr = NOERROR; <br> <br>    // Walk through the output pins list, sending the message downstream <br> <br>    int n = m_pTee-&gt;m_NumOutputPins; <br>    POSITION pos = m_pTee-&gt;m_OutputPinsList.GetHeadPosition(); <br>    while(n) { <br>        CTeeOutputPin *pOutputPin = m_pTee-&gt;m_OutputPinsList.GetNext(pos); <br>        if (pOutputPin != NULL) { <br>            hr = pOutputPin-&gt;DeliverBeginFlush(); <br>            if (FAILED(hr)) <br>                return hr; <br>        } else { <br>            // We should have as many pins as the count says we have <br>            ASSERT(FALSE); <br>        } <br>        n--; <br>    } <br>    return CBaseInputPin::BeginFlush(); <br> <br>} // BeginFlush <br> <br> <br>// <br>// EndFlush <br>// <br>HRESULT CTeeInputPin::EndFlush() <br>{ <br>    CAutoLock lock_it(m_pLock); <br>    ASSERT(m_pTee-&gt;m_NumOutputPins); <br>    HRESULT hr = NOERROR; <br> <br>    // Walk through the output pins list, sending the message downstream <br> <br>    int n = m_pTee-&gt;m_NumOutputPins; <br>    POSITION pos = m_pTee-&gt;m_OutputPinsList.GetHeadPosition(); <br>    while(n) { <br>        CTeeOutputPin *pOutputPin = m_pTee-&gt;m_OutputPinsList.GetNext(pos); <br>        if (pOutputPin != NULL) { <br>            hr = pOutputPin-&gt;DeliverEndFlush(); <br>            if (FAILED(hr)) <br>                return hr; <br>        } else { <br>            // We should have as many pins as the count says we have <br>            ASSERT(FALSE); <br>        } <br>        n--; <br>    } <br>    return CBaseInputPin::EndFlush(); <br> <br>} // EndFlush <br> <br>// <br>// NewSegment <br>// <br>                     <br>HRESULT CTeeInputPin::NewSegment(REFERENCE_TIME tStart, <br>                                 REFERENCE_TIME tStop, <br>                                 double dRate) <br>{ <br>    CAutoLock lock_it(m_pLock); <br>    ASSERT(m_pTee-&gt;m_NumOutputPins); <br>    HRESULT hr = NOERROR; <br> <br>    // Walk through the output pins list, sending the message downstream <br> <br>    int n = m_pTee-&gt;m_NumOutputPins; <br>    POSITION pos = m_pTee-&gt;m_OutputPinsList.GetHeadPosition(); <br>    while(n) { <br>        CTeeOutputPin *pOutputPin = m_pTee-&gt;m_OutputPinsList.GetNext(pos); <br>        if (pOutputPin != NULL) { <br>            hr = pOutputPin-&gt;DeliverNewSegment(tStart, tStop, dRate); <br>            if (FAILED(hr)) <br>                return hr; <br>        } else { <br>            // We should have as many pins as the count says we have <br>            ASSERT(FALSE); <br>        } <br>        n--; <br>    } <br>    return CBaseInputPin::NewSegment(tStart, tStop, dRate); <br> <br>} // NewSegment <br> <br> <br>// <br>// Receive <br>// <br>HRESULT CTeeInputPin::Receive(IMediaSample *pSample) <br>{ <br>    CAutoLock lock_it(m_pLock); <br> <br>    // Check that all is well with the base class <br>    HRESULT hr = NOERROR; <br>    hr = CBaseInputPin::Receive(pSample); <br>    if (hr != NOERROR) <br>        return hr; <br> <br>    // Walk through the output pins list, delivering to each in turn <br> <br>    int n = m_pTee-&gt;m_NumOutputPins; <br>    POSITION pos = m_pTee-&gt;m_OutputPinsList.GetHeadPosition(); <br>    while(n) { <br>        CTeeOutputPin *pOutputPin = m_pTee-&gt;m_OutputPinsList.GetNext(pos); <br>        if (pOutputPin != NULL) { <br>            hr = pOutputPin-&gt;Deliver(pSample); <br>            if (hr != NOERROR) <br>                return hr; <br>        } else { <br>            // We should have as many pins as the count says we have <br>            ASSERT(FALSE); <br>        } <br>        n--; <br>    } <br>    return NOERROR; <br> <br>} // Receive <br> <br> <br>// <br>// Completed a connection to a pin <br>// <br>HRESULT CTeeInputPin::CompleteConnect(IPin *pReceivePin) <br>{ <br>    HRESULT hr = CBaseInputPin::CompleteConnect(pReceivePin); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br> <br>    // Force any output pins to use our type <br> <br>    int n = m_pTee-&gt;m_NumOutputPins; <br>    POSITION pos = m_pTee-&gt;m_OutputPinsList.GetHeadPosition(); <br> <br>    while(n) { <br>        CTeeOutputPin *pOutputPin = m_pTee-&gt;m_OutputPinsList.GetNext(pos); <br>        if (pOutputPin != NULL) { <br>            // Check with downstream pin <br>            if (pOutputPin-&gt;m_Connected != NULL) { <br>                if (m_mt != pOutputPin-&gt;m_mt) <br>                    m_pTee-&gt;ReconnectPin(pOutputPin, &amp;m_mt); <br>            } <br>        } else { <br>            // We should have as many pins as the count says we have <br>            ASSERT(FALSE); <br>        } <br>        n--; <br>    } <br>    return S_OK; <br>} <br> <br> <br>// <br>// CTeeOutputPin constructor <br>// <br>CTeeOutputPin::CTeeOutputPin(TCHAR *pName, <br>                             CTee *pTee, <br>                             HRESULT *phr, <br>                             LPCWSTR pPinName, <br>                             int PinNumber) : <br>    CBaseOutputPin(pName, pTee, pTee, phr, pPinName) , <br>    m_pOutputQueue(NULL), <br>    m_bHoldsSeek(FALSE), <br>    m_pPosition(NULL), <br>    m_pTee(pTee), <br>    m_cOurRef(0), <br>    m_bInsideCheckMediaType(FALSE) <br>{ <br>    ASSERT(pTee); <br>} <br> <br> <br> <br>#ifdef DEBUG <br>// <br>// CTeeOutputPin destructor <br>// <br>CTeeOutputPin::~CTeeOutputPin() <br>{ <br>    ASSERT(m_pOutputQueue == NULL); <br>} <br>#endif <br> <br> <br>// <br>// NonDelegatingQueryInterface <br>// <br>// This function is overwritten to expose IMediaPosition and IMediaSelection <br>// Note that only one output stream can be allowed to expose this to avoid <br>// conflicts, the other pins will just return E_NOINTERFACE and therefore <br>// appear as non seekable streams. We have a LONG value that if exchanged to <br>// produce a TRUE means that we have the honor. If it exchanges to FALSE then <br>// someone is already in. If we do get it and error occurs then we reset it <br>// to TRUE so someone else can get it. <br>// <br>STDMETHODIMP <br>CTeeOutputPin::NonDelegatingQueryInterface(REFIID riid, void **ppv) <br>{ <br>    CheckPointer(ppv,E_POINTER); <br>    ASSERT(ppv); <br>    *ppv = NULL; <br>    HRESULT hr = NOERROR; <br> <br>    // See what interface the caller is interested in. <br>    if (riid == IID_IMediaPosition || riid == IID_IMediaSeeking) { <br>        if (m_pPosition) { <br>            if (m_bHoldsSeek == FALSE) <br>                return E_NOINTERFACE; <br>            return m_pPosition-&gt;QueryInterface(riid, ppv); <br>        } <br>    } else <br>        return CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv); <br> <br>    CAutoLock lock_it(m_pLock); <br>    ASSERT(m_pPosition == NULL); <br>    IUnknown *pMediaPosition = NULL; <br> <br>    // Try to create a seeking implementation <br>    if (InterlockedExchange(&amp;m_pTee-&gt;m_lCanSeek, FALSE) == FALSE) <br>        return E_NOINTERFACE; <br> <br>    // Create implementation of this dynamically as sometimes we may never <br>    // try and seek. The helper object implements IMediaPosition and also <br>    // the IMediaSelection control interface and simply takes the calls <br>    // normally from the downstream filter and passes them upstream <br> <br> <br>    hr = CreatePosPassThru( <br>                   GetOwner(), <br>                   FALSE, <br>                   (IPin *)&amp;m_pTee-&gt;m_Input, <br>                   &amp;pMediaPosition); <br> <br>    if (pMediaPosition == NULL) { <br>        InterlockedExchange(&amp;m_pTee-&gt;m_lCanSeek, TRUE); <br>        return E_OUTOFMEMORY; <br>    } <br> <br>    if (FAILED(hr)) { <br>        InterlockedExchange(&amp;m_pTee-&gt;m_lCanSeek, TRUE); <br>        pMediaPosition-&gt;Release (); <br>        return hr; <br>    } <br> <br>    m_pPosition = pMediaPosition; <br>    m_bHoldsSeek = TRUE; <br>    return NonDelegatingQueryInterface(riid, ppv); <br> <br>} // NonDelegatingQueryInterface <br> <br> <br>// <br>// NonDelegatingAddRef <br>// <br>// We need override this method so that we can do proper reference counting <br>// on our output pin. The base class CBasePin does not do any reference <br>// counting on the pin in RETAIL. <br>// <br>// Please refer to the comments for the NonDelegatingRelease method for more <br>// info on why we need to do this. <br>// <br>STDMETHODIMP_(ULONG) CTeeOutputPin::NonDelegatingAddRef() <br>{ <br>    CAutoLock lock_it(m_pLock); <br> <br>#ifdef DEBUG <br>    // Update the debug only variable maintained by the base class <br>    m_cRef++; <br>    ASSERT(m_cRef &gt; 0); <br>#endif <br> <br>    // Now update our reference count <br>    m_cOurRef++; <br>    ASSERT(m_cOurRef &gt; 0); <br>    return m_cOurRef; <br> <br>} // NonDelegatingAddRef <br> <br> <br>// <br>// NonDelegatingRelease <br>// <br>// CTeeOutputPin overrides this class so that we can take the pin out of our <br>// output pins list and delete it when its reference count drops to 1 and there <br>// is atleast two free pins. <br>// <br>// Note that CreateNextOutputPin holds a reference count on the pin so that <br>// when the count drops to 1, we know that no one else has the pin. <br>// <br>// Moreover, the pin that we are about to delete must be a free pin(or else <br>// the reference would not have dropped to 1, and we must have atleast one <br>// other free pin(as the filter always wants to have one more free pin) <br>// <br>// Also, since CBasePin::NonDelegatingAddRef passes the call to the owning <br>// filter, we will have to call Release on the owning filter as well. <br>// <br>// Also, note that we maintain our own reference count m_cOurRef as the m_cRef <br>// variable maintained by CBasePin is debug only. <br>// <br>STDMETHODIMP_(ULONG) CTeeOutputPin::NonDelegatingRelease() <br>{ <br>    CAutoLock lock_it(m_pLock); <br> <br>#ifdef DEBUG <br>    // Update the debug only variable in CBasePin <br>    m_cRef--; <br>    ASSERT(m_cRef &gt;= 0); <br>#endif <br> <br>    // Now update our reference count <br>    m_cOurRef--; <br>    ASSERT(m_cOurRef &gt;= 0); <br> <br>    // if the reference count on the object has gone to one, remove <br>    // the pin from our output pins list and physically delete it <br>    // provided there are atealst two free pins in the list(including <br>    // this one) <br> <br>    // Also, when the ref count drops to 0, it really means that our <br>    // filter that is holding one ref count has released it so we <br>    // should delete the pin as well. <br> <br>    if (m_cOurRef &lt;= 1) { <br>        int n = 2;                     // default forces pin deletion <br>        if (m_cOurRef == 1) { <br>            // Walk the list of pins, looking for count of free pins <br>            n = m_pTee-&gt;GetNumFreePins(); <br>        } <br> <br>        // If there are two free pins, delete this one. <br>        // NOTE: normall <br>        if (n &gt;= 2 ) { <br>            m_cOurRef = 0; <br>#ifdef DEBUG <br>            m_cRef = 0; <br>#endif <br>            m_pTee-&gt;DeleteOutputPin(this); <br>            return(ULONG) 0; <br>        } <br>    } <br>    return(ULONG) m_cOurRef; <br> <br>} // NonDelegatingRelease <br> <br> <br>// <br>// DecideBufferSize <br>// <br>// This has to be present to override the PURE virtual class base function <br>// <br>HRESULT CTeeOutputPin::DecideBufferSize(IMemAllocator *pMemAllocator, <br>                                        ALLOCATOR_PROPERTIES * ppropInputRequest) <br>{ <br>    return NOERROR; <br> <br>} // DecideBufferSize <br> <br> <br>// <br>// DecideAllocator <br>// <br>HRESULT CTeeOutputPin::DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc) <br>{ <br>    ASSERT(m_pTee-&gt;m_pAllocator != NULL); <br>    *ppAlloc = NULL; <br> <br>    // Tell the pin about our allocator, set by the input pin. <br>    HRESULT hr = NOERROR; <br>    hr = pPin-&gt;NotifyAllocator(m_pTee-&gt;m_pAllocator,TRUE); <br>    if (FAILED(hr)) <br>        return hr; <br> <br>    // Return the allocator <br>    *ppAlloc = m_pTee-&gt;m_pAllocator; <br>    m_pTee-&gt;m_pAllocator-&gt;AddRef(); <br>    return NOERROR; <br> <br>} // DecideAllocator <br> <br> <br>// <br>// CheckMediaType <br>// <br>HRESULT CTeeOutputPin::CheckMediaType(const CMediaType *pmt) <br>{ <br>    CAutoLock lock_it(m_pLock); <br> <br>    // If we are already inside checkmedia type for this pin, return NOERROR <br>    // It is possble to hookup two of the tee filters and some other filter <br>    // like the video effects sample to get into this situation. If we <br>    // do not detect this, we will loop till we blow the stack <br> <br>    if (m_bInsideCheckMediaType == TRUE) <br>        return NOERROR; <br> <br>    m_bInsideCheckMediaType = TRUE; <br>    HRESULT hr = NOERROR; <br> <br>#ifdef DEBUG <br>    // Display the type of the media for debugging purposes <br>    DisplayMediaType(TEXT("Output Pin Checking"), pmt); <br>#endif <br> <br>    // The input needs to have been conneced first <br>    if (m_pTee-&gt;m_Input.m_Connected == NULL) { <br>        m_bInsideCheckMediaType = FALSE; <br>        return VFW_E_NOT_CONNECTED; <br>    } <br> <br>    // Make sure that our input pin peer is happy with this <br>    hr = m_pTee-&gt;m_Input.m_Connected-&gt;QueryAccept(pmt); <br>    if (hr != NOERROR) { <br>        m_bInsideCheckMediaType = FALSE; <br>        return VFW_E_TYPE_NOT_ACCEPTED; <br>    } <br> <br>    // Check the format with the other outpin pins <br> <br>    int n = m_pTee-&gt;m_NumOutputPins; <br>    POSITION pos = m_pTee-&gt;m_OutputPinsList.GetHeadPosition(); <br> <br>    while(n) { <br>        CTeeOutputPin *pOutputPin = m_pTee-&gt;m_OutputPinsList.GetNext(pos); <br>        if (pOutputPin != NULL &amp;&amp; pOutputPin != this) { <br>            if (pOutputPin-&gt;m_Connected != NULL) { <br>                // The pin is connected, check its peer <br>                hr = pOutputPin-&gt;m_Connected-&gt;QueryAccept(pmt); <br>                if (hr != NOERROR) { <br>                    m_bInsideCheckMediaType = FALSE; <br>                    return VFW_E_TYPE_NOT_ACCEPTED; <br>                } <br>            } <br>        } <br>        n--; <br>    } <br>    m_bInsideCheckMediaType = FALSE; <br>    return NOERROR; <br> <br>} // CheckMediaType <br> <br> <br>// <br>// EnumMediaTypes <br>// <br>STDMETHODIMP CTeeOutputPin::EnumMediaTypes(IEnumMediaTypes **ppEnum) <br>{ <br>    CAutoLock lock_it(m_pLock); <br>    ASSERT(ppEnum); <br> <br>    // Make sure that we are connected <br>    if (m_pTee-&gt;m_Input.m_Connected == NULL) <br>        return VFW_E_NOT_CONNECTED; <br> <br>    // We will simply return the enumerator of our input pin's peer <br>    return m_pTee-&gt;m_Input.m_Connected-&gt;EnumMediaTypes(ppEnum); <br> <br>} // EnumMediaTypes <br> <br> <br>// <br>// SetMediaType <br>// <br>HRESULT CTeeOutputPin::SetMediaType(const CMediaType *pmt) <br>{ <br>    CAutoLock lock_it(m_pLock); <br> <br>#ifdef DEBUG <br>    // Display the format of the media for debugging purposes <br>    DisplayMediaType(TEXT("Output pin type agreed"), pmt); <br>#endif <br> <br>    // Make sure that we have an input connected <br>    if (m_pTee-&gt;m_Input.m_Connected == NULL) <br>        return VFW_E_NOT_CONNECTED; <br> <br>    // Make sure that the base class likes it <br>    HRESULT hr = NOERROR; <br>    hr = CBaseOutputPin::SetMediaType(pmt); <br>    if (FAILED(hr)) <br>        return hr; </code></pre>
<p>
</p>
<pre><code><br>    return NOERROR; <br> <br>} // SetMediaType <br> <br> <br>// <br>// CompleteConnect <br>// <br>HRESULT CTeeOutputPin::CompleteConnect(IPin *pReceivePin) <br>{ <br>    CAutoLock lock_it(m_pLock); <br>    ASSERT(m_Connected == pReceivePin); <br>    HRESULT hr = NOERROR; <br> <br>    hr = CBaseOutputPin::CompleteConnect(pReceivePin); <br>    if (FAILED(hr)) <br>        return hr; <br> <br>    // If the type is not the same as that stored for the input <br>    // pin then force the input pins peer to be reconnected <br> <br>    if (m_mt != m_pTee-&gt;m_Input.m_mt) <br>    { <br>        hr = m_pTee-&gt;ReconnectPin(m_pTee-&gt;m_Input.m_Connected, &amp;m_mt); <br>        if(FAILED(hr)) { <br>            return hr; <br>        } <br>    } <br> <br>    // Since this pin has been connected up, create another output pin. We <br>    // will do this only if there are no unconnected pins on us. However <br>    // CompleteConnect will get called for the same pin during reconnection <br> <br>    int n = m_pTee-&gt;GetNumFreePins(); <br>    ASSERT(n &lt;= 1); <br>    if (n == 1 || m_pTee-&gt;m_NumOutputPins == INFTEE_MAX_PINS) <br>        return NOERROR; <br> <br>    // No unconnected pins left so spawn a new one <br> <br>    CTeeOutputPin *pOutputPin = m_pTee-&gt;CreateNextOutputPin(m_pTee); <br>    if (pOutputPin != NULL ) <br>    { <br>        m_pTee-&gt;m_NumOutputPins++; <br>        m_pTee-&gt;m_OutputPinsList.AddTail(pOutputPin); <br>m_pTee-&gt;IncrementPinVersion(); <br>    } <br> <br>    // At this point we should be able to send some <br>    // notification that we have sprung a new pin <br> <br>    return NOERROR; <br> <br>} // CompleteConnect <br> <br> <br>// <br>// Active <br>// <br>// This is called when we start running or go paused. We create the <br>// output queue object to send data to our associated peer pin <br>// <br>HRESULT CTeeOutputPin::Active() <br>{ <br>    CAutoLock lock_it(m_pLock); <br>    HRESULT hr = NOERROR; <br> <br>    // Make sure that the pin is connected <br>    if (m_Connected == NULL) <br>        return NOERROR; <br> <br>    // Create the output queue if we have to <br>    if (m_pOutputQueue == NULL) <br>    { <br>        m_pOutputQueue = new COutputQueue(m_Connected, &amp;hr, TRUE, FALSE); <br>        if (m_pOutputQueue == NULL) <br>            return E_OUTOFMEMORY; <br> <br>        // Make sure that the constructor did not return any error <br>        if (FAILED(hr)) <br>        { <br>            delete m_pOutputQueue; <br>            m_pOutputQueue = NULL; <br>            return hr; <br>        } <br>    } <br> <br>    // Pass the call on to the base class <br>    CBaseOutputPin::Active(); <br>    return NOERROR; <br> <br>} // Active <br> <br> <br>// <br>// Inactive <br>// <br>// This is called when we stop streaming <br>// We delete the output queue at this time <br>// <br>HRESULT CTeeOutputPin::Inactive() <br>{ <br>    CAutoLock lock_it(m_pLock); <br> <br>    // Delete the output queus associated with the pin. <br>    if (m_pOutputQueue) <br>    { <br>        delete m_pOutputQueue; <br>        m_pOutputQueue = NULL; <br>    } <br> <br>    CBaseOutputPin::Inactive(); <br>    return NOERROR; <br> <br>} // Inactive <br> <br> <br>// <br>// Deliver <br>// <br>HRESULT CTeeOutputPin::Deliver(IMediaSample *pMediaSample) <br>{ <br>    // Make sure that we have an output queue <br>    if (m_pOutputQueue == NULL) <br>        return NOERROR; <br> <br>    pMediaSample-&gt;AddRef(); <br>    return m_pOutputQueue-&gt;Receive(pMediaSample); <br> <br>} // Deliver <br> <br> <br>// <br>// DeliverEndOfStream <br>// <br>HRESULT CTeeOutputPin::DeliverEndOfStream() <br>{ <br>    // Make sure that we have an output queue <br>    if (m_pOutputQueue == NULL) <br>        return NOERROR; <br> <br>    m_pOutputQueue-&gt;EOS(); <br>    return NOERROR; <br> <br>} // DeliverEndOfStream <br> <br> <br>// <br>// DeliverBeginFlush <br>// <br>HRESULT CTeeOutputPin::DeliverBeginFlush() <br>{ <br>    // Make sure that we have an output queue <br>    if (m_pOutputQueue == NULL) <br>        return NOERROR; <br> <br>    m_pOutputQueue-&gt;BeginFlush(); <br>    return NOERROR; <br> <br>} // DeliverBeginFlush <br> <br> <br>// <br>// DeliverEndFlush <br>// <br>HRESULT CTeeOutputPin::DeliverEndFlush() <br>{ <br>    // Make sure that we have an output queue <br>    if (m_pOutputQueue == NULL) <br>        return NOERROR; <br> <br>    m_pOutputQueue-&gt;EndFlush(); <br>    return NOERROR; <br> <br>} // DeliverEndFlish <br> <br>// <br>// DeliverNewSegment <br>// <br>HRESULT CTeeOutputPin::DeliverNewSegment(REFERENCE_TIME tStart,  <br>                                         REFERENCE_TIME tStop,   <br>                                         double dRate)           <br>{ <br>    // Make sure that we have an output queue <br>    if (m_pOutputQueue == NULL) <br>        return NOERROR; <br> <br>    m_pOutputQueue-&gt;NewSegment(tStart, tStop, dRate); <br>    return NOERROR; <br> <br>} // DeliverNewSegment <br> <br> <br>// <br>// Notify <br>// <br>STDMETHODIMP CTeeOutputPin::Notify(IBaseFilter *pSender, Quality q) <br>{ <br>    // We pass the message on, which means that we find the quality sink <br>    // for our input pin and send it there <br> <br>    POSITION pos = m_pTee-&gt;m_OutputPinsList.GetHeadPosition(); <br>    CTeeOutputPin *pFirstOutput = m_pTee-&gt;m_OutputPinsList.GetNext(pos); <br> <br>    if (this == pFirstOutput) { <br>if (m_pTee-&gt;m_Input.m_pQSink!=NULL) { <br>    return m_pTee-&gt;m_Input.m_pQSink-&gt;Notify(m_pTee, q); <br>} else { <br> <br>    // No sink set, so pass it upstream <br>    HRESULT hr; <br>    IQualityControl * pIQC; <br> <br>    hr = VFW_E_NOT_FOUND; <br>    if (m_pTee-&gt;m_Input.m_Connected) { <br>m_pTee-&gt;m_Input.m_Connected-&gt;QueryInterface(IID_IQualityControl,(void**)&amp;pIQC); <br> <br>if (pIQC!=NULL) { <br>    hr = pIQC-&gt;Notify(m_pTee, q); <br>    pIQC-&gt;Release(); <br>} <br>    } <br>    return hr; <br>} <br>    } <br> <br>    // Quality management is too hard to do <br>    return NOERROR; <br> <br>} // Notify <br> <br> <br>// <br>// DllRegisterServer <br>// <br>STDAPI DllRegisterServer() <br>{ <br>    return AMovieDllRegisterServer2( TRUE ); <br>} <br> <br> <br>// <br>// DllUnregisterServer <br>// <br>STDAPI <br>DllUnregisterServer() <br>{ <br>    return AMovieDllRegisterServer2( FALSE ); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
