<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>INFTEE.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2827"></a>INFTEE.H</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>#ifndef __INFTEE__ <br>#define __INFTEE__ <br> <br>// define a GUID for infinite tee filters <br> <br>// { 022B8142-0946-11cf-BCB1-444553540000 } <br>DEFINE_GUID(CLSID_Tee, <br>0x22b8142, 0x946, 0x11cf, 0xbc, 0xb1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0); <br> <br>class CTee; <br>class CTeeOutputPin; <br> <br>// class for the Tee filter's Input pin <br> <br>class CTeeInputPin : public CBaseInputPin <br>{ <br>    friend class CTeeOutputPin; <br>    CTee *m_pTee;                  // Main filter object <br>    BOOL m_bInsideCheckMediaType;  // Re-entrancy control <br> <br>public: <br> <br>    // Constructor and destructor <br>    CTeeInputPin(TCHAR *pObjName, <br>                 CTee *pTee, <br>                 HRESULT *phr, <br>                 LPCWSTR pPinName); <br> <br>#ifdef DEBUG <br>    ~CTeeInputPin(); <br>#endif <br> <br>    // Used to check the input pin connection <br>    HRESULT CheckMediaType(const CMediaType *pmt); <br>    HRESULT SetMediaType(const CMediaType *pmt); <br>    HRESULT BreakConnect(); <br> <br>    // Reconnect outputs if necessary at end of completion <br>    virtual HRESULT CompleteConnect(IPin *pReceivePin); <br> <br>    STDMETHODIMP NotifyAllocator(IMemAllocator *pAllocator, BOOL bReadOnly); <br> <br>    // Pass through calls downstream <br>    STDMETHODIMP EndOfStream(); <br>    STDMETHODIMP BeginFlush(); <br>    STDMETHODIMP EndFlush(); <br>    STDMETHODIMP NewSegment( <br>                    REFERENCE_TIME tStart, <br>                    REFERENCE_TIME tStop, <br>                    double dRate); <br> <br>    // Handles the next block of data from the stream <br>    STDMETHODIMP Receive(IMediaSample *pSample); <br> <br>}; <br> <br> <br>// Class for the Tee filter's Output pins. <br> <br>class CTeeOutputPin : public CBaseOutputPin <br>{ <br>    friend class CTeeInputPin; <br>    friend class CTee; <br> <br>    CTee *m_pTee;                  // Main filter object pointer <br>    IUnknown    *m_pPosition;      // Pass seek calls upstream <br>    BOOL m_bHoldsSeek;             // Is this the one seekable stream <br>    COutputQueue *m_pOutputQueue;  // Streams data to the peer pin <br>    BOOL m_bInsideCheckMediaType;  // Re-entrancy control <br>    LONG m_cOurRef;                // We maintain reference counting <br> <br>public: <br> <br>    // Constructor and destructor <br> <br>    CTeeOutputPin(TCHAR *pObjName, <br>                   CTee *pTee, <br>                   HRESULT *phr, <br>                   LPCWSTR pPinName, <br>                   INT PinNumber); <br> <br>#ifdef DEBUG <br>    ~CTeeOutputPin(); <br>#endif <br> <br>    // Override to expose IMediaPosition <br>    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppvoid); <br> <br>    // Override since the life time of pins and filters are not the same <br>    STDMETHODIMP_(ULONG) NonDelegatingAddRef(); <br>    STDMETHODIMP_(ULONG) NonDelegatingRelease(); <br> <br>    // Override to enumerate media types <br>    STDMETHODIMP EnumMediaTypes(IEnumMediaTypes **ppEnum); <br> <br>    // Check that we can support an output type <br>    HRESULT CheckMediaType(const CMediaType *pmt); <br>    HRESULT SetMediaType(const CMediaType *pmt); <br> <br>    // Negotiation to use our input pins allocator <br>    HRESULT DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc); <br>    HRESULT DecideBufferSize(IMemAllocator *pMemAllocator, <br>                              ALLOCATOR_PROPERTIES * ppropInputRequest); <br> <br>    // Used to create output queue objects <br>    HRESULT Active(); <br>    HRESULT Inactive(); <br> <br>    // Overriden to create and destroy output pins <br>    HRESULT CompleteConnect(IPin *pReceivePin); <br> <br>    // Overriden to pass data to the output queues <br>    HRESULT Deliver(IMediaSample *pMediaSample); <br>    HRESULT DeliverEndOfStream(); <br>    HRESULT DeliverBeginFlush(); <br>    HRESULT DeliverEndFlush(); <br>    HRESULT DeliverNewSegment( <br>                    REFERENCE_TIME tStart, <br>                    REFERENCE_TIME tStop, <br>                    double dRate); <br> <br> <br>    // Overriden to handle quality messages <br>    STDMETHODIMP Notify(IBaseFilter *pSender, Quality q); <br>}; <br> <br> <br>// Class for the Tee filter <br> <br>class CTee: public CCritSec, public CBaseFilter <br>{ <br>    // Let the pins access our internal state <br>    friend class CTeeInputPin; <br>    friend class CTeeOutputPin; <br>    typedef CGenericList &lt;CTeeOutputPin&gt; COutputList; <br> <br>    // Declare an input pin. <br>    CTeeInputPin m_Input; <br> <br>    INT m_NumOutputPins;            // Current output pin count <br>    COutputList m_OutputPinsList;   // List of the output pins <br>    INT m_NextOutputPinNumber;      // Increases monotonically. <br>    LONG m_lCanSeek;                // Seekable output pin <br>    IMemAllocator *m_pAllocator;    // Allocator from our input pin <br> <br>public: <br> <br>    CTee(TCHAR *pName,LPUNKNOWN pUnk,HRESULT *hr); <br>    ~CTee(); <br> <br>    CBasePin *GetPin(int n); <br>    int GetPinCount(); <br> <br>    // Function needed for the class factory <br>    static CUnknown * WINAPI CreateInstance(LPUNKNOWN pUnk, HRESULT *phr); <br> <br>    // Send EndOfStream if no input connection <br>    STDMETHODIMP Run(REFERENCE_TIME tStart); <br>    STDMETHODIMP Pause(); <br>    STDMETHODIMP Stop(); <br> <br>protected: <br> <br>    // The following manage the list of output pins <br> <br>    void InitOutputPinsList(); <br>    CTeeOutputPin *GetPinNFromList(int n); <br>    CTeeOutputPin *CreateNextOutputPin(CTee *pTee); <br>    void DeleteOutputPin(CTeeOutputPin *pPin); <br>    int GetNumFreePins(); <br>}; <br> <br>#endif // __INFTEE__ <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
