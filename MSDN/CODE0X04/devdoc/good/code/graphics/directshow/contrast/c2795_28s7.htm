<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CONTRAST.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2797"></a>CONTRAST.CPP</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>#include &lt;windows.h&gt; <br>#include &lt;streams.h&gt; <br>#include &lt;initguid.h&gt; <br>#include &lt;olectl.h&gt; <br>#if (1100 &gt; _MSC_VER) <br>#include &lt;olectlid.h&gt; <br>#endif <br>#include "contuids.h" <br>#include "icontrst.h" <br>#include "contprop.h" <br>#include "contrast.h" <br> <br>// <br>// <br>// What this sample illustrates <br>// <br>// A simple transform filter that adjusts contrast on a video stream. We use <br>// eight bit palettised images exclusively and can increase or decrease the <br>// contrast. The contrast is adjusted through a custom interface we support. <br>// We have a property page that uses this interface to respond to user action <br>// <br>// Summary <br>// <br>// This is a sample transform filter - we have a single input pin and also a <br>// single output pin. The input pin accepts only palettised eight bit video <br>// formats and our output pin also provides an eight bit palettised format. <br>// We will normally be put between a video decoder (AVI or MPEG) and a video <br>// renderer. We adjust the contrast of the video images sent through us, by <br>// increasing contrast the colours become more suturated and likewise less <br>// contrast reduces the colour into some grey shades and finally to all grey <br>// <br>// <br>// Implementation <br>// <br>// We adjust contrast using a neat trick with palettes, the colour palette of <br>// an image effectively determines how the image is interpreted. So in short <br>// how the value 23 (for example) is turned into an RGB triplet for display. <br>// By changing the palette we can reduce and increase contrast without doing <br>// anything to the actual image pixels themselves (which makes us go faster). <br>// So by adjusting the palette in band we can adjust the pixel interpretion. <br>// <br>// The runtime video renderer supports palette changes in band, when we want <br>// to change palettes we pick the new colours and attach a VIDEOINFO to the <br>// next image we send to the renderer. It will then take that palette out of <br>// the sample and realise a new palette in the window for us. The trigger to <br>// change the palette is through a custom interface this filter provides. <br>// <br>// The custom interface we implement is called IContrast, this allows someone <br>// to increase and decrease contrast levels for a given video. The normal way <br>// for the interface to be used is to right click on the contrast filter in <br>// GRAPHEDT and bring up our property page. This has a slider control on it <br>// that can be used to adjust the contrast level. Each time the slider moves <br>// it will ask for a contrast change by calling IContrast. To expose property <br>// pages a filter implements the ISpecifyPropertyPages interface (it has only <br>// one method called GetPages which returns the CLSIDs for the property pages) <br>// <br>// <br>// Demonstration instructions <br>// <br>// Start GRAPHEDT available in the ActiveMovie SDK tools. Drag and drop any <br>// MPEG, AVI or MOV file into the tool and it will be rendered. Then go to <br>// the filters in the graph and find the filter (box) titled "Video Renderer" <br>// Disconnect the renderer from its source filter and insert a contrast in <br>// between them (the contrast is added to the graph using the Graph Menu and <br>// selecting Insert Filters, the filter is in the dialog box list). Once the <br>// contrast filter is inserted run the graph. Right click on the contrast <br>// box and select properties which brings up a property page that contains a <br>// slider. The slider can be dragged up and down to adjust the contrast level <br>// <br>// <br>// Files <br>// <br>// contprop.cpp         Property page implementation with a slider control <br>// contprop.h           Class definition for the property page <br>// contprop.rc          Dialog box template for the property page <br>// contrast.cpp         Main contrast filter class implementation <br>// contrast.def         What APIs we import and export from this DLL <br>// contrast.h           Class definition for the contrast filter <br>// contrast.reg         What goes in the registry to make us work <br>// contuids.h           The transform filter CLSIDs <br>// icontrst.h           Defines the custom contrast filter interface <br>// makefile             How to build it... <br>// resource.h           Microsoft Visual C++ generated resource file <br>// <br>// <br>// Base classes we use <br>// <br>// CTransformFilter     A generic transform filter that has a single input <br>//                      and a single output pin. It has some PURE virtual <br>//                      methods we must override (such as the Transform <br>//                      method that does the real work). We also use it's <br>//                      CUnknown base class to implement IUnknown for the <br>//                      IContrast and ISpecifyPropertyPages we also support <br>// <br>// <br> <br> <br>// setup data <br> <br>const AMOVIESETUP_MEDIATYPE sudPinTypes = <br>{ <br>    &amp;MEDIATYPE_Video,       // Major type <br>    &amp;MEDIASUBTYPE_NULL      // Minor type <br>}; <br> <br>const AMOVIESETUP_PIN psudPins[] = <br>{ <br>    { <br>        L"Input",           // String pin name <br>        FALSE,              // Is it rendered <br>        FALSE,              // Is it an output <br>        FALSE,              // Allowed none <br>        FALSE,              // Allowed many <br>        &amp;CLSID_NULL,        // Connects to filter <br>        L"Output",          // Connects to pin <br>        1,                  // Number of types <br>        &amp;sudPinTypes },     // The pin details <br>      { L"Output",          // String pin name <br>        FALSE,              // Is it rendered <br>        TRUE,               // Is it an output <br>        FALSE,              // Allowed none <br>        FALSE,              // Allowed many <br>        &amp;CLSID_NULL,        // Connects to filter <br>        L"Input",           // Connects to pin <br>        1,                  // Number of types <br>        &amp;sudPinTypes        // The pin details <br>    } <br>}; <br> <br> <br>const AMOVIESETUP_FILTER sudContrast = <br>{ <br>    &amp;CLSID_Contrast,        // Filter CLSID <br>    L"Video Contrast",      // Filter name <br>    MERIT_DO_NOT_USE,       // Its merit <br>    2,                      // Number of pins <br>    psudPins                // Pin details <br>}; <br> <br> <br>// List of class IDs and creator functions for the class factory. This <br>// provides the link between the OLE entry point in the DLL and an object <br>// being created. The class factory will call the static CreateInstance <br> <br>CFactoryTemplate g_Templates[2] = { <br> <br>    { L"Video Contrast" <br>    , &amp;CLSID_Contrast <br>    , CContrast::CreateInstance <br>    , NULL <br>    , &amp;sudContrast } <br>  , <br>    { L"Video Contrast Property Page" <br>    , &amp;CLSID_ContrastPropertyPage <br>    , CContrastProperties::CreateInstance } <br>}; <br>int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]); <br> <br> <br>// <br>// Constructor <br>// <br>CContrast::CContrast(TCHAR *tszName,LPUNKNOWN punk,HRESULT *phr) : <br>    CTransformFilter(tszName, punk, CLSID_Contrast), <br>    m_DefaultContrastLevel(0), <br>    m_ContrastLevel(m_DefaultContrastLevel), <br>    m_PrevLevel(m_ContrastLevel), <br>    m_lBufferRequest(1) <br>{ <br>    ASSERT(tszName); <br>    ASSERT(phr); <br> <br>} // Contrast <br> <br> <br>// <br>// CreateInstance <br>// <br>// Provide the way for COM to create a CContrast object <br>// <br>CUnknown * WINAPI CContrast::CreateInstance(LPUNKNOWN punk, HRESULT *phr) { <br> <br>    CContrast *pNewObject = new CContrast(NAME("Contrast"), punk, phr); <br>    if (pNewObject == NULL) { <br>        *phr = E_OUTOFMEMORY; <br>    } <br>    return pNewObject; <br> <br>} // CreateInstance <br> <br> <br>// <br>// NonDelegatingQueryInterface <br>// <br>// Reveals IContrast and ISpecifyPropertyPages <br>// <br>STDMETHODIMP CContrast::NonDelegatingQueryInterface(REFIID riid, void **ppv) <br>{ <br>    CheckPointer(ppv,E_POINTER); <br> <br>    if (riid == IID_IContrast) { <br>        return GetInterface((IContrast *) this, ppv); <br>    } else if (riid == IID_ISpecifyPropertyPages) { <br>        return GetInterface((ISpecifyPropertyPages *) this, ppv); <br>    } else { <br>        return CTransformFilter::NonDelegatingQueryInterface(riid, ppv); <br>    } <br> <br>} // NonDelegatingQueryInterface <br> <br> <br>// <br>// Transform <br>// <br>// Copy the input sample into the output sample <br>// Then transform the output sample 'in place' <br>// <br>HRESULT CContrast::Transform(IMediaSample *pIn, IMediaSample *pOut) <br>{ <br>    HRESULT hr = Copy(pIn, pOut); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br>    return Transform(pOut); <br> <br>} // Transform <br> <br> <br>// <br>// Copy <br>// <br>// Make destination an identical copy of source <br>// <br>HRESULT CContrast::Copy(IMediaSample *pSource, IMediaSample *pDest) const <br>{ <br>    // Copy the sample data <br> <br>    BYTE *pSourceBuffer, *pDestBuffer; <br>    long lSourceSize = pSource-&gt;GetActualDataLength(); <br>    long lDestSize= pDest-&gt;GetSize(); <br> <br>    ASSERT(lDestSize &gt;= lSourceSize); <br> <br>    pSource-&gt;GetPointer(&amp;pSourceBuffer); <br>    pDest-&gt;GetPointer(&amp;pDestBuffer); <br> <br>    CopyMemory( (PVOID) pDestBuffer,(PVOID) pSourceBuffer,lSourceSize); <br> <br>    // Copy the sample times <br> <br>    REFERENCE_TIME TimeStart, TimeEnd; <br>    if (NOERROR == pSource-&gt;GetTime(&amp;TimeStart, &amp;TimeEnd)) { <br>        pDest-&gt;SetTime(&amp;TimeStart, &amp;TimeEnd); <br>    } <br> <br>    LONGLONG MediaStart, MediaEnd; <br>    if (pSource-&gt;GetMediaTime(&amp;MediaStart,&amp;MediaEnd) == NOERROR) { <br>        pDest-&gt;SetMediaTime(&amp;MediaStart,&amp;MediaEnd); <br>    } <br> <br>    // Copy the Sync point property <br> <br>    HRESULT hr = pSource-&gt;IsSyncPoint(); <br>    if (hr == S_OK) { <br>        pDest-&gt;SetSyncPoint(TRUE); <br>    } <br>    else if (hr == S_FALSE) { <br>        pDest-&gt;SetSyncPoint(FALSE); <br>    } <br>    else {  // an unexpected error has occured... <br>        return E_UNEXPECTED; <br>    } <br> <br>    // Copy the media type <br> <br>    AM_MEDIA_TYPE *pMediaType; <br>    pSource-&gt;GetMediaType(&amp;pMediaType); <br>    pDest-&gt;SetMediaType(pMediaType); <br>    DeleteMediaType(pMediaType); <br> <br>    // Copy the preroll property <br> <br>    hr = pSource-&gt;IsPreroll(); <br>    if (hr == S_OK) { <br>        pDest-&gt;SetPreroll(TRUE); <br>    } <br>    else if (hr == S_FALSE) { <br>        pDest-&gt;SetPreroll(FALSE); <br>    } <br>    else {  // an unexpected error has occured... <br>        return E_UNEXPECTED; <br>    } <br> <br>    // Copy the discontinuity property <br> <br>    hr = pSource-&gt;IsDiscontinuity(); <br>    if (hr == S_OK) { <br>pDest-&gt;SetDiscontinuity(TRUE); <br>    } <br>    else if (hr == S_FALSE) { <br>        pDest-&gt;SetDiscontinuity(FALSE); <br>    } <br>    else {  // an unexpected error has occured... <br>        return E_UNEXPECTED; <br>    } <br> <br>    // Copy the actual data length <br> <br>    long lDataLength = pSource-&gt;GetActualDataLength(); <br>    pDest-&gt;SetActualDataLength(lDataLength); <br>    return NOERROR; <br> <br>} // Copy <br> <br> <br>// <br>// Transform <br>// <br>// 'In place' adjust the contrast of this sample <br>// <br>HRESULT CContrast::Transform(IMediaSample *pMediaSample) <br>{ <br>    signed char ContrastLevel; <br> <br>    // Take a copy, so we dont hold the lock <br>    // for the whole transform. Also ensures <br>    // we use the same level throughout this! <br>    { <br>        CAutoLock cAutoLock(&amp;m_ContrastLock); <br>ContrastLevel = m_ContrastLevel; <br>    } <br> <br>    AM_MEDIA_TYPE *pAdjustedType = NULL; <br> <br>    pMediaSample-&gt;GetMediaType(&amp;pAdjustedType); <br>    if (pAdjustedType != NULL) { <br>        if (CheckInputType(&amp;CMediaType(*pAdjustedType)) == S_OK) { <br>            m_pInput-&gt;CurrentMediaType() = *pAdjustedType; <br>    CoTaskMemFree(pAdjustedType); <br>} else { <br>    CoTaskMemFree(pAdjustedType); <br>    return E_FAIL; <br>} <br>    } <br> <br>    // Pass on format changes to downstream filters <br> <br>    if ((pAdjustedType != NULL) || (m_PrevLevel != ContrastLevel)) { <br>CMediaType AdjustedType((AM_MEDIA_TYPE) m_pInput-&gt;CurrentMediaType()); <br>        HRESULT hr = Transform(&amp;AdjustedType, ContrastLevel); <br>        if (hr == S_OK) { <br>            pMediaSample-&gt;SetMediaType(&amp;AdjustedType); <br>    m_PrevLevel = ContrastLevel; <br>        } else { <br>            return hr; <br>        } <br>    } <br>    return NOERROR; <br> <br>} // Transform <br> <br> <br>// <br>// CheckInputType <br>// <br>// Check the input type is OK, return an error otherwise <br>// <br>HRESULT CContrast::CheckInputType(const CMediaType *mtIn) <br>{ <br>    // Check this is a VIDEOINFO type <br> <br>    if (*mtIn-&gt;FormatType() != FORMAT_VideoInfo) { <br>        return E_INVALIDARG; <br>    } <br> <br>    // Is this a palettised format <br> <br>    if (CanChangeContrastLevel(mtIn)) { <br>    return NOERROR; <br>    } <br>    return E_FAIL; <br> <br>} // CheckInputType <br> <br> <br>// <br>// CheckTransform <br>// <br>// To be able to transform the formats must be identical <br>// <br>HRESULT CContrast::CheckTransform(const CMediaType *mtIn,const CMediaType *mtOut) <br>{ <br>    HRESULT hr; <br>    if (FAILED(hr = CheckInputType(mtIn))) { <br>return hr; <br>    } <br> <br>    // format must be a VIDEOINFOHEADER <br>    if (*mtOut-&gt;FormatType() != FORMAT_VideoInfo) { <br>return E_INVALIDARG; <br>    } <br>     <br>    // formats must be big enough  <br>    if (mtIn-&gt;FormatLength() &lt; sizeof(VIDEOINFOHEADER) || <br>mtOut-&gt;FormatLength() &lt; sizeof(VIDEOINFOHEADER)) <br>return E_INVALIDARG; <br>     <br>    VIDEOINFO *pInput = (VIDEOINFO *) mtIn-&gt;Format(); <br>    VIDEOINFO *pOutput = (VIDEOINFO *) mtOut-&gt;Format(); <br>    if (memcmp(&amp;pInput-&gt;bmiHeader,&amp;pOutput-&gt;bmiHeader,sizeof(BITMAPINFOHEADER)) == 0) { <br>return NOERROR; <br>    } <br> <br>    return E_INVALIDARG; <br>} // CheckTransform <br> <br> <br>// <br>// DecideBufferSize <br>// <br>// Tell the output pin's allocator what size buffers we <br>// require. Can only do this when the input is connected <br>// <br>HRESULT CContrast::DecideBufferSize(IMemAllocator *pAlloc,ALLOCATOR_PROPERTIES *pProperties) <br>{ <br>    // Is the input pin connected <br> <br>    if (m_pInput-&gt;IsConnected() == FALSE) { <br>        return E_UNEXPECTED; <br>    } <br> <br>    ASSERT(pAlloc); <br>    ASSERT(pProperties); <br>    HRESULT hr = NOERROR; <br> <br>    pProperties-&gt;cBuffers = 1; <br>    pProperties-&gt;cbBuffer = m_pInput-&gt;CurrentMediaType().GetSampleSize(); <br> <br>    ASSERT(pProperties-&gt;cbBuffer); <br> <br>    // If we don't have fixed sized samples we must guess some size <br> <br>    if (!m_pInput-&gt;CurrentMediaType().bFixedSizeSamples) { <br>        if (pProperties-&gt;cbBuffer &lt; 100000) { <br>            // nothing more than a guess!! <br>            pProperties-&gt;cbBuffer = 100000; <br>        } <br>    } <br> <br>    // Ask the allocator to reserve us some sample memory, NOTE the function <br>    // can succeed (that is return NOERROR) but still not have allocated the <br>    // memory that we requested, so we must check we got whatever we wanted <br> <br>    ALLOCATOR_PROPERTIES Actual; <br>    hr = pAlloc-&gt;SetProperties(pProperties,&amp;Actual); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br> <br>    ASSERT( Actual.cBuffers == 1 ); <br> <br>    if (pProperties-&gt;cBuffers &gt; Actual.cBuffers || <br>            pProperties-&gt;cbBuffer &gt; Actual.cbBuffer) { <br>                return E_FAIL; <br>    } <br>    return NOERROR; <br> <br>} // DecideBufferSize <br> <br> <br>// <br>// GetMediaType <br>// <br>// I support one type, namely the type of the input pin <br>// We must be connected to support the single output type <br>// <br>HRESULT CContrast::GetMediaType(int iPosition, CMediaType *pMediaType) <br>{ <br>    // Is the input pin connected <br> <br>    if (m_pInput-&gt;IsConnected() == FALSE) { <br>        return E_UNEXPECTED; <br>    } <br> <br>    // This should never happen <br> <br>    if (iPosition &lt; 0) { <br>        return E_INVALIDARG; <br>    } <br> <br>    // Do we have more items to offer <br> <br>    if (iPosition &gt; 0) { <br>        return VFW_S_NO_MORE_ITEMS; <br>    } <br> <br>    *pMediaType = m_pInput-&gt;CurrentMediaType(); <br>    return NOERROR; <br> <br>} // GetMediaType <br> <br> <br>// <br>// get_ContrastLevel <br>// <br>// Return the current contrast level <br>// <br>STDMETHODIMP CContrast::get_ContrastLevel(signed char *ContrastLevel) <br>{ <br>    CAutoLock cAutoLock(&amp;m_ContrastLock); <br>    *ContrastLevel = m_ContrastLevel; <br>    return NOERROR; <br> <br>} // get_ContrastLevel <br> <br> <br>// <br>// put_ContrastLevel <br>// <br>// Sets the contrast level for the filter <br>// <br>STDMETHODIMP CContrast::put_ContrastLevel(signed char ContrastLevel, unsigned long ChangeTime) <br>{ <br>    CAutoLock cAutoLock(&amp;m_ContrastLock); <br>    m_ContrastLevel = ContrastLevel; <br>    return NOERROR; <br> <br>} // put_ContrastLevel <br> <br> <br>// <br>// put_DefaultContrastLevel <br>// <br>// Sets the default contrast level for the filter <br>// <br>STDMETHODIMP CContrast::put_DefaultContrastLevel() <br>{ <br>    CAutoLock cAutoLock(&amp;m_ContrastLock); <br>    m_ContrastLevel = m_DefaultContrastLevel; <br>    return NOERROR; <br> <br>} // put_DefaultContrastLevel <br> <br> <br>// <br>// GetPages <br>// <br>// This is the sole member of ISpecifyPropertyPages <br>// Returns the clsid's of the property pages we support <br>// <br>STDMETHODIMP CContrast::GetPages(CAUUID *pPages) <br>{ <br>    pPages-&gt;cElems = 1; <br>    pPages-&gt;pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID)); <br>    if (pPages-&gt;pElems == NULL) { <br>        return E_OUTOFMEMORY; <br>    } <br>    *(pPages-&gt;pElems) = CLSID_ContrastPropertyPage; <br>    return NOERROR; <br> <br>} // GetPages <br> <br> <br>// <br>// CanChangeContrastLevel <br>// <br>// Check if this is a paletised format <br>// <br>BOOL CContrast::CanChangeContrastLevel(const CMediaType *pMediaType) const <br>{ <br>    if ((IsEqualGUID(*pMediaType-&gt;Type(), MEDIATYPE_Video)) <br>         &amp;&amp; (IsEqualGUID(*pMediaType-&gt;Subtype(), MEDIASUBTYPE_RGB8))) { <br> <br>        // I think I can process this format (8 bit palettised) <br>// So do a quick sanity check on the palette information <br> <br>VIDEOINFO *pvi = (VIDEOINFO *) pMediaType-&gt;Format(); <br>return (pvi-&gt;bmiHeader.biBitCount == 8); <br> <br>    } else { <br>        return FALSE; <br>    } <br> <br>} // CanChangeContrastLevel <br> <br> <br>// <br>// Transform <br>// <br>// Adjust the palette entries of pType to reflect the specified contrast level <br>// <br>HRESULT CContrast::Transform(AM_MEDIA_TYPE *pType, const signed char ContrastLevel) const <br>{ <br>    VIDEOINFO *pvi = (VIDEOINFO *) pType-&gt;pbFormat; <br> <br>    if (ContrastLevel &gt;= 0) { <br>        int Low= 0 + m_ContrastLevel; <br>        int High= 255 - m_ContrastLevel; <br>float Grad= ((float)(High - Low)) / 255; <br> <br>        for (UINT i = 0; i &lt; pvi-&gt;bmiHeader.biClrUsed; i++) { <br> <br>            IncreaseContrast(&amp;pvi-&gt;bmiColors[i], Low, High, Grad); <br>        } <br>    } else { <br>        float Grad = 255 / (255 + (float) ContrastLevel + (float) ContrastLevel); <br> <br>        for (UINT i = 0; i &lt; pvi-&gt;bmiHeader.biClrUsed; i++) { <br>            DecreaseContrast(&amp;pvi-&gt;bmiColors[i], ContrastLevel, Grad); <br>        } <br>    } <br>    return NOERROR; <br> <br>} // Transform <br> <br> <br>// <br>// IncreaseContrast <br>// <br>// Adjust the contrast of this palette element <br>// <br>inline <br>void CContrast::IncreaseContrast(RGBQUAD *pElem, const int Low, const int High, const float Grad) const <br>{ <br>    IncreaseContrast(&amp;pElem-&gt;rgbRed, Low, High, Grad); <br>    IncreaseContrast(&amp;pElem-&gt;rgbGreen, Low, High, Grad); <br>    IncreaseContrast(&amp;pElem-&gt;rgbBlue, Low, High, Grad); <br> <br>} // IncreaseContrast <br> <br> <br>// <br>// IncreaseContrast <br>// <br>// Change this byte's contrast <br>// <br>inline <br>void CContrast::IncreaseContrast(BYTE *pByte, const int Low, const int High, const float Grad) const <br>{ <br>    if (*pByte &lt;= Low) { <br>        *pByte = 0; <br>    } <br>    else if ((Low &lt; *pByte) &amp;&amp; (*pByte &lt;  High)) { <br>*pByte = (BYTE)( (*pByte - Low) / Grad); <br>    } <br>    else {// pElem-&gt;rgbGreen &gt;= High <br>        *pByte = 255; <br>    } <br> <br>} // IncreaseContrast <br> <br> <br>// <br>// DecreaseContrast <br>// <br>// Adjust the contrast of this palette element <br>// <br>inline <br>void CContrast::DecreaseContrast(RGBQUAD *pElem, const int Level, const float Grad) const <br>{ <br>    DecreaseContrast(&amp;pElem-&gt;rgbRed, Level, Grad); <br>    DecreaseContrast(&amp;pElem-&gt;rgbGreen, Level, Grad); <br>    DecreaseContrast(&amp;pElem-&gt;rgbBlue, Level, Grad); <br> <br>} // DecreaseContrast <br> <br> <br>// <br>// DecreaseContrast <br>// <br>// Use different maths to calculate the 'decreasing contrast' line <br>// <br>inline <br>void CContrast::DecreaseContrast(BYTE *pByte, const int Level, const float Grad) const <br>{ <br>    ASSERT(pByte); <br>    ASSERT(Grad != 0.0); <br>    *pByte = (BYTE) ( ((int) (*pByte / Grad)) - Level); <br> <br>} // DecreaseContrast <br> <br> <br>// <br>// DllRegisterServer <br>// <br>// Handle registration of this filter <br>// <br>STDAPI DllRegisterServer() <br>{ <br>    return AMovieDllRegisterServer2( TRUE ); <br> <br>} // DllRegisterServer <br> <br> <br>// <br>// DllUnregisterServer <br>// <br>STDAPI DllUnregisterServer() <br>{ <br>    return AMovieDllRegisterServer2( FALSE ); <br> <br>} // DllUnregisterServer <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
