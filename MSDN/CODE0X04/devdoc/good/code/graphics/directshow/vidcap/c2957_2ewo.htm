<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OVERLAY.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2958"></a>OVERLAY.CPP</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>/* <br> <br>    Methods for CVidOverlay, CVidOverlayNotify <br> <br>    This is a preview pin, which will use the hardware overlay capabilities <br>    of the driver to make it draw into the window of the video renderer that <br>    this pin is connected to.  We connect to the renderer through IOverlay, <br>    meaning that the renderer tells us where the window is at all times, and <br>    it's up to us to draw in it. <br> <br>    When we get RUN, if the capture pin is connected, it will have made <br>    a capture window already, and we must use that capture window, since <br>    there can be only one (it takes the hardware).  If the capture pin <br>    isn't connected, we create the capture window.  In any case, we make it <br>    a child of the video renderer's window and always make it fill up the <br>    video renderer's window's rectangle, and then turn overlay on, and <br>    VOILA!  we have preview.  When we stop streaming, we destroy the <br>    capture window (if we made it) so the capture pin get make one again <br>    if it needs to. <br> <br>    Reading this code is very useful for figuring out how to make a pin <br>    that connects to the renderer through IOverlay. <br> <br>*/ <br> <br>#include &lt;streams.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include &lt;vfw.h&gt; <br>#include "vidcap.h" <br> <br>// CVidOverlay constructor <br>// <br>CVidOverlay::CVidOverlay(TCHAR *pObjectName, CVidCap *pCapture, <br>        HRESULT * phr, LPCWSTR pName) <br>   : <br>   CBaseOutputPin(pObjectName, pCapture, pCapture-&gt;pStateLock(), phr, pName), <br>   m_OverlayNotify(NAME("Overlay notification interface"), pCapture, NULL, phr), <br>   m_pCap(pCapture), <br>   m_fRunning(FALSE), <br>   m_hwndCap(NULL) <br>{ <br>   DbgLog((LOG_TRACE,1,TEXT("CVidOverlay constructor"))); <br>   ASSERT(pCapture); <br>} <br> <br> <br>CVidOverlay::~CVidOverlay() <br>{ <br>    DbgLog((LOG_TRACE,1,TEXT("*Destroying the Overlay pin"))); <br>}; <br> <br> <br>STDMETHODIMP CVidOverlay::NonDelegatingQueryInterface(REFIID riid, void ** ppv) <br>{ <br>    DbgLog((LOG_TRACE,99,TEXT("CVidOverlay::QueryInterface"))); <br>    if (ppv) <br>*ppv = NULL; <br> <br>    /* Do we have this interface */ <br> <br>    if (riid == IID_IKsPropertySet) { <br>        return GetInterface((LPUNKNOWN) (IKsPropertySet *) this, ppv); <br>    } else { <br>        return CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv); <br>    } <br>} <br> <br> <br>// Overridden to connect with IOverlay instead of IMemInputPin <br>// Say if we're prepared to connect to a given input pin from <br>// this output pin <br>// <br>STDMETHODIMP CVidOverlay::Connect(IPin *pReceivePin, <br>                                        const AM_MEDIA_TYPE *pmt) <br>{ <br>    DbgLog((LOG_TRACE,3,TEXT("CVidOverlay::Connect"))); <br> <br>    /*  Call the base class to make sure the directions match! */ <br>    HRESULT hr = CBaseOutputPin::Connect(pReceivePin,pmt); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br>    /*  We're happy if we can get an IOverlay interface */ <br> <br>    hr = pReceivePin-&gt;QueryInterface(IID_IOverlay, <br>                                     (void **)&amp;m_pOverlay); <br> <br>    // we were promised this would work <br>    ASSERT(SUCCEEDED(hr)); <br> <br>    /*  Because we're not going to get called again - except to <br>        propose a media type - we set up a callback here. <br> <br>        There's only one overlay pin so we don't need any context. <br>    */ <br> <br>    hr = m_pOverlay-&gt;Advise(&amp;m_OverlayNotify, <br>                            ADVISE_CLIPPING | ADVISE_POSITION); <br> <br>    /* <br>        We don't need to hold on to the IOverlay pointer <br>        because BreakConnect will be called before the receiving <br>        pin goes away. <br>    */ <br> <br> <br>    if (FAILED(hr)) { <br>// !!! Shouldn't happen, but this isn't quite right <br>        Disconnect(); <br>pReceivePin-&gt;Disconnect(); <br>        return hr; <br>    } else { <br>        m_bAdvise = TRUE; <br>    } <br> <br>    return hr; <br>} <br> <br> <br>// Overridden to connect with IOverlay instead of IMemInputPin <br>// <br>HRESULT CVidOverlay::BreakConnect() <br>{ <br>    DbgLog((LOG_TRACE,3,TEXT("CVidOverlay::BreakConnect"))); <br> <br>    // we must get rid of our overlay notify advise now <br>    if (m_pOverlay != NULL) { <br>        if (m_bAdvise) { <br>            m_pOverlay-&gt;Unadvise(); <br>            m_bAdvise = FALSE; <br>        } <br>        m_pOverlay-&gt;Release(); <br>        m_pOverlay = NULL; <br>    } <br> <br>    return CBaseOutputPin::BreakConnect(); <br>} <br> <br> <br>// Overridden to connect with IOverlay instead of IMemInputPin <br>// Override this because we don't want any allocator! <br>// <br>HRESULT CVidOverlay::DecideAllocator(IMemInputPin * pPin, <br>                        IMemAllocator ** pAlloc) { <br>    /*  We just don't want one so everything's OK as it is */ <br>    return S_OK; <br>} <br> <br> <br>// Overridden to connect with IOverlay instead of IMemInputPin <br>HRESULT CVidOverlay::GetMediaType(int iPosition, CMediaType *pmt) <br>{ <br>    DbgLog((LOG_TRACE,3,TEXT("CVidOverlay::GetMediaType #%d"), iPosition)); <br> <br>    if (pmt == NULL) { <br>        DbgLog((LOG_TRACE,3,TEXT("NULL format, no can do"))); <br>return E_INVALIDARG; <br>    } <br> <br>    if (iPosition &lt; 0) { <br>        return E_INVALIDARG; <br>    } <br> <br>    if (iPosition &gt; 0) { <br>        return VFW_S_NO_MORE_ITEMS; <br>    } <br> <br>    // We provide a media type of OVERLAY with an 8 bit format (the <br>    // renderer won't accept it if we don't set up an 8 bit format) <br> <br>    BYTE aFormat[sizeof(VIDEOINFOHEADER) + SIZE_PALETTE]; <br>    VIDEOINFOHEADER *pFormat = (VIDEOINFOHEADER *)aFormat; <br>    ZeroMemory(pFormat, sizeof(VIDEOINFOHEADER) + SIZE_PALETTE); <br> <br>    // make the overlay window the same size as what's being captured <br>    if (m_pCap-&gt;m_pCapturePin-&gt;m_mt.IsValid()) { <br>        pFormat-&gt;bmiHeader.biWidth = <br>HEADER(m_pCap-&gt;m_pCapturePin-&gt;m_mt.Format())-&gt;biWidth; <br>        pFormat-&gt;bmiHeader.biHeight = <br>HEADER(m_pCap-&gt;m_pCapturePin-&gt;m_mt.Format())-&gt;biHeight; <br>    } else { <br>        pFormat-&gt;bmiHeader.biWidth = 320; <br>        pFormat-&gt;bmiHeader.biHeight = 240; <br>    } <br> <br>    pFormat-&gt;bmiHeader.biSize   = sizeof(BITMAPINFOHEADER); <br>    pFormat-&gt;bmiHeader.biPlanes = 1; <br>    pFormat-&gt;bmiHeader.biBitCount = 8; <br> <br>    pmt-&gt;SetFormat((PBYTE)pFormat, sizeof(VIDEOINFOHEADER) + SIZE_PALETTE); <br>    pmt-&gt;SetFormatType(&amp;FORMAT_VideoInfo); <br> <br>    if (pmt-&gt;pbFormat == NULL) { <br>        return E_OUTOFMEMORY; <br>    } <br> <br>    pmt-&gt;majortype = MEDIATYPE_Video; <br>    pmt-&gt;subtype   = MEDIASUBTYPE_Overlay; <br>    pmt-&gt;bFixedSizeSamples    = FALSE; <br>    pmt-&gt;bTemporalCompression = FALSE; <br>    pmt-&gt;lSampleSize          = 0; <br> <br>    return NOERROR; <br>} <br> <br> <br>// Overridden to connect with IOverlay instead of IMemInputPin <br>// We accept overlay connections only <br>// <br>HRESULT CVidOverlay::CheckMediaType(const CMediaType *pMediaType) <br>{ <br>    DbgLog((LOG_TRACE,3,TEXT("CVidOverlay::CheckMediaType"))); <br>    if (pMediaType-&gt;subtype == MEDIASUBTYPE_Overlay) <br>        return NOERROR; <br>    else <br>return E_FAIL; <br>} <br> <br> <br>// Overridden to connect with IOverlay instead of IMemInputPin <br>// <br>HRESULT CVidOverlay::CheckConnect(IPin *pPin) <br>{ <br>    // we don't connect to anyone who doesn't support IOverlay. <br>    // after all, we're an overlay pin <br>    HRESULT hr = pPin-&gt;QueryInterface(IID_IOverlay, (void **)&amp;m_pOverlay); <br> <br>    if (FAILED(hr)) { <br>        return E_NOINTERFACE; <br>    } else { <br>m_pOverlay-&gt;Release(); <br>m_pOverlay = NULL; <br>    } <br> <br>    return CBasePin::CheckConnect(pPin); <br>} <br> <br> <br>// Overridden to connect with IOverlay instead of IMemInputPin <br>// <br>HRESULT CVidOverlay::Active() <br>{ <br>    DbgLog((LOG_TRACE,2,TEXT("CVidOverlay Stop-&gt;Pause"))); <br>    // don't let the base class Active() get called for non-IMemInput pins <br>    return NOERROR; <br>} <br> <br> <br>// Overridden to connect with IOverlay instead of IMemInputPin <br>// <br>HRESULT CVidOverlay::Inactive() <br>{ <br>    DbgLog((LOG_TRACE,2,TEXT("CVidOverlay Pause-&gt;Stop"))); <br> <br>    // we made our own capture window since the capture pin doesn't have one <br>    if (m_pCap-&gt;m_pCapturePin-&gt;m_hwCapCapturing == NULL &amp;&amp; m_hwndCap) <br>DestroyCaptureWindow(m_hwndCap); <br> <br>    // don't let the base class Inactive() get called for non-IMemInput pins <br>    return NOERROR; <br>} <br> <br> <br>// we want to know when we start running... that's when we are supposed <br>// to start previewing... NOT when we start streaming like normal filters <br>// (when paused) <br>// <br>HRESULT CVidOverlay::ActiveRun(REFERENCE_TIME tStart) <br>{ <br>    DbgLog((LOG_TRACE,2,TEXT("CVidOverlay Pause-&gt;Run"))); <br> <br>    ASSERT(m_pCap-&gt;m_pOverlayPin-&gt;IsConnected()); <br> <br>    m_fRunning = TRUE; <br> <br>    // something's wrong... <br>    if (m_pOverlay == NULL) <br>return NOERROR; <br> <br>    m_hwndCap = m_pCap-&gt;m_pCapturePin-&gt;m_hwCapCapturing; <br> <br>    HWND hwndRender; <br>    m_pOverlay-&gt;GetWindowHandle(&amp;hwndRender); <br>    if (hwndRender == NULL) <br>return NOERROR; <br> <br>    // it appears the capture pin is not connected up.  We'll need to make <br>    // our own capture window.  We'll destroy it when we stop, so we never <br>    // get confused if somebody connects the capture pin up after that. <br>    if (m_hwndCap == NULL) { <br>        DbgLog((LOG_TRACE,2,TEXT("OVERLAY creating its own capwin"))); <br>        // this will make the cap win a child of the renderer <br>m_hwndCap = CreateCaptureWindow(hwndRender); <br>if (m_hwndCap == NULL) <br>   return NOERROR; <br>    } else { <br>// !!! THIS HANGS IN SEND MESSAGE in SetWindowLong! <br>        // make the capture window a child of the renderer so it moves with <br>        // the renderer window and overlay will appear in the renderer window <br>        LONG lStyle = GetWindowLong(m_hwndCap, GWL_STYLE); <br>        lStyle |= WS_CHILD; <br>        SetWindowLong(m_hwndCap, GWL_STYLE, lStyle); <br>        SetParent(m_hwndCap, hwndRender); <br>    } <br> <br>    // now turn overlay ON <br>    DbgLog((LOG_TRACE,2,TEXT("Turning OVERLAY ON"))); <br>    capOverlay(m_hwndCap, TRUE); <br> <br>    return NOERROR; <br>} <br> <br> <br>// we need to stop overlay when we transition from RUN to PAUSE... not <br>// from PAUSE to STOP like normal filters -- that's the rule for capture <br>// filters <br>// <br>HRESULT CVidOverlay::ActivePause() <br>{ <br>    DbgLog((LOG_TRACE,2,TEXT("CVidOverlay Run-&gt;Pause"))); <br> <br>    m_fRunning = FALSE; <br> <br>    // turn overlay off and stop being a child of the renderer <br>    if (m_hwndCap) { <br>        DbgLog((LOG_TRACE,2,TEXT("Turning OVERLAY off"))); <br>        capOverlay(m_hwndCap, FALSE); <br>        LONG lStyle = GetWindowLong(m_hwndCap, GWL_STYLE); <br>        lStyle &amp;= ~WS_CHILD; <br>        SetWindowLong(m_hwndCap, GWL_STYLE, lStyle); <br>        SetParent(m_hwndCap, NULL); <br>    } <br> <br>    return NOERROR; <br>} <br> <br> <br>// make a capture window for our overlay pin, and make it a child of the <br>// video renderer window passed in <br>// <br>HWND CVidOverlay::CreateCaptureWindow(HWND hwndP) <br>{ <br>    BOOL bErr; <br> <br>    HWND hwndCapture;   // The window to return <br> <br>    // make the capture window a child of the renderer window passed in <br>    hwndCapture = capCreateCaptureWindow(NULL, WS_CHILD | WS_VISIBLE, <br>                                         0, 0, 150, 150, <br>                                         hwndP, 261 /* ID */); <br> <br>    if (!hwndCapture) { <br>        DbgLog((LOG_ERROR|LOG_TRACE, 1, TEXT("CAP Window could not be created") )); <br>        return NULL; <br>    } <br>    //DbgLog((LOG_TRACE,2,TEXT("OVERLAY created capture window"))); <br> <br>    // connect to the hardware device we're supposed to use <br>    bErr = capDriverConnect(hwndCapture, <br>m_pCap-&gt;m_pCapturePin-&gt;m_uiDriverIndex); <br>    if (!bErr) { <br>        DestroyWindow(hwndCapture); <br>        DbgLog((LOG_ERROR|LOG_TRACE, 1, TEXT("Driver failed to connect") ) ); <br>        return NULL; <br>    } <br> <br>    return hwndCapture; <br>} <br> <br> <br>// Disconnect the driver before destroying the window. <br>// <br>BOOL CVidOverlay::DestroyCaptureWindow(HWND hwnd) <br>{ <br> <br>    ASSERT(hwnd != NULL); <br> <br>    // !!! why is this failing? <br>    BOOL bDriverDisconnected = capDriverDisconnect(hwnd); <br>    //DbgLog((LOG_TRACE,2,TEXT("Driver disconnect: %x"), bDriverDisconnected)); <br> <br>    BOOL bWindowGone = DestroyWindow(hwnd); <br>    //DbgLog((LOG_TRACE,2,TEXT("Window destroy: %x"), bWindowGone)); <br> <br>    return (bDriverDisconnected &amp;&amp; bWindowGone); <br>} <br> <br> <br>// <br>// PIN CATEGORIES - let the world know that we are a PREVIEW pin <br>// <br> <br>HRESULT CVidOverlay::Set(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData, DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData) <br>{ <br>    return E_NOTIMPL; <br>} <br> <br>// To get a property, the caller allocates a buffer which the called <br>// function fills in.  To determine necessary buffer size, call Get with <br>// pPropData=NULL and cbPropData=0. <br>HRESULT CVidOverlay::Get(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData, DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData, DWORD *pcbReturned) <br>{ <br>    if (guidPropSet != AMPROPSETID_Pin) <br>return E_PROP_SET_UNSUPPORTED; <br> <br>    if (dwPropID != AMPROPERTY_PIN_CATEGORY) <br>return E_PROP_ID_UNSUPPORTED; <br> <br>    if (pPropData == NULL &amp;&amp; pcbReturned == NULL) <br>return E_POINTER; <br> <br>    if (pcbReturned) <br>*pcbReturned = sizeof(GUID); <br> <br>    if (pPropData == NULL) <br>return S_OK; <br> <br>    if (cbPropData &lt; sizeof(GUID)) <br>return E_UNEXPECTED; <br> <br>    *(GUID *)pPropData = PIN_CATEGORY_PREVIEW; <br>    return S_OK; <br>} <br> <br> <br>// QuerySupported must either return E_NOTIMPL or correctly indicate <br>// if getting or setting the property set and property is supported. <br>// S_OK indicates the property set and property ID combination is <br>HRESULT CVidOverlay::QuerySupported(REFGUID guidPropSet, DWORD dwPropID, DWORD *pTypeSupport) <br>{ <br>    if (guidPropSet != AMPROPSETID_Pin) <br>return E_PROP_SET_UNSUPPORTED; <br> <br>    if (dwPropID != AMPROPERTY_PIN_CATEGORY) <br>return E_PROP_ID_UNSUPPORTED; <br> <br>    if (pTypeSupport) <br>*pTypeSupport = KSPROPERTY_SUPPORT_GET; <br>    return S_OK; <br>} <br> <br> <br> <br> <br>//=========================================================================// <br>//***I N T E R M I S S I O N***// <br>//=========================================================================// <br> <br> <br> <br> <br>/* <br>        IOverlayNotify - how the renderer tells us where the window is <br> and when it needs repainting <br>*/ <br> <br>CVidOverlayNotify::CVidOverlayNotify(TCHAR              * pName, <br>                               CVidCap   * pFilter, <br>                               LPUNKNOWN            pUnk, <br>                               HRESULT            * phr) : <br>    CUnknown(pName, pUnk) <br>{ <br>    DbgLog((LOG_TRACE,1,TEXT("*Instantiating CVidOverlayNotify"))); <br>    m_pFilter = pFilter; <br>    m_rcClient.top = -1;// something unusual <br>} <br> <br> <br>CVidOverlayNotify::~CVidOverlayNotify() <br>{ <br>    DbgLog((LOG_TRACE,1,TEXT("*Destroying CVidOverlayNotify"))); <br>} <br> <br> <br>STDMETHODIMP CVidOverlayNotify::NonDelegatingQueryInterface(REFIID riid, <br>                                                         void ** ppv) <br>{ <br>    DbgLog((LOG_TRACE,99,TEXT("CVidOverlayNotify::QueryInterface"))); <br>    if (ppv) <br>*ppv = NULL; <br> <br>    /* Do we have this interface */ <br> <br>    if (riid == IID_IOverlayNotify) { <br>        return GetInterface((LPUNKNOWN) (IOverlayNotify *) this, ppv); <br>    } else { <br>        return CUnknown::NonDelegatingQueryInterface(riid, ppv); <br>    } <br>} <br> <br> <br>STDMETHODIMP_(ULONG) CVidOverlayNotify::NonDelegatingRelease() <br>{ <br>    return m_pFilter-&gt;Release(); <br>} <br> <br> <br>STDMETHODIMP_(ULONG) CVidOverlayNotify::NonDelegatingAddRef() <br>{ <br>    return m_pFilter-&gt;AddRef(); <br>} <br> <br> <br>STDMETHODIMP CVidOverlayNotify::OnColorKeyChange( <br>    const COLORKEY *pColorKey)          // Defines new colour key <br>{ <br>    DbgLog((LOG_TRACE,3,TEXT("CVidOverlayNotify::OnColorKeyChange"))); <br> <br>// We expect the hardware to handle colour key stuff, so I'm really <br>// hoping that the renderer will never draw the colour key itself. <br> <br>    return NOERROR; <br>} <br> <br> <br>// The calls to OnClipChange happen in sync with the window. So it's called <br>// with an empty clip list before the window moves to freeze the video, and <br>// then when the window has stabilised it is called again with the new clip <br>// list. The OnPositionChange callback is for overlay cards that don't want <br>// the expense of synchronous clipping updates and just want to know when <br>// the source or destination video positions change. They will NOT be called <br>// in sync with the window but at some point after the window has changed <br>// (basicly in time with WM_SIZE etc messages received). This is therefore <br>// suitable for overlay cards that don't inlay their data to the framebuffer <br> <br>STDMETHODIMP CVidOverlayNotify::OnClipChange( <br>    const RECT    * pSourceRect,         // Area of source video to use <br>    const RECT    * pDestinationRect,    // screen co-ords of window <br>    const RGNDATA * pRegionData)         // Header describing clipping <br>{ <br> <br>    // we get a LOT of these messages.  Try to save time by ignore many <br>    // of them <br> <br>    if (!m_pFilter-&gt;m_pOverlayPin) <br>return NOERROR; <br> <br>    if (!m_pFilter-&gt;m_pOverlayPin-&gt;IsConnected()) <br>return NOERROR; <br> <br>    if (IsRectEmpty(pSourceRect) &amp;&amp; IsRectEmpty(pDestinationRect)) <br>return NOERROR; <br> <br>    HWND hwnd = NULL; <br>    RECT rcC; <br>    if (m_pFilter-&gt;m_pOverlayPin-&gt;m_pOverlay) <br>        m_pFilter-&gt;m_pOverlayPin-&gt;m_pOverlay-&gt;GetWindowHandle(&amp;hwnd); <br> <br>    if (hwnd == NULL || !IsWindowVisible(hwnd)) <br>return NOERROR; <br> <br>    // It's up to us to keep garbage out of the window by painting it if <br>    // we're not running, and the hardware has nothing to draw <br>    if (!m_pFilter-&gt;m_pOverlayPin-&gt;m_fRunning) { <br>        HDC  hdc; <br>        if (hwnd) <br>    hdc = GetDC(hwnd); <br>        if (hdc == NULL) <br>    return NOERROR; <br>GetClientRect(hwnd, &amp;rcC); <br>HBRUSH hbrOld = (HBRUSH)SelectObject(hdc, GetStockObject(BLACK_BRUSH)); <br>PatBlt(hdc, 0, 0, rcC.right, rcC.bottom, PATCOPY); <br>SelectObject(hdc, hbrOld); <br>        ReleaseDC(hwnd, hdc); <br>return NOERROR; <br>    } <br> <br>    DbgLog((LOG_TRACE,3,TEXT("OnClip/PositionChange (%d,%d) (%d,%d)"), <br>        pSourceRect-&gt;right - pSourceRect-&gt;left, <br>        pSourceRect-&gt;bottom - pSourceRect-&gt;top, <br>        pDestinationRect-&gt;right - pDestinationRect-&gt;left, <br>        pDestinationRect-&gt;bottom - pDestinationRect-&gt;top)); <br> <br>    // make the capture window fill up the renderer window <br>    if (m_pFilter-&gt;m_pOverlayPin-&gt;m_hwndCap) { <br>        GetClientRect(hwnd, &amp;rcC); <br>        if (rcC.left != m_rcClient.left || rcC.top != m_rcClient.top || <br>        rcC.right != m_rcClient.right || <br>rcC.bottom != m_rcClient.bottom) { <br>    SetWindowPos(m_pFilter-&gt;m_pOverlayPin-&gt;m_hwndCap, NULL, <br>rcC.left, rcC.top, rcC.right, rcC.bottom, SWP_NOZORDER); <br>            DbgLog((LOG_TRACE,3,TEXT("Moving CAPWIN to (%d,%d,%d,%d)"), <br>rcC.left, rcC.top, rcC.right, rcC.bottom)); <br>    m_rcClient = rcC; <br>} <br>    } <br> <br>    return NOERROR; <br>} <br> <br> <br>STDMETHODIMP CVidOverlayNotify::OnPaletteChange( <br>    DWORD dwColors,                     // Number of colours present <br>    const PALETTEENTRY *pPalette)       // Array of palette colours <br>{ <br>    DbgLog((LOG_TRACE,3,TEXT("CVidOverlayNotify::OnPaletteChange"))); <br> <br>    return NOERROR; <br>} <br> <br> <br>STDMETHODIMP CVidOverlayNotify::OnPositionChange( <br>    const RECT *pSourceRect,            // Area of video to play with <br>    const RECT *pDestinationRect)       // Area video goes <br>{ <br> <br>    return OnClipChange(pSourceRect, pDestinationRect, NULL); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
