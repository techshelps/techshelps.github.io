<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>VIDCAP.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2961"></a>VIDCAP.H</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>// <br>//  Video capture stream source filter <br>// <br> <br>// - Uses the CSource/CSourceStream classes to create a video capture filter. <br>// - Uses the AVICap capXXX macros to capture from the first driver it finds. <br> <br>// CLSID_VidCap <br>// {fd501040-8ebe-11ce-8183-00aa00577da1} <br>DEFINE_GUID(CLSID_VidCap, <br>0xfd501040, 0x8ebe, 0x11ce, 0x81, 0x83, 0x00, 0xaa, 0x00, 0x57, 0x7d, 0xa1); <br> <br> <br>// align a dw to an arbitrary size <br>#define ALIGNUP(dw,align) ((long)(((long)(dw)+(align)-1) / (align)) * (align)) <br> <br>// forward declarations <br>class CVidOverlay; <br>class CVidPreview; <br> <br>// The buffer sizes required for driver name and version strings <br>const int giDriverNameStrLen = 80; <br>const int giDriverVerStrLen  = 40; <br> <br>class CVidStream;       // manages the output stream &amp; pin <br>class CVideoBufferList; // A place to store filled buffers before we can send <br>                        // them downstream <br> <br> <br>// <br>// CVidCap <br>// <br>// The VidCap filter object. Provides the IBaseFilter/IMediaFilter interfaces. <br>// IPersistPropertyBag must be supported to find out what device to use <br>// (this filter works with many video cards) <br>// CPersistStream must be supported so a .GRF file with this filter in it <br>// can be re-created with the right device <br>// IAMVfwCaptureDialogs is supported to bring up the VfW capture driver <br>// dialog boxes.  A filter that does not work with the VfW capture drivers <br>// will NOT support this interface <br>class CVidCap : public CSource, public IPersistPropertyBag, <br>  public IAMVfwCaptureDialogs, public CPersistStream <br>{ <br> <br>public: <br> <br>    // Construct a VidCap filter <br>    static CUnknown * WINAPI CreateInstance(LPUNKNOWN lpunk, HRESULT *phr); <br> <br>    CCritSec m_cStateLock;      // Lock this when a function accesses <br>                                // the filter state. <br>                                // Generally _all_ functions, since access to <br>                                // this filter will be by multiple threads. <br> <br>    DECLARE_IUNKNOWN <br> <br>    // reveals our interfaces <br>    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv); <br> <br>    int GetPinCount(); <br>    CBasePin * GetPin(int ix); <br> <br>    // overide the Run &amp; Pause methods so that I can notify the pin <br>    // of the state it should move to - also needed for CBaseStreamControl <br>    STDMETHODIMP Run(REFERENCE_TIME tStart); <br>    STDMETHODIMP Pause(void); <br>    STDMETHODIMP Stop(void); <br> <br>    // live source - override GetState to return VFW_S_CANT_CUE when pausing <br>    // since we won't be sending any data when paused <br>    STDMETHODIMP GetState(DWORD dwMSecs, FILTER_STATE *State); <br> <br>    // IAMVfwCaptureDialogs stuff <br>    STDMETHODIMP HasDialog(int iDialog); <br>    STDMETHODIMP ShowDialog(int iDialog, HWND hwnd); <br>    STDMETHODIMP SendDriverMessage(int iDialog, int uMsg, long dw1, long dw2); <br> <br>    // for IAMStreamControl <br>    STDMETHODIMP SetSyncSource(IReferenceClock *pClock); <br>    STDMETHODIMP JoinFilterGraph(IFilterGraph * pGraph, LPCWSTR pName); <br> <br>    // IPersistPropertyBag methods <br>    STDMETHODIMP InitNew(); <br>    STDMETHODIMP Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog); <br>    STDMETHODIMP Save(LPPROPERTYBAG pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties); <br> <br>    // CPersistStream <br>    HRESULT WriteToStream(IStream *pStream); <br>    HRESULT ReadFromStream(IStream *pStream); <br>    int SizeMax(); <br>    STDMETHODIMP GetClassID(CLSID *pClsid); <br> <br>    STDMETHODIMP FindPin( <br>        LPCWSTR Id, <br>        IPin ** ppPin <br>    ); <br>private: <br> <br>    // During construction we create the single CVidStream object that provides <br>    // the capture output pin. <br>    CVidCap(TCHAR *, LPUNKNOWN, HRESULT *); <br>    ~CVidCap(); <br>    void CreatePins(HRESULT *phr); <br> <br>    CVidOverlay *CreateOverlayPin(HRESULT *phr); <br>    CVidPreview *CreatePreviewPin(HRESULT *phr); <br> <br>    CVidStream  *m_pCapturePin;// our capture pin <br>    CVidOverlay *m_pOverlayPin;// our h/w overlay preview pin <br>    CVidPreview *m_pPreviewPin;// our non h/w overlay preview pin <br> <br>    int m_iVideoId;// which device to use <br> <br>    friend class CVidStream; <br>    friend class CVideoBufferList; <br>    friend class CVidOverlay; <br>    friend class CVidPreview; <br>    friend class CVidOverlayNotify; <br>}; <br> <br> <br>// <br>// CVidStream <br>// <br>// Manages the output pin and the video capture device. <br>// Video capture pins are supposed to support all of these interfaces <br>class CVidStream : public CSourceStream, public CBaseStreamControl, <br>   public IAMVideoCompression, public IAMStreamConfig, <br>   public IAMDroppedFrames, public IAMBufferNegotiation, <br>   public IKsPropertySet <br>{ <br> <br>public: <br> <br>    CVidStream( TCHAR           *pObjectName <br>              , HRESULT         *phr <br>              , CVidCap         *pParentFilter <br>              , unsigned int    uiDriverIndex <br>              , LPCWSTR         pPinName <br>              ); <br> <br>    ~CVidStream(); <br> <br>    // <br>    //  --- CSourceStream implementation --- <br>    // <br>public: <br> <br>    HRESULT DecideBufferSize(IMemAllocator *pAlloc, <br>                             ALLOCATOR_PROPERTIES *pProperties); <br> <br>    // helper reconnect function.  We can reconnect everything, or just <br>    // the preview pin because the capture pin changed <br>    void Reconnect(BOOL fCapturePinToo); <br> <br>    // IKsPropertySet stuff - to tell the world we are a "capture" type pin <br>    STDMETHODIMP Set(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData, <br>DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData); <br>    STDMETHODIMP Get(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData, <br>DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData, <br>DWORD *pcbReturned); <br>    STDMETHODIMP QuerySupported(REFGUID guidPropSet, DWORD dwPropID, <br>DWORD *pTypeSupport); <br> <br>    // IAMStreamConfig stuff <br>    STDMETHODIMP SetFormat(AM_MEDIA_TYPE *pmt); <br>    STDMETHODIMP GetFormat(AM_MEDIA_TYPE **ppmt); <br>    STDMETHODIMP GetNumberOfCapabilities(int *piCount, int *piSize); <br>    STDMETHODIMP GetStreamCaps(int i, AM_MEDIA_TYPE **ppmt, LPBYTE pSCC); <br> <br>    /* IAMVideoCompression methods */ <br>    STDMETHODIMP put_KeyFrameRate(long KeyFrameRate) {return E_NOTIMPL;}; <br>    STDMETHODIMP get_KeyFrameRate(long *pKeyFrameRate) {return E_NOTIMPL;}; <br>    STDMETHODIMP put_WindowSize(DWORDLONG WindowSize) {return E_NOTIMPL;}; <br>    STDMETHODIMP get_WindowSize(DWORDLONG *pWindowSize) {return E_NOTIMPL;}; <br>    STDMETHODIMP put_PFramesPerKeyFrame(long PFramesPerKeyFrame) <br>{return E_NOTIMPL;}; <br>    STDMETHODIMP get_PFramesPerKeyFrame(long *pPFramesPerKeyFrame) <br>{return E_NOTIMPL;}; <br>    STDMETHODIMP put_Quality(double Quality) {return E_NOTIMPL;}; <br>    STDMETHODIMP get_Quality(double *pQuality) {return E_NOTIMPL;}; <br>    STDMETHODIMP OverrideKeyFrame(long FrameNumber) {return E_NOTIMPL;}; <br>    STDMETHODIMP OverrideFrameSize(long FrameNumber, long Size) <br>{return E_NOTIMPL;}; <br>    STDMETHODIMP GetInfo(LPWSTR pstrVersion, <br>int *pcbVersion, <br>LPWSTR pstrDescription, <br>int *pcbDescription, <br>long *pDefaultKeyFrameRate, <br>long *pDefaultPFramesPerKey, <br>double *pDefaultQuality, <br>long *pCapabilities); <br> <br>    /* IAMBufferNegotiation methods */ <br>    STDMETHODIMP SuggestAllocatorProperties(const ALLOCATOR_PROPERTIES *pprop); <br>    STDMETHODIMP GetAllocatorProperties(ALLOCATOR_PROPERTIES *pprop); <br> <br> <br>    /* IAMDroppedFrames methods */ <br>    STDMETHODIMP GetNumDropped(long *plDropped); <br>    STDMETHODIMP GetNumNotDropped(long *plNotDropped); <br>    STDMETHODIMP GetDroppedInfo(long lSize, long *plArray, <br>long *plNumCopied); <br>    STDMETHODIMP GetAverageFrameSize(long *plAverageSize); <br> <br>    // <br>    // --- Worker Thread fn's --- <br>    // <br>    HRESULT OnThreadCreate(void); <br>    HRESULT OnThreadDestroy(void); <br> <br>    HRESULT DoBufferProcessingLoop(void); <br>    HRESULT FillBuffer(IMediaSample *pSamp); <br> <br>    HRESULT Inactive(void); <br> <br>    // Override to handle quality messages <br>    STDMETHODIMP Notify(IBaseFilter * pSender, Quality q); <br> <br> <br>    STDMETHODIMP QueryId( <br>        LPWSTR * Id <br>    ); <br>     <br>public: <br> <br>    DECLARE_IUNKNOWN; <br> <br>    // reveals our interfaces <br>    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv); <br> <br>private:        // State shared between worker &amp; client <br>    CCritSec            m_cSharedState;     // Lock this to access this state, <br>                                            // shared with the worker thread <br> <br>    unsigned int        m_uiDriverIndex;    // the device to open when active <br>    HWND                m_hwCapCapturing;   // The AVI capture window, <br>                                            // used whilst active <br>    CVideoBufferList    *m_plFilled;        // The buffers AVICap has filled, <br>                                            // but that haven't been sent yet. <br>                                            // NB This has its own critical <br>                                            // section, so m_cSharedState does <br>                                            // not need to be locked for access <br> <br>    DWORD               m_dwMicroSecPerFrame;   // The current number of <br>                                            // microseconds between each frame <br>    ALLOCATOR_PROPERTIES m_propSuggested;   // IAMBufferNegotiation <br>    ALLOCATOR_PROPERTIES m_propActual;      // what the allocator is using <br>    BOOLm_fSetFormatCalled; // restricted to using this? <br> <br>private:        // thread state. No peeking/writing by anyone else! <br> <br>    enum ThreadState { Stopped,         // will exit soon, or just started <br>                       Paused,          // generate a poster frame if entered <br>                                        // from stop <br>                       Running          // streaming data downstream <br>                     }; <br>    ThreadState m_ThreadState; <br> <br> <br>private:        // Capture Support <br> <br>    HRESULT GetMediaType(CMediaType *pmt); <br>    HRESULT CheckMediaType(const CMediaType *pmt); <br>    HRESULT SetMediaType(const CMediaType *pmt); <br>    HRESULT BreakConnect(); <br> <br>    long    GetSampleSize(LPBITMAPINFOHEADER pbmi);   // Calculate the sample <br>                                                      // size needed. <br> <br>    HWND CreateCaptureWindow(long lBufferCount);// Create the AVICap window <br>                                            // invisibly. Balance with <br>                                            // calls to DestroyCaptureWindow. <br>                                            // This is the function that grabs <br>                                            // resources. The filter holds no <br>                                            // resources (the capture driver) <br>                                            // until it is called <br>    BOOL DestroyCaptureWindow(HWND hwnd);   // Destroy an AVICap window, <br>                                            // release resources <br> <br>    // put the buffer we are given onto the filled list for delivery downstream <br>    static LRESULT CALLBACK VideoCallback(HWND hwnd, LPVIDEOHDR lpVHdr); <br> <br> <br>private: <br> <br>    WCHAR m_szName[giDriverNameStrLen];         // The driver's name <br>    WCHAR m_szVersion[giDriverVerStrLen];       // The driver's version <br> <br>    BOOL m_SupportsVideoSourceDialog;           // The dialogs this driver supports <br>    BOOL m_SupportsVideoDisplayDialog;          // <br>    BOOL m_SupportsVideoFormatDialog;           // <br>    BOOL m_HasOverlay;           // device does h/w overlay <br>#if 0 <br>    BOOL m_UsesPalettes;// does the driver use a palette? <br>    BOOL m_SuppliesPalettes;// can the driver give us a palette? <br>#endif <br> <br>    // for IAMDroppedFrames <br>    unsigned int                m_uiFramesCaptured; <br>    LONGLONG                    m_llTotalFrameSize; <br>    unsigned int                m_uiFramesSkipped; <br>    unsigned int                m_uiFramesDelivered; <br> <br>    friend class CVidCap; <br>    friend class CVideoBufferList; <br>    friend class CVidOverlay; <br>    friend class CVidPreview; <br>    friend class CVidOverlayNotify; <br>}; <br> <br> <br>// <br>// CVideoBufferList <br>// <br>// This list is a place to store a buffer that AVIcap gives to us, before we can <br>// pass them on to the next filter downstream. <br>// Constructs a list of free buffers on construction. <br>class CVideoBufferList { <br> <br>public: <br> <br>    CVideoBufferList( int iBufferSize <br>                    , DWORD dwMicroSecPerFrame <br>                    , CVidCap *pFilter <br>                    , int iBuffers <br>                    ); <br>    ~CVideoBufferList(); <br> <br>    HRESULT Add(LPVIDEOHDR lpVHdr); <br>    HRESULT RemoveHeadIntoSample(IMediaSample *pSample); <br> <br>    HANDLE GetWaitHandle() { <br>        return (HANDLE)m_evList; <br>    } <br> <br>    // * <br>    // * CBuffer <br>    // * <br> <br>    // This is a class to store the data given to us by AVICap. <br>    // This must copy the data it is given, as we don't know what AVICap <br>    // does to its buffers. <br>    class CBuffer { <br> <br>    public: <br> <br>        CBuffer(int iBufferSize);       // prepares an iBufferSize'd memory buffer <br>        ~CBuffer();                     // frees the data buffer <br> <br>        BYTE            *GetPointer() const {return m_pData;} <br>        void            CopyBuffer(LPVIDEOHDR lpVHdr, CRefTime&amp; rt, LONGLONG llTime); <br>        int             GetSize() const {return m_iCaptureDataLength;} <br>        // The time for this sample to be presented <br>        CRefTime        GetCaptureTime() const {return m_rt;} <br>// The frame number <br>        LONGLONG        GetCaptureFrame() const {return m_llFrame;} <br> <br>    private: <br> <br>        BYTE            *m_pData;       // The data stored in this buffer <br>        int             m_iDataLength;  // m_pData's length <br>int             m_iCaptureDataLength;  // length returned from device <br> <br>        CRefTime        m_rt;           // The stream time for this sample. <br>        LONGLONG        m_llFrame;      // The frame number <br>BOOLm_fSyncPoint;// for setting sample flags <br>BOOLm_fDiscontinuity;// for setting sample flags <br> <br>friend class CVideoBufferList; <br>    }; <br> <br>private: <br> <br>    CCritSec                    m_ListCrit;     // Serialize lists <br>    CAMEvent                      m_evList;       // New element on list <br>    CGenericList&lt;CBuffer&gt;       m_lFilled; <br>    CGenericList&lt;CBuffer&gt;       m_lFree; <br> <br>    CVidCap                     *m_pFilter; <br> <br>    BOOL                        m_FirstBuffer; <br> <br>    DWORD                       m_dwMicroSecPerFrame; <br>    CRefTime                    m_rtStartTime; <br>    BOOLm_fLastSampleDiscarded; <br> <br>    // the Time and MediaTime of the last frame delivered <br>    REFERENCE_TIMEm_rtLastStartTime; <br>    LONGLONGm_llLastFrame; <br> <br>    // Did somebody do Run-&gt;Pause-&gt;Run to the graph? <br>    BOOLm_fReRun; <br> <br>    // frame offset to add to the MediaTime - explained in the code <br>    LONGLONGm_llFrameOffset; <br> <br>    int m_iPreviewCount;// send a preview frame every 30th frame <br> <br>    friend class CVidStream; <br>}; <br> <br> <br>// CVidOverlayNotify <br>// where the video renderer informs us of window moves/clips so we can fix <br>// the overlay <br>// <br>class CVidOverlayNotify : public CUnknown, public IOverlayNotify <br>{ <br>    public: <br>        /* Constructor and destructor */ <br>        CVidOverlayNotify(TCHAR              *pName, <br>                       CVidCap  *pFilter, <br>                       LPUNKNOWN           pUnk, <br>                       HRESULT            *phr); <br>        ~CVidOverlayNotify(); <br> <br>        /* Unknown methods */ <br> <br>        DECLARE_IUNKNOWN <br> <br>        STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv); <br>        STDMETHODIMP_(ULONG) NonDelegatingRelease(); <br>        STDMETHODIMP_(ULONG) NonDelegatingAddRef(); <br> <br>        /* IOverlayNotify methods */ <br> <br>        STDMETHODIMP OnColorKeyChange( <br>            const COLORKEY *pColorKey);         // Defines new colour key <br> <br>        STDMETHODIMP OnClipChange( <br>            const RECT *pSourceRect,            // Area of video to play <br>            const RECT *pDestinationRect,       // Area of video to play <br>            const RGNDATA *pRegionData);        // Header describing clipping <br> <br>        STDMETHODIMP OnPaletteChange( <br>            DWORD dwColors,                     // Number of colours present <br>            const PALETTEENTRY *pPalette);      // Array of palette colours <br> <br>        STDMETHODIMP OnPositionChange( <br>            const RECT *pSourceRect,            // Area of video to play with <br>            const RECT *pDestinationRect);      // Area video goes <br> <br>    private: <br>        CVidCap *m_pFilter; <br>        RECT     m_rcClient;// how big the preview window is <br> <br>} ; <br> <br> <br>// CVidOverlay <br>// If the capture card supports hardware overlay, this kind of pin will <br>// be made for a preview pin and connect to the renderer using IOverlay <br>// Hardware overlay preview is free... there's no point ever turning it <br>// off, so we don't support CBaseStreamControl (IAMStreamControl) <br>// <br>class CVidOverlay : public CBaseOutputPin, public IKsPropertySet <br>{ <br>public: <br>    CVidOverlay( <br>        TCHAR *pObjectName, <br>        CVidCap *pCapture, <br>        HRESULT * phr, <br>        LPCWSTR pName); <br> <br>    virtual ~CVidOverlay(); <br> <br>    DECLARE_IUNKNOWN <br> <br>    // reveals our interfaces <br>    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv); <br> <br>    // IKsPropertySet stuff - to tell the world we are a "preview" type pin <br>    STDMETHODIMP Set(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData, <br>DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData); <br>    STDMETHODIMP Get(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData, <br>DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData, <br>DWORD *pcbReturned); <br>    STDMETHODIMP QuerySupported(REFGUID guidPropSet, DWORD dwPropID, <br>DWORD *pTypeSupport); <br> <br>    HRESULT GetMediaType(int iPosition, CMediaType* pt); <br> <br>    // check if the pin can support this specific proposed type&amp;format <br>    HRESULT CheckMediaType(const CMediaType*); <br> <br>    // override this to not do anything with allocators <br>    HRESULT DecideAllocator(IMemInputPin *pPin, <br>                           IMemAllocator **ppAlloc); <br> <br>    // override these to use IOverlay, not IMemInputPin <br>    STDMETHODIMP Connect(IPin *pReceivePin, const AM_MEDIA_TYPE *pmt); <br>    HRESULT BreakConnect(); <br>    HRESULT CheckConnect(IPin *pPin); <br> <br>    HRESULT Active();// Stop--&gt;Pause <br>    HRESULT Inactive();// Pause--&gt;Stop <br>    HRESULT ActiveRun(REFERENCE_TIME tStart);// Pause--&gt;Run <br>    HRESULT ActivePause();// Run--&gt;Pause <br> <br>    // say how big our buffers should be and how many we want <br>    HRESULT DecideBufferSize(IMemAllocator * pAllocator, <br>                            ALLOCATOR_PROPERTIES *pProperties) <br>    { <br>return NOERROR; <br>    }; <br> <br>private: <br>    HWND CreateCaptureWindow(HWND hwnd); <br>    BOOL DestroyCaptureWindow(HWND hwnd); <br> <br>    CVidCap     * m_pCap;     // parent <br>    IOverlay    * m_pOverlay; // Overlay window on output pin <br>    CVidOverlayNotify m_OverlayNotify; // Notify object <br>    BOOL         m_bAdvise;   // Advise id <br>    BOOLm_fRunning;  // am I running? <br>    HWNDm_hwndCap;   // the capture window to use <br> <br>    friend class CVidCap; <br>    friend class CVidOverlayNotify; <br>}; <br> <br> <br>// CVidPreview <br>// for devices that do NOT do hardware overlay, we will be nice and provide <br>// a preview ourselves, even though the device doesn't support it.  We'll do <br>// it by noticing when we have free time, and copying some frames and sending <br>// them out the preview pin.  We'll make sure we never hurt capture <br>// performance by doing so. <br>// <br>class CVidPreview : public CBaseOutputPin, public CBaseStreamControl, <br>    public IKsPropertySet <br>{ <br>public: <br>    CVidPreview( <br>        TCHAR *pObjectName, <br>        CVidCap *pCapture, <br>        HRESULT * phr, <br>        LPCWSTR pName); <br> <br>    virtual ~CVidPreview(); <br> <br>    DECLARE_IUNKNOWN <br> <br>    // override this to say what interfaces we support where <br>    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv); <br> <br>    // IKsPropertySet stuff - to tell the world we are a "preview" type pin <br>    STDMETHODIMP Set(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData, <br>DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData); <br>    STDMETHODIMP Get(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData, <br>DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData, <br>DWORD *pcbReturned); <br>    STDMETHODIMP QuerySupported(REFGUID guidPropSet, DWORD dwPropID, <br>DWORD *pTypeSupport); <br> <br>    HRESULT GetMediaType(int iPosition, CMediaType* pt); <br> <br>    // check if the pin can support this specific proposed type&amp;format <br>    HRESULT CheckMediaType(const CMediaType*); <br> <br>    HRESULT ActiveRun(REFERENCE_TIME tStart);// Pause--&gt;Run <br>    HRESULT ActivePause();// Run--&gt;Pause <br>    HRESULT Active();// Stop--&gt;Pause <br>    HRESULT Inactive();// Pause--&gt;Stop <br> <br>    STDMETHODIMP Notify(IBaseFilter *pFilter, Quality q); <br> <br>    // say how big our buffers should be and how many we want <br>    HRESULT DecideBufferSize(IMemAllocator * pAllocator, <br>                            ALLOCATOR_PROPERTIES *pProperties); <br> <br> <br>private: <br>    static DWORD WINAPI ThreadProcInit(void *pv); <br>    DWORD ThreadProc(); <br>    HRESULT CapturePinActive(BOOL fActive); <br>    HRESULT ReceivePreviewFrame(LPVOID lpFrame, int iSize); <br>    HWND CreateCaptureWindow(); <br>    BOOL DestroyCaptureWindow(HWND hwnd); <br> <br>    CVidCap     *m_pCap;  // parent <br>    REFERENCE_TIME m_rtRun; <br>    HANDLEm_hThread; <br>    DWORDm_tid; <br>    HANDLEm_hEventRun; <br>    HANDLEm_hEventActiveChanged; <br>    CAMEvent    m_EventAdvise; <br>    DWORDm_dwAdvise; <br>    BOOLm_fCapturing;// is the streaming pin active? <br>    BOOLm_fLastSampleDiscarded;// for IAMStreamControl <br>    HWNDm_hwndCap; <br> <br>// !!! these have to be public so the video callback can get at them <br>public: <br>    LPVOIDm_lpFrame; <br>    BOOLm_fRunning; // am I streaming? <br>    intm_iFrameSize; <br>    BOOLm_fFrameValid; <br>    HANDLEm_hEventFrameValid; <br> <br>    // capGrabFrame callback <br>    static LRESULT CALLBACK VideoCallback(HWND hwnd, LPVIDEOHDR lpVHdr); <br> <br>    friend class CVidCap; <br>    friend class CVidStream; <br>    friend class CVideoBufferList; <br>}; <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
