<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PREVIEW.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2959"></a>PREVIEW.CPP</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>/* <br> <br>    Methods for CVidPreview - the preview pin that doesn't use overlay <br> <br>The basic premise here is that the driver only provides one <br>stream... we are FAKING this preview stream by only accepting <br>the same media type as our capture pin, and every once in a while <br>when the capture pin has some extra time it will send us a copy <br>of a frame to use as a preview frame.  If we had hardware that <br>can do a h/w overlay, we would have used the overlay type of <br>preview pin.  If we had hardware that can capture two streams <br>at once, we wouldn't need to fake a preview pin by duplicating <br>data going out the capture pin, but alas, we are not that lucky. <br> <br> This is tricky to do.  If the capture pin is streaming and using <br> a capture window to capture with, we can't make our own capture <br>window or make any calls to the capture pin's capture window (there <br>can be only one around at a time).  So in this case, the capture pin <br>will send us a frame every once in a while for us to copy and deliver. <br>If the capture pin is NOT active, and does not have the capture <br>device open, then we need to create our own capture window and use <br>it to capture frames and deliver them.  We will be able to switch <br>back and forth. <br> <br>This pin supports CBaseStreamControl (and thus IAMStreamControl) <br>for turning preview on and off while the graph is running <br>*/ <br> <br>#include &lt;streams.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include &lt;vfw.h&gt; <br>#include "vidcap.h" <br> <br>// CVidPreview constructor <br>// <br>CVidPreview::CVidPreview(TCHAR *pObjectName, CVidCap *pCapture, <br>        HRESULT * phr, LPCWSTR pName) <br>   : <br>   CBaseOutputPin(pObjectName, pCapture, pCapture-&gt;pStateLock(), phr, pName), <br>   m_pCap(pCapture), <br>   m_fRunning(FALSE), <br>   m_hThread(NULL), <br>   m_tid(0), <br>   m_hEventRun(NULL), <br>   m_dwAdvise(0), <br>   m_fCapturing(FALSE), <br>   m_hEventActiveChanged(NULL), <br>   m_hEventFrameValid(NULL), <br>   m_lpFrame(NULL), <br>   m_iFrameSize(0), <br>   m_fLastSampleDiscarded(FALSE), <br>   m_fFrameValid(FALSE), <br>   m_hwndCap(NULL) <br>{ <br>   DbgLog((LOG_TRACE,1,TEXT("CVidPreview constructor"))); <br>   ASSERT(pCapture); <br>} <br> <br> <br>CVidPreview::~CVidPreview() <br>{ <br>    DbgLog((LOG_TRACE,1,TEXT("*Destroying the Preview pin"))); <br>    // we left one of these hanging around <br>    if (m_hwndCap) <br>DestroyCaptureWindow(m_hwndCap); <br>}; <br> <br> <br>STDMETHODIMP CVidPreview::NonDelegatingQueryInterface(REFIID riid, void ** ppv) <br>{ <br>    if (riid == IID_IAMStreamControl) { <br>return GetInterface((LPUNKNOWN)(IAMStreamControl *)this, ppv); <br>    } else if (riid == IID_IKsPropertySet) { <br>return GetInterface((LPUNKNOWN)(IKsPropertySet *)this, ppv); <br>    } <br> <br>   return CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv); <br>} <br> <br> <br>// we can only allow being connected with the same media type as the <br>// capture pin.  It may be giving us the frames to deliver. <br>// <br>HRESULT CVidPreview::GetMediaType(int iPosition, CMediaType *pmt) <br>{ <br>    DbgLog((LOG_TRACE,3,TEXT("CVidPreview::GetMediaType #%d"), iPosition)); <br> <br>    if (iPosition &lt; 0) <br>return E_INVALIDARG; <br>    if (iPosition &gt; 0) <br>return VFW_S_NO_MORE_ITEMS; <br> <br>    // we preview the same format as we capture <br>    return m_pCap-&gt;m_pCapturePin-&gt;GetMediaType(pmt); <br>} <br> <br> <br>// We only accept what the capture pin would accept. <br>// <br>HRESULT CVidPreview::CheckMediaType(const CMediaType *pMediaType) <br>{ <br>    DbgLog((LOG_TRACE,3,TEXT("CVidPreview::CheckMediaType"))); <br> <br>    // Only accept what our capture pin is providing.  I will not switch <br>    // our capture pin over to a new format just because somebody changes <br>    // the preview pin. <br>    return m_pCap-&gt;m_pCapturePin-&gt;CheckMediaType(pMediaType); <br>} <br> <br> <br>// we are being RUN.  Time to start previewing <br>// <br>HRESULT CVidPreview::ActiveRun(REFERENCE_TIME tStart) <br>{ <br>    DbgLog((LOG_TRACE,2,TEXT("CVidPreview Pause-&gt;Run"))); <br> <br>    ASSERT(IsConnected()); <br> <br>    m_fRunning = TRUE; <br>    m_rtRun = tStart; <br> <br>    // tell our thread to start previewing <br>    SetEvent(m_hEventRun); <br> <br>    return NOERROR; <br>} <br> <br> <br>// we have stopped running.  Our thread will stop previewing <br>// <br>HRESULT CVidPreview::ActivePause() <br>{ <br>    DbgLog((LOG_TRACE,2,TEXT("CVidPreview Run-&gt;Pause"))); <br> <br>    m_fRunning = FALSE; <br> <br>    return NOERROR; <br>} <br> <br> <br>// we are starting to stream.  Time to create a thread to do preview <br>// <br>HRESULT CVidPreview::Active() <br>{ <br>    DbgLog((LOG_TRACE,2,TEXT("CVidPreview Stop-&gt;Pause"))); <br> <br>    ASSERT(IsConnected()); <br> <br>    // This event tells the thread when we are RUN or STOPPED <br>    m_hEventRun = CreateEvent(NULL, TRUE, FALSE, NULL); <br>    if (!m_hEventRun) { <br>        DbgLog((LOG_ERROR,1,TEXT("Can't create Run event"))); <br>        return E_OUTOFMEMORY; <br>    } <br> <br>    // This event is set by the thread when it notices the capture pin <br>    // going from inactive-&gt;active or vv.  We delay returning from <br>    // CapturePinActive() until the thread notices, because the capture <br>    // pin will actually go active after CapturePinActive returns and <br>    // our thread has to have closed the capture window by then. <br>    m_hEventActiveChanged = CreateEvent(NULL, TRUE, FALSE, NULL); <br>    if (!m_hEventActiveChanged) { <br>        DbgLog((LOG_ERROR,1,TEXT("Can't create ActiveChanged event"))); <br>        return E_OUTOFMEMORY; <br>    } <br> <br>    // This event tells the thread that a frame is ready to deliver.  It <br>    // might have come from the capture pin, or we might have captured it <br>    // ourself. <br>    m_hEventFrameValid = CreateEvent(NULL, TRUE, FALSE, NULL); <br>    if (!m_hEventFrameValid) { <br>        DbgLog((LOG_ERROR,1,TEXT("Can't create FrameValid event"))); <br>        return E_OUTOFMEMORY; <br>    } <br> <br>    m_EventAdvise.Reset(); <br>    m_fFrameValid = FALSE; <br> <br>    m_hThread = CreateThread(NULL, 0, CVidPreview::ThreadProcInit, this, <br>0, &amp;m_tid); <br>    if (!m_hThread) { <br>        DbgLog((LOG_ERROR,1,TEXT("Can't create Preview thread"))); <br>       return E_OUTOFMEMORY; <br>    } <br> <br>    // now that we're streaming, we need a capture window to use, unless <br>    // of course, our capture pin is active too, in which case we'll use <br>    // its capture window since there can be only one. <br>    if (!m_fCapturing &amp;&amp; !m_hwndCap) { <br>m_hwndCap = CreateCaptureWindow(); <br>ASSERT(m_hwndCap); <br>    } <br> <br>    return CBaseOutputPin::Active(); <br>} <br> <br> <br>// our pin has stopped streaming.  Time to kill the thread. <br>// <br>HRESULT CVidPreview::Inactive() <br>{ <br>    DbgLog((LOG_TRACE,2,TEXT("CVidPreview Pause-&gt;Stop"))); <br> <br>    ASSERT(IsConnected()); <br> <br>    // tell our thread to give up and die <br>    SetEvent(m_hEventRun); <br>    SetEvent(m_hEventFrameValid); <br>    SetEvent(m_hEventActiveChanged); <br> <br>    // If our thread is stuck in GetDeliveryBuffer, only this will release it <br>    HRESULT hr = CBaseOutputPin::Inactive(); <br> <br>    // We're waiting for an advise that will now never come <br>    if (m_pCap-&gt;m_pClock &amp;&amp; m_dwAdvise) { <br>m_pCap-&gt;m_pClock-&gt;Unadvise(m_dwAdvise); <br>m_EventAdvise.Set(); <br>    } <br> <br>    CloseHandle(m_hEventRun); <br>    CloseHandle(m_hEventActiveChanged); <br>    CloseHandle(m_hEventFrameValid); <br>    m_hEventRun = NULL; <br>    m_hEventActiveChanged = NULL; <br>    m_hEventFrameValid = NULL; <br> <br>    // when our main thread shuts down the capture thread, the capture <br>    // thread will destroy the capture window it made, and this will cause <br>    // USER to send messages to our main thread, and if we're blocked <br>    // waiting for the capture thread to go away, we will deadlock <br>    // preventing user from sending us the messages, and thus our thread <br>    // will never go away.  We need to dispatch messages while waiting <br>    // !!! It's more efficient to use MsgWaitForMultipleObjects, I know. <br>    while (WaitForSingleObject(m_hThread, 50) == WAIT_TIMEOUT) { <br>MSG msg; <br>while (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) { <br>    TranslateMessage(&amp;msg); <br>    DispatchMessage(&amp;msg); <br> } <br>    } <br>    CloseHandle(m_hThread); <br>    m_tid = 0; <br>    m_hThread = NULL; <br>     <br>    // now that we've stopped streaming, the capture pin may need to open <br>    // the device to connect, etc, so we better let it go <br>    if (m_hwndCap) <br>DestroyCaptureWindow(m_hwndCap); <br>    m_hwndCap = NULL; <br> <br>    return hr; <br>} <br> <br> <br>// we want 1 buffer big enough to hold a frame of the type that the capture <br>// pin is capturing.  We do some fancy math to align the buffers if the <br>// pin we are connected to requires it. <br>// <br>HRESULT CVidPreview::DecideBufferSize(IMemAllocator * pAllocator, ALLOCATOR_PROPERTIES *pProperties) <br>{ <br>   DbgLog((LOG_TRACE,2,TEXT("CVidPreview DecideBufferSize"))); <br> <br>   ASSERT(pAllocator); <br>   ASSERT(pProperties); <br> <br>   // !!! more preview buffers? <br>   if (pProperties-&gt;cBuffers &lt; 1) <br>       pProperties-&gt;cBuffers = 1; <br> <br>   if (pProperties-&gt;cbAlign == 0) <br>pProperties-&gt;cbAlign = 1; <br> <br>   // This is how big we need each buffer to be <br>   CMediaType cmt; <br>   HRESULT hr = GetMediaType(0, &amp;cmt); <br>   if (hr != S_OK) <br>return hr; <br>   pProperties-&gt;cbBuffer = max(pProperties-&gt;cbBuffer, <br>(long)(HEADER(cmt.Format())-&gt;biSizeImage)); <br> <br>   // Make the prefix + buffer size meet the alignment restriction <br>   pProperties-&gt;cbBuffer = (long)ALIGNUP(pProperties-&gt;cbBuffer + <br>pProperties-&gt;cbPrefix, pProperties-&gt;cbAlign) - <br>pProperties-&gt;cbPrefix; <br> <br>   ASSERT(pProperties-&gt;cbBuffer); <br> <br>   DbgLog((LOG_TRACE,2,TEXT("Preview: %d buffers, prefix %d size %d align %d"), <br>pProperties-&gt;cBuffers, pProperties-&gt;cbPrefix, <br>pProperties-&gt;cbBuffer, <br>pProperties-&gt;cbAlign)); <br> <br>   ALLOCATOR_PROPERTIES Actual; <br>   return pAllocator-&gt;SetProperties(pProperties,&amp;Actual); <br> <br>   // !!! Are we sure we'll be happy with this? <br> <br>} <br> <br> <br>// I know my preview sucks.  Stop telling me.  :-) <br>HRESULT CVidPreview::Notify(IBaseFilter *pFilter, Quality q) <br>{ <br>    return NOERROR; <br>} <br> <br> <br>// The capture pin is going active ==&gt; We must shut down our capture window <br>// The capture pin is inactive ==&gt; We need our own capture window now <br>// <br>HRESULT CVidPreview::CapturePinActive(BOOL fActive) <br>{ <br>    DbgLog((LOG_TRACE,2,TEXT("Capture pin says Active=%d"), fActive)); <br> <br>    if (fActive == m_fCapturing) <br>return S_OK; <br>    m_fCapturing = fActive; <br> <br>    // the capture pin will want to use the h/w.  Close our capture window <br>    if (fActive &amp;&amp; m_hwndCap) { <br>DestroyCaptureWindow(m_hwndCap); <br>m_hwndCap = NULL; <br>    } <br> <br>    // don't make a capture window if we're stopped and don't need it.  We'll <br>    // make one when we're activated <br>    if (!fActive &amp;&amp; !m_hwndCap &amp;&amp; m_hThread) { <br>m_hwndCap = CreateCaptureWindow(); <br>        ASSERT(m_hwndCap); <br>    } <br> <br>    // stop thread from waiting for us to send a valid frame - no more to come <br>    // it will hang waiting forever if we don't do this <br>    SetEvent(m_hEventFrameValid); <br> <br>    // wait until our worker thread notices the difference <br>    if (m_fRunning) <br>        WaitForSingleObject(m_hEventActiveChanged, INFINITE); <br>    ResetEvent(m_hEventActiveChanged); <br> <br>    return S_OK; <br>} <br> <br> <br>// The capture pin is sending us a frame to preview <br>// <br>HRESULT CVidPreview::ReceivePreviewFrame(LPVOID lpFrame, int iSize) <br>{ <br>    // I'm not the least bit interested in previewing right now, or <br>    // we haven't used the last one yet, or we don't have a place to put it <br>    if (!m_fRunning || m_fFrameValid || m_lpFrame == NULL) { <br>        //DbgLog((LOG_TRACE,4,TEXT("Not interested"))); <br>return S_OK; <br>    } <br> <br>    DbgLog((LOG_TRACE,4,TEXT("Capture pin is giving us a preview frame"))); <br> <br>    // !!! can't avoid mem copy without using our own allocator <br>    // !!! we do this copy memory even if preview pin is OFF (IAMStreamControl) <br>    // because we can't risk blocking this call by calling CheckStreamState <br>    CopyMemory(m_lpFrame, lpFrame, iSize); <br>    m_iFrameSize = iSize; <br>    m_fFrameValid = TRUE; <br>    SetEvent(m_hEventFrameValid); <br>    return S_OK; <br>} <br> <br> <br>// make a capture window for our preview pin <br>// <br>HWND CVidPreview::CreateCaptureWindow() <br>{ <br>    BOOL bErr; <br> <br>    DbgLog((LOG_TRACE,2,TEXT("PREVIEW creating a capture window"))); <br> <br>    HWND hwndCapture;   // The window to return <br> <br>    hwndCapture = capCreateCaptureWindow(NULL, 0, <br>                                         0, 0, 150, 150, <br>                                         NULL, 0 /* ID */); <br> <br>    if (!hwndCapture) { <br>        DbgLog((LOG_ERROR|LOG_TRACE, 1, TEXT("CAP Window could not be created") )); <br>        return NULL; <br>    } <br> <br>    bErr = capDriverConnect(hwndCapture, <br>m_pCap-&gt;m_pCapturePin-&gt;m_uiDriverIndex); <br>    if (!bErr) { <br>        DestroyWindow(hwndCapture); <br>        DbgLog((LOG_ERROR|LOG_TRACE, 1, TEXT("Driver failed to connect") ) ); <br>        return NULL; <br>    } <br> <br>    // we will be grabbing single frames <br>    capSetCallbackOnFrame(hwndCapture, &amp;VideoCallback); <br> <br>    SetWindowLong(hwndCapture, GWL_USERDATA, (LONG) this); <br> <br>    return hwndCapture; <br>} <br> <br> <br>// Disconnect the driver before destroying the window. <br>// <br>BOOL CVidPreview::DestroyCaptureWindow(HWND hwnd) <br>{ <br> <br>    ASSERT(hwnd != NULL); <br> <br>    DbgLog((LOG_TRACE,2,TEXT("PREVIEW destroying the capture window"))); <br> <br>    // !!! why is this failing? <br>    BOOL bDriverDisconnected = capDriverDisconnect(hwnd); <br>    //DbgLog((LOG_TRACE,2,TEXT("Driver disconnect: %x"), bDriverDisconnected)); <br> <br>    BOOL bWindowGone = DestroyWindow(hwnd); <br>    //DbgLog((LOG_TRACE,2,TEXT("Window destroy: %x"), bWindowGone)); <br> <br>    return (bDriverDisconnected &amp;&amp; bWindowGone); <br>} <br> <br> <br>// <br>// VideoCallback <br>// <br>// The AVICap Video callback. Keep a copy of the buffer we are given <br>// May be called after the worker thread, or even the pin has gone away, <br>// depending on AVICap's internal timing. Therefore be very careful with the <br>// pointers we use. <br>// <br>LRESULT CALLBACK CVidPreview::VideoCallback(HWND hwnd, LPVIDEOHDR lpVHdr) <br>{ <br> <br>    CVidPreview *pThis = (CVidPreview *)GetWindowLong(hwnd, GWL_USERDATA); <br>    ASSERT(pThis); <br> <br>    // I'm not the least bit interested in previewing right now, or <br>    // we haven't used the last one yet, or we don't have a place to put it <br>    if (!pThis-&gt;m_fRunning || pThis-&gt;m_fFrameValid || <br>pThis-&gt;m_lpFrame == NULL) { <br>        //DbgLog((LOG_TRACE,4,TEXT("Not interested"))); <br>return S_OK; <br>    } <br> <br>    DbgLog((LOG_TRACE,4,TEXT("capGrabFrame callback got a preview frame"))); <br> <br>    // !!! can't avoid mem copy without using our own allocator <br>    // !!! we do this copy memory even if preview pin is OFF (IAMStreamControl) <br>    // because we can't risk blocking this call by calling CheckStreamState <br>    CopyMemory(pThis-&gt;m_lpFrame, lpVHdr-&gt;lpData, lpVHdr-&gt;dwBufferLength); <br>    pThis-&gt;m_iFrameSize = lpVHdr-&gt;dwBufferLength; <br>    pThis-&gt;m_fFrameValid = TRUE; <br>    SetEvent(pThis-&gt;m_hEventFrameValid); <br>    return S_OK; <br>} <br> <br> <br>DWORD WINAPI CVidPreview::ThreadProcInit(void *pv) <br>{ <br>    CVidPreview *pThis = (CVidPreview *)pv; <br>    return pThis-&gt;ThreadProc(); <br>} <br> <br> <br>DWORD CVidPreview::ThreadProc() <br>{ <br>    IMediaSample *pSample; <br>    CRefTime rtStart, rtEnd; <br>    HRESULT hr; <br>    BOOL fCaptureActive = m_fCapturing; <br>    int iWait; <br>    HANDLE hWait[2] = {m_hEventFrameValid, m_hEventRun}; <br> <br>    DbgLog((LOG_TRACE,2,TEXT("CVidPreview ThreadProc"))); <br> <br>    // Send preview frames as long as we're running.  Die when not streaming <br>    while (1) { <br> <br>// only preview while running <br>if (!m_fRunning) { <br>           DbgLog((LOG_TRACE,3,TEXT("Preview thread waiting for RUN"))); <br>    WaitForSingleObject(m_hEventRun, INFINITE); <br>           DbgLog((LOG_TRACE,3,TEXT("Preview thread got RUN"))); <br> } <br>ResetEvent(m_hEventRun); <br> <br>// if we stopped instead of ran <br>if (!m_fRunning) <br>    break; <br> <br>while (m_fRunning) { <br>    hr = GetDeliveryBuffer(&amp;pSample, NULL, NULL, 0); <br>    if (FAILED(hr)) <br>break; <br>    hr = pSample-&gt;GetPointer((LPBYTE *)&amp;m_lpFrame); <br>    if (FAILED(hr)) <br>break; <br> <br>    // try to notice if the capture pin starts/stops streaming <br>    if (m_fCapturing != fCaptureActive) { <br>               DbgLog((LOG_TRACE,3,TEXT("Preview thread noticed Active=%d"), <br> m_fCapturing)); <br>SetEvent(m_hEventActiveChanged); <br>fCaptureActive = m_fCapturing; <br>    } <br> <br>    // the capture pin will send us a frame <br>    if (fCaptureActive) { <br>               DbgLog((LOG_TRACE,4,TEXT("PREVIEW using capture picture"))); <br> <br>    // m_hEventFrameValid, m_hEventRun <br>iWait = WaitForMultipleObjects(2, hWait, FALSE, INFINITE); <br> <br>// time for our thread to die - don't reset the event because <br>// we may need it to fire when we break out of this loop <br>if (iWait != WAIT_OBJECT_0) { <br>                   DbgLog((LOG_TRACE,2,TEXT("Wait for streaming pic abort1"))); <br>    m_lpFrame = NULL;// please don't write here anymore <br>        pSample-&gt;Release(); <br>    continue; <br>} <br> <br>// the streaming pin stopped being active... switch again <br>if (!m_fFrameValid) { <br>                   DbgLog((LOG_TRACE,2,TEXT("Wait for streaming pic abort2"))); <br>    ResetEvent(m_hEventFrameValid); <br>    m_lpFrame = NULL;// please don't write here anymore <br>        pSample-&gt;Release(); <br>    continue; <br>} <br> <br>ResetEvent(m_hEventFrameValid); <br>        pSample-&gt;SetActualDataLength(m_iFrameSize); <br> <br>    // we have our own capture window and are getting our own frames <br>    } else { <br>               DbgLog((LOG_TRACE,4,TEXT("PREVIEW using capGrabFrame"))); <br> <br>// get a frame, and give it to our callback <br>capGrabFrame(m_hwndCap); <br> <br>    // m_hEventFrameValid, m_hEventRun <br>// wait for our callback to get the frame <br>iWait = WaitForMultipleObjects(2, hWait, FALSE, INFINITE); <br> <br>// time for our thread to die - don't reset the event because <br>// we may need it to fire when we break out of this loop <br>if (iWait != WAIT_OBJECT_0) { <br>                   DbgLog((LOG_TRACE,2,TEXT("Wait for capGrabFrame abort1"))); <br>    m_lpFrame = NULL;// please don't write here anymore <br>        pSample-&gt;Release(); <br>    continue; <br>} <br> <br>// the streaming pin stopped being active... switch again <br>if (!m_fFrameValid) { <br>                   DbgLog((LOG_TRACE,2,TEXT("Wait for capGrabFrame abort2"))); <br>    ResetEvent(m_hEventFrameValid); <br>    m_lpFrame = NULL;// please don't write here anymore <br>        pSample-&gt;Release(); <br>    continue; <br>} <br> <br>ResetEvent(m_hEventFrameValid); <br>        pSample-&gt;SetActualDataLength(m_iFrameSize); <br>    } <br> <br>    // time stamp the sample <br>    if (m_pCap-&gt;m_pClock) { <br>        m_pCap-&gt;m_pClock-&gt;GetTime((REFERENCE_TIME *)&amp;rtStart); <br>              rtStart = rtStart - m_pCap-&gt;m_tStart; <br>if (m_mt.IsValid() &amp;&amp; <br>((VIDEOINFOHEADER *)m_mt.Format())-&gt;AvgTimePerFrame) <br>                  rtEnd = rtStart + <br>((VIDEOINFOHEADER *)m_mt.Format())-&gt;AvgTimePerFrame; <br>else <br>    rtEnd = rtStart + 666666;// assume 15fps <br> <br>// !!! NO TIME STAMPS for preview unless we know the latency <br>// of the graph... we could drop every frame needlessly since <br>// they'll all arrive at the renderer late if we're software <br>// decoding these frames. <br>// <br>// We only send another preview frame when this one is done, <br>// so we won't get a backup if decoding is slow. <br>//  <br>// Actually, adding a latency time would still be broken <br>// if the latency was &gt; 1 frame length, because the renderer <br>// would hold on to the sample until past the time for the <br>// next frame, and we wouldn't send out the next preview frame <br>// as soon as we should, and our preview frame rate would suffer <br>// <br>// But besides all that, we really need time stamps for <br>// the stream control stuff to work, so we'll have to live <br>// with preview frame rates being inferior if we have an <br>// oustanding stream control request. <br> <br>AM_STREAM_INFO am; <br>GetInfo(&amp;am); <br>if (am.dwFlags &amp; AM_STREAM_INFO_START_DEFINED || <br>am.dwFlags &amp; AM_STREAM_INFO_STOP_DEFINED) { <br>                    //DbgLog((LOG_TRACE,0,TEXT("TIME STAMPING ANYWAY"))); <br>                    pSample-&gt;SetTime((REFERENCE_TIME *)&amp;rtStart, <br>(REFERENCE_TIME *)&amp;rtEnd); <br>} <br>          } <br> <br>    // This is important so ReceivePreviewFrame doesn't screw up <br>    m_lpFrame = NULL;// please don't write here anymore <br>    m_fFrameValid = FALSE;// next time m_lpFrame is set, Ok to write <br> <br>    int iStreamState = CheckStreamState(pSample); <br>            pSample-&gt;SetDiscontinuity(FALSE); <br>            if (iStreamState == STREAM_FLOWING) { <br>                DbgLog((LOG_TRACE,4,TEXT("*PREV Sending frame at %d"), (int)rtStart)); <br>        if (m_fLastSampleDiscarded) <br>                    pSample-&gt;SetDiscontinuity(TRUE); <br>            } else { <br>                DbgLog((LOG_TRACE,4,TEXT("*PREVIEW Discarding frame at %d"), <br>(int)rtStart)); <br>        m_fLastSampleDiscarded = TRUE; <br>            } <br>    if (iStreamState == STREAM_FLOWING) { <br>        pSample-&gt;SetSyncPoint(TRUE);// !!! not necessarily <br>        pSample-&gt;SetPreroll(FALSE); <br>               DbgLog((LOG_TRACE,4,TEXT("*Delivering a preview frame"))); <br>        Deliver(pSample); <br>    } <br>    pSample-&gt;Release(); <br> <br>    // if previewing ourself, wait for time till next frame <br>    // !!! capture pin may wait on this to become active <br>    if (!fCaptureActive &amp;&amp; m_pCap-&gt;m_pClock) { <br>                hr = m_pCap-&gt;m_pClock-&gt;AdviseTime(m_rtRun, rtEnd, <br>            (HEVENT)(HANDLE) m_EventAdvise, &amp;m_dwAdvise); <br>            if (SUCCEEDED(hr)) { <br>            m_EventAdvise.Wait(); <br>            } <br>m_dwAdvise = 0; <br>            } <br>} <br>// just in case <br>SetEvent(m_hEventActiveChanged); <br>    } <br> <br>    DbgLog((LOG_TRACE,2,TEXT("CVidPreview ThreadProc is dead"))); <br>    return 0; <br>} <br> <br> <br>// <br>// PIN CATEGORIES - let the world know that we are a PREVIEW pin <br>// <br> <br>HRESULT CVidPreview::Set(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData, DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData) <br>{ <br>    return E_NOTIMPL; <br>} <br> <br>// To get a property, the caller allocates a buffer which the called <br>// function fills in.  To determine necessary buffer size, call Get with <br>// pPropData=NULL and cbPropData=0. <br>HRESULT CVidPreview::Get(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData, DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData, DWORD *pcbReturned) <br>{ <br>    if (guidPropSet != AMPROPSETID_Pin) <br>return E_PROP_SET_UNSUPPORTED; <br> <br>    if (dwPropID != AMPROPERTY_PIN_CATEGORY) <br>return E_PROP_ID_UNSUPPORTED; <br> <br>    if (pPropData == NULL &amp;&amp; pcbReturned == NULL) <br>return E_POINTER; <br> <br>    if (pcbReturned) <br>*pcbReturned = sizeof(GUID); <br> <br>    if (pPropData == NULL) <br>return S_OK; <br> <br>    if (cbPropData &lt; sizeof(GUID)) <br>return E_UNEXPECTED; <br> <br>    *(GUID *)pPropData = PIN_CATEGORY_PREVIEW; <br>    return S_OK; <br>} <br> <br> <br>// QuerySupported must either return E_NOTIMPL or correctly indicate <br>// if getting or setting the property set and property is supported. <br>// S_OK indicates the property set and property ID combination is <br>HRESULT CVidPreview::QuerySupported(REFGUID guidPropSet, DWORD dwPropID, DWORD *pTypeSupport) <br>{ <br>    if (guidPropSet != AMPROPSETID_Pin) <br>return E_PROP_SET_UNSUPPORTED; <br> <br>    if (dwPropID != AMPROPERTY_PIN_CATEGORY) <br>return E_PROP_ID_UNSUPPORTED; <br> <br>    if (pTypeSupport) <br>*pTypeSupport = KSPROPERTY_SUPPORT_GET; <br>    return S_OK; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
