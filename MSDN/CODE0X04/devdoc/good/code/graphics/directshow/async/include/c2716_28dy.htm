<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ASYNCIO.H</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2716"></a>ASYNCIO.H</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>#ifndef __ASYNCIO_H__ <br>#define __ASYNCIO_H__ <br>// <br>// definition of CAsyncFile object that performs file access. It provides <br>// asynchronous, unbuffered, aligned reads from a file, using a worker thread <br>// on win95 and potentially overlapped i/o if available. <br> <br>// !!! Need to use real overlapped i/o if available <br>// currently only uses worker thread, not overlapped i/o <br> <br> <br>class CAsyncIo; <br>class CAsyncStream; <br> <br>// <br>//  Model the stream we read from based on a file-like interface <br>// <br>class CAsyncStream <br>{ <br>public: <br>    virtual ~CAsyncStream() {}; <br>    virtual HRESULT SetPointer(LONGLONG llPos) = 0; <br>    virtual HRESULT Read(PBYTE pbBuffer, <br>                         DWORD dwBytesToRead, <br>                         BOOL bAlign, <br>                         LPDWORD pdwBytesRead) = 0; <br>    virtual LONGLONG Size(LONGLONG *pSizeAvailable = NULL) = 0; <br>    virtual DWORD Alignment() = 0; <br>    virtual void Lock() = 0; <br>    virtual void Unlock() = 0; <br>}; <br> <br>// represents a single request and performs the i/o. Can be called on either <br>// worker thread or app thread, but must hold pcsFile across file accesses. <br>// (ie across SetFilePointer/ReadFile pairs) <br>class CAsyncRequest <br>{ <br>    CAsyncIo *m_pIo; <br>    CAsyncStream *m_pStream; <br>    LONGLONG      m_llPos; <br>    BOOL        m_bAligned; <br>    LONG m_lLength; <br>    BYTE* m_pBuffer; <br>    LPVOID m_pContext; <br>    DWORDm_dwUser; <br>    HRESULT     m_hr; <br> <br>public: <br>    // init the params for this request. Issue the i/o <br>    // if overlapped i/o is possible. <br>    HRESULT Request( <br>    CAsyncIo *pIo, <br>        CAsyncStream *pStream, <br>    LONGLONG llPos, <br>LONG lLength, <br>        BOOL bAligned, <br>BYTE* pBuffer, <br>LPVOID pContext,// filter's context <br>DWORD dwUser);// downstream filter's context <br> <br>    // issue the i/o if not overlapped, and block until i/o complete. <br>    // returns error code of file i/o <br>    HRESULT Complete(); <br> <br>    // cancels the i/o. blocks until i/o is no longer pending <br>    HRESULT Cancel() <br>    { <br>return S_OK; <br>    }; <br> <br>    // accessor functions <br>    LPVOID GetContext() <br>    { <br>    return m_pContext; <br>    }; <br> <br>    DWORD GetUser() <br>    { <br>return m_dwUser; <br>    }; <br> <br>    HRESULT GetHResult() { <br>        return m_hr; <br>    }; <br> <br>    // we set m_lLength to the actual length <br>    LONG GetActualLength() { <br>        return m_lLength; <br>    }; <br> <br>    LONGLONG GetStart() { <br>        return m_llPos; <br>    }; <br>}; <br> <br> <br>typedef CGenericList&lt;CAsyncRequest&gt; CRequestList; <br> <br>// this class needs a worker thread, but the ones defined in classes\base <br>// are not suitable (they assume you have one message sent or posted per <br>// request, whereas here for efficiency we want just to set an event when <br>// there is work on the queue). <br>// <br>// we create CAsyncRequest objects and queue them on m_listWork. The worker <br>// thread pulls them off, completes them and puts them on m_listDone. <br>// The events m_evWork and m_evDone are set when the corresponding lists are <br>// not empty. <br>// <br>// Synchronous requests are done on the caller thread. These should be <br>// synchronised by the caller, but to make sure we hold m_csFile across <br>// the SetFilePointer/ReadFile code. <br>// <br>// Flush by calling BeginFlush. This rejects all further requests (by <br>// setting m_bFlushing within m_csLists), cancels all requests and moves them <br>// to the done list, and sets m_evDone to ensure that no WaitForNext operations <br>// will block. Call EndFlush to cancel this state. <br>// <br>// we support unaligned calls to SyncRead. This is done by opening the file <br>// twice if we are using unbuffered i/o (m_dwAlign &gt; 1). <br>// !!!fix this to buffer on top of existing file handle? <br>class CAsyncIo <br>{ <br> <br>    CCritSec m_csReader; <br>    CAsyncStream *m_pStream; <br> <br>    CCritSec m_csLists;      // locks access to the list and events <br>    BOOL m_bFlushing;        // true if between BeginFlush/EndFlush <br>    CRequestList m_listWork; <br>    CRequestList m_listDone; <br>    CAMEvent m_evWork;         // set when list is not empty <br>    CAMEvent m_evDone; <br> <br>    // for correct flush behaviour: all protected by m_csLists <br>    LONG    m_cItemsOut;    // nr of items not on listDone or listWork <br>    BOOL    m_bWaiting;     // TRUE if someone waiting for m_evAllDone <br>    CAMEvent m_evAllDone;   // signal when m_cItemsOut goes to 0 if m_cWaiting <br> <br> <br>    CAMEvent m_evStop;         // set when thread should exit <br>    HANDLE m_hThread; <br> <br>    LONGLONG Size() { <br>        ASSERT(m_pStream != NULL); <br>        return m_pStream-&gt;Size(); <br>    }; <br> <br>    // start the thread <br>    HRESULT StartThread(void); <br> <br>    // stop the thread and close the handle <br>    HRESULT CloseThread(void); <br> <br>    // manage the list of requests. hold m_csLists and ensure <br>    // that the (manual reset) event hevList is set when things on <br>    // the list but reset when the list is empty. <br>    // returns null if list empty <br>    CAsyncRequest* GetWorkItem(); <br> <br>    // get an item from the done list <br>    CAsyncRequest* GetDoneItem(); <br> <br>    // put an item on the work list <br>    HRESULT PutWorkItem(CAsyncRequest* pRequest); <br> <br>    // put an item on the done list <br>    HRESULT PutDoneItem(CAsyncRequest* pRequest); <br> <br>    // called on thread to process any active requests <br>    void ProcessRequests(void); <br> <br>    // initial static thread proc calls ThreadProc with DWORD <br>    // param as this <br>    static DWORD InitialThreadProc(LPVOID pv) { <br>CAsyncIo * pThis = (CAsyncIo*) pv; <br>return pThis-&gt;ThreadProc(); <br>    }; <br> <br>    DWORD ThreadProc(void); <br> <br>public: <br> <br>    CAsyncIo(CAsyncStream *pStream); <br>    ~CAsyncIo(); <br> <br>    // open the file <br>    HRESULT Open(LPCTSTR pName); <br> <br>    // ready for async activity - call this before <br>    // calling Request <br>    HRESULT AsyncActive(void); <br> <br>    // call this when no more async activity will happen before <br>    // the next AsyncActive call <br>    HRESULT AsyncInactive(void); <br> <br>    // queue a requested read. must be aligned. <br>    HRESULT Request( <br>    LONGLONG llPos, <br>LONG lLength, <br>                BOOL bAligned, <br>BYTE* pBuffer, <br>LPVOID pContext, <br>DWORD dwUser); <br> <br>    // wait for the next read to complete <br>    HRESULT WaitForNext( <br>    DWORD dwTimeout, <br>LPVOID *ppContext, <br>DWORD * pdwUser, <br>                LONG * pcbActual <br>                ); <br> <br>    // perform a read of an already aligned buffer <br>    HRESULT SyncReadAligned( <br>    LONGLONG llPos, <br>LONG lLength, <br>BYTE* pBuffer, <br>                LONG* pcbActual <br>                ); <br> <br>    // perform a synchronous read. will be buffered <br>    // if not aligned. <br>    HRESULT SyncRead( <br>                LONGLONG llPos, <br>                LONG lLength, <br>                BYTE* pBuffer); <br> <br>    // return length <br>    HRESULT Length(LONGLONG *pllTotal, LONGLONG* pllAvailable); <br> <br>    // all Reader positions, read lengths and memory locations must <br>    // be aligned to this. <br>    HRESULT Alignment(LONG* pl); <br> <br>    HRESULT BeginFlush(); <br>    HRESULT EndFlush(); <br> <br>    LONG Alignment() <br>    { <br>        return m_pStream-&gt;Alignment(); <br>    }; <br> <br>    BOOL IsAligned(LONG l) { <br>if ((l &amp; (Alignment() -1)) == 0) { <br>    return TRUE; <br>} else { <br>    return FALSE; <br>} <br>    }; <br> <br>    BOOL IsAligned(LONGLONG ll) { <br>return IsAligned( (LONG) (ll &amp; 0xffffffff)); <br>    }; <br>}; <br> <br>#endif // __ASYNCIO_H__ </code></pre>
<p>&nbsp;</p></body>
</HTML>
