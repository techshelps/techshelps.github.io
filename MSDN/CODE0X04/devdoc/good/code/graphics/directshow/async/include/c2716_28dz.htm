<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ASYNCRDR.H</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2717"></a>ASYNCRDR.H</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>#ifndef __ASYNCRDR_H__ <br>#define __ASYNCRDR_H__ <br> <br> <br> <br>// <br>// AsyncRdr <br>// <br>// Defines an IO source filter. <br>// <br>// This filter (CAsyncReader) supports IBaseFilter and IFileSourceFilter interfaces from the <br>// filter object itself. It has a single output pin (CAsyncOutputPin) <br>// which supports IPin and IAsyncReader. <br>// <br>// This filter is essentially a wrapper for the CAsyncFile class that does <br>// all the work. <br>// <br> <br> <br>// the filter class (defined below) <br>class CAsyncReader; <br> <br> <br>// the output pin class <br>class CAsyncOutputPin <br>  : public IAsyncReader, <br>    public CBasePin <br>{ <br>protected: <br>    CAsyncReader* m_pReader; <br>    CAsyncIo * m_pIo; <br> <br>    //  This is set every time we're asked to return an IAsyncReader <br>    //  interface <br>    //  This allows us to know if the downstream pin can use <br>    //  this transport, otherwise we can hook up to thinks like the <br>    //  dump filter and nothing happens <br>    BOOL         m_bQueriedForAsyncReader; <br> <br>    HRESULT InitAllocator(IMemAllocator **ppAlloc); <br> <br>public: <br>    // constructor and destructor <br>    CAsyncOutputPin( <br>        HRESULT * phr, <br>CAsyncReader *pReader, <br>CAsyncIo *pIo, <br>        CCritSec * pLock); <br> <br>    ~CAsyncOutputPin(); <br> <br>    // --- CUnknown --- <br> <br>    // need to expose IAsyncReader <br>    DECLARE_IUNKNOWN <br>    STDMETHODIMP NonDelegatingQueryInterface(REFIID, void**); <br> <br>    // --- CBasePin methods --- <br> <br>    // return the types we prefer - this will return the known <br>    // file type <br>    HRESULT GetMediaType(int iPosition, CMediaType *pMediaType); <br> <br>    // can we support this type? <br>    HRESULT CheckMediaType(const CMediaType* pType); <br> <br>    // Clear the flag so we see if IAsyncReader is queried for <br>    HRESULT CheckConnect(IPin *pPin) <br>    { <br>        m_bQueriedForAsyncReader = FALSE; <br>        return CBasePin::CheckConnect(pPin); <br>    } <br> <br>    // See if it was asked for <br>    HRESULT CompleteConnect(IPin *pReceivePin) <br>    { <br>        if (m_bQueriedForAsyncReader) { <br>            return CBasePin::CompleteConnect(pReceivePin); <br>        } else { <br>#ifdef VFW_E_NO_TRANSPORT <br>            return VFW_E_NO_TRANSPORT; <br>#else <br>            return E_FAIL; <br>#endif <br>        } <br>    } <br> <br>    // --- IAsyncReader methods --- <br>    // pass in your preferred allocator and your preferred properties. <br>    // method returns the actual allocator to be used. Call GetProperties <br>    // on returned allocator to learn alignment and prefix etc chosen. <br>    // this allocator will be not be committed and decommitted by <br>    // the async reader, only by the consumer. <br>    STDMETHODIMP RequestAllocator( <br>                      IMemAllocator* pPreferred, <br>                      ALLOCATOR_PROPERTIES* pProps, <br>                      IMemAllocator ** ppActual); <br> <br>    // queue a request for data. <br>    // media sample start and stop times contain the requested absolute <br>    // byte position (start inclusive, stop exclusive). <br>    // may fail if sample not obtained from agreed allocator. <br>    // may fail if start/stop position does not match agreed alignment. <br>    // samples allocated from source pin's allocator may fail <br>    // GetPointer until after returning from WaitForNext. <br>    STDMETHODIMP Request( <br>                     IMediaSample* pSample, <br>                     DWORD dwUser);        // user context <br> <br>    // block until the next sample is completed or the timeout occurs. <br>    // timeout (millisecs) may be 0 or INFINITE. Samples may not <br>    // be delivered in order. If there is a read error of any sort, a <br>    // notification will already have been sent by the source filter, <br>    // and STDMETHODIMP will be an error. <br>    STDMETHODIMP WaitForNext( <br>                      DWORD dwTimeout, <br>                      IMediaSample** ppSample,  // completed sample <br>                      DWORD * pdwUser);// user context <br> <br>    // sync read of data. Sample passed in must have been acquired from <br>    // the agreed allocator. Start and stop position must be aligned. <br>    // equivalent to a Request/WaitForNext pair, but may avoid the <br>    // need for a thread on the source filter. <br>    STDMETHODIMP SyncReadAligned( <br>                      IMediaSample* pSample); <br> <br> <br>    // sync read. works in stopped state as well as run state. <br>    // need not be aligned. Will fail if read is beyond actual total <br>    // length. <br>    STDMETHODIMP SyncRead( <br>                      LONGLONG llPosition,// absolute file position <br>                      LONG lLength,// nr bytes required <br>                      BYTE* pBuffer);// write data here <br> <br>    // return total length of stream, and currently available length. <br>    // reads for beyond the available length but within the total length will <br>    // normally succeed but may block for a long period. <br>    STDMETHODIMP Length( <br>                      LONGLONG* pTotal, <br>                      LONGLONG* pAvailable); <br> <br>    // cause all outstanding reads to return, possibly with a failure code <br>    // (VFW_E_TIMEOUT) indicating they were cancelled. <br>    // these are defined on IAsyncReader and IPin <br>    STDMETHODIMP BeginFlush(void); <br>    STDMETHODIMP EndFlush(void); <br> <br>}; <br> <br> <br>// <br>// The filter object itself. Supports IBaseFilter through <br>// CBaseFilter and also IFileSourceFilter directly in this object <br> <br>class CAsyncReader : public CBaseFilter <br>{ <br> <br>protected: <br>    // filter-wide lock <br>    CCritSec m_csFilter; <br> <br>    // all i/o done here <br>    CAsyncIo m_Io; <br> <br>    // our output pin <br>    CAsyncOutputPin m_OutputPin; <br> <br>    // Type we think our data is <br>    CMediaType            m_mt; <br> <br>public: <br> <br>    // construction / destruction <br> <br>    CAsyncReader( <br>        TCHAR *pName, <br>        LPUNKNOWN pUnk, <br>        CAsyncStream *pStream, <br>        HRESULT *phr); <br>    ~CAsyncReader(); <br> <br> <br>    // --- CBaseFilter methods --- <br>    int GetPinCount(); <br>    CBasePin *GetPin(int n); <br> <br>    // --- Access our media type <br>    const CMediaType *LoadType() const <br>    { <br>        return &amp;m_mt; <br>    } <br>}; <br> <br> <br> <br>#endif //__ASYNCRDR_H__ <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
