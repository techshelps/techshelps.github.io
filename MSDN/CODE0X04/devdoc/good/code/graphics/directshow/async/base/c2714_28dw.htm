<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ASYNCIO.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2714"></a>ASYNCIO.CPP</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br> <br>#include &lt;streams.h&gt; <br>#include &lt;asyncio.h&gt; <br> <br>// --- CAsyncRequest --- <br> <br> <br>// implementation of CAsyncRequest representing a single <br>// outstanding request. All the i/o for this object is done <br>// in the Complete method. <br> <br> <br>// init the params for this request. <br>// Read is not issued until the complete call <br>HRESULT <br>CAsyncRequest::Request( <br>    CAsyncIo *pIo, <br>    CAsyncStream *pStream, <br>    LONGLONG llPos, <br>    LONG lLength, <br>    BOOL bAligned, <br>    BYTE* pBuffer, <br>    LPVOID pContext,// filter's context <br>    DWORD dwUser)// downstream filter's context <br>{ <br>    m_pIo = pIo; <br>    m_pStream = pStream; <br>    m_llPos = llPos; <br>    m_lLength = lLength; <br>    m_bAligned = bAligned; <br>    m_pBuffer = pBuffer; <br>    m_pContext = pContext; <br>    m_dwUser = dwUser; <br>    m_hr = VFW_E_TIMEOUT;   // not done yet <br> <br>    return S_OK; <br>} <br> <br> <br>// issue the i/o if not overlapped, and block until i/o complete. <br>// returns error code of file i/o <br>// <br>// <br>HRESULT <br>CAsyncRequest::Complete() <br>{ <br> <br>    m_pStream-&gt;Lock(); <br> <br>    m_hr = m_pStream-&gt;SetPointer(m_llPos); <br>    if (S_OK == m_hr) { <br> <br>        DWORD dwActual; <br>        m_hr = m_pStream-&gt;Read(m_pBuffer, m_lLength, m_bAligned, &amp;dwActual); <br>        if (FAILED(m_hr)) { <br>        } else if (dwActual != (DWORD)m_lLength) { <br>            // tell caller size changed - probably because of EOF <br>            m_lLength = (LONG) dwActual; <br>            m_hr = S_FALSE; <br>        } else { <br>            m_hr = S_OK; <br>        } <br>    } <br> <br>    m_pStream-&gt;Unlock(); <br>    return m_hr; <br>} <br> <br> <br> <br>// --- CAsyncIo --- <br> <br>// note - all events created manual reset <br> <br>CAsyncIo::CAsyncIo(CAsyncStream *pStream) <br> : m_hThread(NULL), <br>   m_evWork(TRUE), <br>   m_evDone(TRUE), <br>   m_evStop(TRUE), <br>   m_listWork(NAME("Work list")), <br>   m_listDone(NAME("Done list")), <br>   m_bFlushing(FALSE), <br>   m_cItemsOut(0), <br>   m_bWaiting(FALSE), <br>   m_pStream(pStream) <br>{ <br> <br>} <br> <br> <br>CAsyncIo::~CAsyncIo() <br>{ <br>    // move everything to the done list <br>    BeginFlush(); <br> <br>    // shutdown worker thread <br>    CloseThread(); <br> <br>    // empty the done list <br>    POSITION pos = m_listDone.GetHeadPosition(); <br>    while (pos) { <br>        CAsyncRequest* pRequest = m_listDone.GetNext(pos); <br>        delete pRequest; <br>    } <br>    m_listDone.RemoveAll(); <br>} <br> <br>// ready for async activity - call this before <br>// calling Request. <br>// <br>// start the worker thread if we need to <br>// <br>// !!! use overlapped i/o if possible <br>HRESULT <br>CAsyncIo::AsyncActive(void) <br>{ <br>    return StartThread(); <br>} <br> <br>// call this when no more async activity will happen before <br>// the next AsyncActive call <br>// <br>// stop the worker thread if active <br>HRESULT <br>CAsyncIo::AsyncInactive(void) <br>{ <br>    return CloseThread(); <br>} <br> <br> <br>// add a request to the queue. <br>HRESULT <br>CAsyncIo::Request( <br>            LONGLONG llPos, <br>            LONG lLength, <br>            BOOL bAligned, <br>            BYTE* pBuffer, <br>            LPVOID pContext, <br>            DWORD dwUser) <br>{ <br>    if (bAligned) { <br>        if (!IsAligned(llPos) || <br>    !IsAligned(lLength) || <br>    !IsAligned((LONG) pBuffer)) { <br>            return VFW_E_BADALIGN; <br>        } <br>    } <br> <br>    CAsyncRequest* pRequest = new CAsyncRequest; <br> <br>    HRESULT hr = pRequest-&gt;Request( <br>                            this, <br>                            m_pStream, <br>                            llPos, <br>                            lLength, <br>                            bAligned, <br>                            pBuffer, <br>                            pContext, <br>                            dwUser); <br>    if (SUCCEEDED(hr)) { <br>        // might fail if flushing <br>        hr = PutWorkItem(pRequest); <br>    } <br> <br>    if (FAILED(hr)) { <br>        delete pRequest; <br>    } <br>    return hr; <br>} <br> <br> <br>// wait for the next request to complete <br>HRESULT <br>CAsyncIo::WaitForNext( <br>    DWORD dwTimeout, <br>    LPVOID *ppContext, <br>    DWORD * pdwUser, <br>    LONG* pcbActual) <br>{ <br>    // some errors find a sample, others don't. Ensure that <br>    // *ppContext is NULL if no sample found <br>    *ppContext = NULL; <br> <br>    // wait until the event is set, but since we are not <br>    // holding the critsec when waiting, we may need to re-wait <br>    for (;;) { <br> <br>        if (!m_evDone.Wait(dwTimeout)) { <br>            // timeout occurred <br>            return VFW_E_TIMEOUT; <br>        } <br> <br>        // get next event from list <br>        CAsyncRequest* pRequest = GetDoneItem(); <br>        if (pRequest) { <br>            // found a completed request <br> <br>            // check if ok <br>            HRESULT hr = pRequest-&gt;GetHResult(); <br>            if (hr == S_FALSE) { <br> <br>                // this means the actual length was less than <br>                // requested - may be ok if he aligned the end of file <br>                if ((pRequest-&gt;GetActualLength() + <br>                     pRequest-&gt;GetStart()) == Size()) { <br>                        hr = S_OK; <br>                } else { <br>                    // it was an actual read error <br>                    hr = E_FAIL; <br>                } <br>            } <br> <br>            // return actual bytes read <br>            *pcbActual = pRequest-&gt;GetActualLength(); <br> <br>            // return his context <br>            *ppContext = pRequest-&gt;GetContext(); <br>            *pdwUser = pRequest-&gt;GetUser(); <br>            delete pRequest; <br>            return hr; <br>        } else { <br>            //  Hold the critical section while checking the <br>            //  list state <br>            CAutoLock lck(&amp;m_csLists); <br>            if (m_bFlushing &amp;&amp; !m_bWaiting) { <br> <br>                // can't block as we are between BeginFlush and EndFlush <br> <br>                // but note that if m_bWaiting is set, then there are some <br>                // items not yet complete that we should block for. <br> <br>                return VFW_E_WRONG_STATE; <br>            } <br>        } <br> <br>        // done item was grabbed between completion and <br>        // us locking m_csLists. <br>    } <br>} <br> <br>// perform a synchronous read request on this thread. <br>// Need to hold m_csFile while doing this (done in <br>// request object) <br>HRESULT <br>CAsyncIo::SyncReadAligned( <br>            LONGLONG llPos, <br>            LONG lLength, <br>            BYTE* pBuffer, <br>            LONG* pcbActual <br>            ) <br>{ <br>    if (!IsAligned(llPos) || <br>!IsAligned(lLength) || <br>!IsAligned((LONG) pBuffer)) { <br>            return VFW_E_BADALIGN; <br>    } <br> <br>    CAsyncRequest request; <br> <br>    HRESULT hr = request.Request( <br>                    this, <br>                    m_pStream, <br>                    llPos, <br>                    lLength, <br>                    TRUE, <br>                    pBuffer, <br>                    NULL, <br>                    0); <br> <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br> <br>    hr = request.Complete(); <br> <br>    // return actual data length <br>    *pcbActual = request.GetActualLength(); <br>    return hr; <br>} <br> <br>HRESULT <br>CAsyncIo::Length(LONGLONG *pllTotal, LONGLONG* pllAvailable) <br>{ <br>    *pllTotal = m_pStream-&gt;Size(pllAvailable); <br>    return S_OK; <br>} <br> <br>// cancel all items on the worklist onto the done list <br>// and refuse further requests or further WaitForNext calls <br>// until the end flush <br>// <br>// WaitForNext must return with NULL only if there are no successful requests. <br>// So Flush does the following: <br>// 1. set m_bFlushing ensures no more requests succeed <br>// 2. move all items from work list to the done list. <br>// 3. If there are any outstanding requests, then we need to release the <br>//    critsec to allow them to complete. The m_bWaiting as well as ensuring <br>//    that we are signalled when they are all done is also used to indicate <br>//    to WaitForNext that it should continue to block. <br>// 4. Once all outstanding requests are complete, we force m_evDone set and <br>//    m_bFlushing set and m_bWaiting false. This ensures that WaitForNext will <br>//    not block when the done list is empty. <br>HRESULT <br>CAsyncIo::BeginFlush() <br>{ <br>    // hold the lock while emptying the work list <br>    { <br>        CAutoLock lock(&amp;m_csLists); <br> <br>        // prevent further requests being queued. <br>        // Also WaitForNext will refuse to block if this is set <br>        // unless m_bWaiting is also set which it will be when we release <br>        // the critsec if there are any outstanding). <br>        m_bFlushing = TRUE; <br> <br>        CAsyncRequest * preq; <br>        while(preq = GetWorkItem()) { <br>            preq-&gt;Cancel(); <br>            PutDoneItem(preq); <br>        } <br> <br> <br>        // now wait for any outstanding requests to complete <br>        if (m_cItemsOut &gt; 0) { <br> <br>            // can be only one person waiting <br>            ASSERT(!m_bWaiting); <br> <br>            // this tells the completion routine that we need to be <br>            // signalled via m_evAllDone when all outstanding items are <br>            // done. It also tells WaitForNext to continue blocking. <br>            m_bWaiting = TRUE; <br>        } else { <br>            // all done <br> <br>            // force m_evDone set so that even if list is empty, <br>            // WaitForNext will not block <br>            // don't do this until we are sure that all <br>            // requests are on the done list. <br>            m_evDone.Set(); <br>            return S_OK; <br>        } <br>    } <br> <br>    ASSERT(m_bWaiting); <br> <br>    // wait without holding critsec <br>    for (;;) { <br>        m_evAllDone.Wait(); <br>        { <br>            // hold critsec to check <br>            CAutoLock lock(&amp;m_csLists); <br> <br>            if (m_cItemsOut == 0) { <br> <br>                // now we are sure that all outstanding requests are on <br>                // the done list and no more will be accepted <br>                m_bWaiting = FALSE; <br> <br>                // force m_evDone set so that even if list is empty, <br>                // WaitForNext will not block <br>                // don't do this until we are sure that all <br>                // requests are on the done list. <br>                m_evDone.Set(); <br> <br>                return S_OK; <br>            } <br>        } <br>    } <br>} <br> <br>// end a flushing state <br>HRESULT <br>CAsyncIo::EndFlush() <br>{ <br>    CAutoLock lock(&amp;m_csLists); <br> <br>    m_bFlushing = FALSE; <br> <br>    ASSERT(!m_bWaiting); <br> <br>    // m_evDone might have been set by BeginFlush - ensure it is <br>    // set IFF m_listDone is non-empty <br>    if (m_listDone.GetCount() &gt; 0) { <br>        m_evDone.Set(); <br>    } else { <br>        m_evDone.Reset(); <br>    } <br> <br>    return S_OK; <br>} <br> <br>// start the thread <br>HRESULT <br>CAsyncIo::StartThread(void) <br>{ <br>    if (m_hThread) { <br>        return S_OK; <br>    } <br> <br>    // clear the stop event before starting <br>    m_evStop.Reset(); <br> <br>    DWORD dwThreadID; <br>    m_hThread = CreateThread( <br>                    NULL, <br>                    0, <br>                    InitialThreadProc, <br>                    this, <br>                    0, <br>                    &amp;dwThreadID); <br>    if (!m_hThread) { <br>DWORD dwErr = GetLastError(); <br>        return HRESULT_FROM_WIN32(dwErr); <br>    } <br>    return S_OK; <br>} <br> <br>// stop the thread and close the handle <br>HRESULT <br>CAsyncIo::CloseThread(void) <br>{ <br>    // signal the thread-exit object <br>    m_evStop.Set(); <br> <br>    if (m_hThread) { <br> <br>        WaitForSingleObject(m_hThread, INFINITE); <br>        CloseHandle(m_hThread); <br>        m_hThread = NULL; <br>    } <br>    return S_OK; <br>} <br> <br> <br>// manage the list of requests. hold m_csLists and ensure <br>// that the (manual reset) event hevList is set when things on <br>// the list but reset when the list is empty. <br>// returns null if list empty <br>CAsyncRequest* <br>CAsyncIo::GetWorkItem() <br>{ <br>    CAutoLock lck(&amp;m_csLists); <br> <br>    CAsyncRequest * preq  = m_listWork.RemoveHead(); <br> <br>    // force event set correctly <br>    if (m_listWork.GetCount() == 0) { <br>        m_evWork.Reset(); <br>    } <br>    return preq; <br>} <br> <br>// get an item from the done list <br>CAsyncRequest* <br>CAsyncIo::GetDoneItem() <br>{ <br>    CAutoLock lock(&amp;m_csLists); <br> <br>    CAsyncRequest * preq  = m_listDone.RemoveHead(); <br> <br>    // force event set correctly if list now empty <br>    // or we're in the final stages of flushing <br>    // Note that during flushing the way it's supposed to work is that <br>    // everything is shoved on the Done list then the application is <br>    // supposed to suck until it gets nothing more <br>    // <br>    // Thus we should not set m_evDone unconditionally until everything <br>    // has moved to the done list which means we must wait until <br>    // cItemsOut is 0 (which is guaranteed by m_bWaiting being TRUE). <br> <br>    if (m_listDone.GetCount() == 0 &amp;&amp; <br>        (!m_bFlushing || m_bWaiting)) { <br>        m_evDone.Reset(); <br>    } <br> <br>    return preq; <br>} <br> <br>// put an item on the work list - fail if bFlushing <br>HRESULT <br>CAsyncIo::PutWorkItem(CAsyncRequest* pRequest) <br>{ <br>    CAutoLock lock(&amp;m_csLists); <br>    HRESULT hr; <br> <br>    if (m_bFlushing) { <br>        hr = VFW_E_WRONG_STATE; <br>    } <br>    else if (m_listWork.AddTail(pRequest)) { <br> <br>        // event should now be in a set state - force this <br>        m_evWork.Set(); <br> <br>        // start the thread now if not already started <br>        hr = StartThread(); <br> <br>    } else { <br>        hr = E_OUTOFMEMORY; <br>    } <br>    return(hr); <br>} <br> <br>// put an item on the done list - ok to do this when <br>// flushing <br>HRESULT <br>CAsyncIo::PutDoneItem(CAsyncRequest* pRequest) <br>{ <br>    ASSERT(CritCheckIn(&amp;m_csLists)); <br> <br>    if (m_listDone.AddTail(pRequest)) { <br> <br>        // event should now be in a set state - force this <br>        m_evDone.Set(); <br>        return S_OK; <br>    } else { <br>        return E_OUTOFMEMORY; <br>    } <br>} <br> <br>// called on thread to process any active requests <br>void <br>CAsyncIo::ProcessRequests(void) <br>{ <br>    // lock to get the item and increment the outstanding count <br>    CAsyncRequest * preq = NULL; <br>    for (;;) { <br>        { <br>            CAutoLock lock(&amp;m_csLists); <br> <br>            preq = GetWorkItem(); <br>            if (preq == NULL) { <br>                // done <br>                return; <br>            } <br> <br>            // one more item not on the done or work list <br>            m_cItemsOut++; <br> <br>            // release critsec <br>        } <br> <br>        preq-&gt;Complete(); <br> <br>        // regain critsec to replace on done list <br>        { <br>            CAutoLock l(&amp;m_csLists); <br> <br>            PutDoneItem(preq); <br> <br>            if (--m_cItemsOut == 0) { <br>                if (m_bWaiting) { <br>                    m_evAllDone.Set(); <br>                } <br>            } <br>        } <br>    } <br>} <br> <br>// the thread proc - assumes that DWORD thread param is the <br>// this pointer <br>DWORD <br>CAsyncIo::ThreadProc(void) <br>{ <br>    HANDLE ahev[] = {m_evStop, m_evWork}; <br> <br>    for (;;) { <br>DWORD dw = WaitForMultipleObjects( <br>    2, <br>    ahev, <br>    FALSE, <br>    INFINITE); <br>if (dw == WAIT_OBJECT_0+1) { <br> <br>    // requests need processing <br>    ProcessRequests(); <br>} else { <br>    // any error or stop event - we should exit <br>    return 0; <br>} <br>    } <br>} <br> <br> <br> <br>// perform a synchronous read request on this thread. <br>// may not be aligned - so we will have to buffer. <br>HRESULT <br>CAsyncIo::SyncRead( <br>            LONGLONG llPos, <br>            LONG lLength, <br>            BYTE* pBuffer) <br>{ <br>    if (IsAligned(llPos) &amp;&amp; <br>IsAligned(lLength) &amp;&amp; <br>IsAligned((LONG) pBuffer)) { <br>            LONG cbUnused; <br>    return SyncReadAligned(llPos, lLength, pBuffer, &amp;cbUnused); <br>    } <br> <br>    // not aligned with requirements - use buffered file handle. <br>    //!!! might want to fix this to buffer the data ourselves? <br> <br>    CAsyncRequest request; <br> <br>    HRESULT hr = request.Request( <br>                    this, <br>                    m_pStream, <br>                    llPos, <br>                    lLength, <br>                    FALSE, <br>                    pBuffer, <br>                    NULL, <br>                    0); <br> <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br> <br>    return request.Complete(); <br>} <br> <br>//  Return the alignment <br>HRESULT <br>CAsyncIo::Alignment(LONG *pl) <br>{ <br>    *pl = Alignment(); <br>    return S_OK; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
