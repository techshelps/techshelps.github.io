<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MEMFILE.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2718"></a>MEMFILE.CPP</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1996 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br>#include &lt;streams.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;asyncio.h&gt; <br>#include &lt;asyncrdr.h&gt; <br>#include "memfile.h" <br> <br>/*  Function prototypes */ <br>HRESULT SelectAndRender(CMemReader *pReader, IFilterGraph **pFG); <br>HRESULT PlayFileWait(IFilterGraph *pFG); <br> <br>/*  Read a file into memory, play it (or part of it), then exit */ <br> <br>int _cdecl main(int argc, char *argv[]) <br>{ <br>    if (argc &lt; 2 || argc &gt; 3) { <br>        printf("Usage : memfile foo.bar &lt;Kbytes per sec&gt;\n"); <br>        return 0; <br>    } <br>    DWORD dwKBPerSec = argc == 2 ? INFINITE : atoi(argv[2]); <br>    CMediaType mt; <br>    mt.majortype = MEDIATYPE_Stream; <br>    LPTSTR lpType; <br>    { <br>        /*  Find the extension */ <br>        int len = lstrlen(argv[1]); <br>        if (len &gt;= 4 &amp;&amp; argv[1][len - 4] == TEXT('.')) { <br>            lpType = argv[1] + len - 3; <br>        } else { <br>            printf("Invalid file extension\n"); <br>            return 1; <br>        } <br>    } <br>    if (lstrcmpi(lpType, TEXT("mpg")) == 0) { <br>        mt.subtype = MEDIASUBTYPE_MPEG1System; <br>    } else <br>    if (lstrcmpi(lpType, TEXT("mpa")) == 0) { <br>        mt.subtype = MEDIASUBTYPE_MPEG1Audio; <br>    } else <br>    if (lstrcmpi(lpType, TEXT("mpv")) == 0) { <br>        mt.subtype = MEDIASUBTYPE_MPEG1Video; <br>    } else <br>    if (lstrcmpi(lpType, TEXT("dat")) == 0) { <br>        mt.subtype = MEDIASUBTYPE_MPEG1VideoCD; <br>    } else <br>    if (lstrcmpi(lpType, TEXT("avi")) == 0) { <br>        mt.subtype = MEDIASUBTYPE_Avi; <br>    } else <br>    if (lstrcmpi(lpType, TEXT("mov")) == 0) { <br>        mt.subtype = MEDIASUBTYPE_QTMovie; <br>    } else <br>    if (lstrcmpi(lpType, TEXT("wav")) == 0) { <br>        mt.subtype = MEDIASUBTYPE_WAVE; <br>    } else <br>    { <br>        printf("Unknown file type %s\n", lpType); <br>        return 1; <br>    } <br> <br>    /*  Read the file */ <br>    HANDLE hFile = CreateFile(argv[1], <br>                              GENERIC_READ, <br>                              FILE_SHARE_READ, <br>                              NULL, <br>                              OPEN_EXISTING, <br>                              0, <br>                              NULL); <br>    if (hFile == INVALID_HANDLE_VALUE) { <br>        printf("Could not open %s\n", argv[1]); <br>        return 1; <br>    } <br> <br>    ULARGE_INTEGER uliSize; <br>    uliSize.LowPart = GetFileSize(hFile, &amp;uliSize.HighPart); <br> <br>    PBYTE pbMem = new BYTE[uliSize.LowPart]; <br>    if (pbMem == NULL) { <br>        printf("Could not allocate %d bytes\n", uliSize.LowPart); <br>        return 1; <br>    } <br> <br>    DWORD dwBytesRead; <br>    if (!ReadFile(hFile, <br>                  (LPVOID)pbMem, <br>                  uliSize.LowPart, <br>                  &amp;dwBytesRead, <br>                  NULL) || <br>        dwBytesRead != uliSize.LowPart) { <br>        printf("Could not read file\n"); <br>        CloseHandle(hFile); <br>        return 1; <br>    } <br>    CloseHandle(hFile); <br>    HRESULT hr = S_OK; <br> <br>    CoInitialize(NULL); <br> <br>    CMemStream Stream(pbMem, (LONGLONG)uliSize.QuadPart, dwKBPerSec); <br>    CMemReader *rdr = new CMemReader(&amp;Stream, &amp;mt, &amp;hr); <br>    if (FAILED(hr) || rdr == NULL) { <br>        delete rdr; <br>        printf("Could not create filter HRESULT 0x%8.8X\n", hr); <br>        CoUninitialize(); <br>        return 1; <br>    } <br> <br>    //  Make sure we don't accidentally go away! <br>    rdr-&gt;AddRef(); <br>    IFilterGraph *pFG = NULL; <br>    hr = SelectAndRender(rdr, &amp;pFG); <br> <br>    if (FAILED(hr)) { <br>        printf("Failed to create graph and render file HRESULT 0x%8.8X", <br>               hr); <br>    } else { <br>        //  Play the file <br>        HRESULT hr = PlayFileWait(pFG); <br>        if (FAILED(hr)) { <br>            printf("Failed to play graph HRESULT 0x%8.8X", <br>                   hr); <br>        } <br>    } <br>    rdr-&gt;Release(); <br>    if (pFG) { <br>        ULONG ulRelease = pFG-&gt;Release(); <br>        if (ulRelease != 0) { <br>            printf("Filter graph count not 0!  was %d", ulRelease); <br>        } <br>    } <br>    CoUninitialize(); <br>    return 0; <br>} <br> <br> <br>//  Select a filter into a graph and render its output pin, returning <br>//  the graph <br> <br>HRESULT SelectAndRender(CMemReader *pReader, IFilterGraph **ppFG) <br>{ <br>    /*  Create filter graph */ <br>    HRESULT hr = CoCreateInstance(CLSID_FilterGraph, <br>                                  NULL, <br>                                  CLSCTX_INPROC, <br>                                  IID_IFilterGraph, <br>                                  (void**) ppFG); <br> <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br> <br>    /*  Get the various interfaces we need */ <br> <br>    /*  Add our filter */ <br>    hr = (*ppFG)-&gt;AddFilter(pReader, NULL); <br> <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br> <br>    /*  Render our output pin */ <br>    IGraphBuilder *pBuilder; <br>    hr = (*ppFG)-&gt;QueryInterface(IID_IGraphBuilder, (void **)&amp;pBuilder); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br>    hr = pBuilder-&gt;Render(pReader-&gt;GetPin(0)); <br>    pBuilder-&gt;Release(); <br>    return hr; <br>} <br> <br>HRESULT PlayFileWait(IFilterGraph *pFG) <br>{ <br>    IMediaControl *pMC; <br>    IMediaEvent *pME; <br>    HRESULT hr = pFG-&gt;QueryInterface(IID_IMediaControl, (void **)&amp;pMC); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br> <br>    hr = pFG-&gt;QueryInterface(IID_IMediaEvent, (void **)&amp;pME); <br>    if (FAILED(hr)) { <br>        pMC-&gt;Release(); <br>        return hr; <br>    } <br> <br>    OAEVENT oEvent; <br>    hr = pME-&gt;GetEventHandle(&amp;oEvent); <br>    if (SUCCEEDED(hr)) { <br>        hr = pMC-&gt;Run(); <br>    } <br>    if (SUCCEEDED(hr)) { <br>        LONG levCode; <br>        hr = pME-&gt;WaitForCompletion(INFINITE, &amp;levCode); <br>    } <br>    pMC-&gt;Release(); <br>    pME-&gt;Release(); <br>    return hr; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
