<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ASYNCRDR.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2715"></a>ASYNCRDR.CPP</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br> <br>// <br>// Implementation of Io source filter methods and output pin methods for <br>// CAsyncReader and CAsyncOutputPin <br>// <br> <br>#include &lt;streams.h&gt; <br>#include "asyncio.h" <br>#include "asyncrdr.h" <br> <br> <br>// --- CAsyncOutputPin implementation --- <br> <br>CAsyncOutputPin::CAsyncOutputPin( <br>    HRESULT * phr, <br>    CAsyncReader *pReader, <br>    CAsyncIo *pIo, <br>    CCritSec * pLock) <br>  : CBasePin( <br>NAME("Async output pin"), <br>pReader, <br>pLock, <br>phr, <br>L"Output", <br>PINDIR_OUTPUT), <br>    m_pReader(pReader), <br>    m_pIo(pIo) <br>{ <br> <br>} <br> <br>CAsyncOutputPin::~CAsyncOutputPin() <br>{ <br>} <br> <br>STDMETHODIMP <br>CAsyncOutputPin::NonDelegatingQueryInterface(REFIID riid, void** ppv) <br>{ <br>    CheckPointer(ppv,E_POINTER); <br>    if (riid == IID_IAsyncReader) { <br>        m_bQueriedForAsyncReader = TRUE; <br>return GetInterface((IAsyncReader*) this, ppv); <br>    } else { <br>return CBasePin::NonDelegatingQueryInterface(riid, ppv); <br>    } <br>} <br> <br>HRESULT <br>CAsyncOutputPin::GetMediaType(int iPosition, CMediaType *pMediaType) <br>{ <br>    if (iPosition &lt; 0) { <br>return E_INVALIDARG; <br>    } <br>    if (iPosition &gt; 0) { <br>return VFW_S_NO_MORE_ITEMS; <br>    } <br>    *pMediaType = *m_pReader-&gt;LoadType(); <br>    return S_OK; <br>} <br> <br>HRESULT <br>CAsyncOutputPin::CheckMediaType(const CMediaType* pType) <br>{ <br>    CAutoLock lck(m_pLock); <br> <br>    /*  We treat MEDIASUBTYPE_NULL subtype as a wild card */ <br>    if ((m_pReader-&gt;LoadType()-&gt;majortype == pType-&gt;majortype) &amp;&amp; <br>(m_pReader-&gt;LoadType()-&gt;subtype == MEDIASUBTYPE_NULL || <br>         m_pReader-&gt;LoadType()-&gt;subtype == pType-&gt;subtype)) { <br>    return S_OK; <br>    } <br>    return S_FALSE; <br>} <br> <br>HRESULT <br>CAsyncOutputPin::InitAllocator(IMemAllocator **ppAlloc) <br>{ <br>    HRESULT hr = NOERROR; <br>    *ppAlloc = NULL; <br>    CMemAllocator *pMemObject = NULL; <br> <br>    /* Create a default memory allocator */ <br> <br>    pMemObject = new CMemAllocator(NAME("Base memory allocator"),NULL, &amp;hr); <br>    if (pMemObject == NULL) { <br>return E_OUTOFMEMORY; <br>    } <br> <br>    if (FAILED(hr)) { <br>delete pMemObject; <br>return hr; <br>    } <br> <br>    /* Get a reference counted IID_IMemAllocator interface */ <br> <br>    hr = pMemObject-&gt;QueryInterface(IID_IMemAllocator,(void **)ppAlloc); <br>    if (FAILED(hr)) { <br>delete pMemObject; <br>return E_NOINTERFACE; <br>    } <br>    ASSERT(*ppAlloc != NULL); <br>    return NOERROR; <br>} <br> <br>// we need to return an addrefed allocator, even if it is the preferred <br>// one, since he doesn't know whether it is the preferred one or not. <br>STDMETHODIMP <br>CAsyncOutputPin::RequestAllocator( <br>    IMemAllocator* pPreferred, <br>    ALLOCATOR_PROPERTIES* pProps, <br>    IMemAllocator ** ppActual) <br>{ <br>    // we care about alignment but nothing else <br>    if (!pProps-&gt;cbAlign || !m_pIo-&gt;IsAligned(pProps-&gt;cbAlign)) { <br>       m_pIo-&gt;Alignment(&amp;pProps-&gt;cbAlign); <br>    } <br>    ALLOCATOR_PROPERTIES Actual; <br>    HRESULT hr; <br>    if (pPreferred) { <br>hr = pPreferred-&gt;SetProperties(pProps, &amp;Actual); <br>if (SUCCEEDED(hr) &amp;&amp; m_pIo-&gt;IsAligned(Actual.cbAlign)) { <br>            pPreferred-&gt;AddRef(); <br>    *ppActual = pPreferred; <br>            return S_OK; <br>        } <br>    } <br> <br>    // create our own allocator <br>    IMemAllocator* pAlloc; <br>    hr = InitAllocator(&amp;pAlloc); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br> <br>    //...and see if we can make it suitable <br>    hr = pAlloc-&gt;SetProperties(pProps, &amp;Actual); <br>    if (SUCCEEDED(hr) &amp;&amp; m_pIo-&gt;IsAligned(Actual.cbAlign)) { <br>        // we need to release our refcount on pAlloc, and addref <br>        // it to pass a refcount to the caller - this is a net nothing. <br>        *ppActual = pAlloc; <br>        return S_OK; <br>    } <br> <br>    // failed to find a suitable allocator <br>    pAlloc-&gt;Release(); <br> <br>    // if we failed because of the IsAligned test, the error code will <br>    // not be failure <br>    if (SUCCEEDED(hr)) { <br>        hr = VFW_E_BADALIGN; <br>    } <br>    return hr; <br>} <br> <br> <br>// queue an aligned read request. call WaitForNext to get <br>// completion. <br>STDMETHODIMP <br>CAsyncOutputPin::Request( <br>    IMediaSample* pSample, <br>    DWORD dwUser)        // user context <br>{ <br>    REFERENCE_TIME tStart, tStop; <br>    HRESULT hr = pSample-&gt;GetTime(&amp;tStart, &amp;tStop); <br>    if (FAILED(hr)) { <br>return hr; <br>    } <br> <br>    LONGLONG llPos = tStart / UNITS; <br>    LONG lLength = (LONG) ((tStop - tStart) / UNITS); <br> <br>    LONGLONG llTotal; <br>    LONGLONG llAvailable; <br>    hr = m_pIo-&gt;Length(&amp;llTotal, &amp;llAvailable); <br>    if (llPos + lLength &gt; llTotal) { <br> <br>        // the end needs to be aligned, but may have been aligned <br>        // on a coarser alignment. <br>        LONG lAlign; <br>        m_pIo-&gt;Alignment(&amp;lAlign); <br>        llTotal = (llTotal + lAlign -1) &amp; ~(lAlign-1); <br> <br>        if (llPos + lLength &gt; llTotal) { <br>            lLength = (LONG) (llTotal - llPos); <br> <br>            // must be reducing this! <br>            ASSERT((llTotal * UNITS) &lt;= tStop); <br>            tStop = llTotal * UNITS; <br>            pSample-&gt;SetTime(&amp;tStart, &amp;tStop); <br>        } <br>    } <br> <br> <br> <br> <br>    BYTE* pBuffer; <br>    hr = pSample-&gt;GetPointer(&amp;pBuffer); <br>    if (FAILED(hr)) { <br>return hr; <br>    } <br> <br>    return m_pIo-&gt;Request( <br>llPos, <br>lLength, <br>                        TRUE, <br>pBuffer, <br>(LPVOID)pSample, <br>dwUser); <br>} <br> <br>// sync-aligned request. just like a request/waitfornext pair. <br>STDMETHODIMP <br>CAsyncOutputPin::SyncReadAligned( <br>                  IMediaSample* pSample) <br>{ <br>    REFERENCE_TIME tStart, tStop; <br>    HRESULT hr = pSample-&gt;GetTime(&amp;tStart, &amp;tStop); <br>    if (FAILED(hr)) { <br>return hr; <br>    } <br> <br>    LONGLONG llPos = tStart / UNITS; <br>    LONG lLength = (LONG) ((tStop - tStart) / UNITS); <br> <br>    LONGLONG llTotal; <br>    LONGLONG llAvailable; <br>    hr = m_pIo-&gt;Length(&amp;llTotal, &amp;llAvailable); <br>    if (llPos + lLength &gt; llTotal) { <br> <br>        // the end needs to be aligned, but may have been aligned <br>        // on a coarser alignment. <br>        LONG lAlign; <br>        m_pIo-&gt;Alignment(&amp;lAlign); <br>        llTotal = (llTotal + lAlign -1) &amp; ~(lAlign-1); <br> <br>        if (llPos + lLength &gt; llTotal) { <br>            lLength = (LONG) (llTotal - llPos); <br> <br>            // must be reducing this! <br>            ASSERT((llTotal * UNITS) &lt;= tStop); <br>            tStop = llTotal * UNITS; <br>            pSample-&gt;SetTime(&amp;tStart, &amp;tStop); <br>        } <br>    } <br> <br> <br> <br> <br>    BYTE* pBuffer; <br>    hr = pSample-&gt;GetPointer(&amp;pBuffer); <br>    if (FAILED(hr)) { <br>return hr; <br>    } <br> <br>    LONG cbActual; <br>    hr = m_pIo-&gt;SyncReadAligned( <br>llPos, <br>lLength, <br>pBuffer, <br>                        &amp;cbActual <br>                        ); <br> <br>    pSample-&gt;SetActualDataLength(cbActual); <br> <br>    return hr; <br>} <br> <br> <br>// <br>// collect the next ready sample <br>STDMETHODIMP <br>CAsyncOutputPin::WaitForNext( <br>    DWORD dwTimeout, <br>    IMediaSample** ppSample,  // completed sample <br>    DWORD * pdwUser)// user context <br>{ <br>    LONG cbActual; <br> <br>    IMediaSample* pSample; <br>    HRESULT hr =  m_pIo-&gt;WaitForNext( <br>    dwTimeout, <br>    (LPVOID*) &amp;pSample, <br>    pdwUser, <br>                            &amp;cbActual <br>                            ); <br>    if (SUCCEEDED(hr)) { <br>        pSample-&gt;SetActualDataLength(cbActual); <br>    } <br>    *ppSample = pSample; <br> <br>    return hr; <br>} <br> <br> <br>// <br>// synchronous read that need not be aligned. <br>STDMETHODIMP <br>CAsyncOutputPin::SyncRead( <br>    LONGLONG llPosition,// absolute Io position <br>    LONG lLength,// nr bytes required <br>    BYTE* pBuffer)// write data here <br>{ <br>    return m_pIo-&gt;SyncRead(llPosition, lLength, pBuffer); <br>} <br> <br>// return the length of the file, and the length currently <br>// available locally. We only support locally accessible files, <br>// so they are always the same <br>STDMETHODIMP <br>CAsyncOutputPin::Length( <br>    LONGLONG* pTotal, <br>    LONGLONG* pAvailable) <br>{ <br>    HRESULT hr = m_pIo-&gt;Length(pTotal, pAvailable); <br>    return hr; <br>} <br> <br>STDMETHODIMP <br>CAsyncOutputPin::BeginFlush(void) <br>{ <br>    return m_pIo-&gt;BeginFlush(); <br>} <br> <br>STDMETHODIMP <br>CAsyncOutputPin::EndFlush(void) <br>{ <br>    return m_pIo-&gt;EndFlush(); <br>} <br> <br> <br> <br> <br>// --- CAsyncReader implementation --- <br> <br>#pragma warning(disable:4355) <br> <br>CAsyncReader::CAsyncReader( <br>    TCHAR *pName, <br>    LPUNKNOWN pUnk, <br>    CAsyncStream *pStream, <br>    HRESULT *phr) <br>  : CBaseFilter( <br>      pName, <br>pUnk, <br>&amp;m_csFilter, <br>CLSID_AsyncReader, <br>        NULL <br>    ), <br>    m_OutputPin( <br>phr, <br>this, <br>&amp;m_Io, <br>&amp;m_csFilter), <br>    m_Io(pStream) <br>{ <br> <br>} <br> <br>CAsyncReader::~CAsyncReader() <br>{ <br>} <br> <br>int <br>CAsyncReader::GetPinCount() <br>{ <br>    return 1; <br>} <br> <br>CBasePin * <br>CAsyncReader::GetPin(int n) <br>{ <br>    if ((GetPinCount() &gt; 0) &amp;&amp; <br>(n == 0)) { <br>return &amp;m_OutputPin; <br>    } else { <br>return NULL; <br>    } <br>} <br> <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
