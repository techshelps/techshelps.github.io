<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DATATYPE.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2833"></a>DATATYPE.H</h2>
<pre><code>/************************************************************************ <br>*                                                                       * <br>*               INTEL CORPORATION PROPRIETARY INFORMATION               * <br>*                                                                       * <br>*    This listing is supplied under the terms of a license agreement    * <br>*      with INTEL Corporation and may not be copied nor disclosed       * <br>*        except in accordance with the terms of that agreement.         * <br>*                                                                       * <br>************************************************************************* <br>*                                                                       * <br>*Copyright (c) 1994-1997 Intel Corporation.* <br>*                         All Rights Reserved.                          * <br>*                                                                       * <br>************************************************************************/ <br> <br>#ifdef INCLUDE_NESTING_CHECK <br>#ifdef _OLE_DATATYPE_H__ <br>#pragma message("***** src\\encode\\ version of DATATYPE.H included multiple times") <br>#else <br>#define _OLE_DATATYPE_H__ <br>#pragma message ("src\\encode\\ version of DATATYPE.H being included first time") <br>#endif <br>#endif <br> <br>#ifndef __DATATYPE_H__ <br>#define __DATATYPE_H__ <br> <br>#ifdef INCLUDE_NESTING_CHECK <br>#pragma message ("src\\encode\\ version of DATATYPE.H actually being used") <br>#endif <br> <br>#include &lt;stddef.h&gt; <br>/* These are the non platform specific data types <br> * for which all data and return types are defined <br> */ <br> <br>/* These types of data must allways be the same <br> * number of bits regardless of the platform. <br> * Therefore, these generic names are defined <br> * to be: <br> *  <br> * U8      8 bits,  unsigned 0..255 <br> * I8      8 bits,  signed -128..127 <br> * U16     16 bits, unsigned 0..65535 <br> * I16     16 bits, signed -32768..32767 <br> * U32     32 bits, unsigned 0..4294967295 <br> * I32     32 bits, signed -2147483648..2147483647 <br> * Sngl    32 bit floating point (4 bytes) <br> * Dbl     64 bit floating point (8 bytes) <br> *  <br> * These pointers are naturally platform specific, <br> * but what they point to is allways the same size <br> * <br> *               These are huge pointers <br> * PU8 <br> * PI8 <br> * PU16 <br> * PI16 <br> * PU32 <br> * PI32 <br> * PSngl <br> * PDbl <br> *               These are far pointers <br> * FPU8 <br> * FPI8 <br> * FPU16 <br> * FPI16 <br> * FPU32 <br> * FPI32 <br> * FPSngl <br> * FPDbl <br> */ <br> <br>#if defined HUGE <br>#undef HUGE <br>#endif <br>#if defined FAR <br>#undef FAR <br>#endif <br>#if defined NEAR <br>#undef NEAR <br>#endif <br> <br>#if defined WINDOWS <br>#if defined WIN32 <br>/* WINDOWS NT data types, Only X86 support at this time */ <br>#define NEAR <br>#define FAR <br>#define HUGE <br> <br>// TCHAR should be appropriately defined in std header files - ?? <br>// #ifndef _TCHAR_DEFINED <br>// typedef wchar_t TCHAR; /* unicode for strings */ <br>// #endif <br> <br>typedef unsigned char  U8; <br>typedef signed char    I8; <br>typedef unsigned short U16; <br>typedef signed short   I16; <br>typedef unsigned long  U32; <br>typedef signed long    I32; <br>typedef float          Sngl; <br>typedef double         Dbl; <br> <br>#else /* WIN32 not defined */ <br>/* WINDOWS 3.x under DOS data types */ <br>#define NEAR _near <br>#define FAR  _far <br>#define HUGE _huge <br> <br>#ifndef _INC_TCHAR <br>typedef char far *LPTSTR; <br>typedef const char far *LPCTSTR; <br>typedef charTCHAR; <br>#define TEXT(quote)quote <br>#endif <br>#ifndef BOOLEAN <br>typedef char BOOLEAN; <br>#endif <br>#ifndef INT <br>typedef int INT; <br>#endif <br> <br>typedef unsigned char  U8; <br>typedef signed char    I8; <br>typedef unsigned short U16; <br>typedef signed short   I16; <br>typedef unsigned long  U32; <br>typedef signed long    I32; <br>typedef float          Sngl; <br>typedef double         Dbl; <br> <br>#endif /* WIN32 */ <br>#else /* WINDOWS not defined */ <br>/* UNIX data types */ <br>#define NEAR <br>#define FAR <br>#define HUGE <br>#define CDECL <br>#define BSENC 1 <br>#define HGLOBAL PI16 <br>#define LRESULT I32 <br>#define HINSTANCE PU8 <br> <br>typedef char TCHAR; /* for compatability with win/win32 datatypes for strings */ <br> <br>typedef unsigned char    U8; <br>typedef signed char      I8; <br>typedef unsigned short   U16; <br>typedef signed short int I16; <br>typedef unsigned long    U32; <br>typedef signed long      I32; <br>typedef float            Sngl; <br>typedef double           Dbl; <br> <br>/* move WIN32 UNICODE data types to UNIX data types */ <br>typedef char * LPTSTR; <br>typedef const char * LPCTSTR; <br> <br>#ifndef TEXT <br>#define TEXT(quote) quote <br>#endif /* TEXT */ <br>#endif /* WINDOWS */ <br> <br>typedef char Chr;        /* character string */ <br>typedef char Qchar;  /* quoted character string */ <br> <br>/* pointers */ <br>typedef Chr  NEAR * PChr;       /* near pointer to Character string */ <br>typedef U8   NEAR * PU8;        /* near pointer to unsigned char */ <br>typedef I8   NEAR * PI8;        /* near pointer to signed char */ <br>typedef U16  NEAR * PU16;       /* near pointer to unsigned 16 bit value */ <br>typedef I16  NEAR * PI16;       /* near pointer to signed 16 bit value */ <br>typedef U32  NEAR * PU32;       /* near pointer to unsigned 32 bit value */ <br>typedef I32  NEAR * PI32;       /* near pointer to signed 32 bit value */ <br>typedef Sngl NEAR * PSngl;      /* near pointer to single precision float */ <br>typedef Dbl  NEAR * PDbl;       /* near pointer to double precision float */ <br> <br>typedef Chr  FAR * FPChr;       /* far pointer to Character string */ <br>typedef U8   FAR * FPU8;        /* far pointer to unsigned char */ <br>typedef I8   FAR * FPI8;        /* far pointer to signed char */ <br>typedef U16  FAR * FPU16;       /* far pointer to unsigned 16 bit value */ <br>typedef I16  FAR * FPI16;       /* far pointer to signed 16 bit value */ <br>typedef U32  FAR * FPU32;       /* far pointer to unsigned 32 bit value */ <br>typedef I32  FAR * FPI32;       /* far pointer to signed 32 bit value */ <br>typedef Sngl FAR * FPSngl;      /* far pointer to single precision float */ <br>typedef Dbl  FAR * FPDbl;       /* far pointer to double precision float */ <br> <br>typedef Chr  HUGE * HPChr;      /* huge pointer to Character string */ <br>typedef U8   HUGE * HPU8;       /* huge pointer to unsigned char */ <br>typedef I8   HUGE * HPI8;       /* huge pointer to signed char */ <br>typedef U16  HUGE * HPU16;      /* huge pointer to unsigned 16 bit value */ <br>typedef I16  HUGE * HPI16;      /* huge pointer to signed 16 bit value */ <br>typedef U32  HUGE * HPU32;      /* huge pointer to unsigned 32 bit value */ <br>typedef I32  HUGE * HPI32;      /* huge pointer to signed 32 bit value */ <br>typedef Sngl HUGE * HPSngl;     /* huge pointer to single precision float */ <br>typedef Dbl  HUGE * HPDbl;      /* huge pointer to double precision float */ <br> <br>typedef PU8  NEAR * PPU8;        /* near handle to unsigned char */ <br>typedef PI8  NEAR * PPI8;        /* near handle to unsigned char */ <br>typedef PU16  NEAR * PPU16;        /* near handle to unsigned char */ <br>typedef PI16  NEAR * PPI16;        /* near handle to unsigned char */ <br>typedef PU32  NEAR * PPU32;        /* near handle to unsigned char */ <br>typedef PI32  NEAR * PPI32;        /* near handle to unsigned char */ <br> <br>/* These types of data do not need to be the <br> * same from platform to platform. The only <br> * concern is that the values represented by <br> * these types fit into the smallest bit size <br> * of any platform we port to. As new platforms <br> * are added, please update this table: <br> *  <br> *                  WIN3.x UNIX  WINNT (win32) <br> * NaturalInt:      16     32    32 <br> * NaturalUnsigned: 16     32    32 <br> *  <br> * These pointers are naturally platform specific, <br> * and what they point to is allowed to be <br> * platform specific also <br> * <br> *               These are huge pointers <br> * PNaturalInt <br> * PNaturalUnsigned <br> *               These are far pointers <br> * FPNaturalInt <br> * FPNaturalUnsigned <br> * <br> * For those who complain about long identifiers, <br> * these data types are spelled out specifically <br> * to avoid confusion with the fixed length data <br> * types and to let the reader who is unfamiliar <br> * with our coding practices know that these data <br> * types are different on each platform. The intent <br> * is to be obvious and obnoxious. <br> * <br> * to facilitate testing, define TEST_16_BITS <br> * which will force all natural data types to 16 bits <br> */ <br> <br>#if defined TEST_16_BITS <br>typedef I16 NaturalInt; <br>typedef U16 NaturalUnsigned; <br>#else <br>#if defined TEST_32_BITS <br>typedef I32 NaturalInt; <br>typedef U32 NaturalUnsigned; <br>#else <br>typedef signed int NaturalInt; <br>typedef unsigned int NaturalUnsigned; <br>#endif /* TEST_32_BITS */ <br>#endif /* TEST_16_BITS */ <br> <br>/* pointers */ <br>typedef NaturalInt HUGE *      PNaturalInt; <br>typedef NaturalUnsigned HUGE * PNaturalUnsigned; <br> <br>typedef NaturalInt FAR *       FPNaturalInt; <br>typedef NaturalUnsigned FAR *  FPNaturalUnsigned; <br> <br>/* logical types */ <br>typedef NaturalIntBoo;    /* was U32 */ <br>typedef BooBoolean; <br>typedef Boo*pBoo; <br> <br>/* BGR_ENTRY <br> * The BGR_ENTRY structure is used to define one color. <br> * Formerly in PIA_MAIN.H <br> */ <br>typedef struct { <br>U8 u8B; <br>U8 u8G; <br>U8 u8R; <br>U8 u8Reserved; <br>} BGR_ENTRY; <br>typedef BGR_ENTRY FAR * PTR_BGR_ENTRY; <br> <br>/* ASM interface */ <br>#if defined WIN32 <br>#define ASM_CALLTYPE _stdcall <br>#else <br>#define ASM_CALLTYPE <br>#endif <br> <br>typedef void NEAR * LOCAL_HANDLE; <br>typedef void NEAR * GLOBAL_HANDLE; <br>typedef void NEAR * VOID_LOCAL_PTR; <br>typedef void FAR * VOID_GLOBAL_PTR;   <br>typedef void HUGE * VOID_HUGE_PTR;   <br>typedef void NEAR * MUTEX_HANDLE; <br>typedef void NEAR * VOID_INSTANCE_PTR; <br> <br>#define PChrPU8 <br>#define TRUE  1 <br>#define FALSE 0 <br>// #define NULL 0  // Currently defined elsewhere <br> <br> <br>/* define useful macros */ <br> <br>// TO DO: Maybe these macros should go somewhere else (not in datatypes.h) <br> <br>#define ARSHIFT(a, b) ((a) &gt;&gt; (b)) <br> <br>#define MAX(a, b) ((a) &gt; (b) ? (a) : (b)) <br>#define MIN(a, b) ((a) &lt; (b) ? (a) : (b)) <br>#define MIN_MAX(a, l, h) ((a) &lt; (l) ? (l) : ((a) &gt; (h) ? (h) : (a))) <br>#define ABS(a) ((a) &lt; 0 ? (-(a)) : (a)) <br>#define ROUND(f) (I32)((f)&gt;=0? f + .4999999 : f - .4999999 ) <br>#define DIV2(x)     ((x)&gt;0?(x)&gt;&gt;1:-(-(x))&gt;&gt;1) <br>#define DIV_ROUND(x,d)     ((x)&gt;0?((x)+(d)/2)/(d):-(((-(x))+(d)/2)/(d))) <br>#define ROUND_SHIFT(a,shift) ( (a)&gt;0?((a)+(1&lt;&lt;((shift)-1)))&gt;&gt;(shift):-((-(a)+(1&lt;&lt;((shift)-1)))&gt;&gt;(shift))) <br> <br>/* <br> * The following are the matrix and rect datatypes, formerly located  <br> * in the simulator matrix toolkit code. <br> * <br> */ <br> <br>typedef struct { <br>I32 NumRows;/* dimensions of matrix (data - cf pitch) */ <br>I32 NumCols; <br>I32 Pitch;/* spacing between rows; &gt;= NumCols */ <br>PI16 pi16; <br>} MatrixSt, *PMatrixSt; <br> <br>typedef const MatrixSt *PCMatrixSt; <br> <br>typedef struct { <br>I32 r;/* row, column of upper left-hand corner */ <br>I32 c; <br>I32 h;/* height, width */ <br>I32 w; <br>} RectSt, *PRectSt, *pRectSt; <br> <br>typedef struct _Point { <br>U32 r, c; <br>} PointSt, *pPointSt; <br> <br>typedef const RectSt *PCRectSt; <br> <br> <br>#endif /* __DATATYPE_H__ */ </code></pre>
<p>&nbsp;</p></body>
</HTML>
