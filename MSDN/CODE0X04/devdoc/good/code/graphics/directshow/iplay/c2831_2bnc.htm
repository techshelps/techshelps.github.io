<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IPLAYDOC.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2838"></a>IPLAYDOC.CPP</h2>
<pre><code>// This code and information is provided "as is" without warranty of <br>// any kind, either expressed or implied, including but not limited to <br>// the implied warranties of merchantability and/or fitness for a <br>// particular purpose. <br> <br>// Copyright (C) 1996 - 1997 Intel corporation.  All rights reserved. <br> <br>// IPlaydoc.cpp : implementation of the CIPlayDoc class <br>// <br> <br>#include "stdafx.h" <br>#include "IPlay.h" <br>#include "IPlaydoc.h" <br> <br>#include &lt;initguid.h&gt;       // OLE (Quartz) initialization <br> <br>#include "ax_spec.h" <br> <br>#ifdef _DEBUG <br>#undef THIS_FILE <br>static char BASED_CODE THIS_FILE[] = __FILE__; <br>#endif <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CIPlayDoc <br> <br>IMPLEMENT_DYNCREATE(CIPlayDoc, CDocument) <br> <br>#define new DEBUG_NEW //Checking for mem leaks in debug mode <br> <br>BEGIN_MESSAGE_MAP(CIPlayDoc, CDocument) <br>//{{AFX_MSG_MAP(CIPlayDoc) <br>ON_COMMAND(ID_MEDIA_LOOP, OnMediaLoop) <br>ON_COMMAND(ID_MEDIA_PAUSE, OnMediaPause) <br>ON_COMMAND(ID_MEDIA_ZOOMX2, OnMediaZoomx2) <br>ON_UPDATE_COMMAND_UI(ID_MEDIA_PAUSE, OnUpdateMediaPause) <br>ON_UPDATE_COMMAND_UI(ID_MEDIA_PLAY, OnUpdateMediaPlay) <br>ON_UPDATE_COMMAND_UI(ID_MEDIA_STOP, OnUpdateMediaStop) <br>ON_UPDATE_COMMAND_UI(ID_MEDIA_ZOOMX2, OnUpdateMediaZoomx2) <br>ON_UPDATE_COMMAND_UI(ID_MEDIA_LOOP, OnUpdateMediaLoop) <br>ON_COMMAND(ID_MEDIA_PLAY, OnMediaPlay) <br>ON_COMMAND(ID_MEDIA_STOP, OnMediaStop) <br>//}}AFX_MSG_MAP <br>END_MESSAGE_MAP() <br> <br>R4_DEC_SEQ_DATA   m_r4SeqData;  // Indeo data structures <br>R4_DEC_FRAME_DATA m_r4FrameData; <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CIPlayDoc construction/destruction <br> <br>CIPlayDoc::CIPlayDoc() <br>{ <br>m_pGraph      = NULL; <br>m_hGraphEvent = NULL; <br>m_pIndeo      = NULL; <br>m_lpstrPath[0] = '\0'; <br>m_bLoop       = FALSE; <br>m_bZoom  = FALSE; <br>m_lWidth  = 0; <br>m_lHeight  = 0; <br>    m_State       = Uninitialized; <br> <br>// Initialize the headers for the Indeo data structures <br>// This stuff never changes (except for dwFlags) <br>m_r4FrameData.dwSize = sizeof(R4_DEC_FRAME_DATA); <br>m_r4FrameData.dwFourCC = FOURCC_IV41; <br>m_r4FrameData.dwVersion = SPECIFIC_INTERFACE_VERSION; <br>m_r4FrameData.oeEnvironment = OE_32; <br>m_r4FrameData.dwFlags = 0; <br> <br>m_r4SeqData.dwSize = sizeof(R4_DEC_SEQ_DATA); <br>m_r4SeqData.dwFourCC = FOURCC_IV41; <br>m_r4SeqData.dwVersion = SPECIFIC_INTERFACE_VERSION; <br>m_r4SeqData.oeEnvironment = OE_32; <br>m_r4SeqData.dwFlags = 0; <br> <br>    ((CIPlayApp *) AfxGetApp())-&gt;OnDocumentCreated( this ); <br>} <br> <br>CIPlayDoc::~CIPlayDoc() <br>{ <br>DeleteContents(); <br> <br>((CIPlayApp *) AfxGetApp())-&gt;OnDocumentDestroyed( this ); <br> <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CIPlayDoc diagnostics <br> <br>#ifdef _DEBUG <br>void CIPlayDoc::AssertValid() const <br>{ <br>CDocument::AssertValid(); <br>} <br> <br>void CIPlayDoc::Dump(CDumpContext&amp; dc) const <br>{ <br>CDocument::Dump(dc); <br>} <br>#endif //_DEBUG <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CIPlayDoc Message Handlers <br> <br>BOOL CIPlayDoc::OnOpenDocument(LPCTSTR lpszPathName)  <br>{ <br>    WCHAR     wPath[MAX_PATH]; <br> <br>char szDrive[ _MAX_DRIVE ] ; <br>char szDir[ _MAX_DIR ]; <br>char szFname[ _MAX_FNAME ]; <br>char szExt[ _MAX_EXT ]; <br> <br>IBaseFilter  *pFilter;  // EnumFilters vars <br>IEnumFilters *pEnum; <br>ULONG        pcFetched; <br>HRESULT      hr; <br>//HWND        hVidWin; <br> <br>void *pIF;  // generic interface to graph object <br> <br>// Get rid of any previously opened graph. <br>    DeleteContents(); <br> <br>// Create a new filter graph object. <br>    if ( !CreateFilterGraph() ) { <br>        AfxMessageBox(IDS_CANT_INIT_QUARTZ); <br>        return FALSE; <br>    } <br> <br>// Render the file using the new filter graph. <br>// This will add the necessary filters to the <br>// graph (which up til now was empty). <br>strcpy(m_lpstrPath, lpszPathName); <br>    MultiByteToWideChar( CP_ACP, 0, lpszPathName, <br>                         -1, wPath, MAX_PATH ); <br> <br>    hr = m_pGraph-&gt;QueryInterface(IID_IGraphBuilder, &amp;pIF); <br> <br>    if (FAILED( ((IGraphBuilder *)pIF)-&gt;RenderFile(wPath, NULL) )) { <br>        AfxMessageBox(IDS_CANT_RENDER_FILE); <br>        return FALSE; <br>    } <br>((IGraphBuilder *)pIF)-&gt;Release(); <br> <br> <br>// Position and set the title of the video window. <br>_splitpath( lpszPathName, szDrive, szDir, szFname, szExt ); <br>MultiByteToWideChar( CP_ACP, 0, CString(szFname) + szExt,-1, <br> wPath, _MAX_FNAME + _MAX_EXT); <br> <br> <br>SetWindow((BSTR)wPath); <br> <br>// Get and save the native video size -- used for  <br>// zoom by 2. <br>hr = m_pGraph-&gt;QueryInterface(IID_IBasicVideo, &amp;pIF); <br> <br>    if( SUCCEEDED(hr) ){ <br>((IBasicVideo *)pIF)-&gt;GetVideoSize(&amp;m_lWidth, &amp;m_lHeight); <br>((IBasicVideo *)pIF)-&gt;Release(); <br>} <br> <br>// Call the stop function to queue up the first <br>// frame of the clip.  Have to set the state first <br>// to Paused so we can transistion to Stopped. <br>m_State = Paused; <br>OnMediaStop(); <br> <br>// See if the Indeo codec filter is in the graph. <br>hr = m_pGraph-&gt;EnumFilters(&amp;pEnum); <br> <br>if (FAILED(hr)) <br>return TRUE; <br> <br>while ((hr = pEnum-&gt;Next(1, &amp;pFilter, &amp;pcFetched)) == S_OK) <br>{ <br>hr = pFilter-&gt;QueryInterface(IID_IIndeoDecode, &amp;m_pIndeo); <br>pFilter-&gt;Release(); <br>if (hr == S_OK) <br>break; <br> <br>} <br>// This interface needs to be released, even though <br>// it was not obtained in the usual way with QueryInterface. <br>pEnum-&gt;Release();  <br> <br>// Someday, the following line can replace the above section of code <br>// that enumerates the filters in the graph to find the  <br>// IIndeoDecode interface, but apparently that someday is not today. <br> <br>//hr = m_pGraph-&gt;QueryInterface(IID_IIndeoDecode, &amp;m_pIndeo); <br> <br>return TRUE; <br>} <br> <br>void CIPlayDoc::OnGraphNotify(void) { <br>    IMediaEvent *pME; <br>    long lEventCode, lParam1, lParam2; <br> <br>    ASSERT( m_hGraphEvent != NULL ); <br> <br>    if( SUCCEEDED(m_pGraph-&gt;QueryInterface(IID_IMediaEvent, (void **) &amp;pME))){ <br>        if( SUCCEEDED(pME-&gt;GetEvent(&amp;lEventCode, &amp;lParam1, &amp;lParam2, 0)) )  { <br> <br>switch (lEventCode) { <br> <br>            case EC_COMPLETE: <br>            OnMediaStop(); <br>if (m_bLoop) OnMediaPlay(); <br>break; <br>            case EC_USERABORT: <br>            case EC_ERRORABORT: <br>                OnMediaStop(); <br>        } <br>} <br> <br>    pME-&gt;Release(); <br>} <br> <br>    // Send a message so toolbar gets updated <br>    PostMessage( AfxGetMainWnd()-&gt;m_hWnd, WM_USER, 0, 0 ); <br> <br>} <br> <br>void CIPlayDoc::OnMediaLoop()  <br>{ <br>m_bLoop = !m_bLoop; <br> <br>} <br> <br>void CIPlayDoc::OnMediaPause()  <br>{ <br>if( CanPause() ){ <br>        HRESULThr; <br>        IMediaControl *pMC; <br> <br>        // Obtain the interface to our filter graph <br>        hr = m_pGraph-&gt;QueryInterface(IID_IMediaControl, (void **) &amp;pMC); <br> <br>        if( SUCCEEDED(hr) ){ <br>            // Ask the filter graph to pause and release the interface <br>            hr = pMC-&gt;Pause(); <br>            pMC-&gt;Release(); <br> <br>            if( SUCCEEDED(hr) ){ <br>                m_State = Paused; <br>                return; <br>            } <br>        } <br>} <br> <br>} <br> <br>void CIPlayDoc::OnMediaPlay()  <br>{ <br>    if( CanPlay() ){ <br>        HRESULThr; <br>        IMediaControl *pMC; <br> <br>        // Obtain the interface to our filter graph <br>        hr = m_pGraph-&gt;QueryInterface(IID_IMediaControl, (void **) &amp;pMC); <br> <br>        if( SUCCEEDED(hr) ){ <br>            // Ask the filter graph to play and release the interface <br>            hr = pMC-&gt;Run(); <br>            pMC-&gt;Release(); <br> <br>            if( SUCCEEDED(hr) ){ <br>                m_State=Playing; <br>// Let Indeo view object know the state changed <br>UpdateAllViews(NULL); <br>                return; <br>            } <br>        } <br>} <br> <br>} <br> <br>void CIPlayDoc::OnMediaStop()  <br>{ <br>if( CanStop() ){ <br>        HRESULThr; <br>        IMediaControl *pMC; <br>IMediaPosition *pMP; <br>OAFilterState fstate; <br> <br>        // Obtain the interface to our filter graph <br>        hr = m_pGraph-&gt;QueryInterface(IID_IMediaControl, (void **) &amp;pMC); <br> <br>        if( SUCCEEDED(hr) ){ <br>            // Ask the filter graph to stop and release the interface <br> <br>// put graph in stopped state <br>            hr = pMC-&gt;Stop();   <br> <br>// Rewind the stream <br>hr = m_pGraph-&gt;QueryInterface(IID_IMediaPosition, (void **) &amp;pMP); <br>hr = pMP-&gt;put_CurrentPosition(0); <br>hr = pMP-&gt;Release(); <br> <br>// Flush the graph <br>hr = pMC-&gt;Pause(); <br> <br>// Wait for state transition to complete <br>hr = pMC-&gt;GetState(5000, &amp;fstate); <br> <br>// Now back to stopped state <br>hr = pMC-&gt;Stop(); <br> <br>            pMC-&gt;Release(); <br> <br>            if( SUCCEEDED(hr) ){ <br>                m_State = Stopped; <br>// Let Indeo view object know the state changed <br>UpdateAllViews(NULL); <br>                return; <br>            } <br>        } <br>} <br> <br>} <br> <br>void CIPlayDoc::OnMediaZoomx2()  <br>{ <br>// This function doubles the width &amp; height of the original video <br>// size -- depending on the hardware, this may result in a <br>// better quality video than a random stretch of the video window. <br>// Subsequent calls toggle the video size between the original size  <br>// and the "x2" size, ignoring the fact that the user may have  <br>// resized the window using the window frame.  The function attempts to  <br>// keep the video window's center in place (zooms/unzooms from top, <br>// bottom, right and left). <br> <br>HRESULT hr; <br>void *pIF; <br>long x,y,width,height,width2,height2; <br> <br>m_bZoom = !m_bZoom; <br> <br>hr = m_pGraph-&gt;QueryInterface(IID_IVideoWindow, &amp;pIF); <br> <br>    if( SUCCEEDED(hr) ){ <br>if (m_bZoom) { <br>// Set the width &amp; height to twice the native video size <br>// Allow for the window frame -- we really want to just <br>// double the size of the client area. <br>width2 = (m_lWidth * 2) + (m_lWinWidth - m_lWidth); <br>height2 = (m_lHeight * 2) + (m_lWinHeight - m_lHeight); <br>((IVideoWindow *)pIF)-&gt;GetWindowPosition(&amp;x, &amp;y, &amp;width, &amp;height); <br>((IVideoWindow *)pIF)-&gt;SetWindowPosition(x + (width - width2)/2, <br>y + (height - height2)/2, width2, height2); <br>} <br>else { <br>// Restore original size <br>((IVideoWindow *)pIF)-&gt;GetWindowPosition(&amp;x, &amp;y, &amp;width, &amp;height); <br>((IVideoWindow *)pIF)-&gt;SetWindowPosition(x + <br>(width - m_lWinWidth)/2, y + (height - m_lWinHeight)/2, <br>m_lWinWidth, m_lWinHeight); <br>}  <br> <br>((IVideoWindow *)pIF)-&gt;Release(); <br> <br>} <br>} <br> <br>void CIPlayDoc::OnUpdateMediaPause(CCmdUI* pCmdUI)  <br>{ <br>    pCmdUI-&gt;Enable( CanPause() ); <br> <br>} <br> <br>void CIPlayDoc::OnUpdateMediaPlay(CCmdUI* pCmdUI)  <br>{ <br>    pCmdUI-&gt;Enable( CanPlay() ); <br> <br>} <br> <br>void CIPlayDoc::OnUpdateMediaStop(CCmdUI* pCmdUI)  <br>{ <br>    pCmdUI-&gt;Enable( CanStop() ); <br> <br>} <br> <br>void CIPlayDoc::OnUpdateMediaLoop(CCmdUI* pCmdUI)  <br>{ <br>    pCmdUI-&gt;Enable( IsInitialized() ); <br>pCmdUI-&gt;SetCheck( m_bLoop ); <br> <br>} <br> <br>void CIPlayDoc::OnUpdateMediaZoomx2(CCmdUI* pCmdUI)  <br>{ <br>    pCmdUI-&gt;Enable( IsInitialized() ); <br>pCmdUI-&gt;SetCheck( m_bZoom ); <br> <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CIPlayDoc Commands <br> <br>BOOL CIPlayDoc::IsIndeo() <br>{ <br>return (m_pIndeo != NULL); <br>} <br> <br>void CIPlayDoc::GetTransFillRGB(int&amp; red, int&amp; green, int&amp; blue) <br>{ <br>HRESULT hr; <br> <br>m_r4FrameData.mtType = MT_DECODE_FRAME_VALUE; <br> <br>m_r4FrameData.dwFlags = DECFRAME_FILL_COLOR | <br>DECFRAME_VALID; <br> <br>m_r4FrameData.dwFillColor = DECFRAME_FILL_UNDEFINED; <br> <br>hr = ((IIndeoDecode *)m_pIndeo)-&gt;get_DecodeFrame(&amp;m_r4FrameData); <br> <br>if (FAILED( hr )) { <br>        AfxMessageBox(IDS_CANT_GET_FRAME_DATA); <br>return; <br>} <br> <br>if (m_r4FrameData.dwFillColor &amp; DECFRAME_FILL_UNDEFINED) { <br>red   = 0; <br>green =0; <br>blue  =0; <br>} else { // Fill color is valid <br>red   = (m_r4FrameData.dwFillColor&amp;0x00FF0000)&gt;&gt;16; <br>green =(m_r4FrameData.dwFillColor&amp;0x0000FF00)&gt;&gt;8; <br>blue  =(m_r4FrameData.dwFillColor&amp;0x000000FF); <br>} <br> <br>return; <br>} <br> <br> <br>void CIPlayDoc::GetBCS(int&amp; b, int&amp; c, int&amp; s) <br>{ <br>HRESULT hr; <br> <br>m_r4FrameData.mtType = MT_DECODE_FRAME_VALUE; <br>m_r4FrameData.dwFlags = DECFRAME_BRIGHTNESS | <br>DECFRAME_CONTRAST | <br>DECFRAME_SATURATION | <br>DECFRAME_VALID; <br> <br>hr = ((IIndeoDecode *)m_pIndeo)-&gt;get_DecodeFrame(&amp;m_r4FrameData); <br> <br>if (FAILED( hr )) { <br>        AfxMessageBox(IDS_CANT_GET_FRAME_DATA); <br>return; <br>} <br> <br>b = LOWORD(m_r4FrameData.lBrightness); <br>c = LOWORD(m_r4FrameData.lContrast); <br>s = LOWORD(m_r4FrameData.lSaturation); <br> <br>return; <br>} <br> <br>void CIPlayDoc::GetDecodeTime(DWORD&amp; time) <br>{ <br>HRESULT hr; <br> <br>m_r4FrameData.mtType = MT_DECODE_FRAME_VALUE; <br>m_r4FrameData.dwFlags = DECFRAME_TIME_LIMIT | DECFRAME_VALID; <br> <br>hr = ((IIndeoDecode *)m_pIndeo)-&gt;get_DecodeFrame(&amp;m_r4FrameData); <br> <br>if (FAILED( hr )) { <br>        AfxMessageBox(IDS_CANT_SET_FRAME_DATA); <br>return; <br>} <br> <br>time = m_r4FrameData.dwTimeLimit; <br> <br>return; <br>} <br> <br> <br>void CIPlayDoc::GetDecodeRect(DWORD&amp; x, DWORD&amp; y, DWORD&amp; width, DWORD&amp; height) <br>{ <br>HRESULT hr; <br> <br>m_r4FrameData.mtType = MT_DECODE_FRAME_VALUE; <br>m_r4FrameData.dwFlags = DECFRAME_DECODE_RECT | DECFRAME_VALID; <br> <br>hr = ((IIndeoDecode *)m_pIndeo)-&gt;get_DecodeFrame(&amp;m_r4FrameData); <br> <br>if (FAILED( hr )) { <br>        AfxMessageBox(IDS_CANT_GET_FRAME_DATA); <br>return; <br>} <br> <br>x = m_r4FrameData.rDecodeRect.dwX; <br>y = m_r4FrameData.rDecodeRect.dwY; <br>width = m_r4FrameData.rDecodeRect.dwWidth; <br>height = m_r4FrameData.rDecodeRect.dwHeight; <br> <br>return; <br>} <br> <br>void CIPlayDoc::GetViewRect(DWORD&amp; x, DWORD&amp; y, DWORD&amp; width, DWORD&amp; height) <br>{ <br>HRESULT hr; <br> <br>m_r4FrameData.mtType = MT_DECODE_FRAME_VALUE; <br>m_r4FrameData.dwFlags = DECFRAME_VIEW_RECT | DECFRAME_VALID; <br> <br>hr = ((IIndeoDecode *)m_pIndeo)-&gt;get_DecodeFrame(&amp;m_r4FrameData); <br> <br>if (FAILED( hr )) { <br>        AfxMessageBox(IDS_CANT_GET_FRAME_DATA); <br>return; <br>} <br> <br>x = m_r4FrameData.rViewRect.dwX; <br>y = m_r4FrameData.rViewRect.dwY; <br>width = m_r4FrameData.rViewRect.dwWidth; <br>height = m_r4FrameData.rViewRect.dwHeight; <br> <br>return; <br>} <br> <br>void CIPlayDoc::GetSequenceOptions(BOOL&amp; altline, BOOL&amp; ddframes, BOOL&amp; ddquality, BOOL&amp; trans, BOOL&amp; usekey, <br>DWORD&amp; key) <br>{ <br>HRESULT hr; <br> <br>m_r4SeqData.mtType = MT_DECODE_SEQ_VALUE; <br>m_r4SeqData.dwFlags =DECSEQ_KEY | <br>DECSEQ_SCALABILITY | <br>DECSEQ_FILL_TRANSPARENT | <br>DECSEQ_ALT_LINE | <br>DECSEQ_VALID; <br> <br>hr = ((IIndeoDecode *)m_pIndeo)-&gt;get_DecodeSequence(&amp;m_r4SeqData); <br> <br>if (FAILED( hr )) { <br>        AfxMessageBox(IDS_CANT_GET_SEQ_DATA); <br>return; <br>} <br> <br>altline = m_r4SeqData.fAltLine; <br>     <br>switch (m_r4SeqData.eScalability) <br>{ <br>case SC_ON: <br>ddframes = ddquality = FALSE; <br>break; <br>case SC_OFF: <br>ddframes = ddquality = TRUE; <br>break; <br>case SC_DONT_DROP_FRAMES: <br>ddframes = TRUE; <br>ddquality = FALSE; <br>break; <br>case SC_DONT_DROP_QUALITY: <br>ddframes = FALSE; <br>ddquality = TRUE; <br>break; <br>} <br> <br>trans = m_r4SeqData.fFillTransparentPixels; <br>usekey = m_r4SeqData.fEnabledKey; <br>key = m_r4SeqData.dwKey; <br> <br>return; <br>} <br> <br>void CIPlayDoc::SetTransFillRGB(DWORD rgb) <br>{ <br>HRESULT hr; <br> <br>m_r4FrameData.mtType = MT_DECODE_FRAME_VALUE; <br>m_r4FrameData.dwFlags = DECFRAME_VALID | DECFRAME_FILL_COLOR; <br> <br>m_r4FrameData.dwFillColor = rgb; <br> <br>hr = ((IIndeoDecode *)m_pIndeo)-&gt;set_DecodeFrame(&amp;m_r4FrameData); <br> <br>if (FAILED( hr ))  <br>        AfxMessageBox(IDS_CANT_SET_FRAME_DATA); <br> <br>return; <br>} <br> <br>void CIPlayDoc::SetBCS(int b, int c, int s) <br>{ <br>HRESULT hr; <br> <br>m_r4FrameData.mtType = MT_DECODE_FRAME_VALUE; <br>m_r4FrameData.dwFlags = DECFRAME_BRIGHTNESS | <br>DECFRAME_CONTRAST | <br>DECFRAME_SATURATION | <br>DECFRAME_VALID; <br> <br>m_r4FrameData.lBrightness = b; <br>m_r4FrameData.lContrast = c; <br>m_r4FrameData.lSaturation = s; <br> <br>hr = ((IIndeoDecode *)m_pIndeo)-&gt;set_DecodeFrame(&amp;m_r4FrameData); <br> <br>if (FAILED( hr ))  <br>        AfxMessageBox(IDS_CANT_SET_FRAME_DATA); <br> <br>return; <br>} <br> <br> <br>void CIPlayDoc::SetDecodeTime(DWORD time) <br>{ <br>HRESULT hr; <br> <br>m_r4FrameData.mtType = MT_DECODE_FRAME_VALUE; <br>m_r4FrameData.dwFlags = DECFRAME_TIME_LIMIT | DECFRAME_VALID; <br> <br>m_r4FrameData.dwTimeLimit = time; <br> <br>hr = ((IIndeoDecode *)m_pIndeo)-&gt;set_DecodeFrame(&amp;m_r4FrameData); <br> <br>if (FAILED( hr ))  <br>        AfxMessageBox(IDS_CANT_SET_FRAME_DATA); <br> <br>return; <br>} <br> <br>void CIPlayDoc::SetDecodeRect(DWORD x, DWORD y, DWORD width, DWORD height) <br>{ <br>HRESULT hr; <br> <br>m_r4FrameData.mtType = MT_DECODE_FRAME_VALUE; <br> <br>m_r4FrameData.dwFlags = DECFRAME_DECODE_RECT |  <br>DECFRAME_VALID; <br> <br>m_r4FrameData.rDecodeRect.dwX = x; <br>m_r4FrameData.rDecodeRect.dwY = y; <br>m_r4FrameData.rDecodeRect.dwWidth = width; <br>m_r4FrameData.rDecodeRect.dwHeight = height; <br> <br>m_r4FrameData.rDecodeRect.dwX = x; <br>m_r4FrameData.rDecodeRect.dwY = y; <br>m_r4FrameData.rDecodeRect.dwWidth = width; <br>m_r4FrameData.rDecodeRect.dwHeight = height; <br> <br>hr = ((IIndeoDecode *)m_pIndeo)-&gt;set_DecodeFrame(&amp;m_r4FrameData); <br> <br>if (FAILED( hr ))  <br>        AfxMessageBox(IDS_CANT_SET_FRAME_DATA); <br> <br>return; <br>} <br> <br>void CIPlayDoc::SetViewRect(BOOL view ,DWORD x, DWORD y, DWORD width, DWORD height) <br>{ <br>HRESULT hr; <br> <br>m_r4FrameData.mtType = MT_DECODE_FRAME_VALUE; <br>m_r4FrameData.dwFlags = DECFRAME_VIEW_RECT |  <br>DECFRAME_VIEW_RECT_ORIGIN | <br>DECFRAME_VALID; <br> <br>m_r4FrameData.fViewRectOrigin = view; <br> <br>m_r4FrameData.rViewRect.dwX = x; <br>m_r4FrameData.rViewRect.dwY = y; <br>m_r4FrameData.rViewRect.dwWidth = width; <br>m_r4FrameData.rViewRect.dwHeight = height; <br> <br>hr = ((IIndeoDecode *)m_pIndeo)-&gt;set_DecodeFrame(&amp;m_r4FrameData); <br> <br>if (FAILED( hr ))  <br>        AfxMessageBox(IDS_CANT_SET_FRAME_DATA); <br> <br>return; <br>} <br> <br>void CIPlayDoc::SetSequenceOptions(BOOL altline, LONG scal, BOOL fill, BOOL usekey, DWORD key) <br>{ <br>HRESULT hr; <br> <br>m_r4SeqData.mtType = MT_DECODE_SEQ_VALUE; <br>m_r4SeqData.dwFlags =DECSEQ_KEY | <br>DECSEQ_SCALABILITY | <br>DECSEQ_FILL_TRANSPARENT | <br>DECSEQ_ALT_LINE | <br>DECSEQ_VALID; <br> <br>m_r4SeqData.fAltLine = altline; <br>m_r4SeqData.eScalability = scal; <br>m_r4SeqData.fFillTransparentPixels = fill; <br>m_r4SeqData.fEnabledKey = usekey; <br>m_r4SeqData.dwKey = key; <br> <br>hr = ((IIndeoDecode *)m_pIndeo)-&gt;set_DecodeSequence(&amp;m_r4SeqData); <br> <br>if (FAILED( hr ))  <br>        AfxMessageBox(IDS_CANT_SET_SEQ_DATA); <br> <br>return; <br>} <br> <br>void CIPlayDoc::GetFrameDefaults(int&amp; b, int&amp; c, int&amp; s, DWORD&amp; time, <br>  DWORD&amp; dx, DWORD&amp; dy, DWORD&amp; dWidth, DWORD&amp; dHeight, <br>  DWORD&amp; vx, DWORD&amp; vy, DWORD&amp; vWidth, DWORD&amp; vHeight) <br>{ <br>HRESULT hr; <br> <br>m_r4FrameData.mtType = MT_DECODE_FRAME_DEFAULT; <br>m_r4FrameData.dwFlags = DECFRAME_BRIGHTNESS | <br>DECFRAME_CONTRAST | <br>DECFRAME_SATURATION |  <br>DECFRAME_TIME_LIMIT | <br>DECFRAME_DECODE_RECT | <br>DECFRAME_VIEW_RECT | <br>DECFRAME_VIEW_RECT_ORIGIN | <br>DECFRAME_VALID; <br> <br>hr = ((IIndeoDecode *)m_pIndeo)-&gt;get_DecodeFrame(&amp;m_r4FrameData); <br> <br>if (FAILED( hr )) { <br>        AfxMessageBox(IDS_CANT_GET_FRAME_DATA); <br>return; <br>} <br> <br>b = LOWORD(m_r4FrameData.lBrightness); <br>c = LOWORD(m_r4FrameData.lContrast); <br>s = LOWORD(m_r4FrameData.lSaturation); <br> <br> <br>time = m_r4FrameData.dwTimeLimit; <br> <br>dx = m_r4FrameData.rDecodeRect.dwX; <br>dy = m_r4FrameData.rDecodeRect.dwY; <br>dWidth = m_r4FrameData.rDecodeRect.dwWidth; <br>dHeight = m_r4FrameData.rDecodeRect.dwHeight; <br> <br>vx = m_r4FrameData.rViewRect.dwX; <br>vy = m_r4FrameData.rViewRect.dwY; <br>vWidth = m_r4FrameData.rViewRect.dwWidth; <br>vHeight = m_r4FrameData.rViewRect.dwHeight; <br> <br>return; <br>} <br> <br>void CIPlayDoc::GetSeqDefaults(BOOL&amp; altline, BOOL&amp; ddframes, BOOL&amp; ddquality, BOOL&amp; trans, BOOL&amp; usekey, <br>DWORD&amp; key) <br>{ <br>HRESULT hr; <br> <br>m_r4SeqData.mtType = MT_DECODE_SEQ_DEFAULT; <br>m_r4SeqData.dwFlags =DECSEQ_KEY | <br>DECSEQ_SCALABILITY | <br>DECSEQ_FILL_TRANSPARENT | <br>DECSEQ_ALT_LINE | <br>DECSEQ_VALID; <br> <br>hr = ((IIndeoDecode *)m_pIndeo)-&gt;get_DecodeSequence(&amp;m_r4SeqData); <br> <br>if (FAILED( hr )) { <br>        AfxMessageBox(IDS_CANT_GET_SEQ_DATA); <br>return; <br>} <br> <br>altline = m_r4SeqData.fAltLine; <br>     <br>switch (m_r4SeqData.eScalability) <br>{ <br>case SC_ON: <br>ddframes = ddquality = FALSE; <br>break; <br>case SC_OFF: <br>ddframes = ddquality = TRUE; <br>break; <br>case SC_DONT_DROP_FRAMES: <br>ddframes = TRUE; <br>ddquality = FALSE; <br>break; <br>case SC_DONT_DROP_QUALITY: <br>ddframes = FALSE; <br>ddquality = TRUE; <br>break; <br>} <br> <br>trans = m_r4SeqData.fFillTransparentPixels; <br>usekey = m_r4SeqData.fEnabledKey; <br>key = m_r4SeqData.dwKey; <br>} <br> <br>ULONG CIPlayDoc::VideoWidth() <br>{ <br>HRESULT hr; <br>IBasicVideo *pIF; <br>long width; <br> <br>    hr = m_pGraph-&gt;QueryInterface(IID_IBasicVideo, (void **)&amp;pIF); <br> <br>    if( FAILED(hr) ) { <br>AfxMessageBox(IDS_CANT_GET_VIDEO_INTERFACE); <br>return 0; <br>} <br> <br>pIF-&gt;get_DestinationWidth(&amp;width); <br>pIF-&gt;Release(); <br> <br>return width; <br> <br>} <br> <br>ULONG CIPlayDoc::VideoHeight() <br>{ <br>HRESULT hr; <br>IBasicVideo *pIF; <br>long height; <br> <br>    hr = m_pGraph-&gt;QueryInterface(IID_IBasicVideo, (void **)&amp;pIF); <br> <br>    if( FAILED(hr) ) { <br>AfxMessageBox(IDS_CANT_GET_VIDEO_INTERFACE); <br>return 0; <br>} <br> <br>pIF-&gt;get_DestinationHeight(&amp;height); <br>pIF-&gt;Release(); <br> <br>return height; <br> <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CIPlayDoc protected funtions <br> <br>BOOL CIPlayDoc::CreateFilterGraph(void) { <br>    HRESULT hr;// return code <br> <br> <br>    ASSERT(m_pGraph == NULL); <br> <br>// Create this document's filter graph object <br>    hr = CoCreateInstance(CLSID_FilterGraph,  <br>                          NULL, <br>                          CLSCTX_INPROC_SERVER, <br>                          IID_IFilterGraph, <br>                          (void **) &amp;m_pGraph); <br> <br> <br>    if (FAILED(hr)){ <br>    m_pGraph = NULL; <br>        return FALSE; <br>    } <br> <br>    // get media event handle  <br>    IMediaEvent *pME; <br>    hr = m_pGraph-&gt;QueryInterface(IID_IMediaEvent, (void **) &amp;pME); <br>    if (FAILED(hr)) { <br>        DeleteContents(); <br>        return FALSE; <br>    } <br> <br>    hr = pME-&gt;GetEventHandle((OAEVENT*) &amp;m_hGraphEvent); <br> <br>    pME-&gt;Release(); <br> <br>    if (FAILED(hr)) { <br>        DeleteContents(); <br>        return FALSE; <br>    } <br>    return TRUE; <br>} <br> <br>void CIPlayDoc::DeleteContents()  <br>{ <br>// Release all interfaces to graph <br>// and filters. <br> <br>if (m_pIndeo != NULL) { <br> ((IIndeoDecode *)m_pIndeo)-&gt;Release(); <br>m_pIndeo = NULL; <br>} <br> <br>    if (m_pGraph != NULL) { <br>        m_pGraph-&gt;Release(); <br>        m_pGraph = NULL; <br>} <br> <br>m_hGraphEvent = NULL; <br> <br>    m_State = Uninitialized; <br>} <br> <br>void CIPlayDoc::SetWindow(BSTR wPath) <br>{ <br>HRESULT hr; <br>IVideoWindow *pVidWin; <br>RECT rDeskTop; <br>int x, y; <br> <br>    hr = m_pGraph-&gt;QueryInterface(IID_IVideoWindow, (void **)&amp;pVidWin); <br> <br>    if( FAILED(hr) ) { <br>AfxMessageBox(IDS_CANT_GET_WINDOW_INTERFACE); <br>return; <br>} <br> <br>// Set the caption of the video window <br>pVidWin-&gt;put_Caption(wPath); <br> <br>// Save the original size for zoom x 2 <br>pVidWin-&gt;get_Width(&amp;m_lWinWidth); <br>pVidWin-&gt;get_Height(&amp;m_lWinHeight); <br> <br>// Center the window on the screen <br>   GetWindowRect(GetDesktopWindow(), &amp;rDeskTop); <br> <br>    if (  m_lWinWidth &lt; (rDeskTop.right - rDeskTop.left) )  <br>   x = ((rDeskTop.right - rDeskTop.left) - m_lWinWidth) / 2; <br>else <br>x = rDeskTop.left; <br> <br>if ( m_lWinHeight &lt; (rDeskTop.bottom - rDeskTop.top) )  <br>y = ((rDeskTop.bottom - rDeskTop.top) - m_lWinHeight) / 2; <br>else <br>y = rDeskTop.top; <br> <br>pVidWin-&gt;SetWindowPosition(x, y, m_lWinWidth, m_lWinHeight); <br> <br>pVidWin-&gt;Release(); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
