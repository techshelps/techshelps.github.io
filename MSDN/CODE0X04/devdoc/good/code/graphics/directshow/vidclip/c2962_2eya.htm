<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DOCUMENT.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2962"></a>DOCUMENT.CPP</h2>
<pre><code>// Document.cpp: implementation of the CDocument class. <br>// <br>////////////////////////////////////////////////////////////////////// <br> <br> <br>#define _WIN32_WINNT 0x0400 <br>#define _ATL_APARTMENT_THREADED <br> <br>#include "vcproj.h" <br>extern TCHAR g_szStart[]; <br>extern TCHAR g_szEnd[]; <br>extern TCHAR g_szAll[]; <br>extern char szAppName[]; <br>LPTSTR   GetStringRes (int id); <br> <br>////////////////////////////////////////////////////////////////////// <br>// Construction/Destruction <br>////////////////////////////////////////////////////////////////////// <br> <br> <br>CDocument::~CDocument() <br>{ <br> <br>} <br> <br> <br>BOOL CDocument::Initialize(HWND hwndDoc) <br>{ <br>    m_hWnd = hwndDoc; <br>    return m_ClipList.Initialize(hwndDoc); <br>} <br> <br>void inline WriteLong(IStream *pStream, long val) <br>{ <br>    pStream-&gt;Write(&amp;val, sizeof(val), NULL); <br>} <br> <br>long inline ReadLong(IStream *pStream) <br>{ <br>    long val; <br>    pStream-&gt;Read(&amp;val, sizeof(val), NULL); <br>    return val; <br>} <br> <br>void CDocument::ResetContents(void) <br>{ <br>    m_TargetFileName.Empty(); <br>    m_VideoCodecDisplayName.Empty(); <br>    m_AudioCodecDisplayName.Empty(); <br>    m_ClipList.ResetContents(); <br>} <br> <br>BOOL CDocument::ReadFromStream(IStream * pStream) <br>{ <br>    ResetContents(); <br>       <br>    m_TargetFileName.ReadFromStream(pStream); <br>    m_VideoCodecDisplayName.ReadFromStream(pStream); <br>    m_AudioCodecDisplayName.ReadFromStream(pStream); <br>    m_Height = ReadLong(pStream); <br>    m_Width = ReadLong(pStream); <br>    m_PixelDepth = ReadLong(pStream); <br> <br>    m_ClipList.ReadFromStream(pStream); <br>    return TRUE; <br>} <br> <br>BOOL CDocument::WriteToStream(IStream * pStream) <br>{ <br>    m_TargetFileName.WriteToStream(pStream); <br>    m_VideoCodecDisplayName.WriteToStream(pStream); <br>    m_AudioCodecDisplayName.WriteToStream(pStream); <br>    WriteLong(pStream, m_Height); <br>    WriteLong(pStream, m_Width); <br>    WriteLong(pStream, m_PixelDepth); <br>    m_ClipList.WriteToStream(pStream); <br>    return TRUE; <br>} <br> <br> <br>BOOL CDocument::NewClip() <br>{ <br>    CClip *pClip; <br>    int i = m_ClipList.CurSelClipIndex(); <br>    if (i &lt; 0) {    // Nothing selected = -1;  Add to end. <br>        i = m_ClipList.NumClips(); <br>    } <br>    m_ClipList.AddClip(i, &amp;pClip); <br>    if (pClip-&gt;DoSettingsDialog(m_hWnd)) { <br>        m_ClipList.UpdateClipView(i); <br>        MarkDirty(); <br>    } else { <br>        m_ClipList.DeleteClip(i); <br>    } <br>    return TRUE; <br>} <br> <br>BOOL CDocument::DeleteClip() <br>{ <br>    int i = m_ClipList.CurSelClipIndex(); <br>    if (i &gt;= 0) { <br>        m_ClipList.DeleteClip(i); <br>        MarkDirty(); <br>    } <br>    return TRUE; <br>} <br> <br>BOOL CDocument::EditClip() <br>{ <br>    int i = m_ClipList.CurSelClipIndex(); <br>    if (i &gt;= 0) { <br>        CClip *pClip = m_ClipList.GetClip(i); <br>        if (pClip-&gt;DoSettingsDialog(m_hWnd)) { <br>            m_ClipList.UpdateClipView(i); <br>            MarkDirty(); <br>        } <br>    } <br>    return TRUE; <br>} <br> <br>extern HINSTANCE hInst; <br> <br> <br> <br>void InitOpenFileName(HWND hWnd, OPENFILENAME&amp; OpenFileName, TCHAR * pszFileName) <br>{ <br>    OpenFileName.lStructSize       = sizeof(OPENFILENAME); <br>    OpenFileName.hwndOwner         = hWnd; <br>    OpenFileName.hInstance         = hInst; <br>    OpenFileName.lpstrFilter       = NULL; <br>    OpenFileName.lpstrCustomFilter = NULL; <br>    OpenFileName.nMaxCustFilter    = 0; <br>    OpenFileName.nFilterIndex      = 0; <br>    OpenFileName.lpstrFile         = pszFileName; <br>    OpenFileName.nMaxFile          = MAX_PATH; <br>    OpenFileName.lpstrFileTitle    = NULL; <br>    OpenFileName.nMaxFileTitle     = 0; <br>    OpenFileName.lpstrInitialDir   = NULL; <br>    OpenFileName.lpstrTitle        = NULL; <br>    OpenFileName.nFileOffset       = 0; <br>    OpenFileName.nFileExtension    = 0; <br>    OpenFileName.lpstrDefExt       = NULL; <br>    OpenFileName.lCustData         = 0; <br>    OpenFileName.lpfnHook    = NULL; <br>    OpenFileName.lpTemplateName    = NULL; <br>    OpenFileName.Flags             = OFN_SHOWHELP; <br>} <br> <br> <br>BOOL CDocument::OpenFile() <br>{ <br>    USES_CONVERSION; <br>    BOOL bWorked = FALSE; <br>    TCHAR szFile[MAX_PATH]; <br> <br>    szFile[0] = 0; <br>    OPENFILENAME OpenFileName; <br>    InitOpenFileName(m_hWnd, OpenFileName, szFile); <br> <br>    if (GetOpenFileName(&amp;OpenFileName)) { <br>        CComBSTR szTryThisName(T2BSTR(szFile)); <br>        CComPtr&lt;IStorage&gt; pStorage; <br>        HRESULT hr = StgOpenStorage(szTryThisName, NULL,   <br>                                    STGM_READ | STGM_SHARE_EXCLUSIVE, NULL, 0, <br>                                    &amp;pStorage); <br>        if (SUCCEEDED(hr)) { <br>            CComPtr &lt;IStream&gt; pStream; <br>            hr = pStorage-&gt;OpenStream(L"VidClip", NULL, STGM_READ | STGM_SHARE_EXCLUSIVE, 0, &amp;pStream); <br>            if (SUCCEEDED(hr)) { <br>                bWorked = ReadFromStream(pStream); <br>                if (bWorked) { <br>                    m_DocumentFileName = szTryThisName; <br>                } <br>            } <br>        } <br>    } <br>    return bWorked; <br>} <br> <br> <br>BOOL CDocument::SaveAsFile(bool bShowDialog) <br>{ <br>    USES_CONVERSION; <br>    BOOL bWorked = FALSE; <br>    TCHAR szFile[MAX_PATH]; <br> <br>    if (!m_DocumentFileName || bShowDialog) { <br>        OPENFILENAME OpenFileName; <br>        InitOpenFileName(m_hWnd, OpenFileName, szFile); <br>        if (m_DocumentFileName) { <br>            lstrcpy(szFile, OLE2T(m_DocumentFileName));     <br>        } else { <br>            szFile[0] = 0; <br>        } <br>        if (!GetSaveFileName(&amp;OpenFileName)) { <br>            return FALSE; <br>        } <br>        m_DocumentFileName = T2OLE(szFile); <br>    } <br> <br>    CComPtr&lt;IStorage&gt; pStorage; <br>    HRESULT hr = StgCreateDocfile(m_DocumentFileName,  <br>                 STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE, 0, <br>                 &amp;pStorage); <br>    if (SUCCEEDED(hr)) { <br>        CComPtr&lt;IStream&gt; pStream; <br>        hr = pStorage-&gt;CreateStream(L"VidClip", STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE, 0, 0, &amp;pStream); <br>        if (SUCCEEDED(hr)) { <br>            bWorked = WriteToStream(pStream); <br>        } <br>    } <br>    return bWorked; <br>} <br> <br> <br> <br>//////////////////// CLIPS <br> <br> <br>void inline WriteStreamTime(IStream *pStream, STREAM_TIME val) <br>{ <br>    pStream-&gt;Write(&amp;val, sizeof(val), NULL); <br>} <br> <br>STREAM_TIME inline ReadStreamTime(IStream *pStream) <br>{ <br>    STREAM_TIME val; <br>    pStream-&gt;Read(&amp;val, sizeof(val), NULL); <br>    return val; <br>} <br> <br> <br> <br>BOOL CClip::WriteToStream(IStream *pStream) <br>{ <br>    m_FileName.WriteToStream(pStream); <br>    WriteStreamTime(pStream, m_stStart); <br>    WriteStreamTime(pStream, m_stEnd); <br>    return TRUE; <br>} <br> <br>BOOL CClip::ReadFromStream(IStream *pStream) <br>{ <br>    m_FileName.Empty(); <br>    m_FileName.ReadFromStream(pStream); <br>    m_stStart = ReadStreamTime(pStream); <br>    m_stEnd = ReadStreamTime(pStream); <br>    return TRUE; <br>} <br> <br>//////////////////// CLIP LIST <br> <br>void CClipList::InsertCol(int iColNum, TCHAR * pszColHeader, int Width) <br>{ <br>    LV_COLUMN col = {LVCF_FMT | LVCF_WIDTH | LVCF_TEXT, LVCFMT_LEFT, Width, pszColHeader, 0, 0}; <br>    ListView_InsertColumn(m_hLV, iColNum, &amp;col); <br>} <br> <br>BOOL CClipList::Initialize(HWND hwndParent) <br>{ <br>    m_hLV = CreateWindowEx(0, WC_LISTVIEW, "ClipList", WS_VISIBLE | WS_CHILDWINDOW | WS_CLIPSIBLINGS | LVS_REPORT | LVS_SINGLESEL, <br>                           0, 0, 0, 0, hwndParent, (HMENU)1, hInst, NULL); <br> <br> <br>    InsertCol(0, "File Name", 400); <br>    InsertCol(1, "Start", 100); <br>    InsertCol(2, "Stop", 100); <br>    return TRUE; <br>} <br> <br> <br>int CClipList::NumClips(void) <br>{ <br>    return ListView_GetItemCount(m_hLV); <br>} <br> <br>int CClipList::CurSelClipIndex(void) <br>{ <br>    return ListView_GetNextItem(m_hLV, -1, LVNI_ALL | LVNI_SELECTED); <br>} <br> <br>CClip * CClipList::GetClip(int i) <br>{ <br>    LV_ITEM lvi = {LVIF_PARAM, i, 0}; <br>    ListView_GetItem(m_hLV, &amp;lvi); <br>    return (CClip *)(lvi.lParam); <br>} <br> <br>BOOL CClipList::AddClip(int i, CClip **ppClip) <br>{ <br>    CClip *pNewClip = new CClip(); <br>    if (!pNewClip) { <br>        return FALSE; <br>    } <br>    LV_ITEM lvi = {LVIF_PARAM | LVIF_TEXT, i, 0}; <br>    lvi.pszText = "&lt;New Clip&gt;"; <br>    lvi.lParam = (LPARAM)pNewClip; <br>    ListView_InsertItem(m_hLV, &amp;lvi); <br>    lvi.pszText = "----"; <br>    lvi.mask = LVIF_TEXT; <br>    lvi.iSubItem = 1; <br>    ListView_SetItem(m_hLV, &amp;lvi); <br>    lvi.iSubItem = 2; <br>    ListView_SetItem(m_hLV, &amp;lvi); <br>    *ppClip = pNewClip; <br> <br>    return TRUE; <br>} <br> <br>void CClipList::DeleteClip(int i) <br>{ <br>    delete GetClip(i); <br>    ListView_DeleteItem(m_hLV, i); <br>} <br> <br> <br>void CClipList::UpdateClipView(int i) <br>{ <br>    USES_CONVERSION; <br>    CClip *pClip = GetClip(i); <br> <br>    LV_ITEM lvi = {LVIF_TEXT, i, 0}; <br>    lvi.pszText = OLE2T(pClip-&gt;m_FileName); <br>    ListView_SetItem(m_hLV, &amp;lvi); <br> <br> <br>    if (pClip-&gt;m_stStart == 0 &amp;&amp; pClip-&gt;m_stEnd == 0) { <br>        lvi.iSubItem = 1; <br>        lvi.pszText = g_szAll; <br>        ListView_SetItem(m_hLV, &amp;lvi); <br>        lvi.iSubItem = 2; <br>        lvi.pszText = _T(""); <br>        ListView_SetItem(m_hLV, &amp;lvi); <br>    } else { <br>        TCHAR s[20]; <br>        long Second = (long)(pClip-&gt;m_stStart / (STREAM_TIME)10000000); <br>        wsprintf(s, _T("%li"), Second); <br>        lvi.iSubItem = 1; <br>        lvi.pszText = pClip-&gt;m_stStart == 0 ? g_szStart : s; <br>        ListView_SetItem(m_hLV, &amp;lvi); <br> <br>        Second = (long)(pClip-&gt;m_stEnd / (STREAM_TIME)10000000); <br>        wsprintf(s, _T("%li"), Second); <br>        lvi.iSubItem = 2; <br>        lvi.pszText = pClip-&gt;m_stEnd == 0 ? g_szEnd : s; <br>        ListView_SetItem(m_hLV, &amp;lvi); <br>    } <br>} <br> <br> <br> <br>BOOL CClipList::WriteToStream(IStream *pStream) <br>{ <br>    int lNumClips = NumClips(); <br>    WriteLong(pStream, lNumClips); <br>    for (int i = 0; i &lt; lNumClips; i++) { <br>        GetClip(i)-&gt;WriteToStream(pStream); <br>    } <br>    return TRUE; <br> <br>} <br> <br>void CClipList::ResetContents() <br>{ <br>    int lNumClips = NumClips(); <br>    for (int i = 0; i &lt; lNumClips; i++) { <br>        delete GetClip(i); <br>    } <br>    ListView_DeleteAllItems(m_hLV); <br>} <br> <br>BOOL CClipList::ReadFromStream(IStream *pStream) <br>{ <br>    ResetContents(); <br> <br>    int lNumClips = ReadLong(pStream); <br>    for (int i = 0; i &lt; lNumClips; i++) { <br>        CClip *pClip; <br>        AddClip(i, &amp;pClip); <br>        pClip-&gt;ReadFromStream(pStream); <br>        UpdateClipView(i); <br>    } <br>    return TRUE; <br>} <br> <br>void CClipList::SetSize(int Height, int Width) <br>{ <br>    MoveWindow(m_hLV, 0, 0, Height, Width, TRUE); <br>} <br> <br> <br>LRESULT CALLBACK ClipSettingsDlg(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam); <br> <br> <br>BOOL CClip::DoSettingsDialog(HWND hwndParent) <br>{ <br>    return DialogBoxParam(hInst, MAKEINTRESOURCE(IDD_CLIP), hwndParent, (DLGPROC)ClipSettingsDlg, (LPARAM)this); <br>} <br> <br> <br>void inline SetEditSeconds(HWND hDlg, int ID, STREAM_TIME st) <br>{ <br>    long Second = (long)(st / (STREAM_TIME)10000000); <br>    TCHAR s[20]; <br>    wsprintf(s, _T("%li"), Second); <br>    SendDlgItemMessage(hDlg, ID, WM_SETTEXT, 0, (LPARAM)s); <br>} <br> <br> <br>void CClip::InitDialog(HWND hDlg) <br>{ <br>    USES_CONVERSION;  <br>    CenterWindow (hDlg, GetWindow (hDlg, GW_OWNER)); <br>    SendDlgItemMessage(hDlg, IDC_EDIT_FILENAME, WM_SETTEXT, 0, (LPARAM)W2T(m_FileName)); <br>    SetEditSeconds(hDlg, IDC_EDIT_START, m_stStart); <br>    SetEditSeconds(hDlg, IDC_EDIT_END, m_stEnd); <br>} <br> <br> <br>bool CClip::CleanUpDialog(HWND hDlg, bool bSaveSettings) <br>{ <br>    bool bWorked = true; <br>    if (bSaveSettings) { <br>        TCHAR szEditContents[MAX_PATH]; <br>        TCHAR *pUnused; <br>        STREAM_TIME stStart, stEnd; <br> <br>        SendDlgItemMessage(hDlg, IDC_EDIT_START, WM_GETTEXT, sizeof(szEditContents) / sizeof(TCHAR), (LPARAM)szEditContents); <br>        stStart = (STREAM_TIME)strtol(szEditContents, &amp;pUnused, 10) * (STREAM_TIME)10000000; <br> <br>        SendDlgItemMessage(hDlg, IDC_EDIT_END, WM_GETTEXT, sizeof(szEditContents) / sizeof(TCHAR), (LPARAM)szEditContents); <br>        stEnd = (STREAM_TIME)strtol(szEditContents, &amp;pUnused, 10) * (STREAM_TIME)10000000; <br> <br>        SendDlgItemMessage(hDlg, IDC_EDIT_FILENAME, WM_GETTEXT, sizeof(szEditContents) / sizeof(TCHAR), (LPARAM)szEditContents); <br> <br>        if (stStart &lt;= stEnd || stEnd == 0) { <br>            HANDLE hTest = CreateFile(szEditContents, GENERIC_READ, FILE_SHARE_READ, NULL,  <br>                                      OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); <br>            if (hTest == INVALID_HANDLE_VALUE) { <br>                bWorked = false; <br>                MessageBox(hDlg, GetStringRes(IDS_FILE_DOES_NOT_EXIST), szAppName, MB_OK); <br>            } else { <br>                CloseHandle(hTest); <br>                m_FileName = szEditContents; <br>                m_stStart = stStart; <br>                m_stEnd = stEnd; <br>            } <br>        } else { <br>            bWorked = false; <br>            MessageBox(hDlg, GetStringRes(IDS_INVALID_TIMES), szAppName, MB_OK); <br>        }  <br>    } <br>    return bWorked; <br>} <br> <br>// <br>//  FUNCTION: ClipSettings(HWND, unsigned, WORD, LONG) <br>// <br>// <br>//  MESSAGES: <br>// <br>// WM_INITDIALOG - initialize dialog box <br>// WM_COMMAND    - Input received <br>// <br>// <br> <br>LRESULT CALLBACK ClipSettingsDlg(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>    CClip *pClip = (CClip *)GetWindowLong(hDlg, DWL_USER); <br>    switch (message) { <br>        case WM_INITDIALOG: <br>            pClip = (CClip *)lParam; <br>            SetWindowLong(hDlg, DWL_USER, lParam); <br>            pClip-&gt;InitDialog(hDlg); <br>            return TRUE; <br> <br>     <br> <br>        case WM_COMMAND: <br>            if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) { <br>                if (pClip-&gt;CleanUpDialog(hDlg, LOWORD(wParam) == IDOK)) { <br>                    EndDialog(hDlg, LOWORD(wParam) == IDOK); <br>                } <br>                return TRUE; <br>            } <br>            if (LOWORD(wParam) == IDC_BUTTON_BROWSE) { <br>                TCHAR szFile[MAX_PATH]; <br>                szFile[0] = 0; <br>                OPENFILENAME OpenFileName; <br>                InitOpenFileName(hDlg, OpenFileName, szFile); <br>                if (GetOpenFileName(&amp;OpenFileName)) { <br>                    SendDlgItemMessage(hDlg, IDC_EDIT_FILENAME, WM_SETTEXT, 0, (LPARAM)szFile); <br>                } <br>                return TRUE; <br>            } <br>            break; <br>   } <br> <br>   return FALSE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
