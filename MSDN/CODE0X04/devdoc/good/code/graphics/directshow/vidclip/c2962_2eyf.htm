<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>VIDCLIP.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2967"></a>VIDCLIP.CPP</h2>
<pre><code>//THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>//ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>//THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>// PARTICULAR PURPOSE. <br>// <br>// Copyright  1994-1996  Microsoft Corporation.  All Rights Reserved. <br>// <br>// PROGRAM: VidClip.c - Stolen from Generic.C <br>// <br>// PURPOSE: Illustrates the 'minimum' functionality of a well-behaved Win32 application.. <br>// <br>// PLATFORMS:  Windows 95, Windows NT 4.0 and up <br>// <br>// FUNCTIONS: <br>//    WinMain() - calls initialization function, processes message loop <br>//    InitApplication() - Initializes window data nd registers window <br>//    InitInstance() -saves instance handle and creates main window <br>//    WindProc() Processes messages <br>//    About() - Process menssages for "About" dialog box <br>//    CenterWindow() -  Centers one window over another <br>// <br>// SPECIAL INSTRUCTIONS: N/A <br>// <br>#include &lt;vcproj.h&gt; <br> <br>#define APPNAME "VidClip" <br> <br>#include &lt;strmif.h&gt; <br>#include &lt;uuids.h&gt; <br>#include &lt;amstream.h&gt; <br>#include &lt;initguid.h&gt; <br>#include &lt;ddrawex.h&gt; <br> <br>#define _WIN32_WINNT 0x0400 <br>#define _ATL_APARTMENT_THREADED <br> <br> <br>#include "atlbase.h" <br>CComModule _Module; <br>#include "atlcom.h" <br> <br>#include &lt;atlimpl.cpp&gt; <br> <br> <br> <br>// Global Variables: <br> <br>HINSTANCE hInst;      // current instance <br>char szAppName[100];  // Name of the app <br>char szTitle[100];    // The title bar text <br>IDirectDraw *g_pDD = NULL; <br> <br>TCHAR g_szStart[100]; <br>TCHAR g_szEnd[100]; <br>TCHAR g_szAll[100]; <br> <br>const DDPIXELFORMAT g_aPixelFormats[] = <br>{ <br>///    {sizeof(DDPIXELFORMAT), DDPF_RGB | DDPF_PALETTEINDEXED8, 0, 8, 0, 0, 0, 0}, <br>    {sizeof(DDPIXELFORMAT), DDPF_RGB, 0, 16, 0x00007C00, 0x000003E0, 0x0000001F, 0}, <br>    {sizeof(DDPIXELFORMAT), DDPF_RGB, 0, 24, 0x00FF0000, 0x0000FF00, 0x000000FF, 0}, <br>    {sizeof(DDPIXELFORMAT), DDPF_RGB, 0, 32, 0x00FF0000, 0x0000FF00, 0x000000FF, 0} <br>}; <br>CDocument g_Document; <br> <br>// Foward declarations of functions included in this code module: <br> <br>BOOL InitApplication(HINSTANCE); <br>BOOL InitInstance(HINSTANCE, int); <br>LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM); <br>LRESULT CALLBACK About(HWND, UINT, WPARAM, LPARAM); <br>LPTSTR   GetStringRes (int id); <br>HRESULT CreateWriterStream(LPOLESTR szOutputFileName, <br>                           LPOLESTR szVideoCodec, <br>                           DDSURFACEDESC&amp; ddsdVideoFormat, <br>                           LPOLESTR szAudioCodec, <br>                           WAVEFORMATEX&amp; wfexAudioFormat, <br>                           IMultiMediaStream **ppMMStream); <br>void DoMakeMovie(HINSTANCE, HWND, CDocument *); <br> <br> <br>// <br>//  FUNCTION: WinMain(HANDLE, HANDLE, LPSTR, int) <br>// <br>//  PURPOSE: Entry point for the application. <br>// <br>//  COMMENTS: <br>// <br>// This function initializes the application and processes the <br>// message loop. <br>// <br>int APIENTRY WinMain(HINSTANCE hInstance, <br>                     HINSTANCE hPrevInstance, <br>                     LPSTR     lpCmdLine, <br>                     int       nCmdShow) <br>{ <br>   MSG msg; <br>   HACCEL hAccelTable; <br> <br>   CoInitialize(NULL); <br>   // Initialize global strings <br>   lstrcpy (szAppName, APPNAME); <br>   LoadString (hInstance, IDS_APP_TITLE, szTitle, 100); <br>   LoadString (hInstance, IDS_START, g_szStart, sizeof(g_szStart)); <br>   LoadString (hInstance, IDS_END,   g_szEnd, sizeof(g_szEnd)); <br>   LoadString (hInstance, IDS_ALL,   g_szAll, sizeof(g_szAll)); <br> <br>   if (!hPrevInstance) { <br>      // Perform instance initialization: <br>      if (!InitApplication(hInstance)) { <br>         return (FALSE); <br>      } <br>   } <br> <br>   // Perform application initialization: <br>   if (!InitInstance(hInstance, nCmdShow)) { <br>      return (FALSE); <br>   } <br> <br>   hAccelTable = LoadAccelerators (hInstance, szAppName); <br> <br>   // Main message loop: <br>   while (GetMessage(&amp;msg, NULL, 0, 0)) { <br>      if (!TranslateAccelerator (msg.hwnd, hAccelTable, &amp;msg)) { <br>         TranslateMessage(&amp;msg); <br>         DispatchMessage(&amp;msg); <br>      } <br>   } <br> <br>   CoUninitialize(); <br>   return (msg.wParam); <br> <br>   lpCmdLine; // This will prevent 'unused formal parameter' warnings <br>} <br> <br> <br>// <br>//  FUNCTION: InitApplication(HANDLE) <br>// <br>//  PURPOSE: Initializes window data and registers window class <br>// <br>//  COMMENTS: <br>// <br>//       In this function, we initialize a window class by filling out a data <br>//       structure of type WNDCLASS. <br>// <br>BOOL InitApplication(HINSTANCE hInstance) <br>{ <br>    WNDCLASSEX  wcex; <br>    HWND        hwnd; <br> <br>    // Win32 will always set hPrevInstance to NULL, so lets check <br>    // things a little closer. This is because we only want a single <br>    // version of this app to run at a time <br>    hwnd = FindWindow (szAppName, szTitle); <br>    if (hwnd) { <br>        // We found another version of ourself. Lets defer to it: <br>        if (IsIconic(hwnd)) { <br>            ShowWindow(hwnd, SW_RESTORE); <br>        } <br>        SetForegroundWindow (hwnd); <br> <br>        // If this app actually had any functionality, we would <br>        // also want to communicate any action that our 'twin' <br>        // should now perform based on how the user tried to <br>        // execute us. <br>        return FALSE; <br>    } else { <br>        // Fill in window class structure with parameters that describe <br>        // the main window. <br> <br>         // Added elements for Windows 95: <br>        wcex.cbSize = sizeof(WNDCLASSEX); <br> <br>        wcex.style          = CS_HREDRAW | CS_VREDRAW; <br>        wcex.lpfnWndProc    = (WNDPROC)WndProc; <br>        wcex.cbClsExtra     = 0; <br>        wcex.cbWndExtra     = 0; <br>        wcex.hInstance      = hInstance; <br>        wcex.hIcon          = LoadIcon (hInstance, szAppName); <br>        wcex.hIconSm        = LoadIcon(hInstance, "SMALL"); <br>        wcex.hCursor        = LoadCursor(NULL, IDC_ARROW); <br>        wcex.hbrBackground  = (HBRUSH)(COLOR_WINDOW+1); <br> <br>        wcex.lpszMenuName  = szAppName; <br>        wcex.lpszClassName = szAppName; <br> <br>        // Register the window class and return success/failure code. <br>        return RegisterClassEx(&amp;wcex); <br>    } <br>} <br> <br> <br>BOOL AddListViewItem(HWND hLV, TCHAR * pszItem, void * pThingie) <br>{ <br>    LV_ITEM lvi; <br>    lvi.mask= LVIF_TEXT | LVIF_PARAM; <br>    lvi.iItem= 0x7FFF; <br>    lvi.iSubItem= 0; <br>    lvi.pszText= pszItem; <br>    lvi.lParam= (LPARAM)pThingie; <br>    lvi.cchTextMax  = 0; <br>    ListView_InsertItem(hLV, &amp;lvi); <br>    return TRUE; <br>} <br> <br> <br>// <br>//   FUNCTION: InitInstance(HANDLE, int) <br>// <br>//   PURPOSE: Saves instance handle and creates main window <br>// <br>//   COMMENTS: <br>// <br>//        In this function, we save the instance handle in a global variable and <br>//        create and display the main program window. <br>// <br>BOOL InitInstance(HINSTANCE hInstance, int nCmdShow) <br>{ <br>   HWND hWnd; <br> <br>   hInst = hInstance; // Store instance handle in our global variable <br> <br>   hWnd = CreateWindow(szAppName, szTitle, WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN, <br>      CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, <br>      NULL, NULL, hInstance, NULL); <br> <br>   if (!hWnd) { <br>      return (FALSE); <br>   } <br> <br>   InitCommonControls(); <br>   /* <br>   HWND hListView = CreateWindowEx(0, WC_LISTVIEW, "Fred", WS_CHILDWINDOW | WS_CLIPSIBLINGS | LVS_REPORT, <br>                        0, 0, 0, 0, hWnd, (HMENU)1, hInstance, NULL); <br> <br>   InitListView(hListView); <br>   AddListViewItem(hListView, "This is a test", NULL); <br>   AddListViewItem(hListView, "And another test", NULL); <br>   AddListViewItem(hListView, "And yet another test", NULL); <br>   */ <br>   g_Document.Initialize(hWnd); <br> <br>   ShowWindow(hWnd, nCmdShow); <br>   UpdateWindow(hWnd); <br> <br>   MessageBox (GetFocus(), GetStringRes(IDS_LIMITEDFUNCTION), szAppName, MB_OK); <br> <br>   //ShowWindow(hListView, nCmdShow); <br>   //UpdateWindow(hListView); <br> <br>   // BUGBUG -- There is still a bug in ddstream with 8bpp palettes &amp; ddreaw <br>   // Make sure to make this work with a NULL g_pDD!!! <br>   CComPtr &lt;IDirectDrawFactory&gt; pFactory; <br>   HRESULT hr = CoCreateInstance(CLSID_DirectDrawFactory, NULL, CLSCTX_INPROC_SERVER, <br>                                IID_IDirectDrawFactory, (void **)&amp;pFactory); <br>   if (SUCCEEDED(hr)) { <br>        hr = pFactory-&gt;CreateDirectDraw(NULL, NULL, DDSCL_NORMAL,0, NULL, &amp;g_pDD); <br>   } <br>   return (TRUE); <br>} <br> <br> <br> <br>void UpdateMenus(HWND hWnd, CDocument * pDoc) <br>{ <br>    BOOL bEnableSave = FALSE; <br>    BOOL bEnableEdit = FALSE; <br>    if (pDoc-&gt;m_ClipList.NumClips() &gt; 0) { <br>        bEnableSave = (pDoc-&gt;m_TargetFileName != NULL); <br>        bEnableEdit = (pDoc-&gt;m_ClipList.CurSelClipIndex() &gt;= 0); <br>    } <br>    HMENU hMenu = GetMenu(hWnd); <br>    UINT uEditSetting = bEnableEdit ? MF_ENABLED : MF_GRAYED; <br>    UINT uSaveSetting = bEnableSave ? MF_ENABLED : MF_GRAYED; <br>    EnableMenuItem(hMenu, IDM_VIDEO_EDITCLIP, uEditSetting); <br>    EnableMenuItem(hMenu, IDM_VIDEO_DELETECLIP, uEditSetting); <br>    EnableMenuItem(hMenu, IDM_VIDEO_MAKEMOVIE, uSaveSetting); <br>    EnableMenuItem(hMenu, IDM_SAVE, uSaveSetting); <br>    EnableMenuItem(hMenu, IDM_SAVEAS, uSaveSetting); <br>} <br> <br> <br> <br>// <br>//  FUNCTION: WndProc(HWND, unsigned, WORD, LONG) <br>// <br>//  PURPOSE:  Processes messages for the main window. <br>// <br>//  MESSAGES: <br>// <br>// WM_COMMAND - process the application menu <br>// WM_PAINT - Paint the main window <br>// WM_DESTROY - post a quit message and return <br>//    WM_DISPLAYCHANGE - message sent to Plug &amp; Play systems when the display changes <br>//    WM_RBUTTONDOWN - Right mouse click -- put up context menu here if appropriate <br>//    WM_NCRBUTTONUP - User has clicked the right button on the application's system menu <br>// <br>// <br>LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>   int wmId, wmEvent; <br>   PAINTSTRUCT ps; <br>   HDC hdc; <br>   POINT pnt; <br>   HMENU hMenu; <br>   BOOL bGotHelp; <br>   CDocument *pDoc = &amp;g_Document; <br> <br>   switch (message) { <br> <br>      case WM_COMMAND: <br>         wmId    = LOWORD(wParam); // Remember, these are... <br>         wmEvent = HIWORD(wParam); // ...different for Win32! <br> <br>         //Parse the menu selections: <br>         switch (wmId) { <br> <br>            case IDM_ABOUT: <br>               DialogBox(hInst, "AboutBox", hWnd, (DLGPROC)About); <br>               break; <br> <br>            case IDM_SETTINGS: <br>                DoSettingsDialog(hInst, hWnd, pDoc); <br>                UpdateMenus(hWnd, pDoc); <br>                break; <br> <br>            case IDM_EXIT: <br>               DestroyWindow (hWnd); <br>               break; <br> <br>            case IDM_HELPTOPICS: // Only called in Windows 95 <br>               bGotHelp = WinHelp (hWnd, APPNAME".HLP", HELP_FINDER,(DWORD)0); <br>               if (!bGotHelp) <br>               { <br>                  MessageBox (GetFocus(), GetStringRes(IDS_NO_HELP), <br>                              szAppName, MB_OK|MB_ICONHAND); <br>               } <br>               break; <br> <br>            case IDM_HELPCONTENTS: // Not called in Windows 95 <br>               bGotHelp = WinHelp (hWnd, APPNAME".HLP", HELP_CONTENTS,(DWORD)0); <br>               if (!bGotHelp) <br>               { <br>                  MessageBox (GetFocus(), GetStringRes(IDS_NO_HELP), <br>                              szAppName, MB_OK|MB_ICONHAND); <br>               } <br>               break; <br> <br>            case IDM_HELPSEARCH: // Not called in Windows 95 <br>               if (!WinHelp(hWnd, APPNAME".HLP", HELP_PARTIALKEY, <br>                           (DWORD)(LPSTR)"")) <br>               { <br>                  MessageBox (GetFocus(), GetStringRes(IDS_NO_HELP), <br>                              szAppName, MB_OK|MB_ICONHAND); <br>               } <br>               break; <br> <br>            case IDM_HELPHELP: // Not called in Windows 95 <br>               if(!WinHelp(hWnd, (LPSTR)NULL, HELP_HELPONHELP, 0)) <br>               { <br>                  MessageBox (GetFocus(), GetStringRes(IDS_NO_HELP), <br>                              szAppName, MB_OK|MB_ICONHAND); <br>               } <br>               break; <br> <br>            case IDM_VIDEO_ADDCLIP: <br>                pDoc-&gt;NewClip(); <br>                break; <br> <br>            case IDM_VIDEO_EDITCLIP: <br>                pDoc-&gt;EditClip(); <br>                break; <br> <br>            case IDM_VIDEO_DELETECLIP: <br>                pDoc-&gt;DeleteClip(); <br>                break; <br> <br>            case IDM_VIDEO_MAKEMOVIE: <br>                DoMakeMovie(hInst, hWnd, pDoc); <br>                break; <br> <br>            // Here are all the other possible menu options, <br>            // all of these are currently disabled: <br>            case IDM_NEW: <br>                pDoc-&gt;ResetContents(); <br>                break; <br> <br>            case IDM_OPEN: <br>                return pDoc-&gt;OpenFile(); <br> <br>            case IDM_SAVE: <br>            case IDM_SAVEAS: <br>                return pDoc-&gt;SaveAsFile(wmId == IDM_SAVEAS); <br> <br>            case IDM_UNDO: <br>            case IDM_CUT: <br>            case IDM_COPY: <br>            case IDM_PASTE: <br>            case IDM_LINK: <br>            case IDM_LINKS: <br> <br>            default: <br>               return (DefWindowProc(hWnd, message, wParam, lParam)); <br>         } <br>         break; <br> <br>      case WM_NCRBUTTONUP: // RightClick on windows non-client area... <br>         if (SendMessage(hWnd, WM_NCHITTEST, 0, lParam) == HTSYSMENU) <br>         { <br>            // The user has clicked the right button on the applications <br>            // 'System Menu'. Here is where you would alter the default <br>            // system menu to reflect your application. Notice how the <br>            // explorer deals with this. For this app, we aren't doing <br>            // anything <br>            return (DefWindowProc(hWnd, message, wParam, lParam)); <br>         } else { <br>            // Nothing we are interested in, allow default handling... <br>            return (DefWindowProc(hWnd, message, wParam, lParam)); <br>         } <br>            break; <br> <br>        case WM_RBUTTONDOWN: // RightClick in windows client area... <br>            pnt.x = LOWORD(lParam); <br>            pnt.y = HIWORD(lParam); <br>            ClientToScreen(hWnd, (LPPOINT) &amp;pnt); <br>      // This is where you would determine the appropriate 'context' <br>      // menu to bring up. Since this app has no real functionality, <br>      // we will just bring up the 'Help' menu: <br>            hMenu = GetSubMenu (GetMenu (hWnd), 2); <br>            if (hMenu) { <br>                TrackPopupMenu (hMenu, 0, pnt.x, pnt.y, 0, hWnd, NULL); <br>            } else { <br>            // Couldn't find the menu... <br>                MessageBeep(0); <br>            } <br>            break; <br> <br> <br> <br>      case WM_PAINT: <br>         hdc = BeginPaint (hWnd, &amp;ps); <br>         // Add any drawing code here... <br>         EndPaint (hWnd, &amp;ps); <br>         break; <br> <br>      case WM_DESTROY: <br>         // Tell WinHelp we don't need it any more... <br>               WinHelp (hWnd, APPNAME".HLP", HELP_QUIT,(DWORD)0); <br>         PostQuitMessage(0); <br>         break; <br> <br>      case WM_SIZE: <br>          pDoc-&gt;m_ClipList.SetSize(LOWORD(lParam), HIWORD(lParam)); <br>          break; <br> <br>      case WM_NOTIFY: { <br>          LPNMHDR pnmhdr = (LPNMHDR)lParam; <br>          if (pnmhdr-&gt;hwndFrom == pDoc-&gt;m_ClipList.m_hLV) { <br>              if (pnmhdr-&gt;code == NM_DBLCLK) { <br>                pDoc-&gt;EditClip(); <br>              } <br>              UpdateMenus(hWnd, pDoc); <br>          } <br>          } <br>          break; <br> <br>      case WM_ACTIVATE: <br>          UpdateMenus(hWnd, pDoc); <br>          // Fall through... <br> <br>      default: <br>         return (DefWindowProc(hWnd, message, wParam, lParam)); <br>   } <br>   return (0); <br>} <br> <br>// <br>//  FUNCTION: About(HWND, unsigned, WORD, LONG) <br>// <br>//  PURPOSE:  Processes messages for "About" dialog box <br>//       This version allows greater flexibility over the contents of the 'About' box, <br>//       by pulling out values from the 'Version' resource. <br>// <br>//  MESSAGES: <br>// <br>// WM_INITDIALOG - initialize dialog box <br>// WM_COMMAND    - Input received <br>// <br>// <br>LRESULT CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>   static  HFONT hfontDlg;    // Font for dialog text <br>   static   HFONT hFinePrint; // Font for 'fine print' in dialog <br>   DWORD   dwVerInfoSize;     // Size of version information block <br>   LPSTR   lpVersion;         // String pointer to 'version' text <br>   DWORD   dwVerHnd=0;        // An 'ignored' parameter, always '0' <br>   UINT    uVersionLen; <br>   WORD    wRootLen; <br>   BOOL    bRetCode; <br>   int     i; <br>   char    szFullPath[256]; <br>   char    szResult[256]; <br>   char    szGetName[256]; <br>   DWORD dwVersion; <br>   char  szVersion[40]; <br>   DWORD dwResult; <br> <br>   switch (message) { <br>        case WM_INITDIALOG: <br>         ShowWindow (hDlg, SW_HIDE); <br> <br>         if (PRIMARYLANGID(GetUserDefaultLangID()) == LANG_JAPANESE) <br>         { <br>            hfontDlg = CreateFont(14, 0, 0, 0, 0, 0, 0, 0, SHIFTJIS_CHARSET, 0, 0, 0, <br>                                  VARIABLE_PITCH | FF_DONTCARE, ""); <br>            hFinePrint = CreateFont(11, 0, 0, 0, 0, 0, 0, 0, SHIFTJIS_CHARSET, 0, 0, 0, <br>                                    VARIABLE_PITCH | FF_DONTCARE, ""); <br>         } <br>         else <br>         { <br>            hfontDlg = CreateFont(14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, <br>                                  VARIABLE_PITCH | FF_SWISS, ""); <br>            hFinePrint = CreateFont(11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, <br>                                    VARIABLE_PITCH | FF_SWISS, ""); <br>         } <br> <br>         CenterWindow (hDlg, GetWindow (hDlg, GW_OWNER)); <br>         GetModuleFileName (hInst, szFullPath, sizeof(szFullPath)); <br> <br>         // Now lets dive in and pull out the version information: <br>         dwVerInfoSize = GetFileVersionInfoSize(szFullPath, &amp;dwVerHnd); <br>         if (dwVerInfoSize) { <br>            LPSTR   lpstrVffInfo; <br>            HANDLE  hMem; <br>            hMem = GlobalAlloc(GMEM_MOVEABLE, dwVerInfoSize); <br>            lpstrVffInfo  = (char *)GlobalLock(hMem); <br>            GetFileVersionInfo(szFullPath, dwVerHnd, dwVerInfoSize, lpstrVffInfo); <br>            // The below 'hex' value looks a little confusing, but <br>            // essentially what it is, is the hexidecimal representation <br>            // of a couple different values that represent the language <br>            // and character set that we are wanting string values for. <br>            // 040904E4 is a very common one, because it means: <br>            //   US English, Windows MultiLingual characterset <br>            // Or to pull it all apart: <br>            // 04------        = SUBLANG_ENGLISH_USA <br>            // --09----        = LANG_ENGLISH <br>            // --11----        = LANG_JAPANESE <br>            // ----04E4 = 1252 = Codepage for Windows:Multilingual <br> <br>            lstrcpy(szGetName, GetStringRes(IDS_VER_INFO_LANG)); <br> <br>            wRootLen = lstrlen(szGetName); // Save this position <br> <br>            // Set the title of the dialog: <br>            lstrcat (szGetName, "ProductName"); <br>            bRetCode = VerQueryValue((LPVOID)lpstrVffInfo, <br>               (LPSTR)szGetName, <br>               (LPVOID *)&amp;lpVersion, <br>               (UINT *)&amp;uVersionLen); <br> <br>            // Notice order of version and string... <br>            if (PRIMARYLANGID(GetUserDefaultLangID()) == LANG_JAPANESE) <br>            { <br>               lstrcpy(szResult, lpVersion); <br>               lstrcat(szResult, "    o [ W        "); <br>            } <br>            else <br>            { <br>               lstrcpy(szResult, "About "); <br>               lstrcat(szResult, lpVersion); <br>            } <br> <br>            // ----------------------------------------------------- <br> <br>            SetWindowText (hDlg, szResult); <br> <br>            // Walk through the dialog items that we want to replace: <br>            for (i = DLG_VERFIRST; i &lt;= DLG_VERLAST; i++) { <br>               GetDlgItemText(hDlg, i, szResult, sizeof(szResult)); <br>               szGetName[wRootLen] = (char)0; <br>               lstrcat (szGetName, szResult); <br>               uVersionLen   = 0; <br>               lpVersion     = NULL; <br>               bRetCode      =  VerQueryValue((LPVOID)lpstrVffInfo, <br>                  (LPSTR)szGetName, <br>                  (LPVOID *)&amp;lpVersion, <br>                  (UINT *)&amp;uVersionLen); <br> <br>               if ( bRetCode &amp;&amp; uVersionLen &amp;&amp; lpVersion) { <br>               // Replace dialog item text with version info <br>                  lstrcpy(szResult, lpVersion); <br>                  SetDlgItemText(hDlg, i, szResult); <br>               } <br>               else <br>               { <br>                  dwResult = GetLastError(); <br> <br>                  wsprintf(szResult, GetStringRes(IDS_VERSION_ERROR), dwResult); <br>                  SetDlgItemText (hDlg, i, szResult); <br>               } <br>               SendMessage (GetDlgItem (hDlg, i), WM_SETFONT, <br>                  (UINT)((i==DLG_VERLAST)?hFinePrint:hfontDlg), <br>                  TRUE); <br>            } // for (i = DLG_VERFIRST; i &lt;= DLG_VERLAST; i++) <br> <br> <br>            GlobalUnlock(hMem); <br>            GlobalFree(hMem); <br> <br>         } else { <br>            // No version information available. <br>         } // if (dwVerInfoSize) <br> <br>            SendMessage (GetDlgItem (hDlg, IDC_LABEL), WM_SETFONT, <br>            (WPARAM)hfontDlg,(LPARAM)TRUE); <br> <br>         // We are  using GetVersion rather then GetVersionEx <br>         // because earlier versions of Windows NT and Win32s <br>         // didn't include GetVersionEx: <br>         dwVersion = GetVersion(); <br> <br>         if (dwVersion &lt; 0x80000000) { <br>            // Windows NT <br>            wsprintf (szVersion, "Microsoft Windows NT %u.%u (Build: %u)", <br>               (DWORD)(LOBYTE(LOWORD(dwVersion))), <br>               (DWORD)(HIBYTE(LOWORD(dwVersion))), <br>                    (DWORD)(HIWORD(dwVersion)) ); <br>         } else if (LOBYTE(LOWORD(dwVersion))&lt;4) { <br>            // Win32s <br>                wsprintf (szVersion, "Microsoft Win32s %u.%u (Build: %u)", <br>               (DWORD)(LOBYTE(LOWORD(dwVersion))), <br>               (DWORD)(HIBYTE(LOWORD(dwVersion))), <br>                    (DWORD)(HIWORD(dwVersion) &amp; ~0x8000) ); <br>         } else { <br>            // Windows 95 <br>                wsprintf (szVersion, "Microsoft Windows 95 %u.%u", <br>                    (DWORD)(LOBYTE(LOWORD(dwVersion))), <br>                    (DWORD)(HIBYTE(LOWORD(dwVersion))) ); <br>         } <br> <br>          SetWindowText (GetDlgItem(hDlg, IDC_OSVERSION), szVersion); <br>         ShowWindow (hDlg, SW_SHOW); <br>         return (TRUE); <br> <br>      case WM_COMMAND: <br>         if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) { <br>            EndDialog(hDlg, TRUE); <br>            DeleteObject (hfontDlg); <br>            DeleteObject (hFinePrint); <br>            return (TRUE); <br>         } <br>         break; <br>   } <br> <br>    return FALSE; <br>} <br> <br>// <br>//   FUNCTION: CenterWindow(HWND, HWND) <br>// <br>//   PURPOSE: Centers one window over another. <br>// <br>//   COMMENTS: <br>// <br>//        In this function, we save the instance handle in a global variable and <br>//        create and display the main program window. <br>// <br>//       This functionwill center one window over another ensuring that <br>//    the placement of the window is within the 'working area', meaning <br>//    that it is both within the display limits of the screen, and not <br>//    obscured by the tray or other framing elements of the desktop. <br>BOOL CenterWindow (HWND hwndChild, HWND hwndParent) <br>{ <br>   RECT    rChild, rParent, rWorkArea; <br>   int     wChild, hChild, wParent, hParent; <br>   int     xNew, yNew; <br>   BOOL  bResult; <br> <br>   // Get the Height and Width of the child window <br>   GetWindowRect (hwndChild, &amp;rChild); <br>   wChild = rChild.right - rChild.left; <br>   hChild = rChild.bottom - rChild.top; <br> <br>   // Get the Height and Width of the parent window <br>   GetWindowRect (hwndParent, &amp;rParent); <br>   wParent = rParent.right - rParent.left; <br>   hParent = rParent.bottom - rParent.top; <br> <br>   // Get the limits of the 'workarea' <br>   bResult = SystemParametersInfo( <br>      SPI_GETWORKAREA,  // system parameter to query or set <br>      sizeof(RECT), <br>      &amp;rWorkArea, <br>      0); <br>   if (!bResult) { <br>      rWorkArea.left = rWorkArea.top = 0; <br>      rWorkArea.right = GetSystemMetrics(SM_CXSCREEN); <br>      rWorkArea.bottom = GetSystemMetrics(SM_CYSCREEN); <br>   } <br> <br>   // Calculate new X position, then adjust for workarea <br>   xNew = rParent.left + ((wParent - wChild) /2); <br>   if (xNew &lt; rWorkArea.left) { <br>      xNew = rWorkArea.left; <br>   } else if ((xNew+wChild) &gt; rWorkArea.right) { <br>      xNew = rWorkArea.right - wChild; <br>   } <br> <br>   // Calculate new Y position, then adjust for workarea <br>   yNew = rParent.top  + ((hParent - hChild) /2); <br>   if (yNew &lt; rWorkArea.top) { <br>      yNew = rWorkArea.top; <br>   } else if ((yNew+hChild) &gt; rWorkArea.bottom) { <br>      yNew = rWorkArea.bottom - hChild; <br>   } <br> <br>   // Set it, and return <br>   return SetWindowPos (hwndChild, NULL, xNew, yNew, 0, 0, SWP_NOSIZE | SWP_NOZORDER); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>// FUNCTION:    GetStringRes (int id INPUT ONLY) <br>// <br>// COMMENTS:    Load the resource string with the ID given, and return a <br>//              pointer to it.  Notice that the buffer is common memory so <br>//              the string must be used before this call is made a second time. <br>// <br>//--------------------------------------------------------------------------- <br> <br>LPTSTR   GetStringRes (int id) <br>{ <br>  static TCHAR buffer[MAX_PATH]; <br> <br>  buffer[0]=0; <br>  LoadString (GetModuleHandle (NULL), id, buffer, MAX_PATH); <br>  return buffer; <br>} <br> <br> <br> <br>//////////////////////////////////////////////////////////////////// <br> <br>typedef HRESULT (STDAPICALLTYPE * PFNSAMPLECALLBACK) (IStreamSample *pSource, <br>                                                      IStreamSample *pDest, <br>                                                      void * pvContext); <br> <br>#define MAX_COPY_STREAMS 5 <br> <br>class CopyPair { <br>public: <br>    CComPtr&lt;IStreamSample&gt; pSource; <br>    CComPtr&lt;IStreamSample&gt; pDest; <br>    MSPID PurposeId; <br>    PFNSAMPLECALLBACK pCallback; <br>    void * pCallbackContext; <br>    HRESULT hrLastStatus; <br>    bool    bReading; <br>    bool    bGotFirstSample; <br>    STREAM_TIME stActualStart; <br>    STREAM_TIME stStartBias; <br>    STREAM_TIME stLastEndTime; <br>}; <br> <br> <br> <br>class CCopyEngine <br>{ <br>public: <br>    CCopyEngine(IMultiMediaStream *pDestMMStream); <br>    ~CCopyEngine(); <br> <br>    HRESULT InitStream(REFMSPID PurposeId, <br>                       PFNSAMPLECALLBACK pCallback = NULL, <br>                       void * pContext = NULL, <br>                       bool bSharedFormat = false); <br>    HRESULT CopyStreamData(IMultiMediaStream *pSourceMMStream, <br>                           STREAM_TIME stStart, STREAM_TIME stEnd); <br> <br>private: <br>    CComPtr&lt;IMultiMediaStream&gt;  m_pDestMMStream; <br>    CopyPair        m_aPair[MAX_COPY_STREAMS]; <br>    HANDLE          m_aEvent[MAX_COPY_STREAMS]; <br>    int             m_cNumPairs; <br>    bool            m_bStarted; <br>}; <br> <br>/////// <br> <br>CCopyEngine::CCopyEngine(IMultiMediaStream *pDestMMStream) : <br>    m_cNumPairs(0), <br>    m_pDestMMStream(pDestMMStream), <br>    m_bStarted(false) <br>    {}; <br> <br>HRESULT CCopyEngine::InitStream(REFMSPID PurposeId, <br>                                PFNSAMPLECALLBACK pCallback, void * pContext, <br>                                bool bSharedFormat) <br>{ <br>    HRESULT hr = E_FAIL;    // Assume it won't work. <br>    if (m_cNumPairs &lt; MAX_COPY_STREAMS) { <br>        CComPtr &lt;IMediaStream&gt; pDest; <br>        if (m_pDestMMStream-&gt;GetMediaStream(PurposeId, &amp;pDest) == NOERROR) { <br>            CComPtr&lt;IStreamSample&gt; pDestSample; <br>            hr = pDest-&gt;AllocateSample(0, &amp;pDestSample); <br>            if (SUCCEEDED(hr)) { <br>                m_aEvent[m_cNumPairs] = CreateEvent(NULL, TRUE, FALSE, NULL); <br>                if (!m_aEvent[m_cNumPairs]) { <br>                    hr = E_OUTOFMEMORY; <br>                } else { <br>                    m_aPair[m_cNumPairs].pDest = pDestSample; <br>                    m_aPair[m_cNumPairs].pCallback = pCallback; <br>                    m_aPair[m_cNumPairs].pCallbackContext = pContext; <br>                    m_aPair[m_cNumPairs].PurposeId = PurposeId; <br>                    m_aPair[m_cNumPairs].stStartBias = 0; <br>                    m_cNumPairs++; <br>                } <br>            } <br>        } <br>    } <br>    return hr; <br>} <br> <br> <br>HRESULT CCopyEngine::CopyStreamData(IMultiMediaStream *pSourceMMStream, <br>                                    STREAM_TIME stClipStart, STREAM_TIME stClipEnd) <br>{ <br>    HRESULT hr; <br>    if (m_cNumPairs == 0) { <br>        return S_FALSE; <br>    } <br>    int i; <br>    for (i = 0; i &lt; m_cNumPairs; i++) { <br>        m_aPair[i].bGotFirstSample = false; <br>        CComPtr &lt;IMediaStream&gt; pSource; <br>        if (pSourceMMStream-&gt;GetMediaStream(m_aPair[i].PurposeId, &amp;pSource) == NOERROR) { <br>            m_aPair[i].pSource = NULL; <br>            hr = pSource-&gt;AllocateSample(0, &amp;m_aPair[i].pSource); <br>        } else { <br>            hr = E_FAIL; <br>        } <br>        if (FAILED(hr)) { <br>            return hr; <br>        } <br>    } <br>    pSourceMMStream-&gt;SetState(STREAMSTATE_RUN); <br>    if (stClipStart) { <br>        pSourceMMStream-&gt;Seek(stClipStart); <br>    } <br>    for (i = 0; i &lt; m_cNumPairs; i++) { <br>        m_aPair[i].hrLastStatus = NOERROR; <br>        m_aPair[i].bReading = true; <br>        m_aPair[i].pSource-&gt;Update(0, m_aEvent[i], NULL, 0); <br>    } <br>    if (!m_bStarted) { <br>        m_pDestMMStream-&gt;SetState(STREAMSTATE_RUN); <br>        m_bStarted = true; <br>    } <br>    int NumRunning = m_cNumPairs; <br>    while (NumRunning &gt; 0) { <br>        DWORD dwWaitRet = WaitForMultipleObjects(m_cNumPairs, m_aEvent, FALSE, INFINITE); <br>        if (dwWaitRet &gt;= WAIT_OBJECT_0 &amp;&amp; dwWaitRet &lt; WAIT_OBJECT_0 + m_cNumPairs) { <br>            int iCompleted = dwWaitRet - WAIT_OBJECT_0; <br>            CopyPair *pPair = &amp;m_aPair[iCompleted]; <br>            IStreamSample *pDone = pPair-&gt;bReading ? pPair-&gt;pSource : pPair-&gt;pDest; <br>            pPair-&gt;hrLastStatus = pDone-&gt;CompletionStatus(0, 0); </code></pre>
<p>
</p>
<pre><code>if (pPair-&gt;hrLastStatus == NOERROR) { <br>                if (pPair-&gt;bReading) { <br>                    STREAM_TIME stStart, stStop; <br>                    pPair-&gt;pSource-&gt;GetSampleTimes(&amp;stStart, &amp;stStop, NULL); <br>                    if (stClipEnd &gt; 0 &amp;&amp; stStart &gt; stClipEnd) { <br>                        if (pPair-&gt;bGotFirstSample) { <br>                            pPair-&gt;stStartBias += pPair-&gt;stLastEndTime - pPair-&gt;stActualStart; <br>                        } <br>                        NumRunning--; <br>                        ResetEvent(m_aEvent[iCompleted]); <br>                    } else { <br>                        if (pPair-&gt;pCallback) { <br>                            pPair-&gt;pCallback(pPair-&gt;pSource, pPair-&gt;pDest, pPair-&gt;pCallbackContext); <br>                        } <br>                        if (!pPair-&gt;bGotFirstSample) { <br>                            pPair-&gt;stActualStart = stStart; <br>                            pPair-&gt;bGotFirstSample = true; <br>                        } <br>                        pPair-&gt;stLastEndTime = stStop; <br>                        stStart += pPair-&gt;stStartBias - pPair-&gt;stActualStart; <br>                        stStop += pPair-&gt;stStartBias - pPair-&gt;stActualStart; <br>                        pPair-&gt;pDest-&gt;SetSampleTimes(&amp;stStart, &amp;stStop); <br>                        pPair-&gt;bReading = false; <br>                        pPair-&gt;pDest-&gt;Update(0, m_aEvent[iCompleted], NULL, 0); <br>                    } <br>                } else { <br>                    pPair-&gt;pSource-&gt;Update(0, m_aEvent[iCompleted], NULL, 0); <br>                    pPair-&gt;bReading = true; <br>                } <br>            } else { <br>                if (pPair-&gt;bGotFirstSample) { <br>                    pPair-&gt;stStartBias += pPair-&gt;stLastEndTime - pPair-&gt;stActualStart; <br>                } <br>                ResetEvent(m_aEvent[iCompleted]); <br>                NumRunning--; <br>            } <br>        } <br>    } <br>    pSourceMMStream-&gt;SetState(STREAMSTATE_STOP); <br>    for (i = 0; i &lt; m_cNumPairs; i++) { <br>        m_aPair[i].pSource = NULL;  // Release the source sample <br>    } <br>    return NOERROR; <br>} <br> <br> <br>CCopyEngine::~CCopyEngine() <br>{ <br>    int i; <br>    for (i = 0; i &lt; m_cNumPairs; i++) { <br>        CloseHandle(m_aEvent[i]); <br>        if (m_bStarted &amp;&amp; m_aPair[i].pDest) { <br>            CComPtr&lt;IMediaStream&gt; pMS; <br>            m_aPair[i].pDest-&gt;GetMediaStream(&amp;pMS); <br>            pMS-&gt;SendEndOfStream(0); <br>        } <br>    } <br>    if (m_bStarted) { <br>        m_pDestMMStream-&gt;SetState(STREAMSTATE_STOP); <br>    } <br> <br>} <br> <br> <br> <br> <br>/////////////////////////////////////////////////////////////////// <br> <br>void ErrorMessage(int StringId) <br>{ <br>    MessageBox (GetFocus(), GetStringRes(StringId), szAppName, MB_OK|MB_ICONHAND); <br>} <br> <br>#define CHECK_ERROR(x, idFailMsg) if (FAILED(hr = (x))) { if (idFailMsg) ErrorMessage(idFailMsg); goto Exit; } <br> <br>#define RECTHEIGHT(r) ((r).bottom - (r).top) <br>#define RECTWIDTH(r)  ((r).right - (r).left) <br> <br>HRESULT STDAPICALLTYPE VideoCallback(IStreamSample *pSource, IStreamSample *pDest, <br>                                     void * pvhWnd) <br>{ <br>    CComQIPtr &lt;IDirectDrawStreamSample, &amp;IID_IDirectDrawStreamSample&gt; pSrcSample(pSource); <br>    CComPtr &lt;IDirectDrawSurface&gt; pSrcSurface; <br>    RECT rectSrc; <br>    if (SUCCEEDED(pSrcSample-&gt;GetSurface(&amp;pSrcSurface, &amp;rectSrc))) { <br>        HDC hdcSurface; <br>        if (SUCCEEDED(pSrcSurface-&gt;GetDC(&amp;hdcSurface))) { <br>            CComQIPtr &lt;IDirectDrawStreamSample, &amp;IID_IDirectDrawStreamSample&gt; pDestSample(pDest); <br>            CComPtr &lt;IDirectDrawSurface&gt; pDestSurface; <br>            RECT rectDest; <br>            HRESULT hr = pDestSample-&gt;GetSurface(&amp;pDestSurface, &amp;rectDest); <br> <br>            HDC hdcDest = GetDC((HWND)pvhWnd); <br>            BOOL fred = StretchBlt(hdcDest, 0, 0, rectDest.right-rectDest.left, rectDest.bottom-rectDest.top, <br>                       hdcSurface, rectSrc.left, rectSrc.top, RECTWIDTH(rectSrc), RECTHEIGHT(rectSrc), SRCCOPY); <br>            ReleaseDC((HWND)pvhWnd, hdcDest); <br> <br>            hr = pDestSurface-&gt;GetDC(&amp;hdcDest); <br>            StretchBlt(hdcDest, 0, 0, rectDest.right-rectDest.left, rectDest.bottom-rectDest.top, <br>                       hdcSurface, rectSrc.left, rectSrc.top, RECTWIDTH(rectSrc), RECTHEIGHT(rectSrc), SRCCOPY); <br> <br>            TextOut(hdcDest, 20, 20, "Easy to do effects!", 19); <br> <br>            pDestSurface-&gt;ReleaseDC(hdcDest); <br> <br>        } <br> <br>        //  Release this ALWAYS to bypass NT4.0 DDraw bug <br>        pSrcSurface-&gt;ReleaseDC(hdcSurface); <br>    } <br>    return NOERROR; <br>} <br> <br> <br> <br>HRESULT OpenReadMMStream(LPOLESTR pszFileName, DDSURFACEDESC &amp; ddsd, IMultiMediaStream **ppMMStream) <br>{ <br>    *ppMMStream = NULL; <br>    CComPtr &lt;IAMMultiMediaStream&gt; pAMStream; <br>    CComPtr &lt;IMediaStream&gt; pVideoStream; <br>    CComQIPtr&lt;IDirectDrawMediaStream, &amp;IID_IDirectDrawMediaStream&gt; pDDStream; <br>    HRESULT hr; <br> <br>    CHECK_ERROR(CoCreateInstance(CLSID_AMMultiMediaStream, NULL, CLSCTX_INPROC_SERVER, <br> IID_IAMMultiMediaStream, (void **)&amp;pAMStream), IDS_UNABLETOINITREAD); <br>    CHECK_ERROR(pAMStream-&gt;Initialize(STREAMTYPE_READ, 0, NULL), IDS_UNABLETOINITREAD); <br>    CHECK_ERROR(pAMStream-&gt;AddMediaStream(g_pDD, &amp;MSPID_PrimaryVideo, 0, &amp;pVideoStream), IDS_UNABLETOINITREAD); <br>    pDDStream = pVideoStream; <br> <br>    CHECK_ERROR(pDDStream-&gt;SetFormat(&amp;ddsd, NULL), IDS_UNABLETOINITREAD); <br> //   CHECK_ERROR(pAMStream-&gt;AddMediaStream(NULL, &amp;MSPID_PrimaryAudio, 0, NULL)); <br> <br>    CHECK_ERROR(pAMStream-&gt;OpenFile(pszFileName, AMMSF_NOCLOCK), IDS_UNABLETOOPENREAD); <br> <br>    *ppMMStream = pAMStream; <br>    pAMStream-&gt;AddRef(); <br> <br>Exit: <br>    return hr; <br>} <br> <br> <br> <br>void DoMakeMovie(HINSTANCE hInst, HWND hWndPreview, CDocument * pDocument) <br>{ <br>    if (!pDocument-&gt;m_TargetFileName) { <br>        ErrorMessage(IDS_NOFILENAME); <br>        return; <br>    } <br>    if (pDocument-&gt;m_ClipList.NumClips() == 0) { <br>        ErrorMessage(IDS_NOCLIPS); <br>        return; <br>    } <br> <br>    DDSURFACEDESC ddsd; <br>    ddsd.dwSize = sizeof(ddsd); <br>    ddsd.dwFlags = DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT; <br>    ddsd.dwHeight = pDocument-&gt;m_Height; <br>    ddsd.dwWidth  = pDocument-&gt;m_Width; <br>    memcpy(&amp;ddsd.ddpfPixelFormat, &amp;g_aPixelFormats[pDocument-&gt;m_PixelDepth], sizeof(ddsd.ddpfPixelFormat)); <br> <br>    WAVEFORMATEX wfex; <br> <br>    ShowWindow(pDocument-&gt;m_ClipList.m_hLV, SW_HIDE); <br> <br>    CComPtr &lt;IMultiMediaStream&gt; pWriterStream; <br>    if (SUCCEEDED(CreateWriterStream(pDocument-&gt;m_TargetFileName,   // If this fails, it will display an appropriate message <br>                       pDocument-&gt;m_VideoCodecDisplayName, <br>                       ddsd, <br>                       pDocument-&gt;m_AudioCodecDisplayName, <br>                       wfex, <br>                       &amp;pWriterStream))) { <br>        CCopyEngine Engine(pWriterStream); <br>        Engine.InitStream(MSPID_PrimaryVideo, VideoCallback, hWndPreview, false); <br>        int NumClips = pDocument-&gt;m_ClipList.NumClips(); <br>        for (int i = 0; i &lt; NumClips; i++) { <br>            CClip *pClip = pDocument-&gt;m_ClipList.GetClip(i); <br>            CComPtr &lt;IMultiMediaStream&gt; pReadStream; <br>            ddsd.dwFlags = DDSD_PIXELFORMAT;    // Only set pixel format on source streams <br>            if (SUCCEEDED(OpenReadMMStream(pClip-&gt;m_FileName, ddsd, &amp;pReadStream))) { <br>                Engine.CopyStreamData(pReadStream, pClip-&gt;m_stStart, pClip-&gt;m_stEnd); <br>            } <br>        } <br>    } <br> <br>    ShowWindow(pDocument-&gt;m_ClipList.m_hLV, SW_SHOW); <br>} <br> <br> <br> <br>HRESULT AddAndRenderCompressor(LPOLESTR pszCodec, <br>                               LPOLESTR pszFilterName, <br>                               ICaptureGraphBuilder *pBuilder, <br>                               IMediaStream *pStream, <br>                               IBaseFilter *pMuxFilter) <br>{ <br>    HRESULT hr; <br>    CComPtr &lt;IMoniker&gt; pDeviceMoniker; <br>    CComPtr &lt;IBindCtx&gt; pBindCtx; <br>    CComPtr &lt;IBaseFilter&gt; pCodecFilter; <br>    CComPtr &lt;IGraphBuilder&gt; pFilterGraph; <br>    if (pszCodec) { <br>        unsigned long ccEaten; <br>        CHECK_ERROR(CreateBindCtx(0, &amp;pBindCtx), IDS_NOCOMPRESSOR); <br>        CHECK_ERROR(MkParseDisplayName(pBindCtx, pszCodec, &amp;ccEaten, &amp;pDeviceMoniker), IDS_NOCOMPRESSOR); <br>        CHECK_ERROR(pDeviceMoniker-&gt;BindToObject(pBindCtx, NULL, IID_IBaseFilter, (void **)&amp;pCodecFilter), IDS_NOCOMPRESSOR); <br>        CHECK_ERROR(pBuilder-&gt;GetFiltergraph(&amp;pFilterGraph), IDS_INTERNALERROR); <br>        CHECK_ERROR(pFilterGraph-&gt;AddFilter(pCodecFilter, pszFilterName), IDS_INTERNALERROR); <br>        hr = pBuilder-&gt;RenderStream(NULL, pStream, pCodecFilter, pMuxFilter); <br>        if (FAILED(hr)) { <br>            ErrorMessage(IDS_CANTCOMPRESS); <br>        } <br>    } else { <br>        hr = pBuilder-&gt;RenderStream(NULL, pStream, NULL, pMuxFilter); <br>        if (FAILED(hr)) { <br>            ErrorMessage(IDS_CANTCONNECTTOMUX); <br>        } <br>    } <br>Exit: <br>    return hr; <br>} <br> <br> <br>HRESULT CreateWriterStream(LPOLESTR szOutputFileName, <br>                           LPOLESTR szVideoCodec, <br>                           DDSURFACEDESC&amp; ddsdVideoFormat, <br>                           LPOLESTR szAudioCodec, <br>                           WAVEFORMATEX&amp; wfexAudioFormat, <br>                           IMultiMediaStream **ppMMStream) <br>{ <br>    *ppMMStream = NULL; <br>    CComPtr &lt;IAMMultiMediaStream&gt; pAMStream; <br>    CComPtr &lt;IMediaStream&gt; pVideoStream; <br>    CComPtr &lt;IMediaStream&gt; pAudioStream; <br>    CComPtr &lt;ICaptureGraphBuilder&gt; pBuilder; <br>    CComPtr &lt;IGraphBuilder&gt; pFilterGraph; <br>    CComPtr &lt;IFileSinkFilter&gt; pFileSinkWriter; <br>    CComPtr &lt;IBaseFilter&gt; pMuxFilter; <br>    CComQIPtr &lt;IDirectDrawMediaStream, &amp;IID_IDirectDrawMediaStream&gt; pDDStream; <br>    CComQIPtr &lt;IAudioMediaStream, &amp;IID_IAudioMediaStream&gt; pAudioSpecificStream; <br>    HRESULT hr; <br> <br>    CHECK_ERROR(CoCreateInstance(CLSID_AMMultiMediaStream, NULL, CLSCTX_INPROC_SERVER, <br> IID_IAMMultiMediaStream, (void **)&amp;pAMStream), IDS_UNABLETOINITWRITE); <br>    CHECK_ERROR(pAMStream-&gt;Initialize(STREAMTYPE_WRITE, 0, NULL), IDS_UNABLETOINITWRITE); <br> <br>    CHECK_ERROR(pAMStream-&gt;AddMediaStream(g_pDD, &amp;MSPID_PrimaryVideo, 0, &amp;pVideoStream), IDS_UNABLETOINITWRITE); <br>  //  CHECK_ERROR(pAMStream-&gt;AddMediaStream(NULL, &amp;MSPID_PrimaryAudio, 0, &amp;pAudioStream)); <br> <br>    pDDStream = pVideoStream; <br>   // pAudioSpecificStream = pAudioStream; <br> <br>    CHECK_ERROR(pDDStream-&gt;SetFormat(&amp;ddsdVideoFormat, NULL), IDS_CANTSETFORMAT); <br> /// BUGBUG!!!   CHECK_ERROR(pAudioSpecificStream-&gt;SetFormat(&amp;wfexAudioFormat)); <br> <br>    CHECK_ERROR(CoCreateInstance(CLSID_CaptureGraphBuilder, NULL, CLSCTX_INPROC_SERVER, <br>                                 IID_ICaptureGraphBuilder, (void **)&amp;pBuilder), IDS_UNABLETOINITWRITE); <br> <br>    CHECK_ERROR(pAMStream-&gt;GetFilterGraph(&amp;pFilterGraph), IDS_INTERNALERROR); <br>    CHECK_ERROR(pBuilder-&gt;SetFiltergraph(pFilterGraph), IDS_INTERNALERROR); <br> <br>    CHECK_ERROR(pBuilder-&gt;SetOutputFileName(&amp;MEDIASUBTYPE_Avi, szOutputFileName, &amp;pMuxFilter, &amp;pFileSinkWriter), IDS_UNABLETOSETOUTPUTNAME); <br> <br>    CHECK_ERROR(AddAndRenderCompressor(szVideoCodec, L"Video compressor", pBuilder, pVideoStream, pMuxFilter), 0); // This function displays its own message <br>///    CHECK_ERROR(AddAndRenderCompressor(szAudioCodec, L"Audio compressor", pBuilder, pAudioStream, pMuxFilter)); <br> <br>    *ppMMStream = pAMStream; <br>    (*ppMMStream)-&gt;AddRef(); <br> <br>Exit: <br>    return hr; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
