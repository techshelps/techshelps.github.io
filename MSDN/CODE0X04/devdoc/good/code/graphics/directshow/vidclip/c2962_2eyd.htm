<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SETTINGS.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2965"></a>SETTINGS.CPP</h2>
<pre><code>#include "vcproj.h" <br> <br> <br> <br>// Local Header Files <br>#include "vidclip.h" <br>#include "resource.h" <br>#include "atlbase.h" <br>extern CComModule _Module; <br>#include "atlcom.h" <br>#include "strmif.h" <br>#include "uuids.h" <br>#include "document.h" <br> <br> <br>class CSettings <br>{ <br>public: <br>    CSettings(CDocument *pDoc) : m_pDocument(pDoc) {}; <br>    void Init(HWND hDlg); <br>    void FillCompressorList(HWND hWndCombo, REFGUID CatGuid, ICreateDevEnum *pCreateDevEnum, CComBSTR&amp; szDisplayName); <br>    void CleanCompressorList(HWND hWndCombo, LPOLESTR * ppDisplayName); <br>    void CleanUp(HWND hDlg, bool bSave); <br> <br>    CDocument * m_pDocument; <br>}; <br> <br>void GetMonikerName(IMoniker *pM, LPOLESTR *ppDisplayName) <br>{ <br>    CComPtr &lt;IBindCtx&gt; pBindCtx; <br>    CreateBindCtx(0, &amp;pBindCtx); <br>    pM-&gt;GetDisplayName(pBindCtx, NULL, ppDisplayName); <br>} <br> <br> <br>void CSettings::FillCompressorList( <br>    HWND hWndCombo, <br>    REFGUID CatGuid, <br>    ICreateDevEnum *pCreateDevEnum, <br>    CComBSTR &amp;szDisplayName) <br>{ <br>    CComPtr &lt;IMalloc&gt; pMalloc; <br>    CoGetMalloc(1, &amp;pMalloc); <br>    bool bFoundPrevSelection = false; <br>    IEnumMoniker *pEm; <br>    HRESULT hr = pCreateDevEnum-&gt;CreateClassEnumerator( <br>        CatGuid, <br>        &amp;pEm, <br>        0); <br>    if(hr == S_OK) <br>    { <br>        // enumerator returns S_FALSE if the category is empty <br>        ULONG cFetched; <br>        IMoniker *pM; <br>        while(hr = pEm-&gt;Next(1, &amp;pM, &amp;cFetched), <br>              hr == S_OK) <br>        { <br>            IPropertyBag *pPropBag; <br>            hr = pM-&gt;BindToStorage(0, 0, IID_IPropertyBag, (void **)&amp;pPropBag); <br>            if(SUCCEEDED(hr)) <br>            { <br>                VARIANT var; <br>                var.vt = VT_BSTR; <br>                hr = pPropBag-&gt;Read(L"FriendlyName", &amp;var, 0); <br>                if(SUCCEEDED(hr)) <br>                { <br>                    TCHAR szString[MAX_PATH]; <br>                    WideCharToMultiByte( <br>                        CP_ACP, 0, var.bstrVal, -1, <br>                        szString, sizeof(szString), 0, 0); <br> <br>                    int ID = SendMessage(hWndCombo, CB_ADDSTRING, 0, (LPARAM)&amp;szString); <br>                    SendMessage(hWndCombo, CB_SETITEMDATA, ID, (LPARAM)pM); <br>                    SysFreeString(var.bstrVal); <br>                    if (!bFoundPrevSelection &amp;&amp; szDisplayName) { <br>                        LPOLESTR pThisDevName; <br>                        GetMonikerName(pM, &amp;pThisDevName); <br>                        if (pThisDevName) { <br>                            if (wcscmp(szDisplayName, pThisDevName) == 0) { <br>                                bFoundPrevSelection = true; <br>                                SendMessage(hWndCombo, CB_SETCURSEL, ID, 0); <br>                            } <br>                            pMalloc-&gt;Free(pThisDevName); <br>                        } <br>                    } <br>                } <br>                pPropBag-&gt;Release(); <br>            } <br> <br>            /// pM-&gt;Release(); -- Will do this later! <br>        } <br>        pEm-&gt;Release(); <br>    } <br>    static TCHAR szNone[] = "&lt;None&gt;"; <br>    int ID = SendMessage(hWndCombo, CB_ADDSTRING, 0, (LPARAM)&amp;szNone); <br>    if (!bFoundPrevSelection) { <br>        SendMessage(hWndCombo, CB_SETCURSEL, ID, 0); <br>    } <br>} <br> <br> <br>void inline SetEditLong(HWND hDlg, int ID, long val) <br>{ <br>    TCHAR s[20]; <br>    wsprintf(s, _T("%li"), val); <br>    SendDlgItemMessage(hDlg, ID, WM_SETTEXT, 0, (LPARAM)s); <br>} <br> <br> <br>void CSettings::Init(HWND hDlg) <br>{ <br>    USES_CONVERSION;  <br>    CComPtr &lt;ICreateDevEnum&gt; pCreateDevEnum;     <br>    HRESULT hr = CoCreateInstance( <br>        CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER, <br>        IID_ICreateDevEnum, (void**)&amp;pCreateDevEnum); <br>    if(SUCCEEDED(hr)) { <br>        FillCompressorList(GetDlgItem(hDlg, IDC_COMBO_VIDCOMP), <br>                           CLSID_VideoCompressorCategory, <br>                           pCreateDevEnum, <br>                           m_pDocument-&gt;m_VideoCodecDisplayName); <br>        FillCompressorList(GetDlgItem(hDlg, IDC_COMBO_AUDIOCOMP), <br>                           CLSID_AudioCompressorCategory, <br>                           pCreateDevEnum, <br>                           m_pDocument-&gt;m_AudioCodecDisplayName); <br>    } <br>    CheckRadioButton(hDlg, IDC_RADIO16BIT, IDC_RADIO24BIT, IDC_RADIO16BIT + m_pDocument-&gt;m_PixelDepth); <br>    SendDlgItemMessage(hDlg, IDC_EDIT_FILENAME, WM_SETTEXT, 0, (LPARAM)W2T(m_pDocument-&gt;m_TargetFileName)); <br>    SetEditLong(hDlg, IDC_HEIGHT, m_pDocument-&gt;m_Height); <br>    SetEditLong(hDlg, IDC_WIDTH, m_pDocument-&gt;m_Width); <br>} <br> <br> <br>void CSettings::CleanCompressorList(HWND hWndCombo, LPOLESTR * ppDisplayName) <br>{ <br>    *ppDisplayName = NULL; <br>    int IDSelected = SendMessage(hWndCombo, CB_GETCURSEL, 0, 0); <br>    if (IDSelected != CB_ERR) { <br>        IMoniker *pMoniker = (IMoniker *)SendMessage(hWndCombo, CB_GETITEMDATA, IDSelected, 0); <br>        if (pMoniker) { <br>            GetMonikerName(pMoniker, ppDisplayName); <br>        } <br>    } <br>    int NumItems = SendMessage(hWndCombo, CB_GETCOUNT, 0, 0); <br>    for (int i = 0; i &lt; NumItems; i++) { <br>        IMoniker *pMoniker = (IMoniker *)SendMessage(hWndCombo, CB_GETITEMDATA, i, 0); <br>        if (pMoniker) { <br>            pMoniker-&gt;Release(); <br>        } <br>    } <br>} <br> <br>void CSettings::CleanUp(HWND hDlg, bool bSave) <br>{ <br>    USES_CONVERSION; <br>    WCHAR *pVideoName = NULL; <br>    WCHAR *pAudioName = NULL; <br>    CleanCompressorList(GetDlgItem(hDlg, IDC_COMBO_VIDCOMP), &amp;pVideoName); <br>    CleanCompressorList(GetDlgItem(hDlg, IDC_COMBO_AUDIOCOMP), &amp;pAudioName); <br>    if (bSave) { <br>        m_pDocument-&gt;m_VideoCodecDisplayName = pVideoName; <br>        m_pDocument-&gt;m_AudioCodecDisplayName = pAudioName; <br>    } <br>    CComPtr &lt;IMalloc&gt; pMalloc; <br>    CoGetMalloc(1, &amp;pMalloc); <br>    pMalloc-&gt;Free(pVideoName); <br>    pMalloc-&gt;Free(pAudioName); <br>    if (bSave) { <br>        TCHAR szEditContents[MAX_PATH]; <br>        TCHAR *pUnused; <br>        m_pDocument-&gt;MarkDirty(); <br>        SendDlgItemMessage(hDlg, IDC_EDIT_FILENAME, WM_GETTEXT, sizeof(szEditContents) / sizeof(TCHAR), (LPARAM)szEditContents); <br>        m_pDocument-&gt;m_TargetFileName = szEditContents; <br> <br>        SendDlgItemMessage(hDlg, IDC_HEIGHT, WM_GETTEXT, sizeof(szEditContents) / sizeof(TCHAR), (LPARAM)szEditContents); <br>        m_pDocument-&gt;m_Height = strtol(szEditContents, &amp;pUnused, 10); <br>        SendDlgItemMessage(hDlg, IDC_WIDTH, WM_GETTEXT, sizeof(szEditContents) / sizeof(TCHAR), (LPARAM)szEditContents); <br>        m_pDocument-&gt;m_Width = strtol(szEditContents, &amp;pUnused, 10); <br> <br>        m_pDocument-&gt;m_PixelDepth = IsDlgButtonChecked(hDlg, IDC_RADIO16BIT) ? 0 : 1; <br>         <br>    } <br>} <br> <br> <br>void DoSettingsDialog(HINSTANCE hInst, HWND hWnd, CDocument *pDoc) <br>{ <br>    CSettings Settings(pDoc); <br>    DialogBoxParam(hInst, MAKEINTRESOURCE(IDD_SETTINGS), hWnd, (DLGPROC)SettingsDlg, (LPARAM)&amp;Settings); <br>} <br> <br>// <br>//  FUNCTION: Settings(HWND, unsigned, WORD, LONG) <br>// <br>//  PURPOSE:  Processes messages for "About" dialog box <br>//       This version allows greater flexibility over the contents of the 'About' box, <br>//       by pulling out values from the 'Version' resource. <br>// <br>//  MESSAGES: <br>// <br>// WM_INITDIALOG - initialize dialog box <br>// WM_COMMAND    - Input received <br>// <br>// <br> <br>LRESULT CALLBACK SettingsDlg(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>    CSettings *pSettings = (CSettings *)GetWindowLong(hDlg, DWL_USER); <br>    switch (message) { <br>        case WM_INITDIALOG: <br>            pSettings = (CSettings *)lParam; <br>            SetWindowLong(hDlg, DWL_USER, lParam); <br>            pSettings-&gt;Init(hDlg); <br>            return TRUE; <br> <br>        case WM_COMMAND: <br>            if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) { <br>                pSettings-&gt;CleanUp(hDlg, LOWORD(wParam) == IDOK); <br>                EndDialog(hDlg, TRUE); <br>                return TRUE; <br>            } <br>            break; <br>   } <br> <br>   return FALSE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
