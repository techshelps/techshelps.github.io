<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CLTEXT.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2803"></a>CLTEXT.CPP</h2>
<pre><code><br>  //========================================================================= <br>  // <br>  //  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>  //  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>  //  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>  //  PURPOSE. <br>  // <br>  // Copyright (c) 1996 - 1997  Microsoft Corporation.  All Rights Reserved. <br>  // <br>  //========================================================================= <br> <br>  #include &lt;windows.h&gt; <br>  #include &lt;streams.h&gt; <br>  #include &lt;strmif.h&gt; <br>  #include &lt;cutlist.h&gt; <br>  #include &lt;stdio.h&gt; <br>  #include "cltext.h" <br> <br>  ICutListGraphBuilder  *pCLGraphBuilder  = NULL; <br>  IStandardCutList      *pVideoCL         = NULL; <br>  IStandardCutList      *pAudioCL         = NULL; <br>  IGraphBuilder         *pigb             = NULL; <br>  IMediaControl         *pimc             = NULL; <br>  IMediaEventEx         *pimex            = NULL; <br>  IVideoWindow          *pivw             = NULL; <br>  IMediaSeeking         *pims             = NULL; <br> <br>  IFileClip             *pVidFileClip[MAX_CLIPS]; <br>  IFileClip             *pAudFileClip[MAX_CLIPS]; <br>  IAMCutListElement       *pVidCLElem[MAX_CLIPS]; <br>  IAMCutListElement       *pAudCLElem[MAX_CLIPS]; <br> <br>  HRESULT hr; <br> <br>  int nVidElems, nAudElems; <br> <br>  void CutlistFromTextfile () <br> <br>    { // CutlistFromTextfile // <br> <br>      WCHAR wFile[MAX_PATH];  // file name <br> <br>      // Initialize video and audio file clips and elements to NULL <br>      // so we can easily free objects later. <br>      for (int x = 0; x &lt; MAX_CLIPS; ++x) <br> <br>        {  <br>          pVidFileClip[x] = NULL;  <br>          pAudFileClip[x] = NULL;  <br>            pVidCLElem[x] = NULL;  <br>            pAudCLElem[x] = NULL;  <br>        }; <br> <br>      // Create cutlist graph builder object <br>      hr = CoCreateInstance(CLSID_CutListGraphBuilder, NULL,  <br>                            CLSCTX_INPROC, IID_ICutListGraphBuilder,  <br>                            (void**)&amp;pCLGraphBuilder); <br> <br>      if (FAILED(hr)) <br>        { // CoCreateInstance of CutListGraphBuiler failed <br>          MBOX("CoCreateInstance of CutListGraphBuiler failed"); <br>          TearDownTheGraph(); <br>          return; <br>        } // CoCreateInstance of CutListGraphBuiler failed <br> <br>      // Create simple (standard) cutlist object for video <br>      hr = CoCreateInstance(CLSID_SimpleCutList, NULL,  <br>                            CLSCTX_INPROC, IID_IStandardCutList,  <br>                            (void**)&amp;pVideoCL); <br>      if (FAILED(hr)) <br>        { // CoCreateInstance of video CutlistFromTextfile failed <br>          MBOX("CoCreateInstance of video CLSID_SimpleCutList failed"); <br>          TearDownTheGraph(); <br>          return; <br>        } // CoCreateInstance of video CLSID_SimpleCutList failed <br> <br>      // Create simple (standard) cutlist object for audio <br>      hr = CoCreateInstance(CLSID_SimpleCutList, NULL,  <br>                            CLSCTX_INPROC, IID_IStandardCutList,  <br>                            (void**)&amp;pAudioCL); <br> <br>      if (FAILED(hr)) <br>        { // CoCreateInstance of audio CutlistFromTextfile failed <br>          MBOX("CoCreateInstance of audio CLSID_SimpleCutList failed"); <br>          TearDownTheGraph(); <br>          return; <br>        } // CoCreateInstance of audio CutlistFromTextfile failed <br> <br>      // Create the individual clips and add them to the cutlist <br>      nVidElems = nAudElems = 0; <br>      for (x = 0; x &lt; gTheSet.nNumClips; ++x) <br> <br>        { // Individual clips <br> <br>          MultiByteToWideChar(CP_ACP, 0,  <br>                              gTheSet.List[x].szFilename,  <br>                              -1, wFile, MAX_PATH ); <br> <br>          // Create a video clip object and give it the file and stream  <br>          // to read from. <br>          // SetFileAndStream will fail if we call it from a video clip  <br>          // object and the clip is not a video clip. <br>          hr = CoCreateInstance(CLSID_VideoFileClip, NULL,  <br>                                CLSCTX_INPROC, IID_IFileClip,  <br>                                (void**)&amp;pVidFileClip[nVidElems]); <br> <br>          hr = pVidFileClip[nVidElems]-&gt;SetFileAndStream(wFile, 0); <br> <br>          if (SUCCEEDED(hr)) <br> <br>            { // Create video cut and add the clip (element) to the cutlist <br> <br>              hr = pVidFileClip[nVidElems]-&gt;CreateCut(&amp;pVidCLElem[nVidElems],  <br>                      gTheSet.List[x].start*SCALE,  <br>                      gTheSet.List[x].stop*SCALE,  <br>                      0,  <br>                      (gTheSet.List[x].stop-gTheSet.List[x].start)*SCALE,  <br>                      0); <br> <br>              if (SUCCEEDED(hr)) <br> <br>                { // Add the element to the cutlist <br> <br>                  hr = pVideoCL-&gt;AddElement(pVidCLElem[nVidElems], CL_DEFAULT_TIME, CL_DEFAULT_TIME); <br> <br>                  if (SUCCEEDED(hr)) <br>                    ++nVidElems; <br> <br>                  else <br> <br>                    { // AddElement failed so release associated objects <br> <br>                      HELPER_RELEASE(pVidCLElem[nVidElems]); <br>                      HELPER_RELEASE(pVidFileClip[nVidElems]); <br>                      MBOX("AddElement (video) failed!"); <br> <br>                    } // AddElement failed so release associated objects <br> <br>                } // Add the element to the cutlist <br> <br>              else MBOX("CreateCut (video) failed!"); <br> <br>            } // Create video cut <br> <br>          else <br> <br>            { // Problems creating video stream <br> <br>              HELPER_RELEASE(pVidFileClip[nVidElems]); <br>              MBOX("SetFileAndStream (video) failed!"); <br> <br>            } // Problems creating video stream <br> <br>          // Create an audio clip object and give it the file and stream  <br>          // to read from. <br>          // SetFileAndStream will fail if we call it from an audio clip  <br>          // object and the clip is not an audio clip <br>          hr = CoCreateInstance(CLSID_AudioFileClip, NULL,  <br>                                CLSCTX_INPROC, IID_IFileClip,  <br>                                (void**)&amp;pAudFileClip[nAudElems]); <br> <br>          hr = pAudFileClip[nAudElems]-&gt;SetFileAndStream(wFile, 0); <br> <br>          if (SUCCEEDED(hr)) <br> <br>            { // Create audio cut and add the clip (element) to the cutlist <br> <br>            hr = pAudFileClip[nAudElems]-&gt;CreateCut(&amp;pAudCLElem[nAudElems],  <br>                      gTheSet.List[x].start*SCALE,  <br>                      gTheSet.List[x].stop*SCALE,  <br>                      0,  <br>                      (gTheSet.List[x].stop-gTheSet.List[x].start)*SCALE,  <br>                      0); <br> <br>              if (SUCCEEDED(hr)) <br> <br>                { // Add the element to the cutlist <br> <br>                  hr = pAudioCL-&gt;AddElement(pAudCLElem[nAudElems], <br>                                            CL_DEFAULT_TIME,  <br>                                            CL_DEFAULT_TIME); <br> <br>                  if (SUCCEEDED(hr)) <br>                    ++nAudElems; <br> <br>                  else <br> <br>                    { // AddElement failed so release associated objects <br> <br>                      HELPER_RELEASE(pAudCLElem[nAudElems]); <br>                      HELPER_RELEASE(pAudFileClip[nAudElems]); <br>                      MBOX("AddElement (audio) failed!"); <br> <br>                    } // AddElement failed so release associated objects <br> <br>                } // Add the element to the cutlist <br> <br>              else MBOX("CreateCut (audio) failed!"); <br> <br>            } // Create audio cut <br> <br>          else <br>           <br>            { // Problems creating audio stream <br> <br>              HELPER_RELEASE(pAudFileClip[nAudElems]); <br>              MBOX("SetFileAndStream (audio) failed!"); <br> <br>            } // Problems creating audio stream <br> <br>        } // Individual clips <br> <br>      // Add the video cutlist to the filter graph <br>      hr = pCLGraphBuilder-&gt;AddCutList(pVideoCL, NULL); <br> <br>      if (FAILED(hr)) // AddCutList (video) failed <br>          MBOX("AddCutList (video) failed"); <br> <br>      // Add the audio cutlist to the filter graph <br>      hr = pCLGraphBuilder-&gt;AddCutList(pAudioCL, NULL); <br> <br>      if (FAILED(hr)) // AddCutList (audio) failed <br>          MBOX("AddCutList (audio) failed"); <br> <br>      if ((!gTheSet.nNumClips) || (!pVideoCL) &amp;&amp; (!pAudioCL)) <br> <br>        { // Clean up <br> <br>          TearDownTheGraph(); <br>          return; <br> <br>        } // Clean up <br> <br>      // Let the filter graph manager construct the the appropriate graph  <br>      // automatically <br>      hr = pCLGraphBuilder-&gt;Render(); <br> <br>      if (FAILED(hr)) <br>        { // Problems rendering the graph <br>          if (!AMGetErrorText(hr, gszScratch, 2048)) <br>            MBOX("Problems rendering the graph!"); <br>          else  <br>            MBOX(gszScratch); <br>          TearDownTheGraph(); <br>          return; <br>        } // Problems rendering the graph <br> <br>      // Retrieve the filter graph and useful interfaces <br>      hr = pCLGraphBuilder-&gt;GetFilterGraph(&amp;pigb); <br> <br>      if (FAILED(hr)) <br>        { // Problems retrieving the graph pointer <br>          if (!AMGetErrorText(hr, gszScratch, 2048)) <br>            MBOX("Problems retrieving the graph pointer!"); <br>          else  <br>            MBOX(gszScratch); <br>          TearDownTheGraph(); <br>          return; <br>        } // Problems retrieving the graph pointer <br> <br>      // QueryInterface for some basic interfaces <br>      pigb-&gt;QueryInterface(IID_IMediaControl, (void **)&amp;pimc); <br>      pigb-&gt;QueryInterface(IID_IMediaEventEx, (void **)&amp;pimex); <br>      pigb-&gt;QueryInterface(IID_IVideoWindow, (void **)&amp;pivw); <br>      pigb-&gt;QueryInterface(IID_IMediaSeeking, (void **)&amp;pims); <br> <br>      // Decrement the ref count on the filter graph <br>      pigb-&gt;Release(); <br> <br>      // Prepare to play in the main application window's client area <br> <br>      RECT rc; <br>      GetClientRect(ghApp, &amp;rc); <br>      hr = pivw-&gt;put_Owner((OAHWND)ghApp); <br>      hr = pivw-&gt;put_WindowStyle(WS_CHILD|WS_CLIPSIBLINGS); <br>      hr = pivw-&gt;SetWindowPosition(rc.left, rc.top, rc.right, rc.bottom); <br> <br>      hr = pims-&gt;SetTimeFormat(&amp;TIME_FORMAT_MEDIA_TIME); <br>      hr = pims-&gt;GetDuration(&amp;glTotalLength); <br> <br>      SetScrollRange(ghApp, SB_HORZ, 0, 100, TRUE); <br>  <br>      //Ready to rumble... <br>      pimc-&gt;Run(); <br> <br>    } // CutlistFromTextfile // <br> <br>  void TearDownTheGraph (void) <br> <br>      { // TearDownTheGraph // <br> <br>        if (gTimerNum) <br>          timeKillEvent(gTimerNum); <br> <br>        if (pimc) <br>          pimc-&gt;Stop(); <br> <br>        if (pivw) <br> <br>          { // Hide the playback window first thing <br> <br>            pivw-&gt;put_Visible(OAFALSE); <br>            pivw-&gt;put_Owner(NULL); <br> <br>          } // <br> <br>        HELPER_RELEASE(pimex); <br>        HELPER_RELEASE(pimc); <br>        HELPER_RELEASE(pivw); <br>        HELPER_RELEASE(pims); <br> <br>        // Remove the video cutlist from the filter graph to free resources <br>        if (pCLGraphBuilder &amp;&amp; pVideoCL) <br>          pCLGraphBuilder-&gt;RemoveCutList(pVideoCL); <br> <br>        // Remove the audio cutlist from the filter graph to free resources <br>        if (pCLGraphBuilder &amp;&amp; pAudioCL) <br>          pCLGraphBuilder-&gt;RemoveCutList(pAudioCL); <br> <br>        for (int x = 0; x &lt; nAudElems; ++x) <br> <br>          { // Release audio objects <br> <br>            HELPER_RELEASE(pAudCLElem[x]); <br>            HELPER_RELEASE(pAudFileClip[x]); <br> <br>          } // Release audio objects <br> <br>        for (x = 0; x &lt; nVidElems; ++x) <br> <br>          { // Release video objects <br> <br>            HELPER_RELEASE(pVidCLElem[x]); <br>            HELPER_RELEASE(pVidFileClip[x]); <br> <br>          } // Release video objects <br> <br>        HELPER_RELEASE(pVideoCL); <br>        HELPER_RELEASE(pAudioCL);       <br>        HELPER_RELEASE(pCLGraphBuilder); <br> <br>        gTheSet.nNumClips = 0; <br> <br>      } // TearDownTheGraph // <br> <br>  BOOL GetCliplistTxtFilename (LPSTR szName) <br> <br>    {   // GetCliplistTxtFilename // <br> <br>        OPENFILENAME ofn; <br> <br>        ofn.lStructSize       = sizeof(OPENFILENAME); <br>        ofn.hwndOwner         = ghApp; <br>        ofn.lpstrFilter       = NULL; <br>        ofn.lpstrFilter       = "Text Files (clip list) (*.txt)\0*.txt\0\0\0"; <br>        ofn.lpstrCustomFilter = NULL; <br>        ofn.nFilterIndex      = 1; <br>        *szName               = 0; <br>        ofn.lpstrFile         = szName; <br>        ofn.nMaxFile          = MAX_PATH; <br>        ofn.lpstrInitialDir   = NULL; <br>        ofn.lpstrTitle        = NULL; <br>        ofn.lpstrFileTitle    = NULL; <br>        ofn.lpstrDefExt       = "TXT"; <br>        ofn.Flags             = OFN_FILEMUSTEXIST | OFN_READONLY | OFN_PATHMUSTEXIST; <br> <br>        return GetOpenFileName((LPOPENFILENAME)&amp;ofn); <br> <br>    }   // GetCliplistTxtFilename // <br> <br>  LRESULT CALLBACK WndMainProc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) <br> <br>    { // WndMainProc // <br> <br>      LONGLONG l; <br> <br>      switch(message) <br> <br>        { // Window msgs handling <br> <br>          case WM_COMMAND: <br> <br>            switch(wParam) <br> <br>              {  // Program menu option <br> <br>                case ID_FILE_EXIT: <br>                  if (gTheSet.nNumClips) <br>                    TearDownTheGraph(); <br>                  PostQuitMessage(0); <br>                  break; <br> <br>                case ID_CUTLIST_PLAY: <br>                  l = 0; <br>                  hr = pimc-&gt;Stop(); <br>                  hr = pims-&gt;SetPositions(&amp;l, AM_SEEKING_AbsolutePositioning, NULL, AM_SEEKING_NoPositioning); <br>                  hr = pimc-&gt;Run(); <br>                  break; <br> <br>              }  // Program menu option <br> <br>            break; <br> <br>          case WM_HSCROLL: <br> <br>            if (SB_THUMBPOSITION == LOWORD(wParam)) <br> <br>              { // Seeking via horiz. scroll <br> <br>                l = (glTotalLength * (LONGLONG)HIWORD(wParam))/100; <br>                pimc-&gt;Stop(); <br>                hr = pims-&gt;SetPositions(&amp;l, AM_SEEKING_AbsolutePositioning, NULL, AM_SEEKING_NoPositioning); <br>                pimc-&gt;Run(); <br> <br>              } // Seeking via horiz. scroll <br>             <br>          break; <br> <br>          case WM_EXITSIZEMOVE: <br> <br>            RECT rc; <br>            GetClientRect(ghApp, &amp;rc); <br>            if (pivw) <br>              pivw-&gt;SetWindowPosition(rc.left, rc.top, rc.right, rc.bottom); <br>            break; <br> <br>          case WM_SIZE: <br>            if ((SIZE_RESTORED == wParam) || (SIZE_MAXIMIZED == wParam)) <br>              PostMessage(ghApp, WM_EXITSIZEMOVE, 0, 0); <br>            break; <br> <br>          case WM_DESTROY: <br>            if (gTheSet.nNumClips) <br>              TearDownTheGraph(); <br>            PostQuitMessage(0); <br>            break; <br> <br>          default: <br>            return DefWindowProc(hWnd, message, wParam, lParam); <br>           <br>        } // Window msgs handling <br> <br>      return FALSE; <br> <br>      }  // WndMainProc // <br> <br>  void ReadTextFile (LPCSTR cFilename) <br> <br>    { // ReadTextFile // <br> <br>      FILE  *fp; <br>      TCHAR cString[MAX_PATH]; <br> <br>      if (!(fp = fopen(cFilename, "rt"))) <br>        return; // File not found! <br> <br>      while (!feof(fp) &amp;&amp; (gTheSet.nNumClips &lt; MAX_CLIPS)) <br> <br>        { // Parse individual lines <br> <br>          ZeroMemory(cString, MAX_PATH); <br>          fgets(cString, MAX_PATH, fp); <br> <br>          if (lstrlen(cString) &amp;&amp; (cString[0] != TCHAR(';'))) <br> <br>            { // Decipher filename, start, stop times <br> <br>              int i = lstrlen(cString); <br> <br>              while (i &amp;&amp; (cString[i] != TCHAR(','))) --i; <br>              gTheSet.List[gTheSet.nNumClips].stop = atol(&amp;cString[i+1]); --i; <br>              while (i &amp;&amp; (cString[i] != TCHAR(','))) --i; <br>              gTheSet.List[gTheSet.nNumClips].start = atol(&amp;cString[i+1]); <br>              cString[i] = TCHAR('\0'); <br>              lstrcpy(gTheSet.List[gTheSet.nNumClips].szFilename, cString); <br>              gTheSet.nNumClips += 1; <br> <br>            } // Deciphering <br> <br>        } // Parse individual lines <br> <br>      fclose(fp); <br> <br>    } // ReadTextFile // <br> <br>  void CALLBACK TimerProc (UINT uID, UINT uMsg, DWORD dwUser, DWORD dw1, DWORD dw2) <br>   <br>    { // TimerProc // <br> <br>      LONGLONG lPos; <br> <br>      if (pims) <br>        pims-&gt;GetCurrentPosition(&amp;lPos); <br>      lPos = (lPos * 100)/glTotalLength; <br>      SetScrollPos(ghApp, SB_HORZ, (int)lPos, TRUE); <br> <br>    } // TimerProc // <br> <br>  int PASCAL WinMain(HINSTANCE hInstC, HINSTANCE hInstP, LPSTR lpCmdLine, int nCmdShow) <br> <br>    { // WinMain // <br>   <br>      MSG msg; <br>      WNDCLASS wc; <br> <br>      // OLE subsystem requires applications to initialize things first! <br>      CoInitialize(NULL); <br> <br>      ZeroMemory(&amp;wc, sizeof wc); <br>      wc.lpfnWndProc = WndMainProc; <br>      ghInst = wc.hInstance = hInstC; <br>      wc.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH); <br>      wc.lpszClassName = CLASSNAME; <br>      wc.hCursor = LoadCursor(NULL, IDC_ARROW); <br>      wc.hIcon = LoadIcon(hInstC, MAKEINTRESOURCE(IDI_CUTLIST)); <br>      RegisterClass(&amp;wc); <br> <br>      RECT rc; <br> <br>      GetWindowRect(GetDesktopWindow(), &amp;rc); <br>      rc.right &gt;&gt;= 1; <br>      rc.bottom &gt;&gt;= 1; <br> <br>      ghApp = CreateWindow(CLASSNAME, <br>      APPLICATIONNAME, <br>      WS_OVERLAPPEDWINDOW|WS_HSCROLL, <br>      rc.right-200, <br>      rc.bottom-200, <br>      400, <br>      400, <br>      0, <br>      0, <br>      ghInst, <br>      0); <br>       <br>      SetMenu(ghApp, ghMenu = LoadMenu(hInstC, MAKEINTRESOURCE(IDR_MENU1))); <br> <br>      ShowWindow(ghApp, SW_NORMAL); <br>      UpdateWindow(ghApp); <br> <br>      ZeroMemory(&amp;gTheSet, sizeof gTheSet); <br> <br>      // Text-file <br> <br>      TCHAR szFilename[MAX_PATH]; <br> <br>      if (lstrlen(lpCmdLine)) <br>        ReadTextFile(lpCmdLine); <br>      else <br>        if (GetCliplistTxtFilename(szFilename)) <br>          ReadTextFile(szFilename); <br>        else <br>          return FALSE; <br> <br>      if (gTheSet.nNumClips) <br>        CutlistFromTextfile(); <br> <br>      // Establish a callback-based tracking timer <br>      gTimerNum = 0; <br>      if (nVidElems || nAudElems) <br>        gTimerNum = timeSetEvent(125, 0, TimerProc, 0, TIME_PERIODIC); <br> <br>      while (GetMessage(&amp;msg,NULL,0,0)) <br> <br>      {  // Message loop <br> <br>         TranslateMessage(&amp;msg); <br>         DispatchMessage(&amp;msg); <br> <br>      }  // Message loop <br> <br>      DestroyMenu(ghMenu); <br> <br>      // Finished with OLE subsystem <br>      CoUninitialize(); <br> <br>      return msg.wParam; <br> <br>  } // WinMain // </code></pre>
<p>&nbsp;</p></body>
</HTML>
