<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SIMPLECL.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2806"></a>SIMPLECL.CPP</h2>
<pre><code><br>  //========================================================================= <br>  // <br>  //  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>  //  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>  //  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>  //  PURPOSE. <br>  // <br>  // Copyright (c) 1996 - 1997  Microsoft Corporation.  All Rights Reserved. <br>  // <br>  //========================================================================= <br> <br>  #include &lt;windows.h&gt; <br>  #include &lt;streams.h&gt; <br>  #include &lt;strmif.h&gt; <br>  #include &lt;cutlist.h&gt; <br>  #include "simplecl.h" <br> <br>  ICutListGraphBuilder  *pCLGraphBuilder  = NULL; <br>  IStandardCutList      *pVideoCL         = NULL; <br>  IStandardCutList      *pAudioCL         = NULL; <br>  IGraphBuilder         *pigb             = NULL; <br>  IMediaControl         *pimc             = NULL; <br>  IMediaEventEx         *pimex            = NULL; <br>  IVideoWindow          *pivw             = NULL; <br> <br>  IFileClip             *pVidFileClip[MAX_CLIPS]; <br>  IFileClip             *pAudFileClip[MAX_CLIPS]; <br>  IAMCutListElement       *pVidCLElem[MAX_CLIPS]; <br>  IAMCutListElement       *pAudCLElem[MAX_CLIPS]; <br> <br>  HRESULT hr; <br> <br>  int nVidElems, nAudElems; <br>  <br>  void SimpleCutList () <br> <br>    { // SimpleCutList // <br> <br>      WCHAR wFile[MAX_PATH];  // file name <br> <br>      // Initialize video and audio file clips and elements to NULL <br>      // so we can easily free objects later. <br>      for (int x = 0; x &lt; MAX_CLIPS; ++x) <br> <br>        {  <br>          pVidFileClip[x] = NULL;  <br>          pAudFileClip[x] = NULL;  <br>            pVidCLElem[x] = NULL;  <br>            pAudCLElem[x] = NULL;  <br>        }; <br> <br>      // Create cutlist graph builder object <br>      hr = CoCreateInstance(CLSID_CutListGraphBuilder, NULL,  <br>                            CLSCTX_INPROC, IID_ICutListGraphBuilder,  <br>                            (void**)&amp;pCLGraphBuilder); <br> <br>      if (FAILED(hr)) <br>        { // CoCreateInstance of CutListGraphBuiler failed <br>          MessageBox(ghApp,  <br>                     "CoCreateInstance of CutListGraphBuiler failed", <br>                     APPLICATIONNAME, MB_OK); <br>          TearDownTheGraph(); <br>          return; <br>        } // CoCreateInstance of CutListGraphBuiler failed <br> <br>      // Create simple (standard) cutlist object for video <br>      hr = CoCreateInstance(CLSID_SimpleCutList, NULL,  <br>                            CLSCTX_INPROC, IID_IStandardCutList,  <br>                            (void**)&amp;pVideoCL); <br>      if (FAILED(hr)) <br>        { // CoCreateInstance of video SimpleCutList failed <br>          MessageBox(ghApp,  <br>                     "CoCreateInstance of video SimpleCutList failed", <br>                     APPLICATIONNAME, MB_OK); <br>          TearDownTheGraph(); <br>          return; <br>        } // CoCreateInstance of video SimpleCutList failed <br> <br>      // Create simple (standard) cutlist object for audio <br>      hr = CoCreateInstance(CLSID_SimpleCutList, NULL,  <br>                            CLSCTX_INPROC, IID_IStandardCutList,  <br>                            (void**)&amp;pAudioCL); <br> <br>      if (FAILED(hr)) <br>        { // CoCreateInstance of audio SimpleCutList failed <br>          MessageBox(ghApp,  <br>                     "CoCreateInstance of audio SimpleCutList failed", <br>                     APPLICATIONNAME, MB_OK); <br>          TearDownTheGraph(); <br>          return; <br>        } // CoCreateInstance of audio SimpleCutList failed <br> <br>      // Create the individual clips and add them to the cutlist <br>      nVidElems = nAudElems = 0; <br>      for (x = 0; x &lt; gTheSet.nNumClips; ++x) <br> <br>        { // Individual clips <br> <br>          MultiByteToWideChar(CP_ACP, 0,  <br>                              gTheSet.List[x].szFilename,  <br>                              -1, wFile, MAX_PATH ); <br> <br>          // Create a video clip object and give it the file and stream  <br>          // to read from. <br>          // SetFileAndStream will fail if we call it from a video clip  <br>          // object and the clip is not a video clip. <br>          hr = CoCreateInstance(CLSID_VideoFileClip, NULL,  <br>                                CLSCTX_INPROC, IID_IFileClip,  <br>                                (void**)&amp;pVidFileClip[nVidElems]); <br> <br>          hr = pVidFileClip[nVidElems]-&gt;SetFileAndStream(wFile, 0); <br> <br>          if (SUCCEEDED(hr)) <br> <br>            { // Create video cut and add the clip (element) to the cutlist <br> <br>              hr = pVidFileClip[nVidElems]-&gt;CreateCut(&amp;pVidCLElem[nVidElems],  <br>                      gTheSet.List[x].start*SCALE,  <br>                      gTheSet.List[x].stop*SCALE,  <br>                      0,  <br>                      (gTheSet.List[x].stop-gTheSet.List[x].start)*SCALE,  <br>                      0); <br> <br>              if (SUCCEEDED(hr)) <br> <br>                { // Add the element to the cutlist <br> <br>                  hr = pVideoCL-&gt;AddElement(pVidCLElem[nVidElems], CL_DEFAULT_TIME, CL_DEFAULT_TIME); <br> <br>                  if (SUCCEEDED(hr)) <br>                    ++nVidElems; <br> <br>                  else <br> <br>                    { // AddElement failed so release associated objects <br> <br>                      HELPER_RELEASE(pVidCLElem[nVidElems]); <br>                      HELPER_RELEASE(pVidFileClip[nVidElems]); <br>                      MessageBox(ghApp, "AddElement (video) failed!", APPLICATIONNAME, MB_OK); <br> <br>                    } // AddElement failed so release associated objects <br> <br>                } // Add the element to the cutlist <br> <br>              else MessageBox(ghApp, "CreateCut (video) failed!", APPLICATIONNAME, MB_OK); <br> <br>            } // Create video cut <br> <br>          else <br> <br>            { // Problems creating video stream <br> <br>              HELPER_RELEASE(pVidFileClip[nVidElems]); <br>              MessageBox(ghApp, "SetFileAndStream (video) failed!", APPLICATIONNAME, MB_OK); <br> <br>            } // Problems creating video stream <br> <br>          // Create an audio clip object and give it the file and stream  <br>          // to read from. <br>          // SetFileAndStream will fail if we call it from an audio clip  <br>          // object and the clip is not an audio clip <br>          hr = CoCreateInstance(CLSID_AudioFileClip, NULL,  <br>                                CLSCTX_INPROC, IID_IFileClip,  <br>                                (void**)&amp;pAudFileClip[nAudElems]); <br> <br>          hr = pAudFileClip[nAudElems]-&gt;SetFileAndStream(wFile, 0); <br> <br>          if (SUCCEEDED(hr)) <br> <br>            { // Create audio cut and add the clip (element) to the cutlist <br> <br>            hr = pAudFileClip[nAudElems]-&gt;CreateCut(&amp;pAudCLElem[nAudElems],  <br>                      gTheSet.List[x].start*SCALE,  <br>                      gTheSet.List[x].stop*SCALE,  <br>                      0,  <br>                      (gTheSet.List[x].stop-gTheSet.List[x].start)*SCALE,  <br>                      0); <br> <br>              if (SUCCEEDED(hr)) <br> <br>                { // Add the element to the cutlist <br> <br>                  hr = pAudioCL-&gt;AddElement(pAudCLElem[nAudElems], <br>                                            CL_DEFAULT_TIME,  <br>                                            CL_DEFAULT_TIME); <br> <br>                  if (SUCCEEDED(hr)) <br>                    ++nAudElems; <br> <br>                  else <br> <br>                    { // AddElement failed so release associated objects <br> <br>                      HELPER_RELEASE(pAudCLElem[nAudElems]); <br>                      HELPER_RELEASE(pAudFileClip[nAudElems]); <br>                      MessageBox(ghApp, "AddElement (audio) failed!", APPLICATIONNAME, MB_OK); <br> <br>                    } // AddElement failed so release associated objects <br> <br>                } // Add the element to the cutlist <br> <br>              else MessageBox(ghApp, "CreateCut (audio) failed!", APPLICATIONNAME, MB_OK); <br> <br>            } // Create audio cut <br> <br>          else <br>           <br>            { // Problems creating audio stream <br> <br>              HELPER_RELEASE(pAudFileClip[nAudElems]); <br>              MessageBox(ghApp, "SetFileAndStream (audio) failed!", APPLICATIONNAME, MB_OK); <br> <br>            } // Problems creating audio stream <br> <br>        } // Individual clips <br> <br>      // Add the video cutlist to the filter graph <br>      hr = pCLGraphBuilder-&gt;AddCutList(pVideoCL, NULL); <br> <br>      if (FAILED(hr)) // AddCutList (video) failed <br>          MessageBox(ghApp, "AddCutList (video) failed", APPLICATIONNAME, MB_OK); <br> <br>      // Add the audio cutlist to the filter graph <br>      hr = pCLGraphBuilder-&gt;AddCutList(pAudioCL, NULL); <br> <br>      if (FAILED(hr)) // AddCutList (audio) failed <br>          MessageBox(ghApp, "AddCutList (audio) failed", APPLICATIONNAME, MB_OK); <br> <br>      if ((!pVideoCL) &amp;&amp; (!pAudioCL)) <br> <br>        { // Clean up <br> <br>          TearDownTheGraph(); <br>          return; <br> <br>        } // Clean up <br> <br>      // Let the filter graph manager construct the the appropriate graph  <br>      // automatically <br>      hr = pCLGraphBuilder-&gt;Render(); <br> <br>      if (FAILED(hr)) <br>        { // Problems rendering the graph <br>          if (!AMGetErrorText(hr, gszScratch, 2048)) <br>            MessageBox(ghApp, "Problems rendering the graph!", APPLICATIONNAME, MB_OK); <br>          else  <br>            MessageBox(ghApp, gszScratch, APPLICATIONNAME, MB_OK); <br>          TearDownTheGraph(); <br>          return; <br>        } // Problems rendering the graph <br> <br>      // Retrieve the filter graph and useful interfaces <br>      hr = pCLGraphBuilder-&gt;GetFilterGraph(&amp;pigb); <br> <br>      if (FAILED(hr)) <br>        { // Problems retrieving the graph pointer <br>          if (!AMGetErrorText(hr, gszScratch, 2048)) <br>            MessageBox(ghApp, "Problems retrieving the graph pointer!", APPLICATIONNAME, MB_OK); <br>          else  <br>            MessageBox(ghApp, gszScratch, APPLICATIONNAME, MB_OK); <br>          TearDownTheGraph(); <br>          return; <br>        } // Problems retrieving the graph pointer <br> <br>      // QueryInterface for some basic interfaces <br>      pigb-&gt;QueryInterface(IID_IMediaControl, (void **)&amp;pimc); <br>      pigb-&gt;QueryInterface(IID_IMediaEventEx, (void **)&amp;pimex); <br>      pigb-&gt;QueryInterface(IID_IVideoWindow, (void **)&amp;pivw); <br> <br>      // Decrement the ref count on the filter graph <br>      pigb-&gt;Release(); <br> <br>      // Prepare to play in the main application window's client area <br> <br>      RECT rc; <br>      GetClientRect(ghApp, &amp;rc); <br>      hr = pivw-&gt;put_Owner((OAHWND)ghApp); <br>      hr = pivw-&gt;put_WindowStyle(WS_CHILD|WS_CLIPSIBLINGS); <br>      hr = pivw-&gt;SetWindowPosition(rc.left, rc.top, rc.right, rc.bottom); <br> <br>      // Have the graph signal event via window callbacks for performance <br>      pimex-&gt;SetNotifyWindow((OAHWND)ghApp, WM_GRAPHNOTIFY, 0); <br> <br>      // Run the graph if RenderFile succeeded <br>      pimc-&gt;Run(); <br> <br>    } // SimpleCutList // <br> <br> void TearDownTheGraph (void) <br> <br>    { // TearDownTheGraph // <br> <br>      if (pimc) <br>        pimc-&gt;Stop(); <br> <br>      if (pivw) <br> <br>        { // Hide the playback window first thing <br> <br>          pivw-&gt;put_Visible(OAFALSE); <br>          pivw-&gt;put_Owner(NULL); <br> <br>        } // <br> <br>      HELPER_RELEASE(pimex); <br>      HELPER_RELEASE(pimc); <br>      HELPER_RELEASE(pivw); <br> <br>      // Remove the video cutlist from the filter graph to free resources <br>      if (pCLGraphBuilder &amp;&amp; pVideoCL) <br>        pCLGraphBuilder-&gt;RemoveCutList(pVideoCL); <br> <br>      // Remove the audio cutlist from the filter graph to free resources <br>      if (pCLGraphBuilder &amp;&amp; pAudioCL) <br>        pCLGraphBuilder-&gt;RemoveCutList(pAudioCL); <br> <br>      for (int x = 0; x &lt; nAudElems; ++x) <br> <br>        { // Release audio objects <br> <br>          HELPER_RELEASE(pAudCLElem[x]); <br>          HELPER_RELEASE(pAudFileClip[x]); <br> <br>        } // Release audio objects <br> <br>      for (x = 0; x &lt; nVidElems; ++x) <br> <br>        { // Release video objects <br> <br>          HELPER_RELEASE(pVidCLElem[x]); <br>          HELPER_RELEASE(pVidFileClip[x]); <br> <br>        } // Release video objects <br> <br>      HELPER_RELEASE(pVideoCL); <br>      HELPER_RELEASE(pAudioCL);       <br>      HELPER_RELEASE(pCLGraphBuilder); <br> <br>    } // TearDownTheGraph // <br> <br>  BOOL CALLBACK DialogProc (HWND h, UINT m, WPARAM w, LPARAM l) <br> <br>    { // DialogProc // <br> <br>      switch(m) <br> <br>        { // Msg handling <br> <br>          case WM_INITDIALOG: <br>            if (wDlgRes == IDD_MEDIATIMES) <br>              SetFocus(GetDlgItem(h, IDC_TRIMIN2)); <br>            else return TRUE; <br>            break; <br> <br>          case WM_COMMAND: <br> <br>            switch(w) <br> <br>              { // Command msg handling <br> <br>                case IDOKTIMES: <br> <br>                  gTheSet.List[gTheSet.nNumClips].start = GetDlgItemInt(h, IDC_TRIMIN2, NULL, FALSE); <br>                  gTheSet.List[gTheSet.nNumClips].stop = GetDlgItemInt(h, IDC_TRIMOUT2, NULL, FALSE); <br> <br>                  EndDialog(h,1); <br>                  break; <br> <br>                case IDOK: <br>                  EndDialog(h,1); <br>                  break; <br> <br>                case IDCANCEL: <br>                  EndDialog(h,0); <br>                  break; <br> <br>              } // Command msg handling <br> <br>            break; <br> <br>        } // Msg handling <br> <br>      return 0; <br> <br>    } // DialogProc // <br> <br>  BOOL GetClipFileName (LPSTR szName) <br> <br>    {   // GetClipFileName // <br> <br>        OPENFILENAME ofn; <br> <br>        ofn.lStructSize       = sizeof(OPENFILENAME); <br>        ofn.hwndOwner         = ghApp; <br>        ofn.lpstrFilter       = NULL; <br>        ofn.lpstrFilter       = "AVI/WAV (*.avi; *.wav)\0*.avi;*.wav\0\0\0"; <br>        ofn.lpstrCustomFilter = NULL; <br>        ofn.nFilterIndex      = 1; <br>        *szName               = 0; <br>        ofn.lpstrFile         = szName; <br>        ofn.nMaxFile          = MAX_PATH; <br>        ofn.lpstrInitialDir   = NULL; <br>        ofn.lpstrTitle        = NULL; <br>        ofn.lpstrFileTitle    = NULL; <br>        ofn.lpstrDefExt       = "AVI;WAV"; <br>        ofn.Flags             = OFN_FILEMUSTEXIST | OFN_READONLY | OFN_PATHMUSTEXIST; <br> <br>        return GetOpenFileName((LPOPENFILENAME)&amp;ofn); <br> <br>    }   // GetClipFileName // <br> <br>  LRESULT CALLBACK WndMainProc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) <br> <br>    { // WndMainProc // <br> <br>      LONG evCode; <br>      LONG evParam1; <br>      LONG evParam2; <br> <br>      switch(message) <br> <br>        { // Window msgs handling <br> <br>          case WM_COMMAND: <br> <br>            switch(wParam) <br> <br>              {  // Program menu option <br> <br>                case IDM_ADDFILE: <br> <br>                  if (GetClipFileName(gTheSet.List[gTheSet.nNumClips].szFilename)) <br> <br>                    { // Add file <br> <br>                      TCHAR szTitleBar[200]; <br> <br>                      DialogBox(ghInst, MAKEINTRESOURCE(wDlgRes = IDD_MEDIATIMES), ghApp, (DLGPROC)DialogProc); <br>                      gTheSet.nNumClips = gTheSet.nNumClips + 1; <br>                      wsprintf(szTitleBar, "SimpleCutList - %d clips(s) added.", gTheSet.nNumClips); <br>                      SetWindowText(ghApp, szTitleBar); <br> <br>                    } // Add file <br> <br>                  break; <br> <br>                case IDM_RUN: <br>                  if (gTheSet.nNumClips &gt; 1) <br>                    SimpleCutList(); <br>                  else <br>                    DialogBox(ghInst, MAKEINTRESOURCE(wDlgRes = IDD_LESSTHAN2), ghApp, (DLGPROC)DialogProc); <br>                  break; <br> <br>                case ID_FILE_ABOUT: <br>                  DialogBox(ghInst, MAKEINTRESOURCE(wDlgRes = IDD_ABOUT), ghApp, (DLGPROC)DialogProc); <br>                  break; <br> <br>                case ID_FILE_EXIT: <br>                  if (gTheSet.nNumClips) <br>                    TearDownTheGraph(); <br>                  PostQuitMessage(0); <br>                  break; <br> <br>              }  // Program menu option <br> <br>            break; <br> <br>          case WM_GRAPHNOTIFY: <br> <br>            if (!pimex) <br>              break; <br> <br>            while (SUCCEEDED(pimex-&gt;GetEvent(&amp;evCode, &amp;evParam1, &amp;evParam2, 0))) <br> <br>              { // Spin through the events <br> <br>                hr = pimex-&gt;FreeEventParams(evCode, evParam1, evParam2); <br> <br>                if ((EC_COMPLETE == evCode) || (EC_USERABORT == evCode)) <br> <br>                  { // Finished <br> <br>                    TearDownTheGraph(); <br> <br>                    if (EC_USERABORT == evCode) <br>                      gTheSet.nNumClips = 0; <br> <br>                    break; <br> <br>                  } // Finished <br>               <br>              } // Spin through the events <br> <br>            break; <br> <br>          case WM_DESTROY: <br>            PostQuitMessage(0); <br>            break; <br> <br>          default: <br>            return DefWindowProc(hWnd, message, wParam, lParam); <br>           <br>        } // Window msgs handling <br> <br>      return FALSE; <br> <br>      }  // WndMainProc // <br> <br>  int PASCAL WinMain(HINSTANCE hInstC, HINSTANCE hInstP, LPSTR lpCmdLine, int nCmdShow) <br> <br>    { // WinMain // <br>   <br>      MSG msg; <br>      WNDCLASS wc; <br> <br>      // OLE subsystem requires applications to initialize things first! <br>      CoInitialize(NULL); <br> <br>      ZeroMemory(&amp;wc, sizeof wc); <br>      wc.lpfnWndProc = WndMainProc; <br>      ghInst = wc.hInstance = hInstC; <br>      wc.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH); <br>      wc.lpszClassName = CLASSNAME; <br>      wc.lpszMenuName = MAKEINTRESOURCE(IDR_MENU1); <br>      wc.hCursor = LoadCursor(NULL, IDC_ARROW); <br>      wc.hIcon = LoadIcon(hInstC, MAKEINTRESOURCE(IDI_CUTLIST)); <br>      RegisterClass(&amp;wc); <br> <br>      RECT rc; <br> <br>      GetWindowRect(GetDesktopWindow(), &amp;rc); <br>      rc.right &gt;&gt;= 1; <br>      rc.bottom &gt;&gt;= 1; <br> <br>      ghApp = CreateWindow(CLASSNAME, <br>      APPLICATIONNAME, <br>      WS_OVERLAPPEDWINDOW, <br>      rc.right-200, <br>      rc.bottom-200, <br>      400, <br>      400, <br>      0, <br>      0, <br>      ghInst, <br>      0); <br>       <br>      ShowWindow(ghApp, SW_NORMAL); <br>      UpdateWindow(ghApp); <br> <br>      ZeroMemory(&amp;gTheSet, sizeof gTheSet); <br> <br>      while (GetMessage(&amp;msg,NULL,0,0)) <br> <br>      {  // Message loop <br> <br>         TranslateMessage(&amp;msg); <br>         DispatchMessage(&amp;msg); <br> <br>      }  // Message loop <br> <br>      // Finished with OLE subsystem <br>      CoUninitialize(); <br> <br>      return msg.wParam; <br> <br>  } // WinMain // </code></pre>
<p>&nbsp;</p></body>
</HTML>
