<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SAMPVID.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2918"></a>SAMPVID.H</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>#ifndef __SAMPVID__ <br>#define __SAMPVID__ <br> <br>DEFINE_GUID(CLSID_SampleRenderer, <br>0x4d4b1600, 0x33ac, 0x11cf, 0xbf, 0x30, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a); <br> <br>DEFINE_GUID(CLSID_SampleQuality, <br>0xdb76d7f0, 0x97cc, 0x11cf, 0xa0, 0x96, 0x00, 0x80, 0x5f, 0x6c, 0xab, 0x82); <br> <br>// Forward declarations <br> <br>class CVideoRenderer; <br>class CVideoInputPin; <br>class CControlVideo; <br>class CVideoText; <br> <br> <br>// This is the video renderer window it supports IBasicVideo and IVideoWindow <br>// by inheriting from the CBaseControlWindow and CbaseControlVideo classes. <br>// Those classes leave a few PURE virtual methods that we have to override to <br>// complete their implementation such as the handling of source and target <br>// rectangles. The class also looks after creating the window with a custom <br>// clip region in the shape of the word ActiveX (only applies to Windows/NT) <br> <br>class CVideoText : public CBaseControlWindow, public CBaseControlVideo <br>{ <br>protected: <br> <br>    CVideoRenderer *m_pRenderer;        // Owning sample renderer object <br>    SIZE m_Size;                        // Size of the masking bitmap <br> <br>public: <br> <br>    CVideoText(TCHAR *pName,                 // Object description <br>               LPUNKNOWN pUnk,               // Normal COM ownership <br>               HRESULT *phr,                 // OLE failure code <br>               CCritSec *pInterfaceLock,     // Main critical section <br>               CVideoRenderer *pRenderer);   // Delegates locking to <br> <br>    virtual ~CVideoText(); <br>    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv); <br> <br>    // Pure virtual methods for the IBasicVideo interface <br> <br>    HRESULT IsDefaultTargetRect(); <br>    HRESULT SetDefaultTargetRect(); <br>    HRESULT SetTargetRect(RECT *pTargetRect); <br>    HRESULT GetTargetRect(RECT *pTargetRect); <br>    HRESULT IsDefaultSourceRect(); <br>    HRESULT SetDefaultSourceRect(); <br>    HRESULT SetSourceRect(RECT *pSourceRect); <br>    HRESULT GetSourceRect(RECT *pSourceRect); <br>    HRESULT GetStaticImage(long *pBufferSize,long *pDIBImage); <br> <br>    // Prepare the window with a text region <br> <br>    void InitRenderer(TCHAR *pStringName); <br>    HRESULT InitWindowRegion(TCHAR *pStringName); <br>    HFONT CreateVideoFont(); <br>    RECT GetDefaultRect(); <br>    VIDEOINFOHEADER *GetVideoFormat(); <br> <br>    // Overriden from CBaseWindow return our window and class styles <br> <br>    LPTSTR GetClassWindowStyles(DWORD *pClassStyles, <br>                                DWORD *pWindowStyles, <br>                                DWORD *pWindowStylesEx); <br> <br>    // Method that gets all the window messages <br> <br>    LRESULT OnReceiveMessage(HWND hwnd,          // Window handle <br>                             UINT uMsg,          // Message ID <br>                             WPARAM wParam,      // First parameter <br>                             LPARAM lParam);     // Other parameter <br>}; // CVideoText <br> <br> <br>// This class supports the renderer input pin. We have to override the base <br>// class input pin because we provide our own special allocator which hands <br>// out buffers based on GDI DIBSECTIONs. We have an extra limitation which <br>// is that we only connect to filters that agree to use our allocator. This <br>// stops us from connecting to the tee for example. The extra work required <br>// to use someone elses allocator and select the buffer into a bitmap and <br>// that into the HDC is not great but would only really confuse this sample <br> <br>class CVideoInputPin : public CRendererInputPin <br>{ <br>    CVideoRenderer *m_pRenderer;        // The renderer that owns us <br>    CCritSec *m_pInterfaceLock;         // Main filter critical section <br> <br>public: <br> <br>    // Constructor <br> <br>    CVideoInputPin( <br>        TCHAR *pObjectName,             // Object string description <br>        CVideoRenderer *pRenderer,      // Used to delegate locking <br>        CCritSec *pInterfaceLock,       // Main critical section <br>        HRESULT *phr,                   // OLE failure return code <br>        LPCWSTR pPinName);              // This pins identification <br> <br>    // Manage our DIBSECTION video allocator <br>    STDMETHODIMP GetAllocator(IMemAllocator **ppAllocator); <br>    STDMETHODIMP NotifyAllocator(IMemAllocator *pAllocator,BOOL bReadOnly); <br> <br>}; // CVideoInputPin <br> <br> <br>// This is the COM object that represents a simple rendering filter. It <br>// supports IBaseFilter and IMediaFilter and a single input stream (pin) <br>// The classes that support these interfaces have nested scope NOTE the <br>// nested class objects are passed a pointer to their owning renderer <br>// when they are created but they should not use it during construction <br> <br>class CVideoRenderer : public ISpecifyPropertyPages, public CBaseVideoRenderer <br>{ <br>public: <br> <br>    // Constructor and destructor <br> <br>    static CUnknown * WINAPI CreateInstance(LPUNKNOWN, HRESULT *); <br>    CVideoRenderer(TCHAR *pName,LPUNKNOWN pUnk,HRESULT *phr); <br>    ~CVideoRenderer(); <br> <br>    // Implement the ISpecifyPropertyPages interface <br> <br>    DECLARE_IUNKNOWN <br>    STDMETHODIMP NonDelegatingQueryInterface(REFIID, void **); <br>    STDMETHODIMP GetPages(CAUUID *pPages); <br> <br>    CBasePin *GetPin(int n); <br> <br>    // Override these from the filter and renderer classes <br> <br>    void PrepareRender(); <br>    HRESULT Active(); <br>    HRESULT BreakConnect(); <br>    HRESULT CompleteConnect(IPin *pReceivePin); <br>    HRESULT SetMediaType(const CMediaType *pmt); <br>    HRESULT CheckMediaType(const CMediaType *pmtIn); <br>    HRESULT CheckVideoType(const VIDEOINFO *pDisplay,const VIDEOINFO *pInput); <br>    HRESULT UpdateFormat(VIDEOINFO *pVideoInfo); <br>    HRESULT DoRenderSample(IMediaSample *pMediaSample); <br>    void OnReceiveFirstSample(IMediaSample *pMediaSample); <br> <br>public: <br> <br>    CImageAllocator m_ImageAllocator;   // Our DIBSECTION allocator <br>    CVideoInputPin m_InputPin;          // IPin based interfaces <br>    CImageDisplay m_Display;            // Manages the video display type <br>    CMediaType m_mtIn;                  // Source connection media type <br>    CVideoText m_VideoText;             // Does the actual video rendering <br>    CImagePalette m_ImagePalette;       // Looks after managing a palette <br>    CDrawImage m_DrawImage;             // Does the actual image drawing <br>    SIZE m_VideoSize;                   // Size of the current video stream <br> <br>}; // CVideoRenderer <br> <br>#endif // __SAMPVID__ <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
