<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>VIDEOTXT.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2919"></a>VIDEOTXT.CPP</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>// Sample ActiveMovie video renderer <br> <br>#include &lt;streams.h&gt; <br>#include &lt;sampvid.h&gt; <br>#include &lt;vidprop.h&gt; <br>#include &lt;tchar.h&gt; <br> <br>// This is a sample renderer that displays video in a window. What is special <br>// about that is that the window is non rectangular, the region it has is a <br>// word (whatever VideoString is defined to be as shown below). Using various <br>// GDI methods we create a region from the word and select it into our window <br>// Windows will then look after clipping and mouse interactions, all we have <br>// to do is handle the painting and drawing. This sample can work if it uses <br>// either its own allocator (the preferred approach) or a source filter's <br>// (like when it connects to the tee filter). It has separate code paths to <br>// handle the drawing depending whose allocator it's using on this connection <br> <br>TCHAR VideoString[] = TEXT("ActiveX"); <br> <br> <br>// <br>// Constructor <br>// <br>CVideoText::CVideoText(TCHAR *pName,                 // Object description <br>                       LPUNKNOWN pUnk,               // Normal COM ownership <br>                       HRESULT *phr,                 // OLE failure code <br>                       CCritSec *pInterfaceLock,     // Main critical section <br>                       CVideoRenderer *pRenderer) :  // Delegates locking to <br> <br>    CBaseControlVideo(pRenderer,pInterfaceLock,pName,pUnk,phr), <br>    CBaseControlWindow(pRenderer,pInterfaceLock,pName,pUnk,phr), <br>    m_pRenderer(pRenderer) <br>{ <br>    PrepareWindow(); <br>    InitWindowRegion(VideoString); <br> <br>} // (Constructor) <br> <br> <br>// <br>// Destructor <br>// <br>CVideoText::~CVideoText() <br>{ <br>    InactivateWindow(); <br>    DoneWithWindow(); <br> <br>} // (Destructor) <br> <br> <br>// <br>// NonDelegatingQueryInterface <br>// <br>// Overriden to say what interfaces we support and where <br>// <br>STDMETHODIMP CVideoText::NonDelegatingQueryInterface(REFIID riid,void **ppv) <br>{ <br>    CheckPointer(ppv,E_POINTER); <br>    if (riid == IID_IVideoWindow) { <br>        return CBaseVideoWindow::NonDelegatingQueryInterface(riid,ppv); <br>    } else { <br>        ASSERT(riid == IID_IBasicVideo); <br>        return CBaseBasicVideo::NonDelegatingQueryInterface(riid,ppv); <br>    } <br>} <br> <br> <br>// <br>// CreateVideoFont <br>// <br>// This is called when we initialise the mask bitmap used when drawing. We <br>// create and install a larger font into the device context. The font used <br>// is 72 point Arial. It doesn't matter that the width of the letters are <br>// bigger than the video as we can stretch the video during the draw. This <br>// makes us go slower but it looks good and the quality management in the <br>// base renderer class should take care of reducing the source frame rate <br>// <br>HFONT CVideoText::CreateVideoFont() <br>{ <br>    LOGFONT lf; <br> <br>    int iLogPelsY = GetDeviceCaps(m_hdc,LOGPIXELSY); <br>    ZeroMemory(&amp;lf,sizeof(LOGFONT)); <br> <br>    lf.lfHeight = (-72 * iLogPelsY) / 72; <br>    lf.lfWeight = 700; <br>    lf.lfCharSet = ANSI_CHARSET; <br>    lf.lfOutPrecision = OUT_DEFAULT_PRECIS; <br>    lf.lfClipPrecision = CLIP_DEFAULT_PRECIS; <br>    lf.lfQuality = PROOF_QUALITY; <br>    lf.lfPitchAndFamily = DEFAULT_PITCH | FF_SWISS; <br>    _tcscpy(lf.lfFaceName,TEXT("Arial")); <br> <br>    return CreateFontIndirect(&amp;lf); <br> <br>} // CreateVideoFont <br> <br> <br>// <br>// InitWindowRegion <br>// <br>// We display the video in a window that has a region selected into it that <br>// matches the word we are passed in. By doing this we let Windows manage <br>// all the clipping and mouse technology. The trick is in creating a region <br>// that matches the word, this is done by using paths. We create a path for <br>// a temporary HDC, draw the word and then end the path. After which we can <br>// then ask Windows for a region that describes that path. That gives us a <br>// region for the outside of the word so we not it to get the word region <br>// <br>HRESULT CVideoText::InitWindowRegion(TCHAR *pStringName) <br>{ <br>    OSVERSIONINFO VersionInfo; <br>    VersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO); <br>    EXECUTE_ASSERT(GetVersionEx(&amp;VersionInfo)); <br> <br>    // Set a window region according to the OS capabilities <br> <br>    if ((VersionInfo.dwPlatformId &amp; VER_PLATFORM_WIN32_NT) == 0) { <br>        m_Size.cx = 320; <br>        m_Size.cy = 240; <br>        return NOERROR; <br>    } <br> <br>    // Get the text extents the word passed in will require based on the <br>    // font and bitmap selected in the current device context. For it to <br>    // be displayed in a different font it must be selected into the HDC <br> <br>    HDC hdc = CreateCompatibleDC(m_hdc); <br>    HFONT hFont = CreateVideoFont(); <br>    SelectObject(hdc,hFont); <br> <br>    GetTextExtentPoint32((HDC) hdc,             // The output device context <br>                         pStringName,           // The string we'll be using <br>                         lstrlen(pStringName),  // Number of characters in it <br>                         (LPSIZE) &amp;m_Size);     // Filled in with the extents <br> <br>    // Create a bitmap that matches the current format <br> <br>    HBITMAP hMaskBitmap = CreateCompatibleBitmap(hdc,m_Size.cx,m_Size.cy); <br>    if (hMaskBitmap == NULL) { <br>        ASSERT(hMaskBitmap); <br>        return E_UNEXPECTED; <br>    } <br> <br>    // Select the monochrome bitmap into the device context <br> <br>    HBITMAP hBitmap = (HBITMAP) SelectObject(hdc,hMaskBitmap); <br>    EXECUTE_ASSERT(BeginPath(hdc)); <br> <br>    // Draw the string into the monochrome bitmap <br> <br>    ExtTextOut((HDC) hdc,               // Target device context <br>               (int) 0,                 // x coordinate reference <br>               (int) 0,                 // Likewise y coordinate <br>               (DWORD) 0,               // No special flags to set <br>               NULL,                    // No clipping rectangle <br>               pStringName,             // Pointer to text words <br>               lstrlen(pStringName),    // Number of characters <br>               NULL);                   // Intercharacter spacing <br> <br>    EXECUTE_ASSERT(EndPath(hdc)); <br>    HRGN hOutside = PathToRegion(hdc); <br>    HRGN hFullWindow = CreateRectRgn(0,0,m_Size.cx,m_Size.cy); <br>    HRGN hWordRegion = CreateRectRgn(0,0,1,1); <br>    CombineRgn(hWordRegion,hFullWindow,hOutside,RGN_DIFF); <br>    SetWindowRgn(m_hwnd,hWordRegion,TRUE); <br> <br>    // Clear up the regions we created <br> <br>    DeleteObject(hWordRegion); <br>    DeleteObject(hOutside); <br>    DeleteObject(hFullWindow); <br> <br>    // Delete the HDC and text bitmap <br> <br>    SelectObject(hdc,hBitmap); <br>    HFONT hDefault = (HFONT) GetStockObject(SYSTEM_FONT); <br>    SelectObject(hdc,hDefault); <br>    DeleteObject(hFont); <br>    DeleteObject(hMaskBitmap); <br>    DeleteDC(hdc); <br> <br>    return NOERROR; <br> <br>} // InitWindowRegion <br> <br> <br>// <br>// GetClassWindowStyles <br>// <br>// When we call PrepareWindow in our constructor it will call this method as <br>// it is going to create the window to get our window and class styles. The <br>// return code is the class name and must be allocated in static storage. We <br>// specify a normal window during creation although the window styles as well <br>// as the extended styles may be changed by the application via IVideoWindow <br>// <br>LPTSTR CVideoText::GetClassWindowStyles(DWORD *pClassStyles, <br>                                        DWORD *pWindowStyles, <br>                                        DWORD *pWindowStylesEx) <br>{ <br>    OSVERSIONINFO VersionInfo; <br>    VersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO); <br>    EXECUTE_ASSERT(GetVersionEx(&amp;VersionInfo)); <br> <br>    // Default styles for Windows NT systems <br> <br>    *pClassStyles = CS_HREDRAW | CS_VREDRAW | CS_BYTEALIGNCLIENT; <br>    *pWindowStyles = WS_POPUP | WS_CLIPCHILDREN; <br>    *pWindowStylesEx = (DWORD) 0; <br> <br>    // Make a normal window on Win95 systems <br> <br>    if ((VersionInfo.dwPlatformId &amp; VER_PLATFORM_WIN32_NT) == 0) { <br>        *pWindowStyles = WS_POPUP | WS_CAPTION | WS_CLIPCHILDREN; <br>    } <br>    return TEXT("VideoTextRenderer"); <br> <br>} // GetClassWindowStyles <br> <br> <br>// <br>// GetDefaultRect <br>// <br>// Return the default window rectangle <br>// <br>RECT CVideoText::GetDefaultRect() <br>{ <br>    RECT DefaultRect = {0,0,m_Size.cx,m_Size.cy}; <br>    ASSERT(m_hwnd); <br>    ASSERT(m_hdc); <br>    return DefaultRect; <br> <br>} // GetDefaultRect <br> <br> <br>// <br>// OnReceiveMessage <br>// <br>// This is the derived class window message handler methods <br>// <br>LRESULT CVideoText::OnReceiveMessage(HWND hwnd,          // Window handle <br>                                     UINT uMsg,          // Message ID <br>                                     WPARAM wParam,      // First parameter <br>                                     LPARAM lParam)      // Other parameter <br>{ <br>    IBaseFilter *pFilter = NULL; <br>    RECT ClientRect; <br> <br>    // Blank out the window background <br> <br>    if (uMsg == WM_ERASEBKGND) { <br>        EXECUTE_ASSERT(GetClientRect(m_hwnd,&amp;ClientRect)); <br>        HBRUSH hBrush = CreateSolidBrush(RGB(0,0,0)); <br>        EXECUTE_ASSERT(FillRect(m_hdc,&amp;ClientRect,hBrush)); <br>        EXECUTE_ASSERT(DeleteObject(hBrush)); <br>        return (LRESULT) 0; <br>    } <br> <br>    // Handle WM_CLOSE by aborting the playback <br> <br>    if (uMsg == WM_CLOSE) { <br>        m_pRenderer-&gt;NotifyEvent(EC_USERABORT,0,0); <br>        DoShowWindow(SW_HIDE); <br>        return CBaseWindow::OnClose(); <br>    } <br> <br>    // We pass on WM_ACTIVATEAPP messages to the filtergraph so that the <br>    // IVideoWindow plug in distributor can switch us out of fullscreen <br>    // mode where appropriate. These messages may also be used by the <br>    // resource manager to keep track of which renderer has the focus <br> <br>    if (uMsg == WM_ACTIVATEAPP) { <br>        NOTE1("Notification of EC_ACTIVATE (%d)",(BOOL) wParam); <br>        m_pRenderer-&gt;QueryInterface(IID_IBaseFilter,(void **) &amp;pFilter); <br>        m_pRenderer-&gt;NotifyEvent(EC_ACTIVATE,wParam,(LPARAM) pFilter); <br>        pFilter-&gt;Release(); <br>        return (LRESULT) 0; <br>    } <br> <br>    // Treat clicks on text as requests to move window <br> <br>    if (uMsg == WM_NCHITTEST) { <br>        LRESULT Result = DefWindowProc(hwnd,uMsg,wParam,lParam); <br>        if (Result == HTCLIENT) { <br>            Result = HTCAPTION; <br>        } <br>        return Result; <br>    } <br> <br>    // The base class that implements IVideoWindow looks after a flag <br>    // that says whether or not the cursor should be hidden. If so we <br>    // hide the cursor and return (LRESULT) 1. Otherwise we pass to <br>    // the DefWindowProc to show the cursor as normal. This is used <br>    // when our window is made fullscreen to imitate the Modex filter <br> <br>    if (uMsg == WM_SETCURSOR) { <br>        if (IsCursorHidden() == TRUE) { <br>            SetCursor(NULL); <br>            return (LRESULT) 1; <br>        } <br>    } <br> <br>    // When we detect a display change we send an EC_DISPLAY_CHANGED <br>    // message along with our input pin. The filtergraph will stop <br>    // everyone and reconnect our input pin. When being reconnected <br>    // we can then accept the media type that matches the new display <br>    // mode since we may no longer be able to draw the current format <br> <br>    if (uMsg == WM_DISPLAYCHANGE) { <br>        m_pRenderer-&gt;m_Display.RefreshDisplayType(NULL); <br>        m_pRenderer-&gt;OnDisplayChange(); <br>        NOTE("Sent EC_DISPLAY_CHANGED event"); <br>        return (LRESULT) 0; <br>    } <br>    return CBaseWindow::OnReceiveMessage(hwnd,uMsg,wParam,lParam); <br> <br>} // OnReceiveMessage <br> <br> <br>// <br>// SetDefaultTargetRect <br>// <br>// This is called when we reset the default target rectangle <br>// <br>HRESULT CVideoText::SetDefaultTargetRect() <br>{ <br>    VIDEOINFOHEADER *pVideoInfo = (VIDEOINFOHEADER *) m_pRenderer-&gt;m_mtIn.Format(); <br>    BITMAPINFOHEADER *pHeader = HEADER(pVideoInfo); <br>    RECT TargetRect = {0,0,m_Size.cx,m_Size.cy}; <br>    m_pRenderer-&gt;m_DrawImage.SetTargetRect(&amp;TargetRect); <br>    return NOERROR; <br> <br>} // SetDefaultTargetRect <br> <br> <br>// <br>// IsDefaultTargetRect <br>// <br>// Return S_OK if using the default target otherwise S_FALSE <br>// <br>HRESULT CVideoText::IsDefaultTargetRect() <br>{ <br>    RECT TargetRect; <br> <br>    VIDEOINFOHEADER *pVideoInfo = (VIDEOINFOHEADER *) m_pRenderer-&gt;m_mtIn.Format(); <br>    BITMAPINFOHEADER *pHeader = HEADER(pVideoInfo); <br>    m_pRenderer-&gt;m_DrawImage.GetTargetRect(&amp;TargetRect); <br> <br>    // Check the destination matches the initial client area <br> <br>    if (TargetRect.left != 0 || TargetRect.top != 0 || <br>            TargetRect.right != m_Size.cx || <br>                TargetRect.bottom != m_Size.cy) { <br>                    return S_FALSE; <br>    } <br>    return S_OK; <br> <br>} // IsDefaultTargetRect <br> <br> <br>// <br>// SetTargetRect <br>// <br>// This is called to set the target rectangle in the video window, it will be <br>// called whenever a WM_SIZE message is retrieved from the message queue. We <br>// simply store the rectangle and use it later when we do the drawing calls <br>// <br>HRESULT CVideoText::SetTargetRect(RECT *pTargetRect) <br>{ <br>    m_pRenderer-&gt;m_DrawImage.SetTargetRect(pTargetRect); <br>    return NOERROR; <br> <br>} // SetTargetRect <br> <br> <br>// <br>// GetTargetRect <br>// <br>// Return the current destination rectangle <br>// <br>HRESULT CVideoText::GetTargetRect(RECT *pTargetRect) <br>{ <br>    ASSERT(pTargetRect); <br>    m_pRenderer-&gt;m_DrawImage.GetTargetRect(pTargetRect); <br>    return NOERROR; <br> <br>} // GetTargetRect <br> <br> <br>// <br>// SetDefaultSourceRect <br>// <br>// This is called when we reset the default source rectangle <br>// <br>HRESULT CVideoText::SetDefaultSourceRect() <br>{ <br>    SIZE VideoSize = m_pRenderer-&gt;m_VideoSize; <br>    RECT SourceRect = {0,0,VideoSize.cx,VideoSize.cy}; <br>    m_pRenderer-&gt;m_DrawImage.SetSourceRect(&amp;SourceRect); <br>    return NOERROR; <br> <br>} // SetDefaultSourceRect <br> <br> <br>// <br>// IsDefaultSourceRect <br>// <br>// Return S_OK if using the default source otherwise S_FALSE <br>// <br>HRESULT CVideoText::IsDefaultSourceRect() <br>{ <br>    RECT SourceRect; <br> <br>    // Does the source match the native video size <br> <br>    SIZE VideoSize = m_pRenderer-&gt;m_VideoSize; <br>    CAutoLock cWindowLock(&amp;m_WindowLock); <br>    m_pRenderer-&gt;m_DrawImage.GetSourceRect(&amp;SourceRect); <br> <br>    // Check the coordinates match the video dimensions <br> <br>    if (SourceRect.right == VideoSize.cx) { <br>        if (SourceRect.bottom == VideoSize.cy) { <br>            if (SourceRect.left == 0) { <br>                if (SourceRect.top == 0) { <br>                    return S_OK; <br>                } <br>            } <br>        } <br>    } <br>    return S_FALSE; <br> <br>} // IsDefaultSourceRect <br> <br> <br>// <br>// SetSourceRect <br>// <br>// This is called when we want to change the section of the image to draw. We <br>// use this information in the drawing operation calls later on. We must also <br>// see if the source and destination rectangles have the same dimensions. If <br>// not we must stretch during the rendering rather than a direct pixel copy <br>// <br>HRESULT CVideoText::SetSourceRect(RECT *pSourceRect) <br>{ <br>    m_pRenderer-&gt;m_DrawImage.SetSourceRect(pSourceRect); <br>    return NOERROR; <br> <br>} // SetSourceRect <br> <br> <br>// <br>// GetSourceRect <br>// <br>// Return the current source rectangle <br>// <br>HRESULT CVideoText::GetSourceRect(RECT *pSourceRect) <br>{ <br>    ASSERT(pSourceRect); <br>    m_pRenderer-&gt;m_DrawImage.GetSourceRect(pSourceRect); <br>    return NOERROR; <br> <br>} // GetSourceRect <br> <br> <br>// <br>// GetStaticImage <br>// <br>// Return a copy of the current image in the video renderer <br>// <br>HRESULT CVideoText::GetStaticImage(long *pBufferSize,long *pDIBImage) <br>{ <br>    NOTE("Entering GetStaticImage"); <br>    IMediaSample *pMediaSample; <br>    pMediaSample = m_pRenderer-&gt;GetCurrentSample(); <br>    RECT SourceRect; <br> <br>    // Is there an image available <br> <br>    if (pMediaSample == NULL) { <br>        return E_UNEXPECTED; <br>    } <br> <br>    // Find a scaled source rectangle for the current bitmap <br> <br>    m_pRenderer-&gt;m_DrawImage.GetSourceRect(&amp;SourceRect); <br>    SourceRect = m_pRenderer-&gt;m_DrawImage.ScaleSourceRect(&amp;SourceRect); <br>    VIDEOINFOHEADER *pVideoInfo = (VIDEOINFOHEADER *) m_pRenderer-&gt;m_mtIn.Format(); <br> <br>    // Call the base class helper method to do the work <br> <br>    HRESULT hr = CopyImage(pMediaSample,        // Buffer containing image <br>                           pVideoInfo,          // Type representing bitmap <br>                           pBufferSize,         // Size of buffer for DIB <br>                           (BYTE*) pDIBImage,   // Data buffer for output <br>                           &amp;SourceRect);        // Current source position <br> <br>    pMediaSample-&gt;Release(); <br>    return hr; <br> <br>} // GetStaticImage <br> <br> <br>// <br>// GetVideoFormat <br>// <br>// Derived classes must override this to return a VIDEOINFOHEADER representing <br>// the video format. We cannot call IPin ConnectionMediaType to get this <br>// format because various filters dynamically change the type when using <br>// DirectDraw such that the format shows the position of the logical <br>// bitmap in a frame buffer surface, so the size might be returned as <br>// 1024x768 pixels instead of 320x240 which are the real video dimensions <br>// <br>VIDEOINFOHEADER *CVideoText::GetVideoFormat() <br>{ <br>    return (VIDEOINFOHEADER *)m_pRenderer-&gt;m_mtIn.Format(); <br>} // GetVideoFormat <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
