<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SAMPVID.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2917"></a>SAMPVID.CPP</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>#include &lt;streams.h&gt; <br>#include &lt;vidprop.h&gt; <br>#include &lt;initguid.h&gt; <br>#include &lt;sampvid.h&gt; <br>#if (1100 &gt; _MSC_VER) <br>#include &lt;olectlid.h&gt; <br>#else <br>#include &lt;olectl.h&gt; <br>#endif <br> <br>// <br>// <br>// What this sample illustrates <br>// <br>// A simple video renderer that draws video into a text shaped window on <br>// Windows NT and a simple popup window on Windows 95. Shows to how use <br>// the base video renderer classes from the ActiveMovie SDK. Implements <br>// a property page to allow users to find out quality management details. <br>// <br>// <br>// Summary <br>// <br>// This is a sample ActiveMovie video renderer - the filter is based on the <br>// CBaseVideoRenderer base class. The base class handles all the seeking, <br>// synchronisation and quality management necessary for video renderers. In <br>// particular we override the DoRenderSample and PrepareRender methods so <br>// that we can draw images and realize palettes as necessary in Windows. <br>// <br>// <br>// Implementation <br>// <br>// The original idea was that the renderer would create a custom window that <br>// spelt out ActiveX, in the letters the video would be displayed. To create <br>// a window with a non rectangular clip region like this meant using paths. <br>// Unfortunately these are only truly supported on WindowsNT so for Win95 we <br>// create a simple popup window (ie no system menu nor accellerator boxes). <br>// <br>// The renderer supports both IBasicVideo and IVideoWindow that is achieved <br>// fairly simply by inheriting our renderer from the CBaseControlVideo and <br>// CBaseControlWindow base classes. To fully implement these interfaces we <br>// must then override and implement some more PURE virtual methods such as <br>// GetVideoFormat and Get/SetSourceRect (which all live in VIDEOTXT.CPP). <br>// <br>// Because we are either a simple popup window or a text shaped window we may <br>// not have a title bar for the user to grab to move the window around. So we <br>// handle WM_NCHITTEST messages (with HTCLIENT) to effectively enable window <br>// dragging by clicking on the video client area. <br>// <br>// We make heavy use of other base classes, notably the CImageAllocator which <br>// provides buffers that are really DIBSECTIONs. This enables faster drawing <br>// of video (and is the same trick pulled by the real runtime renderer). We <br>// also use CImageDisplay to match up optimal drawing formats and for video <br>// type checking, CImagePalette for general palette creation and handling and <br>// last but not least CDrawImage that can be used for general video drawing. <br>// <br>// <br>// Demonstration instructions <br>// <br>// Start GRAPHEDT available in the ActiveMovie SDK tools. Drag and drop any <br>// MPEG, AVI or MOV file into the tool and it will be rendered. Then go to <br>// the filters in the graph and find the filter (box) titled "Video Renderer" <br>// This is the filter we will be replacing with the sample video renderer. <br>// Then click on the box and hit DELETE. After that go to the Graph menu and <br>// select "Insert Filters", from the dialog box find and select the "Sample <br>// Renderer" and then dismiss the dialog. Back in the graph layout find the <br>// output pin of the filter that was connected to the input of the video <br>// renderer you just deleted, right click and select "Render". You should <br>// see it being connected to the input pin of the renderer you just inserted <br>// <br>// Click Pause and Run on the GRAPHEDT frame and you will see the video... <br>// <br>// <br>// Files <br>// <br>// sampvid.cpp          Main implementation of the video renderer <br>// sampvid.def          What APIs the DLL will import and export <br>// sampvid.h            Class definition of the derived renderer <br>// sampvid.rc           Dialog box template for our property page <br>// sampvid.reg          What goes in the registry to make us work <br>// videotxt.cpp         The code to look after a video window <br>// vidprop.cpp          The implementation of the property page <br>// vidprop.h            The class definition for the property page <br>// makefile             How to build it... <br>// <br>// <br>// Base classes used <br>// <br>// CImageAllocator      A DIBSECTION video image allocator <br>// CVideoInputPin       IPin and IMemInputPin interfaces <br>// CImageDisplay        Manages the video display type <br>// CMediaType           Source connection media type <br>// CVideoText           Does the actual video rendering <br>// CImagePalette        Looks after managing a palette <br>// CDrawImage           Does the actual image drawing <br>// <br>// <br> <br> <br>// Setup data <br> <br>const AMOVIESETUP_MEDIATYPE sudPinTypes = <br>{ <br>    &amp;MEDIATYPE_Video,           // Major type <br>    &amp;MEDIASUBTYPE_NULL          // Minor type <br>}; <br> <br>const AMOVIESETUP_PIN sudPins = <br>{ <br>    L"Input",                   // Name of the pin <br>    FALSE,                      // Is pin rendered <br>    FALSE,                      // Is an output pin <br>    FALSE,                      // Ok for no pins <br>    FALSE,                      // Allowed many <br>    &amp;CLSID_NULL,                // Connects to filter <br>    L"Output",                  // Connects to pin <br>    1,                          // Number of pin types <br>    &amp;sudPinTypes                // Details for pins <br>}; <br> <br>const AMOVIESETUP_FILTER sudSampVid = <br>{ <br>    &amp;CLSID_SampleRenderer,      // Filter CLSID <br>    L"Sample Video Renderer",   // Filter name <br>    MERIT_DO_NOT_USE,           // Filter merit <br>    1,                          // Number pins <br>    &amp;sudPins                    // Pin details <br>}; <br> <br>// List of class IDs and creator functions for the class factory. This <br>// provides the link between the OLE entry point in the DLL and an object <br>// being created. The class factory will call the static CreateInstance <br> <br>CFactoryTemplate g_Templates[] = { <br>    { L"Sample Video Renderer" <br>    , &amp;CLSID_SampleRenderer <br>    , CVideoRenderer::CreateInstance <br>    , NULL <br>    , &amp;sudSampVid } <br>  , <br>    { L"Quality Property Page" <br>    , &amp;CLSID_SampleQuality <br>    , CQualityProperties::CreateInstance } <br>}; <br>int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]); <br> <br> <br>// <br>// CreateInstance <br>// <br>// This goes in the factory template table to create new filter instances <br>// <br>CUnknown * WINAPI CVideoRenderer::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr) <br>{ <br>    return new CVideoRenderer(NAME("Sample Video Renderer"),pUnk,phr); <br> <br>} // CreateInstance <br> <br> <br>#pragma warning(disable:4355) <br> <br>// <br>// Constructor <br>// <br>CVideoRenderer::CVideoRenderer(TCHAR *pName, <br>                               LPUNKNOWN pUnk, <br>                               HRESULT *phr) : <br> <br>    CBaseVideoRenderer(CLSID_SampleRenderer,pName,pUnk,phr), <br>    m_InputPin(NAME("Video Pin"),this,&amp;m_InterfaceLock,phr,L"Input"), <br>    m_ImageAllocator(this,NAME("Sample video allocator"),phr), <br>    m_VideoText(NAME("Video properties"),GetOwner(),phr,&amp;m_InterfaceLock,this), <br>    m_ImagePalette(this,&amp;m_VideoText,&amp;m_DrawImage), <br>    m_DrawImage(&amp;m_VideoText) <br>{ <br>    // Store the video input pin <br>    m_pInputPin = &amp;m_InputPin; <br> <br>    // Reset the current video size <br> <br>    m_VideoSize.cx = 0; <br>    m_VideoSize.cy = 0; <br> <br>    // Initialise the window and control interfaces <br> <br>    m_VideoText.SetControlVideoPin(&amp;m_InputPin); <br>    m_VideoText.SetControlWindowPin(&amp;m_InputPin); <br> <br>} // (Constructor) <br> <br> <br>// <br>// Destructor <br>// <br>CVideoRenderer::~CVideoRenderer() <br>{ <br>    m_pInputPin = NULL; <br> <br>} // (Destructor) <br> <br> <br>// <br>// CheckMediaType <br>// <br>// Check the proposed video media type <br>// <br>HRESULT CVideoRenderer::CheckMediaType(const CMediaType *pmtIn) <br>{ <br>    return m_Display.CheckMediaType(pmtIn); <br> <br>} // CheckMediaType <br> <br> <br>// <br>// GetPin <br>// <br>// We only support one input pin and it is numbered zero <br>// <br>CBasePin *CVideoRenderer::GetPin(int n) <br>{ <br>    ASSERT(n == 0); <br>    if (n != 0) { <br>        return NULL; <br>    } <br> <br>    // Assign the input pin if not already done so <br> <br>    if (m_pInputPin == NULL) { <br>        m_pInputPin = &amp;m_InputPin; <br>    } <br>    return m_pInputPin; <br> <br>} // GetPin <br> <br> <br>// <br>// NonDelegatingQueryInterface <br>// <br>// Overriden to say what interfaces we support and where <br>// <br>STDMETHODIMP CVideoRenderer::NonDelegatingQueryInterface(REFIID riid,void **ppv) <br>{ <br>    CheckPointer(ppv,E_POINTER); <br>    if (riid == IID_ISpecifyPropertyPages) { <br>        return GetInterface((ISpecifyPropertyPages *)this, ppv); <br>    } else if (riid == IID_IVideoWindow) { <br>        return m_VideoText.NonDelegatingQueryInterface(riid,ppv); <br>    } else if (riid == IID_IBasicVideo) { <br>        return m_VideoText.NonDelegatingQueryInterface(riid,ppv); <br>    } <br>    return CBaseVideoRenderer::NonDelegatingQueryInterface(riid,ppv); <br> <br>} // NonDelegatingQueryInterface <br> <br> <br>// <br>// GetPages <br>// <br>// Return the CLSIDs for the property pages we support <br>// <br>STDMETHODIMP CVideoRenderer::GetPages(CAUUID *pPages) <br>{ <br>    CheckPointer(pPages,E_POINTER); <br> <br>    pPages-&gt;cElems = 1; <br>    pPages-&gt;pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID)); <br>    if (pPages-&gt;pElems == NULL) { <br>        return E_OUTOFMEMORY; <br>    } <br> <br>    pPages-&gt;pElems[0] = CLSID_SampleQuality; <br>    return NOERROR; <br> <br>} // GetPages <br> <br> <br>// <br>// DoRenderSample <br>// <br>// Have the drawing object render the current image <br>// <br>HRESULT CVideoRenderer::DoRenderSample(IMediaSample *pMediaSample) <br>{ <br>    return m_DrawImage.DrawImage(pMediaSample); <br> <br>} // DoRenderSample <br> <br> <br>// <br>// PrepareRender <br>// <br>// Overriden to realise the palette before drawing. We used to have to realise <br>// the palette on every frame because we could never be sure of receiving top <br>// level messages like WM_PALETTECHANGED. However the plug in distributor will <br>// now make sure we get these but we still have to do this because otherwise <br>// we may not find the palette being realised before the thread comes to draw <br> <br>void CVideoRenderer::PrepareRender() <br>{ <br>    // Realise the palette on this thread <br>    m_VideoText.DoRealisePalette(); <br>} // PrepareRender <br> <br> <br>// <br>// Active <br>// <br>// The auto show flag is used to have the window shown automatically when we <br>// change state. We do this only when moving to paused or running, when there <br>// is no outstanding EC_USERABORT set and when the window is not already up <br>// This can be changed through the IVideoWindow interface AutoShow property. <br>// If the window is not currently visible then we are showing it because of <br>// a state change to paused or running, in which case there is no point in <br>// the video window sending an EC_REPAINT as we're getting an image anyway <br>// <br>HRESULT CVideoRenderer::Active() <br>{ <br>    HWND hwnd = m_VideoText.GetWindowHWND(); <br>    NOTE("AutoShowWindow"); <br> <br>    if (m_VideoText.IsAutoShowEnabled() == TRUE) { <br>        if (m_bAbort == FALSE) { <br>            if (IsWindowVisible(hwnd) == FALSE) { <br>                NOTE("Executing AutoShowWindow"); <br>                SetRepaintStatus(FALSE); <br>                m_VideoText.PerformanceAlignWindow(); <br>                m_VideoText.DoShowWindow(SW_SHOWNORMAL); <br>                m_VideoText.DoSetWindowForeground(TRUE); <br>            } <br>        } <br>    } <br>    return CBaseVideoRenderer::Active(); <br> <br>} // Active <br> <br> <br>// <br>// SetMediaType <br>// <br>// We store a copy of the media type used for the connection in the renderer <br>// because it is required by many different parts of the running renderer <br>// This can be called when we come to draw a media sample that has a format <br>// change with it. We normally delay type changes until they are really due <br>// for rendering otherwise we will change types too early if the source has <br>// allocated a queue of samples. In our case this isn't a problem because we <br>// only ever receive one sample at a time so it's safe to change immediately <br>// <br>HRESULT CVideoRenderer::SetMediaType(const CMediaType *pmt) <br>{ <br>    CAutoLock cInterfaceLock(&amp;m_InterfaceLock); <br>    CMediaType StoreFormat(m_mtIn); <br>    HRESULT hr = NOERROR; <br> <br>    // Fill out the optional fields in the VIDEOINFOHEADER <br> <br>    m_mtIn = *pmt; <br>    VIDEOINFO *pVideoInfo = (VIDEOINFO *) m_mtIn.Format(); <br>    m_Display.UpdateFormat(pVideoInfo); <br> <br>    // We set the new palette before completing so that the method can look <br>    // at the old RGB colours we used and compare them with the new set, if <br>    // they're all identical colours we don't need to change the palette <br> <br>    hr = m_ImagePalette.PreparePalette(&amp;m_mtIn,&amp;StoreFormat,NULL); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br> <br>    // Complete the initialisation <br> <br>    m_DrawImage.NotifyMediaType(&amp;m_mtIn); <br>    m_ImageAllocator.NotifyMediaType(&amp;m_mtIn); <br>    return NOERROR; <br> <br>} // SetMediaType <br> <br> <br>// <br>// BreakConnect <br>// <br>// This is called when a connection or an attempted connection is terminated <br>// and lets us to reset the connection flag held by the base class renderer <br>// The filter object may be hanging onto an image to use for refreshing the <br>// video window so that must be freed (the allocator decommit may be waiting <br>// for that image to return before completing) then we must also uninstall <br>// any palette we were using, reset anything set with the control interfaces <br>// then set our overall state back to disconnected ready for the next time <br> <br>HRESULT CVideoRenderer::BreakConnect() <br>{ <br>    CAutoLock cInterfaceLock(&amp;m_InterfaceLock); <br> <br>    // Check we are in a valid state <br> <br>    HRESULT hr = CBaseVideoRenderer::BreakConnect(); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br> <br>    // The window is not used when disconnected <br>    IPin *pPin = m_InputPin.GetConnected(); <br>    if (pPin) SendNotifyWindow(pPin,NULL); <br> <br>    // The base class break connect disables us from sending any EC_REPAINT <br>    // events which is important otherwise when we come down here to remove <br>    // our palette we end up painting the window again - which in turn sees <br>    // there is no image to draw and would otherwise send a redundant event <br> <br>    m_ImagePalette.RemovePalette(); <br>    m_mtIn.ResetFormatBuffer(); <br>    return NOERROR; <br> <br>} // BreakConnect <br> <br> <br>// <br>// CompleteConnect <br>// <br>// When we complete connection we need to see if the video has changed sizes <br>// If it has then we activate the window and reset the source and destination <br>// rectangles. If the video is the same size then we bomb out early. By doing <br>// this we make sure that temporary disconnections such as when we go into a <br>// fullscreen mode do not cause unnecessary property changes. The basic ethos <br>// is that all properties should be persistent across connections if possible <br>// <br>HRESULT CVideoRenderer::CompleteConnect(IPin *pReceivePin) <br>{ <br>    CAutoLock cInterfaceLock(&amp;m_InterfaceLock); <br>    CBaseVideoRenderer::CompleteConnect(pReceivePin); <br>    m_DrawImage.ResetPaletteVersion(); <br> <br>    // Has the video size changed between connections <br> <br>    VIDEOINFOHEADER *pVideoInfo = (VIDEOINFOHEADER *) m_mtIn.Format(); <br>    if (pVideoInfo-&gt;bmiHeader.biWidth == m_VideoSize.cx) { <br>        if (pVideoInfo-&gt;bmiHeader.biHeight == m_VideoSize.cy) { <br>            return NOERROR; <br>        } <br>    } <br> <br>    // Pass the video window handle upstream <br>    HWND hwnd = m_VideoText.GetWindowHWND(); <br>    NOTE1("Sending EC_NOTIFY_WINDOW %x",hwnd); <br>    SendNotifyWindow(pReceivePin,hwnd); <br> <br>    // Set them for the current video dimensions <br> <br>    m_DrawImage.SetDrawContext(); <br>    m_VideoSize.cx = pVideoInfo-&gt;bmiHeader.biWidth; <br>    m_VideoSize.cy = pVideoInfo-&gt;bmiHeader.biHeight; <br>    m_VideoText.SetDefaultSourceRect(); <br>    m_VideoText.SetDefaultTargetRect(); <br>    m_VideoText.OnVideoSizeChange(); <br>    m_VideoText.ActivateWindow(); <br> <br>    return NOERROR; <br> <br>} // CompleteConnect <br> <br> <br>// <br>// OnReceiveFirstSample <br>// <br>// Use the image just delivered to display a poster frame <br>// <br>void CVideoRenderer::OnReceiveFirstSample(IMediaSample *pMediaSample) <br>{ <br>    DoRenderSample(pMediaSample); <br> <br>} // OnReceiveFirstSample <br> <br> <br>// Constructor <br> <br>CVideoInputPin::CVideoInputPin(TCHAR *pObjectName, <br>                               CVideoRenderer *pRenderer, <br>                               CCritSec *pInterfaceLock, <br>                               HRESULT *phr, <br>                               LPCWSTR pPinName) : <br> <br>    CRendererInputPin(pRenderer,phr,pPinName), <br>    m_pRenderer(pRenderer), <br>    m_pInterfaceLock(pInterfaceLock) <br>{ <br>    ASSERT(m_pRenderer); <br>    ASSERT(pInterfaceLock); <br> <br>} // (Constructor) <br> <br> <br>// <br>// GetAllocator <br>// <br>// This overrides the CBaseInputPin virtual method to return our allocator <br>// we create to pass shared memory DIB buffers that GDI can directly access <br>// When NotifyAllocator is called it sets the current allocator in the base <br>// input pin class (m_pAllocator), this is what GetAllocator should return <br>// unless it is NULL in which case we return the allocator we would like <br>// <br>STDMETHODIMP CVideoInputPin::GetAllocator(IMemAllocator **ppAllocator) <br>{ <br>    CAutoLock cInterfaceLock(m_pInterfaceLock); <br>    CheckPointer(ppAllocator,E_POINTER); <br> <br>    // Has an allocator been set yet in the base class <br> <br>    if (m_pAllocator == NULL) { <br>        m_pAllocator = &amp;m_pRenderer-&gt;m_ImageAllocator; <br>        m_pAllocator-&gt;AddRef(); <br>    } <br> <br>    m_pAllocator-&gt;AddRef(); <br>    *ppAllocator = m_pAllocator; <br>    return NOERROR; <br> <br>} // GetAllocator <br> <br> <br>// <br>// NotifyAllocator <br>// <br>// The COM specification says any two IUnknown pointers to the same object <br>// should always match which provides a way for us to see if they are using <br>// our DIB allocator or not. Since we are only really interested in equality <br>// and our object always hands out the same IMemAllocator interface we can <br>// just see if the pointers match. If they are we set a flag in the main <br>// renderer as the window needs to know whether it can do fast rendering <br>// <br>STDMETHODIMP <br>CVideoInputPin::NotifyAllocator(IMemAllocator *pAllocator,BOOL bReadOnly) <br>{ <br>    CAutoLock cInterfaceLock(m_pInterfaceLock); <br> <br>    // Make sure the base class gets a look <br> <br>    HRESULT hr = CBaseInputPin::NotifyAllocator(pAllocator,bReadOnly); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br> <br>    // Whose allocator is the source going to use <br> <br>    m_pRenderer-&gt;m_DrawImage.NotifyAllocator(FALSE); <br>    if (pAllocator == &amp;m_pRenderer-&gt;m_ImageAllocator) { <br>        m_pRenderer-&gt;m_DrawImage.NotifyAllocator(TRUE); <br>    } <br>    return NOERROR; <br> <br>} // NotifyAllocator <br> <br> <br>// <br>// DllRegisterSever <br>// <br>// Handle the registration of this filter <br>// <br>STDAPI DllRegisterServer() <br>{ <br>    return AMovieDllRegisterServer2( TRUE ); <br> <br>} // DllRegisterServer <br> <br> <br>// <br>// DllUnregisterServer <br>// <br>STDAPI DllUnregisterServer() <br>{ <br>    return AMovieDllRegisterServer2( FALSE ); <br> <br>} // DllUnregisterServer <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
