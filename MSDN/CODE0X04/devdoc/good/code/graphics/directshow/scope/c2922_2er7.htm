<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SCOPE.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2923"></a>SCOPE.CPP</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>#include &lt;streams.h&gt; <br>#include &lt;commctrl.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include &lt;initguid.h&gt; <br>#include &lt;wxdebug.h&gt; <br>#include "scope.h" <br>#include "resource.h" <br> <br>// <br>// <br>// What this sample illustrates <br>// <br>// An audio oscilloscope that shows the waveform graphically as the audio is <br>// received by the filter. The filter is a renderer that can put where ever <br>// the normal runtime renderer goes. We have a single input pin that accepts <br>// a number of difference audio formats and renders the data as appropriate. <br>// <br>// <br>// Summary <br>// <br>// This is an audio oscilloscope renderer - we are basicly an audio renderer <br>// When we are created we also create a class to look after the scope window <br>// whose constructor creates a worker thread, when it is destroyed it will <br>// also terminate the worker thread. On that worker thread a window is looked <br>// after that shows the audio waveform for data sent to us. The data is kept <br>// in a circular buffer that loops when sufficient data has been received. We <br>// support a number of different audio formats such as 8bit mode and stereo. <br>// <br>// <br>// Demonstration Instructions <br>// <br>// (To really sure of this demonstration the machine must have a sound card) <br>// Start GRAPHEDT available in the ActiveMovie SDK tools. Drag and drop any <br>// MPEG, AVI or MOV file into the tool and it will be rendered. Then go to <br>// the filters in the graph and find the filter (box) titled "Audio Renderer" <br>// This is the filter we will be replacing with this oscilloscope renderer. <br>// Then click on the box and hit DELETE. After that go to the Graph menu and <br>// select "Insert Filters", from the dialog box that pops up find and select <br>// "Oscilloscope", then dismiss the dialog. Back in the graph layout find the <br>// output pin of the filter that was connected to the input of the audio <br>// renderer you just deleted, right click and select "Render". You should <br>// see it being connected to the input pin of the oscilloscope you inserted <br>// <br>// Click Run on GRAPHEDT and you'll see a waveform for the audio soundtrack... <br>// <br>// <br>// Files <br>// <br>// icon1.ico            The icon for the oscilloscope window <br>// makefile             How we build it... <br>// resource.h           Microsoft Visual C++ generated file <br>// scope.cpp            The main filter and window implementations <br>// scope.def            What APIs the DLL imports and exports <br>// scope.h              Window and filter class definitions <br>// scope.mak            Visual C++ generated makefile <br>// scope.rc             Dialog box template for our window <br>// scope.reg            What goes in the registry to make us work <br>// <br>// <br>// Base classes we use <br>// <br>// CBaseInputPin        A generic input pin we use for the filter <br>// CCritSec             A wrapper class around a critical section <br>// CBaseFilter          The generic ActiveMovie filter object <br>// <br>// <br> <br> <br>// Setup data <br> <br>const AMOVIESETUP_MEDIATYPE sudPinTypes = <br>{ <br>    &amp;MEDIATYPE_Audio,           // Major type <br>    &amp;MEDIASUBTYPE_NULL          // Minor type <br>}; <br> <br> <br>const AMOVIESETUP_PIN sudPins  = <br>{ <br>    L"Input",                   // Pin string name <br>    FALSE,                      // Is it rendered <br>    FALSE,                      // Is it an output <br>    FALSE,                      // Allowed zero pins <br>    FALSE,                      // Allowed many <br>    &amp;CLSID_NULL,                // Connects to filter <br>    L"Output",                  // Connects to pin <br>    1,                          // Number of pins types <br>    &amp;sudPinTypes } ;            // Pin information <br> <br> <br>const AMOVIESETUP_FILTER sudScope = <br>{ <br>    &amp;CLSID_Scope,               // Filter CLSID <br>    L"Oscilloscope",            // String name <br>    MERIT_DO_NOT_USE,           // Filter merit <br>    1,                          // Number pins <br>    &amp;sudPins                    // Pin details <br>}; <br> <br> <br>// List of class IDs and creator functions for class factory <br> <br>CFactoryTemplate g_Templates []  = { <br>    { L"Oscilloscope" <br>    , &amp;CLSID_Scope <br>    , CScopeFilter::CreateInstance <br>    , NULL <br>    , &amp;sudScope } <br>}; <br>int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]); <br> <br> <br>// <br>// CreateInstance <br>// <br>// This goes in the factory template table to create new instances <br>// <br>CUnknown * WINAPI CScopeFilter::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr) <br>{ <br>    return new CScopeFilter(pUnk, phr); <br> <br>} // CreateInstance <br> <br> <br>// <br>// Constructor <br>// <br>// Create the filter, scope window, and input pin <br>// <br>#pragma warning(disable:4355) <br>// <br>CScopeFilter::CScopeFilter(LPUNKNOWN pUnk,HRESULT *phr) : <br>    CBaseFilter(NAME("Oscilloscope"), pUnk, (CCritSec *) this, CLSID_Scope), <br>    m_Window(NAME("Oscilloscope"), this, phr) <br>{ <br>    // Create the single input pin <br> <br>    m_pInputPin = new CScopeInputPin(this,phr,L"Scope Input Pin"); <br>    if (m_pInputPin == NULL) { <br>        *phr = E_OUTOFMEMORY; <br>    } <br> <br>} // (Constructor) <br> <br> <br>// <br>// Destructor <br>// <br>CScopeFilter::~CScopeFilter() <br>{ <br>    // Delete the contained interfaces <br> <br>    ASSERT(m_pInputPin); <br>    delete m_pInputPin; <br>    m_pInputPin = NULL; <br> <br>} // (Destructor) <br> <br> <br>// <br>// GetPinCount <br>// <br>// Return the number of input pins we support <br>// <br>int CScopeFilter::GetPinCount() <br>{ <br>    return 1; <br> <br>} // GetPinCount <br> <br> <br>// <br>// GetPin <br>// <br>// Return our single input pin - not addrefed <br>// <br>CBasePin *CScopeFilter::GetPin(int n) <br>{ <br>    // We only support one input pin and it is numbered zero <br> <br>    ASSERT(n == 0); <br>    if (n != 0) { <br>        return NULL; <br>    } <br>    return m_pInputPin; <br> <br>} // GetPin <br> <br> <br>// <br>// JoinFilterGraph <br>// <br>// Show our window when we join a filter graph <br>//   - and hide it when we are annexed from it <br>// <br>STDMETHODIMP CScopeFilter::JoinFilterGraph(IFilterGraph *pGraph, LPCWSTR pName) <br>{ <br>    HRESULT hr = CBaseFilter::JoinFilterGraph(pGraph, pName); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br> <br>    // Hide or show the scope as appropriate <br> <br>    if (pGraph == NULL) { <br>        m_Window.InactivateWindow(); <br>    } else { <br>        m_Window.ActivateWindow(); <br>    } <br>    return hr; <br> <br>} // JoinFilterGraph <br> <br> <br>// <br>// Stop <br>// <br>// Switch the filter into stopped mode. <br>// <br>STDMETHODIMP CScopeFilter::Stop() <br>{ <br>    CAutoLock lock(this); <br> <br>    if (m_State != State_Stopped) { <br> <br>        // Pause the device if we were running <br>        if (m_State == State_Running) { <br>            HRESULT hr = Pause(); <br>            if (FAILED(hr)) { <br>                return hr; <br>            } <br>        } <br> <br>        DbgLog((LOG_TRACE,1,TEXT("Stopping...."))); <br> <br>        // Base class changes state and tells pin to go to inactive <br>        // the pin Inactive method will decommit our allocator which <br>        // we need to do before closing the device <br> <br>        HRESULT hr = CBaseFilter::Stop(); <br>        if (FAILED(hr)) { <br>            return hr; <br>        } <br>    } <br>    return NOERROR; <br> <br>} // Stop <br> <br> <br>// <br>// Pause <br>// <br>// Override Pause to stop the window streaming <br>// <br>STDMETHODIMP CScopeFilter::Pause() <br>{ <br>    CAutoLock lock(this); <br> <br>    // Check we can PAUSE given our current state <br> <br>    if (m_State == State_Running) { <br>        m_Window.StopStreaming(); <br>    } <br> <br>    // tell the pin to go inactive and change state <br>    return CBaseFilter::Pause(); <br> <br>} // Pause <br> <br> <br>// <br>// Run <br>// <br>// Overriden to start the window streaming <br>// <br>STDMETHODIMP CScopeFilter::Run(REFERENCE_TIME tStart) <br>{ <br>    CAutoLock lock(this); <br>    HRESULT hr = NOERROR; <br>    FILTER_STATE fsOld = m_State; <br> <br>    // This will call Pause if currently stopped <br> <br>    hr = CBaseFilter::Run(tStart); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br> <br>    m_Window.ActivateWindow(); <br> <br>    if (fsOld != State_Running) { <br>        m_Window.StartStreaming(); <br>    } <br>    return NOERROR; <br> <br>} // Run <br> <br> <br>// <br>// Constructor <br>// <br>CScopeInputPin::CScopeInputPin(CScopeFilter *pFilter, <br>                               HRESULT *phr, <br>                               LPCWSTR pPinName) : <br>    CBaseInputPin(NAME("Scope Input Pin"), pFilter, pFilter, phr, pPinName) <br>{ <br>    m_pFilter = pFilter; <br> <br>} // (Constructor) <br> <br> <br>// <br>// Destructor does nothing <br>// <br>CScopeInputPin::~CScopeInputPin() <br>{ <br>} // (Destructor) <br> <br> <br>// <br>// BreakConnect <br>// <br>// This is called when a connection or an attempted connection is terminated <br>// and allows us to reset the connection media type to be invalid so that <br>// we can always use that to determine whether we are connected or not. We <br>// leave the format block alone as it will be reallocated if we get another <br>// connection or alternatively be deleted if the filter is finally released <br>// <br>HRESULT CScopeInputPin::BreakConnect() <br>{ <br>    // Check we have a valid connection <br> <br>    if (m_mt.IsValid() == FALSE) { <br>        return E_FAIL; <br>    } <br> <br>    m_pFilter-&gt;Stop(); <br> <br>    // Reset the CLSIDs of the connected media type <br> <br>    m_mt.SetType(&amp;GUID_NULL); <br>    m_mt.SetSubtype(&amp;GUID_NULL); <br>    return CBaseInputPin::BreakConnect(); <br> <br>} // BreakConnect <br> <br> <br>// <br>// CheckMediaType <br>// <br>// Check that we can support a given proposed type <br>// <br>HRESULT CScopeInputPin::CheckMediaType(const CMediaType *pmt) <br>{ <br>    WAVEFORMATEX *pwfx = (WAVEFORMATEX *) pmt-&gt;Format(); <br> <br>    if (pwfx == NULL) <br>        return E_INVALIDARG; <br> <br>    // Reject non-PCM Audio type <br> <br>    if (pmt-&gt;majortype != MEDIATYPE_Audio) { <br>        return E_INVALIDARG; <br>    } <br> <br>    if (pmt-&gt;formattype != FORMAT_WaveFormatEx) { <br>        return E_INVALIDARG; <br>    } <br> <br>    if (pwfx-&gt;wFormatTag != WAVE_FORMAT_PCM) { <br>        return E_INVALIDARG; <br>    } <br>    return NOERROR; <br> <br>} // CheckMediaType <br> <br> <br>// <br>// SetMediaType <br>// <br>// Actually set the format of the input pin <br>// <br>HRESULT CScopeInputPin::SetMediaType(const CMediaType *pmt) <br>{ <br>    CAutoLock lock(m_pFilter); <br> <br>    // Pass the call up to my base class <br> <br>    HRESULT hr = CBaseInputPin::SetMediaType(pmt); <br>    if (SUCCEEDED(hr)) { <br> <br>        WAVEFORMATEX *pwf = (WAVEFORMATEX *) pmt-&gt;Format(); <br> <br>        m_pFilter-&gt;m_Window.m_nChannels = pwf-&gt;nChannels; <br>        m_pFilter-&gt;m_Window.m_nSamplesPerSec = pwf-&gt;nSamplesPerSec; <br>        m_pFilter-&gt;m_Window.m_nBitsPerSample = pwf-&gt;wBitsPerSample; <br>        m_pFilter-&gt;m_Window.m_nBlockAlign = pwf-&gt;nBlockAlign; <br> <br>        m_pFilter-&gt;m_Window.m_MaxValue = 128; <br>        m_pFilter-&gt;m_Window.m_nIndex = 0; <br> <br>        if (!m_pFilter-&gt;m_Window.AllocWaveBuffers ()) <br>            return E_FAIL; <br> <br>        // Reset the horizontal scroll bar <br>        m_pFilter-&gt;m_Window.SetHorizScrollRange(m_pFilter-&gt;m_Window.m_hwndDlg); <br>    } <br>    return hr; <br> <br>} // SetMediaType <br> <br> <br>// <br>// Active <br>// <br>// Implements the remaining IMemInputPin virtual methods <br>// <br>HRESULT CScopeInputPin::Active(void) <br>{ <br>    return NOERROR; <br> <br>} // Active <br> <br> <br>// <br>// Inactive <br>// <br>// Called when the filter is stopped <br>// <br>HRESULT CScopeInputPin::Inactive(void) <br>{ <br>    return NOERROR; <br> <br>} // Inactive <br> <br> <br>// <br>// Receive <br>// <br>// Here's the next block of data from the stream <br>// <br>HRESULT CScopeInputPin::Receive(IMediaSample * pSample) <br>{ <br>    // Lock this with the filter-wide lock <br>    CAutoLock lock(m_pFilter); <br> <br>    // If we're stopped, then reject this call <br>    // (the filter graph may be in mid-change) <br>    if (m_pFilter-&gt;m_State == State_Stopped) { <br>        return E_FAIL; <br>    } <br> <br>    // Check all is well with the base class <br>    HRESULT hr = CBaseInputPin::Receive(pSample); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br> <br>    // Send the sample to the video window object for rendering <br>    return m_pFilter-&gt;m_Window.Receive(pSample); <br> <br>} // Receive <br> <br> <br>// <br>// CScopeWindow Constructor <br>// <br>CScopeWindow::CScopeWindow(TCHAR *pName, CScopeFilter *pRenderer,HRESULT *phr) : <br>    m_hInstance(g_hInst), <br>    m_pRenderer(pRenderer), <br>    m_hThread(INVALID_HANDLE_VALUE), <br>    m_ThreadID(0), <br>    m_hwndDlg(NULL), <br>    m_hwnd(NULL), <br>    m_pPoints1(NULL), <br>    m_pPoints2(NULL), <br>    m_nPoints(0), <br>    m_bStreaming(FALSE), <br>    m_bActivated(FALSE), <br>    m_LastMediaSampleSize(0) <br>{ <br>    // Create a thread to look after the window <br> <br>    ASSERT(m_pRenderer); <br>    m_hThread = CreateThread(NULL,                  // Security attributes <br>                             (DWORD) 0,             // Initial stack size <br>                             WindowMessageLoop,     // Thread start address <br>                             (LPVOID) this,         // Thread parameter <br>                             (DWORD) 0,             // Creation flags <br>                             &amp;m_ThreadID);          // Thread identifier <br> <br>    // If we couldn't create a thread the whole thing's off <br> <br>    ASSERT(m_hThread); <br>    if (m_hThread == NULL) { <br>        *phr = E_FAIL; <br>        return; <br>    } <br> <br>    // Wait until the window has been initialised <br>    m_SyncWorker.Wait(); <br> <br>} // (Constructor) <br> <br> <br>// <br>// Destructor <br>// <br>CScopeWindow::~CScopeWindow() <br>{ <br>    // Ensure we stop streaming and release any samples <br> <br>    StopStreaming(); <br>    InactivateWindow(); <br> <br>    // Tell the thread to destroy the window <br>    SendMessage(m_hwndDlg, WM_GOODBYE, (WPARAM)0, (LPARAM)0); <br> <br>    // Make sure it has finished <br> <br>    ASSERT(m_hThread != NULL); <br>    WaitForSingleObject(m_hThread,INFINITE); <br>    CloseHandle(m_hThread); <br> <br>    if (m_pPoints1 != NULL) delete [] m_pPoints1; <br>    if (m_pPoints2 != NULL) delete [] m_pPoints2; <br> <br>} // (Destructor) <br> <br> <br>// <br>// ResetStreamingTimes <br>// <br>// This resets the latest sample stream times <br>// <br>HRESULT CScopeWindow::ResetStreamingTimes() <br>{ <br>    m_StartSample = 0; <br>    m_EndSample = 0; <br>    return NOERROR; <br> <br>} // ResetStreamingTimes <br> <br> <br>// <br>// StartStreaming <br>// <br>// This is called when we start running state <br>// <br>HRESULT CScopeWindow::StartStreaming() <br>{ <br>    CAutoLock cAutoLock(this); <br> <br>    // Are we already streaming <br> <br>    if (m_bStreaming == TRUE) { <br>        return NOERROR; <br>    } <br> <br>    m_bStreaming = TRUE; <br>    return NOERROR; <br> <br>} // StartStreaming <br> <br> <br>// <br>// StopStreaming <br>// <br>// This is called when we stop streaming <br>// <br>HRESULT CScopeWindow::StopStreaming() <br>{ <br>    CAutoLock cAutoLock(this); <br> <br>    // Have we been stopped already <br> <br>    if (m_bStreaming == FALSE) { <br>        return NOERROR; <br>    } <br> <br>    m_bStreaming = FALSE; <br>    return NOERROR; <br> <br>} // StopStreaming <br> <br> <br>// <br>// InactivateWindow <br>// <br>// Called at the end to put the window in an inactive state <br>// <br>HRESULT CScopeWindow::InactivateWindow() <br>{ <br>    // Has the window been activated <br>    if (m_bActivated == FALSE) { <br>        return S_FALSE; <br>    } <br> <br>    // Now hide the scope window <br> <br>    ShowWindow(m_hwndDlg,SW_HIDE); <br>    m_bActivated = FALSE; <br>    return NOERROR; <br> <br>} // InactivateWindow <br> <br> <br>// <br>// ActivateWindow <br>// <br>// Show the scope window <br>// <br>HRESULT CScopeWindow::ActivateWindow() <br>{ <br>    // Has the window been activated <br>    if (m_bActivated == TRUE) { <br>        return S_FALSE; <br>    } <br> <br>    m_bActivated = TRUE; <br>    ASSERT(m_bStreaming == FALSE); <br> <br>    ShowWindow(m_hwndDlg,SW_SHOWNORMAL); <br>    return NOERROR; <br> <br>} // ActivateWindow <br> <br> <br>// <br>// OnClose <br>// <br>// This function handles the WM_CLOSE message <br>// <br>BOOL CScopeWindow::OnClose() <br>{ <br>    InactivateWindow(); <br>    return TRUE; <br> <br>} // OnClose <br> <br> <br>typedef struct GainEntry_tag { <br>    double GainValue; <br>    TCHAR GainText[8]; <br>} GainEntry; <br> <br>GainEntry GainEntries[] = <br>{ <br>    128.,  TEXT ("*128"), <br>    64.,   TEXT ("*64"), <br>    32.,   TEXT ("*32"), <br>    16.,   TEXT ("*16"), <br>    8.,    TEXT ("*8"), <br>    4.,    TEXT ("*4"), <br>    2.,    TEXT ("*2"), <br>    1.,    TEXT ("*1"), <br>    1./2,  TEXT ("/2"), <br>    1./4,  TEXT ("/4"), <br>    1./8,  TEXT ("/8"), <br>    1./16, TEXT ("/16"), <br>    1./32, TEXT ("/32"), <br>    1./64, TEXT ("/64"), <br>    1./128,TEXT ("/128"), <br>    1./256,TEXT ("/256"), <br>}; <br> <br>#define N_GAINENTRIES (sizeof(GainEntries) / sizeof (GainEntries[0])) <br>#define GAIN_DEFAULT_INDEX 7 <br> <br>typedef struct TBEntry_tag { <br>    int TBDivisor; <br>    TCHAR TBText[16]; <br>} TBEntry; <br> <br>TBEntry Timebases[] = <br>{ <br>    10000,  TEXT ("10 uS/Div"), <br>     5000,  TEXT ("20 uS/Div"), <br>     2000,  TEXT ("50 uS/Div"), <br>     1000,  TEXT ("100 uS/Div"), <br>      500,  TEXT ("200 uS/Div"), <br>      200,  TEXT ("500 uS/Div"), <br>      100,  TEXT ("1 mS/Div"), <br>       50,  TEXT ("2 mS/Div"), <br>       20,  TEXT ("5 mS/Div"), <br>       10,  TEXT ("10 mS/Div"), <br>        5,  TEXT ("20 mS/Div"), <br>        2,  TEXT ("50 mS/Div"), <br>        1,  TEXT ("100 mS/Div") <br>}; <br> <br>#define N_TIMEBASES (sizeof(Timebases) / sizeof (Timebases[0])) <br>#define TIMEBASE_DEFAULT_INDEX 9 <br> <br> <br>// <br>// SetControlRanges <br>// <br>// Set the scroll ranges for all of the vertical trackbars <br>// <br>void CScopeWindow::SetControlRanges(HWND hDlg) <br>{ <br>    SendMessage(m_hwndLGain, TBM_SETRANGE, TRUE, MAKELONG(0, N_GAINENTRIES - 1) ); <br>    SendMessage(m_hwndLGain, TBM_SETPOS, TRUE, (LPARAM) GAIN_DEFAULT_INDEX); <br>    SetDlgItemText (hDlg, IDC_L_GAIN_TEXT, GainEntries[m_LGain].GainText); <br> <br>    SendMessage(m_hwndLOffset, TBM_SETRANGE, TRUE, MAKELONG(0, m_Height - 1)); <br>    SendMessage(m_hwndLOffset, TBM_SETPOS, TRUE, (LPARAM) m_Height / 2); <br>    SetDlgItemInt (hDlg, IDC_L_OFFSET_TEXT, -m_LOffset, TRUE); <br> <br>    SendMessage(m_hwndRGain, TBM_SETRANGE, TRUE, MAKELONG(0, N_GAINENTRIES - 1) ); <br>    SendMessage(m_hwndRGain, TBM_SETPOS, TRUE, (LPARAM) GAIN_DEFAULT_INDEX); <br>    SetDlgItemText (hDlg, IDC_R_GAIN_TEXT, GainEntries[m_RGain].GainText); <br> <br>    SendMessage(m_hwndROffset, TBM_SETRANGE, TRUE, MAKELONG(0, m_Height - 1) ); <br>    SendMessage(m_hwndROffset, TBM_SETPOS, TRUE, (LPARAM) m_Height / 2); <br>    SetDlgItemInt (hDlg, IDC_R_OFFSET_TEXT, -m_ROffset, TRUE); <br> <br>    SendMessage(m_hwndTimebase, TBM_SETRANGE, TRUE, MAKELONG(0, N_TIMEBASES - 1) ); <br>    SendMessage(m_hwndTimebase, TBM_SETPOS, TRUE, (LPARAM) m_nTimebase); <br>    SetDlgItemText (hDlg, IDC_TIMEBASE_TEXT, Timebases[m_nTimebase].TBText); <br> <br>} // SetControlRanges <br> <br> <br>// <br>// SetHorizScrollRange <br>// <br>// The horizontal scrollbar handles scrolling through the 1 second circular buffer <br>// <br>void CScopeWindow::SetHorizScrollRange(HWND hDlg) <br>{ <br>    SendMessage(m_hwndTBScroll, TBM_SETRANGE, TRUE, MAKELONG(0, (m_nPoints - 1) / 2) ); <br>    SendMessage(m_hwndTBScroll, TBM_SETPOS, TRUE, (LPARAM) (m_nPoints - 1) / 2); <br> <br>    m_TBScroll = m_nPoints - 1; <br> <br>    TCHAR szFormat[80]; <br> <br>    switch (m_nBitsPerSample + m_nChannels) { <br>        case 9: <br>            // Mono, 8-bit <br>            lstrcpy (szFormat, TEXT ("M-8-")); <br>            break; <br> <br>        case 10: <br>            // Stereo, 8-bit <br>            lstrcpy (szFormat, TEXT ("S-8-")); <br>            break; <br> <br>        case 17: <br>            // Mono, 16-bit <br>            lstrcpy (szFormat, TEXT ("M-16-")); <br>            break; <br> <br>        case 18: <br>            // Stereo, 16-bit <br>            lstrcpy (szFormat, TEXT ("S-16-")); <br>            break; <br> <br>        default: <br>            lstrcpy (szFormat, TEXT (" ")); <br>            SetDlgItemText (hDlg, IDC_FORMAT, szFormat); <br>            return; <br> <br>    } // End of format switch <br> <br>    TCHAR szSamplingFreq[80]; <br>    wsprintf (szSamplingFreq, "%d", m_nSamplesPerSec); <br>    lstrcat (szFormat, szSamplingFreq); <br>    SetDlgItemText (hDlg, IDC_FORMAT, szFormat); <br> <br>} // SetHorizScrollRange <br> <br> <br>// <br>// ProcessHorizScrollCommands <br>// <br>// Called when we get a horizontal scroll bar message <br>// <br>void CScopeWindow::ProcessHorizScrollCommands(HWND hDlg, WPARAM wParam, LPARAM lParam) <br>{ <br>    int pos; <br>    int command = LOWORD (wParam); <br> <br>    if (command != TB_ENDTRACK &amp;&amp; <br>        command != TB_THUMBTRACK &amp;&amp; <br>        command != TB_LINEDOWN &amp;&amp; <br>        command != TB_LINEUP &amp;&amp; <br>        command != TB_PAGEUP &amp;&amp; <br>        command != TB_PAGEDOWN) <br>            return; <br> <br>    ASSERT (IsWindow ((HWND) lParam)); <br> <br>    pos = (int) SendMessage((HWND) lParam, TBM_GETPOS, 0, 0L); <br> <br>    if ((HWND) lParam == m_hwndTBScroll) { <br>        m_TBScroll = ((m_nPoints - 1) / 2 - pos) * 2; <br>    } <br>    OnPaint(); <br> <br>} // ProcessHorizScrollCommands <br> <br> <br>// <br>// ProcessVertScrollCommands <br>// <br>// Called when we get a vertical scroll bar message <br>// <br>void CScopeWindow::ProcessVertScrollCommands(HWND hDlg, WPARAM wParam, LPARAM lParam) <br>{ <br>    int pos; <br>    int command = LOWORD (wParam); <br> <br>    if (command != TB_ENDTRACK &amp;&amp; <br>        command != TB_THUMBTRACK &amp;&amp; <br>        command != TB_LINEDOWN &amp;&amp; <br>        command != TB_LINEUP &amp;&amp; <br>        command != TB_PAGEUP &amp;&amp; <br>        command != TB_PAGEDOWN) <br>            return; <br> <br>    ASSERT (IsWindow ((HWND) lParam)); <br> <br>    pos = (int) SendMessage((HWND) lParam, TBM_GETPOS, 0, 0L); <br> <br>    if ((HWND) lParam == m_hwndLGain) { <br>        m_LGain = pos; <br>        SetDlgItemText (hDlg, IDC_L_GAIN_TEXT, GainEntries[m_LGain].GainText); <br>    } else if ((HWND) lParam == m_hwndLOffset) { <br>        m_LOffset = pos - m_Height / 2; <br>        SetDlgItemInt (hDlg, IDC_L_OFFSET_TEXT, -m_LOffset, TRUE); <br>    } else if ((HWND) lParam == m_hwndRGain) { <br>        m_RGain = pos; <br>        SetDlgItemText (hDlg, IDC_R_GAIN_TEXT, GainEntries[m_RGain].GainText); <br>    } else if ((HWND) lParam == m_hwndROffset) { <br>        m_ROffset = pos - m_Height / 2; <br>        SetDlgItemInt (hDlg, IDC_R_OFFSET_TEXT, -m_ROffset, TRUE); <br>    } else if ((HWND) lParam == m_hwndTimebase) { <br>        m_nTimebase = pos ; <br>        SetDlgItemText (hDlg, IDC_TIMEBASE_TEXT, Timebases[m_nTimebase].TBText); <br>    } <br>    OnPaint(); <br> <br>} // ProcessVertScrollCommands <br> <br> <br>// <br>// InitialiseWindow <br>// <br>// This is called by the worker window thread after it has created the main <br>// window and it wants to initialise the rest of the owner objects window <br>// variables such as the device contexts. We execute this function with the <br>// critical section still locked. <br>// <br>HRESULT CScopeWindow::InitialiseWindow(HWND hDlg) <br>{ <br>    RECT rR; <br> <br>    // Initialise the window variables <br>    m_hwnd = GetDlgItem (hDlg, IDC_SCOPEWINDOW); <br> <br>    // Quick sanity check <br>    ASSERT(m_hwnd != NULL); <br> <br>    m_nTimebase = TIMEBASE_DEFAULT_INDEX; <br>    m_fTriggerPosZeroCrossing = 1; <br>    m_fFreeze = 0; <br> <br>    m_LGain = GAIN_DEFAULT_INDEX; <br>    m_RGain = GAIN_DEFAULT_INDEX; <br>    m_LOffset = 0; <br>    m_ROffset = 0; <br> <br>    m_TBScroll = 0; <br> <br>    GetWindowRect (m_hwnd, &amp;rR); <br>    m_Width = rR.right - rR.left; <br>    m_Height = rR.bottom - rR.top; <br> <br>    m_hwndLGain =       GetDlgItem (hDlg, IDC_L_GAIN); <br>    m_hwndLOffset =     GetDlgItem (hDlg, IDC_L_OFFSET); <br>    m_hwndLGainText =   GetDlgItem (hDlg, IDC_L_GAIN_TEXT); <br>    m_hwndLTitle =      GetDlgItem (hDlg, IDC_L_TITLE); <br> <br>    m_hwndRGain =       GetDlgItem (hDlg, IDC_R_GAIN); <br>    m_hwndROffset =     GetDlgItem (hDlg, IDC_R_OFFSET); <br>    m_hwndRGainText =   GetDlgItem (hDlg, IDC_R_GAIN_TEXT); <br>    m_hwndRTitle =      GetDlgItem (hDlg, IDC_R_TITLE); <br> <br>    m_hwndTimebase =    GetDlgItem (hDlg, IDC_TIMEBASE); <br>    m_hwndFreeze =      GetDlgItem (hDlg, IDC_FREEZE); <br>    m_hwndTBStart =     GetDlgItem (hDlg, IDC_TS_START); <br>    m_hwndTBEnd   =     GetDlgItem (hDlg, IDC_TS_LAST); <br>    m_hwndTBDelta =     GetDlgItem (hDlg, IDC_TS_DELTA); <br>    m_hwndTBScroll =    GetDlgItem (hDlg, IDC_TB_SCROLL); <br> <br>    SetControlRanges(hDlg); <br>    SetHorizScrollRange(hDlg); <br> <br>    CheckDlgButton( <br>            hDlg,                // handle of dialog box <br>            IDC_FREEZE,                // button-control identifier <br>            m_fFreeze);                // check state <br> <br>     CheckDlgButton( <br>            hDlg,                // handle of dialog box <br>            IDC_TRIGGER,        // button-control identifier <br>            m_fTriggerPosZeroCrossing);// check state <br> <br>    m_hPen1 = CreatePen (PS_SOLID, 0, RGB (0, 0xff, 0)); <br>    m_hPen2 = CreatePen (PS_SOLID, 0, RGB (0x40, 0x40, 0xff)); <br>    m_hPenTicks = CreatePen (PS_SOLID, 0, RGB (0x80, 0x80, 0x80)); <br>    m_hBrushBackground = (HBRUSH) GetStockObject (BLACK_BRUSH); <br> <br>    HDC hdc = GetDC (NULL); <br>    m_hBitmap = CreateCompatibleBitmap (hdc, m_Width, m_Height); <br>    ReleaseDC (NULL, hdc); <br>    return NOERROR; <br> <br>} // InitialiseWindow <br> <br> <br>// <br>// UninitialiseWindow <br>// <br>// This is called by the worker window thread when it receives a WM_GOODBYE <br>// message from the window object destructor to delete all the resources we <br>// allocated during initialisation <br>// <br>HRESULT CScopeWindow::UninitialiseWindow() <br>{ <br>    // Reset the window variables <br>    DeleteObject (m_hPen1); <br>    DeleteObject (m_hPen2); <br>    DeleteObject (m_hPenTicks); <br>    DeleteObject (m_hBitmap); <br> <br>    m_hwnd = NULL; <br>    return NOERROR; <br> <br>} // UninitialiseWindow <br> <br> <br>// <br>// ScopeDlgProc <br>// <br>// The Scope window is actually a dialog box, and this is its window proc. <br>// The only thing tricky about this is that the "this" pointer to the <br>// CScopeWindow is passed during the WM_INITDIALOG message and is stored <br>// in the window user data. This lets us access methods in the class <br>// from within the dialog. <br>// <br>BOOL CALLBACK ScopeDlgProc(HWND hDlg,        // Handle of dialog box <br>                           UINT uMsg,        // Message identifier <br>                           WPARAM wParam,// First message parameter <br>                           LPARAM lParam)// Second message parameter <br>{ <br>    CScopeWindow *pScopeWindow;      // Pointer to the owning object <br> <br>    // Get the window long that holds our owner pointer <br>    pScopeWindow = (CScopeWindow *) GetWindowLong(hDlg, GWL_USERDATA); <br> <br>    switch (uMsg) { <br>        case WM_INITDIALOG: <br>            pScopeWindow = (CScopeWindow *) lParam; <br>            SetWindowLong(hDlg, (DWORD) GWL_USERDATA, (LONG) pScopeWindow); <br>            return TRUE; <br> <br>        case WM_COMMAND: <br>            switch (wParam) { <br>                case IDOK: <br>                case IDCANCEL: <br>                    EndDialog (hDlg, 0); <br>                    return TRUE; <br> <br>                case IDC_FREEZE: <br>                    pScopeWindow-&gt;m_fFreeze = <br>                        (BOOL) IsDlgButtonChecked(hDlg,IDC_FREEZE); <br>                    pScopeWindow-&gt;DrawWaveform(); <br>                    break; <br> <br>                case IDC_TRIGGER: <br>                    pScopeWindow-&gt;m_fTriggerPosZeroCrossing = <br>                        (BOOL) IsDlgButtonChecked(hDlg,IDC_TRIGGER); <br>                    pScopeWindow-&gt;DrawWaveform(); <br>                    break; <br> <br>                default: <br>                    break; <br>            } <br> <br>        case WM_VSCROLL: <br>            pScopeWindow-&gt;ProcessVertScrollCommands(hDlg, wParam, lParam); <br>            break; <br> <br>        case WM_HSCROLL: <br>            pScopeWindow-&gt;ProcessHorizScrollCommands(hDlg, wParam, lParam); <br>            break; <br> <br>        case WM_PAINT: <br>            ASSERT(pScopeWindow != NULL); <br>            pScopeWindow-&gt;OnPaint(); <br>            break; <br> <br>        // We stop WM_CLOSE messages going any further by intercepting them <br>        // and then setting an abort signal flag in the owning renderer so <br>        // that it knows the user wants to quit. The renderer can then <br>        // go about deleting it's interfaces and the window helper object <br>        // which will eventually cause a WM_DESTROY message to arrive. To <br>        // make it look as though the window has been immediately closed <br>        // we hide it and then wait for the renderer to catch us up <br> <br>        case WM_CLOSE: <br>            ASSERT(pScopeWindow != NULL); <br>            pScopeWindow-&gt;OnClose(); <br>            return (LRESULT) 0; <br> <br>        // We receive a WM_GOODBYE window message (synchronously) from the <br>        // window object destructor in which case we do actually destroy <br>        // the window and complete the process in the WM_DESTROY message <br> <br>        case WM_GOODBYE: <br>            ASSERT(pScopeWindow != NULL); <br>            pScopeWindow-&gt;UninitialiseWindow(); <br>            PostQuitMessage(FALSE); <br>            EndDialog (hDlg, 0); <br>            return (LRESULT) 0; <br> <br>        default: <br>            break; <br>    } <br>    return (LRESULT) 0; <br> <br>} // ScopeDlgProc <br> <br> <br>// <br>// MessageLoop <br>// <br>// This is the standard windows message loop for our worker thread. It sits <br>// in a normal processing loop dispatching messages until it receives a quit <br>// message, which may be generated through the owning object's destructor <br>// <br>HRESULT CScopeWindow::MessageLoop() <br>{ <br>    MSG Message;        // Windows message structure <br>    DWORD dwResult;     // Wait return code value <br> <br>    HANDLE hWait[] = { (HANDLE) m_RenderEvent }; <br> <br>    // Enter the modified message loop <br> <br>    while (TRUE) { <br> <br>        // We use this to wait for two different kinds of events, the first </code></pre>
<p>
</p>
<pre><code>// are the normal windows messages, the other is an event that will <br>        // be signaled when a sample is ready <br> <br>        dwResult = MsgWaitForMultipleObjects((DWORD) 1,     // Number events <br>                                             hWait,         // Event handle <br>                                             FALSE,         // Wait for either <br>                                             INFINITE,      // No timeout <br>                                             QS_ALLINPUT);  // All messages <br> <br>        // Has a sample become ready to render <br>        if (dwResult == WAIT_OBJECT_0) { <br>            DrawWaveform(); <br>        } <br> <br>        // Process the thread's window message <br> <br>        while (PeekMessage(&amp;Message,NULL,(UINT) 0,(UINT) 0,PM_REMOVE)) { <br> <br>            // Check for the WM_QUIT message <br> <br>            if (Message.message == WM_QUIT) { <br>                return NOERROR; <br>            } <br> <br>            // Send the message to the window procedure <br> <br>            TranslateMessage(&amp;Message); <br>            DispatchMessage(&amp;Message); <br>        } <br>    } <br> <br>} // MessageLoop <br> <br> <br>// <br>// WindowMessageLoop <br>// <br>// This creates a window and processes it's messages on a separate thread <br>// <br>DWORD __stdcall CScopeWindow::WindowMessageLoop(LPVOID lpvThreadParm) <br>{ <br>    CScopeWindow *pScopeWindow;     // The owner renderer object <br> <br>    // Cast the thread parameter to be our owner object <br>    pScopeWindow = (CScopeWindow *) lpvThreadParm; <br> <br>    pScopeWindow-&gt;m_hwndDlg = <br>        CreateDialogParam( <br>            pScopeWindow-&gt;m_hInstance,        // Handle of app instance <br>            MAKEINTRESOURCE (IDD_SCOPEDIALOG),// Dialog box template <br>            NULL,                        // Handle of owner window <br>            (DLGPROC) ScopeDlgProc,        // Address of dialog procedure <br>            (LONG) pScopeWindow                 // Initialization value <br>        ); <br> <br>    if (pScopeWindow-&gt;m_hwndDlg != NULL) <br>    { <br>        // Initialise the window, then signal the constructor that it can <br>        // continue and then unlock the object's critical section and <br>        // process messages <br> <br>        pScopeWindow-&gt;InitialiseWindow(pScopeWindow-&gt;m_hwndDlg); <br>    } <br> <br>    pScopeWindow-&gt;m_SyncWorker.Set(); <br> <br>    if (pScopeWindow-&gt;m_hwndDlg != NULL) <br>    { <br>        pScopeWindow-&gt;MessageLoop(); <br>    } <br> <br>    ExitThread(TRUE); <br>    return TRUE; <br> <br>} // WindowMessageLoop <br> <br> <br>// <br>// OnPaint <br>// <br>// WM_PAINT message <br>// <br>BOOL CScopeWindow::OnPaint() <br>{ <br>    DrawWaveform(); <br>    return TRUE; <br> <br>} // OnPaint <br> <br> <br>// <br>// ClearWindow <br>// <br>// Clear the scope to black and draw the center tickmarks <br>// <br>void CScopeWindow::ClearWindow(HDC hdc) <br>{ <br>    int y = m_Height / 2; <br> <br>    SetMapMode (hdc, MM_TEXT); <br>    SetWindowOrgEx (hdc, 0, 0, NULL); <br>    SetViewportOrgEx (hdc, 0, 0, NULL); <br> <br>    // Paint the entire window black <br>    PatBlt(hdc,            // Handle of device context <br>           (INT) 0,        // x-coord of upper-left corner <br>           (INT) 0,        // y-coord of upper-left corner <br>           m_Width,        // Width of rectangle to be filled <br>           m_Height,       // Height of rectangle to be filled <br>           BLACKNESS);     // Raster operation code <br> <br>    // Draw the horizontal line <br>    HPEN hPenOld = (HPEN) SelectObject (hdc, m_hPenTicks); <br>    MoveToEx (hdc, 0, y, NULL); <br>    LineTo (hdc, m_Width, y); <br> <br>    // Draw the tickmarks <br>    float inc = (float) m_Width / 10; <br>    int pos, j; <br>    int TickPoint; <br>    for (j = 0; j &lt;= 10; j++) { <br>        if (j == 0 || j == 5 || j == 10) <br>            TickPoint =  m_Height / 15; <br>        else <br>            TickPoint = m_Height / 30; <br>        pos = (int) (j * inc); <br>        MoveToEx (hdc, pos, y + TickPoint, NULL); <br>        LineTo (hdc, pos, y - TickPoint); <br>    } <br>    SelectObject (hdc, hPenOld); <br> <br>} // ClearWindow <br> <br> <br>// <br>// DrawPartialWaveform <br>// <br>// Draw a part of the Oscilloscope waveform - IndexStart and IndexEnd <br>// are pointers into the m_pPoints array (in LOGICAL COORDINATES) <br>// while ViewpointStart and ViewpointEnd are in SCREEN COORDINATES <br>// <br>void CScopeWindow::DrawPartialWaveform(HDC hdc, <br>                                       int IndexStart, <br>                                       int IndexEnd, <br>                                       int ViewportStart, <br>                                       int ViewportEnd) <br>{ <br>    int nPoints = IndexEnd - IndexStart; <br>    int nViewportWidth = ViewportEnd - ViewportStart; <br>    ASSERT (IndexStart + nPoints &lt; m_nPoints); <br> <br>    // Origin at lower left, x increases up, y increases to right <br>    SetMapMode (hdc, MM_ANISOTROPIC); <br> <br>    SetWindowOrgEx (hdc, IndexStart, 0, NULL); <br>    SetWindowExtEx (hdc, nPoints, (int) (m_MaxValue / GainEntries[m_LGain].GainValue), NULL); <br>    SetViewportExtEx (hdc, nViewportWidth, -m_Height / 2, NULL); <br>    SetViewportOrgEx (hdc, ViewportStart, m_LOffset + m_Height / 2, NULL); <br> <br>    HPEN OldPen = (HPEN) SelectObject (hdc, m_hPen1); <br>    Polyline (hdc, m_pPoints1 + IndexStart, nPoints + 1); <br>    SelectObject (hdc, OldPen); <br> <br>    if (m_pPoints2) { <br>        SetWindowOrgEx (hdc, IndexStart, 0, NULL); <br>        SetWindowExtEx (hdc, nPoints, (int) (m_MaxValue / GainEntries[m_RGain].GainValue), NULL); <br>        SetViewportExtEx (hdc, nViewportWidth, -m_Height / 2, NULL); <br>        SetViewportOrgEx (hdc, ViewportStart, m_ROffset + m_Height / 2, NULL); <br> <br>        HPEN OldPen = (HPEN) SelectObject (hdc, m_hPen2); <br>        Polyline (hdc, m_pPoints2 + IndexStart, nPoints + 1); <br>        SelectObject (hdc, OldPen); <br>    } <br> <br>} // DrawPartialWaveform <br> <br> <br>// <br>// DrawWaveform <br>// <br>// Draw the full Oscilloscope waveform <br>// <br>void CScopeWindow::DrawWaveform(void) <br>{ <br>    CAutoLock lock(m_pRenderer); <br>    TCHAR szT[40]; <br> <br>    if (m_pPoints1 == NULL) <br>        return; <br> <br>    HDC hdc = GetWindowDC (m_hwnd);  // WindowDC has clipping region <br>    HDC hdcT = CreateCompatibleDC (hdc); <br>    HBITMAP hBitmapOld = (HBITMAP) SelectObject (hdcT, m_hBitmap); <br> <br>    ClearWindow (hdcT); <br> <br>    int StartOffset; <br>    int IndexEdge; <br>    int IndexStart1, IndexEnd1; <br>    int IndexStart2, IndexEnd2; <br>    int PointsToDisplay, PointsToDisplay1, PointsToDisplay2; <br>    int ViewportBreak; <br>    int OffsetTimeMS; <br>    BOOL fWraps;                // If segment to display wraps around 0 <br> <br>    PointsToDisplay = m_nPoints / Timebases [m_nTimebase].TBDivisor; <br> <br>    StartOffset = (m_nIndex - 1) - m_TBScroll; <br>    if (StartOffset &lt; 0) <br>        StartOffset += m_nPoints; <br> <br>    if (m_fTriggerPosZeroCrossing) { <br>        SearchForPosZeroCrossing(StartOffset, &amp;IndexEdge); <br>        IndexEnd2 = IndexEdge; <br>    } else { <br>        IndexEnd2 = StartOffset; <br>    } <br>    IndexStart2 = IndexEnd2 - PointsToDisplay;    // can be negative <br> <br>    if (IndexEnd2 &gt; m_nIndex) <br>        OffsetTimeMS = (m_nIndex + (m_nPoints - IndexEnd2)) * 1000 / m_nSamplesPerSec; <br>    else <br>        OffsetTimeMS = (m_nIndex - IndexEnd2) * 1000 / m_nSamplesPerSec; <br> <br>    if (fWraps = (IndexStart2 &lt; 0)) { <br>        IndexStart1 = IndexStart2 + m_nPoints; <br>        IndexEnd1 = m_nPoints - 1; <br>        IndexStart2 = 0; <br> <br>        PointsToDisplay1 = IndexEnd1 - IndexStart1; <br>    } <br> <br>    PointsToDisplay2 = IndexEnd2 - IndexStart2; <br> <br>    if (fWraps) { <br>        ViewportBreak = (int) (m_Width * (float) PointsToDisplay1 / PointsToDisplay); <br> <br>        // Draw the first section (from the end of the POINT array) <br>        DrawPartialWaveform(hdcT, <br>            IndexStart1, IndexEnd1,     // Index start, Index end <br>            0, ViewportBreak);          // Window start, Window end <br> <br>        // Draw the second section (from the beginning of the POINT array) <br>        DrawPartialWaveform(hdcT, <br>            IndexStart2, IndexEnd2,     // Index start, Index end <br>            ViewportBreak, m_Width);    // Window start, Window end <br>    } else { <br>        DrawPartialWaveform(hdcT, <br>            IndexStart2, IndexEnd2,     // Index start, Index end <br>            0, m_Width);                // Window start, Window end <br>    } <br> <br>    SetMapMode (hdcT, MM_TEXT); <br>    SetWindowOrgEx (hdcT, 0, 0, NULL); <br>    SetViewportOrgEx (hdcT, 0, 0, NULL); <br> <br>    BitBlt(hdc,        // Handle of destination device context <br>            0,        // x-coordinate of upper-left corner <br>            0,         // y-coordinate of upper-left corner <br>            m_Width,// Wwidth of destination rectangle <br>            m_Height,// Height of destination rectangle <br>            hdcT,// Handle of source device context <br>            0,          // x-coordinate of source rectangle <br>            0,          // y-coordinate of source rectangle <br>            SRCCOPY); // Raster operation code <br> <br>    SelectObject (hdcT, hBitmapOld); <br>    DeleteDC (hdcT); <br>    GdiFlush(); <br>    ReleaseDC (m_hwnd, hdc); <br> <br>    // Show the size of the last buffer received <br>    wsprintf (szT, "%d", m_LastMediaSampleSize); <br>    SetDlgItemText (m_hwndDlg, IDC_BUFSIZE, szT); <br> <br>    // Show the timestamps <br>    LONG mSStart; <br>    LONG mSEnd = m_EndSample.Millisecs(); <br> <br>    CRefTime rt; <br>    m_pRenderer-&gt;StreamTime (rt); <br> <br>    // Delta is the difference between the last sample received and <br>    // the current sample playing according to the StreamTime <br>    LONG mSDelta = mSEnd - rt.Millisecs(); <br>    wsprintf (szT, "%d.%d", mSDelta / 1000, abs (mSDelta) % 1000); <br>    SetDlgItemText (m_hwndDlg, IDC_TS_DELTA, szT); <br> <br>    // Show the Delta point on the horizontal trackbar as the selection <br>    if (mSDelta &lt; 1000) { <br>        int SelectStart = m_nPoints - (m_nPoints * mSDelta / 1000); <br>        SelectStart /= 2; <br>        int SelectEnd = SelectStart + m_nPoints / 100; <br>        SendMessage(m_hwndTBScroll, TBM_SETSEL, TRUE, MAKELONG (SelectStart, SelectEnd)); <br>    } <br>    else <br>        SendMessage(m_hwndTBScroll, TBM_SETSEL, TRUE, 0L); // hide the selection <br> <br>    // Display the begin and end times of the sweep <br>    mSEnd -= OffsetTimeMS; <br>    mSStart = mSEnd - PointsToDisplay * 1000 / m_nSamplesPerSec; <br> <br>    wsprintf (szT, "%d.%d", mSStart / 1000, abs (mSStart) % 1000); <br>    SetDlgItemText (m_hwndDlg, IDC_TS_START, szT); <br> <br>    wsprintf (szT, "%d.%d", mSEnd / 1000, abs (mSEnd) % 1000); <br>    SetDlgItemText (m_hwndDlg, IDC_TS_LAST, szT); <br> <br>} // DrawWaveform <br> <br> <br>// <br>// AllocWaveBuffers <br>// <br>// Allocate a 1 second buffer for each channel <br>// This is only called when the format changes <br>// Return TRUE if allocations succeed <br>// <br>BOOL CScopeWindow::AllocWaveBuffers() <br>{ <br>    int j; <br> <br>    if (m_pPoints1) delete [] m_pPoints1; <br>    if (m_pPoints2) delete [] m_pPoints2; <br> <br>    m_pPoints1 = NULL; <br>    m_pPoints2 = NULL; <br>    m_nPoints = 0; <br> <br>    m_nPoints = m_nSamplesPerSec; <br> <br>    if (m_pPoints1 = new POINT [m_nSamplesPerSec]) { <br>        m_nPoints = m_nSamplesPerSec; <br>        for (j = 0; j &lt; m_nSamplesPerSec; j++) <br>            m_pPoints1[j].x = j; <br>    } <br> <br>    if (m_nChannels == 2) { <br>        if (m_pPoints2 = new POINT [m_nSamplesPerSec]) <br>            for (j = 0; j &lt; m_nSamplesPerSec; j++) <br>                m_pPoints2[j].x = j; <br>    } <br> <br>    // Return TRUE if allocations succeeded <br>    ASSERT ((m_pPoints1 != NULL) &amp;&amp; ((m_nChannels == 2) ? (m_pPoints2 != NULL) : TRUE)); <br>    return ((m_pPoints1 != NULL) &amp;&amp; ((m_nChannels == 2) ? (m_pPoints2 != NULL) : TRUE)); <br> <br>} // AllocWaveBuffers <br> <br> <br>// <br>// SearchForPosZeroCrossing <br>// <br>// Searches backward for a positive going zero crossing in the waveform <br>// <br>void CScopeWindow::SearchForPosZeroCrossing(int StartPoint, int * IndexEdge) <br>{ <br>    if (StartPoint &lt; 0) <br>        StartPoint = 0; <br> <br>    int cur, last, j; <br> <br>    *IndexEdge = StartPoint; <br> <br>    last = m_pPoints1[StartPoint].y; <br> <br>    for (j = m_nPoints; j &gt; 0; j--) { <br>        if (--StartPoint &lt; 0) <br>            StartPoint = m_nPoints - 1; <br>        cur = m_pPoints1[StartPoint].y; <br>        if (cur &lt; 0 &amp;&amp; last &gt;= 0) { <br>            *IndexEdge = StartPoint; <br>            break; <br>        } <br>        last = cur; <br>    } <br> <br>} // SearchForPosZeroCrossing <br> <br> <br>// <br>// CopyWaveform <br>// <br>// Copy the current MediaSample into a POINT array so we can use GDI <br>// to paint the waveform.  The POINT array contains a 1 second history <br>// of the past waveform.  The "Y" values are normalized to a range of <br>// +128 to -127 within the POINT array. <br>// <br>void CScopeWindow::CopyWaveform(IMediaSample *pMediaSample) <br>{ <br>    BYTE *pWave;                // Pointer to image data <br>    int  nBytes; <br>    int  nSamplesPerChan; <br> <br>    pMediaSample-&gt;GetPointer(&amp;pWave); <br>    ASSERT(pWave != NULL); <br> <br>    nBytes = pMediaSample-&gt;GetActualDataLength(); <br>    nSamplesPerChan = nBytes / (m_nChannels * m_nBlockAlign); <br> <br>    switch (m_nBitsPerSample + m_nChannels) { <br>        BYTE * pb; <br>        WORD * pw; <br> <br>        case 9: <br>        {   // Mono, 8-bit <br>            pb = pWave; <br>            while (nSamplesPerChan--) { <br>                m_pPoints1[m_nIndex].y = (int)*pb++ - 127;  // Make zero centered <br>                if (++m_nIndex == m_nSamplesPerSec) <br>                    m_nIndex = 0; <br>            } <br>        } <br>        break; <br> <br>        case 10: <br>        {   // Stereo, 8-bit <br>            pb = pWave; <br>            while (nSamplesPerChan--) { <br>                m_pPoints1[m_nIndex].y = (int)*pb++ - 127; // Make zero centered <br>                m_pPoints2[m_nIndex].y = (int)*pb++ - 127; <br>                if (++m_nIndex == m_nSamplesPerSec) <br>                    m_nIndex = 0; <br>            } <br>        } <br>        break; <br> <br>        case 17: <br>        { // Mono, 16-bit <br>            pw = (WORD *) pWave; <br>            while (nSamplesPerChan--) { <br>                m_pPoints1[m_nIndex].y = (int) ((short) *pw++) / 256; <br>                if (++m_nIndex == m_nSamplesPerSec) <br>                    m_nIndex = 0; <br>            } <br>        } <br>        break; <br> <br>        case 18: <br>        { // Stereo, 16-bit <br>            pw = (WORD *)pWave; <br>            while (nSamplesPerChan--) { <br>                m_pPoints1[m_nIndex].y = (int) ((short) *pw++) / 256; <br>                m_pPoints2[m_nIndex].y = (int) ((short) *pw++) / 256; <br>                if (++m_nIndex == m_nSamplesPerSec) <br>                    m_nIndex = 0; <br>            } <br>        } <br>        break; <br> <br>        default: <br>            ASSERT(0); <br>            break; <br> <br>    } // End of format switch <br> <br>} // CopyWaveform <br> <br> <br>// <br>// Receive <br>// <br>// Called when the input pin receives another sample. <br>// Copy the waveform to our circular 1 second buffer <br>// <br>HRESULT CScopeWindow::Receive(IMediaSample *pSample) <br>{ <br>    CAutoLock cAutoLock(this); <br>    ASSERT(pSample != NULL); <br> <br>    // Has our UI been frozen <br> <br>    if (m_fFreeze) { <br>        return NOERROR; <br>    } <br> <br>    REFERENCE_TIME tStart, tStop; <br>    pSample-&gt;GetTime (&amp;tStart,&amp;tStop); <br>    m_StartSample = tStart; <br>    m_EndSample = tStop; <br> <br>    // Ignore zero-length samples <br>    if ((m_LastMediaSampleSize = pSample-&gt;GetActualDataLength()) == 0) <br>        return NOERROR; <br> <br>    if (m_bStreaming == TRUE) { <br>        CopyWaveform (pSample);     // Copy data to our circular buffer <br>        SetEvent(m_RenderEvent);    // Set an event to display the <br>                                    // new data on another thread <br>        return NOERROR; <br>    } <br>    return NOERROR; <br> <br>} // Receive <br> <br> <br>// <br>// DllRegisterServer <br>// <br>// Handles DLL registry <br>// <br>STDAPI DllRegisterServer() <br>{ <br>    return AMovieDllRegisterServer2( TRUE ); <br> <br>} // DllRegisterServer <br> <br> <br>// <br>// DllUnregisterServer <br>// <br>STDAPI DllUnregisterServer() <br>{ <br>    return AMovieDllRegisterServer2( FALSE ); <br> <br>} // DllUnregisterServer <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
