<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SCOPE.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2924"></a>SCOPE.H</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>// Oscilloscope filter <br> <br> <br>// { 35919F40-E904-11ce-8A03-00AA006ECB65 } <br>DEFINE_GUID(CLSID_Scope, <br>0x35919f40, 0xe904, 0x11ce, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65); <br> <br>class CScopeFilter; <br>class CScopeWindow; <br> <br>// Class supporting the scope input pin <br> <br>class CScopeInputPin : public CBaseInputPin <br>{ <br>    friend class CScopeFilter; <br>    friend class CScopeWindow; <br> <br>private: <br> <br>    CScopeFilter *m_pFilter;         // The filter that owns us <br> <br>public: <br> <br>    CScopeInputPin(CScopeFilter *pTextOutFilter, <br>                   HRESULT *phr, <br>                   LPCWSTR pPinName); <br>    ~CScopeInputPin(); <br> <br>    // Lets us know where a connection ends <br>    HRESULT BreakConnect(); <br> <br>    // Check that we can support this input type <br>    HRESULT CheckMediaType(const CMediaType *pmt); <br> <br>    // Actually set the current format <br>    HRESULT SetMediaType(const CMediaType *pmt); <br> <br>    // IMemInputPin virtual methods <br> <br>    // Override so we can show and hide the window <br>    HRESULT Active(void); <br>    HRESULT Inactive(void); <br> <br>    // Here's the next block of data from the stream. <br>    // AddRef it if you are going to hold onto it <br>    STDMETHODIMP Receive(IMediaSample *pSample); <br> <br>}; // CScopeInputPin <br> <br> <br>// This class looks after the management of a window. When the class gets <br>// instantiated the constructor spawns off a worker thread that does all <br>// the window work. The original thread waits until it is signaled to <br>// continue. The worker thread first registers the window class if it <br>// is not already done. Then it creates a window and sets it's size to <br>// a default iWidth by iHeight dimensions. The worker thread MUST be the <br>// one who creates the window as it is the one who calls GetMessage. When <br>// it has done all this it signals the original thread which lets it <br>// continue, this ensures a window is created and valid before the <br>// constructor returns. The thread start address is the WindowMessageLoop <br>// function. This takes as it's initialisation parameter a pointer to the <br>// CVideoWindow object that created it, the function also initialises it's <br>// window related member variables such as the handle and device contexts <br> <br>// These are the video window styles <br> <br>const DWORD dwTEXTSTYLES = (WS_POPUP | WS_CAPTION | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX | WS_CLIPCHILDREN); <br>const DWORD dwCLASSSTYLES = (CS_HREDRAW | CS_VREDRAW | CS_BYTEALIGNCLIENT | CS_OWNDC); <br>const LPTSTR RENDERCLASS = TEXT("OscilloscopeWindowClass"); <br>const LPTSTR TITLE = TEXT("Oscilloscope"); <br> <br>const int iWIDTH = 320;             // Initial window width <br>const int iHEIGHT = 240;            // Initial window height <br>const int WM_GOODBYE (WM_USER + 2); // Sent to close the window <br> <br>class CScopeWindow : public CCritSec <br>{ <br>    friend class CScopeInputPin; <br>    friend class CScopeFilter; <br> <br>private: <br> <br>    HINSTANCE m_hInstance;          // Global module instance handle <br>    CScopeFilter *m_pRenderer;      // The owning renderer object <br>    HWND m_hwndDlg;                 // Handle for our dialog <br>    HWND m_hwnd;                    // Handle for the graph window <br>    HBRUSH m_hBrushBackground;      // Used to paint background <br>    HPEN m_hPen1;                   // We use two pens for drawing <br>    HPEN m_hPen2;                   //  the waveforms in the window <br>    HPEN m_hPenTicks;               // Used to draw ticks at bottom <br>    HBITMAP m_hBitmap;              // Draw all waveforms into here <br>    HANDLE m_hThread;               // Our worker thread <br>    DWORD m_ThreadID;               // Worker thread ID <br>    CAMEvent m_SyncWorker;          // Synchronise with worker thread <br>    CAMEvent m_RenderEvent;         // Signals sample to render <br>    LONG m_Width;                   // Client window width <br>    LONG m_Height;                  // Client window height <br>    BOOL m_bActivated;              // Has the window been activated <br>    CRefTime m_StartSample;         // Most recent sample start time <br>    CRefTime m_EndSample;           // And it's associated end time <br>    BOOL m_bStreaming;              // Are we currently streaming <br>    POINT *m_pPoints1;              // Array of points to graph Channel1 <br>    POINT *m_pPoints2;              // Array of points to graph Channel2 <br>    int m_nPoints;                  // Size of m_pPoints[1|2] <br>    int m_nIndex;                   // Index of last sample written <br>    int m_LastMediaSampleSize;      // Size of last MediaSample <br> <br>    int m_nChannels;                // number of active channels <br>    int m_nSamplesPerSec;           // Samples per second <br>    int m_nBitsPerSample;           // Number bits per sample <br>    int m_nBlockAlign;              // Alignment on the samples <br>    int m_MaxValue;                 // Max Value of the POINTS array <br> <br>    int m_LGain;                    // Left channel control settings <br>    int m_LOffset;                  //  And likewise its offset <br>    int m_RGain;                    // Right channel control settings <br>    int m_ROffset;                  //  And likewise its offset <br>    int m_nTimebase;                // Timebase settings <br>    BOOL m_fFreeze;                 // Flag toi signal we're UI frozen <br>    int m_TBScroll;                 // Holds position in scroll range <br> <br>    // Hold window handles to controls <br> <br>    HWND m_hwndLGain; <br>    HWND m_hwndLOffset; <br>    HWND m_hwndLGainText; <br>    HWND m_hwndLTitle; <br>    HWND m_hwndRGain; <br>    HWND m_hwndROffset; <br>    HWND m_hwndRGainText; <br>    HWND m_hwndRTitle; <br>    HWND m_hwndTimebase; <br>    HWND m_hwndFreeze; <br>    HWND m_hwndTBScroll; <br>    HWND m_hwndTBStart; <br>    HWND m_hwndTBEnd; <br>    HWND m_hwndTBDelta; <br> <br>    BOOL m_fTriggerPosZeroCrossing; <br> <br>    // These create and manage a video window on a separate thread <br> <br>    HRESULT UninitialiseWindow(); <br>    HRESULT InitialiseWindow(HWND hwnd); <br>    HRESULT MessageLoop(); <br> <br>    static DWORD __stdcall WindowMessageLoop(LPVOID lpvThreadParm); <br> <br>    // Maps windows message loop into C++ virtual methods <br>    friend LRESULT CALLBACK WndProc(HWND hwnd,      // Window handle <br>                                    UINT uMsg,      // Message ID <br>                                    WPARAM wParam,  // First parameter <br>                                    LPARAM lParam); // Other parameter <br> <br>    // Called when we start and stop streaming <br>    HRESULT ResetStreamingTimes(); <br> <br>    // Window message handlers <br>    BOOL OnClose(); <br>    BOOL OnPaint(); <br> <br>    // Draw the waveform <br>    void ClearWindow(HDC hdc); <br>    BOOL AllocWaveBuffers(void); <br>    void SearchForPosZeroCrossing(int StartPoint, int * IndexEdge); <br>    void CopyWaveform(IMediaSample *pMediaSample); <br> <br>    void DrawPartialWaveform(HDC hdc, <br>                             int IndexStart, <br>                             int IndexEnd, <br>                             int ViewportStart, <br>                             int ViewportEnd); <br> <br>    void DrawWaveform(void); <br>    void SetControlRanges(HWND hDlg); <br>    void SetHorizScrollRange(HWND hDlg); <br>    void ProcessVertScrollCommands(HWND hDlg, WPARAM wParam, LPARAM lParam); <br>    void ProcessHorizScrollCommands(HWND hDlg, WPARAM wParam, LPARAM lParam); <br> <br>    friend BOOL CALLBACK ScopeDlgProc(HWND hwnd,        // Window handle <br>                                    UINT uMsg,          // Message ID <br>                                    WPARAM wParam,      // First parameter <br>                                    LPARAM lParam);     // Other parameter <br> <br>public: <br> <br>    // Constructors and destructors <br> <br>    CScopeWindow(TCHAR *pName, CScopeFilter *pRenderer, HRESULT *phr); <br>    virtual ~CScopeWindow(); <br> <br>    HRESULT StartStreaming(); <br>    HRESULT StopStreaming(); <br>    HRESULT InactivateWindow(); <br>    HRESULT ActivateWindow(); <br> <br>    // Called when the input pin receives a sample <br>    HRESULT Receive(IMediaSample * pIn); <br> <br>}; // CScopeWindow <br> <br> <br>// This is the COM object that represents the oscilloscope filter <br> <br>class CScopeFilter : public CBaseFilter, public CCritSec <br>{ <br> <br>public: <br>    // Implements the IBaseFilter and IMediaFilter interfaces <br> <br>    DECLARE_IUNKNOWN <br> <br> <br>    STDMETHODIMP Stop(); <br>    STDMETHODIMP Pause(); <br>    STDMETHODIMP Run(REFERENCE_TIME tStart); <br> <br>public: <br> <br>    CScopeFilter(LPUNKNOWN pUnk,HRESULT *phr); <br>    virtual ~CScopeFilter(); <br> <br>    // Return the pins that we support <br>    int GetPinCount(); <br>    CBasePin *GetPin(int n); <br> <br>    // This goes in the factory template table to create new instances <br>    static CUnknown * WINAPI CreateInstance(LPUNKNOWN, HRESULT *); <br> <br>    STDMETHODIMP JoinFilterGraph(IFilterGraph * pGraph, LPCWSTR pName); <br> <br>private: <br> <br>    // The nested classes may access our private state <br>    friend class CScopeInputPin; <br>    friend class CScopeWindow; <br> <br>    CScopeInputPin *m_pInputPin;   // Handles pin interfaces <br>    CScopeWindow m_Window;         // Looks after the window <br> <br>}; // CScopeFilter <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
