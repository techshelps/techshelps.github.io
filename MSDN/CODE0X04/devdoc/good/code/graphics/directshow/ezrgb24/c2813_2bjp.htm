<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>EZRGB24.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2815"></a>EZRGB24.CPP</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>// <br>// <br>// What this sample illustrates <br>// <br>// A special effects filter that does image filtering and colour changes. We <br>// work on decompressed true colour images and apply a range of effects. The <br>// effect we do and when it is applied to the video stream can be configured <br>// through a custom interface we implement and which our property page uses. <br>// We can also save/load our property settings by supporting IPersistStream <br>// <br>// <br>// Summary <br>// <br>// This is a sample special effects filter - it works only with RGB24 formats <br>// We can be inserted between video decoders and renderers and apply a number <br>// of different effects to the decompressed video stream. For example we can <br>// apply red, green or blue filters to the images. We also have posterise and <br>// greying effects amongst others. The effect can be applied to the stream at <br>// a given start and end media time, this is defined by using the IIPEffect <br>// interface and can be viewed by using the property page this filter supports <br>// <br>// <br>// Demonstration instructions <br>// <br>// Start GRAPHEDT available in the ActiveMovie SDK tools. Drag and drop any <br>// MPEG, AVI or MOV file into the tool and it will be rendered. Then go to <br>// the video renderer box and disconnect its input pin from the filter it is <br>// connected to. Go to the Graph menu and select Insert Filters, from the <br>// dialog select the Special Effects filter and dismiss the dialog. back in <br>// the tool workspace connect the output of the decoder to the input of the <br>// sample filter and then connect the output of the sample to the input of <br>// the video renderer (GRAPHEDT may put a colour space convertor in between) <br>// Then press play and then right click on the sample to select a transform <br>// by default a transform will be applied from 2 to 7 seconds into the movie <br>// <br>// <br>// Files <br>// <br>// ezprop.cpp           A property page to control the video effects <br>// ezprop.h             Class definition for the property page object <br>// ezprop.rc            Dialog box template for the property page <br>// ezrgb24.cpp          Main filter code that does the special effects <br>// ezrgb24.def          What APIs we import and export from this DLL <br>// ezrgb24.h            Class definition for the special effects filter <br>// ezrgb24.reg          What goes in the registry to make us work <br>// ezuids.h             Header file containing the filter CLSIDs <br>// iez.h                Defines the special effects custom interface <br>// makefile             How we build it... <br>// resource.h           Microsoft Visual C++ generated resource file <br>// <br>// <br>// Base classes used <br>// <br>// CTransformFilter     A transform filter with one input and output pin <br>// CPersistStream       Handles the grunge of supporting IPersistStream <br>// <br>// <br> <br> <br>#include &lt;windows.h&gt; <br>#include &lt;streams.h&gt; <br>#include &lt;initguid.h&gt; <br>#if (1100 &gt; _MSC_VER) <br>#include &lt;olectlid.h&gt; <br>#else <br>#include &lt;olectl.h&gt; <br>#endif <br>#include "EZuids.h" <br>#include "iEZ.h" <br>#include "EZprop.h" <br>#include "EZrgb24.h" <br>#include "resource.h" <br> <br> <br>// Setup information <br> <br>const AMOVIESETUP_MEDIATYPE sudPinTypes = <br>{ <br>    &amp;MEDIATYPE_Video,       // Major type <br>    &amp;MEDIASUBTYPE_NULL      // Minor type <br>}; <br> <br>const AMOVIESETUP_PIN sudpPins[] = <br>{ <br>    { L"Input",             // Pins string name <br>      FALSE,                // Is it rendered <br>      FALSE,                // Is it an output <br>      FALSE,                // Are we allowed none <br>      FALSE,                // And allowed many <br>      &amp;CLSID_NULL,          // Connects to filter <br>      NULL,                 // Connects to pin <br>      1,                    // Number of types <br>      &amp;sudPinTypes          // Pin information <br>    }, <br>    { L"Output",            // Pins string name <br>      FALSE,                // Is it rendered <br>      TRUE,                 // Is it an output <br>      FALSE,                // Are we allowed none <br>      FALSE,                // And allowed many <br>      &amp;CLSID_NULL,          // Connects to filter <br>      NULL,                 // Connects to pin <br>      1,                    // Number of types <br>      &amp;sudPinTypes          // Pin information <br>    } <br>}; <br> <br>const AMOVIESETUP_FILTER sudEZrgb24 = <br>{ <br>    &amp;CLSID_EZrgb24,         // Filter CLSID <br>    L"Image Effects",       // String name <br>    MERIT_DO_NOT_USE,       // Filter merit <br>    2,                      // Number of pins <br>    sudpPins                // Pin information <br>}; <br> <br> <br>// List of class IDs and creator functions for the class factory. This <br>// provides the link between the OLE entry point in the DLL and an object <br>// being created. The class factory will call the static CreateInstance <br> <br>CFactoryTemplate g_Templates[] = { <br>    { L"Image Effects" <br>    , &amp;CLSID_EZrgb24 <br>    , CEZrgb24::CreateInstance <br>    , NULL <br>    , &amp;sudEZrgb24 } <br>  , <br>    { L"Special Effects" <br>    , &amp;CLSID_EZrgb24PropertyPage <br>    , CEZrgb24Properties::CreateInstance } <br>}; <br>int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]); <br> <br> <br>// <br>// DllRegisterServer <br>// <br>// Handles sample registry and unregistry <br>// <br>STDAPI DllRegisterServer() <br>{ <br>    return AMovieDllRegisterServer2( TRUE ); <br> <br>} // DllRegisterServer <br> <br> <br>// <br>// DllUnregisterServer <br>// <br>STDAPI DllUnregisterServer() <br>{ <br>    return AMovieDllRegisterServer2( FALSE ); <br> <br>} // DllUnregisterServer <br> <br> <br>// <br>// Constructor <br>// <br>CEZrgb24::CEZrgb24(TCHAR *tszName, <br>                   LPUNKNOWN punk, <br>                   HRESULT *phr) : <br>    CTransformFilter(tszName, punk, CLSID_EZrgb24), <br>    m_effect(IDC_RED), <br>    m_lBufferRequest(1), <br>    CPersistStream(punk, phr) <br>{ <br>    char sz[60]; <br>    GetProfileStringA("Quartz", "EffectStart", "2.0", sz, 60); <br>    m_effectStartTime = COARefTime(atof(sz)); <br>    GetProfileStringA("Quartz", "EffectLength", "5.0", sz, 60); <br>    m_effectTime = COARefTime(atof(sz)); <br> <br>} // (Constructor) <br> <br> <br>// <br>// CreateInstance <br>// <br>// Provide the way for COM to create a EZrgb24 object <br>// <br>CUnknown *CEZrgb24::CreateInstance(LPUNKNOWN punk, HRESULT *phr) <br>{ <br>    CEZrgb24 *pNewObject = new CEZrgb24(NAME("Image Effects"), punk, phr); <br>    if (pNewObject == NULL) { <br>        *phr = E_OUTOFMEMORY; <br>    } <br>    return pNewObject; <br> <br>} // CreateInstance <br> <br> <br>// <br>// NonDelegatingQueryInterface <br>// <br>// Reveals IIPEffect and ISpecifyPropertyPages <br>// <br>STDMETHODIMP CEZrgb24::NonDelegatingQueryInterface(REFIID riid, void **ppv) <br>{ <br>    CheckPointer(ppv,E_POINTER); <br> <br>    if (riid == IID_IIPEffect) { <br>        return GetInterface((IIPEffect *) this, ppv); <br>    } else if (riid == IID_ISpecifyPropertyPages) { <br>        return GetInterface((ISpecifyPropertyPages *) this, ppv); <br>    } else { <br>        return CTransformFilter::NonDelegatingQueryInterface(riid, ppv); <br>    } <br> <br>} // NonDelegatingQueryInterface <br> <br> <br>// <br>// Transform <br>// <br>// Copy the input sample into the output sample - then transform the output <br>// sample 'in place'. If we have all keyframes, then we shouldn't do a copy <br>// If we have cinepak or indeo and are decompressing frame N it needs frame <br>// decompressed frame N-1 available to calculate it, unless we are at a <br>// keyframe. So with keyframed codecs, you can't get away with applying the <br>// transform to change the frames in place, because you'll screw up the next <br>// frames decompression. The runtime MPEG decoder does not have keyframes in <br>// the same way so it can be done in place. We know if a sample is key frame <br>// as we transform because the sync point property will be set on the sample <br>// <br>HRESULT CEZrgb24::Transform(IMediaSample *pIn, IMediaSample *pOut) <br>{ <br>    // Copy the properties across <br> <br>    HRESULT hr = Copy(pIn, pOut); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br> <br>    // Check to see if it is time to do the sample <br> <br>    CRefTime tStart, tStop ; <br>    pIn-&gt;GetTime((REFERENCE_TIME *) &amp;tStart, (REFERENCE_TIME *) &amp;tStop); <br> <br>    if (tStart &gt;= m_effectStartTime) { <br>        if (tStop &lt;= (m_effectStartTime + m_effectTime)) { <br>            return Transform(pOut); <br>        } <br>    } <br>    return NOERROR; <br> <br>} // Transform <br> <br> <br>// <br>// Copy <br>// <br>// Make destination an identical copy of source <br>// <br>HRESULT CEZrgb24::Copy(IMediaSample *pSource, IMediaSample *pDest) const <br>{ <br>    // Copy the sample data <br> <br>    BYTE *pSourceBuffer, *pDestBuffer; <br>    long lSourceSize = pSource-&gt;GetActualDataLength(); <br>    long lDestSize= pDest-&gt;GetSize(); <br> <br>    ASSERT(lDestSize &gt;= lSourceSize); <br> <br>    pSource-&gt;GetPointer(&amp;pSourceBuffer); <br>    pDest-&gt;GetPointer(&amp;pDestBuffer); <br> <br>    CopyMemory( (PVOID) pDestBuffer,(PVOID) pSourceBuffer,lSourceSize); <br> <br>    // Copy the sample times <br> <br>    REFERENCE_TIME TimeStart, TimeEnd; <br>    if (NOERROR == pSource-&gt;GetTime(&amp;TimeStart, &amp;TimeEnd)) { <br>        pDest-&gt;SetTime(&amp;TimeStart, &amp;TimeEnd); <br>    } <br> <br>    LONGLONG MediaStart, MediaEnd; <br>    if (pSource-&gt;GetMediaTime(&amp;MediaStart,&amp;MediaEnd) == NOERROR) { <br>        pDest-&gt;SetMediaTime(&amp;MediaStart,&amp;MediaEnd); <br>    } <br> <br>    // Copy the Sync point property <br> <br>    HRESULT hr = pSource-&gt;IsSyncPoint(); <br>    if (hr == S_OK) { <br>        pDest-&gt;SetSyncPoint(TRUE); <br>    } <br>    else if (hr == S_FALSE) { <br>        pDest-&gt;SetSyncPoint(FALSE); <br>    } <br>    else {  // an unexpected error has occured... <br>        return E_UNEXPECTED; <br>    } <br> <br>    // Copy the media type <br> <br>    AM_MEDIA_TYPE *pMediaType; <br>    pSource-&gt;GetMediaType(&amp;pMediaType); <br>    pDest-&gt;SetMediaType(pMediaType); <br>    DeleteMediaType(pMediaType); <br> <br>    // Copy the preroll property <br> <br>    hr = pSource-&gt;IsPreroll(); <br>    if (hr == S_OK) { <br>        pDest-&gt;SetPreroll(TRUE); <br>    } <br>    else if (hr == S_FALSE) { <br>        pDest-&gt;SetPreroll(FALSE); <br>    } <br>    else {  // an unexpected error has occured... <br>        return E_UNEXPECTED; <br>    } <br> <br>    // Copy the discontinuity property <br> <br>    hr = pSource-&gt;IsDiscontinuity(); <br>    if (hr == S_OK) { <br>pDest-&gt;SetDiscontinuity(TRUE); <br>    } <br>    else if (hr == S_FALSE) { <br>        pDest-&gt;SetDiscontinuity(FALSE); <br>    } <br>    else {  // an unexpected error has occured... <br>        return E_UNEXPECTED; <br>    } <br> <br>    // Copy the actual data length <br> <br>    long lDataLength = pSource-&gt;GetActualDataLength(); <br>    pDest-&gt;SetActualDataLength(lDataLength); <br> <br>    return NOERROR; <br> <br>} // Copy <br> <br> <br>// <br>// Transform (in place) <br>// <br>// 'In place' apply the image effect to this sample <br>// <br>HRESULT CEZrgb24::Transform(IMediaSample *pMediaSample) <br>{ <br>    AM_MEDIA_TYPE* pType = &amp;m_pInput-&gt;CurrentMediaType(); <br>    VIDEOINFOHEADER *pvi = (VIDEOINFOHEADER *) pType-&gt;pbFormat; <br> <br>    BYTE *pData;                // Pointer to the actual image buffer <br>    long lDataLen;              // Holds length of any given sample <br>    unsigned int grey,grey2;    // Used when applying greying effects <br>    int iPixel;                 // Used to loop through the image pixels <br>    int temp,x,y;               // General loop counters for transforms <br>    RGBTRIPLE *prgb;            // Holds a pointer to the current pixel <br> <br>    pMediaSample-&gt;GetPointer(&amp;pData); <br>    lDataLen = pMediaSample-&gt;GetSize(); <br> <br>    // Get the image properties from the BITMAPINFOHEADER <br> <br>    int iPixelSize = pvi-&gt;bmiHeader.biBitCount / 8; <br>    int cxImage    = pvi-&gt;bmiHeader.biWidth; <br>    int cyImage    = pvi-&gt;bmiHeader.biHeight; <br>    int cbImage    = cyImage * cxImage * iPixelSize; <br>    int numPixels  = cxImage * cyImage; <br> <br>    switch (m_effect) <br>    { <br>        case IDC_NONE: break; <br> <br>        // Zero out the green and blue components to leave only the red <br>        // so acting as a filter - for better visual results, compute a <br>        // greyscale value for the pixel and make that the red component <br> <br>        case IDC_RED: <br> <br>            prgb = (RGBTRIPLE*) pData; <br>            for (iPixel=0; iPixel &lt; numPixels; iPixel++, prgb++) { <br>        prgb-&gt;rgbtGreen = 0; <br>                prgb-&gt;rgbtBlue = 0; <br>            } <br>            break; <br> <br>        case IDC_GREEN: <br> <br>            prgb = (RGBTRIPLE*) pData; <br>            for (iPixel=0; iPixel &lt; numPixels; iPixel++, prgb++) { <br>                prgb-&gt;rgbtRed = 0; <br>                prgb-&gt;rgbtBlue = 0; <br>            } <br>            break; <br> <br>        case IDC_BLUE: <br>            prgb = (RGBTRIPLE*) pData; <br>            for (iPixel=0; iPixel &lt; numPixels; iPixel++, prgb++) { <br>                prgb-&gt;rgbtRed = 0; <br>                prgb-&gt;rgbtGreen = 0; <br>            } <br>            break; <br> <br>        // Bitwise shift each component to the right by 1 <br>        // this results in the image getting much darker <br> <br>case IDC_DARKEN: <br> <br>            prgb = (RGBTRIPLE*) pData; <br>            for (iPixel=0; iPixel &lt; numPixels; iPixel++, prgb++) { <br>                prgb-&gt;rgbtRed = prgb-&gt;rgbtRed &gt;&gt; 1; <br>                prgb-&gt;rgbtGreen = prgb-&gt;rgbtGreen &gt;&gt; 1; <br>                prgb-&gt;rgbtBlue = prgb-&gt;rgbtBlue &gt;&gt; 1; <br>            } <br>            break; <br> <br>        // Toggle each bit - this gives a sort of X-ray effect <br> <br>        case IDC_XOR:  <br>            prgb = (RGBTRIPLE*) pData; <br>            for (iPixel=0; iPixel &lt; numPixels; iPixel++, prgb++) { <br>                prgb-&gt;rgbtRed = prgb-&gt;rgbtRed ^ 0xff; <br>                prgb-&gt;rgbtGreen = prgb-&gt;rgbtGreen ^ 0xff; <br>                prgb-&gt;rgbtBlue = prgb-&gt;rgbtBlue ^ 0xff; <br>            } <br>            break; <br> <br>        // Zero out the five LSB per each component <br> <br>        case IDC_POSTERIZE: <br>            prgb = (RGBTRIPLE*) pData; <br>            for (iPixel=0; iPixel &lt; numPixels; iPixel++, prgb++) { <br>                prgb-&gt;rgbtRed = prgb-&gt;rgbtRed &amp; 0xe0; <br>                prgb-&gt;rgbtGreen = prgb-&gt;rgbtGreen &amp; 0xe0; <br>                prgb-&gt;rgbtBlue = prgb-&gt;rgbtBlue &amp; 0xe0; <br>            } <br>            break; <br> <br>        // Take pixel and its neighbor two pixels to the right and average <br>        // then out - this blurs them and produces a subtle motion effect <br> <br>        case IDC_BLUR: <br>            prgb = (RGBTRIPLE*) pData; <br>            for (y = 0 ; y &lt; pvi-&gt;bmiHeader.biHeight; y++) { <br>                for (x = 2 ; x &lt; pvi-&gt;bmiHeader.biWidth; x++,prgb++) { <br>                    prgb-&gt;rgbtRed = (prgb-&gt;rgbtRed + prgb[2].rgbtRed) &gt;&gt; 1; <br>                    prgb-&gt;rgbtGreen = (prgb-&gt;rgbtGreen + prgb[2].rgbtGreen) &gt;&gt; 1; <br>                    prgb-&gt;rgbtBlue = (prgb-&gt;rgbtBlue + prgb[2].rgbtBlue) &gt;&gt; 1; <br>} <br>                prgb +=2; <br>            } <br>            break; <br> <br>        // An excellent greyscale calculation is: <br>        //      grey = (30 * red + 59 * green + 11 * blue) / 100 <br>        // This is a bit too slow so a faster calculation is: <br>        //      grey = (red + green) / 2 <br> <br>        case IDC_GREY:  <br>            prgb = (RGBTRIPLE*) pData; <br>            for (iPixel=0; iPixel &lt; numPixels ; iPixel++, prgb++) { <br>                grey = (prgb-&gt;rgbtRed + prgb-&gt;rgbtGreen) &gt;&gt; 1; <br>        prgb-&gt;rgbtRed = prgb-&gt;rgbtGreen = prgb-&gt;rgbtBlue = (BYTE) grey; <br>            } <br>            break; <br> <br>        // Really sleazy emboss - rather than using a nice 3x3 convulution <br>        // matrix, we compare the greyscale values of two neighbours. If <br>        // they are not different, then a mid grey (128, 128, 128) is <br>        // supplied.  Large differences get father away from the mid grey <br> <br>        case IDC_EMBOSS: <br>            prgb = (RGBTRIPLE*) pData; <br>            for (y = 0 ; y &lt; pvi-&gt;bmiHeader.biHeight; y++) { <br>                grey2 = (prgb-&gt;rgbtRed + prgb-&gt;rgbtGreen) &gt;&gt; 1; <br>                prgb-&gt;rgbtRed = prgb-&gt;rgbtGreen = prgb-&gt;rgbtBlue = (BYTE) 128; <br>                prgb++; <br>for (x = 1 ; x &lt; pvi-&gt;bmiHeader.biWidth; x++) { <br>                    grey = (prgb-&gt;rgbtRed + prgb-&gt;rgbtGreen) &gt;&gt; 1; <br>                    temp = grey - grey2; <br>                    if (temp &gt; 127) temp = 127; <br>                    if (temp &lt; -127) temp = -127; <br>                    temp += 128; <br>                    prgb-&gt;rgbtRed = prgb-&gt;rgbtGreen = prgb-&gt;rgbtBlue = (BYTE) temp; <br>                    grey2 = grey; <br>                    prgb++; <br>        } <br>            } <br>            break; <br>    } <br>    return NOERROR; <br> <br>} // Transform (in place) <br> <br> <br>// Check the input type is OK - return an error otherwise <br> <br>HRESULT CEZrgb24::CheckInputType(const CMediaType *mtIn) <br>{ <br>    // check this is a VIDEOINFOHEADER type <br> <br>    if (*mtIn-&gt;FormatType() != FORMAT_VideoInfo) { <br>        return E_INVALIDARG; <br>    } <br> <br>    // Can we transform this type <br> <br>    if (CanPerformEZrgb24(mtIn)) { <br>    return NOERROR; <br>    } <br>    return E_FAIL; <br>} <br> <br> <br>// <br>// Checktransform <br>// <br>// Check a transform can be done between these formats <br>// <br>HRESULT CEZrgb24::CheckTransform(const CMediaType *mtIn, const CMediaType *mtOut) <br>{ <br>    if (CanPerformEZrgb24(mtIn)) { <br>        if (*mtIn == *mtOut) { <br>            return NOERROR; <br>        } <br>    } <br>    return E_FAIL; <br> <br>} // CheckTransform <br> <br> <br>// <br>// DecideBufferSize <br>// <br>// Tell the output pin's allocator what size buffers we <br>// require. Can only do this when the input is connected <br>// <br>HRESULT CEZrgb24::DecideBufferSize(IMemAllocator *pAlloc,ALLOCATOR_PROPERTIES *pProperties) <br>{ <br>    // Is the input pin connected <br> <br>    if (m_pInput-&gt;IsConnected() == FALSE) { <br>        return E_UNEXPECTED; <br>    } <br> <br>    ASSERT(pAlloc); <br>    ASSERT(pProperties); <br>    HRESULT hr = NOERROR; <br> <br>    pProperties-&gt;cBuffers = 1; <br>    pProperties-&gt;cbBuffer = m_pInput-&gt;CurrentMediaType().GetSampleSize(); <br>    ASSERT(pProperties-&gt;cbBuffer); <br> <br>    // Ask the allocator to reserve us some sample memory, NOTE the function <br>    // can succeed (that is return NOERROR) but still not have allocated the <br>    // memory that we requested, so we must check we got whatever we wanted <br> <br>    ALLOCATOR_PROPERTIES Actual; <br>    hr = pAlloc-&gt;SetProperties(pProperties,&amp;Actual); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br> <br>    ASSERT( Actual.cBuffers == 1 ); <br> <br>    if (pProperties-&gt;cBuffers &gt; Actual.cBuffers || <br>            pProperties-&gt;cbBuffer &gt; Actual.cbBuffer) { <br>                return E_FAIL; <br>    } <br>    return NOERROR; <br> <br>} // DecideBufferSize <br> <br> <br>// <br>// GetMediaType <br>// <br>// I support one type, namely the type of the input pin <br>// This type is only available if my input is connected <br>// <br>HRESULT CEZrgb24::GetMediaType(int iPosition, CMediaType *pMediaType) <br>{ <br>    // Is the input pin connected <br> <br>    if (m_pInput-&gt;IsConnected() == FALSE) { <br>        return E_UNEXPECTED; <br>    } <br> <br>    // This should never happen <br> <br>    if (iPosition &lt; 0) { <br>        return E_INVALIDARG; <br>    } <br> <br>    // Do we have more items to offer <br> <br>    if (iPosition &gt; 0) { <br>        return VFW_S_NO_MORE_ITEMS; <br>    } <br> <br>    *pMediaType = m_pInput-&gt;CurrentMediaType(); <br>    return NOERROR; <br> <br>} // GetMediaType <br> <br> <br>// <br>// CanPerformEZrgb24 <br>// <br>// Check if this is a RGB24 true colour format <br>// <br>BOOL CEZrgb24::CanPerformEZrgb24(const CMediaType *pMediaType) const <br>{ <br>    if (IsEqualGUID(*pMediaType-&gt;Type(), MEDIATYPE_Video)) { <br>        if (IsEqualGUID(*pMediaType-&gt;Subtype(), MEDIASUBTYPE_RGB24)) { <br>            VIDEOINFOHEADER *pvi = (VIDEOINFOHEADER *) pMediaType-&gt;Format(); <br>            return (pvi-&gt;bmiHeader.biBitCount == 24); <br>        } <br>    } <br>    return FALSE; <br> <br>} // CanPerformEZrgb24 <br> <br> <br>#define WRITEOUT(var)  hr = pStream-&gt;Write(&amp;var, sizeof(var), NULL); \ <br>       if (FAILED(hr)) return hr; <br> <br>#define READIN(var)    hr = pStream-&gt;Read(&amp;var, sizeof(var), NULL); \ <br>       if (FAILED(hr)) return hr; <br> <br> <br>// <br>// GetClassID <br>// <br>// This is the only method of IPersist <br>// <br>STDMETHODIMP CEZrgb24::GetClassID(CLSID *pClsid) <br>{ <br>    return CBaseFilter::GetClassID(pClsid); <br>} // GetClassID <br> <br> <br>// <br>// ScribbleToStream <br>// <br>// Overriden to write our state into a stream <br>// <br>HRESULT CEZrgb24::ScribbleToStream(IStream *pStream) <br>{ <br>    HRESULT hr; <br>    WRITEOUT(m_effect); <br>    WRITEOUT(m_effectStartTime); <br>    WRITEOUT(m_effectTime); <br>    return NOERROR; <br> <br>} // ScribbleToStream <br> <br> <br>// <br>// ReadFromStream <br>// <br>// Likewise overriden to restore our state from a stream <br>// <br>HRESULT CEZrgb24::ReadFromStream(IStream *pStream) <br>{ <br>    HRESULT hr; <br>    READIN(m_effect); <br>    READIN(m_effectStartTime); <br>    READIN(m_effectTime); <br>    return NOERROR; <br> <br>} // ReadFromStream <br> <br> <br>// <br>// GetPages <br>// <br>// Returns the clsid's of the property pages we support <br>// <br>STDMETHODIMP CEZrgb24::GetPages(CAUUID *pPages) <br>{ <br>    pPages-&gt;cElems = 1; <br>    pPages-&gt;pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID)); <br>    if (pPages-&gt;pElems == NULL) { <br>        return E_OUTOFMEMORY; <br>    } <br>    *(pPages-&gt;pElems) = CLSID_EZrgb24PropertyPage; <br>    return NOERROR; <br> <br>} // GetPages <br> <br> <br>// <br>// get_IPEffect <br>// <br>// Return the current effect selected <br>// <br>STDMETHODIMP CEZrgb24::get_IPEffect(int *IPEffect,REFTIME *start,REFTIME *length) <br>{ <br>    CAutoLock cAutolock(&amp;m_EZrgb24Lock); <br>    CheckPointer(IPEffect,E_POINTER); <br>    CheckPointer(start,E_POINTER); <br>    CheckPointer(length,E_POINTER); <br> <br>    *IPEffect = m_effect; <br>    *start = COARefTime(m_effectStartTime); <br>    *length = COARefTime(m_effectTime); <br> <br>    return NOERROR; <br> <br>} // get_IPEffect <br> <br> <br>// <br>// put_IPEffect <br>// <br>// Set the required video effect <br>// <br>STDMETHODIMP CEZrgb24::put_IPEffect(int IPEffect,REFTIME start,REFTIME length) <br>{ <br>    CAutoLock cAutolock(&amp;m_EZrgb24Lock); <br> <br>    m_effect = IPEffect; <br>    m_effectStartTime = COARefTime(start); <br>    m_effectTime = COARefTime(length); <br> <br>    SetDirty(TRUE); <br>    return NOERROR; <br> <br>} // put_IPEffect <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
