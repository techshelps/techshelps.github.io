<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MPEG1.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2860"></a>MPEG1.CPP</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1996 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>#include &lt;streams.h&gt; <br>#include &lt;pullpin.h&gt; <br>#include &lt;mmreg.h&gt; <br>#include &lt;mpeg2typ.h&gt; <br>#include &lt;alloc.h&gt; <br>#include &lt;splitter.h&gt; <br>#include &lt;mpegdef.h&gt; <br>#include &lt;mpgutil.h&gt; <br>#include &lt;mpeg1.h&gt; <br>#include &lt;initguid.h&gt; <br>//  f28300a0-f0cc-11cf-93d5-0080c795857f <br>DEFINE_GUID(CLSID_MPEG1Sample, <br>    0xf28300a0, 0xf0cc, 0x11cf, 0x93, 0xd5, 0x00, 0x80, 0xc7, 0x95, 0x85, 0x7f); <br> <br> <br>/*  Stuff to make this into a filter */ <br>/* List of class IDs and creator functions for the class factory. This <br>   provides the link between the OLE entry point in the DLL and an object <br>   being created. The class factory will call the static CreateInstance <br>   function when it is asked to create a CLSID_MPEG1Splitter object */ <br> <br>CFactoryTemplate g_Templates[1] = { <br>    {L"MPEG1 Sample", &amp;CLSID_MPEG1Sample, CMPEG1SplitterFilter::CreateInstance} <br>}; <br> <br>int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]); <br> <br> <br>/* This goes in the factory template table to create new instances */ <br> <br>CUnknown *CMPEG1SplitterFilter::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr) <br>{ <br>    CUnknown *pUnkRet = new CMPEG1SplitterFilter(pUnk, phr); <br>    return pUnkRet; <br>} <br> <br>/*  Registration setup stuff */ <br>//  Setup data <br> <br>AMOVIESETUP_MEDIATYPE sudMpgInputType[] = <br>{ <br>    { &amp;MEDIATYPE_Stream, &amp;MEDIASUBTYPE_MPEG1System } <br>}; <br>AMOVIESETUP_MEDIATYPE sudMpgAudioOutputType[] = <br>{ <br>    { &amp;MEDIATYPE_Audio, &amp;MEDIASUBTYPE_MPEG1AudioPayload } <br>}; <br>AMOVIESETUP_MEDIATYPE sudMpgVideoOutputType[] = <br>{ <br>    { &amp;MEDIATYPE_Video, &amp;MEDIASUBTYPE_MPEG1Payload } <br>}; <br> <br>AMOVIESETUP_PIN sudMpgPins[3] = <br>{ <br>    { L"Input", <br>      FALSE,                               // bRendered <br>      FALSE,                               // bOutput <br>      FALSE,                               // bZero <br>      FALSE,                               // bMany <br>      &amp;CLSID_NULL,                         // clsConnectsToFilter <br>      NULL,                                // ConnectsToPin <br>      NUMELMS(sudMpgInputType),            // Number of media types <br>      sudMpgInputType <br>    }, <br>    { L"Audio Output", <br>      FALSE,                               // bRendered <br>      TRUE,                                // bOutput <br>      TRUE,                                // bZero <br>      FALSE,                               // bMany <br>      &amp;CLSID_NULL,                         // clsConnectsToFilter <br>      NULL,                                // ConnectsToPin <br>      NUMELMS(sudMpgAudioOutputType),      // Number of media types <br>      sudMpgAudioOutputType <br>    }, <br>    { L"Video Output", <br>      FALSE,                               // bRendered <br>      TRUE,                                // bOutput <br>      TRUE,                                // bZero <br>      FALSE,                               // bMany <br>      &amp;CLSID_NULL,                         // clsConnectsToFilter <br>      NULL,                                // ConnectsToPin <br>      NUMELMS(sudMpgVideoOutputType),      // Number of media types <br>      sudMpgVideoOutputType <br>    } <br>}; <br> <br>AMOVIESETUP_FILTER sudMpgsplit = <br>{ <br>    &amp;CLSID_MPEG1Sample, <br>    L"MPEG1 Splitter Sample", <br>    0,                                     // Don't use us for real! <br>    NUMELMS(sudMpgPins),                   // 3 pins <br>    sudMpgPins <br>}; <br> <br> <br>// <br>// DllRegisterSever <br>// <br>// Handle the registration of this filter <br>// <br>STDAPI DllRegisterServer() <br>{ <br>    return AMovieDllRegisterServer(); <br> <br>} // DllRegisterServer <br> <br>//  Constructor and destructor <br>CMPEG1SplitterFilter::CMPEG1SplitterFilter( <br>   LPUNKNOWN pUnk, <br>   HRESULT *phr) : <br>   CBaseSplitterFilter( <br>       TEXT("CMPEG1SplitterFilter"), <br>       pUnk, <br>       CLSID_MPEG1Sample, <br>       phr) <br>{ <br>    //  Create our input pin <br>    m_pInput = new CSplitterInputPin(this, phr); <br>} <br>//  Override type checking <br>HRESULT CMPEG1SplitterFilter::CheckInputType(const CMediaType *pmt) <br>{ <br>    /*  We'll accept our preferred type or a wild card for the subtype */ <br> <br>    if (pmt-&gt;majortype != MEDIATYPE_Stream || <br>        pmt-&gt;subtype != MEDIASUBTYPE_MPEG1System &amp;&amp; <br>        pmt-&gt;subtype != MEDIASUBTYPE_NULL) { <br>        return S_FALSE; <br>    } else { <br>        return S_OK; <br>    } <br>} <br> <br>LPAMOVIESETUP_FILTER CMPEG1SplitterFilter::GetSetupData() <br>{ <br>    return &amp;sudMpgsplit; <br>} <br> <br>/*  Complete connection and instantiate parser <br>    This involves: <br> <br>    Instatiate the parser with for the type and have it check the format <br>*/ <br> <br>CBaseParser *CMPEG1SplitterFilter::CreateParser( <br>    CParserNotify *pNotify, <br>    CMediaType *pType <br>) <br>{ <br>    HRESULT hr = S_OK; <br>    return new CMPEG1Parser(pNotify, &amp;hr); <br>} <br> <br>/*  Cheap'n nasty parser - DON'T do yours like this! */ <br>/*  Initialize a parser <br> <br>    pmt     - type of stream if known - can be NULL <br>    pRdr    - way to read the source medium - can be NULL <br>*/ <br>HRESULT CMPEG1Parser::Init(CParseReader *pRdr) <br>{ <br>    const DWORD dwLen = 65536; <br>    /*  Just read 32K and look for interesting stuff */ <br>    PBYTE pbData = new BYTE[dwLen]; <br>    if (pbData == NULL) { <br>        return E_OUTOFMEMORY; <br>    } <br>    HRESULT hr = pRdr-&gt;Read(pbData, dwLen); <br>    if (S_OK != hr) { <br>        delete [] pbData; <br>        return hr; <br>    } <br> <br>    /*  Now just loop looking for start codes */ <br>    DWORD dwLeft = dwLen; <br>    PBYTE pbCurrent = pbData; <br>    while (dwLeft &gt;= 140) { <br>        DWORD dwCode = *(UNALIGNED DWORD *)pbCurrent; <br> <br>        /*  Check if it's a valid start code */ <br>        if ((dwCode &amp; 0x00FFFFFF) == 0x00010000) { <br>            dwCode = DWORD_SWAP(dwCode); <br>            if (VALID_PACKET(dwCode)){ <br>                MPEG_PACKET_DATA Info; <br>                DWORD dwPacketLen = ParseMPEG1Packet( <br>                                        pbCurrent, <br>                                        dwLeft, <br>                                        &amp;Info); <br>                if (dwPacketLen &gt; 4) { <br>                    if (!m_bGotFirstPts &amp;&amp; Info.bHasPts) { <br>                        m_llFirstPts = Info.llPts; <br>                        m_bGotFirstPts = TRUE; <br>                    } <br>                    if (IsVideoStreamId((BYTE)(dwCode &amp; 0xFF))) { <br>                        m_Video.m_uStreamId = (BYTE)(dwCode &amp; 0xFF); <br>                        const BYTE * pbHeader = pbCurrent + Info.dwHeaderLen; <br>                        SEQHDR_INFO seqInfo; <br> <br>                        /*  Create our format block */ <br>                        if (DWORD_SWAP(SEQUENCE_HEADER_CODE) == <br>                            *(UNALIGNED DWORD *)pbHeader &amp;&amp; <br>                            ParseSequenceHeader(pbHeader, dwLeft, &amp;seqInfo)) { <br>                            /*  Create the media type from the stream <br>                                only support Payload streams for now <br>                            */ <br>                            CMediaType cmt; <br>                            GetVideoMediaType(&amp;cmt, TRUE, &amp;seqInfo); <br> <br>                            /*  Create our video stream */ <br>                            m_pNotify-&gt;CreateStream(L"Video", &amp;m_Video.m_pNotify); <br>                            m_Video.m_pNotify-&gt;AddMediaType(&amp;cmt); <br>                        } else { <br>                        } <br>                    } else if (IsAudioStreamId((BYTE)(dwCode &amp; 0xFF))) { <br>                        m_Audio.m_uStreamId = (BYTE)(dwCode &amp; 0xFF); <br> <br>                        /*  Now let's hope the first 2 bytes are a frame <br>                            start ! <br>                        */ <br>                        MPEG1WAVEFORMAT wf; <br>                        if (ParseAudioHeader(pbCurrent + Info.dwHeaderLen, <br>                                             &amp;wf)) { <br>                            CMediaType cmt(&amp;MEDIATYPE_Audio); <br>                            cmt.subtype = MEDIASUBTYPE_MPEG1AudioPayload; <br>                            cmt.SetFormat((PBYTE)&amp;wf, sizeof(wf)); <br>                            cmt.SetFormatType(&amp;FORMAT_WaveFormatEx); <br>                            m_Audio.m_uStreamId = (BYTE)(dwCode &amp; 0xFF); <br>                            m_pNotify-&gt;CreateStream( <br>                                L"Audio", <br>                                &amp;m_Audio.m_pNotify); <br>                            m_Audio.m_pNotify-&gt;AddMediaType(&amp;cmt); <br>                        } <br>                    } <br>                } <br>                ASSERT(dwLeft &gt;= dwPacketLen); <br>                pbCurrent += dwPacketLen; <br>                dwLeft -= dwPacketLen; <br>                continue; <br>            } <br>        } <br> <br>        /*  Hideously inefficient! */ <br>        pbCurrent++; <br>        dwLeft--; <br>    } <br>    delete [] pbData; <br>    if (!m_bGotFirstPts || (!m_Audio.Initialized() &amp;&amp; !m_Video.Initialized())) { <br>        return VFW_E_TYPE_NOT_ACCEPTED; <br>    } else { <br>        return S_OK; <br>    } <br>} <br> <br> <br>/*  Get the size and count of buffers preferred based on the <br>    actual content <br>*/ <br>void CMPEG1Parser::GetSizeAndCount(LONG *plSize, LONG *plCount) <br>{ <br>    *plSize = 32768; <br>    *plCount = 4; <br>} <br> <br>/*  Call this to reinitialize for a new stream */ <br>void CMPEG1Parser::StreamReset() <br>{ <br>} <br> <br>/*  Call this to pass new stream data : <br> <br>    pbData        - pointer to data <br>    lData         - length of data <br>    plProcessed   - Amount of data consumed <br>*/ <br>HRESULT CMPEG1Parser::Process( <br>    const BYTE * pbData, <br>    LONG lData, <br>    LONG *plProcessed <br>) <br>{ <br>    /*  Just loop processing packets until we run out of data <br>        We should do a lot more to sync up than just eat a start <br>        code ! <br>    */ <br> <br>    DWORD dwLeft = lData; <br>    const BYTE * pbCurrent = pbData; <br> <br>    while (dwLeft &gt; 4) { <br>        /*  Find a start code */ <br>        DWORD dwCode = DWORD_SWAP(*(UNALIGNED DWORD *)pbCurrent); <br>        MPEG_PACKET_DATA Info; <br>        if (VALID_PACKET(dwCode)) { <br>            DWORD dwPacketLen = ParseMPEG1Packet(pbCurrent, dwLeft, &amp;Info); <br>            if (dwPacketLen == 0) { <br>                break; <br>            } <br>            if (dwPacketLen == 4) { <br>                dwLeft -= 4; <br>                pbCurrent += 4; <br>                continue; <br>            } <br>            /*  If it's a packet we're interested in send it on */ <br>            CStream *pStream = NULL; <br>            if (((BYTE)(dwCode &amp; 0xFF)) == m_Audio.m_uStreamId) { <br>                pStream = &amp;m_Audio; <br>            } else <br>            if (((BYTE)(dwCode &amp; 0xFF)) == m_Video.m_uStreamId) { <br>                pStream = &amp;m_Video; <br>            } <br>            if (pStream != NULL) { <br>                DbgLog((LOG_TRACE, 3, TEXT("Send sample for stream %2.2X"), <br>                        pStream-&gt;m_uStreamId)); <br>                pStream-&gt;m_pNotify-&gt;SendSample( <br>                    pbCurrent + Info.dwHeaderLen, <br>                    Info.dwPacketLen - Info.dwHeaderLen, <br>                    Info.bHasPts ? TimeStamp(Info.llPts) : 0, <br>                    Info.bHasPts); <br>            } <br>            dwLeft -= Info.dwPacketLen; <br>            pbCurrent += Info.dwPacketLen; <br>        } else { <br>            dwLeft--; <br>            pbCurrent++; <br>        } <br>    } <br>    *plProcessed = lData - dwLeft; <br>    return S_OK; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
