<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ALLOC.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2852"></a>ALLOC.CPP</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1996 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br>/*  Sequential allocator methods */ <br>#include &lt;streams.h&gt; <br>#include &lt;alloc.h&gt; <br> <br>CSequentialAllocator::CSequentialAllocator( <br>    LPUNKNOWN  pUnk, <br>    HRESULT   *phr <br>) : CMemAllocator(TEXT("CSequential Allocator"), pUnk, phr), <br>    m_pbNext(m_pBuffer), <br>    m_parSamples(NULL), <br>    m_lValid(0), <br>    m_pbStartValid(NULL) <br>{ <br>} <br> <br>CSequentialAllocator::~CSequentialAllocator() <br>{ <br>    if (m_parSamples != NULL) { <br>        delete [] m_parSamples; <br>    } <br>} <br> <br>STDMETHODIMP CSequentialAllocator::GetBuffer( <br>    IMediaSample **ppBuffer, <br>    REFERENCE_TIME * pStartTime, <br>    REFERENCE_TIME * pEndTime, <br>    DWORD dwFlags <br>) <br>{ <br>    /*  Like the normal version except we will only allocate the NEXT <br>        buffer <br>    */ <br> <br>    UNREFERENCED_PARAMETER(pStartTime); <br>    UNREFERENCED_PARAMETER(pEndTime); <br>    UNREFERENCED_PARAMETER(dwFlags); <br>    CMediaSample *pSample = NULL; <br> <br>    *ppBuffer = NULL; <br>    for (;;) <br>    { <br>{  // scope for lock <br>    CAutoLock cObjectLock(this); <br> <br>    /* Check we are committed */ <br>    if (!m_bCommitted) { <br>return VFW_E_NOT_COMMITTED; <br>    } <br>            /* Check if the one we want is there */ <br>            CMediaSample *pSearch = m_lFree.Head(); <br>            while (pSearch) { <br>                PBYTE pbBuffer; <br>                pSearch-&gt;GetPointer(&amp;pbBuffer); <br>                if (pbBuffer == m_pbNext) { <br>                    m_lFree.Remove(pSearch); <br>                    pSample = pSearch; <br>                    ASSERT(m_lSize == pSample-&gt;GetSize()); <br>                    m_pbNext += m_lSize; <br>                    if (m_pbNext == m_pBuffer + m_lSize * m_lCount) { <br>                        m_pbNext = m_pBuffer; <br>                    } <br>                    break; <br>                } else { <br>                    pSearch = m_lFree.Next(pSearch); <br>                } <br>            } <br>            if (pSample == NULL) { <br>                /*  If there were some samples but just not ours someone <br>                    else may be waiting <br>                */ <br>                if (m_lFree.GetCount() != 0) { <br>                    NotifySample(); <br>                } <br>                SetWaiting(); <br>            } <br>} <br> <br>/* If we didn't get a sample then wait for the list to signal */ <br> <br>if (pSample) { <br>    break; <br>} <br>        ASSERT(m_hSem != NULL); <br>        DbgLog((LOG_TRACE, 4, TEXT("Waiting - %d buffers available"), <br>                m_lFree.GetCount())); <br>WaitForSingleObject(m_hSem, INFINITE); <br>    } <br> <br>#ifdef VFW_S_CANT_CUE <br>    /* Addref the buffer up to one. On release <br>       back to zero instead of being deleted, it will requeue itself by <br>       calling the ReleaseBuffer member function. NOTE the owner of a <br>       media sample must always be derived from CBaseAllocator */ <br> <br> <br>    ASSERT(pSample-&gt;m_cRef == 0); <br>    pSample-&gt;m_cRef = 1; <br>    *ppBuffer = pSample; <br>#else <br>    /* This QueryInterface should addref the buffer up to one. On release <br>       back to zero instead of being deleted, it will requeue itself by <br>       calling the ReleaseBuffer member function. NOTE the owner of a <br>       media sample must always be derived from CBaseAllocator */ <br> <br>    HRESULT hr = pSample-&gt;QueryInterface(IID_IMediaSample, (void **)ppBuffer); <br> <br>    /* For each sample outstanding, we need to AddRef ourselves on his behalf <br>       he cannot do it, as there is no correct ordering of his release and his <br>       call to ReleaseBuffer as both could destroy him. We release this count <br>       in ReleaseBuffer, called when the sample's count drops to zero */ <br> <br>    AddRef(); <br>#endif <br>    return NOERROR; <br>} <br> <br>HRESULT CSequentialAllocator::Alloc() <br>{ <br>    CAutoLock lck(this); <br>    if (m_parSamples != NULL) { <br>        delete [] m_parSamples; <br>    } <br>    m_parSamples = new LPCMEDIASAMPLE[m_lCount]; <br>    if (m_parSamples == NULL) { <br>        return E_OUTOFMEMORY; <br>    } <br>    HRESULT hr = CMemAllocator::Alloc(); <br> <br>    if (S_OK == hr) { <br>        ASSERT(m_lCount == m_lFree.GetCount()); <br> <br>        /* Find the smallest */ <br>        CMediaSample *pSample = m_lFree.Head(); <br> <br>        m_pBuffer = (PBYTE)(DWORD)-1; <br>        for (; pSample != NULL; pSample = m_lFree.Next(pSample)) { <br>            PBYTE pbTemp; <br>            pSample-&gt;GetPointer(&amp;pbTemp); <br>            if (m_pBuffer &gt; pbTemp) { <br>                m_pBuffer = pbTemp; <br>            } <br>        } <br> <br>        pSample = m_lFree.Head(); <br>        for ( ;pSample != NULL; pSample = m_lFree.Next(pSample)) { <br>            PBYTE pbTemp; <br>            pSample-&gt;GetPointer(&amp;pbTemp); <br>            m_parSamples[BufferIndex(pbTemp)] = pSample; <br>        } <br>    } <br>    m_pbStartValid = m_pBuffer; <br>    m_pbNext       = m_pBuffer; <br>    ASSERT(m_lValid == 0); <br>    return hr; <br>} <br> <br> <br>/*  Get buffer index */ <br>int CSequentialAllocator::BufferIndex(PBYTE pbBuffer) <br>{ <br>    int iPos = (pbBuffer - m_pBuffer) / m_lSize; <br>    ASSERT(iPos &lt; m_lCount); <br>    return iPos; <br>} <br>/*  Given an address get the IMediaSample pointer - <br>    NB needs optimizing <br>*/ <br>CMediaSample *CSequentialAllocator::SampleFromBuffer(PBYTE pBuffer) <br>{ <br>    return m_parSamples[BufferIndex(pBuffer)]; <br>} <br> <br>/*  Add a buffer to the valid list */ <br>void CSequentialAllocator::AddBuffer(CMediaSample *pSample) <br>{ <br>    /*  Don't get fooled by 0 length buffers ! */ <br>    if (pSample-&gt;GetActualDataLength() == 0) { <br>        return; <br>    } <br>    pSample-&gt;AddRef(); <br>#ifdef DEBUG <br>    PBYTE pbBuffer; <br>    pSample-&gt;GetPointer(&amp;pbBuffer); <br>    ASSERT(m_pbStartValid + m_lValid == pbBuffer); <br>#endif <br>    m_lValid += pSample-&gt;GetActualDataLength(); <br>} <br> <br>/*  Step through valid data */ <br>HRESULT CSequentialAllocator::Advance(LONG lAdvance) <br>{ <br>    /*  For every sample boundary we step over we should Release() <br>        a buffer <br>    */ <br>    int iStart = BufferIndex(m_pbStartValid); <br>    int iEnd = BufferIndex(m_pbStartValid + lAdvance); <br>    m_lValid -= lAdvance; <br>    m_pbStartValid += lAdvance; <br> <br>    /*  If we're at the end and the last buffer wasn't full move on <br>        to the next <br>    */ <br>    if (m_lValid == 0 &amp;&amp; <br>        (m_pbStartValid - m_pBuffer) % m_lSize != 0) { <br>        iEnd++; <br>        m_pbStartValid = m_pBuffer + m_lSize * iEnd; <br>    } <br>    while (iStart != iEnd) { <br>        m_parSamples[iStart]-&gt;Release(); <br> <br>        iStart++; <br>    } <br> <br> <br>    ASSERT(m_lValid &lt;= (m_lCount * m_lSize) / 2); <br> <br>    /* <br>        If we're already into the last buffer and about to wrap <br>        NOTE m_Valid CAN be &gt;  m_lSize - hit it with a huge <br>        PROGRAM_STREAM_DIRECTORY packet (can be almost 64K) <br>    */ <br>    if (m_pbStartValid + m_lValid == m_pBuffer + m_lSize * m_lCount) { <br>        return Wrap(); <br>    } else { <br>        return S_OK; <br>    } <br>} <br> <br>/*  Get the valid part */ <br>PBYTE CSequentialAllocator::GetValid(LONG *plValid) <br>{ <br>    *plValid = m_lValid; <br>    return m_pbStartValid; <br>} <br> <br>/*  Wrap end to go back to start */ <br>HRESULT CSequentialAllocator::Wrap(void) <br>{ <br>    if (m_lValid != 0) { <br> <br>        /*  Make sure the copy will work */ <br>        ASSERT(m_lValid &lt;= (m_lSize * m_lCount) / 2); <br>        IMediaSample *pSample; <br> <br>        /*  These samples will be AddRef'd already */ <br>        int nBuffers = (m_lValid + m_lSize - 1) / m_lSize; <br> <br>        ASSERT(nBuffers &lt;= m_lCount / 2); <br>        for (int i = 0; i &lt; nBuffers; i++) { <br>            HRESULT hr = GetBuffer(&amp;pSample, NULL, NULL, 0); <br>            if (FAILED(hr)) { <br>                return hr; <br>            } <br>            ASSERT(pSample == m_parSamples[i]); <br>        } <br> <br>        /*  Now copy the data back to the start */ <br>        CopyMemory((PVOID)(m_pBuffer + m_lSize * nBuffers - m_lValid), <br>                   (PVOID)m_pbStartValid, <br>                   m_lValid); <br>        m_pbStartValid = m_pBuffer + m_lSize * nBuffers - m_lValid; <br> <br>        /*  Release the last buffers since we've effectively <br>            transferred the ref count to the first one <br>        */ <br>        for ( ; nBuffers &gt; 0; nBuffers--) { <br>            m_parSamples[m_lCount - nBuffers]-&gt;Release(); <br>        } <br>    } else { <br>        m_pbStartValid = m_pBuffer; <br>    } <br>    return S_OK; <br>} <br> <br>/*  Flush the allocator - just discard all the data in it */ <br>void CSequentialAllocator::Flush() <br>{ <br>    Advance(m_lValid); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
