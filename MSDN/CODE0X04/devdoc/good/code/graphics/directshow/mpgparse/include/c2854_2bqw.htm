<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MPGUTIL.H</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2858"></a>MPGUTIL.H</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1996 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br>/*  MPEG-2 utility functions */ <br> <br> <br>/*  Packet header info */ <br>typedef struct tag_MPEG_PACKET_DATA { <br>    DWORD    dwHeaderLen; <br>    DWORD    dwPacketLen; <br>    BOOL     bHasPts; <br>    LONGLONG llPts; <br>} MPEG_PACKET_DATA; <br> <br>/*  Read an normal MPEG-1 style clock */ <br>BOOL GetClock(const BYTE * pData, LONGLONG *Clock); <br> <br>/*  Read an extended clock */ <br>BOOL GetExtendedClock(const BYTE * pbData, LONGLONG *pllClock); <br> <br>inline GetStartCode(const BYTE * pbData) <br>{ <br>    return DWORD_SWAP(*(UNALIGNED DWORD *)pbData); <br>} <br> <br> <br>/*  Since dwCode is normally a constant just swap that instead */ <br>inline BOOL IsStartCode(const BYTE * pbData, DWORD dwCode) <br>{ <br>    return DWORD_SWAP(dwCode) == *(UNALIGNED DWORD *)pbData; <br>} <br> <br>/*  Parse pack header <br> <br>    Parameters : <br>        pbData - pointer to data containing the system header <br>        cbData - length of data <br> <br>    Returns : <br>        Number of bytes processed (0 if the header doesn't fit <br>        in the data or 4 if the header is invalid) <br>        We will return 0 if we can't see the next start code to <br>        check whether it's a system header start code <br>*/ <br> <br>DWORD ParseMPEG2PackHeader(const BYTE * pbData, DWORD cbData); <br> <br>/*  Length of pack header - returns 0 if &lt; cbData */ <br>inline DWORD MPEG2PackHeaderLength(const BYTE * pbData, DWORD cbData) <br>{ <br>    /*  Need more data */ <br>    if (cbData &lt; 14) { <br>        return 0; <br>    } else { <br>        DWORD dwLen = 14 + (pbData[13] &amp; 0x07); <br>        if (dwLen &gt; cbData) { <br>            return 0; <br>        } else { <br>            return dwLen; <br>        } <br>    } <br>} <br> <br>/*  Parse system header <br> <br>    Parameters : <br>        pbData - pointer to data containing the system header <br>        cbData - length of data <br> <br>    Returns : <br>        Number of bytes processed (0 if the header doesn't fit <br>        in the data or 4 if the header is invalid) <br>*/ <br> <br>LONG ParseSystemHeader(const BYTE * pbData, DWORD cbData); <br> <br> <br>/*  Parse an MPEG2 packet and extract information */ <br>DWORD ParseMPEG2Packet( <br>    const BYTE * pbData, <br>    DWORD cbData, <br>    MPEG_PACKET_DATA *pPacketData <br>); <br> <br>/*  Parse an MPEG1 packet and extract information */ <br>DWORD ParseMPEG1Packet( <br>    const BYTE * pbData, <br>    DWORD cbData, <br>    MPEG_PACKET_DATA *pPacketData <br>); <br> <br>BOOL ParseMPEG2PacketHeader( <br>    const BYTE * pbData, <br>    DWORD dwLen, <br>    MPEG_PACKET_DATA *pPacketData <br>); <br> <br>/*  Inlines to get PTSs from MPEG2 packets */ <br>inline BOOL MPEG2PacketHasPTS(const BYTE * pbPacket) <br>{ <br>    /*  Just check if the PTS_DTS_flags are 10 or 11 (ie the first <br>        bit is one <br>    */ <br>    return 0 != (pbPacket[7] &amp; 0x80); <br>} <br> <br>/*  Get the PTS from an MPEG2 packet */ <br>LONGLONG MPEG2PacketPTS(const BYTE * pbPacket); <br> <br> <br>typedef struct { <br>    DWORD          dwProfile;          //  Profile - MPEG2 only <br>    DWORD          dwLevel;            //  Level - MPEG2 only <br>    LONG           lWidth;             //  Native Width in pixels <br>    LONG           lHeight;            //  Native Height in pixels <br>    LONG           lvbv;               //  vbv <br>    REFERENCE_TIME  tPictureTime;      //  Time per picture in 100ns units <br>    float          fPictureRate;       //  In frames per second <br>    LONG           lTimePerFrame;      //  Time per picture in MPEG units <br>    LONG           dwBitRate;          //  Bits per second <br>    LONG           lXPelsPerMeter;     //  Pel aspect ratio <br>    LONG           lYPelsPerMeter;     //  Pel aspect ratio <br>    DWORD          dwStartTimeCode;    //  First GOP time code (or -1) <br>    LONG           lActualHeaderLen;   //  Length of valid bytes in raw seq hdr <br>    BYTE           RawHeader[140];     //  The real sequence header <br>} SEQHDR_INFO; <br> <br>/*  MPEG2 stuff */ <br>typedef struct { <br>    BOOL           bExtensionPresent; <br>    BOOL           bDisplayExtensionPresent; <br>    BOOL           bScalableExtensionPresent; <br>    SEQHDR_INFO    seqhdrInfo; <br> <br>} MPEG2_SEQHDR_INFO; <br> <br>/*  Helper */ <br>int inline SequenceHeaderSize(const BYTE *pb) <br>{ <br>    /*  No quantization matrices ? */ <br>    if ((pb[11] &amp; 0x03) == 0x00) { <br>        return 12; <br>    } <br>    /*  Just non-intra quantization matrix ? */ <br>    if ((pb[11] &amp; 0x03) == 0x01) { <br>        return 12 + 64; <br>    } <br>    /*  Intra found - is there a non-intra ? */ <br>    if (pb[11 + 64] &amp; 0x01) { <br>        return 12 + 64 + 64; <br>    } else { <br>        return 12 + 64; <br>    } <br>} <br> <br>/*  Extract info from video sequence header <br> <br>    Returns FALSE if the sequence header is invalid <br>*/ <br> <br>BOOL ParseSequenceHeader(const BYTE *pbData, LONG lData, SEQHDR_INFO *hdrInfo); <br> <br>BOOL ParseAudioHeader(const BYTE * pbData, MPEG1WAVEFORMAT *pFormat); <br> <br>/*  Construct a media type from the video info */ <br>HRESULT GetVideoMediaType(CMediaType *cmt, BOOL bPayload, const SEQHDR_INFO *pInfo); <br> <br>/*  Find the next start code */ <br>BOOL NextStartCode(const BYTE * *ppbData, DWORD *pdwLeft); <br> <br>/*  Parse AC3 header */ <br>BOOL ParseAC3Header(const BYTE * pbData, DOLBYAC3WAVEFORMAT *pwf); </code></pre>
<p>&nbsp;</p></body>
</HTML>
