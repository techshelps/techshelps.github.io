<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MPGUTIL.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2864"></a>MPGUTIL.CPP</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1996 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br>/*  MPEG 1 &amp; 2 parsing routines */ <br> <br>#include &lt;streams.h&gt; <br>#include &lt;mpegdef.h&gt; <br>#include &lt;mmreg.h&gt; <br>#include &lt;mpeg2typ.h&gt; <br>#include &lt;mpgutil.h&gt; <br> <br>#ifdef DEBUG <br>LPCTSTR PictureTypes[8]   = { TEXT("forbidden frame type"), <br>                              TEXT("I-Frame"), <br>                              TEXT("P-Frame"), <br>                              TEXT("B-Frame"), <br>                              TEXT("D-Frame"), <br>                              TEXT("Reserved frame type"), <br>                              TEXT("Reserved frame type"), <br>                              TEXT("Reserved frame type") <br>                            }; <br>LPCTSTR PelAspectRatios[16] = { TEXT("Forbidden"), <br>                                TEXT("1.0000 - VGA etc"), <br>                                TEXT("0.6735"), <br>                                TEXT("0.7031 - 16:9, 625 line"), <br>                                TEXT("0.7615"), <br>                                TEXT("0.8055"), <br>                                TEXT("0.8437 - 16:9, 525 line"), <br>                                TEXT("0.8935"), <br>                                TEXT("0.9375 - CCIR601, 625 line"), <br>                                TEXT("0.9815"), <br>                                TEXT("1.0255"), <br>                                TEXT("1.0695"), <br>                                TEXT("1.1250 - CCIR601, 525 line"), <br>                                TEXT("1.1575"), <br>                                TEXT("1.2015"), <br>                                TEXT("Reserved") }; <br>LPCTSTR PictureRates[16] = { TEXT("Forbidden"), <br>                             TEXT("23.976"), <br>                             TEXT("24"), <br>                             TEXT("25"), <br>                             TEXT("29.97"), <br>                             TEXT("30"), <br>                             TEXT("50"), <br>                             TEXT("59.94"), <br>                             TEXT("60"), <br>                             TEXT("Reserved"), <br>                             TEXT("Reserved"), <br>                             TEXT("Reserved"), <br>                             TEXT("Reserved"), <br>                             TEXT("Reserved"), <br>                             TEXT("Reserved"), <br>                             TEXT("Reserved") }; <br>#endif // DBG <br> <br>const LONG PictureTimes[16] = { 0, <br>                                (LONG)((double)10000000 / 23.976), <br>                                (LONG)((double)10000000 / 24), <br>                                (LONG)((double)10000000 / 25), <br>                                (LONG)((double)10000000 / 29.97), <br>                                (LONG)((double)10000000 / 30), <br>                                (LONG)((double)10000000 / 50), <br>                                (LONG)((double)10000000 / 59.94), <br>                                (LONG)((double)10000000 / 60) <br>                              }; <br> <br>const float fPictureRates[] = <br>   { <br>     (float)0, <br>     (float)23.976, <br>     (float)24, <br>     (float)25, <br>     (float)29.97, <br>     (float)30, <br>     (float)50, <br>     (float)59.94, <br>     (float)60.0 <br>   }; <br> <br>const LONG AspectRatios[16] = { 0, <br>                                393700, <br>                                (LONG)(393700.0 * 0.6735), <br>                                (LONG)(393700.0 * 0.7031), <br>                                (LONG)(393700.0 * 0.7615), <br>                                (LONG)(393700.0 * 0.8055), <br>                                (LONG)(393700.0 * 0.8437), <br>                                (LONG)(393700.0 * 0.8935), <br>                                (LONG)(393700.0 * 0.9375), <br>                                (LONG)(393700.0 * 0.9815), <br>                                (LONG)(393700.0 * 1.0255), <br>                                (LONG)(393700.0 * 1.0695), <br>                                (LONG)(393700.0 * 1.1250), <br>                                (LONG)(393700.0 * 1.1575), <br>                                (LONG)(393700.0 * 1.2015), <br>                                0 <br>                              }; <br> <br>/*  Bit rate tables */ <br>const WORD BitRates[3][16] = <br>{{  0, 32,  64,  96,  128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 0 }, <br> {  0, 32,  48,  56,   64,  80,  96, 112, 128, 160, 192, 224, 256, 320, 384, 0 }, <br> {  0, 32,  40,  48,   56,  64,  80,  96, 112, 128, 160, 192, 224, 256, 320, 0 } <br>}; <br> <br>BOOL inline TESTBIT(const BYTE * pbData, int n) <br>{ <br>    return 0 != (pbData[n &gt;&gt; 3] &amp; (0x80 &gt;&gt; (n &amp; 7))); <br>} <br> <br>/*  Read an extended clock */ <br>BOOL GetExtendedClock(const BYTE * pbData, LONGLONG *pllClock) <br>{ <br>    /*  Check marker bits <br>        These occur at bit positions 5, 21, 37, 47 */ <br>    if (!TESTBIT(pbData, 5) || <br>        !TESTBIT(pbData, 21) || <br>        !TESTBIT(pbData, 37) || <br>        !TESTBIT(pbData, 47)) { <br>        DbgLog((LOG_ERROR, 1, TEXT("Invalid extended clock marker bits"))); <br>        return FALSE; <br>    } <br> <br>    /*  Compute the clock value <br> <br>        * = ignore <br>        M = Marker <br>        x = value <br> <br>            0        1       2        3        4 <br>        **xxxMxx xxxxxxxx xxxxxMxx xxxxxxxx xxxxxM** <br>    */ <br>    LARGE_INTEGER liClock; <br>    liClock.HighPart = (pbData[0] &amp; 0x20) != 0; <br>    liClock.LowPart = ((pbData[0] &amp; 0x18) &lt;&lt; 27) + <br>                      ((pbData[0] &amp; 0x03) &lt;&lt; 28) + <br>                      ( pbData[1]         &lt;&lt; 20) + <br>                      ((pbData[2] &amp; 0xF8) &lt;&lt; 12) + <br>                      ((pbData[2] &amp; 0x03) &lt;&lt; 13) + <br>                      ( pbData[3]         &lt;&lt; 5) + <br>                      ( pbData[4]         &gt;&gt; 3); <br> <br>    /*  Now compute the residual */ <br>    LONG lCRE = ((pbData[4] &amp; 3) &lt;&lt; 7) + (pbData[5] &gt;&gt; 1); <br>    if (lCRE &gt;= 300) { <br>        DbgLog((LOG_ERROR, 1, TEXT("Clock reference extension &gt;= 300"))); <br>        return FALSE; <br>    } <br> <br>    *pllClock = liClock.QuadPart * 300 + lCRE; <br>    return TRUE; <br>} <br> <br>/*  Parse pack header <br> <br>    Parameters : <br>        pbData - pointer to data containing the system header <br>        cbData - length of data <br> <br>    Returns : <br>        Number of bytes processed (0 if the header doesn't fit <br>        in the data or 4 if the header is invalid) <br>        We will return 0 if we can't see the next start code to <br>        check whether it's a system header start code <br>*/ <br> <br>DWORD ParseMPEG2PackHeader(const BYTE * pbData, DWORD cbData) <br>{ <br>    ASSERT(cbData &gt;= 4); <br>    ASSERT(*(UNALIGNED DWORD *)pbData == DWORD_SWAP(PACK_START_CODE)); <br> <br>    /*  Is there enough for the basic length ? */ <br>    if (cbData &lt; 18) { <br>        return 0; <br>    } <br>    DWORD dwLen = 14 + (pbData[13] &amp; 0x07); <br>    if (cbData &lt; dwLen + 4) { <br>        return 0; <br>    } <br> <br>    /*  Check check bits '01' */ <br>    if (pbData[4] &amp; 0xC0 != 0x40) { <br>        DbgLog((LOG_ERROR, 1, TEXT("Invalid bits at start of pack"))); <br>        return 4; <br>    } <br>    /*  Get SCR */ <br>    LONGLONG llSCR; <br>    if (!GetExtendedClock(pbData + 4, &amp;llSCR)) { <br>        DbgLog((LOG_ERROR, 1, TEXT("Invalid pack header SCR field"))); <br>        return 4; <br>    } <br> <br>    /*  Get the mux rate */ <br>    DWORD dwMuxRate = (pbData[10] &lt;&lt; (22 - 8)) + <br>                      (pbData[11] &lt;&lt; (22 - 16)) + <br>                      (pbData[12] &gt;&gt; (24 - 22)); <br>    /*  Check the marker bits */ <br>    if ((pbData[12] &amp; 0x03) != 0x03) { <br>        DbgLog((LOG_ERROR, 1, TEXT("Invalid marker bits in pack header"))); <br>        return 4; <br>    } <br> <br>    /*  Check the stuffing bytes */ <br>    for (DWORD i = 14; i &lt; dwLen; i++ ) { <br>        if (pbData[i] != 0xFF) { <br>            DbgLog((LOG_ERROR, 1, TEXT("Invalid pack stuffing byte 0x%2.2X"), <br>                    pbData[i])); <br>            return 4; <br>        } <br>    } <br>    DbgLog((LOG_TRACE, 4, TEXT("Decoded pack - ESCR %s, Mux Rate %d bytes/sec"), <br>            (LPCTSTR)CDisp(llSCR, CDISP_DEC), <br>            dwMuxRate * 50)); <br> <br>    return dwLen; <br>} <br> <br>/*  Parse system header <br> <br>    Parameters : <br>        pbData - pointer to data containing the system header <br>        cbData - length of data <br> <br>    Returns : <br>        Number of bytes processed (0 if the header doesn't fit <br>        in the data or 4 if the header is invalid) <br>*/ <br> <br>LONG ParseSystemHeader(const BYTE * pbData, DWORD cbData) <br>{ <br>    BOOL bHasAudio = FALSE; <br>    BOOL bHasVideo = FALSE; <br> <br>    ASSERT(cbData &gt;= 4); <br>    ASSERT(*(UNALIGNED DWORD *)pbData == DWORD_SWAP(SYSTEM_HEADER_START_CODE)); <br> <br>    /*  Checkt the length */ <br>    if (cbData &lt; 6) { <br>        return 0; <br>    } <br> <br>    DWORD dwLen = 6 + pbData[5] + (pbData[4] &lt;&lt; 8); <br>    if (dwLen &lt; SYSTEM_HEADER_BASIC_LENGTH) { <br>        DbgLog((LOG_ERROR, 1, TEXT("Invalid System Header length"))); <br>        return 4; <br>    } <br> <br>    if (cbData &lt; dwLen) { <br>        return 0; <br>    } <br>    /*  Check the marker bits */ <br>    if (0 == (pbData[6] &amp; 0x80) || <br>        0 == (pbData[8] &amp; 0x01) || <br>        0 == (pbData[10] &amp; 0x20)) { <br>        DbgLog((LOG_ERROR, 1, TEXT("Invalid System Header Marker bits"))); <br>        return 4; <br>    } <br> <br>    /*  Parse the 'buffer bounds and scale' list */ <br>    const BYTE * pbNext = pbData + SYSTEM_HEADER_BASIC_LENGTH; <br>    DWORD cbLeft = dwLen - SYSTEM_HEADER_BASIC_LENGTH; <br>    for ( ; cbLeft &gt;= 3; cbLeft -= 3, pbNext += 3) { <br>        if (pbNext[0] == AUDIO_GLOBAL) { <br>            bHasAudio == TRUE; <br>        } else <br>        if (pbNext[0] == VIDEO_GLOBAL) { <br>            bHasVideo = TRUE; <br>        } else { <br>            if (pbNext[0] &lt; PROGRAM_STREAM_MAP) { <br>                DbgLog((LOG_ERROR, 1, TEXT("Invalid stream id in system header"))); <br>                return 4; <br>            } <br>            if (IsVideoStreamId(pbNext[0])) { <br>                bHasVideo = TRUE; <br>            } else <br>            if (IsAudioStreamId(pbNext[0])) { <br>                bHasAudio = TRUE; <br>            } <br>        } <br>    } <br>    if (cbLeft != 0) { <br>        DbgLog((LOG_ERROR, 1, TEXT("Invalid system header length"))); <br>        return 4; <br>    } <br>    DbgLog((LOG_TRACE, 4, TEXT("System Header %s, %s"), <br>            bHasAudio ? TEXT("audio") : TEXT("No audio"), <br>            bHasVideo ? TEXT("video") : TEXT("No video"))); <br>    return dwLen; <br>} <br> <br>/*  Parse an MPEG-1 packet */ <br>DWORD ParseMPEG1Packet( <br>    const BYTE * pbData, <br>    DWORD cbData, <br>    MPEG_PACKET_DATA *pPacketData <br>) <br>{ <br>    ZeroMemory((PVOID)pPacketData, sizeof(*pPacketData)); <br>    DWORD dwStartCode = DWORD_SWAP(*(UNALIGNED DWORD *)pbData); <br>    DbgLog((LOG_TRACE, 4, TEXT("Parse packet %d bytes"), cbData)); <br>    /*  Send it to the right stream */ <br>    if (cbData &lt; 6) { <br>        return 0; <br>    } <br> <br>    /*  Find the length */ <br>    DWORD dwLen = ((LONG)pbData[4] &lt;&lt; 8) + (LONG)pbData[5] + 6; <br>    DbgLog((LOG_TRACE, 4, TEXT("Packet length %d bytes"), dwLen)); <br>    if (dwLen &gt; cbData) { <br>        return 0; <br>    } <br>    pPacketData-&gt;dwPacketLen = dwLen; <br> <br>    /*  Pull out PTS if any */ <br>    DWORD dwHeaderSize = 6; <br> <br>    if (dwStartCode != PRIVATE_STREAM_2) { <br>        DWORD dwPts = 6; <br>        for (;;) { <br>            if (dwPts &gt;= dwLen) { <br>                return 4; <br>            } <br> <br>            if (pbData[dwPts] &amp; 0x80) { <br>                /*  Stuffing byte */ <br>                if (pbData[dwPts] != 0xFF) { <br>                    return 4; <br>                } <br>                dwPts++; <br>                continue; <br>            } <br> <br>            /*  Check for STD (nextbits == '01') - <br>                we know the next bit is 0 so check the next one after that <br>            */ <br>            if (pbData[dwPts] &amp; 0x40) { // STD stuff <br>                dwPts += 2; <br>                continue; <br>            } <br> <br>            /*  No PTS - normal case */ <br>            if (pbData[dwPts] == 0x0F) { <br>                dwHeaderSize = dwPts + 1; <br>                break; <br>            } <br> <br>            if ((pbData[dwPts] &amp; 0xF0) == 0x20 || <br>                (pbData[dwPts] &amp; 0xF0) == 0x30) { <br> <br> <br>                /*  PTS or PTS and DTS */ <br>                dwHeaderSize = (pbData[dwPts] &amp; 0xF0) == 0x20 ? dwPts + 5 : <br>                                                             dwPts + 10; <br>                if (dwHeaderSize &gt; dwLen) { <br>                    return 4; <br>                } <br>                if (!GetClock(pbData + dwPts, &amp;pPacketData-&gt;llPts)) { <br>                    return 4; <br>                } <br>                pPacketData-&gt;bHasPts = TRUE; <br>                break; <br>            } else { <br>                return 4; <br>                break; <br>            } <br>        } <br>    } <br>    pPacketData-&gt;dwHeaderLen = dwHeaderSize; <br>    return dwLen; <br>} <br> <br>/*  Parse an MPEG-2 packet */ <br>DWORD ParseMPEG2Packet( <br>    const BYTE * pbData, <br>    DWORD cbData, <br>    MPEG_PACKET_DATA *pPacketData) <br>{ <br>    ASSERT(cbData &gt;= 4); <br>    ASSERT(pbData[3] &gt;= PROGRAM_STREAM_MAP); <br> <br>    ZeroMemory((PVOID)pPacketData, sizeof(*pPacketData)); <br> <br>    if (cbData &lt; 6) { <br>        return 0; <br>    } <br>    DWORD dwLen = 6 + pbData[5] + (pbData[4] &lt;&lt; 8); <br>    if (cbData &lt; dwLen + 4) { <br>        return 0; <br>    } <br> <br>    /*  Check for normal */ <br>    switch (pbData[3]) { <br>    case PROGRAM_STREAM_MAP: <br>    case PRIVATE_STREAM_2: <br>    case ECM_STREAM: <br>    case EMM_STREAM: <br>    case PROGRAM_STREAM_DIRECTORY: <br>    case 0xF2: // DSMCC_Stream <br>    case 0xF8: // H.222 Type E <br>    case PADDING_STREAM: <br>        /*  Just the bytes */ <br>        pPacketData-&gt;dwHeaderLen = 6; <br>        pPacketData-&gt;dwPacketLen = dwLen; <br>        pPacketData-&gt;bHasPts = FALSE; <br>        pPacketData-&gt;llPts = 0; <br>        break; <br> <br>    /*  PES header */ <br>    default: <br>        { <br>            if (!ParseMPEG2PacketHeader(pbData, dwLen, pPacketData)) { <br>                return 4; <br>            } <br>        } <br>        break; <br> <br>    } <br>    return dwLen; <br>} <br> <br>/*  Parse a packet header when present */ <br>BOOL ParseMPEG2PacketHeader( <br>    const BYTE * pbData, <br>    DWORD dwLen, <br>    MPEG_PACKET_DATA *pPacketData <br>) <br>{ <br>    /*  Compute the length */ <br>    if (dwLen &lt; 6 + 3) { <br>        return FALSE; <br>    } <br> <br>    pPacketData-&gt;dwHeaderLen = 6 + 3 + pbData[8]; <br>    pPacketData-&gt;dwPacketLen = dwLen; <br> <br>    /*  Extract the PTS */ <br>    if (MPEG2PacketHasPTS(pbData)) { <br>        pPacketData-&gt;bHasPts = TRUE; <br>        pPacketData-&gt;llPts = MPEG2PacketPTS(pbData); <br>    } else { <br>        pPacketData-&gt;bHasPts = FALSE; <br>        pPacketData-&gt;llPts = 0; <br>    } <br> <br>    return TRUE; <br>} <br> <br>BOOL ParseSequenceHeader(const BYTE *pbData, LONG lData, SEQHDR_INFO *pInfo) <br>{ <br>    ASSERT(*(UNALIGNED DWORD *)pbData == DWORD_SWAP(SEQUENCE_HEADER_CODE)); <br> <br>    /*  Check random marker bit */ <br>    if (!(pbData[10] &amp; 0x20)) { <br>        DbgLog((LOG_ERROR, 2, TEXT("Sequence header invalid marker bit"))); <br>        return FALSE; <br>    } <br> <br>    DWORD dwWidthAndHeight = ((DWORD)pbData[4] &lt;&lt; 16) + <br>                             ((DWORD)pbData[5] &lt;&lt; 8) + <br>                             ((DWORD)pbData[6]); <br> <br>    pInfo-&gt;lWidth = dwWidthAndHeight &gt;&gt; 12; <br>    pInfo-&gt;lHeight = dwWidthAndHeight &amp; 0xFFF; <br>    DbgLog((LOG_TRACE, 2, TEXT("Width = %d, Height = %d"), <br>        pInfo-&gt;lWidth, <br>        pInfo-&gt;lHeight)); <br> <br>    /* the '8' bit is the scramble flag used by sigma designs - ignore */ <br>    BYTE PelAspectRatioAndPictureRate = pbData[7]; <br>    if ((PelAspectRatioAndPictureRate &amp; 0x0F) &gt; 8) { <br>        PelAspectRatioAndPictureRate &amp;= 0xF7; <br>    } <br>    DbgLog((LOG_TRACE, 2, TEXT("Pel Aspect Ratio = %s"), <br>        PelAspectRatios[PelAspectRatioAndPictureRate &gt;&gt; 4])); <br>    DbgLog((LOG_TRACE, 2, TEXT("Picture Rate = %s"), <br>        PictureRates[PelAspectRatioAndPictureRate &amp; 0x0F])); <br> <br>    if ((PelAspectRatioAndPictureRate &amp; 0xF0) == 0 || <br>        (PelAspectRatioAndPictureRate &amp; 0x0F) == 0) { <br>        DbgLog((LOG_ERROR, 2, TEXT("Sequence header invalid ratio/rate"))); <br>        return FALSE; <br>    } <br> <br>    pInfo-&gt;tPictureTime = (LONGLONG)PictureTimes[PelAspectRatioAndPictureRate &amp; 0x0F]; <br>    pInfo-&gt;fPictureRate = fPictureRates[PelAspectRatioAndPictureRate &amp; 0x0F]; <br>    pInfo-&gt;lTimePerFrame = MulDiv((LONG)pInfo-&gt;tPictureTime, 9, 1000); <br> <br>    /*  Pull out the bit rate and aspect ratio for the type */ <br>    pInfo-&gt;dwBitRate = ((((DWORD)pbData[8] &lt;&lt; 16) + <br>                   ((DWORD)pbData[9] &lt;&lt; 8) + <br>                   (DWORD)pbData[10]) &gt;&gt; 6); <br>    if (pInfo-&gt;dwBitRate == 0x3FFFF) { <br>        DbgLog((LOG_TRACE, 2, TEXT("Variable video bit rate"))); <br>        pInfo-&gt;dwBitRate = 0; <br>    } else { <br>        pInfo-&gt;dwBitRate *= 400; <br>        DbgLog((LOG_TRACE, 2, TEXT("Video bit rate is %d bits per second"), <br>               pInfo-&gt;dwBitRate)); <br>    } <br> <br>#if 0 <br>#pragma message (REMIND("Get pel aspect ratio right don't call GDI - it will create a thread!")) <br>    /*  Get a DC */ <br>    HDC hdc = GetDC(GetDesktopWindow()); <br> <br>    ASSERT(hdc != NULL); <br>    /*  Guess (randomly) 39.37 inches per meter */ <br>    LONG lNotionalPelsPerMeter = MulDiv((LONG)GetDeviceCaps(hdc, LOGICALPELSX), <br>                                        3937, 100); <br>#else <br>    LONG lNotionalPelsPerMeter = 2000; <br>#endif <br> <br>    pInfo-&gt;lXPelsPerMeter = lNotionalPelsPerMeter; <br> <br>    pInfo-&gt;lYPelsPerMeter = MulDiv( <br>                              lNotionalPelsPerMeter, <br>                              AspectRatios[PelAspectRatioAndPictureRate &gt;&gt; 4], <br>                              10000); <br>    /*  Pull out the vbv */ <br>    pInfo-&gt;lvbv = ((((LONG)pbData[10] &amp; 0x1F) &lt;&lt; 5) | <br>             ((LONG)pbData[11] &gt;&gt; 3)) * 2048; <br> <br>    DbgLog((LOG_TRACE, 2, TEXT("vbv size is %d bytes"), pInfo-&gt;lvbv)); <br> <br>    /*  Check constrained parameter stuff */ <br>    if (pbData[11] &amp; 0x04) { <br>        DbgLog((LOG_TRACE, 2, TEXT("Constrained parameter video stream"))); <br> <br>        if (pInfo-&gt;lvbv &gt; 40960) { <br>            DbgLog((LOG_ERROR, 1, TEXT("Invalid vbv (%d) for Constrained stream"), <br>                    pInfo-&gt;lvbv)); <br> <br>            /*  Have to let this through too!  bisp.mpg has this */ <br>            /*  But constrain it since it might be random        */ <br>            pInfo-&gt;lvbv = 40960; <br>        } <br>    } else { <br>        DbgLog((LOG_TRACE, 2, TEXT("Non-Constrained parameter video stream"))); <br>    } <br> <br>    /*  tp_orig has a vbv of 2048 (!) */ <br>    if (pInfo-&gt;lvbv &lt; 20000) { <br>        DbgLog((LOG_TRACE, 2, TEXT("Small vbv (%d) - setting to 40960"), <br>               pInfo-&gt;lvbv)); <br>        pInfo-&gt;lvbv = 40960; <br>    } <br> <br>    pInfo-&gt;lActualHeaderLen = SequenceHeaderSize(pbData); <br>    CopyMemory((PVOID)pInfo-&gt;RawHeader, (PVOID)pbData, pInfo-&gt;lActualHeaderLen); <br>    return TRUE; <br>} <br> <br>HRESULT GetVideoMediaType(CMediaType *cmt, BOOL bPayload, const SEQHDR_INFO *pInfo) <br>{ <br>    cmt-&gt;majortype = MEDIATYPE_Video; <br>    cmt-&gt;subtype = bPayload ? MEDIASUBTYPE_MPEG1Payload : <br>                              MEDIASUBTYPE_MPEG1Packet; <br>    VIDEOINFO *videoInfo = <br>        (VIDEOINFO *)cmt-&gt;AllocFormatBuffer(FIELD_OFFSET(MPEG1VIDEOINFO, bSequenceHeader[pInfo-&gt;lActualHeaderLen])); <br>    if (videoInfo == NULL) { <br>        return E_OUTOFMEMORY; <br>    } <br>    RESET_HEADER(videoInfo); <br> <br>    videoInfo-&gt;dwBitRate          = pInfo-&gt;dwBitRate; <br>    videoInfo-&gt;rcSource.right     = pInfo-&gt;lWidth; <br>    videoInfo-&gt;bmiHeader.biWidth  = pInfo-&gt;lWidth; <br>    videoInfo-&gt;rcSource.bottom    = pInfo-&gt;lHeight; <br>    videoInfo-&gt;bmiHeader.biHeight = pInfo-&gt;lHeight; <br>    videoInfo-&gt;bmiHeader.biXPelsPerMeter = pInfo-&gt;lXPelsPerMeter; <br>    videoInfo-&gt;bmiHeader.biYPelsPerMeter = pInfo-&gt;lYPelsPerMeter; <br>    videoInfo-&gt;bmiHeader.biSize   = sizeof(BITMAPINFOHEADER); <br> <br>    videoInfo-&gt;AvgTimePerFrame = pInfo-&gt;tPictureTime; <br>    MPEG1VIDEOINFO *mpgvideoInfo = (MPEG1VIDEOINFO *)videoInfo; <br>    mpgvideoInfo-&gt;cbSequenceHeader = pInfo-&gt;lActualHeaderLen; <br>    CopyMemory((PVOID)mpgvideoInfo-&gt;bSequenceHeader, <br>               (PVOID)pInfo-&gt;RawHeader, <br>               pInfo-&gt;lActualHeaderLen); <br>    mpgvideoInfo-&gt;dwStartTimeCode = pInfo-&gt;dwStartTimeCode; <br> <br> <br>    cmt-&gt;SetFormatType(&amp;FORMAT_MPEGVideo); <br>    return S_OK; <br>} <br> <br>BOOL CheckAudioHeader(const BYTE * pbData) <br>{ <br>    /*  Just check it's valid */ <br>#pragma message (REMIND("Check audio header")) <br>    if ((pbData[2] &amp; 0x0C) == 0x0C) { <br>        DbgLog((LOG_ERROR, 2, TEXT("Invalid audio sampling frequency"))); <br>        return FALSE; <br>    } <br>    if ((pbData[1] &amp; 0x08) != 0x08) { <br>        DbgLog((LOG_ERROR, 2, TEXT("Invalid audio ID bit = 0"))); <br>        return FALSE; <br>    } <br>    if (((pbData[1] &gt;&gt; 1) &amp; 3) == 0x00) { <br>        DbgLog((LOG_ERROR, 2, TEXT("Invalid audio Layer"))); <br>        return FALSE; <br>    } <br> <br>    if (((pbData[2] &gt;&gt; 2) &amp; 3) == 3) { <br>        DbgLog((LOG_ERROR, 2, TEXT("Invalid sample rate"))); <br>        return FALSE; <br>    } <br>    if ((pbData[2] &gt;&gt; 4) == 0x0F) { <br>        DbgLog((LOG_ERROR, 2, TEXT("Invalid bit rate"))); <br>        return FALSE; <br>    } <br> <br>    return TRUE; <br>} <br> <br>LONG SampleRate(const BYTE * pbData) <br>{ <br>    switch ((pbData[2] &gt;&gt; 2) &amp; 3) { <br>        case 0: <br>            return 44100; <br> <br>        case 1: <br>            return 48000; <br> <br>        case 2: <br>            return 32000; <br> <br>        default: <br>            DbgBreak("Unexpected Sample Rate"); <br>            return 44100; <br>    } <br>} <br> <br>BOOL ParseAudioHeader(const BYTE * pbData, MPEG1WAVEFORMAT *pFormat) <br>{ <br>    if (!CheckAudioHeader(pbData)) { <br>        return FALSE; <br>    } <br>    pFormat-&gt;wfx.wFormatTag = WAVE_FORMAT_MPEG; <br> <br>    /*  Get number of channels from Mode */ <br>    switch (pbData[3] &gt;&gt; 6) { <br>    case 0x00: <br>        pFormat-&gt;fwHeadMode = ACM_MPEG_STEREO; <br>        break; <br>    case 0x01: <br>        pFormat-&gt;fwHeadMode = ACM_MPEG_JOINTSTEREO; <br>        break; <br>    case 0x02: <br>        pFormat-&gt;fwHeadMode = ACM_MPEG_DUALCHANNEL; <br>        break; <br>    case 0x03: <br>        pFormat-&gt;fwHeadMode = ACM_MPEG_SINGLECHANNEL; <br>        break; <br>    } <br>    pFormat-&gt;wfx.nChannels = <br>        (WORD)(pFormat-&gt;fwHeadMode == ACM_MPEG_SINGLECHANNEL ? 1 : 2); <br>    pFormat-&gt;fwHeadModeExt = (WORD)(1 &lt;&lt; (pbData[3] &gt;&gt; 4)); <br>    pFormat-&gt;wHeadEmphasis = (WORD)((pbData[3] &amp; 0x03) + 1); <br>    pFormat-&gt;fwHeadFlags   = (WORD)(((pbData[2] &amp; 1) ? ACM_MPEG_PRIVATEBIT : 0) + <br>                           ((pbData[3] &amp; 8) ? ACM_MPEG_COPYRIGHT : 0) + <br>                           ((pbData[3] &amp; 4) ? ACM_MPEG_ORIGINALHOME : 0) + <br>                           ((pbData[1] &amp; 1) ? ACM_MPEG_PROTECTIONBIT : 0) + <br>                           ((pbData[1] &amp; 0x08) ? ACM_MPEG_ID_MPEG1 : 0)); <br> <br>    int Layer; <br> <br>    /*  Get the layer so we can work out the bit rate */ <br>    switch ((pbData[1] &gt;&gt; 1) &amp; 3) { <br>        case 3: <br>            pFormat-&gt;fwHeadLayer = ACM_MPEG_LAYER1; <br>            Layer = 1; <br>            break; <br>        case 2: <br>            pFormat-&gt;fwHeadLayer = ACM_MPEG_LAYER2; <br>            Layer = 2; <br>            break; <br>        case 1: <br>            pFormat-&gt;fwHeadLayer = ACM_MPEG_LAYER3; <br>            Layer = 3; <br>            break; <br>        case 0: <br>            return (FALSE); <br>    } <br> <br>    /*  Get samples per second from sampling frequency */ <br>    pFormat-&gt;wfx.nSamplesPerSec = SampleRate(pbData); <br>    pFormat-&gt;dwHeadBitrate = <br>        (DWORD)BitRates[Layer - 1][pbData[2] &gt;&gt; 4] * 1000; <br>    pFormat-&gt;wfx.nAvgBytesPerSec = pFormat-&gt;dwHeadBitrate / 8; <br> <br>    /*  Deal with free format (!) */ <br>#pragma message (REMIND("Handle variable bit rate (index 0)")) <br> <br>    if (pFormat-&gt;wfx.nSamplesPerSec != 44100 &amp;&amp; <br>        /*  Layer 3 can sometimes switch bitrates */ <br>        !(Layer == 3 &amp;&amp; /* !m_pStreamList-&gt;AudioLock() &amp;&amp; */ <br>            (pbData[2] &gt;&gt; 4) == 0)) { <br> <br>        if (Layer == 1) { <br>            pFormat-&gt;wfx.nBlockAlign = (WORD) <br>                (4 * ((pFormat-&gt;dwHeadBitrate * 12) / pFormat-&gt;wfx.nSamplesPerSec)); <br>        } else { <br>            pFormat-&gt;wfx.nBlockAlign = (WORD) <br>                ((144 * pFormat-&gt;dwHeadBitrate) / pFormat-&gt;wfx.nSamplesPerSec); <br>        } <br>    } else { <br>        pFormat-&gt;wfx.nBlockAlign = 1; <br>    } <br> <br> <br>    pFormat-&gt;wfx.wBitsPerSample = 0; <br>    pFormat-&gt;wfx.cbSize = sizeof(MPEG1WAVEFORMAT) - sizeof(WAVEFORMATEX); <br> <br>    pFormat-&gt;dwPTSLow  = 0; <br>    pFormat-&gt;dwPTSHigh = 0; <br> <br>    return TRUE; <br>} <br> <br>BOOL GetClock(const BYTE * pData, LONGLONG *Clock) <br>{ <br>    BYTE  Byte1 = pData[0]; <br>    DWORD Word2 = ((DWORD)pData[1] &lt;&lt; 8) + (DWORD)pData[2]; <br>    DWORD Word3 = ((DWORD)pData[3] &lt;&lt; 8) + (DWORD)pData[4]; <br> <br>    /*  Do checks */ <br>    if ((Byte1 &amp; 0xE0) != 0x20 || <br>        (Word2 &amp; 1) != 1 || <br>        (Word3 &amp; 1) != 1) { <br>        DbgLog((LOG_TRACE, 2, TEXT("Invalid clock field - 0x%2.2X 0x%4.4X 0x%4.4X"), <br>            Byte1, Word2, Word3)); <br>        return FALSE; <br>    } <br> <br>    LARGE_INTEGER liClock; <br>    liClock.HighPart = (Byte1 &amp; 8) != 0; <br>    liClock.LowPart  = (DWORD)((((DWORD)Byte1 &amp; 0x6) &lt;&lt; 29) + <br>                       (((DWORD)Word2 &amp; 0xFFFE) &lt;&lt; 14) + <br>                       ((DWORD)Word3 &gt;&gt; 1)); <br> <br>    *Clock = liClock.QuadPart; <br> <br>    return TRUE; <br>} <br> <br>/*  Find the next start code */ <br>BOOL NextStartCode(const BYTE * *ppbData, DWORD *pdwLeft) <br>{ <br>    const BYTE * pbData = *ppbData; <br>    DWORD dwLeft = *pdwLeft; <br> <br>    while (dwLeft &gt; 4 &amp;&amp; <br>           (*(UNALIGNED DWORD *)pbData &amp; 0x00FFFFFF) != 0x00010000) { <br>        dwLeft--; <br>        pbData++; <br>    } <br>    *ppbData = pbData; <br>    *pdwLeft = dwLeft; <br>    return dwLeft &gt;= 4; <br>} <br> <br>/*  Parse AC3 header */ <br>BOOL ParseAC3Header(const BYTE * pbData, DOLBYAC3WAVEFORMAT *pwf) <br>{ <br>    ZeroMemory((PVOID)pwf, sizeof(*pwf)); <br>    pwf-&gt;wfx.cbSize = sizeof(DOLBYAC3WAVEFORMAT) - sizeof(WAVEFORMATEX); <br> <br>    /*  First check it IS AC3 */ <br>    if (pbData[0] == 0x77 &amp;&amp; pbData[1] == 0x0B) { <br>    } else <br>    if (pbData[0] == 0x0B &amp;&amp; pbData[1] == 0x77) { <br>        pwf-&gt;bBigEndian = TRUE; <br>    } else { <br>        return FALSE; <br>    } <br> <br>    /*  Get the sampling rate */ <br>    BYTE bData = pwf-&gt;bBigEndian ? pbData[4] : pbData[5]; <br>    int SampleRateCode = bData &gt;&gt; 6; <br>    int BitRateCode = bData &amp; 0x3F; <br>    switch (SampleRateCode) { <br>    case 1: <br>        pwf-&gt;wfx.nSamplesPerSec = 44100; <br>        break; <br>    case 2: <br>        pwf-&gt;wfx.nSamplesPerSec = 32000; <br>        break; <br> <br>    default:  // Isn't one illegal? <br>        pwf-&gt;wfx.nSamplesPerSec = 48000; <br>        break; <br>    } <br> <br>    if (BitRateCode &gt;= 38) { <br>        return FALSE; <br>    } <br> <br>    /*  Get the bit rate */ <br>    int BitRates[] = <br>    { <br>      32,  32,  40,  40,  48,  48,  56,  56,  64,  64, <br>      80,  80,  96,  96, 112, 112, 128, 128, 160, 160, <br>      192, 192, 224, 224, 256, 256, 320, 320, 384, 384, <br>      448, 448, 512, 512, 576, 576, 640, 640 <br>    }; <br>    pwf-&gt;wfx.nAvgBytesPerSec = BitRates[BitRateCode] * (1000 / 8); <br> <br>    /*  Get the frame size <br>        Since every frame contains 1536 samples we can compute it as <br> <br>        Bypes per frame  = Samples per frame (1536)  * Bytes per second <br>                           -------------------------------------------- <br>                                      Samples per second <br>    */ <br>    pwf-&gt;wfx.nBlockAlign = MulDiv(1536, <br>                              pwf-&gt;wfx.nAvgBytesPerSec, <br>                              pwf-&gt;wfx.nSamplesPerSec); <br> <br>    pwf-&gt;wfx.nChannels = 6; // Hack! <br>    pwf-&gt;wfx.wFormatTag = WAVE_FORMAT_DOLBY_AC3; <br> <br>    DbgLog((LOG_TRACE, 3, TEXT("Wave Format Dolby AC3"))); <br>    DbgLog((LOG_TRACE, 3, TEXT("%d bytes per sec, %d samples per sec, align %d"), <br>           pwf-&gt;wfx.nAvgBytesPerSec, <br>           pwf-&gt;wfx.nSamplesPerSec, <br>           pwf-&gt;wfx.nBlockAlign)); <br> <br>    return TRUE; <br>} <br> <br>/*  Return the PTS clock value as a 33 bit number <br>    Returns LONGLONG(-1) if the clock is invalid <br>*/ <br>LONGLONG MPEG2PacketPTS(const BYTE * pbPacket) <br>{ <br>    ASSERT(MPEG2PacketHasPTS(pbPacket)); <br>    LONGLONG llClock; <br>    if (!GetClock(pbPacket + 9, &amp;llClock)) { <br>        return (LONGLONG)-1; <br>    } <br>    return llClock; <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
