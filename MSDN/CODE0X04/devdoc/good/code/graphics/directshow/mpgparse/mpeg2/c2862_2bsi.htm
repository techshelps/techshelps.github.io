<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MPEG2.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2862"></a>MPEG2.CPP</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1996 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>#include &lt;streams.h&gt; <br>#include &lt;pullpin.h&gt; <br>#include &lt;mmreg.h&gt; <br>#include &lt;mpeg2typ.h&gt; <br>#include &lt;alloc.h&gt; <br>#include &lt;splitter.h&gt; <br>#include &lt;mpegdef.h&gt; <br>#include &lt;mpgutil.h&gt; <br>#include &lt;initguid.h&gt; <br>#include &lt;mpeg2ids.h&gt; <br>#include &lt;mpeg2.h&gt; <br>//  59b41160-f483-11cf-a66b-00aa00bf96aa <br>DEFINE_GUID(CLSID_MPEG2Sample, <br>    0x59b41160, 0xf483, 0x11cf, 0xa6, 0x6b, 0x00, 0xaa, 0x00, 0xbf, 0x96, 0xaa); <br> <br> <br>/*  Stuff to make this into a filter */ <br>/* List of class IDs and creator functions for the class factory. This <br>   provides the link between the OLE entry point in the DLL and an object <br>   being created. The class factory will call the static CreateInstance <br>   function when it is asked to create a CLSID_MPEG2Splitter object */ <br> <br>CFactoryTemplate g_Templates[1] = { <br>    {L"MPEG2 Sample", &amp;CLSID_MPEG2Sample, CMPEG2SplitterFilter::CreateInstance} <br>}; <br> <br>int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]); <br> <br> <br>/* This goes in the factory template table to create new instances */ <br> <br>CUnknown *CMPEG2SplitterFilter::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr) <br>{ <br>    CUnknown *pUnkRet = new CMPEG2SplitterFilter(pUnk, phr); <br>    return pUnkRet; <br>} <br> <br>/*  Registration setup stuff */ <br>//  Setup data <br> <br>AMOVIESETUP_MEDIATYPE sudMpgInputType[] = <br>{ <br>    { &amp;MEDIATYPE_Stream, &amp;MEDIASUBTYPE_MPEG2_PROGRAM } <br>}; <br>AMOVIESETUP_MEDIATYPE sudMpgAudioOutputType[] = <br>{ <br>    { &amp;MEDIATYPE_Audio, &amp;MEDIASUBTYPE_MPEG1AudioPayload } <br>}; <br>AMOVIESETUP_MEDIATYPE sudMpgVideoOutputType[] = <br>{ <br>    { &amp;MEDIATYPE_Video, &amp;MEDIASUBTYPE_MPEG2_VIDEO } <br>}; <br> <br>AMOVIESETUP_PIN sudMpgPins[3] = <br>{ <br>    { L"Input", <br>      FALSE,                               // bRendered <br>      FALSE,                               // bOutput <br>      FALSE,                               // bZero <br>      FALSE,                               // bMany <br>      &amp;CLSID_NULL,                         // clsConnectsToFilter <br>      NULL,                                // ConnectsToPin <br>      NUMELMS(sudMpgInputType),            // Number of media types <br>      sudMpgInputType <br>    }, <br>    { L"Audio Output", <br>      FALSE,                               // bRendered <br>      TRUE,                                // bOutput <br>      TRUE,                                // bZero <br>      FALSE,                               // bMany <br>      &amp;CLSID_NULL,                         // clsConnectsToFilter <br>      NULL,                                // ConnectsToPin <br>      NUMELMS(sudMpgAudioOutputType),      // Number of media types <br>      sudMpgAudioOutputType <br>    }, <br>    { L"Video Output", <br>      FALSE,                               // bRendered <br>      TRUE,                                // bOutput <br>      TRUE,                                // bZero <br>      FALSE,                               // bMany <br>      &amp;CLSID_NULL,                         // clsConnectsToFilter <br>      NULL,                                // ConnectsToPin <br>      NUMELMS(sudMpgVideoOutputType),      // Number of media types <br>      sudMpgVideoOutputType <br>    } <br>}; <br> <br>AMOVIESETUP_FILTER sudMpgsplit = <br>{ <br>    &amp;CLSID_MPEG2Sample, <br>    L"MPEG2 Splitter Sample", <br>    0,                                     // Don't use us for real! <br>    NUMELMS(sudMpgPins),                   // 3 pins <br>    sudMpgPins <br>}; <br> <br> <br>// <br>// DllRegisterSever <br>// <br>// Handle the registration of this filter <br>// <br>STDAPI DllRegisterServer() <br>{ <br>    return AMovieDllRegisterServer(); <br> <br>} // DllRegisterServer <br> <br>//  Constructor and destructor <br>CMPEG2SplitterFilter::CMPEG2SplitterFilter( <br>   LPUNKNOWN pUnk, <br>   HRESULT *phr) : <br>   CBaseSplitterFilter( <br>       TEXT("CMPEG2SplitterFilter"), <br>       pUnk, <br>       CLSID_MPEG2Sample, <br>       phr) <br>{ <br>    //  Create our input pin <br>    m_pInput = new CSplitterInputPin(this, phr); <br>} <br> <br>//  Override type checking and connection completion <br>HRESULT CMPEG2SplitterFilter::CheckInputType(const CMediaType *pmt) <br>{ <br>    if (pmt-&gt;majortype != MEDIATYPE_Stream || <br>        pmt-&gt;subtype != MEDIASUBTYPE_MPEG2_PROGRAM &amp;&amp; <br>        pmt-&gt;subtype != MEDIASUBTYPE_NULL) { <br>        return S_FALSE; <br>    } else { <br>        return S_OK; <br>    } <br>} <br> <br> <br>LPAMOVIESETUP_FILTER CMPEG2SplitterFilter::GetSetupData() <br>{ <br>    return &amp;sudMpgsplit; <br>} <br> <br>/*  Complete connection and instantiate parser <br>    This involves: <br> <br>    Instatiate the parser with for the type and have it check the format <br>*/ <br> <br>CBaseParser *CMPEG2SplitterFilter::CreateParser( <br>    CParserNotify *pNotify, <br>    CMediaType *pType <br>) <br>{ <br>    HRESULT hr = S_OK; <br>    return new CMPEG2Parser(pNotify, &amp;hr); <br>} <br> <br>/*  Cheap'n nasty parser - DON'T do yours like this! */ <br>/*  Initialize a parser <br> <br>    pmt     - type of stream if known - can be NULL <br>    pRdr    - way to read the source medium - can be NULL <br>*/ <br>HRESULT CMPEG2Parser::Init(CParseReader *pRdr) <br>{ <br>    const DWORD dwLen = 65536 * 4; <br>    /*  Just read 32K and look for interesting stuff */ <br>    PBYTE pbData = new BYTE[dwLen]; <br>    if (pbData == NULL) { <br>        return E_OUTOFMEMORY; <br>    } <br>    HRESULT hr = pRdr-&gt;Read(pbData, dwLen); <br>    if (S_OK != hr) { <br>        delete [] pbData; <br>        return hr; <br>    } <br> <br>    /*  Now just loop looking for start codes */ <br>    DWORD dwLeft = dwLen; <br>    const BYTE * pbCurrent = pbData; <br>    while (dwLeft &gt;= 140) { <br>        DWORD dwCode = *(UNALIGNED DWORD *)pbCurrent; <br> <br>        /*  Check if it's a valid start code */ <br>        if ((dwCode &amp; 0x00FFFFFF) == 0x00010000) { <br>            dwCode = DWORD_SWAP(dwCode); <br>            /*  Look for a system header */ <br>            if (dwCode == PACK_START_CODE) { <br>                DWORD dwLen = MPEG2PackHeaderLength(pbCurrent, dwLeft); <br>                if (dwLen == 0) { <br> <br>                    /*  Need more data */ <br>                    break; <br>                } else { <br> <br>                    /*  Skip this item */ <br>                    dwLeft -= dwLen; <br>                    pbCurrent += dwLen; <br>                    continue; <br>                } <br>            } <br>            if (dwCode == SYSTEM_HEADER_START_CODE) { <br>                /*  Parse the MPEG-2 system header */ <br>                DWORD dwLen = ParseSystemHeader(pbCurrent, dwLeft); <br>                if (dwLen &gt; 4) { <br>                    /*  Pull out the stream info */ <br>                    BYTE bStreams = pbCurrent[SYSTEM_HEADER_BASIC_LENGTH]; <br>                    DWORD cbStreams = dwLen - SYSTEM_HEADER_BASIC_LENGTH; <br>                    ASSERT(cbStreams % 3 == 0); <br>                    const BYTE *pbStreams = pbCurrent + SYSTEM_HEADER_BASIC_LENGTH; <br>                    for ( ;cbStreams &gt; 0 ; pbStreams += 3, cbStreams -= 3) { <br>                        if (pbStreams[0] == AUDIO_GLOBAL) { <br>                            m_bHasAudio = TRUE; <br>                        } else <br>                        if (pbStreams[0] == VIDEO_GLOBAL) { <br>                            m_bHasVideo = TRUE; <br>                        } else { <br>                            if (IsAudioStreamId(pbStreams[0])) { <br>                                m_bHasAudio = TRUE; <br>                                if (m_uAudioStreamId == 0) { <br>                                    m_uAudioStreamId = pbStreams[0]; <br>                                } <br>                            } <br>                            if (IsVideoStreamId(pbStreams[0])) { <br>                                m_bHasVideo = TRUE; <br>                                if (m_uVideoStreamId == 0) { <br>                                    m_uVideoStreamId = pbStreams[0]; <br>                                } <br>                            } <br>                            StreamInfo(pbStreams[0])-&gt;m_bExists = TRUE; <br>                        } <br> <br>                    } <br>                    pbCurrent += dwLen; <br>                    dwLeft -= dwLen; <br>                    continue; <br>                } else { <br> <br>                    /*  Need more data */ <br>                    if (dwLen == 0) { <br>                        break; <br>                    } <br>                } <br>            } else <br>            if (VALID_PACKET(dwCode)){ <br>                MPEG_PACKET_DATA Info; <br>                DWORD dwPacketLen = ParseMPEG2Packet( <br>                                        pbCurrent, <br>                                        dwLeft, <br>                                        &amp;Info); <br>                if (dwPacketLen &gt; 4) { <br>                    if (!m_bGotFirstPts &amp;&amp; Info.bHasPts) { <br>                        m_llFirstPts = Info.llPts; <br>                        m_bGotFirstPts = TRUE; <br>                    } <br>                    InitStream((UCHAR)(dwCode &amp; 0xFF), <br>                               pbCurrent + Info.dwHeaderLen, <br>                               Info.dwPacketLen - Info.dwHeaderLen <br>                              ); <br> <br>                    if (IsVideoStreamId((BYTE)(dwCode &amp; 0xFF))) { <br>                        if (m_uVideoStreamId == 0) { <br>                            m_uVideoStreamId = (BYTE)(dwCode &amp; 0xFF); <br>                        } <br>                    } else if (IsAudioStreamId((BYTE)(dwCode &amp; 0xFF))) { <br>                        if (m_uAudioStreamId == 0) { <br>                            m_uAudioStreamId = (BYTE)(dwCode &amp; 0xFF); <br>                        } <br>                    } <br>                    ASSERT(dwLeft &gt;= dwPacketLen); <br>                    pbCurrent += dwPacketLen; <br>                    dwLeft -= dwPacketLen; <br>                    continue; <br>                } else { <br>                    if (dwPacketLen == 0) { <br>                        break; <br>                    } <br>                } <br>            } <br>        } <br> <br>        /*  Hideously inefficient but then for program stream this shouldn't <br>            happen very often! */ <br>        pbCurrent++; <br>        dwLeft--; <br>    } <br>    delete [] pbData; <br>    if (!m_bGotFirstPts || (m_uAudioStreamId == 0 &amp;&amp; m_uVideoStreamId == 0)) { <br>        return VFW_E_TYPE_NOT_ACCEPTED; <br>    } else { <br>        return S_OK; <br>    } <br>} <br> <br> <br>/*  Get the size and count of buffers preferred based on the <br>    actual content <br>*/ <br>void CMPEG2Parser::GetSizeAndCount(LONG *plSize, LONG *plCount) <br>{ <br>    /*  HACK HACK - fix this depending on the stream */ <br>    *plSize = 65536; <br>    *plCount = 8; <br>} <br> <br>/*  Call this to reinitialize for a new stream */ <br>void CMPEG2Parser::StreamReset() <br>{ <br>    /*  Find the type of each stream */ <br>    for (int i = PROGRAM_STREAM_MAP; i &lt;= PROGRAM_STREAM_DIRECTORY; i++) { <br>        CStream *pStream = m_Streams[i - PROGRAM_STREAM_MAP].m_pStream; <br>        for (CStream *pSearch = pStream; <br>             pSearch != NULL; <br>             pSearch = pSearch-&gt;m_pNext) { <br>            AM_MEDIA_TYPE mt; <br>            pSearch-&gt;m_pNotify-&gt;CurrentMediaType(&amp;mt); <br>            pSearch-&gt;m_bDoPES = mt.majortype == MEDIATYPE_MPEG2_PES; <br>            FreeMediaType(mt); <br>        } <br>    } <br>} <br> <br>/*  Call this to pass new stream data : <br> <br>    pbData        - pointer to data <br>    lData         - length of data <br>    plProcessed   - Amount of data consumed <br>*/ <br>HRESULT CMPEG2Parser::Process( <br>    const BYTE * pbData, <br>    LONG lData, <br>    LONG *plProcessed <br>) <br>{ <br>    /*  Just loop processing packets until we run out of data <br>        We should do a lot more to sync up than just eat a start <br>        code ! <br>    */ <br> <br>    DWORD dwLeft = lData; <br>    const BYTE * pbCurrent = pbData; <br> <br>    while (dwLeft &gt; 4) { <br>        /*  Find a start code */ <br>        DWORD dwCode = DWORD_SWAP(*(UNALIGNED DWORD *)pbCurrent); <br>        MPEG_PACKET_DATA Info; <br>        if (VALID_PACKET(dwCode)) { <br>            DWORD dwPacketLen = ParseMPEG2Packet(pbCurrent, dwLeft, &amp;Info); <br>            if (dwPacketLen == 0) { <br>                break; <br>            } <br>            if (dwPacketLen == 4) { <br>                dwLeft -= 4; <br>                pbCurrent += 4; <br>                continue; <br>            } <br>            /*  If it's a packet we're interested in send it on */ <br>            BYTE uStreamId = (BYTE)(dwCode &amp; 0xFF); <br>            CStream *pStream = StreamInfo(uStreamId)-&gt;FindStream( <br>                                   pbCurrent[Info.dwHeaderLen]); <br>            if (pStream != NULL) { <br>                DbgLog((LOG_TRACE, 3, TEXT("Send sample for stream %2.2X"), <br>                        pStream-&gt;m_uStreamId)); <br>                if (pStream-&gt;m_bDoPES) { <br>                    pStream-&gt;m_pNotify-&gt;SendSample( <br>                        pbCurrent, <br>                        Info.dwPacketLen, <br>                        Info.bHasPts ? TimeStamp(Info.llPts) : 0, <br>                        Info.bHasPts); <br>                } else { <br>                    pStream-&gt;m_pNotify-&gt;SendSample( <br>                        pbCurrent + Info.dwHeaderLen + pStream-&gt;m_dwSkip, <br>                        Info.dwPacketLen - Info.dwHeaderLen - pStream-&gt;m_dwSkip, <br>                        Info.bHasPts ? TimeStamp(Info.llPts) : 0, <br>                        Info.bHasPts); <br>                } <br>            } <br>            dwLeft -= Info.dwPacketLen; <br>            pbCurrent += Info.dwPacketLen; <br>        } else { <br>            dwLeft--; <br>            pbCurrent++; <br>        } <br>    } <br>    *plProcessed = lData - dwLeft; <br>    return S_OK; <br>} <br> <br>/*  Initialize a stream */ <br>HRESULT CMPEG2Parser::InitStream( <br>    UCHAR uStreamId, <br>    const BYTE * pbFirstPacket, <br>    DWORD dwLen <br>) <br>{ <br>    /*  Do nothing if we've already seen this one */ <br>    if (NULL != StreamInfo(uStreamId)-&gt;FindStream(pbFirstPacket[0])) { <br>        return S_OK; <br>    } <br> <br>    /*  This 'base' implementation just finds the audio and video <br>        streams <br>    */ <br>    if (IsAudioStreamId(uStreamId)) { <br>        return InitAudioStream(uStreamId, pbFirstPacket, dwLen); <br>    } <br>    if (IsVideoStreamId(uStreamId)) { <br>        return InitVideoStream(uStreamId, pbFirstPacket, dwLen); <br>    } <br>    if (uStreamId == PRIVATE_STREAM_1) { <br>        return InitPrivateStream1(uStreamId, pbFirstPacket, dwLen); <br>    } <br>    return S_FALSE; <br>} <br> <br> <br> <br>/*  Initialize an audio stream */ <br>HRESULT CMPEG2Parser::InitAudioStream( <br>    UCHAR uStreamId, <br>    const BYTE * pbFirstPacket, <br>    DWORD dwLen <br>) <br>{ <br>    /*  Just assume it's MPEG1 for now (!) */ <br>    MPEG1WAVEFORMAT wf; <br>    if (ParseAudioHeader(pbFirstPacket, &amp;wf)) { <br>        CMediaType cmt(&amp;MEDIATYPE_Audio); <br>        cmt.subtype = MEDIASUBTYPE_MPEG1AudioPayload; <br>        cmt.SetFormat((PBYTE)&amp;wf, sizeof(wf)); <br>        cmt.SetFormatType(&amp;FORMAT_WaveFormatEx); <br>        return CreateDefaultStream( <br>            uStreamId, <br>            L"Audio", <br>            &amp;cmt, <br>            FALSE); <br>    } else { <br>        return VFW_E_UNKNOWN_FILE_TYPE; <br>    } <br>} <br> <br>/*  Initialize a video stream */ <br>HRESULT CMPEG2Parser::InitVideoStream( <br>    UCHAR        uStreamId, <br>    const BYTE * pbFirstPacket, <br>    DWORD        dwLen <br>) <br>{ <br>    /*  Parse the sequence header and extension */ <br> <br>    /*  Find the next start code */ <br> <br>    const BYTE * pbData = pbFirstPacket; <br>    const BYTE * pbStartSequenceHeader; <br>    if (!NextStartCode(&amp;pbData, &amp;dwLen)) { <br>        return VFW_E_UNKNOWN_FILE_TYPE; <br>    } <br>    if (!IsStartCode(pbData, SEQUENCE_HEADER_CODE)) { <br>        return VFW_E_UNKNOWN_FILE_TYPE; <br>    } <br>    if (dwLen &lt; 200) { <br>        return VFW_E_UNKNOWN_FILE_TYPE; <br>    } <br> <br>    /*  Now handle the sequence header the extension follows right <br>        on from the end and must be there, otherwise we're MPEG1 <br>    */ <br>    pbStartSequenceHeader = pbData; <br>    SEQHDR_INFO Info; <br>    if (!ParseSequenceHeader(pbData, dwLen, &amp;Info)) { <br>        return VFW_E_UNKNOWN_FILE_TYPE; <br>    } <br> <br>    /*  Parse the extension (soft of) */ <br> <br>    pbData += Info.lActualHeaderLen; <br>    dwLen -= Info.lActualHeaderLen; <br>    if (!NextStartCode(&amp;pbData, &amp;dwLen)) { <br>        return VFW_E_UNKNOWN_FILE_TYPE; <br>    } <br>    if (!IsStartCode(pbData, EXTENSION_START_CODE)) { <br>        /*  !!  Do MPEG 1 */ <br>        return VFW_E_UNKNOWN_FILE_TYPE; <br>    } <br> <br>    if (dwLen &lt; 14) { <br>        return VFW_E_UNKNOWN_FILE_TYPE; <br>    } <br> <br>    /*  Get the extension info - note that the various extension start <br>        codes can be identified by the 4-bit ID following them <br>        So we can just keep eating extension start codes until we get <br>        bored an looking for the id - it's up to the authors to <br>        deliver them according to the spec order <br>    */ <br>    /*  Check the sequence extension id */ <br>    if ((pbData[4] &gt;&gt; 4) != 0x01) { <br>        DbgLog((LOG_ERROR, 1, TEXT("Bad extension start code id"))); <br>        return VFW_E_UNKNOWN_FILE_TYPE; <br>    } <br> <br>    /*  The escape bit seems not to be used */ <br> <br>    Info.dwProfile = pbData[4] &amp; 0x07; <br>    Info.dwLevel   = pbData[5] &gt;&gt; 4; <br>    DbgLog((LOG_TRACE, 3, TEXT("%s : %s"), <br>           Info.dwProfile == 5 ? TEXT("Simple Profile") : <br>           Info.dwProfile == 4 ? TEXT("Main Profile")   : <br>           Info.dwProfile == 3 ? TEXT("SNR Scalable Profile") : <br>           Info.dwProfile == 2 ? TEXT("Spatially Scalable Profile") : <br>           Info.dwProfile == 1 ? TEXT("High Profile") : <br>                                 TEXT("Unrecognized Profile"), <br>           Info.dwLevel  == 10 ? TEXT("Low Level") : <br>           Info.dwLevel  == 8  ? TEXT("Main Level") : <br>           Info.dwLevel  == 6  ? TEXT("High 1440 Level") : <br>           Info.dwLevel  == 4  ? TEXT("High Level") : <br>                                 TEXT("Unrecognized Level"))); <br>    Info.lWidth += ((pbData[5] &amp; 1) &lt;&lt; 13) + (pbData[6] &amp; 0x80) &lt;&lt; 5; <br>    Info.lHeight += (pbData[6] &amp; 0x60) &lt;&lt; 7; <br>    Info.dwBitRate += 400 * (((pbData[6] &amp; 0x1F) &lt;&lt; (18 + 7)) + <br>                             ((pbData[7] &amp; 0xFE) &lt;&lt; (18 - 1))); <br> <br> <br>    /*  Find out the total length and save it somewhere (!) */ <br>    dwLen -= 4; <br>    pbData += 4; <br>    while (NextStartCode(&amp;pbData, &amp;dwLen)) { <br>        if (!IsStartCode(pbData, EXTENSION_START_CODE)) { <br>            /*  We're there although we may have gone past - too bad */ <br>            DWORD dwHeaderLen = pbData - pbStartSequenceHeader; <br>            break; <br>        } <br>        dwLen -= 4; <br>        pbData += 4; <br>    } <br> <br> <br>    /*  Hack for now - just give them the MPEG1 stuff */ <br>    CMediaType cmt; <br>    HRESULT hr = GetVideoMediaType(&amp;cmt, TRUE, &amp;Info); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br>    cmt.subtype = MEDIASUBTYPE_MPEG2_VIDEO; <br>    cmt.formattype = FORMAT_MPEG2Video; <br> <br>    /*  Create our stream */ <br>    return CreateDefaultStream(uStreamId, L"Video", &amp;cmt); <br>} <br> <br>/*  Initialize a stream */ <br>HRESULT CMPEG2Parser::InitPrivateStream1( <br>    UCHAR uStreamId, <br>    const BYTE * pbFirstPacket, <br>    DWORD dwLen <br>) <br>{ <br>    DbgLog((LOG_TRACE, 0, TEXT("Substream 0x%2.2X"), pbFirstPacket[0])); <br>    HRESULT hr = InitAC3(uStreamId, pbFirstPacket, dwLen); <br>    if (FAILED(hr)) { <br>        hr = InitSubPicture(uStreamId, pbFirstPacket, dwLen); <br>    } <br>    return hr; <br>} <br>/*  Initialize a stream */ <br>HRESULT CMPEG2Parser::InitSubPicture( <br>    UCHAR uStreamId, <br>    const BYTE * pbFirstPacket, <br>    DWORD dwLen <br>) <br>{ <br>    /*  Don't bother with typs and stuff for now - lucky this test <br>        can't be mistaken for AC3! <br>    */ <br> <br>    if ((pbFirstPacket[0] &amp; 0xE0) != 0x20) { <br>        return VFW_E_UNKNOWN_FILE_TYPE; <br>    } <br> <br>    CMediaType cmt(&amp;MEDIATYPE_Video); <br>    cmt.SetSubtype(&amp;MEDIASUBTYPE_SUBPICTURE); <br> <br>    return CreateDefaultStream( <br>               uStreamId, <br>               L"Subpicture", <br>               &amp;cmt, <br>               TRUE, <br>               TRUE, <br>               pbFirstPacket[0]); <br>} <br> <br>/*  Initialize ac3 stream */ <br>HRESULT CMPEG2Parser::InitAC3( <br>    UCHAR uStreamId, <br>    const BYTE * pbFirstPacket, <br>    DWORD dwLen <br>) <br>{ <br>    /*  Do AC3 - there are 3(4?) types : <br> <br>        DVD - substream id 8 (big endian?) <br>        non-DVD - no substream (but should be in program map) <br>        --  Big endian <br>        --  Little endian (laser disk) - sync word 0x77 0x0B <br>        --  Big endian (normal) - sync word 0x0B 0x77 <br> <br>    */ <br> <br>    BOOL bDVD = FALSE; <br>    BOOL bBigEndian = FALSE; <br> <br>    const BYTE *pbData = pbFirstPacket; <br>    if ((pbFirstPacket[0] &amp; 0xF8) == 0x80) { <br>        bDVD = TRUE; <br>        pbData+= 4; <br>    } <br> <br>    if ((pbData[0] == 0x0B &amp;&amp; pbData[1] == 0x77)) { <br>        bBigEndian = TRUE; <br>    } else <br>    if ((pbData[1] == 0x0B &amp;&amp; pbData[0] == 0x77)) { <br>    } else return VFW_E_UNKNOWN_FILE_TYPE; <br> <br>    /*  Parse the rest of the info */ <br>    DOLBYAC3WAVEFORMAT wf; <br>    if (!ParseAC3Header(pbData, &amp;wf)) { <br>        return VFW_E_UNKNOWN_FILE_TYPE; <br>    } <br> <br>    /*  Create our media type */ <br>    CMediaType cmt(&amp;MEDIATYPE_Audio); <br>    cmt.SetSubtype(&amp;MEDIASUBTYPE_DOLBY_AC3); <br>    cmt.SetFormatType(&amp;FORMAT_WaveFormatEx); <br>    cmt.SetFormat((PBYTE)&amp;wf, sizeof(wf)); <br> <br>    /*  Create out stream */ <br>    HRESULT hr = CreateDefaultStream( <br>        uStreamId, <br>        L"AC3", <br>        &amp;cmt, <br>        TRUE, <br>        bDVD, <br>        bDVD ? pbFirstPacket[0] : 0); <br> <br>    if (S_OK != hr) { <br>        return hr; <br>    } <br> <br>    /*  Set up the stream */ <br>    if (bDVD) { <br>        /*  First 4 bytes skipped for DVD */ <br>        StreamInfo(uStreamId)-&gt;m_pStream-&gt;m_dwSkip = 4; <br>    } <br>    return hr; <br>} <br> <br>HRESULT CMPEG2Parser::CreateDefaultStream( <br>    UCHAR   uStreamId, <br>    LPCWSTR lpszName, <br>    CMediaType *pmt, <br>    BOOL bDoPes, <br>    BOOL bHasSubId, <br>    BOOL uSubId <br>) <br>{ <br>    CStreamInfo *pStreamInfo = StreamInfo(uStreamId); <br> <br>    /*  Check this one doesn't already exist */ <br>    if (NULL != pStreamInfo-&gt;FindStream(uSubId)) { <br>        return S_FALSE; <br>    } <br> <br>    CStream *pStream = new CStream(uStreamId, bHasSubId, uSubId); <br>    if (pStream == NULL) { <br>        return E_OUTOFMEMORY; <br>    } <br>    ASSERT(bHasSubId || pStreamInfo-&gt;m_pStream == NULL); <br> <br>    pStream-&gt;m_pNext = pStreamInfo-&gt;m_pStream; <br>    pStreamInfo-&gt;m_pStream = pStream; <br>    m_pNotify-&gt;CreateStream(lpszName, &amp;pStream-&gt;m_pNotify); <br>    pStream-&gt;m_pNotify-&gt;AddMediaType(pmt); <br> <br>    /*  Support PES format too */ <br>    if (bDoPes) { <br>        pmt-&gt;SetType(&amp;MEDIATYPE_MPEG2_PES); <br>        pStream-&gt;m_pNotify-&gt;AddMediaType(pmt); <br>    } <br> <br>    return S_OK; <br>} <br> <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
