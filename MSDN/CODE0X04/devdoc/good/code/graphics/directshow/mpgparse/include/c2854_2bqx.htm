<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SPLITTER.H</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2859"></a>SPLITTER.H</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1996 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br>/*  Parser class - this class defines the object that actually splits <br>    out the data <br>*/ <br> <br>/*  CBaseParser class <br> <br>    This is the object that determines the nature of the data <br>    and actually splits the stream <br>*/ <br> <br>/*  Simple stream reader class */ <br>class CParseReader <br>{ <br>public: <br>    /*  Set the position */ <br>    virtual HRESULT Length(LONGLONG *pLength) = 0; <br>    virtual HRESULT SetPointer(LONGLONG) = 0; <br>    virtual HRESULT Read(PBYTE pbData, DWORD cbData) = 0; <br>}; <br> <br>/*  Parsing reader from CAsyncReader */ <br>class CParseReaderFromAsync : public CParseReader <br>{ <br>public: <br>    CParseReaderFromAsync(IAsyncReader *pRdr) : <br>        m_pReader(pRdr), m_llPos(0) {}; <br>    HRESULT Length(LONGLONG *pLength) <br>    { <br>        LONGLONG llAvailable; <br>        return m_pReader-&gt;Length(pLength, &amp;llAvailable); <br>    } <br>    HRESULT SetPointer(LONGLONG llPos) <br>    { <br>        m_llPos = 0; <br>        return S_OK; <br>    } <br>    HRESULT Read(PBYTE pbData, DWORD cbData) <br>    { <br>        HRESULT hr = m_pReader-&gt;SyncRead(m_llPos, (LONG)cbData, pbData); <br>        if (S_OK == hr) { <br>            m_llPos += cbData; <br>        } <br>        return hr; <br>    } <br> <br>private: <br>    IAsyncReader *m_pReader; <br>    LONGLONG      m_llPos; <br>}; <br>class CParserNotify; <br>class CBaseParser <br>{ <br>public: <br>    /*  Instantiate a parser <br> <br>        pNotify - to call back the calling object to create streams etc <br>    */ <br>    CBaseParser(CParserNotify *pNotify, <br>                HRESULT *phr) : m_pNotify(pNotify) {}; <br> <br>    /*  Initialize a parser <br> <br>        pmt     - type of stream if known - can be NULL <br>        pRdr    - way to read the source medium - can be NULL <br>    */ <br>    virtual HRESULT Init( <br>        CParseReader *pRdr <br>    ) = 0; <br> <br> <br>    /*  Get the size and count of buffers preferred based on the <br>        actual content <br>    */ <br>    virtual void GetSizeAndCount(LONG *plSize, LONG *plCount) = 0; <br> <br>    /*  Call this to reinitialize for a new stream */ <br>    virtual void StreamReset() = 0; <br> <br>    /*  Call this to pass new stream data : <br> <br>        pbData        - pointer to data <br>        lData         - length of data <br>        plProcessed   - Amount of data consumed <br>    */ <br>    virtual HRESULT Process( <br>        const BYTE *pbData, <br>        LONG lData, <br>        LONG *plProcessed <br>    ) = 0; <br>protected: <br>    CParserNotify * const m_pNotify; <br>}; <br> <br>/*  Parser calls back to create streams and spit out <br>    buffers <br>*/ <br>class CStreamNotify; <br>class CParserNotify <br>{ <br>public: <br> <br>    /*  Create an output stream with type *pmt, notifications <br>        to this stream passed to the **pStreamNotify object <br>    */ <br>    virtual HRESULT CreateStream( <br>        LPCWSTR pszName, <br>        CStreamNotify **pStreamNotify) = 0; <br> <br>}; <br> <br> <br>class CStreamNotify <br>{ <br>public: <br>    virtual HRESULT SendSample( <br>        const BYTE *pbData, <br>        LONG lData, <br>        REFERENCE_TIME rtStart, <br>        BOOL bSync <br>    ) = 0; <br> <br>    /*  Add a media type that's supported */ <br>    virtual HRESULT AddMediaType(CMediaType const *pmt) = 0; <br> <br>    /*  Return the current type */ <br>    virtual void CurrentMediaType(AM_MEDIA_TYPE *pmt) = 0; <br>}; <br> <br>/*  Splitter filter base classes */ <br> <br> <br>/*  Design : <br> <br>    A splitter filter will have 1 input pin and multiple output pins <br> <br>    CBaseSplitterFilter defines a base filter with 1 input pin and <br>    a list of output pins. <br> <br>    This base class provides for pin enumeration, correct distribution <br>    of EndOfStream and handling of errors. <br> <br>    The object structure is : <br> <br> <br>                            IsA <br> <br>    CBaseSplitterFilter  &lt;--------  CBaseFilter <br> <br> <br>    Allocators: <br> <br>        This class relies on use CSequentialAllocator <br> <br>        The input pin is designed around CPullPin which hooks up <br>        to IAsyncReader on the upstream output pin <br>*/ <br> <br>class CBaseSplitterFilter; <br>class CBaseParser; <br> <br>/*  Input pin stuff <br> <br>    The input pin deletes all the output pins when it's disconnected <br> <br>    On connection the output pins are created based on the media type <br>    and possibly on the file content <br> <br>    The base class handles things like flushing and end of stream <br>*/ <br> <br>/*  Special output pin type to handle lifetime */ <br>class CSplitterOutputPin : public CBaseOutputPin <br>{ <br> <br>public: <br> <br>    //  Constructor <br>    CSplitterOutputPin( <br>        CBaseSplitterFilter *pFilter, <br>        HRESULT *phr, <br>        LPCWSTR pName); <br> <br>    ~CSplitterOutputPin(); <br> <br>    //  CUnknown methods <br>    STDMETHODIMP_(ULONG) NonDelegatingAddRef(); <br>    STDMETHODIMP_(ULONG) NonDelegatingRelease(); <br> <br>    //  CBaseOutputPin methods - we just override these to do <br>    //  our own hack allocator <br> <br>    // override this to set the buffer size and count. Return an error <br>    // if the size/count is not to your liking <br>    virtual HRESULT DecideBufferSize( <br>                        IMemAllocator * pAlloc, <br>                        ALLOCATOR_PROPERTIES * pProp); <br> <br>    // negotiate the allocator and its buffer size/count <br>    // calls DecideBufferSize to call SetCountAndSize <br>    virtual HRESULT DecideAllocator(IMemInputPin * pPin, IMemAllocator ** pAlloc); <br> <br>    // override this to control the connection <br>    virtual HRESULT InitAllocator(IMemAllocator **ppAlloc); <br> <br>    // Check the media type proposed <br>    HRESULT CheckMediaType(const CMediaType *); <br> <br>    // returns the preferred formats for a pin <br>    HRESULT GetMediaType(int iPosition,CMediaType *pMediaType); <br> <br>    // Send sample generated by parser <br>    HRESULT SendSample( <br>        const BYTE *pbData, <br>        LONG lData, <br>        REFERENCE_TIME rtStart, <br>        BOOL bSync <br>    ); <br> <br>    /*  Add a media type */ <br>    HRESULT AddMediaType( <br>        CMediaType const *pmt <br>    ); <br> <br> <br>    HRESULT DeliverEndOfStream() <br>    { <br>        m_pOutputQueue-&gt;EOS(); <br>        return S_OK; <br>    } <br> <br>    //  Delete our output queue on inactive <br>    HRESULT Inactive() <br>    { <br>        HRESULT hr = CBaseOutputPin::Inactive(); <br>        if (FAILED(hr)) { <br>            return hr; <br>        } <br> <br>        delete m_pOutputQueue; <br>        m_pOutputQueue = NULL; <br>        return S_OK; <br>    } <br> <br>    /*  Wrapper to call output queue to flush samples */ <br>    void SendAnyway() <br>    { <br>        if (NULL != m_pOutputQueue) { <br>            m_pOutputQueue-&gt;SendAnyway(); <br>        } <br>    } <br> <br>    //  Override Active and EndFlush to set the discontinuity flag <br>    HRESULT Active() <br>    { <br>        m_bDiscontinuity = TRUE; <br>        /*  If we're not connected we don't participate so it's OK */ <br>        if (!IsConnected()) { <br>            return S_OK; <br>        } <br> <br>        HRESULT hr = CBaseOutputPin::Active(); <br>        if (FAILED(hr)) { <br>            return hr; <br>        } <br> <br>        /*  Create our batch list */ <br>        ASSERT(m_pOutputQueue == NULL); <br> <br>        hr = S_OK; <br>        m_pOutputQueue = new COutputQueue(GetConnected(), // input pin <br>                                          &amp;hr,            // return code <br>                                          FALSE,          // Auto detect <br>                                          TRUE,           // ignored <br>                                          50,             // batch size <br>                                          TRUE,           // exact batch <br>                                          50);            // queue size <br>        if (m_pOutputQueue == NULL) { <br>            return E_OUTOFMEMORY; <br>        } <br>        if (FAILED(hr)) { <br>            delete m_pOutputQueue; <br>            m_pOutputQueue = NULL; <br>        } <br>        return hr; <br>    } <br>    HRESULT DeliverBeginFlush() <br>    { <br>        /*  We're already locked via the input pin */ <br>        m_pOutputQueue-&gt;BeginFlush(); <br>        return S_OK; <br>    } <br>    HRESULT DeliverEndFlush() <br>    { <br>        /*  We're already locked via the input pin */ <br>        m_bDiscontinuity = TRUE; <br>        m_pOutputQueue-&gt;EndFlush(); <br>        return S_OK; <br>    } <br> <br>    //  Get our notify object <br>    CStreamNotify *GetNotify() <br>    { <br>        return &amp;m_Notify; <br>    } <br> <br>protected: <br>    //  Get a pointer to our allocator <br>    CSubAllocator *Allocator() <br>    { <br>        return (CSubAllocator *)m_pAllocator; <br>    } <br> <br>    //  Get a properly cast pointer to our filter <br>    CBaseSplitterFilter *Filter() <br>    { <br>        return (CBaseSplitterFilter *)m_pFilter; <br>    } <br> <br> <br>protected: <br>    //  Stream notify stuff <br>    class CImplStreamNotify : public CStreamNotify <br>    { <br>    public: <br>        CImplStreamNotify(CSplitterOutputPin *pPin) : m_pPin(pPin) {} <br>        HRESULT SendSample( <br>            const BYTE *pbData, <br>            LONG lData, <br>            REFERENCE_TIME rtStart, <br>            BOOL bSync <br>        ) <br>        { <br>            return m_pPin-&gt;SendSample(pbData, lData, rtStart, bSync); <br>        } <br> <br>        HRESULT AddMediaType(CMediaType const *pmt) <br>        { <br>            return m_pPin-&gt;AddMediaType(pmt); <br>        } <br>        void CurrentMediaType(AM_MEDIA_TYPE *pmt) <br>        { <br>            m_pPin-&gt;ConnectionMediaType(pmt); <br>        } <br> <br>    private: <br>        CSplitterOutputPin * const m_pPin; <br>    }; <br> <br>    CImplStreamNotify  m_Notify; <br> <br>    //  Remember when to send NewSegment and discontinuity */ <br>    BOOL               m_bDiscontinuity; <br> <br>    //  Output queue <br>    COutputQueue      *m_pOutputQueue; <br> <br>    //  List of media types we support <br>    CGenericList&lt;CMediaType&gt; m_lTypes; <br>}; <br> <br> <br>/*  Base CSplitterInputPin on CPullPin <br>*/ <br>class CSplitterInputPin : public CBaseInputPin <br>{ <br>public: <br>    CSplitterInputPin( <br>        CBaseSplitterFilter *pFilter, <br>        HRESULT *phr); <br> <br>    /*  NonDelegating IUnknown methods - we don't support IMemInputPin */ <br>    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv) <br>    { <br>        if (riid == IID_IMemInputPin) { <br>            return E_NOINTERFACE; <br>        } <br>        return CBaseInputPin::NonDelegatingQueryInterface(riid, ppv); <br>    } <br> <br>    /*  IPin methods */ <br>    STDMETHODIMP EndOfStream(); <br>    STDMETHODIMP BeginFlush(); <br>    STDMETHODIMP EndFlush(); <br>    STDMETHODIMP Receive(IMediaSample *pSample); <br> <br>    /*  IMemInputPin methods */ <br> <br>    /*  Where we're told which allocator we are using */ <br>    STDMETHODIMP NotifyAllocator(IMemAllocator *pAllocator) <br>    { <br>        if (pAllocator != (IMemAllocator *)m_pAllocator) { <br>            return E_FAIL; <br>        } else { <br>            return S_OK; <br>        } <br>    } <br> <br>    /*  Say if we're blocking */ <br>    STDMETHODIMP ReceiveCanBlock() <br>    { <br>        return S_FALSE; <br>    } <br> <br> <br>    /*  CBasePin methods */ <br>    HRESULT BreakConnect();  //  Override to release puller <br>    HRESULT CheckConnect(IPin *pPin);  //  Override to connect to puller <br>    HRESULT Active(); <br>    HRESULT Inactive(); <br>    HRESULT CheckMediaType(const CMediaType *pmt); <br>    HRESULT CompleteConnect(IPin *pReceivePin); <br> <br>    /*  Report filter from reader */ <br>    void NotifyError(HRESULT hr) <br>    { <br>        if (FAILED(hr)) { <br>            m_pFilter-&gt;NotifyEvent(EC_ERRORABORT, hr, 0); <br>        } <br>        EndOfStream(); <br>    }; <br> <br>    /*  Convenient way to get the allocator */ <br>    CSequentialAllocator *Allocator() <br>    { <br>        return (CSequentialAllocator *)m_pAllocator; <br>    } <br> <br>    /*  Point to our media type */ <br>    CMediaType *MediaType() <br>    { <br>        return &amp;m_mt; <br>    } <br> <br>    /*  Return our async reader */ <br>    IAsyncReader *Reader() <br>    { <br>        IAsyncReader *pReader = m_puller.GetReader(); <br>        pReader-&gt;Release(); <br>        return pReader; <br>    } <br> <br>private: <br> <br>    //  Get a properly case pointer to our filter <br>    CBaseSplitterFilter *Filter() <br>    { <br>        return (CBaseSplitterFilter *)m_pFilter; <br>    } <br> <br>    // class to pull data from IAsyncReader if we detect that interface <br>    // on the output pin <br>    class CImplPullPin : public CPullPin <br>    { <br>        // forward everything to containing pin <br>        CSplitterInputPin * const m_pPin; <br> <br>    public: <br>        CImplPullPin(CSplitterInputPin* pPin) <br>          : m_pPin(pPin) <br>        { <br>        }; <br> <br>        // forward this to the pin's IMemInputPin::Receive <br>        HRESULT Receive(IMediaSample* pSample) { <br>            return m_pPin-&gt;Receive(pSample); <br>        }; <br> <br>        // override this to handle end-of-stream <br>        HRESULT EndOfStream(void) { <br>            return m_pPin-&gt;EndOfStream(); <br>        }; <br> <br>        // these errors have already been reported to the filtergraph <br>        // by the upstream filter so ignore them <br>        void OnError(HRESULT hr) { <br>            // ignore VFW_E_WRONG_STATE since this happens normally <br>            // during stopping and seeking <br>            if (hr != VFW_E_WRONG_STATE) { <br>                m_pPin-&gt;NotifyError(hr); <br>            } <br>        }; <br> <br>        // flush the pin and all downstream <br>        HRESULT BeginFlush() { <br>            return m_pPin-&gt;BeginFlush(); <br>        }; <br> <br>        // Tell the next guy we've finished flushing <br>        HRESULT EndFlush() { <br>            return m_pPin-&gt;EndFlush(); <br>        }; <br> <br>    }; <br>    CImplPullPin m_puller; <br>}; <br> <br> <br>class CBaseSplitterFilter : public CBaseFilter <br>{ <br>friend class CSplitterOutputPin; <br>friend class CSplitterInputPin; <br> <br>public: <br>    //  Constructor and destructor <br>    CBaseSplitterFilter( <br>       TCHAR *pName, <br>       LPUNKNOWN pUnk, <br>       REFCLSID rclsid, <br>       HRESULT *phr); <br>    ~CBaseSplitterFilter(); <br> <br>    //  IMediaFilter methods - override these to manage locking <br>    STDMETHODIMP Stop(); <br>    STDMETHODIMP Pause(); <br> <br>    /*  Stream control stuff */ <br>    virtual HRESULT BeginFlush(); <br>    virtual HRESULT EndFlush(); <br>    virtual void    EndOfStream(); <br>    virtual HRESULT Receive(IMediaSample *pSample); <br>    virtual HRESULT CheckInputType(const CMediaType *pmt) = 0; <br>    virtual HRESULT CompleteConnect(IPin *pReceivePin); <br> <br>    //  Create the parser <br>    virtual CBaseParser *CreateParser( <br>        CParserNotify *pNotify, <br>        CMediaType *pType) = 0; <br> <br>    //  CBaseFilter methods <br>    int GetPinCount();     // 0 pins <br>    CBasePin *GetPin(int iPin); <br> <br>    /*  Add a new output pin */ <br>    BOOL AddOutputPin(CSplitterOutputPin *pOutputPin); <br> <br>    /*  Destroy the output pins */ <br>    void DestroyOutputPins(); <br> <br>    /*  Destroy the input pin */ <br>    void DestroyInputPin(); <br> <br>    /*  Notify to create a new stream <br>        Called back through CParseNotify <br>    */ <br>    HRESULT CreateStream( <br>        LPCWSTR         pszName, <br>        CStreamNotify **ppStreamNotify <br>    ); <br> <br>    /*  Called when BreakConnect called on the input pin */ <br>    virtual void BreakConnect(); <br> <br>protected: <br> <br> <br>    /*  Utility to get the allocator */ <br>    CSequentialAllocator *Allocator() <br>    { <br>        return InputPin()-&gt;Allocator(); <br>    } <br> <br>    /*  Reset the states of the allocator and parser <br>        ready to receive a new stream <br>    */ <br>    void ResetAllocatorAndParser() <br>    { <br>        Allocator()-&gt;Flush(); <br>        m_pParser-&gt;StreamReset(); <br>    } <br> <br>    CSplitterInputPin *InputPin() <br>    { <br>        return (CSplitterInputPin *)m_pInput; <br>    } <br> <br>protected: <br> <br>    //  Our input pin - created by derived classes <br>    CBaseInputPin           *m_pInput; <br> <br>    //  Our output pin list - Derived classes append to this <br>    CGenericList&lt;CSplitterOutputPin&gt; m_OutputPins; <br> <br>    //  Filter locking <br>    CCritSec                 m_csFilter; <br> <br>    //  Streaming lock <br>    CCritSec                 m_csStream; <br> <br>    //  Pin database lock <br>    CCritSec                 m_csPins; <br> <br>    //  Parser - created when we're connected <br>    CBaseParser             *m_pParser; <br> <br>    //  Parser notify - use member variable to avoid mulitple inheritance <br>    class CImplParserNotify : public CParserNotify <br>    { <br>    public: <br>        CImplParserNotify(CBaseSplitterFilter *pFilter) : m_pFilter(pFilter) {}; <br>        HRESULT CreateStream( <br>            LPCWSTR         pszName, <br>            CStreamNotify **ppStreamNotify <br>        ) <br>        { <br>            return m_pFilter-&gt;CreateStream(pszName, ppStreamNotify); <br>        } <br>    private: <br>        CBaseSplitterFilter * const m_pFilter; <br> <br>    }; <br>    CImplParserNotify        m_Notify; <br>}; <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
