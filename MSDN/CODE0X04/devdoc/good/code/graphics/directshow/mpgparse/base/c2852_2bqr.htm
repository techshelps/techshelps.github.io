<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SPLITTER.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2853"></a>SPLITTER.CPP</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1996 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>#include &lt;streams.h&gt; <br>#include &lt;pullpin.h&gt; <br>#include &lt;alloc.h&gt; <br>#include &lt;splitter.h&gt; <br> <br>/*  Ignore warnings about this pointers being used in member initialization <br>    lists <br>*/ <br>#pragma warning(disable:4355) <br> <br>/*  Splitter output pin methds */ <br> <br>/*  -- Constructor -- */ <br>CSplitterOutputPin::CSplitterOutputPin( <br>        CBaseSplitterFilter *pFilter, <br>        HRESULT *phr, <br>        LPCWSTR pName) : <br>    CBaseOutputPin( <br>        NAME("CSplitterOutputPin"), <br>        pFilter, <br>        &amp;pFilter-&gt;m_csFilter, <br>        phr, <br>        pName), <br>    m_Notify(this), <br>    m_bDiscontinuity(FALSE), <br>    m_pOutputQueue(NULL), <br>    m_lTypes(NAME("CSplitterFilter::m_lTypes")) <br>{ <br>} <br> <br>CSplitterOutputPin::~CSplitterOutputPin() <br>{ <br>    while (m_lTypes.GetCount() != 0) { <br>        delete m_lTypes.RemoveHead(); <br>    } <br>} <br> <br>/* Override revert to normal ref counting <br>   These pins cannot be finally Release()'d while the input pin is <br>   connected */ <br> <br>STDMETHODIMP_(ULONG) <br>CSplitterOutputPin::NonDelegatingAddRef() <br>{ <br>    return CUnknown::NonDelegatingAddRef(); <br>} <br> <br> <br>/* Override to do normal ref counting */ <br> <br>STDMETHODIMP_(ULONG) <br>CSplitterOutputPin::NonDelegatingRelease() <br>{ <br>    return CUnknown::NonDelegatingRelease(); <br>} <br> <br>// override this to set the buffer size and count. Return an error <br>// if the size/count is not to your liking. <br>HRESULT CSplitterOutputPin::DecideBufferSize( <br>    IMemAllocator * pAlloc, <br>    ALLOCATOR_PROPERTIES * pProp <br>) <br>{ <br>    pProp-&gt;cBuffers = 100; <br>    pProp-&gt;cbBuffer = 65536;            /* Don't care about size */ <br>    pProp-&gt;cbAlign = 1; <br>    pProp-&gt;cbPrefix = 0; <br>    ALLOCATOR_PROPERTIES propActual; <br>    return pAlloc-&gt;SetProperties(pProp, &amp;propActual); <br>} <br> <br>// <br>//  Override DecideAllocator because we insist on our own allocator since <br>//  it's 0 cost in terms of bytes <br>// <br>HRESULT CSplitterOutputPin::DecideAllocator( <br>    IMemInputPin *pPin, <br>    IMemAllocator **ppAlloc <br>) <br>{ <br>    HRESULT hr = InitAllocator(ppAlloc); <br>    if (SUCCEEDED(hr)) { <br>        ALLOCATOR_PROPERTIES propRequest; <br>        ZeroMemory(&amp;propRequest, sizeof(propRequest)); <br>        hr = DecideBufferSize(*ppAlloc, &amp;propRequest); <br>        if (SUCCEEDED(hr)) { <br>            // tell downstream pins that modification <br>            // in-place is not permitted <br>            hr = pPin-&gt;NotifyAllocator(*ppAlloc, TRUE); <br>            if (SUCCEEDED(hr)) { <br>                return NOERROR; <br>            } <br>        } <br>    } <br> <br>    /* Likewise we may not have an interface to release */ <br> <br>    if (*ppAlloc) { <br>        (*ppAlloc)-&gt;Release(); <br>        *ppAlloc = NULL; <br>    } <br>    return hr; <br>} <br> <br>// override this to control the connection <br>// We use the subsample allocator derived from the input pin's allocator <br>HRESULT CSplitterOutputPin::InitAllocator(IMemAllocator **ppAlloc) <br>{ <br>    ASSERT(m_pAllocator == NULL); <br>    HRESULT hr = NOERROR; <br> <br>    *ppAlloc = new CSubAllocator(NULL, &amp;hr, Filter()-&gt;Allocator()); <br>    if (*ppAlloc == NULL) { <br>        return E_OUTOFMEMORY; <br>    } <br> <br>    if (FAILED(hr)) { <br>        delete *ppAlloc; <br>        *ppAlloc = NULL; <br>        return hr; <br>    } <br>    /* Get a reference counted IID_IMemAllocator interface */ <br>    (*ppAlloc)-&gt;AddRef(); <br>    return NOERROR; <br>} <br> <br>//  Check if we accept a media type - only accept 1 for now <br>HRESULT CSplitterOutputPin::CheckMediaType(const CMediaType *pmt) <br>{ <br>    POSITION pos = m_lTypes.GetHeadPosition(); <br>    while (pos) { <br>        CMediaType *pmtList = m_lTypes.GetNext(pos); <br>        if (*pmtList == *pmt) { <br>            return S_OK; <br>        } <br>    } <br>    return S_FALSE; <br>} <br> <br>// returns the preferred formats for a pin <br>HRESULT CSplitterOutputPin::GetMediaType( <br>    int iPosition, <br>    CMediaType *pMediaType <br>) <br>{ <br>    POSITION pos = m_lTypes.GetHeadPosition(); <br>    while (pos) { <br>        CMediaType *pmtList = m_lTypes.GetNext(pos); <br>        if (iPosition-- == 0) { <br>            *pMediaType = *pmtList; <br>            return S_OK; <br>        } <br>    } <br>    return VFW_S_NO_MORE_ITEMS; <br>} <br> <br>/*  Add a media type that's supported */ <br>HRESULT CSplitterOutputPin::AddMediaType( <br>    CMediaType const *pmt <br>) <br>{ <br>    CMediaType *pmtNew = new CMediaType(*pmt); <br>    if (pmtNew) { <br>        if (m_lTypes.AddTail(pmtNew)) { <br>            return S_OK; <br>        } <br>    } <br>    delete pmtNew; <br>    return E_OUTOFMEMORY; <br>} <br> <br>/*  Output pin - Deliver a sample */ <br>HRESULT CSplitterOutputPin::SendSample( <br>    const BYTE * pbData, <br>    LONG lData, <br>    REFERENCE_TIME rtStart, <br>    BOOL bSync <br>) <br>{ <br>    /*  Get a sample from the allocator */ <br>    if (!IsConnected()) { <br>        return S_FALSE; <br>    } <br>    CMediaSample *pSample = Allocator()-&gt;GetSample((PBYTE)pbData, lData); <br>    ASSERT(pSample != NULL); <br>    if (bSync) { <br>        REFERENCE_TIME rtStop = rtStart + 1; <br>        pSample-&gt;SetTime(&amp;rtStart, &amp;rtStop); <br> <br>        /*  Allow for some decoders that only take not of sync points */ <br>        pSample-&gt;SetSyncPoint(TRUE); <br>    } <br> <br>    /*  First send newsegment etc if discontinuity */ <br>    if (m_bDiscontinuity) { <br>        m_bDiscontinuity = FALSE; <br>        pSample-&gt;SetDiscontinuity(TRUE); <br> <br>        /*  HACK - fix this for seeking */ <br>        m_pOutputQueue-&gt;NewSegment(0, 0x7F00000000000000, 1.0); <br>    } <br> <br>    /*  Output queue will release the sample */ <br>    return m_pOutputQueue-&gt;Receive(pSample); <br>} <br> <br> <br>/*  Base splitter class methods */ <br> <br> <br>/* -- Constructor -- */ <br> <br>CBaseSplitterFilter::CBaseSplitterFilter( <br>    TCHAR *pName, <br>    LPUNKNOWN pUnk, <br>    REFCLSID rclsid, <br>    HRESULT *phr) : <br> <br>    CBaseFilter(pName, pUnk, &amp;m_csFilter, rclsid, phr), <br>    m_OutputPins(NAME("CBaseSplitterFilter::m_OutputPins")), <br>    m_Notify(this), <br>    m_pInput(NULL), <br>    m_pParser(NULL) <br>{ <br>} <br> <br>/* -- Destructor -- */ <br> <br>CBaseSplitterFilter::~CBaseSplitterFilter() <br>{ <br>    ASSERT(m_State == State_Stopped); <br> <br>    /* -- Destroy all pins */ <br>    DestroyInputPin(); <br>    DestroyOutputPins(); <br>} <br> <br>// <br>//  Override Pause() so we can prevent the input pin from starting <br>//  the puller before we're ready (ie have exited stopped state) <br>// <br>//  Starting the puller in Active() caused a hole where the first <br>//  samples could be rejected becase we seemed to be in 'stopped' <br>//  state <br>// <br>STDMETHODIMP <br>CBaseSplitterFilter::Pause() <br>{ <br>    CAutoLock lockFilter(&amp;m_csFilter); <br>    if (m_State == State_Stopped) { <br>        // and do the normal inactive processing <br>        POSITION pos = m_OutputPins.GetHeadPosition(); <br>        while (pos) { <br>            CSplitterOutputPin *pPin = m_OutputPins.GetNext(pos); <br>            if (pPin-&gt;IsConnected()) { <br>                pPin-&gt;Active(); <br>            } <br>        } <br> <br>        CAutoLock lockStreaming(&amp;m_csStream); <br> <br>        //  Activate our input pin only if we're connected <br>        if (m_pInput-&gt;IsConnected()) { <br>            m_pInput-&gt;Active(); <br>        } <br>        m_State = State_Paused; <br> <br>        //  Initialize our state <br>        ResetAllocatorAndParser(); <br>    } else { <br>        m_State = State_Paused; <br>    } <br>    return S_OK; <br>} <br> <br>/*  Stop the filter <br> <br>    We override this for efficiency and so that we can manage the <br>    locking correctly <br>*/ <br>STDMETHODIMP CBaseSplitterFilter::Stop() <br>{ <br>    // must get this one first - it serializes state changes <br>    CAutoLock lockFilter(&amp;m_csFilter); <br>    if (m_State == State_Stopped) { <br>        return NOERROR; <br>    } <br> <br>    // decommit the input pin or we can deadlock <br>    if (m_pInput != NULL) { <br>        m_pInput-&gt;Inactive(); <br>    } <br> <br>    // now hold the Receive critsec to prevent further Receive and EOS calls, <br>    CAutoLock lockStreaming(&amp;m_csStream); <br> <br>    // and do the normal inactive processing <br>    POSITION pos = m_OutputPins.GetHeadPosition(); <br>    while (pos) { <br>        CSplitterOutputPin *pPin = m_OutputPins.GetNext(pos); <br>        if (pPin-&gt;IsConnected()) { <br>            pPin-&gt;Inactive(); <br>        } <br>    } <br>    ResetAllocatorAndParser(); <br>    m_State = State_Stopped; <br>    return S_OK; <br>} <br> <br>/*  -- Return number of pins */ <br>int CBaseSplitterFilter::GetPinCount() <br>{ <br>    CAutoLock lck(&amp;m_csPins); <br>    return (m_pInput != NULL ? 1 : 0) + <br>           m_OutputPins.GetCount(); <br>} <br> <br>/*  -- Return a given pin -- */ <br>CBasePin *CBaseSplitterFilter::GetPin(int iPin) <br>{ <br>    CAutoLock lck(&amp;m_csPins); <br>    if (iPin == 0 &amp;&amp; m_pInput != NULL) { <br>        return m_pInput; <br>    } <br>    if (m_pInput != NULL) { <br>        iPin--; <br>    } <br>    if (iPin &lt; 0 || iPin &gt;= m_OutputPins.GetCount()) { <br>        return NULL; <br>    } <br>    POSITION pos = m_OutputPins.GetHeadPosition(); <br>    while (iPin-- &gt; 0) { <br>        m_OutputPins.GetNext(pos); <br>    } <br>    return m_OutputPins.GetNext(pos); <br>} <br> <br>/*  -- Add an output pin -- */ <br>BOOL CBaseSplitterFilter::AddOutputPin(CSplitterOutputPin *pOutputPin) <br>{ <br>    CAutoLock lckFilter(&amp;m_csFilter); <br>    CAutoLock lckPins(&amp;m_csPins); <br>    ASSERT(m_State == State_Stopped); <br>    IncrementPinVersion(); <br>    pOutputPin-&gt;AddRef(); <br>    if (m_OutputPins.AddTail(pOutputPin) == NULL) { <br>        delete pOutputPin; <br>        return FALSE; <br>    } <br>    return TRUE; <br>} <br> <br>/*  -- Destroy the input pin -- */ <br>void CBaseSplitterFilter::DestroyInputPin() <br>{ <br>    delete m_pInput; <br>    m_pInput = NULL; <br>} <br> <br>/*  -- Delete the output pins -- */ <br>void CBaseSplitterFilter::DestroyOutputPins() <br>{ <br>    CAutoLock lckFilter(&amp;m_csFilter); <br>    CAutoLock lckPins(&amp;m_csPins); <br>    ASSERT(m_State == State_Stopped); <br>    for (;;) { <br>        CSplitterOutputPin *pPin = m_OutputPins.RemoveHead(); <br>        if (pPin == NULL) { <br>            break; <br>        } <br>        IncrementPinVersion(); <br> <br>        //  Disconnect if necessary <br>        IPin *pPeer = pPin-&gt;GetConnected(); <br>        if (pPeer != NULL) { <br>            pPeer-&gt;Disconnect(); <br>            pPin-&gt;Disconnect(); <br>        } <br>        pPin-&gt;Release(); <br>    } <br>} <br> <br>/*  Notify to create a new stream <br>    Called back through CParseNotify <br>*/ <br>HRESULT CBaseSplitterFilter::CreateStream( <br>    LPCWSTR         pszName, <br>    CStreamNotify **ppStreamNotify <br>) <br>{ <br>    HRESULT hr = S_OK; <br>    CSplitterOutputPin *pPin = <br>        new CSplitterOutputPin(this, &amp;hr, pszName); <br>    if (FAILED(hr)) { <br>        delete pPin; <br>        return hr; <br>    } <br>    if (pPin == NULL) { <br>        return E_OUTOFMEMORY; <br>    } <br> <br>    if (!AddOutputPin(pPin)) { <br>        delete pPin; <br>        return E_OUTOFMEMORY; <br>    } <br>    *ppStreamNotify = pPin-&gt;GetNotify(); <br>    return S_OK; <br>} <br> <br>HRESULT CBaseSplitterFilter::CompleteConnect(IPin *pReceivePin) <br>{ <br>    m_pParser = CreateParser(&amp;m_Notify, InputPin()-&gt;MediaType()); <br>    if (m_pParser == NULL) { <br>        return E_OUTOFMEMORY; <br>    } <br>    /*  Create a reader to initialize the parser */ <br>    CParseReaderFromAsync rdr(InputPin()-&gt;Reader()); <br> <br>    HRESULT hr = m_pParser-&gt;Init(&amp;rdr); <br>    if (SUCCEEDED(hr)) { <br>        ALLOCATOR_PROPERTIES Props, Actual; <br> <br>        /*  Our allocator doesn't accumulate alignment correctly <br>            so use the alignment currently set <br>        */ <br>        Allocator()-&gt;GetProperties(&amp;Props); <br>        m_pParser-&gt;GetSizeAndCount(&amp;Props.cbBuffer, &amp;Props.cBuffers); <br>        ((IMemAllocator *)Allocator())-&gt;SetProperties(&amp;Props, &amp;Actual); <br>    } <br>    return hr; <br>} <br> <br>/*  Process some data */ <br>HRESULT CBaseSplitterFilter::Receive(IMediaSample *pSample) <br>{ <br>    /*  Notify our allocator about how much data we've got, <br>        Call the parser to eat the data, <br>        eat the data that was parsed <br>    */ <br> <br>    Allocator()-&gt;AddBuffer((CMediaSample *)pSample); <br> <br>    /*  Now eat the data */ <br>    LONG lValid; <br>    PBYTE pbValid = Allocator()-&gt;GetValid(&amp;lValid); <br>    LONG lProcessed; <br>    HRESULT hr = m_pParser-&gt;Process(pbValid, lValid, &amp;lProcessed); <br>    if (S_OK != hr) { <br>        /*  If something goes wrong do error processing */ <br>        return hr; <br>    } <br> <br>    Allocator()-&gt;Advance(lProcessed); <br> <br>    /*  Flush the output queues */ <br>    POSITION pos = m_OutputPins.GetHeadPosition(); <br>    while (pos) { <br>        CSplitterOutputPin *pPin = m_OutputPins.GetNext(pos); <br>        pPin-&gt;SendAnyway(); <br>    } <br>    return S_OK; <br>} <br> <br>/*  Send EndOfStream */ <br>void CBaseSplitterFilter::EndOfStream() <br>{ <br>    ResetAllocatorAndParser(); <br>    POSITION pos = m_OutputPins.GetHeadPosition(); <br>    while (pos) { <br>        CSplitterOutputPin *pPin = m_OutputPins.GetNext(pos); <br>        if (pPin-&gt;IsConnected()) { <br>            pPin-&gt;DeliverEndOfStream(); <br>        } <br>    } <br>} <br> <br>/*  Send BeginFlush() */ <br>HRESULT CBaseSplitterFilter::BeginFlush() <br>{ <br>    POSITION pos = m_OutputPins.GetHeadPosition(); <br> <br>    while (pos) { <br>        CSplitterOutputPin *pPin = m_OutputPins.GetNext(pos); <br>        if (pPin-&gt;IsConnected()) { <br>            pPin-&gt;DeliverBeginFlush(); <br>        } <br>    } <br>    return S_OK; <br>} <br> <br>/*  Send EndFlush() */ <br>HRESULT CBaseSplitterFilter::EndFlush() <br>{ <br>    ResetAllocatorAndParser(); <br>    POSITION pos = m_OutputPins.GetHeadPosition(); <br>    while (pos) { <br>        CSplitterOutputPin *pPin = m_OutputPins.GetNext(pos); <br>        if (pPin-&gt;IsConnected()) { <br>            pPin-&gt;DeliverEndFlush(); <br>        } <br>    } <br>    return S_OK; <br>} <br> <br>/*  Break connection on the input pin */ <br>void CBaseSplitterFilter::BreakConnect() <br>{ <br>    delete m_pParser; <br>    m_pParser = NULL; <br>    DestroyOutputPins(); <br>} <br> <br>/*  -- Input pin methods -- */ <br> <br>/*  Constructor */ <br>CSplitterInputPin::CSplitterInputPin( <br>    CBaseSplitterFilter *pFilter, <br>    HRESULT *phr <br>) : CBaseInputPin(NAME("CSplitterInputPin"), <br>             pFilter, <br>             &amp;pFilter-&gt;m_csFilter, <br>             phr, <br>             L"Input"), <br>    m_puller(this) <br>{ <br>} <br> <br>/*  Connection stuff */ <br>HRESULT CSplitterInputPin::CheckConnect(IPin *pPin) <br>{ <br>    HRESULT hr = CBaseInputPin::CheckConnect(pPin); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br> <br>    /*  Create our allocator */ <br>    ASSERT(m_pAllocator == NULL); <br> <br>    m_pAllocator = new CSequentialAllocator( <br>                           NULL, // No owner - allocators are separate objects <br>                           &amp;hr); <br>    if (m_pAllocator == NULL) { <br>        return E_OUTOFMEMORY; <br>    } <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br> <br>    /*  The base classes expect the allocator to be AddRef'd */ <br>    m_pAllocator-&gt;AddRef(); <br> <br>    // BUGBUG CPullPin might change the allocator and not tell us! <br>    hr = m_puller.Connect(pPin, m_pAllocator, TRUE); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br>    return hr; <br>} <br> <br>/*  Break connection - filter already locked by caller */ <br>HRESULT CSplitterInputPin::BreakConnect() <br>{ <br>    Filter()-&gt;BreakConnect(); <br>    m_puller.Disconnect(); <br>    if (m_pAllocator) { <br>        m_pAllocator-&gt;Release(); <br>        m_pAllocator = NULL; <br>    } <br>    return CBaseInputPin::BreakConnect(); <br>} <br> <br>/*  End of stream */ <br>STDMETHODIMP CSplitterInputPin::EndOfStream() <br>{ <br>    CAutoLock lck(&amp;Filter()-&gt;m_csStream); <br>    HRESULT hr = CheckStreaming(); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br> <br>    /*  Forward to the output pins */ <br>    Filter()-&gt;EndOfStream(); <br>    return S_OK; <br>} <br> <br>/*  Forward BeginFlush() and EndFlush() to filter */ <br>STDMETHODIMP CSplitterInputPin::BeginFlush() <br>{ <br>    CAutoLock lck(m_pLock); <br>    CBaseInputPin::BeginFlush(); <br>    Filter()-&gt;BeginFlush(); <br>    return S_OK; <br>} <br>STDMETHODIMP CSplitterInputPin::EndFlush() <br>{ <br>    CAutoLock lck(&amp;Filter()-&gt;m_csStream); <br>    CBaseInputPin::EndFlush(); <br>    Filter()-&gt;EndFlush(); <br>    return S_OK; <br>} <br> <br>/*  Receive - forward to filter */ <br>STDMETHODIMP CSplitterInputPin::Receive(IMediaSample *pSample) <br>{ <br>    CAutoLock lck(&amp;Filter()-&gt;m_csStream); <br>    HRESULT hr = CheckStreaming(); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br>    hr = Filter()-&gt;Receive(pSample); <br>    if (S_OK != hr) { <br>        NotifyError(hr); <br>    } <br>    return hr; <br>} <br> <br>HRESULT CSplitterInputPin::Active() <br>{ <br>    /*  If we're not seekable then just seek to start for now */ <br>    REFERENCE_TIME rtDuration; <br>    m_puller.Duration(&amp;rtDuration); <br>    m_puller.Seek(0, rtDuration); <br>    HRESULT hr = m_puller.Active(); <br>    if (FAILED(hr)) { <br>        return hr; <br>    } <br>    return CBaseInputPin::Active(); <br>} <br> <br>HRESULT CSplitterInputPin::Inactive() <br>{ <br>    m_puller.Inactive(); <br>    return CBaseInputPin::Inactive(); <br>} <br> <br> <br>/*  forward connection stuff to filter */ <br>HRESULT CSplitterInputPin::CheckMediaType(const CMediaType *pmt) <br>{ <br>    return Filter()-&gt;CheckInputType(pmt); <br>} <br>HRESULT CSplitterInputPin::CompleteConnect(IPin *pReceivePin) <br>{ <br>    return Filter()-&gt;CompleteConnect(pReceivePin); <br>} <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
