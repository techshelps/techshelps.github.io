<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>NULLPROP.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2875"></a>NULLPROP.CPP</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br> <br>#include &lt;streams.h&gt; <br> <br>// Eliminate two expected level 4 warnings from the Microsoft compiler. <br>// The class does not have an assignment or copy operator, and so cannot <br>// be passed by value.  This is normal.  This file compiles clean at the <br>// highest (most picky) warning level (-W4). <br>#pragma warning(disable: 4511 4512) <br> <br>#include &lt;windowsx.h&gt; <br>#include &lt;commctrl.h&gt; <br>#include &lt;olectl.h&gt; <br>#include &lt;memory.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;tchar.h&gt; <br> <br>#include "resource.h"    // ids used in the dialog <br>#include "nulluids.h"    // public guids <br>#include "inull.h"       // private interface between property sheet and filter <br>#include "nullprop.h"    // our own class <br>#include "texttype.h"    // class to express media types as text <br> <br> <br>// <br>// CreateInstance <br>// <br>// Override CClassFactory method. <br>// Set lpUnk to point to an IUnknown interface on a new NullIPProperties object <br>// Part of the COM object instantiation mechanism <br>// <br>CUnknown * WINAPI NullIPProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr) <br>{ <br> <br>    CUnknown *punk = new NullIPProperties(lpunk, phr); <br>    if (punk == NULL) { <br>        *phr = E_OUTOFMEMORY; <br>    } <br>    return punk; <br>} <br> <br> <br>// <br>// NullIPProperties::Constructor <br>// <br>// Constructs and initialises a NullIPProperties object <br>// <br>NullIPProperties::NullIPProperties(LPUNKNOWN pUnk, HRESULT *phr) <br>    : CBasePropertyPage(NAME("NullIP Property Page"),pUnk, <br>        IDD_DIALOG1, IDS_TITLE) <br>    , m_pPin(NULL) <br>    , m_nIndex(0) <br>    , m_pINullIPP(NULL) <br>{ <br>    ASSERT(phr); <br> <br>} // (constructor) NullIPProperties <br> <br> <br>// <br>// SetDirty <br>// <br>// Sets m_hrDirtyFlag and notifies the property page site of the change <br>// <br>void NullIPProperties::SetDirty() <br>{ <br>    m_bDirty = TRUE; <br>    if (m_pPageSite) <br>    { <br>        m_pPageSite-&gt;OnStatusChange(PROPPAGESTATUS_DIRTY); <br>    } <br> <br>} // SetDirty <br> <br> <br>// <br>// OnReceiveMessage <br>// <br>// Override CBasePropertyPage method. <br>// Handles the messages for our property window <br>// <br>BOOL NullIPProperties::OnReceiveMessage(HWND hwnd, <br>                                        UINT uMsg, <br>                                        WPARAM wParam, <br>                                        LPARAM lParam) <br>{ <br>    switch (uMsg) <br>    { <br>        case WM_INITDIALOG: <br>        { <br>            // get the hWnd of the list box <br>            m_hwndLB = GetDlgItem (hwnd, IDC_MEDIALIST) ; <br>            FillListBox(); <br>            return (LRESULT) 1; <br>        } <br> <br>        case WM_COMMAND: <br>        { <br>                if (HIWORD(wParam) == LBN_SELCHANGE) <br>            { <br>                SetDirty(); <br>            } <br>            return (LRESULT) 1; <br>        } <br> <br>    } <br>    return CBasePropertyPage::OnReceiveMessage(hwnd,uMsg,wParam,lParam); <br> <br>} // OnReceiveMessage <br> <br> <br>// <br>// OnConnect <br>// <br>// Override CBasePropertyPage method. <br>// Notification of which object this property page should display. <br>// We query the object for the INullIPP interface. <br>// <br>// If cObjects == 0 then we must release the interface. <br>// Set the member variable m_pPin to the upstream output pin connected <br>// to our input pin (or NULL if not connected). <br>// <br>HRESULT NullIPProperties::OnConnect(IUnknown *pUnknown) <br>{ <br>    ASSERT(m_pINullIPP == NULL); <br> <br>    HRESULT hr = pUnknown-&gt;QueryInterface(IID_INullIPP, (void **) &amp;m_pINullIPP); <br>    if (FAILED(hr)) <br>    { <br>        return E_NOINTERFACE; <br>    } <br> <br>    ASSERT(m_pINullIPP); <br> <br>    ASSERT(!m_pPin); <br>    m_pINullIPP-&gt;get_IPin(&amp;m_pPin); <br> <br>    return NOERROR; <br> <br>} // OnConnect <br> <br> <br>// <br>// OnDisconnect <br>// <br>// Override CBasePropertyPage method. <br>// Release the private interface, release the upstream pin. <br>// <br>HRESULT NullIPProperties::OnDisconnect() <br>{ <br>    // Release of Interface <br> <br>    if (m_pINullIPP == NULL) <br>        return E_UNEXPECTED; <br>    m_pINullIPP-&gt;Release(); <br>    m_pINullIPP = NULL; <br> <br>    // <br>    // Release the pin interface that we are holding. <br>    // <br>    if (m_pPin) <br>    { <br>        m_pPin-&gt;Release() ; <br>        m_pPin = NULL ; <br>    } <br>    return NOERROR; <br> <br>} // OnDisconnect <br> <br> <br>// <br>// Activate <br>// <br>// We are being activated <br>// <br>HRESULT NullIPProperties::OnActivate() <br>{ <br>    SendMessage (m_hwndLB, LB_SETCURSEL, m_nIndex, 0) ; <br>    return NOERROR; <br> <br>} // Activate <br> <br> <br>// <br>// OnApplyChanges <br>// <br>// Changes made should be kept. <br>// <br>HRESULT NullIPProperties::OnApplyChanges() <br>{ <br> <br>    ASSERT(m_pINullIPP); <br> <br>    // <br>    // get the current selection of the media type <br>    // <br>    int iIndex = SendMessage (m_hwndLB, LB_GETCURSEL, 0, 0) ; <br>    if (iIndex &lt;= 0) <br>        iIndex = 0 ; <br> <br>    m_bDirty = FALSE;            // the page is now clean <br>    if (iIndex == 0) <br>    { <br>        m_pINullIPP-&gt;put_MediaType (NULL) ; <br>        m_nIndex = 0; <br>        return NOERROR; <br>    } <br> <br>    IEnumMediaTypes * pMTEnum; <br>    AM_MEDIA_TYPE *pMediaType; <br>    ULONG count; <br> <br>    // <br>    // get the type enumerator from the pin again <br>    // <br>    HRESULT hr = m_pPin-&gt;EnumMediaTypes(&amp;pMTEnum); <br>    if (FAILED(hr)) <br>    { <br>        return hr; <br>    } <br> <br>    // <br>    // skip to the appropriate type and read it <br>    // <br>    pMTEnum-&gt;Skip(iIndex - 1); <br>    pMTEnum-&gt;Next(1, &amp;pMediaType, &amp;count); <br>    if (count != 1) { <br>        pMTEnum-&gt;Release(); <br>        return E_UNEXPECTED; <br>    } <br> <br>    // <br>    // change the type by calling the filter <br>    // <br>    CMediaType cmt(*pMediaType); <br>    DeleteMediaType(pMediaType); <br>    hr = m_pINullIPP-&gt;put_MediaType(&amp;cmt) ; <br>    if (FAILED(hr)) <br>    { <br>        pMTEnum-&gt;Release(); <br>        return NOERROR; <br>    } <br> <br>    // <br>    // update the current selection and release the enumerator <br>    // <br>    m_nIndex = iIndex; <br>    pMTEnum-&gt;Release(); <br>    return NOERROR; <br> <br>} // OnApplyChanges <br> <br> <br>// <br>// FillListBox <br>// <br>// Fill the list box with an enumeration of the media type that our <br>// <br>void NullIPProperties::FillListBox() <br>{ <br>    IEnumMediaTypes * pMTEnum; <br>    AM_MEDIA_TYPE *pMediaType; <br>    ULONG count; <br>    TCHAR szBuffer[200]; <br>    int Loop = 0, wextent = 0 ; <br>    SIZE extent ; <br>    FILTER_STATE state ; <br>    CMediaType *pmtCurrent ; <br> <br>    // <br>    // get the current media type <br>    // <br>    ASSERT(m_pINullIPP); <br>    m_pINullIPP-&gt;get_MediaType (&amp;pmtCurrent); <br>    m_nIndex = 0 ; <br> <br>    // <br>    // Fill the first entry of the list box with a choice to select any media. <br>    // <br>    LoadString(g_hInst, IDS_ANYTYPE, szBuffer, 200); <br>    SendMessage (m_hwndLB, LB_ADDSTRING, 0, (LPARAM)szBuffer) ; <br> <br>    // <br>    // if the filter is not connected on the input, nothing more to fill <br>    // also return if we haven't gotten any pin interface <br>    // <br>    if (m_pPin == NULL) <br>        return ; <br> <br>    // <br>    // get a dc for the control. need this to get the extent of the strings <br>    // that we put in the list box (so that we can get a horiz scroll bar). <br>    // <br>    HDC hdc = GetDC (m_hwndLB) ; <br> <br>    // <br>    // now enumerate the media types from our pin. <br>    // <br>    HRESULT hr = m_pPin-&gt;EnumMediaTypes(&amp;pMTEnum); <br> <br>    if (SUCCEEDED(hr)) <br>    { <br>        ASSERT(pMTEnum); <br>        pMTEnum-&gt;Next(1, &amp;pMediaType, &amp;count); <br>        while (count == 1)                    // While a media type retrieved OK <br>        { <br>            // <br>            // Count it - used to set m_nIndex. <br>            // <br>            Loop++; <br> <br>            // <br>            // convert the media type to string. <br>            // <br>            CTextMediaType(*pMediaType).AsText(szBuffer, 200, TEXT(" - "), TEXT(" - "), TEXT("\0")); <br> <br>            // <br>            // if the mediatype matches the current one, set m_nIndex to cur index <br>            // <br>            if (*pmtCurrent == *pMediaType) { <br>                m_nIndex = Loop; <br>            } <br> <br>            // <br>            // get the extent of the string and save the max extent <br>            // <br>            GetTextExtentPoint (hdc, szBuffer, _tcslen(szBuffer), &amp;extent) ; <br>            if (extent.cx &gt; wextent) <br>                wextent = extent.cx ; <br> <br>            // <br>            // add the string to the list box. <br>            // <br>            SendMessage (m_hwndLB, LB_ADDSTRING, 0, (LPARAM)szBuffer) ; <br> <br>            // <br>            // enumerate the next media type and loop. <br>            // <br>            DeleteMediaType(pMediaType); <br>            pMTEnum-&gt;Next(1, &amp;pMediaType, &amp;count); <br>        } <br>        pMTEnum-&gt;Release(); <br>        SendMessage (m_hwndLB, LB_SETHORIZONTALEXTENT, wextent, 0) ; <br>        SendMessage (m_hwndLB, LB_SETCURSEL, m_nIndex, 0) ; <br>    } <br>    ASSERT(m_pINullIPP); <br> <br>    // <br>    // if the filter is in a running state, disable the list box and allow <br>    // no input. <br>    // <br>    m_pINullIPP-&gt;get_State(&amp;state); <br>    EnableWindow (m_hwndLB, state != State_Running) ; <br> <br>} // FillListBox </code></pre>
<p>&nbsp;</p></body>
</HTML>
