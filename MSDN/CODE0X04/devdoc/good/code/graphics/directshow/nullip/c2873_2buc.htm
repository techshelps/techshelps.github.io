<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>NULLIP.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2874"></a>NULLIP.CPP</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br> <br> <br>// In-Place Null Transform <br>// <br>//     What This Sample Illustrates <br>// <br>// An in-place transform filter. <br>// Media types and the connection process <br>// Performance logging using Measure.dll <br>// Use of CAutoLock class to automatically release critical sections <br>// <br>// <br>//     Summary <br>// <br>// A simple in-place transform with one input pin and one output pin. <br>// The filter operates in-place which means that it has no media type <br>// enumerators of its own.  It obtains enumerators from the filters either <br>// on either side and passes types so obtained across for approval by the <br>// one on the other side.  On the way through it sees if it likes the <br>// type and rejects any that it doesn't.  The property sheet displays the <br>// list of types obtained from the upstream filter and allows one or <br>// all to be selected.  Any type not selected will be rejected by the <br>// connection process.  Almost all the work is done by the base classes. <br>// <br>// <br>//     Demonstration instructions <br>// <br>// First build the sample and get it registered (see nullip.reg) <br>// Start GRAPHEDT (available in the ActiveMovie SDK tools). <br>// Select Graph then InsertFilters and insert FileSource (async) <br>// Select Angry.AVI as the source file. <br>// Insert Null-In-Place.  (If it is not on the list then you <br>// failed to register it properly.  If it fails to load then you either <br>// didn't build it properly or the registration does not correctly point to <br>// the path where nullip.ax is now found.) <br>// Right click on the output pin of the source filter. Select Render. <br>// In the resulting graph you will see the Null-In-Place filter inserted between <br>// the AVI decompressor and the video renderer. <br>// Right click on the null-in-place filter to bring up its properties page. <br>// Select Major Type: MEDIATYPE_Video - Sub Type:MEDIASUBTYPE_RGB24 &lt;etc&gt; <br>// Click on Apply.  It wil tell you that it can't do it. <br>// Delete the output connection (Null-In-Place to Video Renderer) <br>// Try to Apply the media type again.  It succeeds. <br>// Connect the Mull-In-Place transform to the Video Renderer again. <br>// It will (probably) insert a Colour Space Transform to make the connection. <br>// <br>// <br>//     Implementation <br>// <br>// This filter has one input pin, one output pin and <br>// does its "transform" in-place (i.e. without copying the data) <br>// on the push thread (i.e. it is called with a buffer, which it <br>// "transforms" and gives to the next filter downstream.  It is <br>// then blocked until that filter returns.  It then returns <br>// to its own caller.) <br>// <br>// In this case the transform does nothing.  It just passes the data on. <br>// <br>// It has a properties page which allows control of what media types <br>// are allowed on connection. <br> <br>// Note about Receive: <br>// <br>// NOTE: Please note that we shoud NOT override the Receive method to Deliver <br>// the input sample directly. We may have a case where we could not negotiate <br>// the same allocator for the input and output pins. (For example, if the <br>// upstream filter insists on its own allocator and provides a read-only <br>// allocator, that will be the case). In this case samples need to be <br>// copied from input to output allocator and then transformed. The base <br>// class Receive method does this. Transform () will get called on the copied <br>// over buffer and in our case, that function is a NOP and does nothing. <br>// <br>// <br>//      Files <br>// <br>// nullip.cpp    This file - main implementation <br>// nullprop.cpp  Implementation of the properties sheet <br>// nullprop.h    Class definition of properties class (used in nullip.cpp) <br>// nullprop.rc   Defines the property page dialog <br>// inull.h       Interface between nullip and nullprop <br>// nulluids.h    The public class ids (only referred to in nullip) <br>// resource.h    constants shared between nullip.rc and nullip.cpp <br>// texttype.cpp  implementation of class used to display media types as text <br>// texttype.h    definition of class used to display media types as text <br>// nullip.def    Imports and exports <br>// nullip.reg    What goes in the registry <br>// makefile      How to build it <br>// <br>// <br>//     Base classes used (refer to docs for diagram of what they inherit): <br>// <br>// CTransInPlaceFilter <br>// CBasePropertyPage <br>// CMediaType <br>// CTransInPlaceInputPin <br>// CTransInPlaceOutputPin <br> <br> <br>#include &lt;streams.h&gt;          // quartz, includes windows <br> <br>// Eliminate two expected level 4 warnings from the Microsoft compiler. <br>// The class does not have an assignment or copy operator, and so cannot <br>// be passed by value.  This is normal.  This file compiles clean at the <br>// highest (most picky) warning level (-W4). <br>#pragma warning(disable: 4511 4512) <br> <br>#include &lt;measure.h&gt;          // performance measurement (MSR_) <br> <br>#include &lt;initguid.h&gt; <br>#if (1100 &gt; _MSC_VER) <br>#include &lt;olectlid.h&gt; <br>#else <br>#include &lt;olectl.h&gt; <br>#endif <br> <br>#include "nullUids.h"         // our own public guids <br> <br>#include "inull.h"            // interface between filter and property sheet <br>#include "nullprop.h"         // property sheet implementatino class <br> <br> <br> <br>// ---------------------------------------------------------------------------- <br>// Class definitions of input pin, output pin and filter <br>// ---------------------------------------------------------------------------- <br> <br> <br>class CNullInPlaceInputPin : public CTransInPlaceInputPin <br>{ <br>    public: <br>        CNullInPlaceInputPin( TCHAR *pObjectName <br>                            , CTransInPlaceFilter *pTransInPlaceFilter <br>                            , HRESULT * phr <br>                            , LPCWSTR pName <br>                            ) <br>                              : CTransInPlaceInputPin( pObjectName <br>                                                     , pTransInPlaceFilter <br>                                                     , phr <br>                                                     , pName <br>                                                     ) <br>        { <br>        } <br> <br>        HRESULT CheckMediaType(const CMediaType* pmt); <br>}; <br> <br> <br>class CNullInPlaceOutputPin : public CTransInPlaceOutputPin <br>{ <br>    public: <br>        CNullInPlaceOutputPin( TCHAR *pObjectName <br>                             , CTransInPlaceFilter *pTransInPlaceFilter <br>                             , HRESULT * phr <br>                             , LPCWSTR pName <br>                             ) <br>                               : CTransInPlaceOutputPin( pObjectName <br>                                                       , pTransInPlaceFilter <br>                                                       , phr <br>                                                       , pName <br>                                                       ) <br>        { <br>        } <br> <br>        HRESULT CheckMediaType(const CMediaType* pmt); <br>}; <br> <br> <br> <br>// CNullInPlace <br>// <br>class CNullInPlace : public CTransInPlaceFilter <br>                   , public INullIPP <br>                   , public ISpecifyPropertyPages <br>{ <br> <br>        friend class CNullInPlaceInputPin; <br>        friend class CNullInPlaceOutputPin; <br> <br>    public: <br> <br>        static CUnknown * WINAPI CreateInstance(LPUNKNOWN punk, HRESULT *phr); <br> <br>        DECLARE_IUNKNOWN; <br> <br>        // <br>        // --- CTransInPlaceFilter Overrides -- <br>        // <br> <br>        virtual CBasePin *GetPin( int n ); <br> <br>        HRESULT CheckInputType(const CMediaType* mtIn) <br>            { UNREFERENCED_PARAMETER(mtIn);  return S_OK; } <br> <br>        // Basic COM - used here to reveal our property interface. <br>        STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv); <br> <br>        STDMETHODIMP get_IPin (IPin **ppPin) ; <br>        STDMETHODIMP put_MediaType(CMediaType *pmt); <br>        STDMETHODIMP get_MediaType(CMediaType **pmt); <br>        STDMETHODIMP get_State(FILTER_STATE *state); <br> <br> <br>        // <br>        // --- ISpecifyPropertyPages --- <br>        // <br> <br>        STDMETHODIMP GetPages(CAUUID *pPages); <br> <br>    private: <br> <br>        CNullInPlace(TCHAR *tszName, LPUNKNOWN punk, HRESULT *phr); <br> <br>        // <br>        // Overrides the PURE virtual Transform of CTransInPlaceFilter base class <br>        // This is where the "real work" is done. <br>        // <br>        HRESULT Transform(IMediaSample *pSample) <br>            { UNREFERENCED_PARAMETER(pSample); return NOERROR; } <br> <br> <br>        // <br>        // If there are multiple instances of this filter active, it's <br>        // useful for debug messages etc. to know which one this is. <br>        // <br>        static m_nInstanceCount;   // total instances <br>        int m_nThisInstance; <br> <br>        CMediaType m_mtPreferred;  // Media type chosen from property sheet <br> <br>        CCritSec m_NullIPLock;     // To serialise access. <br>}; <br> <br> <br>// ---------------------------------------------------------------------------- <br>// Implementation of pins and filter <br>// ---------------------------------------------------------------------------- <br> <br> <br>// <br>// DbgFunc <br>// <br>// Put out the name of the function and instance on the debugger. <br>// Call this at the start of interesting functions to help debug <br>// <br>#define DbgFunc(a) DbgLog(( LOG_TRACE                        \ <br>                          , 2                                \ <br>                          , TEXT("CNullInPlace(Instance %d)::%s") \ <br>                          , m_nThisInstance                  \ <br>                          , TEXT(a)                          \ <br>                         )); <br> <br>// <br>// setup data <br>// <br> <br>const AMOVIESETUP_MEDIATYPE <br>sudPinTypes =   { &amp;MEDIATYPE_NULL                // clsMajorType <br>                , &amp;MEDIASUBTYPE_NULL }  ;       // clsMinorType <br> <br>const AMOVIESETUP_PIN <br>psudPins[] = { { L"Input"            // strName <br>               , FALSE               // bRendered <br>               , FALSE               // bOutput <br>               , FALSE               // bZero <br>               , FALSE               // bMany <br>               , &amp;CLSID_NULL         // clsConnectsToFilter <br>               , L"Output"           // strConnectsToPin <br>               , 1                   // nTypes <br>               , &amp;sudPinTypes }      // lpTypes <br>             , { L"Output"           // strName <br>               , FALSE               // bRendered <br>               , TRUE                // bOutput <br>               , FALSE               // bZero <br>               , FALSE               // bMany <br>               , &amp;CLSID_NULL         // clsConnectsToFilter <br>               , L"Input"            // strConnectsToPin <br>               , 1                   // nTypes <br>               , &amp;sudPinTypes } };   // lpTypes <br> <br> <br>const AMOVIESETUP_FILTER <br>sudNullIP = { &amp;CLSID_NullInPlace                 // clsID <br>            , L"Null In Place"                // strName <br>            , MERIT_DO_NOT_USE                // dwMerit <br>            , 2                               // nPins <br>            , psudPins };                     // lpPin <br> <br>// <br>// Needed for the CreateInstance mechanism <br>// <br>CFactoryTemplate g_Templates[]= <br>    {   {L"Null-In-Place" <br>        , &amp;CLSID_NullInPlace <br>        ,   CNullInPlace::CreateInstance <br>        , NULL <br>        , &amp;sudNullIP } <br>    , <br>        { L"Null IP Property Page" <br>        , &amp;CLSID_NullIPPropertyPage <br>        , NullIPProperties::CreateInstance } <br> <br>    }; <br>int g_cTemplates = sizeof(g_Templates)/sizeof(g_Templates[0]); <br> <br> <br>// <br>// initialise the static instance count. <br>// <br>int CNullInPlace::m_nInstanceCount = 0; <br> <br> <br>// ---------------------------------------------------------------------------- <br>//            Input pin implementation <br>// ---------------------------------------------------------------------------- <br> <br> <br>// CheckMediaType <br>// <br>// Override CTransInPlaceInputPin method. <br>// If we have been given a preferred media type from the property sheet <br>// then only accept a type that is exactly that. <br>// else if there is nothing downstream, then accept anything <br>// else if there is a downstream connection then first check to see if <br>// the subtype (and implicitly the major type) are different from the downstream <br>// connection and if they are different, fail them <br>// else ask the downstream input pin if the type (i.e. all details of it) <br>// are acceptable and take that as our answer. <br>// <br>HRESULT CNullInPlaceInputPin::CheckMediaType( const CMediaType *pmt ) <br>{   CNullInPlace *pNull = (CNullInPlace *) m_pTIPFilter; <br> <br>#ifdef DEBUG <br>    DisplayType(TEXT("Input type proposed"),pmt); <br>#endif <br> <br>    if (pNull-&gt;m_mtPreferred.IsValid() == FALSE) <br>    { <br>        if( pNull-&gt;m_pOutput-&gt;IsConnected() ) { <br> <br>            //  We used to check here if the subtype of the proposed type <br>            //  matched the subtype of the type on the output pin <br>            //  but this broke as follows: <br>            // <br>            //  Renderering the output pin of a CODEC we picked up <br>            //  2 NULLIPs already in the graph: <br>            // <br>            //  Subtypes      Y41P       Y41P       RGB565 <br>            //  Filters  CODEC----&gt;NULLIP----&gt;NULLIP------&gt;RENDERER <br>            // <br>            //  Each NULLIP has scheduled a reconnect at this point <br>            //  and the reconnect on the first connection happens <br>            //  first: <br>            // <br>            //  Subtypes                 Y41P       RGB565 <br>            //  Filters  CODEC     NULLIP----&gt;NULLIP------&gt;RENDERER <br>            // <br>            //  In trying to (re)connect the CODEC to the first NULLIP <br>            //  we first propose (say) Y41P and the first NULLIP <br>            //  checks that Y41P is the same as its output type <br>            //  so the call gets passed to the QueryAccept of <br>            //  the second NULLIP.  The second NULLIP rejected the <br>            //  call because the subtype on its output pin is not <br>            //  RGB565.  In a similar way the first NULLIP <br>            //  rejected Y41P. <br>            // <br>            //  By removing this optimization (checking the <br>            //  subtype before passing the call on) we avoided <br>            //  the problem. <br> <br>            return pNull-&gt;m_pOutput-&gt;GetConnected()-&gt;QueryAccept( pmt ); <br>        } <br>        return S_OK; <br>    } <br>    else <br>        if (*pmt == pNull-&gt;m_mtPreferred) <br>            return S_OK  ; <br>        else <br>            return VFW_E_TYPE_NOT_ACCEPTED; <br> <br>} <br> <br> <br> <br>// ---------------------------------------------------------------------------- <br>//            Input pin implementation <br>// ---------------------------------------------------------------------------- <br> <br> <br>// CheckMediaType <br>// <br>// Override CTransInPlaceOutputPin method. <br>// If we have ben given a media type from the property sheet, then insist on <br>// exactly that, else pass the request up to the base class implementation. <br>// <br>HRESULT CNullInPlaceOutputPin::CheckMediaType( const CMediaType *pmt ) <br>{   CNullInPlace *pNull = (CNullInPlace *) m_pTIPFilter; <br> <br>    if (pNull-&gt;m_mtPreferred.IsValid() == FALSE) <br>    { <br>        return CTransInPlaceOutputPin::CheckMediaType (pmt) ; <br>    } <br>    else <br>        if (*pmt == pNull-&gt;m_mtPreferred) <br>            return S_OK  ; <br>        else <br>            return VFW_E_TYPE_NOT_ACCEPTED; <br> <br>} <br> <br> <br> <br>// ---------------------------------------------------------------------------- <br>//            Filter implementation <br>// ---------------------------------------------------------------------------- <br> <br> <br>// <br>// CNullInPlace::Constructor <br>// <br>CNullInPlace::CNullInPlace(TCHAR *tszName, LPUNKNOWN punk, HRESULT *phr) <br>    : CTransInPlaceFilter (tszName, punk, CLSID_NullInPlace, phr) <br>{ <br>    m_nThisInstance = ++m_nInstanceCount; <br>    m_mtPreferred.InitMediaType () ; <br>    DbgFunc("CNullInPlace"); <br> <br> <br>} // (CNullInPlace constructor) <br> <br> <br>// <br>// CreateInstance <br>// <br>// Override CClassFactory method. <br>// Provide the way for COM to create a CNullInPlace object <br>// <br>CUnknown * WINAPI CNullInPlace::CreateInstance(LPUNKNOWN punk, HRESULT *phr) { <br> <br>    CNullInPlace *pNewObject = new CNullInPlace(NAME("Null-In-Place Filter"), punk, phr ); <br>    if (pNewObject == NULL) { <br>        *phr = E_OUTOFMEMORY; <br>    } <br> <br>    return pNewObject; <br> <br>} // CreateInstance <br> <br> <br>// <br>// GetPin <br>// <br>// Override CBaseFilter method. <br>// return a non-addrefed CBasePin * for the user to addref if he holds onto it <br>// for longer than his pointer to us.  This is part of the implementation of <br>// EnumMediaTypes.  All attempts to refer to our pins from the outside have <br>// to come through here, so it's a valid place to create them. <br>// <br>CBasePin *CNullInPlace::GetPin(int n) <br>{ <br>    // Create the single input pin and the single output pin <br>    // If anything fails, fail the whole lot and clean up. <br> <br>    if (m_pInput == NULL || m_pOutput == NULL) { <br> <br>        HRESULT hr = S_OK; <br> <br>        m_pInput = new CNullInPlaceInputPin(NAME("Null input pin"), <br>                                          this,              // Owner filter <br>                                          &amp;hr,               // Result code <br>                                          L"Input");         // Pin name <br> <br>        // a failed return code should delete the object <br> <br>        if (FAILED(hr) || m_pInput == NULL) { <br>            delete m_pInput; <br>            m_pInput = NULL; <br>            return NULL; <br>        } <br> <br>        m_pOutput = new CNullInPlaceOutputPin(NAME("Null output pin"), <br>                                            this,            // Owner filter <br>                                            &amp;hr,             // Result code <br>                                            L"Output");      // Pin name <br> <br>        // failed return codes cause both objects to be deleted <br> <br>        if (FAILED(hr) || m_pOutput == NULL) { <br>            delete m_pInput; <br>            m_pInput = NULL; <br>            delete m_pOutput; <br>            m_pOutput = NULL; <br>            return NULL; <br>        } <br>    } <br> <br>    /* Find which pin is required */ <br> <br>    switch(n) { <br>        case 0: <br>            return m_pInput; <br>        case 1: <br>           return m_pOutput; <br>    } <br>    return NULL; <br> <br>} // GetPin <br> <br> <br>// <br>// NonDelegatingQueryInterface <br>// <br>// Override CUnknown method. <br>// Part of the basic COM (Compound Object Model) mechanism. <br>// This is how we expose our interfaces. <br>// <br>STDMETHODIMP CNullInPlace::NonDelegatingQueryInterface(REFIID riid, void **ppv) <br>{ <br>    CheckPointer(ppv,E_POINTER); <br> <br>    if (riid == IID_INullIPP) { <br>        return GetInterface((INullIPP *) this, ppv); <br>    } <br>    else if (riid == IID_ISpecifyPropertyPages) { <br>        return GetInterface((ISpecifyPropertyPages *) this, ppv); <br>    } <br>    else { <br>        return CTransformFilter::NonDelegatingQueryInterface(riid, ppv); <br>    } <br> <br>} // NonDelegatingQueryInterface <br> <br>// get_IPin <br>// <br>// INull method. <br>// Set *ppPin to the upstream output pin which supplies us <br>// or to NULL if there is no upstream pin connected to us. <br>// <br>STDMETHODIMP CNullInPlace::get_IPin (IPin **ppPin) <br>{ <br>    CAutoLock l(&amp;m_NullIPLock); <br>    if (!m_pInput) <br>    { <br>        *ppPin = NULL ; <br>        return NOERROR ; <br>    } <br>    if( !m_pInput-&gt;IsConnected() ) <br>        *ppPin = NULL ; <br>    else <br>    { <br>        *ppPin = m_pInput-&gt;GetConnected () ; <br>        (*ppPin)-&gt;AddRef() ; <br>    } <br>    return NOERROR ; <br> <br>} // get_IPin <br> <br> <br>// <br>// put_MediaType <br>// <br>// INull method. <br>// <br>STDMETHODIMP CNullInPlace::put_MediaType(CMediaType *pmt) <br>{ <br>    CAutoLock l(&amp;m_NullIPLock); <br> <br>    // <br>    // if the state of the graph is running, fail the call. <br>    // <br>    if (m_State == State_Running) <br>        return E_UNEXPECTED ; <br> <br>    // <br>    // check the source and sink filters like this media type <br>    // <br>    if (pmt == NULL) <br>        m_mtPreferred.InitMediaType () ; <br>    else { <br>        IPin *pPin= m_pInput-&gt;GetConnected(); <br>        if (pPin) { <br>            if (pPin-&gt;QueryAccept(pmt) != NOERROR) { <br>                MessageBox(NULL,TEXT("Upstream filter cannot provide this type"), <br>                           TEXT("Format Selection"), <br>                           MB_OK | MB_ICONEXCLAMATION); <br>                return VFW_E_TYPE_NOT_ACCEPTED; <br>            } <br>        } <br>        pPin= m_pOutput-&gt;GetConnected(); <br>        if (pPin) { <br>            if (pPin-&gt;QueryAccept(pmt) != NOERROR) { <br>                MessageBox(NULL,TEXT("Downstream filter cannot accept this type"), <br>                           TEXT("Format Selection"), <br>                           MB_OK | MB_ICONEXCLAMATION); <br>                return VFW_E_TYPE_NOT_ACCEPTED; <br>            } <br>        } <br>        m_mtPreferred = *pmt ; <br>    } <br> <br>    // <br>    // force reconnect of input if the media type of connection does not match. <br>    // <br>    if( m_pInput-&gt;IsConnected() ) <br>    { <br>        if (m_pInput-&gt;CurrentMediaType()!= m_mtPreferred) <br>            m_pGraph-&gt;Reconnect(m_pInput); <br>    } <br>    return NOERROR ; <br> <br>} // put_MediaType <br> <br> <br> <br>// <br>// get_MediaType <br>// <br>// INull method. <br>// Set *pmt to the current preferred media type. <br>// <br>STDMETHODIMP CNullInPlace::get_MediaType(CMediaType **pmt) <br>{ <br>    CAutoLock l(&amp;m_NullIPLock); <br> <br>    *pmt = &amp;m_mtPreferred ; <br>    return NOERROR ; <br> <br>} // get_MediaType <br> <br> <br>// <br>// get_State <br>// <br>// INull method <br>// Set *state to the current state of the filter (State_Stopped etc) <br>// <br>STDMETHODIMP CNullInPlace::get_State(FILTER_STATE *state) <br>{ <br>    CAutoLock l(&amp;m_NullIPLock); <br>    *state = m_State ; <br>    return NOERROR; <br> <br>} // get_State <br> <br> <br> <br>//----------------------------------------------------------------------------- <br>//                  ISpecifyPropertyPages implementation <br>//----------------------------------------------------------------------------- <br> <br> <br>// <br>// GetPages <br>// <br>// Returns the clsid's of the property pages we support <br>// <br>STDMETHODIMP CNullInPlace::GetPages(CAUUID *pPages) { <br> <br>    pPages-&gt;cElems = 1; <br>    pPages-&gt;pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID)); <br>    if (pPages-&gt;pElems == NULL) { <br>        return E_OUTOFMEMORY; <br>    } <br>    *(pPages-&gt;pElems) = CLSID_NullIPPropertyPage; <br> <br>    return NOERROR; <br> <br>} // GetPages <br> <br> <br> <br>/******************************Public*Routine******************************\ <br>* exported entry points for registration and <br>* unregistration (in this case they only call <br>* through to default implmentations). <br>* <br>* <br>* <br>* History: <br>* <br>\**************************************************************************/ <br>STDAPI <br>DllRegisterServer() <br>{ <br>  return AMovieDllRegisterServer2( TRUE ); <br>} <br> <br>STDAPI <br>DllUnregisterServer() <br>{ <br>  return AMovieDllRegisterServer2( FALSE ); <br>} <br> <br> <br>// Microsoft C Compiler will give hundreds of warnings about <br>// unused inline functions in header files.  Try to disable them. <br>#pragma warning( disable:4514) </code></pre>
<p>&nbsp;</p></body>
</HTML>
