<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>EXT_ENUM.H</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2882"></a>EXT_ENUM.H</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br>// <br>// Ext_Enum.h <br>// <br>// <br>// Contents: <br>// <br> <br>#ifndef _Ext_Enum_h <br>#define _Ext_Enum_h <br> <br>#pragma warning( disable : 4514 ) <br> <br>// A helper template &amp; macro so that we only release non-null interface <br>// pointers and we set the pointer to null afterwards so that we don't <br>// release it again. <br>template&lt;class Interface&gt; void SafeRelPtrIPtr( Interface * * ppIUnk ) <br>{ <br>    if ( *ppIUnk ) <br>    { <br>        (*ppIUnk)-&gt;Release(); <br>        (*ppIUnk) = 0; <br>    } <br>} <br> <br>#define SafeRelIPtr( pI ) SafeRelPtrIPtr( &amp;(pI) ) <br> <br>// A template function for cloning.  We always clone an Implementation, but <br>// supply a pointer to an Interface.  We need both to parameterize this function. <br>template&lt;class Implementation, class Interface&gt; <br>static inline HRESULT CloneAny( const Implementation &amp; _this, Interface ** ppI) <br>{ <br>    HRESULT hr; <br> <br>    if (ppI) <br>    { <br>        *ppI = 0; <br>        // Relies on Implementation having defined this kind of "copy" constructor. <br>        Implementation *const p = new Implementation( _this, &amp;hr ); <br>        if (p) <br>        { <br>            if SUCCEEDED(hr)    *ppI = p; <br>            else                delete p; <br>        } <br>        else hr = E_OUTOFMEMORY; <br>    } <br>    else hr = E_POINTER; <br>    return hr; <br>} <br> <br>// AnyEnum presents a simple concrete class that can cover any enumerator that conforms to <br>// the standard COM enumerator interface.  You'll probably never instantiate one of these, <br>// but it gives us a good foundation from which to build derived enumerators with special <br>// behaviour. <br> <br>template&lt;class IEnum, class BaseType&gt; class AnyEnum : public IEnum <br>{ <br>protected: <br>long    m_cRef;                             // Local ref count <br>IEnum * m_pIEnum;                           // Pointer to a "real" enumarator that will do most of the work <br> <br>// Protected default constructor, derived classes relying on this must set m_pIEnum themselves. <br>    AnyEnum()                                   : m_cRef(1), m_pIEnum(0)  {} <br> <br>public: <br>    virtual ~AnyEnum()                          { SafeRelIPtr( m_pIEnum ); } <br>    AnyEnum( const AnyEnum &amp; copy, HRESULT * phr ); <br> <br>    // IUnknown interface <br>STDMETHODIMP            QueryInterface( REFIID iid, void ** ppv ); <br>STDMETHODIMP_(ULONG)    AddRef(); <br>STDMETHODIMP_(ULONG)    Release(); <br> <br>    // IEnum interface <br>    STDMETHODIMP            Next( ULONG cBase, BaseType ** ppBase, ULONG * pcFetched ); <br>    STDMETHODIMP            Skip( ULONG cBase ); <br>STDMETHODIMP            Reset( void ); <br>STDMETHODIMP            Clone( IEnum ** ppEnum ); <br>}; <br> <br> <br>// ConstrictedEnum <br>// <br>// An abstract template class extending AnyEnum by adding a Select() method. <br>// Derived classes must implement this method.  For each object that our inner <br>// enumerator passes back to us, we ask Select() if it meets its selection <br>// criteria, if it does, we pass the object back to our caller, otherwise we <br>// ask our inner enumerator for another candidate. <br>// <br>// Next() is enhanced to call Select() for each candidate.  Skip() is re-implemented <br>// since its skip count must now be in terms of objects that meet Select()'s criteria. <br>// A new Skip() is implemented where we can explicity get a count of the number of <br>// candidates skipped. <br> <br>template&lt;class IEnum, class BaseType&gt; class ConstrictedEnum : public AnyEnum&lt;IEnum,BaseType&gt; <br>{ <br>protected: <br>    ConstrictedEnum()                       {} <br> <br>    // Pure virtual Selector method. <br>virtual BOOL Select( BaseType ** ppBase ) =0; <br> <br>public: <br>    ConstrictedEnum( const ConstrictedEnum &amp; copy, HRESULT * phr ) <br>    : AnyEnum&lt;IEnum,BaseType&gt;( copy, phr )  {} <br> <br>    STDMETHODIMP            Next( ULONG cBase, BaseType ** ppBase, ULONG * pcFetched ); <br>STDMETHODIMP            Skip( ULONG cBase ); <br>STDMETHODIMP            Skip( ULONG cBase, ULONG * pcCount ); <br>}; <br> <br> <br>// CImpIEnumFilters <br>// <br>// This class not only restricts ennumeration to IBaseFilters that support a specific interface, <br>// it also returns pointers to THAT interface, rather than just IBaseFilter pointers. <br> <br>class CImpIEnumFilters : public ConstrictedEnum&lt;IEnumFilters, IBaseFilter&gt; <br>{ <br>private: <br>REFIIDm_iid; <br> <br>protected: <br>CImpIEnumFilters( REFIID iid )                  : m_iid(iid)                {} <br>    BOOLSelect( IBaseFilter ** ppIFilter ); <br> <br>public: <br>    CImpIEnumFilters( const CImpIEnumFilters &amp; copy, HRESULT * phr ) <br>    : ConstrictedEnum&lt;IEnumFilters,IBaseFilter&gt;( copy, phr ), m_iid( copy.m_iid )   {} <br> <br>    CImpIEnumFilters( IFilterGraph * pIFilterGraph, REFIID iid ) <br>: m_iid(iid) <br>{ <br>HRESULT hr = pIFilterGraph-&gt;EnumFilters( &amp;m_pIEnum ); <br>ASSERT( SUCCEEDED(hr) ); <br>} <br> <br>STDMETHODIMP Clone( IEnumFilters  ** ppEnum ); <br>}; <br> <br> <br>// CImpIEnumUnconnectedFilters <br>// <br>// Enumerates filters over a filter graph, but only returns those who have none of their pins connected <br> <br>class CImpIEnumUnconnectedFilters : public ConstrictedEnum&lt;IEnumFilters, IBaseFilter&gt; <br>{ <br>protected: <br>    BOOLSelect( IBaseFilter ** ppIFilter ); <br> <br>public: <br>    CImpIEnumUnconnectedFilters( const CImpIEnumUnconnectedFilters &amp; copy, HRESULT * phr ) <br>    : ConstrictedEnum&lt;IEnumFilters,IBaseFilter&gt;( copy, phr ) {} <br> <br>    CImpIEnumUnconnectedFilters( IFilterGraph * pIFilterGraph ) <br>{ <br>HRESULT hr = pIFilterGraph-&gt;EnumFilters( &amp;m_pIEnum ); <br>ASSERT( SUCCEEDED(hr) ); <br>} <br> <br>    STDMETHODIMP Clone( IEnumFilters  ** ppEnum ); <br>}; <br> <br> <br>template&lt;PIN_DIRECTION DIR&gt; class CImpIEnumPins : public ConstrictedEnum&lt;IEnumPins, IPin&gt; <br>{ <br>protected: <br>CImpIEnumPins()                                                 {} <br>    BOOLSelect( IPin ** ppIPin ); <br> <br>public: <br>CImpIEnumPins( const CImpIEnumPins &amp; copy, HRESULT * phr ) <br>    : ConstrictedEnum&lt;IEnumPins, IPin&gt;( copy, phr )                 {} <br> <br>    CImpIEnumPins( IBaseFilter * pIFilter ) <br>{ <br>HRESULT hr = pIFilter-&gt;EnumPins( &amp;m_pIEnum ); <br>ASSERT ( SUCCEEDED(hr) ); <br>} <br> <br>STDMETHODIMP Clone( IEnumPins  ** ppEnum ); <br>}; <br> <br>typedef CImpIEnumPins&lt;PINDIR_INPUT&gt;     CImpIEnumPinsIn; <br>typedef CImpIEnumPins&lt;PINDIR_OUTPUT&gt;    CImpIEnumPinsOut; <br>typedef AnyEnum&lt;IEnumPins, IPin&gt;        CImpIEnumPinsBoth; <br> <br>template&lt;class EnumPinClass&gt; class CImpIEnumOverGraph : public EnumPinClass <br>{ <br>private: <br>CImpIEnumOverGraph()            {} <br>protected: <br>    HRESULT         m_hr; <br>IEnumFilters* m_pIEnumFilters; <br>    CCritSec        m_crit_sec; <br> <br> <br>    HRESULT NextFilter();           // Iterates us through the filters <br> <br>public: <br>~CImpIEnumOverGraph()           { SafeRelIPtr(m_pIEnumFilters); } <br> <br>    CImpIEnumOverGraph( const CImpIEnumOverGraph &amp; copy, HRESULT * phr ) <br>    : EnumPinClass( copy, phr ) <br>    { <br>        if SUCCEEDED(*phr) <br>        { <br>            *phr = copy.m_pIEnumFilters-&gt;Clone( &amp;m_pIEnumFilters ); <br>            m_hr = SUCCEEDED(*phr) ? copy.m_hr : *phr; <br>        } <br>        else m_pIEnumFilters = 0; <br>    } <br> <br>    CImpIEnumOverGraph( IFilterGraph * pIFilterGraph ) <br>{ <br>HRESULT hr; <br>hr = pIFilterGraph-&gt;EnumFilters( &amp;m_pIEnumFilters ); <br>ASSERT( SUCCEEDED(hr) ); <br>hr = NextFilter(); <br>ASSERT( SUCCEEDED(hr) ); <br>} <br> <br>STDMETHODIMP Next( ULONG cBase, IPin ** ppBase, ULONG * pcFetched ); <br>STDMETHODIMP Reset( void ); <br>STDMETHODIMP Clone( IEnumPins ** ppEnum ); <br>}; <br> <br> <br>typedef CImpIEnumOverGraph&lt;CImpIEnumPinsIn&gt;     CImpIEnumPinsInOverGraph; <br>typedef CImpIEnumOverGraph&lt;CImpIEnumPinsOut&gt;    CImpIEnumPinsOutOverGraph; <br>typedef CImpIEnumOverGraph&lt;CImpIEnumPinsBoth&gt;   CImpIEnumPinsOverGraph; <br> <br>#include "Ext_Enum.inl" <br> <br>#endif </code></pre>
<p>&nbsp;</p></body>
</HTML>
