<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IAMOVIE.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2883"></a>IAMOVIE.CPP</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>#include &lt;streams.h&gt; <br>#include "Ext_Enum.h" <br> <br>class CAMovie : public IAMovie, public CUnknown <br>{ <br>private: <br>    IGraphBuilder   *   pGB; <br>    IMediaControl   *   pMC; <br>    IMediaEvent     *   pME; <br>    IMediaPosition  *   pMP; <br> <br>protected: <br>    ~CAMovie(); <br>    CAMovie(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr); <br> <br>    // Disconnect all pins.  If a filter has no pins, remove it completely <br>    // This is to part-destroy a filter graph, leaving only those filters <br>    // that may be usefult for rendering a file or pin after this function <br>    // has been called. <br>    HRESULT DisconnectAllAndRemoveIsolates(); <br> <br>    // For all filters in graph, if the filter has pins, and all are unconnected, <br>    // then remove the filter from the graph. <br>    HRESULT RemoveAllUnconnected(); <br> <br>public: <br>    DECLARE_IUNKNOWN <br> <br>    static CUnknown * WINAPI CreateInstance(LPUNKNOWN pUnk, HRESULT *phr); <br> <br>    STDMETHODIMP NonDelegatingQueryInterface(REFIID iid, void ** ppv); <br> <br>    // IFilterGraph <br> <br>    // Add a filter to the graph and name it with *pName. <br>    // If the name is not unique, The request will fail. <br>    // The Filter graph will call the JoinFilterGraph <br>    // member function of the filter to inform it. <br>    // This must be called before attempting Connect, ConnectDirect or Render <br>    // for pins of the filter. <br> <br>    STDMETHODIMP AddFilter <br>        ( IBaseFilter * pFilter, <br>          LPCWSTR pName <br>        ); <br> <br>    // Remove a filter from the graph. The filter graph implementation <br>    // will inform the filter that it is being removed. <br> <br>    STDMETHODIMP RemoveFilter <br>        ( IBaseFilter * pFilter <br>        ); <br> <br>    // Set *ppEnum to be an enumerator for all filters in the graph. <br> <br>    STDMETHODIMP EnumFilters <br>        ( IEnumFilters **ppEnum <br>        ); <br> <br>    // Set *ppFilter to be the filter which was added with the name *pName <br>    // Will fail and set *ppFilter to NULL if the name is not in this graph. <br> <br>    STDMETHODIMP FindFilterByName <br>        ( LPCWSTR pName, <br>          IBaseFilter ** ppFilter <br>        ); <br> <br>    //========================================================================== <br>    // Low level connection functions <br>    //========================================================================== <br> <br>    // Connect these two pins directly (i.e. without intervening filters) <br>    // the media type is optional, and may be partially specified (that is <br>    // the subtype and/or format type may be GUID_NULL). See IPin::Connect <br>    // for details of the media type parameter. <br>    STDMETHODIMP ConnectDirect <br>        ( IPin * ppinOut,              // the output pin <br>          IPin * ppinIn,               // the input pin <br>          const AM_MEDIA_TYPE* pmt     // optional mediatype <br>        ); <br> <br>    // On a separate thread (which will not hold any relevant locks) <br>    // Break the connection that this pin has and reconnect it to the <br>    // same other pin. <br> <br>    STDMETHODIMP Reconnect <br>        ( IPin * ppin        // the pin to disconnect and reconnect <br>        ); <br> <br>    // Disconnect this pin, if connected.  Successful no-op if not connected. <br> <br>    STDMETHODIMP Disconnect <br>        ( IPin * ppin <br>        ); <br> <br>    //========================================================================== <br>    // intelligent connectivity - now in IGraphBuilder, axextend.idl <br>    //========================================================================== <br> <br>    //========================================================================== <br>    // Whole graph functions <br>    //========================================================================== <br> <br>    // Once a graph is built, it can behave as a (composite) filter. <br>    // To control this filter, QueryInterface for IMediaFilter. <br> <br>    // The filtergraph will by default ensure that the graph has a sync source <br>    // when it is made to Run.  SetSyncSource(NULL) will prevent that and allow <br>    // all the filters to run unsynchronised until further notice. <br>    // SetDefaultSyncSource will set the default sync source (the same as would <br>    // have been set by default on the first call to Run). <br>    STDMETHODIMP SetDefaultSyncSource(void); <br> <br> <br> <br>    // IGraphBuilder <br> <br>    // Connect these two pins directly or indirectly, using transform filters <br>    // if necessary. <br> <br>    STDMETHODIMP Connect <br>    ( IPin * ppinOut,    // the output pin <br>      IPin * ppinIn      // the input pin <br>    ); <br> <br>    // Connect this output pin directly or indirectly, using transform filters <br>    // if necessary to something that will render it. <br> <br>    STDMETHODIMP Render <br>    ( IPin * ppinOut     // the output pin <br>    ); <br> <br>    // This pair of methods are a cross between the IGraphBuilder ones and the IMediaControl ones, <br>    // unfortunate perhaps, but they do make the nicest C / C++ interfaces . <br> <br>    // adds and connects filters needed to play the specified file <br>    STDMETHODIMP RenderFile( LPCWSTR strFilename ); <br> <br>    // adds to the graph the source filter that can read this file, <br>    // and returns an IFilterInfo object for it <br>    STDMETHODIMP AddSourceFilter( LPCWSTR strFilename, IBaseFilter ** ppUnk); <br> <br> <br>    // IMediaControl methods <br>    STDMETHODIMP Run(); <br>    STDMETHODIMP Pause(); <br>    STDMETHODIMP Stop(); <br> <br>    //returns the state. same semantics as IMediaFilter::GetState <br>    STDMETHODIMP GetState( <br>                LONG msTimeout, <br>                FILTER_STATE* pfs); <br> <br>    // IMediaEvent <br> <br>    // get back the event handle. This is manual-reset <br>    // (don't - it's reset by the event mechanism) and remains set <br>    // when events are queued, and reset when the queue is empty. <br>    STDMETHODIMP GetEventHandle( <br>                    HEVENT * hEvent); <br> <br>    // remove the next event notification from the head of the queue and <br>    // return it. Waits up to msTimeout millisecs if there are no events. <br>    // if a timeout occurs without any events, this method will return <br>    // E_ABORT, and the value of the event code and other parameters <br>    // is undefined. <br>    STDMETHODIMP GetEvent( <br>                    long * lEventCode, <br>                    long * lParam1, <br>                    long * lParam2, <br>                    long msTimeout <br>                    ); <br>    // Free any resources associated with the parameters to an event. <br>    // Event parameters may be LONGs, IUnknown* or BSTR. No action <br>    // is taken with LONGs. IUnknown are passed addrefed and need a <br>    // Release call. BSTR are allocated by the task allocator and will be <br>    // freed by calling the task allocator. <br>    STDMETHODIMP FreeEventParams( <br>    long lEvCode, <br>    long lParam1, <br>    long lParam2); <br> <br>    // Calls GetEvent repeatedly discarding events until it finds a <br>    // completion event (EC_COMPLETE, EC_ERRORABORT, or EC_USERABORT). <br>    // The completion event is removed from the queue and returned <br>    // in pEvCode. Note that the object is still in running mode until <br>    // a Pause or Stop call is made. <br>    // If the timeout occurs, *pEvCode will be 0 and E_ABORT will be <br>    // returned. <br>    STDMETHODIMP WaitForCompletion( <br>                    long msTimeout, <br>                    long * pEvCode); <br> <br>    // cancels any system handling of the specified event code <br>    // and ensures that the events are passed straight to the application <br>    // (via GetEvent) and not handled. A good example of this is <br>    // EC_REPAINT: default handling for this ensures the painting of the <br>    // window and does not get posted to the app. <br>    STDMETHODIMP CancelDefaultHandling( <br>                    long lEvCode); <br> <br>    // restore the normal system default handling that may have been <br>    // cancelled by CancelDefaultHandling(). <br>    STDMETHODIMP RestoreDefaultHandling( long lEvCode); <br> <br> <br>    // IMediaPosition <br>    // properties <br>    STDMETHODIMP get_Duration( <br>                REFTIME* plength); <br> <br>    STDMETHODIMP put_CurrentPosition( <br>                REFTIME llTime); <br> <br>    STDMETHODIMP get_CurrentPosition( <br>                REFTIME* pllTime); <br> <br>    STDMETHODIMP get_StopTime( <br>                REFTIME* pllTime); <br> <br>    STDMETHODIMP put_StopTime( <br>                REFTIME llTime); <br> <br>    STDMETHODIMP get_PrerollTime( <br>                REFTIME* pllTime); <br>    STDMETHODIMP put_PrerollTime( <br>                REFTIME llTime); <br> <br>    STDMETHODIMP put_Rate( <br>                double dRate); <br>    STDMETHODIMP get_Rate( <br>                double * pdRate); <br> <br>/* New methods */ <br> <br>    // Remove all filters <br>    STDMETHODIMP  RemoveAllFilters(); <br> <br>    // If the filter graph can be Run to completion, run it and wait for it to complete <br>STDMETHODIMP  Play(); <br>    // As above, but RenderNewFile first <br>    STDMETHODIMP  PlayFile( LPCWSTR strFilename ); <br> <br>    // Render all unconnected output pins <br>    STDMETHODIMP  RenderAll(); <br>    // Render supplied files "as if" the filter graoh were first emptied <br>    STDMETHODIMP  RenderNewFile( LPCWSTR strFilename ); <br> <br>    STDMETHODIMP  EnumFiltersByInterface( REFIID iid, IEnumFilters ** pEnumFilters ); <br>    // Enum pins over the entire graph <br>    STDMETHODIMP  EnumPins( IEnumPins ** ppEnum ); <br>    STDMETHODIMP  EnumPinsIn( IEnumPins ** ppEnum ); <br>    STDMETHODIMP  EnumPinsOut( IEnumPins ** ppEnum ); <br>}; <br> <br> <br> <br>CFactoryTemplate g_Templates[]= <br>{   {L"ActiveMovie Sample PID", &amp;CLSID_AMovie,   CAMovie::CreateInstance}, <br>}; <br>int g_cTemplates = sizeof(g_Templates)/sizeof(g_Templates[0]); <br> <br> <br>CAMovie::~CAMovie() <br>{ /* nothing to do */ } <br> <br>CAMovie::CAMovie(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr) <br>: CUnknown( pName, pUnk ) <br>, pGB(0), pMC(0), pME(0), pMP(0) <br>{ <br>    if (!pUnk) *phr = VFW_E_NEED_OWNER; <br>    else if SUCCEEDED(*phr) <br>    { <br>        *phr = pUnk-&gt;QueryInterface( IID_IGraphBuilder, reinterpret_cast&lt;void**&gt;(&amp;pGB) ); <br>        if SUCCEEDED(*phr) <br>        { <br>            pGB-&gt;Release(); <br>            *phr = pUnk-&gt;QueryInterface( IID_IMediaControl, reinterpret_cast&lt;void**&gt;(&amp;pMC) ); <br>            if SUCCEEDED(*phr) <br>            { <br>                pMC-&gt;Release(); <br>                *phr = pUnk-&gt;QueryInterface( IID_IMediaEvent, reinterpret_cast&lt;void**&gt;(&amp;pME) ); <br>                if SUCCEEDED(*phr) <br>                { <br>                    pME-&gt;Release(); <br>                    *phr = pUnk-&gt;QueryInterface( IID_IMediaPosition, reinterpret_cast&lt;void**&gt;(&amp;pMP) ); <br>                    if SUCCEEDED(*phr) pMP-&gt;Release(); <br>                } <br>            } <br>        } <br>    } <br>} <br> <br>CUnknown * WINAPI CAMovie::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr) <br>{ <br>    CUnknown * result = 0; <br>    result = new CAMovie( NAME("IAMovie Class"), pUnk, phr ); <br>    if ( !result ) *phr = E_OUTOFMEMORY; <br>    return result; <br>} <br> <br>STDMETHODIMP CAMovie::NonDelegatingQueryInterface(REFIID iid, void ** ppv) <br>{ <br>    CheckPointer(ppv,E_POINTER); <br> <br>    if ( iid == IID_IAMovie ) <br>    { <br>        return GetInterface(static_cast&lt;IAMovie *&gt;(this), ppv ); <br>    } <br>    else <br>    { <br>return CUnknown::NonDelegatingQueryInterface(iid, ppv); <br>    } <br>} <br> <br> <br>// IFilterGraph (pGB) <br>STDMETHODIMP CAMovie::AddFilter( IBaseFilter * pFilter, LPCWSTR pName ) <br>{ return pGB-&gt;AddFilter( pFilter, pName ); } <br>STDMETHODIMP CAMovie::RemoveFilter( IBaseFilter * pFilter ) <br>{ return pGB-&gt;RemoveFilter( pFilter ); } <br>STDMETHODIMP CAMovie::EnumFilters( IEnumFilters **ppEnum ) <br>{ return pGB-&gt;EnumFilters( ppEnum ); } <br>STDMETHODIMP CAMovie::FindFilterByName( LPCWSTR pName, IBaseFilter ** ppFilter ) <br>{ return pGB-&gt;FindFilterByName( pName, ppFilter ); } <br>STDMETHODIMP CAMovie::ConnectDirect( IPin * ppinOut, IPin * ppinIn, const AM_MEDIA_TYPE* pmt ) <br>{ return pGB-&gt;ConnectDirect( ppinOut, ppinIn, pmt ); } <br>STDMETHODIMP CAMovie::Reconnect( IPin * ppin ) <br>{ return pGB-&gt;Reconnect( ppin ); } <br>STDMETHODIMP CAMovie::Disconnect( IPin * ppin ) <br>{ return pGB-&gt;Disconnect( ppin ); } <br>STDMETHODIMP CAMovie::SetDefaultSyncSource( ) <br>{ return pGB-&gt;SetDefaultSyncSource( ); } <br> <br> <br>// IGraphBuilder (pGB) <br>STDMETHODIMP CAMovie::Connect( IPin * ppinOut, IPin * ppinIn ) <br>{ return pGB-&gt;Connect( ppinOut, ppinIn ); } <br>STDMETHODIMP CAMovie::Render( IPin * ppinOut ) <br>{ return pGB-&gt;Render( ppinOut ); } <br> <br> <br>// This pair of methods are a cross between the IGraphBuilder ones and the IMediaControl ones, <br>// unfortunate perhaps, but they do make the nicest C / C++ interfaces . <br>STDMETHODIMP CAMovie::AddSourceFilter( LPCWSTR strFilename, IBaseFilter ** ppUnk ) <br>{ <br>    const LPWSTR fn = const_cast&lt;LPWSTR&gt;(strFilename); <br>    return pGB-&gt;AddSourceFilter( fn, fn, ppUnk ); <br>} <br> <br>STDMETHODIMP CAMovie::RenderFile( LPCWSTR strFilename ) <br>{ <br>    const LPWSTR fn = const_cast&lt;LPWSTR&gt;(strFilename); <br>    return pGB-&gt;RenderFile( fn, fn ); <br>} <br> <br> <br>// IMediaControl (pMC) <br>STDMETHODIMP CAMovie::Run( ) <br>{ return pMC-&gt;Run( ); } <br>STDMETHODIMP CAMovie::Pause( ) <br>{ return pMC-&gt;Pause( ); } <br>STDMETHODIMP CAMovie::Stop( ) <br>{ return pMC-&gt;Stop( ); } <br>STDMETHODIMP CAMovie::GetState( LONG msTimeout, FILTER_STATE* pfs ) <br>{ return pMC-&gt;GetState( msTimeout, (long *)pfs ); } <br> <br> <br> <br>// IMediaEvent (pME) <br>STDMETHODIMP CAMovie::GetEventHandle( HEVENT * hEvent ) <br>{ return pME-&gt;GetEventHandle( (long *)hEvent ); } <br>STDMETHODIMP CAMovie::GetEvent( long * lEventCode, long * lParam1, long * lParam2, long msTimeout ) <br>{ return pME-&gt;GetEvent( lEventCode, lParam1, lParam2, msTimeout ); } <br>STDMETHODIMP CAMovie::FreeEventParams( long lEventCode, long lParam1, long lParam2 ) <br>{ return pME-&gt;FreeEventParams( lEventCode, lParam1, lParam2 ); } <br>STDMETHODIMP CAMovie::WaitForCompletion( long msTimeout, long * pEvCode ) <br>{ return pME-&gt;WaitForCompletion( msTimeout, pEvCode ); } <br>STDMETHODIMP CAMovie::CancelDefaultHandling( long lEvCode ) <br>{ return pME-&gt;CancelDefaultHandling( lEvCode ); } <br>STDMETHODIMP CAMovie::RestoreDefaultHandling( long lEvCode ) <br>{ return pME-&gt;RestoreDefaultHandling( lEvCode ); } <br> <br> <br>// IMediaPosition (pMP ) <br>STDMETHODIMP CAMovie::get_Duration( REFTIME* plength ) <br>{ return pMP-&gt;get_Duration( plength ); } <br>STDMETHODIMP CAMovie::put_CurrentPosition( REFTIME llTime ) <br>{ return pMP-&gt;put_CurrentPosition( llTime ); } <br>STDMETHODIMP CAMovie::get_CurrentPosition( REFTIME* pllTime ) <br>{ return pMP-&gt;get_CurrentPosition( pllTime ); } <br>STDMETHODIMP CAMovie::get_StopTime( REFTIME* pllTime ) <br>{ return pMP-&gt;get_StopTime( pllTime ); } <br>STDMETHODIMP CAMovie::put_StopTime( REFTIME llTime ) <br>{ return pMP-&gt;put_StopTime( llTime ); } <br>STDMETHODIMP CAMovie::get_PrerollTime( REFTIME* pllTime ) <br>{ return pMP-&gt;get_PrerollTime( pllTime ); } <br>STDMETHODIMP CAMovie::put_PrerollTime( REFTIME llTime ) <br>{ return pMP-&gt;put_PrerollTime( llTime ); } <br>STDMETHODIMP CAMovie::put_Rate( double dRate ) <br>{ return pMP-&gt;put_Rate( dRate ); } <br>STDMETHODIMP CAMovie::get_Rate( double * pdRate ) <br>{ return pMP-&gt;get_Rate( pdRate ); } <br> <br> <br> <br>// New methods <br> <br>// Remove all filters <br>STDMETHODIMP CAMovie::RemoveAllFilters() <br>{ <br>    HRESULT  hr; <br> <br>    IEnumFilters * piEnumFilters; <br>    hr = EnumFilters( &amp;piEnumFilters ); <br>    if SUCCEEDED(hr) <br>    { <br>        CGenericList&lt;IBaseFilter&gt; FilterList("List of filters to be removed"); <br> <br>        IBaseFilter * piFilter; <br>        while ( piEnumFilters-&gt;Next(1, &amp;piFilter, 0) == NOERROR ) <br>        { <br>            FilterList.AddTail( piFilter ); <br>        } <br>        piEnumFilters-&gt;Release(); <br>        while ( piFilter = FilterList.RemoveHead() ) <br>        { <br>            hr = RemoveFilter( piFilter ); <br>            piFilter-&gt;Release(); <br>        } <br>    } <br>    return hr; <br>} <br> <br>// If the filter graph can be Run to completion, run it and wait for it to complete <br>STDMETHODIMP  CAMovie::Play() <br>{ <br>    HRESULT hr; <br>    REFTIME duration; <br>    hr = get_Duration( &amp;duration ); <br>    if ( SUCCEEDED( hr ) &amp;&amp; duration &gt; 0 ) <br>    { <br>        hr = Run(); <br>        if SUCCEEDED(hr) <br>        { <br>            long evCode; <br>            WaitForCompletion( INFINITE, &amp;evCode ); <br>        } <br>        Stop(); <br>    } <br>    return hr; <br>} <br> <br>STDMETHODIMP  CAMovie::PlayFile( LPCWSTR strFilename ) <br>{ <br>    HRESULT hr; <br>    hr = RenderNewFile( strFilename ); <br>    if SUCCEEDED(hr) <br>    { <br>        hr = Play(); <br>    } <br>    return hr; <br>} <br> <br>STDMETHODIMP CAMovie::RenderAll( ) <br>{ <br>    HRESULT hr = NOERROR; <br>    CImpIEnumPinsOutOverGraph EnumOutPins( this, &amp;hr ); <br>    if SUCCEEDED(hr) <br>    { <br>        IPin * piPin; <br> <br>        while ( EnumOutPins.Next( 1, &amp;piPin, 0 ) == NOERROR ) <br>        { <br>            Render( piPin ); <br>        } <br>    } <br>    return hr; <br>} <br> <br>STDMETHODIMP CAMovie::RenderNewFile( LPCWSTR strFilename ) <br>{ <br>    HRESULT hr; <br>    DisconnectAllAndRemoveIsolates(); <br>    hr = RenderFile( strFilename ); <br>    RemoveAllUnconnected(); <br>    return hr; <br>} <br> <br>STDMETHODIMP CAMovie::EnumFiltersByInterface( REFIID iid, IEnumFilters ** ppEnum ) <br>{ <br>    HRESULT hr = NOERROR; <br>    *ppEnum = new CImpIEnumFilters( pGB, iid ); <br>    if (!*ppEnum) hr = E_OUTOFMEMORY; <br>    else if FAILED(hr) <br>    { <br>        delete *ppEnum; <br>        *ppEnum = 0; <br>    } <br>    return hr; <br>} <br> <br>STDMETHODIMP CAMovie::EnumPins( IEnumPins ** ppEnum ) <br>{ <br>    HRESULT hr = NOERROR; <br>    *ppEnum = new CImpIEnumPinsOverGraph( pGB, &amp;hr ); <br>    if (!*ppEnum) hr = E_OUTOFMEMORY; <br>    else if FAILED(hr) <br>    { <br>        delete *ppEnum; <br>        *ppEnum = 0; <br>    } <br>    return hr; <br>} <br> <br>STDMETHODIMP CAMovie::EnumPinsIn( IEnumPins ** ppEnum ) <br>{ <br>    HRESULT hr = NOERROR; <br>    *ppEnum = new CImpIEnumPinsInOverGraph( pGB, &amp;hr ); <br>    if (!*ppEnum) hr = E_OUTOFMEMORY; <br>    else if FAILED(hr) <br>    { <br>        delete *ppEnum; <br>        *ppEnum = 0; <br>    } <br>    return hr; <br>} <br> <br>STDMETHODIMP CAMovie::EnumPinsOut( IEnumPins ** ppEnum ) <br>{ <br>    HRESULT hr = NOERROR; <br>    *ppEnum = new CImpIEnumPinsOutOverGraph( pGB, &amp;hr ); <br>    if (!*ppEnum) hr = E_OUTOFMEMORY; <br>    else if FAILED(hr) <br>    { <br>        delete *ppEnum; <br>        *ppEnum = 0; <br>    } <br>    return hr; <br>} <br> <br> <br>// Protected methods <br> <br>// #include &lt;iostream.h&gt; <br>// #include &lt;SampIOS.h&gt; <br> <br>// Disconnect all pins.  If a filter has no pins, remove it completely <br>// This is to part-destroy a filter graph, leaving only those filters <br>// that may be usefult for rendering a file or pin after this function <br>// has been called. <br>HRESULT CAMovie::DisconnectAllAndRemoveIsolates() <br>{ <br>    // cout &lt;&lt; "Pre DisconnectAllAndRemoveIsolates()\n" &lt;&lt; pGB &lt;&lt; endl; <br>    HRESULT  hr; <br> <br>    IEnumFilters * piEnumFilters; <br>    hr = EnumFilters( &amp;piEnumFilters ); <br>    if SUCCEEDED(hr) <br>    { <br>        CGenericList&lt;IPin&gt;        PinList("List of pins to be disconnected"); <br>        CGenericList&lt;IBaseFilter&gt; FilterList("List of filters to be removed"); <br>        IBaseFilter * piFilter; <br>        IPin * piPin; <br>        while ( piEnumFilters-&gt;Next(1, &amp;piFilter, 0) == NOERROR ) <br>        { <br>            BOOL connected = FALSE, connectable = FALSE; <br>            IEnumPins * piEnumPins; <br>            hr = piFilter-&gt;EnumPins( &amp;piEnumPins ); <br>            if SUCCEEDED(hr) <br>            { <br>                while ( piEnumPins-&gt;Next(1, &amp;piPin, 0) == NOERROR ) <br>                { <br>                    connectable = TRUE; <br>                    IPin * piPinConnectedTo; <br>                    piPin-&gt;ConnectedTo( &amp;piPinConnectedTo ); <br>                    if (piPinConnectedTo) <br>                    { <br>                        PinList.AddTail( piPin ); <br>                        piPinConnectedTo-&gt;Release(); <br>                    } <br>                    else piPin-&gt;Release(); <br>                } <br>                piEnumPins-&gt;Release(); <br>            } <br>            if (!connectable)   FilterList.AddTail( piFilter ); <br>            else                piFilter-&gt;Release(); <br>        } <br>        piEnumFilters-&gt;Release(); <br>        while ( piPin = PinList.RemoveHead() ) <br>        { <br>            hr = Disconnect( piPin ); <br>            piPin-&gt;Release(); <br>        } <br>        while ( piFilter = FilterList.RemoveHead() ) <br>        { <br>            hr = RemoveFilter( piFilter ); <br>            piFilter-&gt;Release(); <br>        } <br>    } <br>    // cout &lt;&lt; "Post DisconnectAllAndRemoveIsolates()\n" &lt;&lt; pGB &lt;&lt; endl; <br>    return hr; <br>} <br> <br>// For all filters in graph, if the filter has pins, and all are unconnected, <br>// then remove the filter from the graph. <br>HRESULT CAMovie::RemoveAllUnconnected() <br>{ <br>    // cout &lt;&lt; "Pre RemoveAllUnconnected()\n" &lt;&lt; pGB &lt;&lt; endl; <br>    HRESULT  hr; <br> <br>    IEnumFilters * piEnumFilters; <br>    hr = EnumFilters( &amp;piEnumFilters ); <br>    if SUCCEEDED(hr) <br>    { <br>        CGenericList&lt;IBaseFilter&gt; FilterList("List of filters to be removed"); <br>        IBaseFilter * piFilter; <br>        while ( piEnumFilters-&gt;Next(1, &amp;piFilter, 0) == NOERROR ) <br>        { <br>            BOOL connected = FALSE, connectable = FALSE; <br>            IEnumPins * piEnumPins; <br>            hr = piFilter-&gt;EnumPins( &amp;piEnumPins ); <br>            if SUCCEEDED(hr) <br>            { <br>                IPin * piPin; <br>                while ( !connected &amp;&amp; piEnumPins-&gt;Next(1, &amp;piPin, 0) == NOERROR ) <br>                { <br>                    connectable = TRUE; <br>                    IPin * piPinConnectedTo; <br>                    piPin-&gt;ConnectedTo( &amp;piPinConnectedTo ); <br>                    if (piPinConnectedTo) <br>                    { <br>                        connected = TRUE; <br>                        piPinConnectedTo-&gt;Release(); <br>                    } <br>                    piPin-&gt;Release(); <br>                } <br>                piEnumPins-&gt;Release(); <br>            } <br>            if (connectable &amp;&amp; !connected)  FilterList.AddTail( piFilter ); <br>            else                            piFilter-&gt;Release(); <br>        } <br>        piEnumFilters-&gt;Release(); <br>        while ( piFilter = FilterList.RemoveHead() ) <br>        { <br>            hr = RemoveFilter( piFilter ); <br>            piFilter-&gt;Release(); <br>        } <br>    } <br>    // cout &lt;&lt; "Post RemoveAllUnconnected()\n" &lt;&lt; pGB &lt;&lt; endl; <br>    return hr; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>//  AMovieRegisterInterface() <br>// <br>// <br>// <br>//--------------------------------------------------------------------------- <br> <br>HRESULT <br>AMovieRegisterInterface( CLSID  ClsidInterface <br>                       , LPTSTR strName <br>                       , CLSID  ClsidDistributor ) <br>{ <br>  TCHAR   achKey[MAX_PATH]; <br>  TCHAR   achClsidInterface[CHARS_IN_GUID]; <br>  TCHAR   achClsidDistributor[CHARS_IN_GUID]; <br>  OLECHAR achTemp[CHARS_IN_GUID]; <br>  HKEY    hkey, hsubkey; <br>  LONG    lReturn; <br>  HRESULT hr; <br> <br>  hr = StringFromGUID2( ClsidInterface <br>                      , achTemp <br>                      , CHARS_IN_GUID ); <br>  if( SUCCEEDED(hr) ) <br>  { <br>    wsprintf( achClsidInterface, "%ls", achTemp ); <br> <br>    hr = StringFromGUID2( ClsidDistributor <br>                        , achTemp <br>                        , CHARS_IN_GUID ); <br>  } <br> <br>  if( FAILED(hr) ) return hr; <br> <br>  wsprintf( achClsidDistributor, "%ls", achTemp ); <br> <br>  wsprintf( achKey, "Interface\\%s", achClsidInterface ); <br>  lReturn = RegCreateKey( HKEY_CLASSES_ROOT <br>                        , achKey <br>                        , &amp;hkey ); <br>  if( ERROR_SUCCESS == lReturn ) <br>  { <br>    if( NULL != strName ) <br>    { <br>      RegSetValue( hkey <br>                 , NULL <br>                 , REG_SZ <br>                 , strName <br>                 , lstrlen(strName)+1 ); <br>    } <br> <br>    lReturn = RegCreateKey( hkey <br>                          , "Distributor" <br>                          , &amp;hsubkey ); <br>    if( ERROR_SUCCESS == lReturn ) <br>    { <br> <br>      RegSetValue( hsubkey <br>                 , NULL <br>                 , REG_SZ <br>                 , achClsidDistributor <br>                 , lstrlen(achClsidDistributor)+1 ); <br> <br>      RegCloseKey( hsubkey ); <br>    } <br> <br>    RegCloseKey( hkey ); <br>  } <br> <br>  return HRESULT_FROM_WIN32(lReturn); <br> <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>// AMovieUnregisterInterface() <br>// <br>// <br>// <br>//--------------------------------------------------------------------------- <br> <br>HRESULT <br>AMovieUnregisterInterface( REFCLSID ClsidInterface ) <br>{ <br>  HKEY    hkey; <br>  LONG    lReturn; <br>  HRESULT hr; <br>  TCHAR   achClsidInterface[CHARS_IN_GUID]; <br>  OLECHAR achTemp[CHARS_IN_GUID]; <br> <br>  // comvert CLSID to OLE string <br>  // <br>  hr  = StringFromGUID2( ClsidInterface, achTemp, CHARS_IN_GUID ); <br>  if( FAILED(hr) ) return hr; <br> <br>  // convert OLE string to ANSI (as that's <br>  // all that WIN95 Reg* calls can handle <br>  // <br>  wsprintf( achClsidInterface, "%ls", achTemp ); <br> <br>  // open Interface key <br>  // <br>  lReturn = RegOpenKeyEx( HKEY_CLASSES_ROOT <br>                        , TEXT("Interface") <br>                        , 0 <br>                        , MAXIMUM_ALLOWED <br>                        , &amp;hkey ); <br>  if( ERROR_SUCCESS == lReturn ) <br>  { <br>    // if successful, eliminate subkey and close <br>    // Interface key <br>    // <br>    EliminateSubKey( hkey, achClsidInterface ); <br>    RegCloseKey( hkey ); <br>  } <br> <br>  return HRESULT_FROM_WIN32( lReturn ); <br>} <br> <br>// <br>// exported entry points for registration and <br>// unregistration. <br>// <br>// In this case they (un)register out one and <br>// only interface and then call through to the <br>// default implementation. <br>// <br>// UUID Interface   {359ace10-7688-11cf-8b23-00805f6cef60} <br>// Interface name   IAMovie <br>// UUID Distributor {5f2759c0-7685-11cf-8b23-00805f6cef60} <br>// <br>STDAPI DllRegisterServer() <br>{ <br>  HRESULT hr = NOERROR; <br> <br>  // Register interface so ActiveMovie can <br>  // find me from my IID <br>  // <br>  hr = AMovieRegisterInterface( IID_IAMovie <br>                              , TEXT("IAMovie") <br>                              , CLSID_AMovie  ); <br> <br>  if( SUCCEEDED(hr) ) <br>    hr = AMovieDllRegisterServer2( TRUE ); <br> <br>  return hr; <br>} <br> <br>STDAPI DllUnregisterServer() <br>{ <br>  HRESULT hr = NOERROR; <br> <br>  hr = AMovieUnregisterInterface( IID_IAMovie ); <br> <br>  if( SUCCEEDED(hr) ) <br>    hr = AMovieDllRegisterServer2( FALSE ); <br> <br>  return hr; <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
