<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DXA.CPP</title>
<link disabled rel=stylesheet href=../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2706"></a>DXA.CPP</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1995-1997 Microsoft Corporation. All Rights Reserved. <br> * <br> *  File:       dxa.cpp <br> * <br> *  This file contains functions that make use of DirectX Animation <br> *  to render animation to a ddraw surface. <br> * <br> ***************************************************************************/ <br> <br>#include "dxa.h" <br> <br>IDAViewPtr DXA::_view = NULL; <br> <br>/* <br> * StartOle <br> * <br> * Start the Ole services. <br> */ <br>struct StartOle { <br>    StartOle() { CoInitialize( NULL ); } <br>    ~StartOle() { CoUninitialize(); } <br>} _inst_StartOle; <br> <br>/* <br> * dump_com_error <br> * <br> * Dump the com error should an exception occurs in InitDXAViewObj. <br> * This is mainly for debugging purpose. <br> */ <br>void dump_com_error( _com_error &amp;e ) <br>{ <br>    char buf[2048]; <br> <br>    sprintf(buf, _T( "Oops - hit an error!\n\tCode = %08lx\n\tCode meaning = %s\n" ), <br>            e.Error(), e.ErrorMessage()); <br>    OutputDebugString(buf); <br>} <br> <br>/* <br> * initDXAViewObj <br> * <br> * Create the DAView object, construct the model, then start the model. <br> * <br> */ <br>BOOL DXA::initDXAViewObj(IUnknown *ddsurf) <br>{ <br>    try { <br>        IDAStaticsPtr e; <br> <br>        // Create the statics object <br>        e.CreateInstance( L"DirectAnimation.DAStatics" ); <br>         <br>        // Create and establish the view <br>        _view.CreateInstance( L"DirectAnimation.DAView" ); <br> <br>        // Import Media (images and sound in this case).  The <br>        // GetCurrentDirectory() (which will return the path to either <br>        // the debug or release sub directory) is used as a starting <br>        // point for relative file importing. <br>        TCHAR szMediaBase[_MAX_PATH]; <br>        TCHAR szImg[_MAX_PATH]; <br>        TCHAR szGeo[_MAX_PATH]; <br>        TCHAR szSnd[_MAX_PATH]; <br> <br>        GetModuleFileName(GetModuleHandle("Union.exe"), <br>          szMediaBase,sizeof(szMediaBase)); <br>        char *pos = strrchr( szMediaBase, (int)'\\' ); <br>        int result = pos - szMediaBase + 1; <br>        szMediaBase[result]= NULL; <br> <br>        _tcscat(szMediaBase,_T("../../../../../media/")); <br> <br>        _tcscpy(szImg,szMediaBase); <br>        _tcscpy(szGeo,szMediaBase); <br>        _tcscpy(szSnd,szMediaBase); <br> <br>        _tcscat(szImg,_T("image/")); <br>        _tcscat(szGeo,_T("geometry/")); <br>        _tcscat(szSnd,_T("sound/")); <br>       <br>        IDAGeometryPtr rawSphere = <br>          e-&gt;ImportGeometry( _bstr_t(szGeo) + _bstr_t( "sphere.x" ) ); <br>        IDAGeometryPtr rawCube = <br>          e-&gt;ImportGeometry( _bstr_t(szGeo) + _bstr_t( "cube.x" ) ); <br>        IDAGeometryPtr rawCone = <br>          e-&gt;ImportGeometry( _bstr_t(szGeo) + _bstr_t( "cone.x" ) ); <br>        IDAGeometryPtr rawCylinder = <br>          e-&gt;ImportGeometry( _bstr_t(szGeo) + _bstr_t( "cylinder.x" ) ); <br> <br>        // Import a sound, supply null as the second argument since we don't <br>        // want a length. <br>        IDASoundPtr snd = e-&gt;ImportSound(  _bstr_t(szSnd) + _bstr_t( "etherial.mp2" ) )-&gt;Sound-&gt;Loop(); <br> <br>        // Size the objects down. <br>        IDATransform3Ptr scaler = e-&gt;Scale3UniformAnim( e-&gt;DANumber( 0.25 ) ); <br>        IDAGeometryPtr sphere   = rawSphere-&gt;Transform( scaler ); <br>        IDAGeometryPtr cube     = rawCube-&gt;Transform( scaler ); <br>        IDAGeometryPtr cone     = rawCone-&gt;Transform( scaler ); <br>        IDAGeometryPtr cylinder = rawCylinder-&gt;Transform( scaler ); <br> <br>        IDAGeometryPtr xcone    = cone-&gt;Transform( e-&gt;Rotate3Anim( <br>          e-&gt;GetXVector3(), e-&gt;DANumber( 3.1415927 ) ) ); <br> <br>        IDAColorPtr color1 = myColor( 0, 2, e ); <br>        IDAColorPtr color2 = myColor( 0.25, 3, e ); <br>        IDAColorPtr color3 = myColor( 0.5, 4, e ); <br>        IDAColorPtr color4 = myColor( 0.75, 1, e ); <br> <br>        // Shapes to start with (many with time varying colors) <br>        IDAGeometryPtr shapes[] = { <br>            sphere-&gt;DiffuseColor( color1 ), <br>            sphere-&gt;DiffuseColor( color1 ), <br>            cone-&gt;DiffuseColor( color2 ), <br>            xcone-&gt;DiffuseColor( color2 ), <br>            cube-&gt;DiffuseColor( color3 ), <br>            cube-&gt;DiffuseColor( color3 ), <br>            cylinder-&gt;DiffuseColor( color4 ) }; <br> <br>        // Places to Translate them to. <br>        double tls[][3] = { { 0.75, 0, 0 }, <br>                           { -0.75, 0, 0 }, <br>                           { 0, 0.75, 0 }, <br>                           { 0, -0.75, 0 }, <br>                           { 0, 0, 0.75 }, <br>                           { 0, 0, -0.75 }, <br>                           { 0, 0, 0 } }; <br> <br>        // Go ahead and accumulate up the Translated geometry by cycling <br>        // through the arrays. <br>        IDAGeometryPtr geo = e-&gt;EmptyGeometry; <br>        for ( int i = 0; i &lt; sizeof( shapes ) / sizeof( shapes[0] ); i++ ) { <br>          IDATransform3Ptr xf = e-&gt;Translate3Anim( e-&gt;DANumber( tls[i][0] ), <br>            e-&gt;DANumber( tls[i][1] ), e-&gt;DANumber( tls[i][2] ) ); <br>          geo = e-&gt;UnionGeometry( geo, shapes[i]-&gt;Transform( xf ) ); <br>        } <br> <br>        // Set the whole thing in motion <br>        IDATransform3Ptr xf = <br>            e-&gt;Compose3( e-&gt;Rotate3Anim( e-&gt;GetXVector3(), e-&gt;LocalTime ), <br>              e-&gt;Compose3( e-&gt;Rotate3Anim( e-&gt;GetZVector3(), e-&gt;Mul( e-&gt;LocalTime, e-&gt;DANumber( 1.9 ) ) ), <br>                e-&gt;Compose3( e-&gt;Rotate3Anim( e-&gt;GetYVector3(), e-&gt;Mul( e-&gt;LocalTime, e-&gt;DANumber( 3.1415927 ) ) ), <br>                  e-&gt;Scale3UniformAnim( e-&gt;DANumber( 0.75 ) ) ) ) ); <br> <br>        geo = geo-&gt;Transform( xf ); <br> <br>        // Render into an image, and overlay atop a solid image. <br>        IDAImagePtr geoIm = geometryImage( e-&gt;UnionGeometry( geo, e-&gt;DirectionalLight ), e ); <br> <br>        IDAImagePtr model = e-&gt;Overlay( geoIm, e-&gt;SolidColorImage( e-&gt;White ) ); <br> <br>        // Set the size of the viewport.  Not doing this  (as done in this <br>        // case) will render the animation accross the entire primary surface. <br>        _view-&gt;SetViewport(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT); <br>        // Let the view draw to the primary surface. <br>        _view-&gt;IDirectDrawSurface = ddsurf; <br>        _view-&gt;CompositeDirectlyToTarget = TRUE; <br>        // Start the model on the view. <br>        _view-&gt;StartModel(model, snd, 0); <br> <br>    } catch (_com_error &amp;e) { <br>        dump_com_error( e ); <br>        return false; <br>    } <br>    return true; <br>} <br> <br>BOOL DXA::resetDXASurfaces(IUnknown *ddsurf) <br>{ <br>    try { <br>        _view-&gt;IDirectDrawSurface = ddsurf; <br>    } catch (_com_error &amp;e) { <br>        dump_com_error( e ); <br>        return false; <br>    } <br>    return true; <br>} <br> <br>/*  <br> * geometryImage <br> * Renders a geometry as an image <br> */ <br>IDAImagePtr DXA::geometryImage( IDAGeometryPtr geo, IDAStaticsPtr e ) { <br>    IDACameraPtr cam = e-&gt;PerspectiveCameraAnim( e-&gt;DANumber( 1 ), <br>      e-&gt;DANumber( 0 ) )-&gt;Transform( e-&gt;Translate3Anim( <br>      e-&gt;DANumber( 0 ), e-&gt;DANumber( 0 ), e-&gt;DANumber( 2 ) ) ); <br>    IDATransform2Ptr sc = e-&gt;Scale2UniformAnim( e-&gt;DANumber( 0.1 ) ); <br> <br>    return geo-&gt;Render( cam )-&gt;Transform( sc ); <br>  } <br> <br>/* <br> * myColor <br> * Create a animated color whose saturation varies over time. <br> */ <br>IDAColorPtr DXA::myColor( double hue, double saturationRate, <br>    IDAStaticsPtr e ) { <br>    IDANumberPtr sat = e-&gt;Add( e-&gt;Mul( e-&gt;Sin( e-&gt;Mul( e-&gt;LocalTime, <br>      e-&gt;DANumber( saturationRate ) ) ), e-&gt;DANumber( 0.5 ) ), e-&gt;DANumber( 0.5 ) ); <br> <br>    return e-&gt;ColorHslAnim( e-&gt;DANumber( hue ), sat, e-&gt;DANumber( 0.5 ) ); <br>  } <br> <br>/* <br> * tick <br> * Ask DA to sample and display the model. <br> */ <br>void DXA::tick() { <br>    static double startTime = 0; <br>    struct _timeb timebuffer; <br> <br>    if (_view != NULL) { <br>        _ftime( &amp;timebuffer ); <br>        double thisTime = timebuffer.time + ( timebuffer.millitm / 1000.0 ); <br> <br>        if ( startTime == 0 )  { <br>            startTime = thisTime; <br>            thisTime = 0; <br>        } <br>        else <br>            thisTime -= startTime; <br> <br>        _view-&gt;Tick(thisTime); <br>        _view-&gt;Render(); <br>    } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
