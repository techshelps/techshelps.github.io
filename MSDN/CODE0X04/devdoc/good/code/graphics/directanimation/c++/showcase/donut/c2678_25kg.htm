<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DONUT.CPP</title>
<link disabled rel=stylesheet href=../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2680"></a>DONUT.CPP</h2>
<pre><code>/*========================================================================== <br> * <br> *  Copyright (C) 1995-1997 Microsoft Corporation. All Rights Reserved. <br> * <br> *  File:       donut.cpp <br> * <br> *  This sample takes the ddraw donut sample from the DirectX SDK and <br> *  adds two animating text strings to it using DirectX Animation. <br> * <br> *  It shows how one can add DXA animation to an existing direct draw <br> *  application.  Since DXA can render to a direct draw surface, this sample <br> *  creates an offscreen surface and hands it to DXA.  Two DXA views are <br> *  created, one with a rotating text string (view1), the other with a <br> *  text string moving up and down (view2). <br> <br> *  On every frame, four things are performed: <br> *  1) view1 is asked to render (to the offscreen surface) <br> *  2) blt donut to the same offscreen surface <br> *  3) view2 is asked to render (to the offscreen surface) <br> *  4) blt from the offscreen surface to the primary. <br> * <br> *  Creating multiple views allows DXA animation to be both under and <br> *  above the donut. <br> * <br> ***************************************************************************/ <br> <br>#define NAME "Donut" <br>#define TITLE "Donut" <br> <br>#define WIN32_LEAN_AND_MEAN <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;ddrawex.h&gt; <br>#include "ddutil.h" <br>#include "dxa.h" <br>#include "resource.h" <br> <br>char szBitmap[] = "DONUT"; <br> <br>BOOL            gExclusive = FALSE; <br>BOOL            bPaused = FALSE; <br>HWND            hWndMain; <br> <br>IDirectDrawFactory      *lpDDF; <br>LPDIRECTDRAW            lpDD;           // DirectDraw object <br>LPDIRECTDRAWSURFACE     lpDDSPrimary;   // DirectDraw primary surface <br>LPDIRECTDRAWSURFACE     lpDDSDA;        // Offscreen surface for DA <br>LPDIRECTDRAWSURFACE     lpDDSDonut;     // Offscreen surface for donut <br>LPDIRECTDRAWPALETTE     lpDDPal;        // DirectDraw palette <br>LPDIRECTDRAWCLIPPER     lpClipper;      // Clipper for the primary surface <br>BOOL                    bActive;        // is application active? <br>RECT                    windowRect;     // windows' client rectangle <br> <br>/* <br> * releaseSurfaces <br> * <br> * Release the global surfaces and clipper. <br> */ <br>void releaseSurfaces( void ) <br>{ <br>    if( lpDDSPrimary != NULL ) <br>    { <br>        lpDDSPrimary-&gt;Release(); <br>        lpDDSPrimary = NULL; <br>    } <br>    if( lpDDSDA != NULL ) <br>    { <br>        lpDDSDA-&gt;Release(); <br>        lpDDSDA = NULL; <br>    } <br>    if( lpDDSDonut != NULL ) <br>    { <br>        lpDDSDonut-&gt;Release(); <br>        lpDDSDonut = NULL; <br>    } <br>    if( lpClipper != NULL ) <br>    { <br>        lpClipper-&gt;Release(); <br>        lpClipper = NULL; <br>    } <br>}  <br> <br>/* <br> * finiObjects <br> * <br> * Finish with all objects we use; release them <br> */ <br>static void finiObjects( void ) <br>{ <br>    if( lpDD != NULL ) <br>    { <br>        releaseSurfaces(); <br>        if( lpDDPal != NULL ) <br>        { <br>            lpDDPal-&gt;Release(); <br>            lpDDPal = NULL; <br>        } <br>        lpDD-&gt;Release(); <br>        lpDD = NULL; <br>    } <br> <br>    // Clean up the screen on exit <br>    RedrawWindow( NULL, NULL, NULL, RDW_INVALIDATE | RDW_ERASE | <br>                     RDW_ALLCHILDREN ); <br> <br>} /* finiObjects */ <br> <br>/* <br> * initFail <br> * <br> * This function is called if the initialization function fails <br> */ <br>BOOL initFail( HWND hWnd, LPCTSTR msg ) <br>{ <br>    finiObjects(); <br>    MessageBox( hWnd, msg, TITLE, MB_OK ); <br>    DestroyWindow( hWnd ); <br>    return FALSE; <br> <br>} /* initFail */ <br> <br>/* <br> * createSurfaces <br> * <br> * Create the front and back buffers. <br> */ <br>BOOL createSurfaces( void ) <br>{ <br>    HRESULT             ddrval; <br>    DDSURFACEDESC       ddsd; <br>     <br>    // Create the primary surface <br>    ddsd.dwSize = sizeof( ddsd ); <br>    ddsd.dwFlags = DDSD_CAPS; <br>    ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE; <br> <br>    ddrval = lpDD-&gt;CreateSurface( &amp;ddsd, &amp;lpDDSPrimary, NULL ); <br>    if( ddrval != DD_OK ) <br>        return false; <br> <br>    if(!gExclusive) <br>    { <br>        // <br>        // now create a DirectDrawClipper object. <br>        // <br>        ddrval = lpDD-&gt;CreateClipper(0, &amp;lpClipper, NULL); <br> <br>        if( ddrval == DD_OK ) <br>        { <br>            ddrval = lpClipper-&gt;SetHWnd(0, hWndMain); <br> <br>            if( ddrval == DD_OK ) <br>            { <br>                ddrval = lpDDSPrimary-&gt;SetClipper(lpClipper); <br>            } <br>        } <br>        if( ddrval != DD_OK ) <br>            return false; <br>    } <br> <br>    // <br>    // Create a DirectDrawSurface to hand to Direct Animation. <br>    // <br>    ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT |DDSD_WIDTH; <br>    ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN; <br>    ddsd.dwWidth = WINDOW_WIDTH; <br>    ddsd.dwHeight = WINDOW_HEIGHT; <br> <br>    ddrval = lpDD-&gt;CreateSurface(&amp;ddsd, &amp;lpDDSDA, NULL); <br>    if (ddrval != DD_OK) <br>        return false; <br> <br>    lpDDPal = DDLoadPalette(lpDD, szBitmap); <br>    if (lpDDPal) <br>    { <br>        lpDDSPrimary-&gt;SetPalette(lpDDPal); <br>    } <br> <br>    lpDDSDonut = DDLoadBitmap(lpDD, szBitmap, 0, 0); <br>    if( lpDDSDonut == NULL ) <br>    { <br>        return false; <br>    } <br> <br>    // set color key to black <br>    DDSetColorKey(lpDDSDonut, RGB(0,0,0)); <br>    return true; <br>} /* createSurfaces */ <br> <br>/* <br> * recreateSurfaces <br> * <br> * The screen resolution or bitdepth has changed, re-create <br> * all surfaces. <br> */ <br>BOOL recreateSurfaces( void ) <br>{ <br>    releaseSurfaces(); <br> <br>    if (createSurfaces()) <br>    { <br>        return resetDXASurfaces(lpDDSDA); <br>    } <br>    return false; <br>} /* recreateSurfaces */ <br> <br>/* <br> * restoreAll <br> * <br> * Restore all lost objects <br> */ <br>BOOL restoreAll( void ) <br>{ <br>    HRESULT     ddrval; <br> <br>    ddrval = lpDDSPrimary-&gt;Restore(); <br>    if (ddrval == DDERR_WRONGMODE) <br>    { <br>        if (recreateSurfaces()) <br>            return true; <br> <br>    } <br>    else if (ddrval == DD_OK) <br>    { <br>        ddrval = lpDDSDA-&gt;Restore(); <br>        if( ddrval == DD_OK ) <br>        { <br>            ddrval = lpDDSDonut-&gt;Restore(); <br>            if( ddrval == DD_OK ) <br>            { <br>                DDReLoadBitmap(lpDDSDonut, szBitmap); <br>                return true; <br>            } <br>        } <br>    } <br> <br>    return initFail(hWndMain, "DirectDraw: Can't Recreate Surfaces"); <br>} /* restoreAll */ <br> <br>/* <br> * updateFrame <br> *  <br> * Decide what needs to be blitted next, wait for flip to complete, <br> * then flip the buffers. <br> */ <br>void updateFrame( void ) <br>{ <br>    static DWORD        lastTickCount = 0; <br>    static int          currentFrame = 0; <br>    static BOOL         haveBackground = FALSE; <br>    DWORD               thisTickCount; <br>    DWORD               delay = 17; <br>    HRESULT             ddrval; <br> <br>    thisTickCount = GetTickCount(); <br>    if((thisTickCount - lastTickCount) &lt;= delay) <br>    { <br>        return; <br>    } <br> <br>    thisTickCount = GetTickCount(); <br>    if((thisTickCount - lastTickCount) &gt; delay) <br>    { <br>        // Move to next frame; <br>        lastTickCount = thisTickCount; <br>        currentFrame++; <br>        if(currentFrame &gt; 59) <br>        { <br>            currentFrame = 0; <br>        } <br>    } <br> <br>    // DA doesn't like lost surface.  We should restore lost surface <br>    // before asking DA to render. <br>    if (lpDDSDA &amp;&amp; lpDDSDA-&gt;IsLost() == DDERR_SURFACELOST) <br>    { <br>        // This function will destroy the window if failed.         <br>        if (!restoreAll()) <br>            return; <br>    } <br> <br>    // Ask DA to render to the DA surface the next image/sound for view1. <br>    tick(view1); <br> <br>    // The image in the DA model (defined in dxa.cpp) has a background <br>    // image, so we don't need to clear the background before we draw here. <br>    RECT  donutSrcRect; <br>    donutSrcRect.left   = currentFrame%10*64; <br>    donutSrcRect.top    = currentFrame/10*64; <br>    donutSrcRect.right  = currentFrame%10*64 + 64; <br>    donutSrcRect.bottom = currentFrame/10*64 + 64; <br> <br>    // Blt the donut to the center of the DDSDonut surface. <br>    RECT donutDestRect; <br>    donutDestRect.left   = WINDOW_WIDTH/2-32; <br>    donutDestRect.top    = WINDOW_HEIGHT/2-32; <br>    donutDestRect.right  = donutDestRect.left + 64; <br>    donutDestRect.bottom = donutDestRect.top + 64; <br> <br>    // Blit the donut for the next frame to the DA surface. <br>    while( 1 ) <br>    { <br>        ddrval = lpDDSDA-&gt;Blt(&amp;donutDestRect, lpDDSDonut, <br>            &amp;donutSrcRect, DDBLT_WAIT|DDBLT_KEYSRC, NULL); <br> <br>        if( ddrval == DD_OK ) <br>        { <br>            break; <br>        } <br>        if( ddrval == DDERR_SURFACELOST ) <br>        { <br>            ddrval = restoreAll(); <br>            if( ddrval != DD_OK ) <br>            { <br>                return; <br>            } <br>        } <br> <br>        if( ddrval != DDERR_WASSTILLDRAWING ) <br>        { <br>            return; <br>        } <br>    } <br> <br>    // Ask DA to render to the DA surface the next image/sound for view2. <br>    tick(view2); <br> <br>    // Blit from the DA surface to the screen. <br>    RECT daRect; <br>    daRect.left = 0; <br>    daRect.top = 0; <br>    daRect.right = WINDOW_WIDTH; <br>    daRect.bottom = WINDOW_HEIGHT; <br>    RECT screenRect; <br>    screenRect.left = windowRect.left; <br>    screenRect.top = windowRect.top; <br>    screenRect.right = windowRect.left + WINDOW_WIDTH; <br>    screenRect.bottom = windowRect.top + WINDOW_HEIGHT; <br>         <br>    while( 1 ) <br>    { <br>        ddrval = lpDDSPrimary-&gt;Blt(&amp;screenRect, lpDDSDA, <br>                                   &amp;daRect, DDBLT_WAIT, NULL); <br> <br>        if( ddrval == DD_OK ) <br>        { <br>            break; <br>        } <br>        if( ddrval == DDERR_SURFACELOST ) <br>        { <br>            ddrval = restoreAll(); <br>            if( ddrval != DD_OK ) <br>            { <br>                return; <br>            } <br>        } <br>        if( ddrval != DDERR_WASSTILLDRAWING ) <br>        { <br>            return; <br>        } <br>    } <br> <br>} /* updateFrame */ <br> <br>long FAR PASCAL WindowProc( HWND hWnd, UINT message,  <br>                            WPARAM wParam, LPARAM lParam ) <br>{ <br>    switch( message ) <br>    { <br>    case WM_SIZE: <br>    case WM_MOVE: <br>        if (IsIconic(hWnd)) <br>        { <br>            bPaused = true; <br>        } <br> <br>        if (!gExclusive)  <br>        { <br>            GetClientRect(hWnd, &amp;windowRect); <br>            ClientToScreen(hWnd, (LPPOINT)&amp;windowRect); <br>            ClientToScreen(hWnd, (LPPOINT)&amp;windowRect+1); <br>        } else { <br>            SetRect(&amp;windowRect, 0, 0, WINDOW_WIDTH, WINDOW_HEIGHT); <br>        } <br>        break; <br> <br>    case WM_ACTIVATEAPP: <br>        bActive = wParam &amp;&amp; GetForegroundWindow() == hWnd; <br> <br>        // Unpause when we're no longer iconic. <br>        if (bPaused &amp;&amp; bActive) <br>        { <br>            bPaused = false; <br>        } <br>        break; <br> <br>    case WM_SETCURSOR: <br>        if (gExclusive &amp;&amp; bActive) <br>        { <br>            SetCursor(NULL); <br>            return TRUE; <br>        } <br>        break; <br> <br>    case WM_PALETTECHANGED: <br>        if ((HWND)wParam == hWnd) <br>            break; <br>        // fall through to WM_QUERYNEWPALETTE <br>    case WM_QUERYNEWPALETTE: <br>        // install our palette here <br>        if (lpDDPal) <br>        { <br>            lpDDSPrimary-&gt;SetPalette(lpDDPal); <br>        } <br>        DDReLoadBitmap(lpDDSDonut, szBitmap); <br>        break; <br>         <br>    case WM_CREATE: <br>        break; <br> <br>    case WM_KEYDOWN: <br>        switch( wParam ) <br>        { <br>        case VK_ESCAPE: <br>        case VK_F12: <br>            PostMessage(hWnd,WM_CLOSE,0,0); <br>            break; <br>        } <br>        break; <br> <br>    case WM_DESTROY: <br>        finiObjects(); <br>        PostQuitMessage( 0 ); <br>        break; <br>    } <br> <br>    return DefWindowProc(hWnd, message, wParam, lParam); <br> <br>} /* WindowProc */ <br> <br>/* <br> * doInit - do work required for every instance of the application: <br> *                create the window, initialize data <br> */ <br>static BOOL doInit( HINSTANCE hInstance, int nCmdShow ) <br>{ <br>    WNDCLASS            wc; <br>    HRESULT             ddrval; <br> <br>    /* <br>     * set up and register window class <br>     */ <br>    wc.style = CS_HREDRAW | CS_VREDRAW; <br>    wc.lpfnWndProc = WindowProc; <br>    wc.cbClsExtra = 0; <br>    wc.cbWndExtra = 0; <br>    wc.hInstance = hInstance; <br>    wc.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_ICON1)); <br>    wc.hCursor = LoadCursor( NULL, IDC_ARROW ); <br>    wc.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH); <br>    wc.lpszMenuName = NAME; <br>    wc.lpszClassName = NAME; <br>    RegisterClass( &amp;wc ); <br>     <br>    /* <br>     * create a window <br>     */ <br>    DWORD wndStyle = WS_OVERLAPPEDWINDOW; <br>    if( gExclusive) <br>        wndStyle = WS_POPUP; <br> <br>    hWndMain = CreateWindowEx( <br>        WS_EX_APPWINDOW, <br>        NAME, <br>        TITLE, <br>        wndStyle, <br>        0, <br>        0, <br>        WINDOW_WIDTH, <br>        WINDOW_HEIGHT, <br>        NULL, <br>        NULL, <br>        hInstance, <br>        NULL ); <br> <br>    if( !hWndMain ) <br>    { <br>        return FALSE; <br>    } <br> <br>    ShowWindow( hWndMain, nCmdShow ); <br>    UpdateWindow( hWndMain ); <br> <br>    /* <br>     * create the main DirectDraw object <br>     */ <br>     <br>    ddrval = CoCreateInstance(CLSID_DirectDrawFactory, <br>                              NULL, CLSCTX_INPROC_SERVER, <br>                              IID_IDirectDrawFactory, <br>                              (void **) &amp; lpDDF); <br> <br>    char strDDFailed[] = "DirectDraw Init Failed"; <br>    if( ddrval != DD_OK ) <br>    { <br>        return initFail(hWndMain, strDDFailed); <br>    } <br> <br>    ddrval = lpDDF-&gt;CreateDirectDraw(NULL, hWndMain, DDSCL_NORMAL, 0, NULL, &amp;lpDD); <br>    if( ddrval != DD_OK ) <br>    { <br>        return initFail(hWndMain, strDDFailed); <br>    } <br> <br>    // Get exclusive mode if requested <br>    if(gExclusive) <br>    { <br>        ddrval = lpDD-&gt;SetCooperativeLevel( hWndMain, DDSCL_EXCLUSIVE | DDSCL_FULLSCREEN ); <br>    } <br>    else <br>    { <br>        ddrval = lpDD-&gt;SetCooperativeLevel( hWndMain, DDSCL_NORMAL ); <br>    } <br>    if( ddrval != DD_OK ) <br>    { <br>        return initFail(hWndMain, strDDFailed); <br>    } <br> <br>    if (!createSurfaces()) <br>    { <br>        return initFail(hWndMain, strDDFailed); <br>    } <br> <br>    // Create a DAView object and construct the model. <br>    if (!initDXAViewObj(lpDDSDA)) <br>    { <br>        return initFail(hWndMain, "DirectX Animation Init FAILED"); <br>    } <br> <br>    return TRUE; <br>} /* doInit */ <br> <br>/* <br> * WinMain - initialization, message loop <br> */ <br>int PASCAL WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, <br>                        LPSTR lpCmdLine, int nCmdShow) <br>{ <br>    MSG         msg; <br>    LPSTR       c; <br> <br>    for(c=lpCmdLine; *c != '\0'; c++) <br>    { <br>        switch( *c ) <br>        { <br>            case 'X': gExclusive = TRUE; break; <br>        } <br>    } <br>     <br>    if( !doInit( hInstance, nCmdShow ) ) <br>    { <br>        return FALSE; <br>    } <br> <br>    while( 1 ) <br>    { <br>        if( PeekMessage( &amp;msg, NULL, 0, 0, PM_NOREMOVE ) ) <br>        { <br>            if( !GetMessage( &amp;msg, NULL, 0, 0 ) ) <br>                return msg.wParam; <br>            TranslateMessage(&amp;msg);  <br>            DispatchMessage(&amp;msg); <br>        } <br>        else if (!bPaused &amp;&amp; (bActive || !gExclusive)) <br>        { <br>            updateFrame(); <br>        } <br>        else <br>        { <br>            WaitMessage(); <br>        } <br>    } <br>} /* WinMain */ </code></pre>
<p>&nbsp;</p></body>
</HTML>
