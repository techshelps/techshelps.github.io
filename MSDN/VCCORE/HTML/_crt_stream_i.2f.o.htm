<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Stream I/O</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_crt_stream_i.2f.o"></A><SUP></SUP>Stream I/O</H1>

<P>These functions process data in different sizes and formats, from single characters to large data structures. They also provide buffering, which can improve performance. The default size of a stream buffer is 4K. These routines affect only buffers created by the run-time library routines, and have no effect on buffers created by the operating system.</P>

<P class=label><B>Stream I/O Routines</B></P>

<TABLE border=1 cellpadding=5 cols=2 frame=below rules=rows>

<TR VALIGN="top">
<TD class=label width=20%><B>Routine</B></TD>
<TD class=label width=80%><B>Use</B></TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt_clearerr.htm">clearerr</A></TD>
<TD width=80%>Clear error indicator for stream</TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt_fclose.2c_._fcloseall.htm">fclose</A></TD>
<TD width=80%>Close stream</TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt_fclose.2c_._fcloseall.htm">_fcloseall</A></TD>
<TD width=80%>Close all open streams except <B>stdin</B>, <B>stdout</B>, and <B>stderr</B></TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt__fdopen.2c_._wfdopen.htm">_fdopen, wfdopen</A></TD>
<TD width=80%>Associate stream with handle to open file</TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt_feof.htm">feof</A></TD>
<TD width=80%>Test for end of file on stream</TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt_ferror.htm">ferror</A></TD>
<TD width=80%>Test for error on stream</TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt_fflush.htm">fflush</A></TD>
<TD width=80%>Flush stream to buffer or storage device </TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt_fgetc.2c_.fgetwc.2c_._fgetchar.2c_._fgetwchar.htm">fgetc, fgetwc</A></TD>
<TD width=80%>Read character from stream (function versions of <B>getc</B> and <B>getwc</B>)</TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt_fgetc.2c_.fgetwc.2c_._fgetchar.2c_._fgetwchar.htm">_fgetchar, _fgetwchar</A></TD>
<TD width=80%>Read character from <B>stdin</B> (function versions of <B>getchar</B> and <B>getwchar</B>)</TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt_fgetpos.htm">fgetpos</A></TD>
<TD width=80%>Get position indicator of stream</TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt_fgets.2c_.fgetws.htm">fgets, fgetws</A></TD>
<TD width=80%>Read string from stream</TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt__fileno.htm">_fileno</A></TD>
<TD width=80%>Get file handle associated with stream</TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt__flushall.htm">_flushall</A></TD>
<TD width=80%>Flush all streams to buffer or storage device</TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt_fopen.2c_._wfopen.htm">fopen, _wfopen</A></TD>
<TD width=80%>Open stream</TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt_fprintf.2c_.fwprintf.htm">fprintf, fwprintf</A></TD>
<TD width=80%>Write formatted data to stream</TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt_fputc.2c_.fputwc.2c_._fputchar.2c_._fputwchar.htm">fputc, fputwc</A></TD>
<TD width=80%>Write a character to a stream (function versions of <B>putc</B> and <B>putwc</B>)</TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt_fputc.2c_.fputwc.2c_._fputchar.2c_._fputwchar.htm">_fputchar, _fputwchar</A></TD>
<TD width=80%>Write character to <B>stdout</B> (function versions of <B>putchar</B> and <B>putwchar</B>)</TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt_fputs.2c_.fputws.htm">fputs, fputws</A></TD>
<TD width=80%>Write string to stream</TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt_fread.htm">fread</A></TD>
<TD width=80%>Read unformatted data from stream</TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt_freopen.2c_._wfreopen.htm">freopen, _wfreopen</A></TD>
<TD width=80%>Reassign <B>FILE</B> stream pointer to new file or device</TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt_fscanf.2c_.fwscanf.htm">fscanf, fwscanf</A></TD>
<TD width=80%>Read formatted data from stream</TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt_fseek.htm">fseek</A></TD>
<TD width=80%>Move file position to given location</TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt_fsetpos.htm">fsetpos</A></TD>
<TD width=80%>Set position indicator of stream</TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt__fsopen.2c_._wfsopen.htm">_fsopen, _wfsopen</A></TD>
<TD width=80%>Open stream with file sharing</TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt_ftell.htm">ftell</A></TD>
<TD width=80%>Get current file position</TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt_fwrite.htm">fwrite</A></TD>
<TD width=80%>Write unformatted data items to stream</TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt_getc.2c_.getwc.2c_.getchar.2c_.getwchar.htm">getc, getwc</A></TD>
<TD width=80%>Read character from stream (macro versions of <B>fgetc</B> and <B>fgetwc</B>)</TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt_getc.2c_.getwc.2c_.getchar.2c_.getwchar.htm">getchar, getwchar</A></TD>
<TD width=80%>Read character from <B>stdin</B> (macro versions of <B>fgetchar</B> and <B>fgetwchar</B>)</TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt_gets.2c_.getws.htm">gets, getws</A></TD>
<TD width=80%>Read line from <B>stdin</B></TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt__getw.htm">_getw</A></TD>
<TD width=80%>Read binary <B>int</B> from stream</TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt_printf.2c_.wprintf.htm">printf, wprintf</A></TD>
<TD width=80%>Write formatted data to <B>stdout</B></TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt_putc.2c_.putwc.2c_.putchar.2c_.putwchar.htm">putc, putwc</A></TD>
<TD width=80%>Write character to a stream (macro versions of <B>fputc</B> and <B>fputwc</B>)</TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt_putc.2c_.putwc.2c_.putchar.2c_.putwchar.htm">putchar, putwchar</A></TD>
<TD width=80%>Write character to <B>stdout</B> (macro versions of <B>fputchar</B> and <B>fputwchar</B>)</TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt_puts.2c_._putws.htm">puts, _putws</A></TD>
<TD width=80%>Write line to stream</TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt__putw.htm">_putw</A></TD>
<TD width=80%>Write binary <B>int</B> to stream</TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt_rewind.htm">rewind</A></TD>
<TD width=80%>Move file position to beginning of stream</TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt__rmtmp.htm">_rmtmp</A></TD>
<TD width=80%>Remove temporary files created by <B>tmpfile</B></TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt_scanf.2c_.wscanf.htm">scanf, wscanf</A></TD>
<TD width=80%>Read formatted data from <B>stdin</B></TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt_setbuf.htm">setbuf</A></TD>
<TD width=80%>Control stream buffering</TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt__setmaxstdio.htm">_setmaxstdio</A></TD>
<TD width=80%>Set a maximum for the number of simultaneously open files at the stream I/O level. </TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt_setvbuf.htm">setvbuf</A></TD>
<TD width=80%>Control stream buffering and buffer size</TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt__snprintf.2c_._snwprintf.htm">_snprintf, _snwprintf</A></TD>
<TD width=80%>Write formatted data of specified length to string</TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt_sprintf.2c_.swprintf.htm">sprintf, swprintf</A></TD>
<TD width=80%>Write formatted data to string</TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt_sscanf.2c_.swscanf.htm">sscanf, swscanf</A></TD>
<TD width=80%>Read formatted data from string</TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt__tempnam.2c_._wtempnam.2c_.tmpnam.2c_._wtmpnam.htm">_tempnam, _wtempnam</A></TD>
<TD width=80%>Generate temporary filename in given directory</TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt_tmpfile.htm">tmpfile</A></TD>
<TD width=80%>Create temporary file</TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt__tempnam.2c_._wtempnam.2c_.tmpnam.2c_._wtmpnam.htm">tmpnam, _wtmpnam</A></TD>
<TD width=80%>Generate temporary filename</TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt_ungetc.2c_.ungetwc.htm">ungetc, ungetwc</A></TD>
<TD width=80%>Push character back onto stream</TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt_vfprintf.2c_.vfwprintf.htm">vfprintf, vfwprintf</A> </TD>
<TD width=80%>Write formatted data to stream</TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt_vprintf.2c_.vwprintf.htm">vprintf, vwprintf</A></TD>
<TD width=80%>Write formatted data to <B>stdout</B></TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt__vsnprintf.2c_._vsnwprintf.htm">_vsnprintf, _vsnwprintf</A></TD>
<TD width=80%>Write formatted data of specified length to buffer</TD>
</TR>

<TR VALIGN="top">
<TD width=20%><A HREF="_crt_vsprintf.2c_.vswprintf.htm">vsprintf, vswprintf</A></TD>
<TD width=80%>Write formatted data to buffer</TD>
</TR>
</TABLE><BR>

<P>When a program begins execution, the startup code automatically opens several streams: standard input (pointed to by <B>stdin</B>), standard output (pointed to by <B>stdout</B>), and standard error (pointed to by <B>stderr</B>). These streams are directed to the console (keyboard and screen) by default. Use <B>freopen</B> to redirect <B>stdin</B>, <B>stdout</B>, or <B>stderr</B> to a disk file or a device.</P>

<P>Files opened using the stream routines are buffered by default. The <B>stdout</B> and <B>stderr</B> functions are flushed whenever they are full or, if you are writing to a character device, after each library call. If a program terminates abnormally, output buffers may not be flushed, resulting in loss of data. Use <B>fflush</B> or <B>_flushall</B> to ensure that the buffer associated with a specified file or all open buffers are flushed to the operating system, which can cache data before writing it to disk. The commit-to-disk feature ensures that the flushed buffer contents are not lost in the event of a system failure. </P>

<P>There are two ways to commit buffer contents to disk:

<UL type=disc>
	<LI>Link with the file COMMODE.OBJ to set a global commit flag. The default setting of the global flag is <B>n</B>, for “no-commit.”<BR><BR></LI>

	<LI>Set the mode flag to <B>c</B> with <B>fopen</B> or <B>_fdopen</B>.</LI>
</UL>

<P>Any file specifically opened with either the <B>c</B> or the <B>n</B> flag behaves according to the flag, regardless of the state of the global commit/no-commit flag.</P>

<P>If your program does not explicitly close a stream, the stream is automatically closed when the program terminates. However, you should close a stream when your program finishes with it, as the number of streams that can be open at one time is limited. See <A HREF="_crt__setmaxstdio.htm">_setmaxstdio</A> for information on this limit. </P>

<P>Input can follow output directly only with an intervening call to <B>fflush</B> or to a file-positioning function (<B>fseek</B>, <B>fsetpos</B>, or <B>rewind</B>). Output can follow input without an intervening call to a file-positioning function if the input operation encounters the end of the file.</P>
</font>
</BODY>
</HTML>
