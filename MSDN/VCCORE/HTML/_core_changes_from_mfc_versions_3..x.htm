<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Changes from MFC Versions 3.x</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>

<TABLE ALIGN=right WIDTH=0 BORDER=0><TR><TD>
<OBJECT ID="hhobj_1" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_mfcnotes_TN001">
</OBJECT>
<OBJECT ID="hhobj_2" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_mfc_CWinApp.3a3a.GetFirstDocTemplatePosition">
</OBJECT>
<OBJECT ID="hhobj_3" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_mfc_CWinApp.3a3a.GetNextDocTemplate">
</OBJECT>
<OBJECT ID="hhobj_4" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_mfc_CPropertySheet.3a3a.DoModal">
</OBJECT>
<OBJECT ID="hhobj_5" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_mfcnotes_TN058">
</OBJECT>
<OBJECT ID="hhobj_6" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_mfcnotes_TN059">
</OBJECT>
</TD></TR></TABLE>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_core_changes_from_mfc_versions_3..x"></A>Changes from MFC Versions 3.x</H1>

<P>This article describes the most common problems that can occur when porting an application written with MFC 3.x (the MFC included with Visual C++ 2.x) to MFC 4.x. The following porting issues are discussed:

<UL type=disc>
	<LI><A HREF="#_core_window_classes_are_no_longer_pre.2d.registered_by_mfc">Window classes are no longer pre-registered by MFC</A>.<BR><BR></LI>

	<LI><A HREF="#_core_cwinapp.3a3a.m_templatelist_no_longer_exists">CWinApp::m_templateList no longer exists</A>.<BR><BR></LI>

	<LI><A HREF="#_core_cruntimeclass.3a3a.m_pfnconstruct_is_now_m_pfncreateobject">CRuntimeClass::m_pfnConstruct is now m_pfnCreateObject</A>.<BR><BR></LI>

	<LI><A HREF="#_core_changes_in_cstatusbar_and_ctoolbar_implementation_can_break_previous_code">Changes in CStatusBar and CToolBar implementation can break previous code</A>.<BR><BR></LI>

	<LI><A HREF="#_core_changes_in_cpropertysheet_implementation_can_break_previous_code">Changes in CPropertySheet implementation can break previous code</A>.<BR><BR></LI>

	<LI><A HREF="#_core_cpropertysheet_always_changes_its_font_to_the_default_font">CPropertySheet always changes its font to the default font</A>.<BR><BR></LI>

	<LI><A HREF="#_core_do_property_sheet_modifications_in_oninitdialog_after_a_call_to_the_base_class">Do property sheet modifications in OnInitDialog after a call to the base class</A>.<BR><BR></LI>

	<LI><A HREF="#_core_cpropertysheet.3a3a.domodal_causes_a_first_chance_exception_on_windows_95">CPropertySheet::DoModal causes a first chance exception on Windows 95</A> (the exception can be ignored).<BR><BR></LI>

	<LI><A HREF="#_core_property_sheets_now_have_a_minimum_width">Property sheets now have a minimum width</A>.<BR><BR></LI>

	<LI><A HREF="#_core_ctoolbar_requires_a_minimum_button_size">CToolBar requires a minimum button size</A>.<BR><BR></LI>

	<LI><A HREF="#_core_do_not_replace_cfiledialog.27.s_default_hook_procedure">Do not replace CFileDialog's default hook procedure</A>.<BR><BR></LI>

	<LI><A HREF="#_core_altering_cfiledialog.27.s_standard_explorer_interface_requires_a_call_to_getparent">Altering CFileDialog's standard Explorer interface requires a call to GetParent</A>.<BR><BR></LI>

	<LI><A HREF="#_core_cfiledialog_member_functions_getfilename_and_getfiletitle_are_functionally_reversed">CFileDialog member functions GetFileName and GetFileTitle are functionally reversed</A>.<BR><BR></LI>

	<LI><A HREF="#_core_mfc_threads_cannot_be_created_during_dll_startup">MFC threads cannot be created during DLL startup</A>.<BR><BR></LI>

	<LI><A HREF="#_core_regular_dlls_using_the_mfc_shared_library_require_afx_manage_state_in_exported_functions">Regular DLLs using the MFC shared library require AFX_MANAGE_STATE in exported functions</A>.<BR><BR></LI>

	<LI><A HREF="#_core_mfcans32..dll_no_longer_exists.3a_.ole_functions_in_mfc_applications_now_require_unicode_arguments">MFCANS32.DLL no longer exists: OLE functions in MFC applications now require Unicode arguments</A>.</LI>
</UL>

<P>Knowledge Base articles referenced in this article are available by connecting to http://www.microsoft.com/kb/. Choose Visual C++ in the <B>Choose a Microsoft product or technology</B> drop-down list. Enter the article number in the <B>Enter a Search Phrase</B> text box, then click <B>Begin Search</B>.</P>

<H2><A NAME="_core_window_classes_are_no_longer_pre.2d.registered_by_mfc"></A>Window Classes Are No Longer Pre-Registered by MFC</H2>

<P>Before MFC version 4.0, MFC pre-registered four window classes, as documented in MFC <A HREF="JavaScript:hhobj_1.Click()">Technical Note 1</A>. These <B>WNDCLASS</B>es were <B>AfxWnd</B>, <B>AfxFrameOrView</B>, <B>AfxMDIFrame</B>, and <B>AfxControlBar</B>. </P>

<P>Most code that prevented more than one instance of an application relied on these classes, but, as of version 4.0, the classes are not registered until a window of that type is created. </P>

<P>Custom <B>WNDCLASS</B>-based windows that rely on <B>::GetClassInfo</B> to retrieve class information from the MFC window classes will likely fail to be displayed and will send the message that Window creation failed and <B>GetLastError</B> returned the value 0x57F (ERROR_WNDCLASS_DOES_NOT_EXIST). The message is sent to the debug output window if MFC tracing is turned on. The error message corresponding to this error is "Cannot find window class". </P>

<P>To prevent this situation, provide all of the necessary information when registering custom window classes with <B>RegisterClass</B> or <B>AfxRegisterClass</B> and do not rely on <B>::GetClassInfo</B> to retrieve class values for MFC window classes.</P>

<P>For more information, see the Knowledge Base article Q140596 and the Knowledge Base sample Q141752.</P>

<H2><A NAME="_core_cwinapp.3a3a.m_templatelist_no_longer_exists"></A>CWinApp::m_templateList No Longer Exists</H2>

<P>The <B>m_templateList</B> member variable of <B>CWinApp</B> was undocumented in MFC 3.x, but was used commonly enough to create porting problems. The recommended way to access the templates for an application is to use the <A HREF="JavaScript:hhobj_2.Click()">GetFirstDocTemplatePosition</A> and <A HREF="JavaScript:hhobj_3.Click()">GetNextDocTemplate</A> member functions of <B>CWinApp</B>.</P>

<P>For more information, see the Knowledge Base article Q106455.</P>

<H2><A NAME="_core_cruntimeclass.3a3a.m_pfnconstruct_is_now_m_pfncreateobject"></A>CRuntimeClass::m_pfnConstruct Is Now m_pfnCreateObject</H2>

<P>The member variable <B>m_pfnConstruct</B> was a documented member of <B>CRuntimeClass</B> in MFC versions prior to 4.0, but the name was changed to <B>m_pfnCreateObject</B> to reflect a change in parameters and return value. The documentation included with Visual C++ 4.0 was not updated to reflect this change and incorrectly references the old member variable name.The documentation for Visual C++ 4.1 and later, however, is up to date. </P>

<H2><A NAME="_core_changes_in_cstatusbar_and_ctoolbar_implementation_can_break_previous_code"></A>Changes in CStatusBar and CToolBar Implementation Can Break Previous Code</H2>

<P><B>CStatusBar</B> and <B>CToolBar</B> now wrap the functionality of the Win32 common controls. Any code that relied on or modified the private, undocumented implementation of these classes will likely break when compiled for MFC 4.0. These two common controls support a greater range of common customizations than the previous default MFC implementation and do not require significant overrides of the MFC source for such tasks as constructing palette bars or making resizable toolbars. If needed, the old implementation of these two classes is still available as the <B>COldStatusBar</B> and <B>COldToolBar</B> classes.</P>

<H2><A NAME="_core_changes_in_cpropertysheet_implementation_can_break_previous_code"></A>Changes in CPropertySheet Implementation Can Break Previous Code</H2>

<P>Much of the MFC implementation of <B>CPropertySheet</B> has now changed to wrap the Windows Property Sheet common control. There have been formatting and sizing changes. More importantly, if previous code used any of the private MFC implementation of <B>CPropertySheet</B>, it will likely break since most of the undocumented members of that class are no longer there. </P>

<H2><A NAME="_core_cpropertysheet_always_changes_its_font_to_the_default_font"></A>CPropertySheet Always Changes Its Font to the Default Font</H2>

<P><B>CPropertySheet</B> now always changes its font to the default font. Even if the font of the property pages is changed in the resource editor, property pages will be displayed at run-time with the system font. If it is necessary to change the font, call <B>SetFont</B> in <B>OnInitDialog</B> and then do an appropriate <B>MoveWindow</B> to resize the sheet and move and resize all controls on the page. Also, the property sheet is set back to its original size whenever a page is activated, so it is necessary to resize the page in response to a click on the tab control. For more information, see the Knowledge Base article Q142170.</P>

<H2><A NAME="_core_do_property_sheet_modifications_in_oninitdialog_after_a_call_to_the_base_class"></A>Do Property Sheet Modifications in OnInitDialog After a Call to the Base Class</H2>

<P>Property sheet modifications should be done in <B>OnInitDialog</B> after a call to the base class. During <B>CPropertySheet::OnInitDialog</B>, the property sheet is resized and the four standard buttons (OK, Cancel, Apply, and Help) are hidden at the bottom of modeless property sheets. The proper place to modify the size of the sheet or to customize the four property sheet buttons is in <B>OnInitDialog</B> after the call to the base class. It was common in previous versions of MFC to hide some of the buttons shown with a modal property sheet in <B>OnCreate</B>. These buttons can now be removed easily by modifying styles in the <B>PROPSHEETHEADER</B> structure <B>CPropertySheet::m_psh</B>. For more information, see the Knowledge Base articles Q140585 and Q141039.</P>

<H2><A NAME="_core_cpropertysheet.3a3a.domodal_causes_a_first_chance_exception_on_windows_95"></A>CPropertySheet::DoModal Causes a First Chance Exception on Windows 95</H2>

<P><B>CPropertySheet::DoModal</B> causes a first chance exception on Windows 95 because the property page sets required styles in the dialog resource. The operating system needs to handle this and the message can be ignored. If you surround the <B>DoModal</B> call with a <B>try/catch</B>(...) block in an effort to handle the exception yourself, you will get a stack fault. For more information, see <A HREF="JavaScript:hhobj_4.Click()">DoModal</A>.</P>

<H2><A NAME="_core_property_sheets_now_have_a_minimum_width"></A>Property Sheets Now Have a Minimum Width</H2>

<P>The minimum width of a <B>CPropertySheet</B> window is the size of the four buttons (OK, Cancel, Apply, and Help) that would show up along the bottom of a modal property sheet. This width applies even to modeless property sheets, which do not show the four buttons along the bottom.</P>

<H2><A NAME="_core_ctoolbar_requires_a_minimum_button_size"></A>CToolBar Requires a Minimum Button Size</H2>

<P>Toolbars now require that the width of the button size be at least 7 pixels greater than the image size. The documentation that ships with Visual C++ 4.0 was not updated to reflect this change and is incorrect. The <B>ASSERT</B> that MFC version 4.0 uses to verify correct parameters in <B>SetSizes</B> also incorrectly checks for the old value of 6. There are other limits on the sizes of the toolbar, buttons, and images, but these are correctly covered by <B>ASSERT</B> statements in the MFC source and have not changed since MFC 3.x. For more information, see the Knowledge Base article Q141444.</P>

<H2><A NAME="_core_do_not_replace_cfiledialog.27.s_default_hook_procedure"></A>Do Not Replace CFileDialog's Default Hook Procedure</H2>

<P>MFC always specifies its own hook procedure, <B>_AfxCommDlgProc</B>, for the Open File Dialog during the construction of the <B>CFileDialog</B> object so that it can route notifications for the dialog to the proper handlers. As of MFC 4.x, this hook procedure is used to subclass the <B>CFileDialog</B> object to the Open File Dialog window. If the hook procedure is replaced, subclassing will not happen and any attempt to use the <B>CFileDialog</B> (or an embedded control variable on it) as a window will fail.</P>

<H2><A NAME="_core_altering_cfiledialog.27.s_standard_explorer_interface_requires_a_call_to_getparent"></A>Altering CFileDialog's Standard Explorer Interface Requires a Call to GetParent</H2>

<P>When you use the Windows Explorer-style <B>CFileDialog</B> (the default on Windows 95), MFC 4.x assumes the Windows Explorer model of customization. This implies that custom improvements to the File dialog are included on a separate template that is added around the standard Windows Explorer dialog. </P>

<P>In MFC 4.x, the actual <B>CFileDialog</B> window is a child dialog of the main File Common Dialog, even if you are not providing a template to customize the dialog. Therefore, if you have a need to alter the standard Windows Explorer interface by moving or hiding controls, prefix all <B>GetDlgItem</B> calls to Windows Explorer controls with <B>GetParent</B>. For example, <CODE>GetParent()-&gt;GetDlgItem(IDOK)</CODE> will return a pointer to the Open/Save button on the Windows Explorer dialog. However, this is not recommended because code which relies on the details of the standard Windows Explorer dialog controls will break if the Windows Explorer layout is changed in the future.</P>

<H2><A NAME="_core_cfiledialog_member_functions_getfilename_and_getfiletitle_are_functionally_reversed"></A>CFileDialog Member Functions GetFileName and GetFileTitle Are Functionally Reversed</H2>

<P>MFC 4.0 implementation of <B>CFileDialog</B> member functions <B>GetFileName</B> and <B>GetFileTitle</B> is reversed from previous versions of MFC. For example, in MFC 4.0, given the file "C:\ARTICLE.TXT", <B>CFileDialog::GetFileName</B> returns "ARTICLE.TXT" and <B>CFileDialog::GetFileTitle</B> returns "ARTICLE". Previous versions of MFC returned exactly the opposite. The functions have been changed to work like the Win32 API functions of the same names. However, the documentation included with Visual C++ 4.0 was not updated to reflect these changes. The documentation for Visual C++ 4.1, however, is up to date. </P>

<H2><A NAME="_core_mfc_threads_cannot_be_created_during_dll_startup"></A>MFC Threads Cannot Be Created During DLL Startup</H2>

<P>In previous versions of MFC, it was possible to create a thread during the startup of an MFC DLL. This required calling <B>AfxBeginThread</B> or <B>CWinThread::CreateThread</B> in DllMain, in RawDllMain, in <CODE>InitInstance</CODE> in the DLL, or in any functions called by these. Due to synchronization of MFC thread startup code and blocking at DllMain during <B>DLL_PROCESS_ATTACH</B> and <B>DLL_THREAD_ATTACH</B>, this is no longer permitted. MFC 4.0 DLLs that attempt to do this will hang when loaded by an application. For more information, see the Knowledge Base article Q142243.</P>



<H2><A NAME="_core_regular_dlls_using_the_mfc_shared_library_require_afx_manage_state_in_exported_functions"></A>Regular DLLs Using the MFC Shared Library Require AFX_MANAGE_STATE in Exported Functions</H2>

<P>Previously, the USRDLL model required that MFC be statically linked to the DLL. It is now possible to link dynamically to the MFC40.DLL from a Regular DLL, the new term for _USRDLLs. However, to convert a _USRDLL to a Regular DLL using MFC in a shared library, you need to make sure that you manage your module state information correctly. The single line:</P>

<PRE><CODE>AFX_MANAGE_STATE(AfxGetStaticModuleState());
</CODE></PRE>

<P>should be added to the beginning of any function exported from the DLL which operates on MFC objects. If the module state is not switched appropriately, it could cause the following problems: dialogs and windows fail at creation in a DLL because of missing resources, functions for the wrong application object get called and cause stack overflow or unpredictable results, unrecognized run-time class information, bad window to MFC object handle map linkage, and more. For more information, see the Knowledge Base article Q140850 and MFC <A HREF="JavaScript:hhobj_5.Click()">Technical Note 58</A>. </P>



<H2><A NAME="_core_mfcans32..dll_no_longer_exists.3a_.ole_functions_in_mfc_applications_now_require_unicode_arguments"></A>MFCANS32.DLL No Longer Exists: OLE Functions in MFC Applications Now Require Unicode Arguments</H2>

<P>In MFC 3.x, a special DLL was used (MFCANS32.DLL) to automatically convert between Unicode and MBCS when OLE interfaces were called. MFC 4.x does not use this DLL and instead talks directly to the Unicode OLE interfaces. To handle this change, MFC applications now must pass the correct type of parameters — whether Unicode or MBCS — to OLE functions. MFC 4.0 has provided a number of macros that makes this task easier. For more information, see MFC <A HREF="JavaScript:hhobj_6.Click()">Technical Note 59</A>. </P>
</font>
</BODY>
</HTML>
