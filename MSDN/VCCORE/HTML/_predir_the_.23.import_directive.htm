<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The #import Directive</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>

<TABLE ALIGN=right WIDTH=0 BORDER=0><TR><TD>
<OBJECT ID="hhobj_1" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_oa96_TYPEKIND">
</OBJECT>
</TD></TR></TABLE>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_predir_the_.23.import_directive"></A>The #import Directive</H1>

<P><B>C++ Specific </B></P>

<P>The <B>#import</B> directive is used to incorporate information from a type library. The content of the type library is converted into C++ classes, mostly describing the COM interfaces.</P>

<P class=label><B>Syntax</B></P>

<P><B>#import</B>  <B>"</B><I>filename</I><B>" [</B><I>attributes</I><B>]</B></P>

<P><B>#import</B>  <B>&lt;</B><I>filename</I><B>&gt; [</B><I>attributes</I><B>]</B></P>

<P class=dt><I>attributes:</I></P>

<P class=indent><I>attribute1, attribute2, ...</I></P>

<P class=indent><I>attribute1 attribute2 ...</I></P>

<P><I>filename</I> is the name of the file containing the type library information. A file can be one of the following types:

<UL type=disc>
	<LI>a type library (.TLB or .ODL) file<BR><BR></LI>

	<LI>an executable (.EXE) file<BR><BR></LI>

	<LI>a library (.DLL) file containing a type library resource (such as .OCX)<BR><BR></LI>

	<LI>a compound document holding a type library<BR><BR></LI>

	<LI>any other file format that can be understood by the <B>LoadTypeLib</B> API</LI>
</UL>

<P>The <I>filename</I> is optionally preceded by a directory specification. The filename must name an existing file. The difference between the two forms is the order in which the preprocessor searches for the type library files when the path is incompletely specified.</P>

<TABLE border=1 cellpadding=5 cols=2 frame=below rules=rows>

<TR VALIGN="top">
<TD class=label width=28%><B>Syntax Form</B></TD>
<TD class=label width=72%><B>Action</B></TD>
</TR>

<TR VALIGN="top">
<TD width=28%>Quoted form</TD>
<TD width=72%>This form instructs the preprocessor to first look for type library files in the same directory of the file that contains the <B>#import</B> statement, and then in the directories of whatever files that include (<B>#include</B>) that file. The preprocessor then searches along the paths shown below.</TD>
</TR>

<TR VALIGN="top">
<TD width=28%>Angle-bracket form</TD>
<TD width=72%>This form instructs the preprocessor to search for type library files along the paths shown below.</TD>
</TR>
</TABLE><BR>

<P>The compiler will search in the following directories for the named file:

<OL>
	<LI>the <B>PATH</B> environment variable path list<BR><BR></LI>

	<LI>the <B>LIB</B> environment variable path list<BR><BR></LI>

	<LI>the path specified by the /I (additional include directories) compiler option</LI>
</OL>

<P><B>#import</B> can optionally include one or more attributes. These attributes tell the compiler to modify the contents of the type-library headers. A backslash (<B>\</B>) symbol can be used to include additional lines in a single <B>#import</B> statement. For example:</P>

<PRE><CODE>#import “test.lib” no_namespace \
   rename(“OldName”, “NewName”)
</CODE></PRE>

<P>The <B>#import</B> attributes are listed below:</P>

<TABLE border=1 cellpadding=5 cols=2 frame=below rules=rows>

<TR VALIGN="top">
<TD width=51%><A HREF="#_predir_exclude">exclude</A></TD>
<TD width=49%><A HREF="#_predir_high_method_prefix">high_method_prefix</A></TD>
</TR>

<TR VALIGN="top">
<TD width=51%><A HREF="#_predir_high_property_prefixes">high_property_prefixes</A></TD>
<TD width=49%><A HREF="#_predir_implementation_only">implementation_only</A></TD>
</TR>

<TR VALIGN="top">
<TD width=51%><A HREF="#vcreftheinclude(...)attribute">include(…)</A></TD>
<TD width=49%><A HREF="#_predir_inject_statement">inject_statement</A></TD>
</TR>

<TR VALIGN="top">
<TD width=51%><A HREF="#_predir_named_guids">named_guids</A></TD>
<TD width=49%><A HREF="#vcreftheno_auto_excludeattribute">no_auto_exclude</A></TD>
</TR>

<TR VALIGN="top">
<TD width=51%><A HREF="#_predir_no_implementation">no_implementation</A></TD>
<TD width=49%><A HREF="#_predir_no_namespace">no_namespace</A></TD>
</TR>

<TR VALIGN="top">
<TD width=51%><A HREF="#_predir_raw_dispinterfaces">raw_dispinterfaces</A></TD>
<TD width=49%><A HREF="#_predir_raw_interfaces_only">raw_interfaces_only</A></TD>
</TR>

<TR VALIGN="top">
<TD width=51%><A HREF="#_predir_raw_method_prefix">raw_method_prefix</A></TD>
<TD width=49%><A HREF="#_predir_raw_native_types">raw_native_types</A></TD>
</TR>

<TR VALIGN="top">
<TD width=51%><A HREF="#_predir_raw_property_prefixes">raw_property_prefixes</A></TD>
<TD width=49%><A HREF="#_predir_rename">rename</A></TD>
</TR>

<TR VALIGN="top">
<TD width=51%><A HREF="#_predir_rename_namespace">rename_namespace</A></TD>
<TD width=49%>&nbsp;</TD>
</TR>
</TABLE><BR>

<P><B>#import</B> creates two header files that reconstruct the type library contents in C++ source code. The primary header file is similar to that produced by the Microsoft Interface Definition Language (MIDL) compiler, but with additional compiler-generated code and data. The <A HREF="#_predir_the_primary_type_library_header_file">primary header file</A> has the same base name as the type library, plus a .TLH extension. The secondary header file has the same base name as the type library, with a .TLI extension. It contains the implementations for compiler-generated member functions, and is included (<B>#include</B>) in the primary header file. </P>

<P>Both header files are placed in the output directory specified by the /Fo (name object file) option. They are then read and compiled by the compiler as if the primary header file was named by a <B>#include</B> directive.</P>

<P>The following compiler optimizations come with the <B>#import</B> directive:

<UL type=disc>
	<LI>The header file, when created, is given the same timestamp as the type library. <BR><BR></LI>

	<LI>When <B>#import</B> is processed, the compiler first checks if the header exists and is up to date. If yes, then it does not need to be recreated.<BR><BR></LI>

	<LI>The compiler delays initializing the OLE subsystem until the first <B>#import</B> command is encountered.</LI>
</UL>

<P>The <B>#import</B> directive also participates in minimal rebuild and can be placed in a precompiled header file. See <A HREF="_core_creating_precompiled_header_files.htm">Creating Precompiled Header Files</A> for more information.</P>



<H2><A NAME="_predir_the_primary_type_library_header_file"></A>The Primary Type Library Header File</H2>

<P>The primary type library header file consists of seven sections:

<OL>
	<LI>Heading boilerplate:&nbsp;&nbsp;&nbsp;Consists of comments, <B>#include</B> statement for COMDEF.H (which defines some standard macros used in the header), and other miscellaneous setup information.<BR><BR></LI>

	<LI>Forward references and typedefs:&nbsp;&nbsp;&nbsp;Consists of structure declarations such as <CODE>struct IMyInterface</CODE>, and typedefs for any TKIND_ALIAS items.<BR><BR></LI>

	<LI>Smart pointer declarations:&nbsp;&nbsp;&nbsp; The template class <B>_com_ptr_t</B> is a smart-pointer implementation that encapsulates interface pointers and eliminates the need to call <B>AddRef</B>, <B>Release</B>, <B>QueryInterface</B> functions. In addition, it hides the <B>CoCreateInstance</B> call in creating a new COM object. This section uses macro statement <B>_COM_SMARTPTR_TYPEDEF</B> to establish typedefs of COM interfaces to be template specializations of the <A HREF="_langref__com_ptr_t.htm">_com_ptr_t</A> template class. For example, for interface <B>IFoo</B>, the .TLH file will contain:<BR>
<BR>
<CODE>_COM_SMARTPTR_TYPEDEF(IFoo, __uuidof(IFoo));<BR>
<BR>
which the compiler will expand to:<BR>
<BR>
typedef _com_ptr_t&lt;_com_IIID&lt;IFoo, __uuidof(IFoo)&gt; &gt; IFooPtr;<BR>
<BR>
</CODE>Type <CODE>IFooPtr</CODE> can then be used in place of the raw interface pointer <CODE>IFoo*</CODE>. Consequently, there is no need to call the various <B>IUnknown</B> member functions. <BR><BR></LI>

	<LI>Typeinfo declarations:&nbsp;&nbsp;&nbsp;Primarily consists of class definitions and other items exposing the individual typeinfo items returned by <B>ITypeLib:GetTypeInfo</B>. In this section, each typeinfo from the type library is reflected in the header in a form dependent on the <A HREF="JavaScript:hhobj_1.Click()">TYPEKIND</A> information.<BR><BR></LI>

	<LI>Optional old-style GUID definition:&nbsp;&nbsp;&nbsp;Contains initializations of the named GUID constants. These are names of the form <B>CLSID_CoClass</B> and <B>IID_Interface</B>, similar to those generated by the MIDL compiler.<BR><BR></LI>

	<LI><B>#include</B> statement for the secondary type library header.<BR><BR></LI>

	<LI>Footer boilerplate:&nbsp;&nbsp;&nbsp;Currently includes <CODE>#pragma pack(pop)</CODE>.</LI>
</OL>

<P>All sections, except the heading boilerplate and footer boilerplate section, are enclosed in a namespace with its name specified by the <B>library</B> statement in the original IDL file. You can use the names from the type library header either by an explicit qualification with the namespace name or by including the following statement:</P>

<PRE><CODE>using namespace MyLib;
</CODE></PRE>

<P>immediately after the <B>#import</B> statement in the source code.</P>

<P>The namespace can be suppressed by using the <A HREF="#_predir_no_namespace">no_namespace</A> attribute of the <B>#import</B> directive. However, suppressing the namespace may lead to name collisions. The namespace can also be renamed by the <A HREF="#_predir_rename_namespace">rename_namespace</A> attribute.</P>

<P>The compiler provides the full path to any type library dependency required by the type library it is currently processing. The path is written, in the form of comments, into the type library header (.TLH) that the compiler generates for each processed type library. </P>

<P>If a type library includes references to types defined in other type libraries, then the .TLH file will include comments of the following sort: </P>

<PRE><CODE>//
// Cross-referenced type libraries:
//
//  #import "c:\path\typelib0.tlb"
//
</CODE></PRE>

<P>The actual filename in the <B>#import</B> comment is the full path of the cross-referenced type library, as stored in the registry. If you encounter errors that are due to missing type definitions, check the comments at the head of the .TLH to see which dependent type libraries may need to be imported first. Likely errors are syntax errors (e.g. C2143, C2146, C2321), C2501 (missing decl-specifiers), or C2433 ('inline' not permitted on data declaration) while compiling the .TLI file. </P>

<P>You must determine which of the dependency comments are not otherwise provided for by system headers and then provide an <B>#import</B> directive at some point before the <B>#import</B> directive of the dependent type library in order to resolve the errors.</P>



<H2><A NAME="_predir_exclude"></A>The exclude attribute</H2>

<P><B>exclude("</B><I>Name1</I><B>"[, "</B><I>Name2</I><B>",...])</B></P>

<P class=dt><I>Name1</I></P>

<P class=indent>First item to be excluded</P>

<P class=dt><I>Name2</I></P>

<P class=indent>Second item to be excluded (if necessary)</P>

<P>Type libraries may include definitions of items defined in system headers or other type libraries. This attribute can be used to exclude these items from the type library header files being generated. This attribute can take any number of arguments, each being a top-level type library item to be excluded.</P>



<H2><A NAME="_predir_high_method_prefix"></A>The high_method_prefix attribute</H2>

<P><B>high_method_prefix("</B><I>Prefix</I><B>")</B></P>

<P class=dt><I>Prefix</I></P>

<P class=indent>Prefix to be used</P>

<P>By default, high-level error-handling properties and methods are exposed by member functions named without a prefix. The names are from the type library. The <B>high_method_prefix</B> attribute is used to specify a prefix to be used in naming these high-level properties and methods.</P>



<H2><A NAME="_predir_high_property_prefixes"></A>The high_property_prefixes attribute</H2>

<P><B>high_property_prefixes("</B><I>GetPrefix</I><B>","</B><I>PutPrefix</I><B>","</B><I>PutRefPrefix</I><B>")</B></P>

<P class=dt><I>GetPrefix</I></P>

<P class=indent>Prefix to be used for the <B>propget</B> methods</P>

<P class=dt><I>PutPrefix</I></P>

<P class=indent>Prefix to be used for the <B>propput</B> methods</P>

<P class=dt><I>PutRefPrefix</I></P>

<P class=indent>Prefix to be used for the <B>propputref</B> methods</P>

<P>By default, high-level error-handling <B>propget</B>, <B>propput</B>, and <B>propputref</B> methods are exposed by member functions named with prefixes <B>Get</B>, <B>Put</B>, and <B>PutRef</B> respectively. The <B>high_property_prefixes</B> attribute is used to specify alternate prefixes for all three property methods.</P>



<H2><A NAME="_predir_implementation_only"></A>The implementation_only attribute</H2>

<P>The <B>implementation_only</B> attribute suppresses the generation of the .TLH header file (the primary header file). This file contains all the declarations used to expose the type-library contents. The .TLI header file, with the implementations of the wrapper member functions, will be generated and included in the compilation.</P>

<P>When this attribute is specified, the content of the .TLI header is in the same namespace as the one normally used in the .TLH header. In addition, the member functions are not declared as inline.</P>

<P>The <B>implementation_only</B> attribute is intended for use in conjunction with the <A HREF="#_predir_no_implementation">no_implementation</A> attribute as a way of keeping the implementations out of the precompiled header (PCH) file. An <B>#import</B> statement with the <B>no_implementation</B> attribute is placed in the source region used to create the PCH. The resulting PCH is used by a number of source files. An <B>#import</B> statement with the <B>implementation_only</B> attribute is then used outside the PCH region. You are required to use this statement only once in one of the source files. This will generate all the required wrapper member functions without additional recompilation for each source file.</P>

<P class=indent><B><B>Note</B></B>&nbsp;&nbsp;&nbsp;The <B>implementation_only</B> attribute in one <B>#import</B> statement must be use in conjunction with another <B>#import</B> statement, of the same type library, with the <B>no_implementation</B> attribute. Otherwise, compiler errors will be generated. This is because wrapper class definitions generated by the <B>#import</B> statement with the <B>no_implementation</B> attribute are required to compile the implementations generated by the <B>implementation_only</B> attribute.</P>



<H2><A NAME="vcreftheinclude(...)attribute"></A>The include(...) attribute</H2>

<P><B>include</B>(<B>Name1</B>[<B>,</B> <I>Name2</I><B>,</B> ...]<B>)</B></P>

<P class=dt><I>Name1</I></P>

<P class=indent>First item to be forcibly included</P>

<P class=dt><I>Name2</I></P>

<P class=indent>Second item to be forcibly included (if necessary)</P>

<P>Type libraries may include definitions of items defined in system headers or other type libraries.&nbsp; <B>#import</B> attempts to avoid multiple definition errors by automatically excluding such items.&nbsp; If items have been excluded, as indicated by warning <A HREF="vcrefcompilerwarning(level3)c4192.htm">C4192</A>, and they should not have been, this attribute can be used to disable the automatic exclusion.&nbsp; This attribute can take any number of arguments, each being the name of the type-library item to be included.</P>



<H2><A NAME="_predir_inject_statement"></A>The inject_statement attribute</H2>

<P><B>inject_statement("</B><I>source_text</I><B>")</B></P>

<P class=dt><I>source_text</I></P>

<P class=indent>Source text to be inserted into the type library header file</P>

<P>The <B>inject_statement</B> attribute inserts its argument as source text into the type-library header. The text is placed at the beginning of the namespace declaration that wraps the type-library contents in the header file.</P>



<H2><A NAME="_predir_named_guids"></A>The named_guids attribute</H2>

<P>The <B>named_guids</B> attribute tells the compiler to define and initialize GUID variables in old style, of the form <B>LIBID_MyLib</B>, <B>CLSID_MyCoClass</B>, <B>IID_MyInterface</B>, and <B>DIID_MyDispInterface</B>.</P>



<H2><A NAME="_predir_no_implementation"></A>The no_implementation attribute</H2>

<P>The <B>no_implementation</B> attribute suppresses the generation of the .TLI header, which contains the implementations of the wrapper member functions. If this attribute is specified, the .TLH header, with the declarations to expose type-library items, will be generated without an <B>#include</B> statement to include the .TLI header file.</P>

<P>This attribute is used in conjunction with <A HREF="#_predir_implementation_only">implementation_only</A>.</P>



<H2><A NAME="vcreftheno_auto_excludeattribute"></A>The no_auto_exclude attribute</H2>

<P>Type libraries may include definitions of items defined in system headers or other type libraries.&nbsp; <B>#import</B> attempts to avoid multiple definition errors by automatically excluding such items.&nbsp; When this is done, warning <A HREF="vcrefcompilerwarning(level3)c4192.htm">C4192</A> will be issued for each item to be excluded.&nbsp; You can disable this automatic exclusion by using this attribute.</P>



<H2><A NAME="_predir_no_namespace"></A>The no_namespace attribute</H2>

<P>The type-library contents in the <B>#import</B> header file are normally defined in a namespace. The namespace name is specified in the <B>library</B> statement of the original IDL file. If the <B>no_namespace</B> attribute is specified, this namespace is not generated by the compiler. </P>

<P>If you want to use a different namespace name, use the <A HREF="#_predir_rename_namespace">rename_namespace</A> attribute instead.</P>



<H2><A NAME="_predir_raw_dispinterfaces"></A>The raw_dispinterfaces attribute</H2>

<P>The <B>raw_dispinterfaces</B> attribute tells the compiler to generate low-level wrapper functions for dispinterface methods and properties that call <B>IDispatch::Invoke</B> and return the <B>HRESULT</B> error code. </P>

<P>If this attribute is not specified, only high-level wrappers are generated, which throw C++ exceptions in case of failure.</P>



<H2><A NAME="_predir_raw_interfaces_only"></A>The raw_interfaces_only attribute</H2>

<P>The <B>raw_interfaces_only</B> attribute suppresses the generation of error-handling wrapper functions and <A HREF="_langref_property.htm">__declspec(property)</A> declarations that use those wrapper functions. </P>

<P>The <B>raw_interfaces_only</B> attribute also causes the default prefix used in naming the non-property functions to be removed. Normally, the prefix is <B>raw_</B>. If this attribute is specified, the function names are directly from the type library.</P>

<P>This attribute allows you to expose only the low-level contents of the type library.</P>



<H2><A NAME="_predir_raw_method_prefix"></A>The raw_method_prefix attribute</H2>

<P><B>raw_method_prefix("</B><I>Prefix</I><B>")</B></P>

<P class=dt><I>Prefix</I></P>

<P class=indent>The prefix to be used</P>

<P>Low-level properties and methods are exposed by member functions named with a default prefix of <B>raw_</B> to avoid name collisions with the high-level error-handling member functions. The <B>raw_method_prefix</B> attribute is used to specify a different prefix. </P>

<P class=indent><B><B>Note</B></B>&nbsp;&nbsp;&nbsp;The effects of the <B>raw_method_prefix</B> attribute will not be changed by the presence of the <A HREF="#_predir_raw_interfaces_only">raw_interfaces_only</A> attribute. The <B>raw_method_prefix</B> always takes precedence over <B>raw_interfaces_only</B> in specifying a prefix. If both attributes are used in the same <B>#import</B> statement, then the prefix specified by the <B>raw_method_prefix</B> attribute is used.</P>



<H2><A NAME="_predir_raw_native_types"></A>The raw_native_types attribute</H2>

<P>By default, the high-level error-handling methods use the COM support classes <A HREF="_langref__bstr_t.htm">_bstr_t</A> and <A HREF="_langref__variant_t.htm">_variant_t</A> in place of the <B>BSTR</B> and <B>VARIANT</B> data types and raw COM interface pointers. These classes encapsulate the details of allocating and deallocating memory storage for these data types, and greatly simplify type casting and conversion operations. The <B>raw_native_types</B> attribute is used to disable the use of these COM support classes in the high-level wrapper functions, and force the use of low-level data types instead.</P>



<H2><A NAME="_predir_raw_property_prefixes"></A>The raw_property_prefixes attribute</H2>

<P><B>raw_property_prefixes("</B><I>GetPrefix</I><B>","</B><I>PutPrefix</I><B>","</B><I>PutRefPrefix</I><B>")</B></P>

<P class=dt><I>GetPrefix</I></P>

<P class=indent>Prefix to be used for the <B>propget</B> methods</P>

<P class=dt><I>PutPrefix</I></P>

<P class=indent>Prefix to be used for the <B>propput</B> methods</P>

<P class=dt><I>PutRefPrefix</I></P>

<P class=indent>Prefix to be used for the <B>propputref</B> methods</P>

<P>By default, low-level <B>propget</B>, <B>propput</B>, and <B>propputref</B> methods are exposed by member functions named with prefixes of <B>get_</B>, <B>put_</B>, and <B>putref_</B> respectively. These prefixes are compatible with the names used in the header files generated by MIDL. The <B>raw_property_prefixes</B> attribute is used to specify alternate prefixes for all three property methods.</P>



<H2><A NAME="_predir_rename"></A>The rename attribute</H2>

<P><B>rename("</B><I>OldName</I><B>","</B><I>NewName</I><B>")</B></P>

<P class=dt><I>OldName</I></P>

<P class=indent>Old name in the type library</P>

<P class=dt><I>NewName</I></P>

<P class=indent>Name to be used instead of the old name</P>

<P>The <B>rename</B> attribute is used to work around name collision problems. If this attribute is specified, the compiler replaces all occurrences of <I>OldName</I> in a type library with the user-supplied <I>NewName</I> in the resulting header files.</P>

<P>This attribute can be used when a name in the type library coincides with a macro definition in the system header files. If this situation is not resolved, then various syntax errors will be generated, such as C2059 and C2061.</P>

<P class=indent><B><B>Note</B></B>&nbsp;&nbsp;&nbsp;The replacement is for a name used in the type library, not for a name used in the resulting header file.</P>

<P>Here is an example: Suppose a property named <CODE>MyParent</CODE> exists in a type library, and a macro <CODE>GetMyParent</CODE> is defined in a header file and used before <B>#import</B>. Since <CODE>GetMyParent</CODE> is the default name of a wrapper function for the error-handling <B>get</B> property, a name collision will occur. To work around the problem, use the following attribute in the <B>#import</B> statement:</P>

<PRE><CODE>rename(“MyParent”,”MyParentX”)
</CODE></PRE>

<P>which renames the name <CODE>MyParent</CODE> in the type library. An attempt to rename the <CODE>GetMyParent</CODE> wrapper name will fail:</P>

<PRE><CODE>rename(“GetMyParent”,”GetMyParentX”)
</CODE></PRE>

<P>This is because the name <CODE>GetMyParent</CODE> only occurs in the resulting type library header file.</P>



<H2><A NAME="_predir_rename_namespace"></A>The rename_namespace attribute</H2>

<P><B>rename_namespace("</B><I>NewName</I><B>")</B></P>

<P class=dt><I>NewName</I></P>

<P class=indent>The new name of the namespace</P>

<P>The <B>rename_namespace</B> attribute is used to rename the namespace that contains the contents of the type library. It takes a single argument, <I>NewName</I>, which specifies the new name for the namespace. </P>

<P>To remove the namespace, use the <A HREF="#_predir_no_namespace">no_namespace</A> attribute instead.</P>

<P><B>END C++ Specific</B></P>
</font>
</BODY>
</HTML>
