<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Sample Multithread C Program</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>

<TABLE ALIGN=right WIDTH=0 BORDER=0><TR><TD>
<OBJECT ID="hhobj_1" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_vc_addpf_home">
</OBJECT>
</TD></TR></TABLE>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_core_sample_multithread_c_program"></A>Sample Multithread C Program</H1>

<P><A HREF="JavaScript:hhobj_1.Click()">Home</A>  |&nbsp; <A HREF="_core_multithreaded_programs.3a_.overview.htm">Overview</A>  |&nbsp; <A HREF="_core_multithreading_tasks.htm">How Do I</A>  |&nbsp; <A HREF="_core_multithreading_sample_list.htm">Sample</A></P>

<P>BOUNCE.C is a sample multithread program that creates a new thread each time the letter <B>a</B> or <B>A</B> is typed. Each thread bounces a “happy face” of a different color around the screen. Up to 32 threads can be created. The program’s normal termination occurs when <B>q</B> or <B>Q</B> is typed. See <A HREF="_core_compiling_and_linking_multithread_programs.htm">Compiling and Linking Multithread Programs</A> for details on compiling and linking BOUNCE.C.</P>

<PRE><CODE>/*  Bounce - Creates a new thread each time the letter 'a' is typed.
 *  Each thread bounces a happy face of a different color around the screen.
 *  All threads are terminated when the letter 'Q' is entered.
 *
 *  This program requires the multithread library. For example, compile
 *  with the following command line:
 *      CL /MT BOUNCE.C
 */

#include &lt;windows.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
#include &lt;process.h&gt;

#define MAX_THREADS  32

/* getrandom returns a random number between min and max, which must be in
 * integer range.
 */
#define getrandom( min, max ) ((rand() % (int)(((max) + 1) - (min))) + (min))

void main( void );                     /* Thread 1: main */
void KbdFunc( void  );                 /* Keyboard input, thread dispatch */
void BounceProc( char * MyID );        /* Threads 2 to n: display */
void ClearScreen( void );              /* Screen clear */
void ShutDown( void );                 /* Program shutdown */
void WriteTitle( int ThreadNum );      /* Display title bar information */

HANDLE  hConsoleOut;                   /* Handle to the console */
HANDLE  hRunMutex;                     /* "Keep Running" mutex */
HANDLE  hScreenMutex;                  /* "Screen update" mutex  */
int     ThreadNr;                      /* Number of threads started */
CONSOLE_SCREEN_BUFFER_INFO csbiInfo;   /* Console information */


void main()                            /* Thread One */
{
    /* Get display screen information &amp; clear the screen.*/
    hConsoleOut = GetStdHandle( STD_OUTPUT_HANDLE );
    GetConsoleScreenBufferInfo( hConsoleOut, &amp;csbiInfo );
    ClearScreen();
    WriteTitle( 0 );
    /* Create the mutexes and reset thread count. */
    hScreenMutex = CreateMutex( NULL, FALSE, NULL );   /* Cleared */
    hRunMutex = CreateMutex( NULL, TRUE, NULL );       /* Set */
    ThreadNr = 0;

    /* Start waiting for keyboard input to dispatch threads or exit. */
    KbdFunc();

    /* All threads done. Clean up handles. */
    CloseHandle( hScreenMutex );
    CloseHandle( hRunMutex );
    CloseHandle( hConsoleOut );
}

void ShutDown( void )                  /* Shut down threads */
{
    while ( ThreadNr &gt; 0 )
    {
            /* Tell thread to die and record its death. */
            ReleaseMutex( hRunMutex );
            ThreadNr--;   
    }
    /* Clean up display when done */
    WaitForSingleObject( hScreenMutex, INFINITE );
    ClearScreen();
}

void KbdFunc( void )                   /* Dispatch and count threads. */
{
    int         KeyInfo;

    do
    {
        KeyInfo = _getch();
        if( tolower( KeyInfo ) == 'a' &amp;&amp; ThreadNr &lt; MAX_THREADS )
        {
            ThreadNr++;
            _beginthread( BounceProc, 0, &amp;ThreadNr );
            WriteTitle( ThreadNr );
        }
    } while( tolower( KeyInfo ) != 'q' );

    ShutDown();
}

void BounceProc( char *MyID )
{
    char      MyCell, OldCell;
    WORD      MyAttrib, OldAttrib;
    char      BlankCell = 0x20;
    COORD     Coords, Delta;
    COORD     Old = {0,0};
    DWORD     Dummy;

/* Generate update increments and initial display coordinates. */
    srand( (unsigned) *MyID * 3 );
    Coords.X = getrandom( 0, csbiInfo.dwSize.X - 1 );
    Coords.Y = getrandom( 0, csbiInfo.dwSize.Y - 1 );
    Delta.X = getrandom( -3, 3 );
    Delta.Y = getrandom( -3, 3 );

    /* Set up "happy face" &amp; generate color attribute from thread number.*/
    if( *MyID &gt; 16)
        MyCell = 0x01;                 /* outline face */
    else
        MyCell = 0x02;                 /* solid face */
    MyAttrib =  *MyID &amp; 0x0F;          /* force black background */

    do
    {
        /* Wait for display to be available, then lock it. */
        WaitForSingleObject( hScreenMutex, INFINITE );

        /* If we still occupy the old screen position, blank it out. */
        ReadConsoleOutputCharacter( hConsoleOut, &amp;OldCell, 1, Old, &amp;Dummy );
        ReadConsoleOutputAttribute( hConsoleOut, &amp;OldAttrib, 1, Old, &amp;Dummy );
        if (( OldCell == MyCell ) &amp;&amp; (OldAttrib == MyAttrib))
            WriteConsoleOutputCharacter( hConsoleOut, &amp;BlankCell, 1, Old, &amp;Dummy );

        /* Draw new face, then clear screen lock */
        WriteConsoleOutputCharacter( hConsoleOut, &amp;MyCell, 1, Coords, &amp;Dummy );
        WriteConsoleOutputAttribute( hConsoleOut, &amp;MyAttrib, 1, Coords, &amp;Dummy );
        ReleaseMutex( hScreenMutex );

        /* Increment the coordinates for next placement of the block. */
        Old.X = Coords.X;
        Old.Y = Coords.Y;
        Coords.X += Delta.X;
        Coords.Y += Delta.Y;

        /* If we are about to go off the screen, reverse direction */
        if( Coords.X &lt; 0 || Coords.X &gt;= csbiInfo.dwSize.X )
        {
            Delta.X = -Delta.X;
            Beep( 400, 50 );
        }
        if( Coords.Y &lt; 0 || Coords.Y &gt; csbiInfo.dwSize.Y )
        {
            Delta.Y = -Delta.Y;
            Beep( 600, 50 );
        }
    }
    /* Repeat while RunMutex is still taken. */
    while ( WaitForSingleObject( hRunMutex, 75L ) == WAIT_TIMEOUT );

}

void WriteTitle( int ThreadNum )
{
    char    NThreadMsg[80];

    sprintf( NThreadMsg, "Threads running: %02d.  Press 'A' to start a thread,'Q' to quit.", ThreadNum );
    SetConsoleTitle( NThreadMsg );
}

void ClearScreen( void )
{
    DWORD    dummy;
    COORD    Home = { 0, 0 };
    FillConsoleOutputCharacter( hConsoleOut, ' ', csbiInfo.dwSize.X * csbiInfo.dwSize.Y, Home, &amp;dummy );
}
</CODE></PRE>
</font>
</BODY>
</HTML>
