<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Programmatic Printing</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>

<TABLE ALIGN=right WIDTH=0 BORDER=0><TR><TD>
<OBJECT ID="hhobj_1" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_vc_addpf_home">
</OBJECT>
</TD></TR></TABLE>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_core_programmatic_printing"></A>Programmatic Printing</H1>

<P><A HREF="JavaScript:hhobj_1.Click()">Home</A>  |&nbsp; <A HREF="_core_activex.3a_.overview.htm">Overview</A>  |&nbsp; <A HREF="_core_activex_tasks.htm">How Do I</A></P>

<P>OLE provided the means to uniquely identify persistent documents (<B>GetClassFile</B>) and load them into their associated code (<B>CoCreateInstance</B>, <B>QueryInterface(IID_IPersistFile)</B>, <B>QueryInterface(IID_IPersistStorage)</B>, <B>IPersistFile::Load</B>, and <B>IPersistStorage::Load</B>). To further enable printing documents, Active document containment (using an existing OLE design not shipped with OLE 2.0 originally) introduces a base-standard printing interface,<I> </I><B>IPrint</B>, generally available through any object that can load the persistent state of the document type. Each view of an Active document can optionally support the <B>IPrint </B>interface to provide these capabilities.</P>

<P>The <B>IPrint</B> interface is defined as follows:</P>

<PRE><CODE>interface IPrint : IUnknown
    {
    HRESULT SetInitialPageNum([in] LONG nFirstPage);
    HRESULT GetPageInfo([out] LONG *nFirstPage, [out] LONG *pcPages);
    HRESULT Print([in] DWORD grfFlags, [in,out] DVTARGETDEVICE **pptd
        , [in,out] PAGESET ** ppPageSet , [in,out] STGMEDIUM **ppstgmOptions
        , [in] IContinueCallback* pCallback, [in] LONG nFirstPage
        ,[out] LONG *pcPagesPrinted, [out] LONG *pnPageLast);
    };
</CODE></PRE>

<P>Clients and containers simply use <B>IPrint::Print</B> to instruct the document to print itself once that document is loaded, specifying printing control flags, the target device, the pages to print, and additional options. The client can also control the continuation of printing through the interface <B>IContinueCallback</B> (see below).</P>

<P>In addition,<B> IPrint::SetInitialPageNum</B> supports the ability to print a series of documents as one by numbering pages seamlessly, obviously a benefit for active document containers like Office Binder. <B>IPrint::GetPageInfo</B> makes displaying pagination information simple by allowing the caller to retrieve the starting page number previously passed to <B>SetInitialPageNum</B> (or the document’s internal default starting page number) and the number of pages in the document.</P>

<P>Objects that support <B>IPrint</B> are marked in the registry with the “Printable” key stored under the object’s CLSID:</P>

<P>HKEY_CLASSES_ROOT\CLSID\{...}\Printable</P>

<P><B>IPrint</B> is usually implemented on the same object that supports either <B>IPersistFile</B> or <B>IPersistStorage</B>. Callers note the capability to programmatically print the persistent state of some class by looking in the registry for the “Printable” key. Currently, “Printable” indicates support for at least <B>IPrint</B>; other interfaces may be defined in the future which would then be available through <B>QueryInterface</B> where <B>IPrint </B>simply represents the base level of support.</P>

<P>During a print procedure, you may want the client or container that initiated the printing to control whether or not the printing should continue. For example, the container may support a “Stop Print” command that should terminate the print job as soon as possible. To support this capability, the client of a printable object can implement a small notification sink object with the interface <B>IContinueCallback</B>:</P>

<PRE><CODE>interface IContinueCallback : IUnknown
    {
    HRESULT FContinue(void);
    HRESULT FContinuePrinting([in] LONG cPagesPrinted, [in] LONG nCurrentPage
        , [in] LPOLESTR pszPrintStatus);
    };
</CODE></PRE>

<P>This interface is designed to be useful as a generic continuation callback function that takes the place of the various continuation procedures in the Win32 API (such as the <B>AbortProc</B> for printing and the <B>EnumMetafileProc</B> for metafile enumeration). Thus this interface design is useful in a wide variety of time-consuming processes.</P>

<P>In the most generic cases, the <B>IContinueCallback::FContinue</B> function is called periodically by any lengthy process. The sink object returns <B>S_OK</B> to continue the operation, and <B>S_FALSE</B> to stop the procedure as soon as possible.</P>

<P><B>FContinue</B>, however, is not used in the context of <B>IPrint::Print</B>; rather, printing uses <B>IContinueCallback::FContinuePrint</B>. Any printing object should periodically call <B>FContinuePrinting</B> passing the number of pages that have been printing, the number of the page being printed, and an additional string describing the print status that the client may choose to display to the user (such as “Page 5 of 19”).</P>
</font>
</BODY>
</HTML>
