<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Linker Tools Error LNK2001</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="lnk2001"></A><SUP></SUP>Linker Tools Error LNK2001</H1>

<P class=dt><B>unresolved external symbol "symbol"</B></P>

<P>Code will generate this error message if it references something (like a function, variable, or label) that the linker can’t find in all the libraries and object files it searches. In general, there are two reasons this error occurs: what the code asks for doesn’t exist (the <I>symbol</I> is spelled incorrectly or uses the wrong case, for example), or the code asks for the wrong thing (you are using mixed versions of the libraries?some from one version of the product, others from another version). </P>

<P>Numerous kinds of coding and build errors can cause LNK2001. Several specific causes are listed below, and some have links to more detailed explanations. </P>

<P><B>Coding Problems</B>

<UL type=disc>
	<LI>Mismatched case in your code or module-definition (.DEF) file can cause LNK2001. For example, if you named a variable “var1” in one C++ source file and tried to access it as “VAR1” in another, you would receive this error. The solution is to exactly match the case of the symbol in all references.<BR><BR></LI>

	<LI>A project that uses <A HREF="_error_function_inlining_problems.htm">function inlining</A> yet defines the functions in a .CPP file rather than in the header file can cause LNK2001. <BR><BR></LI>

	<LI>If you are using C++, make sure to use <B>extern</B> “C” when calling a C function from a C++ program. By using <B>extern</B> “C” you force the use of the C naming convention. Be aware of compiler switches like <A HREF="_core_.2f.tc.2c_2f.tp.htm">/Tp</A> or <A HREF="_core_.2f.tc.2c_2f.tp.htm">/Tc</A> that force a file to be compiled as a C (/Tc) or C++ (/Tp) file no matter what the filename extension, or you may get different function names than you expect.<BR><BR></LI>

	<LI>Attempting to reference functions or data that don't have external linkage causes LNK2001. In C++, inline functions and <B>const</B> data have internal linkage unless explicitly specified as <B>extern</B>. <BR><BR></LI>

	<LI>A <A HREF="_error_missing_function_body_or_variable.htm">missing function body or variable</A> will cause LNK2001. Having just a function prototype or <B>extern</B> declaration will allow the compiler to continue without error, but the linker will not be able to resolve your call to an address or reference to a variable because there is no function code or variable space reserved. <BR><BR></LI>

	<LI><A HREF="_error_name_decoration.htm">Name decoration</A> incorporates the parameters of a function into the final decorated function name. Calling a function with parameter types that do not match those in the function declaration may cause LNK2001. <BR><BR></LI>

	<LI>Incorrectly included prototypes will cause the compiler to expect a function body that is not provided. If you have both a class and non-class implementation of a function <CODE>F</CODE>, beware of C++ scope-resolution rules. <BR><BR></LI>

	<LI>When using C++, make sure that you <A HREF="_error_missing_function_body_or_variable.htm">include the implementation</A> of a specific function for a class and not just a prototype in the class definition. <BR><BR></LI>

	<LI>Attempting to call a pure virtual function from the constructor or destructor of an abstract base class will cause LNK2001 since by definition a pure virtual function has no base class implementation. <BR><BR></LI>

	<LI>Only global functions and variables are public. 
<P class=tl><A HREF="_error_the_symbol_is_not_public.htm">Functions declared with the static modifier</A> by definition have file scope. Static variables have the same limitation. Trying to access any static variables from outside of the file in which they are declared can result in a compile error or LNK2001. </P>
<P class=tl>A variable declared within a function (<A HREF="_error_automatic_.28.function_scope.29_.variables.htm">a local variable</A>) can only be used within the scope of that function.<U> </U></P>
<P class=tl><A HREF="_error_global_constants_in_c.2b2b.htm">C++ global constants</A> have <B>static</B> linkage. This is different than C. If you try to use a global constant in C++ in multiple files you get error LNK2001. One alternative is to include the <B>const</B> initializations in a header file and include that header in your .CPP files when necessary, just as if it was a function prototype. Another alternative is to make the variable non-constant and use a constant reference when assessing it. </P></LI>
</UL>

<P><B>Compiling and Linking Problems</B>

<UL type=disc>
	<LI>The names of the Microsoft run-time and MFC libraries needed at link time are included in the object file module by the Microsoft compiler. If you use the /NOD (<A HREF="_core_.2f.nodefaultlib.htm">/NODEFAULTLIB</A>) option, these libraries will <I>not </I>be linked into the project unless you have explicitly included them. Using /NOD will cause error LNK2001 in this case. <BR><BR></LI>

	<LI>If you are using Unicode and MFC, you will get an unresolved external on _<B>WinMain@16</B> if you don’t create an entrypoint to <B>wWinMainCRTStartup</B>. Use the /ENTRY option or type this value in the Project Settings dialog box. (To find this option in the development environment, click Settings on the Project menu, then click the Link tab, and click Output in the Category box.) See <A HREF="_core_unicode_programming_summary.htm">Unicode Programming Summary</A>. <BR>
<BR>
See the following Knowledge Base articles located in the Online Information System for more information. An easy way to reach an article is to copy a "Q" number above, open the Search dialog box from the Help menu and select the Query tab, then paste the number into the first text box and press ENTER.
<UL type=disc>
	<LI>Q125750&nbsp;&nbsp;&nbsp;"PRB: Error LNK2001: '_WinMain@16': Unresolved External Symbol"<BR><BR></LI>

	<LI>Q131204&nbsp;&nbsp;&nbsp;"PRB: Wrong Project Selection Causes LNK2001 on _WinMain@16"<BR><BR></LI>

	<LI>Q100639&nbsp;&nbsp;&nbsp;"Unicode Support in the Microsoft Foundation Class Library"</LI>
</UL>
</LI>

	<LI>Linking code compiled with /MT with the library LIBC.LIB causes LNK2001 on <B>_beginthread</B>, <B>_beginthreadex</B>, <B>_endthread</B>, and <B>_endthreadex</B>. <BR><BR></LI>

	<LI>When compiling with /MD, a reference to "func" in your source becomes a reference "__imp__func" in the object since all the run-time is now held within a DLL. If you try to link with the static libraries LIBC.LIB or LIBCMT.LIB, you will get LNK2001 on __imp__func. If you try to link with MSVCxx.LIB when compiling without /MD you will not always get LNK2001, but you will likely have other problems. <BR><BR></LI>

	<LI>Linking code compiled with an explicit or implicit /ML to the LIBCMT.LIB causes LNK2001 on <B>_errno</B>. <BR><BR></LI>

	<LI>Linking with the release mode libraries when building a debug version of an application can cause LNK2001. Similarly, using an /Mxd option (/MLd, /MTd, or /MDd) and/or defining _<B>DEBUG</B> and then linking with the release libraries will give you potential unresolved externals (among other problems). Linking a release mode build with the debug libraries will also cause similar problems.<BR><BR></LI>

	<LI>Mixing versions of Microsoft libraries and compiler products can be problematic. A new compiler version's libraries may contain new symbols that cannot be found in the libraries included with previous versions. Use <A HREF="_core_dumpbin_reference.htm">DUMPBIN</A> to find out if a symbol is in a 32-bit object file or library. <BR><BR></LI>

	<LI>There is currently no standard for <A HREF="_error_name_decoration.htm">C++ naming</A> between compiler vendors or even between different versions of a compiler. Therefore linking object files compiled with other compilers may not produce the same naming scheme and thus cause error LNK2001.<BR><BR></LI>

	<LI><A HREF="_error_function_inlining_problems.htm">Mixing inline and non-inline compile options</A> on different modules can cause LNK2001. If a C++ library is created with function inlining turned on (/Ob1 or /Ob2) but the corresponding header file describing the functions has inlining turned off (no <B>inline</B> keyword), you will get this error. To prevent this problem, have the inline functions defined with <B>inline</B> in the header file you are going to include in other files.<BR><BR></LI>

	<LI>If you are using the <B>#pragma inline_depth</B> compiler directive, make sure you have a <A HREF="_error_function_inlining_problems.htm">value of 2 or greater set</A>, and make sure you are using the <A HREF="_core_.2f.ob.htm">/Ob1</A> or <A HREF="_core_.2f.ob.htm">/Ob2</A> compiler option. <BR><BR></LI>

	<LI>Omitting the LINK option /NOENTRY when creating a resource-only DLL will cause LNK2001.<BR><BR></LI>

	<LI>Using incorrect /SUBSYSTEM or /ENTRY settings can cause LNK2001. For example, if you write a character-based application (a console application) and specify /SUBSYSTEM:WINDOWS, you will get an unresolved external for <B>WinMain</B>. For more information on these options and entry points, see the <A HREF="_core_.2f.subsystem.htm">/SUBSYSTEM</A> and <A HREF="_core_.2f.entry.htm">/ENTRY</A> linker options. </LI>
</UL>

<P><B>Export Problems</B>

<UL type=disc>
	<LI>When you are porting an application from 16 to 32 bits, LNK2001 can occur. The current 32-bit module-definition (.DEF) file syntax requires that <B>__cdecl</B>, <B>__stdcall</B>, and <B>__fastcall</B> functions be listed in the EXPORTS section without underscores (undecorated). This differs from the 16-bit syntax, where they must be listed with underscores (decorated). For more information, see the description of the <A HREF="_core_exports.htm">EXPORTS</A> section of module-definition files. <BR><BR></LI>

	<LI>Any export listed in the .DEF file and not found will cause LNK2001. This could be because it does not exist, is spelled incorrectly, or uses decorated names (.DEF files do not take decorated names).&nbsp; </LI>
</UL>

<P>This error message is followed by fatal error <A HREF="lnk1120.htm">LNK1120</A>.</P>

<P>The following sections give more detailed information on some of the issues named in the above list.

<UL type=disc>
	<LI><A HREF="_error_missing_function_body_or_variable.htm">Missing function body or variable</A><BR><BR></LI>

	<LI><A HREF="_error_name_decoration.htm">Name decoration</A><BR><BR></LI>

	<LI><A HREF="_error_the_symbol_is_not_public.htm">The symbol is not public</A><BR><BR></LI>

	<LI><A HREF="_error_automatic_.28.function_scope.29_.variables.htm">Automatic (function scope) variables</A><BR><BR></LI>

	<LI><A HREF="_error_global_constants_in_c.2b2b.htm">Global constants in C++</A><BR><BR></LI>

	<LI><A HREF="_error_function_inlining_problems.htm">Function inlining problems</A></LI>
</UL>
</font>
</BODY>
</HTML>
