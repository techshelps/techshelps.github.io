<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>_pipe</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_crt__pipe"></A><SUP></SUP>_pipe</H1>

<P>Creates a pipe for reading and writing.</P>

<P><B>int</B> <B>_pipe(</B> <B>int</B> <B>*</B><I>phandles</I><B>,</B> <B>unsigned</B> <B>int</B> <I>psize</I><B>,</B> <B>int</B> <I>textmode</I> <B>);</B></P>

<TABLE border=1 cellpadding=5 cols=4 frame=below rules=rows>

<TR VALIGN="top">
<TD class=label width=15%><B>Routine</B></TD>
<TD class=label width=27%><B>Required Header</B></TD>
<TD class=label width=28%><B>Optional Headers</B></TD>
<TD class=label width=30%><B>Compatibility</B></TD>
</TR>

<TR VALIGN="top">
<TD width=15%><B>_pipe</B></TD>
<TD width=27%>&lt;io.h&gt;</TD>
<TD width=28%>&lt;fcntl.h&gt;,<SUP>1</SUP> &lt;errno.h&gt;<SUP>2</SUP></TD>
<TD width=30%>Win 95, Win NT</TD>
</TR>
</TABLE><BR>

<P class=mini><SUP>1</SUP>  For <B>_O_BINARY</B> and <B>_O_TEXT</B> definitions.</P>

<P class=mini><SUP>2</SUP>  <B>errno</B> definitions.</P>

<P>For additional compatibility information, see <A HREF="_crt_compatibility.htm">Compatibility</A> in the Introduction.</P>

<P class=label><B>Libraries</B></P>

<TABLE border=1 cellpadding=5 cols=2 frame=below rules=rows>

<TR VALIGN="top">
<TD width=24%>LIBC.LIB</TD>
<TD width=76%>Single thread static library, retail version</TD>
</TR>

<TR VALIGN="top">
<TD width=24%>LIBCMT.LIB</TD>
<TD width=76%>Multithread static library, retail version</TD>
</TR>

<TR VALIGN="top">
<TD width=24%>MSVCRT.LIB</TD>
<TD width=76%>Import library for MSVCRT.DLL, retail version</TD>
</TR>
</TABLE><BR>

<P class=label><B>Return Value</B></P>

<P><B>_pipe</B> returns 0 if successful. It returns –1 to indicate an error, in which case <B>errno</B> is set to one of two values: <B>EMFILE</B>, which indicates no more file handles available, or <B>ENFILE</B>, which indicates a system file table overflow.</P>

<P class=label><B>Parameters</B></P>

<P class=dt><I>phandles</I>[2]</P>

<P class=indent>Array to hold read and write handles</P>

<P class=dt><I>psize</I></P>

<P class=indent>Amount of memory to reserve</P>

<P class=dt><I>textmode</I></P>

<P class=indent>File mode</P>

<P class=label><B>Remarks</B></P>

<P>The <B>_pipe</B> function creates a pipe. A <I>pipe</I> is an artificial I/O channel that a program uses to pass information to other programs. A pipe is similar to a file in that it has a file pointer, a file descriptor, or both, and can be read from or written to using the standard library’s input and output functions. However, a pipe does not represent a specific file or device. Instead, it represents temporary storage in memory that is independent of the program’s own memory and is controlled entirely by the operating system.</P>

<P><B>_pipe</B> is similar to <B>_open</B> but opens the pipe for reading and writing, returning two file handles instead of one. The program can use both sides of the pipe or close the one it does not need. For example, the command processor in Windows NT creates a pipe when executing a command such as</P>

<PRE><CODE>PROGRAM1 | PROGRAM2
</CODE></PRE>

<P>The standard output handle of PROGRAM1 is attached to the pipe’s write handle. The standard input handle of PROGRAM2 is attached to the pipe’s read handle. This eliminates the need for creating temporary files to pass information to other programs.</P>

<P>The <B>_pipe</B> function returns two handles to the pipe in the <I>phandles</I> argument. The element <I>phandles</I>[0] contains the read handle, and the element <I>phandles</I>[1] contains the write handle. Pipe file handles are used in the same way as other file handles. (The low-level input and output functions <B>_read</B> and <B>_write</B> can read from and write to a pipe.) To detect the end-of-pipe condition, check for a <B>_read</B> request that returns 0 as the number of bytes read.</P>

<P>The <I>psize</I> argument specifies the amount of memory, in bytes, to reserve for the pipe. The <I>textmode</I> argument specifies the translation mode for the pipe. The manifest constant <B>_O_TEXT</B> specifies a text translation, and the constant <B>_O_BINARY</B> specifies binary translation. (See <A HREF="_crt_fopen.2c_._wfopen.htm">fopen</A> for a description of text and binary modes.) If the <I>textmode</I> argument is 0, <B>_pipe</B> uses the default translation mode specified by the default-mode variable <A HREF="_crt__fmode.htm">_fmode</A>.</P>

<P>In multithreaded programs, no locking is performed. The handles returned are newly opened and should not be referenced by any thread until after the <B>_pipe</B> call is complete.</P>

<P>In order to use the <B>_pipe</B> function to communicate between a parent and a child process, each process must have only one handle open on the pipe. The handles must be opposites: if the parent has a read handle open, then the child must have a write handle open. The easiest way to do this is to <B>OR</B> (<B>|</B>) the <B>_O_NOINHERIT</B> flag with <I>textmode</I>. Then, use <B>_dup</B> or <B>_dup2</B> to create an inheritable copy of the pipe handle you wish to pass to the child. Close the original handle, and spawn the child process. Upon returning from the spawn call, close the 'duplicate' handle in the parent process. See Example 2 below for more information.</P>

<P>In Windows NT and Windows 95, a pipe is destroyed when all of its handles have been closed. (If all read handles on the pipe have been closed, writing to the pipe causes an error.) All read and write operations on the pipe wait until there is enough data or enough buffer space to complete the I/O request.</P>

<P class=label><B>Example 1</B></P>

<PRE><CODE>/* PIPE.C: This program uses the _pipe function to pass streams of
 * text to spawned processes.
 */

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;io.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;process.h&gt;
#include &lt;math.h&gt;

enum PIPES { READ, WRITE }; /* Constants 0 and 1 for READ and WRITE */
#define NUMPROBLEM 8

void main( int argc, char *argv[] )
{

   int hpipe[2];
   char hstr[20];
   int pid, problem, c;
   int termstat;

   /* If no arguments, this is the spawning process */
   if( argc == 1 )
   {

      setvbuf( stdout, NULL, _IONBF, 0 );

      /* Open a set of pipes */
      if( _pipe( hpipe, 256, O_BINARY ) == -1 )
          exit( 1 );


      /* Convert pipe read handle to string and pass as argument 
       * to spawned program. Program spawns itself (argv[0]).
       */
      itoa( hpipe[READ], hstr, 10 );
      if( ( pid = spawnl( P_NOWAIT, argv[0], argv[0], 
            hstr, NULL ) ) == -1 )
          printf( "Spawn failed" );

      /* Put problem in write pipe. Since spawned program is 
       * running simultaneously, first solutions may be done 
       * before last problem is given.
       */
      for( problem = 1000; problem &lt;= NUMPROBLEM * 1000; problem += 1000)
      {

         printf( "Son, what is the square root of %d?\n", problem );
         write( hpipe[WRITE], (char *)&amp;problem, sizeof( int ) );

      }

      /* Wait until spawned program is done processing. */
      _cwait( &amp;termstat, pid, WAIT_CHILD );
      if( termstat &amp; 0x0 )
         printf( "Child failed\n" );


      close( hpipe[READ] );
      close( hpipe[WRITE] );

   }

   /* If there is an argument, this must be the spawned process. */
   else
   {

      /* Convert passed string handle to integer handle. */
      hpipe[READ] = atoi( argv[1] );

      /* Read problem from pipe and calculate solution. */
      for( c = 0; c &lt; NUMPROBLEM; c++ )
      {

        read( hpipe[READ], (char *)&amp;problem, sizeof( int ) );
        printf( "Dad, the square root of %d is %3.2f.\n",
                 problem, sqrt( ( double )problem ) );

      }
   }
}

</CODE></PRE>

<P class=label><B>Output</B></P>

<PRE><CODE>Son, what is the square root of 1000?
Son, what is the square root of 2000?
Son, what is the square root of 3000?
Son, what is the square root of 4000?
Son, what is the square root of 5000?
Son, what is the square root of 6000?
Son, what is the square root of 7000?
Son, what is the square root of 8000?
Dad, the square root of 1000 is 31.62.
Dad, the square root of 2000 is 44.72.
Dad, the square root of 3000 is 54.77.
Dad, the square root of 4000 is 63.25.
Dad, the square root of 5000 is 70.71.
Dad, the square root of 6000 is 77.46.
Dad, the square root of 7000 is 83.67.
Dad, the square root of 8000 is 89.44.

</CODE></PRE>

<P class=label><B>Example 2</B></P>

<PRE><CODE>// This is a simple filter application.  It will spawn 
// the application on  command line. But before spawning 
// the application, it will create a pipe that will direct the 
// spawned application's stdout to the filter.  The filter 
// will remove ASCII 7 (beep) characters.

// Beeper.Cpp

/* Compile options needed: None */
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main()
{
   int   i;
   for(i=0;i&lt;100;++i)
      {
         printf("\nThis is speaker beep number %d... \n\7", i+1);
      }
   return 0;
}


// BeepFilter.Cpp
/* Compile options needed: none
   Execute as: BeepFilter.exe &lt;path&gt;Beeper.exe
*/
#include &lt;windows.h&gt;
#include &lt;process.h&gt;
#include &lt;memory.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;io.h&gt;

#define   OUT_BUFF_SIZE 512
#define   READ_HANDLE 0
#define   WRITE_HANDLE 1
#define   BEEP_CHAR 7

char szBuffer[OUT_BUFF_SIZE];

int Filter(char* szBuff, ULONG nSize, int nChar)
{
   char* szPos = szBuff + nSize -1;
   char* szEnd = szPos;
   int nRet = nSize;

   while (szPos &gt; szBuff)
   {
      if (*szPos == nChar)
         {
            memmove(szPos, szPos+1, szEnd - szPos);
            --nRet;
         }
      --szPos;
   }
   return nRet;
}

int main(int argc, char** argv)
{
   int nExitCode = STILL_ACTIVE;
   if (argc &gt;= 2)
   {
      HANDLE hProcess;
      int hStdOut;
      int hStdOutPipe[2];

      // Create the pipe
      if(_pipe(hStdOutPipe, 512, O_BINARY | O_NOINHERIT) == -1)
         return   1;

      // Duplicate stdout handle (next line will close original)
      hStdOut = _dup(_fileno(stdout));

      // Duplicate write end of pipe to stdout handle
      if(_dup2(hStdOutPipe[WRITE_HANDLE], _fileno(stdout)) != 0)
         return   2;

      // Close original write end of pipe
      close(hStdOutPipe[WRITE_HANDLE]);

      // Spawn process
      hProcess = (HANDLE)spawnvp(P_NOWAIT, argv[1], 
       (const char* const*)&amp;argv[1]);

      // Duplicate copy of original stdout back into stdout
      if(_dup2(hStdOut, _fileno(stdout)) != 0)
         return   3;

      // Close duplicate copy of original stdout
      close(hStdOut);

      if(hProcess)
      {
         int nOutRead;
         while   (nExitCode == STILL_ACTIVE)
         {
            nOutRead = read(hStdOutPipe[READ_HANDLE], 
             szBuffer, OUT_BUFF_SIZE);
            if(nOutRead)
            {
               nOutRead = Filter(szBuffer, nOutRead, BEEP_CHAR);
               fwrite(szBuffer, 1, nOutRead, stdout);
            }

            if(!GetExitCodeProcess(hProcess,(unsigned long*)&amp;nExitCode))
               return 4;
         }
      }
   }

   printf("\nPress \'ENTER\' key to continue... ");
   getchar();
   return nExitCode;
}

</CODE></PRE>

<P><A HREF="_crt_process_and_environment_control.htm">Process and Environment Control Routines</A></P>

<P><B>See Also</B>&nbsp;&nbsp;&nbsp;<A HREF="_crt__open.2c_._wopen.htm">_open</A></P>
</font>
</BODY>
</HTML>
