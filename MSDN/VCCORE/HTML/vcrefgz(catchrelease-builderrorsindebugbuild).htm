<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>/GZ (Catch Release-Build Errors in Debug Build)</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>

<TABLE ALIGN=right WIDTH=0 BORDER=0><TR><TD>
<OBJECT ID="hhobj_1" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_vc_compiling_home">
</OBJECT>
</TD></TR></TABLE>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="vcrefgz(catchrelease-builderrorsindebugbuild)"></A>/GZ&nbsp;&nbsp;&nbsp;(Catch Release-Build Errors in Debug Build)</H1>

<P><A HREF="JavaScript:hhobj_1.Click()">Home</A>  |&nbsp; <A HREF="_core_overviews.3a_.compiling_and_linking.htm">Overview</A>  |&nbsp; <A HREF="_core_set_compiler_options.htm">How Do I</A>  |&nbsp; <A HREF="_core_compiler_reference.htm">Compiler Options</A></P>

<P>Some bugs normally arise only when you switch to a Release build (<B>/O1</B>, <B>/O2</B>, <B>/Ox</B>, or <B>/Og</B>). You can use the <B>/GZ</B> option to enable run-time checks to catch these bugs in a Debug (<B>/Od</B>) build. <B>/GZ</B> is not compatible with <B>/O1</B>, <B>/O2</B>, <B>/Ox</B>, or <B>/Og</B> builds.</P>

<P><B><B>Note:</B></B> Use of the <B>/GZ </B>option will disable any <CODE>#pragma optimize</CODE> statements in your code.</P>

<P>The <B>/GZ </B>option does the following:

<UL type=disc>
	<LI>Auto-initialization of local variables<BR><BR></LI>

	<LI>Function pointer call stack validation<BR><BR></LI>

	<LI>Call stack validation</LI>
</UL>

<P>See <A HREF="_core_creating_a_release_build.3a_.overview.htm">Creating a Release Build: Overview</A> for more information on going from Debug builds to Release builds.</P>

<H2>Auto-initialization of Local Variables</H2>

<P><B>/GZ</B> initializes all local variables not explicitly initialized by the program. It fills all memory used by these variables with 0xCC.</P>

<P>Assuming the stack is zero, code with uninitialized variables may fail with <B>/GZ</B>. Consider the following example. When compiled with <B>/Od</B> or <B>/Ox </B>without <B>/GZ</B>, this code may produce an access-violation exception, or it may appear to run correctly. When compiled with <B>/Gz /Od</B>, it always produces the exception. You can catch the exception in the debugger and get some hints about the exact location of failure. </P>

<PRE><CODE>#include &lt;stdio.h&gt;

void function1(char **pptr)
{
   printf("*pptr = 0x%X\n", *pptr);
   if(*pptr == NULL)
      *pptr = "Hello world\n";
}
void function2()
{
   int padding[10];          // force sub esp frame initialization
   char * p;               // p is uninitialized

   function1(&amp;p);
   puts(p);
}

void main()
{
   int padding[1000];        // Force clean stack page
   function2();
}
</CODE></PRE>

<H2>Function Pointer Call Stack Validation</H2>

<P>The stack pointer (ESP) is checked to make sure it is the same before and after the call through the function pointer. This can catch any mismatch between the calling function’s cleanup (<B>__cdecl</B>) calling convention and called function’s cleanup calling conventions (<B>__sdtcall</B>, <B>__fastcall</B>, <B>__thiscall</B>) when calling through a function pointer.</P>

<P>This example works with /Od, fails with /Ox and raises an exception with /GZ. You get an exception breakpoint pop-up if compiled with a release version of the run-time library and a more meaningful message when compiled with the debug version of the run-time library.</P>

<PRE><CODE>void __stdcall function1(char *p)
{
   puts(p);
}

typedef void (*PFUNC)(char *);

main()
{
   PFUNC pfunction1 = (PFUNC)function1;

   pfunction1("Hello world\n");
}
</CODE></PRE>

<P>A more realistic scenario occurs with <B>GetProcAddress</B>:</P>

<PRE><CODE>#include &lt;windows.h&gt;
void function1()
{
   typedef int (*FPTYPE)(int); // should be "int(__stdcall *)(int)"
   FPTYPE fp;
   int ret = 0;
   HINSTANCE hinst = LoadLibrary( "your.dll" );
   fp = (FPTYPE) GetProcAddress( hinst, "SomeFunc");

   ret = (*fp)(22);      // ESP invalid after this call.
                        // but it is caught upon return

   FreeLibrary( hinst );

   // and also caught at function exit
}
</CODE></PRE>

<P>Function pointer call stack validation will also catch cases where a function prototype has the incorrect number of parameters if the function uses the <B>__stdcall</B>, <B>__fastcall</B>, or <B>__thiscall</B> calling convention. <B>__cdecl</B> cases are not caught because the caller does both the pushes and the pops of parameters.</P>

<H2>Call Stack Validation</H2>

<P>The stack pointer (ESP) is checked at the end of the function to see that the stack pointer has not been changed. This can catch cases where ESP is corrupted in inline assembly or a non-pointer function's calling convention is declared incorrectly.</P>
</font>
</BODY>
</HTML>
