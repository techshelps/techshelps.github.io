<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Strings: CString Operations Relating to C-Style Strings</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>

<TABLE ALIGN=right WIDTH=0 BORDER=0><TR><TD>
<OBJECT ID="hhobj_1" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_vc_addpf_home">
</OBJECT>
<OBJECT ID="hhobj_2" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_MFC_CString">
</OBJECT>
</TD></TR></TABLE>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_core_strings.3a_.cstring_operations_relating_to_c.2d.style_strings"></A>Strings: CString Operations Relating to C-Style Strings</H1>

<P><A HREF="JavaScript:hhobj_1.Click()">Home</A>  |&nbsp; <A HREF="_core_strings.3a_.overview.htm">Overview</A>  |&nbsp; <A HREF="_core_string_handling_tasks.htm">How Do I</A></P>

<P>It is often useful to manipulate the contents of a <A HREF="JavaScript:hhobj_2.Click()">CString</A> object as if it were a C-style null-terminated string. This article covers the following topics:

<UL type=disc>
	<LI><A HREF="#_core_converting_to_c.2d.style_null.2d.terminated_strings">Converting to C-style null-terminated strings</A><BR><BR></LI>

	<LI><A HREF="#_core_working_with_standard_run.2d.time_library_string_functions">Working with standard run-time library string functions</A><BR><BR></LI>

	<LI><A HREF="#_core_modifying_cstring_contents_directly">Modifying CString contents directly</A><BR><BR></LI>

	<LI><A HREF="#_core_using_cstring_objects_with_variable_argument_functions">Using CString objects with variable argument functions</A><BR><BR></LI>

	<LI><A HREF="#_core_specifying_cstring_formal_parameters">Specifying CString formal parameters</A></LI>
</UL>



<H2><A NAME="_core_converting_to_c.2d.style_null.2d.terminated_strings"></A>Converting to C-Style Null-Terminated Strings</H2>

<P>Consider the following two cases:

<UL type=disc>
	<LI>In the simplest case, you can cast a <B>CString</B> object to be an <B>LPCTSTR</B>. The LPCTSTR type conversion operator returns a pointer to a read-only C-style null-terminated string from a <B>CString</B> object.
<P class=tl>The pointer returned by <B>LPCTSTR</B> points into the data area used by the <B>CString</B>. If the <B>CString</B> goes out of scope and is automatically deleted or something else changes the contents of the <B>CString</B>, the <B>LPCTSTR</B> pointer will no longer be valid. Treat the string to which the pointer points as temporary.</P></LI>

	<LI>You can use <B>CString</B> functions, such as <B>SetAt</B>, to modify individual characters in the string object. However, if you need a copy of a <B>CString</B> object’s characters that you can modify directly, use <B>strcpy</B> (or the Unicode/MBCS-portable <B>_tcscpy</B>) to copy the <B>CString</B> object into a separate buffer where the characters can be safely modified, as shown by the following example:
<PRE><CODE>CString theString( "This is a test" );
LPTSTR lpsz = new TCHAR[theString.GetLength()+1];
_tcscpy(lpsz, theString);
//... modify lpsz as much as you want
</CODE></PRE>

<P class=atl><B><B>Note</B></B>&nbsp;&nbsp;&nbsp;The second argument to <B>strcpy</B> (or the Unicode/MBCS-portable <B>_tcscpy</B>) is either a <B>const wchar_t*</B> (Unicode) or a <B>const char*</B> (ANSI). The example above passes a <B>CString</B> for this argument. The C++ compiler automatically applies the conversion function defined for the <B>CString</B> class that converts a <B>CString</B> to an <B>LPCTSTR</B>. The ability to define casting operations from one type to another is one of the most useful features of C++.</p></LI>
</UL>



<H2><A NAME="_core_working_with_standard_run.2d.time_library_string_functions"></A>Working with Standard Run-Time Library String Functions</H2>

<P>In most situations, you should be able to find <B>CString</B> member functions to perform any string operation for which you might consider using the standard C run-time library string functions, such as <B>strcmp</B> (or the Unicode/MBCS-portable <B>_tcscmp</B>).</P>

<P>If you need to use the C run-time string functions, you can use the techniques described in <A HREF="#_core_converting_to_c.2d.style_null.2d.terminated_strings">Converting to C-Style Null-Terminated Strings</A> to copy the <B>CString</B> object to an equivalent C-style string buffer, perform your operations on the buffer, and then assign the resulting C-style string back to a <B>CString</B> object.</P>



<H2><A NAME="_core_modifying_cstring_contents_directly"></A>Modifying CString Contents Directly</H2>

<P>In most situations, you should use <B>CString</B> member functions to modify the contents of a <B>CString</B> object or to convert the <B>CString</B> to a C-style character string.</P>

<P>However, there are certain situations, such as working with operating-system functions that require a character buffer, where it is advantageous to directly modify the <B>CString</B> contents.</P>

<P>The <B>GetBuffer</B> and <B>ReleaseBuffer</B> member functions allow you to gain access to the internal character buffer of a <B>CString</B> object and modify it directly. The following steps show how to use these functions for this purpose:

<OL>
	<LI>Call <B>GetBuffer</B> for a <B>CString</B> object, specifying the length of the buffer you require.<BR><BR></LI>

	<LI>Use the pointer returned by <B>GetBuffer</B> to write characters directly into the <B>CString</B> object.<BR><BR></LI>

	<LI>Call <B>ReleaseBuffer</B> for the <B>CString</B> object to update all the internal <B>CString</B> state information (such as the length of the string). After modifying a <B>CString</B> object’s contents directly, you must call <B>ReleaseBuffer</B> before calling any other <B>CString</B> member functions.</LI>
</OL>



<H2><A NAME="_core_using_cstring_objects_with_variable_argument_functions"></A>Using CString Objects with Variable Argument Functions</H2>

<P>Some C functions take a variable number of arguments. A notable example is <B>printf</B>. Because of the way this kind of function is declared, the compiler cannot be sure of the type of the arguments and cannot determine which conversion operation to perform on each argument. Therefore, it is essential that you use an explicit type cast when passing a <B>CString</B> object to a function that takes a variable number of arguments.</P>

<P class=label><B>To use a CString object in a variable argument function</B>

<UL type=disc>
	<LI>Explicitly cast the <B>CString</B> to an <B>LPCTSTR</B> string, as shown here:
<PRE><CODE>CString kindOfFruit = "bananas";
int        howmany = 25;
printf( "You have %d %s\n", howmany, (LPCTSTR)kindOfFruit ); 
</CODE></PRE>
</LI>
</UL>



<H2><A NAME="_core_specifying_cstring_formal_parameters"></A>Specifying CString Formal Parameters</H2>

<P>For most functions that need a string argument, it is best to specify the formal parameter in the function prototype as a <B>const</B> pointer to a character (<B>LPCTSTR</B>) instead of a <B>CString</B>. When a formal parameter is specified as a <B>const</B> pointer to a character, you can pass either a pointer to a <B>TCHAR</B> array, a literal string [<CODE>"hi there"</CODE>], or a <B>CString</B> object. The <B>CString</B> object will be automatically converted to an <B>LPCTSTR</B>. Any place you can use an <B>LPCTSTR</B>, you can also use a <B>CString</B> object.</P>

<P>You can also specify a formal parameter as a constant string reference (that is, <B>const CString&amp;</B>) if the argument will not be modified. Drop the <B>const</B> modifier if the string will be modified by the function. If a default null value is desired, initialize it to the null string [<CODE>""</CODE>], as shown below:</P>

<PRE><CODE>void AddCustomer( const CString&amp; name,
                    const CString&amp; address,
                    const CString&amp; comment = "" ); 
</CODE></PRE>

<P>For most function results, you can simply return a <B>CString</B> object by value.</P>

<P><B>See Also</B>&nbsp;&nbsp;&nbsp;<A HREF="_core_strings.3a_.cstring_argument_passing.htm">Strings: CString Argument Passing</A> </P>
</font>
</BODY>
</HTML>
