<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using the Debug Heap</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_core_using_the_debug_heap"></A>Using the Debug Heap</H1>

<P>To use the debug heap, link the debug build of your application with a debug version of the C run-time library. All calls to heap functions such as <B>malloc</B>, <B>free</B>, <B>calloc</B>, <B>realloc</B>, <B>new</B>,<B> </B>and <B>delete</B> resolve to debug versions of those functions that operate in the debug heap. When you free a memory block, the debug heap automatically checks the integrity of the buffers on either side of your allocated area and issues an error report if overwriting has occurred.</P>

<P>Many of the debug heap’s features, however, must be accessed from within your code. You can use a call to <B>_CrtCheckMemory</B>, for example, to check the heap’s integrity at any point. This function inspects every memory block in the heap, verifies that the memory block header information is valid, and confirms that the buffers have not been modified. You can control how the debug heap keeps track of allocations using an internal flag, <B>_crtDbgFlag</B>, which can be read and set using the <B>_CrtSetDbgFlag </B>function. By changing this flag, you can instruct the debug heap to check for memory leaks when the program exits, and report any leaks that are detected. Similarly, you can specify that freed memory blocks not be removed from the linked list, to simulate low-memory situations. When the heap is checked, these freed blocks are inspected in their entirety to ensure that they have not been disturbed.</P>

<P>The <B>_crtDbgFlag</B> flag contains the following bit fields:</P>

<TABLE border=1 cellpadding=5 cols=3 frame=below rules=rows>

<TR VALIGN="top">
<TD class=label width=29%><B>Bit Field</B></TD>
<TD class=label width=13%><B>Value</B></TD>
<TD class=label width=58%><B>Description</B></TD>
</TR>

<TR VALIGN="top">
<TD width=29%><B>_CRTDBG_ALLOC_MEM_DF</B></TD>
<TD width=13%>On</TD>
<TD width=58%>Turns on debug allocation. When this bit is off, allocations remain chained together but their block type is <B>_IGNORE_BLOCK</B>.</TD>
</TR>

<TR VALIGN="top">
<TD width=29%><B>_CRTDBG_DELAY_FREE_MEM_DF</B></TD>
<TD width=13%>Off</TD>
<TD width=58%>Prevents memory from actually being freed, as for simulating low-memory conditions. When this bit is on, freed blocks are kept in the debug heap’s linked list but are marked as <B>_FREE_BLOCK</B> and filled with a special byte value.</TD>
</TR>

<TR VALIGN="top">
<TD width=29%><B>_CRTDBG_CHECK_ALWAYS_DF</B></TD>
<TD width=13%>Off</TD>
<TD width=58%>Causes <B>_CrtCheckMemory</B> to be called at every allocation and deallocation. This slows execution, but catches errors quickly.</TD>
</TR>

<TR VALIGN="top">
<TD width=29%><B>_CRTDBG_CHECK_CRT_DF</B></TD>
<TD width=13%>Off</TD>
<TD width=58%>Causes blocks marked as type <B>_CRT_BLOCK</B> to be included in leak-detection and state-difference operations. When this bit is off, the memory used internally by the run-time library is ignored during such operations.</TD>
</TR>

<TR VALIGN="top">
<TD width=29%><B>_CRTDBG_LEAK_CHECK_DF</B></TD>
<TD width=13%>Off</TD>
<TD width=58%>Causes leak checking to be performed at program exit via a call to <A HREF="_crt__crtdumpmemoryleaks.htm">_CrtDumpMemoryLeaks</A>. An error report is generated if the application has failed to free all the memory that it allocated.</TD>
</TR>
</TABLE><BR>

<P>To change one or more of these bit fields and create a new state for the flag, follow these steps:

<OL>
	<LI>Call <B>_CrtSetDbgFlag</B> with the <I>newFlag</I> parameter set to <B>_CRTDBG_REPORT_FLAG</B> to obtain the current <B>_crtDbgFlag</B> state and store the returned value in a temporary variable.<BR><BR></LI>

	<LI>Turn on any bits by <B>OR</B>-ing (bitwise | symbol) the temporary variable with the corresponding bitmasks (represented in the application code by manifest constants).<BR><BR></LI>

	<LI>Turn off the other bits by <B>AND</B>-ing (bitwise &amp; symbol) the variable with a <B>NOT</B> (bitwise ~ symbol) of the appropriate bitmasks.<BR><BR></LI>

	<LI>Call <B>_CrtSetDbgFlag</B> with the <I>newFlag</I> parameter set to the value stored in the temporary variable to create the new state for <B>_crtDbgFlag</B>.</LI>
</OL>

<P>For example, the following lines of code turn on automatic leak detection and turn off checking for blocks of type <B>_CRT_BLOCK</B>:</P>

<PRE><CODE>// Get current flag
int tmpFlag = _CrtSetDbgFlag( _CRTDBG_REPORT_FLAG );

// Turn on leak-checking bit
tmpFlag |= _CRTDBG_LEAK_CHECK_DF;

// Turn off CRT block checking bit
tmpFlag &amp;= ~_CRTDBG_CHECK_CRT_DF;

// Set flag to the new value
_CrtSetDbgFlag( tmpFlag );
</CODE></PRE>
</font>
</BODY>
</HTML>
