<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using Macros for Verification and Reporting</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_core_using_macros_for_verification_and_reporting"></A>Using Macros for Verification and Reporting</H1>

<P>A common way of keeping track of what is going on in an application during the debugging process is to use <A HREF="_crt_printf.2c_.wprintf.htm">printf</A> statements in code such as the following:</P>

<PRE><CODE>#ifdef _DEBUG
   if ( someVar &gt; MAX_SOMEVAR )
      printf( "OVERFLOW! In NameOfThisFunc( ),
               someVar=%d, otherVar=%d.\n", 
               someVar, otherVar );
#endif
</CODE></PRE>

<P>The <B>_ASSERT</B>, <B>_ASSERTE</B>, <B>_RPTn</B>, and <B>_RPTFn</B> macros defined in the CRTDBG.H header file provide a variety of more concise and flexible ways to accomplish the same task. These macros automatically disappear in your release build when <B>_DEBUG</B> is not defined, so there is no need to enclose them in <B>#ifdef</B>s. For debug builds, they provide a range of reporting options that can be directed to one of several debugging destinations. The following table summarizes these options:</P>

<TABLE border=1 cellpadding=5 cols=2 frame=below rules=rows>

<TR VALIGN="top">
<TD class=label width=37%><B>Macro</B></TD>
<TD class=label width=63%><B>Reporting Option</B></TD>
</TR>

<TR VALIGN="top">
<TD width=37%><B>_ASSERT</B></TD>
<TD width=63%>If an asserted expression evaluates to FALSE, the macro reports the file name and line number of the <B>_ASSERT</B>, under the <B>_CRT_ASSERT</B> report category.</TD>
</TR>

<TR VALIGN="top">
<TD width=37%><B>_ASSERTE</B></TD>
<TD width=63%>Same as <B>_ASSERT</B>, except that it also reports a string representation of the expression that was asserted to be true but was evaluated to be false.</TD>
</TR>

<TR VALIGN="top">
<TD width=37%><B>_RPTn<BR>
</B>(where <B>n</B> is 0, 1, 2, 3, or 4)</TD>
<TD width=63%>These five macros send a message string and from zero to four arguments to the report category of your choice. In the cases of macros <B>_RPT1</B> through <B>_RPT4</B>, the message string serves as a <A HREF="_crt_printf.2c_.wprintf.htm">printf</A>-style formatting string for the arguments.</TD>
</TR>

<TR VALIGN="top">
<TD width=37%><B>_RPTFn<BR>
</B>(where <B>n</B> is 0, 1, 2, 3, or 4)</TD>
<TD width=63%>Same as <B>_RPTn</B> , except that these macros also include in each report the file name and line number at which the macro was executed.</TD>
</TR>
</TABLE><BR>

<P>Asserts are used to check specific assumptions you make in your code. <B>_ASSERTE</B> is a little more convenient to use because it reports the asserted expression that turned out to be false. Often this tells you enough to identify the problem without going back to your source code. A disadvantage, however, is that every expression asserted using <B>_ASSERTE</B> must be included in the debug version of your application as a string constant. If you use so many asserts that these string expressions take up a significant amount of memory, you may prefer to use <B>_ASSERT</B> instead.</P>

<P>Examining the definitions of these macros in the CRTDBG.H header file can give you a detailed understanding of how they work. When <B>_DEBUG</B> is defined, for example, the <B>_ASSERTE</B> macro is defined essentially as follows:</P>

<PRE><CODE>#define _ASSERTE(expr) \
   do { \
      if (!(expr) &amp;&amp; (1 == _CrtDbgReport( \
          _CRT_ASSERT, __FILE__, __LINE__, #expr))) \
         _CrtDbgBreak(); \
    } while (0)
</CODE></PRE>

<P>If <I>expr </I>evaluates to TRUE, execution continues uninterrupted, but if <I>expr </I>evaluates to FALSE, <B>_CrtDbgReport </B>is called to report the assertion failure. If the destination is a message window in which you choose Retry, <B>_CrtDbgReport </B>returns 1 and <B>_CrtDbgBreak </B>calls the debugger.</P>

<P>A single call to <B>_ASSERTE</B> could be used to replace the <B>printf</B> code at the beginning of this topic:</P>

<PRE><CODE>_ASSERTE(someVar &lt;= MAX_SOMEVAR);
</CODE></PRE>

<P>If <B>_CRT_ASSERT</B> reports were being directed to message boxes (the default) or to the debugger, then program execution would be interrupted when <CODE>someVar</CODE> exceeded <CODE>MAX_SOMEVAR</CODE>.</P>

<P>Asserts can also be used as a simple debugging error-handling mechanism for any function that returns FALSE when it fails. For example, in the following code, the assertion will fail if corruption is detected in the heap:</P>

<PRE><CODE>_ASSERTE(_CrtCheckMemory());
</CODE></PRE>

<P>The following memory-checking functions can be used in asserts of this kind to verify pointers, memory ranges, and specific memory blocks:</P>

<P class=dt><A HREF="_crt__crtisvalidheappointer.htm">_CrtIsValidHeapPointer</A></P>

<P class=indent>Verifies that a given pointer points to memory in the local heap; “local” here refers to the particular heap created and managed by this instance of the C run-time library. A dynamic-link library (DLL) could have its own instance of the library, and therefore its own heap, independent of your application’s local heap. Note that this routine catches not only null or out-of-bounds addresses, but also pointers to static variables, stack variables, and any other nonlocal memory.</P>

<P class=dt><A HREF="_crt__crtisvalidpointer.htm">_CrtIsValidPointer</A></P>

<P class=indent>Verifies that a given memory range is valid for reading or writing.</P>

<P class=dt><A HREF="_crt__crtismemoryblock.htm">_CrtIsMemoryBlock</A></P>

<P class=indent>Verifies that a specified block of memory is in the “local” heap and has a valid block type. This function can actually do more than check a block’s validity, however. If you pass it non-null values for the request number, file name and/or line number, it sets the value in the block’s header accordingly.</P>

<P>For more information on how these and other assertion-checking routines can be used during the debugging process, see <A HREF="_core_debugging_assertions.htm">Debugging Assertions</A>.</P>

<P>The <A HREF="_crt_printf.2c_.wprintf.htm">printf</A> code at the start of this topic reported actual values of <CODE>someVar</CODE> and <CODE>otherVar</CODE> to <B>stdout</B>. If these values were useful in the debugging process, one of the <B>_RPTn</B> or <B>_RPTFn</B> macros could be used to report them. The <B>_RPTF2</B> macro, for example, is defined essentially as follows in CRTDBG.H:</P>

<PRE><CODE>#define _RPTF2(rptno, msg, arg1, arg2) \
   do { \
      if (1 == _CrtDbgReport(rptno, __FILE__, \
              __LINE__, msg, arg1, arg2)) \
         _CrtDbgBreak(); \
   } while (0)
</CODE></PRE>

<P>The following call to <B>_RPTF2</B> would report the values of <CODE>someVar</CODE> and <CODE>otherVar</CODE>, together with the file name and line number, every time the function that contained the macro was executed:</P>

<PRE><CODE>_RPTF2(_CRT_WARN, "In NameOfThisFunc( ), someVar= %d,
       otherVar= %d\n", someVar, otherVar);
</CODE></PRE>

<P>Of course, you may only be interested in knowing the values of <CODE>someVar</CODE> and <CODE>otherVar</CODE> under the circumstance that <CODE>someVar</CODE> has exceeded its maximum permitted value. By using an assert, as described above, you could halt program execution and then use the debugger to examine the values of these variables. Alternatively, you could use a variation of the original <B>printf</B> code, enclosing a conditional call to the <B>_RPTF2</B> macro in <B>#ifdef</B>s:</P>

<PRE><CODE>#ifdef _DEBUG
   if (someVar &gt; MAX_SOMEVAR)
      _RPTF2(_CRT_WARN, 
"In NameOfThisFunc( ), someVar= %d, otherVar= %d\n", 
             someVar, otherVar );
#endif
</CODE></PRE>

<P>Of course, if you find that a particular application needs a kind of debug reporting that the macros supplied with the C run-time library do not provide, you can write a macro designed specifically to fit your own requirements. In one of your header files, for example, you could include code like the following to define a macro called <B>ALERT_IF2</B>:</P>

<PRE><CODE>#ifndef _DEBUG                /* For RELEASE builds */
#define  ALERT_IF2(expr, msg, arg1, arg2)  ((void)0)
#else                         /* For DEBUG builds   */
#define  ALERT_IF2(expr, msg, arg1, arg2) \
   do { \
      if ((expr) &amp;&amp; \
          (1 == _CrtDbgReport(_CRT_ERROR, \
               __FILE__, __LINE__, msg, arg1, arg2))) \
         _CrtDbgBreak( ); \
   } while (0)
#endif
</CODE></PRE>

<P>One call to <B>ALERT_IF2</B> could perform all the functions of the <B>printf </B>code at the start of this topic:</P>

<PRE><CODE>ALERT_IF2(someVar &gt; MAX_SOMEVAR, "OVERFLOW! In NameOfThisFunc( ), someVar=%d, otherVar=%d.\n", someVar, otherVar );
</CODE></PRE>

<P>This approach can be particularly useful as your debugging requirements evolve, because a custom macro can easily be changed to report more or less information to different destinations, depending on what is more convenient.</P>
</font>
</BODY>
</HTML>
