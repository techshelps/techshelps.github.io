<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IEEE Floating-Point Representation and Microsoft Languages</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>

<TABLE ALIGN=right WIDTH=0 BORDER=0><TR><TD>
<OBJECT ID="hhobj_1" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_vc_compiling_home">
</OBJECT>
<OBJECT ID="hhobj_2" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="vceditions">
</OBJECT>
</TD></TR></TABLE>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_core_ieee_floating.2d.point_representation_and_microsoft_languages"></A>IEEE Floating-Point Representation and Microsoft Languages</H1>

<P><A HREF="JavaScript:hhobj_1.Click()">Home</A>  |&nbsp; <A HREF="_core_optimizing_your_code.3a_.overview.htm">Overview</A>  |&nbsp; <A HREF="_core_optimize_a_program.htm">How Do I</A></P>

<P class=indent><B><B>Feature Only in Professional and Enterprise Editions</B></B>&nbsp;&nbsp;&nbsp;Code optimization is supported only in Visual C++ Professional and Enterprise Editions. For more information, see <A HREF="JavaScript:hhobj_2.Click()">Visual C++ Editions</A>.</P>

<P>Microsoft Visual C++ is consistent with the IEEE numeric standards. There are three internal varieties of real numbers. Real*4 and real*8 are used in Visual C++. Real*4 is declared using the word <B>float</B>. Real*8 is declared using the word <B>double</B>. In Windows 32-bit programming, the <B>long double</B> data type maps to <B>double</B>. There is, however, assembly language support for computations using the real*10 data type.</P>

<P>The values are stored as follows:</P>

<TABLE border=1 cellpadding=5 cols=2 frame=below rules=rows>

<TR VALIGN="top">
<TD class=label width=16%><B>Value</B></TD>
<TD class=label width=84%><B>Stored as</B></TD>
</TR>

<TR VALIGN="top">
<TD width=16%>real*4</TD>
<TD width=84%>sign bit, 8-bit exponent, 23-bit mantissa</TD>
</TR>

<TR VALIGN="top">
<TD width=16%>real*8</TD>
<TD width=84%>sign bit, 11-bit exponent, 52-bit mantissa</TD>
</TR>

<TR VALIGN="top">
<TD width=16%>real*10</TD>
<TD width=84%>sign bit, 15-bit exponent, 64-bit mantissa</TD>
</TR>
</TABLE><BR>

<P>In real*4 and real*8 formats, there is an assumed leading 1 in the mantissa that is not stored in memory, so the mantissas are actually 24 or 53 bits, even though only 23 or 52 bits are stored. The real*10 format actually stores this bit.</P>

<P>The exponents are biased by half of their possible value. This means you subtract this bias from the stored exponent to get the actual exponent. If the stored exponent is less than the bias, it is actually a negative exponent.</P>

<P>The exponents are biased as follows:</P>

<TABLE border=1 cellpadding=5 cols=2 frame=below rules=rows>

<TR VALIGN="top">
<TD class=label width=26%><B>Exponent</B></TD>
<TD class=label width=74%><B>Biased by</B></TD>
</TR>

<TR VALIGN="top">
<TD width=26%>8-bit&nbsp; (real*4)</TD>
<TD width=74%>127</TD>
</TR>

<TR VALIGN="top">
<TD width=26%>11-bit (real*8)</TD>
<TD width=74%>1023</TD>
</TR>

<TR VALIGN="top">
<TD width=26%>15-bit (real*10)</TD>
<TD width=74%>16383</TD>
</TR>
</TABLE><BR>

<P>These exponents are not powers of ten; they are powers of two. That is, 8-bit stored exponents can be up to 127. The value 2**127 is roughly equivalent to 10**38, which is the actual limit of real*4.</P>

<P>The mantissa is stored as a binary fraction of the form 1.XXX... . This fraction has a value greater than or equal to 1 and less than 2. Note that real numbers are always stored in normalized form; that is, the mantissa is left-shifted such that the high-order bit of the mantissa is always 1. Because this bit is always 1, it is assumed (not stored) in the real*4 and real*8 formats. The binary (not decimal) point is assumed to be just to the right of the leading 1.</P>

<P>The format, then, for the various sizes is as follows:</P>

<TABLE border=1 cellpadding=5 cols=7 frame=below rules=rows>

<TR VALIGN="top">
<TD class=label width=10%>&nbsp;</TD>
<TD class=label width=16%><B>BYTE 1</B></TD>
<TD class=label width=16%><B>BYTE 2</B></TD>
<TD class=label width=17%><B>BYTE 3</B></TD>
<TD class=label width=15%><B>BYTE 4</B></TD>
<TD class=label width=7%><B>...</B></TD>
<TD class=label width=19%><B>BYTE n</B></TD>
</TR>

<TR VALIGN="top">
<TD width=10%>real*4</TD>
<TD width=16%><CODE>XXXX XXXX</CODE></TD>
<TD width=16%><CODE>XMMM MMMM</CODE></TD>
<TD width=17%><CODE>MMMM MMMM</CODE></TD>
<TD width=15%><CODE>MMMM MMMM</CODE></TD>
<TD width=7%>&nbsp;</TD>
<TD width=19%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=10%>real*8</TD>
<TD width=16%><CODE>SXXX XXXX</CODE></TD>
<TD width=16%><CODE>XXXX MMMM</CODE></TD>
<TD width=17%><CODE>MMMM MMMM</CODE></TD>
<TD width=15%><CODE>MMMM MMMM</CODE></TD>
<TD width=7%>...</TD>
<TD width=19%><CODE>MMMM MMMM</CODE></TD>
</TR>

<TR VALIGN="top">
<TD width=10%>real*10</TD>
<TD width=16%><CODE>SXXX XXXX</CODE></TD>
<TD width=16%><CODE>XXXX XXXX</CODE></TD>
<TD width=17%><CODE>1MMM MMMM</CODE></TD>
<TD width=15%><CODE>MMMM MMMM</CODE></TD>
<TD width=7%>...</TD>
<TD width=19%><CODE>MMMM MMMM</CODE></TD>
</TR>
</TABLE><BR>

<P><CODE>S</CODE> represents the sign bit, the <CODE>X</CODE>'s are the exponent bits, and the <CODE>M</CODE>'s are the mantissa bits. Note that the leftmost bit is assumed in real*4 and real*8 formats, but present as "1" in BYTE 3 of the real*10 format.</P>

<P>To shift the binary point properly, you first un-bias the exponent and then move the binary point to the right or left the appropriate number of bits.</P>

<P>The following are some examples in real*4 format:</P>

<PRE><CODE>                    SXXX XXXX XMMM MMMM ... MMMM MMMM
2   =  1  * 2**1  = 0100 0000 0000 0000 ... 0000 0000 = 4000 0000</CODE></PRE>

<P>Note the sign bit is zero, and the stored exponent is 128, or 100 0000 0 in binary, which is 127 plus 1. The stored mantissa is (1.) 000 0000 ... 0000 0000, which has an implied leading 1 and binary point, so the actual mantissa is one.</P>

<PRE><CODE>-2  = -1  * 2**1  = 1100 0000 0000 0000 ... 0000 0000 = C000 0000</CODE></PRE>

<P>Same as +2 except that the sign bit is set. This is true for all IEEE format floating-point numbers.</P>

<PRE><CODE> 4  =  1  * 2**2  = 0100 0000 1000 0000 ... 0000 0000 = 4080 0000</CODE></PRE>

<P>Same mantissa, exponent increases by one (biased value is 129, or 100 0000 1 in binary.</P>

<PRE><CODE>6  = 1.5 * 2**2  = 0100 0000 1100 0000 ... 0000 0000 = 40C0 0000</CODE></PRE>

<P>Same exponent, mantissa is larger by half—it's (1.) 100 0000 ...0000 0000, which, since this is a binary fraction, is 1 1/2 (the values of the fractional digits are 1/2, 1/4, 1/8, and so forth).</P>

<PRE><CODE>1  = 1   * 2**0  = 0011 1111 1000 0000 ... 0000 0000 = 3F80 0000</CODE></PRE>

<P>Same exponent as other powers of two, mantissa is one less than two at 127, or 011 1111 1 in binary.</P>

<PRE><CODE>.75 = 1.5 * 2**-1 = 0011 1111 0100 0000 ... 0000 0000 = 3F40 0000</CODE></PRE>

<P>The biased exponent is 126, 011 1111 0 in binary, and the mantissa is (1.) 100 0000 ... 0000 0000, which is 1 1/2.</P>

<PRE><CODE>2.5 = 1.25 * 2**1 = 0100 0000 0010 0000 ... 0000 0000 = 4020 0000</CODE></PRE>

<P>Exactly the same as two except that the bit that represents 1/4 is set in the mantissa.</P>

<PRE><CODE>0.1 = 1.6 * 2**-4 = 0011 1101 1100 1100 ... 1100 1101 = 3DCC CCCD</CODE></PRE>

<P>1/10 is a repeating fraction in binary. The mantissa is just shy of 1.6, and the biased exponent says that 1.6 is to be divided by 16 (it is 011 1101 1 in binary, which is 123 in decimal). The true exponent is 123 – 127 = –4, which means that the factor by which to multiply is 2**–4 = 1/16. Note that the stored mantissa is rounded up in the last bit—an attempt to represent the unrepresentable number as accurately as possible. (The reason that 1/10 and 1/100 are not exactly representable in binary is similar to the reason that 1/3 is not exactly representable in decimal.)</P>

<PRE><CODE>0  = 1.0 * 2**-128 = all zero's--a special case.</CODE></PRE>
</font>
</BODY>
</HTML>
