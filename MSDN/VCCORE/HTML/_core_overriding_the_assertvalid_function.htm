<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Overriding the AssertValid Function</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_core_overriding_the_assertvalid_function"></A>Overriding the AssertValid Function</H1>

<P>The <B>AssertValid</B> member function is provided in <B>CObject</B> to allow run-time checks of an object’s internal state. <B>AssertValid</B> typically performs assertions on all the object’s member variables to see if they contain valid values. For example, <B>AssertValid</B> can check that all pointer member variables are not <B>NULL</B>. If the object is invalid, <B>AssertValid</B> halts the program.</P>

<P>Although you are not required to override <B>AssertValid</B> when you derive your class from <B>CObject</B>, you can make your class safer and more reliable by doing so. The following example shows how to declare the <B>AssertValid</B> function in the class declaration:</P>

<PRE><CODE>class CPerson : public CObject
{
protected:    
    CString m_strName;
    float   m_salary; 
public:
#ifdef _DEBUG
    virtual void AssertValid() const;    // Override
#endif
    // ...
};
</CODE></PRE>

<P>When you override <CODE>AssertValid</CODE>, first call <B>AssertValid</B> for the base class. Then use the <B>ASSERT</B> macro to check the validity of the members unique to your derived class, as shown by the following example:</P>

<PRE><CODE>#ifdef _DEBUG
void CPerson::AssertValid() const
{
    // call inherited AssertValid first
    CObject::AssertValid();

    // check CPerson members...
    ASSERT( !m_strName.IsEmpty()); // Must have a name
    ASSERT( m_salary &gt; 0 ); // Must have an income
} 
#endif
</CODE></PRE>

<P>If any of the member variables of your class store objects, you can use the <B>ASSERT_VALID</B> macro to test their internal validity (if their classes override <B>AssertValid</B>). The following example shows how this is done.</P>

<P>Consider a class <CODE>CMyData</CODE>, which stores a <B>CObList</B> in one of its member variables. The <B>CObList</B> variable, <CODE>m_DataList</CODE>, stores a collection of <CODE>CPerson</CODE> objects. An abbreviated declaration of <CODE>CMyData</CODE> looks like this:</P>

<PRE><CODE>class CMyData : public CObject
{
    // Constructor and other members ...
    protected:
        CObList* m_pDataList;
    // Other declarations ...
    public:
#ifdef _DEBUG
        virtual void AssertValid( ) const; // Override
#endif
    // Etc. ...
};
</CODE></PRE>

<P>The <B>AssertValid</B> override in <CODE>CMyData</CODE> looks like this:</P>

<PRE><CODE>#ifdef _DEBUG
void CMyData::AssertValid( ) const
{
    // Call inherited AssertValid
    CObject::AssertValid( );
    // Check validity of CMyData members
    ASSERT_VALID( m_pDataList );
    // ...
}
#endif
</CODE></PRE>

<P><CODE>CMyData</CODE> uses the <B>AssertValid</B> mechanism to add validity tests for the objects stored in its data member to the validity test of the <CODE>CMyData</CODE> object itself. The overriding <B>AssertValid</B> of <CODE>CMyData</CODE> invokes the <B>ASSERT_VALID</B> macro for its own <B>m_pDataList</B> member variable.</P>

<P>The chain of validity testing might stop at this level, but in this case class <B>CObList</B> overrides <B>AssertValid</B> too, and the <B>ASSERT_VALID</B> macro causes it to be called. This override performs additional validity testing on the internal state of the list. If an assertion failure occurs, diagnostic messages are printed, and the program halts. </P>

<P>Thus, a validity test on a <CODE>CMyData</CODE> object leads to additional validity tests for the internal states of the stored <B>CObList</B> list object. With a little more work, the validity tests could include the <CODE>CPerson</CODE> objects stored in the list as well. You could derive a class <CODE>CPersonList</CODE> from <B>CObList</B> and override <B>AssertValid</B>. In the override, you would call <B>CObject::AssertValid</B> and then iterate through the list, calling <CODE>AssertValid</CODE> on each <CODE>CPerson</CODE> object stored in the list. The <CODE>CPerson</CODE> class shown at the beginning of this topic already overrides <B>AssertValid</B>.</P>

<P>This is a powerful mechanism when you build for debugging. When you subsequently build for release, the mechanism is turned off automatically.</P>

<P>Users of an <CODE>AssertValid</CODE> function of a given class should be aware of the limitations of this function. A triggered assertion indicates that the object is definitely bad and execution will halt. However, a lack of assertion only indicates that no problem was found, but the object isn’t guaranteed to be good.</P>
</font>
</BODY>
</HTML>
