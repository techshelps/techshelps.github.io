<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Unicode Programming Summary</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>

<TABLE ALIGN=right WIDTH=0 BORDER=0><TR><TD>
<OBJECT ID="hhobj_1" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_vc_addpf_home">
</OBJECT>
</TD></TR></TABLE>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_core_unicode_programming_summary"></A><SUP></SUP>Unicode Programming Summary</H1>

<P><A HREF="JavaScript:hhobj_1.Click()">Home</A>  |&nbsp; <A HREF="_core_unicode_programming_tasks.htm">Unicode Tasks</A>  |&nbsp; <A HREF="_core_multibyte_character_set_.28.mbcs.29_.tasks.htm">Multibyte Character Set (MBCS) Tasks</A></P>

<P>To take advantage of the MFC and C run-time support for Unicode, you need to:

<UL type=disc>
	<LI>Define <B>_UNICODE</B>.
<P class=tl>Define the symbol <B>_UNICODE</B> before you build your program.</P></LI>

	<LI>Specify entry point.
<P class=tl>In the Output category of the Link tab in the Project Settings dialog box, set the Entry Point Symbol to <B>wWinMainCRTStartup</B>.</P></LI>

	<LI>Use “portable” run-time functions and types.
<P class=tl>Use the proper C run-time functions for Unicode string handling. You can use the <B>wcs</B> family of functions, but you may prefer the fully “portable” (internationally enabled) <B>_TCHAR</B> macros. These macros are all prefixed with <B>_tcs</B>; they substitute, one for one, for the <B>str</B> family of functions. These functions are described in detail in the <A HREF="_crt_internationalization.htm">Internationalization</A> section of the <I>Run-Time Library Reference</I>. For more information, see <A HREF="_core_generic.2d.text_mappings_in_tchar..h.htm">Generic-Text Mappings in TCHAR.H</A>. </P>
<P class=tl>Use <B>_TCHAR</B> and the related portable data types described in <A HREF="_core_support_for_unicode.htm">Support for Unicode</A>.</P></LI>

	<LI>Handle literal strings properly.
<P class=tl>The Visual C++ compiler interprets a literal string coded as</P>
<PRE><CODE>L"this is a literal string"
</CODE></PRE>

<P class=tl>to mean a string of Unicode characters. You can use the same prefix for literal characters. Use the <B>_T</B> macro to code literal strings generically, so they compile as Unicode strings under Unicode or as ANSI strings (including MBCS) without Unicode. For example, instead of:</P>
<PRE><CODE>pWnd-&gt;SetWindowText( “Hello” );
</CODE></PRE>

<P class=tl>use:</P>
<PRE><CODE>pWnd-&gt;SetWindowText( _T(“Hello”) );
</CODE></PRE>

<P class=tl>With <B>_UNICODE</B> defined, <B>_T</B> translates the literal string to the L-prefixed form; otherwise, <B>_T</B> translates the string without the L prefix.</P>
<P class=atl><B><B>Tip</B></B>&nbsp;&nbsp;&nbsp;The <B>_T</B> macro is identical to the <B>_TEXT</B> macro.</p></LI>

	<LI>Be careful passing string lengths to functions.
<P class=tl>Some functions want the number of characters in a string; others want the number of bytes. For example, if <B>_UNICODE</B> is defined, the following call to a <B>CArchive</B> object will not work (<CODE>str</CODE> is a <B>CString</B>):</P>
<PRE><CODE>archive.Write( str, str.GetLength( ) );    // invalid
</CODE></PRE>

<P class=tl>In a Unicode application, the length gives you the number of characters but not the correct number of bytes, since each character is two bytes wide. Instead, you must use:</P>
<PRE><CODE>archive.Write( str, str.GetLength( ) * sizeof( _TCHAR ) );    // valid
</CODE></PRE>

<P class=tl>which specifies the correct number of bytes to write.</P>
<P class=tl>However, MFC member functions that are character-oriented, rather than byte-oriented, work without this extra coding:</P>
<PRE><CODE>pDC-&gt;TextOut( str, str.GetLength( ) );
</CODE></PRE>

<P class=tl><B>CDC::TextOut</B> takes a number of characters, not a number of bytes.</P></LI>
</UL>

<P>To summarize, MFC and the run-time library provide the following support for Unicode programming under Windows NT:

<UL type=disc>
	<LI>Except for database class member functions, all MFC functions are Unicode-enabled, including <B>CString</B>. <B>CString</B> also provides Unicode/ANSI conversion functions.<BR><BR></LI>

	<LI>The run-time library supplies Unicode versions of all string-handling functions. (The run-time library also supplies “portable” versions suitable for Unicode or for MBCS. These are the <B>_tcs</B> macros.)<BR><BR></LI>

	<LI>TCHAR.H supplies portable data types and the <B>_T</B> macro for translating literal strings and characters. See <A HREF="_core_generic.2d.text_mappings_in_tchar..h.htm">Generic-Text Mappings in TCHAR.H</A>.<BR><BR></LI>

	<LI>The run-time library provides a wide-character version of <B>main</B>. Use <B>wmain</B> to make your application “Unicode-aware.”</LI>
</UL>
</font>
</BODY>
</HTML>
