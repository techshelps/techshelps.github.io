<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Recordset: Dynamically Binding Data Columns (ODBC)</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>

<TABLE ALIGN=right WIDTH=0 BORDER=0><TR><TD>
<OBJECT ID="hhobj_1" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_vc_addpf_home">
</OBJECT>
<OBJECT ID="hhobj_2" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="Enroll tutorial">
</OBJECT>
<OBJECT ID="hhobj_3" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_sample_mfc_DYNABIND">
</OBJECT>
<OBJECT ID="hhobj_4" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_sample_mfc_CATALOG">
</OBJECT>
<OBJECT ID="hhobj_5" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_sample_mfc_CATALOG">
</OBJECT>
<OBJECT ID="hhobj_6" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_sample_mfc_CATALOG">
</OBJECT>
<OBJECT ID="hhobj_7" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_sample_mfc_DYNABIND">
</OBJECT>
<OBJECT ID="hhobj_8" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_mfc_MFC_Macros_and_Globals">
</OBJECT>
<OBJECT ID="hhobj_9" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_sample_mfc_DYNABIND">
</OBJECT>
</TD></TR></TABLE>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_core_recordset.3a_.dynamically_binding_data_columns_.28.odbc.29"></A>Recordset: Dynamically Binding Data Columns (ODBC)</H1>

<P><A HREF="JavaScript:hhobj_1.Click()">Home</A>  |&nbsp; <A HREF="_core_databases.3a_.overview.htm">Overview</A>  |&nbsp; <A HREF="_core_odbc_database_tasks.htm">How Do I</A>  |&nbsp; <A HREF="_core_databases.3a_.frequently_asked_questions.htm">FAQ</A>  |&nbsp; <A HREF="_core_odbc_database_sample_list.htm">Sample</A>  |&nbsp; <A HREF="JavaScript:hhobj_2.Click()">Tutorial</A>  |&nbsp; <A HREF="_core_odbc_driver_list.htm">ODBC Driver List</A></P>

<P>This article applies to the MFC ODBC classes. For DAO recordsets, see the article <A HREF="_core_dao_recordset.htm">DAO Recordset</A>.</P>

<P>Recordsets manage binding table columns that you specify at design time, but there are cases when you may want to bind columns that were unknown to you at design time. This article explains:

<UL type=disc>
	<LI><A HREF="#_core_when_you_might_bind_columns_dynamically">When you might want to bind columns dynamically to a recordset</A>.<BR><BR></LI>

	<LI><A HREF="#_core_how_to_bind_columns_dynamically">How to bind columns dynamically at run time</A>.</LI>
</UL>

<P class=indent><B><B>Note&nbsp;&nbsp;&nbsp;</B></B>This article applies to objects derived from <B>CRecordset</B> in which bulk row fetching has not been implemented. The techniques described generally are not recommended if you are using bulk row fetching. For more information about bulk row fetching, see the article <A HREF="_core_recordset.3a_.fetching_records_in_bulk_.28.odbc.29.htm">Recordset: Fetching Records in Bulk (ODBC)</A>.</P>

<H2><A NAME="_core_when_you_might_bind_columns_dynamically"></A>When You Might Bind Columns Dynamically</H2>

<P>At design time, ClassWizard creates recordset classes based on the known tables and columns on your data source. Databases can change between when you design them and later when your application uses those tables and columns at run time. You or another user might add or drop a table or add or drop columns from a table that your application’s recordset relies upon. This probably isn’t a concern for all data-access applications, but if it is for yours, how can you cope with changes in the database schema, other than by redesigning and recompiling? The purpose of this article is to answer that question.</P>

<P>This article describes the most common case in which you might bind columns dynamically — having begun with a recordset based on a known database schema, you want to handle additional columns at run time. The article further assumes that the additional columns map to <B>CString</B> field data members, the most common case, although suggestions are supplied to help you manage other data types.</P>

<P>With a small amount of extra code, you can:

<UL type=disc>
	<LI><A HREF="#_core_to_determine_the_columns_in_a_table_at_run_time">Determine what columns are available at run time</A>.<BR><BR></LI>

	<LI><A HREF="#_core_adding_the_columns">Bind additional columns to your recordset dynamically, at run time</A>.</LI>
</UL>

<P>Your recordset still contains data members for the columns you knew about at design time. It also contains a small amount of extra code that dynamically determines whether any new columns have been added to your target table and, if so, binds these new columns to dynamically allocated storage (rather than to recordset data members).</P>

<P>This article doesn’t cover other dynamic binding cases, such as dropped tables or columns. For those, you’ll need to use ODBC API calls more directly. See the ODBC SDK <I>Programmer’s Reference</I> on the MSDN Library CD.</P>

<P>Example code for this article comes from the MFC Database samples <A HREF="JavaScript:hhobj_3.Click()">DYNABIND</A> and <A HREF="JavaScript:hhobj_4.Click()">CATALOG</A>.</P>

<H2><A NAME="_core_how_to_bind_columns_dynamically"></A>How to Bind Columns Dynamically</H2>

<P>To bind columns dynamically in a case like that of the DYNABIND example, you must know (or be able to determine) the names of the additional columns. You must also allocate storage for the additional field data members, specify their names and their types, and specify the number of columns you’re adding. </P>

<P>The following discussion mentions two different recordsets. The first is the main recordset that selects records from the target table. The second is a special column recordset used to get information about the columns in your target table. </P>

<H3><A NAME="_core_the_general_process"></A>The General Process</H3>

<P>At the most general level, you follow these steps:

<OL>
	<LI>Construct your main recordset object.
<P class=tl>Optionally, pass a pointer to an open <B>CDatabase</B> object, or be able to supply connection information to the column recordset in some other way.</P></LI>

	<LI>Take steps to add columns dynamically.
<P class=tl>See the process described in Adding the Columns below.</P></LI>

	<LI>Open your main recordset.
<P class=tl>The recordset selects records and uses record field exchange (RFX) to bind both the static columns (those mapped to recordset field data members) and the dynamic columns (mapped to extra storage that you allocate).</P></LI>
</OL>

<H3><A NAME="_core_adding_the_columns"></A>Adding the Columns</H3>

<P>Dynamically binding added columns at run time requires the following steps:

<OL>
	<LI>Determine at run time what columns are in the target table. Extract from that information a list of the columns that have been added to the table since your recordset class was designed.
<P class=tl>A good approach is to use a column recordset class designed to query the data source for column information for the target table — such as column name, data type, and so on. The MFC Database sample <A HREF="JavaScript:hhobj_5.Click()">CATALOG</A> provides a recordset class called <CODE>CColumns</CODE> that you can use to build a list of the new columns’ names.</P></LI>

	<LI>Provide storage for the new field data members. Your main recordset class doesn’t have field data members for unknown columns, so you must provide a place to store the names, result values, and possibly data type information (if the columns are of different data types). 
<P class=tl>One approach is to build one or more dynamic lists, one for the new columns’ names, another for their result values, and a third for their data types (if necessary). These lists, particularly the value list, provide the information and the necessary storage for binding. The following figure illustrates building the lists.</P>
<P class=label><B><A NAME="_core_illustration_dynamic"></A>Building Lists of Columns to Bind Dynamically</B>

<P><IMG SRC="mr2bdlc.gif" ALT="" BORDER=0></P></LI>

	<LI>Add an RFX function call in your main recordset’s <CODE>DoFieldExchange</CODE> function for each added column. These RFX calls do the work of fetching a record, including the additional columns, and binding the columns to recordset data members or to your dynamically supplied storage for them.
<P class=tl>One approach is to add a loop to your main recordset’s <CODE>DoFieldExchange</CODE> function that loops through your list of new columns, calling the appropriate RFX function for each column in the list. On each RFX call, pass a column name from the column name list and a storage location in the corresponding member of the result value list.</P></LI>
</OL>

<H3><A NAME="_core_lists_of_columns"></A>Lists of Columns</H3>

<P>The four lists you need to work with are:</P>

<P class=dt><A HREF="#_core_illustration_dynamic">Current-Table-Columns (List 1 in the illustration)</A></P>

<P class=indent>A list of the columns currently in the table on the data source. This list may or may not match the list of columns currently bound in your recordset.</P>

<P class=dt><A HREF="#_core_illustration_dynamic">Bound-Recordset-Columns (List 2 in the illustration)</A></P>

<P class=indent>A list of the columns bound in your recordset (usually set up with ClassWizard). These columns already have RFX statements in your <CODE>DoFieldExchange</CODE> function.</P>

<P class=dt><A HREF="#_core_illustration_dynamic">Columns-To-Bind-Dynamically (List 3 in the illustration)</A></P>

<P class=indent>A list of columns in the table but not in your recordset. These are the columns you want to bind dynamically.</P>

<P class=dt><A HREF="#_core_illustration_dynamic">Dynamic-Column-Values (List 4 in the illustration)</A>  A list containing storage for the values retrieved from the columns you bind dynamically. Elements of this list correspond to those in Columns-to-Bind-Dynamically, one to one.</P>

<H3><A NAME="_core_building_your_lists"></A>Building Your Lists</H3>

<P>With a general strategy in mind, you can turn to the details. The procedures in the rest of this article show you how to build the lists shown in <A HREF="#_core_lists_of_columns">Lists of Columns</A>. The procedures guide you through:

<UL type=disc>
	<LI><A HREF="#_core_determining_the_columns_in_your_table_at_run_time">Determining the columns in your table at run time</A><BR><BR></LI>

	<LI><A HREF="#_core_determining_which_table_columns_are_not_in_your_recordset">Determining the names of columns not in your recordset</A><BR><BR></LI>

	<LI><A HREF="#_core_providing_storage_for_the_new_columns">Providing dynamic storage for columns newly added to the table</A><BR><BR></LI>

	<LI><A HREF="#_core_adding_rfx_calls_to_bind_the_columns">Dynamically adding RFX calls for new columns</A></LI>
</UL>

<H3><A NAME="_core_determining_the_columns_in_your_table_at_run_time"></A>Determining the Columns in Your Table at Run Time</H3>

<P>First, build Current-Table-Columns (as in the <A HREF="#_core_illustration_dynamic">illustration</A>): a list of the columns in the table on the data source.</P>

<P class=label><B><A NAME="_core_to_determine_the_columns_in_a_table_at_run_time"></A>To determine the columns in a table at run time (Current-Table-Columns)</B>

<OL>
	<LI>Borrow the files COLUMNST.H/.CPP from the MFC Database sample <A HREF="JavaScript:hhobj_6.Click()">CATALOG</A>. Add the .CPP file to your project and include the .H file as needed. <BR><BR></LI>

	<LI>At run time, construct a “column recordset” object of class <CODE>CColumn</CODE>, passing a pointer to an open <B>CDatabase</B> object. <BR><BR></LI>

	<LI>Before you call <B>Open</B>, set one or more of the column recordset’s parameters. The following table describes what these parameters specify.
<TABLE border=1 cellpadding=5 cols=2 frame=below rules=rows>

<TR VALIGN="top">
<TD class=label width=50%><B>Parameter</B></TD>
<TD class=label width=50%><B>Description</B></TD>
</TR>

<TR VALIGN="top">
<TD width=50%>
<PRE><CODE>m_strQualifierParam</CODE></PRE>
</TD>
<TD width=50%>Identifies the database containing the table for ODBC. You usually don’t need to specify this value.</TD>
</TR>

<TR VALIGN="top">
<TD width=50%>
<PRE><CODE>m_strOwnerParam</CODE></PRE>
</TD>
<TD width=50%>Identifies the person who created the target table.</TD>
</TR>

<TR VALIGN="top">
<TD width=50%>
<PRE><CODE>m_strTableNameParam</CODE></PRE>
</TD>
<TD width=50%>Identifies the target table by name.</TD>
</TR>

<TR VALIGN="top">
<TD width=50%>
<PRE><CODE>m_strColumnNameParam</CODE></PRE>
</TD>
<TD width=50%>Identifies a specific column by name.</TD>
</TR>
</TABLE><BR>

<P class=tl>In most cases, you need only the table name, although some data sources might require the owner name as well, and others might require even more information. In addition to table name, use the column name parameter if you need information for only a single column in the table. For information about these parameters, see <B>::SQLColumns</B> in the ODBC SDK <I>Programmer’s Reference</I> on the MSDN Library CD.</P></LI>

	<LI>Call <B>Open</B> for the column recordset.
<P class=tl>The recordset returns a record for each column in the specified table (unless you specify <B>m_strColumnNameParam</B>).</P></LI>

	<LI>Construct Current-Table-Columns, a collection object that can hold <B>CString</B> objects.
<P class=tl>For example, you might use a <B>CStringList</B>.</P></LI>

	<LI>Scroll through the object’s records, loading column names into Current-Table-Columns as you go.</LI>
</OL>

<P>This procedure results in a collection object that contains the names of all columns in a specified table. For example, the <A HREF="#_core_illustration_dynamic">illustration</A> shows Current-Table-Columns (List 1) with four elements. The last element is “Phone.” For descriptions of the lists, see <A HREF="#_core_lists_of_columns">Lists of Columns</A>. </P>

<H3><A NAME="_core_determining_which_table_columns_are_not_in_your_recordset"></A>Determining Which Table Columns Are Not in Your Recordset</H3>

<P>Next, build a list (Bound-Recordset-Columns, as in List 2 in the <A HREF="#_core_illustration_dynamic">illustration</A>) that contains a list of the columns already bound in your main recordset. Then build a list (Columns-to-Bind-Dynamically, derived from Current-Table-Columns and Bound-Recordset-Columns) that contains column names that are in the table on the data source but not in your main recordset.</P>

<P class=label><B><A NAME="_core_to_determine_the_names_of_columns_not_in_the_recordset"></A>To determine the names of columns not in the recordset (Columns-to-Bind-Dynamically)</B>

<OL>
	<LI>Build a list (Bound-Recordset-Columns) of the columns already bound in your main recordset.
<P class=tl>One approach is to create Bound-Recordset-Columns at design time. You can visually examine the RFX function calls in the recordset’s <CODE>DoFieldExchange</CODE> function to get these names. Then set up your list as an array initialized with the names.</P>
<P class=tl>For example, the <A HREF="#_core_illustration_dynamic">illustration</A> shows Bound-Recordset-Columns (List 2) with three elements. Bound-Recordset-Columns is missing the Phone column shown in Current-Table-Columns (List 1).</P></LI>

	<LI>Compare Current-Table-Columns and Bound-Recordset-Columns to build a list (Columns-to-Bind-Dynamically) of the columns not already bound in your main recordset.
<P class=tl>One approach is to loop through your list of columns in the table at run time (Current-Table-Columns) and your list of columns already bound in your recordset (Bound-Recordset-Columns) in parallel. Into Columns-to-Bind-Dynamically put any names in Current-Table-Columns that don’t appear in Bound-Recordset-Columns. </P>
<P class=tl>For example, the <A HREF="#_core_illustration_dynamic">illustration</A> shows Columns-to-Bind-Dynamically (List 3) with one element: the Phone column found in Current-Table-Columns (List 1) but not in Bound-Recordset-Columns (List 2).</P></LI>

	<LI>Build a list of Dynamic-Column-Values (as in List 4 in the <A HREF="#_core_illustration_dynamic">illustration</A>) in which to store the data values corresponding to each column name stored in your list of columns to bind dynamically (Columns-to-Bind-Dynamically). 
<P class=tl>The elements of this list play the role of new recordset field data members. They are the storage locations to which the dynamic columns are bound. For descriptions of the lists, see <A HREF="#_core_lists_of_columns">Lists of Columns</A>.</P></LI>
</OL>

<H3><A NAME="_core_providing_storage_for_the_new_columns"></A>Providing Storage for the New Columns</H3>

<P>Next, set up storage locations for the columns to be bound dynamically. The idea is to provide a list element in which to store each column’s value. These storage locations parallel the recordset member variables, which store the normally bound columns.</P>

<P class=label><B><A NAME="_core_to_provide_dynamic_storage_for_new_columns"></A>To provide dynamic storage for new columns (Dynamic-Column-Values)</B>

<UL type=disc>
	<LI>Build Dynamic-Column-Values, parallel to Columns-to-Bind-Dynamically, to contain the value of the data in each column. 
<P class=tl>For example, the <A HREF="#_core_illustration_dynamic">illustration</A> shows Dynamic-Column-Values (List 4) with one element: a <B>CString</B> object containing the actual phone number for the current record: “555-1212”.</P>
<P class=tl>In the most common case, Dynamic-Column-Values has elements of type <B>CString</B>. If you’re dealing with columns of varying data types, you’ll need a list that can contain elements of a variety of types.</P></LI>
</UL>

<P>The result of the preceding procedures is two main lists: Columns-to-Bind-Dynamically containing the names of columns and Dynamic-Column-Values containing the values in the columns for the current record.</P>

<P class=indent><B><B>Tip&nbsp;&nbsp;&nbsp;</B></B>If the new columns aren’t all of the same data type, you might want an extra parallel list containing items that somehow define the type of each corresponding element in the column list. (You can use the values <B>AFX_RFX_BOOL</B>, <B>AFX_RFX_BYTE</B>, and so on, for this if you wish. These constants are defined in AFXDB.H.) Choose a list type based on how you represent the column data types.</P>

<H3><A NAME="_core_adding_rfx_calls_to_bind_the_columns"></A>Adding RFX Calls to Bind the Columns</H3>

<P>Finally, arrange for the dynamic binding to occur by placing RFX calls for the new columns in your <CODE>DoFieldExchange</CODE> function.</P>

<P class=label><B><A NAME="_core_to_dynamically_add_rfx_calls_for_new_columns"></A>To dynamically add RFX calls for new columns</B>

<UL type=disc>
	<LI>In your main recordset’s <CODE>DoFieldExchange</CODE> member function, add code that loops through your list of new columns (Columns-to-Bind-Dynamically). In each loop, extract a column name from Columns-to-Bind-Dynamically and a result value for the column from Dynamic-Column-Values. Pass these items to an RFX function call appropriate to the data type of the column. For descriptions of the lists, see <A HREF="#_core_lists_of_columns">Lists of Columns</A>. </LI>
</UL>

<P>In the common case, in your <B>RFX_Text</B> function calls you extract <B>CString</B> objects from the lists, as in the following lines of code, where Columns-to-Bind-Dynamically is a <B>CStringList</B> called <CODE>m_listName</CODE> and Dynamic-Column-Values is a <B>CStringList</B> called <CODE>m_listValue</CODE>:</P>

<PRE><CODE>RFX_Text( pFX, 
            m_listName.GetNext( posName ), 
            m_listValue.GetNext( posValue ));
</CODE></PRE>

<P>For an example of such a loop added to <CODE>DoFieldExchange</CODE>, see <CODE>CSections::DoFieldExchange</CODE> in the file SECTIONS.CPP in the MFC Database sample <A HREF="JavaScript:hhobj_7.Click()">DYNABIND</A>. For more information about RFX functions, see <A HREF="JavaScript:hhobj_8.Click()">Macros and Globals</A> in the <I>Class Library Reference</I>.</P>

<P class=indent><B><B>Tip&nbsp;&nbsp;&nbsp;</B></B>If the new columns are of different data types, use a switch statement in your loop to call the appropriate RFX function for each type.</P>

<P>When the framework calls <CODE>DoFieldExchange</CODE> during the <B>Open</B> process to bind columns to the recordset, the RFX calls for the static columns bind those columns. Then your loop repeatedly calls RFX functions for the dynamic columns.</P>

<P>See the complete source code in the MFC Database sample <A HREF="JavaScript:hhobj_9.Click()">DYNABIND</A>.</P>

<P><B>See Also</B>&nbsp;&nbsp;&nbsp;<A HREF="_core_recordset.3a_.working_with_large_data_items_.28.odbc.29.htm">Recordset: Working with Large Data Items (ODBC)</A> </P>
</font>
</BODY>
</HTML>
