<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The #define Directive</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>

<TABLE ALIGN=right WIDTH=0 BORDER=0><TR><TD>
<OBJECT ID="hhobj_1" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_pluslang_C.2b2b_.Tokens">
</OBJECT>
</TD></TR></TABLE>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_predir_the_.23.define_directive"></A>The #define Directive</H1>

<P>You can use the <B>#define</B> directive to give a meaningful name to a constant in your program. The two forms of the syntax are: </P>

<P class=label><B>Syntax</B></P>

<P><B>#define </B><I>identifier</I> <I>token-string</I><SUB>opt</SUB></P>

<P><B>#define </B><I>identifier</I>[<B>(</B> <I>identifier</I><SUB>opt</SUB><B>,</B>  <I>...</I> <B>,</B> <I>identifier</I><SUB>opt</SUB> <B>)</B>] <I>token-string</I><SUB>opt</SUB></P>

<P>The <B>#define</B> directive substitutes <I>token-string</I> for all subsequent occurrences of an <I>identifier</I> in the source file. The <I>identifier</I> is replaced only when it forms a token. (See <A HREF="JavaScript:hhobj_1.Click()">C++ Tokens</A> in the <I>C++ Language Reference</I>.) For instance, <I>identifier</I> is not replaced if it appears in a comment, within a string, or as part of a longer identifier.</P>

<P>A <B>#define</B> without a <I>token-string</I> removes occurrences of <I>identifier</I> from the source file. The <I>identifier</I> remains defined and can be tested using the <B>#if defined</B> and <B>#ifdef</B> directives.</P>

<P>The <I>token-string</I> argument consists of a series of tokens, such as keywords, constants, or complete statements. One or more white-space characters must separate <I>token-string</I> from <I>identifier</I>. This white space is not considered part of the substituted text, nor is any white space following the last token of the text.</P>

<P>Formal parameter names appear in <I>token-string</I> to mark the places where actual values are substituted. Each parameter name can appear more than once in <I>token-string</I>, and the names can appear in any order. The number of arguments in the call must match the number of parameters in the macro definition. Liberal use of parentheses ensures that complicated actual arguments are interpreted correctly. </P>

<P>The second syntax form allows the creation of function-like macros. This form accepts an optional list of parameters that must appear in parentheses. References to the <I>identifier</I> after the original definition replace each occurrence of <I>identifier</I>( <I>identifier</I><SUB>opt</SUB>, ..., <I>identifier</I><SUB>opt</SUB> ) with a version of the <I>token-string</I> argument that has actual arguments substituted for formal parameters. </P>

<P>The formal parameters in the list are separated by commas. Each name in the list must be unique, and the list must be enclosed in parentheses. No spaces can separate <I>identifier</I> and the opening parenthesis. Use line concatenation — place a backslash (<B>\</B>) before the newline character — for long directives on multiple source lines. The scope of a formal parameter name extends to the new line that ends <I>token-string</I>. </P>

<P>When a macro has been defined in the second syntax form, subsequent textual instances followed by an argument list constitute a macro call. The actual arguments following an instance of <I>identifier</I> in the source file are matched to the corresponding formal parameters in the macro definition. Each formal parameter in <I>token-string</I> that is not preceded by a stringizing (<B>#</B>), charizing (<B>#@</B>), or token-pasting (<B>##</B>) operator, or not followed by a <B>##</B> operator, is replaced by the corresponding actual argument. Any macros in the actual argument are expanded before the directive replaces the formal parameter. (The operators are described in <A HREF="_predir_preprocessor_operators.htm">Preprocessor Operators</A>.)</P>

<P>The following examples of macros with arguments illustrate the second form of the <B>#define</B> syntax:</P>

<PRE><CODE>// Macro to define cursor lines 
#define CURSOR(top, bottom) ((top) &lt;&lt; 8) | bottom))

// Macro to get a random integer with a specified range 
#define getrandom(min, max) \
    ((rand()%(int)(((max) + 1)-(min)))+ (min))
</CODE></PRE>

<P>Arguments with side effects sometimes cause macros to produce unexpected results. A given formal parameter may appear more than once in <I>token-string</I>. If that formal parameter is replaced by an expression with side effects, the expression, with its side effects, may be evaluated more than once. (See the examples under <A HREF="_predir_token.2d.pasting_operator.htm">Token-Pasting Operator (##)</A>.)</P>

<P>The <B>#undef</B> directive causes an identifier’s preprocessor definition to be forgotten. See <A HREF="_predir_the_.23.undef_directive.htm">The #undef Directive</A> for more information.</P>

<P>If the name of the macro being defined occurs in <I>token-string</I> (even as a result of another macro expansion), it is not expanded.</P>

<P>A second <B>#define</B> for a macro with the same name generates an error unless the second token sequence is identical to the first.</P>

<P><B>Microsoft Specific </B></P>

<P>Microsoft C/C++ allows the redefinition of a macro, but generates a warning, provided the new definition is lexically identical to a previous definition. ANSI C considers macro redefinition an error. For example, these macros are equivalent for C/C++ but generate warnings:</P>

<PRE><CODE>#define test( f1, f2 ) ( f1 * f2 )
#define test( a1, a2 ) ( a1 * a2 )
</CODE></PRE>

<P><B>END Microsoft Specific</B></P>

<P>This example illustrates the <B>#define</B> directive:</P>

<PRE><CODE>#define WIDTH       80
#define LENGTH      ( WIDTH + 10 )
</CODE></PRE>

<P>The first statement defines the identifier <CODE>WIDTH</CODE> as the integer constant 80 and defines <CODE>LENGTH</CODE> in terms of <CODE>WIDTH</CODE> and the integer constant 10. Each occurrence of <CODE>LENGTH</CODE> is replaced by (<CODE>WIDTH + 10</CODE>). In turn, each occurrence of <CODE>WIDTH + 10</CODE> is replaced by the expression (<CODE>80 + 10</CODE>). The parentheses around <CODE>WIDTH + 10</CODE> are important because they control the interpretation in statements such as the following:</P>

<PRE><CODE>var = LENGTH * 20;
</CODE></PRE>

<P>After the preprocessing stage the statement becomes:</P>

<PRE><CODE>var = ( 80 + 10 ) * 20;
</CODE></PRE>

<P>which evaluates to 1800. Without parentheses, the result is:</P>

<PRE><CODE>var = 80 + 10 * 20;
</CODE></PRE>

<P>which evaluates to 280.</P>

<P><B>Microsoft Specific </B></P>

<P>Defining macros and constants with the <A HREF="_core_.2f.d.htm">/D</A> compiler option has the same effect as using a <B>#define</B> preprocessing directive at the beginning of your file. Up to 30 macros can be defined with the /D option.</P>

<P><B>END Microsoft Specific</B></P>
</font>
</BODY>
</HTML>
