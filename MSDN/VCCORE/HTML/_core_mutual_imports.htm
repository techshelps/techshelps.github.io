<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Mutual Imports</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>

<TABLE ALIGN=right WIDTH=0 BORDER=0><TR><TD>
<OBJECT ID="hhobj_1" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_vc_addpf_home">
</OBJECT>
</TD></TR></TABLE>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_core_mutual_imports"></A>Mutual Imports</H1>

<P><A HREF="JavaScript:hhobj_1.Click()">Home</A>  |&nbsp; <A HREF="_core_dlls.3a_.overview.htm">Overview</A>  |&nbsp; <A HREF="_core_dll_tasks.htm">How Do I</A>  |&nbsp; <A HREF="_core_dlls.3a_.frequently_asked_questions.htm">FAQ</A>  |&nbsp; <A HREF="_core_dll_topics.htm">Details</A>  |&nbsp; <A HREF="_core_dll_sample_programs.htm">Sample</A></P>

<P>Exporting or importing to another executable file presents complications when the imports are mutual (or "circular"). For example, two DLLs import symbols from each other, similar to mutually-recursive functions.</P>

<P>The problem with mutually-importing executable files (usually DLLs) is that neither can be built without building the other first. Each build process requires, as input, an import library produced by the <I>other</I> build process.</P>

<P>The solution is to use the LIB utility with the /DEF option, which produces an import library without building the executable file. Using this utility, you can build all the import libraries you need, no matter how many DLLs are involved or how complicated the dependencies are.</P>

<P>The general solution for handling mutual imports is:

<OL>
	<LI>Take each DLL in turn. (Any order is feasible, although some orders are more optimal.) If all the needed import libraries exist and are current, run LINK to build the executable file (DLL). This produces an import library. Otherwise, run LIB to produce an import library.
<P class=tl>Running LIB with the /DEF option produces an additional file with an .EXP extension. The .EXP file must be used later to build the executable file.</P></LI>

	<LI>After using either LINK or LIB to build all the import libraries, go back and run LINK to build any executable files that were not built in the previous step. Note that the corresponding .EXP file must be specified on the LINK line.
<P class=tl>If you had run the LIB utility earlier to produce an import library for DLL1, LIB would have produced the file DLL1.EXP as well. You must use DLL1.EXP as input to LINK when building DLL1.DLL.</P></LI>
</OL>

<P>The figure "Linking Two DLLs with Mutual Imports" below illustrates a solution for two mutually-importing DLLs, DLL1 and DLL2. Step 1 is to run LIB, with the /DEF option set, on DLL1. Step 1 produces DLL1.LIB, an import library, and DLL1.EXP. In step 2, the import library is used to build DLL2, which in turn produces an import library for DLL2's symbols. Step 3 builds DLL1, by using DLL1.EXP and DLL2.LIB as input. Note that an .EXP file for DLL2 is <I>not</I> necessary because LIB was not used to build DLL2's import library.</P>

<P class=label><B>Linking Two DLLs with Mutual Imports</B></P>

<P><IMG SRC="q04lnk1.gif" ALT="" BORDER=0></P>

<H2>Limitations of _AFXEXT</H2>

<P>You can use the <B>_AFXEXT</B> preprocessor symbol for your extension DLLs as long as you do not have multiple layers of extension DLLs. If you have extension DLLs which call or derive from classes in your own extension DLLs, which then derive from the MFC classes, you must use your own preprocessor symbol to avoid ambiguity.</P>

<P>The problem is that in Win32, you must explicitly declare any data as <B>__declspec(dllexport)</B> if it is to be exported from a DLL, and <B>__declspec(dllimport)</B> if it is to be imported from a DLL. When you define <B>_AFXEXT</B>, the MFC headers make sure that <B>AFX_EXT_CLASS</B> is defined correctly.</P>

<P>When you have multiple layers, one symbol such as <B>AFX_EXT_CLASS</B> is not sufficient, since an extension DLL may be exporting new classes as well as importing other classes from another extension DLL. In order to solve this problem, use a special preprocessor symbol which indicates that you are building the DLL itself versus using the DLL. For example, imagine two extension DLLs, A.DLL and B.DLL. They each export some classes in A.H and B.H, respectively. B.DLL uses the classes from A.DLL. The header files would look something like this:</P>

<PRE><CODE>// A.H
#ifdef A_IMPL
   #define CLASS_DECL_A   __declspec(dllexport)
#else
   #define CLASS_DECL_A   __declspec(dllimport)
#endif

class CLASS_DECL_A CExampleA : public CObject
{ ... class definition ... };

// B.H
#ifdef B_IMPL
   #define CLASS_DECL_B   __declspec(dllexport)
#else
   #define CLASS_DECL_B   __declspec(dllimport)
#endif

class CLASS_DECL_B CExampleB : public CExampleA
{ ... class definition .. };
.
.
.
</CODE></PRE>

<P>When A.DLL is built, it is built with <CODE>/D A_IMPL</CODE> and when B.DLL is built, it is built with <CODE>/D B_IMPL</CODE>. By using separate symbols for each DLL, <CODE>CExampleB</CODE> is exported and <CODE>CExampleA</CODE> is imported when building B.DLL. <CODE>CExampleA</CODE> is exported when building A.DLL and imported when used by B.DLL (or some other client).</P>

<P>This type of layering cannot be done when using the built-in <B>AFX_EXT_CLASS </B>and <B>_AFXEXT</B> preprocessor symbols. The technique described above solves this problem in a manner not unlike the mechanism MFC itself uses when building its Active technologies, Database, and Network extension DLLs.</P>

<H2>Not Exporting the Entire Class</H2>

<P>When you are not exporting an entire class, you have to ensure that the necessary data items created by the MFC macros are exported correctly. This can be done by re-defining <B>AFX_DATA</B> to your specific class' macro. This should be done any time you are not exporting the entire class.</P>

<P>For example:</P>

<PRE><CODE>   // A.H
   #ifdef A_IMPL
       #define CLASS_DECL_A  _declspec(dllexport)
   #else
       #define CLASS_DECL_A  _declspec(dllimport)
   #endif

   #undef  AFX_DATA
   #define AFX_DATA CLASS_DECL_A

   class CExampleA : public CObject
   {
     DECLARE_DYNAMIC()
     CLASS_DECL_A int SomeFunction();
     //... class definition ...
   };

   #undef AFX_DATA
   #define AFX_DATA
</CODE></PRE>

<H3>What do you want to do?</H3>

<UL type=disc>
	<LI><A HREF="_core_export_from_a_dll.htm">Export from a DLL</A><BR><BR></LI>

	<LI><A HREF="_core_export_from_a_dll_using_..def_files.htm">Export from a DLL using .DEF files</A><BR><BR></LI>

	<LI><A HREF="_core_export_from_a_dll_using___declspec.28.dllexport.29.htm">Export from a DLL using __declspec(dllexport)</A><BR><BR></LI>

	<LI><A HREF="_core_export_and_import_using_afx_ext_class.htm">Export and import using AFX_EXT_CLASS</A><BR><BR></LI>

	<LI><A HREF="_core_export_c.2b2b_.functions_for_use_in_c.2d.language_executables.htm">Export C++ functions for use in C-language executables</A><BR><BR></LI>

	<LI><A HREF="_core_determine_which_exporting_method_to_use.htm">Determine which exporting method to use</A><BR><BR></LI>

	<LI><A HREF="_core_import_into_an_application_using___declspec.28.dllimport.29.htm">Import into an application using __declspec(dllimport)</A></LI>
</UL>

<H3>What do you want to know more about?</H3>

<UL type=disc>
	<LI><A HREF="_core_lib_reference.htm">The LIB utility and the /DEF option</A></LI>
</UL>
</font>
</BODY>
</HTML>
