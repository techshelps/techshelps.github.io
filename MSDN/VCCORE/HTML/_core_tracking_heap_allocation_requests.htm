<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Tracking Heap Allocation Requests</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_core_tracking_heap_allocation_requests"></A>Tracking Heap Allocation Requests</H1>

<P>Although pinpointing the source file name and line number at which an assert or reporting macro executes is often very useful in locating the cause of a problem, the same is not as likely to be true of heap allocation functions. While macros can be inserted at many appropriate points in an application’s logic tree, an allocation is often buried in a special routine that is called from many different places at many different times. The question is usually not what line of code made a bad allocation, but rather which one of the thousands of allocations made by that line of code was bad, and why.</P>

<P>The simplest way to identify the specific heap allocation call that went bad is to take advantage of the unique allocation request number associated with each block in the debug heap. When information about a block is reported by one of the dump functions, this allocation request number is enclosed in curly brackets (for example, “{36}”).</P>

<P>Once you know the allocation request number of an improperly allocated block, you can pass this number to <B>_CrtSetBreakAlloc </B>to create a breakpoint. Execution will break just prior to allocating the block, and you can backtrack to determine what routine was responsible for the bad call. To avoid recompiling, you can accomplish the same thing in the debugger by setting <B>_crtBreakAlloc</B> to the allocation request number you are interested in.</P>

<P>A somewhat more complicated approach is to create debug versions of your own allocation routines, comparable to the <B>_dbg</B> versions of the heap allocation functions. You can then pass source file and line number arguments through to the underlying heap allocation routines, and you will immediately be able to see where a bad allocation originated.</P>

<P>For example, suppose your application contains a commonly used routine similar to the following:</P>

<PRE><CODE>int addNewRecord(struct RecStruct * prevRecord, 
                 int recType, int recAccess)
{
   /* ...code omitted through actual allocation... */
   if ((newRec = malloc(recSize)) == NULL)
   /* ... rest of routine omitted too ... */
}
</CODE></PRE>

<P>In a header file, you could add code such as the following:</P>

<PRE><CODE>#ifdef _DEBUG
#define  addNewRecord(p, t, a) \
         addNewRecord(p, t, a, __FILE__, __LINE__)
#endif
</CODE></PRE>

<P>Next, you could change the allocation in your record-creation routine as follows:</P>

<PRE><CODE>int addNewRecord(struct RecStruct *prevRecord, 
                 int recType, int recAccess
#ifdef _DEBUG
               , const char *srcFile, int srcLine
#endif
   )
{
   /* ... code omitted through actual allocation ... */
   if ((newRec = _malloc_dbg(recSize, _NORMAL_BLOCK, 
        srcFile, scrLine)) == NULL)
   /* ... rest of routine omitted too ... */
}
</CODE></PRE>

<P>Now the source file name and line number where <CODE>addNewRecord</CODE> was called will be stored in each resulting block allocated in the debug heap and will be reported when that block is examined.</P>
</font>
</BODY>
</HTML>
