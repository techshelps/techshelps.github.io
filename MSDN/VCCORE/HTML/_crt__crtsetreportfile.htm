<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>_CrtSetReportFile</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_crt__crtsetreportfile"></A><SUP></SUP>_CrtSetReportFile</H1>

<P>Identifies the file or stream to be used by <B>_CrtDbgReport</B> as a destination for a specific report type (debug version only).</P>

<P><B>_HFILE</B> <B>_CrtSetReportFile(</B> <B>int</B> <I>reportType</I><B>,</B><I> </I><B>_HFILE</B> <I>reportFile </I><B>);</B></P>

<TABLE border=1 cellpadding=5 cols=3 frame=below rules=rows>

<TR VALIGN="top">
<TD class=label width=27%><B>Routine</B></TD>
<TD class=label width=25%><B>Required Header</B></TD>
<TD class=label width=48%><B>Compatibility</B></TD>
</TR>

<TR VALIGN="top">
<TD width=27%><B>_CrtSetReportFile</B></TD>
<TD width=25%>&lt;crtdbg.h&gt;</TD>
<TD width=48%>Win NT, Win 95</TD>
</TR>
</TABLE><BR>

<P>For additional compatibility information, see <A HREF="_crt_compatibility.htm">Compatibility</A> in the Introduction.</P>

<P class=label><B>Libraries</B></P>

<TABLE border=1 cellpadding=5 cols=2 frame=below rules=rows>

<TR VALIGN="top">
<TD width=24%>LIBCD.LIB</TD>
<TD width=76%>Single thread static library, debug version</TD>
</TR>

<TR VALIGN="top">
<TD width=24%>LIBCMTD.LIB</TD>
<TD width=76%>Multithread static library, debug version</TD>
</TR>

<TR VALIGN="top">
<TD width=24%>MSVCRTD.LIB</TD>
<TD width=76%>Import library for MSVCRTD.DLL, debug version</TD>
</TR>
</TABLE><BR>

<P class=label><B>Return Value</B></P>

<P>Upon successful completion, <B>_CrtSetReportFile</B> returns the previous report file defined for the report type specified in <I>reportType</I>. If an error occurs, the report file for <I>reportType</I> is not modified and<B>_CrtSetReportFile</B> returns <B>_CRTDBG_HFILE_ERROR</B>.</P>

<P class=label><B>Parameters</B></P>

<P class=dt><I>reportType</I></P>

<P class=indent>Report type: <B>_CRT_WARN</B>, <B>_CRT_ERROR</B>, <B>_CRT_ASSERT</B></P>

<P class=dt><I>reportFile</I></P>

<P class=indent>New report file for <I>reportType</I>, see the following table</P>

<P class=label><B>Remarks</B></P>

<P><B>_CrtSetReportFile</B> is used in conjunction with the <A HREF="_crt__crtsetreportmode.htm">_CrtSetReportMode</A> function to define the destination(s) for a specific report type generated by <B>_CrtDbgReport</B>. When <B>_CrtSetReportMode</B> has been called to assign the <B>_CRTDBG_MODE_FILE</B> reporting mode for a specific report type, <B>_CrtSetReportFile</B> should then be called to define the specific file or stream to use as the destination. When <A HREF="_crt__debug.htm">_DEBUG</A> is not defined, calls to <B>_CrtSetReportFile</B> are removed during preprocessing.</P>

<P>The <B>_CrtSetReportFile</B> function assigns the new report file specified in <I>reportFile</I> to the report type specified in <I>reportType</I> and returns the previously defined report file for <I>reportType</I>. The following table lists the available choices for <I>reportFile</I> and the resulting behavior of <B>_CrtDbgReport</B>. These options are defined as bit-flags in CRTDBG.H.</P>

<TABLE border=1 cellpadding=5 cols=2 frame=below rules=rows>

<TR VALIGN="top">
<TD class=label width=40%><B>Report File</B></TD>
<TD class=label width=60%><B>_CrtDbgReport Behavior</B></TD>
</TR>

<TR VALIGN="top">
<TD width=40%><B>_HFILE</B></TD>
<TD width=60%><B>_CrtDbgReport</B> writes the message to a user-supplied <B>HANDLE</B> and does not verify the validity of the file handle. The application is responsible for opening and closing the report file and passing a valid file handle.</TD>
</TR>

<TR VALIGN="top">
<TD width=40%><B>_CRTDBG_FILE_STDERR</B></TD>
<TD width=60%><B>_CrtDbgReport</B> writes message to <B>stderr</B>.</TD>
</TR>

<TR VALIGN="top">
<TD width=40%><B>_CRTDBG_FILE_STDOUT</B></TD>
<TD width=60%><B>_CrtDbgReport</B> writes message to <B>stdout</B>.</TD>
</TR>

<TR VALIGN="top">
<TD width=40%><B>_CRTDBG_REPORT_FILE</B></TD>
<TD width=60%><B>_CrtDbgReport</B> is not called and the report file for <I>reportType</I> is not modified. <B>_CrtSetReportFile</B> simply returns the current report file for <I>reportType</I>.</TD>
</TR>
</TABLE><BR>

<P>When the report destination is a file, <B>_CrtSetReportMode</B> is called to set the file bit-flag and <B>_CrtSetReportFile</B> is called to define the specific file to use. The following code fragment demonstrates this configuration:</P>

<PRE><CODE>_CrtSetReportMode( _CRT_ASSERT, _CRTDBG_MODE_FILE );
_CrtSetReportFile( _CRT_ASSERT, _CRTDBG_FILE_STDERR );
</CODE></PRE>

<P>The report file used by each report type can be separately controlled. For example, it is possible to specify that a <I>reportType</I> of <B>_CRT_ERROR</B> be reported to <B>stderr</B>, while a <I>reportType</I> of <B>_CRT_ASSERT</B> be reported to a user-defined file handle or stream.</P>

<P>For more information about defining the report mode(s) and file for a specific report type, see <B>_CrtDbgReport</B>, <B>_CrtSetReportMode</B> and the section <A HREF="_core_debug_reporting_functions_of_the_c_run.2d.time_library.htm">Debug Reporting Functions of the C Run-Time Library</A>.</P>

<P class=label><B>Example</B></P>

<PRE><CODE>/* 
 * REPORT.C:
 * In this program, calls are made to the _CrtSetReportMode,
 * _CrtSetReportFile, and _CrtSetReportHook functions.
 * The _ASSERT macros are called to evaluate their expression.
 * When the condition fails, these macros print a diagnostic message
 * and call _CrtDbgReport to generate a debug report and the
 * client-defined reporting function is called as well.
 * The _RPTn and _RPTFn group of macros are also exercised in
 * this program, as an alternative to the printf function.
 * When these macros are called, the client-defined reporting function
 * takes care of all the reporting - _CrtDbgReport won't be called.
 */

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;malloc.h&gt;
#include &lt;crtdbg.h&gt;

/* 
 * Define our own reporting function.
 * We'll hook it into the debug reporting
 * process later using _CrtSetReportHook.
 *
 * Define a global int to keep track of
 * how many assertion failures occur.
 */
int gl_num_asserts=0;
int OurReportingFunction( int reportType, char *userMessage, int *retVal )
{
   /*
    * Tell the user our reporting function is being called.
    * In other words - verify that the hook routine worked.
    */
   fprintf("Inside the client-defined reporting function.\n", STDOUT);
   fflush(STDOUT);

   /*
    * When the report type is for an ASSERT,
    * we'll report some information, but we also
    * want _CrtDbgReport to get called - 
    * so we'll return TRUE.
    *
    * When the report type is a WARNing or ERROR,
    * we'll take care of all of the reporting. We don't
    * want _CrtDbgReport to get called - 
    * so we'll return FALSE.
    */
   if (reportType == _CRT_ASSERT)
   {
      gl_num_asserts++;
      fprintf("This is the number of Assertion failures that have occurred: %d \n", gl_num_asserts, STDOUT);
      fflush(STDOUT);
      fprintf("Returning TRUE from the client-defined reporting function.\n", STDOUT);
      fflush(STDOUT);
      return(TRUE);
   } else {
      fprintf("This is the debug user message: %s \n", userMessage, STDOUT);
      fflush(STDOUT);
      fprintf("Returning FALSE from the client-defined reporting function.\n", STDOUT);
      fflush(STDOUT);
      return(FALSE);
   }

   /*
    * By setting retVal to zero, we are instructing _CrtDbgReport
    * to continue with normal execution after generating the report.
    * If we wanted _CrtDbgReport to start the debugger, we would set
    * retVal to one.
    */
   retVal = 0;
}

int main()
{
      char *p1, *p2;

   /* 
    * Hook in our client-defined reporting function.
    * Every time a _CrtDbgReport is called to generate
    * a debug report, our function will get called first.
    */
   _CrtSetReportHook( OurReportingFunction );

   /* 
    * Define the report destination(s) for each type of report
    * we are going to generate.  In this case, we are going to
    * generate a report for every report type: _CRT_WARN,
    * _CRT_ERROR, and _CRT_ASSERT.
    * The destination(s) is defined by specifying the report mode(s)
    * and report file for each report type.
    * This program sends all report types to STDOUT.
    */                                             
   _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE);
   _CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDOUT);
   _CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_FILE);
   _CrtSetReportFile(_CRT_ERROR, _CRTDBG_FILE_STDOUT);
   _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_FILE);
   _CrtSetReportFile(_CRT_ASSERT, _CRTDBG_FILE_STDOUT);

   /*
    * Allocate and assign the pointer variables
    */
   p1 = malloc(10);
   strcpy(p1, "I am p1");
   p2 = malloc(10);
   strcpy(p2, "I am p2");

   /*
    * Use the report macros as a debugging
    * warning mechanism, similar to printf.
    *
    * Use the assert macros to check if the
    * p1 and p2 variables are equivalent.
    *
    * If the expression fails, _ASSERTE will
    * include a string representation of the
    * failed expression in the report.
    *
    *  _ASSERT does not include the
    * expression in the generated report.
    */
   _RPT0(_CRT_WARN, "\n\n Use the assert macros to evaluate the expression p1 == p2.\n");
   _RPTF2(_CRT_WARN, "\n Will _ASSERT find '%s' == '%s' ?\n", p1, p2);
   _ASSERT(p1 == p2);

   _RPTF2(_CRT_WARN, "\n\n Will _ASSERTE find '%s' == '%s' ?\n", p1, p2);
   _ASSERTE(p1 == p2);

   _RPT2(_CRT_ERROR, "\n \n '%s' != '%s'\n", p1, p2);
   
   free(p2);
   free(p1);

   return 0;
}
</CODE></PRE>

<P class=label><B>Output</B></P>

<PRE><CODE>Inside the client-defined reporting function.
This is the debug user message: Use the assert macros to evaluate the expression p1 == p2
Returning FALSE from the client-defined reporting function.
Inside the client-defined reporting function.
This is the debug user message: dbgmacro.c(54) : Will _ASSERT find 'I am p1' == 'I am p2' ?
Returning FALSE from the client-defined reporting function.
Inside the client-defined reporting function.
This is the number of Assertion failures that have occurred: 1
Returning TRUE from the client-defined reporting function.
dbgmacro.c(55) : Assertion failed
Inside the client-defined reporting function.
This is the debug user message: dbgmacro.c(57) : Will _ASSERTE find 'I am p1' == 'I am p2' ?
Returning FALSE from the client-defined reporting function.
Inside the client-defined reporting function.
This is the number of Assertion failures that have occurred: 2
Returning TRUE from the client-defined reporting function.
dbgmacro.c(58) : Assertion failed: p1 == p2
Inside the client-defined reporting function.
This is the debug user message: 'I am p1' != 'I am p2'
Returning FALSE from the client-defined reporting function.

</CODE></PRE>

<P><A HREF="_crt_debug_functions.htm">Debug Functions</A></P>

<P><B>See Also</B>&nbsp;&nbsp;&nbsp;<A HREF="_crt__crtdbgreport.htm">_CrtDbgReport</A></P>
</font>
</BODY>
</HTML>
