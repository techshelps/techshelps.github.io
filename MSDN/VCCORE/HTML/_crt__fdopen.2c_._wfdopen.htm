<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>_fdopen, _wfdopen</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_crt__fdopen.2c_._wfdopen"></A><SUP></SUP>_fdopen, _wfdopen</H1>

<P>Associate a stream with a file that was previously opened for low-level I/O.</P>

<P><B>FILE</B> <B>*_fdopen(</B> <B>int</B> <I>handle</I><B>,</B> <B>const</B> <B>char</B> <B>*</B><I>mode</I> <B>);</B></P>

<P><B>FILE</B> <B>*_wfdopen(</B> <B>int</B> <I>handle</I><B>,</B> <B>const</B> <B>wchar_t</B> <B>*</B><I>mode</I> <B>);</B></P>

<TABLE border=1 cellpadding=5 cols=3 frame=below rules=rows>

<TR VALIGN="top">
<TD class=label width=17%><B>Function</B></TD>
<TD class=label width=27%><B>Required Header</B></TD>
<TD class=label width=56%><B>Compatibility</B></TD>
</TR>

<TR VALIGN="top">
<TD width=17%><B>_fdopen</B></TD>
<TD width=27%>&lt;stdio.h&gt;</TD>
<TD width=56%>Win 95, Win NT</TD>
</TR>

<TR VALIGN="top">
<TD width=17%><B>_wfdopen</B></TD>
<TD width=27%>&lt;stdio.h&gt; or &lt;wchar.h&gt;</TD>
<TD width=56%>Win 95, Win NT</TD>
</TR>
</TABLE><BR>

<P>For additional compatibility information, see <A HREF="_crt_compatibility.htm">Compatibility</A> in the Introduction.</P>

<P class=label><B>Libraries</B></P>

<TABLE border=1 cellpadding=5 cols=2 frame=below rules=rows>

<TR VALIGN="top">
<TD width=24%>LIBC.LIB</TD>
<TD width=76%>Single thread static library, retail version</TD>
</TR>

<TR VALIGN="top">
<TD width=24%>LIBCMT.LIB</TD>
<TD width=76%>Multithread static library, retail version</TD>
</TR>

<TR VALIGN="top">
<TD width=24%>MSVCRT.LIB</TD>
<TD width=76%>Import library for MSVCRT.DLL, retail version</TD>
</TR>
</TABLE><BR>

<P class=label><B>Return Value</B></P>

<P>Each of these functions returns a pointer to the open stream. A null pointer value indicates an error.</P>

<P class=label><B>Parameters</B></P>

<P class=dt><I>handle</I></P>

<P class=indent>Handle to open file</P>

<P class=dt><I>mode</I></P>

<P class=indent>&nbsp;&nbsp;Type of file access</P>

<P class=label><B>Remarks</B></P>

<P>The <B>_fdopen</B> function associates an I/O stream with the file identified by <I>handle</I>, thus allowing a file opened for low-level I/O to be buffered and formatted. <B>_wfdopen</B> is a wide-character version of <B>_fdopen</B>; the <I>mode</I> argument to <B>_wfdopen</B> is a wide-character string. <B>_wfdopen</B> and <B>_fdopen</B> behave identically otherwise.</P>

<P class=label><B>Generic-Text Routine Mappings</B></P>

<TABLE border=1 cellpadding=5 cols=4 frame=below rules=rows>

<TR VALIGN="top">
<TD class=label width=17%><B>TCHAR.H Routine </B></TD>
<TD class=label width=29%><B>_UNICODE &amp; _MBCS Not Defined</B></TD>
<TD class=label width=26%><B>_MBCS Defined</B></TD>
<TD class=label width=28%><B>_UNICODE Defined</B></TD>
</TR>

<TR VALIGN="top">
<TD width=17%>_tfdopen</TD>
<TD width=29%>_fdopen</TD>
<TD width=26%>_fdopen</TD>
<TD width=28%>_wfdopen</TD>
</TR>
</TABLE><BR>

<P>The <I>mode</I> character string specifies the type of file and file access. </P>

<P>The character string <I>mode</I> specifies the type of access requested for the file, as follows:</P>

<P class=dt><B>"r"</B></P>

<P class=indent>Opens for reading. If the file does not exist or cannot be found, the <B>fopen</B> call fails.</P>

<P class=dt><B>"w"</B></P>

<P class=indent>Opens an empty file for writing. If the given file exists, its contents are destroyed.</P>

<P class=dt><B>"a"</B></P>

<P class=indent>Opens for writing at the end of the file (appending); creates the file first if it doesn’t exist.</P>

<P class=dt><B>"r+"</B></P>

<P class=indent>Opens for both reading and writing. (The file must exist.)</P>

<P class=dt><B>"w+"</B></P>

<P class=indent>Opens an empty file for both reading and writing. If the given file exists, its contents are destroyed.</P>

<P class=dt><B>"a+"</B></P>

<P class=indent>Opens for reading and appending; creates the file first if it doesn’t exist.</P>

<P>When a file is opened with the <B>"a"</B> or <B>"a+"</B> access type, all write operations occur at the end of the file. The file pointer can be repositioned using <B>fseek</B> or <B>rewind</B>, but is always moved back to the end of the file before any write operation is carried out. Thus, existing data cannot be overwritten. When the <B>"r+"</B>, <B>"w+"</B>, or <B>"a+"</B> access type is specified, both reading and writing are allowed (the file is said to be open for “update”). However, when you switch between reading and writing, there must be an intervening <B>fflush</B>, <B>fsetpos</B>, <B>fseek</B>, or <B>rewind</B> operation. The current position can be specified for the <B>fsetpos</B> or <B>fseek</B> operation, if desired.</P>

<P>In addition to the above values, the following characters can be included in <I>mode</I> to specify the translation mode for newline characters:</P>

<P class=dt><B>t</B></P>

<P class=indent>Open in text (translated) mode. In this mode, carriage return–linefeed (CR-LF) combinations are translated into single linefeeds (LF) on input, and LF characters are translated to CR-LF combinations on output. Also, CTRL+Z is interpreted as an end-of-file character on input. In files opened for reading/writing, <B>fopen</B> checks for a CTRL+Z at the end of the file and removes it, if possible. This is done because using the <B>fseek</B> and <B>ftell</B> functions to move within a file that ends with a CTRL+Z may cause <B>fseek</B> to behave improperly near the end of the file.</P>

<P class=dt><B>b</B></P>

<P class=indent>Open in binary (untranslated) mode; the above translations are suppressed.</P>

<P class=dt><B>c</B></P>

<P class=indent>Enable the commit flag for the associated <I>filename</I> so that the contents of the file buffer are written directly to disk if either <B>fflush</B> or <B>_flushall</B> is called.</P>

<P class=dt><B>n</B></P>

<P class=indent>Reset the commit flag for the associated <I>filename</I> to “no-commit.” This is the default. It also overrides the global commit flag if you link your program with COMMODE.OBJ. The global commit flag default is “no-commit” unless you explicitly link your program with COMMODE.OBJ.</P>

<P>The <B>t</B>, <B>c</B>, and <B>n</B> <I>mode</I> options are Microsoft extensions for <B>fopen</B> and <B>_fdopen</B> and should not be used where ANSI portability is desired.</P>

<P>If <B>t</B> or <B>b</B> is not given in <I>mode</I>, the default translation mode is defined by the global variable <A HREF="_crt__fmode.htm">_fmode</A>. If <B>t</B> or <B>b</B> is prefixed to the argument, the function fails and returns <B>NULL</B>. For a discussion of text and binary modes, see <A HREF="_crt_text_and_binary_mode_file_i.2f.o.htm">Text and Binary Mode File I/O</A>.</P>

<P>Valid characters for the <I>mode</I> string used in <B>fopen</B> and <B>_fdopen</B> correspond to <I>oflag</I> arguments used in <A HREF="_crt__open.2c_._wopen.htm">_open</A> and <A HREF="_crt__sopen.2c_._wsopen.htm">_sopen</A>, as follows.</P>

<TABLE border=1 cellpadding=5 cols=2 frame=below rules=rows>

<TR VALIGN="top">
<TD class=label width=22%><B>Characters in <I>mode</I> String</B></TD>
<TD class=label width=78%><B><BR>
Equivalent <I>oflag </I>Value for _open/_sopen</B></TD>
</TR>

<TR VALIGN="top">
<TD width=22%><B>a</B></TD>
<TD width=78%><B>_O_WRONLY | _O_APPEND</B> (usually <B>_O_WRONLY | _O_CREAT | _O_APPEND</B>)</TD>
</TR>

<TR VALIGN="top">
<TD width=22%><B>a+</B></TD>
<TD width=78%><B>_O_RDWR | _O_APPEND</B> (usually <B>_O_RDWR | _O_APPEND | _O_CREAT</B> )</TD>
</TR>

<TR VALIGN="top">
<TD width=22%><B>r</B></TD>
<TD width=78%><B>_O_RDONLY</B></TD>
</TR>

<TR VALIGN="top">
<TD width=22%><B>r+</B></TD>
<TD width=78%><B>_O_RDWR</B></TD>
</TR>

<TR VALIGN="top">
<TD width=22%><B>w</B></TD>
<TD width=78%><B>_O_WRONLY</B> (usually <B>_O_WRONLY | _O_CREAT | _O_TRUNC</B>)</TD>
</TR>

<TR VALIGN="top">
<TD width=22%><B>w+</B></TD>
<TD width=78%><B>_O_RDWR</B> (usually <B>_O_RDWR | _O_CREAT | _O_TRUNC</B>)</TD>
</TR>

<TR VALIGN="top">
<TD width=22%><B>b</B></TD>
<TD width=78%><B>_O_BINARY</B></TD>
</TR>

<TR VALIGN="top">
<TD width=22%><B>t</B></TD>
<TD width=78%><B>_O_TEXT</B></TD>
</TR>

<TR VALIGN="top">
<TD width=22%><B>c</B></TD>
<TD width=78%>None</TD>
</TR>

<TR VALIGN="top">
<TD width=22%><B>n</B></TD>
<TD width=78%>None</TD>
</TR>
</TABLE><BR>

<P class=label><B>Example</B></P>

<PRE><CODE>/* _FDOPEN.C: This program opens a file using low-
 * level I/O, then uses _fdopen to switch to stream
 * access. It counts the lines in the file.
 */

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;io.h&gt;

void main( void )
{
   FILE *stream;
   int  fh, count = 0;
   char inbuf[128];

   /* Open a file handle. */
   if( (fh = _open( "_fdopen.c", _O_RDONLY )) == -1 )
      exit( 1 );

   /* Change handle access to stream access. */
   if( (stream = _fdopen( fh, "r" )) == NULL )
      exit( 1 );

   while( fgets( inbuf, 128, stream ) != NULL )
      count++;

   /* After _fdopen, close with fclose, not _close. */
   fclose( stream );
   printf( "Lines in file: %d\n", count );
}

</CODE></PRE>

<P class=label><B>Output</B></P>

<PRE><CODE>Lines in file: 32

</CODE></PRE>

<P><A HREF="_crt_stream_i.2f.o.htm">Stream I/O Routines</A></P>

<P><B>See Also</B>&nbsp;&nbsp;&nbsp;<A HREF="_crt__dup.2c_._dup2.htm">_dup</A>, <A HREF="_crt_fclose.2c_._fcloseall.htm">fclose</A>, <A HREF="_crt_fopen.2c_._wfopen.htm">fopen</A>, <A HREF="_crt_freopen.2c_._wfreopen.htm">freopen</A>, <A HREF="_crt__open.2c_._wopen.htm">_open</A></P>
</font>
</BODY>
</HTML>
