<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Dumping Object Contents</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_core_dumping_object_contents"></A>Dumping Object Contents</H1>

<P>This topic explains how to get a diagnostic dump of the contents of your objects.</P>

<P>When deriving a class from <B>CObject</B>, you have the option to override the Dump member function and write a textual representation of the object’s member variables to a dump context which is similar to an I/O stream. Like an I/O stream, you can use the insertion (<B>&lt;&lt;</B>) operator to send data to a <B>CDumpContext</B>.</P>

<P>You do not have to override <B>Dump</B> when you derive a class from <B>CObject.</B> However, if you use other diagnostic features for debugging, providing the capability for dumping an object and viewing its contents is very helpful and highly recommended.</P>

<P class=indent><B><B>Note</B></B>&nbsp;&nbsp;&nbsp;Before you can dump objects, you must enable diagnostic tracing so you can see the results of your dump in the debugger. For more information, see <A HREF="_core_diagnostic_features.htm">Diagnostics</A>. </P>

<P class=label><B><A NAME="_core_to_override_the_dump_member_function"></A>To override the Dump member function</B>

<OL>
	<LI>Call the base class version of <B>Dump</B> to dump the contents of a base class object.<BR><BR></LI>

	<LI>Write a textual description and value for each member variable of your derived class.</LI>
</OL>

<P>The declaration of the <CODE>Dump</CODE> function in the class declaration looks like:</P>

<PRE><CODE>class CPerson : public CObject
{
public:
#ifdef _DEBUG
    virtual void Dump( CDumpContext&amp; dc ) const;
#endif

    CString m_firstName;
    CString m_lastName;
    // etc. ...
};
</CODE></PRE>

<P class=indent><B><B>Note</B></B>&nbsp;&nbsp;&nbsp;Since object dumping only makes sense when you are debugging your program, the declaration of the <CODE>Dump</CODE> function is bracketed with an <B>#ifdef _DEBUG / #endif</B> block.</P>

<P>In the following example from an implementation file for the class <CODE>CPerson</CODE>, the <CODE>Dump</CODE> function’s first statement calls the <B>Dump</B> member function for its base class. It then writes a short description of each member variable along with the member’s value to the diagnostic stream.</P>

<PRE><CODE>#ifdef _DEBUG
void CPerson::Dump( CDumpContext&amp; dc ) const
{
    // call base class function first
    CObject::Dump( dc );

    // now do the stuff for our specific class
    dc &lt;&lt; "last name: " &lt;&lt; m_lastName &lt;&lt; "\n"
        &lt;&lt; "first name: " &lt;&lt; m_firstName &lt;&lt; "\n";
}
#endif
</CODE></PRE>

<P class=indent><B><B>Note</B></B>&nbsp;&nbsp;&nbsp;Again, notice that the definition of the <CODE>Dump</CODE> function is bracketed by <B>#ifdef _DEBUG / #endif</B> directives. If you refer to <B>afxDump</B> in a program linked with the nondebug libraries, you will get unresolved externals errors at link time.</P>

<P class=label><B><A NAME="_core_mfc_to_send_dump_output_to_afxdump"></A>To send Dump output to afxDump</B>

<UL type=disc>
	<LI>You must supply a <B>CDumpContext</B> argument to specify where the dump output will go when you call the <CODE>Dump</CODE> function for an object. MFC supplies a predefined <B>CDumpContext</B> object named <B>afxDump</B> that you will normally use for routine object dumping. The following example shows how to use <B>afxDump</B>:
<PRE><CODE>CPerson* pMyPerson = new CPerson;
// set some fields of the CPerson object...
//...
// now dump the contents
#ifdef _DEBUG
pMyPerson-&gt;Dump( afxDump );
#endif
</CODE></PRE>

<P class=tl>In Windows NT, <B>afxDump</B> output is sent to the debugger, if present. Otherwise, you won’t get any <B>afxDump</B> output.</P>
<P class=atl><B><B>Note</B></B>&nbsp;&nbsp;&nbsp;<B>afxDump</B> is defined only in the debug version of MFC. </p></LI>
</UL>

<P>For more information, see <A HREF="_core_the_trace_macro.htm">The TRACE Macro</A>.</P>
</font>
</BODY>
</HTML>
