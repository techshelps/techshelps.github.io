<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>_CrtSetReportHook</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_crt__crtsetreporthook"></A><SUP></SUP>_CrtSetReportHook</H1>

<P>Installs a client-defined reporting function by hooking it into the C run-time debug reporting process (debug version only).</P>

<P><B>_CRT_REPORT_HOOK</B> <B>_CrtSetReportHook(</B> <B>_CRT_REPORT_HOOK</B> <I>reportHook </I><B>);</B></P>

<TABLE border=1 cellpadding=5 cols=3 frame=below rules=rows>

<TR VALIGN="top">
<TD class=label width=30%><B>Routine</B></TD>
<TD class=label width=25%><B>Required Header</B></TD>
<TD class=label width=45%><B>Compatibility</B></TD>
</TR>

<TR VALIGN="top">
<TD width=30%><B>_CrtSetReportHook</B></TD>
<TD width=25%>&lt;crtdbg.h&gt;</TD>
<TD width=45%>Win NT, Win 95</TD>
</TR>
</TABLE><BR>

<P>For additional compatibility information, see <A HREF="_crt_compatibility.htm">Compatibility</A> in the Introduction.</P>

<P class=label><B>Libraries</B></P>

<TABLE border=1 cellpadding=5 cols=2 frame=below rules=rows>

<TR VALIGN="top">
<TD width=24%>LIBCD.LIB</TD>
<TD width=76%>Single thread static library, debug version</TD>
</TR>

<TR VALIGN="top">
<TD width=24%>LIBCMTD.LIB</TD>
<TD width=76%>Multithread static library, debug version</TD>
</TR>

<TR VALIGN="top">
<TD width=24%>MSVCRTD.LIB</TD>
<TD width=76%>Import library for MSVCRTD.DLL, debug version</TD>
</TR>
</TABLE><BR>

<P class=label><B>Return Value</B></P>

<P><B>_CrtSetReportHook</B> returns the previous client-defined reporting function.</P>

<P class=label><B>Parameter</B></P>

<P class=dt><I>reportHook</I></P>

<P class=indent>New client-defined reporting function to hook into the C run-time debug reporting process</P>

<P class=label><B>Remarks</B></P>

<P><B>_CrtSetReportHook</B> allows an application to use its own reporting function into the C run-time debug library reporting process. As a result, whenever <A HREF="_crt__crtdbgreport.htm">_CrtDbgReport</A> is called to generate a debug report, the application’s reporting function is called first. This functionality enables an application to perform operations such as filtering debug reports so it can focus on specific allocation types or send a report to destinations not available by using <B>_CrtDbgReport</B>. When <A HREF="_crt__debug.htm">_DEBUG</A> is not defined, calls to <B>_CrtSetReportHook</B> are removed during preprocessing.</P>

<P>The <B>_CrtSetReportHook</B> function installs the new client-defined reporting function specified in <I>reportHook</I> and returns the previous client-defined hook. The following example demonstrates how a client-defined report hook should be prototyped:</P>

<PRE><CODE>int YourReportHook( int reportType, char *message, int *returnValue );
</CODE></PRE>

<P>where <CODE>reportType</CODE> is the debug report type (<B>_CRT_WARN</B>, <B>_CRT_ERROR</B>, <B>_CRT_ASSERT</B>), <CODE>message</CODE> is the fully assembled debug user message to be contained in the report, and <CODE>returnValue</CODE> is the value specified by the client-defined reporting function that should be returned by <B>_CrtDbgReport</B>. See the <A HREF="_crt__crtsetreportmode.htm">_CrtSetReportMode</A> function for a complete description of the available report types.</P>

<P>If the client-defined reporting function completely handles the debug message such that no further reporting is required, then the function should return <B>TRUE</B>. When the function returns <B>FALSE</B>, <B>_CrtDbgReport</B> will be called to generate the debug report using the current settings for the report type, mode, and file. In addition, by specifying the <B>_CrtDbgReport</B> return value in <CODE>returnValue</CODE>, the application can also control whether a debug break occurs. See <B>_CrtSetReportMode</B>, <A HREF="_crt__crtsetreportfile.htm">_CrtSetReportFile</A>, and <B>_CrtDbgReport</B> for a complete description of how the debug report is configured and generated.</P>

<P>For more information about other hook-capable run-time functions and writing your own client-defined hook functions, see <A HREF="_core_writing_your_own_debug_hook_functions.htm">Writing Your Own Debug Hook Functions</A>.</P>

<P class=label><B>Example</B></P>

<PRE><CODE>/* 
 * REPORT.C:
 * In this program, calls are made to the _CrtSetReportMode,
 * _CrtSetReportFile, and _CrtSetReportHook functions.
 * The _ASSERT macros are called to evaluate their expression.
 * When the condition fails, these macros print a diagnostic message
 * and call _CrtDbgReport to generate a debug report and the
 * client-defined reporting function is called as well.
 * The _RPTn and _RPTFn group of macros are also exercised in
 * this program, as an alternative to the printf function.
 * When these macros are called, the client-defined reporting function
 * takes care of all the reporting - _CrtDbgReport won't be called.
 */

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;malloc.h&gt;
#include &lt;crtdbg.h&gt;

/* 
 * Define our own reporting function.
 * We'll hook it into the debug reporting
 * process later using _CrtSetReportHook.
 *
 * Define a global int to keep track of
 * how many assertion failures occur.
 */
int gl_num_asserts=0;
int OurReportingFunction( int reportType, char *userMessage, int *retVal )
{
   /*
    * Tell the user our reporting function is being called.
    * In other words - verify that the hook routine worked.
    */
   fprintf("Inside the client-defined reporting function.\n", STDOUT);
   fflush(STDOUT);

   /*
    * When the report type is for an ASSERT,
    * we'll report some information, but we also
    * want _CrtDbgReport to get called - 
    * so we'll return TRUE.
    *
    * When the report type is a WARNing or ERROR,
    * we'll take care of all of the reporting. We don't
    * want _CrtDbgReport to get called - 
    * so we'll return FALSE.
    */
   if (reportType == _CRT_ASSERT)
   {
      gl_num_asserts++;
      fprintf("This is the number of Assertion failures that have occurred: %d \n", gl_num_asserts, STDOUT);
      fflush(STDOUT);
      fprintf("Returning TRUE from the client-defined reporting function.\n", STDOUT);
      fflush(STDOUT);
      return(TRUE);
   } else {
      fprintf("This is the debug user message: %s \n", userMessage, STDOUT);
      fflush(STDOUT);
      fprintf("Returning FALSE from the client-defined reporting function.\n", STDOUT);
      fflush(STDOUT);
      return(FALSE);
   }

   /*
    * By setting retVal to zero, we are instructing _CrtDbgReport
    * to continue with normal execution after generating the report.
    * If we wanted _CrtDbgReport to start the debugger, we would set
    * retVal to one.
    */
   retVal = 0;
}

int main()
{
      char *p1, *p2;

   /* 
    * Hook in our client-defined reporting function.
    * Every time a _CrtDbgReport is called to generate
    * a debug report, our function will get called first.
    */
   _CrtSetReportHook( OurReportingFunction );

   /* 
    * Define the report destination(s) for each type of report
    * we are going to generate.  In this case, we are going to
    * generate a report for every report type: _CRT_WARN,
    * _CRT_ERROR, and _CRT_ASSERT.
    * The destination(s) is defined by specifying the report mode(s)
    * and report file for each report type.
    * This program sends all report types to STDOUT.
    */                                             
   _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE);
   _CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDOUT);
   _CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_FILE);
   _CrtSetReportFile(_CRT_ERROR, _CRTDBG_FILE_STDOUT);
   _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_FILE);
   _CrtSetReportFile(_CRT_ASSERT, _CRTDBG_FILE_STDOUT);

   /*
    * Allocate and assign the pointer variables
    */
   p1 = malloc(10);
   strcpy(p1, "I am p1");
   p2 = malloc(10);
   strcpy(p2, "I am p2");

   /*
    * Use the report macros as a debugging
    * warning mechanism, similar to printf.
    *
    * Use the assert macros to check if the
    * p1 and p2 variables are equivalent.
    *
    * If the expression fails, _ASSERTE will
    * include a string representation of the
    * failed expression in the report.
    *
    *  _ASSERT does not include the
    * expression in the generated report.
    */
   _RPT0(_CRT_WARN, "\n\n Use the assert macros to evaluate the expression p1 == p2.\n");
   _RPTF2(_CRT_WARN, "\n Will _ASSERT find '%s' == '%s' ?\n", p1, p2);
   _ASSERT(p1 == p2);

   _RPTF2(_CRT_WARN, "\n\n Will _ASSERTE find '%s' == '%s' ?\n", p1, p2);
   _ASSERTE(p1 == p2);

   _RPT2(_CRT_ERROR, "\n \n '%s' != '%s'\n", p1, p2);
   
   free(p2);
   free(p1);

   return 0;
}
</CODE></PRE>

<P class=label><B>Output</B></P>

<PRE><CODE>Inside the client-defined reporting function.
This is the debug user message: Use the assert macros to evaluate the expression p1 == p2
Returning FALSE from the client-defined reporting function.
Inside the client-defined reporting function.
This is the debug user message: dbgmacro.c(54) : Will _ASSERT find 'I am p1' == 'I am p2' ?
Returning FALSE from the client-defined reporting function.
Inside the client-defined reporting function.
This is the number of Assertion failures that have occurred: 1
Returning TRUE from the client-defined reporting function.
dbgmacro.c(55) : Assertion failed
Inside the client-defined reporting function.
This is the debug user message: dbgmacro.c(57) : Will _ASSERTE find 'I am p1' == 'I am p2' ?
Returning FALSE from the client-defined reporting function.
Inside the client-defined reporting function.
This is the number of Assertion failures that have occurred: 2
Returning TRUE from the client-defined reporting function.
dbgmacro.c(58) : Assertion failed: p1 == p2
Inside the client-defined reporting function.
This is the debug user message: 'I am p1' != 'I am p2'
Returning FALSE from the client-defined reporting function.

</CODE></PRE>

<P><A HREF="_crt_debug_functions.htm">Debug Functions</A></P>
</font>
</BODY>
</HTML>
