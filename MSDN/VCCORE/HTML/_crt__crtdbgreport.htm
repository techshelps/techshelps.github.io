<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>_CrtDbgReport</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>

<TABLE ALIGN=right WIDTH=0 BORDER=0><TR><TD>
<OBJECT ID="hhobj_1" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_win32_OutputDebugString">
</OBJECT>
<OBJECT ID="hhobj_2" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_win32_MessageBox">
</OBJECT>
<OBJECT ID="hhobj_3" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_win32_WriteFile">
</OBJECT>
</TD></TR></TABLE>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_crt__crtdbgreport"></A><SUP></SUP>_CrtDbgReport</H1>

<P>Generates a report with a debugging message and sends the report to three possible destinations (debug version only).</P>

<P><B>int</B> <B>_CrtDbgReport(</B> <B>int</B> <I>reportType</I><B>,</B><I> </I><B>const char</B> *<I>filename</I><B>,</B><I> </I><B>int</B> <I>linenumber</I><B>,</B> <B>const</B> <B>char</B> <B>*</B><I>moduleName</I><B>,</B> <B>const char</B> <B>*</B><I>format</I> [<B>,</B> <I>argument</I>] ... <B>);</B></P>

<TABLE border=1 cellpadding=5 cols=3 frame=below rules=rows>

<TR VALIGN="top">
<TD class=label width=23%><B>Routine</B></TD>
<TD class=label width=28%><B>Required Header</B></TD>
<TD class=label width=49%><B>Compatibility</B></TD>
</TR>

<TR VALIGN="top">
<TD width=23%><B>_CrtDbgReport</B></TD>
<TD width=28%>&lt;crtdbg.h&gt;</TD>
<TD width=49%>Win NT, Win 95</TD>
</TR>
</TABLE><BR>

<P>For additional compatibility information, see <A HREF="_crt_compatibility.htm">Compatibility</A> in the Introduction.</P>

<P class=label><B>Libraries</B></P>

<TABLE border=1 cellpadding=5 cols=2 frame=below rules=rows>

<TR VALIGN="top">
<TD width=24%>LIBCD.LIB</TD>
<TD width=76%>Single thread static library, debug version</TD>
</TR>

<TR VALIGN="top">
<TD width=24%>LIBCMTD.LIB</TD>
<TD width=76%>Multithread static library, debug version</TD>
</TR>

<TR VALIGN="top">
<TD width=24%>MSVCRTD.LIB</TD>
<TD width=76%>Import library for MSVCRTD.DLL, debug version</TD>
</TR>
</TABLE><BR>

<P class=label><B>Return Value</B></P>

<P>For all report destinations, <B>_CrtDbgReport</B> returns –1 if an error occurs and 0 if no errors are encountered. However, when the report destination is a debug message window and the user chooses the Retry button, <B>_CrtDbgReport</B> returns 1. If the user chooses the Abort button in the debug message window, <B>_CrtDbgReport</B> immediately aborts and does not return a value.</P>

<P>The <A HREF="_crt__assert.2c_._asserte_macros.htm">_ASSERT[E]</A> and <A HREF="_crt__rpt.2c_._rptf_macros.htm">_RPT, _RPTF</A> debug macros call <B>_CrtDbgReport</B> to generate their debug report. When <B>_CrtDbgReport</B> returns 1, these macros start the debugger, provided that “just-in-time” (JIT) debugging is enabled.</P>

<P class=label><B>Parameters</B></P>

<P class=dt><I>reportType</I></P>

<P class=indent>Report type: <B>_CRT_WARN</B>, <B>_CRT_ERROR</B>, <B>_CRT_ASSERT</B></P>

<P class=dt><I>filename</I></P>

<P class=indent>Pointer to name of source file where assert/report occurred or NULL</P>

<P class=dt><I>linenumber</I></P>

<P class=indent>Line number in source file where assert/report occured or NULL</P>

<P class=dt><I>moduleName</I></P>

<P class=indent>Pointer to name of module (.EXE or .DLL) where assert/report occurred</P>

<P class=dt><I>format</I></P>

<P class=indent>Pointer to format-control string used to create the user message</P>

<P class=dt><I>argument</I></P>

<P class=indent>Optional substitution arguments used by <I>format</I></P>

<P class=label><B>Remarks</B></P>

<P>The <B>_CrtDbgReport</B> function is similar to the <A HREF="_crt_printf.2c_.wprintf.htm">printf</A> function, as it can be used to report warnings, errors, and assert information to the user during the debugging process. However, this function is more flexible than <B>printf</B> because it does not need to be enclosed in <B>#ifdef</B> statements to prevent it from being called in a retail build of an application. This is achieved by using the <A HREF="_crt__debug.htm">_DEBUG</A> flag: When <A HREF="_crt__debug.htm">_DEBUG</A> is not defined, calls to <B>_CrtDbgReport</B> are removed during preprocessing.</P>

<P><B>_CrtDbgReport</B> can send the debug report to three different destinations: a debug report file, a debug monitor (the Visual C++ debugger), or a debug message window. Two configuration functions, <A HREF="_crt__crtsetreportmode.htm">_CrtSetReportMode</A> and <A HREF="_crt__crtsetreportfile.htm">_CrtSetReportFile</A>, are used to specify the destination(s) for each report type. These functions allow the reporting destination(s) for each report type to be separately controlled. For example, it is possible to specify that a <I>reportType</I> of <B>_CRT_WARN</B> only be sent to the debug monitor, while a <I>reportType</I> of <B>_CRT_ASSERT</B> be sent to a debug message window and a user-defined report file.</P>

<P><B>_CrtDbgReport</B> creates the user message for the debug report by substituting the <I>argument</I>[<I>n</I>] arguments into the <I>format</I> string, using the same rules defined by the <B>printf</B> function. <B>_CrtDbgReport</B> then generates the debug report and determines the destination(s), based on the current report modes and file defined for <I>reportType</I>. When the report is sent to a debug message window, the <I>filename</I>, <I>lineNumber</I>, and <I>moduleName</I> are included in the information displayed in the window.</P>

<P>The following table lists the available choices for the report mode(s) and file and the resulting behavior of <B>_CrtDbgReport</B>. These options are defined as bit-flags in CRTDBG.H. </P>

<TABLE border=1 cellpadding=5 cols=3 frame=below rules=rows>

<TR VALIGN="top">
<TD class=label width=18%><B>Report Mode</B></TD>
<TD class=label width=21%><B>Report File</B></TD>
<TD class=label width=61%><B>_CrtDbgReport Behavior</B></TD>
</TR>

<TR VALIGN="top">
<TD width=18%><B>_CRTDBG_-<BR>
MODE_DEBUG</B></TD>
<TD width=21%>Not applicable</TD>
<TD width=61%>Writes message to Windows <A HREF="JavaScript:hhobj_1.Click()">OutputDebugString</A> API.</TD>
</TR>

<TR VALIGN="top">
<TD width=18%><B>_CRTDBG_-<BR>
MODE_WNDW</B></TD>
<TD width=21%>Not applicable</TD>
<TD width=61%>Calls Windows <A HREF="JavaScript:hhobj_2.Click()">MessageBox</A><B> API to</B> create message box to display the message along with Abort, Retry, and Ignore buttons. If user selects Abort, _<B>CrtDbgReport</B> immediately aborts. If user selects Retry, it returns 1. If user selects Ignore, execution continues and _<B>CrtDbgReport</B> returns 0. Note that choosing Ignore when an error condition exists often results in “undefined behavior.”</TD>
</TR>

<TR VALIGN="top">
<TD width=18%><B>_CRTDBG_-<BR>
MODE_FILE</B></TD>
<TD width=21%><B>__HFILE</B></TD>
<TD width=61%>Writes message to user-supplied <B>HANDLE</B>, using the Windows <A HREF="JavaScript:hhobj_3.Click()">WriteFile</A> API, and does not verify validity of file handle; the application is responsible for opening the report file and passing a valid file handle. </TD>
</TR>

<TR VALIGN="top">
<TD width=18%><B>_CRTDBG_-<BR>
MODE_FILE</B></TD>
<TD width=21%><B>_CRTDBG_-<BR>
FILE_STDERR</B></TD>
<TD width=61%>Writes message to <B>stderr</B>.</TD>
</TR>

<TR VALIGN="top">
<TD width=18%><B>_CRTDBG_-<BR>
MODE_FILE</B></TD>
<TD width=21%><B>_CRTDBG_-<BR>
FILE_STDOUT</B></TD>
<TD width=61%>Writes message to <B>stdout</B>.</TD>
</TR>
</TABLE><BR>

<P>The report may be sent to one, two, or three destinations, or no destination at all. For more information about specifying the report mode(s) and report file, see the <B>_CrtSetReportMode</B> and <B>_CrtSetReportFile</B> functions. For more information about using the debug macros and reporting functions, see <A HREF="_core_using_macros_for_verification_and_reporting.htm">Using Macros for Verification and Reporting</A> and <A HREF="_core_debug_reporting_functions_of_the_c_run.2d.time_library.htm">Debug Reporting Functions of the C Run-Time Library</A>.</P>

<P>If your application needs more flexibility than that provided by <B>_CrtDbgReport</B>, you can write your own reporting function and hook it into the C run-time library reporting mechanism by using the <A HREF="_crt__crtsetreporthook.htm">_CrtSetReportHook</A> function.</P>

<P class=label><B>Example</B></P>

<PRE><CODE>/* 
 * REPORT.C:
 * In this program, calls are made to the _CrtSetReportMode,
 * _CrtSetReportFile, and _CrtSetReportHook functions.
 * The _ASSERT macros are called to evaluate their expression.
 * When the condition fails, these macros print a diagnostic message
 * and call _CrtDbgReport to generate a debug report and the
 * client-defined reporting function is called as well.
 * The _RPTn and _RPTFn group of macros are also exercised in
 * this program, as an alternative to the printf function.
 * When these macros are called, the client-defined reporting function
 * takes care of all the reporting - _CrtDbgReport won't be called.
 */

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;malloc.h&gt;
#include &lt;crtdbg.h&gt;

#define FALSE 0
#define TRUE !FALSE

/* 
 * Define our own reporting function.
 * We'll hook it into the debug reporting
 * process later using _CrtSetReportHook.
 *
 * Define a global int to keep track of
 * how many assertion failures occur.
 */
int gl_num_asserts=0;
int OurReportingFunction( int reportType, char *userMessage, int *retVal )
{
   /*
    * Tell the user our reporting function is being called.
    * In other words - verify that the hook routine worked.
    */
   fprintf(stdout, "Inside the client-defined reporting function.\n");
   fflush(stdout);

   /*
    * When the report type is for an ASSERT,
    * we'll report some information, but we also
    * want _CrtDbgReport to get called - 
    * so we'll return TRUE.
    *
    * When the report type is a WARNing or ERROR,
    * we'll take care of all of the reporting. We don't
    * want _CrtDbgReport to get called - 
    * so we'll return FALSE.
    */
   if (reportType == _CRT_ASSERT)
   {
      gl_num_asserts++;
      fprintf(stdout, "This is the number of Assertion failures that have occurred: %d \n", gl_num_asserts);
      fflush(stdout);
      fprintf(stdout, "Returning TRUE from the client-defined reporting function.\n");
      fflush(stdout);
      return(TRUE);
   } else {
      fprintf(stdout, "This is the debug user message: %s \n", userMessage);
      fflush(stdout);
      fprintf(stdout, "Returning FALSE from the client-defined reporting function.\n");
      fflush(stdout);
      return(FALSE);
   }

   /*
    * By setting retVal to zero, we are instructing _CrtDbgReport
    * to continue with normal execution after generating the report.
    * If we wanted _CrtDbgReport to start the debugger, we would set
    * retVal to one.
    */
   retVal = 0;
}

int main()
{
      char *p1, *p2;

   /* 
    * Hook in our client-defined reporting function.
    * Every time a _CrtDbgReport is called to generate
    * a debug report, our function will get called first.
    */
   _CrtSetReportHook( OurReportingFunction );

   /* 
    * Define the report destination(s) for each type of report
    * we are going to generate.  In this case, we are going to
    * generate a report for every report type: _CRT_WARN,
    * _CRT_ERROR, and _CRT_ASSERT.
    * The destination(s) is defined by specifying the report mode(s)
    * and report file for each report type.
    * This program sends all report types to stdout.
    */                                             
   _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE);
   _CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDOUT);
   _CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_FILE);
   _CrtSetReportFile(_CRT_ERROR, _CRTDBG_FILE_STDOUT);
   _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_FILE);
   _CrtSetReportFile(_CRT_ASSERT, _CRTDBG_FILE_STDOUT);

   /*
    * Allocate and assign the pointer variables
    */
   p1 = malloc(10);
   strcpy(p1, "I am p1");
   p2 = malloc(10);
   strcpy(p2, "I am p2");

   /*
    * Use the report macros as a debugging
    * warning mechanism, similar to printf.
    *
    * Use the assert macros to check if the
    * p1 and p2 variables are equivalent.
    *
    * If the expression fails, _ASSERTE will
    * include a string representation of the
    * failed expression in the report.
    *
    *  _ASSERT does not include the
    * expression in the generated report.
    */
   _RPT0(_CRT_WARN, "\n\n Use the assert macros to evaluate the expression p1 == p2.\n");
   _RPTF2(_CRT_WARN, "\n Will _ASSERT find '%s' == '%s' ?\n", p1, p2);
   _ASSERT(p1 == p2);

   _RPTF2(_CRT_WARN, "\n\n Will _ASSERTE find '%s' == '%s' ?\n", p1, p2);
   _ASSERTE(p1 == p2);

   _RPT2(_CRT_ERROR, "\n \n '%s' != '%s'\n", p1, p2);
   
   free(p2);
   free(p1);

   return 0;
}
</CODE></PRE>

<P class=label><B>Output</B></P>

<PRE><CODE>Inside the client-defined reporting function.
This is the debug user message: Use the assert macros to evaluate the expression p1 == p2
Returning FALSE from the client-defined reporting function.
Inside the client-defined reporting function.
This is the debug user message: dbgmacro.c(54) : Will _ASSERT find 'I am p1' == 'I am p2' ?
Returning FALSE from the client-defined reporting function.
Inside the client-defined reporting function.
This is the number of Assertion failures that have occurred: 1
Returning TRUE from the client-defined reporting function.
dbgmacro.c(55) : Assertion failed
Inside the client-defined reporting function.
This is the debug user message: dbgmacro.c(57) : Will _ASSERTE find 'I am p1' == 'I am p2' ?
Returning FALSE from the client-defined reporting function.
Inside the client-defined reporting function.
This is the number of Assertion failures that have occurred: 2
Returning TRUE from the client-defined reporting function.
dbgmacro.c(58) : Assertion failed: p1 == p2
Inside the client-defined reporting function.
This is the debug user message: 'I am p1' != 'I am p2'
Returning FALSE from the client-defined reporting function.
</CODE></PRE>

<P><A HREF="_crt_debug_functions.htm">Debug Functions</A></P>

<P><B>See Also</B>&nbsp;&nbsp;&nbsp;<A HREF="_crt__crtsetreportmode.htm">_CrtSetReportMode</A>, <A HREF="_crt__crtsetreportfile.htm">_CrtSetReportFile</A>, <A HREF="_crt_printf.2c_.wprintf.htm">printf</A>, <A HREF="_crt__debug.htm">_DEBUG</A></P>
</font>
</BODY>
</HTML>
