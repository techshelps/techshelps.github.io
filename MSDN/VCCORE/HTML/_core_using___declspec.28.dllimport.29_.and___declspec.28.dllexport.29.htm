<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using __declspec(dllimport) and __declspec(dllexport)</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>

<TABLE ALIGN=right WIDTH=0 BORDER=0><TR><TD>
<OBJECT ID="hhobj_1" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_vc_addpf_home">
</OBJECT>
</TD></TR></TABLE>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_core_using___declspec.28.dllimport.29_.and___declspec.28.dllexport.29"></A>Using __declspec(dllimport) and __declspec(dllexport)</H1>

<P><A HREF="JavaScript:hhobj_1.Click()">Home</A>  |&nbsp; <A HREF="_core_dlls.3a_.overview.htm">Overview</A>  |&nbsp; <A HREF="_core_dll_tasks.htm">How Do I</A>  |&nbsp; <A HREF="_core_dlls.3a_.frequently_asked_questions.htm">FAQ</A>  |&nbsp; <A HREF="_core_dll_topics.htm">Details</A>  |&nbsp; <A HREF="_core_dll_sample_programs.htm">Sample</A></P>

<P>The 32-bit edition of Visual C++ uses <B>__declspec(dllimport)</B> and <B>__declspec(dllexport)</B> to replace the <B>__export</B> keyword previously used in 16-bit versions of Visual C++.</P>

<P>You do not need to use <B>__declspec(dllimport)</B> for your code to compile correctly, but doing so allows the compiler to generate better code. The compiler is able to generate better code because it knows for sure whether a function exists in a DLL or not, so the compiler can produce code that skips a level of indirection that would normally be present in a function call that crossed a DLL boundary. However, you must use <B>__declspec(dllimport) </B>in order to import variables used in a DLL.</P>

<P>With the proper .DEF file EXPORTS section, <B>__declspec(dllexport)</B> is not required. <B>__declspec(dllexport)</B> was added to provide an easy way to export functions from an .EXE or .DLL without using a .DEF file.</P>

<P>The Win32 Portable Executable format is designed to minimize the number of pages that must be touched to fix imports. To do this, it places all the import addresses for any program in one place called the Import Address Table. This allows the loader to modify only one or two pages when accessing these imports.</P>

<H2>Using _declspec(dllimport) for Function Calls</H2>

<P>In the following code example, assume <CODE>func1</CODE> is a function that resides in a DLL separate from the .EXE file that contains the <B>main</B> function.</P>

<P>Without <B>__declspec(dllimport)</B>, given this code:</P>

<PRE><CODE>   void main(void) 
   {
       func1();
   }
</CODE></PRE>

<P>the compiler generates code that looks like this:</P>

<PRE><CODE>    call func1
</CODE></PRE>

<P>and the linker translates the call into something like this:</P>

<PRE><CODE>    call 0x4000000         ; The address of 'func1'.
</CODE></PRE>

<P>If <CODE>func1</CODE> exists in another DLL, the linker can't resolve this directly because it has no way of knowing what the address of <CODE>func1</CODE> is. In 16-bit environments, the linker adds this code address to a list in the .EXE that the loader would patch at run time with the correct address. In 32-bit environments, the linker generates a thunk of which it does know the address. The thunk looks like:</P>

<PRE><CODE>   0x40000000:    jmp DWORD PTR __imp_func1
</CODE></PRE>

<P>Here <CODE>__imp_func1</CODE> is the address for <CODE>func1</CODE>'s slot in the import address table of the .EXE file. All the addresses are thus known to the linker. The loader only has to update the .EXE file's import address table at load time for everything to work correctly.</P>

<P>Therefore, using <B>__declspec(dllimport)</B> is better because if the linker does not generate a thunk if it is not required. Thunks make the code larger (on RISC systems, it can be several instructions) and can degrade your cache performance. If you tell the compiler the function is in a DLL, it can generate an indirect call for you.</P>

<P>So now this code:</P>

<PRE><CODE>   __declspec(dllimport) void func1(void);
   void main(void) 
   {
       func1();
   }
</CODE></PRE>

<P>generates this instruction:</P>

<PRE><CODE>   call DWORD PTR __imp_func1
</CODE></PRE>

<P>There is no thunk and no <CODE>jmp</CODE> instruction, so the code is smaller and faster.</P>

<P>On the other hand, for function calls inside a DLL, you don't want to have to use an indirect call. You already know a function's address. Time and space is required to load and store the address of the function before an indirect call, so a direct call is always faster and smaller. You only want to&nbsp; use <B>__declspec(dllimport)</B> when calling DLL functions from the outside the DLL itself. Don't use <B>__declspec(dllimport)</B> on functions inside a DLL when building that DLL.</P>

<H2>Using _declspec(dllexport)</H2>

<P>Microsoft introduced <B>__export</B> in the 16-bit compiler version of Visual C++ to allow the compiler to generate the export names automatically and place them in a .LIB file. This .LIB file could then be used just like a static .LIB to link with a DLL.</P>

<P>Microsoft added <B>__declspec(dllexport)</B> to continue this convenience. Its purpose is to add the export directive to the object file so you don't need a .DEF file.</P>

<P>This convenience is most apparent when trying to export decorated C++ function names. There is no standard specification for name decoration, so the name of an exported function may change between compiler versions. If you use <B>__declspec(dllexport)</B>, recompiling the DLL and dependent .EXE files is necessary only to account for any naming convention changes.</P>

<P>Many export directives, such as ordinals, NONAME, and PRIVATE, can be made only in a .DEF file, and there is no way to specify these attributes without a .DEF file. However, using <B>__declspec(dllexport)</B> in addition to using a .DEF file does not cause build errors.</P>

<P>As a reference, search through the Win32 WINBASE.H header file. It contains examples of <B>__declspec(dllimport)</B> usage.</P>

<H2>Using __declspec(dllexport) and __declspec(dllimport) on Data</H2>

<P>In the case of data, using <B>__declspec(dllimport)</B> is a convenience item that removes a layer of indirection. When you import data from a DLL, you still have to go through the import address table. In the Win32 days before <B>__declspec(dllimport)</B>, this meant you had to remember to do an extra level of indirection when accessing data exported from the DLL:</P>

<PRE><CODE>   // project.h
   #ifdef _DLL     // If accessing the data from inside            //the DLL
      ULONG ulDataInDll;

   #else            // If accessing the data from                //outside the DLL
      ULONG *ulDataInDll;
   #endif
</CODE></PRE>

<P>You would then export the data in your .DEF file:</P>

<PRE><CODE>   // project.def
   LIBRARY project
   EXPORTS
       ulDataInDll   CONSTANT
</CODE></PRE>

<P>and access it outside the DLL:</P>

<PRE><CODE>   if (*ulDataInDll == 0L) 
   {
      // Do stuff here
   }
</CODE></PRE>

<P>When you mark the data as <B>__declspec(dllimport)</B>, the compiler automatically generates the indirection code for you. You no longer have to worry about the steps above. As stated previously, do not use <B>__declspec(dllimport)</B> declaration on the data when building the DLL. Functions within the DLL will not use the import address table to access the data object; therefore, you will not have the extra level of indirection present.</P>

<P>To export the data automatically from the DLL, use this declaration:</P>

<PRE><CODE>   __declspec(dllexport) ULONG ulDataInDLL;
</CODE></PRE>

<H2>Using a .DEF File</H2>

<P>If you choose to use <B>__declspec(dllimport)</B> along with a .DEF file, you should change the .DEF file to use DATA in place of CONSTANT to reduce the likelihood that incorrect coding will cause a problem:</P>

<PRE><CODE>   // project.def
   LIBRARY project
   EXPORTS
       ulDataInDll   DATA
</CODE></PRE>

<P>The following table shows why:</P>

<TABLE border=1 cellpadding=5 cols=3 frame=below rules=rows>

<TR VALIGN="top">
<TD class=label width=21%><B>Keyword</B></TD>
<TD class=label width=39%><B>Emits in the import library</B></TD>
<TD class=label width=40%><B>Exports</B></TD>
</TR>

<TR VALIGN="top">
<TD width=21%><CODE>CONSTANT</CODE></TD>
<TD width=39%><CODE>_imp_ulDataInDll</CODE><BR>
<CODE>_ulDataInDll</CODE></TD>
<TD width=40%><CODE>_ulDataInDll</CODE></TD>
</TR>

<TR VALIGN="top">
<TD width=21%><CODE>DATA</CODE></TD>
<TD width=39%><CODE>_imp_ulDataInDll</CODE></TD>
<TD width=40%><CODE>_ulDataInDll</CODE></TD>
</TR>
</TABLE><BR>

<P>Using <B>__declspec(dllimport) </B>and CONSTANT lists both the <CODE>__imp_</CODE> version and the undecorated name in the .LIB DLL import library that is created to allow explicit linking. Using <B>__declspec(dllimport)</B> and DATA lists just the <CODE>__imp_</CODE> version of the name. </P>

<P>If you use CONSTANT, either of the following code constructs could be used to access the <CODE>ulDataInDll</CODE>:</P>

<PRE><CODE>   __declspec(dllimport) ULONG ulDataInDll; /*prototype*/
   if (ulDataInDll == 0L)   /*sample code fragment*/
</CODE></PRE>

<P>&nbsp;&nbsp;&nbsp;  -or-</P>

<PRE><CODE>   ULONG *ulDataInDll;      /*prototype*/
   if (*ulDataInDll == 0L)  /*sample code fragment*/
</CODE></PRE>

<P>However, if you use DATA in your .DEF file, only code compiled with the following definition can access the variable <CODE>ulDataInDll</CODE>:</P>

<PRE><CODE>  __declspec(dllimport) ULONG ulDataInDll;

  if (ulDataInDll == 0L)   /*sample code fragment*/
</CODE></PRE>

<P>Using CONSTANT is more risky because if you forget to use the extra level of indirection, you could potentially access the import address table's pointer to the variable — not the variable itself. This type of problem can often manifest as an access violation because the import address table is currently made read-only by the Microsoft compiler and linkers.</P>

<P>The Current Visual C++ linker issues a warning if it sees CONSTANT in the .DEF file to account for this case. The only real reason to use CONSTANT is if you can't recompile some object file where the header file didn't list <B>__declspec(dllimport)</B> on the prototype.</P>

<H3>What do you want to do?</H3>

<UL type=disc>
	<LI><A HREF="_core_export_from_a_dll_using_..def_files.htm">Export from a DLL using .DEF files</A><BR><BR></LI>

	<LI><A HREF="_core_export_and_import_using_afx_ext_class.htm">Export and import using AFX_EXT_CLASS</A><BR><BR></LI>

	<LI><A HREF="_core_export_c.2b2b_.functions_for_use_in_c.2d.language_executables.htm">Export C++ functions for use in C-language executables</A><BR><BR></LI>

	<LI><A HREF="_core_determine_which_exporting_method_to_use.htm">Determine which exporting method to use</A></LI>
</UL>
</font>
</BODY>
</HTML>
