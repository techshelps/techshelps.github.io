<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The .pdb Files</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_core_the_..pdb_files"></A>The .pdb Files </H1>

<P>The .pdb (program database) file holds debugging and project state information. The .pdb file provides the information needed for incremental linking of debug program versions.</P>

<P>Although earlier, 16-bit versions of Visual C++ used .pdb files, the debugging information stored in them was appended to the end of the .exe or .DLL file by the linker. Now, with 32-bit .exe’s, both the linker and the integrated debugger allow .pdb files to be used directly during the debugging process, eliminating substantial amounts of work for the linker and bypassing the cumbersome CVPACK limit of 64K types. </P>

<P>By default, when you build projects generated by Visual C++, the compiler switch <B>/Fd</B> is used to rename the .pdb file to &lt;project&gt;.pdb. Therefore, you will have only one .pdb file for the entire project. </P>

<P>When you run makefiles that were not generated by Visual C++, and the <B>/Fd</B> is not used with <B>/Zi</B>, you will end up with two .pdb files:

<UL type=disc>
	<LI>VC<I>x</I>0.pdb (where <I>x</I> refers to the major version of the corresponding Visual C++). This file stores all debugging information for the individual .obj files and resides in the directory of the project makefile.<BR><BR></LI>

	<LI>&lt;project&gt;.pdb&nbsp;&nbsp;&nbsp;This file stores all debugging information for the resulting .exe file and resides in the \WINDEBUG subdirectory.</LI>
</UL>

<P>Why two files? When the compiler is run, it doesn't know the name of the .exe file into which the .obj files will be linked, so the compiler can't insert the information into &lt;project&gt;.pdb. The two files store different information. Each time you compile an .obj file, the compiler merges the debugging information into VC<I>x</I>0.pdb. It only inserts information concerning types and does not insert symbol information such as function definitions. One benefit of this is that when every source file includes common header files such as &lt;windows.h&gt;, all the typedefs from these headers are only stored once, rather than in every .obj file. </P>

<P>When you run the linker, it creates &lt;project&gt;.pdb, which holds the debugging information for the project's .exe file. All debugging information, including function prototypes and everything else, is placed into &lt;project&gt;.PDB, not just the type information found in VC<I>x</I>0.pdb. The two kinds of .PDB files share the same extension because they are architecturally similar and they both allow incremental updates. Nevertheless, they actually store different information. </P>

<P>The Visual C++ debugger uses the &lt;project&gt;.pdb file created by the linker directly, and embeds the absolute path to the .pdb in the .exe or .dll file. If the debugger can't find the .pdb file at that location or if the path is invalid (for example, if the project was moved to another computer), the debugger looks for it in the current directory. </P>
</font>
</BODY>
</HTML>
