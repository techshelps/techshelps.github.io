<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Exceptions: Freeing Objects in Exceptions</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>

<TABLE ALIGN=right WIDTH=0 BORDER=0><TR><TD>
<OBJECT ID="hhobj_1" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_vc_addpf_home">
</OBJECT>
</TD></TR></TABLE>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_core_exceptions.3a_.freeing_objects_in_exceptions"></A>Exceptions: Freeing Objects in Exceptions</H1>

<P><A HREF="JavaScript:hhobj_1.Click()">Home</A>  |&nbsp; <A HREF="_core_exception_handling.3a_.overview.htm">Overview</A>  |&nbsp; <A HREF="_core_exception_handling_tasks.htm">How Do I</A>  |&nbsp; <A HREF="_core_exception_handling.3a_.frequently_asked_questions.htm">FAQ</A></P>

<P>This article explains the need and the method of freeing objects when an exception occurs. Topics include:

<UL type=disc>
	<LI><A HREF="#_core_handling_the_exception_locally">Handling the exception locally</A><BR><BR></LI>

	<LI><A HREF="#_core_throwing_exceptions_after_destroying_objects">Throwing exceptions after destroying objects</A></LI>
</UL>

<P>Exceptions thrown by the framework or by your application interrupt normal program flow. Thus, it is very important to keep close track of objects so that you can properly dispose of them in case an exception is thrown.</P>

<P>There are two primary methods to do this.

<UL type=disc>
	<LI>Handle exceptions locally using the <B>try</B> and <B>catch</B> keywords, then destroy all objects with one statement.<BR><BR></LI>

	<LI>Destroy any object in the <B>catch</B> block before throwing the exception outside the block for further handling.</LI>
</UL>

<P>These two approaches are illustrated below as solutions to the following problematic example:</P>

<PRE><CODE>void SomeFunc()        // Problematic code
{
    CPerson* myPerson = new CPerson;

    // Do something that might throw an exception.
    myPerson-&gt;SomeFunc();

    // Now destroy the object before exiting.
    delete myPerson;
}
</CODE></PRE>

<P>As written above, <CODE>myPerson</CODE> will not be deleted if an exception is thrown by <CODE>SomeFunc</CODE>. Execution jumps directly to the next outer exception handler, bypassing the normal function exit and the code that deletes the object. The pointer to the object goes out of scope when the exception leaves the function, and the memory occupied by the object will never be recovered as long as the program is running. This is a memory leak; it would be detected by using the memory diagnostics.</P>



<H2><A NAME="_core_handling_the_exception_locally"></A>Handling the Exception Locally</H2>

<P>The <B>try/catch</B> paradigm provides a defensive programming method for avoiding memory leaks and ensuring that your objects are destroyed when exceptions occur. For instance, the example shown earlier in this article could be rewritten as follows:</P>

<PRE><CODE>void SomeFunc()
{
    CPerson* myPerson = new CPerson;

    try
    {
        // Do something that might throw an exception.
        myPerson-&gt;SomeFunc();
    }
    catch( CException* e )
    {
        // Handle the exception locally
        e-&gt;Delete();
    }

    // Now destroy the object before exiting.
    delete myPerson;
}
</CODE></PRE>

<P>This new example sets up an exception handler to catch the exception and handle it locally. It then exits the function normally and destroys the object. The important aspect of this example is that a context to catch the exception is established with the <B>try/catch</B> blocks. Without a local exception frame, the function would never know that an exception had been thrown and would not have the chance to exit normally and destroy the object.</P>



<H2><A NAME="_core_throwing_exceptions_after_destroying_objects"></A>Throwing Exceptions After Destroying Objects</H2>

<P>Another way to handle exceptions is to pass them on to the next outer exception-handling context. In your <B>catch</B> block, you can do some cleanup of your locally allocated objects and then throw the exception on for further processing.</P>

<P>The throwing function may or may not need to deallocate heap objects. If the function always deallocates the heap object before returning in the normal case, then the function should also deallocate the heap object before throwing the exception. On the other hand, if the function does not normally deallocate the object before returning in the normal case, then you must decide on a case-by-case basis whether the heap object should be deallocated.</P>

<P>The following example shows how locally allocated objects can be cleaned up:</P>

<PRE><CODE>void SomeFunc()
{
    CPerson* myPerson = new CPerson;

    try
    {
        // Do something that might throw an exception.
        myPerson-&gt;SomeFunc();
    }
    catch( CException e )
    {
         // Destroy the object before passing exception on.
        delete myPerson;
        // Throw the exception to the next handler.
        throw;
    }

    // On normal exits, destroy the object.
    delete myPerson;
}
</CODE></PRE>

<P>The exception mechanism automatically deallocates frame objects; the destructor of the frame object is also called.</P>

<P>If you call functions that can throw exceptions, you can use <B>try/catch</B> blocks to make sure that you catch the exceptions and have a chance to destroy any objects you have created. In particular, be aware that many MFC functions can throw exceptions.</P>

<P>For related information, see <A HREF="_core_exceptions.3a_.catching_and_deleting_exceptions.htm">Exceptions: Catching and Deleting Exceptions</A>. </P>
</font>
</BODY>
</HTML>
