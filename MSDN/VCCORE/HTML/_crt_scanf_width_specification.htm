<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>scanf Width Specification</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_crt_scanf_width_specification"></A><SUP></SUP>scanf Width Specification</H1>

<P><I>width</I> is a positive decimal integer controlling the maximum number of characters to be read from <B>stdin</B>. No more than <I>width</I> characters are converted and stored at the corresponding <I>argument</I>. Fewer than <I>width</I> characters may be read if a white-space character (space, tab, or newline) or a character that cannot be converted according to the given format occurs before <I>width</I> is reached.</P>

<P>The optional prefixes <B>h</B>, <B>l</B>, <B>I64</B>, and <B>L</B> indicate the “size” of the <I>argument</I> (long or short, single-byte character or wide character, depending upon the type character that they modify). These format-specification characters are used with type characters in <B>scanf</B> or <B>wscanf</B> functions to specify interpretation of arguments as shown in the Table R.7. The type prefixes <B>h</B>, <B>l</B>, <B>I64</B>, and <B>L</B> are Microsoft extensions and are not ANSI-compatible. The type characters and their meanings are described in <A HREF="_crt_scanf_type_field_characters.htm#_crt_table_r..8">Table R.8</A>.</P>

<P class=label><B><A NAME="_crt_table_r..7"></A>Table R.7&nbsp;&nbsp;&nbsp;Size Prefixes for scanf and wscanf Format-Type Specifiers</B></P>

<TABLE border=1 cellpadding=5 cols=3 frame=below rules=rows>

<TR VALIGN="top">
<TD class=label width=49%><B>To Specify</B></TD>
<TD class=label width=18%><B>Use Prefix</B></TD>
<TD class=label width=33%><B>With Type Specifier</B></TD>
</TR>

<TR VALIGN="top">
<TD width=49%><B>double</B></TD>
<TD width=18%><B>l</B></TD>
<TD width=33%><B>e</B>, <B>E</B>, <B>f</B>, <B>g</B>, or <B>G</B></TD>
</TR>

<TR VALIGN="top">
<TD width=49%><B>long int</B></TD>
<TD width=18%><B>l</B></TD>
<TD width=33%><B>d</B>, <B>i</B>, <B>o</B>, <B>x</B>, or <B>X</B></TD>
</TR>

<TR VALIGN="top">
<TD width=49%><B>long unsigned int</B></TD>
<TD width=18%><B>l</B></TD>
<TD width=33%><B>u</B></TD>
</TR>

<TR VALIGN="top">
<TD width=49%><B>short int</B></TD>
<TD width=18%><B>h</B></TD>
<TD width=33%><B>d</B>, <B>i</B>, <B>o</B>, <B>x</B>, or <B>X</B></TD>
</TR>

<TR VALIGN="top">
<TD width=49%><B>short unsigned int</B></TD>
<TD width=18%><B>h</B></TD>
<TD width=33%><B>u</B></TD>
</TR>

<TR VALIGN="top">
<TD width=49%>__<B>int64</B></TD>
<TD width=18%><B>I64</B></TD>
<TD width=33%><B>d</B>, <B>i</B>, <B>o</B>, <B>u</B>, <B>x</B>, or <B>X</B></TD>
</TR>

<TR VALIGN="top">
<TD width=49%>Single-byte character with <B>scanf</B></TD>
<TD width=18%><B>h</B></TD>
<TD width=33%><B>c or</B> <B>C</B></TD>
</TR>

<TR VALIGN="top">
<TD width=49%>Single-byte character with <B>wscanf</B></TD>
<TD width=18%><B>h</B></TD>
<TD width=33%><B>c</B> or <B>C</B></TD>
</TR>

<TR VALIGN="top">
<TD width=49%>Wide character with <B>scanf</B></TD>
<TD width=18%><B>l</B></TD>
<TD width=33%><B>c</B> or <B>C</B></TD>
</TR>

<TR VALIGN="top">
<TD width=49%>Wide character with <B>wscanf</B></TD>
<TD width=18%><B>l</B></TD>
<TD width=33%><B>c</B>, or <B>C</B></TD>
</TR>

<TR VALIGN="top">
<TD width=49%>Single-byte – character string with <B>scanf</B></TD>
<TD width=18%><B>h</B></TD>
<TD width=33%><B>s</B> or <B>S</B></TD>
</TR>

<TR VALIGN="top">
<TD width=49%>Single-byte – character string with <B>wscanf</B></TD>
<TD width=18%><B>h</B></TD>
<TD width=33%><B>s</B> or <B>S</B></TD>
</TR>

<TR VALIGN="top">
<TD width=49%>Wide-character string with <B>scanf</B></TD>
<TD width=18%><B>l</B></TD>
<TD width=33%><B>s</B> or <B>S</B></TD>
</TR>

<TR VALIGN="top">
<TD width=49%>Wide-character string with <B>wscanf</B></TD>
<TD width=18%><B>l</B></TD>
<TD width=33%><B>s</B> or <B>S</B></TD>
</TR>
</TABLE><BR>

<P>Following are examples of the use of <B>h</B> and <B>l</B> with <B>scanf</B>functions and <B>wscanf</B> functions:</P>

<PRE><CODE>scanf( "%ls", &amp;x );    // Read a wide-character string
wscanf( "%lC", &amp;x );    // Read a single-byte character
</CODE></PRE>

<P>To read strings not delimited by space characters, a set of characters in brackets (<B>[ ]</B>) can be substituted for the <B>s</B> (string) type character. The corresponding input field is read up to the first character that does not appear in the bracketed character set. If the first character in the set is a caret (<B>^</B>), the effect is reversed: The input field is read up to the first character that does appear in the rest of the character set.</P>

<P>Note that <B>%[a-z]</B> and <B>%[z-a]</B> are interpreted as equivalent to <B>%[abcde...z]</B>. This is a common <B>scanf</B> function extension, but note that the ANSI standard does not require it.</P>

<P>To store a string without storing a terminating null character ('\0'), use the specification <B>%</B><I>n</I><B>c</B> where <I>n</I> is a decimal integer. In this case, the <B>c</B> type character indicates that the argument is a pointer to a character array. The next <I>n</I> characters are read from the input stream into the specified location, and no null character ('\0') is appended. If <I>n</I> is not specified, its default value is 1.</P>

<P>The <B>scanf</B> function scans each input field, character by character. It may stop reading a particular input field before it reaches a space character for a variety of reasons:

<UL type=disc>
	<LI>The specified width has been reached.<BR><BR></LI>

	<LI>The next character cannot be converted as specified.<BR><BR></LI>

	<LI>The next character conflicts with a character in the control string that it is supposed to match. <BR><BR></LI>

	<LI>The next character fails to appear in a given character set.</LI>
</UL>

<P>For whatever reason, when the <B>scanf</B> function stops reading an input field, the next input field is considered to begin at the first unread character. The conflicting character, if there is one, is considered unread and is the first character of the next input field or the first character in subsequent read operations on <B>stdin</B>.</P>
</font>
</BODY>
</HTML>
