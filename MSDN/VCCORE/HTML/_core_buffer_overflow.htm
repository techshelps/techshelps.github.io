<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Buffer Overflow</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>

<TABLE ALIGN=right WIDTH=0 BORDER=0><TR><TD>
<OBJECT ID="hhobj_1" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_vc_addpf_home">
</OBJECT>
</TD></TR></TABLE>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_core_buffer_overflow"></A><SUP></SUP>Buffer Overflow</H1>

<P><A HREF="JavaScript:hhobj_1.Click()">Home</A>  |&nbsp; <A HREF="_core_unicode_programming_tasks.htm">Unicode Tasks</A>  |&nbsp; <A HREF="_core_multibyte_character_set_.28.mbcs.29_.tasks.htm">Multibyte Character Set (MBCS) Tasks</A></P>

<P>Varying character sizes can cause problems when you put characters into a buffer. Consider the following code, which copies characters from a string, <CODE>sz</CODE>, into a buffer, <CODE>rgch</CODE>:</P>

<PRE><CODE>cb = 0;
while( cb &lt; sizeof( rgch ) )
    rgch[ cb++ ] = *sz++;
</CODE></PRE>

<P>The question is: Was the last byte copied a lead byte? The following does not solve the problem because it can potentially overflow the buffer:</P>

<PRE><CODE>cb = 0;
while( cb &lt; sizeof( rgch ) )
{
    _mbccpy( rgch + cb, sz );
    cb += _mbclen( sz );
    sz = _mbsinc( sz );
}
</CODE></PRE>

<P>The <B>_mbccpy</B> call attempts to do the right thing&nbsp; —  copy the full character, whether it’s one or two bytes. But it doesn’t take into account that the last character copied may not fit the buffer if the character is two bytes wide. The correct solution is:</P>

<PRE><CODE>cb = 0;
while( (cb + _mbclen( sz )) &lt;= sizeof( rgch ) )
{
    _mbccpy( rgch + cb, sz );
    cb += _mbclen( sz );
    sz = _mbsinc( sz );
}
</CODE></PRE>

<P>This code tests for possible buffer overflow in the loop test, using <B>_mbclen</B> to test the size of the current character pointed to by <CODE>sz</CODE>. By making a call to the <B>_mbsnbcpy</B> function, you can replace the code in the <B>while</B> loop with a single line of code. For example:</P>

<PRE><CODE>cb = 0;
while( (cb + _mbclen( sz )) &lt;= sizeof( rgch ) )
{
    _mbsnbcpy( rgch, sz, sizeof( rgch ) );
}
</CODE></PRE>
</font>
</BODY>
</HTML>
