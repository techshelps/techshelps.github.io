<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Handling a Drag-and-Drop Operation</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>

<TABLE ALIGN=right WIDTH=0 BORDER=0><TR><TD>
<OBJECT ID="hhobj_1" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_vc_addpf_home">
</OBJECT>
</TD></TR></TABLE>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_core_handling_a_drag.2d.and.2d.drop_operation"></A>Handling a Drag-and-Drop Operation</H1>

<P><A HREF="JavaScript:hhobj_1.Click()">Home</A>  |&nbsp; <A HREF="_core_win32_programming.3a_.overview.htm">Overview</A> |&nbsp; <A HREF="_core_win32_programming_tasks.htm">How Do I</A></P>

<P>The actual work of handling a drag-and-drop operation is done by overriding four member functions defined by <B>CView</B>:&nbsp; </P>

<PRE><CODE>virtual BOOL OnDrop(COleDataObject* pDataObject,
         DROPEFFECT dropEffect, CPoint point);
virtual DROPEFFECT OnDragEnter(COleDataObject* pDataObject,
            DWORD grfKeyState, CPoint point);
virtual DROPEFFECT OnDragOver(COleDataObject* pDataObject,
            DWORD grfKeyState, CPoint point);
virtual void OnDragLeave();
</CODE></PRE>

<P>These functions are called by the OLE system DLL (via the MFC framework) during a drag-and-drop operation. </P>

<P>The first function called during an actual drag-and-drop operation is <B>OnDragEnter</B>, which is called when the mouse first enters the window:&nbsp; </P>

<PRE><CODE>DROPEFFECT CDrawView::OnDragEnter(COleDataObject* pDataObject,
   DWORD grfKeyState, CPoint point)
{
   ASSERT(m_prevDropEffect == DROPEFFECT_NONE);
   m_bDragDataAcceptable = FALSE;
   if (!COleClientItem::CanCreateFromData( pDataObject ))
      return DROPEFFECT_NONE;

   GetObjectInfo(pDataObject, &amp;m_dragSize, &amp;m_dragOffset);
   CClientDC dc(NULL);
   dc.HIMETRICtoDP(&amp;m_dragSize);
   dc.HIMETRICtoDP(&amp;m_dragOffset);

   return OnDragOver(pDataObject, grfKeyState, point);
}
</CODE></PRE>

<P>This function first checks whether the <B>COleDataObject</B> provided by the drop source contains data that DRAWCLI can use. If not, the function sets a flag indicating that the data is unacceptable, and returns <B>DROPEFFECT_NONE</B>, indicating that a drop operation would have no effect. On the other hand, if DRAWCLI can use the data, the function computes the size and position of the focus rectangle. It does this by using the <CODE>GetObjectInfo</CODE> helper function to get the size of the object in the <B>COleDataObject</B> object. </P>

<P>The next function called during a drag-and-drop operation is <B>OnDragOver</B>, which is called whenever the mouse moves within the window. This function is responsible for determining whether the window can accept the drop operation, and if so, for providing target feedback: </P>

<PRE><CODE>DROPEFFECT CDrawView::OnDragOver(COleDataObject*,
   DWORD grfKeyState, CPoint point)
{
   if (m_bDragDataAcceptable == FALSE)
      return DROPEFFECT_NONE;

   point -= m_dragOffset;  // adjust target rect by cursor offset

   // check for point outside logical area 
   // GetTotalSize() returns the size passed to SetScrollSizes()
   CRect rectScroll(CPoint(0, 0), GetTotalSize());

   CRect rectItem(point,m_dragSize);
   rectItem.OffsetRect(GetDeviceScrollPosition());

   DROPEFFECT de = DROPEFFECT_NONE;
   CRect rectTemp;
   if (rectTemp.IntersectRect(rectScroll, rectItem))
   {
      // check for force link
      if ((grfKeyState &amp; (MK_CONTROL|MK_SHIFT)) == 
         (MK_CONTROL|MK_SHIFT))
         de = DROPEFFECT_NONE; // we don’t support linking
      // check for force copy
      else if ((grfKeyState &amp; MK_CONTROL) == MK_CONTROL)
         de = DROPEFFECT_COPY;
      // check for force move
      else if ((grfKeyState &amp; MK_ALT) == MK_ALT)
         de = DROPEFFECT_MOVE;
      // default -- recommended action is move
      else
         de = DROPEFFECT_MOVE;
   }

   if (point == m_dragPoint)
      return de;

   // else, cursor has moved -- need to update the drag feedback
   CClientDC dc(this);
   if (m_prevDropEffect != DROPEFFECT_NONE)
   {
      // erase previous focus rect
      dc.DrawFocusRect(CRect(m_dragPoint, m_dragSize));
   }
   m_prevDropEffect = de;
   if (m_prevDropEffect != DROPEFFECT_NONE)
   {
      m_dragPoint = point;
      dc.DrawFocusRect(CRect(point, m_dragSize));
   }
   return de;
}
</CODE></PRE>

<P>This function first checks the flag <CODE>m_bDragDataAcceptable</CODE> to see if it’s necessary to do any more processing. If so, the function then checks which, if any, keys are being depressed, determining whether the user wants a link operation, a move, or a copy. Since DRAWCLI isn’t a linking container, this function returns <B>DROPEFFECT_NONE</B> when a link operation is specified, meaning that the view won’t accept the dragged object. DRAWCLI does accept copy or move operations, so the function returns <B>DROPEFFECT_COPY</B> and <B>DROPEFFECT_MOVE</B> in those instances. (The drop source receives these <B>DROPEFFECT</B> values and modifies the mouse cursor appropriately.) Finally, if the operation is a copy or a move, the function draws the focus rectangle to indicate where the object would land if it were dropped. </P>

<P>If the mouse leaves the window without having dropped the object, the function that gets called is <B>OnDragLeave</B>. This function simply performs a little clean-up: </P>

<PRE><CODE>void CDrawView::OnDragLeave()
{
   CClientDC dc(this);
   if (m_prevDropEffect != DROPEFFECT_NONE)
   {
      // erase previous focus rect
      dc.DrawFocusRect(CRect(m_dragPoint,m_dragSize)); 
      m_prevDropEffect = DROPEFFECT_NONE;
   }
}
</CODE></PRE>

<P>If the drag-and-drop operation was one that DRAWCLI was willing to accept, the function removes the target feedback by erasing the last focus rectangle drawn. </P>

<P>Finally, the function that gets called if the user actually performs the drop is <B>OnDrop</B>: </P>

<PRE><CODE>BOOL CDrawView::OnDrop(COleDataObject* pDataObject,
   DROPEFFECT dropEffect, CPoint point)
{
   ASSERT_VALID(this);

   // clean up focus rect
   OnDragLeave();

   // offset point as appropriate for dragging
   GetObjectInfo(pDataObject, &amp;m_dragSize, &amp;m_dragOffset);
   CClientDC dc(NULL);
   dc.HIMETRICtoDP(&amp;m_dragSize);
   dc.HIMETRICtoDP(&amp;m_dragOffset);
   point -= m_dragOffset;

   // invalidate current selection since it will be deselected
   OnUpdate(NULL, HINT_UPDATE_SELECTION, NULL);
   m_selection.RemoveAll();
   if (m_bDragDataAcceptable)
      PasteEmbedded( *pDataObject, point );

   // update the document and all views
   GetDocument()-&gt;SetModifiedFlag();
   GetDocument()-&gt;UpdateAllViews(NULL, 0, NULL); 

   return TRUE;
}
</CODE></PRE>

<P>This function determines the point at which the dropped object resides, deselects the currently selected object, and creates an OLE embedded object, using the <B>COleDataObject</B> object provided by the drop source. Note that the <CODE>CDrawView::PasteEmbedded</CODE> function now takes an additional parameter compared with the previous version of DRAWCLI; this parameter lets the caller specify the location of a new embedded object, something that is unnecessary for Paste operations but is useful for drag-and-drop operations.</P>

<P>It would also be possible to make DRAWCLI a drop source, allowing the user to drag a selection from one of DRAWCLI’s windows into another application’s. However, DRAWCLI doesn’t offer any common Clipboard formats, nor is DRAWCLI an OLE server, so there are no applications that could accept a dragged object originating from DRAWCLI. Consequently, the current version of DRAWCLI would not be a useful drop source.</P>

<P>For more information on MFC’s drag-and-drop support, see <A HREF="_core_drag_and_drop_.28.ole.29.htm">Drag and Drop (OLE)</A>. For more information about drag-and-drop in general, see <I>Inside OLE</I> or the OLE documentation on the MSDN Library CD.</P>
</font>
</BODY>
</HTML>
