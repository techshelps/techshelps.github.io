<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Export and Import Using AFX_EXT_CLASS</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>

<TABLE ALIGN=right WIDTH=0 BORDER=0><TR><TD>
<OBJECT ID="hhobj_1" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_vc_addpf_home">
</OBJECT>
<OBJECT ID="hhobj_2" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_sample_mfc_DLLHUSK">
</OBJECT>
</TD></TR></TABLE>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_core_export_and_import_using_afx_ext_class"></A>Export and Import Using AFX_EXT_CLASS</H1>

<P><A HREF="JavaScript:hhobj_1.Click()">Home</A>  |&nbsp; <A HREF="_core_dlls.3a_.overview.htm">Overview</A>  |&nbsp; <A HREF="_core_dll_tasks.htm">How Do I</A>  |&nbsp; <A HREF="_core_dlls.3a_.frequently_asked_questions.htm">FAQ</A>  |&nbsp; <A HREF="_core_dll_topics.htm">Details</A>  |&nbsp; <A HREF="_core_dll_sample_programs.htm">Sample</A></P>

<P><A HREF="_core_extension_dlls.3a_.overview.htm">Extension DLLs</A> use the macro <B>AFX_EXT_CLASS</B> to export classes; the executables that link to the extension DLL use the macro to import classes. With the <B>AFX_EXT_CLASS</B> macro, the same header file(s) used to build the extension DLL can be used with the executables that link to the DLL.</P>

<P>In the header file for your DLL, add the <B>AFX_EXT_CLASS</B> keyword to the declaration of your class as follows:</P>

<PRE><CODE>class AFX_EXT_CLASS CMyClass : public CDocument
{
// &lt;body of class&gt;
};
</CODE></PRE>

<P>This macro is defined by MFC as <B>__declspec(dllexport)</B> when the preprocessor symbols <B>_AFXDLL</B> and <B>_AFXEXT</B> are defined. But the macro is defined as <B>__declspec(dllimport)</B> when <B>_AFXDLL</B> is defined and <B>_AFXEXT</B> is not defined. When defined, the preprocessor symbol <B>_AFXDLL</B> indicates that the shared version of MFC is being used by the target executable (either a DLL or an application). When both <B>_AFXDLL</B> and <B>_AFXEXT</B> are defined, this indicates that the target executable is an extension DLL. </P>

<P>Because <B>AFX_EXT_CLASS</B> is defined as <B>__declspec(dllexport)</B> when exporting from an extension DLL, you can export entire classes without placing the decorated names for all of that class’s symbols in the .DEF file. This method is used by the MFC Advanced Concepts sample <A HREF="JavaScript:hhobj_2.Click()">DLLHUSK</A>.</P>

<P>Although you can avoid creating a .DEF file and all the decorated names for the class with this method, creating a .DEF file is more efficient because the names can be exported by ordinal. To use the .DEF file method of exporting, place the following code at the beginning and end of your header file:</P>

<PRE><CODE>#undef AFX_DATA
#define AFX_DATA AFX_EXT_DATA
// &lt;body of your header file&gt;
#undef AFX_DATA
#define AFX_DATA
</CODE></PRE>

<P><B>Caution</B>&nbsp;&nbsp;&nbsp;Be careful when exporting inline functions, because they can create the possibility of version conflicts. An inline function gets expanded into the application code; therefore, if you later rewrite the function, it does not get updated unless the application itself is recompiled. (Normally, DLL functions can be updated without rebuilding the applications that use them.)</P>

<H2>Exporting Individual Members in a Class</H2>

<P>Sometimes you may want to export individual members of your class. For example, if you are exporting a <B>CDialog</B>-derived class, you might only need to export the constructor and the <B>DoModal</B> call. You can use <B>AFX_EXT_CLASS</B> on the individual members you need to export.</P>

<P>For example:</P>

<PRE><CODE>   class CExampleDialog : public CDialog
   {
   public:
     AFX_EXT_CLASS CExampleDialog();
     AFX_EXT_CLASS int DoModal();
     ...
     // rest of class definition
     ...
   };
</CODE></PRE>

<P>Because you are no longer exporting all members of the class, you may run into an additional problem because of the way that MFC macros work. Several of MFC's helper macros actually declare or define data members. Therefore, these data members must also be exported from your DLL.</P>

<P>For example, the <B>DECLARE_DYNAMIC</B> macro is defined as follows when building an extension DLL:</P>

<PRE><CODE>   #define DECLARE_DYNAMIC(class_name) \
   protected: \
     static CRuntimeClass* PASCAL _GetBaseClass(); \
   public: \
     static AFX_DATA CRuntimeClass class##class_name; \
     virtual CRuntimeClass* GetRuntimeClass() const; \
</CODE></PRE>

<P>The line that begins with static <B>AFX_DATA</B> is declaring a static object inside of your class. To export this class correctly and access the run-time information from a client executable, you must export this static object. Because the static object is declared with the modifier <B>AFX_DATA</B>, you only need to define <B>AFX_DATA</B> to be <B>__declspec(dllexport)</B> when building your DLL and define it as <B>__declspec(dllimport)</B> when building your client executable. Because <B>AFX_EXT_CLASS</B> is already defined in this way, you just need to redefine <B>AFX_DATA</B> to be the same as <B>AFX_EXT_CLASS</B> around your class definition.</P>

<P>For example:</P>

<PRE><CODE>   #undef  AFX_DATA
   #define AFX_DATA AFX_EXT_CLASS

   class CExampleView : public CView
   {
      DECLARE_DYNAMIC()
      // ... class definition ...
   };

   #undef  AFX_DATA
   #define AFX_DATA
</CODE></PRE>

<P>MFC always uses the <B>AFX_DATA</B> symbol on data items it defines within its macros, so this technique will work for all such scenarios. For example it will work for <B>DECLARE_MESSAGE_MAP</B>.</P>

<P class=indent><B><B>Note</B></B>&nbsp;&nbsp;&nbsp;If you are exporting the entire class rather than selected members of the class, static data members are automatically exported. </P>

<H3>What do you want to do?</H3>

<UL type=disc>
	<LI><A HREF="_core_export_from_a_dll_using_..def_files.htm">Export from a DLL using .DEF files</A><BR><BR></LI>

	<LI><A HREF="_core_export_from_a_dll_using___declspec.28.dllexport.29.htm">Export from a DLL using __declspec(dllexport)</A><BR><BR></LI>

	<LI><A HREF="_core_export_c.2b2b_.functions_for_use_in_c.2d.language_executables.htm">Export C++ functions for use in C-language executables</A><BR><BR></LI>

	<LI><A HREF="_core_export_c_functions_for_use_in_c_or_c.2b2b_.language_executables.htm">Export C functions for use in C or C++-language executables</A><BR><BR></LI>

	<LI><A HREF="_core_determine_which_exporting_method_to_use.htm">Determine which exporting method to use</A><BR><BR></LI>

	<LI><A HREF="_core_import_into_an_application_using___declspec.28.dllimport.29.htm">Import into an application using __declspec(dllimport)</A><BR><BR></LI>

	<LI><A HREF="_core_prepare_the_mfc_dll_for_use.htm">Prepare the MFC DLL for use</A> by an application, or <A HREF="_core_prepare_the_win32_dll_for_use.htm">Prepare the Win32 DLL for use</A> by an application</LI>
</UL>

<H3>What do you want to know more about?</H3>

<UL type=disc>
	<LI><A HREF="_core_decorated_names.htm">Decorated names</A><BR><BR></LI>

	<LI><A HREF="_core_importing_and_exporting_inline_functions.htm">Importing and exporting inline functions</A><BR><BR></LI>

	<LI><A HREF="_core_mutual_imports.htm">Mutual imports</A></LI>
</UL>
</font>
</BODY>
</HTML>
