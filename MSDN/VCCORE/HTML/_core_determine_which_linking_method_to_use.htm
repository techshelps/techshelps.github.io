<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Determine Which Linking Method to Use</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>

<TABLE ALIGN=right WIDTH=0 BORDER=0><TR><TD>
<OBJECT ID="hhobj_1" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_vc_addpf_home">
</OBJECT>
<OBJECT ID="hhobj_2" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_win32_Using_Thread_Local_Storage_in_a_Dynamic_Link_Library">
</OBJECT>
</TD></TR></TABLE>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_core_determine_which_linking_method_to_use"></A>Determine Which Linking Method to Use</H1>

<P><A HREF="JavaScript:hhobj_1.Click()">Home</A>  |&nbsp; <A HREF="_core_dlls.3a_.overview.htm">Overview</A>  |&nbsp; <A HREF="_core_dll_tasks.htm">How Do I</A>  |&nbsp; <A HREF="_core_dlls.3a_.frequently_asked_questions.htm">FAQ</A>  |&nbsp; <A HREF="_core_dll_topics.htm">Details</A>  |&nbsp; <A HREF="_core_dll_sample_programs.htm">Sample</A></P>

<P>Most applications use implicit linking because it is the easiest linking method to use. However, there are times when explicit linking is necessary. Here are some common reasons to use explicit linking:

<UL type=disc>
	<LI>The application does not know the name of a DLL that it will have to load until run time. For example, the application might need to obtain the name of the DLL and the exported functions from a configuration file.<BR><BR></LI>

	<LI>A process using implicit linking is terminated by the operating system if the DLL is not found at process startup. A process using explicit linking is not terminated in this situation and can attempt to recover from the error. For example, the process could notify the user of the error and have the user specify another path to the DLL.<BR><BR></LI>

	<LI>A process using implicit linking is also terminated if any of the DLLs it is linked to have a <B>DllMain</B> function that fails. A process using explicit linking is not terminated in this situation.<BR><BR></LI>

	<LI>An application that implicitly links to many DLLs can be slow to start because Windows loads all the DLLs when the application loads. To improve startup performance, an application can implicitly link to those DLLs needed immediately after loading and wait to explicitly link to the other DLLs when they are needed.<BR><BR></LI>

	<LI>Explicit linking eliminates the need to link the application with an import library. If changes in the DLL cause the export ordinals to change, applications using explicit linking do not have to relink (assuming they are calling <B>GetProcAddress</B> with a name of a function and not with an ordinal value), whereas applications using implicit linking must relink to the new import library.</LI>
</UL>

<P>Here are two hazards of explicit linking to be aware of:

<UL type=disc>
	<LI>If the DLL has a <B>DllMain</B> entry point function, the operating system calls the function in the context of the thread that called <B>LoadLibrary</B>. The entry-point function is not called if the DLL is already attached to the process because of a previous call to <B>LoadLibrary</B> with no corresponding call to the <B>FreeLibrary</B> function. Explicit linking can cause problems if the DLL is using a <B>DllMain</B> function to perform initialization for each thread of a process because threads existing when <B>LoadLibrary</B> (or <B>AfxLoadLibrary</B>) is called will not be initialized. <BR><BR></LI>

	<LI>If a DLL declares static-extent data as <B>__declspec(thread)</B>, it can cause a protection fault if explicitly linked. After the DLL is loaded with <B>LoadLibrary</B>, it causes a protection fault whenever the code references this data. (Static-extent data includes both global and local static items.) Therefore, when you create a DLL, you should either avoid using thread-local storage, or inform DLL users about potential pitfalls (in case they attempt dynamic loading).</LI>
</UL>

<H3>What do you want to do?</H3>

<UL type=disc>
	<LI><A HREF="_core_link_implicitly.htm">Link implicitly</A><BR><BR></LI>

	<LI><A HREF="_core_link_explicitly.htm">Link explicitly</A></LI>
</UL>

<H3>What do you want to know more about?</H3>

<UL type=disc>
	<LI><A HREF="_core_using_implicit_linking.htm">Using implicit linking</A><BR><BR></LI>

	<LI><A HREF="_core_the_search_path_used_by_windows_to_locate_a_dll.htm">The search path used by Windows to locate a DLL</A><BR><BR></LI>

	<LI><A HREF="_core_loadlibrary_and_afxloadlibrary.htm">LoadLibrary and AfxLoadLibrary</A><BR><BR></LI>

	<LI><A HREF="_core_getprocaddress.htm">GetProcAddress</A><BR><BR></LI>

	<LI><A HREF="_core_freelibrary_and_afxfreelibrary.htm">FreeLibrary and AfxFreeLibrary</A><BR><BR></LI>

	<LI><A HREF="JavaScript:hhobj_2.Click()">Using thread local storage in a dynamic-link library (Win32 SDK documentation)</A></LI>
</UL>
</font>
</BODY>
</HTML>
