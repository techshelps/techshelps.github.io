<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Debug Routines</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_crt_debug_functions"></A><SUP></SUP>Debug Routines</H1>

<P>With this version, Visual C++ introduces debug support for the C run-time library. The new debug version of the library supplies many diagnostic services that make debugging programs easier and allow developers to:

<UL type=disc>
	<LI>Step directly into run-time functions during debugging<BR><BR></LI>

	<LI>Resolve assertions, errors, and exceptions<BR><BR></LI>

	<LI>Trace heap allocations and prevent memory leaks<BR><BR></LI>

	<LI>Report debug messages to the user</LI>
</UL>

<P>To use these routines, the <A HREF="_crt__debug.htm">_DEBUG</A> flag must be defined. All of these routines do nothing in a retail build of an application. For more information on how to use the new debug routines, see <A HREF="_core_using_c_run.2d.time_library_debugging_support.htm">Using C Run-Time Library Debugging Support</A>.</P>

<P class=label><B>Debug Versions of the C Run-time Library Routines</B></P>

<TABLE border=1 cellpadding=5 cols=2 frame=below rules=rows>

<TR VALIGN="top">
<TD class=label width=42%><B>Routine</B></TD>
<TD class=label width=58%><B>Use</B></TD>
</TR>

<TR VALIGN="top">
<TD width=42%><A HREF="_crt__assert.2c_._asserte_macros.htm">_ASSERT</A></TD>
<TD width=58%>Evaluate an expression and generates a debug report when the result is FALSE</TD>
</TR>

<TR VALIGN="top">
<TD width=42%><A HREF="_crt__assert.2c_._asserte_macros.htm">_ASSERTE</A></TD>
<TD width=58%>Similar to <B>_ASSERT</B>, but includes the failed expression in the generated report</TD>
</TR>

<TR VALIGN="top">
<TD width=42%><A HREF="_crt__crtcheckmemory.htm">_CrtCheckMemory</A></TD>
<TD width=58%>Confirm the integrity of the memory blocks allocated on the debug heap</TD>
</TR>

<TR VALIGN="top">
<TD width=42%><A HREF="_crt__crtdbgreport.htm">_CrtDbgReport</A></TD>
<TD width=58%>Generate a debug report with a user message and send the report to three possible destinations</TD>
</TR>

<TR VALIGN="top">
<TD width=42%><A HREF="_crt__crtdoforallclientobjects.htm">_CrtDoForAllClientObjects</A></TD>
<TD width=58%>Call an application-supplied function for all <B>_CLIENT_BLOCK</B> types on the heap</TD>
</TR>

<TR VALIGN="top">
<TD width=42%><A HREF="_crt__crtdumpmemoryleaks.htm">_CrtDumpMemoryLeaks</A></TD>
<TD width=58%>Dump all of the memory blocks on the debug heap when a significant memory leak has occurred</TD>
</TR>

<TR VALIGN="top">
<TD width=42%><A HREF="_crt__crtisvalidheappointer.htm">_CrtIsValidHeapPointer</A></TD>
<TD width=58%>Verify that a specified pointer is in the local heap</TD>
</TR>

<TR VALIGN="top">
<TD width=42%><A HREF="_crt__crtismemoryblock.htm">_CrtIsMemoryBlock</A></TD>
<TD width=58%>Verify that a specified memory block is located within the local heap and that it has a valid debug heap block type identifier</TD>
</TR>

<TR VALIGN="top">
<TD width=42%><A HREF="_crt__crtisvalidpointer.htm">_CrtIsValidPointer</A></TD>
<TD width=58%>Verify that a specified memory range is valid for reading and writing</TD>
</TR>

<TR VALIGN="top">
<TD width=42%><A HREF="_crt__crtmemcheckpoint.htm">_CrtMemCheckpoint</A></TD>
<TD width=58%>Obtain the current state of the debug heap and store it in an application-supplied <B>_CrtMemState</B> structure</TD>
</TR>

<TR VALIGN="top">
<TD width=42%><A HREF="_crt__crtmemdifference.htm">_CrtMemDifference</A></TD>
<TD width=58%>Compare two memory states for significant differences and return the results</TD>
</TR>

<TR VALIGN="top">
<TD width=42%><A HREF="_crt__crtmemdumpallobjectssince.htm">_CrtMemDumpAllObjectsSince</A></TD>
<TD width=58%>Dump information about objects on the heap since a specified checkpoint was taken or from the start of program execution</TD>
</TR>

<TR VALIGN="top">
<TD width=42%><A HREF="_crt__crtmemdumpstatistics.htm">_CrtMemDumpStatistics</A></TD>
<TD width=58%>Dump the debug header information for a specified memory state in a user-readable form</TD>
</TR>

<TR VALIGN="top">
<TD width=42%><A HREF="_crt__crtsetallochook.htm">_CrtSetAllocHook</A></TD>
<TD width=58%>Install a client-defined allocation function by hooking it into the C run-time debug memory allocation process</TD>
</TR>

<TR VALIGN="top">
<TD width=42%><A HREF="_crt__crtsetbreakalloc.htm">_CrtSetBreakAlloc</A></TD>
<TD width=58%>Set a breakpoint on a specified object allocation order number</TD>
</TR>

<TR VALIGN="top">
<TD width=42%><A HREF="_crt__crtsetdbgflag.htm">_CrtSetDbgFlag</A></TD>
<TD width=58%>Retrieve or modify the state of the <B>_crtDbgFlag</B> flag to control the allocation behavior of the debug heap manager</TD>
</TR>

<TR VALIGN="top">
<TD width=42%><A HREF="_crt__crtsetdumpclient.htm">_CrtSetDumpClient</A></TD>
<TD width=58%>Install an application-defined function that is called every time a debug dump function is called to dump <B>_CLIENT_BLOCK</B> type memory blocks</TD>
</TR>

<TR VALIGN="top">
<TD width=42%><A HREF="_crt__crtsetreportfile.htm">_CrtSetReportFile</A></TD>
<TD width=58%>Identify the file or stream to be used as a destination for a specific report type by <B>_CrtDbgReport</B></TD>
</TR>

<TR VALIGN="top">
<TD width=42%><A HREF="_crt__crtsetreporthook.htm">_CrtSetReportHook</A></TD>
<TD width=58%>Install a client-defined reporting function by hooking it into the C run-time debug reporting process</TD>
</TR>

<TR VALIGN="top">
<TD width=42%><A HREF="_crt__crtsetreportmode.htm">_CrtSetReportMode</A></TD>
<TD width=58%>Specify the general destination(s) for a specific report type generated by <B>_CrtDbgReport</B></TD>
</TR>

<TR VALIGN="top">
<TD width=42%><A HREF="_crt__rpt.2c_._rptf_macros.htm">_RPT[0,1,2,3,4]</A></TD>
<TD width=58%>Track the application’s progress by generating a debug report by calling <B>_CrtDbgReport</B> with a format string and a variable number of arguments. Provides no source file and line number information.</TD>
</TR>

<TR VALIGN="top">
<TD width=42%><A HREF="_crt__rpt.2c_._rptf_macros.htm">_RPTF[0,1,2,3,4]</A></TD>
<TD width=58%>Similar to the <B>_RPTn</B> macros, but provides the source file name and line number where the report request originated</TD>
</TR>

<TR VALIGN="top">
<TD width=42%><A HREF="_crt__calloc_dbg.htm">_calloc_dbg</A></TD>
<TD width=58%>Allocate a specified number of memory blocks on the heap with additional space for a debugging header and overwrite buffers</TD>
</TR>

<TR VALIGN="top">
<TD width=42%><A HREF="_crt__expand_dbg.htm">_expand_dbg</A></TD>
<TD width=58%>Resize a specified block of memory on the heap by expanding or contracting the block</TD>
</TR>

<TR VALIGN="top">
<TD width=42%><A HREF="_crt__free_dbg.htm">_free_dbg</A></TD>
<TD width=58%>Free a block of memory on the heap</TD>
</TR>

<TR VALIGN="top">
<TD width=42%><A HREF="_crt__malloc_dbg.htm">_malloc_dbg</A></TD>
<TD width=58%>Allocate a block of memory on the heap with additional space for a debugging header and overwrite buffers</TD>
</TR>

<TR VALIGN="top">
<TD width=42%><A HREF="_crt__msize_dbg.htm">_msize_dbg</A></TD>
<TD width=58%>Calculate the size of a block of memory on the heap</TD>
</TR>

<TR VALIGN="top">
<TD width=42%><A HREF="_crt__realloc_dbg.htm">_realloc_dbg</A></TD>
<TD width=58%>Reallocate a specified block of memory on the heap by moving and/or resizing the block</TD>
</TR>
</TABLE><BR>

<P>The debug routines can be used to step through the source code for most of the other C run-time routines during the debugging process. However, Microsoft considers some technology to be proprietary and, therefore, does not provide the source code for these routines. Most of these routines belong to either the exception handling or floating-point processing groups, but a few others are included as well. The following table lists these routines.</P>

<P class=label><B>C Run-time Routines that are Not Available in Source Code Form</B></P>

<TABLE border=1 cellpadding=5 cols=3 frame=below rules=rows>

<TR VALIGN="top">
<TD width=37%><A HREF="_crt_acos.htm">acos</A></TD>
<TD width=28%><A HREF="_crt__fpclass.htm">_fpclass</A></TD>
<TD width=35%><A HREF="_crt__nextafter.htm">_nextafter</A></TD>
</TR>

<TR VALIGN="top">
<TD width=37%><A HREF="_crt_asin.htm">asin</A></TD>
<TD width=28%><A HREF="_crt__fpieee_flt.htm">_fpieee_flt</A></TD>
<TD width=35%><A HREF="_crt_pow.htm">pow</A></TD>
</TR>

<TR VALIGN="top">
<TD width=37%><A HREF="_crt_atan.2c_.atan2.htm">atan, atan2</A></TD>
<TD width=28%><A HREF="_crt__fpreset.htm">_fpreset</A></TD>
<TD width=35%><A HREF="_crt_printf.2c_.wprintf.htm">printf, wprintf</A><SUP>1</SUP></TD>
</TR>

<TR VALIGN="top">
<TD width=37%><A HREF="_crt__cabs.htm">_cabs</A></TD>
<TD width=28%><A HREF="_crt_frexp.htm">frexp</A></TD>
<TD width=35%><A HREF="_crt__scalb.htm">_scalb</A></TD>
</TR>

<TR VALIGN="top">
<TD width=37%><A HREF="_crt_ceil.htm">ceil</A></TD>
<TD width=28%><A HREF="_crt__hypot.htm">_hypot</A></TD>
<TD width=35%><A HREF="_crt_scanf.2c_.wscanf.htm">scanf, wscanf</A><SUP>1</SUP></TD>
</TR>

<TR VALIGN="top">
<TD width=37%><A HREF="_crt__chgsign.htm">_chgsign</A></TD>
<TD width=28%><A HREF="_crt__isnan.htm">_isnan</A></TD>
<TD width=35%><A HREF="_crt_setjmp.htm">setjmp</A></TD>
</TR>

<TR VALIGN="top">
<TD width=37%><A HREF="_crt__clear87.2c_._clearfp.htm">_clear87, _clearfp</A></TD>
<TD width=28%><A HREF="_crt_bessel_functions__j0.2c_._j1.2c_._jn.htm">_j0</A></TD>
<TD width=35%><A HREF="_crt_sin.2c_.sinh.htm">sin</A></TD>
</TR>

<TR VALIGN="top">
<TD width=37%><A HREF="_crt__control87.2c_._controlfp.htm">_control87, _controlfp</A></TD>
<TD width=28%><A HREF="_crt_bessel_functions__j0.2c_._j1.2c_._jn.htm">_j1</A></TD>
<TD width=35%><A HREF="_crt_sin.2c_.sinh.htm">sinh</A></TD>
</TR>

<TR VALIGN="top">
<TD width=37%><A HREF="_crt__copysign.htm">_copysign</A></TD>
<TD width=28%><A HREF="_crt_bessel_functions__j0.2c_._j1.2c_._jn.htm">_jn</A></TD>
<TD width=35%><A HREF="_crt_sqrt.htm">sqrt</A></TD>
</TR>

<TR VALIGN="top">
<TD width=37%><A HREF="_crt_cos.2c_.cosh.htm">cos</A></TD>
<TD width=28%><A HREF="_crt_ldexp.htm">ldexp</A></TD>
<TD width=35%><A HREF="_crt__status87.2c_._statusfp.htm">_status87, _statusfp</A></TD>
</TR>

<TR VALIGN="top">
<TD width=37%><A HREF="_crt_cos.2c_.cosh.htm">cosh</A></TD>
<TD width=28%><A HREF="_crt_log.2c_.log10.htm">log</A></TD>
<TD width=35%><A HREF="_crt_tan.2c_.tanh.htm">tan</A></TD>
</TR>

<TR VALIGN="top">
<TD width=37%><A HREF="_crt_exp.htm">exp</A></TD>
<TD width=28%><A HREF="_crt_log.2c_.log10.htm">log10</A></TD>
<TD width=35%><A HREF="_crt_tan.2c_.tanh.htm">tanh</A></TD>
</TR>

<TR VALIGN="top">
<TD width=37%><A HREF="_crt_fabs.htm">fabs</A></TD>
<TD width=28%><A HREF="_crt__logb.htm">_logb</A></TD>
<TD width=35%><A HREF="_crt_bessel_functions__y0.2c_._y1.2c_._yn.htm">_y0</A></TD>
</TR>

<TR VALIGN="top">
<TD width=37%><A HREF="_crt__finite.htm">_finite</A></TD>
<TD width=28%><A HREF="_crt_longjmp.htm">longjmp</A></TD>
<TD width=35%><A HREF="_crt_bessel_functions__y0.2c_._y1.2c_._yn.htm">_y1</A></TD>
</TR>

<TR VALIGN="top">
<TD width=37%><A HREF="_crt_floor.htm">floor</A></TD>
<TD width=28%><A HREF="_crt__matherr.htm">_matherr</A></TD>
<TD width=35%><A HREF="_crt_bessel_functions__y0.2c_._y1.2c_._yn.htm">_yn</A></TD>
</TR>

<TR VALIGN="top">
<TD width=37%><A HREF="_crt_fmod.htm">fmod</A></TD>
<TD width=28%><A HREF="_crt_modf.htm">modf</A></TD>
<TD width=35%>&nbsp;</TD>
</TR>
</TABLE><BR>

<P class=mini><SUP>1&nbsp;&nbsp;&nbsp;</SUP>Although source code is available for most of this routine, it makes an internal call to another routine for which source code is not provided.</P>

<P>Some C run-time functions and C++ operators behave differently when called from a debug build of an application. (Note that a debug build of an application can be done by either defining the <B>_DEBUG</B> flag or by linking with a debug version of the C run-time library.) The behavioral differences usually consist of extra features or information provided by the routine to support the debugging process. The following table lists these routines.</P>

<P class=label><B>Routines that Behave Differently in a Debug Build of an Application</B></P>

<TABLE border=1 cellpadding=5 cols=2 frame=below rules=rows>

<TR VALIGN="top">
<TD width=49%>C <A HREF="_crt_abort.htm">abort</A> routine</TD>
<TD width=51%>C++ <A HREF="_langref_delete_operator.htm">delete</A> operator</TD>
</TR>

<TR VALIGN="top">
<TD width=49%>C <A HREF="_crt_assert.htm">assert</A> routine</TD>
<TD width=51%>C++ <A HREF="_langref_new_operator.htm">new</A> operator</TD>
</TR>
</TABLE><BR>

<P>For more information about using the debug versions of the C++ operators in the preceding table, see <A HREF="_core_using_the_debug_heap_from_c.2b2b.htm">Using the Debug Heap from C++</A>.</P>
</font>
</BODY>
</HTML>
