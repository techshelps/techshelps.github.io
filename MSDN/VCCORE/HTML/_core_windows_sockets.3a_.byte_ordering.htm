<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Windows Sockets: Byte Ordering</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>

<TABLE ALIGN=right WIDTH=0 BORDER=0><TR><TD>
<OBJECT ID="hhobj_1" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_vc_addpf_home">
</OBJECT>
<OBJECT ID="hhobj_2" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_MFC_CAsyncSocket">
</OBJECT>
<OBJECT ID="hhobj_3" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_MFC_CSocket">
</OBJECT>
<OBJECT ID="hhobj_4" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_MFC_CAsyncSocket">
</OBJECT>
<OBJECT ID="hhobj_5" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_MFC_CArchive">
</OBJECT>
<OBJECT ID="hhobj_6" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_MFC_CSocket">
</OBJECT>
</TD></TR></TABLE>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_core_windows_sockets.3a_.byte_ordering"></A>Windows Sockets: Byte Ordering</H1>

<P><A HREF="JavaScript:hhobj_1.Click()">Home</A>  |&nbsp; <A HREF="_core_windows_sockets_for_network_programming.3a_.overview.htm">Overview</A>  |&nbsp; <A HREF="_core_windows_sockets_tasks.htm">How Do I</A>  |&nbsp; <A HREF="_core_windows_sockets_sample_list.htm">Sample</A></P>

<P>This article and two companion articles explain several issues in Windows Sockets programming. This article covers byte ordering. The other issues are covered in the articles: <A HREF="_core_windows_sockets.3a_.blocking.htm">Windows Sockets: Blocking</A> and <A HREF="_core_windows_sockets.3a_.converting_strings.htm">Windows Sockets: Converting Strings</A>. </P>

<P>If you use or derive from class <A HREF="JavaScript:hhobj_2.Click()">CAsyncSocket</A>, you will need to manage these issues yourself. If you use or derive from class <A HREF="JavaScript:hhobj_3.Click()">CSocket</A>, MFC manages them for you. </P>

<H2>Byte Ordering</H2>

<P>Different machine architectures sometimes store data using different byte orders. For example, Intel-based machines store data in the reverse order of Macintosh (Motorola) machines. Intel’s byte order, called “little-Endian,” is also the reverse of the network standard “big-Endian” order. The following table explains these terms.</P>

<P class=label><B>Big- and Little-Endian Byte Ordering</B></P>

<TABLE border=1 cellpadding=5 cols=2 frame=below rules=rows>

<TR VALIGN="top">
<TD class=label width=24%><B>Byte ordering</B></TD>
<TD class=label width=76%><B>Meaning</B></TD>
</TR>

<TR VALIGN="top">
<TD width=24%>Big-Endian</TD>
<TD width=76%>The most significant byte is on the left end of a word.</TD>
</TR>

<TR VALIGN="top">
<TD width=24%>Little-Endian</TD>
<TD width=76%>The most significant byte is on the right end of a word.</TD>
</TR>
</TABLE><BR>

<P>Typically, you don’t have to worry about byte-order conversion for data that you send and receive over the network, but there are situations in which you must convert byte orders.</P>

<H3>When You Must Convert Byte Orders</H3>

<P>You need to convert byte orders in the following situations:

<UL type=disc>
	<LI>You’re passing information that needs to be interpreted by the network, as opposed to the data you’re sending to another machine. For example, you might pass ports and addresses, which the network must understand.<BR><BR></LI>

	<LI>The server application with which you’re communicating is not an MFC application (and you don’t have source code for it). This calls for byte order conversions if the two machines don’t share the same byte ordering.</LI>
</UL>

<H3>When You Don’t Have to Convert Byte Orders</H3>

<P>You can avoid the work of converting byte orders in the following situations:

<UL type=disc>
	<LI>The machines on both ends can agree not to swap bytes, and both machines use the same byte order. <BR><BR></LI>

	<LI>The server you’re communicating with is an MFC application.<BR><BR></LI>

	<LI>You have source code for the server you’re communicating with, so you can tell explicitly whether you must convert byte orders or not.<BR><BR></LI>

	<LI>You can port the server to MFC.
<P class=tl>This is fairly easy to do, and the result is usually smaller, faster code. For information, see the MFC Migration Kit, which is included with Visual C++.</P></LI>
</UL>

<P>Working with <A HREF="JavaScript:hhobj_4.Click()">CAsyncSocket</A>, you must manage any necessary byte-order conversions yourself. Windows Sockets standardizes the “big-Endian” byte-order model and provides functions to convert between this order and others. <A HREF="JavaScript:hhobj_5.Click()">CArchive</A>, however, which you use with <A HREF="JavaScript:hhobj_6.Click()">CSocket</A>, uses the opposite (“little-Endian”) order — but <B>CArchive</B> takes care of the details of byte-order conversions for you. By using this standard ordering in your applications, or using Windows Sockets byte-order conversion functions, you can make your code more portable. </P>

<P>The ideal case for using MFC sockets is when you’re writing both ends of the communication: using MFC at both ends. If you’re writing an application that will communicate with non-MFC applications, such as an FTP server, you’ll probably need to manage byte-swapping yourself before you pass data to the archive object, using the Windows Sockets conversion routines, <B>ntohs</B>, <B>ntohl</B>, <B>htons</B>, and <B>htonl</B>. An example of these functions used in communicating with a non-MFC application appears later in this article.</P>

<P class=indent><B><B>Note</B></B>&nbsp;&nbsp;&nbsp;When the other end of the communication is not an MFC application, you also must avoid streaming C++ objects derived from <B>CObject</B> into your archive because the receiver will not be able to handle them. See the Caution in the article <A HREF="_core_windows_sockets.3a_.using_sockets_with_archives.htm">Windows Sockets: Using Sockets with Archives</A>. </P>

<P>For more information about byte orders, see the Windows Sockets specification, available in the Win32 SDK.</P>

<H3>A Byte-Order Conversion Example</H3>

<P>The following example shows a serialization function for a <B>CSocket</B> object that uses an archive. It also illustrates using the byte-order conversion functions in the Windows Sockets API. </P>

<P>This example presents a scenario in which you are writing a client that communicates with a non-MFC server application for which you have no access to the source code. In this scenario, you must assume that the non-MFC server uses standard network byte order. In contrast, your MFC client application uses a <B>CArchive</B> object with a <B>CSocket</B> object, and <B>CArchive</B> uses “little-Endian” byte order, the opposite of the network standard. </P>

<P>Suppose the non-MFC server with which you plan to communicate has an established protocol for a message packet like the following:</P>

<PRE><CODE>struct Message
{
    long MagicNumber;
    unsigned short Command;
    short Param1;
    long Param2;
};
</CODE></PRE>

<P>In MFC terms, this would be expressed as follows:</P>

<PRE><CODE>struct Message
{
    long m_lMagicNumber;
    short m_nCommand;
    short m_nParam1;
    long m_lParam2;

    void Serialize( CArchive&amp; ar );
};
</CODE></PRE>

<P>In C++, a <B>struct</B> is essentially the same thing as a class. The <CODE>Message</CODE> structure can have member functions, such as the <CODE>Serialize</CODE> member function declared above. The <CODE>Serialize</CODE> member function might look like this:</P>

<PRE><CODE>void Message::Serialize(CArchive&amp; ar)
{
    if (ar.IsStoring())
    {
        ar &lt;&lt; (DWORD)htonl(m_lMagicNumber);
        ar &lt;&lt; (WORD)htons(m_nCommand);
        ar &lt;&lt; (WORD)htons(m_nParam1);
        ar &lt;&lt; (DWORD)htonl(m_lParam2);
    }
    else
    {
        WORD w;
        DWORD dw;
        ar &gt;&gt; dw;
        m_lMagicNumber = ntohl((long)dw);
        ar &gt;&gt; w ;
        m_nCommand = ntohs((short)w);
        ar &gt;&gt; w;
        m_nParam1 = ntohs((short)w);
        ar &gt;&gt; dw;
        m_lParam2 = ntohl((long)dw);
    }
}
</CODE></PRE>

<P>This example calls for byte-order conversions of data because there is a clear mismatch between the byte ordering of the non-MFC server application on one end and the <B>CArchive</B> used in your MFC client application on the other end. The example illustrates several of the byte-order conversion functions that Windows Sockets supplies. The following table describes these functions.</P>

<P class=label><B>Windows Sockets Byte-Order Conversion Functions</B></P>

<TABLE border=1 cellpadding=5 cols=2 frame=below rules=rows>

<TR VALIGN="top">
<TD class=label width=24%><B>Function</B></TD>
<TD class=label width=76%><B>Purpose</B></TD>
</TR>

<TR VALIGN="top">
<TD width=24%><B>ntohs</B></TD>
<TD width=76%>Convert a 16-bit quantity from network byte order to host byte order (Big-Endian to Little-Endian). </TD>
</TR>

<TR VALIGN="top">
<TD width=24%><B>ntohl</B></TD>
<TD width=76%>Convert a 32-bit quantity from network byte order to host byte order (Big-Endian to Little-Endian). </TD>
</TR>

<TR VALIGN="top">
<TD width=24%><B>htons</B></TD>
<TD width=76%>Convert a 16-bit quantity from host byte order to network byte order (Little-Endian to Big-Endian).</TD>
</TR>

<TR VALIGN="top">
<TD width=24%><B>htonl</B></TD>
<TD width=76%>Convert a 32-bit quantity from host byte order to network byte order (Little-Endian to Big-Endian).</TD>
</TR>
</TABLE><BR>

<P>Another point of this example is that when the socket application on the other end of the communication is a non-MFC application, you must avoid doing something like the following:</P>

<PRE><CODE>ar &lt;&lt; pMsg;
</CODE></PRE>

<P>where <CODE>pMsg</CODE> is a pointer to a C++ object derived from class <B>CObject</B>. This will send extra MFC information associated with objects and the server won’t understand it, as it would if it were an MFC application.</P>

<H3>What do you want to know more about?</H3>

<UL type=disc>
	<LI><A HREF="_core_windows_sockets.3a_.using_class_casyncsocket.htm">Windows Sockets: Using Class CAsyncSocket</A><BR><BR></LI>

	<LI><A HREF="_core_windows_sockets.3a_.background.htm">Windows Sockets: Background</A><BR><BR></LI>

	<LI><A HREF="_core_windows_sockets.3a_.stream_sockets.htm">Windows Sockets: Stream Sockets</A><BR><BR></LI>

	<LI><A HREF="_core_windows_sockets.3a_.datagram_sockets.htm">Windows Sockets: Datagram Sockets</A></LI>
</UL>
</font>
</BODY>
</HTML>
