<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Debugging Assertions</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>

<TABLE ALIGN=right WIDTH=0 BORDER=0><TR><TD>
<OBJECT ID="hhobj_1" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_mfc_ASSERT">
</OBJECT>
</TD></TR></TABLE>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_core_debugging_assertions"></A>Debugging Assertions</H1>

<P>An assertion statement specifies a condition at some particular point in your program. Visual C++ supports assertion statements based on the following constructs:

<UL type=disc>
	<LI>The C run-time library <A HREF="_crt__assert.2c_._asserte_macros.htm">_ASSERT, _ASSERTE Macros</A>. For more information, see <A HREF="_core_using_macros_for_verification_and_reporting.htm">Using Macros for Verification and Reporting</A>.<BR><BR></LI>

	<LI>The Microsoft Foundation Class (MFC) <A HREF="JavaScript:hhobj_1.Click()">ASSERT macro</A><BR><BR></LI>

	<LI>The ANSI C/C++ <A HREF="_crt_assert.htm">assert function</A></LI>
</UL>

<P>Programs that use the MFC library should use the MFC <B>ASSERT </B>macro. Programs that use the run-time library should use the runtime <B>_ASSERT </B>macro. Other programs should use the ANSI assert function. </P>

<P>Assertion statements compile only when <B>_DEBUG</B> is defined. When <B>_DEBUG</B> is not defined, the compiler treats assertions as null statements. Therefore, assertion statements have zero overhead in your final release program; you can use them liberally in your code without affecting the performance of your release version.</P>

<P class=indent><B><B>Note</B></B>&nbsp;&nbsp;&nbsp;The expression argument to <B>ASSERT</B> is not evaluated in the release version of your program. If you want the expression to be evaluated in both debug and release environments, use the <B>VERIFY</B> macro instead of <B>ASSERT</B>. In release environments, <B>VERIFY</B> evaluates the expression argument but does not check the result.</P>

<H2>Catching Errors with Assertion Statements</H2>

<P>Assertion statements are useful for catching logic errors. If you set an assertion on a condition that must be true according to the logic of your program, the assertion has no effect unless a logic error occurs. For example, suppose you are writing a simulation of gas molecules in a container, and the variable <CODE>numMols</CODE> represents the total number of molecules. Obviously, this number cannot be less than zero, so you might include an MFC assertion statement like this:</P>

<PRE><CODE>ASSERT(numMols &gt;= 0);
</CODE></PRE>

<P>This statement does nothing if your program is operating correctly. If a logic error has caused <CODE>numMols </CODE>to be less than zero, however, the statement halts the execution of your program and displays the <B>Assertion Failed</B> dialog box. This dialog box has three buttons, with the functions described in the following table.</P>

<TABLE border=1 cellpadding=5 cols=2 frame=below rules=rows>

<TR VALIGN="top">
<TD class=label width=50%><B>Click this button</B></TD>
<TD class=label width=50%><B>To do this</B></TD>
</TR>

<TR VALIGN="top">
<TD width=50%><B>Retry</B></TD>
<TD width=50%>Debug the assertion or get help on asserts.</TD>
</TR>

<TR VALIGN="top">
<TD width=50%><B>Ignore</B></TD>
<TD width=50%>Ignore the assertion and continue running the program.</TD>
</TR>

<TR VALIGN="top">
<TD width=50%><B>Abort</B></TD>
<TD width=50%>Halt execution of the program and end the debugging session.</TD>
</TR>
</TABLE><BR>

<P>When the debugger halts because of an MFC or C run-time library assertion, it navigates to the point in the source file where the assertion occurred, if the source is available. The <B>Debug</B> tab of the Output window displays the assertion message that appeared in the <B>Assertion Failed</B> dialog box. If you want to keep a copy of the message for future reference, you can copy it from the Output window to a text window using copy and paste or dragging it. The Output window may contain other error messages as well. Examine these carefully; some may provide clues to the cause of the assertion failure.</P>

<P>When you add assertions to your code, avoid writing assertions that have side effects. For example:</P>

<PRE><CODE>ASSERT(numMols++ &gt; 0); -- Don’t do this!
</CODE></PRE>

<P>This assertion statement changes the value of <CODE>numMols</CODE>. If you write assertion statements that have side effects like this, the debug and release versions of your code will produce different results, because the side effects occur only when <B>_DEBUG</B> is defined. Be careful using assertion statements on library or system calls, which may have side effects.</P>

<H2>Checking Results with Assertion Statements</H2>

<P>Use assertion statements when you need to check the result of an operation. Assertions are most valuable for testing operations whose results are not obvious from quick visual inspection. Consider, for example, the following code, which updates the variable <CODE>iMols</CODE> based on the contents of the linked list pointed to by <CODE>mols</CODE>:</P>

<PRE><CODE>while (mols-&gt;type &lt;&gt; “H2O”)
{
 iMols += mols-&gt;num;
 mols = mols-&gt;next;
}
ASSERT(iMols&lt;=numMols);
</CODE></PRE>

<P>The number of molecules counted by <CODE>iMols</CODE> must always be less than or equal to the total number of molecules, <CODE>numMols</CODE>. A visual inspection of this loop does not guarantee that this must be the case, so an assertion statement is used after the loop to test for that condition.</P>

<H2>Testing Error Conditions with Assertion Statements</H2>

<P>Another use of assertion statements is to test for error conditions. Assertion statements are not a substitute for error-handling code, however. The following example shows an assertion statement that can lead to problems in the final release code: </P>

<PRE><CODE>myErr = myGraphRoutine(a, b);
ASSERT(!myErr); -- Don’t do this!
</CODE></PRE>

<P>This code relies on the assertion statement to handle the error condition. As a result, any error code returned by <CODE>myGraphRoutine</CODE> will be unhandled in the final release code.</P>

<P>You can use assertion statements to check for error conditions at a point in your code where any errors should have been handled by preceding code. In the following example, a graphic routine returns zero if it succeeds and an error code if an error (such as running out of memory) occurs. You can use an MFC assertion statement as follows: </P>

<PRE><CODE>myErr = myGraphRoutine(a, b);
...
/* Code to handle errors and 
   reset myErr if successful */
...
ASSERT(!myErr);
</CODE></PRE>

<P>If the error-handling code works properly, any error that occurs is handled, and <CODE>myErr</CODE><B> </B>is restored to a value of zero, indicating no error, before the assertion statement is reached. The assertion succeeds, and control passes to the next statement. However, if <CODE>myErr</CODE><B> </B>has another value, the assertion fails, the program halts, and the <B>Assertion Failed</B> dialog box appears.</P>

<H2>Examining Assertion Failures</H2>

<P>When an assertion fails, you must examine your program to determine the cause of the failure. If the assertion statement and the cause of the failure occur close to one another, debugging can be relatively straightforward. Sometimes, however, an assertion failure may provide little or no clue as to where the cause is located. For example, suppose your code contained the following assertion statement: </P>

<PRE><CODE>ASSERT(ialloc %50 == 0);
</CODE></PRE>

<P>The program in this example allocates memory in blocks of 50 bytes. This assertion tests to see that memory is allocated in multiples of the proper size. If the assertion fails, you know that a memory leak exists in your program. Your next task, of course, is to find out where.</P>

<P>To isolate the location where the memory leak occurs, you might add copies of this assertion statement to other parts of your program where memory is allocated. Another alternative is to set a data breakpoint.</P>

<P class=label><B>To find the locations where a condition fails</B>

<OL>
	<LI>From the <B>Edit</B> menu, choose <B>Breakpoints</B>.
<P class=tl>The <B>Breakpoints</B> dialog box appears.</P></LI>

	<LI>Choose the <B>Data</B> tab.<BR><BR></LI>

	<LI>In the <B>Enter The Expression To Be Evaluated</B> text box, type the negation of the expression that caused the asertion failure.
<P class=tl>In general, for <CODE>ASSERT (</CODE><I>anyExpression</I><CODE>)</CODE>, you can specify a data breakpoint as <CODE>!(</CODE><I>anyExpression</I><CODE>)</CODE>.</P>
<P class=tl>For example, if your program failed on the assertion:</P>
<PRE><CODE>ASSERT(ialloc %50 == 0);
</CODE></PRE>

<P class=tl>In the <B>Breakpoints</B> dialog box, you would type:</P>
<PRE><CODE>!(ialloc %50 == 0)
</CODE></PRE>
</LI>

	<LI>Run your program again.
<P class=tl>Execution halts when the condition specified in the data breakpoint becomes true. This is the point where the condition in the assertion statement becomes false.</P></LI>
</OL>

<H2>Finding Assertion Failures with the Call Stack Window</H2>

<P>Another tool that is often useful for finding the cause of an assertion failure is the Call Stack window. Using the Call Stack window, you can examine previous functions and look for problems that may have caused the failure.</P>

<P class=label><B>To navigate from the Call Stack window to a function’s source or object code</B>

<OL>
	<LI>From the <B>View</B> menu, click <B>Debug Windows</B> and <B>Call Stack</B>.
<P class=tl>The <B>Call Stack</B> window opens.</P></LI>

	<LI>In the <B>Call Stack</B> window, double-click the function name.
<P class=tl>–&nbsp;or&nbsp;–</P>
<P class=tl>Select the function name, and press ENTER. </P></LI>
</OL>

<P>On rare occasions, you might want to look at the assertion-handling code rather than the code that caused the assertion to fail. You can use the Call Stack window for that purpose as well.</P>
</font>
</BODY>
</HTML>
