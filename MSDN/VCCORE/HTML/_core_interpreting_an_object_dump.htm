<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Interpreting an Object Dump</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_core_interpreting_an_object_dump"></A>Interpreting an Object Dump</H1>

<P>The preceding dump comes from the memory checkpoint example introduced in <A HREF="_core_detecting_a_memory_leak.htm">Detecting a Memory Leak</A> in the topic Detecting Memory Leaks. Remember that there were only two explicit allocations in that program — one on the frame and one on the heap:</P>

<PRE><CODE>// do your memory allocations and deallocations ...
CString s = "This is a frame variable";
// the next object is a heap object
CPerson* p = new CPerson( "Smith", "Alan", "581-0215" );
</CODE></PRE>

<P>Start with the <CODE>CPerson</CODE> object; its constructor takes three arguments that are pointers to <B>char</B>. The constructor uses these arguments to initialize <B>CString</B> member variables for the <CODE>CPerson</CODE> class. In the memory dump, you can see the <CODE>CPerson</CODE> object listed along with three nonobject blocks (3, 4, and 5) that hold the characters for the <B>CString</B> member variables. These memory blocks will be deleted when the destructor for the <CODE>CPerson</CODE> object is invoked. </P>

<P>Block number 2 represents the <CODE>CPerson</CODE> object itself. After the <CODE>CPerson</CODE> address listing, the contents of the object are displayed. This is a result of <B>DumpAllObjectsSince</B> calling the <CODE>Dump</CODE> member function for the <CODE>CPerson</CODE> object.</P>

<P>You can guess that block number 1 is associated with the <B>CString</B> frame variable because of its sequence number and its size, which match the number of characters in the frame <B>CString</B> variable. The allocations associated with frame variables are automatically deallocated when the frame variable goes out of scope. </P>

<P>In general, you shouldn’t worry about heap objects associated with frame variables because they are automatically deallocated when the frame variables go out of scope. In fact, to avoid clutter in your memory diagnostic dumps, you should position your calls to <B>Checkpoint</B> so that they are outside the scope of frame variables. For example, place scope brackets around the previous allocation code, as shown here:</P>

<PRE><CODE>oldMemState.Checkpoint();
{
    // do your memory allocations and deallocations ...
    CString s = "This is a frame variable";
    // the next object is a heap object
    CPerson* p = new CPerson( "Smith", "Alan", "581-0215" );
}
newMemState.Checkpoint();
</CODE></PRE>

<P>With the scope brackets in place, the memory dump for this example is as follows:</P>

<PRE><CODE>Dumping objects -&gt;

{5} strcore.cpp(80) : non-object block at $00A7521A, 9 bytes long
{4} strcore.cpp(80) : non-object block at $00A751F8, 5 bytes long
{3} strcore.cpp(80) : non-object block at $00A751D6, 6 bytes long
{2} a CPerson at $51A4

Last Name: Smith
First Name: Alan
Phone #: 581-0215
</CODE></PRE>

<P>Notice that some allocations are objects (such as <CODE>CPerson</CODE>) and some are nonobject allocations. “Nonobject allocations” are allocations for objects not derived from <B>CObject</B> or allocations of primitive C types such as <B>char</B>, <B>int</B>, or <B>long</B>. If the <B>CObject-</B>derived class allocates additional space, such as for internal buffers, those objects will show both object and nonobject allocations. </P>

<P>Notice that the memory block associated with the <B>CString</B> frame variable has been deallocated automatically and does not show up as a memory leak. The automatic deallocation associated with scoping rules takes care of most memory leaks associated with frame variables. </P>

<P>For objects allocated on the heap, however, you must explicitly delete the object to prevent a memory leak. To clean up the last memory leak in the previous example, you can delete the <CODE>CPerson</CODE> object allocated on the heap, as follows:</P>

<PRE><CODE>{
    // do your memory allocations and deallocations ...
    CString s = "This is a frame variable";
    // the next object is a heap object
    CPerson* p = new CPerson( "Smith", "Alan", "581-0215" );
    delete p;
} 
</CODE></PRE>

<P>For more information, see <A HREF="_core_detecting_a_memory_leak.htm">Detecting a Memory Leak</A> and <A HREF="_crt__crtmemdumpallobjectssince.htm">_CrtMemDumpAllObjectsSince</A>.</P>
</font>
</BODY>
</HTML>
