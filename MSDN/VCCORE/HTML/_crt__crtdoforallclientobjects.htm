<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>_CrtDoForAllClientObjects</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_crt__crtdoforallclientobjects"></A><SUP></SUP>_CrtDoForAllClientObjects</H1>

<P>Calls an application-supplied function for all <B>_CLIENT_BLOCK</B> types in the heap (debug version only).</P>

<P><B>void</B> <B>_CrtDoForAllClientObjects(</B> <B>void</B> <B>(*pfn)(void</B> <B>*,</B> <B>void</B> <B>*),</B> <B>void</B> *<I>context </I><B>);</B></P>

<TABLE border=1 cellpadding=5 cols=3 frame=below rules=rows>

<TR VALIGN="top">
<TD class=label width=40%><B>Routine</B></TD>
<TD class=label width=19%><B>Required Header</B></TD>
<TD class=label width=41%><B>Compatibility</B></TD>
</TR>

<TR VALIGN="top">
<TD width=40%><B>_CrtDoForAllClientObjects</B></TD>
<TD width=19%>&lt;crtdbg.h&gt;</TD>
<TD width=41%>Win NT, Win 95</TD>
</TR>
</TABLE><BR>

<P>For additional compatibility information, see <A HREF="_crt_compatibility.htm">Compatibility</A> in the Introduction.</P>

<P class=label><B>Libraries</B></P>

<TABLE border=1 cellpadding=5 cols=2 frame=below rules=rows>

<TR VALIGN="top">
<TD width=24%>LIBCD.LIB</TD>
<TD width=76%>Single thread static library, debug version</TD>
</TR>

<TR VALIGN="top">
<TD width=24%>LIBCMTD.LIB</TD>
<TD width=76%>Multithread static library, debug version</TD>
</TR>

<TR VALIGN="top">
<TD width=24%>MSVCRTD.LIB</TD>
<TD width=76%>Import library for MSVCRTD.DLL, debug version</TD>
</TR>
</TABLE><BR>

<P class=label><B>Return Value</B></P>

<P>None</P>

<P class=label><B>Parameters</B></P>

<P class=dt><I>void (*pfn)(void *, void *)</I></P>

<P class=indent>Pointer to the application-supplied function to call</P>

<P class=dt><I>context</I></P>

<P class=indent>Pointer to the application-supplied context to pass to the application-supplied function</P>

<P class=label><B>Remarks</B></P>

<P>The <B>_CrtDoForAllClientObjects</B> function searches the heap’s linked list for memory blocks with the <B>_CLIENT_BLOCK</B> type and calls the application-supplied function when a block of this type is found. The found block and the <I>context</I> parameter are passed as arguments to the application-supplied function. During debugging, an application can track a specific group of allocations by explicitly calling the debug heap functions to allocate the memory and specifying that the blocks be assigned the <B>_CLIENT_BLOCK</B> block type. These blocks can then be tracked separately and reported on differently during leak detection and memory state reporting.</P>

<P>If the <B>_CRTDBG_ALLOC_MEM_DF</B> bit field of the <A HREF="_crt__crtdbgflag.htm">_crtDbgFlag</A> flag is not turned on, <B>_CrtDoForAllClientObjects</B> immediately returns. When <A HREF="_crt__debug.htm">_DEBUG</A> is not defined, calls to <B>_CrtDoForAllClientObjects</B> are removed during preprocessing.</P>

<P>For more information about the <B>_CLIENT_BLOCK</B> type and how it can be used by other debug functions, see <A HREF="_core_types_of_blocks_on_the_debug_heap.htm">Types of Blocks on the Debug Heap</A>. For information about how memory blocks are allocated, initialized, and managed in the debug version of the base heap, see <A HREF="_core_memory_management_and_the_debug_heap.htm">Memory Management and the Debug Heap</A>.</P>

<P class=label><B>Example</B></P>

<PRE><CODE>/*
 * DFACOBJS.C
 * This program allocates some CLIENT type blocks of memory
 * and then calls _CrtDoForAllClientObjects to print out the contents
 * of each client block found on the heap.
 */

#include &lt;crtdbg.h&gt;
#include &lt;stdio.h&gt;
#include &lt;malloc.h&gt;
#include &lt;stdlib.h&gt;

/*
 * My Memory Block linked-list data structure
 */
typedef struct MyMemoryBlockStruct
{
   struct MyMemoryBlockStruct *NextPtr;
   int blockType;
   int allocNum;
} aMemoryBlock;
aMemoryBlock *HeadPtr;
aMemoryBlock *TailPtr;

/* 
 * CreateMemoryBlock
 * allocates a block of memory, fills in the data structure 
 * and adds the new block to the linked list
 * Returns 1 if successful, otherwise 0
 */
int CreateMemoryBlock(
   int allocNum,
   int blockType
   )
{
   aMemoryBlock *blockPtr;
   size_t size;

   size = sizeof( struct MyMemoryBlockStruct );
   if ( blockType == _CLIENT_BLOCK )
      blockPtr = (aMemoryBlock *) _malloc_dbg( size, _CLIENT_BLOCK, __FILE__, __LINE__ );
   else
      blockPtr = (aMemoryBlock *) _malloc_dbg( size, _NORMAL_BLOCK, __FILE__, __LINE__ );

   if ( blockPtr == NULL )
      return(0);

   blockPtr-&gt;allocNum = allocNum;
   blockPtr-&gt;blockType = blockType;

   blockPtr-&gt;NextPtr = NULL;
   if ( HeadPtr == NULL )
      HeadPtr = blockPtr;
   else
      TailPtr-&gt;NextPtr = blockPtr;
   TailPtr = blockPtr;
   return(1);
}

/*
 * RestoreMemoryToHeap
 * restores all of the memory that we allocated on the heap
 */
void RestoreMemoryToHeap( )
{
   aMemoryBlock *blockPtr;

   if (!HeadPtr)
      return;

   while ( HeadPtr-&gt;NextPtr != NULL )
   {
      blockPtr = HeadPtr-&gt;NextPtr;
      if  ( HeadPtr-&gt;blockType == _CLIENT_BLOCK )
         _free_dbg( HeadPtr, _CLIENT_BLOCK );
      else
         _free_dbg( HeadPtr, _NORMAL_BLOCK );

      HeadPtr = blockPtr;
   }
}

/*
 * MyClientObjectHook
 * A hook function for performing some action on all
 * client blocks found on the heap - In this case, print
 * out the value stored at each memory address.
 */                     
void __cdecl MyClientObjectHook(
   void * pUserData, 
   void * ignored
   )
{
   aMemoryBlock *blockPtr;
   long allocReqNum;
   int success;

   blockPtr = (aMemoryBlock *) pUserData;

   /*
    * Let's retrieve the actual object allocation order request number
    * and see if it's different from the allocation number we stored in
    * in our data structure.
    */
   success = _CrtIsMemoryBlock((const void *) blockPtr,
            (unsigned int) sizeof( struct MyMemoryBlockStruct ), &amp;allocReqNum,
            NULL, NULL );
   if ( success )
   printf( "Block #%d \t Type: %d \t Allocation Number: %d\n", blockPtr-&gt;allocNum,
           blockPtr-&gt;blockType, allocReqNum); 
   else
   {
          printf("ERROR: not a valid memory block.\n");        
          exit( 1 );
   }
}

void main( void )
{
   div_t div_result;
   int i, success, tmpFlag;

   /*
    * Set the _crtDbgFlag to turn debug type allocations.
    * This will enable us to specify that blocks of type
    * _CLIENT_BLOCK can be allocated and tracked separately.
    * Turn off checking for internal CRT blocks.
    */
   tmpFlag = _CrtSetDbgFlag( _CRTDBG_REPORT_FLAG );
   tmpFlag |= _CRTDBG_ALLOC_MEM_DF;
   tmpFlag &amp;= _CRTDBG_CHECK_CRT_DF;
   _CrtSetDbgFlag( tmpFlag );

   /*
    * We're going to allocate 22 blocks and every other block is
    * going to be of type _CLIENT_BLOCK.
    * Blocks numbered 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, and 22
    * should all be _CLIENT_BLOCKS.
    */
   HeadPtr = NULL;
   printf("Allocating the memory ");
   for (i=1; i &lt; 23; i++)
   {
          div_result = div( i, 2);
   if ( div_result.rem &gt; 0 )
      success = CreateMemoryBlock( i, _NORMAL_BLOCK );
   else
      success = CreateMemoryBlock( i, _CLIENT_BLOCK );
        
   if ( !success )
   {
         printf(" ERROR.\n");        
            exit( 1 );
      }
   else
      printf(".");
   }
   printf(" done.\n");
     
   /*
    * We're going to call _CrtDoForAllClientObjects to
    * make sure that only blocks numbered 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, and 22
    * got allocated as _CLIENT_BLOCKS.
    */
   _CrtDoForAllClientObjects( MyClientObjectHook, NULL );

   /*
    * Restore the memory to the heap
    */
   RestoreMemoryToHeap();
   exit( 0 );
}
</CODE></PRE>

<P class=label><B>Output</B></P>

<PRE><CODE>The instruction at "0x00401153" referenced memory at "0x00000004". The memory could not be "read".
</CODE></PRE>

<P><A HREF="_crt_debug_functions.htm">Debug Functions</A> </P>

<P><B>See Also</B>&nbsp;&nbsp;&nbsp;<A HREF="_crt__crtsetdbgflag.htm">_CrtSetDbgFlag</A>, <A HREF="_core_heap_state_reporting_functions.htm">Heap State Reporting Functions</A></P>
</font>
</BODY>
</HTML>
