<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CObject Class: Deriving a Class from CObject</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>

<TABLE ALIGN=right WIDTH=0 BORDER=0><TR><TD>
<OBJECT ID="hhobj_1" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_vc_addpf_home">
</OBJECT>
<OBJECT ID="hhobj_2" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_mfc_CObject">
</OBJECT>
</TD></TR></TABLE>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_core_cobject_class.3a_.deriving_a_class_from_cobject"></A>CObject Class: Deriving a Class from CObject</H1>

<P><A HREF="JavaScript:hhobj_1.Click()">Home</A>  |&nbsp; <A HREF="_core_cobject.2c_.the_root_base_class_in_mfc.3a_.overview.htm">Overview</A>  |&nbsp; <A HREF="_core_cobject_tasks.htm">How Do I</A>  |&nbsp; <A HREF="_core_class_cobject.3a_.frequently_asked_questions.htm">FAQ</A></P>

<P>This article describes the minimum steps necessary to derive a class from <A HREF="JavaScript:hhobj_2.Click()">CObject</A>. Other CObject class articles describe the steps needed to take advantage of specific <B>CObject</B> features, such as serialization and diagnostic debugging support.</P>

<P>In the discussions of <B>CObject</B>, the terms “interface file” and “implementation file” are used frequently. The interface file (often called the header file, or .H file) contains the class declaration and any other information needed to use the class. The implementation file (or .CPP file) contains the class definition as well as the code that implements the class member functions. For example, for a class named <CODE>CPerson</CODE>, you would typically create an interface file named PERSON.H and an implementation file named PERSON.CPP. However, for some small classes that will not be shared among applications, it is sometimes easier to combine the interface and implementation into a single .CPP file.</P>

<P>You can choose from four levels of functionality when deriving a class from <B>CObject</B>:

<UL type=disc>
	<LI>Basic functionality: No support for run-time class information or serialization but includes diagnostic memory management.<BR><BR></LI>

	<LI>Basic functionality plus support for run-time class information.<BR><BR></LI>

	<LI>Basic functionality plus support for run-time class information and dynamic creation.<BR><BR></LI>

	<LI>Basic functionality plus support for run-time class information, dynamic creation, and serialization.</LI>
</UL>

<P>Classes designed for reuse (those that will later serve as base classes) should at least include run-time class support and serialization support, if any future serialization need is anticipated.</P>

<P>You choose the level of functionality by using specific declaration and implementation macros in the declaration and implementation of the classes you derive from <B>CObject</B>. </P>

<P>The following table shows the relationship among the macros used to support serialization and run-time information.</P>

<P class=label><B><A NAME="_core_macros_used_for_serialization_and_run.2d.time_information"></A>Macros Used for Serialization and Run-Time Information</B></P>

<TABLE border=1 cellpadding=5 cols=4 frame=below rules=rows>

<TR VALIGN="top">
<TD class=label width=30%><B><BR>
Macro used</B></TD>
<TD class=label width=22%><B><BR>
CObject::IsKindOf</B></TD>
<TD class=label width=21%><B>CRuntimeClass::<BR>
CreateObject</B></TD>
<TD class=label width=27%><B>CArchive::operator&gt;&gt;<BR>
CArchive::operator&lt;&lt;</B></TD>
</TR>

<TR VALIGN="top">
<TD width=30%>Basic <B>CObject</B> functionality</TD>
<TD width=22%>No</TD>
<TD width=21%>No</TD>
<TD width=27%>No</TD>
</TR>

<TR VALIGN="top">
<TD width=30%><B>DECLARE_DYNAMIC</B></TD>
<TD width=22%>Yes</TD>
<TD width=21%>No</TD>
<TD width=27%>No</TD>
</TR>

<TR VALIGN="top">
<TD width=30%><B>DECLARE_DYNCREATE</B></TD>
<TD width=22%>Yes</TD>
<TD width=21%>Yes</TD>
<TD width=27%>No</TD>
</TR>

<TR VALIGN="top">
<TD width=30%><B>DECLARE_SERIAL</B></TD>
<TD width=22%>Yes</TD>
<TD width=21%>Yes</TD>
<TD width=27%>Yes</TD>
</TR>
</TABLE><BR>

<P class=label><B><A NAME="_core_to_use_basic_cobject_functionality"></A>To use basic CObject functionality</B>

<UL type=disc>
	<LI>Use the normal C++ syntax to derive your class from <B>CObject</B> (or from a class derived from <B>CObject</B>).
<P class=tl>The following example shows the simplest case, the derivation of a class from <B>CObject</B>:</P>
<PRE><CODE>class CPerson : public CObject 
{
    // add CPerson-specific members and functions... 
}
</CODE></PRE>
</LI>
</UL>

<P>Normally, however, you may want to override some of <B>CObject</B>’s member functions to handle the specifics of your new class. For example, you may usually want to override the <B>Dump</B> function of <B>CObject</B> to provide debugging output for the contents of your class. For details on how to override <B>Dump</B>, see the article <A HREF="_core_dumping_object_contents.htm">Diagnostics: Dumping Object Contents</A>. You may also want to override the <B>AssertValid</B> function of <B>CObject</B> to provide customized testing to validate the consistency of the data members of class objects. For a description of how to override <B>AssertValid</B>, see <A HREF="_core_overriding_the_assertvalid_function.htm">Overriding the AssertValid Function</A> in the article Diagnostics: Checking Object Validity. </P>

<P>The article <A HREF="_core_cobject_class.3a_.specifying_levels_of_functionality.htm">CObject Class: Specifying Levels of Functionality</A> describes how to specify other levels of functionality, including run-time class information, dynamic object creation, and serialization. </P>
</font>
</BODY>
</HTML>
