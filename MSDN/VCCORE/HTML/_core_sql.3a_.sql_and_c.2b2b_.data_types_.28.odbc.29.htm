<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SQL: SQL and C++ Data Types (ODBC)</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>

<TABLE ALIGN=right WIDTH=0 BORDER=0><TR><TD>
<OBJECT ID="hhobj_1" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_vc_addpf_home">
</OBJECT>
<OBJECT ID="hhobj_2" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="Enroll tutorial">
</OBJECT>
</TD></TR></TABLE>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_core_sql.3a_.sql_and_c.2b2b_.data_types_.28.odbc.29"></A>SQL: SQL and C++ Data Types (ODBC)</H1>

<P><A HREF="JavaScript:hhobj_1.Click()">Home</A>  |&nbsp; <A HREF="_core_databases.3a_.overview.htm">Overview</A>  |&nbsp; <A HREF="_core_odbc_database_tasks.htm">How Do I</A>  |&nbsp; <A HREF="_core_databases.3a_.frequently_asked_questions.htm">FAQ</A>  |&nbsp; <A HREF="_core_odbc_database_sample_list.htm">Sample</A>  |&nbsp; <A HREF="JavaScript:hhobj_2.Click()">Tutorial</A>  |&nbsp; <A HREF="_core_odbc_driver_list.htm">ODBC Driver List</A></P>

<P class=indent><B><B>Note&nbsp;&nbsp;&nbsp;</B></B>This information applies to the MFC ODBC classes. If you’re working with the MFC DAO classes, see the topic Comparison of Microsoft Jet Database Engine SQL and ANSI SQL in DAO Help.</P>

<P>The following table maps ANSI SQL data types to C++ data types. This augments the C language information given in Appendix D of the ODBC SDK <I>Programmer’s Reference</I> on the MSDN Library CD. ClassWizard manages most data-type mapping for you. If you don’t use ClassWizard, you can use the mapping information to help you write the field exchange code manually.</P>

<P class=label><B>ANSI SQL Data Types Mapped to C++ Data Types</B></P>

<TABLE border=1 cellpadding=5 cols=2 frame=below rules=rows>

<TR VALIGN="top">
<TD class=label width=44%><B>ANSI SQL data type</B></TD>
<TD class=label width=56%><B>C++ data type</B></TD>
</TR>

<TR VALIGN="top">
<TD width=44%><B>CHAR</B></TD>
<TD width=56%><B>CString</B></TD>
</TR>

<TR VALIGN="top">
<TD width=44%><B>DECIMAL</B></TD>
<TD width=56%><B>CString</B> <SUP>1</SUP></TD>
</TR>

<TR VALIGN="top">
<TD width=44%><B>SMALLINT</B></TD>
<TD width=56%><B>int</B></TD>
</TR>

<TR VALIGN="top">
<TD width=44%><B>REAL</B></TD>
<TD width=56%><B>float</B></TD>
</TR>

<TR VALIGN="top">
<TD width=44%><B>INTEGER</B></TD>
<TD width=56%><B>long</B></TD>
</TR>

<TR VALIGN="top">
<TD width=44%><B>FLOAT</B></TD>
<TD width=56%><B>double</B></TD>
</TR>

<TR VALIGN="top">
<TD width=44%><B>DOUBLE</B></TD>
<TD width=56%><B>double</B></TD>
</TR>

<TR VALIGN="top">
<TD width=44%><B>NUMERIC</B></TD>
<TD width=56%><B>CString</B> <SUP>1</SUP></TD>
</TR>

<TR VALIGN="top">
<TD width=44%><B>VARCHAR</B></TD>
<TD width=56%><B>CString</B></TD>
</TR>

<TR VALIGN="top">
<TD width=44%><B>LONGVARCHAR</B></TD>
<TD width=56%><B>CLongBinary</B>, <B>CString</B> <SUP>2</SUP></TD>
</TR>

<TR VALIGN="top">
<TD width=44%><B>BIT</B></TD>
<TD width=56%><B>BOOL</B></TD>
</TR>

<TR VALIGN="top">
<TD width=44%><B>TINYINT</B></TD>
<TD width=56%><B>BYTE</B></TD>
</TR>

<TR VALIGN="top">
<TD width=44%><B>BIGINT</B></TD>
<TD width=56%><B>CString</B> <SUP>1</SUP></TD>
</TR>

<TR VALIGN="top">
<TD width=44%><B>BINARY</B></TD>
<TD width=56%><B>CByteArray</B></TD>
</TR>

<TR VALIGN="top">
<TD width=44%><B>VARBINARY</B></TD>
<TD width=56%><B>CByteArray</B></TD>
</TR>

<TR VALIGN="top">
<TD width=44%><B>LONGVARBINARY</B></TD>
<TD width=56%><B>CLongBinary</B>, <B>CByteArray</B> <SUP>3</SUP></TD>
</TR>

<TR VALIGN="top">
<TD width=44%><B>DATE</B></TD>
<TD width=56%><B>CTime</B>, <B>CString</B></TD>
</TR>

<TR VALIGN="top">
<TD width=44%><B>TIME</B></TD>
<TD width=56%><B>CTime, CString</B></TD>
</TR>

<TR VALIGN="top">
<TD width=44%><B>TIMESTAMP</B></TD>
<TD width=56%><B>CTime, CString</B></TD>
</TR>
</TABLE><BR>

<P class=mini>1. ANSI <B>DECIMAL</B> and <B>NUMERIC</B> map to <B>CString</B> because <B>SQL_C_CHAR</B> is the default ODBC transfer type.</P>

<P class=mini>2. Character data beyond 255 characters is truncated by default when mapped to <B>CString</B>. You can extend the truncation length by explicitly setting the <I>nMaxLength</I> argument of <B>RFX_Text</B>.</P>

<P class=mini>3. Binary data beyond 255 characters is truncated by default when mapped to <B>CByteArray</B>. You can extend the truncation length by explicitly setting the <I>nMaxLength</I> argument of <B>RFX_Binary</B>.</P>

<P>If you are not using the ODBC cursor library, you may encounter a problem when attempting to update two or more long variable-length fields using the Microsoft SQL Server ODBC driver and the MFC ODBC database classes. The ODBC types, <B>SQL_LONGVARCHAR</B> and <B>SQL_LONGVARBINARY</B>, map to "text" and "image" SQL Server types. A <B>CDBException</B> will be thrown if you update two or more long variable-length fields on the same call to <B>CRecordset::Update</B>. Therefore, do not update multiple long columns simultaneously with <B>CRecordset::Update</B>. You can update multiple long columns simultaneously with the ODBC API <B>SQLPutData</B>. You can also use the ODBC cursor library, but this is not recommended for drivers, like the SQL Server driver, that support cursors and don’t need the cursor library.</P>

<P>If you are using the ODBC cursor library with the MFC ODBC database classes and the Microsoft SQL Server ODBC driver, an <B>ASSERT</B> may occur along with a <B>CDBException</B> if a call to <B>CRecordset::Update</B> follows a call to <B>CRecordset::Requery</B>. Instead, call <B>CRecordset::Close</B> and <B>CRecordset::Open</B> rather than <B>CRecordset::Requery</B>. Another solution is not to use the ODBC cursor library, since the SQL Server and the SQL Server ODBC driver provide native support for cursors natively and the ODBC cursor library isn’t needed.</P>

<P><B>See Also</B>&nbsp;&nbsp;&nbsp;<A HREF="_core_sql.3a_.making_direct_sql_calls_.28.odbc.29.htm">SQL: Making Direct SQL Calls (ODBC)</A> </P>
</font>
</BODY>
</HTML>
