<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>_CrtSetReportMode</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_crt__crtsetreportmode"></A><SUP></SUP>_CrtSetReportMode</H1>

<P>Specifies the general destination(s) for a specific report type generated by <B>_CrtDbgReport</B> (debug version only).</P>

<P><B>int</B> <B>_CrtSetReportMode(</B> <B>int</B> <I>reportType</I><B>,</B><I> </I><B>int</B> <I>reportMode</I> <B>);</B></P>

<TABLE border=1 cellpadding=5 cols=3 frame=below rules=rows>

<TR VALIGN="top">
<TD class=label width=30%><B>Routine</B></TD>
<TD class=label width=18%><B>Required Header</B></TD>
<TD class=label width=52%><B>Compatibility</B></TD>
</TR>

<TR VALIGN="top">
<TD width=30%><B>_CrtSetReportMode</B></TD>
<TD width=18%>&lt;crtdbg.h&gt;</TD>
<TD width=52%>Win NT, Win 95</TD>
</TR>
</TABLE><BR>

<P>For additional compatibility information, see <A HREF="_crt_compatibility.htm">Compatibility</A> in the Introduction.</P>

<P class=label><B>Libraries</B></P>

<TABLE border=1 cellpadding=5 cols=2 frame=below rules=rows>

<TR VALIGN="top">
<TD width=24%>LIBCD.LIB</TD>
<TD width=76%>Single thread static library, debug version</TD>
</TR>

<TR VALIGN="top">
<TD width=24%>LIBCMTD.LIB</TD>
<TD width=76%>Multithread static library, debug version</TD>
</TR>

<TR VALIGN="top">
<TD width=24%>MSVCRTD.LIB</TD>
<TD width=76%>Import library for MSVCRTD.DLL, debug version</TD>
</TR>
</TABLE><BR>

<P class=label><B>Return Value</B></P>

<P>Upon successful completion, <B>_CrtSetReportMode</B> returns the previous report mode(s) for the report type specified in <I>reportType</I>. If an error occurs, the report mode(s) for <I>reportType</I> are not modified and<B>_CrtSetReportMode</B> returns –1.</P>

<P class=label><B>Parameters</B></P>

<P class=dt><I>reportType</I></P>

<P class=indent>Report type: <B>_CRT_WARN</B>, <B>_CRT_ERROR</B>, <B>_CRT_ASSERT</B></P>

<P class=dt><I>reportMode</I></P>

<P class=indent>New report mode(s) for <I>reportType</I>, see the table in the Remarks section</P>

<P class=label><B>Remarks</B></P>

<P><B>_CrtSetReportMode</B> is used in conjunction with the <A HREF="_crt__crtsetreportfile.htm">_CrtSetReportFile</A> function to define the destination(s) for a specific report type generated by <A HREF="_crt__crtdbgreport.htm">_CrtDbgReport</A>. If <B>_CrtSetReportMode</B> and <B>_CrtSetReportFile</B> are not called to define the reporting method(s) for a specific report type, then <B>_CrtDbgReport</B> generates the report type using default destinations: Assertion failures and errors are directed to a debug message window, warnings from Windows applications are sent to the debugger, and warnings from console applications are directed to <B>stderr</B>. When <A HREF="_crt__debug.htm">_DEBUG</A> is not defined, calls to <B>_CrtSetReportMode</B> are removed during preprocessing.</P>

<P>The following table lists the report types defined in CRTDBG.H.</P>

<TABLE border=1 cellpadding=5 cols=2 frame=below rules=rows>

<TR VALIGN="top">
<TD class=label width=27%><B>Report Type</B></TD>
<TD class=label width=73%><B>Description</B></TD>
</TR>

<TR VALIGN="top">
<TD width=27%><B>_CRT_WARN</B></TD>
<TD width=73%>Warnings, messages, and information that does not need immediate attention.</TD>
</TR>

<TR VALIGN="top">
<TD width=27%><B>_CRT_ERROR</B></TD>
<TD width=73%>Errors, unrecoverable problems, and issues that require immediate attention.</TD>
</TR>

<TR VALIGN="top">
<TD width=27%><B>_CRT_ASSERT</B></TD>
<TD width=73%>Assertion failures (asserted expressions that evaluate to FALSE).</TD>
</TR>
</TABLE><BR>

<P>The <B>_CrtSetReportMode</B> function assigns the new report mode specified in <I>reportMode</I> to the report type specified in <I>reportType</I> and returns the previously defined report mode for <I>reportType</I>. The following table lists the available choices for <I>reportMode</I> and the resulting behavior of <B>_CrtDbgReport</B>. These options are defined as bit-flags in CRTDBG.H.</P>

<TABLE border=1 cellpadding=5 cols=2 frame=below rules=rows>

<TR VALIGN="top">
<TD class=label width=42%><B>Report Mode</B></TD>
<TD class=label width=58%><B>_CrtDbgReport Behavior</B></TD>
</TR>

<TR VALIGN="top">
<TD width=42%><B>_CRTDBG_MODE_DEBUG</B></TD>
<TD width=58%>Writes the message to an output debug string.</TD>
</TR>

<TR VALIGN="top">
<TD width=42%><B>_CRTDBG_MODE_FILE</B></TD>
<TD width=58%>Writes the message to a user-supplied file handle. <B>_CrtSetReportFile</B> should be called to define the specific file or stream to use as the destination.</TD>
</TR>

<TR VALIGN="top">
<TD width=42%><B>_CRTDBG_MODE_WNDW</B></TD>
<TD width=58%>Creates a message box to display the message along with the Abort, Retry, and Ignore buttons.</TD>
</TR>

<TR VALIGN="top">
<TD width=42%><B>_CRTDBG_REPORT_MODE</B></TD>
<TD width=58%>It is not called, and the report mode for <I>reportType</I> is not modified. <B>_CrtSetReportMode</B> simply returns the current report mode for <I>reportType</I>.</TD>
</TR>
</TABLE><BR>

<P>Each report type may be reported using one, two, or three modes, or no mode at all. Therefore, it is possible to have more than one destination defined for a single report type. For example, the following code fragment causes assertion failures to be sent to both a debug message window and to <B>stderr</B>:</P>

<PRE><CODE>_CrtSetReportMode( _CRT_ASSERT, _CRTDBG_MODE_FILE | _CRTDBG_MODE_WNDW );
_CrtSetReportFile( _CRT_ASSERT, _CRTDBG_FILE_STDERR );
</CODE></PRE>

<P>In addition, the reporting mode(s) for each report type can be separately controlled. For example, it is possible to specify that a <I>reportType</I> of <B>_CRT_WARN</B> be sent to an output debug string, while <B>_CRT_ASSERT</B> be displayed using a a debug message window and sent to <B>stderr</B>, as illustrated above.</P>

<P>For more information about defining the report mode(s) and file for a specific report type, see <B>_CrtDbgReport</B>, <B>_CrtSetReportFile</B> and the section <A HREF="_core_debug_reporting_functions_of_the_c_run.2d.time_library.htm">Debug Reporting Functions of the C Run-Time Library</A>.</P>

<P class=label><B>Example</B></P>

<PRE><CODE>/* 
 * REPORT.C:
 * In this program, calls are made to the _CrtSetReportMode,
 * _CrtSetReportFile, and _CrtSetReportHook functions.
 * The _ASSERT macros are called to evaluate their expression.
 * When the condition fails, these macros print a diagnostic message
 * and call _CrtDbgReport to generate a debug report and the
 * client-defined reporting function is called as well.
 * The _RPTn and _RPTFn group of macros are also exercised in
 * this program, as an alternative to the printf function.
 * When these macros are called, the client-defined reporting function
 * takes care of all the reporting - _CrtDbgReport won't be called.
 */

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;malloc.h&gt;
#include &lt;crtdbg.h&gt;

/* 
 * Define our own reporting function.
 * We'll hook it into the debug reporting
 * process later using _CrtSetReportHook.
 *
 * Define a global int to keep track of
 * how many assertion failures occur.
 */
int gl_num_asserts=0;
int OurReportingFunction( int reportType, char *userMessage, int *retVal )
{
   /*
    * Tell the user our reporting function is being called.
    * In other words - verify that the hook routine worked.
    */
   fprintf("Inside the client-defined reporting function.\n", STDOUT);
   fflush(STDOUT);

   /*
    * When the report type is for an ASSERT,
    * we'll report some information, but we also
    * want _CrtDbgReport to get called - 
    * so we'll return TRUE.
    *
    * When the report type is a WARNing or ERROR,
    * we'll take care of all of the reporting. We don't
    * want _CrtDbgReport to get called - 
    * so we'll return FALSE.
    */
   if (reportType == _CRT_ASSERT)
   {
      gl_num_asserts++;
      fprintf("This is the number of Assertion failures that have occurred: %d \n", gl_num_asserts, STDOUT);
      fflush(STDOUT);
      fprintf("Returning TRUE from the client-defined reporting function.\n", STDOUT);
      fflush(STDOUT);
      return(TRUE);
   } else {
      fprintf("This is the debug user message: %s \n", userMessage, STDOUT);
      fflush(STDOUT);
      fprintf("Returning FALSE from the client-defined reporting function.\n", STDOUT);
      fflush(STDOUT);
      return(FALSE);
   }

   /*
    * By setting retVal to zero, we are instructing _CrtDbgReport
    * to continue with normal execution after generating the report.
    * If we wanted _CrtDbgReport to start the debugger, we would set
    * retVal to one.
    */
   retVal = 0;
}

int main()
{
      char *p1, *p2;

   /* 
    * Hook in our client-defined reporting function.
    * Every time a _CrtDbgReport is called to generate
    * a debug report, our function will get called first.
    */
   _CrtSetReportHook( OurReportingFunction );

   /* 
    * Define the report destination(s) for each type of report
    * we are going to generate.  In this case, we are going to
    * generate a report for every report type: _CRT_WARN,
    * _CRT_ERROR, and _CRT_ASSERT.
    * The destination(s) is defined by specifying the report mode(s)
    * and report file for each report type.
    * This program sends all report types to STDOUT.
    */                                             
   _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE);
   _CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDOUT);
   _CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_FILE);
   _CrtSetReportFile(_CRT_ERROR, _CRTDBG_FILE_STDOUT);
   _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_FILE);
   _CrtSetReportFile(_CRT_ASSERT, _CRTDBG_FILE_STDOUT);

   /*
    * Allocate and assign the pointer variables
    */
   p1 = malloc(10);
   strcpy(p1, "I am p1");
   p2 = malloc(10);
   strcpy(p2, "I am p2");

   /*
    * Use the report macros as a debugging
    * warning mechanism, similar to printf.
    *
    * Use the assert macros to check if the
    * p1 and p2 variables are equivalent.
    *
    * If the expression fails, _ASSERTE will
    * include a string representation of the
    * failed expression in the report.
    *
    *  _ASSERT does not include the
    * expression in the generated report.
    */
   _RPT0(_CRT_WARN, "\n\n Use the assert macros to evaluate the expression p1 == p2.\n");
   _RPTF2(_CRT_WARN, "\n Will _ASSERT find '%s' == '%s' ?\n", p1, p2);
   _ASSERT(p1 == p2);

   _RPTF2(_CRT_WARN, "\n\n Will _ASSERTE find '%s' == '%s' ?\n", p1, p2);
   _ASSERTE(p1 == p2);

   _RPT2(_CRT_ERROR, "\n \n '%s' != '%s'\n", p1, p2);
   
   free(p2);
   free(p1);

   return 0;
}
</CODE></PRE>

<P class=label><B>Output</B></P>

<PRE><CODE>Inside the client-defined reporting function.
This is the debug user message: Use the assert macros to evaluate the expression p1 == p2
Returning FALSE from the client-defined reporting function.
Inside the client-defined reporting function.
This is the debug user message: dbgmacro.c(54) : Will _ASSERT find 'I am p1' == 'I am p2' ?
Returning FALSE from the client-defined reporting function.
Inside the client-defined reporting function.
This is the number of Assertion failures that have occurred: 1
Returning TRUE from the client-defined reporting function.
dbgmacro.c(55) : Assertion failed
Inside the client-defined reporting function.
This is the debug user message: dbgmacro.c(57) : Will _ASSERTE find 'I am p1' == 'I am p2' ?
Returning FALSE from the client-defined reporting function.
Inside the client-defined reporting function.
This is the number of Assertion failures that have occurred: 2
Returning TRUE from the client-defined reporting function.
dbgmacro.c(58) : Assertion failed: p1 == p2
Inside the client-defined reporting function.
This is the debug user message: 'I am p1' != 'I am p2'
Returning FALSE from the client-defined reporting function.

</CODE></PRE>

<P><A HREF="_crt_debug_functions.htm">Debug Functions</A></P>
</font>
</BODY>
</HTML>
