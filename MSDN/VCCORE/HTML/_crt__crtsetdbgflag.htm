<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>_CrtSetDbgFlag</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_crt__crtsetdbgflag"></A><SUP></SUP>_CrtSetDbgFlag</H1>

<P>Retrieves and/or modifies the state of the <B>_crtDbgFlag</B> flag to control the allocation behavior of the debug heap manager (debug version only).</P>

<P><B>int</B> <B>_CrtSetDbgFlag(</B> <B>int</B> <I>newFlag </I><B>);</B></P>

<TABLE border=1 cellpadding=5 cols=3 frame=below rules=rows>

<TR VALIGN="top">
<TD class=label width=24%><B>Routine</B></TD>
<TD class=label width=27%><B>Required Header</B></TD>
<TD class=label width=49%><B>Compatibility</B></TD>
</TR>

<TR VALIGN="top">
<TD width=24%><B>_CrtSetDbgFlag</B></TD>
<TD width=27%>&lt;crtdbg.h&gt;</TD>
<TD width=49%>Win NT, Win 95</TD>
</TR>
</TABLE><BR>

<P>For additional compatibility information, see <A HREF="_crt_compatibility.htm">Compatibility</A> in the Introduction.</P>

<P class=label><B>Libraries</B></P>

<TABLE border=1 cellpadding=5 cols=2 frame=below rules=rows>

<TR VALIGN="top">
<TD width=24%>LIBCD.LIB</TD>
<TD width=76%>Single thread static library, debug version</TD>
</TR>

<TR VALIGN="top">
<TD width=24%>LIBCMTD.LIB</TD>
<TD width=76%>Multithread static library, debug version</TD>
</TR>

<TR VALIGN="top">
<TD width=24%>MSVCRTD.LIB</TD>
<TD width=76%>Import library for MSVCRTD.DLL, debug version</TD>
</TR>
</TABLE><BR>

<P><B>_CrtSetDbgFlag</B> returns the previous state of <B>_crtDbgFlag</B>.</P>

<P class=label><B>Parameter</B></P>

<P class=dt><I>newFlag</I></P>

<P class=indent>New state for the <B>_crtDbgFlag</B></P>

<P class=label><B>Remarks</B></P>

<P>The <B>_CrtSetDbgFlag</B> function allows the application to control how the debug heap manager tracks memory allocations by modifying the bit fields of the <B>_crtDbgFlag</B> flag. By setting the bits (turning on), the application can instruct the debug heap manager to perform special debugging operations, including checking for memory leaks when the application exits and reporting if any are found, simulating low memory conditions by specifying that freed memory blocks should remain in the heap’s linked list, and verifying the integrity of the heap by inspecting each memory block at every allocation request. When <A HREF="_crt__debug.htm">_DEBUG</A> is not defined, calls to <B>_CrtSetDbgFlag</B> are removed during preprocessing.</P>

<P>The following table lists the bit fields for <B>_crtDbgFlag</B> and describes their behavior. Because setting the bits results in increased diagnostic output and reduced program execution speed, most of the bits are not set (turned off) by default. For more information about these bit fields, see <A HREF="_core_using_the_debug_heap.htm">Using the Debug Heap</A>.</P>

<TABLE border=1 cellpadding=5 cols=3 frame=below rules=rows>

<TR VALIGN="top">
<TD class=label width=30%><B>Bit field</B></TD>
<TD class=label width=12%><B>Default</B></TD>
<TD class=label width=58%><B>Description</B></TD>
</TR>

<TR VALIGN="top">
<TD width=30%><B>_CRTDBG_ALLOC-<BR>
_MEM_DF</B></TD>
<TD width=12%>ON</TD>
<TD width=58%>ON: Enable debug heap allocations and use of memory block type identifiers, such as <B>_CLIENT_BLOCK</B>.<BR>
OFF: Add new allocations to heap’s linked list, but set block type to <B>_IGNORE_BLOCK</B>.</TD>
</TR>

<TR VALIGN="top">
<TD width=30%><B>_CRTDBG_CHECK-<BR>
_ALWAYS_DF</B></TD>
<TD width=12%>OFF</TD>
<TD width=58%>ON: Call <A HREF="_crt__crtcheckmemory.htm">_CrtCheckMemory</A> at every allocation and deallocation request.<BR>
OFF: <B>_CrtCheckMemory</B> must be called explicitly.</TD>
</TR>

<TR VALIGN="top">
<TD width=30%><B>_CRTDBG_CHECK-<BR>
_CRT_DF</B></TD>
<TD width=12%>OFF</TD>
<TD width=58%>ON: Include <B>_CRT_BLOCK</B> types in leak detection and memory state difference operations.<BR>
OFF: Memory used internally by the run-time library is ignored by these operations.</TD>
</TR>

<TR VALIGN="top">
<TD width=30%><B>_CRTDBG_DELAY-<BR>
_FREE_MEM_DF</B></TD>
<TD width=12%>OFF</TD>
<TD width=58%>ON: Keep freed memory blocks in the heap’s linked list, assign them the <B>_FREE_BLOCK</B> type, and fill them with the byte value 0xDD.<BR>
OFF: Do not keep freed blocks in the heap’s linked list.</TD>
</TR>

<TR VALIGN="top">
<TD width=30%><B>_CRTDBG_LEAK-<BR>
_CHECK_DF</B></TD>
<TD width=12%>OFF</TD>
<TD width=58%>ON: Perform automatic leak checking at program exit via a call to <A HREF="_crt__crtdumpmemoryleaks.htm">_CrtDumpMemoryLeaks</A> and generate an error report if the application failed to free all the memory it allocated.<BR>
OFF: Do not automatically perform leak checking at program exit.</TD>
</TR>
</TABLE><BR>

<P><I>newFlag</I> is the new state to apply to the <B>_crtDbgFlag</B> and is a combination of the values for each of the bit fields. To change one or more of these bit fields and create a new state for the flag, follow these steps:

<OL>
	<LI>Call <B>_CrtSetDbgFlag</B> with <I>newFlag</I> equal to <B>_CRTDBG_REPORT_FLAG</B> to obtain the current <B>_crtDbgFlag</B> state and store the returned value in a temporary variable.<BR><BR></LI>

	<LI>Turn on any bits by OR-ing the temporary variable with the corresponding bitmasks (represented in the application code by manifest constants).<BR><BR></LI>

	<LI>Turn off the other bits by AND-ing the variable with a bitwise NOT of the appropriate bitmasks.<BR><BR></LI>

	<LI>Call <B>_CrtSetDbgFlag</B> with <I>newFlag</I> equal to the value stored in the temporary variable to set the new state for <B>_crtDbgFlag</B>.</LI>
</OL>

<P>The following lines of code demonstrate how to simulate low memory conditions by keeping freed memory blocks in the heap’s linked list and prevent <B>_CrtCheckMemory</B> from being called at every allocation request:</P>

<PRE><CODE>// Get the current state of the flag
// and store it in a temporary variable
int tmpFlag = _CrtSetDbgFlag( _CRTDBG_REPORT_FLAG );

// Turn On (OR) - Keep freed memory blocks in the
// heap’s linked list and mark them as freed
tmpFlag |= _CRTDBG_DELAY_FREE_MEM_DF;

// Turn Off (AND) - prevent _CrtCheckMemory from
// being called at every allocation request
tmpFlag &amp;= ~_CRTDBG_CHECK_ALWAYS_DF;

// Set the new state for the flag
_CrtSetDbgFlag( tmpFlag );
</CODE></PRE>

<P>For an overview of memory management and the debug heap, see <A HREF="_core_memory_management_and_the_debug_heap.htm">Memory Management and the Debug Heap</A>.</P>

<P>To disable a flag with the <B>_CrtSetDbgFlag</B> function, you should AND the variable with the bitwise NOT of the bitmask.</P>

<P class=label><B>Example</B></P>

<PRE><CODE>/*
 * SETDFLAG.C
 * This program concentrates on allocating and freeing memory
 * blocks to test the functionality of the _crtDbgFlag flag..
 */

#include &lt;string.h&gt;
#include &lt;malloc.h&gt;
#include &lt;crtdbg.h&gt;

void main( )
{
        char *p1, *p2;
        int tmpDbgFlag;

        /*
         * Set the debug-heap flag to keep freed blocks in the
         * heap's linked list - This will allow us to catch any
         * inadvertent use of freed memory
         */
        tmpDbgFlag = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);
        tmpDbgFlag |= _CRTDBG_DELAY_FREE_MEM_DF;
        tmpDbgFlag |= _CRTDBG_LEAK_CHECK_DF;
        _CrtSetDbgFlag(tmpDbgFlag);

        /*
         * Allocate 2 memory blocks and store a string in each
         */
        p1 = malloc( 34 );
        p2 = malloc( 38 );
        strcpy( p1, "p1 points to a Normal allocation block" );
        strcpy( p2, "p2 points to a Client allocation block" );

        /*
         * Free both memory blocks
         */
        free( p2 );
        free( p1 );

        /*
         * Set the debug-heap flag to no longer keep freed blocks in the
         * heap's linked list and turn on Debug type allocations (CLIENT)
         */
        tmpDbgFlag = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);
        tmpDbgFlag |= _CRTDBG_ALLOC_MEM_DF;
        tmpDbgFlag &amp;= ~_CRTDBG_DELAY_FREE_MEM_DF;
        _CrtSetDbgFlag(tmpDbgFlag);

        /*
         * Explicitly call _malloc_dbg to obtain the filename and line number
         * of our allocation request and also so we can allocate CLIENT type
         * blocks specifically for tracking
         */
        p1 = _malloc_dbg( 40, _NORMAL_BLOCK, __FILE__, __LINE__ );
        p2 = _malloc_dbg( 40, _CLIENT_BLOCK, __FILE__, __LINE__ );
        strcpy( p1, "p1 points to a Normal allocation block" );
        strcpy( p2, "p2 points to a Client allocation block" );

        /*
         * _free_dbg must be called to free the CLIENT block
         */
        _free_dbg( p2, _CLIENT_BLOCK );
        free( p1 );

        /*
         * Allocate p1 again and then exit - this will leave unfreed
         * memory on the heap
         */
        p1 = malloc( 10 );
}
</CODE></PRE>

<P class=label><B>Output</B></P>

<PRE><CODE>Debug Error!
Program: C:\code\setdflag.exe
DAMAGE: after Normal block (#31) at 0x002D06A8.
Press Retry to debug the application.

</CODE></PRE>

<P><A HREF="_crt_debug_functions.htm">Debug Functions</A>  </P>

<P><B>See Also</B>&nbsp;&nbsp;&nbsp;<A HREF="_crt__crtdbgflag.htm">_crtDbgFlag</A>, <A HREF="_crt__crtcheckmemory.htm">_CrtCheckMemory</A>, <A HREF="_core_heap_state_reporting_functions.htm">Heap State Reporting Functions</A></P>
</font>
</BODY>
</HTML>
