<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Choosing Between Functions and Macros</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_crt_choosing_between_functions_and_macros"></A><SUP></SUP>Choosing Between Functions and Macros</H1>

<P>Most Microsoft run-time library routines are compiled or assembled functions, but some routines are implemented as macros. When a header file declares both a function and a macro version of a routine, the macro definition takes precedence, because it always appears after the function declaration. When you invoke a routine that is implemented as both a function and a macro, you can force the compiler to use the function version in two ways:

<UL type=disc>
	<LI>Enclose the routine name in parentheses.
<PRE><CODE>#include &lt;ctype.h&gt;
a = toupper(a);    //use macro version of toupper
a = (toupper)(a);  //force compiler to use function version of toupper
</CODE></PRE>
</LI>

	<LI>“Undefine” the macro definition with the <B>#undef</B> directive:
<PRE><CODE>#include &lt;ctype.h&gt;
#undef toupper
</CODE></PRE>
</LI>
</UL>

<P>If you need to choose between a function and a macro implementation of a library routine, consider the following trade-offs:

<UL type=disc>
	<LI>Speed versus size. The main benefit of using macros is faster execution time. During preprocessing, a macro is expanded (replaced by its definition) inline each time it is used. A function definition occurs only once regardless of how many times it is called. Macros may increase code size but do not have the overhead associated with function calls.<BR><BR></LI>

	<LI>Function evaluation. A function evaluates to an address; a macro does not. Thus you cannot use a macro name in contexts requiring a pointer. For instance, you can declare a pointer to a function, but not a pointer to a macro.<BR><BR></LI>

	<LI>Macro side effects. A macro may treat arguments incorrectly when the macro evaluates its arguments more than once. For instance, the <B>toupper</B> macro is defined as:
<PRE><CODE>#define toupper(c) ( (islower(c)) ? _toupper(c) :  (c) )
</CODE></PRE>

<P class=tl>In the following example, the <B>toupper</B> macro produces a side effect:</P>
<PRE><CODE>#include &lt;ctype.h&gt;

int a = 'm';
a = toupper(a++);
</CODE></PRE>

<P class=tl>The example code increments <CODE>a</CODE> when passing it to <B>toupper</B>. The macro evaluates the argument <CODE>a++</CODE> twice, once to check case and again for the result, therefore increasing <CODE>a</CODE> by 2 instead of 1. As a result, the value operated on by <B>islower</B> differs from the value operated on by <B>toupper</B>.</P></LI>

	<LI>Type-checking. When you declare a function, the compiler can check the argument types. Because you cannot declare a macro, the compiler cannot check macro argument types, although it can check the number of arguments you pass to a macro.</LI>
</UL>
</font>
</BODY>
</HTML>
