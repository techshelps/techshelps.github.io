<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using Extension DLL,Database/OLE/Sockets in Regular DLL</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>

<TABLE ALIGN=right WIDTH=0 BORDER=0><TR><TD>
<OBJECT ID="hhobj_1" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_vc_addpf_home">
</OBJECT>
<OBJECT ID="hhobj_2" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_MFCNOTES_TN011">
</OBJECT>
<OBJECT ID="hhobj_3" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_MFCNOTES_TN033">
</OBJECT>
</TD></TR></TABLE>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_core_using_extension_dll.2c.database.2f.ole.2f.sockets_in_regular_dll"></A>Using Extension DLL,Database/OLE/Sockets in Regular DLL</H1>

<P><A HREF="JavaScript:hhobj_1.Click()">Home</A>  |&nbsp; <A HREF="_core_dlls.3a_.overview.htm">Overview</A>  |&nbsp; <A HREF="_core_dll_tasks.htm">How Do I</A>  |&nbsp; <A HREF="_core_dlls.3a_.frequently_asked_questions.htm">FAQ</A>  |&nbsp; <A HREF="_core_dll_topics.htm">Details</A>  |&nbsp; <A HREF="_core_dll_sample_programs.htm">Sample</A></P>

<P>When using an extension DLL from a regular DLL, if the extension DLL is not wired into the <B>CDynLinkLibrary</B> object chain of the regular DLL, you may run into one or more of a set of related problems. Because the debug versions of the MFC Database, OLE, and Sockets support DLLs are implemented as extension DLLs, you might see similar problems if you are using these MFC features, even if you're not explicitly using any of your own extension DLLs. Some symptoms are:

<UL type=disc>
	<LI>When attempting to de-serialize an object of a type of class defined in the extension DLL, the message "Warning: Cannot load CYourClass from archive. Class not defined." appears in the TRACE debug window and the object fails to serialize.<BR><BR></LI>

	<LI>An exception indicating 'bad class' may be thrown.<BR><BR></LI>

	<LI>Resources stored in the extension DLL fail to load because <B>AfxFindResourceHandle</B> returns <B>NULL</B> or an incorrect resource handle.<BR><BR></LI>

	<LI><B>DllGetClassObject</B>, <B>DllCanUnloadNow</B>, and the <B>UpdateRegistry</B>, <B>Revoke</B>, <B>RevokeAll</B>, and <B>RegisterAll</B> member functions of <B>COleObjectFactory</B> fail to locate a class factory defined in the extension DLL.<BR><BR></LI>

	<LI><B>AfxDoForAllClasses</B> does not work for any classes in the extension DLL.<BR><BR></LI>

	<LI>Standard MFC database, sockets, or OLE resources fail to load. For example, <B>AfxLoadString</B>(<B>AFX_IDP_SQL_CONNECT_FAIL</B>) returns an empty string, even when the regular DLL is properly using the MFC Database classes.</LI>
</UL>

<P>The solution to these problems is to create and export an initialization function in the extension DLL that creates a <B>CDynLinkLibrary</B> object. Call this initialization function exactly once from each regular DLL which uses the extension DLL.</P>

<H2>MFC OLE, MFC Database (or DAO), or MFC Sockets Support </H2>

<P>If you are using any MFC OLE, MFC Database (or DAO), or MFC Sockets support in your regular DLL, respectively, the MFC debug extension DLLs MFCOxxD.DLL, MFCDxxD.DLL, and MFCNxxD.DLL (where xx is the version number) are linked in automatically. You must call a predefined initialization function for each of&nbsp; these DLLs that you are using. </P>

<P>For database support, add a call to <B>AfxDbInitModule</B> to your regular DLL's <B>CWinApp::InitInstance</B> function. Make sure this call occurs before any base-class call or any added code which accesses the MFCDxxD.DLL. This function takes no parameters and returns void.</P>

<P>For OLE support, add a call to <B>AfxOleInitModule</B> to your regular DLL's <B>CWinApp::InitInstance</B>. Note that the <B>COleControlModule InitInstance</B> function calls <B>AfxOleInitModule</B> already, so if you are building an OLE control and are using <B>COleControlModule</B>, you should not add this call to <B>AfxOleInitModule</B>.</P>

<P>For Sockets support, add a call to <B>AfxNetInitModule</B> to your regular DLL's <B>CWinApp::InitInstance</B>.</P>

<P>Note that release builds of MFC DLLs and applications do not use separate DLLs for database, sockets, or OLE support. However, it is safe to call these initialization functions in release mode.</P>

<H2>CDynLinkLibrary Objects</H2>

<P>During each of the operations mentioned at the beginning of this article, MFC needs to search for a desired value or object. For example, during de-serialization, MFC needs to search through all of the currently available runtime classes to match objects in the archive with their proper runtime class.</P>

<P>As a part of these searches, MFC scans through all of the extension DLLs in use by walking a chain of <B>CDynLinkLibrary</B> objects. <B>CDynLinkLibrary</B> objects attach automatically to a chain during their constructor and are created by each extension DLL in turn during initialization. In addition, every module (application or regular DLL) has its own chain of <B>CDynLinkLibrary</B> objects. </P>

<P>In order for an extension DLL to get wired into a <B>CDynLinkLibrary</B> chain, it must create a <B>CDynLinkLibrary</B> object in the context of every module that uses the extension DLL. Therefore, if an extension DLL is going to be used from regular DLLs, it must provide an exported initialization function that creates a <B>CDynLinkLibrary</B> object. Every regular DLL that uses the extension DLL must call the exported initialization function.</P>

<P>If an extension DLL is only going to be used from an MFC application (.EXE) and never from a regular DLL, then it is sufficient to create the <B>CDynLinkLibrary</B> object in the extension DLL's <B>DllMain</B>. This is what the AppWizard extension DLL code does. When loading an extension DLL implicitly, <B>DllMain</B> loads and executes before the application ever starts. Any <B>CDynLinkLibrary</B> creations are wired into a default chain that the MFC DLL reserves for an MFC application.</P>

<P>Note that it is a bad idea to have multiple <B>CDynLinkLibrary</B> objects from one extension DLL in any one chain, especially if the extension DLL will be dynamically unloaded from memory. Do not call the initialization function more than once from any one module.</P>

<H2>Sample Code</H2>

<P>This sample code assumes that the regular DLL is implicitly linking to the extension DLL. This is accomplished by linking to the import library (.LIB) of the extension DLL when building the regular DLL. </P>

<P>These lines should be in the source of the extension DLL:</P>

<PRE><CODE>// YourExtDLL.cpp:

// standard MFC extension DLL routines
#include "afxdllx.h"

static AFX_EXTENSION_MODULE NEAR extensionDLL = { NULL, NULL };

extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        // extension DLL one-time initialization.
        if (!AfxInitExtensionModule(extensionDLL, hInstance))
           return 0;
    }
    return 1;   // ok
}

// Exported DLL initialization is run in context of
// application or regular DLL
extern "C" void WINAPI InitYourExtDLL()
{
    // create a new CDynLinkLibrary for this app
    new CDynLinkLibrary(extensionDLL);

    // add other initialization here
}
</CODE></PRE>

<P>Be sure to export the <B>InitYourExtDLL</B> function. This could be done using <B>__declspec(dllexport)</B>, or in your DLL's .DEF file as follows:</P>

<PRE><CODE>// YourExtDLL.Def:
LIBRARY      YOUREXTDLL
CODE         PRELOAD MOVEABLE DISCARDABLE
DATA         PRELOAD SINGLE
EXPORTS
    InitYourExtDLL
</CODE></PRE>

<P>Add a call to the <B>InitInstance</B> member of the <B>CWinApp</B>-derived object in each regular DLL using the extension DLL: </P>

<PRE><CODE>// YourRegularDLL.cpp:

class CYourRegularDLL : public CWinApp
{
public:
    virtual BOOL InitInstance(); // Initialization
    virtual int ExitInstance();  // Termination

    // nothing special for the constructor
    CYourRegularDLL(LPCTSTR pszAppName) : CWinApp(pszAppName) { }
};

BOOL CYourRegularDLL::InitInstance()
{
  // any DLL initialization goes here
    TRACE0("YOUR regular DLL initializing\n");

  // wire any extension DLLs into CDynLinkLibrary chain
    InitYourExtDLL();

    return TRUE;
}
</CODE></PRE>

<H3>What do you want to do?</H3>

<UL type=disc>
	<LI><A HREF="_core_initialize_extension_dlls.htm">Initialize an extension DLL</A><BR><BR></LI>

	<LI><A HREF="_core_initialize_regular_dlls.htm">Initialize regular DLLs</A></LI>
</UL>

<H3>What do you want to know more about?</H3>

<UL type=disc>
	<LI><A HREF="_core_extension_dlls.htm">Extension DLLs</A><BR><BR></LI>

	<LI><A HREF="_core_regular_dlls_statically_linked_to_mfc.htm">Regular DLLs statically linked to MFC</A><BR><BR></LI>

	<LI><A HREF="_core_regular_dlls_dynamically_linked_to_mfc.htm">Regular DLLs dynamically linked to MFC</A><BR><BR></LI>

	<LI><A HREF="JavaScript:hhobj_2.Click()">Using MFC as Part of a DLL</A><BR><BR></LI>

	<LI><A HREF="JavaScript:hhobj_3.Click()">DLL Version of MFC</A></LI>
</UL>
</font>
</BODY>
</HTML>
