<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Technote: Improved Conformance to ANSI C++</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="technote.3a_.improved_conformance_to_ansi_c.2b2b"></A>Technote: Improved Conformance to ANSI C++</H1>

<P>As a result of improved C++ conformance, some constructs that used to compile will now give errors. Each error message that may result from some of these changes is flagged by "(new behavior; please see help)" at the end of the message. This doesn't mean that the error message has a new meaning; it means that the compiler may be diagnosing an error which it previously did not.</P>

<P>The errors affected are: </P>

<TABLE border=1 cellpadding=5 cols=6 frame=below rules=rows>

<TR VALIGN="top">
<TD width=16%>C2434</TD>
<TD width=17%>C2440</TD>
<TD width=17%>C2446</TD>
<TD width=16%>C2553</TD>
<TD width=17%>C2585</TD>
<TD width=17%>C2592</TD>
</TR>

<TR VALIGN="top">
<TD width=16%>C2664</TD>
<TD width=17%>C2665</TD>
<TD width=17%>C2666</TD>
<TD width=16%>C2667</TD>
<TD width=17%>C2668</TD>
<TD width=17%>C2674</TD>
</TR>

<TR VALIGN="top">
<TD width=16%>C2675</TD>
<TD width=17%>C2676</TD>
<TD width=17%>C2677</TD>
<TD width=16%>C2678</TD>
<TD width=17%>C2679</TD>
<TD width=17%>&nbsp;</TD>
</TR>
</TABLE><BR>

<H2>Overload Resolution Changes</H2>

<P>Visual C++ overload resolution rules have been brought more in line with those specified in the draft C++ standard. This will allow some things to work that previously did not, but it also will result in ambiguities in code that compiled cleanly with earlier versions of Microsoft Visual C++.</P>

<P class=label><B>Dereferencing a Reference is an Identity Conversion</B></P>

<P>Previous versions of Microsoft Visual C++ considered dereferencing a reference or binding to a reference to be a worse conversion than an exact match. These conversions (listed in the <I>Annotated C++ Reference Manual</I> as trivial conversions) are now considered to be identity.</P>

<P>For example:</P>

<PRE><CODE>void foo(const int);
void foo(int&amp;);

void bar(void)
{
    int i;
    int &amp;ri = i;
    foo(i);  // Accepted by VC2.0, VC1.x, rejected by VC4.0, error C2668
    foo(ri);  // Accepted by VC2.0, VC1.x, rejected by VC4.0, error C2668
}
</CODE></PRE>

<P class=label><B>User-Defined Conversions (UDCs) are Selected by 'this' Pointer Types</B></P>

<P>Previous versions of Visual C++ selected the user-defined conversion to call based on the conversion required to get from the result type of the UDC to the required type and ignored the conversion required for the 'this' pointer of the UDC. User-defined conversions are now selected based on the quality of match on the 'this' pointer. As a Microsoft extension (not currently flagged by /Za), the quality of the conversion from the UDC result to the target type is used as a tie-breaker in the event that the 'this' pointers match.</P>

<P>This change of behavior will catch some bad errors that previously had not been detected. For example:</P>

<PRE><CODE>struct C {
    // some class
};

struct D {
    // A class which wraps a C
    C myC;

    // Two user-defined conversion functions, one for 
    //  using myC, and the other for modifying it
    operator C () { return myC; }   // conversion #1
    operator C&amp; () { return myC; }   // conversion #2
};

// A function that takes a C
void func1(C);

// A function that has a D
void func2()
{
    D aD;

    func1(D);  // Error diagnosed in VC4.0: error C2664
}
</CODE></PRE>

<P>The error in this case is that the user-defined conversion is ambiguous. This is because the conversion for the this-pointer is identical for both UDCs, and the result of the UDCs has an identical conversion. The following example (added to the previous one) illustrates another error:</P>

<PRE><CODE>// A function that wants to modify a C
void func3(C&amp;);

// Some function that gets a D&amp;
void func4(const D&amp; aD)
{
    func3(aD);  // Error diagnosed in VC4.0: error C2664
}
</CODE></PRE>

<P>This time, the error occurs because neither UDC can be called—the D object is <B>const</B>, but neither UDC takes a <B>const</B> this pointer.</P>

<P>The way to correct both these problems is to rewrite conversion #1 as follows:</P>

<PRE><CODE>operator C () const { return myC; }  // conversion #1a
</CODE></PRE>

<P>or:</P>

<PRE><CODE>operator const C&amp; () const { return myC; }  // conversion #1b
</CODE></PRE>

<P>Both these conversions take a <B>const </B>this pointer, so they can be called for <B>const</B> objects. In addition, conversion #1b returns a reference to a <B>const</B> object, avoiding copy construction, but still ensuring that the original object will not be modified.</P>

<P>An additional, more subtle effect of this change is that user-defined conversions can silently change behavior. For example:</P>

<PRE><CODE>void foo(int);

struct C {
    operator int () const;
    operator long ();
};

void main(void)
{
    C aC;
    const C acC;

    foo(acC);  // calls "operator int() const"
    foo(aC);   // calls "operator int() const" in VC2.0, 
               // but "operator long()" in VC4.0
}</CODE></PRE>
</font>
</BODY>
</HTML>
