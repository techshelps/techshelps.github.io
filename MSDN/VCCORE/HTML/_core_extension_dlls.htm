<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Extension DLLs</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>

<TABLE ALIGN=right WIDTH=0 BORDER=0><TR><TD>
<OBJECT ID="hhobj_1" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_vc_addpf_home">
</OBJECT>
<OBJECT ID="hhobj_2" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_sample_mfc_DLLHUSK">
</OBJECT>
<OBJECT ID="hhobj_3" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_sample_mfc_DLLHUSK">
</OBJECT>
<OBJECT ID="hhobj_4" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_sample_mfc_DLLHUSK">
</OBJECT>
<OBJECT ID="hhobj_5" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_mfcnotes_TN035">
</OBJECT>
<OBJECT ID="hhobj_6" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_MFCNOTES_TN033">
</OBJECT>
</TD></TR></TABLE>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_core_extension_dlls"></A>Extension DLLs</H1>

<P><A HREF="JavaScript:hhobj_1.Click()">Home</A>  |&nbsp; <A HREF="_core_dlls.3a_.overview.htm">Overview</A>  |&nbsp; <A HREF="_core_dll_tasks.htm">How Do I</A>  |&nbsp; <A HREF="_core_dlls.3a_.frequently_asked_questions.htm">FAQ</A>  |&nbsp; <A HREF="_core_dll_topics.htm">Details</A>  |&nbsp; <A HREF="_core_dll_sample_programs.htm">Sample</A></P>

<P>An MFC extension DLL is a DLL that typically implements reusable classes derived from the existing Microsoft Foundation Class Library classes. </P>

<P>An MFC extension DLL has the following features and requirements:

<UL type=disc>
	<LI>The client EXE must be an MFC application compiled with <B>_AFXDLL</B> defined.<BR><BR></LI>

	<LI>An extension DLL can also be used by a regular DLL which dynamically linked to MFC.<BR><BR></LI>

	<LI>Extension DLLs should be compiled with <B>_AFXEXT</B> defined. This will force <B>_AFXDLL</B> to be also defined and ensures that the proper declarations, etc., will be pulled in from the MFC header files. It also ensures that <B>AFX_EXT_CLASS</B> will be defined as <B>__declspec(dllexport)</B> while building the DLL, which is necessary if you are using this macro to declare the classes in your extension DLL. <BR><BR></LI>

	<LI>Extension DLLs should not instantiate a class derived from <B>CWinApp</B>, but should rely on the client application (or DLL) to provide this object. <BR><BR></LI>

	<LI>Extension DLLs should, however, provide a <B>DllMain</B> function and do any necessary initialization there. </LI>
</UL>

<P>Extension DLLs are built using the dynamic link library version of MFC (also known as the shared version of MFC). Only MFC executables (either applications or regular DLLs) that are built with the shared version of MFC can use an extension DLL. Both the client application and the extension DLL must use the same version of MFCx0.DLL. With an extension DLL, you can derive new custom classes from MFC and then offer this "extended" version of MFC to applications that call your DLL.</P>

<P>Extension DLLs can also be used for passing MFC-derived objects between the application and the DLL. The member functions associated with the passed object exist in the module where the object was created. Since these functions are properly exported when using the shared DLL version of MFC, you can freely pass MFC or MFC-derived object pointers between an application and the extension DLLs it loads.</P>

<P>An MFC extension DLL uses a shared version of MFC in the same way an application uses the shared DLL version of MFC, with a few additional considerations:

<UL type=disc>
	<LI>It does not have a <B>CWinApp</B>-derived object. It must work with the <B>CWinApp</B>-derived object of the client application. This means that the client application owns the main message pump, the idle loop, and so on.<BR><BR></LI>

	<LI>It calls <B>AfxInitExtensionModule</B> in its <B>DllMain</B> function. The return value of this function should be checked. If a zero value is returned from <B>AfxInitExtensionModule</B>, return 0 from your <B>DllMain</B> function.<BR><BR></LI>

	<LI>It will create a <B>CDynLinkLibrary</B> object during initialization if the extension DLL wishes to export <B>CRuntimeClass</B> objects or resources to the application.</LI>
</UL>

<P>Before version 4.0 of MFC, this type of DLL was called an AFXDLL. AFXDLL refers to the <B>_AFXDLL</B> preprocessor symbol that is defined when building the DLL.</P>

<P>The import libraries for the shared version of MFC are named according to the convention described in the topic <A HREF="_core_naming_conventions_for_mfc_dlls.htm">Naming conventions for MFC DLLs</A>. Visual C++ supplies prebuilt versions of the MFC DLLs, plus a number of non-MFC DLLs that you can use and distribute with your applications. These are documented in REDISTRB.WRI, which is found in the \OS\System directory on the Visual C++ CD-ROM.</P>

<P>If you are exporting using a .DEF file, place the following code at the beginning and end of your header file:</P>

<PRE><CODE>#undef AFX_DATA
#define AFX_DATA AFX_EXT_DATA
// &lt;body of your header file&gt;
#undef AFX_DATA
#define AFX_DATA
</CODE></PRE>

<P>These four lines ensure that your code will be compiled correctly for an extension DLL. Leaving out these four lines may cause your DLL to either compile or link incorrectly.</P>

<P>If you need to pass an MFC or MFC-derived object pointer to or from an MFC DLL, the DLL should be an extension DLL. The member functions associated with the passed object exist in the module where the object was created. Since these functions are properly exported when using the shared DLL version of MFC, you can freely pass MFC or MFC-derived object pointers between an application and the extension DLLs it loads.</P>

<P>Due to C++ name mangling and export issues, the export list from an extension DLL may be different between the debug and retail versions of the same DLL and DLLs for different platforms. The retail MFCx0.DLL has about 2,000 exported entry points; the debug MFCx0D.DLL has about 3,000 exported entry points.</P>

<H2>Memory Management</H2>

<P>MFCx0.DLL and all extension DLLs loaded into a client application's address space will use the same memory allocator, resource loading, and other MFC "global" states as if they were in the same application. This is significant because the non-MFC DLL libraries and the regular DLLs do the exact opposite and have each DLL allocating out of its own memory pool.</P>

<P>If an extension DLL allocates memory, then that memory can freely intermix with any other application-allocated object. Also, if an application that dynamically links to MFC crashes, the protection of the operating system will maintain the integrity of any other MFC application sharing the DLL.</P>

<P>Similarly other "global" MFC states, like the current executable file to load resources from, are also shared between the client application and all MFC extension DLLs as well as MFCx0.DLL itself.</P>

<H2>Sharing Resources and Classes</H2>

<P>Exporting resources is done through a resource list. Each application contains a singly linked list of <B>CDynLinkLibrary</B> objects. When looking for a resource, most of the standard MFC implementations that load resources look first at the current resource module (<B>AfxGetResourceHandle</B>) and if the resource is not found walk the list of <B>CDynLinkLibrary</B> objects attempting to load the requested resource. </P>

<P>Walking the list has the disadvantages that it is slightly slower and requires managing resource ID ranges. It has the advantage that a client application that links to several extension DLLs can use any DLL-provided resource without having to specify the DLL instance handle. <B>AfxFindResourceHandle</B> is an API used for walking the resource list to look for a given match. It takes the name and type of a resource and returns the resource handle where it was first found (or NULL).</P>

<P>If you wish to not walk the list and only load resources from a specific place, use the functions <B>AfxGetResourceHandle</B> and <B>AfxSetResourceHandle</B> to save the old handle and set the new handle. Be sure to restore the old resource handle before you return to the client application. For an example of using this approach to explicitly loading a menu, see the file TESTDLL2 .CPP in the sample <A HREF="JavaScript:hhobj_2.Click()">DLLHUSK</A>.</P>

<P>Dynamic creation of MFC objects given an MFC name is similar. The MFC object deserialization mechanism needs to have all of the <B>CRuntimeClass</B> objects registered so that it can reconstruct by dynamically creating C++ objects of the required type based on what was stored earlier.</P>

<P>In the case of the MFC Advanced Concepts sample <A HREF="JavaScript:hhobj_3.Click()">DLLHUSK</A>, the list looks something like:</P>

<PRE><CODE>head -&gt;   DLLHUSK.EXE   - or -   DLLHUSK.EXE
               |                      |
          TESTDLL2.DLL           TESTDLL2.DLL
               |                      |
          TESTDLL1.DLL           TESTDLL1.DLL
               |                      |
           MFCOxxD.DLL                |
               |                      |
           MFCDxxD.DLL                |
               |                      |
            MFCxxD.DLL            MFCxx.DLL
</CODE></PRE>

<P>where <I>xx</I> is the version number; for example, '42' represents version 4.2.</P>

<P>The MFCxx.DLL is usually last on the resource and class list. MFCxx.DLL includes all of the standard MFC resources, including prompt strings for all the standard command IDs. Placing it at the end of the list allows DLLs and the client application itself not to have their own copy of the standard MFC resources, but to rely on the shared resources in the MFCxx.DLL instead.</P>

<P>Merging the resources and class names of all DLLs into the client application's name space has the disadvantage of requiring you to be careful with what IDs or names you pick. </P>

<P>The <A HREF="JavaScript:hhobj_4.Click()">DLLHUSK</A> sample manages the shared resource name space by using multiple header files. </P>

<P>If your MFC extension DLL needs to maintain extra data for each application, you can derive a new class from <B>CDynLinkLibrary</B> and create it in <B>DllMain</B>. When running, the DLL can check the current application's list of <B>CDynLinkLibrary</B> objects to find the one for that particular extension DLL.</P>

<H3>What do you want to do?</H3>

<UL type=disc>
	<LI><A HREF="_core_initialize_extension_dlls.htm">Initialize an extension DLL</A></LI>
</UL>

<H3>What do you want to know more about?</H3>

<UL type=disc>
	<LI><A HREF="JavaScript:hhobj_5.Click()">Tips on using shared resource files</A><BR><BR></LI>

	<LI><A HREF="JavaScript:hhobj_6.Click()">DLL Version of MFC</A><BR><BR></LI>

	<LI><A HREF="_core_regular_dlls_statically_linked_to_mfc.htm">Regular DLLs statically linked to MFC</A><BR><BR></LI>

	<LI><A HREF="_core_regular_dlls_dynamically_linked_to_mfc.htm">Regular DLLs dynamically linked to MFC</A><BR><BR></LI>

	<LI><A HREF="_core_using_extension_dll.2c.database.2f.ole.2f.sockets_in_regular_dll.htm">Using Extension DLL,Database/OLE/Sockets in Regular DLL</A></LI>
</UL>
</font>
</BODY>
</HTML>
