<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Writing a Multithreaded Win32 Program</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>

<TABLE ALIGN=right WIDTH=0 BORDER=0><TR><TD>
<OBJECT ID="hhobj_1" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_vc_addpf_home">
</OBJECT>
</TD></TR></TABLE>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_core_writing_a_multithreaded_win32_program"></A>Writing a Multithreaded Win32 Program</H1>

<P><A HREF="JavaScript:hhobj_1.Click()">Home</A>  |&nbsp; <A HREF="_core_multithreaded_programs.3a_.overview.htm">Overview</A>  |&nbsp; <A HREF="_core_multithreading_tasks.htm">How Do I</A>  |&nbsp; <A HREF="_core_multithreading_sample_list.htm">Sample</A></P>

<P>When you write a program with multiple threads, you must coordinate their behavior and <A HREF="#_core_sharing_common_resources_between_threads">use of the program’s resources</A>. You must also make sure that each thread receives <A HREF="#_core_thread_stacks">its own stack</A>. </P>



<H2><A NAME="_core_sharing_common_resources_between_threads"></A>Sharing Common Resources Between Threads</H2>

<P class=indent><B><B>Note</B></B>&nbsp;&nbsp;&nbsp;For a similar discussion from the MFC point of view, see Multithreading: Programming Tips and Multithreading: When to Use the Synchronization Classes.</P>

<P>Each thread has its own stack and its own copy of the CPU registers. Other resources, such as files, static data, and heap memory, are shared by all threads in the process. Threads using these common resources must be synchronized. Win32 provides several ways to synchronize resources, including semaphores, critical sections, events, and mutexes.</P>

<P>When multiple threads are accessing static data, your program must provide for possible resource conflicts. Consider a program where one thread updates a static data structure containing <I>x</I>,<I>y</I> coordinates for items to be displayed by another thread. If the update thread alters the <I>x</I> coordinate and is preempted before it can change the <I>y</I> coordinate, the display thread may be scheduled before the <I>y</I> coordinate is updated. The item would be displayed at the wrong location. You can avoid this problem by using semaphores to control access to the structure.</P>

<P>A mutex (short for <I>mut</I>ual <I>ex</I>clusion) is a way of communicating among threads or processes that are executing asynchronously of one another. This communication is usually used to coordinate the activities of multiple threads or processes, typically by controlling access to a shared resource by “locking” and “unlocking” the resource. To solve this <I>x</I>,<I>y</I> coordinate update problem, the update thread would set a mutex indicating that the data structure is in use before performing the update. It would clear the mutex after both coordinates had been processed. The display thread must wait for the mutex to be clear before updating the display. This process of waiting for a mutex is often called “blocking” on a mutex because the process is blocked and cannot continue until the mutex clears.</P>

<P>The BOUNCE.C program shown in the <A HREF="_core_sample_multithread_c_program.htm">previous section</A> uses a mutex named <CODE>ScreenMutex</CODE> to coordinate screen updates. Each time one of the display threads is ready to write to the screen, it calls <B>WaitForSingleObject</B> with the handle to <CODE>ScreenMutex</CODE> and constant <B>INFINITE</B> to indicate that the <B>WaitForSingleObject</B> call should block on the mutex and not time out. If <CODE>ScreenMutex</CODE> is clear, the wait function sets the mutex so other threads cannot interfere with the display and continues executing the thread. Otherwise, the thread blocks until the mutex clears. When the thread completes the display update, it releases the mutex by calling <B>ReleaseMutex</B>.</P>

<P>Screen displays and static data are only two of the resources requiring careful management. For example, your program may have multiple threads accessing the same file. Because another thread may have moved the file pointer, each thread must reset the file pointer before reading or writing. In addition, each thread must make sure that it is not preempted between the time it positions the pointer and the time it accesses the file. These threads should use a semaphore to coordinate access to the file by bracketing each file access with <B>WaitForSingleObject</B> and <B>ReleaseMutex</B> calls. The following code fragment illustrates this technique:</P>

<PRE><CODE>HANDLE    hIOMutex= CreateMutex (NULL, FALSE, NULL);

WaitForSingleObject( hIOMutex, INFINITE );
fseek( fp, desired_position, 0L );
fwrite( data, sizeof( data ), 1, fp );
ReleaseMutex( hIOMutex);
</CODE></PRE>



<H2><A NAME="_core_thread_stacks"></A>Thread Stacks</H2>

<P>All of an application’s default stack space is allocated to the first thread of execution, which is known as thread 1. As a result, you must specify how much memory to allocate for a separate stack for each additional thread your program needs. The operating system will allocate additional stack space for the thread, if necessary, but you must specify a default value.</P>

<P>The first argument in the <B>_beginthread</B> call is a pointer to the <B>BounceProc</B> function, which will execute the threads. The second argument specifies the default stack size for the thread. The last argument is an ID number that is passed to <B>BounceProc</B>. <B>BounceProc</B> uses the ID number to seed the random number generator and to select the thread’s color attribute and display character.</P>

<P>Threads that make calls to the C run-time library or to the Win32 API must allow sufficient stack space for the library and API functions they call. The C <B>printf</B> function requires more than 500 bytes of stack space, and you should have 2K of stack space available when calling Win32 API routines.</P>

<P>Because each thread has its own stack, you can avoid potential collisions over data items by using as little static data as possible. Design your program to use automatic stack variables for all data that can be private to a thread. The only global variables in the BOUNCE.C program are either mutexes or variables that never change after they are initialized.</P>

<P>Win32 also provides Thread-Local Storage (TLS) to store per-thread data. See <A HREF="_core_thread_local_storage_.28.tls.29.htm">Thread Local Storage</A> for more information.</P>
</font>
</BODY>
</HTML>
