<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Dumping All Objects</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_core_dumping_all_objects"></A>Dumping All Objects</H1>

<P>This topic explains how to obtain a diagnostic dump of all objects in your program.</P>

<P>For information on dumping C run-time objects, see <A HREF="_core_using_the_debug_heap.htm">Using the Debug Heap</A> and <A HREF="_crt__crtsetdbgflag.htm">_CrtSetDbgFlag</A>.</P>

<P><B>DumpAllObjectsSince</B> dumps out a description of all objects detected on the heap that have not been deallocated. As the name implies, <B>DumpAllObjectsSince</B> dumps all objects allocated since the last <B>Checkpoint</B>. However, if no <B>Checkpoint</B> has taken place, all objects and nonobjects currently in memory are dumped.</P>

<P class=indent><B><B>Note</B></B>&nbsp;&nbsp;&nbsp;Before you can use MFC object dumping, you must enable diagnostic tracing. See the Note in the topic <A HREF="_core_diagnostic_features.htm">Diagnostics</A>. </P>

<P class=label><B><A NAME="_core_to_dump_all_objects"></A>To dump all objects</B>

<UL type=disc>
	<LI>Expanding on the example shown in <A HREF="_core_detecting_a_memory_leak.htm">Detecting a Memory Leak</A> in the topic Detecting Memory Leaks, the following code dumps all objects that have not been deallocated when a memory leak is detected:
<PRE><CODE>if( diffMemState.Difference( oldMemState, newMemState ) )
{
    TRACE( "Memory leaked!\n" );
    diffMemState.DumpAllObjectsSince();
}
</CODE></PRE>

<P class=tl>A sample dump from the preceding example is shown here:</P>
<PRE><CODE>Dumping objects -&gt;

{5} strcore.cpp(80) : non-object block at $00A7521A, 9 bytes long
{4} strcore.cpp(80) : non-object block at $00A751F8, 5 bytes long
{3} strcore.cpp(80) : non-object block at $00A751D6, 6 bytes long
{2} a CPerson at $51A4

Last Name: Smith
First Name: Alan
Phone #: 581-0215

{1} strcore.cpp(80) : non-object block at $00A7516E, 25 bytes long
</CODE></PRE>

<P class=tl>The numbers in braces at the beginning of most lines specify the order in which the objects were allocated. The most recently allocated object appears first. You can use these ordering numbers to help identify allocated objects.</P></LI>
</UL>

<P>To set a breakpoint when a particular allocation occurs, first start your application in the debugger. Set the global variable <B>_afxBreakAlloc</B> to the number in braces discussed earlier. This will set a conditional breakpoint in your application that will trigger when the allocation you specify is being made. Looking at the call stack at this point will tell you the path your program took to get to the specified allocation.</P>

<P>The C run-time library has a similar function, <A HREF="_crt__crtsetbreakalloc.htm">_CrtSetBreakAlloc</A>, that you can use for C run-time allocations.</P>
</font>
</BODY>
</HTML>
