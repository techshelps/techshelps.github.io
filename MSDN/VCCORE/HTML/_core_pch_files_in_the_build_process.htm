<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PCH Files in the Build Process</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>

<TABLE ALIGN=right WIDTH=0 BORDER=0><TR><TD>
<OBJECT ID="hhobj_1" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_vc_compiling_home">
</OBJECT>
</TD></TR></TABLE>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_core_pch_files_in_the_build_process"></A>PCH Files in the Build Process</H1>

<P><A HREF="JavaScript:hhobj_1.Click()">Home</A></P>

<P>The code base of a software project is usually contained in multiple C or C++ source files, object files, libraries, and header files. Typically, a makefile coordinates the combination of these elements into an executable file. Figure 1 shows the structure of a makefile that uses a precompiled header file. Both the NMAKE macro names and the filenames in this diagram coincide with those in the example code found at the end of this section.</P>

<P>The following figure uses three diagrammatic devices to show the flow of the build process. Named rectangles represent each file or each macro; the three macros represent one or more files. Shaded areas represent each compile or link action. Arrows show which files and macros are combined during the compilation or linking process.</P>

<P class=label><B>Structure of a Makefile That Uses a Precompiled Header File</B></P>

<P><IMG SRC="mkflpch.gif" ALT="" BORDER=0></P>

<P>Beginning at the top of the diagram, both STABLEHDRS and BOUNDRY are NMAKE macros in which you list files not likely to need recompilation. These files are compiled using the command string</P>

<PRE><CODE>CL /c /W3 /Yc$(BOUNDRY) applib.cpp myapp.cpp</CODE></PRE>

<P>only if the precompiled header file (STABLE.PCH) does not exist or if you make changes to the files listed in the two macros. In either case, the precompiled header file will contain code only from the files listed in the STABLEHDRS macro. List the last file you want precompiled in the BOUNDRY macro. </P>

<P>The files you list in these macros can be either header files or C or C++ source files. (A single .PCH file cannot be used with both C and C++ modules.) Note that you can use the hdrstop macro to stop precompilation at some point within the BOUNDRY file. See <A HREF="_core_using_the_hdrstop_pragma.htm">Using the hdrstop Pragma</A> for more information.</P>

<P>Continuing down the diagram, APPLIB.OBJ represents the support code used in your final application. It is created from APPLIB.CPP, the files listed in the UNSTABLEHDRS macro, and precompiled code from the precompiled header. </P>

<P>MYAPP.OBJ represents your final application. It is created from MYAPP.CPP, the files listed in the UNSTABLEHDRS macro, and precompiled code from the precompiled header.</P>

<P>Finally, the executable file (MYAPP.EXE) is created by linking the files listed in the OBJS macro (APPLIB.OBJ and MYAPP.OBJ).</P>
</font>
</BODY>
</HTML>
