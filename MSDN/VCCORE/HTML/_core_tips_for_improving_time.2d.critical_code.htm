<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Tips for Improving Time-Critical Code</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>

<TABLE ALIGN=right WIDTH=0 BORDER=0><TR><TD>
<OBJECT ID="hhobj_1" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_vc_perf_home">
</OBJECT>
<OBJECT ID="hhobj_2" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_mfc_CString">
</OBJECT>
<OBJECT ID="hhobj_3" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_mfc_CArray">
</OBJECT>
<OBJECT ID="hhobj_4" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_mfc_CList">
</OBJECT>
<OBJECT ID="hhobj_5" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_win32_HeapCreate">
</OBJECT>
<OBJECT ID="hhobj_6" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_win32_HeapAlloc">
</OBJECT>
<OBJECT ID="hhobj_7" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_win32_SetProcessWorkingSetSize">
</OBJECT>
<OBJECT ID="hhobj_8" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_win32_GetProcessWorkingSetSize">
</OBJECT>
<OBJECT ID="hhobj_9" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="spy">
</OBJECT>
<OBJECT ID="hhobj_10" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="pview">
</OBJECT>
</TD></TR></TABLE>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_core_tips_for_improving_time.2d.critical_code"></A>Tips for Improving Time-Critical Code</H1>

<P><A HREF="JavaScript:hhobj_1.Click()">Home</A>  |&nbsp; <A HREF="_core_overviews.3a_.performance_tuning.htm">Overviews</A></P>

<P>Writing fast, time-critical code requires that you carefully analyze all aspects of your code and how it interacts with the system. This section will suggest alternatives to some of the more obvious coding techniques when fast execution times are required.</P>

<P>One of the key factors in writing fast code is to "know your code." If you are using a library, make sure you have the source code (or have a thorough understanding of how the library works where it pertains to performance-critical code) which will enable you to make informed decisions. </P>

<P>In addition to the suggestions provided in this section there are tools like the <A HREF="_core_profiling.3a_.overview.htm">profiler</A> and Windows NT performance monitor (perfmon.exe) that may assist you in analyzing and maximizing your code's performance.</P>

<P>This section offers suggestions to ensure that the time-critical portions of your code perform satisfactorily.

<UL type=disc>
	<LI><A HREF="#_core_cache_hits_and_page_faults">Cache Hits and Page Faults</A><BR><BR></LI>

	<LI><A HREF="#_core_sorting_and_searching">Sorting and Searching</A><BR><BR></LI>

	<LI><A HREF="#_core_mfc_and_class_libraries">MFC and Class Libraries</A><BR><BR></LI>

	<LI><A HREF="#_core_shared_libraries">Shared Libraries</A><BR><BR></LI>

	<LI><A HREF="#_core_heaps">Heaps</A><BR><BR></LI>

	<LI><A HREF="#_core_threads">Threads</A><BR><BR></LI>

	<LI><A HREF="#_core_small_working_set">Small Working Set</A></LI>
</UL>

<H2>Summary of Improving Time-Critical Sections of Code</H2>

<P>The following points summarize where you should concentrate your efforts to make your code run as efficiently as possible:

<UL type=disc>
	<LI>Know which parts of your program have to be fast.<BR><BR></LI>

	<LI>Know the size and speed of your code.<BR><BR></LI>

	<LI>Know the cost of new features.<BR><BR></LI>

	<LI>Know the minimum work needed to accomplish the job.</LI>
</UL>



<H2><A NAME="_core_cache_hits_and_page_faults"></A>Cache Hits and Page Faults</H2>

<P>Missed cache hits, on both the internal and external cache, as well as page faults (going to secondary storage for program instructions and data) slow the performance of a program. </P>

<P>It is estimated that a missed CPU cache hit results in a loss of 10–20 clock cycles. A missed external cache hit results in a loss of 20–40 clock cycles. A page fault results in about 1 million lost instructions. Therefore, it is in the best interest of program execution to write code that will reduce the number of missed cache hits and page faults.</P>

<P>One reason for slow programs is that they take more page faults or miss the cache more often than necessary.&nbsp; To avoid this, it’s important to use data structures with good locality of reference, which means keeping related things together.&nbsp; Sometimes a data structure which looks great turns out to be horrible because of poor locality of reference, and sometimes the reverse is true. Here are two examples:

<UL type=disc>
	<LI>Dynamically allocated linked lists can reduce program performance because when you search for an item or when you traverse a list to the end, each skipped link could miss the cache or cause a page fault. A list implementation based on simple arrays might actually be much faster because of better caching and fewer page faults—even allowing for the fact that the array would be harder to grow, it still might be faster. <BR><BR></LI>

	<LI>Hash tables that use dynamically allocated linked lists can degrade performance. By extension, hash tables that use dynamically allocated linked lists to store their contents might perform substantially worse than you might expect. In fact, in the final analysis, a simple linear search through an array <B><I>might</I></B> actually be faster (depending on the circumstances). Array-based hash tables (so-called “closed hashing”) is an often-overlooked implementation which frequently has superior performance. </LI>
</UL>



<H2><A NAME="_core_sorting_and_searching"></A>Sorting and Searching</H2>

<P>Sorting is an inherently time consuming operation (compared to other typical operations you might have to do). The best way to speed up code that is slow due to sorting is to find a way to not sort at all. 

<UL type=disc>
	<LI>Perhaps the sort can be deferred to a non-performance–critical time.<BR><BR></LI>

	<LI>Perhaps only part of the data truly needs to be sorted.<BR><BR></LI>

	<LI>Perhaps information was available at some other time that would have made the sort easier to do later.</LI>
</UL>

<P>You <I>might</I> be able to build the list in sorted order. But this might slow you down overall because inserting each new element in order could require a more complicated data structure with possibly worse locality of reference. There are no easy answers; try several approaches and measure the differences.</P>

<P>If you find that you must sort there are a few things to remember:

<UL type=disc>
	<LI>Use a stock sort; writing your own is a recipe for bugs. <BR><BR></LI>

	<LI>Anything you can do <I>before</I> the sort that simplifies what you need to do <I>during</I> the sort is probably a good thing. If a sort runs in O(<I>n</I> log <I>n</I>) and you can make a one-time pass over your data to simplify the comparisons such that the sort can now run in O(<I>n</I>), you’re well ahead<I>.</I>  <BR><BR></LI>

	<LI>Think about the locality of reference of the sort algorithm you’re using versus the data that you expect it to run on.</LI>
</UL>

<P>There are fewer alternatives to searching than for sorting if you want to improve performance. If you need to do a search and if the search is time-critical, a binary search or hash table lookup is almost always the right answer. But again keep locality in mind. A linear search through a small array might be faster than a binary search through a data structure with a lot of pointers, which could cause page faults or cache misses.</P>



<H2><A NAME="_core_mfc_and_class_libraries"></A>MFC and Class Libraries</H2>

<P>The Microsoft Foundation Class library (MFC) provides a framework that can greatly simplify writing code. Other class libraries are available for the same purpose. The following discussion is specific to MFC but is valid for similar idioms in other libraries. </P>

<P>When writing time-critical code, you should be aware of the overhead implied in using some of the classes. Examine the MFC code that your time-critical section is using to see if it meets your performance requirements. The following is a list of some performance issues you should be aware of in MFC.

<UL type=disc>
	<LI><B>CString</B>&nbsp;&nbsp;&nbsp;The memory for a <A HREF="JavaScript:hhobj_2.Click()">CString</A> is dynamically allocated, which means it calls the C run-time library which in turn could call the operating system. So don’t use a <B>CString</B> simply to store a constant string; use <B>const char *</B>. Often a simple char array on the stack is the right answer.
<P class=tl>The <B>CString</B> class simplifies the writing of code that does string manipulation. Keep in mind, however, that any operation you perform with a <B>CString</B> object could imply a significant amount of overhead that could affect your performance. Step through the code that is generated to see exactly what is executed. It may be faster to use the run-time library <A HREF="_crt_string_manipulation.htm">string</A> functions to have more complete control over what is executed. Generally speaking a <B>CString </B>is as efficient as any other <I>dynamically</I> allocated string, which means you bear the overhead of the dynamic allocation and release of memory.</P></LI>

	<LI><B>CArray </B>and <B>CList</B>&nbsp;&nbsp;&nbsp;The <A HREF="JavaScript:hhobj_3.Click()">CArray</A> and <A HREF="JavaScript:hhobj_4.Click()">CList</A> classes provide functionality to your MFC program that is not available to regular arrays. You may not need <B>CArray </B>if you know the specific limits necessary for the array; in that case you can just use a global fixed array. If you use <B>CArray</B>, you&nbsp; should use <B>CArray::SetSize </B>to establish its size and specify the number of elements by which to grow whenever a reallocation is necessary. If you do not use <B>SetSize</B>, adding elements could cause your array to be frequently reallocated and copied, which is inefficient and can fragment memory. You should also be aware that if you insert an item into an array, <B>CArray </B>will move subsequent items in memory. Before moving, <B>CArray </B>may need to grow the array. Both of these actions could cause cache misses or page faults. This is one of the things that is not obvious if you just use the <B>CArray </B>class members, and again you should step through the code that MFC uses to see if you can write something more specific to your scenario that would improve your code's performance. For example, you could provide <B>CArray </B>specializations for specific types, since it is a template.
<P class=tl><B>CList </B>is a doubly-linked list, which means that element insertion is fast at the head, tail, and at a known <B>POSITION</B> in the list. A sequential search is necessary to look up an element by value or index. This search can be slow if the list is long. If your code just requires a singly-linked list, then you may want to reconsider using <B>CList</B>, whose overhead includes updating an additional pointer for all operations as well as the memory for that pointer. While the additional memory is not great, it is another opportunity for missed cache hits or page faults.</P></LI>

	<LI><B>IsKindOf</B>&nbsp;&nbsp;&nbsp;This function can generate many calls and potentially visit a lot of memory in different data areas (bad locality of reference), which you can observe as you step through the MFC source code. <B>IsKindOf</B> is useful for a debug build (in an ASSERT call, for example) but you should consider whether it can be avoided in a release build.<BR><BR></LI>

	<LI><B>PreTranslateMessage</B> function&nbsp;&nbsp;&nbsp;You should use <B>PreTranslateMessage</B> in cases where a particular tree of windows needs different keyboard accelerators. You can also use <B>PreTranslateMessage </B>where you must insert message handling into the message pump. <B>PreTranslateMessage</B> is the approved way of altering the way MFC dispatches messages. You should be careful to override <B>PreTranslateMessage</B> only at the level needed. For example, it is not necessary to override <B>CMainFrame::PreTranslateMessage</B> if all you are interested in is messages going to children of a particular view. In that case, just override <B>PreTranslateMessage </B>for the view class.
<P class=tl>You should not circumvent the normal dispatch path by using <B>PreTranslateMessage</B> to handle any message sent to any window. For this you should use <A HREF="_core_registering_window_.93.classes.94.htm">window procedures</A> and <A HREF="_core_how_to_manage_commands_and_messages_with_classwizard.htm">MFC message maps</A>.</P></LI>

	<LI><B>OnIdle</B> function&nbsp;&nbsp;&nbsp;Idle events can occur at times you do not expect, such as between <B>WM_KEYDOWN</B> and <B>WM_KEYUP </B>events. Timers may be a more efficient way to trigger your desired behavior. Also, you should not force <B>OnIdle </B>to be called repetitively by generating false messages or by always returning <B>TRUE </B>from an override of <B>OnIdle </B>because this will never allow your thread to sleep. Again, a timer or a separate thread might be more appropriate.</LI>
</UL>



<H2><A NAME="_core_shared_libraries"></A>Shared Libraries</H2>

<P>Code reuse is desirable. However, if you are going to use someone else’s code, you should make sure you know exactly what it does in those cases where performance is critical to you. The best way to understand this is by stepping through the source code or by measuring with tools such as the profiler, PView, or Windows NT Performance monitor.</P>



<H2><A NAME="_core_heaps"></A>Heaps</H2>

<P>Use multiple heaps with discretion. Additional heaps are created with <A HREF="JavaScript:hhobj_5.Click()">HeapCreate</A> and <A HREF="JavaScript:hhobj_6.Click()">HeapAlloc</A> and let you manage and then dispose of a related set of allocations. You don’t want to commit too much memory. If you’re using multiple heaps, pay special attention to the amount of memory that is initially committed.</P>

<P>Instead of multiple heaps, you may want to use helper functions to wrap the default heap. You can write helper functions to interface between your code and the default heap. Helper functions could facilitate custom allocation strategies that could improve the performance of your application. For example, if you perform many small allocations frequently, you may want to localize these allocations to one part of the default heap. You can allocate a large block of memory and then use a helper function to suballocate from that block. If you do this, you will not have additional heaps with unused memory because the allocation is coming out of the default heap.</P>

<P>On the other hand, using the default heap might get you less locality of reference than you desire. You really have to measure the effects of moving objects from heap to heap with tools such as the profiler, PView, Spy++, or Windows NT Performance monitor.</P>

<P>Measure your heaps so you can account for every allocation on the heap. Use the C run-time <A HREF="_core_using_the_debug_heap.htm">debug heap routines</A> to checkpoint and dump your heap.&nbsp; You could then read the output into Excel and use pivot tables to view the results. Note the total number and size of allocations as well as the distribution of the allocations. You may want to compare these versus the size of working sets. You may also be interested in clustering of related-sized objects.</P>

<P>You can also use the Windows NT performance counters to monitor memory usage.</P>



<H2><A NAME="_core_threads"></A>Threads</H2>

<P>When you need a background task, threads may not be your best solution. Effective idle handling of the event may be a better solution. It’s easier to understand the locality of reference of your program with one thread than with two or more.</P>

<P>A good rule of thumb is that you should only use a thread if an operating system notification that you need to block on is at the root of the background work. Threads are best in such a case because it is not practical to block a main thread on an event.</P>

<P>Threads also present communication problems. You will have to manage the communication link between your threads, whether it be with a list of messages or by allocating and using shared memory. Managing your communication link will likely require synchronization to avoid race conditions and deadlock problems. Such complexity can easily turn into&nbsp; bugs and performance problems.</P>

<P>For addititonal information, see <A HREF="_core_idle_loop_processing.htm">Idle Loop Processing</A> and <A HREF="_core_multithreading_topics.htm">Multithreading Topics</A>.</P>



<H2><A NAME="_core_small_working_set"></A>Small Working Set</H2>

<P>Smaller working sets mean fewer page faults and more cache hits. This directly translates to into performance gains. We’ve mentioned locality of reference throughout this document; a small working set can mean good locality of reference. The process working set is the closest metric the operating system directly provides for telling you if you have good or bad locality of reference.</P>

<P class=indent>See <A HREF="JavaScript:hhobj_7.Click()">SetProcessWorkingSetSize</A><B> </B>for information on how to set the upper and lower limits of the working set.&nbsp; See <A HREF="JavaScript:hhobj_8.Click()">GetProcessWorkingSetSize</A> for information on how to obtain the minimum and maximum working set sizes.&nbsp; You can use <A HREF="JavaScript:hhobj_9.Click()">Spy++</A> or <A HREF="JavaScript:hhobj_10.Click()">PView</A> to view the size of the working set.</P>
</font>
</BODY>
</HTML>
