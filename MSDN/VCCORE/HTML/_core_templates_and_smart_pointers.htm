<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Templates and Smart Pointers</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>

<TABLE ALIGN=right WIDTH=0 BORDER=0><TR><TD>
<OBJECT ID="hhobj_1" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_vc_addpf_home">
</OBJECT>
</TD></TR></TABLE>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_core_templates_and_smart_pointers"></A>Templates and Smart Pointers</H1>

<P><A HREF="JavaScript:hhobj_1.Click()">Home</A>  |&nbsp; <A HREF="_core_templates_in_c.2b2b3a_.overview.htm">Overview</A>  |&nbsp; <A HREF="_core_template_tasks.htm">How Do I</A></P>

<P>C++ allows you to create “smart pointer” classes that encapsulate pointers and override pointer operators to add new functionality to pointer operations. Templates allow you to create generic wrappers to encapsulate pointers of almost any type.</P>

<P>The following code outlines a simple reference count garbage collector. The template class Ptr&lt;T&gt; implements a garbage collecting pointer to any class derived from RefCount.</P>

<PRE><CODE>#include &lt;stdio.h&gt;

#define TRACE printf

class RefCount {
    int crefs;
public:
    RefCount(void) { crefs = 0; }
    ~RefCount() { TRACE("goodbye(%d)\n", crefs); }
    void upcount(void) { ++crefs; TRACE("up to %d\n", crefs);}
    void downcount(void)
     {
     if (--crefs == 0)
      {
      delete this;
      }
     else
      TRACE("downto %d\n", crefs);
     }
};

class Sample : public RefCount {
public:
    void doSomething(void) { TRACE("Did something\n");}
};

template &lt;class T&gt; class Ptr {
    T* p;
public:
    Ptr(T* p_) : p(p_) { p-&gt;upcount(); }
    ~Ptr(void) { p-&gt;downcount(); }
    operator T*(void) { return p; }
    T&amp; operator*(void) { return *p; }
    T* operator-&gt;(void) { return p; }
    Ptr&amp; operator=(Ptr&lt;T&gt; &amp;p_)
        {return operator=((T *) p_);}
    Ptr&amp; operator=(T* p_) {
        p-&gt;downcount(); p = p_; p-&gt;upcount(); return *this;
    }
};

int main() {
    Ptr&lt;Sample&gt; p  = new Sample; // sample #1
    Ptr&lt;Sample&gt; p2 = new Sample; // sample #2
    p = p2; // #1 will have 0 crefs, so it is destroyed;
            // #2 will have 2 crefs.
    p-&gt;doSomething();
    return 0;
    // As p2 and p go out of scope, their destructors call
    // downcount. The cref variable of #2 goes to 0, so #2 is
    // destroyed
}
</CODE></PRE>

<P>Classes <CODE>RefCount</CODE> and <CODE>Ptr&lt;T&gt;</CODE> together provide a simple garbage collection solution for any class that can afford the <CODE>int</CODE> per instance overhead to inherit from <CODE>RefCount</CODE>. Note that the primary benefit of using a parametric class like <CODE>Ptr&lt;T&gt;</CODE> instead of a more generic class like <CODE>Ptr</CODE> is that the former is completely type-safe. The preceding code ensures that a <CODE>Ptr&lt;T&gt;</CODE> can be used almost anywhere a <CODE>T*</CODE> is used; in contrast, a generic <CODE>Ptr</CODE> would only provide implicit conversions to <CODE>void*</CODE>.</P>

<P>For example, consider a class used to create and manipulate garbage collected files, symbols, strings, and so forth. From the class template <CODE>Ptr&lt;T&gt;</CODE>, the compiler will create template classes <CODE>Ptr&lt;File&gt;</CODE>, <CODE>Ptr&lt;Symbol&gt;</CODE>, <CODE>Ptr&lt;String&gt;</CODE>, and so on, and their member functions: <CODE>Ptr&lt;File&gt;::~Ptr()</CODE>, <CODE>Ptr&lt;File&gt;::operator File*()</CODE>, <CODE>Ptr&lt;String&gt;::~Ptr()</CODE>, <CODE>Ptr&lt;String&gt;::operator String*()</CODE>, and so on.</P>
</font>
</BODY>
</HTML>
