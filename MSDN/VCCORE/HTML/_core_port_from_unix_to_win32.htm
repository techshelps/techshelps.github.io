<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Port from UNIX to Win32</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>

<TABLE ALIGN=right WIDTH=0 BORDER=0><TR><TD>
<OBJECT ID="hhobj_1" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_win32_Deviation_from_Berkeley_Sockets_2">
</OBJECT>
<OBJECT ID="hhobj_2" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_rpc_Run_Time_RPC_Functions">
</OBJECT>
<OBJECT ID="hhobj_3" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_mapi1book_Creating_a_New_Interprocess_IPC_Message_Class">
</OBJECT>
<OBJECT ID="hhobj_4" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_win32_Graphics_Device_Interface_PT">
</OBJECT>
</TD></TR></TABLE>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_core_port_from_unix_to_win32"></A>Port from UNIX to Win32</H1>

<P>When migrating applications from UNIX to Windows, there are several options:

<UL type=disc>
	<LI>Running UNIX applications on Windows NT using the POSIX subsystem<BR><BR></LI>

	<LI>Using UNIX libraries to port applications from UNIX to Win32<BR><BR></LI>

	<LI>Porting applications from UNIX to Win32 natively</LI>
</UL>

<P>The first option UNIX programmers look at is the Windows NT POSIX subsystem. However, it only supports POSIX 1003.1, which was the only POSIX version standardized when Windows NT was created. Since then, there has been little demand for extending this subsystem, because most applications have been converted to Win32. The 1003.1 system is of limited interest for fully featured applications, because it does not include many capabilities (such as those in 1003.2, network support, and so on). Full featured applications run under the Windows NT POSIX subsystem do not have access to Windows NT features available to Win32 applications, such as memory-mapped files, networking, and graphics. Applications such as VI, LS, and GREP are the main targets for the Windows NT POSIX subsystem.</P>

<P>The second option UNIX programmers normally consider is using third-party UNIX-like libraries to let their UNIX code compile as a Win32 executable. Several commercial (and at least one public domain) libraries do this. This is an option for some applications. The advantage of these porting libraries is that they minimize the initial porting effort. The main disadvantage, for a competitive software product, is that a native Win32 port of an application will generally be faster and will inevitably have more functionality. It can be awkward for the application to step outside of its UNIX shell if it needs to make Win32 calls to get more power from Windows NT.</P>

<P>The third option is porting UNIX applications directly to Win32. Using ANSI C/C++ libraries, and commercial C compiler libraries, many of the traditional system calls relied on by UNIX applications are available in Win32 applications.</P>

<P>The output model of <B>stdio</B>-based applications does not need to be changed, since the Win32 console APIs mimic the <B>stdio</B> model, and versions of cursors exist that use the Win32 console APIs.</P>

<P>Berkeley socket-based applications need very few changes to work as Win32 applications. The Windows Sockets interface was designed for portability with BSD sockets, with minimal changes that are noted in the introductory sections of the WinSock specification. See <A HREF="JavaScript:hhobj_1.Click()">Deviation from Berkeley Sockets</A>.</P>

<P>Windows NT supports DCE-compliant RPC, so RPC-based applications are easily usable. See the <A HREF="JavaScript:hhobj_2.Click()">Introduction to Run-Time RPC Functions</A>.</P>

<P>One of the largest areas of difference is in the process model. UNIX has <B>fork</B>; Win32 does not. Depending on the use of <B>fork</B> and the code base, Win32 has two APIs that can be used: <B>CreateProcess</B> and <B>CreateThread</B>. A UNIX application that forks multiple copies of itself can be reworked in Win32 to have either multiple processes or a single process with multiple threads. If multiple processes are used, there are multiple methods of IPC that can be used to communicate between the processes (and perhaps to update the code and data of the new process to be like the parent, if the functionality that <B>fork</B> provides is needed). See <A HREF="JavaScript:hhobj_3.Click()">Creating a New Interprocess (IPC) Message Class</A>.</P>

<P>Windows and UNIX graphical models are very different. UNIX uses the X Window System GUI, while Windows uses GDI. Though similar in concept, there is no simple mapping of the X API to the GDI API. However, OpenGL support is available for migrating UNIX OpenGL-based applications. And there are X clients and X servers for Windows. See <A HREF="JavaScript:hhobj_4.Click()">Graphics Device Interface</A> for information on GDI.</P>

<P>Basic UNIX applications, including many CGI applications, should port easily to Visual C++ running on Windows NT. Functions like <B>open</B>, <B>fopen</B>, <B>read</B>, <B>write</B> and others are available in the Visual C++ run-time library. Also, there is a one-to-one mapping between C UNIX APIs and Win32 APIs: <B>open</B> to <B>CreateFile</B>, <B>read</B> to <B>ReadFile</B>, <B>write</B> to <B>WriteFile</B>, <B>ioctl</B> to <B>DeviceIOControl</B>, <B>close</B> to <B>CloseFile</B>, and so on.</P>
</font>
</BODY>
</HTML>
