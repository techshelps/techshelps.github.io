<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>malloc</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_crt_malloc"></A><SUP></SUP>malloc</H1>

<P>Allocates memory blocks.</P>

<P><B>void</B> <B>*malloc(</B> <B>size_t</B> <I>size</I> <B>);</B></P>

<TABLE border=1 cellpadding=5 cols=3 frame=below rules=rows>

<TR VALIGN="top">
<TD class=label width=16%><B>Routine</B></TD>
<TD class=label width=28%><B>Required Header</B></TD>
<TD class=label width=56%><B>Compatibility</B></TD>
</TR>

<TR VALIGN="top">
<TD width=16%><B>malloc</B></TD>
<TD width=28%>&lt;stdlib.h&gt; and &lt;malloc.h&gt;</TD>
<TD width=56%>ANSI, Win 95, Win NT</TD>
</TR>
</TABLE><BR>

<P>For additional compatibility information, see <A HREF="_crt_compatibility.htm">Compatibility</A> in the Introduction.</P>

<P class=label><B>Libraries</B></P>

<TABLE border=1 cellpadding=5 cols=2 frame=below rules=rows>

<TR VALIGN="top">
<TD width=24%>LIBC.LIB</TD>
<TD width=76%>Single thread static library, retail version</TD>
</TR>

<TR VALIGN="top">
<TD width=24%>LIBCMT.LIB</TD>
<TD width=76%>Multithread static library, retail version</TD>
</TR>

<TR VALIGN="top">
<TD width=24%>MSVCRT.LIB</TD>
<TD width=76%>Import library for MSVCRT.DLL, retail version</TD>
</TR>
</TABLE><BR>

<P class=label><B>Return Value</B></P>

<P><B>malloc</B> returns a void pointer to the allocated space, or <B>NULL</B> if there is insufficient memory available. To return a pointer to a type other than <B>void</B>, use a type cast on the return value. The storage space pointed to by the return value is guaranteed to be suitably aligned for storage of any type of object. If size is 0, <B>malloc</B> allocates a zero-length item in the heap and returns a valid pointer to that item. Always check the return from <B>malloc</B>, even if the amount of memory requested is small.</P>

<P class=label><B>Parameter</B></P>

<P class=dt><I>size</I></P>

<P class=indent>Bytes to allocate</P>

<P class=label><B>Remarks</B></P>

<P>The <B>malloc</B> function allocates a memory block of at least <I>size</I> bytes. The block may be larger than <I>size</I> bytes because of space required for alignment and maintenance information.</P>

<P>The startup code uses <B>malloc</B> to allocate storage for the <B>_environ</B>, <B>envp</B>, and <B>argv</B> variables. The following functions and their wide-character counterparts also call <B>malloc</B>:</P>

<TABLE border=1 cellpadding=5 cols=4 frame=below rules=rows>

<TR VALIGN="top">
<TD width=24%><A HREF="_crt_calloc.htm">calloc</A></TD>
<TD width=17%><A HREF="_crt_fscanf.2c_.fwscanf.htm">fscanf</A></TD>
<TD width=19%><A HREF="_crt__getw.htm">_getw</A></TD>
<TD width=40%><A HREF="_crt_setvbuf.htm">setvbuf</A></TD>
</TR>

<TR VALIGN="top">
<TD width=24%><A HREF="_crt__exec.2c_._wexec_functions.htm">_exec functions</A></TD>
<TD width=17%><A HREF="_crt_fseek.htm">fseek</A></TD>
<TD width=19%><A HREF="_crt__popen.2c_._wpopen.htm">_popen</A></TD>
<TD width=40%><A HREF="_crt__spawn.2c_._wspawn_functions.htm">_spawn functions</A></TD>
</TR>

<TR VALIGN="top">
<TD width=24%><A HREF="_crt_fgetc.2c_.fgetwc.2c_._fgetchar.2c_._fgetwchar.htm">fgetc</A></TD>
<TD width=17%><A HREF="_crt_fsetpos.htm">fsetpos</A></TD>
<TD width=19%><A HREF="_crt_printf.2c_.wprintf.htm">printf</A></TD>
<TD width=40%><A HREF="_crt__strdup.2c_._wcsdup.2c_._mbsdup.htm">_strdup</A></TD>
</TR>

<TR VALIGN="top">
<TD width=24%><A HREF="_crt_fgetc.2c_.fgetwc.2c_._fgetchar.2c_._fgetwchar.htm">_fgetchar</A></TD>
<TD width=17%><A HREF="_crt__fullpath.2c_._wfullpath.htm">_fullpath</A></TD>
<TD width=19%><A HREF="_crt_putc.2c_.putwc.2c_.putchar.2c_.putwchar.htm">putc</A></TD>
<TD width=40%><A HREF="_crt_system.2c_._wsystem.htm">system</A></TD>
</TR>

<TR VALIGN="top">
<TD width=24%><A HREF="_crt_fgets.2c_.fgetws.htm">fgets</A></TD>
<TD width=17%><A HREF="_crt_fwrite.htm">fwrite</A></TD>
<TD width=19%><A HREF="_crt_putc.2c_.putwc.2c_.putchar.2c_.putwchar.htm">putchar</A></TD>
<TD width=40%><A HREF="_crt__tempnam.2c_._wtempnam.2c_.tmpnam.2c_._wtmpnam.htm">_tempnam</A></TD>
</TR>

<TR VALIGN="top">
<TD width=24%><A HREF="_crt_fprintf.2c_.fwprintf.htm">fprintf</A></TD>
<TD width=17%><A HREF="_crt_getc.2c_.getwc.2c_.getchar.2c_.getwchar.htm">getc</A></TD>
<TD width=19%><A HREF="_crt__putenv.2c_._wputenv.htm">_putenv</A></TD>
<TD width=40%><A HREF="_crt_ungetc.2c_.ungetwc.htm">ungetc</A></TD>
</TR>

<TR VALIGN="top">
<TD width=24%><A HREF="_crt_fputc.2c_.fputwc.2c_._fputchar.2c_._fputwchar.htm">fputc</A></TD>
<TD width=17%><A HREF="_crt_getc.2c_.getwc.2c_.getchar.2c_.getwchar.htm">getchar</A></TD>
<TD width=19%><A HREF="_crt_puts.2c_._putws.htm">puts</A></TD>
<TD width=40%><A HREF="_crt_vfprintf.2c_.vfwprintf.htm">vfprintf</A></TD>
</TR>

<TR VALIGN="top">
<TD width=24%><A HREF="_crt_fputc.2c_.fputwc.2c_._fputchar.2c_._fputwchar.htm">_fputchar</A></TD>
<TD width=17%><A HREF="_crt__getcwd.2c_._wgetcwd.htm">_getcwd</A></TD>
<TD width=19%><A HREF="_crt__putw.htm">_putw</A></TD>
<TD width=40%><A HREF="_crt_vprintf.2c_.vwprintf.htm">vprintf</A></TD>
</TR>

<TR VALIGN="top">
<TD width=24%><A HREF="_crt_fputs.2c_.fputws.htm">fputs</A></TD>
<TD width=17%><A HREF="_crt__getcwd.2c_._wgetcwd.htm">_getdcwd</A></TD>
<TD width=19%><A HREF="_crt_scanf.2c_.wscanf.htm">scanf</A></TD>
<TD width=40%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TD width=24%><A HREF="_crt_fread.htm">fread</A></TD>
<TD width=17%><A HREF="_crt_gets.2c_.getws.htm">gets</A></TD>
<TD width=19%><A HREF="_crt__searchenv.2c_._wsearchenv.htm">_searchenv</A></TD>
<TD width=40%>&nbsp;</TD>
</TR>
</TABLE><BR>

<P>The C++ <A HREF="_crt__set_new_mode.htm">_set_new_mode</A> function sets the new handler mode for <B>malloc</B>. The new handler mode indicates whether, on failure, <B>malloc</B> is to call the new handler routine as set by <A HREF="_crt__set_new_handler.htm">_set_new_handler</A>. By default, <B>malloc</B> does not call the new handler routine on failure to allocate memory. You can override this default behavior so that, when <B>malloc</B> fails to allocate memory, <B>malloc</B> calls the new handler routine in the same way that the <B>new</B> operator does when it fails for the same reason. To override the default, call </P>

<PRE><CODE>_set_new_mode(1)
</CODE></PRE>

<P>early in your program, or link with NEWMODE.OBJ.</P>

<P>When the application is linked with a debug version of the C run-time libraries, <B>malloc</B> resolves to <A HREF="_crt__malloc_dbg.htm">_malloc_dbg</A>. For more information about how the heap is managed during the debugging process, see <A HREF="_core_using_c_run.2d.time_library_debugging_support.htm">Using C Run-Time Library Debugging Support</A>.</P>

<P class=label><B>Example</B></P>

<PRE><CODE>/* MALLOC.C: This program allocates memory with
 * malloc, then frees the memory with free.
 */

#include &lt;stdlib.h&gt;         /* For _MAX_PATH definition */
#include &lt;stdio.h&gt;
#include &lt;malloc.h&gt;

void main( void )
{
   char *string;

   /* Allocate space for a path name */
   string = malloc( _MAX_PATH );
   if( string == NULL )
      printf( "Insufficient memory available\n" );
   else
   {
      printf( "Memory space allocated for path name\n" );
      free( string );
      printf( "Memory freed\n" );
   }
}

</CODE></PRE>

<P class=label><B>Output</B></P>

<PRE><CODE>Memory space allocated for path name
Memory freed

</CODE></PRE>

<P><A HREF="_crt_memory_allocation.htm">Memory Allocation Routines</A></P>

<P><B>See Also</B>&nbsp;&nbsp;&nbsp;<A HREF="_crt_calloc.htm">calloc</A>, <A HREF="_crt_free.htm">free</A>, <A HREF="_crt_realloc.htm">realloc</A></P>
</font>
</BODY>
</HTML>
