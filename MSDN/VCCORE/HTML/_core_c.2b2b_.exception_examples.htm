<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>C++ Exception Examples</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>

<TABLE ALIGN=right WIDTH=0 BORDER=0><TR><TD>
<OBJECT ID="hhobj_1" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_vc_addpf_home">
</OBJECT>
</TD></TR></TABLE>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_core_c.2b2b_.exception_examples"></A>C++ Exception Examples</H1>

<P><A HREF="JavaScript:hhobj_1.Click()">Home</A>  |&nbsp; <A HREF="_core_exception_handling.3a_.overview.htm">Overview</A>  |&nbsp; <A HREF="_core_exception_handling_tasks.htm">How Do I</A>  |&nbsp; <A HREF="_core_exception_handling.3a_.frequently_asked_questions.htm">FAQ</A></P>

<P>The real power of C++ exception handling lies not only in its ability to deal with exceptions of varying types, but also in its ability to automatically call destructor functions during stack unwinding for all local objects constructed before the exception was thrown.</P>

<P>The context which exists between the <B>throw</B> site and the <B>catch</B> handler is referred to as the “exception stack frame.” This frame may contain objects with destructor semantics. If an exception is thrown during execution of the guarded section or in any routine the guarded section calls (directly or indirectly), an exception object is created from the object created by the <B>throw</B> operand. (This implies that a copy constructor may be involved.) At this point, the compiler looks for a <B>catch</B> clause in a higher execution context that can handle an exception of the type thrown, or a <B>catch</B> handler that can handle any type of exception. The <B>catch</B> handlers are examined in order of their appearance following the <B>try</B> block. If no appropriate handler is found, the next dynamically enclosing <B>try</B> block is examined. This process continues until the outermost enclosing <B>try</B> block is examined. </P>

<P>If a matching handler is still not found, or if an exception occurs while unwinding but before the handler gets control, the predefined run-time function <B>terminate</B> is called. If an exception occurs after throwing the exception but before the unwind begins, the <B>terminate</B> function is called. You can install a custom termination function to handle such situations. See <A HREF="_core_unhandled_exceptions.htm">Unhandled Exceptions</A> for more information.</P>

<P>The following example demonstrates C++ exception handling using classes with destructor semantics. It declares two C++ classes; one (class <CODE>CTest</CODE>) for defining the exception object itself, and the second (class <CODE>CDtorDemo</CODE>) for demonstrating the destruction of a separate frame object during stack unwinding:</P>

<PRE><CODE>#include &lt;iostream.h&gt;

void MyFunc( void );

class CTest
{
public:
    CTest(){};
    ~CTest(){};
    const char *ShowReason() const { return "Exception in CTest class."; }

};

class CDtorDemo
{
public:
    CDtorDemo();
    ~CDtorDemo();
};

CDtorDemo::CDtorDemo()
{
    cout &lt;&lt; "Constructing CDtorDemo." &lt;&lt; endl;
}

CDtorDemo::~CDtorDemo()
{
    cout &lt;&lt; "Destructing CDtorDemo." &lt;&lt; endl;
}

void MyFunc()
{

    CDtorDemo D;
    cout&lt;&lt; "In MyFunc(). Throwing CTest exception." &lt;&lt; endl;
    throw CTest();
}

int main()
{
    cout &lt;&lt; "In main." &lt;&lt; endl;
    try
    {
        cout &lt;&lt; "In try block, calling MyFunc()." &lt;&lt; endl;
        MyFunc();
    }
    catch( CTest E )
    {
        cout &lt;&lt; "In catch handler." &lt;&lt; endl;
        cout &lt;&lt; "Caught CTest exception type: ";
        cout &lt;&lt; E.ShowReason() &lt;&lt; endl;
    }
    catch( char *str )
    {
        cout &lt;&lt; "Caught some other exception: " &lt;&lt; str &lt;&lt; endl;
    }
    cout &lt;&lt; "Back in main. Execution resumes here." &lt;&lt; endl;
    return 0;

}
</CODE></PRE>

<P>If a matching <B>catch</B> handler is found, and it catches by value, its formal parameter is initialized by copying the exception object. If it catches by reference, the parameter is initialized to refer to the exception object. After the formal parameter is initialized, the process of “unwinding the stack” begins. This involves the destruction of all automatic objects that were constructed (but not yet destructed) between the beginning of the <B>try</B> block associated with the <B>catch</B> handler and the exception’s throw site. Destruction occurs in reverse order of construction. The <B>catch</B> handler is executed and the program resumes execution following the last handler (that is, the first statement or construct that is not a <B>catch</B> handler).</P>

<P>This is the output from the preceding example:</P>

<PRE><CODE>In main.
In try block, calling MyFunc().
Constructing CDtorDemo.
In MyFunc(). Throwing CTest exception.
Destructing CDtorDemo.
In catch handler.
Caught CTest exception type: Exception in CTest class.
Back in main. Execution resumes here.
</CODE></PRE>

<P>Note the declaration of the exception parameter in both <B>catch</B> handlers:</P>

<PRE><CODE>catch( CTest E )
{ // ... }
catch( char *str )
{ // ... }
</CODE></PRE>

<P>You do not need to declare this parameter; in many cases it may be sufficient to notify the handler that a particular type of exception has occurred. However, if you do not declare an exception object in the exception declaration, you will not have access to the object in the <B>catch</B> handler clause. For example:</P>

<PRE><CODE>catch( CTest )
{ 
    // No access to a CTest exception object in this handler.
}
</CODE></PRE>

<P>A <B>throw</B> expression with no operand re-throws the exception currently being handled. Such an expression should appear only in a <B>catch</B> handler or in a function called from within a <B>catch</B> handler. The re-thrown exception object is the original exception object (not a copy). For example:</P>

<PRE><CODE>try
{
    throw CSomeOtherException();
}
catch(...)      // Handle all exceptions
{
    // Respond (perhaps only partially) to exception
    //...

    throw;      // Pass exception to some other handler
}
</CODE></PRE>
</font>
</BODY>
</HTML>
