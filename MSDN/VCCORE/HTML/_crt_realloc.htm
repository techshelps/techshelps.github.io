<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>realloc</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_crt_realloc"></A><SUP></SUP>realloc</H1>

<P>Reallocate memory blocks.</P>

<P><B>void</B> <B>*realloc(</B> <B>void</B> <B>*</B><I>memblock</I><B>,</B> <B>size_t</B> <I>size</I> <B>);</B></P>

<TABLE border=1 cellpadding=5 cols=3 frame=below rules=rows>

<TR VALIGN="top">
<TD class=label width=15%><B>Routine</B></TD>
<TD class=label width=26%><B>Required Header</B></TD>
<TD class=label width=59%><B>Compatibility</B></TD>
</TR>

<TR VALIGN="top">
<TD width=15%><B>realloc</B></TD>
<TD width=26%>&lt;stdlib.h&gt; and &lt;malloc.h&gt;</TD>
<TD width=59%>ANSI, Win 95, Win NT</TD>
</TR>
</TABLE><BR>

<P>For additional compatibility information, see <A HREF="_crt_compatibility.htm">Compatibility</A> in the Introduction.</P>

<P class=label><B>Libraries</B></P>

<TABLE border=1 cellpadding=5 cols=2 frame=below rules=rows>

<TR VALIGN="top">
<TD width=24%>LIBC.LIB</TD>
<TD width=76%>Single thread static library, retail version</TD>
</TR>

<TR VALIGN="top">
<TD width=24%>LIBCMT.LIB</TD>
<TD width=76%>Multithread static library, retail version</TD>
</TR>

<TR VALIGN="top">
<TD width=24%>MSVCRT.LIB</TD>
<TD width=76%>Import library for MSVCRT.DLL, retail version</TD>
</TR>
</TABLE><BR>

<P class=label><B>Return Value</B></P>

<P><B>realloc</B> returns a <B>void</B> pointer to the reallocated (and possibly moved) memory block. The return value is <B>NULL</B> if the size is zero and the buffer argument is not <B>NULL</B>, or if there is not enough available memory to expand the block to the given size. In the first case, the original block is freed. In the second, the original block is unchanged. The return value points to a storage space that is guaranteed to be suitably aligned for storage of any type of object. To get a pointer to a type other than <B>void</B>, use a type cast on the return value.</P>

<P class=label><B>Parameters</B></P>

<P class=dt><I>memblock</I></P>

<P class=indent>Pointer to previously allocated memory block</P>

<P class=dt><I>size</I></P>

<P class=indent>New size in bytes</P>

<P class=label><B>Remarks</B></P>

<P>The <B>realloc</B> function changes the size of an allocated memory block. The <I>memblock</I> argument points to the beginning of the memory block. If <I>memblock</I> is <B>NULL</B>, <B>realloc</B> behaves the same way as <B>malloc</B> and allocates a new block of <I>size</I> bytes. If <I>memblock</I> is not <B>NULL</B>, it should be a pointer returned by a previous call to <B>calloc</B>, <B>malloc</B>, or <B>realloc</B>.</P>

<P>The <I>size</I> argument gives the new size of the block, in bytes. The contents of the block are unchanged up to the shorter of the new and old sizes, although the new block can be in a different location. Because the new block can be in a new memory location, the pointer returned by <B>realloc</B> is not guaranteed to be the pointer passed through the <I>memblock</I> argument.</P>

<P><B>realloc </B>calls <B>malloc </B>in order to use the C++ <A HREF="_crt__set_new_mode.htm">_set_new_mode</A> function to set the new handler mode. The new handler mode indicates whether, on failure, <B>malloc</B> is to call the new handler routine as set by <A HREF="_crt__set_new_handler.htm">_set_new_handler</A>. By default, <B>malloc</B> does not call the new handler routine on failure to allocate memory. You can override this default behavior so that, when <B>realloc</B> fails to allocate memory, <B>malloc</B> calls the new handler routine in the same way that the <B>new</B> operator does when it fails for the same reason. To override the default, call </P>

<PRE><CODE>_set_new_mode(1)
</CODE></PRE>

<P>early in your program, or link with NEWMODE.OBJ.</P>

<P>When the application is linked with a debug version of the C run-time libraries, <B>realloc</B> resolves to <A HREF="_crt__realloc_dbg.htm">_realloc_dbg</A>. For more information about how the heap is managed during the debugging process, see <A HREF="_core_using_c_run.2d.time_library_debugging_support.htm">Using C Run-Time Library Debugging Support</A>.</P>

<P class=label><B>Example</B></P>

<PRE><CODE>/* REALLOC.C: This program allocates a block of memory for
 * buffer and then uses _msize to display the size of that
 * block. Next, it uses realloc to expand the amount of
 * memory used by buffer and then calls _msize again to
 * display the new amount of memory allocated to buffer.
 */

#include &lt;stdio.h&gt;
#include &lt;malloc.h&gt;
#include &lt;stdlib.h&gt;

void main( void )
{
   long *buffer;
   size_t size;

   if( (buffer = (long *)malloc( 1000 * sizeof( long ) )) == NULL )
      exit( 1 );

   size = _msize( buffer );
   printf( "Size of block after malloc of 1000 longs: %u\n", size );

   /* Reallocate and show new size: */
   if( (buffer = realloc( buffer, size + (1000 * sizeof( long )) )) 
        ==  NULL )
      exit( 1 );
   size = _msize( buffer );
   printf( "Size of block after realloc of 1000 more longs: %u\n", 
            size );

   free( buffer );
   exit( 0 );
}

</CODE></PRE>

<P class=label><B>Output</B></P>

<PRE><CODE>Size of block after malloc of 1000 longs: 4000
Size of block after realloc of 1000 more longs: 8000

</CODE></PRE>

<P><A HREF="_crt_memory_allocation.htm">Memory Allocation Routines</A></P>

<P><B>See Also</B>&nbsp;&nbsp;&nbsp;<A HREF="_crt_calloc.htm">calloc</A>, <A HREF="_crt_free.htm">free</A>, <A HREF="_crt_malloc.htm">malloc</A></P>
</font>
</BODY>
</HTML>
