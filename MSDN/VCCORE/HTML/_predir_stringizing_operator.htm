<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Stringizing Operator (#)</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_predir_stringizing_operator"></A><SUP></SUP>Stringizing Operator (#)</H1>

<P>The number-sign or “stringizing” operator (<B>#</B>) converts macro parameters (after expansion) to string constants. It is used only with macros that take arguments. If it precedes a formal parameter in the macro definition, the actual argument passed by the macro invocation is enclosed in quotation marks and treated as a string literal. The string literal then replaces each occurrence of a combination of the stringizing operator and formal parameter within the macro definition.</P>

<P>White space preceding the first token of the actual argument and following the last token of the actual argument is ignored. Any white space between the tokens in the actual argument is reduced to a single white space in the resulting string literal. Thus, if a comment occurs between two tokens in the actual argument, it is reduced to a single white space. The resulting string literal is automatically concatenated with any adjacent string literals from which it is separated only by white space. </P>

<P>Further, if a character contained in the argument usually requires an escape sequence when used in a string literal (for example, the quotation mark (<B>"</B>) or backslash (<B>\</B>) character), the necessary escape backslash is automatically inserted before the character. The following example shows a macro definition that includes the stringizing operator and a main function that invokes the macro:</P>

<PRE><CODE>#define stringer( x ) printf( #x "\n" )

void main()
{
    stringer( In quotes in the printf function call\n ); 
    stringer( "In quotes when printed to the screen"\n );   
    stringer( "This: \"  prints an escaped double quote" );
}
</CODE></PRE>

<P>Such invocations would be expanded during preprocessing, producing the following code:</P>

<PRE><CODE>void main()
{
   printf( "In quotes in the printf function call\n" "\n" );
   printf( "\"In quotes when printed to the screen\"\n" "\n" );
   printf( "\"This: \\\" prints an escaped double quote\"" "\n" );
}
</CODE></PRE>

<P>When the program is run, screen output for each line is as follows:</P>

<PRE><CODE>In quotes in the printf function call

"In quotes when printed to the screen"

"This: \" prints an escaped double quotation mark"
</CODE></PRE>

<P><B>Microsoft Specific </B></P>

<P>The Microsoft C (versions 6.0 and earlier) extension to the ANSI C standard that previously expanded macro formal arguments appearing inside string literals and character constants is no longer supported. Code that relied on this extension should be rewritten using the stringizing (<B>#</B>) operator.</P>

<P><B>END Microsoft Specific</B></P>
</font>
</BODY>
</HTML>
