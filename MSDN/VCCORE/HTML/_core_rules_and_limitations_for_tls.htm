<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Rules and Limitations for TLS</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>

<TABLE ALIGN=right WIDTH=0 BORDER=0><TR><TD>
<OBJECT ID="hhobj_1" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_win32_LoadLibrary">
</OBJECT>
<OBJECT ID="hhobj_2" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_win32_TlsAlloc">
</OBJECT>
</TD></TR></TABLE>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_core_rules_and_limitations_for_tls"></A>Rules and Limitations for TLS</H1>

<P>The following guidelines must be observed when declaring statically bound thread local objects and variables:

<UL type=disc>
	<LI>The <B>thread</B> attribute can be applied only to data declarations and definitions. It cannot be used on function declarations or definitions. For example, the following code will generate a compiler error:
<PRE><CODE>#define Thread  __declspec( thread )
Thread void func();     // This will generate an error.
</CODE></PRE>
</LI>

	<LI>The <B>thread</B> modifier may be specified only on data items with <B>static</B> extent. This includes global data objects (both <B>static</B> and <B>extern</B>), local static objects, and static data members of C++ classes. Automatic data objects may not be declared with the <B>thread</B> attribute. The following code will generate compiler errors:
<PRE><CODE>#define Thread  __declspec( thread )
void func1()
{
    Thread int tls_i;            // This will generate an error.
}

int func2( Thread int tls_i )    // This will generate an error.
{
    return tls_i;
}
</CODE></PRE>
</LI>

	<LI>The declarations and the definition of a thread local object must all specify the <B>thread</B> attribute. For example, the following code will generate an error:
<PRE><CODE>#define Thread  __declspec( thread )
extern int tls_i;        // This will generate an error, since the
int Thread tls_i;        // declaration and definition differ.
</CODE></PRE>
</LI>

	<LI>The <B>thread</B> attribute cannot be used as a type modifier. For example, the following code will generate a compiler error:
<PRE><CODE>char __declspec( thread ) *ch;        // Error
</CODE></PRE>
</LI>

	<LI>C++ classes cannot use the <B>thread</B> attribute. However, C++ class objects may be instantiated with the <B>thread</B> attribute. For example, the following code will generate a compiler error:
<PRE><CODE>#define Thread  __declspec( thread )
class Thread C       // Error: classes cannot be declared Thread.
{
// Code
};
C CObject;
</CODE></PRE>

<P class=tl>Because the declaration of C++ objects that utilize the <B>thread</B> attribute is permitted, the following two examples are semantically equivalent:</P>
<PRE><CODE>#define Thread  __declspec( thread )
Thread class B
{
// Code
} BObject;               // OK--BObject is declared thread local.

class B
{
// Code
};
Thread B BObject;        // OK--BObject is declared thread local.
</CODE></PRE>
</LI>

	<LI>Because C++ objects with constructors and destructors (as well as any object that utilizes some form of initialization semantics) may be allocated as thread local objects, an associated initialization routine (such as the constructor) is called to initialize that object. For example:
<PRE><CODE>class tlsClass
{
    private:
        int x;
    public:
        tlsClass() { x = 1; } ;
        ~tlsClass();
}

__declspec( thread ) tlsClass tlsObject;
extern int func();
__declspec( thread ) int y = func();
</CODE></PRE>

<P class=tl>In this case, data or objects initialized by the <CODE>func</CODE> routine do not necessarily belong to the same thread into which <CODE>tlsObject</CODE> is instantiated.</P></LI>

	<LI>The address of a thread local object is not considered constant, and any expression involving such an address is not considered a constant expression. In standard C, the effect of this is to forbid the use of the address of a thread local variable as an initializer for an object or pointer. For example, the following code will be flagged as an error by the C compiler:
<PRE><CODE>#define Thread  __declspec( thread )
Thread int tls_i;
int *p = &amp;tls_i;        //This will generate an error in C.
</CODE></PRE>

<P class=tl>This restriction does not apply in C++, however. Because C++ permits dynamic initialization of all objects, you can initialize an object with an expression that uses the address of a thread local variable. This is accomplished in the same way as the construction of thread local objects. For example, the code shown above will not generate an error when compiled as a C++ source file. Note that the address of a thread local variable is valid only as long as the thread in which the address was taken still exists.</P></LI>

	<LI>Standard C permits the initialization of an object or variable with an expression involving a reference to itself, but only for objects of nonstatic extent. Although C++ normally permits such dynamic initialization of objects with an expression involving a reference to itself, this type of initialization is not permitted with thread local objects. For example:
<PRE><CODE>#define Thread  __declspec( thread )
Thread int tls_i = tls_i;                // Error in C and C++ 
int j = j;                               // OK in C++, error in C
Thread int tls_i = sizeof( tls_i )       // Legal in C and C++
</CODE></PRE>

<P class=tl>Note that a <CODE>sizeof</CODE> expression that includes the object being initialized does not constitute a reference to itself, and is legal in both C and C++.</P>
<P class=tl>C++ does not allow such dynamic initialization of thread data because of possible future enhancements to the thread local storage facility.</P></LI>

	<LI>If a DLL declares any nonlocal data or object as <B>__declspec</B>( thread ), it can cause a protection fault if dynamically loaded. After the DLL is loaded with <A HREF="JavaScript:hhobj_1.Click()">LoadLibrary</A>, it causes system failure whenever the code references the nonlocal <B>__declspec</B>( thread ) data. Because the global variable space for a thread is allocated at run time, the size of this space is based on a calculation of the requirements of the application plus the requirements of all of the DLLs that are statically linked. When you use <B>LoadLibrary</B>, there is no way to extend this space to allow for the thread local variables declared with <B>__declspec</B>( thread ). Use the TLS APIs, such as <A HREF="JavaScript:hhobj_2.Click()">TlsAlloc</A>, in your DLL to allocate TLS if the DLL might be loaded with <B>LoadLibrary</B>.</LI>
</UL>
</font>
</BODY>
</HTML>
