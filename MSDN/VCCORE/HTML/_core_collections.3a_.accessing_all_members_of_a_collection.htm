<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Collections: Accessing All Members of a Collection</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>

<TABLE ALIGN=right WIDTH=0 BORDER=0><TR><TD>
<OBJECT ID="hhobj_1" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_vc_addpf_home">
</OBJECT>
<OBJECT ID="hhobj_2" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_Sample_mfc_collect">
</OBJECT>
<OBJECT ID="hhobj_3" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="Scribble start">
</OBJECT>
</TD></TR></TABLE>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_core_collections.3a_.accessing_all_members_of_a_collection"></A>Collections: Accessing All Members of a Collection</H1>

<P><A HREF="JavaScript:hhobj_1.Click()">Home</A>  |&nbsp; <A HREF="_core_collections.2c_.working_with_aggregate_data.3a_.overview.htm">Overview</A>  |&nbsp; <A HREF="_core_collection_class_tasks.htm">How Do I</A>  |&nbsp; <A HREF="JavaScript:hhobj_2.Click()">Sample</A>  |&nbsp; <A HREF="JavaScript:hhobj_3.Click()">Tutorial</A></P>

<P>The MFC array collection classes — both template-based and not — use indexes to access their elements. The MFC list and map collection classes — both template-based and not — use an indicator of type <B>POSITION</B> to describe a given position within the collection. To access one or more members of these collections, you first initialize the position indicator and then repeatedly pass that position to the collection and ask it to return the next element. The collection is not responsible for maintaining state information about the progress of the iteration. That information is kept in the position indicator. But, given a particular position, the collection is responsible for returning the next element.</P>

<P>The following procedures show how to iterate over the three main types of collections provided with MFC:

<UL type=disc>
	<LI><A HREF="#_core_to_iterate_an_array">Iterating an array</A><BR><BR></LI>

	<LI><A HREF="#_core_to_iterate_a_list">Iterating a list</A><BR><BR></LI>

	<LI><A HREF="#_core_to_iterate_a_map">Iterating a map</A></LI>
</UL>

<P class=label><B><A NAME="_core_to_iterate_an_array"></A>To iterate an array</B>

<UL type=disc>
	<LI>Use sequential index numbers with the <B>GetAt</B> member function:
<PRE><CODE>CTypedPtrArray&lt;CObArray, CPerson*&gt; myArray;

for( int i = 0; i &lt; myArray.GetSize();i++ )
{
    CPerson* thePerson = myArray.GetAt( i );
    ...
}
</CODE></PRE>

<P class=tl>This example uses a typed pointer array that contains pointers to <CODE>CPerson</CODE> objects. The array is derived from class <B>CObArray</B>, one of the nontemplate predefined classes. <B>GetAt</B> returns a pointer to a <CODE>CPerson</CODE> object. For typed pointer collection classes — arrays or lists — the first parameter specifies the base class; the second parameter specifies the type to store.</P>
<P class=tl>The <B>CTypedPtrArray</B> class also overloads the <B>[</B> <B>]</B> operator so that you can use the customary array-subscript syntax to access elements of an array. An alternative to the statement in the body of the <CODE>for</CODE> loop above is</P>
<PRE><CODE>CPerson* thePerson = myArray[ i ];
</CODE></PRE>

<P class=tl>This operator exists in both <B>const</B> and non-<B>const</B> versions. The <B>const</B> version, which is invoked for <B>const</B> arrays, can appear only on the right side of an assignment statement.</P></LI>
</UL>

<P class=label><B><A NAME="_core_to_iterate_a_list"></A>To iterate a list</B>

<UL type=disc>
	<LI>Use the member functions <B>GetHeadPosition</B> and <B>GetNext</B> to work your way through the list:
<PRE><CODE>CTypedPtrList&lt;CObList, CPerson*&gt; myList;

POSITION pos = myList.GetHeadPosition();
while( pos != NULL )
{
    CPerson* thePerson = myList.GetNext( pos );
    ...
}
</CODE></PRE>

<P class=tl>This example uses a typed pointer list to contain pointers to <CODE>CPerson</CODE> objects. The list declaration resembles the one for the array in the procedure <A HREF="#_core_to_iterate_an_array">To iterate an array</A> but is derived from class <B>CObList</B>. <B>GetNext</B> returns a pointer to a <CODE>CPerson</CODE> object.</P></LI>
</UL>

<P class=label><B><A NAME="_core_to_iterate_a_map"></A>To iterate a map</B>

<UL type=disc>
	<LI>Use <B>GetStartPosition</B> to get to the beginning of the map and <B>GetNextAssoc</B> to repeatedly get the next key and value from the map, as shown by the following example:
<PRE><CODE>CMap&lt;CString, LPCTSTR, CPerson*, CPerson*&gt; myMap;

POSITION pos = myMap.GetStartPosition();
while( pos != NULL )
{
    CPerson* pPerson;
    CString string;
    // Get key ( string ) and value ( pPerson )
    myMap.GetNextAssoc( pos, string, pPerson );
    // Use string and pPerson
}
</CODE></PRE>

<P class=tl>This example uses a simple map template (rather than a typed pointer collection) that uses <B>CString</B> keys and stores pointers to <CODE>CPerson</CODE> objects. When you use access functions such as <B>GetNextAssoc</B>, the class provides pointers to <CODE>CPerson</CODE> objects. If you use one of the nontemplate map collections instead, you must cast the returned <B>CObject</B> pointer to a pointer to a <CODE>CPerson</CODE>. </P>
<P class=atl><B><B>Note&nbsp;&nbsp;&nbsp;</B></B>For nontemplate maps, the compiler requires a reference to a <B>CObject</B> pointer in the last parameter to <B>GetNextAssoc</B>. On input, you must cast your pointers to that type, as shown in the next example.</p>
<P class=tl>The template solution is simpler and provides better type safety. The nontemplate code is more complicated, as you can see here:</P>
<PRE><CODE>CMapStringToOb myMap;    // A nontemplate collection class

POSITION pos = myMap.GetStartPosition( );
while( pos != NULL )
{
    CPerson* pPerson;
    CString string;
    // Gets key (string) and value (pPerson)
    myMap.GetNextAssoc( pos, string, 
                            (CObject*&amp;)pPerson );
    ASSERT( pPerson-&gt;IsKindOf( 
                 RUNTIME_CLASS( CPerson ) ) );
    // Use string and pPerson
}
</CODE></PRE>
</LI>
</UL>

<P>For related information, see <A HREF="_core_collections.3a_.deleting_all_objects_in_a_cobject_collection.htm">Collections: Deleting All Objects in a CObject Collection</A>. </P>
</font>
</BODY>
</HTML>
