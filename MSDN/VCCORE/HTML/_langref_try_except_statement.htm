<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>try-except Statement</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_langref_try_except_statement"></A><SUP></SUP>try-except Statement</H1>

<P><B>Microsoft Specific —&gt;</B></P>

<P>The <B>try-except</B> statement is a Microsoft extension to the C and C++ languages that enables 32-bit target applications to gain control when events that normally terminate program execution occur. Such events are called exceptions, and the mechanism that deals with exceptions is called structured exception handling.</P>

<P>For related information, see the <A HREF="_langref_try_finally_statement.htm">try-finally statement</A>. For more information on structured exception handling in general, see <A HREF="_core_exception_handling_topics_.28.seh.29.htm">Exception Handling Topics (SEH)</A>. </P>

<P>Exceptions can be either hardware-based or software-based. Even when applications cannot completely recover from hardware or software exceptions, structured exception handling makes it possible to display error information and trap the internal state of the application to help diagnose the problem. This is especially useful for intermittent problems that cannot be reproduced easily.</P>

<P class=indent><B><B>Note</B></B>&nbsp;&nbsp;&nbsp;Structured exception handling works with Win32 for both C and C++ source files. However, it is not specifically designed for C++. You can ensure that your code is more portable by using C++ exception handling. Also, C++ exception handling is more flexible, in that it can handle exceptions of any type. For C++ programs, it is recommended that you use the new C++ exception-handling mechanism (<A HREF="_langref_try.2c_.catch.2c_.and_throw_statements.htm">try, catch, and throw</A> statements). </P>

<P><I>try-except-statement</I> :<BR>
<B>__try</B> <I>compound-statement</I><BR>
<B>__except</B> ( <I>expression</I> ) <I>compound-statement</I></P>

<P>The compound statement after the <B>__try</B> clause is the body or guarded section. The compound statement after the <B>__except</B> clause is the exception handler. The handler specifies a set of actions to be taken if an exception is raised during execution of the body of the guarded section. Execution proceeds as follows:

<OL>
	<LI>The guarded section is executed.<BR><BR></LI>

	<LI>If no exception occurs during execution of the guarded section, execution continues at the statement after the <B>__except</B> clause.<BR><BR></LI>

	<LI>If an exception occurs during execution of the guarded section or in any routine the guarded section calls, the <B>__except</B> expression is evaluated and the value determines how the exception is handled. There are three values:
<P class=tl><B>EXCEPTION_CONTINUE_EXECUTION (–1)</B>&nbsp;&nbsp;&nbsp;Exception is dismissed. Continue execution at the point where the exception occurred.</P>
<P class=tl><B>EXCEPTION_CONTINUE_SEARCH (0)</B>&nbsp;&nbsp;&nbsp;Exception is not recognized. Continue to search up the stack for a handler, first for containing <B>try-except</B> statements, then for handlers with the next highest precedence.</P>
<P class=tl><B>EXCEPTION_EXECUTE_HANDLER (1)</B>&nbsp;&nbsp;&nbsp;Exception is recognized. Transfer control to the exception handler by executing the <B>__except</B> compound statement, then continue execution at the assembly instruction that was executing when the exception was raised. </P></LI>
</OL>

<P>Because the __<B>except</B> expression is evaluated as a C expression, it is limited to a single value, the conditional-expression operator, or the comma operator. If more extensive processing is required, the expression can call a routine that returns one of the three values listed above. </P>

<P>Each application can have its own exception handler. The <B>__except</B> expression executes in the scope of the <B>__try</B> body. This means it has access to any local variables declared there.</P>

<P>It is illegal to jump into a <B>__try</B> statement, but legal to jump out of one. The exception handler is not called if a process is killed in the middle of executing a <B>try-except</B> statement.</P>

<P class=label><B>Structured Exception Handling Intrinsic Functions</B></P>

<P>The structured exception handling feature provides two intrinsics that are available for use with the <B>try-except</B> statement. These are <B>_exception_code</B> and <B>_exception_info</B>.</P>

<P>The intrinsic function <B>_exception_code</B> returns the code (a 32-bit integer) of the exception.</P>

<P>The intrinsic function <B>_exception_info</B> returns a pointer to a structure containing additional information about the exception. Through this pointer, you can access the machine state that existed at the time of a hardware exception. The structure is as follows:</P>

<PRE><CODE>struct exception_pointers {
      EXCEPTION_RECORD *ExceptionRecord,
      CONTEXT *ContextRecord }</CODE></PRE>

<P>The pointer types _<B>EXCEPTION_RECORD</B> and _<B>CONTEXT</B> are defined in the include file EXCPT.H.</P>

<P>You can use the _<B>exception_code</B> function within the exception handler. However, you can use _<B>exception_info</B> only within the exception filter. The information it points to is generally on the stack and is wiped out when control is transferred to the exception handler.</P>

<P>The intrinsic function _<B>abnormal_termination</B> is available within a termination handler. It returns 0 if the body of the <B>try-finally</B> statement terminates sequentially. In all other cases, it returns 1.</P>

<P><B>END Microsoft Specific</B></P>

<P class=label><B>Example</B></P>

<PRE><CODE>// Example of try-except and try-finally statements
#include "stdio.h"

void main()
{
   int* p = 0x00000000;   // pointer to NULL
   puts("hello");
   try{
      puts("in try");
      try{
         puts("in try");
         *p = 13;    // causes an access violation exception;
      }__finally{
         puts("in finally");
      }
   }__except(puts("in filter"), 1){
      puts("in except");
   }
   puts("world");
}</CODE></PRE>

<P>This is the output from the example, with commentary added on the right:</P>

<PRE><CODE>hello
in try         //fall into try
in try         //fall into nested try
in filter      //execute filter; returns 1 so accept
in finally     //unwind nested finally
in except      //transfer control to selected handler
world          //flow out of handler</CODE></PRE>
</font>
</BODY>
</HTML>
