<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Connection Points</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>

<TABLE ALIGN=right WIDTH=0 BORDER=0><TR><TD>
<OBJECT ID="hhobj_1" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_vc_addpf_home">
</OBJECT>
<OBJECT ID="hhobj_2" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_mfc_CConnectionPoint">
</OBJECT>
<OBJECT ID="hhobj_3" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_mfc_CCmdTarget">
</OBJECT>
</TD></TR></TABLE>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_core_connection_points"></A>Connection Points</H1>

<P><A HREF="JavaScript:hhobj_1.Click()">Home</A></P>

<P>This article explains how to implement connection points (formerly known as OLE connection points) using <B>CCmdTarget</B> and <B>CConnectionPoint</B>.</P>

<P>In the past, the Component Object Model (COM) defined a general mechanism (<B>IUnknown::QueryInterface</B>) that allowed objects to implement and expose functionality in interfaces. However, a corresponding mechanism that allowed objects to expose their capability to call specific interfaces was not defined. That is, COM defined how incoming pointers to objects (pointers to that object’s interfaces) were handled, but it did not have an explicit model for outgoing interfaces (pointers the object holds to other objects’ interfaces). COM now has a model, called connection points, that supports this functionality.</P>

<P>A connection has two parts: the object calling the interface, called the source, and the object implementing the interface, called the sink. A connection point is the interface exposed by the source. By exposing a connection point, a source allows sinks to establish connections to itself (the source). Through the connection point mechanism (the <B>IConnectionPoint </B>interface), a pointer to the sink interface is passed to the source object. This pointer provides the source with access to the sink’s implementation of a set of member functions. For example, to fire an event implemented by the sink, the source can call the appropriate method of the sink’s implementation. The following figure demonstrates the connection point just described.</P>

<P class=label><B>An Implemented Connection Point</B></P>

<P><IMG SRC="mconpt.gif" ALT="" BORDER=0></P>

<P>MFC implements this model in the <A HREF="JavaScript:hhobj_2.Click()">CConnectionPoint</A> and <A HREF="JavaScript:hhobj_3.Click()">CCmdTarget</A> classes. Classes derived from <B>CConnectionPoint </B>implement the <B>IConnectionPoint</B> interface, used to expose connection points to other objects. Classes derived from <B>CCmdTarget</B> implement the <B>IConnectionPointContainer</B> interface, which can enumerate all of an object’s available connection points or find a specific connection point.</P>

<P>For each connection point implemented in your class, you must declare a connection part that implements the connection point. If you implement one or more connection points, you must also declare a single connection map in your class. A connection map is a table of connection points supported by the ActiveX control.</P>

<P>The following examples demonstrate a simple connection map and one connection point. The first example declares the connection map and point; the second example implements the map and point. Note that <CODE>CMyClass </CODE>must be a <B>CCmdTarget</B>-derived class. In the first example, code is inserted in the class declaration, under the <B>protected </B>section:</P>

<PRE><CODE>class CMyClass : public CCmdTarget
{
 ...
 protected:
// Connection point for ISample interface
    BEGIN_CONNECTION_PART(CMyClass, SampleConnPt)
        CONNECTION_IID(IID_ISampleSink)
    END_CONNECTION_PART(SampleConnPt)

    DECLARE_CONNECTION_MAP()

};
</CODE></PRE>

<P>The <B>BEGIN_CONNECTION_PART</B> and <B>END_CONNECTION_PART </B>macros declare an embedded class, <CODE>XSampleConnPt</CODE> (derived from <B>CConnectionPoint</B>) that implements this particular connection point. If you want to override any <B>CConnectionPoint</B> member functions or add member functions of your own, declare them between these two macros. For example, the <B>CONNECTION_IID</B> macro overrides the <B>CConnectionPoint::GetIID</B> member function when placed between these two macros.</P>

<P>In the second example, code is inserted in the control’s implementation file (.CPP). This code implements the connection map, which includes the connection point, <CODE>SampleConnPt</CODE>:</P>

<PRE><CODE>BEGIN_CONNECTION_MAP(CMyClass, CMyBaseClass)
    CONNECTION_PART(CMyClass, IID_ISampleSink, SampleConnPt)
END_CONNECTION_MAP()
</CODE></PRE>

<P>If your class has more than one connection point, insert additional <B>CONNECTION_PART</B> macros between the <B>BEGIN_CONNECTION_MAP</B> and <B>END_CONNECTION_MAP</B> macros.</P>

<P>Finally, add a call to <B>EnableConnections</B> in the class’s constructor. For example:</P>

<PRE><CODE>CMyClass::CMyClass()
{
EnableConnections();
...
}
</CODE></PRE>

<P>Once this code has been inserted, your <B>CCmdTarget</B>-derived class exposes a connection point for the <B>ISampleSink </B>interface. The following figure illustrates this example.</P>

<P class=label><B>A Connection Point Implemented with MFC</B></P>

<P><IMG SRC="mconxn.gif" ALT="" BORDER=0></P>

<P>Usually, connection points support “multicasting” — the ability to broadcast to multiple sinks connected to the same interface. The following example fragment demonstrates how to multicast by iterating through each sink on a connection point:</P>

<PRE><CODE>void CMyClass::CallSinkFunc()
{
    const CPtrArray* pConnections = m_xSampleConnPt.GetConnections();
    ASSERT(pConnections != NULL);

    int cConnections = pConnections-&gt;GetSize();
    ISampleSink* pSampleSink;
    for (int i = 0; i &lt; cConnections; i++)
    {
        pSampleSink = (ISampleSink*)(pConnections-&gt;GetAt(i));
        ASSERT(pSampleSink != NULL);
        pSampleSink-&gt;SinkFunc();
    }
}
</CODE></PRE>

<P>This example retrieves the current set of connections on the <CODE>SampleConnPt</CODE> connection point with a call to <B>CConnectionPoint::GetConnections</B>. It then iterates through the connections and calls <B>ISampleSink::SinkFunc</B> on every active connection.</P>
</font>
</BODY>
</HTML>
