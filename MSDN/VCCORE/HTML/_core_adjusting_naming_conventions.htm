<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Adjusting Naming Conventions</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>

<TABLE ALIGN=right WIDTH=0 BORDER=0><TR><TD>
<OBJECT ID="hhobj_1" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_vc_addpf_home">
</OBJECT>
</TD></TR></TABLE>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_core_adjusting_naming_conventions"></A>Adjusting Naming Conventions</H1>

<P><A HREF="JavaScript:hhobj_1.Click()">Home</A>  |&nbsp; <A HREF="_core_mixed.2d.language_programming.3a_.overview.htm">Overview</A>  |&nbsp; <A HREF="_core_mixed.2d.language_programming_tasks.htm">How Do I</A></P>

<P>The naming convention determines how a language alters a symbol name as it places the name in an .OBJ file. This is an issue for external data symbols shared between modules as well as for external routines. Parameter names are never affected. The reasons for altering the name include case sensitivity or lack thereof, type decoration, and other issues. Note that you can always see exactly how a name has been placed in an .OBJ file by using the DUMPBIN utility with the /SYMBOLS option. If naming conventions are not reconciled, the program cannot successfully link. You will receive an “unresolved external” error.</P>

<P>Naming conventions are closely related to calling conventions because the keywords that specify calling conventions affect naming conventions as well. However, C/C++ preserves case sensitivity in its symbol tables and Fortran does not, which can necessitate some additional work on your part. Fortunately, you can use the Fortran <B>ALIAS</B> attribute to resolve any discrepancy in names.</P>

<P>The following table summarizes how C, Fortran, and C++ handle public names.</P>

<P class=label><B>Naming Conventions in C</B>, <B>Fortran, and C++</B></P>

<TABLE border=1 cellpadding=5 cols=3 frame=below rules=rows>

<TR VALIGN="top">
<TD class=label width=28%><B>Language</B></TD>
<TD class=label width=33%><B>Name translated as</B></TD>
<TD class=label width=39%><B>Case of name in OBJ file</B></TD>
</TR>

<TR VALIGN="top">
<TD width=28%>C, <B>cdecl</B> (default)</TD>
<TD width=33%><B>_</B><I>name</I></TD>
<TD width=39%>Mixed case preserved</TD>
</TR>

<TR VALIGN="top">
<TD width=28%>C, <B>__stdcall</B></TD>
<TD width=33%><B>_</B><I>name</I><B>@</B><I>nn</I></TD>
<TD width=39%>Mixed case preserved</TD>
</TR>

<TR VALIGN="top">
<TD width=28%>Fortran [C]</TD>
<TD width=33%><B>_</B><I>name</I></TD>
<TD width=39%>All lowercase</TD>
</TR>

<TR VALIGN="top">
<TD width=28%>Fortran [STDCALL]</TD>
<TD width=33%><B>_</B><I>name</I><B>@</B><I>nn</I></TD>
<TD width=39%>All lowercase</TD>
</TR>

<TR VALIGN="top">
<TD width=28%>Fortran default</TD>
<TD width=33%><B>_</B><I>name</I><B>@</B><I>nn</I></TD>
<TD width=39%>All uppercase</TD>
</TR>

<TR VALIGN="top">
<TD width=28%>C++</TD>
<TD width=33%><B>_</B><I>name</I><B>@@</B><I>decoration</I></TD>
<TD width=39%>Mixed case preserved</TD>
</TR>
</TABLE><BR>

<P>In the previous table, <I>nn</I> represents the stack space, in decimal notation, occupied by parameters. For example, assume a function is declared in C as</P>

<PRE><CODE>extern int __stdcall Sum_Up( int a, int b, int c );
</CODE></PRE>

<P>Each integer occupies 4 bytes, so the symbol name placed in the .OBJ file is:</P>

<PRE><CODE>_Sum_Up@12
</CODE></PRE>

<P>Case sensitivity can present a problem. The 32-bit linker always distinguishes case. The strategy you use to handle a discrepancy due to case depends on whether the situation involves:

<UL type=disc>
	<LI>Calls from C to Fortran, where Fortran cannot be recompiled<BR><BR></LI>

	<LI><A HREF="#_core_all.2d.lowercase_names">Symbol names that are all lowercase</A><BR><BR></LI>

	<LI><A HREF="#_core_mixed.2d.case_names">Mixed-case names</A></LI>
</UL>



<H2><A NAME="_core_c_calls_using_fortran_names"></A>C Calls Using Fortran Names</H2>

<P>If you call a Fortran routine from C and cannot recompile the Fortran code, and if the routine uses Fortran defaults, you must use an all-uppercase name to make the call. Use of the <B>__stdcall</B> convention is not enough, because <B>__stdcall</B> (unlike the <B>fortran</B> keyword in 16-bit code) always preserves case. Fortran generates all-uppercase names by default and the C code must match it.</P>

<P>For example, this prototype sets up a call to a Fortran function <CODE>ffarctan</CODE>:</P>

<PRE><CODE>extern float __stdcall FFARCTAN( float angle );
</CODE></PRE>



<H2><A NAME="_core_all.2d.lowercase_names"></A>All-Lowercase Names</H2>

<P>If the name of the routine appears as all lowercase in C, naming conventions are automatically correct when the <B>C</B> or <B>STDCALL</B> attribute is applied to the Fortran declaration. Any case may be used in the Fortran source code, including mixed case; the <B>C</B> and <B>STDCALL</B> attributes change the name to all lowercase. Note that this is a way in which <B>STDCALL</B> differs from the Fortran default behavior.</P>



<H2><A NAME="_core_mixed.2d.case_names"></A>Mixed-Case Names</H2>

<P>If the name of the routine appears as mixed-case in C, and you cannot change the name, you can resolve naming conflicts only by using the Fortran <B>ALIAS</B> attribute. <B>ALIAS</B> is required in this situation so that Fortran will generate mixed-case names.</P>

<P>To use the <B>ALIAS</B> attribute, place the name in quotation marks exactly as it is to appear in the .OBJ file. For example, suppose you are calling a C function that has the following prototype:</P>

<PRE><CODE>extern void My_Proc (int i);
</CODE></PRE>

<P>The Fortran call to this function should be declared with the following <B>INTERFACE</B> block:</P>

<PRE><CODE>      INTERFACE TO SUBROUTINE My_Proc [C, ALIAS:’_My_Proc’] (I)
      INTEGER*4 I
      END
</CODE></PRE>

<P class=indent><B><B>Note</B></B>&nbsp;&nbsp;&nbsp;When using the <B>__stdcall</B> convention, both Fortran and C should calculate parameter-space size by rounding each parameter upward to multiples of four (because it is more efficient to keep the stack-pointer aligned on 4-byte boundaries). Thus, the function Print_Nums, which is passed a byte, a short, and a long integer should be translated as _Print_Nums@12. However, there is an early version of 32-bit Fortran that translates this as _Print_Nums@7, not rounding upward. To correct the discrepancy, use the <B>ALIAS</B> attribute.</P>
</font>
</BODY>
</HTML>
