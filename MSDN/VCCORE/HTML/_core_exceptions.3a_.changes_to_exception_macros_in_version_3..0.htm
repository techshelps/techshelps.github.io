<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Exceptions: Changes to Exception Macros in Version 3.0</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>

<TABLE ALIGN=right WIDTH=0 BORDER=0><TR><TD>
<OBJECT ID="hhobj_1" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_vc_addpf_home">
</OBJECT>
</TD></TR></TABLE>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_core_exceptions.3a_.changes_to_exception_macros_in_version_3..0"></A>Exceptions: Changes to Exception Macros in Version 3.0</H1>

<P><A HREF="JavaScript:hhobj_1.Click()">Home</A>  |&nbsp; <A HREF="_core_exception_handling.3a_.overview.htm">Overview</A>  |&nbsp; <A HREF="_core_exception_handling_tasks.htm">How Do I</A>  |&nbsp; <A HREF="_core_which_exception_handling_mechanism_should_i_use.3f.htm">FAQ</A></P>

<P>This is an advanced topic.</P>

<P>In MFC version 3.0 and later, the exception-handling macros have been changed to use C++ exceptions. This article tells how those changes can affect the behavior of existing code that uses the macros.</P>

<P>This article covers the following topics:

<UL type=disc>
	<LI><A HREF="#_core_exception_types_and_the_catch_macro">Exception types and the CATCH macro</A><BR><BR></LI>

	<LI><A HREF="#_core_re.2d.throwing_exceptions">Re-throwing exceptions</A></LI>
</UL>



<H2><A NAME="_core_exception_types_and_the_catch_macro"></A>Exception Types and the CATCH Macro</H2>

<P>In earlier versions of MFC, the <B>CATCH</B> macro used MFC run-time type information to determine an exception’s type; the exception’s type is determined, in other words, at the catch site. With C++ exceptions, however, the exception’s type is always determined at the throw site by the type of the exception object that is thrown. This will cause incompatibilities in the rare case where the type of the pointer to the thrown object differs from the type of the thrown object.</P>

<P>The following example illustrates the consequence of this difference between MFC version 3.0 and earlier versions:</P>

<PRE><CODE>TRY
{
    THROW( (CException*) new CCustomException() );
}
CATCH( CCustomException, e )
{
    TRACE( "MFC 2.x will land here\n" );
}
AND_CATCH( CException, e )
{
    TRACE( "MFC 3.0 will land here\n" );
}
END_CATCH
</CODE></PRE>

<P>This code behaves differently in version 3.0 because control always passes to the first <B>catch </B>block with a matching exception-declaration. The result of the throw expression</P>

<PRE><CODE>THROW((CException*)new CCustomException());
</CODE></PRE>

<P>is thrown as a <B>CException*</B>, even though it is constructed as a <B>CCustomException</B>. The <B>CATCH</B> macro in MFC versions 2.5 and earlier uses <B>CObject::IsKindOf</B> to test the type at run time. Because the expression</P>

<PRE><CODE>e-&gt;IsKindOf( RUNTIME_CLASS( CException ) )
</CODE></PRE>

<P>is true, the first catch block catches the exception. In version 3.0, which uses C++ exceptions to implement many of the exception-handling macros, the second catch block matches the thrown <B>CException</B>.</P>

<P>Code like this is uncommon. It usually appears when an exception object is passed to another function that accepts a generic <B>CException*</B>, performs “pre-throw” processing, and finally throws the exception.</P>

<P>To work around this problem, move the throw expression from the function to the calling code and throw an exception of the actual type known to the compiler at the time the exception is generated.</P>



<H2><A NAME="_core_re.2d.throwing_exceptions"></A>Re-Throwing Exceptions</H2>

<P>A catch block cannot throw the same exception pointer that it caught.</P>

<P>For example, this code was valid in previous versions, but will have unexpected results with version 3.0:</P>

<PRE><CODE>TRY
{
    // Do something to throw an exception.
}
CATCH( CSomeException, e )
{
    THROW( e );    // Wrong. Use THROW_LAST() instead
}
END_TRY
</CODE></PRE>

<P>Using <B>THROW</B> in the catch block causes the pointer <CODE>e</CODE> to be deleted, so that the outer catch site will receive an invalid pointer. Use <B>THROW_LAST</B> to re-throw <CODE>e</CODE>.</P>

<P>For related information, see <A HREF="_core_exceptions.3a_.catching_and_deleting_exceptions.htm">Exceptions: Catching and Deleting Exceptions</A>. </P>
</font>
</BODY>
</HTML>
