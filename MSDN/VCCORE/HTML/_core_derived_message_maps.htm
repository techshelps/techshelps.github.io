<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Derived Message Maps</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>

<TABLE ALIGN=right WIDTH=0 BORDER=0><TR><TD>
<OBJECT ID="hhobj_1" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_vc_addpf_home">
</OBJECT>
<OBJECT ID="hhobj_2" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="Scribble start">
</OBJECT>
</TD></TR></TABLE>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_core_derived_message_maps"></A>Derived Message Maps</H1>

<P><A HREF="JavaScript:hhobj_1.Click()">Home</A>  |&nbsp; <A HREF="_core_messages_and_commands.3a_.overview.htm">Overview</A>  |&nbsp; <A HREF="_core_message.2d.mapping_tasks.htm">How Do I</A>  |&nbsp; <A HREF="JavaScript:hhobj_2.Click()">Tutorial</A></P>

<P>During message handling, checking a class’s own message map is not the end of the message-map story. What happens if class <CODE>CMyView</CODE> (derived from <B>CView</B>) has no matching entry for a message? </P>

<P>Keep in mind that <B>CView</B>, the base class of <CODE>CMyView</CODE>, is derived in turn from <B>CWnd</B>. Thus <CODE>CMyView</CODE> <I>is</I> a <B>CView</B> and <I>is</I> a <B>CWnd</B>. Each of those classes has its own message map. The figure “A View Hierarchy” below shows the hierarchical relationship of the classes, but keep in mind that a <CODE>CMyView</CODE> object is a single object that has the characteristics of all three classes.</P>

<P class=label><B>A View Hierarchy</B></P>

<P><IMG SRC="m02vwhi.gif" ALT="" BORDER=0></P>

<P>So if a message can’t be matched in class <CODE>CMyView</CODE>’s message map, the framework also searches the message map of its immediate base class. The <B>BEGIN_MESSAGE_MAP</B> macro at the start of the message map specifies two class names as its arguments:</P>

<PRE><CODE>BEGIN_MESSAGE_MAP(CMyView, CView)
</CODE></PRE>

<P>The first argument names the class to which the message map belongs. The second argument provides a connection with the immediate base class —  <B>CView</B> here — so the framework can search its message map, too. </P>

<P>The message handlers provided in a base class are thus inherited by the derived class. This is very similar to normal virtual member functions without needing to make all handler member functions virtual.</P>

<P>If no handler is found in any of the base-class message maps, default processing of the message is performed. If the message is a command, the framework routes it to the next command target. If it is a standard Windows message, the message is passed to the appropriate default window procedure. </P>

<P>To speed message-map matching, the framework caches recent matches on the likelihood that it will receive the same message again. One consequence of this is that the framework processes unhandled messages quite efficiently. Message maps are also more space-efficient than implementations that use virtual functions.</P>
</font>
</BODY>
</HTML>
