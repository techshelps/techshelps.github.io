<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SQL: Customizing Your Recordset's SQL Statement (ODBC)</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>

<TABLE ALIGN=right WIDTH=0 BORDER=0><TR><TD>
<OBJECT ID="hhobj_1" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_vc_addpf_home">
</OBJECT>
<OBJECT ID="hhobj_2" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="Enroll tutorial">
</OBJECT>
<OBJECT ID="hhobj_3" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_sample_mfc_ENROLL">
</OBJECT>
<OBJECT ID="hhobj_4" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_sample_mfc_CATALOG">
</OBJECT>
<OBJECT ID="hhobj_5" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_sample_mfc_CATALOG">
</OBJECT>
</TD></TR></TABLE>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_core_sql.3a_.customizing_your_recordset.92.s_sql_statement_.28.odbc.29"></A>SQL: Customizing Your Recordset’s SQL Statement (ODBC)</H1>

<P><A HREF="JavaScript:hhobj_1.Click()">Home</A>  |&nbsp; <A HREF="_core_databases.3a_.overview.htm">Overview</A>  |&nbsp; <A HREF="_core_odbc_database_tasks.htm">How Do I</A>  |&nbsp; <A HREF="_core_databases.3a_.frequently_asked_questions.htm">FAQ</A>  |&nbsp; <A HREF="_core_odbc_database_sample_list.htm">Sample</A>  |&nbsp; <A HREF="JavaScript:hhobj_2.Click()">Tutorial</A>  |&nbsp; <A HREF="_core_odbc_driver_list.htm">ODBC Driver List</A></P>

<P>This article explains: 

<UL type=disc>
	<LI><A HREF="#_core_sql_statement_construction">How the framework constructs an SQL statement</A>. <BR><BR></LI>

	<LI><A HREF="#_core_overriding_the_sql_statement">How to override the SQL statement</A>.</LI>
</UL>

<P class=indent><B><B>Note&nbsp;&nbsp;&nbsp;</B></B>This information applies to the MFC ODBC classes. If you’re working with the MFC DAO classes, see the topic Comparison of Microsoft Jet Database Engine SQL and ANSI SQL in DAO Help.</P>

<H2><A NAME="_core_sql_statement_construction"></A>SQL Statement Construction</H2>

<P>Your recordset bases record selection primarily on an SQL <B>SELECT</B> statement. When you declare your class with ClassWizard, the wizard writes an overriding version of the <B>GetDefaultSQL</B> member function that looks something like this (for a recordset class called <CODE>CAuthors</CODE>).</P>

<PRE><CODE>CString CAuthors::GetDefaultSQL()
{
    return "AUTHORS";
}
</CODE></PRE>

<P>By default, this override returns the table name you specified with ClassWizard — in the example, the table name is “AUTHORS.” When you later call the recordset’s <B>Open</B> member function, <B>Open</B> constructs a final <B>SELECT</B> statement of the form:</P>

<PRE><CODE>SELECT rfx-field-list FROM table-name [WHERE m_strFilter] 
       [ORDER BY m_strSort]
</CODE></PRE>

<P>where <CODE>table-name</CODE> is obtained by calling <B>GetDefaultSQL</B> and <CODE>rfx-field-list</CODE> is obtained from the RFX function calls in <B>DoFieldExchange</B>. This is what you get for a <B>SELECT</B> statement unless you replace it with an overriding version at run time, although you can also modify the default statement with parameters or a filter.</P>

<P class=indent><B><B>Important&nbsp;&nbsp;&nbsp;</B></B>If you specify a column name that contains (or could contain) spaces, you must enclose the name in square brackets. For example, the name “First Name” should be “[First Name]”.</P>

<P>To override the default <B>SELECT</B> statement, pass a string containing a complete <B>SELECT</B> statement when you call <B>Open</B>. Instead of constructing its own default string, the recordset uses the string you supply. If your replacement statement contains a <B>WHERE</B> clause, don’t specify a filter in <B>m_strFilter</B> because you would then have two filter statements. Similarly, if your replacement statement contains an <B>ORDER BY</B> clause, don’t specify a sort in <B>m_strSort</B> so that you will not have two sort statements.</P>

<P class=indent><B><B>Caution&nbsp;&nbsp;&nbsp;</B></B>In the ENROLL tutorial application, filter strings typically use a parameter placeholder, “?”, rather than assigning a specific literal value, such as “MATH101”, at compile time. If you do use literal strings in your filters (or other parts of the SQL statement), you may have to “quote” (enclose in specified delimiters) such strings with a DBMS-specific literal prefix and literal suffix character (or characters). For example, the code in the ENROLL tutorial uses a single quote character to bracket the value “MATH101” assigned as the filter. </P>

<P class=indent>You may also encounter special syntactic requirements for operations such as outer joins, depending on your DBMS. Use ODBC functions to obtain this information from your driver for the DBMS. For example, call <B>::SQLGetTypeInfo</B> for a particular data type, such as <B>SQL_VARCHAR</B>, to request the <B>LITERAL_PREFIX</B> and <B>LITERAL_SUFFIX</B> characters. If you are writing database-independent code, see Appendix C in the ODBC SDK <I>Programmer’s Reference</I> on the MSDN Library CD for detailed syntax information.</P>

<P>A recordset object constructs the SQL statement that it uses to select records unless you pass a custom SQL statement. How this is done depends mainly on the value you pass in the <I>lpszSQL</I> parameter of the <B>Open</B> member function.</P>

<P>The general form of an SQL <B>SELECT</B> statement is:</P>

<PRE><CODE>SELECT [ALL | DISTINCT] column-list FROM table-list
    [WHERE search-condition][ORDER BY column-list [ASC | DESC]]
</CODE></PRE>

<P>One way to add the <B>DISTINCT</B> keyword to your recordset’s SQL statement is to embed the keyword in the first RFX function call in <B>DoFieldExchange</B>. For example: </P>

<PRE><CODE>...
    RFX_Text(pFX, "DISTINCT CourseID", m_strCourseID);
...
</CODE></PRE>

<P class=indent><B><B>Warning&nbsp;&nbsp;&nbsp;</B></B>Use this technique only with a recordset opened as read-only.</P>



<H2><A NAME="_core_overriding_the_sql_statement"></A>Overriding the SQL Statement</H2>

<P>The following table shows the possibilities for the <I>lpszSQL</I> parameter to <B>Open</B>. The cases in the table are explained following the table.</P>

<P class=label><B>The <I>lpszSQL</I> Parameter and the Resulting SQL String</B></P>

<TABLE border=1 cellpadding=5 cols=3 frame=below rules=rows>

<TR VALIGN="top">
<TD class=label width=10%><B>Case</B></TD>
<TD class=label width=41%><B>What you pass in <I>lpszSQL</I></B></TD>
<TD class=label width=49%><B>The resulting SELECT statement </B></TD>
</TR>

<TR VALIGN="top">
<TD width=10%>1</TD>
<TD width=41%><B>NULL</B></TD>
<TD width=49%><B>SELECT</B> <I>rfx-field-list</I> <B>FROM</B> <I>table-name</I>
<P><B>CRecordset::Open</B> calls <B>GetDefaultSQL</B> to get the table name. The resulting string is one of Cases 2 through 5, depending on what <B>GetDefaultSQL</B> returns.</P>
</TD>
</TR>

<TR VALIGN="top">
<TD width=10%>2</TD>
<TD width=41%>A table name</TD>
<TD width=49%><B>SELECT</B> <I>rfx-field-list</I> <B>FROM</B> <I>table-name</I>
<P>The field list is taken from the RFX statements in <B>DoFieldExchange</B>. If <B>m_strFilter</B> and <B>m_strSort</B> are not empty, adds the <B>WHERE</B> and/or <B>ORDER BY</B> clauses.</P>
</TD>
</TR>

<TR VALIGN="top">
<TD width=10%>3 *</TD>
<TD width=41%>A complete <B>SELECT</B> statement but without a <B>WHERE</B> or <B>ORDER BY</B> clause</TD>
<TD width=49%>As passed. If <B>m_strFilter</B> and <B>m_strSort</B> are not empty, adds the <B>WHERE</B> and/or <B>ORDER BY</B> clauses.</TD>
</TR>

<TR VALIGN="top">
<TD width=10%>4 *</TD>
<TD width=41%>A complete <B>SELECT</B> statement with a <B>WHERE</B> and/or <B>ORDER BY</B> clause</TD>
<TD width=49%>As passed. <B>m_strFilter</B> and/or <B>m_strSort</B> must remain empty, or two filter and/or sort statements will be produced.</TD>
</TR>

<TR VALIGN="top">
<TD width=10%>5 *</TD>
<TD width=41%>A call to a stored procedure</TD>
<TD width=49%>As passed.</TD>
</TR>
</TABLE><BR>

<P class=mini>* <B>m_nFields</B> must be less than or equal to the number of columns specified in the <B>SELECT</B> statement. The data type of each column specified in the <B>SELECT</B> statement must be the same as the data type of the corresponding RFX output column.</P>

<H3>Case 1&nbsp;&nbsp;&nbsp;<I>lpszSQL</I> = NULL</H3>

<P>The recordset selection depends on what <B>GetDefaultSQL</B> returns when <B>CRecordset::Open</B> calls it. Cases 2 through 5 describe the possible strings.</P>

<H3>Case 2&nbsp;&nbsp;&nbsp;<I>lpszSQL</I> = a Table Name</H3>

<P>The recordset uses record field exchange (RFX) to build the column list from the column names provided in the RFX function calls in the recordset class’s override of <B>DoFieldExchange</B>. If you used ClassWizard to declare your recordset class, this case has the same result as Case 1 (provided that you pass the same table name you specified in ClassWizard). If you don’t use ClassWizard to write your class, Case 2 is the simplest way to construct the SQL statement.</P>

<P>The following example constructs an SQL statement that selects records from the MFC tutorial sample <A HREF="JavaScript:hhobj_3.Click()">ENROLL</A>. When the framework calls the <B>GetDefaultSQL</B> member function, the function returns the name of the table, <CODE>SECTION</CODE>. </P>

<PRE><CODE>CString CEnrollSet::GetDefaultSQL()
{
    return "SECTION";
}
</CODE></PRE>

<P>To obtain the names of the columns for the SQL <B>SELECT</B> statement, the framework calls the <B>DoFieldExchange</B> member function.</P>

<PRE><CODE>void CEnrollSet::DoFieldExchange(CFieldExchange* pFX)
{
    pFX-&gt;SetFieldType(CFieldExchange::outputColumn);
    //{{AFX_FIELD_MAP(CEnrollSet)
    RFX_Text(pFX, "CourseID", m_strCourseID);
    RFX_Text(pFX, "InstructorID", m_strInstructorID);
    RFX_Text(pFX, "RoomNo", m_strRoomNo);
    RFX_Text(pFX, "Schedule", m_strSchedule);
    RFX_Text(pFX, "SectionNo", m_strSectionNo);
    //}}AFX_FIELD_MAP
}
</CODE></PRE>

<P>When complete, the SQL statement looks like this:</P>

<PRE><CODE>SELECT CourseID, InstructorID, RoomNo, Schedule, SectionNo 
    FROM SECTION
</CODE></PRE>

<H3>Case 3&nbsp;&nbsp;&nbsp;<I>lpszSQL</I> = a SELECT/FROM Statement</H3>

<P>You specify the column list by hand rather than relying on RFX to construct it automatically. You might want to do this when:

<UL type=disc>
	<LI>You want to specify the <B>DISTINCT</B> keyword following <B>SELECT</B>.
<P class=tl>Your column list should match the column names&nbsp; and types in the same order as they are listed in <B>DoFieldExchange</B>.</P></LI>

	<LI>You have reason to manually retrieve column values using the ODBC function <B>::SQLGetData</B> rather than relying on RFX to bind and retrieve columns for you.
<P class=tl>You might, for example, want to accommodate new columns a customer of your application added to the database tables after the application was distributed. You need to add these extra field data members, that were not known at the time you declared the class with ClassWizard.</P>
<P class=tl>Your column list should match the column names and types in the same order as they are listed in <B>DoFieldExchange</B>, followed by the names of the manually bound columns. The MFC Database sample <A HREF="JavaScript:hhobj_4.Click()">CATALOG</A> provides classes called <B>CTable</B> and <B>CColumn</B> which you can use to retrieve column information from the data source. For more information, see the article <A HREF="_core_recordset.3a_.dynamically_binding_data_columns_.28.odbc.29.htm">Recordset: Dynamically Binding Data Columns (ODBC)</A> and the MFC sample <A HREF="JavaScript:hhobj_5.Click()">CATALOG</A>.</P></LI>

	<LI>You want to join tables by specifying multiple tables in the <B>FROM</B> clause.
<P class=tl>For information and an example, see the article <A HREF="_core_recordset.3a_.performing_a_join_.28.odbc.29.htm">Recordset: Performing a Join (ODBC)</A>. </P></LI>
</UL>

<H3>Case 4&nbsp;&nbsp;&nbsp;<I>lpszSQL</I> = SELECT/FROM Plus WHERE and/or ORDER BY</H3>

<P>You specify everything: the column list (based on the RFX calls in <B>DoFieldExchange</B>), the table list, and the contents of a <B>WHERE</B> and/or an <B>ORDER BY</B> clause. If you specify your <B>WHERE</B> and/or <B>ORDER BY</B> clauses this way, do not use <B>m_strFilter</B> and/or <B>m_strSort</B>.</P>

<H3>Case 5&nbsp;&nbsp;&nbsp;<I>lpszSQL</I> = a Stored Procedure Call</H3>

<P>If you need to call a predefined query (such as a stored procedure in a Microsoft SQL Server database), you must write a <B>CALL</B> statement in the string you pass to <I>lpszSQL</I>. ClassWizard doesn’t support declaring a recordset class for calling a predefined query. Not all predefined queries return records. </P>

<P>If a predefined query doesn’t return records, you can use the <B>CDatabase</B> member function <B>ExecuteSQL</B> directly. For a predefined query that does return records, you must also manually write the RFX calls in <B>DoFieldExchange</B> for any columns the procedure returns. The RFX calls must be in the same order, and return the same types, as the predefined query. For more information, see the article <A HREF="_core_recordset.3a_.declaring_a_class_for_a_predefined_query_.28.odbc.29.htm">Recordset: Declaring a Class for a Predefined Query (ODBC)</A>. </P>

<P><B>See Also</B>&nbsp;&nbsp;&nbsp;<A HREF="_core_sql.3a_.sql_and_c.2b2b_.data_types_.28.odbc.29.htm">SQL: SQL and C++ Data Types (ODBC)</A>, <A HREF="_core_sql.3a_.making_direct_sql_calls_.28.odbc.29.htm">SQL: Making Direct SQL Calls (ODBC)</A> </P>
</font>
</BODY>
</HTML>
