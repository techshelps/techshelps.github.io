<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Mixing C and C++ Exceptions</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>

<TABLE ALIGN=right WIDTH=0 BORDER=0><TR><TD>
<OBJECT ID="hhobj_1" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_vc_addpf_home">
</OBJECT>
</TD></TR></TABLE>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_core_mixing_c_and_c.2b2b_.exceptions"></A>Mixing C and C++ Exceptions</H1>

<P><A HREF="JavaScript:hhobj_1.Click()">Home</A>  |&nbsp; <A HREF="_core_exception_handling.3a_.overview.htm">Overview</A>  |&nbsp; <A HREF="_core_exception_handling_tasks.htm">How Do I</A>  |&nbsp; <A HREF="_core_exception_handling.3a_.frequently_asked_questions.htm">FAQ</A></P>

<P>If you want to write more portable code, using structured exception handling in a C++ program is not recommended. However, you may sometimes want to mix C and C++ source code, and need some facility for handling both kinds of exceptions. Because a structured exception handler has no concept of objects or typed exceptions, it cannot handle exceptions thrown by C++ code; however, C++ <B>catch</B> handlers can handle C exceptions. As such, C++ exception handling syntax (<B>try</B>, <B>throw</B>, <B>catch</B>) is not accepted by the C compiler, but structured exception handling syntax (<B>__try</B>, <B>__except</B>, <B>__finally</B>) is supported by the C++ compiler.</P>

<P>If you mix C and C++ exceptions, note the following:

<OL>
	<LI>C++ exceptions and C exceptions cannot be mixed within the same function.<BR><BR></LI>

	<LI>Termination handlers (<B>__finally</B> blocks) are always executed, even during unwinding after an exception is thrown. <BR><BR></LI>

	<LI>C++ exception handling can catch and preserve unwind semantics in all modules compiled with the <A HREF="_core_.2f.gx.htm">/GX</A> compiler option (this option enables unwind semantics).<BR><BR></LI>

	<LI>There may be some situations in which destructor functions are not called for all objects. For example, if a C exception occurs while attempting to make a function call through an uninitialized function pointer, and that function takes as parameters objects that were constructed before the call, those objects will not have their destructors called during stack unwind.</LI>
</OL>

<H3>What do you want to know more about?</H3>

<UL type=disc>
	<LI><A HREF="_core_using_setjmp.2f.longjmp.htm">Using setjmp or longjmp in C++ programs</A><BR><BR></LI>

	<LI><A HREF="_core_exception_handling_differences.htm">Differences between SEH and C++ EH</A></LI>
</UL>
</font>
</BODY>
</HTML>
