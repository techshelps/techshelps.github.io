<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Calling DLL Functions from Visual Basic Applications</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>

<TABLE ALIGN=right WIDTH=0 BORDER=0><TR><TD>
<OBJECT ID="hhobj_1" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_vc_addpf_home">
</OBJECT>
</TD></TR></TABLE>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_core_calling_dll_functions_from_visual_basic_applications"></A>Calling DLL Functions from Visual Basic Applications</H1>

<P><A HREF="JavaScript:hhobj_1.Click()">Home</A>  |&nbsp; <A HREF="_core_dlls.3a_.overview.htm">Overview</A>  |&nbsp; <A HREF="_core_dll_tasks.htm">How Do I</A>  |&nbsp; <A HREF="_core_dlls.3a_.frequently_asked_questions.htm">FAQ</A>  |&nbsp; <A HREF="_core_dll_topics.htm">Details</A>  |&nbsp; <A HREF="_core_dll_sample_programs.htm">Sample</A></P>

<P>In order for Visual Basic applications (or applications in other languages such as Pascal or Fortran) to call functions in a C/C++ DLL, the functions must be exported using the correct calling convention without any name decoration done by the compiler. In Windows 3.x and 16-bit editions of Visual C++, you could use the <B>_pascal</B> keyword as part of the definition of the exported function. However, there is no <B>_pascal</B> keyword in the 32-bit editions of Visual C++. Instead the WINDEF.H header file has PASCAL defined as <B>__stdcall</B>. This creates the correct calling convention for the function (the called function cleans up the stack and parameters are passed from right to left) but decorates the function name differently. So, when <B>__declspec(dllexport)</B> is used on an exported function in a DLL, the decorated name is exported instead of the desired PASCAL style name, which is undecorated and all uppercase.</P>

<P>PASCAL name decoration is simply the undecorated symbol name in uppercase letters. The <B>__stdcall</B> name decoration prefixes the symbol name with an underscore (_) and appends the symbol with an at sign (@) character followed by the number of bytes in the argument list (the required stack space). So, the function when declared as: </P>

<PRE><CODE>   int  __stdcall func (int a, double b)
</CODE></PRE>

<P>is decorated as:</P>

<PRE><CODE>   _func@12
</CODE></PRE>

<P>The C calling convention (<B>__cdecl</B>) decorates the name as <CODE>_func</CODE>. Whereas the desired PASCAL style name is <CODE>FUNC</CODE>.</P>

<P>To get the decorated name, set the Generate Mapfile option in the Linker General category setting. Use of <B>__declspec(dllexport)</B> does the following:

<UL type=disc>
	<LI>If the function is exported with the C calling convention (<B>_cdecl</B>), it strips the leading underscore (_) when the name is exported.<BR><BR></LI>

	<LI>If the function being exported does not use the C calling convention (for example, <B>__stdcall</B> ), it exports the decorated name.</LI>
</UL>

<P>So to simulate PASCAL name decoration and calling conventions, you must have the "Called Function stack clean-up" provided by using <B>__stdcall </B>and the undecorated uppercase name.</P>

<P>Because there is no way to override where the stack clean up occurs, you must use <B>__stdcall</B>. To undecorate names with <B>__stdcall</B>, you must specify them by using aliases in the EXPORTS section of the .DEF file. This is shown below for the following function declaration:</P>

<PRE><CODE>   int  __stdcall MyFunc (int a, double b);
   void __stdcall InitCode (void);
</CODE></PRE>

<P>In the .DEF file:</P>

<PRE><CODE>   EXPORTS
      MYFUNC=_MyFunc@12
      INITCODE=_InitCode@0
</CODE></PRE>

<P>For DLLs to be called by programs written in the 32-bit version of Visual Basic version 4.0, the alias technique shown in this article is needed in the .DEF file. If alias is done in the Visual Basic program, use of aliasing in the .DEF file is not necessary. It can be done on the Visual Basic program by adding an alias clause to the <B>declare</B> statement as shown here:</P>

<PRE><CODE>Declare Function MyFunc Lib "dlllibname" Alias "_MyFunc@12"  (...)
                                As Integer
</CODE></PRE>

<P>The complete syntax for the Visual Basic <B>declare</B> statement follows:</P>

<PRE><CODE>[Public | Private ] Declare Function name Lib
     "libname" [Alias "aliasname" ] [([arglist])][As type]
</CODE></PRE>

<P class=indent><B><B>Note</B></B>&nbsp;&nbsp;&nbsp;A very good discussion (with example code) of calling a C DLL from Visual Basic can be found in the file VB4DLL.TXT in the VB directory.

<UL type=disc>
	<LI><A HREF="_core_export_from_a_dll.htm">Export from a DLL</A><BR><BR></LI>

	<LI><A HREF="_core_export_from_a_dll_using_..def_files.htm">Export from a DLL using .DEF files</A><BR><BR></LI>

	<LI><A HREF="_core_export_from_a_dll_using___declspec.28.dllexport.29.htm">Export from a DLL using __declspec(dllexport)</A><BR><BR></LI>

	<LI><A HREF="_core_export_c.2b2b_.functions_for_use_in_c.2d.language_executables.htm">Export C++ functions for use in C-language executables</A><BR><BR></LI>

	<LI><A HREF="_core_determine_which_exporting_method_to_use.htm">Determine which exporting method to use</A></LI>
</UL>

<H3>What do you want to know more about?</H3>

<UL type=disc>
	<LI><A HREF="_core_decorated_names.htm">Decorated names</A></LI>
</UL>
</font>
</BODY>
</HTML>
