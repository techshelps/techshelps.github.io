<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Serialization: Serializing an Object</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>

<TABLE ALIGN=right WIDTH=0 BORDER=0><TR><TD>
<OBJECT ID="hhobj_1" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_vc_addpf_home">
</OBJECT>
<OBJECT ID="hhobj_2" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_gs_Serializing_the_Data">
</OBJECT>
<OBJECT ID="hhobj_3" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_MFC_CArchive">
</OBJECT>
<OBJECT ID="hhobj_4" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink">
	<PARAM NAME="DefaultTopic" VALUE="_topic_not_found.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="_MFCNOTES_TN002">
</OBJECT>
</TD></TR></TABLE>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_core_serialization.3a_.serializing_an_object"></A>Serialization: Serializing an Object</H1>

<P><A HREF="JavaScript:hhobj_1.Click()">Home</A>  |&nbsp; <A HREF="_core_serialization.3a_.overview.htm">Overview</A>  |&nbsp; <A HREF="_core_serialization_tasks.htm">How Do I</A>  |&nbsp; <A HREF="JavaScript:hhobj_2.Click()">Tutorial</A></P>

<P>The article <A HREF="_core_serialization.3a_.making_a_serializable_class.htm">Serialization: Making a Serializable Class</A> shows how to make a class serializable. Once you have a serializable class, you can serialize objects of that class to and from a file via a <A HREF="JavaScript:hhobj_3.Click()">CArchive</A> object. This article explains: 

<UL type=disc>
	<LI><A HREF="#_core_what_is_a_carchive_object">What a CArchive object is</A>.<BR><BR></LI>

	<LI><A HREF="#_core_two_ways_to_create_a_carchive_object">Two ways to create a CArchive</A>.<BR><BR></LI>

	<LI><A HREF="#_core_using_the_carchive_.3c3c_.and_.3e3e_.operators">How to use the CArchive &lt;&lt; and &gt;&gt; operators</A>.<BR><BR></LI>

	<LI><A HREF="#_core_storing_and_loading_cobjects_via_an_archive">Storing and loading CObjects via an archive</A>.</LI>
</UL>

<P>You can let the framework create the archive for your serializable document or explicitly create the <B>CArchive</B> object yourself. You can transfer data between a file and your serializable object by using the &lt;&lt; and &gt;&gt; operators for <B>CArchive</B> or, in some cases, by calling the <CODE>Serialize</CODE> function of a <B>CObject</B>-derived class.</P>



<H2><A NAME="_core_what_is_a_carchive_object"></A>What Is a CArchive Object</H2>

<P>A <B>CArchive</B> object provides a type-safe buffering mechanism for writing or reading serializable objects to or from a <B>CFile</B> object. Usually the <B>CFile</B> object represents a disk file; however, it can also be a memory file (<B>CSharedFile</B> object), perhaps representing the Clipboard.</P>

<P>A given <B>CArchive</B> object either stores (writes, serializes) data or loads (reads, deserializes) data, but never both. The life of a <B>CArchive</B> object is limited to one pass through writing objects to a file or reading objects from a file. Thus, two successively created <B>CArchive</B> objects are required to serialize data to a file and then deserialize it back from the file.</P>

<P>When an archive stores objects to a file, the archive attaches the <B>CRuntimeClass</B> name to the objects. Then, when another archive loads objects from a file to memory, the <B>CObject</B>-derived objects are dynamically reconstructed based on the <B>CRuntimeClass</B> of the objects. A given object may be referenced more than once as it is written to the file by the storing archive. The loading archive, however, will reconstruct the object only once. The details about how an archive attaches <B>CRuntimeClass</B> information to objects and reconstructs objects, taking into account possible multiple references, are described in <A HREF="JavaScript:hhobj_4.Click()">Technical Note 2</A>.</P>

<P>As data is serialized to an archive, the archive accumulates the data until its buffer is full. Then the archive writes its buffer to the <B>CFile</B> object pointed to by the <B>CArchive</B> object. Similarly, as you read data from an archive, it reads data from the file to its buffer and then from the buffer to your deserialized object. This buffering reduces the number of times a hard disk is physically read, thus improving your application’s performance.</P>



<H2><A NAME="_core_two_ways_to_create_a_carchive_object"></A>Two Ways to Create a CArchive Object</H2>

<P>There are two ways to create a <B>CArchive</B> object:

<UL type=disc>
	<LI><A HREF="#_core_implicit_creation_of_a_carchive_object_via_the_framework">Implicit creation of a CArchive object via the framework</A><BR><BR></LI>

	<LI><A HREF="#_core_explicit_creation_of_a_carchive_object">Explicit creation of a CArchive object</A></LI>
</UL>



<H3><A NAME="_core_implicit_creation_of_a_carchive_object_via_the_framework"></A>Implicit Creation of a CArchive Object via the Framework</H3>

<P>The most common, and easiest, way is to let the framework create a <B>CArchive</B> object for your document on behalf of the Save, Save As, and Open commands on the File menu. </P>

<P>Here is what the framework does when the user of your application issues the Save As command from the File menu:

<OL>
	<LI>Presents the <B>Save As</B> dialog box and gets the filename from the user.<BR><BR></LI>

	<LI>Opens the file named by the user as a <B>CFile</B> object.<BR><BR></LI>

	<LI>Creates a <B>CArchive</B> object that points to this <B>CFile</B> object. In creating the <B>CArchive</B> object, the framework sets the mode to “store” (write, serialize), as opposed to “load” (read, deserialize).<BR><BR></LI>

	<LI>Calls the <CODE>Serialize</CODE> function defined in your <B>CDocument</B>-derived class, passing it a reference to the <B>CArchive</B> object.</LI>
</OL>

<P>Your document’s <CODE>Serialize</CODE> function then writes data to the <B>CArchive</B> object, as explained shortly. Upon return from your <CODE>Serialize</CODE> function, the framework destroys the <B>CArchive</B> object and then the <B>CFile</B> object.</P>

<P>Thus, if you let the framework create the <B>CArchive</B> object for your document, all you have to do is implement the document’s <CODE>Serialize</CODE> function that writes and reads to and from the archive. You also have to implement <CODE>Serialize</CODE> for any <B>CObject</B>-derived objects that the document’s <CODE>Serialize</CODE> function in turn serializes directly or indirectly.</P>



<H3><A NAME="_core_explicit_creation_of_a_carchive_object"></A>Explicit Creation of a CArchive Object</H3>

<P>Besides serializing a document via the framework, there are other occasions when you may need a <B>CArchive</B> object. For example, you might want to serialize data to and from the Clipboard, represented by a <B>CSharedFile</B> object. Or, you may want to use a user interface for saving a file that is different from the one offered by the framework. In this case, you can explicitly create a <B>CArchive</B> object. You do this the same way the framework does, using the following procedure.</P>

<P class=label><B><A NAME="_core_to_explicitly_create_a_carchive_object"></A>To explicitly create a CArchive object</B>

<OL>
	<LI>Construct a <B>CFile</B> object or an object derived from <B>CFile</B>.<BR><BR></LI>

	<LI>Pass the <B>CFile</B> object to the constructor for <B>CArchive</B>, as shown in the following example:
<PRE><CODE>CFile theFile;
theFile.Open(..., CFile::modeWrite);
CArchive archive(&amp;theFile, CArchive::store);
</CODE></PRE>

<P class=tl>The second argument to the <B>CArchive</B> constructor is an enumerated value that specifies whether the archive will be used for storing or loading data to or from the file. The <CODE>Serialize</CODE> function of an object checks this state by calling the <B>IsStoring</B> function for the archive object.</P></LI>
</OL>

<P>When you are finished storing or loading data to or from the <B>CArchive</B> object, close it. Although the <B>CArchive</B> (and <B>CFile</B>) objects will automatically close the archive (and file), it is good practice to explicitly do so since it makes recovery from errors easier. For more information about error handling, see the article <A HREF="_core_exceptions.3a_.catching_and_deleting_exceptions.htm">Exceptions: Catching and Deleting Exceptions</A>. </P>

<P class=label><B><A NAME="_core_to_close_the_carchive_object"></A>To close the CArchive object</B>

<UL type=disc>
	<LI>The following example illustrates how to close the <B>CArchive</B> object:
<PRE><CODE>archive.Close();
theFile.Close();
</CODE></PRE>
</LI>
</UL>



<H2><A NAME="_core_using_the_carchive_.3c3c_.and_.3e3e_.operators"></A>Using the CArchive &lt;&lt; and &gt;&gt; Operators</H2>

<P><B>CArchive</B> provides &lt;&lt; and &gt;&gt; operators for writing and reading simple data types as well as <B>CObject</B>s to and from a file.</P>

<P class=label><B><A NAME="_core_to_store_an_object_in_a_file_via_an_archive"></A>To store an object in a file via an archive</B>

<UL type=disc>
	<LI>The following example shows how to store an object in a file via an archive:
<PRE><CODE>CArchive ar(&amp;theFile, CArchive::store);
WORD wEmployeeID;
...
ar &lt;&lt; wEmployeeID;
</CODE></PRE>
</LI>
</UL>

<P class=label><B><A NAME="_core_to_load_an_object_from_a_value_previously_stored_in_a_file"></A>To load an object from a value previously stored in a file</B>

<UL type=disc>
	<LI>The following example shows how to load an object from a value previously stored in a file:
<PRE><CODE>CArchive ar(&amp;theFile, CArchive::load);
WORD wEmployeeID;
...
ar &gt;&gt; wEmployeeID;
</CODE></PRE>
</LI>
</UL>

<P>Usually, you store and load data to and from a file via an archive in the <CODE>Serialize</CODE> functions of <B>CObject</B>-derived classes, which you must have declared with the <B>DECLARE_SERIALIZE</B> macro. A reference to a <B>CArchive</B> object is passed to your <CODE>Serialize</CODE> function. You call the <B>IsLoading</B> function of the <B>CArchive</B> object to determine whether the <CODE>Serialize</CODE> function has been called to load data from the file or store data to the file.</P>

<P>The <CODE>Serialize</CODE> function of a serializable <B>CObject</B>-derived class typically has the following form:</P>

<PRE><CODE>void CPerson::Serialize(CArchive&amp; ar)
{
    CObject::Serialize(ar);
    if (ar.IsStoring())
    {
        // TODO:  add storing code here
    }
    else
    {
    // TODO:  add loading code here
    }
}
</CODE></PRE>

<P>The above code template is exactly the same as the one AppWizard creates for the <CODE>Serialize</CODE> function of the document (a class derived from <B>CDocument)</B>. This code template helps you write code that is easier to review, because the storing code and the loading code should always be parallel, as in the following example:</P>

<PRE><CODE>void CPerson:Serialize(CArchive&amp; ar)
{
    if (ar.IsStoring())
    {
        ar &lt;&lt; m_strName;
        ar &lt;&lt; m_wAge;
    }
    else
    {
        ar &gt;&gt; m_strName;
        ar &gt;&gt; m_wAge;
    }
}
</CODE></PRE>

<P>The library defines <B>&lt;&lt;</B> and <B>&gt;&gt;</B> operators for <B>CArchive</B> as the first operand and the following data types and class types as the second operand:</P>

<TABLE border=1 cellpadding=5 cols=3 frame=below rules=rows>

<TR VALIGN="top">
<TD width=33%><B>CObject*</B></TD>
<TD width=33%><B>SIZE and CSize</B></TD>
<TD width=34%><B>float</B></TD>
</TR>

<TR VALIGN="top">
<TD width=33%><B>WORD</B></TD>
<TD width=33%><B>CString</B></TD>
<TD width=34%><B>POINT</B> and <B>CPoint</B></TD>
</TR>

<TR VALIGN="top">
<TD width=33%><B>DWORD</B></TD>
<TD width=33%><B>BYTE</B></TD>
<TD width=34%><B>RECT</B> and <B>CRect</B></TD>
</TR>

<TR VALIGN="top">
<TD width=33%><B>double</B></TD>
<TD width=33%><B>LONG</B></TD>
<TD width=34%><B>CTime</B> and <B>CTimeSpan</B></TD>
</TR>

<TR VALIGN="top">
<TD width=33%><B>int</B></TD>
<TD width=33%><B>COleCurrency</B></TD>
<TD width=34%><B>COleVariant</B></TD>
</TR>

<TR VALIGN="top">
<TD width=33%><B>COleDateTime</B></TD>
<TD width=33%><B>COleDateTimeSpan</B></TD>
<TD width=34%>&nbsp;</TD>
</TR>
</TABLE><BR>

<P class=indent><B><B>Note</B></B>&nbsp;&nbsp;&nbsp;Storing and loading <B>CObject</B>s via an archive requires extra consideration. For more information see <A HREF="#_core_storing_and_loading_cobjects_via_an_archive">Storing and Loading CObjects via an Archive</A> below.</P>

<P>The <B>CArchive &lt;&lt;</B> and <B>&gt;&gt;</B> operators always return a reference to the <B>CArchive</B> object, which is the first operand. This enables you to chain the operators, as illustrated below:</P>

<PRE><CODE>BYTE bSomeByte;
WORD wSomeWord;
DWORD wSomeDoubleWord;
...
ar &lt;&lt; bSomeByte &lt;&lt; wSomeWord &lt;&lt; wSomeDoubleWord;
</CODE></PRE>



<H2><A NAME="_core_storing_and_loading_cobjects_via_an_archive"></A>Storing and Loading CObjects via an Archive</H2>

<P>Storing and loading <B>CObject</B>s via an archive requires extra consideration. In certain cases, you should call the <CODE>Serialize</CODE> function of the object, where the <B>CArchive</B> object is a parameter of the <CODE>Serialize</CODE> call, as opposed to using the <B>&lt;&lt;</B> or <B>&gt;&gt;</B> operator of the <B>CArchive</B>. The important fact to keep in mind is that the <B>CArchive</B> <B>&gt;&gt;</B> operator constructs the <B>CObject</B> in memory based on <B>CRuntimeClass</B> information previously written to the file by the storing archive.</P>

<P>Therefore, whether you use the <B>CArchive</B> <B>&lt;&lt;</B> and <B>&gt;&gt;</B> operators, versus calling <CODE>Serialize</CODE>, depends on whether you <I>need</I> the loading archive to dynamically reconstruct the object based on previously stored <B>CRuntimeClass</B> information. Use the <CODE>Serialize</CODE> function in the following cases:

<UL type=disc>
	<LI>When deserializing the object, you know the exact class of the object beforehand.<BR><BR></LI>

	<LI>When deserializing the object, you already have memory allocated for it.</LI>
</UL>

<P class=indent><B><B>Caution</B></B>&nbsp;&nbsp;&nbsp;If you load the object using the <CODE>Serialize</CODE> function, you must also store the object using the <CODE>Serialize</CODE> function. Don’t store using the <B>CArchive</B> <B>&lt;&lt;</B> operator and then load using the <CODE>Serialize</CODE> function, or store using the <CODE>Serialize</CODE> function and then load using <B>CArchive &gt;&gt;</B> operator.</P>

<P>The following example illustrates the cases:</P>

<PRE><CODE>class CMyObject : public CObject
{
// ...Member functions
   public:
   CMyObject() { }
   virtual void Serialize( CArchive&amp; ar ) { }

// Implementation
   protected:
   DECLARE_SERIAL( CMyObject )
};


class COtherObject : public CObject
{
   // ...Member functions
   public:
   COtherObject() { }
   virtual void Serialize( CArchive&amp; ar ) { }

// Implementation
protected:
   DECLARE_SERIAL( COtherObject )
};


class CCompoundObject : public CObject
{
   // ...Member functions
   public:
   CCompoundObject();
   virtual void Serialize( CArchive&amp; ar );

// Implementation
protected:
   CMyObject m_myob;    // Embedded object
   COtherObject* m_pOther;    // Object allocated in constructor
   CObject* m_pObDyn;    // Dynamically allocated object
   //..Other member data and implementation

   DECLARE_SERIAL( CCompoundObject )
};

IMPLEMENT_SERIAL(CMyObject,CObject,1)
IMPLEMENT_SERIAL(COtherObject,CObject,1)
IMPLEMENT_SERIAL(CCompoundObject,CObject,1)


CCompoundObject::CCompoundObject()
{
   m_pOther = new COtherObject; // Exact type known and object already 
            //allocated.
   m_pObDyn = NULL;    // Will be allocated in another member function
            // if needed, could be a derived class object.
}

void CCompoundObject::Serialize( CArchive&amp; ar )
{
   CObject::Serialize( ar );    // Always call base class Serialize.
   m_myob.Serialize( ar );    // Call Serialize on embedded member.
   m_pOther-&gt;Serialize( ar );    // Call Serialize on objects of known exact type.

   // Serialize dynamic members and other raw data
   if ( ar.IsStoring() )
   {
      ar &lt;&lt; m_pObDyn;
      // Store other members
   }
   else
   {
      ar &gt;&gt; m_pObDyn; // Polymorphic reconstruction of persistent 
            // object 
            //load other members
   }
}
</CODE></PRE>

<P>In summary, if your serializable class defines an embedded <B>CObjec</B>t as a member, you should <I>not</I> use the <B>CArchive</B> <B>&lt;&lt;</B> and <B>&gt;&gt;</B> operators for that object, but should call the <CODE>Serialize</CODE> function instead. Also, if your serializable class defines a pointer to a <B>CObject</B> (or an object derived from <B>CObject</B>) as a member, but constructs this other object in its own constructor, you should also call <CODE>Serialize</CODE>.</P>
</font>
</BODY>
</HTML>
