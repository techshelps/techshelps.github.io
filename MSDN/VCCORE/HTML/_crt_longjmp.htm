<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>longjmp</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_crt_longjmp"></A><SUP></SUP>longjmp</H1>

<P>Restores stack environment and execution locale.</P>

<P><B>void</B> <B>longjmp(</B> <B>jmp_buf</B> <I>env</I><B>,</B> <B>int</B> <I>value</I> <B>);</B></P>

<TABLE border=1 cellpadding=5 cols=3 frame=below rules=rows>

<TR VALIGN="top">
<TD class=label width=15%><B>Routine</B></TD>
<TD class=label width=26%><B>Required Header</B></TD>
<TD class=label width=59%><B>Compatibility</B></TD>
</TR>

<TR VALIGN="top">
<TD width=15%><B>longjmp</B></TD>
<TD width=26%>&lt;setjmp.h&gt;</TD>
<TD width=59%>ANSI, Win 95, Win NT</TD>
</TR>
</TABLE><BR>

<P>For additional compatibility information, see <A HREF="_crt_compatibility.htm">Compatibility</A> in the Introduction.</P>

<P class=label><B>Libraries</B></P>

<TABLE border=1 cellpadding=5 cols=2 frame=below rules=rows>

<TR VALIGN="top">
<TD width=24%>LIBC.LIB</TD>
<TD width=76%>Single thread static library, retail version</TD>
</TR>

<TR VALIGN="top">
<TD width=24%>LIBCMT.LIB</TD>
<TD width=76%>Multithread static library, retail version</TD>
</TR>

<TR VALIGN="top">
<TD width=24%>MSVCRT.LIB</TD>
<TD width=76%>Import library for MSVCRT.DLL, retail version</TD>
</TR>
</TABLE><BR>

<P class=label><B>Return Value</B></P>

<P>None</P>

<P class=label><B>Parameters</B></P>

<P class=dt><I>env</I></P>

<P class=indent>Variable in which environment is stored</P>

<P class=dt><I>value</I></P>

<P class=indent>Value to be returned to <B>setjmp</B> call</P>

<P class=label><B>Remarks</B></P>

<P>The <B>longjmp</B> function restores a stack environment and execution locale previously saved in <I>env</I> by <B>setjmp</B>. <B>setjmp</B> and <B>longjmp</B> provide a way to execute a nonlocal <B>goto</B>; they are typically used to pass execution control to error-handling or recovery code in a previously called routine without using the normal call and return conventions.</P>

<P>A call to <B>setjmp</B> causes the current stack environment to be saved in <I>env</I>. A subsequent call to <B>longjmp</B> restores the saved environment and returns control to the point immediately following the corresponding <B>setjmp</B> call. Execution resumes as if <I>value</I> had just been returned by the <B>setjmp</B> call. The values of all variables (except register variables) that are accessible to the routine receiving control contain the values they had when <B>longjmp</B> was called. The values of register variables are unpredictable. The value returned by <B>setjmp</B> must be nonzero. If <I>value</I> is passed as 0, the value 1 is substituted in the actual return.</P>

<P>Call <B>longjmp</B> before the function that called <B>setjmp</B> returns; otherwise the results are unpredictable.</P>

<P>Observe the following restrictions when using <B>longjmp</B>:

<UL type=disc>
	<LI>Do not assume that the values of the register variables will remain the same. The values of register variables in the routine calling <B>setjmp</B> may not be restored to the proper values after <B>longjmp</B> is executed. <BR><BR></LI>

	<LI>Do not use <B>longjmp</B> to transfer control out of an interrupt-handling routine unless the interrupt is caused by a floating-point exception. In this case, a program may return from an interrupt handler via <B>longjmp</B> if it first reinitializes the floating-point math package by calling <B>_fpreset</B>.<BR><BR></LI>

	<LI>Be careful when using <B>setjmp</B> and <B>longjmp</B> in C++ programs. Because these functions do not support C++ object semantics, it is safer to use the C++ exception-handling mechanism.</LI>
</UL>

<P class=label><B>Example</B></P>

<PRE><CODE>/* FPRESET.C: This program uses signal to set up a
 * routine for handling floating-point errors.
 */

#include &lt;stdio.h&gt;
#include &lt;signal.h&gt;
#include &lt;setjmp.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;float.h&gt;
#include &lt;math.h&gt;
#include &lt;string.h&gt;

jmp_buf mark;              /* Address for long jump to jump to */
int     fperr;             /* Global error number */

void __cdecl fphandler( int sig, int num );   /* Prototypes */
void fpcheck( void );

void main( void )
{
   double n1, n2, r;
   int jmpret;
   /* Unmask all floating-point exceptions. */
    _control87( 0, _MCW_EM );
   /* Set up floating-point error handler. The compiler
    * will generate a warning because it expects
    * signal-handling functions to take only one argument.
    */
    if( signal( SIGFPE, fphandler ) == SIG_ERR )

   {
      fprintf( stderr, "Couldn't set SIGFPE\n" );
      abort();   }

   /* Save stack environment for return in case of error. First 
    * time through, jmpret is 0, so true conditional is executed. 
    * If an error occurs, jmpret will be set to -1 and false 
    * conditional will be executed.
    */
   jmpret = setjmp( mark );
   if( jmpret == 0 )
   {
      printf( "Test for invalid operation - " );
      printf( "enter two numbers: " );
      scanf( "%lf %lf", &amp;n1, &amp;n2 );
      r = n1 / n2;
      /* This won't be reached if error occurs. */
      printf( "\n\n%4.3g / %4.3g = %4.3g\n", n1, n2, r );

      r = n1 * n2;
      /* This won't be reached if error occurs. */
      printf( "\n\n%4.3g * %4.3g = %4.3g\n", n1, n2, r );
   }
   else
      fpcheck();
}
/* fphandler handles SIGFPE (floating-point error) interrupt. Note
 * that this prototype accepts two arguments and that the 
 * prototype for signal in the run-time library expects a signal 
 * handler to have only one argument.
 *
 * The second argument in this signal handler allows processing of
 * _FPE_INVALID, _FPE_OVERFLOW, _FPE_UNDERFLOW, and 
 * _FPE_ZERODIVIDE, all of which are Microsoft-specific symbols 
 * that augment the information provided by SIGFPE. The compiler 
 * will generate a warning, which is harmless and expected.

 */
void fphandler( int sig, int num )
{
   /* Set global for outside check since we don't want
    * to do I/O in the handler.
    */
   fperr = num;
   /* Initialize floating-point package. */
   _fpreset();
   /* Restore calling environment and jump back to setjmp. Return 
    * -1 so that setjmp will return false for conditional test.
    */
   longjmp( mark, -1 );
}
void fpcheck( void )
{
   char fpstr[30];
   switch( fperr )
   {
   case _FPE_INVALID:
       strcpy( fpstr, "Invalid number" );
       break;
   case _FPE_OVERFLOW:
       strcpy( fpstr, "Overflow" );

       break;
   case _FPE_UNDERFLOW:
       strcpy( fpstr, "Underflow" );
       break;
   case _FPE_ZERODIVIDE:
       strcpy( fpstr, "Divide by zero" );
       break;
   default:
       strcpy( fpstr, "Other floating point error" );
       break;
   }
   printf( "Error %d: %s\n", fperr, fpstr );
}

</CODE></PRE>

<P class=label><B>Output</B></P>

<PRE><CODE>Test for invalid operation - enter two numbers: 5 0
Error 131: Divide by zero

</CODE></PRE>

<P><A HREF="_crt_process_and_environment_control.htm">Process and Environment Control Routines</A></P>

<P><B>See Also</B>&nbsp;&nbsp;&nbsp;<A HREF="_crt_setjmp.htm">setjmp</A></P>
</font>
</BODY>
</HTML>
