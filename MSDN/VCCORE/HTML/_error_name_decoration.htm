<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Name Decoration</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>
<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="_error_name_decoration"></A>Name Decoration</H1>

<P>Normally this refers to C++ naming conventions, but it applies to a number of non-C++ cases as well. C++ by default will use the name of a function, its parameters and its return type when calculating a name for a function. The linker function name for </P>

<PRE><CODE>void CALLTYPE test(void)
</CODE></PRE>

<P>might come to anything in the table below depending on what CALLTYPE is and what language you are using. CALLTYPEs such as __<B>cdecl</B>, __<B>fastcall</B>, and __<B>stdcall</B> can change the naming conventions for a function/variable. </P>

<TABLE border=1 cellpadding=5 cols=3 frame=below rules=rows>

<TR VALIGN="top">
<TD class=label width=33%><B>Calling convention</B></TD>
<TD class=label width=32%><B>extern “C” or .C file</B></TD>
<TD class=label width=35%><B>.CPP , .CXX or /TP</B></TD>
</TR>

<TR VALIGN="top">
<TD width=33%>C naming convention (__<B>cdecl</B>) </TD>
<TD width=32%>_test</TD>
<TD width=35%>?test@@ZAXXZ </TD>
</TR>

<TR VALIGN="top">
<TD width=33%>Fastcall naming convention (__<B>fastcall</B>) </TD>
<TD width=32%>@test@0</TD>
<TD width=35%>?test@@YIXXZ</TD>
</TR>

<TR VALIGN="top">
<TD width=33%>Standard Call naming convention (__<B>stdcall</B>)</TD>
<TD width=32%>_test@0</TD>
<TD width=35%>?test@@YGXXZ</TD>
</TR>
</TABLE><BR>

<P>Use extern “C” when calling a C function from a C++ program. Extern “C” forces use of the C naming convention for non-class C++ functions. Be aware of compiler switches like /TP or /Tc that force a file to be compiled as a C (/Tc) or C++ (/TP) file no matter what the filename extension, or you may get different function names than you expect.</P>

<P>Having function prototypes that have mismatched parameters can also cause this error. Name decoration incorporates the parameters of a function into the final decorated function name. Calling a function with the parameter types that do not match those in the function declaration may also cause LNK2001. </P>

<P>There is currently no standard for C++ naming between compiler vendors or even between different versions of a compiler. Therefore linking object files compiled with other compilers may not produce the same naming scheme and thus causes unresolved externals.</P>
</font>
</BODY>
</HTML>
