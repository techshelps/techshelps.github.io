<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Debugging COM Clients and Servers Using RPC Debugging</TITLE>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>


<font face="verdana,arial,helvetica" size="2">
<H1><A NAME="vcrefdebuggingcomclientsserversusingrpc"></A>Debugging COM Clients and Servers Using RPC Debugging</H1>

<P>You can use RPC (remote procedure call) debugging to debug COM client/server applications. You must enable RPC debugging if you want to use it.</P>

<P class=label><B>To enable RPC debugging</B>

<OL>
	<LI>From the <B>Tools</B> menu, choose <B>Options</B>.<BR><BR></LI>

	<LI>In the <B>Options</B> dialog box, choose the <B>Debug</B> tab.<BR><BR></LI>

	<LI>Select the <B>Just-in-time debugging</B> check box.<BR><BR></LI>

	<LI>Select the <B>OLE RPC debugging</B> check box.
<P class=atl><B><B>Note</B></B>&nbsp;&nbsp;&nbsp;With Windows NT, you must have administrator privileges to select the <B>OLE RPC debugging</B> check box.</p></LI>

	<LI>Choose <B>OK</B>. </LI>
</OL>

<P>RPC debugging works with two types of remote procedure calls:

<UL type=disc>
	<LI>In-process<BR><BR></LI>

	<LI>Out-of-process</LI>
</UL>

<P>When the client you are debugging steps into an in-process remote procedure call, the debugger steps into the server code. If the in-process server runs on a different thread, the debugger switches focus to the server thread.</P>

<P>When the client you are debugging steps into an out-of-process remote procedure call, RPC debugging launches (or activates) a second instance of the debugger to handle the COM server you are stepping into. Similarly, when you are debugging a server that returns to the client, RPC debugging launches or activates an instance of the debugger for the client. </P>

<P>In either case (in-process or out-of-process), the debugger opens the source code for the server, if the source code is available. If the source code is not available, the debugger presents the disassembled object code in the Disassembly window. </P>

<P>If you are debugging a server and choose the <B>Step Out</B> command, the debugger returns to the client side.&nbsp; </P>

<P>Consider the following example. Suppose you have a COM server with an interface like this:</P>

<PRE><CODE>interface ISimpleServer {

   HRESULT Method1(
      IN int   n
      );
};</CODE></PRE>

<P>The client looks like this:</P>

<PRE><CODE>   ISimpleServer*   server = NULL;

   //
   // server = CoCreateInstance (... SIMPLE_SERVER );
   
   hr = server-&gt;Method1 (100);
   
   if (FAILED (hr))
   .
   .
   .</CODE></PRE>

<P>And the server looks like this:</P>

<PRE><CODE>HRESULT
CSimpleServer::Method1(
   int   n
   )
{
    char buffer [256];
    
    sprintf (buffer, ""n is %d\n", n);
    OutputDebugString (buffer);
}         </CODE></PRE>

<P>With RPC debugging enabled, you might set a breakpoint on this line from the client application:</P>

<PRE><CODE>   hr = server-&gt;Method1 (100);
</CODE></PRE>

<P>When the debugger reaches the breakpoint, you can choose <B>Step Into</B>. This command causes the debugger to step into the first line of CSimpleServer::Method1:</P>

<PRE><CODE>    char buffer [256];
</CODE></PRE>

<P>If you then choose <B>Step Out</B>, control returns to the client on the next line of code:</P>

<PRE><CODE>   if (FAILED (hr))
</CODE></PRE>
</font>
</BODY>
</HTML>
