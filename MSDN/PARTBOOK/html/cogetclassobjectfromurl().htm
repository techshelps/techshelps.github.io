<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CoGetClassObjectFromURL()</title>
<style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000 dir=ltr>
<h1><a name="cogetclassobjectfromurl()"></a>CoGetClassObjectFromURL()</h1>
<p>
Like <b><code>CoGetClassObject()</code></b>, this function will return a class factory interface for a specified CLSID. The object instance will be created if it's already installed locally. If necessary, this routine will also download and install the code from the specified URL. If the URL points to an uncompressed <b><code>.OCX</code></b>, <b><code>.DLL</code></b>, (<b><code>.CLASS</code></b> for Java) or <b><code>.EXE</code></b> file, the component is registered locally after download and the object factory instance will be created. If the URL points to a <b><code>.INF</code></b> file, the instruction within the <b><code>.INF</code></b> file will be followed to either download more URL based files, or install and download more components. If the URL is a compressed <b><code>.CAB</code></b> file, the file is decompressed and authenticated (via call to <b><code>WinVerifyTrust()</code></b>) with its embedded digital signature; the decompressed contents are then treated as if they are freshly downloaded COM servers or an <b><code>.INF</code></b> file as described above. This API is server agnostic, it will work with any web servers, not just the Microsoft IIS.</p>
<p>
It's also possible to call without a specified CLSID, in this case, the content type parameter determines the CLSID of the executable to use in interpreting or displaying the specific MIME type. The MIME type to CLSID mapping is kept in the local registry directly under the key: </p>
<p>
<b><code>\HKEY_CLASSES_ROOT\MIME\Database\ContentType</code></b></p>
<p>
Using the MIME type feature is a way for the system to associate a specific default executable to deal with a specific multimedia data type. For example, if the content is a music file in MIDI <b><code>.MID</code></b> format, the associated executable may be the Media Player applet.</p>
<p>
The call prototype for <b><code>CoGetClassObjectFromURL()</code></b> is:</p>
<pre><code>STDAPI CoGetClassObjectFromURL( REFCLSID rclsid,
                                LPCWSTR szCodeURL,
                                DWORD dwFileVersionMS,
                                DWORD dwFileVersionLS,
                                LPCWSTR szContentTYPE, 
                                LPBINDCTX pBindCtx,
                                DWORD dwClsContext,
                                LPVOID pvReserved,
                                REFIID riid,
                                VOID **ppv );</code></pre>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=blue width=270><b>Parameter</b></td>
<td class=blue width=270><b>Description</b></td>
</tr>
<tr valign=top>
<td width=270><b><code>rclsid</code></b></td>
<td width=270>A pointer to the CLSID of the object instance to be created. It can contain <b><code>NULL</code></b>, in which case the <b><code>szContentTYPE</code></b> will be used to determine what to instantiate.</td>
</tr>
<tr valign=top>
<td width=270><b><code>szCodeURL</code></b></td>
<td width=270>A wide-string indicating the URL of the code for the COM object. As mentioned above, it can be a <b><code>.CAB</code></b>, <b><code>.INF</code></b>, <b><code>.OCX</code></b>, <b><code>.DLL</code></b>, <b><code>.CLASS</code></b> or <b><code>.EXE</code></b> file.</td>
</tr>
<tr valign=top>
<td width=270><b><code>dwFileVersionMS</code></b></td>
<td width=270>The most significant word of the version number (usually the major version number).</td>
</tr>
<tr valign=top>
<td width=270><b><code>dwFileVersionLS</code></b></td>
<td width=270>The least significant word of the version number (usually the minor version number).</td>
</tr>
<tr valign=top>
<td width=270><b><code>szContentType</code></b></td>
<td width=270>A wide-string containing the MIME content type description string. It's used to determine the CLSID to instantiate in cases where the <b><code>rclsid</code></b> parameter contains <b><code>NULL</code></b>. For example, <b><code>szContentType</code></b> may contain <b><code>audio/x-wav</code></b> which will cause the sound recorder applet to be instantiated.</td>
</tr>
<tr valign=top>
<td width=270><b><code>pBindCtx</code></b></td>
<td width=270>Pointer to a bind context that is passed in. Note that if the client is interested in receiving status information during the download (i.e. if the link is slow), a callback should be registered with the bind context. We'll explain what a bind context is later on in this section.</td>
</tr>
<tr valign=top>
<td width=270><b><code>dwClsContext</code></b></td>
<td width=270>A value from the <b><code>CLSCTX</code></b> enumeration specifying the execution context of the object (i.e. <b><code>CLSCTX_INPROC_SERVER</code></b>, <b><code>CLSCTX_INPROC_HANDLER</code></b>, or <b><code>CLSCTX_LOCAL_SERVER</code></b>).</td>
</tr>
<tr valign=top>
<td width=270><b><code>pvReserved</code></b></td>
<td width=270>Set this to <b><code>NULL</code></b>.</td>
</tr>
<tr valign=top>
<td width=270><b><code>riid</code></b></td>
<td width=270>Pointer to the IID of the initial interface to ask for, almost always <b><code>IClassFactory</code></b>.</td>
</tr>
<tr valign=top>
<td width=270><b><code>ppv</code></b></td>
<td width=270>An output value, a pointer to an interface pointer which will be set to point at the requested interface from the new object instance.</td>
</tr>
</table><br>
<p>
The possible return values from <b><code>CoGetClassObjectFromURL()</code></b> are:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=blue width=143><b>Return Value</b></td>
<td class=blue width=397><b>Description</b></td>
</tr>
<tr valign=top>
<td width=143><b><code>S_OK</code></b></td>
<td width=397>The <b><code>ppv</code></b> return value now contains the requested interface. </td>
</tr>
<tr valign=top>
<td width=143><b><code>E_NOINTERFACE</code></b></td>
<td width=397>Cannot obtain the requested interface. </td>
</tr>
<tr valign=top>
<td width=143><b><code>REGDB_E_READREGDB</code></b></td>
<td width=397>Error encountered when accessing the registry.</td>
</tr>
<tr valign=top>
<td width=143><b><code>CO_E_ERRORINDLL</code></b></td>
<td width=397>The <b><code>.DLL</code></b> or <b><code>.EXE</code></b> image has problems.</td>
</tr>
<tr valign=top>
<td width=143><b><code>CO_E_APPDIDNTREG</code></b></td>
<td width=397>The local server was started but it did not register any class objects.</td>
</tr>
<tr valign=top>
<td width=143><b><code>E_ACCESSDENIED</code></b></td>
<td width=397>General access failure.</td>
</tr>
<tr valign=top>
<td width=143>MK_S_ASYNCHRONOUS</td>
<td width=397>Asynchronous completion. If the client has registered a callback, it will be called to update status.</td>
</tr>
</table><br>
<h2>Asynchronous and URL Monikers</h2>
<p>
We'll now explain the <b><code>pBindCtx</code></b> parameter and the <b><code>E_PENDING</code></b> return value. These parameters are supporting the <b>asynchronous</b> nature of the <b><code>CoGetClassObjectFromURL()</code></b> call. Under the hood, the <b><code>CoGetClassObjectFromURL()</code></b> call makes use of a COM facility called a <b>URL Moniker</b> to do its magic. The URL Moniker is actually an instance of a concept known as an <b>Asynchronous Moniker</b> defined by the Internet Addendum to the OC96 specifications. The following is the conceptual inheritance tree.</p>
<p>
<img src="03750905.gif" border=0></p>
<p>
First, we must give a quick explanation of what a Moniker is. Monikers are essentially 'smart name objects' in COM. Any COM object that implements the <b><code>IMoniker</code></b> interface is deemed a Moniker. The unique property of a Moniker (usually a relatively small object) is that it knows how to find the object that it names. It also completely hides from the client how it goes about finding the object. By 'binding' to a Moniker, we magically get the object that it names. Monikers provide a level of indirection between the client of an object and the object itself. This level of indirection provides unlimited extensibility because the Moniker isn't obliged to follow any standard rules or protocols when it goes about its binding operation. In the old days, Monikers were used almost exclusively for OLE linking operations. In this context, embedding means to embed an entire object into a document while linking means embedding a Moniker (much smaller object) into the document. It's easy to throw Monikers into compound documents (or any arbitrary file) because <b><code>IMoniker</code></b> is derived from <b><code>IPersistStream</code></b>, which supports serialization of the Moniker to memory, disk, or even across a network.</p>
<p>
Asynchronous Monikers are a relatively new breed introduced to solve the problems produced by operations over a slow Internet link. Unlike its age-old parent, the binding operation on an Asynchronous Moniker can take as long as it wants. Meanwhile, the client invoking the binding operation gets freed to do other things right away. If the client registers a callback function with the Asynchronous Moniker, the Moniker will report back status information as it's performing the binding operation.</p>
<p>
A URL Moniker is a specific implementation of an Asynchronous Moniker. We know how it does its magic. Since a URL Moniker is a name (URL in this case) that knows how to find the object that it represents (i.e. an ActiveX control stored on the web server), we can deduce that the URL Moniker will be using HTTP to fetch the object over the network. And this is indeed how it's done. Of course, if the URL should be <b><code>ftp://ftp.abwil.com/objects/atldept.dll</code></b>, then alternative protocols would be used (again, transparent to the client since the Moniker performs all the magic). Since the going rate for asynchronous modems is 28.8Kbps, we can quickly understand why a URL Moniker must be asynchronous. We certainly don't want to hold the client (and thus the application) in a frozen blocked state while a URL Moniker is finishing its magical binding effort.</p>
<p>
The current implementation of URL Monikers uses standard Win32 Internet APIs (formerly called WinINET) to access the actual resources, this allows security proxies to work transparently underneath.</p>
<p>
It's quite easy to see that our <b><code>CoGetClassObjectFromURL()</code></b> call is using URL Monikers underneath to do its dirty work. This is where the <b><code>BindCtx</code></b> requirement comes from. A bind context is just a small COM object that's passed into a Moniker during a bind operation. It functions as a client-supplied instance-identification 'scratch pad'. While not always necessary, you may want to receive status feedback during the asynchronous process, and then there's substantially more work to be done. You can easily create a bind context by making the <b><code>CreateBindCtx()</code></b> call. The interface that you grab a bind context object by is, not surprisingly, called <b><code>IBindCtx</code></b>. The <b><code>IBindCtx</code></b> interface comprises 13 methods altogether, including the three required by <b><code>IUnknown</code></b>. We aren't actually interested in any of these methods. There exists a (new!) helper function, called <b><code>RegisterBindStatusCallback()</code></b>, which will do our callback registration for us. The usage of <b><code>RegisterBindStatusCallback()</code></b> is:</p>
<pre><code>HRESULT RegisterBindStatusCallback( IBindCtx *pbc,
                                    IBindStatusCallback *pbsc,
                                    IBindStatusCallback **ppbscPrevious,
                                    DWORD dwReserved ); </code></pre>
<p>
The parameters required are:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=blue width=115><b>Parameter</b></td>
<td class=blue width=425><b>Description</b></td>
</tr>
<tr valign=top>
<td width=115><b><code>pbc</code></b></td>
<td width=425>Pointer to the <b><code>IBindCtx</code></b> of our bind context object.</td>
</tr>
<tr valign=top>
<td width=115><b><code>pbsc</code></b></td>
<td width=425>Pointer to an <b><code>IBindStatusCallback</code></b> of a bind status callback object to be registered. We'll discuss how to create this later.</td>
</tr>
<tr valign=top>
<td width=115><b><code>PpbscPrevious</code></b></td>
<td width=425>An output parameter which will be filled with a pointer to the previously registered <b><code>IBindStatusCallback</code></b> instance.</td>
</tr>
<tr valign=top>
<td width=115><b><code>dwReserved</code></b></td>
<td width=425>Set this to <b><code>0</code></b>.</td>
</tr>
</table><br>
<p>
The possible return values for <b><code>RegisterBindStatusCallback()</code></b> are:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=blue width=115><b>Return Value</b></td>
<td class=blue width=425><b>Description</b></td>
</tr>
<tr valign=top>
<td width=115><b><code>S_OK</code></b></td>
<td width=425>The operation has completed successfully.</td>
</tr>
<tr valign=top>
<td width=115><b><code>E_INVALIDARG</code></b></td>
<td width=425>An argument passed was invalid.</td>
</tr>
<tr valign=top>
<td width=115><b><code>E_OUTOFMEMORY</code></b></td>
<td width=425>The operation can't be performed because memory was exhausted during its execution.</td>
</tr>
</table><br>
<p>
The use of the function is straightforward, except for the <b><code>IBindStatusCallback</code></b> pointer that we need. Typically, the <b><code>ppbscPrevious</code></b> returned will be <b><code>NULL</code></b> since it will be the first <b><code>IBindStatusCallback</code></b> that we register for this bind context. Once we've registered an <b><code>IBindStatusCallback</code></b> with a bind context, it would last until it's revoked by <b><code>RevokeBindStatusCallback()</code></b>, displaced by a new one through another <b><code>RegisterBindStatusCallback()</code></b> call, or the bind context itself is destroyed.</p>
<p>
The <b><code>IBindStatusCallback</code></b> pointer should be pointing to an interface that the client (or an object that the client controls) would implement. The <b><code>IBindStatusCallback</code></b> interface consists of a total of 11 methods, including the three <b><code>IUnknown</code></b> methods. These methods are: </p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=blue width=248><b><code>IBindStatusCallBack</code> Method Name</b></td>
<td class=blue width=292><b>Description</b></td>
</tr>
<tr valign=top>
<td width=248><b><code>QueryInterface()</code></b></td>
<td width=292>Standard <b><code>IUnknown</code></b> requirement. Make sure that a query for <b><code>ICodeInstall</code></b> will return the client’s <b><code>ICodeInstall</code></b> interface (see below).</td>
</tr>
<tr valign=top>
<td width=248><b><code>AddRef()</code></b></td>
<td width=292>Standard <b><code>IUnknown</code></b> requirement.</td>
</tr>
<tr valign=top>
<td width=248><b><code>Release()</code></b></td>
<td width=292>Standard <b><code>IUnknown</code></b> requirement.</td>
</tr>
<tr valign=top>
<td width=248><b><code>GetBindInfo()</code></b></td>
<td width=292>Called by the Moniker to get binding information.</td>
</tr>
<tr valign=top>
<td width=248><b><code>OnStartBinding()</code></b></td>
<td width=292>A chance for the client to tell the Moniker which events/callback the client is interested in. Also provides the client with an <b><code>IBinding</code></b> interface for the client to control downloading.</td>
</tr>
<tr valign=top>
<td width=248><b><code>GetPriority()</code></b></td>
<td width=292>Obtains the priority of this binding operation.</td>
</tr>
<tr valign=top>
<td width=248><b><code>OnProgress()</code></b></td>
<td width=292>Reports progress to the client.</td>
</tr>
<tr valign=top>
<td width=248><b><code>OnDataAvailable()</code></b></td>
<td width=292>Reports the incremental availability of data.</td>
</tr>
<tr valign=top>
<td width=248><b><code>OnObjectAvailable()</code></b></td>
<td width=292>The requested object interface pointer is passed to the client.</td>
</tr>
<tr valign=top>
<td width=248><b><code>OnLowResource()</code></b></td>
<td width=292>The Moniker reports a low resource condition during the bind.</td>
</tr>
<tr valign=top>
<td width=248><b><code>OnStopBinding()</code></b></td>
<td width=292>Notification that the binding operation has completed, and returns error code if any.</td>
</tr>
</table><br>
<p>
&nbsp;</p>
<p>
It's safe to return <b><code>E_NOTIMPL</code></b> for the <b><code>GetPriority()</code></b>, and <b><code>OnDataAvailable()</code></b> members in most cases.</p>
<p>
If we're supporting automatic installation of a component (i.e. through registry update or an <b><code>.INF</code></b> file), we must also implement the <b><code>ICodeInstall</code></b> interface. The Moniker will do a <b><code>QueryInterface()</code></b> on <b><code>IBindStatusCallback</code></b> for <b><code>ICodeInstall</code></b>. The <b><code>ICodeInstall</code></b> interface has a total of only 5 methods. The client must implement this interface. </p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=blue width=200><b><code>ICodeInstall</code> Method Name</b></td>
<td class=blue width=340><b>Description</b></td>
</tr>
<tr valign=top>
<td width=200><b><code>QueryInterface()</code></b></td>
<td width=340>Standard <b><code>IUnknown</code></b> requirement.</td>
</tr>
<tr valign=top>
<td width=200><b><code>AddRef()</code></b></td>
<td width=340>Standard <b><code>IUnknown</code></b> requirement.</td>
</tr>
<tr valign=top>
<td width=200><b><code>Release()</code></b></td>
<td width=340>Standard <b><code>IUnknown</code></b> requirement.</td>
</tr>
<tr valign=top>
<td width=200><b><code>NeedVerificationUI()</code></b></td>
<td width=340>Called when the server needs to display a verification window. The client should supply a parent window in this case.</td>
</tr>
<tr valign=top>
<td width=200><b><code>OnCodeInstallProblem()</code></b></td>
<td width=340>Called when server encounters code installation problem (i.e. out of disk space). The client may attempt to correct the situation by prompting the user accordingly.</td>
</tr>
</table><br>
<p>
By supporting a callback in our bind context for the asynchronous (URL) moniker, we gain a lot of control over the display of status during the binding process, as well as the ability to customize system-displayed UI and handle error conditions during the code installation process.</p>
<p>
There exists also an asynchronous moniker specific function, called <b><code>CreateAsyncBindCtx()</code></b> which combines the function of <b><code>RegisterBindStatusCallback()</code></b> and <b><code>CreateBindCtx()</code></b> into one convenient call.</p>
<pre><code>HRESULT CreateAsyncBindCtx( DWORD dwReserved, 
                            IBindStatusCallback *pbsc, 
                            IEnumFORMATETC *penumfmtetc, 
                            IBindCtx **ppbc );</code></pre>
<p>
The parameters required are:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=blue width=115><b>Parameter</b></td>
<td class=blue width=425><b>Description</b></td>
</tr>
<tr valign=top>
<td width=115><b><code>dwReserved</code></b></td>
<td width=425>Must be zero.</td>
</tr>
<tr valign=top>
<td width=115><b><code>pbsc</code></b></td>
<td width=425>Pointer to an <b><code>IBindStatusCallback</code></b> of a bind status callback object to be registered.</td>
</tr>
<tr valign=top>
<td width=115><b><code>penumfmtetc</code></b></td>
<td width=425>Pointer to an <b><code>IEnumFORMATETC</code></b> of an enumerator object for format negotiation during binding, should be set to <b><code>NULL</code></b> for URL moniker binding through the <b><code>CoGetClassObjectFromURL()</code></b> call.</td>
</tr>
<tr valign=top>
<td width=115><b><code>ppbc</code></b></td>
<td width=425>Pointer to hold the <b><code>IBindCtx</code></b> pointer for the newly created bind context object.</td>
</tr>
</table><br>
<p>
The possible return values for <b><code>CreateAsyncBindCtx()</code></b> are:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=blue width=115><b>Return Value</b></td>
<td class=blue width=425><b>Description</b></td>
</tr>
<tr valign=top>
<td width=115><b><code>S_OK</code></b></td>
<td width=425>The operation has completed successfully.</td>
</tr>
<tr valign=top>
<td width=115><b><code>E_INVALIDARG</code></b></td>
<td width=425>An argument passed was invalid.</td>
</tr>
<tr valign=top>
<td width=115><b><code>E_OUTOFMEMORY</code></b></td>
<td width=425>The operation can't be performed because memory was exhausted during its execution.</td>
</tr>
</table>
</BODY>
</HTML>
