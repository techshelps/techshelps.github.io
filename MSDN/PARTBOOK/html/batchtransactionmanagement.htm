<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Batch and Transaction Management</title>
<style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000 dir=ltr>
<h1><a name="batchtransactionmanagement"></a>Batch and Transaction Management</h1>
<p>
Perhaps the most compelling reason to use a batch SQL approach is the need for a finer level of transaction control. When using an Access database with a single user, transaction management is a minor concern at best. However, when multiple users are accessing a data source, with the potential of simultaneous updates, transaction management can have a huge impact on the performance and reliability of SQL Server.</p>
<p>
In the previous example, the transaction is committed to the server—i.e. the changes are actually applied to the data—as soon as it is executed. In many cases this is perfectly acceptable. However, if we need a finer level of control over when a transaction is committed, either for performance reasons or due to dependencies between records, we can choose to define the beginning and the end of each transaction.</p>
<p>
We looked briefly at transactions in the previous chapter. To define the beginning and end of transaction, we use the <b><code>BeginTrans</code></b> and <b><code>CommitTrans</code></b> methods of the <b><code>Connection</code></b> object: </p>
<pre><code>Conn.BeginTrans 
Conn.Execute SQLQuery, lRecs
Conn.CommitTrans</code></pre>
<p>
Here we explicitly define the beginning of a transaction. By doing so, the underlying ODBC provider will no longer automatically commit a transaction. To apply changes to a database, the <b><code>Connection</code></b> object's <b><code>CommitTrans</code></b> method is called. If an error occurs, the <b><code>RollbackTrans</code></b> method is available. <b><code>RollbackTrans</code></b> will 'undo' any changes made as a result of the SQL that has been submitted since the last <b><code>CommitTrans</code></b> was called. </p>
<h2>Things to Consider When Using Transactions</h2>
<p>
To get the maximum performance when using transaction statements to process database records, we need to structure them well. The following is a list of guidelines that may be helpful as you experiment with transactions:</p>
<ul type=disc>
<li>
Keep the transaction processing blocks as short as possible. Remember that as long as a transaction is open on a series of records (especially in the case of an update), other people cannot access or change them. For example: <br><br></li>
<li>
<pre><code>Conn.BeginTrans
  Statement1...
  Statement2...
  Statement3...
  Statement4...  '*** If you have a number of statements,
                 '*** you could slow processing and increase 
                 '*** the chance of errors occurring.
Conn.CommitTrans  (or RollbackTrans)</code></pre>
</li>
<li>
When working with transaction statements, don’t create a new connection or perform further database processing until the transaction is complete. Jumping out of an open transaction can lead to contention and lockout conditions: <br><br></li>
<li>
<pre><code>Conn.BeginTrans
  Statement1...
  Statement2...

  '*** Don’t create a new transaction within an open tranaction

  Set RS = Server.CreateObject("ADODB.RecordSet")
  RS.Open "select * from Message", DBConn, 3, 1, 2
  If NOT RS.EOF Then 
    Statement3...
    Statement4...
  End if
Conn.CommitTrans  (or RollbackTrans)</code></pre>
</li>
<li>
When working with a <b><code>Recordset</code></b> object, don't refresh the object in the middle of a series of transactions. Doing so will create the "Attempt to Commit or Rollback without BeginTrans" error:<br><br></li>
<li>
<pre><code>Conn.BeginTrans
  Statement1...
  If UserReset Then 
    Rs.Refresh  '*** Can cause an error
  End If 
  Statement2...
  Statement3...
Conn.CommitTrans  (or Rollback)</code></pre>
</li>
<li>
When using transactions to control server updates, don't execute a <b><code>Close</code></b> in the middle of a transaction. This can lead to problems when attempting to commit the transaction:<br><br></li>
<li>
<pre><code>Conn.BeginTrans
  Statement1
  If Error
    db.Close  '*** Commit will fail after this
  End If
  Statement2...
  Statement3...
Conn.CommitTrans  (or Rollback)</code></pre>
</li>
</ul>
<p>
As you can see, we can now specify when and under what conditions data is applied to our data server. In addition, and perhaps more importantly, we can undo these changes at any point in the process. </p>
</BODY>
</HTML>
