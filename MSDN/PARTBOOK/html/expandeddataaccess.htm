<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Expanded Data Access</title>
<style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000 dir=ltr>
<h1><a name="expandeddataaccess"></a>Expanded Data Access</h1>
<p>
The ADO is a collection of objects that expose a standard set of properties and methods that our applications can use when accessing data. Like many of its predecessors, such as DAO and RDO, ADP relies on an underlying layer of software to actually interact with a given data source. As we saw in the last chapter, <b>OLE</b> <b>DB</b> is this underlying layer.</p>
<p>
OLE DB technology is being positioned as the cornerstone to Microsoft's component database architecture. It is a set of OLE interfaces that provide applications with a standard means of accessing data stored in various information sources. These standard interfaces support specific elements of the Database Management System's (DBMS) functionality that are appropriate to the data source, enabling it to share its data.</p>
<p>
The benefits of component DBMS's can be seen in the success of the <b>Open</b> <b>Database</b> <b>Connectivity</b> (ODBC) database access interface. ODBC is provided as a means of accessing data from a diverse set of sources, using a standard series of functions and commands, the idea being that the programmer is shielded from having to code to each specific data source’s requirements, thus vastly increasing productivity. </p>
<p>
OLE DB takes ODBC a step further, towards a truly standard means of accessing data from diverse sources. Whereas ODBC is designed around accessing relational data sources using Structured Query Language (SQL), OLE DB is focused on providing access to <i>any</i> data, anywhere. For example, an ODBC provider has just been released that provides access to NT 4, Novell version 3, and NDS directory services, all through OLE DB. And there are more to come.</p>
<p>
In addition to simplifying the programmer’s job, the OLD DB interface layer provides the developer with a means of accessing data which may not be stored in a traditional DBMS format. As we all know, there is a large amount of mission-critical data stored in systems that are not classified as a DBMS. One of the most significant limitations of the ODBC approach to data access is that it is difficult for non-relational database vendors to support. Building a data provider layer means exposing the data via SQL. For a non-SQL data provider, such as an Excel file or a Mail system, this requires the equivalent of a SQL engine within the ODBC driver.</p>
<p>
OLE DB simplifies the development of access methods for simple tabular data providers by only requiring them to implement the functionality native to their data source. At a minimum, an access provider must implement the interfaces necessary to expose data in a tabular form. This requirement allows for the development of query processor components, such as SQL query processors, that can work with tabular information from any provider that exposes its data through OLE DB. In essence then, OLE DB provides an interface layer that is consistent despite its having an underlying data structure that may be very diverse. </p>
<p>
<img src="07235_01.gif" border=0></p>
<h2>OLE DB and the ADO</h2>
<p>
As we have seen, OLE DB is a collection of components that work together to provide data access capabilities to an application. These components are loosely grouped into two classes, <b>consumers</b> and <b>providers</b>. Consumers are the components that submit requests for data. Providers service these requests by accessing the data sources, and retrieving the information requested. In these terms, ADO is an OLE DB consumer. In other words, it makes requests to a provider. The name of the provider that will service a request is supplied either as a part of a <b>connection</b> <b>string</b>, or as the <b><code>Provider</code></b> property of the <b><code>Connection</code></b> object. </p>
<p>
In this example, we supply the name of the Microsoft ODBC provider for OLE DB and the ADO, <b><code>MSDASQL</code></b>, as a parameter to the <b><code>Provider</code></b> method of the <b><code>Connection</code></b> object.</p>
<pre><code>Set DBConn = Server.CreateObject("ADODB.Connection")
DBConn.Provider ="MSDASQL"
DBConn.Open "DSN=SQLForum;UID=sa;PWD=;"
Set Session("DBConn") = DBConn</code></pre>
<p class=indent>
Be careful not to include a <b><code>Provider</code></b> <b><code>Name</code></b> as both a part of the connection string, and as the <b><code>Provider</code></b> property of the <b><code>Connection</code></b> object. If you do, the result is unpredictable. </p>
<p>
Providers, like any other OLE object, must be defined in the registry before the OLE DB layer can use them. They are identified by the OLE DB Provider sub-key, under the class ID of the provider. Within the HKEY_CLASSES_ROOT key, providers must have the following sub-keys and values for the programmatic identifier (<b><code>ProgID</code></b>):</p>
<pre><code><b><i>ProviderProgID</i></b> = <b><i>FriendlyDisplayName</i></b>
<b><i>ProviderProgID</i></b>\CLSID = <b><i>ProviderCLSID</i></b></code></pre>
<p>
The entries for the <b><code>MSDASQL</code></b> ODBC provider are show here—the CLSID value is a unique key that identifies the provider installed:</p>
<pre><code>MSDASQL = Microsoft OLE DB Provider for ODBC Drivers
MSDASQL\CLSID = {c8b522cb-5cf3-11ce-ade5-00aa0044773d}</code></pre>
<p>
Under the HKEY_CLASSES_ROOT\CLSID sub-key, providers must have the following sub-keys and values:</p>
<pre><code><b><i>ProviderCLSID</i></b> = <b><i>FriendlyDisplayName</i></b>
<b><i>ProviderCLSID\ProgID</i></b> = <b><i>ProviderProgID</i></b>
<b><i>ProviderCLSID</i></b>\VersionIndependentProgID = <b><i>VersionIndependentProgID</i></b>
<b><i>ProviderCLSID</i></b>\InprocServer32 = <b><i>ProviderDLLFilename</i></b>
<b><i>ProviderCLSID</i></b>\InprocServer32\ThreadingModel = Apartment | Free | Both
<b><i>ProviderCLSID</i></b>\OLE DB Provider = <b><i>Description</i></b></code></pre>
<p>
Again, the entries for the <b><code>MSDASQL</code></b> ODBC provider are:</p>
<pre><code>{c8b522cb-5cf3-11ce-ade5-00aa0044773d} = MSDASQL
{c8b522cb-5cf3-11ce-ade5-00aa0044773d}\VersionIndependentProgID  = MSDASQL
{c8b522cb-5cf3-11ce-ade5-00aa0044773d}\InprocServer32 = MSDASQL.DLL
{c8b522cb-5cf3-11ce-ade5-00aa0044773d}\InprocServer32\ThreadingModel =
                                                                   ? Both
{c8b522cb-5cf3-11ce-ade5-00aa0044773d}\OLE DB Provider = Microsoft OLE DB
                                              ? Provider for ODBC Drivers</code></pre>
<p>
In addition, the ODBC provider entry references a second key that points to another OLE object, which is used for error processing. Other providers are identified in the registry in this same way. Thankfully, the installation of ADO provides all the registry entries required, but you'll find the information here useful if you need to delve into the registry yourself.</p>
<h2>Connecting to a Data Source</h2>
<p>
Let’s take a moment to look at how we connect to various data sources. The ADO provides a number of ways of actually establishing a connection to a data source. Each has its advantages and disadvantages but, underneath the covers, each is limited by the ability of the provider to service the connection. As we walk through various examples, keep in mind that some of the features discussed may only be appropriate for the provider being used in that example. </p>
<h3>The Connection Object</h3>
<p>
In the previous chapter, we reviewed how the <b><code>Connection</code></b> object is used to create a connection between an ASP page and a data source. Now let's look in more detail at the <b><code>Connection</code></b> object and at some of the more advanced options we can take use when connecting to and working with various data sources, including SQL Server. </p>
<p>
The <b><code>Connection</code></b> object is the parent object in a hierarchy of several other objects including the <b><code>Errors</code></b> object, <b><code>Command</code></b> object and <b><code>Recordset</code></b> object. The <b><code>Connection</code></b> object can be used to create a new connection to a data source, by providing it with a connection string or connection information. This connection can then be referenced by each of the other objects in the hierarchy to interact with the described data source. </p>
<pre><code>Set DBConn = Server.CreateObject("ADODB.Connection")
DBConn.Provider="MSDASQL"
DBConn.Open "DSN=SQLForum; UID=sa; PWD=; APP=Forum; WSID=MAINFRAME;
                                                  ? Database=Forum"
Set Session("DBConn") = DBConn</code></pre>
<p>
However, unlike the DAO and RDO libraries, the ADO doesn't require you to work your way down a hierarchy of objects in order to instantiate the one you actually require. The <b><code>Command</code></b> and <b><code>Recordset</code></b> objects can be called independently of any <b><code>Connection</code></b> object, allowing these objects to create a new <b><code>Connection</code></b> directly and interact with the database through it: </p>
<pre><code>Set oRS = Server.CreateObject("ADODB.RecordSet")
oRS.Open "Select * from Message", "DSN=SQLForum;UID=sa;PW="
Response.Write "&lt;B&gt; Records Found: &lt;/B&gt;&lt;P&gt;"
Do While Not oRS.EOF
  For intCount = 0 to oRS.Fields.Count -1
    Response.Write oRS.Fields(intCount).Value &amp; " - " 
  Next 
  Response.Write "&lt;BR&gt;" 
  oRS.MoveNext 
Loop</code></pre>
<p>
In this example, we create a simple listing of each record in the <b><code>Message</code></b> table. You will notice that no <b><code>Connection</code></b> object is explicitly created, we simply create a <b><code>Recordset</code></b> with the <b><code>Open</code></b> method of the <b><code>Recordset</code></b>, using an SQL query and a connection string. Behind the scenes, ADO creates a <b><code>Connection</code></b> object and associates it with the <b><code>Recordset</code></b> we just created. When the <b><code>Recordset</code></b> goes out of scope or is set to <b><code>Nothing</code></b>, the <b><code>Connection</code></b> object is released. </p>
<p>
Let's take another example. Here we need to call an SQL Server Stored Procedure only once per session. Rather then opening a <b><code>Connection</code></b> object, and passing a reference to it to a <b><code>Command</code></b> object, we can take advantage of the <b><code>Command</code></b> object’s ability to create a <b><code>Connection</code></b> object for us automatically in the background:</p>
<pre><code>Set oCmd = Server.CreateObject("ADODB.Command")
oCmd.ActiveConnection = "dsn=SQLForum;database=Forum;uid=sa;pwd=;"
oCmd.CommandText = "{call myproc}"
oCmd.Execute</code></pre>
<p>
In the above example, we supply a connection string to the <b><code>Open</code></b> method of the object. The connection string is passed directly to the underlying ODBC driver, which in turn uses it to attach to the specified data source. Here a connection object is created for temporary use and destroyed when the <b><code>oCmd</code></b> object variable goes out of scope, or is set to <b><code>Nothing</code></b>.</p>
</BODY>
</HTML>
