<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Creating Bitmaps for Our Control</title>
</HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<font face="verdana, arial, helvetica" size="2"><h1><a name="creatingbitmapsforourcontrol"></a>Creating Bitmaps for Our Control</h1>
<p>
We want our control to display a cloudy day before it is pressed (when the button is up), and a sunny day when it is pressed (when the button is down). To do that, we&#39;ll create the customized button bitmaps IDB_UPBITMAP (cloudy day) and IDB_DOWNBITMAP (sunny day). We select the Visual C++ Insert|Resource menu item and select Bitmap in the Insert Resource box that appears. This action opens the bitmap editor, as shown in Figure 9.6.</p>
<p>
<img src="fig09-06.gif" border=0></p>
<p>
<b>Figure 9.6&nbsp; We design a custom bitmap.</b></p>
<p>
This new bitmap has the default ID IDB_BITMAP1; change that to IDB_UPBITMAP using the bitmap&#39;s property page. Open that page by selecting Properties in the Visual C++ Edit menu. This opens the property page for the bitmap, and you can change the bitmap&#39;s ID directly. Next, draw a representation of a cloudy day in the IDB_UPBITMAP bitmap, as shown in Figure 9.6. Similarly, create a new bitmap with the ID IDB_DOWNBITMAP and draw a sunny day in it.</p>
<p>
The customized images for CONTROL are now ready. Using these bitmaps, we&#39;ll see how to change the control&#39;s appearance. We will also have access to all the events a button normally has, such as click events, in ClassWizard. We&#39;ll also see how to add customized events, properties, and methods to control.ocx and how to install our new control in a Visual C++ program.</p>
<p>
As before, the control support file, CONTROLCTL.CPP, will be the most important. Here is how our control is created, based on the Windows button control (from CONTROLCTL.CPP). Note that the program derives this control from the Windows button type.</p>
<pre><code>BOOL CControlCtrl::PreCreateWindow(CREATESTRUCT&amp; cs)
{
    cs.lpszClass = _T(&#34;BUTTON&#34;);
    return COleControl::PreCreateWindow(cs);
}</code></pre>
<p>
We want to draw the button, so we will modify this code a little. PreCreateWindow() is called when our control is first created, and we are passed a reference to a creation structure (a structure of type CREATESTRUCT). One of the members of this creation structure is the style member, which holds the style of the control we are creating. We OR the button style with two new button styles: BS_PUSHBUTTON and BS_OWNERDRAW.</p>
<pre><code>BOOL CControlCtrl::PreCreateWindow(CREATESTRUCT&amp; cs)
{
    cs.lpszClass = _T(&#34;BUTTON&#34;);
--&gt; cs.style |= BS_PUSHBUTTON | BS_OWNERDRAW;
    return COleControl::PreCreateWindow(cs);
}</code></pre>
<p>
Using BS_OWNERDRAW means that now we are responsible for drawing the button. If we wanted to draw an unchanging control, we could place code in the OnDraw() function, and whatever we drew there would appear in our OLE control. However, we want to do more than that. We want to draw the button in both a pressed and an unpressed state as the user clicks it. This means that we will have to intercept the message that tells the button control when to show itself as pressed and when as released&mdash;which OnDraw() alone will not do.</p>
<p>
To draw an active button, we intercept the OCM_DRAWITEM message. The prefix OCM stands for OLE control message, which OLE custom controls receive (in addition to Windows messages starting with the WM_ prefix). When we receive OCM_DRAWITEM, we will get information such as whether the button is supposed to be up or down. This information will enable us to draw the button with the correct bitmap (sunny day or cloudy day).</p>
<p>
To attach a function to the OCM_DRAWITEM message, we edit the message map in CONTROLCTL.CPP directly. (ClassWizard will not work with OCM messages.) Find the message map in CONTROLCTL.CPP:</p>
<pre><code>// ControlCtl.cpp : Implementation of the CControlCtrl OLE control class.
#include &#34;stdafx.h&#34;
#include &#34;control.h&#34;</code></pre>
<p>
.</p>
<pre><code>.
        .
BEGIN_MESSAGE_MAP(CControlCtrl, COleControl)
    //{{AFX_MSG_MAP(CControlCtrl)
    ON_MESSAGE(OCM_COMMAND, OnOcmCommand)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()
        .
        .
        .</code></pre>
<p>
We intercept the OCM_DRAWITEM message by connecting it to the function OnOcmDrawItem() (add this line of code):</p>
<pre><code>// ControlCtl.cpp : Implementation of the CControlCtrl OLE control class.
#include &#34;stdafx.h&#34;
#include &#34;control.h&#34;
        .
        .
        .
BEGIN_MESSAGE_MAP(CControlCtrl, COleControl)
    //{{AFX_MSG_MAP(CControlCtrl)
    ON_MESSAGE(OCM_COMMAND, OnOcmCommand)
--&gt; ON_MESSAGE(OCM_DRAWITEM, OnOcmDrawItem)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()
        .
        .
        .</code></pre>
<p>
In addition, we add the prototype of OnOcmDrawItem() to CONTROLCTL.H (note that this function returns an argument of type LRESULT, as we&#39;ll see soon):</p>
<pre><code>// ControlCtl.h : Declaration of the CControlCtrl OLE control class.
/////////////////////////////////////////////////////////////////////////////
        .
        .
        .
    DECLARE_OLECREATE_EX(CControlCtrl)    // Class factory and guid
    DECLARE_OLETYPELIB(CControlCtrl)      // GetTypeInfo
    DECLARE_PROPPAGEIDS(CControlCtrl)     // Property page IDs
    DECLARE_OLECTLTYPE(CControlCtrl)        // Type name and misc status
    // Subclassed control support
    BOOL PreCreateWindow(CREATESTRUCT&amp; cs);
    WNDPROC* GetSuperWndProcAddr(void);
    LRESULT OnOcmCommand(WPARAM wParam, LPARAM lParam);
--&gt; LRESULT OnOcmDrawItem(WPARAM wParam, LPARAM lParam);
        .
        .
        .</code></pre>
<p>
Now create the OnOcmDrawItem() function in CONTROLCTL.CPP by typing it in:</p>
<pre><code>LRESULT CControlCtrl::OnOcmDrawItem(WPARAM wParam, LPARAM lParam)
{
}</code></pre>
<p>
As with most direct Windows message handlers, we are passed two parameters: wParam and lParam, the standard low-level parameters that accompany Windows messages. Here, lParam is a long pointer to a structure of type LPDRAWITEMSTRUCT; because this structure contains additional information about what we&#39;re supposed to be drawing, it will allow us to draw our button in both the pressed and the released states. For example, from the hDC member of the LPDRAWITEMSTRUCT structure we get a pointer to the device context we&#39;re supposed to draw in. The hDC member is actually a handle to a device context, and it is simply a numerical index standing for that device context as far as Windows is concerned. We create a pointer to the device context from hDC using the Visual C++ CDC class function FromHandle():</p>
<pre><code>LRESULT CControlCtrl::OnOcmDrawItem(WPARAM wParam, LPARAM lParam)
{
--&gt; CDC *pdc;
--&gt; pdc = CDC::FromHandle(((LPDRAWITEMSTRUCT)lParam)-&gt;hDC);
      .
      .
      .
}</code></pre>
<p>
Now that we have a pointer to the device context we want to draw in, the next step is to load the bitmap from the disk. We use the two bitmaps we created&mdash;IDB_DOWNBITMAP for the button-down bitmap and IDB_UPBITMAP for the button-up bitmap&mdash;and we load the appropriate bitmap depending on whether the button is up or down. We check the itemState member of the DRAWITEMSTRUCT structure that we were passed a pointer to. If the ODS_SELECTED bit in itemState is set, we draw the button as pressed; otherwise, we draw it as released. Based on itemState, then, we load the correct bitmap into an object of class CBitmap named bmpObj:</p>
<pre><code>LRESULT CControlCtrl::OnOcmDrawItem(WPARAM wParam, LPARAM lParam)
{
    CDC *pdc;
--&gt; CBitmap bmpObj;
    pdc = CDC::FromHandle(((LPDRAWITEMSTRUCT)lParam)-&gt;hDC);
--&gt; bmpObj.LoadBitmap((((LPDRAWITEMSTRUCT)lParam)-&gt;itemState &amp; 
        ODS_SELECTED) ? IDB_DOWNBITMAP : IDB_UPBITMAP); 
        .
        .
        .</code></pre>
<p>
At this point, we have loaded the bitmap to display into a bitmap object of the MFC class CBitmap. The next step is to display the bitmap. We need the dimensions of the bitmap, which we get by filling a structure of type BITMAP:</p>
<pre><code>typedef struct tagBITMAP { 
            int     bmType;
            int     bmWidth;
            int     bmHeight;
            int     bmWidthBytes;
            BYTE    bmPlanes;
            BYTE    bmBitsPixel;
            LPVOID  bmBits;
        } BITMAP;</code></pre>
<p>
We fill the BITMAP structure, named bmp, using the CBitmap member function GetObject():</p>
<pre><code>LRESULT CControlCtrl::OnOcmDrawItem(WPARAM wParam, LPARAM lParam)
{
    CDC *pdc;
    CBitmap bmpObj;
--&gt; BITMAP  bmp;
    pdc = CDC::FromHandle(((LPDRAWITEMSTRUCT)lParam)-&gt;hDC);
    bmpObj.LoadBitmap((((LPDRAWITEMSTRUCT)lParam)-&gt;itemState &amp; 
        ODS_SELECTED) ? IDB_DOWNBITMAP : IDB_UPBITMAP); 
--&gt; bmpObj.GetObject(sizeof(BITMAP), &amp;bmp);
        .
        .
        .</code></pre>
<p>
To determine the dimensions of the bitmap, we use the BITMAP members bmWidth and bmHeight to fill a CRect object named rect:</p>
<pre><code>LRESULT CControlCtrl::OnOcmDrawItem(WPARAM wParam, LPARAM lParam)
{
    CDC *pdc;
    CBitmap bmpObj;
    BITMAP  bmp;
--&gt; CRect rect;
    pdc = CDC::FromHandle(((LPDRAWITEMSTRUCT)lParam)-&gt;hDC);
    bmpObj.LoadBitmap((((LPDRAWITEMSTRUCT)lParam)-&gt;itemState &amp; 
        ODS_SELECTED) ? IDB_DOWNBITMAP : IDB_UPBITMAP); 
    bmpObj.GetObject(sizeof(BITMAP), &amp;bmp);
--&gt; rect.right = bmp.bmWidth;
--&gt; rect.bottom = bmp.bmHeight;
        .
        .
        .
}</code></pre>
<p>
Now we have the bitmap and its size, so all that&#39;s left is to draw it. We&#39;ll use a shortcut method: the Visual C++ class CPictureHolder. A popular property (we&#39;ll see more about properties soon) for ActiveX controls is the Picture property, which holds the image of the control. Reloading the Picture property with a new bitmap changes the appearance of the control. We won&#39;t support the picture property here, but we will use the CPictureHolder class, because it is designed to hold a control&#39;s bitmap (its graphical representation) and display it easily. Because the CPictureHolder class is specially made to work with the image of our control, we will create a CPictureHolder object here and load our bitmap into it:</p>
<pre><code>LRESULT CControlCtrl::OnOcmDrawItem(WPARAM wParam, LPARAM lParam)
{
    CDC *pdc;
    CBitmap bmpObj;
    BITMAP  bmp;
--&gt; CPictureHolder picHolderObj;
    CRect rect;
    pdc = CDC::FromHandle(((LPDRAWITEMSTRUCT)lParam)-&gt;hDC);
    bmpObj.LoadBitmap((((LPDRAWITEMSTRUCT)lParam)-&gt;itemState &amp; 
        ODS_SELECTED) ? IDB_DOWNBITMAP : IDB_UPBITMAP); 
    bmpObj.GetObject(sizeof(BITMAP), &amp;bmp);
    rect.right = bmp.bmWidth;
    rect.bottom = bmp.bmHeight;
--&gt; picHolderObj.CreateFromBitmap((HBITMAP)bmpObj.m_hObject, NULL, FALSE);
        .
        .
        .
}</code></pre>
<p>
To draw the item, we need only call the CPictureHolder member function Render(). We pass it the size of the control&#39;s bounding rectangle (which we get as rcItem in the DRAWITEMSTRUCT structure passed to us) and the bounding rectangle of the bitmap we want to draw. Finally, we return a value of 1 from OnOcmDrawItem(), indicating success:</p>
<pre><code>LRESULT CControlCtrl::OnOcmDrawItem(WPARAM wParam, LPARAM lParam)
{
    CDC *pdc;
    CBitmap bmpObj;
    BITMAP  bmp;
    CPictureHolder picHolderObj;
    CRect rect;
    pdc = CDC::FromHandle(((LPDRAWITEMSTRUCT)lParam)-&gt;hDC);
    bmpObj.LoadBitmap((((LPDRAWITEMSTRUCT)lParam)-&gt;itemState &amp; 
        ODS_SELECTED) ? IDB_DOWNBITMAP : IDB_UPBITMAP); 
    bmpObj.GetObject(sizeof(BITMAP), &amp;bmp);
    rect.right = bmp.bmWidth;
    rect.bottom = bmp.bmHeight;
    picHolderObj.CreateFromBitmap((HBITMAP)bmpObj.m_hObject, NULL, FALSE);
--&gt; picHolderObj.Render(pdc, ((LPDRAWITEMSTRUCT)lParam)-&gt;rcItem, rect);
--&gt; return 1;
}</code></pre>
<p>
We create and support control.ocx by selecting the Build control.ocx menu item in the Visual C++ Project menu, followed by Register Control in the Tools menu.</p>
<p>
Now let&#39;s see our control in action. Find control.ocx&#39;s uuid value (from the corresponding .odl file or from the Windows registry by using regedit.exe) and create an .html file:</p>
<pre><code>&lt;HTML&gt;
&lt;HEAD&gt;
&lt;TITLE&gt;Control Page&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY LANGUAGE = VBS ONLOAD = &#34;Page_Initialize&#34;&gt;
&lt;CENTER&gt;
&lt;H1&gt;Control Page&lt;/H1&gt;
&lt;/CENTER&gt;
&lt;!- control.ocx&gt;
&lt;CENTER&gt;
&lt;OBJECT CLASSID=&#34;clsid:D96FBCC1-090A-101C-BAC7-040224009C02&#34; 
        HEIGHT=80 WIDTH=100 ID=Ctrl1&gt;&lt;/OBJECT&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;</code></pre>
<p>
The result appears in Figure 9.7; when you click this CONTROL button, the image displayed turns from the cloudy day to the sunny one and back again. Even though we&#39;ve <font face="Font14793">subclassed</font> our control from an existing Windows control (a command button), we now know how to draw it ourselves. So far, then, control.ocx is a success.</p>
<p>
<img src="fig09-07.gif" border=0></p>
<p>
<b>Figure 9.7 &nbsp;Our control.ocx control.</b></p>
<p>
There is far more to learn about controls. For example, controls may support properties, methods, and custom events. After we add our custom control to a VBScript page, we simply use VBScript to connect subroutines to our custom events, just as we would for the events of any other control.</p>
<p>
Properties are useful. If you had a custom control that displayed text, for example, you might set the text simply by setting the control&#39;s Text property. Methods are also useful: if you had a custom control that displayed data in a graph, you might pass it the data to graph in a method named SetData().</p>
<p>
We will also support custom events in our control. Let&#39;s say our control supports a custom event named posEvent, which we <font face="Font14793">fire</font> (firing an event causes its event-handing function to be called) when the mouse button is pushed. We could place our custom control in a VBScript page, and the control would display its cloudy or sunny day image as required. In addition, we could set up a VBScript subroutine named Ctrl1_posEvent() to handle the control&#39;s event (assuming we had given our control the ID Ctrl1) just as it might handle a button control&#39;s click event with a function named Button1_OnClick(). In this way, as far as VBScript is concerned, our new OCX acts just like any other control (such as a button or textbox). As another example, if we had a custom control named DATE that displayed the date, we could give it an event named DateChanged, which would be fired every time the date changed. Then, in VBScript, we could connect a subroutine, DateCtrl_DateChanged(), to an embedded DATE control.</p>
<p>
Properties, methods, and events are integral parts of ActiveX controls, so let&#39;s examine them now.</p>
<h1></h1>
</font></BODY>
</HTML>
