<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Calling COM Methods Between Machines</title>
<style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000 dir=ltr>
<h1><a name="callingcommethodsbetweenmachines"></a>Calling COM Methods Between Machines</h1>
<p>
Now that we have a basic understanding of how an interface method call is transmitted across two communicating processes on the same machine or across a network, the next logical question is: how is the object on the destination created in the first place? Simply put, the SCM will locate or create the object instance across the network whenever necessary (if there are no object instances which can service the call, the SCM will launch the required object server on the remote machine, subjected to security constraints detailed in the next chapter). In the case where the caller and called party are both on the same machine under the same OS, the channel is typically working over shared memory and LRPC will be used. In the case where the caller and called party are on different machines over a network, the channel uses the DCE RPC over a layer of network software called the protocol stack (usually TCP/IP but IPX and NETBEUI are also supported by RPC on Windows platforms).</p>
<p>
<img src="03750903.gif" border=0></p>
<p>
Of course, there's low level sanity checking and connection management work that DCOM must do because of the added network connection. All this work, though, is completely hidden from you as an application developer and you can develop components without worrying about where they may be executed.</p>
</BODY>
</HTML>
