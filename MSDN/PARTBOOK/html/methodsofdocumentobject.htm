<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Methods of the Document Object</title>
<style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000 dir=ltr>
<h1><a name="methodsofdocumentobject"></a>Methods of the Document Object</h1>
<p>
Like we’ve said before, the methods of the <b><code>Document</code></b> object are all concerned with modifying the HTML of the document. As usual, a quick example is often the easiest way to explain what we mean. Fire up NotePad once again, and enter the following code:</p>
<pre><code>&lt;HTML&gt;
&lt;HEAD&gt;
&lt;TITLE&gt; Document Methods &lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;H1&gt; Document Object Methods &lt;/H1&gt;
&lt;SCRIPT LANGUAGE="VBScript"&gt;
Document.Write "The current time is " &amp; Now &amp; "."
&lt;/SCRIPT&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;</code></pre>
<p>
Load up the page and look at the results. It's displaying the current date and time—even though we didn’t enter it in our HTML or have the file processed on the server before it was sent to the client. The language interpreter on the client machine is still interpreting our code—it’s just generating HTML instead of responding to an event and doing things like popping up message boxes or navigating to a new page. If we view the source for this page we’ll still see our script code and not the results, unlike if the script was executing on the server where it would just send us HTML. </p>
<p>
<img src="docwrite.gif" border=0></p>
<p>
All of the <b><code>Document</code></b> object’s methods work this way – they modify the HTML as they’re interpreted. If you’re curious you could try a little experiment to show that ASP code is indeed executed earlier than client-side code. Add a few lines of ASP code to the example above to read the current time on the server and output it to the page. When the browser finally finishes rendering the page, you’ll see two time values that differ by a second or two—even if the browser and server are running on the same machine.</p>
<h2>The Write and WriteLn Methods</h2>
<p>
Lets take a look at the <b><code>Write</code></b> method in a little more detail. This method simply takes a string, and outputs it as part of the HTML stream. Because the text is actually interpreted by a script engine, it can include variable references and function calls, in addition to plain text. The interpreter executes all of the calls and resolves all variables, before sending a final string to the browser.</p>
<p>
Since the string is going to the browser, it can (and should) include whatever HTML markup tags are needed. For example, the following <b><code>Document.Write</code></b> line displays the current date and time in the <b><code>Header</code></b> <b><code>1</code></b> font of the current browser:</p>
<pre><code>Document.Write "&lt;H1&gt;" &amp; Now &amp; "&lt;/H1&gt;"</code></pre>
<p>
Calls to the <b><code>Document.Write</code></b> method can be interspersed with standard HTML, just as calls to the <b><code>Response.Write</code></b> method can be intertwined with HTML on the server.</p>
<p>
<b><code>WriteLn</code></b> is nearly identical to <b><code>Write</code></b>, with one difference that may be important to us depending exactly upon the point at which we need to use the <b><code>Write</code></b> methods. <b><code>WriteLn</code></b> writes a string to the document just like <b><code>Write</code></b>, however it appends a new-line character to the end of each string. Since the HTML specification ignores white space and new-line characters when interpreting standard text, the browser output may look the same, independent of which <b><code>Write</code></b> method is used. The only place we’ll see a difference is when the output we’re writing is inside a formatting tag that pays attention to line-feeds. For example, when <b><code>WriteLn</code></b> is used inside of a <b><code>&lt;PRE&gt;...&lt;/PRE&gt;</code></b> block, separate <b><code>WriteLn</code></b> statements will result in text that is displayed on separate lines.</p>
<p>
One last question you might have regards what happens if <b><code>Write</code></b> or <b><code>WriteLn</code></b> are used after a page is already loaded—as part of an event handler, for example. We're going to postpone the answer to this question until we’ve covered the <b><code>Document</code></b>’s <b><code>Open</code></b>, <b><code>Close</code></b>, and <b><code>Clear</code></b> methods in the next section. You’ll see why afterwards.</p>
<h2>The Open, Close and Clear Methods</h2>
<p>
As we’ve seen in the example above, it’s possible to use the <b><code>Write</code></b> or <b><code>WriteLn</code></b> methods by themselves. Sandwiching our calls to <b><code>Write</code></b> and <b><code>WriteLn</code></b> between a call to the <b><code>Document</code></b> object's <b><code>Open</code></b> and <b><code>Close</code></b> methods gives us more control over when the strings are outputted to the page. In effect, using these methods is like using the buffering ability ASP provides with the <b><code>Response</code></b> object.</p>
<p>
Although the documentation claims that calling <b><code>Open</code></b> after the output stream already has data will clear the output stream, we haven’t been able to see this behavior with Internet Explorer 3.01. Our recommendation is to experiment with these methods on the latest version of your browser, and determine how close your browser, and the browsers your customers may have, come to the original specifications. This omission on the part of the browser isn’t catastrophic—in many cases this functionality isn’t necessary. Perfect software is great, but certainly not a reality in an imperfect world.</p>
</BODY>
</HTML>
