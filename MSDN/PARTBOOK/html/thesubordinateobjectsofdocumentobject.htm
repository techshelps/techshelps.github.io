<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The Subordinate Objects of the Document Object</title>
<style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000 dir=ltr>
<h1><a name="thesubordinateobjectsofdocumentobject"></a>The Subordinate Objects of the Document Object</h1>
<p>
OK, we’ve covered a lot of <b><code>Document</code></b>’s functionality in the last few pages, but we’re not finished yet. We still have some of the most useful things to talk about. Not surprisingly, these are actually objects in themselves. We’ll be talking about the <b><code>Anchor</code></b>, <b><code>Link</code></b>, and <b><code>Form</code></b> objects (as well as their respective collections) and the <b><code>Location</code></b> object (which, all by its lonesome self, doesn’t have a collection). All of these objects are generated when the page is parsed, and they reflect the properties of the page currently in the browser.</p>
<p>
Like we’ve said, three of the four objects we’ll be talking about here are actually stored in <b>collections</b>. Objects inside collections can’t be referenced in code without the collection being named first in some manner. After covering the objects themselves, we’ll talk about some special cases that can arise when programming with collections. You've already had experience with many ASP collections, like <b><code>Request.Cookies</code></b>, and <b><code>Request.Form</code></b>, and you can rest assured that using collections on the client is nearly identical—only the names of the collections, the objects, and their properties and methods, are different.</p>
<h2>The Link Object</h2>
<p>
The <b><code>Link</code></b> object represents something you’re very familiar with if you’ve ever browsed the web—a hypertext link on a page. The <b><code>Links</code></b> collection is made up of <b><code>Link</code></b> objects, one for each anchor tag containing an <b><code>HREF</code></b> attribute (<b><code>&lt;A</code></b> <b><code>HREF="..."&gt;</code></b>) on the page. We can’t change the links on the current page when browsing, and so, not surprisingly, all the elements of this collection, and their properties, are read-only. The link object has nine properties and two events, but no methods.</p>
<h3>Link Object Properties</h3>
<p>
Guess what? The properties of the <b><code>Link</code></b> object (with one addition) are identical to the properties of the <b><code>Location</code></b> object we covered earlier. We won’t repeat them here, but if you need to you can refresh your memory a few pages back.</p>
<p>
In addition to the eight properties that it shares with <b><code>Location</code></b>, a <b><code>Link</code></b> object also possesses an additional property called <b><code>Target</code></b>. This property is blank unless the link has a <b><code>TARGET</code></b> attribute used to refer to a new browser window or frame. For example, the <b><code>Target</code></b> property of the following URL is <b><code>MainFrame</code></b>:</p>
<pre><code>&lt;A HREF="http://www.mysite.com" TARGET="MainFrame"&gt;</code></pre>
<h3>Link Object Events</h3>
<p>
Viewers of our page can do things to links: they can click them or move their mouse over them. The events supported by <b><code>Link</code></b> allow us to respond appropriately to these actions.</p>
<p>
The <b><code>Link</code></b> object has an <b><code>onMouseOver</code></b> event that is fired when the user moves the mouse over a link. We can do some cool tricks with links by hooking up code to this event. Since links really don’t have a <b><code>name</code></b> per se, it’s easiest to specify the desired behavior in the anchor tag itself:</p>
<pre><code>...
&lt;A HREF="http://bossman" onMouseOver="MyFunc"&gt;Bossman&lt;A&gt;
...
...
&lt;SCRIPT LANGUAGE="VBScript"&gt;
Sub MyFunc
  Alert "Moved"
End Sub
&lt;/SCRIPT&gt;
...</code></pre>
<p>
In this example, the combination of the anchor tag’s <b><code>onMouseOver</code></b> attribute and the <b><code>MyFunc</code></b> subroutine causes an alert message box to be displayed whenever the mouse is moved over the link. Use this for demonstration purposes only. Doing something exactly like this could be annoying to the viewer of our page— they’ll have a hard time clicking on the link if they’re always trying to dismiss a message box first!</p>
<p>
<b><code>Link</code></b> objects also have an <b><code>onClick</code></b> event that works the same as the <b><code>onMouseOver</code></b> event, except that it is only fired when the link is actually clicked on. To hook up code to this event we just add an <b><code>onClick</code></b> attribute to the HTML for our link, like this:</p>
<pre><code>&lt;A HREF="http://bossman" onClick="MyFunc"&gt;Bossman&lt;/A&gt;</code></pre>
<p>
If we’re not going to do much in the function, we might find it easier to just include our code within the anchor tag, as in-line script. We outlined how to do this in the 'hooking up the code' section at the beginning of this chapter.</p>
<h2>The Anchor Object</h2>
<p>
The <b><code>Anchor</code></b> object is one of the simplest objects we’ll see in any object model, and it isn't very useful in most client-side programming. In HTML an anchor is simply an <b><code>&lt;A&gt;</code></b> tag. In the object model, we have access to a collection of these tags via the <b><code>Document</code></b> object’s <b><code>Anchors</code></b> property. Anchor objects have one property, <b><code>Name</code></b>, which is set to the <b><code>NAME</code></b> attribute of the given tag.</p>
<p>
Internet Explorer 3.01’s <b><code>Anchors</code></b> collection only includes HTML elements with a <b><code>NAME</code></b> property and without an <b><code>HRef</code></b> property.</p>
<h2>The Form Object</h2>
<p>
In contrast to the <b><code>Anchor</code></b> object, the <b><code>Form</code></b> object is supremely useful to client-side programmers. Its properties encompass such information as the current <b><code>ACTION</code></b> address, the <b><code>METHOD</code></b>, and the encoding for the form. Its sole method and event encapsulate form submission. In addition to the normal properties, each <b><code>Form</code></b> object has an <b><code>Elements</code></b> collection that provides access to each HTML element (the text boxes, buttons, etc.) on a given form. We’ll cover this very important collection as soon as we finish talking about the <b><code>Form</code></b> object itself.</p>
<h3>The Form Object Properties</h3>
<p>
The five properties of <b><code>Form</code></b> are <b><code>Action</code></b>, <b><code>Encoding</code></b>, <b><code>Method</code></b>, <b><code>Target</code></b>, and <b><code>Elements</code></b>. This section talks about the first four properties. These are derived from the opening <b><code>&lt;FORM&gt;</code></b> tag. So, like we did with the <b><code>Location</code></b> object, we’ll invent a tag and then show the resulting property values. Our tag for this demonstration will be:</p>
<pre><code>&lt;FORM NAME="myForm" ACTION="http://www.mysite.com/search" METHOD="GET" TARGET="NewWindow" ENCTYPE="text/html"&gt;</code></pre>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=blue width=128><b>Property</b></td>
<td class=blue width=233><b>Value</b></td>
<td class=blue width=326><b>Description</b></td>
</tr>
<tr valign=top>
<td width=128><b><code>Action</code></b></td>
<td width=233>http://www.mysite.com/search</td>
<td width=326>Action for form processing (usually a URL)</td>
</tr>
<tr valign=top>
<td width=128><b><code>Method</code></b></td>
<td width=233>GET</td>
<td width=326>Form data submission to server (GET or POST)</td>
</tr>
<tr valign=top>
<td width=128><b><code>Target</code></b></td>
<td width=233>NewWindow</td>
<td width=326>Name of target window to display results in</td>
</tr>
<tr valign=top>
<td width=128><b><code>Encoding</code></b></td>
<td width=233>text/html*</td>
<td width=326>Encoding for the form</td>
</tr>
</table><br>
<p>
* IE 3.01 doesn’t display or allow this property to be set correctly</p>
<p>
These properties can be read or set to determine the current form settings, or possibly to change the behavior of the form before it is submitted.</p>
<h3>Submit and onSubmit: The Form’s Method and Event</h3>
<p>
The <b><code>Form</code></b> object’s single method (<b><code>Submit</code></b>) and event (<b><code>onSubmit</code></b>) handle form submission. Calling <b><code>Submit</code></b> submits the form, with the same result as a viewer clicking on a Submit button in the form.</p>
<p>
As you’ll see in the simple code in this section, and in a detailed example in the next chapter, client-side code can be very useful in performing validation of data entered on a form before the form is submitted. By doing this, we save a trip to the web server and back just to inform a user that they entered invalid data. Keep in mind that this only guarantees that information coming from <i>our</i> page is properly validated and acceptable. It <i>doesn’t</i> actually mean that <i>any</i> data received is OK. </p>
<p>
For example, there’s nothing stopping someone from writing an application that sends data to our Web server, and in this case the data will never have seen the validation code in our Web page. The morale of the story is: if it’s extremely important that only certain data ends up in your database, then you'd better check it at the server end too. However, most applications don’t require this depth of protection.</p>
<p>
The page below submits the form when the Submit button is clicked, unless the user has entered "no" in the text box—in which case the form is not submitted:</p>
<pre><code>&lt;HTML&gt;
&lt;HEAD&gt;
&lt;TITLE&gt; Form Submit &lt;/TITLE&gt;
&lt;/HEAD
&lt;BODY&gt;
&lt;H1&gt; Form Submit &lt;/H1&gt;
&lt;FORM NAME="myForm" ACTION="http://mysite.com/" METHOD="GET"&gt;
   &lt;INPUT TYPE="TEXT" NAME="txtOne"&gt;
   &lt;INPUT TYPE="SUBMIT" NAME="sbmTest"&gt;
&lt;/FORM&gt;
&lt;SCRIPT LANGUAGE="VBScript"&gt;
Function myForm_onSubmit
   If Document.myForm.txtOne.Value = "no" then
      myForm_onSubmit = False
   Else
      myForm_onSubmit = True
   End if
End Function
&lt;/SCRIPT&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;</code></pre>
<p>
Looking closely at the code on this page, you might notice something odd: the handler for the <b><code>onSubmit</code></b> event is a <b>function</b>, not just a normal <b>subroutine</b>. Every other event handler we’ve written has always been a subroutine, so why the change now? The answer is in the way Internet Explorer and Navigator are set up to process the <b><code>onSubmit</code></b> event. In this one single case, they look for a return value and act accordingly. If this event returns <b><code>False</code></b>, the form isn’t submitted. If it returns anything else, the form is submitted normally.</p>
<p>
An alternative to this method is to create a normal (i.e., non-submit) button with an <b><code>&lt;INPUT</code></b> <b><code>TYPE="BUTTON"&gt;</code></b> tag. In the handler for the <b><code>onClick</code></b> event of this button, we perform our validation. We only submit the form, using the <b><code>FormName.Submit</code></b> method, when the data meets our requirements. The next chapter includes a more in-depth example of client-side validation.</p>
<h2>The Elements Collection</h2>
<p>
Each <b><code>Form</code></b> object has an <b><code>Elements</code></b> collection, which represents the HTML form elements inside a pair of <b><code>&lt;FORM&gt;...&lt;/FORM&gt;</code></b> tags. Any element that can be created with HTML (including objects created with the <b><code>&lt;OBJECT&gt;</code></b> tag) can be represented in the <b><code>Elements</code></b> collection.</p>
<p>
As we’ll see in the next section, it’s important to correctly name the form where the object we’re interested in resides (both in script code and in HTML). If this information is incorrect, the browser won’t be able to find the object we’re talking about, and will give us a rude error message saying that the object doesn’t exist! If we don’t identify the object correctly, as far as the browser is concerned, it doesn’t exist.</p>
<p>
Once we have access to the elements of a form, we might want to know how they act. We’ll cover the HTML form elements next.</p>
<h2>HTML Form Elements and the Element Object</h2>
<p>
HTML form elements can be very different. We can create text boxes, buttons, check boxes, and more with HTML. Accordingly it will probably come as no surprise to you, having worked with these elements before, that the properties, methods, and events for these elements are also different. Fortunately, however, similar objects usually have the same properties, methods, and events, making our job of understanding them easier.</p>
<p>
Rather than cover how to use each and every one of these elements, and duplicate a lot of code and text in the process, we’ll instead provide a table showing the properties, methods, and events for each object, and some general comments about these characteristics.</p>
<p class=indent>
For a much more detailed coverage of this topic, check out the Wrox Press book <i>Instant VBScript</i>.</p>
<p>
If you’re interested in actual code (and who isn’t?), be sure to take a look at the in-depth examples in the next chapter, and at the code samples throughout this chapter.</p>
<table border=1 cellpadding=5 cols=4 frame=below rules=rows>
<tr valign=top>
<td class=blue width=135><b>Element</b></td>
<td class=blue width=197><b>Properties</b></td>
<td class=blue width=144><b>Methods</b></td>
<td class=blue width=264><b>Events</b></td>
</tr>
<tr valign=top>
<td width=135><b><code>button,</code></b> <b><code>reset,</code></b> <b><code>submit</code></b></td>
<td width=197>form, name, value</td>
<td width=144>click</td>
<td width=264>onClick</td>
</tr>
<tr valign=top>
<td width=135><b><code>checkbox</code></b></td>
<td width=197>form, name, value, checked, defaultChecked</td>
<td width=144>click</td>
<td width=264>onClick</td>
</tr>
<tr valign=top>
<td width=135><b><code>radio</code></b></td>
<td width=197>form, name, value, checked</td>
<td width=144>click, focus</td>
<td width=264>onClick</td>
</tr>
<tr valign=top>
<td width=135><b><code>password</code></b></td>
<td width=197>form, name, value, defaultValue</td>
<td width=144>focus, blur, select</td>
<td width=264>None</td>
</tr>
<tr valign=top>
<td width=135><b><code>text,</code></b> <b><code>textarea</code></b></td>
<td width=197>form, name, value, defaultValue</td>
<td width=144>focus, blur, select</td>
<td width=264>onFocus, onBlur, onChange, onSelect</td>
</tr>
<tr valign=top>
<td width=135><b><code>select</code></b></td>
<td width=197>name, length, options, selectedIndex</td>
<td width=144>focus, blur</td>
<td width=264>onFocus, onBlur, onChange</td>
</tr>
<tr valign=top>
<td width=135><b><code>hidden</code></b></td>
<td width=197>name, value</td>
<td width=144>None</td>
<td width=264>None</td>
</tr>
</table><br>
<p>
Many of these properties will be familiar to you from prior reading and work, but we’ll review them briefly below.</p>
<h3>The Element Object's Properties</h3>
<p>
Fortunately for us, each object has a <b><code>Name</code></b> property. If it didn’t, we’d have a hard time referring to the object in code, and the object model wouldn’t be much use to us. Other useful properties include <b><code>Form</code></b> and <b><code>Value</code></b>. <b><code>Form</code></b> returns a reference to the element’s form object, while <b><code>Value</code></b> gets or sets the value of the element. While all the elements have a <b><code>Value</code></b> property, the actual contents of this property vary depending on the object itself. For example, the <b><code>Value</code></b> of a <b><code>text</code></b> element is the string in the text box, while the <b><code>Value</code></b> of a <b><code>button</code></b> is the button’s caption.</p>
<h3>The Element Object's Methods</h3>
<p>
Some combination of the <b><code>click</code></b> and <b><code>focus</code></b> methods is common to all elements except for the <b><code>hidden</code></b> element (which has no methods or events). The <b><code>click</code></b> method causes the same result as a user clicking on the object. Calling the <b><code>focus</code></b> method of an object moves the current input location, or focus, to the object. For example, the code:</p>
<pre><code>txtOne.Focus</code></pre>
<p>
moves the input cursor to the text box object named <b><code>txtOne</code></b>. The <b><code>blur</code></b> method is the converse of <b><code>focus</code></b>; it removes the focus from the current object. Finally, the <b><code>select</code></b> method, a feature of the <b><code>password</code></b>, <b><code>text</code></b>, and <b><code>textarea</code></b> input elements, selects the current contents of the object. This has the same effect as if the viewer of the page had clicked and dragged the mouse across the text in the input element.</p>
<h3>The Element Object's Events</h3>
<p>
We’ve already seen one input element event many times: <b><code>onClick</code></b>. Each object that has a <b><code>click</code></b> method also has an <b><code>onClick</code></b> event, where code is placed ready to be executed when the object is clicked. Other interesting events that can be used in a similar way are <b><code>onFocus</code></b> (called when the element receives the focus), <b><code>onBlur</code></b> (called when the element loses focus), and <b><code>onChange</code></b> (called when the <b><code>Value</code></b> property of the object changes).</p>
<h2>Referencing Objects in Collections</h2>
<p>
Now that we’ve covered the most important collections in the <b><code>Document</code></b> object, it’s a good time to refresh our memory on how collection objects need to be referenced in code. Just like with ASP collections, items in the collections of the browser object model can be referenced one of two ways: by name or by index.</p>
<p>
The choice of these collections has a practical aspect: whenever we refer to an object in a form (a very common client-side task) we need to make sure we reference the object correctly. Remember that the browser creates a <b><code>Form</code></b> object in the <b><code>Forms</code></b> collection for each <b><code>&lt;FORM&gt;</code></b> tag on the HTML page, and an item in the <b><code>Form</code></b>’s <b><code>Elements</code></b> collection for each element in the form. All collections have the additional property <b><code>Count</code></b>, which returns the number of objects that are currently held in the collection.</p>
<p>
To illustrate this concept, we’ll use the <b><code>Form</code></b> and <b><code>Elements</code></b> collection. Suppose a page with a single HTML form laid out like this:</p>
<pre><code>&lt;FORM NAME="myForm"&gt;
&lt;INPUT TYPE="BUTTON" NAME="btnOne" VALUE="Click Me"&gt;&lt;BR&gt;
&lt;INPUT TYPE="TEXT" NAME="txtElement"&gt;
&lt;/FORM&gt;</code></pre>
<p>
After the page is parsed and displayed the <b><code>Count</code></b> property of the page’s <b><code>Forms</code></b> collection would hold the value one, as the page boasts a single form, named <b><code>myForm</code></b>. The <b><code>Count</code></b> property of the <b><code>myForm.Elements</code></b> collection would be two, because there are two input elements inside <b><code>myForm</code></b>.</p>
<p>
Why does this matter, outside of knowing how many objects are in a collection? When referring to objects in code, the index numbers of the collections can be used instead of, or in tandem with, the names of the objects. For example, the <b><code>Action</code></b> property of <b><code>myForm</code></b> could be referred to with this code, which uses the name of the form:</p>
<pre><code>Document.myForm.Action</code></pre>
<p>
or with this code, which uses the index:</p>
<pre><code>Document.Forms(0).Action</code></pre>
<p>
Note that, while <b><code>Count</code></b> returns <b><code>1</code></b>, the collection is indexed from <b><code>0</code></b> to <b><code>Count</code></b> <b><code>–</code></b> <b><code>1</code></b>.</p>
<p>
Similarly, the form’s elements could be named in code like this:</p>
<pre><code>Document.Forms(0).btnOne.Value
Document.Forms(0).txtElement.Value</code></pre>
<p>
or by index, like this:</p>
<pre><code>Document.Forms(0).Elements(0).Value
Document.Forms(0).Elements(1).Value    </code></pre>
<p>
It’s important to remember that we need to add this relatively long qualifier when referring to input elements (or <b><code>OBJECT</code></b>s) inside a form. If we don’t do this, the browser will think we’re trying to refer to a control that’s not on a form, i.e. that we’re talking about a control that’s on the page itself. Using simply <b><code>btnOne.Value</code></b> instead of one of the longer lines of code above will cause an Object required error (unless of course an element named <b><code>btnOne</code></b> exists outside the form). Without specifying the form that the object resides in, the browser can’t tell what form element we’re talking about.</p>
<p>
Form elements or objects created with the <b><code>&lt;OBJECT&gt;</code></b> tag that are placed outside of a <b><code>&lt;FORM&gt;</code></b> tag should be named without a preceding object reference—they don't belong to any form, and so they aren’t a part of any form’s <b><code>Elements</code></b> collection. And because objects are only created when an <b><code>&lt;OBJECT&gt;</code></b> tag is encountered while parsing the page, we need to make sure that any <b><code>&lt;OBJECT&gt;</code></b> tags come before script code that references them.</p>
</BODY>
</HTML>
