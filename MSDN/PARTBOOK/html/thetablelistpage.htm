<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The Table List Page</title>
<style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000 dir=ltr>
<h1><a name="thetablelistpage"></a>The Table List Page</h1>
<p>
To start things off, we define a number of variables that will be used throughout this page: </p>
<pre><code>Dim oServer
Dim sServerName
Dim sUid
Dim sDatabase
Dim sPassword</code></pre>
<p>
Of interest, as you will soon see, is the <b><code>oServer</code></b> variable. It will be used to hold a reference to the SQL Server OLE Object—in this first part of our sample, we have to take a step beyond ADO. Why? Well, we want catalog information concerning what structures are actually maintained by the SQL Server, and typically this information would be gathered from the ODBC provider. </p>
<p>
However, at the time of this writing, the ODBC/ADO provider supplied for SQL Server does not include catalog level functionality. As such, we need to find an alternative method. The alternative is to create a reference to the SQL Server OLE Object directly. SQL Server 6.5 client utilities provide a number of OLE Objects that can be used to access SQL Server services. These OLE objects take advantage of the underlying SQL Server network libraries in order to communicate with the server. </p>
<p>
First off, we use the same <b><code>CreateObject</code></b> method to create an instance of the SQL Server Object, <b><code>sqlole.sqlserver</code></b>, within ADO:</p>
<pre><code>Set OServer = Server.CreateObject("sqlole.sqlserver")</code></pre>
<p>
With this reference created, we now have an access mechanism we can use to talk to a SQL Server. Before we can establish a connection, we will need the information supplied by the user on the main page. To do this we use:</p>
<pre><code>sServerName = Trim(Request.Form("ServerName"))
sDatabase   = Trim(Request.Form("DatabaseName")) 
sUid        = Trim(Request.Form("Login")) 
sPassword   = Trim(Request.Form("Password"))</code></pre>
<p>
Then, with this information, we call the OLE Object's <b><code>Connect</code></b> method to establish a link to the server specified by the user:</p>
<pre><code>OServer.Connect sServerName,sUid,sPassword</code></pre>
<p>
An important point to note here is that, because we are accessing the SQL Server via its OLE Object libraries, we are bypassing ODBC completely. Any previous ODBC definitions have no impact on this connection. </p>
<p>
With a connection established, we are ready to retrieve the catalog data needed. In this case, we want a list of all the tables that exist for the selected database. This can be done using the catalog functions that are provided via the SQL OLE interface. First we display a confirmation of the login details, then retrieve the information we want by querying the <b><code>Database</code></b> object's <b><code>Tables</code></b> object. The name of each table found is used to populate a drop down list box:</p>
<pre><code>&lt;SELECT NAME="TableNames" SIZE="1"&gt;
&lt;% Set oSQLdb = oServer.Databases(sDatabase)
   For Each oSQLTable In oSQLdb.Tables
      Response.Write "&lt;option value=""" &amp; oSQLTable.Name &amp; """ &gt; " _
                     &amp; oSQLTable.Name &amp; "&lt;/option&gt;"
   Next %&gt;
&lt;/SELECT&gt;</code></pre>
<p>
And here's the result:</p>
<p>
<img src="07235_09.gif" border=0></p>
<p>
Now we can select a table on which to gather additional information, and click the Submit button to bring up our final ASP page <b><code>Map.asp</code></b>. This will display all of the fields in the selected table, along with their type, size, precision etc..</p>
<p>
To do this, ADO does provide the functionality we need. To begin, we create a read-only, forward-scrolling <b><code>Recordset:</code></b></p>
<pre><code>Set oRS = Server.CreateObject("ADODB.recordset")
oRS.Open "SELECT * FROM " &amp; sDatabase &amp; ".dbo." _
         &amp; Request.Form("TableNames"), "Driver={SQL Server};Server=" _
         &amp; sServerName &amp; ";uid=" &amp; sUid &amp; ";pwd=" &amp; sPassword _
         &amp; ";Database=" &amp; sDatabase &amp; ";DSN=;"</code></pre>
<p>
Note that in this instance, the use of a forward-scrolling <b><code>Recordset</code></b> is very important. If you remember earlier, we indicated that the default <b><code>CacheSize</code></b> setting for this type of cursor is one. As such, even though we are doing a <b><code>SELECT</code></b> <b><code>*</code></b> SQL command; only a single record will actually be retrieved. You may also notice that this recordset is created without using a DSN. This is because we do not know what the connection will be defined as until the user of the application provides us with a server name. We define the connection 'on the fly'.</p>
<p>
With a cursor in place, we are ready to retrieve information about the fields in our table: </p>
<pre><code>iRow = RS.Fields.Count
For iCount = 0 to (iRow - 1)
  Set Fld = RS.Fields(iCount)
  response.write "&lt;TR&gt;"
  response.write "&lt;TD&gt; " &amp; Fld.Name &amp; "&lt;/TD&gt;"
  response.write "&lt;TD&gt; " &amp; Fld.Type &amp; "&lt;/TD&gt;"
  response.write "&lt;TD&gt; " &amp; Fld.ActualSize &amp; "&lt;/TD&gt;"
  If Int(Fld.Precision) &gt;= 255 Then
    response.write "&lt;TD&gt; 0 &lt;/TD&gt;" 
  Else
    response.write "&lt;TD&gt; " &amp; Int(Fld.Precision) &amp; "&lt;/TD&gt;"
  End If
  If Int(Fld.NumericScale) &gt;= 255 Then
    response.write "&lt;TD&gt; 0 &lt;/TD&gt;"
  Else
    response.write "&lt;TD&gt; " &amp; Int(Fld.NumericScale) &amp; "&lt;/TD&gt;"
  End If
  response.write "&lt;/TR&gt;"
Next</code></pre>
<p>
Here we use the number of <b><code>Field</code></b> objects in the data source's <b><code>Fields</code></b> collection to control how many cells are created in the output table. We then populate each cell with data from each <b><code>Field</code></b> object. The end result is a presentation of each <b><code>Field</code></b>, along with its attributes:</p>
<p>
<img src="07235_10.gif" border=0></p>
</BODY>
</HTML>
