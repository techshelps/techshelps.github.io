<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The Object-Oriented Hype</title>
<style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000 dir=ltr>
<h1><a name="theobjectorientedhype"></a>The Object-Oriented Hype</h1>
<p>
The object-oriented gold rush of the early 1990s has been eclipsed by the painful discovery of the difficulties involved when putting the methods into practice. Full adoption of the object-oriented culture entails revolutionary changes throughout the life cycle of a product, from OO Analysis/Planning to OO Design, to OO Programming, through to OO environment for software maintenance and support. The exposure to such culture, for most people, is limited to the utilization of object-oriented programming languages and development environments. The C++ language has became the most popular ambassador of object-oriented design and development techniques. Unfortunately, much of its popularity comes from the fact that it attempts to be backward compatible with the most popular system (and microcomputer applications) programming language of all time: C. This compatibility has provided many 'backdoors' in programming which break all rules of object-oriented software design. While discipline in software design works well in small object-oriented projects working in C++, industry case studies have shown that the practice inevitably breaks down in very large projects involving multiple programming teams. One key problem cited is the inability to reuse C++ classes effectively across projects without having access to the underlying source code. Many of the promises made by the object-oriented pundits remained undeliverable in the era of object-oriented C++ software development.</p>
<p>
Another very real limitation is that unless the entire system is object-oriented, it becomes very difficult to manage the 'boundaries' between the pieces on a system that are and aren't object-oriented. After all, a simple computing language can only give an 'illusion' of object-orientation without an underlying object-oriented runtime operating system, or data access support. Without these supports, some sort of 'mapping' has to be performed to work with the underlying subsystem if it isn't object-oriented. Because an alternative method of access is available which isn't object-oriented, such a system typically requires very involved maintenance and is subjected to easy corruption. There were valiant attempts in the industry to address this problem by making the complete system object-oriented, most notable are the Next operating system, the SmallTalk programming language and programming/runtime environment, and many of the object databases. In each case, by having total control over the entire operating environment, some of the higher level benefits of object-oriented design based on inheritance and polymorphism can be realized. While there are a significant number of people following and adopting the approaches of these systems, their 'revolutionary' nature has kept them from many of the largest corporate installations.</p>
</BODY>
</HTML>
