<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Binary Data</title>
<style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000 dir=ltr>
<h1><a name="binarydata"></a>Binary Data</h1>
<p>
The <b><code>Recordset</code></b> is an extremely flexible object. In addition to working with data of various types, it supports the retrieval and manipulation of raw binary data stored in a database. This can be especially valuable if our database contains items such as graphical or sound data. </p>
<p>
It's important to note that although BLOB (Binary Large Object) data can be retrieved from a database, it is not wise to store all of the graphical images on the Web site in the database. SQL Server, or Access for that matter, was not designed to process and work with this type of data. Typically it's far more efficient to store BLOB information as normally, as <b><code>.gif</code></b> or <b><code>.wav</code></b> files, along with our Web pages.</p>
<p>
BLOB data manipulation comes in handy when we have graphics that are supplied from other sources, and are typically dynamic in nature. For example, a workflow imaging system may track document images across various users, and we may need to display some of these images within a dynamic Web page. To do this, the <b><code>GetChunk</code></b> method of the <b><code>Field</code></b> object is used. Let's take a look at an example:</p>
<pre><code>ID = Request.QueryString("ID")
BlockSize = 4096
Response.ContentType = "image/JPEG"
strQuery = "SELECT * FROM Blob WHERE Blob_ID = " &amp; ID
Set oRS = oConn.Execute(strQuery)      '<b>oConn is a Session level object</b>
oRS.MoveFirst
Set Field = oRS("Blob")
FileLength = Field.ActualSize
NumBlocks = FileLength \ BlockSize
LeftOver = FileLength Mod BlockSize
Response.BinaryWrite Field.GetChunk(LeftOver)
For intLoop = 1 To NumBlocks
  Response.BinaryWrite Field.GetChunk(BlockSize)
Next
oRS.Close</code></pre>
<p class=indent>
Make sure the BLOBs are the last things in your <b><code>SELECT</code></b> statement. Currently they don't work if they are not the last field(s).</p>
<p>
In this example, a <b><code>jpeg</code></b> image has been stored in an <b><code>Image</code></b> field within our SQL Server database. We're retrieving it from the database, and displaying it on our Web page. SQL Server supports several binary data types. Two of these, <b><code>Binary</code></b> and <b><code>VarBinary</code></b> are limited to a maximum of <b><code>255</code></b> characters. In addition, SQL Server supports an <b><code>Image</code></b> type that stores data as <b><code>2KB</code></b> increments of binary information. This type meets our need for this example.</p>
<p>
Our first step is to obtain a key that references the binary object in which we are interested. Here, we will use an <b><code>ID</code></b> that is selected by the user on a previous page. In a real world scenario, the previous page would include a number of “thumb nail” pictures, that when selected would call this page and pass the appropriate <b><code>ID</code></b> for the image required. </p>
<p>
A <b><code>BlockSize</code></b> value is used to determine how much data will be read from the data source at one time. Take care when setting this value. It is best to use a value that is a multiple of the field increment size to avoid an excessively large or small leftover chunk. It may seem logical to read the whole image as a single chunk, but keep in mind that we need to move this data from our server to our Web site in a single transaction, a process that can be very resource intensive with large files.</p>
<p>
The next step is to define the type of data that will be displayed on the page. This is done using the <b><code>ContentType</code></b> property of the <b><code>Response</code></b> object. Then, with our initial values set, we can define a query to retrieve the data. Using the <b><code>Execute</code></b> method of the <b><code>Connection</code></b> object, we submit the query and return a <b><code>Recordset</code></b> containing the query results. To verify that the data set is populated, we call the <b><code>MoveFirst</code></b> method of the <b><code>Recordset</code></b> object. </p>
<p>
Now we are ready to actually read the data from our <b><code>Recordset</code></b>. To do this we define an object variable representing the <b><code>BLOB</code></b> field. In this example we use:</p>
<pre><code>Set Field = RS("BLOB")</code></pre>
<p>
The object variable <b><code>Field</code></b> now has a reference to the actual binary data. Our next step is to calculate how much data we need to retrieve in terms of the block size defined earlier. We do this by retrieving the actual size of the object (using the <b><code>ActualSize</code></b> property as you might guess), and then dividing that value by our block size variable to determine the number of chunks our data can retrieved in. As our block size may not be evenly devisable by the size of the image, a <b><code>LeftOver</code></b> value is calculated to determine any partial chunk of data that needs to be retrieved:</p>
<pre><code>FileLength = Field.ActualSize
NumBlocks = FileLength \ BlockSize
LeftOver = FileLength Mod BlockSize</code></pre>
<p>
Using the <b><code>BinaryWrite</code></b> method of the <b><code>Response</code></b> object, we can output a chunk of the data read from the data source with the <b><code>GetChunk</code></b> method. <b><code>GetChunk</code></b> is design to read an unstructured binary data stream from an object of a given size. Here, we initially retrieve the extra bytes (if any), and then read blocks of data of the size defined, and write them to the Web page: </p>
<pre><code>Response.BinaryWrite Field.GetChunk(LeftOver)
For i = 1 To NumBlocks
  Response.BinaryWrite Field.GetChunk(BlockSize)
Next</code></pre>
</BODY>
</HTML>
