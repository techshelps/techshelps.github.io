<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Client-Side Form Validation</title>
<style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000 dir=ltr>
<h1><a name="clientsideformvalidation"></a>Client-Side Form Validation</h1>
<p>
One of the easiest and most practical applications of client-side code is input validation. When Microsoft and Netscape first started talking about adding scripting to HTML people asked why, and this was one of the first responses the marketing people gave. The horizons have expanded greatly with objects, but this remains one of the most beneficial uses of script code.</p>
<h2>The Form Validation Example</h2>
<p>
The code for this example (<b><code>validation.htm</code></b>) is a bit more complex than the last one, but it should be accordingly more useful. The screenshot below shows a form with four fields called, in turn, Name, Age, Email Address, and Next Birthday. Each field (with the exception of Age등e don't want to offend anyone!) must have a certain type of input before the form can be submitted.</p>
<p>
<img src="validate.gif" border=0></p>
<h3>What is Valid Input?</h3>
<p>
So how do we determine what constitutes a valid input? The Name field is easy들t just requires some text. We're not going to try to make any judgements about whether or not a name is really a name. Email is similar등e couldn't expect to know if the user name or domain name was real. However, we do know that every valid email address always contains the @ character. Our validation criteria for the Email will just be that등e'll accept the input if we see a @. </p>
<p>
How about the Next Birthday field? A date is more likely to follow a recognizable pattern, so we'll accept the input if it follows any date format our computer understands. With VBScript, it's taken care of easily in just a single line. In addition, we'll add one more parameter. Since we asked for the date of the user's <i>next</i> birthday, we'll need to check that the date hasn't already occurred.</p>
<p>
Now load up the page <b><code>validation.htm</code></b> and enter some different combinations of input. If you enter everything it's asking for, you'll be rewarded by a 404듎bject Not Found reply. We don't want to do anything real with the data at the moment, so드gain듮he <b><code>ACTION</code></b> attribute in our form points to <b><code>DeadLink.asp</code></b>. In a real application we would take the validated data and insert it into a database or perform other processing. If we try to sneak some bad data to the server you'll see dialogs like these:</p>
<p>
<img src="bed.gif" border=0></p>
<p>
<img src="novalues.gif" border=0></p>
<p>
With invalid input, after pressing OK to dismiss the message box, you'll see the same page as before pressing Submit. The form data hasn't been sent to the server, and the page is still waiting patiently for input it can accept.</p>
<h2>The Validation Code</h2>
<p>
We could come up with additional data types ad infinitum, but these will get us started. Requiring some input, an email address, and a date (in a certain range) are some of the most common requests made on HTML forms. In addition, as you'll see when we look at the code, it can be easily extended to incorporate validation for any type of data.</p>
<p>
The non-script HTML for this page isn't anything we haven't seen before. After printing a header, it creates a six-element form with these elements:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=blue width=164><b>Name</b></td>
<td class=blue width=168><b>INPUT Type</b></td>
</tr>
<tr valign=top>
<td width=164><b><code>txtName</code></b></td>
<td width=168><b><code>TEXT</code></b></td>
</tr>
<tr valign=top>
<td width=164><b><code>txtAge</code></b></td>
<td width=168><b><code>TEXT</code></b></td>
</tr>
<tr valign=top>
<td width=164><b><code>txtEmail</code></b></td>
<td width=168><b><code>TEXT</code></b></td>
</tr>
<tr valign=top>
<td width=164><b><code>txtBirthday</code></b></td>
<td width=168><b><code>TEXT</code></b></td>
</tr>
<tr valign=top>
<td width=164><b><code>sbmMyForm</code></b></td>
<td width=168><b><code>SUBMIT</code></b></td>
</tr>
<tr valign=top>
<td width=164><b><code>rstMyForm</code></b></td>
<td width=168><b><code>RESET</code></b></td>
</tr>
</table><br>
<p>
*** can we get the table alongside the paragraph above?</p>
<p>
As always, the action occurs in between the <b><code>&lt;SCRIPT&gt;</code></b> and <b><code>&lt;/SCRIPT&gt;</code></b> tags. All of our code for this example is in one routine, the <b><code>onSubmit</code></b> handler for our form object.</p>
<pre><code>Function myForm_onSubmit
...
...
End Function</code></pre>
<p>
This is different to the other event handlers we often see. Remember that <b><code>myForm_onSubmit</code></b> is a <b><code>Function</code></b>, not a <b><code>Sub</code></b>. Functions return a value, and subroutines don't. With a form, we might want to cancel the form submission. Remember our discussion about this in the last chapter듮he browser is set up to pay attention to the return value of this handler. If we return <b><code>True</code></b>, the form is submitted; if we send back <b><code>False</code></b>, nothing happens들t's like the user never pressed Submit in the first place. An alternative method is to create a normal button with an <b><code>&lt;INPUT</code></b> <b><code>TYPE="BUTTON"&gt;</code></b> tag and submit it using the <b><code>Submit</code></b> method of the <b><code>Form</code></b> object.</p>
<p>
With <b><code>onSubmit</code></b> out of the way, we can focus on the code that does the validation. Since we might want to use this code with a wide variety of different forms, it's been set up so that adding and removing validation for various form fields is easy. The function itself can be subdivided into two parts: the validation code that may change for each form, and the supporting code that prints the error message.</p>
<h3>Supporting the Validation Code</h3>
<p>
Take a look at the all of the code outside of the specific validation sections. This is the code we're talking about:<br>
</p>
<pre><code>Function myForm_onSubmit
   Dim msgError
   Dim fRef
   Set fRef = Document.myForm    'get myForm reference
   '... VALIDATION CODE GOES HERE ... 
   If msgError &lt;&gt; "" Then   'print error message if validation failure
      MsgBox "There was a problem with your submission:" _
             &amp; Chr(13) &amp; msgError &amp; Chr(13) &amp; Chr(13) _
             &amp; "Please change your input and submit again."
      myForm_onSubmit = False
   Else
      myForm_onSubmit = True
   End If
End Function</code></pre>
<p>
This code first prepares for the validation. Then, if a problem with the user's input has been detected, it displays a message box explaining the problem and cancels the form submission. If the input is OK, the form is submitted.</p>
<p>
We first declare two variables, <b><code>msgError</code></b> and <b><code>fRef</code></b>. Like we've said, declaring variables isn't absolutely necessary, but it's good practice and makes our code easier to read. The <b><code>msgError</code></b> variable is what we'll use to store a string describing the problem(s) with the input. We'll write to it in the validation code, and display it if we decide to cancel the form submission. After we declare <b><code>fRef</code></b>, we initialize it with this line of code:<br>
</p>
<pre><code>Set fRef = Document.myForm    'get myForm reference</code></pre>
<p>
The variable <b><code>fRef</code></b> isn't absolutely necessary, but it simplifies our repeated references to the <b><code>myForm</code></b> object. This allows us to use refer to the form in our validation sections with the code:</p>
<pre><code>fRef.txtName.Value</code></pre>
<p>
instead of:</p>
<pre><code>Document.myForm.txtName.Value</code></pre>
<p>
In addition to simplifying our code, this technique makes it run faster. The script engine takes time to resolve each reference, so we shortcut this process by only performing the <b><code>Document.myForm</code></b> resolution once, and saving the result in a variable for later use.</p>
<p>
After these initialization steps the validation code is allowed to do its work. We'll talk about these routines in a second, just understand for now that whenever the code detects a problem with the input it adds some text describing the problem to the string variable <b><code>msgError</code></b>. This is the basis for the code at the end of the routine. Since <b><code>msgError</code></b> starts as an empty string, we know that if it's still an empty string when the validation code is complete then there were no problems with the user's input, and we can submit the form by setting the return value of the <b><code>myForm_onSubmit</code></b> function to <b><code>True</code></b>.</p>
<p>
If <b><code>msgError</code></b> holds anything other than the empty string, then we've found a problem. In this case we display a message box, wrapping the strings There was a problem with your submission: and Please change your input and submit again around the text in <b><code>msgError</code></b> describing the problem. We also set <b><code>myForm_onSubmit</code></b> to <b><code>False</code></b> to cancel the submission. The newline character, <b><code>Chr(13)</code></b>, is used to separate the lines in the message box.</p>
<h3>Validating the Fields</h3>
<p>
The only thing left is to understand how each field is validated. Of course this depends on exactly what constitutes a valid input. Take a look at the code for the Name field, where we just want to make sure the user has entered some text:</p>
<pre><code>&nbsp;&nbsp;&nbsp;If fRef.txtName.Value = "" Then
      msgError = msgError &amp; Chr(13) &amp; "Name must have a value."
   End If</code></pre>
<p>
We first test to see if the value of the <b><code>txtName</code></b> text box is equal to the empty string. If it is we append a newline character and the error string Name must have a value to the <b><code>msgError</code></b> variable and store it back into <b><code>msgError</code></b>. We need to keep any previous contents of <b><code>msgError</code></b> intact, so we can't just assign our error string to the variable들f we did this anything that was there previously it would be overwritten. Name is the first field, so we can be sure there won't ever be anything in <b><code>msgError</code></b> yet, but it's a good practice to stay consistent between validation steps and we <i>will</i> need to append in all the code after this. Plus, it gives us a space between the default error text, and makes our message box look nicer.</p>
<p>
If the user has entered something into the <b><code>txtName</code></b> text box, everything is cool and we can move onto the next field without doing anything to <b><code>msgError</code></b>. All of the validation code follows this pattern: 1 - test the input and, 2a - write <b><code>msgError</code></b> if there's problem, or, 2b - don't write <b><code>msgError</code></b> if things are OK.</p>
<p>
The only additional wrinkles are how we handle different kinds of validation, and how we deal with fields that must meet multiple criteria. Fortunately, the validation code for the Email field demonstrates both of these tasks.</p>
<p>
When checking Email, we need to make sure it not an empty string, and that there is a @ character somewhere in it. We could check both of these in a single statement, but then our error message wouldn't give the user any clue about the specific thing that was wrong with their input. Instead we'll use an additional <b><code>ElseIf</code></b> clause in our code:</p>
<pre><code>&nbsp;&nbsp;&nbsp;If fRef.txtEmail.Value = "" Then
      msgError = msgError &amp; Chr(13) &amp; "Email must have a value."
   ElseIf InStr(fRef.txtEmail.Value, "@") = 0 Then 
      msgError = msgError &amp; Chr(13) &amp; "Email must have an ""@"" sign."
   End If</code></pre>
<p>
We first check to see if anything exists in the text box, because we can't possibly find an <b><code>@</code></b> if the text box is empty. If the user hasn't entered anything in <b><code>txtEmail</code></b> the validation for this field fails and we write the same error string as above into <b><code>msgError</code></b>.</p>
<h3>A Valid Email Address</h3>
<p>
If something does exist, we can use the VBScript <b><code>InStr()</code></b> function to see if the string includes an <b><code>@</code></b>. In its simplest form, <b><code>InStr()</code></b> (short for In String) takes two strings, one string to look in, and one string to look for. If it finds the second string in the first string it returns an integer specifying the location in the first string where the second string begins. If it doesn't find the string, it returns <b><code>0</code></b>.</p>
<p>
It's easy to understand how this code works then. If <b><code>Instr</code></b> doesn't find an <b><code>@</code></b> in the value the user has entered it returns <b><code>0</code></b>, and we know to write the message <b><code>Email</code></b> <b><code>must</code></b> <b><code>have</code></b> <b><code>an</code></b> <b><code>""@""</code></b> <b><code>sign</code></b> to the error string. We want the string displayed in the message box to include double quotation signs around the <b><code>@</code></b>, so we use the VBScript convention of specifying two double quotes when inside a string.</p>
<h3>A Valid Date Value</h3>
<p>
Finally, we need to cover the validation of the Birthday field. In this we need to check three things: that <b><code>txtBirthday</code></b> has a value, that the value is a date, and that the date isn't in the past (since we asked for the user's next birthday). There are a lot of things to check, but they're actually very easy to do using the date manipulation ability of VBScript. The whole of the validation code is only five lines long:</p>
<pre><code>&nbsp;&nbsp;&nbsp;If Not IsDate(fRef.txtBirthday.Value) Then
      msgError = msgError &amp; Chr(13) &amp;_
      "You must enter a date for the birthday field."
   ElseIf CDate(fRef.txtBirthday.Value) &lt; Now Then
      msgError = msgError &amp; Chr(13) &amp;_
      "Next birthday can't be in the past!"
   End If</code></pre>
<p>
We wrap our first two criteria into one test using the <b><code>IsDate</code></b> function. <b><code>IsDate</code></b> takes a variable and returns <b><code>True</code></b> if the value in the variable can be converted into a date, or <b><code>False</code></b> if it can't. Fortunately, the empty string can't be converted into a date, so <b><code>IsDate</code></b> returns <b><code>False</code></b> both when nothing has been entered in the <b><code>txtBirthday</code></b> text box, and when the value entered can't be converted to a date. We can give a meaningful error message for both cases (and avoid using an additional <b><code>ElseIf</code></b> clause) by saying You must enter a date for the birthday field.</p>
<p>
Once we're sure we have a valid date, we can compare it to the current date to make sure the user hasn't tried to sneak in with a date that has already gone. We can easily accomplish this by first converting the value in the text box to a date using the <b><code>CDate</code></b> function and then comparing our date value with the current date returned by the <b><code>Now</code></b> function. Since we're comparing two dates we just need to use the <b><code>&lt;</code></b> (less than) operator to determine if our user's next birthday has already occurred. If it has then we write an appropriate error message to <b><code>msgError</code></b> and we are done.</p>
<p>
<br>
From this discussion you can see how easy it is to add your own tests to the framework. All you need to do is plug in an <b><code>If...Then</code></b> block containing your validation test, and write to <b><code>msgError</code></b> if you detect a problem.</p>
<h2>Adding ASP to the Validation Example</h2>
<p>
Again, there are plenty of ways that we could integrate this example with ASP. In fact it's likely that the results from a form like this will ultimately be stored in a database, so ASP would be an obvious way to manipulate the information after it has been submitted. You'll see some excellent examples of how this can be done in Chapter 12. </p>
<p>
So, like the previous example, you could allow users to edit their details, by fetching them from the database with ASP, and building a page that contained the current values as the defaults. And, again as featured in the Chapter 12 example, we could quite easily add features such as sending a confirmation message to the user by email, using the address they had just entered.</p>
<h3>Client-side vs Server-side Validation</h3>
<p>
One point to remember, and something we discussed in Chapter 6, is that you need to be aware of the limitations of client-side data validation. It is a great way of reducing server load and network traffic, because you can ensure that only data of the appropriate type is submitted from the form. However, there are a couple of problems.</p>
<p>
What you can't do with just client-side validation, is be absolutely sure that the data is valid when it gets to your server. Unscrupulous users could send data from their own forms to your applicationremember that the URL of the page that handles the data is freely visible in the original form page. In the next chapter, you'll see how we can reduce this risk, by using digital certificates and secure channels to communicate the results.</p>
<p>
This also leads to the other concern we expressed in Chapter 6. If the method of validating the data requires some 'secret formula', it's not a good idea to do it in a scripting language on the client, where everyone can view the source of the page and see the code. Instead, you might want to use a custom control on the client, which hides the formula inside the control, or validate this data once you get it back at your server.</p>
</BODY>
</HTML>
