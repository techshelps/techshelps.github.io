<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Manipulating Frames with VBScript and ASP</title>
<style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000 dir=ltr>
<h1><a name="manipulatingframeswithvbscriptasp"></a>Manipulating Frames with VBScript and ASP </h1>
<p>
The first two examples in this chapter showed some things that can be done easily with client-side scripting. However, they didn't actually incorporate any of the features of ASP, we only suggested ways that this could be done. In this and the next examples, we'll be using ASP in conjunction with script code on the client.</p>
<p>
While ASP is great at building the individual pages for a web application dynamically, its features are rather limited when it comes to handling the frameset pages that are so common to today's sites. Using the <b><code>Redirect</code></b> method of the <b><code>Response</code></b> object we can redirect to a single page, but we can't target it to a specific frame—only the browser can do that. The combination of client and server code in this example shows how scripting languages on both sides of the Web connection can, together, manage framesets and the pages inside the frames.</p>
<h2>The Frames Example</h2>
<p>
This is more complicated than the first two examples we looked at. Before we launch into an explanation of what this example does, you might like to bring up <b><code>frameset.asp</code></b> in your browser and see for yourself. Experiment by clicking on a few of the links in the left hand pane. We'll spend some time discussing the code that makes this sample work, and you'll understand it better if we're familiar with the samples behavior in the browser. Since this is now an ASP file, you also need to be sure that it comes from your server and is loaded via HTTP.</p>
<p>
You'll notice that clicking on a page link on the left hand side loads that page into the right hand frame, and also updates the left frame itself so that only links to the pages not currently shown are available. This makes sense—if we're already viewing the second page we shouldn't be able to jump to it again.</p>
<p>
<img src="pagetwo.gif" border=0></p>
<p class=indent>
Since we're viewing page two in the right hand frame, it's not visible in the list in the left hand frame.</p>
<p>
Now click over to the third page, and you'll see a list of options in the main frame. If you choose one of the Option links, rather than a Page link, you'll see the left frame refresh with a list of the remaining options, and the right frame with the actual page you selected. If you watch closely, you'll see that the left frame is refreshed a split second <i>before</i> the right frame is updated. We'll talk about why this happens later in this section.</p>
<p>
<img src="three2.gif" border=0></p>
<p>
So that's what this example does: it displays a variety of pages in the main section of a two-pane frameset and keeps the left-hand pane in sync—and it uses both client and server-side scripting to accomplish this.</p>
<p>
<img src="fstart.gif" border=0></p>
<p>
If you've designed a site with frames before, you know that creating a two-pane frameset with a navigation frame and contents frame isn't too difficult. The frameset HTML file contains the size and URL information for the frames, so that they can be created and laid out. Each of the pages is a separate file, as specified in the frameset file, and these are loaded into the frames just created. </p>
<p>
Once the pages have been rendered, new pages are targeted to a specific frame by adding the <b><code>TARGET</code></b> attribute to the links that modify the other frame. For example, our frameset has two frames called <b><code>NavBar</code></b> and <b><code>MainFrame</code></b>. To change the contents of <b><code>MainFrame</code></b> from a click on a link in <b><code>NavBar</code></b>, we'd just use:</p>
<pre><code>&lt;A HREF="mypage.htm" TARGET="MainFrame"&gt;Go To My Page&lt;/A&gt;</code></pre>
<p>
However, with this method, the left-hand frame doesn't change to reflect what is shown in the main frame. Our example does allow this, and this significant improvement comes from the combination of ASP and client-side code.</p>
<p>
Where would we use something like this? The answer is any place that we currently use (or could use) frames, but want to give the viewer of our site more feedback as to what is happening. Or perhaps we'd like to customize the available options based on which user is accessing our site, or what part of the site they're viewing. We can easily extend this example to the specific needs of our site, but first we should understand how the code works. </p>
<h2>How It Works</h2>
<p>
In contrast to the first two examples (and the next one), this sample consists of more than a few files, although the interesting work takes place primarily in two files: <b><code>frameset.asp</code></b> and <b><code>navbar.asp</code></b>. It's no coincidence that these files are the only Active Server pages of the whole lot. The rest of the pages are simple HTML files—that in the real, non-book-example, world would hold the site's content. So we can keep things straight, all of the files are listed below: </p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=blue width=270><b>Filename</b></td>
<td class=blue width=270><b>Purpose</b></td>
</tr>
<tr valign=top>
<td width=270><b><code>frameset.asp</code></b></td>
<td width=270>The top-level frameset page</td>
</tr>
<tr valign=top>
<td width=270><b><code>navbar.asp</code></b></td>
<td width=270>Navigation bar (left-hand pane) page</td>
</tr>
<tr valign=top>
<td width=270><b><code>pageone.htm</code></b></td>
<td width=270>Page one</td>
</tr>
<tr valign=top>
<td width=270><b><code>pagetwo.htm</code></b></td>
<td width=270>Page two</td>
</tr>
<tr valign=top>
<td width=270><b><code>pagethree.htm</code></b></td>
<td width=270>Page three (with option links)</td>
</tr>
<tr valign=top>
<td width=270><b><code>option1.htm</code></b></td>
<td width=270>Option page one</td>
</tr>
<tr valign=top>
<td width=270><b><code>option2.htm</code></b></td>
<td width=270>Option page two</td>
</tr>
<tr valign=top>
<td width=270><b><code>option3.htm</code></b></td>
<td width=270>Option page three</td>
</tr>
<tr valign=top>
<td width=270><b><code>option4.htm</code></b></td>
<td width=270>Option page four</td>
</tr>
</table><br>
<h3>Creating the Frameset with ASP</h3>
<p>
We first need to understand how the <b><code>frameset.asp</code></b> page works. This is the page you loaded into your browser earlier, and it's where everything starts. The ASP code in the page sets the values of two variables, <b><code>NavBarPage</code></b> and <b><code>MainFramePage</code></b>, depending on the value passed to the page in the URL. We'll see this in a while—just accept for now that they are set up correctly. So, <b><code>frameset.asp</code></b> sets up the frameset with different pages:</p>
<pre><code>... the ASP code that sets NavBarPage and MainFramePage goes here ...
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;TITLE&gt; Frameset Demonstration &lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;FRAMESET COLS="150,*"&gt;
   &lt;FRAME NAME="NavBar" SRC="&lt;%= NavBarPage %&gt;" SCROLLING="AUTO"&gt;
   &lt;FRAME NAME="MainFrame" SRC="&lt;%= MainFramePage %&gt;" SCROLLING="AUTO"&gt;
&lt;/FRAMESET&gt;
&lt;/HTML&gt;</code></pre>
<p>
The <b><code>&lt;FRAMESET</code></b> <b><code>COLS="150,*"&gt;</code></b> line creates a frameset consisting of two columns. The width of the left-hand column is <b><code>150</code></b> pixels, and the right hand column takes up the remainder. The two <b><code>&lt;FRAME&gt;</code></b> tags provide the information about each frame. The <b><code>NAME</code></b> attribute defines the frame's name, and is important because it's what we use in our links and script code to refer to the frame. The <b><code>SCROLLING</code></b> attribute turns scrolling on if needed. But what of the <b><code>SRC</code></b> attribute with that familiar ASP code string <b><code>&lt;%= ... %&gt;</code></b> ? </p>
<h3>Selecting the Pages to Display</h3>
<p>
We're telling ASP to insert whatever is in the variables <b><code>NavBarPage</code></b> and <b><code>MainFramePage</code></b> into the <b><code>&lt;FRAME&gt;</code></b> tags. The important thing is how these variables are set, and to understand this we need to look at the code we didn't show in the listing above. The page expects to find an argument in the query string, containing a parameter called <b><code>Nav</code></b>. In other words, it expects to be called with a URL like this:</p>
<pre><code>http://www.yoursite.com/frameset.asp?Nav=all</code></pre>
<p>
Here's the code itself:</p>
<pre><code>&lt;%  'get Nav and use it to determine which frames to display
    'and which parameter to call navbar.asp with
NavChoice = Request.QueryString("Nav")
Select Case NavChoice
   Case "pageone"
      NavBarPage = "navbar.asp?BarChoice=pageone"
      MainFramePage = "pageone.htm"
   Case "pagetwo"
      NavBarPage = "navbar.asp?BarChoice=pagetwo"
      MainFramePage = "pagetwo.htm"
   Case "pagethree"
      NavBarPage = "navbar.asp?BarChoice=pagethree"
      MainFramePage = "pagethree.htm"
   Case "all"
      NavBarPage = "navbar.asp?BarChoice=all"
      MainFramePage = "main.htm"
   Case Else   'choose all
      Response.Redirect "frameset.asp?nav=all"
 
End Select  %&gt;
... HTML code is here ...</code></pre>
<p>
The first line of real code uses the <b><code>QueryString</code></b> collection of the <b><code>Request</code></b> object to get the value of the <b><code>Nav</code></b> parameter, if it exists, from the URL. We store that value in the variable called <b><code>NavChoice</code></b>. With this information the code uses a <b><code>Select</code></b> <b><code>Case</code></b> statement to set the variables depending on what was specified in the URL. By using <b><code>all</code></b>, we can ask for the main content page (<b><code>main.htm</code></b>) to be displayed in the main frame, and the navigation bar to show links to all three pages.</p>
<p>
If there is no value for <b><code>Nav</code></b> in the query string, as when we first loaded the page, the <b><code>Else</code></b> part of the <b><code>Select Case</code></b> construct is executed. This uses the <b><code>Response</code></b> object's <b><code>Redirect</code></b> method to refresh the page, showing the main content page and all of the links. Of course, we could have copied the code down from the <b><code>all</code></b> clause immediately above it—it has exactly the same effect. However, this is better style because it means we only have to change our code in one place if we decide to modify the default action.</p>
<p>
Looking at the clauses themselves, it's easy to understand what they are doing. They put the name of the file that should be loaded into the main frame into <b><code>MainFramePage</code></b>. When our <b><code>Nav</code></b> option is <b><code>pageone</code></b> it's logical to think that <b><code>pageone.htm</code></b> should be the page we see, and so on. However, notice that setting the <b><code>NavBarPage</code></b> variable is a little different—we're loading the same file <b><code>navbar.asp</code></b> in each case. What our code does, however, is add a different parameter to the query string each time.</p>
<h3>The Dynamic Navigation Bar</h3>
<p>
This is because the <b><code>navbar.asp</code></b> file changes its behavior, depending on the <b><code>BarChoice</code></b> value included in the URL. The part of <b><code>navbar.asp</code></b> that we're interested in is this:</p>
<pre><code>&lt;% BarChoice = Request.QueryString("BarChoice")
Select Case BarChoice
   Case "pageone" %&gt;
      &lt;TABLE WIDTH="100%" BORDER="2" CELLPADDING="5" CELLSPACING="2"&gt;
         &lt;TR&gt;
            &lt;TD ALIGN="CENTER"&gt;&lt;A HREF="javascript:GoPageTwo()"&gt;
            Page Two&lt;/A&gt;&lt;/TD&gt;
         &lt;/TR&gt;
         &lt;TR&gt;
            &lt;TD ALIGN="CENTER"&gt;&lt;A HREF="javascript:GoPageThree()"&gt;
            Page Three&lt;/A&gt;&lt;/TD&gt;
         &lt;/TR&gt;
      &lt;/TABLE&gt;
      &lt;P&gt;&lt;CENTER&gt;&lt;H3&gt; Page One &lt;/H3&gt;&lt;/CENTER&gt;
... similar code for "pagetwo", "pagethree" and "all" goes here ...</code></pre>
<p>
This works almost identically to the code in <b><code>frameset.asp</code></b>. First it stores the value of the <b><code>BarChoice</code></b> part of the URL in a variable of the same name, and then uses this variable in a <b><code>Select</code></b> <b><code>Case</code></b> construct to output the appropriate set of <b><code>&lt;TABLE&gt;</code></b> and <b><code>&lt;A&gt;</code></b> tags. When <b><code>BarChoice</code></b> equals <b><code>pageone</code></b>, the code only outputs links to <b><code>pagetwo.htm</code></b> and <b><code>pagethree.htm</code></b>. The code for the <b><code>pagetwo</code></b>, <b><code>pagethree</code></b>, and <b><code>all</code></b> options is nearly identical to the code here, so we haven't listed it. You can check it out in the <b><code>navbar.asp</code></b> source.</p>
<h3>Changing Both Frames with Client-Side Code: Method One</h3>
<p>
Now that we've talked about how the two most important pages are created, we can discuss that new enigma we've unearthed: the use of <b><code>javascript:function-name()</code></b> in the anchor tags in <b><code>navbar.asp</code></b>. As we said earlier, it's possible to change the contents of one frame, when a link in another is clicked, by using the <b><code>TARGET</code></b> attribute in normal HTML. However, in our case, what we want to do is update <i>both</i> of the frames in our frameset, and HTML doesn't provide a way to do this. Fortunately, our task can be accomplished with a little client-side code. We show two different methods to accomplish this in the sample, and we're ready to discuss the first now.</p>
<p>
If you remember back to the object model discussion in the last chapter, you'll recall the <b><code>Frames</code></b> collection of the <b><code>Document</code></b> object, and the <b><code>Location</code></b> object. <b><code>Frames</code></b> provides an interface to each frame in a frameset, while the <b><code>Location</code></b> object gives information about the current page displayed in the frame. Each frame and window has a <b><code>Location</code></b> object. It's no surprise, then that two lines of code can change the contents of both of our frames:</p>
<pre><code>parent.frames("NavBar").location.href = "navbar.asp?BarChoice=pageone"
parent.frames("MainFrame").location.href = "pageone.htm"</code></pre>
<p>
We need to remember that, to access the <b><code>Location</code></b> objects of the frames in our frameset, we need to go back one step to the top-level frame. The <b><code>Frames</code></b> collection of the <b><code>NavBar</code></b> and <b><code>MainFrame</code></b> frames are both empty because these frames don't have any sub-frames. However, the parent frame of <b><code>NavBar</code></b> and <b><code>MainFrame</code></b> includes both <b><code>NavBar</code></b> and <b><code>MainFrame</code></b>. In the code above we use the <b><code>Parent</code></b> property of the (default) <b><code>Window</code></b> object to access the correct collection. Once we have the reference to the correct frame, setting the <b><code>HRef</code></b> property of the <b><code>Location</code></b> object causes the current window to display whatever URL is specified. </p>
<p>
The only thing we haven't talked about is how the code above actually gets executed. Normally we connect client-side code to an event raised by an object. For example, we might execute code when form button is clicked, i.e. the <b><code>onClick</code></b> event is fired. In this case we'd like to execute the code when a link is clicked. Link objects do have an event called <b><code>onClick</code></b>, and we could specify that our relocation code be executed in response to this event. We're not going to use it in this case, because then we'd have to follow the unsightly practice of specifying an <b><code>HREF</code></b> attribute whose value is the empty string (because our code would be doing all the work). Holding the mouse over a link with no value can confuse viewers who depend on the status bar to see where they're going. In addition, in a more graphical site we might want to do the same thing but with an image map, and these don't have <b><code>onClick</code></b> events like <b><code>Link</code></b> objects do. Instead we'll directly specify the code to executed in the <b><code>HREF</code></b> attribute. This is where the <b><code>javascript:function-name()</code></b> syntax comes into our lives.</p>
<h3>Using javascript: function-name() with VBScript</h3>
<p>
We've been using VBScript in the last few chapters, but Internet Explorer doesn't support the <b><code>vbscript:subroutine-name</code></b> syntax. It does support the equivalent <b><code>javascript:function-name()</code></b>. The clever part if that, if we specify the name of a VBScript subroutine instead of a JavaScript function it still works. The VBScript routine is executed correctly, and this is exactly what we do in on this page of the sample. The parts of <b><code>navbar.asp</code></b> we haven't see yet contain these routines:</p>
<pre><code>&lt;SCRIPT LANGUAGE="VBScript"&gt;
&lt;!--
Sub GoPageOne()
   parent.frames("NavBar").location.href = "navbar.asp?BarChoice=pageone"
   parent.frames("MainFrame").location.href = "pageone.htm"
End Sub
... more similar routines here ...
--&gt;
&lt;/SCRIPT&gt;
...
&lt;TD ALIGN="CENTER"&gt;&lt;A HREF="javascript:GoPageOne()"&gt;Page One&lt;/A&gt;&lt;/TD&gt;</code></pre>
<p>
Putting this all together, we can see that clicking the Page One link causes the browser to execute the code in the <b><code>GoPageOne</code></b> subroutine, and this code loads <b><code>pageone.htm</code></b> into the main frame and reloads <b><code>navbar.asp</code></b> with <b><code>BarChoice</code></b> equal to <b><code>pageone</code></b>. The rest of the Page links follow the same format. They call a VBScript function that changes the <b><code>HRef</code></b> properties of both frames to the correct URLs. When <b><code>navbar.asp</code></b> reloads, it changes the page links displayed, and everything is ready to go again.</p>
<h3>The Option Links on Page Three</h3>
<p>
The last major feature of this example, which we haven't talked about yet, is the set of option links on page three. If you haven't already seen these, open up page three by clicking on the appropriate link.</p>
<p>
<img src="pthree.gif" border=0></p>
<p>
Click on one of the option links in the main frame. The <b><code>NavBar</code></b> frame reloads, displaying links to all three pages and to the options that weren't selected. The page for the option we clicked is displayed in the main frame.</p>
<p>
<img src="option2.gif" border=0></p>
<p>
We could have implemented this in the same way we did the page navigation, but we've chosen an alternative method so that we can keep all of the navigation code in <b><code>navbar.asp</code></b>. If we used the first method, we would have to add many additional functions to the third page, making the content more difficult to modify independently of the script code, and further melding the site's logic and content—not a good thing. </p>
<p>
In addition, suppose we had option arrays like this on each of our three pages. All of a sudden we need to maintain navigation code in four documents instead of one. Finally, as you'll see when we look at the code that implements this in <b><code>navbar.asp</code></b>, we are able to use the similarities between the text strings to move most of the code into a loop, further simplifying our design. In a real world situation we'd be far more likely to use entries from a database to populate this list, but even then the same code can apply—using the unique identifier for each database record instead of our arbitrary series of options from 1 to 4.</p>
<h3>Changing Both Frames with Client-Side Code: Method Two</h3>
<p>
Those are the benefits, but how exactly does this second scheme work? Our first clue is the <b><code>HREF</code></b> attribute of each of the links on page three. Here's the code for the first link:</p>
<pre><code>&lt;LI&gt;&lt;A TARGET="NavBar" HREF="navbar.asp?BarChoice=onelink&amp;id=1"&gt;Option One&lt;/A&gt;</code></pre>
<p>
We're using the <b><code>TARGET</code></b> attribute, which is the good old HTML-only way of targeting a page with a frame different to the one containing the link. The HTML here changes the contents of <b><code>NavBar</code></b> (which, since this code is in <b><code>MainFrame</code></b>, is the other frame) to the URL <b><code>"navbar.asp?BarChoice=onelink&amp;id=1"</code></b>. This code doesn't do anything about changing the page loaded into <b><code>MainFrame</code></b>, yet the page itself does indeed change.</p>
<p>
It's only possible to directly change one frame or window with the <b><code>TARGET</code></b> attribute of the anchor tag. However, with some strategically placed client-side code, we can change more than that. In our example, code in <b><code>navbar.asp</code></b> is changing the contents of <b><code>MainFrame</code></b>, using the value of the <b><code>BarChoice</code></b> parameter—<b><code>onelink</code></b> in this case—to determine which block of code to execute. The value <b><code>id</code></b> parameter that follows it is used by the <b><code>onelink</code></b> code, as we'll see in a moment. Think about that for a second. The sequence is:
<ul type=disc>
<li>
Click on a link in frame <b><code>MainFrame</code></b> that points to <b><code>NavFrame</code></b> and <b><code>navbar.asp</code></b>,<br><br></li>
<li>
The <b><code>navbar.asp</code></b> page reloads and <b><code>NavFrame</code></b> is updated,<br><br></li>
<li>
Code in <b><code>navbar.asp</code></b> reloads <b><code>MainFrame</code></b>.</li>
</ul>
<p>
<br>
For example, the first link on page three passes the query string <b><code>BarChoice=onelink&amp;id=1</code></b> to the navigation bar file <b><code>navbar.asp</code></b>. We've already looked at the <b><code>pagexxx</code></b> values of the <b><code>BarChoice</code></b> parameter that this code can handle, so let's look now at the final choice, <b><code>onelink</code></b>. The <b><code>Select</code></b> <b><code>Case</code></b> clauses for the other pages consisted of a block of HTML. The clause for <b><code>onelink</code></b> is a little more complicated, including two sets of ASP script in addition to the same HTML. We'll start with the familiar and move quickly into new territory.</p>
<h3>The Navigation Bar 'onelink' Code</h3>
<p>
We see the same old table listing page options at the top of the finished <b><code>onelink</code></b> frame, and it's no surprise—the first visible HTML generated by <b><code>navbar.asp</code></b> for this option is the same as we've seen before in the other categories. After this table we display the list of options that aren't currently displayed. If we're currently showing <b><code>Option3.htm</code></b> in the main frame, we'd like to display links to options one, two, and four in the navigation bar. Our ASP code for this looks like:</p>
<pre><code>&lt;% For i = 1 to 4
      If CInt(CurrOption) &lt;&gt; i Then  'print link %&gt;
         &lt;A HREF="navbar.asp?barchoice=onelink&amp;id=&lt;%= i %&gt;"&gt;
         Option &lt;%= i %&gt;&lt;/a&gt;&lt;p&gt;
&lt;%    End If
   Next %&gt;</code></pre>
<p>
And it generates this HTML:</p>
<pre><code>&lt;A HREF="navbar.asp?barchoice=onelink&amp;id=1"&gt;Option 1&lt;/a&gt;&lt;p&gt;
&lt;A HREF="navbar.asp?barchoice=onelink&amp;id=2"&gt;Option 2&lt;/a&gt;&lt;p&gt;
&lt;A HREF="navbar.asp?barchoice=onelink&amp;id=4"&gt;Option 4&lt;/a&gt;&lt;p&gt;</code></pre>
<p>
The code loops once for each element in our array of options, printing out a link every time, except for when the value stored in <b><code>CurrOption</code></b> is the same as our loop index. At the top of the <b><code>onelink</code></b> code we set a local variable called <b><code>CurrOption</code></b> to the value of the id portion of the query string. So calling <b><code>onelink</code></b> with an additional <b><code>&amp;id=3</code></b> causes <b><code>CurrOption</code></b> to be set to <b><code>3</code></b>. This is the first use of the <b><code>id</code></b> parameter we've talked about—the second is in the code that loads the main frame.</p>
<h3>Creating VBScript Code Dynamically</h3>
<p>
If you've looked at the entire code for the <b><code>onelink</code></b> clause you noticed this somewhat nasty looking section right at the beginning of the block:</p>
<pre><code>Response.Write "&lt;SCRIPT LANGUAGE=" &amp; Chr(34) &amp; "VBScript" &amp; Chr(34) &amp; "&gt;" _
                &amp; Chr(13) &amp; Chr(10)
Response.Write "&lt;!--" &amp; Chr(13) &amp; Chr(10)
Response.Write "Sub Window_OnLoad()" &amp; Chr(13) &amp; Chr(10)
Response.Write "On Error Resume Next" &amp; Chr(13) &amp; Chr(10)
strTemp = "Parent.frames(" &amp; Chr(34) &amp; "MainFrame" &amp; Chr(34) _
        &amp; ").location.href = " &amp; Chr(34) &amp; "Option" &amp; CurrOption _
        &amp; ".htm" &amp; Chr(34)
Response.Write strTemp
Response.Write Chr(13) &amp; Chr(10)
Response.Write "End Sub" &amp; Chr(13) &amp; Chr(10)
Response.Write "--&gt;" &amp; Chr(13) &amp; Chr(10)
Response.Write "&lt;/SCRIPT&gt;" &amp; Chr(13) &amp; Chr(10)</code></pre>
<p>
But, before we let ourselves be scared away by this mess, take a look at the nice and simple HTML code it generates for the browser:</p>
<pre><code>&lt;SCRIPT LANGUAGE="VBScript"&gt;
&lt;!--
Sub Window_OnLoad()
   On Error Resume Next
   Parent.frames("MainFrame").location.href = "Option3.htm"
End Sub
--&gt;
&lt;/SCRIPT&gt;</code></pre>
<p>
What we have here is a block of ASP code on the server that generates a block of code that is to be executed on the client. This is very powerful—we're actually changing our client-side code 'on the fly' to suit our purposes.</p>
<p>
Let's first understand how <b><code>navbar.asp</code></b> is using this code to reload <b><code>MainFrame</code></b>, and then we'll talk a little more about the ASP code that generated the code in the first place. The client-side code we end up with is relatively simple. Immediately after the HTML page has finished loading, the <b><code>Window_onLoad</code></b> event fires. In the code that is executed, we're using the <b><code>Frames</code></b> collection and <b><code>Location</code></b> object to load the contents of <b><code>Option3.htm</code></b> into our main frame. The only wrinkle is the handy placement of <b><code>On</code></b> <b><code>Error</code></b> <b><code>Resume</code></b> <b><code>Next</code></b> to avoid any unsightly errors in the navigation frame if a non-existent URL is accidentally specified in the next line.</p>
<p>
All the ASP code does is to generate this small four-line subroutine by using a series of <b><code>Response.Write</code></b> calls. It uses <b><code>Chr(34)</code></b> to generate double quotes that can't be specified directly in the code because they will be interpreted as server-side code, and the line feeds and carriage returns so the final output is neatly placed on separate lines.</p>
<h3>Moving the Code to Our Own Site</h3>
<p>
That's all for this sample. We've covered a lot in the last few pages, and really showed how ASP can be used with client-side code to generate pages that weren't possible with just HTML or client-side code alone.</p>
<p>
In moving the concepts in this example to your own site, you would keep much of the existing <b><code>frameset.asp</code></b> and <b><code>navbar.asp</code></b> code, modifying it to point to the actual files in your site. The rest of the files (<b><code>page*</code></b> and <b><code>option*</code></b>) would be replaced by your content. </p>
</BODY>
</HTML>
