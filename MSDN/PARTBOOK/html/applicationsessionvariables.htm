<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Application and Session Variables</title>
<style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000 dir=ltr>
<h1><a name="applicationsessionvariables"></a>Application and Session Variables</h1>
<p>
The <b><code>Application</code></b> and <b><code>Session</code></b> objects can be used to store values that are global either to a particular user (the <b><code>Session</code></b>) or to all users (the <b><code>Application</code></b>). Within the <b><code>onStart</code></b> events, we can initialize these variables. We can also store new variables, or change existing values, in the code inside any other ASP page. </p>
<p>
Initializing variables is very important, especially with a language like VBScript that uses <b><code>Variants</code></b>. Imagine the following code in a page: </p>
<pre><code>Response.Write("The current value is: " &amp; Session("MyValue"))</code></pre>
<p>
This places the contents of the <b><code>Session</code></b> variable <b><code>MyValue</code></b> in the page. The only problem with this code is if the variable has not been initialized. What we get is:</p>
<pre><code>The current value is:</code></pre>
<p>
Any <b><code>Variant</code></b> (the only data type available in VBScript) that has not been assigned a value is said to be <b><code>Empty</code></b>. Because we are dumping the variable as its default type, we get nothing. The best way to solve this type of problem is either assign a default value to it, or examine the variable using the <b><code>IsEmpty()</code></b> function. Here's how we could use <b><code>IsEmpty()</code></b>:</p>
<pre><code>varTheValue = Session("MyValue")
If IsEmpty(varTheValue) Then varTheValue = "* Undefined *"
Response.Write("The current value is: " &amp; varTheValue)</code></pre>
<p>
Alternatively, we can set any default value we like in the <b><code>Session_onStart</code></b> event, so that we have a value ready for access in that session:</p>
<pre><code>Sub Session_OnStart
  Session("MyValue") = 42
End Sub</code></pre>
<h2>Counting Sessions</h2>
<p>
An immediately obvious use of this technique is to count how many sessions have occurred during the current application. All we do is use a variable stored in the <b><code>Application</code></b> object, which is then available to all sessions:</p>
<pre><code>Sub Application_OnStart
  Application("NumVisitors") = 0
End Sub</code></pre>
<p>
Now, in <b><code>Session_onStart</code></b>, we can increment the value for each new session:</p>
<pre><code>Sub Session_OnStart
  Application.Lock
  Application("NumVisitors") = Application("NumVisitors") + 1
  Application.Unlock
End Sub</code></pre>
<p>
Them we can drop it into the 'welcome' page with a few lines of code:</p>
<pre><code>&lt;% Application.Lock %&gt;
&lt;H3&gt; Your are visitor number &lt;% = Application("NumVisitors") %&gt; &lt;/H3&gt;
&lt;% Application.Unlock %&gt;
</code></pre>
<p>
<img src="visitor.gif" border=0></p>
<h2>Storing Array Variables</h2>
<p>
As we briefly mentioned in Chapter 2, we have a problem when storing arrays in a <b><code>Session</code></b> or <b><code>Application</code></b> object, which maintain all values as <b><code>Variants</code></b>. The following example shows how we can get round this limitation:</p>
<pre><code><b>'Create and initializing the array
</b>Dim MyArray()
ReDim MyArray(5)
MyArray(0) = "hello"
MyArray(1) = "some other string"
'Store the array in the Session object
Session("StoredArray") = MyArray
'Now retrieve the array from the Session object
LocalArray = Session("StoredArray")
LocalArray(1) = "there"
...
'and then store the updated one back again
Session("StoredArray") = LocalArray
...</code></pre>
<p>
We create the array <b><code>MyArray()</code></b>and <b><code>ReDim</code></b> it to hold five elements. Then we assign strings to the elements <b><code>0</code></b> and <b><code>1</code></b>,and simply assign the array directly to a variable <b><code>StoredArray</code></b> in the <b><code>Session</code></b> object. We've effectively converted our array of strings into a <b>variant</b> <b>array</b>, and stored it in a single <b><code>Variant</code></b> in the <b><code>Session</code></b>.</p>
<p>
Later in the same script, or in another request in the same session, we can retrieve the array using <b><code>LocalArray</code></b> <b><code>=</code></b> <b><code>Session("StoredArray")</code></b>, then access it as normal using the indexes. You might be tempted to believe that instead of assigning the array to a single <b><code>Session</code></b> variable, we could access it using <b><code>Session("StoredArray")(1)</code></b> <b><code>=</code></b> <b><code>"there"</code></b>, but this is <i>not</i> the correct method. It will result in loss of data.</p>
<p class=indent>
The <b><code>Application</code></b> and <b><code>Session</code></b> objects' variables are implemented as collections, however we should not actually access them in this way—it is not documented or recommended. Neither is it possible to store references to any of the Active Server Pages built-in objects—for example the statement <b><code>Set</code></b> <b><code>Session("MyRequest")</code></b> <b><code>=</code></b> <b><code>Request</code></b> is not legal.</p>
<h2>Reference Counting with the Application Object</h2>
<p>
You'll recall we suggested earlier that the <b><code>Application_onEnd</code></b> event might not be fired until the Web server is stopped. So what happens to the global objects that are stored within the <b><code>Application</code></b> object? They are kept alive and available all of the time. If you have a resource that you don't want to be kept in memory for days on end, when the application is not in use, the following code solves the problem, and demonstrates some of the ways of using the <b><code>Application</code></b> and <b><code>Session</code></b> objects:</p>
<pre><code>Sub Session_OnStart
  Application.Lock
  If IsEmpty(Application("Object")) Then
    Set Application("Object") = Server.CreateObject("global.connection")
    Application("ObjectCount") = 0
  End If
  Application("ObjectCount") = Application("ObjectCount") + 1
  Application.Unlock
End Sub
Sub Session_OnEnd
  Application.Lock
  Application("ObjectCount") = Application("ObjectCount") - 1
  If Application("ObjectCount") = 0 Then
    Set Application("Object") = Nothing
  End If
  Application.Unlock
End Sub</code></pre>
<p>
The technique we use in this code is called <b>reference</b> <b>counting</b>. Notice that the <b><code>Application</code></b> <i>events</i> are not used, but the <b><code>Application</code></b> <i>object</i> is. All the events are those that occur for each <b><code>Session</code></b>. The technique, however, is simple enough. At the start of each <b><code>Session</code></b>, we only create an instance of the object we want (in this case a fictitious <b><code>"global.connection"</code></b>) if it does not already exist. At the end of each <b><code>Session</code></b>, we destroy the object if no-one else is using it. If you like, it's the old 'last one out turn off the lights' trick.</p>
<h3>How It Works</h3>
<p>
This code works by keeping a count of the number of users that are using the application at any one time, storing this count in a global variable called <b><code>ObjectCount</code></b>. If this is zero, or does not exist, the <b><code>Session_onStart</code></b> code creates the object and stores the reference to it in the <b><code>Application</code></b> object as a variable called <b><code>Object</code></b>, and it's then available to all users. At the same time, it sets the value of <b><code>ObjectCount</code></b> to zero, in case it didn't actually exist—in other words if this was the first ever session to use the application.</p>
<p>
The next step is to increment the value of <b><code>ObjectCount</code></b>, so that it reflects the number of current sessions. If the object already exists when a <b><code>Session</code></b> starts, and the <b><code>Object</code></b> variable does reference an object when this session begins (i.e. it's not <b><code>Empty</code></b>), the code will just increment <b><code>ObjectCount</code></b> without creating a new instance of the object.</p>
<p>
The <b><code>Session_onEnd</code></b> code, which runs for each <b><code>Session</code></b> as it ends, just has to decrement the value of <b><code>ObjectCount</code></b>, and it can then tell how many other sessions are still active. If this is zero it can destroy the object by setting its reference variable to <b><code>Nothing</code></b>.</p>
<p>
Notice that we've again used the <b><code>Application</code></b> object's <b><code>Lock</code></b> and <b><code>Unlock</code></b> methods before changing the values of any of its variables. Failing to do this can cause all kinds of problems by allowing more than one session to access the values at the same time. This concept is called <b>concurrency</b>, and we'll look at the implications that arise from it next. </p>
</BODY>
</HTML>
