<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>A Non-Microsoft Scenario</title>
<style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000 dir=ltr>
<h1><a name="anonmicrosoftscenario"></a>A Non-Microsoft Scenario</h1>
<p>
If you've surfed the Internet at all, you've probably encountered sites or web pages which require a password and user ID. When such a page is reached, the browser would pop up a little password entry dialog box. The interesting thing here is that there seems to be something built into the browser-server combination that provides this authentication capability. Yet, if you were to look into the documentation for the browser (and sometimes even from the server), you may be surprised to find that this capability is often not well described. At any rate, there seems to be no standard way to follow for authenticating a remote user using a random browser and server combination. How exactly is this done?</p>
<p>
The secret, it turns out, lies in the transmitted HTTP packet's header information.</p>
<p>
The scenario which leads to the triggering of the pop-up on the browser is as follow:</p>
<ol>
<li>
The client clicked on a link on the browser display which attempts to access some protected resource<br><br></li>
<li>
The browser, having no way to tell a requested resource is protected, formats a normal HTTP request packet and transmit it to the server asking for the resource<br><br></li>
<li>
The server attempts to access the resource and faces an 'access denied' situation<br><br></li>
<li>
The server sends an access denied HTTP response packet back to the client, but in the header indicates the authentication schemes that the server will support in the order of preference<br><br></li>
<li>
The browser receives the 'access denied' packet, and looks into the header to find the authentication schemes supported by the server and matches it against what it would support<br><br></li>
<li>
If the lowest common denominator between the browser and server authentication support is basic authentication, the browser will pop-up the dialog box asking the user for a user ID and password<br><br></li>
<li>
The user keys in the user ID and password<br><br></li>
<li>
The browser retries the request packet, this time including the desired authentication method, the user ID, and Base64-encoded (totally unsecured) password in the header<br><br></li>
<li>
The server receives the request packet with authentication information, impersonates the client if authentication is successful, and accesses the protected resource on behalf of the remote user<br><br></li>
<li>
The server sends the contents of the requested resource back to the browser which promptly displays it</li>
</ol>
<p>
We should notice a few distinguishing points about the above scenario:
<ul type=disc>
<li>
Nothing about it is specific to Microsoft or ActiveX: the situation can be handled with any browser supporting basic authentication, and any server running on any operating system which supports authentication capabilities<br><br></li>
<li>
If the user were to access a series of protected pages, the above scenario would repeat itself, asking the user to repeatedly enter his or her user ID and password<br><br></li>
<li>
The password of the user is sent over the wire with minimal encoding, leaving it vulnerable to potential interception</li>
</ul>
<p>
The form of authentication detailed above is called <b>basic authentication</b> and is the most widely used one over the Internet, since most browser, web server, and operating system combinations will support it.</p>
</BODY>
</HTML>
