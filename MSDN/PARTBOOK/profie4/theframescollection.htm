<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The frames Collection</title>
<style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000 dir=ltr>
<h1><a name="theframescollection"></a>The frames Collection</h1>
<p>
The last major element of the <b><code>window</code></b> object, aside from its descendant objects, is the <b><code>frames</code></b> collection. This collection exists to give a developer access to all of the frames in any frameset currently displayed in the browser.</p>
<p>
The <b><code>frames</code></b> collection is indexed from 0 so that a three-frame frameset, like the one that follows, has three elements in the <b><code>frames</code></b> collection, numbered from 0 to 2. It's important to note that this three-element collection is only seen from the top-level window – more about this in a second.</p>
<p>
<img src="win01.gif" border=0></p>
<p>
Each frame is a <b><code>window</code></b> object itself, and each frame reference returns a reference to a <b><code>window</code></b> object. All we need is a reference to a <b><code>window</code></b> object to enable our use of the properties and methods we've spent the last few pages discussing. It shouldn't be surprising then that the <b><code>frames</code></b> collection allows us to control each frame in a frameset as if we're controlling a separate window. In fact, this is exactly what we're doing. Each element in the <b><code>frames</code></b> collection is a reference to a new <b><code>window</code></b> object.</p>
<h2>Accessing Collection Members by Index and Name</h2>
<p>
For example, this code changes the URL of the bottom left-hand frame in the frameset above:</p>
<pre><code>window.frames(1).navigate "http://bossman"</code></pre>
<p>
In the above example we're referencing the frame object we want 'by index' which means we're using a number that refers to the frame. We can also access members of the <b><code>frames</code></b> collection (and other collections) 'by name' if we've specified an ID or name attribute when we created the element of the collection. For example, if the frameset with an index of 1 was named <b><code>leftHandFrame</code></b>, we could also access it with this code:</p>
<pre><code>window.frames("leftHandFrame").navigate "http://bossman.com"</code></pre>
<p>
These naming methods work identically – they both return a reference to the same frame.</p>
<p>
As we'll see when we talk about scripting in chapter six, we also have the <b><code>For Each</code></b> construct available to us for use with collections. We use <b><code>For Each</code></b> to iterate through each element in a collection.</p>
<h2>The Frame as a Window Object</h2>
<p>
Now back to that cryptic statement about the top-level window that I made a second ago… The only other confusing aspect about the <b><code>frames</code></b> collection also arises from the fact that each frame is a <b><code>window</code></b> object in its own right. Think about the world from the point of view of the frame in our example indexed with the number 1. It doesn't contain any additional frames (although it could – its page would need to contain a <b><code>&lt;FRAMESET&gt;</code></b> tag with one or more <b><code>&lt;FRAME&gt;</code></b> tags). No contained frames means that the <b><code>frames</code></b> collection of the <b><code>frame(1)</code></b> should be empty, and this is exactly what we see if we query the <b><code>length</code></b> property of the collection in code. Its own <b><code>frames</code></b> collection has zero elements, but the page containing it owns three frames.</p>
<p>
So how do we access another frame from our code in <b><code>frame(1)</code></b>? Remember way back to the <b><code>top</code></b> and <b><code>parent</code></b> properties of the <b><code>window</code></b> object? These properties are the key to working with multiple frames in the browser object model. Before we can reference <b><code>frame(0)</code></b> or <b><code>frame(2)</code></b> from <b><code>frame(1)</code></b> we need to get a reference to the top-level <b><code>window</code></b> object so we can use its <b><code>frames</code></b> collection. This task is just as simple as using the code from <b><code>frame(1)</code></b>:</p>
<pre><code>parent.frames(0).method
parent.frames(2).method</code></pre>
<p>
In this case, since we're only moving up a single level, <b><code>parent</code></b> and <b><code>top</code></b> return a reference to the same <b><code>window</code></b> object.If we were to work with a set of nested frames, we'd see that <b><code>top</code></b> always returns a reference to the top-most <b><code>window</code></b> object, while <b><code>parent</code></b> just returns a reference to the <b><code>window</code></b> object that is immediately above itself.</p>
<p>
Generally we'll stick to using <b><code>parent</code></b> instead of <b><code>top</code></b> to avoid problems when our pages are viewed from another site. If a user browses to our framed pages from another site that uses frames then <b><code>top</code></b> will return a reference to the top-level frame from the first site. In this instance, assuming that that <b><code>top</code></b> and <b><code>parent</code></b> are identical breaks our code.</p>
</BODY>
</HTML>
