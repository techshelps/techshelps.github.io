<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The Script Section of a Scriptlet</title>
<style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000 dir=ltr>
<h1><a name="thescriptsectionofscriptlet"></a>The Script Section of a Scriptlet</h1>
<p>
The script portion of a Scriptlet has a conventional structure. We must expose the public interface of the object, as well as include some internal 'helper' routines. The script procedures we write will provide the Scriptlet behavior, and take care of responding to all the Dynamic HTML events that are supported by the Scriptlet itself. Using special naming conventions, we declare some of these routines as <b>public</b> and allow the container script code to access them. Scripting may use a mix of VBScript, JavaScript, JScript, and any other scripting language supported in the browser.</p>
<h2>Defining the Public Interface</h2>
<p>
At the start of this chapter, we saw one way to define the interface of a Scriptlet – with VBScript and the implicit declarations which use the <b><code>public_</code></b> prefix. JavaScript offers a <b><code>public_description</code></b> object that works as a class definition module. In a certain sense, using this object is similar to writing a header file for a C++ class. We can use it to assign properties and methods to the Scriptlet by name. For each attribute, we specify the name of the 'helper' script routine that implements it. A container's element will refer to that attribute using an external name, which is determined following a special naming convention.</p>
<p>
&nbsp;</p>
<p>
First of all, we have to initialize the <b><code>public_description</code></b> object like this:</p>
<pre><code>&lt;script language="Javascript"&gt;
public_description = new CreateThisScriptlet();
&lt;/script&gt;</code></pre>
<p>
<b><code>CreateThisScriptlet</code></b> is not a system routine, but just the name we give to the actual function we want to use to create the interface. This is a typical body for it:</p>
<pre><code>function CreateThisScriptlet () {
  this.put_color = put_color;
  this.get_color = get_color;
  this.title = window.document.title;
  this.paint = doPaint;
  this.event_onPainting = "";
}</code></pre>
<p>
<b><code>CreateThisScriptlet</code></b> defines properties, methods and events for the new object, assigning them dynamically to the <b><code>this</code></b> pointer. As we saw earlier in the chapter, to fully expose a <b>property</b> called <b><code>color</code></b> we need to write two script procedures called <b><code>get_color</code></b><i> </i>and <b><code>put_color</code></b>. They must be assigned to the corresponding elements in the <b><code>public_description</code></b> object, and take care of reading and writing the property value. In the <b><code>get</code></b> function we usually only need to return the current setting. The <b><code>put</code></b> function, however, saves the new value and often applies the changes to the Scriptlet output. Notice that we must use the <b><code>put</code></b> and <b><code>get</code></b> prefix to qualify it as a read/write property. If we want a read-only or write-only property, we just omit the declaration we don't need.</p>
<h3>Defining Methods and Events in JavaScript</h3>
<p>
<b>Methods</b> don't follow any convention, and the name we assign to the public descriptor is the same one we invoke outside the Scriptlet. In the above sample, the <b><code>doPaint</code></b> procedure will execute after any external caller invokes the <b><code>paint</code></b> method. There is absolutely no need to implement the <b><code>paint</code></b> function with a script procedure called <b><code>doPaint</code></b>—though it is preferable for the sake of clarity. Feel free to give it the same name as your dog if you prefer!</p>
<p>
<b>Events </b>have no actual code implementation. In an ActiveX control, for instance, you need to declare events just to let the development tool build the proper type library, so that the container knows about these events. This is also true for Scriptlets. A component fires events, but the actual code that runs in response is decided and executed in the container page. In other words, the host and object swap their respective roles. When raising an event, any object (Scriptlets, ActiveX controls) ends up invoking a dynamic method on the host, allowing the host to provide the code that is executed in response to the event.</p>
<p>
At first sight, the line</p>
<pre><code>this.event_onPainting = "";</code></pre>
<p>
seems to be necessary to make sure that event is properly notified and received. If you want a Visual Basic 5 ActiveX control to raise a given event, you absolutely need to declare it. This ensures that the container will get a pointer to a connection-point interface that includes an entry-point with the name <b><code>onPainting</code></b>:</p>
<pre><code>Event onPainting(ByVal data As Long)</code></pre>
<p>
This is certainly true for ActiveX controls, but not for Scriptlets. If we want our Scriptlet to raise an event called <b><code>onPainting</code></b>, we don't need to declare it explicitly, because the Scriptlet custom events are all routed through the same entry-point: <b><code>onScriptletEvent</code></b>. More on this later. For now, just keep in mind that we aren't strictly required to declare events, but it is nice if we do so simply for documentation's sake. </p>
<h3>Javascript vs VBScript</h3>
<p>
In the previous section, we discussed how to define the Scriptlet's public interface using JavaScript . As we saw at the beginning of this chapter, this is not the only approach we can take. By using a special naming convention for all the properties and methods you want to expose, you can make them <b><code>public</code></b> by design.</p>
<p>
If you're an expert Windows programmer, this should sound familiar, and remind you of the two options you have for exporting functions from within a DLL. You can list all of them in a <b><code>DEF</code></b> file, or you can make them public using the special keyword <b><code>declspec(dllexport)</code></b> in the prototype. </p>
<p>
Look at how to convert the previous sample using the <b><code>public</code></b> keyword:   </p>
<pre><code>Function public_get_color
Sub public_put_color 
Sub public_paint
' note that there are no declarations for events</code></pre>
<p>
This approach, called <b>default interface description</b>, allows us to use VBScript instead of JavaScript. However, bear in mind that the JavaScript approach creates a single niche in our code where the whole of the object's public interface is described. Furthermore, it allows us to have different public and private names for all the methods and properties. </p>
<p class=indent>
Note that the JavaScript approach always takes priority over the default interface descrition approach if both exist in the same Scriptlet.</p>
<h2>Ambient Properties</h2>
<p>
A Scriptlet runs inside a special container object that offers the following ambient properties. </p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows width=842>
<tr valign=top>
<td class=blue width=20%><b>Property</b></td>
<td class=blue width=11%><b>Type</b></td>
<td class=blue width=69%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=20%><b><code>scrollbar</code></b></td>
<td width=11%><i>Boolean</i></td>
<td width=69%>If <b><code>true</code></b> enables the use of scrollbars. If the Scriptlet content is too large for its actual size, both vertical and horizontal scrollbars will appear automatically. Default is <b><code>false</code></b>.</td>
</tr>
<tr valign=top>
<td width=20%><b><code>selectableContent </code></b></td>
<td width=11%><i>Boolean</i></td>
<td width=69%>If <b><code>true</code></b> allows users to select the Scriptlet's content and drag it or copy it to the clipboard. Otherwise the user can't select anything in the Scriptlet's area. Default is <b><code>false</code></b>.</td>
</tr>
<tr valign=top>
<td width=20%><b><code>version</code></b></td>
<td width=11%><i>String</i></td>
<td width=69%>Identifies the current version of the Scriptlet container object. At present it is <b><code>"4.0 Win32"</code></b>.</td>
</tr>
<tr valign=top>
<td width=20%><b><code>frozen</code></b></td>
<td width=11%><i>Boolean</i></td>
<td width=69%>Read-only property.  If <b><code>false</code></b>, indicates that the page hosting the Scriplet is ready to handle events.</td>
</tr>
</table><br>
<p>
These <b>stock</b> attributes are accessible through an object called <b><code>external</code></b>, which is a new property of the Dynamic HTML <b><code>window</code></b> object. We can use them to control the environment of our Scriptlet to some extent, for example we can enable the use of scrollbars from within a Scriptlet with a line like this:</p>
<pre><code>window.external.scrollbar = true</code></pre>
<h3>Accessing the External Object</h3>
<p>
The <b><code>external</code></b> object is available only when the Scriptlet page is actually viewed as a Scriptlet within another page. If we load and view the Scriptlet as an ordinary HTML page (for example, select it up from the File | Open menu) the <b><code>external</code></b> object doesn't get initialized. Attempting to use it will then result in a runtime error. Curiously, this situation seems to be handled differently by the two scripting engines that come with IE 4. Consider the following HTML code:</p>
<pre><code>&lt;HTML&gt;
&lt;BODY&gt;

&lt;SCRIPT language="Javascript" for="window" event="onload"&gt;
  alert("External.version is: " + window.external.version);
&lt;/SCRIPT&gt;

&lt;SCRIPT language="VBScript" for="window" event="onload"&gt;
  MsgBox "External.version is: " &amp; window.external.version
&lt;/SCRIPT&gt;

&lt;/BODY&gt;
&lt;/HTML&gt;</code></pre>
<p>
Both the scripts catch the <b><code>onLoad</code></b> event of the <b><code>window</code></b> object, and try to display a message box with the current value of the <b><code>window.external.version</code></b> property. The JavaScript procedure traps the exception and returns the string "<b><code>undefined"</code></b>, while the VBScript procedure produces the error like the one shown here:</p>
<p>
<img src="0707_14_25.gif" border=0></p>
<h3>Detecting When a Scriptlet is Running – Our Custom InScriplet Variable</h3>
<p>
A Scriptlet is nothing more than a Web page viewed through a special container. Though it may not always make sense, we might also want it to display properly if viewed directly with a browser, rather then embedded into another page. Unfortunately, this produces a runtime script error if we refer to the <b><code>window.external</code></b> object in our code. It would be nice to be able to detect whether the page is being viewed directly in a browser, or as a Scriptlet. In this way, we could only access the ambient properties when appropriate.</p>
<p>
To do this, we introduce a custom JavaScript variable named <b><code>InScriptlet</code></b> into our Scriptlet code, and set it to <b><code>true</code></b> if we are running the page as a Scriptlet, or <b><code>false</code></b> if not. This is done using the JavaScript <b><code>typeOf</code></b> method, which tells us what kind of value a variable or property is holding: </p>
<pre><code>InScriptlet = (typeOf (window.external.version)=="string");
if( InScriptlet ) {
  window.external.scrollbar = true;
}</code></pre>
<p>
JavaScript will never prompt us with a script error. In the above situation, the <b><code>window.external.version</code></b> property will be of type <b><code>string</code></b> if it actually exists (i.e. we are running a Scriptlet), or <b><code>undefined</code></b> if the <b><code>external</code></b> object doesn't exist because we are running the page directly.</p>
</BODY>
</HTML>
