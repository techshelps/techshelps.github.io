<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The Container Object</title>
<style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000 dir=ltr>
<h1><a name="thecontainerobject"></a>The Container Object </h1>
<p>
All Scriptlets runs in an HTML page by the means of an embedded container. This container recreates for the Scriptlet the same habitat as IE 4, and makes available the <b>ambient</b> properties listed earlier. In addition, it provides the following methods:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=782>
<tr valign=top>
<td class=blue width=19%><b>Method</b></td>
<td class=blue width=81%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=19%><b><code>bubbleEvent</code></b></td>
<td width=81%>Passes the current event down to the host environment, whether an HTML page or a Visual Basic form. </td>
</tr>
<tr valign=top>
<td width=19%><b><code>raiseEvent</code></b></td>
<td width=81%>Fires a custom event for the Scriptlet. Each event is identified by name but routed through the single <b><code>onScriptletEvent</code></b> of the container.</td>
</tr>
<tr valign=top>
<td width=19%><b><code>setContextMenu</code></b></td>
<td width=81%>Allows us to associate a pop-up menu with the Scriptlet. The menu will appear after a right-click on the Scriptlet's area of the page.</td>
</tr>
</table><br>
<p>
A Scriptlet receives notification of all the standard Dynamic HTML events for the <b><code>window</code></b> and <b><code>document</code></b> objects, and any other elements it contains. <b><code>bubbleEvent</code></b> is the method we use to pass (or bubble) any events we trap in the Scriptlet back up to the container. If we don't pass these events explicitly, event bubbling stops at the container and the host HTML page (or VB form., etc.) will never know that an event occurred. </p>
<p>
If we want to handle an <b><code>onclick</code></b> event, for example, then bubble it back up to the container page, we could use the following code within our Scriptlet:</p>
<pre><code>&lt;script language="VBscript" 
  for="document" event="onclick"&gt;
  if (InScriptlet) And Not (window.external.frozen) Then
    window.external.bubbleEvent
  end if 
&lt;/script&gt;</code></pre>
<p>
Aside from just checking to see if the Scriplet page is being run as a Scriptlet (indicated by the <b><code>InScriptlet</code></b> variable) we also have to check to make sure that the hosting container is ready to receive events. This is done by making sure that the <b><code>window.external.frozen</code></b> property is <b><code>false</code></b>.</p>
<p>
Once the event gets back up to the container page, we can handle it there. We do this using the container window's <b><code>event</code></b> object, and examine it to get information about the event. So code to handle a bubbled event might look like this:</p>
<pre><code>&lt;script language="jscript" for="Scriptlet1" event="onclick"&gt;
<b>// inspect event object to see which button was clicked</b>
if (window.event.button = 2) 
  alert ("Right-Button Clicked");
&lt;/script&gt;</code></pre>
<p class=indent>
If the Scriptlet is hosted in a non-Web browser environment, such as a C++, Visual Basic, or Office97 application, we have to use the <b><code>event</code></b> object that hangs of the Scriptlet control, rather than the integral <b><code>window</code></b> object's <b><code>event</code></b> object. We'll look at hosting Scriptlets in these kinds of applications towards the end of this chapter.</p>
<h2>Handling Custom Events</h2>
<p>
The <b><code>raiseEvent</code></b> method fires custom events, such as the <b><code>onPainting</code></b> event we discussed earlier. Its prototype is </p>
<pre><code>RaiseEvent(<i>name</i>, <i>data</i>)</code></pre>
<p>
The following is a typical call to the <b><code>raiseEvent</code></b> method:</p>
<pre><code>window.external.raiseEvent "onPainting", window.document</code></pre>
<p>
The first argument of <b><code>raiseEvent</code></b> is the name of the event we want to raise. The second is the data we want to associate with the event, and notify to the receiver. Whatever name we assign to the event, it will always be detected and handled in the container through the <b><code>onScriptletEvent </code></b>– which is the counterpart of <b><code>raiseEvent</code></b>. Because of this, there is no need to declare our events in a Scriptlet, as they all arrive through the built-in <b><code>onScriptletEvent</code></b> event.</p>
<p>
When the client is notified of a custom event (i.e. one that is not a standard DHTML event), it can distinguish which of the Scriptlet's event this is with multiple <b><code>if..then</code></b> statements, or with a <b><code>select..case</code></b> or <b><code>switch</code></b> statement—based on the <b><code>name</code></b> argument. For example:</p>
<pre><code>&lt;script language="jscript" for="Scriptlet1" event="onscriptletevent(eventname, eventdata)"&gt;
if(eventname == "onPainting") {
    alert("Start painting");
}
else {
  if(eventname == "onEndPainting") {
    alert("End painting");
  }
}
&lt;/script&gt;</code></pre>
<p>
The Scriptlet would raise these events to the container using:</p>
<pre><code>window.external.raiseEvent "onPainting", window.document
window.external.raiseEvent "onEndPainting", window.document</code></pre>
<p>
The <b><code>window.document</code></b> parameter simply represents the data we want to pass to the container's event code. This, of course, will change according to the actual requirements of your code. As previously discussed, the <b><code>window.external.frozen</code></b> property should be checked before firing events.</p>
<p>
All the events a Scriptlet raises are perceived by the container as occurrences of the same event, <b><code>onScriptletEvent</code></b>, with different parameters. This also means that we can define events at any time, and qualify them with a string. </p>
<h2>Adding a Context Menu</h2>
<p>
The Scriptlet container object also allows us to create and assign a pop-up <b>context menu</b> to a Scriptlet. To do this we must use either VBScript or JavaScript, as these are the only script languages guaranteed to create arrays compatible with the expectations of the <b><code>setContextMenu</code></b> method. </p>
<p>
To create a context menu that shows <i>n </i>items, we define an array of <i>2*n</i> elements. For each pair of elements in the array, the first item is the caption that will be shown on the menu, while the second is the name of the function that will executed when the user selects that item on the menu (notice that these procedures cannot take parameters). If we want an item separator, just add a couple of empty items. Finally, we pass the array to the <b><code>setContextMenu</code></b> method of the <b><code>window.external</code></b> object: </p>
<pre><code>&lt;SCRIPT language="VBScript" for="window" event="onload"&gt;
   dim menuItems(6)     
   
   menuItems(0) = "&amp;One"  
   menuItems(1) = "One"

   menuItems(2) = "&amp;Two"   
   menuItems(3) = "Two"

   menuItems(4) = "&amp;Three"   
   menuItems(5) = "Three"

   window.external.setContextMenu(menuItems)
&lt;/SCRIPT&gt;</code></pre>
<p>
Once we have assigned the context menu to the <b><code>external</code></b> object, we're done. We have to do nothing more to set up the menu, and have no need to investigate which button the user presses. The container takes care of handling the right-click event, and running the appropriate code, automatically. Here's the result:</p>
<p>
<img src="0707_14_26.gif" border=0></p>
<h3>Creating Dynamic Context Menus</h3>
<p>
The best place to create the context menu is the <b><code>window</code></b>.<b><code>onLoad</code></b> event, as we did in the previous example. If we use a different event, we have to wait for that event to occur before the context menu is initialized and displayed. The context menu can be changed in code during Scriptlet execution, but all the items displayed at any moment in time must occupy consecutive locations in the menu items array. The following example produces the same menu as in the previous example the first time it is clicked. From the second time onwards, the menu changes to include a separator and a fourth menu item:</p>
<pre><code>&lt;script language="VBscript"&gt;
dim menuItems(10)     
dim bFirstTime

Sub InitMyScriptlet
  if InScriptlet then
    window.external.selectableContent = mSelectable
    menuItems(0) = "&amp;One"  
    menuItems(1) = "One"
    menuItems(2) = "&amp;Two"   
    menuItems(3) = "Two"
    menuItems(4) = "&amp;Three"   
    menuItems(5) = "Three"
    menuItems(6) = "xxx"     ' stub the next items
    menuItems(7) = ""        ' stub the next items
    window.external.setContextMenu(menuItems)
    bFirstTime = 1
  end if
End Sub

Sub document_onmousedown
  if bFirstTime = 0 then
    menuItems(6) = ""  <b>     ' separator</b>
    menuItems(7) = ""       <b>' separator</b>
    menuItems(8) = "&amp;Four"
    menuItems(9) = "Four"
    window.external.setContextMenu(menuItems)
  else
    bFirstTime = 0
  end if    
End Sub

Sub One
  MsgBox "One"
End Sub

Sub Two
  MsgBox "Two"
End Sub

Sub Three
  MsgBox "Three"
End Sub

Sub Four
  MsgBox "Four"
End Sub
&lt;/script&gt;</code></pre>
<p>
The context menu gets initialized first in <b><code>window.onload</code></b> event, then is updated in the <b><code>document_onmousedown</code></b> event. In any case, before the menu is displayed, our Scriptlet will receive an <b><code>onmousedown</code></b> event, so we have the opportunity to initialize it, or make changes to it, there. Here's the result—you can run or download this page, <b><code>MenuDemo.htm</code></b>, from our Web site at <b><code>http://rapid.wrox.co.uk/books/0707</code></b>:</p>
<p>
<img src="0707_14_27.gif" border=0></p>
<p>
If you aren't using different arrays for different menus, you probably declared an oversized array to make room for new items. In this case, we recommend you use:</p>
<pre><code>menuItems(6) = "xxx"   <b>  ' stub the next items</b>
menuItems(7) = ""        ' stub the next items</code></pre>
<p>
to suppress the unnecessary items, by assigning a non-empty caption and an empty or non-existing procedure. Otherwise you risk being flooded with item separators from the multiple empty strings.</p>
</BODY>
</HTML>
