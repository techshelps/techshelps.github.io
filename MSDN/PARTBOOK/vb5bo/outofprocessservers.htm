<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Out-of-Process Servers</title>
<style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000 dir=ltr>
<h1><a name="outofprocessservers"></a>Out-of-Process Servers</h1>
<p>
An out-of-process server is a component that is effectively a separate program containing objects. This type of server will always run in its own process space, and will thus be largely independent from any client programs.</p>
<p>
There are two main options with out-of-process servers. We can create the server so that each object runs in its own process, or we can create the server so that all the objects in the server run within a single process. </p>
<p>
There are cases where our business objects will be running in a number of separate processes. The most notable scenario is where we have a full-blown application that can also be used as a component. We might also create out-of-process servers when we want to start some task and let it run in the background while the user continues to work with our application.</p>
<p>
There is a cost to this approach however. Most applications require many different business objects to be active all at the same time and, if each object runs in its own process, we'll have a lot of processes running concurrently. Having a great many processes active on a workstation can be devastating to performance. </p>
<p>
The Windows operating system does some work every <b>quantum</b> (20 milliseconds or so) to determine which process should get to run next. Even if a process is idle, it is still in the list of processes to check, and so the operating system has to do some extra work to check our idle process. If we have a lot of processes, this can add up and become a problem:</p>
<p>
<img src="image1-10.gif" border=0></p>
<p>
On the other hand, we can create a server where all of our objects exist inside a single process. If we put business objects inside this type of server, all of the objects can work together, sharing resources and memory. Many clients can use the objects in our server, and all the objects from all those clients can easily communicate and work with each other inside the same process.</p>
<p>
<img src="image1-11.gif" border=0></p>
<p>
Either type of out-of-process server suffers from one very significant drawback: performance. </p>
<p>
All Windows components use the Component Object Model (COM) to allow communication with objects in other processes. We'll discuss COM in more detail later in the chapter. For now, all we need to know is that COM handles all communication between objects in different processes.</p>
<p>
Unfortunately, COM imposes a very high overhead on each call from one process to another (cross-process calls). Therefore, on each reference to a property and each call to a method, we take the hit of this overhead - and performance can suffer substantially.</p>
<p>
There are techniques that can be used to help minimize the impact of this overhead, and I'll demonstrate those later in the book.</p>
</BODY>
</HTML>
