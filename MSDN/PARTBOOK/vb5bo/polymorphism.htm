<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Polymorphism</title>
<style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000 dir=ltr>
<h1><a name="polymorphism"></a>Polymorphism</h1>
<p>
Polymorphism is often considered to be directly tied to inheritance (which we'll discuss next). In reality, however, it's independent to a large degree. Polymorphism means that we can have two classes with different implementations or code, but with the same interface. We can then write a program that operates upon that interface and doesn't care about which type of object it operates at runtime.</p>
<h2>Polymorphism through Late Binding</h2>
<p>
For example, if we have a class called <b><code>Square</code></b> and another one called <b><code>Cowboy</code></b><i> </i>then<i> </i>they may both have a method called <b><code>Draw</code></b>. We can write a program that tells an object to draw by calling the <b><code>Draw</code></b> method. This program won't care if it is working with a <b><code>Square</code></b> or a <b><code>Cowboy</code></b> - even though each object must obviously implement the <b><code>Draw</code></b> method differently.</p>
<p>
If the <b><code>Square</code></b> class contains the following code:</p>
<pre><code>Option Explicit

Public Sub Draw(Target As Form)
  Target.Line Step(0, 0)-Step(0, 100)
  Target.Line Step(0, 0)-Step(100, 0)
  Target.Line Step(0, 0)-Step(0, -100)
  Target.Line Step(0, 0)-Step(-100, 0)
End Sub</code></pre>
<p>
And the <b><code>Cowboy</code></b> class contains this code:</p>
<pre><code>Option Explicit

Public Sub Draw(Target As Form)
  Target.Print "Draw from holster"
  Target.Print "Aim"
  Target.Print "Fire"
End Sub</code></pre>
<p>
Then we can put this routine in a form:</p>
<pre><code>Public Sub DoDraw(SomeObject As Object)
  SomeObject.Draw Me
End Sub</code></pre>
<p>
This routine doesn't care if it is passed a <b><code>Square</code></b> or a <b><code>Cowboy</code></b>, even though the two classes are implemented in an entirely different fashion. Notice that the routine accepts a parameter of type <b><code>Object</code></b>. By doing this, we have allowed the routine to accept literally any object we care to send it. This simple example of polymorphism works in Visual Basic 4.0 as well as Visual Basic 5.0.</p>
<p>
Visual Basic 4.0 implements polymorphism in the same manner as Smalltalk, by using something called <b>late binding</b>. We've just seen an example of late binding with the <b><code>Draw</code></b> method of the <b><code>Square</code></b> and <b><code>Cowboy</code></b> objects. </p>
<p>
Late binding means that the Visual Basic compiler makes no effort to determine if calls to our objects are valid. All the checking takes place while the program is running. Each call to an object is checked as it's called, and an error is raised if the call turns out to be invalid.</p>
<h2>Polymorphism with Early Binding</h2>
<p>
Visual Basic 5.0 retains this ability, but also implements a stricter form of polymorphism (similar to that found in C++) through its support of <b>interface inheritance</b> using the <b><code>Implements</code></b> keyword.</p>
<p>
For example, if we create a <b><code>Shape</code></b> class with the following code:</p>
<pre><code>Option Explicit

Public Sub Draw(Target As Form)

End Sub</code></pre>
<p>
Then we can use <b><code>Shape</code></b> as a base to create a <b><code>Square</code></b> class:</p>
<pre><code>Option Explicit

Implements Shape

Public Sub Shape_Draw(Target As Form)
  Target.Line Step(0, 0)-Step(0, 100)
  Target.Line Step(0, 0)-Step(100, 0)
  Target.Line Step(0, 0)-Step(0, -100)
  Target.Line Step(0, 0)-Step(-100, 0)
End Sub</code></pre>
<p>
And we can also create a <b><code>Circle</code></b> class, again using the <b><code>Shape</code></b> class as a base class:</p>
<pre><code>Option Explicit

Implements Shape

Public Sub Shape_Draw(Target As Form)
  Target.Circle Step(0, 0), 200
End Sub</code></pre>
<p>
With these classes defined, we can try them out. The following code accepts a parameter and then calls its <b><code>Draw</code></b> method:</p>
<pre><code>Public Sub DrawShape(objSomeShape As Shape)
  SomeShape.Draw Me
End Sub</code></pre>
<p>
Notice the difference between this example and the previous one with the <b><code>Square</code></b> and <b><code>Cowboy </code></b>classes. Instead of accepting an <b><code>Object</code></b> type as a parameter, we're now able to accept a parameter of type <b><code>Shape</code></b>. We've ensured that the only objects passed to our routine will be shapes. Since we'd probably never use the <b><code>Shape</code></b> class as a base to build a <b><code>Cowboy</code></b> class, we don't have to worry about getting a <b><code>Cowboy</code></b> when we wanted a <b><code>Square</code></b> or <b><code>Circle</code></b>.</p>
<p>
This uses <b>early binding</b>.<b> </b>Early binding occurs as the program is being compiled, which means that the compiler can help us out by doing type checking and by verifying that the properties and methods we call on the object are valid.</p>
</BODY>
</HTML>
