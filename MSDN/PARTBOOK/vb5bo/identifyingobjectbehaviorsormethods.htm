<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Identifying Object Behaviors (or Methods)</title>
<style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000 dir=ltr>
<h1><a name="identifyingobjectbehaviorsormethods"></a>Identifying Object Behaviors (or Methods)</h1>
<p>
Objects do not only have attributes; they also have behaviors. Our programs ask an object to act out its behaviors by using <b>methods</b>. A method is very much like a subprogram, or function, that our program can call; but whereas a subprogram is simply a routine in our program, a method is a routine defined for our object.</p>
<p>
Objects have behaviors that help model their role in business process. Very often, they also have behaviors, or methods, that let them interact with the other objects in the model - in ways that aren't necessarily obvious from the use cases. </p>
<p class=indent>
We're going to discuss business process behaviors in this section. We'll cover object relationship behaviors in the next section.</p>
<p>
The technique we need to follow to determine an object's behavior is very similar to that which we've just seen for an object's properties. First, we need to go through the functional use case to find any methods that are required. Then, we need to look at our object model and add any methods that are required for objects to interact with each other.</p>
<h3>Identifying Behaviors - Looking through the Use Case</h3>
<p>
Let's look through each object in our object model and read through the use case to decide what behaviors or actions each object might be able to take. Many business objects primarily provide data, so don't be surprised if many of our objects don't have methods.</p>
<p>
Looking at the <i>customer </i>object, we can see that the actual person does a lot of things, like putting the videos on the counter, and providing an ID card. However, our software doesn't need to be aware of these actions - so we don't need to provide methods for them. But our software does need to retrieve and display the customer's name and address once the ID number is entered. Now, since these are attributes of the customer object, it's a good bet that our <i>customer </i>object will have some behavior to load this information.</p>
<p>
Next, let's look at the <i>video </i>object. Again, the <i>video</i> object doesn't play an active part in the use case as far as our application is concerned - other than that it needs to load the description and rental price once its ID number is entered.</p>
<p>
Our last object is the <i>invoice </i>object. This object isn't directly in the use case at all, but it does have the subtotal, tax and total values as attributes. The use case indicates that these values are calculated, so the <i>invoice</i> object will probably need a method to support this behavior.</p>
<p>
At this point, our objects have the following behaviors:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=342>
<tr valign=top>
<td class=blue width=31%><b>Object</b></td>
<td class=blue width=69%><b>Behavior</b></td>
</tr>
<tr valign=top>
<td width=31%>Customer</td>
<td width=69%>Load customer data</td>
</tr>
<tr valign=top>
<td width=31%>Video</td>
<td width=69%>Load video data</td>
</tr>
<tr valign=top>
<td width=31%>Invoice</td>
<td width=69%>Calculate subtotal<p>
Calculate tax</p>
<p>
Calculate total</p>
</td>
</tr>
</table><br>
<p class=indent>
If we look back at the requirements use case, we can see that there are other behaviors that we are not taking into account. For instance, the invoice needs to be printed, and it is implied that the rented videos will be recorded in the inventory system. We don't need to worry about these issues at this point, since they would normally be covered by other functional use cases. This illustrates how closely all the different use cases are related to each other, and how they are all used together to come up with a comprehensive object model.</p>
<h3>Identifying Behaviors - Looking through the Object Model</h3>
<p>
The <i>customer</i> and <i>video</i> objects both have behaviors that comprise loading data from a database. This type of behavior is integral in making objects persistent, as we discussed in Chapter 2. In Chapter 4, we'll get into the code for implementing this behavior. For now, however, we're just interested in defining our objects' interfaces, so we'll add a <b><code>Load</code></b> method to support this behavior, and worry about the details later.</p>
<p>
We've listed three different calculation behaviors for the <i>invoice</i> object, all of which are closely related. This is an interesting situation that requires some thought. There are three ways to approach these behaviors:</p>
<ul type=disc>
<li>
Implement three calculation methods<br><br></li>
<li>
Implement a single calculation method<br><br></li>
<li>
Automatically recalculate when properties are changed</li>
</ul>
<p>
When we're making decisions about our objects' interfaces, we need to keep our customer in mind. We have two main design issues: modeling the business entities, and making our objects easy to use at the presentation layer. Here, our customer is the programmer who is writing the user interface.</p>
<p>
Implementing three different calculation methods means that the UI programmer needs to understand and call all three methods where appropriate. Since all the calculations are directly tied to each other, it would surely be much better to combine them into a single method for the programmer to call.</p>
<p>
Better still, suppose the programmer didn't need to call <i>any</i> method to do the calculation. The calculation would only need to happen when a video was added or removed from the list of rentals. The invoice object owns the list of videos, so it should be able to detect when a video is added or removed - and automatically recalculate the values.</p>
<p>
All three solutions are valid, and we could choose any of them and have a working program. We should always strive to provide the simplest object interface for the UI programmer, since it helps them to be more productive and it makes the code less prone to bugs. In this case, the upshot is that we'll opt to automatically recalculate the subtotal, tax and total, so that those values are always correct. This means we don't need any calculation methods on our <i>invoice</i> object.</p>
<p>
Ideally, we'd be able to notify the UI when the values have been recalculated, thus making it easy for the programmer to update the display. Fortunately, Visual Basic 5.0 provides the <b><code>RaiseEvent</code></b> command to let us do just that.</p>
</BODY>
</HTML>
