<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The Aggregate Relationship - Combining Objects</title>
<style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000 dir=ltr>
<h1><a name="theaggregaterelationshipcombiningobjects"></a>The Aggregate Relationship - Combining Objects</h1>
<p>
There are many times when an object is composed of other objects, in whole or in part. For instance, our <b><code>Invoice</code></b> object is partially composed of the <b><code>Customer</code></b> object. Without the <b><code>Customer</code></b> object, our <b><code>Invoice</code></b> doesn't have enough information to be useful. The <b><code>Customer</code></b> is subordinate to the <b><code>Invoice</code></b>, but the <b><code>Invoice</code></b> can't exist without the <b><code>Customer</code></b>.</p>
<p>
There are two different approaches that we can use to handle this situation. The first of these is simple aggregation; the second involves combining interfaces.</p>
<p>
Our discussion will therefore run as follows: </p>
<ul type=disc>
<li>
We'll look at a simple aggregation example<br><br></li>
<li>
We'll alter that example to use a combined interface technique<br><br></li>
<li>
We'll investigate how one object might expose another object's data <br>
 as a read-only property</li>
</ul>
<h2>Technique 1 - Simple Aggregation</h2>
<p>
The first approach we'll look at is simple aggregation. With this approach, we can simply expose the subordinate objects as properties of the top-level object. For instance, look at the following code:</p>
<pre><code>Option Explicit

Private objCustomer As Customer

Private Sub Class_Initialize()
  Set objCustomer = New Customer
End Sub

Public Function Customer() As Customer
  Set Customer = objCustomer
End Function</code></pre>
<p>
All we've done, here, is create a private <b><code>Customer</code></b> object, and allowed the calling program to gain access to it through our <b><code>Customer</code></b> method. This is very simple to implement, and it gives the calling program full access to any of the objects we've aggregated into our top-level object.</p>
<p>
There are, however, a couple of drawbacks to simple aggregation. The most obvious problem is that the calling program can do virtually anything to the aggregated object. In the example above, the calling program has full access to the <b><code>Customer</code></b> object, so it can change any properties or call any methods. In some cases, this might be fine, but we may want greater control over what the calling program can do, such as validation and error handling.</p>
<p class=indent>
When we're designing an object model, it's important to assume that everything will get misused or called incorrectly. Objects need to protect themselves, and if an object is composed of other objects then it needs to protect the subordinate objects as well.</p>
<h2>Technique 2 - Combining Object Interfaces</h2>
<p>
Now that we've seen how easy it is to implement simple aggregation, let's look at an approach that gives us more control over how the client code can use the aggregated object.</p>
<p>
Although this doesn't follow true object-oriented design, it's often a better idea to simply merge the properties and methods of all the objects into a single object interface. With this approach, we can still have the aggregated objects instantiated inside our top-level object, but we don't make them directly available to the calling program.</p>
<p>
Consider the following code from the <b><code>Invoice</code></b> class:</p>
<pre><code>Option Explicit

Private objCustomer As Customer
Private curTax As Currency

Private Sub Class_Initialize()
  Set objCustomer = New Customer
End Sub

Public Property Let Name(strValue As String)
  objCustomer.Name = strValue
End Property

Public Property Get Name() As String
  Name = objCustomer.Name
End Property

Public Property Get Tax() As Currency
  Tax = curTax
End Property</code></pre>
<p>
Note that this class is made up of both its own data and the <b><code>Customer</code></b> object; but rather than exposing the <b><code>Customer</code></b> object itself, this implementation has its own <b><code>Name</code></b> property that just calls the <b><code>Customer</code></b> object's <b><code>Name</code></b> property. This technique passes a lot of control to the <b><code>Invoice</code></b> object - at the expense of object-oriented philosophy.</p>
<p>
Of course, this approach also has some drawbacks. If an aggregated object's interface changes, perhaps by adding a new property, then the new interface elements aren't immediately available to client programs. In that situation, we would need to add the new elements to the top-level object's interface first. With simple aggregation, on the other hand, where we would expose the aggregated object as a property, this problem would never arise.</p>
<h2>Technique 3 - Combining Data</h2>
<p>
As we've seen, simple aggregation and aggregation through combined interfaces are very good ways to solve the problem where one object relies on another for data or functionality. Unfortunately, neither solution is truly ideal in a client/server setting.</p>
<p>
Let's diverge a bit from object theory, and look at a common scenario in business programming. Most of us work with data that is stored in relational tables. Even if we choose to represent that data as objects, such as <b><code>Customer</code></b> or <b><code>Invoice</code></b>, we'll often run into cases where the data needs to be consolidated (or aggregated) together across object boundaries. </p>
<p>
With our current example, the <b><code>Invoice</code></b> object needs data from the <b><code>Customer</code></b> object to function - in our case, the <b><code>Customer</code></b> object's <b><code>Name</code></b> property. Essentially, we're trying to consolidate some of the <b><code>Customer</code></b> object's data into the <b><code>Invoice</code></b>. So far, we've done that using a couple different techniques to implement aggregation.</p>
<p>
Unfortunately, this can be very inefficient. In order to get the <b><code>Name</code></b> property from the <b><code>Customer</code></b> object, our <b><code>Invoice</code></b> object has to load the <i>entire</i> <b><code>Customer</code></b> object from the database. This means that we're loading two whole objects - one of them just to get a single property value. Most relational database engines can pull information together much faster than we can when we load individual objects and put them together ourselves.</p>
<p>
Let's take an example. Here's a functional use case from the <i>Rental Analysis</i> requirements:</p>
<p class=indent>
Consolidated Reporting</p>
<p class=indent>
</p>
<p class=indent>
This use case covers the specific steps used to consolidate the rental counts and prices for each video.</p>
<p class=indent>
&nbsp;</p>
<p class=indent>
The system must scan all invoice detail lines for each video. Each invoice for a video will count as a single rental, and so the system must count the invoices. For this analysis, the system must also calculate an average rental price, based on each invoice for the video. Prices may change over the life of the video, and so the analysis needs to use the average price.</p>
<p class=indent>
</p>
<p class=indent>
Once the system has calculated a video's rental count and average price, it needs to provide these numbers - along with the name of the producing studio and the video's category for analysis. The studio and category are stored with the other video information.</p>
<p>
We'll discuss two different ways of solving this business situation. First, let's look at how we might solve it using pure aggregation of objects; then, we'll look at an alternative solution that provides much better performance.</p>
<h3>Object Method</h3>
<p>
Looking at this problem with a pure object focus, we can quickly pick out the <b><code>LineItem</code></b><i> </i>and <b><code>Video</code></b> objects as containing the data we need. We'll add in a <b><code>VideoData </code></b>object, which will contain the business logic to accumulate all the data together. So far, we have the objects and properties as shown in the table on the following page.</p>
<p>
Using objects, our <b><code>VideoData</code></b> object would contain the logic to load all the <b><code>LineItem</code></b> objects for each invoice, and accumulate a rental count and average price for each <b><code>Video</code></b>. It would also aggregate the <b><code>Video</code></b> object to get the <b><code>Studio</code></b> and <b><code>Category</code></b> data.</p>
<p class=indent>
In Chapter 4, we'll discuss a couple of efficient techniques for loading and saving object data in a database. As good as these are, they don't compare to the performance we can get by processing a lot of data in the data tier.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=336>
<tr valign=top>
<td class=blue width=48%><b>Object</b></td>
<td class=blue width=52%><b>Properties</b></td>
</tr>
<tr valign=top>
<td width=48%><b><code>LineItem</code></b></td>
<td width=52%><b><code>VideoID</code></b><p>
<b><code>Price</code></b></p>
</td>
</tr>
<tr valign=top>
<td width=48%><b><code>Video</code></b></td>
<td width=52%><b><code>VideoID</code></b><p>
<b><code>Studio</code></b></p>
<p>
<b><code>Category</code></b></p>
</td>
</tr>
<tr valign=top>
<td width=48%><b><code>VideoData</code></b></td>
<td width=52%><b><code>VideoID</code></b><p>
<b><code>RentalCount</code></b></p>
<p>
<b><code>AveragePrice</code></b></p>
<p>
<b><code>Studio</code></b></p>
<p>
<b><code>Category</code></b></p>
</td>
</tr>
</table><br>
<p>
It's relatively inefficient for the <b><code>VideoData</code></b> object to load all the <b><code>LineItem</code></b> objects from the database. The rental count and average price can be calculated with a simple SQL statement in the database itself, and this would be much faster. With an extra <b><code>JOIN</code></b>, the SQL statement can pull in the <b><code>Studio</code></b> and <b><code>Category</code></b> data without even having to load a separate <b><code>Video</code></b> object.</p>
<h3>Database Method</h3>
<p>
Following a database train of thought, we would have one type of object: <b><code>VideoData</code></b>. This object would be loaded directly from the database using a SQL statement to pull together all the data at once, very efficiently. The following is an example SQL statement that we could use in Microsoft Access to achieve this:</p>
<pre><code>SELECT InvoiceDetail.VideoID, Count(InvoiceDetail.VideoID) AS CountOfVideoID, Avg(InvoiceDetail.Price) AS AvgOfPrice, Videos.Studio, Videos.Category
FROM InvoiceDetail INNER JOIN Videos ON InvoiceDetail.VideoID = Videos.VideoID
GROUP BY InvoiceDetail.VideoID, Videos.Studio, Videos.Category;</code></pre>
<p>
The following figure (overleaf) shows this query in Access.</p>
<p>
Of course, there are some drawbacks to building objects this way rather than through regular aggregation. Suppose the <b><code>LineItem</code></b> object had business logic behind the <b><code>Price</code></b> property. By pulling the price directly from the database, we will have bypassed that logic. This might force us to replicate the code inside the <b><code>VideoData</code></b> object. In that case, we'd want to think hard about which solution is the most appropriate.</p>
<p>
<img src="image3-9.gif" border=0></p>
</BODY>
</HTML>
