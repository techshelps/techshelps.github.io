<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The Ownership Relationship - Implementing Collections</title>
<style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000 dir=ltr>
<h1><a name="theownershiprelationshipimplementingcollections"></a>The Ownership Relationship - Implementing Collections</h1>
<p>
Ownership really defines a parent-child type relationship between objects. There may be one child, or this may be a one-to-many relationship. In this section, we're going to focus on the situation where one parent has many children.</p>
<p class=indent>
If there can only be one child, it's often more appropriate to view the relationship as a form of aggregation, which we'll talk about later in this chapter.</p>
<p>
This ownership relationship is the basis for most object hierarchies we'll find in Windows applications. It is usually viewed as a <b>collection</b> of child objects that are owned or controlled in some way by the parent. The best way to manage this type of relationship is to build a collection class to contain the child objects, and then implement a read-only property on the parent object to provide access to the collection object.</p>
<h2>The Invoice Object</h2>
<p>
If we consider our video store example, our <b><code>Invoice</code></b> object is likely to have a list of line items: one line item for each video that the customer rents. This is a parent-child type relationship, where it would be good to have a collection of <b><code>LineItem</code></b> objects available through the <b><code>Invoice</code></b> object.</p>
<p>
In our <b><code>Invoice</code></b> object, we'll add a property so that the calling program can access the collection of videos. We'll call the new property <b><code>LineItems</code></b>, since it will be a list of <b><code>LineItem</code></b> objects. The code to handle this in the <b><code>Invoice</code></b> class would look something like this:</p>
<pre><code>Option Explicit

Private WithEvents objLineItems As InvoiceItems

Private Sub Class_Initialize()
  Set objLineItems = New InvoiceItems
End Sub

Public Property Get LineItems() As InvoiceItems
  Set LineItems = objLineItems
End Property

Private Sub objLineItems_AddItem(strID As String)
  CalculateAmounts
End Sub

Private Sub objLineItems_RemoveItem(strID As String)
  CalculateAmounts
End Sub

Private Sub CalculateAmounts()
  ' here we'd recalculate the subtotal, tax
  ' and total amounts for the invoice
End Sub</code></pre>
<p>
The <b><code>LineItems</code></b> property is the key, since it allows the calling program to get at the <b><code>InvoiceItems</code></b> collection. We've also included events so that the <b><code>Invoice</code></b> object will be notified when a <b><code>LineItem</code></b> object is added or removed from the collection. This ties in with our earlier discussion about raising events to recalculate the subtotal, tax and total amounts on the invoice.</p>
<h2>The InvoiceItems Collection Object</h2>
<p>
The <b><code>InvoiceItems</code></b> collection class is based on Visual Basic's native <b><code>Collection</code></b> class. Our collection uses a Visual Basic <b><code>Collection</code></b> object, internally, to store all the <b><code>LineItem</code></b> objects - but we've enhanced the <b><code>Add</code></b> method so that it only supports <b><code>LineItem</code></b> objects. </p>
<p class=indent>
The normal Visual Basic <b><code>Collection</code></b> will accept just about anything to store, which doesn't bode well if we only want to get <b><code>LineItem</code></b> objects.</p>
<p>
Here's what the code to support our <b><code>InvoiceItems</code></b> collection object might look like:</p>
<pre><code>Option Explicit

Event AddItem(strID As String)
Event RemoveItem(strID As String)

Private colItems As Collection

Private Sub Class_Initialize()
  Set colItems = New Collection
End Sub

Public Function Add(strID As String) As LineItem
  Dim objItem As LineItem
  
  Set objItem = New LineItem
  objItem.Load strID
  colItems.Add objItem, strID
  Set Add = objItem
  RaiseEvent AddItem(strID)
End Function

Public Sub Remove(ByVal varIndex As Variant)
  Dim strID As String
  
  strID = colItems.Item(varIndex).ID
  colItems.Remove varIndex
  RaiseEvent RemoveItem(strID)
End Sub

Public Function Count() As Long
  Count = colItems.Count
End Function

Public Function Item(ByVal varIndex As Variant) As LineItem
  Set Item = colItems.Item(varIndex)
End Function

Public Function NewEnum() As IUnknown
  Set NewEnum = colItems.[_NewEnum]
End Function</code></pre>
<p>
In this code, we've simply encapsulated a <b><code>Collection</code></b> object, <b><code>colItems</code></b>, by creating a <b><code>Private</code></b> variable and exposing our own <b><code>Add</code></b>, <b><code>Remove</code></b>, <b><code>Item</code></b>, and <b><code>Count</code></b> elements. </p>
<p>
The key here is that the new <b><code>Add</code></b> method only supports <b><code>LineItem</code></b> objects, so that no unexpected object types can get into our collection. The <b><code>Add</code></b> method is also responsible for creating the <b><code>LineItem</code></b> object, and arranges to load any data based on the ID value supplied - by calling the <b><code>Load</code></b> method.</p>
<p>
<code>&nbsp;&nbsp;Set objItem = New LineItem</code></p>
<p>
<code>&nbsp;&nbsp;objItem.Load strID</code></p>
<p>
Although we can't see it in the code, the <b><code>Item</code></b> method has been made the default by using a new capability of Visual Basic 5.0. This means that where we'd previously have written code like this:</p>
<p>
<code>&nbsp;&nbsp;Set objLineItem = objItems.Item(1)</code></p>
<p>
We can now write the same line like this:</p>
<p>
<code>&nbsp;&nbsp;Set objLineItem = objItems(1)</code></p>
<p>
To set a method as the default, </p>
<p>
choose the Tools-Procedure Attributes menu, and click on the Advanced button when the dialog comes up: </p>
<p>
In the Name field, choose the method name to be changed. Then, in the Procedure ID field, choose the (Default) setting and click OK.</p>
<p>
<img src="image3-7.gif" border=0></p>
<p>
Our new class also contains a <b><code>NewEnum</code></b> method. This is a special method that allows the calling code to use the <b><code>For Each...Next</code></b> style of accessing the contents of our collection. This means that we can write client code like this:</p>
<p>
<code>&nbsp;&nbsp;For Each objLineItem In objItems</code></p>
<p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;Debug.Print objLineItem.Price</code></p>
<p>
<code>&nbsp;&nbsp;Next</code></p>
<p>
<img src="image3-8.gif" border=0></p>
<p>
Until Visual Basic 5.0, the <b><code>For Each</code></b> structure was only available for native Visual Basic <b><code>Collection</code></b> objects. Now, by implementing the <b><code>NewEnum</code></b> method, we can make our user-defined <b><code>Collection</code></b> objects support the <b><code>For...Each</code></b> structure as well.</p>
<p>
Our <b><code>NewEnum</code></b> method simply returns a hidden object within the native Visual Basic <b><code>Collection</code></b> class, called <b><code>_NewEnum</code></b>. Like the <b><code>Item</code></b> method, we need to use the Tools-Procedure Attributes menu option to set some special values for the <b><code>NewEnum</code></b> method. The following diagram shows the settings that are required:</p>
<p>
The Procedure ID field is set to –4, which is the value required to work with <b><code>For...Each</code></b> structures. Also, the Hide this member box is checked, to make our method hidden in the COM type library.</p>
<p>
Notice that the <b><code>InvoiceItems</code></b> class declares and raises two events: <b><code>AddItem </code></b>and <b><code>RemoveItem</code></b>. These events allow the <b><code>Invoice</code></b> object to know when the calling program has added or removed a video from the collection, so that the invoice amounts can be recalculated.</p>
<h2>The LineItem Object</h2>
<p>
We'll keep the <b><code>LineItem</code></b> object simple. We'll just give it an <b><code>ID</code></b> and a <b><code>Price</code></b> property, along with the <b><code>Load</code></b> method. Here's the code:</p>
<pre><code>Option Explicit

Private strID As String
Private dblPrice As Double

Public Sub Load(ID As String)
  strID = ID
  ' eventually there will be code here to go
  ' load the video information from the
  ' database, but for now we'll just make up
  ' a price
  dblPrice = 1.99
End Sub

Public Property Let ID(strValue As String)
  strID = strValue
End Property

Public Property Get ID() As String
  ID = strID
End Property

Public Property Let Price(dblValue As Double)
  dblPrice = dblValue
End Property

Public Property Get Price() As Double
  Price = dblPrice
End Property</code></pre>
<p>
The <b><code>LineItem</code></b> object has no extra code to support collections or any other relationships. The object is entirely designed around modeling the real-world video entity.</p>
<h2>The Calling Program</h2>
<p>
In order to bring this whole thing together, let's look at some code that will add some line items to the invoice and then interrogate the price of the first item:</p>
<p>
<code>&nbsp;&nbsp;Dim objInvoice As Invoice</code></p>
<p>
<code>&nbsp;&nbsp;Dim strPrice as String</code></p>
<p>
<code>&nbsp;&nbsp;</code></p>
<p>
<code>&nbsp;&nbsp;Set objInvoice = New Invoice</code></p>
<p>
<code>&nbsp;&nbsp;objInvoice.LineItems.Add "1"</code></p>
<p>
<code>&nbsp;&nbsp;objInvoice.LineItems.Add "2"</code></p>
<p>
<code>&nbsp;&nbsp;strPrice= objInvoice.LineItems(1).Price</code></p>
<p>
Notice how we've just used the <b><code>InvoiceItems</code></b> method as though it were a collection, calling its <b><code>Add</code></b> method for each video. </p>
<p>
This approach to implementing parent-child relationships is very powerful, and yet it provides a very easy interface for the end programmer who'll be using our objects to develop the application.</p>
</BODY>
</HTML>
