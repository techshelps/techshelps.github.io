<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The Generalization Relationship - Containing Objects</title>
<style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000 dir=ltr>
<h1><a name="thegeneralizationrelationshipcontainingobjects"></a>The Generalization Relationship - Containing Objects</h1>
<p>
<b>Generalization</b> is an analysis technique used to find common ground between a number of objects. Once we've established that a group of objects have a set of common behaviors and properties, we can create a more generalized class to represent all those common elements. We can then use that generalized class as a base from which we can create all the other, more specialized, classes.</p>
<p>
We can view this new, general class as a sort of <i>parent</i> to all the more specialized classes. The process of creating the specialized classes from the general class is called <b>inheritance</b> - something we discussed in a different context in Chapter 1. When we view our generalized class as a parent of the specialized classes, we're creating what's called a <b>class hierarchy</b>.</p>
<p>
A class hierarchy is like a family tree for our objects. As we trace back from one object to the next, we become more and more general. Let's look at a quick example to see what this means:</p>
<p>
<img src="image3-10.gif" border=0></p>
<p>
This diagram demonstrates how a class hierarchy might appear for various types of <i>Person</i>. If we look at an <i>Hourly</i> employee, we can see that they're a specialized type of <i>Employee</i>. In other words, the <i>Employee</i> class is a parent to <i>Hourly</i> and <i>Salaried</i>. We can follow the flow all the way back to the most general class, <i>Person</i>. All of these classes are derived from the <i>Person</i> class.</p>
<p>
Generalization is a very powerful analysis technique. By identifying the commonalities between various objects, we provide ourselves with an opportunity to achieve a high level of reuse. Since we can implement all the common functionality in one class, we can then use that functionality in all the more specialized classes. The more specialized classes <i>inherit</i> the functionality from the generalized class.</p>
<p>
Inheritance is the technique used to implement objects that are identified using the generalization technique. Visual Basic 5.0 doesn't provide a direct mechanism to support inheritance, but it's such an important concept that we need to provide it. As we discussed in Chapter 1, we can use containment and delegation together to simulate inheritance in Visual Basic.</p>
<p>
To see how we can implement inheritance, let's use an example from our video rental store. Suppose the store decides to not only rent videos, but also to sell popcorn, candy bars and other snacks.</p>
<h2>Looking for Common Ground</h2>
<p>
We've already considered that our <i>Invoice </i>object has <i>LineItem</i> objects to reflect the videos that are rented. Now we're saying that we've got two different types of line item - a video rental line item and a line item for snacks the customer wants to purchase.</p>
<p>
Let's look at the possible properties and methods for the video rental line item, which we'll call <b><code>RentalItem</code></b>:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=263>
<tr valign=top>
<td class=blue width=49%><b>Properties</b></td>
<td class=blue width=51%><b>Methods</b></td>
</tr>
<tr valign=top>
<td width=49%>Title</td>
<td width=51%>CheckOut</td>
</tr>
<tr valign=top>
<td width=49%>Price</td>
<td width=51%>MarkAsPaid</td>
</tr>
</table><br>
<p>
Now let's look at the possible properties and methods we might find in the line item to purchase a snack (<b><code>PurchaseItem</code></b>):</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=263>
<tr valign=top>
<td class=blue width=49%><b>Properties</b></td>
<td class=blue width=51%><b>Methods</b></td>
</tr>
<tr valign=top>
<td width=49%>Price</td>
<td width=51%>ReduceInventory</td>
</tr>
<tr valign=top>
<td width=49%>TaxableFlag</td>
<td width=51%>MarkAsPaid</td>
</tr>
</table><br>
<p>
We have a couple of indications that we may be able to come up with a more general class from these two. First off, we know they are both used in a similar way - they're both line items of an <b><code>Invoice</code></b> object. Secondly, in looking at their respective properties and methods, we can see that they share some interface elements.</p>
<p>
Taking the common properties and methods from each, we derive the following list:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=263>
<tr valign=top>
<td class=blue width=49%><b>Properties</b></td>
<td class=blue width=51%><b>Methods</b></td>
</tr>
<tr valign=top>
<td width=49%>Price</td>
<td width=51%>MarkAsPaid</td>
</tr>
</table><br>
<p>
We can look at this as being a new, more general line item object, called <b><code>LineItem</code></b>. If we then use <b><code>LineItem</code></b> as a base from which to implement both the <b><code>RentalItem</code></b> and <b><code>PurchaseItem</code></b> objects, </p>
<p>
we'll have a class hierarchy.</p>
<p>
<img src="image3-11.gif" border=0></p>
<p>
This diagram illustrates how each of our specialized line item classes, <b><code>RentalItem</code></b> and <b><code>PurchaseItem</code></b>, will inherit behaviors from the more general <b><code>LineItem</code></b> class.</p>
<p>
Now let's implement this relationship using Visual Basic. To start with, we'll create our general class, <b><code>LineItem</code></b>. Once that's done, we'll use it as a base class to implement the <b><code>RentalItem</code></b> class. Once we've seen how to implement <b><code>RentalItem</code></b>, the implementation of the <b><code>PurchaseItem</code></b> class would be trivial, so we won't rehash the same material again.</p>
<h2>LineItem Class</h2>
<p>
Our general <b><code>LineItem</code></b> class will implement the properties and methods that are common to all line items. In this case, we're talking about a <b><code>Price</code></b> property and a <b><code>MarkAsPaid</code></b> method. Let's take a look at the code for the <b><code>LineItem</code></b> class:</p>
<pre><code>Option Explicit

Private dblPrice As Double
Private flgPaid As Boolean

Public Property Get Price() As Double
  Price = dblPrice
End Property

Public Property Let Price(dblValue As Double)
  dblPrice = dblValue
End Property

Public Sub MarkAsPaid()
  flgPaid = True
End Sub

Private Sub Class_Initialize()
  flgPaid = False
End Sub</code></pre>
<p>
This code is very straightforward. Our <b><code>Price</code></b> property merely stores and retrieves its value from the <b><code>dblPrice</code></b> variable, while the <b><code>MarkAsPaid</code></b> method simply sets the <b><code>flgPaid</code></b> variable to <b><code>True</code></b>. Obviously, any real business object would be more complex, but this should be enough code to demonstrate how inheritance works.</p>
<h2>RentalItem Class</h2>
<p>
Now we're getting into the interesting part. Since Visual Basic doesn't directly support inheritance, we'll use a combination of containment and delegation to simulate it. We covered this briefly in Chapter 1, but we'll get a good taste for the process as we implement the <b><code>RentalItem</code></b> class. </p>
<h3>Setting up the RentalItem Class</h3>
<p>
Before we inherit the behaviors of the <b><code>LineItem</code></b> class, let's set up the basics of our <b><code>RentalItem</code></b> class. We don't need to worry about the <b><code>Price</code></b> property or the <b><code>MarkAsPaid</code></b> method, since we'll inherit them from the <b><code>LineItem</code></b> class. We do need to implement the <b><code>Title</code></b> property and <b><code>CheckOut</code></b> method however:</p>
<pre><code>Option Explicit

Private strTitle As String
Private flgCheckedOut As Boolean

Public Property Get Title() As String
  Title = strTitle
End Property

Public Property Let Title(strValue As String)
  strTitle = strValue
End Property

Public Sub CheckOut()
  flgCheckedOut = True
End Sub

Private Sub Class_Initialize()
  flgCheckedOut = False
End Sub</code></pre>
<p>
We've kept this code very simple as well. The <b><code>Title</code></b> property just stores and retrieves its value from the <b><code>strTitle</code></b> variable, with the <b><code>CheckOut</code></b> method setting the <b><code>flgCheckedOut</code></b> variable to <b><code>True</code></b>.</p>
<h3>Containing a LineItem Object</h3>
<p>
With the basics of the class down, we can move on to inherit the <b><code>LineItem</code></b> class's functionality. The first thing we need to do is use the technique of containment to make our <b><code>RentalItem</code></b> object <i>contain</i> a <b><code>LineItem</code></b> object. This means declaring a <b><code>Private</code></b> variable to hold the reference to our <b><code>LineItem</code></b> object. Add the following line to the <b><code>RentalItem</code></b> class:</p>
<p>
<code>Option Explicit</code></p>
<p>
<code>Private strTitle As String</code></p>
<p>
<code>Private flgCheckedOut As Boolean</code></p>
<pre><code>Private objLineItem As LineItem</code></pre>
<p>
We also need to create an instance of the <b><code>LineItem</code></b> class. The best place to do this is in the <b><code>Class_Initialize</code></b> routine, so the object is created right up front and is available any time we need it. Add this line to the <b><code>RentalItem</code></b> class:</p>
<p>
<code>Private Sub Class_Initialize()</code></p>
<p>
<code>&nbsp;&nbsp;flgCheckedOut = False</code></p>
<pre><code>&nbsp;&nbsp;Set objLineItem = New LineItem</code></pre>
<p>
<code>End Sub</code></p>
<h3>Inheriting Behavior Using Delegation</h3>
<p>
Our <b><code>RentalItem</code></b> object now has access to its own private <b><code>LineItem</code></b> object. Rather than implementing its own <b><code>Price</code></b> property, it can rely on its <b><code>LineItem</code></b> object's <b><code>Price</code></b> property to do the work. The same goes for the <b><code>MarkAsPaid</code></b> method, where the <b><code>RentalItem</code></b> object can <i>delegate</i> the work to its private <b><code>LineItem</code></b> object.</p>
<p>
Of course, the <b><code>LineItem</code></b> object is <b><code>Private</code></b>, so any client code working with our <b><code>RentalItem</code></b> object won't be able to get at it. In order to make a <b><code>Price</code></b> property and <b><code>MarkAsPaid</code></b> method available to the client code, our <b><code>RentalItem</code></b> object will need to implement them. The implementation is simple however, since we'll just delegate the work down to our private <b><code>LineItem</code></b> object. </p>
<p>
Add this code to the <b><code>RentalItem</code></b> class:</p>
<pre><code>Public Property Get Price() As Double
  Price = objLineItem.Price
End Property

Public Property Let Price(dblValue As Double)
  objLineItem.Price = dblValue
End Property

Public Sub MarkAsPaid()
  objLineItem.MarkAsPaid
End Sub</code></pre>
<p>
When the client code calls the <b><code>MarkAsPaid</code></b> method, for instance, our <b><code>RentalItem</code></b> code merely echoes the call to the <b><code>LineItem</code></b> object's <b><code>MarkAsPaid</code></b> method, rather than trying to do any work itself.</p>
<h3>Trying It Out</h3>
<p>
Let's take a quick look at some client code that we might use to work with the <b><code>RentalItem</code></b> object at this point. Rather than creating a UI for such a simple example, let's look at how we might test this object in Visual Basic's Immediate debug window. With our two classes in place, we can enter the following into the Immediate window:</p>
<p>
<code>set x=New RentalItem</code></p>
<p>
<code>x.Price=1.99</code></p>
<p>
<code>print x.Price</code></p>
<p>
<code>&nbsp;1.99 </code></p>
<p>
<code>x.MarkAsPaid</code></p>
<p>
<code>x.CheckOut</code></p>
<p>
<code>x.Title="Video X"</code></p>
<p>
<code>print x.Title</code></p>
<p>
<code>&nbsp;Video X</code></p>
<p>
This example shows how we're able to work with the properties and methods from the <b><code>RentalItem</code></b> object itself, as well as those from the <b><code>LineItem</code></b> object. To the client code, there is no difference at all. This is exactly the behavior that we'd get using actual inheritance, were it available.</p>
<p>
This would, of course, be a lot easier if Visual Basic directly supported inheritance; but, at the same time, this shows that we can do inheritance in Visual Basic - after a fashion. Since generalization is such an important part of object design, it's very important for us to be able to implement it in some manner.</p>
</BODY>
</HTML>
