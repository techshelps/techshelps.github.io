<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Inheritance</title>
<style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000 dir=ltr>
<h1><a name="inheritance"></a>Inheritance</h1>
<p>
Inheritance is the concept that a new class can be based on an existing class, inheriting its interface and functionality from the original class.With inheritance, a class gains all the properties and methods that make up the interface of the base class, and it can then extend the interface by adding properties and methods of its own. The new class can also extend or change the implementation of each of the properties and methods from the original base class.</p>
<p>
For instance, if we had a class called <i>Fruit</i> that had all the properties and methods which apply to all types of fruit, then inheritance would make it very easy to create classes for <i>Apple</i>, <i>Orange</i> and so forth. We wouldn't have to recreate all the code for an apple to be a fruit: it would get that automatically from the original Fruit class.</p>
<h2>Interface Inheritance</h2>
<p>
Visual Basic 5.0 doesn't directly support the concept of inheritance. It does provide something called <b>interface inheritance</b> using the <b><code>Implements</code></b> keyword. We've already used this keyword when we discussed polymorphism, but it can be applied here to help simulate a form of inheritance. </p>
<p>
Interface inheritance lets us inherit the interface of one class into a new class. The downside is that all we get is the interface, not the original object's data or behavior. Worse still, we can't extend an interface created with the <b><code>Implements</code></b> keyword. One of the key benefits of inheritance is the ability to extend the base interface, so this is a substantial drawback.</p>
<p>
If we look at a <b><code>Fruit</code></b> class, we'll find an interface that includes elements appropriate for any type of fruit. In this example, we've got a growing climate and color for the fruit:</p>
<pre><code>Option Explicit

Public Property Get GrowingClimate() As String

End Property

Public Property Get Color() As String

End Property</code></pre>
<pre><code>Public Property Get Bites() As Integer

End Property</code></pre>
<p>
Notice that there's no code in the routines shown here. That's because all we'll be inheriting is the interface; any code in these routines wouldn't be used anyway.</p>
<p>
Now we can create a new class, <b><code>Apple</code></b>, and inherit the interface from the <b><code>Fruit</code></b> class by using the <b><code>Implements</code></b> keyword:</p>
<pre><code>Option Explicit

Implements Fruit

Private Property Get Fruit_GrowingClimate() As String
  Fruit_GrowingClimate = "Moderate"
End Property

Private Property Get Fruit_Color() As String
  Fruit_Color = "Red"
End Property

Private Property Get Fruit_Bites() As Integer
  Fruit_Bites = 20
End Property</code></pre>
<p>
Earlier in the chapter, we discussed multiple interfaces and how the <b><code>Implements</code></b> keyword works. Instead of declaring <b><code>GrowingClimate</code></b>, <b><code>Color</code></b> and <b><code>Bites</code></b> directly, we need to make them <b><code>Private</code></b> in scope and put <b><code>Fruit_</code></b> in front of each name so Visual Basic knows that these routines belong to the <b><code>Fruit</code></b> interface.</p>
<p>
We might also create an <b><code>Orange</code></b> class, again based on the <b><code>Fruit</code></b> interface:</p>
<pre><code>Option Explicit

Implements Fruit

Private Property Get Fruit_GrowingClimate() As String
  Fruit_GrowingClimate = "Warm"
End Property

Private Property Get Fruit_Color() As String
  Fruit_Color = "Orange"
End Property

Private Property Get Fruit_Bites() As Integer
  Fruit_Bites = 20
End Property</code></pre>
<p>
Now, contrary to what we'd expect, we can write code to compare apples and oranges:</p>
<pre><code>Public Function CompareColor(AnApple As Fruit, AnOrange As Fruit)
  CompareColor = (AnApple.Color = AnOrange.Color)
End Function</code></pre>
<p>
More importantly, we've created two different classes, both having inherited the same interface from <b><code>Fruit</code></b>. This is a very powerful technique when we have otherwise dissimilar classes that have a number of the same interface elements. We can write client code to treat all the objects the same - even though they are different.</p>
<p>
Unfortunately, this technique doesn't allow us to extend the interface, and so it is less a way to implement inheritance than it is to implement polymorphism, as in the last section. The <b><code>Orange</code></b> class can't add properties or methods to its version of the <b><code>Fruit</code></b> interface. This limits our flexibility, and really prevents us from using this to simulate full-blown inheritance.</p>
<h2>Containment and Delegation</h2>
<p>
Fortunately, it is possible, with a little extra work, to roll our own inheritance using Visual Basic - and thus gain many of the advantages we'd get in other languages that fully support inheritance. This is achieved by combining a concept called <b>containment</b> with another called <b>delegation</b>. </p>
<p>
Containment is the idea that an object can have a private instance of another object inside itself. Were we to have a <i>Human</i> object, it might <i>contain</i> a <i>Heart</i> object. The Heart object would be private to the <i>Human</i> object, since no client code would normally interact with the Heart.</p>
<p>
Delegation means that one object delegates work to another object rather than doing the work itself. If our <i>Human</i> object has a <i>PulseRate</i> property, it might ask the <i>Heart</i> object for the rate rather than figuring it out by itself. It has effectively delegated the responsibility for the <i>PulseRate</i> to the <i>Heart</i> object.</p>
<p>
If we combine these two concepts, we can simulate inheritance. Let's look at how that can work with our fruit example.</p>
<p>
Again, we'll create a class called <b><code>Fruit</code></b>; but this time we'll put some code in the <b><code>GrowingClimate</code></b> routine. With inheritance, we'd expect to be able to use this behavior in any new classes we create based on <b><code>Fruit</code></b>:</p>
<pre><code>Option Explicit

Public Property Get GrowingClimate() As String
  GrowingClimate = "Moderate"
End Property

Public Property Get Color() As String

End Property

Public Property Get Bites() As Integer

End Property</code></pre>
<p>
Now we'll create an <b><code>Apple</code></b> class, but this time we won't use the <b><code>Implements</code></b> keyword. Instead, we'll manually recreate the interface from the <b><code>Fruit</code></b> class - with absolutely no changes to the declarations of either property:</p>
<pre><code>Option Explicit

Private objFruit As New Fruit

Public Property Get GrowingClimate() As String
  GrowingClimate = objFruit.GrowingClimate
End Property

Public Property Get Color() As String
  Color = "Red"
End Property

Public Property Get Bites() As Integer
  Bites = 20
End Property</code></pre>
<p>
The first thing you might notice is that we're creating a <b><code>Private</code></b> <b><code>Fruit</code></b> object within our new class. Our new <b><code>Apple</code></b> class is using the concept of containment to have an instance of the <b><code>Fruit</code></b> class inside itself:</p>
<pre><code>Private MyFruit As New Fruit</code></pre>
<p>
In the <b><code>GrowingClimate</code></b> routine, our new <b><code>Apple</code></b> class just delegates the work down to the private <b><code>Fruit</code></b> object:</p>
<pre><code>GrowingClimate = objFruit.GrowingClimate</code></pre>
<p>
Now let's create an <b><code>Orange</code></b> class by following the same technique:</p>
<pre><code>Option Explicit

Private objFruit As New Fruit

Public Property Get GrowingClimate() As String
  GrowingClimate = "Warm"
End Property

Public Property Get Color() As String
  Color = "Orange"
End Property

Public Property Get Bites() As Integer
  Bites = objFruit.Bites
End Property

Public Property Get Slices() As Integer
  Slices = Bites / 2
End Property</code></pre>
<p>
Since the <b><code>GrowingClimate</code></b> for an <b><code>Orange</code></b> is different, it doesn't delegate that call down to the <b><code>Fruit</code></b> object. Instead, it replaces, or overrides, the functionality by implementing the routine itself.</p>
<p>
We have also extended the interface for our <b><code>Orange</code></b> object by adding a <b><code>Slices</code></b> property. While we've simulated the inheritance of the <b><code>GrowingClimate</code></b>, <b><code>Color</code></b> and <b><code>Bites</code></b> properties, we're also able to extend the interface as needed for each specific class.</p>
<p>
Back to our client code, which compares apples and oranges, we need to change how we accept our parameters:</p>
<pre><code>Public Function CompareColor(AnApple As Object, _
    AnOrange As Object)
  CompareColor = (AnApple.Color = AnOrange.Color)
End Function</code></pre>
<p>
The code within this routine is the same as we had before, but now our parameters are of type <b><code>Object</code></b> instead of type <b><code>Fruit</code></b>. Since our new classes don't use the <b><code>Implements</code></b> keyword, we can't have Visual Basic treat these objects like a <b><code>Fruit</code></b> object. </p>
<p>
However, we do know that they have the same set of properties and methods, and so we can write our code to treat them identically. We just need to tell Visual Basic that they are generic objects rather than objects of a specific class.</p>
</BODY>
</HTML>
