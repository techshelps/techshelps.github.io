<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Defining Object Relationships</title>
<style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000 dir=ltr>
<h1><a name="definingobjectrelationships"></a>Defining Object Relationships</h1>
<p>
Although it may sound old-fashioned, it can be very valuable to write the name of each object that we listed on to a small card or piece of paper, one note per object. Then we can use a white-board, or any other large surface we can draw on, and stick the objects to the surface. This lets us move the objects around as needed, and lets us draw lines between the objects to show how they're connected.</p>
<p class=indent>
There are commercial case tools on the market that make this very easy to perform on a computer. Rational Rose for Visual Basic and Microsoft Visual Modeler are good examples. These programs can be very useful, as they offer the same abilities as putting cards on a white-board, but allow us to save the diagrams to disk, add comments to our objects and relationships, and sometimes even generate code based on the object design.</p>
<p>
Once our objects are written down and placed on a surface, we're ready to move on and figure out how they relate to each other. This is fairly straightforward, since all we need to do is go back through the use case and look for verbs and other connecting phrases between the nouns. Again, this could get carried to an extreme, so some judgement is required!</p>
<h2>Types of Relationships</h2>
<p>
There are some key types of relationships that we need to find. Other relationships exist, and are important, but these are ones we need to make sure we get:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=674>
<tr valign=top>
<td class=blue width=35%><b>Relationship</b></td>
<td class=blue width=65%><b>Description/Example</b></td>
</tr>
<tr valign=top>
<td width=35%>Ownership (owns, has)</td>
<td width=65%>Parent-child relationships</td>
</tr>
<tr valign=top>
<td width=35%>User (uses)</td>
<td width=65%>One object uses or employs the services of another object</td>
</tr>
<tr valign=top>
<td width=35%>Aggregate (contains, made of)</td>
<td width=65%>One object is made up of other (subordinate) objects</td>
</tr>
<tr valign=top>
<td width=35%>Generalization (is a)</td>
<td width=65%>One object is a specific type of another object</td>
</tr>
</table><br>
<p>
Something else to keep in mind is that we might need to add some new objects as we go along. Picking out the nouns from the use case is great, but the use case might have <i>implied</i> some other objects that we don't have yet. For instance, we may find that we need objects to represent some of the verbs in our use cases. That's fine, just don't be surprised if it happens. </p>
<p>
Following the same logic, there will be objects that we don't need, and we'll be getting rid of those.</p>
<h2>Example Relationships</h2>
<p>
So let's look through the use case and pick out some relationships:</p>
<ul type=disc>
<li>
A customer <b>owns </b>an ID card<br><br></li>
<li>
An ID card <b>contains </b>a customer number<br><br></li>
<li>
A customer <b>has </b>an ID number<br><br></li>
<li>
A video <b>has </b>an ID number<br><br></li>
<li>
Attendant <b>uses </b>the screen<br><br></li>
<li>
Attendant <b>chooses </b>a menu option<br><br></li>
<li>
Barcode reader <b>scans </b>the ID card<br><br></li>
<li>
The screen <b>displays (or uses) </b>the customer information<br><br></li>
<li>
The screen <b>displays (or uses) </b>the video information<br><br></li>
<li>
The screen <b>displays (or uses) </b>the subtotal, tax, and total<br><br></li>
<li>
The subtotal price <b>uses </b>the video prices<br><br></li>
<li>
The tax <b>uses </b>the subtotal price<br><br></li>
<li>
The total is <b>made up of </b>the subtotal and tax</li>
</ul>
<p>
There are other relationships that we could identify; these are just some examples that illustrate the common relationships we'll encounter. This information is more clearly presented in diagrammatic form:</p>
<p>
<img src="image3-2.gif" border=0></p>
<p class=indent>
The figure shown here was drawn using Microsoft Visual Modeler, part of the Visual Studio package. The notation used is the Universal Modeling Language (UML). Appendix B contains a brief explanation of UML as used here.</p>
<h2>Eliminating Unneeded Objects</h2>
<p>
Now the challenge is to eliminate the objects that we don't need to put into our software model. There are two main things to look at:</p>
<ul type=disc>
<li>
Objects that just aren't needed in this particular use case<br><br></li>
<li>
Objects that fit into other layers of the application, such as the presentation layer</li>
</ul>
<p>
The first thing we should do is look at those objects that don't have a lot of relationships in the diagram. Neither the attendant nor the barcode reader are well connected, so they need to be looked at carefully. </p>
<p>
It's unlikely that we'll need to have an attendant object to handle the functionality in this use case, since the attendant just interacts with the screen. We won't completely write it off as an object, however, because it was also listed in the requirements use case - so it may be used to provide some other functionality. Still, we don't need it here, so we can remove it from our diagram.</p>
<p>
The barcode reader is probably not required either. This is more of a common sense issue, but barcode readers usually just provide input to the software that's indistinguishable from keyboard input, so it's hard to imagine what such a business object would do for our program.</p>
<p>
Now look at the objects that the attendant and barcode reader touched. The screen object is still very connected, but the ID card is a borderline case. Since the ID card is just a way of expressing the customer's ID number, we can probably eliminate it from the picture as well.</p>
<p>
The next step is to look at each object and eliminate those that belong in either the presentation or data processing layers of the application. In our case, the screen object certainly fits the bill for belonging in the presentation layer. </p>
<p class=indent>
However, it's very useful to leave something representing the presentation layer in the model, for the sake of clarity. At the same time, we don't want to mistake it to be an actual business object, so we need to keep that in mind when we look at the figure.</p>
<p>
After all the changes, our diagram looks like this:</p>
<p>
<img src="image3-3.gif" border=0></p>
<h2>Consolidating Objects</h2>
<p>
At this point, we've got a pretty clear picture of the objects that we need, and how they're all related to each other. Now is a good time to look at the diagram with a critical eye to determine if there are objects that can be consolidated to form a more general object.</p>
<p class=indent>
There may also be objects in our diagram that are really attributes of other objects, but we won't worry about those yet. We'll discuss attributes and properties in the next section.</p>
<p>
Looking at the diagram, there are three objects that are all very much interrelated. The <i>tax</i> and <i>total</i> objects are both generated upon the basis on the <i>subtotal</i> object. It would make a lot of sense to add a new object to the diagram that would give us a more general view of these objects.</p>
<p>
If we look back at our requirements use case, we'll see that there is a potential business object called an <i>invoice</i>. </p>
<p class=indent>
It is important to keep looking back at the requirements use case, and to look at all the other related functional use cases, to find objects that overlap or have relationships with the objects at hand. Our functional analysis is not happening in isolation, so it's important to regularly stop and take a look at the bigger picture.</p>
<p>
The <i>invoice</i> object needs to display the total amount along with some other information, so it's a good candidate to use as an object to contain the <i>total</i>, <i>tax</i> and <i>subtotal</i> objects. Here's a list the relationships for our new <i>invoice</i> object:</p>
<ul type=disc>
<li>
The invoice <b>has a</b> total<br><br></li>
<li>
The invoice <b>has a</b> subtotal<br><br></li>
<li>
The invoice <b>has a</b> tax<br><br></li>
<li>
The invoice <b>refers to</b> customer<br><br></li>
<li>
The invoice <b>has a</b> list of videos</li>
</ul>
<p>
Looking back at the previous example, we can see how complex the model is for the presentation designer. The <i>screen</i> entity is communicating with a lot of different objects in our model, so it may be very difficult for the programmer of the presentation layer to use our model effectively. In this new model, however, the UI developer only needs to worry about interacting with three objects: <i>invoice</i>, <i>video</i> and <i>customer</i>. All the other objects are available through one of those three.</p>
<p>
If we add in the <i>invoice</i> object, we end up with the following diagram for our objects:</p>
<p>
<img src="image3-4.gif" border=0></p>
<p>
At this point, we have a pretty good understanding of the business objects that we need to handle for the functional use case. We may not be done yet, however: it's possible that we'll still need to add or remove some objects as we finish up the analysis.</p>
<p>
Now we need to move on to figure out some specifics about the objects; in particular, we need to list the properties, methods, and events that each object needs in order to support the use case's functionality. First, let's look at the properties.</p>
</BODY>
</HTML>
