<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Notification (or Events)</title>
<style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000 dir=ltr>
<h1><a name="notificationorevents"></a>Notification (or Events)</h1>
<p>
There are many times when objects can perform some action in response to a property being set or a method being called. This has traditionally been difficult to implement, since an object has usually needed to notify the calling program that the action has taken place.</p>
<p>
In the previous section, we discussed the <i>invoice</i> object and how it can detect when a video is added or removed from the list of rentals. Either of these conditions should cause the subtotal, tax and total amounts to be recalculated. The challenge is that the UI needs to be notified that these values have changed so that the display can be updated.</p>
<h2>Traditional Solutions</h2>
<p>
Traditionally, this would have been handled either by having the UI refresh the values when it added or removed a video, or by calling a special <i>Calculate </i>method to force the calculation. </p>
<p>
If the UI updates the values when adding or removing a video, we've effectively coded some business logic into the UI. After all, the UI would have to know all the conditions under which the values might change, so that it could know when to refresh the display.</p>
<p>
Using an explicit <i>Calculate</i> method is also far from ideal. If we have such a method, then we're relying on the UI code to call it, rather than recalculating our values automatically. If the UI doesn't call the method when appropriate, we could end up in a situation where the subtotal, tax, and total properties on the object would be incorrect. This solution can not only lead to bugs, but it also requires that the UI programmer must have more knowledge about how our object works than we might otherwise prefer (such as a more appropriate time to call the <i>Calculate</i> method).</p>
<h2>Callbacks</h2>
<p>
A more complex solution to the problem would be to have the <i>invoice</i> object call a method of another object and have that object update the UI. This solution solves most of our problems, but it's definitely harder to implement for the UI developer.</p>
<p>
To implement this, the UI itself would have to create an object to receive the message sent by the invoice object. Of course, the invoice object would need to know about the UI's object so that it could call it; we'd therefore need to add a method to the invoice object so that the UI could pass a reference to its object! </p>
<p>
Once the invoice object had a reference to the UI's object (let's call it <i>Displayer</i>), it could call some predefined method on the <i>Displayer</i> object whenever a message needed to be sent to the UI. This is shown in this diagram:</p>
<p>
Let's look through some code that could handle this.</p>
<p>
<img src="image3-6.gif" border=0></p>
<h3>Displayer Object</h3>
<p>
First off, our UI developer will need to provide an object to update the display. Create an ActiveX DLL project, create a new class module called <b><code>Displayer</code></b>, and add this sample code:</p>
<pre><code>Option Explicit

Public Sub UpdateValues()
  ' in this routine we'd update our display
  ' with the properties from the Invoice
  ' object
End Sub</code></pre>
<p>
This example assumes that we've implemented our business objects in an ActiveX DLL, and that the UI is in a different EXE or DLL. We'll keep our <b><code>Displayer</code></b> class in a separate ActiveX DLL for now, which will allow us to create a simple UI test harness in a Standard EXE. (Alternatively, if we had created our UI in a ActiveX DLL, then the <b><code>Displayer</code></b> class could have been included within the main UI project.) </p>
<p>
The <b><code>Displayer</code></b> class must also have its <b><code>Instancing</code></b> property set to 5 - MultiUse so that we can make it available to the <b><code>Invoice</code></b> object. </p>
<p>
<br>
The upshot of all this is that if we did want our <b><code>Displayer </code></b>class to be within the main UI program, then our UI project would need to be an ActiveX server - whereas it may have only needed to be a regular program prior to the introduction of the callback mechanism.</p>
<h3>Invoice Objects</h3>
<p>
Within the main DLL project for our business objects, the <b><code>Invoice</code></b> class also needs some special code to support the callback. It needs a method that will allow the UI to give it a reference to the <b><code>Displayer</code></b> object. </p>
<p>
For our current example, add a sample DLL for our business objects, using the File-Add Project menu option, then add a class module, using the Project-Add Class Module menu option, and call that class module <b><code>Invoice</code></b>. Now add the following sample code to <b><code>Invoice</code></b>:</p>
<pre><code>Option Explicit

Private objCallback As Object

Public Sub SetCallback(Display As Object)
  Set objCallback = Display
End Sub</code></pre>
<h3>Performing the Callback</h3>
<p>
Then, in the routine where the <b><code>Invoice</code></b> object does the calculations, we need to call the <b><code>UpdateValues</code></b> method of the <b><code>Displayer</code></b> object:</p>
<pre><code>Public Sub Calculate()
  ' here we'd do the calculations
  
  objCallback.UpdateValues
End Sub</code></pre>
<h3>Releasing Object References</h3>
<p>
Finally, we need to make sure that the <b><code>Invoice</code></b> object releases its reference to the <b><code>Displayer</code></b> object before the <b><code>Invoice</code></b> goes away. If we don't do this, we run the risk of having objects hanging around in memory after we've tried to close down the program:</p>
<pre><code>Private Sub Class_Terminate()
  Set objCallback = Nothing
End Sub</code></pre>
<h3>The UI Code</h3>
<p>
Now that all that has been set up, we can write some UI code that creates the <b><code>Invoice</code></b> object. Since we're going to use a Standard EXE to hold our sample UI and test our callback mechanism, add a Standard EXE project using the File-Add Project menu option, add a standard module to that project, using the Project-Add Module menu option, and enter this example code:</p>
<pre><code>Private objInvoice As Invoice
Private objDisplayer As Displayer</code></pre>
<pre><code>Set objDisplayer = New Displayer
Set objInvoice = New Invoice

objInvoice.SetCallback objDisplayer
objInvoice.Calculate</code></pre>
<p>
Notice that, as well as creating an <b><code>Invoice</code></b> object, we create a <b><code>Displayer</code></b> object, and give the <b><code>Invoice</code></b> object a reference to it.</p>
<p class=indent>
You'll need to make a reference to the <b><code>Invoice</code></b> object from the UI project. Select the UI project in the Project window, and use the Project-References menu option to select the project containing our <b><code>Invoice</code></b> object.<br>
<br>
Since we've created a separate EXE for the UI test harness, we also need to add references to the projects containing the <b><code>Displayer</code></b> object and the <b><code>Invoice</code></b> object. Select the UI EXE project in the Project window, and use the Project-References menu option to select the appropriate references to the other projects.</p>
<p>
If you run the sample program as it stands, you won't see much happen: but if you step through the program execution, you'll see the callback mechanism alive and well. The UI code successfully establishes the <b><code>Displayer</code></b> callback method to itself before it calls the <b><code>Invoice</code></b> object's <b><code>Calculate</code></b> method. Within the <b><code>Calculate</code></b> method, the callback is then made to the <b><code>Displayer</code></b> class's <b><code>UpdateValues</code></b> routine.</p>
<p>
This solves our problem, in that it allows an object to notify our program when something has happened. In our example, the <b><code>Invoice</code></b> object notifies the UI object that <b><code>Calculate</code></b> method has been called. In some ways, this is very attractive, since the interaction between the two objects is very well defined, and the UI can give the <b><code>Invoice</code></b> object a reference to any object that implements an <b><code>UpdateValues</code></b> method. Since this technique uses regular method calls between the two objects, we can write our code to pass any parameters that our program might need.</p>
<p>
On the other hand, this solution is somewhat complex: it forces the UI developer to add a new class to the project, or make the UI program an ActiveX server. It also tightly couples the business object to the UI implementation, since it requires that the UI provide an object with a specific method.</p>
<h2>Raising Events</h2>
<p>
Visual Basic 5.0 introduced the ability to raise <b>events</b> from our objects. This means that we can write code in our class module that will raise an event in the calling code, just as a button control can raise a <b><code>Click</code></b> event in a form.</p>
<p>
This is done by introducing three new keywords to the Visual Basic 5.0 language. In our class module, we need to use the <b><code>Event</code></b> and <b><code>RaiseEvent</code></b> keywords, respectively, to declare and raise events. In the calling code (Form or Class module), we need to declare the object using the new <b><code>WithEvents</code></b> keyword.</p>
<p>
Sticking with the <b><code>Invoice</code></b> object example, we could have the <b><code>Invoice</code></b> object raise an event when the subtotal, tax and total amounts have changed. Then the UI programmer would just need to write code behind the event to update the display. This is a very nice model, since all Visual Basic programmers are familiar with writing code to respond to events - so the learning curve for the UI programmer is very small.</p>
<h3>Invoice Objects</h3>
<p>
Inside our <b><code>Invoice</code></b> object, we need to have a line to declare our event:</p>
<pre><code>Public Event UpdateValues()</code></pre>
<p>
Then in the routine where we calculate the amounts, we can add a line to raise the event:</p>
<p>
<code>Private Sub Calculate()</code></p>
<p>
<code>&nbsp;&nbsp;' here we'd do the calculations</code></p>
<p>
<code>&nbsp;&nbsp;</code></p>
<pre><code>&nbsp;&nbsp;RaiseEvent UpdateValues</code></pre>
<p>
<code>End Sub</code></p>
<p>
All references to our <b><code>objCallback</code></b> object are now unnecessary, and we no longer need our <b><code>SetCallback</code></b> routine, since we've managed to create the same mechanism using events.</p>
<h3>The UI Code</h3>
<p>
The UI programmer just needs to make a change to the declaration of the <b><code>Invoice</code></b> object to include the <b><code>WithEvents</code></b> keyword:</p>
<pre><code>Private WithEvents objInvoice As Invoice</code></pre>
<p>
At this point, the <b><code>objInvoice</code></b> object will appear in the Object dropdown in the upper-left of the code window, along with any other controls or objects available to the module. If we choose <b><code>objInvoice</code></b>, then the Procedure dropdown in the upper right will list all the events that are declared in the <b><code>Invoice</code></b> class - just <b><code>UpdateValues</code></b> in this case. This means we can write a regular event procedure:</p>
<pre><code>Private Sub objInvoice_UpdateValues()
  ' here we'd put the code to update the
  ' values on the display
End Sub</code></pre>
<p>
All references to our <b><code>objDisplayer</code></b> object are now unnecessary; and, since we no longer need our <b><code>Displayer</code></b> class module, the UI no longer needs to be an ActiveX server.</p>
<p>
This solution is not very different from implementing a callback, but it does have some significant advantages. The UI programmer doesn't need to implement a special class. In fact, the UI programmer can draw on existing knowledge and techniques to write code behind the object's events - just as if they were events from a control on a form. Furthermore, the <b><code>Invoice</code></b> object author doesn't need to worry about being passed some external object, or any specifics about the calling program at all. They may appreciate that.</p>
<p>
The bottom line is that the <b><code>RaiseEvents</code></b> command works independently of whether anyone actually receives the event that's raised. This means that we've effectively separated the UI programmer's tasks from the object developer's tasks.</p>
</BODY>
</HTML>
