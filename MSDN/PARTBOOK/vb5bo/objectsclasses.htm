<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Objects and Classes</title>
<style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000 dir=ltr>
<h1><a name="objectsclasses"></a>Objects and Classes</h1>
<p>
All objects are defined by a <b>class</b>. A class is essentially a template from which the object is created, which means that we can create many objects based on a single class. Each object is referred to as an <b>instance</b> of the class.</p>
<p>
The word class is pretty descriptive, since we're basically classifying our objects. For instance, if we have a couple of objects, <i>Squirrel</i> and <i>Rabbit</i>, they could be instances of a <i>Mammal</i> class. </p>
<p>
To use a more business-like example, we may have a <i>Customer</i> class. From this class we could create instances to represent each our customers, such as <i>Fred Smith</i> and <i>Mary Jones</i>. Each actual customer would have its own object, but all the objects would be created from the same template, the Customer class: </p>
<p>
<img src="image1-2.gif" border=0></p>
<p>
In Visual Basic, we define classes using <b>class modules</b>. We can then create objects based on the class module, with each object being an instance of the class.</p>
<p>
Class modules are like form or standard modules, in that they have a declaration section followed by a series of <b><code>Sub</code></b>, <b><code>Function</code></b> and <b><code>Property</code></b> subroutines. The difference is that the variables and code in a class module can only be used by creating an instance of the class.</p>
<p>
Let's take a look at how Visual Basic's class modules are used to provide a template for our objects.</p>
<h2>Objects Contain Data</h2>
<p>
All objects contain data about themselves. For instance, an object representing a simple cardboard box might have data about the box's height, width, and depth. The object might also know whether the box is open or closed. Furthermore, we might have many box objects, each with its own height, width and depth. Each of these objects could be an instance of a <i>Box</i> class.</p>
<p>
Data values in objects are stored in <b>instance variables</b>. Each instance of an object has its own set of variables, separate from the variables of any other object, even those of the same class. In this way, two objects of the same class can each have their own individual data, so each of our earlier box objects can have its own height, width, and depth.</p>
<p>
In Visual Basic, a class's instance variables are stored as module-level variables inside a class module. For example:</p>
<pre><code>Option Explicit

Private dblHeight As Double
Private dblWidth As Double
Private dblDepth As Double
Private blnOpen As Boolean</code></pre>
<p>
As with any other module, module-level variables in a class module can be declared as either <b><code>Public</code></b> or <b><code>Private</code></b>. </p>
<p>
<b><code>Private</code></b> variables are only accessible to code within the class module, and they are the preferable way to manage data within objects. For any client code to manipulate a <b><code>Private</code></b> variable, it must call our object's code to do the manipulation; it can't do anything directly. This gives us a lot of control, since we can implement business or validation rules against any values that the client code attempts to change.</p>
<p>
Instance variables declared as <b><code>Public</code></b> are accessible to code within our object, but they are also directly accessible to any client code written to use our object. Use of <b><code>Public</code></b> instance variables is very bad practice. Any client code can directly manipulate a <b><code>Public</code></b> instance variable, without going through any of our object's code. This means our object gives up all control over the value, trusting the author of the client code not to break any rules or do anything that is invalid.</p>
<p>
One of the primary principles of object design is <b>encapsulation</b>, a concept we'll explore throughout the rest of the book. Encapsulation means that objects should hide their internal design and data from the code that uses them. </p>
<p>
<b><code>Private</code></b> variables help by forcing any client code to use our code to change our object's data, thus allowing us to change how the object is implemented at any time with little or no impact on other programs that use this object. <b><code>Public</code></b> variables directly break the principal of encapsulation, providing a client with direct and uncontrolled access to an object's data.</p>
<h2>Objects Have Behaviors</h2>
<p>
Of course, the whole idea behind having an object is so our programs can interact with it. If we're encapsulating an object's data then we need to provide the ability for the client programmer to access the information that the object holds. </p>
<p>
Objects need to provide an interface to allow their client programs to gain access to these services. Just as in the real world, where objects interact - it is our aim in programming with objects to facilitate and control their interaction - via properties, methods and events. These form the interface the object presents to the world.</p>
<p>
In Visual Basic, an object's interface is composed of <b><code>Property</code></b>, <b><code>Sub</code></b> and <b><code>Function</code></b> routines, as well as any events declared using the <b><code>Event</code></b> keyword. Any of these routines declared as <b><code>Public</code></b> within the class module become part of the object's interface.</p>
<p class=indent>
In reality, an object can have many interfaces, allowing client code to use the object in different ways as appropriate. We'll cover this in more detail in the next section.</p>
<h3>Properties</h3>
<p>
A property is an attribute that describes the object. Objects often have many properties to provide client code with access to all of their attributes.</p>
<p>
It's important to make that an object's properties are not the same as its data. Objects often contain data that would not be considered to be an attribute of the object. For instance, a <i>Person</i> object may have an <i>Age</i> property, but the underlying data might be a birth date. The birth date itself may or may not be available as a property of the object.</p>
<p>
Properties allow us, as the object's designer, to pick and choose what information we want to make available about our object. We can also choose which property values can be changed by our object's users. Some of that information may come directly from our object's data, while other information may come from calculated values or other sources.</p>
<p>
So in our earlier box example we may not care to let other programs see the box's dimensions, but we may want them to be able to get at the box's volume:</p>
<pre><code>Public Property Get Volume() As Double
  Volume = dblHeight * dblWidth * dblDepth
End Property</code></pre>
<p>
Visual Basic provides us with three different types of <b><code>Property</code></b> routines. <b><code>Property Get</code></b> routines are used to retrieve a property from an object. Then there are two routines to put values into a property, depending on whether the value is a reference to an object or not. <b><code>Property Let</code></b> routines allow client code to put any value into a property other than a reference to an object, while <b><code>Property Set</code></b> routines are used only for object references.</p>
<p>
Properties can be read-only (<b><code>Property</code></b> <b><code>Get</code></b>), write-only (<b><code>Property</code></b> <b><code>Let/Set</code></b>) or read-write (both properties). Even if we include a <b><code>Property</code></b> <b><code>Let</code></b> or <b><code>Property</code></b> <b><code>Set</code></b> routine for a property, we can include code in that routine to validate the new value or check any other business rules before allowing the client code to change the value.</p>
<h3>Methods</h3>
<p>
Objects, like their real-world counterparts, need to provide services (or functions) when they interact. Using their own data, or data passed as parameters to the method, they manipulate information to yield a result.</p>
<p>
Methods are simply routines that we code within the class to implement the services we want to provide. Some methods return values or provide information back to the calling code. These are called <b>interrogative methods</b>. Others, called <b>imperative methods</b>, just perform a service and return nothing to the calling code.</p>
<p>
In Visual Basic, methods are implemented using <b><code>Sub</code></b> or <b><code>Function</code></b> routines within the class module that defines our object. <b><code>Sub</code></b> routines may accept parameters, but they do not return any result value when they are complete. <b><code>Function</code></b> routines can also accept parameters, and they always generate a result value that can be used by the calling code.</p>
<p class=indent>
The difference between a <b><code>Function</code></b> routine and a <b><code>Property Get</code></b> routine is quite subtle. Both return a value to the calling code and, either way, our object is running a subroutine defined by our class module to return the value. </p>
<p class=indent>
The difference is less programmatic than it is a design choice. We could create all our objects without any <b><code>Property</code></b> routines at all, just using methods for all interactions with the object. However, <b><code>Property</code></b> routines are obviously attributes of the object, while a <b><code>Function</code></b> might be an attribute or a method. By carefully implementing all attributes as <b><code>Property Get</code></b> routines, and any interrogative methods as <b><code>Function</code></b> routines, we will create more readable and understandable code.</p>
<p>
Using our now familiar box example, programs may need to open or close the box - so we need to provide a way to do this:</p>
<pre><code>Public Sub OpenBox()
  blnOpen = True
End Sub

Public Sub CloseBox()
  blnOpen = False
End Sub</code></pre>
<p>
With this approach, our client code might look like this:</p>
<pre><code>&nbsp;&nbsp;Dim objBox As New Box

  objBox.Open
  objBox.Close</code></pre>
<p>
Where this gets more useful is when we add code to check our rules. We shouldn't be able to open an already open box, or close an already closed box. With absolutely no impact to our client code, we can add the following rules to the <b><code>Box</code></b> class:</p>
<pre><code>Public Sub OpenBox()
  If Not blnOpen Then Err.Raise vbObjectError, _
    "Box already open"
  blnOpen = True
End Sub

Public Sub CloseBox()
  If Not blnOpen Then Err.Raise vbObjectError, _
    "Box already closed"
  blnOpen = False
End Sub</code></pre>
<p>
In this case, we're simply raising an error if the client code tries to call either the <b><code>OpenBox</code></b> method when the box is already open or the <b><code>CloseBox</code></b> method when it's already closed. The real key, here, is that the implementation of these methods is totally encapsulated within our class module. We were able to make these changes without having to make any changes to our client code.</p>
<h3>Events</h3>
<p>
In object-oriented design, the concept of an event is pervasive. In OO parlance, objects act in response to events, such as a user providing a value, or another object calling one of our object's methods. In the Visual Basic 5.0 environment, we have access to a somewhat different type of event.</p>
<p>
Any Visual Basic developer is used to writing code to respond to events. Controls on forms generate events continually, and we write code behind those events to take appropriate action. For instance, a <b><code>CommandButton</code></b> control provides a <b><code>Click</code></b> event, firing it any time the user clicks on the button. We then write code to respond appropriately:</p>
<pre><code>Private Sub Command1_Click()
  MsgBox "The user clicked the button"
End Sub</code></pre>
<p>
Before Visual Basic 5.0, there was no way for a Visual Basic developer to <i>cause</i> events, only to respond to them. Now we can use the <b><code>Event</code></b> statement to declare an event and the <b><code>RaiseEvent</code></b> command to fire it off.</p>
<p>
Going back to our <b><code>Box</code></b> class, let's allow the user to stretch our box by implementing a <b><code>Stretch</code></b> method:</p>
<pre><code>Public Sub Stretch(Percentage As Double)
  dblHeight = dblHeight * Percentage
  dblWidth = dblWidth * Percentage
  dblDepth = dblDepth * Percentage
End Sub</code></pre>
<p>
As a convenience, perhaps we want to raise an event to let any client programs know that our box has a new size. Visual Basic makes this very easy. We just need to add an <b><code>Event</code></b> declaration in the (General) (Declarations) section of our <b><code>Box</code></b> class module:</p>
<pre><code>Event Stretched()</code></pre>
<p>
Events are always <b><code>Public</code></b> in scope, since they're always raised back to whatever client code has a reference to our object.</p>
<p>
With our event declared, we can now fire it off using the <b><code>RaiseEvent</code></b> command: </p>
<pre><code>Public Sub Stretch(Percentage As Double)
  dblHeight = dblHeight * Percentage
  dblWidth = dblWidth * Percentage
  dblDepth = dblDepth * Percentage
  RaiseEvent Stretched
End Sub</code></pre>
<p>
We'll go into much more detail about events in Chapter 3.</p>
<h2>Multiple Interfaces</h2>
<p>
So far, we've looked at an object as having a single interface composed of its <b><code>Public</code></b> <b><code>Sub</code></b>, <b><code>Function</code></b>, and <b><code>Property</code></b> routines, along with any events it has declared. With Visual Basic 5.0, things are a bit more complex. Our objects can actually have many different interfaces simultaneously, although a client can only use one at a time.</p>
<p>
If we create an object from a class we built in Visual Basic, that object will have at least the one interface we defined in our class module. In this simple case, it appears as though our program has direct access to the object, although in reality we're getting at the object through an interface defined by the class:</p>
<p>
<img src="image1-3.gif" border=0></p>
<p class=indent>
With Visual Basic 5.0, a client program never has direct access to an object, only to one of the object's interfaces.</p>
<p>
Sometimes, one interface isn't enough. Our object may represent more than one real world entity, and we need to be able to model this in Visual Basic. For instance, a <i>Customer</i> object is great, but a real customer is also a person. To model this in our application, we might need our Customer object to also act like a <i>Person</i> object from time to time.</p>
<p>
To accomplish this, we can just add the Person interface to our object. Then a client program can use our object through the Customer interface with its set of properties and methods. It might also use the object through the Person interface, with its own separate set of properties and methods. This way, the client can use the object in whichever way is appropriate at any given time:</p>
<p>
<img src="image1-4.gif" border=0></p>
<p>
As we've seen, when we create a class in Visual Basic, its <b><code>Public</code></b> members comprise the interface for our object. However, we can also use the <b><code>Implements</code></b> statement to add another interface to our object. The <b><code>Implements</code></b> keyword requires that we supply a class name with which it will work. </p>
<p>
With our <b><code>Box</code></b> example, for instance, we might also include an interface for a more generic <b><code>Container</code></b> class. To do this, we'd need to add an <b><code>Implements</code></b> statement in the general declarations section of our <b><code>Box</code></b> class module:</p>
<pre><code>Implements Container</code></pre>
<p>
As soon as we add this line, Visual Basic will require that we add code to our class module to implement all the <b><code>Public</code></b> properties and methods from the <b><code>Container</code></b> class. Suppose the <b><code>Container</code></b> class module contains a single method, called <b><code>PutIn</code></b>, and a property, called <b><code>IsOpen</code></b>:</p>
<pre><code>Public Sub PutIn(Item As Object)

End Sub

Public Property Get IsOpen() As Boolean

End Property</code></pre>
<p>
The property and method may or may not have code in them. As I've shown them in this example, there's no code. It doesn't really matter to our <b><code>Box</code></b> class, since we need to add our own code in the <b><code>Box</code></b> class module regardless. For instance, the <b><code>Box</code></b> class's implementation of <b><code>PutIn</code></b> may add any new items into a <b><code>Private</code></b> collection variable, and <b><code>IsOpen</code></b> may just return our <b><code>blnOpen</code></b> flag:</p>
<pre><code>Option Explicit
Implements Container

Private colItems As New Collection
Private dblHeight As Double
Private dblWidth As Double
Private dblDepth As Double
Private blnOpen As Boolean

Public Sub OpenBox()
  If Not blnOpen Then Err.Raise vbObjectError, _
    "Box already open"
  blnOpen = True
End Sub

Public Sub CloseBox()
  If Not blnOpen Then Err.Raise vbObjectError, _
    "Box already closed"
  blnOpen = False
End Sub

Private Sub Container_PutIn(Item As Object)
  colItems.Add Item
End Sub

Private Property Get Container_IsOpen() As Boolean
  Container_IsOpen = blnOpen
End Property</code></pre>
<p>
There are a couple interesting things about these new routines we've added. First off, they are declared as <b><code>Private</code></b> routines, so at first glance they don't appear to be available to any client code. This is deceptive, however, since they are available to clients through the <b><code>Container</code></b> interface. </p>
<p>
If these routines were declared as <b><code>Public</code></b>, they'd be part of the <b><code>Box</code></b> interface. That's not what we are after though. Instead of declaring them as <b><code>Public</code></b>, we declare them as <b><code>Private</code></b>, and then indicate that they belong to the <b><code>Container</code></b> interface by putting <b><code>Container_</code></b> in front of the name of the routine.</p>
<p>
We'll discuss multiple interfaces in more detail later in the book.</p>
</BODY>
</HTML>
