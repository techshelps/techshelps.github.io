<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Event-Driven Programming</title>
<style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000 dir=ltr>
<h1><a name="eventdrivenprogramming"></a>Event-Driven Programming</h1>
<p>
Visual Basic programming (and Windows programming, more generally) is almost entirely geared towards event-driven programming. This means that our programs are typically composed of subroutines that are run only in response to external events - such as a mouse click. It is a rare Windows program that runs a series of procedures from top to bottom and is done.</p>
<p>
Most mini-computer, mainframe and DOS-based applications were sequential in nature. They gathered the user's input in a specific order, processed it, and generated specific output. This was all very predictable, since the application itself was very much in control.</p>
<p>
In an event-driven environment, such as Windows, our applications effectively give control over to the user. The user gets to choose in which order they want to enter any input, when it should be processed and often how and where the results should be displayed. Rather than being in control, our application code sits in the background waiting for the user to indicate what should be done.</p>
<p>
For instance, let's look at how we might get input from the user. In a sequential application, we'd prompt the user for input when we needed it. In some form of DOS BASIC, that process might look like this:</p>
<pre><code>Print "Name? ";
Input strName
Print "Age? ";
Input intAge
Call DoProcessing(strName, intAge)</code></pre>
<p>
Here, the program is in control: it asks the user for each bit of information in turn, and the user has no choice but to follow the program's flow from top to bottom.</p>
<p>
Within Visual Basic, the approach is entirely different. We display a form to the user, allowing them to choose into which field, if any, they want to enter information:</p>
<p>
<img src="image2-1.gif" border=0></p>
<p>
Our code, rather than being a single sequential list of commands, now becomes a series of subroutines that are only run when specific events occur. For instance, as the user enters values into each text box on the screen, we may react to the input events and store the values in variables:</p>
<pre><code>Private Sub txtName_Change()
  strName = txtName
End Sub

Private Sub txtAge_Change()
  intAge = Val(txtAge)
End Sub</code></pre>
<p>
Then, in response to the <b><code>Click</code></b> event caused when the user clicks the OK button, we might perform some processing:</p>
<pre><code>Private Sub cmdOK_Click()
  DoProcessing(strName, intAge)
End Sub</code></pre>
<p>
Either approach gets the job done, but the event-driven approach turns a lot of control back over to the user. This is, generally, a positive thing: users usually like to have a choice about how they use their applications.</p>
<h2>Events and Objects</h2>
<p>
Event-driven programming works well when we're dealing with objects. This is because an event is basically a type of message. When the user clicks on a button, our program gets a message saying, "<i>Hey, the user clicked the button</i>". Of course, the message comes to us in the form of an event - in this case, the <b><code>Click</code></b> event for our button. Still, what we basically received was a message that something happened.</p>
<p>
When we're dealing with objects, we always interact with an object though its interface; that is, its properties and methods. When we call an object's method, we do so by <i>sending it a message</i>. This may not be very obvious, since, within our code, it looks as if we just called a method on the object. Take this line of code, for example:</p>
<pre><code>&nbsp;&nbsp;objCustomer.CreateInvoice</code></pre>
<p>
This code <i>looks</i> like a call to the <b><code>CreateInvoice</code></b> subroutine within the <b><code>Customer</code></b> class module. However, it's important to remember, when dealing with objects, that this kind of code actually sends a <b><code>CreateInvoice</code></b> <i>message</i> to the <b><code>objCustomer</code></b> object.</p>
<p>
Our objects react to such events in the same way that Visual Basic programs have always reacted to events: using a subroutine.</p>
<pre><code>Public Sub CreateInvoice()
  ' create the invoice here
End Sub</code></pre>
<p>
Any time we interact with an object, we're doing so by sending it a message. From the object's perspective, a message is basically an event caused by some outside force (typically, our program's code or some other object), and so our objects are always driven by events - just like our traditional Visual Basic applications.</p>
</BODY>
</HTML>
