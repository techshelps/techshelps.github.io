<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Caching</TITLE>

<META NAME=MS-HKWD CONTENT="Caching">
<META NAME="Keywords" CONTENT="Internet Tools & Technologies">
<META NAME="Platform" CONTENT="Windows, Win95, WinNT, Mac">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">


<SCRIPT>
//<!--
var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";
// -->
</SCRIPT>
<SCRIPT SRC="../../../code/ver.js"></SCRIPT>


<SCRIPT DEFER SRC="../../../code/common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
	if (g_isIE && g_iMaj >= 4)	
	{
		SetTOC();
	}
}
//-->
</SCRIPT>

<LINK REL="stylesheet" HREF="/msdn/sdk/inetsdk/help/basicsdkIE4.css" TYPE="text/css">
<!-- STYLE_START -->


<SCRIPT>
//<!--
   var sVR = '../../../'	// Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
	   if (g_iMaj >= 4) // For MSIE 4.0 or later
	   {
		   sCSS += 'basicSDKIE4';
		   if (g_sPlat == "Win") // Windows only for now
		   {
			   document.createStyleSheet(sVR + 'advSDKIE4.css');
		   }
	   }
	   else // For MSIE 3.0 or earlier
	   {
		   sCSS += 'basicSDKIE3';
	   }
   }
   else if (g_isNav) // For all Nav versions
   {
	   sCSS += 'basicSDKNAV';
   }
   else
   {
	   sCSS += 'basicSDKIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->
</SCRIPT>
<!-- STYLE_END -->
</HEAD>
<BODY onload="InitPage()" BGCOLOR="#FFFFFF">

<A NAME="pagetop"></A><A NAME="winineto_cache"></A>
<!-- NAV_LINKS_START -->
<TABLE class=main BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="10%"><TR><TD ROWSPAN="3" VALIGN="TOP" WIDTH="121"><IMG SRC="../../../art/headbar2.gif" WIDTH="121" HEIGHT="82" BORDER=0 ALT="Caching"></TD><TD ROWSPAN="2" VALIGN="TOP" WIDTH="186"><IMG SRC="../../../art/headbard.gif" WIDTH="186" HEIGHT="44" BORDER=0 ALT="Caching"></TD><TD VALIGN="TOP" WIDTH="470"><IMG SRC="../../../art/replace1.gif" WIDTH="470" HEIGHT="17" BORDER=0 ALT="*"></TD></TR>
<TR><TD><PRE><IMG SRC="../../../art/arrowrht.gif" WIDTH="14" HEIGHT="14" ALIGN="MIDDLE" BORDER=0 ALT="*"><object id="hhal_1" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Contents>
</object><A STYLE="color:black" ID=TOC HREF=JavaScript:hhal_1.Click()>Contents</A>  <IMG SRC="../../../art/arrowrht.gif" WIDTH="14" HEIGHT="14" ALIGN="MIDDLE" BORDER=0 ALT="*"><object id="hhal_2" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Index_1sz1>
</object><A STYLE="color:black" HREF=JavaScript:hhal_2.Click()>Index</A>  <IMG SRC="../../../art/arrowrht.gif" WIDTH="14" HEIGHT="14" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black" HREF="introduction.htm#ch_winineto">Topic Contents</A></PRE></TD></TR>
<TR><TD COLSPAN="2"><PRE><IMG SRC="../../../art/arrowlft.gif" WIDTH="17" HEIGHT="15" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" HREF="cookie.htm">Cookie Functions</A>
<IMG SRC="../../../art/arrownxt.gif" WIDTH="17" HEIGHT="16" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A  STYLE="color:black" HREF="appendix_a.htm">Appendix A: HINTERNET Handles</A></PRE></TD></TR>
</TABLE>
<!-- NAV_LINKS_END -->
<BLOCKQUOTE class="body">
<!-- CONTENTS_START -->
<H1>Caching</H1>

<P>The Win32 Internet functions have simple, yet flexible, built-in caching support. Any data retrieved from the network is cached on the hard disk and retrieved for subsequent requests. The application using the Win32 Internet functions can control the caching on each request. For HTTP requests from the server, most headers received are also cached. When an HTTP request is satisfied from the cache, the cached headers are also returned to the caller. This makes data download from Win32 Internet functions seamless, whether it is coming from the cache or from the network.

<P>Unlike previous versions of the Win32 Internet functions, the current and future versions do not have an upper limit on the cache entry size. Applications must properly allocate a buffer in order to get the desired results when using the persistent URL caching functions. For more information, see <A HREF="appendix_b.htm#Using_Buffers">Appendix B: Using Buffers</A>.



<H2><A NAME="Using_Flags_to_Contr">Using Flags to Control Caching</A></H2>
<P>The Win32 Internet function flags allow an application to control when and how it uses the cache. These flags can be used alone or in combination with the <I>dwFlags</I> parameter in functions that access information or resources on the Internet. The Win32 Internet functions store all data downloaded from the Internet by default.

<P>The following flags can be used with the Win32 Internet functions to control caching: 

<TABLE>
<TR><TD>INTERNET_FLAG_DONT_CACHE </TD><TD>Does not cache the data, either locally or in any gateways. Identical to the preferred value, INTERNET_FLAG_NO_CACHE_WRITE.</TD></TR>
<TR><TD>INTERNET_FLAG_HYPERLINK</TD><TD>Forces the application to reload a resource if no expire time and no last-modified time was returned when the resource was stored in the cache.</TD></TR>
<TR><TD>INTERNET_FLAG_MAKE_PERSISTENT</TD><TD>No longer supported.</TD></TR>
<TR><TD>INTERNET_FLAG_MUST_CACHE_REQUEST </TD><TD>Causes a temporary file to be created if the file cannot be cached. Identical to the preferred value, INTERNET_FLAG_NEED_FILE. </TD></TR>
<TR><TD>INTERNET_FLAG_NEED_FILE </TD><TD>Causes a temporary file to be created if the file cannot be cached. </TD></TR>
<TR><TD>INTERNET_FLAG_NO_CACHE_WRITE</TD><TD>Rejects any attempt by the function to store data downloaded from the Internet in the cache. This flag is necessary if the application does not want any downloaded resources to be stored locally. </TD></TR>
<TR><TD>INTERNET_FLAG_OFFLINE</TD><TD>Prevents the application from making requests to the network. All requests are resolved using the resources stored in the cache. If the resource is not in the cache, a suitable error, such as ERROR_FILE_NOT_FOUND, is returned.</TD></TR>
<TR><TD>INTERNET_FLAG_RELOAD</TD><TD>Forces the function to retrieve the requested resource directly from the Internet. The information that is downloaded is stored in the cache.</TD></TR>
<TR><TD>INTERNET_FLAG_RESYNCHRONIZE</TD><TD>Causes an application to perform a conditional download of the resource from the Internet. If the version stored in the cache is current, the information is downloaded from the cache. Otherwise, the information is reloaded from the server.</TD></TR></TABLE>
<H2><A NAME="Persistent_Caching_F">Persistent Caching Functions</A></H2>
<P>Clients that need persistent caching services use the persistent caching functions to allow their applications to save data in the local file system for subsequent use, such as in situations where a low-bandwidth link limits access to the data, or the access is not available at all. The calling program that inserts data into the persistent cache assigns a source name that is used to perform operations, including retrieving, setting and getting some properties, and deleting the data.

<P>The Win32 Internet function protocols use the cache functions to provide persistent caching and offline browsing. Unless the INTERNET_FLAG_NO_CACHE_WRITE flag explicitly specifies no caching, Win32 Internet functions cache all data downloaded from the network. The responses to POST data are not cached.



<H2><A NAME="Using_the_Persistent">Using the Persistent URL Cache Functions</A></H2>
<P>The following persistent URL cache functions allow an application to access and manipulate information stored in the cache.

<TABLE>
<TR><TD><B>Function
 </B></TD><TD><B>Description
</B></TD></TR>
<TR><TD><A HREF="../functions/CommitUrlCacheEntry.htm#CommitUrlCacheEntry">CommitUrlCacheEntry</A> </TD><TD>Caches data in the specified file in the cache storage and associates it with the given URL.</TD></TR>
<TR><TD><A HREF="../functions/CreateUrlCacheEntry.htm#CreateUrlCacheEntry">CreateUrlCacheEntry</A> </TD><TD>Allocates the requested cache storage and creates a local file name for saving the cache entry corresponding to the source name.</TD></TR>
<TR><TD><A HREF="../functions/CreateUrlCacheGroup.htm#CreateUrlCacheGroup">CreateUrlCacheGroup</A> </TD><TD>Generates a cache group identification.</TD></TR>
<TR><TD><A HREF="../functions/DeleteUrlCacheEntry.htm#DeleteUrlCacheEntry">DeleteUrlCacheEntry</A> </TD><TD>Removes the file associated with the source name from the cache, if the file exists.</TD></TR>
<TR><TD><A HREF="../functions/DeleteUrlCacheGroup.htm#DeleteUrlCacheGroup">DeleteUrlCacheGroup</A> </TD><TD>Releases a GROUPID and any associated state in the cache index file.</TD></TR>
<TR><TD><A HREF="../functions/FindCloseUrlCache.htm#FindCloseUrlCache">FindCloseUrlCache</A> </TD><TD>Closes the specified enumeration handle.</TD></TR>
<TR><TD><A HREF="../functions/FindFirstUrlCacheEntry.htm#FindFirstUrlCacheEnt">FindFirstUrlCacheEntry</A> </TD><TD>Begins the enumeration of the cache.</TD></TR>
<TR><TD><A HREF="../functions/FindFirstUrlCacheEntryEx.htm#FindFirstUrlCacheEnt">FindFirstUrlCacheEntryEx</A> </TD><TD>Begins a filtered enumeration of the cache.</TD></TR>
<TR><TD><A HREF="../functions/FindNextUrlCacheEntry.htm#FindNextUrlCacheEntr">FindNextUrlCacheEntry</A> </TD><TD>Retrieves the next entry in the cache.</TD></TR>
<TR><TD><A HREF="../functions/FindNextUrlCacheEntryEx.htm#FindNextUrlCacheEntr">FindNextUrlCacheEntryEx</A> </TD><TD>Retrieves the next entry in a filtered cache enumeration.</TD></TR>
<TR><TD><A HREF="../functions/GetUrlCacheEntryInfo.htm#GetUrlCacheEntryInfo">GetUrlCacheEntryInfo</A> </TD><TD>Retrieves information about a cache entry.</TD></TR>
<TR><TD><A HREF="../functions/GetUrlCacheEntryInfoEx.htm#GetUrlCacheEntryInfo">GetUrlCacheEntryInfoEx</A> </TD><TD>Searches for the URL after translating any cached redirections that would be applied in offline mode by <A HREF="../functions/HttpSendRequest.htm#HttpSendRequest">HttpSendRequest</A>.</TD></TR>
<TR><TD><A HREF="../functions/ReadUrlCacheEntryStream.htm#ReadUrlCacheEntryStr">ReadUrlCacheEntryStream</A> </TD><TD>Reads the cached data from a stream that has been opened using <A HREF="../functions/RetrieveUrlCacheEntryStream.htm#RetrieveUrlCacheEntr">RetrieveUrlCacheEntryStream</A>.</TD></TR>
<TR><TD><A HREF="../functions/RetrieveUrlCacheEntryFile.htm#RetrieveUrlCacheEntr">RetrieveUrlCacheEntryFile</A> </TD><TD>Retrieves a cache entry from the cache in the form of a file.</TD></TR>
<TR><TD><A HREF="../functions/RetrieveUrlCacheEntryStream.htm#RetrieveUrlCacheEntr">RetrieveUrlCacheEntryStream</A> </TD><TD>Provides the most efficient and implementation-independent way of accessing the cache data.</TD></TR>
<TR><TD><A HREF="../functions/SetUrlCacheEntryGroup.htm#SetUrlCacheEntryGrou">SetUrlCacheEntryGroup</A> </TD><TD>Adds or removes entries from a cache group.</TD></TR>
<TR><TD><A HREF="../functions/SetUrlCacheEntryInfo.htm#SetUrlCacheEntryInfo">SetUrlCacheEntryInfo</A> </TD><TD>Sets the specified members of the <A HREF="../structures/INTERNET_CACHE_ENTRY_INFO.htm#INTERNET_CACHE_ENTRY">INTERNET_CACHE_ENTRY_INFO</A> structure.</TD></TR>
<TR><TD><A HREF="../functions/UnlockUrlCacheEntryFile.htm#UnlockUrlCacheEntryF">UnlockUrlCacheEntryFile</A> </TD><TD>Unlocks the cache entry that was locked while the file was retrieved for use from the cache.</TD></TR>
<TR><TD><A HREF="../functions/UnlockUrlCacheEntryStream.htm#UnlockUrlCacheEntryS">UnlockUrlCacheEntryStream</A> </TD><TD>Closes the stream that has been retrieved using <A HREF="../functions/RetrieveUrlCacheEntryStream.htm#RetrieveUrlCacheEntr">RetrieveUrlCacheEntryStream</A>.</TD></TR></TABLE>
<H3><A NAME="Enumerating_the_cach">Enumerating the cache</A></H3>
<P>The <A HREF="../functions/FindFirstUrlCacheEntry.htm#FindFirstUrlCacheEnt">FindFirstUrlCacheEntry</A> and <A HREF="../functions/FindNextUrlCacheEntry.htm#FindNextUrlCacheEntr">FindNextUrlCacheEntry</A> functions enumerate the information stored in the cache. <B>FindFirstUrlCacheEntry</B> starts the enumeration by taking a search pattern, a buffer, and a buffer size to create a handle and return the first cache entry. <B>FindNextUrlCacheEntry</B> takes the handle created by <B>FindFirstUrlCacheEntry</B>, a buffer, and a buffer size to return the next cache entry.

<P>Both functions store an <A HREF="../structures/INTERNET_CACHE_ENTRY_INFO.htm#INTERNET_CACHE_ENTRY">INTERNET_CACHE_ENTRY_INFO</A> structure in the buffer. The size of this structure varies for each entry. If the buffer size passed to either function is insufficient, the function fails and
<object id="hhal_3" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_3.Click()>GetLastError</A> returns ERROR_INSUFFICIENT_BUFFER. The buffer size variable contains the buffer size that was needed to retrieve that cache entry. A buffer of the size indicated by the buffer size variable should be allocated, and the function should be called again with the new buffer.

<P>The <A HREF="../structures/INTERNET_CACHE_ENTRY_INFO.htm#INTERNET_CACHE_ENTRY">INTERNET_CACHE_ENTRY_INFO</A> structure contains the structure size; URL of the cached information; local file name; cache entry type; use count; hit rate; size; last modified, expire, last access, and last synchronized times; header information and header information size; and file extension.

<P><A HREF="../functions/FindFirstUrlCacheEntry.htm#FindFirstUrlCacheEnt">FindFirstUrlCacheEntry</A> takes a search pattern, a buffer that stores the <A HREF="../structures/INTERNET_CACHE_ENTRY_INFO.htm#INTERNET_CACHE_ENTRY">INTERNET_CACHE_ENTRY_INFO</A> structure, and the buffer size. Currently, only the default search pattern, which returns all cache entries, is implemented. 

<P>After the cache is enumerated, the application should call <A HREF="../functions/FindCloseUrlCache.htm#FindCloseUrlCache">FindCloseUrlCache</A> to close the cache enumeration handle.

<P>The following example displays the URL of each entry in the cache into a list box, IDC_CacheList. It uses MAX_CACHE_ENTRY_INFO_SIZE to initially allocate a buffer, since the Microsoft Internet Explorer 3.0 version of WinInet did not enumerate the cache properly otherwise. Internet Explorer 4.0 does enumerate the cache properly and there is no cache size limit. All applications that run on computers with the Internet Explorer 4.0 version of WinInet must allocate a buffer of the size required. For more information, see <A HREF="appendix_b.htm#Using_Buffers">Appendix B: Using Buffers</A>.

<PRE>int WINAPI EnumerateCacheOld(HWND hX)
{
    DWORD dwEntrySize;
    LPINTERNET_CACHE_ENTRY_INFO lpCacheEntry;
    DWORD MAX_CACHE_ENTRY_INFO_SIZE=4096;
    HANDLE hCacheDir;
    int nCount=0;

    SendDlgItemMessage(hX,IDC_CacheList,LB_RESETCONTENT,0,0);


    
    SetCursor(LoadCursor(NULL,IDC_WAIT));

    dwEntrySize = MAX_CACHE_ENTRY_INFO_SIZE;
    lpCacheEntry = (LPINTERNET_CACHE_ENTRY_INFO) new char[dwEntrySize];
    lpCacheEntry-&gt;dwStructSize = dwEntrySize;

again:

    if (!(hCacheDir = FindFirstUrlCacheEntry(NULL,lpCacheEntry,&amp;dwEntrySize)))
    {
        delete[]lpCacheEntry;
        switch(GetLastError())
        {
            case ERROR_NO_MORE_ITEMS: 
                char tempout[80];
                sprintf(tempout,"The number of cache entries = %d \n",nCount);
                MessageBox(hX,tempout,"Cache Enumeration",MB_OK);
                FindCloseUrlCache(hCacheDir);
                SetCursor(LoadCursor(NULL,IDC_ARROW));
                return TRUE;
                break;
                        case ERROR_INSUFFICIENT_BUFFER:
                                lpCacheEntry = (LPINTERNET_CACHE_ENTRY_INFO) 
                                                new char[dwEntrySize];
                                lpCacheEntry-&gt;dwStructSize = dwEntrySize;
                                goto again;
                                break;
                        default:
                                ErrorOut(hX,GetLastError(),"FindNextUrlCacheEntry Init");
                                FindCloseUrlCache(hCacheDir);
                                SetCursor(LoadCursor(NULL,IDC_ARROW));
                                return FALSE;
                }
        }

SendDlgItemMessage(hX,IDC_CacheList,LB_ADDSTRING,
                                0,(LPARAM)(lpCacheEntry-&gt;lpszSourceUrlName));
        nCount++;
        delete (lpCacheEntry);

        do 
        {
                dwEntrySize = MAX_CACHE_ENTRY_INFO_SIZE;
                lpCacheEntry = (LPINTERNET_CACHE_ENTRY_INFO) new char[dwEntrySize];
                lpCacheEntry-&gt;dwStructSize = dwEntrySize;

retry:
                if (!FindNextUrlCacheEntry(hCacheDir,lpCacheEntry, &amp;dwEntrySize))
                {
                        delete[]lpCacheEntry;
                        switch(GetLastError())
                        {
                                case ERROR_NO_MORE_ITEMS: 
                                        char tempout[80];
                                        sprintf(tempout,"The number of cache entries = 
                                                %d \n",nCount);
                                        MessageBox(hX,tempout,"Cache Enumeration",MB_OK);
                                        FindCloseUrlCache(hCacheDir);
                                        return TRUE;
                                        break;
                                case ERROR_INSUFFICIENT_BUFFER:
                                        lpCacheEntry = (LPINTERNET_CACHE_ENTRY_INFO) 
                                                        new char[dwEntrySize];
                                        lpCacheEntry-&gt;dwStructSize = dwEntrySize;
                                        goto retry;
                                        break;
                                default:
                                        ErrorOut(hX,GetLastError(),"FindNextUrlCacheEntry Init");
                                        FindCloseUrlCache(hCacheDir);
                                        return FALSE;
                        }
                }

SendDlgItemMessage(hX,IDC_CacheList,LB_ADDSTRING,
                                        0,(LPARAM)(lpCacheEntry-&gt;lpszSourceUrlName));
                nCount++;
                delete[] lpCacheEntry;

        
        }
        while (TRUE);

        SetCursor(LoadCursor(NULL,IDC_ARROW));
        return TRUE;
        
}
</PRE>
<H3><A NAME="Retrieving_cache_ent">Retrieving cache entry information</A></H3>
<P>The <A HREF="../functions/GetUrlCacheEntryInfo.htm#GetUrlCacheEntryInfo">GetUrlCacheEntryInfo</A> function allows you to retrieve the <A HREF="../structures/INTERNET_CACHE_ENTRY_INFO.htm#INTERNET_CACHE_ENTRY">INTERNET_CACHE_ENTRY_INFO</A> structure for the specified URL. This structure contains the structure size; URL of the cached information; local file name; cache entry type; use count; hit rate; size; last modified, expire, last access, and last synchronized times; header information and header information size; and file extension.

<P><A HREF="../functions/GetUrlCacheEntryInfo.htm#GetUrlCacheEntryInfo">GetUrlCacheEntryInfo</A> accepts a URL, a buffer for an <A HREF="../structures/INTERNET_CACHE_ENTRY_INFO.htm#INTERNET_CACHE_ENTRY">INTERNET_CACHE_ENTRY_INFO</A> structure, and the buffer size. If the URL is found, the information is copied into the buffer. Otherwise, the function fails and
<object id="hhal_4" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_4.Click()>GetLastError</A> returns ERROR_FILE_NOT_FOUND. If the buffer size is insufficient to store the cache entry information, the function fails and <B>GetLastError</B> returns ERROR_INSUFFICIENT_BUFFER. The size required to retrieve the information is stored in the buffer size variable.

<P><A HREF="../functions/GetUrlCacheEntryInfo.htm#GetUrlCacheEntryInfo">GetUrlCacheEntryInfo</A> does not do any URL parsing, so a URL containing an anchor (#) will not be found in the cache, even if the resource is cached. For example, if the URL, http://example.com/example.htm#sample, was passed, the function would return ERROR_FILE_NOT_FOUND even if http://example.com/example.htm is in the cache.

<P>The following example retrieves the cache entry information for the specified URL. The function then displays the header information in the IDC_CacheDump edit box.

<PRE>int WINAPI GetCacheEntryInfo(HWND hX,LPSTR lpszUrl)
{
        DWORD dwEntrySize=0;
        LPINTERNET_CACHE_ENTRY_INFO lpCacheEntry;

        char strTemp[80];
        DWORD dwTemp;

        SetCursor(LoadCursor(NULL,IDC_WAIT));
        if (!GetUrlCacheEntryInfo(lpszUrl,NULL,&amp;dwEntrySize))
        {
                if (GetLastError()!=ERROR_INSUFFICIENT_BUFFER)
                {
                        ErrorOut(hX,GetLastError(),"GetUrlCacheEntryInfo");
                        SetCursor(LoadCursor(NULL,IDC_ARROW));
                        return FALSE;
                }
                else
                        lpCacheEntry = (LPINTERNET_CACHE_ENTRY_INFO) 
                                        new char[dwEntrySize];
        }
        else
                return FALSE;    //should not be successful w/ NULL buffer and 0 size.

        if (!GetUrlCacheEntryInfo(lpszUrl,lpCacheEntry,&amp;dwEntrySize))
        {
                ErrorOut(hX,GetLastError(),"GetUrlCacheEntryInfo");
                SetCursor(LoadCursor(NULL,IDC_ARROW));
                return FALSE;
        }
        else
        {
                if ((lpCacheEntry-&gt;dwHeaderInfoSize)!=0)
                {
                        LPSTR(lpCacheEntry-&gt;lpHeaderInfo)[lpCacheEntry-&gt;dwHeaderInfoSize]='\0';
                        SetDlgItemText(hX,IDC_Headers,LPSTR(lpCacheEntry-&gt;lpHeaderInfo));
                }
                else
                {
                        SetDlgItemText(hX,IDC_Headers,"None");
                }

SetCursor(LoadCursor(NULL,IDC_ARROW));
                return TRUE;
        }
        
}
</PRE>
<H3><A NAME="Cache_Entry">Creating a cache entry</A></H3>
<P>An application uses the <A HREF="../functions/CreateUrlCacheEntry.htm#CreateUrlCacheEntry">CreateUrlCacheEntry</A> and <A HREF="../functions/CommitUrlCacheEntry.htm#CommitUrlCacheEntry">CommitUrlCacheEntry</A> functions to create a cache entry.

<P><A HREF="../functions/CreateUrlCacheEntry.htm#CreateUrlCacheEntry">CreateUrlCacheEntry</A> accepts the URL, expected file size, and file extension. The function then creates a local file name for saving the cache entry corresponding to the URL and file extension. 

<P>Using the local file name, write the data into the local file using standard C/C++ functions or Win32 functions. After the data has been written to the local file, the application should call <A HREF="../functions/CommitUrlCacheEntry.htm#CommitUrlCacheEntry">CommitUrlCacheEntry</A>.

<P><A HREF="../functions/CommitUrlCacheEntry.htm#CommitUrlCacheEntry">CommitUrlCacheEntry</A> accepts the URL; local file name; expire and last modified times; cache entry type; header information and header information size; and file extension. The function then caches data in the file specified in the cache storage and associates it with the given URL.

<P>The following example uses the local file name, created by a previous call to <A HREF="../functions/CreateUrlCacheEntry.htm#CreateUrlCacheEntry">CreateUrlCacheEntry</A>, stored in the text box, IDC_LocalFile, to store the text from the text box, IDC_CacheDump, in the cache entry. After the data has been written to the file using <B>fopen</B>, <B>fprintf</B>, and <B>fclose</B>, the entry is committed using <A HREF="../functions/CommitUrlCacheEntry.htm#CommitUrlCacheEntry">CommitUrlCacheEntry</A>.

<PRE>int WINAPI CommitEntry(HWND hX)
{
        LPSTR lpszUrl, lpszExt, lpszFileName;
        LPSTR lpszData,lpszSize;
        DWORD dwSize;
        DWORD dwEntryType=0;
        FILE *lpfCacheEntry;
        LPFILETIME lpdtmExpire, lpdtmLastModified;
        LPSYSTEMTIME lpdtmSysTime;

        if(SendDlgItemMessage(hX,IDC_RBNormal,BM_GETCHECK,0,0))
                dwEntryType = dwEntryType + NORMAL_CACHE_ENTRY;
        else
                if(SendDlgItemMessage(hX,IDC_RBStable, BM_GETCHECK,0,0))
                        dwEntryType = dwEntryType + STABLE_CACHE_ENTRY;
                else
                        if(SendDlgItemMessage(hX,IDC_RBSticky, BM_GETCHECK,0,0))
                                dwEntryType = dwEntryType + STICKY_CACHE_ENTRY;
                        else
                                if(SendDlgItemMessage(hX,IDC_RBSparse, BM_GETCHECK,0,0))
                                        dwEntryType = dwEntryType + SPARSE_CACHE_ENTRY;

        if(SendDlgItemMessage(hX,IDC_RBOCX, BM_GETCHECK,0,0))
                dwEntryType = dwEntryType + OCX_CACHE_ENTRY;
        else
                if(SendDlgItemMessage(hX,IDC_RBCookie, BM_GETCHECK,0,0))
                        dwEntryType = dwEntryType + COOKIE_CACHE_ENTRY;
                else
                        if(SendDlgItemMessage(hX,IDC_RBUrl, BM_GETCHECK,0,0))
                                dwEntryType = dwEntryType + URLHISTORY_CACHE_ENTRY;

        if(SendDlgItemMessage(hX,IDC_RBNone, BM_GETCHECK,0,0))
        {
                dwEntryType=0;
        }
        

        lpdtmSysTime = new SYSTEMTIME;
        lpdtmExpire = new FILETIME;
        lpdtmLastModified = new FILETIME;

        GetLocalTime(lpdtmSysTime);
        SystemTimeToFileTime(lpdtmSysTime,lpdtmExpire);
        SystemTimeToFileTime(lpdtmSysTime,lpdtmLastModified);
        delete(lpdtmSysTime);

        lpszUrl = new char[MAX_PATH];
        lpszFileName = new char[MAX_PATH];
        lpszExt = new char[5];
        lpszSize = new char[10];

        GetDlgItemText(hX,IDC_SourceURL,lpszUrl,MAX_PATH);
        GetDlgItemText(hX,IDC_LocalFile,lpszFileName,MAX_PATH);
        GetDlgItemText(hX,IDC_FileExt,lpszExt,5);

        GetDlgItemText(hX,IDC_SizeLow,lpszSize,5);
        dwSize = (DWORD)atol(lpszSize);
        delete(lpszSize);

        if (dwSize==0)
        {
                if((MessageBox(hX,"Incorrect File Size.\nUsing 8000 characters, Okay?\n",
                        "Commit Entry",MB_YESNO))==IDYES)
                {
                        dwSize = 8000;
                }
                else
                {
                        return FALSE;
                }
        }

        lpszData = new char[dwSize];
        GetDlgItemText(hX,IDC_CacheDump,lpszData,dwSize);
        
        lpfCacheEntry = fopen(lpszFileName,"w");
        fprintf(lpfCacheEntry,"%s",lpszData);
        fclose(lpfCacheEntry);
        delete(lpszData);

        if (!CommitUrlCacheEntry(lpszUrl, lpszFileName, *lpdtmExpire,
                *lpdtmLastModified, dwEntryType,NULL,0,lpszExt,0))
        {
                ErrorOut(hX,GetLastError(),"Commit Cache Entry");
                delete(lpszUrl);
                delete(lpszFileName);
                delete(lpszExt);
                delete(lpdtmExpire);
                delete(lpdtmLastModified);
                return FALSE;
        }
        else
        {
                delete(lpszUrl);
                delete(lpszFileName);
                delete(lpszExt);
                delete(lpdtmExpire);
                delete(lpdtmLastModified);
                return TRUE;
        }
}
</PRE>
<H3><A NAME="Deleting_a_cache_ent">Deleting a cache entry</A></H3>
<P>The <A HREF="../functions/DeleteUrlCacheEntry.htm#DeleteUrlCacheEntry">DeleteUrlCacheEntry</A> function takes a URL and removes the cache file associated with it. If the cache file does not exist, the function fails and
<object id="hhal_5" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_5.Click()>GetLastError</A> returns ERROR_FILE_NOT_FOUND. If the cache file is currently locked or in use, the function fails and <B>GetLastError</B> returns ERROR_ACCESS_DENIED, and the file will be deleted when unlocked.



<H3><A NAME="Retrieving_a_cache_e">Retrieving a cache entry stream</A></H3>
<P><A HREF="../functions/RetrieveUrlCacheEntryStream.htm#RetrieveUrlCacheEntr">RetrieveUrlCacheEntryStream</A>, <A HREF="../functions/ReadUrlCacheEntryStream.htm#ReadUrlCacheEntryStr">ReadUrlCacheEntryStream</A>, and <A HREF="../functions/UnlockUrlCacheEntryStream.htm#UnlockUrlCacheEntryS">UnlockUrlCacheEntryStream</A> retrieve the resources stored in the cache.

<P><A HREF="../functions/RetrieveUrlCacheEntryStream.htm#RetrieveUrlCacheEntr">RetrieveUrlCacheEntryStream</A> accepts a URL, a buffer that stores the <A HREF="../structures/INTERNET_CACHE_ENTRY_INFO.htm#INTERNET_CACHE_ENTRY">INTERNET_CACHE_ENTRY_INFO</A> structure, the buffer size, and a Boolean value to determine if random reads are allowed. If the cache file is found, the function then creates a handle to the file.

<P><A HREF="../functions/RetrieveUrlCacheEntryStream.htm#RetrieveUrlCacheEntr">RetrieveUrlCacheEntryStream</A> does not do any URL parsing, so a URL containing an anchor (#) will not be found in the cache, even if the resource is cached. For example, if the URL, http://example.com/example.htm#sample, was passed, the function would return ERROR_FILE_NOT_FOUND even if http://example.com/example.htm is in the cache.

<P><A HREF="../functions/ReadUrlCacheEntryStream.htm#ReadUrlCacheEntryStr">ReadUrlCacheEntryStream</A> uses the handle created by <A HREF="../functions/RetrieveUrlCacheEntryStream.htm#RetrieveUrlCacheEntr">RetrieveUrlCacheEntryStream</A>, a file offset, a buffer, and a buffer size variable. If the buffer size is insufficient to hold the amount of data available, the function fails and
<object id="hhal_6" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_6.Click()>GetLastError</A> returns ERROR_INSUFFICIENT_BUFFER. The buffer size variable is set to the size necessary to download the resource.

<P>After the cache file is retrieved, the application must call <A HREF="../functions/UnlockUrlCacheEntryStream.htm#UnlockUrlCacheEntryS">UnlockUrlCacheEntryStream</A> to close the handle that was created by <A HREF="../functions/RetrieveUrlCacheEntryStream.htm#RetrieveUrlCacheEntr">RetrieveUrlCacheEntryStream</A>.

<P>The following example retrieves the information stored in the cache entry for the specified URL. The function displays text resources in the IDC_CacheDump edit box. Other resources are not displayed.

<PRE>int WINAPI RetrieveStream(HWND hX, LPSTR lpszUrl)
{
    LPINTERNET_CACHE_ENTRY_INFO lpCacheEntry;
    DWORD dwEntrySize=0,dwStreamSize=0;
    HANDLE hStream;
    LPSTR lpszOut;

    RetrieveUrlCacheEntryStream(lpszUrl,NULL, &amp;dwEntrySize, TRUE, 0);
    lpCacheEntry = LPINTERNET_CACHE_ENTRY_INFO(new char[dwEntrySize]);
    if (!(hStream = RetrieveUrlCacheEntryStream(lpszUrl,lpCacheEntry, 
        &amp;dwEntrySize, TRUE, 0)))
    {
        ErrorOut(hX,GetLastError(),"RetrieveUrlCacheEntryStream");
        return FALSE;
    }
    else
    {
        dwStreamSize = lpCacheEntry-&gt;dwSizeLow;
        lpszOut = new char[dwStreamSize];
        if (!ReadUrlCacheEntryStream(hStream,0,LPVOID(lpszOut),&amp;dwStreamSize,
            0))
        {
            ErrorOut(hX,GetLastError(),"ReadUrlCacheEntryStream");
            return FALSE;
        }
        else
        {
            lpszOut[dwStreamSize]='\0';
            SetDlgItemText(hX,IDC_CacheDump,lpszOut);
            return TRUE;
        }
    }

    delete (lpCacheEntry);
    delete (lpszOut);
    
    if (!UnlockUrlCacheEntryStream(hStream,0))
    {
        ErrorOut(hX,GetLastError(),"UnlockUrlCacheEntryStream");
        return FALSE;
    }
    else
        return TRUE;
}
</PRE>
<H3><A NAME="Retrieving_cache_ent">Retrieving cache entry files</A></H3>
<P>For applications that require the file name of a resource in order to launch, the Win32 Internet API provides the <A HREF="../functions/RetrieveUrlCacheEntryFile.htm#RetrieveUrlCacheEntr">RetrieveUrlCacheEntryFile</A> and <A HREF="../functions/UnlockUrlCacheEntryFile.htm#UnlockUrlCacheEntryF">UnlockUrlCacheEntryFile</A> functions. Applications that do not require the file name should use the <A HREF="../functions/RetrieveUrlCacheEntryStream.htm#RetrieveUrlCacheEntr">RetrieveUrlCacheEntryStream</A>, <A HREF="../functions/ReadUrlCacheEntryStream.htm#ReadUrlCacheEntryStr">ReadUrlCacheEntryStream</A>, and <A HREF="../functions/UnlockUrlCacheEntryStream.htm#UnlockUrlCacheEntryS">UnlockUrlCacheEntryStream</A> functions to retrieve the information in the cache.

<P><A HREF="../functions/RetrieveUrlCacheEntryStream.htm#RetrieveUrlCacheEntr">RetrieveUrlCacheEntryStream</A> does not do any URL parsing, so a URL containing an anchor (#) will not be found in the cache, even if the resource is cached. For example, if the URL, http://example.com/example.htm#sample, was passed, the function would return ERROR_FILE_NOT_FOUND even if http://example.com/example.htm is in the cache.

<P><A HREF="../functions/RetrieveUrlCacheEntryFile.htm#RetrieveUrlCacheEntr">RetrieveUrlCacheEntryFile</A> accepts a URL, a buffer that stores the <A HREF="../structures/INTERNET_CACHE_ENTRY_INFO.htm#INTERNET_CACHE_ENTRY">INTERNET_CACHE_ENTRY_INFO</A> structure, and the buffer size. The function is retrieved and locked for the caller.

<P>After the information in the file has been used, the application should call <A HREF="../functions/UnlockUrlCacheEntryFile.htm#UnlockUrlCacheEntryF">UnlockUrlCacheEntryFile</A> to unlock the file.



<H3><A NAME="Cache_groups">Cache groups</A></H3>
<P>Support for cache groups has been added to the Win32 Internet functions. To create a cache group, the <A HREF="../functions/CreateUrlCacheGroup.htm#CreateUrlCacheGroup">CreateUrlCacheGroup</A> function must be called to generate a GROUPID for the cache group. Entries can be added to the cache group by supplying the cache entry's URL and the INTERNET_CACHE_GROUP_ADD flag to the <A HREF="../functions/SetUrlCacheEntryGroup.htm#SetUrlCacheEntryGrou">SetUrlCacheEntryGroup</A> function. To remove a cache entry from a group, pass the cache entry's URL and the INTERNET_CACHE_GROUP_REMOVE flag to <B>SetUrlCacheEntryGroup</B>.

<P>The <A HREF="../functions/FindFirstUrlCacheEntryEx.htm#FindFirstUrlCacheEnt">FindFirstUrlCacheEntryEx</A> and <A HREF="../functions/FindNextUrlCacheEntryEx.htm#FindNextUrlCacheEntr">FindNextUrlCacheEntryEx</A> functions can be used to enumerate the entries in a specified cache group. After the enumeration is complete, the function should call <A HREF="../functions/FindCloseUrlCache.htm#FindCloseUrlCache">FindCloseUrlCache</A>.



<!-- ************************ BRADYA: BEGIN UPDATE ************************ -->
<H2><A NAME="Handling_Structures_">Handling Structures with Variable Size Information</A></H2>
<P>The cache can contain variable size information for each URL stored. This is reflected in the <A HREF="../structures/INTERNET_CACHE_ENTRY_INFO.htm#INTERNET_CACHE_ENTRY">INTERNET_CACHE_ENTRY_INFO</A> structure. When the cache functions return this structure, they create a buffer that is always the size of <B>INTERNET_CACHE_ENTRY_INFO</B> plus any variable size information. If a pointer member is not NULL, it points to the memory area immediately after the structure. While copying the returned buffer from a function into another buffer, the pointer members should be fixed to point to the appropriate place in the new buffer, as the following example shows.

<PRE>lpDstCEInfo-&gt;lpszSourceUrlName = 
    (LPINTERNET_CACHE_ENTRY_INFO) ((LPBYTE) lpSrcCEInfo + 
        ((DWORD) (lpOldCEInfo-&gt;lpszSourceUrlName) - (DWORD) lpOldCEInfo))
</PRE>
<P>Some cache functions fail with the ERROR_INSUFFICIENT_BUFFER error message if you specify a buffer that is too small to contain the cache-entry information retrieved by the function. In this case, the function also returns the required size of the buffer. You can then allocate a buffer of the appropriate size and call the function again. 






<!-- CONTENTS_END -->
<!-- START PAGE FOOTER -->
<H6><HR size=1></H6>
<P><A ID=line HREF="#pagetop"><IMG src="../../../art/arrowup1.gif" WIDTH="17" HEIGHT="16" ALIGN="MIDDLE" BORDER="0" ALT="Up">&nbsp;Top of Page</A>
<BR><A ID=line HREF="http://www.microsoft.com/misc/cpyright.htm" TARGET="_top">&#169; 1997 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END PAGE FOOTER -->
</BLOCKQUOTE>
</BODY>
</HTML>