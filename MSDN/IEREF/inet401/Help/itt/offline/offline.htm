<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Offline Browsing</TITLE>

<META NAME=MS-HKWD CONTENT="Offline Browsing">
<META NAME="Keywords" CONTENT="Internet Tools & Technologies">
<META NAME="Platform" CONTENT="Windows, Win95, WinNT, Mac">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">


<SCRIPT>
//<!--
var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";
// -->
</SCRIPT>
<SCRIPT SRC="../../code/ver.js"></SCRIPT>


<SCRIPT DEFER SRC="../../code/common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
	if (g_isIE && g_iMaj >= 4)	
	{
		SetTOC();
	}
}
//-->
</SCRIPT>

<LINK REL="stylesheet" HREF="/msdn/sdk/inetsdk/help/basicsdkIE4.css" TYPE="text/css">
<!-- STYLE_START -->


<SCRIPT>
//<!--
   var sVR = '../../'	// Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
	   if (g_iMaj >= 4) // For MSIE 4.0 or later
	   {
		   sCSS += 'basicSDKIE4';
		   if (g_sPlat == "Win") // Windows only for now
		   {
			   document.createStyleSheet(sVR + 'advSDKIE4.css');
		   }
	   }
	   else // For MSIE 3.0 or earlier
	   {
		   sCSS += 'basicSDKIE3';
	   }
   }
   else if (g_isNav) // For all Nav versions
   {
	   sCSS += 'basicSDKNAV';
   }
   else
   {
	   sCSS += 'basicSDKIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->
</SCRIPT>
<!-- STYLE_END -->
</HEAD>
<BODY onload="InitPage()" BGCOLOR="#FFFFFF">

<A NAME="pagetop"></A><A NAME="bk_offline"></A>
<!-- NAV_LINKS_START -->
<TABLE class=main BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="10%"><TR><TD ROWSPAN="3" VALIGN="TOP" WIDTH="121"><IMG SRC="../../art/headbar2.gif" WIDTH="121" HEIGHT="82" BORDER=0 ALT="Offline Browsing"></TD><TD ROWSPAN="2" VALIGN="TOP" WIDTH="186"><IMG SRC="../../art/headbard.gif" WIDTH="186" HEIGHT="44" BORDER=0 ALT="Offline Browsing"></TD><TD VALIGN="TOP" WIDTH="470"><IMG SRC="../../art/replace1.gif" WIDTH="470" HEIGHT="17" BORDER=0 ALT="*"></TD></TR>
<TR><TD><PRE><IMG SRC="../../art/arrowrht.gif" WIDTH="14" HEIGHT="14" ALIGN="MIDDLE" BORDER=0 ALT="*"><object id="hhal_1" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Contents>
</object><A STYLE="color:black" ID=TOC HREF=JavaScript:hhal_1.Click()>Contents</A>  <IMG SRC="../../art/arrowrht.gif" WIDTH="14" HEIGHT="14" ALIGN="MIDDLE" BORDER=0 ALT="*"><object id="hhal_2" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Index_1sz1>
</object><A STYLE="color:black" HREF=JavaScript:hhal_2.Click()>Index</A>  <IMG SRC="../../art/arrowrht.gif" WIDTH="14" HEIGHT="14" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black" HREF="../internet.htm#set_internet_tools">Topic Contents</A></PRE></TD></TR>
<TR><TD COLSPAN="2"><PRE><IMG SRC="../../art/arrowlft.gif" WIDTH="17" HEIGHT="15" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" HREF="../shortcuts/reference/URLINVOKECOMMANDINFO.htm">URLINVOKECOMMANDINFO</A>
<IMG SRC="../../art/arrownxt.gif" WIDTH="17" HEIGHT="16" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A  STYLE="color:black" HREF="../osd/osd.htm">Open Software Description (OSD)</A></PRE></TD></TR>
</TABLE>
<!-- NAV_LINKS_END -->
<BLOCKQUOTE class="body">
<!-- CONTENTS_START -->
<H1>Offline Browsing</H1>

<H2><A NAME="ch_offlinebrowsing">Supporting Offline Browsing in Applications and Components</A></H2>
<P>To further provide users with the best browsing experience, Internet Explorer 4.0 introduces offline browsing to the Win32 platform. Offline browsing allows users to view Web pages from the cache, a local repository of files gathered from the Web through normal browsing and the delivery of content subscriptions.
<P><A CLASS=tctop HREF="offline.htm#ch_offlineax_global"><IMG SRC="../../art/arrowy.gif" WIDTH="6" HEIGHT="11" BORDER=0 ALT="arrowy.gif">Understanding the Global Offline State</A><BR>
<P><A CLASS=tctop HREF="offline.htm#Application_Developm"><IMG SRC="../../art/arrowy.gif" WIDTH="6" HEIGHT="11" BORDER=0 ALT="arrowy.gif">Application Development Considerations for Offline Browsing</A><BR>
<P><A CLASS=tctop HREF="offline.htm#Offline_Consideratio"><IMG SRC="../../art/arrowy.gif" WIDTH="6" HEIGHT="11" BORDER=0 ALT="arrowy.gif">Offline Considerations for Component Developers</A><BR>
<P><A CLASS=tctop HREF="offline.htm#Considering_Backward"><IMG SRC="../../art/arrowy.gif" WIDTH="6" HEIGHT="11" BORDER=0 ALT="arrowy.gif">Considering Backward Compatibility</A><BR>
<P><A CLASS=tctop HREF="offline.htm#Conclusion"><IMG SRC="../../art/arrowy.gif" WIDTH="6" HEIGHT="11" BORDER=0 ALT="arrowy.gif">Conclusion</A><BR>
<H3><A NAME="ch_offlineax_global">Understanding the Global Offline State</A></H3>
<P>In conjunction with this feature, users can choose to work offline by selecting the corresponding menu item from the File menu in Internet Explorer 4.0. 

<P><IMG SRC="../../art/workoff.gif" WIDTH="280" HEIGHT="64" ALT="Work Offline" >

<P>Once this item is selected, the system enters a global offline state independent of any current network connection, and content is read exclusively from the cache. If the content is not available locally, Internet Explorer 4.0 prompts the user to go online or to continue working offline.

<P><IMG SRC="../../art/goonline.gif" WIDTH="306" HEIGHT="197" ALT="Work Offline" >

<P>The following document describes the API elements that enable third-party developers to hook into the offline browsing architecture. It also provides some recommendations to developers to help them provide a seamless experience to users.

<H3><A NAME="Application_Developm">Application Development Considerations for Offline Browsing</A></H3>
<P>At the core of Internet Explorer 4.0 is URLMON.DLL and WININET.DLL. These DLLs handle all low-level requests made by the browser for Internet resources. Using the <A HREF="../wininet/wininet.htm#book_wininet">WININET</A> and <A HREF="../monikers/monikers.htm#book_monikers">URLMON</A> APIs, developers targeting Internet, Intranet, and Extranet environments can easily contribute to a positive offline browsing experience.

<H4><A NAME="Determining_the_Glob">Determining the Global Offline State</A></H4>
<P>Internet Explorer 4.0 uses URL Monikers which in turn uses the WININET API to perform all network requests including URL navigation and caching. WININET automatically checks the global offline state before making a resource request. If the system is globally offline, WININET attempts to retrieve the resource exclusively from the cache. If the resource is present, the request succeeds. Otherwise, the request fails. If the request fails, Internet Explorer 4.0 checks if the user is in the global offline state. An application can use the WININET <A HREF="../wininet/functions/InternetQueryOption.htm#InternetQueryOption">InternetQueryOption</A> function to check the global offline state.

<PRE>
   // Returns true if the global state is offline. Otherwise, false. 
   BOOL IsGlobalOffline(void)
   {
      DWORD dwState = 0, dwSize = sizeof(DWORD);
      BOOL fRet = FALSE;

      if(InternetQueryOption(NULL, 
         INTERNET_OPTION_CONNECTED_STATE, &amp;dwState,
         &amp;dwSize))
      {
         if(dwState &amp; INTERNET_STATE_DISCONNECTED_BY_USER)
            fRet = TRUE;
      }
      return fRet; 
   }
</PRE>
<P>If the user explicitly chooses to navigate to unavailable content, Internet Explorer uses the WININET <A HREF="../wininet/functions/InternetGoOnline.htm#InternetGoOnline">InternetGoOnline</A> function to present the user with a dialog box that allows the user to "Connect" or "Stay Offline." If "Connect" is chosen, the function invokes <B>InternetAutoDial</B>. This function attempts to establish a network connection and, upon success, takes the system out of global offline mode. If <B>InternetGoOnline</B> succeeds, the system is connected and globally online. An application can then make the request for the resource again. 

<P>Here's some code that demonstrates the overall logic:

<PRE>
   // Cache the Internet handle if not already available.
   DWORD dwAccessType = INTERNET_OPEN_TYPE_PRECONFIG;
   DWORD dwInetOpenFlags = 0;

   hInternet = InternetOpen(
         "007",
         dwAccessType,
         NULL,
         NULL,
         dwInetOpenFlags); 

   hFile = InternetOpenUrl(
         hInternet,
         szURL,
         NULL, 0, 0, 0);

   if (!hFile)
   {
      if (IsGlobalOffline())
      {
         // If globally offline, ask the user for permission to go online.
         if (InternetGoOnline(szURL, g_hwnd, INTERENT_GOONLINE_REFRESH))
         {
            // try again now that we're online
            hFile = InternetOpenUrl(
               hInternet,
               szURL,
               NULL, 0, 0, 0);
            if (!hFile)
            {
               InternetCloseHandle(hInternet);
               return;
            }
      }
   }
</PRE>
<P>If the user chooses to go online and the second request fails, the resource simply may not exist as is the case when a user specifies a bad URL in the address bar or clicks on a stale hyperlink.

<H4><A NAME="Detecting_if_Content">Detecting if Content is Locally Available</A></H4>
<P>While it is essential that the user be presented with a dialog box before they are taken out of global offline mode, applications should make every effort to avoid bothering the user unnecessarily. When the user is viewing hyperlinks on a page, Internet Explorer 4.0 provides the user with a visual indicator, a small crossed-out circle attached to the cursor known as the offline hand, to indicate that the content is not available in the cache. 

<P><IMG SRC="../../art/nocache.gif" WIDTH="59" HEIGHT="34" ALT="Not in Cache" >

<P>By recognizing this cursor, the user is given the chance to preempt the "go online" dialog box. The following code can be used to determine if the content at a specified address is available locally.

<PRE>
   BOOL IsAvailableOffline(LPCWSTR wszUrl)
   {
      HRESULT hr;
      DWORD   dwUsesNet, dwCached;
      DWORD   dwSize;

      if (!wszUrl)
        return E_INVALIDARG;
    
      // First, let URLMON check the protocol scheme.
      hr = CoInternetQueryInfo(wszUrl, 
            QUERY_USES_NETWORK,
            0,
            &amp;dwUsesNet,
            sizeof(dwUsesNet),
            &amp;dwSize,
            0);
   
      if (FAILED(hr) || !dwUsesNet)
         return true;

      // Then let URLMON peek in the cache.
      hr = CoInternetQueryInfo(wszUrl,
            QUERY_IS_CACHED_OR_MAPPED,
            0,
            &amp;dwCached,
            sizeof(dwCached),
            &amp;dwSize,
            0);

      if (FAILED(hr))
        return false;

      return dwCached;
   }
</PRE>
<P>The offline hand is a cursor resource in <A HREF="../ieprog/IEProg.htm#book_browsing">SHDOCVW.DLL</A>. The following code demonstrates how to load and display the cursor:

<PRE>
   HINSTANCE hInst = LoadLibrary("shdocvw.dll");
   hCursor = (HCURSOR)LoadCursor(hInst, 
      MAKEINTRESOURCE(IDC_OFFLINE_HAND));
   if (hCursor)
      SetCursor(hCursor);
</PRE>
<H4><A NAME="Setting_the_Global_O">Setting the Global Offline Mode</A></H4>
<P>A third-party can use the API elements presented above or implement their own. Given the user's explicit permission, here is how an application or component can change the offline mode of the system:

<PRE>
   void SetGlobalOffline(BOOL fGoOffline)
   {
      INTERNET_CONNECTED_INFO ci;

      memset(&amp;ci, 0, sizeof(ci));
      if(fGoOffline) 
      {
         ci.dwConnectedState = INTERNET_STATE_DISCONNECTED_BY_USER;
         ci.dwFlags = ISO_FORCE_DISCONNECTED;
      } 
      else 
     {
        ci.dwConnectedState = INTERNET_STATE_CONNECTED;
     }

     InternetSetOption(NULL, 
         INTERNET_OPTION_CONNECTED_STATE, &amp;ci, sizeof(ci));
   }
</PRE>
<P>Typically, only application developers should attempt to manipulate the global offline state. Just as applications should minimize the interruption of the user's experience, component developers should focus upon seamless integration into their container's UI. The following section discusses how a specialized container, the Active Desktop, enables components to provide consistent behavior with minimal additional implementation requirements.

<H3><A NAME="Offline_Consideratio">Offline Considerations for Component Developers</A></H3>
<P>Internet Explorer 4.0 turns the user's desktop into a Web page by introducing the Active Desktop. Users can can <A HREF="../../delivery/authoring/desktop_items.htm#ch_ad_components">add any content</A> viewable in the browser as an item to the Active Desktop using the Web tab of the system's Display property sheet. Programmatically, Active Desktop items can be added using the <A HREF="../activedesktop/ifaces/iactivedesktop/IActiveDesktop.htm#IActiveDesktop">IActiveDesktop</A> interface. Custom components such as ActiveX controls and Java applets can be integrated into the Active Desktop by embedding them in content inserted into the Active Desktop.

<P>Since the majority of users does not have a persistent connection to a network, components used as Active Desktop items should not make network requests when the user first logs in. A system configured for dialup use that is not in global offline mode will automatically present dialer UI or incur unexpected dial-up charges each time the user logs in. A control that ignores this recommendation will quickly lose popularity with users.


<P><IMG SRC="../../art/dialup.gif" WIDTH="282" HEIGHT="392" ALT="Dialer UI" >

<H4><A NAME="Understanding_the_Of">Understanding the Offline Ambient</A></H4>
<P>The discussion regarding the <B>global offline state</B> makes it clear that applications and components that make calls through URLMON and WININET need not add any special flags to their requests to achieve offline behavior. Since the global offline state is an integral part of these low-level components, no attempt will be made to access the net when the system is globally offline. When the system is not globally offline, however, a network-aware component must consider the case where the system is disconnected from the Internet.

<P>To help components that access network resources exhibit desirable behavior when embedded in the Active Desktop, Internet Explorer 4.0 introduces a new ambient property with a dispatch ID of DISPID_AMBIENT_OFFLINEIFNOTCONNECTED. Before attempting any network requests, an ActiveX control should retrieve the value of this ambient. If the ambient property is true, a component should check the connection state of the system using the WININET <A HREF="../wininet/functions/InternetGetConnectedState.htm#InternetGetConnected">InternetGetConnectedState</A> function. If the function indicates that the computer is disconnected, the control should add the appropriate offline flag in its requests to URLMON and WININET. This will prevent these APIs from displaying dialer UI. Note that a component is free to check the connected state and act appropriately regardless of the container in which they are embedded.

<H4><A NAME="Detecting_the_Offlin">Detecting the Offline Ambient</A></H4>
<P>A control need only retrieve the property once at initialization time through the
<object id="hhal_3" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_3.Click()>IDispatch</A> interface exposed by the container's client site. A control detects additional changes to all ambients via its implementation of <B>IOleControl::OnAmbientPropertyChange</B>. The following code shows how a control built using the Active Template Library (ATL) might implement this:

<PRE>
   #include &lt;idispids.h&gt;

   // Cache the container's OFFLINEIFNOTCONNECTED ambient. 
   HRESULT GetAmbientOffline(LPUNKNOWN pUnkContainer, 
              BOOL* pfAmbientOffline)
   {
      HRESULT hr;

      if (!pfAmbientOffline || !pUnkContainer) 
         return E_INVALIDARG;

      *pfAmbientOffline = false;

      // Obtain container OA interface through its client site.
      CComQIPtr&lt;IDispatch, &amp;IID_IDispatch&gt; spDisp(pUnkContainer);

&#009;DISPPARAMS dispParams = {NULL, NULL, 0, 0};
&#009;VARIANT vResult = {0};
&#009;hr = spDisp-&gt;Invoke( 
&#009;&#009;DISPID_AMBIENT_OFFLINEIFNOTCONNECTED,
&#009;&#009;IID_NULL,
&#009;&#009;0,
&#009;&#009;DISPATCH_PROPERTYGET,
&#009;&#009;&amp;dispParams,
&#009;&#009;&amp;vResult,
&#009;&#009;NULL,
&#009;&#009;NULL);

&#009;if (SUCCEEDED(hr))
&#009;{
         // Cache the value in a member variable.
         *pfAmbientOffline = 
            (VARIANT_TRUE == V_BOOL(&amp;vResult) ? true : false);

&#009;   VariantClear(&amp;vResult);
       }
&#009;return hr;
   }

   // Implementation of IObjectWithSite::SetSite:
   // Mostly delegates to ATL's default implementation
   // but additionally retrieves the ambient.
   STDMETHODIMP CAxOffl::SetSite(LPUNKNOWN pUnkSite)
   {
      HRESULT hr;
      if (SUCCEEDED(hr = 
            IObjectWithSiteImpl&lt;CAxOffl&gt;::SetSite(pUnkSite))
&#009;&#009;&amp;&amp; pUnkSite)
      {
         hr = GetAmbientOffline(&amp;m_AmbientOffline, m_spUnkSite);
      }

      return hr;
   }

   // Listen for notifications regarding changes to this ambient.
   STDMETHODIMP CAxOffl::OnAmbientPropertyChange(DISPID dispid)
   {
      HRESULT hr;

      if (dispid == DISPID_AMBIENT_OFFLINEIFNOTCONNECTED)
      {
&#009;   hr = GetOfflineIfNotConnected();
      }
      return S_OK;
   }
</PRE>
<P>An ActiveX control that uses URL Monikers to make network resource requests should add <B>BINDF_OFFLINE</B> to the bind flags it returns via <A HREF="../monikers/ifaces/ibindstatuscallback/GetBindInfo.htm#IBindStatusCallback_">IBindStatusCallback::GetBindInfo</A> as follows:

<PRE>
   void SetBindfFlags(BOOL fAmbientOffline, LPDWORD  grfBINDF)
   {
      if(fAmbientOffline)
      {
         DWORD dwConnectedStateFlags;
         if((!(InternetGetConnectedState(&amp;dwConnectedStateFlags, 0))) 
            &amp;&amp; 
              (0 == (dwConnectedStateFlags &amp; 
                             INTERNET_CONNECTION_MODEM_BUSY))) 
         {   // use the cache
            *grfBINDF |= BINDF_OFFLINEOPERATION;
            *grfBINDF &amp;= ~BINDF_GETFROMCACHE_IF_NET_FAIL;
         }
         else // Use the net; cache if net request fails.
         {
            *grfBINDF |= BINDF_GETFROMCACHE_IF_NET_FAIL;
            *grfBINDF &amp;= ~BINDF_OFFLINEOPERATION;   
         }
      }
   }
</PRE>
<P>Similarly, an ActiveX control that uses WININET should add <A HREF="../wininet/constants/API_Flags.htm#INTERNET_FLAG_OFFLIN">INTERNET_FLAG_OFFLINE</A> to the flags it passes to <A HREF="../wininet/functions/InternetOpen.htm#InternetOpen">InternetOpen</A>.

<PRE>
   void SetInetOpenFlags(BOOL fAmbientOffline, LPDWORD pdwOpenFlags)
   {
      // A component should first and foremost pay attention to 
      // the offline ambient provided by its container.
      if  (fAmbientOffline)
      {
         DWORD dwConnectedStateFlags;
         BOOL fIsConnected =
            InternetGetConnectedState(&amp;dwConnectedStateFlags, 0);

         // If not connected and not because the line is busy.
         if ( (!fIsConnected) &amp;&amp; (0 == 
           (dwConnectedStateFlags &amp; INTERNET_CONNECTION_MODEM_BUSY)))
         {
            // use the cache exclusively
            *pdwOpenFlags |= INTERNET_FLAG_OFFLINE;
&#009;&#009;*pdwOpenFlags &amp;= ~INTERNET_FLAG_CACHE_IF_NET_FAIL;
         }
         else
         {
            // Do not treat this as an offline operation
            // but use the cache if the net request fails.
&#009;&#009;*pdwOpenFlags |= INTERNET_FLAG_CACHE_IF_NET_FAIL;
            *pdwOpenFlags &amp;= ~INTERNET_FLAG_OFFLINE;   
         }
      }
   }
</PRE>
<P>While an application developer can use discretion in setting the bind flags by independently displaying a UI if a site is inaccessible, a control should always make an offline request to the URLMON or WININET APIs when it determines the system is disconnected from the network and the OFFLINEIFNOTCONNECTED ambient is set to TRUE. Contrary behavior will result in a repeated, unsolicited online request UI to be presented to the user.

<H3><A NAME="Considering_Backward">Considering Backward Compatibility</A></H3>
<P>Component authors who wish to maintain compatibility with previous versions of Internet Explorer should use dynamic rather than static linking when calling functions such as <A HREF="../wininet/functions/InternetGetConnectedState.htm#InternetGetConnected">InternetGetConnectedState</A>. This call was not available in Internet Explorer 3.0x. The following code demonstrates how to load and call <B>InternetGetConnectedState</B> without statically linking to WININET.LIB.
<PRE>
   typedef  BOOL (WINAPI* PFNINTERNETGETCONNECTEDSTATE)(LPDWORD, DWORD);

   HRESULT DynInternetGetConnectedState(LPDWORD pdwFlags)
   {
      PFNINTERNETGETCONNECTEDSTATE pfnInternetGetConnectedState;
      BOOL fConnected;

      if (!pdwFlags) return E_INVALIDARG;
 
      HMODULE hModule = LoadLibrary("wininet.dll");
      if (!hModule)
         return E_FAIL;

      pfnInternetGetConnectedState = 
         (PFNINTERNETGETCONNECTEDSTATE)GetProcAddress(hModule, 
            "InternetGetConnectedState");

      if (!pfnInternetGetConnectedState)
         return E_FAIL;

      fConnected = (*pfnInternetGetConnectedState)(pdwFlags, 0);

      FreeLibrary(hModule);
      return (fConnected ? S_OK : S_FALSE);
   }
</PRE>
<P>If the component implementing this function is hosted in Internet Explorer 3.0x, the call to GetProcAddress will return NULL, and DynInternetGetConnectedState will return E_FAIL. The component can then either make the network request regardless of the connected state or execute its own code to determine the state using sockets.

<H3><A NAME="Conclusion">Conclusion</A></H3>
<P>Internet Explorer 4.0 extends the browsing experience by providing offline services to application and component developers authoring for the Win32 platform. Through the use of this infrastructure, users can look forward to consistent behavior online and offline among all network-savvy applications and components.

<!-- CONTENTS_END -->
<!-- START PAGE FOOTER -->
<H6><HR size=1></H6>
<P><A ID=line HREF="#pagetop"><IMG src="../../art/arrowup1.gif" WIDTH="17" HEIGHT="16" ALIGN="MIDDLE" BORDER="0" ALT="Up">&nbsp;Top of Page</A>
<BR><A ID=line HREF="http://www.microsoft.com/misc/cpyright.htm" TARGET="_top">&#169; 1997 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END PAGE FOOTER -->
</BLOCKQUOTE>
</BODY>
</HTML>