<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OLE-DB Simple Provider for Java: A Data Binding API for IE4/MSHTML</TITLE>

<META NAME=MS-HKWD CONTENT="OLE-DB Simple Provider for Java: A Data Binding API for IE4/MSHTML">
<META NAME="Keywords" CONTENT="Internet Tools & Technologies, data binding">
<META NAME="Platform" CONTENT="Windows, Win95, WinNT, Mac">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">


<SCRIPT>
//<!--
var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";
// -->
</SCRIPT>
<SCRIPT SRC="../../code/ver.js"></SCRIPT>


<SCRIPT DEFER SRC="../../code/common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
	if (g_isIE && g_iMaj >= 4)	
	{
		SetTOC();
	}
}
//-->
</SCRIPT>

<LINK REL="stylesheet" HREF="/msdn/sdk/inetsdk/help/basicsdkIE4.css" TYPE="text/css">
<!-- STYLE_START -->


<SCRIPT>
//<!--
   var sVR = '../../'	// Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
	   if (g_iMaj >= 4) // For MSIE 4.0 or later
	   {
		   sCSS += 'basicSDKIE4';
		   if (g_sPlat == "Win") // Windows only for now
		   {
			   document.createStyleSheet(sVR + 'advSDKIE4.css');
		   }
	   }
	   else // For MSIE 3.0 or earlier
	   {
		   sCSS += 'basicSDKIE3';
	   }
   }
   else if (g_isNav) // For all Nav versions
   {
	   sCSS += 'basicSDKNAV';
   }
   else
   {
	   sCSS += 'basicSDKIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->
</SCRIPT>
<!-- STYLE_END -->
</HEAD>
<BODY onload="InitPage()" BGCOLOR="#FFFFFF">

<A NAME="pagetop"></A><A NAME="chp_simpletabulardatajava"></A>
<!-- NAV_LINKS_START -->
<TABLE class=main BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="10%"><TR><TD ROWSPAN="3" VALIGN="TOP" WIDTH="121"><IMG SRC="../../art/headbar2.gif" WIDTH="121" HEIGHT="82" BORDER=0 ALT="OLE-DB Simple Provider for Java: A Data Binding API for IE4/MSHTML"></TD><TD ROWSPAN="2" VALIGN="TOP" WIDTH="186"><IMG SRC="../../art/headbard.gif" WIDTH="186" HEIGHT="44" BORDER=0 ALT="OLE-DB Simple Provider for Java: A Data Binding API for IE4/MSHTML"></TD><TD VALIGN="TOP" WIDTH="470"><IMG SRC="../../art/replace1.gif" WIDTH="470" HEIGHT="17" BORDER=0 ALT="*"></TD></TR>
<TR><TD><PRE><IMG SRC="../../art/arrowrht.gif" WIDTH="14" HEIGHT="14" ALIGN="MIDDLE" BORDER=0 ALT="*"><object id="hhal_1" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Contents>
</object><A STYLE="color:black" ID=TOC HREF=JavaScript:hhal_1.Click()>Contents</A>  <IMG SRC="../../art/arrowrht.gif" WIDTH="14" HEIGHT="14" ALIGN="MIDDLE" BORDER=0 ALT="*"><object id="hhal_2" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Index_1sz1>
</object><A STYLE="color:black" HREF=JavaScript:hhal_2.Click()>Index</A>  <IMG SRC="../../art/arrowrht.gif" WIDTH="14" HEIGHT="14" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black" HREF="databind.htm#book_data_bind">Topic Contents</A></PRE></TD></TR>
<TR><TD COLSPAN="2"><PRE><IMG SRC="../../art/arrowlft.gif" WIDTH="17" HEIGHT="15" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" HREF="javadatasources.htm">Java Applets as Data Providers</A>
<IMG SRC="../../art/arrownxt.gif" WIDTH="17" HEIGHT="16" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A  STYLE="color:black" HREF="../infodelivery/infodelivery.htm">Information Delivery API</A></PRE></TD></TR>
</TABLE>
<!-- NAV_LINKS_END -->
<BLOCKQUOTE class="body">
<!-- CONTENTS_START -->
<H1>OLE-DB Simple Provider for Java: A Data Binding API for IE4/MSHTML</H1>
<BR CLEAR=ALL>
<P>IE4/MSHTML supports a very simple, easily implemented API for
exposing data to HTML pages. The API supports access to string
and variant data types and is built using array-like structures
to expose rows and columns. Third parties can use the OLE-DB
Simple Provider API to implement their custom data source
objects. 
<P><A CLASS=tctop HREF="simpletabulardatajava.htm#Introduction"><IMG SRC="../../art/arrowy.gif" WIDTH="6" HEIGHT="11" BORDER=0 ALT="arrowy.gif">Introduction</A><BR>
<P><A CLASS=tctop HREF="simpletabulardatajava.htm#OLE_DB_Simple_Provid"><IMG SRC="../../art/arrowy.gif" WIDTH="6" HEIGHT="11" BORDER=0 ALT="arrowy.gif">OLE-DB Simple Provider</A><BR>
<P><A CLASS=tctop HREF="simpletabulardatajava.htm#OLE_DB_Simple_Provid"><IMG SRC="../../art/arrowy.gif" WIDTH="6" HEIGHT="11" BORDER=0 ALT="arrowy.gif">OLE-DB Simple Provider Listener</A><BR>
<P><A CLASS=tctop HREF="simpletabulardatajava.htm#Interface_Summary"><IMG SRC="../../art/arrowy.gif" WIDTH="6" HEIGHT="11" BORDER=0 ALT="arrowy.gif">Interface Summary</A><BR>
<P><A CLASS=tctop HREF="simpletabulardatajava.htm#Exceptions"><IMG SRC="../../art/arrowy.gif" WIDTH="6" HEIGHT="11" BORDER=0 ALT="arrowy.gif">Exceptions</A><BR>

<H2><A NAME="Introduction">Introduction</A></H2>
<P>OLE-DB Simple Provider (OSP) is a JavaBeans interface specification that hosts can implement to expose their tabular data to HTML elements in IE4/MSHTML. OSP specifies only simple, minimal functionality that requires only minimal effort on the part of applet authors to expose their data. OSP specifies methods for adding, deleting, and setting the value of columns, searching through the set of data, and receiving notifications on data events.


<H2><A NAME="OLE_DB_Simple_Provid">OLE-DB Simple Provider</A></H2>
<P>OSP exposes a set of tabular data (data set) in an array-like structure. Elements of the data set are referenced by their row and column indexes. 

<H3>Data references</H3>
 
<P>Indexes begin with value 1 and increase. There are two special index values: 

<TABLE>
<TR><TD>0</TD>
<TD>Reserved for label information in the case of a row, and header information in the case of a column.</TD></TR>
<TR><TD>-1</TD>
<TD>The wildcard value. Refers to an unknown value or all values. For example, Row=-1, Col=2 refers to the entire column 2.</TD></TR>
</TABLE> 
 
<P>OSP defines two distinct interfaces: <B>OLEDBSimpleProvider</B> and <B>OLEDBSimpleProviderListener</B>. As you would expect, <B>OLEDBSimpleProvider</B> implements the methods used for data access, and <B>OLEDBSimpleProviderListener</B> specifies the methods to be
implemented by the host for receiving notification of data changes.

<H3>Schema functions</H3>
 
<P>Three functions are provided for obtaining the schema for the underlying rows or columns. 
<DL>
<DT><B>public int getRowCount( ) throws OSPException</B></DT>
<DD>Returns the number of rows in the data set.</DD>
<DT><B>public int getColumnCount( ) throws OSPException</B></DT>
<DD>Returns the number of columns in the data set.</DD>
<DT><B>public int getRWStatus(int iRow, int iColumn) throws OSPException</B></DT>
<DD>Returns the read/write status for the specified row and column. If one or both of iRow and iColumn have a value of -1, the read/write status is returned for the entire column, row, or complete data set.</DD>
</DL>

<P><B>OSPRW</B> is an interface that defines the following return values.
 
<PRE>public interface OSPRW
{
    public static final int OSPRW_DEFAULT = 1;
    public static final int OSPRW_READONLY = 0;
    public static final int OSPRW_READWRITE = 1;
    public static final int OSPRW_MIXED = 2;
}
</PRE>

<P>The definitions for the values are:

<TABLE>
<TR><TD>OSPRW_READONLY </TD>
<TD>Cell, row, column, or
data set is read-only.</TD></TR>
<TR><TD>OSPRW_READWRITE </TD>
<TD>Cell, row, column, or
data set can be modified.</TD></TR>
<TR><TD>OSPRW_MIXED</TD>
<TD>Cell, row, column, or
data set read-write status unknown <i>or</i> row, column or data set mixed status.</TD></TR> 
</TABLE>

<H3>Variant-oriented functions</H3>
 
<P>Two functions are provided to allow retrieval and setting of variant values in the data set. 
<DL>
<DT><B>public Object getVariant(int iRow, int iColumn, int fFormatted) throws OSPException</B></DT>
<DD>Returns the value of the cell at the row and column indicated. Based on the value specified in fFormatted, the returned value will contain either a value with the type of the underlying column, a string that corresponds to the underlying type of the column, or an HTML fragment that corresponds to the underlying type of the column.</DD>
<DT><B>public void setVariant(int iRow, int iColumn, int fFormatted, Object objVal) throws OSPException</B></DT>
<DD>Sets the value of the cell at the row and column indicated to the value of the Object supplied in objVal in the type requested by the value of fFormatted.</DD>
</DL>

<P><B>OSPFORMAT</B> is an interface that defines the following values: 

<PRE>public interface OSPFORMAT
{
    public static final int OSPFORMAT_RAW = 0;
    public static final int OSPFORMAT_DEFAULT = 0;
    public static final int OSPFORMAT_FORMATTED = 1;
    public static final int OSPFORMAT_HTML = 2;
}
</PRE>

<P>The definitions for the values are:

<TABLE>
<TR><TD>OSPFORMAT_RAW</TD>
<TD>The underlying type of the column should be used to either set the value or get the value.</TD></TR>
<TR><TD>OSPFORMAT_FORMATTED </TD>
<TD>The underlying type of the column should be converted to a string and the string returned as a BSTR within the variant. </TD></TR>
<TR><TD>OSPFORMAT_HTML</TD>
<TD>The underlying type of the column should be converted to an HTML string.</TD></TR>
</TABLE>

<h4>Notes</h4>
<ul> 
<LI>Valid Java class types for these interfaces are Integer, Long, Float, Double, String, Boolean, Date, and null.
<LI>Types other than those listed immediately above will be represented as String by calling the toString function on the class.
<LI>For setVariant with any of the formatting options, it is the provider's responsibility to perform the appropriate coercion to the underlying type of the column. In cases where the coercion cannot be successfully completed, an appropriate exception should be thrown.
<LI>For setVariant with OSPFORMAT_FORMATTED, the provider is free to interpret the input string however it sees fit. Alternatively, the provider may attempt to parse the input string and heuristically determine an appropriate data type and value to place into the cell&#151;for example, when updating formatted spreadsheet cells.
<LI>When OSPFORMAT_HTML is requested, the provider can, at its option, return a plain string (unadorned with HTML tags and so on).
<LI>A database NULL is indicated by returning a null.
<LI>Wildcard values (-1) are not valid for the iRow and iColumn attributes in setVariant or getVariant. That is, only a single value can be returned/set from either call.
</uL>

<H3>Deletion and insertion</H3>

<P>Functions are provided to insert and delete rows. For all functions, the row numbers provide the position within the data set to which the row will be inserted. That is, the row inserted will have the index specified. 

<DL>
<DT><B>public int deleteRows(int iRow, int cRows) throws OSPException</B></DT>
<DD>Deletes cRows from the data set starting at row iRow. The number of rows successfully deleted is returned.</DD>
<DT><B>public int insertRows(int iRow, int cRows) throws OSPException</B></DT>
<DD>Inserts cRows into the data set starting at row iRow. The number of rows successfully inserted is returned.</DD>
</DL>

<h4>Notes</h4>
<UL>
<LI>In the case of an error, the provider can choose to insert/delete rows up to the point where the error occurred. In such a case, the return value specifies the number of rows actually inserted/deleted.
<LI>Values for the inserted rows are not specified. Use the setVariant function to set the value of the cells inside rows that were inserted.
</UL>

<H3>Searching</H3> 
<P>A function is provided that supports some basic searching capability on the data set. The goal of this function is to be fairly easy for the provider to implement while providing the client with a meaningful set of functionality to perform complex searching.


<DL>
<DT><B>public int find(int iRowStart, int iColumn, Object objVal, int findFlags, int compType) throws OSPException</B></DT>
<DD>Searches for the values specified in objVal in column iColumn starting at row iRowStart. Upon successful completion, the row number with the matching value is returned in piRowFound.</DD>
</DL>

<P>The <B>OSPFIND</B> interface defines the values for findFlags as follows:
 
<PRE>public interface OSPFIND
{
    public static final int OSPFIND_DEFAULT = 0;
    public static final int OSPFIND_UP = 1;
    public static final int OSPFIND_CASESENSITIVE = 2;
}
</PRE>

<P>The definitions for the values are:
<TABLE>
<TR><TD>OSPFIND_UP</TD>
<TD>Specifies scan should be decreasing in row number.</TD></TR>
<TR><TD>OSPFIND_CASESENSITIVE </TD>
<TD>Specifies that search should be case sensitive.</TD></TR>
</TABLE>

<P>Similarly, the <B>OSPCOMP</B> interface defines the values for compType as follows:
 
<PRE>public interface OSPCOMP
{
    public static final int OSPCOMP_EQ = 1;
    public static final int OSPCOMP_DEFAULT = 1;
    public static final int OSPCOMP_LT = 2;
    public static final int OSPCOMP_LE = 3;
    public static final int OSPCOMP_GE = 4;
    public static final int OSPCOMP_GT = 5;
    public static final int OSPCOMP_NE = 6;
}
</PRE>

<P>The definitions for the values are:
<TABLE>
<TR><TD>OSPCOMP_LT</TD>
<TD>Specifies the first value less than objVal is being searched for.</TD></TR>
<TR><TD>OSPCOMP_LE</TD>
<TD>Specifies the first value less than or equal to objVal is being searched for.</TD></TR>
<TR><TD>OSPCOMP_GT</TD>
<TD>Specifies the first value greater than objVal is being searched for.</TD></TR>
<TR><TD>OSPCOMP_GE</TD>
<TD>Specifies the first value greater than or equal to objVal is being searched for.</TD></TR>
<TR><TD>OSPCOMP_EQ</TD>
<TD>Specifies the first value equal to objVal is being searched for.</TD></TR>
<TR><TD>OSPCOMP_NE</TD>
<TD>Specifies the first value not equal to objVal is being searched for.</TD></TR>
</TABLE>

<h4>Notes</h4>
<UL>
<LI>Find does compares using the native type of the underlying column. Providers are encouraged to simply fail when the type of the objVal differs from the underlying type of the column.
<LI>Find supports the same object types for objVal as setVariant and getVariant.
<LI>Comparing string values always compares values as they would be returned from a call to getVariant with OSPFORMAT_FORMATTED. Providers should not coerce values of objVal obtained from a previous call to getVariant with OSPFORMAT_HTML.
<LI>If no corresponding match is found, Find should return the constant -1.
</UL>

<H3>Asynchronous data population</H3>
<P>The main function of an OSP is to provide data to an HTML page. In many cases, the data will need to be transported over high-latency, low bandwidth networks, in most cases using a 28.8K modem. The OSP design accounts for making data available as expediently as possible while maintaining an architecture and interface specification that is easy to author.

<P>All OSP authors are encouraged to implement support for populating (or retrieving) the data they expose asynchronously. This allows the host to continue processing during data transmission instead of blocking on a call to the OSP until the entire data set has been transmitted to the client.

<P>The majority of the work required to support asynchronous data delivery does not involve the OSP interface specifically&#151;it is a requirement on the mechanisms to retrieve data from their underlying storages. Accordingly, three methods are required in the OSP interface: one to indicate whether the provider supports asynchronous population; one to return the progress of the asynchronous population; and a third to stop the asynchronous transmission of data.

<P>Two additional events are added to the OSP event notifications. One event indicates when additional data has become available for access through the interface, while the other signals that the asynchronous data population has completed. Both events are specified below in the <A HREF="simpletabulardatajava.htm#OLE_DB_Simple_Provid">OLE-DB Simple Provider Listener</A> section.
 
<DL>
<DT><B>public boolean isAsync( ) throws OSPException</B></DT>
<DD>Returns a Boolean indicating whether data is being populated asynchronously.</DD>
</DL>

<h4>Notes</h4>
<P>isAsynch should never block; it should always return the appropriate state.

<DL>
<DT><B>public int getEstimatedRows( ) throws OSPException</B></DT>
<DD>Returns the estimated total number of rows in the data set. Callers can use this in conjunction with getRowCount with an asynchronous provider to obtain an estimate of the percentage of data received.</DD></DL>

<h4>Notes</h4>
<UL>
<LI>When the number of rows in the data set cannot be estimated, the provider should return the special value -1.
<LI>Synchronous providers should not block on the call to getEstimatedRows. They should either return -1 to indicate that they cannot provide an estimate, or the actual row count (same as would be obtained through getRowCount).
<LI>Providers should not return the final row count from EstimatedRows prior to firing the transferComplete event (see below).
</UL>

<DL>
<DT><B>public void stopTransfer( ) throws OSPException</B></DT>
<DD>Requests that the OSP discontinue asynchronous transfer of data.</DD>
</DL>

<h4>Notes</h4>
<UL>
<LI>Providers should make every effort to expose the data transferred prior to receiving this request. The provider must expose a valid, consistent OSP interface for such data&#151;appropriate column/row count, read/write status, and so on.
<LI>Providers that cannot expose the data transferred prior to this request should discontinue the transfer of data and fail all subsequent calls to the OSP interface.
</UL>

<H3>Internationalization</H3>
 
<P>Implementers might have to consider cases where the consumer is running in a different locale from the source of the data. The provider is responsible for ensuring that data conversions are done in an appropriate fashion. In particular, be careful in cases where the string representation of many data types differs according to locale. For example, the float or double number 3.14 would be "3.14" in the US, and "3,14" in Germany. Date representations differ even more. For example, number (especially float, date) to string conversions done by GetVariant or SetVariant with the OSP_FORMATTED option specified should usually be done in the locale of the browser.
<P>The Find method has more complicated issues to deal with to implement its ordered comparisons correctly across locale boundaries. These comparisons should, where possible, also be done in the locale of the browser, although this issue is not as clear cut. (For example, if the data consists of strings containing European accented characters, it is not clear that a browser in the en-us locale has any preferred sorting order for these strings. The sorting order of the provider locale might be more useful.) 

<P>It is anticipated that there will be cases where the consumer will need to know the locale of the data in order to perform proper operations on that data. A method is provided for the provider to return this information. 

<DL>
<DT><B>public String getLocale( ) throws OSPException</B></DT>
<DD>Returns a string that indicates the locale of the data. This is used to perform the appropriate type conversions.</DD>
</DL>

<h4>Notes</h4>
<UL>
<LI>getLocale should simply return the empty string ("") when the provider does not support localization. This will allow the consuming entity to use the default from the operating system.
<LI>For all return values the category LC_ALL is assumed by the consumer.
</UL>

<H3>Sinking events</H3> 
<P>Methods are provided to attach and detach a unicast event handler for all events.

<DL>
<DT><B>public void addOLEDBSimpleProviderListener(OLEDBSimpleProviderListener objOSPL) throws OSPException</B></DT>
<DD>Registers the event handler interface specified by objOSPL to receive notifications of changes to data.</DD>
</DL>

<h4>Notes</h4> 
<UL>
<LI>If an event handler was specified previously, addOLEDBSimpleProviderListener replaces the previous event handler.
<LI>OSP events are unicast only. There can be only one listener.
</UL>

<DL>
<DT><B>public void removeOLEDBSimpleProviderListener(OLEDBSimpleProviderListener objOSPL) throws OSPException</B></DT>
<DD>Unregisters the event handler interface specified by objOSPL.</DD>
</DL>

<h4>Notes</h4>
<p>removeOLEDBSimpleProviderListener should always specify the objOSPL previously registered. In the event that objOSPL differs from the event handler registered, the call should fail.

<H2><A NAME="OLE_DB_Simple_Provid">OLE-DB Simple Provider Listener</A></H2>

<P>OSP implementers fire notifications of changes to the underlying data through a single event handler. There are pre- and post-notifications for each event. 

<P>The event handler, registered through addOLEDBSimpleProviderListener, should implement the following methods.

<DL>
<DT><B>public void aboutToChangeCell(int iRow, int iColumn) throws Exception</B></DT>
<DD>Indicates that the cell(s) indicated is about to change. This notification is fired when values are modified through setVariant or internally by a provider. aboutToChangeCell should fire before any data values are changed.</DD>
</DL>

<h4>Notes</h4>
<UL>
<LI>Calls to getVariant should return the original, unchanged value(s) prior to the return of control from firing the aboutToChangeCell event.
<LI>In aboutToChangeCell, the value -1 can be specified for iRow, iColumn, or both.
</UL>

<DL>
<DT><B>public void cellChanged(int iRow, int iColumn) throws Exception</B></DT>
<DD>Indicates that the cell(s) indicated was changed. This notification is fired when values are modified through setVariant or internally by a provider.</DD>
</DL>

<h4>Notes</h4>
<UL>
<LI>cellChanged should be fired after the data value(s) has changed. All subsequent calls to getVariant should return the new value(s).
<LI>In cellChanged, the value -1 can be specified for iRow, iColumn, or both.
</UL>

<DL>
<DT><B>public void aboutToDeleteRows(int iRow, int cRows) throws Exception</B></DT>
<DD>Indicates that cRows beginning at row iRow are about to be deleted. This notification is fired just prior to the rows being deleted either from a call to deleteRows or internally by the provider.</DD>
</DL>
 
<h4>Notes</h4> 
<p>Access to cells in the deleted rows should remain valid until control is returned from the aboutToDeleteRows function.
 
<DL>
<DT><B>public void deletedRows(int iRow, int cRows) throws Exception</B></DT>
<DD>Indicates that cRows were deleted beginning at row iRow. This notification is fired when rows are deleted through deleteRows or internally by a provider.</DD>
</DL>

<h4>Notes</h4> 
<p>deletedRows should be fired after the rows are deleted.

<DL>
<DT><B>public void aboutToInsertRows(int iRow, int cRows) throws Exception</B></DT>
<DD>Indicates that cRows beginning at row iRow are about to be inserted. This notification is fired just prior to the rows being inserted either from a call to insertRows or internally by the provider.</DD>
</DL>
 
<DL>
<DT><B>public void insertedRows(int iRow, int cRows) throws Exception</B></DT>
<DD>Indicates that cRows were inserted beginning at row iRow. This notification is fired when rows are inserted through insertRows or internally by a provider.</DD>
</DL>

<DL>
<DT><B>public void rowsAvailable(int iRow, int cRows) throws Exception</B></DT>
<DD>Indicates that cRows beginning at iRow are now available. This is useful for providers that obtain and expose their data asynchronously. The event notifies consumers that additional data is available.</DD>
</DL>
 
<h4>Notes</h4> 
<p>OSP consumers expect periodic notifications when data is available since they will likely be displaying or processing the data as it arrives. Providers should weigh the advantages of code simplification by firing the event once for each row against the performance impact of doing so.

<DL>
<DT><B>public void transferComplete(int doneReason) throws Exception</B></DT>
<DD>All providers must fire this event to indicate that the data transfer is complete. The event should be fired after the entire data set exposed by the provider is available. doneReason indicates whether the population was completed successfully, aborted, or was stopped&#151;the reason for why data population is complete.</DD>
</DL>

<P>The <B>OSPXFER</B> interface defines values for doneReason as follows: 
 
<PRE>public interface OSPXFER
{
    public static final int OSPXFER_COMPLETE = 0;
    public static final int OSPXFER_ABORT = 1;
    public static final int OSPXFER_ERROR = 2;
}
</PRE>

<P>The definitions for the values are:

<TABLE>
<TR><TD>OSPXFER_COMPLETE </TD>
<TD>Indicates that data transmission is completed successfully.</TD></TR>
<TR><TD>OSPXFER_ABORT</TD>
<TD>Indicates that the data transmission is completed due to a call to the Stop method.</TD></TR>
<TR><TD>OSPXFER_ERROR</TD>
<TD>Indicates that the data transmission completed in an error state.</TD></TR>
</TABLE>

<h4>Notes</h4>
<p>For providers that retrieve their data asynchronously, this event signifies that no additional rowsAvailable events will be called for this data set.

<h4>Notes for all events functions</h4>
<p>If your provider does not require any additional processing, it is not necessary to catch exceptions from the event routines. The unhandled exceptions will return up through to the setVariant, or [insert|delete]Rows call from which it initiated. The the exception should be handled there.

<H2><A NAME="Interface_Summary">Interface Summary</A></H2>
<P>All interfaces are part of the com.ms.osp package. The interfaces are as follows:


<PRE>public interface OLEDBSimpleProvider
{
    public int getRowCount( ) throws OSPException;
    public int getColumnCount( ) throws OSPException;
    public int getRWStatus(int iRow, int iColumn) throws OSPException;
    public Object getVariant(int iRow, int iColumn, int fFormatted) throws OSPException;
    public void setVariant(int iRow, int iColumn, int fFormatted, Object obj) throws OSPException;
    public int deleteRows(int iRow, int cRows) throws OSPException;
    public int insertRows(int iRow, int cRows) throws OSPException;
    public int find(int iRowStart, int iColumn, Object objVal, int findFlags, int compType)
	    throws OSPException;
    public boolean isAsync( ) throws OSPException;
    public int getEstimatedRows( ) throws OSPException;
    public void stopTransfer( ) throws OSPException;
    public String getLocale( ) throws OSPException;
    public void addOLEDBSimpleProviderListener(OLEDBSimpleProviderListener objOSPL)
	    throws OSPException,
                                                                                                                java.util.TooManyListenersException;
    public void removeOLEDBSimpleProviderListener(OLEDBSimpleProviderListener objOSPL)
	    throws OSPException;
}
</PRE>

<PRE>abstract interface OLEDBSimpleProviderListener
{
    public void aboutToChangeCell(int iRow, int iColumn) throws Exception;
    public void cellChanged(int iRow, int iColumn) throws Exception;
    public void aboutToDeleteRows(int iRow, int cRows) throws Exception;
    public void deletedRows(int iRow, int cRows) throws Exception;
    public void aboutToInsertRows(int iRow, int cRows) throws Exception;
    public void insertedRows(int iRow, int cRows) throws Exception;
    public void rowsAvailable(int iRow, int cRows) throws Exception;
    public void transferComplete(int doneReason) throws Exception;
}
</PRE>

<PRE>public interface OSPRW
{
    public static final int OSPRW_DEFAULT = 1;
    public static final int OSPRW_READONLY = 0;
    public static final int OSPRW_READWRITE = 1;
    public static final int OSPRW_MIXED = 2;
}
</PRE>

<PRE>public interface OSPFORMAT
{
    public static final int OSPFORMAT_RAW = 0;
    public static final int OSPFORMAT_DEFAULT = 0;
    public static final int OSPFORMAT_FORMATTED = 1;
    public static final int OSPFORMAT_HTML = 2;
}
</PRE>

<PRE>public interface OSPFIND
{
    public static final int OSPFIND_DEFAULT = 0;
    public static final int OSPFIND_UP = 1;
    public static final int OSPFIND_CASESENSITIVE = 2;
}
</PRE>

<PRE>public interface OSPCOMP
{
    public static final int OSPCOMP_EQ = 1;
    public static final int OSPCOMP_DEFAULT = 1;
    public static final int OSPCOMP_LT = 2;
    public static final int OSPCOMP_LE = 3;
    public static final int OSPCOMP_GE = 4;
    public static final int OSPCOMP_GT = 5;
    public static final int OSPCOMP_NE = 6;
}
</PRE>

<PRE>public interface OSPXFER
{
    public static final int OSPXFER_COMPLETE = 0;
    public static final int OSPXFER_ABORT = 1;
    public static final int OSPXFER_ERROR = 2;
}
</PRE>

<H2><A NAME="Exceptions">Exceptions</A></H2>
<P>OSP supports a number of exceptions. They are defined as follows:

<UL>
<LI><B>AccessDeniedException:</B> An inability to read/write the data has occurred.
<LI><B>ConversionException:</B> An error occurred attempting to coerce data types.
<LI><B>IllegalArgumentException:</B> A method was passed an invalid or inappropriate argument or was  invoked on an inappropriate object.
<LI><B>NotImplementedException:</B> The functionality of a called method is not implemented.
<LI><B>OSPException:</B> A failure has occurred calling an OSP method. This is used in all cases not covered by the previous exceptions.
</UL>
<!-- CONTENTS_END -->
<!-- START PAGE FOOTER -->
<H6><HR size=1></H6>
<P><A ID=line HREF="#pagetop"><IMG src="../../art/arrowup1.gif" WIDTH="17" HEIGHT="16" ALIGN="MIDDLE" BORDER="0" ALT="Up">&nbsp;Top of Page</A>
<BR><A ID=line HREF="http://www.microsoft.com/misc/cpyright.htm" TARGET="_top">&#169; 1997 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END PAGE FOOTER -->
</BLOCKQUOTE>
</BODY>
</HTML>