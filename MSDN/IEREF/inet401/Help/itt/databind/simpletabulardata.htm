<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OLE-DB Simple Provider: A Data Binding API for IE4/MSHTML</TITLE>

<META NAME=MS-HKWD CONTENT="OLE-DB Simple Provider: A Data Binding API for IE4/MSHTML">
<META NAME="Keywords" CONTENT="Internet Tools & Technologies, data binding">
<META NAME="Platform" CONTENT="Windows, Win95, WinNT, Mac">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">


<SCRIPT>
//<!--
var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";
// -->
</SCRIPT>
<SCRIPT SRC="../../code/ver.js"></SCRIPT>


<SCRIPT DEFER SRC="../../code/common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
	if (g_isIE && g_iMaj >= 4)	
	{
		SetTOC();
	}
}
//-->
</SCRIPT>

<LINK REL="stylesheet" HREF="/msdn/sdk/inetsdk/help/basicsdkIE4.css" TYPE="text/css">
<!-- STYLE_START -->


<SCRIPT>
//<!--
   var sVR = '../../'	// Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
	   if (g_iMaj >= 4) // For MSIE 4.0 or later
	   {
		   sCSS += 'basicSDKIE4';
		   if (g_sPlat == "Win") // Windows only for now
		   {
			   document.createStyleSheet(sVR + 'advSDKIE4.css');
		   }
	   }
	   else // For MSIE 3.0 or earlier
	   {
		   sCSS += 'basicSDKIE3';
	   }
   }
   else if (g_isNav) // For all Nav versions
   {
	   sCSS += 'basicSDKNAV';
   }
   else
   {
	   sCSS += 'basicSDKIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->
</SCRIPT>
<!-- STYLE_END -->
</HEAD>
<BODY onload="InitPage()" BGCOLOR="#FFFFFF">

<A NAME="pagetop"></A><A NAME="chp_osp"></A>
<!-- NAV_LINKS_START -->
<TABLE class=main BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="10%"><TR><TD ROWSPAN="3" VALIGN="TOP" WIDTH="121"><IMG SRC="../../art/headbar2.gif" WIDTH="121" HEIGHT="82" BORDER=0 ALT="OLE-DB Simple Provider: A Data Binding API for IE4/MSHTML"></TD><TD ROWSPAN="2" VALIGN="TOP" WIDTH="186"><IMG SRC="../../art/headbard.gif" WIDTH="186" HEIGHT="44" BORDER=0 ALT="OLE-DB Simple Provider: A Data Binding API for IE4/MSHTML"></TD><TD VALIGN="TOP" WIDTH="470"><IMG SRC="../../art/replace1.gif" WIDTH="470" HEIGHT="17" BORDER=0 ALT="*"></TD></TR>
<TR><TD><PRE><IMG SRC="../../art/arrowrht.gif" WIDTH="14" HEIGHT="14" ALIGN="MIDDLE" BORDER=0 ALT="*"><object id="hhal_1" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Contents>
</object><A STYLE="color:black" ID=TOC HREF=JavaScript:hhal_1.Click()>Contents</A>  <IMG SRC="../../art/arrowrht.gif" WIDTH="14" HEIGHT="14" ALIGN="MIDDLE" BORDER=0 ALT="*"><object id="hhal_2" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Index_1sz1>
</object><A STYLE="color:black" HREF=JavaScript:hhal_2.Click()>Index</A>  <IMG SRC="../../art/arrowrht.gif" WIDTH="14" HEIGHT="14" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black" HREF="databind.htm#book_data_bind">Topic Contents</A></PRE></TD></TR>
<TR><TD COLSPAN="2"><PRE><IMG SRC="../../art/arrowlft.gif" WIDTH="17" HEIGHT="15" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" HREF="comdatasources.htm">COM Objects as Data Providers</A>
<IMG SRC="../../art/arrownxt.gif" WIDTH="17" HEIGHT="16" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A  STYLE="color:black" HREF="javadatasources.htm">Java Applets as Data Providers</A></PRE></TD></TR>
</TABLE>
<!-- NAV_LINKS_END -->
<BLOCKQUOTE class="body">
<!-- CONTENTS_START -->
<H1>OLE-DB Simple Provider: A Data Binding API for IE4/MSHTML</H1>

<P>IE4/MSHTML supports a very simple, easily implemented API for exposing data to HTML pages. The API supports access to string and variant data types and is built using array-like structures to expose rows and columns. Third parties can use the OLE-DB Simple Provider API to implement their custom data source objects. 
<P><A CLASS=tctop HREF="simpletabulardata.htm#Introduction"><IMG SRC="../../art/arrowy.gif" WIDTH="6" HEIGHT="11" BORDER=0 ALT="arrowy.gif">Introduction</A><BR>
<P><A CLASS=tctop HREF="simpletabulardata.htm#OLE_DB_Simple_Provid"><IMG SRC="../../art/arrowy.gif" WIDTH="6" HEIGHT="11" BORDER=0 ALT="arrowy.gif">OLE-DB Simple Provider</A><BR>
<P><A CLASS=tctop HREF="simpletabulardata.htm#OLE_DB_Simple_Provid"><IMG SRC="../../art/arrowy.gif" WIDTH="6" HEIGHT="11" BORDER=0 ALT="arrowy.gif">OLE-DB Simple Provider Listener</A><BR>

<H2><A NAME="Introduction">Introduction</A></H2>
<P>OLE-DB Simple Provider (OSP) is an interface specification
that hosts can implement to expose their tabular data to HTML
elements in IE4/MSHTML. OSP specifies only simple, minimal
functionality that requires only minimal effort on the part of
control/applet authors to expose their data. OSP specifies
methods for adding, deleting, and setting the value of columns,
searching through the set of data and receiving notifications on
data events.

<P>OLE-DB Simple Provider was formerly called Simple Tabular Data,
or STD for short.


<H2><A NAME="OLE_DB_Simple_Provid">OLE-DB Simple Provider</A></H2>
<P>OSP exposes a set of tabular data (data set) in an array-like
structure. Elements of the data set are referenced by their row
and column indexes. 

<H3>Data references</H3>
 
<P>Indexes begin with value 1 and increase. There are two special index values.
 
<TABLE>
<TR><TD>0</TD>
<TD>Reserved for label information in the case of a row, and header information in the case of a column.</TD></TR>
<TR><TD>-1</TD>
<TD>The wildcard value. Refers to an unknown value or all values. For example, Row=-1, Col=2 refers to the entire column 2.</TD></TR> 
</TABLE>

<P>OSP defines two distinct interfaces: <B>OLEDBSimpleProvider</B> and
<B>OLEDBSimpleProviderListener</B>. As you would expect,
<B>OLEDBSimpleProvider</B> implements the methods used for data access,
and <B>OLEDBSimpleProviderListener</B> specifies the methods to be
implemented by the host for receiving notification of data
changes.

<H3>Interface ID</h3>
<P>The <B>OLEDBSimpleProvider</B> interface is identified by the following IID:
<P>{E0E270C0-C0BE-11d0-8FE4-00A0C90A6341}

<P>The methods implemented by <B>OLEDBSimpleProvider</B> can be broken
down into the following logical areas. 

<H4>Schema functions</h4>
 
<P>Three functions are provided for obtaining the schema for the underlying rows or columns. 

<DL>
<DT><B>HRESULT getRowCount([out, retval] LONG *pcRows)</B></DT>
<DD>Returns the number of rows in the data set.</DD>
<DT><B>HRESULT getColumnCount( [out,retval] LONG *pcColumns)</B></DT>
<DD>Returns the number of columns in the data set.</DD>
<DT><B>HRESULT getRWStatus([in] LONG iRow, [in] LONG iColumn, [out, retval] OSPRW *prwStatus)</B></DT>
<DD>Returns the read/write status for the specified row and column. If one or both of iRow and iColumn have a value of -1, the read/write status is returned for the entire column, row, or complete data set.</DD>
</DL>

<P><B>OSPRW</B> is an enumeration with the following values: 

<TABLE>
<TR><TD>OSPRW_READONLY</TD>
<TD>Cell, row, column, or data set is read-only.</TD></TR>
<TR><TD>OSPRW_READWRITE </TD>
<TD>Cell, row, column, or data set can be modified.</TD></TR>
<TR><TD>OSPRW_MIXED</TD>
<TD>Cell, row, column, or data set read-write status unknown <i>or</i> row, column, or data set mixed status.</TD></TR>
</TABLE>

<h4>Variant-oriented functions</h4>
 
<p>Two functions are provided to allow retrieval and setting of variant values in the data set:
 
<DL>
<DT><B>HRESULT getVariant([in] LONG iRow, [in] LONG iColumn, [in] OSPFORMAT fFormatted,
[    out, retval] VARIANT *pVar)</B></DT>
<DD>Retrieves the value of the cell at the row and column indicated into the preallocated variant supplied in pVar. Based on the value specified in fFormatted, pVar will contain either a value with the type of the underlying column, a string that corresponds to the underlying type of the column, or an HTML fragment that corresponds to the underlying type of the column.</DD>
<DT><B>HRESULT setVariant([in] LONG iRow, [in] LONG iColumn, [in] OSPFORMAT fFormatted,
    [in, retval] VARIANT Var)</B></DT>
<DD>Sets the value of the cell at the row and column indicated to the value of the variant supplied in pVar in the type requested by the value of fFormatted.</DD>
</DL>

<P><B>OSPFORMAT</B> is an enumeration with the following values:

<TABLE>
<TR><TD>OSPFORMAT_RAW</TD>
<TD>The underlying type of the column should be used to either set the value or get the value.</TD></TR>
<TR><TD>OSPFORMAT_FORMATTED </TD>
<TD>The underlying type of the column should be converted to a string and the string returned as a BSTR within the variant. </TD></TR>
<TR><TD>OSPFORMAT_HTML </TD>
<TD>The underlying type of the column should be converted to an HTML string.</TD></TR>
</TABLE>

<h4>Notes</h4> 
<UL>
<LI>For both functions, as per the definition of VARIANT, references are not supported.
<LI>For setVariant with any of the formatting options, it is the provider's responsibility to perform the appropriate coercion to the underlying type of the column. In cases where the coercion cannot be successfully completed, an appropriate error return code should be returned.
<LI>For setVariant with OSPFORMAT_FORMATTED, the provider is free to interpret the input string however it sees fit. Alternatively, the provider may attempt to parse the input string and heuristically determine an appropriate data type and value to place into the cell&#151;for example, when updating formatted spreadsheet cells.
<LI>When OSPFORMAT_HTML is requested, the provider may, at its option, return a plain string (unadorned with HTML tags and so on).
<LI>A database NULL is indicated by returning a variant of type VT_NULL for any of the fFormatted types.
<LI> Wildcard values (-1) are not valid for the iRow and iColumn attributes in setVariant or getVariant.
 </UL>

<h3>Deletion and Insertion</h3>
<BR>Functions are provided to insert and delete rows. For all functions, the row numbers provide the position within the data set to which the row will be inserted. That is, the row inserted will have the index specified. 

<DL>
<DT><B>HRESULT deleteRows([in] LONG iRow, [in] LONG cRows, [out, retval] LONG *pcRowsDeleted)</B></DT>
<DD>Deletes cRows from the data set starting at row iRow. The number of rows successfully deleted is returned in pcRowsDeleted.</DD>
<DT><B>HRESULT insertRows([in] LONG iRow, [in] LONG cRows, [out, retval] LONG *pcRowsInserted)</B> </DT>
<DD>Inserts cRows into the data set starting at row iRow. The number of rows successfully inserted is returned in pcRowsInserted.</DD>
</DL>
 
<h4>Notes</h4> 
<UL>
<LI>In the case of an error, the provider may choose to insert/delete rows up to the point where the error occurred. In such a case, the [out] parameter specifies the number of rows actually inserted/deleted.
<LI>Values for the inserted rows are not specified. Use the setVariant function to set the value of the cells inserted.
</UL>

<h3>Searching</h3> 
<p>A function is provided that supports some basic searching capability on the data set. The goal of this function is to be fairly easy for the provider to implement while providing the client with a meaningful set of functionality to perform complex searching.

<DL>
<DT><B>HRESULT find([in] LONG iRowStart, [in] LONG iColumn, [in] VARIANT varSval, [in] OSPFIND findFlags, [in] OSPCOMP compType, [out, retval] LONG *piRowFound)</B></DT>
<DD>Searches for the values specified in varSval in column iColumn starting at row iRowStart. Upon successful completion, the row number with the matching value is returned in piRowFound.</DD>
</DL>
 
<P>Supported values for <B>OSPFIND</B> are: 
<TABLE>
<TR><TD>OSPFIND_UP</TD>
<TD>Specifies scan should be decreasing in row number.</TD></TR>
<TR><TD>OSPFIND_CASESENSITIVE </TD>
<TD>Specifies that search should be case sensitive.</TD></TR>
</TABLE>

<P>Supported values for <B>OSPCOMP</B> are: 
<TABLE>
<TR><TD>OSPCOMP_LT</TD>
<TD>Specifies the first value less than varSval is being searched for.</TD></TR>
<TR><TD>OSPCOMP_LE</TD>
<TD>Specifies the first value less than or equal to varSval is being searched for.</TD></TR>
<TR><TD>OSPCOMP_GT</TD>
<TD>Specifies the first value greater than varSval is being searched for.</TD></TR>
<TR><TD>OSPCOMP_GE</TD>
<TD>Specifies the first value greater than or equal to varSval is being searched for.</TD></TR>
<TR><TD>OSPCOMP_EQ</TD>
<TD>Specifies the first value equal to varSval is being searched for.</TD></TR>
<TR><TD>OSPCOMP_NE</TD>
<TD>Specifies the first value not equal to varSval is being searched for.</TD></TR>
</TABLE>


<h4>Notes</h4>
<UL>
<LI>Find does compares using the native type of the underlying column. Providers are encouraged to simply fail when the type of the varSval differs from the underlying type of the column.
<LI>Comparing string values always compares values as they would be returned from a call to GetVariant with OSPFORMAT_FORMATTED. Providers should not coerce values of varSval obtained from a previous call to GetVariant with OSPFORMAT_HTML.
<LI>If no corresponding match is found, Find should return the constant -1.
</UL>

<h3>Asynchronous data population</h3>

<p>The main function of an OSP is to provide data to an HTML page. In many cases, the data will need to be transported over high-latency, low bandwidth networks, in most cases using a 28.8K modem. The OSP design accounts for making data available as expediently as possible while maintaining an architecture and interface specification that is easy to author.

<P>All OSP authors are encouraged to implement support for populating (or retrieving) the data they expose asynchronously. This allows the host to continue processing during data transmission instead of blocking on a call to the OSP until the entire data set has been transmitted to the client.

<P>The majority of the work required to support asynchronous data delivery does not involve the OSP interface specifically; it is a requirement on the mechanisms to retrieve data from their underlying storages. Accordingly, three methods are required in the OSP interface: one to indicate whether the provider supports asynchronous population; one to return the progress of the asynchronous population; and a third to stop the asynchronous transmission of data.

<P>Two additional events are added to the OSP event notifications. One event indicates when additional data has become available for access through the interface, while the other signals that the asynchronous data population has completed. Both events are specified below in the OLE-DB Simple Provider Events section.

<DL>
<DT><B>HRESULT isAsync( [out, retval] BOOL *pbAsynch)</B></DT>
<DD>Returns a Boolean indicating whether data is being populated asynchronously.</DD>
</DL>

<h4>Notes</h4> 
<P>IsAsynch should never block; it should always return the appropriate state.

<DL> 
<DT><B>HRESULT getEstimatedRows( [out, retval] LONG *piRows)</B></DT>
<DD>Returns the estimated total number of rows in the data set. Callers can use this in conjunction with GetRowCount with an asynchronous provider to obtain an estimate of the percentage of data received.</DD>
</DL>

<h4>Notes</h4> 
<UL>
<LI>When the number of rows in the data set cannot be estimated, the provider should return the special value -1.
<LI>Synchronous providers should not block on the call to GetEstimatedRows. They should either return -1 to indicate that they cannot provide an estimate, or the actual row count (same as would be obtained through GetRowCount).
<LI>Providers should not return the final row count from EstimatedRows prior to firing the TransferComplete event (see below).
</UL>

<DL>
<DT><B>HRESULT stopTransfer()</B></DT>
<DD>Requests that the OSP discontinue asynchronous transfer of data.</DD>
</DL>

<h4>Notes</h4>
<UL>
<LI>Providers should make every effort to expose the data transferred prior to receiving this request. The provider must expose a valid, consistent OSP interface for such data&#151;appropriate column/row count, read/write status, and so on.
<LI>Providers that cannot expose the data transferred prior to this request should discontinue the transfer of data and fail all subsequent calls to the OSP interface.
</UL>

<h3>Internationalization</h3>
 
<P>Implementers may have to consider cases where the consumer is running in a different locale from the source of the data. The provider is responsible for ensuring that data conversions are done in an appropriate fashion. In particular, be careful in cases where the string representation of many data types differs according to locale. For example, the float or double number 3.14 would be "3.14" in the US, and "3,14" in Germany. Date representations differ even more. For example, number (especially float, date) to string conversions done by GetVariant or SetVariant with the OSP_FORMATTED option specified should usually be done in the locale of the browser.

<P>The Find method has more complicated issues to deal with to implement its ordered comparisons correctly across locale boundaries. These comparisons should, where possible, also be done in the locale of the browser, although this issue is not as clear cut. (For example, if the data consists of strings containing European accented characters, it is not clear that a browser in the en-us locale has any preferred sorting order for these strings. The sorting order of the provider locale might be more useful.) 

<P>It is anticipated that there will be cases where the consumer will need to know the locale of the data in order to perform proper operations on that data. A method is provided for the provider to return this information. 

<DL>
<DT><B>HRESULT getLocale([out,retval] BSTR *pbstrLocale)</B></DT>
<DD>Returns a string in pbstrLocale that indicates the locale of the data returned by GetLocale. This is used to perform the appropriate type conversions.</DD>
</DL>

<h4>Notes</h4>
<UL>
<LI>GetLocale should simply return the empty string ("") when the provider does not support localization. This will allow the consuming entity to use the default from the operating system.
<LI>For all values of pbstrLocale, the category LC_ALL is assumed by the consumer.
</UL>

<h3>Sinking events</h3> 
<P>Methods are provided to attach and detach a unicast event handler for all events.

<DL>
<DT><B>HRESULT addOLEDBSimpleProviderListener([in] OLEDBSimpleProviderListener *posplListener)</B> </DT>
<DD>Registers the event handler interface specified by posplListener to receive notifications of changes to data.</DD>
</DL>

<h4>Notes</h4>
<UL>
<LI>If an event handler was specified previously, addOLEDBSimpleProviderListener releases the previous event handler prior to registering posplListener.
<LI>OSP events are unicast only. There can be only one listener.
</UL>

<DL>
<DT><B>HRESULT removeOLEDBSimpleProviderListener([in] OLEDBSimpleProviderListener *posplListener)</B> </DT>
<DD>Unregisters the event handler interface specified by posplListener.
</DL>
 
<h4>Notes</h4> 

<P>removeOLEDBSimpleProviderListener should always specify the posplListener previously registered. In the event that posplListener differs from the event handler registered, the call should fail.

<H2><A NAME="OLE_DB_Simple_Provid">OLE-DB Simple Provider Listener</A></H2>
<P>OSP implementers fire notifications of changes to the underlying data through a single event handler. There are pre- and post-notifications for each event. 

<h3>Interface ID</h3>

<P>The <B>OLEDBSimpleProviderListener</B> interface can be identified by the following IID:

<P>{E0E270C1-C0BE-11d0-8FE4-00A0C90A6341}
 
<P>The event handler, registered through <B>OLEDBSimpleProvider::addOLEDBSimpleProviderListener</B>,
should implement the following methods:

<DL>
<DT><B>HRESULT aboutToChangeCell([in] LONG iRow, [in] LONG iColumn)</B></DT>
<DD>Indicates that the cell(s) indicated is about to change. This notification is fired when values are modified through SetVariant or internally by a provider. AboutToChangeCell should fire before any data values are changed.
</DL>

<h4>Notes</h4> 
<UL>
<LI>Calls to GetVariant should return the original, unchanged value(s) prior to the return of control from firing the AboutToChangeCell event.
<LI>In AboutToChangeCell, the value -1 can be specified for iRow, iColumn, or both.
</UL>

<DL>
<DT><B>HRESULT cellChanged([in] LONG iRow, [in] LONG iColumn)</B></DT>
<DD>Indicates that the cell(s) indicated was changed. This notification is fired when values are modified through SetVariant or internally by a provider.
</DL>

<h4>Notes</h4>
<UL>
<LI>CellChanged should be fired after the data value(s) has changed. All subsequent calls to GetVariant should return the new value(s).
<LI>In CellChanged(), the value -1 can be specified for iRow, iColumn, or both.
</UL>

<DL>
<DT><B>HRESULT aboutToDeleteRows([in] LONG iRow, [in] LONG cRows)</B></DT>
<DD>Indicates that cRows beginning at row iRow are about to be deleted. This notification is fired just prior to the rows being deleted either from a call to DeleteRows or internally by the provider.
</DL>
 
<h4>Notes</h4> 
<P>Access to cells in the deleted rows should remain valid until control is returned from the AboutToDeleteRows function.

<DL>
<DT><B>HRESULT deletedRows([in] LONG iRow, [in] LONG cRows)</B></DT>
<DD>Indicates that cRows were deleted beginning at row iRow. This notification is fired when rows are deleted through DeleteRows or internally by a provider.
</DL>
 
<h4>Notes</h4> 
<P>DeletedRows should be fired after the rows are deleted.

<DL>
<DT><B>HRESULT aboutToInsertRows([in] LONG iRow, [in] LONG cRows)</B></DT>
<DD>Indicates that cRows beginning at row iRow are about to be inserted. This notification is fired just prior to the rows being inserted either from a call to InsertRows or internally by the provider.
</DL>

<DL> 
<DT><B>HRESULT insertedRows([in] LONG iRow, [in] LONG cRows)</B></DT>
<DD>Indicates that cRows were inserted beginning at row iRow. This notification is fired when rows are inserted through InsertRows or internally by a provider.
</DL>

<DL>
<DT><B>HRESULT rowsAvailable([in] LONG iRow, [in] LONG cRows)</B></DT>
<DD>Indicates that cRows beginning at iRow are now available. This is useful for providers that obtain and expose their data asynchronously. The event notifies consumers that additional data is available.</DD>
</DL>
 
<h4>Notes</h4>
<P>OSP consumers expect periodic notifications when data is available since they will likely be displaying or processing the data as it arrives. Providers should weigh the advantages of code simplification by firing the event once for each row against the performance impact of doing so.

<DL>
<DT><B>HRESULT transferComplete([in] OSPXFER doneReason)</B></DT>
<DD>All providers must fire this event to indicate that the data transfer is complete. The event should be fired after the entire data set exposed by the provider is available. doneReason indicates whether the population was completed successfully, or aborted, or stopped&#151;the reason for why data population is complete.</DD>
</DL>

<P>Supported values for <B>OSPXFER</B> are: 
<TABLE>
<TR><TD>OSPXFER_COMPLETE </TD>
<TD>Indicates that the data
 transmission is completed successfully.</TD></TR>
<TR><TD>OSPXFER_ABORT</TD>
<TD>Indicates that the data transmission is completed due to a call to the Stop method.</TD></TR>
<TR><TD>OSPXFER_ERROR</TD>
<TD>Indicates that the data transmission completed in an error state.</TD></TR>
</TABLE>

<h4>Notes</h4>
<P>For providers that retrieve their data asynchronously, this event signifies that no additional RowsAvailable events will be called for this data set.

<h4>Notes for all events functions</h4> 

<P>The returned value is propagated back to the function that resulted in the notification. That is, if CellChanged returns E_BADVALUE, the SetVariant function will also return E_BADVALUE. 



<!-- CONTENTS_END -->
<!-- START PAGE FOOTER -->
<H6><HR size=1></H6>
<P><A ID=line HREF="#pagetop"><IMG src="../../art/arrowup1.gif" WIDTH="17" HEIGHT="16" ALIGN="MIDDLE" BORDER="0" ALT="Up">&nbsp;Top of Page</A>
<BR><A ID=line HREF="http://www.microsoft.com/misc/cpyright.htm" TARGET="_top">&#169; 1997 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END PAGE FOOTER -->
</BLOCKQUOTE>
</BODY>
</HTML>