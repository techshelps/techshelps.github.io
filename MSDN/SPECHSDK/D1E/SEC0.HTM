<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Text Buffers</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,atial,helvetica" SIZE="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Text Buffers</H3><P>Before an engine can begin speaking text, an application must pass the text to the engine. To do this, the application adds text buffers to the engine's speaking queue. </P>
<P>To add a text buffer to the queue, an application calls the <B>ITTSCentral::TextData</B> member function. When calling <B>TextData</B>, the application specifies an <B>SDATA</B> structure that contains the address of the text buffer to add to the speaking queue and a value indicating the number of bytes in the buffer, including the terminating null character. The application also specifies a value indicating the character set that the engine should use to translate the text in the buffer and a flag indicating whether the text contains control tags. Because <B>TextData</B> copies the text buffer into the engine's speaking queue, the application can free the buffer as soon as the member function returns. </P>
<P>Another option is for an application to specify the address of an <B>ITTSBufNotifySink</B> interface when calling <B>TextData</B>. The engine object uses the interface to notify the application about the status of the buffer it placed into the speaking queue. For more information about buffer-related notifications, see "Buffer Notifications" later in this section.</P>
<P>When the engine starts playing the buffer, the application receives an<B> ITTSNotifySink::AudioStart</B> notification. The application receives the <B>ITTSNotifySink::AudioStop</B> notification when the audio finishes playing. If the engine supports visual feedback, the <B>ITTSNotifySink::Visual</B> notification should be called periodically.</P>
<P>To play more buffers, the application calls <B>TextData</B> with the additional buffers. If a previous buffer is still playing, the new buffers are added to the end of the queue. When the engine has finished processing the last text-to-speech buffer, the engine notifies the application by calling the <B>ITTSBufNotifySink::TextDataDone</B> notification. The engine does not wait for the audio object to finish speaking the audio before sending the notification.</P></FONT></BODY></HTML>
