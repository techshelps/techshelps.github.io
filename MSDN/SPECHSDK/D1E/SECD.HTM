<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Initializing an Application for Text-to-Speech</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,atial,helvetica" SIZE="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<h2>Initializing an Application for Text-to-Speech</H2><P>To implement text-to-speech features, you must initialize the OLE libraries and then create instances of the audio-destination object and the text-to-speech engine object. The engine object translates a text buffer into audio output and passes it to the audio-destination object, which plays the speech output on the audio-output device. In addition, you can use the text-to-speech enumerator and engine enumerator to find an engine and mode that meets your application's requirements. </P>
<P>The following example demonstrates how to initialize an application for text-to-speech. It shows how to create the necessary objects for implementing text-to-speech translation. The example accomplishes the following tasks:</P>
<P> <FONT FACE="Symbol">·</FONT>    Uses the <B>CoInitialize</B> function to initialize the OLE libraries. </P>
<P> <FONT FACE="Symbol">·</FONT>    Creates an instance of the multimedia audio-destination object, which allows the engine to send speech output to the multimedia wave-out driver. </P>
<P> <FONT FACE="Symbol">·</FONT>    Uses the text-to-speech enumerator to find an engine and mode that most closely matches the application's requirements. </P>
<P> <FONT FACE="Symbol">·</FONT>    Creates an instance of an application-defined class that implements the <B>ITTSBufNotifySink</B> interface. The engine calls this interface to notify the application of buffer-related events. </P>
<P></P>
<P>// FindAndSelectEngine - creates a multimedia audio-destination object,</P>
<P>//   finds and selects a text-to-speech engine and mode, and creates</P>
<P>//   the buffer notification object.</P>
<P>// Returns TRUE if successful or FALSE if an error occurs.</P>
<P>//</P>
<P>// Global variables:</P>
<P>//   g_pIAMM - address of IAudioMultiMediaDevice interface</P>
<P>//   g_TTSModeInfo - address of TTSMODEINFO structure that contains</P>
<P>//     information about the selected mode   </P>
<P>//   g_pIBufNotifySink - address of the application's </P>
<P>//     ITTSBufNotifySink interface</P>
<P>BOOL FindAndSelectEngine(void) </P>
<P>{</P>
<P>    HRESULT hRes;          // result code</P>
<P>    TTSMODEINFO ttsmiTemp; // information about the desired mode</P>
<P>    PITTSFIND pITTSFind;   // address of ITTSFind interface</P>
<P></P>
<P>    // Initialize OLE.</P>
<P>    if (FAILED(CoInitialize(NULL))) </P>
<P>        return FALSE;</P>
<P></P>
<P>    // Create the multimedia audio-destination object and retrieve the</P>
<P>    // address of the object's IAudioMultiMediaDevice interface. </P>
<P>    hRes = CoCreateInstance(CLSID_MMAudioDest, NULL, CLSCTX_ALL, </P>
<P>        IID_IAudioMultiMediaDevice, (void**) &amp;g_pIAMM);</P>
<P>    if (hRes)</P>
<P>        return FALSE;</P>
<P>    </P>
<P>    // Set the device identifier for the multimedia wave-out device.</P>
<P>    g_pIAMM-&gt;DeviceNumSet(WAVE_MAPPER);</P>
<P></P>
<P>    // Create the text-to-speech enumerator and retrieve the address of</P>
<P>    // the object's ITTSFind interface. </P>
<P>    hRes = CoCreateInstance(CLSID_TTSEnumerator, NULL, CLSCTX_ALL, </P>
<P>        IID_ITTSFind, (void**) &amp;pITTSFind);</P>
<P>    if (FAILED(hRes)) {</P>
<P>        g_pIAMM-&gt;Release;</P>
<P>        return FALSE;</P>
<P>    }</P>
<P></P>
<P>    // Define the characteristics of the desired text-to-speech mode.</P>
<P>    ZeroMemory(&amp;ttsmiTemp, sizeof(ttsmiTemp));</P>
<P>    ttsmiTemp.language.LanguageID = </P>
<P>        MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);</P>
<P>    ttsmiTemp.wGender = GENDER_FEMALE;</P>
<P>    ttsmiTemp.wAge = TTSAGE_ADULT;</P>
<P>    lstrcpy(ttsmiTemp.szStyle, "Business");</P>
<P></P>
<P>    // Find the engine and mode that most closely matches the desired </P>
<P>    // characteristics. </P>
<P>    hRes = pITTSFind-&gt;Find(&amp;ttsmiTemp, NULL, &amp;g_TTSModeInfo);</P>
<P>    if (hRes) {</P>
<P>        g_pIAMM-&gt;Release;</P>
<P>        pITTSFind-&gt;Release();</P>
<P>        return FALSE;</P>
<P>    }</P>
<P></P>
<P>    // Select the text-to-speech mode and create an engine object to </P>
<P>    // represent the mode. Also, retrieve the address of the engine's </P>
<P>    // ITTSCentral interface.</P>
<P>    hRes = pITTSFind-&gt;Select(g_TTSModeInfo.gModeID, &amp;g_pITTSCentral, </P>
<P>        (LPUNKNOWN) g_pIAMM);</P>
<P>    if (hRes) {</P>
<P>        g_pIAMM-&gt;Release;</P>
<P>        pITTSFind-&gt;Release();</P>
<P>        return FALSE;</P>
<P>    };</P>
<P></P>
<P>    // Release the text-to-speech enumerator; it is no longer needed.</P>
<P>    pITTSFind-&gt;Release();</P>
<P></P>
<P>    // Create an instance of the buffer notification object based on the</P>
<P>    // application-defined CBufNotify class. </P>
<P>    if ((g_pIBufNotifySink = new CBufNotify) == NULL)</P>
<P>        return FALSE;</P>
<P></P>
<P>    return TRUE;</P>
<P>}</P>
<P></P></FONT></BODY></HTML>
