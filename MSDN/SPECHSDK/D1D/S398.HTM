<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Examples of Typical Rules</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,atial,helvetica" SIZE="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Examples of Typical Rules</H3><P>The following examples show typical rules that might be defined for a context-free grammar. </P>
<P>The rule syntax shown here is for purposes of illustration only, and is not actually understood by the engine. The syntax for rules is up to the grammar designer.</P>
<H4><A NAME="sec0"></A>Rules That Specify Lists</H4><P>A rule might specify a list of names such as "Bob," "Fred," "George," and "Bill," allowing the speaker to say only one of those names. Such a rule might appear as follows:</P>
<P>&lt;Names&gt;=ALT("Bob", "Fred", "George")</P>
<P></P>
<P>In this example, ALT indicates that only one of the words can be spoken.</P>
<P>If the names are longer than one word, the rule might take either of the following forms:</P>
<P>&lt;Names&gt;=ALT("Bob Marks", "Fred Smith", "George Hill")</P>
<P></P>
<P>or</P>
<P>&lt;Names&gt;=ALT(SEQ("Bob", "Marks"), SEQ("Fred", "Smith"), ...)</P>
<P></P>
<P>In this example, SEQ indicates a sequence of words to be spoken.</P>
<P>As an alternative, the last name might be optional, in which case the rule might take the following form:</P>
<P>&lt;Names&gt;=ALT(SEQ("Bob",OPT("Marks")), ... </P>
<P></P>
<P>In this example, OPT indicates that the word can be spoken but is not required. This is equivalent to:</P>
<P>&lt;Names&gt;=ALT("Bob", "Bob Marks", "Fred", "Fred Smith", ...)</P>
<P></P>
<H4><A NAME="sec1"></A>Rules That Refer to Lists</H4><P>A list of names is insufficient by itself for most recognition, but the list can be used as a component of another rule. For example, if several different actions — such as "Send mail to &lt;Name&gt;" or "Who is &lt;Name&gt;" — could be performed on a specific name, a rule might include alternatives and sequences that refer to the &lt;Names&gt; rule. For example:</P>
<P>&lt;Actions&gt;=ALT(SEQ("Send mail to",&lt;Name&gt;), SEQ("Who is", &lt;Name&gt;)), ...)</P>
<P></P>
<P>This example is equivalent to the following:</P>
<P>&lt;Actions&gt;=ALT("Send mail to Bob", "Send mail to Bob Marks",  </P>
<P>    "Send mail to Fred", "Send mail to Fred Smith", ...)</P>
<P></P>
<P>A repeat operator, which allows its contents to be repeated indefinitely, is also useful. Rules are recursive, so the restriction of a single operand for repeat is not significant. For example:</P>
<P>&lt;MoreActions&gt;=SEQ(&lt;Actions&gt;, OPT(REP(SEQ("and", &lt;Names&gt;))))</P>
<P></P>
<P>This kind of rule allows the speaker to say such things as "Send mail to Fred" or "Send mail to Fred and Bob and Bill."</P>
<H4><A NAME="sec2"></A>Lists That Are Filled at Run Time</H4><P>A rule can also refer to a list that is filled at run time after the grammar has been loaded. Rather than send text strings to the engine, which is too slow, the grammar sends a list of structures filled with the equivalent operations and symbols. Although lists may require more processing to recognize, they allow grammars to be modified dynamically for such things as filenames that change frequently and often depend upon context. For example:</P>
<P>&lt;Actions&gt; = ALT(LIST(&lt;Names&gt;))</P>
<P></P>
<P>For example, if the &lt;Names&gt; list contains "Bob Marks" and "Fred Smith" at run time, the speaker can say "Send mail to Bob Marks" and "Send mail to Fred Smith."</P></FONT></BODY></HTML>
