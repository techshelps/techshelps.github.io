<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Processing Recognition Notifications</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,atial,helvetica" SIZE="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<h2>Processing Recognition Notifications</H2><P>The speech-recognition engine object calls an application's <B>ISRGramNotifySink</B> interface to inform the application of recognition events so that the application can respond to them. To receive notifications, the application must create a COM object that supports the <B>ISRGramNotifySink</B> interface, and it must pass the address of the interface to the engine object when calling the <B>ISRCentral::GrammarLoad</B> member function. </P>
<P>The <B>ISRGramNotifySink</B> interface consists of a set of member functions that correspond to recognition events. When an event occurs, the engine object calls the member function that corresponds to the event. </P>
<P>The following example shows how to define an object class that implements the <B>ISRGramNotifySink</B> interface:</P>
<P>class CISRGramNotifySink : public ISRGramNotifySink {</P>
<P>    public:</P>
<P>        CISRGramNotifySink(void);</P>
<P>        ~CISRGramNotifySink(void);</P>
<P></P>
<P>        // IUnknown members that delegate to m_punkOuter</P>
<P>        // Non-delegating object IUnknown</P>
<P>        STDMETHODIMP         QueryInterface (REFIID, LPVOID FAR *);</P>
<P>        STDMETHODIMP_(ULONG) AddRef();</P>
<P>        STDMETHODIMP_(ULONG) Release();</P>
<P></P>
<P>        // ISRNotifySink</P>
<P>        STDMETHODIMP BookMark         (DWORD);</P>
<P>        STDMETHODIMP Paused           ();</P>
<P>        STDMETHODIMP PhraseFinish     (DWORD, QWORD, QWORD, PSRPHRASE, </P>
<P>            LPUNKNOWN);</P>
<P>        STDMETHODIMP PhraseHypothesis (DWORD, QWORD, QWORD, PSRPHRASE, </P>
<P>            LPUNKNOWN);</P>
<P>        STDMETHODIMP PhraseStart      (QWORD);</P>
<P>        STDMETHODIMP ReEvaluate       (LPUNKNOWN);</P>
<P>        STDMETHODIMP Training         (DWORD);</P>
<P>        STDMETHODIMP UnArchive        (LPUNKNOWN);</P>
<P></P>
<P>        CISRGrammarObject *m_pGramObj;   // address of grammar object</P>
<P></P>
<P>protected:</P>
<P>        DWORD m_dwRefCnt;</P>
<P>};</P>
<P></P>
<P>The following example shows a simple implementation of the <B>ISRGramNotifySink::PhraseFinish</B> member function. The engine object calls <B>PhraseFinish</B> when the speaker has finished a phrase and the engine has recognized the words that were spoken. The member function receives the address of an <B>SRPHRASE</B> structure that includes one <B>SRWORD</B> structure for each recognized word in the phrase. The example parses the <B>SRPHRASE</B> structure, writes the words from the phrase into a buffer,  and then causes a WM_PAINT message to be sent to a window that draws the contents of the buffer. </P>
<P>STDMETHODIMP CISRGramNotifySink::PhraseFinish(DWORD dwFlags, <BR>    QWORD qTimeStampBegin, QWORD qTimeStampEnd, PSRPHRASE pSRPhrase,<BR>    LPUNKNOWN lpResults )</P>
<P>{</P>
<P>    DWORD dwCnt;     // count of SRPHRASE bytes processed</P>
<P>    SRWORD *psrWord;</P>
<P>    PBYTE pb;</P>
<P></P>
<P>    // Check the flags to determine whether to process the phrase.</P>
<P>    if (!((dwFlags &amp; ISRNOTEFIN_RECOGNIZED) &amp;&amp; </P>
<P>        (dwFlags &amp; ISRNOTEFIN_THISGRAMMAR)))</P>
<P>        return -1; </P>
<P></P>
<P>    // Initialize variables for processing the SRPHRASE structure.</P>
<P>    dwCnt = sizeof(pSRPhrase-&gt;dwSize); // account for size of dwSize</P>
<P>    psrWord = (SRWORD *) pSRPhrase-&gt;abWords; // point to first SRWORD</P>
<P>    pb = (PBYTE) psrWord; // initialize index pointer</P>
<P>    g_szPhrase[0] = '\0'; // makes lstrcat work properly</P>
<P></P>
<P>    // Process the SRPHRASE structure, stopping the entire contents </P>
<P>    // have been processed. </P>
<P>    while (dwCnt  pSRPhrase-&gt;dwSize) { </P>
<P></P>
<P>        // Copy word to buffer, followed by a space to separate words.</P>
<P>        lstrcat(g_szPhrase, (LPSTR) psrWord-szWord); </P>
<P>        lstrcat(g_szPhrase, " "); </P>
<P>        dwCnt += psrWord-dwSize; // add size of SRWORD to index</P>
<P>        pb += psrWord-dwSize;    // move index pointer to next SRWORD</P>
<P>        psrWord = (PSRWORD) pb;   // point to next SRWORD</P>
<P>    }</P>
<P></P>
<P>    // Cause a WM_PAINT so that the phrase is drawn in the window.</P>
<P>    InvalidateRect(g_hwndSR, NULL, TRUE);</P>
<P>    UpdateWindow(g_hwndSR);</P>
<P></P>
<P>    return NOERROR;</P>
<P>}</P>
<P></P></FONT></BODY></HTML>
