<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Custom Audio-Source Object</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,atial,helvetica" SIZE="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Custom Audio-Source Object</H3><P>A custom audio source can allow the application to do the following:</P>
<P> <FONT FACE="Symbol">·</FONT>    Recognize speech from an audio file — for example, to transcribe a recording of a meeting or telephone conversation.</P>
<P> <FONT FACE="Symbol">·</FONT>    Share incoming audio with another task. (The multimedia audio-source object does not support sharing a waveform-audio device.)</P>
<P> <FONT FACE="Symbol">·</FONT>    Recognize audio from hardware that does not support a multimedia driver.</P>
<P></P>
<P>To write an audio-source object, you would code the object's OLE COM framework and support three interfaces: <B>IUnknown</B>, <B>IAudio</B>, and <B>IAudioSource</B>. You might also define a custom interface that allows the application to control the audio source, such as an <B>IAudioFile</B> interface to specify which file to recognize from.</P>
<P>When an engine first receives the <B>IUnknown</B> for the audio source (see "Engine Selection" later in this section), it calls the <B>QueryInterface</B> member function for a variety of interfaces, such as those that control specific hardware. If the engine cannot find any of these custom interfaces, it eventually tries the <B>IAudio</B> and <B>IAudioSource </B>interfaces. The engine then calls the <B>IAudio::WaveFormatSet</B> member function with several different wave formats, starting with custom formats and working its way down to pulse-code modulation (PCM) if none of the earlier formats is supported. (The application must determine which formats are acceptable.) If the engine cannot find any interfaces or formats that it can use, it fails to create an engine object.</P>
<P>After the engine selects a wave format, it generates the engine object and returns from the call to the <B>ISRFind::Select</B> or <B>ISREnum::Select </B>member function. As the application calls functions on the engine object, that object calls functions on the audio source to get the needed digital audio, such as <B>IAudio::Start</B>, <B>IAudioSource::DataGet</B>, and so on.</P></FONT></BODY></HTML>
