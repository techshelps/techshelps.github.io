<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Adding Commands to a Voice Menu</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,atial,helvetica" SIZE="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<h2>Adding Commands to a Voice Menu</H2><P>After you create a voice-menu object, you can add commands to the menu by filling an array of <B>VCMDCOMMAND</B> structures, copying the address and size of the array into an <B>SDATA</B> structure, and passing the address of the <B>SDATA</B> structure to the <B>IVCmdMenu::Add</B> member function. </P>
<P>The example in this section shows how to add a new set of commands to a voice-menu object. The example consists of three functions: UseCommands, GetCommands, and NextCommand. The UseCommands function deactivates the voice menu, replaces any existing commands in the menu with a new set, and reactivates the menu. </P>
<P>One of the parameters to UseCommands is the address of a buffer containing the list of command strings to enter. UseCommands passes the address of the command-string buffer to the GetCommands function along with the address of an <B>SDATA</B> structure. The GetCommands function converts the buffer to an array of <B>VCMDCOMMAND</B> structures and copies the address and size of the array into the <B>SDATA</B> structure. The NextCommand function is a helper routine that GetCommands uses to retrieve individual command strings from the command buffer passed to UseCommands. </P>
<P>// UseCommands - adds commands to a voice-menu object, replacing any </P>
<P>//   existing commands.</P>
<P>// Returns the result code returned by a voice-menu function.</P>
<P>// pszCommands - address of a null-terminated string of commands </P>
<P>//   separated by \n or \r characters</P>
<P>// pMenu - address of the IVCmdMenu interface for the voice-menu object</P>
<P>HRESULT UseCommands (char *pszCommands, PIVCMDMENU pMenu)</P>
<P>{</P>
<P>    HRESULT hRes;</P>
<P>    SDATA   data;</P>
<P>    DWORD   dwNum, dwStart;</P>
<P></P>
<P>hRes = pMenu-&gt;Deactivate(); // deactivate the menu</P>
<P>if (hRes) return hRes;</P>
<P></P>
<P>// Retrieve the number of commands in the menu.</P>
<P>hRes = pMenu-&gt;Num(&amp;dwNum); </P>
<P>if (hRes) return hRes;</P>
<P></P>
<P>// Remove the existing commands from the menu.</P>
<P>if (dwNum)</P>
<P>   hRes = pMenu-&gt;Remove (1, dwNum, VCMD_BY_POSITION);</P>
<P>if (hRes) return hRes;</P>
<P></P>
<P>// Call GetCommands, an application-defined function that fills an SDATA </P>
<P>// structure with information about the commands to add to the menu.</P>
<P>if (!GetCommands(pszCommands, &amp;data, &amp;dwNum))</P>
<P>   return ResultFromScode (E_OUTOFMEMORY);</P>
<P></P>
<P>// Add the commands to the menu.</P>
<P>hRes = pMenu-&gt;Add (dwNum, data, &amp;dwStart);</P>
<P>if (hRes) return hRes;</P>
<P></P>
<P>// Free the command data. </P>
<P>free (data.pData);</P>
<P></P>
<P>// Reactivate the menu.</P>
<P>hRes = pMenu-&gt;Activate(ghwndDialog, 0);</P>
<P>return hRes;</P>
<P>}</P>
<P></P>
<P></P>
<P>// GetCommands - takes a block of memory containing command strings and </P>
<P>//   converts it into a list of VCMDCOMMAND structures.</P>
<P>// Returns TRUE if successful or FALSE otherwise.</P>
<P>// pszMemory - address of a null-terminated string of commands </P>
<P>//   separated by \n or \r characters</P>
<P>// pData - address of an SDATA structure that receives the address and </P>
<P>//   size of the memory containing the VCMDCOMMAND structures. The </P>
<P>//   caller must free the memory by using the free function.</P>
<P>// pdwNumCommands - receives the count of VCMDCOMMAND structures in the </P>
<P>//   memory block</P>
<P>BOOL GetCommands(char *pszMemory, PSDATA pData, DWORD *pdwNumCommands)</P>
<P>{</P>
<P>    PSTR  pTemp;</P>
<P>    DWORD dwTotal, dwSize, dwSizeDesc, dwSizeCat;</P>
<P>    DWORD dwSizeCmd;</P>
<P>    PVCMDCOMMAND pCmd, pCmdNew;</P>
<P>    CHAR    *pszBegin;</P>
<P>    DWORD   dwCmdSize;</P>
<P>    DWORD   dwCmds = 0;  // current count</P>
<P>    DWORD   dwCount = 1; // command number</P>
<P>    char    szCat[] = "Main";</P>
<P></P>
<P>    dwTotal = dwSize = 0;</P>
<P></P>
<P>    pTemp = (PSTR) malloc(0);</P>
<P>    if (!pTemp)</P>
<P>        return FALSE;</P>
<P></P>
<P>    pCmd = (PVCMDCOMMAND) pTemp;</P>
<P>    for( ;; ) {</P>
<P>        // Retrieve the next command from the list of command strings.</P>
<P>        pszMemory = NextCommand (pszMemory, &amp;pszBegin, &amp;dwCmdSize);</P>
<P>        if (!pszMemory)</P>
<P>            break;   // no more</P>
<P></P>
<P>        dwSize = sizeof(VCMDCOMMAND); // size of header</P>
<P>        dwSizeCmd = (dwCmdSize + 1);  // get command-string length</P>
<P></P>
<P>        // Align the command string on a doubleword boundary. </P>
<P>        dwSizeCmd += 3;</P>
<P>        dwSizeCmd &amp;= (~3);</P>
<P>        dwSize += dwSizeCmd;</P>
<P></P>
<P>        dwSizeDesc = (dwCmdSize + 1); // get description length</P>
<P></P>
<P>        // Align the description on a doubleword boundary. </P>
<P>        dwSizeDesc += 3;</P>
<P>        dwSizeDesc &amp;= (~3);</P>
<P>        dwSize += dwSizeDesc;</P>
<P></P>
<P>        dwSizeCat = lstrlen(szCat) + 1; // get category length</P>
<P></P>
<P>        // Align the category string on a doubleword boundary.</P>
<P>        dwSizeCat += 3;</P>
<P>        dwSizeCat &amp;= (~3);</P>
<P>        dwSize += dwSizeCat;</P>
<P></P>
<P>        dwSize += sizeof(DWORD); // action indicator</P>
<P></P>
<P>        // Accumulate the total size of the command.</P>
<P>        dwTotal += dwSize;</P>
<P></P>
<P>        // Reallocate enough memory to hold the command.</P>
<P>        pTemp = (PSTR) realloc((PVOID) pCmd, dwTotal);</P>
<P></P>
<P>        // Fill the new VCMDCOMMAND structure.</P>
<P>        pCmd = (PVCMDCOMMAND) pTemp;</P>
<P>        pTemp += (dwTotal-dwSize);</P>
<P>        pCmdNew = (PVCMDCOMMAND) pTemp;</P>
<P>        memset (pCmdNew, 0, dwSize);</P>
<P></P>
<P>        pCmdNew-&gt;dwSize = dwSize;</P>
<P>        pCmdNew-&gt;dwFlags = 0;</P>
<P>        pCmdNew-&gt;dwAction = (DWORD) (pCmdNew-&gt;abData - (PBYTE) pTemp);</P>
<P>        pCmdNew-&gt;dwActionSize = sizeof(DWORD);</P>
<P>        pCmdNew-&gt;dwCommandText = NULL;</P>
<P></P>
<P>        // Point past the header to the beginning of the command data.</P>
<P>        pTemp += (pCmdNew-&gt;abData - (PBYTE) pTemp);</P>
<P></P>
<P>        // Set the action index.</P>
<P>        *(DWORD *) pTemp = dwCount++;</P>
<P>        pTemp += sizeof(DWORD);</P>
<P></P>
<P>        // Set the command string.</P>
<P>        pCmdNew-&gt;dwCommand = (DWORD) ((PBYTE) pTemp - (PBYTE) pCmdNew);</P>
<P>        strncpy(pTemp, pszBegin, dwCmdSize);</P>
<P>        pTemp += dwSizeCmd;</P>
<P></P>
<P>        // Set the description.</P>
<P>        pCmdNew-&gt;dwDescription = </P>
<P>            (DWORD) ((PBYTE) pTemp - (PBYTE) pCmdNew);</P>
<P>        strncpy(pTemp, pszBegin, dwCmdSize);</P>
<P>        pTemp += dwSizeDesc;</P>
<P></P>
<P>        // Set the category.</P>
<P>        pCmdNew-&gt;dwCategory = (DWORD) ((PBYTE) pTemp - (PBYTE) pCmdNew);</P>
<P>        strcpy(pTemp, szCat);</P>
<P></P>
<P>        // Increment the count of commands.</P>
<P>        dwCmds++;</P>
<P>    }</P>
<P></P>
<P>    pData-pData = (PVOID) pCmd;</P>
<P>    pData-dwSize = dwTotal;</P>
<P>    *pdwNumCommands = dwCmds;</P>
<P>    return TRUE;</P>
<P>}</P>
<P></P>
<P></P>
<P>// NextCommand - finds the next command in a block of memory.</P>
<P>// Returns the address of the next command string in the block, or NULL </P>
<P>//   if no command string is found.</P>
<P>// pszMemory - address of a null-terminated string of commands </P>
<P>//   separated by \n or \r characters</P>
<P>// pBegin - receives the address of the next command string</P>
<P>// pdwSize - receives the number of bytes in the command string, not </P>
<P>//   including any terminating NULL character</P>
<P></P>
<P>CHAR * NextCommand (CHAR *pszMemory, PCHAR *pBegin, DWORD *pdwSize)</P>
<P>{</P>
<P>    DWORD i;</P>
<P></P>
<P>    for( ;; ) {</P>
<P>        // Try to find a non-newline character.</P>
<P>        while ((*pszMemory == '\n') || (*pszMemory == '\r')) {</P>
<P>            if (*pszMemory == '\0')</P>
<P>                return NULL;</P>
<P>            pszMemory++;</P>
<P>        };</P>
<P></P>
<P>    // Try to find a newline character.</P>
<P>    for (i = 0;</P>
<P>        (pszMemory[i] != '\n') &amp;&amp; (pszMemory[i] != '\r') &amp;&amp; </P>
<P>            (pszMemory[i] != '\0'); i++);</P>
<P>    if (!i) {</P>
<P>        if (!pszMemory[i])</P>
<P>            return NULL; // end</P>
<P>        pszMemory++;</P>
<P>        continue;        // try again</P>
<P>      };</P>
<P></P>
<P>    // A string was found. Return it. </P>
<P>    *pBegin = pszMemory;</P>
<P>    *pdwSize = i;</P>
<P>    return pszMemory + i;</P>
<P>    };</P>
<P>}</P>
<P></P></FONT></BODY></HTML>
