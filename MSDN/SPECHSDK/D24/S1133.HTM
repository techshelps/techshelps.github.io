<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Sample</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,atial,helvetica" SIZE="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Sample</H3><P>Adding voice commands is fairly simple. An application using these would only have to make the following modifications:</P>
<P>CoCreateInstance (CLSID_VCmd, NULL, CLSCTX_LOCAL_SERVER, IID_IVoiceCmd, &amp;pIVoiceCommand); </P>
<P>CoCreateInstance() instantiates a local copy of the Voice Commands Object.</P>
<P>pIVCmdNotifySink = new CMyIVCmdNotifySink;</P>
<P>This creates a instance of the CMyIVCmdNotifySink class that receives notifications when the user says a command. The functionality of the class is specific to the application.</P>
<P>pIVoiceCommand-&gt;Register ("", pIVCmdNotifySink, IID_IVCmdNotifySink, 0, NULL);</P>
<P>Calling Register informs the voice-commands object of the notification sink and also specifies where the audio is to come from.</P>
<P>sData.pData = a pointer to a list of VCMDCOMMAND structures;</P>
<P>sData.dwSize = size of the memory pointed to by sData.pData;</P>
<P>Next, the application must include a list of VCMDCOMMAND structures. Each structure contains a command ("Open a file"), description ("This opens a file from the disk"), command ID for identification, and a few other parameters. The commands are specific to the application.</P>
<P>strcpy (VCmdName.szApplication, "Application Name");</P>
<P>strcpy (VCmdName.szState, "Main");</P>
<P>pIVoiceCommand-&gt;MenuCreate (&amp;VCmdName, NULL, VCMDMC_CREATE_TEMP, &amp;pIVCmdMenu);</P>
<P>pIVCmdMenu-&gt;Add (number of commands, sData, NULL);</P>
<P>The code above creates an instance of a Voice menu object using the commands specified in sData. The menu generated in this example is temporary, but menus can be saved to a system storage, similar to the registry, so that an application doesn't have to reconstruct the VCMDCOMMAND structures every time.</P>
<P>pIVCmdMenu-&gt;Activate (hWnd, 0);</P>
<P>Calling Activate causes the speech-recognition engine to start "listening" for the specified commands whenever the window, hWnd, is active.</P>
<P>Once the application has called Activate, speech recognition will begin listening. When the user says one of the commands in the menu, the notification sink will be called with pIVCmdNotifySink-&gt;CommandRecognize (..., dwID, ...). dwID contains the ID command spoken, just like a Windows menu. Other notifications such as the VU-meter also come through, but most applications will only care about dWID.</P>
<P>When an application is no longer required to get recognitions for the menu anymore, it simply calls:</P>
<P>pIVCmdMenu-&gt;Deactivate ();</P>
<P>Finally, when the application shuts down, it releases the object:</P>
<P>pIVCmdMenu-&gt;Release();</P>
<P>pIVoiceCommand-&gt;Release();</P>
<P>Wait until pIVCmdNotifySink is released by engine.</P>
<P>That's a concise overview of how this high-level interface works.</P></FONT></BODY></HTML>
