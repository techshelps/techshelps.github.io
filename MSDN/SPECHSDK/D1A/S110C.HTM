<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Porting an Existing Text-to-Speech Engine</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,atial,helvetica" SIZE="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Porting an Existing Text-to-Speech Engine</H3><P>Typically, an engine developer ports the code for an existing text-to-speech engine from 16-bit Windows, UNIX, Macintosh, or OS/2, rather than develop a completely new engine. Porting a text-to-speech engine to the text-to-speech API usually involves these steps:</P>
<P>    1.    Port the engine code to Win32 by using the API that is already in the code. This should be straightforward, but be aware that this may uncover old bugs because Win32 is more stringent about memory.</P>
<P>    2.    Move the engine code into a DLL.</P>
<P>    3.    Implement the major interfaces for text-to-speech translation first to get the engine running with the speech API as quickly as possible.</P>
<P>    4.    Redesign the engine's audio input and output architecture to use streams. Using streams makes the engine consistent with the multimedia audio source and multimedia audio-destination objects, which also use streams. These objects are similar to multimedia wave-in and wave-out drivers. </P>
<P>    5.    Design the engine's interface architecture to support the interfaces defined for the text-to-speech engine object.</P>
<P>    6.    Implement the text-to-speech interfaces and functions for the engine.</P>
<P>    7.    Write additional code to enable the engine to support multiple instances. The time required to do this varies depending upon the engine's internal architecture.</P>
<P></P>
<P>The engine must provide the engine enumerator and the engine object. The following table lists the required and optional interfaces for each object.</P>
<P>The engine should support both ANSI and Unicode implementations of each interface.</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="168pt" VALIGN="TOP"><COL WIDTH="180pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Class</P></TD><TD VALIGN="TOP"><P>Interface</P></TD></TR><TR><TD COLSPAN="2" VALIGN="TOP"><P></P></TD></TR><TR><TD VALIGN="TOP"><P>Engine enumerator</P></TD><TD VALIGN="TOP"><P><B>ITTSEnum<BR>ITTSFind</B> (optional)</P></TD></TR><TR><TD VALIGN="TOP"><P>Engine</P></TD><TD VALIGN="TOP"><P><B>ILexPronounce</B> (optional)<BR><B>ITTSAttributes<BR>ITTSCentral<BR>ITTSDialogs</B></P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>
<P>The engine should also support the following notification sinks to pass information back to the application.</P>
<P> <FONT FACE="Symbol">·</FONT>    <B>ITTSBufNotifySink</B>.  Notify the application of changes to the buffer that contains the text being spoken.</P>
<P> <FONT FACE="Symbol">·</FONT>    <B>ITTSNotifySink</B>.  Notify the application of the phoneme being spoken or that audio has started or stopped.</P>
<P></P></FONT></BODY></HTML>
