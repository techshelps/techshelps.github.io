<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Buffering Text with ITTSCentral::TextData</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,atial,helvetica" SIZE="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>Buffering Text with ITTSCentral::TextData</H3><P>For buffering and playing back text, Microsoft suggests the following approach, which uses the <B>ITTSCentral::TextData</B>, <B>ITTSCentral::AudioPause</B>, and <B>ITTSCentral::AudioResume </B>member functions. More complex schemes using threads can be easily derived from this scheme.</P>
<P>    1.    When the text-to-speech engine object is first created, it is in a playback state. Calling the <B>ITTSCentral::AudioPause</B> member function pauses the engine; calling the <B>ITTSCentral::AudioResume</B> member function returns it to the playback state.</P>
<P>    2.    The engine maintains an internal linked list of text buffers. Initially, the list is empty.</P>
<P>    3.    When the application calls the <B>ITTSCentral::TextData</B> member function with new data, the engine allocates memory for the data, copies the text into the memory, and adds the memory to the linked list. If the buffer was empty and the engine is in the playback state, the engine calls <B>TextToAudio</B>, an internal function that processes the data.</P>
<P>    4.    Reading from a position at the top of the linked list, <B>TextToAudio</B> converts the list to phonemes and then into digital audio. The engine then calls the <B>IAudioDest::DataSet</B> member function to pass the data to the audio-destination object, continuing until the digital-audio object cannot take any more data. Note that if the engine is paused, the <B>IAudioDest::DataSet</B> member function does nothing.</P>
<P>    5.    In the background, the audio-destination object's internal buffer gradually empties as the digital audio is played over the speaker. When the status of the internal buffer changes, the audio-destination object notifies the engine, which then calls <B>TextToAudio</B> to convert more data.</P>
<P>    6.    When the application calls the <B>ITTSCentral::AudioPause</B> member function on the engine, the engine is paused and it calls the <B>IAudio::Stop</B> member function on the audio-destination object.</P>
<P>    7.    When the application calls the <B>ITTSCentral::AudioResume</B> member function on the engine, the engine resumes playback and calls the <B>IAudio::Start</B> member function on the audio-destination object.</P></FONT></BODY></HTML>
