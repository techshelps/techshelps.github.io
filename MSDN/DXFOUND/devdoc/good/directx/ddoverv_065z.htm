<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Creating an Off-Screen Surface</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h4><a name="_dx5_creating_an_off_screen_surface_ddraw"></a>Creating an Off-Screen Surface</h4>
<p>
An off-screen surface is often used to cache bitmaps that will later be blitted to the primary surface or a back buffer. You must declare the dimensions of an off-screen surface by including the DDSC_WIDTH and DDSD_HEIGHT flags and the corresponding values in the <b>dwWidth</b> and <b>dwHeight</b> members. Additionally, you must include the DDSCAPS_OFFSCREENPLAIN flag in the accompanying <a href="ddref_7mlz.htm"><b>DDSCAPS</b></a> structure.</p>
<p>
By default, DirectDraw creates a surface in display memory unless it will not fit, in which case it creates the surface in system memory. You can explicitly choose display or system memory by including the DDSCAPS_SYSTEMMEMORY or DDSCAPS_VIDEOMEMORY flags in the <b>dwCaps</b> member of the <a href="ddref_7mlz.htm"><b>DDSCAPS</b></a> structure. The method fails, returning an error, if it can't create the surface in the specified location.</p>
<p>
The following example shows how to prepare for creating a simple off-screen surface.</p>
<pre><code>DDSURFACEDESC ddsd; 
ddsd.dwSize = sizeof(ddsd); 
 
// Tell DirectDraw which members are valid. 
ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH; 
 
// Request a simple off-screen surface, sized 
// 100 by 100 pixels. 
//
// (This assumes that the offscreen surface we are about
// to create will match the pixel format of the 
// primary surface.)
ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN; 
dwHeight = 100; 
dwWidth = 100; 
 </code></pre>
<p>
Additionally, you can create surfaces whose pixel format differs from the primary surface's pixel format. However, in this case there is one drawback — you are limited to using system memory. The following code fragment shows how to prepare the <a href="ddref_8hbr.htm"><b>DDSURFACEDESC</b></a> structure members in order to create an 8-bit palettized surface (assuming that the current display mode is something other than 8-bits per pixel).</p>
<pre><code>ZeroMemory(&amp;ddsd, sizeof(ddsd));
ddsd.dwSize  = sizeof(ddsd);
ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT;
ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN | DDSCAPS_SYSTEMMEMORY;
ddsd.dwHeight = 100;
ddsd.dwWidth  = 100;
ddsd.ddpfPixelFormat.dwSize  = sizeof(DDPIXELFORMAT);
ddsd.ddpfPixelFormat.dwFlags = DDPF_RGB | DDPF_PALETTEINDEXED8;

// Set the bit depth for an 8-bit surface, but DO NOT 
// specify any RGB mask values. The masks must be zero
// for a palettized surface.
ddsd.ddpfPixelFormat.dwRGBBitCount = 8;
 </code></pre>
<p>
In previous versions of DirectX, the maximum width of off-screen surfaces was limited to the width of the primary surface. With DirectX 5, you can create surfaces as wide as you need, permitting that the display hardware can support them. Be careful when declaring wide off-screen surfaces; if the video card memory cannot hold a surface as wide as you request, the surface is created in system memory. If you explicitly choose video memory and the hardware can't support it, the call fails. For more information, see <a href="ddoverv_8caf.htm">Creating Wide Surfaces</a>.</p>
<p>&nbsp;</p></body>
</HTML>
