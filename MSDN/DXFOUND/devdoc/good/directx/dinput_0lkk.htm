<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IDirectInputDevice::SetEventNotification</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_dx5_idirectinputdevice_seteventnotification_dinput"></a>IDirectInputDevice::SetEventNotification</h1>
<p>
The <b>IDirectInputDevice::SetEventNotification</b> method sets the event notification status. This method specifies an event that is to be set when the device state changes. It is also used to turn off event notification.</p>
<pre><code><b>HRESULT SetEventNotification(
  HANDLE</b><i> hEvent  </i>
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>hEvent</i></dt>
<dd>
Handle to the event that is to be set when the device state changes. DirectInput will use the Win32 <b>SetEvent</b> function on the handle when the state of the device changes. If the <i>hEvent</i> parameter is NULL, then notification is disabled. 
<p>
The application may create the handle as either a manual-reset or automatic-reset event by using the Win32 <b>CreateEvent</b> function. If the event is created as an automatic-reset event, then the operating system will automatically reset the event once a wait has been satisfied. If the event is created as a manual-reset event, then it is the application's responsibility to call the Win32 <b>ResetEvent</b> function to reset it. DirectInput will not call the Win32 <b>ResetEvent</b> function for event notification handles. Most applications will create the event as an automatic-reset event.

</dd>
</dl>
<h4>Return Values</h4>
<p>
If the method succeeds, the return value is DI_OK or <a href="dinput_7yk4.htm#_dx5_di_polleddevice_dinput">DI_POLLEDDEVICE</a>.</p>
<p>
If the method fails, the return value may be one of the following error values:</p>
<table cellspacing=4 cols=1>
<tr valign=top>
<td width=100%><a href="dinput_7yk4.htm#_dx5_dierr_acquired_dinput">DIERR_ACQUIRED</a> </td>
</tr>
<tr valign=top>
<td width=100%><a href="dinput_7yk4.htm#_dx5_dierr_handleexists_dinput">DIERR_HANDLEEXISTS</a> </td>
</tr>
<tr valign=top>
<td width=100%><a href="dinput_7yk4.htm#_dx5_dierr_invalidparam_dinput">DIERR_INVALIDPARAM</a> </td>
</tr>
<tr valign=top>
<td width=100%><a href="dinput_7yk4.htm#_dx5_dierr_notinitialized_dinput">DIERR_NOTINITIALIZED</a> </td>
</tr>
</table><br>
<h4>Remarks</h4>
<p>
A device state change is defined as any of the following:
<ul>
<li>
A change in the position of an axis</li>
<li>
A change in the state (pressed or released) of a button</li>
<li>
A change in the direction of a POV control</li>
<li>
Loss of acquisition</li>
</ul>
<p>
Do not call the Win32 <b>CloseHandle</b> function on the event while it has been selected into a DirectInputDevice object. You must call this method with the <i>hEvent</i> parameter set to NULL before closing the event handle.</p>
<p>
The event notification handle cannot be changed while the device is acquired. If the function is successful, then the application can use the event handle in the same manner as any other Win32 event handle.</p>
<p>
The following example checks if the handle is currently set without blocking:</p>
<pre><code>dwResult = WaitForSingleObject(hEvent, 0); 
if (dwResult == WAIT_OBJECT_0) { 
    // Event is set. If the event was created as 
    // automatic-reset, then it has also been reset. 
} 
 </code></pre>
<p>
The following example illustrates blocking indefinitely until the event is set. Note that this behavior is strongly discouraged because the thread will not respond to the system until the wait is satisfied. In particular, the thread will not respond to Windows messages.</p>
<pre><code>dwResult = WaitForSingleObject(hEvent, INFINITE); 
if (dwResult == WAIT_OBJECT_0) { 
    // Event has been set. If the event was created 
    // as automatic-reset, then it has also been reset. 
} 
 </code></pre>
<p>
The following example illustrates a typical message loop for a message-based application that uses two events:.</p>
<pre><code>HANDLE ah[2] = { hEvent1, hEvent2 }; 
 
while (TRUE) { 
 
    dwResult = MsgWaitForMultipleObjects(2, ah, FALSE, 
                        INFINITE, QS_ALLINPUT); 
    switch (dwResult) { 
    case WAIT_OBJECT_0: 
        // Event 1 has been set. If the event was created as
        // automatic-reset, then it has also been reset. 
        ProcessInputEvent1(); 
        break; 
 
    case WAIT_OBJECT_0 + 1: 
        // Event 2 has been set. If the event was created as
        // automatic-reset, then it has also been reset. 
        ProcessInputEvent2(); 
        break; 
 
    case WAIT_OBJECT_0 + 2: 
        // A Windows message has arrived. Process 
        // messages until there aren't any more. 
        while(PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)){ 
            if (msg.message == WM_QUIT) { 
                goto exitapp; 
            } 
            TranslateMessage(&amp;msg); 
            DispatchMessage(&amp;msg); 
        } 
        break; 
 
    default: 
        // Unexpected error. 
        Panic(); 
        break; 
    } 
} 
 </code></pre>
<p>
The following example illustrates a typical application loop for a non-message-based application that uses two events:</p>
<pre><code>HANDLE ah[2] = { hEvent1, hEvent2 }; 
DWORD dwWait = 0; 
 
while (TRUE) { 
 
    dwResult = MsgWaitForMultipleObjects(2, ah, FALSE, 
                                         dwWait, QS_ALLINPUT); 
    dwWait = 0; 
 
    switch (dwResult) { 
    case WAIT_OBJECT_0: 
        // Event 1 has been set. If the event was 
        // created as automatic-reset, then it has also 
        // been reset. 
        ProcessInputEvent1(); 
        break; 
 
    case WAIT_OBJECT_0 + 1: 
        // Event 2 has been set. If the event was 
        // created as automatic-reset, then it has also 
        // been reset. 
        ProcessInputEvent2(); 
        break; 
 
    case WAIT_OBJECT_0 + 2: 
        // A Windows message has arrived. Process 
        // messages until there aren't any more. 
        while(PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)){ 
            if (msg.message == WM_QUIT) { 
                goto exitapp; 
            } 
            TranslateMessage(&amp;msg); 
            DispatchMessage(&amp;msg); 
        } 
        break; 
 
    default: 
        // No input or messages waiting. 
        // Do a frame of the game. 
        // If the game is idle, then tell the next wait 
        // to wait indefinitely for input or a message. 
        if (!DoGame()) { 
            dwWait = INFINITE; 
        } 
        break; 
    } 
} 
 </code></pre>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Use version 5.0 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Use Windows 95 or later. Available as a redistributable for Windows 95.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in dinput.h.<br>
<b>&nbsp;&nbsp;Import Library: </b>Use dinput.lib.</p>
<h4>See Also</h4>
<p>
<a href="dinput_1zqs.htm">Polling and Events</a></p>
<pre></pre>
<p>&nbsp;</p></body>
</HTML>
