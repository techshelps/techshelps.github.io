<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Objects and Interfaces</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_dx5_objects_and_interfaces_d3d"></a>Objects and Interfaces</h3>
<p>
DirectDraw presents programmers with a single, unified object that encapsulates both the DirectDraw and Direct3D states. When you create a DirectDraw object and then use the <a href="dxintro_0pgv.htm"><b>IDirectDraw2::QueryInterface</b></a> method to obtain an IDirect3D2 interface, the <a href="glossary_14qb.htm#_dx5_reference_count_glos">reference count</a> of the DirectDraw object is 2.</p>
<p>
The important implication of this is that the lifetime of the Direct3D driver state is the same as that of the DirectDraw object. Releasing the Direct3D interface does not destroy the Direct3D driver state. That state is not destroyed until all references to that object—whether they are DirectDraw or Direct3D references—have been released. Therefore, if you release a Direct3D interface while holding a reference to a DirectDraw driver interface, and then query the Direct3D interface again, the Direct3D state will be preserved.</p>
<p>
In DirectX 2 and DirectX 3, a Direct3D device was aggregated off a DirectDraw surface—that is, <b>IDirect3DDevice</b> and <b>IDirectDrawSurface</b> were two interfaces to the same object. A given Direct3D object supported multiple 3-D device types. The <b>IDirect3D</b> interface was used to find or enumerate the device types. The <a href="d3dimref_1e3o.htm"><b>IDirect3D::EnumDevices</b></a> and <a href="d3dimref_423o.htm"><b>IDirect3D::FindDevice</b></a> methods identified the various device types by unique interface IDs (IIDs), which were then used to retrieve a Direct3D device interface by calling the <b>QueryInterface </b>method on a DirectDraw surface. The lifetimes of the DirectDraw surface and the Direct3D device were identical, since the same object implemented them. This architecture did not allow the programmer to change the rendering target of the Direct3D device</p>
<p>
In DirectX 5 there are two models of Direct3D device objects. In the new model, Direct3D devices are separate objects from DirectDraw surface objects. For backward compatibility with DirectX 3 applications, the earlier model, in which Direct3D devices and DirectDraw surfaces were aggregated, is also supported. You cannot use the new DirectX 5 features with the old model. If your application calls the <b>QueryInterface</b> method on a DirectDraw surface and retrieves an <b>IDirect3DDevice</b>, it is using the old device model. You cannot call the <b>QueryInterface</b> method on a device object created in this way to retrieve an <b>IDirect3DDevice2</b> interface.</p>
<p>
It is recommended that all applications written with the DirectX 5 Programmer's Reference use the new device object model. </p>
<p>
In DirectX 5, the new device model has the Direct3D device as a separate object from a DirectDraw surface. The <b>IDirect3D2</b> interface is used to find or enumerate the types of devices supported. However, <b>IDirect3D2</b> identifies devices by unique IDs known as class IDs in COM (CLSID). These are used to uniquely identify one of the various classes that implement a given interface. Since there are multiple Direct3D devices with different capabilities (some software based, some hardware based), but each supports the same set of interfaces, a CLSID is used to identify which type of device object we want. The CLSID obtained from <a href="d3dimref_423o.htm"><b>IDirect3D2::FindDevice</b></a> or <a href="d3dimref_1e3o.htm"><b>IDirect3D2::EnumDevices</b></a> is then used in a call to the <a href="d3dimref_0dus.htm"><b>IDirect3D2::CreateDevice</b></a> method to create a device. The device objects created in this fashion support both <b>IDirect3DDevice</b> and <b>IDirect3DDevice2</b> interfaces. Unlike in DirectX 3, however, you cannot call QueryInterface on these objects to retrieve an <b>IDirectDrawSurface</b> interface. Instead, you must use the <a href="d3dimref_5jj8.htm"><b>IDirect3DDevice2::GetRenderTarget</b></a> method.</p>
<p>
The <b>IDirect3DTexture</b> interface is not an interface to a distinct object type, but instead is another interface to a DirectDrawSurface object. The same rules for reference counts and state lifetimes that apply to <b>IDirect3D2</b> interfaces to DirectDraw objects also apply to Direct3D textures. </p>
<p>
The DirectDraw HEL supports the creation of texture, <a href="glossary_129f.htm#_dx5_mipmap_glos">mipmap</a>, and z-buffer surfaces. Furthermore, because of the tight integration of DirectDraw and Direct3D, a DirectDraw-enabled system always provides Direct3D support (in software emulation, at least). Therefore, the DirectDraw HEL exports the DDSCAPS_3DDEVICE flag to indicate that a surface can be used for 3-D rendering. DirectDraw drivers for hardware-accelerated 3-D display cards export this capability to indicate the presence of hardware-accelerated 3-D.</p>
<p>&nbsp;</p></body>
</HTML>
