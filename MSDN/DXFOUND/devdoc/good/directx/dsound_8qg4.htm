<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Access to the Primary Buffer</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_dx5_access_to_the_primary_buffer_dsound"></a>Access to the Primary Buffer</h3>
<p>
For applications that require specialized mixing or other effects not supported by secondary buffers, DirectSound allows direct access to the primary buffer. </p>
<p>
When you obtain write access to a <a href="glossary_33qr.htm#_dx5_primary_sound_buffer_glos">primary sound buffer</a>, other DirectSound features become unavailable. Secondary buffers are not mixed and, consequently, hardware-accelerated mixing is unavailable.</p>
<p>
Most applications should use secondary buffers instead of directly accessing the primary buffer. Applications can write to a secondary buffer easily because the larger buffer size provides more time to write the next block of data, thereby minimizing the risk of gaps in the audio. Even if an application has simple audio requirements, such as using one stream of audio data that does not require mixing, it will achieve better performance by using a secondary buffer to play its audio data.</p>
<p>
You cannot specify the size of the primary buffer, and you must accept the returned size after the buffer is created. A primary buffer is typically very small, so if your application writes directly to this kind of buffer, it must write blocks of data at short intervals to prevent the previously written data from being replayed.</p>
<p>
You create an accessible primary buffer by specifying the DSBCAPS_PRIMARYBUFFER flag in the <a href="dsound_1010.htm"><b>DSBUFFERDESC</b></a> structure passed to the <a href="dsound_0604.htm"><b>IDirectSound::CreateSoundBuffer</b></a> method. If you want to write to the buffer, the cooperative level must be DSSCL_WRITEPRIMARY.</p>
<p>
Primary sound buffers must be played with looping. Ensure that the DSBPLAY_LOOPING flag is set.</p>
<p>
The following example shows how to obtain write access to the primary buffer:</p>
<pre><code>BOOL AppCreateWritePrimaryBuffer( 
    LPDIRECTSOUND lpDirectSound, 
    LPDIRECTSOUNDBUFFER *lplpDsb, 
    LPDWORD lpdwBufferSize, 
    HWND hwnd) 
{ 
    DSBUFFERDESC dsbdesc; 
    DSBCAPS dsbcaps; 
    HRESULT hr; 
    // Set up wave format structure. 
    memset(&amp;pcmwf, 0, sizeof(PCMWAVEFORMAT)); 
    pcmwf.wf.wFormatTag = WAVE_FORMAT_PCM; 
    pcmwf.wf.nChannels = 2; 
    pcmwf.wf.nSamplesPerSec = 22050; 
    pcmwf.wf.nBlockAlign = 4; 
    pcmwf.wf.nAvgBytesPerSec = 
        pcmwf.wf.nSamplesPerSec * pcmwf.wf.nBlockAlign; 
    pcmwf.wBitsPerSample = 16; 
    // Set up DSBUFFERDESC structure. 
    memset(&amp;lplpDsb, 0, sizeof(DSBUFFERDESC)); // Zero it out. 
    dsbdesc.dwSize = sizeof(DSBUFFERDESC); 
    dsbdesc.dwFlags = DSBCAPS_PRIMARYBUFFER; 
    // Buffer size is determined by sound hardware. 
    dsbdesc.dwBufferBytes = 0; 
    dsbdesc.lpwfxFormat = NULL; // Must be NULL for primary buffers. 
 
    // Obtain write-primary cooperative level. 
    hr = lpDirectSound-&gt;lpVtbl-&gt;SetCooperativeLevel(lpDirectSound, 
        hwnd, DSSCL_WRITEPRIMARY); 
    if (DS_OK == hr) { 
        // Succeeded. Try to create buffer. 
        hr = lpDirectSound-&gt;lpVtbl-&gt;CreateSoundBuffer(lpDirectSound, 
            &amp;dsbdesc, lplpDsb, NULL); 
        if (DS_OK == hr) { 
            // Succeeded. Set primary buffer to desired format. 
            hr = (*lplpDsb)-&gt;lpVtbl-&gt;SetFormat(*lplpDsb, &amp;pcmwf); 
            if (DS_OK == hr) { 
                // If you want to know the buffer size, call GetCaps. 
                    dsbcaps.dwSize = sizeof(DSBCAPS); 
                (*lplpDsb)-&gt;lpVtbl-&gt;GetCaps(*lplpDsb, &amp;dsbcaps); 
                *lpdwBufferSize = dsbcaps.dwBufferBytes; 
                return TRUE; 
            } 
        } 
    } 
    // SetCooperativeLevel failed. 
    // CreateSoundBuffer, or SetFormat. 
    *lplpDsb = NULL; 
    *lpdwBufferSize = 0; 
    return FALSE; 
} 
 </code></pre>
<p>
You cannot obtain write access to a primary buffer unless it exists in hardware. To determine whether this is the case, call the <a href="dsound_43xg.htm"><b>IDirectSoundBuffer::GetCaps</b></a> method and check for the DSBCAPS_LOCHARDWARE flag in the <b>dwFlags</b> member of the <a href="dsound_886c.htm"><b>DSBCAPS</b></a> structure that is returned. If you attempt to lock a primary buffer that is emulated in software, the call will fail.</p>
<p>
You may also create a primary buffer object without write access, by specifying a cooperative level other than DSSCL_WRITEPRIMARY. One reason for doing this would be to call the <a href="dsound_7rz8.htm"><b>IDirectSoundBuffer::Play</b></a> method for the primary buffer, in order to eliminate problems associated with frequent short periods of silence. For more information, see <a href="dsound_5l5w.htm">Playing the Primary Buffer Continuously</a>.</p>
<p>
See also <a href="dsound_9ip0.htm">Custom Mixers</a>.</p>
<p>&nbsp;</p></body>
</HTML>
