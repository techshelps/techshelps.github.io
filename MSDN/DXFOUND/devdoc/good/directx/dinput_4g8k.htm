<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Step 6: Retrieving Data from the Joystick</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_dx5_step_6_retrieving_data_from_the_joystick_dinput"></a>Step 6: Retrieving Data from the Joystick</h3>
<p>
Since your application is more likely concerned with the position of the joystick axes than with their movement, you will probably want to retrieve immediate rather than buffered data from the device. You can do this by polling with <a href="dinput_0aes.htm"><b>IDirectInputDevice::GetDeviceState</b></a>. Remember, not all device drivers will notify DirectInput when the state of the device changes, so it's always good policy to call the <a href="dinput_46d0.htm"><b>IDirectInputDevice2::Poll</b></a> method before checking the device state.</p>
<p>
The Space Donuts application calls the following function on each pass through the rendering loop, provided the joystick is the active input device.</p>
<pre><code>DWORD ReadJoystickInput(void) 
{ 
    DWORD                   dwKeyState; 
    HRESULT                 hRes; 
    DIJOYSTATE              js; 

    // poll the joystick to read the current state
    hRes = IDirectInputDevice2_Poll(g_pdevCurrent);
 
    // get data from the joystick 
    hRes = IDirectInputDevice_GetDeviceState(g_pdevCurrent, 
                                            sizeof(DIJOYSTATE), &amp;js); 
 
    if (hRes != DI_OK) 
    { 
      // did the read fail because we lost input for some reason? 
      // if so, then attempt to reacquire. If the second acquire 
      // fails, then the error from GetDeviceData will be 
      // DIERR_NOTACQUIRED, so we won't get stuck an infinite loop. 
      if(hRes == DIERR_INPUTLOST) 
         ReacquireInput(); 
 
      // return the fact that we did not read any data 
      return 0; 
    } 
 
    // Now study the position of the stick and the buttons. 
 
    dwKeyState = 0; 
    if (js.lX &lt; 0) { 
      dwKeyState |= KEY_LEFT; 
    } else if (js.lX &gt; 0) { 
      dwKeyState |= KEY_RIGHT; 
    } 
 
    if (js.lY &lt; 0) { 
      dwKeyState |= KEY_UP; 
    } else if (js.lY &gt; 0) { 
        dwKeyState |= KEY_DOWN; 
   } 
 
    if (js.rgbButtons[0] &amp; 0x80) { 
      dwKeyState |= KEY_FIRE; 
    } 
 
    if (js.rgbButtons[1] &amp; 0x80) { 
      dwKeyState |= KEY_SHIELD; 
    } 
 
    if (js.rgbButtons[2] &amp; 0x80) { 
      dwKeyState |= KEY_STOP; 
    } 
 
    return dwKeyState; 
} 
 </code></pre>
<p>
Note the calls to <b>IDirectInputDevice2_Poll</b> and <b>IDirectInputDevice_GetDeviceState</b>. These are macros that expand to C calls to the corresponding methods, similar to the macro in the previous step of this tutorial. The parameters to the macro are the same as those you would pass to the method. Here is what the call to <b>GetDeviceState</b> looks like:</p>
<pre><code>hRes = IDirectInputDevice_GetDeviceState(g_pdevCurrent, 
                                            sizeof(DIJOYSTATE), &amp;js); 
 </code></pre>
<p>
The first parameter is the this pointer; that is, a pointer to the calling object. The second parameter is the size of the structure in which the data will be returned, and the last parameter is the address of this structure, which is of type <a href="dinput_414k.htm"><b>DIJOYSTATE</b></a>. This structure holds data for up to six axes, 32 buttons, and a point-of-view hat. The sample program looks at the state of two axes and three buttons.</p>
<p>
If the position of an axis is reported as non-zero, that axis is outside the <a href="glossary_4xtf.htm#_dx5_dead_zone_glos">dead zone</a>, and the function responds by setting the <i>dwKeyState</i> variable appropriately. This variable holds the current set of user commands as entered with either the keyboard or the joystick. For example, if the x-axis of the stick is greater than zero, that is considered the same as the right arrow key being down.</p>
<p>
Joystick buttons work just like keys or mouse buttons: if the high bit of the returned byte is set, the button is down.</p>
<p>&nbsp;</p></body>
</HTML>
