<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Working With Z-Buffers</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_dx5_working_with_z_buffers_d3d"></a>Working With Z-Buffers</h2>
<p>
A z-buffer, also called a depth buffer, is a DirectDraw surface that stores depth information to be used by Direct3D. When Direct3D renders a 3-D scene to a target surface, it can use the memory in an attached z-buffer surface as a workspace to determine how the pixels of rasterized polygons occlude one another. The target buffer that D3D uses for rendering is an offscreen DirectDraw surface to which color values are written. The z-buffer surface that is attached to the target surface is used to store depth information which tells Direct3D how "deep" each visible pixel is in the scene. </p>
<p>
When a 3-D scene is rendered with z-buffering enabled, each point on the rendering surface is tested. At the beginning of the test, the depth value in the z-buffer is set to the largest possible value for the scene. The color value on the rendering surface is set to either the background color value, or the color value of the background texture at that point. Each polygon in the scene is tested to see if it intersects with the current coordinate x,y on the rendering surface. If it does, the z value at the current point is tested to see if it is smaller than the z value stored in the z-buffer. If the z of the polygon value is smaller, it is stored in the z-buffer and the color value from the polygon is written to the current point on the rendering surface. If the z value of the polygon at that point is larger, the next polygon in the list is tested.</p>
<p>
<img src="images/zbuffer.gif" border=0></p>
<h5><img src="../../images/wedge.gif" border=0>&nbsp;&nbsp;&nbsp;&nbsp;To enable z-buffering when using D3D:</h5>
<ol>
<li>
Using a <a href="ddref_8hbr.htm"><b>DDSURFACEDESC</b></a> structure, describe a DirectDraw surface that matches the target surface's dimensions and that can be used as a z-buffer.</li>
<li>
Create the surface.</li>
<li>
Attach the z-buffer surface to the rendering surface.</li>
<li>
Set the rendering state of the D3D device so that z-buffering is enabled.</li>
</ol>
<p>
Steps 1-3 are illustrated in the code fragments given in the section entitled <a href="imover_6zhg.htm"><b>Creating the Direct3D Device</b></a>. The surface to be used for the z-buffer is created by calling the <a href="ddref_9ign.htm"><b>IDirectDraw2::CreateSurface</b></a> function. It is attached to the rendering target using the <a href="ddref_09pz.htm"><b>IDirectDrawSurface3::AddAttachedSurface</b></a><b> </b>function.</p>
<p>
Step 4 is accomplished by using the <a href="d3dimref_94f8.htm"><b>IDirect3DDevice2::SetRenderState</b></a> function. When setting the render state to enable z-buffering, the <i>dwRenderStateType </i>parameter must be set to D3DRENDERSTATE_ZENABLE, and the <i>dwRenderState </i>parameter should be set to 1. </p>
<p>
By default, the D3D system is allowed to write to the z-buffer. Most applications should leave z-buffer writes enabled. However, there are some special effects that can be achieved by not allowing the D3D system to write to the z-buffer. Disabling z-buffer writes is done by calling the <b>IDirect3DDevice2::SetRenderState</b> function with the <i>dwRenderStateType </i>parameter set to <a href="d3dimref_3pk4.htm#_dx5_d3drenderstate_zwriteenable_d3d">D3DRENDERSTATE_ZWRITEENABLE</a> and the  <i>dwRenderState </i>parameter should be set to 0.</p>
<p>
When depth testing using z-buffers is performed on a rendering surface, the D3D system searches for the smallest z value for each point on the rendering surface by default. This default can be changed for customize rendering by calling the <b>IDirect3DDevice2::SetRenderState</b> function with the <i>dwRenderStateType </i>parameter set to <a href="d3dimref_3pk4.htm#_dx5_d3drenderstate_zfunc_d3d">D3DRENDERSTATE_ZFUNC</a>. The <i>dwRenderState </i>parameter should be set to one of the values in the <a href="d3dimref_8a78.htm">D3DCMPFUNC</a> enumeration.</p>
<p>
Polygons that are coplanar in your 3-D space can be made to appear as if they are not coplanar by adding a z-bias to each one. This is a technique commonly used to ensure that shadows in a scene are displayed properly. For instance, a shadow on a wall has the same z value as the wall. However, it must appear on the wall for the scene to look correct. To add a z-bias to a polygon, call the <b>IDirect3DDevice2::SetRenderState</b> function just before <a href="d3dimref_93tw.htm"><b>IDirect3DDevice2::DrawPrimitive</b></a> is called to render the polygon. Set the <i>dwRenderStateType </i>parameter to <a href="d3dimref_3pk4.htm#_dx5_d3drenderstate_zbias_d3d">D3DRENDERSTATE_ZBIAS</a>. Set the <i>dwRenderState</i> parameter to a value between 0-16 inclusive. A higher z-bias value will increase the likelihood that the particular polygon will be visible when displayed with coplanar polygons.</p>
<p>
D3D also provides a specialized variant of z-buffering called z-checking. When z-checking is enabled, polygons are culled in groups instead of one at a time. The <b>IDirect3DDevice2::SetRenderState</b> function is used to enable z-checking. Set the <i>dwRenderStateType </i>parameter to <a href="d3dimref_3pk4.htm#_dx5_d3drenderstate_zvisible_d3d">D3DRENDERSTATE_ZVISIBLE</a>.</p>
<p>
Whenever a z-buffer surface is created, a pointer to it should be maintained by the application until it shuts the D3D system down. The z-buffer surface should be released just before the rendering surface is released.</p>
<p>
Z-buffering requires overhead during rendering. Various techniques can be used to optimized rendering when z-buffering is used. For details, see <a href="imover_9oh0.htm"><b>Z-Buffer Performance</b></a>.</p>
<p>&nbsp;</p></body>
</HTML>
