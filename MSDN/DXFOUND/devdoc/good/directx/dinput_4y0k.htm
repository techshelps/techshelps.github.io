<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Device Object Enumeration</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_dx5_device_object_enumeration_dinput"></a>Device Object Enumeration</h3>
<p>
It may be necessary for your application to determine what buttons or axes are available on a given device. To do this you enumerate the device objects in much the same way you enumerate devices.</p>
<p>
To some extent <a href="dinput_0eus.htm"><b>IDirectInputDevice::EnumObjects</b></a> overlaps the functionality of <a href="dinput_30l0.htm"><b>IDirectInputDevice::GetCapabilities</b></a>. Either method may be used to determine how many buttons or axes are available. However, <b>EnumObjects</b> is really intended for cataloguing all the available objects rather than checking for a particular one. The DIQuick application in the DirectX code samples in the Platform SDK References, for example, uses <b>EnumObjects</b> to populate the list on the Objects page for the selected device. </p>
<p>
Like <a href="dinput_41x0.htm"><b>IDirectInput::EnumDevices</b></a>, the <b>EnumObjects</b> function has a callback function that gives you the chance to do other processing on each object – for example, adding it to a list or creating a corresponding element on a user interface.</p>
<p>
Here's a callback function that simply extracts the name of each object so that it can be added to a string list or array. This standard callback is documented under the placeholder name <a href="dinput_3yyc.htm"><b>DIEnumDeviceObjectsProc</b></a>, but you can give it any name you like. Remember, this function is called once for each object enumerated. </p>
<pre><code>char  szName[MAX_PATH]; 
 
BOOL CALLBACK DIEnumDeviceObjectsProc( 
                      LPCDIDEVICEOBJECTINSTANCE lpddoi,
                      LPVOID pvRef) 
{ 
  lstrcpy(szName, lpddoi-&gt;tszName); 
  // Now add szName to a list or array 
  . 
  . 
  . 
  return DIENUM_CONTINUE; 
} 
 </code></pre>
<p>
The first parameter points to a structure containing information about the object. This structure is created for you by DirectInput.</p>
<p>
The second parameter is an application-defined pointer to data, equivalent to the second parameter to <b>EnumObjects</b>. In the example, this parameter is not used.</p>
<p>
The return value in this case indicates that enumeration is to continue as long as there are still objects to be enumerated.</p>
<p>
Now here's the call to the <b>EnumObjects</b> method, which puts the callback function to work.</p>
<pre><code>lpdiMouse-&gt;EnumObjects(DIEnumDeviceObjectsProc, 
                       NULL, DIDFT_ALL); 
 </code></pre>
<p>
The first parameter is the address of the callback function.</p>
<p>
The second parameter can be a pointer to any data you want to use or modify in the callback. The example does not use this parameter and so passes NULL.</p>
<p>
The third parameter is a flag to indicate which type or types of objects are to be included in the enumeration. In the example, all objects are to be enumerated. To restrict the enumeration, you can use one or more of the other DIDFT_* flags listed in the reference for <a href="dinput_41x0.htm"><b>IDirectInput::EnumDevices</b></a>.</p>
<p>
<b>Note</b>&nbsp;&nbsp;Some of the DIDFT_* flags are combinations of others; for example, DIDFT_AXIS is equivalent to DIDFT_ABSAXIS | DIDFT_RELAXIS.</p>
<p>&nbsp;</p></body>
</HTML>
