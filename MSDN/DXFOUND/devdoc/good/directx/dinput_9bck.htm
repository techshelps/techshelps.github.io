<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Step 6: Retrieving Buffered Data from the Mouse</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_dx5_step_6_retrieving_buffered_data_from_the_mouse_dinput"></a>Step 6: Retrieving Buffered Data from the Mouse</h3>
<p>
Once the mouse is acquired, your application can begin to retrieve data from it.</p>
<p>
In the Scrawl sample, retrieval is triggered by a signaled event. In the <b>WinMain</b> function, the application sleeps until <b>MsgWaitForMultipleObjects </b>indicates that there is either a signal or a message. If there's a signal associated with the mouse, the Scrawl_OnMouseInput function is called. This function is a good illustration of how buffered input is handled, so we'll look at it in detail.</p>
<p>
First the function makes sure the old cursor position will be cleaned up. Remember, Scrawl is maintaining its own cursor and is wholly responsible for drawing and erasing it.</p>
<pre><code>void Scrawl_OnMouseInput(HWND hwnd)
{
    /* Invalidate the old cursor so it will be erased */
    InvalidateCursorRect(hwnd);
 </code></pre>
<p>
Now the function enters a loop to read and respond to the entire contents of the buffer. Because it retrieves just one item at a time, it needs only a single <a href="dinput_5cms.htm"><b>DIDEVICEOBJECTDATA</b></a> structure to hold the data. </p>
<p>
Another way to go about handling input would be to read the entire buffer at once and then loop through the retrieved items, responding to each one in turn. In that case, <i>dwElements</i> would be the size of the buffer, and <i>od</i> would be an array with the same number of elements.</p>
<pre><code>while (!fDone) {
        DIDEVICEOBJECTDATA od;
        DWORD dwElements = 1;   // number of items to be retrieved
 </code></pre>
<p>
The application calls the <a href="dinput_74ms.htm"><b>IDirectInputDevice::GetDeviceData</b></a> method in order to fetch the data. The second parameter tells DirectInput where to put the data, and the third tells it how many items are wanted. The final parameter would be DIGDD_PEEK if the data was to be left in the buffer, but in this case the data is not going to be needed again, so it is removed.</p>
<pre><code>HRESULT hr = g_pMouse-&gt;GetDeviceData(
                             sizeof(DIDEVICEOBJECTDATA), 
                             &amp;od,
                             &amp;dwElements, 0);
 </code></pre>
<p>
Now the application checks to see if access to the device has been lost and, if so, tells itself to try to reacquire the mouse at the first opportunity. This step was discussed in <a href="dinput_0wc4.htm">Step 5: Managing Access to the Mouse</a>. </p>
<pre><code>if (hr == DIERR_INPUTLOST) {
            PostMessage(hwnd, WM_SYNCACQUIRE, 0, 0L);
            break;
        }
 </code></pre>
<p>
Next the application makes sure the call to the <b>GetDeviceData</b> method succeeded and that there was actually data to be retrieved. Remember, after the call to <b>GetDeviceData</b> the <i>dwElements</i> variable shows how many items were actually retrieved.</p>
<pre><code>/* Unable to read data or no data available */
        if (FAILED(hr) || dwElements == 0) {
            break;
        }
 </code></pre>
<p>
If execution has proceeded to this point, everything is fine: the call succeeded and there is an item of data in the buffer. Now the application looks at the <b>dwOfs</b> member of the <b>DIDEVICEOBJECTDATA</b> structure to determine which object on the device reported a change of state, and calls helper functions to respond appropriately. The value of the <b>dwData</b> member, which gives information about what happened, is passed to these functions. </p>
<pre><code>/* Look at the element to see what happened */
 
        switch (od.dwOfs) {

        /* DIMOFS_X: Mouse horizontal motion */
        case DIMOFS_X: UpdateCursorPosition(od.dwData, 0); break;

        /* DIMOFS_Y: Mouse vertical motion */
        case DIMOFS_Y: UpdateCursorPosition(0, od.dwData); break;

        /* DIMOFS_BUTTON0: Button 0 pressed or released */
        case DIMOFS_BUTTON0:

            if (od.dwData &amp; 0x80) { /* Button pressed */
                fDone = 1;
                Scrawl_OnButton0Down(hwnd); /* Go into button-down
                                               mode */
            }
            break;

        /* DIMOFS_BUTTON1: Button 1 pressed or released */
        case DIMOFS_BUTTON1:
 
            if (!(od.dwData &amp; 0x80)) {    /* Button released */
                fDone = 1;
                Scrawl_OnButton1Up(hwnd); /* Context menu time */
            }
        }
 
    }
 </code></pre>
<p>
Finally, the Scrawl_OnMouseInput sample function invalidates the screen rectangle occupied by the cursor, in case the cursor has been moved by one of the helper functions.</p>
<pre><code>/* Invalidate the new cursor so it will be drawn */
    InvalidateCursorRect(hwnd);
}
 </code></pre>
<p>
Scrawl also collects mouse data in the Scrawl_OnButton0Down function. This is where the application keeps track of mouse movements while the primary button is being held down — that is, while the user is drawing. This function does not rely on event notification, but repeatedly polls the DirectInput buffer until the button is released.</p>
<p>
A key point to note in the Scrawl_OnButton0Down function is that no actual drawing is done until all pending data has been read. The reason is that each horizontal or vertical movement of the mouse is reported as a separate event. (Both events are, however, placed in the buffer at the same time.) If a line were immediately drawn in response to each separate axis movement, a diagonal movement of the mouse would produce two lines at right angles.</p>
<p>
Another way you can be sure that the movement in both axes is taken into account before responding in your application is to check the sequence numbers of the x-axis item and the y-axis item. If the numbers are the same, the two events took place simultaneously. For more information, see <a href="dinput_79o4.htm">Time Stamps and Sequence Numbers</a>.</p>
<p>&nbsp;</p></body>
</HTML>
