<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>View Transform</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_dx5_view_transform_d3d"></a>View Transform</h3>
<p>
The view transform changes coordinates from world space to camera space. In effect, this transform moves the world around so that the right parts of it are in front of the camera, given a camera position and orientation. </p>
<p>
The following ViewMatrix sample function creates a view matrix based on the camera location passed to it. It uses the <a href="d3dimref_1rc4.htm"><b>Normalize</b></a>, <a href="d3dimref_28f8.htm"><b>CrossProduct</b></a>, and <a href="d3dimref_5d7o.htm"><b>DotProduct</b></a> D3D_OVERLOADS helper functions. The RotateZ user-defined function it uses is shown in the <a href="imover_6gpw.htm">World Transform</a> section.</p>
<pre><code>D3DMATRIX
ViewMatrix(const D3DVECTOR from,      // camera location
           const D3DVECTOR at,        // camera look-at target
           const D3DVECTOR world_up,  // world's up, usually 0, 1, 0
           const float roll)          // clockwise roll around
                                      //    viewing direction, 
                                      //    in radians
{
    D3DMATRIX  view = IdentityMatrix();  // shown below
    D3DVECTOR  up, right, view_dir;
    
    view_dir = Normalize(at - from);
    right = CrossProduct(world_up, view_dir);
    up = CrossProduct(view_dir, right);
    
    right = Normalize(right);
    up = Normalize(up);
    
    view(0, 0) = right.x;
    view(1, 0) = right.y;
    view(2, 0) = right.z;
    view(0, 1) = up.x;
    view(1, 1) = up.y;
    view(2, 1) = up.z;
    view(0, 2) = view_dir.x;
    view(1, 2) = view_dir.y;
    view(2, 2) = view_dir.z;
    
    view(3, 0) = -DotProduct(right, from);
    view(3, 1) = -DotProduct(up, from);
    view(3, 2) = -DotProduct(view_dir, from);
    
    if (roll != 0.0f) {
        // MatrixMult function shown below
        view = MatrixMult(RotateZ(-roll), view); 
    }
    
    return view;
    }  // end of ViewMatrix()
 
D3DMATRIX
IdentityMatrix(void)       // initializes identity matrix
{
    D3DMATRIX ret;
    for (int i=0; i&lt;4; i++)
        for (int j=0; j&lt;4; j++)
            ret(i, j) = (i==j) ? 1.0f : 0.0f;
    return ret;
}    // end of IdentityMatrix()
 
// Multiplies two matrices.
D3DMATRIX
MatrixMult(const D3DMATRIX a, const D3DMATRIX b)  
{
    D3DMATRIX ret = ZeroMatrix(); // shown below
 
    for (int i=0; i&lt;4; i++) {
        for (int j=0; j&lt;4; j++) {
            for (int k=0; k&lt;4; k++) {
                ret(i, j) += a(k, j) * b(i, k);
            }
        }
    }
    return ret;
}    // end of MatrixMult()
 
D3DMATRIX 
ZeroMatrix(void)  // initializes matrix to zero
{
    D3DMATRIX ret;
    for (int i=0; i&lt;4; i++)
        for (int j=0; j&lt;4; j++)
            ret(i, j) = 0.0f;
    return ret;
}    // end of ZeroMatrix()
 </code></pre>
<p>&nbsp;</p></body>
</HTML>
