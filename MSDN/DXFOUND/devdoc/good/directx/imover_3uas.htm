<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Filling the Execute Buffer</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_dx5_filling_the_execute_buffer_code_d3d"></a>Filling the Execute Buffer</h2>
<p>
The FillExecuteBuffer sample function fills the single <a href="glossary_8yb7.htm#_dx5_execute_buffer_glos">execute buffer</a> used in this sample with all the vertices, transformations, light and render states, and drawing primitives necessary to draw our triangle.</p>
<p>
The method shown here is not the most efficient way of organizing the execute buffer. For best performance you should minimize state changes. In this sample we submit the execute buffer for each frame in the animation loop and no state in the buffer is modified. The only thing we modify is the world matrix (its contents—not its handle). Therefore, it would be more efficient to extract all the static state instructions into a separate execute buffer which we would issue once only at startup and, from then on, simply execute a second execute buffer with vertices and triangles.</p>
<p>
However, because this sample is more concerned with clarity than performance, it uses only one execute buffer and resubmits it in its entirety for each frame.</p>
<pre><code>static HRESULT 
FillExecuteBuffer(void) 
{ 
    HRESULT              hRes; 
    D3DEXECUTEBUFFERDESC d3dExeBufDesc; 
    LPD3DVERTEX          lpVertex; 
    LPD3DINSTRUCTION     lpInstruction; 
    LPD3DPROCESSVERTICES lpProcessVertices; 
    LPD3DTRIANGLE        lpTriangle; 
    LPD3DSTATE           lpState; 
 
    ASSERT(NULL != lpd3dExecuteBuffer); 
    ASSERT(0  != hd3dSurfaceMaterial); 
    ASSERT(0  != hd3dWorldMatrix); 
    ASSERT(0  != hd3dViewMatrix); 
    ASSERT(0  != hd3dProjMatrix); 
 
    // Lock the execute buffer. 
 
    ZeroMemory(&amp;d3dExeBufDesc, sizeof(d3dExeBufDesc)); 
    d3dExeBufDesc.dwSize = sizeof(d3dExeBufDesc); 
    hRes = lpd3dExecuteBuffer-&gt;lpVtbl-&gt;Lock(lpd3dExecuteBuffer, 
        &amp;d3dExeBufDesc); 
    if (FAILED(hRes)) 
        return hRes; 
 
    // For purposes of illustration, we fill the execute buffer by 
    // casting a pointer to the execute buffer to the appropriate data 
    // structures. 
 
    lpVertex = (LPD3DVERTEX)d3dExeBufDesc.lpData; 
 
    // First vertex. 
 
    lpVertex-&gt;dvX  = D3DVAL( 0.0); // Position in model coordinates 
    lpVertex-&gt;dvY  = D3DVAL( 1.0); 
    lpVertex-&gt;dvZ  = D3DVAL( 0.0); 
    lpVertex-&gt;dvNX = D3DVAL( 0.0); // Normalized illumination normal 
    lpVertex-&gt;dvNY = D3DVAL( 0.0); 
    lpVertex-&gt;dvNZ = D3DVAL(-1.0); 
    lpVertex-&gt;dvTU = D3DVAL( 0.0); // Texture coordinates (not used) 
    lpVertex-&gt;dvTV = D3DVAL( 1.0); 
    lpVertex++; 
 
    // Second vertex. 
 
    lpVertex-&gt;dvX  = D3DVAL( 1.0); // Position in model coordinates 
    lpVertex-&gt;dvY  = D3DVAL(-1.0); 
    lpVertex-&gt;dvZ  = D3DVAL( 0.0); 
    lpVertex-&gt;dvNX = D3DVAL( 0.0); // Normalized illumination normal 
    lpVertex-&gt;dvNY = D3DVAL( 0.0); 
    lpVertex-&gt;dvNZ = D3DVAL(-1.0); 
    lpVertex-&gt;dvTU = D3DVAL( 1.0); // Texture coordinates (not used) 
    lpVertex-&gt;dvTV = D3DVAL( 1.0); 
    lpVertex++; 
 
    // Third vertex. 
 
    lpVertex-&gt;dvX  = D3DVAL(-1.0); // Position in model coordinates 
    lpVertex-&gt;dvY  = D3DVAL(-1.0); 
    lpVertex-&gt;dvZ  = D3DVAL( 0.0); 
    lpVertex-&gt;dvNX = D3DVAL( 0.0); // Normalized illumination normal 
    lpVertex-&gt;dvNY = D3DVAL( 0.0); 
    lpVertex-&gt;dvNZ = D3DVAL(-1.0); 
    lpVertex-&gt;dvTU = D3DVAL( 1.0); // Texture coordinates (not used) 
    lpVertex-&gt;dvTV = D3DVAL( 0.0); 
    lpVertex++; 
 
    // Transform state - world, view and projection. 
 
    lpInstruction = (LPD3DINSTRUCTION)lpVertex; 
    lpInstruction-&gt;bOpcode = D3DOP_STATETRANSFORM; 
    lpInstruction-&gt;bSize   = sizeof(D3DSTATE); 
    lpInstruction-&gt;wCount  = 3U; 
    lpInstruction++; 
    lpState = (LPD3DSTATE)lpInstruction; 
    lpState-&gt;dtstTransformStateType = D3DTRANSFORMSTATE_WORLD; 
    lpState-&gt;dwArg[0] = hd3dWorldMatrix; 
    lpState++; 
    lpState-&gt;dtstTransformStateType = D3DTRANSFORMSTATE_VIEW; 
    lpState-&gt;dwArg[0] = hd3dViewMatrix; 
    lpState++; 
    lpState-&gt;dtstTransformStateType = D3DTRANSFORMSTATE_PROJECTION; 
    lpState-&gt;dwArg[0] = hd3dProjMatrix; 
    lpState++; 
 
    // Lighting state. 
 
    lpInstruction = (LPD3DINSTRUCTION)lpState; 
    lpInstruction-&gt;bOpcode = D3DOP_STATELIGHT; 
    lpInstruction-&gt;bSize   = sizeof(D3DSTATE); 
    lpInstruction-&gt;wCount  = 2U; 
    lpInstruction++; 
    lpState = (LPD3DSTATE)lpInstruction; 
    lpState-&gt;dlstLightStateType = D3DLIGHTSTATE_MATERIAL; 
    lpState-&gt;dwArg[0] = hd3dSurfaceMaterial; 
    lpState++; 
    lpState-&gt;dlstLightStateType = D3DLIGHTSTATE_AMBIENT; 
    lpState-&gt;dwArg[0] = RGBA_MAKE(128, 128, 128, 128); 
    lpState++; 
 
    // Render state. 
 
    lpInstruction = (LPD3DINSTRUCTION)lpState; 
    lpInstruction-&gt;bOpcode = D3DOP_STATERENDER; 
    lpInstruction-&gt;bSize = sizeof(D3DSTATE); 
    lpInstruction-&gt;wCount = 3U; 
    lpInstruction++; 
    lpState = (LPD3DSTATE)lpInstruction; 
    lpState-&gt;drstRenderStateType = D3DRENDERSTATE_FILLMODE; 
    lpState-&gt;dwArg[0] = D3DFILL_SOLID; 
    lpState++; 
    lpState-&gt;drstRenderStateType = D3DRENDERSTATE_SHADEMODE; 
    lpState-&gt;dwArg[0] = D3DSHADE_GOURAUD; 
    lpState++; 
    lpState-&gt;drstRenderStateType = D3DRENDERSTATE_DITHERENABLE; 
    lpState-&gt;dwArg[0] = TRUE; 
    lpState++; 
 
    // The D3DOP_PROCESSVERTICES instruction tells the driver what to 
    // do with the vertices in the buffer. In this sample we want 
    // Direct3D to perform the entire pipeline on our behalf, so 
    // the instruction is D3DPROCESSVERTICES_TRANSFORMLIGHT. 
 
    lpInstruction = (LPD3DINSTRUCTION)lpState; 
    lpInstruction-&gt;bOpcode = D3DOP_PROCESSVERTICES; 
    lpInstruction-&gt;bSize   = sizeof(D3DPROCESSVERTICES); 
    lpInstruction-&gt;wCount  = 1U; 
    lpInstruction++; 
    lpProcessVertices = (LPD3DPROCESSVERTICES)lpInstruction; 
    lpProcessVertices-&gt;dwFlags    = D3DPROCESSVERTICES_TRANSFORMLIGHT; 
    lpProcessVertices-&gt;wStart     = 0U;           // First source vertex 
    lpProcessVertices-&gt;wDest      = 0U; 
    lpProcessVertices-&gt;dwCount    = NUM_VERTICES; // Number of vertices 
    lpProcessVertices-&gt;dwReserved = 0; 
    lpProcessVertices++; 
 
    // Draw the triangle. 
 
    lpInstruction = (LPD3DINSTRUCTION)lpProcessVertices; 
    lpInstruction-&gt;bOpcode = D3DOP_TRIANGLE; 
    lpInstruction-&gt;bSize   = sizeof(D3DTRIANGLE); 
    lpInstruction-&gt;wCount  = 1U; 
    lpInstruction++; 
    lpTriangle = (LPD3DTRIANGLE)lpInstruction; 
    lpTriangle-&gt;wV1    = 0U; 
    lpTriangle-&gt;wV2    = 1U; 
    lpTriangle-&gt;wV3    = 2U; 
    lpTriangle-&gt;wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE; 
    lpTriangle++; 
 
    // Stop execution of the buffer. 
 
    lpInstruction = (LPD3DINSTRUCTION)lpTriangle; 
    lpInstruction-&gt;bOpcode = D3DOP_EXIT; 
    lpInstruction-&gt;bSize   = 0; 
    lpInstruction-&gt;wCount  = 0U; 
 
    // Unlock the execute buffer. 
 
    lpd3dExecuteBuffer-&gt;lpVtbl-&gt;Unlock(lpd3dExecuteBuffer); 
 
    return DD_OK; 
} 
 </code></pre>
<p>&nbsp;</p></body>
</HTML>
