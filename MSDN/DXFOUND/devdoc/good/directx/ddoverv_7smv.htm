<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Step 4.2: Setting Up the Source and Destination Rectangles</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h4><a name="_dx5_step_4.2_setting_up_the_source_and_destination_rectangles_ddraw"></a>Step 4.2: Setting Up the Source and Destination Rectangles</h4>
<p>
After retrieving the driver's overlay restrictions you should set the values for your source and destination rectangles accordingly, assuring that you will be able to successfully display the overlay. The following sample from the Mosquito sample application starts by setting the characteristics of the source rectangle:</p>
<pre><code>// Set initial values in the source RECT.
    rs.left=0; rs.top=0; 
    rs.right = 320;
    rs.bottom = 240;

    // Apply size alignment restrictions, if necessary.
    if (capsDrv.dwCaps &amp; DDCAPS_ALIGNSIZESRC &amp;&amp; uSrcSizeAlign)
        rs.right -= rs.right % uSrcSizeAlign; 
 </code></pre>
<p>
The preceding code sets initial values for the surface to include the dimensions of the entire surface. If the device driver requires size alignment for the source rectangle, the example adjusts the source rectangle to conform. The example adjusts the width of the source rectangle to be narrower than the original size because the width cannot be expanded without completely recreating the surface. However, your code could just as easily start with a smaller rectangle and widen the rectangle to meet driver restrictions.</p>
<p>
After the dimensions of the source rectangle are set and conform with hardware restrictions, you need to set and adjust the dimensions of the destination rectangle. This process requires a little more work because the rectangle might need to be stretched first, then adjusted to meet size alignment restrictions. The following code performs the task of accounting for the minimum stretch factor:</p>
<pre><code>// Set up the destination RECT, starting with the source RECT values.
    // We use the source RECT dimensions instead of the surface dimensions in
    // case they differ.
    rd.left=0; rd.top=0; 
    rd.right  = (rs.right*uStretchFactor1000+999)/1000;     // (Adding 999 avoids integer truncation problems.)

    // (This isn't required by DDraw, but we'll stretch the
    //  height, too, to maintain aspect ratio).
    rd.bottom = rs.bottom*uStretchFactor1000/1000; 
 </code></pre>
<p>
The preceding code sets the top left corner of the destination rectangle to the top left corner of the screen, then sets the width to account for the minimum stretch factor. While adjusting for the stretch factor, note that the example adds 999 to the product of the width and stretch factor. This is done to prevent integer truncation that could result in a rectangle that isn't as wide as the minimum stretch factor requires. For more information, see <a href="ddoverv_4trr.htm">Minimum and Maximum Stretch Factors</a>. Also, after the example stretches the width, it stretches the height. Stretching the height isn't required, but was done to preserve the bitmap's aspect ratio and avoid a distorted appearance.</p>
<p>
After stretching the destination rectangle, the example continues by adjusting it to conform to size alignment restrictions as follows:</p>
<pre><code>// Adjust the destination RECT's width to comply with any imposed
    // alignment restrictions.
    if (capsDrv.dwCaps &amp; DDCAPS_ALIGNSIZEDEST &amp;&amp; uDestSizeAlign)
        rd.right = (int)((rd.right+uDestSizeAlign-1)/uDestSizeAlign)*uDestSizeAlign;
 </code></pre>
<p>
The example checks the capabilities flags to see if the driver imposes destination size alignment restrictions. If so, the destination rectangle's width is increased by enough pixels to meet alignment restrictions. Note that the rectangle is adjusted by expanding the width, not by decreasing it. This is done because decreasing the width could cause the destination rectangle to be smaller than is required by the minimum stretch factor, consequently causing attempts to display the overlay surface to fail.</p>
<p>&nbsp;</p></body>
</HTML>
