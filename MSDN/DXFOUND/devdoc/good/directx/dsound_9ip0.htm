<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Custom Mixers</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_dx5_custom_mixers_dsound"></a>Custom Mixers</h3>
<p>
Most applications will use the DirectSound mixer; it should be sufficient for almost all mixing needs and it automatically takes advantage of any available hardware acceleration. However, if an application requires some other functionality that DirectSound does not provide, it can obtain write access to the <a href="glossary_33qr.htm#_dx5_primary_sound_buffer_glos">primary sound buffer</a> and mix streams directly into it.</p>
<p>
To implement a custom mixer, the application must first obtain the DSSCL_WRITEPRIMARY cooperative level and then create a primary sound buffer. (See <a href="dsound_8qg4.htm">Access to the Primary Buffer</a>.) It can then lock the buffer, write data to it, unlock it, and play it just like any other buffer. (See <a href="dsound_04mc.htm">Playing Sounds</a>.) Note however that the DSBPLAY_LOOPING flag must be specified or the <a href="dsound_7rz8.htm"><b>IDirectSoundBuffer::Play</b></a> call will fail.</p>
<p>
The following example illustrates how an application might implement a custom mixer. The AppMixIntoPrimaryBuffer sample function would have to be called at regular intervals, frequently enough to prevent the sound device from repeating blocks of data. The CustomMixer function is an application-defined function that mixes several streams together, as specified in the application-defined AppStreamInfo structure, and writes the result to the specified pointer.</p>
<pre><code>BOOL AppMixIntoPrimaryBuffer( 
    LPAPPSTREAMINFO lpAppStreamInfo, 
    LPDIRECTSOUNDBUFFER lpDsbPrimary, 
    DWORD dwDataBytes, 
    DWORD dwOldPos, 
    LPDWORD lpdwNewPos) 
{ 
    LPVOID lpvPtr1; 
    DWORD dwBytes1; 
    LPVOID lpvPtr2; 
    DWORD dwBytes2; 
    HRESULT hr; 
    // Obtain write pointer. 
    hr = lpDsbPrimary-&gt;lpVtbl-&gt;Lock(lpDsbPrimary, 
                                    dwOldPos, dwDataBytes, 
                                    &amp;lpvPtr1, &amp;dwBytes1, 
                                    &amp;lpvPtr2, &amp;dwBytes2, 0); 
    // If DSERR_BUFFERLOST is returned, restore and retry lock. 
    if(DSERR_BUFFERLOST == hr) { 
        lpDsbPrimary-&gt;lpVtbl-&gt;Restore(lpDsbPrimary); 
        hr = lpDsbPrimary-&gt;lpVtbl-&gt;Lock(lpDsbPrimary, 
                                        dwOldPos, dwDataBytes,
                                        &amp;lpvPtr1, &amp;dwBytes1, 
                                        &amp;lpvPtr2, &amp;dwBytes2, 0); 
    } 
    if (DS_OK == hr) { 
        // Mix data into the returned pointers. 
        CustomMixer(lpAppStreamInfo, lpvPtr1, dwBytes1); 
        *lpdwNewPos = dwOldPos + dwBytes1; 
        if (NULL != lpvPtr2) { 
            CustomMixer(lpAppStreamInfo, lpvPtr2, dwBytes2); 
            *lpdwNewPos = dwBytes2; // Because it wrapped around. 
        } 
        // Release the data back to DirectSound. 
        hr = lpDsbPrimary-&gt;lpVtbl-&gt;Unlock(lpDsbPrimary, 
                                          lpvPtr1, dwBytes1, 
                                          lpvPtr2, dwBytes2); 
        if (DS_OK == hr) { 
            // Success. 
            return TRUE; 
        } 
    } 
    // Lock or Unlock failed. 
    return FALSE; 
} 
 </code></pre>
<p>&nbsp;</p></body>
</HTML>
