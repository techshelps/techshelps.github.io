<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Creating the Primary Surface and Clipper Object</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_dx5_creating_the_primary_surface_and_clipper_object_d3d"></a>Creating the Primary Surface and Clipper Object</h3>
<p>
The CreatePrimary function creates the <a href="glossary_33qr.htm#_dx5_primary_surface_glos">primary surface</a> (representing the desktop) and creates and attaches a clipper object. If necessary, this function also creates a palette.</p>
<pre><code>static HRESULT 
CreatePrimary(HWND hwnd) 
{ 
    HRESULT             hRes; 
    DDSURFACEDESC       ddsd; 
    LPDIRECTDRAWCLIPPER lpddClipper; 
    HDC                 hdc; 
    int                 i; 
    PALETTEENTRY        peColorTable[256]; 
 
    ASSERT(NULL != hwnd); 
    ASSERT(NULL != lpdd); 
    ASSERT(NULL == lpddPrimary); 
    ASSERT(NULL == lpddPalette); 
 
    // Create the primary surface. 
 
    ZeroMemory(&amp;ddsd, sizeof(ddsd)); 
    ddsd.dwSize         = sizeof(ddsd); 
    ddsd.dwFlags        = DDSD_CAPS; 
    ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE; 
    hRes = lpdd-&gt;lpVtbl-&gt;CreateSurface(lpdd, &amp;ddsd, &amp;lpddPrimary, NULL); 
    if (FAILED(hRes)) 
        return hRes; 
 
    // Create the clipper. We bind the application's window to the 
    // clipper and attach it to the primary. This ensures that when we 
    // blit from the rendering surface to the primary we don't write 
    // outside the visible region of the window. 
 
    hRes = DirectDrawCreateClipper(0, &amp;lpddClipper, NULL); 
    if (FAILED(hRes)) 
        return hRes; 
    hRes = lpddClipper-&gt;lpVtbl-&gt;SetHWnd(lpddClipper, 0, hwnd); 
    if (FAILED(hRes)) 
    { 
        lpddClipper-&gt;lpVtbl-&gt;Release(lpddClipper); 
        return hRes; 
    } 
    hRes = lpddPrimary-&gt;lpVtbl-&gt;SetClipper(lpddPrimary, lpddClipper); 
    if (FAILED(hRes)) 
    { 
        lpddClipper-&gt;lpVtbl-&gt;Release(lpddClipper); 
        return hRes; 
    } 
 
    // We release the clipper interface after attaching it to the 
    // surface because we don't need to use it again. The surface 
    // holds a reference to the clipper when it has been attached. 
    // The clipper will therefore be released automatically when the 
    // surface is released. 
 
    lpddClipper-&gt;lpVtbl-&gt;Release(lpddClipper); 
 
    // If the primary surface is palettized, the device will be, too. 
    // (The device surface must have the same pixel format as the 
    // current primary surface if we want to double buffer with 
    // DirectDraw.) Therefore, if the primary surface is palettized we 
    // need to create a palette and attach it to the primary surface 
    // (and to the device surface when we create it). 
 
    ZeroMemory(&amp;ddsd, sizeof(ddsd)); 
    ddsd.dwSize = sizeof(ddsd); 
    hRes = lpddPrimary-&gt;lpVtbl-&gt;GetSurfaceDesc(lpddPrimary, &amp;ddsd); 
    if (FAILED(hRes)) 
        return hRes; 
    if (ddsd.ddpfPixelFormat.dwFlags &amp; DDPF_PALETTEINDEXED8) 
    { 
    // Initializing the palette correctly is essential. Since we are 
    // running in a window, we must not change the top ten and bottom 
    // ten static colors. Therefore, we copy them from the system 
    // palette and mark them as read only (D3DPAL_READONLY). The middle 
    // 236 entries are free for use by Direct3D so we mark them free 
    // (D3DPAL_FREE). 
 
    // NOTE: In order that the palette entries are correctly 
    // allocated it is essential that the free entries are 
    // also marked reserved to GDI (PC_RESERVED). 
 
    // NOTE: We don't need to specify the palette caps flag 
    // DDPCAPS_INITIALIZE. This flag is obsolete. CreatePalette 
    // must be given a valid palette-entry array and always 
    // initializes from it. 
 
        hdc = GetDC(NULL); 
        GetSystemPaletteEntries(hdc, 0, 256, peColorTable); 
        ReleaseDC(NULL, hdc); 
 
        for (i = 0; i &lt; 10; i++) 
            peColorTable[i].peFlags = D3DPAL_READONLY; 
        for (i = 10; i &lt; 246; i++) 
            peColorTable[i].peFlags = D3DPAL_FREE | PC_RESERVED; 
        for (i = 246; i &lt; 256; i++) 
            peColorTable[i].peFlags = D3DPAL_READONLY; 
        hRes = lpdd-&gt;lpVtbl-&gt;CreatePalette(lpdd, 
            DDPCAPS_8BIT, peColorTable, &amp;lpddPalette, NULL); 
 
        if (FAILED(hRes)) 
            return hRes; 
 
        hRes = lpddPrimary-&gt;lpVtbl-&gt;SetPalette(lpddPrimary, 
                lpddPalette); 
            return hRes; 
    } 
 
    return DD_OK; 
} 
 </code></pre>
<p>&nbsp;</p></body>
</HTML>
