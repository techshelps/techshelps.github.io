<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Enumeration Callback Function</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_dx5_enumeration_callback_function_d3d"></a>Enumeration Callback Function</h3>
<p>
The EnumDeviceCallback function is invoked for each Direct3D device installed on the system. For each device we retrieve its identifying GUID, a name and description, a description of its hardware and software capabilities, and an unused user argument.</p>
<p>
The EnumDeviceCallback function uses the following algorithm to choose an appropriate Direct3D device:
<ol>
<li>
Discard any devices which don't match the current display depth.</li>
<li>
Discard any devices which can't do Gouraud-shaded triangles.</li>
<li>
If a hardware device is found which matches points one and two, use it. However, if we are running in debug mode we will skip hardware.</li>
<li>
Otherwise favor Mono/Ramp mode software renderers over RGB ones; until MMX is widespread, Mono will be faster.</li>
</ol>
<p>
This callback function is invoked by the ChooseDevice enumeration function, which is described in <a href="imover_3l44.htm">Enumeration Function</a>.</p>
<p>
Note that the first parameter passed to this callback function, <i>lpGUID</i>, is NULL for the primary device. All other devices should have a non-NULL pointer. You should consider saving the actual GUID for the device you choose, not the pointer to the GUID, in case the pointer is accidentally corrupted.</p>
<pre><code>static HRESULT WINAPI 
EnumDeviceCallback(LPGUID          lpGUID, 
                   LPSTR           lpszDeviceDesc, 
                   LPSTR           lpszDeviceName, 
                   LPD3DDEVICEDESC lpd3dHWDeviceDesc, 
                   LPD3DDEVICEDESC lpd3dSWDeviceDesc, 
                   LPVOID          lpUserArg) 
{ 
    BOOL            fIsHardware; 
    LPD3DDEVICEDESC lpd3dDeviceDesc; 
 
        // Call the USE_PARAM macro on the unused parameter to 
        // avoid compiler warnings. 
 
    USE_PARAM(lpUserArg); 
 
        // If there is no hardware support the color model is zero. 
 
    fIsHardware     = (0 != lpd3dHWDeviceDesc-&gt;dcmColorModel); 
    lpd3dDeviceDesc = (fIsHardware ? lpd3dHWDeviceDesc : 
                                     lpd3dSWDeviceDesc); 
 
        // If we are in debug mode and this is a hardware device, 
        // skip it. 
 
    if (fDebug &amp;&amp; fIsHardware) 
        return D3DENUMRET_OK; 
 
        // Does the device render at the depth we want? 
 
    if (0 == (lpd3dDeviceDesc-&gt;dwDeviceRenderBitDepth &amp; 
              dwDeviceBitDepth)) 
    { 
                // If not, skip this device. 
 
        return D3DENUMRET_OK; 
    } 
 
        // The device must support Gouraud-shaded triangles. 
 
    if (D3DCOLOR_MONO == lpd3dDeviceDesc-&gt;dcmColorModel) 
    { 
        if (!(lpd3dDeviceDesc-&gt;dpcTriCaps.dwShadeCaps &amp; 
              D3DPSHADECAPS_COLORGOURAUDMONO)) 
        { 
                        // No Gouraud shading. Skip this device. 
 
            return D3DENUMRET_OK; 
        } 
    } 
    else 
    { 
        if (!(lpd3dDeviceDesc-&gt;dpcTriCaps.dwShadeCaps &amp; 
              D3DPSHADECAPS_COLORGOURAUDRGB)) 
        { 
                        // No Gouraud shading. Skip this device. 
 
            return D3DENUMRET_OK; 
        } 
    } 
 
    if (!fIsHardware &amp;&amp; fDeviceFound &amp;&amp; 
           (D3DCOLOR_RGB == lpd3dDeviceDesc-&gt;dcmColorModel)) 
    { 
                // If this is software RGB and we already have found 
                // a software monochromatic renderer, we are not 
                // interested. Skip this device. 
 
        return D3DENUMRET_OK; 
    } 
 
        // This is a device we are interested in. Save the details. 
 
    fDeviceFound = TRUE; 
    CopyMemory(&amp;guidDevice, lpGUID, sizeof(GUID)); 
    strcpy(szDeviceDesc, lpszDeviceDesc); 
    strcpy(szDeviceName, lpszDeviceName); 
    CopyMemory(&amp;d3dHWDeviceDesc, lpd3dHWDeviceDesc, 
               sizeof(D3DDEVICEDESC)); 
    CopyMemory(&amp;d3dSWDeviceDesc, lpd3dSWDeviceDesc, 
               sizeof(D3DDEVICEDESC)); 
 
        // If this is a hardware device, we have found 
        // what we are looking for. 
 
    if (fIsHardware) 
        return D3DENUMRET_CANCEL; 
 
        // Otherwise, keep looking. 
 
    return D3DENUMRET_OK; 
} 
 </code></pre>
<p>&nbsp;</p></body>
</HTML>
