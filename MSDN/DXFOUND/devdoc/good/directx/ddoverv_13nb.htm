<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Accessing the Frame-Buffer Directly</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_dx5_accessing_the_frame_buffer_directly_ddraw"></a>Accessing the Frame-Buffer Directly</h3>
<p>
You can directly access surface memory in the frame-buffer or in system memory by using the <a href="ddref_201j.htm"><b>IDirectDrawSurface3::Lock</b></a> method. When you call this method, the <i>lpDestRect</i> parameter is a pointer to a <b>RECT</b> structure that describes the rectangle on the surface you want to access directly. To request that the entire surface be locked, set <i>lpDestRect</i> to NULL. Also, you can specify a <b>RECT</b> that covers only a portion of the surface. Providing that no two rectangles overlap, two threads or processes can simultaneously lock multiple rectangles in a surface.</p>
<p>
The <b>Lock</b> method fills a <a href="ddref_8hbr.htm"><b>DDSURFACEDESC</b></a> structure with all the information you need to properly access the surface memory. The structure includes information about the <a href="glossary_33qr.htm#_dx5_pitch_glos">pitch</a> (or stride) and the pixel format of the surface, if different from the pixel format of the <a href="glossary_33qr.htm#_dx5_primary_surface_glos">primary surface</a>. When you finish accessing the surface memory, call the <a href="ddref_0w53.htm"><b>IDirectDrawSurface3::Unlock</b></a> method to unlock it.</p>
<p>
While you have a surface locked, you can directly manipulate the contents. The following list describes some tips for avoiding common problems with directly rendering surface memory:
<ul>
<li>
Never assume a constant display pitch. Always examine the pitch information returned by the <a href="ddref_201j.htm"><b>IDirectDrawSurface3::Lock</b></a> method. This pitch can vary for a number of reasons, including the location of the surface memory, the type of display card, or even the version of the DirectDraw driver. For more information, see <a href="ddoverv_3nlj.htm">Width and Pitch</a>.</li>
<li>
Make certain you blit to unlocked surfaces. DirectDraw blit methods will fail, returning <a href="ddref_71rr.htm#_dx5_dderr_surfacebusy_ddraw">DDERR_SURFACEBUSY</a> or <a href="ddref_71rr.htm#_dx5_dderr_lockedsurfaces_ddraw">DDERR_LOCKEDSURFACES</a>, if called on a locked surface. Similarly, GDI blit functions fail without returning error values if called on a locked surface that exists in display memory.</li>
<li>
Limit your application's activity while a surface is locked. While a surface is locked, DirectDraw often holds the Win16Lock so that gaining access to surface memory can occur safely. The Win16Lock serializes access to GDI and USER, shutting down Windows for the duration between the <b>IDirectDrawSurface3::Lock</b> and <b>IDirectDrawSurface3::Unlock</b> calls. The <a href="ddref_4q0n.htm"><b>IDirectDrawSurface3::GetDC</b></a> method implicitly calls <b>IDirectDrawSurface3::Lock</b>, and the <a href="ddref_0xpz.htm"><b>IDirectDrawSurface3::ReleaseDC</b></a> implicitly calls <b>IDirectDrawSurface3::Unlock</b>.</li>
<li>
Copy aligned to display memory. Windows 95 uses a page fault handler, Vflatd.386, to implement a virtual flat-frame buffer for display cards with bank-switched memory. The handler allows these display devices to present a linear frame buffer to DirectDraw. Copying unaligned to display memory can cause the system to suspend operations if the copy spans memory banks.</li>
</ul>
<p>
Locking the surface typically causes DirectDraw to take the Win16Lock. During the Win16Lock all other applications, including Windows, cease execution. Since the Win16Lock stops applications from executing, standard debuggers cannot be used while the lock is held. Kernel debuggers can be used during this period.</p>
<p>
If a blit is in progress when you call <a href="ddref_201j.htm"><b>IDirectDrawSurface3::Lock</b></a>, the method will return immediately with an error, as a lock cannot be obtained. To prevent the error, use the DDLOCK_WAIT flag to cause the method to wait until a lock can be successfully obtained.</p>
<p>&nbsp;</p></body>
</HTML>
