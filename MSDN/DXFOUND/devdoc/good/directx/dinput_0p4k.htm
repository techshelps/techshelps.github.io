<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Buffered and Immediate Data</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_dx5_buffered_and_immediate_data_dinput"></a>Buffered and Immediate Data</h3>
<p>
DirectInput supplies two types of data: buffered and immediate. Buffered data is a record of events that is stored until an application retrieves it. Immediate data is a snapshot of the current state of a device.</p>
<p>
You might use immediate data in an application that is concerned only with the current state of a device: for example, a flight combat simulation that responds to the current position of the joystick and a pressed "fire" button. Buffered data might be the better choice where events are more important than states: for example, in an application that responds to movement of the mouse and button clicks.</p>
<p>
You get immediate data with the <a href="dinput_0aes.htm"><b>IDirectInputDevice::GetDeviceState</b></a> method. As the name implies, this method simply returns the current state of the device: for example, whether each button is up or down. The method provides no data about what has happened with the device since the last call, apart from implicit information you can derive by comparing the current state with the last one. If the user manages to press and release a button between two calls to <b>GetDeviceState</b>, your application won't know anything about it. On the other hand, if the user is holding a button down, <b>GetDeviceState</b> will continue reporting "button down" until the user releases it. </p>
<p>
This way of reporting the device state is different from the way Windows reports events with one-time messages like WM_LBUTTONDOWN; it is more akin to the results from the Win32 <b>GetKeyboardState</b> function. If you are polling a device with <b>GetDeviceState</b>, you are responsible for determining what constitutes a button click, a double-click, a single keystroke, and so on, and for ensuring that your application doesn't keep responding to a button-down or key-down state when it's not appropriate to do so.</p>
<p>
With buffered data, events are stored until you're ready to deal with them. Every time a button or key is pressed or an axis is moved, information about the event is placed in a <a href="dinput_5cms.htm"><b>DIDEVICEOBJECTDATA</b></a> structure in the buffer. If the buffer overflows, new data is lost. Your application reads the buffer with a call to <a href="dinput_74ms.htm"><b>IDirectInputDevice::GetDeviceData</b></a>. You can read any number of items at a time.</p>
<p>
Reading an item normally deletes it from the buffer, but you also have the choice of peeking without deleting.</p>
<p>
In order to get buffered data you must first set the buffer size with the <a href="dinput_24vo.htm"><b>IDirectInputDevice::SetProperty</b></a><b> </b>method. (See the example under <a href="dinput_94tw.htm">Device Properties</a>.) You set the buffer size before acquiring the device for the first time. For reasons of efficiency, the default size of the buffer is zero. You will not be able to obtain buffered data unless you change this value.</p>
<p>
<b>Note</b>&nbsp;&nbsp;The size of the buffer is measured in items of data for that type of device, not in bytes or words.</p>
<p>
You should check the value of the <i>pdwInOut</i> parameter after a call to the <b>GetDeviceData</b> method. The number of items actually retrieved from the buffer is returned in this variable.</p>
<p>
The DIQuick application supplied with the DirectX code samples in the Platform SDK Reference lets you see both immediate and buffered data from a device. After you create the device in the application window, set its properties on the Mode page. Now, on the Data page, you see immediate data on the left and buffered data on the right.</p>
<p>
<b>Note</b>&nbsp;&nbsp;For devices that do not generate interrupts, such as analog joysticks, DirectInput does not obtain any data until you call the <a href="dinput_46d0.htm"><b>IDirectInputDevice2::Poll</b></a> method.&nbsp; For more information, see <a href="dinput_1zqs.htm">Polling and Events</a>.</p>
<p>
For examples of retrieving buffered data, see <a href="dinput_74ms.htm"><b>IDirectInputDevice::GetDeviceData</b></a>.</p>
<p>
See also:
<ul>
<li>
<a href="dinput_79o4.htm">Time Stamps and Sequence Numbers</a></li>
<li>
<a href="dinput_0dv8.htm">Mouse Data</a></li>
<li>
<a href="dinput_40xg.htm">Keyboard Data</a></li>
<li>
<a href="dinput_2tkk.htm">Joystick Data</a></li>
</ul>
<p>&nbsp;</p></body>
</HTML>
