<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Step 4.3: Displaying the Overlay Surface</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h4><a name="_dx5_step_4.3_displaying_the_overlay_surface_ddraw"></a>Step 4.3: Displaying the Overlay Surface</h4>
<p>
After you've set up the source and destination rectangles, you can display the overlay for the first time. If you've prepared correctly, this will be simple. The Mosquito sample uses the following code to initially display the overlay:</p>
<pre><code>// Set the flags we'll send to UpdateOverlay
    dwUpdateFlags = DDOVER_SHOW | DDOVER_DDFX;

    // Does the overlay hardware support source color keying?
    // If so, we can hide the black background around the image.
    // This probably won't work with YUV formats
    if (capsDrv.dwCKeyCaps &amp; DDCKEYCAPS_SRCOVERLAY)
        dwUpdateFlags |= DDOVER_KEYSRCOVERRIDE;

    // Create an overlay FX structure so we can specify a source color key.
    // This information is ignored if the DDOVER_SRCKEYOVERRIDE flag isn't set.
    ZeroMemory(&amp;ovfx, sizeof(ovfx));
    ovfx.dwSize = sizeof(ovfx);

    ovfx.dckSrcColorkey.dwColorSpaceLowValue=0; // Specify black as the color key
    ovfx.dckSrcColorkey.dwColorSpaceHighValue=0;

    // Call UpdateOverlay() to displays the overlay on the screen.
    ddrval = g_lpddsOverlay-&gt;UpdateOverlay(&amp;rs, g_lpddsPrimary, &amp;rd, dwUpdateFlags, &amp;ovfx);
    if(FAILED(ddrval))
        return FALSE;
 </code></pre>
<p>
The preceding example starts by setting the DDOVER_SHOW and DDOVER_DDFX flags in the <i>dwUpdateFlags</i> temporary variable, indicating that the overlay is to be displayed for the first time, and that the hardware should use the effects information included in an associated <a href="ddref_31h3.htm"><b>DDOVERLAYFX</b></a> structure to do so. Next, the example checks a previously existing <a href="ddref_1a9j.htm"><b>DDCAPS</b></a> structure to determine if overlay source <a href="glossary_0xbn.htm#_dx5_color_key_glos">color keying</a> is supported. If it is, the DDOVER_KEYSRCOVERRIDE is included in the <i>dwUpdateFlags</i> variable to take advantage of source color keying and the example sets color key values accordingly.</p>
<p>
After preparation is complete, the example calls the <a href="ddref_0nxz.htm"><b>IDirectDrawSurface3::UpdateOverlay</b></a> method to display the overlay. For the call, the first and third parameters are the addresses of the adjusted source and destination rectangles. The second parameter is the address of the primary surface over which the overlay will be displayed. The fourth parameter consists of the flags placed in the previously prepared <i>dwUpdateFlags</i> variable, and the fifth parameter is the address of <b>DDOVERLAYFX</b> structure whose members were set to match those flags.</p>
<p>
If the hardware only supports one overlay surface and that surface is in use, the <b>UpdateOverlay</b> method fails, returning DDERR_OUTOFCAPS. Additionally, if <b>UpdateOverlay</b> fails, you might try increasing the width of the destination rectangle to accommodate for the possibility that the hardware incorrectly reported a minimum stretch factor that was too small. However, this rarely occurs and Mosquito simply fails if <b>UpdateOverlay</b> doesn't succeed.</p>
<p>&nbsp;</p></body>
</HTML>
