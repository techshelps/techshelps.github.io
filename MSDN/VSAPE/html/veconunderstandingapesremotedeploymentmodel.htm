<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Understanding APE's Remote Deployment Model</title>
<style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="veconunderstandingapesremotedeploymentmodel"></a>Understanding APE's Remote Deployment Model</h1>
<p>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:See Also">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="veconUnderstandingAPEsRemoteDeploymentModel_C">
</object>&nbsp;&nbsp;&nbsp;<object id=alink_2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:Tasks">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="veconUnderstandingAPEsRemoteDeploymentModel_T">
</object></p>
<p>
APE models remote deployment using two separate components working closely together: a worker and a service. This is good component-based design, separating the execution context (worker) from the actual computational routines or business services (service). Since remote components are most efficiently packaged as in-process servers, they need a process space on the remote machine in which to execute. The worker component provides this process space and execution thread, while the service encapsulates the application-specific functionality.</p>
<p>
As with all remote components, the resource capacity of the remote machine often limits the amount of work that can be done. In order to use remote components as part of a high-performance enterprise application, you must understand APE's three basic remote deployment models and how they affect your application's performance. These are:
<ul type=disc>
<li>
Synchronous Communication Model<br><br></li>
<li>
Asynchronous Communication Model<br><br></li>
<li>
Queued Objects Communication Model with Callbacks</li>
</ul>
<p>
The following sections will acquaint you with the important remote deployment design concepts that you can configure and test using Application Performance Explorer.</p>
<h2>Synchronous Communication Model</h2>
<p>
The Application Performance Explorer implements synchronous connections as a direct request from a client application to an object that lives on a remote network server. Because the connection is synchronous, the client application waits for the task to be completed and is blocked until the server returns.</p>
<p>
<img src="ve53t81.gif" border=0></p>
<p>
In step 1 of the preceding illustration, the client creates a worker, which in turn creates a service that performs the work. When the service is finished, both the worker and service are destroyed. In step 2, additional clients create additional workers and services, never sharing them with other clients.</p>
<p>
Direct object instantiation and executing repeated calls on a method is most useful for exploring network latency. Changing calling parameters and return value sizes can help determine network throughput, which can be useful in deciding which components should be run across a network on remote computers and which should remain together on a single machine.</p>
<p>
One of the limitations of the synchronous approach is the overhead involved in starting the worker and service objects. When a client is done with a worker, both the worker and service are destroyed.</p>
<h2>Asynchronous Communication Model</h2>
<p>
Without queuing, when a burst of requests comes in the object pool starts growing, the objects can't recycle fast enough, and the new object allocations rapidly degrade the server into a thrashing state. Without queuing, you must have sufficient memory on the server to deal with the absolute peak load, which is often many times more than the hardware needed for normal processing loads.</p>
<p>
The asynchronous communication model keeps workers "alive" and reduces the overhead of initializing them. There are a number of approaches to this, including pool manager and queue manager scenarios. APE implements a queue manager as shown below.</p>
<p>
<img src="ve53t82.gif" border=0></p>
<p>
In the simplest case, in step 1 the queue manager creates a given number of workers, all of them initially having a "not busy" status. In step 2, when a client request comes in, the queue manager allocates a worker and marks it as "busy." In step 3, the queue manager uses the worker to perform the service until it is completed, and changes its status back to "not busy." In step 4, the queue manager accepts all requests and allocates workers on a first-come, first-served basis.</p>
<p>
Because the queue manager maintains its queue internally, client requests are never refused. If all pre-allocated workers are busy, the queue manager simply waits until one becomes available and assigns it to the next waiting client in turn. In distributed solutions, such a queue can be used to keep workers busy. This results in servers running at their optimum performance level — that is, fully loaded.</p>
<p>
The choice to communicate asynchronously has another particular advantage: if the receiver is not running at the same time as the server, synchronous communication attempts will always fail; asynchronous communications can still succeed.</p>
<p>
The performance value of queuing is that it allows your hardware to work at capacity without mismanagement or inefficient use. A side benefit of queuing is that, during peak workloads, the application's throughput degrades gracefully. Queuing is an important design concept required for high-performance, robust applications.</p>
<p>
It's important to notice that this asynchronous deployment model has no provision for either returning status information to the client or logging transaction information for administrative purposes.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Although the current implementation of APE does not directly use Microsoft Message Queue Server (MSMQ) during performance test runs, APE does have a configurable Job Manager queue that can be adjusted to realistically model your application as if it were actually using MSMQ.</p>
<p>
<B><b>For More Information</b></B>&nbsp;&nbsp;&nbsp;For more information on why queuing is an important design concept, see <object id=alink_3 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="veconPerformanceValueOfServiceQueuingWithMSMQ">
</object><a href=JavaScript:alink_3.Click()>Performance Value Of Service Queuing with MSMQ</a>. Microsoft Message Queue Server (MSMQ) is available in the Windows NT Service Pack 4. For more information on installing and using Microsoft Message Queue Server, see information about Windows NT Server at the Microsoft Web site at http://www.microsoft.com/ntserver/.</p>
<h2>Queued Objects Communication Model with Callbacks</h2>
<p>
The queued objects model with callbacks has provision for either returning status information to the client or logging transaction information for administrative purposes.</p>
<p>
In general, return information can be conveyed in one of two ways: either synchronously through a return value, or asynchronously through an indirect notification mechanism. The synchronous (direct) method results in the client program being blocked waiting for the return to complete. For asynchronous operations, a separate notification mechanism is required. Callbacks, available in Visual Basic, provide such a mechanism. Callbacks allow the client to continue processing and be notified asynchronously when the server side has something relevant to report.</p>
<p>
To use callbacks in the queue model, an additional component, the expediter, is used to queue return information back to the client.</p>
<p>
<img src="ve53t83.gif" border=0></p>
<p>
In operation, the client implements an internal Callback class with a predefined method. In step 1, the client then creates an instance of that callback object and passes a pointer to it to the queue manager, along with its work request. In step 2, the queue manager in turn calls the worker, passing the callback object pointer. In step 3, when the task is completed, the worker returns information to the queuing manager, once again passing along the pointer to the callback object. In step 4, the expediter calls back asynchronously into the client object. </p>
<p>
Notice that this diagram also illustrates the queue manager, worker, and expediter all feeding into a logger.</p>
</BODY>
</HTML>
