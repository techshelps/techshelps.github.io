<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Why Use Application Performance Explorer?</title>
<style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="veconwhyuseapplicationperformanceexplorer"></a>Why Use Application Performance Explorer?</h1>
<p>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:See Also">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="veconWhyUseApplicationPerformanceExplorer_C">
</object>&nbsp;&nbsp;&nbsp;<object id=alink_2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:Tasks">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="veconWhyUseApplicationPerformanceExplorer_T">
</object></p>
<p>
Application Performance Explorer (APE) helps with the design process by setting up test cases with various logical and physical deployment configurations, and measuring performance under run-time workload conditions you define. Using APE to define and save profiles that prototype your design choices, you can adjust and evaluate those choices more easily than has traditionally been possible.</p>
<p>
One of the key assumptions in designing modern multi-tier, client/server, distributed applications is that components are valuable. Using components you can break up a big problem into smaller, more manageable pieces, often with the benefit of reusing work from other developers. In addition, in component-based applications, you can use valuable design options such as asynchronous execution, remote resources, and differing logical and physical deployment configurations.</p>
<p>
It's not unusual for a developer to have very little experience with multi-tier, distributed component architectures. Unfortunately, the design assumptions that often lead to a successful workstation application are often tragically wrong for a component-based, distributed enterprise application. In the classic desktop or mainframe programming scenario, resources are fully dedicated to the application's demands. In distributed applications, this idea of on-demand allocation of shared server resources is actually an expensive and damaging notion that developers should not carry from their desktop-centric application model.</p>
<p>
For example, while it's true that the location transparency of DCOM allows an application to call remote objects as if they were local, this model is not efficient as the workload increases. The overhead of creating the objects and the associated resource consumption required to satisfy dozens or hundreds of simultaneous users eventually consumes a machine to the point of thrashing. Instead, design strategies that incorporate service queuing and object pooling can provide higher performance in distributed application architectures.</p>
<p>
<B><b>For More Information</b></B>&nbsp;&nbsp;&nbsp;You can find guidelines for designing enterprise applications in <object id=alink_3 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="veconDefiningApplicationLogic">
</object><a href=JavaScript:alink_3.Click()>Defining Application Logic</a>.</p>
<p>
In order to understand the performance opportunities and design consequences of your distributed applications, you can use Application Performance Explorer to create real run-time scenarios, stressing all of the application's infrastructure in accordance with adjustable settings.</p>
<p>
APE is configurable to show the performance implications of client loads, network bandwidth, machine boundaries, component instancing and reuse, queuing, DCOM business service processes, data access and transfer methods, server capacity, and various physical deployment options.</p>
<p>
Design and performance testing options include modeling various Microsoft BackOffice technologies such as Microsoft Transaction Server (MTS) and Microsoft SQL Server.</p>
<p>
Application Performance Explorer can help you understand and evaluate different design strategies and discover the optimum architectural model for your application by providing:
<ul type=disc>
<li>
Design performance evaluation.<br><br></li>
<li>
Easily configured and storable design scenarios.<br><br></li>
<li>
Reference source code examples demonstrating recommended design technologies.</li>
</ul>
<p>
In addition, APE is itself an example of a well-designed distributed application. The APE source code is commented, and is structured to serve as a template for component-based applications. This source code has been designed so that you can use it as the starting point for your own distributed multi-tier application.</p>
<p>
<B><b>For More Information</b></B>&nbsp;&nbsp;&nbsp;The source code for the Application Performance Explorer is in the <code>..\Program Files\Microsoft Visual Studio\Common\Tools\Ape\Source</code> subdirectory of your Visual Studio installation.</p>
</BODY>
</HTML>
