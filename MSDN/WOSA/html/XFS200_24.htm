<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>3.8.2 Compound Devices</TITLE>
<BODY bgcolor=white>

<FONT FACE="verdana"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>
<h5>
3.8.2 Compound Devices</h5>
<p>
Compound devices are very common in the financial services industry.  For the purposes of this discussion, there are three types of compound devices:</p>
<ul>
<li>
Two or more separate logical devices that share a physical housing (or perhaps some other attribute), but function completely independently of one another<p>
</li>
<li>
Two or more distinct logical devices that are functionally interdependent in some way, such as a journal printer and passbook printer that use the same print head mechanism<p>
</li>
<li>
Two or more logical devices that are simply different logical views of a single physical device, such as a single printer that is managed as two separate logical devices, a document printer and a passbook printer</li>
</ul>
<p>
The first of these types has no special significance from the XFS point of view.  Each of the devices is managed as a separate logical and physical device, and the system configuration issues (e.g., making sure that devices that are packaged together are assigned to the same workstation) are left to application utilities outside the scope of this specification.</p>
<p>
The latter two types are treated identically in an XFS system.  When any one of a set of interdependent logical devices that forms a compound device is locked, all the other logical devices in that compound device are also <b><i>implicitly</i></b> locked on behalf of the requesting application.  (The specific policy is described below.)  If the <b><i>same</i></b> application (see the discussion of “application identity” below and in Section 3.5) explicitly requests a lock of another of these logical devices, the lock is granted.  In order to allow the application to “know” that the devices are part of a compound device, and therefore interdependent, the <b>WFSLock</b> function returns an array of service handles, defining the set of other devices within the compound device that are now explicitly locked  by the application.  This allows the application to manage its use of these devices accordingly.  Normally, it must use them in a strictly sequential manner to avoid any possible conflicts, but if it has some special knowledge of how the devices are related, it may be able to multiplex requests in some ways.</p>
<p>
Note that an application can also determine whether a device is compound by using the device capabilities query function of <b>WFSGetInfo</b>.</p>
<p>
There are many different ways in which programmers can make use of multiple threads and/or processes in financial applications.  Each WOSA/XFS service can be controlled from its own thread; all services can be controlled from a single thread, with other threads/processes used for other application functions; several identical threads can handle all open services as needed; etc.  In some of these models, the “user” of a service could be considered to be the process as a whole; in other models, the “user” is a single thread.  The WOSA/XFS design allows for both models by providing the programmer the capability to explicitly control the “identity” of an application.  The programmer can make all the threads in a process appear to a service provider as one “application,” identify each thread as a different “application,” or create some hybrid of these approaches, allowing interdependent compound devices to be managed correctly no matter what application architecture is used.</p>
<p>
In order to allow this flexibility in application architecture, the “identity” of an application can optionally be managed explicitly using the concept of <u>application handles</u>.  An application handle (<i>hApp</i>) is created using the <b>WFSCreateAppHandle</b> function, and is guaranteed unique within the system.  The <b>WFSOpen</b> function takes an optional application handle parameter which is bound to the service handle (<i>hService</i>) returned by the open function.  This approach allows applications that use interdependent compound devices to be implemented with any combination of single or multiple processes and/or threads, by explicitly managing an appropriate set of application handles.  If this facility is not used (indicated by the application using the value WFS_DEFAULT_HAPP for the <i>hApp</i> parameter in <b>WFSOpen</b>), the XFS subsystem automatically treats each process as having a single, unique application handle.  See Section 3.5 for additional discussion of this topic.</p>
<p>
The lock policy for interdependent compound devices uses the same rules as for independent devices, with some additional constraints.  In order to synchronize access via multiple logical services to a single physical device, or to interdependent devices, the service manages a single lock queue and a single deferred queue for the set of related logical services.  The additional constraints are:</p>
<p>
<b><u>Service state:  LOCK_PENDING</u></b></p>
<ul>
<li>
When a lock request has been granted to one of a set of related logical services:<ul>
<li>
All the other related services in the set change to a “reserved” state in which they are treated as being in the LOCKED state for requests not from the owner.<p>
</li>
<li>
Any lock request from the owner for one of the reserved services is granted on arrival.<p>
</li>
<li>
Lock requests that are not from the owner of the reserved devices are placed in the lock queue.</li>
</ul>
</li>
</ul>
<ol>
</ol>
<p>
<b><u>Service state:  LOCKED</u></b></p>
<ul>
<li>
Any lock request from the owner for one of the reserved services is granted on arrival.<p>
</li>
<li>
Lock requests that are not from the owner of the reserved devices are placed in the lock queue.<p>
</li>
<li>
Note that if a <b>WFPUnlock</b> or <b>WFPClose</b> request is processed for the service, and any other logical service that is related to this service is in the LOCKED state, then the service state is set to “reserved,” <b><i>not</i></b> UNLOCKED.<p>
</li>
<li>
Note also, that if a <b>WFPUnlock</b> or <b>WFPClose</b> request is processed for the service, and the other logical services that are related to this service are in the “reserved” state, then all these services change to the UNLOCKED state.</li>
</ul>
</BODY>
</HTML>
