<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>3.9 Timeout </TITLE>
<BODY bgcolor=white>

<FONT FACE="verdana"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>
<h5>
3.9 Timeout </h5>
<p>
There are two fundamentally different time domains in a system, each having a different implication on the concept of timeout:</p>
<ul>
<li>
“user time” = real time; timeout here says simply “this job is taking too long” as defined by the application and/or the user (indicated by a WFS_ERR_TIMEOUT error code)<p>
</li>
<li>
“service time” = the time taken by the service request <b><i>within</i></b> the service; typically, the physical device operation (indicated by WFS_ERR_DEV_NOT_READY or WFS_ERR_HARDWARE_ERROR error code)</li>
</ul>
<p>
In WOSA/XFS systems, the service manages the latter, <b><i>without</i></b> needing any input from the application, since it “knows” the charactistics of the device, and can generate a timeout event if the device takes too long, even if the application timeout value (if any) has not been exceeded.  Therefore, the timeout value provided in the API is treated by the service provider as user/real time.  If the time is exceeded, the service provider cancels the request and returns a timeout event to the application.  An application can also specify that a request should wait until completion, no matter how long the request takes, by specifying the special value WFS_INDEFINITE_WAIT.</p>
</BODY>
</HTML>
