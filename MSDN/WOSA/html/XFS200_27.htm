<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>3.11 Notification Mechanisms — Registering for Events</TITLE>
<BODY bgcolor=white>

<FONT FACE="verdana"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>
<h5>
3.11 Notification Mechanisms — Registering for Events</h5>
<p>
The <b>WFSRegister</b> and <b>WFSDeregister</b> functions (and their asynchronous counterparts) are used to register and deregister the window procedures which are to receive Windows messages when particular unsolicited, asynchronous events occur, either during request processing or at other times.  In other words, they are used to enable or disable the reception of event notifications.  By providing notifications of this type to applications, the requirement to poll for status is removed, and a simple method for implementing &quot;monitoring&quot; applications is provided.  Each <b>WFSRegister</b> call specifies a service handle (<i>hService</i>), one or more event classes, and an application window handle (<i>hWnd</i>) which is to receive all the messages of the specified class(es).  The corresponding SPI functions, <b>WFPRegister</b> and <b>WFPDeregister</b>, implement the API functions.  </p>
<p>
There are four classes of events:</p>
<ul>
<li>
SERVICE_EVENTS<p>
</li>
<li>
USER_EVENTS<p>
</li>
<li>
SYSTEM_EVENTS<p>
</li>
<li>
EXECUTE_EVENTS</li>
</ul>
<p>
For the first three of these event classes, if a class is being monitored and an event occurs in that class, a message is broadcast to every <i>hWnd</i> registered for that class, specifying the service identified by the <i>hService</i> handle.  The events are generated when:</p>
<ul>
<li>
the service status changes (SERVICE_EVENTS), e.g., a printer is suspended or is no longer available.<p>
</li>
<li>
the service needs an operation from the user to take place (USER_EVENTS), e.g., a device needs “abnormal” attention, such as adding paper or toner to a printer.<p>
</li>
<li>
a system event occurs (SYSTEM_EVENTS), e.g., a hardware error occurs, a version negotiation fails, the network is no longer available or there is no more disk space.</li>
</ul>
<p>
The EXECUTE_EVENTS class is different from the other three.  These are events which occur as a normal part of processing an <b>WFSExecute</b> command.  Examples include the need to interact with the user or operator to request an action such as inserting a passbook into a printer, “swiping” a mag stripe card, etc.  A message generated by one of these events is sent <b><i>only</i></b> to the application that issued the <b>WFSExecute</b> that caused the event, even though other applications are registered for EXECUTE_EVENTS.  Note that an application must explicitly register for these events; if it has not, and such an event occurs, the event is not deliverable and the <b>WFSExecute</b> completes normally.</p>
<p>
The logic of <b>WFSRegister</b> is cumulative: for a given service the number of notification messages sent may be increased by specifying additional event classes.  Since the XFS Manager does not keep track of what events the application is registered for and the logic of the register/deregister mechanism is cumulative, the service providers are responsible for implementing the logic of this process.</p>
<dl>
<dt>
An application requests registration for more than one event class in a single call by using a logical ‘OR’:</dt>
<dd>
<pre><FONT FACE="COURIER NEW" SIZE=2>hr = <b>WFSRegister</b>( hService,USER_EVENTS|SERVICE_EVENTS,hWnd );</FONT></pre>
</dd>
</dl>
<p>
Note that services always monitor their resources, regardless of whether any application has registered for event monitoring or not.  Issuing <b>WFSRegister</b> simply causes a service to send notifications to the service provider, which, in turn, sends notifications to one or more applications.</p>
<p>
To communicate to the XFS Manager that it no longer wishes to receive messages in one or more event classes, an application can cancel any previous registration using the <b>WFSDeregister </b>function.  The logic of <b>WFSRegister</b> and <b>WFSDeregister</b> is symmetric: the application can deregister one or more classes of events monitored for each window, by properly specifying them in the parameter list.  To deregister completely (e.g., every event class for every window), an application uses NULL event class and window handle values in the parameter list. </p>
<p>
Although the <b>WFSDeregister</b> takes effect immediately, it is possible that messages may be waiting in the application's message queue.  A robust application must therefore be prepared to receive event messages even after deregistration.</p>
<p>
Note that an event notification message always passes the information describing the event to an application by pointing to a <b>WFSRESULT</b> data structure.  After the application has used the data in the structure, it <b><i>must</i></b> free the memory that the service provider allocated for the <b>WFSRESULT</b> data structure, using the <b>WFSFreeResult</b> function.</p>
</BODY>
</HTML>
