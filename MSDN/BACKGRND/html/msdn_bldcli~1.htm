<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Building Successful Client/Server Applications</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_bldcli~1"></a>Building Successful Client/Server Applications</h1>
<p>
Bill Vaughn<br>
Microsoft Corporation</p>
<p>
March 19, 1997 </p>
<h2>Introduction</h2>
<p>
Today, over 80 percent of the applications running on a Microsoft® Windows® platform access data. More and more of these applications are used where the client/server architecture is not only recommended, but is a requirement. Unfortunately, most of these applications fail to succeed for a variety of reasons, including poor planning, design, and implementation. Here, we examine the most common mistakes, and discuss the benefits of using the Active Platform. Developers use the Active Platform so that client/server applications work seamlessly over the Internet, an intranet, or corporate network. </p>
<h3>What Makes a Design a Client/Server Design?</h3>
<p>
There are many answers about what differentiates client/server architecture from some other design. There is no single correct answer, but generally, an accepted definition describes a <i>client</i> application as the user interface to an intelligent database engine—the <i>server</i>. Well-designed client applications do not hard code details of how or where date is physically stored, fetched, and managed, nor do they perform low-level data manipulation. Instead, they communicate their data needs at a more abstract level, the server performs the bulk of the processing, and the result set isn’t raw data but rather an intelligent answer. </p>
<p>
Generally, a client/server application has these characteristics:
<ul type=disc>
<li>
<b>Centralized Intelligent Servers <br>
</b>That is, the server in a client/server system is more than just a file repository where multiple users share file sectors over a network. Client/server servers are intelligent, because they carry out commands in the form of Structured Query Language (SQL) questions and return answers in the form of result sets. <br><br></li>
<li>
<b>Network Connectivity<br>
</b>Generally, a server is connected to a clients by way of a network. This could be a LAN, WAN, or the Internet. However, most correctly designed client/server designs do not consume significant resources on a wire. In general, short SQL queries are sent from a client and a server returns brief sets of specifically focused data.<br><br></li>
<li>
<b>Operationally Challenged Workstations<br>
</b>A client computer in a client/server system need not run a particularly complex application. It must simply be able to display results from a query and capture criteria from a user for subsequent requests. While a client computer is often more capable than a dumb terminal, it need not house a particularly powerful processor—unless it must support other, more hardware-hungry applications.<br><br></li>
<li>
<b>Applications Leverage Server Intelligence<br>
</b>Client/server applications are designed with server intelligence in mind. They assume that the server will perform the heavy lifting when it comes to physical data manipulation. Then, all that is required of the client application is to ask an intelligent question—expecting an intelligent answer from the server. The client application's job is to display the results intelligently.<br><br></li>
<li>
<b>Shared Data, Procedures, Support, Hardware<br>
</b>A client/server system depends on the behavior of the clients—all of them—to properly share the server's—and the clients’— resources. This includes data pages, stored procedures, and RAM as well as network capacity.<br><br></li>
<li>
<b>System Resource Use Minimized<br>
</b>All client/server systems are designed to minimize the load on the overall system. This permits an application to be scaled more easily—or at all. <br><br></li>
<li>
<b>Maximize Design Tradeoffs<br>
</b>A well-designed client/server application should be designed to minimize overall systems load, or designed for maximum throughput, or designed to avoid really bad response times—or maybe a good design can balance all of these.</li>
</ul>
<p>
Exactly how this design is implemented is up to the systems architect. The design can be scaled into a single-tiered, two-, three-, or <i>n-</i>tiered design, or be implemented on the intranet, Internet, or on a local server.</p>
<p>
With the advent of the Active Platform and its associated technologies, browser-based applications can also fall into the client/server category. The leading browsers from Microsoft and Netscape can host applications and packaged controls, and can easily act as a host for client/server applications. While these controls can be written in Java script, also called Java applets, they can also be written in Visual Basic® or Visual C++® by creating ActiveX™ Components.</p>
<p>
Strictly speaking, the Web is a global, non-centralized network of computers operating with TCP/IP, HTTP, and HTML as a base set of protocols. However, removing the global aspect, Web technologies can also apply to local networks. Corporate intranets use Web technologies, meaning they can be non-centralized networks based on TCP/IP, HTTP, and HTML protocols. Computer applications exchange information on corporate intranets with the same core set of protocols as those used over the Web.</p>
<p>
From one perspective, Web technologies simply offer another arena for development efforts. When a developer deploys ActiveX Components in conjunction with Web technologies, for example, the developer can go about it differently—incorporating HTML and Visual Basic Script code, providing security features, and so forth. But even with Web technology the developer still calls methods, sets properties, and handles events. In this way, all of the development team's knowledge about using Microsoft visual tools can be carried into the Web arena.</p>
<p>
From another perspective, applying Web technologies enables an organization to extend development efforts in ways not otherwise possible. For example, benefits of blending ActiveX Components with Internet technology include:
<ul type=disc>
<li>
Easier deployment and client maintenance—components deployed as part of a Web application can be downloaded as needed as page content, eliminating the need to enroll users in the upgrade process.<br><br></li>
<li>
The ability to extend functionality to the Internet—through common protocols, shifting between an intranet and the Internet can be virtually seamless.</li>
</ul>
<h3>Goals Dictate Design</h3>
<p>
When choosing architecture for a data retrieval application, the application architect is faced with a number of issues that really guide or focus the development process. For example, if many people are expected to use the application simultaneously, the choices of which data access technique to use are narrowed. If the application is planned to work over a WAN or the Internet, choices are further reduced. However, if support is only required for a dozen or so users, developers can chose from a broader set of options. </p>
<p>
To start with, consider these goals as guidelines for any client/server development project. As the application is designed, consider that it should be easy to:
<ul type=disc>
<li>
<b>Develop. </b>Designing in ease of development not only means that an application can cost less to develop, it means that the team's skills can be better utilized. It means that training and support costs are lower, and the result can be more robust. By embracing standard component-based design and connectivity standards, and by understanding cross-platform issues, creating a less complex application is also possible.<br><br></li>
<li>
<b>Scale. </b>It is possible to build a single application that can be used by virtually any number of users—simultaneously. This number can range from 2 to 200,000 depending on how the application is built, how it is deployed, and how many users need access to the information it manages. While it isn't necessary to create every application to perform at a level at which it could service ticket requests for a Beatles reunion concert, it should be designed to support the expected growth of the application variables—times two.<br><br></li>
<li>
<b>Maintain. </b>Customer requirements change, businesses change, business needs change and will continue to change while the team adapts existing systems to last week's changes. If a client/server application cannot be changed faster—and at lower cost—than the world around it, it is doomed. In addition, if the application requires rocket scientists to repair or update, accommodating changes over time will be difficult, unless the Rocket Science Team is available to help maintain the system. <br><br></li>
<li>
<b>Deploy. </b>At installation time, the distribution of new application executable files and support components must be clearly established. In addition, simply installing the new application cannot affect the operation of existing applications or system components. It also means that when—not if—the application changes, users' systems can be easily upgraded to the new version.<br><br></li>
<li>
<b>Use. </b>The application must not only work responsively, it must anticipate user needs, adapt to them when working with database information, the whole system, and deliver the requested information—quickly, quietly, and efficiently.</li>
</ul>
<p>
These goals seem simple enough, but designing a client/server application while considering the entire set of customer, developer, and systems constraints can be daunting. </p>
<p>
On the other hand, because we are not designing a single application, but an entire system of company-wide applications to be used over the next ten years, the time invested in design can easily result in a more scalable, maintainable, deployable, and more usable system of applications. Both users and managers will thank the client/server architect for it. </p>
<h2>Avoiding the Top Ten Design Mistakes </h2>
<p>
Many application designs are flawed before the first line of code is written—although admittedly, developers working in the trenches can contribute to the fallibility of a design. With apologies to popular Top Ten List designers, take note of these top ten reasons for systems—especially client/server systems—not meeting expectations:
<ol>
<li>
<b>The design did not deliver what the customers wanted. </b>In many cases, this is because the customer for whom the application was built did not know what they wanted until it wasn't delivered. In the end, they knew what they didn't want, but they did not have a firm grasp of what they <i>did</i> want. Generally, this is the result of an implementation without a clear—meaning written—specification. When writing a specification, the application design writer studies what needs to be done—and comes to an understanding about the result and writes it down. This way the writer and the application consumer come to a common understanding about what the end result will look like, so there will be no misunderstanding when the team delivers its work. <br><br></li>
<li>
<b>The system architect or analyst did not understand which technology to use and how to use it. </b>Invariably, people build what they know how to build, using familiar tools. If the analyst is an ISAM (Indexed Sequential Access Method) expert, predictably an ISAM solution will be posed as a solution for this application. The application consumer has no way of knowing which is the best implementation, and perhaps management doesn't know either. Sometimes a better understanding of the alternatives is in order. <p class=tl>
Sometimes we hear complaints that Microsoft Visual Basic or Microsoft Access is seemingly incapable of building a cursor against a giant table. The real problem was that building a cursor against a giant table was an inappropriate approach. For the most part, client/server applications that support dozens of dozens of users don't build <b>Select *</b> cursors on base tables—they use stored procedures, views, or server-side intelligent objects to return information—not rows.</P></li>
<li>
<b>The design assumed that since the application worked for five users it should work for 50 or 500 or 5000. </b>A corollary is: "since the application worked with 500 users—ten percent of the corporate population—on the test network, it will work on the live corporate network." Too often, we see designs that don't account for the volume of traffic generated by an application or any of the applications that use the same design taken as a whole. <p class=tl>
In today's world of 500K e-mail messages broadcast to everyone announcing the birth of the new group administrator's twins, network bandwidth can be already taxed to the limit. Scalability of any application depends on the quantity of resources consumed by each individual application. This includes workstation resources, but also must include network packets sent and received, round trips to the server, and resources on the server. If a single application creates a 40MB TempDB sorted result set, how is the system going to support 50 or 500 instances of the same application—each consuming server resources like a shark in a feeding frenzy.</P></li>
<li>
<b>The team didn't remember the oldest maxim of all: "What Can Go Wrong Will Go Wrong."&nbsp; </b>In a robust client/server application, many lines of code deal with errors and messages returned from the server or the operating system that support the application. Not only should the application deal with these errors, it should do so from the beginning when the developer knows where problems can best be trapped and addressed. Frequently, the team assumes that the network or the available resources will exist when the application is deployed in the same way they are available when the application is written. <br><br></li>
<li>
<b>Integrating business rules into single applications creates a maintenance nightmare. </b>Over time, teams have moved from building simple two-tier client/server applications that include many business rules and field edits to building more applications using this same design. This can mean that the same business rules are built many times into many applications. While this does not seem to have much influence on the first or second application built, by the time the fourth or fourteenth is coded, problems can arise. Here's why: When business rule code is included into every application and then the rules get changed, someone has to go back and change every application. Business rules belong in a central repository or server where all of the developers can access them as needed. <br><br></li>
<li>
<b>The design didn't account for everyone updating the same records. </b>A common design challenge is addressing heavy insert and update activity focused on the pages containing the most current rows. A developer can deal with this problem by changing the data indexing scheme so new rows are added to different pages in the database. Otherwise, the system is destined to bog down as individual applications vie for the most frequently used pages. <br><br></li>
<li>
<b>The design didn't account for developers accessing potentially sensitive data. </b>Security is a prime concern where I work and it should be concern for other designers too. Since tools such as Visual Basic make client/server data access simple, without appropriate security, it’s possible that a well-intentioned bungler could gain easy access to corporate information and stomp on the data. This is especially true when the User-ID and Password assignments grant permissions to access base database tables. <p class=tl>
By building stored procedures or server-side ActiveX Components to gate access to the data, a developer can prevent the sharks from slithering through the aquarium nibbling at the trophy specimens. This design also offers a way to implement business rules on the server and simplify application design and dissemination. Since security procedures can change without recompiling applications, significant security enhancements can be made without changing a single installed application. </P></li>
<li>
<b>No one is prepared for the attack of the BLOB. </b>Not everyone is a fan of adding Binary Large Objects (BLOBs) to a database. While it is possible to do so, there are not many cases where this yields the best performance. In many cases, tortoise-speed performance can be made dramatically faster by simply leaving the photos, tomes, and other BLOBs in the original source files, and adding a pointer from the database—preferably an HTTP pointer—to the BLOB file.<br><br></li>
<li>
<b>The design failed to anticipate disasters. </b>A data backup-and-restore regimen must be part of any workable client/server design. When it is not, it is just a matter of time before an angry mob wanting to access their data presents itself. Few situations threaten more jobs than not having an adequate backup and restore strategy. Test the regimen, too. In many cases, without the proper utilities and procedures, recovery might not restore a single table or restore at all.<br><br></li>
<li>
<b>The design called for a customized third-party solution that did not have complete buy-off across the company. </b>The “not invented here” (NIH) syndrome hamstrings companies large and small, and has done since the dawn of time. How could someone else's solution be as good as ours? Sometimes decisions are made based on tradition and comfort level, and not on what works best for this situation. While this is a valid process, it must be tempered with the realities of future viability and support. <p class=tl>
Sometimes, the decision to buy or make has more to do with people skills than technical merits. For example, for a team of COBOL programmers faced with implementing a PC solution, IS management can either retrain the staff and start from scratch or buy an outside solution leaving the team to shuffle 80 column cards. Neither is particularly easy to do. Companies that don't make these tough decisions eventually die or are absorbed.</P></li>
</ol>
<h2>Designing with ActiveX Components</h2>
<p>
ActiveX is a set of technologies that enables software components to interact with one another in a networked environment, regardless of the language in which they were created. ActiveX is built on the open Component Object Model (COM) and takes advantage of more than five years of application investment. Integrating ActiveX Components into a design can make what was once a nightmare an easily understood and workable alternative.</p>
<p>
Microsoft ActiveX Scripting is the process of managing ActiveX Components with a scripting language, which through its interpreter enhances HTML to support a limited subset of the Visual Basic Scripting language. It makes the language dynamic by adding the ability to invoke ActiveX Components running on the server as DLLs. A growing set of ActiveX Server Components have been defined to do many useful tasks, including handling user preferences, user authentication, database access, and conducting full-text searches.</p>
<p>
An ActiveX Server Page is built as an Internet Server Application Program Interface (ISAPI) application that runs on top of Microsoft Internet Information Server™ (IIS), or on a peer Web server relative of IIS. You can review a diagram of this relationship in Figure 1.</p>
<p>
<img src="bldcli1.gif" border=0></p>
<p class=label>
<b>Figure 1. Infrastructure of an ActiveX Server Page.</b></p>
<p>
Client requests are made using the HTTP protocol, and are dispatched to the ActiveX Server Page run-time code through ISAPI. The run-time module is coded to handle processing template files and operations such as callouts to ActiveX Components to create the resulting HTTP response—typically an HTML page. Then the response is passed back to the client. ActiveX technologies expand the power of client/server applications in a number of ways—some of which are implemented already with Visual C++ and for the first time in Visual Basic using Visual Basic version 5.0.</p>
<h3>Moving Business Logic to the Server</h3>
<p>
“Thin client” has become a fashionable term to describe HTML-based Web applications that leverage browser or downloaded functionality to build the interface for client applications. Actually, building thinner clients has been a goal of client/server developers for a while, as they code systems that implement business logic in server-side objects, stored procedures, and triggers—which are event-driven stored-procedures. </p>
<p>
Use of server-side components is easier now when using the Microsoft Transaction Server (MTS) and using Visual Basic to build ActiveX Components that the MTS can manage. Previously, the skills of C++ programmers were comprehensive enough to create these advanced components. MTS can be used to manage multiple clients' use of shared headless ActiveX Components by handling thread pooling and security issues as well as permitting remote management of complex multi-operation transactions.</p>
<h3>Creating Common Tools and Forms</h3>
<p>
Historically, when a developer wanted inheritable control and forms, the developer employed complex languages such as C++. With Microsoft visual tools, the choice can be made to use Visual C++ or Visual Basic 5.0. This means a developer can create controls using built-in, OCX-based, or third party Visual Basic controls, and assemble additional controls built from these composite controls. When a member control is modified, the composite controls that include it are affected by the change. </p>
<p>
A developer can also build entire forms using this same technology, to more easily create patterns for implementing specific business solutions. For example, it would be easy to implement a common name/address control form that could be used anywhere a control could be used. Visual Basic version 5.0 includes a powerful set of wizards designed to help extrude properties and implement methods as a developer constructs these controls and codes the property and method handlers. While a programmer might find that creating a grid control is more trouble than it is worth, there is nothing to prevent use of the existing built-in grid control to build a customized adaptation that meets specific needs.</p>
<p>
New data binding technology makes it easier than ever to expose the composite control's properties to a data control. A developer can now bind any number of properties of any control to a data control, including custom composite controls. A developer can also implement custom data management routines for the control to avoid dependence on data source controls. </p>
<p>
By using Remote Data Objects (RDO) and Visual Basic version 5.0, a developer can implement unique events and manage asynchronous operations and these user-developed custom controls can be coded into very sophisticated stand-alone database interfaces.</p>
<p>
No, Visual Basic does not create complex hierarchies of controls when a developer builds custom controls. Each control component is managed independently, which makes deployment and integration easier and results in higher performance.</p>
<h2>Choosing the "Right" Language</h2>
<p>
Once the architect addresses the design of the application, the next step is to focus on the languages and/or tools to implement the design. It takes more than a solid language to develop production-quality applications in today's amalgamation of components, connectivity, and development options. But without a reliable, efficient, and flexible set of development tools, this task can become daunting to impossible. </p>
<p>
The development tool chosen to meet this challenge must coordinate its operations and work in harmony with many aspects of the whole system. Not only must the language work with third-party components and libraries, but it must be capable of developing and leveraging user-written controls and libraries. The language must be useful for developing fast, scalable applications, which can be used as basic building blocks for large and small systems.</p>
<p>
Choosing the right tools for the job is an essential component in implementing any successful client/server application. Our experience has shown that the tool—or combination of tools—that delivers the product on time, on target, and on budget—is more likely to succeed than a tool that might be more sophisticated in its feature set, but does not implement the business solution within the business-case constraints. That is, if the new application works, is fast and feature rich, but two years late and over budget, it won't be too useful—and may doom the application from its inception. As not all client/server applications are successful, really, mitigation of risk is clearly a high-priority consideration when making a choice of development tools. The real question might be whether or not the granularity of control afforded by C++ is necessary, or the ease of use afforded by Visual Basic is preferred. Again, there is often a need for both—each to be used in the right places.</p>
<p>
Another problem we face is that application consumers' needs and demands change faster than we can implement solutions. The key here is to build solutions that are flexible enough to accommodate constantly changing application requirements. Much of this can be done by building custom tools and components that themselves can be used to build customized solutions—leveraging what works, adapting existing tools, and building new components for what doesn't work. Both the rapid application development tools and Visual C++ can play important roles in creating and deploying developer-defined components and tools.</p>
<h3>Using RAD Tools</h3>
<p>
Basically, there are two approaches to building client/server applications using today's technology: 1) Rapid application development (RAD) tools such as Visual Basic and Visual FoxPro™ and 2) more traditional edit, compile, link, and test tools such as Visual C++. While Visual C++ provides some of the RAD features of Visual Basic, it is not suited for RAD development because of its steeper learning curve and longer development cycle. Today, the bulk of client/server applications are being built using RAD tools and C++. That is, when it is necessary to streamline a section of the logic, it sometimes makes sense to implement a lower-level C++ solution for selected procedures. </p>
<p>
This approach can yield optimum performance and can better leverage the experience and skills of both the RAD and C++ teams. However, since the bulk of the client/server application is developed using RAD tools, here we focus on using Visual Basic—and then, how to best leverage C++ when necessary. </p>
<p>
Developers familiar with the introduction of Visual Basic version 4.0 will agree that Visual Basic 5.0 Enterprise Edition is a more mature product. Besides NSTL-certified performance improvements, version 5.0 includes new language features, additional enterprise support applications, and more complete integration with ODBC and Microsoft SQL Server™ platforms. </p>
<h3>Security Issues</h3>
<p>
Whatever implementation strategy is chosen for the client/server application, security must be considered. The loudest Internet advocates admit that the most troubling problem about this public network is security. Until the application can protect confidential business information and confidential data belonging to the organization or its customers, an application has no business sending such data over an unsecured wire. To some critics, it is the equivalent of displaying the information on the reader board in Times Square in New York City or hearing it from the pulpit in the Notre Dame cathedral in Paris.</p>
<h3>Microsoft Developer Studio Delivers These Tools</h3>
<p>
Using Visual C++ or Visual Basic, a developer can code applications, in the form of executable files, DLLs, and ActiveX Components, and execute them virtually anywhere in the system. They can execute anywhere from local in-process modules to remote servers on the other side of the planet. SQL Server can execute them through extended stored procedures. These applications, controls, and libraries can become powerful extensions to the systems software—part of sophisticated <i>n</i>-tiered data access systems. </p>
<p>
To developers and their managers this means:
<ul type=disc>
<li>
Applications and components are more scaleable than ever. Visual Basic and Visual C++ components can be used to create server-side business objects to reduce the dependency on proprietary-language stored procedures and to further reduce client-side footprint and complexity.<br><br></li>
<li>
A developer can build more types of sophisticated tools using Visual Basic without having to relegate all complex solutions to C++ code. This means that C++ teams won't be burdened with building the code to perform the tasks heretofore impossible to do with Visual Basic.<br><br></li>
<li>
Visual Basic controls can be totally integrated into C++ programs and can be debugged using Microsoft Developer Studio and Visual C++ tools.<br><br></li>
<li>
A developer using Visual Basic can create applications and components in any of the Microsoft Office applications, including Microsoft Word, Microsoft Excel, Microsoft PowerPoint®, or Microsoft Project. These applications are added to the third-party applications that have integrated Visual Basic for Applications as their native macro language.<br><br></li>
<li>
These same applications can be used on the Web as Active Documents or as Web-page-based ActiveX Controls without changing a line of code. Visual Basic version 5.0 components can also be exposed to any ActiveX-aware application or simply executed from other applications including SQL Server.</li>
</ul>
<h3>Avoiding Single-Tiered Application Pitfalls</h3>
<p>
Typically, single-tiered applications access the base tables on the server and, in many cases, treat the intelligent server as if it were a common file-based database server. This means a typical client application query fetches rows directly from the tables using hard-coded queries and references to the underlying data structures. In addition, single-tiered applications often depend on updateable cursors that prohibit the use of stored procedures. </p>
<p>
Applications are designed this way because of being ported from ISAM architectures where it is common to create a table object against an entire table, choose an index, and use the <b>Seek</b> method to position to specific rows.</p>
<p>
This approach to data access and retrieval presents a number of problems: 
<ul type=disc>
<li>
When the system administrator only exposes business objects or stored procedures and views for data access, applications based on direct table access logic must be redesigned.<br><br></li>
<li>
Single-tier designs can generate intensive network traffic. Unless queries limit the size of the result sets requested, these applications cannot be scaled easily. This means while the application might work well with a few users, as additional users are added the overall system performance degrades, often to the point of collapse.<br><br></li>
<li>
Single-tier client applications are frequently designed using intimate knowledge of the database schema. This means that if the database management system structure changes—even subtly—all client applications affected by the change risk recoding, recompiling, retesting and redeployment.</li>
</ul>
<p>
Applications designed this way don't leverage existing data access code, because they often evolve on an application basis instead of on a more generic level. This means that work for teams coding larger projects is made especially difficult. Projects must be serialized and constructed in a strict sequence to prevent changes at one level from affecting subsequent coding efforts. When evolved with a generic-level design, the code can be used in any application that accesses the same database. </p>
<p>
Over the years, many successful database applications have been built using two-tiered architecture. Experience has taught us that while this design is easy to setup and implement—and is widely supported by easy-to-use database management tools—its inherent limitations get in the way of performance, scalability, and team development. When planning to build systems that must support more than a dozen or so users, or whose complexity calls for a larger staff of developers and analysts, a systems architect should consider designs that are more sophisticated.</p>
<h2>Building Two-Tiered Applications</h2>
<p>
A first step that most larger database management systems sites have already taken involves migrating much of the database-specific physical access logic out of the client application and placing it on the server where it belongs. When made available on a server, the logic can be more easily implemented, tuned, and reconfigured as needed. Most sophisticated remote servers, such as Microsoft SQL Server, are capable of managing and executing many stored procedures at once—each with their own thread. </p>
<p>
Using this design, thin client applications can be built when this code is repositioned on the server. These client applications must be designed in a fundamentally different way. To begin with, for fetching and updating data thin clients should be written to access logical objects or remote procedures instead of physical objects, such as tables. This is not a new concept. SQL Server and other intelligent databases already use and promote this architecture. However, the new RAD tools are better equipped to directly address these remote business objects or stored procedures. </p>
<h3>Building Two-Tiered Applications by Exposing Logical Business Objects</h3>
<p>
A two-tiered application typically exposes developer-written stored procedures to return rows of data values based on criteria received from client-side invocations. The procedures are also designed to limit the scope of the queries and protect the underlying data from unauthorized access or undisciplined access that can severely limit performance and throughput. For the most part, these stored procedures are designed as business objects. For example, <b>AddCustomer</b>, <b>RemoveCustomer</b>, <b>FindCustomer,</b> and <b>ChangeCustomer</b> procedures perform whatever low-level operations are necessary to perform these logical business operations. </p>
<p>
Another variation on two-tiered applications exposes ActiveX Components that can be executed through extended stored procedure calls directly from stored procedure code. These components also can be intelligent business objects that use properties instead of parameters and methods to perform specific business tasks.</p>
<p>
For example, a developer can implement a <b>Customer</b> object with a set of properties used to expose the various attributes of a specific customer. When it comes time to add, change, delete, or find customers, one or more methods can be defined for each of these operations. By using this approach, the client application simply knows about a <b>Customer</b> object and need not be concerned about how the data is stored, retrieved, or protected. </p>
<p>
As business needs evolve (for example, credit cut-off comes when a customer is 60, not 90, days in arrears), changes to the logical business objects do not affect the base design of the client application. This means that even though business rules change, the client applications need not be rebuilt and redeployed. When changes occur, simply changing them on the server automatically implements the changes system-wide—regardless of the number of applications that use the objects or procedures.</p>
<p>
Building applications out of components has tremendous appeal and was one early promise of object-oriented computing. It is particularly attractive for server applications because it provides a natural way to encapsulate business functions. However, engineering applications from components was harder than it first appeared. A fundamental weakness of early object systems was the lack of a common framework that developers could employ to integrate objects created by different parties into one application, either in the same process or across processes. The Component Object Model (COM) addressed this weakness.</p>
<p>
However, simply having a common component object model is not sufficient for building server applications from components; the components must also use a common server framework. Developers who build their own server frameworks have limited opportunities to use components developed by others.</p>
<p>
When a design spans multiple servers, this calls for expanding three-tier design concepts to additional levels. This is where the Microsoft Transaction Server (MTS) plays a critical support role—performing many complex operations that are, in many cases, simply impossible to perform without the extra help of the Transaction Server. MTM takes up where the Distributed Transaction Manager in SQL Server 6.5 leaves off. It not only deals with transaction issues between servers, but also manages thread pooling and object brokering.</p>
<h4>Maintaining application integrity</h4>
<p>
It is critical that business systems accurately maintain the state of the business. For example, an online bookstore must reliably track orders or major revenue losses can result. Current orders could be lost or dissatisfied customers could take their business elsewhere. </p>
<p>
Maintaining the integrity of business systems has never been easy, especially after failures. Ironically, although computers are becoming increasingly more reliable, systems as a whole are becoming more unreliable. Failures are common with systems composed of hundreds to thousands to millions of desktop computers connected by way of an intranet, and the Internet to tens, or hundreds, or potentially hundreds of thousands of server computers. </p>
<p>
The problem is compounded by the demand for distributed applications. Business transactions, such as reserving a hotel room, increasingly involve multiple servers. For example, credit must be verified, confirmation letters mailed, room reservations managed, and customers billed. Updates must occur in multiple databases on multiple servers. Developers of distributed applications must anticipate that some parts of the application may continue to run even after other parts have failed. These failure scenarios are orders of magnitude more complicated than those of monolithic applications, which fail—when they do—completely.</p>
<p>
Business applications are frequently required to coordinate multiple pieces of work as part of a single business transaction. For example, before booking a hotel room, an online travel agent wants to capture appropriate billing information and, conversely, would not bill a customer without booking a hotel room. Coordinating the pieces of work so that all of it happens or none of it happens is difficult without special support from the system. Guaranteeing atomic updates, even in the face of failures, is hard. It is especially difficult when an application is distributed across multiple databases or systems. Using multiple components, which by design hide their implementations, can compound the complexity.</p>
<p>
Applications must also deliver consistent behavior when multiple clients access a component. Concurrent orders for the same book title should not result in sending two copies of the book to a customer, unless that's what the customer ordered. Unless the application is properly written, race conditions will eventually cause inconsistencies. These problems are difficult and expensive to resolve, and are more likely to occur as volume and concurrency increase. Again, using components compounds the problem.</p>
<p>
Microsoft Transaction Server integrates transactions with component-based programming so a developer can code robust, distributed, component-based applications.</p>
<h2>Examining a Three-Tiered Implementation</h2>
<p>
To get a better picture of what a business object really is and how a set of these objects could be implemented, lets look at a simple implementation in more detail. First, consider that the real benefit to business objects is the ability to access them from multiple clients. That is, once a logical business object is created a human interface front-end or a telephone switch computer can access it with equal ease. For the development team, this means that once the specification for the business object is published, developers from all over the company can code applications that leverage its logic as a portal to the database. It is also a carefully orchestrated portal so that business partner developers outside the company can also code applications that use it. </p>
<p>
As an example, consider a simple hotel management system. In this case, we have implemented a number of business objects that are accessed by the front desk using the Desk Clerk application. This application collects data, verifies reservation information about arriving guests, and prints a bill when guests check out. The individual fields are pre-edited by the application by querying a field's description class stored on the server and applying edits as masks to incoming data. </p>
<p>
The hotel phone operators use another interface to query the residents and have no access to more sensitive information. When housekeeping finishes making up a room, they too use the phone to call a special number to record the new room state—clean and ready or still out of order because of remodeling. When a guest places a telephone call, the same system, coupled with the hotel's telephone switch, records the number dialed and duration of the connection, and passes data sent from the telephone service provider to be recorded on the guest's folio. You can see the relationship among these events in Figure 2.</p>
<p>
<img src="bldcli2.gif" border=0></p>
<p class=label>
<b>Figure 2. The Desk Clerk application.</b></p>
<p>
Each of these subsystems use the same business objects to access the base tables in the database—but never open or access them. They are only opened by business objects and they use stored procedures to access the data. Because of this design, if the base tables change or some subtle—or not so subtle—change is made to the way the database works, it has no affect on the applications. Sure, the business objects affected will need to be adapted, but this is a straightforward task. </p>
<p>
When it comes time to upgrade this system to access external systems or add more complex multi-user operations, use of the Microsoft Transaction Server will probably be called for. In the future, when the hotel wants to post room availability on the Web, adding a Web portal should not be a problem—as we discuss below.</p>
<h3>A Brief Look at Object Management Tools</h3>
<p>
Multi-tiered applications can be complicated to build, maintain, and enhance. It is probably not possible to reap many rewards from more sophisticated designs until the development team can leverage the business objects they create. </p>
<h4>The Microsoft Repository</h4>
<p>
To make managing objects easier, Microsoft, in conjunction with Texas Instruments, developed a sophisticated object repository that can cut application development time because it reduces the need to create code from scratch for each new application. A repository is a database for storing software components or pre-constructed segments of code that perform specific operations. The repository not only keeps track of the code, but the documentation associated with it, so a developer can easily see if there is a suitable component to use in the newest design. </p>
<p>
The Microsoft Repository stores components, functional documentation, and Web-related documentation so a development team has access to a gallery of organization-wide components. The repository is available while using a variety of development, modeling, management, and Web-specific tools. Each time a new component is created it is banked in the repository. When it comes time to build a new application, a developer can browse the repository and locate the appropriate pre-built routines to do the job. When an object needs adjustment to fit the new task, the new version is posted to the repository with the appropriate documentation. </p>
<p>
You can read more about Microsoft Repository at <a href="http://www.microsoft.com/repository/">http://www.microsoft.com/repository/</a>.</p>
<h4>The Microsoft Transaction Server </h4>
<p>
Microsoft Transaction Server (MTS) is an essential element of the Microsoft Internet and intranet application strategy. MTS is based on proven transaction-processing methods, but its importance transcends the domain of transaction processing monitors. It defines a general-purpose<i> </i>programming model for distributed component-based server applications.</p>
<p>
Microsoft Transaction Server is specifically designed to support server applications as they scale over a wide range of user volume, from small single-user systems to high-volume Internet servers. It provides the robustness and integrity traditionally associated only with high-end transaction processing systems. </p>
<p>
The Microsoft Transaction Server application model is based on the Component Object Model (COM) and has these benefits:
<ul type=disc>
<li>
The concept of an interface—the means by which a client requests services from an object, such as the logical business objects we discussed earlier.<br><br></li>
<li>
The ability to communicate with an object transparently across process and computer boundaries. This means the objects can reside anywhere the network or the Internet can find them.<br><br></li>
<li>
A component can be identified and dynamically loaded and executed. MTS handles the loading and execution of the logical business objects for an application—so it is not necessary to write that extra code.<br><br></li>
<li>
Objects can support multiple interfaces, so a client application can query an object about its support for a specific interface. This approach means components can offer varying levels of function and new versions can be introduced gracefully. <br><br></li>
<li>
Create component-based applications by using common programming languages and tools, including Visual Basic, Visual C++, Java, and other third-party languages.</li>
</ul>
<p>
Microsoft Transaction Server extends COM to provide a general server application framework. In addition to the inherent COM features mentioned in the previous list, Microsoft Transaction Server:
<ul type=disc>
<li>
Handles server registration, process and thread management, context management, the management and synchronization of shared resources, and component-based security. <br><br></li>
<li>
Introduces transactions into the programming model as a mechanism to achieve atomic updates and consistency across components, database systems, and network boundaries. <br><br></li>
<li>
Provides management tools for administering the distributed environment. </li>
</ul>
<p>
Read more about Microsoft Transaction Server at <a href="http://www.microsoft.com/Transaction/">http://www.microsoft.com/Transaction/</a>.</p>
<h3>Object Modeling Tools</h3>
<p>
Another important consideration for three-tiered applications is the use of object modeling software. A few vendors, listed below, offer such products. Modeling tools have different functions and goals. Some, like Rational Rose, offer a pure object-oriented approach, while others may offer different approaches, including DDL generation or round-trip engineering. They include code generation, including C++ and Visual Basic, as well as reverse engineering.</p>
<p>
The advantage of using object modeling software is this: developers working as a team can set requirements, problem domains, and application architectures. Many of these tools integrate with the Microsoft Repository as well, or the vendors have announced plans to add that support.</p>
<h4>Object modeling software vendors</h4>
<p>
In this list, you'll find the name<b> </b>of the software vendor, the name(s) of the product(s), and the URL for their Web site.
<ul type=disc>
<li>
<b>Cayenne Software </b>(a merger between Cadre and Bachman Information Systems)<p class=tl>
TeamWork and ObjectWork</P><p class=tl>
<a href="http://www.cayennesoft.com/products/datasheets/po-teamwork.html">http://www.cayennesoft.com/products/datasheets/po-teamwork.html</a></P></li>
<li>
<b>Platinum Technology</b><p class=tl>
Paradigm Plus</P><p class=tl>
<a href="http://www.platinum.com/products/appdev/pplus_ps.htm">http://www.platinum.com/products/appdev/pplus_ps.htm</a></P></li>
<li>
<b>Popkin</b><p class=tl>
System Architect</P><p class=tl>
<a href="http://www.popkin.com/prods/product.htm">http://www.popkin.com/prods/product.htm</a></P></li>
<li>
<b>Rational Software</b><p class=tl>
Rational ROSE</P><p class=tl>
<a href="http://www.rational.com">http://www.rational.com</a></P></li>
<li>
<b>Select Software Tools</b><p class=tl>
Select Enterprise</P><p class=tl>
<a href="http://www.selectst.com/Products/Enterprise/Enterprise.htm">http://www.selectst.com/Products/Enterprise/Enterprise.htm</a></P></li>
<li>
<b>Texas Instruments</b><p class=tl>
Composer</P><p class=tl>
<a href="http://www.ti.com/software/portfol/co-main.htm">http://www.ti.com/software/portfol/co-main.htm</a></P></li>
</ul>
<h4>Leveraging existing data</h4>
<p>
Virtually all client/server applications deal with existing data one way or another. One story goes this way. When working for EDS many years ago, a fellow we know created a new IBM 5110 general ledger application that was basically a database of accounting data that replaced an existing paper system. When the application was delivered to the customer, they were happy but called later that day. It seems someone actually laid their old ledgers on top of the system—expecting that the computer would be able to read in their old data. </p>
<p>
While most customers are somewhat more computer-aware than this, odds are any new application will still deal with legacy data. Porting this data to SQL Server or to a Jet database may be an unavailable luxury; the customer is invariably using live applications that cannot be switched off while they are being replaced. In this situation, here are a number of options:
<ul type=disc>
<li>
Build a parallel system and import the existing data on a periodic basis or replicate the data coming into the existing system until both systems are producing the same—or desirable—results.<br><br></li>
<li>
Link to the existing data so the new client applications depend on the existing data store.</li>
</ul>
<p>
The following sections discuss how to access data not stored in the central database, or external data.</p>
<h2>Choosing a Data Access Interface</h2>
<p>
When counting the lines of code in a typical client/server application, one can find that a relatively low percentage is directly related to data-access operations. However, the data access programming model chosen and the way it is used has significant impact on the scalability, performance, footprint, and user acceptance of the application. Even if the "right" data access programming interface is chosen, if the system design does not accommodate its features or it does not correctly manage the DBMS data, again, failure to create a successful application is likely. </p>
<p>
Now that data access code can be implemented in headless components that reside on the server, choice of an efficient data access model is even more important. This is especially true when it is expected that the code will be cloned repeatedly as the transaction manager launches additional copies of the application.</p>
<h3>Using Data Access Objects and the Microsoft Jet Database Engine</h3>
<p>
The Data Access Objects (DAO) were initially created to provide a comprehensive programming interface for all applications—regardless of how or where data was stored. Over time, DAO became increasingly accepted as a native relational .mdb database and ISAM interface. DAO was implemented using the Microsoft Jet database engine—which is a relational data engine, but oriented toward ISAM data access, capable of accessing data from a variety of sources, as we have already discussed. </p>
<p>
The strength of Jet is in its ability to join data from a variety of data sources and permit updates against this disparate data—no small feat. When an application must leverage existing ISAM data, one of the most powerful tools available is the Microsoft Jet database engine. In addition to its native .mdb database format, ISAM data from Microsoft FoxPro, Btrieve, Paradox, or any xBase format is also easily managed by Jet. Because the Jet database engine is exposed by way of DAO, writing code to access both native Jet databases and external ODBC data sources is especially easy. And Jet’s ability to access ODBC data sources also facilitates writing custom data import/export utilities to meet specific customer needs. </p>
<p>
When data must be filtered and modified, DAO can be useful as the Jet query processor. The result set builder can do most of the work so a developer doesn't have to worry about row-by-row data management. The downside of this approach is that it requires a procedure be coded in Visual Basic or Visual C++ to build the result sets and manage the data. </p>
<p>
Jet brings a number of important features to database designs:
<ul type=disc>
<li>
Jet is best when managing data drawn from a variety of legacy sources and where complex heterogeneous joins are performed on these otherwise disparate sources. Jet knows how to manipulate data from ODBC as well as ISAM data sources—at the same time.<br><br></li>
<li>
Using Jet, a developer can build an updateable cursor—even one resulting from a complex join.<br><br></li>
<li>
Jet supports a rich set of referential integrity constraints in addition to cascading updates, deletes, and user security controls—all manageable in code from Visual Basic or Visual C++.</li>
</ul>
<p>
For the most part, Jet is designed to work best with tables. That is, if a design calls for direct table manipulation, Jet is the ticket. However, if a design expects to use stored procedures or remote business objects, Jet might not be the best choice. While a developer can execute stored procedures from DAO, Jet does not handle complex result sets particularly well. That's where DAO ODBCDirect comes in. By using familiar DAO objects, a developer can throw a switch and activate the ODBCDirect mode to access stored procedures and the most complex result sets she can create. </p>
<h3>Using Microsoft Access or Microsoft Visual FoxPro </h3>
<p>
If the application consumer does not want to hand-code a data export/import utility, or only intends to perform the operation once, it makes sense to use one of the interactive DBMS tools such as Microsoft Access or Microsoft Visual FoxPro. These tools are designed to make data transfer easy and foolproof using a graphical user interface. Built in wizards can make management of duplicate result sets or direct exportation of data tables to Microsoft SQL Server—using the Access upsizing wizard—as easy as point-and-click technology can make it. </p>
<p>
Note that it is no longer necessary to use Microsoft Access to create queries to access database tables—or stored procedures. Microsoft Database Tools included with the Visual Basic version 5.0, Enterprise Edition, are designed for this specific purpose. This set of applications is designed to help a non-programmer create queries interactively and manage database schema.</p>
<h3>Using the Microsoft SQL Server Bulk Copy Program Utility</h3>
<p>
If it is necessary to move data to and from delimited ASCII files when working with SQL Server, users will find that the Bulk Copy Program (BCP) utility delivered with SQL Server is often the easiest solution. BCP is provided in either executable form that can be run from a Windows 95 or Windows NT® command line, or through the use of the BCP API as exposed by VB SQL (in Visual Basic) or the DB-Library (in Visual C++). BCP can be configured to deal with a number of file and record formatting issues. SQL Server is designed to deal with the special uploading requirements of BCP so that data transfers can be made quickly. In many production systems, BCP is used in periodic data transfer schemes that upload and download data to base tables on a regular basis—often using interfaces that run completely unattended. </p>
<h3>Accessing Mainframe Data</h3>
<p>
Corporations all over the world depend on legacy data stored in mainframe systems, and this data must be accessible from company-wide departmental and other external systems. In addition, many corporations are using PC and mini-based data concentrators to reduce mainframe loads, making them more productive for more client applications.</p>
<p>
While many applications written for a mainframe are written in high-level languages, such as COBOL or RPG, these applications can usually be ported to Visual Basic with all of the existing business logic intact. There are a number of ways to access this data and the years invested in these applications. This is becoming an increasingly serious issue as software vendors move their support to PC-based client platforms. To support the companies converting to this new technology, a number of companies have implemented upgrade or legacy data leveraging paths to include:
<ul type=disc>
<li>
<b>Screen-scrapers </b>that duplicate the look of green-screen terminals. While this approach is simple, it does little to leverage the power and potential of the PC. These applications replace existing terminals with very little to show for the conversion effort by way of increased productivity.<br><br></li>
<li>
<b>Code converters </b>that convert existing RPG code for the IBM AS400 computer to Visual Basic source code. This approach can yield better performance, but unless a significant amount of work is done, it converts an old database interface and an old database to a new database interface with the same old database.<br><br></li>
<li>
<b>API interfaces </b>to custom IBM AS/400 DLLs that permit access to DB2 databases using a native interface. This approach is supported by companies that provide training for existing COBOL and RPG developers so they can leverage their business experience to create new GUI applications using Visual Basic to access data stored on existing DB2 platforms.</li>
</ul>
<h2>Using Remote Data Objects</h2>
<p>
Remote Data Objects (RDO) was introduced in Visual Basic version 4.0, Enterprise Edition, as a programming model specifically designed to deal with the special needs of client/server developers—especially those accessing SQL Server and Oracle databases. From the beginning it was clear that the ODBC API could deliver the performance required by client/server developers, but it was not particularly well suited for RAD development. The ODBC API required careful management of all aspects of data handling, and if a developer made a mistake, the result was often a general protection fault. When 32-bit platforms are added to the equation, the ODBC API became less attractive.</p>
<p>
RDO was designed to act as a thin layer on the ODBC API—and originally it was. While RDO has grown more powerful in version 2.0, it is still substantially smaller and faster than DAO or other alternatives. </p>
<p>
What RDO adds is productivity. No, RDO applications do not execute quite as quickly as ODBC API applications do, but they can be written faster, and are easier to maintain and deploy because of their employment of ActiveX technology. Unlike the ODBC API—or any API-based approach—RDO is exposed as a set of classes, methods, and properties. It handles all variable binding and memory management tasks as well as asynchronous polling and event management. RDO is also integrated into the User Connection Designer as well as the T-SQL debugger. </p>
<h3>Using RDO to Handle Stored Procedures</h3>
<p>
RDO's chief strength is its ability to handle complex result sets—especially those generated by stored procedures (SP). Since SPs form the core of three-tiered client/server architecture, the ability to invoke them, parse the returning rowsets, output parameters, and return values is vitally important. </p>
<h4>Using the new UserConnection Designer</h4>
<p>
RDO is also used by the UserConnection Designer to create UserConnection objects, a new feature in Microsoft visual tools. Using an interactive wizard, the UserConnection Designer creates a UserConnection object, a structure that identifies a specific connection, and selected stored procedures exposed by the selected database. In code, executing SPs is as simple as calling RDO methods—because the UserConnection object exposes each stored procedure as a method. Passing parameters to the stored procedure is accomplished through method parameters. What once took about a dozen lines of code to create <b>rdoPreparedStatements</b>, set up the parameters, prepare to set up a connection and open it, and create a result set, can now be done with less than half the code. To a developer that means fewer mistakes, to the manager that means more productivity, to a customer, that means a better, more stable application. </p>
<h3>The RDO Client Batch Cursor Library</h3>
<p>
RDO also has added an entirely new cursor library that offers flexibility and speed to Visual Basic version 5.0 data access applications. The Client Batch cursor library has new features so a developer can:
<ul type=disc>
<li>
Establish a connection.<br><br></li>
<li>
Submit a query and create a scrollable, updateable cursor on one or more rows in the database.<br><br></li>
<li>
Disassociate the <b>rdoConnection</b> from the specific connection—essentially hang up on the connection—once the result set is populated.<br><br></li>
<li>
Perform operations on the dissociate <b>rdoResultset,</b> including adds, changes, and deletes. These changes are maintained locally on the client computer.<br><br></li>
<li>
Re-associate the <b>rdoResultset</b> object with a specific connection.<br><br></li>
<li>
Execute the <b>BatchUpdate</b> method that uses optimistic concurrency to synchronize the database with the operations performed while the connection was broken.<br><br></li>
<li>
Manage the collisions—if any—using a status collection that indicates the success or failure of operations—row by row.</li>
</ul>
<p>
The Client Batch cursor library was designed to provide many performance benefits of server-side cursors, but with the extra flexibility of a local cursor store. This new cursor library means that applications can create and manage local cursors more quickly and with more options than were supported with the ODBC cursor library.</p>
<h3>Using RDO Asynchronous Options</h3>
<p>
The patience of an end user is a system resource that should not be overlooked. When an end user feels a system is unresponsive, he or she is likely to reset it—or try to—or give up on the application, although the only thing wrong is that the process takes longer than expected. If, however, the user can see something to indicate that the system is still working, the chances of the user abandoning the operation or the application decrease dramatically. </p>
<p>
The trick is to use asynchronous mode for all operations that are expected—even remotely expected—to take a long time. This way an application can be written to provide a progress bar (even "guess-timate" progress) or some status indicator that gives a user some idea of how long to wait for a response.</p>
<p>
RDO 2.0 now supports more asynchronous operations. In addition, instead of polling RDO, using the <b>StillExecuting</b> property, to see when an operation is complete, RDO supports a group of events that signal the completion and success or failure of each asynchronous operation. For example, a developer can use asynchronous operations to:
<ul type=disc>
<li>
Open and establish connections. This is important when completing the connection is impossible to time—as with a WAN or Internet connection.<br><br></li>
<li>
Create <b>rdoResultset</b> objects. Building cursors—even small ones—can take an indeterminate amount of time. <br><br></li>
<li>
Execute action queries. Many action queries or composite batches can also take a long time to complete—sometimes several hours.<br><br></li>
<li>
Move to the last row of an <b>rdoResultset</b> operation (<b>MoveLast</b>). This fills the last gap in the asynchronous operations.</li>
</ul>
<h3>Using Asynchronous Options to Control Multitasking</h3>
<p>
One of the most important features built into Windows 95 and Windows NT operating systems is support of true multitasking—meaning that an executable file can continue to use CPU cycles while other operations run, usually in the background. This feature does not necessarily mean that an application behaves differently, only that the end user—or an application—can continue to work while another application performs some operation. This also means that an application should not be forced to make an end user wait for a long time without giving the computer system an opportunity to perform other work, or to cancel the currently running operation.</p>
<p>
The programming models discussed here work either synchronously or asynchronously. When an application executes a query, the data interface behaves in one of several ways:
<ul type=disc>
<li>
It blocks or waits until the operation is complete or at least until the first row of the results is ready. This is an example of <i>synchronous processing.</i><br><br></li>
<li>
It returns control immediately, before any result sets have been returned by the query, while the data interface continues to work in the background to fetch the first row(s) of the result set. This is an example of <i>asynchronous processing.</i><br><br></li>
<li>
It returns control after the first row has been returned and continues to populate the result set in the background until it is fully populated. This is another example of <i>asynchronous processing.</i></li>
</ul>
<p>
If it takes more than a few seconds to execute a query, use one of the asynchronous techniques that returns control to the application immediately. In this case, the application periodically checks the data interface until the data is ready for processing. </p>
<h4>Managing reentrancy</h4>
<p>
Another aspect of asynchronous operations is reentrancy. Reentrant code is designed to be executed by more than one part of a program at the same time. For example, if code includes <b>DoEvents</b> statements, or if the operating system supports true multitasking, the end user can execute procedures that are already running. In addition, if an application can continue processing while the data access engine is building the result set, an end user can:
<ul type=disc>
<li>
Choose an option that negates the current query. A developer should write code so the application can cancel the running query and prepare the data interface for any subsequent requests. Unless it is using transactions, the application should not attempt to cancel a query that is modifying data.<br><br></li>
<li>
Initiate another query. This additional query may interfere with the first query or may simply be a duplicate of the query based on operator impatience, or be caused by an inadvertent extra mouse click. Code should either prevent or handle multiple operations. With some programming models, a developer can easily create any additional connections or result sets and start a new query. With other models or on some servers, one operation must be completed before another is initiated.<br><br></li>
<li>
Process part of the result set and request another query. Code should cancel the remaining result sets and reset the data interface before proceeding. If the application supports multiple result sets, code should simply flush the current result set and move to the next result set.</li>
</ul>
<h4>Managing result set population</h4>
<p>
One important part of asynchronous operations is background population of result sets. Because the server can hold locks on pages being retrieved in a query, it is best to complete a query as quickly as possible to free these locks. This should only be a problem for non-cursor, or bulk, operations. For server-side cursors, the keyset is either populated in the background by the server or not populated, which is the case with dynamic cursors.</p>
<p>
Not all of the Visual Basic data access programming models support all features of asynchronous operations. Often a developer will perform background result set population or polling logic in code.</p>
<h4>Creating event-driven applications</h4>
<p>
The Remote Data Object (RDO) events are the first data access events to appear in Visual Basic. Not only do these events signal the end of asynchronous data access operations, but they can also be used to intercept data access operations to ensure that they execute according to plan. These same events are also implemented on the RemoteData control, so it is possible to execute stored procedures both to return rows and to perform updates. Both asynchronous and synchronous queries fire events when queries complete or are about to be executed. By creating procedures for these events, a developer can gain a higher degree of control over an application and prevent lock-up situations that often cause an end user to reboot the system.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;RDO events are not exposed through ODBCDirect.</p>
<h3>The Remote Data Object Class Library</h3>
<p>
The RDO class libraries have also been incorporated into Visual C++. When working in any Microsoft Office application a developer accesses RDO's libraries whenever he or she uses the ODBCDirect mode from DAO. RDO also exposes the underlying ODBC handles so that when it becomes necessary to perform some function not supported by RDO methods or properties, a developer can simply call an ODBC API function using the appropriate handle.</p>
<p>
You can review Remote Data Objects in Figure 3.</p>
<p>
<img src="bldcli3.gif" border=0></p>
<p class=label>
<b>Figure 3. Remote Data Objects</b></p>
<h2>Using Data Bound Controls</h2>
<h3>ODBCDirect—The DAO Client/Server Interface</h3>
<p>
DAO version 3.5, as provided in Visual Basic version 5.0 and other hosts, expands the flexibility of DAO and breaks the dependence on the Jet database engine when accessing ODBC data sources. While DAO applications are still capable of accessing ODBC data sources just as with previous versions, DAO applications can now opt to use the new ODBCDirect mode that relegates all data access operations to RDO. When an ODBCDirect Workspace is activated, the Jet database engine is not loaded. </p>
<p>
ODBCDirect should not be considered as a panacea for applications designed to use ISAM concepts to access relational data. It does not automatically convert single-tiered applications to three-tiered designs. What ODBCDirect does offer is a way for a developer to work in a familiar programming paradigm while accessing remote data sources. ODBCDirect does not expose the table object or the <b>Seek</b> method on the <b>Recordset</b> object. However, it does give a developer access to most of the expanded functionality exposed by RDO. Missing from the list is the ability to trap RDO events and work with stand-alone <b>rdoQuery</b> and <b>rdoConnection</b> objects—the rest is there and usable via DAO objects with which a developer is already familiar. </p>
<h3>ODBC API</h3>
<p>
The ODBC API is the lowest-level data access interface a developer should consider for new application development. Generally, use of the ODBC API should also be limited to adding additional flexibility to RDO—not as a base interface. That is, when a developer needs to manipulate a driver interface or server option that can only be set from the ODBC API, specific ODBC API functions using the ODBC handles generated by RDO objects can be executed. As stated earlier, developing applications directly in the ODBC API is possible, but not recommended. While the resulting application might run faster than its RDO equivalent—but not by much—the development process is more complex and the resulting applications are more difficult to maintain. </p>
<h3>DB-Library</h3>
<p>
When SQL Server was first released, the only way to create client applications was to use the DB-Library API. Over the years Sybase eventually dropped support for DB-Library in favor of their proprietary CT-Lib API interface. While Microsoft has not chosen to abandon DB-Library, it is not planned to be enhanced for subsequent releases. Because of this, DB-Library is not recommended for new applications. </p>
<h3>Active Data Objects</h3>
<p>
ADO is an important technology for the future of the Microsoft data access strategy. The Microsoft Database API group is currently working on two core APIs—ODBC and OLE DB. ODBC is the recognized industry standard database API for SQL data as supported by all major database and database application vendors. OLE DB represents the future data access API for Microsoft as exposed through Active Data Objects (ADO). ADO allows all data sources, not just full-fledged databases, to expose their data through a common set of interfaces. Application writers can consume information from all these different data sources with a common set of interfaces. As ADO gains momentum, the amount of data available through a common set of interfaces is predicted to grow tremendously. </p>
<p>
One distinctive difference exists between OLE DB and the ODBC API. While it is possible to write applications that use the ODBC API from Visual Basic, OLE DB is not intended to be exposed as a programming interface from any language except C++—and then only when writing device drivers for ADO.</p>
<p>
The ADO Automation Server provides standard, easy-to-use, efficient programmability to OLE DB. Significant effort has been made to keep the programming model, objects, and concepts very similar to DAO 3.<i>x. </i>ADO consists of three upward-compatible models:
<ul type=disc>
<li>
<b>ADO 1.0. </b>Small, fast, downloadable, extensible, DML only, an upward-compatible subset of DAO 3.<i>x </i>that exposes new features for ease-of-use and efficient enterprise and Internet data access. The ADO Automation Server provides standard, easy-to-use, and efficient programmability to OLE DB. ADO 1.0 forms the core component of the ADO architecture that has been designed to provide an extensible programming model for building enterprise and Internet applications. <br><br></li>
<li>
<b>ADO DDL. </b>A<b> </b>DDL and information schema add-on to ADO 1.0. <br><br></li>
<li>
<b>Jet Extension to ADO. </b>A DAO 3.<i>x</i> source-code compatible add-on to ADO 1.0 and ADO DDL including Jet-specific features such as replication and arbitrary predicate find.</li>
</ul>
<p>
ADO is shipped as part of the ODBC and OLE DB SDKs. Target customers for ADO include Microsoft Access, Microsoft Excel, Microsoft Office, Microsoft Visual Basic, Microsoft Visual C++, Active Data, Microsoft Visual InterDev™, Forms(3), and the OLE DB and ODBC SDKs. The end users of ADO will continue to be primarily developers who use Visual Basic, Visual C++ and the data access SDK, but there will also be significant core groups that only use ADO in the context of their host product, such as Microsoft Access or Microsoft Excel. </p>
</BODY>
</HTML>
