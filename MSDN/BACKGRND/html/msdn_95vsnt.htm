<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Problems Encountered by Some Windows 95 Applications on Windows NT</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_95vsnt"></a>Problems Encountered by Some Windows 95 Applications on Windows NT</h1>
<p>
Noel Nyman<br>
Microsoft Corporation</p>
<p>
October 2, 1996</p>
<h2>Introduction</h2>
<p>
In general, most applications developed and tested on Microsoft® Windows® 95 will run without modification on Microsoft Windows NT® Workstation 4.0 and Microsoft Windows NT Server 4.0. Many Windows 95–based applications will also run on Windows NT version 3.51. However, a much higher percentage of applications written for Windows 95 will work on Windows NT 4.0 because this version of Windows NT includes the Windows 95 user interface (UI).</p>
<p>
Some applications developed for Windows 95 may not perform as expected when run on Windows NT. A few common coding errors cause most of these problems. Developers can ensure their applications work on all Microsoft 32-bit operating systems by following API calling conventions, avoiding legacy algorithms and code written for 16-bit environments, and using the following guidelines.</p>
<h2>Overview</h2>
<p>
Microsoft® Windows 95®, Windows NT® Workstation 4.0, and Windows NT Server 4.0 are all 32-bit operating systems that use the same Win32® application programming interface (API). Although the API has changed and expanded to encompass new features, code should in most cases work without modification on all three operating systems. (See "Introduction to the Win32 Application Programming Interface" [MSDN Library, Backgrounders].) Developers sometimes find that a program runs bug-free on Windows 95, but has problems running on Windows NT. </p>
<p>
Some of the problems are caused by failure to follow the API calling rules and conventions. Windows NT strictly enforces 32-bit handles, API parameters, and memory ownership among multiple threads. Windows 95 may be tolerant of poor 32-bit coding practices because it must support legacy 16-bit driver code.</p>
<p>
Misinterpreting the operating system platform causes some programs to make Windows 95–specific procedure calls when running on Windows NT. A few developers hard-code executable paths or registry keys that are not identical on Windows 95 and Windows NT. </p>
<p>
We see some common program bugs on both systems, although circumstances often hide them on Windows 95. Some applications fail to deal properly with long file and printer names. Others fail to install dynamic-link libraries (DLLs) that they require, or they replace system DLLs with files for the wrong platform. Developers may use poor coding practices that cause users problems on both Windows 95 and Windows NT.</p>
<p>
There are some differences between Windows 95 and Windows NT that applications must accommodate to run successfully. The user's permissions and rights are inherited by programs they start. The programs may not be able to perform expected tasks on Windows NT if the user has insufficient rights. Windows NT is a Unicode operating system. Programs designed only for Windows 95 may pass ANSI data when Windows NT expects Unicode or treat Unicode data as ANSI.</p>
<p>
Following API conventions, using code reviews and debugging tools to eliminate legacy 16-bit-based code and algorithms, and specifying flexibility in application design that allows programs to adapt to the features of both Windows 95 and Windows NT will provide users with robust products that run well in all 32-bit Windows environments. </p>
<p>
This paper was developed as a result of Microsoft's own internal experiences in testing a wide range of 32-bit applications during the development of the Windows NT 4.0 operating system.</p>
<h2>Following 32-bit API Conventions </h2>
<h3>32-bit Handles</h3>
<p>
Windows 95 and Windows NT are 32-bit operating systems. Both use 32 bits for handles to resources. To accommodate legacy code, Windows 95 accepts 16-bit handles and generates all 32-bit handles with the high 16 bits set to zero. </p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=25%>0000000000000000</td>
<td width=75%>1010101010101010</td>
</tr>
<tr valign=top>
<td width=25%><b>High 16 bits</b></td>
<td width=75%><b>Low 16 bits</b></td>
</tr>
</table><br>
<p class=label>
<b>Figure 1. Windows 95 accepts and generates 32-bit handles with all zeroes in the high 16 bits.</b></p>
<p>
Windows NT 3.<i>x</i> uses all 32 bits for handles. To accommodate legacy code, Windows NT 3.<i>x</i> will accept a 16-bit handle and will try to match it to the low 16 bits of all open handles. If a match is found on the low 16 bits, Windows NT 3.<i>x</i> uses that 32-bit handle in place of the 16-bit handle. To avoid duplicating an existing 32-bit handle with a truncated or 16-bit handle, Windows NT always creates handles with at least one high bit set.</p>
<p>
Windows NT 4.0 requires full 32-bit handles. It will not accept 16-bit handles. All 32 bits are used to identify handles. Any code that doesn't correctly accept and return 32-bit handles will fail on Windows NT 4.0. </p>
<p>
If the application casts a Windows NT 4.0–supplied handle to 16 bits, Windows NT 4.0 will not carry out any API calls using the truncated handle. Some programs truncate a handle to device context (hDC) to 16 bits and then use it to open a Print dialog box. On Windows NT 4.0, the dialog box never appears, so the user is unable to print anything. In other cases, a window may remain on top of the application work area because the handle passed to Windows NT 4.0 with the WM_DESTROY message is truncated. Windows NT 4.0 cannot identify the window to destroy because the handle is invalid. Some developers saw the high 16 bits of all handles always set to zero while developing programs on Windows 95. Thinking that was expected on <i>all</i> platforms, they added code to check for <i>all</i> handles to have zeroes in the high 16 bits. These programs fail when run on Windows NT 4.0 where all handles have at least one nonzero high 16 bit. </p>
<p>
Incorrectly using 16-bit handles in a 32-bit operating system is often caused by porting legacy algorithms or using libraries intended for 16-bit environments. Algorithms should be subjected to careful code review to remove any 16-bit–specific implementations. As part of debugging tests, all handles should be validated as true 32-bit handles. When code is tested on Windows NT 4.0, all handles will have at least one of the high 16 bits set to one.</p>
<h3>API Parameters</h3>
<p>
Windows NT includes functionality that is not available on Windows 95. Win32 APIs invoking those functions require parameters for the Windows NT features, even when run on Windows 95. Windows 95 ignores the parameters it can't use. Code tested only on Windows 95 could pass invalid values for the parameters that Windows NT uses. The invalid values may cause the code to fail when run on Windows NT.</p>
<p>
For example, <b>ChangeDisplaySettings</b> can change the driver refresh rate on Windows NT. That functionality is not supported on Windows 95 drivers. Some applications change display settings and cache the current settings to be restored when the application ends. If the application does not read and cache the refresh rate, an invalid value will be passed to the API call when the display is reset on Windows NT. The driver uses its lowest refresh rate when given an illegal value. Unless the user has, by coincidence, selected that rate, the display will be a different size than the user expected and will probably appear offset on the monitor. </p>
<p>
Test all code that makes API calls and holds returned parameters for later use to verify that all parameters passed from the call are read and cached, even parameters not used by the code or the operating system. Test all parameters passed from the application to API calls to make sure they hold legal value.</p>
<h3>Memory Management</h3>
<p>
Windows NT strictly enforces memory management to maintain security and prevent processes and threads from interfering with each other. Allocated memory and resources may persist after the process or thread terminates, unless the memory or resource is specifically freed.</p>
<pre><code>SetCurrentDirectory(install_directory);
For (hFile = FindFirstFile(szBuffer, &amp;FileInfo);
      hFile != INVALID<u>_</u>HANDLE<u>_</u>VALUE &amp;&amp; bReturnValue;
   bReturnValue = FindNextFile(hFile, &amp;FileInfo))
   {
      DeleteFile(FileInfo.FileName);
   }
SetCurrentDirectory(initial_directory);
bReturn = RemoveDirectory(install_directory);
</code></pre>
<p class=label>
<b>Figure 2. The RemoveDirectory call works as expected on Windows 95, but it fails to remove the installation directory on Windows NT.</b></p>
<p>
The preceding code fragment is an example from an installation program. The program creates <b>install_directory</b>, expands temporary files into it, and uses the files to install the application. This fragment removes all temporary files and <b>install_directory</b> from the system. It loops using <b>FindNextFile</b> to delete the installation files. Then it tries to remove <b>install_directory</b>. The directory is removed as expected on Windows 95. When the same code is run on Windows NT, the call returns <b>ERROR_SHARING_VIOLATION</b> and the directory is not removed. </p>
<p>
Even though <b>FindNextFile </b>returns a null handle when all files have been deleted, the handle <b>hFile</b> is still allocated in memory. Unless <b>FindClose</b> is called to close the handle, Windows NT will not allow any process or thread to remove the folder associated with that handle. Windows NT protects all resources from arbitrary deletion by other processes and threads, and requires developers to specifically free all resources they allocate.</p>
<h2>Interpreting the Operating System Version</h2>
<h3>Background—GetVersion and GetVersionEx</h3>
<p>
Applications determine operating system platform, version, and build information by calling <b>GetVersion</b> or <b>GetVersionEx.</b> (See "To SUR, With Love: Important Stuff to Know About the Windows NT 4.0 Shell Update Release" at http://microsoft.com/win32dev/ui/ntsur.htm.) The <b>GetVersion</b> function returns information in a double word and <b>GetVersionEx</b> returns enumerated constants in a structure. </p>
<table border=1 cellpadding=5 cols=5 frame=below rules=rows>
<tr valign=top>
<td width=16%><code>S</code></td>
<td width=10%><code>9</code></td>
<td width=27%><code>bbbbbbbbbbbbbb</code></td>
<td width=25%><code>iiiiiiii</code></td>
<td width=22%><code>jjjjjjjj</code></td>
</tr>
<tr valign=top>
<td width=16%><b>Win32s™</b></td>
<td width=10%><b>95</b></td>
<td width=27%><b>build number</b></td>
<td width=25%><b>minor ver</b></td>
<td width=22%><b>major ver</b></td>
</tr>
</table><br>
<p class=label>
<b>Figure 3. GetVersion returns platform, build number, and version coded in a DWORD.</b></p>
<h3>Reading GetVersion Returns</h3>
<p>
Some of the Windows 95–based applications when run on Windows NT 4.0 have problems that are caused by their incorrect use of <b>GetVersion</b>. On Windows 95, the two high bits, labeled "S" and "9" in the preceding diagram, are set (not to zero). All versions of Windows NT return zero in these two bits. Both Windows 95 and Windows NT 4.0 return major version "4" and minor version "0." If an application makes installation or internal path decisions based on platform, it must evaluate the platform bits <i>and</i> the version number to make the correct determination of Windows 95 or Windows NT. </p>
<p>
Many applications verify only the operating system version number. Their developers assume that only Windows 95 returns "4" as a major version number. When these applications find major version "4" returned by Windows NT 4.0, they install code that make Windows 95–specific calls into Kernel32.dll. These procedures are not available on Windows NT, and the calls will fail. Often, the applications will fail as well.</p>
<p>
Other applications test only the platform bits. They correctly determine that they are running on Windows NT. Their developers assume the platform must be Windows NT 3.<i>x</i> and that Windows 95 features, such as TAPI and the Windows Explorer shell, are not present. The applications either do not install or do not activate their features that require those Windows 95 functions. In most cases, Windows NT 4.0 supports the same features as Windows 95 and the applications would run successfully. Some applications interpret the platform incorrectly during installation and install files for Windows 95 or an older version of Windows NT. Then the applications use different code after they start that correctly identifies the platform. The applications fail when they tried to execute code they did not install. </p>
<p>
Some applications that require a specific version, or higher, of Windows NT do not correctly evaluate the version information. They test only the minor version number, expecting a value equal to or greater than the minimum version the applications required. The "0" in minor version is less than the value expected, and the applications fail to install.</p>
<p>
A few applications test the platform bits, detect Windows NT, and assume version 3.<i>x</i>, with Windows NT 3.<i>x</i>–style common dialog boxes. Later, the applications determine that the Windows Explorer is present and set the OFN_EXPLORER flag for calling common dialog boxes. When the applications try to create certain common dialog boxes, they pass both the old-style structure and the OFN_EXPLORER flag. Windows NT expects to receive the new-style structure based on the OFN_EXPLORER flag and cannot read the old-style structure. The common dialog box, often the Save As dialog box, is never created, making the critical Save function unavailable to the user.</p>
<p>
Specific build number tests should be avoided in applications. Programs will fail if they test for build "0" as returned by <b>GetVersion</b> on Windows 95 or "950" as returned by GetVersionEx on Windows 95. Windows NT 4.0 returns build numbers between "1058" and "1381" for both calls. Note that the Win32 Software Development Kit (SDK) identifies the build number bits as "reserved" for Windows 95 on calls to <b>GetVersion</b>. Code that tests for any specific return value may fail on future versions of Windows 95 as well as Windows NT.</p>
<h3>Using GetVersionEx</h3>
<p>
<b>GetVersion </b>has been superseded by <b>GetVersionEx,</b> which is the preferred call for new applications. The data is returned in an <b>OSVERSIONINFO</b> structure that's less easily misinterpreted than the individual bits in <b>DWORD</b> from <b>GetVersion</b>. For example, the platform is returned as an enumerated constant.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=50%><b>Value</b></td>
<td class=label width=50%><b>Platform</b></td>
</tr>
<tr valign=top>
<td width=50%>VER_PLATFORM_WIN32s</td>
<td width=50%>Win32s on Windows 3.1 </td>
</tr>
<tr valign=top>
<td width=50%>VER_PLATFORM_WIN32_WINDOWS</td>
<td width=50%>Win32 on Windows 95</td>
</tr>
<tr valign=top>
<td width=50%>VER_PLATFORM_WIN32_NT</td>
<td width=50%>Windows NT</td>
</tr>
</table><br>
<p class=label>
<b>Figure 4. GetVersionEx returns platform as one of three constants in dwPlatformId.</b></p>
<p>
The application must still get <i>all</i> the information it needs to determine operation system platform and version and use that information correctly.</p>
<h3>Using IMAGECFG.EXE to Verify Version Problems</h3>
<p>
The Imagecfg.exe tool is useful for verifying version problems in applications. Imagecfg adds information to the header of the application .exe or .dll that forces Windows NT to return "incorrect" information from <b>GetVersion</b> and <b>GetVersionEx</b> calls in place of the "real" operating system information. Parameters to Imagecfg tell Windows NT what "lie" to pass to the application. By specifying an earlier version of Windows NT or the version information associated with Windows 95, version problem applications may install or function as expected. Imagecfg will only write information to 32-bit headers.</p>
<pre><code>C:&gt;imagecfg&nbsp; -w&nbsp; c0000004&nbsp; sample.exe 
</code></pre>
<p class=label>
<b>Figure 5. After using IMAGECFG with these parameters, Windows NT will return "version 4.0, Windows 95" to sample.exe when it calls GetVersion or GetVersionEx. The "-w" flag indicates that the next parameter is the desired GetVersion DWORD in hexadecimal: Win32s and Windows 95 bits set, build number zero, minor version "0," and major version "4."</b></p>
<p>
Imagecfg can be found in the \support\debug\&lt;platform&gt; folder on the Windows NT compact disc. The command files "SetNT351.cmd" and "Setwin95.cmd" in the same folder will execute Imagecfg with the correct parameters for Windows NT 3.51 and Windows 95. For more information, run Imagecfg with the "-?" switch from a command prompt.</p>
<p class=indent>
<B><b>WARNING</b></B>&nbsp;&nbsp;&nbsp;Imagecfg writes information into the headers of .exe and .dll files that may adversely affect performance of the files. The changes may not be reversible. The tool should only be used on copies of files, <i>never</i> originals. While Imagecfg has been tested extensively, Microsoft will not be responsible for direct or consequential damages resulting from its use on any file.</p>
<h3>Testing for Future OS Versions with IMAGECFG.EXE</h3>
<p>
You can use Imagecfg to identify specific version dependencies in new applications you develop. By using a small build number and a high version number, you can trap errors caused by testing specifically for the information today's operating systems return.</p>
<pre><code>C:&gt;imagecfg&nbsp; -w&nbsp; 00202306&nbsp; sample.exe 
</code></pre>
<p class=label>
<b>Figure 6. After using IMAGECFG, Windows NT will return "build 32, version 6.35 of Windows NT" to sample.exe when it calls GetVersion or GetVersionEx.</b></p>
<h3>Testing for Features, Not Version</h3>
<p>
Many problems with applications on Windows NT 4.0 can be avoided by testing for the existence of features required rather than a specific operating system or version. As Windows 95 and Windows NT mature, they will have more features in common. Some features may be added as service packs or in OEM service releases. The version number may remain the same, even though new features are present in the system.</p>
<p>
Testing for required features instead of just the version when installing or starting an application will give the user the greatest flexibility when upgrading the operating system. </p>
<h2>Hard-Coded Paths</h2>
<h3>Paths to Executable Files</h3>
<p>
The names and purposes of operating system executable files may change across versions or platforms. API function calls are available to start the executable files. Applications that avoid the API calls in favor of hard-coding the executable file name or path risk failing on different versions and platforms.</p>
<p>
For example, Winhelp.exe in the Windows 3<i>.x</i> operating system displayed version 1.0 Help files. It was installed by default in the %windir% directory. On Windows 95, the executable file with that same name is a stub that starts the appropriate Help engine, depending on the Help file version. Some developers use a hard-coded path to Winhelp.exe in 16-bit applications to open version 1.0 Help files. The same code works on Windows 95 from the 16-bit applications and from 32-bit versions of those applications, even though they use version 2.0 Help files. Using the hard-coded Winhelp.exe name gave the developers "portability" on Windows 95 for both 16-bit and 32-bit applications.</p>
<p>
On Windows NT 4.0, Winhelp.exe is the version 1.0 Help file engine, just as it is on Windows 3<i>.x</i>. On Windows NT, it provides compatibility with legacy 16-bit applications. If it's started with a version 2.0 Help file, it displays an error dialog box because the file is an unknown format. 32-bit applications with Winhelp.exe hard-coded fail to display version 2.0 Help files on Windows NT 4.0, even though they work as expected on Windows 95.</p>
<p>
The .hlp extension is associated with the proper Help engine on all operating systems. Creating a process using the .hlp file will start the correct Help engine on Windows 95 or Windows NT. By hard-coding the Help engine name instead, developers limit their applications to one version on one platform. If Windows 95 changes its Winhelp.exe implementation, the applications may no longer function on that platform either. Applications that don't rely on a hard-coded executable file name will survive the change.</p>
<h3>Hard-Coded Registry Keys</h3>
<p>
Instead of using API calls, some developers search the Windows 95 registry for information they need. When they find it, they hard-code the path to the key. For example, Windows 95 stores printer information in subkeys of HKEY_LOCAL_MACHINE:System\CurrentControlSet\Control\Print\Printers.</p>
<p>
Some applications look at that key and assume the absence of any subkeys means that there is no default printer. The applications usually failed to start if there was no default printer installed. Windows NT uses a different registry location to store printer information. When run on Windows NT, these applications will fail, even though a printer is installed. </p>
<p>
The API call <b>GetProfileString</b> returns the name of the default printer on all 32-bit operating systems. Using the API call will result in the proper application behavior. (See "Designing Your Installation Program" in <i>Windows Interface Guidelines for Software Design</i> in the MSDN Library.)</p>
<h2>Common Issues—Long File and Printer Names</h2>
<h3>Names May Be Long and Contain Previously Illegal Characters</h3>
<p>
Both Windows 95 and Windows NT support file paths and printer names up to MAX_PATH characters long. (See <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="msdn_longfile">
</object><a href=JavaScript:alink_1.Click()>"Making Room for Long Filenames."</a>) Although coding errors regarding long names are exposed by both operating systems, Windows NT is often used in business environments where such names are most common. Testing on Windows 95 may be inadvertently limited to short path and printer names or names that do not use some characters that were illegal on DOS but permitted in 32-bit operating systems. In all cases, the same bugs are exposed on both Windows 95 and Windows NT if the same path and printer names are used.</p>
<h3>Legacy Algorithms—Length</h3>
<p>
DOS file names require an "8.3" format. DOS path length is limited to 128 characters. Some legacy algorithms and library routines still assume the DOS limitations.</p>
<p>
Some applications correctly allow the path to be up to MAX_PATH characters, but they restrict the name of each folder and file to the 8.3 format. They parse for the backslash ("\") separator, then truncate folder names longer than 8 characters to the next dot (".") or backslash. An additional three characters may be accepted following a dot. Existing files with names longer than the 8.3 format allows cannot be found. When new files are created, they appear in new folders based on the truncated names of existing folders. </p>
<h3>Legacy Algorithms—Accepted Characters</h3>
<p>
Several characters that are illegal in DOS file, folder, and printer names are accepted under Windows 95 and Windows NT. In addition to the space (ANSI 0032), these characters are now legal in names:</p>
<p>
<b>+&nbsp;&nbsp; ,&nbsp;&nbsp; . ;&nbsp;&nbsp; =&nbsp;&nbsp; [&nbsp;&nbsp; ]</b></p>
<p>
Legacy algorithms may not allow one or more of these characters in names. If users create files, folders, or printers outside your application, they may not be able to access those resources from your application if your algorithms retain any of the DOS limitations. Some applications have no problems with names longer than 8.3, but will not accept spaces in the names of folders and files. </p>
<p>
Some applications use existing controls for file handling that, by design, do not allow all the legal characters. Microsoft Office 95, for example, uses an edit box in Save As dialog boxes. Edit boxes treat a semicolon (;) as a text separator. When the user tries to type a document path with a folder name containing a semicolon in the Save As dialog box, the edit box assumes the semicolon is a delimiter between two document names and displays an error dialog box.</p>
<p>
<img src="95vsnt_1.gif" border=0></p>
<p class=label>
<b>Figure 7. Office 95 Save As dialog boxes use the semicolon as a delimiter. An error dialog box appears if the user enters a folder name that contains a semicolon.</b></p>
<p>
Other applications, such as WordPad, that use the system common dialog boxes allow semicolons in folder and file names. </p>
<h3>Long Names to Use for Testing</h3>
<p>
Use the following guidelines to test your application for proper handling of long file and printer names (spaces are represented by the <i>#</i> character):
<ul type=disc>
<li>
Allow periods, plus signs, commas, semicolons, equal signs, and square brackets anywhere.<br><br></li>
<li>
Don't save leading or trailing spaces.<br><br></li>
<li>
Don't save question marks.<br><br></li>
<li>
Support MAX_PATH characters (including the drive, path, and extension). <br><br></li>
<li>
Save to a universal naming convention (UNC) path, such as \\Server\Directory\Filename.<br><br></li>
<li>
If your application uses a default extension, it should add it automatically. For example, "test." will save as "test..ext".<p class=tl>
<b>test<br>
....test....<br>
....####test####....<br>
....####te..st####....<br>
test....<br>
....test<br>
.test<br>
test.<br>
test#test#test#test<br>
C:\test#1234567890[on to MAX_PATH total length]<br>
\\folder#one\folder#two\folder#three\folder#four\file</b></P><p class=tl>
<b>test (saved as "test.ext")<br>
###test (saved as "test.ext")<br>
test### (saved as "test.ext")<br>
###..test..##(saved as "..test...ext")<br>
test#;#+#,#=#[#] (saved as "test#;#+#,#=#[#].ext")<br>
####....####test.test####....## (saved as "....####test.test####.....ext")</b></P></li>
</ul>
<h2>Common Issues – Dynamic-link Libraries</h2>
<h3>MFC DLLs</h3>
<p>
Neither Windows 95 nor Windows NT installs the MFC 30 (Microsoft Foundation Classes version 3.0) dynamic-link libraries (DLLs) on a minimum installation. Neither operating system requires the MFC 30 DLLs for its core functionality. Many applications used with Windows 95, such as WordPad, are MFC 30 applications, and they will install the MFC 30 DLLs. Since most Windows 95 users accept the default setup, which installs WordPad, they will find MFC 30 DLLs on their systems.</p>
<p>
Windows NT WordPad does not use MFC 30 DLLs, nor does any other application that ships as part of Windows NT. Unless the user installs Office 95 or other applications that also install the MFC 30 DLLs, your application will not find the DLLs on a Windows NT system.</p>
<p>
Some Windows 95 applications need the MFC 30 DLLs, but fail to install them. The applications were tested by their developers on Windows 95. Since most Windows 95 installations have, by coincidence, the MFC 30 DLLs, the applications installed and performed as expected. The applications either fail to install or do not work properly on Windows NT because the required DLLs are not available.</p>
<p>
Applications should verify the presence of all DLLs that they require and be prepared to install them if necessary. Applications should warn the user with a clear and specific dialog box if they find what appears to be an older version of a required DLL. The user should be given the option to replace the "older" DLL or leave it in place. Applications should refcount DLLs they use that already exist on the system. When an application is removed, it should decrement the refcount on DLLs it uses. MFC and system DLLs should not be removed, even if the refcount is zero. (See "To SUR, With Love: Important Stuff to Know About the Windows NT 4.0 Shell Update Release" at http://microsoft.com/win32dev/ui/ntsur.htm.) </p>
<h3>Replacing System DLLs</h3>
<p>
Some applications replace system DLLs, such as URL.dll, with newer versions. Applications that don't verify operating system platform and version correctly may install a new DLL for the wrong platform or version (see the preceding section "Interpreting the Operating System Version"). Many applications that replace URL.dll on Windows NT install a Windows 95–specific version. When that happens, any application that initializes URL.dll will display an error dialog box. The Windows NT Kernel32.dll does not contain the entry point <b>ReinitializeCriticalSection</b> that a Windows 95–specific URL.dll uses.</p>
<p>
Applications must warn the user with a clear and specific dialog box if they intend to replace any system DLL. Applications should provide platform specific DLLs if any calls are made from the DLL to other platform specific functions.</p>
<h2>Common Issues—Large Drives</h2>
<h3>Benign Errors During Installation</h3>
<p>
The Windows 95 Team tested many applications as part of FAT32 development. Some of those applications displayed incorrect drive size information during installation when drives had more than 2 gigabytes (GB) of free drive space. </p>
<p>
Similar tests were run on Windows NT, which also has the ability to support single drives with more than 2 GB of free drive space. Using an 8-GB drive, 25 percent of the tested applications, including Windows NT–specific applications, underreported the free drive space available. Most of these applications reported free drive space between 1 GB and 430 megabytes (MB). None of these bugs had been reported by Windows 95 users during earlier Microsoft testing, nor by Windows NT users. There are four likely reasons:
<ul type=disc>
<li>
All installations succeeded. Even if the application found only 430 MB free, none of the applications required more than 430 MB for installation.<br><br></li>
<li>
The free drive space information appeared only during installation when it could be easily overlooked or ignored by the user.<br><br></li>
<li>
Until recently, the price per MB of hard disks made large drives uncommon. Most users installed applications on drives with less than 2 GB of free space.<br><br></li>
<li>
Users with very large drives may have filled them with data or other applications, so less than 2 GB of free drive space remained when the underreporting applications were installed. </li>
</ul>
<p>
A few applications reported negative numbers for free drive space on drives over 2 GB. In all cases, the user could click an Ignore button, and then the installation proceeded normally.</p>
<h3>Application Errors That Affect the User</h3>
<p>
Some applications either require the correct value for free drive space for part of their functionality or display the value to the user. Most applications that perform disk operations such as tape backup use the correct free drive space values, even if they display a low value during installation. </p>
<p>
One command shell application reports a size of 1 MB for an 8-GB drive from its "dir" and "free" commands. Most users consider that a serious bug. Other applications display free drive space as incidental information, usually in a system resources dialog box from their Help menus. Underreporting free drive space in those dialog boxes is not considered as serious by users, since they do not often look at or rely on the information.</p>
<h3>API Changes to Accommodate Legacy Code</h3>
<p>
Because many existing applications failed on drives larger than 2 GB, a change has been made in the API function<b> GetDiskFreeSpace</b>. The function now returns a maximum value of 2 GB, even if the drive has more than 2 GB free. A new API function <b>GetDiskFreeSpaceEx</b> will return the true free drive space. Applications running on Windows 95 or Windows NT that need the true free drive space should call <b>GetDiskFreeSpaceEx</b>.</p>
<h2>Common Issues—Coding Practices</h2>
<h3>Large Fonts</h3>
<p>
Some applications use splash screens to let the user choose options. A bitmap with the options is displayed on a dialog box. Hidden controls under the bitmap receive mouse clicks from the user to make selections.</p>
<p>
<img src="95vsnt_2.gif" border=0></p>
<p class=label>
<b>Figure 8. In this simulated splash screen, the user can select User, Kernel, GDI or close the dialog box by clicking the word "Exit." The dialog box appears on a machine using the Large Fonts option. The bitmap image did not scale with the dialog box, and a gray background appears behind the bitmap on the resized dialog box.</b></p>
<p>
If the system is set to use large fonts on the Settings tab in Display Properties, dialog boxes will resize to accommodate the large fonts. (See "Font and Size" at http://microsoft.com/win32dev/uiguide/uigui401.htm.) Controls on the dialog boxes move along with the dialog box. The bitmap image does not resize. In this example, the control that should be under the word "Exit" is at the bottom of the resized dialog box. When the user clicks on the word "Exit," the "Kernel" option will probably appear since that control has moved lower on the dialog box, relative to the bitmap. With no Close button on the dialog box and the hidden "exit" control buried in the gray border, the user is challenged to close the dialog box.</p>
<p>
The problem can be avoided on Windows 95 and Windows NT by using a static window with SS_BITMAP and SS_CENTERIMAGE flags instead of using a dialog box window to hold the bitmap.</p>
<p>
In addition to splash screen bugs, clipping may occur in static controls and edit boxes. All applications should be tested with large fonts. </p>
<h3>Full Drag</h3>
<p>
A few applications will not resize or change to full-screen mode properly if the "Show contents while dragging" option has been checked on the Plus! tab in Display Properties. Windows NT 3<i>.x</i> called this option "Full drag." The problems are most common in 16-bit applications. Some 32-bit applications ported from 16-bit code also display these bugs.</p>
<h2>Differences Between WINDOWS 95 and Windows NT</h2>
<h3>Passing ANSI Characters to Windows NT</h3>
<p>
Windows NT is a Unicode operating system. All of its internal routines use Unicode for character handling. (See "Unicode Support in Win32" [MSDN Library, Backgrounders].)</p>
<p>
Code can be compiled specifically for the Unicode environment by defining Unicode to notify the preprocessor to expand generic function prototype macros, such as <b>SetWindowText</b>, to wide character versions. Code designed to run only in an ANSI environment, compiled with Unicode not defined, prototypes only the ANSI versions. Applications can also be written making mixed calls to both the ANSI and Unicode versions of text-oriented API calls; <b>SetWindowTextA</b> and <b>SetWindowTextW</b>, for example. The ANSI functions take ANSI text parameters (LPCSTR) and Unicode, or wide, functions take wide parameters (LPCWSTR). A few wide API functions have no ANSI equivalents and required Unicode parameters.</p>
<p>
Several applications designed for Windows 95 pass ANSI text when Windows NT expects Unicode. Autorun on the Windows 95 compact disc passes the names of files to Windows NT using ANSI strings. Windows NT evaluates them as Unicode and cannot find any of the files on the compact disc. Windows NT assumes the wrong compact disc is in the drive and repeatedly prompts the user to reinsert the Windows 95 compact disc.</p>
<p>
<img src="95vsnt_3.gif" border=0></p>
<p class=label>
<b>Figure 9. Applications can add Help verbs to the right-click menu in Windows Explorer with Help strings printed on the status bar.</b></p>
<p>
Windows NT expects Unicode characters for the Windows Explorer right-click menu Help strings. Many Windows 95–based applications pass only ANSI strings, which display as garbage instead of text. Applications have several options for creating readable Help strings on both platforms:
<ul type=disc>
<li>
Switch on Windows 95/Windows NT and use either the ANSI or wide function call as appropriate.<br><br></li>
<li>
Switch on the uFlags parameter of <b>IContextMenu::GetCommandString</b>. Pass ANSI on GCS_HELPTEXT and Unicode on GCS_HELPTEXTW.<br><br></li>
<li>
Pass a null string on the GCS_HELPTEXTW flag. Windows NT will attempt the call again with the GCS_HELPTEXT flag. The application can then pass an ANSI string and Windows NT will make the Unicode conversion.</li>
</ul>
<h3>Receiving Unicode Characters from Windows NT</h3>
<p>
Some API functions return Unicode strings on Windows NT. If an application processes only ANSI strings, it must use <b>WideCharToMultiByte</b> to make its own conversions.</p>
<p>
Some applications receiving Unicode strings use incorrect parameters when calling <b>WideCharToMultiByte</b>, so the conversion is unsuccessful. If the applications fail to trap the error code returned by Windows NT, they use whatever text (or garbage) was in the buffer before the call.</p>
<h3>Common and Personal Program Groups</h3>
<p>
Windows 95 supports only one type of program group on the Start menu. Windows NT 3<i>.x</i> used two types of groups: Common and Personal. Beta 1 of Windows NT 4.0 used the Windows 95 program groups model to be compatible with the Windows 95 shell. Many Windows NT Beta 1 users requested the dual model used in earlier Windows NT versions.</p>
<p>
Windows NT 4.0 now supports both Common and Personal groups on the Start menu. It implements logic that tries to "do the right thing" automatically when Windows 95–based applications are installed. You can ensure that the proper group is created by using the CSIDL_PROGRAMS or CSIDL_COMMON_PROGRAMS flags when calling <b>SHGetSpecialFolderLocation</b>.</p>
<p>
Only users with Administrator rights can create Common groups. If your program needs to create a Common group, you should inform your user to install the program as an Administrator. Ideally your application will verify the rights it has inherited from the user.</p>
<p>
Test your application's uninstall routine to be certain it locates any program groups that it created. Remove all of them, as well as the icons they contain.</p>
<h3>Rights and Privileges</h3>
<p>
Windows NT is a secure operating system. User rights and privileges maintain that security. As discussed in the preceding section, your application inherits the rights, permissions and limitations of the user running it. Your application may not have access to expected hardware, system, and file resources on some Windows NT–based systems. Some applications fail to install critical files or fail to write to the registry on Windows NT if the installing user is not an Administrator, but the applications give no warning to the user. The applications subsequently fail to start, or they crash during operation.</p>
<h3>Uninstall and SharedDLLs Registry Keys</h3>
<p>
Windows NT does not create Uninstall or SharedDLLs keys in the registry during installation. Applications should be prepared to create the keys during installation.</p>
<h3>Compressed NTFS</h3>
<p>
Windows NT supports the NT file system (NTFS). It supports compressed NTFS beginning with Windows NT version 3.51. Although NTFS compression should be transparent to applications, some programs will not create directories or files on compressed NTFS drives. Applications should be tested on NTFS and compressed NTFS as well as FAT drives. See also the preceding section "Common Issues – Large Drives."</p>
<h3>Multiple Processors</h3>
<p>
Windows NT can support multiple processor (MP) machines. MP machines should be transparent to applications, but some applications have difficulties running on MP machines. Test applications on machines with more than one processor. Look in particular for incorrect window repainting.</p>
<h3>RISC Platforms</h3>
<p>
Windows NT supports MIPS R4000, DEC™ Alpha AXP™ and IBM® PowerPC™ processors. Users with those machines may provide an additional lucrative market for your 32-bit applications. Programs run most effectively on RISC-based machines when compiled to native code.</p>
<p>
A technology preview, Microsoft Windows x86, is available for Windows NT 4.0 that allows users to run 32-bit Intel® code on RISC-based machines under software emulation. Windows x86 has been tested with many applications, and most work as expected. Some API functions are not implemented in the Windows x86 technology preview. You may want to test your 32-bit Intel application on one or more RISC-based machines on Windows x86. (See http://www.microsoft.com/ntworkstation/x86.htm for information on Windows x86.)</p>
<h3>Memory Leaks</h3>
<p>
Even small memory leaks in applications may eventually degrade Windows NT performance for several reasons:
<ul type=disc>
<li>
Windows NT is robust. Application problems can require rebooting a computer running Windows 3<i>.x</i> or Windows 95. On Windows NT, the process can be easily terminated without affecting the operating system or, in most cases, any other processes. Machines may run for months without rebooting Windows NT. If an application leaks memory or resources, and it's started several times a day, the leaks will accumulate over time to impact total system memory.<br><br></li>
<li>
Even small leaks can affect the ability of Windows NT to provide the large contiguous blocks of memory some applications require.<br><br></li>
<li>
Memory or handles allocated to resources such as files and folders may prevent users from legitimately changing or removing them. See the section "Memory Management," earlier in this article.</li>
</ul>
<p>
Applications should be tested for leaks on Windows 95 and Windows NT. Pmon.exe in the \support folder on the Windows NT compact disc may be helpful in finding application leaks. Several commercial products are available to analyze source code and running programs for leaks, unused resource assignments, and other problems.</p>
<h3>Autoexec.bat and Config.sys</h3>
<p>
New applications should use the registry instead of Autoexec.bat or Config.sys. Your new application may need to use those files to maintain compatibility with legacy 16-bit versions. </p>
<p>
Because a few 16-bit applications fail to install if either Autoexec.bat or Config.sys is missing, Windows NT creates zero-byte–length files with those names in the root directory of the boot drive. If your application reads or writes to either Autoexec.bat or Config.sys, you should test it with zero-byte–length files to verify correct performance.</p>
<h2>Summary</h2>
<p>
This white paper has presented common compatibility problems observed at Microsoft while testing applications developed for Windows 95 on Windows NT 4.0. In most cases, Windows 95 applications work as expected on Windows NT 4.0 because the operating systems share the same Shell interface and have similar API functionality. Where differences exist between the two operating systems, special care should be taken to ensure that applications correctly detect the operating system platform and version. Applications should test for the presence of features they require rather than a specific operating system version. Applications written to conform with Win32 API specifications have the best chance of working on new versions of both Windows 95 and Windows NT.</p>
</BODY>
</HTML>
