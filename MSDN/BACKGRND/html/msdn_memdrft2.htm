<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Microsoft Windows CE Memory Use</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_memdrft2"></a>Microsoft Windows CE Memory Use</h1>
<p>
John Murray</p>
<p>
September 1997</p>
<h2>Introduction</h2>
<p>
Microsoft® Windows® CE is a componentized operating system that can be customized for different target devices, or <i>platforms</i>. An original equipment manufacturer (OEM) or embedded system developer can select the system modules and components that will be provided in the operating system for the target platform. The selected modules and components determine its memory requirements.</p>
<p>
A <i>module</i> represents a complete functional area that is either present or not present in the system software. If the functionality is not needed, the entire module is omitted. For example, all serial port functionality is provided within a single module, named "serial," which is either included or not.</p>
<p>
Some large modules are further partitioned into <i>components</i>. This allows the OEM to custom-build smaller versions of these modules by including only the components needed by the OEM device. For example, the file system module includes components for a RAM file system, a ROM file system, the registry, and the database. The OEM can mix and match these file system components (with some constraints) to meet the needs of the target platform.</p>
<p>
To help the OEM and embedded system developer make design decisions, it is useful to be able to know the memory consumption of a given module or component. This article describes how the Windows CE 2.0 operating system uses memory and lists the memory requirements for the major system modules and components for selected Windows CE system configurations. It also describes how to use the Windows CE tools to find these memory requirements for other configurations.</p>
<p>
For Windows CE version 2.0, Microsoft has created and tested several base configurations of these modules and components. These configurations represent different sets of system capabilities, ranging from a base system with minimal user input and no display capabilities, to the full look and feel of Microsoft Windows in the Handheld PC (H/PC).</p>
<p>
Each configuration builds on previous configurations. The following table lists the tested configurations that are examined in this paper.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=48%><b>Configuration </b></td>
<td class=label width=52%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=48%>Minimal input system (MinInput)</td>
<td width=52%>Kernel, base file system, registry, and base user support. Base user input support includes: support for message queues, touch pad, keyboard input devices; audio, power, notification light-emitting diode (LED), and idle.</td>
</tr>
<tr valign=top>
<td width=48%>Minimal graphical display interface (MinGDI)</td>
<td width=52%>MinInput and minimal GDI (base drawing primitives, device contexts).</td>
</tr>
<tr valign=top>
<td width=48%>Minimum communications (MinComm)</td>
<td width=52%>MinInput and communications stacks (Transfer Control Protocol/Internet Protocol [TCP/IP], Point-to-Point Protocol [PPP], telephony application programming interface [TAPI], Serial, Network Device/Driver Interface Specification [NDIS], Infrared Data Association [IRDA]).</td>
</tr>
<tr valign=top>
<td width=48%>Windows user interface (UI) configuration (HPC2Apps)</td>
<td width=52%>MinComm and all window-related API functions (such as <b>CreateWindow</b>); this is the version that is used on the H/PC.</td>
</tr>
</table><br>
<h2>System Memory Use</h2>
<p>
A typical Windows CE device contains ROM and RAM memory. The device maintains the contents of RAM even when the device is turned off by refreshing with a backup battery.</p>
<p>
The system memory can be categorized as described in the following table.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=31%><b>Memory</b></td>
<td class=label width=69%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=31%>ROM</td>
<td width=69%>Contains Windows CE executables and other system files. The .text (code) and read-only data sections of these files are uncompressed for execute-in-place (XIP).</td>
</tr>
<tr valign=top>
<td width=31%>RAM—storage memory</td>
<td width=69%>Contains the file system (including the registry and the Windows CE database). Contains the read/write data sections. </td>
</tr>
<tr valign=top>
<td width=31%>RAM—program memory</td>
<td width=69%>Working RAM.</td>
</tr>
</table><br>
<p>
ROM contains the uncompressed files that execute in place (XIP), including the system executables, dynamic-link libraries (DLLs), and bundled applications such as Microsoft Pocket Word. These files start at the beginning of a page boundary. ROM also contains the miscellaneous files used by these applications, such as fonts, audio, and bitmaps. Most miscellaneous files are compressed (with the exception of a few fonts). Code and read-only sections for the executables and DLLs are uncompressed to enable execute-in-place. The read/write sections are compressed because they are destined for RAM, where they will be compressed.</p>
<p>
To save space, many of these small miscellaneous files and compressed read/write sections are placed into <i>holes</i> in memory. A <i>hole</i> is the space remaining on the last page after a code or read-only memory section is placed in ROM.</p>
<p>
It is also possible to compress an executable or DLL in ROM. When such an executable runs, the on-demand paging uncompresses the required pages and loads them into RAM.</p>
<p>
RAM is divided into two parts: storage memory and program memory. The storage memory contains the registry, file system, and database. The file system contains the application and data files installed or created by the user. All files in the file system are always compressed. The program memory is used by the system and running applications. The user can adjust the division of RAM into the storage and program memory at any time without rebooting.</p>
<p>
User-installed applications reside compressed in the file system. The code and data need to be uncompressed into the program memory for execution. On-demand paging is supported—when a user-installed application is started, only a small part of the application needs to be uncompressed into program memory.</p>
<p>
In addition to the .data section, each executable usually consumes some amount of program memory for its heap and stack data. The heap and stack usually grow and shrink dynamically.</p>
<h2>Memory Use for Windows CE Version 2.0 </h2>
<p>
The following tables show the memory usage on the Hitachi D9000 Development Platform with the SH3 microprocessor. The RAM and stack values are obtained after startup at the time the Memtool utility inspected the system state. These numbers are calculated as follows:
<ul type=disc>
<li>
<b>ROM (code and read-only data).</b> Sum of all sections listed in the Romimage utility output for that module.<br><br></li>
<li>
<b>RAM.</b> Read/write data listed in the page summary by the Memtool utility and the Ppsh utility memory information (mi) command.<br><br></li>
<li>
<b>Stack.</b> Value listed for stack in the page summary by the Memtool utility and the Ppsh utility mi command.</li>
</ul>
<p>
Although the Memtool and Ppsh utilities display read-only data in RAM for each process, this memory often represents shared memory that is allocated by the kernel. This shared memory physically consumes only one page that is used by the kernel. Accordingly, modules with a read-only page size of 1 are not counted toward that module's RAM requirements. Exceptions include the kernel and modules with read-only page sizes greater than 1. For these exceptions, the RAM requirement is calculated as the sum of the read-only and read/write sections.</p>
<h3>MinInput</h3>
<p>
The <i>MinInput</i> system represents a minimal input system. This includes the kernel, base file system, registry, and base user-input support. Base user-input support includes: support for message queues, touch pad, keyboard input devices; audio, power, notification LED, and idle.</p>
<p>
The following table contains valuesin kilobytes (K) for a retail MinInput configuration immediately after system startup.</p>
<table border=1 cellpadding=5 cols=4 frame=below rules=rows>
<tr valign=top>
<td class=label width=22%><b>Module</b></td>
<td class=label width=26%><b>ROM (in K)</b></td>
<td class=label width=26%><b>RAM (in K)</b></td>
<td class=label width=26%><b>Stack (in K)</b></td>
</tr>
<tr valign=top>
<td width=22%>Nk.exe</td>
<td width=26%>119</td>
<td width=26%>5</td>
<td width=26%>4</td>
</tr>
<tr valign=top>
<td width=22%>Filesys.exe</td>
<td width=26%>57</td>
<td width=26%>6</td>
<td width=26%>1</td>
</tr>
<tr valign=top>
<td width=22%>Gwes.exe</td>
<td width=26%>60</td>
<td width=26%>9</td>
<td width=26%>3</td>
</tr>
<tr valign=top>
<td width=22%>Coredll.dll</td>
<td width=26%>94</td>
<td width=26%></td>
<td width=26%></td>
</tr>
</table><br>
<p>
This configuration also includes the following DLLs in ROM.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=46%><b>Module</b></td>
<td class=label width=54%><b>ROM (in K)</b></td>
</tr>
<tr valign=top>
<td width=46%>Toolhelp.dll</td>
<td width=54%>2</td>
</tr>
<tr valign=top>
<td width=46%>Keybddr.dll</td>
<td width=54%>8</td>
</tr>
<tr valign=top>
<td width=46%>Touch.dll</td>
<td width=54%>12</td>
</tr>
</table><br>
<h3>MinGDI</h3>
<p>
The <i>MinGDI</i> system represents a minimal system with a GDI. The minimal GDI includes all of the components in the MinInput system, and adds base drawing primitives and device contexts.</p>
<p>
The following table contains values for a retail MinGDI configuration immediately after system startup.</p>
<table border=1 cellpadding=5 cols=4 frame=below rules=rows>
<tr valign=top>
<td class=label width=22%><b>Module</b></td>
<td class=label width=26%><b>ROM (in K)</b></td>
<td class=label width=26%><b>RAM (in K)</b></td>
<td class=label width=26%><b>Stack (in K)</b></td>
</tr>
<tr valign=top>
<td width=22%>Nk.exe</td>
<td width=26%>119</td>
<td width=26%>7</td>
<td width=26%>4</td>
</tr>
<tr valign=top>
<td width=22%>Filesys.exe</td>
<td width=26%>122</td>
<td width=26%>7</td>
<td width=26%>1</td>
</tr>
<tr valign=top>
<td width=22%>Gwes.exe</td>
<td width=26%>282</td>
<td width=26%>697</td>
<td width=26%>4</td>
</tr>
<tr valign=top>
<td width=22%>Coredll.dll</td>
<td width=26%>103</td>
<td width=26%></td>
<td width=26%></td>
</tr>
</table><br>
<p>
In addition to the DLLs listed under the MinInput configuration, this configuration also includes the following DLLs in ROM.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=37%><b>Module</b></td>
<td class=label width=63%><b>ROM (in K)</b></td>
</tr>
<tr valign=top>
<td width=37%>Ddi.dll</td>
<td width=63%>29</td>
</tr>
<tr valign=top>
<td width=37%>Wavedev.dll</td>
<td width=63%>15</td>
</tr>
</table><br>
<h3>MinComm</h3>
<p>
The MinComm configuration represents a system with minimal communications capabilities. The MinComm system includes all of the components in the MinInput system, and adds the communications stacks (TCP/IP, PPP, TAPI, Serial, NDIS, and IRDA).</p>
<p>
The following table contains values for a retail MinComm configuration immediately after system startup.</p>
<table border=1 cellpadding=5 cols=4 frame=below rules=rows>
<tr valign=top>
<td class=label width=22%><b>Module</b></td>
<td class=label width=25%><b>ROM (in K)</b></td>
<td class=label width=24%><b>RAM (in K)</b></td>
<td class=label width=29%><b>Stack (in K)</b></td>
</tr>
<tr valign=top>
<td width=22%>nk.exe</td>
<td width=25%>119</td>
<td width=24%>31</td>
<td width=29%>4</td>
</tr>
<tr valign=top>
<td width=22%>filesys.exe</td>
<td width=25%>86</td>
<td width=24%>9</td>
<td width=29%>1</td>
</tr>
<tr valign=top>
<td width=22%>gwes.exe</td>
<td width=25%>45</td>
<td width=24%>12</td>
<td width=29%>1</td>
</tr>
<tr valign=top>
<td width=22%>device.exe</td>
<td width=25%>15</td>
<td width=24%>67</td>
<td width=29%>8</td>
</tr>
<tr valign=top>
<td width=22%>coredll.dll</td>
<td width=25%>128</td>
<td width=24%></td>
<td width=29%></td>
</tr>
</table><br>
<p>
In addition to the DLLs listed for the MinInput configuration, this configuration also includes the following DLLs in ROM.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=48%><b>Module</b></td>
<td class=label width=52%><b>ROM (in K)</b></td>
</tr>
<tr valign=top>
<td width=48%>ppp.dll</td>
<td width=52%>64</td>
</tr>
<tr valign=top>
<td width=48%>cxport.dll</td>
<td width=52%>6</td>
</tr>
<tr valign=top>
<td width=48%>ircomm.dll</td>
<td width=52%>7</td>
</tr>
<tr valign=top>
<td width=48%>winsock.dll</td>
<td width=52%>18</td>
</tr>
<tr valign=top>
<td width=48%>secur32.dll</td>
<td width=52%>19</td>
</tr>
<tr valign=top>
<td width=48%>schannel.dll</td>
<td width=52%>111</td>
</tr>
<tr valign=top>
<td width=48%>ntlmssp.dll</td>
<td width=52%>14</td>
</tr>
<tr valign=top>
<td width=48%>afd.dll</td>
<td width=52%>39</td>
</tr>
<tr valign=top>
<td width=48%>arp.dll</td>
<td width=52%>19</td>
</tr>
<tr valign=top>
<td width=48%>ndis.dll</td>
<td width=52%>42</td>
</tr>
<tr valign=top>
<td width=48%>ne2000.dll</td>
<td width=52%>21</td>
</tr>
<tr valign=top>
<td width=48%>tcpstk.dll</td>
<td width=52%>98</td>
</tr>
<tr valign=top>
<td width=48%>irdastk.dll</td>
<td width=52%>55</td>
</tr>
<tr valign=top>
<td width=48%>tapi.dll</td>
<td width=52%>17</td>
</tr>
<tr valign=top>
<td width=48%>unimodem.dll</td>
<td width=52%>21</td>
</tr>
<tr valign=top>
<td width=48%>redir.dll</td>
<td width=52%>74</td>
</tr>
<tr valign=top>
<td width=48%>netbios.dll</td>
<td width=52%>25</td>
</tr>
<tr valign=top>
<td width=48%>wininet.dll</td>
<td width=52%>105</td>
</tr>
<tr valign=top>
<td width=48%>pcmcia.dll</td>
<td width=52%>29</td>
</tr>
<tr valign=top>
<td width=48%>serial.dll</td>
<td width=52%>26</td>
</tr>
</table><br>
<h3>HPC2Apps</h3>
<p>
The HPC2Apps configuration represents the complete system that appears on the Handheld PC. The HPC2Apps configuration includes all of the components in the MinComm system, and adds all window-related API functions (such as <b>CreateWindow</b>).</p>
<table border=1 cellpadding=5 cols=4 frame=below rules=rows>
<tr valign=top>
<td class=label width=22%><b>Module</b></td>
<td class=label width=26%><b>ROM (in K)</b></td>
<td class=label width=26%><b>RAM (in K)</b></td>
<td class=label width=26%><b>Stack (in K)</b></td>
</tr>
<tr valign=top>
<td width=22%>nk.exe</td>
<td width=26%>119 K</td>
<td width=26%>46</td>
<td width=26%>4</td>
</tr>
<tr valign=top>
<td width=22%>filesys.exe</td>
<td width=26%>122 K</td>
<td width=26%>9</td>
<td width=26%>4</td>
</tr>
<tr valign=top>
<td width=22%>gwes.exe</td>
<td width=26%>508 K</td>
<td width=26%>724</td>
<td width=26%>7</td>
</tr>
<tr valign=top>
<td width=22%>device.exe</td>
<td width=26%>15 K</td>
<td width=26%>78</td>
<td width=26%>10</td>
</tr>
<tr valign=top>
<td width=22%>coredll.dll</td>
<td width=26%>122</td>
<td width=26%></td>
<td width=26%></td>
</tr>
</table><br>
<p>
In addition to the DLLs listed for the MinComm configuration, this configuration also includes the following DLLs in ROM.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=47%><b>Module</b></td>
<td class=label width=53%><b>ROM (in K)</b></td>
</tr>
<tr valign=top>
<td width=47%>fatfs.dll</td>
<td width=53%>54</td>
</tr>
<tr valign=top>
<td width=47%>prnport.dll</td>
<td width=53%>5</td>
</tr>
<tr valign=top>
<td width=47%>pcl.dll</td>
<td width=53%>24</td>
</tr>
<tr valign=top>
<td width=47%>atadisk.dll</td>
<td width=53%>9</td>
</tr>
<tr valign=top>
<td width=47%>sramdisk.dll</td>
<td width=53%>7</td>
</tr>
<tr valign=top>
<td width=47%>waveapi.dll</td>
<td width=53%>68</td>
</tr>
<tr valign=top>
<td width=47%>ole32.dll</td>
<td width=53%>150</td>
</tr>
<tr valign=top>
<td width=47%>oleaut32.dll</td>
<td width=53%>183</td>
</tr>
<tr valign=top>
<td width=47%>dhcp.dll</td>
<td width=53%>13</td>
</tr>
<tr valign=top>
<td width=47%>hwxusa.dll</td>
<td width=53%>86</td>
</tr>
<tr valign=top>
<td width=47%>netui.dll</td>
<td width=53%>19</td>
</tr>
</table><br>
<h2>Viewing ROM Use</h2>
<p>
It is possible to see exactly how the files are placed in ROM by inspecting the output of the Microsoft Windows CE ROM Image Builder utility, Romimage.exe. (The numbers in this paper are obtained from the Image Builder utility log files.)</p>
<p>
Files are divided into sections and placed into ROM. The sections are characterized as follows by the Windows CE development tools.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=20%><b>Section </b></td>
<td class=label width=80%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=20%>.text</td>
<td width=80%>Code</td>
</tr>
<tr valign=top>
<td width=20%>.rsrc</td>
<td width=80%>Resource data</td>
</tr>
<tr valign=top>
<td width=20%>.data</td>
<td width=80%>Data</td>
</tr>
<tr valign=top>
<td width=20%>.pdata</td>
<td width=80%>Debugging and exception processing information for each function in the code section</td>
</tr>
<tr valign=top>
<td width=20%>.CRT</td>
<td width=80%>Special section—C++ construct</td>
</tr>
<tr valign=top>
<td width=20%>.KDATA</td>
<td width=80%>Special section—only present in the kernel (Nk.exe)</td>
</tr>
</table><br>
<p>
Romimage is a command-line utility. The first few lines of output from a typical Romimage session list the program banner, the page size, and the beginning of the MODULES section:</p>
<pre><code>Windows CE ROM Image Builder&nbsp; v1.0&nbsp; Copyright Microsoft 1995.
Copying d:\WINCE\release\odo2bpp.dll to d:\WINCE\release\ddi.dll for debugger.
Copying d:\WINCE\release\odo2bpp.pdb to d:\WINCE\release\ddi.pdb for debugger.
Setting PageSize to 1024
DumpSymbols: pTOC found at 00000e50
MODULES Section
Module&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Section&nbsp; Start&nbsp;&nbsp;&nbsp;&nbsp; Length&nbsp; psize&nbsp;&nbsp; vsize&nbsp;&nbsp; Filler
------------ -------- --------- ------- ------- ------- ------
nk.exe&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .text&nbsp;&nbsp;&nbsp; 8c600400h&nbsp; 116736&nbsp; 116736&nbsp; 116268
nk.exe&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .pdata&nbsp;&nbsp; 8c61cc00h&nbsp;&nbsp;&nbsp; 4096&nbsp;&nbsp;&nbsp; 4096&nbsp;&nbsp;&nbsp; 3864
coredll.dll&nbsp; .text&nbsp;&nbsp;&nbsp; 8c61dc00h&nbsp; 119808&nbsp; 119296&nbsp; 118987
coredll.dll&nbsp; .rsrc&nbsp;&nbsp;&nbsp; 8c63b000h&nbsp;&nbsp;&nbsp; 1024&nbsp;&nbsp;&nbsp; 1024&nbsp;&nbsp;&nbsp;&nbsp; 528
...
</code></pre>
<p>
The first entry in the MODULES section, Nk.exe, has a size of 116268 = 0x1c62c bytes. This actual size is rounded up to the next 1024-byte page boundary, 116736 = 0x1c800, and placed in ROM. This leaves a hole of 468 bytes available for miscellaneous files. Similarly, a hole of 496 bytes is available at address 0x8c63b210, at the end of the last page that contains the Coredll.dll .rsrc section.</p>
<p>
After placing all the .text (code) sections, Romimage begins placing data sections that are smaller than a page into these holes. For example, the same Romimage log contains the following information, later in the MODULES section:</p>
<pre><code>Module&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Section&nbsp; Start&nbsp;&nbsp;&nbsp;&nbsp; Length&nbsp; psize&nbsp;&nbsp; vsize&nbsp;&nbsp; Filler
------------ -------- --------- ------- ------- ------- ------
...
coredll.dll&nbsp; .data&nbsp;&nbsp;&nbsp; 8c61ca2ch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp; 200 FILLER
coredll.dll&nbsp; .pdata&nbsp;&nbsp; 8cb32800h&nbsp;&nbsp;&nbsp; 4868&nbsp;&nbsp;&nbsp; 4866&nbsp;&nbsp;&nbsp; 8064
filesys.exe&nbsp; .data&nbsp;&nbsp;&nbsp; 8cb33b04h&nbsp;&nbsp; 12236&nbsp;&nbsp; 12234&nbsp;&nbsp; 21376
filesys.exe&nbsp; .pdata&nbsp;&nbsp; 8cb36ad0h&nbsp;&nbsp;&nbsp; 2152&nbsp;&nbsp;&nbsp; 2149&nbsp;&nbsp;&nbsp; 2640
gwes.exe&nbsp;&nbsp;&nbsp;&nbsp; .data&nbsp;&nbsp;&nbsp; 8cb37338h&nbsp;&nbsp; 10796&nbsp;&nbsp; 10794&nbsp;&nbsp; 17828
gwes.exe&nbsp;&nbsp;&nbsp;&nbsp; .pdata&nbsp;&nbsp; 8cb39d64h&nbsp;&nbsp; 12456&nbsp;&nbsp; 12456&nbsp;&nbsp; 15768
device.exe&nbsp;&nbsp; .data&nbsp;&nbsp;&nbsp; 8c61ca30h&nbsp;&nbsp;&nbsp;&nbsp; 213&nbsp;&nbsp;&nbsp;&nbsp; 213&nbsp;&nbsp;&nbsp;&nbsp; 276 FILLER
device.exe&nbsp;&nbsp; .pdata&nbsp;&nbsp; 8c63b210h&nbsp;&nbsp;&nbsp;&nbsp; 341&nbsp;&nbsp;&nbsp;&nbsp; 341&nbsp;&nbsp;&nbsp;&nbsp; 424 FILLER
fatfs.dll&nbsp;&nbsp;&nbsp; .data&nbsp;&nbsp;&nbsp; 8c659c84h&nbsp;&nbsp;&nbsp;&nbsp; 366&nbsp;&nbsp;&nbsp;&nbsp; 366&nbsp;&nbsp;&nbsp;&nbsp; 504 FILLER
fatfs.dll&nbsp;&nbsp;&nbsp; .pdata&nbsp;&nbsp; 8cb3ce0ch&nbsp;&nbsp;&nbsp; 1324&nbsp;&nbsp;&nbsp; 1322&nbsp;&nbsp;&nbsp; 1624
shell.exe&nbsp;&nbsp;&nbsp; .data&nbsp;&nbsp;&nbsp; 8cb3d338h&nbsp;&nbsp;&nbsp; 1608&nbsp;&nbsp;&nbsp; 1605&nbsp;&nbsp;&nbsp; 2864
shell.exe&nbsp;&nbsp;&nbsp; .pdata&nbsp;&nbsp; 8c61cb05h&nbsp;&nbsp;&nbsp;&nbsp; 183&nbsp;&nbsp;&nbsp;&nbsp; 183&nbsp;&nbsp;&nbsp;&nbsp; 208 FILLER
...
</code></pre>
<p>
The first .data section for Coredll.dll is 4 bytes, and is placed at the first available hole, 0x8c600400 + 0x1c62c = 0x8c61ca2c. It consumes four bytes, moving the next filler address to 0x8c61ca30 and shrinking the hole to 464 bytes.</p>
<p>
The next .data section smaller than a page is for Device.exe and requires 213 = 0xd5 bytes, which is also small enough to fit within the remaining space in this first hole. It is placed there, the address changes to 0x8c61cb05, and the hole shrinks to 251 bytes.</p>
<pre><code>device.exe&nbsp;&nbsp; .data&nbsp;&nbsp;&nbsp; 8c61ca30h&nbsp;&nbsp;&nbsp;&nbsp; 213&nbsp;&nbsp;&nbsp;&nbsp; 213&nbsp;&nbsp;&nbsp;&nbsp; 276 FILLER
</code></pre>
<p>
The .pdata section for Device.exe, 341 bytes, is larger than the remaining space in this hole, so it is placed into another—the hole following the last page of the Coredll.dll resource section, starting at 0x8c63b210.</p>
<pre><code>device.exe&nbsp;&nbsp; .pdata&nbsp;&nbsp; 8c63b210h&nbsp;&nbsp;&nbsp;&nbsp; 341&nbsp;&nbsp;&nbsp;&nbsp; 341&nbsp;&nbsp;&nbsp;&nbsp; 424 FILLER
</code></pre>
<p>
The next .data or .pdata section smaller than the remaining size of 251 bytes in the first hole is the .data section for the debug shell, Shell.exe, at 183 bytes. It is placed in the first hole, at that next available address, 0x8c61cb05.</p>
<pre><code>shell.exe&nbsp;&nbsp;&nbsp; .pdata&nbsp;&nbsp; 8c61cb05h&nbsp;&nbsp;&nbsp;&nbsp; 183&nbsp;&nbsp;&nbsp;&nbsp; 183&nbsp;&nbsp;&nbsp;&nbsp; 208 FILLER
</code></pre>
<p>
The Romimage tool continues in this fashion until all the sections have been placed. Any remaining holes are listed as part of the report:</p>
<pre><code>Unfilled ROM Holes (Address,Length):
8c9cfbf8h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 8caef3f8h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 8cb253f8h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 8cb2bff8h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8
8c769bf9h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7 8c8d4ffah&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6 8c8f37fah&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6 8c98dffah&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6
8cb16ffah&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6 8cb1d7fah&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6 8cb327fah&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6 8c61dbfbh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5
8c6e6ffbh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5 8c763ffbh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5 8c855ffbh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5 8c935bfbh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5
8c9877fbh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5 8c7537fch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 8c765bfch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 8c7bcffch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4
8c7d3bfch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 8c80dbfch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 8c82f3fch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 8c8f27fch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4
8c938ffch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 8c9c17fch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 8c9e23fch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 8ca6e7fch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4
8cacfbfch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 8cb20bfch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 8c61cbfdh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3 8c659ffdh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3
8c6e13fdh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3 8c6e23fdh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3 8c6e87fdh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3 8c6ee7fdh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3
8c63b3feh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 8c74fffeh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 8c785ffeh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 8c7b8ffeh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2
8c7c23feh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 8c9717feh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 8c99d7feh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 8cb09ffeh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2
8cb227feh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 8c63afffh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 8c65a3ffh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 8c6ea7ffh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1
8c788fffh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 8c793fffh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 8c9727ffh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 8c9a8bffh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1
8ca83bffh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 8cacf7ffh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 8cb047ffh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 8cb0bfffh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1
</code></pre>
<p>
The ability to identify the FILLER sections is significant because the size and number of executables and DLLs can change between different configurations. This in turn affects the size of the available holes, and can affect the total amount of memory required.</p>
<p>
To determine ROM use by each module, calculate the sum of all sections listed in the Romimage utility output for that module—except for those sections that are listed as filler. Because the filler is inserted into the available holes, it does not increase the memory requirement for that module.</p>
<h2>Viewing Virtual Memory</h2>
<p>
It is possible to examine every page of virtual memory with the Memtool utility. Memtool provides a complete memory map for the 32 megabyte (MB) slot available to each process. The memory map notes whether the code and data is in ROM or RAM.</p>
<p>
Memtool also displays a summary of the current stack usage. The stack size changes dynamically, growing and shrinking as needed. The stack numbers shown may not indicate a maximum requirement. They describe the state of the stack at the time it was examined by the Memtool utility.</p>
<p>
For example, the first few lines of the memory map for the Filesys.exe process demonstrate a variety of different uses. Each symbol represents a page of memory and indicates how that page is used:</p>
<pre><code>Memory usage for Process 8c056d2c: 'filesys.exe' pid 1
Slot base 04000000&nbsp; Section ptr 8cfe4c00
 &nbsp;&nbsp; 04000000(1): ----------------------r-----------------------------------------
 &nbsp;&nbsp; 04010000(0): -CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 &nbsp;&nbsp; 04020000(0): CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 &nbsp;&nbsp; 04030000(0): CCCCCCCCCCWWWWWWWWWWWWWWWWWWWWW---R
 &nbsp;&nbsp; 04040000(0): -------------------------------------------------SSS----SSSS
 &nbsp;&nbsp; 04050000(0): PPPPOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO</code></pre>
<p>
The hyphen character (-) indicates that the page is reserved; lowercase <i>r</i> indicates data in RAM; capital <i>C</i> indicates code in ROM; <i>W</i> indicates read/write data in RAM; <i>R</i> indicates data in ROM; <i>S</i> indicates stack; <i>P</i> indicates peripheral memory (not allocated through the kernel but mapped by Gwes or device drivers); and <i>O</i> indicates object store. In addition to these symbols, lowercase <i>c</i> indicates code executing from RAM.</p>
<p>
After the memory map, the Memtool utility displays summary information. Similar information is also available from the Ppsh utility MI command , which appears as follows:</p>
<pre><code>Memory usage for Process 8c036d2c: 'filesys.exe' pid 1
Slot base 04000000&nbsp; Section ptr 8c5e7000
Page summary: code=207(0) data r/o=2 r/w=7 stack=1 reserved=13963
</code></pre>
<p>
In the page summary, the value associated with <i>code</i> indicates the number of pages in ROM. The number in parentheses indicates the number of pages in RAM. The data pages indicate read-only and read/write, respectively. The value associated with <i>stack</i> indicates the number of pages in use by the stack.</p>
<p>
To obtain the memory requirement information for other microprocessors and other platforms, examine the output from the ROM Image Builder and the Ppsh or Memtool utilities. Complete documentation for these utilities is available in the Microsoft Windows CE Embedded Toolkit for Visual C++® 5.0.</p>
<h2>For More Information</h2>
<p>
For the Microsoft Windows CE Embedded Toolkit for Visual C++ 5.0, see the Microsoft Windows CE Web site (<a href="http://www.microsoft.com/windowsce/developer/prodinfo/vcceembed.htm">http://www.microsoft.com/windowsce/developer/prodinfo/vcceembed.htm</a>). The toolkit will also be available to Universal Subscribers of the MSDN Library.</p>
<p>
Also, be sure to take a look at the following articles, all available in the MSDN Library:</p>
<p>
<a href="msdn_embeddev.htm">"Embedded Development with Microsoft Windows CE 2.0,"</a> by Franklin Fite Jr. and Randy Kath.</p>
<p>
<a href="msdn_vcceembo.htm">"Introducing the Windows CE Embedded Toolkit for Visual C++ 5.0,"</a> by David Pellerin.</p>
<p>
<a href="msdn_mgdiview.htm">"Microsoft Windows CE Display Drivers and Hardware,"</a> by Jason Black and Jon Christiansen.</p>
<p>
<a href="msdn_mgdidft1.htm">"Microsoft Windows CE Graphics Features,"</a> by Jon Christiansen.</p>
<p>
<a href="msdn_comm_mod.htm">"The Microsoft Windows CE Communications Model,"</a> by Guy Smith.</p>
<p>
<a href="msdn_rtdraft6.htm">"Real-Time Systems with Microsoft Windows CE,"</a> by John Murray.</p>
<p>
<a href="msdn_w32model.htm">"The Win32 Programming Model: A Primer for Embedded Software Developers,"</a> by David Pellerin.</p>
<p>
<i>The information contained in this document represents the current view of Microsoft Corporation on the issues discussed as of the date of publication. Because Microsoft must respond to changing market conditions, it should not be interpreted to be a commitment on the part of Microsoft, and Microsoft cannot guarantee the accuracy of any information presented after the date of publication. This document is for informational purposes only. </i></p>
<p>
<i>MICROSOFT MAKES NO WARRANTIES, EXPRESS OR IMPLIED, IN THIS SUMMARY.</i></p>
</BODY>
</HTML>
