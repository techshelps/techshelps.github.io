<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Agility in Server Components</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_agility"></a>Agility in Server Components</h1>
<p>
Neil Allain<br>
MicroCrafts</p>
<p>
October 10, 1997</p>
<h2>Introduction</h2>
<p>
Using the Active Template Library (ATL), it's easy to make an Active Server Pages (ASP) component that supports both free-threaded and apartment-threaded threading models. However, you may not be gaining the performance benefits you had hoped for. To understand why, let's take a quick look at threading models and how components support them. It is also helpful to review the threading model summary provided at the end of this article, although developers should note this summary applies only to version<b> </b>4.0 of Internet Information Server (IIS).</p>
<h2>Understanding the Threading Model</h2>
<p>
If any thread wants to use Component Object Model (COM) objects, it must first call some form of <b>CoInitialize</b> (<b>OleInitialize</b> or <b>CoInitializeEx</b>). Once called, you have bound the thread to use a certain threading model, either single-threaded apartment or multi-threaded apartment. (The single-threaded apartment model is generally called the apartment model, while the multithreaded apartment model is generally called the multithreaded or free-threaded model.)</p>
<p>
Every application has one and <b>only</b> one multithreaded apartment (which may have zero or more threads associated with it), and has one single-threaded apartment for every thread that was initialized as single-threaded. Objects marked as apartment-threaded belong in the single-threaded apartment thread in which they were created. Objects marked as free-threaded always belong to the multithreaded apartment, regardless of the thread in which they were created. So a free-threaded object created in a single-threaded apartment would actually belong to a different apartment (the multithreaded apartment), and an apartment-threaded object created in a multithreaded apartment would belong to its own single-threaded apartment (possibly creating a new thread for that apartment). An object that is marked as supporting both threading models, however, always belongs to the apartment in which it was created. This means it is an apartment-threaded object when created in a single-threaded apartment, and it is a free-threaded object when created in a multithreaded apartment. It is not both, however, and still belongs to one and only one apartment.</p>
<p>
Why does it matter what apartment an object belongs to? Any calls to an object from an apartment other than the one it belongs to must go through a proxy rather than use the object directly. This is considerably slower than using the object directly, not to mention the fact that all your hard work in making your object thread-safe would count for nothing if your object gets created in a single-threaded apartment. There is a solution to this problem, and ATL makes it very easy.</p>
<h2>Making Your Server Component Agile</h2>
<p>
The solution is to aggregate a free-threaded marshaler. When an interface pointer is being marshaled between two apartments, a free-threaded marshaler will supply a direct pointer to the object rather than a proxy. This enables you to take full advantage of multithreading, regardless of the apartment in which an object was created. An object that aggregates a free-threaded marshaler is called <i>agile</i>. If you are using the ATL Wizard to create an object, simply select the <b>Free Threaded Marshaler </b>check box and the <b>Yes</b> radio button under <b>Aggregation</b> to make the object agile: </p>
<p>
<img src="agility1.gif" border=0></p>
<p class=label>
<b>Figure 1. ATL Object Wizard Properties</b></p>
<p>
If you want to make an existing object agile, it requires only a little more work. In the class declaration, add the following few lines (the new lines are in italicized boldface type):</p>
<pre><code>class ATL_NO_VTABLE CMyObject : 
…
{
public:
…
<b><i>DECLARE_GET_CONTROLLING_UNKNOWN()</i></b>

BEGIN_COM_MAP(CMyObject)
…
<b><i> COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)</i></b>
…
END_COM_MAP()

<i> <b>HRESULT FinalConstruct()</b></i>
<b><i> {</i></b>
<b><i> return CoCreateFreeThreadedMarshaler(</i></b>
<b><i>  GetControllingUnknown(), &amp;m_pUnkMarshaler.p );</i></b>
<b><i> }</i></b>
 <b>void FinalRelease()</b>
<b> {</b>
<b> m_pUnkMarshaler.Release();</b>
<b> }</b>
<b>…</b>
<b><i> CComPtr&lt;IUnknown&gt;   m_pUnkMarshaler;</i></b>
…
};
</code></pre>
<p>
These are exactly the lines the ATL Wizard adds for you when you are creating a new object.</p>
<p>
Now that your object is agile, it's doing what you originally expected it to do when you marked it as supporting<b> both </b>threading models, and it can be accessed directly from any thread of execution. Writing agile server components will boost your Web application's performance.</p>
<h2>IIS 4.0 Threading Model Summary</h2>
<p>
Andrew Sigal<br>
Software Design Engineer<br>
Microsoft Corporation</p>
<p>
This model applies to Internet Information Server version 4.0 <b>only</b>.</p>
<table border=1 cellpadding=5 cols=5 frame=below rules=rows>
<tr valign=top>
<td class=label width=20%></td>
<td class=label width=20%><b>Both</b><p class=label>
<b>(+Free-Threaded Marshaler)</b></p>
</td>
<td class=label width=20%><b>Single</b></td>
<td class=label width=20%><b>Free</b></td>
<td class=label width=20%><b>Apartment</b></td>
</tr>
<tr valign=top>
<td width=20%><b>Application</b><p>
<b>&lt;OBJECT&gt;</b></p>
<p>
<b>tag objects</b></p>
</td>
<td width=20%>Access is direct.<p>
Object runs in current user security context.</p>
<p>
Accesses are not serialized.</p>
</td>
<td width=20%>Access through proxy via GIP.<p>
Object runs in SYSTEM context.</p>
<p>
Accesses are serialized. </p>
<p>
Cannot access ObjectContext.</p>
</td>
<td width=20%>Access through proxy via GIP. <p>
Object runs in SYSTEM context. </p>
<p>
Accesses are not serialized.</p>
<p>
Cannot access ObjectContext.</p>
</td>
<td width=20%>Access through proxy via GIP.<p>
Object runs in SYSTEM context.</p>
<p>
Accesses are serialized.</p>
</td>
</tr>
<tr valign=top>
<td width=20%><b>Application</b><p>
<b>Properties</b></p>
<p>
<b>(i.e., Application ("obj") = )</b></p>
</td>
<td width=20%>Access is direct.<p>
Object runs in current user security context.</p>
<p>
Accesses are not serialized.</p>
</td>
<td width=20%>Access through proxy via GIP. <p>
Object runs in SYSTEM context. </p>
<p>
Accesses are serialized. </p>
<p>
Cannot access ObjectContext.</p>
</td>
<td width=20%>Access through proxy. <p>
Object runs in SYSTEM context. </p>
<p>
Accesses are serialized. </p>
<p>
Cannot access ObjectContext. </p>
<p>
Session is locked down.</p>
</td>
<td width=20%>Access is direct.<p>
Object runs in current user security context. </p>
<p>
Accesses are serialized.</p>
<p>
Session is locked down.</p>
</td>
</tr>
<tr valign=top>
<td width=20%><b>Session Objects</b></td>
<td width=20%>Access is direct.<p>
Object runs in current user security context.</p>
<p>
Accesses are not serialized.</p>
</td>
<td width=20%>Access through proxy.<p>
Object runs in SYSTEM context.</p>
<p>
Accesses are serialized. </p>
<p>
Cannot access ObjectContext.</p>
<p>
Session is locked down.</p>
</td>
<td width=20%>Access through proxy. <p>
Object runs in SYSTEM context. </p>
<p>
Accesses are serialized. </p>
<p>
Cannot access ObjectContext.</p>
<p>
Session is locked down.</p>
</td>
<td width=20%>Access is direct.<p>
Object runs in current user security context.</p>
<p>
Accesses are serialized.</p>
<p>
Session is locked down.</p>
</td>
</tr>
<tr valign=top>
<td width=20%><b>Page Objects</b></td>
<td width=20%>Access is direct.<p>
Object runs in current user security context.</p>
<p>
Accesses are not serialized.</p>
</td>
<td width=20%>Access through proxy.<p>
Object runs in system context.</p>
<p>
Accesses are serialized.</p>
<p>
Cannot access ObjectContext.</p>
</td>
<td width=20%>Access through proxy.<p>
Object runs in system context.</p>
<p>
Accesses are serialized. </p>
<p>
Cannot access ObjectContext.</p>
</td>
<td width=20%>Access is direct.<p>
Object runs in current user security context.</p>
<p>
Accesses are serialized.</p>
</td>
</tr>
</table><br>
<p>
<i>Author Neil Allain is a developer on the IIS team, working on component development.</i></p>
<p>
<i>Andrew Sigal is a lead developer on the IIS team.</i></p>
</BODY>
</HTML>
