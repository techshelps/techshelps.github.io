<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Distributing Microsoft Excel 97, Word 97, and PowerPoint 97 Solutions</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_addins97"></a>Distributing Microsoft Excel 97, Word 97, and PowerPoint 97 Solutions</h1>
<p>
Microsoft Corporation</p>
<p>
March 3, 1997</p>
<h2>Introduction</h2>
<p>
This article describes how to get a Microsoft® Excel 97, Word 97, or PowerPoint® 97 Visual Basic® for Applications solution ready for distribution and how to package the solution for distribution using the Setup Wizard. Most of the article discusses the issues involved in preparing a solution for distribution—deciding how you want your solution to load, avoiding problematic references, and protecting your code.</p>
<h2>Getting Your Solution Ready to Distribute</h2>
<p>
Once you’ve created a solution, you face a series of decisions and tasks as you prepare the solution for distribution. Probably the first decision is simply how to package the project. Should it be distributed as a document, or, more commonly, as an add-in (or global template in Word)?</p>
<p>
If you decide to distribute the solution as an add-in, it’s important to pay attention to how and when the add-in will load. For example, should it load automatically at startup or only on demand?</p>
<p>
Finally, chances are you’ll want to protect your code and, of course, perform a final check to get rid of those last-minute bugs that always seem to appear just when you’re ready to cut your disk.</p>
<h3>Decide How You Want to Package Your Solution</h3>
<p>
When you write a solution using Visual Basic for Applications code, you write it in a project associated with a document (the term “document” is used generically in this paper to refer to an Microsoft Excel workbook, a PowerPoint presentation, or a Word document). When it’s time to distribute the solution, you need to decide whether the user must have access to both the document and the code in the associated project or just to the code.</p>
<p>
If you want to make both the document and the project available to the user, you simply distribute it as a document—again, this means as an Microsoft Excel workbook, a PowerPoint presentation, or a Word document. This is often the case when you write a vertical solution—that is, a very specific solution for a very specific user. For example, if you create an automated performance review form in Word, you want both the review document and the code that automates it to be available to the user.</p>
<p>
If, on the other hand, you want to make only the project available to the user, you distribute it as an add-in (Microsoft Excel and PowerPoint) or a global template (Word).</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Users can’t get to the worksheets in an add-in, because when a workbook is made into an add-in, its worksheets are automatically hidden. Similarly, when a presentation is made into an add-in, its slides are automatically removed. For more information on what happens when a workbook or presentation is converted to an add-in, see the section “Save Your Solution as an Add-in or Global Template” later in this article.</p>
<p>
You may decide not to give the user access to the document associated with a project, either because the document isn’t of use to the user or because there’s data in the document you don’t want the user to be able to see or change. This is often the case when your solution contains procedures that extend and customize the standard feature set of an application—that is, procedures that are designed to have a broad application and to be independent of any specific document; the user only needs access to the code in the project, not to the associated document. For example, if you write procedures that automate common spreadsheet formatting tasks, the user will need access to them from any workbook, but won’t need access to the specific workbook associated with the project where the code is stored.</p>
<p class=indent>
<B><b>Important</b></B>&nbsp;&nbsp;&nbsp;Whether you distribute a solution as an add-in or template instead of as a document is a separate issue from whether you protect your code. See the section “Protect or Unprotect Your Code” later in this article for more information.</p>
<h3>Control When an Add-in or Global Template Is Loaded</h3>
<p>
If you decide to distribute your solution as an add-in or global template, you’ll probably want to control how it is loaded. The user can always load the add-in using the <b>Templates and Add-Ins</b> or <b>Add-Ins </b>dialog box from the <b>Tools</b> menu, but that’s usually not the best solution. You can set an add-in or global template to load automatically at startup. Or, to avoid slowing down an application’s startup, you can set an add-in or global template to load in response to a particular event or to the user choosing a command. You can also load an add-in or global template programmatically.</p>
<h4>Loading an add-In or global template at startup</h4>
<p>
The features of an add-in become available to the user when the add-in is loaded. For example, when a global template is loaded, Word merges the template’s menus, toolbars, AutoText entries, and macros into the Word environment. Because of this, you may want to load the add-in or global template when the user launches Word, Microsoft Excel, or PowerPoint.</p>
<p>
To load add-ins or templates automatically when you start an application, you can place them in the Office Startup folder. The default Startup folder is located in Program Files\Microsoft Office\Office\Startup.</p>
<p>
In Microsoft Excel, you can also place an add-in in the Xlstart folder or in the folder you designate as the alternate startup folder. To set the alternate startup folder, assign a path and folder name to the HKEY_CURRENT_USER\Software\Microsoft\Office\8.0\Excel\Microsoft Excel\AltStartup key in the Windows® registry.</p>
<h4>Automatically loading a Microsoft Excel add-in using the OPEN command in the Windows registry</h4>
<p>
In addition to storing the add-in in one of the startup folders described above, you can use the OPEN command in the Windows Registry to specify add-in files you want to load automatically when you start Microsoft Excel.</p>
<p>
You must create one OPEN command in the registry key HKEY_CURRENT_USER\Software\Microsoft\Office\8.0\Excel\Microsoft Excel for each file you want to open at startup. If you want to open more than one file, append incremented numbers to consecutive OPEN commands. For example, use OPEN for the first file you want to open at startup, OPEN1 for the second, OPEN2 for the third, and so on.</p>
<p>
The syntax for the OPEN command is as follows:</p>
<pre><code>"OPEN =[/Switch] pathandfilename"
</code></pre>
<p>
The available switches are /R and /F. The /R switch opens the file read-only. The /F switch is used for demand loading workbooks. Microsoft Excel only reads enough information from the add-in workbook file to reference the custom functions. The following is an example of an OPEN command:</p>
<pre><code>HKEY_CURRENT_USER\Software\Microsoft\Office\8.0\Excel\Microsoft Excel\OPEN =/R "C:\OFFICE\OFFICE\LIBRARY\ANALYSIS\ANALYS32.XLL"
</code></pre>
<p>
The OPEN command is provided for backward compatibility and is required for demand loading of function macros. Refer to the Init Commands and Init Menus settings information later in this paper for the new method.</p>
<h4>Automatically loading a PowerPoint add-in using the AutoLoad value in the Windows registry</h4>
<p>
Just as with Microsoft Excel, you can set values in the Windows registry to load add-ins automatically when you start Microsoft PowerPoint. You use different settings to do so, however.</p>
<p>
If an add-in is to be loaded automatically when PowerPoint is launched, the name of an add-in file should be a subkey under either HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE in the Windows Registry. The Path value for the key should be the location of the add-in. Set the AutoLoad value to 1 to load the add-in automatically at startup.</p>
<h4>Loading add-ins that were loaded in the previous session</h4>
<p>
A Microsoft Excel or PowerPoint add-in that is loaded and registered during the current session of Microsoft Excel or PowerPoint will be automatically loaded the next time the application starts up.</p>
<p>
When you load a global template in Word, it remains loaded for the current session, but is not automatically reloaded when you restart Word.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;When you add add-ins to the list in the <b>Add-Ins</b> dialog box (using the <b>Add New</b> button) in Microsoft Excel or PowerPoint, they are registered under HKEY_CURRENT_USER. Hence, registered add-ins will only be available to the user that was logged onto the machine at the time when the add-in was added to the list.</p>
<h4>Loading an add-in or global template programmatically</h4>
<p>
You can programmatically install an add-in or global template using the Addins collection.</p>
<p>
In Word or Microsoft Excel, set the <b>Installed</b> property of the Addin object to <b>True</b> to load the add-in or global template. The following example loads a global template named "Gallery.dot."</p>
<pre><code>Addins("C:\Microsoft Office\Templates\Gallery.dot").Installed = True
</code></pre>
<p>
In PowerPoint, set the <b>Loaded</b> property of the <b>Addin</b> object to <b>True</b> to load the add-in, and set the <b>Registered</b> property to <b>True</b> to register it. The following example loads and registers MyTools.ppa.</p>
<pre><code>With Addins("C:\my documents\mytools.ppa")
 &nbsp;&nbsp; .Loaded = True
 &nbsp;&nbsp; .Registered = True
End With
</code></pre>
<h4>Loading an add-in programmatically in response to an event</h4>
<p>
If you want your add-in to load in response to a particular event, you can place the code that loads the add-in in an event procedure. For more information on events, see the Word or Microsoft Excel Visual Basic for Applications Help files.</p>
<h4>Opening and programmatically loading a Word global template using a command line</h4>
<p>
Use the following sample command line, where <i>path</i> is the location of the file Add-in.dot, to install an add-in called Add-in.dot and run a Sub procedure called <b>Main</b> in the module named Add-inInstall:</p>
<pre><code>WinWord "&lt;Path&gt;\Add-in.dot" /mAdd-inInstall
</code></pre>
<p>
Word has a number of command line switches. The /m switch runs the code in the specified module. Note that there is no space after the "m". Note also that you don’t specify the <b>Main</b> procedure; only a procedure named <b>Main</b> will run. If there is no procedure named <b>Main</b>, no code will run when the module is loaded. Here is an example <b>Main</b> procedure:</p>
<pre><code>'Name the module Add-inInstall.
Option Explicit
Sub Main()
'Check to see if Add-In is loaded in Add-In list.

 &nbsp;&nbsp; Dim wkbAddin As Word.AddIn

 &nbsp;&nbsp; On Error GoTo Errorhandler
 &nbsp;&nbsp; Set wkbAddin = AddIns(ThisDocument.Name)
 &nbsp;&nbsp; If wkbAddin Is Nothing Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Add the template to the add-ins collection and install it.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set wkbAddin = AddIns.Add(ThisDocument.FullName, True)
 &nbsp;&nbsp; End If

 &nbsp;&nbsp; ' If template is the active document close it.
 &nbsp;&nbsp; If ThisDocument.Name = ActiveDocument.Name Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' The Add-in should not be dirty.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ThisDocument.Close
 &nbsp;&nbsp; End If

 &nbsp;&nbsp; Exit Sub
Errorhandler:

 &nbsp;&nbsp; ' Only ignore "Subscript out of range" errors.
 &nbsp;&nbsp; Select Case Err.Number
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case 9, 5941
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Err.Clear
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Resume Next
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case Else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Assert the error when in Debug mode.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #If DebugMode Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AssertError
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #End If
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Insert other error handling code here.
 &nbsp;&nbsp; End Select
End Sub
</code></pre>
<h4>Unloading an add-in or template programmatically</h4>
<p>
An add-in remains loaded until the end of the current session or until you unload it using Visual Basic for Applications code or using the <b>Add-Ins</b> or <b>Templates and Add-ins</b> dialog box from the <b>Tools</b> menu. Unloading an add-in conserves memory.</p>
<p>
In Word or Microsoft Excel, set the <b>Installed</b> property of the Addin object to <b>False</b> to unload the add-in or global template. The following example unloads the global template named "Gallery.dot."</p>
<pre><code>Addins("C:\Microsoft Office\Templates\Gallery.dot").Installed = False
</code></pre>
<p>
In PowerPoint, set the <b>Loaded</b> property of the Addin object to <b>False</b> to unload the add-in, and set the <b>Registered</b> property to <b>False</b> to deregister it. The following example unloads MyTools.ppa.</p>
<pre><code>Addins("C:\my documents\mytools.ppa").Loaded = False
</code></pre>
<h4>Demand loading</h4>
<p>
Loading an add-in or template into memory at startup can significantly slow the time it takes Microsoft Excel, Word, or PowerPoint to load if the add-in is large. You can use demand loading to defer loading the add-in until the user invokes a command or a procedure in the add-in.</p>
<p>
Wizards and utility add-ins that are initiated by a menu command are demand loaded automatically.</p>
<p>
There are several other techniques for setting up demand loading that are specific to particular applications.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;If you intend to use an add-in or template as a code library whose procedures will be called from other projects, you generally don’t need to load it explicitly. Visual Basic will load the referenced add-in or template on demand, when a procedure is called that resides in the template.</p>
<p>
<b>Using explicit references in Microsoft Excel</b></p>
<p>
The first method of demand loading is to use an explicit reference when assigning a macro name to the toolbar. The following line calls the subroutine MySub that resides in the ThisWorkbook module from the workbook (add-in) “C:\My Documents\MyTools.xla”:</p>
<pre><code>‘C:\My Documents\MyTools.xla’!ThisWorkbook.MySub.
</code></pre>
<p>
The add-in is loaded only when the macro is executed.</p>
<p>
For solutions that are distributed using an installation program, see the section “Adding Menus and Submenus to Microsoft Excel without Loading an Add-In” later in this article for more details.</p>
<p>
<b>Demand loading function libraries in Microsoft Excel</b></p>
<p>
If you are distributing a solution that contains a library of function<b> </b>macros, you may want to demand load these functions. You would also normally want the functions to be listed in the Functions Wizard. To demand load worksheet functions requires XLM macros. Typically, these macros are wrappers for Visual Basic functions.</p>
<p>
When Microsoft Excel sees that an add-in is marked for demand load, it reads just the function macro headers from the file. The reason these function macros must be XLM is that Microsoft Excel can read the information without having to load Visual Basic for Applications. Visual Basic for Applications is not loaded until it is required.</p>
<p>
To modify an add-in to take advantage of demand loading
<ol>
<li>
Add a Microsoft Excel 4.0 macro sheet to the add-in workbook. Right click on a Worksheet tab and select <b>Insert</b>. In the <b>Insert</b> dialog box select <b>MS Excel 4.0 Macro</b>.<br><br></li>
<li>
Create a Microsoft Excel 4.0 function macro that wraps the Visual Basic for Applications function.<br><br></li>
<li>
In the first cell enter the name of the Function.<p class=tl>
a. In the cell below the function name, insert the Argument(Name_Text, Data_Type_ID) worksheet function.</P><p class=tl>
b. Name_Text is the name of the parameter. Ideally, this should match the name of the Visual Basic for Applications function’s parameter it is supposed to represent.</P><p class=tl>
c. Data_Type_ID is the ID that determines what type of data Microsoft Excel accepts for the argument. This parameter is optional.</P><p class=tl>
d. Repeat steps b, c and d for each parameter in the Visual Basic for Applications function.</P><p class=tl>
e. If it is necessary to specify the result type of the function use the Result(Data_Type_ID) worksheet function.</P><p class=tl>
f. The Return(value) worksheet function signals the end of the function macro.</P><p class=tl>
g. Select all of the cells that contain the macro.</P><p class=tl>
h. On the <b>Insert</b> menu, point to <b>Name</b>, and then click <b>Define</b></P><p class=tl>
i. Name the range the name of the function.</P><p class=tl>
j. Select the <b>Function</b> radio button in the Macro group.</P><p class=tl>
k. Click <b>Add</b> then click <b>OK</b>.</P></li>
<li>
Select <b>Insert</b> from the menu bar. Then select <b>Define</b> from the <b>Name</b> submenu. Add the name “__DemandLoad” that refers to “=TRUE” (just type it in the <b>Refers To</b> text box). Note there are 2 underscores in front of DemandLoad. Click <b>Add</b>, then click <b>Close</b> to dismiss the dialog.<br><br></li>
<li>
Set the <b>IsAddIn</b> property of the Workbook object to TRUE.<br><br></li>
<li>
Save the workbook.</li>
</ol>
<p>
Here is an example of a Microsoft Excel 4 function macro that wraps a Visual Basic for Applications function:</p>
<pre><code>MyFunction
=ARGUMENT(“szArgOne”)
=ARGUMENT(“intArgTwo”)
=RETURN(vMYFunction(szArgOne, intArgTwo))
</code></pre>
<p>
Here’s how the function itself would be set up:</p>
<pre><code>Function vMYFunction(szArgOne as String, intArgTwo as Integer) As String
…
End Function
</code></pre>
<p>
These steps make it possible for your add-in to be loaded on demand. Once the add-in is loaded, it is not removed from memory until the current instance of Microsoft Excel is terminated.</p>
<h4>Adding menus and submenus to Microsoft Excel without loading an add-in</h4>
<p>
Microsoft Excel 97 has added two new registry keys, which are read at startup, and which create menu items that provide entry points into an add-in without having to load the add-in until a pertinent menu command is issued. These new keys are the Init Menus and the Init Commands registry keys. The Delete Commands key, which you can use to remove menu items, is also documented in this section.</p>
<p>
<b>The Init Menus key</b></p>
<p>
The key HKEY_CURRENT_USER\Software\Microsoft\Office\8.0\Excel\Init Menus<i> </i>contains one string value for each menu that is added to a built-in menu bar. Each value name is a unique tag that identifies the menu item that is created. The string has the following syntax:</p>
<pre><code>Value_name = Menu_bar_num,Menu_name,Menu_position,[Menu_parent]
</code></pre>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=25%><b>Argument</b></td>
<td class=label width=75%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=25%>menu_bar_num</td>
<td width=75%>Number of the built-in menu bar to which you want to add the menu. The menu bars change, depending on the type of sheet that is active in the workbook. The menu bar numbers are as follows:<br>
3&nbsp; Nil menu bar (no open workbooks)<br>
10 Worksheet, dialog sheet, version 4.0 macro sheet<br>
11 Chart sheet<br>
12 Visual Basic module</td>
</tr>
<tr valign=top>
<td width=25%>menu_name</td>
<td width=75%>Name of the new menu.</td>
</tr>
<tr valign=top>
<td width=25%>menu_position</td>
<td width=75%>Position of the new menu on the menu bar. This may be the name of the menu after which you want to place the new menu, or a number indicating the menu’s position from the left end of the menu bar.</td>
</tr>
<tr valign=top>
<td width=25%>menu_parent</td>
<td width=75%>&lt;Optional&gt; If defining a submenu, this is the menu name or number on the menu bar that will contain this new submenu.</td>
</tr>
</table><br>
<p>
<b>The Init Commands key</b></p>
<p>
The HKEY_CURRENT_USER\Software\Microsoft\Office\8.0\Excel\Init Commands<i> </i>contains one string value for each command that’s added to a menu. Each value name is a unique tag that identifies command that is added. The string has the following syntax:</p>
<pre><code>Value_name = Menu_bar_num,Menu_name,Command_name,Macro,
Command_position,[Macro_key],[Status_text],[Help_reference]
</code></pre>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=24%><b>Argument</b></td>
<td class=label width=76%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=24%>menu_bar_num</td>
<td width=76%>Number of the built-in menu bar to which you want to add the menu. The menu bars change, depending on the type of sheet that is active in the workbook. The menu bar numbers are as follows:<br>
10 Worksheet, dialog sheet, version 4.0 macro sheet<br>
11 Chart sheet<br>
12 Visual Basic module</td>
</tr>
<tr valign=top>
<td width=24%>menu_name</td>
<td width=76%>The name of the menu or submenu. Submenus are indicated by a “menu\submenu” string. The backslash delimits the menu name from the submenu name. The submenu must already exist or be declared in the Init Menu registry key.</td>
</tr>
<tr valign=top>
<td width=24%>command_name</td>
<td width=76%>Name of the new command.</td>
</tr>
<tr valign=top>
<td width=24%>macro</td>
<td width=76%>Reference to a procedure in an add-in workbook. Choosing the command opens the add-in and runs this procedure. The procedure should delete the command added by this registry key and then replace it with a command that runs a procedure that performs the command actions.</td>
</tr>
<tr valign=top>
<td width=24%>command_position</td>
<td width=76%>Position of the command on the menu. This may be the name of the command after which you want to place the new command, or a number indicating the command’s position on the menu. If omitted, the command appears at the end of the menu.</td>
</tr>
<tr valign=top>
<td width=24%>macro_key</td>
<td width=76%>&lt;Optional&gt; Key assigned to the procedure, if any.</td>
</tr>
<tr valign=top>
<td width=24%>status_text</td>
<td width=76%>&lt;Optional&gt; Message to be displayed in the status bar when the command is selected.</td>
</tr>
<tr valign=top>
<td width=24%>help_reference</td>
<td width=76%>&lt;Optional&gt; Filename and topic number for a custom Help topic for the command.</td>
</tr>
</table><br>
<p>
<b>Delete Commands key</b></p>
<p>
You can use the Delete Commands key to delete commands from built-in menus. The Add-In Manager (click <b>Add-Ins</b> on the <b>Tools</b> menu) reads and writes values in the Delete Commands key. The key contains one string value for each command that is deleted from a menu. Each value name is a unique tag that identifies the deleted command. The string has the following syntax:</p>
<pre><code>Value_name = Menu_bar_num,Menu_name,Command_position
</code></pre>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=21%><b>Argument</b></td>
<td class=label width=79%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=21%>menu_bar_num</td>
<td width=79%>Number of the built-in menu bar to which you want to add the menu. The menu bars change, depending on the type of sheet that is active in the workbook. The menu bar numbers are as follows:<br>
3&nbsp; Nil menu bar (no open workbooks)<br>
10 Worksheet, dialog sheet, version 4.0 macro sheet<br>
11 Chart sheet<br>
12 Visual Basic module </td>
</tr>
<tr valign=top>
<td width=21%>menu_name</td>
<td width=79%>Name of the new menu.</td>
</tr>
<tr valign=top>
<td width=21%>menu_position</td>
<td width=79%>Position of the command on the menu. This may be the name of the command or a number indicating the command’s position on the menu.</td>
</tr>
</table><br>
<p class=indent>
<B><b>Caution!</b></B>&nbsp;&nbsp;&nbsp;Don't delete the <b>Exit </b>command from the <b>File </b>menu unless you’ve created another way to quit Microsoft Excel!</p>
<h4>Demand loading in PowerPoint</h4>
<p>
To demand load a PowerPoint add-in, you have to create a DLL to add PowerPoint menu items and toolbars when PowerPoint is loaded; there is no other way to demand load an add-in in PowerPoint.</p>
<p>
To add a DLL, you create a key with the name of the DLL add-in under the \Office\8.0\PowerPoint\DLL Addins\ key in the Windows Registry. Under the DLL add-in key, you have to add three named values: AutoLoad, InitFunction, and Path.
<ul type=disc>
<li>
<b>AutoLoad.</b> &lt;DWORD&gt; A value of 0 or 1; a value of 1indicates that the DLL is automatically loaded when PowerPoint 97 is launched.<br><br></li>
<li>
<b>InitFunction.</b> &lt;STRING&gt; The name of the function in the DLL that PowerPoint 97 should call when once the DLL is loaded. This DLL function would create any required menu items or toolbars.<br><br></li>
<li>
<b>Path.</b> &lt;STRING&gt; Full path and file name to the file location of the DLL.</li>
</ul>
<p>
The DLL add-in would add the necessary menu items and toolbars and set the <b>OnAction</b> property of the menu toolbar item to the name of a fully qualified macro name in a Visual Basic for Applications add-in file (*.ppa, *.pwz).</p>
<h4>Demand loading in Word</h4>
<p>
To implement a demand loaded scheme, you need to use late bound code. In this situation, you’re also responsible for opening and closing templates (see “Calling Routines Using Late Bound References” ).</p>
<h3>Write Code to Execute When the Add-in or Global Template Loads or Unloads</h3>
<p>
You may want to write code that will execute when you load or unload an add-in. For example, when the add-in loads you may want to run a procedure that displays a toolbar whose buttons give the user easy access to procedures in the add-ins. Or you may want a procedure that removes the toolbar when the add-in is unloaded. Word, Microsoft Excel, and PowerPoint each give you a way to do this.</p>
<h4>Microsoft Excel AddinInstall and AddinunInstall events</h4>
<p>
Microsoft Excel 97 has added the AddinInstall and AddinUninstall events, which are fired in an add-in when the user loads or unloads it. The events are fired whether the user loads or unloads the add-in using the <b>Add-ins</b> dialog box from the <b>Tools</b> menu or programmatically using the <b>Installed</b> property of the AddIn object. The <b>AddinInstall</b> and <b>AddinUninstall</b> events are the ideal place to add entries to the <b>Init</b> Menus and <b>Init</b> Commands registry keys.</p>
<p>
You can use the Open event procedure of a workbook to handle registering the workbook and adding it to the <b>Add-in</b> dialog. In the following example, the <b>AddinInstall</b> and <b>AddinUninstall</b> event procedures contain trivial code instead of code to modify the Microsoft Excel environment, which they would normally contain.</p>
<pre><code>Option Explicit

Private Sub Workbook_AddinInstall()
 &nbsp;&nbsp; ' Add code to customize the Microsoft Excel UI here.
 &nbsp;&nbsp; MsgBox "Addin Installed"
End Sub

Private Sub Workbook_AddinUninstall()
 &nbsp;&nbsp; ' Add code to remove customizations of the Microsoft Excel UI here.
 &nbsp;&nbsp; MsgBox "Addin Uninstalled"
End Sub

Private Sub Workbook_Open()
 &nbsp;&nbsp; '''Check to see if add-in is loaded in Microsoft Excel's AddIn list.
 &nbsp;&nbsp; Dim wkbAddIn As Excel.AddIn

 &nbsp;&nbsp; On Error GoTo Errorhandler
 &nbsp;&nbsp; Set wkbAddIn = AddIns(ThisWorkbook.Name)
 &nbsp;&nbsp; If wkbAddIn Is Nothing Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Setting the CopyFile argument to true will cause the add-in
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' to be copied to the local harddisk if it is on a removeable
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' medium.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set wkbAddIn = AddIns.Add(ThisWorkbook.FullName, True)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' The next line will cause the Workbook.AddInInstalled event
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' to fire.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wkbAddIn.Installed = True
 &nbsp;&nbsp; End If

 &nbsp;&nbsp; ' Initialize add-in here.

 &nbsp;&nbsp; Exit Sub
Errorhandler:

 &nbsp;&nbsp; ' Only ignore "Subscript out of range" errors.
 &nbsp;&nbsp; If Err.Number = 9 Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Err.Clear
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Resume Next
 &nbsp;&nbsp; Else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Assert the error when in Debug mode.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #If DebugMode Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AssertError
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #End If
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Insert other error handling code here.
 &nbsp;&nbsp; End If
End Sub
</code></pre>
<h4>PowerPoint Auto_Open and Auto_Close procedures</h4>
<p>
Instead of supporting events, as in Microsoft Excel, a PowerPoint add-in supports the <b>Auto_Open</b> Sub procedure, which runs when it is loaded, and the <b>Auto_Close</b> Sub procedure, which runs when it is unloaded.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The <b>Auto_Open</b> and <b>Auto_Close</b> procedures are only executed if they reside in a PowerPoint add-in file. If they reside within a presentation file (*.ppt), they are not executed when the presentation is loaded.</p>
<h4>Word AutoExec and AutoExit procedures</h4>
<p>
When you create a template in Word, you can create procedures named <b>AutoExec</b> and <b>AutoExit</b>, which run when the template is loaded or unloaded. For example, you can use <b>AutoExec</b> and <b>AutoExit</b> procedures to display or hide toolbars when a user loads or unloads the template.</p>
<p>
You can also create <b>AutoExec</b> and <b>AutoExit</b> modules which each contain a Sub procedure named Main. The procedure called Main in the <b>AutoExec</b> module will run when the project is loaded, and the procedure called Main in the <b>AutoExit </b>module will run when the project is unloaded</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;If the file is opened as a document, the <b>AutoExec</b> macro or module does not execute. Instead, the <b>AutoOpen</b> procedure and/or <b>Document_Open</b> event procedure execute. For more information on Word document events, see “Using Events with the Document Object” in the Help file.</p>
<p>
The following example initiates the monitoring of application events so that you can subsequently use the events of the Application object. The first two routines should be placed a class module named CAppEvents, and the last should be placed in a standard module named <b>AutoExec</b>. The <b>Main</b> Sub procedure in the <b>AutoExec</b> module, which is automatically called when the template that contains these modules is loaded into memory, instantiates the CAppEvents class defined in the class module. The <b>Class_Initialize</b> event sets the <i>App </i>variable to the Application object. Visual Basic will then run the <b>DocumentChange</b> event procedure whenever the active document changes.</p>
<pre><code>' Class module named CAppEvents
Public WithEvents App As Word.Application

Private Sub Class_Initialize()
 &nbsp;&nbsp; ' Make the class self-initializing by connecting the object declared
 &nbsp;&nbsp; ' in the class module with the Application object.
 &nbsp;&nbsp; Set App = Application
End Sub

Private Sub App_DocumentChange()
 &nbsp;&nbsp; ' Display a message box with the active document name.
 &nbsp;&nbsp; If Documents.Count &gt; 0 Then MsgBox ActiveDocument.Name
End Sub


' In a standard module named AutoExec
Global AppEvent As CAppEvents

Public Sub Main()
 &nbsp;&nbsp; ' Instantiate and initialize the CAppEvents class. This is all
 &nbsp;&nbsp; ' that is needed to have the above class work.
 &nbsp;&nbsp; Set AppEvent = New CAppEvents
End Sub
</code></pre>
<p>
In Word, you may want to include code to manipulate an add-in in the document event procedures <b>Open</b>, <b>Close</b>, and <b>New</b>, which run when the global template is opened or closed as a document or when a new document is created based on it. You may also want to use the application event procedures <b>Startup</b>, <b>Quit</b>, and <b>DocumentChange</b>. Be aware that before you can use application events, you must create a new class module, declare an object of type Application using the <b>WithEvents</b> keyword, and instantiate the class. For more information on Word application and document events, look up “events” on the <b>Index</b> tab of Word Visual Basic for Applications online help.</p>
<p class=indent>
<B><b>Important</b></B>&nbsp;&nbsp;&nbsp;If <b>AutoClose</b>, <b>AutoNew</b> or <b>AutoOpen</b> macros and corresponding event procedures exist in the same document, both the macros and the event procedures will execute.</p>
<h3>Check Your Code for Common “Gotchas”</h3>
<p>
Before you package your solution as an add-in or global template, check your code for potential trouble spots.</p>
<h4>Check references to the active workbook or document</h4>
<p>
Remember that if the code in your add-in or global template code contains an explicit or implicit reference to the active workbook or document, it will to refer to whatever workbook or document happens to be active when the code in your add-in runs. If you want to make sure your code refers to the add-in or global template itself, use <b>ThisWorkbook</b> or <b>ThisDocument</b>.</p>
<p>
For example, both of the following code samples call the worksheet named “Addin Definition” in whatever workbook happens to be active when the code runs. The first contains an explicit reference to the active workbook, using the property <b>ActiveWorkbook</b>. The second makes an implicit reference: because it doesn’t explicitly refer to a specific workbook, the reference is assumed to be to the active workbook:</p>
<pre><code>Sub ExplicitReference()
 &nbsp;&nbsp; Set rMnuTable = ActiveWorkbook.Worksheets("Addin Definition")._
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Range("MenuDefinition")
 &nbsp;&nbsp; Add_Menu rMnuTable
End Sub

Sub ImplicitCode()
 &nbsp;&nbsp; Set rMnuTable = Worksheets("Addin Definition")._
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Range("MenuDefinition")
 &nbsp;&nbsp; Add_Menu rMnuTable
End Sub
</code></pre>
<p>
The following code uses the <b>ThisWorkbook</b> property to refer to the workbook in which the code is running—that is, the add-in workbook.</p>
<pre><code>Sub CorrectCode()
 &nbsp;&nbsp; Set rMnuTable = ThisWorkbook.Worksheets("Addin Definition") _
.Range("MenuDefinition")
 &nbsp;&nbsp; Add_Menu rMnuTable
End Sub
</code></pre>
<h4>Calling routines in other projects</h4>
<p>
If you want to call functions, subroutines, and classes that are in one project from another project, the calling project must have a reference to the called project. For example, if A.XLA is calling procedures in B.XLA, then you need a reference in A.XLA to B.XLA.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;You cannot create references to PowerPoint presentations—you can only create references to PowerPoint add-ins. If you want to make the code in a presentation available to other presentations, save the presentation as an add-in, and create a reference to the add-in file.</p>
<p>
Before you can create a reference to one project from another, you must make sure they have different names. You can view and change the default name of a project either in the <b>Properties</b> window or in the <b>Project Name</b> box of the <b>Project Properties</b> dialog box (right click on the project name in the Visual Basic environment, and click on the project's properties).</p>
<p>
After you have given the projects distinct names, you can set a reference manually using the <b>References</b> dialog box from the <b>Tools</b> menu or programmatically, using the <b>AddFromFile</b> method of the <b>References</b> collection. The following line sets a reference from the active workbook to the project in the add-in MyTools.xla:</p>
<pre><code>ActiveWorkbook.VBProject.References.AddFromFile “C:\Tools\MyTools.xla”
</code></pre>
<p>
Note that before you can write code to set a reference in Microsoft Excel, Word, and PowerPoint, you must first set a reference to the Visual Basic for Applications Extensibility type library. This type library provides objects that you can use to work with a Visual Basic for Applications project programmatically.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The <b>Auto_Open</b> routine within a referenced add-in is not executed when it is loaded by reference from another add-in file or presentation.</p>
<h4>Avoiding unresolved references</h4>
<p>
When you save and distribute an add-in or template, the references that have been set for its project travel with it. However, if the add-ins or templates that are referenced aren’t in the same location on the user’s machine as they were on the solution developer’s machine, the calling add-in may not be able to resolve its references. If the references cannot be resolved, an error occurs, and the solution won’t execute.</p>
<p>
In PowerPoint, Visual Basic tries to resolve the reference by looking for the referenced add-in only in the same folder as the calling presentation or add-in.</p>
<p>
In Word and Microsoft Excel, Visual Basic tries to resolve the references by looking for the referenced file in the following locations:
<ol>
<li>
In the same folder as the calling add-in or template<br><br></li>
<li>
In the host application's root folder<br><br></li>
<li>
In the System and Windows folder<br><br></li>
<li>
In the all of the folders of the environment path statement</li>
</ol>
<p>
In Microsoft Excel, Visual Basic also looks in the folders appended to the Addin Path<b> </b>registry value.</p>
<p>
If the reference is not found after completing the above search, the execution of the solution is halted.</p>
<p>
Here are a few methods you can use to resolve the reference issue.
<ul type=disc>
<li>
Ship all files in the same folder.<p class=tl>
This is the most common solution. It’s very simple and least likely to fail.</P></li>
<li>
Have the setup program update the Add-ins Path registry key (Microsoft Excel only).<p class=tl>
Microsoft Excel 97 provides the HKEY_CURRENT_USER\Software\Microsoft\Office\8.0\Excel\Microsoft Excel\Add-in Path registry value, which points to folders where Microsoft Excel looks for add-ins. The Add-in Path value is a single string that consists of multiple paths delimited with semi-colons (;). When you install Microsoft Excel, the Setup program inserts paths to the Library, Analysis and Solver folders. Other setup programs may modify the “Add-in Path” value. All setup programs that write to this key must be polite and append entries. Uninstall programs that remove files and registry entries must only remove the portion of the Add-in Path value that applies to the application that is being uninstalled.</P></li>
<li>
Append your solutions folder to the Path environment variable.<p class=tl>
You can use the <b>GetEnvironmentVariable</b> and <b>SetEnvironmentVariable</b> API functions to append the solutions folder temporarily, or you can append it permanently writing to the Autoexec.bat Path statement. The following code example uses <b>GetEnvironmentVariable</b> and <b>SetEnvironmentVariable</b> to temporarily append the folder path to the Path environment variable:</P><pre><code>Option Explicit

Private Declare Function GetEnvironmentVariable Lib "kernel32" _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Alias "GetEnvironmentVariableA" (ByVal lpName As String, _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ByVal lpBuffer As String, _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ByVal nSize As Long) As Long

Private Declare Function SetEnvironmentVariable Lib "kernel32" _
 &nbsp;&nbsp;&nbsp;&nbsp; Alias "SetEnvironmentVariableA" (ByVal lpName As String, _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ByVal lpValue As String) As Long
'AppWord is a user defined compile directive.
#If AppWord = True Then
Public Sub AutoExec()
 &nbsp;&nbsp; AppendEnvironmentPath ThisDocument
End Sub
#End If

'AppExcel is a user defined compile directive.
#If AppExcel = True Then
Public Sub Workbook_Open()
 &nbsp;&nbsp; AppendEnvironmentPath ThisWorkbook
End Sub
#End If

Private Sub AppendEnvironmentPath(ThisDocObject as Object)
 &nbsp;&nbsp; Const ENV_PATH As String = "Path"

 &nbsp;&nbsp; Dim iRet As Long
 &nbsp;&nbsp; Dim szPath As String

 &nbsp;&nbsp; szPath = String$(1024, 0)
 &nbsp;&nbsp; ' Retrieve the current environment setting.
 &nbsp;&nbsp; iRet = GetEnvironmentVariable(ENV_PATH, szPath, 1024)
 &nbsp;&nbsp; If iRet Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' iRet contains the length of the returned string.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' trim any trailing characters.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; szPath = Mid$(szPath, 1, iRet)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' See if the templates path is included in the path statement.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If InStr(1, szPath, ThisDocObject.Path, vbTextCompare) = 0 Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Path is not part of the environment.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; szPath = szPath &amp; ";" &amp; ThisDocument.Path
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iRet = SetEnvironmentVariable(ENV_PATH, szPath)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If iRet = 0 Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Handle error here. Template path was not appended to
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' environment.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Err.Raise vbObjectError + Err.LastDllError, _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ThisDocObject.Name &amp; ".AppendEnvironmentPath", _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Path environment was not set."
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
 &nbsp;&nbsp; Else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' should raise an error here. This should never happen ...
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Err.Raise vbObjectError + Err.LastDllError, ThisDocObject.Name &amp;_
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ".AppendEnvironmentPath", "No path environment was found."
 &nbsp;&nbsp; End If
End Sub
</code></pre>
</li>
<li>
Write a reference broker add-in that customizes the references for a specific machine. The reference broker would check references and links before the solution is run (or at load time).<p class=tl>
This type of component is best suited for three-tier solutions. The reference broker could dynamically link the front-end component to backend components based on version, security level or other parameters determined by an administrator. This technique could be used to update components of a solution on the fly. This provides IS managers an easy way to maintain solutions on a WAN.</P><p class=tl>
One way to determine whether a reference is valid, is to use the <b>IsBroken</b> property of the <b>Reference</b> object. For more information about using the <b>IsBroken</b> property, refer to online Help in the Office applications.</P></li>
</ul>
<h4>Calling a routine in a PowerPoint add-in without setting a reference to the add-in</h4>
<p>
If you want to load an add-in file temporarily and execute a routine from the add-in, use <b>Application.Run</b> <i>add-in or presentation file name</i><b>!</b><i>macro name</i> (where <b>Application</b> represents the PowerPoint Application object) and then immediately unload the add-in. When <b>Application.Run</b> is executed, Microsoft PowerPoint will load the add-in and execute the specified macro. To immediately unload the add-in, set the <b>Loaded</b> property of the add-in to <b>False</b>.</p>
<pre><code>Sub CallAddInMacro()
 &nbsp;&nbsp; Application.Run "d:\My Documents\MyAddIn.ppa!MyMacro"
 &nbsp;&nbsp; AddIns("MyAddIn").Loaded = False
End Sub
</code></pre>
<p>
You can replace the last line of code with the following line:</p>
<pre><code>AddIns(AddIns.Count).Loaded = False
</code></pre>
<h4>Calling routines using late-bound references</h4>
<p>
You can call any public subroutine, function, property, or variable in the <b>ThisDocument</b> or <b>ThisWorkbook</b> class module of a document or workbook by using a late-bound reference to the associated <b>Document</b> or <b>Workbook</b> object. For example, the following statement sets an object variable to the <b>Document</b> object returned by the <b>Open</b> method and then calls the <b>MySub</b> routine in the <b>ThisDocument</b> class module of the document.</p>
<pre><code>Dim objDoc as Object
Set objDoc = Documents.Open(szFileName)
objDoc.MySub
</code></pre>
<p>
If the document represented by the <i>objDoc </i>variable didn’t have a public subroutine called MySub in its <b>ThisDocument</b> class module, a runtime error would occur. You can only call code in the <b>ThisDocument</b> or <b>ThisWorkbook</b> class module this way. If you want to call code in other modules, classes, and forms of the project using this method, you can write wrappers in the <b>ThisDocument</b> or <b>ThisWorkbook</b> class module to access the other .</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;This technique does not work in Microsoft PowerPoint because no events are defined for a PowerPoint presentation and there is therefore no <b>ThisPresentation</b> class module in a PowerPoint project.</p>
<h3>Protect or Unprotect your code</h3>
<p>
Setting the <b>IsAddin</b> property does not protect your source code. To protect your code, check <b>Lock project for viewing</b> and enter a password on the <b>Protection</b> tab of the <i>project name</i><b> Properties</b> dialog box from the <b>Tools</b> menu. If you enter a password without checking <b>Lock project for viewing</b>, users can view your code, but they can’t open the <i>project name</i><b> Properties</b> dialog box unless they know the password. After you set the password for the project, save the project by clicking <b>Save</b> on the <b>File</b> menu of the Visual Basic Editor.</p>
<p>
To unprotect your code, right-click the project name, click <i>project name</i><b> Properties</b>, enter the project password, and clear <b>Lock project for viewing</b> and enter a password on the <b>Protection</b> tab of the <i>project name</i><b> Properties</b> dialog box.</p>
<h3>Save Your Solution as an Add-in or Global Template</h3>
<p>
The procedure for creating an add-in varies in each Office application. In Microsoft Excel and PowerPoint, you save a file in a format specific to add-ins. In Word, you can save a document as a template (.dot) file.</p>
<h4>Creating a Microsoft Excel add-in</h4>
<p>
When you turn a workbook into an add-in, worksheets in the workbook are hidden, and subroutines in the add-in project are hidden from the user (the routines don’t appear in the <b>Macros</b> dialog box).</p>
<p>
To create a Microsoft Excel add-in, set the <b>IsAddIn</b> property to <b>True</b> for the workbook that contains your code. One way to do this is to save a copy of the workbook that includes the Visual Basic project as a Microsoft Excel add-in. To do this, select the Microsoft Excel add-in file type (.xla) in the <b>Save A</b>s dialog box from the <b>File</b> menu.</p>
<p>
You can also set the property manually in the Visual Basic Editor. To do this, select “ThisWorkbook” in the Visual Basic Project Explorer. Now set the <b>IsAddIn</b> property in the Properties Window to <b>True</b>. When the <b>IsAddIn</b> property is <b>True</b>, the workbook is hidden in Microsoft Excel.</p>
<p>
You can also set this property programmatically:</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;If you need to edit the workbook elements after creating the add-in, set the <b>IsAddIn</b> property to <b>False</b>. The workbook will become visible and editable. When you are done editing the add-in, set the <b>IsAddin</b> property to <b>True</b>, and save the workbook using the <b>Save</b> command on the <b>File</b> menu in the Visual Basic Editor.</p>
<h4>Creating a PowerPoint add-in</h4>
<p>
When you save a copy of a presentation as an add-in, all slides in the presentation are discarded, and only the Visual Basic project associated with the presentation is compiled and stored in the newly created PowerPoint add-in (*.ppa) file. Subroutines in the add-in are hidden from the user (they don’t appear in the <b>Macros</b> dialog box).</p>
<p>
Before you save a presentation as an add-in, save it as a presentation (a .ppt file). Then, to create a PowerPoint add-in, save a copy of the presentation as a PowerPoint add-in. To do this, click <b>Microsoft PowerPoint Add-In (*.ppa)</b> in the <b>Save As Type</b> box in the <b>Save</b> <b>As</b> dialog box (<b>File</b> menu).</p>
<p>
If you need to make changes to an add-in, modify copy of the presentation that has been saved as a .ppt file, and then create a new .ppa file from it.</p>
<h4>Creating a Word global template</h4>
<p>
Word does not support a separate add-in file format in the same way as Microsoft Excel and PowerPoint. A global template, or a template that has been loaded into memory so that its macro routines are available from any document, is the Word equivalent to Microsoft Excel and PowerPoint add-ins.</p>
<p>
To create a global template in Word, from the <b>File</b> menu click <b>Save As</b> and, in the <b>Save As Type</b> box, click <b>Document Template (*.dot)</b>.</p>
<h3>Debug Your Add-in or Global Template</h3>
<p>
Debugging add-ins and templates in Office 97 can be as simple as unprotecting the project and running the code.</p>
<h4>Debugging a Microsoft Excel add-in</h4>
<p>
To debug a Microsoft Excel 97 add-in while it is loaded, simply unprotect the Visual Basic for Applications project.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;If you need to see the workbook while you are debugging the project, set the <b>IsAddIn</b> property to <b>False</b>.</p>
<h4>Debugging a PowerPoint add-in</h4>
<p>
In Microsoft PowerPoint 97, the process for testing, debugging and editing the contents of an add-in involves setting a registry value in the Windows Registry. By default, Microsoft PowerPoint does not display loaded add-ins in the Visual Basic Project Explorer. However, PowerPoint provides a value in the Windows Registry under the following key for solution providers to debug their add-ins:</p>
<pre><code>HKEY_CURRENT_USER\Software\Microsoft\Office\8.0\PowerPoint\Options
</code></pre>
<p>
Under this key, set the value of DebugAddins to 1. The next time Microsoft PowerPoint is launched, all loaded Visual Basic for Applications add-ins will be displayed in the Project Explorer in the Visual Basic Editor. You can then unprotect the project if necessary, expand the project, set breakpoints and step through your add-in code.</p>
<p>
Setting the DebugAddins value to 1 also allows you to set breakpoints and step through the macro you have assigned to an action in a slide show using the <b>Action Setting</b> dialog box from the <b>Slide Show</b> menu. If DebugAddins is set to 0, the breakpoints are not honored.</p>
<h4>Debugging a Word global template</h4>
<p>
In Microsoft Word 97, the process for testing, debugging and editing a template is much the same as it was in previous versions of Word. Open the global template, unprotect the project if necessary, and run the appropriate subroutine. You may want to minimize the template in the application workspace.</p>
<h2>Distributing Your Solution with the Setup Wizard</h2>
<p>
Your custom solution can be composed of many files. For example, it can contain a Microsoft Access database, a Word template, a Microsoft Excel workbook, and various ActiveX™ controls.</p>
<p>
When you distribute a custom solution, you should make sure that the appropriate files are copied to the user's system, registry entries are created if necessary, and a shortcut to the custom application is created if needed.</p>
<p>
The Microsoft Office Developer's Edition includes a Setup Wizard you can use to create a Setup program that users can run to install the files for your custom solution on their systems. The Setup Wizard displays a series of dialog boxes that prompt you for information about your custom solution. When you finish responding to all the dialog boxes, the wizard creates a set of folders, known as disk images, on your hard disk. These folders contain your custom Setup program and the files needed for your custom solution. You can then copy the contents of the folders to floppy disks, a network location, or a compact disc.</p>
<h3>Setup Wizard Features</h3>
<p>
Depending on the settings you specify when you run the Setup Wizard, the Setup program for your custom solution can:
<ul type=disc>
<li>
Copy the custom solution files to specified locations on a user's hard drive.<br><br></li>
<li>
Create Windows shortcuts that start your custom solution.<br><br></li>
<li>
Add Windows registry keys and entries for your custom solution.<br><br></li>
<li>
Define components that users can select when they run the Setup program.<br><br></li>
<li>
Install the run-time version of Microsoft Access so that users won't need to have it previously installed to run your custom solution.<br><br></li>
<li>
Install other Microsoft Office components, such as Microsoft Graph 97, Replication Manager, indexed sequential access method (ISAM) drivers, and the files needed to use ODBCDirect.<br><br></li>
<li>
Run an application or open a file after the program finishes installing your custom solution.</li>
</ul>
<h3>Run the Setup Wizard</h3>
<p>
This section demonstrates how to run the Setup wizard to create a custom setup program. The sample solution used contains three files: a document describing the application, an Microsoft Excel add-in that is run from a menu command, and an Microsoft Excel add-in that contains demand loaded worksheet functions.</p>
<h4>Listing the files to include in the solution</h4>
<p>
When you run the Setup Wizard, you first list the files that you want your custom Setup program to copy. The wizard provides an <b>Add</b> button that you can use to add files to a <b>List of Files to Copy</b> list box. The first file added should be the main file of the application. In the solution shown, the main application file is the document.</p>
<p>
<img src="addins97_1.gif" border=0></p>
<p class=label>
<b>Figure 1. The Setup wizard</b></p>
<p>
After adding the main file, add all other files you want to distribute with your custom solution. If you used any additional ActiveX controls on forms or documents, be sure to include the .ocx file in the list of files to copy.</p>
<h4>Where you should install components</h4>
<p>
The Setup Wizard contains three destination folder roots: the Application path, Windows path and Windows System path. The Application path, <i>$(AppPath)</i>, is defined by the user at installation time. Components such as ActiveX controls that are used only by the solution should be installed into the application folder. Shared components are best installed in the Windows System folder, <i>$(WinSysPath)</i>.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The reason to keep ActiveX components that are <i>not </i>shared (not used by other applications) with the application is to prevent any file naming conflicts from occurring. Clients of the ActiveX control use the registry to find and load the control. The ActiveX technology uses a GUID (Globally Unique Identifiers) to guarantee that the interfaces defined in the registry are unique to the control.</p>
<p>
Paths can be appended to a root path. For example a destination folder <i>$(AppPath)/Data</i> would be the "Data" subfolder where the user chose to install the application.</p>
<h4>Grouping files into components</h4>
<p>
You can group the files in your solution into components. This can be useful if you have different levels of users who require different components. For example, you can define a Help component that includes all the .hlp files for your custom solution. A user can choose whether to include the Help component when running your Setup program.</p>
<p>
To define a component, click the ellipses (<b>. . .</b>) button next to the <b>Component Name</b> list box on the second screen of the Setup Wizard. The <b>Components Builder</b> dialog box enables you to add and delete component names. To define which files you want to include with each component, select a file under <b>List of File Names</b> in the <b>Component Name</b> list box, and then select the component in which you want to include the file.</p>
<p>
The sample solution has only the Application component group, which is required for all installations.</p>
<p>
<img src="addin02.gif" border=0></p>
<p class=label>
<b>Figure 2. The component builder</b></p>
<h4>Adding shortcuts</h4>
<p>
Clicking <b>Next</b> will display the <b>Add Shortcuts</b> panel, where you can add shortcuts for you solution. For the sample solution shown, a shortcut is added to the documentation file.</p>
<p>
<img src="addin03.gif" border=0></p>
<p class=label>
<b>Figure 3. Adding shortcuts with the Setup wizard</b></p>
<h4>Adding registry values</h4>
<p>
Clicking <b>Next</b> will display the <b>Add Registry</b> values panel. For Microsoft Excel add-ins, this is an important step. Here you can add menus, and commands and load add-ins without ever having to load Microsoft Excel. The following steps demonstrate adding a command called "Example Macro. . ." to the Microsoft Excel <b>Tools</b> menu via the registry.
<ol>
<li>
Select <i>HKEY_CURRENT_USER</i> as the top-level key.<br><br></li>
<li>
For the Path to Key type Software\Microsoft\Office\8.0\Excel\Init Commands.<br><br></li>
<li>
For the Value Name<b> </b>enter any unique name that describes the purpose of the value. For this example, enter DistExample.<br><br></li>
<li>
Select the file this value is going to be based on. This will automatically add the setting <i>$(FilePath)\filename.ext</i> to the Value Data setting.<br><br></li>
<li>
In the <b>Value Data</b> setting, the script variable $(FilePath)<b> </b>represents the path the user chose to install the application to. Change the current setting to "10,Tools,Example Macro …, $(FilePath)\DevSolAddinExample.xls!ThisWorkbook.Example,,,Status Text".</li>
</ol>
<p>
<img src="addin04.gif" border=0></p>
<p class=label>
<b>Figure 4. Adding registry values with the Setup wizard</b></p>
<p>
Gathering information from the user or environment might best be done by running a program after the Setup program is finished. This could be done by opening up a Word or Microsoft Excel document and using the Open event handler to execute a Visual Basic for Applications macro. Frequently it is easier for Word or Microsoft Excel to do this type of setup than a setup tool. In the <b>Execute Application</b> panel in the Setup Wizard, select the document or file that should open after the setup completes.</p>
<p>
<img src="addin05.gif" border=0></p>
<p class=label>
<b>Figure 5. Setting which application will open after custom Setup is complete</b></p>
<p>
After completing the information on the type of installation, you want to build, click <b>Finish</b> to complete the wizard.</p>
<h4>Testing your distribution solution</h4>
<p>
After the Setup Wizard finishes creating a distribution disk set for your add-in, you should test the Setup program. The test system should have the minimum installation of each target OS and minimum installation of Office. Developers commonly have a complete installation of Office and don't realize that a solution they have created may depend on a component that is not included with a typical Office installation.</p>
<p>
If you are targeting an international market, test your solution with international versions of the target OS and Office applications. Most international issues can be solved by changing the International settings in the Control Panel to those of the appropriate country. For more information on international issues, see the Readme document that ships with the Setup Wizard. It is more common for Control Panel settings to bring out bugs in your code than the language of the OS.</p>
<p>
Setup should be tested from floppy disk images, CD-ROM, the local hard disk, and the network. Testing across the network should include both mapped drives and UNC connections.</p>
<p>
Microsoft Office should be installed in path configurations different from that of the developer who created the solution. The locations for key features such as templates, startup directories, and workgroup information files should be changed to non-default settings.</p>
</BODY>
</HTML>
