<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Microsoft Jet 3.5 Performance Overview and Optimization Techniques</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_jet35"></a>Microsoft Jet 3.5 Performance Overview and Optimization Techniques</h1>
<p>
January 15, 1997</p>
<p>
Kevin Collins<br>
Microsoft Jet Program Management</p>
<h2>Overview</h2>
<p>
Microsoft® Jet 3.5 is the database engine that is used in Microsoft Office 97, which includes Microsoft Access 97, and in Microsoft Visual Basic® version 5.0. Any application that has access to the version of Visual Basic for Applications that shipped with Office 97 will have access to Jet data. There is no format change in Jet 3.5; thus, it is possible to access a database that was created with Jet 3.0 without converting it. (Note: Microsoft Access 97 does require a conversion process, primarily due to a new method of storing Visual Basic for Applications.) Even though the database format has not changed, an application cannot access Jet 3.5 using DAO 3.0. Thus, if you are using Microsoft Visual Basic version 4.0, you will not be able to reference the DAO 3.5 type library to gain access to Jet 3.5. Jet 3.5 also has new file names for the three primary DLLs that it uses (MSJET35.DLL, MSJINT35.DLL, and MSJTER35.DLL).</p>
<p>
The primary goal of this paper is to disseminate information regarding features of Jet 3.5 that you can use to improve and optimize performance. Since many of the features are primarily exposed through DAO, this paper will also illustrate some of the new properties and methods included in DAO 3.5. This paper will go over each feature and, where applicable, include sample code to illustrate the features along with performance numbers generated from the Jet performance lab. In addition, tips and techniques discovered during our performance analysis will be shown along with other pertinent information discovered from customers in the field. Below is a high level list of the major enhancements that were put into Jet/DAO 3.5 to improve and fine tune performance.
<ul type=disc>
<li>
Programmatic run-time control of registry settings<br><br></li>
<li>
Improved caching mechanism<br><br></li>
<li>
Reduced locking<br><br></li>
<li>
Improved allocation of pages by extents (clustering)<br><br></li>
<li>
Improved page recycling<br><br></li>
<li>
Explicit default registry entries<br><br></li>
<li>
Removal of locking issues with Netware<br><br></li>
<li>
Improved lock-retry mechanism to reduce network traffic<br><br></li>
<li>
Programmatic control of refreshing cache<br><br></li>
<li>
Programmatic control to guarantee flushing of cache to disk<br><br></li>
<li>
Significant performance increase with large SQL DML statements<br><br></li>
<li>
Improved Rushmore™ algorithms<br><br></li>
<li>
Improved performance on SQL DELETE statements</li>
</ul>
<h2>Architecture Changes</h2>
<h3>Non-configurable Performance Settings </h3>
<h4>Reduced locking</h4>
<p>
To improve multi-user performance over that of Jet 3.0, the Jet team took a hard look at where concurrency bottlenecks were occurring. This analysis leads to a modification of locking algorithms in two areas: write locks on index pages and read locks on long value (LV) data pages. </p>
<p>
When a Jet 3.0 database used enforced referential integrity, Jet would always place a read lock on any index page that was being read. This was necessary to prevent other users from changing data in an upper-level index btree that might be necessary to enforce referential integrity. However, this did not come without cost as write locks on a series of index pages would prevent other users from even seeking on that index. </p>
<p>
This was discovered too late in the Jet 3.0 time frame for the Jet team to make an architectural change to reduce the concurrency hit. This was resolved in Jet 3.5 by replacing the write locks with read locks on index pages that were not being modified. This allows Jet to continue to enforce referential integrity while still allowing other users to read the index pages.</p>
<p>
The other locking enhancement in Jet 3.5 concerns placing read locks on LV pages. LV pages typically contain columns with the Memo and OLE data types used in Microsoft Access. In Jet 3.0 a read lock would be placed on every LV page that was being read. The primary reason for using read locks was to ensure that the user would see unchanged data when reading large LV pages. However, while we examined more customer databases, we discovered that many users were using a Memo field with only a minimal amount of data being stored. Since LV data that did not span more than one page did not meet the original criteria for placing read locks, the Jet team devised a way to eliminate read locks in those scenarios. The outcome of this was to remove read locks on LV pages that did not span more than one page. This substantially reduced concurrency conflicts and substantially increased performance.</p>
<p>
Figure 1 shows the multi-user performance throughput improvements in Jet 3.5:</p>
<p>
<img src="jet35_1.gif" border=0></p>
<p>
Since Jet 3.0, a large effort has been made to measure performance with Jet. The Jet 3.5 team expanded on this effort by increasing test suites to over 1,500 performance benchmarks. The chart above and graphs that will follow are results from some of those tests.</p>
<p>
The lab was also upgraded during the 3.5 cycle to reflect the operating system and machine hardware that a high-end customer might use. Of course, testing was still done with memory restrictions as low as 5 MB of RAM to represent users with low-end hardware. The majority of the multi-user tests were conducted on 36 machines. 27 of them were identically configured Pentium 60 MHz machines with 32 MB of RAM while the remaining nine were Pentium 120 machines with 64 MB of RAM. All machines had a 540-MB IDE hard disk drive and many had a second 1.2- or 2.5-GB EIDE hard disk drive with a PCI network interface card (NIC). The tests were run using only DAO/SQL commands on Windows NT® Server/Workstation 3.51 SP5, Windows NT Server/Workstation 4.0, Windows® 95 SP1 or OSR2. When run in a network environment, the network operating system was NetWare 4.11 on a Dell XPE PowerEdge P120 with four, 1-GB RAID drives running off a dedicated EISA RAID SCSI host adapter, two four-port PCI full-duplexed Ethernet NICs and 64 MB of RAM.</p>
<h4>Improved Rushmore algorithms</h4>
<p>
<img src="jet35_2.gif" border=0></p>
<p>
Jet 3.5 was improved to use Rushmore technology on more operands in predicates. In particular, the FALSE and &lt;&gt; operands now provide substantial performance improvements.</p>
<p>
<img src="jet35_3.gif" border=0></p>
<h4>Removal of implicit transaction for SQL DML statements</h4>
<p>
Even with all the work in Jet 3.0 to eliminate transactions in order to obtain better performance, SQL DML statements were still placed in an implicit transaction. This negated some of the performance work and typically resulted in DAO looping code to substantially outperform SQL DML statements. Jet 3.5 has removed that restriction and SQL DML statements now are no longer placed in an implicit transaction. This results in a substantial performance benefit when running SQL DML statements that affect many rows of data.</p>
<p>
<img src="jet35_4.gif" border=0></p>
<p>
While this change provides a substantial performance increase, it also introduces a change to the behavior of SQL DML statements. Previously, a SQL DML statement would roll back if any part of the SQL DML statement could not be completed. This was due to the fact that Jet placed it in an implicit transaction. It is now possible to have some of the rows committed by a SQL DML statement while others are not. An example of this would be when Jet’s cache is exceeded. The data in the cache will be flushed to disk and the next set of rows will be modified and placed in the cache. Therefore, if the connection were terminated, there would be a possibility that some of the rows were saved to disk and others were not. This behavior is the exact behavior that Jet 3.0 users would see when using DAO looping constructs to update data without an explicit transaction. If this behavior is not desired, then the user will need to add explicit transactions around the SQL DML statement to define a set of work and sacrifice the performance gains. </p>
<h4>Reduced index Btree navigation</h4>
<p>
Jet 3.5 has been enhanced to not reseek an index page if the index is a primary or unique index. This reduces the amount of I/O that occurs since Jet does not need as many reads.</p>
<h4>Improved cache reuse</h4>
<p>
Jet 3.0 would always refresh its cache on a page when a read lock was promoted to a write lock. In Jet 3.5 it is no longer necessary to refresh the cache when this operation occurs, thus resulting in reduced I/O.</p>
<h4>Persistent connections to security system tables</h4>
<p>
While working with the Microsoft Access team, we discovered that their implementation of Jet through the user interface required frequent checking for security on objects. Jet 3.5 now keeps the MSysObjects and MSysACEs tables open for the duration of a Jet instance in order to improve performance through the Microsoft Access user interface and other areas where security is implemented and objects are being referenced through DAO. This reduces the overhead of constantly opening and closing those tables when security is implemented and reduces I/O.</p>
<h4>Reduced flushing of the cache</h4>
<p>
When adding data to a table, Jet 3.0 would always flush its cache every two seconds after each extent (up to 16K) was added. By examining the performance characteristics when adding one million rows of data, Jet 3.5 was modified to only flush its cache two seconds after all new extent data was added to the database. This results in less I/O.</p>
<p>
<img src="jet35_5.gif" border=0></p>
<h4>Larger allocation by extents</h4>
<p>
Jet 3.0 would allocate up to 8 pages (16K) at a time when adding data to a table. This was done to allow data to be contiguous within a table, thus optimizing sequential reads and Jet’s read-ahead cache. It was determined during performance testing that increasing this maximum allocation resulted in better performance. Jet 3.5 has been modified to add up to 32 pages (64K) at a time when adding data. Like Jet 3.0, Jet 3.5 is smart about adding large extents to tables and will only do so when large numbers of rows exist in a table. </p>
<h4>Improved performance with DELETE statements</h4>
<p>
<img src="jet35_6.gif" border=0></p>
<p>
One of the big performance improvements in Jet 3.0 was the reduced time it took to remove a table or delete all the rows in a table. While Jet 3.0 offered substantial performance improvements, there was still room for improvement and Jet 3.5 took advantage of that by optimizing how it removed pages in the database by reading and processing less directory pages.</p>
<h4>Faster generation of query plans</h4>
<p>
During the course of performance tests, it was determined that users who used temporary queries (for example, DB.Execute SQL) or constantly modified stored queries in code were experiencing slow performance. Jet 3.5 addressed this issue by optimizing the query plan generation process.</p>
<p>
<img src="jet35_7.gif" border=0></p>
<h4>Explicit registry values</h4>
<p>
<img src="jet35_8.gif" border=0></p>
<p>
With Jet 3.0 it was difficult for users to manipulate registry values to control Jet because the key names, types, and values were not created in the registry. Jet 3.5 remedies that by explicitly loading the key names and default values when Jet 3.5 is registered. Explicit registry names and values are also loaded for the Jet 2.<i>x</i> installable ISAM. Below is a listing of the default registry entries for Jet 3.5. New registry entries will be discussed later in this paper.</p>
<h4>New MaxBufferSize formula</h4>
<p>
When using the default value of zero for the MaxBufferSize registry setting in Jet 3.0, Jet would calculate how much RAM to dynamically allocate for its cache. This formula was <code>((Total in MB – 12) / 4 + 512K)</code>. However, it was discovered that machines with large amounts of RAM (that is, over 64 MB) were becoming more common and causing Jet to start using a large amount of RAM for the cache. This could potentially cause a lot of swapping to occur due to the use of virtual memory, especially when Jet was being used with Microsoft Internet Information Server (IIS). Jet 3.5 addressed this issue by putting a cap of 13,824K on the result of the formula. The user can override the formula and the cap by putting a value other than zero for the MaxBufferSize setting.</p>
<h3>Configurable Performance Enhancements</h3>
<h4>Programmatic run-time registry control</h4>
<p>
From talking with customers and examining the results of different registry settings while running performance tests, we realized that there was only so much self-tuning that Jet could do to optimize all scenarios. The only way to fine-tune Jet was by exposing programmatic run-time controls via DAO. </p>
<p>
Probably the most exciting enhancement to Jet 3.5 is the ability to control the majority of Jet’s registry value settings during run time. This provides the developer with ultimate control over performance and functionality for Jet 3.5. These new features are exposed through DAO 3.5 with the new <b>SetOption</b> method of the <b>DBEngine</b> object. Below is a list of the Jet registry values and their corresponding DAO constants that can be manipulated during run time.</p>
<p>
<img src="jet35_9.gif" border=0></p>
<p>
It is important to note that using the <b>SetOption</b> method only affects the run-time values of the registry and does not physically change the values in the registry. Thus, once Jet is restarted, it will read the values in the registry. This means that in order to control Jet’s registry setting the developer must use the <b>SetOption</b> method in code that executes every time an application starts. Below is a code sample that illustrates how a developer might use the <b>SetOption</b> method to optimize code to take advantage of Jet’s buffer setting:</p>
<pre><code>Sub Main()
 &nbsp;&nbsp; On Error GoTo ErrorHandler
 &nbsp;&nbsp; Dim db As Database, rs As Recordset, ws As Workspace
 &nbsp;&nbsp; Dim strCompanyName As String, _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strContactName As String, _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lngReads As Long, lngWrites As Long
 &nbsp;&nbsp; Set db = _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OpenDatabase("c:\northwind.mdb", False, False)
 &nbsp;&nbsp; DBEngine.SetOption dbMaxBufferSize, 128
 &nbsp;&nbsp; Set rs = db.OpenRecordset _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ("SELECT * FROM Customers", dbOpenDynaset)
 &nbsp;&nbsp; Set ws = Workspaces(0)
 &nbsp;&nbsp; lngReads = DBEngine.ISAMStats(0, True)
 &nbsp;&nbsp; lngWrites = DBEngine.ISAMStats(1, True)
 &nbsp;&nbsp; While Not rs.EOF
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rs.Edit
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strCompanyName = rs!CompanyName
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strContactName = rs!ContactName
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rs!CompanyName = strCompanyName
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rs!ContactName = strContactName
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rs.Update
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rs.MoveNext
 &nbsp;&nbsp; Wend
 &nbsp;&nbsp; ' The null transaction ensures no more asynchronous
 &nbsp;&nbsp; ' activity that could yield inaccurate statistics.
 &nbsp;&nbsp; ws.BeginTrans
 &nbsp;&nbsp; ws.CommitTrans
 &nbsp;&nbsp; lngReads = DBEngine.ISAMStats(0)
 &nbsp;&nbsp; lngWrites = DBEngine.ISAMStats(1)
 &nbsp;&nbsp; MsgBox "Total reads " &amp; CStr(lngReads) &amp; _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " Total writes " &amp; CStr(lngWrites)
 &nbsp;&nbsp;&nbsp; Exit Sub
ErrorHandler:
 &nbsp;&nbsp; MsgBox "An error has occurred " &amp; Err &amp; " " &amp; Error
 &nbsp;&nbsp; Resume Next
End Sub
</code></pre>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;If the dbMaxBufferSize value above is modified from 128 to 2048, the number of writes will decrease from 20 to 11. This is an extreme example to illustrate the point while using the Northwind database. Using these numbers for a real world scenario is not recommended.</p>
<h4>Programmatic control of flushing Jet’s write cache</h4>
<p>
While programmatically flushing Jet’s write cache isn’t necessarily a performance enhancement, it allows developers to guarantee that their data has been written to disk after they issue the DAO <b>CommitTrans</b> method. While Jet does tell the operating system to write its data to disk after a <b>CommitTrans</b>, the operating system has a lazy-write cache that does not necessarily write data to disk, but does notify Jet that the data has been written to its cache. While Jet could tell the operating system to bypass its lazy-write cache, doing so would cause significant performance degradation. Therefore, to give developers the best default performance, but allow for increased functionality, Jet exposed an interface to bypass Windows 95’s and Windows NT Server/Workstation’s lazy-write cache. (Note: This feature works only for Windows 95 and Windows NT Server/Workstation. If the .mdb file is used with any other operating system, the feature will not work.) You can programmatically flush the cache by using an additional property on the <b>CommitTrans</b> method called <b>dbForceOSFlush</b> (for example, <code>ws.CommitTrans dbForceOSFlush</code>). </p>
<p>
This property should be used only when it is critical to know that all the data in a transaction has been written to disk before proceeding with the next command. Below is a chart demonstrating the performance impact when utilizing this property.</p>
<p>
<img src="jet35_10.gif" border=0></p>
<h4>Programmatic control of refreshing the cache</h4>
<p>
A feature of Jet 3.0 was the ability to have performance parity between a database being opened as shared and a database being opened exclusively. This was largely accomplished by improved buffer refreshing. However, to implement that feature, it was necessary to modify the behavior of PageTimeout to check the database header page (DBH). The default for checking the DBH was determined by the PageTimeOut setting in the registry and by default would retry it every five seconds. While this proved optimal for performance, the drawback was that a user could go for almost ten seconds before seeing changes made by other users. The workaround for this behavior was to set the PageTimeOut registry setting to a lower value. However, this resulted in a performance hit as Jet was forced to read the DBH more frequently, resulting in increased I/O.</p>
<p>
Jet 3.5 addressed this problem by exposing an interface to force the cache to be refreshed regardless of the PageTimeOut setting. DAO exposed this interface by adding a new argument, <b>dbRefreshCache</b>, to the <b>Idle</b> method of the <b>DBEngine</b> object. The <code>DBEngine.Idle dbRefreshCache</code> statement forces Jet to immediately read the DBH to see if any changes have occurred. If they have, Jet’s cache will be refreshed and the user that issued the command will see any changes made by other users. This change allows for the PageTimeOut setting to be left at its default, thus providing optimal performance, and giving the developer control over when to check for other users’ changes. However, just as may happen when PageTimeOut is set to a low value, using <code>DBEngine.Idle dbRefreshCache</code> inappropriately may cause performance problems. Below is a chart illustrating the increased I/O that is caused by repeatedly calling <b>dbRefreshCache</b>.</p>
<p>
<img src="jet35_11.gif" border=0></p>
<h4>Improved control over lock retries</h4>
<p>
Depending on the network operating system, Jet can cause short bursts of network traffic when attempting to retry for a lock. In order to prevent these short bursts of network traffic that could cause performance problems for the network administrator, Jet 3.5 introduced a new registry setting called LockDelay. This registry setting works in conjunction with the LockRetry registry setting and places a default delay of 100 milliseconds between every lock retry. Besides eliminating the short burst of lock retries that could occur on certain network operating systems, this feature provides a more consistent feel to users when they encounter locking conflicts.</p>
<h4>Improved functionality with NetWare network operating system</h4>
<p>
All versions of Jet place locks on the .ldb file while modifying data. Many locks can accumulate when data is being manipulated inside a transaction. The accumulation of locks caused particular problems with NetWare servers because they could handle only up to 10,000 locks per connection. This limit ensured good performance on a NetWare server, but caused Jet not to complete large transactions. When users would encounter this scenario, they would experience long delays before they would even get an error message stating that the transaction would need to be rolled back. The only workaround was to break transactions that affected many rows into mini transactions and replace SQL DML statements (prior to version 3.5) with the equivalent DAO looping scenarios that would use mini transactions that affected fewer rows. </p>
<p>
Jet 3.5 addresses this problem by introducing a new registry setting called MaxLocksPerFile. With Jet 3.5, an explicit transaction will automatically partially commit when more than the default setting of 9500 locks have accumulated. While this setting is primarily for NetWare users, it is also useful to Windows NT Server/Workstation 3.5x users because performance will start to degrade when Windows NT Server/Workstation has to manage that many locks. Windows NT Server/Workstation 4.0 addresses many of those performance issues, but still runs optimally with the MaxLocksPerFile registry setting as its default.</p>
<h4>Improved page recycling</h4>
<p>
Many applications would experience database bloat when manipulating LV data types. This behavior was caused by performance enhancements with LV data in Jet 3.0. A particular area of database bloat would occur when developers would manipulate form, report, or Visual Basic for Application modules in Microsoft Access. There were only two workarounds to recover the empty space from modified LV data types. The first workaround required a user to be the last user to close the database. Once the database was reopened, the empty LV space would be recycled, but the size of the .mdb file would not shrink. The other solution was to compact the database, which would reclaim the LV data pages and shrink the database’s physical size.</p>
<p>
Jet 3.5 resolved this issue by modifying the way that it recycles pages. Jet 3.5 can now recycle LV pages once a new allocation of LV pages has been created. The size of the database will still grow initially, but it will remain stable with only small increases of size over time. However, the Jet performance team discovered that this feature caused a performance hit when manipulating LV data. To circumvent the performance issue, a new registry entry called RecycleLVs was added. By default, RecycleLVs is turned off to ensure performance parity with Jet 3.0. However, Microsoft Access will dynamically turn this feature on immediately before manipulating any of its objects that utilize LV data and will turn it off when those objects are no longer being manipulated. This provides the user with optimal performance while minimizing database bloat.</p>
<p>
DAO users who are manipulating LV data should leave the RecycleLVs registry setting turned off and turn it on only when necessary by utilizing the <b>SetOption</b> method of the <b>DBEngine</b> object discussed above.</p>
<h4>New asynchronous writing techniques</h4>
<p>
The biggest performance change for Jet 3.5 was a modification to how Jet uses its internal cache for manipulating data outside transactions. One of the biggest performance improvements in Jet 3.0 was the introduction of asynchronous writes. However, due to potential concurrency issues, this feature could not be fully exploited.</p>
<p>
In Jet 3.0, asynchronous writes were controlled by two registry entries: MaxBufferSize and SharedAsyncDelay/ExclusiveAsyncDelay. The SharedAsyncDelay setting is used for databases opened in shared mode; likewise, ExclusiveAsyncDelay is used for databases opened in exclusive mode. The combination of the two settings determined how long modified data pages could be held in Jet’s cache before being flushed to disk. The most restrictive of the two registry entries was SharedAsyncDelay. The default SharedAsyncDelay value was 50 milliseconds. This value prevents concurrency issues that could arise with Microsoft Visual Basic or Microsoft Access users modifying data through forms, because any modified data that is held in Jet’s cache also has a corresponding write lock. Therefore it was necessary to keep the SharedAsyncDelay setting low as to prevent pages from sitting in Jet’s cache and holding write locks. This scenario would cause a significant concurrency issue if a higher SharedAsyncDelay value were used as the pages in Jet’s cache would continue to hold write locks. However, leaving the value low also directly affected performance on operations that manipulated many rows of data at once (such as looping constructs in DAO or SQL DML statements) due to the fact that Jet was not utilizing its cache as it flushed its cache every 50 milliseconds. </p>
<p>
This situation made it very difficult for a developer to take advantage of the asynchronous writing techniques that were present in Jet 3.0 without affecting concurrency. The only way to take advantage of these techniques was to have one machine with a high SharedAsyncDelay setting designated as the machine to only run operations that affected many rows. </p>
<p>
Jet 3.5 introduces a new method of determining when to flush the cache for asynchronous writes that eliminates this problem. This was accomplished by adding a new registry setting called FlushTransactionTimeout that would ignore the AsyncDelay registry settings. While Jet 3.0 would use the SharedAsyncDelay setting to determine a maximum amount of time to elapse before flushing the cache to disk, Jet 3.5 uses the FlushTransactionTimeout setting to determine an amount of time of inactivity before flushing the cache to disk. </p>
<p>
This eliminates the problem with users modifying data in forms because 500 milliseconds, the default setting for FlushTransactionTimeout, would expire before the user could modify and save the next row. Therefore, the maximum amount of time that a lock would be held on the data and index pages associated with the row being edited would be 500 milliseconds. This eliminated any concurrency issues when using forms in Microsoft Visual Basic or Microsoft Access. On the performance side, users would see significant performance increases, as Jet would now be able to use the maximum amount of cache before flushing to disk. This is due to the fact that any operation that modifies many rows (for example, a DAO looping construct or a SQL DML statement) would be adding rows to Jet’s cache before the 500 milliseconds setting would expire. This behavior results in Jet fully utilizing its cache and substantially less I/O because Jet does fewer reads and writes. Below is an example of the performance differences with the new behavior.</p>
<p>
<img src="jet35_12.gif" border=0></p>
<p>
As the chart illustrates, almost a 50% reduction in I/O was accomplished with this new setting, while not increasing concurrency with forms usage. While the Jet performance team did not encounter any reason to not use this feature, setting the FlushTransactionTimeout value to zero disables the feature. Disabling this feature causes Jet to use the AysncDelay settings in the same manner as Jet 3.0.</p>
<h2>Optimization Tips and Techniques</h2>
<p>
This section is intended to illustrate performance optimization tips and tricks that the Jet performance team discovered during our internal tests and while examining performance issues provided by customers. </p>
<h3>Prevent Unnecessary Query Recompilation</h3>
<p>
An area that can cause performance degradation is the constant recompiling of stored queries. We have seen this occur when DAO objects are not explicitly closed. The reason for this is that stored queries reference a particular memory address in order to use the Visual Basic for Applications expression service. If a DAO object is opened followed by the execution of a stored query, re-executing that query may cause Jet to recompile because the original memory address space is occupied. In certain circumstances this can also cause the database to increase in size. Many of these issues were resolved in Jet 3.5, but some of the issues can be resolved only by explicitly closing DAO objects when they are no longer being used. The developer should not rely on Visual Basic for Applications to implicitly close objects when a <b>Sub</b> or <b>Function</b> procedure is exited. </p>
<p>
If explicitly closing the DAO object is not an option due to nested explicit transactions or some other scenario, another possible workaround is to use the <code>dbForwardOnly</code> syntax when opening a recordset. Using the <code>dbOpenShapshot, dbForwardOnly</code> syntax prevents Jet from recompiling the query. We have found this to be most useful when using the data grid that comes with Microsoft Visual Basic version 4.0, because the developer has no control to explicitly close the DAO objects being used.</p>
<h3>Compact Frequently</h3>
<p>
From a performance perspective, there are many reasons to frequently compact a database. One reason is that compacting will create a new database that stores all table rows in a contiguous order. If a primary key or unique index is defined, the rows will be sorted in order of the primary key or unique index. This allows Jet to take full advantage of its read-ahead cache and also reduces disk I/O when doing sequential scans of a table. Compacting also causes all the statistics in the database to be recalculated. Statistics can become out of date during the course of database operations, thus resulting in inaccurate query plans. Probably the most important performance reason for compacting the database is that the <b>CompactDatabase</b> command or <b>CompactDatabase</b> method switches a flag in all stored queries that causes them to recompile the next time they are executed. This is important because it ensures that the query plan retrieves the latest statistics and creates the best execution path to retrieve the data.</p>
<p>
Compacting is also important from a stability standpoint because it removes all deleted pages, recopies all pages (thus ensuring integrity in the pages), and recreates all index pages. </p>
<p>
A somewhat related issue to this concerns repairing a database. A bug was found in Jet 3.0 where issuing the <b>RepairDatabase</b> command (or the <b>RepairDatabase</b> method) before compacting the database could result in a database that could no longer be opened. This problem (due to a very rare bug that could allow duplicate indexes on the system tables) has been resolved in Jet 3.5 and a special release of Jet 3.0 is now available on <a href="http://www.microsoft.com/kb/articles/q151/1/86.htm">http://www.microsoft.com/kb/articles/q151/1/86.htm</a>. Note that the problem will never occur if the database is compacted before it is repaired. Previously it was recommended to repair the database before compacting it. This was primarily for Jet 2.<i>x</i> databases, because the <b>RepairDatabase</b> command and <b>RepairDatabase</b> method had additional functionality to recover truncated rows of data. This is no longer true for Jet 3.<i>x</i> file formats and it is recommended that users only repair a database if a Jet error message indicates that this is necessary.</p>
<h3>Avoid Embedding Expressions in Queries</h3>
<p>
Probably the biggest performance issue that we have seen from customer databases results from the use of expressions in queries. Having an expression in a query prevents Jet’s query optimizer from recognizing the column in the expression, thus not using the column for index or Rushmore optimization. This alone can cause a substantial performance hit. In addition, expressions are evaluated for every row, not just the rows that are returned. This can cause substantial overhead. One customer’s query went from two minutes to two seconds by removing the embedded expressions. The best place to put expressions is at the form or report level because then expressions are only evaluated for the rows returned.</p>
<h3>Cautiously Use Indexes</h3>
<p>
While having indexes can typically decrease data-retrieval times, they always carry a cost in maintenance and concurrency issues. Below is a test showing the throughput differences when randomly updating one row of data in one table from six workstations.</p>
<p>
<img src="jet35_13.gif" border=0></p>
<p>
By simply adding an index to the column that was being updated, overall throughput diminished over five times! The question then becomes: When should a column be indexed? There is no concrete answer for this, as it depends on the type of application. The first rule of thumb is that highly duplicated data types should not be indexed (for example, Boolean data types, and columns that represent gender, state abbreviations, or country codes). The second rule of thumb is to not add indexes to columns simply to force Rushmore to use more than one index. An example of this would be indexing a column called City and a column called ZipCode in a customer table when the application is always going to be using both columns for retrieval purposes. In this instance, ZipCode is going to be the most unique index and would return a faster result set if City was not indexed. This is because Rushmore need not use the index on City, thus reducing overall I/O. Of course, if both values were not always being entered and they were used alternatively and equally, then having an index on both columns would probably be advantageous. Rushmore is best utilized when combined indexes generate a unique result set.</p>
<p>
It is also important to remember that indexes create concurrency issues, as one index page represents many data pages. Therefore, modifying an index page can cause users with data on an entirely different data page to be locked out when trying to update the indexed column. This is illustrated in the chart above. </p>
<p>
To see this behavior, open the Northwind database in Microsoft Access 97 and turn pessimistic locking on. Update a value in one indexed field in the Customer table but don’t move to the next record. On another workstation, open the Customer table and try to edit another value in the same indexed field that the other workstation is editing. Next try updating a value in an non-indexed field in the Customer table. What will become evident is that substantially more records of data are locked when you try to update a value in an indexed field than when you try to update a value in a non-indexed field.</p>
<p>
While we are not stating that developers should not index, we are saying that developers and database administrators should be aware of the pros and cons of indexing.</p>
<h3>Use SQL DML Statements Instead of DAO Looping Constructs</h3>
<p>
In the majority of cases (Jet 3.5 only), it is better to use a single SQL DML statement than a looping DAO construct. Below are two examples of code, with a chart following showing the time differences.</p>
<pre><code>Set rs = gdbOrder.OpenRecordset("Customer")
While Not rs.EOF
 &nbsp;&nbsp;&nbsp; rs.Edit
 &nbsp;&nbsp;&nbsp; rs![AddressStatus] = rs![AddressStatus] + 1
 &nbsp;&nbsp;&nbsp; rs![CTitle] = "President"
 &nbsp;&nbsp;&nbsp; rs![CCompany] = "Olivetti"
 &nbsp;&nbsp;&nbsp; rs![EntryDate] = "10:20AM"
 &nbsp;&nbsp;&nbsp; rs![Country] = 12
 &nbsp;&nbsp;&nbsp; rs.Update
 &nbsp;&nbsp;&nbsp; rs.MoveNext
Wend
gdbOrder.Execute "UPDATE Customer SET AddressStatus = (AddressStatus+1), Ctitle = ‘President’, Ccompany = ‘Olivetti’, EntryDate = #10:20AM#, Country=12;", dbFailOnError
</code></pre>
<p>
<img src="jet35_14.gif" border=0></p>
<p>
While this is one of the more extreme examples that we have seen and is only inherent in Jet 3.5 due to removal of implicit transactions for SQL DML statements, it demonstrates that the developer should examine the code for potential performance enhancements by re-coding DAO looping constructs with SQL DML statements.</p>
<h3>Implement Persistent Connections with Linked (Attached) Tables</h3>
<p>
Another performance issue raised by customers using Jet 3.0 was due to a change in how Jet dealt with the .ldb file. The .ldb file is used to track which users have the database open and to track the locking of pages in the .mdb file. In Jet 3.0, the .ldb file was deleted when the last user closed the database. This was done to prevent littering of .ldb files when replication was being used. However, in situations where only one user was accessing a linked table, particularly in a looping construct, a significant performance hit was experienced. This was because linked tables do not keep persistent connections to the database where they reside. This causes a lot of additional I/O to delete, recreate, and establish locks on the .ldb file. </p>
<p>
The workaround for this is to have the application keep a persistent connection to any table where other linked tables reside in another database file. This prevents Jet from constantly deleting, creating, and obtaining lock information on the .ldb file. One customer’s scenario was improved from three minutes to thirty seconds by employing this technique.</p>
<h3>Use Explicit Transactions When Implementing Online-Transaction Processing (OLTP)</h3>
<p>
Due to the changes in Jet 3.5 regarding the FlushTransactionTimeout registry setting, it is possible to see significant throughput decreases due to concurrency issues when OLTP is being implemented from many workstations. The reason for this is that Jet 3.5 will cache modified pages until no activity is encountered or the cache is full. Thus the fast throughput of OLTP statements will cause Jet to not flush its cache and release the locks on index and data pages. This may cause many pages to be locked during this time period, which will cause concurrency issues with many users trying to update one row at a time on the same table. The workaround is to use explicit transactions for these scenarios to force Jet to flush its cache when the transaction is committed. Below is an extreme example of throughput degradation when not using an explicit transaction for OLTP type work to quickly update one random row at a time from six workstations.</p>
<p>
<img src="jet35_15.gif" border=0></p>
<p>
While this illustrates why you should use explicit transactions for this type of operation, it also illustrates, again, the cost of updating an indexed column in regards to how many rows of indexed columns are locked.</p>
<h3>Check Parameterized Queries for Optimal Performance</h3>
<p>
Parameterized queries can only be implemented by using a stored query. Since stored queries have a precompiled query plan, parameterized queries that contain parameters on indexed columns may not execute efficiently. Since the query engine does not know the values to be passed in a parameter in advance, it can only guess as to the most efficient query plan. Based on customer performance scenarios that we have examined, we have discovered that in some instances substantial performance gains can be achieved by replacing a stored parameterized query with a temporary query. This means creating the SQL string in code and passing it to the DAO <b>OpenRecordset </b>or <b>Execute</b> methods of the <b>Database</b> object.</p>
<h2>Unsupported Tuning Features</h2>
<p>
The information below has been available, but not thoroughly documented, since Jet 3.0. Microsoft will not support this information and the sole intention of documenting it here is to have a valid measurement to experiment with the ideas in this white paper. Much of the information is excerpted from the <i>Microsoft Jet Database Engine Programmer’s Guide</i> (available from Microsoft Press). These features were implemented primarily for use by the Jet performance team as a way to better measure and improve Jet performance, thus the availability or similar functionality of these features in future releases of Jet is not guaranteed.</p>
<h3>The ISAMStats Function</h3>
<p>
The DAO object model exposes a function that allows the developer to get information about the raw disk reads, writes, locks, and caching. The graphs in this white paper used these functions. The following syntax is used for the ISAMStats function:</p>
<pre><code>ISAMStats(StatNum as Long[, Reset as Boolean]) as Long
</code></pre>
<p>
This method returns the value of a given engine statistic as defined by StatNum, which is defined in the following table. If the optional Reset argument is supplied, then the statistic defined by StatNum is reset and no value is returned. A Reset argument value of <b>False</b> is equivalent to not supplying the argument. The statistics returned apply to the whole engine, regardless of how many databases or sessions are active, including temporary databases.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=28%><b>StatNum</b></td>
<td class=label width=72%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=28%>0</td>
<td width=72%>Number of disk reads.</td>
</tr>
<tr valign=top>
<td width=28%>1</td>
<td width=72%>Number of disk writes.</td>
</tr>
<tr valign=top>
<td width=28%>2</td>
<td width=72%>Number of reads from cache.</td>
</tr>
<tr valign=top>
<td width=28%>3</td>
<td width=72%>Number of reads from read-ahead cache.</td>
</tr>
<tr valign=top>
<td width=28%>4</td>
<td width=72%>Number of locks placed.</td>
</tr>
<tr valign=top>
<td width=28%>5</td>
<td width=72%>Number of release lock calls.</td>
</tr>
</table><br>
<p>
The following code illustrates a sample use of the <b>ISAMStats</b> function:</p>
<pre><code>Sub Main()
 &nbsp;&nbsp; Dim dbs As Database, ws As Workspace
 &nbsp;&nbsp; Dim strSQL As String
 &nbsp;&nbsp; Dim lngDiskRead As Long, lngDiskWrite As Long, _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lngCacheRead As Long, _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lngCacheReadAheadCache As Long, _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lngLocksPlaced As Long, _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lngLocksReleased As Long
 &nbsp;&nbsp; ' Explicitly set the counters to zero.
 &nbsp;&nbsp; lngDiskRead = DBEngine.ISAMStats(0, True)
 &nbsp;&nbsp; lngDiskWrite = DBEngine.ISAMStats(1, True)
 &nbsp;&nbsp; lngCacheRead = DBEngine.ISAMStats(2, True)
 &nbsp;&nbsp; lngCacheReadAheadCache = DBEngine.ISAMStats(3, True)
 &nbsp;&nbsp; lngLocksPlaced = DBEngine.ISAMStats(4, True)
 &nbsp;&nbsp; lngLocksReleased = DBEngine.ISAMStats(5, True)
 &nbsp;&nbsp; Set dbs = OpenDatabase("northwind.mdb", False, False)
 &nbsp;&nbsp; Set ws = Workspaces(0)
 &nbsp;&nbsp; strSQL = _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "UPDATE Customers SET ContactName = ContactName"
 &nbsp;&nbsp; dbs.Execute strSQL, dbFailOnError
 &nbsp;&nbsp; 
 &nbsp;&nbsp; ' The null transaction ensures no more asynchronous
 &nbsp;&nbsp; ' activity that could yield inaccurate statistics.
 &nbsp;&nbsp; ws.BeginTrans
 &nbsp;&nbsp; ws.CommitTrans
 &nbsp;&nbsp; 
 &nbsp;&nbsp; ' The following ISAMStats calls will retrieve the latest
 &nbsp;&nbsp; ' values. The values will accumulate until they
 &nbsp;&nbsp; ' are reset.
 &nbsp;&nbsp; lngDiskRead = DBEngine.ISAMStats(0)
 &nbsp;&nbsp; lngDiskWrite = DBEngine.ISAMStats(1)
 &nbsp;&nbsp; lngCacheRead = DBEngine.ISAMStats(2)
 &nbsp;&nbsp; lngCacheReadAheadCache = DBEngine.ISAMStats(3)
 &nbsp;&nbsp; lngLocksPlaced = DBEngine.ISAMStats(4)
 &nbsp;&nbsp; lngLocksReleased = DBEngine.ISAMStats(5)
 &nbsp;&nbsp; Debug.Print "Disk reads " &amp; lngDiskRead
 &nbsp;&nbsp; Debug.Print "Disk writes " &amp; lngDiskWrite
 &nbsp;&nbsp; Debug.Print "Cache reads " &amp; lngCacheRead
 &nbsp;&nbsp; Debug.Print "Cache reads from RA cache " &amp; lngCacheReadAheadCache
 &nbsp;&nbsp; Debug.Print "Locks placed " &amp; lngLocksPlaced
 &nbsp;&nbsp; Debug.Print "Locks released " &amp; lngLocksReleased
End Sub
</code></pre>
<h2>Notes</h2>
<p>
The number of disk reads and writes include all reads and writes in all circumstances, including background read-ahead in separate threads. One read or write doesn’t necessarily equal one page: one read or write could represent many pages that were read or written simultaneously. An example of this is commands wrapped in a transaction. This is why it is important to issue a null transaction to ensure accurate statistics. A null transaction is defined as issuing the <b>CommitTrans</b> and <b>BeginTrans</b> methods with no commands in between the two statements.</p>
<p>
There are two types of cached reads returned. The CacheRead statistic reflects pages that are read from previously modified pages that still remain in the cache and have not been modified in the physical database by other users. The read-ahead cache statistic shows reads that occurred when Jet anticipates that a sequential read activity is about to occur. This is done to reduce reads to disk.</p>
<p>
The number of locks placed and released may not be balanced. A single call to release a lock may result in the release of many locks.</p>
<p>
Using these statistics in conjunction with the <b>SetOption</b> method can allow the developer to instantly see results that may produce timing differences on a LAN that may not be apparent from running on a local machine. This is why many of the graphs above show I/O instead of timings as it more accurately represents what is occurring.</p>
<h3>The ShowPlan Function</h3>
<p>
The Microsoft Jet query engine implements a cost-based query optimizer. When a query is compiled, the query engine creates a query plan. This plan is used internally to find the quickest way to execute a query. Using the ShowPlan key in the registry will cause Jet to create a text file containing the query execution plans.</p>
<p>
The ShowPlan function was available in Jet 3.0 by adding the following key to the registry:</p>
<pre><code>WARE\MICROSOFT\JET\3.0\Engines\Debug
</code></pre>
<p>
Under this key, add a string data type called JETSHOWPLAN (make sure to use all capital letters). To turn on ShowPlan, set the value to ON. To turn it off, set the value to OFF.</p>
<p>
When ShowPlan is turned on, Jet appends text to a file called SHOWPLAN.OUT every time a query is compiled. You must modify or compact the database in order to have a stored query show its query plan. It is also important to note that SHOWPLAN.OUT appends new data for every new query plan. Leaving ShowPlan on could result in an extremely large SHOWPLAN.OUT file.</p>
<p>
Jet 3.5 includes enhancements and bug fixes to ShowPlan. For example, you can now determine the inputs to the query. This is very useful in determining the uniqueness of an index; thus determining how useful that index is in retrieving the overall result set and what affect it may have on concurrency. Since Jet 3.5 utilizes a different registry key structure, the physical location of ShowPlan has changed. To activate ShowPlan for Jet 3.5 you must use this key location:</p>
<pre><code>WARE\MICROSOFT\JET\3.5\Engines\Debug
</code></pre>
<p>
Below is a sample output generated by running the Invoices query. This query comes with the Northwind database in Microsoft Access 97.</p>
<pre><code>---------------------------------------------
DATE: 01/19/97
VER:&nbsp; 3.50.3428
NOTE: Currently does not handle subqueries, vt [virtual table] parameters, and subqueries.
NOTE: You may see ERROR messages in these cases.
--- Invoices ---
- Inputs to Query -
Table 'Orders'
Table 'Order Details'
 &nbsp;&nbsp; Using index 'OrdersOrder Details'
 &nbsp;&nbsp; Having Indexes:
 &nbsp;&nbsp; OrdersOrder Details 2155 entries, 8 pages, 830 values
 &nbsp;&nbsp;&nbsp;&nbsp; which has 1 column, fixed
 &nbsp;&nbsp; OrderID 2155 entries, 8 pages, 830 values
 &nbsp;&nbsp;&nbsp;&nbsp; which has 1 column, fixed
Table 'Customers'
 &nbsp;&nbsp; Using index 'PrimaryKey'
 &nbsp;&nbsp; Having Indexes:
 &nbsp;&nbsp; PrimaryKey 91 entries, 1 page, 91 values
 &nbsp;&nbsp;&nbsp;&nbsp; which has 1 column, fixed, unique, primary-key, no-nulls
 &nbsp;&nbsp; PostalCode 91 entries, 1 page, 87 values
 &nbsp;&nbsp;&nbsp;&nbsp; which has 1 column, fixed
 &nbsp;&nbsp; CompanyName 91 entries, 3 pages, 91 values
 &nbsp;&nbsp;&nbsp;&nbsp; which has 1 column, fixed
 &nbsp;&nbsp; City 91 entries, 1 page, 69 values
 &nbsp;&nbsp;&nbsp;&nbsp; which has 1 column, fixed
Table 'Employees'
Table 'Products'
Table 'Shippers'
- End inputs to Query -
01) Sort table 'Orders'
02) Inner Join table 'Shippers' to result of '01)'
 &nbsp;&nbsp;&nbsp;&nbsp; using temporary index
 &nbsp;&nbsp;&nbsp;&nbsp; join expression "Shippers.ShipperID=Orders.ShipVia"
03) Sort table 'Employees'
04) Inner Join result of '02)' to result of '03)'
 &nbsp;&nbsp;&nbsp;&nbsp; using temporary index
 &nbsp;&nbsp;&nbsp;&nbsp; join expression "Orders.EmployeeID=Employees.EmployeeID"
05) Inner Join result of '04)' to table 'Customers'
 &nbsp;&nbsp;&nbsp;&nbsp; using index 'Customers!PrimaryKey'
 &nbsp;&nbsp;&nbsp;&nbsp; join expression "Orders.CustomerID=Customers.CustomerID"
06) Inner Join result of '05)' to table 'Order Details'
 &nbsp;&nbsp;&nbsp;&nbsp; using index 'Order Details!OrdersOrder Details'
 &nbsp;&nbsp;&nbsp;&nbsp; join expression "Orders.OrderID=[Order Details].OrderID"
07) Sort table 'Products'
08) Inner Join result of '06)' to result of '07)'
 &nbsp;&nbsp;&nbsp;&nbsp; using temporary index
 &nbsp;&nbsp;&nbsp;&nbsp; join expression "[Order Details].ProductID=Products.ProductID"
--- temp query ---
- Inputs to Query -
Table 'Customers'
 &nbsp;&nbsp; Using index 'CompanyName'
 &nbsp;&nbsp; Having Indexes:
 &nbsp;&nbsp; CompanyName 91 entries, 3 pages, 91 values
 &nbsp;&nbsp;&nbsp;&nbsp; which has 1 column, fixed
 &nbsp;&nbsp; City 91 entries, 1 page, 69 values
 &nbsp;&nbsp;&nbsp;&nbsp; which has 1 column, fixed
- End inputs to Query -
01) Scan table 'Customers'
 &nbsp;&nbsp; Using index 'CompanyName'
--- temp query ---
- Inputs to Query -
Table 'Products'
 &nbsp;&nbsp; Using index 'ProductName'
 &nbsp;&nbsp; Having Indexes:
 &nbsp;&nbsp; ProductName 77 entries, 1 page, 77 values
 &nbsp;&nbsp;&nbsp;&nbsp; which has 1 column, fixed
 &nbsp;&nbsp; PrimaryKey 77 entries, 1 page, 77 values
 &nbsp;&nbsp;&nbsp;&nbsp; which has 1 column, fixed, unique, clustered and/or counter, primary-key, no-nulls
 &nbsp;&nbsp; CategoryID 77 entries, 1 page, 8 values
 &nbsp;&nbsp;&nbsp;&nbsp; which has 1 column, fixed
 &nbsp;&nbsp; CategoriesProducts 77 entries, 1 page, 8 values
 &nbsp;&nbsp;&nbsp;&nbsp; which has 1 column, fixed
- End inputs to Query -
01) Scan table 'Products'
 &nbsp;&nbsp; Using index 'ProductName'
</code></pre>
<h2>Conclusion</h2>
<p>
The Jet team takes performance very seriously and has had a dedicated team for performance since Jet 3.0. However, even with our 1,500 plus performance tests, we cannot encounter all the scenarios that our customers put Jet through. If you believe that you have encountered a performance issue with Jet, please contact Microsoft support with a precise reproducible scenario. They will forward this information to the Jet performance team and we will examine it and try to come up with workarounds or attempt to correct the issue in the next release of Jet. </p>
<p>
Another method of letting the Jet team know about features or performance requests specific to the Jet database engine is to send us e-mail at JetWish@Microsoft.com. </p>
<p>
If this paper interests you, I would highly recommend purchasing the <i>Microsoft Jet Database Engine Programmer’s Guide</i> from Microsoft Press. While it does not address Jet 3.5 (a revised release is currently being planned), it does have pertinent information on understanding how Jet works and the best ways to use Jet.</p>
</BODY>
</HTML>
