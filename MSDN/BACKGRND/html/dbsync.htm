<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Remote Database Synchronization with Microsoft Office and Microsoft BackOffice</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1>Remote Database Synchronization with Microsoft Office and Microsoft BackOffice </h1>
<p>
April 1995</p>
<p>
<i>Moss Micro has been building custom software applications since 1987. The primary development thrust has been in support of the Microsoft suite of applications and tools such as Visual Basic, Word, Excel, Access, and SQL Server. Other database products on Windows NT and UNIX, such as Sybase and Oracle, are supported along with a variety of front-end products and programming languages. The fast-growing staff of Moss Micro, now numbering 27, represents over 85 years of software development experience. You can contact Moss Micro at 31952 Camino Capistrano, Suite C22, San Juan Capistrano, CA 92675. Phone: (714)&nbsp;248-1701, Fax: (714) 248-0203.</i></p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Backgrounders Samples">
<PARAM name="Item2" value="4164">
</OBJECT><a href="javascript:sample1.Click()">Click here to open or copy the files in the DBSync sample application for this technical article.</a></p>
<h2>Abstract</h2>
<p>
This paper is a discussion of a solution to synchronize remote databases using Microsoft® Access®, Microsoft SQL Server, ODBC, and Microsoft Mail.</p>
<h2>Overview</h2>
<p>
Sharing data using database applications among multiple users typically requires that the users all be connected to the same data source. In some situations, however, the multiple users (clients) need to have their own copy or "slice" of the data on a remote PC, or are in some other way unable to connect to the main (server) data source because of practical or performance reasons.</p>
<p>
For example, a large sales force that is mostly mobile logs a great deal of information about their daily customer visits, changes in a customer's demographic information, additions or deletions to contact information, and so on. However, because these users are remote, these changes are recorded only on their personal machines, not in the master database. This information from the field could be useful to the corporate office, to enhance customer service, track customer activity, and so on. <i>Synchronization</i> would allow remote users the performance and freedom benefit of a stand-alone system, while providing the corporate office with reliable, synchronized data on each of its customers.</p>
<p>
This paper (and accompanying sample application files) presents a solution to this problem, using Microsoft® Access® 2.0 as the remote client.</p>
<h2>Development Considerations</h2>
<p>
The final solution, "DBSync Contact Manager," was built in about two weeks, within the following parameters:
<ul type=disc>
<li>
Because the remote data source (client) and main data source (server) would be different types of database management systems, a common application programming interface (API), ODBC, was selected as a programming interface for the bulk of the synchronization process.<br><br></li>
<li>
The users of the system should not be required to "operate" the synchronization process—it should be nearly unnoticeable to the user. (An overview of the user interface will follow.)<br><br></li>
<li>
The administrator of the system should not be required to "operate" the process, either; the DBSync system should handle its own confirmation and application of data changes.<br><br></li>
<li>
Users need to "connect" to the server transparently, without any additional effort (or training), preferably during the course of their daily activities (for instance, while using Microsoft Mail).<br><br></li>
<li>
The connection to the server should be secure; in other words, the network must be inaccessible to the user (through remote access service [RAS] or other some other remote protocol).<br><br></li>
<li>
The amount of actual time connected should be kept to a minimum—a user should connect, send the new data, and disconnect. (Remote Mail lends itself to this rather well.)<br><br></li>
<li>
Changes made by "related" users—those users sharing responsibility on a customer—users' managers, and SQL Server users should be part of the synchronization process as well.</li>
</ul>
<h2>The DBSync Contact Manager User Interface</h2>
<h3>General Feature Outline</h3>
<p>
The DBSync Contact Manager application is intended primarily as a guide and example of the type of problems that can be solved using the Microsoft Office/BackOffice/Language tools. A brief tour of the "features" of the application may help you understand the scope and purpose of some of the development.
<ul type=disc>
<li>
The application is centered around "Customers" and "Users." Users interact with and (we hope) sell to Customers.<br><br></li>
<li>
More than one User may "work" on a single Customer. The relationship between the two is defined by the table "UsersCustomers." In order to "own" a Customer, a User needs only to have an entry in the UsersCustomers table.<br><br></li>
<li>
Users interact with Customers through "Contacts" and they record their daily activities and communications with each Customer through "Notes." A Customer can have many Contacts and Notes. (See also the "Administrative Tools" section.)<br><br></li>
<li>
The user interface lets Users work with Customers as a group or individually. The User can select a single customer, (All) Customers, or (All) User's Customers.<p>
<img src="dbsync_1.gif" border=0></P></li>
<li>
Each User may have one or more other related Users in their database. (See also the "Administrative Tools" section.)<br><br></li>
<li>
Major areas of functionality are divided into four "Tabs" or pages of the Main form: Customers, Contacts, Notes, and Sales.<p>
</P></li>
<li>
By selecting different pages of the form you can see All Customers, All Contacts, or All Contacts for a Customer, or All Notes for a Customer, and so on.<p>
<img src="dbsync_3.gif" border=0></P></li>
<li>
Users correspond (by letter, fax, and so on) with Contacts. Using OLE automation and Microsoft Word for Windows®, the application provides a way to send "automatic" letters and fax cover sheets to a specific Contact or all the Contacts in the datasheet.<p>
<img src="dbsync_4.gif" border=0></P></li>
<li>
When a letter is sent to a single Contact, a Note is added to the Notes table and the name of the file is stored with the Note. The file may be retrieved later (using OLE automation) for review (provided that the file still exists—this is sort of a "poor person’s document manager").<p>
<img src="dbsync_5.gif" border=0></P></li>
<li>
Notes can be entered automatically, by sending a letter or by adding them directly to the datasheet.<br><br></li>
<li>
Additionally, the User may choose to "schedule" the Note (a meeting or phone call, for instance) by using Microsoft Schedule+. (Schedule+ must be running. Also, this feature is only available under Windows for Workgroups.) DBSync Contact Manager schedules a one-hour appointment into the current user's calendar, starting at the time specified by the Note Date.<br><br></li>
<li>
Finally, Customers buy things—or at least, the good ones do—and most Users want to see the sales numbers.<p>
<img src="dbsync_6.gif" border=0></P></li>
<li>
Using OLE Automation and Microsoft Excel, a User can further analyze these sales numbers, with charts and pivot tables.</li>
</ul>
<h4>Microsoft SQL Server (BackOffice)</h4>
<ul type=disc>
<li>
Using ODBC and Access, the data source can be changed from a remote (Access) "slice" of the database to a total corporate picture of the data. This way many local users can have benefit of the information while their changes are reflected and distributed to the remote users.<br><br></li>
<li>
The application automatically handles establishing a secure connection with the SQL server, thus opening up the application to a potentially much larger group of online users. (See the <b>UpdateAttachments()</b> function in the Main module for code examples.)</li>
</ul>
<h4>Administrative Tools</h4>
<ul type=disc>
<li>
After the database is created, each remote user needs his or her "slice" of the data. The "make database" process copies the appropriate data from SQL server into new databases to be sent to each user.<p>
<img src="dbsync_7.gif" border=0></P></li>
</ul>
<h4>Distribution of the Transactions</h4>
<ul type=disc>
<li>
Once a day, the outstanding transactions (changes) are sent to the Users affected by the change. This includes any "team" Users, managers of the Users, and others. A simple form is opened; this form creates and maintains a timer that fires a distribution process once a day.<p>
<img src="dbsync_8.gif" border=0></P></li>
<li>
This process also handles the sending of confirmation messages back to remote users who have "synchronized" their data.</li>
</ul>
<h3>Software Components</h3>
<p>
With the above considerations in mind, the following components were selected:
<ul type=disc>
<li>
<b>Client</b> <b>software:</b>  Microsoft Office, primarily Microsoft Access 2.0 (both local and remote users)&nbsp; <br><br></li>
<li>
<b>Transport:</b>  Microsoft Mail Remote (remote users) using Custom Messages sent via the simple MAPI interface.<br><br></li>
<li>
<b>Server:</b>  Microsoft SQL Server, Microsoft Mail 3.<i>x</i> (as the process "administrator")<br><br></li>
<li>
<b>Languages:</b>  Microsoft Visual C++™ version 1.51 (and 2.0 for the 32-bit applications)</li>
</ul>
<h3>Synchronization Implementation Details</h3>
<h4>Introduction</h4>
<p>
As each change is made to the database (in Microsoft Access 2.0), a "transaction" is recorded with the changes. Each transaction records the time, user identification, and type of change. At the end of a "session," (user's interaction with the database) or a menu command, the outstanding "transactions" are packaged into a file and sent (e-mailed) to the SQL Server counterpart. These files are then stored on the local machine until a confirmation is received from the server. The confirmation message is sent (via Microsoft Mail) and the file is deleted from the user's machine. If outstanding files are still on the local machine when a new file is sent, the outstanding (unconfirmed) file is sent first.</p>
<p>
On the server side, a single mail client receives the messages. When the message is received the file is "unpacked," and the transactions are applied to the server. Each successfully applied transaction is stored for future distribution to related users. When the changes have been successfully applied, a "log" entry is made in the database to prevent the reapplication of the same changes. </p>
<p>
Next, at a regular interval, confirmation messages are sent to users and the "applied" log entry is deleted. If the confirmation fails, the file is sent again from the remote user and the entire process starts again.</p>
<p>
The applied changes (transactions) are stored in another table for distribution to other remote users (managers, related users, and so on). Once a day, the transactions are ordered by date and distributed to the related users. When these changes are received (as part of the connection to Mail) they are applied to the client's database. The client sends a similar confirmation message to the server, removing the server's local copy of the transaction file.</p>
<h4>Transaction logging details</h4>
<p>
There are three types of changes that can be made to data in a database: INSERT (or add), UPDATE (or change), and DELETE. Microsoft Access fires a form level "event" for each of these changes. As each event occurs, the key information is stored in an attached table.
<ul type=disc>
<li>
For INSERT changes, only the Primary key columns and values are stored in the transaction table. <br><br></li>
<li>
For UPDATE changes, the updated columns are also queried and stored to minimize the chance of overwritten rows when data is shared between many users.<br><br></li>
<li>
For DELETE changes, Access actually sends two messages: one saying that the row has been deleted, and one that either confirms or cancels the delete. The DBSync code logs the transaction as if it were deleted, then marks it as "confirmed" if the delete is confirmed, or deletes the transaction(s) if the event was canceled by the user.</li>
</ul>
<p>
Additionally, the current user (by number) and the CustomerID are also stored for each transaction. This allows the DBSync process to avoid sending the same change back to the user who made the change, and helps build the related user list when distributing the transactions.</p>
<p>
On every form that is involved in the DBSync process, you will need to store a form level variable of type DBSYNC_INFO and handle the following events: <i>Form_BeforeUpdate(), Form_AfterUpdate(), Form_Delete(), Form_AfterDelConfirm(), </i>and <i>Form_AfterInsert()</i>. For each of these events you will call <b>dbx_OnRowChange()</b> with a reference to the form (caller) and reference to the DBSYNC_INFO structure.</p>
<p>
Almost all of the transaction events happen from a form, but the DBSync code also provides a programmatic method of logging a transaction. For example (from the Customers_datasheet form):</p>
<pre><code>Sub Form_AfterInsert ()
 &nbsp;&nbsp; On Error GoTo Form_AfterInsert_Error
 &nbsp;&nbsp; 
 &nbsp;&nbsp; Dim rs As Recordset
 &nbsp;&nbsp; Dim sSql As String

 &nbsp;&nbsp; 'log the customer table change

<b> &nbsp;&nbsp; dbxInfo.nStatus = DBSYNC_INSERT</b>

<b> &nbsp;&nbsp; dbx_OnRowChange Me, dbxInfo</b>


 &nbsp;&nbsp; 'Now add a related row into the UsersCustomers table so that
 &nbsp;&nbsp; 'this customer will show up in this user's list.
 &nbsp;&nbsp; Set rs = db.OpenRecordset("UsersCustomers", DB_OPEN_DYNASET, DB_APPENDONLY)
 &nbsp;&nbsp; 
 &nbsp;&nbsp; rs.AddNew
 &nbsp;&nbsp; rs("UserID") = tGlob.lUserID
 &nbsp;&nbsp; rs("CustomerID") = Me.CustomerID
 &nbsp;&nbsp; rs.Update

 &nbsp;&nbsp; rs.FindFirst "UserID = " &amp; CStr(tGlob.lUserID) &amp; " and CustomerID = " &amp; CStr(Me.CustomerID)
 &nbsp;&nbsp; If (Not (rs.NoMatch)) Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>dbx_LogTransaction rs, DBSYNC_INSERT</b> &nbsp;&nbsp; 'Log the transaction.
 &nbsp;&nbsp; Else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DoMessageBox IDS_E_ADDUSERCUSTOMER
 &nbsp;&nbsp; End If
 &nbsp;&nbsp; 
Form_AfterInsert_Exit:
 &nbsp;&nbsp; If (Not (rs Is Nothing)) Then rs.Close
 &nbsp;&nbsp; Set rs = Nothing

 &nbsp;&nbsp; Exit Sub
Form_AfterInsert_Error:
 &nbsp;&nbsp; GenericError "Customers_datasheet: Form_AfterInsert()", Err
 &nbsp;&nbsp; Exit Sub
End Sub
</code></pre>
<h4>Transaction SQL statements</h4>
<p>
After all the changes have been logged (for the session, or day, or whatever) call <b>dbx_SetTransTableSQL()</b> to prepare the transactions for the synchronization process. In practical terms, this means walking back through the Primary Key names and values for each transaction and building an ODBC-runnable SQL statement that reflects the changes.</p>
<p>
In some cases, the row that the SQL statement is being built from will be unavailable. For instance, DELETE changes are simply written to the transaction table without looking for the (deleted) row. Also, because each transaction is logged as it happens, a row may be unavailable because it was first INSERTED, then UPDATED, then DELETED. In this case, the transaction is not sent.</p>
<h4>Referential integrity</h4>
<p>
A transaction is recorded for the <b>primary</b> table in the affected record set only. (This is determined by the dbsyncid column in the record set). Because each transaction is recorded against only this one table at a time, it is essential that the SQL server provide the exact functionality of the Jet engine—mainly referential integrity triggers and cascading updates and deletes.</p>
<p>
There has been no attempt to "reproduce" the engine level functionality in the DBSync implementation. Instead, the Microsoft Upsizing Wizard was used to make a "duplicate" of the affected database. (See the DBSYNC.SQL script and/or the resulting database for details.)</p>
<h4>Handling the INSERTs</h4>
<p>
In a remote system such as this, it becomes important that each user have his or her own "range" of new row identifiers (or PrimaryKey values). Typically, an Access "counter" column is used, but in this case, the chance for duplicates is certain. The solution is to give each user a "range" of new IDs, based on his or her user ID. In the DBSync Contact Manager, a function called <b>GetNewID()</b> is used to give each user a range of 1 million new IDs in any one table. (Note that this limits the number of users to about 2,000.)</p>
<p>
Before each insert event, <b>GetNewID()</b> is called and the return value is assigned to the appropriate column. For example (from the Customers_datasheet form):</p>
<pre><code>Sub Form_BeforeUpdate (Cancel As Integer)
 &nbsp;&nbsp; Me.DateModified = Now
 &nbsp;&nbsp; If (IsNull(Me.CustomerID)) Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Me.CustomerID = <b>GetNewID</b>(ID_TABLE_CUSTOMERS, "CustomerID")
 &nbsp;&nbsp; End If
 &nbsp;&nbsp; dbxInfo.nStatus = DBSYNC_BEFORE_UPDATE
 &nbsp;&nbsp; dbx_OnRowChange Me, dbxInfo
End Sub
</code></pre>
<h3>Microsoft Mail</h3>
<h4>Custom messages</h4>
<p>
A <i>custom message</i> is a special class or type of message you can create to exchange information between Mail recipients or Mail-aware applications. The DBSYNC.DLL processes three types of custom messages: <i>DBSync, DBSyncToCorp</i>, and<i> DBSyncConfirm</i>. When a message of any one of these types arrives in the in-box, Mail calls a single function in DBSYNC.DLL, <b>Command()</b>.</p>
<p>
After the <b>Command()</b> function is called, DBSYNC.DLL establishes a session with Mail (by logging on), reads the custom message, saves the attached file, and, using ODBC, applies the SQL statements from the file to the appropriate data source. (For details, see the DBSYNC.DLL source files.) If the file is processed without error, the message is deleted, with no user intervention. If the message is a DBSyncConfirm (or confirmation message) the message body contains a file name (prefaced by a user ID if it is sent by a remote user). When the message is processed, DBSYNC.DLL looks in the DBSYNC.INI file for the path to the local storage of .DBX (transaction) files. If the file exists, it is deleted. This prevents the file from being sent an additional time.</p>
<p>
The custom message types need to be registered in the remote user's MSMAIL.INI file, as shown in the following code example. (Setup will create these settings; see the SETUP.TXT for details.)</p>
<pre><code>IPM.DBSync.DBSync=3.0;;;;&lt;system&gt;dbsync.dll;;2122222100000000;;;;
IPM.DBSync.DBSyncToCorp=3.0;;;;&lt;system&gt;dbsync.dll;;2122222100000000;;;;
IPM.DBSync.DBSyncConfirm=3.0;;;;&lt;system&gt;dbsync.dll;;2122222100000000;;;;
</code></pre>
<p>
Strictly speaking, only two of these settings are required, depending on what type of database you are using. For remote users, only the first and third are required. For an SQL Server Mail client (there should only be one), only the second and third lines are required. In a production environment, you should avoid the second message declaration on the remote users' machines.</p>
<p>
The series of numbers (16) indicates when the custom .DLL is to be called. In most cases, the 8th position, which represents a delivery operation (a message of this class has arrived in the in-box) is all that will be acted upon by the DBSync process. However, in case of unexpected failure, the second position, which represents an open operation (a user double-clicks on the message) also causes Mail to call the custom .DLL and process the message. This can be useful if you are testing the process.</p>
<p>
For more information, you may want to read the Microsoft Mail technical reference.</p>
</BODY>
</HTML>
