<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Understanding Microsoft Jet Locking</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_jetlock"></a>Understanding Microsoft Jet Locking </h1>
<p>
Kevin Collins<br>
Microsoft Jet Program Management</p>
<p>
November 21, 1995</p>
<p>
<OBJECT id=sample1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
	width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Backgrounders Samples">
<PARAM name="Item2" value="4890">
</OBJECT><a href="javascript:sample1.Click()">Click to open or copy the utilities discussed in this technical article.</a></p>
<h2>Abstract</h2>
<p>
The purpose of this paper is to introduce you to Microsoft® Jet version 2<i>.x</i> and Microsoft Jet version 3.0 locking techniques so that you can apply the information to coding and debugging when developing multiuser applications. This paper addresses the following concepts:
<ul type=disc>
<li>
Layout of the .LDB file<br><br></li>
<li>
Database header page<br><br></li>
<li>
Types of Microsoft Jet locks<br><br></li>
<li>
Deciphering Microsoft Jet locks</li>
</ul>
<h2>Layout of the .LDB File</h2>
<p>
The .LDB file plays an important role in the Microsoft® Jet multiuser scheme. This file stores the computer and security names and has extended byte range locks placed on it by Microsoft Jet.</p>
<p>
Microsoft Jet retrieves the computer name by making a request to the operating system. To modify the computer name in Microsoft Windows® for Workgroups, Microsoft Windows 95, or Microsoft Windows NT®, simply go to the Control Panel and choose the Network icon. From there, you can change the computer name. Windows for Workgroups stores the computer name in the SYSTEM.INI file, whereas Windows 95 and Windows NT store the computer name in the Windows Registry. The security name is determined by passing a value to the <b>Workspace</b> object in Data Access Object (DAO). The default security name is Admin.</p>
<p>
Extended byte range locks are locks placed outside the physical boundaries of a file—no data is ever physically locked. For example, you can place a lock at 10 million hex for a file that has a physical size of only 64 bytes. In other words, a lock is <i>virtually</i> placed at a location that does not exist on the hard disk. This type of locking is used because extended byte range locks are not limited by the size of the physical file, allowing for locking algorithms that would not otherwise be possible. Also, placing locks inside a data file would prevent other users from reading that data. In the early Borland® dBASE® days, a user could place a lock on a row located in the data file that prevented anyone from reading that data: when printing a report, for example.</p>
<p>
One .LDB file is always created for each Microsoft Jet database file that is connected in a shared mode. The .LDB file always retains the same name as the database that was opened (for example, NWIND.MDB always has a NWIND.LDB), and the .LDB file is always in the same directory as the database. If an .LDB file does not exist and the database is connected in a shared mode, an .LDB file is created. The physical structure of the .LDB file is best thought of as a one-dimensional array. Each element in the array, up to 255, consists of 64 bytes. The first 32 bytes contain the computer name (such as KevinCol), and the second 32 bytes contain the security name (such as Admin). This data is then used to provide information regarding which other users are holding locks. You can view this information by simply looking at the contents of the .LDB file.</p>
<p>
The physical size of the .LDB file never exceeds 16,320 bytes, because the maximum number of concurrent users in a Microsoft Jet database is 255 (255 * 64 = 16,320).</p>
<p>
The high-order ASCII characters seen in Microsoft Jet 2<i>.x</i> .LDB files are meaningless to both the viewer and to Microsoft Jet. Microsoft Jet 3.0 eliminates the high-order ASCII characters from the .LDB file so that only the computer and security names are shown.</p>
<p>
Microsoft Jet 3.0 automatically deletes the .LDB file when the last user closes the database. This is done to aid in issues with replicated databases and to allow for performance improvements when determining which other users have locks. The exception to this is when a user does not have networked operating system or operating system (NOS/OS) delete rights to the .LDB file or if the database is in a suspect state. There is no performance or concurrency benefit gained from deleting your .LDB file in a Microsoft Jet 2.<i>x </i>environment.</p>
<p>
A 32-bit utility (LDBView), which is included with this article, enables you to view the status of the commit byte(s) (commit bytes are described in the next section) and what users are currently logged onto the database. This utility helps you determine which user(s) left the database in a suspect state.</p>
<p>
Another utility (MSLDBUSR.DLL), which is included with this article, now enables you to programmatically retrieve the following information if you're running 32-bit Microsoft Visual Basic® for Applications (VBA) applications:
<ul type=disc>
<li>
A list of all users in an .LDB file<br><br></li>
<li>
A list of all connected users in an .LDB file<br><br></li>
<li>
A list of users that left a database in a suspected state</li>
</ul>
<p>
You can find out how to use this dynamic-link library (DLL) at the end of this paper.</p>
<h2>Database Header Page</h2>
<p>
The database header page (DBH) is the first page in a database. It is partially used to store the commit byte(s) for each of the 256 possible users connected to a database. A commit byte (or pair of bytes in version 3.0) is a value that is used by Microsoft Jet to determine the state of the database.</p>
<p>
Microsoft Jet 2<i>.x</i> utilizes 256 bytes that store the commit bytes for each possible user starting at 700 hex and continuing to the end of the page (800 hex). Microsoft Jet 3.0 utilizes 512 bytes that use two bytes per user starting at 600 hex. The first byte (Microsoft Jet 2<i>.x</i>) or the first two bytes (Microsoft Jet 3.0) are used only when a database is connected in an exclusive mode and the remaining 255 bytes (Microsoft Jet 2<i>.x</i>) or 510 bytes (Microsoft Jet 3.0) are used when the database is connected in a shared mode.</p>
<p>
Commit bytes in Microsoft Jet 2.0 have only two valid values, FF and 00. A value of 00 represents a neutral state and a value of FF means that Microsoft Jet is in the process of physically writing data to disk. If there is a value of FF and no corresponding user lock, then a user has had an abnormal shutdown of the database file. New users attempting to connect to the database receive the message "Database is corrupted or is not a database file," and they will be forced to run repair on the database to open it. An anomaly in Microsoft Jet 2.0 allowed instances where the database could be closed with a value of FF, thus preventing other users from connecting to the database until repair could be run. This was corrected in Microsoft Jet version 2.5.</p>
<p>
Commit bytes in Microsoft Jet 2.5 have five valid values ranging from 00 to 04. This range of values provides more information on what users were doing when the database is left in a suspect state. Similar to Microsoft Jet 2.0, the database is in a suspect state if there is a nonzero value without a corresponding user lock. A value of 00 represents a neutral state. A value of 01 indicates that a user accessed a corrupted page in the database. A value of 02 indicates that the database is being created. A value of 03 indicates that the database is being repaired, and a value of 04 indicates that the user is in the process of physically writing data to disk.</p>
<p>
Commit bytes in Microsoft Jet 3.0 can have many different values, so they were increased to 2 bytes. A value of 00 00 indicates that the user is in the process of physically writing to disk, and a value of 01 00 indicates that a user has accessed a corrupted page. Therefore, if either a value of 00 00 is present without a corresponding user lock or a value of 01 00 is present, users are not allowed to connect to the database without first executing the repair utility. If a user is looking at these commit byte values with the LDBView utility, he or she will notice that there may be many other values present in the 600 to 800 hex range. These values are used internally by Microsoft Jet for performance reasons (mainly to determine whether other users have written data to the database file). If Microsoft Jet determines that other users have not written information to disk, it delays refreshing its internal cache, resulting in fewer reads and increased performance. Therefore, it is possible that a database opened in shared mode may approach the performance levels of a database opened in exclusive mode.</p>
<p>
Again, which commit bytes are actually used for a user is determined by their corresponding user lock in the .LDB file. A detailed discussion of how these locations are obtained appears later in this paper. Also, a user can monitor these values for both Microsoft Jet 2<i>.x</i> and 3.0 databases by using the 32-bit LDBView utility included with this article.</p>
<h2>Types of Microsoft Jet Locks</h2>
<h3>Shared vs. Exclusive Locks</h3>
<p>
These two types of locks are referred to frequently later in the paper, and it is important to understand the concepts behind them. Regardless of the type of lock, each extended byte range lock placed on the .LDB file always represents one page in the .MDB file (except for user locks). No locks are ever placed on the .MDB file.</p>
<p>
A shared lock occupies only 1 byte and never conflicts with another shared lock. These types of locks are typically used to allow many people to read information at the same time. Shared locks are used, for example, when many users have the same table open at the same time without conflicting with each other or when users are reading an index that participates in referential integrity. In these situations, many users would be able to read the index at the same time.</p>
<p>
An exclusive lock spans between 256 and 512 bytes and always conflicts with other shared locks and other exclusive locks. The exclusive lock always locks the first 256 bytes of the range to prevent any shared locks from being set and determines whether there are any existing shared locks set. In addition, it locks enough additional bytes beyond 256 to determine which user is holding the lock. An example of an exclusive lock is when a user opens a table in deny-read mode. This exclusive lock would be prevented if another user had a shared lock on the table; if the exclusive lock were acquired, it would prevent other users from obtaining a shared lock. Another example is when a user is writing information back to an index page that participates in referential integrity. This would produce a write lock, which is always exclusive, and would prevent anyone from reading the index page. The index page requires a read lock and is always shared.</p>
<p>
There are seven types of Microsoft Jet locks:
<ul type=disc>
<li>
User locks<br><br></li>
<li>
Write locks<br><br></li>
<li>
Read locks<br><br></li>
<li>
Commit locks (Microsoft Jet 2<i>.x</i> only)<br><br></li>
<li>
Table-read locks<br><br></li>
<li>
Table-write locks<br><br></li>
<li>
Table deny-write locks</li>
</ul>
<p>
These extended byte range locks are broken out into six virtual regions off of the .LDB file for Microsoft Jet 2<i>.x</i> and five virtual regions for Microsoft Jet 3.0. These areas are where Microsoft Jet places extended byte range locks that range from 10000001 to 6FF800FF hex. These locks are present only when users have the database connected in a shared or read-only mode. Note that the names of these locks were assigned by the Microsoft Jet development team and do not necessarily have the same meaning that other database vendors use. See Table 1 after the descriptions below for a summary of these locking ranges.</p>
<h3>User Locks</h3>
<p>
User locks determine ownership of a commit byte(s) in the DBH, write the computer and security names in the correct location in the .LDB file, and retrieve the computer and security names of another user who has conflicting locks. A user lock is obtained and is persistent for as long as a user is connected to the database. (Persistence in this context indicates the duration of a lock or how long a lock is held.) Only one user lock exists for each connected user; however, multiple instances of Microsoft Jet on the same computer create an individual user lock for each instance. User locks are always in the range of 10000001 hex through 100000FF hex. User locks occupy only 1 byte (for example, 10000002 to 10000002).</p>
<h3>Write Locks</h3>
<p>
Write locks prevent other users from changing data while a user is modifying data. A write lock is typically placed on data, index, or long value pages. (Long value pages are a type of data page that contains ANSI SQL data types of CHARACTER, VARYING, BIT, or BIT VARYING. These data types are known as <b>Memo</b> or <b>OLE Object</b> fields in Microsoft Access and Visual Basic.) Write locks are in the range of 20000000 hex through 2FF800FF hex and always span between 256 and 512 bytes (for example, 2000E600 to 2000E700 hex), and therefore are always exclusive locks. The persistence of write locks is directly related to the duration of a transaction. All SQL Data Manipulation Language (DML) statements have implicit transactions placed around them. Thus, an <b>UPDATE</b> statement has persistent write locks until the entire update is committed. The persistence of write locks is also determined by the type of locking that is chosen for recordset navigation and form editing (for example, pessimistic/optimistic) and whether explicit transactions are used. For more information on locking semantics, see Chapter 12 in the Microsoft Access 2.0<i> Building Applications</i> manual.</p>
<h3>Read Locks (Microsoft Jet 2<i>.x</i>)</h3>
<p>
Read locks, which are a type of shared lock, are primarily used for the immediate recycling of index pages and for ensuring that index pages in the Microsoft Jet cache are up-to-date. This type of lock is placed on long value pages and index pages. It is used to prevent an index page from being recycled while that page is being referenced in the Microsoft Jet cache and to provide an integral view of the index. Read locks are placed in the range of 30000000 to 3FF800FF hex. They occupy only 1 byte (for example, 30001A01 to 30001A01).</p>
<p>
Read locks in version 2.<i>x</i> are probably the most troublesome types of locks to deal with because they can cause locking conflicts that are not obvious to the developer or user. The persistence of read locks is determined by:
<ol>
<li>
The LockedPageTimeout setting, specified in tenths of a second, which determines the amount of time the Microsoft Jet database engine retains locks before releasing them. By increasing the LockedPageTimeout setting, read locks are retained for a longer period of time, which reduces the need for Microsoft Jet to reread data pages into cache. The LockedPageTimeout setting can be changed by modifying the \ISAM section of the corresponding .INI file (MSACC20.INI for Microsoft Access users) or by modifying the value in the Windows Registry for Windows 95 or Windows NT in the Microsoft Jet 2<i>.x</i>\ISAM key. The side-effects could be reduced concurrency due to commit lock conflicts, which are discussed next.<br><br></li>
<li>
Calling the <b>DBEngine.Idle DBFreeLocks</b> statement or the <b>FreeLocks</b> statement. However, these commands do not always free all read locks when inside a transaction (see lock log examples later in this article). Note that the <b>DBFreeLocks</b> constant is used in DAO 3.0 and would be used when Microsoft Access version 7.0 or Visual Basic version 4.0 has opened a Microsoft Jet 2<i>.x</i> database. If Microsoft Access 2.0 or Visual Basic 3.0 is used, then the constant would be <b>DB_FreeLocks</b>.</li>
</ol>
<p>
Read locks are typically placed when an index or long value page is read and placed in the Microsoft Jet cache, for example, when performing an SQL DML <b>UPDATE</b> command on a table that has a primary key.</p>
<h3>Read Locks (Microsoft Jet 3.0)</h3>
<p>
The main purpose of read locks in Microsoft Jet 3.0 is to allow multiple users to read long value data, but prevent users from writing to it while others are reading.</p>
<p>
Microsoft Jet 3.0 has reduced the amount of read locks that are placed on index pages, which directly results in greater concurrency and performance. Read locks on index pages are now placed only when referential integrity is being enforced. Unlike Microsoft Jet 2<i>.x</i>, the persistence of read locks is determined by the currency of a row. Thus, a read lock on a long value page remains until the user leaves that row. An exception to this is when a long value page contains data from more than one row, at which point Microsoft Jet releases the read lock on that page. An example of this is when several rows of <b>Memo</b> data are placed on one long value page.</p>
<p>
Because read locks are persistent until the user loses currency on the row, the <b>DBEngine.Idle DBFreeLocks</b> statement and <b>FreeLocks</b> statement no longer provide any functionality. (the <b>FreeLocks</b> statement is no longer supported in Visual Basic 4.0 or Microsoft Access 7.0, unless the DAO 2.5/3.0 compatibility layer is enabled.) Microsoft Jet 3.0 read locks are also placed in the same range as write locks; the only difference is that read locks are shared locks and they occupy only 1 byte (for example, 20001A01 to 20001A01).</p>
<h3>Commit Locks</h3>
<p>
Commit locks are present only in Microsoft Jet 2.<i>x</i> and are very similar to read locks, except that they are always exclusive locks. These locks are also placed in the 30001A01 through 3FF800FF hex range. They are placed when either index pages or long value pages are being written back to the database, and they conflict only with read locks. Read locks are typically placed on index pages whenever an index page is placed in the Microsoft Jet cache. An index page references many data pages, and therefore it becomes apparent why many users can experience locking conflicts when they know other users are not editing data on the same data page.</p>
<p>
One of the best mechanisms to prevent these conflicts is to judiciously use the <b>DBEngine.Idle DB_FreeLocks</b> statement or <b>FreeLocks</b> statement in the application code. The use of these two commands is the most effective way to free up read locks so that commit locks do not conflict with them.</p>
<p>
Commit locks do not exist in Microsoft Jet 3.0 because the range for read locks has been moved into the same range as write locks, thus eliminating the need for this type of lock.</p>
<h3>Table-Read Locks</h3>
<p>
Table-read locks are used to control placing a table in a deny-read mode, which uses an exclusive lock and prevents other users from reading data from the table. Unlike the previous types of locks, table-read locks and the rest of the table-type locks are placed only on a special type of page called a table header page (TBH). There is one TBH page for each table, and every TBH contains statistics about the table (such as row count, next counter value, column data types, and index types).</p>
<p>
Table-read locks are placed in the 40000000 through 4FF800FF hex range and can be placed as shared locks or exclusive locks.</p>
<p>
When a table is opened, a shared table-read lock is placed. Deny-read mode is set when the default locking on a database is set to All Records (through the Microsoft Access user interface) or <b>dbDenyRead</b> is issued through the DAO <b>OpenRecordSet</b> method. If the exclusive lock can be obtained, then there are no other users that have the table opened. The exclusive lock prevents other users from acquiring shared locks when they try to open a table. These locks are persistent until the user closes the table.</p>
<h3>Table-Write Locks</h3>
<p>
Table-write locks are used in conjunction with table deny-write locks and are placed in the 50000000 through 5FF800FF hex range. These shared locks are persistent whenever a table is opened in a state that allows writing.</p>
<h3>Table Deny-Write Locks</h3>
<p>
These locks are used in conjunction with table-write locks and are explicitly set when opening a table in deny-write mode. These locks are placed in the 60000000 through 6FF800FF hex range and have a persistent shared lock while the table is opened in deny-write mode. An exclusive lock is placed, but not held, to determine which other users have the table open in deny-write mode.</p>
<p class=label>
<b>Table 1</b></p>
<table border=1 cellpadding=5 cols=7 frame=below rules=rows>
<tr valign=top>
<td class=label width=12%><b><br>
<br>
Lock name</b></td>
<td class=label width=20%><b><br>
<br>
What sets the lock</b></td>
<td class=label width=16%><b><br>
<br>
What is locked</b></td>
<td class=label width=14%><b><br>
What the lock prevents</b></td>
<td class=label width=14%><b><br>
Persistence of the lock</b></td>
<td class=label width=12%><b>Shared or exclusive available</b></td>
<td class=label width=12%><b><br>
Byte range examples</b></td>
</tr>
<tr valign=top>
<td width=12%>User</td>
<td width=20%>User opens an .mdb file</td>
<td width=16%>N/A</td>
<td width=14%>Nothing</td>
<td width=14%>Until user exits .mdb file</td>
<td width=12%>N/A</td>
<td width=12%>10000001–<br>
10000001</td>
</tr>
<tr valign=top>
<td width=12%>Write</td>
<td width=20%>Insert, update, or delete</td>
<td width=16%>All available page types</td>
<td width=14%>Updates or deletes to data and sometimes inserts to a table</td>
<td width=14%>Controlled by default locking (optimistic or pessimistic) and the duration of a transaction</td>
<td width=12%>Exclusive</td>
<td width=12%>2000A601–<br>
2000A701</td>
</tr>
<tr valign=top>
<td width=12%>Read (version 2.<i>x</i>)</td>
<td width=20%>Reads on a long value or an index page</td>
<td width=16%>Long value, index, or TBH</td>
<td width=14%>Updates or deletes to long value pages or index</td>
<td width=14%>Controlled by LockedPageTimeout in the .INI file or by issuing a <b>FreeLocks</b> call</td>
<td width=12%>Shared</td>
<td width=12%>30001E01–<br>
30001E01</td>
</tr>
<tr valign=top>
<td width=12%>Read (version 3.0)</td>
<td width=20%>Reads on certain long values or index pages when referential integrity is being enforced</td>
<td width=16%>Long value, index, or directory pages</td>
<td width=14%>Updates or deletes to long value or index pages</td>
<td width=14%>Until a read or a transaction is complete or the user moves to a new row</td>
<td width=12%>Shared</td>
<td width=12%>20063801–<br>
20063801</td>
</tr>
<tr valign=top>
<td width=12%>Commit (dropped in version 3.0)</td>
<td width=20%>Writes to long value or index pages</td>
<td width=16%>Long value or index pages</td>
<td width=14%>Prevents reads when data is being written to disk</td>
<td width=14%>Until data is finished being written to disk</td>
<td width=12%>Exclusive</td>
<td width=12%>30001A01–<br>
30001B01</td>
</tr>
<tr valign=top>
<td width=12%>Table-read</td>
<td width=20%>Shared lock is obtained when a table is opened; exclusive lock is obtained when default locking is set to All Records through Microsoft Access or Set dbDenyRead has been issued through DAO <b>OpenRecordSet</b>.</td>
<td width=16%>TBH </td>
<td width=14%>Prevents exclusive read lock from being set</td>
<td width=14%>As long as the table is open</td>
<td width=12%>Both</td>
<td width=12%>4000C801–<br>
4000C801</td>
</tr>
<tr valign=top>
<td width=12%>Table-write</td>
<td width=20%>Shared lock is obtained when a table is opened; exclusive lock is obtained when default locking is set to All Records through Microsoft Access or dbDenyRead has been issued through DAO <b>OpenRecordset</b>.</td>
<td width=16%>TBH</td>
<td width=14%>Prevents exclusive write lock from being set, does not prevent table deny-write lock</td>
<td width=14%>As long as the table is open</td>
<td width=12%>Both</td>
<td width=12%>5000C801–<br>
5000C801</td>
</tr>
<tr valign=top>
<td width=12%>Table deny-write</td>
<td width=20%>Can be set only through DAO</td>
<td width=16%>TBH</td>
<td width=14%>Prevents all writes to the table</td>
<td width=14%>As long as the table is open</td>
<td width=12%>Both</td>
<td width=12%>6000C801–<br>
6000C801</td>
</tr>
</table><br>
<h2>Deciphering Lock Ranges</h2>
<p>
To use the information previously discussed in a way that can help you resolve locking issues with your application, you need to be able to view, understand, and decipher the locks that Microsoft Jet places.</p>
<p>
To view the locks being placed, you need to have either a Novell® NetWare® environment, Microsoft SMS Network Monitor, or some other "network sniffing" tool. By using one of these utilities, particularly the real-time NetWare Monitor program, an administrator can view the locks being placed by Microsoft Jet on the .LDB file. Developers can also use this information to see how their code places locks on the .LDB file and what effects it might have in a multiuser environment.</p>
<h2>User Lock Algorithm</h2>
<p>
All Microsoft Jet multiuser locking schemes revolve around the placement of a user lock. As stated previously, user locks are placed in the 10 million hex range and occupy only 1 byte. When Microsoft Jet connects to a database in a shared or read-only mode, the following activities occur before a user lock is actually placed.</p>
<p>
The first activity is a determination whether the Microsoft Jet database engine is in a suspect state. This is done by examining the DBH page and seeing what bytes have a nonzero value. If the first byte (Microsoft Jet 2<i>.x</i>) or the first 2 bytes (Microsoft Jet 3.0) contain a commit in progress value, or the remaining 255 bytes (Microsoft Jet 2.<i>x</i>) or 510 bytes (Microsoft Jet 3.0) have a commit in progress value and do not have a corresponding user lock, then Microsoft Jet forces the user to repair the database. When opening a database in shared mode, there is never a need to check for a user lock on the first byte (Microsoft Jet 2.<i>x</i>) or the first two bytes (Microsoft Jet 3.0), because the lock is only used when a database is connected exclusively. A corresponding user lock would be a lock that shares the same offset in the ten-million-hex range as the offset from the first byte in the DBH page. Thus, a nonzero commit byte at 701 hex (Microsoft Jet 2<i>.x</i>) or 602 to 603 hex (Microsoft Jet 3.0) would need to have a user lock at 10000001 in order for the database to be opened without a corrupt database message.</p>
<p>
The Microsoft Jet database engine then opens the .LDB file (or creates one if one does not exist) and tries to place a lock at 10000001 hex. If Microsoft Jet is successful in obtaining this lock, it writes the computer and security name to the first 64 bytes of the file. If Microsoft Jet cannot acquire this lock, it continues moving one byte further until a lock can be successfully obtained. After the user lock is acquired, the Microsoft Jet database engine writes the computer and security name at the corresponding location in the .LDB file. For example, a user lock at 10000040 hex would write an entry starting at 4096 bytes in the physical part of the .LDB file.</p>
<p>
Some users have experienced delays when trying to connect to a database that already has many users connected. This is mainly due to nonoptimized network drivers, for example, when a user is running a Microsoft Windows NT 3.5 client accessing a NetWare server. If a user were trying to connect to the database and 30 other users were currently connected, it could take upwards of 30 seconds to perform the user lock algorithm. Windows NT 3.51 has a modified NetWare requester driver that decreases the wait to approximately two seconds.</p>
<h2>Deciphering Write Locks</h2>
<p>
As stated previously, write locks always occur in the 20 million hex range and always have a starting and ending lock range between 256 and 512 bytes. The code below places write locks on the .LDB file that relates to pages in the Customers table. All future references to locks on pages are really referring to locks placed on the .LDB file that relates to pages in the database file.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The following code examples assume that the user is using Visual Basic 4.0 or Microsoft Access 7.0 with either an original Microsoft Jet 2<i>.x</i> version of the NWIND database that shipped with Access 2.0, or a NWIND database that was compacted to Microsoft Jet 3<i>.x</i> from the original Access 2.0 NWIND database (using the DAO <b>CompactDatabase</b> method in Visual Basic 4.0 [32-bit] or Microsoft Access 7.0). If Microsoft Access 7.0 is used to convert the Microsoft Access 2.0 NWIND database using the Convert option from the Tools/Database Utilities menu, then the logs differ from the Microsoft Jet 3.0 logs below. The logs also assume that the user is the first user logged on to the database, thus implying a user lock of 10000001 hex.</p>
<h3>Data Page Write Locks</h3>
<p>
Here is sample code and a lock log (Table 2) of write locks placed on data pages:</p>
<pre><code>Sub WriteLocksDataPages ()
 &nbsp;&nbsp; 'The example is intended to be run from Access 7.0 or VB 4.0.
 &nbsp;&nbsp; Dim db As Database
 &nbsp;&nbsp; Dim rs As Recordset
 &nbsp;&nbsp; Dim ws As Workspace
 &nbsp;&nbsp; Dim ContactName As String
 &nbsp;&nbsp; Set db = OpenDatabase("NWind.mdb", False, False)
 &nbsp;&nbsp; Set rs = db.OpenRecordset("SELECT * FROM Customers")
 &nbsp;&nbsp; rs.lockedits = false
 &nbsp;&nbsp; Set ws = Workspaces(0)
 &nbsp;&nbsp; ws.BeginTrans
 &nbsp;&nbsp; While Not rs.eof
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rs.Edit
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ContactName = rs![Contact Name]
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rs![Contact Name] = ContactName
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rs.Update
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rs.MoveNext
 &nbsp;&nbsp; Wend
 &nbsp;&nbsp; ws.CommitTrans
End Sub
</code></pre>
<p>
When you set a breakpoint on the recordset <b>MoveNext</b> method, the Microsoft Jet database engine leaves a write lock on the first data page of the Customers table. Assuming that only one user is connected to the database, the write lock has a starting and ending lock address of 2000AC00 to 2000AD00 (Microsoft Jet 2<i>.x</i>). To determine what page is being locked, follow these steps:
<ol>
<li>
Remove the first digit (2000AC00 to AC00).<br><br></li>
<li>
Convert to decimal (AC00 to 44032).<br><br></li>
<li>
Determine the page number by dividing by 512 (44032 / 512 = 86). Thus, page 86 is being locked via the .LDB file by <b>rs.Edit</b>. Page 86 would represent the page in the database starting at 176,128 bytes and extending to 178,176 bytes.</li>
</ol>
<p>
To determine the user number that is locking the page, simply take the last two digits of the ending address, convert it to decimal, and add one digit if the database is Microsoft Jet 2<i>.x</i> (2000AD00  00 + 1 = 1). If the database is a Microsoft Jet 3.0 database, simply converting the last two digits to decimal gives the user number (2000A701  01 = 1). Thus, in the Microsoft Jet 2<i>.x</i> example above, user one would be holding the lock (last two digits are zero, plus one).</p>
<p>
To find the computer name of the user, simply open the corresponding .LDB file and move to the offset of the user number * 64. In the previous example, the computer name would be in the first 32 bytes of the .LDB file (1 * 64). Alternatively, you can use the 32-bit LDBView utility included with this article to quickly find the computer name of the user who is placing the lock.</p>
<p>
In addition to knowing which user has a page locked, it is usually more useful to know which table is associated with the write lock. You can find this information by using the 32-bit Visual Basic 4.0 utility (DBLock) that is included with this article.</p>
<p>
Table 2 below shows the majority of locks placed from the previous code example with descriptions for each lock. By using DBLock, you can enter the beginning lock range shown and get a description of the type of lock and which table it is locking. DBLock cannot get table names for long value pages and other internal types of pages used by Microsoft Jet.</p>
<p class=label>
<b>Table 2</b></p>
<table border=1 cellpadding=5 cols=5 frame=below rules=rows>
<tr valign=top>
<td class=label width=19%><b><br>
DAO command</b></td>
<td class=label width=19%><b>Microsoft Jet 2<i>.x</i> <br>
lock hex</b></td>
<td class=label width=24%><b><br>
Description</b></td>
<td class=label width=18%><b>Microsoft Jet 3.0 lock hex</b></td>
<td class=label width=20%><b><br>
Description</b></td>
</tr>
<tr valign=top>
<td width=19%><b>OpenDatabase</b></td>
<td width=19%>10000001–<br>
10000001</td>
<td width=24%>User lock</td>
<td width=18%>10000001–<br>
10000001</td>
<td width=20%>User lock</td>
</tr>
<tr valign=top>
<td width=19%></td>
<td width=19%>30001A01–<br>
30001A01</td>
<td width=24%>Read lock on index page for MSysObjects</td>
<td width=18%></td>
<td width=20%></td>
</tr>
<tr valign=top>
<td width=19%></td>
<td width=19%>30001E01–<br>
30001E01</td>
<td width=24%>Read lock on index page for MSysObjects</td>
<td width=18%></td>
<td width=20%></td>
</tr>
<tr valign=top>
<td width=19%></td>
<td width=19%>30002001–<br>
30002001</td>
<td width=24%>Read lock on index page for MSysIndexes</td>
<td width=18%></td>
<td width=20%></td>
</tr>
<tr valign=top>
<td width=19%></td>
<td width=19%>30002201–<br>
30002201</td>
<td width=24%>Read lock on index page for MSysACEs</td>
<td width=18%></td>
<td width=20%></td>
</tr>
<tr valign=top>
<td width=19%></td>
<td width=19%>30003001–<br>
30003001</td>
<td width=24%>Read lock on index page for MSysObjects</td>
<td width=18%></td>
<td width=20%></td>
</tr>
<tr valign=top>
<td width=19%></td>
<td width=19%>3000AA01–<br>
3000AA01</td>
<td width=24%>Read lock on index page for MSysColumns</td>
<td width=18%></td>
<td width=20%></td>
</tr>
<tr valign=top>
<td width=19%></td>
<td width=19%>30040C01–<br>
30000C01</td>
<td width=24%>Read lock on index page for MSysColumns</td>
<td width=18%></td>
<td width=20%></td>
</tr>
<tr valign=top>
<td width=19%></td>
<td width=19%>30065201–<br>
30065201</td>
<td width=24%>Read lock on index page for MSysACEs</td>
<td width=18%></td>
<td width=20%></td>
</tr>
<tr valign=top>
<td width=19%><b>OpenRecordSet</b></td>
<td width=19%>4000A601–<br>
4000A601</td>
<td width=24%>Shared table-read lock on Customers table</td>
<td width=18%>4000A201–<br>
400A201</td>
<td width=20%>Shared table-read lock on Customers table</td>
</tr>
<tr valign=top>
<td width=19%></td>
<td width=19%>5000A601–<br>
5000A601</td>
<td width=24%>Shared table-write lock on Customers table</td>
<td width=18%></td>
<td width=20%></td>
</tr>
<tr valign=top>
<td width=19%><b>rs.Edit</b></td>
<td width=19%></td>
<td width=24%>No lock placed due to optimistic locking</td>
<td width=18%></td>
<td width=20%></td>
</tr>
<tr valign=top>
<td width=19%><b>rs.Update</b></td>
<td width=19%>2000AC00–<br>
2000AD00</td>
<td width=24%>Write lock on Customers table</td>
<td width=18%>2000A601–<br>
2000A701</td>
<td width=20%>Write lock on Customers table.</td>
</tr>
<tr valign=top>
<td width=19%><b>Repeat loop until EOF</b></td>
<td width=19%>2000AE00–<br>
2000AF00</td>
<td width=24%>15 rows have looped through before the next data page is write locked. Even though pessimistic locking is enabled, the transaction holds the write locks until <b>WS.CommitTrans</b>.</td>
<td width=18%>2000A801–<br>
2200A901</td>
<td width=20%>16 rows have looped through before the next data page is write locked.</td>
</tr>
<tr valign=top>
<td width=19%></td>
<td width=19%>2000B000–<br>
2000B100</td>
<td width=24%></td>
<td width=18%>2000AA01–<br>
2000AB01</td>
<td width=20%></td>
</tr>
<tr valign=top>
<td width=19%></td>
<td width=19%>2000B200–<br>
2000B300</td>
<td width=24%></td>
<td width=18%>2000AC01–<br>
2000AD01</td>
<td width=20%></td>
</tr>
<tr valign=top>
<td width=19%></td>
<td width=19%>2000B400–<br>
2000B500</td>
<td width=24%></td>
<td width=18%>2000AE01–<br>
2000AF01</td>
<td width=20%></td>
</tr>
<tr valign=top>
<td width=19%></td>
<td width=19%>2000B600–<br>
2000B700</td>
<td width=24%></td>
<td width=18%>2000B001–<br>
2000B101</td>
<td width=20%></td>
</tr>
<tr valign=top>
<td width=19%></td>
<td width=19%>2000B800–<br>
2000B900</td>
<td width=24%></td>
<td width=18%>2000B201–<br>
2000B301</td>
<td width=20%></td>
</tr>
</table><br>
<p>
There is some interesting information in this trace log. Notice that the Microsoft Jet 3.0 log has no read locks placed and that the last two digits of the write locks represent the true user number, whereas the last two digits for the Microsoft Jet 2<i>.x</i> write locks require the user to add one to determine the true user number. Also, when optimistic locking is used, the explicit transaction holds write locks for the duration of the transaction, thus emulating pessimistic locking. Many users mistakenly believe that optimistic locking is always in effect regardless of the transaction mechanism. Another example of this would be to issue the following code to mimic the DAO code example above.</p>
<h3>Internal Transactions on SQL DML Commands</h3>
<p>
Because all DML commands are implicitly wrapped in a transaction, the write locks in the example below are held until the <b>UPDATE</b> statement is completed successfully.</p>
<pre><code>Sub WriteLocksDML ()
 &nbsp;&nbsp; 'This code example is intended to be run from Access 7.0 or VB 4.0.
 &nbsp;&nbsp; Dim db As Database
 &nbsp;&nbsp; Set db = OpenDatabase("NWind.mdb", False, False)
 &nbsp;&nbsp; DBEngine.Execute _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "UPDATE Customers SET ContactName = ContactName", _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dbFailOnError
End Sub
</code></pre>
<h3>Internal Transactions on DAO Code with Microsoft Jet 3.0</h3>
<p>
By removing the explicit calls to <b>WS.BeginTrans</b> and <b>WS.CommitTrans</b> from the code above (WriteLocksDatapage), Microsoft Jet 3.0 utilizes internal transactions. Based on settings (SharedAsyncDelay and MaxBufferSize) in the system registry, Microsoft Jet places a series of commands into an internal transaction. While this does speed up performance, it may also create concurrency issues where they did not exist in Microsoft Jet 2<i>.x</i>.</p>
<h3>Nested Transactions</h3>
<p>
The following code example and lock log (Table 3) demonstrate that locks are held in nested transactions until the outermost transaction is committed:</p>
<pre><code>Sub NestedTransactions()
 &nbsp;&nbsp; 'This code example is intended to be run from Access 7.0 or VB 4.0.
 &nbsp;&nbsp; Dim ws As Workspace
 &nbsp;&nbsp; Set ws = Workspaces(0)
 &nbsp;&nbsp; Dim ws1 As Workspace
 &nbsp;&nbsp; Set ws1 = Workspaces(0)
 &nbsp;&nbsp; ws.BeginTrans
 &nbsp;&nbsp; db.Execute _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "UPDATE Suppliers SET [Contact Name] = [Contact Name]", _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dbFailOnError
 &nbsp;&nbsp; ws1.BeginTrans
 &nbsp;&nbsp; db.Execute _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "UPDATE Employees SET [Last Name] = [Last Name]", _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dbFailOnError
 &nbsp;&nbsp; ws1.CommitTrans
 &nbsp;&nbsp; ws.CommitTrans
End Sub
</code></pre>
<p class=label>
<b>Table 3</b></p>
<table border=1 cellpadding=5 cols=5 frame=below rules=rows>
<tr valign=top>
<td class=label width=18%><b><br>
DAO command</b></td>
<td class=label width=16%><b>Microsoft Jet 2<i>.x</i> lock hex</b></td>
<td class=label width=25%><b><br>
Description</b></td>
<td class=label width=16%><b>Microsoft Jet 3.0 lock hex</b></td>
<td class=label width=25%><b><br>
Description</b></td>
</tr>
<tr valign=top>
<td width=18%><b>WS.BeginTrans</b></td>
<td width=16%></td>
<td width=25%>Start outer level transaction.</td>
<td width=16%></td>
<td width=25%>Start outer level transaction.</td>
</tr>
<tr valign=top>
<td width=18%><b>UPDATE</b> <b>Suppliers</b></td>
<td width=16%>40042401–<br>
40042401</td>
<td width=25%>Shared table-read lock on Suppliers table</td>
<td width=16%>400C7E01–<br>
400C7E01</td>
<td width=25%>Shared table-read lock on Suppliers table.</td>
</tr>
<tr valign=top>
<td width=18%></td>
<td width=16%>50042401–<br>
50042401</td>
<td width=25%>Shared table-write lock on Suppliers table</td>
<td width=16%>200C5001–<br>
200C5101</td>
<td width=25%>Write lock on data page for MsysObjects. This is for compilation of the temporary query and is not placed every time.</td>
</tr>
<tr valign=top>
<td width=18%></td>
<td width=16%>20042600–<br>
20042700</td>
<td width=25%>Write lock on data page for Suppliers table</td>
<td width=16%>200C8401–<br>
200C8501</td>
<td width=25%>Write lock on data page for Suppliers table</td>
</tr>
<tr valign=top>
<td width=18%></td>
<td width=16%>20042800–<br>
20042900</td>
<td width=25%>Write lock on data page for Suppliers table</td>
<td width=16%>200C8601–<br>
200C8701</td>
<td width=25%>Write lock on data page for Suppliers table</td>
</tr>
<tr valign=top>
<td width=18%></td>
<td width=16%>20042A00–<br>
20042B00</td>
<td width=25%>Write lock on data page for Suppliers table</td>
<td width=16%></td>
<td width=25%></td>
</tr>
<tr valign=top>
<td width=18%><b>WS1.BeginTrans</b></td>
<td width=16%></td>
<td width=25%>Start inner level transaction</td>
<td width=16%></td>
<td width=25%>Start inner level transaction.</td>
</tr>
<tr valign=top>
<td width=18%><b>UPDATE</b> <b>Employees</b></td>
<td width=16%>4000CC01–<br>
4000CC01</td>
<td width=25%>Shared table-read lock on Employees table</td>
<td width=16%>4000C801–<br>
4000C801</td>
<td width=25%>Shared table-read lock on Employees table.</td>
</tr>
<tr valign=top>
<td width=18%></td>
<td width=16%>5000CC01–<br>
5000CC01</td>
<td width=25%>Shared table-write lock on Employees table</td>
<td width=16%></td>
<td width=25%></td>
</tr>
<tr valign=top>
<td width=18%></td>
<td width=16%>2000E600–<br>
2000E700</td>
<td width=25%>Write lock on data page for Employees table</td>
<td width=16%>2000E401–<br>
2000E501</td>
<td width=25%>Write lock on data page for MSysObjects. This is for compiling the temp query.</td>
</tr>
<tr valign=top>
<td width=18%></td>
<td width=16%>20020400–<br>
20020500</td>
<td width=25%>Write lock on data page for Employees table</td>
<td width=16%>20020801–<br>
20020901</td>
<td width=25%>Write lock on data page for Employees table</td>
</tr>
<tr valign=top>
<td width=18%><b>WS1.CommitTrans</b></td>
<td width=16%></td>
<td width=25%>Write locks stay on.</td>
<td width=16%></td>
<td width=25%>Write locks stay on.</td>
</tr>
<tr valign=top>
<td width=18%><b>WS1.Rollback</b></td>
<td width=16%></td>
<td width=25%>If a rollback is issued here, the write locks on the Employees table are removed.</td>
<td width=16%></td>
<td width=25%>If a rollback was issued here, the write locks on the Employees table would be removed.</td>
</tr>
<tr valign=top>
<td width=18%><b>WS.CommitTrans</b></td>
<td width=16%></td>
<td width=25%>Write locks are removed.</td>
<td width=16%></td>
<td width=25%>Write locks are removed.</td>
</tr>
</table><br>
<p>
The previous example illustrates a couple of key points. <i>If a <b>CommitTrans</b> or <b>Rollback</b> statement is not issued or is not balanced with corresponding <b>BeginTrans</b> commands, write locks are held until the database is closed.</i> This can cause serious concurrency issues. If a user does not explicitly check the error status of a <b>Rollback</b> or <b>CommitTrans</b> statement, then the command could fail, leaving locks on the .LDB file. Also, simply executing a nested <b>CommitTrans</b> statement does not remove write locks nor is the modified data actually flushed to disk until the outermost transaction is committed.</p>
<h3>Index Page Write Locks</h3>
<p>
Below is sample code and a lock log (Table 4) of the majority of write locks placed on both data and index pages.</p>
<pre><code>Sub WriteLocksIndexPages ()
 &nbsp;&nbsp; 'This code example is intended to be run from Access 7.0 or VB 4.0.
 &nbsp;&nbsp; Dim db As Database
 &nbsp;&nbsp; Set db = OpenDatabase("NWind.mdb", False, False)
 &nbsp;&nbsp; Dim CompanyName As String
 &nbsp;&nbsp; Set rs = db.OpenRecordset _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ("SELECT * FROM Customers", dbopendynaset)
 &nbsp;&nbsp; 'The constant dbFreeLocks is DAO v3 specific and is used
 &nbsp;&nbsp; 'when Jet 3.0 (Access 7.0/ VB 4.0) is opening a Jet 2<i>.x</i> database.
 &nbsp;&nbsp; 'If Access 2.0 or VB 3.0 is used, the constant would be db_FreeLocks.
 &nbsp;&nbsp; DBEngine.Idle dbFreeLocks 'Works only in Jet 2<i>.x.</i>
 &nbsp;&nbsp; Set ws = Workspaces(0)
 &nbsp;&nbsp; ws.BeginTrans
 &nbsp;&nbsp; While Not rs.EOF
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rs.Edit
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CompanyName = rs![Company Name]
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rs![Company Name] = CompanyName
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DBEngine.Idle dbFreeLocks 'Works only in V2.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rs.Update
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rs.MoveNext
 &nbsp;&nbsp; Wend
 &nbsp;&nbsp; ws.CommitTrans
 &nbsp;&nbsp; rs.Close
End Sub
</code></pre>
<p class=label>
<b>Table 4</b></p>
<table border=1 cellpadding=5 cols=5 frame=below rules=rows>
<tr valign=top>
<td class=label width=20%><b><br>
DAO Command</b></td>
<td class=label width=19%><b>Microsoft Jet 2</b><i>.x</i><b> lock hex</b></td>
<td class=label width=24%><b><br>
Description</b></td>
<td class=label width=21%><b>Microsoft Jet 3.0 lock hex</b></td>
<td class=label width=16%><b><br>
Description</b></td>
</tr>
<tr valign=top>
<td width=20%><b>OpenDatabase</b></td>
<td width=19%>10000001</td>
<td width=24%>User lock</td>
<td width=21%>10000001</td>
<td width=16%>User lock</td>
</tr>
<tr valign=top>
<td width=20%></td>
<td width=19%>30001A01–<br>
30001A01</td>
<td width=24%>Read lock on index page for MSysObjects</td>
<td width=21%></td>
<td width=16%></td>
</tr>
<tr valign=top>
<td width=20%></td>
<td width=19%>30001E01–<br>
30001E01</td>
<td width=24%>Read lock on index page for MSysObjects</td>
<td width=21%></td>
<td width=16%></td>
</tr>
<tr valign=top>
<td width=20%></td>
<td width=19%>30002001–<br>
30002001</td>
<td width=24%>Read lock on index page for MSysIndexes</td>
<td width=21%></td>
<td width=16%></td>
</tr>
<tr valign=top>
<td width=20%></td>
<td width=19%>30002201–<br>
30002201</td>
<td width=24%>Read lock on index page for MSysACEs</td>
<td width=21%></td>
<td width=16%></td>
</tr>
<tr valign=top>
<td width=20%></td>
<td width=19%>30003001–<br>
30003001</td>
<td width=24%>Read lock on index page for MSysObjects</td>
<td width=21%></td>
<td width=16%></td>
</tr>
<tr valign=top>
<td width=20%></td>
<td width=19%>3000AA01–<br>
3000AA01</td>
<td width=24%>Read lock on index page for MSysColumns</td>
<td width=21%></td>
<td width=16%></td>
</tr>
<tr valign=top>
<td width=20%></td>
<td width=19%>30040C01–<br>
30000C01</td>
<td width=24%>Read lock on index page for MSysColumns</td>
<td width=21%></td>
<td width=16%></td>
</tr>
<tr valign=top>
<td width=20%></td>
<td width=19%>30065201–<br>
30065201</td>
<td width=24%>Read lock on index page for MSysACEs</td>
<td width=21%></td>
<td width=16%></td>
</tr>
<tr valign=top>
<td width=20%><b>OpenRecordSet</b></td>
<td width=19%>4000A601–<br>
4000A601</td>
<td width=24%>Shared table-read lock on Customers table</td>
<td width=21%>4000A201–<br>
4000A201</td>
<td width=16%>Shared table-read lock on Customers table</td>
</tr>
<tr valign=top>
<td width=20%></td>
<td width=19%>5000A601–<br>
5000A601</td>
<td width=24%>Shared table-write lock on Customers table</td>
<td width=21%></td>
<td width=16%></td>
</tr>
<tr valign=top>
<td width=20%><b>DBFreeLocks</b></td>
<td width=19%></td>
<td width=24%>All 30 million hex locks removed</td>
<td width=21%></td>
<td width=16%>Does nothing</td>
</tr>
<tr valign=top>
<td width=20%><b>rs.Edit</b></td>
<td width=19%>2000AC00–<br>
2000AD00</td>
<td width=24%></td>
<td width=21%>2000A601–<br>
2000A701</td>
<td width=16%></td>
</tr>
<tr valign=top>
<td width=20%><b>rs.Update</b></td>
<td width=19%>3000BC01–<br>
3000BC01</td>
<td width=24%>Read lock on index page for Customers table</td>
<td width=21%></td>
<td width=16%></td>
</tr>
<tr valign=top>
<td width=20%></td>
<td width=19%>3000BE01–<br>
3000BE01</td>
<td width=24%>Read lock on index page for Customers table</td>
<td width=21%></td>
<td width=16%></td>
</tr>
<tr valign=top>
<td width=20%><b>DBFreeLocks</b></td>
<td width=19%></td>
<td width=24%>3000BE01 is removed; 3000BC01 remains and is not freed by a <b>DBFreelocks</b> statement.</td>
<td width=21%></td>
<td width=16%>Does nothing</td>
</tr>
<tr valign=top>
<td width=20%><b>rs.Update</b></td>
<td width=19%>2000AE00–<br>
2000AF00</td>
<td width=24%>Write lock on data page for Customers table</td>
<td width=21%>2000A801–<br>
2200A901</td>
<td width=16%>Write lock on data page for Customers table</td>
</tr>
<tr valign=top>
<td width=20%></td>
<td width=19%>2000BE00–<br>
2000BF00</td>
<td width=24%>Write lock on index page for Customers table</td>
<td width=21%>2000B601–<br>
2000B701</td>
<td width=16%>Write lock on index page for Customers table</td>
</tr>
<tr valign=top>
<td width=20%><b>Continue looping</b></td>
<td width=19%></td>
<td width=24%></td>
<td width=21%></td>
<td width=16%></td>
</tr>
<tr valign=top>
<td width=20%></td>
<td width=19%>2000B000–<br>
2000B100</td>
<td width=24%>Write lock on data page for Customers table</td>
<td width=21%>2000AA01–<br>
2000AB01</td>
<td width=16%>Write lock on data page for Customers table</td>
</tr>
<tr valign=top>
<td width=20%></td>
<td width=19%>2000B200–<br>
2000B300</td>
<td width=24%>Write lock on data page for Customers table</td>
<td width=21%>2000AC01–<br>
2000AD01</td>
<td width=16%>Write lock on data page for Customers table</td>
</tr>
<tr valign=top>
<td width=20%></td>
<td width=19%>2000B400–<br>
2000B500</td>
<td width=24%>Write lock on data page for Customers table</td>
<td width=21%>2000AE01–<br>
2000AF01</td>
<td width=16%>Write lock on data page for Customers table</td>
</tr>
<tr valign=top>
<td width=20%></td>
<td width=19%>2000B600–<br>
2000B700</td>
<td width=24%>Write lock on data page for Customers table </td>
<td width=21%>2000BA01–<br>
2000BB01</td>
<td width=16%>Write lock on index page for Customers table</td>
</tr>
<tr valign=top>
<td width=20%></td>
<td width=19%>2000B800–<br>
2000B900</td>
<td width=24%>Write lock on data page for Customers table</td>
<td width=21%>2000B001–<br>
2000B101</td>
<td width=16%>Write lock on data page for Customers table</td>
</tr>
<tr valign=top>
<td width=20%></td>
<td width=19%>3000C001–<br>
3000C001</td>
<td width=24%>Read lock on index page for Customers table</td>
<td width=21%>2000B201–<br>
2000B301</td>
<td width=16%>Write lock on data page for Customers table</td>
</tr>
<tr valign=top>
<td width=20%></td>
<td width=19%>2000C000–<br>
2000C100</td>
<td width=24%>Write lock on index page for Customers table</td>
<td width=21%></td>
<td width=16%></td>
</tr>
</table><br>
<p>
The above log illustrates the reduction in read locks from Microsoft Jet 2<i>.x</i> to Microsoft Jet 3.0. Most importantly, the lock log demonstrates how indexes can greatly affect concurrency. In both versions of Microsoft Jet, there were three index pages that were locked in the Customers table that referenced eight data pages. Thus, by updating one index column, a user could be locking out many other users trying to update values on different data pages.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;While indexes can increase retrieval performance, it is very important to weigh their costs when using a multiuser system. By following the motto "If in doubt, index," you may experience substantial performance degradation and concurrency conflicts.</p>
<p>
Coming up with the best balance of indexed and nonindexed columns is an art and is different for every application and database. One rule of thumb: Don't index columns that have a high duplication factor—for example, indexing a Customer Type column on the Customers table where there were only four unique Customer Types in the Customers table that had 100,000 rows. Indexing this column would typically not increase performance on SQL SELECT statements and would cause performance (maintaining the index) and concurrency issues (each highly duplicated index page would reference many data pages) on SQL DML statements. The developer and system administrator need to weigh the importance of retrieval time (SQL SELECT statements) versus online transaction processing (OLTP) time (SQL DML statements) and come up with a proper balance of indexes that provides the fastest retrieval times with the fastest OLTP times.</p>
<h3>Inserting Rows</h3>
<p>
The following code example and lock log (Table 5) illustrate the drastic improvement in the locking algorithms used in Microsoft Jet 3.0. While Microsoft Jet 2<i>.x</i> would require a lock on the last data page and the TBH during a row insert, Microsoft Jet 3.0 requires a lock only on the last data page. Also, if Microsoft Jet 3.0 can't acquire a lock on the last data page, it continues seeking available data pages allocated to that table until it can successfully acquire a lock. This eliminates locking contentions when multiple users insert rows into the same table at the same time. The exception to this is when indexes are present on the table, because the user might experience some conflicts while modifying the index page.</p>
<p>
Also note the keyword <b>dbFailOnError</b> after the SQL string. This is absolutely necessary if a user wants to have an error returned. This was not supported in Visual Basic 3.0, and it prevented many users from using SQL in multiuser environments because locking conflicts could not be trapped.</p>
<pre><code>Sub InsertRows ()
 &nbsp;&nbsp; 'This code example is intended to be run from Access 7.0 or VB 4.0.
 &nbsp;&nbsp; db.Execute _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "INSERT INTO Shippers ([Company Name]) VALUES ('Test')", _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dbFailOnError
End Sub
</code></pre>
<p class=label>
<b>Table 5</b></p>
<table border=1 cellpadding=5 cols=5 frame=below rules=rows>
<tr valign=top>
<td class=label width=17%><b><br>
DAO command</b></td>
<td class=label width=18%><b>Microsoft Jet 2</b><i>.x</i><b> lock hex</b></td>
<td class=label width=24%><b><br>
Description</b></td>
<td class=label width=19%><b>Microsoft Jet 3.0 lock hex</b></td>
<td class=label width=22%><b><br>
Description</b></td>
</tr>
<tr valign=top>
<td width=17%><b>INSERT</b></td>
<td width=18%>20041A00–<br>
20041B00</td>
<td width=24%>Write lock on table header page</td>
<td width=19%>2003BE01–<br>
2003BF01</td>
<td width=22%>Write lock on last data page</td>
</tr>
<tr valign=top>
<td width=17%></td>
<td width=18%>20041C00–<br>
20041D00</td>
<td width=24%>Write lock on last data page of Shippers table</td>
<td width=19%>2003C401–<br>
2003C501</td>
<td width=22%>Write lock on PK index page for counter column</td>
</tr>
<tr valign=top>
<td width=17%></td>
<td width=18%>20041E00–<br>
20041F00</td>
<td width=24%>Write lock on PK index page for counter column in Shippers table</td>
<td width=19%>4003BA01–<br>
4003BA01</td>
<td width=22%>Table-read lock on Shippers table</td>
</tr>
<tr valign=top>
<td width=17%></td>
<td width=18%>30041E00–<br>
30041E00</td>
<td width=24%>Read lock on PK index page for counter column in Shippers table</td>
<td width=19%>5003BA01–<br>
5003BA01</td>
<td width=22%>Table-write lock on Shippers table</td>
</tr>
<tr valign=top>
<td width=17%></td>
<td width=18%>40041A01–<br>
40041A01</td>
<td width=24%>Table-read lock on Shippers table</td>
<td width=19%></td>
<td width=22%></td>
</tr>
<tr valign=top>
<td width=17%></td>
<td width=18%>50041A01–<br>
50041A01</td>
<td width=24%>Table-write lock on Shippers table</td>
<td width=19%></td>
<td width=22%></td>
</tr>
</table><br>
<h3>Inserting Rows with a Counter</h3>
<p>
The following code example and lock log (Table 6) illustrate some of the types of locks placed when inserting rows with a <b>Counter</b> data type.</p>
<pre><code>Sub InsertCounter()
 &nbsp;&nbsp; 'This code example is intended to be run from Access 7.0 or VB 4.0.
 &nbsp;&nbsp; Set ws = Workspaces(0)
 &nbsp;&nbsp; Dim SQLStr AS String
 &nbsp;&nbsp; SQLStr = "INSERT INTO Categories ([Category Name], Description, "
 &nbsp;&nbsp; SQLStr = SQLStr &amp; "Picture) VALUES ('CounterLock', 'CounterLock', NULL)"
 &nbsp;&nbsp; ws.BeginTrans
 &nbsp;&nbsp; db.Execute SQLStr, dbFailOnError
 &nbsp;&nbsp; ws.CommitTrans
End Sub
</code></pre>
<p class=label>
<b>Table 6</b></p>
<table border=1 cellpadding=5 cols=5 frame=below rules=rows>
<tr valign=top>
<td class=label width=14%><b>DAO command</b></td>
<td class=label width=18%><b>Microsoft Jet 2</b><i>.x</i><b> lock hex</b></td>
<td class=label width=24%><b><br>
Description</b></td>
<td class=label width=19%><b>Microsoft Jet 3.0 lock hex</b></td>
<td class=label width=25%><b><br>
Description</b></td>
</tr>
<tr valign=top>
<td width=14%><b>INSERT</b></td>
<td width=18%>20003C00–<br>
20003D00</td>
<td width=24%>Write lock on TBH page for Categories table</td>
<td width=19%>20004601–<br>
20004701</td>
<td width=25%>Write lock on data page for Categories table</td>
</tr>
<tr valign=top>
<td width=14%></td>
<td width=18%>20004A00–<br>
20004B00</td>
<td width=24%>Write lock on data page for Categories table</td>
<td width=19%>20009C01–<br>
20009D01</td>
<td width=25%>Write lock on index page for Categories table</td>
</tr>
<tr valign=top>
<td width=14%></td>
<td width=18%>2000A000–<br>
2000A100</td>
<td width=24%>Write lock on index page for Categories table</td>
<td width=19%>20009E01–<br>
20009F01</td>
<td width=25%>Write lock on index page for Categories table</td>
</tr>
<tr valign=top>
<td width=14%></td>
<td width=18%>2000A200–<br>
2000A300</td>
<td width=24%>Write lock on index page for Categories table</td>
<td width=19%></td>
<td width=25%></td>
</tr>
<tr valign=top>
<td width=14%></td>
<td width=18%>40003C01–<br>
40003C01</td>
<td width=24%>Shared read lock on Categories table</td>
<td width=19%>40003401–<br>
40003401</td>
<td width=25%>Shared read lock on Categories table</td>
</tr>
<tr valign=top>
<td width=14%></td>
<td width=18%>50003C01–<br>
50003C01</td>
<td width=24%>Shared write lock on Categories table</td>
<td width=19%>50003401–<br>
50003401</td>
<td width=25%>Shared write lock on Categories table</td>
</tr>
</table><br>
<h3>Deleting Rows</h3>
<p>
The following code example and lock log (Table 7) demonstrate the types of locks placed when making a deletion.</p>
<pre><code>Sub DeleteRow()
 &nbsp;&nbsp; 'This code example is intended to be run from Access 7.0 or VB 4.0.
 &nbsp;&nbsp; Set ws = Workspaces(0)
 &nbsp;&nbsp; ws.BeginTrans
 &nbsp;&nbsp; db.Execute _
 &nbsp;&nbsp; "DELETE ROWS FROM Customers WHERE [Customer Id] = 'Paris'", _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dbFailOnError
 &nbsp;&nbsp; DBEngine.Idle dbFreeLocks
 &nbsp;&nbsp; ws.CommitTrans
End Sub
</code></pre>
<p class=label>
<b>Table 7</b></p>
<table border=1 cellpadding=5 cols=5 frame=below rules=rows>
<tr valign=top>
<td class=label width=16%><b>DAO <br>
command</b></td>
<td class=label width=18%><b>Microsoft Jet 2</b><i>.x</i><b> lock hex</b></td>
<td class=label width=23%><b><br>
Description</b></td>
<td class=label width=18%><b>Microsoft Jet 3.0 lock hex</b></td>
<td class=label width=25%><b><br>
Description</b></td>
</tr>
<tr valign=top>
<td width=16%><b>DELETE</b></td>
<td width=18%>20003400–<br>
20003500</td>
<td width=23%>Write lock on data page for table MSysObjects</td>
<td width=18%>20002E01–<br>
20002F01</td>
<td width=25%>Write lock on data page for table MSysObjects</td>
</tr>
<tr valign=top>
<td width=16%></td>
<td width=18%>2000A600–<br>
2000A700</td>
<td width=23%>Write lock on TBH page for Customers table</td>
<td width=18%>2000AC01–<br>
2000AD01</td>
<td width=25%>Write lock on data page for Customers table</td>
</tr>
<tr valign=top>
<td width=16%></td>
<td width=18%>2000B400–<br>
2000B500</td>
<td width=23%>Write lock on data page for Customers table</td>
<td width=18%>2000B401–<br>
2000B501</td>
<td width=25%>Write lock on index page for Customers table</td>
</tr>
<tr valign=top>
<td width=16%></td>
<td width=18%>2000BA00–<br>
2000BB00</td>
<td width=23%>Write lock on index page for Customers table</td>
<td width=18%>2000B601–<br>
2000B701</td>
<td width=25%>Write lock on index page for Customers table</td>
</tr>
<tr valign=top>
<td width=16%></td>
<td width=18%>2000BE00–<br>
2000BF00</td>
<td width=23%>Write lock on index page for Customers table</td>
<td width=18%>2000B801–<br>
2000B901</td>
<td width=25%>Write lock on index page for Customers table</td>
</tr>
<tr valign=top>
<td width=16%></td>
<td width=18%>2000C200–<br>
2000C300</td>
<td width=23%>Write lock on index page for Customers table</td>
<td width=18%>2000BC01–<br>
2000BD01</td>
<td width=25%>Write lock on index page for Customers table</td>
</tr>
<tr valign=top>
<td width=16%></td>
<td width=18%>2000C400–<br>
2000C500</td>
<td width=23%>Write lock on index page for Customers table</td>
<td width=18%>2000BE01–<br>
2000BF01</td>
<td width=25%>Write lock on index page for Customers table</td>
</tr>
<tr valign=top>
<td width=16%></td>
<td width=18%></td>
<td width=23%></td>
<td width=18%>200CE201–<br>
200CE301</td>
<td width=25%>Write lock on data page for table MsysObjects</td>
</tr>
<tr valign=top>
<td width=16%></td>
<td width=18%></td>
<td width=23%></td>
<td width=18%>200CE401–<br>
200CE501</td>
<td width=25%>Write lock on long value page for temporary query</td>
</tr>
<tr valign=top>
<td width=16%></td>
<td width=18%>3000BA01–<br>
3000BA01</td>
<td width=23%>Read lock on index page for Customers table</td>
<td width=18%></td>
<td width=25%></td>
</tr>
<tr valign=top>
<td width=16%></td>
<td width=18%>3000BE01–<br>
3000BE01</td>
<td width=23%>Read lock on index page for Customers table</td>
<td width=18%></td>
<td width=25%></td>
</tr>
<tr valign=top>
<td width=16%></td>
<td width=18%>3000C201–<br>
3000C201</td>
<td width=23%>Read lock on index page for Customers table</td>
<td width=18%></td>
<td width=25%></td>
</tr>
<tr valign=top>
<td width=16%></td>
<td width=18%>3000C401–<br>
3000C401</td>
<td width=23%>Read lock on index page for Customers table</td>
<td width=18%></td>
<td width=25%></td>
</tr>
<tr valign=top>
<td width=16%></td>
<td width=18%>4000A601–<br>
4000A601</td>
<td width=23%>Shared read lock on Customers TBH</td>
<td width=18%>4000A201–<br>
4000A201</td>
<td width=25%>Shared read lock on Customers TBH</td>
</tr>
<tr valign=top>
<td width=16%></td>
<td width=18%>5000A601–<br>
5000A601</td>
<td width=23%>Shared write lock on Customers TBH</td>
<td width=18%>5000A201–<br>
5000A201</td>
<td width=25%>Shared write lock on Customers TBH</td>
</tr>
<tr valign=top>
<td width=16%></td>
<td width=18%></td>
<td width=23%></td>
<td width=18%>400B8A01–<br>
400B8A01</td>
<td width=25%>Shared read lock on Orders TBH</td>
</tr>
</table><br>
<h3>Updating Rows in a Multitable Join</h3>
<p>
The following code example and lock log (Table 8) illustrate that write locks are placed on all tables involved in the join, even when only one column from one table is being modified.</p>
<pre><code>Sub UpdateJoin ()
 &nbsp;&nbsp; Dim SQLStr As String
 &nbsp;&nbsp; Dim ContactName As String
 &nbsp;&nbsp; SQLStr = "SELECT * FROM Customers AS C INNER JOIN "
 &nbsp;&nbsp; SQLStr = SQLStr &amp; "(Orders AS O INNER JOIN "
 &nbsp;&nbsp; SQLStr = SQLStr &amp; "[Order Details] AS OD ON "
 &nbsp;&nbsp; SQLStr = SQLStr &amp; "OD.[Order Id] = O.[Order Id]) ON "
 &nbsp;&nbsp; SQLStr = SQLStr &amp; "C.[Customer Id] = O.[Customer Id] "
 &nbsp;&nbsp; Set rs = db.OpenRecordset(SQLStr, dbOpenDynaset)
 &nbsp;&nbsp; rs.Edit
 &nbsp;&nbsp; ContactName = rs![Contact Name]
 &nbsp;&nbsp; rs![Contact Name] = ContactName
 &nbsp;&nbsp; rs.Update
 &nbsp;&nbsp; rs.Close
End Sub
</code></pre>
<p class=label>
<b>Table 8</b></p>
<table border=1 cellpadding=5 cols=5 frame=below rules=rows>
<tr valign=top>
<td class=label width=17%><b><br>
DAO command</b></td>
<td class=label width=18%><b>Microsoft Jet 2</b><i>.x</i><b> lock hex</b></td>
<td class=label width=22%><b><br>
Description</b></td>
<td class=label width=18%><b>Microsoft Jet 3.0 lock hex</b></td>
<td class=label width=25%><b><br>
Description</b></td>
</tr>
<tr valign=top>
<td width=17%><b>OpenRecordSet</b></td>
<td width=18%>4000A601–<br>
4000A601</td>
<td width=22%>Shared table-read lock on Customers table</td>
<td width=18%>4000A201–<br>
4000A201</td>
<td width=25%>Shared table-read lock on Customers table</td>
</tr>
<tr valign=top>
<td width=17%></td>
<td width=18%>40026201–<br>
40026201</td>
<td width=22%>Shared table-read lock on Order Details table</td>
<td width=18%>40024801–<br>
40024801</td>
<td width=25%>Shared table-read lock on Order Details table</td>
</tr>
<tr valign=top>
<td width=17%></td>
<td width=18%>40031C01–<br>
40031C01</td>
<td width=22%>Shared table-read lock on Orders table</td>
<td width=18%>40020C01–<br>
40020C01</td>
<td width=25%>Shared table-read lock on Orders table</td>
</tr>
<tr valign=top>
<td width=17%></td>
<td width=18%>5000A601–<br>
5000A601</td>
<td width=22%>Shared table-write lock on Customers table</td>
<td width=18%></td>
<td width=25%></td>
</tr>
<tr valign=top>
<td width=17%></td>
<td width=18%>50026201–<br>
50026201</td>
<td width=22%>Shared table-write lock on Order Details table</td>
<td width=18%></td>
<td width=25%></td>
</tr>
<tr valign=top>
<td width=17%></td>
<td width=18%>50031C01–<br>
50031C01</td>
<td width=22%>Shared table-write lock on Orders table</td>
<td width=18%></td>
<td width=25%></td>
</tr>
<tr valign=top>
<td width=17%><b>rs.Edit</b></td>
<td width=18%>2000AC00–<br>
2000AD00</td>
<td width=22%>Write lock on data page for Customers table</td>
<td width=18%>2000A601–<br>
2000A701</td>
<td width=25%>Write lock on data page for Customers table</td>
</tr>
<tr valign=top>
<td width=17%></td>
<td width=18%>2002A000–<br>
2002A100</td>
<td width=22%>Write lock on data page for Order Details table</td>
<td width=18%>20029801–<br>
20029901</td>
<td width=25%>Write lock on data page for Order Details table</td>
</tr>
<tr valign=top>
<td width=17%></td>
<td width=18%>2037C00–<br>
2037D00</td>
<td width=22%>Write lock on data page for Orders table</td>
<td width=18%>200365401–<br>
20035501</td>
<td width=25%>Write lock on data page for Orders table</td>
</tr>
<tr valign=top>
<td width=17%><b>rs.Update</b></td>
<td width=18%></td>
<td width=22%>All write locks removed.</td>
<td width=18%></td>
<td width=25%>All write locks removed.</td>
</tr>
</table><br>
<h2>Deciphering Read and Commit Locks (Microsoft Jet 2.<i>x</i>)</h2>
<p>
As stated previously, read and commit locks only occur in the 30-million-hex range. Read locks always start and end on the same byte and commit locks start and end between 256 and 512 bytes. To determine what page is being locked, use the 32-bit Visual Basic 4.0 DBLock program included with this article. To determine the user number, simply take the last two digits of the ending lock range and convert them to decimal form</p>
<h2>Deciphering Read and Commit Locks (Microsoft Jet 3.0)</h2>
<p>
To determine which page is being locked, use the DBLock program. To determine the user number, simply take the last two digits of the ending lock range and convert them to decimal.</p>
<p>
Following is a code sample and lock log (Table 9) of read locks that were placed while reading a picture from the NWIND database:</p>
<pre><code>Sub ReadLocks ()
 &nbsp;&nbsp; 'This example is intended to be run from Access 7.0 or VB 4.0.
 &nbsp;&nbsp; Dim Photo As Variant
 &nbsp;&nbsp; Dim db As Database
 &nbsp;&nbsp; Dim rs As RecordSet
 &nbsp;&nbsp; Set Db = OpenDatabase("NWIND.MDB", False, True)
 &nbsp;&nbsp; Set rs = db.OpenRecordset _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ("SELECT * FROM Employees", dbOpenDynaset)
 &nbsp;&nbsp; While Not rs.EOF
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Photo = rs!Photo
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DBEngine.Idle DBFreeLocks
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rs.MoveNext
 &nbsp;&nbsp; Wend
 &nbsp;&nbsp; rs.Close
End Sub
</code></pre>
<p class=label>
<b>Table 9</b></p>
<table border=1 cellpadding=5 cols=5 frame=below rules=rows>
<tr valign=top>
<td class=label width=18%><b><br>
DAO command</b></td>
<td class=label width=19%><b>Microsoft Jet 2</b><i>.x</i><b> lock hex</b></td>
<td class=label width=15%><b><br>
Description</b></td>
<td class=label width=19%><b>Microsoft Jet 3.0 lock hex</b></td>
<td class=label width=29%><b><br>
Description</b></td>
</tr>
<tr valign=top>
<td width=18%><b>OpenDatabase</b></td>
<td width=19%>10000001–<br>
10000001</td>
<td width=15%>User lock</td>
<td width=19%>10000001–<br>
10000001</td>
<td width=29%>User Lock</td>
</tr>
<tr valign=top>
<td width=18%><b>OpenRecordSet</b></td>
<td width=19%>4000CC01–<br>
4000CC01</td>
<td width=15%>Shared table-read lock</td>
<td width=19%>4000C801–<br>
4000C801</td>
<td width=29%>Shared table-read lock</td>
</tr>
<tr valign=top>
<td width=18%></td>
<td width=19%>5000CC01–<br>
5000CC02</td>
<td width=15%>Shared table-write lock</td>
<td width=19%></td>
<td width=29%></td>
</tr>
<tr valign=top>
<td width=18%><b>Photo = RS!Photo</b></td>
<td width=19%>3000D001–<br>
3000D001</td>
<td width=15%>Read lock on long value.</td>
<td width=19%>20063801–<br>
20063801</td>
<td width=29%>Read lock on long value.</td>
</tr>
<tr valign=top>
<td width=18%><b>DBEngine.Idle DBFreeLocks</b></td>
<td width=19%></td>
<td width=15%>Lock is removed.</td>
<td width=19%></td>
<td width=29%>Lock is persistent until <b>RS.MoveNext</b>. <b>DBFreeLocks</b> is an obsolete command in Microsoft Jet 3.0.</td>
</tr>
<tr valign=top>
<td width=18%><b>Repeat loop until EOF</b></td>
<td width=19%>3000E801–<br>
3000E801</td>
<td width=15%>Read lock on next long value.</td>
<td width=19%>2000E601–<br>
2000E601</td>
<td width=29%>Read lock on next long value.</td>
</tr>
<tr valign=top>
<td width=18%></td>
<td width=19%>30010001–<br>
30010001</td>
<td width=15%>" "</td>
<td width=19%>2000FC01–<br>
2000FC01</td>
<td width=29%>" "</td>
</tr>
<tr valign=top>
<td width=18%></td>
<td width=19%>30011801–<br>
30011801</td>
<td width=15%>" "</td>
<td width=19%>20011201–<br>
20011201</td>
<td width=29%>" "</td>
</tr>
<tr valign=top>
<td width=18%></td>
<td width=19%>30013001–<br>
30013001</td>
<td width=15%>" "</td>
<td width=19%>20012801–<br>
20012801</td>
<td width=29%>" "</td>
</tr>
<tr valign=top>
<td width=18%></td>
<td width=19%>30014801–<br>
30014801</td>
<td width=15%>" "</td>
<td width=19%>20013E01–<br>
20013E01</td>
<td width=29%>" "</td>
</tr>
<tr valign=top>
<td width=18%></td>
<td width=19%>30016001–<br>
30016001</td>
<td width=15%>" "</td>
<td width=19%>20015401–<br>
20015401</td>
<td width=29%>" "</td>
</tr>
<tr valign=top>
<td width=18%></td>
<td width=19%>30017801–<br>
30017801</td>
<td width=15%>" "</td>
<td width=19%>20016301–<br>
20016301</td>
<td width=29%>" "</td>
</tr>
<tr valign=top>
<td width=18%></td>
<td width=19%>30018E01–<br>
30018E01</td>
<td width=15%>" "</td>
<td width=19%>20018201–<br>
20018201</td>
<td width=29%>" "</td>
</tr>
<tr valign=top>
<td width=18%></td>
<td width=19%>3001A401–<br>
3001A401</td>
<td width=15%>" "</td>
<td width=19%>20019801–<br>
20019801</td>
<td width=29%>" "</td>
</tr>
<tr valign=top>
<td width=18%></td>
<td width=19%>3001BC01–<br>
3001BC01</td>
<td width=15%>" "</td>
<td width=19%>2001AE01–<br>
2001AE01</td>
<td width=29%>" "</td>
</tr>
<tr valign=top>
<td width=18%></td>
<td width=19%>3001D401–<br>
3001D401</td>
<td width=15%>" "</td>
<td width=19%>2001C401–<br>
2001C401</td>
<td width=29%>" "</td>
</tr>
<tr valign=top>
<td width=18%></td>
<td width=19%>3001EC01–<br>
3001EC01</td>
<td width=15%>" "</td>
<td width=19%>2001DA01–<br>
2001DA01</td>
<td width=29%>" "</td>
</tr>
<tr valign=top>
<td width=18%></td>
<td width=19%>30020601–<br>
30020601</td>
<td width=15%>" "</td>
<td width=19%>2001F201–<br>
2001F201</td>
<td width=29%>" "</td>
</tr>
<tr valign=top>
<td width=18%></td>
<td width=19%>30021E01–<br>
30021E01</td>
<td width=15%>" "</td>
<td width=19%>20020A01–<br>
20020A01</td>
<td width=29%>" "</td>
</tr>
</table><br>
<h2>Deciphering All Types of Table Locks</h2>
<p>
As stated previously, table locks occur in three ranges: 40, 50, and 60 million hex. Using the Customers table as an example, and assuming that the user below is the first user to connect to the database in shared mode, the following steps determine which table is being locked:
<ol>
<li>
Open the Customers table with the <b>OpenRecordSet</b> method, using the shared table-read lock at 4000A601 as a reference.<br><br></li>
<li>
Drop the first digit (4000A601 becomes A601).<br><br></li>
<li>
Drop the last two digits (A601 becomes A6).<br><br></li>
<li>
Divide by two (A6 hex / 2 hex = 53 hex) and convert to decimal (83) to get the tableid.<br><br></li>
<li>
Browse MSysObjects.Id for value 83, and then look at MSysObjects.Name in the rows identified to determine the table name.</li>
</ol>
<p>
The same information can be obtained by using the 32-bit Visual Basic 4.0 utility included with this article.</p>
<p>
Below is the lock log (Table 10) for the following commands:</p>
<pre><code>Sub TableDenyRead ()
 &nbsp;&nbsp; 'This example is intended to be run from Access 7.0 or VB 4.0.
 &nbsp;&nbsp; Dim db As Database
 &nbsp;&nbsp; Dim rs As Recordset
 &nbsp;&nbsp; Set db = OpenDatabase("NWind.mdb", false, false)
 &nbsp;&nbsp; Set rs = db.OpenRecordset _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ("Customers", dbOpenTable, dbDenyRead)
End Sub
</code></pre>
<p class=label>
<b>Table 10</b></p>
<table border=1 cellpadding=5 cols=5 frame=below rules=rows>
<tr valign=top>
<td class=label width=19%><b><br>
DAO command</b></td>
<td class=label width=19%><b>Microsoft Jet 2</b><i>.x</i><b> lock hex</b></td>
<td class=label width=17%><b><br>
Description</b></td>
<td class=label width=17%><b>Microsoft Jet 3.0 lock hex</b></td>
<td class=label width=28%><b><br>
Description</b></td>
</tr>
<tr valign=top>
<td width=19%><b>OpenDatabase</b></td>
<td width=19%>10000001–<br>
10000001</td>
<td width=17%>User lock</td>
<td width=17%>10000001–<br>
10000001</td>
<td width=28%>User lock</td>
</tr>
<tr valign=top>
<td width=19%><b>OpenRecordSet</b></td>
<td width=19%>4000A600–<br>
4000A700</td>
<td width=17%>Exclusive table-read lock</td>
<td width=17%>4000A201–<br>
4000A301</td>
<td width=28%>Exclusive table-read lock</td>
</tr>
</table><br>
<p>
Below is the lock log (Table 11) for the following commands:</p>
<pre><code>Sub TableDenyWrite ()
 &nbsp;&nbsp; 'This example is intended to be run from Access 7.0 or VB 4.0.
 &nbsp;&nbsp; Dim db As Database
 &nbsp;&nbsp; Dim rs As Recordset
 &nbsp;&nbsp; Set db = OpenDatabase("NWind.mdb", false, false)
 &nbsp;&nbsp; Set rs = db.OpenRecordset _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ("Customers", dbOpenTable, dbDenyWrite)
End Sub
</code></pre>
<p class=label>
<b>Table 11</b></p>
<table border=1 cellpadding=5 cols=5 frame=below rules=rows>
<tr valign=top>
<td class=label width=18%><b><br>
DAO command</b></td>
<td class=label width=20%><b>Microsoft Jet 2</b><i>.x</i><b> lock hex</b></td>
<td class=label width=16%><b><br>
Description</b></td>
<td class=label width=19%><b>Microsoft Jet 3.0 lock hex</b></td>
<td class=label width=27%><b><br>
Description</b></td>
</tr>
<tr valign=top>
<td width=18%><b>OpenDatabase</b></td>
<td width=20%>10000001–<br>
10000001</td>
<td width=16%>User lock</td>
<td width=19%>10000001–<br>
10000001</td>
<td width=27%>User lock</td>
</tr>
<tr valign=top>
<td width=18%><b>OpenRecordSet</b></td>
<td width=20%>4000A601–<br>
4000A601</td>
<td width=16%>Shared table-read lock</td>
<td width=19%>4000A201–<br>
4000A201</td>
<td width=27%>Shared table-read lock</td>
</tr>
<tr valign=top>
<td width=18%></td>
<td width=20%>5000A601–<br>
5000A601</td>
<td width=16%>Shared table-write lock</td>
<td width=19%>5000A201–<br>
5000A201</td>
<td width=27%>Shared table-write lock</td>
</tr>
<tr valign=top>
<td width=18%></td>
<td width=20%>6000A601–<br>
6000A601</td>
<td width=16%>Table deny-write lock</td>
<td width=19%>6000A201–<br>
6000A201</td>
<td width=27%>Table deny-write lock</td>
</tr>
</table><br>
<h2>Using the Utilities</h2>
<p>
All the utilities referenced in this paper are included with this article.</p>
<h3>LDBView</h3>
<p>
You can use the LDBView utility (Figure 1) to accomplish the following tasks:
<ul type=disc>
<li>
Discover which users have been connected to the database and what users are currently connected to the database.<br><br></li>
<li>
Discover the values of the commit bytes in the DBH.<br><br></li>
<li>
Determine which user(s) have left the database in a suspect state.</li>
</ul>
<p>
<img src="jetlock_1.gif" border=0></p>
<p class=label>
<b>Figure 1</b></p>
<p>
LDBView is a 32-bit single .EXE utility that can run under either Windows 95 or Windows NT and can view both Microsoft Jet 2<i>.x</i> and Microsoft Jet 3.0 databases. In order for the utility to run, a corresponding .LDB file must be present.</p>
<p>
To use the utility, click the database that you want to view from the File menu. After selecting a database, a screen similar to that in Figure 1 appears. At this point, you can modify the refresh interval by selecting values on the View menu. Changing these values determines how often LDBView looks at and reads and displays information from the selected database and corresponding .LDB file.</p>
<h3>DBLock</h3>
<p>
The DBLock utility (Figure 2) determines which types of locks that Microsoft Jet places, which page types are being locked, and which tables are associated with those pages. By using a utility, such as NetWare's Monitor utility, you can immediately enter a beginning lock range and determine what effect a particular command would have on other users. You can also use this utility to help determine what bottlenecks exist when users experience locking conflicts. You can then use this information to modify the application or database design (by removing unnecessary indexes, for example).</p>
<p>
<img src="jetlock_2.gif" border=0></p>
<p class=label>
<b>Figure 2</b></p>
<p>
DBLock is a 32-bit Visual Basic 4.0 utility that runs under either Windows 95 or Windows NT and can work against both Microsoft Jet 2<i>.x</i> and Microsoft Jet 3.0 databases. The Setup program installs the Microsoft Jet DLLs necessary to run this program. By default, DBLock installs a default SYSTEM.MDA (security file for Microsoft Jet 2<i>.x</i>) and a default SYSTEM.MDW (security file for Microsoft Jet 3.0). If you have an unsecured database, the utility grants rights to MSysObjects for user Admin. If you have a secured database, you need to use the Tools menu to point to the path of your security database.</p>
<p>
After a database has been selected, simply enter in the hexadecimal values that appear (on the NetWare Monitor utility, for example) and the information for the table name, page type, available page space, and type of lock is populated.</p>
<h3>MSLDBUSR.DLL</h3>
<p>
This 32-bit DLL enables you to retrieve one of the most often-sought pieces of information: a list of users connected to the database. This was previously impossible to do programmatically unless a programmer understood the user lock algorithm and understood how to place extended byte range locks. Because this is a 32-bit DLL, it works only with 32-bit products (such as Microsoft Access 7.0, Visual Basic 4.0, Microsoft Excel 7.0, and Visual C++®) running on Windows 95 or Windows NT. However, it retrieves information for both Microsoft Jet 2<i>.x</i> and Microsoft Jet 3.0 databases. MSLDBUSR.DLL enables your application to display a list of users who are preventing you from opening the database exclusively or running a repair or a compact.</p>
<p>
Because the DLL places real-time extended byte range locks, the information that it retrieves can be out of date as soon as another user logs out, but recalling the DLL always provides current information.</p>
<p>
Figure 3 is a screen shot of a sample Visual Basic 4.0 utility (LDBUsrDLL.VBP) that includes source code on how to use the DLL. Figure 4 shows a screen shot of a sample Microsoft Access 7.0 database (provided by Michael Kaplan).</p>
<p>
<img src="jetlock_3.gif" border=0></p>
<p class=label>
<b>Figure 3</b></p>
<p>
To use MSLDBUSR.DLL, simply select a database file and choose an option under LDB User Options. Then click Execute or Refresh, which calls the function <b>LDBUser_GetUsers</b>. To view error codes and descriptions, click the Show Viewer button, which calls the <b>LDBUser_GetError</b> function. This utility does not work against library or wizard databases, because those are opened exclusively and the Show Users That Left Database in a Suspect State option needs to open the database in a shared mode.</p>
<p>
<img src="jetlock_4.gif" border=0></p>
<p class=label>
<b>Figure 4</b></p>
<p>
The above screen shot uses the LDB700.MDB database from Microsoft Access 7.0. For the utility to work properly, it is necessary to have the MSLDBUSR.DLL in the path or the SYSTEM directory.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;To use the DLL you must make the following two function declarations. These must go into your module (this cannot be a form module), and the DLL must be located in the SYSTEM directory.</p>
<pre><code>Declare Function LDBUser_GetUsers Lib "MSLDBUSR.DLL"
 &nbsp;&nbsp; (lpszUserBuffer() As String, ByVal lpszFilename As String,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ByVal nOptions As Long) As Integer
Declare Function LDBUser_GetError Lib "MSLDBUSR.DLL"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (ByVal nErrorNo As Long) As String
</code></pre>
<p>
The following options can be called from the function <b>LDBUser_GetUsers</b>:</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td width=26%>Public Const <b>OptAllLDBUsers</b> </td>
<td width=11%>&amp;H1</td>
<td width=63%>Returns a list of users in the .LDB file. This option opens the .LDB file and returns each user one by one and then adds him/her to the array list. This option does not check to see whether the users currently have the database open. It essentially represents users who at one time or another had the database open. It also does not represent all users who have ever had the database open.</td>
</tr>
<tr valign=top>
<td width=26%>Public Const <b>OptLDBLoggedUsers</b> </td>
<td width=11%>&amp;H2</td>
<td width=63%>Shows all .LDB users who currently have the database open. This is similar to <b>OptAllLDBUsers</b>, except it checks to make sure that the users listed in the .LDB file have the database opened. Often, <b>OptAllLDBUsers</b> and <b>OptLDBLoggedUsers</b> show the same list.</td>
</tr>
<tr valign=top>
<td width=26%>Public Const <b>OptLDBCorruptUsers</b> </td>
<td width=11%>&amp;H4</td>
<td width=63%>Shows all user(s) who left the database in a suspect state.</td>
</tr>
<tr valign=top>
<td width=26%>Public Const <b>OptLDBUserCount</b> </td>
<td width=11%>&amp;H8</td>
<td width=63%>Returns a list of users connected to the database. (Note that you still must include an array and .LDB filename.)</td>
</tr>
<tr valign=top>
<td width=26%>Public Const <b>OptLDBUserAuthor</b></td>
<td width=11%>&amp;HB0B</td>
<td width=63%>Invokes the credits screen when using -Z as the .LDB filename.</td>
</tr>
</table><br>
<p>
Here is some sample Visual Basic for Applications code that gets the first user in the .LDB file:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;'The DLL must be in the SYSTEM directory or have a path referencing it.
Declare Function LDBUser_GetUsers Lib "MSLDBUSR.DLL" _
 &nbsp;&nbsp; (lpszUserBuffer() As String, ByVal lpszFilename As String, _
 &nbsp;&nbsp; ByVal nOptions As Long) As Integer
Declare Function LDBUser_GetError Lib "MSLDBUSR.DLL" _
 &nbsp;&nbsp; (ByVal nErrorNo As Long) As String
Public Const OptAllLDBUsers = &amp;H1
Public Const OptLDBLoggedUsers = &amp;H2
Public Const OptLDBCorruptUsers = &amp;H4
Public Const OptLDBUserCount = &amp;H8
Public Const OptLDBUserAuthor = &amp;HB0B
Sub Main()
 &nbsp;&nbsp; 'It is important that ReDim is used to define the array as the DLL,
 &nbsp;&nbsp; 'because the DLL depends on being able to redimension the array.
 &nbsp;&nbsp; ReDim msString(1) As String
 &nbsp;&nbsp; 'The array is 1-based rather then 0-based, regardless if Option Base 1
 &nbsp;&nbsp; 'is specified in the declarations section.
 &nbsp;&nbsp; Dim miLoop As Integer
 &nbsp;&nbsp; Dim LDBReturn As String
 &nbsp;&nbsp; Dim LDBName As String
 &nbsp;&nbsp; LDBName = InputBox _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ("Enter a LDB name", " ", "c:nwind.mdb")
 &nbsp;&nbsp; miLoop = LDBUser_GetUsers(msString, LDBName, OptAllLDBUsers)
 &nbsp;&nbsp; 'The function calls cannot be combined and must be used individually.
 &nbsp;&nbsp; 'Get the first user in the selected .LDB file.
 &nbsp;&nbsp; LDBReturn = msString(1)
 &nbsp;&nbsp; MsgBox ("Total number of users in .LDB file is: " &amp; miLoop &amp; _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ". The first computer name in .LDB file is " _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp; LDBReturn &amp; ".")
End Sub
</code></pre>
</BODY>
</HTML>
