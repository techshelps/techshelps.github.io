<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The Foundations of Microsoft Windows NT System Architecture</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_ntfound"></a>The Foundations of Microsoft Windows NT System Architecture</h1>
<p>
Microsoft Corporation</p>
<p>
September 1997</p>
<h2>Abstract</h2>
<p>
This paper explains the primary design goals of Microsoft® Windows&nbsp;NT®—robustness, extensibility, and maintainability—and explains how these attributes informed and directed each aspect of the initial system design and its development over the last several years. Windows&nbsp;NT was designed to provide a solid foundation for future development efforts by Microsoft and the larger development community. This paper describes the original design process, provides a high-level overview of the architecture, and concludes with a real-world example of the coding standards implemented and maintained by the Windows&nbsp;NT design team.</p>
<h2>Introduction</h2>
<p>
From its inception, Microsoft Windows&nbsp;NT was designed to be a robust, portable operating system that would be maintainable, flexible, and secure over time. This paper describes the design decisions that were made during the initial planning of Windows&nbsp;NT; describes each of the design goals in priority order (as documented in the original design documentation, "NT OS/2 Subsystem Design Rationale," [June 1989]); and describes how these goals were met in the system architecture. Finally, the paper provides an example of a subsystem component specifically designed to meet the goals of robustness and maintainability over time.</p>
<h3>The Mission</h3>
<p>
When the Windows&nbsp;NT development team was formed in 1989, it had a clear mission<i>: to design and build a personal computer operating system that would meet the current and future operating system needs of the PC platform.</i> To meet this objective, the design team identified the following market requirements:
<ul type=disc>
<li>
To provide easy portability to other 32-bit architectures<br><br></li>
<li>
To provide scalability and multiprocessing support<br><br></li>
<li>
To support distributed computing, allowing multiple computers to share resources<br><br></li>
<li>
To support the application programming interfaces (APIs) required by the Portable Operating System Interface for UNIX (POSIX)<br><br></li>
<li>
To provide U.S. government Class 2 (C2) security features, and to provide a path to Class B1 and beyond</li>
</ul>
<h3>The Design Goals</h3>
<p>
Based on market requirements and Microsoft's development strategy, the original Microsoft NT design team established a set of prioritized goals. Note that from the outset, the priority design objectives of Windows&nbsp;NT were <i>robustness</i> and <i>extensibility</i>:
<ol>
<li>
<b>Robustness.</b> The operating system must actively protect itself from internal malfunction and external damage (whether accidental or deliberate), and must respond predictably to software and hardware errors. The system must be straightforward in its architecture and coding practices, and interfaces and behavior must be well specified.<br><br></li>
<li>
<b>Extensibility and maintainability.</b> Windows&nbsp;NT must be designed with the future in mind. It must grow to meet the future needs of original equipment manufacturers (OEMs) and of Microsoft. And the system must be designed for maintainability—it must accommodate changes and additions to the API sets it supports and the APIs should not employ flags or other devices that drastically alter their functionality.<br><br></li>
<li>
<b>Portability.</b> The system architecture must be able to function on a number of platforms with minimal recoding.<br><br></li>
<li>
<b>Performance.</b> Algorithms and data structures that lead to a high level of performance and that provide the flexibility needed to achieve our other goals must be incorporated into the design.<br><br></li>
<li>
<b>POSIX compliance and government certifiable C2 security.</b> The POSIX standard calls for operating system vendors to implement UNIX-style interfaces so that applications can be moved easily from one system to another. U.S. government security guidelines specify certain protections such as auditing capabilities, access detection, per-user resource quotas, and resource protection. Inclusion of these features would allow Windows&nbsp;NT to be used in government operations.</li>
</ol>
<h3>Design Alternatives</h3>
<p>
With its primary goals in mind, the development team investigated several alternatives during the design phase.</p>
<p>
The first design layered the POSIX API set over a slightly extended OS/2 API set. (Originally, the operating system was to have an OS/2-style user interface and was to provide the OS/2 API as its primary programming interface. However, due largely to the greater popularity of Microsoft Windows®, Microsoft refocused its strategy and developed the Microsoft Win32® API, a 32-bit programming interface for the development of next-generation applications.) As the design progressed, it became clear that it would result in a system that would not be robust, easily maintained, or extensible. A similar attempt during the development of OS/2 led to considerable change in the base system capabilities, which further strengthened the team's conclusion that this was a poor alternative.</p>
<p>
The next design implemented both OS/2 and POSIX API sets directly in the Windows&nbsp;NT executive. This was an improvement on the previous design, but the large number of oddly structured and tricky interfaces required by this design threatened the goals of extensibility and maintainability.</p>
<p>
The third design implemented OS/2 and POSIX as protected subsystems outside the Windows&nbsp;NT executive. This type of client/server architecture had been successful in the academic community and at other research sites, largely because it decoupled the more volatile services from the operating-system kernel—thus preserving the integrity of the operating system while allowing system services to grow and change as necessary. After analysis and an extended mock up and test cycle, it became clear that this design would provide<code> </code>the robustness, extensibility, maintainability, portability, and performance that the new operating system required.</p>
<p>
The next section of this document provides an overview of Windows&nbsp;NT architecture, particularly as it relates to the crucial design goals of system robustness and maintainability over time.</p>
<h2>The Windows&nbsp;NT Design</h2>
<p>
The Windows&nbsp;NT system design consists of a highly functional executive, which runs in privileged processor (or <i>kernel</i>) mode and provides system services and internal processes, and a set of nonprivileged servers called <i>protected subsystems, </i>which run in nonprivileged (or <i>user</i>) mode outside of the executive. Note that the executive provides the only entry point into the system—there are no back door entry points that could compromise security or damage the system in any way.</p>
<p>
A protected subsystem executes in user mode as a regular (native) process. The subsystem may have extended privileges as compared to an application, but it is not considered a part of the executive and, therefore, cannot bypass the system security architecture or corrupt the system in any other way. Subsystems communicate with their clients and each other using high-performance local procedure calls (LPCs).</p>
<p>
The NT executive includes a set of system service components—the Object Manager, the Security Reference Monitor, the Process Manager, and so forth—which are exposed through a set of API-like system services. While the executive performs some internal routines, it is primarily responsible for taking an existing process thread from a requesting subsystem or application, validating that the thread should be processed, executing it, and then returning control of the thread to the requestor.</p>
<h3>Maintainability and Extensibility over Time</h3>
<p>
The following efforts ensure that Windows&nbsp;NT meets its goals of maintainability and extensibility:
<ul type=disc>
<li>
The original developers of Windows&nbsp;NT designed the system to be simple and provided extensive code documentation. This, coupled with a common coding standard used throughout the system, has enabled subsequent programmers to work on any piece of the system without having to consult a system expert to learn about hidden rules, side effects, magical programming tricks, or Windows&nbsp;NT folklore. The code is straightforward, as is the documentation.<br><br></li>
<li>
By using subsystems to implement major portions of the system, Windows&nbsp;NT isolates and controls dependencies. For example, the only piece of the system affected by a change to the POSIX standard is the POSIX subsystem. The design of the process structure, memory management, synchronization primitives, and so on, are not affected.<br><br></li>
<li>
The Windows&nbsp;NT design accommodates change and growth. Subsystems that provide additional functionality can be added to the system without impacting the base system. New subsystems can be added without modifications to the Windows&nbsp;NT executive;<code> </code>for example, new subsystems can be added to allow limited support for operating system environments other than the Microsoft-provided MS-DOS®, OS/2, Win32, and POSIX environments. Moreover, the executive itself is modular in design—because its components are independent from each other and interact in predictable ways, and because the interfaces between these components are so carefully controlled, it is possible to replace a component without adversely impacting the system. If the new version implements all of the system services and internal interfaces correctly, the operating system will function as before.<br><br></li>
<li>
Perhaps most importantly, all subsystems can be coded to take advantage of the security features provided in Windows&nbsp;NT.</li>
</ul>
<p>
Figure 1 illustrates the basic architecture of the operating system through version 3.51 (note that only a few of the subsystems are illustrated).</p>
<p>
<img src="ntfound01.gif" border=0></p>
<p class=label>
<b>Figure 1. Windows&nbsp;NT basic architecture—version 3.51 and earlier</b></p>
<p>
In Windows&nbsp;NT 4.0, much of the Win32 graphical user interface (GUI) subsystem—the Window Manager, Graphics Device Interface (GDI), and related graphics drivers—were moved from a body of code that executed in the csrss.exe subsystem process to a kernel-mode device driver (win32k.sys). The console, shutdown, and hard error-handling portions remain in user mode. This change significantly improves system performance while decreasing memory requirements, and has no impact on application developers. Applications now access the GUI implementation subsystems just as they access other system services, such as input/output (I/O) and memory management. This change only serves to demonstrate the maintainability and flexibility of the Windows&nbsp;NT modular design.</p>
<p>
<img src="ntfound02.gif" border=0></p>
<p class=label>
<b>Figure 2. Windows&nbsp;NT basic architecture—version 4.0</b></p>
<h3>Built-in Robustness</h3>
<p>
Windows&nbsp;NT meets its primary goal of robustness as follows:
<ul type=disc>
<li>
The kernel-mode portion of the system exports well-defined APIs that, in general, do not have mode parameters or other magic flags. Therefore, the APIs are simple to implement, easy to test, and easy to document.<br><br></li>
<li>
A formal design document was produced for all portions of the Windows&nbsp;NT system prior to coding. This effort led to well-documented interfaces for native services and internal functions.<br><br></li>
<li>
The partitioning of major components, such as Win32, OS/2, and POSIX, into separate subsystems resulted in simple, elegant designs for these subsystems. Each subsystem implements only those features needed to provide its API set.<br><br></li>
<li>
The prevalent use of frame-based exception handlers (exception handlers associated with a particular procedure or part of a procedure) allows Windows&nbsp;NT and its subsystems to catch programming errors and filter bad or inaccessible parameters in an efficient and reliable manner.</li>
</ul>
<p>
The division of the operating system into kernel-mode system services and subsystems adds a layer of validation to ensure that poorly behaved applications can't crash the operating system.</p>
<p>
The next section of this document describes the argument-probing and capture requirements to which all system services must adhere. The requirements described here are part of a living document that has existed since the project began in 1989, and serve to illustrate Microsoft's longstanding commitment to robustness and maintainability in the Windows&nbsp;NT code base.</p>
<h2>Argument Validation in Windows&nbsp;NT</h2>
<p>
Since its inception, Windows&nbsp;NT development has required that system services be robust and provide protection against malicious attack and inadvertent program bugs. To meet the goal of robustness, it must not be possible to crash or corrupt the system by passing an invalid argument value, by passing a pointer to memory that is not accessible to the caller, or by dynamically altering or deleting the memory occupied by an argument in a simultaneously executing thread.</p>
<p>
The next few subsections detail some of the standards and coding practices used in the development of past and future versions of Windows&nbsp;NT.</p>
<h3>System-Service Requirement</h3>
<p>
To ensure robust system operation, each system service must ensure that the arguments on which it operates are valid (that is, the values are correct). This requires the service to capture the values and probe the argument addresses at appropriate points. In general, a system service should capture all arguments at the outset. This ensures that the caller or one of its threads cannot dynamically alter the value of the argument after it has been read and verified, or delete the memory in which it is contained.</p>
<p>
In some cases, it is not necessary to capture the value of an argument immediately. Such is the case for I/O buffers and name strings. However, all pointers MUST be captured and the addresses to which they point MUST be probed for accessibility.</p>
<p>
Fortunately, most arguments do not need explicit capture since they are passed in registers. Arguments that are passed in memory are probed and captured by the system service dispatcher as necessary.</p>
<h3>Address-Space Layout</h3>
<p>
The address-space layout of Windows&nbsp;NT clearly separates user address space from system address space.</p>
<p>
All addresses above the boundary are system addresses and all addresses below the boundary are user addresses. Furthermore, at the boundary between user address space and system address space, there is a 64K barrier that is inaccessible to both modes. With this address-space design, it is possible to determine whether an address is a valid user address simply by comparing boundaries.</p>
<p>
Pages in the system part of the address space are owned by kernel mode and are not accessible to the user unless they are double-mapped into the user portion of the address space. Pages in the user part of the address space are owned by user mode. The executive <i>never</i> creates a page that is owned by kernel mode in the user part of the address space.</p>
<h3>System-Service Operation</h3>
<p>
System-service operation should occur as described in the following paragraphs.</p>
<p>
When a system service is called, the trap handler gets control, saves state, and transfers control to the system-service dispatcher. The system-service dispatcher determines which system service is being called, and obtains the address of the appropriate function and the number of in-memory arguments from a dispatch table.</p>
<p>
If the previous processor mode is <i>user</i> and there is one or more in-memory arguments, the in-memory argument list is probed and copied to the kernel stack.
<ul type=disc>
<li>
If an access violation occurs during the copy, the system service finishes with a status of "Access Violation."<br><br></li>
<li>
If an access violation does not occur, the pointer to the in-memory argument list is changed to point to the copy of the arguments on the kernel stack.</li>
</ul>
<p>
The system service dispatcher sets up a catchall condition handler and then calls the system service function.</p>
<p>
The system service establishes an exception handler. This handler should handle any access violation that may occur as argument pointers are dereferenced to read or write actual argument values.</p>
<p>
The system service obtains the previous processor mode.
<ul type=disc>
<li>
If the previous mode was <i>kernel</i>, there is no need to probe any arguments. The executive does not call one of its own services and provide bad arguments.<br><br></li>
<li>
If the previous mode was <i>user</i>, any argument values that are read or written by dereferencing a pointer must be probed for accessibility. To probe a pointer, the service first ensures that the address of the variable is within the user's address space, and then reads or writes the variable as appropriate. The code that actually probes pointer-related arguments does not set up a condition handler. It merely does a boundary check and then reads or writes the indicated location. If the boundary check fails or if the memory is inaccessible, an access violation occurs. (Note that probes are not expensive in terms of system resources.)</li>
</ul>
<p>
The code at the beginning of a system service should be constructed as follows: </p>
<pre><code>PreviousMode = KeGetPreviousMode();
if (PreviousMode != KernelMode) {
  try {
 &nbsp;&nbsp; ProbeForWrite(ProcessInformation,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ProcessInformationLength,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof(ULONG));
 &nbsp;&nbsp; if (ARGUMENT_PRESENT(ReturnLength)) {
 &nbsp;&nbsp;&nbsp;&nbsp; ProbeForWriteUlong(ReturnLength);
 &nbsp;&nbsp; }
  } except(EXCEPTION_EXECUTE_HANDLER) {
 &nbsp;&nbsp; return GetExceptionCode();
  }
}
</code></pre>
<p>
This code sequence guarantees that all address parameters that the service is going to write through are valid user-mode addresses. If any of the probes were to fail, an exception would occur and the exception code would be returned as the service status. Since for this service, <b>ProcessInformation</b>, and <b>ReturnLength</b> are direct arguments to the service, they do not need to be captured manually inside the service. The system-service dispatcher captures them on entry to the system.</p>
<h2>Conclusion</h2>
<p>
From the outset, Windows&nbsp;NT was designed to be a robust, reliable operating system that could be easily maintained and that could be extended to take advantage of new technologies as they were developed. The system includes a highly functional executive that executes in kernel mode, and provides native system services. The executive provides the sole, secure entry point into the system—there are no back door entry points that could compromise security or damage the system in any way. In addition, the design includes a layer of protected system services that function in user mode between the application layer and the operating system. This modular approach allows additional crucial services to be added—with no change to the executive layer. Each major executive subsystem has been extensively documented to ensure that standard coding practices are used and that all features adhere to the system design and are maintainable over time.</p>
<p>
This design has remained virtually unchanged from 1989 until now. It provides the foundation for all versions of Windows&nbsp;NT to date, including the highly distributed version that will be shipped in 1998.</p>
<h2>For More Information</h2>
<p>
For more information on the design and architecture of Windows&nbsp;NT, refer to the product documentation. Historical information about the development and early design of Windows&nbsp;NT can be found in <i>Inside Windows&nbsp;NT</i> by Helen Custer (Microsoft Press, September 1995).</p>
<p>
For the latest information on Windows&nbsp;NT Server, see the Microsoft Windows NT Server 4.0 Web site (<a href="http://www.microsoft.com/ntserver">http://www.microsoft.com/ntserver</a>).</p>
<p>
Also, see the Windows&nbsp;NT Server Forum on the Microsoft Network (GO WORD: MSNTS).</p>
<p>
<i>The information contained in this document represents the current view of Microsoft Corporation on the issues discussed as of the date of publication. Because Microsoft must respond to changing market conditions, it should not be interpreted to be a commitment on the part of Microsoft, and Microsoft cannot guarantee the accuracy of any information presented after the date of publication.</i></p>
<p>
<i>This White Paper is for informational purposes only. MICROSOFT MAKES NO WARRANTIES, EXPRESS OR IMPLIED, IN THIS DOCUMENT.</i></p>
</BODY>
</HTML>
