<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Microsoft Visual C++ 4.2 and the Standard C++ Library: Frequently Asked Questions</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_stlfaq"></a>Microsoft Visual C++ 4.2 and the Standard C++ Library: Frequently Asked Questions</h1>
<p>
Microsoft Corporation</p>
<p>
October 1996</p>
<h4>What does the Standard C++ Library contain?</h4>
<p>
The facilities provided by the Standard C++ Library from Plum Hall are as follows:
<ul type=disc>
<li>
<b>Language Support:</b> Provides common type definitions used throughout the library such as characteristics of predefined types, functions supporting start and termination of C++ programs, support for dynamic memory allocation, support for dynamic type identification, and support for exception processing and other runtime support.<br><br></li>
<li>
<b>Diagnostics:</b> Includes components for reporting several kinds of exceptional conditions, components for documenting program assertions, and a global variable for error number codes.<br><br></li>
<li>
<b>General utilities:</b> Includes components used in other elements of the Standard C++ Library. These components may also be used by any C++ programs. This category also includes components used by the Standard Template Library (STL) and function objects, dynamic memory management utilities, and date/time utilities. This category also includes memory management components from the C library.<br><br></li>
<li>
<b>Strings:</b> Includes components for manipulating sequences of "characters," where characters may be of type <i>char</i>, <i>w_char</i>, or of a type defined in a C++ program. The library provides a class template <b>basic_string</b>, which defines the basic properties of strings. The <b>string</b> and <b>wstring</b> types are predefined template instantiations provided by the library.<br><br></li>
<li>
<b>Localization:</b> Includes internationalization support for character classification and string collation; numeric, monetary, and date/time formatting and parsing; and message retrieval.<br><br></li>
<li>
<b>The Standard Template Library (STL):</b> Provides a C++ program with access to the most widely used algorithms and data structures. STL headers can be grouped into three major organizing concepts: containers, iterators, and algorithms. <i>Containers</i> are template classes that provide powerful and flexible ways to organize data: for example, vectors, lists, sets and maps. <i>Iterators</i> are the glue that pastes together algorithms and containers. STL provides a large set of programmable <i>algorithms</i> to handle sorting, searching, and other common tasks.<br><br></li>
<li>
<b>Numerics:</b> Includes components used to perform seminumerical operations and components for complex number types, numeric arrays, generalized numeric algorithms, and facilities included from the ISO C library.<br><br></li>
<li>
<b>Input/Output:</b> Includes components for forward declarations of iostreams, predefined iostream objects, base iostream classes, stream buffering, stream formatting and manipulators, string streams, and file streams.</li>
</ul>
<p>
The Standard C++ Library also incorporates the Standard C Library.</p>
<h4><a name="howuse"></a>How do I use the Standard C++ Library in Visual C++ version 4.2? How does the C runtime library relate to the Standard C++ Library in Visual C++ 4.2?</h4>
<p>
Microsoft Visual C++® version 4.2 provides the Standard C++ Library facilities through included files and associated static and dynamic libraries. </p>
<p>
A C++ program can use the different components of the Standard C++ Library by including the required header and linking with the appropriate static or dynamic library.</p>
<p>
Tables 1 and 2 list all the Standard C++ Library headers and associated static and dynamic libraries provided by Visual C++ 4.2.</p>
<p class=label>
<b>Table 1. The Standard C++ Library Headers</b></p>
<table border=1 cellpadding=5 cols=4 frame=below rules=rows>
<tr valign=top>
<td width=25%>ALGORITHM</td>
<td width=25%>BITSET</td>
<td width=25%>CASSERT</td>
<td width=25%>CCTYPE</td>
</tr>
<tr valign=top>
<td width=25%>CERRNO</td>
<td width=25%>CFLOAT</td>
<td width=25%>CISO646</td>
<td width=25%>CLIMITS</td>
</tr>
<tr valign=top>
<td width=25%>CLOCALE</td>
<td width=25%>CMATH</td>
<td width=25%>COMPLEX</td>
<td width=25%>CSETJMP</td>
</tr>
<tr valign=top>
<td width=25%>CSIGNAL</td>
<td width=25%>CSTDARG</td>
<td width=25%>CSTDDEF</td>
<td width=25%>CSTDIO</td>
</tr>
<tr valign=top>
<td width=25%>CSTDLIB</td>
<td width=25%>CSTRING</td>
<td width=25%>CTIME</td>
<td width=25%>CWCHAR</td>
</tr>
<tr valign=top>
<td width=25%>CWCTYPE</td>
<td width=25%>DEQUE</td>
<td width=25%>EXCEPTION</td>
<td width=25%>FSTREAM</td>
</tr>
<tr valign=top>
<td width=25%>FUNCTIONAL</td>
<td width=25%>IOMANIP</td>
<td width=25%>IOS</td>
<td width=25%>IOSFWD</td>
</tr>
<tr valign=top>
<td width=25%>IOSTREAM</td>
<td width=25%>ISTREAM</td>
<td width=25%>ITERATOR</td>
<td width=25%>LIMITS</td>
</tr>
<tr valign=top>
<td width=25%>LIST</td>
<td width=25%>LOCALE</td>
<td width=25%>MAP</td>
<td width=25%>MEMORY</td>
</tr>
<tr valign=top>
<td width=25%>NEW</td>
<td width=25%>NUMERIC</td>
<td width=25%>OSTREAM</td>
<td width=25%>QUEUE</td>
</tr>
<tr valign=top>
<td width=25%>SET</td>
<td width=25%>SSTREAM</td>
<td width=25%>STACK</td>
<td width=25%>STDEXCEPT</td>
</tr>
<tr valign=top>
<td width=25%>STREAMBUF</td>
<td width=25%>STRING</td>
<td width=25%>STRSTREAM</td>
<td width=25%>TYPEINFO</td>
</tr>
<tr valign=top>
<td width=25%>UTILITY</td>
<td width=25%>VALARRAY</td>
<td width=25%>VECTOR</td>
<td width=25%>XIOSBASE</td>
</tr>
<tr valign=top>
<td width=25%>XLOCALE</td>
<td width=25%>XLOCINFO</td>
<td width=25%>XLOCMON</td>
<td width=25%>XLOCNUM</td>
</tr>
<tr valign=top>
<td width=25%>XLOCTIME</td>
<td width=25%>XMEMORY</td>
<td width=25%>XSTDDEF</td>
<td width=25%>XSTRING</td>
</tr>
<tr valign=top>
<td width=25%>XTREE</td>
<td width=25%>XUTILITY</td>
<td width=25%></td>
<td width=25%></td>
</tr>
</table><br>
<p>
Visual C++ 4.2 includes the following static and dynamic libraries (in addition to the Microsoft Class Library [MFC]):
<ul type=disc>
<li>
Basic C runtime library<br><br></li>
<li>
Standard C++ Library from Plum Hall<br><br></li>
<li>
Old iostream library </li>
</ul>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;With Visual C++ 4.2, the iostream support has been pulled out of the C runtime library and exists as an independent entity. Now Visual C++ has the following libraries:</p>
<p class=label>
<b>Table 2. Static and Dynamic Libraries Included with Microsoft Visual C++ 4.2</b></p>
<table border=1 cellpadding=5 cols=4 frame=below rules=rows>
<tr valign=top>
<td class=label width=29%><b>Library types and related compiler switches</b></td>
<td class=label width=24%><b>Basic C runtime library</b></td>
<td class=label width=23%><b>Standard C++ Library</b></td>
<td class=label width=24%><b>Old iostream library</b></td>
</tr>
<tr valign=top>
<td width=29%>Single Threaded (ML)</td>
<td width=24%>LIBC.LIB</td>
<td width=23%>LIBCP.LIB</td>
<td width=24%>LIBCI.LIB</td>
</tr>
<tr valign=top>
<td width=29%>Multithreaded (MT)</td>
<td width=24%>LIBCMT.LIB</td>
<td width=23%>LIBCPMT.LIB</td>
<td width=24%>LIBCIMT.LIB</td>
</tr>
<tr valign=top>
<td width=29%>Multithreaded DLL version (MD)</td>
<td width=24%>MSVCRT.LIB (import library for MSVCRT.DLL)</td>
<td width=23%>MSVCPRT.LIB<sup>*</sup> (also uses MSVCRT.DLL)</td>
<td width=24%>MSVCIRT.LIB (import library for MSVCIRT.DLL)</td>
</tr>
<tr valign=top>
<td width=29%>Debug Single Threaded (MLd)</td>
<td width=24%>LIBCD.LIB</td>
<td width=23%>LIBCPD.LIB</td>
<td width=24%>LIBCID.LIB</td>
</tr>
<tr valign=top>
<td width=29%>Debug Multithreaded (MTd)</td>
<td width=24%>LIBCMTD.LIB</td>
<td width=23%>LIBCPMTD.LIB</td>
<td width=24%>LIBCIMTD.LIB</td>
</tr>
<tr valign=top>
<td width=29%>Debug Multithreaded DLL (MDd)</td>
<td width=24%>MSVCRTD.LIB (import library for MSVCRTD.DLL)</td>
<td width=23%>MSVCPRTD.LIB * (also uses MSVCRTD.DLL)</td>
<td width=24%>MSVCIRTD.LIB (import library for MSVCIRTD.DLL)</td>
</tr>
</table><br>
<p class=mini>
<b>* </b>MSVCPRT.LIB and MSVCPRTD.LIB are static libraries and do not have any DLLs related with them directly. These libraries are also dependent on MSVCRT.DLL and MSVCRTD.DLL, respectively. Any applications that use MSVCPRT.LIB or MSVCPRTD.LIB and use the "Ignore Default Library" (/NOD or NODEFAULTLIB) option, must link MSVCPRT.LIB(or MSVCPRTD.LIB) and MSVCRT.LIB (or MSVCRTD.LIB ), otherwise linker errors (such as LNK2001: unresolved externals in MSVCPRT.LIB or MSVCPRTD.LIB) will be produced.</p>
<p>
<b>Case 1.</b> Consider the following sample C++ program where test.cpp uses the Standard C++ Library iostream to print "Hello World".</p>
<pre><code>// test.cpp
#include &lt;iostream&gt;
void main()
{
 &nbsp;&nbsp; cout &lt;&lt; "Hello World" &lt;&lt; endl ;
}
</code></pre>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=45%><b>Building test.cpp using</b></td>
<td class=label width=55%><b>Will cause test.cpp to link with</b></td>
</tr>
<tr valign=top>
<td width=45%>cl /ML /GX test.cpp</td>
<td width=55%>LIBC.LIB, LIBCP.LIB</td>
</tr>
<tr valign=top>
<td width=45%>cl /MLd /GX test.cpp</td>
<td width=55%>LIBCD.LIB, LIBCPD.LIB</td>
</tr>
<tr valign=top>
<td width=45%>cl /MT /GX test.cpp</td>
<td width=55%>LIBCMT.LIB, LIBCPMT.LIB</td>
</tr>
<tr valign=top>
<td width=45%>cl /MTd /GX test.cpp</td>
<td width=55%>LIBCMTD.LIB, LIBCPMTD.LIB</td>
</tr>
<tr valign=top>
<td width=45%>cl /MD /GX test.cpp</td>
<td width=55%>MSVCRT.LIB, MSVCPRT.LIB</td>
</tr>
<tr valign=top>
<td width=45%>cl /MDd /GX test.cpp</td>
<td width=55%>MSVCRTD.LIB, MSVCPRTD.LIB</td>
</tr>
</table><br>
<p>
In Case 1, test.cpp used the Standard C++ Library input/output component to print "Hello World". The program just includes the Standard C++ Library header <b>&lt;iostream&gt;</b>. When compiling the program, specify a runtime library option: /ML[d],/MT[d], or /MD[d]. The program will then link with a basic runtime library (for example, LIBC.LIB with the /ML option) and a Standard C++ Library (for example, LIBCP.LIB with the /ML option). The /GX option enables exception handling. Exception handling must be enabled for any programs that use the Standard C++ Library.</p>
<p>
It is important to remember that starting with Visual C++ 4.2, a C++ program, depending on the runtime library compiler option specified (/ML[d],/MT[d], or /MD[d]), will always link with one Basic C runtime library and, depending on headers included, link with either a Standard C++ Library (as in the case 1), an old iostream library (as in Case 3), or neither (as in Case 2).</p>
<p>
<b>Case 2.</b> Consider the following sample program:</p>
<pre><code>// test.cpp
void main()
{
}
</code></pre>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=44%><b>Building test.cpp using</b></td>
<td class=label width=56%><b>Will cause test.cpp to link with</b></td>
</tr>
<tr valign=top>
<td width=44%>cl /ML test.cpp</td>
<td width=56%>LIBC.LIB</td>
</tr>
<tr valign=top>
<td width=44%>cl /MLd test.cpp</td>
<td width=56%>LIBCD.LIB</td>
</tr>
<tr valign=top>
<td width=44%>cl /MT test.cpp</td>
<td width=56%>LIBCMT.LIB</td>
</tr>
<tr valign=top>
<td width=44%>cl /MTd test.cpp</td>
<td width=56%>LIBCMTD.LIB</td>
</tr>
<tr valign=top>
<td width=44%>cl /MD test.cpp</td>
<td width=56%>MSVCRT.LIB</td>
</tr>
<tr valign=top>
<td width=44%>cl /MDd test.cpp</td>
<td width=56%>MSVCRTD.LIB</td>
</tr>
</table><br>
<p>
<b>Case 3.</b> Consider the following sample program:</p>
<pre><code>// test.cpp
#include &lt;iostream.h&gt;
void main()
{
}
</code></pre>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=44%><b>Building test.cpp using</b></td>
<td class=label width=56%><b>Will cause test.cpp to link with</b></td>
</tr>
<tr valign=top>
<td width=44%>cl /ML test.cpp</td>
<td width=56%>LIBC.LIB, LIBCI.LIB</td>
</tr>
<tr valign=top>
<td width=44%>cl /MLd test.cpp</td>
<td width=56%>LIBCD.LIB, LIBCID.LIB</td>
</tr>
<tr valign=top>
<td width=44%>cl /MT test.cpp</td>
<td width=56%>LIBCMT.LIB, LIBCIMT.LIB</td>
</tr>
<tr valign=top>
<td width=44%>cl /MTd test.cpp</td>
<td width=56%>LIBCMTD.LIB, LIBCIMTD.LIB</td>
</tr>
<tr valign=top>
<td width=44%>cl /MD test.cpp</td>
<td width=56%>MSVCRT.LIB, MSVCIRT.LIB</td>
</tr>
<tr valign=top>
<td width=44%>cl /MDd test.cpp</td>
<td width=56%>MSVCRTD.LIB, MSVCIRTD.LIB</td>
</tr>
</table><br>
<h4>I am receiving the following compiler error: "C2373: '&gt;=": redefinition ; different type modifiers;"<i> </i>when my application includes the header &lt;iostream&gt; and the MFC header &lt;afxwin.h&gt; The following piece of code demonstrates the error. What is wrong with the code?</h4>
<pre><code>#include &lt;afxwin.h&gt;
#include &lt;iostream&gt;

void main()
{
 &nbsp;&nbsp; CString cstr1("Hello"), cstr2("World") ;
 &nbsp; 
 &nbsp;&nbsp; // following line causes a C2373
 &nbsp;&nbsp; if ( cstr1 &gt;= cstr2 )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "ctsr1 &gt;= ctsr2" ;
 &nbsp;&nbsp; 
}
</code></pre>
<p>
The problem is caused by an ambiguity during function-overload resolution for the <b>operator&gt;=()</b> function. This is an inadvertent conflict between the MFC global definition of <b>operator&gt;=</b> and the Standard C++ Library global function template <b>operator&gt;=().</b></p>
<p>
Here is the MFC global definition of the <b>operator&gt;=()</b> function. It is used to compare <b>CString</b> objects.</p>
<pre><code>BOOL operator &gt;=( const CString&amp; <i>s1</i>, const CString&amp; <i>s2</i> );
</code></pre>
<p>
Here is the Standard C++ Library global function template <b>operator&gt;=()</b>. This function is defined in the header <b>&lt;utility&gt;</b>. Including the header <b>&lt;iostream&gt;</b> causes the header <b>&lt;utility&gt;</b> to be included in the source file.</p>
<pre><code>template&lt;class _TYPE&gt; Inline
bool operator&gt;=(const _TYPE&amp; _X, const _TYPE&amp; _Y) ;
</code></pre>
<p>
The problem occurs in the case of <b>CString</b> during function-overload resolution for the line </p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;if ( cstr1 &gt;= cstr2 )
</code></pre>
<p>
which is the same as calling <b>operator&gt;=(cstr1, ctsr2)</b>. <b>CString</b> defines the <b>operator&gt;=()</b> function as a friend function. When the compiler looks for the appropriate function to call, it first looks for an exact match for the arguments. First, it finds <b>operator&gt;=(const CString, const CString)</b> defined; but this is not an exact match, as <b>cstr1</b> and <b>cstr2</b> are <b>CString</b>s, not <b>const CString</b>s. Next, it instantiates the template class described above and generates another version of <b>operator&gt;=(const CString, const CString)</b>, which is still not an exact match. Finally, it attempts the least-intrusive conversion, which is from <b>CString</b> to <b>const CString</b>. When this is done, it finds there are two definitions for <b>operator&gt;=(const CString, const CString)</b>, hence the ambiguity and the error. </p>
<p>
There are two workarounds to resolve this problem:
<ol>
<li>
Use the <b>operator&lt;()</b> function and <b>operator==()</b> function for comparison. For example, in the above code change<pre><code>if(cstr1 &gt;= cstr2)
</code></pre>
<p class=tl>
to:</P><pre><code>if(!(cstr1 &lt; cstr2))
</code></pre>
</li>
<li>
Use the old iostream library by including <b>&lt;iostream.h&gt;</b>. If you are using any other components of the Standard C++ Library in your program, this will not work. You cannot mix the old iostream library headers with the Standard C++ Library headers. See the discussion on the compiler error <a href="#errc2371">C2371</a>.</li>
</ol>
<h4>I have an MFC program that uses the Standard C++ Library. When I run the program in the debugger, it reports memory leaks. The leaks are reported in objects that are part of the Standard C++ Librariesnot in my code.</h4>
<p>
This is a known problem in Visual C++ 4.2. Most of the leaks are constant (they do not grow in time) and small. There is no known workaround at this time. Microsoft is researching this issue, and the issue will be addressed in a future release of Visual C++.</p>
<h4>When I try to compile a source file with "#include &lt;stl.h&gt;", I receive several compiler errors, which are all in the STL header files. Is there a bug in STL?</h4>
<p>
STL.H was included with Visual C++ 4.2 by mistake. It is not part of the American National Standards Institute (ANSI) standard for Standard C++ Libraries and should not be used. Instead, include the individual header files associated with the particular STL component(s) the program is using. The sample code below, for example, will compile and run correctly if "#include &lt;stl.h&gt;" is changed to "#include &lt;vector&gt;".</p>
<pre><code>//workaround: change the following line to #include &lt;vector&gt;
#include &lt;stl.h&gt;

//workaround: change the "typedef" to:
//typedef vector&lt;int, allocator&lt;int&gt; &gt; INTVECT;&nbsp; // See Question 7
typedef vector&lt;int&gt; INTVECT;

void main()
{
 &nbsp;&nbsp;&nbsp; INTVECT ivect;
}
</code></pre>
<h4>I am receiving compiler error "C2976: 'istream_iterator' : too few template arguments when attempting to instantiate an istream_iterator as follows: ostream_iterator&lt;int&gt; MyIterator;". I also have a similar problem with istream_iterator. Most of the books on STL programming use the above syntax to instantiate a stream iterator. What are the other parameters I need to specify?</h4>
<p>
In Visual C++ 4.2, when instantiating stream iterators you need to use the following syntax:</p>
<pre><code>ostream_iterator&lt;int, char, char_traits&lt;char&gt; &gt; ostrIter ;
</code></pre>
<p>
Here are the definitions of the <b>istream_iterator</b> and <b>ostream_iterator</b> class templates in Visual C++ 4.2:</p>
<pre><code>template &lt;class T, class charT, class traits = char_traits&lt;charT&gt; &gt; class istream_iterator;
template &lt;class T, class charT, class traits = char_traits&lt;charT&gt; &gt; class ostream_iterator;
</code></pre>
<p>
You need to specify the two extra parameters <i>char</i>, and <i>char_traits&lt;char&gt;</i> when instantiating stream iterators. This is because Visual C++ 4.2 does not support the following syntax:</p>
<pre><code>template &lt;class T, class charT, class traits = char_traits&lt;charT&gt; &gt;
</code></pre>
<h4>What do these extra parameters mean?</h4>
<ul type=disc>
<li>
The <i>charT</i><b> </b>parameter defines the data type of a character. The ANSI working papers define character as any object that, when treated sequentially, can represent text. Examples of predefined character types are <i>char</i><b> </b>and <i>wchar_t</i>.<br><br></li>
<li>
The <i>char_traits&lt;charT&gt;</i> class encapsulates a set of the defined types and functions necessary for handling character objects of type <i>charT</i> within the stream.<br><br></li>
<li>
Standard C++ requires that every implementation include definitions of both <i>char_traits&lt;char&gt;</i> and <i>char_traits&lt;wchar_t&gt;</i> (defined in <b>&lt;iosfwd&gt;</b>).</li>
</ul>
<p>
For more information on traits, see the article "A New and Useful Template Technique: 'TRAITS.' " by Nathan Myers, <i>C++ Report,</i> June 1995.</p>
<h4>I am receiving the compiler error "C2976: 'identifier': too few template parameters," when instantiating STL containers. Why do the STL containers of Visual C++ 4.2 require an extra parameter? What is that extra parameter?</h4>
<p>
Several STL components use default template arguments. The ANSI draft specification for the STL container classes (such as vector) specifies that the second template argument (the <b>allocator</b>) must have a default value of "allocator", as follows: </p>
<pre><code>template&lt;class T, class Allocator = allocator&gt; class vector;
</code></pre>
<p>
The predefined <b>allocator</b> class uses member templates. Visual C++ 4.2 does not support the use of member templates. </p>
<p>
Because it is not possible to implement the <b>allocator</b> class directly, the <b>allocator</b> has been implemented as a template class in the current implementation of the STL. The problem lies in attempting to use the templated <b>allocator</b> class as a default template argument. Consider the following: </p>
<pre><code>template&lt;class T, class Allocator = allocator&lt;T&gt; &gt; class vector;
</code></pre>
<p>
Visual C++ 4.2 does not support this syntax. This makes it necessary, in the case of STL containers, to remove the default template argument for the allocator. The definition of vector now becomes:</p>
<pre><code>template&lt;class T, class Allocator&gt; class vector;
</code></pre>
<p>
The side effect of this is that declaring a container will now require that you explicitly specify the allocator class as a template argument. Consider the following declaration of an int vector: </p>
<pre><code>vector&lt;int&gt; myVector; 
</code></pre>
<p>
This will cause the following compiler error: </p>
<pre><code>Compiler error C2976 : 'vector' : too few template parameters
</code></pre>
<p>
To correct the error, the declaration must be changed to: </p>
<pre><code>vector&lt;int, allocator&lt;int&gt; &gt; myVector;
</code></pre>
<p>
<b>IMPORTANT INFORMATION: Using a typedef </b></p>
<p>
It is good programming practice to use <b>typedef</b> statements when instantiating template classes. Using a <b>typedef</b> has the following advantages: 
<ul type=disc>
<li>
If the definition of the class template changes, you can simply change the <b>typedef</b> statement and the rest of your program will work as is.<br><br></li>
<li>
Template class instantiations tend to become long. Using <b>typedef</b> saves you the trouble of remembering complex class names.</li>
</ul>
<p>
For example, if you have a class template as follows: </p>
<pre><code>template &lt;class A, class B, class C, class D&gt;
class Test
{
} ;
</code></pre>
<p>
you can instantiate a template class using the above class template as follows: </p>
<pre><code>Test&lt;int, int, float, float&gt; ifClass1 ;
</code></pre>
<p>
For another instantiation in a different source file, you would repeat: </p>
<pre><code>Test&lt;int, int, float, float&gt; ifClass2 ;
</code></pre>
<p>
Now if the definition of the <b>Test </b>class template changes as follows </p>
<pre><code>&nbsp;&nbsp;template &lt;class A, class B, class C, class D, class E&gt;
class Test
{
} ;
</code></pre>
<p>
you will have to modify every instantiation in your source code to reflect the changenot a very easy task. </p>
<p>
Using a <b>typedef</b> makes life easier, because you only need to change the <b>typedef</b> statement. So use a <b>typedef</b> as follows: </p>
<pre><code>&nbsp;&nbsp;template &lt;class A, class B, class C, class D&gt;
class Test
{
} ;

typedef Test&lt;int, int, float, float &gt; MYCLASS ;

MYCLASS myObj1 ;
MYCLASS myObj2 ;
</code></pre>
<p>
Now if the <b>Test</b> class template definition changes, you only need to change the <b>typedef:</b> </p>
<pre><code>&nbsp;&nbsp;template &lt;class A, class B, class C, class D, class E&gt;
class Test
{
} ;

typedef Test&lt;int, int, float, float, char&gt; MYCLASS ;

MYCLASS myObj1 ;
MYCLASS myObj2 ;
</code></pre>
<p>
You can save some valuable time and reduce the frustration by using a <b>typedef</b>!</p>
<h4><a name="errc2371"></a>I am receiving compiler error "C2371: 'identifier' redefinition; different basic types". What is causing this?</h4>
<p>
Mixing Standard C++ Library headers and old iostream library headers will cause this error, even if they are included in different source files. </p>
<p class=label>
<b>Table 3. Old iostream Library Headers </b></p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td width=32%>FSTREAM.H</td>
<td width=35%>IOMANIP.H</td>
<td width=33%>IOS.H</td>
</tr>
<tr valign=top>
<td width=32%>IOSTREAM.H</td>
<td width=35%>ISTREAM.H</td>
<td width=33%>OSTREAM.H</td>
</tr>
<tr valign=top>
<td width=32%>STDIOSTR.H</td>
<td width=35%>STREAMB.H</td>
<td width=33%>STRSTREA.H</td>
</tr>
</table><br>
<p class=label>
<b>Table 4. Standard C++ Library Headers </b></p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td width=32%>ALGORITHM</td>
<td width=35%>BITSET</td>
<td width=33%>COMPLEX</td>
</tr>
<tr valign=top>
<td width=32%>DEQUE</td>
<td width=35%>FSTREAM</td>
<td width=33%>FUNCTIONAL</td>
</tr>
<tr valign=top>
<td width=32%>IOMANIP</td>
<td width=35%>IOS</td>
<td width=33%>IOSFWD</td>
</tr>
<tr valign=top>
<td width=32%>IOSTREAM</td>
<td width=35%>ISTREAM</td>
<td width=33%>ITERATOR</td>
</tr>
<tr valign=top>
<td width=32%>LIMITS</td>
<td width=35%>LIST</td>
<td width=33%>LOCALE</td>
</tr>
<tr valign=top>
<td width=32%>MAP</td>
<td width=35%>MEMORY</td>
<td width=33%>NUMERIC</td>
</tr>
<tr valign=top>
<td width=32%>OSTREAM</td>
<td width=35%>QUEUE</td>
<td width=33%>SET</td>
</tr>
<tr valign=top>
<td width=32%>SSTREAM</td>
<td width=35%>STACK</td>
<td width=33%>STDEXCEPT</td>
</tr>
<tr valign=top>
<td width=32%>STREAMBUF</td>
<td width=35%>STRING</td>
<td width=33%>STRSTREAM</td>
</tr>
<tr valign=top>
<td width=32%>TYPEINFO</td>
<td width=35%>UTILITY</td>
<td width=33%>VALARRAY</td>
</tr>
<tr valign=top>
<td width=32%>VECTOR</td>
<td width=35%>XIOSBASE</td>
<td width=33%>XLOCALE</td>
</tr>
<tr valign=top>
<td width=32%>XLOCINFO</td>
<td width=35%>XLOCMON</td>
<td width=33%>XLOCNUM</td>
</tr>
<tr valign=top>
<td width=32%>XLOCTIME</td>
<td width=35%>XMEMORY</td>
<td width=33%>XSTRING</td>
</tr>
<tr valign=top>
<td width=32%>XTREE</td>
<td width=35%>XUTILITY</td>
<td width=33%>YMATH.H</td>
</tr>
</table><br>
<h4>I have a project that was built with the "Ignore Default Libraries" option (/NOD or /NODEFAULTLIB). With Visual C++ 4.2, I am receiving linker error "LNK2001: unresolved external symbol <i>'symbol' </i>" on all iostream function calls. What has changed?</h4>
<p>
The iostream functions have been removed from the C runtime library. </p>
<p>
If you are using the old iostream functions, you will need to add an additional library as follows: LIBCI.LIB with the single-threaded, or &lt;/ML&gt;, option; LIBCMI.LIB with the multithreaded, or &lt;/MT&gt;, option; or MSVCIRT.LIB with the multithreaded dll, or &lt;/MD&gt;, option. </p>
<p>
If you are using the new iostream functions included with the Standard C++ Library, you will need to add an additional library as follows: LIBCP.LIB with the single-threaded, or &lt;/ML&gt;, option; LIBCMP.LIB with the multithreaded, or &lt;/MT&gt;, option; or MSVCPRT.LIB with the multithreaded dll, or &lt;/MD&gt;, option. </p>
<p>
Do not mix different versions of the libraries. For example, if you are using the single-threaded version of the C runtime library, you must also use the single-threaded version of the iostream library or Standard C++ Library. </p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;You cannot mix calls to the old iostream library functions and the new Standard C++ Library iostream functions. </p>
<p>
See related issues: 
<ul type=disc>
<li>
"Issues Surrounding iostream, STL, and the Standard C++ Library" in the Visual C++ documentation in the MSDN library. <br><br></li>
<li>
The discussion of compiler error <a href="#errc2371">C2371</a>.</li>
</ul>
<h4>I am receiving compiler warnings C4786 and/or C4788. None of the symbols in my program is anywhere near 255 characters in length. What is causing this?</h4>
<p>
C4786 and C4788 are issued when a symbol's name exceeds 255 characters in length. This often happens with templates and, especially, with STL components. </p>
<p>
Ignoring this warning is usually safe. Use a #pragma warning (disable: 4786,4788) to suppress the messages. </p>
<p>
See "Compiler Warning (level 1) C4786" in the Visual C++ documentation in the MSDN library for further details.</p>
<h4>I am receiving compiler warning "C4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX." What does that mean?</h4>
<p>
Programs that use the Standard C++ library must be compiled with C++ exception handling enabled. </p>
<p>
To enable C++ exception handling in Visual C++: 
<ul type=disc>
<li>
In the <b>Project Settings</b> dialog box, click the <b>C/CC++</b> tab, and select <b>Enable Exception Handling</b> in the C++ Language category. <br><br></li>
<li>
Use the /GX compiler switch.</li>
</ul>
<h4>I am receiving compiler error C2146, followed by compiler error C2065, and finally compiler error C2143, all pointing to the same line in my source. What does this mean?</h4>
<p>
This sequence of errors can be caused by the following type of construct:</p>
<pre><code>vector&lt;int, allocator&lt;int&gt;&gt; iV;
</code></pre>
<p>
The problem is caused by the consecutive "&gt;&gt;" at the end of the declaration. The solution is to put a space between them, so the above becomes: </p>
<pre><code>vector&lt;int, allocator&lt;int&gt; &gt; iV;
</code></pre>
<p>
This is consistent with the proposed ANSI specification.</p>
<h4>Can I use existing static or dynamic link libraries built with Visual C++ 4.0 or Visual C++ 4.1 with applications being developed using Visual C++ 4.2?</h4>
<p>
If your application is not going to use the Standard C++ Library, you can use the existing libraries in your application as is. </p>
<p>
If your application is going to use the Standard C++ Library, you need to consider the following issues: 
<ul type=disc>
<li>
You will have to rebuild your libraries using the Standard C++ Library.<br><br></li>
<li>
If your library is iostream intensive, you will need to rewrite some parts of your code before you can rebuild your library using the Standard C++ Library. See the "Differences Between Old and New iostream Implementations" section in "Potential Problems When Linking an Old Application with the New Libraries" in the Visual C++ 4.2 documentation in the MSDN Library. </li>
</ul>
<p>
For related issues see: 
<ul type=disc>
<li>
"Issues Surrounding iostream, STL and the Standard C++ Library"<br><br></li>
<li>
The response to <a href="#howuse">"How do I use the Standard C++ Library in Visual C++ 4.2?"</a>. <br><br></li>
<li>
The <b>Ignore Default Libraries</b> option in Visual C++ 4.2</li>
</ul>
<h4>I ported my application from Visual C++ 4.1 to Visual C++ 4.2. I do not want to use the Standard C++ Library. So, how do I retain the old iostream functionality?</h4>
<p>
If you want to retain the old iostream library, include one or more of the old iostream header files in your code. <b>Do not use the new Standard C++ headers. You cannot mix calls to the old iostream and the new Standard C++ library.</b> For further details, see "Issues Surrounding iostream, STL and the Standard C++ Library," or the response to <a href="#howuse">"How do I use the Standard C++ Library in Visual C++ 4.2?"</a>.</p>
<h4>How do I make the Standard C++ Library the default library for my application?</h4>
<p>
If you want to make the Standard C++ Libraries the default library, include one or more of the new Standard C++ headers. Remember, you cannot mix calls to the old iostream and the new Standard C++ library. Existing libraries (static or dynamic link) that use iostream functions will have to be rebuilt using Standard C++ Library iostream functions. For further details, see "Issues Surrounding iostream, STL and the Standard C++ Library," or the response to <a href="#howuse">"How do I use the Standard C++ Library in Visual C++ 4.2?"</a>.</p>
</BODY>
</HTML>
