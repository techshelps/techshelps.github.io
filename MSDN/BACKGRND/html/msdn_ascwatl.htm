<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Developing Active Server Components with ATL</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><sup><a name="msdn_ascwatl"></a></sup>Developing Active Server Components with ATL</h1>
<p>
George V. Reilly <br>
Senior Software Engineer, MicroCrafts, Inc. </p>
<p>
April 2, 1997</p>
<p>
<i>George V. Reilly is a Senior Software Engineer at MicroCrafts, Inc., a Redmond, WA –based consulting firm. He wrote many of the IIS Sample Components for Active Server Pages.</i></p>
<p>
This article tells you how to write and when to use an Active Server Pages (ASP) component with the Microsoft Active Template Library (ATL). It assumes that you're familiar with C++, know a little about Component Object Model (COM) and ActiveX™, and have a basic understanding of how ASP works.</p>
<h2>Why Bother?</h2>
<p>
Why would you want to bother writing C++ components for your Web server now that ASP is an integral part of Microsoft® Internet Information Server (IIS) version 3.0? Surely you can throw away all of those laboriously written Internet Server Application Programming Interface (ISAPI) extension dynamic-link libraries (DLLs) and Common Gateway Interface (CGI) programs and just whip up a concoction of Hypertext Markup Language (HTML) and Microsoft Visual Basic® Scripting Edition (VBScript) in a tenth of the time? </p>
<p>
Yes and no. It's certainly true that you can replace many ISAPI extension DLLs and CGI programs with ASP scripts that are easier to write, easier to customize, and easier to update, but there is still a place for C++ programs on your Web server. </p>
<p>
VBScript and Microsoft JScript™ are powerful and useful, but they have disadvantages, too. Here are a few reasons why you might want to use languages other than VBScript or JScript:
<ul type=disc>
<li>
<b>Performance.</b> Interpreted languages are inherently slower than well-written C++. Also, parsing and executing interpreted languages uses CPU cycles that might be put to better use in making the server more responsive to other users.<br><br></li>
<li>
<b>Access to the operating system.</b> Many features of the operating system are difficult or impossible to use from VBScript: system registry access, thread support, file mapping, and so on. <br><br></li>
<li>
<b>Access to the missing features of Visual Basic.</b> VBScript is missing many of the features of Visual Basic. Some of those features, such as forms, have no place in a server-side scripting language; however, being able to use, say, all of the date-formatting facilities would be very convenient sometimes. <br><br></li>
<li>
<b>Leverage existing code/code reuse.</b> You may have existing C++ code that you want to use in an ASP application; just wrap it up in an ASP component. <br><br></li>
<li>
<b>Separate the UI from the data processing.</b> You can put ever-fancier VBScript user interfaces on your applications, while keeping the guts of the application in a common core. <br><br></li>
<li>
<b>Encapsulating business logic.</b> Wrapping your business logic in a component makes it easier to debug and easier to distribute. <br><br></li>
<li>
<b>Protect your intellectual property.</b> If you're in the business of selling ASP applications to other Web sites and you're writing those ASP applications in VBScript, then you're selling your source code to your customers.</li>
</ul>
<p>
However, do not underestimate the usefulness of VBScript. You can produce working ASP applications using VBScript in a fraction of the time that it takes to write C++ code, and they'll be good enough most of the time. The edit/compile/debug cycle is notably shorter, plus it's much easier to tweak the look of your pages. </p>
<h3>When to Write a Component</h3>
<p>
A few points you should bear in mind when deciding whether to write a component:
<ul type=disc>
<li>
Writing components is time consuming. You're likely to spend considerably more time writing and debugging a component in C++ than you would writing an equivalent ASP program. If you're writing the component in the name of the great god "Efficiency", be sure that you really need to write the component. Prototype it first in VBScript and measure the performance. Be sure that it really is a bottleneck, that it really is too slow, and that it really does use too much CPU time. <br><br></li>
<li>
Writing components is expensive. They take more time to write, and time is money. They require more skilled and, hence, more expensive, programmers. <br><br></li>
<li>
Components can't do everything that you might want to do on a Web server. Neither can ISAPI extension DLLs. If you want to do custom logging or change the HTML data stream sent back to users' browsers, you'll have to write an ISAPI filter DLL. Unfortunately, that's beyond the scope of this article.</li>
</ul>
<h3>Which Language to Use?</h3>
<p>
Which language should you use to write a component?
<ul type=disc>
<li>
<b>Visual Basic 5.0<br>
</b>Visual Basic 5.0 components are easy to write because Visual Basic takes care of a lot of things for you, such as memory management, and hides many of the details of COM. Visual Basic 5.0 can create apartment-threaded objects, which are recommended for good performance; Visual Basic 4.0 is restricted to single-threaded objects, and its runtime is not thread-safe. <br><br></li>
<li>
<b>Java/Microsoft Visual J++™<br>
</b>Java is a powerful language, well suited for creating server-side components. It also takes care of many of the tedious details for you. However, there are some things that Java cannot do. For example, some of the Win32 application programming interfaces (APIs) expect pointers, and Java has no notion of a pointer. <br><br></li>
<li>
<b>C++</b><br>
C++ gives you the most power. It's faster than Java and slightly faster than Visual Basic 5.0. It also gives you full access to the operating system. The down side is that C++ code is harder to write and, even with good class libraries like ATL, you have more bookkeeping to do. <br><br></li>
<li>
<b>Other languages<br>
</b>Any language capable of creating Automation servers can be used to build ASP components. For best results, you should build <i>both-threaded</i> (both apartment-threaded and free-threaded) or apartment-threaded in-proc servers.<p class=tl>
<b>Note: </b>With Active Server Pages, a pure free-threaded object will not perform as well as a both-threaded object (an object marked as both apartment-threaded and free-threaded) or an apartment-threaded object.</P></li>
</ul>
<h2>ATL: Active Template Library</h2>
<p>
The Microsoft Active Template Library (ATL) is used to build COM objects that can be called from an ASP page, from Visual Basic, or from other Automation clients. </p>
<p>
ATL is the recommended library for writing ASP and other ActiveX components in C++ for the following reasons: 
<ul type=disc>
<li>
It produces small, fast, industrial-strength components ("lean and mean") <br><br></li>
<li>
It supports all COM threading models (single, apartment, and free) <br><br></li>
<li>
It supports <b>IDispatch</b> interfaces <br><br></li>
<li>
It makes dual interfaces easy <br><br></li>
<li>
It supports the COM error mechanism <br><br></li>
<li>
It calls methods very quickly <br><br></li>
<li>
It gives fine control over COM features ("closer to the metal") <br><br></li>
<li>
It allows you to build several different types of objects and controls, including: <ul type=disc>
<li>
Minimal COM objects <br><br></li>
<li>
Full controls <br><br></li>
<li>
Internet Explorer controls <br><br></li>
<li>
Property pages <br><br></li>
<li>
Dialog boxes</li>
</ul>
</li>
</ul>
<p>
ATL versions 2.0 and 2.1 were released in mid-February 1997. ATL 2.0, for Microsoft Visual C++® version 4.2, is available for download at <a href="http://www.microsoft.com/visualc/prodinfo/">http://www.microsoft.com/visualc/prodinfo/</a>. ATL 2.1 is an integral part of Visual C++ 5.0. </p>
<p>
ATL 2.0 requires Visual C++ 4.2b. If you are using Visual C++ 4.2, you must upgrade to Visual C++ 4.2b with the Visual C++ 4.2b Technology Update. Download the Visual C++ Technology Update from <a href="http://www.microsoft.com/visualc/prodinfo/archives/download/vc42b.htm">http://www.microsoft.com/visualc/prodinfo/archives/download/vc42b.htm</a>. Note that this update will work only with Visual C++ version 4.2.</p>
<h2>Creating a Component with ATL</h2>
<p>
To create a new component: 
<ol>
<li>
On the <b>File</b> menu in Developer Studio, click <b>New . . .</b><br><br></li>
<li>
Select <b>ATL COM AppWizard</b>. <br><br></li>
<li>
Enter the name and location of the project. <br><br></li>
<li>
Click <b>OK</b>. <br><br></li>
<li>
Accept the defaults and click <b>Finish</b>.</li>
</ol>
<p>
If you're worried about 8.3 names, be sure that the base name of your project is no more than six characters, as IDL will generate <i>Project</i>_i.c, <i>Project</i>_p.c, <i>Project</i>PS.def, and <i>Project</i>PS.mak. </p>
<p>
Now that you've created the project, it's time to create a COM object within the project.
<ol>
<li>
Do one of the following:<ul type=disc>
<li>
In Visual C++ 4.2, select <b>Component&nbsp;.&nbsp;.&nbsp;.</b> from the <b>Insert</b> menu of Developer Studio. The Component Gallery will appear. A number of tabs will appear at the bottom of the picture, such as <b>Microsoft</b> and <b>OLE Controls</b>. Scroll right until you see the <b>ATL</b> tab. From the <b>ATL</b> tab, double-click the <b>ATL Object Wizard</b>. <br><br></li>
<li>
In Visual C++ 5.0, on the <b>Insert</b> menu, click <b>New ATL Object&nbsp;.&nbsp;.&nbsp;.</b>. Or, right-click the classes in the ClassView pane, and then click <b>New ATL Object&nbsp;.&nbsp;.&nbsp;.</b>.</li>
</ul>
</li>
<li>
In the <b>ATL Object Wizard</b> dialog box, you'll see two panes. In the left pane, click <b>Objects</b>. If you are using Visual C++ 4.2, in the right pane, double-click <b>Simple Object</b>. If you are using Visual C++ 5.0, in the right pane you'll see a number of additional objects; click <b>ActiveX Server Component</b> instead. <br><br></li>
<li>
The <b>ATL Object Wizard Properties</b> dialog box will appear. On the <b>Names</b> tab, type the short name of your object. The other names will be filled in automatically. You can edit them if you wish. It's quite likely that you'll want to edit the <b>Prog ID</b>. <br><br></li>
<li>
Click the <b>Attributes</b> tab, and then consider the following:<ul type=disc>
<li>
You may want to change the <b>Threading Model</b> to <b>Both</b> (see "Threading" later in this article for a discussion of threading models). <br><br></li>
<li>
You probably don't need to support <b>Aggregation</b>. <br><br></li>
<li>
See "Reporting Errors" later in this article for why you should to support <b>ISupportErrorInfo</b>. <br><br></li>
<li>
You should not need to change the other options. </li>
</ul>
</li>
<li>
On the <b>ASP</b> tab (only present in Visual C++ 5.0), you'll see a number of options that will make much more sense after you read the section on ASP intrinsics below. You can selectively enable the intrinsics that you want to use.</li>
</ol>
<h3>A Simple Example</h3>
<p>
Let's build a really simple component called Upper. It has one method, <b>ToUpper</b>, which takes a string and converts it to uppercase. For the sake of this example, we'll use <b>Upper1</b> as the short name of the component. </p>
<p>
To create a method that returns a value to VBScript, make the return value be the last parameter to the method and declare it as <b>[out, retval]</b>. </p>
<p>
If you're using Visual C++ 4.2, put the following in your Upper.idl file, in the interface<b> IUpper1&nbsp;:&nbsp;IDispatch block</b>:</p>
<pre><code>[helpstring("Convert a string to uppercase")]
 &nbsp;&nbsp; HRESULT ToUpper([in] BSTR bstr,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [out, retval] BSTR* pbstrRetVal);
</code></pre>
<p>
If you're using Visual C++ 5.0, right-click <b>IUpper1</b> in the ClassView pane and click <b>Add Method&nbsp;.&nbsp;.&nbsp;.</b>. Type <b>ToUpper</b> as the method name and include the following in the parameters:</p>
<pre><code>[in] BSTR bstr,
[out, retval] BSTR* pbstrRetVal
</code></pre>
<p>
Click <b>Attributes&nbsp;.&nbsp;.&nbsp;.</b> to change the helpstring. When you click <b>OK</b>, appropriate code will be added to your .idl, .h, and .cpp files. Of course, you still need to add the body of the <b>ToUpper</b> method, as shown below. </p>
<p>
In Visual C++&nbsp; 4.2, declare the method in your component's Upper1.h file, at the end of the <b>CUpper1</b> class:</p>
<pre><code>public:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STDMETHOD(ToUpper)(BSTR bstr, BSTR* pbstrRetVal);
</code></pre>
<p>
and define the <b>ToUpper</b> method in your component's Upper1.cpp file, as follows:</p>
<pre><code>STDMETHODIMP
 &nbsp;&nbsp; CUpper1::ToUpper(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BSTR bstr,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BSTR* pbstrRetVal)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // validate parameters
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (bstr == NULL || pbstrRetVal == NULL)
 &nbsp;&nbsp;     &nbsp;&nbsp; return E_POINTER;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;    // Create a temporary CComBSTR
 &nbsp;&nbsp;    CComBSTR bstrTemp(bstr);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;    if (!bstrTemp)
 &nbsp;&nbsp;     &nbsp;&nbsp; return E_OUTOFMEMORY;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;    // Make string uppercase&nbsp;&nbsp; 
 &nbsp;&nbsp;    wcsupr(bstrTemp);&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;    // Return m_str member of bstrTemp
 &nbsp;&nbsp;    *pbstrRetVal = bstrTemp.Detach();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;    return S_OK;
 &nbsp;&nbsp; }
</code></pre>
<p>
Note the use of the CComBSTR wrapper class, which adds some useful functionality to the native <b>BSTR</b> COM datatype. Another useful class is CComVariant, which wraps VARIANTs. Two other wrapper classes, CComPtr and CComQIPtr, are discussed later in the "ASP Intrinsics" section. </p>
<p>
This code is quite paranoid. For quick and dirty tests, you can probably safely eliminate both tests, as ASP will call you with valid parameters and the CComBSTR constructor is unlikely to fail. However, in production code, you ought to handle these potential failures. </p>
<p>
The <b>ToUpper</b> method can be called with the following script, named Upper.asp. Don't forget to put the script in an executable virtual directory.</p>
<pre><code>&lt;%
 &nbsp;&nbsp;&nbsp;&nbsp; Set oUpper = Server.CreateObject("Upper.Upper1.1")
 &nbsp;&nbsp;&nbsp;&nbsp; str = "Hello, World!"
 &nbsp;&nbsp;&nbsp;&nbsp; upper = oUpper.ToUpper(str)
 &nbsp;&nbsp; %&gt;

 &nbsp;&nbsp; The uppercase of "&lt;% = str %&gt;" is "&lt;%&nbsp; = upper %&gt;".
</code></pre>
<p>
VBScript checks the HRESULT return value for you under the covers. If you return a failure error code, the script will abort with an error message unless there's some error handling in it (such as <b>On Error Next</b>). </p>
<p>
If you move the component to another machine, you'll have to run regsvr32.exe to register it. The wizard-generated makefile does this automatically whenever you recompile the component. </p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;If you're testing your components inside Active Server Pages 1.0 (instead of, say, Visual Basic 5.0), you will have to stop and restart the Web service before you can relink your components. You will also have to stop and restart the File Transfer Protocol (FTP) and Gopher services, if you're running them. On a development machine, you should turn the FTP and Gopher services off permanently unless you really need them. </p>
<p>
You can make restarting the Web service considerably faster if you create the registry entry REG_DWORD in the following registry path, and set the value to zero:</p>
<pre><code>HKEY_LOCAL_MACHINE
 &nbsp;&nbsp; \SYSTEM 
 &nbsp;&nbsp;&nbsp; \CurrentControlSet 
 &nbsp;&nbsp;&nbsp;&nbsp; \Services 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \W3SVC
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \Parameters 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \EnableSvcLoc
</code></pre>
<p>
Do the same for MSFTPSVC and GOPHERSVC, if you're running them. On a production server, the service locator should be enabled.</p>
<h3>ASP Intrinsics</h3>
<p>
The ASP intrinsics are the built-in Application, Session, Server, Request, and Response objects. Most ASP components need one or more of these to make full use of ASP facilities. </p>
<p>
To use the intrinsics, you must provide two methods in your object, <b>OnStartPage</b> and <b>OnEndPage</b>. ASP calls these optional methods on an object whenever a page is opened or closed by the user's Web browser, and they bracket the lifetime of the page. </p>
<p>
The <b>OnStartPage</b> method receives an <b>IDispatch</b>* that can be queried (using <b>QueryInterface</b>) for a pointer to an <b>IScriptingContext</b> interface, which provides methods for getting pointers to the intrinsic objects. </p>
<p>
Visual C++ 5.0 allows you to add these methods automatically when you create the object by using the <b>ASP</b> tab in the <b>ATL Object Wizard</b> <b>Properties</b> dialog box. </p>
<p>
In Visual C++ 4.2, add the following method declarations to your .idl file:</p>
<pre><code>HRESULT OnStartPage(IDispatch* pScriptContext);
 &nbsp;&nbsp; HRESULT OnEndPage();
</code></pre>
<p>
In your .H file, add </p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;#include &lt;asptlb.h&gt;
</code></pre>
<p>
near the top and add the following declarations at the bottom of the CObj class:</p>
<pre><code>public:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STDMETHOD(OnStartPage)(IDispatch*);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STDMETHOD(OnEndPage)();

 &nbsp;&nbsp; private:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CComPtr&lt;IRequest&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_piRequest;&nbsp;&nbsp;&nbsp;&nbsp; // Request Object
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CComPtr&lt;IResponse&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_piResponse;&nbsp;&nbsp;&nbsp; // Response Object
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CComPtr&lt;IApplicationObject&gt; m_piApplication; // Application Object
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CComPtr&lt;ISessionObject&gt; &nbsp;&nbsp;&nbsp; m_piSession;&nbsp;&nbsp;&nbsp;&nbsp; // Session Object
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CComPtr&lt;IServer&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_piServer;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Server Object
</code></pre>
<p>
Finally, add the following method definitions to your .cpp file:</p>
<pre><code>STDMETHODIMP
 &nbsp;&nbsp; CObj::OnStartPage(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDispatch* pScriptContext)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pScriptContext == NULL)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return E_POINTER;
 &nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Get the IScriptingContext Interface.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CComQIPtr&lt;IScriptingContext, &amp;IID_IScriptingContext&gt;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pContext = pScriptContext;
 &nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!pContext)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return E_NOINTERFACE;
 &nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Get Request Object Pointer.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HRESULT hr = pContext-&gt;get_Request(&amp;m_piRequest);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Get Response Object Pointer.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (SUCCEEDED(hr))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hr = pContext-&gt;get_Response(&amp;m_piResponse);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Get Application Object Pointer.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (SUCCEEDED(hr))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hr = pContext-&gt;get_Application(&amp;m_piApplication);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Get Session Object Pointer.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (SUCCEEDED(hr))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hr = pContext-&gt;get_Session(&amp;m_piSession);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Get Server Object Pointer.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (SUCCEEDED(hr))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hr = pContext-&gt;get_Server(&amp;m_piServer);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (FAILED(hr))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Release all pointers upon failure.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_piRequest.Release();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_piResponse.Release();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_piApplication.Release();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_piSession.Release();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_piServer.Release();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return hr;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; 
 &nbsp;&nbsp; 
 &nbsp;&nbsp; 
 &nbsp;&nbsp; STDMETHODIMP
 &nbsp;&nbsp; CObj::OnEndPage()&nbsp; 
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_piRequest.Release();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_piResponse.Release();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_piApplication.Release();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_piSession.Release();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_piServer.Release();
 &nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return S_OK;
 &nbsp;&nbsp; }
</code></pre>
<p>
If you don't need all five objects, remove the ones you don't need from your code.</p>
<h3>CComPtr and CComQIPtr</h3>
<p>
Take note of the use of the CComPtr and CComQIPtr variables above. These are type-safe smart pointer classes that encapsulate traditional pointers to interfaces and can be used interchangeably with them. They give you considerable notational convenience and the assurance that their destructors will automatically <b>Release</b> interfaces. A CComQIPtr automatically queries an interface when it is constructed; a CComPtr does not. </p>
<p>
Note that for variables of both classes, you should use <b>piFoo.Release()</b> and not <b>piFoo-&gt;Release()</b> because <b>piFoo.Release()</b> resets piFoo.p to NULL after calling <b>piFoo.p-&gt;Release()</b>, while <b>piFoo-&gt;Release()</b> uses the overloaded <b>operator-&gt;</b> to call <b>p-&gt;Release()</b> directly, leaving <b>piFoo</b> in an inconsistent state. That apart, you treat a CComPtr&lt;IFoo&gt;&nbsp;piFoo exactly as you would an <b>IFoo*&nbsp;piFoo</b>.</p>
<h4>Object scope</h4>
<p>
<b>OnStartPage</b> and <b>OnEndPage</b> are only called on page-level and session-level objects. If your object has application-level scope (for example, if it was created in <b>Application_OnStart</b> in global.asa and added to the Application object), these methods will not be called. </p>
<p>
If your object is somehow created by means other than <b>Server.CreateObject</b> or <b>&lt;OBJECT RUNAT=Server ...&gt;</b>, your <b>OnStartPage</b> and <b>OnEndPage</b> methods will not be called either. </p>
<p>
Therefore, check that your pointers to the intrinsics are valid before you use them with code such as this: </p>
<pre><code>if (!m_piRequest || !m_piResponse)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ::ReportError(E_NOINTERFACE);
</code></pre>
<p>
You might wonder how "!" is being used on objects. Simple—CComPtr and CComQIPtr both define <b>operator!</b> to check their internal pointer, <i>p</i>, and return TRUE if it's NULL. See "Reporting Errors" for an explanation of <b>ReportError</b>.</p>
<h4>asptlb.h</h4>
<p>
To build an object that uses <b>IScriptingContext</b>, you will need to copy asptlb.h from your ASP installation directory to your include directory at \Program&nbsp;Files\DevStudio\VC\include. (On Microsoft Windows NT®, the default installation directory for asptlb.h is %SystemRoot%\System32\Inetsrv\ASP\Cmpnts. On Windows® 95, it is \Program&nbsp;Files\WebSvr\System\ ASP\Cmpnts.) If you get linker errors, you may need to add, in one .cpp file, "#include &lt;initguid.h&gt;" before "#include &lt;asptlb.h&gt;".</p>
<h3>Threading</h3>
<p>
When creating components in C++, you should understand the following threading models: 
<ul type=disc>
<li>
<b>Single-threading model.</b> Only one thread uses COM, and all calls to COM objects are synchronized by COM. Except for the simplest of applications, this leads to unacceptable performance on a server such as ASP. <br><br></li>
<li>
<b>Apartment-threading model.</b> One or more threads in a process use COM, and calls to COM objects are synchronized by COM. An instance of an object is always called on the same thread, guaranteeing serial access to it. Interfaces are marshaled between threads. You need to protect shared data only, not per-instance data. Apartment-threaded objects give acceptable performance. <br><br></li>
<li>
<b>Free-threading model.</b> One or more threads in a process use COM, and calls to COM objects are synchronized by the objects themselves. Interfaces are not marshaled between threads. You must also protect per-instance data. <br><br></li>
<li>
<b>Both-threading model.</b> Objects are marked as both apartment-threaded and free-threaded. This is the default for objects produced by ATL, and this is the recommended model.</li>
</ul>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;With Active Server Pages, a pure free-threaded object will not perform as well as a both-threaded object or an apartment-threaded object. </p>
<p>
Your objects must be thread-safe and they must not deadlock. It is up to you to protect shared data and global data with critical sections or other synchronization mechanisms. Remember that static data in functions, classes, and at file level is also shared data, as may be files, registry keys, mail slots, and other external system resources. </p>
<p>
For a comprehensive discussion of threading models, see Knowledge Base article Q150777, "Descriptions and Workings of OLE Threading Models." </p>
<h3>Reporting Errors</h3>
<p>
If you want to be a little friendlier to the users of your component, you can set the <b>Error Info</b>. It's up to the calling application to decide what to do with it. By default, ASP/VBScript will print the error number (and message, if there is one) and abort the page. Use <b>On Error Next</b> to override this behavior. </p>
<p>
Here is some code that takes a Win32 error or an HRESULT, gets the associated error message (if it exists) and reports it, and then returns the error as an HRESULT.</p>
<pre><code>HRESULT
 &nbsp;&nbsp; ReportError(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD dwErr)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ::ReportError(HRESULT_FROM_WIN32(dwErr), dwErr);
 &nbsp;&nbsp; }
 &nbsp;&nbsp; 
 &nbsp;&nbsp; 
 &nbsp;&nbsp; HRESULT
 &nbsp;&nbsp; ReportError(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HRESULT hr)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ::ReportError(hr, (DWORD) hr);
 &nbsp;&nbsp; }


 &nbsp;&nbsp; HRESULT
 &nbsp;&nbsp; ReportError(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HRESULT hr,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD&nbsp;&nbsp; dwErr)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HLOCAL pMsgBuf = NULL;
 &nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // If there's a message associated with this error, report that.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (::FormatMessage(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL, dwErr,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LPTSTR) &amp;pMsgBuf, 0, NULL)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt; 0)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AtlReportError(CLSID_CObj, (LPCTSTR) pMsgBuf, IID_IObj, hr);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // TODO: add some error messages to the string resources and
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // return those if FormatMessage doesn't return anything (not
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // all system errors have associated error messages).
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Free the buffer, which was allocated by FormatMessage.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pMsgBuf != NULL)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::LocalFree(pMsgBuf);
 &nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return hr;
 &nbsp;&nbsp; }
</code></pre>
<p>
You might call it like this:</p>
<pre><code>if (bstrName == NULL)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ::ReportError(E_POINTER);
</code></pre>
<p>
or like this: </p>
<pre><code>HANDLE hFile = CreateFile(...);
 &nbsp;&nbsp; if (hFile == INVALID_HANDLE_VALUE)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ::ReportError(::GetLastError());
</code></pre>
<h3>Exceptions</h3>
<p>
To reduce the size of the components, C++ exceptions are turned off for ATL components by default, as the C runtime library is required if exceptions are enabled. This has a few implications, notably that <b>new</b> does not throw exceptions, as it normally would. Instead it returns NULL. C++ exception handling can be turned on, however. It will be turned on if the Microsoft Foundation Class Library (MFC) is also being used. Accordingly, the ATL source is sprinkled with code like this:</p>
<pre><code>CFoo* pFoo = NULL;
 &nbsp;&nbsp; ATLTRY(pFoo = new CFoo(_T("Hello"), 7))
 &nbsp;&nbsp; if (pFoo == NULL)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return E_OUTOFMEMORY;
</code></pre>
<p>
where ATLTRY is defined as: </p>
<pre><code>#if defined (_CPPUNWIND) &amp; (defined(_ATL_EXCEPTIONS) | defined(_AFX))
 &nbsp;&nbsp; # define ATLTRY(x) try{x;} catch(...) {}
 &nbsp;&nbsp; #else
 &nbsp;&nbsp; # define ATLTRY(x) x;
 &nbsp;&nbsp; #endif
</code></pre>
<p>
It's up to you to decide if you want to turn on exceptions. Making a component 25K larger by linking in the C runtime library is much less of an issue for server components than for downloadable browser components. You'll probably want other features of the C runtime library anyway. If you do turn on exceptions, be aware that it is considered extremely bad form to throw C++ exceptions or structured exception handling (SHE) exceptions across COM boundaries, so you should catch all exceptions thrown in your code. If you leave exceptions disabled, then you must check for NULL.</p>
<h3>Character Sets</h3>
<p>
OLE/ActiveX is all Unicode, Windows NT uses Unicode internally, but Windows 95 uses the ANSI character set. ASP runs on both Windows NT and Windows 95. So, for maximum portability, you should not assume that your components will be running on a Unicode platform and you should not take short cuts such as the following, as they will fail on Windows 95:</p>
<pre><code>CreateFileW(..., bstrFilename, ...)
</code></pre>
<p>
ATL comes with a number of easy-to-use macros such as <b>OLE2T</b> for converting between BSTRs, Unicode, ANSI, and TCHARs. One caveat—these macros use <b>_alloca</b> internally, which allocates memory on the stack, so you must be careful about returning the results of these macros from functions.</p>
<h2>Samples</h2>
<p>
A number of samples are now available on the Microsoft IIS Samples site at <a href="http://www.microsoft.com/IIS/UsingIIS/Developing/Samples/">http://www.microsoft.com/IIS/UsingIIS/Developing/Samples/</a>. They include:
<ul type=disc>
<li>
Two small components, Simple and Power, each written in ATL, MFC, Java, Visual Basic 4.0, and Visual Basic 5.0, so you can compare and contrast their implementations<br><br></li>
<li>
A Registry access component (ATL)<br><br></li>
<li>
A page counter component (ATL)<br><br></li>
<li>
A permission checker component (ATL)<br><br></li>
<li>
An HTML database table formatting component (Java)<br><br></li>
<li>
A text formatter component (parallel implementations in ATL, Java, and Visual Basic 5.0)</li>
</ul>
<p>
Other components on the site include: 
<ul type=disc>
<li>
The Adventure Works application<br><br></li>
<li>
A utility to convert Internet Database Connector (.idc) files and HTML extension (.htx) files to ASP<br><br></li>
<li>
An ASP debugging script<br><br></li>
<li>
An ISAPI filter that allows ASP scripts to execute in virtual directories that lack execute permissions</li>
</ul>
</BODY>
</HTML>
