<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Debugging Microsoft Transaction Server Components</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_debug"></a>Debugging Microsoft Transaction Server Components</h1>
<p>
Microsoft Corporation</p>
<p>
June 1997</p>
<h2>Abstract</h2>
<p>
This article suggests techniques for debugging Microsoft® Transaction Server (MTS) components written with Microsoft Visual Basic®, Microsoft Visual C++®, and Microsoft Visual J++™ development tools. These suggestions are not mandatory for successfully debugging MTS components; you can choose your debugging environment and techniques according to your application needs.</p>
<p>
If you are using MTS components in a distributed environment, it is recommended that you debug your components on a single computer before deploying to multiple servers. Components that function without error in a package on a local computer should generally run successfully over a distributed network. If you do encounter problems with distributed components, you will have to test and debug both the client and server machines to determine the problem. It is also recommended that you stress test your application with as many clients as possible. You can build a test client that simulates multiple clients to perform the stress test on your application.</p>
<h2>Debugging Visual Basic MTS Components</h2>
<p>
MTS components that are written in Visual Basic version 5.0 or Visual C++ version 5.0 can be debugged in the Microsoft Visual Studio™ 97 Integrated Development Environment (IDE).</p>
<p>
If you want to debug your components after they are compiled, you cannot use the Visual Basic 5.0 debugger, which only debugs at design time. To debug a compiled Visual Basic component, you will need to use the Visual Studio 97 IDE debugger.</p>
<p>
Follow these steps to configure the Visual Studio IDE to debug MTS components built with Visual Basic 5.0:
<ol>
<li>
In the Visual Basic IDE, click Properties on the Project menu and then click the Compile tab to select the Compile to Native Code and the Create Symbolic Debug Info check box. You should also select the No Optimization check box while debugging.<br><br></li>
<li>
In the MTS Explorer, right-click on the package in which your component is installed and select the Properties option. Place your cursor over the Package ID and select and copy the GUID to the clipboard.<br><br></li>
<li>
Open the Visual Studio IDE. On the File menu, click Open and select the DLL containing the component that you want to debug.<br><br></li>
<li>
Select Project Settings, then click the Debug tab. Select the MTS executable for the debug session (\mtx\mtx.exe). Enter the program arguments as /p:{&lt;package GUID&gt;} for the package GUID that you copied from the package properties. MTS 2.0 allows for the package name to be used in place of the GUID. Open the .cls files containing the code that you want to debug and then set your breakpoints. You may also want to display variable information in the debug environment by going to the Visual Studio Tools menu, selecting Options, and then selecting the Debug tab. In the Debug tab, place a check next to Display Unicode Strings.<br><br></li>
<li>
In the MTS Explorer, shut down all server processes.<br><br></li>
<li>
In the Visual Studio IDE, select Build and then Start Debug. Next, select Go to run the server process that will host your component(s), and set breakpoints to step through your code.<br><br></li>
<li>
Run your client application to access and debug your components in the Visual Studio IDE.<br><br></li>
<li>
Before you deploy your application, remember to select one of the optimizing options in the Compile tab on the Project menu of the Visual Basic IDE (set to No Optimization in Step 1), and clear the Create Symbolic Debug Info check box and recompile the project.</li>
</ol>
<p>
In order to facilitate application debugging using Visual Basic 5.0, a component that uses <b>ObjectContext</b> can be debugged by enabling a special version of the object context. This debug-only version is enabled by creating the following registry key:</p>
<p>
<b>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Transaction Server\Debug\RunWithoutContext</b></p>
<p>
Note that when running in debug mode, none of the functionality of MTS is actually enabled. <b>GetObjectContext</b> will return the debug <b>ObjectContext</b> rather than returning <b>Nothing</b>. See the MTS Readme file for more information.</p>
<p>
You can also develop your own testing message box functions to generate an assert in an MTS Visual Basic component. The following sample code can be used to display error messages while debugging Visual Basic code. You can also use this in conjunction with the Microsoft Windows&nbsp;NT® debugger (WinDbg), a 32-bit application that, along with a collection of DLLs, is used for debugging the Kernel, device drivers, and applications. Note that you must enter DEBUGGING = -1 in the <b>Conditional Compilation</b> dialog box (located on the Make tab of the Project Properties dialog box) to enable the assert.</p>
<p>
<b>Example</b></p>
<pre><code>#If DEBUGGING Then
 &nbsp;&nbsp; 'API Functions
 &nbsp;&nbsp; Private Declare Sub OutputDebugStringA _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Lib "KERNEL32" (ByVal strError As String)
 &nbsp;&nbsp; Private Declare Function MessageBoxA _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Lib "USER32" (ByVal hwnd As Long, _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ByVal lpText As String, _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ByVal lpCaption As String, _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ByVal uType As Long) As Long
 &nbsp;&nbsp; 'API Constants
 &nbsp;&nbsp; Private Const API_NULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; As Long = 0
 &nbsp;&nbsp; Private Const MB_ICONERROR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; As Long = &amp;H10
 &nbsp;&nbsp; Private Const MB_SERVICE_NOTIFICATION As Long = &amp;H200000

Public Sub DebugPrint(ByVal strError As String)
 &nbsp;&nbsp; Call OutputDebugStringA(strError)
End Sub

Public Sub DebugMessage(ByVal strError As String)
 &nbsp;&nbsp; Dim lngReturn As Long
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lngReturn = MessageBoxA(API_NULL, strError, "Error In Component", _
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MB_ICONERROR Or MB_SERVICE_NOTIFICATION)
End Sub
#End If
</code></pre>
<p>
You can then run checks through your code to aid stress debugging.</p>
<p>
<b>Example</b></p>
<pre><code>SetobjObjectContext=GetObjectContext()
#If DEBUGGING Then
If objObjectContext Is Nothing Then Call DebugMessage(“Context is Not Available”)
#End If
</code></pre>
<h2>Debugging Visual C++ Microsoft Transaction Server Components</h2>
<p>
You can use Visual Studio 97 to debug MTS components written in Visual C++, including components that call Microsoft SQL Server™ functions or stored procedures. (See the section on debugging Visual Basic MTS components above for more information.)</p>
<p>
If you are using Visual Studio and Microsoft Foundation Classes (MFC) to debug, the TRACE macro can facilitate your debugging. The TRACE macro is an output debug function that traces debugging output to evaluate argument validity. The TRACE macro expressions specify a variable number of arguments that are used in exactly the same way that a variable number of arguments are used in the run-time function <b>printf</b>. The TRACE macro provides similar functionality to the <b>printf</b> function by sending a formatted string to a dump device such as a file or debug monitor. Like <b>printf</b> for C programs under MS-DOS, the TRACE macro is a convenient way to track the value of variables as your program executes. In the Debug environment, the TRACE macro output goes to afxDump. In the Release environment, the TRACE macro output does nothing.</p>
<p>
<b>Example</b></p>
<pre><code>// example for TRACE
int i = 1;
char sz[] = "one";
TRACE( "Integer = %d, String = %s\n", i, sz );
// Output: 'Integer = 1, String = one'
</code></pre>
<p>
The TRACE macro is available only in the debug version of MFC, but a similar function could be written for use without MFC. For more information on using the TRACE macro, see the "MFC Debugging Support" section in the <i>Microsoft Visual C++ Programmer's Guide</i> (on the Library at Developer Products, Visual C++).</p>
<p>
Note that you should avoid using standard ASSERT code in Visual C++. Instead, it is recommended that you write assert macros like a MessageBox using the MB_SERVICE_NOTIFICATION flag, and TRACE macro statements using the <b>OutputDebugString</b> function call.</p>
<h2>Debugging Java Classes</h2>
<p>
Debug your Java classes as thoroughly as possible before converting the Java classes into MTS components. Note that once your Java class is converted into an MTS component, it is not possible to step through the code in the Visual J++ debugger (or any current debugging tool).</p>
<h3>Using Visual J++ to Debug Java Classes</h3>
<p>
Microsoft Visual J++ provides a Java debugger that you can use to set breakpoints in your code. Note that when you are using Visual J++ to debug, if you set a breakpoint in a Java source file before starting the debugging session, Visual J++ sometimes will not stop on the breakpoint. For performance reasons, the debugger pre-loads only the main class of your project. The main class is either the class with the same name as the project or the class you specify in Visual J++. If you set breakpoints in other classes via the editor before the classes are loaded, the breakpoints are disabled.</p>
<p>
You can do one of the following to load the correct class so that the debugger stops at breakpoints:
<ul type=disc>
<li>
Specify the class in the category <b>Additional Classes</b>, located on the <b>Debug</b> tab of the Project<b> Settings</b> dialog box, and make sure the first column is checked. This loads the class when the debugging session starts.<br><br></li>
<li>
Right-click on a method in the <b>ClassView</b> pane of the <b>Project Workspace </b>and select Set<b> </b>Breakpoint from the <b>Shortcut</b> menu. This causes a break when program execution enters the method.<br><br></li>
<li>
Set the breakpoint after Visual J++ has loaded the class during debugging. You may need to step through your Java source until the class is loaded.</li>
</ul>
<p>
Also, when a method has one or more overloaded versions and shows up as a called method in the <b>Call Stack</b> window, the type and value for the parameters are not displayed in some cases. It appears as though the method takes no parameters. This occurs when the method being called is not defined as the first version of the overloaded method in the class definition. For example, see the following class definition.</p>
<pre><code>public class Test
 &nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int method(short s)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return s;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int method(int i)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return i;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp; }
</code></pre>
<p>
If you were looking at a call to the second version of the method in the <b>Call Stack </b>window, it would appear without the type and value for the method:</p>
<pre><code>method()
</code></pre>
<p>
To view the method’s parameters, change the order of the method overloads so that the method you are currently debugging is first in the class definition.</p>
<h2>printf-style Debugging</h2>
<p>
You can use printf-style debugging to debug your Java classes without using a debugger. printf-style debugging involves including status text messages into your code, allowing you to "step through" your code without a debugger. You can also use printf-style debugging to return error information. The following code shows how you can add a System.out.println call to the <b>try</b> clause of the Hellojtx.HelloObj.SayHello sample.</p>
<pre><code>try
{&nbsp;&nbsp;&nbsp; 
System.out.println("This message is from the HelloObj implementation");
 &nbsp;&nbsp; result[0] = "Hello from simple MTS Java sample";
 &nbsp;&nbsp; MTx.GetObjectContext().SetComplete();
 &nbsp;&nbsp; return 0;
}
</code></pre>
<p>
The client must be a Java client class, and you must use the JVIEW<b> </b>console<b> </b>window to run that class. Note that you should configure your component to run in the process of its caller (in this case, the JVIEW). Otherwise, this debugging technique results in your component running in the MTS server process (mtx.exe), which would put the <b>println</b> output in the bit bucket rather than the JVIEW console window.</p>
<p>
Use the MTS Explorer to configure your component to run in the caller's process by following these steps.
<ol>
<li>
Right-click on the component.<br><br></li>
<li>
Click the Properties<b> </b>option.<br><br></li>
<li>
Click the Activation tab and clear the "In a server process on this computer" check box.<br><br></li>
<li>
Select the "In the creator’s process..." check box.<br><br></li>
<li>
Reload the Client class. Your component's <b>println</b> calls will be visible in the JVIEW console window.</li>
</ol>
<h2>Using the AWT Classes</h2>
<p>
You can also use the Abstract Window Toolkit (AWT) classes to display intermediate results, even if your component is running in a server process. The java.awt package provides an integrated set of classes to manage user interface components such as windows, dialog boxes, buttons, checkboxes, lists, menus, scrollbars, and text fields.</p>
<p>
The following example demonstrates how to use the AWT classes to display intermediate results in a dialog box:</p>
<pre><code>import java.awt.*;

public final class MyMessage extends Frame
{

 &nbsp;&nbsp; private Button closeButton;
 &nbsp;&nbsp; private Label textLabel;

 &nbsp;&nbsp; // constructor
 &nbsp;&nbsp; public MyMessage(String msg)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; super("Debug Window");

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Panel panel;

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; textLabel = new Label (msg, Label.CENTER);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; closeButton = new Button ("Close");

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setLayout (new BorderLayout (15, 15));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add ("Center", textLabel);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add ("South", closeButton);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pack();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; show();
 &nbsp;&nbsp; }

 &nbsp;&nbsp; public boolean action (Event e, Object arg)
 &nbsp;&nbsp; {

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (e.target == closeButton)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hide();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dispose();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;
 &nbsp;&nbsp; }

}
</code></pre>
<h2>Asynchronous Java Garbage Collection</h2>
<p>
Note that garbage collection for Java components is asynchronous to program execution and can cause unexpected behavior. This behavior especially affects MTS components that perform functions like enumerating through the collections in the catalog, because the collection count will be too high (since garbage collection of pointers is not synchronized). To force synchronous release of references to COM or MTS objects, you can use the release method defined in class com.ms.com.ComLib.</p>
<p>
<b>Example</b></p>
<pre><code>Import com.ms.com.ComLib
…
ComLib.release(someMTSObject);
</code></pre>
<p>
This method releases the reference to the object when the call is executed. Release the object reference when you are sure that the reference will not be used again. Note that if you fail to release the reference, you will not be returned an application error. However, your collection count will be incorrect because the object reference will be released asynchronously when the garbage collector eventually runs.</p>
<p>
You can also force the release of your pointer and not call that released pointer again. </p>
<p>
<b>Example</b></p>
<pre><code>myHello = null;
 &nbsp;&nbsp; System.gc();
</code></pre>
<p>
Note that forcing the release of a pointer consumes extensive system resources. It is recommended that you use the release method defined in class com.ms.com.ComLib to enable synchronous release of references to MTS objects.</p>
</BODY>
</HTML>
