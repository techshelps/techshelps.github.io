<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Creating Add-Ins for the Visual FoxPro Class Browser</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_addins"></a>Creating Add-Ins for the Visual FoxPro Class Browser</h1>
<p>
August 1, 1995</p>
<h2>Introduction</h2>
<p>
Working with class libraries and managing them is not an easy task. The Class Browser in Microsoft® Visual FoxPro® provides an easy, user-friendly interface for dealing with visual class libraries. However, ease of use represents only a mere fraction of the Class Browser's power. The Class Browser also supports the unique customization ability provided by add-ins.</p>
<h2>Flexibility and the Class Browser</h2>
<p>
The key to a tool is how well it can work in getting a job done. Managing class libraries carries with it a myriad of chores, from checking the code in a class to merging it with the production libraries.</p>
<p>
Visual FoxPro, in true keeping with the history of both Microsoft's visual development tools and the FoxPro product line, not only provides a simple-to-use tool for managing class libraries, but has also made the architecture of this utility totally open so that it can be customized to fit the needs of every individual. This customization is accomplished using add-ins.</p>
<h2>Add-Ins</h2>
<p>
An <i>add-in</i> is a program that you write and "register" with the Class Browser. Once registered, this program can be executed automatically in response to an event in the Class Browser, or can be called manually by the user. An add-in can do just about anything you'd like.</p>
<h3>An Add-In Program</h3>
<pre><code>*&nbsp; Program...........: CLSNAME.PRG
*) Description.......: Simple add-in for the Class Browser that
*)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : displays the current class name.
*&nbsp; Calling Samples...: 
*&nbsp; Parameter List....: 
*&nbsp; Major change list.: 

LPARAMETERS toSource

WAIT WINDOW toSource.ProperBaseClass(toSource.cClass)

RETURN
</code></pre>
<p>
Note the parameter—the Class Browser, when calling the add-in, passes <i>itself</i> as a parameter to the add-in. This means that all of the member objects, properties, events, and methods are available for reference. In the example above, the Class Browser's <b>ProperBaseClass()</b> method and <b>cClass</b> property are used in the add-in.</p>
<p>
This capability allows you to do many things. You can use the information in the Class Browser to guide what you want to do (for example, if the currently selected class is really the .VCX file, you could loop through all the classes in the .VCX instead of just using the class currently selected), access the methods, or even get at the .VCX table itself. Understanding and using this powerful feature is key to creating add-ins. </p>
<p>
Let's cover the nuts and bolts of registering and running add-ins.</p>
<h3>Registering the Add-In</h3>
<p>
Before you can use an add-in, you must register it as follows (the Class Browser must be running):</p>
<pre><code>_oBrowser.AddIn("AddIn Name", "ClsName")
</code></pre>
<p>
The <b>Addin()</b> method registers an add-in. The syntax shown above specifies a name for the add-in (<i>AddIn Name</i>) and the program to run (ClsName.Prg). The name is case-insensitive, but the way you specify it determines the way it will be displayed in the Add-in menu.</p>
<h3>Running the Add-In</h3>
<p>
The add-in can be run in several ways. First of all, the add-in can be run with the <b>DoAddIn()</b> method, using the syntax:</p>
<pre><code>_oBrowser.DoAddIn("Class Name")
</code></pre>
<p>
Passing the name of a registered add-in to the <b>DoAddIn()</b> method will run that add-in.</p>
<p>
You can also run an add-in by clicking the Add-in button, which activates a menu with the installed add-ins. Figure 1 shows the Class Browser with the Add-In menu activated from the Add-in button.</p>
<p>
<img src="addins_1.gif" border=0></p>
<p class=label>
<b>Figure 1. Class Browser with Add-In menu</b></p>
<p>
The same menu can be expanded manually with the <b>AddInMenu()</b> method as follows:</p>
<pre><code>_oBrowser.AddInMenu()
</code></pre>
<p>
Running this method will expand the menu at the location of the mouse pointer. You can close the menu with <b>_oBrowser.DeactivateMenu()</b> although you shouldn't need to because the menu is automatically closed when a selection is made.</p>
<h3>Unregistering an Add-In</h3>
<p>
You can also use the <b>AddIn()</b> method to remove an add-in from the Browser registration table:</p>
<pre><code>_oBrowser.AddIn("Class Name",.NULL.)
</code></pre>
<p>
If the program name is provided as a value of .NULL., the Add-In record in the Browser registration table is marked for deletion.</p>
<h2>Boosting Power with Add-Ins</h2>
<p>
Add-ins let you do all kinds of great things. The previous example is simple: It displays the name of the currently selected class by accepting the object parameter (remember, the Class Browser is the parameter) and then accessing the <b>cClass</b> property in the WAIT WINDOW command.</p>
<p>
While the previous example is not particularly useful, it does illustrate a few key concepts. First, using the Class Browser as the parameter to the add-in gives the add-in access to the full power of the Class Browser. That's why it is so important to take the time to learn about the objects, properties, events, and methods of the Class Browser (they're all documented in the Visual FoxPro help file). Another key point here is that there is not much that an add-in cannot do for you.</p>
<p>
The following add-in adds some additional header information to the code exported with the Class Browser's <b>ExportClass()</b> method. It is useful when having to represent a class in code. You may need to do this for system documentation, when writing articles or books, and so on.</p>
<pre><code>*&nbsp; Program...........: DOCCLASS.PRG
*) Description.......: DocClass is an add-in program for
*)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : the Class Browser that exports
*)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : the code for a class with a 
*)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : standard heading at the top.
*&nbsp; Calling Samples...: 
*&nbsp; Parameter List....: 
*&nbsp; Major change list.: 

LPARAMETERS toObject

#DEFINE cr_lf chr(13)+chr(10)

_cliptext = toObject.ExportClass()

LOCAL laHdrLine[5], lcText, lnCounter

laHdrLine[1] = "*&nbsp; Class.............: " + ;
 &nbsp;&nbsp;&nbsp;&nbsp; toObject.ProperBaseClass(toObject.cClass)
laHdrLine[2] = "*&nbsp; Author............: " + ;
 &nbsp;&nbsp;&nbsp;&nbsp; "Joe Developer"
laHdrLine[3] = "*&nbsp; Project...........: " + ;
 &nbsp;&nbsp;&nbsp;&nbsp; "My Project"
laHdrLine[4] = "*&nbsp; Copyright.........: " + ;
 &nbsp;&nbsp;&nbsp;&nbsp; "(c) My Company, Inc. 1995"
laHdrLine[5] = "*&nbsp; Notes.............: " + ;
 &nbsp;&nbsp;&nbsp;&nbsp; "Exported code from Class Browser."

lcText = ""

FOR lnCounter = 1 TO ALEN(laHdrLine,1)
 &nbsp; lcText = lcText + ;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; laHdrLine[lnCounter] + cr_lf
ENDFOR

lcText = lcText + cr_lf

_cliptext = lcText + _cliptext

=MessageBox("Code exported to clipboard!", 32)

RETURN
</code></pre>
<p>
In theory, this add-in is very simple: The <b>ExportClass()</b> method is used to dump the code for the class into the clipboard (modifying <b>_cliptext</b> modifies the clipboard). The array holds the additional header lines, which are then added, with carriage returns and line feeds, to the output text. The output text can then be pasted wherever it is needed.</p>
<p>
This is a fairly good example of an add-in because it automates a procedure and reduces it to two simple mouse clicks.</p>
<h2>Changing Class Browser Behavior with Add-Ins</h2>
<p>
By installing an add-using the manner shown earlier, you could run it by selecting a class, clicking on the Add-in command button, and selecting the appropriate menu item.</p>
<p>
Sometimes an add-in most appropriately enhances or replaces existing functionality in the Class Browser. For example, the <i>DocumentClass</i> add-in could be viewed as analogous to the View Class command button. You could say that it would be appropriate to hook this add-in to the <b>RightClick</b> event of the View Class button instead of adding it to the Add-In menu.</p>
<p>
To show how this is accomplished, let me take a closer look at the syntax of the <b>AddIn()</b> method.</p>
<pre><code>AddIn(&lt;Add-in Name&gt;, ;
 &nbsp;&nbsp;&nbsp;&nbsp; &lt;Program Name&gt;, ;
 &nbsp;&nbsp;&nbsp;&nbsp; &lt;Method Name&gt;, ;
 &nbsp;&nbsp;&nbsp;&nbsp; &lt;Active For Files&gt;, ;
 &nbsp;&nbsp;&nbsp;&nbsp; &lt;PlatForm&gt;, ;
 &nbsp;&nbsp;&nbsp;&nbsp; &lt;Comment&gt;)
</code></pre>
<p>
This function installs or removes a Class Browser add-in. It has the following parameters:
<ul type=disc>
<li>
<i>Add-in Name</i> is the name of the add-in. This name can consist of one or more words. Case is not important except that it will be displayed on the menu exactly as it is specified here. The add-in will be displayed in the Add-In menu if the third parameter (<i>Method Name</i>) is not specified.<br><br></li>
<li>
<i>Program Name</i> is the name of a program to run. The program can be a .PRG, .APP, .EXE, or .FXP file. In addition, you can specify a .SCX. .PRG is the assumed extension; specify other extensions as appropriate.<p class=tl>
<i>Program Name</i> can also be the name of an object. You would use the syntax &lt;<i>.VCX Name, Class Name</i>&gt;;for example:</P><pre><code>_oBrowser.AddIn("MyAddIn", "MyVcx.VCX, MyClass")
</code></pre>
<p class=tl>
When the add-in is run, the class <i>MyClass</i> of MyVcx.VCX is instantiated. Remember that an object parameter will be sent through to the class.</P><p class=tl>
It's not a bad idea to specify a full path to the program in this parameter. This will ensure that the add-in runs properly regardless of its location. If the Class Browser cannot find the program or .VCX when trying to call an add-in, an error will be generated.</P></li>
<li>
<i>Method Name </i>is the name of a method that automatically calls the add-in. Any valid method, either a method of the Class Browser form or one of its objects, can be a hook for a method. For example, if you wanted to hook <i>MyAddIn</i> to the Export command button's <b>RightClick</b> event, you could specify:<pre><code>_oBrowser.AddIn("MyAddIn", , "CmdExport.Click")
</code></pre>
<p class=tl>
Note, by the way, that you do not have to specify the second parameter in this command. This allows you to change the registration of an add-in only as much as you need. In this case, since the program that will run when <i>MyAddIn</i> is run does not change, there was no need to specify that parameter. Leaving it blank will pass a logical .F. to the corresponding parameter variable. The <b>AddIn() </b>method is intelligent enough to understand that an empty parameter means that the corresponding value remains unchanged.</P><p class=tl>
The third parameter is the key to this task. By specifying the <b>cmdExport.RightClick</b> method in the third parameter, the add-in is hooked to that event and will be called by that event when it fires.</P><p class=tl>
By the way, if you hook into a method that already has behavior (for example, the click method of <b>cmdExport</b> calls <b>ExportClass()</b>), the add-in will run before the original behavior. If you have multiple add-ins registered for a method, they will run in the order in which they were registered.</P><p class=tl>
Finally, if you want to totally override the behavior of a method (for example, you do not want <b>cmdExport</b> to call <b>ExportClass()</b>), the add-in must set the <i>lNoDefault</i> property on the Class Browser to .T. If this property is set to .T., the Class Browser method will detect this and ignore the rest of the method.</P></li>
<li>
<i>Active For Files</i> allows you to determine the files for which the add-in will work. By default, when an add-in is added to the Class Browser registration table, it is available for all .VCX and .SCX files you work with. This parameter allows you to specify a file or list of files (separated by commas) for which this add-in would be available. For other files loaded into the Class Browser, the add-in would simply not exist.<br><br></li>
<li>
<i>Platform</i> specifies the platform (for example, Microsoft® Windows®) on which the add-in will work. By default, the add-in is available for all platforms.<br><br></li>
<li>
<i>Comment</i> is an optional comment you can store with the add-in.</li>
</ul>
<p>
If you take a close look at the <b>AddIn()</b> method, you will notice that it provides a wealth of insight into the power and flexibility of the Class Browser. Add-ins can allow you to totally customize the Class Browser to run your code at almost any interval.</p>
<p>
For example, if you wish to use Courier New as the font for the Class Browser, you can create the following add-in and register it for the <b>Init()</b> method:</p>
<pre><code>*&nbsp; Program...........: FONTSET.PRG
*&nbsp; Author............: Menachem Bazian, CPA
*&nbsp; Copyright.........: (c) Flash Creative Management, Inc., 1995
*) Description.......: Set the fonts for the class

LPARAMETERS toSource

toSource.SetFont("Courier New")
</code></pre>
<p>
To register the add-in, use:</p>
<pre><code>_oBrowser.AddIn("FontSet", "FontSet", "Init")
</code></pre>
<p>
Figure 2 shows the Class Browser form after you run this add-in.</p>
<p>
<img src="addins_2.gif" border=0></p>
<p class=label>
<b>Figure 2. Class Browser with FontSet</b></p>
<h2>Handling the Rename Crisis with an Add-In</h2>
<p>
Here's one final add-in. Renaming a class can be very dangerous because it can break the chain in a class hierarchy. Take the following example:</p>
<p>
Suppose you have a <i>CommandButton</i> class called <b>OKButton</b>. <b>OKButtonSubclass</b> is a subclass of <b>OKButton</b>. Now, you rename <b>OKButton</b> to <b>CloseButton</b>. At that point, the <b>OKButtonSubclass</b> class is orphaned and no longer references the right parent class. In effect, <b>OKButtonSubclass</b> is now useless.</p>
<p>
This situation can be remedied. If the Class Browser is set to display classes in alphabetical mode, you will be able to see <b>OKButtonSubclass</b> in the list of classes. You could then use the Redefine feature to set <b>OKButtonSubclass</b> as a subclass of <b>CloseButton</b> instead of <b>OKButton</b>. However, if you do a lot of renaming, or if there are many subclasses in a renamed class, all this work can get tedious.</p>
<p>
The following add-in will take care of the problem. This add-in, called RenmAll.PRG, handles the renaming of all classes and objects based on the current object. Thus, if you rename a class from <b>MyOriginalClass</b> to <b>MyNewClass</b>, all subclasses of <b>MyOriginalClass</b> will be changed to reference <b>MyNewClass</b> instead.</p>
<p>
The key to this add-in is knowing that the class name on which an object is based is stored in the <b>Class</b> field in the .VCX. The only limitation to this add-in is that it can adjust only classes and forms that are loaded in the Class Browser.</p>
<p>
Here's the code:</p>
<pre><code>*&nbsp; Program...........: RENMALL.PRG
*) Description.......: Renames a class in the Class Browser
*)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : and keeps the class hierarchy alive
*&nbsp; Calling Samples...: 
*&nbsp; Parameter List....: 
*&nbsp; Major change list.: 

LPARAMETERS toSource

LOCAL lcOldClassName, lcNewClassName, lnOldDataSession, lnOldArea, lnOldDisplayMode

*-- The idea here is very simple. As long as the classes are 
*-- loaded in the Class Browser, we can get at the metadata
*-- tables (metadata1 - &lt;n&gt;).
*--
*-- All we need to do is get to all the records with the 
*-- OLD class name in the CLASS field and change it to the new name.

*-- Note, by the way, that this will REPLACE the cmdRename button's 
*-- click method entirely.

toSource.lNoDefault = .T.

*-- First, get and save the current class name.

lcOldClassName = ALLTRIM(LOWER(toSource.cClass))

*-- In order to prevent an error message, we need to
*-- set display mode to alphabetical. We'll set it back
*-- on the way out.

lnOldDisplayMode = toSource.opgDisplayMode.Value
toSource.opgDisplayMode.Value = 2

*-- Now, the name dialog.

toSource.RenameClass()

*-- Get the new class name.

lcNewClassName = ALLTRIM(LOWER(toSource.cClass))

*-- Now, go through all the classes in all open metadata tables.

lnOldDataSess = SET("datasession")

SET DATASESSION TO (toSource.DataSessionId)

*-- A quick note: You can have up to 255 tables open per 
*-- data session (according to the help file, anyway).
*--
*-- There is a slim chance that the Class Browser will have
*-- that many files open. However, since the following loop
*-- will run only until it finds an empty work area, this is 
*-- an easy way to run through all the work areas. 

lnOldArea = SELECT()

FOR lnCounter = 1 TO 255
 &nbsp; SELECT (lnCounter)
 &nbsp; 
 &nbsp; IF EMPTY(alias())
 &nbsp;&nbsp;&nbsp;&nbsp; EXIT
 &nbsp; ENDIF
 &nbsp; 
 &nbsp; IF "METADATA" $ UPPER(ALIAS())
 &nbsp;&nbsp;&nbsp;&nbsp; =RenameClasses(lcOldClassName, lcNewClassName)
 &nbsp; ENDIF
ENDFOR

SELECT (lnOldArea)
SET DATASESSION TO (lnOldDataSess)

toSource.RefreshClassList()
toSource.opgDisplayMode.Value = lnOldDisplayMode

RETURN

*&nbsp; Procedure.........: RenameClasses&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
*&nbsp; Created...........: June 19, 1995 - 12:23:43
*&nbsp; Copyright.........: (c) Flash Creative Management, Inc., 1995
*) Description.......: Loops through the metadata table and renames
*&nbsp; Calling Samples...: 
*&nbsp; Parameter List....: 
*&nbsp; Major change list.: 

************************************************************
PROCEDURE RenameClasses&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
************************************************************

LPARAMETERS tcOldClassName, tcNewClassName

GO TOP
SCAN 
 &nbsp; IF LOWER(ALLTRIM(tcOldClassName)) == LOWER(ALLTRIM(Class))
 &nbsp;&nbsp;&nbsp;&nbsp; REPLACE Class WITH LOWER(ALLTRIM(tcNewClassName))
 &nbsp; ENDIF
ENDSCAN

RETURN
</code></pre>
<p>
The idea is simple: Call the <b>RenameClass()</b> method from here and trap the class name both before and after the class is renamed. Then, loop through all the records in all the open .VCX and .SCX files (that is, through all files with an alias of METADATA*) and replace all occurrences of the old class name with the new one.</p>
<p>
Note that the add-in starts out by setting the display mode to alphabetical before playing with the class names. If the display is in hierarchical mode, the Class Browser will generate an error after renaming a parent class, indicating that it cannot rebuild the tree (because the chain has been broken). When all the names have been modified, the <b>RefreshClassList()</b> method is called to read in the classes again, and the display is reset to what it was before the add-in was executed.</p>
<p>
Note also that this method is designed to replace the functionality of <b>cmdRename.Click()</b>. By setting <i>lNoDefault</i> to .T., the rename button's original click method will not run.</p>
<p>
To register this add-in:</p>
<pre><code>_oBrowser.AddIn("Full Rename", CURDIR()+"RenmAll", "cmdRename.Click")
</code></pre>
<h2>Conclusion</h2>
<p>
The true test of a development environment lies not only in the features of the language but also in the tools it provides to get the job done. </p>
<p>
Managing class libraries is not an easy task. The Class Browser represents, in its vanilla form, a powerful tool for managing class libraries. The hidden power of the Class Browser, however, in the form of the open architecture inherent in its class-driven design and in the add-in feature, increases its utility tremendously. Add-ins are being created to perform a myriad of tasks.</p>
<p>
The job of managing class libraries is difficult enough without having to worry about the manual aspects. The Class Browser gives developers and class librarians a powerful way to facilitate many tasks.</p>
<h2>Acknowledgments</h2>
<p>
We acknowledge the help of Flash Creative Management, Inc., Hackensack, NJ, in providing this material.</p>
</BODY>
</HTML>
