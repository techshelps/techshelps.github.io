<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Microsoft Internet Explorer 3.0 Signature and Certificate Interface: Application Programmer's Guide and Reference</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>
<h1><a name="msdn_iesignwp"></a>Microsoft Internet Explorer 3.0 Signature and Certificate Interface: Application Programmer's Guide and Reference</h1>
<p>
Beta Release </p>
<p>
September 10, 1996 </p>
<p>
(Preliminary) </p>
<p>
Microsoft Corporation </p>
<h3>Contents </h3>
<h4><a href="#iesignoverview">Overview</a></h4>
<p>
<a href="#iesigndataint">Data Integrity Through Digital Signatures</a><br>
<a href="#iesignentityauthent">Entity Authentication Through Certificates</a><br>
<a href="#iesignhierarchy">The Hierarchy of Trust</a><br>
<a href="#iesigndigcert">Digital Certification</a><br>
<a href="#iesignrelatedstan">Overview of Related Standards</a><br>
<a href="#iesignx509certif">X.509 Certificates</a><br>
<a href="#iesignx500name">X.500 Names</a><br>
<a href="#iesignpkcs7">PKCS #7 Signed Data Signature Blocks</a><br>
<a href="#iesignpkcs10">PKCS #10 Certification Request</a></p>
<h4><a href="#iesigncominterface">The COM Interface Suite</a></h4>
<p>
<a href="#iesigncompclass">Component Classes</a></p>
<p class=indent>
<a href="#iesigncertificates">Certificates</a><br>
<a href="#iesigncertstore">Certificate Store</a><br>
<a href="#iesigncertrequest">Certificate Requests</a><br>
<a href="#iesignsigblock">Signature Blocks</a></p>
<p>
<a href="#iesignimpint">Important Interfaces</a></p>
<p class=indent>
<a href="#iesigniamhashed">IAmHashed</a><br>
<a href="#iesigniamsigned">IAmSigned</a><br>
<a href="#iesignicertificatelist">ICertificateList</a><br>
<a href="#iesignicertificatestore">ICertificateStore</a><br>
<a href="#iesignicertificatestoreaux">ICertificateStoreAux</a><br>
<a href="#iesignicertificatestorereginit">ICertificateStoreRegInit</a><br>
<a href="#iesignipkcs7signeddata">IPkcs7SignedData</a><br>
<a href="#iesignipkcs10">IPkcs10</a> <br>
<a href="#iesignipublickeycontainer">IPublicKeyContainer</a><br>
<a href="#iesignipublickeypair">IPublicKeyPair</a><br>
<a href="#iesigniselectedattributes">ISelectedAttributes</a> <br>
<a href="#iesignisignabledocument">ISignableDocument</a><br>
<a href="#iesignisignerinfo">ISignerInfo</a> <br>
<a href="#iesignix509">IX509</a> <br>
<a href="#iesignix500name">IX500Name</a> </p>
<p>
This document describes a suite of COM interfaces that manipulate objects relating to the technical infrastructure needed to support the affixing of "digital signatures" to data of various forms and, subsequently, to verify that a given signature is correct and is acceptable. </p>
<h2><a name="iesignoverview"></a>Overview</h2>
<p>
Secure communications over nonsecure networks generally involves three major areas of concern—privacy, authentication, and data integrity. </p>
<p>
<i>Privacy</i> indicates the desire to keep anyone except the intended recipient from being able to read the message. Accomplishing this usually involves some type of data encryption and decryption, otherwise known as cryptography. </p>
<p>
<i>Authentication</i> is the need to know that the entity with whom you are communicating is, in fact, who you think it is. Perhaps the most common method of accomplishing this is through the use of certificates. A certificate is a set of data that identifies an entity and verifies that the specific public encryption and signature keys belongs to that entity. A certificate is issued by a Certification Authority (CA) only after that authority has verified that the specified public key belongs to the specified entity. </p>
<p>
Another concern in secure communications is <i>data integrity</i>—the process of insuring that the data has not been changed or modified while en route to its intended destination. Data integrity is usually accomplished through the use of digital signatures, the electronic equivalent of a written signature on a piece of paper. </p>
<p>
The Microsoft® Internet Explorer version 3.0 Signature and Certificate Interface (IE3 Sig) addresses the concerns of authentication and of data integrity. Authentication is addressed through COM interfaces that provide for the processing and management of certificates, and data integrity is addressed through COM interfaces that provide for the processing of digital signatures. </p>
<h3><a name="iesigndataint"></a>Data Integrity Through Digital Signatures</h3>
<p>
Digital signatures are based on well-known cryptographic technologies known as <i>public-key</i> cryptography. To sign a document, the signer first produces a hash of the object using one of several well-known and well-studied cryptographic hash algorithms. Cryptographic hashes are typically large, on the order of sixteen to twenty bytes, and are believed to be <i>secure</i> in the sense that it is computationally unfeasible to find a document that hashes to a particular, given value. Cryptographic hash algorithms are sometimes also referred to as digest <i>algorithms</i>.</p>
<p>
The <i>signature</i> of the document is then nothing more than the encryption of the document's hash. However, a special type of encryption algorithm is used, one where the key used to encrypt data is different than the key later used to decrypt it and, further, knowledge of one key doesn't help you figure out what the other one is. One key in such a pair is kept secret and is known as the <i>private</i> key. It's corresponding mate is broadly distributed and is called a <i>public</i> key. </p>
<p>
The signature, then, is the encryption of the document's hash using a certain private key. The document and its signature are then together distributed to the appropriate recipients. </p>
<p>
To verify the signature, the recipient computes the hash in two ways:
<ol>
<li>
From the document itself, just as the signer did.<br><br></li>
<li>
By decrypting the encrypted hash that he was given, using, of course, the appropriate public key. </li>
</ol>
<p>
If the two hashes match, the recipient can be assured that the contents of the document are in the same state as when they were signed and that they were signed by the person who has possession of the private key that corresponds to the public key used to decrypt the hash. </p>
<h3><a name="iesignentityauthent"></a>Entity Authentication Through Certificates</h3>
<p>
The use of some physical document to achieve authentication has been in existence for a long time. For example, when you write a check for some purchase and the merchant asks to see your driver's license, the license is being used to increase the merchant's confidence that you are who the check indicates you are. In this case, the merchant trusts that the state that issued you the license did an adequate job of verifying your identity. Another example is your use of a passport when traveling. The customs official who looks at your passport and accepts it as proof that you are who you say you are trusts that your government did an adequate job of identifying you before issuing you a passport. Notice that in both examples there has to be a level of trust in the certifying authority. </p>
<p>
This same concept has been applied to the authentication of persons and entities on a digital communications network. The documents that provide authentication of persons and entities on a network are called digital certificates or, more often, just certificates. The use of certificates on a network is more complex because of the fact that the communicating parties will most likely never physically meet—necessitating that a method be worked out so that the necessary level of trust is still maintained. Additionally, on a network, it is much easier for unethical people to intercept messages and pretend to be someone that they are not. To prevent these kinds of problems, cryptographic techniques are used on the certificate to make it very difficult, if not impossible, for someone to modify it such that he or she can pose as someone else. </p>
<p>
Digital certificates have one other unique characteristic. They contain the public key of the person or entity to whom the certificate is issued. </p>
<h3><a name="iesignhierarchy"></a>The Hierarchy of Trust</h3>
<p>
As mentioned in the previous section, in order for digital certificates to be effective, the users of the network must have a high level of trust in the certificate. But what happens if someone doesn't trust the CA—perhaps the person has never heard of the CA before and, therefore, is uncomfortable with accepting the certificate at face value. This problem is addressed in the certifying process by something called the hierarchy of trust. </p>
<p>
The concept of hierarchy of trust is simply that the process must begin with some certifying authority that everyone agrees is trustworthy. Perhaps this could be some agency of the federal government such as the U.S. Postal Service or some company that everyone agrees is trustworthy. This ultimate authority, whatever it is, is called the root authority. The root authority then can certify other, first-tier CAs, who can then certify second-tier CAs, as shown in the following diagram. </p>
<p>
<img src="iesignwp_1.gif" border=0></p>
<p class=label>
<b>Figure 1. The hierarchy of trust </b></p>
<p>
When someone on the network receives a certificate that has been issued by a first- or second-tier CA, he or she can verify that the CA that signed the certificate has been certified by a CA at the tier above it and that, in turn, that CA has been certified by the one above it, and so on until a chain of trust exists between the lower level CA (or a user certificate) and the root CA. For example, in the preceding diagram, it can be verified that CA #4 was certified by CA #1 and that CA #1 was certified by the root CA. This means that when a certificate from a lower-level CA is passed along with the encrypted message, all of the certificates in its chain of trust up to the root should be passed along with it. </p>
<p>
It should be noted that the diagram and description just presented is conceptual; in the real world the situation is rapidly evolving, with no single "root" authority having been established or accepted. It remains to be seen exactly how the actual situation will evolve. </p>
<h3><a name="iesigndigcert"></a>Digital Certification</h3>
<p>
One of the primary goals of a digital certificate is to confirm that the public key contained in the certificate is, in fact, the public key belonging to the person or entity to whom the certificate is issued. For example, a CA may digitally sign a special message (the certificate information) containing the name of a user, say "Alice," and her public key. This is done in such a way that anyone can verify that the certificate information message was signed by only the CA and can, thereby, develop trust in Alice's public key. </p>
<p>
The typical implementation of digital certification involves a signature algorithm for signing the certificate. The process may go as follows:
<ol>
<li>
Alice sends a signed certification request containing her name and her public key to a CA. The request must be signed by Alice to prove that she has the private key that coincides with the public key contained in the request.<br><br></li>
<li>
The CA creates a special message from Alice's request and signs it with its private key, obtaining a separate signature in the process. The CA returns the message and the signature to Alice; the two parts together form a certificate.<br><br></li>
<li>
Alice sends the certificate to Bob to convey trust in her public key.<br><br></li>
<li>
Bob verifies the signature using the CA's public key. If the signature proves valid, he accepts Alice's public key. </li>
</ol>
<p>
As with an ordinary digital signature, anyone can verify, at any time and without any secret information, that the certificate was signed by the CA.</p>
<p>
The scenario just presented assumes that Bob knows the CA's public key. That key could be obtained by getting a copy of the CA's certificate, which contains its public key. </p>
<p>
A broader application of digital certification produces a certificate that includes not only Alice's name and public key, but also other information about Alice. Such a certificate is usually called an extended certificate. Extended certificates are more than stepping stones in a digital hierarchy of trust. They enable the CA to give Bob a means of trusting not only Alice's public key, but also that other information. The other information may include, for example, Alice's e-mail address, her authorization to sign documents of a given value, or her authorization to sign other certificates. </p>
<p>
Because certificates have a valid time duration, it is possible for the certificate to expire and no longer be valid. It is also possible for certificates to be revoked by the CA for other reasons. To handle this situation, the CA maintains a list of revoked certificates. This list is called a certificate revocation list (CRL) and is made available to users of the network so that they can determine the validity of any given certificate. </p>
<h3><a name="iesignrelatedstan"></a>Overview of Related Standards</h3>
<p>
Quite a number of broadly used standards exist in the area of public key cryptography and digital signatures. Among these are:
<ul type=disc>
<li>
The Open Systems Interconnect (OSI) Abstract Syntax Notation One (ASN.1) data definition language. ASN.1 is a notation for defining data formats such as structures, unions, and arrays. When used with an accompanying encoding standard, such as the Distinguished Encoding Rules (DER), an ASN.1 definition precisely defines a byte representation that encodes some particular data. Nearly all of the standards relevant to this area have their standard data formats defined using ASN.1. <br><br></li>
<li>
RSA Data Security, Inc. encryption standard, known as RSA Public Key Cryptography Standard #1 (PKCS #1_. This standard defines a particular suite of cryptographic hash algorithms, public key encryption algorithms, and standard encoding for hashes and signatures. There are other relevant cryptographic standards, such as the Secure Hash Algorithm (SHA) from the National Institute of Standards and Technology (NIST). <br><br></li>
<li>
X.509v3 Certificate Standard. This OSI/ITU-T standard defines both the de jure and (amazingly) de facto standard representation of a digital certificate. <br><br></li>
<li>
PKCS #7 Cryptographic Message Syntax Standard. This standard defines, among other things, a standard representation of a <i>signature block</i>—a way to attach one or more signatures to a block of data that one wishes to sign. <br><br></li>
<li>
PKCS #10 Certification Request Syntax Standard. This standard defines, in effect, a standard electronic form by which you can request a certificate from some appropriate certificate-issuing agency. </li>
</ul>
<h3><a name="iesignx509certif"></a>X.509 Certificates</h3>
<p>
In order to provide context for what follows, a brief review of the contents of an X.509 certificate is presented. Note, though, that the X.509 certificate is only described to a degree sufficient for the understanding of this document; for detailed X.509 information, consult the ITU-T recommendation X.509 (also, ISO/IEC 9594-8). Be advised that IE3 Sig does not support the <b>issuerUniqueIdentifier</b> or <b>subjectUniqueIdentifier</b> fields.</p>
<p>
The top-level ASN.1 for a certificate can be written as:</p>
<pre><code>CertificateInfo ::= SEQUENCE {
 &nbsp; version&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [0] Version DEFAULT v1,
 &nbsp; serialNumber&nbsp;&nbsp;&nbsp;&nbsp; INTEGER,
 &nbsp; signature&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AlgorithmIdentifier,
 &nbsp; issuer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Name,
 &nbsp; validity&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Validity,
 &nbsp; subject&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Name,
 &nbsp; subjectPublicKeyInfo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SubjectPublicKeyInfo,
 &nbsp; issuerUniqueIdentifier&nbsp;&nbsp;&nbsp; [1]&nbsp; IMPLICIT UniqueIdentifier OPTIONAL,-- If
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; present, version must be v2 or v3.
 &nbsp; SubjectUniqueIdentifier&nbsp; [2]&nbsp; IMPLICIT UniqueIdentifier OPTIONAL,-- If
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; present, version must be v2 or v3.
 &nbsp; Extensions&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [3]&nbsp; EXPLICIT Extensions OPTIONAL&nbsp; -- If 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; present, version must be v3.
 &nbsp; }
Validity ::= SEQUENCE {
 &nbsp; notBefore&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UTCTIME,
 &nbsp; notAfter&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UTCTIME
 &nbsp; }
Certificate ::= SEQUENCE {
 &nbsp; signedData&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CertificateInfo,&nbsp;&nbsp; -- The certificate 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; information.
 &nbsp; AlgorithmIdentifier&nbsp; AlgorithmIdentifier,&nbsp;&nbsp; -- The hash and&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; encryption 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; algorithms used.
 &nbsp; EncryptedHash&nbsp;&nbsp;&nbsp; BIT STRING&nbsp;&nbsp; -- The encrypted hash of 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the certificate
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; information.
 &nbsp;&nbsp;&nbsp;&nbsp; }
</code></pre>
<p>
This defines a sequence (in C it would be called a struct) <b>CertificateInfo</b> that contains some number of members: the name of the entity that issued this certificate, which, together with the issuer-assigned serial number uniquely identifies this certificate; the name of the subject of the certificate, the subject's public key information, the validity period for this certificate, and so on. A <b>Certificate</b> is then simply a <b>CertificateInfo</b> together with an encrypted hash along with an identification of the particular algorithms used. </p>
<p>
There is a <b>Name </b>data type used for the subject and issuer names. This isn't an ordinary, simple data type, like a string. Rather, it's a complicated data construct defined by X500.2. Also, notice the extensions field in the <b>CertificateInfo</b>. The <b>Extensions</b> data type can be written as:</p>
<pre><code>Extensions ::= SEQUENCE OF Extension
Extension ::= SEQUENCE {
 &nbsp; extnId&nbsp;&nbsp;&nbsp;&nbsp; OBJECT IDENTIFIER,&nbsp;&nbsp; -- identifies semantic of 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; particular extension.
 &nbsp; Critical&nbsp;&nbsp; BOOLEAN DEFAULT FALSE, -- if true, then if you&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; don't understand this 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; semantic of extension,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw out the 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; certificate.
 &nbsp; ExtnValue&nbsp; OCTET STRING&nbsp;&nbsp;&nbsp; -- The (arbitrary) data of 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the extension.
}
</code></pre>
<p>
Inside the <b>CertificateInfo</b> of a Certificate there can be an arbitrary list of any number of extensions (including zero), each of which is completely arbitrary in format. An OBJECT IDENTIFIER is the method used by OSI to identify the semantic of a particular extension and is globally unique. </p>
<p>
Anyone can make up a new certificate extension (and most people, it seems, do), therefore any interface or application programming interface (API) for manipulating certificates must allow for this in a reasonable way. That being said, there are a certain number of more or less standard and common extensions that might as well be considered part of the core content of a certificate.</p>
<h3><a name="iesignx500name"></a>X.500 Names</h3>
<p>
The following code is the ASN.1 representation of a <b>Name</b>:</p>
<pre><code>Name ::= CHOICE { 
 rdnSequence RDNSequence&nbsp;&nbsp; -- Only one possibility for now.
 }
RDNSequence&nbsp;&nbsp; ::= SEQUENCE OF RelativeDistinguishedName
RelativeDistinguishedName ::= SET OF AttributeTypeAndValue
AttributeTypeAndValue&nbsp; ::= SEQUENCE {
 type&nbsp; ATTRIBUTE.&amp;ID,&nbsp; -- ie: an OBJECT IDENTIFIER.
 value ATTRIBUTE.&amp;Type&nbsp; -- ie: data in arbitrary format per the 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; object identifier.
 }
</code></pre>
<p>
C programmers can think of this as an "array of sets of tagged arbitrary blobs." </p>
<p>
In practice, things are not quite this bad:
<ul type=disc>
<li>
The sets are almost always of size one. So there is an "array of tagged arbitrary blobs." <br><br></li>
<li>
Most of the time, the arbitrary blob is an instance of the structure <b>DirectoryString:</b> <pre><code>DirectoryString ::= CHOICE {
 &nbsp; teletexString&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TeletexString,
 &nbsp; printableString&nbsp;&nbsp;&nbsp;&nbsp; PrintableString,
 &nbsp; universalString&nbsp;&nbsp;&nbsp;&nbsp; UniversalString 
 &nbsp; }
</code></pre>
</li>
</ul>
<p>
<b>UniversalString</b> is IS0646, the 4-byte generalization of Unicode; <b>PrintableString</b> is a subset of ASCII made up of letters, numbers, and limited punctuation; <b>TeletexString</b> is a monstrosity that is best ignored. <b>DirectoryString</b> isn't my favorite data type, but at least it allows for generality while still being compact in the common cases. 
<ul type=disc>
<li>
While the arbitrary blob in a relative distinguished name (RDN) is usually an instance of <b>DirectoryString</b>, the object ID, which is the type, can vary widely. There are many handy types defined, including:<pre><code>id-at-commonName&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OBJECT IDENTIFIER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::=&nbsp; {id-at 3} 
id-at-surname&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OBJECT IDENTIFIER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::=&nbsp; {id-at 4}
id-at-serialNumber&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OBJECT IDENTIFIER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::=&nbsp; {id-at 5}
id-at-countryName&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OBJECT IDENTIFIER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::=&nbsp; {id-at 6}
id-at-localityName&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OBJECT IDENTIFIER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::=&nbsp; {id-at 7}
id-at-collectiveLocalityName&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OBJECT IDENTIFIER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::=&nbsp; {id-at 7 1}
id-at-stateOrProvinceName&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OBJECT IDENTIFIER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::=&nbsp; {id-at 8}
id-at-collectiveStateOrProvinceName&nbsp;&nbsp;&nbsp; OBJECT IDENTIFIER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::=&nbsp; {id-at 8 1}
id-at-streetAddress&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OBJECT IDENTIFIER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::=&nbsp; {id-at 9}
id-at-collectiveStreetAddress&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OBJECT IDENTIFIER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::=&nbsp; {id-at 9 1}
id-at-organizationName&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OBJECT IDENTIFIER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::=&nbsp; {id-at 10}
id-at-collectiveOrganizationName&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OBJECT IDENTIFIER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::=&nbsp; {id-at 10 1}
id-at-organizationalUnitName&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OBJECT IDENTIFIER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::=&nbsp; {id-at 11}
id-at-collectiveOrganizationalUnitName OBJECT IDENTIFIER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::=&nbsp; {id-at 11 1}
id-at-title&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OBJECT IDENTIFIER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::=&nbsp; {id-at 12}
id-at-description&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OBJECT IDENTIFIER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::=&nbsp; {id-at 13}
id-at-searchGuide&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OBJECT IDENTIFIER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::=&nbsp; {id-at 14}
id-at-businessCategory&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OBJECT IDENTIFIER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::=&nbsp; {id-at 15}
id-at-postalAddress&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OBJECT IDENTIFIER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::=&nbsp; {id-at 16}
id-at-collectivePostalAddress&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OBJECT IDENTIFIER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::=&nbsp; {id-at 16 1}
id-at-postalCode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OBJECT IDENTIFIER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::=&nbsp; {id-at 17}
id-at-collectivePostalCode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OBJECT IDENTIFIER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::=&nbsp; {id-at 17 1}
id-at-postOfficeBox&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OBJECT IDENTIFIER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::=&nbsp; {id-at 18}
id-at-collectivePostOfficeBox&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OBJECT IDENTIFIER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::=&nbsp; {id-at 18 1}
id-at-physicalDeliveryOfficeName&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OBJECT IDENTIFIER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::=&nbsp; {id-at 19}
</code></pre>
</li>
</ul>
<p>
Some of these even have standard abbreviations, such as CN for "id-at-<i>commonName</i>," and OU for "id-at-<i>organizationalUnitName</i>."<i> </i>
<ul type=disc>
<li>
In the case where all the sets are of size one, all the blobs are <b>DirectoryStrings</b>,<b> </b>and all the object IDs have an abbreviation, X.400 defines a standard string representation for the name as a whole. It's not worth going into the details here, but an example is:<pre><code>C=US; OU=Microsoft; CN=Paul Borm;
</code></pre>
</li>
</ul>
<p>
Regrettably, while there is a limited standard for a string representation of an X.500 name, there is absolutely no standard, either de jure or de facto, for the semantics and meaning of each of the elements in the RDN Sequence. Some name-creating bodies, for example, use the "id-at-<i>organizationName</i>" where others use "id-at-<i>organizationalUnitName;</i>" some names use more than one organizational unit name, where others do not; and so on.</p>
<h3><a name="iesignpkcs7"></a>PKCS #7 Signed Data Signature Blocks</h3>
<p>
PKCS #7 defines the <b>SignedData</b> structure for the purpose of being able to affix one or more signatures to a chunk of data. The ASN.1 for a <b>SignedData</b> structure is specified by PKCS #7 as follows:</p>
<pre><code>SignedData ::= SEQUENCE {
 &nbsp; version&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Version,
 &nbsp; digestAlgorithms DigestAlgorithmIdentifiers,
 &nbsp; contentInfo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ContentInfo,
 &nbsp; certificates&nbsp;&nbsp;&nbsp;&nbsp; [0] IMPLICIT ExtendedCertificatesAndCertificates OPTIONAL,
 &nbsp; crls&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [1] IMPLICIT CertificateRevocationLists OPTIONAL,
 &nbsp; signerInfos&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SignerInfos 
 &nbsp; }
DigestAlgorithmIdentifiers ::= SET OF DigestAlgorithmIdentifier
SignerInfos ::= SET OF SignerInfo
</code></pre>
<p>
The following are relevant things to note:
<ul type=disc>
<li>
The <b>contentInfo</b> field contains the content data to be signed. In PKCS #7 as originally designed, this was physically the actual data. Now, the <b>contentInfo</b> field contains an indirect reference to the actual data. The <b>contentInfo</b> field will be discussed later in this article.<br><br></li>
<li>
The <b>signerInfos </b>(there can be more than one) contain the signature(s) on that data. <br><br></li>
<li>
As discussed in PKCS #7, it is intended that the set of certificates in the <b>ExtendedCertificatesAndCertificates</b> be sufficient to contain chains of certificates from a recognized "root" or "top-level certification authority" to all of the signers in the <b>signerInfos</b> field, though this is not required: there may be fewer or more certificates than are necessary. Put another way, this field is a means to convey several certificates that may be useful when attempting to process the various <b>signerInfos. </b></li>
</ul>
<p>
<b>SignerInfo</b> is defined as follows:</p>
<pre><code>SignerInfo ::= SEQUENCE {
 &nbsp; version&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Version,
 &nbsp; issuerAndSerialNumber&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IssuerAndSerialNumber,
 &nbsp; digestAlgorithm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DigestAlgorithmIdentifier,
 &nbsp; authenticatedAttributes&nbsp;&nbsp;&nbsp; [0] IMPLICIT Attributes OPTIONAL,
 &nbsp; digestEncryptionAlgorithm&nbsp; DigestEncryptionAlgorithmIdentifier,
 &nbsp; encryptedDigest&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EncryptedDigest,
 &nbsp; unauthenticatedAttributes&nbsp; [1] IMPLICIT Attributes OPTIONAL 
 &nbsp; }
IssuerAndSerialNumber&nbsp; := SEQUENCE {
 &nbsp; issuer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Name,
 &nbsp; serialNumber&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CertificateSerialNumber
 &nbsp; }
EncryptedDigest&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::= OCTET STRING
Attributes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::= SET OF Attribute
Attribute&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::= SEQUENCE { 
 &nbsp; type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ATTRIBUTE.&amp;id,&nbsp; -- Another OBJECT IDENTIFIER
 &nbsp; values&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SET OF ATTRIBUTE.&amp;Type&nbsp; -- Yet another blob per 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the object identifier.
 &nbsp; }
</code></pre>
<p>
Of note, a <b>SignerInfo</b> has:
<ul type=disc>
<li>
A signature, in the <b>encryptedDigest</b>, along with the identification of the hash algorithm used (<b>digestAlgorithm</b>) and the algorithm used to encrypt the hash. <br><br></li>
<li>
A number of arbitrary authenticated attributes that get included in the hashing process and, therefore, are signed along with the content. An attribute is very much like an extension in a certificate, except it lacks the "critical" field and was invented by a different standards body. <br><br></li>
<li>
A second group of attributes, the unauthenticated attributes, that aren't included in the signing process. <br><br></li>
<li>
An identification, including issuer and serial number, of the certificate used in the process of making the signature. You need to find this certificate in order to dig out the public key you need to decrypt the hash (notice that the public key isn't in the <b>SignerInfo</b>), so this is important. </li>
</ul>
<p>
<b>ContentInfo</b> is defined by PCKS#7 as follows:</p>
<pre><code>&nbsp;&nbsp;&nbsp;CONTENTINFO ::= CLASS {
 &nbsp;&nbsp;&nbsp;&nbsp; &amp;Type,
 &nbsp;&nbsp;&nbsp;&nbsp; &amp;id&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OBJECT IDENTIFIER UNIQUE 
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp; WITH SYNTAX {
 &nbsp;&nbsp;&nbsp;&nbsp; WITH SYNTAX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;Type
 &nbsp;&nbsp;&nbsp;&nbsp; ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;id 
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp; ContentInfo ::= SEQUENCE {
 &nbsp;&nbsp;&nbsp;&nbsp; contentType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CONTENTINFO.&amp;id,
 &nbsp;&nbsp;&nbsp;&nbsp; content&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [0] EXPLICIT CONTENTINFO.&amp;Type OPTIONAL
 &nbsp;&nbsp;&nbsp;&nbsp; }
</code></pre>
<p>
A <b>ContentInfo</b> is yet another set of data that is parameterized by an object identifier. If you know the object identifier, you know how to process the data. PKCS #7 defines several <b>ContentInfo</b> data types, including:</p>
<pre><code>data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OBJECT IDENTIFIER ::= { pkcs-7 1 }
signedData&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OBJECT IDENTIFIER ::= { pkcs-7 2 }
envelopedData&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OBJECT IDENTIFIER ::= { pkcs-7 3 }
signedAndEnvelopedData&nbsp;&nbsp;&nbsp; OBJECT IDENTIFIER ::= { pkcs-7 4 }
digestedData&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OBJECT IDENTIFIER ::= { pkcs-7 5 }
encryptedData&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OBJECT IDENTIFIER ::= { pkcs-7 6 }
</code></pre>
<p>
The <b>Data</b> field represents data, the definition of which lies outside of any ASN.1; its data format is OCTET STRING so far as ASN.1 is concerned. <b>SignedData</b> has data as discussed previously. The remaining types allow for various cryptographic operations that go beyond merely signing things to include such things as encryption. While very interesting indeed, they are beyond the scope of the present document and are not supported in IE3 Sig. </p>
<p>
As was noted previously, the design presented in PKCS #7 has the actual content contained physically inside <b>ContentInfo</b>. If you want to sign something, you have to, in effect, change its file format to be a <b>SignedData</b> or a <b>ContentInfo</b> that contains a <b>SignedData</b>. Since this is not practical in the real world, a means of referring, in <b>ContentInfo</b>, to an external data source has been defined. To accomplish this, a new <b>ContentInfo</b> type has been invented, called <b>IndirectDataContent</b>. <b>IndirectDataContent</b> contains:
<ol>
<li>
An indication of the kind of data to be hashed. This is an object identifier; thus, new kinds of indirect data can be independently invented.<br><br></li>
<li>
Optionally, an indication of the actual data to be hashed. This is specified in a syntax governed by the object identifier. Commonly this is a file name, a Uniform Resource Locator (URL), or other type of data, along with any additional parameters needed to indicate which specific subpart of the data is involved. If this indication is absent, then the actual data to be hashed is located implicitly in an object-identifier–specific means, such as the file in which the <b>IndirectDataContent</b> is physically located. For Java .class files, this indication is typically omitted, meaning that the indicated data is the containing .class file.<br><br></li>
<li>
A digest of the indicated data, along with an indication of the digest algorithm used. This digest/digest-algorithm pair is then itself digested and signed as part of the signing process of the <b>SignedData</b> per PKCS#7—thus, associating a digital signature with the indicated data. </li>
</ol>
<p>
The definition of <b>IndirectDataContent</b> and related structures is as follows:</p>
<pre><code>&nbsp;&nbsp;&nbsp;
indirectDataContent CONTENTINFO ::= {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WITH SYNTAX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IndirectDataContent
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; id-indirectdata
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp; IndirectDataContent ::= SEQUENCE {
 &nbsp;&nbsp;&nbsp;&nbsp; data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AttributeTypeAndOptionalValue,
 &nbsp;&nbsp;&nbsp;&nbsp; messageDigest&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DigestInfo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- DigestInfo is defined in PKCS #1
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp; AttributeTypeAndOptionalValue ::= SEQUENCE {
 &nbsp;&nbsp;&nbsp;&nbsp; type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ATTRIBUTE.&amp;id,
 &nbsp;&nbsp;&nbsp;&nbsp; value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ATTRIBUTE.&amp;Type({...}{@type}) OPTIONAL
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp; id-indirectdata OBJECT IDENTIFIER ::= (value to be supplied)
</code></pre>
<p>
Remember that in practice this is contained inside a <b>ContentInfo</b>, which is contained inside a <b>SignedData</b>, which may in turn be contained inside another <b>ContentInfo.</b> An example of an <b>IndirectDataContent</b> that has been defined is:</p>
<pre><code>rawFileSourceType ATTRIBUTE&nbsp;&nbsp; ::=&nbsp;&nbsp; {
 &nbsp; WITH SYNTAX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RawFileData
 &nbsp; ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; id-indirectdata-rawFile
 &nbsp;&nbsp;&nbsp;&nbsp; }
RawFileData ::= Link
</code></pre>
<p>
A Link just names an external reference; it is a generalization of an URL and moniker. For completeness, its definition is as follows:</p>
<pre><code>Link ::= CHOICE {
 &nbsp; url&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [0] IMPLICIT UniformResourceLocator,
 &nbsp; moniker&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [1] IMPLICIT SerializedMoniker,
 &nbsp; file&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [2] IMPLICIT FileName
 &nbsp; } 
UniformResourceLocator ::= IA5String
FileName&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::= DcmiString
SerializedMoniker&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::= SerializedObject
SerializedObject&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::= SEQUENCE {
 &nbsp; classid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Uuid,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp; serializedData&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OCTET STRING -- format determined by classid
 &nbsp; }
Uuid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::= OCTET STRING (SIZE(16..16))&nbsp;&nbsp; -- an OSF UUID
DcmiString ::= CHOICE {
 &nbsp; unicode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [0] IMPLICIT BMPString,
 &nbsp; ascii&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [1] IMPLICIT IA5String
 &nbsp; }
</code></pre>
<p>
Put that altogether and you understand the data formats needed to affix a signature to a raw flat file. </p>
<h3><a name="iesignpkcs10"></a>PKCS #10 Certification Request</h3>
<p>
When an end entity (user) needs to get a certificate from a Certification Authority (CA), a request must be constructed following a carefully defined structure and format. Then this request is transmitted to the CA. </p>
<p>
A certification request consists of a distinguished name, a public key, and an optional set of attributes, collectively signed by the entity (user) requesting certification. Certification requests are sent to a CA, who usually transforms the request to an X.509 public-key certificate (or possibly a PKCS #6 extended certificate. In what form the CA returns the newly signed certificate is outside the scope of this document.) </p>
<p>
The intention of including a set of attributes is twofold: to provide other information about a given entity, such as the postal address to which the signed certificate should be returned if electronic mail is not available, or a "challenge password" by which the entity may later request certificate revocation; and to provide attributes for a PKCS #6 extended certificate. A nonexhaustive list of attributes is given in PKCS #9. </p>
<p>
The primary intended application of this standard is to support PKCS #7 cryptographic messages. </p>
<p>
A certification request consists of three parts: certification request information, a signature algorithm identifier, and a digital signature on the certification request information. The certification request information consists of the entity's distinguished name, the entity's public key, and a set of attributes providing other information about the entity. </p>
<p>
The process by which a certification request is constructed involves the following steps:
<ol>
<li>
A <b>CertificationRequestInfo</b> value containing a distinguished name, a public key, and an optional set of attributes is constructed by an entity.<br><br></li>
<li>
The <b>CertificationRequestInfo</b> value is signed with the entity's private key.<br><br></li>
<li>
The <b>CertificationRequestInfo</b> value, a signature algorithm identifier, and the entity's signature are collected together into a <b>CertificationRequest</b> value, defined below. </li>
</ol>
<p>
A certification authority fulfills the request by verifying the entity's signature, and, if it is valid, constructing an X.509 certificate from the distinguished name and public key, issuer name, serial number, validity period, and signature algorithm of the CA's choice. If the certification request contains a PKCS #9 extended-certificate–attributes attribute, the CA also constructs a PKCS #6 extended certificate from the X.509 certificate and the extended-certificate–attributes attribute value.</p>
<p>
Certification request information shall have ASN.1 type <b>CertificationRequestInfo:</b></p>
<pre><code>CertificationRequestInfo ::= SEQUENCE {
  version&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Version,
  subject&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Name,
  subjectPublicKeyInfo&nbsp;&nbsp;&nbsp; SubjectPublicKeyInfo,
  attributes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [0] IMPLICIT Attributes }
Version ::= INTEGER
Attributes ::= SET OF Attribute
</code></pre>
<p>
<b>CertificationRequestInfo</b> fields have the following meanings:
<ul type=disc>
<li>
<i>Version</i> is the version number, for compatibility with future revisions of this standard. <br><br></li>
<li>
<i>Subject</i> is the distinguished name of the certificate subject (the entity whose public key is to be certified). <br><br></li>
<li>
<b>subjectPublicKeyInfo</b> contains information about the public key being certified. The information identifies the entity's public-key algorithm (and any associated parameters). Examples of public-key algorithms include X.509's RSA and PKCS #1's <i>rsaEncryption</i>. The information also includes a bit-string representation of the entity's public key. For both of these public-key algorithms, the bit string contains the BER encoding of a value of X.509/PKCS #1 type <i>RSAPublicKey</i>. <br><br></li>
<li>
<i>Attributes</i> is a set of attributes providing additional information about the subject of the certificate. Some attribute types that might be useful here are defined in PKCS #9. An example is the extended-certificate–attributes attribute, which specifies attributes for a PKCS #6 extended certificate. </li>
</ul>
<p>
A certification request shall have ASN.1 type <b>CertificationRequest</b>:</p>
<pre><code>CertificationRequest ::= SEQUENCE {
  certificationRequestInfo&nbsp; CertificationRequestInfo,
  signatureAlgorithm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SignatureAlgorithmIdentifier,
  signature Signature }
SignatureAlgorithmIdentifier ::= AlgorithmIdentifier
Signature ::= BIT STRING
</code></pre>
<p>
The <b>CertificationRequest</b> fields have the following meanings:
<ul type=disc>
<li>
<b>certificateRequestInfo</b> is the certification-request information. It is the value being signed. <br><br></li>
<li>
<b>signatureAlgorithm</b> identifies the signature algorithm (and any associated parameters) under which the certification-request information is signed. Examples include the PKCS #1 <i>md2WithRSAEncryption</i> and <i>md5WithRSAEncryption. </i><br><br></li>
<li>
<i>Signature</i> is the result of signing the certification request information with the certification-request subject's private key. </li>
</ul>
<p>
The signature process consists of two steps:
<ol>
<li>
The value of the <b>certificationRequestInfo</b> field is DER encoded, yielding an octet string.<br><br></li>
<li>
The result of step 1 is signed with the certification-request subject's private key under the specified signature algorithm, yielding a bit string—the signature. </li>
</ol>
<h2><a name="iesigncominterface"></a>The COM Interface Suite</h2>
<p>
The previous section gave you an introduction to data integrity through digital signatures and authentication through the use of certificates. It also introduced you to a number of standards that are used in secure communications.</p>
<p>
This section will show you how those concepts and standards are implemented in the Microsoft Internet Explorer 3.0 Signature and Certificate Interface.</p>
<h3><a name="iesigncompclass"></a>Component Classes</h3>
<p>
These are a suite of COM objects that expose interrelated interfaces through which data can be manipulated and actions can be taken. These objects can be grouped into four categories—certificates, certificate store, certificate requests, and signature blocks.</p>
<h4><a name="iesigncertificates"></a>Certificates</h4>
<p>
The objects in this class have interfaces that can manipulate the data contained in an X.509 certificate. The objects and the interfaces they expose follow.</p>
<p>
<b>X509</b></p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interface IUnknown;
 &nbsp;&nbsp;&nbsp;&nbsp; interface IPersistFile;
 &nbsp;&nbsp;&nbsp;&nbsp; interface IPersistStream;
 &nbsp;&nbsp;&nbsp;&nbsp; interface IPersistMemBlob;
 &nbsp;&nbsp;&nbsp;&nbsp; interface IX509;
 &nbsp;&nbsp;&nbsp;&nbsp; interface IAmHashed;
 &nbsp;&nbsp;&nbsp;&nbsp; interface IAmSigned;
 &nbsp;&nbsp;&nbsp;&nbsp; interface ISelectedAttributes;
 &nbsp;&nbsp;&nbsp;&nbsp; interface IPublicKeyContainer;
 &nbsp;&nbsp;&nbsp;&nbsp; interface IPublicKeyPair;
</code></pre>
<p>
<b>X500_Name</b></p>
<p>
An X500_Name is a sequence of X500_RelativeDistinguishedNames.</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interface IUnknown;
 &nbsp;&nbsp;&nbsp;&nbsp; interface IPersistFile;
 &nbsp;&nbsp;&nbsp;&nbsp; interface IPersistStream;
 &nbsp;&nbsp;&nbsp;&nbsp; interface IPersistMemBlob;
 &nbsp;&nbsp;&nbsp;&nbsp; interface IX500Name;
</code></pre>
<p>
<b>X500_RelativeDistinguishedName</b></p>
<pre><code>interface IUnknown;
 &nbsp;&nbsp;&nbsp;&nbsp; interface ISelectedAttributes;
</code></pre>
<p>
<b>Certificate objects relationships</b></p>
<p>
Figure 2 shows the relationships between some of the certificate objects.</p>
<p>
<img src="iesignwp_2.gif" border=0></p>
<p class=label>
<b>Figure 2. Certificate object interface relationships</b></p>
<h4><a name="iesigncertstore"></a>Certificate Store</h4>
<p>
These objects deal with persistently storing and retrieving X.509 certificates.</p>
<p>
<b>CertificateStore</b></p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interface IUnknown;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interface ICertificateStore;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interface ICertificateStoreRegInit;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interface ICertificateStoreAux;
 &nbsp;&nbsp;&nbsp;&nbsp; interface ICertificateList;
</code></pre>
<p>
<b>Certificate store object interfaces</b></p>
<p>
Figure 3 shows the most important interfaces for the <b>CertificateStore</b> object.</p>
<p>
<img src="iesignwp_3.gif" border=0></p>
<p class=label>
<b>Figure 3. CertificateStore object interfaces</b></p>
<h4><a name="iesigncertrequest"></a>Certificate Requests</h4>
<p>
These objects are used to request a certificate from a CA.</p>
<p>
<b>Pkcs10</b></p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interface IUnknown;
 &nbsp;&nbsp;&nbsp;&nbsp; interface IPersistFile;
 &nbsp;&nbsp;&nbsp;&nbsp; interface IPersistStream;
 &nbsp;&nbsp;&nbsp;&nbsp; interface IPersistMemBlob;
 &nbsp;&nbsp;&nbsp;&nbsp; interface IPkcs10;
 &nbsp;&nbsp;&nbsp;&nbsp; interface ISelectedAttributes;
 &nbsp;&nbsp;&nbsp;&nbsp; interface IAmHashed;
 &nbsp;&nbsp;&nbsp;&nbsp; interface IAmSigned;
 &nbsp;&nbsp;&nbsp;&nbsp; interface IPublicKeyContainer;
 &nbsp;&nbsp;&nbsp;&nbsp; interface IPublicKeyPair;
</code></pre>
<p>
<b>Pkcs10Subject</b></p>
<p>
The same as X500_Name.</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interface IUnknown;
 &nbsp;&nbsp;&nbsp;&nbsp; interface IPersistFile;
 &nbsp;&nbsp;&nbsp;&nbsp; interface IPersistStream;
 &nbsp;&nbsp;&nbsp;&nbsp; interface IPersistMemBlob;
 &nbsp;&nbsp;&nbsp;&nbsp; interface IX500Name;
</code></pre>
<p>
plus:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interface ISelectedAttributes;&nbsp;&nbsp; 
</code></pre>
<p>
<b>Certificate request objects relationships</b></p>
<p>
Figure 4 shows the relationships between some of the certificate request objects.</p>
<p>
<img src="iesignwp_4.gif" border=0></p>
<p class=label>
<b>Figure 4. Request for certificate interface relationships</b></p>
<h4><a name="iesignsigblock"></a>Signature Blocks</h4>
<p>
These objects provide the capability to sign data and verify signatures.</p>
<p>
<b>Pkcs7SignedData</b></p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interface IUnknown;
 &nbsp;&nbsp;&nbsp;&nbsp; interface IPersistFile;
 &nbsp;&nbsp;&nbsp;&nbsp; interface IPersistStream;
 &nbsp;&nbsp;&nbsp;&nbsp; interface IPersistStorage;
 &nbsp;&nbsp;&nbsp;&nbsp; interface IPersistMemBlob;
 &nbsp;&nbsp;&nbsp;&nbsp; interface IPkcs7SignedData;
 &nbsp;&nbsp;&nbsp;&nbsp; interface IAmHashed;
 &nbsp;&nbsp;&nbsp;&nbsp; interface ICertificateList;
 &nbsp;&nbsp;&nbsp;&nbsp; interface ICertificateStore;
</code></pre>
<p>
<b>SignerInfo</b></p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interface IUnknown;
 &nbsp;&nbsp;&nbsp;&nbsp; interface IPersistMemBlob;
 &nbsp;&nbsp;&nbsp;&nbsp; interface ISignerInfo;
 &nbsp;&nbsp;&nbsp;&nbsp; interface IAmHashed;
 &nbsp;&nbsp;&nbsp;&nbsp; interface IAmSigned;
</code></pre>
<p>
<b>Pkcs7 Signed data objects relationships</b></p>
<p>
Figure 5 shows the relationships between some of the <b>Pkcs7SignedData</b> objects.</p>
<p>
<img src="iesignwp_5.gif" border=0></p>
<p class=label>
<b>Figure 5. Pkcs7SignedData object relationships </b></p>
<h3><a name="iesignimpint"></a>Important Interfaces</h3>
<p>
The following interfaces are the most used and, therefore, the most important interfaces. They are presented in alphabetical order.</p>
<h4><a name="iesigniamhashed"></a>IAmHashed</h4>
<p>
This interface is used for hashing things that are hashable.</p>
<pre><code>interface IAmHashed : IUnknown {
 &nbsp; HRESULT&nbsp;&nbsp;&nbsp; Hash(
 &nbsp;&nbsp;&nbsp;&nbsp; [in] HCRYPTHASH&nbsp; hash&nbsp; // The hash key to use on the data.
 &nbsp;&nbsp;&nbsp;&nbsp; );&nbsp; 
 &nbsp; }
</code></pre>
<h4><a name="iesigniamsigned"></a>IAmSigned </h4>
<p>
This interface is used for signing things that are signable.</p>
<pre><code>interface IAmSigned : IAmHashed {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Note the interface inheritance.
 &nbsp; 
 &nbsp;&nbsp;&nbsp; // Sign the information herein.
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp; Sign(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp; HCRYPTPROV&nbsp;&nbsp; hprov,&nbsp;&nbsp;&nbsp;&nbsp; // Crypto provider to use
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp; DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwKeySpec,&nbsp;&nbsp; // Key spec of provider to use. Usually 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // AT_SIGNATURE.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp; ALG_ID&nbsp;&nbsp;&nbsp; algidHash&nbsp;&nbsp;&nbsp;&nbsp; // Hash algorithm to use (encryption 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // alg implied&nbsp; by key).
 &nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp;&nbsp; // Verify that the information herein is signed with the private key that
 &nbsp;&nbsp;&nbsp; // corresponds to the provided public key.
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp; Verify(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp; HCRYPTPROV&nbsp;&nbsp; hprov,&nbsp;&nbsp;&nbsp;&nbsp; // Crypto provider used for services.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp; HCRYPTKEY&nbsp;&nbsp;&nbsp; hkeypub&nbsp;&nbsp;&nbsp; // The public key to test with.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ); 
 &nbsp;&nbsp;&nbsp; // Return values:
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // S_OK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yes, it was signed with this key.
 &nbsp;&nbsp;&nbsp; // NTE_BAD_SIGNATURE&nbsp;&nbsp; No, it was not signed with this key.
 &nbsp;&nbsp;&nbsp; //Other error code:&nbsp;&nbsp;&nbsp; An error in processing prevented the determination
 &nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; from being made.
 &nbsp;&nbsp;&nbsp; //
}
</code></pre>
<h4><a name="iesignicertificatelist"></a>ICertificateList </h4>
<p>
This interface provides a simple way to manipulate an ordered list of certificates.</p>
<pre><code>interface ICertificateList : IUnknown {
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // Return the number of certificates that the list presently contains.
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp; get_CertificateCount(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [out,retval] LONG*&nbsp; pccert
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp; 
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // Return access to the n'th certificate.
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp; get_Certificate(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; icert,&nbsp;&nbsp; // Zero-origin index of
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // certificate sought
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REFIID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iid,&nbsp;&nbsp;&nbsp;&nbsp; // Typically IX509
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [out, iid_is(iid),retval] void**&nbsp; ppv
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // Create a new certificate at the end of the list and return access to it.
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp; create_Certificate(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; icertBefore,&nbsp; // Create before this; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // -1 means end
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REFIID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iid,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Typically IX509
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [out, iid_is(iid),retval] void**&nbsp; ppv
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // Delete an existing certificate. The indices of the
 &nbsp;&nbsp;&nbsp; // signer infos above this shift down by one.
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // If the certificate is presently open, this method fails.
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; remove_Certificate(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LONG&nbsp;&nbsp;&nbsp; icert&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Zero-origin index of certificate to
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // remove.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // Copy the list, preserving the order.
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; CopyTo(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ICertificateList* plistTo
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp;&nbsp; }
</code></pre>
<h4><a name="iesignicertificatestore"></a>ICertificateStore </h4>
<p>
This interface is the central interface to a body of code that can store numerous certificates. It provides basic querying functionality, as well as import/export capability.</p>
<pre><code>interface ICertificateStore : IUnknown {
 &nbsp;&nbsp;&nbsp; // 
 &nbsp;&nbsp;&nbsp; // Put a new X.509 certificate into the store, given the bits of the 
 &nbsp;&nbsp;&nbsp; // certificate.
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; ImportCertificate(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in] BLOB*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pData,&nbsp;&nbsp;&nbsp;&nbsp; // DER encoding of the certificate.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in] LPCOLESTR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wszID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // A unique string to tag this cert with
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // may be NULL.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // Retrieve an X.509 certificate from the store. Return STG_E_FILENOTFOUND 
 &nbsp;&nbsp;&nbsp; // if the certificate cannot be located.
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; ExportCertificate(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp; CERTIFICATENAMES*&nbsp; pnames,&nbsp;&nbsp; // The name(s) of the certificate to
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // retrieve.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [out] LPOLESTR*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pwszId,&nbsp;&nbsp; // The tag of this cert, if any. 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // pwszId may be NULL.
 &nbsp;&nbsp;&nbsp;&nbsp; [out,retval] BLOB*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pData&nbsp;&nbsp;&nbsp;&nbsp; // Data returned in DER encoding.
 &nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // Get read-only access to a certificate with a particular name. That is, 
 &nbsp;&nbsp;&nbsp; // changes made to the returned certificate will NOT be reflected back into 
 &nbsp;&nbsp;&nbsp; // the store. Returns STG_E_FILENOTFOUND if the certificate cannot be 
 &nbsp;&nbsp;&nbsp; // located.
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; get_ReadOnlyCertificate(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CERTIFICATENAMES* pnames,&nbsp; // The name(s) of the 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // certificate to retrieve.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [out]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPOLESTR*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pwszId,&nbsp; // The tag of this cert, if 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // any. pwszId may be NULL.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REFIID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iid,&nbsp;&nbsp;&nbsp;&nbsp; // Typically IX509.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [out, iid_is(iid),retval] void**&nbsp; ppv
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // Copy all the certificates in this store into the indicated destination 
 &nbsp;&nbsp;&nbsp; // store.
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; CopyTo(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in] ICertificateStore*&nbsp;&nbsp;&nbsp; pStoreDest
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp;&nbsp; }
</code></pre>
<h4><a name="iesignicertificatestoreaux"></a>ICertificateStoreAux </h4>
<p>
This is an interface that allows auxiliary information to be maintained by the store. The store associates the information with a given certificate by means of the string "tags."</p>
<pre><code>interface ICertificateStoreAux : IUnknown {
//
 &nbsp;&nbsp; // Set the information associated with a given tag.
 &nbsp;&nbsp; //
 &nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; put_AuxInfo(
 &nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp; LPCOLESTR&nbsp;&nbsp;&nbsp; wszTag,
 &nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp; CERTSTOREAUXINFO* pinfo
 &nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp; //
 &nbsp;&nbsp; // Retreieve the information associated with a given tag.
 &nbsp;&nbsp; //
 &nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; get_AuxInfo(
 &nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp; LPCOLESTR&nbsp;&nbsp; wszTag,
 &nbsp;&nbsp;&nbsp;&nbsp; [out] CERTSTOREAUXINFO* pinfo
 &nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp; //
 &nbsp;&nbsp; // Helper utility to free an information structure.
 &nbsp;&nbsp; //
 &nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; FreeAuxInfo(
 &nbsp;&nbsp;&nbsp;&nbsp; [in,out] CERTSTOREAUXINFO* pinfo
 &nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp; //
 &nbsp;&nbsp; // Return the number of tags.
 &nbsp;&nbsp; //
 &nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; TagCount(
 &nbsp;&nbsp;&nbsp;&nbsp; [out] LONG* pctag
 &nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp; //
 &nbsp;&nbsp; // Return the ith tag.
 &nbsp;&nbsp; //
HRESULT&nbsp;&nbsp;&nbsp; get_Tag(
 &nbsp; [in]&nbsp; LONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; itag,
 &nbsp; [out] LPOLESTR*&nbsp;&nbsp;&nbsp;&nbsp; pwszTag
 &nbsp; );
}
</code></pre>
<h4><a name="iesignicertificatestorereginit"></a>ICertificateStoreRegInit </h4>
<p>
This is an interface on the system certificate-store implementation that provides the capability to retarget which part of the registry to use.</p>
<pre><code>interface ICertificateStoreRegInit : IUnknown {
  //
  // Tell the implementation which part of the registry to use.
  // 
  HRESULT&nbsp;&nbsp;&nbsp; SetRoot(
 &nbsp;&nbsp; [in] HKEY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hkey,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // eg: HKEY_LOCAL_MACHINE
 &nbsp;&nbsp; [in] LPCOLESTR&nbsp;&nbsp;&nbsp; wszRoot&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Root key name to use under that key.
 &nbsp;&nbsp; );
}
</code></pre>
<h4><a name="iesignipkcs7signeddata"></a>IPkcs7SignedData </h4>
<p>
This interface is used for manipulating a PKCS #7 cryptographic message, which is an instance of the <b>SignedData</b> type defined in the PKCS #7 standard.</p>
<p>
<b>IPkcs7SignedData</b> provides access to the content, the signer information, and the certificate list inside the message; for simplicity (since usage is expected to be rare) it does not provide access to the certificate-revocation lists (said access could be provided later in a new, auxiliary interface).</p>
<p>
Instances of this interface always support <b>ICertificateList</b>.<b> ICertificateStore</b> is usually supported (in the implementation returned by <b>CreatePkcs7SignedData</b>, it always is).</p>
<p>
They also support <b>IPersistStorage</b>, which saves the storage in a spot that doesn't interfere with hashing.</p>
<pre><code>interface IPkcs7SignedData : IUnknown {
 &nbsp; //////////////////////////////////////////////////////////////////////
 &nbsp; //
 &nbsp; //&nbsp;&nbsp; Generic ContentInfo Management
 &nbsp; //
 &nbsp; //////////////////////////////////////////////////////////////////////
 &nbsp; // Retrieve the content information and the DER encoding of the 
 &nbsp; // data according to its contentType. Note that while the contentType
 &nbsp; // is always provided, it is legal for the data itself to actually
 &nbsp; // be omitted; this is indcated by pinfo-&gt;data.pBlobData == NULL
 &nbsp; //
 &nbsp; HRESULT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get_ContentInfo(
 &nbsp;&nbsp;&nbsp;&nbsp; [out,retval] PKCS7_CONTENTINFO*&nbsp; pinfo
 &nbsp;&nbsp;&nbsp;&nbsp; ); 
 &nbsp; //
 &nbsp; // Set the content information. Note that it is legal, as explained above,
 &nbsp; // for the actual content to be omitted.
 &nbsp; //
 &nbsp; HRESULT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; put_ContentInfo(
 &nbsp;&nbsp;&nbsp;&nbsp; [in] PKCS7_CONTENTINFO*&nbsp; pinfo
 &nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp; //////////////////////////////////////////////////////////////////////
 &nbsp; //
 &nbsp; // One particular kind of ContentInfo is an 'IndirectData', whose
 &nbsp; //&nbsp; ASN.1 looks like:
 &nbsp; //
 &nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IndirectDataContent ::= SEQUENCE {
 &nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AttributeTypeAndOptionalValue,
 &nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; messageDigest&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DigestInfo
 &nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- This is the message digests of the indicated data.
 &nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- (DigestInfo is defined in PKCS. It's a indication of
 &nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- the algorithm used along with the actual hash data.)
 &nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } --&lt;PDU&gt;--
 &nbsp; //
 &nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AttributeTypeAndOptionalValue ::= SEQUENCE {
 &nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ATTRIBUTE.&amp;id,
 &nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ATTRIBUTE.&amp;Type({...}{@type}) OPTIONAL
 &nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp; //
 &nbsp; //&nbsp; A ContentInfo of type IndirectDataContent is used to refer to a
 &nbsp; //&nbsp; data source that is external to the SignedData. The 'type' of 
 &nbsp; //&nbsp; the 'data' indicates, at the least, the means by which that external
 &nbsp; //&nbsp; data is to be hashed. 'value' is often omitted, implying that the
 &nbsp; //&nbsp; data refers to the entity of the indicated type in which this SignedData
 &nbsp; //&nbsp; is most immediately physically embedded. If present it usually
 &nbsp; //&nbsp; indicates some hint (such as a file name or URL) of the data to
 &nbsp; //&nbsp; which this SignedData refers.
 &nbsp; //
 &nbsp; //////////////////////////////////////////////////////////////////////
 &nbsp; HRESULT&nbsp;&nbsp;&nbsp; put_IndirectDataContent(
 &nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp; // Set the ContentInfo of this SignedData to be an IndirectDataContent
 &nbsp;&nbsp;&nbsp;&nbsp; // that has the following information.
 &nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp; OSIOBJECTID*&nbsp;&nbsp; pid,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Id value to set in the 'data.'
 &nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp; BLOB*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pBlobVale,&nbsp;&nbsp; // The encoded contents of the 'value.'
 &nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp; DIGESTINFO*&nbsp;&nbsp;&nbsp; pDigest&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The digest of the referred-to data.
 &nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp; HRESULT&nbsp;&nbsp;&nbsp; get_IndirectDataContent(
 &nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp; // Retrieve the IndirectDataContent that we expect to find in this
 &nbsp;&nbsp;&nbsp;&nbsp; // SignedData.
 &nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp; // E_FAIL is returned if all went well except that this 
 &nbsp;&nbsp;&nbsp;&nbsp; // SignedData doesn't contain the desired IndirectDataContent inside.
 &nbsp;&nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp;&nbsp; [in] OSIOBJECTID*&nbsp;&nbsp; pid,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Id value expected; error if different.
 &nbsp;&nbsp;&nbsp;&nbsp; [in] BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fValueNeeded,&nbsp; // Whether to bother returning the 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // value .
 &nbsp;&nbsp;&nbsp;&nbsp; [out]BLOB*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pBlobValue, // The returned value, if requested.
 &nbsp;&nbsp;&nbsp;&nbsp; [out]DIGESTINFO*&nbsp;&nbsp;&nbsp; pDigest&nbsp;&nbsp;&nbsp;&nbsp; // The returned digest of the referred-
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // to data.
 &nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp; //////////////////////////////////////////////////////////////////////
 &nbsp; //
 &nbsp; // Helper functions for signing data that requires the parameters, contained
 &nbsp; // in the IndirectDataContent representation in the SignedData, to be a 
 &nbsp; // link. 
 &nbsp; //
 &nbsp; // The basic sequence of events in signing is as follows:
 &nbsp; //
 &nbsp; //&nbsp; 1. Create an appropriate ISignableDocument
 &nbsp; //&nbsp; 2. Call IPkcs7SignedData::HashAndSetSignableDocument, passing in the 
 &nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; document
 &nbsp; //&nbsp; 3. Sign the SignedData with one or more SignerInfos
 &nbsp; //&nbsp; 4. Store the signature in the signable using 
 &nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IPkcs7SignedData::SaveIntoSignableDocument
 &nbsp; //
 &nbsp; // For verification, you do the reverse:
 &nbsp; //
 &nbsp; //&nbsp; 1. Create an appropriate signable
 &nbsp; //&nbsp; 2. Load the signature using LoadFromSignable
 &nbsp; //&nbsp; 3. Verify the basics using VerifyGeneric
 &nbsp; //&nbsp; 4. Verify the signature on the signer info using IAmSigned
 &nbsp; //
 &nbsp; //////////////////////////////////////////////////////////////////////
 &nbsp; HRESULT&nbsp;&nbsp;&nbsp; HashAndSetSignableDocument(
 &nbsp;&nbsp;&nbsp;&nbsp; [in] ISignableDocument* pdoc,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The source to hash.
 &nbsp;&nbsp;&nbsp;&nbsp; [in] HCRYPTPROV&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hprov,&nbsp;&nbsp;&nbsp;&nbsp; // (optional) Crypto provider to use: 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // for efficiency.
 &nbsp;&nbsp;&nbsp;&nbsp; [in] ALG_ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; algidHash&nbsp; // The hash algorithm to use.
 &nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp; 
 &nbsp; HRESULT&nbsp;&nbsp;&nbsp; SaveIntoSignableDocument(
 &nbsp;&nbsp;&nbsp;&nbsp; [in] ISignableDocument*&nbsp;&nbsp;&nbsp; pSignable,
 &nbsp;&nbsp;&nbsp;&nbsp; [in] BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fClearDirty
 &nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp; HRESULT&nbsp;&nbsp;&nbsp; LoadFromSignableDocument(
 &nbsp;&nbsp;&nbsp;&nbsp; [in] ISignableDocument*&nbsp; pSignable
 &nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp; 
 &nbsp; // VerifySignableDocument—The twin to HashAndSetSignableDocument.
 &nbsp; //
 &nbsp; // Verify that a) this SignedData contains an IndirectDataContent of the 
 &nbsp; // appropriate type of document, and b) the hash found inside said 
 &nbsp; // IndirectDataContent matches the current hash of the document.
 &nbsp; //
 &nbsp; // Note that we do not do signature checking; that is done, instead, on
 &nbsp; // SignerInfos found in this SignedData. 
 &nbsp; //
 &nbsp; // Return values:
 &nbsp; //&nbsp;&nbsp;&nbsp; S_OK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; It all matched
 &nbsp; //&nbsp;&nbsp;&nbsp; E_FAIL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Content isn't an IndirectDataContent of the right type
 &nbsp; //&nbsp;&nbsp;&nbsp; NTE_BAD_SIGNATURE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The hash did not match ...
 &nbsp; //
 &nbsp; HRESULT&nbsp;&nbsp;&nbsp; VerifySignableDocument(
 &nbsp;&nbsp;&nbsp;&nbsp; [in] ISignableDocument*&nbsp;&nbsp;&nbsp; pdoc,&nbsp;&nbsp;&nbsp; // The source to verify
 &nbsp;&nbsp;&nbsp;&nbsp; [in] HCRYPTPROV&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hprov,&nbsp;&nbsp; //(optional) Crypto provider to use:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //for efficiency .
 &nbsp;&nbsp;&nbsp;&nbsp; [in] ALG_ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; algidHash&nbsp;&nbsp;&nbsp; // Zero means use alg indicated by 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the data.
 &nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp; 
 &nbsp; //////////////////////////////////////////////////////////////////////
 &nbsp; //
 &nbsp; // Helper functionality that makes it easy to sign a flat file.
 &nbsp; //
 &nbsp; //////////////////////////////////////////////////////////////////////
 &nbsp; // Put/get a ContentInfo that refers indirectly to a flat file.
 &nbsp; //
 &nbsp; HRESULT&nbsp;&nbsp;&nbsp; put_ContentRawFile(
 &nbsp;&nbsp;&nbsp;&nbsp; [in] PKCS7_FILEDATA* pdata
 &nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp; HRESULT&nbsp;&nbsp;&nbsp; get_ContentRawFile(
 &nbsp;&nbsp;&nbsp;&nbsp; [out,retval] PKCS7_FILEDATA* pdata
 &nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp; // Even easier to use: hash the indicated file and then set the ContentInfo
 &nbsp; // to be IndirectDataContent that points to the indicated file. The intent
 &nbsp; // here is to cover the 80 percent case while letting the preceding functions
 &nbsp; //cover the more general cases.
 &nbsp; //
 &nbsp; HRESULT&nbsp;&nbsp;&nbsp; HashAndSetRawFile(
 &nbsp;&nbsp;&nbsp;&nbsp; [in] FILEHANDLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hFile,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (optional) An already-open handle
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // to the file.
 &nbsp;&nbsp;&nbsp;&nbsp; [in] LPCOLESTR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wszFileName,&nbsp; // NOT optional. the name of the file
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // to hash.
 &nbsp;&nbsp;&nbsp;&nbsp; [in] HCRYPTPROV&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hprov,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (optional) Crypto provider to use: 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // for efficiency.
 &nbsp;&nbsp;&nbsp;&nbsp; [in] ALG_ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; algidHash&nbsp;&nbsp;&nbsp;&nbsp; // The hash algorithm to use.
 &nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp; 
 &nbsp; // VerifyRawFile-The twin to HashAndSetRawFile.
 &nbsp; //
 &nbsp; // Verify that (a) this SignedData contains an IndirectDataContent of type 
 &nbsp; // 'raw file', and (b) the hash found inside this IndirectDataContent matches 
 &nbsp; // the hash of the file indicated here as EITHER wszFileName OR hFile. 
 &nbsp; // Use NULL to omit wszName; 
 &nbsp; // INVALID_HANDLE_VALUE to omit hFile. If both are provided, hFile, is used.
 &nbsp; // Note that we do NOT compare the link info in the IndirectDataContent 
 &nbsp; // to wszFileName in any way. Note also that this does not do signature
 &nbsp; // checking; that instead is done on SignerInfos found in this SignedData 
 &nbsp; //
 &nbsp; // Return values:
 &nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S_OK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; It all matched
 &nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; E_FAIL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Content isn't an IndirectDataContent of type raw file
 &nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NTE_BAD_SIGNATURE The hash did not match other...
 &nbsp; //
 &nbsp; HRESULT&nbsp;&nbsp;&nbsp; VerifyRawFile(
 &nbsp;&nbsp;&nbsp;&nbsp; [in] FILEHANDLE&nbsp;&nbsp;&nbsp;&nbsp; hFile,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (optional) An already-open handle to
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; the file.
 &nbsp;&nbsp;&nbsp;&nbsp; [in] LPCOLESTR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wszFileName,&nbsp; // (optional) The name of the file to
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; hash.
 &nbsp;&nbsp;&nbsp;&nbsp; [in] HCRYPTPROV&nbsp;&nbsp;&nbsp;&nbsp; hprov,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (optional) Crypto provider to use: 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; for efficiency.
 &nbsp;&nbsp;&nbsp;&nbsp; [in] ALG_ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; algidHash&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; Zero means use alg indicated by the 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; data.
 &nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp; //////////////////////////////////////////////////////////////////////
 &nbsp; // 
 &nbsp; //Methods for Istorages, which is analogous to that of raw files.
 &nbsp; //
 &nbsp; //////////////////////////////////////////////////////////////////////
 &nbsp; //
 &nbsp; // Note that Pkcs7SignedDatas also support IPersistStorage, by which
 &nbsp; // they can be loaded from/saved to an IStorage in the appropriate
 &nbsp; // location.

 &nbsp; HRESULT&nbsp;&nbsp;&nbsp; put_ContentStructuredStorage(
 &nbsp;&nbsp;&nbsp;&nbsp; [in] PKCS7_FILEDATA* pdata&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Often CERT_LINK_TYPE_NONE
 &nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp; HRESULT&nbsp;&nbsp;&nbsp; get_ContentStructuredStorage(
 &nbsp;&nbsp;&nbsp;&nbsp; [out,retval] PKCS7_FILEDATA* pdata&nbsp; // Often CERT_LINK_TYPE_NONE
 &nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp; HRESULT&nbsp;&nbsp;&nbsp; HashAndSetStorage(
 &nbsp;&nbsp;&nbsp;&nbsp; [in] IStorage*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pstg,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The IStorage to hash.
 &nbsp;&nbsp;&nbsp;&nbsp; [in] HCRYPTPROV&nbsp;&nbsp;&nbsp;&nbsp; hprov,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (optional) Crypto provider to use:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // for efficiency.
 &nbsp;&nbsp;&nbsp;&nbsp; [in] ALG_ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; algidHash&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The hash algorithm to use.
 &nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp; HRESULT&nbsp;&nbsp;&nbsp; VerifyStorage(
 &nbsp;&nbsp;&nbsp;&nbsp; [in] IStorage*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pstg,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The IStorage to hash.
 &nbsp;&nbsp;&nbsp;&nbsp; [in] HCRYPTPROV&nbsp;&nbsp;&nbsp;&nbsp; hprov,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (optional) Crypto provider to use:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // for efficiency.
 &nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp; ALG_ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; algidHash&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Zero means use alg indicated by the
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // data.
 &nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp; //////////////////////////////////////////////////////////////////////
 &nbsp; //
 &nbsp; // Methods for Image files—analogous to that of raw files
 &nbsp; //
 &nbsp; //////////////////////////////////////////////////////////////////////
 &nbsp; 
 &nbsp; HRESULT&nbsp;&nbsp;&nbsp; put_ContentImageFile(
 &nbsp;&nbsp;&nbsp;&nbsp; [in] PKCS7_IMAGEFILEDATA* pdata
 &nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp; HRESULT&nbsp;&nbsp;&nbsp; ContentImageFile(
 &nbsp;&nbsp;&nbsp;&nbsp; [out] PKCS7_IMAGEFILEDATA* pdata,
 &nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp; BOOL fWantFileData
 &nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp; 
 &nbsp; HRESULT&nbsp;&nbsp;&nbsp; HashAndSetImageFile(
 &nbsp;&nbsp;&nbsp;&nbsp; [in] DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwDigestLevel,&nbsp;&nbsp; // CERT_PE_IMAGE_DIGEST_XXXX
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // flags.
 &nbsp;&nbsp;&nbsp;&nbsp; [in] FILEHANDLE&nbsp;&nbsp;&nbsp; hFile,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (optional) An already-open handle
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // to the file.
 &nbsp;&nbsp;&nbsp;&nbsp; [in] LPCOLESTR&nbsp;&nbsp;&nbsp;&nbsp; wszFileName,&nbsp;&nbsp;&nbsp;&nbsp; // NOT optional. The name of the file 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // to hash.
 &nbsp;&nbsp;&nbsp;&nbsp; [in] HCRYPTPROV&nbsp;&nbsp;&nbsp; hprov,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (optional) Crypto provider to use: 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // for efficiency.
 &nbsp;&nbsp;&nbsp;&nbsp; [in] ALG_ID&nbsp;&nbsp;&nbsp;&nbsp; a&nbsp; lgidHash&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The hash algorithm to use.
 &nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp; //
 &nbsp; // Verify that: 
 &nbsp; //&nbsp; (a) this SignedData contains an IndirectDataContent of type 'image file',
 &nbsp; //&nbsp; and (b) the hash found inside this IndirectDataContent matches the hash
 &nbsp; //&nbsp; of the file indicated here as EITHER wszFileName OR hFile. Use NULL to 
 &nbsp; //&nbsp; omit wszName; INVALID_HANDLE_VALUE to omit hFile. If both are provided,
 &nbsp; //&nbsp; hFile is used.
 &nbsp; // 
 &nbsp; HRESULT&nbsp;&nbsp;&nbsp; VerifyImageFile(
 &nbsp;&nbsp;&nbsp;&nbsp; [in] DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwDigestLevel,&nbsp;&nbsp; // CERT_PE_IMAGE_DIGEST_XXXX
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // flags, zero==use per data indication
 &nbsp;&nbsp;&nbsp;&nbsp; [in] FILEHANDLE&nbsp;&nbsp; hFile,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (optional) An already-open handle to
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; the file.
 &nbsp;&nbsp;&nbsp;&nbsp; [in] LPCOLESTR&nbsp;&nbsp;&nbsp; wszFileName,&nbsp;&nbsp;&nbsp;&nbsp; // (optional) The name of the file to 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; hash.
 &nbsp;&nbsp;&nbsp;&nbsp; [in] HCRYPTPROV&nbsp;&nbsp; hprov,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (optional) Crypto provider to use: 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; for efficiency.
 &nbsp;&nbsp;&nbsp;&nbsp; [in] ALG_ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; algidHash&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; Zero means use alg indicated by the
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; data.
 &nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp; //////////////////////////////////////////////////////////////////////
 &nbsp; //
 &nbsp; //Methods for Java class files—analogous to that of raw files.
 &nbsp; //
 &nbsp; //////////////////////////////////////////////////////////////////////
 &nbsp; 
 &nbsp; HRESULT&nbsp;&nbsp;&nbsp; put_ContentJavaClassFile(
 &nbsp;&nbsp;&nbsp;&nbsp; [in] PKCS7_FILEDATA* pdata
 &nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp; HRESULT&nbsp;&nbsp;&nbsp; get_ContentJavaClassFile(
 &nbsp;&nbsp;&nbsp;&nbsp; [out,retval] PKCS7_FILEDATA* pdata
 &nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp; HRESULT&nbsp;&nbsp;&nbsp; HashAndSetJavaClassFile(
 &nbsp;&nbsp;&nbsp;&nbsp; [in] FILEHANDLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hFile,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (optional) An already-open handle 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // to the file.
 &nbsp;&nbsp;&nbsp;&nbsp; [in] LPCOLESTR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wszFileName,&nbsp;&nbsp; // NOT optional. the name of the file
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // to hash.
 &nbsp;&nbsp;&nbsp;&nbsp; [in] HCRYPTPROV&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hprov,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (optional) Crypto provider to use:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // for efficiency.
 &nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp; ALG_ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; algidHash&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The hash algorithm to use.
 &nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp; HRESULT&nbsp;&nbsp;&nbsp; VerifyJavaClassFile(
 &nbsp;&nbsp;&nbsp;&nbsp; [in] FILEHANDLE&nbsp;&nbsp;&nbsp;&nbsp; hFile,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (optional) An already-open handle 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; to the file.
 &nbsp;&nbsp;&nbsp;&nbsp; [in] LPCOLESTR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wszFileName,&nbsp;&nbsp; // (optional) The name of the file to 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; hash.
 &nbsp;&nbsp;&nbsp;&nbsp; [in] HCRYPTPROV&nbsp;&nbsp;&nbsp;&nbsp; hprov,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (optional) Crypto provider to use: 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; for efficiency.
 &nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp; ALG_ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; algidHash&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; Zero means use alg indicated by the
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; data.
 &nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp; HRESULT&nbsp;&nbsp;&nbsp; SaveIntoJavaClassFile(
 &nbsp;&nbsp;&nbsp;&nbsp; [in] FILEHANDLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hFile,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (optional) An already-open handle to
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; the file.
 &nbsp;&nbsp;&nbsp;&nbsp; [in] LPCOLESTR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wszFileName,&nbsp; // (optional) The name of the file to 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; hash.
 &nbsp;&nbsp;&nbsp;&nbsp; [in] BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fClearDirty
 &nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp; HRESULT&nbsp;&nbsp;&nbsp; LoadFromJavaClassFile(
 &nbsp;&nbsp;&nbsp;&nbsp; [in] FILEHANDLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hFile,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (optional) An already-open handle
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; to the file.
 &nbsp;&nbsp;&nbsp;&nbsp; [in] LPCOLESTR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wszFileName&nbsp;&nbsp;&nbsp; // (optional) The name of the file
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; to hash.
 &nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp; //////////////////////////////////////////////////////////////////////
 &nbsp; //////////////////////////////////////////////////////////////////////
 &nbsp; //
 &nbsp; //&nbsp;&nbsp; SignerInfo management.
 &nbsp; //
 &nbsp; //////////////////////////////////////////////////////////////////////
 &nbsp; //////////////////////////////////////////////////////////////////////
 &nbsp; //
 &nbsp; // Return the number of signer infos that presently exist.
 &nbsp; //
 &nbsp; HRESULT&nbsp;&nbsp;&nbsp; get_SignerInfoCount(
 &nbsp;&nbsp;&nbsp;&nbsp; [out,retval] LONG* pcinfo
 &nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp; 
 &nbsp; //
 &nbsp; // Return access to the nth signerinfo we presently have. Callers
 &nbsp; // should not rely on the ordering across save / load boundaries.
 &nbsp; //
 &nbsp; HRESULT&nbsp;&nbsp;&nbsp; get_SignerInfo(
 &nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LONG iInfo,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Zero-origin index of info sought
 &nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REFIID iid,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Typically ISignerInfo
 &nbsp;&nbsp;&nbsp;&nbsp; [out, iid_is(iid),retval] void** ppv
 &nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp; //
 &nbsp; // Create a new signer info at the end of the list and return access to it.
 &nbsp; //
 &nbsp; HRESULT&nbsp;&nbsp;&nbsp; create_SignerInfo(
 &nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LONG&nbsp;&nbsp;&nbsp; iInfoBefore,// Create before this; -1 means end.
 &nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REFIID&nbsp; iid,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Typically ISignerInfo
 &nbsp;&nbsp;&nbsp;&nbsp; [out, iid_is(iid),retval] void**&nbsp;&nbsp;&nbsp; ppv
 &nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp; //
 &nbsp; // Delete an existing signer info. The indices of the
 &nbsp; // signer infos above this shift down by one.
 &nbsp; //
 &nbsp; // If any signer info is presently open, this method returns an error.
 &nbsp; //
 &nbsp; HRESULT&nbsp;&nbsp;&nbsp; remove_SignerInfo(
 &nbsp;&nbsp;&nbsp;&nbsp; [in] LONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iInfo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Zero-origin index of info to remove.
 &nbsp;&nbsp;&nbsp;&nbsp; );
}
</code></pre>
<h4><a name="iesignipkcs10"></a>IPkcs10 </h4>
<p>
This is an interface used for manipulating a PKCS #10 Certification Request. </p>
<p>
Instances of this interface normally also support several other interfaces. In particular, <b>ISelectedAttributes </b>is supported in order to provide access to the attributes that are part of the request, but are not going into the ultimately generated certificate. </p>
<p>
See also the method <b>IPkcs10::get_Subject</b>.</p>
<pre><code>interface IPkcs10 : IPublicKeyContainer {
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // Retrieve an object through which the subject information of the 
 &nbsp;&nbsp;&nbsp; // certification request may be set or inquired. The attributes set on this 
 &nbsp;&nbsp;&nbsp; // subject become(part of) the attributes of the issued certificate. The 
 &nbsp;&nbsp;&nbsp; // returned object will support (at least) ISelectedAttributes and 
 &nbsp;&nbsp;&nbsp; // IX500Name.
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; get_Subject(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REFIID&nbsp;&nbsp; iid,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ISelectedAttributes or IX500Name
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [out, iid_is(iid),retval] void**&nbsp;&nbsp; ppvObj
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
}
</code></pre>
<h4><a name="iesignipublickeycontainer"></a>IPublicKeyContainer </h4>
<p>
An interface that abstracts the ability to contain a public key of a public/private key pair.</p>
<pre><code>interface IPublicKeyContainer : IUnknown {
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // Retrieve and set the public key contained herein.
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get_PublicKey(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HCRYPTPROV hprov,&nbsp;&nbsp;&nbsp;&nbsp; // Provider under which to retrieve
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // things.
 &nbsp;&nbsp;&nbsp;&nbsp; [out,retval] HCRYPTKEY* phkey&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Place to return the public key.
 &nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; put_PublicKey(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HCRYPTPROV hprov,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Get the key from this provider...
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwKeySpec&nbsp;&nbsp; //&nbsp; ... and this key spec (usually 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // AT_SIGNATURE).
 &nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; get_PublicKeyBlob(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [out,retval] BLOB* pblob&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Retrieves DER encoding of 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // SubjectPublicKeyInfo.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; put_PublicKeyBlob(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BLOB* pblob&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DER or BER of SubjectPublicKeyInfo.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // Return the necessary Cryptographic information so that you can tell what
 &nbsp;&nbsp;&nbsp; // kind of provider is going to be needed for this public key.
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // Examples returned include:
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALG_RSA_SIGN
 &nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALG_DSS_SIGN
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // That is, the 'signature' key spec variation is always returned;
 &nbsp;&nbsp;&nbsp; // if caller wishes to do 'key exchange' instead, he must map the
 &nbsp;&nbsp;&nbsp; // algorithm identifiers.
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; get_SignatureAlgorithm(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [out,retval] ALG_ID* palgid
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp; 
}
</code></pre>
<h4><a name="iesignipublickeypair"></a>IPublicKeyPair </h4>
<p>
This is a helper interface for manipulating a public-key pair generated and found in a Cryptographic Service Provider.</p>
<pre><code>interface IPublicKeyPair : IUnknown {
 &nbsp;&nbsp;&nbsp; // Set the cryptographic provider to use. If not called, then this defaults&nbsp; 
 &nbsp;&nbsp;&nbsp; // to the default crypto provider. This is an initialization method; it 
 &nbsp;&nbsp;&nbsp; // must be called before any of the generation or loading methods, if it is
 &nbsp;&nbsp;&nbsp; // to be called at all.
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; SetProviderInfo(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp; LPCWSTR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wszProviderName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp; DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwProviderType
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp;&nbsp; // Generate a new key pair.
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp; Generate(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in] HWND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hwnd,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Parent for any user interaction 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // needed.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in] LPCWSTR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wszKeySet,&nbsp;&nbsp; // Optional. Key set name to use.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in] DWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwKeySpec&nbsp;&nbsp;&nbsp; // AT_SIGNATURE or AT_KEYEXCHANGE
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp;&nbsp; // Save the key pair into the indicated file name.
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp; Save(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in] HWND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hwnd,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Parent for any user interaction 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // needed.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in] LPCWSTR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wszKeyNickName, // Optional, defaults to wszFileName.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in] LPCWSTR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wszFileName&nbsp;&nbsp;&nbsp;&nbsp; // File to save to.
 &nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp;&nbsp; // Load the key pair from the indicated file name.
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; Load
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in] LPCWSTR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wszKeySet,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Optional. Key set name to use.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in] HWND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hwnd,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Parent for any user interaction 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // needed.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in] LPCWSTR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wszKeyNickName, // Optional, defaults to wszFileName.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in,out] DWORD*&nbsp;&nbsp; pdwKeySpec,&nbsp;&nbsp;&nbsp;&nbsp; // Optional, keyspec to load/was
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // loaded.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in] LPCWSTR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wszFileName&nbsp;&nbsp;&nbsp;&nbsp; // File to load from.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp;&nbsp; // Save the key pair into the indicated already-open Istorage.
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp; SaveStg(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in] HWND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hwnd,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Parent for any user interaction
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // needed.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in] LPCWSTR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wszKeyNickName, // 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in] IStorage*&nbsp;&nbsp;&nbsp; pstg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // IStorage to save into.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp;&nbsp; // Load the key pair from the indicated already-open Istorage.
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; LoadStg(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in] LPCWSTR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wszKeySet,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Optional. Key set name to use.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in] HWND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hwnd,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Parent for any user interaction
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // needed.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in] LPCWSTR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wszKeyNickName, // 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in,out] DWORD*&nbsp;&nbsp; pdwKeySpec,&nbsp;&nbsp;&nbsp;&nbsp; // Optional. keyspec to load/was
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //loaded.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in] IStorage*&nbsp;&nbsp;&nbsp; pstg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // IStorage to load from.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp;&nbsp; // Return the present cryptographic information
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; GetCryptInfo(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp; HWND&nbsp;&nbsp; hwnd,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Parent for any user interaction
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // needed.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [out] HCRYPTPROV*&nbsp;&nbsp; phprov,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Optional.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [out] HCRYPTKEY*&nbsp;&nbsp; phkey,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Optional; must be NULL if phprov is
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [out] LPWSTR*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pwszKeySet,&nbsp;&nbsp; // Optional.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [out] DWORD*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pdwKeySpec&nbsp;&nbsp;&nbsp;&nbsp; // Optional.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp;&nbsp; // Destroy the key pair that is presently generated/loaded. This
 &nbsp;&nbsp;&nbsp; // is not done automatically.
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; Destroy( );
}
</code></pre>
<h4><a name="iesigniselectedattributes"></a>ISelectedAttributes </h4>
<p>
This is an interface for setting and retrieving a selection of common and/or useful attributes (defined in X.501). Specifically, the attributes listed here are many of those suggested as being handy by PKCS #9, some of the ones defined in PKCS #9 itself, and a few others.</p>
<p>
The interface can also can be used to read and write X.509 extensions instead of X.501 attributes. Typically, a given instance of this interface will either write extensions or will write attributes; an attempt to write extensions to an attribute instance will return DIGSIG_E_EXTENSIBILITY.</p>
<p>
All maximum sizes mentioned here are per <b>UpperBounds</b> {joint-iso-ccitt ds(5) module(1) <b>upperBounds</b>(10) 2}.</p>
<pre><code>interface ISelectedAttributes : IUnknown {
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // Set/get an arbitrary single-valued attribute (Attribute is defined in 
 &nbsp;&nbsp;&nbsp; // X.501).No support is presently provided for arbitrary multi-valued 
 &nbsp;&nbsp;&nbsp; // attributes. When attempting to retrieve an attribute, an error of 
 &nbsp;&nbsp;&nbsp; // STG_E_FILENOTFOUND indicates that the requested attribute is not 
 &nbsp;&nbsp;&nbsp; // present.
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp; put_Attribute (
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in] OSIOBJECTID* id,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The attribute ID to set.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in] BLOB*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pData&nbsp;&nbsp;&nbsp; // Data in ASN.1 DER; NULL to remove 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // attribute.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp; get_Attribute(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp; OSIOBJECTID*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; id, // The attribute ID to retrieve.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [out,retval] BLOB*&nbsp; pData&nbsp;&nbsp; // Returned data in ASN.1 DER, NULL to not 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // get data.
 &nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp; 
 &nbsp;&nbsp;&nbsp; // Set/get an arbitrary X.509 v3 Extension. When attempting to retrieve an 
 &nbsp;&nbsp;&nbsp; // attribute, an error of STG_E_FILENOTFOUND indicates that the requested 
 &nbsp;&nbsp;&nbsp; // extension is not present.

 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp; put_Extension
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in] OSIOBJECTID* id,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The extension ID to set.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in] BOOL fCritical,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Whether this is a critical extension or
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // not.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in] BLOB*pData&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Data in ASN.1 DER; NULL to remove 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // extension.
 &nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp; get_Extension
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp; OSIOBJECTID* id,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The extension ID to retrieve.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [out] BOOL*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fCritical, // Whether this is a critical extension or
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // not.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [out,retval] BLOB*pData&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Returned data in ASN.1 DER, NULL to not
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // get data.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp;&nbsp; // Retrieve the entire list of attribute/extension object IDs that is found
 &nbsp;&nbsp;&nbsp; // herein.
 &nbsp; 
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; get_ OsiIdList(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [out,retval] OSIOBJECTIDLIST** ppList&nbsp;&nbsp; // Place to return newly-
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // allocated list of IDs.
 &nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp; 
 &nbsp;&nbsp;&nbsp; // Copy this bag of attributes/extensions into another. 
 &nbsp;&nbsp;&nbsp; // The destination bag of attributes is NOT emptied first; we merely add to 
 &nbsp;&nbsp;&nbsp; // it(perhaps replacing some existing attributes with updated instances).
 &nbsp; 
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; CopyTo(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in, unique] ISelectedAttributes* pattrs&nbsp;&nbsp; // Bag of attributes to fill.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp;&nbsp; //----------------------------
 &nbsp;&nbsp;&nbsp; // Helper methods for setting/getting a selected number of common
 &nbsp;&nbsp;&nbsp; // attributes/extensions.
 &nbsp; 
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // Set/get a generic directory string (see the ITU-T standard).
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp; put_DirectoryString([in] OSIOBJECTID*pid, [in] LPCOLESTR wsz);
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp; get_DirectoryString([in] OSIOBJECTID*pid, [out,retval] LPOLESTR*
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pwsz);
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp; put_CommonName([in] LPCOLESTR wsz);
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp; get_CommonName([out,retval] LPOLESTR* pwsz);
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp; put_Surname([in] LPCOLESTR wsz);
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp; get_Surname([out,retval] LPOLESTR* pwsz);
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp; put_LocalityName([in] LPCWSTR wsz);
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp; get_LocalityName&nbsp;&nbsp; ([out,retval] LPOLESTR* pwsz);
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp; put_CountryName&nbsp;&nbsp; ([in] LPCOLESTR wsz);
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp; get_CountryName&nbsp;&nbsp; ([out,retval] LPOLESTR* pwsz);
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp; put_StateOrProvinceName([in] LPCOLESTR wsz);
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp; get_StateOrProvinceName([out,retval] LPOLESTR* pwsz);
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp; put_OrganizationName&nbsp;&nbsp; ([in] LPCOLESTR wsz);&nbsp;&nbsp; // 64 chars max
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp; get_OrganizationName&nbsp;&nbsp; ([out,retval] LPOLESTR* pwsz); 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 64 ch. max
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp; put_OrganizationalUnitName([in] LPCOLESTR wsz);
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp; get_OrganizationalUnitName([out,retval] LPOLESTR* pwsz);
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // From X.509 v3 DAM:
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; //&nbsp;&nbsp; "This field, which can be either a certificate extension or CRL 
 &nbsp;&nbsp;&nbsp; //&nbsp;&nbsp; extension,identifies the CA's key used to sign the certificate or CRL. 
 &nbsp;&nbsp;&nbsp; //&nbsp;&nbsp; It enables distinct keys used by the same CA to be differentiated 
 &nbsp;&nbsp;&nbsp; //&nbsp;&nbsp; (for example, as key updating occurs). The key may be identified by an
 &nbsp;&nbsp;&nbsp; //&nbsp;&nbsp; explicit key identifier, by identification of a certificate for the 
 &nbsp;&nbsp;&nbsp; //&nbsp;&nbsp; key (giving certificate issuer and certificate serial number), or 
 &nbsp;&nbsp;&nbsp; //&nbsp;&nbsp; both. If both are used then the certificate issuer shall ensure that 
 &nbsp;&nbsp;&nbsp; //&nbsp;&nbsp; all three fields are consistent."
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; //&nbsp;&nbsp; These methods give access to this extension, if it is present. The 
 &nbsp;&nbsp;&nbsp; //&nbsp;&nbsp; (optional) keyIdentifer field is only returned if it is the size of an 
 &nbsp;&nbsp;&nbsp; //&nbsp;&nbsp; MD5Digest.
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; put_AuthorityKeyIdentifier([in] CERTIFICATENAMES* pnames);
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; get_AuthorityKeyIdentifier([out, retval] CERTIFICATENAMES* 
 &nbsp;&nbsp;&nbsp; pnames);
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // CertIdentifier is an attribute that is closely related to 
 &nbsp;&nbsp;&nbsp; // AuthorityKeyIdentifier.
 &nbsp;&nbsp;&nbsp; // It is intended for use in PKCS#7 SignerInfos.
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // An X.509 certificate certifies (among other things) in its signed data:
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; issuer name
 &nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; serial number
 &nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subject name
 &nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subject public key
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // Given just this information, an attempt can be made to locate the parent 
 &nbsp;&nbsp;&nbsp; // certificate. This is done by looking for a parent certificate whose 
 &nbsp;&nbsp;&nbsp; // subject name is the issuer name in the child certificate.
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // The X.509 DAM defines infrastructure to support alternate ways of 
 &nbsp;&nbsp;&nbsp; // finding the parent certificate. Specifically (as used herein) it defines 
 &nbsp;&nbsp;&nbsp; // a certificate extension, which (in addition to the above info) 
 &nbsp;&nbsp;&nbsp; // indicates:
 &nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parent's issuer name &amp;  parent's serial number
 &nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parent's public key
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // Thus, one can now look for the parent certificate by finding a 
 &nbsp;&nbsp;&nbsp; // certificate whose issuer name and serial number are those of the parent 
 &nbsp;&nbsp;&nbsp; // as indicated in the authorityKeyIdentifier extension of the child, or 
 &nbsp;&nbsp;&nbsp; // whose public key is the one of the parent as indicated.
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // Consider, now, PCKS#7 SignerInfos, which have a similar need to identify
 &nbsp;&nbsp;&nbsp; // the certificate used. Inside the SignerInfo itself one can place the:
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parent's issuer name &amp;  parent's serial number
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // (where 'parent' is the certificate used to sign the SignerInfo).&nbsp; 
 &nbsp;&nbsp;&nbsp; // However, no support is provided for looking up by either simple parent 
 &nbsp;&nbsp;&nbsp; // subject name or parent public key. To provide for such uniformity, we 
 &nbsp;&nbsp;&nbsp; // herein define a new attribute that allows such additional information to 
 &nbsp;&nbsp;&nbsp; // be conveyed. This is the CertIdentifier attribute, which stores:
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parent subject name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and / or
 &nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parent public key
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // (any issuerSerialNumber in the pnames paramter is ignored).
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; put_CertIdentifier([in]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CERTIFICATENAMES* pnames);
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; get_CertIdentifier([out, retval]CERTIFICATENAMES* pnames);
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // Access to the 'basicConstraints' extension as defined by the X.509 DAM.
 &nbsp;&nbsp;&nbsp; // Support is not provided here for the (optional) 'permittedSubtrees' and 
 &nbsp;&nbsp;&nbsp; // 'exludedSubtrees' defined therein, other than to provide a means to 
 &nbsp;&nbsp;&nbsp; // indicate their presence or absence; if access to these is required, 
 &nbsp;&nbsp;&nbsp; // please use the generic extension/attribute mechanisms previously 
 &nbsp;&nbsp;&nbsp; // defined.
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; put_BasicConstraints(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp;&nbsp;&nbsp; CERT_BASICCONSTRAINTS*&nbsp;&nbsp;&nbsp; pConstraints,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp;&nbsp;&nbsp; BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fCritical
 &nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp; get_BasicConstraints(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [out]&nbsp; CERT_BASICCONSTRAINTS*&nbsp; pConstraints,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in,out,unique] BOOL*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pfCritical,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Was extension
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; critial may be NULL
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in,out,unique] BOOL*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pfSubtreesPresent // NULL if you don't 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; want&nbsp; to know
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // Per the X.509 v3 DAM, the keyUsageRestriction extension can be used to 
 &nbsp;&nbsp;&nbsp; // restrict the set of policies under which a certified key may be used. 
 &nbsp;&nbsp;&nbsp; // Microsoft has defined a restricted use of this extension, known as a 
 &nbsp;&nbsp;&nbsp; // 'Key Purpose'. In short, a key purpose is a certificate policy element 
 &nbsp;&nbsp;&nbsp; // that is a yes/no predicate as to whether the key can be used for a given 
 &nbsp;&nbsp;&nbsp; // function. Examples of key purposes include software publisher
 &nbsp;&nbsp;&nbsp; // licensing, and 'windows compatibility testing' _Allowed_ 
 &nbsp;&nbsp;&nbsp; // purposes are indicated in the keyUsageRestriction of a certificate; when 
 &nbsp;&nbsp;&nbsp; // one actually signs some data, the _applied_ purpose of the signing can 
 &nbsp;&nbsp;&nbsp; // be indicated in the StatementType attribute (see below).
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // KeyCanBeUsedForSigning answers whether the certificate can be used for 
 &nbsp;&nbsp;&nbsp; // creating digital signatures with the indicated purpose. If key usage 
 &nbsp;&nbsp;&nbsp; // restrictions are absent, then fExplicit controls whether 'yes' or 'no' 
 &nbsp;&nbsp;&nbsp; // is returned. If a key usage restriction is present, then a check is made 
 &nbsp;&nbsp;&nbsp; // that:
 &nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a) The indicated purpose is a policy-element ID in at least one of 
 &nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the permitted cert policies, and
 &nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b) The certificate is allowed to be used for the usage 
 &nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'digitalSignature' and/or 'keyCertSign'
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // Note that in practice this question about whether a given key can be 
 &nbsp;&nbsp;&nbsp; // used for signing needs to be explicitly asked of each thing up the 
 &nbsp;&nbsp;&nbsp; // certification chain; this routine itself does no walking of that chain.
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // Return values:
 &nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S_OK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yes, it can
 &nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S_FALSE&nbsp;&nbsp; no, it cannot
 &nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error&nbsp;&nbsp;&nbsp;&nbsp; I can't tell for some reason
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; get_KeyCanBeUsedForSigning(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in,unique] CERT_PURPOSE*&nbsp;&nbsp; pPurpose,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fExplicit&nbsp;&nbsp; // False means absence of 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // restriction is ok.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // The inverse of get_KeyCanBeUsedForSigning. Indicate, explicitly, that 
 &nbsp;&nbsp;&nbsp; // this key can be used for signing things with the given purpose.
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp; put_ KeyCanBeUsedForSigning(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in,unique] CERT_PURPOSE*&nbsp;&nbsp; pPurpose
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get_MeetsMinimalFinancialCriteria(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [out]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BOOL*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pfFinancialCriteriaAvailable,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [out, retval] BOOL*&nbsp;&nbsp;&nbsp; pfMeets
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; put_ MeetsMinimalFinancialCriteria(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fFinancialCriteriaAvailable,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BOOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fMeets
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // Access to the MS-defined Statement Type attribute, used, typically, in 
 &nbsp;&nbsp;&nbsp; // the authenticatedAttributes of SignerInfo inside a PKCS#7 SignedData.
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp; put_StatementType([in]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CERT_PURPOSES* pUsages);
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp; get_StatementType([out,retval]CERT_PURPOSES**ppUsages);
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // Information about an agency that issues Software Publishing Licenses.
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp; put_SplAgencyInfo([in]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SPL_AGENCYINFO* pinfo);
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp; get_SplAgencyInfo([out,retval]SPL_AGENCYINFO* pinfo);
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // Information about a published work of software.
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp; put_SplOpusInfo([in]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SPL_OPUSINFO* pinfo);
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp; get_SplOpusInfo([out,retval]SPL_OPUSINFO* ppinfo)
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // A couple of attributes from PKCS #9 that are needed in PKCS #7
 &nbsp;&nbsp;&nbsp; // SignerInfos.
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; put_ContentType([in ] OSIOBJECTID*&nbsp;&nbsp;&nbsp;&nbsp; pidContentType);
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; get_ContentType([out, retval] OSIOBJECTID** ppidContentType);
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; put_MessageDigest([in] BLOB* pBlobDigest);
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; get_MessageDigest([out, retval] BLOB*&nbsp;&nbsp; pBlobDigest);
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; put_EmailAddress([in] LPCOLESTR wsz);
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; get_EmailAddress&nbsp;&nbsp; ([out, retval] LPOLESTR*&nbsp;&nbsp; pwsz);
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; put_SigningTime([in,&nbsp; unique] FILETIME* pftUtc);&nbsp;&nbsp; // NULL uses
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 'now'
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; get_SigningTime([out, retval] FILETIME* pftUtc);
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; put_UnstructuredName([in] LPCWSTR wsz);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // PKCS#9
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; get_UnstructuredName([out,retval] LPWSTR* pwsz);&nbsp;&nbsp; // PKCS#9
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; put_GivenName([in] LPCOLESTR wsz);
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; get_GivenName([out,retval] LPOLESTR* pwsz);
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; put_Initials([in] LPCOLESTR wsz);
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; get_Initials([out,retval] LPOLESTR* pwsz);
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; put_Title([in] LPCOLESTR wsz);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 64 chars max
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; get_Title([out,retval] LPOLESTR* pwsz);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 64 chars max
 &nbsp;&nbsp;&nbsp; //----------------------------
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; put_StreetAddress([in] LPCWSTR wsz);
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; get_StreetAddress([out,retval] LPWSTR* pwsz);
 &nbsp; 
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; put_PostalCode([in] LPCWSTR wsz);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 40 chars max
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; get_PostalCode([out,retval] LPWSTR* pwsz);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 40 chars max
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; put_PostOfficeBox([in] LPCWSTR wsz);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 40 chars max
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; get_PostOfficeBox([out,retval] LPWSTR* pwsz);&nbsp;&nbsp;&nbsp; // 40 chars max
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; put_PhysicalDeliveryOfficeName([in] LPCWSTR wsz);&nbsp; // 128 ch max
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; get_PhysicalDeliveryOfficeName([out,retval] LPWSTR* pwsz); 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 128&nbsp; max
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; UnstructuredAddress([in] LPCWSTR wsz);
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; UnstructuredAddress([out,retval] LPWSTR* pwsz);
 &nbsp; 
 &nbsp; //----------------------------
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; put_TelephoneNumber([in] LPCWSTR wsz);&nbsp;&nbsp; // 32 chars max,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // printable chars only
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; get_TelephoneNumber([out,retval] LPWSTR* pwsz); // 32 chars max,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp; printable chars only 
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; put_FaxTelephoneNumber([in] LPCWSTR wsz);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 32 chars max,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp; printable chars only
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; get_FaxTelephoneNumber([out,retval] LPWSTR* pwsz);&nbsp;&nbsp; // 32 chars
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // max, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp; printable chars only 
 &nbsp;&nbsp;&nbsp; //----------------------------
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; put_ChallengePassword([in] LPCWSTR wsz);
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; get_ChallengePassword([out,retval] LPWSTR* pwsz);
}
</code></pre>
<h4><a name="iesignisignabledocument"></a>ISignableDocument</h4>
<p>
An interface used on an object that participates in the generic signing process in <b>IPkcs7SignedData</b>.</p>
<p>
Notice that this interface derives from <b>IAmHashed</b>.</p>
<pre><code>interface ISignableDocument : IAmHashed {
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // Return the information to go into the IndirectDataContent
 &nbsp;&nbsp;&nbsp; // that indicates the flavor of indirect data in question.
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get_DataIdentifier(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [out] OSIOBJECTID** ppid
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // Get a reference to the location of this data.
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get_DataLocation(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [out]&nbsp; CERT_LINK* plink&nbsp;&nbsp;&nbsp; // CERT_LINK_TYPE_NONE is legal
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp; 
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // Load the signature block from this data.
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LoadSignature(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [out,retval]&nbsp;&nbsp; BLOB* pBlobSignature
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // Insert the signature block into this data.
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; SaveSignature(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp;&nbsp; BLOB* pBlobSignature
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp;&nbsp; };
</code></pre>
<h4><a name="iesignisignerinfo"></a>ISignerInfo </h4>
<p>
This interface is used to manipulate a PKCS #7 <b>SignerInfo</b> structure. Typically, instances are created and manipulated using <b>IPkcs7SignedData::SignerInfo</b>.</p>
<p>
Instances of this interface also support <b>IAmSigned</b>, by which the actual signing is carried out.</p>
<pre><code>interface ISignerInfo : IUnknown {
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // Return access to the authenticated attributes.
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; get_AuthenticatedAttributes(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REFIID&nbsp;&nbsp;&nbsp; iid,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Typically ISelectedAttributes
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [out, iid_is(iid),retval] void** ppv
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp; 
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // Return access to the unauthenticated attributes.
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; get_UnauthenticatedAttributes(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REFIID iid,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Typically ISelectedAttributes
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [out, iid_is(iid),retval] void** ppv
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // If we have ANY authenticated attributes, then update/create 
 &nbsp;&nbsp;&nbsp; // those that MUST be there per PKCS#7. This is done automatically
 &nbsp;&nbsp;&nbsp; // if the SignerInfo is signed; this method allows it to be done
 &nbsp;&nbsp;&nbsp; // manually so that the correct hash may be extracted if desired.
 &nbsp;&nbsp;&nbsp; // Note, however, that signing is the ONLY thing that will automatically
 &nbsp;&nbsp;&nbsp; // update; in particular, saving will not.
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; UpdateRequiredAuthenticatedAttributes(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp; HCRYPTPROV&nbsp;&nbsp;&nbsp;&nbsp; hprov,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Crypto provider to use for hash
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp; ALG_ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; algidHash&nbsp;&nbsp; // Hash algorithm to use (encryption
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp; alg implied by&nbsp; key)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp;&nbsp; // 
 &nbsp;&nbsp;&nbsp; // Access to the information about the certificate used
 &nbsp;&nbsp;&nbsp; // in signing this signer info.
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; put_CertificateUsed(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in] CERTIFICATENAMES*&nbsp;&nbsp;&nbsp; pnames
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get_CertificateUsed(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [out,retval] CERTIFICATENAMES* pnames
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp;&nbsp; }
</code></pre>
<h4><a name="iesignix509"></a>IX509 </h4>
<p>
<b>IX509</b> is the central interface used for manipulating an X.509 certificate. Instances of <b>IX509</b> almost always support <b>ISelectedAttributes</b> (in extensions mode) as a means by which extensions to the certificate can be read or written. Its definition is as follows:</p>
<pre><code>interface IX509 : IPublicKeyContainer {
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // Set/get the serial number in the certificate.
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp; get_SerialNumber(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [out,retval] CERTSERIAL*&nbsp;&nbsp;&nbsp; pserial
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; put_SerialNumber(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in] CERTSERIAL*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pserial
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // Get access to the issuer name of this certificate.
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get_Issuer(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REFIID&nbsp;&nbsp; iid,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Usually IX500Name or 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // IPersistMemBlob
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [out, iid_is(iid),retval] void**&nbsp;&nbsp;&nbsp; ppv
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // This certificate, if it belongs to a CA, may be used to certify other 
 &nbsp;&nbsp;&nbsp; // certificates. In such a child certificate, the name of *this*&nbsp; 
 &nbsp;&nbsp;&nbsp; // certificate needs to be stored as a means of indicating the parent 
 &nbsp;&nbsp;&nbsp; // certificate in the chain. This method returns the names by which this 
 &nbsp;&nbsp;&nbsp; // certificate should be so known when used as such a parent certificate in 
 &nbsp;&nbsp;&nbsp; // a chain.
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; HRESULT get_CertificateNames(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HCRYPTPROV&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hprov,&nbsp;&nbsp;&nbsp;&nbsp; // (Optional; provide 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // for performance.)
 &nbsp;&nbsp;&nbsp;&nbsp; [out,retval] CERTIFICATENAMES*&nbsp; pnames
 &nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // Get access to the subject name of this certificate.
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; get_Subject(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REFIID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iid,&nbsp;&nbsp; // Usually IX500Name or 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // IPersistMemBlob.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [out, iid_is(iid),retval] void** ppv
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // Set/get the validity period of the certificate.
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; get_Validity(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [out] FILETIME*&nbsp;&nbsp; pftUtcNotBefore,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [out] FILETIME*&nbsp;&nbsp; pftUtcNotAfter
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; put_Validity(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp; FILETIME*&nbsp;&nbsp; pftUtcNotBefore,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp; FILETIME*&nbsp;&nbsp; pftUtcNotAfter
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // A handy helper that sets the start of the validity
 &nbsp;&nbsp;&nbsp; // as 'now' and the end as the indicated number of 
 &nbsp;&nbsp;&nbsp; // months in the future.
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp; put_ValidityDuration(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in] WORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nMonths
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; // A handy helper that answers whether the certificate
 &nbsp;&nbsp;&nbsp; // is valid at the indicated time: S_OK==YES, S_FALSE==NO, or
 &nbsp;&nbsp;&nbsp; // error==can't tell.
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp; IsInValidityPeriod(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [in, unique] FILETIME*&nbsp;&nbsp;&nbsp; pftUtc&nbsp;&nbsp; // If NULL, the current date &amp; time
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // is used.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp;&nbsp;&nbsp; // 
 &nbsp;&nbsp;&nbsp; // A handy helper that returns ALL the names that are available for the
 &nbsp;&nbsp;&nbsp; // parent certificate.
 &nbsp;&nbsp;&nbsp; //
 &nbsp;&nbsp;&nbsp; HRESULT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get_CertificateUsed(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [out,retval] CERTIFICATENAMES*&nbsp;&nbsp;&nbsp; pnames
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
  }
</code></pre>
<h4><a name="iesignix500name"></a>IX500Name </h4>
<p>
This interface is for manipulating an <b>X500Name</b> instance as defined in the X.501 specification.</p>
<pre><code>interface IX500Name : IUnknown {
 &nbsp; ////////////////////////////////////////////////////////////////////////////
 &nbsp; //
 &nbsp; // Simple, common access.
 &nbsp; //
 &nbsp; ////////////////////////////////////////////////////////////////////////////
 &nbsp; // Convert the name to a string form in the standard syntax and return it.
 &nbsp; //
 &nbsp; // Example: "C=US; OU=Microsoft; 1.2.3.4=Some Custom String Attribute; 
 &nbsp; // CN=Joe Howard;"
 &nbsp; //
 &nbsp; HRESULT&nbsp;&nbsp;&nbsp; get_String(
 &nbsp;&nbsp;&nbsp;&nbsp; [out,retval] LPOLESTR*&nbsp;&nbsp;&nbsp; posz
 &nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp; //
 &nbsp; // Set our full name from the indicated string. This cannot be called
 &nbsp; // while any RDN's are outstanding per the above.
 &nbsp; //
 &nbsp; HRESULT&nbsp;&nbsp;&nbsp; put_String(
 &nbsp;&nbsp;&nbsp;&nbsp; [in] LPCOLESTR&nbsp;&nbsp;&nbsp; osz
 &nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp; ////////////////////////////////////////////////////////////////////////////
 &nbsp; //
 &nbsp; // Full power, less-common access.
 &nbsp; //
 &nbsp; ////////////////////////////////////////////////////////////////////////
 &nbsp; //
 &nbsp; // Return the number of relative distinguished names in the name.
 &nbsp; //
 &nbsp; HRESULT&nbsp;&nbsp;&nbsp; get_RelativeDistinguishedNameCount(
 &nbsp;&nbsp;&nbsp;&nbsp; [out,retval] LONG*&nbsp;&nbsp;&nbsp; pcrdn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Place to return count.
 &nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp; //
 &nbsp; // Return an accessor to the irdn'th (zero-origin) relative distinguished 
 &nbsp; // name.
 &nbsp; //
 &nbsp; HRESULT&nbsp;&nbsp;&nbsp; get_RelativeDistinguishedName(
 &nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp; LONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; irdn,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Zero-origin index of relative name.
 &nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp; REFIID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iid,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // iid sought, usually
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ISelectedAttributes.
 &nbsp;&nbsp;&nbsp;&nbsp; [out, iid_is(iid),retval] void**&nbsp;&nbsp; ppv
 &nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp; //
 &nbsp; // Create a new RelativeDistinguishedName at the end of the list
 &nbsp; // and return access to it.
 &nbsp; //
 &nbsp; HRESULT&nbsp;&nbsp;&nbsp; create_RelativeDistinguishedName(
 &nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp; LONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; irdnBefore,&nbsp;&nbsp; // Create before this; -1 means end.
 &nbsp;&nbsp;&nbsp;&nbsp; [in]&nbsp; REFIID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iid,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // iid sought, usually 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ISelectedAttributes.
 &nbsp;&nbsp;&nbsp;&nbsp; [out, iid_is(iid),retval] void**&nbsp;&nbsp;&nbsp; ppv
 &nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp; //
 &nbsp; // Remove a particular RDN. This cannot be called while any RDNs are 
 &nbsp; // outstanding.
 &nbsp; //
 &nbsp; HRESULT&nbsp;&nbsp;&nbsp; remove_RelativeDistinguishedName(
 &nbsp;&nbsp;&nbsp;&nbsp; [in] LONG irdn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // zero-origin index of name to remove.
 &nbsp;&nbsp;&nbsp;&nbsp; );
 &nbsp; //
 &nbsp; // Copy this name into another. We, of course, replace 
 &nbsp; // the contents of the destination name entirely.
 &nbsp; //
 &nbsp; HRESULT&nbsp;&nbsp;&nbsp; CopyTo(
 &nbsp;&nbsp;&nbsp;&nbsp; [in,unique] IX500Name* pname&nbsp;&nbsp; // Name to copy into.
 &nbsp;&nbsp;&nbsp;&nbsp; );
}
</code></pre>
</BODY>
</HTML>
