<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Multibyte Character Set (MBCS) Survival Guide</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_mbcssg"></a>Multibyte Character Set (MBCS) Survival Guide</h1>
<p>
Chau Vu, Seiichi Satoh, and Matt Grove<br>
Microsoft Visual C++ Business Unit</p>
<p>
August 1995</p>
<h2>1. Introduction</h2>
<p>
Most of the information detailed here is from past experience within the Microsoft® Visual C++® business unit (VCBU), and it's very much geared toward multibyte character set (MBCS) for the Far East platforms (specifically Japan). Think of it as a guide/reference document instead of depending on it as a "how to" cook book.</p>
<p>
Some parts of this document were written by Seiichi Satoh and Matt Grove, which I found very useful to include. Seiichi Satoh's original document was intended as a double-byte character set (DBCS) enabling spec. It is very specific to the Japanese platform but should be applicable to other Far East operating systems as well. Matt Grove's original document was intended to show how to write "internationally aware" code using the TCHAR.H header file. Using this header file and the techniques described in this document, code can be conditionally compiled to:
<ul type=disc>
<li>
ANSI (U.S., Europe)<br><br></li>
<li>
DBCS (Japanese, Chinese, Korean)<p class=tl>
Actually, the DBCS libraries currently only handle Japanese. However, the techniques described in this document for DBCS should apply to Chinese and Korean as well.</P></li>
<li>
UNICODE™</li>
</ul>
<p>
It is assumed that the reader has some familiarity with the concepts of DBCS.</p>
<h2>2. Considerations</h2>
<p>
Most traditional C and C++ code makes a number of assumptions about character and string manipulation, which don't work very well (or at all!) for users outside the U.S. This section provides a brief overview of some of the problems involved in writing truly international code.</p>
<h3>2.1. European Languages (the signed char bugaboo)</h3>
<p>
Our European users use the "U.S." (ANSI-compiled) versions of our products. If the market is big enough, we may translate a given product into (for example) German, but only the strings and resources are translated—the code is still the "U.S." version. Users of our product in smaller countries must use the U.S. version directly, complete with English strings.</p>
<p>
The only real problem with writing code that our European users can use is that many characters in the European languages have values &gt;=0x80. In particular, the "funny" characters such as ß, ç, å, ä, and so on all have values &gt;=0x80. European users want to use these characters in their code comments, and in filenames (and potentially in other places where the user is allowed to name something). Since we use mostly signed characters in our code (the char type is signed by default), these characters will get sign-extended when converting to ints.</p>
<p>
For example, the following code may behave quite differently from what you expect:</p>
<pre><code>int&nbsp;&nbsp; some_table[256];

int some_func(void)
{
 &nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; ch;
 &nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; i;

 &nbsp;&nbsp; // ch acquires some value here

 &nbsp;&nbsp; i = some_table[ch];
}
</code></pre>
<p>
The problem with this code is that array indexing is always done with <code>int</code>s. While <code>ch &lt;= 0x7F</code>, this code does what's expected (indexing into <code>some_table</code>). But if <code>ch &gt;= 0x80</code>, <code>ch</code> gets sign-extended and becomes a negative <code>int</code>! The above code will index prior to the start of the array in memory if <code>ch &gt;= 0x80</code>. This is likely to cause a GP fault or index into some random data.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Beware of sign extension. Beware of code that may explicitly or implicitly be 'promoting' a <code>char</code> to an <code>int</code>, since the <code>char</code> may be sign-extended and become a negative-valued <code>int</code>.</p>
<h3>2.2. Japanese, Chinese, and Korean Languages (DBCS)</h3>
<p>
These languages all use DBCS (double-byte character set, sometimes referred to as MBCS, or multibyte character set). In DBCS, a 'character' as the user thinks of it may be one or two bytes. There are two main problems when writing code for DBCS:
<ul type=disc>
<li>
A pointer to a <code>char</code> must never point in the middle of a double-byte character. This is a recipe for disaster. All code must use special mechanisms to 'walk' a character string in order to ensure that it is never pointing to the 'trail' byte of a double-byte character.<br><br></li>
<li>
In general, you can't keep 'characters' in data, nor can you pass them to functions. This is because the size of a character (1 byte or 2 bytes?) isn't known at compile time. Instead, you must pass a pointer to the character (which is presumably in the middle of a string somewhere), and the recipient can access the character appropriately.</li>
</ul>
<p>
Most of the techniques described in this document are specific to Japanese, but they are also applicable to Chinese (China and Taiwan Region) and Korean.</p>
<p>
In the Japanese language, there are four alphabets:
<ul type=disc>
<li>
Kanji—ideograms—meaning not related to pronunciation<br><br></li>
<li>
Hiragana—phonetic—used for Japanese words<br><br></li>
<li>
Katakana—phonetic—used for foreign words<br><br></li>
<li>
Romaji—Latin letters</li>
</ul>
<h3>2.3. UNICODE (all languages)</h3>
<p>
UNICODE really solves the problems described in the previous two subsections. In UNICODE, all characters are uniformly 16 bits. This solves the <code>char -&gt; int</code> promotion problem AND the DBCS problem. Unfortunately, the world isn't quite ready for UNICODE yet.</p>
<p>
When writing UNICODE code, the only real difference is that you can't use the C/C++ <code>char</code> type when you are dealing with 'real' characters (it's OK to use the <code>char</code> type if you are dealing with bytes). Instead, both the C and C++ languages define the <code>wchar_t</code> type, which is a 16-bit character.</p>
<h2>3. Input Method Editor (IME)</h2>
<p>
IMEs are applets that allow users to enter the thousands of different characters used in Far East written languages with a standard 101-key keyboard. The basic things you need to know about the IME are its status window and the conversion window.</p>
<h3>3.1. Windows 95/J IME</h3>
<p>
To type some Japanese characters into an edit field, first activate the IME status (sometimes called IME control panel), then select an IME mode (for example, double-byte Katakana) and start typing Japanese phonetically, like "iruka" for "dolphin." Or, if you don't know Japanese, use those brand names that you are familiar with, such as "toyota," "yamaha," "suzuki," and so on.</p>
<p>
<b><img src="mbcssg_1.gif" border=0></b></p>
<p>
<img src="mbcssg_2.gif" border=0></p>
<h3>3.2. Windows NT/J IME</h3>
<p>
<img src="mbcssg_3.gif" border=0></p>
<p>
<img src="mbcssg_4.gif" border=0></p>
<h3>3.3. IME support</h3>
<p>
There are three levels of IME support:
<ul type=disc>
<li>
IME-unaware—app that handles DBCS only<br><br></li>
<li>
IME-halfaware—app that handles DBCS and some IME messages<br><br></li>
<li>
IME-fullaware—app that handles DBCS and fully supports all IME messages</li>
</ul>
<p>
Visual C++ IDE is an IME-halfaware app. The IDE is fully DBCS-enabled, and it basically handles the IME conversion window correctly for the following situations: focus change, font change, window move, and window resize.</p>
<h2>4. Double-Byte Character Table</h2>
<p>
To distinguish DBC from SBC, the code area that is except for SBC characters is used as leading byte character so that applications can recognize that it is a DBC. In Japan, the code area of the trailing byte character partly overlaps. (In Korea, both of leading byte and trailing byte don't overlap with SBC.) The following is a Japanese DBC (Shift JIS) table.</p>
<h3>4.1. Leading Byte (shaded part)</h3>
<p>
<img src="mbcssg_5.gif" border=0></p>
<h3>4.2. Trailing Byte (shaded part)</h3>
<p>
<img src="mbcssg_6.gif" border=0></p>
<p class=label>
<b>Lead Byte Ranges. Each code page may have different lead byte ranges.</b></p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td width=30%>Japan</td>
<td width=20%>932</td>
<td width=50%>0x81-0x9F</td>
</tr>
<tr valign=top>
<td width=30%>Korea</td>
<td width=20%>949</td>
<td width=50%>0xA1-0xFE</td>
</tr>
<tr valign=top>
<td width=30%>China</td>
<td width=20%>936</td>
<td width=50%>0xA1-0xFE</td>
</tr>
<tr valign=top>
<td width=30%>Taiwan Region</td>
<td width=20%>950</td>
<td width=50%>0xA1-0xFE, 0x8E-0xA0, 0x81-0x8D</td>
</tr>
</table><br>
<h2>5. Scanning Characters</h2>
<p>
Basically, an application can recognize 2-byte data in a string as DBC by scanning from the top of the string toward the end. If a string consists of DBC only, it's obvious that even bytes are leading bytes and odd bytes are trailing bytes. But in almost all cases, a string contains both DBC and SBC. In short, if a byte data that is pointed by a pointer has an SBC code, it isn't always an SBC itself.</p>
<p>
Example:</p>
<p>
<img src="mbcssg_7.gif" border=0></p>
<h3>5.1. Issues of DBC</h3>
<p>
As I described above, SBC code in a string isn't always SBC itself. Then the following issues occur. But these issues are not always caused by DBCS but caused by Japanese DBCS system (Shift JIS). In Korea, these issues may not occur.</p>
<h4>5.1.1. Toupper, tolower</h4>
<p>
Applications must make sure an SBC code in a string is either SBC itself or not. Otherwise, some DBC may convert to another character.</p>
<h4>5.1.2. Backslash</h4>
<p>
Unfortunately, backslash code (5Ch) is used as a trailing byte of DBC in some characters (see table in section 1.2). When applications manipulate a string text of filename, applications must make sure a backslash code in a string text is either a real backslash or a trailing byte of DBC.</p>
<h2>6. Multiline Edit Control</h2>
<p>
The following is an overview of DBCS enabling for multiline text control.</p>
<h3>6.1. Horizontal Caret Movement</h3>
<p>
Caret (edit position on a line) must always be on the border between characters.</p>
<p>
<img src="mbcssg_8.gif" border=0></p>
<h3>6.2. Vertical Caret Movement</h3>
<p>
<i>Comments (MasaT):</i></p>
<p>
<i>This section is not applied to IDE because IDE supports non-fixed-pitch fonts. However the idea that we locate the caret only between the characters is true for us.</i></p>
<p>
See the following figure.</p>
<p>
<img src="mbcssg_9.gif" border=0></p>
<h3>6.3. Delete, Backspace</h3>
<p>
Deleting by delete key and deleting by backspace key must be carried out by each character.</p>
<p>
<img src="mbcssg_10.gif" border=0></p>
<p class=label>
<b>[SBC] on left; [DBC] on right</b></p>
<p>
<img src="mbcssg_11.gif" border=0></p>
<p class=label>
<b>[SBC] on left; [DBC] on right</b></p>
<h3>6.4. Character Overstrike</h3>
<p>
<img src="mbcssg_12.gif" border=0></p>
<p class=label>
<b>Left: [replace SBC with DBC]; right: [replace DBC with SBC]</b></p>
<h3>6.5. Horizontal Scroll</h3>
<p>
<i>Comments (MasaT):</i></p>
<p>
<i>This section is not applied to IDE because of IDE's spec.</i></p>
<p>
If the leftmost character of a displayed line is a trailing byte data, it must be replaced with space (20H).</p>
<p>
<img src="mbcssg_13.gif" border=0></p>
<h3>6.6. Selecting Text by Mouse Dragging or Keyboard</h3>
<p>
<i>Comments (MasaT):</i></p>
<p>
<i>The key is handling the selection by character.</i></p>
<p>
Characters in a text line must be selected by each character.</p>
<p>
<img src="mbcssg_14.gif" border=0></p>
<h3>6.7. Cursor Shape of Overstrike Mode</h3>
<p>
<i>Comments (MasaT):</i></p>
<p>
<i>This section is not applied to IDE because of IDE's spec. We don't change the cursor shape.</i></p>
<p>
Cursor shape must be changed by the character type.</p>
<p>
<img src="mbcssg_15.gif" border=0></p>
<h3>6.8. Selection of Text by Mouse Double-Click</h3>
<p>
<i>Comments (MasaT):</i></p>
<p>
<i>This section is not applied to IDE because of IDE's spec. See IDE DBCS spec for word detection.</i></p>
<p>
The limit of selection is the following. But this spec cannot apply to all product.</p>
<p>
<img src="mbcssg_16.gif" border=0></p>
<h2>7. TCHAR.H</h2>
<p>
The TCHAR.H header file is intended to help solve some of these problems.</p>
<p>
TCHAR.H is an official part of the Windows NT™ Software Development Kit (SDK) header files. As originally defined (by VCBU and picked up by the Windows NT group), it included support for ANSI and UNICODE only. VCBU has extended this file to include support for DBCS (double-byte character set, also sometimes known as MBCS, or multibyte character set). The extended file will ship with Ikura, and represents VCBU's recommended solution for targeting ANSI, DBCS, and UNICODE. Windows NT may at some point pick up the extended file as their "official" header. This document describes the extended version of this file, which the Dolphin project is currently using.</p>
<h3>7.1. Conditional Compilation Symbols</h3>
<p>
TCHAR.H uses two compiler preprocessor symbols to determine how it behaves:</p>
<pre><code>_UNICODE
_MBCS
</code></pre>
<p>
If neither symbol is defined, ANSI (U.S., Europe) is assumed. If <code>_UNICODE</code> is defined, the code will be compiled for UNICODE; if <code>_MBCS</code> is defined, the code will be compiled for DBCS (MBCS). The behavior if both symbols are defined is undefined.</p>
<pre><code>#ifdef _UNICODE
// UNICODE specific code
#endif

#ifdef _MBCS
// DBCS specific code
#endif

#if !defined(_UNICODE) &amp;&amp; !defined(_MBCS)
// ANSI (single byte) specific code
#endif

// *** NON-SPECIFIC CODE ***
//
// Code not under any #ifs or #ifdefs is NOT specific
// to ANY configuration! It must work for all three!
</code></pre>
<p>
All code should use these same symbols for consistency. Additionally, code that is Kanji (Japanese) specific should be <code>#ifdef</code>'d with the <code>KANJI</code> symbol. Whenever possible, however, code should be written to handle generic DBCS issues, rather than being Kanji specific.</p>
<h2>8. The TCHAR Data Type</h2>
<p>
TCHAR.H defines a new data type, the <code>TCHAR</code> type. (For ANSI conformance, the "official" type is <code>_TCHAR</code>. In practice, either <code>TCHAR</code> or <code>_TCHAR</code> is acceptable.) The exact underlying type that a <code>TCHAR</code> maps to depends on the setting of the <code>_UNICODE</code> and <code>_MBCS</code> symbols:</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=27%><b>Code compiled for</b></td>
<td class=label width=27%><b>Actual type of TCHAR</b></td>
<td class=label width=46%><b>Size of TCHAR data type, in bytes</b></td>
</tr>
<tr valign=top>
<td width=27%>ANSI</td>
<td width=27%><code>char</code></td>
<td width=46%>1</td>
</tr>
<tr valign=top>
<td width=27%>_MBCS</td>
<td width=27%><code>char</code></td>
<td width=46%>1</td>
</tr>
<tr valign=top>
<td width=27%>_UNICODE</td>
<td width=27%><code>wchar_t</code></td>
<td width=46%>2</td>
</tr>
</table><br>
<p>
Generally speaking, you should not make any assumptions about the size of a <code>TCHAR</code>. You may have sections of code that are specific to ANSI, DBCS, or UNICODE, and assumptions about the size of a <code>TCHAR</code> are acceptable in those sections. Such specific sections of code are not usually necessary, though.</p>
<h3>8.1. Why Use TCHARs?</h3>
<p>
<code>TCHAR</code>s don't actually help with DBCS programming at all—if the code is compiled for DBCS, a <code>TCHAR</code> is really just a <code>char</code>, as it is if the code is compiled for ANSI. Where <code>TCHAR</code>s help is with UNICODE.</p>
<p>
In code compiled for UNICODE, a <code>TCHAR</code> is actually a <code>wchar_t</code>, which is a 16-bit character. In UNICODE, all characters are uniformly 16 bits (two bytes). If the <code>TCHAR</code> type is used consistently in place of the <code>char</code> type, the code will work properly if compiled for UNICODE. Array indexing and pointer arithmetic, for example, is handled automatically by the compiler. Thus, the following code fragments work fine for both ANSI and UNICODE:</p>
<pre><code>TCHAR * pch;

while (*pch == _T(' '))&nbsp;&nbsp; // See section 8.2 for definition of _T macro
 &nbsp; ++pch;

TCHAR rgch[80];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Declare an array of 80 TCHARs--actually
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 160 bytes if compiling for UNICODE

rgchSave[ich] = rgch[ich];

TCHAR * sz1, * sz2;

while (*sz1++ = *sz2++)
 &nbsp; ;
</code></pre>
<p>
In fact, most such string manipulation works fine for both ANSI and UNICODE as long as you use <code>TCHAR</code>s instead of <code>char</code>s.</p>
<h3>8.2. The _T and _TEXT Macros</h3>
<p>
One problem that arises trying to write code that works for both ANSI and UNICODE is the problem of character and string literals. In the C and C++ languages, the character literal <code>'A'</code> has type <code>int</code>. (Strange but true. ANSI says that <code>'A'</code>, which might appear to be of type <code>char</code>, is actually of type <code>int</code>. The value of the constant <code>'A'</code> depends on whether the <code>char</code> type is <code>signed</code> or <code>unsigned</code>. If it is <code>signed</code>, the value is the value of the character sign-extended to 16 bits. If it is <code>unsigned</code>, the 16-bit value will have a "high byte" value of 0. In particular, if <code>char</code>s are <code>signed</code>, then the expression <code>'\xFF' == (int)-1</code> is true, and if chars are unsigned, then <code>'\xFF' == (int)0xFF</code> is true instead.) Likewise, the string literal <code>"string"</code> defines a nul-terminated array of <code>char</code>s. To declare a wide character character literal or a wide character string literal, you must use the <code>L</code> prefix, as in <code>L'A'</code> or <code>L"string"</code> (this is a language feature defined by both the C and C++ languages). The <code>L</code> prefix indicates that the character literal is of type <code>wchar_t</code>, and the string literal is an array of <code>wchar_t</code>s (including a wide character nul terminator). To avoid having to write code such as this:</p>
<pre><code>TCHAR * pch;

#ifdef _UNICODE
if (*pch == L'A')
#else
if (*pch == 'A')
#endif
</code></pre>
<p>
TCHAR.H defines the <code>_T</code> and <code>_TEXT macros</code>. These macros are identical; either one can be used. The remainder of this document will use the <code>_T</code> macro.</p>
<p>
The <code>_T</code> macro takes a 'normal' character literal or 'normal' string literal as its argument and prepends the <code>L</code> prefix if compiling for UNICODE. Thus, the following code fragments work for both ANSI and UNICODE:</p>
<pre><code>TCHAR * pch;

if (*pch == _T('A'))
 &nbsp; DoSomething();

pch = _T("hello");

ASSERT(pch[0] == _T('h'));
ASSERT(pch[1] == _T('e'));
ASSERT(pch[2] == _T('l'));
// etc.
</code></pre>
<p>
If you are comparing character literals or string literals against <code>TCHAR</code>s or <code>(TCHAR *)</code>s, or are performing assignments between character literals or string literals and <code>TCHAR</code>s or <code>(TCHAR *)</code>s, you must use the <code>_T</code> macro to define the character literals and string literals.</p>
<h3>8.3. So What About DBCS?</h3>
<p>
Subsections 4.1 and 4.2 showed how using <code>TCHAR</code>s allows you to write code that will work properly for either ANSI or UNICODE. So how do they help with writing code that works correctly when compiled for DBCS? Well, they don't, really. <code>TCHAR</code>s <i>do</i> succeed in "hiding" some of the UNICODE issues. Since the goal as stated in section 1 is to write code that will successfully work for ANSI, DBCS, <i>and</i> UNICODE, <code>TCHAR</code>s are an important part of the system.</p>
<p>
As noted earlier, <code>TCHAR</code>s are really just <code>char</code>s when the code is compiled for DBCS. This means that all the usual DBCS problems are still present. Fortunately, however, the extended TCHAR.H defines various macros that work with all three environments—ANSI, DBCS, and UNICODE—if you use the <code>TCHAR</code> data type.</p>
<h3>8.4. The _tcsinc and _tcsdec Macros</h3>
<p>
One of the most important things to remember when coding for DBCS is that you can't simply increment a character pointer, since it could be pointing to a one-byte <i>or</i> a two-byte character. Using <code>TCHAR</code>s doesn't automatically help here, since a <code>TCHAR</code> is just a <code>char</code> when compiling for DBCS. So TCHAR.H provides two important macros to handle incrementing and decrementing character pointers:</p>
<pre><code>pchNext = _tcsinc(pchCur);
pchPrev = _tcsdec(pchStart, pchCur);
</code></pre>
<p>
Note that the <code>_tcsdec</code> macro requires a pointer to the start of the string as well as the pointer that is to be decremented. This is because in the DBCS case, backing up a character may require backing up all the way to the start of the string to "synchronize" the pointer with a known 'good' character boundary (that is, a byte that is known not to point to the second byte of a double-byte character). In actuality, the first argument to <code>_tcsdec</code> can be a pointer to any known 'good' character boundary inside the string that lies prior to the other pointer argument passed in (that is, <code>pchStart &lt; pchCur</code>).</p>
<p>
If you have a pointer to a character that is of unknown size, you <i>must</i> use the <code>_tcsinc</code> and <code>_tcsdec</code> macros to work properly in a DBCS environment.</p>
<p>
There are cases where you can safely increment a <code>TCHAR</code> pointer or a <code>TCHAR</code> index—if you have sufficient knowledge that the characters that make up the string are not double-byte characters in DBCS, then you don't need to use <code>_tcsinc</code> and <code>_tcsdec</code>. For example, if you are dealing with a string that is known to be a C or C++ language identifier, then that string should not contain any double-byte characters in DBCS. It is also true that if you are pointing to a character that is known not to be a double-byte character in DBCS, you need not use <code>_tcsinc</code>:</p>
<pre><code>TCHAR * pch;

while (*pch == _T(' '))
 &nbsp; ++pch;
</code></pre>
<p>
Beware of making the same assumption about <code>_tcsdec</code>, though—it is only safe to decrement a <code>TCHAR</code> pointer or index if the character <i>previous</i> to the current one is known to be a single-byte character in DBCS.</p>
<p>
In general, the "better safe than sorry" rule applies. The <code>_tcsinc</code> and <code>_tcsdec</code> macros are actually just inline functions for the ANSI and UNICODE cases, since they don't need to do anything special (assuming the 'character pointer' arguments are of type <code>(TCHAR *)</code> and not <code>(char *)</code>). So there shouldn't be any loss of efficiency from using these macros and compiling for ANSI or UNICODE.</p>
<h2>9. C Run-Time Library Functions</h2>
<p>
Section 4 described the <code>TCHAR</code> data type, and various macros that help to write code that can be conditionally compiled to work with ANSI, DBCS, and UNICODE. So far, however, any discussion of the various C run-time library functions, such as <code>strlen</code>, <code>strcpy</code>, <code>strchr</code>, and so forth, has been absent. So an interesting question arises:</p>
<p>
What exactly does <code>strlen(szSomeString)</code> return? Does it return:
<ul type=disc>
<li>
The length in bytes?<br><br></li>
<li>
The length in <code>TCHAR</code>s?<br><br></li>
<li>
Something else?</li>
</ul>
<p>
The answer is that <code>strlen</code> always returns the length in bytes of the string passed in. In fact, it is true of all the <code>strxxx</code> functions that they 'think' only in bytes and single byte nul-terminated strings.</p>
<p>
Calling <code>strlen</code> on a UNICODE string is likely to be quite disastrous. The character <code>L'A'</code> in UNICODE has the value <code>0x0061</code>. Calling <code>strlen</code> on the string <code>L"ABCDE"</code> will thus return either zero or one, depending on how the CPU arranges 16-bit quantities (80x86 CPUs will store <code>0x0061</code> in memory as <code>0x61</code> <code>0x00</code>, so <code>strlen()</code> will return 1 in that case).</p>
<p>
In general, the <code>strxxx</code> routines can be disastrous, since UNICODE strings are quite likely to contain embedded nul bytes.</p>
<p>
Calling <code>strlen</code> on a DBCS string works fine—it returns the length of the string in bytes. In the DBCS system, a single nul byte indicates the end of a string, and it is guaranteed that the second (trail) byte of a double-byte character will never be zero.</p>
<p>
ANSI defines a set of <code>wcsxxx</code> functions that work in UNICODE. (Our run-time libraries have extended this notion to encompass non-standard string functions. For example, Microsoft defines the string function <code>_stricmp</code> and the UNICODE equivalent <code>_wcsicmp</code>.) They are analogous to the <code>strxxx</code> functions, except that they 'think' in <code>wchar_t</code>s instead of in bytes. Thus, <code>wcslen</code> returns the length of its string argument (a string composed of <code>wchar_t</code>s!) as a count of <code>wchar_t</code>s. To find the length of a wide character string in bytes, you must multiply by <code>sizeof(wchar_t)</code>.</p>
<p>
So how do we find the length of a string in bytes in a way that works for U.S., DBCS, and UNICODE? Here's one solution:</p>
<pre><code>TCHAR * sz;

#ifdef _UNICODE
cb = wcslen(sz) * sizeof(TCHAR);&nbsp;&nbsp; // Can't call strlen() on a wide char string!
#else
cb = strlen(sz);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // strlen() works fine for U.S. and DBCS
#endif
</code></pre>
<p>
Fortunately, TCHAR.H provides a better method. In the same way that ANSI defined a set of <code>wcsxxx</code> functions that 'think' in wide characters (<code>wchar_t</code>s), TCHAR.H defines a set of <code>_tcsxxx</code> functions that 'think' in <code>TCHAR</code>s. Thus, <code>_tcslen</code> returns the length of a string in <code>TCHAR</code>s, and the code above can be rewritten as simply:</p>
<pre><code>TCHAR * sz;

cb = _tcslen(sz) * sizeof(TCHAR);
</code></pre>
<p>
All <code>_tcsxxx</code> functions work with <code>TCHAR</code>s. (This isn't actually quite true. Most <code>_tcsxxx</code> functions behave this way. There are a few exceptions, but they have non-standard names. For example, <code>_tcsclen</code> returns the length of its argument string in <i>logical characters.</i> It is, however, true that every <code>_tcsxxx</code> function that is a direct analogue of a <code>strxxx</code> function will behave as described in the box.) Arguments and return values are <code>TCHAR</code>s, <code>(TCHAR *)</code>s, counts of <code>TCHAR</code>s, or indices into arrays of <code>TCHAR</code>s.</p>
<p>
Thus, <code>_tcsspn</code> returns a <code>TCHAR</code> index into the string argument, <code>_tcsncpy</code> copies up to 'n' <code>TCHAR</code>s, and so forth.</p>
<p>
Generally speaking, the <code>_tcsxxx</code> macros map to either <code>strxxx</code>, <code>_mbsxxx</code>, or <code>wcsxxx</code>. The <code>_mbsxxx</code> are analogues of the <code>strxxx</code> functions that handle DBCS strings. (This is not always true. For historical reasons, <code>_mbslen</code> returns the length of its argument in <i>logical characters</i>. A logical character is a character as the user thinks of it—as a component of a word or other piece of text, and as something that has a single visual representation on the screen. In the DBCS system, a logical character is one or two bytes, while a <code>TCHAR</code> is always one byte. If &alpha;, &beta;, and &delta; are double-byte characters, then the string "&alpha;&beta;XYZ&delta;" contains 9 bytes [and thus 9 <code>TCHAR</code>s], but only 6 logical characters. Calling <code>_mbslen</code> on that string would return 6. As a result, <code>_tcslen</code> maps to <code>_wcslen</code> for the UNICODE case, but <code>strlen</code> for both U.S. and DBCS, and thus correctly returns the length of the string in <code>TCHAR</code>s. <i>Some</i> other <code>_mbsxxx</code> functions behave this way [returning counts of logical characters, or logical character indices, or taking such values as parameters], while others don't. In any event, the <code>_tcsxxx</code> functions take this into account and map to alternate functions when this would present a problem. The <code>_tcsxxx</code> functions always deal only with <code>TCHAR</code>s and <code>TCHAR</code> counts or indices.)</p>
<p>
See section 7 for examples of how to use the <code>_tcsxxx</code> functions.</p>
<h2>10. CString</h2>
<p>
A "<code>TCHAR</code> enabled" version of the Microsoft Foundation Class Library (MFC) is available since Visual C++ 2.0. All appropriate MFC methods and functions will change from accepting or returning <code>(char *)</code>s to accepting or returning <code>(TCHAR *)</code>s. All methods of the <code>CString</code> object will observe this behavior. For example, <code>CString::GetLength</code> will return the length of the string in <code>TCHAR</code>s. Likewise, <code>CString::Left</code> will return the leftmost N <code>TCHAR</code>s of the string.</p>
<h2>11. Code Samples</h2>
<p>
This section provides tables of common actions, and the proper code for those actions. Unless otherwise noted, all strings are of type <code>TCHAR *</code>, all characters are of type <code>TCHAR</code>, and all character indices are <code>TCHAR</code> indices.</p>
<table border=1 cellpadding=5 cols=4 frame=below rules=rows>
<tr valign=top>
<td class=label width=16%><b>Action</b></td>
<td class=label width=34%><b>Non-CString code</b></td>
<td class=label width=33%><b>CString code</b></td>
<td class=label width=17%><b>Comments</b></td>
</tr>
<tr valign=top>
<td width=16%>Find the length of a string in bytes</td>
<td width=34%><code>cb = _tcslen(sz) * <br>
  sizeof(TCHAR);</code></td>
<td width=33%><code>cb = string.GetLength() * <br>
  sizeof(TCHAR);</code></td>
<td width=17%>strlen is dangerous when used on UNICODE strings</td>
</tr>
<tr valign=top>
<td width=16%>Find the number of bytes required for a buffer to copy a string into</td>
<td width=34%><code>cb = _tcslen(sz) * <br>
  sizeof(TCHAR) + <br>
  sizeof(TCHAR);</code></td>
<td width=33%><code>cb = string.GetLength() * <br>
  sizeof(TCHAR) + <br>
  sizeof(TCHAR);</code></td>
<td width=17%>strlen is dangerous when used on UNICODE strings</td>
</tr>
<tr valign=top>
<td width=16%>Copy a string</td>
<td width=34%><code>_tcscpy(szDst, szSrc);</code></td>
<td width=33%><code>stringDst = stringSrc;</code></td>
<td width=17%>strcpy is dangerous when used on UNICODE strings</td>
</tr>
<tr valign=top>
<td width=16%>Increment a TCHAR pointer</td>
<td width=34%><code>pch = _tcsinc(pch);</code></td>
<td width=33%>// not applicable</td>
<td width=17%>Handles DBCS case</td>
</tr>
<tr valign=top>
<td width=16%>Decrement a TCHAR pointer</td>
<td width=34%><code>pch = _tcsdec(pchStart, <br>
  pch);</code></td>
<td width=33%>// not applicable</td>
<td width=17%>Handles DBCS case</td>
</tr>
<tr valign=top>
<td width=16%>Obtain a TCHAR pointer to the last "logical character" of a string</td>
<td width=34%><code>pch = _tcsdec(pchStart, <br>
  pchStart + <br>
  _tcslen(pchStart));</code></td>
<td width=33%>// not applicable</td>
<td width=17%>Technique is to find pointer to nul terminator, then decrement pointer</td>
</tr>
<tr valign=top>
<td width=16%>Compare the TCHAR pointed to against a character constant</td>
<td width=34%><code>if (*pch == _T('A'))<br>
  HaveMatch();</code></td>
<td width=33%>// not applicable</td>
<td width=17%>Use _T macro!</td>
</tr>
<tr valign=top>
<td width=16%>Skip leading spaces in a string</td>
<td width=34%><code>while (*pch == _T(' '))<br>
  ++pch;</code></td>
<td width=33%>// not applicable</td>
<td width=17%>++pch is OK since character being skipped is known to not be a double byte character</td>
</tr>
<tr valign=top>
<td width=16%>Find the first occurrence of the character '&amp;' in a string</td>
<td width=34%><code>pch = _tcschr(sz, <br>
  _T('&amp;'));</code></td>
<td width=33%><code>ich = string.Find(_T('&amp;'));</code></td>
<td width=17%>For CString case, ich returned is TCHAR index</td>
</tr>
<tr valign=top>
<td width=16%>Find the last occurrence of the character '&amp;' in a string</td>
<td width=34%><code>pch = _tcsrchr(sz, <br>
  _T('&amp;'));</code></td>
<td width=33%><code>ich = string.ReverseFind(_T('&amp;'));</code></td>
<td width=17%>For CString case, ich returned is TCHAR index</td>
</tr>
<tr valign=top>
<td width=16%>Walk a string, examining each character</td>
<td width=34%><code>while (*pch != _T('\0'))<br>
{<br>
  ExamineChar(pch);<br>
  pch = _tcsinc(pch);<br>
}</code></td>
<td width=33%><code>ich = 0;<br>
while (string[ich] != <br>
  _T('\0'))<br>
{<br>
  ExamineChar((TCHAR *)<br>
 &nbsp;&nbsp; string + ich);<br>
  ich +=<br>
 &nbsp;&nbsp; _tclen((const TCHAR<br>
 &nbsp;&nbsp; *)string + ich);<br>
}</code></td>
<td width=17%>Note that ExamineChar takes a (TCHAR *) parameter rather than a TCHAR parameter. Otherwise, in DBCS, we might be passing the first (lead) byte of a double byte character, which is useless (or worse) to the called function.<br>
<br>
The CString code is complicated; in general, this sort of thing is done better by setting <code>pch = string</code> (using CString's operator const TCHAR * method) and using the non-CString code. Don't do this if you plan to modify the string, though.<br>
<br>
_tclen is a macro defined in TCHAR.H which returns the length of the character pointed to in TCHARs.</td>
</tr>
<tr valign=top>
<td width=16%>Is a character an alphabetic character?</td>
<td width=34%><code>// !! complicated !!</code></td>
<td width=33%><code>// !! complicated !!</code></td>
<td width=17%>This is quite complicated to get right. In general, AVOID using the isxxx and toxxx routines such as isalpha, isupper, toupper, etc. There are _istxxx definitions in TCHAR.H, but there are hidden traps for the unwary.</td>
</tr>
<tr valign=top>
<td width=16%>Compare two characters</td>
<td width=34%><code>if (_tccmp(pch1, <br>
  pch2) == 0)<br>
 &nbsp;&nbsp; CharsAreEqual();</code></td>
<td width=33%><code>if (_tccmp(string1 + ich1,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string2 + ich2))<br>
  CharsAreEqual();</code></td>
<td width=17%>The _tccmp macro defined in TCHAR.H compares two characters given (TCHAR *)s.</td>
</tr>
<tr valign=top>
<td width=16%>Make a string uppercase</td>
<td width=34%><code>_tcsupr(szString);</code></td>
<td width=33%><code>string.MakeUpper();</code></td>
<td width=17%>Easy, for once!</td>
</tr>
<tr valign=top>
<td width=16%>Copy a 'source' string into a 'destination' buffer of size cchBuf (count of TCHARs) while there's still space</td>
<td width=34%><code>cchUsed = 0;<br>
--cchBuf; // save room <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // for termin-<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ating nul--<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // need one TCHAR<br>
<br>
while (cchUsed + <br>
  _tclen(*pchSrc)<br>
 &nbsp;&nbsp;&nbsp;&nbsp; &lt; cchBuf)<br>
{<br>
 &nbsp; _tccpy(pchDst, pchSrc);<br>
 &nbsp; cchUsed += <br>
 &nbsp;&nbsp; _tclen(pchSrc);<br>
 &nbsp; pchSrc = _tcsinc(pchSrc);<br>
 &nbsp; pchDst = _tcsinc(pchDst);<br>
}<br>
<br>
*pchDst = _T('\0');</code></td>
<td width=33%>// not applicable</td>
<td width=17%>Note use of _tclen to find the length (in TCHARs) of a character (a DBCS character may be one TCHAR long or two TCHARs long), and use of _tccpy to copy a character (copying a character in DBCS may involve copying one or two TCHARs; _tccpy does the right thing automatically and is cheap for ANSI and UNICODE).</td>
</tr>
<tr valign=top>
<td width=16%>Watch for buffer overflow after the translation</td>
<td width=34%><code>IDS_STRING1&nbsp;&nbsp;&nbsp; "Die <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Datei <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "%1 Kann <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "nicht <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "geoffnet <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "werden"</code><p>
<code>#define cbMaxSz&nbsp;&nbsp;&nbsp; 4095<br>
  // max for win32</code></p>
<p>
<code>TCHAR szString[cbMaxSz];</code></p>
<p>
<code>LoadString(hMod, <br>
  IDS_STRING1, szString, <br>
  cbMaxSz);</code></p>
</td>
<td width=33%>// not applicable</td>
<td width=17%>This is the original code and 25 character buffer is certainly not enough after the translation.<p>
<code>IDS_STRING1&nbsp;&nbsp; "Cannot open file %1"</code></p>
<p>
<code>char szString[25];</code></p>
<p>
<code>LoadString<br>
 (hMod, IDS_STRING1, szString, sizeof<br>
 (szString));</code></p>
</td>
</tr>
<tr valign=top>
<td width=16%>Search for first backslash in path\filename</td>
<td width=34%><code>char * <br>
  GetBackSlash(char *psz)<br>
{<br>
  while (*psz)<br>
  {<br>
 &nbsp;&nbsp; if ( <br>
 &nbsp;&nbsp;&nbsp;&nbsp; !_istleadbyte(*psz) )<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( *psz == <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T('\\') )<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return psz;<br>
 &nbsp;&nbsp; psz = _tcsinc(psz);<br>
  }<br>
  return NULL;<br>
}</code></td>
<td width=33%>// not applicable</td>
<td width=17%>This is just to show how the code is done. In reality, use C run-time <code>_tcschr(psz, T('\\'))</code> to find the first occurrence of a backslash in a string.</td>
</tr>
<tr valign=top>
<td width=16%>Check if a path ends with a backslash (i.e. c:\path\ )</td>
<td width=34%><code>pszTemp = _tcsrchr(psz, <br>
  T('\\'));<br>
if ( pszTemp &amp;&amp; <br>
  (*_tcsinc(pszTemp) <br>
  == T('\0')) )</code></td>
<td width=33%>// not applicable</td>
<td width=17%></td>
</tr>
<tr valign=top>
<td width=16%>Byte indices</td>
<td width=34%><code>while (rgch[i] != '\\')<br>
  i+= _tclen(rgch + i);</code></td>
<td width=33%>// not applicable</td>
<td width=17%>The original code is as shown below and it has the same problems as pointer manipulation.<p>
<code>while <br>
  (rgch[i] <br>
  != '\\')<br>
 &nbsp;&nbsp; i++;</code></p>
</td>
</tr>
<tr valign=top>
<td width=16%>Character assignment</td>
<td width=34%><code>while (*pszSrc)<br>
{<br>
  if (*pszSrc != T('A'))<br>
  {<br>
 &nbsp;&nbsp; _tccpy(pszDest, pszSrc);<br>
 &nbsp;&nbsp; pszDest = <br>
 &nbsp;&nbsp;&nbsp;&nbsp; _tcsinc(pszDest);<br>
  }<br>
  pszSrc = _tcsinc(pszSrc);<br>
}</code></td>
<td width=33%>// not applicable</td>
<td width=17%>The original un-world-wide enabled code looks like this.<p>
<code>while <br>
  (*pszSrc)<br>
{<br>
  if (*pszSrc<br>
 &nbsp;&nbsp; != 'A')<br>
 &nbsp; *pszDest++<br>
 &nbsp; = *pszSrc;<br>
  pszSrc++;<br>
}</code></p>
</td>
</tr>
<tr valign=top>
<td width=16%>Buffer overflow</td>
<td width=34%><code>-------- incorrect ---<br>
while (cb &lt; sizeof(rgch)<br>
{<br>
  _tccpy(rgch + cb, pszSrc);<br>
// may overflow rgch<br>
  cb += _tclen(pszSrc);<br>
  pszSrc = _tcsinc(pszSrc);<br>
}<br>
</code><p>
<code>-------- correct -------<br>
while ( (cb+_tclen(pszSrc) <br>
  &lt;= sizeof(rgch)<br>
{<br>
  _tccpy(rgch + cb, pszSrc);<br>
  cb += _tclen(pszSrc);<br>
  pszSrc = _tcsinc(pszSrc);<br>
}</code></p>
</td>
<td width=33%>// not applicable</td>
<td width=17%>The original un-world-wide enabled code looks like this.<p>
<code>while (cb &lt; <br>
sizeof(rgch))<br>
rgch[cb++] = <br>
  *pszSrc++</code></p>
</td>
</tr>
<tr valign=top>
<td width=16%>Enjoy writing this kind of code</td>
<td width=34%>// not likely</td>
<td width=33%>// not here either</td>
<td width=17%>Try to understand all the issues and remember to THINK.</td>
</tr>
</table><br>
<h2>12. More on TCHAR.H and MBCS</h2>
<p>
The use of TCHAR.H under _MBCS can be confusing.</p>
<p>
The basic problem is that when _MBCS is defined, some of the _tcs*() macros map to _mbs*() functions, which expect "unsigned char *" parameters (_tcschr() -&gt; _mbschr()), while others map to _str*() functions, which expect "char *" parameters (_tcscat() -&gt; strcat). A previous version of TCHAR.H type-cast the macro parameters, leading to type safety problems. Now TCHAR.H supplies type-safe function thunks that map _tcs*() functions to _mbs*() functions. For compilers without inlining, these functions now also exist in the run-time libraries. Also, the old method of mapping (via macro) directly from _tcs*() to _mbs*() still exists, but you must either live with "char * != unsigned char *" warnings (in C at least, C++ will error), type cast the parameters yourself, or use _TXCHAR, which maps to "unsigned char *" in the _MBCS case.</p>
<p>
So to summarize the options using _tcschr as an example:
<ul type=disc>
<li>
(the default) TCHAR.H contains a prototype for _tcschr(). _tcschr simply calls _mbschr at run time. This results in an extra function call.<br><br></li>
<li>
(_USE_INLINING &amp;&amp; !__STDC__) _tcschr is an inline function thunk, simply calls _mbschr. This results in no extra cost if it is indeed inlined.<br><br></li>
<li>
(_MB_MAP_DIRECT) _tcschr is replaced by _mbschr by the preprocessor. User must be responsible for maintaining the types properly by casting or using _TXCHAR. No extra cost.</li>
</ul>
<h2>13. Example of Code Using TCHAR.H</h2>
<p>
The following example is provided courtesy of Chris Weight.</p>
<pre><code>////////////////////// START TCHAR.H EXAMPLE ///////////////////////////

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;direct.h&gt;
#include &lt;errno.h&gt;
#include &lt;tchar.h&gt;


/*
 * Generic program.
 */

int __cdecl _tmain(int argc, _TCHAR **argv, _TCHAR *envp)
{
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _TCHAR buff[_MAX_PATH];
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _TCHAR *str = _T("Astring");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *amsg = "Reversed";
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t *wmsg = L"Is";

#ifdef _UNICODE
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("Unicode version\n");
#else /* _UNICODE */
#ifdef _MBCS
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("MBCS version\n");
#else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("SBCS version\n");
#endif
#endif /* _UNICODE */

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (_tgetcwd(buff, _MAX_PATH) == NULL)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("Can't Get Current Directory - errno=%d\n", errno);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _tprintf(_T("Current Directory is '%s'\n"), buff);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _tprintf(_T("'%s' %hs %ls:\n"), str, amsg, wmsg);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _tprintf(_T("'%s'\n"), _tcsrev(str));

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
}


/*
 * Unicode version.
 */

int __cdecl wmain(int argc, wchar_t **argv, wchar_t *envp)
{
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t buff[_MAX_PATH];
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t *str = L"Astring";
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *amsg = "Reversed";
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t *wmsg = L"Is";

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("Unicode version\n");

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (_wgetcwd(buff, _MAX_PATH) == NULL)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("Can't Get Current Directory - errno=%d\n", errno);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wprintf(L"Current Directory is '%s'\n", buff);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wprintf(L"'%s' %hs %ls:\n", str, amsg, wmsg);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wprintf(L"'%s'\n", wcsrev(str));

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
}


/*
 * SBCS version.
 */

int __cdecl main(int argc, char **argv, char *envp)
{
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char buff[_MAX_PATH];
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *str = "Astring";
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *amsg = "Reversed";
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t *wmsg = L"Is";

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("SBCS version\n");

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (_getcwd(buff, _MAX_PATH) == NULL)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("Can't Get Current Directory - errno=%d\n", errno);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("Current Directory is '%s'\n", buff);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("'%s' %hs %ls:\n", str, amsg, wmsg);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("'%s'\n", strrev(str));

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
}


/*
 * MBCS version.
 */

int __cdecl main(int argc, char **argv, char *envp)
{
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char buff[_MAX_PATH];
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *str = "Astring";
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *amsg = "Reversed";
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t *wmsg = L"Is";

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("MBCS version\n");

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (_getcwd(buff, _MAX_PATH) == NULL)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("Can't Get Current Directory - errno=%d\n", errno);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("Current Directory is '%s'\n", buff);

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("'%s' %hs %ls:\n", str, amsg, wmsg);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("'%s'\n", _mbsrev(str));

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
}

////////////////////// END TCHAR.H EXAMPLE ///////////////////////////
</code></pre>
<h2>14. Tips</h2>
<h3>14.1. Development</h3>
<ul type=disc>
<li>
Don't mix and match Win32® APIs with CRT APIs<p class=tl>
The difference is that Win32 APIs rely on System information, whereas the CRT APIs rely on the user to initialize for the appropriate settings. CRT defaults to ANSI "C" locale.</P><p class=tl>
For example: The following example will fail even if psz really points to a Japanese lead byte and the system is running in a different codepage other than 932.</P><pre><code>// **** undefined behaviour ****
setlocale(LC_ALL, "Japanese");&nbsp; // set run-time to Japanese locale
if (IsDBCSLeadByte(*psz))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // query system locale *** wrong ***
....
// **** correct behaviour ****
if (isleadbyte((_TXCHAR)*psz))&nbsp; // correct locale is used. Also note that 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (_TXCHAR) casting was used to make sure 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // integral conversion is correct
</code></pre>
</li>
<li>
Use appropriate casting<p class=tl>
Some TCHAR functions take <i>int</i> as input. If you pass on a TCHAR and it happens to be in the range of 0x80-0xff, the compiler automatically converts it to <i>sign char</i> first and then to <i>int</i>, and this is wrong. The following example makes sure *psz is converted to <i>unsigned<b> </b>char</i> before becoming an <i>int</i>.</P><pre><code>if (isleadbyte((_TXCHAR)*psz))
</code></pre>
</li>
<li>
Avoid run-time message munging<p class=tl>
The danger is when a string get translated, the order you expected might get switched around and it's disastrous, especially when the format strings aren't the same (that is, %s %i %c get switched to %i %c %s).</P><pre><code>LINETOOLONG_STRING&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "line %i in file '%s' is too long."
translated string becomes&nbsp;&nbsp; "....'%s'........%i...."

szBuffer.LoadString(LINETOOLONG_STRING);
wsprintf(szTmp, szBuffer, i, filename);&nbsp; // the translated string 
 &nbsp;&nbsp;&nbsp;&nbsp; // will end up with address of 'i' being used for&nbsp; %s
</code></pre>
<p class=tl>
There are alternative ways to avoid this problem but none are foolproof. When you absolutely have to do this, make sure to notify the translator clearly on how the message should be translated. Alternative ways can be done using AfxFormatString2(), or structure your message and break it off into smaller, self-contained messages.</P></li>
<li>
Avoid putting non-localize string in the resource table<p class=tl>
We deliver an English product that is DBCS-enabled to an external localization site and have them use a tool to do the translation, then ship back to us the translated EXEs and DLLs. It is very likely that the translators will know nothing about the product, so it's hard for them to know what string should or shouldn't be translated. Therefore, it's absolutely critical for us to move all non-localize strings back into code where they belong.</P></li>
<li>
Font usage<p class=tl>
Generalize the font usage and make sure the right character set is being selected accordingly. Most of the time, DEFAULT_CHARSET should be used or, for specific CharSet, query the system for what's available.</P></li>
<li>
30 percent more width for dialogs and controls<p class=tl>
From experience, adding 30 percent more for the width is sufficient. This addition really helps when running the English version on non-English platforms because most non-English platforms have bigger font size, especially for the Far East ones.</P></li>
<li>
Common dialog and template<p class=tl>
Commdlg is convenient and saves time, but it's sometimes a headache for the localized versions. When you pass your own template to a commdlg call, it's likely that you get inconsistency in size and font between your template controls and commdlg's controls.</P></li>
<li>
Don't reuse resource strings<p class=tl>
Very often the same English word or string being used in different contexts gets translated into different words or strings for some languages. For this reason, always provide one resource string for each item, even though they are the same string.</P><p class=tl>
For example: Japanese UI guide recommends that only SB Katakana and/or Kanji should be used on main menu and in list box. DB Katakana, Kanji, and/or Hiragana should be used in pop-up menu and dialog control.</P></li>
<li>
Don't build string by stripping out characters<p class=tl>
It's not unusual for a programmer to build strings out of existing strings by stripping out certain key words/characters. This should be avoided as much as possible, because you can never guarantee that the same method will work after a string has been translated.</P><p class=tl>
For example: sometimes it's convenient to strip out the '&amp;' character from a menu item to build a string such as "F&amp;ind in files..." to become "Find in files...". For Japanese, the menu item is translated as <code><font face="‚l‚r –¾’©">"</font></code>????????<code><font face="‚l‚r –¾’©">(&amp;I)..."</font></code> and the output becomes "????????<code><font face="‚l‚r –¾’©">(I)...</font></code>", which is wrong</P></li>
<li>
UNICODE -&gt; ANSI != half the size<p class=tl>
Don't assume that this conversion will reduce your buffer size in half, because if there are DB characters in the string, you will overflow the buffer. A safe bet is to keep the buffer size the same as when it was in UNICODE.</P></li>
<li>
"C" locale<p class=tl>
By default, all C/C++ programs operate in the "C" locale as defined by the ANSI/ISO C standard, but beware of other locales.</P><p class=tl>
For example: isalpha() returns TRUE for inputs a-z, A-Z, but in French locale, it also returns TRUE for characters such as é.</P></li>
<li>
Shortcut keys<p class=tl>
Don't use these characters when assigning shortcut keys: @ $ { } [ ] \ ~ | ^ ' &lt; &gt;. These keys are often not available on foreign keyboards or sometimes require more than three simultaneous keystrokes, and are very awkward to type.</P></li>
<li>
Text template in Font dialog<p class=tl>
The text template you are most familiar with in the Font dialog box is "AaBbYyZz". When you use the common font dialog with your own template, make sure you don't change this text template—for different font CharSet, the text is automatically switched to that CharSet. If you use your own text template, it will stay constant no matter what font CharSet is selected.</P></li>
<li>
Upper/Lower<p class=tl>
When converting upper/lower using _toupper/_tolower, don't assume the locale is what you are expecting. If you don't know for sure, use AnsiUpper/AnsiLower instead.</P></li>
<li>
Constants in header files<p class=tl>
Don't define constants that are related to locale in header files. Put them in a resource table and communicate the constants' definitions to the translator.</P><p class=tl>
For example: the definitions below will require a recompile, which is not desirable:</P><pre><code>#define DEFAULT_LEFTMARGIN&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp; // left margin default is 1 inch
#define DEFAULT_RIGHTMARGIN&nbsp;&nbsp; 2&nbsp;&nbsp; // right margin default is 2 inch
</code></pre>
</li>
<li>
Lead byte table<p class=tl>
Avoid hardcoding the lead byte tables in your code. They rarely get changed, but you never know. Use isleadbyte() or IsDBCSLeadByte() instead.</P></li>
<li>
Menu item such as this: "File(\03F\037K)"<p class=tl>
Don't be surprised to see the above menu item. This is the old Win 3.1/J style that we need to keep in mind when parsing the string.</P></li>
<li>
Processing WM_CHAR message<p class=tl>
Don't forget that there will be two messages for every DB character. Always check to see if a lead byte is received, and buffer the characters correctly.</P></li>
<li>
CString<p class=tl>
The MFC CString is MBCS-enabled. Use it.</P></li>
<li>
Dealing with Path/File name<p class=tl>
Make the C run time work for you. Use _tcschr(), _tcsrchr(), _splitpath(), _makepath(), _fullpath(), and so on</P></li>
</ul>
<h3>14.2. Testing</h3>
<ul type=disc>
<li>
Well-known problem with File/Path name on J system<p class=tl>
The best test cases when dealing with file/path name have to do with DB characters with trailing byte being a backslash (\0x5C) or a vertical bar (\0x7C). The best way to generate a DB character like that is to activate the IME control and change it to double-byte Katakana mode (see IME section x.x for more detail), then follow the below examples. The first example generates a DB character with a backslash in the trail byte. The second example generates a DB character with a vertical bar in the trail byte.</P><ul type=disc>
<li>
type "so", then press enter. You should see this Japanese character: "\ƒ". Remember to select a Japanese font too before typing.<br><br></li>
<li>
type "po", then press enter. You should see this Japanese character: "?".</li>
</ul>
</li>
<li>
Translated or not<p class=tl>
It's not unusual for a Japanese localized product to have English text in it, so how do you know if a string has been translated or not. It's easy, because a translated string has this format: "........(&amp;X)" where 'X' is the hotkey.</P><p class=tl>
For example: English menu item "&amp;ClassWizard" becomes "ClassWizard(&amp;C)" in Japanese.</P></li>
<li>
How do I know it's a bug<p class=tl>
Most often, you will run into a situation where you will have no idea whether it's a by-design or a bug. The best way to determine what it is, is to use either Notepad, Wordpad, or Winword/J and see how those apps handle the situation.</P></li>
<li>
Cursor movement and selection using the keyboard<p class=tl>
When testing the cursor movement and text selection, move the cursor into a DB character from all directions (left, right, up, down). Also use a good combination of text steam that includes both SB and DB characters intermixed.</P></li>
<li>
Cursor movement and selection using the mouse<p class=tl>
When testing the cursor movement and text selection, click the mouse in the middle of a DB character. Also, use a good combination of text steam that includes both SB and DB characters intermixed.</P></li>
<li>
Buffer handling<p class=tl>
When testing buffer limit on an edit field, try typing a DB character when the cursor position is at second from last, next to last, and last just before the end of line is reached.</P><p class=tl>
For example: if the limit is 10 characters, test a DB character when the cursor is at 7th, 8th, and 9th position.</P></li>
<li>
Codepage<p class=tl>
When possible, run your test on different codepages, especially 437, 850, and 932.</P></li>
<li>
Double byte and file/path name<p class=tl>
For ASCII, a filename using character 'a' is the same as a filename using character 'A'. However, a filename using DB character 'a' is NOT the same as a filename using DB character 'A'.</P></li>
<li>
Upper/Lower conversion<p class=tl>
Double-byte characters are not case-sensitive. In other words, there is no such thing as upper/lower case for a DB character. Test to see if an app handles this okay by selecting a DB character, and do the opposite case conversion to see if the character changes.</P></li>
<li>
Insert/Overstrike<p class=tl>
Testing of insert and overstrike modes on DB character should be interesting too.</P><p class=tl>
</P></li>
</ul>
</BODY>
</HTML>
