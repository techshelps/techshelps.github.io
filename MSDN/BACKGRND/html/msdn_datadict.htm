<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The Visual FoxPro Data Dictionary</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_datadict"></a>The Visual FoxPro Data Dictionary </h1>
<p>
October 1997</p>
<p>
Doug Hennig<br>
Partner</p>
<p>
Stonefield Systems Group Inc.<br>
2055 Albert Street, Suite 420<br>
Regina, SK Canada S4P 2T8 </p>
<p>
Phone: (306) 586-3341<br>
Fax: (306) 586-5080<br>
CompuServe: 75156,2326<br>
E-mail: dhennig@stonefield.com<br>
World Wide Web: www.stonefield.com </p>
<h2>Overview </h2>
<p>
With Visual FoxPro®, Microsoft is finally giving us something Xbase developers have needed for years: a built-in data dictionary. Visual FoxPro's data dictionary is based on a database container, a table that contains definitions for tables, persistent relationships between tables, connections to remote data sources such as Microsoft® SQL Server™, and views (both for local and remote data).</p>
<p>
This article will take a close look at the data dictionary, how it is supported with new and existing commands, and what strategies you should be considering for implementing the data dictionary in your applications.</p>
<h2>Introduction </h2>
<p>
FoxPro has always provided the developer with some wonderful tools (sometimes called "design surfaces") to make development faster and easier: the Screen Builder, the Project Manager, the Report Builder, and more. However, one tool that was always lacking was a <i>data dictionary</i>.</p>
<p>
A data dictionary is a repository for some types of <i>meta-data</i> (a fancy word for "data about data"); specifically, that information regarding tables, their structures, indexes, and relationships with each other.</p>
<p>
You may be wondering why a data dictionary is important when FoxPro already provides the <code>display structure</code> command to determine DBF structures. Here are several reasons: 
<ul type=disc>
<li>
File definitions keep the minimum amount of information about a field (the name, type, and size). There is no place in the file structure to record other information, such as the purpose of a field or validation information. Index file definitions keep only the index expression and index/tag name, not whether the index is the primary key for the file or not. Relations are not stored at all, requiring the developer to program them by hand every time they're needed.<br><br></li>
<li>
Since field names are only 10 characters long and don't allow spaces, developers must often resort to using cryptic field names such as COMP_NUM for company number and LAST_UP for date of last update. Users certainly won't know what these names mean, and even developers can forget after a while.<br><br></li>
<li>
The complexity of an application with even a relatively small number of files and fields can quickly overwhelm a developer who must rely on memory to keep track of what field belongs in what file and what a particular file is used for. </li>
</ul>
<p>
By providing a complete description of the data elements in an application and implementing data integrity rules, a good data dictionary acts as both the definition of the database as well as its guardian.</p>
<h2>"New" Terminology </h2>
<p>
The Xbase world has always been a little off the rest of the database community when it comes to what terms to use for a number of concepts.</p>
<p>
In relational database systems, data is considered to be stored in two-dimensional structures called <i>tables</i>. In Xbase, we called these things <i>databases</i>. This gave rise to things like the DBF (DataBase File) extension used for a file containing data and the <code>close database</code> command which closes such a file. Unfortunately, "database" means something different to other database people; it means the set of all the data for an application, a system, or even an entire business. To other database users, tables consist of <i>rows</i> and <i>columns</i>. In Xbase lingo, we referred to these as <i>records</i> and <i>fields</i>.</p>
<p>
Well, guess what? With Visual FoxPro (Visual FoxPro), we Xbasers are being brought into sync with the rest of the database community. The files we stored data in are now called "tables." A "database" in Visual FoxPro is now considered to be a set of tables (among other things) rather than just one file. "Records" and "rows" tend to be used interchangeably in Visual FoxPro, as do "fields" and "columns."</p>
<h2>Databases </h2>
<p>
Visual FoxPro implements databases in a different manner than Microsoft's other database products. In Microsoft Access, for example, all of the data is contained in the database, which is a single file with an MDB extension. Tables and the data they contain are stored in different sections of the database.</p>
<p>
Visual FoxPro, by comparison, keeps data in individual files, each table being a separate file with the familiar DBF extension. The database is stored in a <i>database container</i>, a file with a DBC extension. As you may guess, a DBC file is actually a Visual FoxPro table (the associated index and memo files have DCX and DCT extensions, respectively). Like other tables, it can be opened, browsed, etc.</p>
<p>
The DBC file doesn't contain any of the data in the tables, nor does it contain the tables themselves. Instead, it contains information about the tables (among other things). For example, the DBC contains the name of each table in the database, along with each field and index that make up each table.</p>
<p>
The Visual FoxPro database includes information on: 
<ul type=disc>
<li>
Tables.<br><br></li>
<li>
Fields.<br><br></li>
<li>
Indexes.<br><br></li>
<li>
The relationships between tables (called <i>persistent relationships</i>).<br><br></li>
<li>
Information (called <i>connections</i>) describing how to access remote data sources, such as SQL Server tables.<br><br></li>
<li>
Cursors (or <i>views</i>) created from local tables, remote tables, or a combination of each, using SQL commands. </li>
</ul>
<p>
Interestingly, the database doesn't contain information stored in the header of the DBF and CDX files. In other words, you won't find metadata such as the type and size of each field, nor will you find the index expression for each tag. This means you cannot create a table or its indexes from the information stored in the DBC.</p>
<h2>Do I Gotta? </h2>
<p>
Before we go any further, you should know that just because Visual FoxPro supports databases, you aren't required to use them. You can continue to use tables that aren't part of a database (called <i>free tables</i>) just as you used to in FoxPro 2.<i>x</i>.</p>
<p>
However, there are some very good reasons for using databases instead of free tables. A few of them are: 
<ul type=disc>
<li>
You can define <i>long names</i> (up to 128 characters long) and comments for tables and fields. Visual FoxPro uses long names instead of "real" names in many places, such as browse column headers and the values returned by <code>field()</code> and <code>afields()</code>.<br><br></li>
<li>
Databases act like a guardian for your data. You can define default values for fields (automatically entered when new records are created), field-level validation, record-level validation, even referential integrity handlers that ensure parent records can't be deleted if any child records exist. This code can be stored within the database itself (called <i>stored procedures</i>) so anything accessing the data (programs or even users in interactive mode) must follow your rules.<br><br></li>
<li>
Visual FoxPro now supports transaction processing so you can ensure all of the updates that make up a "transaction" are properly completed or else none of them are. </li>
</ul>
<p>
For all these advantages, there is one drawback: because Visual FoxPro stores the name and path for the database in the DBF header (called a <i>backlink</i>), a table can only belong to a single database. Thus, a database must be shared by all applications needing access to the tables contained in the database.</p>
<h2>Database Commands </h2>
<p>
There are several new commands specific for databases. The more important ones are: 
<ul type=disc>
<li>
<code>create database</code> <code>&lt;</code>Name<code>&gt; </code>creates a DBC.<br><br></li>
<li>
<code>open database &lt;Name&gt;</code> opens a database and makes it current.<br><br></li>
<li>
<code>set database to &lt;Name&gt;</code> makes the specified database the current one (like tables, you can have many databases open at once, but only one is selected at a time).<br><br></li>
<li>
<code>close database</code> no longer closes all open tables. Instead, it closes the current database and all its tables. Other open databases and their tables are left open. A new <code>close tables</code> command closes just the tables for the current database, leaving the database itself open along with other databases and their tables. <code>close database all </code>does what the 2.x close database command does—it closes all open databases and tables. </li>
</ul>
<h2>Database Designer </h2>
<p>
<code>modify database</code> brings up the Database Designer, Visual FoxPro's visual tool for maintaining databases. The Database Designer shows all of the tables contained in the DBC graphically.</p>
<p>
<img src="datadict1.gif" border=0></p>
<p>
Using the Database Designer, you can create or add tables to the database, define relationships between tables, define views, and maintain stored procedures. Anything you can do in the Database Designer, you can do programmatically as well.</p>
<h3>The DBC File </h3>
<p>
As I mentioned earlier, Visual FoxPro's database container is a table that can be opened, browsed, edited, etc. Here's the structure of a DBC:</p>
<p>
<img src="datadict4.gif" border=0></p>
<p>
Here's what each field in the DBC contains: 
<ul type=disc>
<li>
<i>OBJECTID</i>: the ID for the object in the current record. OBJECTID is a sequential number; it always equals <code>recno()</code> for the record. Each table, field, index, relation, connection, and view is stored in a separate record.<br><br></li>
<li>
<i>PARENTID</i>: matches the OBJECTID of the parent record for this object. For example, each field and index for a table has the table's OBJECTID value as its PARENTID value.<br><br></li>
<li>
<i>OBJECTTYPE</i>: the type of the object; see the table below.<br><br></li>
<li>
<i>OBJECTNAME</i>: the name of the object (for all objects except relations, the name is stored in lower case). For example, this would be the table name, the field name, the tag name of the index, etc. This is actually the long name for tables and fields rather than the actual name.<br><br></li>
<li>
<i>PROPERTY</i>: contains information about the object. This field contains encoded information—careless editing of the information can result in an invalid database record.<br><br></li>
<li>
<i>CODE</i>: contains code built into the database (stored procedures).<br><br></li>
<li>
<i>RIINFO</i>: referential integrity information for relation records.<br><br></li>
<li>
<i>USER</i>: Microsoft has thoughtfully provided a field where we can add our own information. This field is not maintained by Visual FoxPro and we can store anything we wish in here. </li>
</ul>
<h2>Tables </h2>
<p>
Tables can either be free or attached to a database. Because of the new backlink mentioned earlier (in free tables, the backlink area is blank), the DBF file structure is no longer backwardly compatible with earlier versions of FoxPro or other applications that can read DBF files.</p>
<h3>New Data Types </h3>
<p>
Visual FoxPro supports several new data types: Binary Character and Memo, Currency, DateTime, Double, and Integer.</p>
<h3>Binary Character and Memo </h3>
<p>
Two new data types, binary versions of Character and Memo fields, allow you to specify fields that contain non-ASCII data and are therefore not subject to automatic code page translation. Unlike FoxPro 2.x, since these data types are defined directly in the table structure, there's no danger in forgetting to specify which fields to not translate when a table is opened.</p>
<h3>Currency </h3>
<p>
A Currency field, which has a type of Y, is stored as an eight-byte binary number. Because Currency fields take up eight bytes regardless of the number stored, they may require less storage space than normal Numeric fields if you need to store large numbers. Currency fields also provide better performance for mathematical operations. Since Numeric fields are actually stored as the ASCII characters that make up the digits, Visual FoxPro must convert the information into a real number before doing an operation on the field, then convert the result back to ASCII characters before storing it in the table. With Currency fields, neither conversion step is necessary.</p>
<p>
Currency fields automatically have four decimal places. Currency fields have a range of -922,337,203,685,477.5807 to 922,337,203,685,477.5807.</p>
<h3>DateTime </h3>
<p>
A DateTime field, which has a type of T and requires 8 bytes, stores both date and time (to the second) in the same field. You can add a number of seconds to a DateTime to obtain another DateTime or subtract two DateTimes to obtain the number of seconds between them. Several new functions, similar to those for Date fields, allow you to control the entry and display of DateTime fields, obtain portions of the field (such as the minutes portion), and convert to and from other data types.</p>
<h3>Double </h3>
<p>
A Double field, like a Currency field, is stored as an eight-byte binary number. However, it's stored as a double-precision floating point number. Although Double fields are fixed at eight bytes in length, like Numeric fields, you must specify the number of decimals (up to 18) when you define a field. The number of decimals is used for display only, not as the number of decimals to use for internal calculations.</p>
<p>
Double fields have a type of B. The range of negative values for a Double field is -1.79769313486232E+308 to -4.94065648541247E-324; the range of positive values is 4.94065648541247E-324 to 1.79769313486232E+308.</p>
<h3>Integer </h3>
<p>
An Integer field, which has a type of I, is stored as a four-byte binary number. It can only store whole numbers (as you would probably guess from its name) in the range of -2,147,483,647 to 2,147,483,647. Integer fields are ideal for storing whole numbers up to a couple billion because they require less than half the storage of the equivalent Numeric field: four bytes versus ten. For example, Integer would be a good choice for a field storing a sequential value as the primary key for a table.</p>
<h3>Memos and General Fields </h3>
<p>
In FoxPro 2.x, a Memo or General field is stored in a DBF as a ten-byte pointer to a block in the FPT file where the actual text is stored. In Visual FoxPro, this pointer is now a four-byte binary pointer. This will reduce the size of your tables by six bytes per record for each Memo and General field used, and will have slightly faster performance as well. Visual FoxPro also now supports a block size of one byte.</p>
<h3>Nulls </h3>
<p>
Visual FoxPro provides support for null fields and values. Null is not a data type, but a value (or rather, lack of a value). A null is not a zero or a blank value; it represents the absence of data. The simplest way to think of a null value is "I don't know what the value is." Fields and memory variables of any type can contain a null value. For example, a Character field and Numeric memory variable can both be null.</p>
<p>
In many designs, null and blank or zero may be synonymous, but a null is not involved in mathematical operations (like averaging) while zero is.</p>
<h2>Table Designer </h2>
<p>
<code>modify structure</code> brings up the Table Designer, Visual FoxPro's new visual tool for maintaining the structure of tables.</p>
<p>
<img src="datadict2.gif" border=0></p>
<p>
In addition to a spiffier interface, the Table Designer has some new features that the 2.x version doesn't: 
<ul type=disc>
<li>
A NULL column where you can indicate a field can accept null values.<br><br></li>
<li>
An index tab so you can define fields and indexes in the same dialog.<br><br></li>
<li>
The Type drop-down includes the new data types described earlier.<br><br></li>
<li>
All kinds of cool new things like field validation rules, default values, and even a Memo field for unlimited comments. </li>
</ul>
<p>
Several of these new features (Table Name, Database, and Table Properties) are only available for tables attached to a database.</p>
<h3>Field Properties </h3>
<p>
There are several new properties available for fields: long name, caption, comments, validation rule and text, and default value.</p>
<p>
A field long name can be up to 128 characters and can be used to refer to the field in place of the real field name. This isn't the same thing as a full-text description for a field since spaces aren't allowed, making it less presentable to the end user (that's what Caption is for). However, it does allow us to have more meaningful names for fields, such as Monthly_Posted_Balance instead of MONBAL. Comments can be used to describe the purpose or contents of the field.</p>
<p>
You can define field validation rules and the text to display if the validation fails. This ability, along with support for the table-level validation rules and triggers we'll see later, is probably the most powerful feature of Visual FoxPro's data dictionary. By defining data validation rules that are enforced at the engine level, you prevent invalid data from getting into your tables, whether it be by users typing in a browse or a program that neglected to do proper data checking.</p>
<p>
Default is the value that will be entered into a field when a record is added interactively (such as in a browse) or programmatically (with <code>append blank</code>, when the SQL <code>insert</code> command is used and a value for the field isn't specified, etc.). The default can be any expression, including a UDF, as long as it evaluates to the same type as the field. Probably the most useful default value is an automatically incrementing value. This is useful for all kinds of fields, such as invoice number, check number, or any field that's the primary key of its table.</p>
<h3>Table Properties </h3>
<p>
There are several properties available for tables from the Table Designer: long name, comments, validation rule and text, and insert, delete, and update triggers.</p>
<p>
A table long name can be up to 128 characters and can be used to refer to the field in place of the real table name. Comments can be used to describe the purpose or contents of the table.</p>
<p>
You can define table-level validation rules that are evaluated when Visual FoxPro tries to write an edited record to the table (for example, the record pointer is moved or the table is closed). Table validation can be used to handle rules that field validation can't, such as dependencies between fields or updating other tables (such as updating summary information).</p>
<p>
We'll discuss triggers a little later.</p>
<h3>Keys and Indexes </h3>
<p>
Except for a change to the user interface, the only difference between Visual FoxPro and FoxPro 2.x with respect to indexes is that you can now define an <i>index type</i> for each tag. For free tables, the types are: 
<ul type=disc>
<li>
<i>Regular</i>: this type is just like the indexes in earlier versions of FoxPro—they are compact tags stored in a structural CDX file.<br><br></li>
<li>
<i>Unique</i>: this type does not prevent duplicate keys; only the first occurrence of a duplicate key value is included in the index. Duplicate records may exist in the table, but only the first one is "visible" when the table's order is set to that index.<br><br></li>
<li>
<i>Candidate</i>: Candidate indexes are what most people think unique indexes are when they first hear of them. A candidate index is one that will allow neither null nor duplicate values. </li>
</ul>
<p>
For tables included in a database, another index type is available: <i>primary</i>. A primary index is essentially a candidate index (it automatically prevents null and duplicate key values) except that while you can define as many candidate indexes as you like, a table can only have one primary key. The distinction between primary and candidate keys is mainly for relationships.</p>
<p>
Since the primary key for a table is stored in the database, when you remove the table from the database, Visual FoxPro automatically changes the index type to candidate. The reason for the name "candidate" is since it too will not accept duplicate or null values (and thus uniquely identifies a record), such an index is a "candidate" to be the primary key; it's just that something more suitable was chosen instead.</p>
<h3>Table Commands </h3>
<p>
There are lots of new and improved commands regarding tables. A few of them are: 
<ul type=disc>
<li>
<code>create table</code> now supports many new clauses, such as <code>primary key</code> to define the primary key for the table, <code>references</code> to define a persistent relationship with another table, and <code>null</code> to permit null support for a field.<br><br></li>
<li>
<code>use</code> now automatically opens the database associated with a table if it isn't already.<br><br></li>
<li>
<code>alter table</code> is a new command that you <i>must</i> get to know. It allows you to alter the structure of a table programmatically, something that formerly required a lot of code. Here's an example of a single line of code that adds three new fields, deletes one field, removes the relationship between COMPANY and CATEGORY (but keeps the index on COMPCAT), and removes the table validation rule: <pre><code>alter table COMPANY add column ADDRESS C(30) ;
add column CITY C(30) ;
add column POSTCODE C(10) ;
drop column TEST ;
drop foreign key COMPCAT save ;
drop check
</code></pre>
</li>
<li>
<code>copy to</code> now supports an new <code>fox2x</code> type so you can output records in a format older version of FoxPro can read.<br><br></li>
<li>
<code>dbgetprop()</code> is a new function that returns information from the database, such as the caption for a field or the validation rule for a table. Here's a routine called GETFIELD that uses <code>dbgetprop()</code> to display a popup of fields, but using the field caption (which is preferably something meaningful) instead of the field name: <pre><code>local lnI
define popup FIELD_POP from 0, 0 title 'Select Field'
for lnI = 1 to fcount()
define bar lnI of FIELD_POP prompt dbgetprop(alias() + '.' + ;
field(lnI), 'Field', 'Caption')
next lnI
on selection popup FIELD_POP deactivate popup
activate popup FIELD_POP
wait window 'You selected ' + field(bar())
</code></pre>
</li>
</ul>
<h3>Persistent Relationships </h3>
<p>
A shortcoming that's always existed in Xbase systems is the lack of persistent relationships between tables. Unlike table structures, which are defined in the header of the DBF file, and index structures, which are defined within the CDX file, relationships between tables are only defined within program code. You specifically code <code>set relation</code> or SQL <code>select</code> with a join condition to relate or join tables together.</p>
<p>
With Visual FoxPro, persistent relationships between tables can now be defined in the database. These relationships are not only useful for documentation purposes, but are also used as default relationships between tables added to the DataEnvironment of forms and reports, and in the Query and View Designers.</p>
<p>
Persistent relationships are always defined from one index to another rather than from one field to another as you might expect.</p>
<h3>Creating Persistent Relationships </h3>
<p>
Defining a relationship between two tables in the Database Designer is simple: drag an index from one table to another. There are some rules about which indexes get dragged where: 
<ul type=disc>
<li>
Dropping a candidate or primary index on a regular index gives a 1:M relationship.<br><br></li>
<li>
Dropping a candidate or primary index on a candidate or primary index gives a 1:1 relationship. </li>
</ul>
<p>
Since you can only drag a candidate or primary index to another index, you are always setting a relationship from the "one" table into the other table (either "many" or "one," depending on the type of index involved).</p>
<p>
Relationships are shown as lines between tables. One end of the line has a bar across it; this end connects to the "one" table. The other end of the line has a "fork" symbol; this end connects to the "many" table.</p>
<p>
Persistent relationships can also be defined programmatically using the <code>create table</code> and <code>alter table</code> commands. For example, the following command creates the COMPANY table and relates it to the CATEGORY table:</p>
<pre><code>create table COMPANY (COMP_ID I primary key, NAME C(30), ADDRESS C(30), ;
 &nbsp; CITY C(25), POSTAL_CODE C(10), CATCODE C(4) references CATEGORY)
</code></pre>
<h2>Triggers, Stored Procedures, and Referential Integrity </h2>
<p>
Maintaining referential integrity (RI) is a very important issue for database developers to consider. RI means every child record has a matching parent. For example, if the employee table is a child of the department table, every employee must have a matching department. This means the department ID field mustn't be blank, nor must it contain an invalid department ID.</p>
<p>
There are two ways to ensure RI is maintained. Some database management systems, such as Gupta's SQLBase Server, support <i>declarative</i> RI. This means by defining a relationship between the two tables and the rules to follow for delete, update, and insert events, you are telling the database to handle the events automatically.</p>
<p>
FoxPro supports another type of RI: <i>procedural</i>. Instead of the database engine automatically performing RI actions, procedural code is written to perform the appropriate action. While declarative RI may seem preferable, it actually has the advantage in being more flexible, since you, not the database engine, decide exactly how the RI should be enforced.</p>
<h3>Triggers </h3>
<p>
Triggers are pieces of code automatically executed when a particular event occurs. For example, if you define a function as the delete trigger for a table, Visual FoxPro calls the function (the trigger is said to be <i>fired</i>) whenever an attempt is made to delete a record, either programmatically or interactively. If the trigger code returns .T., the record is deleted. If it returns .F., the record will not be deleted and a trappable error (1539) occurs.</p>
<p>
Triggers are stored in databases, so you can't define them for free tables. You can define triggers for three events for each table: inserting, updating, and deleting records. Any program or interactive session (such as during a browse or in a form) causing an insert, update, or delete event to occur will cause the trigger to fire.</p>
<p>
The most typical use for triggers is to maintain referential integrity. The update and delete triggers are often used for parent tables to prevent orphaning child records. The insert trigger is usually used for a child table to ensure a foreign key field matches a record in a parent table. Examples of actions taken by a delete trigger are preventing a record from being deleted if there are any child records (called a "restrict" delete rule) and deleting the child records (a "cascading" delete).</p>
<p>
The fact that both programmatic and interactive events cause a trigger to fire provides us with a powerful mechanism for protecting our data. Together, triggers and the other rules defined in a database help you maintain both data integrity (preventing invalid data from getting into tables) and referential integrity (preventing invalid links between tables), whether it be by users typing in a browse or a program that neglected to do proper data checking.</p>
<p>
Triggers can be nested; in fact, they're automatically nested if necessary. If the trigger code for one table causes an event to occur in another table, that other table's trigger code will fire. For example, cascading deletes from parent to child to grandchild are automatically performed by creating delete triggers for the parent and child tables. The parent table's trigger deletes the child record, which causes the child table's trigger to fire, which in turn deletes the grandchild record. </p>
<p>
Triggers can be defined in the Table Designer by selecting the Table Properties button, or programmatically using <code>create trigger on &lt;Alias&gt; for &lt;Event&gt; as &lt;Expression&gt;</code>.</p>
<h3>Stored Procedures </h3>
<p>
A stored procedure is a routine stored within the database itself: the source code is stored in the CODE field of the StoredProceduresSource record in the DBC and the compiled code is stored in the CODE field of the StoredProceduresObject record. Stored procedures are usually used for trigger code and any routines the trigger code must call.</p>
<p>
Since the procedures are stored in a database, the database can protect itself from improper changes to the data without requiring an external program to do the work. It also means once the triggers and stored procedures are defined, the application programmer doesn't have to worry about knowing those rules or implementing them in every program that accesses the database. Another advantage is if the rules change, they change in one place rather than changing every program that accesses the database. Because the trigger code is stored in the database, and the only way to access a table is through the database, there's no way for users or programmers to circumvent the rules enforced through the triggers. This isn't exactly the same as object-orientation, but it does provide encapsulation of data and code into a database.</p>
<p>
Stored procedures can be maintained from the Database Designer or programmatically. <code>modify procedures</code> brings up an edit window with the stored procedures for the current database. <code>append procedures</code> appends code from a file to the stored procedures in the current database.</p>
<p>
What code should go in stored procedures and what should be in library routines? The approach I use is to put routines enforcing business rules specific to a database in the stored procedures for the database, and put generic, reusable code where it belongs: in library routines. The drawback to this approach is the database can't stand by itself; the library routines have to be available or the stored procedures calling them will fail. However, since I rarely allow users of applications I write to browse tables directly from the Command window, I don't consider this to be a major concern. Also, if someone does browse a table and tries to make changes, the trigger and validation routines will fail (an error trap can provide a more elegant interface than just having the program bomb) and no changes to the data will be permitted. In other words, if we can't ensure the data is valid, let's not allow it to be changed.</p>
<h3>RI Builder </h3>
<p>
Microsoft provides an RI builder that automatically generate triggers and stored procedures that maintain RI according to rules you specify. To bring up the RI builder, open the Database Designer, double-click on a relationship line, and choose the Referential Integrity button in the dialog that appears.</p>
<p>
<img src="datadict3.gif" border=0></p>
<p>
The RI Builder has columns for the parent and child tables and their tags, as well as columns for the rules to use for update, delete, and insert events. Tabs below the list allow you to choose a particular event and the rule to use for the relationship selected in the list; you can also click in the appropriate cell in the list and choose the desired rule from the drop-down list that appears. The update and delete events pertain to the parent table and define what should happen to the child table. The insert event is for the child table and defines whether the foreign key must match a parent record or not.</p>
<h2>Connections and Views </h2>
<p>
FoxPro 2.x allowed you to access client-server databases if you installed the Connectivity Kit, an add-on library from Microsoft. With Visual FoxPro, access to other databases is built into the product. Visual FoxPro uses ODBC (Open Database Connectivity) to allow you to connect to any database for which an ODBC driver is available. For example, Access, Oracle, Watcom, and SQL Server databases are all accessible from Visual FoxPro now. Visual FoxPro does client-server!</p>
<p>
Although one of the benefits of client-server development is that network traffic is reduced since only records matching a query are sent to the workstation, Visual FoxPro provides several features to help performance with backend databases even more: progressive fetching, delayed memo download, batch updating, and so on.</p>
<p>
There are two aspects to accessing another database (called <i>remote data</i>, even if it exists on the same machine as Visual FoxPro): connections and views, both of which must exist in a database. </p>
<h4>Connections </h4>
<p>
Connections describe how to connect to remote data, including the datasource, user ID and password, timeout intervals, and type of processing to be used.</p>
<h4>Views </h4>
<p>
Views are simply pre-defined SQL <code>select</code> statements to retrieve data. However, unlike the cursor or table that results from a regular <code>select</code> statement, views are <i>updatable</i>, meaning that changes made to the data in a view can update the original tables. Views can contain remote or local data, or a combination of both.</p>
<p>
Views can be opened using <code>use &lt;ViewName&gt;</code>, which causes the <code>select</code> statement to be executed. The resulting cursor can be browsed or edited just like a regular table.</p>
<p>
Views are defined visually with the new View Designer or programmatically using <code>create sql view.</code></p>
<h2>Extending the Data Dictionary </h2>
<p>
Visual FoxPro's database allows you to extend the information stored in the DBF and CDX file headers to contain other important repository information. However, there is certainly some information missing from the DBC that you might have expected: 
<ul type=disc>
<li>
table structural information such as field name, type, and size;<br><br></li>
<li>
index structural information such as index expression and filter; and<br><br></li>
<li>
non-structural but useful information such as input and output masks (pictures) for fields. </li>
</ul>
<p>
There are some other limitations as well, such as: 
<ul type=disc>
<li>
Visual FoxPro provides a caption for fields, which can act as a full-text description shown to the user. However, there is no similar information for tables or indexes.<br><br></li>
<li>
No event is triggered when a database is opened. This means there's no ability to do things like open all or some of the tables in the database or to ask for a password and close the database if the wrong one is entered.<br><br></li>
<li>
Although forms and reports have DataEnvironments, there's no built-in function to set up a relation defined in the database for a program. <br><br></li>
</ul>
</BODY>
</HTML>
