<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Microsoft Foundation Class Library Development Guidelines</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_mfcgde"></a>Microsoft Foundation Class Library Development Guidelines </h1>
<p>
Microsoft Corporation</p>
<p>
Updated March 31, 1997</p>
<h2>Table of Contents </h2>
<p>
<a href="#overview">Overview</a> </p>
<p>
<a href="#design goals">Design Goals of the MFC Class Library</a> </p>
<p>
<a href="#guidelines for writing">Guidelines for Writing Class Library Extensions</a> </p>
<p>
<a href="#follow mfc's">Follow MFC’s Conventions</a> </p>
<p>
<a href="#make your classes">Make Your Classes Flexible</a> </p>
<p>
<a href="#use mfc to create">Use MFC to Create Your Classes</a> </p>
<p>
<a href="#write thorough">Write Thorough Documentation to Help Your Users</a> </p>
<p>
<a href="#in conclusion">In Conclusion</a> </p>
<h2><a name="overview"></a>Overview </h2>
<p>
This paper is intended for use by developers who want to create extensions for the Microsoft® Foundation Class Library and who want to ensure that their classes are "MFC-friendly"; that is, classes that will function well with MFC. This paper is also useful for anyone writing MFC applications who wants to know the philosophy and development practices used in the Library. </p>
<h2><a name="design goals"></a>Design Goals of the MFC Class Library</h2>
<p>
The Microsoft Foundation Class Library, a C++ Windows® interface, is built on top of the C-language Windows application programming interface (API) to ensure long-term compatibility with the thousands of applications already written for Windows. MFC is a truly object-oriented interface designed with the following goals in mind: 
<ul type=disc>
<li>
Significantly reduced effort for programming an application for Windows <br><br></li>
<li>
Execution speed comparable to that of the C-language API <br><br></li>
<li>
Minimum code size overhead <br><br></li>
<li>
Ability to call any Windows C function directly <br><br></li>
<li>
Easier conversion of existing C applications to C++ <br><br></li>
<li>
Ability to leverage from the existing base of C-language Windows programming experience <br><br></li>
<li>
True Windows API for C++ that effectively uses C++ language features</li>
</ul>
<p>
The core of the Microsoft Foundation Class Library encapsulates a large portion of the Windows API in C++ form. Library classes represent windows, dialog boxes, device contexts, common GDI objects, and other standard Windows items. These classes provide a convenient C++ member function interface to the structures in Windows that they encapsulate. The Microsoft Foundation Class Library also supplies a layer of additional application functionality built on the C++ encapsulation of the Windows API. This layer is a working application framework for Windows that provides most of the common user interface expected of programs for Windows. </p>
<p>
The single characteristic that sets the Microsoft Foundation Class Library apart from other class libraries for Windows is the close mapping to the Windows API written in the C language. You can generally mix calls to the class library freely with direct calls to the Windows API. However, the classes are not a complete replacement for that API. Developers must still occasionally make direct calls to some Windows functions (<b>::GetSystemMetrics</b>, for example). A Windows function is wrapped by a class member function only when there is a clear advantage to doing so. </p>
<h2><a name="guidelines for writing"></a>Guidelines for Writing Class Library Extensions </h2>
<p>
The remainder of this paper outlines the practices that the MFC developers use when writing new classes for the Library. We recommend that you follow these same practices when writing classes that extend the MFC Library. For optimum performance and compatibility with the Library, we suggest that you: </p>
<p>
<b>Keep the classes simple. </b></p>
<p>
Follow the conventions for naming classes, member functions, and data members. </p>
<p>
<b>Make your classes flexible. </b></p>
<p>
Use MFC to write your classes. </p>
<p>
<b>Write thorough documentation to assist your users.</b></p>
<h3>Keep Your Classes Simple </h3>
<p>
Classes you expose to the user should be as uncomplicated as you can make them. It is okay for your job as the class library designer to be difficult if doing so makes it easier for your users (in this case, other developers) to understand the classes you have written. </p>
<h4>Use a safe subset of the C++ language features </h4>
<p>
MFC uses a safe subset of the C++ language features. This lowers the level of complexity in the Class Library, and ensures that the classes will be compatible with a wide range of uses. MFC uses C++ idioms in commonly accepted practices. Advanced issues such as copy construction, assignment operators, and correct object destruction are handled in a thorough and consistent manner. To make your classes MFC-friendly, we recommend that you follow these principles as you create your classes. </p>
<h4>Limit the number of abstract base classes you write </h4>
<p>
MFC has a few abstract base classes that serve specific purposes, such as CObject and CCmdTarget. In general we advise developers to combine an abstract base class with a useful implementation if that is possible. CFile and CWnd are examples of classes that are used in both concrete and abstract forms. </p>
<h4>Use //Implementation section instead of implementation classes </h4>
<p>
Creating a class that is for implementation purposes only, yet is visible to your users, is both confusing and frustrating. Instead, put implementation details below the //Implementation line in your header files. For more information, see "Limit the Use of ‘Private’ in Your Classes" elsewhere in this document, and also see "MFC: Using the MFC Source Files" in the <i>Visual C++ Programmer’s Guide </i>in the online documentation (MSDN Library, Developer Products, Visual C++). </p>
<h4>Use single rather than multiple inheritance in your classes </h4>
<p>
Multiple inheritance adds a high degree of complexity to application development. The Microsoft Foundation Class Library does not use multiple inheritance in the design or implementation of any of its classes. While you can use multiple inheritance with MFC to write an application (see Technical Note 16 in the Microsoft Foundation Class Reference in the Visual C++® online documentation: MSDN Library, Developer Products, Visual C++, Microsoft Foundation Class Reference), we do not recommend using it in MFC-friendly classes. </p>
<h4>Use templates as an advantage in your classes </h4>
<p>
Templates in C++ are relatively new to the language and rather complicated to implement. Templates allow your classes to be generic when necessary, but the level of complexity inherent to templates can negate this advantage. Templates are most useful when creating "collection" classes, or for providing type-safe wrappers on a non type-safe base implementation. </p>
<h4>Use "Accessor" (Get/Set) functions when they add value </h4>
<p>
There is a philosophy of class design that suggests that all data members should be private or protected and that accessor functions should be used to change the values in those data members. MFC uses public data members instead, frequently offering both a public data member and an accessor function for use by the developer. For example, class CWnd provides both a public data member, <b>CWnd::m_hWnd</b>, and an accessor function, <b>CWnd::GetSafeHwnd.</b> Depending on the needs of a particular application, a developer might use the data member or the member function, or both. </p>
<p>
More often, MFC uses accessor functions in significant operations such as setting and retrieving style settings, returning pointers, and obtaining values used in other operations. We encourage developers who are writing MFC-friendly classes to use public data members as often as possible, and reserve accessor functions for operations that do more than simply change values in a data member, such as incrementing a counter or updating another function. </p>
<h4>Use a thin layer over the Windows API </h4>
<p>
Part of MFC’s success lies in the fact that the framework is a very thin layer over the Windows API. Most of the time MFC "wraps" the Windows functionality in C++ without adding functionality. In some cases (for example, dialog boxes), MFC greatly simplifies the Windows API by managing the details for you, but the general rule is to keep the layer as thin as possible. This principle also applies to the Windows Open Services Architecture (WOSA) APIs. </p>
<p>
By keeping the framework layer very thin, developers can manipulate aspects of the Windows API more directly while still taking advantage of the power of C++. This layer can be especially helpful in HANDLE-based APIs such as the graphics device interface (GDI) HDCs and USER HWNDS. </p>
<p>
To make your classes truly MFC-friendly, we recommend that you keep the encapsulation of any Windows API functions as simple as possible. Remember, however, to allow developers to call the Windows API directly whenever they need it. </p>
<p>
Table 1 shows examples of the relationship between MFC and the Windows API, as well as common naming conventions used with these objects. </p>
<p class=label>
<b>Table 1. Relationships Between MFC and Windows Handles, Controls, and Structures </b></p>
<table border=1 cellpadding=5 cols=4 frame=below rules=rows>
<tr valign=top>
<td class=label width=24%><b>Windows Type</b></td>
<td class=label width=27%><b>Example Variable </b></td>
<td class=label width=20%><b>MFC Class </b></td>
<td class=label width=29%><b>Example Object</b></td>
</tr>
<tr valign=top>
<td width=24%><b>HWND</b></td>
<td width=27%>hWnd; </td>
<td width=20%><b>CWnd</b><sup>*</sup> </td>
<td width=29%><i>pWnd;</i></td>
</tr>
<tr valign=top>
<td width=24%><b>HDLG </b></td>
<td width=27%>hDlg; </td>
<td width=20%><b>CDialog</b><sup>*</sup> </td>
<td width=29%><i>pDlg;</i></td>
</tr>
<tr valign=top>
<td width=24%><b>HDC </b></td>
<td width=27%>hDC; </td>
<td width=20%><b>CDC</b><sup>*</sup> </td>
<td width=29%><i>pDC;</i></td>
</tr>
<tr valign=top>
<td width=24%><b>HGDIOBJ </b></td>
<td width=27%>hGdiObj; </td>
<td width=20%><b>CGdiObject</b><sup>*</sup> </td>
<td width=29%><i>pGdiObj;</i></td>
</tr>
<tr valign=top>
<td width=24%><b>HPEN </b></td>
<td width=27%>hPen; </td>
<td width=20%><b>CPen</b><sup>*</sup> </td>
<td width=29%><i>pPen;</i><sup>1</sup></td>
</tr>
<tr valign=top>
<td width=24%><b>HBRUSH </b></td>
<td width=27%>hBrush; </td>
<td width=20%><b>CBrush</b><sup>*</sup> </td>
<td width=29%><i>pBrush;</i><sup>1</sup></td>
</tr>
<tr valign=top>
<td width=24%><b>HFONT </b></td>
<td width=27%>hFont; </td>
<td width=20%><b>CFont</b><sup>*</sup> </td>
<td width=29%><i>pFont;</i><sup>1</sup></td>
</tr>
<tr valign=top>
<td width=24%><b>HBITMAP </b></td>
<td width=27%>hBitmap; </td>
<td width=20%><b>CBitmap</b><sup>*</sup> </td>
<td width=29%><i>pBitmap;</i><sup>1</sup></td>
</tr>
<tr valign=top>
<td width=24%><b>HPALETTE </b></td>
<td width=27%>hPalette; </td>
<td width=20%><b>CPalette</b><sup>*</sup> </td>
<td width=29%><i>pPalette;</i><sup>1</sup></td>
</tr>
<tr valign=top>
<td width=24%><b>HRGN </b></td>
<td width=27%>hRgn; </td>
<td width=20%><b>CRgn</b><sup>*</sup> </td>
<td width=29%><i>pRgn;</i><sup>1</sup></td>
</tr>
<tr valign=top>
<td width=24%><b>HMENU </b></td>
<td width=27%>hMenu; </td>
<td width=20%><b>CMenu</b><sup>*</sup> </td>
<td width=29%><i>pMenu;</i><sup>1</sup></td>
</tr>
<tr valign=top>
<td width=24%><b>HWND </b></td>
<td width=27%>hCtl; </td>
<td width=20%><b>CStatic</b><sup>*</sup> </td>
<td width=29%><i>pStatic;</i><sup>2</sup></td>
</tr>
<tr valign=top>
<td width=24%><b>HWND </b></td>
<td width=27%>hCtl; </td>
<td width=20%><b>CButton</b><sup>*</sup> </td>
<td width=29%><i>pBtn;</i><sup>2</sup></td>
</tr>
<tr valign=top>
<td width=24%><b>HWND </b></td>
<td width=27%>hCtl; </td>
<td width=20%><b>CEdit</b><sup>*</sup> </td>
<td width=29%><i>pEdit;</i><sup>2</sup></td>
</tr>
<tr valign=top>
<td width=24%><b>HWND </b></td>
<td width=27%>hCtl; </td>
<td width=20%><b>CListBox</b><sup>*</sup> </td>
<td width=29%><i>pListBox;</i><sup>2</sup></td>
</tr>
<tr valign=top>
<td width=24%><b>HWND </b></td>
<td width=27%>hCtl; </td>
<td width=20%><b>CComboBox</b><sup>*</sup> </td>
<td width=29%><i>pComboBox;</i><sup>2</sup></td>
</tr>
<tr valign=top>
<td width=24%><b>HWND </b></td>
<td width=27%>hCtl; </td>
<td width=20%><b>CScrollBar</b><sup>*</sup> </td>
<td width=29%><i>pScrollbar;</i><sup>2</sup></td>
</tr>
<tr valign=top>
<td width=24%><b>HSZ </b></td>
<td width=27%>hszStr; </td>
<td width=20%><b>CString </b></td>
<td width=29%><i>pStr;</i><sup>2</sup></td>
</tr>
<tr valign=top>
<td width=24%><b>POINT </b></td>
<td width=27%>pt; </td>
<td width=20%><b>CPoint </b></td>
<td width=29%><i>pt;</i></td>
</tr>
<tr valign=top>
<td width=24%><b>SIZE </b></td>
<td width=27%>size; </td>
<td width=20%><b>CSize </b></td>
<td width=29%><i>size;</i></td>
</tr>
<tr valign=top>
<td width=24%><b>RECT </b></td>
<td width=27%>rect; </td>
<td width=20%><b>CRect </b></td>
<td width=29%><i>rect;</i></td>
</tr>
</table><br>
<p class=mini>
* Most OLE data types are wrapped by the COleVariant class. Other MFC classes used with COleVariant include <b>COleDateTime</b>, <b>COleDateTimeSpan</b>, and <b>COleCurrency</b>.<br>
1. Graphics device interface (GDI) objects typically are allocated as local variables on the stack frame. When allocated as such, the convention is to name them without a prefix, in lowercase characters; for example, CPen pen.<br>
2. Controls typically are allocated at the same time the parent window is allocated, and usually are embedded by value in the parent window. For example, a <b>CDialog</b> that contains a <b>CButton</b> object will declare a member variable as CButton m_button. </p>
<h3>Understand the Differences between Value and Framework Classes </h3>
<p>
MFC uses two types of classes as the basis for the class library: "value" classes and "framework" classes. </p>
<p>
Value classes are encapsulations of single structures that contain values such as a string or coordinates. The MFC value classes allow you to manipulate these values in an efficient manner. Some of the classes (for example, <b>CPoint</b>) add to the basic Windows functionality to make the classes easier to use. </p>
<p>
Framework classes are derived from <b>CObject</b>. These classes provide the basic requirements of a Windows application and encapsulate much of the Windows interface. In some cases the framework classes are a very thin encapsulation of the Windows API, and in other cases the MFC classes add a lot of value to make the manipulation of Windows API details easy to manage. </p>
<p>
Table 2 describes some of the characteristics of "value" and "framework" classes. </p>
<p class=label>
<b>Table 2. Value and Framework Class Characteristics </b></p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=43%><b>Characteristics </b></td>
<td class=label width=21%><b>Value </b></td>
<td class=label width=36%><b>Framework</b></td>
</tr>
<tr valign=top>
<td width=43%>Has virtual functions? </td>
<td width=21%>No </td>
<td width=36%>Yes</td>
</tr>
<tr valign=top>
<td width=43%>Is a base class? </td>
<td width=21%>No </td>
<td width=36%><b>CObject</b> derived</td>
</tr>
<tr valign=top>
<td width=43%>Is designed for direct usage? </td>
<td width=21%>Yes </td>
<td width=36%>Maybe</td>
</tr>
<tr valign=top>
<td width=43%>Is designed to be derived from? </td>
<td width=21%>No </td>
<td width=36%>Yes</td>
</tr>
<tr valign=top>
<td width=43%>Has an <b>operator=</b>? </td>
<td width=21%>Usually </td>
<td width=36%>No</td>
</tr>
<tr valign=top>
<td width=43%>Has a copy constructor? </td>
<td width=21%>Usually </td>
<td width=36%>No</td>
</tr>
<tr valign=top>
<td width=43%>Acts like built-in type? </td>
<td width=21%>Usually </td>
<td width=36%>No</td>
</tr>
<tr valign=top>
<td width=43%>Comparing values is meaningful? </td>
<td width=21%>Usually </td>
<td width=36%>No</td>
</tr>
<tr valign=top>
<td width=43%>Comparing address is meaningful? </td>
<td width=21%>No </td>
<td width=36%>Yes (address is identity)</td>
</tr>
</table><br>
<h3>Use const to Control Accessibility of Data Members </h3>
<p>
Using <b>const</b> in your code is a way to protect the accessibility of data. In general, developers could use <b>const</b> more often than they do, and in MFC <b>const</b> is used whenever feasible to make the data less vulnerable. We encourage you to apply <b>const</b> to your data members as often as possible as a guarantee to your users that your accessor functions do not have hidden side effects. This is particularly important because you will derive other classes and objects from the MFC-friendly classes that you write. </p>
<h3>Passing Parameters </h3>
<p>
It is important to safeguard the data in your value classes by using the following principles: 
<ul type=disc>
<li>
A <b>const</b> reference should be used as an optimization. If the class data is small (for example, two int members, as is the case with <b>CSize</b>), then pass by value. If the class data is larger, pass by const reference instead. This retains the "by value" semantics of the class, as well as providing efficient parameter passing. <br><br></li>
<li>
Framework objects cannot be copied, and therefore cannot be passed by value. Passing by reference will work, but is misleading, since it appears to be a "copy by value" parameter. To keep the "framework" semantics and expectations in a class, it is best to pass by address.</li>
</ul>
<p>
To pass as an input parameter: 
<ul type=disc>
<li>
If you are using a value object, pass it by value. If the object is too big, pass by <b>const</b> reference.<pre><code>void Do(CMyValue val); 
void Do( const CMyValue&amp; val ); 
// from the caller's perspective these look the same 
</code></pre>
</li>
<li>
If you are using a framework object, pass it as a const pointer: <pre><code>void Do( const CMyView* pob ); 
To pass as an output parameter: 
</code></pre>
</li>
<li>
If you are using a value object, pass it as a non-const pointer:<pre><code>void GetSomething( CMyValue* pval ); 
</code></pre>
</li>
<li>
If you are using a framework object, pass it as a non-const pointer:<pre><code>void UpdateSomething( CMyView* pob ); 
</code></pre>
</li>
<li>
To pass as an input/output parameter: <p class=tl>
Passing value objects as input/output parameters should be avoided. If you must, you can use a non-const pointer, or a non-const reference. Ideally, however, you should stay away from passing value objects in this manner. </P></li>
<li>
If you are using a framework object, pass it as a non-const pointer:<pre><code>void UpdateSomething( CMyView* pob ); 
</code></pre>
</li>
</ul>
<p>
To determine return values: 
<ul type=disc>
<li>
If you are using a value object, return it as an object:<pre><code>CMyValue GetCurrentValue(); 
</code></pre>
</li>
<li>
If you are using a framework object, return it as a pointer:<pre><code>CMyView* GetCurrentView(); 
</code></pre>
</li>
</ul>
<h3>Avoid Overloading operator = and Copy Constructors </h3>
<p>
The majority of the classes you will create as extensions to MFC will be framework-type classes. For those classes, you should keep to a safe subset of C++ functions. If you do create value classes, be sure to use all the advantages of the C++ language as MFC has done with its value classes. <b>CString</b> and <b>CRect</b> are good examples of classes to review for these features. </p>
<p>
In general, framework objects do not behave like the types built-in to C++, so you cannot add them or assign them the way you would with value objects. Deciding what semantics the <b>operator =</b> would represent would be arbitrary, so avoid including this operator in your framework classes. In many such MFC classes provision is made for copying in such a way to protect the integrity of the data. For example, in the template collection classes, you cannot do the following: </p>
<pre><code>CArray myarray1; 
CArray myarray2; 
... (insertion of data) 
myarray1=myarray2; 
You can, however, do this: 
CArray myarray1; 
CArray myarray2; 
... (insertion of data) 
myarray2.RemoveAll(); 
myarray2.Append(myarray1); 
</code></pre>
<p>
For more information, see "General Rules for Operator Overloading" in the C++ Language Reference in the Visual C++ online documentation (MSDN Library, Developer Products, Visual C++). </p>
<p>
Along the same lines, avoid overloading copy constructors in framework classes. The type of the copy constructor's argument should be "<b>const</b> <i>classname</i><b>&amp;</b>" whenever possible. This prevents the copy constructor from accidentally changing the object from which it is copying. It also allows copying from const objects. </p>
<h2><a name="follow mfc's"></a>Follow MFC's Conventions</h2>
<p>
MFC uses a set of conventions to make it easy to identify elements of the code. We recommend that you follow these simple conventions to leverage the ease-of-identification found in MFC. </p>
<h3>Use the Windows API Data Types, API Names, and Message Names </h3>
<p>
MFC uses the Windows API types, API names, and message names whenever possible as the basis for naming classes and functions in the class library. This makes it easy to determine that the Windows API is encapsulated by an MFC member function. MFC’s member function names do not clash with those found in the Windows API because they operate within a class scope rather than a file scope. On occasion you might need to call a Windows API function instead of an MFC function, and you can do that using the global scoping operator (<b>::</b>). When you write MFC-friendly classes, we encourage you to follow the same conventions to make it easy for your users to understand your intentions. </p>
<h3>Follow the MFC Conventions for Commenting Source Code </h3>
<p>
In both the MFC source files and the files that AppWizard creates, you will find comments like these within class declarations (usually in this order): </p>
<p>
// Constructors </p>
<p>
// Attributes </p>
<p>
// Operations </p>
<p>
// Overridables </p>
<p>
// Implementation </p>
<p>
MFC uses these commenting conventions to delineate the sections of the class declarations containing similar kinds of class members. Some classes omit some sections but all classes have at least the //Implementation section, and larger classes may have additional sections besides those listed above. </p>
<p>
Following these and other conventions outlined in the article "MFC: Using the MFC Source Files" in the <i>Visual C++ Programmer’s Guide </i>found in the online documentation is optional, of course. However, doing so makes it easy for your users to find the functions they need in your header files. </p>
<h3>Use Simplified Hungarian Notation </h3>
<p>
The following tables describe the subset of Hungarian notation used in MFC. Table 3 shows general prefix naming conventions. Note that all class names and structure names begin with the letter "C", and member variables are preceded by m_. </p>
<p class=label>
<b>Table 3. General Prefix Naming Conventions </b></p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=19%><b>Prefix </b></td>
<td class=label width=35%><b>Type </b></td>
<td class=label width=46%><b>Example </b></td>
</tr>
<tr valign=top>
<td width=19%><b>C </b></td>
<td width=35%>Class or structure </td>
<td width=46%><b>CDocument</b>, <b>CPrintInfo</b> </td>
</tr>
<tr valign=top>
<td width=19%><b>m_ </b></td>
<td width=35%>Member variable </td>
<td width=46%>m_pDoc, m_nCustomers</td>
</tr>
</table><br>
<p>
You may notice the absence of static member variables in Table 3. Static member variables are not really members of the object (that is to say, the instantiation of the class). Static member variables are global variables whose "namespace" is within the context of a class. Since global variables are not prefixed, static member variables are not prefixed. </p>
<p>
Table 4 lists the prefixes MFC uses for naming variables. If you use these naming conventions in your MFC-friendly classes, users of your classes will appreciate the consistency between your code and MFC. </p>
<p class=label>
<b>Table 4. Variable Prefix Naming Conventions </b></p>
<table border=1 cellpadding=5 cols=4 frame=below rules=rows>
<tr valign=top>
<td class=label width=17%><b>Prefix </b></td>
<td class=label width=21%><b>Type </b></td>
<td class=label width=37%><b>Description </b></td>
<td class=label width=25%><b>Example </b></td>
</tr>
<tr valign=top>
<td width=17%><b>ch </b></td>
<td width=21%>char </td>
<td width=37%>8-bit character </td>
<td width=25%><i>chGrade </i></td>
</tr>
<tr valign=top>
<td width=17%><b>ch </b></td>
<td width=21%>TCHAR </td>
<td width=37%>16-bit character if<b> _UNICODE</b> is defined </td>
<td width=25%><i>chName</i></td>
</tr>
<tr valign=top>
<td width=17%><b>b </b></td>
<td width=21%>BOOL </td>
<td width=37%>Boolean value </td>
<td width=25%><i>bEnabled</i></td>
</tr>
<tr valign=top>
<td width=17%><b>n </b></td>
<td width=21%>int </td>
<td width=37%>Integer (size dependent on operating system) </td>
<td width=25%><i>nLength</i></td>
</tr>
<tr valign=top>
<td width=17%><b>n </b></td>
<td width=21%>UINT </td>
<td width=37%>Unsigned value (size dependent on operating system) </td>
<td width=25%><i>nLength </i></td>
</tr>
<tr valign=top>
<td width=17%><b>w </b></td>
<td width=21%>WORD </td>
<td width=37%>16-bit unsigned value </td>
<td width=25%><i>wPos </i></td>
</tr>
<tr valign=top>
<td width=17%><b>l </b></td>
<td width=21%>LONG </td>
<td width=37%>32-bit signed integer </td>
<td width=25%><i>lOffset </i></td>
</tr>
<tr valign=top>
<td width=17%><b>dw </b></td>
<td width=21%>DWORD </td>
<td width=37%>32-bit unsigned integer </td>
<td width=25%><i>dwRange </i></td>
</tr>
<tr valign=top>
<td width=17%><b>p </b></td>
<td width=21%>* </td>
<td width=37%>Pointer </td>
<td width=25%><i>pDoc </i></td>
</tr>
<tr valign=top>
<td width=17%><b>lp </b></td>
<td width=21%>FAR* </td>
<td width=37%>Far pointer </td>
<td width=25%><i>lpDoc </i></td>
</tr>
<tr valign=top>
<td width=17%><b>lpsz </b></td>
<td width=21%>LPSTR </td>
<td width=37%>32-bit pointer to character string </td>
<td width=25%><i>lpszName </i></td>
</tr>
<tr valign=top>
<td width=17%><b>lpsz </b></td>
<td width=21%>LPCSTR </td>
<td width=37%>32-bit pointer to constant character string </td>
<td width=25%><i>lpszName </i></td>
</tr>
<tr valign=top>
<td width=17%><b>lpsz </b></td>
<td width=21%>LPCTSTR </td>
<td width=37%>32-bit pointer to constant character string if <b>_UNICODE</b> is defined </td>
<td width=25%><i>lpszName</i></td>
</tr>
<tr valign=top>
<td width=17%><b>h </b></td>
<td width=21%>handle </td>
<td width=37%>Handle to Windows object </td>
<td width=25%><i>hWnd </i></td>
</tr>
<tr valign=top>
<td width=17%><b>lpfn </b></td>
<td width=21%>callback </td>
<td width=37%>Far pointer to <b>CALLBACK</b> function </td>
<td width=25%><i>lpfnAbort</i></td>
</tr>
</table><br>
<h3>Know and Use Other MFC Conventions </h3>
<p>
Consistency with MFC helps flatten the learning curve for your users since they will recognize the MFC conventions in your classes and already know what they mean. </p>
<p>
Table 5 shows symbols generated and used by AppWizard and ClassWizard in MFC applications. You can also use these prefixes in classes and resource files in your MFC-friendly classes. </p>
<p class=label>
<b>Table 5. Symbols Used by Applications </b></p>
<table border=1 cellpadding=5 cols=4 frame=below rules=rows>
<tr valign=top>
<td class=label width=15%><b>Prefix </b></td>
<td class=label width=29%><b>Type of Symbol </b></td>
<td class=label width=30%><b>Example </b></td>
<td class=label width=26%><b>Range </b></td>
</tr>
<tr valign=top>
<td width=15%><b>IDR_ </b></td>
<td width=29%>Identification shared by multiple resources of different types. </td>
<td width=30%>IDR_MAINFRAME </td>
<td width=26%>1 to 0x6FFF</td>
</tr>
<tr valign=top>
<td width=15%><b>IDD_ </b></td>
<td width=29%>Dialog resource </td>
<td width=30%>IDD_SPELL_CHECK </td>
<td width=26%>1 to 0x6FFF</td>
</tr>
<tr valign=top>
<td width=15%><b>HIDD_ </b></td>
<td width=29%>Dialog-resource Help context </td>
<td width=30%>HIDD_SPELL_CHECK </td>
<td width=26%>0x20001 to 0x26FF </td>
</tr>
<tr valign=top>
<td width=15%><b>IDB_ </b></td>
<td width=29%>Bitmap resource </td>
<td width=30%>IDB_COMPANY_LOGO </td>
<td width=26%>1 to 0x6FFF </td>
</tr>
<tr valign=top>
<td width=15%><b>IDC_ </b></td>
<td width=29%>Cursor resource </td>
<td width=30%>IDC_PENCIL </td>
<td width=26%>1 to 0x6FFF </td>
</tr>
<tr valign=top>
<td width=15%><b>IDI_ </b></td>
<td width=29%>Icon resource </td>
<td width=30%>IDI_NOTEPAD </td>
<td width=26%>1 to 0x6FFF</td>
</tr>
<tr valign=top>
<td width=15%><b>ID_ _</b></td>
<td width=29%>Command from menu item or toolbar </td>
<td width=30%>ID_TOOLS_SPELLING </td>
<td width=26%>0x8000 to 0xDFFF </td>
</tr>
<tr valign=top>
<td width=15%><b>HID_ </b></td>
<td width=29%>Command Help context </td>
<td width=30%>HID_TOOLS_SPELLING </td>
<td width=26%>0x18000 to 0x1DFFF </td>
</tr>
<tr valign=top>
<td width=15%><b>IDP_ </b></td>
<td width=29%>Message-box prompt </td>
<td width=30%>IDP_INVALID_PARTNO </td>
<td width=26%>8 to 0xDFFF </td>
</tr>
<tr valign=top>
<td width=15%><b>HIDP_ </b></td>
<td width=29%>Message-box Help context </td>
<td width=30%>HIDP_INVALID_PARTNO </td>
<td width=26%>0x30008 to 0x3DFFF</td>
</tr>
<tr valign=top>
<td width=15%><b>IDS_ </b></td>
<td width=29%>String resource </td>
<td width=30%>IDS_COPYRIGHT </td>
<td width=26%>1 to 0x7FFF </td>
</tr>
<tr valign=top>
<td width=15%><b>IDC_ </b></td>
<td width=29%>Control within dialog box </td>
<td width=30%>IDC_RECALC </td>
<td width=26%>8 to 0xDFFF </td>
</tr>
</table><br>
<p>
Table 6 describes some macros used in the framework. For more information on the DEBUG macro, see the article "Diagnostics" in the <i>Visual C++ Programmer’s Guide </i>in the online documentation. The AFXAPI and CALLBACK macros mark specific types of MFC functions. </p>
<p class=label>
<b>Table 6. Configuration Macros Used in MFC </b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=30%><b>Macro Name </b></td>
<td class=label width=70%><b>Type of Macro </b></td>
</tr>
<tr valign=top>
<td width=30%>_AFXDLL </td>
<td width=70%>Stand-alone dynamic-link library (DLL) version </td>
</tr>
<tr valign=top>
<td width=30%>_ALPHA </td>
<td width=70%>Compilation for the DEC Alpha processor only </td>
</tr>
<tr valign=top>
<td width=30%>_DEBUG </td>
<td width=70%>Debug version including diagnostics </td>
</tr>
<tr valign=top>
<td width=30%>_MBCS </td>
<td width=70%>Compilation for multi-byte character sets </td>
</tr>
<tr valign=top>
<td width=30%>_UNICODE </td>
<td width=70%>Enables Unicode in an application </td>
</tr>
<tr valign=top>
<td width=30%>AFXAPI<sup>1</sup></td>
<td width=70%>Function provided by MFC </td>
</tr>
<tr valign=top>
<td width=30%>CALLBACK </td>
<td width=70%>Function called back via pointer </td>
</tr>
</table><br>
<p class=mini>
1. Reserved for use by MFC.</p>
<h2><a name="make your classes"></a>Make Your Classes Flexible</h2>
<p>
The classes you create should be flexible enough to be used in ways you did not originally intend for them to be used. Here are some guidelines for creating flexible classes. </p>
<h3>Limit the Use of "Private" in Your Classes </h3>
<p>
It is important that your users be able to use your MFC-friendly classes in ways that you might not have originally intended. By keeping the majority of member functions, data members, and operators public, you allow for flexibility in their use. In MFC, even functions declared in the //Implementation section of a class are usually public or protected. </p>
<p>
If you are concerned about future changes to functions within your classes that might break functionality, put those functions below the //Implementation line in your code (even if they are declared public). This will indicate that functions in this section should not be relied upon to remain the same in future versions of your classes. </p>
<h3>Remember to Include Virtual Destructors for Your Class </h3>
<p>
Remember to declare virtual destructors for your classes if they include virtual functions. Using virtual destructors, you can destroy objects without knowing their type—the correct destructor for the object is invoked using the virtual function mechanism. For rules on declaring virtual destructors, see "Declaring Destructors" in the C++ Language Reference in the Visual C++ online documentation. </p>
<h3>Allow for Unicode and ANSI Variants in Your Code </h3>
<p>
Portability makes your classes more appealing to other developers. Classes that you write as extensions of MFC should allow for Unicode and ANSI variants so that the code is easy to port to other platforms. By using TCHAR in your code, you have the flexibility of creating generic and Unicode-enabled builds with a few simple changes in the build definition. </p>
<p>
Unicode is available only under Windows NT. For more information on Unicode, see the article "Unicode Programming Summary" in the <i>Visual C++ Programmer’s Guide </i>in the online documentation. </p>
<h3>Make Your Code MBCS-Aware </h3>
<p>
MFC is also fully enabled for multibyte character sets (MBCS), specifically for double-byte character sets (DBCS). DBCS characters are composed of one or two bytes. Some ranges of bytes are set aside for use as "lead bytes." A lead byte specifies that it and the following "trail byte" comprise a single two-byte-wide character. You must keep track of which bytes are lead bytes. </p>
<p>
MBCS is a good alternative to Unicode, and we encourage you to also MBCS-enable classes you write as extensions to MFC. For more information on MBCS, see "Support for Multibyte Character Sets (MBCS)" in the <i>Visual C++ Programmer’s Guide </i>in the online documentation. </p>
<h3>Put Localizable Strings in an Included Resource File </h3>
<p>
If your classes contain strings that need to be localized (translated) because they appear in an interface, be sure to put the strings into your resource file rather than coding them elsewhere in an application. In your header and implementation files, use the functions in MFC that refer to localizable strings by ID number rather than, for example, supplying a caption as an argument in a function. It is much easier to maintain your resources by ID than referring to resources by their values. </p>
<h2><a name="use mfc to create"></a>Use MFC to Create Your Classes </h2>
<p>
Take advantage of the thousands of lines of pretested, versatile code included in the MFC sources to speed construction of your classes. You can leverage the carefully designed code in MFC to save yourself hundreds of hours of work. In addition, by following the recommendations outlined below, your code will be compatible with MFC. </p>
<h3>Derive from Class CObject If Your Class Has Virtual Member Functions </h3>
<p>
If classes you write as extensions to MFC contain virtual functions, be sure to base them on <b>CObject</b>. If your class already has virtual functions, adding the <b>CObject</b> vtbl entries doesn’t add to the size of the object, since you already have the overhead of a vtbl pointer in your object. <b>CObject</b> provides a number of services including serialization, run-time class information, and object diagnostic output. The cost of deriving your class from <b>CObject</b> is minimal: your derived class will have the overhead of four virtual functions and a single <b>CRuntimeClass</b> object. Refer to Table 2 for more information. </p>
<h3>Use Class CString for Manipulating Strings </h3>
<p>
Class <b>CString</b> is a robust, flexible, safe way to manipulate strings in your code. <b>CString</b> can store up to <b>INT_MAX</b> (2,145,483,647) characters, and has a built-in memory allocation feature that allows the <b>CString</b> object to grow if necessary. A <b>CString</b> object can also behave like a literal C-style string, and can be substituted for character pointers in function calls. Although class <b>CString</b> is not implemented as an MFC collection class, <b>CString</b> objects can be stored as elements of a collection. We recommend that you use <b>CString</b> in your MFC-friendly classes. </p>
<h3>Use CString for String Return Values </h3>
<p>
Using class <b>CString</b> for string return values in your classes instead of C-style strings gives you several advantages. 
<ul type=disc>
<li>
<b>CString</b> objects can grow dynamically, but they behave like built-in primitive types and simple classes. When <b>CString</b> objects are copied, MFC increments a reference count rather than copying the data. This makes passing parameters by value and returning <b>CString</b> objects by value more efficient. As a result, a <b>CString</b> is no more "expensive" to use than a normal C++ data type. <br><br></li>
<li>
Beginning with MFC 3.0, you no longer have to write explicit cleanup code for <b>CString</b> objects following an exception. Under the C++ exception handling mechanism that MFC now uses, <b>CString</b> objects are cleaned up for you. <br><br></li>
<li>
Class <b>CString</b> is both Unicode- and MBCS-enabled. By following the conventions outlined in the main article "Strings" and its sub-articles in the <i>Visual C++ Programmer’s Guide </i>(in the online documentation), you can write <b>CString</b> object code that will automatically be handled correctly in either Unicode- or MBCS-enabled builds of your application. </li>
</ul>
<h3>Provide CString Overloads When Advantageous </h3>
<p>
Make conversions between your own data types and class <b>CString</b> as easy as possible. Using <b>CString</b> parameters is often more convenient than using <b>LPCTSTR</b>. This is especially true if the parameter can contain embedded <b>NUL</b> characters, or if the function requires a separate length parameter. A good example for study is <b>CDC::TextOut.</b> </p>
<h3>Use CDC* and CWnd* When Possible </h3>
<p>
Use pointers to the MFC <b>CWnd</b> and <b>CDC</b> objects rather than <b>hWnd</b> or <b>hDC</b> handles in Windows. MFC’s encapsulation of the Windows functionality in these classes provides some advantages to using these objects over the direct use of the equivalent Windows handles: </p>
<p>
If a temporary C++ object is needed to encapsulate an <b>hWnd</b> or <b>hDC</b>, the object is created for you by MFC and destroyed automatically when the object goes out of scope. </p>
<p>
<b>CDC</b> and <b>CWnd</b> present a simpler interface to most of the Windows APIs they encapsulate.</p>
<h3>Create MFC Extension DLLs from Your Classes </h3>
<p>
The most effective way to make the classes you write available to users is to create an MFC Extension Dynamic Link Library (DLL). Extension DLLs can be prepared in a variety of formats. For example, you can create versions that are Unicode-enabled or not, debug or retail, and so on. </p>
<p>
The Extension DLLs for MFC use the following naming conventions. The library names have the form </p>
<p>
<i>u</i>AFX<i>CWd</i>.LIB </p>
<p>
where the letters shown in italic lowercase are place holders for specifiers, as shown in Table 7. </p>
<p class=label>
<b>Table 7. Library Naming Conventions </b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=31%><b>Specifier </b></td>
<td class=label width=69%><b>Values and Meaning</b></td>
</tr>
<tr valign=top>
<td width=31%>u </td>
<td width=69%>ANSI (N) or Unicode (U)</td>
</tr>
<tr valign=top>
<td width=31%>d </td>
<td width=69%>Debug or Release: D=Debug; omit specifier for Release</td>
</tr>
</table><br>
<p>
Table 8 shows examples of how static versions of the MFC libraries are prepared and named. </p>
<p class=label>
<b>Table 8. Static Library Versions </b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=34%><b>Library </b></td>
<td class=label width=66%><b>Description </b></td>
</tr>
<tr valign=top>
<td width=34%>NAFXCWD.LIB </td>
<td width=66%>Debug version: MFC Static Link Library </td>
</tr>
<tr valign=top>
<td width=34%>NAFXCW.LIB </td>
<td width=66%>Release version: MFC Static Link Library </td>
</tr>
<tr valign=top>
<td width=34%>UAFXCWD.LIB </td>
<td width=66%>Debug version: MFC Static Link Library with Unicode support </td>
</tr>
<tr valign=top>
<td width=34%>UAFXCW.LIB </td>
<td width=66%>Release version: MFC Static Link Library with Unicode support </td>
</tr>
</table><br>
<p>
We recommend that you prepare your MFC-friendly classes as an MFC Extension Dynamic Link Library (DLL) or as a static library (LIB) using a variation of the naming scheme described above. </p>
<p>
Table 9 describes the macros that are used in the creation of MFC Extension DLLs. </p>
<p class=label>
<b>Table 9. Macros Used With Dynamic Link Libraries (DLLs) </b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=40%><b>Macro Name </b></td>
<td class=label width=60%><b>Type of Macro</b></td>
</tr>
<tr valign=top>
<td width=40%>_AFXDLL </td>
<td width=60%>Stand-alone dynamic-link library (DLL) version </td>
</tr>
<tr valign=top>
<td width=40%>WINAPI </td>
<td width=60%>Function provided by Windows </td>
</tr>
</table><br>
<p>
For more information on creating an MFC Extension DLL, see the article "DLLs: Building and Using an Extension DLL" in the <i>Visual C++ Programmer’s Guide </i>in the online documentation. </p>
<h3>Use #pragma comment to Conditionally Include Your Classes </h3>
<p>
The #pragma directives offer a way for a compiler to offer machine- or operating system-specific features while retaining overall compatibility with the C++ language. MFC uses the #pragma comment preprocessor directive in AFX.H to determine which version of the MFC library to link with an application when it is compiled. </p>
<p>
You can use the same method to assist your users in determining which version of your MFC Extension DLL the compiler should use. </p>
<p>
For example, the following code fragment from the AFX.H header file instructs the linker to link in either the NAFXCWD.LIB or NAFXCW.LIB version of MFC, depending on whether you are using the debug version of MFC: </p>
<pre><code>#ifndef _UNICODE 
#ifdef _DEBUG 
#pragma comment(lib, "nafxcwd.lib") 
#else 
#pragma comment(lib, "nafxcw.lib") 
#endif 
#else 
#ifdef _DEBUG 
#pragma comment(lib, "uafxcwd.lib") 
#else 
#pragma comment(lib, "uafxcw.lib") 
#endif 
#endif... 
</code></pre>
<p>
For more information on the #pragma comment preprocessor directive, see "Pragma Directives" and "MFC Library Versions" in the Visual C++ Programmer’s Guide, both found in the online documentation (MSDN Library, Developer Products, Visual C++). </p>
<h2><a name="write thorough"></a>Write Thorough Documentation to Help Your Users </h2>
<p>
When you finish writing your classes, make sure that users understand and can use the full potential of your work by documenting the classes thoroughly. Writing good reference documentation is important, but you can also write encyclopedia articles, technical notes, and samples help that explain how to use the classes. The MFC documentation has a consistent and accessible style that we describe in the remaining sections of this paper. </p>
<p>
The documentation included with the Microsoft Foundation Class Library consists of the Class Library Reference, the MFC Technical Notes, MFC-specific articles in the Visual C++ Programmer’s Guide, the sample abstracts that accompany the MFC Samples, and tutorials found in the Visual C++ Tutorials. The MFC documentation in general has a clear, friendly style that avoids the use of jargon and obscure terms. </p>
<p>
The Visual C++ documentation uses a common set of conventions that assist readers in identifying elements of documentation such as code, keyboard key names, procedures, and so on. We suggest that you follow these conventions as you prepare documentation for the classes you write as extensions to MFC. Here are the Documentation Conventions used in the Visual C++ online documentation. </p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=30%><b>Example </b></td>
<td class=label width=70%><b>Description </b></td>
</tr>
<tr valign=top>
<td width=30%>STDIO.H </td>
<td width=70%>Uppercase letters indicate filenames, segment names, registers, and terms used at the operating-system command level. </td>
</tr>
<tr valign=top>
<td width=30%>expression </td>
<td width=70%>Words in italics indicate placeholders for information you must supply, such as a filename. Italic type is also occasionally used for emphasis in the text. </td>
</tr>
<tr valign=top>
<td width=30%>char, _setcolor, _ _far </td>
<td width=70%>Bold type indicates keywords, operators, language-specific characters, and library routines. Within discussions of syntax, bold type indicates the text must be entered exactly as shown. <br>
 &nbsp;&nbsp;&nbsp; Many functions and constants begin with either a single or double underscore. These are part of the name and are mandatory. For example, to have the _ _cplusplus manifest constant be recognized by the compiler, you must enter the leading double underscore.</td>
</tr>
<tr valign=top>
<td width=30%>[option] </td>
<td width=70%>Items inside square brackets are optional. </td>
</tr>
<tr valign=top>
<td width=30%>#pragma pack {1 | 2} </td>
<td width=70%>Braces and a vertical bar indicate a choice among two or more items. You must choose one of these items unless square brackets surround the braces: [ { | } ]. </td>
</tr>
<tr valign=top>
<td width=30%>#include &lt;io.h&gt; </td>
<td width=70%>This font is used for examples, user input, program output, and error messages in text. </td>
</tr>
<tr valign=top>
<td width=30%>CL [option...] file... </td>
<td width=70%>Three dots (an ellipsis) following an item indicate that more items having the same form can appear. </td>
</tr>
<tr valign=top>
<td width=30%>while()<br>
.<br>
.<br>
.<br>
}</td>
<td width=70%>A column or row of three dots tells you that part of an example program has been intentionally omitted.</td>
</tr>
<tr valign=top>
<td width=30%>CTRL+ENTER </td>
<td width=70%>Small capital letters are used to indicate the names of keys on the keyboard. When you see a plus sign (+) between two key names, you should hold down the first key while pressing the second.<br>
 &nbsp;&nbsp;&nbsp; The carriage-return key, sometimes marked as a bent arrow on the keyboard, is called ENTER.</td>
</tr>
<tr valign=top>
<td width=30%>"argument" </td>
<td width=70%>Quotation marks enclose a new term the first time it is defined in text. </td>
</tr>
<tr valign=top>
<td width=30%>"C string" </td>
<td width=70%>Some C constructs, such as strings, require quotation marks. </td>
</tr>
<tr valign=top>
<td width=30%>Color/Graphics Adapter (CGA) </td>
<td width=70%>The first time an acronym is used, it is usually spelled out. </td>
</tr>
</table><br>
<h3>Match the Structure and Conventions of the MFC Reference </h3>
<p>
The Class Library Reference is the cornerstone of the MFC documentation. This volume contains descriptions of all of the class members in the Library that appear above the //Implementation line in the MFC source code. Each class has a corresponding Overview, Member Functions list, and individual descriptions of the member functions, data members, and operators in each class. We recommend that you follow this structure and the conventions in this book to make it easy for your users to find the information they need. </p>
<h3>Write Class Overviews and Member Function Lists </h3>
<p>
The individual class Overviews describe the class in just enough detail to help developers decide whether this is the class they want. The Overview points readers to articles in the <i>Visual C++ Programmer’s Guide </i>for details. Here’s what a class overview should do: 
<ul type=disc>
<li>
Describe the purpose of an object of the class (a sentence or two). If the class is a base class used only for deriving other classes, make this clear. In the See Also section below the class overview, list the important classes derived from this class as well as any other related classes. <br><br></li>
<li>
Provide essential caveats and instructions, e.g. "You must derive an application-specific class...." <br><br></li>
<li>
Provide a concise description of how to use the class. This description is aimed at developers who don’t want or need to navigate through the encyclopedia because they basically understand the class and are ready to use it. The thumbnail is a reminder of basic usage, in a short paragraph. <br><br></li>
<li>
Refer the reader to the appropriate encyclopedia article(s) for further information. This is the valuable link to conceptual and procedural information that many developers will want.</li>
</ul>
<p>
The Member Functions list in each class corresponds to sections that appear in MFC source code. In some classes, additional sections in the Class Library Reference further categorize the member functions to make them easy to locate. Each member function, data member, and operator in a class should have an entry in the list, along with a one or two sentence description. </p>
<h3>Write Detailed Member Function Descriptions </h3>
<p>
Each member function, data member, and operator that appears above the //Implementation line in the class has an individual description. Each description has one or more of the following six sections that appear in a specific order: 
<ul type=disc>
<li>
Function name <br><br></li>
<li>
Syntax line <br><br></li>
<li>
Return Value <br><br></li>
<li>
Parameter descriptions <br><br></li>
<li>
Remarks section <br><br></li>
<li>
Example <br><br></li>
<li>
“See Also” cross references</li>
</ul>
<p>
When viewed online, the See Also entries include hypertext jumps to the individual class Overview, the list of Class Member functions, and the Hierarchy Chart that applies to the class, as well as cross references to other member functions in that class. </p>
<p>
Note carefully the use of bold, italics, and alternate fonts in the documentation. These help readers distinguish between example code, syntax, and parameters. Whenever the Windows API functions are cited, they are preceded with the global scoping operator ( for example, <b>::GetSystemMetrics</b>). </p>
<h3>Write Encyclopedia Articles for Your Classes (Optional) </h3>
<p>
The <i>Visual C++ Programmer’s Guide </i>is a procedural and encyclopedic manual that contains articles that describe aspects of programming with C++ and MFC. The articles in this book offer both an overview and procedures you can use in specific situations by functional area. Table 10 describes characteristics of the sections of the <i>Visual C++ Programmer’s Guide.</i> </p>
<p class=label>
<b>Table 10. Articles in the Visual C++ Programmer’s Guide </b></p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=20%><b>Purpose </b></td>
<td class=label width=40%><b>Description </b></td>
<td class=label width=40%><b>Level of Information</b></td>
</tr>
<tr valign=top>
<td width=20%>Overview </td>
<td width=40%>Descriptions of the topic with links to further information </td>
<td width=40%>High-level overviews, e.g. "Database Overview" </td>
</tr>
<tr valign=top>
<td width=20%>How Do I? </td>
<td width=40%>Lists of tasks with links to further information </td>
<td width=40%>Lists of possible tasks </td>
</tr>
<tr valign=top>
<td width=20%>Frequently Asked Questions </td>
<td width=40%>Short answers to common questions with links to other information. </td>
<td width=40%>Easy to find information </td>
</tr>
<tr valign=top>
<td width=20%>Details </td>
<td width=40%>Procedural articles and sub-articles </td>
<td width=40%>In-depth conceptual and procedural information </td>
</tr>
</table><br>
<p>
Including encyclopedic articles with your MFC-friendly class documentation is optional. Nevertheless, we encourage you to at least include a conceptual overview of the uses of your classes (in addition to the one in the Reference section) so that developers can take full advantage of the power and flexibility in your classes. By providing adequate documentation up front, you can avoid or reduce costly product support calls, and ensure customer satisfaction both now and in the future. </p>
<h3>Balance Conceptual Information Between Overviews and Articles </h3>
<p>
Ideally, a class overview included with reference material should contain a short description of the class, a set of high-level procedures for using the class, and cross-references to similar or related classes. The class overview should serve as a quick summary that a developer can read to decide whether the class you have written is the appropriate class for their need. Save any lengthy or detailed descriptions of the class usage for encyclopedic articles. </p>
<h3>Prepare Technical Notes (Optional) </h3>
<p>
The MFC Technical Notes "are written by developers for developers." The Technical Notes cover advanced techniques in specific areas, and offer a level of technical detail that average developers don’t normally require to do their work. </p>
<p>
Writing technical notes for your MFC-friendly classes is optional. When used sparingly and for very specific situations, technical notes can be an invaluable resource for unusual situations. Review the MFC Technical Notes for ideas on how you can write your own to your best advantage. </p>
<h3>Write Help Files for Your MFC Samples </h3>
<p>
Sample code is an essential part of any documentation, and providing sample applications for your users is the best way for them to understand the intent and usage of your MFC-friendly classes. MFC provides a substantial number of samples as part of their documentation, and abstracts of each MFC sample appear in Visual C++ Samples, MFC Samples, in the online documentation. </p>
<p>
The MFC Samples abstracts contain individual descriptions of the features of the sample. You can find an alphabetical list of samples and a cross-reference index by subject under "MFC Samples Index" in Visual C++ Samples in the online documentation. </p>
<p>
We highly recommend that you document your samples in a similar help file. Developers can refer again and again to these descriptions to help them locate code they can use in their own applications. </p>
<h2><a name="in conclusion"></a>In Conclusion</h2>
<p>
We have covered general principles for developing "MFC-friendly" classes, given examples of how to make your classes robust as well as practical, and outlined methods for documenting your work. We encourage you to follow up on references to the documentation for more information on these principles. You can also get help in class design from the sources listed below. </p>
<h3>CompuServe Forums </h3>
<h4>Developer forums</h4>
<p>
These forums cover developer-specific information on the Windows operating system, languages, tools, and utilities. (For example, you can find forums on development products by typing GO MSDEVPROD.) You can use these forums to exchange messages with experienced users of Microsoft development products. Microsoft support engineers act as section leaders and monitor the forums to ensure complete and accurate information flow and to provide general technical information on Microsoft development products. </p>
<h4>Developer Knowledge Base </h4>
<p>
This comprehensive database contains more than 40,000 detailed articles with technical information about Microsoft development products, bug lists, fix lists, documentation errors, and answers to common technical support questions. The Knowledge Base is a primary Microsoft product information source used daily by Microsoft support engineers. You can search the Knowledge Base by keyword, and files can be downloaded for local use. Many Microsoft Knowledge Base articles have associated Software Library items (MSDN Library, Knowledge Base).</p>
<h4>Software Library </h4>
<p>
This Library contains sample programs, device drivers, patches, software updates, programming aids, and downloadable application notes and white papers. The entire library can be searched by keyword, and the files can be downloaded for local use. To help you quickly evaluate items, a brief text description is displayed when you view each item. Additionally, many Software Library items have associated Microsoft Knowledge Base articles that more fully discuss the subject. For the Software Library, type GO MSL.</p>
</BODY>
</HTML>
