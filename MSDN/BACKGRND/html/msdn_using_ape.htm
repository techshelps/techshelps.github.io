<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using APE: A User's Guide to the Application Performance Explorer</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_using_ape"></a>Using APE: A User's Guide to the Application Performance Explorer</h1>
<p>
Microsoft Corporation</p>
<p>
1996</p>
<h2>Abstract</h2>
<p>
The Application Performance Explorer (APE) is a software utility written in Microsoft Visual Basic® to aid in the design, deployment planning, and performance tuning of distributed client-server applications. It allows you to easily run automated "what-if" tests to profile the performance of a multitier application in different network topologies, taking into consideration such factors as network bandwidth, request frequency, data transfer requirements, server capacity, and so on.</p>
<p>
In addition, APE is itself an example of a well-designed distributed application. Its Visual Basic source code is well commented and structured to serve as a "template" for component-based client-server applications. This source code can easily be used as the starting point for a custom multitier solution.</p>
<p>
This document describes the models of remote deployment supported by APE, followed by instructions for setting up and using the tool. Finally, a brief discussion of component-based design and performance-tuning issues is presented.</p>
<h2>Performance Profiling in a Distributed Environment</h2>
<p>
Multitier client-server applications partition functionality into separate components that can be distributed on the network in a wide variety of physical deployment configurations. The key performance issue for the designers of these distributed applications is not tuning raw code execution, but determining the optimum network topology for a distributed solution. Developers today need design assistance to determine:
<ol>
<li>
<b>Granularity:</b> How should objects and services be grouped into physical components?<br><br></li>
<li>
<b>Deployment:</b> Where should each component go in order to achieve the required performance?</li>
</ol>
<p>
The Application Performance Explorer helps answer these questions by allowing you to quickly set up test cases in various network configurations and to measure performance under different conditions. Exploring alternative scenarios with APE can shed light on questions such as:
<ul type=disc>
<li>
Is it more efficient to package services in a single, large component or to break up functionality among many smaller components?<br><br></li>
<li>
Is it better to deploy a particular computation-intensive task on a remote server in order to take advantage of superior computing resources, or on the local desktop machine to minimize network traffic?<br><br></li>
<li>
What is the effect upon my solution when adding more clients?<br><br></li>
<li>
Where are the bottlenecks of my solution during the worst network conditions?<br><br></li>
<li>
What happens to performance when requests to a back-end server exceeds its capacity?</li>
</ul>
<p>
To understand the significance of the various factors APE allows you to benchmark, it is necessary to understand the basics of remote component deployment. The following section briefly covers the models of remote deployment supported by APE. If you are already familiar with these models, you may wish to skip ahead to the section titled <a href="#usingape">"Using APE,"</a> later in this document.</p>
<h2>Remote Deployment Models</h2>
<p>
Remote components can be deployed either <i>synchronously</i> or <i>asynchronously</i>. Each of these approaches has its advantages and disadvantages. Different parts of your application can use different models, depending on the needs of the tasks being implemented.</p>
<p>
APE provides built-in models for remotely executing and managing objects both synchronously and asynchronously. These models are described below.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;In the discussion that follows, you will notice that APE models remote tasks using two separate components working closely together: a <i>worker</i> and a <i>service</i>. This is good component-based design, separating the execution context (worker) from the actual computational routines or business services (service). Since remote components are most efficiently packaged as in-process servers, they need a process space on the remote machine in which to execute. The worker component provides this process space and execution thread, while the service encapsulates the application-specific functionality.</p>
<h3>The Synchronous (Direct Instantiation) Model</h3>
<p>
The Application Performance Explorer implements synchronous connections as a direct request from a client application to an object that lives on a remote network server. Because the connection is synchronous, the client application waits for the task to be completed and is blocked until the server returns.</p>
<p>
<img src="usingape_1.gif" border=0></p>
<p class=label>
<b>Figure 1. The Synchronous Model</b></p>
<p>
As shown in the illustration above, (1) the Client creates a Worker, which in turn creates a Service that performs the work. When the Service is finished, both the Worker and Service are destroyed. (2) Additional Clients create additional Workers and Services, never sharing them with other Clients.</p>
<p>
Direct object instantiation and executing repeated calls on a method is most useful for exploring network latency. Changing calling parameters and return value sizes can help determine "over-the-wire" throughput, which can be useful in deciding which components should be run across a network on remote computers and which should remain together on a single machine.</p>
<h3>The Asynchronous (Queued Objects) Model</h3>
<p>
One of the limitations of the direct approach is the overhead involved in starting the Worker and Service objects. When a Client is done with a Worker, both the Worker and Service are destroyed.</p>
<p>
A better approach is to keep Workers "alive" and reduce the overhead of initializing them. There are a number of approaches to this, including "Pool Manager" and "Queue Manager" scenarios. APE implements a Queue Manager, as shown below.</p>
<p>
<img src="usingape_2.gif" border=0></p>
<p class=label>
<b>Figure 2. The Asynchronous Model</b></p>
<p>
In the simplest case, (1) the Queue Manager creates a given number of Workers, all of them initially having a "not busy" status. (2) When a Client request comes in, the Queue Manager allocates a Worker, marks it as "busy," (3) uses the Worker to perform the Service until it is completed, and changes its status back to "not busy." (4) The Queue Manager accepts all requests and allocates Workers on a first-come, first-served basis:</p>
<p>
Because the Queue Manager maintains its queue internally, Client requests are never refused. If all pre-allocated workers are busy, the Queue Manager simply waits until one becomes available and assigns it to the next waiting Client in turn. In distributed solutions, such a queue can be used to keep workers busy. This results in servers running at their optimum performance level—that is, fully loaded.</p>
<h3>The Queued Objects Model with Callbacks</h3>
<p>
The Queue Manager illustrated in Figure 2 showed only the minimum steps necessary to accomplish the work. No provision was made for either returning status information to the Client or logging transaction information for administrative purposes.</p>
<p>
In general, return information can be conveyed in one of two ways: either synchronously through a return value, or asynchronously through an indirect notification mechanism. As discussed earlier, the synchronous (direct) method results in the Client program being blocked waiting for the return to complete. For asynchronous operations, a separate notification mechanism is required. OLE callbacks, available in Visual Basic, provide such a mechanism. Callbacks allow the Client to continue processing and be notified asynchronously when the Server side has something relevant to report.</p>
<p>
To use callbacks in the Queue Model, an additional component—the Expediter—is used to queue return information back to the Client.</p>
<p>
<img src="usingape_3.gif" border=0></p>
<p class=label>
<b>Figure 3. The Queued Objects Model with callbacks</b></p>
<p>
In operation, the Client implements an internal Callback class with a predefined method.
<ol>
<li>
The Client then creates an instance of that Callback object and passes a pointer to it to the Queue Manager, along with its work request.<br><br></li>
<li>
The Queue Manager in turn calls the Worker, passing the Callback object pointer.<br><br></li>
<li>
When the task is completed, the Worker calls the Expediter with the return information, once again passing along the pointer to the Callback object.<br><br></li>
<li>
Finally, the Expediter calls back asynchronously into the Client object.</li>
</ol>
<p>
This diagram also illustrates the Queue Manager, Worker, and Expediter all feeding into a Logger.</p>
<h2><a name="usingape"></a>Using APE</h2>
<p>
The Application Performance Explorer has been designed to help you explore the distributed application scenarios outlined above in your environment and on your own machines. Building on the above models, the Application Performance Explorer allows you to control a variety of parameters and determine their overall impact on your application. While DPE includes implementations for all distributed models using "empty" routines, DPE is designed to let you easily specify your own component objects as the Service.</p>
<p>
The Application Performance Explorer consists of a single application window comprising three areas: the upper area allows you to load or save a "profile" of the connections and settings to conduct a particular test, the middle area contains tabs for controlling the parameters of each of the components, and the lower area contains summary statistics.</p>
<p>
<img src="usingape_4.gif" border=0></p>
<p class=label>
<b>Figure 4. APE application window</b></p>
<h3>Setting Up and Testing APE</h3>
<p>
Three separate setups are provided, as described below:
<ol>
<li>
<b>Manager installation.</b> This setup installs all the components necessary to use APE on one machine. The Manager user interface, the server components, and the Client are all included.<br><br></li>
<li>
<b>Server installation.</b> This setup installs only the server components on a machine. Use this setup if you want to use a machine as a server but do not want to use the Manager or any Clients.<br><br></li>
<li>
<b>Remote Client installation.</b> This setup installs just the Client on a machine to be used for creating remote Clients in a multiple-client scenario.</li>
</ol>
<p>
The Manager installation includes all components necessary to use the Application Performance Explorer, including server-side components. APE is fully functional when run on a single machine; although in this configuration, it is unable to remote server-side components. To quickly use APE, run the client setup on one machine, start the application, choose any provided profile, and click Start.</p>
<p>
To perform a remote test, it is necessary to use the APE Server or Remote Client installation on a second machine, to ensure that a network connection is possible, and to set remote automation permissions on the server components.</p>
<p>
During setup on the second (or server) machine, permissions will be set to allow remote activation on the classes used by APE:
<ul type=disc>
<li>
AELogger.Logger<br><br></li>
<li>
AEPoolMgr.PoolMgr<br><br></li>
<li>
AEQueueMgr.QueueMgr<br><br></li>
<li>
AEServerMgr.ServerMgr<br><br></li>
<li>
AEWorker.Worker</li>
</ul>
<p>
Note that the permissions can later be modified using the "Remote Automation Connection Manager," which can be found in the "Remote Automation Management" folder or program group. To perform the remote test:
<ul type=disc>
<li>
Start "Automation Manager" in the "Remote Automation Management" folder or program group on the server.<br><br></li>
<li>
Start the Application Performance Explorer on the client machine.<br><br></li>
<li>
Choose an Asynchronous profile from the drop-down list.<br><br></li>
<li>
Click the <b>Connection</b> tab. Check the <b>Remote Connection</b> box, enter the machine name of the server, and choose a Protocol and Authentication Level that both machines support.<br><br></li>
<li>
Click Apply to cause the connection settings to take effect.</li>
</ul>
<h3>Configuring the Component Objects</h3>
<p>
Each of the supported models for distributing components uses the same set of component object types, with user settings to control various aspects of their functionality. The APE Manager interface contains tabs for each of these component types, the settings of which collectively become the "profile" of the scenario to be modeled.</p>
<p>
Each component type independently provides the option of displaying status forms and logging event information. These features are enabled by selecting the two check boxes at the bottom of each tab.</p>
<p>
When the configuration options for each object type have been entered, click the "+" button to the right of the Profile list box to save your settings as a new profile.</p>
<h4>Clients</h4>
<p>
The major Client parameters are the number of Clients to be created, the number of calls that each Client makes, and—if used—the size of the data to be passed. Varying the number of Clients is useful for "loading" the system and for examining the advantages of a queue manager with extremely large numbers of Clients. Note that it is often impractical to setup 100 or more PCs to test the effect of a large number of users connected to the system. It is, however, more practical to set up 10 clients and increase the call frequency to simulate high-traffic conditions.</p>
<p>
The number of calls is most useful for examining the effect of "component persistence": when a component stays in memory between calls, the system spends less time creating and destroying objects and can support a much higher volume of work. Varying the size and type of the data can also be useful in discovering major performance drop-offs in network throughput.</p>
<p>
If remote clients will be used in your test, select the <b>Remote Clients</b> check box to enable the <b>Configure…</b> command button. This brings up a <b>Client Machines</b> dialog box to specify their addresses and connection information.</p>
<p>
<img src="usingape_5.gif" border=0></p>
<p class=label>
<b>Figure 5. APE Manager: Clients tab</b></p>
<h4>Asynchronous</h4>
<p>
The <b>Asynchronous</b> tab configures the Queue and Expediter components, which are only used in the Asynchronous models, as described earlier in this document. If you select a Synchronous model, the tab changes to Synchronous and the options are disabled.</p>
<p>
<img src="usingape_6.gif" border=0></p>
<p class=label>
<b>Figure 6. APE Manager: Asynchronous tab</b></p>
<h4>Worker</h4>
<p>
The Worker component presents four configurable parameters.
<ul type=disc>
<li>
<b>Number of Workers.</b> As previously indicated, this is only relevant for the Asynchronous Queue model. It determines the number of worker objects that are "pre-instantiated" by the queue.<br><br></li>
<li>
<b>Early Bind Services.</b> Object controllers can bind to object interfaces in one of two ways: late binding using the IDispatch mechanism or early binding using a vTable. In general, object variables that are dimensioned "as Object" are late bound: each method or property address is looked up at <i>run time</i>. Object variables that can take advantage of type libraries and be dimensioned as <i>specific</i> object types (for instance, "as Worksheet") at <i>compile time </i>are said to be early bound. Early binding offers a number of advantages, the most important of which is substantially better performance.<br><br></li>
<li>
<b>Retain Service References.</b> In many object models, an object is created, used, and destroyed each time it is called. Setting this option allows the Worker to keep the Service object in memory for repeated calls against the same object. This is most useful in the Queue Manager model. In the Direct model, this option only has an effect if the number of calls (set on the <b>Clients</b> tab) is greater than 1.<br><br></li>
<li>
<b>Preload Services.</b> Workers are created in the Queue Manager model before any Client requests are processed. This option forces the Worker, when instantiated, to load its corresponding Service. Setting this option eliminates this overhead from the performance log.</li>
</ul>
<p>
<img src="usingape_7.gif" border=0></p>
<p class=label>
<b>Figure 7. APE Manager: Workers tab</b></p>
<h4>Services</h4>
<p>
The Service component included with the Application Performance Explorer simulates real work: it can be made to take a specific amount of time to complete and—when investigating loads on server machines—use up processor time.</p>
<p>
Regardless of the work simulation determined by these settings, the only "real" work performed by APE's built-in Service components, is to return the data requested by the Client. For more accurate measurement, you can substitute your own object method as a Service. To do this, you specify a string of the form "<b>Library.Class.Method</b>," where <b>Library</b> is typically the name of your object server, <b>Class</b> corresponds to one of its publicly exposed object classes, and <b>Method</b> is any method implemented by the Class that requires no parameters.</p>
<p>
<img src="usingape_8.gif" border=0></p>
<p class=label>
<b>Figure 8. APE Manager: Services tab</b></p>
<h4>Logger</h4>
<p>
The Logger component simply builds a .LOG (text) file to record the step-by-step progress of your test and the actions of each of its components. Because of the performance impact of logging to disk, the log can be maintained in memory and written either when the scenario is completed or when a predefined maximum log size is reached.</p>
<p>
<img src="usingape_9.gif" border=0></p>
<p class=label>
<b>Figure 9. APE Manager: Logger tab</b></p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;APE is configured to launch the Windows Notepad program to view the log, in response to pressing the View button. In some cases, however, the log file can grow quite large and exceed the capacity of Notepad. If you encounter a message indicating that the file is too large, manually open the file with another viewing program, or rerun the tests with less logging information or for a shorter duration.</p>
<h4>Connection</h4>
<p>
The <b>Connection</b> tab is used to configure the connection to the remote object classes. It can be used for Remote Automation and—if the system supports it—Distributed COM (DCOM). The <b>Connection</b> tab is merely a single interface for remoting all the object classes used by the Application Performance Explorer: it simplifies the remoting process described in the section "Setting Up and Testing APE" earlier in this article.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;In order to use Distributed COM (DCOM), you must be using Windows NT 4.0.</p>
<p>
<img src="usingape_10.gif" border=0></p>
<p class=label>
<b>Figure 10. APE Manager: Connection tab</b></p>
<h2>Interesting Questions to Explore</h2>
<p>
The Application Performance Explorer is a flexible and powerful tool, and there are a number of interesting questions you can answer with it. Most importantly, you can directly examine the effects on throughput of varying the major input parameters: the number of calls, the size of objects, whether the Service is in-process or out-of-process, and so on.</p>
<p>
Other questions APE can help you explore include:
<ul type=disc>
<li>
What performance advantages does early binding offer over late binding?<br><br></li>
<li>
What will happen to your model when you exceed net capacity?<br><br></li>
<li>
What is the effect on performance of using asynchronous notification?<br><br></li>
<li>
What is the effect on performance of detailed event logging?<br><br></li>
<li>
What is the optimum component size for my environment? By varying the Service parameters and even substituting your own Service component, you can examine different component sizes and help determine how granular your components should be.<br><br></li>
<li>
What is the best network protocol? Using the Protocol parameter found on the <b>Connection</b> tab, it's possible to communicate with remote objects using any installed RPC transport protocol.<br><br></li>
<li>
What is the appropriate level of call security? Using the Authentication parameter found on the <b>Connection</b> tab, it's possible to set RPC authentication to any of the supported values. In general, higher levels of authentication have increased overhead: controlling this parameter helps you determine the effect that call security has on your application.<br><br></li>
<li>
What are the queue dynamics when work is done also being done on the queue system? Since you can control whether the Service uses processor cycles, you can simulate whether the queue operates on a dedicated system or is passed off to yet another remote server.<br><br></li>
<li>
How will the response time of my clients be affected when any of these things happen?</li>
</ul>
<p>
The first and most important question that a designer must answer in considering how best to take advantage of the potential for distributed computing—and whether a specific application task should in fact be remotely executed—is this: <i>Is the overhead associated with the remoting worth the benefit?</i></p>
<p>
To answer this question a number of performance, maintenance, and administrative factors must be considered. No tool can answer all of these questions, but the Application Performance Explorer can go a long way toward answering the most important <i>performance</i> questions.</p>
<h3>Design and Performance Factors</h3>
<p>
Considered most broadly, the question of whether or not to remotely deploy a particular task requires considering the following parameters:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=36%>Task size (TS)</td>
<td width=64%>How big is the task being considered for remoting?</td>
</tr>
<tr valign=top>
<td width=36%>Request frequency (RF)</td>
<td width=64%>How often does the task need to be executed? This includes requests from all users, not just a single desktop machine.</td>
</tr>
<tr valign=top>
<td width=36%>Network bandwidth (NB)</td>
<td width=64%>What is the raw speed of the network cable, network interface card(s), network protocol, RPC, and drivers, as well as the collision/retry overhead caused by network traffic?</td>
</tr>
<tr valign=top>
<td width=36%>Data transfer requirements (DT)</td>
<td width=64%>How much data needs to be transferred to and from the task? (Note: In some cases this may be negative because the location of the task on a remote server may actually reduce data transfer requirements to the desktop.)</td>
</tr>
<tr valign=top>
<td width=36%>Desktop system capacity (DC)</td>
<td width=64%>Primarily, what is the raw bandwidth of the desktop system's CPU(s), Memory, Disk I/O, and other I/O devices that are needed to process the task?</td>
</tr>
<tr valign=top>
<td width=36%>Remote system capacity (RC)</td>
<td width=64%>Primarily, what is the raw bandwidth of the remote system's CPU(s), Memory, Disk I/O, and other I/O devices that are needed to process the task?</td>
</tr>
<tr valign=top>
<td width=36%>Desktop opportunity cost (DO)</td>
<td width=64%>What could the desktop machine be doing if it were not running the task?</td>
</tr>
<tr valign=top>
<td width=36%>Server opportunity cost (SO)</td>
<td width=64%>What could the server being doing if it were not running the task?</td>
</tr>
<tr valign=top>
<td width=36%>Desktop resource burden (DB) </td>
<td width=64%>Primarily, what burdens do the OS and other applications impose on the desktop system?</td>
</tr>
<tr valign=top>
<td width=36%>Shared resource burden (SB) </td>
<td width=64%>Primarily, what burdens do the OS and other applications impose on the shared system?</td>
</tr>
<tr valign=top>
<td width=36%>Application design &amp; implementation (AD)</td>
<td width=64%>How efficiently are the above factors considered in the design and implementation of an application? (Note: Because of the simplicity of Visual Basic 4.0 and Remote Automation, the programming question of how hard it is to use the resources of a remote system vs. the resources of a desktop system is not considered a factor.)</td>
</tr>
<tr valign=top>
<td width=36%>Centralized administration</td>
<td width=64%>What is the benefit of administrating or updating the task from a centralized location rather than each desktop.</td>
</tr>
</table><br>
<h3>The General Equation</h3>
<p>
From the parameters listed above, it is possible to compose a general "equation" to answer the question of whether to remote a task or not:</p>
<p class=indent>
If DO or CA is "big enough" or if (DO &gt; SO and f(TS, DC, DB) &gt; f(TS, RF, NB, DT, RC, SB, AD)) then the task should be remoted.</p>
<p>
Obviously, it will usually be impossible to find a simple quantitative answer to this equation. Its purpose here is primarily to expose the issues so that the factors that are important in any particular scenario can be examined in sufficient detail. The Application Performance Explorer, along with prototyping and other analytical tools, can provide meaningful insights and measurable answers to many of these questions.</p>
</BODY>
</HTML>
