<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Holding State in Objects with Microsoft Transaction Server</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_state"></a>Holding State in Objects with Microsoft Transaction Server</h1>
<p>
Microsoft Corporation</p>
<p>
June 1997</p>
<h2>Abstract</h2>
<p>
Although there are many benefits to using stateless Microsoft® Transaction Server (MTS) objects, there are cases where holding state is desirable. This article provides some guidelines in deciding where state is held in your application.</p>
<h2>Determining State</h2>
<p>
The following diagram shows a three-tier architecture:</p>
<p>
<img src="state1.gif" border=0></p>
<p>
Typically, the latency between tiers differs greatly. Calls between the presentation tier and business tier are often an order of magnitude slower than the business tier and data tier. As a result, held state is more costly when calling into the business tier.</p>
<p>
However, it often makes sense to hold state within the transaction boundary itself. For example, the objects in the data tier may represent a complex join across many tables in separate databases. Reconstructing the data object state is potentially more costly than any resources held by those objects while they remain active.</p>
<p>
Remember that objects lose state on transaction boundaries. If you need to hold state across transactions, use the Shared Property Manager or store the state in a database.</p>
<h3>Example: Order-Entry Application</h3>
<p>
There are two separate issues when considering the effects of holding state in an application:
<ul type=disc>
<li>
Network round trips—More frequent network roundtrips and slower connections extend the lifetime of the called MTS object.<br><br></li>
<li>
Held resources—Holding state often means holding onto a resource, such as a database connection, and, potentially, locks on the database.</li>
</ul>
<p>
Consider the example of an online shopping application. The client chooses items from a catalog and submits an order. The order processing is handled by a business object, which in turn stores the order in a database (not shown).</p>
<p>
One way of building the application is for the client to call an Order object, with each call adding or removing an item from the order:</p>
<p>
<img src="state2.gif" border=0></p>
<p>
This application has the following properties:
<ul type=disc>
<li>
Client maintains no state.<br><br></li>
<li>
Server maintains state across multiple calls.<br><br></li>
<li>
Many network round trips.<br><br></li>
<li>
High contention for resources. The database connection is held for the lifetime of the Order object. This is not a very scalable solution.</li>
</ul>
<p>
You could require that the client cache the items in an array or recordset:</p>
<p>
<img src="state3.gif" border=0></p>
<p>
This application has the following properties:
<ul type=disc>
<li>
Stateful client.<br><br></li>
<li>
Server is virtually stateless with one call to the server.<br><br></li>
<li>
Fewer network round trips.<br><br></li>
<li>
Less contention for resources. This is a scalable solution.</li>
</ul>
<h2>Concurrency</h2>
<p>
In addition to network bandwidth and resources, concurrency affects application performance. There are two types of concurrency:
<ul type=disc>
<li>
<b>Pessimistic</b>—The database locks the records being changed as soon as editing begins. The records are unlocked when all changes are complete. No two users can access the same record at the same time.<br><br></li>
<li>
<b>Optimistic</b>—The database locks the records being changed only when the changes are committed. Two users can access the same record at the same time, and the database must be able to reconcile (or simply reject) changed records that have been edited by multiple users prior to commit.</li>
</ul>
<p>
Implementing a server cache implies optimistic concurrency. The server does not have to hold locks on the database, thus freeing resources.</p>
<p>
However, if there is high contention for the resource, pessimistic concurrency may be preferred. It is easier to reject a request to access a database and have the server try again than it is to reconcile data that is becoming out-of-date in a server cache with a rapidly changing database.</p>
</BODY>
</HTML>
