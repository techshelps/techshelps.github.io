<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Naming Conventions for Microsoft Access</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_20naming"></a>Naming Conventions for Microsoft Access</h1>
<h4>The Leszynski/Reddick Guidelines for Microsoft Access</h4>
<p>
Stan Leszynski and Greg Reddick</p>
<p>
Revised: May 25, 1994</p>
<p>
The authors wish to thank the individuals who submitted comments on and participated in reviews of the standard.</p>
<p>
<i>Stan Leszynski is president of Kwery Corp., which produces several Microsoft® Access® add-on products, including Access To Word and Kwery Control Paks. Stan also manages Leszynski Company, Inc., a consulting group active in database development, which he founded in 1982. He writes and speaks on Access regularly. Stan can be reached at (206) 644-7826 or on CompuServe® at 71151,1114.</i></p>
<p>
<i>Greg Reddick is the president of Gregory Reddick &amp; Associates, a software consulting company specializing in developing solutions in Microsoft Windows using C/C++, Access, and Visual Basic. He worked for four years on the Access development team at Microsoft, and has co-authored two Access books. Greg can be reached at (206) 881-6879 or on CompuServe at 71501,2564.</i></p>
<p class=indent>
<b>Editor's Note</b>&nbsp;&nbsp;&nbsp;April, 1998. Although originally written for Microsoft Access 1.<i>x</i> and 2.<i>x</i>, and Access Basic, the naming conventions in this article still apply equally well to current and forthcoming versions of Microsoft Access and to Visual Basic for Applications. The code samples in this article may need slight updating in order to run under Visual Basic for Applications.</p>
<p>
If you've ever inherited a project from another developer, you know how frustrating it is to try to dissect another developer's style and maintain his or her code. When developers code with a common style, however, you can minimize these frustrations. To best share ideas and knowledge, the Access development community will benefit greatly if it adopts a common programming style so that we can benefit from each other's expertise with a minimum of translation overhead. Although Microsoft uses certain naming conventions in the Microsoft® Access documentation, to date they haven't published an official or comprehensive standard. Thus, we've formulated a set of naming conventions to better serve Access users and developers. </p>
<p>
These conventions were originally published in the Charter Issue of <i>Smart Access</i>. Since then, we've logged thousands of hours of development time and scores of comments from <i>Smart</i> <i>Access</i> readers and other users of the conventions, and we continue to improve the style and make it more useful.</p>
<p>
Our naming style ties Access conventions closely to Visual Basic® conventions because we recognize that many Access developers also use or plan to use Visual Basic for some data access applications. Access and Visual Basic are becoming more similar with each released version. We've written these naming conventions so you can also use them with Visual Basic database applications.</p>
<p>
There are two levels to the naming style. Level 1 is comprehensive, but doesn't clarify objects as explicitly as Level 2. Level 1 is suitable for beginning developers, while Level 2 is intended for more experienced developers and developers involved in complex development projects and multiple-developer environments. You should experiment and choose the level that works best for you. (Please note that not all parts of the standard have two levels.)</p>
<p>
If you're already using any previous version of our conventions, you may need to make a few changes to accommodate the enhancements in this revision. Because Access provides little help in renaming objects, you may wish to leave existing applications as is and apply the revised conventions to new projects, going back to existing applications as time permits.</p>
<h2>Naming Conventions: An Overview</h2>
<p>
Our naming style is based on a method of naming called <i>Hungarian</i>, referring to the nationality of its creator, Charles Simonyi (who, incidentally, worked on the first version of Access). Hungarian was first proposed in his doctoral thesis.</p>
<p>
Some elements of Hungarian style are used in Microsoft's Visual Basic manuals and Development Kit documentation, among others. Microsoft uses Hungarian internally, and many programmers around the world use it as well. We've adapted the Hungarian style for the Access environment.</p>
<p>
In our Access naming style, an object name is made up of four parts: one or more prefixes,&nbsp; a tag, a base name, and a qualifier. The four parts are assembled as follows:</p>
<p>
<b>[prefixes]tag[Basename][Qualifier]</b></p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The brackets denote that these components are optional and aren't part of the name.</p>
<p>
The tag is the only required component, but in almost all cases the name will have the base name component because you need to be able to distinguish two objects of the same type. (Having the tag as the only required part may seem counterintuitive, but in Access Basic you can have code that deals with a generic form passed as a parameter. In this case you'd use "frm" as the parameter name; the base name isn't required except to distinguish it from a different form object variable in the code.). Here are a few examples:</p>
<table border=1 cellpadding=5 cols=5 frame=below rules=rows>
<tr valign=top>
<td class=label width=26%><b>Name</b></td>
<td class=label width=19%><b>Prefix</b></td>
<td class=label width=18%><b>Tag</b></td>
<td class=label width=18%><b>Base</b></td>
<td class=label width=19%><b>Qualifier</b></td>
</tr>
<tr valign=top>
<td width=26%>tblCustomer</td>
<td width=19%></td>
<td width=18%>tbl</td>
<td width=18%>Customer</td>
<td width=19%></td>
</tr>
<tr valign=top>
<td width=26%>aintPartNum</td>
<td width=19%>a</td>
<td width=18%>int</td>
<td width=18%>PartNum</td>
<td width=19%></td>
</tr>
<tr valign=top>
<td width=26%>strCustNamePrev</td>
<td width=19%></td>
<td width=18%>str</td>
<td width=18%>CustName</td>
<td width=19%>Prev</td>
</tr>
</table><br>
<p>
Prefixes and tags are always lowercase so your eye goes past them to the first uppercase letter where the base name begins. This makes the names more readable. The base and qualifier components begin with an uppercase letter.</p>
<p>
The base name succinctly describes the <i>object</i>, not its <i>class</i>. This is the name you'd likely give the object if you weren't using any particular naming style. For example, in the query name <i>qryPartNum</i>, "PartNum" is the base name; it's an abbreviation for Part Number. Object tags are short and mnemonic. Object prefixes precede some object names and tags and provide further information. For example, if an integer variable <i>intPartNum</i> is an array of part numbers, the prefix "a" for array is added to the front, as in <i>aintPartNum()</i>. Further, a variable that provides an index into the array would use the name of the array prefixed with the index prefix "i", for example, <i>iaintPartNum</i>.</p>
<p>
Applying a naming style like this requires more effort up front, but try to imagine which of these two code samples will make more sense to you a year from now when you attemptto modify or reuse your code:</p>
<pre><code>Z = Y(X)
</code></pre>
<p>
or</p>
<pre><code>intPart = aintPartNum(iaintPartNum)
</code></pre>
<p>
Object qualifiers may follow a name and further clarify names that are similar. Continuing with our parts index example, if you kept two indexes to the array, one for the first item and one for the last, the variable <i>iaintPartNum</i> above would become two qualified variables—<i>iaintPartNumFirst</i> and <i>iaintPartNumLast</i>.</p>
<h2>Naming Database Objects</h2>
<p>
Database objects (tables, queries, forms, reports, macros, and modules) are the most frequently referenced items in an Access application. They appear in your macro code, in your Access Basic routines, and in properties. Thus, it's important that you standardize how you name them.</p>
<p>
Microsoft's examples in the Northwind Database and Access manuals allow for spaces in object names, but we don't use them in our style. In most database engines and programming languages, including Access Basic, a space is a delimiter character between items, it isn't a logical part of an item's name. Also, spaces in field names don't work in most other database platforms or Microsoft Windows®-based applications such as Microsoft SQL Server™ or Word for Windows. Instead, use upper and lowercase designations in names, such as <i>tblAccountsPayable</i>. If spacing is still necessary, use the underscore (_) character instead of a space to be consistent with traditionally accepted SQL syntax and with Access 2.x function naming conventions.</p>
<h3>Tags for Database Container Objects</h3>
<p>
All database container object names in our style have tags. Adding tags to these objects may make them less readable to nondevelopers, but new users will understand their value when they're trying to discern a table from a query in the listbox for a New Report wizard or a form's Control Source property. This is because Access merges table and query names into one long list. Here are Level 1 database container object name tags:</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=27%><b>Object</b></td>
<td class=label width=32%><b>Tag</b></td>
<td class=label width=41%><b>Example</b></td>
</tr>
<tr valign=top>
<td width=27%>Table</td>
<td width=32%>tbl</td>
<td width=41%>tblCustomer</td>
</tr>
<tr valign=top>
<td width=27%>Query</td>
<td width=32%>qry</td>
<td width=41%>qryOverAchiever</td>
</tr>
<tr valign=top>
<td width=27%>Form</td>
<td width=32%>frm</td>
<td width=41%>frmCustomer</td>
</tr>
<tr valign=top>
<td width=27%>Report</td>
<td width=32%>rpt</td>
<td width=41%>rptInsuranceValue</td>
</tr>
<tr valign=top>
<td width=27%>Macro</td>
<td width=32%>mcr</td>
<td width=41%>mcrUpdateInventory</td>
</tr>
<tr valign=top>
<td width=27%>Module</td>
<td width=32%>bas</td>
<td width=41%>basBilling</td>
</tr>
</table><br>
<p>
At Level 1, the only name qualifier (appended to the name) that we use for database container objects is Sub, which we place at the end of a form or report name for a subform or subreport. The form frmProductSupplier would have the related subform frmProductSupplierSub. This allows objects and their subform or subreport to sort next to each other in the database container.</p>
<p>
Level 2 tags, shown here, provide more descriptive information.</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=38%><b>Object</b></td>
<td class=label width=24%><b>Tag</b></td>
<td class=label width=38%><b>Example</b></td>
</tr>
<tr valign=top>
<td width=38%>Table</td>
<td width=24%>tbl</td>
<td width=38%>tblCustomer</td>
</tr>
<tr valign=top>
<td width=38%>Table (lookup)</td>
<td width=24%>tlkp</td>
<td width=38%>tlkpShipper</td>
</tr>
<tr valign=top>
<td width=38%>Query (select)</td>
<td width=24%>qry (or qsel)</td>
<td width=38%>qryOverAchiever</td>
</tr>
<tr valign=top>
<td width=38%>Query (append)</td>
<td width=24%>qapp</td>
<td width=38%>qappNewProduct</td>
</tr>
<tr valign=top>
<td width=38%>Query (crosstab)</td>
<td width=24%>qxtb</td>
<td width=38%>qxtbRegionSales</td>
</tr>
<tr valign=top>
<td width=38%>Query (data definition)</td>
<td width=24%>qddl</td>
<td width=38%>qddlAddWorkColumn</td>
</tr>
<tr valign=top>
<td width=38%>Query (delete)</td>
<td width=24%>qdel</td>
<td width=38%>qdelOldAccount</td>
</tr>
<tr valign=top>
<td width=38%>Query (form filter)</td>
<td width=24%>qflt</td>
<td width=38%>qfltSalesToday</td>
</tr>
<tr valign=top>
<td width=38%>Query (lookup)</td>
<td width=24%>qlkp</td>
<td width=38%>qlkpStatus</td>
</tr>
<tr valign=top>
<td width=38%>Query (make table)</td>
<td width=24%>qmak</td>
<td width=38%>qmakShipTo</td>
</tr>
<tr valign=top>
<td width=38%>Query (pass-through)</td>
<td width=24%>qspt</td>
<td width=38%>qsptArchiveQuantity</td>
</tr>
<tr valign=top>
<td width=38%>Query (union)</td>
<td width=24%>quni</td>
<td width=38%>quniOrderDetail</td>
</tr>
<tr valign=top>
<td width=38%>Query (update)</td>
<td width=24%>qupd</td>
<td width=38%>qupdDiscount</td>
</tr>
<tr valign=top>
<td width=38%>Form</td>
<td width=24%>frm</td>
<td width=38%>frmCustomer</td>
</tr>
<tr valign=top>
<td width=38%>Form (dialog)</td>
<td width=24%>fdlg</td>
<td width=38%>fdlgLogin</td>
</tr>
<tr valign=top>
<td width=38%>Form (menu)</td>
<td width=24%>fmnu</td>
<td width=38%>fmnuUtility</td>
</tr>
<tr valign=top>
<td width=38%>Form (message)</td>
<td width=24%>fmsg</td>
<td width=38%>fmsgWait</td>
</tr>
<tr valign=top>
<td width=38%>Form (subform)</td>
<td width=24%>fsub</td>
<td width=38%>fsubOrder</td>
</tr>
<tr valign=top>
<td width=38%>Report</td>
<td width=24%>rpt</td>
<td width=38%>rptInsuranceValue</td>
</tr>
<tr valign=top>
<td width=38%>Report (subreport)</td>
<td width=24%>rsub</td>
<td width=38%>rsubOrder</td>
</tr>
<tr valign=top>
<td width=38%>Macro</td>
<td width=24%>mcr</td>
<td width=38%>mcrUpdateInventory</td>
</tr>
<tr valign=top>
<td width=38%>Macro (for form)</td>
<td width=24%>m[formname]</td>
<td width=38%>mfrmCustomer</td>
</tr>
<tr valign=top>
<td width=38%>Macro (menu)</td>
<td width=24%>mmnu</td>
<td width=38%>mmnuEntryFormFile</td>
</tr>
<tr valign=top>
<td width=38%>Macro (for report)</td>
<td width=24%>m[rptname]</td>
<td width=38%>mrptInsuranceValue</td>
</tr>
<tr valign=top>
<td width=38%>Module</td>
<td width=24%>bas</td>
<td width=38%>basBilling</td>
</tr>
</table><br>
<p>
Using our Level 2 style causes objects with similar functions to sort together in the database container in large applications. Imagine that you have a database container with 100 forms in it (we do!), 30 of which are messages that display during the application. Your users now want all message forms to have red text instead of black, so you must change each of the 30 forms. Having the message forms sort together in the database container (because they've all got the same tag) saves you significant effort trying to discern which forms you need to change.</p>
<p>
Choose your table names carefully. Since changes to the names of Access objects do not propagate through the database, it is important to name things correctly when the object is created. For example, changing the name of a table late in the development cycle requires changing all the queries, forms, reports, macros, and modules that refer to that table.</p>
<p>
You may want to name each database object that refers to a table with the same base name as the table, using the appropriate tag to differentiate them. For example, if your table is tblCustomer, its primary form would be frmCustomer, its primary report would be rptCustomer, and the macros that drive all of the events would be mfrmCustomer and mrptCustomer. We also suggest that you not make table names plural (for example, use tblCustomer, not tblCustomers), because a table usually holds more than one record, so it's plural by implication.</p>
<h3>Database Object Prefixes</h3>
<p>
We use four database object prefixes:
<ul type=disc>
<li>
"zz" denotes objects you've deserted but may want to keep in the database for awhile for future reference or use (for example, zzfrmPhoneList). "zz" causes the object name to sort to the bottom of the database container, where it's available but out of the way. <br><br></li>
<li>
"zt" denotes temporary objects (for example, ztqryTest). <br><br></li>
<li>
"zs" denotes system objects (for example, zstblObjects). System objects are items that are part of the development and maintenance of an application not used by end users, such as error logs, development notes, documentation routines, relationship information, and so on. (Note that "zs" is a prefix. It causes the system objects to sort toward the bottom of the database container).<br><br></li>
<li>
"_" denotes objects under development (for example, _mcrNewEmployee). An underscore before an object name sorts to the top of the database container to visually remind you that it needs attention. Remove the underscore when the object is ready to use and it will sort normally.</li>
</ul>
<h3>Tags for Fields</h3>
<p>
Using tags in field names is a hotly debated issue, even between the authors of this article. Greg maintains that tags in field names uniformly apply the naming style across all database elements and further document your work in Access Basic routines and form or report properties. Stan prefers that the database schema remain pure (platform- and data type-independent) for migration and connectivity to other products or platforms. He prefers that a field name remain independent of its data type.</p>
<p>
Consider both positions, along with your unique needs, when you choose whether to apply the field name tags shown here:</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=26%><b>Field Type</b></td>
<td class=label width=36%><b>Tag</b></td>
<td class=label width=38%><b>Example</b></td>
</tr>
<tr valign=top>
<td width=26%>Binary</td>
<td width=36%>bin</td>
<td width=38%>binInternal</td>
</tr>
<tr valign=top>
<td width=26%>Byte</td>
<td width=36%>byt</td>
<td width=38%>bytFloorNum</td>
</tr>
<tr valign=top>
<td width=26%>Counter</td>
<td width=36%>lng</td>
<td width=38%>lngPKCnt</td>
</tr>
<tr valign=top>
<td width=26%>Currency</td>
<td width=36%>cur</td>
<td width=38%>curSalary</td>
</tr>
<tr valign=top>
<td width=26%>Date/Time</td>
<td width=36%>dtm</td>
<td width=38%>dtmHireDate</td>
</tr>
<tr valign=top>
<td width=26%>Double</td>
<td width=36%>dbl</td>
<td width=38%>dblMass</td>
</tr>
<tr valign=top>
<td width=26%>Integer</td>
<td width=36%>int (C programmers may prefer "w")</td>
<td width=38%>intUnit</td>
</tr>
<tr valign=top>
<td width=26%>Long</td>
<td width=36%>lng (C programmers may prefer "dw")</td>
<td width=38%>lngPopulation</td>
</tr>
<tr valign=top>
<td width=26%>Memo</td>
<td width=36%>mem</td>
<td width=38%>memComments</td>
</tr>
<tr valign=top>
<td width=26%>Ole</td>
<td width=36%>ole</td>
<td width=38%>oleEmpPhoto</td>
</tr>
<tr valign=top>
<td width=26%>Single</td>
<td width=36%>sng (Some users find "sgl" more mnemonic<sup> </sup>)</td>
<td width=38%>sngScore</td>
</tr>
<tr valign=top>
<td width=26%>Text</td>
<td width=36%>str (Used as opposed to "txt" because a textbox control uses "txt". C programmers may prefer "sz")</td>
<td width=38%>strFirstName</td>
</tr>
<tr valign=top>
<td width=26%>Yes/No</td>
<td width=36%>ysn (C programmers may prefer "f")</td>
<td width=38%>ysnDiscounted</td>
</tr>
</table><br>
<p>
<b>Notes: </b>
<ul type=disc>
<li>
The Access engine ("Jet") supports a data type called binary but the Access user interface doesn't expose it to the user. It's still possible to get a field with the binary data type by importing or attaching certain external tables. Also, some of the system table fields use this data type.<br><br></li>
<li>
Internally, Access treats a counter data type as a long integer with a special property called auto-increment. Because counter fields are often referenced by foreign keys and the data type in the other table is a long, Greg uses the same tag as a long. Optionally, if you want to distinguish a counter from a long, use the qualifier Cnt at the end of the name.</li>
</ul>
<h3>Tags for Control Objects</h3>
<p>
Access forms and reports automatically assign the field name to the Control Name property when you create a new bound control. Having the control name and field name the same creates some ambiguity in the database schema and in some cases may cause errors in Access Basic code referencing both a control and a field with the same name. To resolve this situation, apply the naming style to form and report controls by inserting the appropriate tag from the list below, in front of the control name suggested by Access. For example, the control name for a field whose Control Source is LastName would be <i>txtLastName</i>.</p>
<p>
At Level 1, we recognize that users need to know the difference between an active control and a label, but may not be concerned with the type of the control. Thus the control tags are as follows:</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=38%><b>Object</b></td>
<td class=label width=21%><b>Tag</b></td>
<td class=label width=41%><b>Example</b></td>
</tr>
<tr valign=top>
<td width=38%>Label</td>
<td width=21%>lbl</td>
<td width=41%>lblLastName</td>
</tr>
<tr valign=top>
<td width=38%>Other types</td>
<td width=21%>ctl</td>
<td width=41%>ctlLastName</td>
</tr>
</table><br>
<p>
Level 1 tags provide the minimum differentiation necessary to still prove useful in functions, macros, and program documentation. For example, the control tags above allow you to differentiate between labels, which aren't modifiable at runtime, and other controls, which accept values from code and users.</p>
<p>
Level 2 control tags denote the specific type of the control on the form or report (see table below). This makes Access Basic code and macros more explicit with respect to the properties and events of the individual control.</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=42%><b>Object</b></td>
<td class=label width=21%><b>Tag</b></td>
<td class=label width=37%><b>Example</b></td>
</tr>
<tr valign=top>
<td width=42%>Chart (graph)</td>
<td width=21%>cht</td>
<td width=37%>chtSales</td>
</tr>
<tr valign=top>
<td width=42%>Check box</td>
<td width=21%>chk</td>
<td width=37%>chkReadOnly</td>
</tr>
<tr valign=top>
<td width=42%>Combo box</td>
<td width=21%>cbo</td>
<td width=37%>cboIndustry</td>
</tr>
<tr valign=top>
<td width=42%>Command button</td>
<td width=21%>cmd</td>
<td width=37%>cmdCancel</td>
</tr>
<tr valign=top>
<td width=42%>Frame (object)</td>
<td width=21%>fra</td>
<td width=37%>fraPhoto</td>
</tr>
<tr valign=top>
<td width=42%>Label</td>
<td width=21%>lbl</td>
<td width=37%>lblHelpMessage</td>
</tr>
<tr valign=top>
<td width=42%>Line</td>
<td width=21%>lin</td>
<td width=37%>linVertical</td>
</tr>
<tr valign=top>
<td width=42%>List box</td>
<td width=21%>lst</td>
<td width=37%>lstPolicyCode</td>
</tr>
<tr valign=top>
<td width=42%>Option button</td>
<td width=21%>opt</td>
<td width=37%>optFrench</td>
</tr>
<tr valign=top>
<td width=42%>Option group</td>
<td width=21%>grp</td>
<td width=37%>grpLanguage</td>
</tr>
<tr valign=top>
<td width=42%>Page break</td>
<td width=21%>brk</td>
<td width=37%>brkPage1</td>
</tr>
<tr valign=top>
<td width=42%>Rectangle (Visual Basic uses the term "shape")</td>
<td width=21%>shp</td>
<td width=37%>shpNamePanel</td>
</tr>
<tr valign=top>
<td width=42%>Subform/report</td>
<td width=21%>sub</td>
<td width=37%>subContact</td>
</tr>
<tr valign=top>
<td width=42%>Text box</td>
<td width=21%>txt</td>
<td width=37%>txtLoginName</td>
</tr>
<tr valign=top>
<td width=42%>Toggle button</td>
<td width=21%>tgl</td>
<td width=37%>tglForm</td>
</tr>
</table><br>
<p>
The only prefix for controls, "zs", appears at Level 2. It denotes system-level controls used by the form or code but not displayed to the user. Such controls usually aren't visible at run time but they may store temporary values or parameters passed to the form.</p>
<h2>Naming Access Basic and Macro Objects</h2>
<p>
Using standardized and descriptive variable, constant, and function names greatly enhances the ability of developers to share, maintain, and jointly develop code.</p>
<h3>Procedures and Macros</h3>
<p>
Access Basic requires that each nonprivate procedure name in a database be unique. For a function called from a property on a form in Access 1.x, construct the function name as follows:</p>
<p>
<b>formname_controlname_propertyname</b></p>
<p>
For example:</p>
<p>
<b>frmEmployee_cmdAdd_Push</b></p>
<p>
This tells you that this function is called from the OnPush property of the control cmdAdd on the form frmEmployee. For a property that affects the entire form, just use formname_propertyname, as in frmEmployee_Open. If two or more controls on one form execute the same code, create unique functions for each using the naming style in this section, then have each of these functions call the same private function that contains the common code.</p>
<p>
In Access 2.x, the code for controls on a form is stored attached to the form, so the form name is implied in the function and does not need to be in the function name. Thus, the example above becomes:</p>
<p>
<b>cmdAdd_Click</b></p>
<p>
Macro names inside a macro group also use this format. In the macro group mfrmEmployee, the macro txtName_BeforeUpdate contains the actions for the txtName control's BeforeUpdate event. For example, the txtName control on your frmEmployee form would have one of these properties, depending on whether you use modules (Access 1.x), attached code (Access 2.x), or macros to implement the task:</p>
<p>
<b>1.x code:BeforeUpdate....=frmEmployee_txtName_BeforeUpdate()</b></p>
<p>
<b>2.x code:BeforeUpdate....=txtName_BeforeUpdate()</b></p>
<p>
<b>Macros:BeforeUpdate...mfrmEmployee.txtName_BeforeUpdate</b></p>
<p>
You should prefix procedure names in library databases with a unique set of characters to prevent their names from conflicting with any other names from attached libraries. The prefix should be in uppercase letters, followed by an underscore, and be no more than four letters. For example, we prefix all the library function names for our mail-merge utility, Access To Word, with "ATW_". Global constants and variables in a library should use the same prefix because they must also be unique across the entire database name space. Similarly, it is important to use these prefixes in Declare statements to alias all external dynamic-link library (DLL) function and procedure calls.</p>
<h3>Tags for Access Basic Variables</h3>
<p>
Every Access Basic variable should have a type tag from the following list:</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=27%><b>Variable Type</b></td>
<td class=label width=20%><b>Tag</b></td>
<td class=label width=53%><b>Example</b></td>
</tr>
<tr valign=top>
<td width=27%>Container</td>
<td width=20%>con</td>
<td width=53%>Dim conTables as Container</td>
</tr>
<tr valign=top>
<td width=27%>Control</td>
<td width=20%>ctl</td>
<td width=53%>Dim ctlVapor As Control</td>
</tr>
<tr valign=top>
<td width=27%>Currency</td>
<td width=20%>cur</td>
<td width=53%>Dim curSalary As Currency</td>
</tr>
<tr valign=top>
<td width=27%>Database</td>
<td width=20%>db</td>
<td width=53%>Dim dbCurrent As Database</td>
</tr>
<tr valign=top>
<td width=27%>Document</td>
<td width=20%>doc</td>
<td width=53%>Dim docRelationships as Document</td>
</tr>
<tr valign=top>
<td width=27%>Double</td>
<td width=20%>dbl</td>
<td width=53%>Dim dblPi As Double</td>
</tr>
<tr valign=top>
<td width=27%>Dynaset</td>
<td width=20%>dyn</td>
<td width=53%>Dim dynTransact As Dynaset</td>
</tr>
<tr valign=top>
<td width=27%>Flag (Y/N, T/F)</td>
<td width=20%>f</td>
<td width=53%>Dim fAbort As Integer</td>
</tr>
<tr valign=top>
<td width=27%>Field</td>
<td width=20%>fld</td>
<td width=53%>Dim fldLastName as Field</td>
</tr>
<tr valign=top>
<td width=27%>Form</td>
<td width=20%>frm</td>
<td width=53%>Dim frmGetUser As Form</td>
</tr>
<tr valign=top>
<td width=27%>Group</td>
<td width=20%>gru</td>
<td width=53%>Dim gruManagers as Group</td>
</tr>
<tr valign=top>
<td width=27%>Index</td>
<td width=20%>idx</td>
<td width=53%>Dim idxOrderId as Index</td>
</tr>
<tr valign=top>
<td width=27%>Integer</td>
<td width=20%>int</td>
<td width=53%>Dim intRetValue As Integer</td>
</tr>
<tr valign=top>
<td width=27%>Long</td>
<td width=20%>lng</td>
<td width=53%>Dim lngParam As Long</td>
</tr>
<tr valign=top>
<td width=27%>Object</td>
<td width=20%>obj</td>
<td width=53%>Dim objGraph As Object</td>
</tr>
<tr valign=top>
<td width=27%>Parameter</td>
<td width=20%>prm</td>
<td width=53%>Dim prmBeginDate as Parameter</td>
</tr>
<tr valign=top>
<td width=27%>Property</td>
<td width=20%>prp</td>
<td width=53%>Dim prpUserDefined as Property</td>
</tr>
<tr valign=top>
<td width=27%>QueryDef</td>
<td width=20%>qdf (or qrd)</td>
<td width=53%>Dim qdfPrice As QueryDef</td>
</tr>
<tr valign=top>
<td width=27%>Recordset</td>
<td width=20%>rec (or rst)</td>
<td width=53%>Dim recPeople as Recordset</td>
</tr>
<tr valign=top>
<td width=27%>Relation</td>
<td width=20%>rel</td>
<td width=53%>Dim relOrderItems as Relation</td>
</tr>
<tr valign=top>
<td width=27%>Report</td>
<td width=20%>rpt</td>
<td width=53%>Dim rptYTDSales As Report</td>
</tr>
<tr valign=top>
<td width=27%>Single</td>
<td width=20%>sng</td>
<td width=53%>Dim sngLoadFactor As Single</td>
</tr>
<tr valign=top>
<td width=27%>Snapshot</td>
<td width=20%>snp</td>
<td width=53%>Dim snpParts As Snapshot</td>
</tr>
<tr valign=top>
<td width=27%>String</td>
<td width=20%>str</td>
<td width=53%>Dim strUserName As String</td>
</tr>
<tr valign=top>
<td width=27%>Table</td>
<td width=20%>tbl</td>
<td width=53%>Dim tblVendor As Table</td>
</tr>
<tr valign=top>
<td width=27%>TableDef</td>
<td width=20%>tdf (or tbd)</td>
<td width=53%>Dim tdfBooking as TableDef</td>
</tr>
<tr valign=top>
<td width=27%>Type (user-defined)</td>
<td width=20%>typ</td>
<td width=53%>Dim typPartRecord As mtPART_RECORD</td>
</tr>
<tr valign=top>
<td width=27%>User</td>
<td width=20%>usr</td>
<td width=53%>Dim usrJoe as User</td>
</tr>
<tr valign=top>
<td width=27%>Variant</td>
<td width=20%>var</td>
<td width=53%>Dim varInput As Variant</td>
</tr>
<tr valign=top>
<td width=27%>Workspace</td>
<td width=20%>wrk (or wsp)</td>
<td width=53%>Dim wrkPrimary as Workspace</td>
</tr>
<tr valign=top>
<td width=27%>Yes/No18</td>
<td width=20%>ysn</td>
<td width=53%>Dim ysnPaid As Integer</td>
</tr>
</table><br>
<p>
Our style doesn't use data-type suffixes such as $ and % on variable names, because the Access and Visual Basic documentation recommends against using these suffixes.</p>
<p>
Tags for database object variables such as the Form and Report types are the same as those used for the objects. This helps when coding, because the variable you assign an object to (for example, tblVendor) usually has the same name as the object it references (tblVendor), providing you with consistent object names when coding. </p>
<h3>Constants and User-Defined Types</h3>
<p>
It is common practice in programming for Windows to use uppercase names for constants, but the authors differ on how to treat constants. Stan prefers using the uppercase notation and adding a scope prefix (see below), so a global constant for a specific error might be gNO_TABLE_ERROR. Greg prefers to treat constants as typed variables without scope, for example, strNoTableError.</p>
<p>
In the above table, we've added a variable type tag of "typ" for user-defined types, and suggest a convention that matches that of constants, because you can think of both user-defined types and user-defined constants as persistent, user-created objects. The recommendations for a user-defined data type syntax include the following:
<ul type=disc>
<li>
Use uppercase letters (or upper/lower syntax if you use that optional convention for globals).<br><br></li>
<li>
Use a tag of "t" in front of the type name to denote that it's a type structure.<br><br></li>
<li>
Use "g" and "m" prefixes to denote the scope of the type (see below).</li>
</ul>
<h3>Prefixes for Scope</h3>
<p>
Level 2 of the naming convention introduces scope prefixes for variables and constants. The scope prefix comes before any other prefixes.
<ul type=disc>
<li>
Variables declared locally with a Dim statement have no prefix.<br><br></li>
<li>
Variables declared locally with a Static statement are prefixed with an "s", as in "sintAccumulate".<br><br></li>
<li>
Variables that are declared in the Declarations section of a module (or form in Visual Basic) using a Dim statement are prefixed with an "m", as in "mcurRunningSum".<br><br></li>
<li>
Variables declared with global scope using a Global statement in the Declarations section have the prefix "g", as in "glngGrandTotal".<br><br></li>
<li>
Variables that denote parameters passed to a function (in the parentheses after the function name) have a prefix of "p", as in "pstrLastName". Alternately, we sometimes use "r" instead of "p" for values passed to a function by reference, and "v" for values passed ByVal, when both types of parameters are used in a single function declaration.</li>
</ul>
<p>
Object qualifiers follow the variable name and further differentiate it from similar names. You'll probably devise a list of qualifiers relevant to the types of applications you develop, but here are some of our common ones:</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=43%><b>Variable Property</b></td>
<td class=label width=21%><b>Qualifier </b></td>
<td class=label width=36%><b>Example</b></td>
</tr>
<tr valign=top>
<td width=43%>Current element of set</td>
<td width=21%>Cur</td>
<td width=36%>iaintCur</td>
</tr>
<tr valign=top>
<td width=43%>First element of set</td>
<td width=21%>First</td>
<td width=36%>iaintStockFirst</td>
</tr>
<tr valign=top>
<td width=43%>Last element of set</td>
<td width=21%>Last</td>
<td width=36%>iaintStockLast</td>
</tr>
<tr valign=top>
<td width=43%>Next element of set</td>
<td width=21%>Next</td>
<td width=36%>strCustomerNext</td>
</tr>
<tr valign=top>
<td width=43%>Previous element of set</td>
<td width=21%>Prev</td>
<td width=36%>strCustomerPrev</td>
</tr>
<tr valign=top>
<td width=43%>Lower limit of range</td>
<td width=21%>Min</td>
<td width=36%>iastrNameMin</td>
</tr>
<tr valign=top>
<td width=43%>Upper limit of range</td>
<td width=21%>Max</td>
<td width=36%>iastrNameMax</td>
</tr>
<tr valign=top>
<td width=43%>Source</td>
<td width=21%>Src</td>
<td width=36%>lngBufferSrc</td>
</tr>
<tr valign=top>
<td width=43%>Destination</td>
<td width=21%>Dest</td>
<td width=36%>lngBufferDest</td>
</tr>
</table><br>
<h3>Access Basic Labels</h3>
<p>
For Access Basic labels, we use a qualifier on the function name to create several standard labels. For On Error GoTo statements, we use the name of the function with the qualifier _Err appended, for example:</p>
<p>
<b>cmdAdd_Click_Err:</b></p>
<p>
Some functions also have a label for jumping forward to the end of the function, because it's more appropriate to leave a function only in one place than to scatter Exit Function statements throughout a routine. We use the Done qualifier, as in:</p>
<p>
<b>cmdAdd_Click_Done:</b></p>
<h3>Access Basic Example</h3>
<p>
Below is an example of an Access Basic routine using the naming conventions. Note these items:
<ul type=disc>
<li>
We put a header in every function that describes, at a minimum, purpose, comments, author's name/date, last revision date and notes, and parameters passed and/or returned.<br><br></li>
<li>
We return to the Done routine from the Error routine to ensure that open objects are closed properly before exiting the function. The temptation to simply use Exit Function from an error handler may leave files open and locked.<br><br></li>
<li>
The example was originally written for Access 1.<i>x</i> and uses syntax that has been modified in 2.<i>x</i> (for example, CreateDynaset is now OpenRecordset).</li>
</ul>
<pre><code>Function EliminateNulls (ByVal vstrFieldName As String, ByVal vstrTableName As String) As Integer
' What:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Replaces Null values with unique ascending integers
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A standardized version of a routine from NWIND and Chapter 8
' Author:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Microsoft&nbsp; Created: 11/92&nbsp; Last Revision: 5/25/94&nbsp; By: grr/swl
' Passed in:&nbsp;&nbsp;&nbsp; field name and table name
' Returns:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0/-1

 &nbsp;&nbsp; On Error GoTo EliminateNulls_Err
 &nbsp;&nbsp; Dim db As Database
 &nbsp;&nbsp; Dim dynTableSrc As Dynaset
 &nbsp;&nbsp; Dim varCounter As Variant
 &nbsp;&nbsp; Dim varCriteria As Variant
 &nbsp;&nbsp; 
 &nbsp;&nbsp; EliminateNulls = 0
 &nbsp;&nbsp; Set db = CurrentDB()
 &nbsp;&nbsp; Set dynTableSrc = db.CreateDynaset(vstrTableName)
 &nbsp;&nbsp; varCounter = DMax(vstrFieldName, vstrTableName)
 &nbsp;&nbsp; If IsNull(varCounter) Or IsEmpty(varCounter) Then
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; varCounter = 1
 &nbsp;&nbsp; Else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; varCounter = Val(varCounter) + 1
 &nbsp;&nbsp; End If
 &nbsp;&nbsp; varCriteria = vstrFieldName &amp; " = Null"

 &nbsp;&nbsp; ' Iterate over all records in the table, throw out records with Nulls
 &nbsp;&nbsp; dynTableSrc.FindFirst varCriteria
 &nbsp;&nbsp; Do Until dynTableSrc.NoMatch
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dynTableSrc.Edit
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dynTableSrc(vstrFieldName) = varCounter
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dynTableSrc.Update
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; varCounter = varCounter + 1
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dynTableSrc.FindNext varCriteria
 &nbsp;&nbsp; Loop
 &nbsp;&nbsp; EliminateNulls = -1

EliminateNulls_Done:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Jump here to clean up and exit
 &nbsp;&nbsp; dynTableSrc.Close
 &nbsp;&nbsp; db.Close
 &nbsp;&nbsp; On Error GoTo 0
Exit Function

EliminateNulls_Err:
 &nbsp;&nbsp; Select Case Err 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Handle specific errors here
 &nbsp;&nbsp; Case Else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Generic error handler here
 &nbsp;&nbsp; Resume EliminateNulls_Done
 &nbsp;&nbsp; End Select
End Function
</code></pre>
<h3>Putting Standards into Practice</h3>
<p>
Naming conventions never replace the judicious use of comments in your table definitions, macro code, or Access Basic routines. Naming conventions are an extension of, not a replacement for, good program-commenting techniques.</p>
<p>
Formulating, learning, and applying a consistent naming style requires a significant initial investment of time and energy. However, you'll be amply rewarded when you return to your application a year later to do maintenance or when you share your code with others. Once you implement standardized names, you'll quickly grow to appreciate the initial effort you made.</p>
<p>
If the entire Access community, including Microsoft, coded using&nbsp; one common naming style, we'd all find it easier to share information about Access. With this in mind, we submit these revised guidelines to the Access community.</p>
<p>
<i>This document accompanied the August 1994 issue of Smart Access Journal, published by Pinnacle Publishing, Inc. Earlier versions of these guidelines were published in the February and August 1993 issues of Smart Access.</i></p>
<p>
This document copyright 1993-1994 by Stan Leszynski and Greg Reddick. It may be distributed freely as long as no profit is made from its publication or distribution, or from publications that include it, and the complete text is published or distributed without alteration of the content. All other rights reserved. Please send the authors a copy of any publication that includes this document.</p>
</BODY>
</HTML>
