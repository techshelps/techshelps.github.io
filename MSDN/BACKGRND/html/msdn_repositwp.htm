<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The Microsoft Repository</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_repositwp"></a>The Microsoft Repository </h1>
<p>
Philip A. Bernstein, Microsoft Corporation<br>
Paul Sanders, Texas Instruments, Inc.<br>
Brian Harry, Microsoft Corporation<br>
David Shutt, Microsoft Corporation<br>
Jason Zander, Microsoft Corporation</p>
<p>
<i>Authors’ address: Microsoft Corp., One Microsoft Way, Redmond, WA 98052-6399. <br>
E-mail: {philbe, bharry, v-paulsa, dshutt, jasonz}@microsoft.com</i></p>
<p>
Proceedings of the 23rd VLDB (Very Large Data Bases) Conference</p>
<p>
Athens, Greece, 1997</p>
<h2>Abstract</h2>
<p>
Microsoft® Repository is an object-oriented repository that ships as a component of Visual Basic® version 5.0. It includes a set of ActiveX™ interfaces that a developer can use to define information models and a repository engine that is the underlying storage mechanism for these information models. The repository engine sits on top of a SQL database system.</p>
<p>
The repository is designed to meet the persistent storage needs of software tools. Its two main technical goals are: 
<ul type=disc>
<li>
Compatibility with Microsoft’s existing ActiveX object architecture consisting of the Component Object Model (COM) and Automation. <br><br></li>
<li>
Extensibility by customers and independent software vendors who need to tailor the repository by adding functionality to objects stored by the repository engine and extending information models provided by Microsoft and others. </li>
</ul>
<p>
This paper explains how the repository attains these goals by providing an object-oriented database (OODB) architecture based on Microsoft’s binary object model (COM) and type system of Visual Basic (Automation).</p>
<p class=indent>
<B><b>Note&nbsp;&nbsp;&nbsp;</b></B>To highlight the effect of COM and Automation on the repository design, we have tagged each sentence that describes such an effect with an asterisk (*). Numbers in brackets throughout the text refer to the endnotes in the References section at the end of this article.</p>
<h2>1. Introduction</h2>
<p>
Microsoft Repository is composed of two major components: a set of object-oriented ActiveX interfaces that a developer can use to define information models, and a repository engine that is the underlying storage mechanism for these information models. (<i>Information model</i> is repository terminology for database schema [3].) The repository engine sits on top of either Microsoft SQL Server or Microsoft Jet (the database system in Microsoft Access) and supports both navigational access via the object-oriented interfaces and direct SQL access to the underlying store. In addition, the repository includes a set of information models that cover the data sharing needs of software tools.</p>
<p>
The two main technical goals of Microsoft Repository are 
<ol>
<li>
<b>COM/ActiveX Compatibility:</b> It should fit naturally into Microsoft’s existing object architecture, consisting of COM and Automation (now subsumed under ActiveX). Thus, the repository should use existing ActiveX interfaces and implementation technology wherever possible and minimize the number of new concepts that the large community of ActiveX users needs to learn.<br><br></li>
<li>
<b>Extensibility:</b> Given the size and diversity of Microsoft’s market, it’s important that customers and third-party vendors be able to tailor the repository to their needs, both by providing methods on objects stored by the repository engine and by extending persistent state. The latter is done declaratively, with no code. </li>
</ol>
<p>
This paper explains how Microsoft Repository attains these goals by providing an OODB architecture that fits into Microsoft’s existing object infrastructure. In contrast to C++- or Smalltalk-based OODBs, its object model is a binary standard, not a language API, and is very strongly interface-based, rather than class-based. Fitting an OODB or repository into an existing object model is a delicate activity, which we explain in detail. The reward is a repository that offers the powerful extensibility of COM/ActiveX, without requiring many new extensibility features of its own.</p>
<p>
The Microsoft Repository is also interesting because of its pervasiveness. It ships in Visual Basic 5.0 Professional and Enterprise editions and will therefore have several hundred thousand copies deployed within a year—perhaps more, as it is added to other Microsoft products.</p>
<p>
There is very little in the research literature about complete repository systems. A general introduction can be found in [3]. The PCTE standard is described in [10]. Many OODBs are used as repositories, though they are not the same thing, as explained in [2]. Still, the large literature on OODB system descriptions is relevant to the present work, such as [4, 11]. A comparison of our design with other systems is beyond the scope of this paper.</p>
<h2>2. COM and Automation</h2>
<h3>2.1 The Component Object Model</h3>
<p>
Microsoft’s Component Object Model (COM) is the foundation of Microsoft’s object architecture. It is a binary standard that describes component-to-component early-bound calling conventions in a language-neutral fashion, so that components written in one language can seamlessly call components written in another language.</p>
<p>
In COM, a <i>class</i> is an executable program image. It can have multiple <i>interfaces</i>, where each interface is a collection of methods, called <i>members</i>. All of the repository’s interfaces are COM interfaces.</p>
<p>
Each class has a <i>class id</i>, which is a 128-bit globally unique identifier (GUID). Given a class id, the function <b>CoCreateInstance</b> creates an <i>object</i>, which is an instance of the class. <b>CoCreateInstance</b> finds the class’s executable by looking up the class id in the registry, which is a small hierarchical persistent store managed by Windows® operating systems. Entering the class id in the registry is part of the class’s installation procedure.</p>
<p>
An interface’s specification includes an ordered list of its method names, each method’s parameters, and an <i>interface identifier </i>(IID), which is a GUID. An interface’s specification is immutable. Therefore, to enhance an interface, one must implement a new interface with a new IID.</p>
<p>
By convention, interface names begin with <i>I</i>. Figure 1 gives a graphical representation of a class with multiple interfaces; interfaces are depicted as lollipops attached to the class or instance of the class. Methods are ordinarily not shown in this representation; for example, the <b>IForm</b> interface could support the <b>Resize</b> and <b>AddControl</b> methods, which are not shown in the figure.</p>
<p>
<img src="reposit1.gif" border=0></p>
<p class=label>
<b>Figure 1. Representation of a COM component</b></p>
<p>
A COM interface can directly inherit from at most one other interface, in which case it supports the members of the interface from which it inherits. Every COM object inherits, directly or indirectly, from <b>IUnknown</b>. COM supports a form of multiple inheritance, in that a class can support many interfaces. It also supports polymorphism, in that an interface can be supported by many classes.</p>
<p>
Every COM class, and hence instances of that class, support the interface <b>IUnknown</b>. <b>QueryInterface</b> is a method on <b>IUnknown</b> that allows a client to ask a COM object if it supports a particular interface, given the interface’s unique IID. If the object supports the IID, it returns a pointer to that interface on that object. In this case, the client knows exactly what behavior the object will provide, because interface definitions are immutable. If it doesn’t support the IID, it returns null. Thus, in Figure 1, an instance of <b>Form</b> would respond positively to a call on <b>QueryInterface</b> given <b>IForm’s</b> IID and therefore supports all the methods specified for <b>IForm</b>.</p>
<p>
The <b>QueryInterface</b> mechanism helps cope with type evolution, as follows: 
<ul type=disc>
<li>
Since interface definitions are immutable, to change the behavior of an interface, one must define a new interface. Over time, one may have several different interfaces that are effectively versions of each other. We use "version" loosely here; each "version" is an independent interface insofar as COM is concerned. <br><br></li>
<li>
A class can support several different interfaces, which may be different versions of an interface that has evolved over time. <br><br></li>
<li>
A client can cope with multiple versions of a class’s interface as follows: The client queries for the IID of the interface version it prefers. The class’s instance replies yes or no. If it answers no, the client tries its second favorite interface, and so on. The client and object can interoperate if the client finds an interface that it knows how to use and that the object supports. </li>
</ul>
<p>
This mechanism allows classes and their clients to be independently upgraded.</p>
<p>
Every class has a <i>class factory</i>, which can create instances of the class. The class factory returns a pointer to an interface on the object. After receiving this pointer, a client can call methods on that object (locally, or remotely using Distributed COM [DCOM]), or can use <i>QueryInterface</i> to find other interfaces on the object and call methods on them.</p>
<p>
A COM class, C, can be extended by wrapping it. This technique is called <i>aggregation</i> if the wrapper passes through any of C’s interfaces, else it is called <i>containment</i>. The technique involves writing a class, C¢, that supports the extended behavior, which may consist of new interfaces and/or wrapped implementations of C’s interfaces. C¢ only needs access to C’s executable (not its source code). To make this work, C-prime replies to <b>QueryInterface</b> only on interfaces C-prime implements (that is, those it wrapped or its new interfaces). It delegates calls on <b>QueryInterface</b> for other interfaces to C. Since C-prime includes all of C’s behavior, C-prime uses C’s class id, c, so <b>CoCreateInstance</b>(c) produces instances of C-prime. COM aggregation is explained thoroughly in COM documentation and is well known to COM developers [9].</p>
<p>
A class can aggregate many classes and be aggregated by many classes; in this sense, COM supports multiple inheritance of implementations. As we will see, the repository’s support of user-defined methods and much of its extensibility is a direct application of COM aggregation.</p>
<p>
A COM interface on an object is implemented in memory as a <i>vtable</i> (that is, a virtual table), plus some object-local data structures. A vtable has an entry for each of its members, which points to the in-memory executable for that member. The pointer returned by <b>QueryInterface</b> points to that interface’s vtable in that object. In this sense, COM is a binary calling standard. Since the caller is assumed to know the order (and meaning) of member entries in the vtable, COM is best suited for early-bound access.</p>
<h3>2.2 Automation</h3>
<p>
Automation is a mechanism for late-bound calling of objects, originally developed for Visual Basic and later integrated with COM. Automation functionality is captured by the COM interface <b>IDispatch</b>. <b>IDispatch</b> supports a method, <b>Invoke(M, parm1, parm2, …)</b>, which implements a late-bound call to method M with parameters parm1, parm2, …, on the object (that is, the one that implements <b>IDispatch</b>). For an interface on an object to be invoked in this way, it must inherit from <b>IDispatch</b>, in which case it is called a <i>dispatch interface</i>.</p>
<p>
A dispatch interface can have many members, each identified by a <i>dispatch id</i>, which is the value used for parameter M in <b>Invoke</b>. <b>IDispatch</b> also includes a method <b>GetIDsOfNames</b>, which maps member names to dispatch ids (for efficient late-bound access), using information contained in a type library (described below).</p>
<p>
A member of a dispatch interface can either be an ordinary method or a property, which is a shorthand for saying it has methods <b>get_Foo </b>and <b>put_Foo</b> for the property <b>Foo</b>. A property can either be single-valued or collection-valued. In the latter case, it returns a collection object, which in turns supports the following methods: 
<ul type=disc>
<li>
<b>Add</b> inserts an element. <br><br></li>
<li>
<b>Count</b> returns the cardinality of the collection. <br><br></li>
<li>
<b>Item</b> retrieves an element by index or key. <br><br></li>
<li>
<b>Remove</b> deletes an element identified by index or key. <br><br></li>
<li>
<b>_enum</b> returns an enumerator (that is, a cursor) on the collection, which can be traversed by calls to the <b>Next</b> method. </li>
</ul>
<p>
An interface can be both a COM interface and a dispatch interface, called a <i>dual</i> interface. This is an optimization that allows some members of a dispatch interface to be called through the early-bound COM mechanism. A caller who knows the definition of the interface at compile time can use this information to make an early-bound call and therefore avoid the overhead of interpretation by <b>IDispatch</b>. All interfaces to the repository engine are dual interfaces.</p>
<p>
The "standard" implementation of IDispatch (that is, for Visual Basic) uses a <i>type library</i> object to look up the definition of external interfaces it is asked to invoke. To produce a type library, a class developer writes an interface definition in Microsoft’s interface definition language (MIDL) and compiles it into a type library, which can either be stored as part of the class’s executable or in a separate file. Type libraries can be directly accessed via their own interfaces, such as <b>ITypeLib</b> and <b>ITypeInfo</b>. Often, they are accessed indirectly via <b>IDispatch::GetIDsOfNames</b>.</p>
<p>
Visual Basic syntax translates directly into calls on <b>IDispatch</b>. For example, consider this program fragment:</p>
<pre><code>DIM X as Object
X.Foo = 7
</code></pre>
<p>
The Visual Basic implementation (called an <i>Automation Controller</i>) uses <b>GetIDsOfNames</b> to look up <b>Foo</b>, and then uses Invoke to call <b>put_Foo(7)</b>. If X supports multiple interfaces, then the above program accesses property <b>Foo</b> on its default interface. Another interface, <b>IBar</b>, could be accessed like this:</p>
<pre><code>DIM Y as IBar
Set Y = X
Z = Y.MyFunction()
</code></pre>
<p>
The statement "Set Y = X" calls <b>QueryInterface</b> on X for <b>IBar</b> and assigns that value to Y.</p>
<h2>3 The Repository Engine</h2>
<h3>3.1 The Repository’s Object Model</h3>
<p>
COM and Automation are used as the native object model by the vast majority of programming tools for Microsoft operating systems. It was therefore a requirement that the repository engine’s functionality be exposed as a set of COM and Automation objects. These objects are in-memory representations of the information held in the repository database. Every object supports a set of repository-specific dual interfaces. That is, an object is a repository object if it supports a certain set of repository-specific interfaces.</p>
<p>
The repository supports four main kinds of objects: 
<ul type=disc>
<li>
<b>Repository Session:</b> Represents the repository database itself. It behaves much like a database session. <br><br></li>
<li>
<b>Repository Object:</b> Represents the persistent state of an object in a repository. That state consists of the object’s properties and collections. <br><br></li>
<li>
<b>Collection Object:</b> Represents a set of relationship objects. A collection of relationships is accessed and updated using the standard collection methods: <b>Add</b>, <b>Count</b>, <b>Remove</b>, Item<b>,</b> and <b>_Enum</b>. <br><br></li>
<li>
<b>Relationship Object:</b> Represents a connection between two repository objects. A relationship can have properties (unlike the ODMG standard [4]). The relationship’s connection and properties are stored in the repository database. </li>
</ul>
<p>
The repository engine is a type-driven interpreter. A user defines classes, interfaces, properties, methods, and relationships. The repository engine then provides methods for creating objects that are instances of these classes, and for storing and retrieving these objects’ properties and relationships to and from the repository database. One good way to understand the repository’s capabilities is to understand what can be expressed in type definitions.</p>
<h3>3.2 The Type Model</h3>
<p>
Repository type definitions are ordinary repository objects that have certain properties and relationships that are interpreted by the repository engine. For example, a class definition is an object that has a property containing its unique identifier and a relationship to the interfaces it implements. This usage of its own storage mechanism for type definitions is analogous to SQL engines, which store type definitions as rows of tables.</p>
<p>
Type definitions are grouped into repository type libraries. These have the same logical structure and namespace behavior as Automation type libraries. Having the same namespace behavior is important for the repository to match Automation semantics for name-based access to properties and collections.* Specifically, class and interface names must be distinct (i.e., in <b>DIM X as ABC</b>, <b>ABC</b> could be a class or interface), and member names must be unique relative to an interface (that is, in <b>Object.MyMember</b>, <b>MyMember</b> could be a method, collection, or property). Classes and interfaces also have unique class ids, as in COM. *</p>
<p>
A type library contains definitions of the following kinds of objects: 
<ul type=disc>
<li>
<b>Class:</b> Defines which interfaces it supports, one of which is its default interface (for Automation).* <br><br></li>
<li>
<b>Relationship class:</b> Defines which collections (on which interfaces) are connected by instances of the relationship class. <br><br></li>
<li>
<b>Interface definition:</b> Defines which properties, collections, and methods are members of this interface, and which interface it inherits from.* <br><br></li>
<li>
<b>Property definition:</b> Defines properties of the property, such as its data type and its mapping to an underlying SQL column. <br><br></li>
<li>
<b>Collection definition:</b> Defines properties of the collection, such as min and max cardinality. These are properties of endpoints of a relationship type, called <i>roles</i> in some object models. <br><br></li>
<li>
<b>Method definition:</b> Defines properties of the method, such as its dispatch id.* </li>
</ul>
<p>
<img src="reposit02.gif" border=0></p>
<p class=label>
<b>Figure 2. An Information model</b></p>
<p>
As shown in Figure 2, interfaces are defined on classes, and properties and collections (i.e. relationships) are defined on interfaces.* Interface <b>IProject</b> describes project containers and <b>IProjectItem</b> describes objects that can be put into project containers. The Project class supports both <b>IProject</b> and <b>IProjectItem</b> (since a project can have subprojects), while the Form class supports <b>IProjectItem</b> but not <b>IProject</b>. Properties and relationships that are specific to forms are captured by <b>IForm</b> (shown in the Form class but not defined in Figure 2). The relationship Contains is accessible via the <b>ProjectItems</b> collection on <b>IProject</b> and the Projects collection on <b>IProjectItem</b>.</p>
<p>
Like all repository objects, type definitions are instances of classes, which in turn support interfaces that have properties and relationships stored in the repository. For example, the definitions of <b>IProject</b> and <b>IProjectItem</b> are instances of the class <b>InterfaceDef</b>, which supports the interfaces <b>IInterfaceDef</b> (which provides the behavior unique to interface definitions) and <b>IReposTypeInfo</b> (which allows interfaces to be the target of <b>DIM</b> statements in Visual Basic*). Thus, the information summarized in (i) – (vi) above is captured by the interfaces and relationships summarized in Figure 3.</p>
<p>
<img src="reposit03.gif" border=0></p>
<p class=label>
<b>Figure 3. Repository type model</b></p>
<p>
The classes that use these interfaces are as follows: 
<ul type=disc>
<li>
<b>ClassDef:</b> Supports <b>IReposTypeInfo</b> and <b>IclassDef</b><br><br></li>
<li>
<b>RelationshipDef:</b> Supports <b>IReposTypeInfo</b> and <b>IClassDef</b> (relationship-specific information is in <b>ICollectionDef</b>, so no "<b>IRelationshipDef</b>" interface is needed) <br><br></li>
<li>
<b>InterfaceDef:</b> Supports <b>IReposTypeInfo</b> and <b>IInterfaceDef</b> <br><br></li>
<li>
<b>PropertyDef:</b> Supports <b>IInterfaceMember</b> and <b>IPropertyDef</b> <br><br></li>
<li>
<b>CollectionDef:</b> Supports <b>IInterfaceMember</b> and <b>IcollectionDef</b><br><br></li>
<li>
<b>MethodDef:</b> Supports <b>IInterfaceMember</b> </li>
</ul>
<p>
The COM objects that represent type definitions are instances of the above classes.</p>
<p>
The classes are described as instances of themselves. That is, there is an instance of ClassDef for each of the above classes: ClassDef, RelationshipDef, etc. And there is an instance of RelationshipDef for each of the relationships in Fig. 3: IsScopeFor, Implements, Has, etc. In this sense, the repository is self-describing. This characteristic is useful for model-driven tools, such as generic browsers and scripting languages, which need to discover the information model at run time and which should be applicable to the repository’s type model as well as models customized for applications. It also positions the repository to exploit its own new features that appear in future releases. For example, when the repository supports version and configuration management of repository objects, type definitions will automatically be able to be versioned and grouped into configurations too.</p>
<p>
Several aspects of interface definitions are worth noting: 
<ul type=disc>
<li>
The repository engine supports interface inheritance with the same semantics as COM.* That is, if an interface I2 InheritsFrom an interface I1, then all of the properties and collections that are defined on I1 are also available on I2. <br><br></li>
<li>
Not all of the properties of an interface need to be persisted in the repository. <br><br></li>
<li>
An interface can include custom methods, whose existence can be documented in the interface definition stored in the repository. The information-model developer is responsible for implementing such methods (see Section 4). </li>
</ul>
<h3>3.3 Object Manipulation</h3>
<h4>Repository objects</h4>
<p>
Each repository object has a unique 20-byte opaque "external" id. It can be created by the repository or supplied by the caller when creating the repository object. The latter is useful to give an object and its replica the same identity (for example, a type definition that’s stored in many repositories). Objects also have an internal identifier that is an 8-byte compressed representation of the global identifier, an important storage optimization. The local identifier is always assigned by the repository and can be different in every repository. Object identity can be determined by comparing object IDs (internal or external).</p>
<p>
To use the repository, one starts by creating a <i>repository session</i>, which is an instance of the class Repository. One then uses the repository session’s <b>Create</b> method to create a new repository database or its <b>Open</b> method to open an existing repository database. Now, one can access repository objects by following relationships from well-known repository objects or by executing queries.</p>
<p>
One well-known repository object is the repository’s unique root object, which is accessible from the repository session and connected directly or indirectly to all other repository objects in the database. Usually, class and interface definitions are well known, since their object ids are the same in every repository. From a class definition, there is a computed relationship to all repository objects that are instances of that class. Similarly, there is a computed relationship from each interface definition to all repository objects that support that interface.</p>
<p>
To link up the result of a SQL query with the object-oriented API, the repository session supports a method <b>get_Object</b>, which loads an object given its object id. It also supports the <b>CreateObject</b> method, which creates a repository object of a given class.</p>
<p>
Repository objects can have single-valued scalar-valued properties, which are accessible using <b>IDispatch</b> (for Automation) and generic <b>get_value</b> and <b>put_value</b> methods (for COM). The former allows properties to be accessed using ordinary Visual Basic syntax*, such as</p>
<pre><code>DIM X as RepositoryObject
X.Foo = 7
</code></pre>
<p>
where Foo is a property of X’s default interface.</p>
<h4>Relationship objects</h4>
<p>
A relationship is bidirectional. That is, it can be followed from either of the repository objects it connects. Like a repository object, it can have properties. Unlike a repository object, it can’t have relationships or methods, though this restriction is likely to disappear in a future release. Customers drove us to support attributed relationships, which we accepted since it added no storage or run-time expense to information models that don’t use the feature.</p>
<p>
Each relationship is an instance of a <i>relationship class</i>. A relationship class definition connects two collection definitions (on the same or different interfaces), called the <i>origin</i> and <i>destination</i>. Although a relationship instance can be traversed in either direction, some semantics of the relationship is sensitive to the relationship’s polarity indicated by origin and destination. More on this later.</p>
<p>
Starting from a repository object, you can get to a relationship by accessing a relationship collection, and then accessing the relationship within the relationship collection. The repository object you start from is called the <i>source</i> and the one you traverse to is called the <i>target</i>. That is, the concepts of source and target are relative to the traversal direction. So, the source could be on the origin or destination side of the relationship’s relationship class. Notice that a relationship is actually a member of two collections, one on its source and one on its target. In the common case where you don’t need access to a relationship’s properties, you can skip over the relationship object and go directly from source to target, by using methods on <b>ITargetObjectCol</b>(lection) instead of <b>IRelationshipCol</b>. This ability to skip over relationship objects avoids one disadvantage of attributed relationships—that it makes programs that don’t need such attributes more verbose.</p>
<p>
For example, consider the Contains relationship between <b>IProject</b> and <b>IProjectItem</b> in Figure 2. Contains relationships would be accessed via the relationship collection <b>ProjectItems</b> (on interface <b>IProject</b>) on Project objects and the relationship collection Projects (on interface <b>IProjectItem</b>) on Form objects. The <b>GetProjectItems</b> method on <b>IProject</b> returns a collection of relationship objects, each of which points to a repository object supporting <b>IProjectItem</b>. (Or it may skip over the relationship objects and return a collection of Form objects.) Figure 4 is an instance-level view of this model, showing COM objects. The ProjectItems collection for the instance of the Project labeled MyProject has three relationships, one of which, labeled x, points to the instance of Form labeled MyForm. MyForm, in turn, supports <b>IProjectItem</b> and therefore has the collection Projects, which contains two relationships pointing to instances of Project, one of which is x pointing to MyProject.</p>
<p>
<img src="reposit04.gif" border=0></p>
<p class=label>
<b>Figure 4. Relationships and relationship collections</b></p>
<p>
Much of the interesting semantics of a repository is captured in the behavior of relationships. In ours, a relationship class can have three kinds of semantics: <i>naming</i>, <i>sequencing</i>, and <i>delete propagation</i>.</p>
<p>
A relationship can have a name, which identifies the destination object relative to its origin. The origin collection definition of the relationship class specifies whether it’s a naming relationship and, if so, whether names are case sensitive and/or unique (that is, whether two instances of the relationship from the same origin must have different names). Since there can be more than one naming relationship to a repository object, a repository object can have different names in different contexts. For example, if the contains relationship type in Figure 2 is a naming relationship, and <b>IProject</b> is the origin, then there could be two relationships from different projects to the same form. That is, a form could have a different name in different projects, as shown in Figure 5.</p>
<p>
<img src="reposit05.gif" border=0></p>
<p class=label>
<b>Figure 5. Named relationships</b></p>
<p>
As a convenience, an object can have a name that’s the same in all contexts by using a special interface <b>INamedObject</b>, which has one property called <b>Name</b>. If a repository object supports <b>INamedObject</b>, then the <b>put_Name</b> method on <b>IRepositoryObject</b> assigns the same name to that <b>Name</b> property and to all naming relationships to that object. A direct update to the <b>Name</b> property of <b>INamedObject</b> updates that property only. This avoids the extra API complexity of assigning names to every relationship to an object for programs that don’t need context-dependent naming.</p>
<p>
Within a relationship collection, the destination objects can be sequenced within the context of a particular origin object and relationship type. This is indicated by setting a flag on the origin collection definition. One can use the <b>Insert</b> and <b>Move</b> methods on relationship collections to control the sequencing. (If it’s a naming relationship and is not sequenced, the collection is ordered by name.) Sequencing is useful in many design scenarios, such as ordering column definitions in a table definition and ordering member definitions in an interface definition.</p>
<p>
<b>Delete</b> methods can propagate to objects beyond the one being deleted. Deleting a relationship usually affects only the relationship being deleted. However, if the delete propagation flag is set on the collection definition of the relationship’s origin, and the relationship is the last relationship of its type that points to the destination object, then the destination object is deleted too. This is useful for containment hierarchies, where an object that has no container should be deleted. Deleting a repository object causes the deletion of all incident relationships, some of which may propagate as just described.</p>
<h4>Support for IUnknown</h4>
<p>
Some of a repository object’s interfaces are generic interfaces supported by the repository engine on every repository object (for example, <b>IRepositoryObject</b>, <b>IDispatch</b>). Others are custom interfaces defined in the information model. The properties and relationships on these interfaces are implemented by the generic repository engine by interpreting these interfaces’ type definitions. Making these properties and relationships available through Automation involves making them accessible via interfaces that inherit from <b>IDispatch</b>.*</p>
<p>
Making these interfaces available through COM involves supporting COM methods to access them. This follows immediately from the Automation implementation, since <b>IDispatch</b> is a COM interface,* with one exception. The engine’s generic implementation of repository object would not respond positively to a <b>QueryInterface</b> call on <b>IUnknown</b> for custom interfaces. That is, the generic implementation of repository object would only know about interfaces that existed when its implementation was compiled. It would not know about interfaces that are defined later—custom interfaces, such as <b>IProject</b>. To ensure these custom interfaces are bona fide COM interfaces, the repository engine synthesizes such interfaces.* For each custom interface, such as <b>IProject</b>, it dynamically constructs a vtable for <b>IDispatch</b> that knows about the properties and collections of the custom interface. An object that supports this custom interface has a pointer to that vtable, and that pointer can be returned by a call to <b>QueryInterface</b> with the custom interface’s interface id as parameter.</p>
<h4>Support for model-driven tools</h4>
<p>
Model-driven tools need to discover information models at run time. This can be done by traversing type information stored in the repository. As a convenience, the repository offers a more direct way to get this information. It supports an interface <b>IRepositoryDispatch</b>, which inherits from <b>IDispatch</b> and supports one method, <b>Properties</b>. This method returns a collection of the properties and relationship collections defined on this interface, including those that are inherited from ancestor interfaces. To use this feature, interfaces defined in the information model should inherit from <b>IRepositoryDispatch</b>, rather than <b>IDispatch</b>.</p>
<p>
The repository also supports the COM equivalent of <b>QueryInterface</b> for Visual Basic programmers.* Recall from Section 2.2 that one can force an execution of <b>QueryInterface</b> in Automation, by declaring an object variable to be of a particular interface, as in "<b>DIM Y as IBar</b>." But this only works for interfaces known to an application at compile time. To give the same capability to model-driven tools, which discover the information model at runtime, repository objects support a method called <b>Interface</b>, which takes an interface as a parameter and casts the object to the requested interface. Thus, if <b>IBar</b> were discovered at run time, one could access property <b>Foo</b> on <b>IBar</b> as follows:</p>
<pre><code>DIM X as RepositoryObject
Set Y=X.Interface("IBar").Properties("Foo")
</code></pre>
<h3>3.4 Storage Model</h3>
<p>
The repository engine stores its data in a SQL database. This database contains the properties and relationships of objects stored in the repository. Some of the tables in this database are generic—they are present in every repository. The main generic tables are the object table and relationship table, which contain the basic information the engine needs to know about every repository object and relationship. Figure 6 shows how rows of these tables are related. Other tables are specific to the information model, such as the ProjectItem table in Figure 6.</p>
<p>
<img src="reposit06.gif" border=0></p>
<p class=label>
<b>Figure 6. Repository table layout</b></p>
<p>
They contain the properties that appear in custom interface definitions (cf. the IProjectItem definition in Fig. 2).</p>
<p>
For most purposes, the user of the repository (a tool programmer) calls methods on ActiveX objects. However, users will sometimes want to issue SQL queries to the repository database for faster or more complex retrievals. They can do this using the <b>ExecuteQuery</b> method on <b>IRepositoryODBC</b>, which is supported by the Repository class. <b>ExecuteQuery</b> takes a SQL query that includes object id and class id in the SELECT clause, so that it can cast the returned rows as repository objects, which it returns in a collection. Updating the tables directly is <i>not</i> recommended, since the repository engine’s update methods maintain the integrity of the database in subtle ways that a repository user might miss</p>
<p>
When repository type definitions are created or modified, the repository automatically generates and modifies the layout of SQL tables that persist interface-specific properties. Each table having interface-specific properties is keyed on internal object id (the 8-byte compressed form) and has all of the properties of each interface that is stored in that table. Thus, the unit of mapping from information model properties to a database schema is the interface.</p>
<p>
By default, the engine maps each interface on an object to a separate table. However, users can control this mapping by storing several interfaces in the same table. For example, a user can have the properties of <b>IProjectItem</b> stored in the same table as those of <b>IForm</b>. Also, users can add and remove indexes on these tables, in addition to the index on internal object id, which the engine defines by default.</p>
<p>
For fast traversal of relationships, the relationship table has a clustered index on [origin object id, relationship type, name] and a secondary index on the primary key [destination object id, relationship type, origin object id] (in SQL Server, a table’s clustered index needn’t be on its primary key). The most common queries on this table are to retrieve a relationship collection for a given object (given the origin id and relationship type, find the destination objects, or vice versa). For named collections, the third column in the index allows us to find a named relationship within a collection or retrieve the relationships in the collection in name sequence.</p>
<p>
The type definition classes ClassDef, RelationshipDef, InterfaceDef, etc. are mapped to tables in the same way as other classes, by mapping the interfaces they support (see Figure 3) into tables. For example, <b>IPropertyDef</b> has the properties: <b>APIType</b>, <b>SQLType</b>, <b>SQLSize</b>, <b>SQLScale</b>, <b>ColumnName</b>, and <b>Flags</b>. This interface is mapped to a table whose columns include these properties and an internal object id (its key). Given a property definition (a row in this table) and its associated interface definition (which identifies the interface’s table), the repository engine can find and interpret instances of this property.</p>
<p>
Since type information is frequently accessed, it is cached in an optimized main memory structure that’s persisted, to avoid recomputing it every time the repository is opened. The cost is updating this structure whenever a type definition is updated, a nontrivial but infrequently incurred expense.</p>
<h3>3.5 Transactions</h3>
<p>
Advanced transaction capability was not a goal of our version-one product. Rather, we wanted to minimize the implementation effort by passing through the transaction behavior of the underlying SQL DBMS. Still, even this modest goal required that we include some transaction functions in the repository engine itself.</p>
<p>
Like most database access models (for example, ODBC [6]), we attach transaction behavior to the user’s connection to the database, which in our case is a repository session. Thus, each repository session offers the <b>Begin</b>, <b>Commit</b>, and <b>Abort</b> methods. Every repository object is loaded in the context of a repository session and retains that context as long as it’s loaded. So its transaction context is implicit and need not be passed as a parameter to any calls.</p>
<p>
Transactions are flat, that is, not nested. All methods on a repository object execute within the transaction of its corresponding repository session. Methods within a transaction read committed data, so its updates are isolated from other transactions until it commits, when the updates are permanently installed in the database. That is, degree 2 (read committed) consistency is the default [1,7].</p>
<p>
Like other DBMS designers before us, we found that degree 3 consistency was fairly low on our customers’ priority list, so we swallowed our pride and deferred serializability for a later release. However, we do offer a lock primitive that allows users to explicitly synchronize access to shared data and thereby get the effect of two-phase locking, albeit with some application programming.</p>
<p>
Each repository session only allows one transaction to execute at a time. To have two concurrent transactions on the same repository database, one can create two repository sessions connected to that database. If the repository sessions execute in the same process, then they share the database cache. Therefore, updates by a transaction T in one repository session are visible to transactions in the other repository session as soon as T commits. Repository sessions in other processes will not see T’s updates until that process’s repository engine refreshes its cache, which it does periodically. Methods are offered to tell the repository engine to refresh its cache immediately, so an up-to-date view of the repository database can be obtained if needed. This explicit refresh seemed rather crude to us, but actually reflects the behavior of most of the tools that would use the repository. Most Windows-based tools, beginning with the Explorer, offer an explicit refresh.</p>
<p>
If an application has two repository sessions connected to the same database in the same process and loads the same repository object through both repository instances, it will get two COM objects representing the same persisted repository object. This is required because each repository (COM) object retains the context of the repository session that loaded it, where it gets its transaction context. To avoid a cache coherency problem, we ensure that both COM objects share the same cached copy of the repository object’s persistent state. We ensure this in all situations where two COM objects representing the same persisted repository object are concurrently active.</p>
<h2>4. Extensibility</h2>
<p>
Defining a class that has only properties and relationships involves providing type definitions only for the class and all of its interfaces. This is akin to writing data definitions in SQL. Moreover, one can extend classes in this way dynamically. For example, one can add an interface to an existing class, and the repository engine will create and alter table definitions as necessary.</p>
<p>
One can extend the behavior of the repository engine by providing custom code. Useful extensions could include validating special kinds of integrity constraints (which are not supported by the repository), adding custom methods to interfaces (such as supporting a <b>Build</b> method on <b>IProject</b>), or storing some properties of an object outside the repository (for example, in a file). This is done by writing a wrapper for the repository object, re-implementing interfaces that you want to extend, and calling the repository engine’s base implementation of those interfaces to read and write properties and relationships. (See Figure 7.) Interfaces that you do not want to extend are simply passed through. The mechanics of this wrapping is defined by COM aggregation, which was mentioned in Section 2.1.* When the repository creates or loads an object, it calls <b>CoCreateInstance</b>, thereby invoking the user’s customized class.</p>
<p>
<img src="reposit07.gif" border=0></p>
<p class=label>
<b>Figure 7. Using COM aggregation to extend a repository Object class</b></p>
<p>
This is another example of the repository using a standard COM mechanism, in this case one for extending objects.</p>
<p>
Another form of extensibility is the ability to create new versions of interfaces—that is, new versions of information models. This is a major problem in many repository systems. We support it using the standard COM approach explained in Section 2.1:* Every COM interface is immutable. Its interface id identifies a contract that, once published, cannot be changed. So, to change an interface, you define a new interface. Newly written clients are built to prefer the new interface but cope with the old one; newly written classes are built to support both interfaces, so that old clients can use them.</p>
<p>
One should then write an aggregation of the class that supports the new interface, and supports the old interface too by mapping old interface members to new interface members. The amounts to a view. One could automate this by a model-driven tool that creates the aggregated class from the interface definitions.</p>
<h2>5. Interface-Oriented Information Models</h2>
<p>
COM is highly interface-centric. One can write programs that access objects by navigating interfaces and never know the class of which those objects are instances. The only reason to know an object’s class is to create the object in the first place.</p>
<p>
COM’s interface-centric view has a profound effect on tools that share objects in the repository. To share data, tools only need to agree on interface definitions, not on class definitions.* For example, suppose we define an interface <b>IComponentDescription</b> that includes properties <b>Owner</b>, <b>TechnologyType</b> (for example, ActiveX control, stored procedure, Java applet), and <b>Status</b> (for example, draft, unit-tested, system-tested) and a collection <b>Keywords</b>. A component reuse tool that understands <b>IComponentDescription</b> could display useful information about the component and offer a keyword-based search of components. Many different tools could create reusable components that support <b>IComponent-Description</b>. For example, development tools for ActiveX controls, stored procedures, and Java applets could create objects of different classes, but all those classes could support <b>IComponentDescription</b> and therefore be visible to the component reuse tool.</p>
<p>
Thus, to support sharing between tools, the important part of an information model is the interface definitions, not the class definitions. The interface definitions define the properties and relationships that tools of a certain category need to depend on. Such categories are called <i>subject areas</i> in information-modeling terminology. Example subject areas are component-based design, databases, data warehouses, and project configurations.</p>
<p>
To share information, class definitions from different vendors support the same interfaces. However, similar classes from different vendors (such as the table definition class supported by database design tool vendors) don’t need to support the same combination of interfaces and typically have different implementations of those interfaces.* This flexibility has high payoff to a large vendor like Microsoft, which expects many other vendors to use its repository.</p>
<p>
Still, vendors often need to make some assumptions about which sets of interfaces are used in combination. Therefore, an information model should specify which sets of interfaces should be implemented together. For example, it might say that if a class supports <b>IForm</b>, then it must also support <b>IProjectItem</b>. In ActiveX, such a combination of interfaces is called a <i>cotype</i>.*</p>
<p>
At the level of mechanism, an information model consists of a set of interface definitions, each uniquely identified by its repository object id and COM interface id, along with the property, collection, relationship, and method definitions that it references. Generally, an information model is packaged in its own repository type library, so that it’s easy to tell if a repository has that information model loaded and so that independently developed information models need not worry about name conflicts and the like.</p>
<p>
Microsoft is collaborating with other vendors to publish open information models in areas that are relevant to its tool groups. This will enable independent tool vendors to share objects with Microsoft tools and each other. Given how easy it is to extend the repository, vendors will be able to specialize those information models to their needs without sacrificing interoperability with other vendors that conform to those information models.</p>
<h2>6. Conclusion</h2>
<p>
The repository is used in Visual Basic 5.0 as the storage for a component reuse tool. It also supports an information model for Rational Software’s Unified Modeling Language (UML), which is under consideration as an OMG standard [8]. It is used in to support the exchange of object models with the Visual Basic Visual Modeler tool.</p>
<p>
Since the Microsoft Repository is a new product, it’s too soon to draw strong conclusions about whether tool vendors find it a useful place to store and share persistent objects. Likewise, it’s too soon to tell whether the trade-offs that were made to meet the product release schedule were the optimal ones.</p>
<p>
However, we do feel quite confident that the primary goal of fitting hand-in-glove with COM and Automation has been well met, yielding several major benefits: 
<ul type=disc>
<li>
Extensibility and evolvability of types and classes without breaking applications<br><br></li>
<li>
Class-independent sharing of type information using interfaces<br><br></li>
<li>
Easy prototyping of information models without writing any code<br><br></li>
<li>
Use of Visual Basic as a persistent programming language with no impedance mismatch </li>
</ul>
<p>
The first two benefits we attained by supporting COM, with its interface-oriented type system, globally unique interface ids, and self-describing objects via the method <b>QueryInterface</b>. The third benefit is attained by the type-driven interpreter. And the last benefit was attained by supporting <b>IDispatch</b>, with a type system that is compatible with type libraries.</p>
<h2>Acknowledgments</h2>
<p>
The design of the Microsoft Repository interfaces was a joint effort between Microsoft Corp. and Texas Instruments, Inc., originally conceived by David Vaskevitch of Microsoft and Keith Short of Texas Instruments. We’re grateful for their sponsorship of the effort. In addition to the authors, early contributors to the design effort included John Cheesman and Bill Dawson (Texas Instruments), and Melissa Waldie and Laura Yedwab (Microsoft). We learned much from their initial investigations. We also thank Thomas Bergstraesser, Murat Ersan, and David Maier for their help with many aspects of the design and implementation.</p>
<h2>References </h2>
<p>
1. Berenson, H., P. A. Bernstein, J. Gray, J. Melton, E. O’Neil, and P. O’Neil, "A Critique of ANSI SQL Isolation Level," Proc. ACM SIGMOD 1995, ACM, N.Y. </p>
<p>
2. Bernstein, P.A., "Repositories and Object-Oriented Databases," Proceedings of BTW 1997, Springer, March 1997, pp. 34–46. </p>
<p>
3. Bernstein, P.A., and U. Dayal, "An Overview of Repository Technology," International Conference on Very Large Data Bases, Morgan Kaufmann Publishers, San Francisco, 1994, pp. 705–713. </p>
<p>
4. Cattell, R.G.G., T. Atwood, D. Barry, J, Duhl, J. Eastman, G. Ferran, D. Jordan, M. Loomis, and D. Wade, "The Object Database Standard: ODMG-93," Morgan Kaufmann Publishers, San Francisco, CA 1995. </p>
<p>
5. Constantopoulos, P., M. Jarke, J. Mylopoulos, and Y. Vassiliou, "The Software Information Base: A Server for Reuse," VLDB Journal, 4 (1995), Boxwood Press, Pacific Grove, CA, pp. 1–43. </p>
<p>
6. Geiger, K., <i>Inside ODBC</i>, Microsoft Press, Redmond, WA, 1995. </p>
<p>
7. Gray, J., R. Lorie, G. Putzolu and I. Traiger, "Granularity of Locks and Degrees of Consistency in a Shared Data Base," in <i>Readings in Database Systems</i>, 2nd Edition, Chapter 3, Michael Stonebraker, Ed., Morgan Kaufmann 1994 (originally published 1977). </p>
<p>
8. Rational Corp., "Unified Modeling Language Resource Center," http://www.rational.com/uml. </p>
<p>
9. Rogerson, D., <i>Inside COM</i>, Microsoft Press, Redmond, WA, 1997. </p>
<p>
10. Wakeman, L. and J. Jowett, <i>PCTE – The Standard for Open Repositories</i>, Prentice-Hall, 1993. </p>
<p>
11. Zdonik, S.B., and D. Maier, <i>Readings in Object-Oriented Database Systems</i>, Morgan Kaufmann Publishers, San Francisco, 1990. </p>
<p>
--------------------------------------------------</p>
<p>
<i>Permission to copy without fee all or part of this material is granted provided that the copies are not made or distributed for direct commercial advantage, the VLDB copyright notice and the title of the publication and its date appear, and notice is given that copying is by permission of the Very Large Data Base Endowment. To copy otherwise, or to republish, requires a fee and/or special permission from the Endowment.</i></p>
<p>
<i>©1997 Very Large Data Base Endowment</i></p>
</BODY>
</HTML>
