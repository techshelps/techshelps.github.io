<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DirectX Version 5.0 New Features Review</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_directx5"></a>DirectX Version 5.0 New Features Review</h1>
<p>
Microsoft Corporation</p>
<p>
September 1997</p>
<h2>Abstract</h2>
<p>
Microsoft® DirectX® provides a finely tuned set of application programming interfaces (APIs) that provide you with the resources you need to design high-performance, real-time applications. The DirectX set of APIs provides Windows®-based applications with high-performance, real-time access to available hardware on current and future computer systems. DirectX provides a consistent interface between hardware and applications, reducing the complexity of installation and configuration and using the hardware to its best advantage. By using the interfaces provided by DirectX, software developers can take advantage of hardware features without being concerned about the implementation details of that hardware.</p>
<h4>Contents</h4>
<p>
<a href="#directx5_new">DirectX Version 5.0 New Features Review</a></p>
<p>
<a href="#directx5_what">What's New in DirectX 5.0</a></p>
<p>
<a href="#directx5_com">DirectX and COM</a></p>
<p>
<a href="#directx5_draw">DirectDraw</a></p>
<p>
<a href="#directx5_sound">DirectSound</a></p>
<p>
<a href="#directx5_input">DirectInput</a></p>
<p>
<a href="#directx5_immed">Direct3D Immediate Mode</a></p>
<p>
<a href="#directx5_retain">Direct3D Retained Mode</a></p>
<p>
<a href="#directx5_play">DirectPlay</a></p>
<p>
<a href="#directx5_set">DirectSetup</a></p>
<p>
<a href="#directx5_formor">For More Information</a></p>
<h2><a name="directx5_new"></a>DirectX version 5.0 New Features Review</h2>
<p>
While continuing to expand support for performance games, Microsoft DirectX version 5.0 lays the foundation for extending DirectX media services to multimedia, Internet, and other performance applications.</p>
<p>
Microsoft DirectX provides a finely tuned set of APIs that provide you with the resources you need to design high-performance, real-time applications. Microsoft developed the DirectX set of APIs so that the performance of applications running in the Microsoft Windows operating system can exceed the performance of applications running in the MS-DOS® operating system or on game consoles.</p>
<p>
DirectX provides Windows-based applications with high-performance, real-time access to available hardware on current and future computer systems. DirectX provides a consistent interface between hardware and applications, reducing the complexity of installation and configuration and using the hardware to its best advantage. By using the interfaces provided by DirectX, software developers can take advantage of hardware features without being concerned about the implementation details of that hardware.</p>
<h3>DirectX 5.0 Goals</h3>
<p>
DirectX 5.0 has been developed to meet a set of related goals:</p>
<p>
<b>Unify media services.</b> With DirectX, games and multimedia developers get the benefits of device independence without losing the benefits of direct access to the hardware. To accomplish this, DirectX provides a consistent API interface, device independence through the hardware abstraction layer/hardware emulation layer (HAL/HEL) architecture, and APIs that provide both low-level and high-level services.</p>
<p>
<b>Support entertainment, multimedia, and Internet development.</b> When Microsoft created DirectX, one of its primary goals was to promote games development for the Windows environment. Prior to DirectX, the majority of games developed for the personal computer were MS-DOS–based. Developers of these games had to conform to a number of hardware implementations for a variety of cards. With the success of DirectX, this original mission has been extended to provide the media performance required by game developers to a larger class of applications, including multimedia and accelerated Internet content.</p>
<p>
<b>Enable hardware innovation.</b> A key element of the success and importance of DirectX is that it is enabling a new generation of hardware innovation on personal computers. DirectX provides hardware development guidelines based on feedback from developers of high-performance applications and independent hardware vendors (IHVs). As a result, DirectX components might provide specifications for hardware-accelerator features that do not yet exist. In many cases, the software emulates these features. In other cases, the software polls the hardware regarding its capabilities and bypasses the feature if it is not supported.</p>
<p>
<b>Serve developers, hardware makers, and end users.</b> Putting all these together, DirectX offers an evolving, innovative performance media platform for software developers, hardware makers, and end users.</p>
<p>
DirectX offers hardware makers a key vehicle to introduce new classes of hardware features and achieve new levels of media processing performance. At the same time, DirectX offers software developers access to hardware features without being concerned about the implementation details of that hardware. For end users, DirectX offers to reduce he complexity of installation and configuration and an assurance that software will use hardware to its best advantage</p>
<h2>DirectX 5.0 Architecture</h2>
<p>
DirectX 5.0 introduces a new "big-picture" architecture that organizes DirectX into two sets of services: the low-level DirectX foundation and high-level DirectX media.</p>
<p>
The big-picture organization of DirectX services is shown in Figure 1.</p>
<p>
<img src="directx501.gif" border=0></p>
<p class=label>
<b>Figure 1. DirectX architecture</b></p>
<p>
DirectX foundation provides the basis for performance media on Windows-based computers, through DirectDraw®, DirectInput®, DirectSound®, and Direct3D® Immediate Mode:</p>
<p class=label>
<b>Figure 2. DirectX foundation</b></p>
<p>
DirectX media is a set of higher-level APIs that use DirectX foundation. These services include Direct3D Retained Mode, DirectShow™, DirectAnimation™, DirectModel and DirectShow. Support for Virtual Reality Markup/Modeling Language (VRML) is also provided in DirectX media.</p>
<p>
<img src="directx503.gif" border=0></p>
<p class=label>
<b>Figure 3. DirectX Media</b></p>
<h2><a name="directx5_what"></a>What's New In DirectX 5.0</h2>
<p>
DirectX 5.0 is primarily an upgrade of DirectX foundation; DirectX 5.0.1 in the near future will be the first major release of DirectX media, which will include DirectAnimation, DirectShow (the system-level portions of ActiveMovie™), and VRML support.</p>
<p>
The key new features in DirectX 5.0 are summarized below:</p>
<p class=label>
<b>Table 1. New DirectX features</b></p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=29%><b>DirectX 5.0 Service</b></td>
<td class=label width=34%><b>Description</b></td>
<td class=label width=37%><b>New features</b></td>
</tr>
</table><br>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td width=29%><b>DirectX foundation</b></td>
<td width=32%></td>
<td width=39%></td>
</tr>
<tr valign=top>
<td width=29%><b>DirectDraw</b></td>
<td width=32%>Graphics surface management</td>
<td width=39%>Video-ports, new MMX HEL, AGP</td>
</tr>
<tr valign=top>
<td width=29%><b> DirectSound</b></td>
<td width=32%>Sound mixer and effects</td>
<td width=39%>3D HAL, capture, property sets</td>
</tr>
<tr valign=top>
<td width=29%><b>Direct3D Immediate Mode</b></td>
<td width=32%>Low-level 3D display</td>
<td width=39%>DrawPrimitive, overloads</td>
</tr>
<tr valign=top>
<td width=29%><b>DirectInput</b></td>
<td width=32%>Input device interface</td>
<td width=39%>New devices, force feedback</td>
</tr>
<tr valign=top>
<td width=29%><b>DirectSetup</b></td>
<td width=32%>Driver installation</td>
<td width=39%>Improved driver updating, user interface customization</td>
</tr>
</table><br>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td width=29%><b>DirectX media </b></td>
<td width=34%></td>
<td width=37%></td>
</tr>
<tr valign=top>
<td width=29%><b>Direct3D Retained Mode</b></td>
<td width=34%>3D scene graph</td>
<td width=37%>Interpolators, progressive meshes</td>
</tr>
<tr valign=top>
<td width=29%><b>Microsoft DirectPlay®</b></td>
<td width=34%>Multiuser player</td>
<td width=37%>Connection shortcuts, improved password protection, secure server connections</td>
</tr>
</table><br>
<h2><a name="directx5_com"></a>DirectX and COM</h2>
<p>
Most APIs in the DirectX Software Development Kit (SDK) are composed of objects and interfaces based on the Component Object Model (COM). COM is a foundation for an object-based system that focuses on reuse of interfaces, and it is the model at the heart of COM programming. It is also an interface specification from which any number of interfaces can be built. It is an object model at the operating-system level.</p>
<p>
Many DirectX APIs are created as instances of COM objects. You can consider an object to be a black box that represents the hardware and requires communication with applications through an interface. The commands sent to and from the object through the COM interface are called methods. For example, the <b>IDirectDraw2::GetDisplayMode </b>method is sent through the <b>IDirectDraw2</b> interface to get the current display mode of the display adapter from the DirectDraw object.</p>
<p>
Objects can bind to other objects at run time, and they can use the implementation of interfaces provided by the other object. If you know an object is a COM object, and if you know which interfaces that object supports, your application (or another object) can determine which services the first object can perform. One of the methods all COM objects inherit, the <b>QueryInterface</b> method, lets you determine which interfaces an object supports and creates pointers to these interfaces.</p>
<p>
COM dictates that objects update their functionality not by changing the methods within existing interfaces, but by extending new interfaces that encompass new features. By keeping existing interfaces static, an object built on COM can freely extend its services while maintaining compatibility with older applications.</p>
<p>
DirectX components follow this philosophy. For example, the DirectDraw component supports three versions of the <b>IDirectDrawSurface</b> interface: <b>IDirectDrawSurface</b>, <b>IDirectDrawSurface2</b>, and <b>IDirectDrawSurface3</b>. Each version of the interface supports the methods provided by its ancestor, adding new methods to support new features. If your application doesn't need to use these new features, it doesn't need to retrieve newer interfaces. However, to take advantage of features provided by a new interface, you must call the object's <b>IUnknown::QueryInterface </b>method, specifying the globally unique identifier (GUID) of the interface you want to retrieve. Interface GUIDs are declared in the corresponding header file.</p>
<p>
In some rare cases, a new interface will not support some methods provided in a previous interface version. The <b>IDirect3DDevice2</b> interface is an example of this type of interface. If your application requires features provided by an earlier version of an interface, you can query for the earlier version in the same way as shown in the preceding example, using the GUID of the older interface to retrieve it.</p>
<h2><a name="directx5_draw"></a>DirectDraw</h2>
<p>
DirectDraw is the foundation for performance graphics and video on Windows platforms. DirectDraw is essentially a memory manager for graphics and video surfaces that provides access to hardware-accelerated functions like blitting and overlays.</p>
<p>
DirectDraw works with a wide variety of display hardware, ranging from simple SVGA monitors to advanced hardware implementations that provide clipping, stretching, and non-RGB color format support. The interface is designed so that applications can enumerate the capabilities of the underlying hardware and then use any supported hardware-accelerated features. DirectDraw emulates features that are not implemented in hardware.</p>
<p>
DirectDraw is not a high-level graphics API that draws graphics primitives like lines and rectangles. Instead, DirectDraw is a low-level API that operates at the graphics surface level, providing the base for higher-level two-dimensional (2-D) and three-dimensional (3-D) graphics APIs.</p>
<p>
Key features of DirectDraw are:
<ul type=disc>
<li>
<b>HAL/HEL architecture.</b> The DirectDraw HAL provides a consistent interface through which to work directly with the display and video memory, getting maximum performance from the system hardware. Additionally, DirectDraw provides a HEL to support features when the hardware does not.<br><br></li>
<li>
<b>Graphics acceleration. </b>DirectDraw assesses the video hardware's capabilities, making use of special hardware features whenever possible. For example, if your video card supports hardware blitting, DirectDraw delegates blits to the video card, greatly increasing performance.<br><br></li>
<li>
<b>32-bit memory.</b> DirectDraw exists over the Windows 95 operating system, gaining the advantage of 32-bit memory addressing and a flat memory model that the operating system provides. DirectDraw presents video and system memory as large blocks of storage, not as small segments. If you've ever used <i>segment:offset</i> addressing, you will quickly begin to appreciate this "flat" memory model.<br><br></li>
<li>
<b>Page flipping.</b> DirectDraw makes it easy for you to implement page flipping with multiple back buffers in full-screen applications.</li>
</ul>
<p>
DirectDraw also provides:
<ul type=disc>
<li>
Support for clipping in windowed or full-screen applications.<br><br></li>
<li>
Support for 3-D z-buffers.<br><br></li>
<li>
Support for hardware-assisted overlays.<br><br></li>
<li>
Access to image-stretching hardware.<br><br></li>
<li>
Simultaneous access to standard and enhanced display-device memory areas.<br><br></li>
<li>
Other features including custom and dynamic palettes, exclusive hardware access, and resolution switching.</li>
</ul>
<p>
These features combine to make it possible for you to write applications that easily out-perform standard Windows GDI-based applications and even MS-DOS–based applications.</p>
<h4>New in DirectX 5.0</h4>
<ul type=disc>
<li>
<b>Video-ports. </b>Video ports allow applications to control the flow of data from a hardware video-port device to a DirectDraw surface in display memory.<br><br></li>
<li>
<b>MMX HEL</b>. The DirectDraw HEL now exploits performance improvements made possible by the Pentium MMX processor. DirectDraw tests for the presence of an MMX processor the first time you create a surface in any process.<br><br></li>
<li>
<b>AGP.</b> DirectDraw now supports the Advanced Graphics Port (AGP) architecture. On AGP-equipped systems, you can create surfaces in non-local video memory. The DDSCAPS structure now supports flags to differentiate between standard (local) video memory and AGP (non-local) video memory. The DDCAPS structure now contains members that carry information about blit operations using non-local video memory surfaces.<br><br></li>
<li>
<b>Wide surfaces</b>. DirectDraw now supports off-screen surfaces wider than the primary surface. You can create surfaces as wide as you need, permitting that the display hardware can support it.</li>
</ul>
<h3>Why use DirectDraw?</h3>
<p>
The key reason to use DirectDraw is that it offers faster graphics performance than the standard Microsoft Win32® graphics functions and provides access to a new generation of graphics accelerators.</p>
<p>
Most Windows programs access drawing surfaces indirectly through the Win32 device context functions such as <b>GetDC</b>. The application then writes indirectly to the device context through the graphics device interface (GDI) system. The GDI is a system component that provides an abstraction layer that enables standard Windows applications to draw to the screen.</p>
<p>
The drawback of GDI is that it was not designed for high-performance multimedia software, it was made to be used by business applications like word processors and spreadsheet applications. GDI provides access to a video buffer in system memory, not video memory, and does not take advantage of special features that some video cards provide. In short, GDI is great for most types of business software, but its performance is too slow for multimedia or game software.</p>
<p>
On the other hand, DirectDraw provides drawing surfaces that represent actual video memory. This means that with DirectDraw an application can write directly to the memory on the video card, making your graphics routines extremely fast. These surfaces are represented as contiguous blocks of memory, making it easy to perform addressing within them.</p>
<h3>What Is a Surface?</h3>
<p>
A surface is memory that represents visual images. A surface can be memory physically located on a graphics board, or it can an also be system memory used for graphics or video purposes.</p>
<p>
Unless specifically instructed otherwise during the creation of the DirectDrawSurface object, DirectDraw object will put the DirectDrawSurface object wherever the best performance can be achieved given the requested capabilities. DirectDrawSurface objects can take advantage of specialized processors on display cards, not only to perform certain tasks faster, but also to perform some tasks in parallel with the system CPU.</p>
<p>
DirectDraw provides device-dependent access to display memory in a device-independent way. Essentially, DirectDraw manages display memory. Your application need only recognize some basic device dependencies that are standard across hardware implementations, such as RGB and YUV color formats and the pitch between raster lines. You need not call specific procedures to use the blitter or manipulate palette registers. Using DirectDraw, you can manipulate display memory with ease, taking full advantage of the blitting and color decompression capabilities of different types of display hardware without becoming dependent on a particular piece of hardware.</p>
<p>
DirectDraw is a software interface that provides direct access to display devices while maintaining compatibility with the Windows GDI. DirectDraw provides a device-independent way for games and Windows subsystem software, such as 3-D graphics packages and digital video codecs, to gain access to the features of specific display devices.</p>
<h3>Video-Ports</h3>
<p>
A video port, new in DirectX 5.0, is hardware on a display device that enables direct access to a surface within the frame buffer, bypassing the CPU and PCI bus. Direct frame buffer access makes it possible to efficiently play live or recorded video without creating noticeable load on the CPU. Once in a surface, an image can be displayed on the screen as an overlay, used as a Direct3D texture, or accessed by the CPU for capture or other processing.</p>
<p>
In a machine equipped with a video port, data in a video stream can flow directly from a video source through a video decoder and the video port to the frame buffer. These components often exist together on a display adapter, but can be on separate hardware components that are physically connected to one another.</p>
<p>
An example of this data flow is shown in Figure 4.</p>
<p>
<img src="directx504.gif" border=0></p>
<p class=label>
<b>Figure 4. Video data flow</b></p>
<p>
<b>Video source.</b> In the scope of video-port technology, a video source is strictly a hardware video input device, such as a Zoom Video port, MPEG codec, or other hardware source. These sources broadcast signals in a variety of formats, including NTSC, PAL, and SECAM (or in a digital TV format) through a physical connection to a video decoder.</p>
<p>
<b>Video decoder.</b> A video decoder is also a hardware component. The video decoder's job is to decipher the information provided by the video source and send it to the video port in an agreed upon connection format. The decoder possesses a physical connection to the video port, and exposes its services through a stream class minidriver. The decoder is responsible for sending video data and clock and sync information to the video port.</p>
<p>
<b>Video-port.</b> Like the other components in the data flow path, the video-port is a piece of hardware. The video port exists on the display adapter's VGA chip and has direct access to the frame buffer. It receives information sent from the decoder, processes it, and places it in the frame buffer to be displayed. During processing, the video port can manipulate image data to provide scaling, shrinking, color control, or cropping services.</p>
<p>
<b>Frame buffer.</b> The frame buffer accepts video data as provided by the video port. Once received, applications can programmatically manipulate the image data, blit it to other locations, or show it on the display using an overlay (the most common function).</p>
<h2><a name="directx5_sound"></a>DirectSound</h2>
<p>
DirectSound is the audio component of DirectX. DirectSound enables hardware and software sound mixing, capture, and effects like 3-D positioning and panning.</p>
<p>
Key features of DirectSound are:
<ul type=disc>
<li>
<b>Low-latency mixing playback.</b> Multiple sounds can be mixed together and played at the same time.<br><br></li>
<li>
<b>Hardware acceleration. </b>Sound card features are engaged automatically or emulated in software if not supported in hardware.<br><br></li>
<li>
<b>Effects and 3-D positioning. </b>Applications can change volume, frequency and panning and can simulate 3-D positional effects through rolloff, arrival offset, muffling and Doppler shift effects.<br><br></li>
<li>
<b>Direct access to the sound device. </b>Custom mixing engines can directly access the sound hardware.</li>
</ul>
<h4>New in DirectX 5.0</h4>
<ul type=disc>
<li>
<b>Audio capture.</b> Applications can now record as well as play back sounds<br><br></li>
<li>
<b>Property sets</b>. Applications can access extended services offered by specific sound cards.<br><br></li>
<li>
<b>3-D HAL.</b> Hardware acceleration of 3-D positional effects is supported in DirectX 5.0.</li>
</ul>
<h3>DirectSound and Windows Audio Functions</h3>
<p>
Despite the advantages of DirectSound, the standard waveform-audio functions in Windows continue to be a practical solution for certain tasks. For example, an application can easily play a single sound or audio stream, such as introductory music, by using the <b>PlaySound</b> or <b>WaveOut</b> functions.</p>
<p>
The relationship between DirectSound and Windows sound functions is shown in Figure 5.</p>
<p>
<img src="directx505.gif" border=0></p>
<p class=label>
<b>Figure 5. The DirectSound and Windows sound relationship</b></p>
<h3>How DirectSound Works</h3>
<p>
DirectSound is essentially a sound mixing engine. The application places a set of sounds in buffers, called secondary buffers. DirectSound combines these sounds and writes them into a primary buffer, which holds the sound that the listener actually hears.</p>
<p>
DirectSound automatically creates a primary buffer, which typically will reside in memory on a sound card. The application creates the secondary buffers either in system memory or directly on the sound card.</p>
<p>
<img src="directx506.gif" border=0></p>
<p class=label>
<b>Figure 6. How DirectSound works</b></p>
<p>
Depending on the type of sound card, DirectSound buffers can exist in hardware as on-board RAM, wave-table memory, a direct memory access (DMA) channel, or a virtual buffer (for an input/output [I/O] port–based audio card). Where there is no hardware implementation of a DirectSound buffer, it is emulated in system memory. Secondary sound buffers can be either static (contain a complete sound) or streaming (a small sound buffer that plays a lengthy sound because the application dynamically loads data into the buffer while it is playing).</p>
<p>
Only the available processing time limits the number of buffers that DirectSound can mix, and an application can query a sound buffer to determine what percentage of main processing cycles are needed to mix the sound buffer. The DirectSound mixer can provide as little as 20 milliseconds of latency, so there is no perceptible delay before play begins. Under these conditions, if an application plays a buffer and immediately begins a screen animation, the audio and video appear to start at the same time. However, if DirectSound must emulate hardware features in software, the mixer cannot achieve low latency and a longer delay (typically 100-150 milliseconds) occurs before the sound is reproduced.</p>
<p>
DirectSound supports pulse-code modulation (PCM) sound data, but does not currently support compressed wave formats. DirectSound does not include functions for parsing a sound file. It is the responsibility of the developer to stream data in the correct format into the secondary sound buffers.</p>
<p>
Multiple applications can create DirectSound objects for the same sound device. When the input focus changes between applications, the audio output automatically switches from one application's streams to another's. Applications thus do not have to repeatedly play and stop their buffers when the input focus changes. Also sound buffers can have "sticky focus"—the ability of sounds from one application to play while the user is using another application.</p>
<h3>Effects and 3-D Sound</h3>
<p>
DirectSound's mixing engine does not simply mix several sounds together. It can also apply effects to a sound as it is written from a secondary buffer into the primary buffer. Although these effects are audible using standard loudspeakers, they are more obvious and compelling when the user wears headphones.</p>
<p>
Basic effects are volume and frequency control and panning (changing the relative volume between the left and right audio channels).</p>
<p>
But DirectSound can also simulate 3-D positional effects through the following techniques:
<ul type=disc>
<li>
<b>Rolloff.</b> The further an object is from the listener, the quieter it sounds. This phenomenon is known as rolloff.<br><br></li>
<li>
<b>Arrival offset</b><i>.</i> A sound emitted by a source to the listener's right will arrive at the right ear slightly before it arrives at the left ear. (The duration of this offset is approximately a millisecond.)<br><br></li>
<li>
<b>Muffling</b><i>.</i> The orientation of the ears ensures that sounds coming from behind the listener are slightly muffled compared with sounds coming from in front. In addition, if a sound is coming from the right, the sounds reaching the left ear will be muffled by the mass of the listener's head as well as by the orientation of the left ear.<br><br></li>
<li>
<b>Doppler shift effect. </b>DirectSound automatically creates Doppler shift effects for any buffer or listener that has a velocity. Effects are cumulative: if the listener and the sound source are both moving, the system automatically calculates the relationship between their velocities and adjusts the Doppler effect accordingly.</li>
</ul>
<p>
An application can also implement its own custom mixing algorithm, and DirectSound will let the application write directly to the primary buffer.</p>
<h2><a name="directx5_input"></a>DirectInput</h2>
<p>
DirectInput provides high-performance access to input devices including the mouse, keyboard, joystick, and the new force-feedback (input/output) devices that are coming to market.</p>
<p>
Why use DirectInput over the standard Win32 API input device functions? DirectInput offers two key benefits:
<ul type=disc>
<li>
<b>Support for more types of devices</b>. DirectInput's generalized device interfaces support a much wider range of input and output devices than the standard Win32 API functions.<br><br></li>
<li>
<b>Faster responsiveness</b>. DirectInput works directly with device drivers, bypassing the Windows message system. This means faster, more responsive access to input devices, which is essential for games and other high-performance applications.</li>
</ul>
<h4>New in DirectX 5.0</h4>
<ul type=disc>
<li>
<b>Support for new devices</b>. DirectInput now offers new services for joysticks and other devices such as game pads, flight yokes, steering wheels, and virtual-reality headgear. These new services supersede the Win32 API functions centered on <b>joyGetPosEx</b>, which were previously documented as part of DirectInput.<br><br></li>
<li>
<b>Force feedback.</b> DirectInput now supports force feedback devices through the <b>DirectInputEffect</b> interface. Force feedback devices "respond" to an application with application-definable effects, such as kick-back when a trigger is fired, vibration, and resistance. Force feedback devices make many game and entertainment experiences much more realistic and engaging.<br><br></li>
<li>
<b>USB Joystick Support.</b> Universal Serial Bus (USB) is a new external PC bus that provides a new, exciting way to add high-speed game devices to a PC. USB is a serial protocol that runs at 1-12 megabits per second, with complete support for Plug and Play, power management, and hot plugging to add or change devices without turning of the PC. DirectInput provides an interface that developers can use to get fast consistent direct access to game devices, including USB devices.</li>
</ul>
<h3>How DirectInput Works</h3>
<p>
Like other DirectX components, DirectInput is based on COM. The basic architecture of DirectInput is a hierarchy of objects:
<ul type=disc>
<li>
<b>DirectInput object.</b> The DirectInput object is the overall manager object that an application uses to initialize and configure input devices.<br><br></li>
<li>
<b>Devices.</b> Each DirectInputDevice object represents one input device such as a mouse, keyboard, or joystick. Two or more DirectInputDevice objects may represent a physical device that is really a combination of different types of input devices, such as a keyboard with a trackball. A force feedback device is represented by a single joystick device object that handles both input and output.<br><br></li>
<li>
<b>Object instances.</b> Each device in turn has "object instances," which are individual controls or switches such as keys, buttons, or axes. For example, object instances on a joystick might include the x-axis and y-axis of the stick, several buttons, and a throttle slider. Mouse objects might include two or three buttons, the x-axis and y-axis, and a wheel. For a keyboard, each key is an object.<br><br></li>
<li>
<b>Effects.</b> Objects called effects represent individual force-feedback effects.</li>
</ul>
<p>
DirectInput's object architecture is summarized in Figure 7.</p>
<p>
<img src="directx507.gif" border=0></p>
<p class=label>
<b>Figure 7. DirectInput architecture</b></p>
<p>
DirectInput supplies two types of data: <i>buffered</i> and <i>immediate</i>. Buffered data is a record of events that is stored until an application retrieves it. Immediate data is a snapshot of the current state of a device.</p>
<p>
There are two ways to find out whether input data is available: by polling and by event notification. Polling a device means regularly getting the current state of the device objects with <b>IDirectInputDevice::GetDeviceState</b> or retrieving the contents of the buffer with <b>IDirectInputDevice::GetDeviceData</b>.</p>
<p>
Polling is typically used by real-time games that are never idle but are constantly updating and rendering the game world. Event notification is suitable for applications that wait for input before doing anything. To use event notification, the application sets up a thread synchronization object with the Win32 <b>CreateEvent</b> function and then associates this event with the device by passing its handle to <b>IDirectInputDevice::SetEventNotification</b>. DirectInput then signals the event whenever the state of the device changes. The application can receive notification of the event with a Win32 function such as <b>WaitForSingleObject</b>, and then respond by checking the input buffer to find out what the event was.</p>
<h3>Integration with Windows</h3>
<p>
Because DirectInput works directly with the device drivers, it either suppresses or ignores mouse and keyboard messages. When using the mouse in exclusive mode, DirectInput suppresses mouse messages; as a result, Windows is unable to show the standard cursor.</p>
<p>
DirectInput also ignores mouse and keyboard settings made by the user in the Windows Control Panel. For the mouse, DirectInput ignores Control Panel settings such as acceleration and swapped buttons. Again, DirectInput works directly with the mouse driver, bypassing the subsystem of Windows that interprets mouse data for windowed applications. For a joystick or other game device, DirectInput does use the calibrations set by the user in Control Panel.</p>
<p>
For the keyboard, DirectInput does not use character repeat settings. When using buffered data, DirectInput interprets each press and release as a single event, with no repetition. When using immediate data, DirectInput is concerned only with the present physical state of the keys, not with keyboard events as interpreted by Windows.</p>
<p>
As far as DirectInput is concerned, the keyboard is not a text input device but a game pad with many buttons. When an application requires text input, DirectInput is not the recommended method. It is far easier to retrieve the data from the normal Windows messages, which conveniently offer services such as character repeat and translation of physical keys to virtual keys.</p>
<h3>Force Feedback</h3>
<p>
Unlike a typical input device like a mouse, keyboard, or joystick, a force-feedback device is also an output device. This means that a force-feedback device moves or responds in some way to output from the application. For example, a joystick could be made to vibrate to simulate the motor of a racecar or kick back when firing a missile. A motor mounted in the base of a joystick could create the "force" in the joystick. Force feedback devices are beginning to appear on the market at consumer price points.</p>
<h3>Effects</h3>
<p>
DirectInput provides a generalized interface for force-feedback devices through the DirectInputEffect object. A particular instance of movement or resistance over a period of time is called an effect. With DirectInput, an application can define, manipulate and apply a wide range of standard and custom effects to a force feedback device.</p>
<h3>Forces</h3>
<p>
DirectInput supports several standard categories of effects. These types of effects are called forces, and include:
<ul type=disc>
<li>
<b>Constant force.</b> A steady force in a single direction.<br><br></li>
<li>
<b>Ramp force.</b> A force that steadily increases or decreases in magnitude. A ramp force may continue in a single direction, or it may start as a strong push in one direction, weaken, stop, and then strengthen in the opposite direction.<br><br></li>
<li>
<b>Periodic effect.</b> A force that pulsates according to a defined wave pattern, such as:<p class=tl>
<i>Square</i></P><p class=tl>
<i>Sine</i></P><p class=tl>
<i>Cosine</i></P><p class=tl>
<i>Triangle</i></P><p class=tl>
<i>SawtoothUp.</i> The waveform drops vertically after it reaches maximum positive force.</P><p class=tl>
<i>SawtoothDown.</i> The waveform rises vertically after it reaches maximum negative force.</P></li>
<li>
<b>Condition.</b> A force that occurs only in response to input by the user. Two examples are a friction effect that generates resistance to movement of the joystick, and a spring effect that tends to move the stick back to a certain position after it has been moved. DirectInput defines the following types of condition effects:<p class=tl>
<i>Friction.</i> The force is applied when the axis is moved, and depends on the defined friction coefficient.</P><p class=tl>
<i>Damper.</i> The force increases in proportion to the velocity with which the user moves the axis.</P><p class=tl>
<i>Inertia.</i> The force increases in proportion to the acceleration of the axis.</P><p class=tl>
<i>Spring.</i> The force increases in proportion to the distance of the axis from a defined neutral point.</P></li>
<li>
<b>Custom.</b> Application writers can create their own effects by creating a custom force. A custom force is an <i>n</i>-dimensional array of force values played back by the device.<br><br></li>
<li>
<b>Device-specific.</b> DirectInput provides a way to control device-specific effects. This is useful for hardware vendors who have extra effects that are not directly supported by DirectInput.</li>
</ul>
<p>
Table 2 lists the standard forces supported by DirectInput.</p>
<p class=label>
<b>Table 2. DirectInput Standard Forces</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=54%><b>DirectInput Force Types</b></td>
<td width=46%></td>
</tr>
<tr valign=top>
<td width=54%>GUID_ConstantForce</td>
<td width=46%>GUID_SawtoothDown</td>
</tr>
<tr valign=top>
<td width=54%>GUID_RampForce</td>
<td width=46%>GUID_Spring</td>
</tr>
<tr valign=top>
<td width=54%>GUID_Square</td>
<td width=46%>GUID_Damper</td>
</tr>
<tr valign=top>
<td width=54%>GUID_Sine</td>
<td width=46%>GUID_Inertia</td>
</tr>
<tr valign=top>
<td width=54%>GUID_Triangle</td>
<td width=46%>GUID_Friction</td>
</tr>
<tr valign=top>
<td width=54%>GUID_SawtoothUp</td>
<td width=46%>GUID_CustomForce</td>
</tr>
</table><br>
<p>
The strength of the force is called its <i>magnitude</i>. Magnitude is measured in units ranging from zero (no force) to 10,000 (maximum force for the device). A negative value indicates force in the opposite direction. Magnitudes are linear: a force of 10,000 is twice as great as one of 5,000.</p>
<p>
Ramp forces have a beginning and ending magnitude. The basic magnitude of a periodic effect is the force at the peak of the wave.</p>
<p>
The <i>direction</i> of a force is the direction from which it comes; just as a north wind comes from the north, a positive force on a given axis pushes from the positive toward the negative.</p>
<p>
Effects also have <i>duration</i>, measured in microseconds. Periodic effects have a <i>period</i>, or the duration of one cycle, also measured in microseconds. The <i>phase</i> of a periodic effect is the point along the wave where playback begins.</p>
<p>
A sawtooth periodic force is shown in Figure 8.</p>
<p>
<img src="directx508.gif" border=0></p>
<p class=label>
<b>Figure 8. A sawtooth periodic force</b></p>
<p>
A force may be modified by an <i>envelope</i>. An envelope is a "wrapper" that constrains a force within specified ranges over time. For example, an envelope could look similar to Figure 9.</p>
<p>
<img src="directx509.gif" border=0></p>
<p class=label>
<b>Figure 9. A force envelope</b></p>
<p>
An envelope defines an <i>attack value</i> and a <i>fade value</i>, which modify the beginning and ending magnitude of the effect. Attack and fade also have duration that determines how long the magnitude takes to reach or fall away from the <i>sustain value</i>, the magnitude in the middle portion of the effect.</p>
<p>
When the envelope shown in Figure 9 is applied to a sawtooth force, the resulting force would appear as shown in Figure 10.</p>
<p>
<img src="directx510.gif" border=0></p>
<p class=label>
<b>Figure 10. Combining an envelop with a sawtooth periodic force</b></p>
<p>
The force shown in Figure 10 would make a joystick pulsate for a period of time—first with more pronounced pulses that declined in force, stayed constant for a while, then faded down.</p>
<p>
Before an effect can be played, it must be downloaded to the device. Generally this means the driver will put the parameters of the effect in hardware memory. This speeds up the playback of the effect and reduces latency, and is particularly important for actions like trigger responses, such as a "fire" button. Ideally the device will not have to communicate with the system at all in order to respond to axis movements and button presses.</p>
<h2><a name="directx5_immed"></a>Direct3D Immediate Mode</h2>
<p>
Direct3D Immediate Mode is designed to enable world-class game and interactive 3-D graphics on a computer running Windows. Its mission is to provide device-dependent access to 3-D video-display hardware in a device-independent manner. Simply put, Direct3D is a drawing interface for 3-D hardware.</p>
<p>
You can use Direct3D in either of two modes: Immediate Mode or Retained Mode. Microsoft developed the Direct3D Immediate Mode as a low-level 3-D API. Immediate Mode is ideal for developers who need to port games and other high-performance multimedia applications to the Microsoft Windows operating system. Immediate Mode is a device-independent way for applications to communicate with accelerator hardware at a low level.</p>
<p>
Retained Mode is a high-level 3-D application programmer interface (API) for programmers who require rapid development or who want the help of Retained Mode's built-in support for hierarchies and animations. Direct3D Retained Mode is built on top of Immediate Mode.</p>
<p>
Key features of Direct3D Immediate Mode include:
<ul type=disc>
<li>
Switchable z-buffering<br><br></li>
<li>
Flat and Gouraud shading<br><br></li>
<li>
Phong lighting model, with multiple lights and light types<br><br></li>
<li>
Full material and texture support, including mipmapping<br><br></li>
<li>
Ramp and RGB software emulation<br><br></li>
<li>
Transformation and clipping<br><br></li>
<li>
Hardware independence<br><br></li>
<li>
Full support on Microsoft Windows&nbsp;NT®<br><br></li>
<li>
Support for the Intel® MMX architecture</li>
</ul>
<h4>New in DirectX 5.0</h4>
<ul type=disc>
<li>
<b>DrawPrimitive</b>. Direct3D Immediate Mode now supports drawing primitives without having to work directly with execute buffers.<br><br></li>
<li>
<b>Overloads</b>. A set of extensions and helper functions has been implemented for C++ programmers.</li>
</ul>
<p>
The world management of Immediate Mode is based on vertices, polygons, and commands that control them. It allows immediate access to the transformation, lighting, and rasterization 3-D graphics pipeline and provides emulation for missing hardware functionality. (The programmer is always told which capabilities are in hardware and which are being emulated.)</p>
<h3>DrawPrimitive</h3>
<p>
There are two ways to use Immediate Mode: you can use the DrawPrimitive methods introduced in DirectX 5.0 or you can work with execute buffers (display lists) that have always existed in the Immediate Mode.</p>
<p>
Most developers who have never worked with Immediate Mode before will use the DrawPrimitive methods. Developers who already have an investment in code that uses execute buffers will probably continue to work with them.</p>
<h3>What is DrawPrimitive?</h3>
<p>
DrawPrimitive is an easy-to-use API for 3-D drawing. DrawPrimitive draws 3-D triangles, lines, and points—the fundamental primitives of 3-D—into DirectDraw surfaces.</p>
<p>
DrawPrimitive is a simple, compact API—a set of 17 methods that extend the Direct3D device interface. This design simplicity makes DrawPrimitve ideal for a wide range of 3-D–related tasks, from quick prototyping and adding 3-D elements to existing applications to interfacing 3-D engines and toolkits to 3-D hardware.</p>
<p>
DrawPrimitive does not require specific 3-D hardware, but is optimized to deliver maximum performance on both software-only and hardware-accelerated systems. DrawPrimitive is designed to be a foundation interface for 3-D acceleration that is rapidly becoming a standard computing capability.</p>
<p>
DrawPrimitive provides a simple yet extremely powerful set of functions to perform the foundation operations of 3-D drawing. Whether your task is to add a few 3-D elements to an existing application or interface an entire 3-D game engine or tool to 3-D hardware, DrawPrimitive provides the essential primitive-level draw functionality you will need.</p>
<h3>Design Goals</h3>
<p>
DrawPrimitive was designed with three key design goals: ease of use, DirectX compatibility, and scalable performance.</p>
<p>
<b>Ease of use.</b> Ease of use is the key design goal of DrawPrimitive. Ease of use is a critical feature for anyone using a 3-D API:
<ul type=disc>
<li>
<b>New 3-D users.</b> By extending familiar 2-D draw paradigms into 3-D, DrawPrimitive simplifies the introduction of 3-D terms and concepts, lowers the 3-D learning curve, and speeds getting results on screen. Supporting macros and library routines further simplify common activities.<br><br></li>
<li>
<b>Experienced 3-D users.</b> Ease of use is more than a 3-D learning curve issue. For experienced 3-D programmers, a clean, simple API means rapid prototyping, easier debugging and maintenance, and clearer optimization strategies.<br><br></li>
<li>
<b>3-D engine and toolkit builders.</b> DrawPrimitive is a true immediate mode abstraction of a 3-D drawing device. This means that 3-D engines and toolkits (such as 3-D game or binary space partition (BSP) tree engines, scene graph frameworks, or 3-D tools) can use DrawPrimitive to quickly and transparently interface to 3-D hardware without going through an intermediate data structure.<br><br></li>
<li>
<b>Hardware designers.</b> DrawPrimitive defines a foundation interface and clear target for 3-D hardware designers. This speeds time-to-market for 3-D device drivers, freeing resources to focus on performance optimization and feature extensions.</li>
</ul>
<p>
<b>DirectX compatibility.</b> The second design goal for DrawPrimitive is DirectX compatibility. The reason is simple: DirectX is enormously successful, with hundreds of applications using DirectX technologies and millions of DirectX-enabled devices already in use. The DirectX family of performance graphics and media services are quickly become a core, universal PC media playback facility. As an extension of DirectX, DrawPrimitive API continues the DirectX "direct" design and interface philosophy, combining software emulation and hardware abstraction to unify and innovate digital media playback.</p>
<p>
And indeed, users will find DrawPrimitive immediately familiar. Direct3D Immediate Mode users will perceive DrawPrimitive as a natural extension of Direct3D execute buffers, which are in essence user-compiled blocks of DrawPrimitive commands. DirectDraw users will find DrawPrimitive a simple and fast way to draw 3-D primitives into the DirectDraw surfaces they are already using. Device driver writers will find adding a DrawPrimitive extension to existing DirectX drivers to involve only a matter of days or weeks of effort.</p>
<p>
All of this underscores the Microsoft commitment to DirectX as a core technology. DrawPrimitive protects the investment in DirectX technologies by ISVs and IHVs, while at the same time extending the functionality of DirectX over time.</p>
<p>
<b>Scalable performance.</b> The final design goal of DrawPrimitive is scalable performance. This means that DrawPrimitive is designed to deliver to the API user the maximum performance available on the full range of 3-D–capable computing architectures.</p>
<p>
There is no single universal 3-D computing architecture, and innovation in media computing architectures is sure to continue. A foundation 3-D draw API must therefore be scalable from plain software-only systems to various media processing architectures, from simple hardware triangle engines to advanced commodity media architectures like Talisman. This is a major design challenge, and requires hardware abstraction, software emulation, and the capability of the programmer to query and configure for a particular system.</p>
<h3>Core Draw Primitives</h3>
<p>
DrawPrimitive is designed to do one thing very well—draw 3-D primitives. This requires supporting a variety of formats for describing 3-D primitives.</p>
<p>
<b>Triangles.</b> DrawPrimitives supports triangle lists, triangle strips, and triangle fans:</p>
<p>
<img src="directx511.gif" border=0></p>
<p class=label>
<b>Figure 11. Triangles</b></p>
<p>
DrawPrimitive uses triangles to represent both simple and complex surfaces through texture mapping and shading algorithms.</p>
<p>
<b>Lines and points</b>. DrawPrimitive supports line lists, line strips, and point lists:</p>
<p>
<img src="directx512.gif" border=0></p>
<p class=label>
<b>Figure 12. Lines and Points</b></p>
<p>
<b>Indexed primitives.</b> DrawPrimitive can represent primitives in two formats: as a list of vertices, or as a list of vertices plus an index into the list of vertices. For primitives described a list of vertices, the draw engine simply processes the vertices in the order they appear in the vertex list. For indexed primitives, the draw engine processes the vertex list in the order described by the index list.</p>
<h3>DrawPrimitive Architecture</h3>
<p>
The conceptual architecture of DrawPrimitive is straightforward. A core set of functions is used to pass 3-D primitives to a draw engine, which then draws the primitives into a DirectDraw surface. The Draw engine uses a transform formula to calculate how to convert locations in 3-D space into 2-D screen coordinates and uses a set of state variables that specify the stylistic characteristics of the draw operation.</p>
<p>
The DrawPrimitive architecture is summarized in Figure 13.</p>
<p>
<img src="directx513.gif" border=0></p>
<p class=label>
<b>Figure 13. The DrawPrimitive architecture</b></p>
<p>
The 3 components of the Direct3D device are:</p>
<p>
<b>Transform.</b> The transform is a set of formulas that describe how to convert a vertex's position in 3-D space into 2-D screen coordinates. The transform is actually made up of 3 matrix formulas, the world, view and projection matrix. The Transform matrices are configured with the <b>SetTransform</b> or <b>MultiplyTransform</b> methods or with helper macros.</p>
<p>
<b>State variables.</b> State variables describe the current style settings for drawing operations.</p>
<p>
<b>Draw engine.</b> The draw engine performs 3 separate functions: transformation, lighting, and rasterization. The API user can choose which of these functions the draw engine should perform by describing the vertex data in a particular vertex format. <b>D3DVertex</b> describes a vertex for the draw engine to transform, light and rasterize. <b>D3DLVertex</b> describes a vertex for which the calling application has already determined the color (a "lit" vertex). <b>D3DTLVertex</b> is used by the calling application to describe an already transformed and lit vertex, and the draw engine only needs to draw the primitive.</p>
<h2><a name="directx5_retain"></a>Direct3D Retained Mode</h2>
<p>
Direct3D Retained Mode is a high-level 3-D scene graph manager that simplifies the building and animation of 3-D worlds and data.</p>
<h4>New in DirectX 5.0</h4>
<ul type=disc>
<li>
<b>Animation interpolators.</b> Direct3D Retained Mode now support interpolators that enable you to blend colors, move objects smoothly between positions, morph meshes, and perform many other transformations.<br><br></li>
<li>
<b>Progressive meshes.</b> Retained Mode also supports progressive meshes that allow you to begin with a coarse mesh and increasingly refine it; this can help you take the level of detail into account and can help with progressive downloads from remote locations.</li>
</ul>
<p>
All access to Direct3D Retained Mode is through a small set of objects. Table 3 lists these objects and a brief description of each:</p>
<p class=label>
<b>Table 3. Direct3D Retained Mode Objects</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=32%><b>Object</b></td>
<td class=label width=68%><b>Description </b></td>
</tr>
<tr valign=top>
<td width=32%>Direct3DRMAnimation</td>
<td width=68%>Defines how a transformation will be modified, often in reference to a Direct3DRMFrame or Direct3DRMFrame2 object. You use it to animate position, orientation, and scaling of Direct3DRMVisual, Direct3DRMLight, and Direct3DRMViewport objects.</td>
</tr>
<tr valign=top>
<td width=32%>Direct3DRMAnimationSet</td>
<td width=68%>Allows Direct3DRMAnimation objects to be grouped together.</td>
</tr>
<tr valign=top>
<td width=32%>Direct3DRMDevice</td>
<td width=68%>Represents the visual display destination for the renderer.</td>
</tr>
<tr valign=top>
<td width=32%>Direct3DRMDevice2</td>
<td width=68%>Same as the Direct3DRMDevice object but with enhanced control of transparency.</td>
</tr>
<tr valign=top>
<td width=32%>Direct3DRMFace</td>
<td width=68%>Represents a single polygon in a mesh.</td>
</tr>
<tr valign=top>
<td width=32%>Direct3DRMFrame</td>
<td width=68%>Positions objects within a scene and defines the positions and orientations of visual objects.</td>
</tr>
<tr valign=top>
<td width=32%>Direct3DRMFrame2</td>
<td width=68%>Extends the Direct3DRMFrame object by enabling access to the frame axes, bounding boxes, and materials. Also supports ray picking.</td>
</tr>
<tr valign=top>
<td width=32%>Direct3DRMInterpolator</td>
<td width=68%>Stores actions and applies the actions to objects with automatic calculation of in-between values.</td>
</tr>
<tr valign=top>
<td width=32%>Direct3DRMLight</td>
<td width=68%>Defines one of five types of lights that are used to illuminate the visual objects in a scene.</td>
</tr>
<tr valign=top>
<td width=32%>Direct3DRMMaterial</td>
<td width=68%>Defines how a surface reflects light.</td>
</tr>
<tr valign=top>
<td width=32%>Direct3DRMMesh</td>
<td width=68%>A set of polygonal faces. You can use this object to manipulate groups of faces and vertices.</td>
</tr>
<tr valign=top>
<td width=32%>Direct3DRMMeshBuilder</td>
<td width=68%>Allows you to work with individual vertices and faces in a mesh.</td>
</tr>
<tr valign=top>
<td width=32%>Direct3DRMMeshBuilder2</td>
<td width=68%>Allows you to work with individual vertices and faces in a mesh. Same as the Direct3DRMMeshBuilder object but with than the Direct3DRMMeshBuilder object.</td>
</tr>
<tr valign=top>
<td width=32%>Direct3DRMObject</td>
<td width=68%>A base class used by all other Direct3D Retained-Mode objects; it has characteristics that are common to all objects.</td>
</tr>
<tr valign=top>
<td width=32%>Direct3DRMPickedArray</td>
<td width=68%>Identifies a visual object that corresponds to a given 2-D point.</td>
</tr>
<tr valign=top>
<td width=32%>Direct3DRMPicked2Array</td>
<td width=68%>Identifies a visual object corresponding to a given ray intersection.</td>
</tr>
<tr valign=top>
<td width=32%>Direct3DRMProgressiveMesh</td>
<td width=68%>A coarse base mesh together with records describing how to incrementally refine the mesh. This allows a generalized level of detail to be set on the mesh as well as progressive download of the mesh from a remote source.</td>
</tr>
<tr valign=top>
<td width=32%>Direct3DRMShadow</td>
<td width=68%>Defines a shadow.</td>
</tr>
<tr valign=top>
<td width=32%>Direct3DRMTexture</td>
<td width=68%>A rectangular array of colored pixels.</td>
</tr>
<tr valign=top>
<td width=32%>Direct3DRMTexture2</td>
<td width=68%>Same as the Direct3DRMTexture object except that resources can be loaded from files other than the currently executing file, textures can be created from images in memory, and you can generate MIP maps.</td>
</tr>
<tr valign=top>
<td width=32%>Direct3DRMUserVisual</td>
<td width=68%>This object is defined by an application to provide functionality not otherwise available in the system.</td>
</tr>
<tr valign=top>
<td width=32%>Direct3DRMViewport</td>
<td width=68%>Defines how the 3-D scene is rendered into a 2-D window.</td>
</tr>
<tr valign=top>
<td width=32%>Direct3DRMVisual</td>
<td width=68%>Anything that can be rendered in a scene. Visual objects need not be visible; for example, a frame can be added as a visual.</td>
</tr>
<tr valign=top>
<td width=32%>Direct3DRMWrap</td>
<td width=68%>Calculates texture coordinates for a face or mesh.</td>
</tr>
</table><br>
<h3>Animation Interpolators</h3>
<p>
An animation in Retained Mode is defined by a set of keys. A key is a time value associated with a scaling operation, an orientation, or a position. A Direct3DRMAnimation object defines how a transformation is modified according to the time value. The animation can be set to operate on a Direct3DRMFrame object, so it could be used to animate the position, orientation, and scaling of Direct3DRMVisual, Direct3DRMLight, and Direct3DRMViewport objects.</p>
<p>
The <b>IDirect3DRMAnimation::AddPositionKey</b>, <b>IDirect3DRMAnimation::AddRotateKey</b>, and <b>IDirect3DRMAnimation::AddScaleKey </b>methods each specify a time value whose units are arbitrary. If an application adds a position key with a time value of 99, for example, a new position key with a time value of 49 would occur exactly halfway between the (zero-based) beginning of the animation and the first position key.</p>
<p>
Calling the <b>IDirect3DRMAnimation::SetTime </b>method drives the animation. This sets the visual object's transformation to the interpolated position, orientation, and scale of the nearby keys in the animation. As with the methods that add animation keys, the time value for <b>IDirect3DRMAnimation::SetTime </b>is an arbitrary value, based on the positions of keys the application has already added.</p>
<p>
A Direct3DRMAnimationSet object allows Direct3DRMAnimation objects to be grouped together. This allows all the animations in an animation set to share the same time parameter, simplifying the playback of complex articulated animation sequences. An application can add an animation to an animation set by using the <b>IDirect3DRMAnimationSet::AddAnimation </b>method, and it can remove one by using the <b>IDirect3DRMAnimationSet::DeleteAnimation </b>method. Calling the <b>IDirect3DRMAnimationSet::SetTime </b>method drives animation sets.</p>
<h3>Progressive Meshes</h3>
<p>
A mesh is a visual object that is made up of a set of polygonal faces. A mesh defines a set of vertices and a set of faces.</p>
<p>
A progressive mesh is a mesh that is stored as a base mesh (a coarse version) and a set of records that are used to increasingly refine the mesh. This allows you to set the level of detail rendered for a mesh and also allows progressive download from remote sources.</p>
<p>
Using the methods of the <b>IDirect3DRMProgressiveMesh</b> interface, you can set the number of vertices or faces to render and thereby control the render detail. You can also specify a minimum level of detail required for rendering. Normally, a progressive mesh is rendered once the base mesh is available, but with the <b>IDirect3DRMProgressiveMesh::SetMinRenderDetail</b> method you can specify that a greater level of detail is necessary before rendering. You can also build a Direct3DRMMesh object from a particular state of the progressive mesh using the <b>IDirect3DRMProgressiveMesh::CreateMesh</b> method.</p>
<p>
You can load a progressive mesh from a file, resource, memory, or Universal Resource Locator (URL). Loading can be done synchronously or asynchronously. You can check the status of a download with the <b>IDirect3DRMProgressiveMesh::GetLoadStatus</b> method, and terminate a download with the <b>IDirect3DRMProgressiveMesh::Abort</b> method. If loading is asynchronous, it is up to the application to use events through the <b>IDirect3DRMProgressiveMesh::RegisterEvents</b> and <b>IDirect3DRMProgressiveMesh::GetLoadStatus</b> methods to find out how the load is progressing.</p>
<h2><a name="directx5_play"></a>DirectPlay</h2>
<p>
DirectPlay makes it easy to connect games over the Internet, a modem link, or a network.</p>
<p>
DirectPlay is a software interface that simplifies application access to communication services. DirectPlay has become a technology family that not only provides a way for applications to communicate with each other, independent of the underlying transport, protocol, or online service, but also provides this independence for matchmaking servers, game servers, and billing.</p>
<p>
Applications (especially games) can be more compelling if they can be played against real players, and the personal computer has richer connectivity options than any game platform in history. Instead of forcing the developer to deal with the differences that each connectivity solution represents, DirectPlay provides well-defined, generalized communication capabilities. DirectPlay shields developers from the underlying complexities of diverse connectivity implementations, freeing them to concentrate on producing a great application.</p>
<p>
DirectPlay 5.0 has a new interface, <b>IDirectPlay3</b>. This interface inherits directly from <b>IDirectPlay2</b> and by default behaves as <b>IDirectPlay2</b>. All new functionality is enabled through new methods or new flags.</p>
<p>
DirectPlay 5.0 includes numerous new features and improvements:
<ul type=disc>
<li>
<b>Connection shortcuts</b><p class=tl>
<b>IDirectPlay3::EnumConnections </b>enumerates the connection shortcuts available to the application. This method supersedes <b>DirectPlayEnumerate</b>.</P></li>
<li>
<b>New initialization method</b><p class=tl>
<b>IDirectPlay3::InitializeConnection </b>initializes a DirectPlay connection. This method supersedes <b>DirectPlayCreate</b>. The new <b>IDirectPlayLobby2::CreateCompoundAddress </b>method creates connection shortcuts to pass to the <b>InitializeConnection</b> method.</P></li>
<li>
<b>Improved security</b><p class=tl>
<b>IDirectPlay3::SecureOpen </b>creates or joins a session on a machine that uses Windows NT LAN Manager (NTLM) security.</P></li>
<li>
<b>Groups in groups</b><p class=tl>
<b>IDirectPlay3::CreateGroupInGroup</b>, <b>IDirectPlay3::AddGroupToGroup</b>, <b>IDirectPlay3::DeleteGroupFromGroup</b>, and <b>IDirectPlay3::EnumGroupsInGroup </b>add richer group functionality and navigation when connected to a lobby server.</P></li>
<li>
<b>Chat</b><p class=tl>
<b>IDirectPlay3::SendChatMessage </b>enables players to chat with other players connected to a lobby server.</P></li>
<li>
<b>Synchronized application launching</b><p class=tl>
<b>IDirectPlay3::SetGroupConnectionSettings</b>, <b>IDirectPlay3::GetGroupConnectionSettings</b>, and <b>IDirectPlay3::StartSession </b>enable synchronized application launching from a lobby server.</P></li>
<li>
<b>Improved password protection</b><p class=tl>
Password protection of sessions has been greatly improved. The new DPCREDENTIALS structure holds the user name and password to use when connecting to a secure server. The DPSECURITYDESC structure describes the security properties of a DirectPlay session instance.</P></li>
<li>
<b>Multiple DirectPlay objects</b><p class=tl>
An application can create multiple DirectPlay objects.</P></li>
<li>
<b>Guaranteed messaging</b><p class=tl>
Guaranteed messaging is available for all service providers.</P></li>
<li>
<b>Multicast server</b><p class=tl>
A new multicast server improves group messaging.</P></li>
<li>
<b>Scalable client/server architecture applications</b><p class=tl>
Support has been added for highly scalable client/server architecture applications.</P></li>
</ul>
<h3>How DirectPlay Works</h3>
<p>
The DirectPlay API is a network abstraction that applications can be written to. The API defines the functionality of the abstract DirectPlay network and all the functionality is available to your application regardless of whether the actual underlying network supports it or not. In cases where the underlying network does not support a function, DirectPlay contains all the code necessary to emulate it. Examples include group messaging and guaranteed messaging.</p>
<p>
The service provider architecture in DirectPlay insulates the application from the underlying network it is running on. The application can query DirectPlay for specific capabilities of the underlying network, such as latency and bandwidth, and adjust its communications accordingly.</p>
<p>
<img src="directx514.gif" border=0></p>
<p class=label>
<b>Figure 14. The DirectPlay architecture</b></p>
<h3>Session Management</h3>
<p>
A DirectPlay session is a communications channel between several machines. Before an application can start communicating with other machines it must join a session. An application can do this in one of two ways: it can enumerate all the existing sessions on a network and join one of them, or it can create a new session and wait for other machines to join it. Once the application has joined a session, it can create a player and exchange messages with all the other players in the session.</p>
<p>
Each session has one machine that is designated as the host. The host is the owner of the session and is the only machine that can change the properties of the session.</p>
<p>
The following diagram illustrates the DirectPlay session model: An application must join a session to communicate with other machines using DirectPlay.</p>
<p>
<img src="directx515.gif" border=0></p>
<p class=label>
<b>Figure 15. The DirectPlay session model</b></p>
<h3>Players and Groups</h3>
<p>
The most basic entity within a DirectPlay session is a player. A player represents a logical object within the session that can send and receive messages. DirectPlay does not have any representation of a physical machine in the session. Each player is identified as being either a local player (one that exists on your machine) or a remote player (one that exists on another machine). Each machine must have at least one local player before it can start sending and receiving messages. Individual machines can have more than one local player but within the context of a DirectPlay session they are considered to be distinct entities.</p>
<p>
When an application sends a message, it is always directed to another player—not another machine. The player can be another local player (in which case the message will not go out over the network) or a remote player. Similarly, when messages are received by an application they are always addressed to a specific (local) player and marked as being from some other player (except system messages which are always marked as being from DPID_SYSMSG).</p>
<p>
<img src="directx516.gif" border=0></p>
<p class=label>
<b>Figure 16. Player and group structure</b></p>
<p>
DirectPlay supports the concepts of groups within a session. A group is logical collection of players. By creating a group of players, an application can send a single message to the group and all the players in the group will receive a copy of the message. A group is the means by which multicast capabilities of the network are exposed to the application.</p>
<p>
Groups can also be used as a general means to organize players in a session. A player can belong to more than one group. Functions are provided for administering groups and their membership. Additional functions are also provided to associate names and data with individual groups as a convenience but are not necessary to use groups.</p>
<h2><a name="directx5_set"></a>DirectSetup</h2>
<p>
DirectSetup is a simple API that provides you with a one-call installation for the DirectX components. This is more than merely a convenience; DirectX is a complex product, and its installation is an involved task. You should not attempt to manually install DirectX.</p>
<p>
In addition, DirectSetup provides an automated way to install the appropriate Microsoft Windows registry information for applications that use the DirectPlayLobby object. This registry information is required for the DirectPlayLobby object to enumerate and start the application.</p>
<h4>New in DirectX 5.0</h4>
<p>
<b>User interface customization.</b> DirectSetup now supports a callback function that provides notification of various types of events that occur during the setup of DirectX. This allows developers to customize the setup interface.</p>
<p>
<b>Unregister.</b> Also new in this version of DirectSetup is the ability of DirectPlayLobby applications to remove registration information.</p>
<h3>Why You Need DirectSetup</h3>
<p>
Applications and games that depend on DirectX use the <b>DirectXSetup</b> function to install their system components into an existing Windows installation. It optionally updates the display and audio drivers to support DirectX during the DirectX installation process. This process is designed to happen smoothly, without adversely affecting the user's system. Older drivers are upgraded whenever possible to prevent reduced performance or stability of all DirectX-based applications on a computer.</p>
<p>
Note that the DirectXSetup function overwrites system components from previous versions of DirectX. For example, if you install DirectX 5.0 on a system that already has DirectX version 3.0 components, all DirectX 3.0 components will be overwritten. Because all DirectX components comply with COM backward-compatibility rules, software written for DirectX 3.0 will continue to function properly.</p>
<p>
The DirectX SDK contains the \Redist directory. Setup programs that use the DirectXSetup function must distribute the entire contents of the Redist directory, not just the contents of the \Redist\Directx directory. They must also include Dsetup.dll, Dsetup16.dll, and Dsetup32.dll.</p>
<p>
As with previous versions of DirectX, version 5.0 requires the installation of all components. Current DirectX components are tightly integrated together for maximum performance. Hence, they all need to be installed for any one of them to work.</p>
<h3>The Default Setup Process with DirectXSetup</h3>
<p>
The <b>DirectXSetup</b> function can tell when DirectX components, display drivers, and audio drivers need to be upgraded. It can also distinguish whether or not these components can be upgraded without adversely affecting the Windows operating system. This is said to be a "safe" upgrade. It is important to note that the upgrade is safe for the operating system, not necessarily for the applications running on the computer. Some hardware-dependent applications can be negatively affected by an upgrade that is safe for Windows.</p>
<p>
The <b>DirectXSetup</b> function makes two passes through all of the installed drivers. The first pass is a dry run, during which the <b>DirectXSetup</b> function will not perform any upgrades. The second pass is the action run, during which the <b>DirectXSetup</b> function actually installs the drivers.</p>
<p>
During this two-step process, <b>DirectXSetup</b> creates a backup copy of the system components and drivers that are replaced. These can typically be restored in the event of an error.</p>
<p>
When display or audio drivers are upgraded, the <b>DirectXSetup</b> function utilizes a database created by Microsoft to manage the process. The database contains information on existing drivers that are provided either by Microsoft, the manufacturers of the hardware, or the vendors of the hardware. This database describes the upgrade status of each driver, based on testing done at Microsoft and at other sites.</p>
<h2><a name="directx5_formor"></a>For More Information</h2>
<p>
For additional information on DirectX, please refer to the Microsoft DirectX Web site (<a href="http://www.microsoft.com/directx">http://www.microsoft.com/directx</a>).</p>
<p>
<i>The information contained in this document represents the current view of Microsoft Corporation on the issues discussed as of the date of publication. Because Microsoft must respond to changing market conditions, it should not be interpreted to be a commitment on the part of Microsoft, and Microsoft cannot guarantee the accuracy of any information presented after the date of publication.</i></p>
<p>
<i>This document is for informational purposes only. MICROSOFT MAKES NO WARRANTIES, EXPRESS OR IMPLIED, IN THIS DOCUMENT.</i></p>
</BODY>
</HTML>
