<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Real-Time Systems with Microsoft Windows CE</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_rtdraft6"></a>Real-Time Systems with Microsoft Windows CE</h1>
<p>
John Murray</p>
<p>
September 1997</p>
<h2>Introduction</h2>
<p>
High-performance embedded applications must often manage time-critical responses. Examples include manufacturing process controls, high-speed data acquisition devices, telecommunications switching equipment, medical monitoring equipment, aircraft "fly-by-wire" controls, and weapons delivery, space navigation and guidance, laboratory experiment control, automobile engine control, and robotics systems.</p>
<p>
Validating such an application means examining not only its computational accuracy but also the timeliness of its results. The application must deliver its responses within specified time parameters—in real time.</p>
<p>
A real-time system is loosely defined as "any system where a timely response by the computer to external stimuli is vital," in <i>Real Time Systems</i> by C.M. Krishna and Kang G. Shin (McGraw Hill, 1996). The standard definition provided in the Internet newsgroup comp.realtime states: "A real-time system is one in which the correctness of the computations not only depends upon the logical correctness of the computation but also upon the time at which the result is produced. If the timing constraints of the system are not met, system failure is said to have occurred."<sup> </sup>in the comp.realtime "Frequently Asked Questions" by Mark Linimon and Jean-Christophe Monfret.</p>
<p>
It is important to distinguish between a real-time system and a real-time operating system (RTOS). The real-time system represents the set of all system elements—the hardware, operating system, and applications—that are needed to meet the system requirements. The RTOS is just one element of the complete real-time system and must provide sufficient functionality to enable the overall real-time system to meet its requirements.</p>
<p>
It is also important to distinguish between a fast operating system and an RTOS. Speed, although useful for meeting the overall requirements, does not by itself meet the requirements for an RTOS. The Internet newsgroup comp.realtime lists some requirements that an operating system must meet to be considered an RTOS:
<ul type=disc>
<li>
The operating system must be multithreaded and preemptive.<br><br></li>
<li>
The operating system must support thread priority.<br><br></li>
<li>
A system of priority inheritance must exist.<br><br></li>
<li>
The operating system must support predictable thread synchronization mechanisms.</li>
</ul>
<p>
In addition, the operating system behavior must be predictable. This means real-time system developers must have detailed information about the system interrupt levels, system calls, and timing:
<ul type=disc>
<li>
The maximum time during which interrupts are masked by the operating system and by device drivers must be known.<br><br></li>
<li>
The maximum time that device drivers use to process an interrupt, and specific interrupt request (IRQ) information relating to those device drivers, must be known.<br><br></li>
<li>
The interrupt latency (the time from interrupt to task run) must be predictable and compatible with application requirements.<br><br></li>
<li>
The time for every system call should be predictable and independent of the number of objects in the system.</li>
</ul>
<p>
This article describes how Microsoft® Windows® CE meets each of these requirements for a real-time operating system. Most significantly, Windows CE guarantees an upper bound on the time it takes to start a real-time priority thread after receiving an interrupt. This article describes the interrupt latency times for a specific reference platform, the "Odo" platform with the Hitachi SH3 microprocessor.</p>
<h2>Microsoft Windows CE</h2>
<h3>Overview</h3>
<p>
Microsoft Windows CE is designed as a general-purpose operating system for small form-factor devices that are typically diskless systems with a limited memory capacity. Windows CE is adapted for a specific hardware platform by creating a thin layer of code that resides between the kernel and the hardware. This is known as the Hardware Abstraction Layer (HAL). (In previous releases, this interface was called the <i>OEM Adaptation Layer</i>, or<i> </i>OAL, and the Kernel Abstraction Layer, or KAL, to avoid confusion with the Windows NT® HAL.)</p>
<p>
Unlike other Windows operating systems, Windows CE does not represent one standard, identical piece of software that is common to all platforms. To be flexible enough to meet the needs of a wide range of products, Windows CE is <i>modular</i>. This means that it can be custom-built for a product by selecting from a provided set of software modules. In addition, some of the available modules are <i>componentized</i>. This means these modules can be custom-built by selecting from a set of available components. By selecting the minimum set of required modules and components that meet the system requirements, the OEM can minimize the memory footprint and performance of the operating system.</p>
<p>
The Microsoft Windows CE Embedded Toolkit for Visual C++® 5.0 provides the system libraries, tools, documentation, and sample code to enable OEMs to customize Windows CE for their specific hardware platforms. For more information about the toolkit, see the Microsoft Windows CE Web site (<a href="http://www.microsoft.com/windowsce/developer/prodinfo/vcceembed.htm">http://www.microsoft.com/windowsce/developer/prodinfo/vcceembed.htm</a>). The toolkit will also be available to Universal Subscribers of the MSDN Library. The embedded toolkit also includes the Device Driver Kit (DDK) and the Software Development Kit (SDK). The DDK provides additional documentation about writing device drivers. The SDK provides libraries, header files, sample code, and documentation that allows developers to write applications for Windows CE platforms. Windows CE offers subsets of the same programming interfaces used to develop applications for other Windows operating systems. For example, Windows CE version 1.01 supported about 500 of the 1000 Microsoft Win32® application programming interface (API) functions. This means that a wide variety of tools, third-party books, and training courses for Win32 developers are already in place and available for Windows CE system developers.</p>
<p>
Real-time systems developers can use the Windows CE Embedded Toolkit for Visual C++ 5.0 to port the operating system to their specific platform, and to develop additional device drivers and real-time applications for that platform.</p>
<h3>Threads and Thread Priority</h3>
<p>
Windows CE is a preemptive multitasking operating system. It allows multiple applications, or processes, to run within the system at the same time. Windows CE supports a maximum of 32 simultaneous processes. A process consists of one or more threads, where each thread represents an independent portion of that process. One thread is designated as the primary thread for the process; the process can also create an unspecified number of additional threads. The actual number of additional threads is limited only by available system resources.</p>
<p>
Windows CE uses a priority-based time-slice algorithm to schedule the execution of threads. Windows CE supports eight discrete priority levels, from 0 through 7, where 0 represents the highest priority. These are defined in the header file Winbase.h.</p>
<p class=label>
<b>Table 1. Thread priority levels</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=28%><b>Priority level </b></td>
<td class=label width=72%><b>Constant and description</b></td>
</tr>
<tr valign=top>
<td width=28%>0 (highest priority)</td>
<td width=72%>THREAD_PRIORITY_TIME_CRITICAL (highest priority)</td>
</tr>
<tr valign=top>
<td width=28%>1</td>
<td width=72%>THREAD_PRIORITY_HIGHEST</td>
</tr>
<tr valign=top>
<td width=28%>2</td>
<td width=72%>THREAD_PRIORITY_ABOVE_NORMAL</td>
</tr>
<tr valign=top>
<td width=28%>3</td>
<td width=72%>THREAD_PRIORITY_NORMAL</td>
</tr>
<tr valign=top>
<td width=28%>4</td>
<td width=72%>THREAD_PRIORITY_BELOW_NORMAL</td>
</tr>
<tr valign=top>
<td width=28%>5</td>
<td width=72%>THREAD_PRIORITY_LOWEST</td>
</tr>
<tr valign=top>
<td width=28%>6</td>
<td width=72%>THREAD_PRIORITY_ABOVE_IDLE</td>
</tr>
<tr valign=top>
<td width=28%>7 (lowest priority)</td>
<td width=72%>THREAD_PRIORITY_IDLE (lowest priority)</td>
</tr>
</table><br>
<p>
Levels 0 and 1 are typically used for real-time processing and device drivers; levels 2–4 for kernel threads and normal applications; and levels 5–7 for applications that can always be preempted by other applications. Note that level 6 is present, and has a constant associated with it.</p>
<p>
Preemption is based solely on the thread's priority. Threads with a higher priority are scheduled to run first. Threads at the same priority level run in a round-robin fashion with each thread receiving a <i>quantum</i>, or slice of execution time. The quantum has a default value of 25 milliseconds (Windows CE version 2.0 supports changes to the quantum value on MIPS platforms). Threads at a lower priority do not run until all threads with a higher priority have finished, that is, until they either yield or are blocked. An important exception is that threads at the highest priority level (level 0, THREAD_PRIORITY_TIME_CRITICAL) do not share the time slice with other threads at the highest priority level. These threads continue executing until they have finished.</p>
<p>
Unlike other Microsoft Windows operating systems, the Windows CE thread priorities are fixed and do not change. Windows CE does not age priorities and does not mask interrupts based on these levels. They can be temporarily modified, but only by the Windows CE kernel, and only to avoid what is known as "priority inversion."</p>
<p>
<i>Priority inversion</i> refers to a situation where the use of a resource by a low-priority thread delays the execution of a high-priority thread, when both are contending for the same resources. To correct this situation and free the higher-priority thread, Windows CE allows the lower-priority thread to inherit the more critical thread's priority and run at the higher priority until it releases its use of the resource.</p>
<p>
For example, if a thread running at the highest priority attempts to acquire a mutex that is held by a lower priority thread, the lower priority thread is inverted to the higher priority and run until it releases the mutex. The priority inversion algorithm applies to all threads in the system—for example, even kernel threads running at priority 1 can be inverted to level 0 should a priority 0 thread run demand-paged code and cause a blocking fault.</p>
<p>
The priority-based preemptive multitasking design of the scheduler ensures that a thread running at the highest priority can be guaranteed to execute within a known period of time. This paper will later discuss specific latency figures for the Windows CE reference platform and the formulas to derive these figures for other platforms. Tools in the OEM Adaptation Kit (OAK) and SDK display the thread's state and priority level, and profile the performance of a given real-time system.</p>
<h3>Thread Synchronization</h3>
<p>
Real-time systems must ensure that processes and threads are synchronized. For example, if one part of the real-time application completes before a second part gets the most current data, the process that the application is monitoring may become unstable. Synchronization ensures that interaction between the application threads occurs correctly.</p>
<p>
Like other Windows operating systems, Windows CE offers a rich set of "wait objects" for thread synchronization. These include critical section, event, and mutex objects. These wait objects allow a thread to block its own execution and wait until the specified object changes.</p>
<p>
Windows CE queues mutex, critical section, and event requests in "FIFO-by-priority" order: a different first-in, first-out (FIFO) queue is defined for each of the eight discrete priority levels. A new request from a thread at a given priority is placed at the end of that priority's list. The scheduler adjusts these queues when priority inversions occur.</p>
<p>
In addition to wait objects, Windows CE supports standard Win32 timer API functions. These use software interrupts from the kernel to obtain time intervals for use in managing real-time applications. Threads can use the system's interval timer by calling <b>GetTickCount</b>, which returns a count of milliseconds. For more detailed timing information, the Windows CE kernel also supports the Win32 API functions <b>QueryPerformanceCounter</b> and <b>QueryPerformanceFrequency</b>. The OEM must provide the hardware and software support for these calls with a higher-resolution timer and OAL interfaces to the timer.</p>
<h4>Other considerations</h4>
<p>
Windows CE provides a virtual memory system. For example, while some current hardware platforms running Windows CE offer 4 megabytes (MB) of physical RAM, Windows CE supports a virtual address space of 2 gigabytes (GB), with each process accessing its own 32 MB of virtual address space. Paging a thread's code or data into physical memory as it is needed generates paging interrupts that can affect the amount of thread execution time.</p>
<p>
Paging input/output (I/O) occurs at a lower priority level than the real-time priority process levels. Paging within the real-time process is still free to occur, but this ensures that background virtual memory management won't interfere with processing at real-time priorities.</p>
<p>
Real-time threads should be locked into memory to prevent these nondeterministic paging delays that can result from using the virtual memory management system.</p>
<p>
Windows CE allows memory mapping which permits multiple processes to share the same physical memory. This results in very fast data transfers between cooperating processes or between a driver and an application. Memory mapping can be used to dramatically enhance real-time performance.</p>
<h3>Interrupt Handling: IRQs, ISRs, and ISTs</h3>
<p>
Real-time applications are designed to respond to external events within a specified time interval. Real-time applications use interrupts as a way of ensuring that external events are quickly noticed by the operating system.</p>
<p>
Within Windows CE, the kernel and the OAL are tuned to optimize interrupt delivery and event dispatching to the rest of the system. Windows CE balances performance and ease of implementation by splitting interrupt processing into two steps: an interrupt service routine (ISR) and an interrupt service thread (IST).</p>
<p>
Each hardware interrupt request line (IRQ) is associated with one ISR. When interrupts are enabled and an interrupt occurs, the kernel calls the registered ISR for that interrupt. The ISR, the kernel-mode portion of interrupt processing, is kept as short as possible. Its responsibility is primarily to direct the kernel to launch the appropriate IST.</p>
<p>
The ISR performs its minimal processing and returns an interrupt ID to the kernel. The kernel examines the returned interrupt ID and sets the associated event. The interrupt service thread is waiting on that event. When the kernel sets the event, the IST stops waiting and starts performing its additional interrupt processing. Most of the interrupt handling actually occurs within the IST. The two highest thread priority levels (levels 0 and 1) are usually assigned to ISTs, ensuring that these threads run as quickly as possible.</p>
<p>
As noted previously, ISTs at the highest priority level are not preempted by any other threads. These threads continue execution until they either yield or are blocked.</p>
<p>
Windows CE does not support nested interrupts. This means that an interrupt can not be serviced while a previous interrupt is being processed. That is, if an interrupt is raised while the kernel is within an ISR, execution continues to the end of that ISR before starting the ISR for the new IRQ. This can introduce latencies, or delays between the time of the hardware interrupt and the start of the ISR.</p>
<h3>Interrupt Latency</h3>
<p>
In this paper, the term <i>interrupt latency</i> refers primarily to the software interrupt handling latencies; that is, the amount of time that elapses from the time that an external interrupt arrives at the processor until the time that the interrupt processing begins.</p>
<p>
Windows CE interrupt latency times are bounded for threads locked in memory (when paging does not occur). This makes it possible to calculate the worst-case latencies—the total times to the start of the ISR and to the start of the IST. The total amount of time until the interrupt is handled can then be determined by calculating the amount of time needed within the ISR and IST.</p>
<p>
The general formula for ISR latency is defined as follows:</p>
<p>
<b>start of ISR</b> <b>= value1 + </b><i>dISR_Current</i> <b>+ sum(</b><i>dISR_Higher</i><b>)</b></p>
<p class=indent>
<b>value1</b> = The latency value due to processing within the kernel.</p>
<p class=indent>
<i>dISR_Current</i> = The duration of an ISR in progress at the time the interrupt arrives. This value can range from 0 to the duration of longest ISR in the system.</p>
<p class=indent>
<b>sum(</b><i>dISR_Higher</i>) = The sum of the duration of all higher-priority ISRs that arrive before this ISR starts; that is, interrupts that arrive during the time <b>value1 + </b><i>dISR_Current</i>.</p>
<p>
For example, consider a simple embedded system with a critical-priority ISR. Because the ISR is set to the highest priority, there are no higher priority ISRs, and the value <i>dISR_Higher</i> resolves to 0. The lowest latency, when no other ISRs are in progress, is <b>value1</b>. The highest latency is <b>value1</b> + the duration of the longest ISR in the system, when the interrupt arrives just as the longest ISR in the system is just starting.</p>
<p>
The general formula for IST latency is defined as follows:</p>
<p>
<b>start of IST = value2 + sum(</b><i>dIST</i><b>) + sum(</b><i>dISR</i><b>)</b></p>
<p class=indent>
<b>value2</b> = The latency value due to processing within the kernel.</p>
<p class=indent>
<b>sum(</b><i>dIST</i><b>)</b> = The sum of the duration of all higher priority ISTs and thread context switch times that occur between this ISR and its start of IST.</p>
<p class=indent>
<b>sum(</b><i>dISR</i><b>)</b> = The sum of the duration of all other ISRs that run between this interrupt's ISR and its IST.</p>
<p>
For the simplest case—the embedded system with one critical-priority ISR and just one critical-priority thread (and no other priority 0 threads)—no other ISTs can intervene between the ISR and its IST. However, it is possible that other ISRs can be processed between the time-critical ISR and the start of its associated IST.</p>
<p>
Because ISRs are processed as soon as they are available, it is possible to imagine pathological cases that involve generating a constant stream of ISRs, indefinitely postponing the start of the IST. This is unlikely to occur because the OEM has complete control over the number of interrupts present in the system. Because the OEM is creating a custom version of Windows CE for a specific operating environment, the OEM can take advantage of constraints within that target operating environment to optimize the system design.</p>
<p>
To minimize latency times, the OEM can control the processing times of the ISR and IST, interrupt priorities, and thread priorities. The <b>value1</b> and <b>value2</b> elements in the formulas represent processing times within the Windows CE kernel that the OEM cannot control.</p>
<p>
The current work on timing studies involves identifying the values for these numbers.</p>
<h3>Validating the Real-Time Performance of Windows CE</h3>
<p>
Two different approaches are being used to validate Windows CE performance:
<ul type=disc>
<li>
In-house inspection and analysis of the kernel code by the Windows CE development team<br><br></li>
<li>
OEM and independent software vendors (ISV) timing validation of specific configurations using tools that will be provided in future versions of the Windows CE Embedded Toolkit for Visual C++.</li>
</ul>
<p>
The Windows CE Embedded Toolkit for Visual C++ 5.0 will include the following tools:
<ul type=disc>
<li>
An instrumented version of the kernel for timing studies<br><br></li>
<li>
The Intrtime.exe utility for observing minimum, maximum, and average time to interrupt processing</li>
</ul>
<p class=indent>
<B><b>Note&nbsp;&nbsp;&nbsp;</b></B> For more information about the toolkit, see the Microsoft Windows CE Web site (<a href="http://www.microsoft.com/windowsce/developer/prodinfo/vcceembed.htm">http://www.microsoft.com/windowsce/developer/prodinfo/vcceembed.htm</a>). The toolkit will also be available to Universal Subscribers of the MSDN Library.</p>
<p>
Microsoft can also develop other timing-related tools based on customers' needs</p>
<p>
The Windows CE development team has inspected the kernel code to verify that it can be characterized by a worst-case time that is independent of the number of system objects.</p>
<p>
For the purposes of this inspection, the kernel is characterized as a set of KCALLs, or system calls. These are kernel routines during which the kernel turns off preemption and does not allow other threads to run. The worst-case time that a real-time thread is held from running can be characterized as the worst-case KCALL time in the kernel. (Note that these times do not affect ISRs, but only threads, such as the ISTs.)</p>
<p>
The development team has by inspection shown that there are no nonconstant loops through the KCALLs. This means that all KCALLs can be expressed as code paths with only forward branches, and ensures that it is possible to find the worst case time through the KCALL independent of input parameters.</p>
<p>
Finding the actual worst-case times involves using the instrumented kernel. This is simply a version of the kernel that is compiled and built after setting a specific environment variable, <i>KCALL_PROFILE</i>=1, to enable additional timing-related functions. The instrumented kernel is not the same as the debug kernel. The instrumented kernel is built as a retail kernel to obtain timing values that are as close as possible to the shipping product. The only difference between the retail kernel and the instrumented kernel is its instrumentation code.</p>
<p>
The instrumented kernel records all KCALL times. These values, including minimum, maximum, and average times, can be printed to the debug port by calling the special API function, <b>DumpKCallProfile</b>. The instrumented kernel is typically run under heavy stress and then an application calls <b>DumpKCallProfile</b> to obtain the times.</p>
<p>
The interrupt test utility Intrtime.exe collects interrupt-timing-delay data on a standard version of Windows CE. The utility takes over the system timer interrupt during the test, so it is not suitable for use on systems where the timer is required. For example, this utility cannot be used with the instrumented version of the kernel, which also requires the timer for its data.</p>
<h3>Measured Latencies on Windows CE Alder (Beta)</h3>
<p>
The Intrtime utility ran a test of 1000 interrupts on the Hitachi D9000 Reference Platform with an SH3 microprocessor, running at 58.98 megahertz (MHz) internal and 14.745 MHz external frequency.(For information about Windows CE runtime characteristics running on other microprocessors, please contact the vendors.)</p>
<p>
&nbsp;The tests ran on a standard Handheld/PC configuration built to include all modules and components of Windows CE. Only the main operating system processes were running (Nk.exe, Filesys.exe, Gwes.exe, Device.exe, Shell.exe, and Explorer.exe), with no user-initiated interrupts (touch screen, keyboard, or other applications) during the tests. The utility reported the following minimum and maximum times to Start of ISR and Start of IST.</p>
<p class=label>
<b>Table 2. Interrupt test results</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=27%><b>Latency</b></td>
<td class=label width=73%><b>Minimum and maximum values (1000 tests)</b></td>
</tr>
<tr valign=top>
<td width=27%>Start of ISR</td>
<td width=73%>1.3–7.5 microseconds</td>
</tr>
<tr valign=top>
<td width=27%>Start of IST</td>
<td width=73%>93–275 microseconds</td>
</tr>
</table><br>
<p>
Most of the test results were distributed near the reported minimum values. While testing the start of ISR times, the minimum values 1.3 microseconds and 1.6 microseconds occurred 293 and 549 times, respectively, representing 84 percent of the tests. Similarly, over 90 percent (923 of 1000) of the Start-of-IST tests reported maximum latencies of 102 microseconds or less.</p>
<p>
The Intrtime utility also creates a user-configurable number of system objects to test the ISR and IST start times with a variety of system objects. Although this work is very preliminary, it demonstrates that the Start of ISR times are independent of the number of system objects. The tests ran 1000 times (unless otherwise noted) with a background thread priority set to 5 or 7.</p>
<p class=label>
<b>Table 3. ISR start times</b></p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=21%><b>Start of ISR Maximum</b></td>
<td class=label width=54%><b>Numbers of background threads (with one event per thread)</b></td>
<td class=label width=25%><b>Background thread priority</b></td>
</tr>
<tr valign=top>
<td width=21%>8.4</td>
<td width=54%>0</td>
<td width=25%>7</td>
</tr>
<tr valign=top>
<td width=21%>8.6</td>
<td width=54%>5 (Note: represents only 100 tests)</td>
<td width=25%>7</td>
</tr>
<tr valign=top>
<td width=21%>9.0</td>
<td width=54%>10 (Note: represents only 100 tests)</td>
<td width=25%>5</td>
</tr>
<tr valign=top>
<td width=21%>14.8</td>
<td width=54%>10</td>
<td width=25%>5</td>
</tr>
<tr valign=top>
<td width=21%>19.2</td>
<td width=54%>10</td>
<td width=25%>5</td>
</tr>
<tr valign=top>
<td width=21%>17.0</td>
<td width=54%>10</td>
<td width=25%>7</td>
</tr>
<tr valign=top>
<td width=21%>12.8</td>
<td width=54%>20</td>
<td width=25%>5</td>
</tr>
<tr valign=top>
<td width=21%>11.0</td>
<td width=54%>20 (Note: represents only 100 tests)</td>
<td width=25%>7</td>
</tr>
<tr valign=top>
<td width=21%>10.0</td>
<td width=54%>50</td>
<td width=25%>7</td>
</tr>
<tr valign=top>
<td width=21%>15.0</td>
<td width=54%>100</td>
<td width=25%>5</td>
</tr>
<tr valign=top>
<td width=21%>15.6</td>
<td width=54%>100</td>
<td width=25%>7</td>
</tr>
</table><br>
<p>
The values are not a function of the number of objects in the system. The different values are likely accounted for by the kernel state at the time the interrupt occurred. The development team is currently working on identifying the worst-case Start-of-ISR time.</p>
<p>
Working backward from these results, and assuming that the minimum value to Start of ISR represents the best-case scenario, where <i>dISR_Current</i> and <b>sum(</b><i>dISR_Higher</i><b>)</b> = 0, the minimum <b>value1</b> = start of ISR = 1.3 microseconds. Similarly, assuming the best-case scenario where <b>sum(</b><i>dIST</i><b>) and sum(</b><i>dISR</i><b>)</b> have the value 0, the minimum <b>value2</b> = Start of IST = 93 microseconds. From these test results alone, however, it is not possible to determine the maximum values for <b>value1</b> or <b>value2</b>.</p>
<p>
Additional timing information can be gleaned from the instrumented kernel. A worst-case value for the amount of time spent in the kernel before Start of IST, <b>value2</b>, can be calculated based on the following formula:</p>
<p>
<b>value2 = </b><i>dKCall</i><b> + </b><i>dNextThread</i></p>
<p class=indent>
<i>dKCall</i> = The duration of the kernel call; the amount of time spent in one of the sections of the kernel during which preemption is turned off.</p>
<p class=indent>
<i>dNextThread</i> = The duration of the <b>NextThread</b> kernel call; the amount of time spent setting up the IST.</p>
<p>
In reality, the scheduling of a thread at priority level 0 is faster than the general <b>NextThread</b> call, but this formula can simulate the upper bound.</p>
<p>
The following table shows the worst-case results during preliminary tests with the instrumented kernel. These tests ran under the same conditions as the Intrtime tests described above.</p>
<p class=label>
<b>Table 4. Worst-case results</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=50%><b>Kernel call profiled</b></td>
<td class=label width=50%><b>Maximum values (ad-hoc testing)</b></td>
</tr>
<tr valign=top>
<td width=50%>Highest maximum time, all kernel calls</td>
<td width=50%>266 microseconds (<b>LeaveCrit</b>)</td>
</tr>
<tr valign=top>
<td width=50%><b>NextThread</b></td>
<td width=50%>237 microseconds</td>
</tr>
<tr valign=top>
<td width=50%><b>Total</b></td>
<td width=50%><b>503 microseconds</b></td>
</tr>
</table><br>
<p>
The instrumented kernel suggests that the upper bound for <b>value2</b> in these conditions is about 500 microseconds. This value, the sum of two worst-case times, far exceeds the actual test results reported by the Intrtime utility, and is greater than the actual worst-case time. For example, scheduling a priority 0 thread does not lead to the worst-case path through <b>NextThread</b>. This suggests that the 500-microsecond value represents a conservative upper bound that is higher than the actual worst-case time.</p>
<p>
The Intrtime utility is useful for reporting <i>observed</i> worst-case times of the system as a whole. The instrumented kernel is useful for reporting <i>possible</i> worst-case times. It profiles all latencies caused by the kernel—those cases where an IST is ready to run but is blocked while execution continues within a nonpreemptible portion of the kernel. The system worst-case latency can be calculated from the sum of the worst-case times of its parts.</p>
<p>
Note that in this preliminary version of this article, all test results are based on an internal beta version of Windows CE. The existing operating system and utilities will continue to be modified and additional testing will profile system performance under a variety of operating conditions. These values will continue to be updated and published to reflect the current shipping version of the operating system.</p>
<h2>Summary</h2>
<p>
The Microsoft Windows CE kernel design meets the minimum requirements of an RTOS described here, enabling Windows CE to be used as the operating system in many different types of embedded and real-time systems:
<ul type=disc>
<li>
Windows CE is multithreaded and preemptive.<br><br></li>
<li>
Windows CE supports eight levels of thread priority.<br><br></li>
<li>
Windows CE supports a system of priority inheritance that dynamically adjusts thread priorities to correct priority inversion.<br><br></li>
<li>
Windows CE supports predictable thread synchronization mechanisms, including such wait objects as mutex, critical section, and named and unnamed event objects, which are queued based on thread priority. Windows CE also supports access to system timers.<br><br></li>
<li>
The OEM can control interrupt handling performed by the system, as the OEM implements the ISRs and ISTs that make up the interrupt-processing software.<br><br></li>
<li>
The OEM has complete control over all IRQs mapped to interrupt IDs and its associated interrupt-handling software, the ISR and IST. Profiling tools and utilities are available to record the maximum time required to process an interrupt.<br><br></li>
<li>
Interrupt latency is predictable and bounded. The upper bound is the sum of the amount of time spent in the kernel while preemption is turned off, task switching time, and the amount of processing time required by the ISRs and ISTs implemented by the OEM.<br><br></li>
<li>
The time for every system call (KCALL) is predictable and independent of the number of objects in the system. The system call time can be validated using the instrumented kernel.</li>
</ul>
<p>
The Windows CE kernel design ensures predictable, bounded latencies for interrupts and their associated threads. This makes it suitable for many real-time applications. Future releases of the Windows CE Embedded Toolkit for Visual C++ will include interrupt timing utilities and an instrumented kernel to allow the OEM to examine and calibrate timing performance.</p>
<h2>For More Information</h2>
<p>
For the Microsoft Windows CE Embedded Toolkit for Visual C++ 5.0, see the Microsoft Windows CE Web site (<a href="http://www.microsoft.com/windowsce/developer/prodinfo/vcceembed.htm">http://www.microsoft.com/windowsce/developer/prodinfo/vcceembed.htm</a>). The toolkit will also be available to Universal Subscribers of the MSDN Library.</p>
<p>
Also, be sure to take a look at the following articles, all available in the MSDN Library:</p>
<p>
<a href="msdn_embeddev.htm">"Embedded Development with Microsoft Windows CE 2.0,"</a> by Franklin Fite Jr. and Randy Kath.</p>
<p>
<a href="msdn_vcceembo.htm">"Introducing the Windows CE Embedded Toolkit for Visual C++ 5.0,"</a> by David Pellerin.</p>
<p>
<a href="msdn_mgdiview.htm">"Microsoft Windows CE Display Drivers and Hardware,"</a> by Jason Black and Jon Christiansen.</p>
<p>
<a href="msdn_mgdidft1.htm">"Microsoft Windows CE Graphics Features,"</a> by Jon Christiansen.</p>
<p>
<a href="msdn_memdrft2.htm">"Microsoft Windows CE Memory Use,"</a> by John Murray.</p>
<p>
<a href="msdn_comm_mod.htm">"The Microsoft Windows CE Communications Model,"</a> by Guy Smith.</p>
<p>
<a href="msdn_w32model.htm">"The Win32 Programming Model: A Primer for Embedded Software Developers,"</a> by David Pellerin.</p>
</BODY>
</HTML>
