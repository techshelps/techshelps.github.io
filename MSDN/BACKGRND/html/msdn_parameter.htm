<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Parameter Passing in Microsoft Transaction Server</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_parameter"></a>Parameter Passing in Microsoft Transaction Server</h1>
<p>
Microsoft Corporation</p>
<p>
June 1997</p>
<h2>Abstract</h2>
<p>
This article covers the following:
<ul type=disc>
<li>
Parameter types and marshaling<br><br></li>
<li>
Objects as parameters<br><br></li>
<li>
Passing Microsoft® Transaction Server (MTS) object references<br><br></li>
<li>
Callbacks<br><br></li>
<li>
Passing large data</li>
</ul>
<h2>Parameter Types and Marshaling</h2>
<p>
Microsoft Transaction Server object interfaces must be able to be marshaled. <i>Marshaling</i> interfaces allows calls across thread, process, and machine boundaries. <i>Use standard marshaling</i> with MTS applications. This means that your MTS object interfaces must either:
<ul type=disc>
<li>
Have method parameters which are Automation data types and be described in a type library, or<br><br></li>
<li>
Use custom interfaces with an MIDL-generated proxy-stub DLL</li>
</ul>
<p>
For more information on type libraries and proxy-stub DLLs, see <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="msdn_DllMTS">
</object><a href=JavaScript:alink_1.Click()>"DLLs, Type Libraries, and Microsoft Transaction Server."</a></p>
<p>
<i>Do not use custom marshaling</i>. Even if a component supports the <b>IMarshal</b> interface, its <b>IMarshal</b> methods will never be called by the MTS run-time environment.</p>
<h3>VBScript Parameters</h3>
<p>
Components that are intended for use from Active Server Pages (ASPs) using Microsoft Visual Basic®, Scripting Edition (VBScript) should support <b>IDispatch</b> and limit method parameter types as follows:
<ul type=disc>
<li>
<b>VBScript version 1.0—</b>Any Automation type may be passed by value, but not by reference. Method return values must be of type <b>Variant</b>.<br><br></li>
<li>
<b>VBScript version 2.0—</b>Same as VBScript version 1.0, except parameters of type <b>Variant</b> may now be passed by reference.</li>
</ul>
<h2>Objects as Parameters</h2>
<p>
Whether an object is passed <i>by value</i> or <i>by reference</i> is not specified by the client, but is a characteristic of the object itself. Basic COM objects can either be passed by reference or by value, depending on their implementation. If the COM object uses standard marshaling, then it is passed by reference. COM objects can also implement <b>IMarshal</b> to copy data by value. MTS objects are always passed by reference.</p>
<p>
Additionally, the function of the object affects how it should be passed as a parameter. When deciding whether to pass objects by value or by reference, it is useful to classify the objects as follows:
<ul type=disc>
<li>
<b>Recordset Objects—</b>Encapsulate raw data; for example, an ADO recordset. Recordset objects are not registered as MTS objects.<br><br></li>
<li>
<b>Business Object—</b>Encapsulate business logic; for example, an order-processing component. Business objects should be registered as MTS objects.</li>
</ul>
<p>
The following table describes when to pass recordset objects by value or by reference:</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=25%><b>Pass Parameter</b></td>
<td class=label width=33%><b>If</b></td>
<td class=label width=42%><b>Client Requirements</b></td>
</tr>
<tr valign=top>
<td width=25%>By value</td>
<td width=33%>Data is relatively small</td>
<td width=42%>Recipient requires all data and can get data without reaccessing caller.</td>
</tr>
<tr valign=top>
<td width=25%>By reference</td>
<td width=33%>Data is relatively large</td>
<td width=42%>Recipient does not require all data and must reaccess caller, possibly many times.</td>
</tr>
</table><br>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Whether data is "small" or "large" also depends on the speed of the connection. For example, if the component will be accessed over a corporate intranet, a much larger recordset could be passed to the client in one call than a client accessing the component on an Internet server over a modem could receive.</p>
<p>
Because business objects are MTS objects, they are always passed by reference.</p>
<h2>Passing MTS Object References</h2>
<p>
You must ensure that MTS object references are only exchanged in the following ways:
<ul type=disc>
<li>
Through return from an object creation interface, such as <b>CoCreateInstance</b> (or its equivalent), ITransactionContext::CreateInstance<b> </b>, or IObjectContext::CreateInstance.<br><br></li>
<li>
Through a call to <b>QueryInterface</b>.<br><br></li>
<li>
Through a method that has called <b>SafeRef</b> to obtain the object reference.</li>
</ul>
<p>
An object reference that is obtained in these ways is called a safe reference. MTS ensures that methods invoked using safe references execute within the correct context.</p>
<p>
<img src="parameter1.gif" border=0></p>
<p class=label>
<b>Figure 1. Using SafeRef to pass a reference to an object</b></p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;It is not safe to exchange references by any other means. In particular, do not pass interfaces outside the object by using global variables. These restrictions are similar to those imposed by COM for references passed between apartments.</p>
<p>
Calls that use safe references always pass through the MTS run-time environment. This allows MTS to manage context switches and allows MTS objects to have lifetimes that are independent from client references. (For more information, see the "Deactivating Objects" topic in the Microsoft Transaction Server version 1.0 Help file.)</p>
<h2>Callbacks</h2>
<p>
It is possible to make <i>callbacks</i> to clients and to other MTS components. For example, you could have an object that creates another object. The creating object can pass a reference to itself to the created object; the created object can then use this reference to call the creating object.</p>
<p>
If you choose to use callbacks, note the following restrictions:
<ul type=disc>
<li>
Calling back to the base client or another package requires access-level security on the client. Additionally, the client must be a DCOM server.<br><br></li>
<li>
Intervening firewalls may block calls back to the client.<br><br></li>
<li>
Work done on the callback executes in the environment of the object being called. It may be part of the same transaction, a different transaction, or no transaction.<br><br></li>
<li>
The creating object must call <b>SafeRef</b> and pass the returned reference to the created object in order to call back to itself.</li>
</ul>
<h2>Passing Large Data</h2>
<p>
When returning a large amount of data, consider using a Microsoft Active Data Objects (ADO) recordset. In particular, the Microsoft Advanced Data Connector (ADC) provides a recordset implementation that can be disconnected from the server and marshaled by value to the client.</p>
<p>
<img src="parameter2.gif" border=0></p>
<p>
The disconnected recordset moves state to the client, allowing server resources to be freed. The client can make changes to the recordset and reconnect to the server to submit updates. For more information on state, see <a href="msdn_state.htm">"Holding State in Objects."</a></p>
<p>
Another method of packaging large amounts of data is to use <i>safe arrays</i>. For example, when using Microsoft Remote Data Objects (RDO), you can use the <b>rdoResultSet.GetRows</b> method to copy rows into an array, and then pass the array back to the client. This requires fewer calls and is more efficient than issuing <b>MoveNext</b> calls across the network for each row.</p>
</BODY>
</HTML>
