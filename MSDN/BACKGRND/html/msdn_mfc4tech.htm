<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Microsoft Foundation Class Library 4.0: C++ Application Framework for Microsoft Windows</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_mfc4tech"></a>Microsoft Foundation Class Library 4.0: C++ Application Framework for Microsoft Windows</h1>
<p>
September 1995</p>
<h2>Introduction</h2>
<p>
This paper provides a technical discussion of the major features of the Microsoft® Foundation Class Library version 4.0 (MFC 4.0). MFC 4.0 provides developers with a set of reusable, prebuilt C++ components that provide a completely portable interface for applications for the Microsoft Windows®, Windows 95, and Windows NT™ operating systems, as well as the Macintosh® and UNIX® platforms. These components encapsulate the common Windows-based functions that end users have come to expect in any Windows-based application, such as toolbars and status bars, form and edit views, print and print preview, OLE visual editing and OLE Automation, multiple-document interface, splitter and scroller windows, dialog data exchange and validation, dialog boxes, database access, and even context-sensitive help. Using MFC's prebuilt components, programmers can quickly create professional Windows-based applications that contain preconstructed application behavior. Using the MFC library saves programmers a considerable amount of development time.</p>
<p>
MFC 4.0 is integrated with the Microsoft Visual C++® development system version 4.0 and in particular with Component Gallery, ClassWizard, and AppWizard. Many features of MFC are made simpler, less error-prone, and more streamlined by using these tools and the Visual C++ development system. For more information on the Visual C++ development system version 4.0, see the <i>Microsoft Visual C++ Version 4.0 Reviewers Guide</i>.</p>
<p>
In this document, MFC 1.0, MFC 2.0, MFC 2.5, MFC 3.0, and MFC 4.0 refer to features specific to that particular version of the Microsoft Foundation Class Library. The name <i>MFC</i> refers to general concepts, architecture, and application programming interfaces (APIs) of the Microsoft Foundation Class Library and focuses on the latest versions of the classes.</p>
<h2>History and Evolution</h2>
<p>
The Microsoft Foundation Class Library 4.0 is a robust C++ application framework designed for writing applications in C++ for the Microsoft Windows operating system. MFC 4.0 is the latest version in the growing and evolving MFC library.</p>
<p>
MFC 1.0 was released in April 1992 with Microsoft C/C++ version 7. The 32-bit version was released later that year as part of the Win32® Prerelease Development Kit program. The features of MFC 1.0 fell mainly into two categories: general-purpose classes for the nongraphical portion of an application and Windows-related classes for the graphical user-interface (GUI) features of an application.</p>
<p>
General-purpose classes were the following: 
<ul type=disc>
<li>
Run-time type information<br><br></li>
<li>
Object persistence<br><br></li>
<li>
Collection classes<br><br></li>
<li>
Strings<br><br></li>
<li>
Files<br><br></li>
<li>
Time and date<br><br></li>
<li>
Exception handling<br><br></li>
<li>
Exception handling</li>
</ul>
<p>
Windows-related classes were the following:
<ul type=disc>
<li>
Application startup and other application services<br><br></li>
<li>
Window management<br><br></li>
<li>
Graphics device interface (GDI)<br><br></li>
<li>
Multiple-document interface (MDI)<br><br></li>
<li>
Menus<br><br></li>
<li>
Dialog boxes<br><br></li>
<li>
Windows controls<br><br></li>
<li>
Windows common dialogs<br><br></li>
<li>
OLE version 1.0</li>
</ul>
<p>
Ten months later, in February 1993, MFC 2.0 was released as part of Visual C++ version 1.0. The core features of MFC 1.0 were extended to include new architectural classes to help organize and structure application programs as well as high-level abstractions in the form of prebuilt functionality that provides major building blocks. In August of the same year, the 32-bit version of MFC 2.0 was released as part of the 32-bit edition of Visual C++ 1.0.</p>
<p>
Architectural classes were the following:
<ul type=disc>
<li>
Commands<br><br></li>
<li>
Documents and views<br><br></li>
<li>
Printing and print preview<br><br></li>
<li>
Dialog data exchange and validation (DDX/DDV)<br><br></li>
<li>
Context-sensitive help</li>
</ul>
<p>
High-level abstractions were the following:
<ul type=disc>
<li>
Form view<br><br></li>
<li>
Edit view<br><br></li>
<li>
Scrolling view<br><br></li>
<li>
Splitter window<br><br></li>
<li>
Toolbars and status bar<br><br></li>
<li>
Dialog bar and other control bars<br><br></li>
<li>
VBX version 1.0 controls (16-bit only)</li>
</ul>
<p>
Ten months later, in December 1993, MFC 2.5 was released as part of Visual C++ version 1.5. In addition to all the features of MFC 2.0, this new release added support for databases, giving programmers access to any data source through ODBC and full support for the many features of OLE. This was a 16-bit-only release, and MFC 2.5 continues to be supported for 16-bit application development.</p>
<p>
Database classes were the following:
<ul type=disc>
<li>
Database engine classes<br><br></li>
<li>
Record field exchange (RFX)<br><br></li>
<li>
Record view</li>
</ul>
<p>
OLE 2.0 classes were the following:
<ul type=disc>
<li>
Visual editing servers<br><br></li>
<li>
Visual editing containers<br><br></li>
<li>
Drag and drop<br><br></li>
<li>
Structured storage<br><br></li>
<li>
OLE Automation servers<br><br></li>
<li>
OLE Automation clients</li>
</ul>
<p>
Fewer than 10 months later, in September of 1994, MFC 3.0 was released as part of Visual C++ version 2.0. In addition to all the new features of MFC 2.5, this release added 32-bit functionality, more user-interface idioms, more support for the Win32 API, as well as bootstrapping for OLE controls. MFC 3.0 extended the role of MFC to be the core infrastructure of most Win32-based applications.</p>
<p>
New user-interface classes were the following:
<ul type=disc>
<li>
Enhanced toolbars<br><br></li>
<li>
Miniframe windows<br><br></li>
<li>
Tabbed dialogs (property pages)</li>
</ul>
<p>
New support for Win32 consisted of the following:
<ul type=disc>
<li>
New Win32 APIs<br><br></li>
<li>
Multithreading<br><br></li>
<li>
Unicode™ support<br><br></li>
<li>
Shared 32-bit dynamic-link libraries (DLLs)</li>
</ul>
<p>
New language syntax support included the following features:
<ul type=disc>
<li>
C++ templates<br><br></li>
<li>
C++ exceptions</li>
</ul>
<p>
In two following Visual C++ subscription releases, MFC was again updated to deliver support for key Windows functionality such as Messaging Application Programming Interface (MAPI), Windows Sockets, and more. The features added to MFC 3.1 and 3.2 include the following:
<ul type=disc>
<li>
Windows 95 common controls<br><br></li>
<li>
Simple MAPI<br><br></li>
<li>
Windows Sockets<br><br></li>
<li>
Swap-tuned DLL versions</li>
</ul>
<p>
The latest version, MFC 4.0, is available via the latest release of Visual C++, version 4.0. The new features in MFC 4.0 include the following:
<ul type=disc>
<li>
Containment of OLE controls<br><br></li>
<li>
Data Access Objects (DAO)<br><br></li>
<li>
Simplified Windows 95 common controls<br><br></li>
<li>
Windows 95 common dialogs<br><br></li>
<li>
Thread synchronization objects<br><br></li>
<li>
Integration of the OLE Control Development Kit</li>
</ul>
<h2>MFC Overview</h2>
<p>
MFC 4.0 builds upon the core set of functionality of MFC 1.0, the architecture and prebuilt high-level abstractions added in MFC 2.0, the OLE and Open Database Connectivity (ODBC) functionality added in MFC 2.5 and MFC 3.0, and the new user-interface and Windows Open Services Architecture (WOSA) features of MFC 3.1 and 3.2. MFC makes it possible to write professional, full-featured Windows-based applications in a fraction of the time it would take using C and the Software Development Kit (SDK) or other application frameworks. Equally important, MFC 4.0 continues the tradition of upward compatibility that is essential to development teams.</p>
<p>
MFC offers a high level of abstraction that lets programmers focus on the details specific to the application while allowing its classes to be customized and extended. Like its predecessors, MFC 4.0 also allows access to the native Windows API for maximum flexibility and power. Rigorous tuning and optimizing of the source code have resulted in very high execution speeds and small executable files whose sizes are comparable to those produced using C.</p>
<p>
MFC relies on the underlying Windows (Win32) API not only for its implementation but also for the factoring and flavor of many of the lower-level MFC classes. Providing C++ functionality that is tied to the Win32 API is a strength, because the Win32 API provides portability and a good infrastructure, and it makes it easy to call APIs that are not provided by the framework. Of course, MFC will continue to evolve and support the Windows operating system very closely, so developers using MFC will have support for the latest features of the operating system.</p>
<p>
MFC uses a safe subset of the C++ language and was designed so that programmers could take advantage of their knowledge about programming to the Windows API. MFC uses C++ idioms in the commonly accepted manner and does not overlook advanced issues such as copy construction, assignment operators, and correct object destruction. These issues are a common source of error in user code and can be difficult to track down. Users of MFC do not have to be experts who understand all the details and idiosyncrasies of the C++ language. At the same time, more experienced C++ developers can use more advanced features of the language and still access the power of MFC. Also, the MFC library source code serves as an example of both professional C++ code and professional Windows-based code.</p>
<p>
MFC makes programming in Windows and C++ a much more productive endeavor. Through its carefully designed architecture, MFC provides substantial programming power in an intuitive and uncomplicated package. MFC 4.0 offers more than 100 reusable C++ classes that provide a wide range of functionality.</p>
<h3>Customer Feedback Drives Evolution</h3>
<p>
Microsoft's Visual C++ group continually receives a great deal of feedback on MFC from many users who are working with real-world projects and are shipping applications. Visual C++ received critical acclaim from both developers and the press, and the product was generally recognized as the standard application framework for Windows. Microsoft also received hundreds of suggestions and feature requests through CompuServe® and Microsoft's MSVC e-mail address and from the dozens of conferences and shows where Microsoft team members heard from users who had developed mission-critical applications with MFC. Microsoft has implemented many of these requested features, and this release of the application framework represents the collective wisdom of the user community. MFC 4.0 includes substantial support for OLE controls, fast data access, and the new Windows common controls supported by Windows 95, which have been requested by many users.</p>
<p>
The ability to incorporate user feedback is important to the long-term evolution of MFC as Microsoft continues to improve MFC for future releases. Microsoft developers are also part of the user community; the Visual C++ team at Microsoft has been using MFC to develop its own products. As a case in point, the Visual C++ 4.0 development environment, Developer Studio, is an MFC 4.0 application. MFC has also been widely adopted by companies such as Siebel Systems, Micrografx, Attachmate Corporation, and Federal Express to develop mission-critical solutions.</p>
<h3>MFC Portability</h3>
<p>
MFC has been designed to be portable to a number of platforms, allowing applications written to MFC to target a variety of different platforms. MFC is also portable to a variety of compiler implementations, and the many companies who have licensed MFC have made it a standard application framework for Windows-based development. Microsoft plans to keep extending and evolving MFC to support new functionality for applications and to exploit new functionality in the operating system.</p>
<h3>Multiple Platforms</h3>
<p>
Writing a program on top of MFC makes that program portable to a wide variety of platforms. Because MFC is built on top of the Win32 API, any platform that supports the Win32 API can be targeted by an MFC application. A powerful aspect of MFC portability is that Win32-based platforms are not limited to Microsoft Windows. Through the use of the Windows Portability Layer, MFC applications built on Win32 can also be built to run under the Macintosh System 7 operating system.</p>
<p>
MFC applications can target a large number of platforms today:
<ul type=disc>
<li>
Microsoft Windows 95<br><br></li>
<li>
Microsoft Windows NT running on Intel® processors<br><br></li>
<li>
Microsoft Windows NT running on MIPS® processors<br><br></li>
<li>
Microsoft Windows NT running on Alpha AXP™<br><br></li>
<li>
Microsoft Windows NT running on PowerPC™<br><br></li>
<li>
Microsoft Windows 3.1 using the Win32s® API<br><br></li>
<li>
Apple® Macintosh (using the 68000-series instruction set)<br><br></li>
<li>
Apple Macintosh (using the PowerPC™ instruction set)</li>
</ul>
<p>
In addition, Microsoft continues to working with companies licensed to provide the Windows API on UNIX and VMS™ platforms to make sure that developers can easily port their MFC applications to these platforms as well. These products are available today.</p>
<h2>Licensing of MFC</h2>
<p>
In August 1993, Microsoft announced the licensing of MFC (then version 2.0) to other software vendors, including competing C/C++ compiler vendors. Licensees receive all of the MFC source code, code samples, and help files, along with the right to redistribute them to their customers.</p>
<p>
Several major tools vendors are shipping MFC with their products, and the list of MFC licensees continues to grow.</p>
<h2>Evolution of an Industry Standard</h2>
<p>
The Microsoft Foundation Class Library is appropriately named because it represents the foundation of a class architecture that is constantly evolving to bring developers the best support for the Windows operating system. The class hierarchy and the functionality it encapsulates have been designed for scalability. Applications written for MFC 1.0 are compatible with MFC 2.0 through MFC 4.0 and beyond. MFC applications that were originally written for 16-bit Windows can be recompiled with very minor source-code modifications to run as full 32-bit programs under any of the many Win32-compatible platforms. (The modifications required are due to converting any 16-bit specific code in the application. The application framework code does not rely on 16-bit or 32-bit implementation details.)</p>
<p>
The Microsoft Foundation Class Library represents an entire family of class libraries. The design of MFC 4.0 incorporates an architecture that is highly scalable. As new versions of the Windows operating system are released, the Microsoft Foundation Class Library will grow in a natural manner to encompass new capabilities. As a case in point, MFC 4.0 is designed to facilitate application portability to the many platforms that now support the Win32 API.</p>
<p>
MFC 4.0 encompasses most of the functionality available through the Win32 API. Because more than 70,000 lines of portable C++ source code for the application framework are included with the product, developers can use the framework in its original form or fully customize it for their own purposes. This source code serves as an example of robust and professional C++ Windows-based code. In addition, programmers are able to use this code to learn new implementation techniques and look "under the hood" of MFC. Consistent naming conventions and coding style, along with stand-alone documentation, make the learning curve minimal. A tutorial is included that helps programmers step by step through development of a substantial C++ MFC program for Windows, incorporating most application framework features. In addition, more than 70 complete sample applications are included that demonstrate the most common uses (and many advanced uses) of the framework.</p>
<h2>MFC Migration Kit</h2>
<p>
Because of the great productivity gains that developers have been achieving from using MFC, an increasing number of developers want to adopt the framework. To help these developers, Microsoft has developed an MFC Migration Kit that is designed to assist the migration to MFC of existing applications for Windows written in C. The MFC Migration Kit supplies the following:
<ul type=disc>
<li>
An extensive <i>MFC Migration Guide</i>, a help file that takes developers through the migration process with both 16- and 32-bit sample applications using MFC<br><br></li>
<li>
A migration tool (in 16- and 32-bit versions) that scans C-language source code and suggests steps for migrating the code to MFC<br><br></li>
<li>
Both 16- and 32-bit sample applications before migration (in C) and after migration (in C++)</li>
</ul>
<p>
The migration tool can also help developers port 16-bit applications to 32 bits, with or without MFC. The <i>MFC Migration Guide</i> explains where that port fits into your migration strategy. The MFC Migration Kit is available in the latest subscription release of Visual C++, version 4.0. The kit is located in the \MFCKIT directory on the Visual C++ CD-ROM disc. Setup for the kit can be run from that location.</p>
<h2>New Features in MFC 4.0</h2>
<p>
The following features have been introduced in MFC 4.0. Some of these features appeared earlier in subscription updates to Visual C++.</p>
<h3>Windows Common Control Classes</h3>
<p>
Microsoft Visual C++ version 4.0 supplies MFC classes to encapsulate most of the new Windows common controls supplied with the Windows 95 and Windows NT operating systems. The integrated tools (editors and wizards) in Visual C++ 4.0 also support Windows common controls. These controls are also supported by the Visual C++ Cross-Development system for the Macintosh.</p>
<p>
The Windows common controls supported by MFC 4.0 include the following:
<ul type=disc>
<li>
<b>CAnimateCtrl. </b>A control that displays successive frames of an Audio Video Interleaved (AVI) clip during a lengthy operation.<br><br></li>
<li>
<b>CCheckListBox. </b>A control that displays a list of items, such as file names, that the user can view and select. A check box appears next to each item in the list; the user can check or clear the selected item's check box.<br><br></li>
<li>
<b>CDragListBox. </b>A control similar to a <b>CListBox</b> that allows the user to move items, such as file names and string literals, within the list box. List boxes with this capability are useful for an item list that is in an order other than alphabetic, such as one that includes path names or files in a project.<br><br></li>
<li>
<b>CHeaderCtrl</b>. A resizable button that appears above a column of text, allowing the user to display more or less information in the column.<br><br></li>
<li>
<b>CHotkeyCtrl. </b>A window that enables the user to create a hot key. A <i>hot key</i> is a key combination that the user can press to perform an action quickly.<br><br></li>
<li>
<b>CImageList. </b>A collection of images used to efficiently manage large sets of icons or bitmaps.<br><br></li>
<li>
<b>CListCtrl. </b>A window that displays a collection of items, each consisting of an icon and a label.<br><br></li>
<li>
<b>CProgressCtrl. </b>Also known as a <i>progress bar control</i>, this window can be used by an application to indicate the progress of a lengthy operation.<br><br></li>
<li>
<b>CRichEditCtrl. </b>A window in which the user can enter and edit text with character and paragraph formatting. The control can include embedded OLE objects.<br><br></li>
<li>
<b>CSliderCtrl. </b>Also known as a <i>trackbar</i>, this window containing a slider and optional tick marks sends notification messages to indicate changes in its position.<br><br></li>
<li>
<b>CSpinButtonCtrl. </b>Also known as an <i>up-down control</i>, this pair of arrow buttons can be clicked to increment or decrement a value, such as a scroll position or a number displayed in a companion control.<br><br></li>
<li>
<b>CStatusBarCtrl. </b>A horizontal window in a parent window in which an application can display various kinds of status information. This control resembles the MFC <b>CStatusBar</b> class.<br><br></li>
<li>
<b>CTabCtrl. </b>This control is analogous to the dividers in a notebook or the labels in a file cabinet. By using a tab control, an application can define multiple pages for the same area of a window or dialog box.<br><br></li>
<li>
<b>CToolBarCtrl. </b>A window that contains one or more command-generating buttons. This control resembles the MFC <b>CToolBar</b> class.<br><br></li>
<li>
<b>CToolTipCtrl. </b>A small pop-up window that displays a single line of text describing the purpose of a toolbar button or other tool in an application.<br><br></li>
<li>
<b>CTreeCtrl. </b>Also known as a <i>tree view control</i>, this window displays a hierarchical list of items, such as the headings in a document, the entries in an index, or the files and directories on a disk. Each item consists of a label and an optional bitmapped image, and each item can have a list of subitems associated with it.</li>
</ul>
<p>
Several <b>CView</b>-derived classes are also available to simplify the use of the new controls in document-view architecture applications. <b>CListView</b>, <b>CTreeView</b> and <b>CRichEditView</b> make it easier to use the <b>CListCtrl</b>, <b>CTreeCtrl</b> and <b>CRichEditCtrl</b> objects. To provide further support for rich-text editing, <b>CRichEditDoc</b>, <b>CRichEditView</b> and <b>CRichEditCntrItem</b> classes are available that provide Document/View and control encapsulation. </p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Some of these controls appeared in MFC 3.1, but they have been improved and expanded (with improved documentation) for MFC 4.0.</p>
<h3>Full OLE Control Support</h3>
<p>
MFC now supplies complete OLE control container support and integrates the OLE Control Development Kit (CDK) with the rest of MFC. This allows developers to build, use, and share OLE controls with other developers, even those using different tools. </p>
<p>
Developers can choose from hundreds of OLE controls already on the market or build their own. These OLE controls are compatible with the latest versions of the Microsoft Visual Basic® programming system and the Microsoft Visual FoxPro™ database management system, as well as with many other development tools. The Visual C++ 4.0 dialog editor supports placing OLE controls in a dialog resource, making it easy to use prebuilt controls in applications. </p>
<p>
With the new OLE controls container, developers need not understand all the details of using OLE container applications. Support is based on the <b>CWnd</b> class, which allows users to create both the container and the control sides. In MFC version 4.0, an OLE control becomes a special kind of child window, with <b>CWnd</b> functions, including <b>CWnd::CreateControl</b>, which dynamically creates an OLE control rather than an ordinary window. </p>
<p>
Support is also provided for dialog data exchange (DDX), preloaded controls for improved performance, and transparent keyboard translation in <b>IsDialogMessage</b>. </p>
<h3>Direct Database Access with DAO</h3>
<p>
In addition to the existing ODBC database support, the new Data Access Object (DAO) classes for MFC enable developers to directly access the Microsoft Jet database engine, which is the same engine that is used in Microsoft Access for Windows 95 and Microsoft Visual Basic 4.0. The DAO classes encapsulate an OLE Component Object Model (COM) interface to the Jet database engine, so developers don't have to write the structured query language (SQL) themselves unless they want to do so.</p>
<p>
As with the ODBC database classes, developers can open and manipulate databases and recordsets and display the data in a form view. With DAO, they can also set up and use work spaces, create and manipulate tables and queries, and use and create indexes for those tables through the use of the SQL data definition language (DDL).</p>
<p>
Developers can also access ODBC data sources through attached tables using the DAO classes and the Jet engine.</p>
<h3>New Common Dialogs</h3>
<p>
Two new OLE common dialog classes, <b>CPageSetupDialog</b> and <b>COlePropertiesDialog</b>, have been developed to improve access to several aspects of an OLE object. <b>COlePropertiesDialog</b> encapsulates the Windows common OLE Properties dialog box to provide an easy way to display and modify the properties of an OLE document item in a manner consistent with Windows specifications. </p>
<p>
In addition, <b>CPageSetupDialog</b> encapsulates the services provided by the Windows common Page Setup dialog box with additional support for setting and modifying print margins. Several other new common dialogs, including the Windows 95 file I/O dialogs, are now supported by MFC.</p>
<h3>Thread Synchronization Objects</h3>
<p>
Multithread programs often require synchronizing access to shared resources by different concurrent threads. To manage synchronization, MFC supplies a new base class, <b>CSyncObject</b>, and several derived objects that represent common synchronization techniques. </p>
<p>
<b>CSyncObject</b> provides functionality common to the derived synchronization objects in the Win32 API. Support includes <b>Lock</b> and <b>Unlock</b> as virtual abstract operations that derived classes override. Classes derived from <b>CSyncObject</b> are <b>CSemaphore</b>, <b>CCriticalSection</b>, <b>CMutex</b>, and <b>CEvent</b>, encapsulating the Win32 synchronization objects. The <b>CSingleLock</b> and <b>CMultiLock</b> classes represent the access-control mechanisms used in controlling access to a resource in a multithread program. </p>
<h3>Simple MAPI Support</h3>
<p>
MAPI, the Messaging API for Windows, is a set of functions that mail-enabled and mail-aware applications use to create, manipulate, transfer, and store mail messages. It gives application developers the tools to define the purpose and content of mail messages, and it gives them flexibility in their management of stored mail messages. MAPI also provides a common interface that application developers can use to create mail-enabled and mail-aware applications independent of the underlying messaging system.</p>
<p>
Messaging clients provide a human interface for interaction with MAPI. This interaction typically includes requesting services from MAPI-compliant providers such as message stores and address books.</p>
<p>
MFC 3.1 includes support for Simple MAPI in classes <b>CDocument</b> and <b>COleDocument</b>. This support is also provided in MFC 2.52 for 16-bit development.</p>
<p>
With minimal effort, developers can add the ability to send an application's documents by means of the resident e-mail host. (Sending OLE compound documents is managed correctly in the <b>COleDocument</b> portion of the MAPI implementation.)</p>
<h3>Support for Windows Sockets</h3>
<p>
New Windows Sockets classes have been added for network programming. MFC provides support for Windows Sockets, the network-independent API for network communications programming under the Microsoft Windows and Windows NT operating systems.</p>
<p>
The new classes include <b>CAsyncSocket</b>, <b>CSocket</b>, and <b>CSocketFile</b>. Class <b>CAsyncSocket</b> encapsulates the Windows Sockets API. Class <b>CSocket</b>, derived from <b>CAsyncSocket</b>, additionally provides a simple programming model that lets developers serialize data from one socket application to another via a <b>CArchive</b> object, using a <b>CSocketFile</b> object.</p>
<h2>Features Introduced in MFC 3.0</h2>
<h3>Enhanced Toolbars</h3>
<p>
One of the most commonly requested user-interface elements is the toolbar, a row of buttons represented by bitmaps and optional separators. These bitmap buttons can behave like push buttons, check-box buttons, or radio group buttons. The MFC class <b>CToolBar</b> supports the standard toolbar look. All the toolbar buttons are normally taken from a single bitmap image, which is edited using the Visual C++ bitmap editor and contains one image for each button. Storing all the images in one bitmap reduces the amount of system resources used by an application.</p>
<p>
One of the key advantages of the MFC <b>CToolBar</b> class is that by using commands, programmers can enable and disable the various buttons in the toolbar in conjunction with any menu items for those same commands. This is important because toolbar buttons almost always duplicate menu items, allowing the programmers to write the command handler once and drive it from either a menu item or a toolbar button. </p>
<p>
MFC 4.0 adds dynamic resizing and layout of toolbars, which lets users change not only the toolbar location, but also resize the toolbar window. This makes vertical toolbars and tool "palettes" possible. A dockable toolbar can be attached or "docked" to any side of its parent window, or it can be "floated" in its own miniframe window (using <b>CMiniFrameWnd</b>). </p>
<p>
Programmers who use AppWizard to generate the skeleton of an application are asked to choose whether or not they want dockable and resizable toolbars. By default, AppWizard creates code to enable docking, resizing toolbars. <b>CToolBar</b> and <b>CFrameWnd</b> member functions are available to customize the behavior of the docking toolbar and to programatically dock or float a toolbar.</p>
<p>
Support for "tool tips" is also included. When the user moves the mouse over a toolbar button, a small box is shown on top of the button to describe the action that would be performed. Also supported are "fly-by" tool tips that provide a more detailed description of the command on the status bar. This saves the user from having to press a toolbar button to find out what the command does.</p>
<p>
MFC 3.0 also allowed persistence of toolbar configurations. Like many professional applications, MFC allows users to save the entire state of a given frame window's toolbar configuration, including each toolbar's current position and visible and floating states.</p>
<p>
The <b>CToolBar</b> class can easily support additional standard Windows controls, such as drop-down list boxes or edit controls, on the toolbar. In addition, <b>CToolBar</b> provides programmatic APIs for dynamically changing the buttons on the toolbar, customizing docking behavior, and highly customizing user interfaces in other ways.</p>
<p>
<img src="mfc4tech_1.gif" border=0></p>
<p class=label>
<b>Figure 1. Resized and floating toolbars</b></p>
<h3>Miniframe Windows</h3>
<p>
Miniframe windows are frame windows with thin caption bars, like those used in the Visual C++ property windows.</p>
<p>
The MFC class <b>CMiniFrameWnd</b>, derived from <b>CFrameWnd</b>, provides an alternative user interface for floating palettes and toolbars. In fact, the <b>CToolBar</b> implementation of tear-off toolbars uses the <b>CMiniFrameWnd</b> class to hold the torn-off toolbar.</p>
<p>
A <b>CMiniFrameWnd</b> object represents a half-height frame window typically seen around floating toolbars. These miniframe windows behave like normal frame windows, except that they do not have minimize/maximize buttons or menus, and the user only has to single-click the system menu to dismiss them.</p>
<h3>Property Sheets</h3>
<p>
MFC contains support for <i>property sheets</i>, also known as "tabbed dialog boxes." A property sheet is a special kind of dialog box that is generally used to modify the attributes of some external object, such as the current selection in a view. The property sheet has three main parts: the containing dialog box, one or more property pages shown one at a time, and a tab at the top of each page that the user clicks to select that page. Property sheets are useful when a number of similar groups of settings or options need to be changed. An example of a property sheet is the Project Settings dialog box in Visual C++. In this case, a number of different groups of options need to be set. The property sheet allows a large amount of information to be grouped in an easily understood fashion.</p>
<p>
This support is provided in two classes: <b>CPropertySheet</b>, which is a class to contain all the pages, with one tab per page; and <b>CPropertyPage</b>, which is a class that each property page is derived from.</p>
<p>
To create a property sheet with several pages, first create a dialog template resource for each property page using the Visual C++ dialog editor, then use ClassWizard to create a <b>CPropertyPage</b>-derived class corresponding to each property page dialog template. For each of these new classes, use ClassWizard to create member variables to hold the values for the property page. The process for adding member variables to a property page is exactly the same as adding member variables to a dialog box, because a property page is a specialized dialog box. </p>
<p>
Creating the property sheet at run time is easy to do, either by using the <b>CPropertySheet</b> class directly or by deriving a more specialized property sheet from it.</p>
<p>
<img src="mfc4tech_2.gif" border=0></p>
<p class=label>
<b>Figure 2. Miniframe property sheet</b></p>
<h3>User Interface for Windows 95</h3>
<p>
For Windows 95, MFC is designed so that applications run with the correct user interface depending on which operating system they are running on.</p>
<p>
Developers can build one Win32-based executable file using MFC. The application will look and act like a Windows 3.1-based application when run on Windows 3.1 or on Windows NT on an Intel processor.</p>
<p>
<img src="mfc4tech_3.gif" border=0></p>
<p class=label>
<b>Figure 3. Scribble demo on Windows NT</b></p>
<p>
When the same executable file runs under Windows 95, the application will look and act like a Windows 95-based application.</p>
<p>
<img src="mfc4tech_4.gif" border=0></p>
<p class=label>
<b>Figure 4. Scribble demo on Windows 95</b></p>
<p>
Splitter windows, toolbars, status bars, and miniframe windows all have a markedly different look when running on Windows 95. Also, <b>CScrollView</b>-derived classes automatically take advantage of proportional scroll thumbs, if available. In addition, the property page classes were modeled after the Windows 95 user interface.</p>
<h3>Support for Win32</h3>
<p>
MFC continues to play its role as the C++ API to Windows. MFC 3.0 provided expanded and improved encapsulation of some of the Win32 services. Member functions in existing classes improved the Win32 API coverage. Classes support writing multithread applications, Unicode, or Double-Byte Character Sets (DBCS) applications using MFC as a shared DLL. MFC 3.0 also included extended coverage of the Win32 API, including GDI functionality such as Béziers, Paths, and a number of other Win32 USER APIs.</p>
<h3>Multithreading</h3>
<p>
MFC is thread-safe and supports writing multithread MFC applications. Threads of execution are encapsulated in the class <b>CWinThread</b>. The main application class, <b>CWinApp</b>, is derived from <b>CWinThread</b>; it represents the main user-interface thread of the application.</p>
<p>
MFC distinguishes two types of threads: user-interface threads and worker threads. User-interface threads are commonly used to handle user input and respond to events and messages generated by the user. Worker threads are commonly used to complete tasks that do not require user input, such as recalculation. MFC handles user-interface threads specially by supplying a message pump for events in the user interface. <b>CWinApp</b> is an example of a user-interface thread object, because it derives from <b>CWinThread</b> and handles events and messages generated by the user.</p>
<p>
Developers can create additional threads in their applications if they wish, creating new objects of the class <b>CWinThread</b> or a class derived from <b>CWinThread</b>. In most situations, the developer doesn't even have to create these objects explicitly and can instead call the framework helper function <b>AfxBeginThread</b>, which creates the <b>CWinThread</b> object.</p>
<p>
Of course, even with the multithread enabling of MFC, writing and debugging multithread applications is an inherently complicated and tricky undertaking, because the developer must ensure that a given object is not accessed by more than one thread at a time.</p>
<h3>Unicode Support</h3>
<p>
Some international markets use languages that have large character sets, such as Japanese and Chinese. To support programming for these markets, the MFC library is enabled for two approaches to handling large character sets, Unicode and Double-Byte Character Sets (DBCS).</p>
<p>
DBCS is supported on all platforms. Unicode is supported on all Windows NT platforms. The MFC library is designed to support either option. A special version of the MFC library must be linked in when building a Unicode application.</p>
<p>
MFC is provided in a version that directly supports Unicode characters and strings. In particular, class <b>CString</b> is Unicode-enabled. <b>CString</b> is based on the <b>TCHAR</b> data type. If the symbol _UNICODE is defined for a build of the program, <b>TCHAR</b> is defined as type <b>wchar_t</b>, a 16-bit character-encoding type; otherwise, it is defined as type <b>char</b>, the normal 8-bit character encoding. As a result, under Unicode, <b>CStrings</b> are composed of 16-bit characters; without Unicode, they are composed of characters of type <b>char</b>. <b>CString</b> also supplies Unicode-aware constructors, assignment operators, and comparison operators.</p>
<p>
If Unicode is not specified, the class library defaults to supporting the ANSI character set, with support specifically for DBCS. Under the DBCS scheme, a character can be either one or two bytes wide. If it is two bytes wide, its first byte is a special "lead" byte, chosen from a particular range depending on which code page is in use. Taken together, the lead and "trail" bytes specify a unique character encoding. </p>
<p>
In either case, CString conversion operators and constructors make it easy to convert ANSI and Unicode strings to a <b>CString</b> object, in the case that program deals with both ANSI and Unicode characters.</p>
<p>
Note that <b>Unicode</b> string serialization in MFC can read both Unicode and DBCS strings, regardless of which version of the application is running. Because of this, data files are portable between Unicode and DBCS versions of the program.</p>
<h3>Shared 32-Bit DLLs</h3>
<p>
MFC provides all the application framework in a shared DLL form. MFC 2.0 introduced the shared DLL feature and provided a single DLL for all the MFC features (MFC200.DLL). This feature was continued with MFC 2.5 (MFC*250.DLL). However, this shared DLL was available only on the 16-bit Windows platform.</p>
<p>
For MFC 3.0, the functionality was factored into three 32-bit DLLs: one for the core features (MFC30.DLL), one for the OLE 2-specific support (MFCO30.DLL), and one for the database-specific support (MFCD30.DLL). All three DLLs are available in two forms: a freely redistributable retail version and a debugging version.</p>
<p>
MFC 4.0 combines all of these DLLs into one unified DLL for simplified distribution. For increased performance, advanced page-tuning techniques reduce overhead for applications that don't use all MFC features.</p>
<p>
The benefits of this shared DLL implementation to the programmer are significant. Now, several MFC applications can share framework code if they are running simultaneously, thus reducing system-resource usage. Also, executable files are much smaller than static-link versions of the same applications, although the size of the DLL must be included for a true measurement.</p>
<h3>Language Syntax Support</h3>
<p>
MFC takes advantage of new C++ language features such as C++ templates and exceptions. Version 1.0 of MFC was designed at the time these C++ language features were still under development, so additional tools and macros were needed. Today, with MFC 4.0 and direct compiler support for these language features, the benefits of the original design are visible.</p>
<p>
With MFC 4.0, there is no need to use <b>TEMPLDEF</b> or the <b>TRY</b>, <b>CATCH</b>, and <b>THROW</b> exception macros. True C++ syntax for templates and MFC "templatized" collections are supported. C++ exceptions are supported for both new and old code, so objects on the stack will always be destroyed when exceptions are thrown. For backward compatibility, the old ways (prior to MFC 4.0) of doing things are still supported.</p>
<h4>C++ templates</h4>
<p>
MFC provides collection classes based on C++ templates, which makes it easier to derive one's own type-safe collection classes. MFC 3.0 provided two types of collection classes to manage groups of objects: collection classes that are created from C++ templates; and Collection classes that are not created from templates.</p>
<p>
The nontemplate collection classes are the same as those provided by MFC in versions 1.0 and later. Developers whose code already uses these classes can continue to use them. Developers who write new type-safe collection classes for their own data types should consider using the newer template-based classes.</p>
<p>
A collection class is characterized by its <i>shape</i> and by the types of its elements. The shape refers to the way the objects are organized and stored by the collection. MFC provides three basic collection shapes: lists, arrays, and maps (also known as dictionaries), which provide easy-to-understand yet powerful building blocks for the rest of the application. Developers can pick the collection shape most suited to their particular programming problems:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=12%><b>Shape</b></td>
<td class=label width=88%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=12%><b>List</b></td>
<td width=88%>The list class provides an ordered, nonindexed list of elements, implemented as a doubly linked list. A list has a "head" and a "tail," and adding or removing elements from the head or tail, or inserting or deleting elements in the middle, is very fast.</td>
</tr>
<tr valign=top>
<td width=12%><b>Array</b></td>
<td width=88%>The array class provides a dynamically sized, ordered, and integer-indexed array of objects.</td>
</tr>
<tr valign=top>
<td width=12%><b>Map</b></td>
<td width=88%>A map is a collection that associates a key object with a value object.</td>
</tr>
</table><br>
<p>
The easiest way to implement a type-safe collection that contains objects of any type is to use one of the MFC template-based classes. </p>
<table border=1 cellpadding=5 cols=7 frame=below rules=rows>
<tr valign=top>
<td class=label width=45%><b>Collection contents</b></td>
<td class=label width=18%><b>Arrays</b></td>
<td class=label colspan=2 width=17%><b>Lists</b></td>
<td class=label colspan=2 width=18%><b>Maps</b></td>
</tr>
<tr valign=top>
<td width=45%><b>Collections of objects of any type</b></td>
<td width=18%>CArray</td>
<td colspan=2 width=17%>CList</td>
<td colspan=2 width=18%>CMap</td>
</tr>
<tr valign=top>
<td width=45%><b>Collections of pointers to objects of any type</b></td>
<td colspan=2 width=19%>CTypedPtrArray</td>
<td colspan=2 width=18%>CTypedPtrList</td>
<td colspan=2 width=18%>CTypedPtrMap</td>
</tr>
</table><br>
<p>
For example, to create a dynamically sized array of "doubles," use C++ template syntax:</p>
<p>
CArray&lt;double, double&gt; myArray;</p>
<p>
If the application already uses MFC nontemplate classes, developers can continue to use them, but they should consider using the template-based classes for new collections.</p>
<h4>C++ exceptions</h4>
<p>
In MFC, exceptions are used to signal abnormal execution, including situations in which conditions outside the program's control are influencing the outcome of the function, such as low memory or I/O errors. Abnormal situations are handled by catching and throwing exceptions, rather than by using return codes that are often overlooked and so result in inefficient code. The exception syntax is a clean and efficient mechanism for abnormal conditions.</p>
<p>
MFC provides two compatible ways of using exceptions: the C++ exceptions, available starting with MFC version 3.0; and the MFC exception macros, available starting with MFC version 1.0.</p>
<p>
Developers writing new applications using MFC should use the C++ exceptions mechanism. The macro-based mechanism can be used if the existing application already uses that mechanism extensively. Existing codes can be converted readily to use C++ exceptions instead of the MFC exception macros, if desired.</p>
<p>
If an application has already been developed using the MFC exception macros, the developer can continue to use the MFC exception macros in the existing code, while using C++ exceptions in new code.</p>
<p>
Whether they use the C++ exceptions directly or use the MFC exception macros, developers will use <b>CException</b> or <b>CException</b>-derived objects that may be thrown by the framework or by the application. MFC provides several predefined exception classes to handle everything from out-of-memory to OLE dispatch exceptions.</p>
<h3>Database Classes</h3>
<p>
Visual C++ provides integrated support in AppWizard, ClassWizard, and the Visual C++ dialog editor for building database applications. In version 3.0, MFC provided database engine functionality. Also, a new mechanism was provided to enable data-bound controls using ClassWizard, which makes it easy for the developer to build forms that view and edit fields in a database without having to write any C++ code.</p>
<p>
These database classes provide easy access to any database for which an ODBC driver is available. Also provided with Visual C++ are portions of the ODBC SDK, the ODBC driver manager, and a new set of drivers.</p>
<h4>Database engine classes</h4>
<p>
In addition to the new DAO classes, there are two main classes that provide the encapsulation of ODBC data sources: <b>CDatabase</b> and <b>CRecordset</b>. These classes are modeled after the high-level database abstractions used in the Visual Basic programming system and the Microsoft Access database management system. The MFC versions of these abstractions are provided as type-safe C++ classes that allow programmers to access data in an easy and comfortable way, without requiring them to give up the performance and compile-time checking that C++ provides.</p>
<p>
The class <b>CDatabase</b> represents a connection to a data source through which developers can operate on the data source. The database engine classes are smart enough to allocate and open a new <b>CDatabase</b> connection as needed by the program. Developers who want to manage their database connections manually, or to optimize performance or control transactions, will want to use the <b>CDatabase</b> class.</p>
<p>
The class <b>CRecordset</b> encapsulates a set of records selected from a data source. Recordsets enable scrolling from record to record, updating of records (adding, editing, and deleting records), qualifying the selection with a filter, sorting the selection, and "parameterizing" the selection with information obtained or calculated at run time.</p>
<p>
Programmers will normally derive their own custom classes from <b>CRecordset</b> to add type-safe member variables to the class that will be bound to specific columns of a data source. The process of creating a new C++ class and managing the binding of columns to member variables is performed by ClassWizard. The process of moving data between the database and the member variables of the class is called <i>record field exchange</i> (RFX). This technique is similar to the dialog data exchange (DDX) mechanism introduced in MFC 2.0 (see below).</p>
<p>
Data values obtained from an ODBC data source are turned into C++ and MFC data types such as short, long, float and <b>CString</b>. For large binary data, a class <b>CLongBinary</b> is provided for efficient management of large data values.</p>
<h4>Record view</h4>
<p>
One of the most common types of Windows-based applications is form processing. A form is like a dialog box that the user can interact with to fill in edit controls, select options from list boxes and radio groups, and work with other dialog box controls. For example, an order/entry database application would probably use forms to allow customer service representatives to enter order information. </p>
<p>
MFC 2.0 introduced the high-level abstraction of a form view. MFC 3.0 included a class called <b>CRecordView</b>, derived from <b>CFormView</b>, that provides a form directly connected to a recordset object.</p>
<p>
Using the same mechanism as for dialog boxes and simple form views, a record view uses the MFC DDX mechanism to exchange data values between the recordset and the controls of the record view. Like all form views, a record view is based on a dialog template resource. Record views also support moving from record to record in the recordset, updating records, and closing the associated recordset when the record view closes.</p>
<p>
Like any form view, a record view automatically supports many features, such as scrolling, synchronous update, support for VBX custom controls, support for standard Windows controls, and the ability to place a form view in any window, including MDI child windows.</p>
<h3>OLE Classes</h3>
<p>
OLE provides many attractive features to the end user of OLE-capable applications. For the developer, OLE provides a lot of functionality in many APIs but adds the burden of many design decisions and a lot of implementation work.</p>
<p>
The MFC support for OLE provides C++ classes integrated with the MFC framework that make developing OLE-capable applications easy. AppWizard has been extended to make it easy to start developing OLE applications. ClassWizard has been extended to make it easier to support OLE Automation in programs.</p>
<p>
The MFC support for OLE encapsulates much of the complexity of the OLE API in a small set of C++ classes that provide a higher-level interface to OLE. Of course, following the MFC design philosophy, developers can call the underlying C-language OLE API functions directly wherever the OLE classes don't meet their needs.</p>
<p>
Also provided with Visual C++ is the OLE 2.0 SDK, as well as a number of tools and sample applications to help developers test their OLE applications. Online documentation includes overview material, tutorials, an encyclopedia, and a class reference.</p>
<p>
This paper divides the features of OLE into two main categories: features for supporting OLE visual editing and features for OLE Automation. The development work involved depends on whether the application will provide these services (as an OLE <i>server</i>), or whether it will use or consume these services (as an OLE <i>client</i> or a <i>container</i>).</p>
<h2>OLE Overview</h2>
<p>
OLE is a mechanism that allows users to create and edit documents containing data created by multiple applications. OLE documents seamlessly integrate various types of data, called <i>items</i>. Sound clips, spreadsheets, and bitmaps are typical examples of items found in OLE documents. Supporting OLE in an application allows the user to work with OLE documents without worrying about switching back and forth between the different applications; OLE does the switching.</p>
<p>
A container application is used to create OLE documents, and a server application is used to create the items within the container application. Any application may be a container, a server, or both.</p>
<p>
OLE incorporates many concepts that all work toward the goal of seamless interaction between applications. These areas include the following:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=26%><b>Feature</b></td>
<td class=label width=74%><b>Definition</b></td>
</tr>
<tr valign=top>
<td width=26%>Linking and embedding</td>
<td width=74%>Linking and embedding are used for storing items inside an OLE document that were created in another application. </td>
</tr>
<tr valign=top>
<td width=26%>In-place activation</td>
<td width=74%>Activating an embedded or linked item in the context of the container application is called in-place activation. The interface of the container application changes to incorporate the features of the application that created the embedded or linked item. </td>
</tr>
<tr valign=top>
<td width=26%>Uniform data transfer</td>
<td width=74%>Uniform data transfer (UDT) is a set of interfaces that allows data to be sent and received in a standard fashion, regardless of the actual method chosen to transfer the data. UDT forms the basis for data transfers using the Clipboard and drag and drop.</td>
</tr>
<tr valign=top>
<td width=26%>Drag and drop</td>
<td width=74%>Drag and drop is an easy-to-use, direct-manipulation technique to transfer data between applications, between windows within an application, or even within a single window in an application. The data to be transferred is simply selected and dragged to the desired destination.</td>
</tr>
<tr valign=top>
<td width=26%>Compound files</td>
<td width=74%>Compound files provide a standard file format that simplifies structured storing of OLE documents for OLE applications. Within a compound file, "storages" have many features of directories, and "streams" have many features of files. </td>
</tr>
<tr valign=top>
<td width=26%>OLE Automation</td>
<td width=74%>OLE Automation allows one application to drive another application. The driving application is known as an automation client, and the application being driven is known as an automation server. </td>
</tr>
<tr valign=top>
<td width=26%>OLE Component Object Model</td>
<td width=74%>The OLE Component Object Model (COM) provides the infrastructure used when OLE objects communicate with each other. The Microsoft Foundation Class Library OLE classes simplify OLE COM for the programmer.</td>
</tr>
</table><br>
<h3>Visual Editing</h3>
<p>
Support for visual editing includes in-place activation and editing, drag and drop, and OLE document (structured) storage. Two sets of MFC classes support visual editing. One set of classes is designed to help developers build OLE servers, the software components that can be embedded or linked inside other applications. This server support lets developers visually export the components in their applications. The other set of classes is designed to help developers build OLE containers that allow the components from other applications to be visually embedded or linked in OLE documents.</p>
<h3>Visual Editing Servers</h3>
<p>
A visual editing server application can create OLE items for use by other applications that have the appropriate OLE support to contain these items (for information on container applications, see the following section, "Visual Editing Containers"). Server applications usually support copying their data to the Clipboard or by drag and drop so that container applications can paste the data as an embedded or linked item.</p>
<p>
A <i>miniserver</i> is a special type of server application that can be launched only by a container. The Microsoft Draw and Microsoft Graph servers are examples of miniservers. A miniserver does not store its own data as files on disk; instead, it reads its documents from and writes them to items in documents belonging to containers. As a result, a miniserver can only support embedding, not linking. </p>
<p>
A <i>full-server</i> can either be run as a stand-alone application or launched by a container application. A full-server can store documents as files on disk. It can support embedding only, both embedding and linking, or only linking. The user of a container application creates an embedded item by choosing the Cut or Copy command in the server and the Paste command in the container. A linked item is created by choosing the Copy command in the server and the Paste Link command in the container. </p>
<p>
When a server application is launched by a container application and is in place, MFC handles all of the toolbar and menu negotiation to allow the server's menus and toolbar to display in place of the menus and toolbar of the container. Even advanced user-interface features such as docking toolbars are supported when a server is in-place activated; in this case, the toolbars are docked to the container's frame window. MFC handles all the negotiation with the container for the tool space, including showing correct feedback when the toolbar is being dragged.</p>
<h3>Visual Editing Containers</h3>
<p>
A visual editing container application can incorporate embedded or linked items into its own documents. The documents managed by a container application must be able to store and display OLE items as well as the data created by the application itself. A container application allows users to insert new items or edit existing items by activating server applications when needed.</p>
<p>
Container applications will launch and contain a server application. Communication between containers and servers is achieved through the OLE system DLLs. These OLE system DLLs provide functions that containers and servers call, and the containers and servers provide call-back functions that the DLLs call. Using this means of communication, a container doesn't need to know the implementation details of the server application. A container can accept items created by any server without having to define the types of servers with which the container can work. As a result, the user of a container application can take advantage of future applications and data formats. As long as these new applications are OLE servers, an OLE document will be able to incorporate items created by those applications.</p>
<h3>Drag and Drop</h3>
<p>
Drag and drop is an easy-to-use, direct-manipulation technique to transfer data between applications, between windows within an application, or even within a single window in an application. The data to be transferred is simply selected and dragged to the desired destination. One application provides the data for copying, and another application accepts the data for pasting. Each side of the transfer needs to perform different operations on the data for the transfer to succeed. The MFC library provides full support to represent each side of this transfer.</p>
<p>
Data sources represent the source side of the data transfer. They are created by the source application when data is provided for a drag-and-drop operation. Data objects represent the destination side of the data transfer. They are created when the destination application has data dropped into it.</p>
<h3>Compound Files (Structured Storage)</h3>
<p>
Compound files are an integral part of OLE. They are used to facilitate data transfer and OLE-document storage. Compound files are an implementation of the structured-storage model.</p>
<p>
MFC supports using both compound files and normal flat files for an application's file storage. The code the developer writes is the same. Using the <b>CArchive</b> abstraction, MFC is able to hide the differences between these two file formats while offering the benefits of each. These benefits include support for serialization to a storage (using the OLE <b>IStorage</b> interface), a stream (using the OLE <b>IStream</b> interface), or a normal or flat file where the developer has complete control over the file format.</p>
<h3>OLE Automation Servers</h3>
<p>
An OLE Automation server exposes programmable software components, along with their properties and methods, to other applications. These driving applications are called OLE Automation clients. Exposing objects in this way is beneficial when applications provide functionality that is useful for other applications. For example, a word processor might expose its spelling-check functionality so that other programs can use it. Exposure of objects enables vendors to improve the functionality of their applications by using the ready-made functionality of other applications. </p>
<p>
ClassWizard, AppWizard, and the framework all provide extensive support for OLE Automation servers. They handle much of the overhead involved in creating an OLE Automation server so that developers can focus their efforts on the functionality of their applications.</p>
<p>
MFC, along with ClassWizard support, makes it extremely easy to expose member variables and member functions from type-safe C++ classes as OLE Automation properties and methods. This allows an application's objects to be driven by an external macro language such as Visual Basic.</p>
<p>
MFC provides direct support for creating type libraries. Type libraries are useful for exporting OLE Automation servers to other C++ client applications. The new AppWizard will automatically create an .ODL file, and ClassWizard will automatically maintain the .ODL source file used to create the type library.</p>
<h3>OLE Automation Clients</h3>
<p>
An OLE Automation client manipulates components implemented in other applications. The application being manipulated, which is the OLE Automation server, exposes programmable components and allows clients to automate certain procedures by directly accessing the server components, along with their properties and methods.</p>
<p>
By creating an OLE Automation client, MFC makes it easy to drive other applications, allowing developers to build an application using C++ language to drive the objects exposed by large applications such as Microsoft Excel, Microsoft Word, or any other OLE Automation server that has a type library.</p>
<p>
ClassWizard reads the type library provided by the OLE Automation server and creates new custom C++ classes for the <b>IDispatch</b> interfaces exposed by that server. MFC provides the glue to connect these dynamic OLE (<b>IDispatch</b>) interfaces into type-safe C++ classes. Therefore, most OLE Automation clients written in C++ do not have to deal with the dynamic nature of <b>IDispatch</b>. </p>
<h3>OLE Controls</h3>
<p>
The OLE control architecture merges the popular VBX custom control architecture with the open, standard architecture of OLE. OLE controls make component-based development a reality by allowing developers to easily use existing bodies of functional code encapsulated as OLE controls. An OLE control is a custom control, implemented as an OLE object with visual editing and OLE Automation support. An OLE control has additional capabilities beyond those of ordinary OLE components, such as the ability to fire events. With MFC 4.0, containment of OLE controls is supported by using <b>AfxEnableControlContainer</b>.</p>
<p>
Most OLE objects require a substantial amount of implementation effort. Fortunately, the OLE Control Development Kit (CDK)—built into Visual C++ 4.0—provides most of the required implementation, so developers only have to fill in details that are specific to the OLE control. The OLE control CDK classes themselves are based on MFC base classes (that is, <b>COleControl</b> derives from <b>CWnd</b>). This makes it easier for developers who are experienced with MFC to create OLE controls. It also makes it easier to use existing MFC code inside the implementation of new OLE controls.</p>
<p>
MFC includes support for creating and using 32-bit OLE controls. MFC, along with the newly merged CDK, provides support for creating, testing, and using OLE controls, including hundreds available from third parties.</p>
<h2>MFC Architecture Classes</h2>
<p>
A key benefit of an application framework is that it not only provides a large body of prebuilt functionality but offers an architecture in which to add new functionality. An elegant architecture gives developers a logical and obvious location to add application-specific code when implementing features in their applications. For example, when developers are implementing the File Save command, the application framework should have an obvious technique (such as a member function or a hook) to add this functionality. It is not enough, however, to point programmers to the right place, because there is often no single right place, or the application framework may not foresee the exact situation. MFC addresses these issues with a group of tightly integrated classes collectively known as the <i>application architecture classes</i>. These classes provide support for the important areas common to many parts of the application, such as commands, documents, views, printing, online help, and dialog processing.</p>
<h3>Commands</h3>
<p>
Menu items, keyboard accelerators, and toolbar buttons are the most common sources of commands in an application. A <i>command</i> is an instruction to the program to perform a certain action. Unlike a procedure or function call, a command is a message that is routed to various command targets<i> </i>that may carry out the instruction. Command <i>targets</i> are objects derived from the <b>CCmdTarget</b> class, and they include documents, views, windows, and the application itself.</p>
<p>
The command architecture ensures that any user-interface action, such as clicking a toolbar button or selecting a menu item, will route the command to the appropriate handler. Command routing can also be used to update the visual state of menu items or toolbar buttons. For example, the Edit Cut command might have both a menu item and a toolbar button that can be enabled or disabled. Using the command architecture, it is easy to maintain the visually enabled or disabled state of both the menu item and the toolbar button with a single line of code in a single location.</p>
<p>
Another integral part of the MFC architecture are message maps, which were introduced in MFC 1.0 and were extended in MFC 2.0 and MFC 3.0. A message map provides a type-safe mechanism for directing any windows message, control notification, or command to a C++ member function in the appropriate class. Each command target has a message map, and it contains entries that map each command ID defined in the Visual C++ resource editor to a C++ member function. Because there can be a large number of commands (as well as Windows-based messages and notifications) handled by each command target, ClassWizard is usually used to create classes and to maintain a class's message maps and message-handler functions.</p>
<p>
MFC 3.0 extended the use of the command-handling architecture to support OLE Automation. Any class derived from <b>CCmdTarget</b> can expose member variables and member functions as OLE Automation properties and methods. MFC 3.0 also included macros to make it easier to handle ranges of command IDs, a commonly requested feature.</p>
<p>
MFC provides support for extended control notifications (WM_NOTIFY), routed just like any other command. This support is included for new services that are exploited in the release of future operating systems, and it is another example of MFC being on the leading edge of support for new operating systems.</p>
<h3>Documents and Views </h3>
<p>
The document/view architecture introduced in MFC 2.0 is the basis for managing the storage and display of application-specific data. The <b>CDocument</b> class provides support for managing an application's data, and an application will typically derive a new class from <b>CDocument</b> for each document type. The key feature of a document class is its ability to save a document object to a file for later use. The programmer's responsibility is to override the <b>Serialize</b> member function, which saves and loads application-specific data to and from storage. By implementing this function, MFC automatically supports high-level commands such as File New, File Save, File Save As, and File Open. MFC does all the work of displaying a dialog box to gather information from the user and managing the disk file. Although most documents are typically associated with disk files, the <b>CDocument</b> architecture is flexible enough to allow manipulation of data stored in other ways, such as in a database file, or to allow manipulation of data without any kind of stored representation. AppWizard provides several options for the initial skeleton of an application that incorporate database functionality in a variety of ways. </p>
<p>
Each document in a running application is attached to one or more views of that document. Views control the graphical display of the application's data on the screen. Programmers typically derive a class from the MFC <b>CView</b> class and then implement the display code. A view represents the main area of a window on the screen and is a simple child window that can be manipulated with <b>CWnd</b> member functions. This usually involves implementing the <b>OnDraw</b> member function and writing the code that displays the data that is currently visible to the user. The <b>OnDraw</b> function replaces the low-level <b>OnPaint</b> handler of MFC 1.0 with a high-level abstraction. After implementing <b>OnDraw</b>, the program automatically supports printing and print preview. The <b>CView</b>-derived class is usually the best place to handle most of the commands and window messages that graphically manipulate the data. To support high throughput and fast updates, a number of APIs enable optimization of the drawing process to support most professional applications. It is also easy to have many views on the same document, and each view can be a different <b>CView</b>-derived class. For example, a splitter window will have one view for each pane.</p>
<p>
To coordinate documents and views, MFC uses the helper class <b>CDocTemplate</b>. This class orchestrates the creation of documents, views, and frame windows in response to user input. One document-template object is created for each document type and is the glue that connects the document and view types. The application object maintains the document templates. Two document-template classes are supplied: one for multiple-document interface (MDI) and one for single-document interface (SDI). The significant differences between an MDI and SDI user-interface model are encapsulated in the document template and frame window classes.</p>
<h3>Printing and Print Preview</h3>
<p>
By leveraging the document/view architecture, MFC is able to provide an application with device-independent printing. This means that the same code written for <b>OnDraw</b> in the <b>CView</b>-derived class can be used to draw on the screen and on the printer. When the user asks to print a document using the standard File Print command, MFC calls the <b>OnDraw</b> member function with a special device context that is aware of the current printer and knows how to translate the screen display into appropriate printed output. MFC also provides support for all the standard printing user-interface dialog boxes.</p>
<p>
In combination with the printing and document/view architectures, MFC supports print preview functionality, which shows a reduced image of either one or two pages of a document as they would appear when printed on the currently selected printer. The implementation provides the standard user interface for navigating between pages, toggling between one- and two-page viewing, and zooming the display in and out to different levels of magnification. The ability to support print preview is an excellent example of the level of prebuilt functionality and the high level of abstraction in MFC. The print preview feature represents several thousand lines of code in the application framework, but programmers only need to handle the display output code in the <b>OnDraw</b> member function of class <b>CView</b> and make sure that the File Print Preview menu command is available—the framework does the rest. </p>
<h3>Dialog Data Exchange and Validation (DDX/DDV)</h3>
<p>
The capability known as <i>dialog data exchange</i> (DDX) introduced in MFC 2.0 provides an easy way to initialize the controls in a dialog box and gather input from the user. An associated mechanism known as <i>dialog data validation</i> (DDV) provides validation of the dialog data. The heart of the DDX/DDV feature is the <b>DoDataExchange</b> member function, which is called automatically by the application framework when data must be transferred and/or validated.</p>
<p>
Because there are so many possibilities for exchange and validation (for example, the use of custom controls or the need for application-specific validation schemes), Microsoft made the DDX/DDV architecture fully extensible. Developers can supply their own DDX and DDV functions and integrate them seamlessly with MFC.</p>
<p>
In MFC 2.0, this mechanism was used primarily for dialogs. Now, the DDX mechanism has been extended to work with data-bound record views as well as with normal dialogs and simple form views. The DDX/DDV architecture is tightly integrated with ClassWizard, which enables developers to define all the necessary member variables and DDX/DDV routines without having to write any code.</p>
<h3>Context-Sensitive Help </h3>
<p>
Support for online and context-sensitive documentation is essential for most applications. MFC provides an architecture that makes it easy to incorporate the two most common types of help support in Windows-based applications. Help support includes a Help menu with the standard commands and provides an architecture for the application framework to map from command or resource IDs to the various help contexts. Help contexts are easily created in Visual C++, because every time a user-interface element is created in the Visual C++ resource editor, a help context for that element is automatically created. Help files (.HLP) are authored using standard authoring tools.</p>
<p>
When a user presses the F1 key, MFC automatically processes the keystroke as a help request for the current command target. For example, the <b>CDialog</b> class processes the help request by invoking WinHelp on the help topic for the currently displayed dialog box. If no help context is defined for the current command target, then the application framework automatically launches the default help. The <b>CFrameWnd</b>, <b>CMDIFrameWnd</b> and <b>CDialog</b> classes all provide handler functions for help support. Developers can add support to any class that is a command target.</p>
<p>
When a user presses SHIFT+F1, MFC captures the mouse and changes the cursor into the standard context-sensitive help cursor (arrow + question mark). When this cursor is displayed, clicking a user-interface object tells the application framework to invoke WinHelp with the correct help context based on the selected object. </p>
<p>
MFC provides a tool to manage the help-context information, which associates user-interface elements with help contexts. In addition, AppWizard provides much of the standard WinHelp-format file with prewritten information on all of the standard commands. All that is needed is an editor capable of editing Rich Text Format (RTF) text, such as Microsoft Word, to add application-specific information. In this way, MFC, AppWizard, and the Visual C++ development environment work together to provide programmers most of their applications' help features automatically.</p>
<h2>High-Level Abstractions</h2>
<p>
MFC 1.0 was the cornerstone of a robust framework for building reusable classes, but it did not provide enough high-level abstractions to reduce programming time. With MFC 2.0 and later, this issue is addressed with a set of classes that support the most common user-interface idioms and provide capabilities for taking advantage of other prebuilt functionality. These classes, collectively called <i>high-level abstractions</i>, are designed to be used as supplied by MFC and can result in a dramatic reduction in programming time. In a few lines of code, programmers can build a text-processing window that integrates seamlessly with other MDI windows, or they can change the base class to turn a view into a scrolling view. In addition to this power, all of these high-level classes are designed to be easily modified using C++ inheritance.</p>
<h3>Form View</h3>
<p>
The functionality of <b>CRecordView</b> is built upon the <b>CFormView</b> high-level abstraction introduced in MFC 2.0. <b>CFormView</b> supports many features that true form-processing applications require but which are not available in the native Windows dialog manager, such as scrolling, multiple forms for the same data, synchronous update, and printing.</p>
<p>
A <b>CFormView</b> provides a view (a class derived from <b>CView</b>) based on a dialog resource that can be edited with the Visual C++ dialog editor. This view can be used to create form views with arbitrary Windows controls. The user can scroll the form view and tab among controls. The benefit of <b>CFormView</b> over standard dialogs is that <b>CFormView</b> objects integrate with the entire application framework architecture, providing automatic support for command handling and document management. A form view can also be an MDI child window.</p>
<h3>EditView</h3>
<p>
<b>CEditView</b> is a simple, plain-text-editor view that has all the functionality of the standard Windows edit control. In addition, however, <b>CEditView</b> supports high-level functionality such as printing, find and replace, cut, copy, paste, and undo, as well as the standard File commands (Open, Save, and Save As). Of course, because <b>CEditView</b> is derived from <b>CView</b>, all of the architectural benefits described above apply. From a simple AppWizard-created application, programmers can use <b>CEditView</b> by simply creating a document template that uses <b>CEditView</b>; applications can have an MDI text editor without the programmers having to derive their own view classes.</p>
<h3>Scrolling View</h3>
<p>
Most applications can show only a portion of their data files on the screen at a single time. The <b>CScrollView</b> class, which is another high-level view class derived from <b>CView</b>, supports views that scroll and views that are automatically scaled to the size of the frame window that displays them. By deriving from <b>CScrollView</b>, developers can add the ability to scroll or scale to their view classes. <b>CScrollView</b> manages window sizes and mapping mode for graphics, manages special modes needed for OLE in-place editing, and handles the automatic scrolling in response to user-interface actions such as clicking the scroll bar.</p>
<h3>Splitter Window</h3>
<p>
In a splitter window, the window can be split into two or more separately scrollable panes. A splitter control in the window frame next to the scroll bars allows the user to adjust the relative sizes of the panes. Each pane is a different view on the same document. This type of user interface is useful, for example, when a user wishes to view both the beginning and end of a very long document on a single screen. MFC provides the high-level class <b>CSplitterWnd</b> to support this user-interface model. The <b>CSplitterWnd</b> class also supports the two most common types of splitters: dynamic and static. With dynamic splitters, the user can add or remove arbitrary split panes; static splitters have a predefined number of panes. Each of the splitter pane's views can be the same class, or each can be a different derived <b>CView</b> class. In all cases, the application framework automatically manages all aspects of the user interface and standard Windows messages.</p>
<h3>Control Bars</h3>
<p>
<b>CToolBar</b>, <b>CStatusBar</b>, and <b>CDialogBar</b> all derive from the common base class <b>CControlBar</b>. The <b>CControlBar</b> abstraction enables the MFC implementation to reuse code among these classes. <b>CControlBar</b> provides the functionality for automatic layout within the parent frame window of the derived classes. <b>CControlBar</b> demonstrates the power of a base class that provides a partial implementation that is completed in a series of closely related derived classes.</p>
<p>
The <b>CStatusBar</b> class implements a row of text-output panes, or indicators. The output panes are commonly used as message lines and status indicators. Examples include the menu help-message lines that briefly describe the selected menu command and the indicators for the keyboard states of Num Lock, Scroll Lock, and Caps Lock. The <b>CStatusBar</b> class supports any number of panes and automatically lays them out based on the width of the contents. Each pane can have a customized style, including three-dimensional borders, pop-out text, disabled, and stretchy. The MFC command architecture supports automatic menu prompt strings, and when using the Visual C++ menu editor to edit menus for MFC applications, programmers can also define the prompt string for the menu item. When creating a new application with AppWizard, developers can specify whether or not the application will provide a status bar.</p>
<p>
The <b>CDialogBar</b> class is like a modeless dialog in that it easily supports any combination of Windows controls and is created from a dialog template edited with the Visual C++ dialog editor. Dialog bars support tabbing among controls and can be aligned to the top, bottom, left, or right edge of the enclosing frame window. The most common example of a dialog bar is the print-preview user interface.</p>
<h2>Obsolete Features</h2>
<p>
With MFC's tradition of providing very good backward compatibility, most MFC 1.0, 2.0, 2.5 and 3.0 programs will work with MFC 4.0 with a few very minor modifications. Very few features of previous versions of MFC are no longer supported in MFC 4.0 or will not be supported in the future.</p>
<p>
Obsolete features are in technologies that are replaced by OLE technology.</p>
<h3>Support for OLE 1.0</h3>
<p>
MFC 1.0 and MFC 2.0 provided nine classes to support version 1.0 of OLE. These classes were obsolete with MFC 2.5 and have been replaced with the OLE 2.0 versions of these classes. Because OLE 2.0 is a functional superset of OLE 1.0 and provides many more features, writing OLE 1.0 applications is no longer recommended.</p>
<h3>VBX 1.0 Controls (16-Bit Only)</h3>
<p>
Microsoft Visual Basic introduced the concept of add-in components known as VBX controls. VBX control functionality is replaced by the new OLE controls model. MFC 4.0 provides support for creating, testing, and using OLE controls.</p>
<h2>Windows API Classes</h2>
<p>
MFC provides classes that simplify programming for Windows while at the same time permitting application developers to leverage both existing Windows-based code and programming experience. For the inexperienced programmer for Windows, the Microsoft Foundation Class Library simplifies Windows-based programming by providing prebuilt functionality for many standard programming idioms. These classes have evolved from the MFC 1.0 implementation, but backward compatibility has been maintained.</p>
<h3>Standard Application Support</h3>
<p>
MFC encapsulates the standard application structure in an easily customizable application object. In addition to standard initialization, message processing, and termination, the <b>CWinApp</b> class supports idle-time processing of user-defined operations. Additional features of the <b>CWinApp</b> class include support for profile settings, context-sensitive help, File Manager drag and drop, shell registration for launching the application from File Manager, and other user-interface features. The <b>CWinApp</b> class frees the programmer from the details of the WinMain, LibMain, and WEP routines and provides a standard abstraction across Windows platforms.</p>
<h3>Frame Windows</h3>
<p>
Along with an application object, most programs will use a standard frame window. MFC provides support for both the single-document interface (SDI) and the multiple-document interface (MDI). Many of the common MDI commands and user-interface functionality, such as changing the menu bar that is based on the active window, are provided as prebuilt functionality by the framework. In addition, error-prone areas of programming for Windows, such as keyboard accelerators and implementation of default behavior, are handled in a seamless manner by the application framework. Frame windows are managed by the document-template class in applications that take advantage of the document/view architecture. A view is contained within a frame window (usually a <b>CFrameWnd</b> or a <b>CMDIChildWnd</b>).</p>
<h3>Graphics/GDI</h3>
<p>
The MFC 1.0 device-context class, <b>CDC</b>, provided a simple Windows API wrapper. MFC 2.0 extended the <b>CDC</b> implementation to allow polymorphic implementations of device-context output functions. This enables a virtual-display context that allows MFC applications to use the same drawing code to send output to the screen, a printer, a metafile, or a print-preview view. MFC provides a complete set of classes for drawing graphical objects and managing device contexts. These graphical object classes include all of the standard Windows objects, including pens, brushes, bitmaps, fonts, regions, and palettes. Several device-context classes are also supplied to make the handling of common Windows idioms (such as window repainting) simpler and less error-prone. The graphical objects are designed to free system resources automatically when they are no longer needed, which simplifies common object-ownership problems and enables an application to run safely in a resource-constrained environment.</p>
<h3>Dialogs</h3>
<p>
MFC makes it easier to use dialogs within an application. The application framework manages many of the intricate details of Windows-based system-oriented dialogs automatically, including the handling of dialog-specific messages. Dialogs are handled with the <b>CDialog</b> class, which supports both modal and modeless dialogs. Programmers simply derive from a dialog class and customize it by overriding member functions and message handlers. This customization model is exactly like every other <b>CWnd</b>-derived class, which provides good programming consistency.</p>
<h3>Controls</h3>
<p>
Controls are windows that are drawn in the client area of frame windows or as controls in a dialog box. MFC provides classes for all of the standard controls: static text, buttons, edit control, list boxes, combo boxes, scroll bars, handwriting controls, and user-defined child windows. MFC makes it easy for developers to derive their own child windows (including deriving from the standard Windows controls) and to customize the behavior of the windows using C++ inheritance and message maps. MFC 4.0 adds classes that support Windows common controls. (See the section titled "Windows Common Control Classes" earlier in this document.)</p>
<h2>General-Purpose Classes</h2>
<p>
The general-purpose classes give programmers a wide range of functionality designed to take advantage of the powerful features of C++. These classes are available for programmers to develop the nongraphical portion of the application. In many respects, the general-purpose classes, together with the Windows API classes, are the building blocks for the entire application framework and provide fundamental functionality to those classes as well as programmer-defined classes. </p>
<h3>Run-Time Type Information</h3>
<p>
Most MFC classes are derived either directly or indirectly from the class <b>CObject</b>, which provides the most basic object-oriented features of the framework. <b>CObject</b> supports dynamic type checking, which allows the type of an object to be queried at run time. This feature provides programmers with a type-safe means to cast down a pointer from a base class to a derived class. Without dynamic type checking, this cast can be a source of errors and can break the type safety of C++. Most programmers find this feature useful, but because it incurs a very small run-time overhead (approximately 24 bytes per class), its use is optional.</p>
<h3>Object Persistence</h3>
<p>
<i>Persistence</i> is the ability of any object to save its state to a persistent<i> </i>storage medium, such as a disk. If a collection is made persistent, then all members of that collection are made persistent. The <b>CArchive</b> class is used to support object persistence and allows type-safe retrieval of object data. To use persistence, a class implementor must override the <b>Serialize</b> member function, call the base class' <b>Serialize</b> function, and then implement the data-storage routines for member data that is specific to a derived class. Entire networks of objects, with references to other objects, including both multiple and circular references, can be saved with a single line of code. As with dynamic type checking, the use of persistence is optional.</p>
<h3>Collection Classes</h3>
<p>
MFC excels in the efficiency of standard data structures. The provided collection classes, a standard component of any C++ class library, are well-tested, well-coded, and highly reusable. The MFC collection classes include double-linked list classes, map (dictionary) classes, and dynamic (growable) array classes. All of these have been implemented using the proposed ANSI template syntax for type-safe usage. For example, the list class is supplied with variants supporting <b>UINT</b>, <b>BYTE</b>, <b>WORD</b>, <b>DWORD</b>, <b>void*</b>, <b>CObject*</b>, and <b>CString</b> elements. The map and array classes have similar sets of variants. In all, MFC supplies 17 collection classes. For users who wish to take advantage of the template syntax to generate a type-safe variant of a supplied implementation (or write their own templates), a template-expansion tool written using MFC is provided as a sample application.</p>
<h3>Strings</h3>
<p>
The <b>CString</b> class supports a very fast string implementation that is compatible with standard C <b>char*</b> pointers. This class allows strings to be manipulated with syntax similar to the Basic language that includes concatenation operators and functions such as <b>Mid</b>, <b>Left</b>, and <b>Right</b>. <b>CString</b> also provides its own memory management, freeing the programmer from having to allocate and free string memory.</p>
<h3>Files</h3>
<p>
MFC offers three general-purpose file classes: <b>CFile</b> and its two derived classes, <b>CStdioFile</b> and <b>CMemFile</b>. <b>CFile</b> supports low-level binary file I/O (read, write, and seek). <b>CStdioFile</b> provides buffered file I/O similar to the standard I/O run-time libraries. <b>CMemFile</b> supports file semantics in RAM-resident files for managing Clipboard data as well as other forms of interapplication communication. The polymorphism provided by the three file classes (<b>CFile</b>, <b>CStdioFile</b>, and <b>CMemFile</b>) allows the same code to be used for sending data to a variety of destinations using the <b>CFile</b> interface. MFC 2.5 and MFC 4.0 extend the use of the file classes to include compatibility with OLE structure storage (<b>IStream</b> and <b>IStorage</b>).</p>
<h3>Time and Date</h3>
<p>
In addition to the standard time and date functions, a class is provided to conveniently support time-and-date arithmetic using overloaded operators. Binary time values are automatically formatted into human-readable form.</p>
<h3>Debugging and Diagnostic Support</h3>
<p>
An area overlooked by many class libraries is the inclusion of sophisticated diagnostic and debugging facilities. Incorporated directly into the fabric of MFC is a backbone of diagnostic code that is supported in the debug version of the framework. Applications written with MFC and compiled for debugging can be up to twice as large as their nondebug counterparts—an indication of the extensive diagnostic support within the application framework. </p>
<p>
Programmers can add debug code anywhere in an application that will print out all currently allocated heap objects. This capability is invaluable for the detection of serious memory leaks that are often impossible to track by other means. A <i>memory leak</i> is a slow depletion of system resources that can go undetected for several days until all resources are consumed. For all heap-allocated objects, a record is kept of the size, source file, and line number of the allocation. After a debug version of an MFC application terminates, the application framework automatically displays all heap objects that the programmer failed to free.</p>
<p>
Other debug support includes functions that are able to validate any pointer and determine if it refers to a genuine C++ <b>CObject</b>-derived object. The framework also provides run-time assertions and class invariants, which were popularized by the Eiffel programming language. Every class in MFC implements a member function that checks the current state of the object and causes a debug assert if the object is not in a proper state. Library member functions validate parameters to functions in the debug version of the framework.</p>
<p>
Each of the more than 6,000 <b>ASSERT</b> statements within the implementation of MFC checks the condition of the internal state of a class or parameters passed into an API. If a programmer erroneously causes the application framework to enter an unpredictable state, the application will immediately break into the debugger (if it is running), or an alerting message box will be displayed. <b>ASSERT</b> statements catch errors much earlier and can save hours of development time. All major Microsoft applications use assertion statements extensively. In the release (nondebug) version of an MFC application, <b>ASSERT</b> statements are not executed and generate no code (they are designed for testing purposes only), and thus they incur no cost to the application's end users. The <b>ASSERT</b> mechanism is provided for users of MFC as well, and programmers are encouraged to take advantage of it within their own code.</p>
<p>
MFC also provides <b>TRACE</b> statements, which are formatted information messages. As with <b>ASSERT</b> statements, <b>TRACE</b> statements are executed only in the debug version of an application. The <b>TRACE</b> statements in the application framework display possible misuse of a feature, low-memory conditions, rarely executed boundary conditions, and full message and command tracing. Because the output can be verbose (there are over 400 <b>TRACE</b> statements in MFC), it is easy to select which categories of messages are reported using the TRACER.EXE tool. For example, developers who are only interested in information about OLE can filter out all the other <b>TRACE</b> output. The <b>TRACE</b> facility can also be used by programmers within their own codes.</p>
</BODY>
</HTML>
