<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Visual C++/MFC Frequently Asked Questions</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="msdn_mfcfaq50"></a>Visual C++/MFC Frequently Asked Questions</h1>
<p>
Scot Wingo <br>
Stingray Software</p>
<p>
Version 5.0, updated 5/15/97</p>
<p class=indent>
<B><b>MSDN Editor's Note</b></B><i>&nbsp;&nbsp;&nbsp;This document was copied with permission from the "Microsoft Visual C++/Microsoft Foundation Classes (MFC) Frequently Asked Questions (aka the MFC FAQ)," written and compiled by Scot Wingo and sponsored by Stingray Software. You can find out more about Stingray Software's products at </i><a href="http://www.stingsoft.com/">http://www.stingsoft.com/</a><i>.</i></p>
<p class=indent>
<i>The latest version of the MFC FAQ can be found on the World Wide Web at </i><a href="http://www.stingsoft.com/mfc_faq/">http://www.stingsoft.com/mfc_faq/</a><i>. If you have any questions or comments concerning the MFC FAQ, please address them to </i><a href="mailto:mfc_faq@stingsoft.com">mfc_faq@stingsoft.com</a><i>.</i></p>
<p class=indent>
<i>This FAQ is not produced or checked for technical accuracy by Microsoft Corporation. </i></p>
<h2>About Stingray Software</h2>
<p>
The MFC FAQ is graciously sponsored by Stingray Software. Stingray Software was founded in July 1995 with the goal of creating best-of-breed object oriented developer tools for Windows programmers. Since its inception, Stingray has focused on filling the holes not covered by the MFC. Recently, Stingray has also ventured into the Java developers tool market by offering its popular object-oriented tools in the form of Java class libraries that are compatible with the Microsoft’s Visual J++ and Symantec’s Café product lines.</p>
<h2>Copyright Notice</h2>
<p>
This document is compilation copyright © 1997 by Scot Wingo. It may be freely copied and/or distributed in its entirety as long as this copyright notice is not removed. It may not be sold for profit or incorporated into commercial products without the author's written permission. Compilation copyright means that you can freely use individual sections of this document, but any significant collection of sections is subject to the copyright. Hey, I may want to turn this into a book or a movie some day!</p>
<p>
This FAQ is in no way connected with Microsoft. It contains some answers to frequently asked questions about their products. The author in no way guarantees that any of these answers are correct. This is just a collection of information posted to public online forums to help the average MFC programmer.</p>
<p>
The maintainer of this FAQ can be contacted at <a href="mailto:mfc_faq@stingsoft.com">mfc_faq@stingsoft.com</a>.</p>
<h4>Contents</h4>
<p>
<a href="#mfcfaqgeneric">Generic Class Questions</a><br>
<a href="#mfcfaqgdi">GDI Class Questions</a><br>
<a href="#mfcfaqwindow">Windows, Controls, and Dialogs Class Questions</a><br>
<a href="#mfcfaqdocs">Views, Documents, and Frame Class Questions</a><br>
<a href="#mfcfaqolecq">OLE Class Questions</a><br>
<a href="#mfcfaqwosa">WOSA Class Questions</a><br>
<a href="#mfcfaqdll">DLL and Build Questions</a><br>
<a href="#mfcfaqtips">MFC Tips, Tricks, and Caveats</a><br>
<a href="#mfcfaqwizard">Wizard Questions</a><br>
<a href="#mfcfaqvisual">Visual C++ Questions</a></p>
<h2><a name="mfcfaqgeneric"></a>Generic Class Questions</h2>
<p>
<a href="#mfcfaqcexception">CException—Exceptions and Exception Handling</a></p>
<h3><a name="mfcfaqcexception"></a>CException—Exceptions and Exception Handling</h3>
<p>
<b>How do I throw a CUserException-derived exception?</b></p>
<p>
When I try to catch a derived exception I get the following error: "error C2039: 'classCMyException': is not a member of 'CMyException' 'classCMyException': undeclared identifier 'IsKindOf': cannot convert parameter 1 from 'int*' to 'const&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct CRuntimeClass*"</p>
<p>
You need to make your CMyException class dynamically creatable by using the DECLARE_DYNAMIC() and IMPLEMENT_DYNAMIC() macros. The CATCH macro expects to be able to access run-time information about the thrown class.</p>
<p class=indent>
Mike Blaszczak, blaszczak@bix.com comp.os.ms-windows.programmer.misc, 6/5/95</p>
<p>
<b>Do my exceptions have to be derived from CUserException?</b></p>
<p>
No. The "User" in CUserException simply means that the exception is caused by user actions. It is a common misconception that this is the only exception you can derive from.</p>
<p class=indent>
nuj@kruger.dk via email, 11/23/95</p>
<h2><a name="mfcfaqgdi"></a>GDI Class Questions</h2>
<p>
<a href="#mfcfaqcdc">CDC</a><br>
<a href="#mfcfaqcbitmap">CBitmap</a></p>
<h3><a name="mfcfaqcdc"></a>CDC</h3>
<p>
<b>How do I create a CDC from an HDC?</b></p>
<p>
Sometimes the Windows API will just give you a handle to a DC and you might want to create a CDC from that. One example is owner-drawn lists, combos, and buttons. You will receive a draw item message with an hDC. Here's some code to turn that hDC into the more familiar CDC.</p>
<p>
You can use this technique for any of the other MFC class/Windows handle pairs, too.</p>
<pre><code>void MyODList::DrawItem(LPDRAWITEMSTRUCT lpDrawItem)
{
 &nbsp;&nbsp; CDC myDC;
 &nbsp;&nbsp; myDC.Attach(lpDrawItem-&gt;hDC);
 &nbsp;&nbsp; // Do more stuff here.
 &nbsp;&nbsp; // If you don't detach, it will get deleted and Windows will
 &nbsp;&nbsp; // not be happy if you delete its dc.
 &nbsp;&nbsp; myDC.Detach();
}
</code></pre>
<p>
Another approach is to call the CDC FromHandle method:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;CDC * pDC = CDC:FromHandle(lpDrawItem-&gt;hDC);
</code></pre>
<p>
It's not clear which is "better"—FromHandle() is less error-prone because you do not have to remember to "detach".</p>
<p class=indent>
Jim McCabe, jmccabe@portage1.portup.com, 6/5/95</p>
<h3><a name="mfcfaqcbitmap"></a>CBitmap</h3>
<p>
<b>How do I read a 256-color bitmap file from disk?</b></p>
<p>
Currently, MFC does not contain direct support for reading and displaying DIBs or BMPs. However, there are a number of sample applications that illustrate just how to do this.</p>
<p>
The first sample is the MFC sample application DIBLOOK. The MULTDOCS sample uses the same source code provided by DIBLOOK to read and display DIBs and BMPs.</p>
<p>
Two other examples provided with Visual C++ are the SDK samples DIBVIEW and SHOWDIB.</p>
<p class=indent>
Question posted on comp.lang.c++, 6/5/95, found this in MS FAQ, 6/25/95</p>
<h2><a name="mfcfaqwindow"></a>Windows, Controls, and Dialogs Class Questions</h2>
<p>
<a href="#mfcfaqwindows">Windows</a><br>
<a href="#mfcfaqcontrols">Controls</a><br>
<a href="#mfcfaqdialogs">Dialogs</a><br>
<a href="#mfcfaqbars">Control Bars, Status Bars, Toolbars, Dialog Bars</a><br>
<a href="#mfcfaqmenus">Menus</a><br>
<a href="#mfcfaqcommon">Windows Common Controls (aka Windows 95 Controls)</a><br>
<a href="#mfcfaqcsplit">CSplitterWnd FAQs</a></p>
<h3><a name="mfcfaqwindows"></a>Windows</h3>
<p>
<b>How can I use a custom icon for a window?</b></p>
<p>
The Microsoft Foundation Class Library stores icons for the main frame window and the MDI frame window as resources. The icon with resource ID AFX_IDI_STD_MDIFRAME is the icon for the MDI frame window, and the icon with resource ID AFX_IDI_STD_FRAME is the icon for the main frame window. To replace these icons in your application, add an icon to your resources file with the appropriate ID.</p>
<p>
The application specifies the icon for a view in an MDI child window when it creates the template. The application uses the icon with the specified resource ID when the user minimizes the MDI child window that contains the corresponding view.</p>
<p>
This technique allows you to specify one icon for the application to associate with these windows. Windows also supports dynamically painting a minimized window. To do this with MFC, use AfxRegisterWndClass() to register a window class with a NULL icon handle. Override the PreCreateWindow() function in the window class for the dynamically painted icon and copy the name returned by AfxRegisterWndClass() into the lpszClassName member of the CREATESTRUCT. This creates the window using the class that has a NULL icon. When the user minimizes this window, the icon receives WM_PAINT messages that it can process to display information appropriately. To do so, override the OnPaint() message handler and call the IsIconic() function to see if the window is minimized. If so, create a CPaintDC object and use it to draw on the icon. If the window is not minimized, call the base class version of OnPaint() to update the window normally.</p>
<p class=indent>
Visual C++ Knowledge Base article Q109039, 6/4/94</p>
<p>
<b>How do I change the styles for a window that's created by MFC?</b></p>
<p>
To change the default window attributes used by a framework application created in AppWizard, override the window's PreCreateWindow() virtual member function. PreCreateWindow() allows an application to access the creation process normally processed internally by the CDocTemplate class. The framework calls PreCreateWindow() just prior to creating the window. By modifying the CREATESTRUCT structure parameter to PreCreateWindow(), your application can change the attributes used to create the window.</p>
<p>
The CTRLBARS sample application, provided with the Microsoft Foundation Class Library version 2.0, demonstrates this technique to change window attributes. Note that depending on what your application changes in PreCreateWindow(), it may be necessary to call the base class implementation. For more information, see Visual C++ Knowledge Base article Q99847.</p>
<p class=indent>
Visual C++ Knowledge Base article Q109039, 6/7/95</p>
<p>
<b>How do I get the minimal size of a window using MFC?</b></p>
<p>
Write a handler for WM_GETMINMAXINFO.</p>
<p class=indent>
Mike Blaszczak, blaszczak@BIX.com, via programmer.misc, 6/12/95</p>
<p>
<b>How do I change a Window's title?</b></p>
<pre><code>AfxGetApp()-&gt;m_pMainWnd-&gt;SetWindowText("My Window Title");
</code></pre>
<p>
—Or—</p>
<pre><code>AfxGetMainWnd()-&gt;SetWindowText ( "My Own Title" );
</code></pre>
<p class=indent>
aj536@freenet.toronto.on.ca, mfc-l, 7/9/95</p>
<p>
<b>How do I get rid of "Untitled" in my main window caption?</b></p>
<p>
Override the PreCreateWindow() function in your MainFrame class and do the following in it:</p>
<pre><code>cs.style &amp;= ~FWS_ADDTOTITLE; 
</code></pre>
<p>
You can also set the initial window position (cs.x, cs.y, cs.cx, cs.cy) this way and change your class (cs.lpszClass) this way! <i>Remember to call CFrameWnd::PreCreateWindow at the end...</i></p>
<p class=indent>
netninja@svpal.org, programmer.misc, 7/29/95</p>
<p>
<b>How do I maximize my MDI child?</b></p>
<pre><code>void CMainFrame::ActivateFrame(int nCmdShow)
{
 &nbsp;&nbsp; if (!m_bActivated) 
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_bActivated = TRUE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nCmdShow = SW_SHOWMAXIMIZED;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; CFrameWnd::ActivateFrame(nCmdShow);
}
</code></pre>
<p>
where m_bActivated is a member variable of your frame object.</p>
<p class=indent>
duane@anasazi.com, programmer.win32, 8/3/95</p>
<p>
<b>Why does focus go nutso with a CSplitterWnd?</b></p>
<p>
Whenever I move the splitter bar, the I-beam cursor in my edit control goes away. I have to click again in the edit control to get back the cursor.</p>
<p>
The Knowledge Base Article Q108434, "FIX: CSplitterWnd Class Does Not Handle All Focus Cases," explains the focus problem associated with splitter windows and a couple of workarounds to the problem. This may be of help to you.</p>
<p class=indent>
Ramesh (NetQuest), MSMFC, 8/3/95</p>
<p>
<b>How do I make my first MDI child window start out maximized?</b></p>
<p>
Here is a solution that works for me:</p>
<pre><code>class CChildFrame : public CMDIChildWnd
{
 &nbsp; // .. stuff deleted ...
 &nbsp; // This makes the MDI child maximized.
 &nbsp;&nbsp;&nbsp; virtual void ActivateFrame(int nCmdShow) { 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // if another window is open, use default
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(GetMDIFrame()-&gt;MDIGetActive())
 &nbsp;&nbsp;&nbsp;&nbsp; CMDIChildWnd::ActivateFrame(nCmdShow); 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp; CMDIChildWnd::ActivateFrame(SW_SHOWMAXIMIZED); // else open maximized.
  }
// ... stuff deleted ...
};
</code></pre>
<p class=indent>
Stephen Bade, bade@convergent-design.com</p>
<h3><a name="mfcfaqcontrols"></a>Controls</h3>
<p>
<b>How do I get a CControl from a Dialog Template?</b></p>
<p>
You can get a pointer to a control from an already created dialog control by doing a simple typecast of the results from GetDlgItem. Here's an example that creates a CButton from a checkbox with ID&nbsp; :&nbsp; IDC_CHECK1.</p>
<pre><code>void my_function(CDialog * pDialog)
{
 &nbsp;&nbsp; CButton * pButton = (CButton *)pDialog-&gt;GetDlgItem(IDC_CHECK1);
 &nbsp;&nbsp; ASSERT(pButton != NULL);
 &nbsp;&nbsp; pButton-&gt;SetCheck(m_bShowState);
}
</code></pre>
<p>
Note that it's always safer to check for the validity of the results from GetDlgItem.</p>
<p class=indent>
Scot Wingo, scot@stingsoft.com</p>
<p>
<b>How do I subclass a control using MFC?</b></p>
<p>
Read the documentation on SubClassDlgItem. Here's an example of how to call it:</p>
<pre><code>BOOL CMyDialog::OnInitDialog()
{
 &nbsp;&nbsp; // Do your subclassing first.
 &nbsp;&nbsp; m_MyControl.SubClassDlgItem(ID_MYCONTROL, this);
 &nbsp;&nbsp; // Let the base class do its thing.
 &nbsp;&nbsp; CDialog::OnInitDialog();
 &nbsp;&nbsp; // Perhaps do some more stuff.
 &nbsp;&nbsp; // Be sure to call Ctl3d last, or it will cause
 &nbsp;&nbsp; // assertions from multiple subclassing.
 &nbsp;&nbsp; Ctl3dSubclassDlg(m_hWnd, CTL3D_ALL);
}
</code></pre>
<p class=indent>
Mike Williams, mikew@marlin.ssnet.com, mfc-l, 6/1/95</p>
<p>
<b>Why do I get an ASSERT when I subclass a control?</b></p>
<p>
Make sure that you subclass the control <i>before</i> you call Ctl3dSubclassDlg. If the 3-D control DLL is loaded first, it will already have subclassed your controls and you will get an assert. </p>
<p class=indent>
Mike Williams, mikew@marlin.ssnet.com, mfc-l, 6/1/95</p>
<p>
<b>How do I validate the contents of a control when it loses focus?</b></p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;This is in the Microsoft Software Library (MSL).</p>
<p>
The FCSVAL sample application was created to show how an application can do control-by-control validation in a dialog box.</p>
<p>
The application itself is just a modal dialog box displayed by the CWinApp::InitInstance(). After displaying the dialog box, InitInstance() simply quits the application.</p>
<p>
The important part of the sample takes place in the dialog-box class implementation: There are two edit controls. The first takes input of an integer between 1 and 20. The second takes a character string as input with length less than or equal to 5. When you tab or click from control to control within the displayed dialog box, the contents of the control that is losing focus are validated.</p>
<p>
<b>The CFocusDlg Class</b></p>
<p>
The application's functionality centers on the CFocusDlg class and its implementation of four message handlers (discussed below). Normal data exchange (DDX) and validation (DDV) using the routines provided by MFC take place in OnInitialUpdate(), when the dialog box is first displayed, and when the user chooses the OK button to accept the input. This is default behavior provided by ClassWizard when member variables are connected to dialog-box controls and can be examined in the dialog class DoDataExchange() function.</p>
<p>
Validating control contents when switching focus from one control to the next is done by handling the EN_KILLFOCUS notification sent by the edit control that is losing focus. The idea here is to check the contents and, if they are not valid, to display the message box, inform the user, and then set the focus back to the control from which it came. Unfortunately, some difficulties arise when trying to set the focus (or display the message boxes) within a killfocus message handler. At this point, Windows is in an indeterminate state as it is moving focus from one control to the other. This is a bad place to do the validation and SetFocus() call.</p>
<p>
The solution here is to post a user-defined message to the dialog box (parent) and do the validation and SetFocus() there, thus waiting for a safer time to do the work. (See "CFocusDlg::OnEditLostFocus()" in the file FOCUSDLG.CPP and "WM_EDITLOSTFOCUS user-defined message" in the file FOCUSDLG.H.)</p>
<p>
Another thing you will notice about this function is that it uses TRY/CATCH to do the validation. The provided DDX/DDV routines throw CUserExceptions when failing to validate or load a control's data. You should catch these and do the SetFocus() in the CATCH block. </p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;This sample has other cool stuff, but this is the major one I've seen asked about on the Net.</p>
<p class=indent>
Knowledge Base article Q142481, 6/25/95</p>
<p>
<b>How do I enable/disable a bank of checkboxes?</b></p>
<p>
I don't know about a magic way to do this using a single HWND, but there is a simple and self-documenting technique that I've been using for a long time. You can make a routine that accepts an array of UINTs (your control IDs) and a visibility flag.</p>
<p>
This function can be a standalone function, or you can put it inside a class. I have been collecting little utility functions like this and keep them in a CDialogBase class—when I create a new dialog box in ClassWizard, I fix up the code to derive from CDialogBase instead of CDialog.</p>
<p>
For example, the function might look like this:</p>
<pre><code>void CDialogBase::ShowControls(UINT* pControls, UINT cControls, BOOL fVisible)
{
 &nbsp;&nbsp; for (UINT uIndex = 0; uIndex &lt; cControls; uIndex++)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CWnd* pwnd = GetDlgItem(pControls[uIndex]);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pwnd)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pwnd-&gt;ShowWindow(fVisible ? SW_SHOW : SW_HIDE);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pwnd-&gt;EnableWindow(fVisible);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp; }
}
</code></pre>
<p>
Then later, often in your OnInitDialog handler, you can call this function with your control group:</p>
<pre><code>#define SIZEOF_ARRAY(a) (sizeof(a) / sizeof(a[0]))
{
 &nbsp;&nbsp; static UINT aGroup1[] = { DLG_CHBOX1, DLG_CHBOX2, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DLG_STATIC1 };
 &nbsp;&nbsp; static UINT aGroup2[] = { DLG_LABEL2, DLG_LABEL7 };
 &nbsp;&nbsp; ShowControls(aGroup1, SIZEOF_ARRAY(aGroup1), TRUE);
 &nbsp;&nbsp; ShowControls(aGroup2, SIZEOF_ARRAY(aGroup2), FALSE);
}
</code></pre>
<p>
You can find many uses for these control arrays later, too. (Changing fonts in a series of controls, etc.) Good luck.</p>
<p class=indent>
jmccabe@portage1.portup.com, mfc-l, 7/18/95</p>
<p>
<b>How do I change the background color of a control?</b></p>
<p>
Your dialog can trap the WM_CTLCOLOR message—look up the MFC Help file notes for CWnd::OnCtlColor(). Before a control is about to paint itself, the parent window receives a chance to set its own default text color and background brush.</p>
<p class=indent>
jmccabe@portage1.portup.com, mfc-l, 7/18/95</p>
<p>
Also, check out the Knowledge Base article Q117778, "Changing the Background Color of an MFC Edit Control."</p>
<p class=indent>
Ramesh, MSMFC, 7/19/95</p>
<p>
<b>How do I trap the key for my control?</b></p>
<p>
Handle WM_GETDLGCODE and return the appropriate value. Remember that the list box (or any other control) can handle keyboard input only when it has the focus.</p>
<p class=indent>
Joe Janakovic, joej@golddisk.com, programmer.misc, 8/21/95</p>
<p>
<b>How can I DDX with a multiple selection list box?</b></p>
<p>
Download MLBDDX.ZIP from the MSMFC library on CIS. You'll get all the necessary code. When the dialog closes, a provided CStringList will be filled with the selected items. Freeware. </p>
<p class=indent>
Patrick Philippot, CIS email, 8/3/95</p>
<p>
<b>How do I change the background color of a button?</b></p>
<p>
Note: the method in "How do I change the background color of a control?" will not work for buttons!</p>
<p>
If you want to change the color of a dialog button, you have to use an owner-draw button. (You can use bitmap buttons.) Changing the color through OnCtlColor() will not work for buttons. The following Knowledge Base articles may be of help to you: Q32685, "Using the WM_CTLCOLOR Message," and Q64328, "SAMPLE: Owner-Draw: 3-D Push Button Made from Bitmaps with Text." This article explains sample code for a owner-draw button.</p>
<p class=indent>
Ramesh (NetQuest), MSMFC, 8/3/95</p>
<p>
<b>Why isn't CEdit putting things on separate lines?</b></p>
<p>
Make sure that the lines are separated with \r\n, not just \n.</p>
<p class=indent>
sutor@watson.ibm.com, mfc-l, 8/7/95</p>
<p>
<b>How do I get to the CEdit in a combo box?</b></p>
<pre><code>CComboCox combo;
CEdit edit;
// Combobox creation ...
// ...
POINT tmpPoint = {1,1};
edit.SubclassWindow( combo.ChildWindowFromPoint(tmpPoint)
-&gt;GetSafeHwnd());
</code></pre>
<p class=indent>
jahans@slb.com, mfc-l, 8/25/95</p>
<p>
Or:</p>
<p>
Look into the MFC sample—npp - npview.cpp! Turns out all combos create their edits with an ID of 1001 (decimal), so—if pComboBox is the pWnd object pointing to the combo—all you need is:</p>
<pre><code>pComboBox-&gt;GetDlgItem(1001);
</code></pre>
<p>
<b>How do I load more than 64K into an edit control?</b></p>
<p>
The Rich Edit Control available in Visual C++ 2.1 and later supports much more than 64K. The WordPad sample is a great way to learn more about this subject. If you're stuck with 16-bit programming, I think that Magma Systems has a 16-bit DLL that does this. Contact Marc Adler at 75300.2062@compuserve.com for details.</p>
<p class=indent>
Scot Wingo—scot@stingsoft.com</p>
<p>
<b>How do I subclass the list box portion of a combo box?</b></p>
<p>
The listbox portion of a combo box is of type COMBOLBOX (notice the "L").&nbsp;&nbsp;&nbsp; Because the ComboLBox window is not a child of the ComboBox window, it is not obvious how to subclass the COMBOLBOX control. Luckily, under the Win32 API, Windows sends a message to the COMBOBOX (notice no "L") called WM_CTLCOLORLISTBOX before the list box is drawn. The lParam passed with this message contains the handle of the list box. For example:</p>
<pre><code>LRESULT CFileUpdateCombo::OnCtlColorListBox(WPARAM wParam, 
 &nbsp; LPARAM lParam) 
{
 &nbsp;&nbsp; if ( ! m_bSubclassedListBox ) 
{
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HWND hWnd = (HWND)lParam;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CWnd* pWnd = FromHandle(hWnd);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( pWnd &amp;&amp; pWnd != this )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // m_ListBox is derived from CListBox.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_ListBox.SubclassWindow(hWnd );
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_ListBox.SetOwner(this); 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_bSubclassedListBox = TRUE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp; }
 &nbsp;&nbsp; return (LRESULT)GetStockObject(WHITE_BRUSH);
}
</code></pre>
<p class=indent>
mikem@abelcomputers.com, email, 9/7/95</p>
<p>
<b>How do I inherit from an MFC standard control class and provide initialization code that works on both subclassed and nonsubclassed controls?</b></p>
<p class=indent>
<B><b>Editor's note (Scot Wingo):&nbsp;&nbsp;&nbsp;</b></B>OK, this probably isn't a FAQ, but I thought it sounded pretty cool.</p>
<p>
I have a fix, but you may not like it; however, it takes care of both subclassing methods.</p>
<p>
If SubclassWindow() was virtual, all problems would be solved, as SubclassDlgItem calls SubclassWindow(), and common initialization could be called from this point and from OnCreate(). Even better would be a virtual SetupWindow() function called from all initialization points by Microsoft's code.</p>
<p>
C'est la vie. My fix might slow the message loop for the control in question, but so far I haven't seen any performance hits. Override the virtual function WindowProc() for your control something like the following (call SetupWindow() in OnCreate() also):</p>
<pre><code>LRESULT CExtendControl::WindowProc( UINT message, WPARAM wParam,
 &nbsp; LPARAM lParam)
{
 &nbsp;&nbsp; if (!m_bSetup)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetupWindow();
 &nbsp;&nbsp; return CEdit::WindowProc(message, wParam, lParam );
}
// This is a virtual function. Use it for Hwnd setup in all inherited 
// classes. It will work for a subclassed window.
void CExtendControl::SetupWindow()
{
 &nbsp;&nbsp; ASSERT( m_hWnd );
 &nbsp;&nbsp; m_bSetup = TRUE;
 &nbsp;&nbsp; *** Insert Initialization Code here!***
}
</code></pre>
<p class=indent>
Jody Power, jodyp@andyne.on.ca)</p>
<h3><a name="mfcfaqdialogs"></a>Dialogs</h3>
<p>
<b>How do I center my dialog?</b></p>
<p>
Use the CWnd::CenterWindow method to accomplish this. I usually put it in my OnInitDialog overloaded function. Since CDialog is an ancestor of CWnd, you can call the method directly: </p>
<pre><code>&nbsp;BOOL CMyDialog::OnInitDialog()
{
 &nbsp;&nbsp; // Perform any other dialog initialization up here.
 &nbsp;&nbsp; CenterWindow();
 &nbsp;&nbsp; return TRUE;
}
</code></pre>
<p class=indent>
Scot Wingo, scot@stingsoft.com, 6/1/95</p>
<p>
<b>How do I get the "old style" common dialogs on Windows 95?</b></p>
<p>
MFC detects if it is running on Windows 95, and if so, replaces the standard FileOpen dialog box with an Explorer version of the File Open dialog box. You can prevent MFC from using this Explorer version by adding the following line to your CFileDialog derived class constructor:</p>
<pre><code>m_ofn.Flags &amp;= ~OFN_EXPLORER;
</code></pre>
<p class=indent>
andyd@andyne.on.ca (Andy DeWolfe), via programmer.win32, 5/10/95</p>
<p>
<b>How do I subclass a Windows 95 common dialog?</b></p>
<p>
You can do it, but Microsoft has made it much more difficult in Windows 95. You need to create a "child dialog template" (with the WS_CHILD style) and set it to m_ofn.lpTemplateName (making sure m_ofn.hInstance is set to your app instance). This template must contain <i>only</i> the controls that you are adding to the dialog (that is, <i>not </i>the whole dialog with the standard controls duplicated, as in Windows 3.<i>x</i>).</p>
<p>
When the dialog is invoked, your template will appear (by default) below the regular file dialog controls. If you put a static control with id stc32 (defined in include\dlgs.h), the common dialog code will rearrange things so that the original controls will appear wherever you put the stc32 control. (You don't have to size it to match—the common dlg code will do that for you.)</p>
<p>
You will need to supply m_ofn.lpfnHook and handle your additional controls through the hook proc. Note that since the system puts your dialog template <i>on top</i> of the normal dialog, MFC message routing won't get to your controls, so you can't code them through a message map in your CFileDialog derivative. If anybody has found a way around this, I'd love to hear it!!</p>
<p>
This is very messy and Microsoft knows it. They promise a fix in MFC 4.0.</p>
<p class=indent>
<B><b>Editor's note (Scott Wingo)</b></B>&nbsp;&nbsp;&nbsp;This is much nicer in 4.0. There are virtuals to override for getting callbacks, plus it even handles the old and new style templates—pretty clever stuff!</p>
<p class=indent>
joej@golddisk.com, via programmer.win32, 6/10/95</p>
<p>
<b>CDialog::Create() fails. What could be wrong?</b></p>
<p>
Invalid HWND passed as a parent.</p>
<p>
Invalid dialog resource ID passed. (Be careful about numeric IDs vs. string IDs—be careful with #define ID_MYDIALOG 0x1234—it is a "string" ID to the resource compiler.)</p>
<p>
One or more controls on your dialog could not be created, usually because of the use of a custom control that was not registered. Calling EndDialog during the OnInitDialog message (or some other handler called early in the game)!</p>
<p>
NULL HWND passed as parent when dialog has WS_CHILD style.</p>
<p>
That's about all I can think of right now.</p>
<p class=indent>
Dean McCrory, MSMFC, 6/16/95</p>
<p>
<b>How do I create a toolbar/status bar in a dialog?</b></p>
<p>
There's a sample in the Microsoft Software Library, DLGCBR, that demonstrates how to do this. Basically there's four steps, outlined and then coded below.</p>
<p>
To add a control bar to a dialog, you must create the control bar as usual and then make room for the control bar within the client area of the dialog. For the control bar to function properly, the dialog must duplicate some of the functionality of frame windows. If you want ON_UPDATE_COMMAND_UI handlers to work for the control bars, you also need to derive new control bar classes, and handle the WM_IDLEUPDATECMDUI message. If your dialog is not the main window of your application, you will also need to modify its parent frame window to pass the WM_IDLEUPDATECMDUI message on to the dialog's control bars.</p>
<p>
To make room for a control bar within the client area of the dialog, follow these steps in your dialog's OnInitDialog() function:
<ol>
<li>
Create the control bars:<pre><code>CRect rcClientStart;
CRect rcClientNow;
GetClientRect(rcClientStart);
RepositionBars(AFX_IDW_CONTROLBAR_FIRST,
AFX_IDW_CONTROLBAR_LAST,
,reposQuery,
rcClientNow);
</code></pre>
</li>
<li>
Figure out how much room the control bars will take by using the reposQuery option of RepositionBars():<pre><code>CPoint ptOffset(rcClientStart.left - rcClientNow.left,
rcClientStart.top - rcClientNow.top);
ptOffset.y += ::GetSystemMetrics(SM_CYMENU);
CRect rcChild;
CWnd* pwndChild = GetWindow(GW_CHILD);
while (pwndChild)
{
pwndChild-&gt;GetWindowRect(rcChild);
rcChild.OffsetRect(ptOffset);
pwndChild-&gt;MoveWindow(rcChild, FALSE);
pwndChild = pwndChild-&gt;GetNextWindow();
}
</code></pre>
</li>
<li>
Move all the controls in your dialog to account for space used by control bars at the top or left of the client area. If your dialog contains a menu, you also need to account for the space used by the menu.<br><br></li>
<li>
Increase the dialog window dimensions by the amount of space used by the control bars:<pre><code>CRect rcWindow;
GetWindowRect(rcWindow);
rcWindow.right += rcClientStart.Width() - rcClientNow.Width();
rcWindow.bottom += rcClientStart.Height() - rcClientNow.Height();
MoveWindow(rcWindow, FALSE);
</code></pre>
</li>
<li>
Position the control bars using RepositionBars(). </li>
</ol>
<p>
To update the first pane of a status bar with menu item text, you must handle WM_MENUSELECT, WM_ENTERIDLE, and WM_SETMESSAGESTRING in your dialog class. You need to duplicate the functionality of the CFrameWnd handlers for these messages. See the CModelessMain class in the sample program for examples of these message handlers.</p>
<p>
To allow ON_UPDATE_COMMAND_UI handlers to work for other status bar panes and for toolbar buttons, you must derive new control bar classes and implement a message handler for WM_IDLEUPDATECMDUI. This is necessary because the default control bar implementations of OnUpdateCmdUI() assume the parent window is a frame window. However, it doesn't do anything but pass the parent window pointer on to a function that only requires a CCmdTarget pointer. Therefore, you can temporarily tell OnUpdateCmdUI() that the parent window pointer you are giving it is a CFrameWnd pointer to meet the compiler requirements. Here's an example:</p>
<pre><code>LRESULT CDlgToolBar::OnIdleUpdateCmdUI(WPARAM wParam,LPARAM lParam)
{
 &nbsp;&nbsp; if (IsWindowVisible())
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CFrameWnd* pParent = (CFrameWnd*)GetParent();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pParent)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OnUpdateCmdUI(pParent, (BOOL)wParam);
 &nbsp;&nbsp; }
 &nbsp;&nbsp; return 0L;
}
</code></pre>
<p>
To pass WM_IDLEUPDATECMDUI messages on to dialogs other than the main window, save dialog pointers in your frame window class and create a WM_IDLEUPDATECMDUI handler in that class. The handler should send the WM_IDLEUPDATECMDUI message on to the dialog child windows by using CWnd::SendMessageToDescendants(). Then perform default processing for the message within the frame window.</p>
<p class=indent>
Visual C ++ Knowledge Base article Q123158, 6/25/95</p>
<p>
<b>Why isn't my CDialog::PreCreateWindow() getting called?</b></p>
<p>
PreCreateWindow does not get called when you create a dialog box. If you would like to init some data/controls for a dialog box, you have to trap the OnInitDialog message and then do your stuff there. PreCreateWindow is used to modify params for a window that you are creating.</p>
<p class=indent>
ewalker@tezcat.com, mfc-l, 7/12/95</p>
<p>
<b>How do I embed a common dialog in a property page?</b></p>
<p>
This question comes up frequently on the MFC forum of CompuServe and the simple answer—unfortunately—is that there is no way to do it :-(</p>
<p class=indent>
chris@chrism.demon.co.uk, programmer.win32, 7/12/95</p>
<p>
[Correct. The problem is that the Windows implementation of these dialogs is a modal dialog. In order to embed something on a property sheet, it would need to be implemented as a modeless child dialog window. Because the Windows API does not expose modeless child capability for any of the common dialogs, you cannot embed them on a property sheet. The only way to get the functionality you are after is to "roll your own" implementation of these pages.</p>
<p class=indent>
Dean McCrory's reply to MSDN editor's query, 4/25/96]</p>
<p>
<b>Why can't I DDX/DDV to initialize my CDialog controls?</b></p>
<p>
You can't do anything with the dialog controls until your dialog is created—which doesn't happen until DoModal(). The standard way of overcoming the problems is to create member variables for the data, initialize them before calling DoModal, and then transfer the values in OnInitDialog. Or perhaps in UpdateData(). Much like the ClassWizard member variables do it.</p>
<p>
So have your dialog include a CStringList or CStringArray, put the values for the listbox in that and transfer them to the listbox in OnInitDialog. [Etc....]</p>
<p class=indent>
Niels Ull Jacobsen, null@diku.dk, programmer.controls, 7/11/95</p>
<p>
Init your dialog in OnInitDialog. If necessary, pass a pointer to your document to the constructor of your dialog (and save it in a private/protected m_pDoc member).</p>
<p class=indent>
jhasling@gascad.co.at, programmer.controls, 7/11/95</p>
<p>
<b>How do I change the captions of a CPropertyPage?</b></p>
<p>
You can change the label before adding the page to the property sheet in the following way. You have to derive a class from CPropertyPage and add a public function, SetCaption, which sets the caption.</p>
<pre><code>void CPage1::SetCaption(char *str)
{
 &nbsp;&nbsp; m_strCaption = str; // m_strCaption is protected member of
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // CPropertyPage
}
</code></pre>
<p>
Now you can use the SetCaption() function in the following way:</p>
<pre><code>CMySheet my("My PropSheet");
CPage1 p1;
p1.SetCaption(str); // Setting the caption.
my.AddPage(&amp;p1);
CAnotherSheet newps("New Sheet");
CPage1 p2;
p2.SetCaption(newstr);
newps.AddPage(&amp;p2);
my.DoModal();
</code></pre>
<p class=indent>
Ramesh (NetQuest), MSMFC, 8/3/95</p>
<p>
<b>How do I trap F1 in my dialog?</b></p>
<p>
The Knowledge Base article Q117563, "How to Trap WM_KEYDOWN Messages in a CDialog," explains a way to trap the WM_KEYDOWN messages in the dialog box.</p>
<p>
"SAMPLE: Context Sensitive Help in a CDialog" explains how to provide context-sensitive help in a dialog. It also points to sample code (Knowledge Base article Q110506).</p>
<p class=indent>
Ramesh (NetQuest), MSMFC, 8/31/95</p>
<p>
<b>How do I change the icon for a dialog-only MFC application?</b></p>
<p>
Add the following code to the InitInstance() for the CWinApp derived class:</p>
<pre><code>BOOL CDialogTestApp::InitInstance()
{
 &nbsp;&nbsp; // ...
#if(_MFC_VER &gt;= 0x0300)
 &nbsp;&nbsp; SetClassLong(m_pMainWnd-&gt;m_hWnd,GCL_HICON,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (LONG)LoadIcon(IDC_ICONDIALOGAPP));
#else
 &nbsp;&nbsp; SetClassWord(m_pMainWnd-&gt;m_hWnd,GCW_HICON,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (WORD)LoadIcon(IDC_ICONDIALOGAPP));
#endif
 &nbsp;&nbsp; // ...
 &nbsp;&nbsp; m_pMainWnd-&gt;ShowWindow(m_nCmdShow);
 &nbsp;&nbsp; return TRUE;
}
</code></pre>
<h3><a name="mfcfaqbars"></a>Control Bars, Status Bars, Toolbars, Dialog Bars</h3>
<p>
<b>How do I add a combo box to my toolbar?</b></p>
<p>
You can do this using the CToolBar::SetButtonInfo() method. The MFC sample CTRLBARS shows how to do this in file mainfrm.cpp. Basically, you call SetButtonInfo to create a blank space (TBBS_SEPARATOR) for the combo box, with the resource ID of the help and tool tip for the combo box. You then use GetItemRect to get the bounding rectangle of the combo box, and create a combo box window of your own in that space.</p>
<p class=indent>
Scot Wingo, scot@stingsoft.com, 6/1/95; martynl@cix.compulink.co.uk—updated</p>
<p>
<b>How do I update the text of a pane in a status bar?</b></p>
<p>
By default, a CStatusBar pane is not enabled when the pane is created. To activate a pane, you must call the ON_UPDATE_COMMAND_UI() macro for each pane on the status bar and update the panes. Because panes do not send WM_COMMAND messages, you cannot use ClassWizard to activate panes; you must type the code manually. For example, suppose one pane has ID_INDICATOR_PAGE as its identifier and that it contains the current page number in a document. To make the ID_INDICATOR_PAGE pane display text, add the following to a header file (probably the MAINFRM.H file):</p>
<pre><code>afx_msg void OnUpdatePage(CCmdUI *pCmdUI);
</code></pre>
<p>
Add the following to the application message map:</p>
<pre><code>ON_UPDATE_COMMAND_UI(ID_INDICATOR_PAGE, OnUpdatePage)
</code></pre>
<p>
Add the following to a source code file (probably MAINFRM.CPP):</p>
<pre><code>void CMainFrame::OnUpdatePage(CCmdUI *pCmdUI){&nbsp;&nbsp;&nbsp; pCmdUI-&gt;Enable();}
</code></pre>
<p>
To display text in the panes, either call SetPaneText() or call CCmdUI::SetText() in the OnUpdate() function. For example, you might want to set up an integer variable m_nPage that contains the current page number. Then, the OnUpdatePage() function might read as follows:</p>
<pre><code>void CMainFrame::OnUpdatePage(CCmdUI *pCmdUI){&nbsp;&nbsp;&nbsp; pCmdUI-&gt;Enable();&nbsp;&nbsp;&nbsp; char szPage[16];&nbsp;&nbsp;&nbsp; wsprintf((LPSTR)szPage, "Page %d", m_nPage);&nbsp;&nbsp;&nbsp; pCmdUI-&gt;SetText((LPSTR)szPage);}
</code></pre>
<p>
This technique causes the page number to appear in the pane during idle processing in the same manner that the application updates other indicators.</p>
<p class=indent>
Visual C++ Knowledge Base article 109039, 6/4/94</p>
<p>
<b>How do I make my CToolBar customizable at run time?</b></p>
<p>
You might consider reading article "CToolBarCtrl: Handling Customization Notifications" in the Product Documentation of Visual C++ 2.1.</p>
<p>
Here is the relevant extract :</p>
<p class=indent>
"A Windows toolbar common control has built-in customization features, including a system-defined customization dialog box, which allow the user to insert, delete, or rearrange toolbar buttons. The application determines whether the customization features are available and controls the extent to which the user can customize the toolbar. These customization features are available in the CToolBarCtrl class but not in the current CToolBar class.</p>
<p class=indent>
"You can make these customization features available to the user by giving the toolbar the CCS_ADJUSTABLE style. The customization features allow the user to drag a button to a new position or to remove a button by dragging it off the toolbar. In addition, the user can double-click the toolbar to display the Customize Toolbar dialog box, which allows the user to add, delete, and rearrange toolbar buttons. The application can display the dialog box by using the Customize member function."</p>
<p class=indent>
R. Rajendran (NetQuest), 76041.2245@compuserve.com, MSMFC Forum, 5/9/95</p>
<p>
If you want to make a standard MFC CToolbar customizable, you can download CUSBAR.ZIP from the MSMFC library on CompuServe. This package implements CCustomToolbar, the run-time customizable toolbar, and also provides the necessary user tools (customization dialog box, including the code for a bitmapped listbox). Freeware.</p>
<p class=indent>
Patrick Philippot, 8/3/95 via email on CSERVE</p>
<p>
<b>How do I turn off the toolbar or status bar?</b></p>
<p>
You can turn the status bar off in any of your views (for example in the OnViewStatusBar() method you describe above) with the following code: </p>
<pre><code>if( ((CMainFrame*)GetParent())-&gt;m_wndToolBar.IsWindowVisible() )
{
 &nbsp;&nbsp; GetParent()-&gt;SendMessage(WM_COMMAND, ID_VIEW_TOOLBAR, 0L);
}
if( ((CMainFrame*)GetParent())-&gt;m_wndStatusBar.IsWindowVisible() )
{
 &nbsp;&nbsp; GetParent()-&gt;SendMessage(WM_COMMAND, ID_VIEW_STATUS_BAR, 0L);
}
</code></pre>
<p>
Use 1L instead of 0L for the SendMessage's lParam to turn the bars on.</p>
<p class=indent>
JKBenjamin@aol.com, via mfc-l, 5/16/95</p>
<p>
<b>How do I create a toolbar/statusbar in a dialog?</b></p>
<p>
See section 6.3.5. of this FAQ </p>
<p>
<b>Why doesn't MFC support the new controls provided by IE?</b></p>
<p>
<b>Why doesn't MFC have toolbars like the Office 97 applications?</b></p>
<p>
<b>Why doesn't MFC support command bar menus like the Visual C++ IDE?</b></p>
<p>
The new user interface style provided by Microsoft Internet Explorer is implemented by a version of COMCTL32.DLL that's still in beta. The beta import library, DLL, and documentation is available in the Microsoft ActiveX SDK (for Internet Explorer 3.01). The Microsoft ActiveX SDK documentation can be found on the MSDN Library under the SDK Documentation bin. The actual SDK is available for download from <a href="http://www.microsoft.com/msdn/">http://www.microsoft.com/msdn/</a>. Because the controls are still in beta, MFC doesn't support them. When they're available in their final version, you can assume that a version of MFC that supports them will be forthcoming.</p>
<p>
The IDE and the Office applications do not use the COMCTL32.DLL implementations of those controls, and therefore aren't concerned with the release state of the system implementation library. </p>
<p class=indent>
mikeblas@microsoft.com</p>
<p>
<b>Note:</b> The Internet Explorer control is called Rebar. (There was a very good MSJ article about it.) It is useful <i>only </i>if you want to implement Internet Explorer 3 or 4 style toolbars. The toolbars in Visual C++ 5.<i>x</i> and Microsoft Office 97 are different—they are called Command bars. <b>They are not rebar controls</b>—the differences?</p>
<p>
Rebar controls "slides" around. </p>
<p>
Rebar controls aren't customizable (to my knowledge).</p>
<p>
Command bars have cool floating menus. (Rebar controls may do this eventually) </p>
<p>
Command bars are less clunky. </p>
<p>
Command bars don't have a transparent background. </p>
<p>
Command bars are implemented inside of Office97/Developer Studio—they are not available for developers to use. Rebar will be available as part of a common control DLL. </p>
<p>
Both have a "cool" or "flat" look and appear three-dimensional when the mouse pointer moves over them. </p>
<p>
I don't think Rebar controls are vertically dockable. </p>
<p>
If you want to play with Rebar, you need the files COMMCTRL.H and COMCTL32.LIB that come with the ActiveX SDK.</p>
<p>
Also, for more information, take a look at the REBAR sample available with the article "Rebar: It Isn't Just for Concrete Anymore" at: <a href="http://www.microsoft.com/win32dev/ui/">http://www.microsoft.com/win32dev/ui/.</a></p>
<p class=indent>
<B><b>FYI</b></B>&nbsp;&nbsp;&nbsp;Stingray Software has implemented Office97/Developer Studio style command bars in Objective Toolkit—check out the demo at <a href="http://www.stingsoft.com/">http://www.stingsoft.com/</a>. Right now Stingray only has the toolbar working, but they promise, a future release, complete menus too!</p>
<h3><a name="mfcfaqmenus"></a>Menus</h3>
<p>
<b>How do I get a pointer to the menu bar in an MDI app?</b></p>
<p>
Question: I'm writing an MDI application and I have problems to get a pointer to the actual menu bar. The normal construction doesn't seem to work in MDI:</p>
<pre><code>CMenu *menu;menu = GetMenu()-&gt;GetSubMenu(0);
</code></pre>
<p>
How can I get a pointer to the menu bar to update the menu?</p>
<p>
Answer:</p>
<pre><code>AfxGetApp()-&gt;m_pMainWnd-&gt;GetMenu()-&gt;GetSubMenu(n);
</code></pre>
<p class=indent>
mlinar@pollux.usc.edu (Mitch Mlinar), 6/8/95</p>
<p>
<b>How do I implement a right-mouse pop-up menu?</b></p>
<pre><code>///////////////////////////////////////////////////////////////////
// WM_RBUTTONDOWN handler.
//
// Trap this message and display the Button Properties pop-up menu.
// The main frame receives the pop-up menu messages. This allows the
// status bar to be updated with the help text.
///////////////////////////////////////////////////////////////////

void CAppButton::OnRButtonDown(UINT flags, CPoint point)
{
 &nbsp;&nbsp; CMenu menu;
 &nbsp;&nbsp; CMenu *submenu;
 &nbsp;&nbsp; // Load the menu.
 &nbsp;&nbsp; menu.LoadMenu(IDR_LAUNCH);
 &nbsp;&nbsp; // Get the pop-up menu.
 &nbsp;&nbsp; submenu = menu.GetSubMenu(0);
 &nbsp;&nbsp; // Convert to screen coordinates.
 &nbsp;&nbsp; ClientToScreen(&amp;point);
 &nbsp;&nbsp; // Post the menu.
 &nbsp;&nbsp; submenu-&gt;TrackPopupMenu(TPM_LEFTALIGN|TPM_RIGHTBUTTON,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; point.x,&nbsp;&nbsp;&nbsp; point.y,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AfxGetApp()-&gt;m_pMainWnd,NULL);
}
</code></pre>
<p class=indent>
johnm@unipalm.co.uk, programmer.win32, 7/12/95</p>
<p>
It's better to use RBUTTONUP instead; however, right-clicking on dialog controls doesn't generate RBUTTONUP and RBUTTONDOWN messages. </p>
<p>
If it's necessary to treat this situation too, a program has to catch the WM_PARENTNOTIFY message in Windows 3.<i>x</i> and Windows NT, and WM_CONTEXTMENU in Windows 95. Here's a code:</p>
<pre><code>// May be dialog too:
BEGIN_MESSAGE_MAP(CMyPropertyPage, CPropertyPage)
 &nbsp;&nbsp; // {{AFX_MSG_MAP(CMyPropertyPage)
 &nbsp;&nbsp; ON_WM_RBUTTONUP()
 &nbsp;&nbsp; ON_WM_PARENTNOTIFY()
 &nbsp;&nbsp; ON_MESSAGE(WM_CONTEXTMENU, OnContextMenu)
 &nbsp;&nbsp; // }}AFX_MSG_MAP
END_MESSAGE_MAP()
void CMyPropertyPage::OnRButtonUp(UINT nFlags, CPoint point)=20
{
 &nbsp;&nbsp; PopupMenu (&amp;point);
}
void CMyPropertyPage::OnParentNotify(UINT message, LPARAM lParam)
{
 &nbsp;&nbsp; if (message !=3D WM_RBUTTONDOWN)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CPropertyPage::OnParentNotify(message, lParam);
 &nbsp;&nbsp; else
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CPoint pt(LOWORD(lParam),HIWORD(lParam));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PopupMenu (&amp;pt);
 &nbsp;&nbsp; }
}
LONG CMyPropertyPage::OnContextMenu (UINT wParam, LONG lParam)
{
 &nbsp;&nbsp; CPoint pt(LOWORD(lParam),HIWORD(lParam));
 &nbsp;&nbsp; ScreenToClient (&amp;pt);
 &nbsp;&nbsp; PopupMenu (&amp;pt);
 &nbsp;&nbsp; return 0;
}
// *****************************************************************
void CMyPropertyPage::PopupMenu(CPoint* pt)
{
 &nbsp;&nbsp; ASSERT(m_idContextMenu !=3D 0);
 &nbsp;&nbsp; ASSERT(nSubMenu &gt;=3D 0);
 &nbsp;&nbsp; ClientToScreen (pt);
 &nbsp;&nbsp; CMenu FloatingMenu;
 &nbsp;&nbsp; VERIFY(FloatingMenu.LoadMenu(ID_POPUP_MENU));
 &nbsp;&nbsp; CMenu* pPopupMenu =3D FloatingMenu.GetSubMenu (0);
 &nbsp;&nbsp; ASSERT(pPopupMenu !=3D NULL);
 &nbsp;&nbsp; pPopupMenu-&gt;TrackPopupMenu (TPM_LEFTALIGN | TPM_RIGHTBUTTON,=20
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pt-&gt;x, pt-&gt;y, this);
}
</code></pre>
<p class=indent>
PaulACost@msn.com, via email, 10/15/95</p>
<p>
<b>How do I dynamically change the mainframe menu?</b></p>
<pre><code>CMenu newMenu;
newMenu.LoadMenu (IDR_MENU1);
AfxGetMainWnd()-&gt;SetMenu( &amp;newMenu );
AfxGetMainWnd()-&gt;DrawMenuBar();
newMenu.Detach ();
</code></pre>
<p class=indent>
Arun Rao, MSMFC, 6/27/95</p>
<p>
<b>How do I "attach" a menu to a window's creation/destruction?</b></p>
<p class=indent>
<B><b>Editor's note (Scot Wingo)</b></B>&nbsp;&nbsp;&nbsp;the original question talked about dialogs, but you can interpolate this code to any kind of window that you want to have change the menu.</p>
<p>
One of the ways to do this is as follows.</p>
<p>
Declare a variable CMenu pNewMenu in one of the dialog classes.</p>
<p>
Handle the WM_INITDIALOG and WM_CLOSE messages in the dialog class as follows:</p>
<pre><code>BOOL CMydlg::OnInitDialog()
{
 &nbsp;&nbsp; CDialog::OnInitDialog();
 &nbsp;&nbsp; // Load the IDR_MYFRAME menu.
 &nbsp;&nbsp; pNewMenu = new CMenu;
 &nbsp;&nbsp; pNewMenu-&gt;LoadMenu(IDR_MYFRAME);
 &nbsp;&nbsp; // Set the mainframe menu to mainframe.
 &nbsp;&nbsp; ((CMainFrame *)AfxGetMainWnd())-&gt;SetMenu(pNewMenu);
 &nbsp;&nbsp; return TRUE;
}
</code></pre>
<p>
And</p>
<pre><code>void CMydlg::OnClose()
{
 &nbsp;&nbsp; // Detach the previous HMenu handle from the object.
 &nbsp;&nbsp; pNewMenu-&gt;Detach();
 &nbsp;&nbsp; pNewMenu-&gt;LoadMenu(IDR_MAINFRAME);
 &nbsp;&nbsp; // Restore the mainframe menu.
 &nbsp;&nbsp; ((CMainFrame *)AfxGetMainWnd())-&gt;SetMenu(pNewMenu);
 &nbsp;&nbsp; CDialog::OnClose();
}
</code></pre>
<p>
If there are other methods of closing the dialog (for example, by clicking a button in the dialog), then the code given above in the <b>OnClose</b> handler must be put in the button click handler.</p>
<p class=indent>
Sanjeev Kumar, MSMFC, 6/23/95</p>
<h3><a name="mfcfaqcommon"></a>Windows Common Controls (aka Windows 95 Controls)</h3>
<p>
<b>Can I use these controls under Windows NT or Win32s?</b></p>
<p>
Windows NT version 3.50 does not support the common controls, and will not in the future. You must use Windows NT version 3.51 to gain the common controls.</p>
<p class=indent>
blaszczak@BIX.com, mfc-l, 7/6/95</p>
<p>
Version 1.30 of Win32s supports the common controls.</p>
<p>
<b>Where's a demo of these wickedly cool controls?</b></p>
<p>
Check out the MFC sample, FIRE, which features most of the controls in action: MSVC20\samples\mfc\fire. Under version 4.0, there's another one called CMNCTRLS.</p>
<p class=indent>
Scot Wingo, scot@stingsoft.com, 7/27/95</p>
<p>
<b>How do you handle NM_DBLCLK for a CListCtl?</b></p>
<pre><code>BEGIN_MESSAGE_MAP(CListView, CView)
 &nbsp;&nbsp; ON_NOTIFY( NM_DBLCLK,ID_LISTCTRL,OnDblClick )
END_MESSAGE_MAP()
void CListView::OnDblClick(NMHDR* /*k*/, LRESULT* /*j*/)
{
 &nbsp;&nbsp; int nItem, nFlags;
 &nbsp;&nbsp; char szTest[80];
 &nbsp;&nbsp; nFlags = LVNI_SELECTED;
 &nbsp;&nbsp; nItem = m_ListCtrl-&gt;GetNextItem(-1, nFlags );
 &nbsp;&nbsp; if ( nItem != -1 )
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf( szTest, "Selected Item %d", nItem);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AfxMessageBox(szTest);
 &nbsp;&nbsp; }
}
</code></pre>
<p class=indent>
spolyak@interaccess.com, mfc-l, 7/21/95</p>
<p>
<b>Does CTreeCtrl support multiple selection?</b></p>
<p>
No. Sorry! (I see this one all the time!)</p>
<p class=indent>
Scot Wingo, scot@stingsoft.com</p>
<p>
If it's accessible to you, <i>Microsoft Systems Journal</i>, July 1994, has an extensive look at TreeViews, including a sample program that includes drag-and-drop. [<i><b>MSDN editor’s note</b>&nbsp;&nbsp;&nbsp;You can find this in the Library under Books and Periodicals, Microsoft Systems Journal, 1994 Volume 9.</i>] ]If you're developing for Windows 95, you don't need a shareware implementation—MFC has a class for it.</p>
<p class=indent>
steven@primenet.com</p>
<p>
<b>When I expand a node in my CTreeCtrl, there's no visual feedback—what to do?</b></p>
<p>
Create the control with TVS_SHOWSELALWAYS style.</p>
<p class=indent>
kfreeman@viewlogic.com</p>
<p>
<b>How do I implement multiple selection, ToolTips, editable nodes, and multiple columns in my tree control?</b></p>
<p>
Unfortunately, because the tree control lives in a binary DLL, it is not very extensible and you are stuck without these features. There have been articles on how to try and "hack" these features, but they do not work reliably.</p>
<p>
Stingray Software has a drop-in tree control replacement that implements all of these features and more in Objective Toolkit. Demos are at <a href="http://www.stingsoft.com/">http://www.stingsoft.com/.</a></p>
<p class=indent>
Scot Wingo, scot@stingsoft.com</p>
<h3><a name="mfcfaqcsplit"></a>CSplitterWnd FAQs</h3>
<p>
We would like to add lots of CSplitterWnd questions to this FAQ—email your toughest ones to <a href="mailto:mfc_faq@stingsoft.com">mfc_faq@stingsoft.com</a>.</p>
<p>
<b>FYI:</b>  <i>MFC Internals</i>, written<i> </i>by George Shepherd and me, has a whole chapter devoted to this—it's my personal favorite MFC class because it has lots of interesting internals, shortcomings, odd behaviors, and so forth.</p>
<p>
We wrote a <i>Dr. Dobbs Journal</i> article where we show how to swap the splitter from horizontal to vertical. I think the code is at <a href="http://www.ddj.com">http://www.ddj.com</a>, if you are interested.</p>
<p class=indent>
Scot Wingo, scot@stingsoft.com</p>
<h2><a name="mfcfaqdocs"></a>Views, Documents, and Frame Class Questions</h2>
<p>
<a href="#mfcfaqviews">Views</a><br>
<a href="#mfcfaqdocuments">Documents</a></p>
<h3><a name="mfcfaqviews"></a>Views</h3>
<p>
<b>How do I size a view?</b></p>
<p>
Normally, you can change the size of a window by calling MoveWindow(). In an application developed with the Microsoft Foundation Class (MFC) Library, the view window is a child window of the frame window that surrounds the view. To change the size of the view window, retrieve a pointer to the frame window of the view by calling GetParentFrame(), then call MoveWindow() to change the size of the parent. When the parent frame window changes size, it automatically changes the size of the view window to fit in the parent frame.</p>
<p class=indent>
Visual C++ Knowledge Base article Q109039, 6/4/94</p>
<p>
<b>How do I size a CFormView?</b></p>
<p>
See the Visual C++ Knowledge Base article Q98598, "Using CFormView in SDI and MDI Applications," for a very long answer. Basically, you need to override OnInitialUpdate() in a CFormView derived class. There's other details to deriving from CFormView that the article goes into.</p>
<p class=indent>
Visual C++ Knowledge Base article Q98598, 6/7/95</p>
<p>
In the view ClikethisView declaration:</p>
<pre><code>virtual void OnInitialUpdate();
</code></pre>
<p>
In the ClikethisView code:</p>
<pre><code>void ClikethisView::OnInitialUpdate()
{
 &nbsp;&nbsp; // Make the window the size of the main dialog.
 &nbsp;&nbsp; CFormView::OnInitialUpdate();
 &nbsp;&nbsp; GetParentFrame()-&gt;RecalcLayout();
 &nbsp;&nbsp; ResizeParentToFit( /*FALSE*/ );
}
</code></pre>
<p class=indent>
andyr@gate.net, programmer.misc, 8/11/95</p>
<p>
<b>How do I use new views with a doc template?</b></p>
<p>
In an application created with AppWizard, you have two options: Change the derivation of the current view, or create a new view and use the new view in your MDI application along with the original view.</p>
<p>
To create a new view, use ClassWizard to create a new class derived from CView. After the class has been created, the steps to use the new view or to modify the view provided by AppWizard are the same.
<ol>
<li>
Modify the header file for the view class to change all references to CView to the name of the desired view class. In this example, the class is derived from CScrollView. Usually, this step involves changing the class the view class is derived from as follows:<pre><code>class CMyView : public CScrollView
</code></pre>
</li>
<li>
Modify the implementation file for the view class to change all references to CView to the name of the desired view class. This involves changing the IMPLEMENT_DYNCREATE line as follows:<pre><code>IMPLEMENT_DYNCREATE(CMyView, CScrollView)
</code></pre>
<p class=tl>
Changing the BEGIN_MESSAGE_MAP as follows:</P><pre><code>BEGIN_MESSAGE_MAP(CMyView, CScrollView)
</code></pre>
<p class=tl>
and changing any other references to CView to CScrollView.</P></li>
<li>
No further modifications are required if you are modifying a view created by App Wizard. If you create a new view, find the AddDocTemplate() call in the CWinApp::InitInstance() function. The third parameter to AddDocTemplate() is RUNTIME_CLASS(CSomeView). To replace the current view with the new view class, change CSomeView to CMyView. In an MDI application, you can use multiple view types by adding a second AddDocTemplate() call that changes RUNTIME_CLASS(CSomeView) to RUNTIME_CLASS(CMyView).</li>
</ol>
<p>
For more information, please see Knowledge Base article Q99562, "Switching Views in a Single Document Interface Program."</p>
<p class=indent>
Visual C++ Knowledge Base article Q99562, 6/7/95</p>
<p>
<b>How do I change the background color of a view?</b></p>
<p>
To change the background color for a CView, CFrameWnd, or CWnd object, process the WM_ERASEBKGND message. The following code shows how: </p>
<pre><code>BOOL CSampleView::OnEraseBkgnd(CDC* pDC)
{
 &nbsp;&nbsp; // Set brush to desired background color.
 &nbsp;&nbsp; CBrush backBrush(RGB(255, 128, 128));
 &nbsp;&nbsp; // Save old brush.
 &nbsp;&nbsp; CBrush* pOldBrush = pDC-&gt;SelectObject(&amp;backBrush);
 &nbsp;&nbsp; CRect rect;
 &nbsp;&nbsp; pDC-&gt;GetClipBox(&amp;rect);&nbsp;&nbsp;&nbsp;&nbsp; // Erase the area needed.
 &nbsp;&nbsp; pDC-&gt;PatBlt(rect.left, rect.top, rect.Width(), 
 &nbsp;&nbsp; rect.Height(), PATCOPY);
 &nbsp;&nbsp; pDC-&gt;SelectObject(pOldBrush);
 &nbsp;&nbsp; return TRUE;
}
</code></pre>
<p>
I solved the problem like this:</p>
<pre><code>HBRUSH dlgtest::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor) 
{
 &nbsp;&nbsp; switch (nCtlColor)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case CTLCOLOR_BTN:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case CTLCOLOR_STATIC:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDC-&gt;SetBkMode(TRANSPARENT);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case CTLCOLOR_DLG:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CBrush*&nbsp;&nbsp;&nbsp;&nbsp; back_brush;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COLORREF&nbsp;&nbsp;&nbsp; color;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; color = (COLORREF) GetSysColor(COLOR_BTNFACE);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; back_brush = new CBrush(color);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (HBRUSH) (back_brush-&gt;m_hObject);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp; }
 &nbsp;&nbsp; return(CFormView::OnCtlColor(pDC, pWnd, nCtlColor));
}
</code></pre>
<p class=indent>
Tim, tfiner@vrli.com, email, 9/10/95</p>
<p>
<a name="mfcfaqcurview"></a><b>How do I get the current view?</b></p>
<p>
The best thing to do is to pass the view along as a parameter. If this is impractical, you can get the view if you <i>know </i>that it is the currently active document and the currently active view. For details, see the Visual C++ Knowledge Base article Q108587, "Get Current CDocument or CView from Anywhere."</p>
<p>
In brief, use</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;((CFrameWnd*) AfxGetApp()-&gt;m_pMainWnd))-&gt;GetActiveDocument()
</code></pre>
<p>
and</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;((CFrameWnd*)(AfxGetApp()-&gt;m_pMainWnd))-&gt;GetActiveView()
</code></pre>
<p>
to get the document and the view. It might be a good idea to wrap them in static functions in your CMyDoc and CMyView and check that they are of the correct RUNTIME_CLASS.</p>
<p>
However, if the view isn't the currently active view or if you can run OLE in place, this won't work.</p>
<p class=indent>
null@diku.dk, programmer.misc, 6/8/95</p>
<p>
<b>How do I create multiple views on one document?</b></p>
<p>
The CDocTemplate::CreateNewFrame() function creates additional views of a document in an MDI application written with MFC. To call this function, specify a pointer to a CDocument object (the document for which the function will create a view) and a pointer to a frame window that has the properties to duplicate. Typically, the second parameter of this function is NULL.</p>
<p>
When an application calls CreateNewFrame(), the function creates a new frame window and a view in the frame window. The frame window type and view type depend on the document template (CDocTemplate) associated with the document specified in the CreateNewFrame() call.</p>
<p>
The CHKBOOK MFC sample application that ships with Visual C++ also demonstrates creating additional frames and views for documents. Check out CHKBOOK.CPP, the CChkBookApp::OpenDocumentfile() function.</p>
<p>
Another example of using CreateNewFrame() is the MULTVIEW sample application.</p>
<p>
CreateNewFrame() creates both a frame and a view; not only a view. If, for some reason, CreateNewFrame() does not quite address your situation, the source code for CreateNewFrame() is quite useful to demonstrate the steps required to create frames and views.</p>
<p class=indent>
Visual C++ Knowledge Base article Q100993 with mods, 6/25/95</p>
<p>
<b>How do I get all the views in an MDI app?</b></p>
<p>
You need to use some functions that are undocumented:
<ul type=disc>
<li>
CDocument::GetFirstViewPosition(); // DOCCORE.CPP<br><br></li>
<li>
CDocument::GetNextView(); // DOCCORE.CPP<br><br></li>
<li>
CMultiDocTemplate::GetFirstDocPosition(); // DOCMULTI.CPP<br><br></li>
<li>
CMultiDocTemplate::GetNextDoc(); // DOCMULTI.CPP</li>
</ul>
<p>
You'll also need to mess with the m_templateList member of CWinApp.</p>
<p class=indent>
blaszczak@Bix.com, mfc-l, 7/11/95</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;This has changed with MFC version 4.0. There's now a class called CDocManager that can get to all of the views/docs for you. Check out MFC Internals for details. </p>
<p class=indent>
Scot Wingo, scot@stingsoft.com</p>
<p>
<b>How do I make a CScrollView "mouse scrollable"?</b></p>
<p>
Download AUTOSV.LZH from the MSMFC library on CIS. This code shows you how to implement a secondary message loop, taking care of the mouse activity. Hooks are provided to customize the code. Freeware.</p>
<p class=indent>
Patrick Philippot, CIS email, 8/3/95</p>
<h3><a name="mfcfaqdocuments"></a>Documents</h3>
<p>
<b>Do I have to use the document/view architecture?</b></p>
<p>
MFC does not force you to use document/views. Check out the HELLO, MDI, and HELLOAPP samples—they don't use it at all. Most MFC features can be used in non-document/view applications. You do lose features like print preview and many OLE features when you don't go document/view.</p>
<p class=indent>
Scot Wingo, scot@stingsoft.com, 6/7/95</p>
<p>
<b>How do I get the current document?</b></p>
<p>
See <a href="#mfcfaqcurview">"How do I get the current view?"</a> for details.</p>
<p>
<b>When are documents destroyed?</b></p>
<p>
In SDI applications, the document is deleted when the application exits. In MDI applications, the document is deleted when the last view on the document is closed. To help keep your document SDI/MDI compatible, you should delete the document's data in the virtual DeleteContents() function, not in the destructor.</p>
<p class=indent>
Richard Hazenberg, drmcode@euronet.nl, programmer.misc, 6/24/95</p>
<p>
<b>How do I create multiple documents?</b></p>
<p>
To add support for additional document types, you can create and register additional CMultiDocTemplate objects with your CWinApp derived object. This technique is illustrated in the MULTDOCS sample application. The general steps needed to add an additional document type to an MFC application are listed below.
<ol>
<li>
Use AppWizard to create a new document class and a new view class.<br><br></li>
<li>
Use the Resource Editor to add a new resource string to support the new document class. For more information on the format of the document template string resource, see the topic "How to Interpret a Document Template String."<br><br></li>
<li>
Use the Resource Editor to add an additional icon and menu resource to the application. Note that the ID for each of these resources needs to be the same ID as the resource ID used for the document template string created in Step 2. This ID is used by the CMultiDocTemplate class to identify the resources associated with the additional document type.<br><br></li>
<li>
In the application's InitInstance() function, create another CMultiDocTemplate object and register it with the CWinApp::AddDocTemplate() function. For example:<pre><code>CMultiDocTemplate* pDocTemplate2 = new CMultiDocTemplate(
IDR_DOC2TYPE, RUNTIME_CLASS(CDoc2),
RUNTIME_CLASS(CMDIChildWnd), RUNTIME_CLASS(CView2));
AddDocTemplate(pDocTemplate2);
</code></pre>
</li>
</ol>
<p>
And finally, add the custom serialization and painting code to your new document and view classes.</p>
<p class=indent>
MS FAQ, 6/25/95</p>
<p>
<b>How do I get a list of open documents?</b></p>
<p>
The code below demonstrates how to retrieve a list of pointers to all CDocuments that were created using a CDocTemplate object.</p>
<p>
In the code below, CMyApp is derived from CWinApp. The variable m_templateList is a CPtrList object that is a member of CWinApp, and it contains a list of pointers to all of the document templates (CDocTemplates). The CDocTemplate functions GetFirstDocPosition() and GetNextDoc() are used to iterate through the list of documents for each document template.</p>
<pre><code>void CMyApp::GetDocumentList(CObList * pDocList)
{
 &nbsp;&nbsp; ASSERT(pDocList-&gt;IsEmpty());
 &nbsp;&nbsp; POSITION pos = m_templateList.GetHeadPosition();
 &nbsp;&nbsp; while (pos)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CDocTemplate* pTemplate = 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (CDocTemplate*)m_templateList.GetNext(pos);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; POSITION pos2 = pTemplate-&gt;GetFirstDocPosition();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (pos2) 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CDocument * pDocument;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((pDocument=pTemplate-&gt;GetNextDoc(pos2)) != NULL)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDocList-&gt;AddHead(pDocument);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp; }
}
</code></pre>
<p>
There are two public member functions of the CDocTemplate class that are not documented in the reference manual or the online help. However, these are public member functions defined in the CDocTemplate class and provide simple functionality for traversing the list of open documents. These functions operate as follows:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=16%>Function</td>
<td width=84%>Virtual POSITION GetFirstDocPosition() const;</td>
</tr>
<tr valign=top>
<td width=16%>Remarks</td>
<td width=84%>Call this function to get the position of the first document in the list of open documents associated with the template.</td>
</tr>
<tr valign=top>
<td width=16%>Return Value</td>
<td width=84%>A POSITION value that can be used for iteration with the GetNextDoc member function.</td>
</tr>
<tr valign=top>
<td width=16%>Function</td>
<td width=84%>Virtual CDocument* GetNextDoc(POSITION&amp; rPosition) const;</td>
</tr>
<tr valign=top>
<td width=16%>rPosition</td>
<td width=84%>A reference to a POSITION value returned by a previous call to the GetNextDoc or GetFirstDocPosition member function. This value must not be NULL.</td>
</tr>
<tr valign=top>
<td width=16%>Remarks</td>
<td width=84%>Call this function to iterate through all of the document template's open documents. The function returns the document identified by rPosition and then sets rPosition to the POSITION value of the next document in the list. If the retrieved document is the last in the list, then rPosition is set to NULL.</td>
</tr>
<tr valign=top>
<td width=16%>Return Value</td>
<td width=84%>A pointer to the view identified by rPosition.</td>
</tr>
</table><br>
<p class=indent>
Visual C++ Knowledge Base article Q106455, 6/25/95</p>
<p>
Note that this is only valid for MFC version 3.2 and lower; MFC version 4.0 follows:</p>
<pre><code>void CMyApp::DoSomethingToAllDocs()
{
 &nbsp;&nbsp; CObList&nbsp; pDocList;
 &nbsp;&nbsp; POSITION pos = GetFirstDocTemplatePosition();
 &nbsp;&nbsp; while(pos)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CDocTemplate* pTemplate = GetNextDocTemplate(pos); 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; POSITION pos2 = pTemplate-&gt;GetFirstDocPosition();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(pos2)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CDocument* pDocument;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(pDocument = pTemplate-&gt;GetNextDoc(pos2))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pDocList.AddHead(pDocument);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp; }
 &nbsp;&nbsp; if(!pDocList.IsEmpty()){
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pos = pDocList.GetHeadPosition();
 &nbsp;&nbsp; while(pos)
 &nbsp;&nbsp; {&nbsp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Call some CDocument function for each document.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( (CDocument*)pDocList.GetNext(pos) )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt;UpdateAllViews(NULL);
 &nbsp;&nbsp; }
}
</code></pre>
<p class=indent>
mcontest@universal.com, email, 9/22/95</p>
<p>
<b>How do I keep my application from creating a new document at startup?</b></p>
<p>
Add this call:</p>
<pre><code>cmdInfo.m_nShellCommand = CCommandLineInfo::FileNothing
</code></pre>
<p>
just before the call to ProcessShellCommand in the app's InitInstance.</p>
<p class=indent>
lechner-cos1@kaman.com, email, 1/6/96</p>
<h2><a name="mfcfaqolecq"></a>OLE Class Questions</h2>
<p>
<a href="#mfcfaqstruct">Structured Storage/Compound Files</a><br>
<a href="#mfcfaqolecont">OLE Controls (Previously Called OCXs)</a></p>
<h3><a name="mfcfaqstruct"></a>Structured Storage/Compound Files</h3>
<p>
<b>When I upgraded, I could not read my files generated by the old version of MFC. What do I do?</b></p>
<p>
There may be an easier way, but here is how I did it:</p>
<p>
Use VERSIONABLE_SCHEMA and GetObjectSchema to identify the version. If it is an old version, then it is stored in OLE version 1.0 format. To read this format, first read a WORD and a CString (type and name info). Next is the OLE data itself (the hard part). Use the following steps:
<ol>
<li>
Use StgCreateDocfile to create a temporary Compound File.<br><br></li>
<li>
Use OleConvertOLESTREAMToIStorage to copy the data to the Compound file, converting to OLE version 2.0 format.<br><br></li>
<li>
Call OleLoad using the IStorage to get an IUnknown pointer, then call QueryInterface to set the COleClientItem::m_lpObject member, and set m_nDrawAspect to DVASPECT_CONTENT.<br><br></li>
<li>
Release the IUnknown pointer and the IStorage pointer.<br><br></li>
<li>
The OleConvertOLESTREAMToIStorage code requires an OLESTREAM implementation. Copy the code from Visual C++ 1.0 MFC code.</li>
</ol>
<p>
This actually works. There are some issues with messing with the schema parameter, and I have not implemented writing OLE 1/MFC files. Code available on request.</p>
<p class=indent>
Ron Jones, ronjones@xnet.com, via programmer.tools, 5/9/95</p>
<h3><a name="mfcfaqolecont"></a>OLE Controls (Previously Called OCXs)</h3>
<p>
<b>What is an OLE control?</b></p>
<p>
OLE controls are the 32-bit successor to 16-bit VBX controls. Instead of being stored in a plain DLL and having functional interfaces, OLE controls rely on OLE Automation. Hopefully, this will make the interface more flexible and easier to use than VBXs.</p>
<p>
Although OLE controls use OLE, they are not object oriented. There is a flat set of properties you have access to and you can not apply OO techniques such as inheritance, polymorphism, etc., to them. In my opinion, this can be pretty frustrating to the MFC programmer who is used to the OO techniques.</p>
<p class=indent>
Scot Wingo, scot@stingsoft.com, 6/25/95</p>
<p>
<b>How do I write OLE controls?</b></p>
<p>
In Visual C++ 2.<i>x</i>, Microsoft released the OLE Control Developer's Kit (CDK). You use that kit and its tools to write OLE controls. In Visual C++ 4.0, this is no longer separate and you now just run the Control Wizard. Check your Visual C++ documentation for more info.</p>
<p class=indent>
Scot Wingo, scot@stingsoft.com, 6/25/95</p>
<p>
<b>What versions of MFC support OLE control containment?</b></p>
<p>
MFC 4.0 supports OLE control containment. Earlier versions of MFC don't unless you roll your own. (Yuck!)</p>
<p>
<b>How do I get application-specific control bars to disappear when editing in place?</b></p>
<p>
Add CBRS_HIDE_INPLACE to Create() of the toolbar.</p>
<p>
Example:</p>
<pre><code>m_wndFormBar.Create(this,
 &nbsp;&nbsp; WS_CHILD|WS_VISIBLE|CBRS_TOP|CBRS_HIDE_INPLACE,IDW_FORMBAR)
</code></pre>
<p class=indent>
Paul Rony, 102615.601@compuserve.com</p>
<h2><a name="mfcfaqwosa"></a>WOSA Class Questions</h2>
<p>
<a href="#mfcfaqcrecordset">CRecordSet</a><br>
<a href="#mfcfaqwinsock">WinSock</a></p>
<h3><a name="mfcfaqcrecordset"></a>CRecordSet</h3>
<p>
<b>When I add a CRecordSet class, I get tons of linker errors.</b></p>
<p>
If you haven't told AppWizard to use Database Support when you created your project, AppWizard doesn't include the database headers. If you add "#include" in your stdafx.h, CRecordSet will be "legalized." Then open the Linker Options window and add the library: "odbc". This avoids tons of linker errors.</p>
<p class=indent>
Wolfgang Bessler, bessler@highland.swb.de, comp.lang.c++, 6/5/95</p>
<p>
<b>I need a CRecordSet::Find(). What should I do?</b></p>
<p>
Use the WHERE clause in SQL.</p>
<p class=indent>
mikeblas@interserv.com, mfc-l, 10/10/95</p>
<h3><a name="mfcfaqwinsock"></a>WinSock</h3>
<p>
<b>I'm having problems with CSocket blocking—what's up?</b></p>
<p>
I've worked around this by creating a dialog box that I pop up after calling Connect(). For example:</p>
<pre><code>CMySocket MySocket;
MySocket.Create();
MySocket.Connect("mysmtphost",25);
DummyDlg DummyDialog;
MySocket.m_pDialog=&amp;DummyDialog;
DummyDialog.DoModal();
</code></pre>
<p>
This suspends the thread until MySocket sends a WM_CLOSE message to DummyDialog. I'd rather it look like:</p>
<pre><code>MySocket.m_hEvent=CreateEvent(...);
WaitForSingleObject(MySocket.m_hEvent,INFINITE);
</code></pre>
<p>
But that stops all processing of MySocket.</p>
<p class=indent>
Cynthia Jennings (idlewild@is.net), programmer.win32, 6/19/95</p>
<h2><a name="mfcfaqdll"></a>DLL and Build Questions</h2>
<p>
If you have questions about extension and user DLLs, be sure to read MFC 3.1 Technical Notes 11 and 33. Volume 2 of the documentation has more info too. Finally, try searching on the sample names DLLHUSK (extension DLL) and DLLTRACE (user DLL) in Books Online.</p>
<p>
<b>Do I need a CWinApp object in a DLL?</b></p>
<p>
The Microsoft Foundation Class Library supports two types of DLLs: _USRDLL and _AFXDLL. The _USRDLL model requires one CWinApp object to perform the initialization and cleanup of the Microsoft Foundation Class Library Windows classes that the DLL uses. This requirement is described in MFC Tech Note 11; the DLLTRACE sample demonstrates a _USRDLL that contains a CWinApp object.</p>
<p>
An _AFXDLL does not require a CWinApp object. Because it shares the Microsoft Foundation Class Library classes with the application, it does not require a CWinApp to provide initialization and cleanup. Instead, an _AFXDLL requires a special version of LibMain() and a DLL initialization function.</p>
<p class=indent>
Visual C++ Knowledge Base article Q109031, 6/4/95</p>
<p>
<b>How should I define the WEP in a MFC DLL?</b></p>
<p>
In a dynamic-link library (DLL) built with Microsoft Foundation Class Library version 2.0, the USRDLL model uses the WEP() (Windows exit procedure) function provided in the C run-time library. Because the code uses the C library WEP() function, the destructors for static and global objects in the DLL are called and the CWinApp::ExitInstance() function for the DLL application object is called.</p>
<p>
See Visual C++ Knowledge Base article Q98374 and Technical Notes 11 and 33.</p>
<p class=indent>
Visual C++ Knowledge Base article Q98374, 6/7/95</p>
<p>
<b>How do I build an "extension DLL"?</b>
<ol>
<li>
When you're building a 32-bit extension DLL, define _AFXEXT on the compiler command line. If you look in AFXVER_.H, you'll see that this forces _AFXDLL to also be defined. So an "AFXEXT" DLL is an AFXDLL.<br><br></li>
<li>
When _AFXDLL is defined, AfxGetResourceHandle returns a value stored in MFC's global data, which is shared by the .EXE, the extension DLL, and the MFC DLL. The handle returned identifies the module that will be searched first when looking for a resource.<p class=tl>
(See the source code for AfxFindResourceHandle() if you're curious about the order of the search.)</P></li>
<li>
Strictly speaking, what we need to load a resource is a module handle rather than an instance handle. (Instances share modules—that is, code and resources—but have different data.) A DLL has a module handle that is distinct from the handle of the .EXE.<br><br></li>
<li>
You can use ::GetModuleHandle to get the handle for your DLL, then pass it to AfxSetResourceHandle so that your DLL is the first place searched for resources. But note that this removes the .EXE module from modules searched. You'll probably want to save a copy of the handle returned by AfxGetResourceHandle before calling AfxSetResourceHandle, then restore it once you're done loading the DLL resource.</li>
</ol>
<p class=indent>
Charlie Kester, Microsoft Developer Support, MSMFC, 7/19/95</p>
<p>
<b>How can I manage resources in a resource-only DLL and still benefit from ClassWizard?</b></p>
<p>
zThe following text is available as RESDLL.ZIP in the MSMFC library on CompuServe (applies to Visual C++ version 2.0):</p>
<p>
"How To Manage An MFC Project Storing Its Resources Into A Resource-Only DLL"</p>
<p>
Software localization is much easier when your project stores its resources in a resource-only DLL. There are also many situations where storing the project's resources in a DLL can be a good idea.</p>
<p>
However, if this project is an MFC project, doing so will generate a major drawback: You will not benefit from the ClassWizard capabilities any longer because the resources will be managed in a separate project.</p>
<p>
However, there's a trick that you can use to develop your project as if it were a standard project, while being able to quickly switch to the resource-only DLL model. Here's how to proceed:</p>
<p>
<b>Method 1</b>
<ol>
<li>
Create your project as usual using AppWizard (we'll name it TEST).<br><br></li>
<li>
Close the project and create a new DLL project in the same directory (call it RESDLL). When you click on the Create button, Visual C++ opens the Add file dialog. Take this opportunity to add the resource file of the previous project (TEST.RC) to this new project.<br><br></li>
<li>
Before being able to compile the resources of the TEST project as a resource-only DLL, you must add the /NOENTRY option to the linker. Unfortunately, the Settings dialog box of Visual C++ doesn't allow you to do that in a simple way:<p class=tl>
Select Project|Settings from the man menu.</P><p class=tl>
Click the Link tab.</P><p class=tl>
Select General from the Category combo box.</P><p class=tl>
In the Object/Library Modules field, remove all references to any .LIB file (they are useless) and add /NOENTRY. This option should then appear in the Common Options display area.</P><p class=tl>
Click OK and compile. You now have a DLL containing only the resources for your project.</P></li>
<li>
Do not open the TEST.MAK project. Instead, copy TEST.MAK to TEST_RES.MAK in your project directory.<br><br></li>
<li>
Open TEST_RES.MAK and remove TEST.RC from the project files.<br><br></li>
<li>
Select Project|Settings, click on the General tab, and add "USE_RESDLL" to the list of Preprocessor Definitions.<br><br></li>
<li>
Open TEST.H and modify the class declaration of CTestApp this way:<pre><code>public:
CTestApp();
#ifdef USE_RESDLL
public:
virtual int ExitInstance();
private:
HINSTANCE m_hInstDLL;
#endif // USE_RESDLL
</code></pre>
</li>
<li>
Open TEST.CPP and modify CTestApp::InitInstance as follows. Also, add the newly declared ExitInstance member function:<pre><code>BOOL CTestApp::InitInstance()
{
// Standard initialization.
// If you are not using these features and wish to reduce the size
// of your final executable, you should remove from the following
// the specific initialization routines you do not need.
#ifdef USE_RESDLL
if ((m_hInstDLL = LoadLibrary("resdll.dll")) == NULL)
{
return FALSE; // Failed to load the localized resources.
}
else
{
AfxSetResourceHandle(m_hInstDLL); 
// Get resources from the DLL.
}
#endif
// ....
#ifdef USE_RESDLL
int CTestApp::ExitInstance()
{
FreeLibrary(m_hInstDLL);
return CWinApp::ExitInstance();
}
#endif
</code></pre>
</li>
<li>
Compile. TEST_RES.EXE should work very nicely, loading its resources from the DLL.<br><br></li>
<li>
Close the project and open TEST.MAK. Compile. TEST.EXE should also work very well but this time, the resources are loaded from the .EXE file because you have not defined USE_RESDLL in this version of the project.</li>
</ol>
<p class=indent>
<B><b>Warning</b></B>&nbsp;&nbsp;&nbsp;When switching from one model to another, you must either Rebuild All or touch TEST.CPP. Otherwise, you'll have problems.</p>
<p>
Now, you are able to modify your resources and to use ClassWizard when you work with TEST.MAK. To build the resource-only DLL version of the project, just switch to TEST_RES.MAK after recompiling RESDLL (RESDLL.MAK) if changes have been made to the resources.</p>
<p>
It's that easy!</p>
<p>
<b>Method 2</b>
<ol>
<li>
Proceed as above in Steps 1, 2, and 3.<br><br></li>
<li>
Instead of creating a new project, copy TEST.RC to RESDLL.RC. Remove TEST.RC from your project and add RESDLL.RC. A different name is somewhat safer.<br><br></li>
<li>
Double-click RESDLL.RC to trigger a rebuild of the .CLW file.<br><br></li>
<li>
Apply the "Exclude File from Build" command to RESDLL.RC. (Project|Settings, General Page, "Exclude File From Build")<br><br></li>
<li>
Delete TEST.CLW and TEST.RC.</li>
</ol>
<p>
Now TEST and RESDLL will work together through the ClassWizard. The resources defined in RESDLL.RC will not be added to TEST.EXE. This method is simpler but doesn't allow you to test your program in both cases (resources in the DLL or resources linked to the .EXE file). I prefer the latter when developing because I do not have to bother about orphaned DLLs when a GPF occurs (although this is less a problem under Windows NT).</p>
<p>
Don't forget to recompile the DLL before testing your program each time you modify the resources. A batch file calling NMAKE installed in the Tools menu will certainly be faster than switching from project to project. Using the "New Target" facility won't help in that case.</p>
<p>
It would be nice if Visual C++ had the same capability as Borland C++: a project can contain multiple independent targets. So, the developer is able to manage DLL and .EXE creation from within the same project.</p>
<p class=indent>
Patrick Philippot, CIS email, 8/3/95</p>
<p>
<b>I am having some problems with exports/imports and extension DLLs. Where can I go for help?</b></p>
<p>
This is a very complex subject. George Shepard and I actually wrote about this in our "MFC Internals" column in <i>Visual C++ Developer's Journal</i>, at <a href="http://www.vcdj.com">http://www.vcdj.com.</a> Also, Chapter 9 of our book, <i>MFC Internals</i>, covers MFC and DLLs (extension and regular) in great detail. </p>
<p class=indent>
Scot Wingo, scot@stingsoft.com</p>
<p class=indent>
</p>
<h2><a name="mfcfaqtips"></a>MFC Tips, Tricks, and Caveats</h2>
<p>
<b>What's the best way to convert my C Windows App to MFC?</b></p>
<p>
Microsoft and Symantec have jointly developed a tool that helps you make the move from a C Windows application to MFC. It's called the MFC Migration Kit. You can find it on the Visual C++ 2.<i>x</i> CD-ROM in the MFCKIT directory. The kit is also available from the Microsoft Software Library and from Symantec. </p>
<p>
<b>Why is my MFC application running slow?</b></p>
<p>
MFC apps should be nice and snappy. Make sure you are not building the debug version and that you have the trace options off (MFCTRACE.EXE). If your application continues to be slow, try doing some quick profiling to see if you are making any redundant calls.</p>
<p class=indent>
Scot Wingo, scot@stingsoft.com, 5/31/95</p>
<p>
<b>How can I create an application that is initially maximized?</b></p>
<p>
For new applications, this can be done with AppWizard during Step 4. During Step 4, select Advanced, and then choose the Main Frame tab. Check the Maximized option.</p>
<p>
For an MDI application, in the CWinApp::InitInstance() function, set CWinApp::m_nCmdShow to SW_SHOWMAXIMIZED before calling pMainFrame-&gt;ShowWindow(m_nCmdShow). In an application generated by AppWizard, the code is as follows:</p>
<pre><code>// Create main MDI Frame window.
CMainFrame* pMainFrame = new CMainFrame;
if (!pMainFrame-&gt;LoadFrame(IDR_MAINFRAME))
 &nbsp;&nbsp; return FALSE;

<i>m_nCmdShow = SW_SHOWMAXIMIZED;&nbsp; // ADD THIS LINE!</i>

pMainFrame-&gt;ShowWindow(m_nCmdShow);
pMainFrame-&gt;UpdateWindow();
m_pMainWnd = pMainFrame;
</code></pre>
<p>
In an SDI application, in the CWinApp::InitInstance() function, set CWinApp::m_nCmdShow to SW_SHOWMAXIMIZED before calling OnFileNew(). For example, in an application generated by AppWizard,&nbsp; the code is as follows:</p>
<pre><code>m_nCmdShow = SW_SHOWMAXIMIZED;
// Create a new (empty) document.
OnFileNew();
</code></pre>
<p class=indent>
Visual C++ Knowledge Base article Q109039, 6/4/95</p>
<p>
<b>How do I enable TRACE macros in my app?</b></p>
<p>
If you use Visual C++ 1.0, run the TRACER application from your Microsoft Visual C++ program group (its icon has the title "MFC Trace Options"). Select "Enable Tracing," then choose OK. </p>
<p>
If you use Microsoft C/C++ 7.0, you must copy the AFX.INI file from the Microsoft Foundation Class Library source directory (by default, C:\C700\MFC\SRC) to your Windows directory (by default, C:\WINDOWS). This file should contain a section such as the following:</p>
<pre><code>[Diagnostics]
 &nbsp; TraceEnabled = 1
 &nbsp; TraceFlags = 0
</code></pre>
<p>
As long as TraceEnabled is set to 1, tracing is enabled.</p>
<p>
This AFX.INI file is the same for both C/C++ 7.0 and Visual C++ 1.0. In Visual C++ 2.x, the TRACE output automatically goes to the 'Debug' window when you run in the debugger.</p>
<p class=indent>
Visual C++ Knowledge Base article Q109039, 6/7/95</p>
<p>
<b>How do I perform background processing in my application?</b></p>
<p>
Many applications perform lengthy processing "in the background" during intervals that the user is not otherwise interacting with the application. In an application developed for the Microsoft Windows operating system, an application can perform background processing by splitting a lengthy process into many small fragments. After processing each fragment, the application yields execution control to Windows using a PeekMessage() loop.</p>
<p>
An application developed with the Microsoft Foundation Class Library can perform background processing either by using the PeekMessage() loop in the library code's main message loop or by embedding another PeekMessage() loop in the application.</p>
<p>
See Visual C++ Knowledge Base Q99999 for more info.</p>
<p class=indent>
Visual C++ Knowledge Base article Q99999, 6/7/95</p>
<p>
<b>How do I send a message to another thread?</b></p>
<p>
Try using SendNotifyMessage() to send messages to another thread.</p>
<p class=indent>
null@diku.dk, via programmer.misc, 6/18/95</p>
<p>
<b>Does Microsoft use MFC in their products? Which ones?</b></p>
<p>
There are many Microsoft apps written in MFC. Sometimes it's just not obvious. (To name a few: Bookshelf, Bob, WordArt OLE server, Visual C++ (of course), Windows 95 Paint, Windows 95 WordPad, some portions of Windows 95 FAX software, some Windows 95 games I know of....)</p>
<p>
In the future, there are more apps coming out using MFC. I don't have a way to track all of these uses, so there is certainly more that I'm not aware of or can't remember. I don't expect Word or Excel to ever use MFC—they have way too much legacy code and they don't see any customer benefit to rewriting to MFC. But my point is—definitely for new code, Microsoft is using MFC. Even some "old" code is taking advantage of MFC in future versions.</p>
<p class=indent>
Dean McCrory, MSMFC, 6/8/95</p>
<p>
<b>How do I limit my MFC application to one instance?</b></p>
<p>
Look at the Microsoft C++ sample ONETIME.</p>
<p>
In brief:</p>
<pre><code>const char* MyMainWndClassName = "MyMainWndXQW"
BOOL CMyApp::InitApplication()
{
 &nbsp;&nbsp; // Call base class. Default version does nothing.
 &nbsp;&nbsp; CWinApp::InitApplication();
 &nbsp;&nbsp; WNDCLASS wndcls;
 &nbsp;&nbsp; // Start with NULL defaults.
 &nbsp;&nbsp; memset(&amp;wndcls, 0, sizeof(WNDCLASS));&nbsp;&nbsp; 
 &nbsp;&nbsp; // Get class information for default window class.
 &nbsp;&nbsp; ::GetClassInfo(AfxGetInstanceHandle(),"AfxFrameOrView",&amp;wndcls);
 &nbsp;&nbsp; // Substitute unique class name for new class.
 &nbsp;&nbsp; wndcls.lpszClassName = MyMainWndClassName;
 &nbsp;&nbsp; // Register new class and return the result code.
 &nbsp;&nbsp; return ::RegisterClass(&amp;wndcls);
}
</code></pre>
<p>
And:</p>
<pre><code>BOOL CMyApp::FirstInstance()
{
 &nbsp;&nbsp; CWnd *PrevCWnd, *ChildCWnd;
 &nbsp;&nbsp; // Determine if another window with our class name exists.
 &nbsp;&nbsp; PrevCWnd = CWnd::FindWindow(MyMainWndClassName, NULL);
 &nbsp;&nbsp; if (PrevCWnd != NULL)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // If so, does it have any pop-ups?
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ChildCWnd=PrevCWnd-&gt;GetLastActivePopup();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Bring the main window to the top.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PrevCWnd-&gt;BringWindowToTop();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // If iconic, restore the main window.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PrevCWnd-&gt;IsIconic())
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PrevCWnd-&gt;ShowWindow(SW_RESTORE);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // If there are pop-ups, bring them along too!
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PrevCWnd != ChildCWnd)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ChildCWnd-&gt;BringWindowToTop();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Return FALSE. This isn't the first instance
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // and we are done activating the previous one.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // First instance. Proceed as normal.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return TRUE;
}
CMyApp::InitInstance()
{
 &nbsp;&nbsp; if (!FirstInstance()) 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;
 &nbsp;&nbsp; // ...
}
</code></pre>
<p class=indent>
null@diku.dk, programmer.tools, 6/19/95</p>
<p>
See also Win32 SDK Knowledge Base article Q124134 ("Allowing Only One Application Instance on Win32s") and Jeffrey Richter's <i>Advanced Windows NT</i>, chapter 7, "Prohibiting Multiple Instances of an Application from Running: The MultInst Sample Application" (available on the MSDN Library CD).</p>
<p class=indent>
null@diku.dk, email, 8/8/95</p>
<p>
Update—these were posted to mfc-l:</p>
<p>
I have each InitApplication() create a semaphore. If GetLastError() returns ERROR_ALREADY_EXISTS then I know that some other application is already running and has gotten that far, so I bail.</p>
<pre><code>Yourapp::InitInstance()
{
 &nbsp;&nbsp; hMutexOneInstance = 
 &nbsp;&nbsp; CreateMutex(NULL,TRUE,_T("PreventSecondInstance"));
 &nbsp;&nbsp; if(GetLastError() == ERROR_ALREADY_EXISTS)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bFound = TRUE;
 &nbsp;&nbsp; if(hMutexOneInstance) 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReleaseMutex(hMutexOneInstance);
 &nbsp;&nbsp; return (bFound == TRUE) ? FALSE : TRUE;
}
</code></pre>
<p class=indent>
mcontest@universal.com</p>
<p>
There is a nice section in Jeffrey Richter's book <i>Advanced Windows NT</i> about this. Essentially, it uses shared data segments between processes. 
<ol>
<li>
In your main file, add: <pre><code>#pragma data_seg(".SharedData") 
LONG nUsageCount = -1; 
#pragma data_seg() 
</code></pre>
</li>
<li>
In your Application's InitInstance(), call:<pre><code>InterlockedIncrement ( &amp;nUsageCount ); 
</code></pre>
<p class=tl>
This function returns the incremented value of the variable. If it is nonzero, you know that you are not the first App. </P></li>
<li>
In your Application's ExitInstance(), call: <pre><code>InterlockedDecrement( &amp;nUsageCount ); 
</code></pre>
</li>
<li>
In your .DEF file, have the following lines (note that the segment name you give here should match the one in the application's main file):<pre><code>SEGMENTS 
 &nbsp;&nbsp; .SharedData shared 
</code></pre>
</li>
</ol>
<p class=indent>
abalakri@us.oracle.com</p>
<p>
You'd better use one of the built-in synchronization methods. See the Win32 Knowledge Base article Q124134, "Allowing Only One Application Instance on Win32s," for a sample of using a memory-mapped file for synchronization. It doesn't include starting the previous instance, but if you detect that you're not the only one running, it should be pretty simple: If CreateFileMapping fails, try to find the previous instance from the window class name. If it's not found, sleep for a while and start over (with CreateFileMapping). In this way, either you will find the other instance when it gets around to creating its window or CreateFileMapping will eventually succeed. The advantage of using CreateFileMapping instead of CreateObject is that it also works on Win32s.</p>
<p class=indent>
nuj@kruger.dk</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;There's a sample of this that was contributed by john@jing.com (John Xu) called onetime4.zip that is in the MFC FAQ archive.</p>
<p>
<b>How do I get my MFC app to use the Registry on Win32 platforms?</b></p>
<p>
Just make a call to SetRegistryKey("MyCompany") in your CWinApp class and pass it a string (typically your company name). This string will define where in the registry the data goes: HKEY_CURRENT_USER\Software\MyCompany\\\</p>
<p>
After making this call just use the normal WriteProfile<i>xxx</i>() routines and the data will go to the registry instead of to an .INI file. It works well and is simple!</p>
<p class=indent>
Brett Robichaud, brett_robichaud@tallysys.com programmer.win32, 6/23/95</p>
<p>
<b>How do I programmatically terminate my MFC application?</b></p>
<p>
MFC does not provide a public function to gracefully exit an application. A method for dealing with this is to create a function in your application like the following:</p>
<pre><code>void ExitApp()
{
 &nbsp;&nbsp; // Same as double-clicking on main window close box.
 &nbsp;&nbsp; ASSERT(AfxGetApp()-&gt;m_pMainWnd != NULL);
 &nbsp;&nbsp; AfxGetApp()-&gt;m_pMainWnd-&gt;SendMessage(WM_CLOSE);
}
</code></pre>
<p>
As you can see, this is implemented as a global function, which can be called from anywhere in your application. It simply sends a WM_CLOSE message to your application's mainframe window. This initiates an orderly shutdown of the application.</p>
<p>
If you are using MFC version 2.5 or later, you can take advantage of a new global MFC function, "AfxGetMainWnd", to simplify the code:</p>
<pre><code>void ExitMFCApp()
{
 &nbsp;&nbsp; // Same as double-clicking on main window close box.
 &nbsp;&nbsp; ASSERT(AfxGetMainWnd() != NULL);
 &nbsp;&nbsp; AfxGetMainWnd()-&gt;SendMessage(WM_CLOSE);
}
</code></pre>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Always call CDocument::SetModifiedFlag() after changing your document data. This will ensure that the framework prompts the user to save before shutdown. If you need more extensive control over the shutdown procedure, you can override CDocument::SaveModified().</p>
<p class=indent>
Visual C++ Knowledge Base article Q117320, 6/25/95</p>
<p>
<b>What's the difference between IMPLEMENT_DYNAMIC, IMPLEMENT_DYNCREATE, and IMPLEMENT_SERIAL?</b></p>
<p>
IMPLEMENT_DYNAMIC provides run-time type information to support macros such as IsKindOf and GetRuntimeClass.</p>
<p>
IMPLEMENT_DYNCREATE adds the ability to allow MFC to create the type on the fly. This is required for any concrete data type that will be serialized to a file.</p>
<p>
IMPLEMENT_SERIAL also provides a version number for the class and adds the ability to use the &gt;&gt; operator to read the type from a file.</p>
<p>
As an example, if a derived class Dog uses IMPLEMENT_DYNCREATE and a base class Animal uses IMPLEMENT_SERIAL, then a Dog can be written with a pointer to either but can only be read by a pointer to Animal.</p>
<p>
MFC 3.<i>x</i> provides a constant called VERSIONABLE_SCHEMA to be used with IMPLEMENT_SERIAL to support multiple versions at the same time. The implementation in MFC is broken and fails at run time.</p>
<p class=indent>
jimb@turningpoint.com, email, 7/11/95</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;It is not true that the versionable schema is still broken. It has been fixed in MFC 4.0.</p>
<p class=indent>
<B><b>MSDN editor's note</b></B><i>&nbsp;&nbsp;&nbsp;At one time versionable schemas did not work as claimed, but this problem has been fixed in MFC version 4.0.</i></p>
<p>
<b>How can I declare an abstract base class to be IMPLEMENT_SERIAL?</b></p>
<p>
You need a special form of IMPLEMENT_SERIAL that looks like this: Use the regular DECLARE_SERIAL, but use IMPLEMENT_SERIAL_ABC shown below instead of IMPLEMENT_SERIAL.</p>
<pre><code>#define IMPLEMENT_SERIAL_ABC(class_name, base_class_name, wSchema)
_IMPLEMENT_RUNTIMECLASS(class_name, base_class_name, wSchema, NULL)
CArchive&amp; AFXAPI operator&gt;&gt;(CArchive&amp; ar, class_name* &amp;pOb)
{
 &nbsp;&nbsp; pOb = (class_name*) ar.ReadObject(RUNTIME_CLASS(class_name)); 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ar;
}
</code></pre>
<p class=indent>
anonymous</p>
<p>
<b>What is afx.inl and afxwin1.inl, etc.?</b></p>
<p>
These files live in the \msvc<i>xx</i>\mfc\include directory and include inline functions. These functions are only "inline" during non-debug (_DEBUG is not defined) builds of MFC. They are prefaced with a special _AFX_INLINE directive that gets turned into "inline" for non-debug builds and '' for debug builds.</p>
<p>
MFC does this so that you can debug into the functions in debug mode, but get the benefits of inlining during release builds. That's one of the reasons the library shrinks so much in release build mode.</p>
<p class=indent>
Scot Wingo, scot@stingsoft.com, 7/20/95</p>
<p>
<b>Is MFC available on the Macintosh?</b></p>
<p>
Yes! Microsoft has something called the Visual C++ cross-platform edition. This product lets you cross-compile for the 68000-based Macs and I think they have a PowerPC version coming out soon. Contact Microsoft directly for more info.</p>
<p class=indent>
Scot Wingo, scot@stingsoft.com, 7/27/95</p>
<p>
<b>Is MFC available on OS/2?</b></p>
<p>
No.</p>
<p>
<b>How should I learn/start learning MFC?</b></p>
<p>
I see this posted lots. To start with, check out section 2.4.2 of this FAQ—books always help. [<i><b>MSDN editor's note</b>&nbsp;&nbsp;&nbsp;see the original version of this FAQ on the Web for this information.</i>] Another good point is that you can't really get down-and-dirty in MFC without knowing and understanding the underlying Windows API, so you might want to start with an overview of that. (The Petzold book is the classic here.) At the very least get a feel for what Windows does and what it's capable of.</p>
<p>
Another hint I have is don't rely too much on the Wizards—these are great, but they sometimes shield the newbie too much. Take a look at what AppWizard/ClassWizard has done for you, run the debugger through a mainfrm.cpp, etc. You won't understand what the heck is going on until you understand what your magically generated code is doing.</p>
<p>
I thought the <i>Writing Windows Applications with MFC</i> book was a good merge between Petzold and intro MFC stuff. <i>Inside Visual C++</i> may move too fast for someone who doesn't know Windows already.</p>
<p class=indent>
Scot Wingo, scot@stingsoft.com, 7/27/95</p>
<p>
There's no substitute for paying your dues.</p>
<p>
Unfortunately MFC is set up so that you're never done paying your dues. (HAHAHAHA!!!)</p>
<p class=indent>
raymond@btw.com, mfc-l, 7/23/95</p>
<p>
Start with the Visual C++ <i>User's Guide</i> and work your way through the Scribble Tutorial. You get an intro to Visual C++ and MFC and see how they work together. Then there are numerous articles on the MSDN CD-ROM to help with basic concepts. Try searching on MFC and Architecture. Don't shy away from reading the MFC Encyclopedia articles (they take more of a "how-to" approach) and by all means become familiar with the MFC Technical Notes. Also (hint), stay focused on the 32-bit stuff if you're just starting out. There are also a number of excellent&nbsp; journals out there to help.</p>
<p class=indent>
billb@microsoft.com, mfc-l, 7/23/95</p>
<p>
The important points (of the top of my head) are:</p>
<p>
If you're a windows programmer don't worry about graphics. The CDC member functions are an almost direct encapsulation of the Windows functions. Also CWnd encapsulates much of the window manipulation functions. </p>
<p>
Learn the document/view architecture: document templates, the interaction between the application, the documents and views (AfxGetApp, GetDocument, UpdateAllViews, etc.).</p>
<p>
Learn serialization (Scribble makes a good intro to it). DDX and DDV for dialog boxes: there is a good tech note on this. WM_COMMAND handlers and COMMAND_UI handlers, which allow you to enable/disable menu items as well as to apply check mark and radio button marks on menu items; it also gives you one way to use status bars.</p>
<p>
During all this you'll also learn how to use ClassWizard and see how it is integrated with the Editor and Resource Editor. Perhaps as part of the MFC FAQ we could create a list of topics (ordered in terms of importance) to learn? <i>[Sure, this is a good start, no? —Scot]</i></p>
<p class=indent>
grimes@parallax.co.uk, mfc-l, 7/24/95</p>
<p>
<b>What DLLs should I distribute with my MFC app?</b></p>
<p>
You should review the file REDISTRB.WRI on your Visual C++ CD. This file explains what files are necessary for different kinds of applications; it explains what to do about both Windows files and MFC files.</p>
<p class=indent>
blaszczak@BIX.com, programmer.tools, 7/9/95</p>
<p>
dumpbin /imports myapp.exe dll_one.dll dll_two.dll | grep -i dll and recurse through the DLLs you find. Won't find DLLs loaded by LoadLibrary(), however.</p>
<p class=indent>
null@diku.dk, programmer.tools, 7/10/95</p>
<p>
<b>How do I intercept WM_SETTEXT messages?</b></p>
<p>
Because MFC didn't provide generic support for overriding WM_SETTEXT, you can use OnMessage(WM_SETTEXT, OnSetText) in the message map and then define your own method: </p>
<pre><code>....LRESULT CMyClass::OnSetText(wParam, lParam);
 &nbsp;&nbsp; // ...
</code></pre>
<p class=indent>
jfriend@collabra.com, programmer.tools, 8/17/95</p>
<p>
<b>I can't create an instance because of DECLARE_DYNCREATE!</b></p>
<p>
Question: ClassWizard generated a class for me but used DECLARE_DYNCREATE(...) and declared my constructor as protected. Now, when I try to create an instance of the class I get the compiler error:</p>
<p class=indent>
error C2248: 'CChkTbl::~CChkTbl': cannot access protected member declared in class 'CChkTbl'</p>
<p>
Answer: ClassWizard does this because the framework normally handles instantiation for you. I.e., if this is a CView derived class, normally the CDocumentTemplate instantiates the view during the default OnFileNew() or when you call C<i>xxx</i>DocTemplate-&gt;OpenDocumentFile() or something similar. The framework does this so that it will give you an error message if you accidentally try to instantiate it yourself. If you really need to do instantiation outside of the CDocTemplate framework, simply change the constructor to be public.</p>
<p class=indent>
chucks@skypoint.com, programmer.tools, 8/12/95</p>
<p>
Answer: The answer is that the DECLARE_DYNCREATE macro lays down a "protected:" directive and leaves it in place. One needs to make sure that anything following DECLARE_DYNCREATE should be "protected" too; if not, one needs to declare "public:" or "private:", as needed.</p>
<p class=indent>
duane@anasazi.com, email, 8/15/95</p>
<p>
<b>What the heck is this _T() thing I keep seeing?</b></p>
<p>
_T is a macro to expand the string literal to support Unicode.</p>
<p class=indent>
Mike Oliver, MSMFC, 8/1/95</p>
<p>
<b>How do I use CMemoryState?</b></p>
<p>
In MFC 2.0 and later built-in diagnostic facilities are provided. Hence it is not necessary to include CMemoryState explicitly in your app. The MFC 2.0 debugging libraries automatically perform memory leak detection. The detection code is in AFXMEM.CPP. This code detects the case in which an application dynamically allocates an object and fails to delete the object before the program terminates.</p>
<p>
In fact, CMemoryState may not function properly. You can refer to the Visual C++ Knowledge Base article Q99022, "Foundation Class Debug Library Detects Memory Leaks," for more details.</p>
<p>
#define new DEBUG_NEW should be defined in every .CPP source file. Also, insert the following code in InitInstance of the application:</p>
<pre><code>#ifdef _DEBUG
 &nbsp;&nbsp; afxMemDF |= checkAlwaysMemDF;
#endif
</code></pre>
<p>
You can refer to the Visual C++ Knowledge Base article Q117326, "Foundation Classes Common Asserts, Causes and Solutions," for more details.</p>
<p class=indent>
Muniraju (NetQuest), MSMFC, 8/1/95</p>
<p>
<b>How do I handle my own registered messages?</b></p>
<p class=indent>
<B><b>Editor’s note (Scot Wingo)</b></B>&nbsp;&nbsp;&nbsp;In this FAQ, Dean is telling a guy how to handle WM_CHKTBLTOGGLE, which is some message that dude is trying to handle. The guy was doing it a wrong way before—I've left that in for educational reasons.</p>
<p>
Use ON_MESSAGE:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;ON_MESSAGE(WM_CHKTBLTOGGLE, OnChkTblToggle)
</code></pre>
<p>
In your class definition:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;afx_msg LRESULT OnChkTblToggle(WPARAM wParam, LPARAM lParam);
</code></pre>
<p>
In your message map:</p>
<pre><code>#define ON_WM_CHKTBLTOGGLE()
{
WM_CHKTBLTOGGLE, 0, AfxSig_vwp, (AFX_PMSG)(AFX_PMSGW)(BOOL 
(AFX_MSG_CALL CWnd::*)(BYTE, BYTE))OnChkTblToggle 
},
</code></pre>
<p>
In your code:</p>
<pre><code>LRESULT CMyView::OnChkTblToggle(WPARAM wParam, LPARAM lParam)
{
 &nbsp;&nbsp; // TODO: write your code here.
}
</code></pre>
<p>
You told MFC that your function is:</p>
<pre><code>&nbsp;&nbsp;&nbsp;&nbsp;void CMYView::OnChkTblToggle(UINT, CPoint)
</code></pre>
<p>
That's what the signature AfxSig_vwp means...and definitely not what you want. </p>
<p>
ON_MESSAGE and ON_REGISTERED_MESSAGE are intended to allow you to extend the message handlers to your own custom message handlers. Please don't rely on specific AfxSig_* values or on the message map structure—it may change without notice.</p>
<p class=indent>
Dean McCrory, mfc-l, 8/19/95</p>
<p>
<b>How do I customize the MFC idle time processing?</b></p>
<p>
In my opinion, MFC's idle processing happens too often. Unfortunately, we can't change it because it might break apps when not necessary. But. . . we have built into the code a way for applications to customize the times in which they "enter idle". The secret? CWinThread::IsIdleMessage!</p>
<p>
Here's an example that disables idle entry for mouse and timer messages:</p>
<pre><code>BOOL CMyApp::IsIdleMessage(MSG* pMsg)
{
 &nbsp;&nbsp; if (!CWinApp::IsIdleMessage(pMsg))
 &nbsp;&nbsp; return FALSE;
 &nbsp;&nbsp; if ((pMsg-&gt;message &gt;= WM_MOUSEFIRST &amp;&amp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pMsg-&gt;message &lt;= WM_MOUSELAST) ||
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (pMsg-&gt;message &gt;= WM_NCMOUSEMOVE &amp;&amp; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pMsg-&gt;message &lt;= WM_NCMBUTTONDBLCLK))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;
 &nbsp;&nbsp; if (pMsg-&gt;message == WM_TIMER)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;
 &nbsp;&nbsp; // Otherwise msg must kick in idle processing...
 &nbsp;&nbsp; return TRUE;
}
</code></pre>
<p>
Now, what would happen if you had a clock on your status bar, and were relying on a WM_TIMER to kick in a call to your update handler for that pane? Well...as you might have guessed, the above code would break you. There is an easy way to fix that, as there is a backdoor method of forcing an idle to kick in: WM_KICKIDLE, defined in afxpriv.h, can be used to make this happen.</p>
<p>
So, in your timer handler (most likely a handler in your derived CStatusBar class), you would add some code that does:</p>
<pre><code>if (TimeIsDifferentEnough())
 &nbsp;&nbsp; PostMessage(WM_KICKIDLE);
</code></pre>
<p>
If you take a look at CWinThread::IsIdleMessage, you'll see that we go through a fair amount of pain to avoid unnecessary OnIdle calls, like checking for mouse moves to the same location as last time. (I don't know why Windows NT does that, but it does—every time the caret flashes.) We are doing just about everything we can without breaking backward compatibility.</p>
<p class=indent>
deanm@microsoft.com, via email</p>
<p>
<b>How do I create nonresizable (static <i>and</i> fixed) splitter bars?</b></p>
<p>
See the Visual C++ Knowledge Base article Q105150, "Preventing Static Splitter Bars from Tracking." It describes how to do this. Basically, derive a class from the CSplitterWnd and override the left button and mouse move messages: call the CWnd versions rather than CSplitterWnd versions. Finally, remove menu items that may generate ID_WINDOW_SPLIT commands.</p>
<p class=indent>
bills@anest4.anest.ufl.edu, mfc-l, 9/28/95</p>
<p>
<b>How do I add "What's this" menus to my application—like Windows 95 hip apps have?</b></p>
<p>
Here are some steps to get you started:
<ol>
<li>
Put the following menu into a resource script:<pre><code>IDR_WHAT_IS_THIS_MENU&nbsp;&nbsp;&nbsp; MENU&nbsp;&nbsp;&nbsp; DISCARDABLE
BEGIN
BEGIN
POPUP "a"
BEGIN
MENUITEM "What's this?", ID_WHAT_IS_THIS
END
END
END
</code></pre>
</li>
<li>
Add to your dialog a right-click handler (OnRButtonDown) with menu IDR_WHAT_IS_THIS_MENU. You need to store the point of the last click in some variable—for example,<pre><code>CPoint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_cLastRClickPoint;
</code></pre>
<p class=tl>
and store here the client coordinates of the last right click.</P></li>
<li>
Put the following code into your dialog class (or probably the parent class of all your dialogs):<pre><code>BEGIN_MESSAGE_MAP(CMyDialog, CDialog)
 &nbsp;&nbsp; // {{AFX_MSG_MAP(CMyDialog)
 &nbsp;&nbsp; // Whatever
 &nbsp;&nbsp; //}}
 &nbsp;&nbsp; ON_COMMAND(ID_WHAT_IS_THIS, OnWhatIsThis)
END_MESSAGE_MAP()
void CMyDialog::OnWhatIsThis()
{
 &nbsp;&nbsp; CWnd* pControl = ChildWindowFromPoint (m_cLastRClickPoint);
 &nbsp;&nbsp; // If the click wasn't on one of the controls, open Help for dialog.
 &nbsp;&nbsp; if (pControl == NULL || pControl-&gt;m_hWnd == m_hWnd)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WinHelp (HID_BASE_RESOURCE + m_nIDHelp, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HELP_CONTEXTPOPUP);
 &nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WinHelp (HID_BASE_CONTROL + pControl-&gt;GetDlgCtrlID(),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HELP_CONTEXTPOPUP);
}
</code></pre>
<p class=tl>
—and finally add the following lines to the makehelp.bat file:</P><pre><code>echo. &gt;&gt;hlp\wr.hm
echo // Controls (IDC_*) &gt;&gt;hlp\wr.hm
makehm IDC_,HIDC_,0x50000 resource.h &gt;&gt;hlp\wr.hm
</code></pre>
<p class=tl>
This wires everything to your Help system.</P></li>
</ol>
<p class=indent>
Poul A. Costinsky, PoulACost@msn.com</p>
<p>
<b>How do I display a Choose Directory dialog, instead of a Choose File dialog?</b></p>
<pre><code>/* Works only if we're Windows 95 capable */
if (afxData.bWin4)
{
 &nbsp;&nbsp; LPMALLOC pMalloc;
 &nbsp;&nbsp; /* Gets the Shell's default allocator */
 &nbsp;&nbsp; if (::SHGetMalloc(&amp;pMalloc) == NOERROR)
 &nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BROWSEINFO bi;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char pszBuffer[MAX_PATH];
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPITEMIDLIST pidl;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Get help on BROWSEINFO struct - it's got all the bit settings.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bi.hwndOwner = GetSafeHwnd();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bi.pidlRoot = NULL;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bi.pszDisplayName = pszBuffer;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bi.lpszTitle = _T("Select a Starting Directory");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bi.ulFlags = BIF_RETURNFSANCESTORS | BIF_RETURNONLYFSDIRS;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bi.lpfn = NULL;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bi.lParam = 0;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // This next call issues the dialog box.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((pidl = ::SHBrowseForFolder(&amp;bi)) != NULL)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (::SHGetPathFromIDList(pidl, pszBuffer))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // At this point pszBuffer contains the selected path */.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DoingSomethingUseful(pszBuffer);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Free the PIDL allocated by SHBrowseForFolder.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pMalloc-&gt;Free(pidl);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Release the shell's allocator.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pMalloc-&gt;Release();
 &nbsp;&nbsp; }
} 
</code></pre>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;This code will work on Windows 95 only—it's part of the shell.</p>
<p class=indent>
bradw@netnet.net, mfc-l, 9/9/95</p>
<p>
<a name="mfcfaqstl"></a><b>I'm having problems using MFC 4.0 and the STL. What could be wrong?</b></p>
<p>
The trick is to include "new.h" (and also "iostream.h" for similar reasons) before you include any STL headers. For example:</p>
<pre><code>#include &lt;new.h&gt;
#include &lt;iostream.h&gt;
namespace std {
#include &lt;map.h&gt;
}
</code></pre>
<p class=indent>
dave_bickford@compuware.com, mfc-l</p>
<p>
<b>How do I make a window stay on top of the others?</b></p>
<pre><code>SetWindowPos(&amp;wndTopMost,NULL,NULL,NULL,NULL,SWP_NOMOVE|SWP_NOSIZE)
</code></pre>
<p>
(Like DBWIN does).</p>
<p class=indent>
lee@usa.nai.net, mfc-l, 1/19/95</p>
<p>
<b>How do I make a window move in front of another?</b></p>
<p>
Call either:</p>
<pre><code>SetWindowPos(&amp;wndTop,NULL,NULL,NULL,NULL,SWP_NOMOVE|SWP_NOSIZE)
</code></pre>
<p>
or </p>
<pre><code>BringWindowToFront();
</code></pre>
<p class=indent>
lee@usa.nai.net, mfc-l, 1/19/95</p>
<p>
<b>Is MFC Dead?</b></p>
<p>
No. MFC continues to grow and change as the operating system grows and changes, and as the needs of our users continue to grow and mature. During the summer of 1997, some MFC team members will provide presentations under strict non-disclosure agreements that explain some of the planning that's happening for the next version of the product. The development of the product might change directions to fill an unforeseen pressing need, but the product is by no means dead.</p>
<p class=indent>
mikeblas@microsoft.com</p>
<p>
<b>Does ATL Replace MFC?</b></p>
<p>
No. ATL and MFC are designed to solve two very different problems.</p>
<p class=indent>
mikeblas@microsoft.com</p>
<p>
<b>How do I implement docking windows like Developer Studio has?</b></p>
<p>
MFC does not easily let you do this. The problem is that the dockbar/control bar architecture is built for basic toolbars, not windows. We have solved the problem in our Objective Toolkit product. Our Web site, <a href="http://www.stingsoft.com/">http://www.stingsoft.com/,</a> has demos and white papers—check it out!</p>
<p class=indent>
Scot Wingo, scot@stingsoft.com</p>
<p>
<b>Will the next version of MFC support [<i>some particular feature</i>]?</b></p>
<p>
The MFC Team increases MFC's feature set as time and resources allow.</p>
<p>
MFC features are added when the MFC team feels that MFC can provide a clear win for C++ programmers over using some API or system feature directly. The MFC team tracks features in the operating system as well as new strategic technologies that Microsoft introduces.</p>
<p>
Unfortunately, some people in the industry have irresponsibly begun predicting what MFC will or will not support. If someone who is not on the MFC Team claims to know whether MFC will or will not support a particular feature, they're wrong—they don't know. If someone who is on the MFC Team says that the team is planning support for a feature, they're probably right—at that particular moment in time. Because software development schedules change and are influenced by all sorts of surprises, the feature may or may not make the final version of the product, despite the best efforts of the team members.</p>
<p class=indent>
mikeblas@microsoft.com</p>
<h2><a name="mfcfaqwizard"></a>Wizard Questions</h2>
<p>
<b>How can I change the AppWizard options I selected for my application?</b></p>
<p>
Unfortunately, AppWizard will not modify already created and modified applications. You need to generate a new skeleton application using AppWizard and either merge your code into that or compare that skeleton with your original to see what's different. The good news is that it's mostly just a minor tweak to add/remove OLE support, or MDI, or something like that. It usually is just changing your CWinApp derivate, your frame window, or something like that.</p>
<p class=indent>
Scot Wingo, scot@stingsoft.com, 5/31/95</p>
<h2><a name="mfcfaqvisual"></a>Visual C++ Questions</h2>
<p>
<a href="#mfcfaqwin95">Windows 95 Questions</a><br>
<a href="#mfcfaqconfig">Configuration Questions</a><br>
<a href="#mfcfaqlanguage">Language Feature Questions</a><br>
<a href="#mfcfaqrelig">Religious Questions</a><br>
<a href="#mfcfaqadvanced">Advanced Visual C++ Tips and Tricks</a><br>
<a href="#mfcfaqmisc">Miscellaneous Visual C++ Questions</a><br>
<a href="#mfcfaqhints">Visual C++/MFC 4.0 Specific Hints, Problems, etc.</a></p>
<p>
I'm trying to keep these as generic as possible, but these types of questions tend to be very release-specific, so where possible, I've included the version that's being questioned.</p>
<h3><a name="mfcfaqwin95"></a>Windows 95 Questions</h3>
<p>
<b>I'm running Visual C++ 2.0 and I can't get the Windows 95 look and feel in my dialogs. What's wrong?</b></p>
<p>
In Visual C++ version 2.0, go to the Project/Options dialog, select "Linker" and change the linker command line to include: /subsystem:windows,4.0. This is the default in Visual C++ version 2.1.</p>
<p class=indent>
Chris Marriott, chris@chrism.demon.co.uk, programmer.misc, 5/25/95</p>
<p>
<b>When I compile under Windows 95, it flashes in and out of DOS mode.</b></p>
<p>
Remove or rename any dosprmpt.pif files in your Windows 95 and Windows directories. If this doesn't work, do the same with all .pif files.</p>
<p class=indent>
Scot Wingo, scot@stingsoft.com, 5/25/95</p>
<p>
In the \Win95\system directory there is a .pif for Conagent. It is this .pif file that a person has to change to Window screen mode instead of Full Screen mode. Worked like a charm on mine after running about a month with the screen blanking....</p>
<p class=indent>
RockyMoore@aol.com, email, 7/16/95</p>
<p>
<b>Can Visual C++ 1.5 or 2.0 be used for Windows 95?</b></p>
<p>
You can run both versions under Windows 95. Visual C++ versions 1.5<i>x</i> can <i>only </i>generate 16-bit applications. You <i>can</i> run these on Windows 95, but it's more desirable to have true 32-bit applications, which Visual C++ version 2.0 generates. These same rules apply to Windows NT.</p>
<p class=indent>
Scot Wingo, scot@stingsoft.com, 6/5/95</p>
<h3><a name="mfcfaqconfig"></a>Configuration Questions</h3>
<p>
<b>What are the memory requirements of Visual C++?</b></p>
<p>
Visual C++ version 1.5.<i>x</i> will work on a 486-class machine with a minimum of 4 MB of RAM. 8 MB will make your life much better. Visual C++ version 2.<i>x</i> needs at least 16 MB. Microsoft recommends 20 MB on the box.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Visual C++ 1.5 takes a big (3x) performance hit under all operating systems if you have less than 16 MB. I published an article about this (and other performance enhancements) in <i>Windows/DOS Developer's Journal</i> in May, 1995.</p>
<p class=indent>
jimb@turningpoint.com, email, 7/11/95</p>
<p>
<b>How can I get Visual C++ 2.1? I can't find it in stores.</b></p>
<p>
The point releases are part of the Visual C++ subscription. Only major releases are sold through retail, so you'll need to buy a subscription to get the point releases. Subscriptions are available from Microsoft, Programmer's Paradise, and Programmer's Shop. </p>
<p>
<b>Should I run under Windows 95 or NT?</b></p>
<p>
Life is a bunch of trade-offs. The trade-offs here are if you run under Windows 95, you won't need as much memory, but the OS is not as robust as Windows NT, so you will probably crash more. On the flip side, if you run under Windows NT (a full 32-bit OS), you won't crash as much, but alas, you will need more memory. Personally, I prefer the Windows NT route. Windows NT caches all memory problems and handles them nicely for you without destabilizing the system.</p>
<p class=indent>
Scot Wingo, scot@stingsoft.com, 6/18/95</p>
<p>
<b>How do I set the include/lib/exe directories?</b></p>
<p>
Visual C++ versions earlier than 2.0 used environment variables INCLUDE/LIBDIR/EXEDIR. Visual C++ versions 2.0 or later use settings in the Visual C++ Tools menu. Select the Tools menu and then choose Options. A dialog box opens, and you then select the Directories tab. There you can set Include directories, Library directories, Executable directories, and so on.</p>
<p class=indent>
Lee, Jin Woo, lee@sam1.info.samsung.co.kr, via programmer.win32, 6/10/95</p>
<p>
<b>I can't compile any programs! Help!</b></p>
<p>
Question: I just installed Visual C++ 1.51 on my system. Installation proceeded smoothly without any errors. However, I can't compile any programs! Even when I try to compile the simplest and shortest programs, I get this error message:</p>
<p class=indent>
Can't open the compilation response file</p>
<p>
Answer: A common cause of this type of error is having a TMP or TEMP environment variable that isn't pointing at a valid directory. For example, your AUTOEXEC.BAT file says:</p>
<pre><code>set TMP=C:\TMP
</code></pre>
<p>
and you don't have a C:\TMP directory.</p>
<p class=indent>
chris@chrism.demon.co.uk, programmer.misc, 6/18/95</p>
<p>
<b>Can I set up a project to search different paths for source?</b></p>
<p>
I would like to have my projects first search for the source in a local directory, and if it can't find it there, search a network drive.</p>
<p class=indent>
Joe Kinsella, jkinsella@procd.com</p>
<p>
<b>How do I build a browser file for all of MFC?</b></p>
<p>
It's nice to be able to browse the MFC classes and source code. The best way to do this is via some Microsoft-supplied .BAT files for the Microsoft Software Library:</p>
<p>
BLDBSC15.BAT—for Visual C++ 1.5</p>
<p>
BLDBSC20.BAT—for Visual C++ 2.0</p>
<p>
BLDBSC21.BAT—for Visual C++ 2.1</p>
<p>
Basically, you want invoke the compiler on every file with /Zs as the option, which means generate the .sbr file and no .obj. Next, you want to run bscmake.exe on the generated .sbr files to create your .bsc file. The MFC makefile will complain about the missing .obj, but you can ignore that warning. It will take significantly longer and more time to create both .sbrs and .objs.</p>
<p class=indent>
Scot Wingo, scot@stingsoft.com, 6/25/95</p>
<p>
It is worth noting that Visual C++ 2.1 has a pre-built browser file that is on the CD-ROM but is not installed. It can be loaded at any time into the IDE with the File/Open command.</p>
<p class=indent>
jimb@turningpoint.com, email, 7/11/95</p>
<p>
If you are using the 32-bit versions, you can get more information in the README.TXT file in the \msvc20\mfc\src directory. It tells you to move to that directory and from the DOS prompt run:</p>
<pre><code>nmake DEBUG=1 BROWSEONLY=1
</code></pre>
<p class=indent>
billb@microsoft.com, mfc-l, 7/17/95</p>
<h3><a name="mfcfaqlanguage"></a>Language Feature Questions</h3>
<p>
<b>Does Visual C++ support templates and exception handling?</b></p>
<p>
The 32-bit Visual C++ 2.0 release introduced templates and exception handling. There is no support for these C++ features in 16-bit versions of the product.</p>
<p>
It is worth noting that the 16-bit implementation of THROW and CATCH are brain-damaged. They do not clean up the stack as it unwinds.</p>
<p class=indent>
jimb@turningpoint.com, email, 7/11/95</p>
<p>
<b>Does Visual C++ support the Standard Template Library?</b></p>
<p>
Yes! See <a href="#mfcfaqstl">I'm having problems using MFC 4.0 and the STL. What could be wrong?</a> for some hints. This support was added with version 4.0.</p>
<p>
<b>Does Visual C++ support RTTI?</b></p>
<p>
Yes, version 4.0 does.</p>
<p class=indent>
Scot Wingo, scot@stingsoft.com, 6/7/95</p>
<h3><a name="mfcfaqrelig"></a>Religious Questions</h3>
<p>
<b>Which is better—OWL or MFC, Borland C++ or Microsoft Visual C++?</b></p>
<p>
This is constantly getting asked on Usenet. The answer really depends on what you are doing. If you demand the latest C++ features such as templates, RTTI, etc., Borland C++ usually has these first. But be careful, when Borland went from OWL 2 to 3 (or was it 1 to 2?) they made everybody completely rewrite their applications. Applications that were written with MFC version 1.0 still work with the newer versions of MFC today! The best advice is to get the features from each vendor and see what's best for your situation.</p>
<p class=indent>
Scot Wingo, scot@stingsoft.com, comp.lang.c++, 6/8/95</p>
<p>
<b>Should I use Visual C++ or Visual Basic?</b></p>
<p>
(Here's a funny analogy I saw posted...) Well, the principle is the same (create interface, add code to respond to events, add code to do something useful). But programming in Visual Basic is like riding a kiddy bike, while programming in C++ is like driving a Formula 1 racing car—be prepared for accidents.</p>
<p>
But seriously—Visual Basic is interpreted, Visual C++ is compiled, therefore Visual C++ programs should be much faster (if written well). It's generally believed that Visual Basic is the best way to "prototype" a user-interface, but when it comes to code reuse and solving larger problems, Visual Basic breaks down. Visual C++ on the other hand is not as easy to use as Visual Basic, but once you learn it, you can write much more complex programs than with Visual Basic. The Readers Digest version of all this is: It depends on the application you are writing.</p>
<p class=indent>
Scot Wingo, scot@stingsoft.com, 6/18/95</p>
<p>
<b>MFC philosophy (from a Microsoftie!)</b></p>
<p>
Just a note about the classes provided in MFC.... Keep in mind that these classes are designed as "general-purpose" classes, not "all-purpose" classes. No one implementation can have performance characteristics that are ideal for <i>all</i> possible applications. It is up to you, the programmer, to evaluate a provided implementation and decide whether it is appropriate for the task at hand. If it is not, you have several alternatives: modify or subclass the provided implementation, find a more appropriate class from another source, or write one from scratch.</p>
<p class=indent>
elsbree@msn.com, mfc-l, 7/15/95</p>
<p>
<b>Should I use the MFC collections or the STL collections?</b></p>
<p>
Please contribute.</p>
<h3><a name="mfcfaqadvanced"></a>Advanced Visual C++ Tips and Tricks</h3>
<p>
<b>How do I see the Visual C++ "Easter Eggs"?</b></p>
<p>
FYI: <i>Easter eggs</i> are hidden screens that usually have secret initials, development team names, etc.</p>
<p>
To see the spinning PLUS with the Visual C++ team members:</p>
<p>
In Visual C++ 2.0 or 2.1:
<ol>
<li>
Bring up the About box: click Help, then click About.<br><br></li>
<li>
Press CTRL+TAB and double click in the middle of the box at the same time.</li>
</ol>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;You must have the Visual C++ CD-ROM loaded for this to work, I think.</p>
<p>
If the procedure above does not work, try this:
<ol>
<li>
Copy the MSVCCRD.DLL from the CD-ROM to \msvc\bin.<br><br></li>
<li>
Press CTRL and double-click the picture in the dialog.</li>
</ol>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Release the CTRL key at the same time as the second click.</p>
<p class=indent>
Jeff O'Halloran, ohallorj@pwc-tpc.ca</p>
<p>
To see the Visual C++ 4.0 About box, double-click in the About box while the CD-ROM is in the drive and you are holding the CTRL key down. The OK button should go away. Wait about 3–5 minutes and you should see a pretty neat flight simulator! You can browse the picture by opening msdevcrd.dll, which lives in \msdev\bin.</p>
<p class=indent>
Scot Wingo, scot@stingsoft.com</p>
<p>
<b>What are the command-line options to Visual C++?</b></p>
<p>
MSVC /V—Runs the compiler in a DOS box (version 1.5 only?)</p>
<p class=indent>
mark@techop.demon.co.uk</p>
<p>
MSVC /NOLOGO—Runs Visual C++ without the About box, saves a second or two.</p>
<p>
MSVC /bppassc:yes—Enables a cool breakpoint counter in the "Breakpoints" dialog (under the Debug menu).</p>
<p class=indent>
jimb@turningpoint.com, email, 7/11/95</p>
<p>
MSVC -p—attaches Visual C++ to a process.</p>
<p>
<b>How to change the color of ClassWizard-generated code!</b></p>
<p>
The default color for text modified by the ClassWizard is black print on a white background. Visual C++ is aware of the code that the ClassWizard modifies and can highlight these changes for you using a different color.</p>
<p>
Highlighting the text ClassWizard modifies makes the new modifications very obvious and easy to find. To do this, from the Tools menu, choose Options. Then select the Format tab in the Options dialog box. From the Colors Listbox, select Wizard Code. Then define the colors for text and the background.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Only applies to Visual C++ 2.<i>x</i> (and 4.<i>x</i>), but it's waaaay cool!</p>
<p class=indent>
Visual C++ Knowledge Base article Q125779, 6/25/95</p>
<p>
<b>Ten cool things you can do in the Visual C++ editor!</b></p>
<p>
CTRL+ALT+T shows your tab characters.</p>
<p>
SHIFT+ESC closes the active dockable window.</p>
<p>
CTRL+F3 finds the next occurrence of the current word.</p>
<p>
CTRL+M finds the matching bracket.</p>
<p>
CTRL+&gt; and CTRL+&lt; find the next/prev matching #ifdef/#else/#endif.</p>
<p>
CTRL+SHIFT+R starts/stops macro recording.</p>
<p>
CTRL+SHIFT+P plays recorded macro.</p>
<p>
Right-click #includes to open the header file.</p>
<p>
TAB/SHIFT+TAB indent or unindent selected lines.</p>
<p>
Hold the ALT key down to select columns.</p>
<p class=indent>
Jeff Henshaw, borrowed off MFC PDC slide, 6/25/95</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Not all of these work in Visual C++ 1.5<i>x</i>; most do in 2.<i>x</i> and 4.<i>x.</i></p>
<p>
<b>How do I speed up Visual C++ compiles?</b></p>
<p>
Use precompiled headers, turn off the browser (Options:Project:Compiler:Listing Files:Browser Information), increase and/or decrease the size of your disk cache, tinker with the INCLUDE and LIB environment variable directory orders. That's about it.</p>
<p class=indent>
ebarb@iadfw.net, programmer.tools, 8/19/95</p>
<p>
<b>Make all MFC keywords a different color!</b></p>
<p>
Download (ftp://landru.unx.com/pub/mfc_faq/archive) the file USERTYPE.DAT from the FAQ Archive. This archive contains MFC samples that illustrate FAQs. Try it, you'll like it!</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;This has been updated for version 4.0.</p>
<p class=indent>
Scot Wingo, scot@stingsoft.com, 8/31/95</p>
<p>
<b>An easy way to launch 4.<i>x</i> projects without .mdp files.</b></p>
<p>
zFor very large projects you might not bank or put .mdp files into the version control system. You just want to grab the makefile and go. The problem is that Visual C++ does not easily recognize .mak files. Here's an easy way to launch right from a makefile to Visual C++ 4.0 and have a .mdp file created.
<ol>
<li>
Bring up the registry edit (Registry.exe for Windows 95 and Regedt32.exe for Windows NT 3.51).<br><br></li>
<li>
Activate the HKEY_CLASSES_ROOT window.<br><br></li>
<li>
Add a new key:<p class=tl>
.mak</P></li>
<li>
Add a new string value:<p class=tl>
mdpfile</P></li>
<li>
Close the registry.</li>
</ol>
<p>
That's it. Now you can just select any Visual C++ 4.0 makefile from File Manager or Explorer and the Visual C++ IDE will come up and a project workspace (.mdp) will be created for that makefile. You no longer have to go into the visual environment do a "file open", enter a filename, and select "open as...makefile". This is definitely a time-saver.</p>
<p class=indent>
G_LEDONNE@msn.com</p>
<h3><a name="mfcfaqmisc"></a>Miscellaneous Visual C++ Questions</h3>
<p>
<b>What are all these files that Visual C++ is creating?</b></p>
<p>
Here's a table that explains the common extensions and what Visual C++ uses them for:</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=24%><b>Extension</b></td>
<td class=label width=35%><b>Use</b></td>
<td class=label width=41%><b>Notes</b></td>
</tr>
<tr valign=top>
<td width=24%>.APS</td>
<td width=35%>AppStudio file</td>
<td width=41%></td>
</tr>
<tr valign=top>
<td width=24%>.BSC</td>
<td width=35%>Browser file</td>
<td width=41%>.SBRs combined into 1 .BSC.</td>
</tr>
<tr valign=top>
<td width=24%>.CLW</td>
<td width=35%>ClassWizard file</td>
<td width=41%></td>
</tr>
<tr valign=top>
<td width=24%>.ILK</td>
<td width=35%>Incremental linker file</td>
<td width=41%></td>
</tr>
<tr valign=top>
<td width=24%>.NCB</td>
<td width=35%>Contains the ClassView information</td>
<td width=41%>Added in 4.0; delete if you have problems.</td>
</tr>
<tr valign=top>
<td width=24%>.PCH</td>
<td width=35%>Pre-compiled header file</td>
<td width=41%></td>
</tr>
<tr valign=top>
<td width=24%>.PDB</td>
<td width=35%>Debugging info</td>
<td width=41%>/Z7 affects this.</td>
</tr>
<tr valign=top>
<td width=24%>.RES</td>
<td width=35%>RC "object" file</td>
<td width=41%>Linked into .EXE.</td>
</tr>
<tr valign=top>
<td width=24%>.SBR</td>
<td width=35%>Browser info for 1 file</td>
<td width=41%>Combined into .BSC.</td>
</tr>
<tr valign=top>
<td width=24%>.VCP</td>
<td width=35%>Visual C++ state file</td>
<td width=41%></td>
</tr>
</table><br>
<p>
<b>How do I change from using MFCXX.DLL to using a statically linked library?</b></p>
<p>
You need to flick a few settings in the build settings windows:</p>
<p>
In the C/C++ tab, select the General Category. Remove "_AFXDLL" from the list of preprocessor definitions. In the Code Generation tab, select Multithreaded or Debug Multithreaded, whichever is appropriate for your build.</p>
<p>
In the Resources tab, make sure that "_AFXDLL" doesn't appear in the list that's in the Preprocessor Definitions edit.</p>
<p class=indent>
&nbsp;blaszczak@BIX.com</p>
<p>
<b>How do I report a bug to Microsoft?</b></p>
<p>
If you find what you think is a bug, here's what you should do:
<ol>
<li>
Panic.<br><br></li>
<li>
Threaten to nuke my neighborhood.<br><br></li>
<li>
Try to consolidate the problem.<br><br></li>
<li>
Take that consolidation to another project on another machine and try it.<br><br></li>
<li>
If it still is a problem, step through the code. <i>Think</i>.<br><br></li>
<li>
<i>Think </i>some more.</li>
</ol>
<p>
If you're still sure it's a bug, do one or more of these things:
<ul type=disc>
<li>
Call PSS.<br><br></li>
<li>
Talk to a support professional, such as a certified consultant.<br><br></li>
<li>
Write to MFC-L or the MSFMC group, or the MFC bulletin board on MSN.</li>
</ul>
<p>
But realize that calling PSS is the official, guaranteed way to get help.</p>
<p>
My job is to write software, and I try to be pretty good at that. (I'm pretty good at going to hockey games, too.) But I really can't also do the job of product support on a full-time, full-responsibility basis. Sending bug reports directly to me will do nothing more than make me feel awkward and say "Sorry, can't help" to you.</p>
<p>
Thanks for understanding,</p>
<p class=indent>
mikeblas@iqnterserv.com</p>
<h3><a name="mfcfaqhints"></a>Visual C++/MFC 4.0 Specific Hints, Problems, etc.</h3>
<p>
<b>Why aren't my windows being created in MFC 4.0?</b></p>
<p>
The problem is probably that you are relying on one of the MFC 3.<i>x</i> and earlier registered window classes for the class name passed to your ::Create(). For example, a very popular way to create a window with a white background is to use "AfxViewOrFrame". In MFC 4.0, not only have all of the window class names been changed, but they also happen dynamically when needed!</p>
<p>
The solution is to use AfxRegisterWndClass() and pass the results to Create(). Be sure to specify the right flags to get the desired results. Also check out MFC Technical Note 1, which has been revised for 4.0.</p>
<p class=indent>
Scot Wingo, scot@stingsoft.com, 1/20/96</p>
<p>
<b>How do I convert a Visual C++ 2.<i>x</i> makefile over to 4.<i>x</i>?</b>
<ol>
<li>
Select File/Open.<br><br></li>
<li>
Select your *.mak file.<br><br></li>
<li>
Select Open as: Makefile.<br><br></li>
<li>
Select Open, then Visual C++ will offer you to convert it to a Visual C++ workspace—this is what you want.</li>
</ol>
<p>
<b>ClassWizard has problems wiring controls to members in international 4.0 versions—what the heck do I do?</b></p>
<p>
To test to see if you have the problem:
<ol>
<li>
In Visual C++ version 4.0, use the AppWizard to create a dialog-based application.<br><br></li>
<li>
Then use the dialog Resource Editor to add controls, etc., onto the dialog box generated above.<br><br></li>
<li>
Then fire up the ClassWizard to associate member variables to the added controls. The control IDs are <i>not </i>listed in the command ID windows (the IDCANCEL and IDOK are there and that's it!) of the member variables property page.</li>
</ol>
<p>
The control IDs <i>are </i>in the messagemap property page but not on the member variables property page! Huh?</p>
<p>
The fix:</p>
<p>
The fix is to change the language property of the dialog template (highlight the name of the dialog box in the resource window and click right mouse button). For me, I had to change the language property from English (US) to English (Australian)—only after doing this do the member variables of controls appear. I assume this property must match your Windows 95 chosen language; in any case the change fixed it for me and a German user who had the same problem.</p>
<p class=indent>
doug@psy.uwa.edu.au, email, 12/13/95</p>
<p>
<b>Visual C++ 4.0 crashes all the time on me! Help!</b></p>
<p>
I haven't personally experienced these problems, but here are some solutions (some are probably old wives’ tales) for solving the problems:</p>
<p>
Make sure you have downloaded the service update from: <a href="http://www.microsoft.com/visualc">http://www.microsoft.com/visualc.</a></p>
<p>
If you're using subprojects, this is probably the culprit—they're very unstable.</p>
<p>
If you're using 200+ files, try to carve your project into DLLs.</p>
<p>
Try removing the .ncb file—this is where the ClassView info is stored.</p>
<p>
If you converted your project over from 2.<i>x</i> and are having problems, start fresh with a 4.0 project and insert your files into it.</p>
<p>
<b>How do I add components (not just classes) to the Component Gallery?</b></p>
<p>
The APIs used for the Component Gallery have not been made public yet by Microsoft.</p>
<p>
<b>What is up with the Visual C++ 5.0 help system?</b></p>
<p>
It is widely known (at least to everyone I talk to) that the Visual C++ 5.0 help system is very slow! Microsoft replaced the wonderful, speedy RTF-based WinHelp viewer system with an HTML-based Internet Explorer viewer system. Why is it slow? Well, now it is as if you are using Alta Vista to search because the help files are in HTML. There is an indexing system that is suppose to get better, but it is really slow right now.</p>
<p>
Here's what I do. . . 
<ol>
<li>
Remove all of the help files.<br><br></li>
<li>
Install Visual C++ 4.2, choose only the IDE and help file options. Install into some unique directory such as c:\vc42_help.<br><br></li>
<li>
Now use Visual C++ 4.2 for help and Visual C++ 5.0 for compiles.</li>
</ol>
<p>
Sounds cheesy and it is, but the 5.0 help is really that slow if you are a heavy user like I am (I'm not sure if that is a good or bad thing).</p>
<p class=indent>
Scot Wingo, scot@stingsoft.com</p>
<p class=indent>
<B><b>MSDN Editor's Note</b></B><i>&nbsp;&nbsp;&nbsp;Yes, the initial release of InfoViewer version 5.0 (the Internet Explorer–based browser for the MSDN Library and various documentation sets) was very slow. A "performance-enhanced" version has been included with the MSDN Library since the April 1997 release and will be included with Visual Studio 97 and Visual C++ 5.0 by early summer of 1997.</i></p>
<p class=indent>
<i>If you are considering using the Visual C++ 4.2 documentation with Visual C++ 5.0, beware that there are significant differences between versions 4.2 and 5.0—the version 4.2 help will not be as accurate as the version 5.0 help. MSDN suggests using the Visual C++ 5.0 documentation with Visual C++ 5.0.</i></p>
<p class=indent>
</p>
</BODY>
</HTML>
