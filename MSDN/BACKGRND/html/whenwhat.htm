<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>When to Use Which OLE Technology</title>
                <style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>
<h1>When to Use Which OLE Technology</h1>
<p>
Kraig Brockschmidt<br>
Microsoft Developer Relations</p>
<p>
February 10, 1995</p>
<h2>What Is OLE?</h2>
<p>
There have been many answers to this question, ranging from the sublime to the ridiculous, as OLE has been identified at some time or another with each of its various sub-technologies. At one point it is all about in-place activation and document-centric computing; at another point it's all about OLE Automation and customization; then again it's all about component architectures; or perhaps it's nothing but OLE Controls.</p>
<p>
Although each of these definitions contains some truth, they are all quite narrow perspectives. Each of them misses any conception of how all parts of OLE fit together, and what it all means. A complete definition of OLE needs to include not only the big important and marketable technologies, but also the capacity for extension and customization on all levels of the architecture. This section of the article attempts to provide a complete definition of OLE, and is specifically written for readers who are familiar with OLE terminology already.</p>
<h3>OLE as Services</h3>
<p>
OLE, an umbrella term that includes all other OLE technologies such as OLE Controls, is made up of a number of Win32®-style application programming interface (API) functions, as well as a large number of component-object model (COM)—standard interfaces. Each interface has a fair number of functions as well. How does one make sense of this incredible mass of functionality?</p>
<p>
There are three general classifications for all of this functionality:
<ol>
<li>
Access to OLE-implemented services (including many helper functions)<br><br></li>
<li>
Customization of OLE-implemented services<br><br></li>
<li>
Extension of the environment through custom services that conform to one or more of four major integration protocols: COM, OLE Automation, OLE Documents, and OLE Controls.</li>
</ol>
<p>
In other words, OLE implements a fair amount of functionality itself, and in many cases allows direct customization of that functionality through plug-in implementations of certain services. Where OLE doesn't provide a service—most of its services are very general—OLE supports the installation of custom (specific) services, making them available through the same mechanisms as the existing OLE services. With these classifications, let us define OLE as follows:</p>
<p class=indent>
<i>OLE is a unified environment of object-based services with the ability to both customize those services and arbitrarily extend the architecture through custom services, with the overall purpose of enabling rich integration between components.</i></p>
<p>
Stated another way, OLE offers what is known as an <i>extensible service architecture</i>,<i> </i>and in addition to the <i>architecture</i>, OLE itself provides a number of key customizable services, one of which is the ability to create custom services of any complexity that extend the environment within the same architectural framework. All services—regardless of their complexity, point of storage, point of execution, and implementation—are globally available to all applications, to the system, and to all other services.</p>
<p>
The collective term used to refer to all services, regardless of the source, is the word <i>component</i>. Software that makes use of these components is <i>component software</i>, the practical and consumer-oriented realization of the developer-oriented principles of object-oriented programming. It is the vision of a computing environment where developers and end users can add features to the applications they create and use simply by purchasing additional components, instead of writing such components themselves or finding more feature-laden monolithic applications.</p>
<p>
The mechanisms used to access the functionality and information provided by a component involve the use of one or more <i>objects</i>, for lack of a better name. For example, a <i>memory-management</i> component (or service) may involve a single, simple "allocator" object that knows how to allocate, reallocate, and free blocks of memory. A <i>complex persistent storage</i> component may involve the use of several objects, such as objects that represent directory entities and objects that represent single file or stream entities within those directories, as well as objects that determine whether all of the information is written to a disk, memory, a database field, or wherever. OLE's extensible service architecture uses this concept of components and objects.</p>
<p>
These "objects" are fully encapsulated units of functionality and information, where the internal implementation is absolutely irrelevant from the perspective of external clients. The encapsulation happens through what are called "interfaces" that the object provides to those clients. These interfaces form a binary standard (that is, language-independent) mechanism for accessing objects and is critical and is the most fundamental standard for interoperability in OLE, also providing the ability to treat different objects from different components polymorphically and the ability to reuse implementations of interfaces between objects and components.</p>
<p>
So any given service, or component, will be some collection of object types, each with some specific sets of interfaces that are accessed in a particular way. These vary greatly from service to service. If you want to access and use a particular service, you need to know what type of objects provide that service, who implements the objects, and the mechanism for creating instances of the objects or accessing already-running instances. If you want to customize a service, you have to know what kind of objects you must implement yourself and how to plug those objects into the architecture of that service. If you want to create your own service, you must know what objects are necessary and the interfaces on those objects that are important. OLE defines a number of standard extensions, such as Drag and Drop, OLE Documents, and OLE Controls, where the objects you provide must implement a certain set of interfaces. For services where Microsoft or third-party standards groups have not defined standard extensions, you can create your own interfaces and your own rules.</p>
<p>
Historically, the lack of concise differentiation between who does what for which services has caused a great deal of confusion, both inside and outside of Microsoft. For example, a good deal of literature attempts to ask who implements this or that <i>interface</i>, when the real question is who implements this or that <i>service</i> and <i>what objects and interfaces are used to access that service</i>. The confusion is that <i>interface</i>, and sometimes <i>object</i>, is used interchangeably with <i>service</i>, when a service can easily have multiple objects that each have multiple interfaces. (There is a lot of confusion about whether objects are equivalent to interfaces. In an article on OLE Automation, page 42 of <i>Software Development</i>, November 1992, Andy Barnhart reveals this basic confusion: “When you speak of an object in OLE Automation, what you are really referring to is an <i>IDispatch </i>interface or a dispatch interface. In OLE, every object is really an interface of some kind.” This is dead wrong as far as COM and OLE are concerned.) In some cases, it is true, a service will have one object and one interface, but this is not a good general definition. It also doesn't make sense in many cases to talk about <i>the </i>implementation of an interface, because the objects in many services are entirely replaceable with custom implementations.</p>
<p>
So to understand the differences between services and their interfaces, let's look at the specific services that OLE provides, how those services are customized, and what it means to have a custom service. With that defined, we'll be in a position to determine just how to apply OLE to any particular project.</p>
<h3>OLE-Implemented Services and Customizations</h3>
<p>
OLE provides a sizable number of services and allows customization of the following services:
<ul type=disc>
<li>
Task memory allocation. (Replaceable under 16-bits, possibly under 32-bit versions after Windows NT™ 3.5)<br><br></li>
<li>
"Remoting" of interface calls, where one can plug into this architecture the necessary code for "remoting" a custom interface.<br><br></li>
<li>
Concurrency management, handled by default, customizable for more precise control of timeouts and rejected remote calls.<br><br></li>
<li>
Service Management/Custom Services, customized by the creation of custom services (see next section) along with the ability to have one service emulate another.<br><br></li>
<li>
Compound Files, the OLE-standard implementation of Structured Storage, where the actual bytes in the underlying data structures can be redirected to any storage medium/device. In the future an installable file system will be a custom implementation of the structured storage interfaces.<br><br></li>
<li>
Naming and Binding, where the names, or references to objects, are called <i>monikers</i>, which support persistence and binding, which means to execute a process to access the object named by the moniker. Where any standard moniker is usable, custom monikers can be tied directly and seamlessly into the existing naming and binding architecture.<br><br></li>
<li>
Running Object Table, a service for tracking "running" objects by name. This service allows no customization.<br><br></li>
<li>
"Standard Dispatch" Automation Object, provides an easy, although limited, means of implementing Automation. Generally this service is not practical to use in a shipping product, and a customization is to implement Automation more directly, ignoring this service.<br><br></li>
<li>
Data Type Conversion, a set of functions to manipulate variables of different types that are encountered in Automation. This service has no customization.<br><br></li>
<li>
Safe Arrays, a set of functions to manipulate arrays and safely exchange them between Automation processes. No customization.<br><br></li>
<li>
String Manipulation, a set of functions to manipulate BASIC-style strings. No customization.<br><br></li>
<li>
Type Libraries, the ability to create and browse information about objects and interfaces. The type library service itself is not customizable, but any specific type information can be managed through the same service. It is also possible to implement a custom type library service or a wrapper to the standard service.<br><br></li>
<li>
OLE Clipboard, which functions to facilitate data exchange using OLE's Uniform Data Transfer interfaces. Data sources provide the custom data set to exchange, but the behavior of the service itself is not customizable.<br><br></li>
<li>
OLE Drag and Drop, which functions to facilitate data exchange through direct user manipulation. This service <i>requires </i>customization to be useful—that is, it requires at least one custom implementation of a Drag and Drop source and one of a Drag and Drop target, otherwise no operations can occur.<br><br></li>
<li>
Advise Holders, generic helper implementations for objects that need to multicast standard notifications (only applies to OLE Documents and Uniform Data Transfer, not to notifications in general). No customization.<br><br></li>
<li>
Standard Property Page Frame, in which standard and custom property pages are displayed. A custom frame simply ignores this service.<br><br></li>
<li>
Default Data Cache, which facilitates creation of object handlers and in-process servers in OLE Documents where custom handlers and servers can aggregate on the default cache functionality and override specific cache behavior as necessary.<br><br></li>
<li>
Standard Font and Picture Objects, the ability to manipulate GDI fonts, bitmaps, and metafiles as objects through interfaces instead of through the Win32 API. These are simply a convenience and allow no customization.<br><br></li>
<li>
OLE 1, 16/32 Compatibility. OLE automatically provides interoperability between OLE 2 and OLE 1 components as well as between most 16- and 32-bit components (with a few exceptions). Conversion of persistent OLE 1 object data to OLE 2 persistent storage is facilitated through helper functions.<br><br></li>
<li>
Helper Functions. OLE provides a fair number of miscellaneous API functions that make implementation a little more convenient in places. Many APIs are wrappers around common sequences of other API/interface calls. Others perform functions like command routing to separate applications from a shared menu during in-place activation. Customization is a matter of doing the same work yourself and not using these helpers.</li>
</ul>
<p>
Appendix A lists these services along with the specific API functions and interfaces that expose that service, as well as the interfaces and API functions that allow customization. Appendix B goes further to list almost all of the OLE interfaces and API functions and their purposes.</p>
<h3>Custom Services</h3>
<p>
How, then, is the service environment extended? In the list above there is an entry called "Service Management." This is an OLE service that exists solely for the purpose of managing custom services. This particular management is a fixed process—one that is implemented inside the OLE libraries and one that clients of services can always depend upon. Therefore the <i>process </i>of creating instances of components in and of itself that doesn't provide for much customization. However, the <i>variety</i> (types) of services that can work within this management scheme is entirely open and arbitrary. Clients can depend on a standard process to access services, and those services can still be very rich.</p>
<p>
A new service or component is an implementation of an object, with any interfaces it requires to provide its services, structured within a "server module" (.DLL or .EXE) as required by OLE's management mechanisms. As is well documented, this server module must provide a class factory that is associated with the CLSID of the service, where that class factory creates the objects through which external clients access the service. The class factory is then something of a service itself. The server module also makes provisions for unloading itself. The mechanisms through which a server exposes its class factory and provides for unloading tie directly into specific OLE API functions for service management.</p>
<p>
Where the entire business of class factories is integral to building a component, the component itself has, at its root, some object class (the class associated with the CLSID). The component may involve multiple objects, but only one object is accessed through the class factory. In any case, all objects in the component can implement basically any set of interfaces, whatever suits the purpose. Each interface has its own rules for how a client of the component accesses that service.</p>
<p>
In some circumstances, the component is intended to fit into a standard integration protocol where the expected behavior of that component spans a set of interfaces instead of a single interface. At this time there are three such protocols: <i>OLE Automation </i>(methods, properties, programmatic control of UI), <i>OLE Documents </i>(compound documents made of unstructured information, linked or embedded), and <i>OLE Controls </i>(methods, properties, events, layout, and UI interaction inside a form). In each case the object (or objects) is structured inside a server module as a custom service—the differences lie completely in the interfaces implemented on the object, the client-side interfaces in the container (controller, document, form, and so on), the expected interaction between object and container, and the user interface standards through which end-users work with such components. An automation object may provide a service like the programmatic control of a hardware board in the computer without any UI; a compound document object may provide a charting or picture drawing service such that the container doesn't have to understand charts or drawing itself; a control might provide a text editing, push button, or label service. The type of service generally determines the appropriate protocol.</p>
<p>
Of course, many components won't fit into one of these three protocols and thus implement whatever interfaces are appropriate, which may include custom interfaces. In all these cases the expected behavior of a component is specific to whatever interface is in use—there is no higher protocol that spans a set of interfaces. Whatever the case may be, there are many standard OLE interfaces that are applicable to specific functionality, such as <i>IDataObject, IViewObject, </i>and <i>IPersist*</i>. Where a standard interface doesn't exist for the needed task, objects can support any number of custom interfaces. This involves not only publishing the interface (header file or type library) but when custom interfaces are supported across process boundaries, the service is also responsible for providing marshaling support (standard or custom marshaling). This marshaling support is made of plug-in customizations (in the form of other objects, of course) to OLE's built-in remoting service. This level of customization occurs transparently to both the component and the client of the component.</p>
<h2>Applying OLE</h2>
<p>
It has been a perpetual problem to describe just how an application might "do OLE." How does an application become an "OLE Application"? The answers have not always been clear, and depend on who you talk to. Some would say you should support OLE Documents, others OLE Automation, others OLE Controls. Or they tell you to use Compound Files and create a Summary Information stream, or to support Drag and Drop. In almost all cases, an "OLE Application" from a marketing perspective generally means that an application uses OLE in some way that is visible to the end user—the idea is that end users will start to demand "OLE" in all their applications and thus we get a proliferation of the technology. This is an appropriate policy for things like the Windows® 95 logo program.</p>
<p>
However, in order to make OLE truly successful in realizing a vision of component software, the use of OLE in software products must go deeper than just user interface (UI) features. It must permeate all levels of software development, a process that includes empowering end users to essentially write their own custom applications using available services, where those services themselves use other lower-level services.</p>
<p>
In the short term of the next few years, "OLE Applications" will fall into two categories: applications that use only the available OLE services/components, and applications that provide components themselves. In the long term the latter category becomes much more important and involves the process of "componentization." The next two sections of this article describe these two categories in more detail, with the second including something approaching a component design guide.</p>
<h3>Using OLE Components</h3>
<p>
OLE has some very powerful services that are applicable outside of most other services. For example, an application can use Compound Files as its native storage mechanism. An application might use the OLE clipboard service instead of using the Win32 API for the same feature, and it might use OLE Drag and Drop to gain integration with the system shell and other data-bearing applications. An application might also simply use OLE's default task allocator for memory management instead of lugging around its own proprietary implementation.</p>
<p>
Whatever the case may be, an application in this category is simply using some of the OLE API and the interfaces involved to implement some feature as it would any other part of the Win32 API. To determine which OLE technology to use, application designers simply determine which features they want and check if OLE provides the means to implement those features. If so, they incorporate at least these parts of OLE in that application. With some OLE services, the application may need to customize that service, or implement objects (ones without CLSIDs or server modules) that interact with that service, such as with Drag and Drop.</p>
<p>
Into this category we might also put those applications that are clients of custom services: OLE Automation Controllers, OLE Document Containers, and OLE Control Containers. Although these applications can make use of the custom services in these protocols from other sources, they do not implement custom services themselves. These client applications use OLE's "Service Management" facility to instantiate or initially access the objects from the other sources, then incorporate them into documents or forms through the standard interfaces such as <i>IDispatch</i>, <i>IOleObject</i>, and <i>IOleControl</i>.</p>
<p>
In time, the total number of controller or container applications will be very small compared to the total number of available custom services. Many years from now there might only need to be a single container that can fully integrate any custom service, including language modules (for customization of the language used to write automation scripts) and document/form templates (for customization of document or form types). These plug-in modules would just be custom services themselves. This is not yet a reality because the necessary interfaces have not been designed nor researched, and such work takes a considerable amount of time. But in time they will happen.</p>
<h3>"Componentization" (Also Called "OLE-Factoring")</h3>
<p>
Although making simple use of OLE services (as described in the previous section) is a viable way to create an "OLE Application" today, the long-term view is one where only one such client application exists and everything else provides one or more custom services, or "components." The process of "componentization" is one in which today's applications are broken up into individual services that can then be used from any other client application. Over time this means a diminishing number of client applications, through either consolidation or just plain obsolescence. Everyone should understand the direction that component software is headed, and not bet much of their future on selling clients. What, then, is "componentization"?</p>
<p class=indent>
<i>Componentization is the thorough process of breaking any piece of software into functional components where those components are useful to developers and end users alike.</i></p>
<p>
Componentization, over time, is essential to the success of component software in that such a process yields a diversity of components, a rich set that varies in scale and target user. When the end user is included as a target, componentization can create new markets and new revenue, and that is the compelling reason for anyone to undertake this sort of process.</p>
<p>
Componentization involves both design and implementation and can be summarized in the following seven steps. The first step is to find the objects; all remaining steps are applied to each object in turn.
<ol>
<li>
Determine what conceptual "objects" or "services" you wish to expose to <i>both </i>developers and end users. Services that are useful to low-level programmers include function libraries and controllable subroutines. Certain mid-level controllable pieces, such as "business objects," are more useful to a corporate developer. High-level objects such as controls, charts, graphics, text, and other information- or UI-intensive elements are very useful to end users and to some corporate developers. Remember to keep in mind the types of elements that would enable end users to write their own custom applications.<br><br></li>
<li>
For each object, determine its <i>content</i>, its information that might be of interest to clients. Determine how this information is best exposed. Is it a data structure with a defined format (such as CF_TEXT or CF_METAFILEPICT)? Could it be considered "unstructured," such that it might be incorporated into a compound document? Is it best manipulated through individual properties? Can the content be viewed and printed? Is the content persistent?<br><br></li>
<li>
Determine its "functionality," excluding data exchange and specific "action" verbs. Is the functionality best exposed as a simple library? Should the functions be early-bound or late-bound? Does the object have events it would like to fire (that is, outgoing functionality) in response to hardware or software changes or end-user manipulations?<br><br></li>
<li>
Determine the desired UI through which you will allow end users to manipulate both content and functionality. Is content something that can be put on the Clipboard or exchanged through Drag and Drop? Is content a set of properties that can be edited in property pages? Is content manipulation tied to the execution of functional "actions" (verbs) such as "play," "edit," and "rewind"? Is content best manipulated directly in a window through mouse clicks and keystrokes, perhaps including menu commands and toolbars and tool palettes?<br><br></li>
<li>
Use Tables 1, 2, and 3 (below) to match up content, functionality, and UI mechanisms desired with the applicable and appropriate OLE technologies. Then consult Table 4 to check the object-side interfaces required.<br><br></li>
<li>
Determine if the object will need to use any other objects or services itself. For each service or technology, check Table 4 below for the client-side requirements of that service. In many cases an object that is a client of another will have to implement additional client-side interfaces. Note, however, that those interfaces are not part of the exposed object-side service.<br><br></li>
<li>
Implement the service by implementing the object(s) and the necessary surrounding structures to plug into OLE. Implement certain features using OLE services where applicable, and implement other small objects (these are <i>not </i>services) that support customization of OLE as necessary. Be sure to pay attention to other implementation and deployment details such as server module type, registration, licensing, compatibility, and so on.</li>
</ol>
<h3>Why "Componentization" Is Important</h3>
<p>
OLE enables the integration of components through different relationships, from low-level relationships to high-level relationships. In order to integrate components, you must first <i>have </i>components. The process of componentization is the structuring of functionality and content into meaningful packages, from the very simple groups of library functions to complex but very rich compound document objects and controls. But while OLE enables the integration, independent software vendors (ISVs) must provide the components to integrate.</p>
<p>
It is not good enough to ask ISVs to just break up an application into components for the sake of easing the development process for other ISVs. This is the promise that "object-oriented programming" and "object technology" have both failed to deliver in any real abundance. The "object" experts have failed to address the most fundamental question: Why should the customer care? Revolutionizing the development process was a promise with dynamic-link libraries (DLLs), once upon a time. That, too, failed. Dynamic date exchange (DDE) had some hope of making programmable applications. That failed. OLE 1.0 had the hope of making compound documents and document-centric computing. That made more progress, but still didn't cause any significant change. Before OLE 2, VBXs caused the most significant change, because they put the power of programming applications closer to the hands of the people who would use those applications. That is, VBXs empowered more corporate developers, who create more specific applications for their end users than ISVs necessarily can.</p>
<p>
OLE, including COM, Automation, OLE Documents, and OLE Controls, is a unified architecture that can empower not only ISVs with reusable low-level components, but can also empower corporate developers with automation objects and controls, and even empower end users with controls, compound document objects, and automation objects to some extent.</p>
<p>
Componentization will not succeed if it is done simply for the sake of breaking a large application up into "reusable objects" (the chant of traditional object-oriented programming), because for the potentially large cost of restructuring an application there is hardly any benefit to the end user and there is hardly any potential for increasing the application's market or customer base. Componentization will most surely fail if object-orientation for the exclusive benefit of the programmer is the goal. To be successful, the process must generate building blocks for programmers of all types, because that motivates the final consumer, the end-user, to individually decide to purchase your components, <i>and it is only from those consumers that software publishers earn their livelihood!</i></p>
<p>
The key to making this all work is generating a large number of components and a fair number of tools that can integrate those components. Different components are useful to different developers or customers. Different tools targeted for different problems and different users are necessary, just as the components those tools use are varied. Because the ability to integrate is limited by one's container, so in order to make integration more powerful there must be strong containers and strong components. Such components, tools, and containers are not something that a single company can build by itself; it requires the involvement of everyone in the industry. Component software is a tremendous challenge and opportunity.</p>
<p class=label>
<b>Table 1. Mappings from Content Mechanisms to OLE Technologies</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=48%><b>Content Category</b></td>
<td class=label width=52%><b>Technology</b></td>
</tr>
<tr valign=top>
<td width=48%>Get/Set of formats-specific properties</td>
<td width=52%>Uniform Data Transfer</td>
</tr>
<tr valign=top>
<td width=48%>Get/Set of single properties (class-specific properties)</td>
<td width=52%>OLE Automation, Property Change Notification</td>
</tr>
<tr valign=top>
<td width=48%>Embedding of unstructured information</td>
<td width=52%>OLE Documents, Embedding</td>
</tr>
<tr valign=top>
<td width=48%>Linking to unstructured information</td>
<td width=52%>OLE Documents, Linking</td>
</tr>
<tr valign=top>
<td width=48%>Ability to display and print graphical presentations</td>
<td width=52%>Viewable Objects (inherent in OLE Documents)</td>
</tr>
<tr valign=top>
<td width=48%>Persistence of information</td>
<td width=52%>Persistent Objects (inherent in OLE Documents)</td>
</tr>
</table><br>
<p class=label>
<b>Table 2. Mappings from Functionality Mechanisms to OLE Technologies</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=43%><b>Functional Category</b></td>
<td class=label width=57%><b>Technology</b></td>
</tr>
<tr valign=top>
<td width=43%>Incoming Functions, v-table binding (early or late)</td>
<td width=57%>Standard interfaces where applicable, custom interfaces where necessary (described in header file or type library)</td>
</tr>
<tr valign=top>
<td width=43%>Incoming Functions, dispatch binding (early or late)</td>
<td width=57%>OLE Automation (described in type library)</td>
</tr>
<tr valign=top>
<td width=43%>Outgoing Functions, any binding</td>
<td width=57%>Connectable Objects</td>
</tr>
</table><br>
<p class=label>
<b>Table 3. Mappings from UI Mechanisms to OLE Technologies</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=61%><b>UI Category</b></td>
<td class=label width=39%><b>Technology</b></td>
</tr>
<tr valign=top>
<td width=61%>Content: Direct manipulation of object properties</td>
<td width=39%>Property Pages</td>
</tr>
<tr valign=top>
<td width=61%>Content: Separate Window Activation of embedded and linked content</td>
<td width=39%>OLE Documents (all types)</td>
</tr>
<tr valign=top>
<td width=61%>Functionality: Access custom actions (functional verbs)</td>
<td width=39%>OLE Documents (all types)</td>
</tr>
<tr valign=top>
<td width=61%>Content: In-Place Activation of embedded content</td>
<td width=39%>OLE Documents In-Place Activation</td>
</tr>
<tr valign=top>
<td width=61%>Content: Direct manipulation of object data in its own UI</td>
<td width=39%>OLE Controls</td>
</tr>
<tr valign=top>
<td width=61%>Functionality: Transformation of end user actions into events</td>
<td width=39%>OLE Controls</td>
</tr>
</table><br>
<p class=label>
<b>Table 4. Service/Object- and Client-Side Interfaces for OLE Technologies</b></p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=24%><b>OLE Technology</b></td>
<td class=label width=41%><b>Service/Object-Side Interfaces</b></td>
<td class=label width=35%><b>Client-Side Interfaces</b></td>
</tr>
<tr valign=top>
<td width=24%>Connectable Objects</td>
<td width=41%>On object: <i>IConnectionPointContainer, IProvideClassInfo</i>; on sub-objects for each outgoing interfaces: <i>IConnectionPoint</i></td>
<td width=35%>For each connected outgoing interface, client provides a sink object with that interface</td>
</tr>
<tr valign=top>
<td width=24%>Custom Interfaces</td>
<td width=41%>Custom interface</td>
<td width=35%>Depends on design of the custom interface; the custom interface may require other custom interfaces on the client side</td>
</tr>
<tr valign=top>
<td width=24%>Uniform Data Transfer</td>
<td width=41%><i>IDataObject</i>, <i>IEnumFORMATETC</i></td>
<td width=35%>Sink object with <i>IAdviseSink</i> (for data changes)</td>
</tr>
<tr valign=top>
<td width=24%>Viewable Objects</td>
<td width=41%><i>IViewObject</i> (in-process objects only)</td>
<td width=35%>Sink object with <i>IAdviseSink</i> (for view changes)</td>
</tr>
<tr valign=top>
<td width=24%>Persistent Objects</td>
<td width=41%><i>IPersistStorage</i>, <i>IPersistStream[Init],</i> <i>IPersistFile</i></td>
<td width=35%>None</td>
</tr>
<tr valign=top>
<td width=24%>Naming and Binding</td>
<td width=41%><i>IPersistFile, IOleItemContainer, IParseDisplayName</i></td>
<td width=35%>None</td>
</tr>
<tr valign=top>
<td width=24%>Property Change Notification</td>
<td width=41%>Same as Connectable Objects with an <i>IPropertyNotifySink</i> connection point</td>
<td width=35%>Sink object with <i>IPropertyNotifySink</i></td>
</tr>
<tr valign=top>
<td width=24%>OLE Automation for Properties and Methods</td>
<td width=41%><i>IDispatch, </i>optionally <i>IProvideClassInfo</i></td>
<td width=35%>None</td>
</tr>
<tr valign=top>
<td width=24%>Property Pages</td>
<td width=41%>On object: <i>ISpecifyPropertyPages</i>; Associate objects: <i>IPropertyPage[2]</i>, <i>IPerPropertyBrowsing</i></td>
<td width=35%>Page Frame: <i>IPropertyPageSite</i> (usually provided through OLE's standard frame)</td>
</tr>
<tr valign=top>
<td width=24%>OLE Documents, Embedding</td>
<td width=41%><i>IOleObject</i> with <i>IDataObject</i> and <i>IPersistStorage</i> for EXE servers, <i>IViewObject</i>, <i>IOleCache[2]</i>, and <i>IOleCacheControl</i> additional for DLL servers (for DLLs, most interfaces come from default handler or cache)</td>
<td width=35%>Embedding Site: <i>IOleClientSite</i>, <i>IAdviseSink</i></td>
</tr>
<tr valign=top>
<td width=24%>OLE Documents, Linking</td>
<td width=41%>DLL servers: same requirements for embedding plus IOleLink (implemented in the default handler). EXE servers: <i>IOleObject</i>, <i>IDataObject</i>, plus interfaces to resolve monikers, usually <i>IPersistFile</i> and <i>IOleItemContainer </i>implementations</td>
<td width=35%>Linking Site: <i>IOleClientSite</i>, <i>IAdviseSink</i> (an in-process handler acting as a client to a local server will implement <i>IAdviseSink2</i>. Normally this is the default handler)</td>
</tr>
<tr valign=top>
<td width=24%>OLE Document, In-Place Activation</td>
<td width=41%><i>IOleInPlaceObject</i>, <i>IOleInPlaceActiveObject</i></td>
<td width=35%>Frame: <i>IOleInPlaceFrame</i>; Document (if applicable): <i>IOleInPlaceUIWindow</i>; Embedding Site: <i>IOleInPlaceSite</i></td>
</tr>
<tr valign=top>
<td width=24%>OLE Controls</td>
<td width=41%>All interfaces required for embedded object with in-place activations plus <i>IOleControl</i>. A simple frame control that contains other controls has <i>ISimpleFrameSite.</i></td>
<td width=35%>Embedding Site: <i>IOleControlSite</i>, <i>IDispatch</i> (for ambient properties); Event Sinks: <i>IDispatch</i> or other vtable interface depending on event set. May also include extended control implementations of various control-side interfaces.</td>
</tr>
</table><br>
<h2>Appendix A. OLE-Implemented Services and Customizations</h2>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=27%><b>Service</b></td>
<td class=label width=31%><b>Access Mechanism</b></td>
<td class=label width=42%><b>Customization</b></td>
</tr>
<tr valign=top>
<td width=27%>Task Memory Allocation</td>
<td width=31%>API functions: <i>CoGetStandardMalloc </i>and <i>CoGetMalloc; </i>Interfaces:<i> IMalloc</i></td>
<td width=42%>A custom task allocator (<i>IMalloc</i>) can be installed with <i>CoInitialize</i> (or <i>OleInitialize</i>) on most OLE implementations. <i>CoGetMalloc </i>accesses the currently installed allocator, default or custom, in this scenario.</td>
</tr>
<tr valign=top>
<td width=27%>"Remoting" of Interface Calls (Standard interfaces)</td>
<td width=31%>None—"remoting" is automatic</td>
<td width=42%>Custom interfaces require custom "remoting" support, but this is an issue for custom services, not OLE implemented services.</td>
</tr>
<tr valign=top>
<td width=27%>Concurrency Management (incoming calls, time-outs, etc.)</td>
<td width=31%>None: default management is installed automatically.</td>
<td width=42%>A custom filter object with <i>IMessageFilter </i>is installed with <i>CoRegisterMessageFilter </i>and allows full control over concurrency.</td>
</tr>
<tr valign=top>
<td width=27%>Service Management</td>
<td width=31%>API functions such as <i>CoCreateInstance</i>, registration functions. Interfaces vary</td>
<td width=42%>While the creation and registration processes are fixed, the services that can be installed to work with the processes are completely open.</td>
</tr>
<tr valign=top>
<td width=27%>Type Libraries</td>
<td width=31%>Creation: API functions such as <i>CreateTypeLib</i> and the <i>ICreateTypeLib </i>and <i>ICreateTypeInfo </i>interfaces<p>
Manipulation: API functions such as <i>LoadTypeLib </i>to load, interfaces <i>ITypeLib, ITypeInfo, </i>and <i>ITypeComp </i>to navigate</p>
</td>
<td width=42%>None: OLE implementations always used.</td>
</tr>
<tr valign=top>
<td width=27%>Compound Files</td>
<td width=31%>API functions: <i>StgCreateDocfile, StgOpenStorage, </i>etc.<p>
Interfaces: <i>IStorage, IRootStorage, IStream </i>interfaces</p>
</td>
<td width=42%>By default, Compound Files writes to a disk file through a default "LockBytes" object (<i>ILockBytes</i>). A custom LockBytes can redirect the information to a different byte-array device. Such an object is installed with a function like <i>StgCreateDocfileOnILockBytes</i>. In the future, installable file systems will be custom implementations of <i>IStorage </i>and <i>IStream</i>.</td>
</tr>
<tr valign=top>
<td width=27%>Naming and Binding</td>
<td width=31%>API functions <i>CreateFileMoniker</i>, <i>CreateItemMoniker</i>,<i> </i>etc.<p>
Interfaces: <i>IMoniker, IBindCtx, IParseDisplayName, IOleItemContainer, </i>etc.</p>
</td>
<td width=42%>A custom moniker (an object with <i>IMoniker</i>) is polymorphic with any OLE-provided moniker; that is, all monikers are interchangeable as far as their interfaces are concerned. A server implements various interfaces to assist in the binding process.</td>
</tr>
<tr valign=top>
<td width=27%>Running Object Table</td>
<td width=31%>API Function: <i>GetRunningObjectTable;</i> Interface: <i>IRunningObjectTable</i></td>
<td width=42%>None—the OLE implementation of this service is always used.</td>
</tr>
<tr valign=top>
<td width=27%>Default Automation Object (wrapper)</td>
<td width=31%>API function: <i>CreateStdDispatch</i>; interface: <i>IDispatch</i></td>
<td width=42%>None—a fully customized automation object doesn't use the default wrapper implementations</td>
</tr>
<tr valign=top>
<td width=27%>Type Conversion (OLE Automation)</td>
<td width=31%>API functions: <i>Variant*</i></td>
<td width=42%>None; no need for it.</td>
</tr>
<tr valign=top>
<td width=27%>Safe Arrays (OLE Automation)</td>
<td width=31%>API functions: <i>SafeArray*</i></td>
<td width=42%>None; no need for it.</td>
</tr>
<tr valign=top>
<td width=27%>String Manipulation (OLE Automation)</td>
<td width=31%>API functions: <i>SysAlloc* </i></td>
<td width=42%>None; no need for it.</td>
</tr>
<tr valign=top>
<td width=27%>OLE Clipboard</td>
<td width=31%>API functions: <i>OleGetClipboard, OleSetClipboard, </i>etc.<p>
Interface <i>IDataObject, IEnumFORMATETC.</i></p>
</td>
<td width=42%>For pasting, none. For sourcing, you provide the implementation of the data object (<i>IDataObject</i>)<i> </i>that is conceptually "on" the Clipboard.</td>
</tr>
<tr valign=top>
<td width=27%>OLE Drag and Drop</td>
<td width=31%>None</td>
<td width=42%>Drag and Drop requires the presence of a custom source and a custom target to perform any transfer operation. The source and target are notified of various important events during the operation as OLE tracks the movement of the mouse and changes in the keyboard state.<p>
The source is an object that implements <i>IDropSource</i>. That object and a data object is given to the API function <i>DoDragDrop </i>to start an operation. The target is an object with <i>IDropTarget </i>that is installed with <i>RegisterDragDrop </i>and removed with <i>RevokeDragDrop</i>.</p>
</td>
</tr>
<tr valign=top>
<td width=27%>"Advise Holders" (simplify management of multi-cast notifications)</td>
<td width=31%>API functions <i>CreateDataAdviseHolder </i>and <i>CreateOleAdviseHolder</i><p>
Interfaces <i>I[Data&lt;!--htmlstart--&gt;&amp;#124;&lt;!--htmlend--&gt;Ole]AdviseHolder</i></p>
</td>
<td width=42%>None: these services are always generic and there is no need for custom implementations.</td>
</tr>
<tr valign=top>
<td width=27%>Standard Property Frame (displays property pages; OLE Controls)</td>
<td width=31%>API functions <i>OleCreatePropertyFrame[Indirect]</i><p>
Interface: <i>IPropertyPageSite </i></p>
</td>
<td width=42%>A custom property frame is some custom object with <i>IPropertyPageSite</i>. This does not tie into the API in any way.</td>
</tr>
<tr valign=top>
<td width=27%>Default Data Cache (OLE Documents only)</td>
<td width=31%>API function <i>CreateDataCache</i></td>
<td width=42%>Custom caching is accomplished through aggregation on the default cache. This occurs generally in in-process compound document servers.</td>
</tr>
<tr valign=top>
<td width=27%>Default Object Handler (OLE Documents only)</td>
<td width=31%>API functions: <i>OleCreateDefaultHandler</i><p>
Interfaces vary</p>
</td>
<td width=42%>A custom handler will typically aggregate on the default handler, letting it handle most in-process compound document services.</td>
</tr>
<tr valign=top>
<td width=27%>Standard Font and Picture Objects (from OLE Controls)</td>
<td width=31%>API functions: <i>OleCreate[Font &lt;!--htmlstart--&gt;&amp;#124;&lt;!--htmlend--&gt; Picture]Indirect</i><p>
Interfaces: <i>IFont, IPicture</i></p>
</td>
<td width=42%>None—these are provided simply as a convenience. Their use is not required.</td>
</tr>
<tr valign=top>
<td width=27%>OLE 1 and 16/32 Compatibility</td>
<td width=31%>Usually Automatic, API functions handle conversion of storage</td>
<td width=42%>None—run-time compatibility is handled automatically and transparently; storage compatibility is a manual process using helper functions.</td>
</tr>
<tr valign=top>
<td width=27%>Helper Functions</td>
<td width=31%>Varies</td>
<td width=42%>None—OLE provides helper functions to make programming more convenient.</td>
</tr>
</table><br>
<h2>Appendix B: The Purpose of All OLE APIs and Interfaces</h2>
<p>
OLE is a set of implemented services, mechanisms to customize those services, and mechanisms to install custom services according to various protocols. Every OLE API function and every currently defined interface (that is, those found in shipping OLE technologies) has a purpose in this framework. The table below lists each API function and interface, along with its purpose, be it a service, a customization, or a mere helper or wrapper function. This helps to illustrate why the various APIs and interfaces exist. (Note that the collection of functions in the OLE UI library is not included at this time. Some recently added interfaces are also missing.)</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=32%><b>Function or Interface</b></td>
<td class=label width=68%><b>Purpose</b></td>
</tr>
<tr valign=top>
<td class=label width=32%><b>General</b></td>
<td class=label width=68%></td>
</tr>
<tr valign=top>
<td width=32%><i>IUnknown</i></td>
<td width=68%>Control of object lifetime, interface negotiation. Ubiquitous for any component regardless of implementation. <i>QueryInterface </i>exposes incoming interfaces.</td>
</tr>
<tr valign=top>
<td width=32%><i>IEnum*</i></td>
<td width=68%>Enumeration of various types of lists. Used in many cases throughout OLE.</td>
</tr>
<tr valign=top>
<td width=32%><i>IProvideClassInfo</i></td>
<td width=68%>Expose the type information about an object's incoming and outgoing interfaces.</td>
</tr>
<tr valign=top>
<td width=32%><i>IConnectionPointContainer, IEnumConnectionPoints, IConnectionPoint, IEnumConnections</i></td>
<td width=68%>Expose an object's outgoing interfaces</td>
</tr>
<tr valign=top>
<td class=label width=32%><b>Initialization, Memory Mgmt.</b></td>
<td class=label width=68%></td>
</tr>
<tr valign=top>
<td width=32%><i>CoBuildVersion, OleBuildVersion</i></td>
<td width=68%>Check OLE library version numbers</td>
</tr>
<tr valign=top>
<td width=32%><i>IMalloc</i></td>
<td width=68%>Task memory allocation</td>
</tr>
<tr valign=top>
<td width=32%><i>CoInitialize, CoUninitialize, OleInitialize, OleUninitialize</i></td>
<td width=68%>Initialize/Uninitialize COM/OLE libraries and install an OLE-provided task allocator (most OLE implementations also allow installation of a custom allocator).</td>
</tr>
<tr valign=top>
<td width=32%><i>CoCreateStandardMalloc</i></td>
<td width=68%>Access standard task memory allocator</td>
</tr>
<tr valign=top>
<td width=32%><i>CoGetMalloc</i></td>
<td width=68%>Access currently installed task allocator</td>
</tr>
<tr valign=top>
<td class=label width=32%><b>"Remoting"</b></td>
<td class=label width=68%></td>
</tr>
<tr valign=top>
<td width=32%><i>IExternalConnection</i></td>
<td width=68%>Notification: connection/disconnection from remote process</td>
</tr>
<tr valign=top>
<td width=32%><i>CoLockObjectExternal</i></td>
<td width=68%>Lock a remote object implementation</td>
</tr>
<tr valign=top>
<td width=32%><i>CoDisconnectObject</i></td>
<td width=68%>Forcibly disconnect any remote connections</td>
</tr>
<tr valign=top>
<td width=32%><i>IMarshal</i></td>
<td width=68%>Standard marshaling (OLE impl); custom marshaling (custom impl)</td>
</tr>
<tr valign=top>
<td width=32%><i>CoGetStandardMarshal</i></td>
<td width=68%>Access standard implementation of IMarshal</td>
</tr>
<tr valign=top>
<td width=32%><i>IStdMarshalInfo</i></td>
<td width=68%>Support for Custom Interfaces</td>
</tr>
<tr valign=top>
<td width=32%><i>CoMarshalHresult, CoUnmarshalHresult, CoMarshalInterface, CoUnmarshalInterface, CoReleaseMarshalData</i></td>
<td width=68%>Helpers for marshaling both standard and custom. <i>CoMarshalInterface, </i>for example, is always called whenever any object needs to create the server-side remoting support for an interface pointer to a new object. <i>CoUnmarshalInterface </i>creates the client side to match.</td>
</tr>
<tr valign=top>
<td width=32%><i>CoIsHandlerConnected</i></td>
<td width=68%>Helper to determine if an in-process component is connected to a remote process.</td>
</tr>
<tr valign=top>
<td width=32%><i>Custom Interface</i></td>
<td width=68%>Installs a custom IMessageFilter implementation.</td>
</tr>
<tr valign=top>
<td width=32%><i>IMessageFilter</i></td>
<td width=68%>Helper functions for OLE 1 container document compatibility.</td>
</tr>
<tr valign=top>
<td width=32%><i>CoRegisterMessageFilter</i></td>
<td width=68%>Concurrency management handling interface. A default implementation is always installed when remoting occurs</td>
</tr>
<tr valign=top>
<td class=label width=32%><b>Custom Services</b></td>
<td class=label width=68%></td>
</tr>
<tr valign=top>
<td width=32%><i>CoCreateInstance</i></td>
<td width=68%>Access custom component implementation given a CLSID</td>
</tr>
<tr valign=top>
<td width=32%><i>IClassFactory[2]</i></td>
<td width=68%>Creation of custom component based on CLSID</td>
</tr>
<tr valign=top>
<td width=32%><i>CoGetClassObject</i></td>
<td width=68%>Access custom class factory implementation given a CLSID</td>
</tr>
<tr valign=top>
<td width=32%><i>DllGetClassObject</i></td>
<td width=68%>Expose a custom class factory implementation from a DLL</td>
</tr>
<tr valign=top>
<td width=32%><i>CoRegisterClassObject, CoRevokeClassObject</i></td>
<td width=68%>Install/remove a custom class factory implementation</td>
</tr>
<tr valign=top>
<td class=label width=32%><b>Service Registration</b></td>
<td class=label width=68%></td>
</tr>
<tr valign=top>
<td width=32%><i>CoCreateGuid, IsEqualGUID, IsEqualIID, IsEqualCLSID</i></td>
<td width=68%>Helper for creation and comparison of GUIDs</td>
</tr>
<tr valign=top>
<td width=32%><i>DllRegisterServer, DllUnregisterServer</i></td>
<td width=68%>Expose self-registration functionality from a DLL server module.</td>
</tr>
<tr valign=top>
<td width=32%><i>CoGetTreatAsClass, CoTreatAsClass, OleDoAutoConvert, OleGetAutoConvert, OleSetAutoConvert, GetConvertStg, SetConvertStg</i></td>
<td width=68%>Conversion/Emulation manipulation (only customization is registry information that describes which classes are interchangeable)</td>
</tr>
<tr valign=top>
<td class=label width=32%><b>DLL Server Management</b></td>
<td class=label width=68%></td>
</tr>
<tr valign=top>
<td width=32%><i>DllCanUnloadNow</i></td>
<td width=68%>Control DLL server unloading</td>
</tr>
<tr valign=top>
<td width=32%><i>CoLoadLibrary, CoFreeLibrary, CoFreeAllLibraries, CoFreeUnusedLibraries</i></td>
<td width=68%>Load and unload in-process server modules</td>
</tr>
<tr valign=top>
<td class=label width=32%><b>Misc. COM Functions</b></td>
<td class=label width=68%></td>
</tr>
<tr valign=top>
<td width=32%><i>CLSIDFrom[ProgID &lt;!--htmlstart--&gt;&amp;#124;&lt;!--htmlend--&gt; String], [ProgID &lt;!--htmlstart--&gt;&amp;#124;&lt;!--htmlend--&gt; String]FromCLSID, IIDFromString, StringFromIID, StringFromGUID2</i></td>
<td width=68%>Helper functions for conversion between GUIDs, strings, and ProgIDs.</td>
</tr>
<tr valign=top>
<td width=32%><i>CoGetCurrentProcess</i></td>
<td width=68%>Miscellaneous helper</td>
</tr>
<tr valign=top>
<td width=32%><i>CoDosDateTimeToFileTime, CoFileTimeToDosDateTime, CoFileTimeNow</i></td>
<td width=68%>Miscellaneous helper functions for date/time conversion. (More appropriate to be a Win32 API.)</td>
</tr>
<tr valign=top>
<td width=32%><i>IsValidIid, IsValidInterface, IdValidPtrIn, IsValidPtrOut</i></td>
<td width=68%>Miscellaneous validation functions (16-bit only)</td>
</tr>
<tr valign=top>
<td class=label width=32%><b>Naming, Monikers</b></td>
<td class=label width=68%></td>
</tr>
<tr valign=top>
<td width=32%><i>IMoniker</i></td>
<td width=68%>Exposes moniker functionality. OLE provides five moniker implementations (five different classes). Custom implementations can be exposed via object creation functions or custom API..</td>
</tr>
<tr valign=top>
<td width=32%><i>BindMoniker</i></td>
<td width=68%>Wrapper for <i>IMoniker::BindToObject</i></td>
</tr>
<tr valign=top>
<td width=32%><i>CreateFileMoniker, CreateItemMoniker, CreateAntiMoniker, CreatePointerMoniker, CreateGenericComposite</i></td>
<td width=68%>Access OLE standard moniker implementations</td>
</tr>
<tr valign=top>
<td width=32%><i>IParseDisplayName</i></td>
<td width=68%>Implemented on a custom object to parse a user-readable display name into a moniker object, standard or custom.</td>
</tr>
<tr valign=top>
<td width=32%><i>IOleContainer, IOleItemContainer</i></td>
<td width=68%>While generally related to OLE Documents, these interfaces are implemented on an object that contains items and is necessary to bind item monikers.</td>
</tr>
<tr valign=top>
<td width=32%><i>IBindCtx</i></td>
<td width=68%>Implemented on the OLE standard "bind context" object.</td>
</tr>
<tr valign=top>
<td width=32%><i>CreateBindCtx</i></td>
<td width=68%>Instantiates a bind context object returning an IBindCtx pointer.</td>
</tr>
<tr valign=top>
<td width=32%><i>IRunningObjectTable</i></td>
<td width=68%>Exposed from the OLE implemented "running object table" service. No customizations.</td>
</tr>
<tr valign=top>
<td width=32%><i>GetRunningObjectTable</i></td>
<td width=68%>Access the running object table.</td>
</tr>
<tr valign=top>
<td width=32%><i>MkParseDisplayName</i></td>
<td width=68%>Converts a string into a moniker which includes the intelligence to determine whose implementation of <i>IParseDisplayName </i>to use.</td>
</tr>
<tr valign=top>
<td width=32%><i>MonikerRelativePathTo, MonikerCommonPrefixWith</i></td>
<td width=68%>Helpers to manipulate file monikers to create absolute and relative paths using <i>IMoniker::RelativePathTo </i>and <i>IMoniker::CommonPrefixWith.</i></td>
</tr>
<tr valign=top>
<td class=label width=32%><b>Structured Storage</b></td>
<td class=label width=68%></td>
</tr>
<tr valign=top>
<td width=32%><i>IStorage</i></td>
<td width=68%>Expose storage object functionality (directory)</td>
</tr>
<tr valign=top>
<td width=32%><i>IStream</i></td>
<td width=68%>Expose stream object functionality (files)</td>
</tr>
<tr valign=top>
<td width=32%><i>IRootStorage</i></td>
<td width=68%>Control underlying file attached to an IStorage in a Compound File</td>
</tr>
<tr valign=top>
<td width=32%><i>ILockBytes</i></td>
<td width=68%>Customize underlying storage medium in a Compound File</td>
</tr>
<tr valign=top>
<td width=32%><i>StgCreateDocfile, StgOpenStorage</i></td>
<td width=68%>Create or open OLE's Compound File (IStorage/IRootStorage) implementation using default file-based ILockBytes implementation</td>
</tr>
<tr valign=top>
<td width=32%><i>StgCreateDocfileOnILockBytes, StgOpenStorageOnILockBytes</i></td>
<td width=68%>Create or open OLE's Compound File (IStorage/IRootStorage) implementation using a custom ILockBytes implementation.</td>
</tr>
<tr valign=top>
<td width=32%><i>StgIsStorageFile, StgIsStorageILockBytes</i></td>
<td width=68%>Check if a file is a Compound File with the default implementation of ILockBytes or a custom implementation.</td>
</tr>
<tr valign=top>
<td width=32%><i>CreateILockBytesOnHGlobal, GetHGlobalFromILockBytes</i></td>
<td width=68%>Access memory-based ILockBytes implementation.</td>
</tr>
<tr valign=top>
<td width=32%><i>CreateStreamOnHGlobal, GetHGlobalFromStream</i></td>
<td width=68%>Access memory-based IStream implementation</td>
</tr>
<tr valign=top>
<td width=32%><i>[Read &lt;!--htmlstart--&gt;&amp;#124;&lt;!--htmlend--&gt; Write]Class[Stg &lt;!--htmlstart--&gt;&amp;#124;&lt;!--htmlend--&gt; Stm], [Read &lt;!--htmlstart--&gt;&amp;#124;&lt;!--htmlend--&gt; Write]FmtUserTypeStg, GetClassFile </i></td>
<td width=68%>Retrieve or save CLSID, data format, and user type information to a storage or stream.</td>
</tr>
<tr valign=top>
<td width=32%><i>StgSetTimes</i></td>
<td width=68%>Helper function to manipulate Compound File timestamp</td>
</tr>
<tr valign=top>
<td class=label width=32%><b>Persistent Objects</b></td>
<td class=label width=68%></td>
</tr>
<tr valign=top>
<td width=32%><i>IPersist, IPersistFile, IPersistStorage, IPersistStream[Init]</i></td>
<td width=68%>Expose from a persistent object based on storage model: file-based, <i>IStorage</i>-based, <i>IStream</i>-based (with or without initialization).</td>
</tr>
<tr valign=top>
<td class=label width=32%><b>Notifications/Events</b></td>
<td class=label width=68%></td>
</tr>
<tr valign=top>
<td width=32%><i>IAdviseSink[2]</i></td>
<td width=68%>Receive notifications of data change, view change, compound document object changes</td>
</tr>
<tr valign=top>
<td width=32%><i>IPropertyNotifySink</i></td>
<td width=68%>Receive notifications of property changes and control overrideable changes.</td>
</tr>
<tr valign=top>
<td width=32%>Events sets</td>
<td width=68%>Interfaces defined by an object, implemented by an outside event sink.</td>
</tr>
<tr valign=top>
<td class=label width=32%><b>Uniform Data Transfer</b></td>
<td class=label width=68%></td>
</tr>
<tr valign=top>
<td width=32%><i>IDataObject, (IAdviseSink), IEnumFORMATETC</i></td>
<td width=68%>Expose ability to exchange formatted data structures and notify an advise sink of data changes.</td>
</tr>
<tr valign=top>
<td width=32%><i>OleDuplicateData</i></td>
<td width=68%>Helper function for copying data structures</td>
</tr>
<tr valign=top>
<td width=32%><i>ReleaseStgMedium</i></td>
<td width=68%>Helper to free data structures</td>
</tr>
<tr valign=top>
<td class=label width=32%><b>Viewable Objects</b></td>
<td class=label width=68%></td>
</tr>
<tr valign=top>
<td width=32%><i>IViewObject[2], (IAdviseSink)</i></td>
<td width=68%>Expose ability to draw visual presentations to device contexts and notify an advise sink of view changes</td>
</tr>
<tr valign=top>
<td width=32%><i>OleDraw</i></td>
<td width=68%>Simple wrapper around <i>IViewObject::Draw</i></td>
</tr>
<tr valign=top>
<td width=32%><i>OleGetIconOfFile, OleMetafilePictFromIconAnd-Label, OleGetIconOfClass, </i></td>
<td width=68%>Helper function for manipulation of iconic views of objects.</td>
</tr>
<tr valign=top>
<td width=32%><i>OleTranslateColor</i></td>
<td width=68%>Helper to translates between COLORREF and OLE_COLOR types</td>
</tr>
<tr valign=top>
<td class=label width=32%><b>Standard Types</b></td>
<td class=label width=68%></td>
</tr>
<tr valign=top>
<td width=32%><i>IFont, IFontDisp</i></td>
<td width=68%>Expose standard font object implementation (OLE Controls)</td>
</tr>
<tr valign=top>
<td width=32%><i>OleCreateFontIndirect</i></td>
<td width=68%>Access standard font object implementation</td>
</tr>
<tr valign=top>
<td width=32%><i>IPicture, IPictureDisp</i></td>
<td width=68%>Expose standard picture object implementation (OLE Controls)</td>
</tr>
<tr valign=top>
<td width=32%><i>OleCreatePictureIndirect</i></td>
<td width=68%>Access standard picture object implementation</td>
</tr>
<tr valign=top>
<td width=32%><i>OleLoadPicture</i></td>
<td width=68%>Create a picture object from stream information</td>
</tr>
<tr valign=top>
<td width=32%><i>OleIconToCursor</i></td>
<td width=68%>Helper function to turn an icon into a cursor for simple Win32 API based drag and drop (not OLE drag and drop)</td>
</tr>
<tr valign=top>
<td class=label width=32%><b>OLE Clipboard</b></td>
<td class=label width=68%></td>
</tr>
<tr valign=top>
<td width=32%><i>OleSetClipboard, OleGetClipboard, OleFlushClipboard, OleIsCurrentClipboard</i></td>
<td width=68%>API for clipboard handling service via <i>IDataObject</i>. No customization except for whatever <i>IDataObject</i> implementation is involved.</td>
</tr>
<tr valign=top>
<td class=label width=32%><b>OLE Drag and Drop</b></td>
<td class=label width=68%></td>
</tr>
<tr valign=top>
<td width=32%><i>IDropSource</i></td>
<td width=68%>Exposes source-side functionality in a drag-and-drop operation.</td>
</tr>
<tr valign=top>
<td width=32%><i>IDropTarget</i></td>
<td width=68%>Exposes target-side functionality in a drag-and-drop operation.</td>
</tr>
<tr valign=top>
<td width=32%><i>DoDragDrop</i></td>
<td width=68%>Installs <i>IDropSource</i> (and <i>IDataObject</i>) implementations to begin a drag-and-drop operation</td>
</tr>
<tr valign=top>
<td width=32%><i>RegisterDragDrop, RevokeDragDrop</i></td>
<td width=68%>Installs/uninstalls a drop target implementation. Drop target is exposed to <i>DoDragDrop</i> only.</td>
</tr>
<tr valign=top>
<td class=label width=32%><b>Type Libraries</b></td>
<td class=label width=68%></td>
</tr>
<tr valign=top>
<td width=32%><i>ITypeLib, ITypeInfo</i></td>
<td width=68%>Standard OLE implementations to navigate through a type library structure</td>
</tr>
<tr valign=top>
<td width=32%><i>ITypeComp</i></td>
<td width=68%>Standard OLE implementation to bind to interface functions defined in a type library in a much more efficient manner, useful for compilers</td>
</tr>
<tr valign=top>
<td width=32%><i>LHashValOfName[Sys]</i></td>
<td width=68%>Create a hash value used in <i>ITypeComp</i> functions</td>
</tr>
<tr valign=top>
<td width=32%><i>LoadTypeLib, LoadRegTypeLib, LoadTypeLibFromResource, RegisterTypeLib, QueryPathOfRegTypeLib</i></td>
<td width=68%>Helpers for registering and loading a type library. Loading a type library means instantiating the type library object with <i>ITypeLib</i> on it. In other words, <i>Load[Reg]TypeLib[FromResource]</i> accesses the standard <i>ITypeLib</i> implementation.</td>
</tr>
<tr valign=top>
<td width=32%><i>CreateTypeLib</i></td>
<td width=68%>Creates a brand new type library (as opposed to loading an existing one). The type library implements <i>ICreateTypeLib</i>. Generally used from type library compilers.</td>
</tr>
<tr valign=top>
<td width=32%><i>ICreateTypeLib, ICreateTypeInfo</i></td>
<td width=68%>Implementations in OLE for creating a type library. Used from type library compilers.</td>
</tr>
<tr valign=top>
<td width=32%><i>CreateDispTypeInfo</i></td>
<td width=68%>Create a type information object with <i>ITypeInfo</i> based on INTERFACEDATA structures</td>
</tr>
<tr valign=top>
<td width=32%><i>CompareStringA, LCMapStringA, GetLocaleInfoA, GetStringTypeA, GetSystemDefault[LangID &lt;!--htmlstart--&gt;&amp;#124;&lt;!--htmlend--&gt; LCID], GetUserDefault[LangID &lt;!--htmlstart--&gt;&amp;#124;&lt;!--htmlend--&gt; LCID]</i></td>
<td width=68%>Helper functions for working with locale-specific information in OLE Automation. These are primarily for Win16 platforms as the same functions are part of the standard Win32 API.</td>
</tr>
<tr valign=top>
<td class=label width=32%><b>OLE Automation</b></td>
<td class=label width=68%></td>
</tr>
<tr valign=top>
<td width=32%><i>IDispatch, IEnumVARIANT</i></td>
<td width=68%>Expose methods and properties through a dispatch (DISPID) mechanism as well as "collections"</td>
</tr>
<tr valign=top>
<td width=32%><i>CreateStdDispatch</i></td>
<td width=68%>Install a custom interface into a standard <i>IDispatch</i> implementation. In other words, access a standard <i>IDispatch</i> that internally depends on a custom interface implementation.</td>
</tr>
<tr valign=top>
<td width=32%><i>DispGetIDOfNames, DispGetParams, DispInvoke</i></td>
<td width=68%>Helper functions for direct implementations or uses of <i>IDispatch</i>.</td>
</tr>
<tr valign=top>
<td width=32%><i>RegisterActiveObject, RevokeActiveObject, GetActiveObject</i></td>
<td width=68%>Helper functions to register automation objects as running and access running object. Basically wrappers around the running object table.</td>
</tr>
<tr valign=top>
<td width=32%><i>SafeArray- AccessData, AllocData, AllocDescriptor, Copy, Create, Destroy, DestroyData, DestroyDescriptor, GetDim, GetElement, GetElemSize, GetLBound, GetUBound, Lock, PutElement, Redim, UnAccessData, Unlock</i></td>
<td width=68%>Helper functions for manipulating arrays passed through <i>IDispatch</i></td>
</tr>
<tr valign=top>
<td width=32%><i>Sys- AllocString, AllocStringLen, FreeString, ReAllocString, ReAllocStringLen, StringLen</i></td>
<td width=68%>Helper functions to manipulate BSTR types</td>
</tr>
<tr valign=top>
<td width=32%><i>Variant- ChangeType[Ex], Clear, Copy, CopyInf, Init, TimeToDosDateTime; (DosDateTimeToVarantTime)</i></td>
<td width=68%>Helper functions to manipulate variables passed in VARIANT structures, such as type conversion and duplication.</td>
</tr>
<tr valign=top>
<td class=label width=32%><b>OLE Property Pages</b></td>
<td class=label width=68%></td>
</tr>
<tr valign=top>
<td width=32%><i>OleCreatePropertyFrame-[Indirect]</i></td>
<td width=68%>Access standard implementation of a property page frame that implements <i>IPropertyPageSite.</i></td>
</tr>
<tr valign=top>
<td width=32%><i>IPropertyPageSite</i></td>
<td width=68%>Expose capability as a property page frame.</td>
</tr>
<tr valign=top>
<td width=32%><i>ISpecifyPropertyPages</i></td>
<td width=68%>Expose CLSIDs of an object's property pages (which are separate objects).</td>
</tr>
<tr valign=top>
<td width=32%><i>IPropertyPage[2]</i></td>
<td width=68%>Expose property page functionality.</td>
</tr>
<tr valign=top>
<td width=32%><i>IPerPropertyBrowsing</i></td>
<td width=68%>Expose the ability to manipulate individual properties</td>
</tr>
<tr valign=top>
<td class=label width=32%><b>OLE Documents, General</b></td>
<td class=label width=68%></td>
</tr>
<tr valign=top>
<td width=32%><i>OleRegGetUserType, OleRegGetMiscStatus, OleRegEnumFormatEtc, OleRegEnumVerbs</i></td>
<td width=68%>Helper functions for default registry handling (OLE Documents, mostly)</td>
</tr>
<tr valign=top>
<td width=32%><i>IRunnableObject</i></td>
<td width=68%>Notifications of when an object is going between loaded and running.</td>
</tr>
<tr valign=top>
<td width=32%><i>OleIsRunning, OleLockRunning, OleRun, OleNoteObjectVisible, OleSetContainedObject</i></td>
<td width=68%>Helpers for control of running objects in compound documents. Most of these functions call <i>IRunnableObject </i>members.</td>
</tr>
<tr valign=top>
<td width=32%><i>IOleAdviseHolder</i></td>
<td width=68%>Helper functions for managing <i>IAdviseSink</i> pointers from within a compound document object implementation.</td>
</tr>
<tr valign=top>
<td width=32%><i>CreateOleAdviseHolder</i></td>
<td width=68%>Access OLE implementation of <i>IOleAdviseHolder</i> object. No customization</td>
</tr>
<tr valign=top>
<td width=32%><i>OleLoad, OleLoadFromStream, OleSave, OleSaveToStream</i></td>
<td width=68%>Functions to load and save compound document objects in IStorage or IStream instances. Wrappers for IPersistStorage and IPersistStream calls.</td>
</tr>
<tr valign=top>
<td width=32%><i>OleCreateStaticFromData</i></td>
<td width=68%>Access OLE implementation of a static object</td>
</tr>
<tr valign=top>
<td class=label width=32%><b>OLE Documents: Handlers and Caching</b></td>
<td class=label width=68%><b><br>
</b></td>
</tr>
<tr valign=top>
<td width=32%><i>OleCreateDefaultHandler, OleCreateEmbeddingHelper</i></td>
<td width=68%>Access OLE implementation of default handler or "embedding helper" (a cut-rate default handler for same-process objects).</td>
</tr>
<tr valign=top>
<td width=32%><i>IOleCache[2]</i></td>
<td width=68%>Implemented by default provided by OLE, in-process handlers and servers in compound document uses can customize.</td>
</tr>
<tr valign=top>
<td width=32%><i>CreateDataCache</i></td>
<td width=68%>Access OLE's data cache implementation (service). Cache object implements a number of interfaces including <i>IOleCache[2]</i>, <i>IOleCacheControl</i>, <i>IDataObject</i>, <i>IViewObject[2]</i>, and <i>IPersistStorage</i>.</td>
</tr>
<tr valign=top>
<td width=32%><i>IOleCacheControl</i></td>
<td width=68%>Implemented in OLE's default handler to access remote server's <i>IDataObject</i> implementation. Used in OLE Documents</td>
</tr>
<tr valign=top>
<td class=label width=32%><b>OLE Documents: Embedding</b></td>
<td class=label width=68%></td>
</tr>
<tr valign=top>
<td width=32%><i>IOleObject</i></td>
<td width=68%>Expose compound document object functionality</td>
</tr>
<tr valign=top>
<td width=32%><i>IOleClientSite</i></td>
<td width=68%>Provide container-side information and functions to compound document objects</td>
</tr>
<tr valign=top>
<td width=32%><i>OleCreate, OleCreateFromData, OleCreateFromFile; OleQueryCreateFromData</i></td>
<td width=68%>Access custom implementations of embedded compound document objects depending on where the source information exists). <i>OleQueryCreateFromData</i> checks if <i>OleCreateFromData</i> will work.</td>
</tr>
<tr valign=top>
<td class=label width=32%><b>OLE Documents: Linking</b></td>
<td class=label width=68%></td>
</tr>
<tr valign=top>
<td width=32%><i>IOleLink</i></td>
<td width=68%>Expose from in-process implementations of linked compound document objects (usually taken from OLE's default handler).</td>
</tr>
<tr valign=top>
<td width=32%><i>OleCreateLink, OleCreateLinkFromData, OleCreateLinkToFile; OleQueryCreateLinkFromData</i></td>
<td width=68%>Access custom implementations of linked compound document objects depending on where the source information exists). <i>OleQueryCreateLinkFromData</i> checks if <i>OleCreateLinkFromData</i> will work.</td>
</tr>
<tr valign=top>
<td width=32%><i>IOleContainer, IOleItemContainer</i></td>
<td width=68%>Enumerate objects within a generic container (usually compound document container, but not necessarily). <i>IOleItemContainer</i> supports the additional step of binding an item moniker.</td>
</tr>
<tr valign=top>
<td class=label width=32%><b>OLE Documents: In-Place Activation</b></td>
<td class=label width=68%><b><br>
</b></td>
</tr>
<tr valign=top>
<td width=32%><i>IOleInPlaceObject, IOleInPlaceActiveObject</i></td>
<td width=68%>Expose object-side functionality for in-place activation support (interfaces derive from <i>IOleWindow</i>)</td>
</tr>
<tr valign=top>
<td width=32%><i>IOleInPlaceFrame, IOleInPlaceUIWindow, IOleInPlaceSite</i></td>
<td width=68%>Expose container-side functionality for in-place activation support (interfaces derive from <i>IOleWindow</i>)</td>
</tr>
<tr valign=top>
<td width=32%><i>OleCreateMenuDescriptor, OleDestroyMenuDescriptor, OleSetMenuDescriptor, OleTranslateAccelerator</i></td>
<td width=68%>OLE-provided helper functions for in-place activation.</td>
</tr>
<tr valign=top>
<td class=label width=32%><b>OLE Documents: OLE 1 Compatibility</b></td>
<td class=label width=68%><b><br>
</b></td>
</tr>
<tr valign=top>
<td width=32%><i>CoIsOle1Class</i></td>
<td width=68%>Helper to check if a class is an OLE 1 compound document object.</td>
</tr>
<tr valign=top>
<td width=32%><i>OleConvertIStorageToOLE-STREAM[Ex], OleConvertOLE-STREAMToIStorage[Ex]</i></td>
<td width=68%>Helper functions for a container providing compatibility with OLE 1 compound documents.</td>
</tr>
<tr valign=top>
<td class=label width=32%><b>OLE Controls</b></td>
<td class=label width=68%></td>
</tr>
<tr valign=top>
<td width=32%><i>IOleControl</i></td>
<td width=68%>Expose OLE Control specifics to a container dealing with keyboard mnemonics and ambient property changes.</td>
</tr>
<tr valign=top>
<td width=32%><i>IOleControlSite</i></td>
<td width=68%>Expose OLE Control Container specifics to an OLE Control.</td>
</tr>
<tr valign=top>
<td width=32%><i>ISimpleFrameSite</i></td>
<td width=68%>Expose an OLE Control that is merely a visual frame around a set of other controls that filters messages going to the controls within it to provide group behavior for a set of controls (like radio buttons).</td>
</tr>
</table><br>
</BODY>
</HTML>
