<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Replacing DLLs in Memory</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_win32_replacing_dlls_in_memory_pt"></a>Replacing DLLs in Memory</h2>
<p>
Installation programs often need to replace old .DLL files with new versions. However, what if the DLL is already in memory? It is still possible to replace the DLL. The method you use to replace DLLs in memory depends on the platform. <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="../../notopic_0pk4.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_msi_roadmap_to_installer_technology_documentation">
</object><a href=JavaScript:alink_1.Click()>Microsoft Installer Technology</a>, provides a mechanism for handling files in use.</p>
<h4>Windows NT: </h4>
<p>
To replace DLLs already loaded in memory, use the <object id=alink_2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="../../notopic_0pk4.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_win32_movefileex">
</object><a href=JavaScript:alink_2.Click()><b>MoveFileEx</b></a> function.</p>
<h4>Windows 95:</h4>
<p>
Windows 95 does not allow a .DLL file to be replaced if the DLL is currently loaded into memory. To solve this problem, your installation program must copy the new .DLL files to the user's machine, giving each new .DLL file a temporary name that is different from that of the corresponding old .DLL file. Your installation program must also copy a file called WININIT.INI to the user's machine. The WININIT.INI file is processed by the WININIT.EXE program when the system is restarted, before any DLLs are loaded. The WININIT.INI file specifies the destination path and filename for each new DLL. </p>
<p>
The WININIT.INI file contains a [rename] section that specifies the source and destination path and filenames for the new DLLs. The entries in the [rename] section have the following syntax.</p>
<pre><code>DestinationFileName=SourceFileName 
 </code></pre>
<p>
The following syntax is used to delete a file.</p>
<pre><code>NUL=SourceFileName 
 </code></pre>
<p>
The following example shows a [rename] section from a WININIT.INI file.</p>
<pre><code>[rename] 
C:\WINDOWS\Fonts\arial.ttf=C:\WINDOWS\Fonts\arial.win 
C:\WINDOWS\SYSTEM\advapi32.dll=C:\WINDOWS\SYSTEM\advapi32.tmp 
 </code></pre>
<p>
When the system is restarted, it searches for a WININIT.INI file and, if it finds one, runs WININIT.EXE on the file. After processing the file, WININIT.EXE renames it to WININIT.BAK.</p>
<p>
The DestinationFileName and SourceFileName must both be short (8.3) names instead of long filenames because WININIT.EXE is a non-Windows application and runs before the protected mode disk system is loaded. Because long filenames are only visible when the protected mode disk system is loaded, WININIT.EXE won't see them, and therefore, won't process them.</p>
<p>&nbsp;</p></body>
</HTML>
