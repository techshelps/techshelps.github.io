<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IEnumWbemClassObject::NextAsync</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_hmm_ienumwbemclassobject_nextasync"></a>IEnumWbemClassObject::NextAsync</h1>
<p>
<span style=color:#FF0000>[This is preliminary documentation and subject to change.]</span> </p>
<p>
The <b>IEnumWbemClassObject::NextAsync</b> method is used when a controlled asynchronous retrieval of objects to a sink is required. Normal asynchronous retrieval, such as a call to <a href="hmmref_99sz.htm"><b>IWbemServices::ExecQueryAsync</b></a><i>, </i>results in uncontrolled delivery of objects to the caller's implementation of <a href="hmmref_8qnf.htm"><b>IWbemObjectSink</b></a>.<i> </i>This method is helpful for cases where components can only handle a reduced rate of delivery.</p>
<pre><code><b>HRESULT NextAsync(
  [in] ULONGARG</b><i> uCount</i><b>,</b><i> </i>
<b>  [in] IWbemObjectSink </b><i>*pSink </i>
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>uCount</i></dt>
<dd>
The number of objects being requested.</dd>
<dt>
<i>pSink</i></dt>
<dd>
The sink to receive the objects. The sink must be implemented by the caller.
</dd>
</dl>
<h4>Return Values</h4>
<table cellspacing=4 cols=2>
<tr valign=top>
<td width=20%>S_OK</td>
<td width=80%>The call succeeded. The system begins delivery of objects to the sink.</td>
</tr>
<tr valign=top>
<td width=20%>S_FALSE</td>
<td width=80%>The call failed, and no objects will be delivered to the sink. <p>
A call to the COM function <b>GetErrorInfo</b> provides more information about the error.</p>
</td>
</tr>
</table><br>
<h4>Remarks</h4>
<p>
This call returns immediately, and delivery to the sink occurs in the background. If multiple calls are made to this method from one or more threads, they are logically queued, and the order of calls and object delivery is preserved. A call to <b>Reset</b> does not affect delivery of objects currently in progress as a result of previous calls. <b>Reset</b> only causes new calls to start at the beginning of the object sequence.</p>
<p>
The <a href="hmmref_7neb.htm"><b>IWbemObjectSink::SetStatus</b></a> method is called to indicate the actual result of the request. As the objects become available, <a href="hmmref_9y3p.htm"><b>IWbemObjectSink::Indicate</b></a> is called zero or more times to deliver the objects, followed by a call to <b>IWbemObjectSink::SetStatus</b> with a value of S_OK, if uCount items are returned. </p>
<p>
If fewer objects are available than the number requested, then <b>IWbemObjectSink::Indicate</b> is called for those objects that are available. This is followed by a call to <b>IWbemObjectSink::SetStatus</b> with a value of S_FALSE, or the error code if an error occurred. If there are no available objects, <b>Indicate</b> is not called.</p>
<h4>Sample Code</h4>
<pre><code>void ListObjects3(
    IEnumWbemClassObject *pEnum,
    IWbemObjectSink *pSink
    )
{
    HRESULT hRes;

    while (1)
    {
        hRes = pEnum-&gt;NextAsync(5, pSink);

            // Wait until sink is ready for more by
            // some private mechanism. Note that hRes gives
            // no indication as to whether to continue the
            // enumeration or not.

           BOOL bContinue = WaitUntilMoreObjectsNeeded();

            if (!bContinue)
                break;
    }
}
 </code></pre>
<p>&nbsp;</p></body>
</HTML>
