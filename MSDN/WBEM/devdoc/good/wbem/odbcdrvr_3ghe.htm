<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The SQL Grammar</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_hmm_the_sql_grammar"></a>The SQL Grammar</h1>
<p>
<span style=color:#FF0000>[This is preliminary documentation and subject to change.]</span> </p>
<p>
The adapter supports a subset of the ODBC Minimum SQL Grammar. It does not support Data Definition Language (DDL) constructs and writeable Data Manipulation Language (DML) constructs. If the data provider supports queries, the adapter decomposes the ODBC Minimum SQL into a series of WBEM Level 1 queries, and then passes them to the data provider. Thus, queries can be optimized for specific data providers. </p>
<p>
<b>ODBC Minimum SQL Grammar</b></p>
<table cellspacing=4 cols=2>
<tr valign=top>
<td width=48%>select-statement::=</td>
<td width=52%>SELECT [ALL|DISTINCT] select-list<p>
FROM table-reference-list</p>
<p>
[WHERE search-condition]</p>
<p>
[order-by-clause]</p>
</td>
</tr>
<tr valign=top>
<td width=48%>select-list::=</td>
<td width=52%>* | select-sublist[,select-sublist]</td>
</tr>
<tr valign=top>
<td width=48%>select-sublist::=</td>
<td width=52%>expression</td>
</tr>
<tr valign=top>
<td width=48%>expression::=</td>
<td width=52%>term|expression {+|-} term</td>
</tr>
<tr valign=top>
<td width=48%>term::=</td>
<td width=52%>factor | term {*|/} factor</td>
</tr>
<tr valign=top>
<td width=48%>factor::=</td>
<td width=52%>[+|-] primary</td>
</tr>
<tr valign=top>
<td width=48%>primary:: </td>
<td width=52%>column-name |<p>
dynamic-parameter |</p>
<p>
literal |</p>
<p>
(expression)</p>
</td>
</tr>
<tr valign=top>
<td width=48%>dynamic-parameter:=</td>
<td width=52%>?</td>
</tr>
<tr valign=top>
<td width=48%>literal::=</td>
<td width=52%>character-string-literal</td>
</tr>
<tr valign=top>
<td width=48%>character-string-literal::=</td>
<td width=52%>'{character}...'</td>
</tr>
<tr valign=top>
<td width=48%>character::=</td>
<td width=52%>our character set</td>
</tr>
<tr valign=top>
<td width=48%>column-name::=</td>
<td width=52%>[table-name.]column-identifier</td>
</tr>
<tr valign=top>
<td width=48%>column-identifier::=</td>
<td width=52%>user-defined-name</td>
</tr>
<tr valign=top>
<td width=48%>user-defined-name::=</td>
<td width=52%>letter[digit|letter|_]...</td>
</tr>
<tr valign=top>
<td width=48%>table-reference-list::=</td>
<td width=52%>table-reference[table-reference]..</td>
</tr>
<tr valign=top>
<td width=48%>table-reference::=</td>
<td width=52%>table-name</td>
</tr>
<tr valign=top>
<td width=48%>table-name::=</td>
<td width=52%>table-identifier</td>
</tr>
<tr valign=top>
<td width=48%>table-identifier::=</td>
<td width=52%>user-defined-name</td>
</tr>
<tr valign=top>
<td width=48%>search-condition::=</td>
<td width=52%>boolean-term [OR search-condition]</td>
</tr>
<tr valign=top>
<td width=48%>boolean-term::=</td>
<td width=52%>boolean-factor [AND boolean-term]</td>
</tr>
<tr valign=top>
<td width=48%>boolean-factor::=</td>
<td width=52%>[NOT]boolean-primary</td>
</tr>
<tr valign=top>
<td width=48%>boolean-primary::=</td>
<td width=52%>predicate | (search-condition)</td>
</tr>
<tr valign=top>
<td width=48%>predicate::=</td>
<td width=52%>comparison-predicate |<p>
like-predicate |</p>
<p>
null-predicate</p>
</td>
</tr>
<tr valign=top>
<td width=48%>comparison-predicate::=</td>
<td width=52%>expression comparison-operator expression</td>
</tr>
<tr valign=top>
<td width=48%>comparison-operator::=</td>
<td width=52%>&lt;|&gt;|&lt;=|&gt;=|=|&lt;&gt;</td>
</tr>
<tr valign=top>
<td width=48%>like-predicate::=</td>
<td width=52%>expression [NOT] LIKE</td>
</tr>
<tr valign=top>
<td width=48%>pattern-value::=</td>
<td width=52%>character-string-literal | dynamic-parameter</td>
</tr>
<tr valign=top>
<td width=48%>null-predicate::=</td>
<td width=52%>column-name IS [NOT] NULL</td>
</tr>
<tr valign=top>
<td width=48%>order-by-clause::=</td>
<td width=52%>ORDER BY sort-specification[,sort-specification]</td>
</tr>
<tr valign=top>
<td width=48%>sort-specification::=</td>
<td width=52%>{unsigned-integer | column} [ASC |DESC]</td>
</tr>
</table><br>
<p>
In Level 1 provider SQL grammar, all operations are on a single table, and dynamic parameters are not supported. This grammar can be converted into postfix notation, which means the functions are preceded by all their operands, to facilitate the implementation of a simpler stack-based SQL parser in the data provider.</p>
<p>
<b>Level 1 Provider SQL Grammar</b></p>
<table cellspacing=4 cols=2>
<tr valign=top>
<td width=48%>select-statement::=</td>
<td width=52%>SELECT [ALL|DISTINCT] select-list<p>
FROM table-reference</p>
<p>
[WHERE search-condition]</p>
<p>
[order-by-clause]</p>
</td>
</tr>
<tr valign=top>
<td width=48%>select-list::=</td>
<td width=52%>* | select-sublist[,select-sublist]</td>
</tr>
<tr valign=top>
<td width=48%>select-sublist::=</td>
<td width=52%>expression</td>
</tr>
<tr valign=top>
<td width=48%>expression::=</td>
<td width=52%>term|expression {+|-} term</td>
</tr>
<tr valign=top>
<td width=48%>term::=</td>
<td width=52%>factor | term {*|/} factor</td>
</tr>
<tr valign=top>
<td width=48%>factor::=</td>
<td width=52%>[+|-] primary</td>
</tr>
<tr valign=top>
<td width=48%>primary:: </td>
<td width=52%>column-name |<p>
literal |</p>
<p>
(expression)</p>
</td>
</tr>
<tr valign=top>
<td width=48%>literal::=</td>
<td width=52%>character-string-literal</td>
</tr>
<tr valign=top>
<td width=48%>character-string-literal::=</td>
<td width=52%>'{character}...'</td>
</tr>
<tr valign=top>
<td width=48%>character::=</td>
<td width=52%>our character set</td>
</tr>
<tr valign=top>
<td width=48%>column-name::=</td>
<td width=52%>[table-name.]column-identifier</td>
</tr>
<tr valign=top>
<td width=48%>column-identifier::=</td>
<td width=52%>user-defined-name</td>
</tr>
<tr valign=top>
<td width=48%>user-defined-name::=</td>
<td width=52%>letter[digit|letter|_]...</td>
</tr>
<tr valign=top>
<td width=48%>table-reference::=</td>
<td width=52%>table-name</td>
</tr>
<tr valign=top>
<td width=48%>table-name::=</td>
<td width=52%>table-identifier</td>
</tr>
<tr valign=top>
<td width=48%>table-identifier::=</td>
<td width=52%>user-defined-name</td>
</tr>
<tr valign=top>
<td width=48%>search-condition::=</td>
<td width=52%>boolean-term [OR search-condition]</td>
</tr>
<tr valign=top>
<td width=48%>boolean-term::=</td>
<td width=52%>boolean-factor [AND boolean-term]</td>
</tr>
<tr valign=top>
<td width=48%>boolean-factor::=</td>
<td width=52%>[NOT]boolean-primary</td>
</tr>
<tr valign=top>
<td width=48%>boolean-primary::=</td>
<td width=52%>predicate | (search-condition)</td>
</tr>
<tr valign=top>
<td width=48%>predicate::=</td>
<td width=52%>comparison-predicate |<p>
like-predicate |</p>
<p>
null-predicate</p>
</td>
</tr>
<tr valign=top>
<td width=48%>comparison-predicate::=</td>
<td width=52%>expression comparison-operator expression</td>
</tr>
<tr valign=top>
<td width=48%>comparison-operator::=</td>
<td width=52%>&lt;|&gt;|&lt;=|&gt;=|=|&lt;&gt;</td>
</tr>
<tr valign=top>
<td width=48%>like-predicate::=</td>
<td width=52%>expression [NOT] LIKE</td>
</tr>
<tr valign=top>
<td width=48%>pattern-value::=</td>
<td width=52%>character-string-literal | dynamic-parameter</td>
</tr>
<tr valign=top>
<td width=48%>null-predicate::=</td>
<td width=52%>column-name IS [NOT] NULL</td>
</tr>
<tr valign=top>
<td width=48%>order-by-clause::=</td>
<td width=52%>ORDER BY sort-specification[,sort-specification]</td>
</tr>
<tr valign=top>
<td width=48%>sort-specification::=</td>
<td width=52%>{unsigned-integer | column} [ASC |DESC]</td>
</tr>
</table>
<p>&nbsp;</p></body>
</HTML>
