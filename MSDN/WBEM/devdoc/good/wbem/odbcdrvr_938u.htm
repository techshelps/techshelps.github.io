<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SQL Optimization</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_hmm_sql_optimization"></a>SQL Optimization</h1>
<p>
<span style=color:#FF0000>[This is preliminary documentation and subject to change.]</span> </p>
<p>
The WBEM ODBC adapter does not provide any traditional SQL query optimization. However, it does support decomposition of ODBC Minimum Level SQL queries into WBEM Level 1 queries. The data provider can then specify optimizations on single tables. </p>
<p>
For the grammar of WBEM Level 1 queries, see <a href="odbcdrvr_3ghe.htm">The SQL Grammar</a>. To summarize, a Level 1 query is an ODBC minimum-level query that can only act on a single table. The adapter decomposes an arbitrary ODBC minimum SQL into a number of these queries and sends them to the gateway.</p>
<p>
During the <a href="odbcdrvr_8r3o.htm">SQLPrepare phase</a>, the adapter examines the <b>WHERE</b> predicate tree. If no <b>WHERE</b> predicate tree exists, no optimization is performed. It then attempts to decompose the<b> </b>SQL statement into Level 1 queries. If successful, each Level 1 query is sent to the gateway server via an <b>ExecQuery</b> call. If query decomposition is unsuccessful, the adapter enumerates the whole row of instances as before.</p>
<p>
The generation of the Level 1 query is handled by two classes. First, the <b>PredicateParser</b> class generates the <b>WHERE</b> predicate for the desired table. It does this by scanning the parse tree for the current SQL<b> </b>statement. It then converts the <b>WHERE</b> predicate portion of the parse tree into an ASCII text string for the desired table. The next phase is to generate the select list in the WBEM Level 1 query for the columns required for the desired table. This is handled by the <b>TableColumnInfo</b> class, which manages associations between tables and their associated columns. The <b>TableColumnInfo</b> class scans the parse tree for the current SQL statement and extracts any column names for the currently chosen table. It can then generate an ASCII select list text string from these column names.</p>
<p>
Another optimization is also performed during the adapter's Parse phase. In the following SQL statement,</p>
<pre><code>SELECT c1t1 FROM t1, t2
</code></pre>
<p>
<b>t2</b> is redundant. The adapter attempts to identify these redundancies and remove them from the parse tree.</p>
<p>
This optimization is handled by the <b>TableColumnInfo</b> class. The <b>TableColumnInfo</b> class <b>will </b>scans the parse tree for the current SQL statement, and generates associations between tables and columns. It highlights any tables that do not have any associated columns. Once the tables have been identified, they can be removed from the parse tree.</p>
<p>&nbsp;</p></body>
</HTML>
