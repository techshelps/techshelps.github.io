<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Declaring Methods</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_hmm_declaring_methods"></a>Declaring Methods</h1>
<p>
<span style=color:#FF0000>[This is preliminary documentation and subject to change.]</span> </p>
<p>
Class declarations can include one or more methods. A method is a function the class defines. An implementation of a method may or may not be available. Whereas the definition of methods are inherited between classes, their implementation may not be. The <b>Implemented</b> qualifier must be used to describe a method that has an available implementation for a given class. Omission of the <b>Implemented</b> qualifier indicates that the method is lacking implementation. </p>
<p>
If a method is redeclared for a class without the <b>Implemented</b> qualifier, it is considered unimplemented for that class and the invoked implementation at runtime becomes the implementation of the superclass. Therefore, a derived class always inherits the implementation of its superclass unless the derived class provides its own implementation. Redeclaration of a method in a derived class is useful only when method qualifiers are changed; such as is the case when adding the <b>Implemented</b> qualifier.</p>
<p>
When a provider is supplying the implementation of a method, it must mark the class with the <b>Provider</b> qualifier. The value of the <b>Provider</b> qualifier is the name of the provider. </p>
<p>
Every method must have a unique name; WBEM does not allow two methods with the same name and different signatures to exist in one class or within a class hierarchy. Methods can not be overloaded. </p>
<p>
The return value for a method is one of the <a href="mof_1u0j.htm">CIM data types</a>. Parameters are listed with both their name and type and must be marked either as input parameters, output parameters, or both input and output parameters using the <b>In</b>, <b>Out</b>, or <b>In, Out</b> qualifiers:</p>
<pre><code>[Dynamic, Provider ("ProviderX")]
class MyClass
{
    [Implemented] 
    sint32 MyMethod1 ([in] sint32 InParam);
    [Implemented] 
    void MyMethod2 ([in] sint32 InParam, [out] sint32 OutParam);
    [Implemented] 
    sint32 MyMethod3 ([in, out] sint32 InOutParam);
}
</code></pre>
<p>
If the same parameter name appears with both an <b>In</b> and an <b>Out</b> qualifier, it it is conceptually the same as the <b>In, Out</b> qualifier on a single parameter.  However, by using separate declarations, the input and output parameters can be treated differently. For example, other qualifiers can be added only to the input parameter.</p>
<p>
Schema objects (existing CIM repository classes) can be used as either parameters or return values, as the following example illustrates:</p>
<pre><code>[Dynamic, Provider ("ProviderX")]
class MyClass
{
    [Implemented] sint32 MyMethod1 ([in] Win32LogicalDisk DiskParam);
    [Implemented] 
    Win32LogicalDisk MyMethod2 ([in] string DiskVolLabel);
}</code></pre>
<p>
Arrays can only be passed as parameters; they are not allowed as return value types. Arrays can be unbounded or have an explicit size, as is illustrated below:</p>
<pre><code>[Dynamic, Provider ("ProviderX")]
class MyClass
{
    [Implemented] 
    sint32 MyMethod1 ([in] Win32LogicalDisk DiskParam[]);
    [Implemented] 
    sint32 MyMethod2 ([in] Win32LogicalDisk DiskParam[32]);
}</code></pre>
<p>
The MOF language supports the use of object references as parameters. Object references are paths to objects. The parameter type object ref can be used to indicate a generic path to any object. Using object references reduces transport time and encoding if the object already exists in its entirety within the CIM repository. The following class definition shows how to include two object references: one to a Win32LogicalDisk object and the other to a generic object: </p>
<pre><code>[Dynamic, Provider("ProviderX")]
class MyClass
{
    [Implemented] 
    sint32 MyMethod1 ([in] Win32LogicalDisk ref DiskRef);
    [Implemented] 
    sint32 MyMethod2 ([in] object ref AnyObject);
}
</code></pre>
<p>&nbsp;</p></body>
</HTML>
