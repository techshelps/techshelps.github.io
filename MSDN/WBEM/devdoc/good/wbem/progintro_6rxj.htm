<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Semisynchronous Processing</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_hmm_semisynchronous_processing"></a>Semisynchronous Processing</h1>
<p>
<span style=color:#FF0000>[This is preliminary documentation and subject to change.]</span> </p>
<p>
Semisynchronous processing is a compromise between synchronous processing and asynchronous processing, providing the advantages of each technique. Semisynchronous processing can be used by management applications to improve the speed and efficiency of processing queries, enumerations, and events. </p>
<p>
With synchronous processing, applications call the methods of the <b>IEnumWbemClassObject</b> to retrieve objects. The application's thread is blocked until the call completes. This blockage can cause a lengthy delay in processing time. </p>
<p>
With asynchronous query processing, applications must implement <b>IWbemObjectSink</b>. WBEM calls <b>IWbemObjectSink::Indicate</b> to deliver objects, allowing the application to continue with other work. One disadvantage with asynchronous processing is that it can be difficult for a provider or CIMOM to control the flow of information back to the application process. Large result sets can take a considerable amount of time to deliver, forcing the application to spend significant system resources to handle the delivery. </p>
<p>
The semisynchronous<i> </i>technique solves both the thread blockage and uncontrolled delivery problems. To take advantage of semisynchronous query processing, an application:
<ol>
<li>
Calls <a href="hmmref_57qx.htm"><b>IWbemServices::ExecQuery</b></a> to execute the query.</li>
<li>
Calls <a href="hmmref_994k.htm"><b>IEnumWbemClassObject::Next</b></a><b> </b>or<b> <a href="hmmref_7s9v.htm">IEnumWbemClassObject::NextAsync</a></b> using the <i>ppEnum</i><b> </b>pointer returned by <b>ExecQuery </b>to retrieve the results of the query in small groups. The <i>uCount</i> parameter should be set to the number of objects to be returned in the group. </li>
<li>
Sets the <i>pSink</i> parameter if using <b>NextAsync</b> to point to an implementation of the <b>IWbemObjectSink</b> interface. As the implementor of <b>NextAsync</b>, CIMOM calls the <a href="hmmref_9y3p.htm"><b>IWbemObjectSink::Indicate</b></a> method to deliver the query results asynchronously.  </li>
</ol>
<p>
The <b>IEnumWbemClassObject::NextAsync</b> call is nonblocking and returns immediately. In the background CIMOM begins to deliver the requested number of objects by calling <b>IWbemObjectSink::Indicate</b>. It then stops, waiting for another <b>NextAsync</b><i> </i>call. <b>NextAsync</b> places the number of objects actually returned in the <i>lObjectCount</i> parameter and the objects themselves in the contents of the <i>ppObjArray</i> parameter.</p>
<p>
If the entire result set is not needed, an application should release the enumerator by calling <b>IEnumWbemClassObject</b>::<b>Release</b>. Calling this <b>Release</b> method results in CIMOM canceling its delivery of any remaining objects.</p>
<p>&nbsp;</p></body>
</HTML>
