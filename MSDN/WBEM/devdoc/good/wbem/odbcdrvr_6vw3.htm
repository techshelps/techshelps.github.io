<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Multi-threading Issues in the Adapter and Client Applications</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_hmm_multi_threading_issues_in_the_adapter_and_client_applications"></a>Multi-threading Issues in the Adapter and Client Applications</h1>
<p>
<span style=color:#FF0000>[This is preliminary documentation and subject to change.]</span> </p>
<p>
Since the ODBC Driver Manager is thread-safe, the adapter is inherently thread-safe.</p>
<p>
The only exception to this is where an <b>SQLCancel</b> is invoked on synchronously executing the <a href="odbcdrvr_9wdv.htm">statement handle</a> <b>hStmt</b> object from a different thread. The Driver Manager uses critical sections (non-reentrant pieces of code) on the <a href="odbcdrvr_9wdv.htm">environment handle</a> <b>hEnvs</b>, the <a href="odbcdrvr_9wdv.htm">connection handle</a> <b>hDbcs</b>, and <b>hStmts</b> to guarantee synchronous operation on these objects. </p>
<p>
An action on one of these objects causes the Driver Manager to enter a critical section for that object. In the case of <b>SQLCancel</b>, the Driver Manager enters a "cancel-in-progress" critical section. This prevents <b>SQLCancel</b> from being reentered before the first one is completed. The adapter's <b>SQLCancel</b> is then invoked. </p>
<p>
If there is no simultaneous action on the statement handle, the <b>SQLCancel</b> is treated as an <b>SQLFreeStmt</b> or <b>SQL_CLOSE</b> operation. The adapter returns <b>SQL_SUCCESS_WITH_INFO</b> with a <b>SQLSTATE</b> of 01S05. This causes the Driver Manager to return <b>SQL_SUCCESS</b> to the application. </p>
<p>
If there was simultaneous action on the statement handle, the return code from the original thread's ODBC function determines if the <b>SQLCancel</b> was successful. </p>
<p>
The adapter's <b>SQLCancel</b> is implemented as follows:
<ol>
<li>
In the adapter, each statement has a critical section. </li>
<li>
This critical section is entered on all ODBC functions that take a statement handle (except <b>SQLCancel</b>), and is left upon exit. </li>
<li>
The <b>SQLCancel</b> code inspects this critical section to determine if it has been entered (non-zero owning thread). This is the test for determining if an <b>SQLFreeStmt/SQL_CLOSE</b> needs to be called. </li>
<li>
If there is activity on the statement, the adapter sets a CANCEL flag on the statement handle, which the original thread periodically checks for to determine if it needs to cancel the operation, however it deems appropriate. </li>
</ol>
<p>
The <i>ODBC 2.0 Programmer's Reference and SDK Guide</i> suggests two techniques for writing thread-safe multithreaded ODBC applications: 
<ul>
<li>
Have multiple statement handles on a single connection handle, with a single thread per statement handle. </li>
<li>
Have multiple connection handles, with a single statement handle per connection handle and a single thread per connection handle. </li>
</ul>
<p>
The application must know which operations are being performed on an object. For example, if a thread does an <b>SQLFetch</b> on a statement handle, begins to process the data, and a second thread does an <b>SQLFetch</b> on the same statement handle into the same buffer, the first thread might get columns from the first row of the rowset mixed with columns from the second row. </p>
<p>
Also, the application must be particularly careful in performing <b>SQLFreeStmts</b>. For example, if an application attempts to perform an operation on a statement handle that is being freed, it blocks on the statement handle. When it unblocks, it fails with an access violation because the statement handle no longer exists. The application must ensure that the statement handle is inactive before calling <b>SQLFreeStmt</b>, <b>SQL_DROP</b>, or <b>SQLDisconnect</b>.</p>
<h4>See Also</h4>
<p>
<a href="odbcdrvr_9wdv.htm">ODBC Handles</a></p>
<p>&nbsp;</p></body>
</HTML>
