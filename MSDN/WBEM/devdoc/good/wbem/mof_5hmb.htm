<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using Qualifiers</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_hmm_using_qualifiers"></a>Using Qualifiers</h1>
<p>
<span style=color:#FF0000>[This is preliminary documentation and subject to change.]</span> </p>
<p>
Qualifiers are modifiers that can be used to describe a class, an instance, a property, a method, or a parameter. Creators of classes and instances can attach qualifiers to their class and instance declarations to provide the user of those declarations, typically management applications, with more detail. Similar to properties, qualifiers have a name, a type, and a value. Unlike properties, the value of a qualifier rarely changes. Also unlike properties, a qualifier can be associated with a flag known as a flavor. Qualifier flavors indicate how a qualifier is used. For example, the qualifier flavor  <b>NotOverrideable</b> indicates that when a qualifier is propagated from a base class to a derived class or from a class to an instance, its value cannot be changed. All inherited versions of the qualifier have the original value.</p>
<p>
Some examples of qualifiers are:</p>
<table cellspacing=4 cols=3>
<tr valign=top>
<th align=left width=21%>Qualifier </th>
<th align=left width=19%>Used with</th>
<th align=left width=60%>Purpose</th>
</tr>
<tr valign=top>
<td width=21%><b>Dynamic</b></td>
<td width=19%>Classes</td>
<td width=60%>Indicates that instances of a class are supplied by a provider.</td>
</tr>
<tr valign=top>
<td width=21%><b>Implemented</b></td>
<td width=19%>Methods</td>
<td width=60%>Indicates that an implementation of a method is available. </td>
</tr>
<tr valign=top>
<td width=21%><b>In</b></td>
<td width=19%>Parameters</td>
<td width=60%>Describes a parameter as an input parameter.</td>
</tr>
<tr valign=top>
<td width=21%><b>Read</b></td>
<td width=19%>Properties</td>
<td width=60%>Describes a property's value as read-only.</td>
</tr>
<tr valign=top>
<td width=21%><b>Units</b></td>
<td width=19%>Properties</td>
<td width=60%>Describes a property value's unit of measure.</td>
</tr>
</table><br>
<p>
Some of the qualifiers that are commonly used in MOF syntax are defined by WBEM and are known as <a href="hmmqual_0of9.htm">standard qualifiers</a>. The <b>Dynamic</b> and <b>Read</b> qualifiers are examples of standard qualifiers. Other qualifiers are included in the Desktop Management Task Force (DMTF) CIM specification, available from http:// www.dmtf.org. Still other qualifiers are defined by the creators of new classes, typically providers. The <b>Units</b> qualifier is an example of a non-standard, provider-specific qualifier. </p>
<p>
WBEM enforces virtually no rules regarding the the naming of qualifiers or their use. The only restriction is that neither the standard CIMOM qualifiers or those included in the CIM specification can be redefined. To avoid potential conflict, WBEM recommends that providers prefix their new qualifiers with the name or their schema. </p>
<p>
In MOF syntax, a qualifier is placed before the keyword or identifier that it is describing:</p>
<pre><code>[QualifierName1 ("QualifierValue1")]
</code></pre>
<p>
The following syntax shows the placement of class qualifiers, property qualifiers, method qualifiers, and parameter qualifiers:</p>
<pre><code>[qualifiers...]
class MyClass
{
    [qualifiers...]  uint32 dwNumber;
    [qualifiers...]  sint32 ValueMethod ();
    sint32 MyMethod ([qualifiers...] sint32 Param);
};
 </code></pre>
<p>
All qualifier names are case-insensitive. Their type is inferred from the declaration syntax as is described in the following table:</p>
<table cellspacing=4 cols=3>
<tr valign=top>
<th align=left width=31%>Qualifier type</th>
<th align=left width=34%>CIM type</th>
<th align=left width=35%>Automation type</th>
</tr>
<tr valign=top>
<td width=31%>String</td>
<td width=34%>String</td>
<td width=35%>VT_BSTR</td>
</tr>
<tr valign=top>
<td width=31%>Signed or unsigned 16 bit number </td>
<td width=34%>Sint16, Uint16</td>
<td width=35%>VT_I2</td>
</tr>
<tr valign=top>
<td width=31%>Signed or unsigned 32-bit number </td>
<td width=34%>Sint32, Sin32</td>
<td width=35%>VT_I4</td>
</tr>
<tr valign=top>
<td width=31%>Signed or unsigned 64-bit number</td>
<td width=34%>Sint64, Uint64</td>
<td width=35%>VT_BSTR</td>
</tr>
<tr valign=top>
<td width=31%>Floating-point</td>
<td width=34%>Real8</td>
<td width=35%>VT-R8</td>
</tr>
<tr valign=top>
<td width=31%>Boolean</td>
<td width=34%>Boolean</td>
<td width=35%>VT_BOOL</td>
</tr>
</table><br>
<p>
Homogeneous arrays of any of these types are supported. The other Automation types such as VT_I2 and VT_NULL are not supported.</p>
<p>
The following class definition  is an example of a derived class that has class qualifiers. The class qualifiers, <b>Dynamic</b> and <b>Provider</b>, are standard qualifiers defined by WBEM. <b>Dynamic</b> is a boolean qualifier that when set indicates that instances of the class are dynamically provided. <b>Provider</b> is a string qualifier supplying the name of the provider associated with the class.</p>
<pre><code>[Dynamic, Provider ("ProviderX")] 
class MyDerivedClass : MyClass
{
    [Implemented] uint32 dwNumber ;
    [Implemented] sint32 ValueMethod();
    [Implemented] sint32 MyMethod ([in] sint32 Param)
} ;
</code></pre>
<p>
The next definition shows how to use qualifiers with instances. The two instances of the MyClass class are differentiated using the Description qualifier:</p>
<pre><code>[Description ("This instance is the first")] 
instance of MyClass
{
    dwNumber = 1;
} ;

  [Description ("This instance is the second")] 
instance of MyClass
{
    dwNumber = 2;
} ;
</code></pre>
<p>
One of the most common uses of property qualifiers is to associate access permissions with a property. For example, this class has three properties, two that are read-only and one that is read/write. The read/write property is also marked with the <b>Key</b> qualifier, identifying it as the unique identifier for the class. Although keys are optional like all other qualifiers, most classes include one. Classes that are intended solely as abstract base classes do not necessarily include a key as a property. </p>
<pre><code>class MyClass3 
{
    [read, write, KEY] STRING  MyKey;
    [read] real32 MyProp1;
    [read] real64 MyProp2;
};
</code></pre>
<p>
WBEM defines two qualifiers that are commonly used with methods: <b>Implemented</b> and <b>Static</b>. The <b>Implemented</b> qualifier indicates whether a method has an implementation available for a particular class or instance. Because the data type of this qualifier is boolean, its absence indicates the absence of an implementation. The <b>Static</b> qualifier marks a method as able to run against an object path that refers to a class definition. These qualilfiers are used as follows:</p>
<pre><code>[Dynamic, Provider ("ProviderY")]
class MyMethodClass 
{
    [read, write, KEY] STRING  MyKey;
    [implemented] sint32 MyMethod1 ();;
    [static] sint32 MyMethod2();
};
</code></pre>
<p>
Parameters to methods can have standard qualifiers that describe whether a parameter is an input parameter, an output parameter, or an input parameter and an output parameter. Other qualifiers can also be attached to method parameters. </p>
<pre><code>[Dynamic, Provider ("ProviderZ")]
class MyMethodClass 
{
    [read, write, KEY] STRING  MyKey;
    [implemented] sint32 MyMethod1 ([in] uint32 Param1);
    [static] sint32 MyMethod2 ([out] uint32 Param2);
    sint32 MyMethod3 ([in] uint32 Param1, [in, out] string Param3);
};</code></pre>
<p>&nbsp;</p></body>
</HTML>
