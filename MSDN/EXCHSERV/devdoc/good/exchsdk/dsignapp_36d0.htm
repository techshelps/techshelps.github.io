<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Performance Considerations in Memory Management</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_edk_performance_considerations_in_memory_management"></a>Performance Considerations in Memory Management</h2>
<p>
How an application uses its chosen memory allocators is just as important as choosing them in the first place. An application that spends a significant portion of its time in the heap allocator is not well-designed. It should be using custom allocators to create objects with less overhead.</p>
<p>
Multithreaded server applications can use the following features of <b>HeapAlloc</b> to improve their performance:
<ul>
<li>
Give a thread its own heap (locality) if its dynamic memory needs warrant this.</li>
<li>
Use the HEAP_NO_SERIALIZE flag to the Win32 <b>HeapAlloc</b> function to eliminate critical section waits and improve scalability. If you use this flag, however, you must manage heap access yourself or risk corrupting the heaps.</li>
<li>
Eliminate the need to free individual items by creating a temporary heap and destroying the heap when done. This saves overhead and gives more locality, thus improving performance.</li>
<li>
Eliminate the overhead of checking for memory allocation failure by using the HEAP_GENERATE_EXCEPTIONS flag to <b>HeapAlloc</b>, and handling memory allocation failure as an exception. </li>
<li>
To maximize performance by increasing locality, it may still be necessary for the application to create custom allocators for various types of objects. Using <b>HeapAlloc</b> alone may not suffice.</li>
</ul>
<p>
</p>
<p>
Another C runtime function, <b>_alloca</b>, should be used instead of the heap allocator when the item to be allocated is of function scope, requires only short-term memory use, and its size can vary. The <b>_alloca</b> function simply extends the function’s stack frame, so it is very fast. When the function returns, the allocation evaporates.</p>
<p>
It is not unusual for applications that run well on single processor systems to degrade in performance on a multiprocessor system. This is almost always the result of excessive contention for locks, particularly for critical sections. The Win32 <b>GlobalAlloc</b> function, the OLE <b>IStorage</b> and <b>IStream</b> functions, and similar allocator functions all use critical sections for synchronization. For a single processor system, it is very rare to find contention on these critical sections since the thread that owns the critical section is unlikely to be preempted. On a multiprocessor system, such contention is much more likely since more than one thread is running simultaneously. </p>
<p>
The easiest way to determine whether an application is having trouble with contention is to run the application first on a single processor machine and then on a multiprocessor machine and compare the context switches per second and the system calls per second. These will both increase when there is contention. When there is no contention on a critical section, it is very fast and requires no context switching or system calls. When there is contention (one thread tries to acquire the critical section while another thread holds it) additional system calls and context switches are required in order for the requesting thread to wait until the owning thread has released the critical section. </p>
<p>
Other interesting statistics that can uncover a performance deterioration because of an allocation problem are the number of context switches per transaction and the number of system calls per transaction. If these numbers change dramatically with the number of processors or the amount of load on the system, there is probably an allocation problem with the application.</p>
<p>&nbsp;</p></body>
</HTML>
