<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Memory Allocation for Client Applications</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_edk_memory_allocation_for_client_applications"></a>Memory Allocation for Client Applications</h2>
<p>
The most important considerations for client applications are the following:
<ul>
<li>
Portability</li>
<li>
RPC serialization</li>
<li>
Performance</li>
</ul>
<p>
</p>
<p>
For most <a href="glossary_1oo3.htm#_edk_client_application">client applications</a> (and interactive applications in particular), heap performance and serialization are not as great a factor when the application is run only on the client. They become more important when <a href="glossary_1ooi.htm#_edk_remote_procedure_call_rpc_">remote procedure calls (RPCs)</a> are involved.</p>
<p>
<a href="glossary_1ood.htm#_edk_mapi">MAPI</a> provides three functions that manage memory in a consistent way. <b>MAPIAllocateBuffer</b>, <b>MAPIAllocateMore</b>, and <b>MAPIFreeBuffer</b> enable client applications and service providers to exchange blocks of memory. <b>MAPIAllocateBuffer </b>is called initially to allocate memory for a buffer; <b>MAPIAllocateMore</b> can allocate another block of memory that is linked to the initial block. </p>
<p>
When both client applications and <a href="glossary_1ooj.htm#_edk_service_provider">service providers</a> use these functions, whoever owns and is able to release a particular block of memory is no longer an issue. The service provider can simply allocate memory blocks and the client can later release them at will, independent of the service provider. </p>
<p>
If the application has unusually high performance requirements, be aware that the MAPI allocation functions are serialized and do not offer control over the locality of allocations. Both of these factors can impair the performance of multithreaded applications. Use the Win32 memory allocator functions in this case.</p>
<p>
Another thing to consider is that the very convenience of the MAPI allocators can affect performance. For example, MAPI providers always return memory allocated using MAPI allocators. So every time a call is made to <b>IMAPIProp::GetProps</b>, <b>IMAPITable::QueryRows</b>, or any MAPI functions, the memory is released and must be reallocated for the next call, so the client allocator itself is serialized if it is a MAPI allocator.</p>
<p>
For general applications and most interactive ones, the CPU overhead incurred by the heap allocator is negligible. The difference in performance between the MAPI allocator and other allocators is also negligible. This includes many client applications and a few server applications that perform logging, reporting, link monitoring, and other tasks where flexibility and simplicity are more important than throughput.</p>
<p>
Special consideration is required for 16-bit client memory allocation. Using the Windows 3.11 heap allocator may not be appropriate for your Microsoft Exchange Server client applications. The Win32 <b>LocalAlloc</b> function relies on a fixed-size heap in the application’s data segment and is too small for most usage. The Win32 <b>GlobalAlloc</b> function returns a new segment for each allocation, and only a limited number of segments are available, so it may not be a good choice for your application either. If your application must cover all platforms, MAPI allocators are often the best choice for local heap implementation. OLE allocators can also be used. </p>
<p>
The C runtime function <b>malloc</b> has low overhead, but requires that memory is specifically freed. This function may be useful for applications if regular calls to the <b>_heapmin</b> function can be made. MAPI providers should never use <b>malloc</b> because they cannot predict when they will be called by the client. MAPI allocators support linked allocations, while OLE allocators do not. OLE supports resizing blocks, while MAPI does not. The 16-bit OLE allocator is not tolerant of a large number of allocated segments when the application itself has significant overhead.</p>
<p>
For 32-bit clients, either <b>HeapAlloc</b>, <b>VirtualAlloc</b>, or a custom memory manager should be used, depending on whether there are special performance requirements for the memory manager.</p>
<p>&nbsp;</p></body>
</HTML>
