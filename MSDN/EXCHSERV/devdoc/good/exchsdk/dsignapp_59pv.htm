<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Implementing Thread-Safe Objects</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_edk_implementing_thread_safe_objects"></a>Implementing Thread-Safe Objects</h2>
<p>
With <a href="glossary_1oof.htm#_edk_object">objects</a> that are returned from interface method calls directly, it is the <a href="glossary_1ooj.htm#_edk_service">service</a> provider’s responsibility to ensure thread-safety. With callback objects, it is the client’s responsibility. A service provider implements a thread-safe object by serializing access to shared data within the object, ensuring that one thread does not inadvertently replace the work of another thread. A service provider can implement serialized access to data in three ways:
<ul>
<li>
Provide every object with its own critical section by calling the Win32 <b>EnterCriticalSection</b> function at the beginning of every method call and the <b>LeaveCriticalSection</b> function at the end. Most samples in <a href="glossary_1ood.htm#_edk_mapi">MAPI</a> use this method. This option has two drawbacks: high overhead and the possibility of deadlock. For example, deadlock can occur if the thread-safe object calls either the MAPI support object or an object returned indirectly through one of the copy methods. </li>
<li>
Use a single critical section for all objects, calling <b>EnterCriticalSection</b> when the provider is loaded and <b>LeaveCriticalSection</b> when the provider is unloaded. This option is the simplest, but performance suffers when it is used with multithreaded clients. </li>
<li>
Create a small number of critical sections to be associated with crucial shared data structures. The data is isolated from the object, placed, for example, in memory or in a parent object. Access to the data is handled through an internal interface. This option offers the best balance between performance and simplicity. </li>
</ul>
<p>
</p>
<p>
A client can implement a thread-safe notification callback by calling the MAPI <b>HrThisThreadAdviseSink</b> utility, which transforms a non-thread-safe advise sink into a thread-safe one. (There is no such utility at this time for progress callbacks.) A client can choose to use the MAPI thread-safe progress object or create one manually.</p>
<p>
A thread-safe object may or may not be thread-aware. A thread-aware object maintains a separate context for every thread that is using it. Service providers are not required to support thread-awareness in their thread-safe objects, although supporting thread-awareness is useful in some situations. Two MAPI tables always provide their own context by definition. A single table used on more than one thread does not and should not provide a unique context.</p>
<p>
A client can choose between receiving notifications on the same thread that was used for the <b>MAPIInitialize</b> call, on the same thread that was used for the <b>Advise</b> call, or on a separate thread owned by MAPI. To ensure that notifications arrive on the same thread used to call <b>MAPIInitialize</b>, a client calls <b>MAPIInitialize</b> and passes zero in the <b>ulFlags</b> member of the <b>MAPIINIT_0</b> structure. Notifications are then delivered during the main message loop. </p>
<p>
To receive notifications on the MAPI-owned thread, a client calls <b>MAPIInitialize</b> with the <b>ulFlags</b> member of the <b>MAPIINIT_0</b> structure set to MAPI_MULTITHREAD_NOTIFY. The <b>Advise</b> call is made with the client’s advise sink object rather than a wrapped version.</p>
<p>
To ensure that notifications arrive on the same thread that was used to call <b>Advise</b>, a client calls <b>HrThisThreadAdviseSink</b> and passes the newly created wrapped advise sink to <b>Advise</b> rather than the original advise sink. <b>MAPIInitialize</b> can be called with either flag value.</p>
<p>&nbsp;</p></body>
</HTML>
