<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Notes on MAPI Properties</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_edk_notes_on_mapi_properties"></a>Notes on MAPI Properties</h3>
<p>
You can increase the efficiency of how to use MAPI properties with Microsoft Exchange Server in the following ways.</p>
<h4>Address Resolution</h4>
<p>
When you call <b>IMAPIProp::SetProps </b>or <b>IMessage::ModifyRecipients</b>, the Microsoft Exchange Server information store provider resolves addresses to either a native EX address-type entry identifier or a MAPI one-off format entry identifier. Similarly, when calling <b>ModifyRecipients</b>, a personal address book <a href="glossary_1oo4.htm#_edk_distribution_list_dl_">distribution list (DL)</a> is expanded on the client side, and each recipient in that distribution list is stored as either a native EX address-type entry identifier or a MAPI one-off address. </p>
<p>
Personal address book DLs are not expanded until the message is submitted. This means that it may not be possible to resolve a recipient entry identifier if the address-book provider is not currently available.</p>
<h4>Methods Cached at the Client  </h4>
<p>
The Microsoft Exchange Server information store provider has both a client and a server component. Each one uses its own memory space, in which it manipulates message objects. Some of the message’s properties exist on the message object on the client and some exist on the server, as shown in the illustration under <a href="compnent_11ir.htm">About Information Store Client and Server Components</a>. You can use this feature to increase the performance of your application. For more information, see <a href="perform_4g11.htm">Application Performance</a>. </p>
<p>
In addition, calls to <b>IMAPIProp::SetProps</b>, <b>IMAPIProp::DeleteProps</b>, and <b>IMessage::ModifyRecipients</b> are cached on the client until a call to <b>IMAPIProp::GetProps</b> or <b>IMAPIProp::SaveChanges</b> causes them to be executed on the server, or until a buffer that holds them is full. The rule of thumb is that the information store provider does write caching, but not read caching. This means that a call to the <b>GetProps</b> method, which gets (reads the value of) properties stored on the server computer is not cached, but rather executed immediately, thereby causing an RPC. The only method affected by the MAPI_DEFERRED_ERRORS flag is <b>IMAPIProp::SaveChanges</b>.  </p>
<p>
For more information on this and other performance-related issues, see <a href="perform_4g11.htm">Application Performance</a>. </p>
<h4>RTF Awareness</h4>
<p>
The Microsoft Exchange Server information store is RTF-aware. In other words, only the PR_COMPRESSED_RTF property is stored, which means that you never need to set the PR_BODY property. In fact, getting or setting PR_BODY can cause substandard server performance<b>. </b>When copying the message text from one message to another, it is best to call <b>IMAPIProp::GetProps</b> on PR_COMPRESSED_RTF for the first message and then call <b>IMAPIProp::SetProps</b> on PR_COMPRESSED_RTF for the second message.</p>
<p>
The PR_COMPRESSED_RTF and PR_BODY properties are stored so that setting or deleting one property also sets or deletes the other.</p>
<h4>Unicode Versions of Text Properties</h4>
<p>
The Microsoft Exchange Server information store provider supports <b>IMAPIProp::SetProps </b>and <b>IMAPIProp::GetProps</b> PT_UNICODE versions of all text properties except the PR_BODY property. It does not support setting the message text in Unicode. In general, it is recommended that you use PR_COMPRESSED_RTF instead of PR_BODY. If your application runs with Unicode as its effective codepage (the encoding of bytes into characters, do not use PT_STRING8 versions of the properties. In this case, only PT_UNICODE versions are supported.[[commented out because Milind wrote: “this can never happen in real life.” (Ok, but ask him why.)]] <b>›</b>If your application runs with a non-Unicode code page, you can use both PT_STRING8 and PT_UNICODE versions of the text properties as you like.</p>
<h4>Message Submission</h4>
<p>
Microsoft Exchange Server can grant or deny access to an application that is submitting a message. A message is accepted for submission if the SENT_REPRESENTING property is set to an addressable object in the Microsoft Exchange Server directory. Therefore, it can be set to nothing (the message is not being sent on behalf of another), or to a Microsoft Exchange Server user, a Microsoft Exchange Server distribution list, or a public folder. </p>
<h4>Folder Access Rights</h4>
<p>
The ability to call <b>IMsgStore::OpenEntry</b> to open a message depends on the effective access rights on the folder containing the message in the context of the current session. For example, this determines whether a given message can be opened read/write, read-only, or not at all. Another factor that affects access is whether the caller is the creator of the message; that is, whether the entry identifier of the user you are logged on as matches PR_CREATOR_ENTRYID). </p>
<h4>PR_MESSAGE_FLAGS </h4>
<p>
This is an unsigned long (ULONG) property. It is writeable if the message has not yet been saved. The information store provider does not set or clear the MAPI MSGFLAG_FROMME flag on this property. Also, the information store provider sets the MSGFLAG_READ flag (within PR_MESSAGE_FLAGS) on a per-user basis on messages in a public information store.</p>
<h4>Properties of Posted Messages</h4>
<p>
The following properties should be set by the calling application on a message posted to a Microsoft Exchange Server public folder. These properties appear in addition to those set automatically by the Microsoft Exchange Server information store when the message is created. For a list of those properties, see <a href="objects_3age.htm">Properties Set at Message Creation</a>. 
<ul>
<li>
PR_MESSAGE_CLASS  Set this property to IPM.Post. Setting this gives you the <b>Post</b> icon displayed by the Microsoft Exchange Client, and a read form that includes the <b>Post Reply</b> <b>in This Folder</b> toolbar button.</li>
<li>
PR_SUBJECT  Optional property, but Microsoft Exchange Server derives PR_CONVERSATION_TOPIC from PR_SUBJECT.</li>
<li>
PR_BODY  Optional property. </li>
<li>
PR_SENDER_ENTRYID  Property returned by <b>QueryIdentity</b>. </li>
<li>
PR_SENDER_NAME  Property read from the object returned by <b>QueryIdentity</b>.</li>
<li>
PR_SENT_REPRESENTING_ENTRYID  In this example, this property is set to the value of PR_SENDER_ENTRYID, but it can be set to a different property if delegate access is used. </li>
<li>
PR_SENT_REPRESENTING_NAME  In this example, this property is set to the value of PR_SENDER_NAME, but it can be set to a different property if delegate access is used. This is the string that appears in the <b>From</b> column in the right pane of the Microsoft Exchange Client.</li>
<li>
PR_DELETE_AFTER_SUBMIT  The client sets this property to 0 (FALSE) when it posts a message.</li>
<li>
PR_ORIGINATOR_DELIVERY_REPORT_REQUESTED  The client sets this property to 0 (FALSE) when it posts a message. This property is ignored by the information store on public folder postings because no delivery actually takes place. </li>
<li>
PR_READ_RECEIPT_REQUESTED  The client sets this property to 0 (FALSE) when it posts a message. This property is ignored by the information store because there is no specified recipient for a public folder posting. </li>
<li>
PR_PRIORITY  Set appropriately. PRIO_NORMAL is the default. </li>
</ul>
<p>&nbsp;</p></body>
</HTML>
