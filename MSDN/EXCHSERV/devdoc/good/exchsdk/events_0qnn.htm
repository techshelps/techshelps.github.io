<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Caching Sessions and Scripts</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_edk_caching_sessions_and_scripts"></a>Caching Sessions and Scripts</h3>
<p>
Your handler's design depends in part on the number of folders it will be used in and the workload (number, or volume, of events) it will carry within a folder. One affected design element is whether to cache a CDO session and a script. Consider the following cases:
<ul>
<li>
<b>Few folders, high volume per folder</b>  For example, an agent functioning as a distribution list could broadcast any item posted to the monitored folder to the members of the list. Caching the members of the list could help in this example since list membership is not likely to change as often as messages are being posted. </li>
<li>
<b>Many folders, low volume</b> <b>per folder</b>  Caching would be less helpful in this case. </li>
<li>
<b>Many folders, high volume</b> <b>per folder</b>  An example of this case is a script agent used in many folders on a server; This case could occur, for example, when many of a system's recipients use script agents in folders within their private mailboxes. Caching information specific to each mailbox would probably help in this case. </li>
</ul>
<p>
In general, caching is more likely to help if high volume is involved. </p>
<p>
In the case of the Microsoft Exchange Scripting Handler, if a new CDO session (which includes a logon to MAPI) had to be created every time a script fired, performance would suffer greatly. In this case, the session object (using the mailbox of the script author) is cached, which helps greatly. In other words, if a new script is run whose author also created another recently run script, that person's CDO session, having been cached, is reused. The script itself is also cached, to be used when the next event triggers it. </p>
<h4>CDO Sessions and MAPI Sessions</h4>
<p>
The session that is passed to you is a MAPI session from the service, not a CDO session. This precludes Microsoft Visual Basic handlers from using it,<b> </b>because Visual Basic can only manipulate the <b>IDispatch</b> interface, an interface that MAPI does not support.</p>
<p>
If your custom agent is written in Microsoft Visual Basic, it will need to perform its own CDO session logon.</p>
<p>&nbsp;</p></body>
</HTML>
