<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Memory Allocation for Server Applications</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_edk_memory_allocation_for_server_applications"></a>Memory Allocation for Server Applications</h2>
<p>
<a href="glossary_1ooj.htm#_edk_server_application">Server applications</a> are rated by their throughput numbers and by the number of simultaneously connected users they can support. Therefore, performance is the most important consideration. Minimizing the effects of memory allocation functions on performance requires an understanding of the unique interactions of such a system and time spent tuning the system based on these unique interactions.</p>
<p>
Important issues include the following:
<ul>
<li>
Locality of reference (how many memory pages are touched)</li>
<li>
Scalability on multiple CPUs</li>
<li>
Fragmentation</li>
<li>
Serialization</li>
<li>
Matching the memory allocation characteristics of an application to its environment</li>
<li>
Considering multiple threads and multiple processors and their effect on the performance of memory allocation functions</li>
<li>
Matching the memory allocation characteristics of an application to its purpose</li>
</ul>
<p>
</p>
<p>
For a server application, the choices include the <a href="glossary_1ood.htm#_edk_mapi">MAPI</a> allocator functions, the Win32 <b>HeapAlloc</b> or <b>GlobalAlloc</b> functions, or writing allocator functions specifically for the application.</p>
<p>
MAPI requires the use of MAPI allocators for certain allocations. When MAPI allocators are used and several very busy threads must make MAPI calls, there will be serialization and reduced performance. </p>
<p>
The MAPI allocators do not give the application control over the placement of memory blocks, which makes it impossible for the application to tune locality. The MAPI allocators always serialize through a critical section on a common heap because they can make no assumptions about how they will be called. Besides adding CPU overhead, this can dramatically impact the scalability of a multithreaded server.</p>
<p>
There has been considerable analysis of how Win32 memory allocator functions behave in the information store process. Fragmentation has not been shown to be a problem with a single heap. Win32 functions give good performance in coalescing free blocks and packing new allocations into the right place. The <a href="glossary_1oo9.htm#_edk_information_store">information store</a>, however, is heavily serialized with a single heap. Using the multiple heaps available with some other allocation strategies  virtually eliminates this contention.</p>
<p>
Because calls to the MAPI functions <b>PrepareRecips</b> and <b>ResolveNames</b> reallocate memory in ADRENTRY, it is likely that the MAPI allocators must be called if an ADRLIST is used in your application. Because of this, at some point in a multithreaded application there will be multiple threads trying to access the one Microsoft Exchange Server directory heap available to MAPI client applications. The contention for this heap will have an adverse effect of performance. To see if this is affecting your application, count the number of allocations per hour against the number of threads using MAPI allocators. A <a href="glossary_1oo7.htm#_edk_gateway">gateway</a> is an example of an application that is very likely to use <b>PrepareRecips</b> and <b>ResolveNames</b>.</p>
<p>
Server applications do not normally use the OLE <b>IMalloc</b> memory allocation function except where required by OLE interfaces. </p>
<p>
The <b>malloc</b> and <b>free</b> C runtime functions cause problems for server applications in two ways. First, unless the Visual C++ 4.0 version is used, <b>free</b> does not return memory to the operating system. Unless the application is able to call <b>_heapmin</b> periodically, its virtual memory consumption will grow without bound. The C++ <b>new </b>and <b>delete</b> operators use <b>malloc</b> by default. Overhead-conscious server applications written in C++ should always overwrite the <b>new </b>and <b>delete</b> operators. Whether to replace them with a new pair of global operators that call <b>HeapAlloc</b>, or to implement smarter class-specific operators, depends on how the application organizes its object lifetimes. The <b>malloc</b> and <b>free</b> memory allocation functions as implemented in Visual C++ 4.0 actually call <b>HeapAlloc</b> and <b>HeapFree</b> functions respectively. If that version is used, there is no problem with returning freed memory to the system. </p>
<p>
Another option to consider is a package of memory allocation functions written for your application, which can implement multiple heaps serialized outside the <b>HeapAlloc</b> and <b>HeapFree</b> functions. Such a package can eliminate almost all heap contention by tracking which heap is busy and always trying to steer allocations to non-busy heaps. This is useful for per-thread heaps. When the heap is created, the parallelism can be specified, which controls the number of heaps.</p>
<p>&nbsp;</p></body>
</HTML>
