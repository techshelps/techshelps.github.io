<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Database Routines</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>	<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>


	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<h3>Database Routines</H3><p>The TCP/IP protocol relies on the binary representations for addresses and various other identifiers. However, end users and programmers prefer to use easy-to-remember names (such as "ftp rhino.microsoft.com"). It is therefore necessary to provide a common method to resolve both services and hostnames into their respective binary equivalents. To solve this, the Windows Sockets specification offers a set of APIs known as the <I>database routines. </I></P>
<p>The database routines fall into three categories:</P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="92pt" VALIGN="TOP"><COL WIDTH="272pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>host resolution</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Learning the IP address for a host based on system, or host name</P></TD>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>protocol resolution</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Learning the protocol ID of a specific member of a protocol family (TCP, for example)</P></TD>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>service resolution</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Learning the port ID of a service based on a service name/protocol pair</P></TD>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><p>All the database routines return information in structures defined in the previous section. </P>
<p>Applications use the <I>gethostbyname()</I> and <I>gethostbyaddr() </I>functions to learn about the names and IP address(es) of a particular system, knowing only the name or the address of the system. Both calls return a pointer to a <I>hostent </I>structure as defined in the previous section. The <I>gethostbyname()</I> call simply accepts a pointer to a null-terminated string representing the name of the system to resolve. The <I>gethostbyaddr()</I> instead accepts three parameters: a pointer to the address (in network byte order), the length of the address, and the type of address.</P>
<p>Generally the hostname or IP address is offered to the application by the user to specify a remote system to connect to, and the IP address is resolved by Windows Sockets by either parsing a local<I> hosts</I> file, or querying a DNS (domain name system) server. The details of the resolution however, are specific to the implementation, abstracted from the application by these APIs.</P>
<p>The <I>getservbyname()</I> and <I>getservbyport() </I>functions return information about well-known Windows Sockets services, or applications. Each of these system calls return a pointer to a <I>servent</I> structure, as defined in the previous section. Typically an application will use these calls to determine the port ID for a well-known service (such as FTP) to create an endpoint address. </P>
<p>The following code fragment demonstrates the use of the <I>getservbyname() </I>function to fill in the <I>sockaddr_in</I> structure which will be used to connect a socket to a well-known port (the FTP protocol port over TCP):</P>
<P CLASS="spacing"><BR></P>
<pre><FONT FACE="Courier New" SIZE="3">char            buf [MAX_BUF_LEN];
struct sockaddr_in        srv_addr;
LPSERVENT            srv_info;
LPHOSTENT            host_info;
SOCKET            s;
.
.
.
/* Get FTP service port information */

srv_info=getservbyname("ftp","tcp");

if (srv_info== NULL) {
    /* Couldn't find an entry for "ftp" over "tcp" */

    sprintf(buf,"Windows Sockets error %d: Couldn't resolve FTP service port.",
         WSAGetLastError());
    MessageBox (hWnd,buf,"Windows Sockets Error",MB_OK);
    shutdown_app();
}

/* Set up socket */

srv_addr.sin_family = AF_INET;
srv_addr.sin_addr.s_addr = INADDR_ANY;
srv_addr.sin_port=srv_info-&gt;s_port;</font></pre>
<p>The example uses <I>getservbyname()</I> to resolve the port number of the FTP service over TCP. The port ID is used to construct the <I>sockaddr_in</I> structure (endpoint address) for future use by the application. As we mentioned before, the address family for TCP/IP is always assigned as AF_INET. We use the <I>INADDR_ANY </I>macro to specify any local IP interface to accept incoming connections (more on this later).</P>
<p>To round out the database routines, <I>getprotobyname() </I>and <I>getprotobynumber() </I>fill in a <I>protoent</I> structure, sometimes used by applications to create a socket over a particular protocol (e.g., UDP or TCP). More often, however, an application will use the SOCK_DGRAM and SOCK_STREAM macros to create either datagram or stream sockets.</P></BODY></HTML>
