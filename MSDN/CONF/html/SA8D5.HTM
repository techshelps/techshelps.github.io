<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Disk Striping</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>	<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>


	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<h3>Disk Striping</H3><p>Disk Striping with parity is based on concepts put forth in RAID 5. Here a number of different partitions on different disks are combined to make one large logical drive. The partitions are used and arranged to ensure multiple single points of failure in the array. Disk striping with parity is only supported in Microsoft Windows&nbsp;NT Server. There must be at least three disks and no more than 32 disks in a striped set. A partition of approximately the same size must be selected from each disk. The disks may be on the same or on different controllers. Small computer system interface (SCSI) disks are best, because advanced recovery features, such as bad block remapping, can be used during the recovery process. Data is written in stripes across all partitions in the set. In addition to the data, a parity stripe is interleaved with the data stripes. The parity stripe is simply a byte parity of the data stripes at a given stripe level or row. Assume you have five disks in the striped set. At level 0, you have stripe block 0 on disk 0, 1 on 1, 2 on 2, and 3 on 3 and the parity (exclusive OR) of the stripe blocks on disk 4. The size of the stripes (striping factor) is currently 64K. The size of the parity stripe is the size of the data stripes. On the next row, the parity stripe is on disk 0. Data is on the rest of the disks. Because the parity stripes are not all on the same disk (as in RAID 4) there is no single point of failure for the set.</P>
<p>When using any of the fault-tolerant disk schemes, Microsoft Windows&nbsp;NT uses a device driver called FTDISK.SYS to receive commands and respond appropriately, based on the type of fault tolerance that is being used. Thus, when the file system generates a request to read a given section of a file, the normal disk system receives the request from the file system and passes it to the FTDISK.SYS driver. This driver then determines the stripe the data is in. From this and the information on the number of disks in the set the disk and location on the disk is located. The data is read into memory. Striping can actually increase read performance because each disk in the set can have an outstanding read at the same time.</P>
<p>Writing to a parity-striped set is a little more difficult. First, the original data from the stripe that is to be written must be read along with the parity information for that stripe level. The differences to the parity information are calculated and added to the parity stripe. Finally, both the parity and the new information are written to disks. The reads and the writes can be issued concurrently since they must be on different disks by design.</P>
<p>There are two general cases of fault tolerance with parity striping. A data stripe is no longer readable. Even though the data stripe is no longer readable, the system may still function. When the bad data stripe is to be read, all of the remaining good data stripes are read along with the parity stripe. Each data stripe is subtracted (XORed) from the parity stripe, and the order isn't important. The result is the missing data stripe! Writing is a little more complicated but works very much the same way. All the data stripes are read and backed out of the parity stripe, leaving the missing data stripe. The modifications to the parity stripe can now be calculated and made. Because the system knows the data stripe is bad, it is not written&mdash;only the parity stripe.</P>
<p>The other general case is the loss of a parity stripe. During data reads, this does not present a problem. The parity stripe is not used during normal reads. Writes become much less complicated as well. Because there is no way to maintain the parity stripe, the writes behave as a data stripe without parity. The parity stripe can be recalculated during regeneration.</P></BODY></HTML>
