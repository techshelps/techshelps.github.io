<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The TransmitFile() API</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>	<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>


	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<h3>The TransmitFile() API</H3><p>Windows&nbsp;NT 3.51 adds a new Windows Sockets API called <B>TransmitFile().</B> This API is designed to allow applications and services to send file data very quickly over the network. It works by taking handles to a connected socket and to an open file. Then, in kernel mode, it reads data directly from the system cache and passes it off to the transport protocol. This avoids all the buffer copies, context switches, and kernel transitions associated with the typical methods of sending file data.</P>
<p>Another advantage of <B>TransmitFile() </B>is that it allows "head" and "tail" buffers to be specified along with the file handle. These buffers are sent before and after the file data, respectively. This is very efficient because it allows the transport protocol to combine the head buffer with the first chunk of file data and the tail buffer with the last chunk of file data.</P>
<p>The performance effect of <B>TransmitFile()</B> is significant, as shown in the following chart:</P>
<P><img src="40738.gif"></P>
<p>This chart compares three common mechanisms for sending file data: with the <B>ReadFile()</B> and <B>send()</B> APIs, by memory-mapping the file, setting SO_SNDBUF to 0 and using overlapped <B>WriteFile()</B> calls (thereby avoiding the buffer copies), and by using <B>TransmitFile()</B>. These tests were run with a 486/33 on two Ethernets with Compaq Netflex cards.</P>
<p>The chart shows that the cost of buffer copies, kernel transitions, and context switches make <B>ReadFile()</B> and <B>send()</B> the least fast way to send file data. This is because there are two buffer copies for every I/O (into the user buffer for <B>ReadFile()</B> and from the user buffer for <B>send()</B>) as well as kernel transitions and context switches.</P>
<p>Using a memory-mapped file avoids a buffer copy into the user buffer when retrieving data, and using <B>WriteFile()</B> with SO_SNDBUF set to 0 avoids the buffer copy when sending the data. Therefore, this mechanism achieves much better performance, especially for larger files. However, it must still incur the costs of the kernel transitions and context switches.</P>
<p>The fastest method is the <B>TransmitFile()</B> which simply sits in kernel mode, using highly optimized cache manager functions to retrieve the data and tight code paths to give this data to the transport protocol. Using <B>TransmitFile()</B>, the 486/33 is nearly able to saturate the full bandwidth of two Ethernets with file data.</P>
<p>Another note on <B>TrasnmitFile()</B> for high-performance file transfer is that it is relatively simple to use. The mapped file mechanism used above took 213 lines of source code, while <B>TransmitFile()</B> used only 41.</P></BODY></HTML>
