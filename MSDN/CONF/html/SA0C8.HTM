<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Unsupported Objects and Methods</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>	<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>


	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<h3>Unsupported Objects and Methods</H3><p>You may need to change code that uses objects and methods that are not supported in remote tables. In many cases, such as the CompactDatabase method or the Container object, there is simply no equivalent on a SQL Server.</P>
<p>The following data access objects are not supported:</P>
<P><ul><li>    Container</P>
<P><li>    Document</P>
<P><li>    Index</P>
<P><li>    QueryDef</P>
<P><li>    Relation</P></ul>
<p>The following methods are not supported:</P>
<P><ul><li>    CompactDatabase</P>
<P><li>    CreateDatabase</P>
<P><li>    CreateField</P>
<P><li>    CreateQueryDef</P>
<P><li>    DeleteQueryDef</P>
<P><li>    ListParameters</P>
<P><li>    ListTables</P>
<P><li>    OpenQueryDef</P>
<P><li>    RepairDatabase</P>
<P><li>    Seek</P>
<P><li>    SetDefaultWorkspace</P></ul>
<H4> </A>Nested Transactions</H4><p>Microsoft&nbsp;Access supports transactions nested up to five levels. SQL Server supports only one transaction at a time. If your Microsoft&nbsp;Access code includes nested transactions, only the outermost transaction is sent to the server; the other transactions are ignored, and no error is produced.</P>
<H5 CLASS="h4"> </A>Example</H5><P CLASS="spacing"><BR></P>
<pre><FONT FACE="Courier New" SIZE="3">BeginTrans            'Outermost transaction sent to the server
'edits, updates

    BeginTrans        'Nested transaction is not sent to the server
    'edits, updates    
    CommittTrans        

CommittTrans</font></pre>
<p>You may need to modify your code in light of this difference. If your nested transactions are rolled back when any of them fail, the single-transaction limitation won't pose major difficulties. If some nested transactions are committed even if others fail, duplicating this functionality with one transaction may prove to be difficult.</P>
<H4> </A>Default and Counter Values</H4><p>Microsoft&nbsp;Access default and counter field values appear when you begin editing a new record. Default values generated by SQL Server defaults and counter values generated by table triggers appear only after a record has been inserted. You will need to change any code, such as code for lookups, that depends on having the values before the record is committed.</P>
<H4> </A>Validation Rules</H4><p>In Microsoft&nbsp;Access, field validation occurs when the user tabs out of a field. When you edit SQL Server data in attached tables, triggers and rules are not fired until you leave the record. Record validation rules that rely on field validation occurring when a field is exited may need to be modified.</P>
<H4>Unconverted Expressions</H4><p>The upsizing report shows whether each Microsoft&nbsp;Access table validation rule, field validation rule, and default was successfully converted. If the Upsizing Wizard was not successful in translating an Microsoft&nbsp;Access Basic expression, you will need to rewrite it using Transact-SQL.</P>
<p>For example, if a field validation rule could not be converted, you should rewrite the validation rule in Transact-SQL and then add it to the update and insert trigger for the table. You could also create a rule.</P>
<p>Another option is to perform validation at the form level in Microsoft&nbsp;Access. However, if server data is then modified without using a particular form, the validation will not be applied and invalid data may be entered.</P>
<H4> </A>Record Locking</H4><p>You cannot open a Dynaset object against an attached server table in exclusive mode. Consequently, the value of the Record Locks property of all forms must be set to No Locks or Edited Record. (Edited Record is treated the same as No Locks.) The value All Records is illegal and generates an error. </P>
<p>With server tables, Microsoft&nbsp;Access uses optimistic locking internally. The row is locked only while the update process occurs, when the edited value is committed, which is usually a very brief interval.</P>
<H4> </A>Back-End Databases</H4><p>Many developers take a "back-end, front-end" approach to developing Microsoft&nbsp;Access applications. They keep tables in one database (the back end) and all other objects such as forms and reports in another database (the front end).</P>
<P>To upsize a back-end, front-end application</P>
<P>1.    Upsize the back-end database using the Upsizing Wizard.</P>
<P>2.    After upsizing, open the front-end database in Microsoft&nbsp;Access.</P>
<P>3.    From the File menu, choose Add-ins, and then choose Import Database.</P>
<P>A File Open dialog box is displayed.</P>
<P>4.    Choose the back-end database, then click OK.</P>
<P>This will import all tables and queries from the back-end database, including the attached tables and aliasing queries that the Upsizing Wizard created.</P>
<P>You may delete local tables and queries that you don't need.</P>
<H4> </A>Handling Errors from the Server</H4><p>Whenever your application causes an error to occur on the server, Microsoft&nbsp;Access displays two messages: first the Microsoft&nbsp;Access error message and then the message from the server. If you trap an ODBC error (numbered 3146 through 3299) in a Microsoft&nbsp;Access Basic procedure, the <B>Error$</B> function returns both the Microsoft&nbsp;Access message and all server error messages concatenated together. By parsing the value returned by <B>Error$</B>, you can find out which server error occurred and what the text of the server error message is.</P>
<p>The following error-handling code demonstrates how you can obtain the server error number and message when an ODBC error occurs:</P>
<P CLASS="spacing"><BR></P>
<pre><FONT FACE="Courier New" SIZE="3">Dim RemoteError As Integer, ErrorText As String
Dim NumStart As Integer, TextStart As Integer

Select Case Err
Case 3146 To 3299            ' It's an ODBC error, so parse it.
    ' Find error number.
    NumStart = InStr(Error$, "(#") + 2
    ErrorNum = Val(Mid$(Error$, NumStart))    
    ' Find error message.
    TextStart = InStr(Error$, "] ") + 2
    ErrorText = Mid$(Error$, TextStart, NumStart - TextStart - 3)
        ...                    ' Handle remote error.</font></pre></BODY></HTML>
