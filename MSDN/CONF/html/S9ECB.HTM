<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using Secure RPC</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>	<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>


	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<H2>Using Secure RPC</H2><p>Any RPC application can turn security on by using simple security enabling RPC APIs. In this section we present the APIs, various associated parameters, and then discuss where to use each API to get security services.</P>
<H3> </A>RPC Security Interfaces</H3><p>The security related RPC interfaces are:</P>
<P CLASS="spacing"><BR></P>
<pre><FONT FACE="Courier New" SIZE="3">RPC_STATUS RPC_ENTRY
<B>RpcBindingInqAuthInfoW</B> (
 IN RPC_BINDING_HANDLE Binding,
 OUT RPC_CHAR PAPI * PAPI * ServerPrincName, OPTIONAL
 OUT unsigned long PAPI * AuthnLevel, OPTIONAL
 OUT unsigned long PAPI * AuthnSvc, OPTIONAL
 OUT RPC_AUTH_IDENTITY_HANDLE PAPI * AuthIdentity, OPTIONAL
 OUT unsigned long PAPI * AuthzSvc OPTIONAL
 )
RPC_STATUS RPC_ENTRY
<B>RpcBindingInqAuthInfoExW</B> (
 IN RPC_BINDING_HANDLE Binding,
 OUT RPC_CHAR PAPI * PAPI * ServerPrincName, OPTIONAL
 OUT unsigned long PAPI * AuthnLevel, OPTIONAL
 OUT unsigned long PAPI * AuthnSvc, OPTIONAL
 OUT RPC_AUTH_IDENTITY_HANDLE PAPI * AuthIdentity, OPTIONAL
 OUT unsigned long PAPI * AuthzSvc, OPTIONAL
 IN unsigned long RpcSecurityQosVersion,
 OUT RPC_SECURITY_QOS * SecurityQos
 )</font></pre>
<p>RpcBindingInqAuthInfo is a client-side API that can be used to inquire aboutthe authentication information set on the supplied binding handle. Ex-counterpart provides additional information on the security quality of service setting on the binding handle.</P>
<P CLASS="spacing"><BR></P>
<pre><FONT FACE="Courier New" SIZE="3">RPC_STATUS RPC_ENTRY
<B>RpcBindingSetAuthInfoW</B> (
 IN RPC_BINDING_HANDLE Binding,
 IN RPC_CHAR PAPI * ServerPrincName,
 IN unsigned long AuthnLevel,
 IN unsigned long AuthnSvc,
 IN RPC_AUTH_IDENTITY_HANDLE AuthIdentity, OPTIONAL
 IN unsigned long AuthzSvc
 )
RPC_STATUS RPC_ENTRY
<B>RpcBindingSetAuthInfoExW</B> (
 IN RPC_BINDING_HANDLE Binding,
 IN RPC_CHAR PAPI * ServerPrincName,
 IN unsigned long AuthnLevel,
 IN unsigned long AuthnSvc,
 IN RPC_AUTH_IDENTITY_HANDLE AuthIdentity, OPTIONAL
 IN unsigned long AuthzSvc,
 IN RPC_SECURITY_QOS *SecurityQOS
 )</font></pre>
<p>RpcBindingSetAuthInfo is a client-side API that can be used by to set authentication information on the supplied binding handle. This involves setting up authentication level, authentication service, and so forth. Ex-counterpart provides additional capability to set security quality of service information on the binding handle. The mapping of various RPC security constants is described in subsections later.</P>
<P CLASS="spacing"><BR></P>
<pre><FONT FACE="Courier New" SIZE="3">RPC_STATUS RPC_ENTRY
<B>RpcMgmtInqDefaultProtectLevel</B>(
 IN unsigned long AuthnSvc,
 OUT unsigned long PAPI *AuthnLevel
 )</font></pre>
<p>RpcMgmtInqDefaultProtectLevel returns the mapping for RPC_C_AUTHN_LEVEL_DEFAULT for the supplied authentication service.</P>
<P CLASS="spacing"><BR></P>
<pre><FONT FACE="Courier New" SIZE="3">RPC_STATUS RPC_ENTRY
<B>RpcServerRegisterAuthInfoW</B> (
 IN RPC_CHAR PAPI * ServerPrincName,
 IN unsigned long AuthnSvc,
 IN RPC_AUTH_KEY_RETRIEVAL_FN GetKeyFn, OPTIONAL
 IN void PAPI * Arg OPTIONAL
 )</font></pre>
<p>RpcServerRegisterAuthInfo is the server side API to turn on security for the various server interfaces that are registered. It sets up the server, principal name, authentication service to use, any key retrieval function (default is supplied by authentication service) in the RPC_SERVER object. The authentication service to use is specified by a constant. The mapping of these constants to packages is discussed in a subsection later.</P>
<P CLASS="spacing"><BR></P>
<pre><FONT FACE="Courier New" SIZE="3">RPC_STATUS RPC_ENTRY
<B>RpcBindingInqAuthClientW</B> (
 IN RPC_BINDING_HANDLE ClientBinding, OPTIONAL
 OUT RPC_AUTHZ_HANDLE PAPI * Privs,
 OUT RPC_CHAR PAPI * PAPI * ServerPrincName, OPTIONAL
 OUT unsigned long PAPI * AuthnLevel, OPTIONAL
 OUT unsigned long PAPI * AuthnSvc, OPTIONAL
 OUT unsigned long PAPI * AuthzSvc OPTIONAL
 )</font></pre>
<p>The server-side application can use RpcBindingInqAuthClient to obtain authorization information about the client making the authenticated RPC.</P>
<P CLASS="spacing"><BR></P>
<pre><FONT FACE="Courier New" SIZE="3">RPC_STATUS RPC_ENTRY
<B>RpcImpersonateClient</B> (
 IN RPC_BINDING_HANDLE ClientBinding OPTIONAL
 )
RPC_STATUS RPC_ENTRY
<B>RpcRevertToSelfEx</B> (
 IN RPC_BINDING_HANDLE ClientBinding OPTIONAL
 )
RPC_STATUS RPC_ENTRY
<B>RpcRevertToSelf</B> (
 )</font></pre>
<p>RpcImpersonateClient is used by the server thread to impersonate the client whose request it is servicing. The impersonation level is set according to the one specified by the client when making the connection.</P>
<p>RevertToSelf is used to return the default security context.</P>
<P CLASS="spacing"><BR></P>
<pre><FONT FACE="Courier New" SIZE="3">RPC_STATUS RPC_ENTRY
<B>RpcMgmtInqServerPrincNameW</B> (
 IN RPC_BINDING_HANDLE Binding,
 IN unsigned long AuthnSvc,
 OUT RPC_CHAR __RPC_FAR * __RPC_FAR * ServerPrincName
 )
RPC_STATUS RPC_ENTRY
<B>RpcServerInqDefaultPrincNameW</B> (
 IN unsigned long AuthnSvc,
 OUT RPC_CHAR __RPC_FAR * __RPC_FAR * PrincName
 )</font></pre>
<p>RpcMgmtInqServerPrincName is used by the server application to inquire aboutthe server's principal name corresponding to the supplied binding handle and the authentication service.</P>
<p>RpcServerInqDefaultPrincName returns the default principal name for the server for the supplied authentication service.</P>
<H3> </A>RPC Authentication Service Constants</H3><p>Authentication service is provided by security support packages. RPC defines six authentication service identifiers. Security support packages are loaded in the system as part of the security provider DLL. Each provider DLL can support one or more security packages. RPC loads the  provider DLLs and then calls EnumerateSecurityPackages() in the DLL to get the security packages in the DLL. Each security package information contains "wRPCID" which has to be one of the six RPC identifiers. This information is used to select the security package which corresponds to the authentication service requested by the application during the security initialization calls.</P>
<P></P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="171pt" VALIGN="TOP"><COL WIDTH="265pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>RPC Authentication Service</B></P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>Security Support Package</B></P></TD>

</TR><TR><TD VALIGN="TOP">
<FONT FACE="Verdana, Arial" SIZE=2><P>
RPC_C_AUTHN_NONE </P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>no authentication package to use, ie No security.</P></TD>

</TR><TR><TD VALIGN="TOP">
<FONT FACE="Verdana, Arial" SIZE=2><P>
RPC_C_AUTHN_DCE_PRIVATE</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>not currently supported</P></TD>

</TR><TR><TD VALIGN="TOP">
<FONT FACE="Verdana, Arial" SIZE=2><P>
RPC_C_AUTHN_DCE_PUBLIC</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>not currently supported</P></TD>

</TR><TR><TD VALIGN="TOP">
<FONT FACE="Verdana, Arial" SIZE=2><P>
RPC_C_AUTHN_DEC_PUBLIC</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>not currently supported</P></TD>

</TR><TR><TD VALIGN="TOP">
<FONT FACE="Verdana, Arial" SIZE=2><P>
RPC_C_AUTHN_WINNT</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>NTLM SSP in security.dll (NT4.0)</P></TD>

</TR><TR><TD VALIGN="TOP">
<FONT FACE="Verdana, Arial" SIZE=2><P>
RPC_C_AUTHN_DEFAULT</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>NTLM SSP in security.dll (NT4.0)</P></TD>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><P><B>Table 1: RPC Authentication Service Identifiers.</B></P>
<H3>RPC Authentication Level Constants</H3><p>RPC provides security by "levels." The authentication levels are:</P>
<UL><LI>Default ( RPC_C_AUTHN_LEVEL_DEFAULT) == Per Connection <BR>Authentication</LI><LI>No Authentication (RPC_C_AUTHN_LEVEL_NONE)</LI><LI>Per Connection Authentication (RPC_C_AUTHN_LEVEL_CONNECT)</LI><LI>Per Call Authentication (RPC_C_AUTHN_LEVEL_CALL)</LI><LI>Per Packet Authentication (RPC_C_AUTHN_LEVEL_PKT)</LI><LI>Per Packet Authentication with Packet Integrity (RPC_C_AUTHN_LEVEL_PKT_INTEGRITY)</LI><LI>Per Packet Authentication with Packet Integrity and <BR>Privacy (RPC_C_AUTHN_LEVEL_PKT_PRIVACY). </LI></UL><p>Whether a particular authentication level is available is decided by the security package being used. If a security package does not support the requested level it may upgrade it to the next highest level it supports (if available) or return an error during server initialization.</P>
<P><B></B></P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="189pt" VALIGN="TOP"><COL WIDTH="252pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">
<FONT FACE="Verdana, Arial" SIZE=2><P>
<B>RPC Authentication Level</B></P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>SSP Service Level</P></TD>

</TR><TR><TD VALIGN="TOP">
<FONT FACE="Verdana, Arial" SIZE=2><P>
RPC_C_AUTHN_LEVEL_CONNECT</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>ISC_REQ_USE_DCE_STYLE | ISC_REQ_DELEGATE | ISC_REQ_MUTUAL_AUTH</P></TD>

</TR><TR><TD VALIGN="TOP">
<FONT FACE="Verdana, Arial" SIZE=2><P>
RPC_C_AUTHN_LEVEL_CALL</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>bumped to RPC_C_AUTHN_LEVEL_PKT</P></TD>

</TR><TR><TD VALIGN="TOP">
<FONT FACE="Verdana, Arial" SIZE=2><P>
RPC_C_AUTHN_LEVEL_PKT</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>ISC_REQ_USE_DCE_STYLE | ISC_REQ_DELEGATE | ISC_REQ_MUTUAL_AUTH | ISC_REQ_REPLAY_DETECT</P></TD>

</TR><TR><TD VALIGN="TOP">
<FONT FACE="Verdana, Arial" SIZE=2><P>
RPC_C_AUTHN_LEVEL_PKT_ INTEGRITY</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>ISC_REQ_USE_DCE_STYLE | ISC_REQ_DELEGATE | ISC_REQ_MUTUAL_AUTH | ISC_REQ_REPLAY_DETECT | ISC_REQ_SEQUENCE_DETECT</P></TD>

</TR><TR><TD VALIGN="TOP">
<FONT FACE="Verdana, Arial" SIZE=2><P>
RPC_C_AUTHN_LEVEL_PKT_ PRIVACY</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>ISC_REQ_USE_DCE_STYLE | ISC_REQ_DELEGATE | ISC_REQ_MUTUAL_AUTH | ISC_REQ_REPLAY_DETECT |ISC_REQ_SEQUENCE_DETECT| ISC_REQ_CONFIDENTIALITY</P></TD>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><P><B>Table 2: RPC Authentication Levels and SSP Services.</B></P>
<p>The mapping of RPC authentication levels to SSPI's capabilities is constant. It does not change with the change of authentication package. It is up to the authentication package to ignore or return an error on some of these depending on the capabilities it supports.</P>
<H3> </A>RPC Impersonation Levels</H3><p>RPC is designed to provide all the impersonation levels defined by a native Windows&nbsp;NT-based system:</P>
<UL><LI>Anonymous (RPC_C_IMP_LEVEL_ANONYMOUS)</LI><LI>Identify (RPC_C_IMP_LEVEL_IDENTIFY)</LI><LI>Impersonate (RPC_C_IMP_LEVEL_IMPERSONATE)</LI><LI>Delegate (RPC_C_IMP_LEVEL_DELEGATE)</LI></UL><p>The delegation impersonation level is not supported by Windows&nbsp;NT natively but the security package may have the ability to provide it. In fact, in the current implementation, RPC always requests delegation level security context from the security package for nonauthenticated transports. It maps the requested level to the native level for authenticated transports (Namedpipes and LPC). Impersonation levels are also associated with context tracking modes. If the tracking is static, the security context is created only once and is never revised during the entire communication, even if the client side changes it. In the case of dynamic tracking, the context is revised whenever the LogonId in the client's token is changed.</P>
<p>NTLM security package, the default security package in Windows&nbsp;NT 4.0, does not currently support delegation and ignores the RPC's request.</P>
<H4 CLASS="h4"> </A>RPC Authentication Identity</H4><p>During client initialization, client process can supply a client identity handle in the RpcBindingSetAuthInfo call. This authentication identity handle points to a structure which contains the username, domainname, and plaintext password of the user. This information is not required, and if not present, the process's default identity is picked from the attached token by the security package.</P>
<p>RPC stores this information with the binding and passes it on to the security support package when acquiring security credentials.</P>
<H4 CLASS="h4"> </A>RPC Authorization Service Constants</H4><p>RPC currently defines three authorization service constants:</P>
<UL><LI>RPC_C_AUTHZ_NONE</LI><LI>RPC_C_AUTHZ_NAME</LI><LI>RPC_C_AUTHZ_DCE</LI></UL><p>RPC currently does not use this information. It corresponds to authorization service setting by the security package. The default security package in Windows&nbsp;NT 4.0 (NTLM security package) sets this to 0.</P>
<H3> </A>RPC Client and Server Security Initialization</H3><p>The RPC server initializes security by calling RpcServerRegisterAuthInfo<B> </B>as follows:</P>
<P CLASS="spacing"><BR></P>
<pre><FONT FACE="Courier New" SIZE="3">//
// Request Security…
//
Status = RpcServerRegisterAuthInfo(
    NULL,
    RPC_C_AUTHN_WINNT,
    NULL,
    NULL
    );
//
// where:
//    Arg1 = ServerPrincipalName (ignored by NTLM SSP).
//    Arg2 = The SSP to use based on RPC settings =&gt; default NTLM SSP
//    Arg3/Arg4 = GetKey function and its argument, not used.
// 

if(Status)
{
    // Oops.. we have a problem…
}

//
//    Standard RPC calls to register the interface, set up the endpoint, etc.
//    and then go into Listen…
//
</font></pre>
<p>The RPC client initializes security by calling<B> </B>RpcBindingSetAuthInfo(Ex)<B> </B>as follows:</P>
<P CLASS="spacing"><BR></P>
<pre><FONT FACE="Courier New" SIZE="3">//
//    Do the binding etc.
//

// 
// Request Security…
//
Status = RpcBindingSetAuthInfoEx(
    RpcInterfaceHandle,
    NULL,
    AuthnLevel,
    RPC_C_AUTHN_WINNT,
    NULL,
    AuthzSvc,
          SecurityQos
    );
//
// where:
//    Arg1 = Binding Handle just established.
//    Arg2 = ServerPrincipalName (NULL as it is ignored by NTLM SSP).
//    Arg3 = Authentication Leve (see above for valid values).
//    Arg4 = Auth service which be default selects NTLM SSP for NT.
//    Arg5 = Authentication Identity which can be SEC_WINNT_AUTH_IDENTITY structure
//        specifying Username, DomainName and password. NULL means use default.
//    Arg6 = Autorization Service (see above for valid values).
//    Arg7 = Impersonation Level, see above for valid values.
//
</font></pre>
<H3> </A>RPC Invocations and Executions.</H3><p>Once the client and server sides have initialized security, the client can go ahead and start making remote procedure calls without worrying about security. Underlying RPC run time encapsulates all of the SSPI interactions to establish the authenticated connection and secure message exchange.</P>
<p>On the server side, when a procedure is invoked for execution, it can use RpcImpersonateClient() API to impersonate the client before servicing the request, if so required. It can then revert to original security context using RpcRevertToSelf().</P></BODY></HTML>
