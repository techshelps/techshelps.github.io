<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Sending and Receiving Data (stream sockets)</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>	<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>


	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<h3>Sending and Receiving Data (stream sockets)</H3><p>Once an application successfully establishes a socket connection, it is ready to start transferring data over the connection. With stream (TCP) sockets, data transfer is said to be "reliable," meaning that the application may assume that the underlying transport will ensure that the data gets to the remote host without duplication or corruption. When a connection is established on a stream socket, a the TCP transport creates a "virtual circuit" between the two machines. This circuit remains open until both applications decide that they are done sending data on the circuit (typically a "graceful" close), or until a network error occurs which causes the circuit to be terminated abnormally. </P>
<p>An application sends data using the <I>send() </I>API. This API takes a socket descriptor, a pointer to a buffer to send, the length of the buffer, and an integer which specifies flags which can modify the behavior of <I>send().</I> To receive data, an application uses the <I>recv()</I> API, which takes a pointer to a buffer to fill with data, the length of the specified buffer, and a flags integer. <I>recv() </I>returns the number of bytes actually received, and <I>send()</I> returns the number of bytes actually sent. Note that applications should always check the return codes of <I>send()</I>and <I>recv()</I> for the number of bytes actually transferred, since it may be different from the number requested. Because of the stream-oriented nature of TCP sockets, there isn't necessarily a one-to-one correspondence between <I>send() </I>and <I>recv() </I>calls. For example, a client application may perform ten calls to <I>send()</I>, each for 100 bytes. The system may combine or "coalesce" these sends into a single network packet, so that if the server application did a <I>recv()</I> with a buffer of 1000 bytes, it would get all the data at once. </P>
<p>Therefore, an application must not make any assumptions about how data will arrive. A server which expects to receive 1000 bytes should call <I>recv()</I>in a loop until it has received all of the data:</P>
<P CLASS="spacing"><BR></P>
<pre><FONT FACE="Courier New" SIZE="3">SOCKET         s;
int         bytes_received;
char         buffer[1000];
char         *buffer_ptr;
int         buffer_length;

.
.
buffer_ptr = buffer;
buffer_length = sizeof(buffer);

/* Receive all outstanding data on socket s */

do {
    bytes_received = recv(s, buffer_ptr, buffer_length, 0);
    if (bytes_received == SOCKET_ERROR) {
        sprintf(buf,"Windows Sockets error %d: Error while receiving data.",
             WSAGetLastError());
        MessageBox (hWnd,buf,"Windows Sockets Error",MB_OK);    
        shutdown_app();
    }
    buffer_ptr += bytes_received;
    buffer_length -= bytes_received;
} while (buffer_length &gt; 0);</font></pre>
<p>Likewise, an application which wants to send 1000 bytes should <I>send() </I>in a loop until all of the data has been sent:</P>
<P CLASS="spacing"><BR></P>
<pre><FONT FACE="Courier New" SIZE="3">SOCKET         s;
int         bytes_sent;
char         buffer[1000];
char         *buffer_ptr;
int         buffer_length;

buffer_ptr = buffer;
buffer_length = sizeof(buffer);

/* Enter send loop until all data in buffer is sent */

do {
    bytes_sent = send(s, buffer_ptr, buffer_length, 0);
    if (bytes_sent == SOCKET_ERROR) {
        sprintf(buf,"Windows Sockets error %d: Error while sending data.",
             WSAGetLastError());
        MessageBox (hWnd,buf,"Windows Sockets Error",MB_OK);    
        shutdown_app();
    }
    buffer_ptr += bytes_sent;
    buffer_length -= bytes_sent;
} while (buffer_length &gt; 0);</font></pre></BODY></HTML>
