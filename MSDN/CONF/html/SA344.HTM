<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Standards</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>	<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>


	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<h3>Standards</H3><p>Standards are absolutely essential for the success of large, multi-developer projects. We will review three distinct areas in which we have defined standards for our developers to adhere to: naming, programming and GUI design. Again, the effort involved here isn't so much <I>difficult</I>, but it does require some up-front investment (mainly of time) to put it into place. Once you have a well-defined set of standards in place, you will realize benefits in the following areas:</P>
<UL><LI><B>Development time.</B> The key is to drive down the time spent on essentially trivial matters: you don't want expensive resources like Visual Basic programmers endlessly debating naming or coding conventions with each other, or arguing over whether command buttons should have ellipses or have proper-case text. Naming, programming and GUI design standards should ultimately be so internalized by your development team that they become a base language everybody can take for granted.</LI><LI><B>Maintenance time. </B>Consistently named and formatted code is much easier to maintain than ad-hoc code. The classic example is returning to an application for changes or maintenance six months after it's been written: if you have the same conventions now as you did then, this just might be possible &mdash; if not, forget it!</LI><LI><B>Customer acceptance.</B> A consistent GUI design that basically adheres to Windows standards will present a more professional appearance and ease users' learning and ultimately acceptance of an application. Similarly, published naming and programming standards will increase the comfort level of IS personnel &mdash; an important issue if you are an independent developer working on custom corporate applications.</LI></UL><p>In this section we'll present a guide to defining your own standards in these important areas. As elsewhere in the presentation, our focus will be on how these standards are adapted to the Visual Basic world. We don't have time to present a complete standards document, but we'll try to present enough concrete examples to get you started.</P>
<H4> </A>Naming</H4><p>In Appendix A we include a summary of a naming approach that has worked well for us. For now, we'll provide some general guidelines and then review some of the areas you will want to define a set of naming standards to cover.</P>
<H5 CLASS="h4"> </A>General Guidelines</H5><p>In general, our naming conventions obey the <I>de facto</I> standard construct:</P>
<p>&lt;prefix&gt;&lt;Mnemonic&gt;</P>
<p>The &lt;prefix&gt; portion identifies the technical nature of the thing being named: what type of control it is, what data type a variable is, the scope of a variable, the type of object a variable points to, and so on. The &lt;Mnemonic&gt; portion identifies the business role the thing plays, or the function it performs.</P>
<p>You should have well-defined naming conventions for at least the following areas:</P>
<UL><LI><B>Controls</B>. Both standard and extended (third-party) controls should be covered.</LI><LI><B>Variables</B>. Some of the issues you should address include:

<UL><LI>     Scope, persistence, how arguments are passed to procedures</LI><LI>     Data type</LI><LI>     Object variables: distinguish between types of object variables and different object models (e.g. Jet, Microsoft Excel VBA)</LI></UL></LI><LI><B>Procedures</B>. Address issues such as:

<UL><LI>     Scope (global vs. form-level)</LI><LI>     Function vs. Sub procedure</LI></UL></LI></UL><H4> </A>GUI Design</H4><p>Having standards in place for graphical user interface (GUI) design should be as non-controversial as for naming or programming. With the newness of the Windows operating system environment and the recent "down-sizing of America," this does seem to be an area that lags behind the more "technical" areas in terms of standards implementation. Custom corporate applications have a particular set of interface issues that developer workgroups should define standards for; many of these issues are not discussed in the standard references (for example, <I>The Windows Interface: An Application Design Guide</I>, Microsoft&nbsp;Press&reg;, 1992 is essentially written as a guide for commercial application developers). We don't have time in this presentation to provide a complete guide to GUI design; rather, we'll present an overview of the areas you should have standards in place for, and give what we feel are some of the "greatest hits" of required GUI design standards.</P>
<H5 CLASS="h4"> </A>General Issues</H5><UL><LI>    Proper keyboard support
<P CLASS="lp1">For any application requiring appreciable head-down data entry, this is probably a good rule to have in place. All menu commands need to be keyboard accessible (with either mnemonic keys or keyboard shortcuts), and all major system commands should be available from a menu. Remember, it's not the Windows interface that's keyboard-unfriendly, it's the GUI designer of a particular application.</P></LI><LI>    Textual feedback to the user
<P CLASS="lp1">Text messages, especially in informational and warning dialogs, need to be properly and consistently conveyed. Here are some worthwhile rules of thumb you should consider incorporating into your standards:</P>


<UL><LI>     Avoid technical jargon.</LI><LI>     Limit messages to 2-3 lines.</LI><LI>     Avoid phrasing that blames the user.</LI><LI>     Avoid the use of contractions.</LI><LI>     Left-align multiple line messages.</LI><LI>     Never, ever, ever include misspellings, bad grammar or incorrect pronunciation. If your programmers wear their bad grammar like a badge, that's all the more reason to have someone who doesn't review the application!</LI></UL></LI><LI>    Proper font usage
<P CLASS="lp1">Table 1 provides a simple guide to proper Windows font usage, adapted slightly for custom corporate projects. Something like this should be a part of your GUI design standards document.</P></LI></UL><P>Table 1: Proper font usage for custom applications</P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="126pt" VALIGN="TOP"><COL WIDTH="190pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">
<FONT FACE="Verdana, Arial" SIZE=2><P>
Text</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Font</P></TD>

</TR><TR><TD VALIGN="TOP">
<FONT FACE="Verdana, Arial" SIZE=2><P>
Title bars, menu text</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Windows System font (10 point Sans Serif)</P></TD>

</TR><TR><TD VALIGN="TOP">
<FONT FACE="Verdana, Arial" SIZE=2><P>
Control labels and captions</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>8 point bold Sans Serif</P></TD>

</TR><TR><TD VALIGN="TOP">
<FONT FACE="Verdana, Arial" SIZE=2><P>
Data entry fields</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>8 point non-bold Sans Serif</P></TD>

</TR><TR><TD VALIGN="TOP">
<FONT FACE="Verdana, Arial" SIZE=2><P>
Status bar text</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>10 point non-bold Sans Serif</P></TD>

</TR><TR><TD VALIGN="TOP">
<FONT FACE="Verdana, Arial" SIZE=2><P>
Icon text</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>8 point non-bold Sans Serif</P></TD>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><UL><LI>    Correctly labeling interface controls
<P CLASS="lp1">Inconsistently labeled interface controls (text boxes, combo and list boxes, option buttons and groups, and so forth) can do as much as any single factor to give an application a hurried, unprofessional look. Without going into detail here, we'll recommend you define standards for:</P>


<UL><LI>     Capitalization</LI><LI>     Alignment and positioning</LI><LI>     Use of colons and other highlighting schemes</LI></UL></LI></UL><H5 CLASS="h4"> </A>Windows and Dialogs</H5><UL><LI>    Different window types/MDI Applications
<P CLASS="lp1">Windows applications are made up of three types of windows: application windows, MDI windows and dialog windows. MDI (for multiple document interface) windows are useful in applications where different views are required of the same underlying data. Since this is the situation in many moderate to complex Visual Basic projects (especially database applications), you should consider the MDI interface for your applications.</P>

<P CLASS="lp1">Visual Basic has excellent built-in support for MDI applications. One project can have one MDI parent window, and the <B>MDIChild</B> property is set to True for every window you want to be an MDI child window. Once you've determined that an application should be MDI, here are some tips you might find helpful.</P></LI></UL><p><B>Tip: MDI Applications.</B> Even though child windows, according to the standard references, should be completely sizable, we've found a slight departure from this works best in custom application work. Since many <I>data windows</I> present fixed fields and controls on the form, make these MDI child windows fixed in size and not maximizable. Give them these property settings:</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="81pt" VALIGN="TOP"><COL WIDTH="247pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">
<FONT FACE="Verdana, Arial" SIZE=2><P>
<B>BorderStyle</B></P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>1 - Fixed Single</P></TD>

</TR><TR><TD VALIGN="TOP">
<FONT FACE="Verdana, Arial" SIZE=2><P>
<B>MinButton</B></P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>True</P></TD>

</TR><TR><TD VALIGN="TOP">
<FONT FACE="Verdana, Arial" SIZE=2><P>
<B>MaxButton</B></P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>False</P></TD>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><p><B>Tip: Reusable Interface Components.</B> Better yet, create template forms for your MDI parent and child forms. Even though Visual Basic doesn't have the concept, as does Access, of a "normal" form on which default properties can be based, we've found that template forms can be used to much the same purpose. For example, template forms can be created with fairly extensive menu systems, both to demonstrate to your developers what your standard menus are for MDI parent and child forms, and to save them the time of having to create them over and over again. We keep our template forms in a shared project called GLOBALS.MAK. This not only contains re-usable interface components, but also our standard modules of generic procedures, global and constant declarations and so forth. </P>
<UL><LI>    Using Windows common dialogs
<P CLASS="lp1">Few things are more truly reusable than the resources provided by the underlying operating environment. In Windows 3.1x applications, you can use the File Open, File Save As, Color, Font, and Printer dialogs by either making a Windows API call or by using the common dialog custom control in Visual Basic. Getting used to using these operating system resources is important, and will become even more so as your applications make the transition to the Windows&nbsp;95 environment. Windows&nbsp;95 will make available a <I>much</I> higher level of functionality in the form of dialogs accessible by API calls, as long as you're programming to the Win32&reg; API set. Some of these will be a rich-text editor with built-in spell checking, and lots of interesting interface gadgets, such as gauges, scroll controls, and so forth.</P></LI></UL><H5 CLASS="h4"> </A>Menus</H5><UL><LI>    Menu types
<P CLASS="lp1">Given the three primary menu types Windows supports &mdash; pull-down, pop-up and cascading &mdash; you should define a standard for when to use what type of menu. In general, most Windows 3.1x Visual Basic applications rely primarily on pull-down menus. The use of cascading menus has been discouraged in the Windows 3.1 environment, but the Windows&nbsp;95 user interface relies heavily on cascading menus, and due to their easier operation it actually improves a user-interface somewhat.</P>

<P CLASS="lp1">You should also define a standard for when to use pop-up (context-sensitive) menus, since users are beginning to get used to their availability in popular application suites such as the Microsoft Office.</P></LI><LI>    Menus in custom applications
<P CLASS="lp1">In database applications, certain types of forms are so common that you can define a good standard for the menus that should be available for every form of a specific. For example, in our work we've defined a <I>data window</I> as any window that provides record or row-based navigation of an underlying table or set of records. You'll save a lot of time and develop more consistent and professional-looking applications if you define your own standard. Figure x-x shows one of the standard "Record" menus we use in our applications' data windows. Again, this form is included in the session code.</P></LI></UL><p><B>Tip: Copying and Pasting Menus.</B> Always remember to save your Visual Basic forms as text files (make sure the "Save as Text" checkbox is selected in the "Save File As" dialog). If you do, you can reuse interface components such as menus, even if you don't implement the complete forms-template approach we discussed above. You can do this by loading the form definition .FRM file for any of the forms in your application, copying the menu definition portion of the file to the clipboard, and pasting it into the proper location in a "target" form requiring the same menus. For example, Listing 1 shows the definition of a "Records" menu that could make sense in any table-based form.</P>
<p><I>Listing 1: Menu Definition Section of a .FRM File</I></P>
<P CLASS="spacing"><BR></P>
<pre><FONT FACE="Courier New" SIZE="3">Begin Menu mnuRecords 
      Caption         =   "&amp;Records"
      Begin Menu mnuRecordsGoto 
         Caption         =   "&amp;Go To"
         Begin Menu mnuRecordsGotoFirst 
            Caption         =   "&amp;First"
         End
         Begin Menu mnuRecordsGotoLast 
            Caption         =   "&amp;Last"
         End
         Begin Menu mnuRecordsGotoNext 
            Caption         =   "&amp;Next"
         End
         Begin Menu mnuRecordsGotoPrevious 
            Caption         =   "&amp;Previous"
         End
      End
      Begin Menu mnuRecordsSep1 
         Caption         =   "-"
      End
      Begin Menu mnuRecordsSort 
         Caption         =   "&amp;Sort..."
      End
      Begin Menu mnuRecordsFind 
         Caption         =   "&amp;Find..."
         Shortcut        =   ^F
      End
      Begin Menu mnuRecordsSep2 
         Caption         =   "-"
      End
      Begin Menu mnuRecordsAdd 
         Caption         =   "&amp;Add"
         Shortcut        =   ^A
      End
      Begin Menu mnuRecordsDelete 
         Caption         =   "&amp;Delete..."
      End
      Begin Menu mnuRecordsSave 
         Caption         =   "&amp;Save"
         Shortcut        =   ^S
      End
   End</font></pre>
<H5 CLASS="h4"> </A>Custom Controls and Add-Ons in Visual Basic</H5><p>Given the popularity of .VBX custom controls and add-on tools, you really have to define a standard toolset for your Visual Basic development teams. If you don't, your applications will not have a consistent look and feel, and your developers will continually be wasting time learning the latest cool tool. Without <I>recommending</I> any specific tools, here are the categories of add-ons our we've defined standards for:</P>
<UL><LI>    Enhancing the Visual Basic design environment</LI><LI>    Collections of enhanced/data aware versions of "standard" controls</LI><LI>    Collections of non-standard controls (e.g., tab controls, customizable toolbars, etc.)</LI></UL></BODY></HTML>
