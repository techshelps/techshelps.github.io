<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Minimizing Buffer Copies</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>	<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>


	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<h3>Minimizing Buffer Copies</H3><p>Under most UNIX implementations, every sockets I/O request results in a buffer copy to or from a system buffer. This generally simplifies things for applications, but at the cost of extra CPU overhead to perform the buffer copy.</P>
<p>Under Windows&nbsp;NT and Windows '95 operating systems, Windows Sockets attempts to avoid buffer copies whenever possible. However, application actions play a big role in how often buffer copies must be performed.</P>
<p>On the sending side, the rules for buffer copies are simple. By default, Windows Sockets <I>always</I> copies the user buffer into an intermediate buffer before passing it on to the transport protocol. This is because the transport protocol must hang on to the data until it receives an acknowledgment from the remote end that the data has been successfully received. However, most applications want their <B>send()</B> call to complete immediately so that the thread can proceed with other work.</P>
<p>Applications and services which require extremely high performance can, at the cost of some complexity, avoid the send-side buffer copies. To avoid the buffer copies, set the SO_SNDBUF socket option to 0, which tells Windows Sockets not to do send buffering. The application must then use an overlapped <B>WriteFile()</B> call to send data. These <B>WriteFile()</B> calls will not complete until the transport protocol is done with the data, so it is important to keep data available to the transport protocol by pending multiple I/O calls at any one time. For example, the application calls <B>WriteFile()</B> which returns ERROR_IO_PENDING. Before I/O completion is signaled, the application should, assuming that there is more data to be sent, can <B>WriteFile()</B> a second time. As soon as the first <B>WriteFile()</B> completes, the application calls <B>WriteFile() </B>again, giving yet more data. This "double-buffering" ensures that there is always data available in the transport protocol, so that the pipe never empties.</P>
<p>On the receiving side, the rules are a little different. Windows Sockets will copy incoming data directly into a user buffer if one is available. If there is no available user buffer, Windows Sockets is forced to copy into a system buffer, then into a user buffer when one eventually comes in.</P>
<p>A user buffer is available whenever a <B>recv()</B> or <B>ReadFile()</B> is outstanding on a socket. Therefore, if an application calls <B>recv()</B> in advance of data arriving, the data will be placed directly into the user buffer. This is another reason to avoid the <B>select()</B> call: applications which call <B>select() </B>usually do not have any user buffers available to the system, so Windows Sockets is forced to perform buffer copies whenever data comes in.</P>
<p>Double buffering can also be used on the receive side to avoid buffer copies. On the receive side, the application should pend two <B>ReadFile()</B> calls so that two user buffers are available to the system. Then, when data arrives, it does directly into one of the buffers. While the application is processing that data, there is still another buffer to receive incoming data, thereby avoiding the window where two chunks of data arrive back-to-back, the first going into a user buffer and the second into a system buffer.</P></BODY></HTML>
