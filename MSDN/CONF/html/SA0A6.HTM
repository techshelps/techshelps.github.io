<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Overview of Object Mapping</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>	<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>


	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<h3>Overview of Object Mapping</H3><p>To upsize a Microsoft&nbsp;Access database to SQL Server, the Upsizing Wizard creates SQL Server objects that, as far as possible, do everything the Microsoft&nbsp;Access database did.</P>
<p>In some cases, mapping Microsoft&nbsp;Access objects to SQL Server objects is very straightforward. Microsoft&nbsp;Access databases, tables, fields, defaults, and indexes map to SQL Server databases, tables, fields, defaults, and indexes. This is a direct, one-to-one mapping.</P>
<p>However, this is not the case for all objects. Validation rules and referential integrity, in Microsoft&nbsp;Access, are part of the data dictionary and are enforced at the engine level. SQL Server validation rules and referential integrity are not part of the data dictionary, and are enforced through code bound to a table.</P>
<p>These differences, as well as design decisions made by the Upsizing Wizard, mean that much of the Microsoft&nbsp;Access data dictionary cannot be mapped directly to SQL Server constructs.</P>
<p>The following table summarizes how objects are mapped from Microsoft&nbsp;Access objects to SQL Server:</P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="117pt" VALIGN="TOP"><COL WIDTH="154pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>Microsoft&nbsp;Access object</B></P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>SQL Server object</B></P></TD>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Database</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Database</P></TD>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Table</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Table</P></TD>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Indexes</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Indexes</P></TD>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Field</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Field</P></TD>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Default</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Default</P></TD>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Table validation rule</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Update and Insert triggers</P></TD>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Field validation rule</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Update and Insert triggers</P></TD>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Field Required property</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Update and Insert triggers</P></TD>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Relations</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Update, Insert, and Delete triggers</P></TD>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><p>The following sections discuss each Microsoft&nbsp;Access object and the SQL Server object (or objects) to which it maps.</P>
<H4> </A>Database and Table Objects</H4><p>A Microsoft&nbsp;Access .MDB file maps directly to a SQL Server database. A Microsoft&nbsp;Access table, excluding much of its data dictionary, maps to a SQL Server table.</P>
<p>The Upsizing Wizard replaces illegal characters with the "_" symbol. Any names that are SQL Server keywords, FROM or GROUP for example, have the "_" symbol appended to them, resulting in the names FROM_ and GROUP_.</P>
<H4> </A>Attachments to New Server Tables</H4><p>If you selected the Attach newly created SQL Server tables check box, the Upsizing Wizard will create these attachments as well as give them many of the properties of the fields in the original local table.</P>
<p>Fields in attached tables inherit the following properties from the original fields:</P>
<P><ul><li>    Description</P>
<P><li>    Caption</P>
<P><li>    Format</P>
<P><li>    InputMask</P>
<P><li>    DecimalPlaces</P></ul>
<H4> </A>Indexes</H4><p>SQL Server and Microsoft&nbsp;Access indexes are very similar. Microsoft&nbsp;Access primary keys are converted to SQL Server clustered, unique indexes, and are always named "aaaaa_PrimaryKey." When attaching to a remote table, Microsoft&nbsp;Access chooses the index that is first alphabetically in the list of available indexes as the primary key. The name "aaaaa_PrimaryKey" ensures that the right index is chosen. All other indexes retain their names, except where they contain illegal characters. Illegal characters are replaced with the "_" symbol.</P>
<p>Unique and non-unique Microsoft&nbsp;Access indexes become unique and non-unique SQL Server indexes. SQL Server doesn't support ascending or descending indexes.</P>
<H4> </A>Relationship Indexes</H4><p>When you create a relationship between two Microsoft&nbsp;Access tables, a new index on the foreign key in the relationship is created automatically. These system-generated indexes do not appear in the Microsoft&nbsp;Access index editor.</P>
<p>Microsoft&nbsp;Access names these relationship indexes "Reference" and, if the index name is not unique within a database, adds a suffix. Because an index named "Reference" could also be created by a user, the Upsizing Wizard exports all indexes, and does not distinguish between system-generated indexes and user-created indexes.</P>
<p>These system-generated relationship indexes improve performance when tables are joined. However, if you end up with two identical indexes, one user created and the other system generated, you can drop one of the indexes.</P>
<H4>Example</H4><p>The following table lists the indexes created when an Employees table is upsized.</P>

<TABLE COLS="4" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="85pt" VALIGN="TOP"><COL WIDTH="109pt" VALIGN="TOP"><COL WIDTH="99pt" VALIGN="TOP"><COL WIDTH="64pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>Microsoft&nbsp;Access Index Name</B></P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>Index type</B></P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>SQL Server Index&nbsp;Name</B></P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>Index type</B></P></TD>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>PrimaryKey</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Unique primary key</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>aaaaa_PrimaryKey</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Clustered, unique</P></TD>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Dept ID</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Non-unique, ascending</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Dept_ID</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Non-unique</P></TD>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Reports To</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Non-unique, ascending</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Reports_To</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Non-unique</P></TD>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Reference</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Non-unique, ascending</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Reference</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Non-unique</P></TD>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><p>The index "Reference" is a relationship index created by Microsoft&nbsp;Access on the Dept ID field, which serves as the foreign key for a Departments table.</P>
<H4> </A>Fields</H4><p>Field names and data types are automatically translated into SQL Server fields when a Microsoft&nbsp;Access table is exported by the Upsizing Wizard.</P>
<p>Microsoft&nbsp;Access data types map to SQL Server data types as follows:</P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="112pt" VALIGN="TOP"><COL WIDTH="90pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>Microsoft&nbsp;Access Type</B></P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>SQL Server Type</B></P></TD>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Yes/No</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>bit</P></TD>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Number (Byte)</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>smallint</P></TD>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Number (Integer)</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>smallint</P></TD>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Number (Long Integer)</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>int</P></TD>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Number (Single)</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>real</P></TD>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Number (Double)</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>float</P></TD>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Currency</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>money</P></TD>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Date/Time</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>datetime</P></TD>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Counter</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>int</P></TD>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Text(n)</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>varchar(n)</P></TD>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Memo</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>text</P></TD>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>OLE Object</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>image</P></TD>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><H4> </A>Defaults</H4><p>A Microsoft&nbsp;Access default expression maps directly to a single SQL Server default. While largely similar, there are some differences in the way defaults are created and behave in the two products.</P>
<p>SQL Server defaults are independent of any particular field or table. Once a default has been created, it can be used or "bound" to any number of different fields. The Upsizing Wizard tries to create a SQL Server default based on the default expression for a Microsoft&nbsp;Access field.</P>
<p>Defaults created by the Upsizing Wizard are named according to the SQL Server table to which they are bound, with a number that represents the position of the field in the Microsoft&nbsp;Access table definition. (This is the same as the order in which the fields appear in table design view.)</P>
<p>If two or more fields have the same nonzero default expression, the Upsizing Wizard creates two defaults that are functionally identical with different names. Fields with a default expression of zero are bound to a default named UW_ZeroDefault.</P>
<p>If any exported tables contain counter fields, the UW_ZeroDefault is automatically created and bound to each of those fields, whether or not you chose to export defaults. Also, any Yes/No fields that don't have a default will automatically have a "no" default bound to them. This makes interaction between Microsoft&nbsp;Access and SQL Server much smoother.</P>
<p>The upsizing report will indicate whether the Upsizing Wizard was successful in translating the Microsoft&nbsp;Access Basic expression to SQL Server Transact-SQL. If the default was successfully created, the wizard binds it to the appropriate SQL Server field.</P>
<H4> </A>Triggers</H4><p>Counter fields, validation rules, and table relations map to SQL Server triggers. A trigger is a series of Transact-SQL statements associated with a particular SQL Server table. The Upsizing Wizard creates triggers when you export validation rules or table relationships, or when your table contains a counter field.</P>
<p>Validation rules and table relations do not map directly to triggers. Each rule or relation may become part of several triggers. Each trigger may contain code to emulate the functionality of several validation and referential integrity rules.</P>
<p>A table can have three triggers, one for each of the commands that can modify data in the table: the UPDATE, INSERT, and DELETE commands. The trigger is automatically executed when the command is carried out.</P>
<p>The following table describes the triggers created by the Upsizing Wizard. Any specific trigger may contain code to emulate one, all, or none of the Microsoft&nbsp;Access functions listed.</P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="125pt" VALIGN="TOP"><COL WIDTH="239pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>Trigger</B></P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>Microsoft&nbsp;Access Functionality Emulated</B></P></TD>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>UPDATE</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Validation rules (Record validation, Field validation, Required property)</P>
<P>Referential integrity</P></TD>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>INSERT</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Validation rules (Record validation, Field validation, Required property)</P>
<P>Referential integrity (Child table triggers only)</P>
<P>Counter data type</P></TD>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>DELETE (Parent table triggers only)</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>\Referential integrity</P></TD>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><H4> </A>Counter Fields</H4><p>Counter fields in Microsoft&nbsp;Access are long integer fields that are automatically incremented. SQL Server doesn't support the counter data type, so the Upsizing Wizard includes code in the INSERT triggers that provides equivalent functionality.</P>
<H4> </A>Example</H4><p>The Transact-SQL code below was generated as part of upsizing a Tasks table, and is contained in the trigger called Tasks_ITrigger. This code provides the same functionality as the counter field "Task ID" in a Microsoft&nbsp;Access table Tasks.</P>
<P CLASS="spacing"><BR></P>
<pre><FONT FACE="Courier New" SIZE="3">DECLARE @maxc int, @newc int
SELECT @maxc = (SELECT Max(Task_ID) FROM Tasks) 
SELECT @newc = (SELECT Task_ID FROM inserted) 
IF @newc = 0 OR @maxc &lt;&gt; @newc SELECT @maxc = @maxc + 1 
UPDATE Tasks SET Task_ID = @maxc WHERE Task_ID = @newc</font></pre>
<H4> </A>Validation Rules</H4><p>The Upsizing Wizard can export table validation rules and field validation.</P>
<p>For each table, the Upsizing Wizard:</P>
<P><ul><li>    Converts each validation rule to Transact-SQL, if possible. The upsizing report will indicate whether conversion was successful.</P>
<P><li>    Creates a fragment of Transact-SQL code for each Microsoft&nbsp;Access field where the Required property is set to true. This code presents an error message, similar to the one Microsoft&nbsp;Access displays if the field is null when a record is added or updated.</P>
<P><li>    Combines all the converted validation rules and Required property code.</P>
<P><li>    Places a copy of the combined code into both an UPDATE and an INSERT trigger on the SQL Server table.</P></ul>
<p><B>Note  </B> The Upsizing Wizard uses triggers rather than SQL Server rules to enforce field level validation because SQL Server rules do not allow you to display custom error messages.</P>
<H4> </A>Example</H4><p>The following code is contained in both the Tasks_Itrig and Tasks_Utrig triggers, which are associated with the Tasks table.</P>
<p>This code is the SQL Server equivalent of two Microsoft&nbsp;Access field level validation rules (for the Status and Date Completed fields) and one Microsoft&nbsp;Access table validation rule.</P>
<P CLASS="spacing"><BR></P>
<pre><FONT FACE="Courier New" SIZE="3">...
ELSE IF (SELECT Count(*) FROM inserted 
WHERE NOT (Status In ('Not Started','Started','Done'))) &gt; 0
  BEGIN
    RAISERROR 44444 "Status must be one of: 'Not 
Started','Started','Done'"
    ROLLBACK TRANSACTION
  END
ELSE IF (SELECT Count(*) FROM inserted 
WHERE NOT (Date_Completed Is Null Or Date_Completed&gt;'01/1/94')) &gt; 0
  BEGIN
    RAISERROR 44444 "Date_Completed must be after 1/1/94"
    ROLLBACK TRANSACTION
  END
ELSE IF (SELECT Count(*) FROM inserted 
WHERE NOT (Status="Done" Or Date_Completed Is Null)) &gt; 0
  BEGIN
    RAISERROR 44444 "Status must be 'Done' before you enter Date_Completed"
    ROLLBACK TRANSACTION
  END</font></pre>
<p><B>Note  </B> The user-defined error number of 44444 is used for all instances where validation rules (table validation, field validation, and the Required property) are violated.</P>
<H4> </A>Required Property</H4><p>When the Required property of a Microsoft&nbsp;Access field is set to true, a user cannot insert a record and leave the required field null (if there is no default bound to the field), or make the field null when updating a record. The Upsizing Wizard can generate SQL Server Transact code to emulate the Required property.</P>
<p>The Upsizing Wizard uses triggers to emulate the Required property, rather than the SQL Server engine–enforced equivalent of this functionality, so that you can allow or disallow nulls by changing the trigger.</P>
<H5 CLASS="h4"> </A>Example</H5><p>The following code is generated because the Required property of the Emp ID field in the Tasks table is set to true. The code is contained in both the Tasks_Utrig and Tasks_Itrig triggers of the Tasks table.</P>
<P CLASS="spacing"><BR></P>
<pre><FONT FACE="Courier New" SIZE="3">IF (SELECT Count(*) FROM inserted WHERE Emp_ID IS NULL) &gt; 0
  BEGIN
    RAISERROR 44444 "Emp_ID may not be NULL"
    ROLLBACK TRANSACTION
  END</font></pre>
<H4> </A>Table Relationships</H4><p>The Upsizing Wizard creates triggers that include the Transact-SQL code required to duplicate Microsoft&nbsp;Access table relationships. Microsoft&nbsp;Access supports declarative referential integrity that is enforced at the engine level. In SQL Server, referential integrity is enforced by Transact-SQL code in triggers. A Microsoft&nbsp;Access relationship becomes four SQL Server triggers: two for the parent table and two for the child table.</P>
<p><B>Important: </B>If only one of the tables in a relationship is upsized, or if referential integrity is not enforced in Microsoft&nbsp;Access, the relationship is not exported.</P>
<H4> </A>Parent Table</H4><p>The Upsizing Wizard will create an UPDATE trigger that will either prevent changing the parent table's primary key or cascade that change through the child table, depending on the type of relationship that was created in Microsoft&nbsp;Access.</P>
<p>The wizard will also create a DELETE trigger that prevents deleting a record with related child records, or that deletes the child records, again depending on the type of the original relationship between the tables in Microsoft&nbsp;Access.</P>
<H5 CLASS="h4"> </A>Examples</H5><p>The following Transact-SQL code is contained in the Departments_Dtrig trigger of the Departments table. It prevents deleting a parent record that would orphan related records in the Employees table.</P>
<P CLASS="spacing"><BR></P>
<pre><FONT FACE="Courier New" SIZE="3">IF (SELECT COUNT(*) FROM deleted, Employees 
WHERE (deleted.Dept_ID = Employees.Dept_ID)) &gt; 0
    BEGIN
        RAISERROR 44445 'There are dependent rows in Employees'
        ROLLBACK TRANSACTION
    END</font></pre>
<p>The second example illustrates how changes to the primary key (the Email field) are cascaded to the child table's foreign key. The code is contained in the Employees_Utrig trigger of the Employees table. </P>
<P CLASS="spacing"><BR></P>
<pre><FONT FACE="Courier New" SIZE="3">IF UPDATE(Email)
    BEGIN
       UPDATE Tasks
       SET Tasks.Emp_ID = inserted.Email
       FROM Tasks, deleted, inserted
       WHERE deleted.Email = Tasks.Emp_ID
    END</font></pre>
<H4> </A>Child Table</H4><p>For the child table, the Upsizing Wizard creates an UPDATE trigger that prevents changes to the foreign key that would orphan the record. Likewise, an INSERT trigger is created to prevent a new record from being added that has no parent.</P>
<H5 CLASS="h4"> </A>Example</H5><p>This code prevents adding a record to the Tasks table if no parent record exists in the Employees table, and is contained in the Tasks_Itrig trigger.</P>
<P CLASS="spacing"><BR></P>
<pre><FONT FACE="Courier New" SIZE="3">IF (SELECT COUNT(*) FROM inserted) !=
   (SELECT COUNT(*) FROM Employees, inserted 
    WHERE (Employees.Email = inserted.Emp_ID))
    BEGIN
        RAISERROR 44447 'No row in Employees with matching key'
        ROLLBACK TRANSACTION
    END</font></pre>
<p>Similar code is found in the Tasks_Utrig trigger to prevent orphaning records through changing the foreign key.</P>
<H4> </A>Custom Error Values</H4><p>When the referential integrity established by the wizard-created triggers is violated, the Upsizing Wizard places a custom error value into the @@ERROR variable. The value depends on the action the user was attempting: updating, inserting, or deleting.</P>
<p>The following table lists the error numbers generated for each action:</P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="88pt" VALIGN="TOP"><COL WIDTH="40pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>Action</B></P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>Error</B></P></TD>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Attempted delete</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>44445</P></TD>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Attempted update</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>44446</P></TD>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Attempted insert</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>44447</P></TD>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P></BODY></HTML>
