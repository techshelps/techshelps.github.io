<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Sending and Receiving Data (datagram sockets)</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>	<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>


	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<h3>Sending and Receiving Data (datagram sockets)</H3><p>Data transmission on datagram sockets is significantly different from stream sockets. The most important difference is that transmission is not reliable on datagram sockets. This means that if an application attempts to send data to another application, the system does nothing to guarantee that the data will actually be delivered to the remote application. Reliability will tend to be good on LANs (local-area networks, such as a network connecting several computers within a single building), but can be very poor on WANs (wide-area networks, such as the Internet which connects hundreds of thousands of computers worldwide). </P>
<p>The next important difference in datagram sockets is that they are connectionless. This means that there is no default remote address assigned to them. For this reason, an application which wants to send data must specify the address to which the data is destined with the <I>sendto() </I>API. In addition, an application typically wants to know where data came from, so it receives data with the <I>recvfrom() </I>API, which returns the address of the sender of the data.</P>
<p>The final significant difference in data transmission for datagram sockets is that it is "message oriented." This means that there is a one-to-one correspondence between <I>sendto() </I>and <I>recvfrom()</I> calls, and that the system does not coalesce data when sending it. For example, if an application makes 10 calls to <I>sendto()</I> with a buffer of two bytes, the remote application will need to perform 10 calls to <I>recvfrom()</I> with a buffer of at least two bytes to receive all the data.</P>
<p>Below is a code fragment from a datagram sockets application which echos datagrams back to the sender.</P>
<P CLASS="spacing"><BR></P>
<pre><FONT FACE="Courier New" SIZE="3"> 
SOCKET             s;
SOCKADDR_IN         remoteAddr;
int             remoteAddrLength = sizeof(remoteAddr);
BYTE             buffer[1024];
int             bytesReceived;

for ( ; ; ) {       
    /* Receive a datagram on socket s */

   bytesReceived = recvfrom( s, buffer, sizeof(buffer),0,
                        (PSOCKADDR)&amp;remoteAddr, &amp;remoteAddrLength );
  
    /* Echo back to the server as long as bytes were received */

   if ( bytesReceived != SOCKET_ERROR ||
        sendto( s, buffer, bytesRecieved, 0,
                (PSOCKADDR)&amp;remoteAddr, remoteAddrLength ) ==
        SOCKET_ERROR ){
        sprintf(buf,"Windows Sockets error %d: Error while sending data.",
             WSAGetLastError());
        MessageBox (hWnd,buf,"Windows Sockets Error",MB_OK);    
        shutdown_appl();
    }
}</font></pre>
<p>As mentioned earlier, it is possible to <I>connect()</I> a datagram socket. Once a datagram socket is connected, all data is sent and received from the remote address to which the datagram is connected, so it is possible to use the <I>send()</I> and <I>recv()</I> APIs on connected datagram sockets.</P></BODY></HTML>
