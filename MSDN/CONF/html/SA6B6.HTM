<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Speed finds by creating a temporary indexed table and seeking</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>	<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>


	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<h3>Speed finds by creating a temporary indexed table and seeking</H3><p>When you know that you are going to do queries that only involve a certain subset of data, you can create a temporary table containing just the rows and columns that you expect to search later. This is created by executing a three or four table join and returning only the needed columns and rows. If you add an index to the temporary table, access to this table is even faster.</P>
<p>Snapshots are a good way to get to this data for ODBC servers, but they cannot be searched with the Seek method because the temporary result that is returned is not indexed. The find methods are unable to use an index for the same reason, and they can be slow if this is a large dynaset. Further WHERE clause refinements to the query still take server time, and if there are a large number of such queries this can be too slow.</P>
<p>One possible solution in this scenario is to do a make-table query to create a "permanent" table in the local database that has its own index, that the time to seek is well worth the time it takes to build. The numbers below show an example of these different approaches with a small table:</P>
<UL><LI>7 seconds to create permanent table subset from an ODBC table and index and 0.7 seconds to open it, versus</LI>
<LI>0.7 seconds to open a snapshot (and movelast)</LI>
<LI>The times to find data in each of these result sets is:</LI>
<LI>2.7 seconds to locate each of n records in the table using Seek, versus</LI>
<LI>21.6 seconds to locate each of n records in the snapshot using findfirst</LI></ul>
<p>This does not scale very well with larger tables that are drawn from SQL Server, but you can always use passthrough to create real SQL Server temporary tables and query against those. </P>
<p>When tried against larger .MDB tables the results are as follows:</P>
<p>For a query that returns 564 records,</P>
<UL><LI>77 seconds to create a permanent table and index, versus</LI>
<LI>70 seconds to create a snapshot with the same data (with movelast)</LI></UL>
<p>Searching for 342 records:</P>
<UL><LI>14 seconds via Seek against the permanent table</LI>
<LI>83 seconds via FindFirst against the snapshot</LI></ul>
<BR>There is a 10% price to pay to get a permanent table built vs. a snapshot. However, on the lookup end, the improved performance is dramatic - almost six times as fast. Obviously the number of subsequent searches you expect to be doing is a big factor here.</BR>
<BR>The downside to using permanent tables like this are:</BR>
<OL><LI>The developer must ensure that the table is deleted when no longer needed. Jet does not provide for a way to automatically drop these tables when the database or workspace is no longer in scope.</LI>
<LI>Name collisions on multi-user systems. You must build a guaranteed unique name. (See the Access Knowledge Base article Q88929 for one way of doing this.)</LI>
<P>Of course like all the tips given in this paper, you should carefully benchmark any solution to ensure that all the tradeoffs are taken into account.</P></OL></BODY></HTML>
