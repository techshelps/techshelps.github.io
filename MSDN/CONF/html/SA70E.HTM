<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using Caching</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>	<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>


	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<h3>Using Caching</H3><p>One of the slowest and most inefficient ways to process server data is to open a dynaset on an attached ODBC table and then proceed to move through it. For example, you should avoid doing the following:</P>
<P CLASS="spacing"><BR></P>
<pre><FONT FACE="Courier New" SIZE="3">' DO NOT DO THIS, ESPECIALLY with ODBC data!  
' Use SQL Statements Instead.  For example:
'  MyDB.Execute "UPDATE Employees SET Title = 'Account Executive'
'                WHERE Title = 'Sales Representative'"

Dim MyDB As Database, MyRS As Recordset
Set MyDB = DBEngine.Workspaces(0).Databases(0)
Set MyRS = MyDB.OpenRecordset("Employees", DB_OPEN_DYNASET)
...
MyRS.MoveFirst    ' Locate first record.
Do Until MyRS.EOF    ' Begin loop.
    If MyRS!Title = "Sales Representative" Then   ' Check title.
        MyRS.Edit    ' Enable editing.
        MyRS!Title = "Account Executive"    ' Change title.
        MyRS.Update    ' Save changes.
    End If
    MyRS.MoveNext    ' Locate next record.
Loop                            ' End of loop.
MyRS.Close            ' Close table.</font></pre>
<p>Of course the above code would execute much more efficiently with an appropriate SQL statement, especially as a pass-through query (see elsewhere in this document). Even though the above code example is an obvious candidate for being replaced, some situations may require that you write code similar to this. If you need to, then you should use the <I>Cache</I> properties and methods in DAO.</P>
<p>Microsoft&nbsp;Access 2.0's CacheSize and CacheStart properties let you store all or part of the data contained in a dynaset-type Recordset in local memory. Local caching of rows dramatically speeds up operations when traversing dynaset rows bi-directionally and shows significant improvements even when moving in a forward only direction. </P>
<p>To use caching, you specify the number of rows to be stored by the value of CacheSize (Long) and the beginning row by the bookmark stored as the value of the CacheStart (String) property. Applying the FillCache method fills the cache with server data. Fetches within the cache boundary occur locally, speeding display of the cached records in a datasheet or in a continuous form. The allowable range of the value of CacheSize is between 5 and 1,200 records; if the size of the cache exceeds available memory, the excess records spill into a temporary disk file. Typically, you set the value of CacheSize to 100. To recover the cache memory, set CacheSize = 0. </P>
<p>For example, the above code would become:</P>
<P CLASS="spacing"><BR></P>
<pre><FONT FACE="Courier New" SIZE="3">' Assumes Employees is an attached ODBC table
Const EmpCache% = 100     ' # of employee recs to cache
Dim MyDB As Database, MyRS As Recordset, Dim I as Integer
Set MyDB = DBEngine.Workspaces(0).Databases(0)
Set MyRS = MyDB.OpenRecordset("Employees", DB_OPEN_DYNASET)

MyRS.CacheSize = EmpCache

I = 0
Do Until MyRS.EOF
    If I Mod EmpCache = 0 Then
        MyRS.CacheStart = MyRS.Bookmark
        MyRS.FillCache
    End If
    If MyRS!Title = "Sales Representative" Then
        MyRS.Edit
        MyRS!Title = "Account Executive"
        MyRS.Update
    End If
    MyRS.MoveNext
    I = I + 1
Loop    
MyRS.Close</font></pre>
<p>As shown above, once you establish the cache, you need to keep moving its location to stay synchronized with the set of records you're working with. Using a cache with the example above can provide twice the performance of not specifying cache. If the application requires backward scrolling within the cached region, the performance improvements will be even larger. Depending on your scenario, using a cache may be faster than using a read-only, forward-only snapshot (especially if the snapshot contains memo or long binary fields that may only be referenced occasionally). </P>
<p>The size of the cache you use will be determined by the application needs. For example, if you are displaying these records to the user, then you might use a cache size determined by the number of rows they can have on the screen. If the code has no user interaction, then a tradeoff between local memory availability, network traffic, row size, and fetch delay can be made, usually by experimentation.</P></BODY></HTML>
