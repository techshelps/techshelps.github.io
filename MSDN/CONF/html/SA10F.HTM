<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Microsoft SQL Server Optimization and Tuning Guidelines</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>	<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>


	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<h3>Microsoft SQL Server Optimization and Tuning Guidelines</H3><p>The following optimization guidelines will aid in the optimization of Microsoft SQL Server as part of a Microsoft BackOffice solution. Optimal application of these guidelines are unique to each environment. Thus, you may wish to experiment with different configurations and values, in order to arrive at the best combination of settings for your particular Microsoft BackOffice system.</P>
<P>     The SQL Server Setup program allows for the selection of two options that affect the priority at which SQL Server runs, thereby influencing system performance. These options can be found under the "Set Server Options" selection of the Setup program.</P>
<P CLASS="lp1">Since these options affect the priority at which SQL Server threads run, the following definitions are necessary for basic understanding of Windows&nbsp;NT thread scheduling.</P>
<P>     <B>Thread Priority</B>&mdash;Windows&nbsp;NT uses 32 levels of thread priorities, ranging from 1 (the lowest) to 31 (the highest), with 0 being reserved for system use. There are two thread priority categories, variable and real-time.</P>
<P>     <B>Variable Priority</B>&mdash;Variable priority threads range from 1 through 15. The Windows&nbsp;NT thread scheduler adjusts the priority based on thread behavior. Hence, variable priority threads may have their priority adjusted up or down.</P>
<P>     <B>Real-Time Priority</B>&mdash;Real-time priority threads range from 16 through 31. The priority of these threads are not adjusted by the Windows&nbsp;NT thread scheduler based on behavior. Consequently, this provides "near real-time" execution.</P>
<P>     <B>Dispatch Queue</B>&mdash;A list of "ready threads" that are in order of priority. The scheduler examines the dispatch queue for the highest-priority ready thread and selects it for execution for the allotted time slice.</P>
<H4 CLASS="h4"> </A>Boost Microsoft SQL Server Priority</H4><p>Boosting Microsoft SQL Server's priority can improve performance and throughput on single- and multiple-processor hardware platforms. By default this option is turned off and SQL Server runs at a priority of 7. When selected on a single-processor platform, SQL Server runs at priority 13. When selected on a dedicated SMP platform, SQL Server runs at priority 24. The significance is of course that the Windows&nbsp;NT thread scheduler will favor SQL Server threads over threads of other processes.</P>
<p>If this option is turned on, it may degrade the performance of other processes. Hence, this option should only be turned on for dedicated SQL Server machines, or if slower performance of other processes is tolerable.</P>
<H4 CLASS="h4"> </A>Dedicated Multiprocessor Performance</H4><p>Microsoft SQL Server can take advantage of SMP platforms without this option being turned on. In this off state SQL Server runs at a priority level of 7. When this option is turned on the priority is increased to 13, thus increasing the scalability improvement multiple CPUs have on SQL Server performance.</P>
<p>As with the Boost SQL Server priority option, if turned on it may degrade the performance of other processes. Hence, this option should only be turned on for dedicated SQL Server–based machines.</P>
<p>If both options are turned on for SMP platforms, SQL Server runs at a priority of 24.</P>
<p>The following SQL Server configuration parameters are those that impact performance or performance-related resources. Each configuration parameter is defined with respect to its function and its impact on performance. See the SQL Server Configuration Guide for more details on sp_configure settings. It is recommended that you start with the default values and experiment with changing parameter values once you have obtained a baseline of performance. When adjusting parameters to tune performance, adjust one parameter at a time, and measure the difference in performance; changing multiple parameters in an ad hoc fashion is generally not productive.</P>
<P>     <B>Memory:</B> As a general rule; on machines with 32 MB or less, you should allocate at least 8 to 16 MB to Windows&nbsp;NT, and configure Microsoft SQL Server to use the rest. When you have more than 32 MB in your machine, allocate 16 to 20 MB to Windows&nbsp;NT, and allocate the rest of the memory to SQL Server.</P>
<P CLASS="lp1"><B>Performance impact:</B> Physical memory is used by SQL Server for server operation overhead, data (buffer) cache, and procedure cache. Hence, in order to reduce SQL Server page faults, an appropriate amount of memory should be configured. Please refer to the previous discussion in this paper concerning memory.</P>
<P>     <B>Max async IO:</B> The "max async IO" parameter controls the number of outstanding asynchronous batch writes performed by checkpoint and Lazywriter. The default is 8, and this is likely to be sufficient in most cases. However, you may wish to experiment with this number to try to improve performance. Increasing the parameter will allow more asynchronous batch writes to be done, effectively shortening the period that the system is checkpointing or doing Lazywriting. However, if your I/O subsystem cannot sustain the increased write activity, the increased writes will flood the I/O systems and can interfere with the ability of SQL Server (or other processes) to read from the disk, resulting in decreased throughput. The behavior of this parameter is thus dependent to a large degree on the underlying I/O subsystem.</P>
<P CLASS="lp1"><B>Performance impact:</B> SQL Server for Windows&nbsp;NT uses the asynchronous I/O capability of the Windows&nbsp;NT operating system. Examples of these are the Win32 API calls ReadFile(), ReadFileEx(), WriteFile(), and WriteFileEx(). See the Win32 Software Development Kit (SDK) for more information. Asynchronous, or overlapped I/O, refers to the ability of a calling program to issue an I/O request and without waiting for completion to continue with another activity. When the I/O finishes, the operating system will notify the program via a callback or other Win32 synchronization mechanism.</P>
<P>     <B>Procedure cache:</B> By default, 20% of the available memory is reserved for procedure cache. In systems with large amounts of memory, this is often excessive. </P>
<P CLASS="lp1"><B>Performance impact:</B> Having a properly sized procedure cache will result in fewer page faults with respect to use of stored procedures, triggers, rules, and defaults. Please refer to the previous discussion in this paper concerning memory.</P>
<P>     <B>Tempdb in RAM:</B> This option can improve performance when processing involves sorting, group by, or joins without supporting indexes. Allocating memory to Tempdb effectively reduces the amount of memory available to allocate to the SQL Server data cache. Accordingly, you need enough physical memory to store the entire Tempdb in RAM without impacting the memory required for Windows&nbsp;NT Server, SQL Server, and applications. Thus you should only consider using Tempdb in RAM when you have large amounts of memory available. The default is off (0).</P>
<P CLASS="lp1"><B>Performance impact:</B> Forcing Tempdb into RAM may result in increased performance if a significant amount of processing involves the creation and use of "WORKTABLES" by the SQL Server optimizer. Execution of such processing in RAM is inherently faster than corresponding disk I/O from paging.</P>
<p>The tuning of system resources typically involves the discovery of "bottlenecks." A bottleneck is the single resource that consumes the most time during a task's execution. In the case of Microsoft SQL Server, such resource bottlenecks adversely affect the performance of normal relational database operations as well as causing contention with other Microsoft BackOffice applications. Hence, the following information pertains to the detection of SQL Server resource bottlenecks and the subsequent adjustment of the resource in order to relieve the demand and increase performance.</P>
<H4> </A>Processor Tuning</H4><p>Processor tuning involves the detection of CPU-bound operations. The following processor bottleneck monitoring guidelines will aid in determining such problems.</P>
<H5 CLASS="h4"> </A>Symptoms and Actions:</H5><P>     <B>Symptom:</B> If <B>Processor: % Processor Time</B> consistently registers in the range of 80% to 100%, the processor(s) may be the bottleneck. (<B>System: %</B> <B>Total Processor Time</B> can be viewed for multiprocessor systems).</P>
<P CLASS="lp1"><B>Action:</B> If this occurs you need to determine which Microsoft SQL Server User process is consuming the CPU. To determine which process is using up most of the CPU's time, monitor the <B>SQLServer-Users: CPUtime</B> for all of the process instances (spid). One or more will appear as using the greatest cumulative time. Having determined the offending process instance, examine the query for inefficient design. In addition, examine indexes and database design for inefficiencies with respect to excessive I/O, which consumes CPU cycles. (Wide tables and indexes cause more I/Os to occur as do table scans.)</P>
<P>     <B>Symptom:</B> If <B>Processor: % Privlieged Time</B> is consistently over 20% and <B>Processor: % User Time</B> is consistently below 80%, then SQL Server is likely generating excessive I/O requests to the system.</P>
<P CLASS="lp1"><B>Action:</B> Examine the disk controller card and the network interface card. (See the topic under General Actions below.) In addition, if this is not a dedicated SQL Server system, look for other processes that meet the above criteria via <B>Process: % Privlieged Time </B>and<B> Process: % User Time.</B> If you find such processes eliminate them or schedule them to run at more convenient times.</P>
<H5 CLASS="h4"> </A>General Actions for Processor Tuning:</H5><P>     Excessive processing may indicate a need to further denormalize the database.</P>
<P>     Schedule CPU-intensive queries during off-peak hours.</P>
<P>     Investigate tuning the query to be less CPU-intensive (see query tuning).</P>
<P>     Boost the Microsoft SQL Server priority as previously discussed.</P>
<P>     Determine that no unnecessary processes are running on the SQL Server platform. If so, turn them off in order to see if this improves performance.</P>
<P>     Set Windows&nbsp;NT Tasking to "Foreground and Background Applications Equally Responsive."</P>
<P>     Assuming you have at least a 486-based server, part of your problem may be the network or disk adapter cards you have chosen. The 8-bit cards use more processor time than 16-bit or 32-bit cards. The number of bits here refers to the amount of data moved to memory from the adapter on each transfer. The most efficient cards use 32-bit transfers to adapter memory or direct memory access (DMA) to move their data. Adapters that don't use memory-mapped buffers or DMA must use processor instructions to move data, and that makes the processor busy. DMA uses the memory, and that can slow the processor down but it is still more efficient than individual instructions.</P>
<P>     Placing Tempdb in RAM may help by reducing I/O requests.</P>
<P>     Assuming that Microsoft SQL Server has sufficient memory to run (see memory tuning), increasing CPU power is the most effective hardware-related way to improve performance. You can add CPU power in two ways: using a faster CPU or adding additional CPUs.</P>
<P>     Faster CPU: When performance is important, you should consider using as fast a CPU as possible. In general, a faster CPU will probably realize a bigger performance gain over adding an additional CPU. This is because while adding CPUs provides additional power, the operating system and SQL Server (or any application) incur an overhead in managing the work performed by multiple CPUs. Of course, once you are running the fastest CPU available in your chosen architecture, you can add additional CPUs to increase performance.</P>
<P>     Additional CPUs: Windows&nbsp;NT supports symmetric multiprocessing (SMP). Since SQL Server is implemented using native Windows&nbsp;NT threads, it can automatically take advantage of multiple CPUs. SQL Server takes good advantage of SMP platforms, and you can boost performance significantly by moving your application to an SMP platform, or adding additional CPUs to an existing SMP platform.</P>
<H4> </A>Memory Tuning</H4><p>Memory tuning involves the detection of memory-constrained operations. The following memory bottleneck monitoring guidelines will aid in determining such problems.</P>
<H5 CLASS="h4"> </A>Symptoms and Actions:</H5><P>     <B>Symptom:</B> If the <B>SQLServer: Cache Hit Ratio</B> is less than 80% then memory may be a bottleneck.</P>
<P CLASS="lp1"><B>Action:</B> Either allocate more memory to Microsoft SQL Server or increase the amount of system memory.</P>
<P>     <B>Symptom:</B> If the <B>SQLServer: I/O - Lazy Writes/sec</B> counter indicates a great deal of activity over a long interval of time, then a memory bottleneck may be indicated. Typically this counter should be zero until the LRUthreshold (default 3%) is reached with respect to free buffer pages. However, frequent activity may indicate not enough memory is available for data page caching.</P>
<P CLASS="lp1"><B>Action:</B> Compare the <B>SQLServer: Cache - Number of Free Buffers</B> value against the LRUtheshold value. This value is derived by obtaining the total number of buffers allocated via the DBCC MEMUSAGE command and multiplying this value by the LRUthreshold percentage (default 0.03). If the number of free buffers is close to the derived value, then either allocate more memory to SQL Server or increase the amount of system memory.</P>
<P>     If <B>Memory: Page Faults/sec</B> is consistently high (other than during SQL Server initialization), then not enough memory is dedicated to Windows&nbsp;NT or possibly the system as a whole.</P>
<P CLASS="lp1"><B>Action:</B> Increase the system memory or increase the memory dedicated to Windows&nbsp;NT, by decreasing the memory allocated to SQL Server or other processes. Moreover, you may also eliminate noncritical processes as these also utilize memory resources.</P>
<P>     If <B>SQLServer: I/O - Page Reads/sec</B> is consistently high, it may indicate a memory bottleneck. Typically, if enough memory is available for database activities during normal operations, this counter will generally reach an equilibrium point. However, if this counter remains high over a long time interval, lack of sufficient memory may be causing excessive SQL Server page faults. This may be due to a less than adequate data cache, poor index design, or poor database design.</P>
<P CLASS="lp1"><B>Action:</B> Increase the memory allocated to SQL Server or decrease the procedure cache percentage, thereby increasing the data cache. If indexes are not being utilized, design intelligent indexes. If database tables are too wide, thus resulting in fewer data rows per data page, redesign the tables to be narrower.</P>
<P>     If <B>SQLServer: Cache - Ave. Free Page Scan</B> or <B>SQLServer: Cache - Max. Free Page Scan</B> are over 10, a memory bottleneck may be indicated due to excessive buffer scanning while searching for a free page.</P>
<P CLASS="lp1"><B>Action:</B> Increase the data cache size or the frequency of checkpoints. Checkpoints can be increased via the recovery interval value or by manual execution.</P>
<H5 CLASS="h4"> </A>General Actions for Memory Tuning:</H5><P>     Check the amount of memory dedicated to Microsoft SQL Server via the SQL Server configuration options. Follow the memory allocation guidelines previously discussed, increasing memory appropriately. Allocate at least 16 MB to Windows&nbsp;NT.</P>
<P>     Make sure the PAGEFILE.SYS file is of adequate size. However, it should not be growing in size, as this would indicate that virtual memory requirements are exceeding capacity. On a dedicated SQL Server system, there should be virtually no paging as long as Windows&nbsp;NT has been allotted sufficient memory; at least 16 MB.</P>
<P>     If you make extensive use of extended stored procedures, you should unload the DLL after execution via the DBCC <I>dllname</I>(FREE) command. This releases the memory used by the DLL.</P>
<H4> </A>Disk Subsystem Tuning</H4><p>Disk subsystem tuning involves the detection of disk I/O constrained operations. Such bottleneck constraints may be caused by the disk controller, the physical disk drives, or lack of some other resource that results in excessive disk I/O generating activity. Furthermore, poor disk subsystem performance may also be caused by poor index or database design. The goal is to operate the Microsoft SQL Server with as few physical I/Os and associated interrupts as possible. The following disk I/O bottleneck monitoring guidelines will aid in achieving this goal.</P>
<p><B>Note</B> In order to monitor low-level disk activity with respect to the <B>PhysicalDisk</B> Performance Monitor counters, it is necessary to enable the diskperf option. This can be accomplished by issuing the following command from the system prompt: <I>diskperf -y</I>. Running with this option enabled may result in a slight (0.1%–1.5%) degradation in performance. Hence, disable it when not required for use (<I>diskperf -n).</I></P>
<p>When performance tuning the SQL Server disk subsystem, you should first attempt to isolate the disk I/O bottleneck with the <B>SQLServer</B> counters, using the <B>PhysicalDisk</B> and <B>LogicalDisk</B> counters for more detailed monitoring and refinement of an action plan.</P>
<H5 CLASS="h4"> </A>Symptoms and Actions:</H5><P>     <B>Symptom:</B> If <B>SQLServer: I/O - Lazy Writes/sec</B> is active for extended intervals, this may indicate the disk subsystem is not adequate with respect to the current I/O demands. (Also see memory bottleneck symptoms.)</P>
<P CLASS="lp1"><B>Action:</B> Observing either <B>LogicalDisk: Disk Queue Length</B> or <B>PhysicalDisk: Disk Queue Length</B> can reveal significant disk congestion. Typically, a value over 2 indicates disk congestion. Increasing the number of disk drives or obtaining faster drives will help performance.</P>
<P>     <B>Symptom:</B> If <B>SQLServer: I/O Outstanding Reads</B> and/or <B>I/O Outstanding Writes</B> are high for extended intervals of time, the disk subsystem may be a bottleneck.</P>
<P CLASS="lp1"><B>Action:</B> Observing either <B>LogicalDisk: Disk Queue Length</B> or <B>PhysicalDisk: Disk Queue Length</B> can reveal significant disk congestion. Typically, a value over 2 indicates disk congestion. Increasing the number of disk drives or obtaining faster drives will help performance.</P>
<P>     <B>Symptom:</B> If <B>SQLServer: Log Writes/sec</B> seems to reach a maximum level, you may have encountered the maximum sequential write capability of the disk drives in the system. You will see this occur most frequently on systems that have a dedicated disk drive for logging. On systems without a dedicated log disk drive, you will observer a greater number of outstanding I/O requests as discussed previously.</P>
<P CLASS="lp1"><B>Action:</B> Obtaining faster disk drives or disk controllers will help to improve this value.</P>
<H5 CLASS="h4"> </A>General Actions for Disk I/O Tuning:</H5><P>     If you have a disk subsystem that supports asynchronous I/O (one that supports disk arrays and/or includes a smart SCSI controller), you may consider increasing the <B>max async io</B> option (default 8) in order to obtain higher throughput. In order to determine if higher throughput is gained, monitor <B>SQLServer: I/O - Batch Writes/sec</B> before the change to <B>max async io</B> and after the change. You should also notice an increase in the value of <B>SQLServer: I/O Transactions/sec.</B> This assumes the current physical disks are not experiencing I/O congestion. In addition, increasing the max async io value to high may result in excessive overhead.</P>
<P>     Install a faster disk and/or controller. Determine if the controller card does 8-bit, 16-bit, or 32-bit transfers. The more bits in the transfer operation, the faster the controller moves data. You may also want to choose a different drive technology such as IDE (Integrated Drive Electronic), which has a 2.5MB/s throughput; ESDI, which has a 3 MB/sec; SCSI-2, which has a 5MB/s throughput; or a Fast SCSI-2, which has a 10MB/sec throughput.</P>
<P>     Create mirrored data sets. The I/O system can issue concurrent reads to 2 partitions. The first portion of the read will be to partition A, while the next portion of the read will be to partition B. (Assuming the disk driver and controller can handle asynchronous I/O.)</P>
<P>     Create striped data sets. Multiple disks can process I/O requests concurrently (assuming the disk driver and controller can handle asynchronous I/O).</P>
<P>     Add memory to increase the data cache size, thereby decreasing physical page reads.</P>
<P>     Change to a different I/O bus architecture. EISA, MCA, and local bus (VESA or PCI) buses transfer data at a much higher rate than ISA buses. PCI is fast because it transfers data at 33 MHz, a double word at a time (33 MHz * 4 = 132 Mb/sec) where as ISA maximizes out at about 5 Mb/sec and EISA about 32 Mb/sec (EISA transfers at 8 MHz * 4 bytes). There has been talk about raising the PCI clock rate to 66 MHz (to get a 264 Mb/sec transfer rate) but most manufacturers are resisting the idea (at about 50 MHz or so, getting past FCC class B certification is a nightmare&mdash;the main reason Intel drops the 50-MHz 486 and goes with clock doubler).</P>
<P>     When choosing a I/O device such as a disk controller, consider the architecture of the card. For example here are some of the points to consider about each architecture:</P>
<P>     <B>PIO: </B>PIO (programmed I/O) requires intervention by the CPU.<B> </B>For example, the Adaptec 1522 is a PIO device and can do either 16-bit PIO or 32-bit PIO. However, CPU-usage is quite intensive (30%–40%) and it will slow down your system during a large transfer or a CD-ROM access. As such, most high-performance systems don't use PIO device because it adversely impacts system throughput. <I>BYTE</I> magazine did a comparison of Adaptec 2940 (PCI) against a Future Domain adapter (PIO). While the Future Domain and Adaptec 2940 provide almost identical benchmark results, the Future Domain consumes<B> </B>a hefty 40% of CPU time whereas the 2940 does not. However, all PIO devices are much cheaper to manufacture&mdash;the FD is about half the price of the 2940. A standard ATDISK disk (IDE drive) does PIO.</P>
<P>     <B>DMA: </B>ISA DMA has only 24 address lines so it can physically address 16 MB. However, if you happen to have 32 MB of RAM, the OS can see all of the memory. Therefore, if the OS wants to transfer a block of memory (which happens to be located at memory location above 16 MB, which the ISA DMA card, such as the Adaptec 1542C, cannot physically see), it will have to copy that block down to an area in the 0–15 MB range (where the Adaptec 1542c can see) so the 1542C can initiate the DMA transfer (double buffering). This copying down to 0–15 MB range and also copying up (16 MB and up) <B><I>takes quite a bit of time</I></B> (using Intel repsb, repsw, repsd) so that explains the slow down.<B> </B>However, you don't have that problem with either VL, PCI, or EISA as they all have 32-bit DMA address lines and can physically see up to 4 GB. PIO devices can see all of the memory, including those above 16 MB. The only problem is that it takes processor cycles to do any kind of data transfer.</P>
<P>     <B>Bus Master: </B>Bus master devices have their own intelligence and<B> </B>offload this work from the CPU.<B> </B>The CPU can resume doing its own work while the bus-master device is doing all the I/O.<B> </B>When it's done, it hands the result to the CPU.</P>
<P>     On a 2 SCSI disk daisy-chained system, the SCSI controller has more of an impact on your total performance than your disk drive. You would be better off buying a slower, cheaper disk and investing in a better SCSI controller. </P>
<P>     Choose a disk with a low seek time (the time required to move the disk drive's heads from one track of data to another). The ratio of time spent seeking to time spent transferring data is usually 10 to 1, and often much higher.<B> </B></P>
<P>     Distribute the workload as evenly as possible among different I/O systems and disk drives. This will allow you to take full advantage of the system's I/O bandwidth.</P>
<H4> </A>Network Tuning</H4><p>Network tuning with respect to Microsoft SQL Server performance is affected by the following:</P>
<P>     Throughput of the LAN or WAN.</P>
<P>     Throughput of the server's network interface card.</P>
<P>     Availability of resources on the server to service client requests.</P>
<p>Regarding the throughput of the LAN or WAN, this is beyond the scope of this paper and is not critical to the tuning of a specific SQL Server. However, when considering remote procedure calls between SQL Servers or data replication, LAN and/or WAN throughput will be an important concern. Thus, this section will deal with tuning issues related to the network interface card and system or SQL Server resources that affect the SQL Server's network performance. Accordingly, the following network bottleneck monitoring guidelines will deal with these issues.</P>
<H5 CLASS="h4"> </A>Symptoms and Actions:</H5><P>     <B>Symptom:</B> On a dedicated SQL Server system, if<B> SQLServer: Network Reads/sec</B> is substantially lower than <B>Server: Bytes Received/sec,</B> this may indicate network activity outside that generated by SQL Server. This may also be caused by periodic Windows&nbsp;NT Server administrative processes if the system also serves as a Primary Domain Controller or Backup Domain Controller.</P>
<P CLASS="lp1"><B>Action:</B> Determine if any processes or protocols extraneous to the operation of SQL Server are running. If so, eliminate them.</P>
<P>     <B>Symptom:</B> On a dedicated SQL Server system, if<B> SQLServer: Network Writes/sec</B> is substantially lower than <B>Server: Bytes Transmitted/sec,</B> this may indicate network activity outside that generated by SQL Server. This may also be caused by periodic Windows&nbsp;NT Server administrative processes if the system also serves as a Primary Domain Controller or Backup Domain Controller.</P>
<P CLASS="lp1"><B>Action:</B> Determine if any processes or protocols extraneous to the operation of SQL Server are running. If so, eliminate them.</P>
<P>     <B>Symptom:</B> If <B>SQLServer: Network Reads/sec</B> or <B>SQLServer: Network Writes/sec</B> is high, this indicates a great deal of network traffic.</P>
<P CLASS="lp1"><B>Action:</B> Look at the number of <B>SQLServer: User Connections</B> and the <B>SQLServer: Network Command Queue Length.</B> If these values are also high, especially <B>Network Command Queue Length,</B> then consider increasing the number of available worker threads via <B>sp_configure</B> and/or increase memory allocated to SQL Server.<B> </B>However, you may wish to restrict user connections via <B>sp_configure</B> in order to decrease the workload on the SQL Server. Remember, user connections and worker threads are counted as overhead against the SQL Server memory allocation. Thus, plan accordingly when adjusting these values.</P>
<H5 CLASS="h4"> </A>General Actions for Network Tuning:</H5><P>     Tabular data stream (TDS) is the application protocol used by Microsoft SQL Server for the transfer of requests and request results between clients and servers. TDS data is sent in fixed-size chunks, called packets. TDS packets have a default size of 512 bytes. If an application does bulk copy operations, or sends or receives large amounts of text or image data, a packet size larger than 512 bytes may improve network performance, since it results in fewer reads and writes. For large data transfers, a packet size between 4092 and 8192 is usually best. Any larger size packet may degrade performance.</P>
<P CLASS="lp1">An application can change the packet size by using the DB-Library <B>DBSETLOACKET()</B> call. The packet size may also be changed while using the BCP and ISQL utilities using the [<B>/a packetsize</B>] parameter. Increasing the packet size will only work for name pipes clients to SQL Server on Windows&nbsp;NT.</P>
<P CLASS="lp1">You can monitor the improvement in network read and write efficiency by viewing the <B>SQLServer: Network Reads/sec </B>and<B> SQLServer: Network Writes/sec</B> counters before and after changing the TDS packet size. Fewer reads and writes should occur after increasing the packet size.</P>
<P>     Make sure the server throughput is set to "Maximize Throughput for Network Applications"; this is the default for SQL Server. However, with this option set, user application access has priority over file cache access to memory (4 MB of memory is allocated to available memory for starting up and running local applications).</P>
<P>     Increase Netlogon service update notice periods on the SQL Server if your SQL Server is a Primary Domain Controller, as well as the server announcement period if you are concerned with the amount of maintenance traffic Windows&nbsp;NT Server is creating and the load on the primary domain controller.</P>

<TABLE COLS="4" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="89pt" VALIGN="TOP"><COL WIDTH="79pt" VALIGN="TOP"><COL WIDTH="85pt" VALIGN="TOP"><COL WIDTH="87pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>Value Name</B></P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>Default Value</B></P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>Minimum Value</B></P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>Maximum Value</B></P></TD>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>PulseConcurrency</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>20</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>1</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>500</P></TD>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Pulse</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>300 (5 minutes)</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>60 (1 minute)</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>3600 (1 hour)</P></TD>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Randomize</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>1 (1 second)</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>0 (0 seconds)</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>120 (2 minutes)</P></TD>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><P CLASS="lp1"><B>Pulse</B> defines the typical pulse frequency (in seconds).<B> </B>All SAM/LSA (User/Security account database) changes made within this time are collected together.<B> </B>After this time, a pulse is sent to each BDC needing the changes.<B> </B>No pulse is sent to a BDC that is up to date.</P>
<P CLASS="lp1"><B>PulseConcurrency</B> defines the maximum number of simultaneous pulses the PDC will send to BDCs.</P>
<P CLASS="lp1">Netlogon sends pulses to individual BDCs.<B> </B>The BDCs respond by asking for any database changes.<B> </B>To control the maximum load these responses place on the PDC, the PDC will only have PulseConcurrency pulses "pending" at once.<B> </B>The PDC should be sufficiently powerful to support this many concurrent replication RPC calls (related directly to Server service tuning as well as the amount of memory in the machine).</P>
<P CLASS="lp1">Increasing PulseConcurrency increases the load on the PDC.<B> </B>Decreasing PulseConcurrency increases the time it takes for a domain with a large number of BDCs to get a SAM/LSA change to all of the BDCs.<B> </B>Consider that the time to replicate a SAM/LSA change to all the BDCs in a domain will be greater than: (Randomize/2) * NumberOfBdcsInDomain) / PulseConcurrency</P>
<P>     If you need to transfer huge amounts of data between different computer systems, Ethernet may not be the appropriate medium to use;<B> </B>the basic Ethernet cable is limited to 10 MB per second (considerably less when you include network overhead).<B> </B>Other media are now available that offer significantly higher sustained transfer rates (FDDI, ATM, and so on).</P>
<P>     The Network Monitor (provided with Microsoft Systems Management Server) is a very good tool to use to monitor the general network performance. It offers additional Performance Monitor counters as well as a few unique statistics from within the application.</P>
<P>     Match the network interface card to the system bus. If you have a 16-bit bus, use a 16-bit network adapter; if you have a 32-bit bus, use a 32-bit network adapter. In addition, the card should be a bus-master card in order to minimize the processing overhead associated with network interrupts.</P>
<p>For more in-depth information concerning Microsoft SQL Server optimization and tuning, refer to Appendix A.</P></BODY></HTML>
