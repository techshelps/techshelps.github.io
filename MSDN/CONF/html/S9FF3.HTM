<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Code Behind Forms (CBF)</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>	<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>


	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<H2>Code Behind Forms (CBF)</H2><p>Microsoft&nbsp;Access version 2.0 has code modules that are scoped to particular forms or reports. We call this Code Behind Forms, or CBF. There are several advantages to placing CBF for application development in general, for Wizard development in particular. First, it reduces the likelihood of variable name conflicts. Second, it can improve overall performance. This is because all global Access Basic code is loaded into memory when Microsoft&nbsp;Access launches. On memory-constrained machines, this forces more swapping and hurts performance. CBF, on the other hand, isn't loaded into memory until the form is loaded and is discarded when the form is closed. Thus, users don't pay the performance penalty for the memory footprint of code that they aren't using. The downside to this strategy is that the Wizard takes slightly longer to load. This section gives you an overview of how CBF can be used in Wizard development. </P></BODY></HTML>
