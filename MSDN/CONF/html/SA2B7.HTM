<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Setting Up Client and Server Sockets</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>	<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>


	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<h3>Setting Up Client and Server Sockets</H3><p>Most Windows Sockets applications are asymmetrical; that is, there are generally two components to the network application&mdash;a client and a server. Frequently, these components are isolated into separate programs. Sometimes, these components are integrated into a single application (such as our sample application). When both the client and server components of a networking application are integrated, the application is generally referred to as a "peer" application. Both the client and the server components go through different procedures to ready themselves for networking by making a number of Windows Sockets API calls. The following state diagrams illustrate the state transitions for setting up client- and server-side socket applications:</P>
<P><img src="NT2132.gif"></P>
<P></P>
<P>Setting up a server-side stream-based application</P>
<P><img src="NT2133.gif"></P>
<P>Setting up a client-side stream socket-based application</P>
<p>The <I>socket()</I> call creates an endpoint for both client- and server-side application communication. When calling <I>socket()</I>, the application specifies the protocol family and either the socket type (stream or datagram), or the specific protocol which it expects to use (for example, TCP). Both the client- and server-side of a network application use the <I>socket() </I>call to define their respective endpoints. <I>socket()</I> returns a <I>socket descriptor</I>, an integer which uniquely identifies the socket created within Windows Sockets.</P>
<H4> </A>Server-side connection setup</H4><p>Once the socket is created, the server-side associates the freshly created socket descriptor and a <I>local endpoint address </I>via the <I>bind()</I> API. The local endpoint address is comprised of two pieces of data, the IP address and the port ID for the socket. The local IP address is used to determine which interfaces the server application will accept connection requests on; the port ID identifies the TCP or UDP port on which connections will be accepted. It is for these two values that the network byte-ordering routines (<I>htonl(), htons(),</I> etc.) were created. These values must always be represented in network byte order.</P>
<p>Alternatively, an application may substitute the value INADDR_ANY in place of a valid local IP address, and the system will accept incoming requests on any local interface, and will send requests on the "most appropriate" local interface. In fact, most server applications do exactly this. To associate a socket with any valid system port, provide a value of 0 for the .<I>sin_port</I> member of the <I>sockaddr_in</I> structure. This will select an unused system port between 1025 and 5000. As mentioned before, most server applications listen on a specified port, and client applications use this mechanism to obtain an unused local port. Once an application uses this mechanism to obtain a valid local port, it may call <I>getsockname()</I> to determine the port the system selected.</P>
<p>The <I>listen()</I> API sets up a connection queue. It accepts only two parameters, the socket descriptor and the queue length. The queue length identifies the number of outstanding connection requests that will be allowed to queue up on a particular port/address pair, before denying service to incoming connections.</P>
<p>The <I>accept()</I> API completes a stream-based server-side connection by accepting an incoming connection request, assigning a new socket to the connection, and returning the original socket to the <I>listen</I>ing state. The new socket is returned to the application, and the server can begin interacting with the client over the network.</P>
<H4> </A>Client-side connection setup</H4><p>From the client's perspective, the application also creates a socket using the <I>socket() </I>call. The <I>bind() </I>command is used to bind the socket to a locally specified endpoint address which the server will use to transmit data back to the client. Once a local endpoint association is made, the <I>connect()</I> API establishes a connection with a remote endpoint. This routine initiates the network connection between the two systems. Once the connection is made, the client can begin interaction with the server on the network.</P>
<p>Although the client may choose to call <B>bind()</B>, it is not necessary to do so. Calling <B>connect()</B> with an unbound socket will simply force the system to choose an IP interface and unique port ID and mark the socket as bound. Most client-side applications neglect the <B>bind()</B> call as there are rarely specific requirements for a particular local interface/port ID pair<I>. </I></P>
<p>The following code fragments create and connect a pair of stream-based sockets using the API flow outlined above:</P>
<H4> </A>Server-side (connection-oriented)</H4><P CLASS="spacing"><BR></P>
<pre><FONT FACE="Courier New" SIZE="3">#define            SERVICE_PORT        5001

SOCKET             srv_sock,        cli_sock;
struct sockaddr_in        srv_addr,        cli_addr;
char             buf[MAX_BUF_LEN];

/* Create the server-side socket */

srv_sock=socket(AF_INET,SOCK_STREAM,0);
if (srv_sock==INVALID_SOCKET){
    sprintf(buf,"Windows Sockets error %d: Couldn't create socket.",
         WSAGetLastError());
    MessageBox (hWnd,buf,"Windows Sockets Error",MB_OK);
    shutdown_app();
}

srv_addr.sin_family=AF_INET;
srv_addr.sin_addr.s_addr=INADDR_ANY;
srv_addr.sin_port=SERVICE_PORT;        /* specific port for server to listen on */

/* Bind socket to the appropriate port and interface (INADDR_ANY) */

if (bind(srv_sock,(LPSOCKADDR)&amp;srv_addr,sizeof(srv_addr))==SOCKET_ERROR){
    sprintf(buf,"Windows Sockets error %d: Couldn't bind socket.",
         WSAGetLastError());
    MessageBox (hWnd,buf,"Windows Sockets Error",MB_OK);    
    shutdown_app();
}

/* Listen for incoming connections */

if (listen(srv_sock,1)==SOCKET_ERROR){

    sprintf(buf,"Windows Sockets error %d: Couldn't set up listen on socket.",
         WSAGetLastError());
    MessageBox (hWnd,buf,"Windows Sockets Error",MB_OK);
    shutdown_app();
}

/* Accept and service incoming connection requests indefinitely */

for ( ; ; ) {
    cli_sock=accept(srv_sock,(LPSOCKADDR)&amp;cli_addr,&amp;addr_len);
    if (cli_sock==INVALID SOCKET){
    
        sprintf(buf,"Windows Sockets error %d: Couldn't accept incoming \
             connection on socket.",WSAGetLastError());
        MessageBox (hWnd,buf,"Windows Sockets Error",MB_OK);    
        shutdown_app();
    }
    .
    /* Client-server network interaction takes place here */
    .
    closesocket(cli_sock);
}</font></pre>
<H4> </A>Client-side (connection-oriented)</H4><P CLASS="spacing"><BR></P>
<pre><FONT FACE="Courier New" SIZE="3">/* Static IP address for remote server for example. In reality, this would be    
   specified as a hostname or IP address by the user */

#define    SERVER        "131.107.1.121"        

struct     sockaddr_in    srv_addr,cli_addr;
LPSERVENT            srv_info;
LPHOSTENT            host_info;
SOCKET            cli_sock;
.
/* Set up client socket */

cli_sock=socket(PF_INET,SOCK_STREAM,0);

if (cli_sock==INVALID_SOCKET){
    
    sprintf(buf,"Windows Sockets error %d: Couldn't create socket.",
         WSAGetLastError());
    MessageBox (hWnd,buf,"Windows Sockets Error",MB_OK);
    shutdown_app();
}

cli_addr.sin_family=AF_INET;
cli_addr.sin_addr.s_addr=INADDR_ANY;        
cli_addr.sin_port=0;                /* no specific port req'd */

/* Bind client socket to any local interface and port */

if (bind(cli_sock,(LPSOCKADDR)&amp;cli_addr,sizeof(cli_addr))==SOCKET_ERROR){
    
    sprintf(buf,"Windows Sockets error %d: Couldn't bind socket.",
         WSAGetLastError());
    MessageBox (hWnd,buf,"Windows Sockets Error",MB_OK);
    shutdown_app();
}

/* Get the remote port ID to connect to for FTP service */

srv_info=getservbyname("ftp","tcp");

if (srv_info== NULL) {

    sprintf(buf,"Windows Sockets error %d: Couldn't resolve FTP service port.",
         WSAGetLastError());
    MessageBox (hWnd,buf,"Windows Sockets Error",MB_OK);
    shutdown_app();
}

srv_addr.sin_family = AF_INET;
srv_addr.sin_addr.s_addr = inet_addr(SERVER); 
srv_addr.sin_port=srv_info-&gt;s_port;

/* Connect to FTP server at address SERVER */

if (connect(cli_sock,(LPSOCKADDR)&amp;srv_addr,sizeof(srv_addr))==SOCKET_ERROR){

    sprintf(buf,"Windows Sockets error %d: Couldn't connect socket.",
         WSAGetLastError());
    MessageBox (hWnd,buf,"Windows Sockets Error",MB_OK);
    shutdown_app();
}
/* Client-server network interaction takes place here */</font></pre>
<p>Although the above fragment makes use of the <B>bind()</B> API, it would be just as effective to skip over this call as there are no specific local port ID requirements for this client. The only advantage that <B>bind() </B>offers is the accessibility of the port which the system chose via the <B>.sin_port</B> member of the <B>cli_addr</B> structure which will be set upon success of the <B>bind()</B> call.</P>
<p>For connectionless, or "datagram" sockets, Windows Sockets usage is a little simpler. Since the communication in datagram sockets is connectionless, it is not necessary to use the APIs necessary for creating a connection, namely: <I>connect()</I>, <I>listen()</I>, and <I>accept(). </I>The flow of Windows Sockets APIs that a typical connectionless client-server pair will generally traverse follows:</P>
<P><img src="NT2134.gif"></P>
<P>Setting up a server-side datagram-based application</P>
<P><img src="NT2135.gif"></P>
<P>Setting up a client-side stream-based application</P>
<p>As pictured above, a client may choose to <I>connect()</I> the datagram socket for convenience of multiple sends to the remote endpoint. Connecting a datagram socket will cause all sends to go to the connected address, and any datagrams received from a remote address different than the connected address are discarded by the system. Generally, connectionless clients use the <I>sendto()</I> API to transmit application data. The <I>sendto()</I> call requires that the destination's endpoint address be specified with every call to the API. By <I>connect</I>ing a datagram socket, a client sending a large amount of data to the same destination can simply use the <I>send()</I> API to transmit, without having to specify a remote endpoint with every call, and the client need not concern itself with the possibility of receiving unwanted data from other hosts. Depending on the type of application you are developing, and the Windows Sockets implementation below your application, <I>connect</I>ing datagram sockets may improve performance of your application.</P>
<p>Some sample code illustrates how the TFTP protocol (a connectionless protocol for file transfer) client and server might be implemented over Windows Sockets:</P>
<H4>Server-side (connectionless)</H4><P CLASS="spacing"><BR></P>
<pre><FONT FACE="Courier New" SIZE="3">SOCKET             srv_sock;
struct sockaddr_in        srv_addr;

.
.
/* Create server socket for connectionless service */

srv_sock=socket(PF_INET,SOCK_DGRAM,0);

if (srv_sock==INVALID_SOCKET){

    sprintf(buf,"Windows Sockets error %d: Couldn't create socket.",
         WSAGetLastError());
    MessageBox (hWnd,buf,"Windows Sockets Error",MB_OK);
    shutdown_app();
}

/* Resolve TFTP service port to listen on */

srv_info=getservbyname("tftpd","udp");

if (srv_info== NULL) {

    sprintf(buf,"Windows Sockets error %d: Couldn't resolve TFTPd service port.",
         WSAGetLastError());
    MessageBox (hWnd,buf,"Windows Sockets Error",MB_OK);
    shutdown_app();
}

srv_addr.sin_family = AF_INET;
srv_addr.sin_addr.s_addr = INADDR_ANY;   /* Allow the server to accept connections                         /* over any interface */
srv_addr.sin_port=srv_info-&gt;s_port;

/* Bind remote server's address and port */

if (bind(srv_sock,(LPSOCKADDR)&amp;srv_addr,sizeof(srv_addr))==SOCKET_ERROR){
    
    sprintf(buf,"Windows Sockets error %d: Couldn't bind socket.",
         WSAGetLastError());
    MessageBox (hWnd,buf,"Windows Sockets Error",MB_OK);
    shutdown_app();
}

/* Client-server network interaction takes place here */
</font></pre>
<H4> </A>Client-side (connectionless)</H4><P CLASS="spacing"><BR></P>
<pre><FONT FACE="Courier New" SIZE="3">/* Static IP address for remote server for example. In reality, this would be    
   specified as a hostname or IP address by the user */

#define    SERVER        "131.107.1.121"        

struct sockaddr_in        srv_addr,cli_addr;
LPSERVENT            srv_info;
LPHOSTENT            host_info;
SOCKET            cli_sock;

.
.
/* Create client-side datagram socket */

cli_sock=socket(PF_INET,SOCK_DGRAM);
if (cli_sock==INVALID_SOCKET){
    
    sprintf(buf,"Windows Sockets error %d: Couldn't create socket.",
         WSAGetLastError());
    MessageBox (hWnd,buf,"Windows Sockets Error",MB_OK);
    shutdown_app();
}

cli_addr.sin_family=AF_INET;
cli_addr.sin_addr.s_addr=INADDR_ANY;        
cli_addr.sin_port=0;                /* no specific local port req'd */

/* Bind local socket */
if (bind(cli_sock,(LPSOCKADDR)&amp;cli_addr,sizeof(cli_addr))==SOCKET_ERROR){
    
    sprintf(buf,"Windows Sockets error %d: Couldn't bind socket.",
         WSAGetLastError());
    MessageBox (hWnd,buf,"Windows Sockets Error",MB_OK);
    shutdown_app();
}

/* Resolve port information for TFTP service */

srv_info=getservbyname("tftp","udp");
if (srv_info== NULL) {

    sprintf(buf,"Windows Sockets error %d: Couldn't resolve TFTP service port.",
         WSAGetLastError());
    MessageBox (hWnd,buf,"Windows Sockets Error",MB_OK);
    shutdown_app();
}

srv_addr.sin_family = AF_INET;
srv_addr.sin_addr.s_addr = inet_addr(SERVER);
srv_addr.sin_port=srv_info-&gt;s_port;

if (connect(cli_sock,(LPSOCKADDR)&amp;srv_addr,sizeof(srv_addr))==SOCKET_ERROR){
    sprintf(buf,"Windows Sockets error %d: Couldn't connect socket.",
         WSAGetLastError());
    MessageBox (hWnd,buf,"Windows Sockets Error",MB_OK);
    shutdown_app();
}
/* Client-server network interaction takes place here */</font></pre>
<p>Since a connectionless client (such as TFTP) will undoubtedly be doing successive transmissions with the server (especially during long transfers), we have chosen to connect the socket, allowing the use of the <B>send()</B> and <B>recv()</B> APIs rather than <B>sendto()</B> and <B>recvfrom()</B>. The use of <B>connect()</B> with datagram sockets is purely optional.</P></BODY></HTML>
