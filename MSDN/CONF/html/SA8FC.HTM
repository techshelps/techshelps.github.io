<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Threading Models</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>	<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>


	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<h3>Threading Models</H3><p>For a client application, the chosen threading model typically does not have a significant effect on performance. However, services that handle tens or hundreds or remote users need to select carefully the threading model they use because a poor choice can lead to poor performance.</P>
<p>The simplest thread model is a single process with a single thread that handles all the connected clients, typically using the <B>select()</B> API to multiplex between the clients. A single loop calls <B>select()</B> repeatedly, calling <B>send()</B>, <B>recv(), </B>or <B>accept()</B> when the <B>select()</B> call indicates that an action can be performed on one of the sockets. While simple to implement, the performance of services using this model can suffer because every network I/O call passes through <B>select()</B> which incurs significant CPU overhead for each I/O. This is acceptable when CPU use is not an issue, but presents a problem when the service requires high performance.</P>
<p>The next most complicated model is a single thread for each client. Every time a client connects, the service calls <B>CreateThread()</B> to create a thread which handles the client for the duration of the connection. This model can achieve very high performance when the number of connected clients is small, but at around 40 clients the thread context switching and resource overhead begins to present a significant burden for the system. </P>
<p>A similar model to thread per client is process per client. In process per client, an entire new process is created using <B>CreateProcess()</B> for each client that connects. This is the model typically used in UNIX Daemons. This model is discouraged for Windows&nbsp;NT and Windows '95 because processes are much more expensive than threads, both in terms of resources used and in the CPU overhead of context switching.</P>
<p>The most efficient threading models use a <I>worker thread</I> pool. In this model, a pool of threads services all the connected clients. In worker thread models, the service will usually use overlapped I/O with the Win32&reg; <B>WriteFile() </B>and <B>ReadFile()</B> APIs to facilitate multiplexing and minimize the number of threads required by the service. In Windows&nbsp;NT 3.5, I/O completion ports may be used for additional efficiency. While this threading model is the most efficient for large numbers of clients, it is also the most complex. Therefore, it should only be used where it is required to have high performance with large numbers of connected clients.</P></BODY></HTML>
