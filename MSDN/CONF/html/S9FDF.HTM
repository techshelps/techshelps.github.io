<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>On ODBC data use find-only on indexed fields, otherwise open a new cursor</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>	<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>


	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<h3>On ODBC data use find-only on indexed fields, otherwise open a new cursor</H3><p>The Find methods are useful for moving to a record that meets a specific criteria within a recordset. A common trap when converting code to work with an ODBC database is to try to replace Seek method calls with Find method calls. As a general rule, this code will be slow. </P>
<p>When trying to find an individual record, the best approach is to create a new recordset with a WHERE clause that contains the Find criteria. This will return all records that match the criteria. Because this is a single operation on the server, this will be as efficient as possible. It may be necessary to change forms or other visual elements to use this approach, but this is generally preferable - especially when large tables are involved.</P>
<H4> </A>Find with dynasets</H4><p>If your program can't be modified to avoid using Find methods, then understanding exactly how they work will help you make the best use of them. Find will be fairly efficient if the following two criteria are met:</P>
<P><ul><li>    the search criteria is a match against a single column which is indexed on the server, and</P>
<P><li>    the search expression is either testing for equality or uses LIKE.</P></ul>
<p>Jet recognizes the above cases and executes a query on the server that returns primary keys for all the records that match the search criteria. If matching records are found, it then moves through the keys it has stored for the recordset until it finds a match. If the local recordset is reasonably sized (say less than 500 rows), this is a relatively quick operation.</P>
<p>One result of the above strategy is that <I>unsuccessful</I> Finds will be as fast as the server allows. This isn't something you'll be able to take advantage of in all scenarios(!), but it may be useful in some.</P>
<p>An example of a reasonably efficient use of Find is if you want to match a <B>lastname</B> in a set of records (assuming lastname was indexed on the server):</P>
<P CLASS="spacing"><BR></P>
<pre><FONT FACE="Courier New" SIZE="3">RS.FindFirst "lastname = ""Smith"""
RS.FindFirst "lastname Like ""Smith*"""</font></pre>
<H4> </A>Find with snapshots</H4><p>Find methods will also be reasonably efficient if:</P>
<P><ul><li>    the recordset is a snapshot-type recordset, and</P>
<P><li>    the number of records in the snapshot is reasonable (say &lt; 500, depending on the speed of your Microsoft Windows&reg; TEMP directory and memory available for buffering).</P></ul>
<p>In the above case, the Find criteria are resolved by searching the data which has already been downloaded into the snapshot on the local machine. Of course, if the snapshot is not yet fully populated, that time to fetch data will be added to the search time. This means that Finds that fail will be slow if all the records will have to be fetched, unlike the dynaset case above where no further fetching will be done if the Find fails.</P>
<H4> </A>Slow find</H4><p>Find methods will usually be slow if:</P>
<P><ul><li>    the recordset is a dynaset-type recordset on an ODBC data source, and</P>
<P><li>    the number of records in the recordset is more than, say, one hundred, and</P>
<P><li>    the Find criteria do not match the restrictions given previously.</P></ul>
<p>The algorithm used to resolve the criteria in this case is to fetch each record and see if the criteria match until a match is found or all records have been examined.</P>
<p>At the risk of stating the obvious, don't be tempted to avoid using Find methods and code the equivalent loop in Basic! That is guaranteed to be the slowest technique of all.</P></BODY></HTML>
