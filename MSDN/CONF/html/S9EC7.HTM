<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using DCOM Security</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>	<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>


	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<H2>Using DCOM Security</H2><p>DCOM can make distributed applications secure without any security specific coding or design in either the client or the component. Just like the DCOM programming model hides a component's location, it also hides the security requirements of a component. The same (preexisting or off-the-shelf) binary code that works in a single-machine environment, where security may be of no concern, can be used in a distributed environment in a secure fashion.</P>
<p>For more information about DCOM in general, see the <I>DCOM Technical Overview</I> and <I>DCOM Architecture</I> white papers. This section will try to summarize how DCOM security features are layered on the Windows SSPI.</P>
<p>There are two distinguishable categories of security provided by Distributed COM. The first form is termed <B><I>Activation Security</I></B>, and it controls which objects a client is allowed to instantiate. The second form is <B><I>Call Security</I></B>, which dictates how security operates at the per-call level between an established connection from a client to an object (server). Activation security controls which classes a client is allowed to launch and retrieve objects from.</P>
<p>DCOM provides two mechanisms to secure calls. The first mechanism DCOM provides is APIs and interfaces that applications may use to perform their own security checking. The second mechanism is done automatically by the DCOM infrastructure. An important item to note is the automatic mechanism does security checking for the process, not for individual objects or methods. </P>
<p>Since DCOM security is layered on secure RPC, there are frequent references to constants defined for RPC-level interfaces. The section below on <I>Using Secure RPC</I> shows how the RPC constants map to SSPI security provider features.</P>
<H3> </A>Client Security</H3><p>In a typical scenario, the client queries an existing object for IClientSecurity, which is implemented locally by the interface remoting layer. The client uses IClientSecurity to control the security of individual interface proxies on the object prior to making a call on one of the interfaces.</P>
<p>An example illustrating a specific use of the IClientSecurity interface would be to ensure the integrity and privacy of a credit card transaction; you may want to utilize the IClientSecurity interface to escalate the RPC authentication level to include packet encryption (RPC_C_AUTHN_LEVEL_PKT_INTEGRITY).</P>
<p>Although DCOM provides default security levels for authentication, the client requests additional features using IClientSecurity::SetBlanket to define the security level required. The definition of IClientSecurity::SetBlanket is shown below.</P>
<P CLASS="spacing"><BR></P>
<pre><FONT FACE="Courier New" SIZE="3">HRESULT IClientSecurity::SetBlanket(pProxy, dwAuthnSvc,
   dwAuthzSvc, pServerPrincName, dwAuthnLevel, 
   dwImpLevel, pAuthInfo, dwCapabilities );</font></pre>
<p>This method sets the authentication information that will be used to make calls on the specified proxy. The values specified here override the values chosen by automatic security. Calling this method changes the security values for all other users of the specified proxy.</P>
<p>The arguments for IClientSecurity::SetBlanket are the following:</P>
<p></P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="134pt" VALIGN="TOP"><COL WIDTH="134pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>Argument</B></P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>Type</B></P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>Description</B></P></TD>

</TR><TR><TD VALIGN="TOP">
<FONT FACE="Verdana, Arial" SIZE=2><P>
pProxy</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>void*</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>This parameter indicates the proxy to set.</P></TD>

</TR><TR><TD VALIGN="TOP">
<FONT FACE="Verdana, Arial" SIZE=2><P>
dwAuthnSvc</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>DWORD</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>A single value from the list of RPC_C_AUTHN constants indicating the authentication<I> </I>service to use. It may be RPC_C_AUTHN_NONE if no authentication is required.</P></TD>

</TR><TR><TD VALIGN="TOP">
<FONT FACE="Verdana, Arial" SIZE=2><P>
dwAuthzSvc</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>DWORD</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>A single value from the list of RPC_C_AUTHZ constants indicating the authorization<I> </I>service to use. If you are using the Windows&nbsp;NT authentication service, use RPC_C_AUTHZ_NONE.</P></TD>

</TR><TR><TD VALIGN="TOP">
<FONT FACE="Verdana, Arial" SIZE=2><P>
pServerPrincName</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>WCHAR*</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Indicates the server principal name to use with the authentication service. If you are using RPC_C_AUTHN_WINNT, the principal name will be ignored.</P></TD>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>Argument</B></P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>Type</B></P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>Description</B></P></TD>

</TR><TR><TD VALIGN="TOP">
<FONT FACE="Verdana, Arial" SIZE=2><P>
dwAuthnLevel</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>DWORD</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>A single value from the list of RPC_C_AUTHN_LEVEL constants indicating the authentication level to use.</P></TD>

</TR><TR><TD VALIGN="TOP">
<FONT FACE="Verdana, Arial" SIZE=2><P>
dwImpLevel</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>DWORD</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>A single value from the list of RPC_C_IMP constants indicating the impersonation level to use. Currently, only RPC_C_IMP_LEVEL_IMPERSONATE is supported.</P></TD>

</TR><TR><TD VALIGN="TOP">
<FONT FACE="Verdana, Arial" SIZE=2><P>
pAuthInfo</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>RPC_AUTH_IDENTITY_HANDLE*</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Establishes the identity of the client. It is authentication service specific. Some authentication services allow the application to pass in a different user name and password. COM keeps a pointer to the memory passed in until COM is uninitialized or a new value is set. If NULL is specified COM uses the current identity (whether it is the process token or impersonation token).</P></TD>

</TR><TR><TD VALIGN="TOP">
<FONT FACE="Verdana, Arial" SIZE=2><P>
dwCapabilities</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>DWORD</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Flags to establish indicating the further capabilities of this proxy. Currently, no capability flags are defined.</P></TD>

</TR><TR><TD VALIGN="TOP">
<FONT FACE="Verdana, Arial" SIZE=2><P>
<I>Returns</I></P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>S_OK</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Success.</P></TD>

</TR><TR><TD VALIGN="TOP">
<FONT FACE="Verdana, Arial" SIZE=2><P>
E_INVALIDARG</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>One or more arguments is invalid.</P></TD>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P></P></TD>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><p>By default DCOM will choose the first available authentication service and authorization service available on both the client and server machines and the principal name which the server registered for that authentication service. Currently, DCOM will not try another authentication service if the first fails.</P>
<p>The arguments allow the client application to select a specific authentication service and authentication level. The available values for these arguments are shown below in Table 1: RPC Authentication Service Identifiers and Table 2: RPC Authentication Levels and SSP Services. The default Windows&nbsp;NT authentication service uses the NTLM security support provider. Future versions of Windows&nbsp;NT will make available additional authentication services based on Kerberos and SSL.</P>
<H3> </A>Server Security</H3><p>When a call arrives at the server, the server may call CoGetCallContext to retrieve a IServerSecurity interface which allows the server to check the client's authentication and to impersonate the client, if needed. The IServerSecurity object is valid for the duration of the call. CoInitializeSecurity allows the client to establish default call security for the process, avoiding the use of IClientSecurity on individual proxies. CoInitializeSecurity allows a server to register automatic authentication services for the process. </P>
<p>The IServerSecurity interface is used by a server to help identify the client and is also used to impersonate the client during a call. By calling IServerSecurity::ImpersonateClient, the server can impersonate a client for the duration of the call. One should note that CoImpersonateClient is a helper function that calls CoCallGetContext in order to retrieve an IServerSecurity interface pointer and then it calls IServerSecurity::ImpersonateClient. </P>
<p>The IServerSecurity::ImpersonateClient maps through the RPC run time layer to the SSPI call ImpersonateSecurityContext.</P>
<UL><LI>HRESULT IServerSecurity::ImpersonateClient();</LI></UL><p>This method allows a server to impersonate a client for the duration of a call. The server may impersonate the client on any secure call at the identify, impersonate, or delegate level. At the identify level, the server may only find out the clients name and perform ACL checks; it may not access system objects as the client. At delegate level the server may make off machine calls while impersonating the client. The impersonation information only lasts until the end of the current method call. At that time IServerSecurity::RevertToSelf will automatically be called, if necessary.</P>
<UL><LI>HRESULT IServerSecurity::RevertToSelf();</LI></UL><p>This method restores the authentication information on a thread to the process's identity.</P>
<p>The server may impersonate the client on any secure call at the identify, impersonate, or delegate level. At the identify level, the server may only find out the clients name and perform Access Control List (ACL) verification; it may not access system objects as the client. At the delegate level the server may make service calls on behalf of the client to servers on different machines. The impersonation information only lasts until the end of the current method call. At that time IServerSecurity::RevertToSelf will automatically be called if necessary.</P>
<p>The following helper routines are available to support DCOM server impersonation.</P>
<UL><LI><B>HRESULT CoImpersonateClient();</B></LI></UL><p>Allows the server to impersonate the client of the current call for the duration of the call. This function will fail unless the object is being called with RPC_C_IMP_LEVEL_IMPERSONATE or higher impersonation in effect. This function encapsulates the following sequence of common calls (error handling excluded):</P>
<P CLASS="spacing"><BR></P>
<pre><FONT FACE="Courier New" SIZE="3">    CoGetCallContext(IID_IServerSecurity, (void**)&amp;pss);
    pss-&gt;ImpersonateClient();
    pss-&gt;Release();
</font></pre>
<UL><LI><B>HRESULT CoRevertToSelf();</B></LI></UL><p>Restores the authentication information on a thread of execution to its previous identity. This function encapsulates the following sequence of common calls (error handling excluded):</P>
<P CLASS="spacing"><BR></P>
<pre><FONT FACE="Courier New" SIZE="3">    CoGetCallContext(IID_IServerSecurity, (void**)&amp;pss);
    pss-&gt;RevertToSelf();
    pss-&gt;Release();</font></pre>
<H3>DCOM Secure Sample</H3><p>The Win32 SDK contains a sample program that demonstrates the use of DCOM call security features. (The location of the DCOM secure example program in the Win32 SDK is c:\mstools\samples\ole\dcom\secure.) The SECURE sample consists of a client portion and a server portion. The purpose of the sample is to demonstrate client-side and server-side security features.</P>
<p>The server application, SECSVR.EXE, demonstrates the packaging options available to server writers and the call-security capabilities. It implements the following server capabilities:</P>
<UL><LI>A free-threaded server implemented as a service. The application implements the class "LocalService" (CLSID_SecureObjectService).</LI><LI>A free-threaded server implemented as a standard executable. The application implements the class "LocalServer32" (CLSID_SecureObject).</LI><LI>An apartment-threaded server implemented as a standard executable. The application implements the class "LocalServer32" (CLSID_SecureObject).</LI></UL><p>The client application, SECCLNT.EXE, allows you to select security settings for the client application's connections to the server application.</P>
<p>DCOM uses the authentication, authorization, and message integrity capabilities of authenticated RPC. The next section looks at secure RPC services, and the APIs available to integrate security features at that level.</P></BODY></HTML>
