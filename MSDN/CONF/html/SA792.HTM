<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Programming with OLE Controls</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>	<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>


	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<h3>Programming with OLE Controls</H3><p>Programming an OLE control is very easy. You just use its events, properties, and methods as with any other control or object in Microsoft Access. The Calendar Sample control in Microsoft Access is an example of using the Calendar control. It fires the various methods of the control via a command button and works with the control's events.</P>
<p>There are a few points to keep in mind when working with OLE controls. First, the syntax to get to a control's methods and properties is a bit different. You need to say: "Forms!MyForm!Embedded0.Object.Method" where "Embedded0" is the name of the unbound object frame that contains the control. For example:</P>
<P CLASS="spacing"><BR></P>
<pre><FONT FACE="Courier New" SIZE="3">    Forms![Calendar Sample].Embedded0.Object.NextMethod
    Forms![Calendar Sample].Embedded0.Object.Value</font></pre>
<p>You can get around this by declaring a variable of type Object and setting it to the unbound object frame's Object property. Then you can use a shorter, more Visual Basic–like syntax. For example:</P>
<P CLASS="spacing"><BR></P>
<pre><FONT FACE="Courier New" SIZE="3">    Dim Foo As Object
    Set Foo = Forms![Calendar Sample].Embedded0.Objec
    Foo.NextMethod
    Foo.Value</font></pre>
<p>This limitation is not part of the OLE Control architecture; it's only part of the Microsoft Access implementation.</P>
<p>The second point is that even though Microsoft Access 2.0 and the OLE Control architecture don't currently support data-bound controls, you can simulate data binding if the control supports BeforeUpdate and AfterUpdate–type events on its Value property. The sample form shows how this can work by binding the value of the Calendar control to that of an unbound text box.</P>
<p>In the BeforeUpdate event for the Calendar, we can check the new date and reject that date if desired.</P>
<P CLASS="spacing"><BR></P>
<pre><FONT FACE="Courier New" SIZE="3">Sub CalendarFrame_BeforeUpdate (Cancel As Integer)
'Only allow dates after 1992. This allows us to demonstrate 
'the "data binding"-like stuff you can do with BeforeUpdate &amp;
'AfterUpdate
If (Calendar.Value &lt;= #12/31/92#) Then
    MsgBox "Only allowed dates after 12/31/92"
    Cancel = 1
End If
End Sub</font></pre>
<p>During the AfterUpdate event we set the unbound text box to the same value as the Calendar.</P>
<P CLASS="spacing"><BR></P>
<pre><FONT FACE="Courier New" SIZE="3">Sub CalendarFrame_AfterUpdate ()
'Update unbound field with value of Calendar control
Me!CalDate = Calendar.Value
End Sub</font></pre></BODY></HTML>
