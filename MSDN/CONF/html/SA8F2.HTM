<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Addressing</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>	<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>


	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<h3>Addressing</H3><p>The most obvious difference between different transport protocols is the way in which each uses transport addresses, or "sockaddrs" in Windows Sockets terms. Virtually all transport protocols expose different address formats to applications, the one exception being NetBIOS protocols which all use the same address format.</P>
<p>A number of Windows Sockets APIs take sockaddrs as input or output parameters, including <B>bind(), ccept(), sendto(), recvfrom(), getsockname(), </B>and <B>getpeername(). </B>For all these APIs a sockaddr is really two arguments: a pointer to the sockaddfr structure itself and a length integer which gives the number of bytes in the sockaddr. For many transport protocols the length of a sockaddr is always the same, but sockaddr lengths may differ between transport protocols. For example, a TCP/IP sockaddr has 16 bytes and an IPX/SPX sockaddr has 14 bytes.</P>
<p>The format of sockaddr structures used by a transport protocol is specified in the <I>af</I> or "address family" argument to the <B>socket()</B> API. All TCP/IP sockets (including both TCP and UDP sockets) are opened with the AF_INET address family, while IPX/SPX sockets are opened with AF_IPX. Other transport protocols use different address family values as defined in the header file <I>winsock.h</I>.</P>
<p>It is up to an application to fill in a sockaddr when <B>bind()</B>ing to a local address or <B>connect()</B>ing to a remote address, and also to interpret the sockaddrs returned from the <B>accept()</B>, <B>sendto(), recvfrom, getpeername(), </B>and <B>getsockname()</B> APIs.</P></BODY></HTML>
