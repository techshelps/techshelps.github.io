<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Section 2: Upsizing a Transaction Processing Application</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>	<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>


	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<h3>Section 2: Upsizing a Transaction Processing Application</H3><p>In order to provide a simple, clear example of upsizing an application, we chose to use the existing sample application that ships with Access version 2.0: Northwind Traders. The forms and code will be altered to highlight some of the concepts outlined above.</P>
<p>Included in the sample database will be a report document that outlines the changes made to the application, and the location of the form, query, or code that has changed.</P>
<p>Although Microsoft SQL Server for Windows&nbsp;NT&trade; version 4.2 is used for this exercise, the methodology employed applies to the majority of other popular client-server RDBMSs.</P>
<H4>Migrating Microsoft&nbsp;Access Tables to Database Servers</H4><p>A high level summary of steps involved in migrating from a file server to a client/server environment include:</P>
<OL><LI>Create the server database.</LI>
<LI>Establish your ODBC data source using the ODBC Administrator.</LI>
<LI>Document your existing Microsoft&nbsp;Access database.</LI>
<LI>Export each table to the server database, using the Export choice of Microsoft&nbsp;Access version 2.0's File menu.</LI>
<LI>Add the indexes to the server tables with the necessary attributes.</LI>
<LI>Add server based data integrity constraints.</LI>
<LI>Attach to the server tables using the Microsoft&nbsp;Access attach facility.</LI></OL>
<p>At this point your application can behave similarly to when it was a file server application, however, it will probably not behave optimally. The remainder of this section is intended to explain the above steps in more detail and help you optimize your Microsoft&nbsp;Access applications for client/server computing. </P>
<p>To ensure your Microsoft&nbsp;Access applications scale up easily to a relational database, certain practices are recommended:</P>
<UL><LI>Do not embed spaces in your table names because most servers cannot support them. During export, Jet will replace spaces with underscores in the name but then your code references will fail.</P>
<LI>Create an <I>alias</I> query if you have applications with embedded spaces. ; An alias query is a query saved as the original table name, including spaces, but points to the server table without spaces. You can also alias column names using the convention "Field Name: FIELD_NAME" in the query result column field.</P>
<LI>Be consistent in the use of the case of your object names. Access default behavior is case insensitivity.</P>
<LI>Do not use the <B>Recordset </B>type of table to manipulate remote objects, always use the <B>Dynaset</B> type instead.</P></UL>
<H4>Establishing Your ODBC Data Source</H4><p>You use the ODBC Administrator application, which is now a component of Windows' Control Panel, to establish the ODBC data source. You must own the appropriate ODBC driver for your database server. Install ODBC drivers in a manner similar to that for other Windows&reg; drivers. ODBC drivers available are registered in ODBCINST.INI. They appear in the Add Data Source dialog box that appears when you click the Add button of the Data Sources dialog box opened when launching the ODBC Administrator. Process details of adding ODBC data sources are documented in the <I>Microsoft&nbsp;Access Advanced Topic</I> manual, as well as in on-line help.</P>
<H4>Documenting Your Existing Microsoft&nbsp;Access Database</H4><p>Indexes, business rules (domain integrity enforcement), default values, and referential integrity rules are not created when you export tables to a client/server database or use bulk-copy operations. You need to add the indexes, rules, and default values after creating new server tables. If permissions vary for users of the database, you'll need this information, too. You can print a very comprehensive list of the properties of the tables in your .MDB file with Microsoft&nbsp;Access version 2.0's Database Documentor.</P>
<H4>Exporting Microsoft&nbsp;Access Tables to the Server Database</H4><p>Creating the structure of a complex, multi-table, client/server database can be a tedious and time-consuming process. Microsoft&nbsp;Access version 2.0's table export capability can speed this process greatly. To do so, export each table to the server database, using the Export facility of Microsoft&nbsp;Access version 2.0's File menu. </P>
<p>There are trade-offs to consider when exporting data. When exporting data using Microsoft&nbsp;Access, the Jet engine exports each row, one at a time. This ensures that your exported data adheres to all the server-based rules, but is significantly slower with very large tables than using server-based, bulk-copy routines.</P>
<p>If your tables contain a few thousand records or less, it is usually faster to export the tables from the Microsoft&nbsp;Access database to the server database, rather than using bulk-copy programs (BCP for SQL Server) with text files. </P>
<p>Most migrations to client/server operation are done in two phases; test and production. You can limit the number of records used for the test phase by writing the appropriate SELECT * INTO <I>tblServer</I> FROM <I>tblMSA</I> WHERE <I>criteria</I> ORDER BY <I>keyfield(s)</I> statement. </P>
<p>If you intend to use BCP or the equivalent to load the tables, you can save time and assure data type and field size consistency by exporting Microsoft&nbsp;Access tables containing at least one record to the server.</P>
<H4>Adding Server-based Integrity Constraints</H4><p>You can use the database document you generated earlier to create the default values, domain integrity, and referential integrity constraints in your server. </P>
<p>Note that Microsoft&nbsp;Access version 2.0 has declarative referential integrity implemented in the Jet engine using the SQL-92 reserved words CONSTRAINT, REFERENCES, PRIMARY KEY, and FOREIGN KEY to implement the enforcement process.</P>
<p>If you are migrating a Microsoft&nbsp;Access version 1.1 application that uses attached tables, it is likely that your application includes macros or Access Basic code to enforce referential integrity. One of the primary canons of relational database design is: Rules are enforced by the database, not by applications.</P>
<p>Client/server RDBMSs not supporting the preceding SQL reserved words for enforcing referential integrity require you to create <I>triggers</I> to enforce referential integrity. A trigger is a piece of code residing on the server, similar to a rule, that executes a SQL statement prior to the occurrence of a specified event, such as INSERT, DELETE, or UPDATE. The general syntax of SQL Server's CREATE TRIGGER statement is:</P>
<P>
<pre><FONT FACE="Courier New" SIZE="3">CREATE TRIGGER [<I>owner, </I>]<I>trigger_name</I><BR>     ON [<I>owner, </I>]<I>table_name</I><BR>     [FOR {INSERT|UPDATE|DELETE}] AS<BR>          <I>sql_statement</I></font></pre>
<P><B>Adding Default Values and Enforcing Domain and Referential Integrity</B></P>
<p>Most client/server RDBMSs provide a default value property. Otherwise, you need to use stored procedures, similar to the preceding example to set default values for fields whose value is not supplied during the append process. You can specify NOT NULL to emulate the <B>Required</B> property of fields in Microsoft&nbsp;Access tables. If the server database does not support ANSI SQL's reserved words, you'll need to create rules to enforce domain integrity, and write stored procedures to enforce referential integrity and perform cascading updates and deletions. None of the rules and stored procedures you create will be visible to Jet; if your applications violate the rules, your application will receive an error message from the server.</P>
<H4>Adding Indexes</H4><p>Add the indexes to the server tables with the necessary attributes (e.g., PrimaryKey, No Duplicates, No Nulls) identical to those employed by the Microsoft&nbsp;Access database. Jet cannot update a table that does not have a unique index.</P>
<p>The Jet engine in Microsoft&nbsp;Access version 2.0 has significantly enhanced <B>Dynaset</B> that now support server-based, primary key generation from triggers. In earlier versions, as the primary key was generated during an insert, the <B>Dynaset</B> cursor would think the record has been deleted since it is no longer was in the same location. Jet now re-fetches the record, keeping the <B>Dynaset</B> up to date.</P>
<p>This is particularly significant because many developers use the convenient Counter field to generate their primary keys. The equivalent of Microsoft&nbsp;Access's Counter field data type seldom is found in client/server RDBMSs, yet is critical in functionality to your application.</P>
<p>Now you can create an INSERT trigger that increments the integer value of the Counter field each time a new record is appended to the table. The Transact-SQL statement to create the equivalent of a Counter is:</P>
<P>
<pre><FONT FACE="Courier New" SIZE="3">    CREATE TRIGGER add_customer_id ON dbo.customers<BR>    FOR INSERT AS <BR>_    UPDATE dbo.customers<BR>    SET inserted.Customer_ID = (SELECT MAX(Customer_ID)<BR>    FROM dbo.customers) + 1<BR>    WHERE dbo.customers.customer_ID IS NULL</font></pre>
<p>Note that when you use a trigger to create the Counter field equivalent, you will not see the Counter field's value in a bound control until you complete the appending process for the record.</P>
<H4>Attaching to Server Tables</H4><p>The easiest and most obvious way to attach tables is to use the File/Attach command from the database container menu. When you attach a table, Jet creates a local image of the table structure and stores it in the system tables. This enables the user to build queries, forms, and reports as if the tables were local to their machine.</P>
<p>After attaching, relationships between tables need to be established using the new relationships editor found in the DB Container's Edit/Relationships menu. This establishes the default join conditions and types while building new queries.</P>
<P><B>Automating the Attachment Process</B></P>
<p>There are cases where it is desirable to create relationships from a module to automate the attachment process. This is useful if the database is not found; the user can be prompted to locate where the back end resides, and then automatically reattach it through code. This is also useful if server-table structures change and you need all the clients to reattach.</P>
<p>The general form of the code for Microsoft&nbsp;Access version 2.0's new <B>CreateTableDef()</B> method, that attaches tables from ODBC data sources is:</P>
<P>
<pre><FONT FACE="Courier New" SIZE="3">strConnect = "ODBC; DSN=str<I>DataSourceName</I>;UID=str<I>UserID</I>; <BR>    PWD=str<I>Password</I>; DATABASE=str<I>DbName</I>"<BR>Set tdf<I>Name</I> = dbCurrent.CreateTableDef(str<I>TableName,<BR>    </I>int<I>Attributes, strSourceTable, str</I>Connect)<BR>db<I>Current</I>.TableDefs.Append tdf<I>Name</I></font></pre>
<P><B>Renaming Attached Tables</B></P>
<p>As Jet attaches to a remote table, it prefixes the default table owner ID of SQL Server to each table name when you attach the table. (The period separator between the owner ID and the table name is replaced by an underscore, because periods in table names are not permitted by Microsoft&nbsp;Access.) Thus, the names of attached tables do not correspond to the original table names in your .MDB file. The simple fix however is to simply rename your tables after attaching back their original name.</P>
<P><B>Remote Tables in Design Mode</B></P>
<p>Any operation in datasheet view that is permissible for a native Microsoft&nbsp;Access table is applicable to tables attached by ODBC. In design mode, you can set the values of the <B>Format</B>, <B>InputMask</B>, and <B>Caption</B> properties in table design view. All other properties of attached tables are read-only.</P>
<H4>Conclusion</H4><p>As mentioned earlier, a separate report document will be included in the sample database to relate the specific optimization techniques mentioned previously, with particular code segments and design structures in the Northwind Traders' application.</P></BODY></HTML>
