<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using Secure WinSock</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>	<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>


	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<H2>Using Secure WinSock</H2><p>WinSock 2.0 extends the Windows Socket interface to allow the underlying transport provider to expose security features that may be built into the provider. It is conceivable that a TCP/IP provider could use SSPI to encapsulate security functionality such that it can be invoked by a WinSock application. This will be very similar to how RPC encapsulates this functionality and all the application needs to do is to <B>request</B> it! Note that such a provider does not currently exist for Windows&nbsp;NT 4.0. Microsoft is implementing a WinSock 2.0 provider for SSL 3.0 which will be available soon. A general purpose SSPI-TCP/IP transport provider is not currently implemented, but Microsoft will make one available in a future release.</P>
<p>Using the TCP/IP and SSL security provider as an example, all that an application needs to do to use SSPI services is the following:</P>
<UL><LI>Enumerate the available transport providers</LI><LI>Create a socket in which to use the transport, and initialize the necessary callback functions</LI><LI>Initialize the SSL security provider options using WSAIoctl calls</LI><LI>Connect to the server</LI></UL><p>The following example is taken from the Microsoft Internet Security Schannel examples. The example below shows how to use SSL 3.0 and a TCP/IP provider from WinSock 2.0.</P>
<P CLASS="spacing"><BR></P>
<pre><FONT FACE="Courier New" SIZE="3">//
// Initialize the WinSock 2 subsystem.
//

err = WSAStartup(MAKEWORD(2,2), &amp;WsaData);
if(err != 0)
{
 printf("**** Error initializing WinSock!\n");
 return;
}

//
// Choose a WinSock 2 provider that supports both TCP/IP and the
// chosen security scheme.
//
cProtocols = WSAEnumProtocols(NULL,
        NULL,
        &amp;cbProtocolBuffer);
if(cProtocols == SOCKET_ERROR &amp;&amp; WSAGetLastError() != WSAENOBUFS)
{
 printf("**** Error %d during WSAEnumProtocols\n", WSAGetLastError());
 return;
}

// Allocate memory
pProtocolBuffer = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, cbProtocolBuffer);
if(pProtocolBuffer == NULL) return FALSE;

// Read array of WSAPROTOCOL_INFO structures.
cProtocols = WSAEnumProtocols(NULL,
        pProtocolBuffer,
        &amp;cbProtocolBuffer);
if(cProtocols == SOCKET_ERROR)
{
 LocalFree(pProtocolBuffer);
 return;
}
// Search for SSL protocol
for(i = 0, fFound = FALSE ; i &lt; cProtocols ; i++)
{
 if(pProtocolBuffer[i].iProtocol == IPPROTO_TCP &amp;&amp;
  pProtocolBuffer[i].iSecurityScheme == SECURITY_PROTOCOL_SSL)
 {
  *pProtocolInfo = pProtocolBuffer[i];
  fFound = TRUE;
  break;
 }
}
if(!fFound)
{
 LocalFree(pProtocolBuffer);
 return;
}

// Free memory
LocalFree(pProtocolBuffer);
</font></pre>
<p>Once we have selected the WinSock provider of choice, we can go ahead and create a socket and initialize security on it.</P>
<P CLASS="spacing"><BR></P>
<pre><FONT FACE="Courier New" SIZE="3">//
 // Create socket
 //

 Socket = WSASocket(FROM_PROTOCOL_INFO,  // address family
      FROM_PROTOCOL_INFO,  // type
      FROM_PROTOCOL_INFO,  // protocol
      pProtocolInfo,   // protocol info
      0,      // group
      0);      // flags
 if(Socket == INVALID_SOCKET)
 {
  printf("**** Error creating socket!\n");
  return FALSE;
 }
 else
 {
  *pSocket = Socket;
 }

 //
 // Set the socket's SSL flags.
 //

 {
  DWORD dwFlags;

  dwFlags = SSL_FLAG_ENABLE;

  err = WSAIoctl(Socket,
      SO_SSL_SET_FLAGS,
      (LPVOID)&amp;dwFlags,
      sizeof(dwFlags),
      NULL,     // output buffer
      0,      // output buffer size
      NULL,     // # bytes returned
      NULL,     // overlapped structure
      NULL);     // completion routine
  if(err == SOCKET_ERROR)
  {
   printf("**** Error setting SSL flags!\n");
   return FALSE;
  }
 }

//
// Set the socket's SSL client parameters.
//

{
 SSLCLIENTOPTS SslClientOpts;
 DWORD cbBytesRead;

 // Read the default client parameters.
 err = WSAIoctl(Socket,     // socket
     SO_SSL_GET_CLIENT_OPTS, // dwIoControlCode
     NULL,     // lpvInBuffer
     0,      // cbInBuffer
     (LPVOID)&amp;SslClientOpts, // lpvOutBuffer
     sizeof(SslClientOpts), // cbOutBuffer
     &amp;cbBytesRead,   // lpcbBytesReturned
     NULL,     // lpOverlapped
     NULL);     // lpCompletionRoutine
 if(err == SOCKET_ERROR)
 {
  printf("**** Error reading default client options!\n");
  return FALSE;
 }

 // Set the session cache timeout period to 10 minutes. Leave
 // everything else at the default value.
 SslClientOpts.CacheTimeout = 600;

 // Set the client parameters.
 err = WSAIoctl(Socket,     // socket
     SO_SSL_SET_CLIENT_OPTS, // dwIoControlCode
     (LPVOID)&amp;SslClientOpts, // lpvInBuffer
     sizeof(SslClientOpts), // cbInBuffer
     NULL,     // lpvOutBuffer
     0,      // cbOutBuffer
     NULL,     // lpcbBytesReturned
     NULL,     // lpOverlapped
     NULL);     // lpCompletionRoutine
 if(err == SOCKET_ERROR)
 {
  printf("**** Error setting client options!\n");
  return FALSE;
 }
}

//
// We could additionally set up authentication call back functions, etc.
// using WSAIoctl API, depending on what else may be involved in setting
// up a secure socket.
//</font></pre>
<P>Note: The code above is for demonstration purposes only, no such WinSock provider is currently available from Microsoft.</P>
<p>Once the socket is set up, the application can use WSAConnect API to connect to the server and the underlying provider will use the socket security settings to authenticate the connection using an appropriate security package, and so forth. From then on, all the communication can occur transparent of any message signing and sealing that may be done by the provider via SSPI.</P></BODY></HTML>
