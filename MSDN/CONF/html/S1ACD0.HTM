<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OLE Document Objects Specification</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>	<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>



	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<H1>OLE Document Objects Specification</H1><P CLASS="byl"><I>OLE Design Team and Office Design Team</I></P>
<p>Version 1.0</P>
<P CLASS="date">November 27, 1995</P>
<P CLASS="nt"><B>Note:</B> This document is an early release of the final specification. It is meant to specify and accompany software that is still in development. Some of the information in this documentation may be inaccurate or may not be an accurate representation of the functionality of the final specification or software. Microsoft assumes no responsibility for any damages that might occur either directly or indirectly from these inaccuracies. Microsoft may have trademarks, copyrights, patents or pending patent applications, or other intellectual property rights covering subject matter in this document. The furnishing of this document does not give you a license to these trademarks, copyrights, patents, or other intellectual property rights.</P>
<H2 CLASS="h3"> </A>Contents:</H2><p><A name="#sec1"></A></P>
<p><A href="#sec2">Feature Description</A></P>
<p><A href="#sec3">A General Overview of Document Objects</A></P>
<p><A href="#sec5">Architectural Details of Document Objects</A></P>
<ul><li><A href="#sec6">Overview</A></LI><li><A href="#sec7">Relevant Objects and the Interfaces They Must Implement</A></LI><li><A href="#sec13">Help Menu Merging: An Extension to OLE Documents</A></LI><li><A href="#sec14">Programmatic Printing (IPrint and IContinueCallback)</A></LI><li><A href="#sec15">Command Targets</A></LI></UL></SPAN><p><A href="#sec16">Implementation Notes</A></P>
<ul><li><A href="#sec17">Becoming a DocObject Server</A></LI><li><A href="#sec24">Becoming a DocObject Container</A></LI></UL></SPAN><p><A href="#sec30">Document Objects Interface Reference</A></P>
<ul><li><A href="#sec31">The IOleDocument Interface</A></LI><li><A href="#sec35">The IEnumOleDocumentViews Interface</A></LI><li><A href="#sec40">The IOleDocumentSite Interface</A></LI><li><A href="#sec42">The IOleDocumentView Interface</A></LI><li><A href="#sec56">The IPrint Interface</A></LI><li><A href="#sec63">The IContinueCallback Interface</A></LI><li><A href="#sec66">The IOleCommandTarget Interface</A></LI></UL></SPAN><p><A href="#sec79">Appendix: Office Binder Issues</A></P>
<a name="#sec1"></a><H2> Introduction</H2><p>The software industry has entered an era in which customers rely on many products to complete their work. For example, when a new company creates its business plan, it may rely on Microsoft Word to create the basic proposal, Microsoft Excel to create a summary of projected financial performance, and Microsoft PowerPoint to create a slide show for potential investors. Although customers rely on several distinct products to complete their projects, they think of each project as a single entity: a business plan, a sales proposal, a book, and so forth.</P>
<p>Microsoft Office for Windows 95 introduced a new application called the Office Binder that makes it easier for customers to complete projects that contain heterogeneous documents (that is, a variety of documents created by many distinct applications). And it makes it easy for them to use the standard Office applications as they do so. It may be helpful to think of the Binder as an electronic paper clip: It holds together text files, spreadsheets, graphics presentations, and other documents so that the user can manipulate them as a single entity. From another perspective, the Binder is a sophisticated "viewer" that can host a variety of heterogeneous documents which let the user create, edit, save, print, and view distinctly different kinds of information.</P>
<p>"Document Objects" (DocObjects for short) is the core technology that makes Office Binder work. While originally developed as a proprietary technology for Office, Microsoft believes that DocObjects represent an important step forward and will benefit customers in many more ways than just Office and Office-Compatible applications. Most notably, the technology is flexible enough to support document containers other than the Office Binder, and can support document servers other than just Office and Office-Compatible applications.</P>
<p>One obvious application for this technology is within the domain of "Internet browsers", where the adoption of Binder technology will not only facilitate the presentation of Internet-based information (Web pages and so forth) but will, at the same time with the same implementation, enable the browser to present documents from Office and Office-Compatible applications. In short, the user need only go to one navigation tool to browse and view all documents whether local or network-based.</P>
<p>This specification explains the Document Objects architecture in terms of the container and the server side of the technology.</P>
<P CLASS="nt"><B>Note:</B> This specification has been written from the perspective of an advanced OLE programmer. For additional information about OLE issues discussed below, please consult the <I>OLE Programmer's Reference</I> and related publications.</P>
<a name="#sec2"></a><H2>Feature Description</H2><p>The following picture illustrates the Office 95 Binder, which for the purposes of this document serves merely as an illustration of a "document container."</P>
<p><img src="60107.gif"></P>
<p>As this illustration shows, the Binder includes two primary panes, as do most containers.  The left pane shows thumbnails that correspond to the section of the Binder.  For example, the preceding Binder contains a Word document, a PowerPoint slide show, and an Excel spreadsheet.  Users can click these images to activate the corresponding "document object" or "DocObject."  The right pane of the Binder shows the Word document on which the user is currently working. In an "Explorer" type of container, the left pane would display a hierarchical tree list of a drive or network while the right pane would display the available document or page in that point of the hierarchy.</P>
<p>When a document is "activated" in the right hand pane, it looks and acts, for all intents and purposes, as if the user was running the stand-alone application that normally manages that particular document type, complete with toolbars, menus, and all other user interface elements.  A container like Office Binder thus provides a single frame in which to work with documents, instead of forcing the user to multiple application frames for each document type.  (This is also different than working with embeddings in a compound document where only a single piece of content is being activated; here we are activating an entire document, that is, an entire application, within the context of a single frame).</P>
<p>While the Document Objects technology allows an application like Office Binder to present literally a "three-ring binder" paradigm, DocObjects is generic enough to accommodate many other possible user interfaces that have the same requirements.</P>
<a name="#sec3"></a><H2>A General Overview of Document Objects</H2><p>The DocObjects technology is a set of extensions to OLE Documents, the compound document technology of OLE. The extensions are in the form of additional interfaces that allow what mostly looks like an embeddable in-place object to represent an entire document instead of a single piece of embedded content. As with OLE Documents, DocObjects involve a container that provides the display space for DocObjects and servers that provide the user interface and manipulation capabilities for DocObjects themselves.</P>
<p>A DocObject server is a product that supports one or more document object classes, where each object itself supports the extension interfaces that allow the object to be activated in a suitable container, such as Binder. A DocObject is best understood by distinguishing it from a standard OLE embedded object. Following the OLE convention, an embedded object is one which is displayed within the "page" of the document that "owns it" where the document is managed by an OLE container. The container stores the embedded object's data with the rest of the document.</P>
<p>However, embedded objects are limited because they do not control the page on which they appear. By necessity they tend to be rather small objects: a picture that supplements the surrounding text (provided by the container), a spreadsheet that clarifies its supporting analysis (again provided by the container), and so forth.</P>
<p>By contrast, a document object provided from a DocObject server is essentially a full-scale, conventional document which is embedded as an object within another DocObject container (Binder, browsers, etc.). Unlike embedded objects, DocObjects have complete control over their pages, and the full power of the application is available to the user to edit them. Thus, unlike embedded objects, DocObjects tend to be full-scale, robust documents that exploit the complete native functionality of the server (application) that creates them. Users can create documents (called sections within the Binder, for example) using the full horsepower of their favorite applications (if they are DocObject-enabled), yet they can treat the resulting project as a single entity, which can be uniquely named, saved, and transmitted to co-workers for review or editing, printed as a single entity. In the same way, a user of an Internet browser (such as a future version of Internet Explorer) can treat the entire network as well as local file systems as a single document-storage entity with the ability to browse the documents in that storage from a single location.</P>
<h3> </A>Summary of Requirements for Document Object Participation</H3><p>A DocObject container that wishes to integrate DocObjects must:</P>
<OL>Be capable of handling object storage through the <B>IPersistStorage </B>interface, that is, it must provide an <B>IStorage</B><I> </I>instance to each DocObject.</LI><LI CLASS="OLI1">Support the basic embedding features of OLE Documents, necessitating "site" objects (one per document or embedding) that implements <B>IOleClientSite </B>and <B>IAdviseSink.</B></LI><LI CLASS="OLI1">Support in-place activation of embedded objects or DocObjects, requiring the container's site objects to implement <B>IOleInPlaceSite</B> and requiring the container's frame object to provide <B>IOleInPlaceFrame</B>.</LI><LI CLASS="OLI1">Support the DocObjects extensions through the implementation of <B>IOleDocumentSite </B>and possibly <B>IContinueCallback</B> on the site object, along with <B>IOleCommandTarget</B><I> </I>on the frame object.</LI></OL></SPAN><p>(Note that OLE Documents support in a container implies more than just interface implementations. It also requires knowledge of using the interfaces of an embedded object. The same applies to DocObjects extensions where the container must also know how to use those extension interfaces on the DocObjects themselves.)</P>
<p>Correspondingly, a "document object" that wishes to work within a DocObject container must:</P>
<OL>Use OLE's Compound Files as their storage mechanism, that is, implement <B>IPersistStorage</B>.</LI><LI CLASS="OLI1">Support the basic embedding features of OLE Documents, including "Create From File."  This necessitates the interfaces <B>IPersistFile</B>, <B>IOleObject</B>, and <B>IDataObject</B>.</LI><LI CLASS="OLI1">Support the in-place activation extension of OLE Documents, that is, <B>IOleInPlaceObject </B>and <B>IOleInPlaceActiveObject</B> (using the container's <B>IOleInPlaceSite </B>and <B>IOleInPlaceFrame</B> interfaces).</LI><LI CLASS="OLI1">Support the DocObjects extensions that involve these new interfaces: <B>IOleDocument</B>, <B>IOleDocumentView</B>, <B>IOleCommandTarget,</B> and <B>IPrint</B>.</LI></OL></SPAN><p>Again, knowledge of when and how to use the container-side interfaces is implied in these requirements.</P>
<p>The remainder of this document will describe the architecture of Document Objects and how the new interfaces of <B>IOleDocument</B>, <B>IEnumOleDocumentViews</B><I>,</I><B> IOleDocumentView</B>, <B>IOleDocumentSite</B>, <B>IPrint</B>, <B>IContinueCallback</B><I>, </I>and <B>IOleCommandTarget</B> work together to achieve the document-activation features described earlier. First will be the architectural details of Document Objects including special requirements for Help menu merging (an extension to OLE Documents), programmatic printing, and "command targets." This is followed by implementation notes for DocObject containers and servers, and then by the complete interface reference and an appendix describing additional details of the Office Binder's implementation of this architecture.</P>
<a name="#sec5"></a><H2>Architectural Details of Document Objects</H2><a name="#sec6"></a><h3>Overview</H3><p>In general, a particular product owns a set of data, the storage in which they are saved, and the views through which they are displayed for the user. OLE Documents introduced technology that let applications store their documents (including data and information about the way they should be displayed) in an abstract manner. That is, the application was freed from the need to understand the granular aspects of its storage vehicle, and could, instead, deal with a variety of storage sites in a consistent fashion (that is, without regard for their underlying properties). Products that exploited this OLE "abstract storage technology," could save their documents into files, databases, and other types of storage in a uniform way. In addition, OLE enabled applications (via <B>IPersist*</B> interfaces) to permanently save their documents in storage that they did not own. Thus, applications that support OLE can treat storage abstractly.</P>
<p>The OLE Documents architecture also took an important step toward letting applications treat their views (that is, the port through which their data are displayed for the user) abstractly. Products that supported in-place activation could display their content in a "foreign" frame that they did not own. While this represented an important step forward, it had its limitations. In particular, in-place activation supports an object view of the data rather than a document view. That is, the OLE container is responsible for siting the object's view port, for controlling the overall display of its pages, for printing them, and so forth. To overcome some of these limitations, the embedded object can be opened so that more of the native functionality of its parent (that is, the OLE server) can be used. Nevertheless, some important limitations remained.</P>
<p>Among these limitations, it is worth noting that a defining characteristic of a document, as distinguished from an embedded object, is that it owns the printed page. It can have headers, footers, footnotes, endnotes, revision marks, and so forth, and it knows where to place them on the page and how to display them for the user. Embedded objects (that is, object views) do not control the page on which they appear. Instead, they must live within a containment hierarchy whose root container is an actual document.</P>
<p>The Document Objects architecture defines an abstraction for <I>views </I>and their management, so that objects can function within containers and yet retain control over their display and some important printing functions. This architecture makes it possible to display documents both in foreign frames (such as Binder or Explorer) and in native frames (such as the product's own view ports).</P>
<p>A view can be divided into two components: the view frame component and the view component. The view frame may consist of just the frame window in the case of an Single Document Interface (SDI) product, or it may include the frame and the Multiple Document Interface (MDI) window in the case of an MDI product. The view frame component provides the space for menus, toolbars, a status bar, and so forth. The frame component also provides the view port within which adornments such as rulers, scroll bars, and similar tools can be displayed. Note that the frame does not "tell" the document how big it should be, nor does it care. On the contrary, it merely conveys to the contained application the view port size that was selected by the user. The view port, by contrast, is the region within which the data are displayed. If the frame were an SDI frame, for example, then the view port could be the client area of the frame window minus the space allocated for tool bars, status bar, and such. In an MDI setting, the view port would be the client area of the MDI document window minus any other frame level user interface elements (for example, space for tab bar in case of workbook).</P>
<p>This breakdown of components offers several advantages:</P>
<ul><li>The view frame can be of any type: SDI, MDI, Workbook, Form, and so forth. A single implementation of the document's view can be used within many different types of <I> </I>frames.</LI><li>Multiple applications can have the same frame level UI and functionality, while supporting distinctly different data sets. In principle, this offers a great advantage to vendors who wish to develop a core user interface as a frame that is used throughout their entire product line. In essence, they can build the frame once and re-use it as appropriate.</LI></UL></SPAN><p>Special attention should be given to the fact that the view and storage aspects of a data set are two entirely orthogonal aspects of the document to which they belong. The storage provider and the view frame provider could be the same, or they could be different. In any case, the application can proceed with its work in a standard manner that isolates it from the need to understand either its storage or its view port in specific detail. In some sense, this separation of views and storage is present within OLE, since when an embedded object is "open edited", the server application provides the view frame while its container provides the storage. However, the Document Objects architecture takes matters much further, since it lets the document's storage container (or some other container) provide the view frame. In addition, moniker binders can also provide view frames, and this can enable in-place activation of links.</P>
<a name="#sec7"></a><h3>Relevant Objects and the Interfaces They Must Implement</H3><p>A DocObject can<I> </I>support one or more views, each of which is capable of in-place activation. The document component of the object must not only support standard OLE Document interfaces, but also must support new interfaces such as <B>IOleDocument</B>. The view component must additionally support certain standard OLE interfaces (<B>IOleInPlaceObject</B><I> </I>and<B> IOleInPlaceActiveObject</B>), and in addition it must support the new <B>IOleDocumentView</B> interface, too<I>.</I> DocObject containers must implement <B>IOleDocumentSite</B><I> </I>along with OLE container interfaces, and they must implement <B>IOleInPlaceSite</B><I> </I>on each view site. Finally, the frame object, the view object(s), and the container object can optionally implement <B>IOleCommandTarget</B> to support the dispatch of certain commands (as discussed below). </P>
<p>View and container objects can also optionally implement <B>IPrint</B><I> </I>and <B>IContinueCallback </B>(discussed below), to support programmatic printing.</P>
<p>The following illustration shows the conceptual relationships between a container and its components (on the left) and the DocObject and its views (on the right), where the DocObject manages storage and data and the view displays and possibly prints that data. Interfaces in bold are those required for DocObject participation; those bold and italic are optional. All others are required according to OLE Document rules.</P>
<p><img src="60108.gif"></P>
<p>Note that a document that supports only a single view can implement both the view and document components (that is, their corresponding interfaces) on a single concrete class. In addition, a container site that only supports one view at a time can combine the document site and the view site into a single concrete site class. The container's frame object, however, must remain distinct, and the container's document component is merely shown here to complete the OLE Documents architecture. This piece of the container is not affected by the Document Objects architecture.</P>
<p>A DocObject is one that has some data and one or more views associated with it. The Document Objects architecture formalizes the relationship between the document, its views, and their view sites/frames<I>.</I></P>
<H4> </A>Document Objects (Server)</H4><p>The DocObject owns a set of data and has access to storage where the data can be saved and retrieved. It can create and manage one or more views on its data. In addition to supporting the usual embedding and in-place activation interfaces according to OLE Documents, the DocObject communicates its ability to create views through <B>IOleDocument</B>. Through this interface the container can ask to create (and possibly enumerate) the views that the DocObject can display. Through this interface, the DocObject can also provide miscellaneous information about itself, such as whether it supports multiple views or complex rectangles.</P>

<pre><FONT FACE="Courier New" SIZE="3">interface IOleDocument : IUnknown
    {
    HRESULT CreateView([in] IOleInPlaceSite *pIPSite, [in] IStream *pstm<BR>        , [in] DWORD dwReserved, [out] IOleDocumentView **ppView);
    HRESULT GetDocMiscStatus([out] DWORD *pdwStatus);
    HRESULT EnumViews([out] IEnumOleDocumentViews **ppEnum<BR>        , [out] IOleDocumentView **ppView);
    }</font></pre>
<p>Every DocObject must have a view frame provider with this interface. If the document is not embedded within a container, then the DocObject server itself must provide the view frame. However, when the DocObject is embedded in a DocObject container then the container provides the view frame.</P>
<p>The <B>IEnumOleDocumentViews</B><I> </I>interface is a standard OLE enumerator for <B>IOleDocumentView *</B> types.</P>
<H4> </A>Views Objects (Server)</H4><p>A DocObject can create one or more types of views, for example, normal, outline, page layout) of its data. From a functional perspective, views act like filters through which the data can be seen.</P>
<p>Even if the document has only one type of view, it may still wish to support multiple views as a means of supporting "Window/New Window" functionality (for example, the Window menu in Office applications). Functionally these views are like ports onto a particular method for displaying the data.</P>
<p>To be represented within the DocObject container, a view component must support <B>IOleInPlaceObject</B><I> </I>and <B>IOleInPlaceActiveObject</B><I> </I>in addition to <B>IOleDocumentView</B>:</P>

<pre><FONT FACE="Courier New" SIZE="3">interface IOleDocumentView : IUnknown
    {
    HRESULT SetInPlaceSite([in] IOleInPlaceSite *pIPSite);
    HRESULT GetInPlaceSite([out] IOleInPlaceSite **ppIPSite);
    HRESULT GetDocument([out] IUnknown **ppunk);
    [input_sync] HRESULT SetRect([in] LPRECT prcView);
    HRESULT GetRect([in] LPRECT prcView);
    [input_sync] HRESULT SetRectComplex([in] LPRECT prcView
        , [in] LPRECT prcHScroll, [in] LPRECT prcVScroll
        , [in] LPRECT prcSizeBox);
    HRESULT Show([in] BOOL fShow);
    HRESULT UIActivate([in] BOOL fUIActivate);
    HRESULT Open(void);
    HRESULT CloseView([in] DWORD dwReserved);
    HRESULT SaveViewState([in] IStream *pstm);
    HRESULT ApplyViewState([in] IStream *pstm);
    HRESULT Clone([in] IOleInPlaceSite *pIPSiteNew, [out] IOleDocumentView **ppViewNew);
    }</font></pre>
<p>Every view has an associated view site, which encapsulates the view frame and the view port (HWND and a rectangular area in that window). The site exposes this functionality through the standard <B>IOleInPlaceSite</B><I> </I>interface. Note that it is possible to have more than one view port on a single HWND.</P>
<p>Typically each type of view has a different printed representation. Hence views and the corresponding view sites should implement the printing interfaces if <B>IPrint</B><I> </I>and <B>IContinueCallback</B><I>, </I>respectively. The view frame must negotiate with the view provider through <B>IPrint</B><I> </I>when printing begins, so that headers, footers, margins, and related elements are printed correctly. The view provider notifies the frame of printing-related events through <B>IContinueCallback</B>. For more information on the use of these interfaces, see "Programmatic Printing" later in this document.</P>
<p>Do note that if a DocObject only supports a single view, then the DocObject and that single view can be implemented using a single concrete class. <B>IOleDocument::CreateView</B> simply returns the same object's <B>IOleDocumentView</B> interface pointer. In short, it is not necessary that there be two separate object instances when only one view is required.</P>
<p>A view object can also choose to be a command target by implementing <B>IOleCommandTarget</B>. This allows it to easily receive commands that originate in the container's user interface (such as File New, Open, Save As, Print; Edit Copy, Paste, Undo, etc.). For more information, see "Command Targets" later in this document.</P>
<H4> </A>Document Site Objects (Container)</H4><p>In the Document Objects architecture, a document site is the same as a client site object in OLE Documents with the addition of the <B>IOleDocument</B><I> </I>interface:</P>

<pre><FONT FACE="Courier New" SIZE="3">interface IOleDocumentSite : IUnknown
    {
    HRESULT ActivateMe(IOleDocumentView *pViewToActivate);
    }</font></pre>
<p>The document site is conceptually the container for one or more "view site" objects that are each associated with individual view objects of the document managed by the document site. If the container only supports a single view per document site, then it can implement the document site and the view site with a single concrete class.</P>
<H4> </A>View Site Objects (Container)</H4><p>A container's "view site" object manages the display space for a particular view of a document. In addition to supporting the standard <B>IOleInPlaceSite</B><I> </I>interface, a view site also generally implements <B>IContinueCallback</B><I> </I>for programmatic printing control. (Note that the view object never queries for <B>IContinueCallback</B><I> </I>so it can actually be implemented on any object the container desires).</P>
<p>A container that supports multiple views must be able to create multiple view site objects within the document site. This provides each view with separate activation and deactivation services as provided through <B>IOleInPlaceSite</B><I>.</I></P>
<H4> </A>Frame Object (Container)</H4><p>The container's frame object is, for the most part, the same frame that is used for in-place activation in OLE Documents, that is, the one that handles menu and toolbar negotiation. A view object has access to this frame object through <B>IOleInPlaceSite::GetWindowContext</B><I> </I>which also provides access to the container object representing the container document (which can handle pane-level toolbar negotiation and contained object enumeration).</P>
<p>In Document Objects, a container can augment the frame by adding <B>IOleCommandTarget</B>. This allows it to receive commands that originate in the DocObject's user interface in the same way that this interface can allow a container to send the same commands (such as File New, Open, SaveAs, Print; Edit Copy, Paste, Undo, etc.) to a DocObject. For more information, see "Command Targets" later in this document.</P>
<a name="#sec13"></a><h3>Help Menu Merging: An Extension to OLE Documents</H3><p>When an object is active within a container, the menu merging protocol of OLE Documents gives the object complete control of the Help menu. As a result, the container's Help topics are not available unless the user deactivates the object. The Document Objects architecture expands on the rules for in-place menu merging to allow both the container and an active DocObject to share the menu. The new rules are simply additional conventions about what component owns what part of the menu and how the shared menu is constructed.</P>
<p>The new convention is simple. In DocObjects, the Help menu has two top-level menu items organized as follows:</P>

<pre><FONT FACE="Courier New" SIZE="3">Help
   Container Help &gt;
   Object Help    &gt;</font></pre>
<p>For example, when a Word section is active in the Office Binder, then the Help menu would appear as follows:</P>

<pre><FONT FACE="Courier New" SIZE="3">Help
   Binder Help &gt;
   Word Help   &gt;</font></pre>
<p>Both menu items are cascade menus under which any additional menu items specific to the container and the object are provided to the user. What items appear here will vary with the container and objects involved.</P>
<p>To construct this merged Help menu, the Document Objects architecture modifies the normal OLE Documents procedure.  According to OLE Documents, the merged menu bar can have 6 groups of menus:  File, Edit, Container, Object, Window, Help, in that order, and in each group there can be 0 or more menus. The groups File, Container, and Window<I> </I>belong to the container and the groups Edit, Object, and Help belong to the object. When the object wants to do menu merging it creates a blank menu bar and hands it over to the container, to let it insert its menus by calling<B> IOleInPlaceFrame::InsertMenus</B>. The object also hands over a structure which is an array of six LONGs (OLEMENUGROUPWIDTHS). After inserting the menus, container would mark how many menus he added in each one of its groups, and then returns. Then the object inserts its menus paying attention to the count of menus in each container group. Then finally object passes the merged menu bar and the array (which contains the count of menus in each group) to OLE, which returns an opaque "menu descriptor" handle. Later the object passes that handle and the merged menu bar to the container, via <B>IOleInPlaceFrame::SetMenu.</B> At this time container displays the merged menu bar and also passes the handle to OLE, so that OLE can do proper dispatching of menu messages.</P>
<p>In the modified DocObject procedure, the object must first initialize the OLEMENUGROUPWIDTHS elements to zero before passing it to the container. Then the container would do what it normally does in its menu insertion code with one exception. The container inserts a Help pop-up menu as the last item and stores a value of 1 in the last (sixth) entry of the OLEMENUGROUPWIDTHS array (that is, <I>width[5]</I> which belongs to the object's Help group). This Help popup menu will have only one item which is another popup menu, the "Container Help &gt;" cascade menu as described above.</P>
<p>The object then does its normal menu insertion code, except that before inserting its Help menu, it checks the sixth entry of the OLEMENUGROUPWIDTHS array. If the value is 1 and the name of the last menu is Help<I>(or the appropriate localized string)</I>, then the object inserts its Help popup menu as sub-menu of container's Help popup menu.</P>
<p>The object then sets the sixth element of OLEMENUGROUPWIDTHS to zero and increments the fifth element by one. This lets OLE know that the Help menu belongs to the container and the menu messages corresponding that menu (and its sub menus) should be routed to the container. It is then the container's responsibility to forward WM_INITMENUPOPUP, WM_SELECT, WM_COMMAND, and other menu-related messages that belong to the object's portion of the Help menu. (This is accomplished by using WM_INITMENU to clear a flag that tells the container whether or not the user has navigated into the object's Help menu. The container then watches WM_MENUSELECT for entry into or exit from any item on the Help popup that the container did not add itself. On entry, it means the user has navigated into an object popup, so the container sets the "in-object Help menu" flag and uses the state of that flag to forward any WM_MENUSELECT, WM_INITMENUPOPUP, and WM_COMMAND messages, as a minimum, to the object window. On exit, the container clears the flag and then processes these same messages itself.) The container should use the window returned from the object's <B>IOleInPlaceActiveObject::GetWindow</B> function as the destination for these messages.</P>
<p>If the object detects a zero in the sixth element of OLEMENUGROUPWIDTHS it otherwise proceeds according to the normal OLE Documents rules. This will take care of containers that participate in Help menu merging as well as those which do not.</P>
<p>When the object calls <B>IOleInPlaceFrame::SetMenu</B><I>, </I>before displaying the merged menu bar, the container checks whether his Help popup menu has an additional sub-menu, in addition to what it has inserted. If so the container would leave its Help popup menu in the merged menu bar, else it will remove it from the merged menu bar. This will take care of the objects that do participate in Help menu merging as well as those that do not.</P>
<p>Finally, during menu disassembly, the object would remove the inserted Help menu, in addition to removing the other inserted menus. And when container gets a chance to remove its menus, it will remove its Help popup menu in addition to the other menus that it has inserted. </P>
<a name="#sec14"></a><h3>Programmatic Printing (IPrint and IContinueCallback)</H3><p>OLE provided the means to uniquely identify persistent documents (<B>GetClassFile</B>) and load them into their associated code (<B>CoCreateInstance</B>, <B>QueryInterface(IID_IPersistFile/IID_IPersistStorage...)</B><I>,</I><B> IPersistFile/IPersistStorage::Load</B><I>)</I>. To further enable printing of documents, Document Objects (using an existing OLE design not originally shipped with OLE 2.0) introduces a base-standard printing interface, <B>IPrint</B><I>, </I>generally available through any object that can load the persistent state of the document type. Each view of a document object in the Document Objects architecture can optionally support the <B>IPrint</B><I> </I>interface to provide these capabilities.</P>
<p>The <B>IPrint</B><I> </I>interface is defined as follows:</P>

<pre><FONT FACE="Courier New" SIZE="3">interface IPrint : IUnknown
    {
    HRESULT SetInitialPageNum([in] LONG nFirstPage);
    HRESULT GetPageInfo([out] LONG *nFirstPage, [out] LONG *pcPages);
    HRESULT Print([in] DWORD grfFlags, [in,out] DVTARGETDEVICE **pptd<BR>        , [in,out] PAGESET ** ppPageSet , [in,out] STGMEDIUM **ppstgmOptions<BR>        , [in] IContinueCallback* pCallback, [in] LONG nFirstPage
        ,[out] LONG *pcPagesPrinted, [out] LONG *pnPageLast);
    };</font></pre>
<p>Clients and containers simply use<B> IPrint::Print</B><I> </I>to instruct the document to print itself once that document is loaded, specifying printing control flags, the target device, the pages to print, and additional options. The client can also control the continuation of printing through the interface <B>IContinueCallback</B> (see below).</P>
<p>In addition, <B>IPrint::SetInitialPageNum</B><I> </I>supports the ability to print a series of documents together as if they were one by numbering pages seamlessly, obviously a benefit for DocObject containers like Office Binder. <B>IPrint::GetPageInfo </B>simply allows the caller to retrieve the starting page number previously passed to <B>SetInitialPageNum</B><I> </I>and the number of pages in the document, useful for displaying pagination information.</P>
<p>Objects that support <B>IPrint</B><I> </I>mark themselves in the registry with the "Printable" key stored under the object's CLSID:</P>

<pre><FONT FACE="Courier New" SIZE="3">HKEY_CLASSES_ROOT\CLSID\{...}\Printable</font></pre>
<p><B>IPrint</B><I> </I>is usually implemented on the same object supporting either <B>IPersistFile</B><I> </I>or <B>IPersistStorage</B>. Callers note the capability to programmatically print the persistent state of some class by looking in the registry for the "Printable" key. At the time being, "Printable" indicates support for at least <B>IPrint;</B> other interfaces may be defined in the future which would then be available through <B>QueryInterface</B> where <B>IPrint</B><I> </I>simply represents the base level of support.</P>
<p>During a print procedure, the client or container that initiated the printing may wish to control whether or not the printing should continue. For example, the container may support a "Stop Print" command that should terminate the print job as soon as possible. To support this capability, the client of a printable object can implement a small notification sink object with the interface <B>IContinueCallback:</B></P>

<pre><FONT FACE="Courier New" SIZE="3">interface IContinueCallback : IUnknown
    {
    HRESULT FContinue(void);
    HRESULT FContinuePrinting([in] LONG cPagesPrinted, [in] LONG nCurrentPage<BR>        , [in] LPOLESTR pszPrintStatus);
    };</font></pre>
<p>This interface is designed to be useful as a generic continuation callback function which takes the place of the various continuation procedures in the Win32 API (such as the <I>AbortProc</I> for printing and the <I>EnumMetafileProc</I> for metafile enumeration). Thus this interface design is useful in a wide variety of time-consuming processes.</P>
<p>In the most generic cases, <B>IContinueCallback::FContinue</B> function is called periodically by any lengthy process. The sink object returns S_OK to continue the operation, S_FALSE to stop the procedure as soon as possible.</P>
<p><I>FContinue</I>, however, is not used in the context of <B>IPrint::Print</B>; rather, printing uses <B>IContinueCallback::FContinuePrint</B>. Any printing object should periodically call <I>FContinuePrint</I> passing the number of pages that have been printing, the number of the page being printed, and an additional string describing the print status that the client may choose to display to the user (such as "Page 5 of 19").</P>
<p>Complete details of these interfaces is given in the reference section at the end of this document.</P>
<a name="#sec15"></a><h3>Command Targets</H3><p>The command dispatch interface <B>IOleCommandTarget</B><I> </I>defines a simple and extensible mechanism to query and execute commands. This mechanism is simpler than OLE Automation's <B>IDispatch</B><I> </I>because it relies entirely on a standard set of commands. Commands rarely have arguments and no type information is involved (type safety is diminished for command arguments as well).</P>
<p>In this design, each command belongs to a "command group" which is itself identified with a GUID. Therefore anyone can define a new group and define all the commands within that group without any need to coordinate with Microsoft or any other vendor.(This is essentially the same means of definition as a dispinterface plus dispIDs in OLE Automation. There is overlap here, although this command routing mechanism is just for command routing and not for scripting/programmability on a large scale as OLE Automation handles.)</P>
<p><B>IOleCommandTarget</B><I> </I>handles the following scenarios:</P>
<OL>When an object is in-place activated, only the object's toolbars are typically displayed and the object's toolbars may have buttons for some of the container commands like "Print," "Print Preview," "Save," "New," "Zoom," etc. (Also do not register a "\protocol\StdFileEditing\server" to prevent inclusion in an OLE 1 container's Insert Object dialog. In-place activation standards recommend that objects remove such buttons from their toolbars, or at least disable them. This design allows those commands to be enabled and yet routed to the right handler.) Currently there is no mechanism for the object to dispatch these commands to the container.</LI><LI CLASS="OLI1">When a DocObject is embedded in a DocObject container (such as Binder), the container may need to send commands such as, "Print," "Page Setup," "Properties," to the contained DocObject.</LI></OL></SPAN><p>Obviously this simple command routing could be handled through existing OLE Automation standards and <B>IDispatch</B><I>. </I>However, the overhead involved with <B>IDispatch</B><I> </I>is more than is necessary here, so <B>IOleCommandTarget</B> provides a simpler means to achieve the same ends:</P>

<pre><FONT FACE="Courier New" SIZE="3">interface IOleCommandTarget : IUnknown
    {
    HRESULT QueryStatus([in] GUID *pguidCmdGroup, [in] ULONG cCmds<BR>        , [in,out][size_id(cCmds)] OLECMD *prgCmds, [in,out] OLECMDTEXT *pCmdText);
    HRESULT Exec([in] GUID *pguidCmdGroup, [in] DWORD nCmdID, [in] DWORD nCmdExecOpt<BR>        , [in] VARIANTARG *pvaIn, [in,out] VARIANTARG *pvaOut);
    }</font></pre>
<p>The <I>QueryStatus </I>method here tests whether a particular set of commands, the set being identified with a GUID, is supported. This call fills an array of OLECMD values (structures) with the supported list of commands as well as returning text describing the name of a command and/or status information. When the caller wishes to invoke a command, it can pass the command (and the set GUID) to <I>Exec</I> along with options and arguments, getting back a return value.</P>
<p>For more information on this interface, see the reference section at the end of this document.</P>
<a name="#sec16"></a><H2>Implementation Notes</H2><a name="#sec17"></a><h3>Becoming a DocObject Server</H3><p>This section discusses issues related to server side implementation of the Document Objects architecture, specifically the implementation of a DocObject and its view.</P>
<p>A DocObject can be implemented as an in-process object or as a local object (in an EXE). The Document Objects architecture has been designed so that it is relatively easy to transform an existing in-place implementation into a DocObject. The document object itself must support those interfaces described earlier. This will require existing object implementations to modify their code slightly in several places: <B>IOleObject::DoVerb</B>, <B>IOleObject::SetClientSite</B>, and in-place activation functions. The following sections describe these issues in more detail.</P>
<H4> </A>IOleObject::SetClientSite</H4><p>An object must be able to determine whether it can and should activate as a DocObject. This will depend on whether the client site (that is, the container) supports <B>IOleDocumentSite</B><I>.</I> When an object's <B>IOleObject::SetClientSite</B><I> </I>is called<I>, </I>it should query the given pointer for <B>IOleDocumentSite </B>as the following code illustrates:</P>

<pre><FONT FACE="Courier New" SIZE="3">HRESULT IOleObject::SetClientSite(IOleClientSite *pSite)
    {
    //Perform regular SetClientSite processing.

    // If we currently have a document site pointer, release it.
    if (NULL!=m_pDocSite)
        {
        ReleaseInterface(m_pDocSite);  //Macro to Release and NULL
        m_fDocObj=FALSE;
        }

    if (NULL!=pSite)
        {
        if (SUCCEEDED(pSite-&gt;QueryInterface(IID_IOleDocumentSite, &amp;m_pDocSite)))
            m_fDocObj=TRUE;
        }
    }</font></pre>
<H4> </A>IOleObject::DoVerb</H4><p>When a DocObject's <B>IOleObject::DoVerb</B><I> </I>is called<I>, </I>it will know whether to activate itself as a DocObject or not as determined in <B>IOleObject::SetClientSite</B>. Once DocObject support is acknowledged, various verbs are handled differently than a normal embedded object would handle them.</P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="140pt" VALIGN="TOP"><COL WIDTH="363pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Verb</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Handling Procedure</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>OLEIVERB_SHOW</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The object calls <B>IOleDocumentSite::ActivateMe</B><I>. </I>The object does not call either <B>IOleClientSite::ShowObject</B><I> </I>or <B>IOleClientSite::OnShowWindow</B><I> </I>at this time because it waits until calls to<B> IOleDocumentView</B><I> </I>for specific activation instructions.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>OLEIVERB_OPEN</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Same as OLEIVERB_SHOW&mdash;note that this is <I>not recommended </I>for containers.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>OLEIVERB_UIACTIVATE</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Same as OLEIVERB_SHOW.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>OLEIVERB_HIDE</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The object should return an error (E_INVALIDARG)</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><H4> </A>In-Place Activation Differences</H4><p>When activating as a DocObject, the object should behave as follows:</P>
<ul><li>Bypass displaying the in-place hatch border and object adornments (such as sizing handles etc.)</LI><li>Do not generate <B>IOleInPlaceSite::OnPosRectChange</B> calls (no need for them)</LI><li>Ignore <B>IOleObject::SetExtent</B> calls</LI><li>Draw scroll bars within the view rectangle (see <B>IOleDocumentView::SetRect</B><I> </I>and <B>SetRectComplex</B>) as opposed to drawing them outside that rectangle (as in normal in-place activation)</LI><li>Do not call <B>IOleClientSite::ShowObject</B><I> </I>and <B>IOleClientSite::ShowWindow</B> during activation.</LI></UL></SPAN><H4> </A>Storage Requirements</H4><p>The storage format of a DocObject must be the same whether it opens the file on its own and writes the data or whether it saves that data into storage provided by its container. In short, the DocObject must depends on <B>IStorage</B><I> </I>and <B>IStream</B><I> </I>for its persistence mechanisms. This enables a DocObject container to take the data in the object's storage and create a file out of it. Binder, for example, uses this mechanism to move the bound sections on to the shell.</P>
<p>In standard OLE, when <B>IPersistFile::Save</B> method is called with NULL for the file name, then the object must save itself into the file that it currently owns. The frame provider, which is not the storage provider, can use this mechanism to ask the document to save itself into the storage it currently owns.</P>
<H4> </A>Registration</H4><p>Every DocObject server should include the "DocObject" key in the registry entries of its supported classes. This key indicates Document Objects support. For example:</P>

<pre><FONT FACE="Courier New" SIZE="3">\CLSID\{&lt;CLSID for Word Document&gt;} = Microsoft Word 7.0 Document
\CLSID\{&lt;CLSID for Word Document&gt;}\DocObject = 0</font></pre>
<p>The value of the "DocObject" key indicates whether the DocObject can create multiple views and whether it can accept complex rectangles. See <B>IOleDocument::GetDocMiscStatus</B> for more information.</P>
<p>The DocObject must also use the "DefaultExtension" key to register the default extension used by its files along with a descriptive string that can be used in a File Open or File Save As dialog. For example:</P>

<pre><FONT FACE="Courier New" SIZE="3">\&lt;CLSID for Word Document&gt;\DefaultExtension=.doc, Word Documents (*.doc)</font></pre>
<p>Finally, if the object supports the <B>IPrint</B><I> </I>interface, it must register the "Printable" key. For example:</P>

<pre><FONT FACE="Courier New" SIZE="3">\&lt;CLSID…&gt;\Printable</font></pre>
<H4> </A>Limiting Embedding Support</H4><p>All DocObjects will be embeddable because they implement all the relevant interfaces for OLE Documents (<B>IOleObject</B><I>, </I><B>IDataObject</B><I>,</I><B> IPersistFile</B>,<I> </I>and <B>IPersistStorage</B>). However, they can choose to limit the embedding functionality they support. This can be done as follows:</P>
<ul><li>Do not register the "Insertable" key to prevent compound document containers from listing the document object class in the Insert Object dialog. Also do not register a "\protocol\StdFileEditing\server" to prevent inclusion in an OLE 1 container's Insert Object dialog.)</LI><li>Do not offer "Embed Source" or "Embedded Object" formats in data exchange operations. This prevents the object from being pasted into compound document containers.</LI><li>Set the OLEMISC_CANTLINKINSIDE bit in your MiscStatus key of the registry to prevent linking to embedded DocObjects.</LI><li>Set the OLEMISC_ICONICONLY bit to force the document to appear as an icon in any container that might still receive the object through the Insert From File dialog (an option in Insert Object) or when the file is dropped on a container from the system shell. Because it is only displayed as an icon, there is no need to worry about generating metafiles nor in handling <B>IOleObject::SetExtent</B> calls, etc.</LI></UL></SPAN><a name="#sec24"></a><h3>Becoming a DocObject Container</H3><p>This section discusses issues related to container or host side implementation of the Document Objects architecture. It goes without saying that a container supports the necessary interfaces as described in the architecture. However, there are a number of other considerations:</P>
<OL>Storage provisions and user interface</LI><LI CLASS="OLI1">Creation and initialization of a DocObject</LI><LI CLASS="OLI1">Activation of a DocObject</LI><LI CLASS="OLI1">DocObject saving and shutdown</LI><LI CLASS="OLI1">Support for other OLE features and completeness of interface implementations</LI></OL></SPAN><p>The following sections describe each of these topics in more detail. These are the core pieces of a DocObject container that require more comment than is found elsewhere in this specification, and the following discussion is not intended to touch on every container-side detail. As such, specific items like Help menu merging and command targets are not described here and are left for sample code to demonstrate.</P>
<H4> </A>Storage Provisions and User Interface</H4><p>A DocObject container is generally a container that manages multiple "documents" (from the user perspective) in a single data store of some kind. Now, that data store could be something as complex as an entire file system, or it could be something simple like an individual compound file. In general, the container's methods for dealing with the ultimate storage of documents edited as DocObjects will in many ways determine the type of user interface that the container supports.</P>
<p>The Office Binder, for example, uses a single "Binder" file, an OLE Compound File, as its own data store. Within that single Binder file, the Binder can embed any number of other documents as "sections" in the binder. Technically speaking, while the Binder file itself is a single root instance of <B>IStorage</B>, each section is then given the <B>IStorage</B><I> </I>of a sub-storage within the root. Each embedded DocObject is handed this sub-storage pointer through <B>IPersistStorage::InitNew</B><I> </I>or <B>IPersistStorage::Load</B><I> </I>(either at creation or reloading time, respectively) and stores all of its data directly in that storage.</P>
<p>What the Office Binder does for a user interface, then, is provide a left-hand pane that displays the "documents" or sections in the binder, activating them one at a time in the right-hand pane as if they were being opened in their respective applications. However, one never leaves the binder paradigm as one changes from section to section. Each so-called document is just a sub-storage in the entire binder.</P>
<p>Now a container that browses a file system, on the other hand, will see the whole file system, or the World Wide Web for that matter, as a single "file" or "binder" in which are found many individual documents. This kind of container would have the browsing UI in the left-hand pane and would individually activate DocObjects within a viewing pane of that browser. In this case the <B>IStorage</B><I> </I>handed to each DocObject is the root <B>IStorage</B><I> </I>for the entire document on the file system itself.</P>
<p>One must not confuse the use of an <B>IStorage</B><I> </I>in the DocObjects architecture with the use of streams to save and re-load view states through <B>IOleDocumentView::SaveViewState</B><I> </I>and <B>IOleDocumentView::ApplyViewState</B> as described in more detail below.</P>
<H4> </A>Creation and Initialization</H4><p>How a container wishes to create an embedded DocObject is up to that container. This will generally involve one of the OLE API functions <B>OleCreate</B><I>,</I><B> OleCreateFromData</B><I>, </I><B>OleCreateFromFile</B>, and <B>OleLoad</B>. <B>OleCreate</B>, of course, is used to create a new, uninitialized DocObject&mdash;when that object is activated the user starts with a clean slate. <B>OleCreateFromData</B><I> </I>and <B>OleCreateFromFile</B>, on the other hand, create new instances of objects with a state initialized from either the contents of a data object (clipboard, drag and drop, etc.) or from the contents of a file, respectively. Once a DocObject is saved to its <B>IStorage</B> via <B>OleSave</B>, it can then be reloaded with <I>OleLoad</I>, of course.</P>
<p>The full initialization sequence for a DocObject will depend on the exact nature of the container. At a minimum, however, it will involve these steps after creation or loading:</P>
<OL><B>IPersistStorage::InitNew</B> (create) or <B>IPersistStorage::Load </B>(reload)</LI><LI CLASS="OLI1"><B>IOleObject::SetClientSite</B></LI><LI CLASS="OLI1"><B>IOleObject::Advise</B></LI></OL></SPAN><p>These three calls will initialize the DocObject and set up communication between it and the container's <B>IOleClientSite</B><I> </I>and <B>IAdviseSink</B> interfaces. Nothing more is essential, although containers that display something like an iconic rendering of the object may also include calls to <B>IViewObject2</B><I> </I>members such as <B>GetExtent</B> and <B>SetAdvise</B>.</P>
<p>Note that as described in the server section above, the container's call to <B>IOleObject::SetClientSite</B><I> </I>will generate a <B>QueryInterface</B><I> </I>call to the container for <B>IOleDocumentSite</B><I>.</I> The object then uses this interface during activation, which is the next topic.</P>
<H4> </A>Activation</H4><p>Activating a DocObject is largely just a matter of calling <B>IOleObject::DoVerb</B>(OLEIVERB_SHOW, …)<I> </I> then responding to <B>IOleDocumentSite::ActivateMe</B>. OLEIVERB_SHOW is generally the most appropriate activation verb here, but OLEIVERB_PRIMARY and OLEIVERB_UIACTIVATE are also allowable. OLEIVERB_OPEN isn't recommended as highly because it implies separate-window activation instead of an in-place activation.</P>
<p>Activation of a DocObject is almost entirely self-contained within <B>IOleDocumenSite::ActivateMe </B>whose implementation generally appears as follows:</P>

<pre><FONT FACE="Courier New" SIZE="3">STDMETHODIMP CImpIOleDocumentSite::ActivateMe(IOleDocumentView *pView)
    {
    RECT                rc;
    
    /*
     * If we're passed a NULL view pointer, then try to get one from
     * the document object.
     */
    if (NULL==pView)
        {
        IOleDocument *pDoc;

        if (FAILED(m_pSite-&gt;m_pObj-&gt;QueryInterface(IID_IOleDocument
            , (void **)&amp;pDoc)))
            return E_FAIL;

        if (FAILED(pDoc-&gt;CreateView(m_pSite-&gt;m_pImpIOleIPSite, NULL
            , 0, &amp;pView)))
            return E_OUTOFMEMORY;
        }
    else
        {
        //Make sure that the view has our client site
        pView-&gt;SetInPlaceSite(m_pSite-&gt;m_pImpIOleIPSite);

        //We're holding onto the pointer, so AddRef it.
        pView-&gt;AddRef();
        }

    //Remember the type of object we have and the view pointer
    m_pSite-&gt;m_fDocObj==TRUE;
    m_pSite-&gt;m_pIOleDocView=pView;
    
    //This sets up toolbars and menus first
    pView-&gt;UIActivate(TRUE);

    //Set the window size sensitive to new toolbars
    GetClientRect(m_pSite-&gt;m_hWnd, &amp;rc);
    pView-&gt;SetRect(&amp;rc);

    //Makes it all visible
    pView-&gt;Show(TRUE);

    return NOERROR;
    }
</font></pre>
<p>This code is taken from a working DocObject container and demonstrates the proper sequence of operations for DocObject activation:</P>
<OL>If <B>ActivateMe </B>is passed an as <B>IOleDocumentView</B> pointer, then call <B>IOleDocumentView::SetInPlaceSite</B> followed by <B>AddRef </B>if you're holding onto the pointer (which is generally the case). Otherwise query the document object itself for <B>IOleDocument</B> and call <B>IOleDocument::CreateView</B> passing in the container's <B>IOleInPlaceSite</B> pointer. In both cases you'll end up with an <B>IOleDocumentView</B> pointer for the DocObject's view that should be released when the container no longer needs it.</LI><LI CLASS="OLI1">Activate the DocObject view by calling <B>IOleDocumentView::UIActivate(TRUE)</B> which will cause it to perform menu merging, toolbar negotiation, and reparent its display window to the window returned through <B>IOleInPlaceSite::GetWindow</B><I>.</I> Part of the toolbar negotiation sequence should be for the container to remember exactly how much border space is taken up, resizing any client-area windows in the container to account for this space.</LI><LI CLASS="OLI1">Call <B>IOleDocumentView::SetRect </B>(or <B>SetRectComplex </B>depending on the container) to tell the view exactly how much space to occupy in its parent. If the container manages a client-area window as the code sample above is doing, then this rectangle is simply the client area of that window. Note that this step is important to do <I>after </I>calling <B>UIActivate </B>because the container would otherwise send the view the wrong dimensions that wouldn't account for toolbar space.</LI><LI CLASS="OLI1">Call <B>IOleDocumentView::Show(TRUE) </B>to make the DocObject visible. This is the last step because the DocObject view knows exactly what space it occupies and all its other tools are there.</LI></OL></SPAN><p>While the DocObject remains active, it is also imperative that the container fulfill a few other requirements, some of which come from standard in-place activation rules:</P>
<OL>Call <B>IOleInPlaceActiveObject::ResizeBorder</B> when the container frame is resized so the object can resize its toolbars appropriately.</LI><LI CLASS="OLI1">Call <B>IOleDocumentView::SetRect</B> whenever the window used for the DocObject parent is resized. This might be the frame window, a client-area window, or a document window (in an MDI container). <B>SetRect </B>tells the DocObject to resize its view to fully occupy the parent window's client area.</LI><LI CLASS="OLI1">Implement <B>IOleInPlaceFrame::SetStatusText</B><I> </I>if the container has a toolbar.</LI><LI CLASS="OLI1">Call <B>IOleInPlaceActiveObject::TranslateAccelerator</B> from the container's message loop.</LI><LI CLASS="OLI1">Detect the F1 key to enter context-sensitive Help mode as well as ESC to leave it, calling <B>IOleInPlaceActiveObject::ContextSensitiveHelp </B>with TRUE and FALSE, respectively<I>.</I></LI><LI CLASS="OLI1">Handle WM_SETFOCUS to the frame window by setting focus to the window returned from <B>IOleInPlaceActiveObject::GetWindow</B>.</LI></OL></SPAN><p>All of these bits other than step 2 are standard in-place activation requirements.</P>
<H4> </A>Saving and Shutdown</H4><p>When a DocObject is closed, the container should ensure that its data is saved as it would with any other embedded object. This means the container must handle <B>IOleClientSite::SaveObject</B> in which it generates a call to the object's <B>IPersistStorage::Save,</B> usually through <B>OleSave</B><I>, </I>followed by <B>IPersistStorage::SaveCompleted</B> and an <B>IStorage::Commit</B><I> </I>if transactioned storage is being employed.</P>
<p>When the container wishes to close the object entirely, that is, unload it completely (with or without saving), then the container should first call <B>IOleInPlaceObject::InPlaceDeactivate</B>, <B>IOleObject::Close</B>, followed by <B>Release</B><I> </I>calls on all interface pointers that the container is holding. When the last reference count is released, the DocObject will delete itself and its server will shut down as appropriate.</P>
<p>Again, all of this is standard for standard embedding scenarios in OLE Documents.</P>
<H4> </A>Support for Other OLE Features and Completeness of Interface Implementations</H4><p>As described in the previous section, DocObject servers will never generate calls to various members of the <B>IOleClientSite </B>and <B>IOleInPlaceSite</B> interfaces, such as:</P>
<ul><li><B>IOleClientSite::GetMoniker</B></LI><li><B>IOleClientSite::GetContainer</B></LI><li><B>IOleClientSite::RequestNewObjectLayout</B></LI><li><B>IOleClientSite::OnShowWindow</B></LI><li><B>IOleClientSite::ShowObject</B></LI><li><B>IOleInPlaceSite::OnPosRectChange</B></LI><li><B>IOleInPlaceSite::Scroll</B></LI><li><B>IOleInPlaceSite::ContextSensitiveHelp</B> (if container has no support for this)</LI></UL></SPAN><p>Therefore, strictly DocObject containers can simply return E_NOTIMPL from these members. In addition, most of the <B>IAdviseSink</B><I> </I>members need no implementation, with <B>IAdviseSink::OnClose</B> being the only one of probable interest; in some cases a container may not need <B>IAdviseSink</B> at all, and thus would never need to call <B>IOleObject::Advise</B><I> </I>(or <B>IViewObject::SetAdvise</B> when the container doesn't display anything for the object visually).</P>
<p>All other members of <B>IOleClientSite</B><I> </I>and <B>IOleInPlaceSite</B>, as well as those in <B>IOleInPlaceFrame </B>require some implementation which is sometimes considerable and at other times nothing more than a return of NOERROR (such as <B>IOleInPlaceSite::CanInPlaceActivate</B>).</P>
<p>Of course, the container may support more than just DocObjects&mdash;it might also support normal OLE compound document linking and embedding in which case it will completely implement these interfaces as specified for OLE Documents. The container may also support OLE Controls in which case it would have <B>IDispatch</B>, event handlers, <B>IOleControlSite</B>, and so on. It should be noted, however, that DocObjects do not interfere with support for these other types of objects, provided that the container maintains a variable (like <I>m_fDocObj</I> as described in the activation section above) that tells the rest of its code that certain operations won't be needed when a DocObject is in use.</P>
<p>Finally, there is also the separate-window activation model available through <B>IOleDocumentView</B> which can be employed as a container sees fit. Support for that model is not a requirement for all DocObject containers, however.</P>
<a name="#sec30"></a><H2>Document Objects Interface Reference</H2><p>This section lists all interfaces, related structures, and related enumerations that are defined by this architecture. The section has a detailed description of interface member functions and their arguments.</P>
<a name="#sec31"></a><h3>The <I>IOleDocument </I>Interface</H3><p>By implementing this interface alongside other interfaces relating to OLE Documents, an object indicates its ability to act as a "document object." Through this interface, a container for DocObjects can ask the object to create views of itself as well as to enumerate those views and to retrieve MiscStatus bits related to the document object.</P>
<p>IDL:</P>

<pre><FONT FACE="Courier New" SIZE="3">[
uuid(B722BCC5-4E68-101B-A2BC-00AA00404770)
    , object, pointer_default(unique)
]
interface IOleDocument : IUnknown
    {
    HRESULT CreateView([in] IOleInPlaceSite *pIPSite, [in] IStream *pstm<BR>        , [in] DWORD dwReserved, [out] IOleDocumentView **ppView);
    HRESULT GetDocMiscStatus([out] DWORD *pdwStatus);
    HRESULT EnumViews([out] IEnumOleDocumentViews **ppEnum<BR>        , [out] IOleDocumentView **ppView);
    }</font></pre>
<H4> </A>IOleDocument::CreateView</H4>
<pre><FONT FACE="Courier New" SIZE="3">HRESULT IOleDocument::CreateView([in] IOleInPlaceSite *pIPSite,
   [in] IStream *pstm, [in] DWORD dwReserved, [out] IOleDocumentView **ppView)</font></pre>
<p>Ask the document object to create a new view sub-object, returning that view object's <B>IOleDocumentView i</B>nterface pointer. Optionally this call can also initialize the view from the contents a given stream. A container calls this function to both create new views as well as to reload previously saved viewed.. The view must wait for calls to either <B>IOleDocumentView::Show</B><I> </I>or <B>IOleDocumentView::UIActivate</B><I> </I>before showing itself.</P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="99pt" VALIGN="TOP"><COL WIDTH="270pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Argument</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Type</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Description</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><I>pIPSite</I></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>I<B>OleInPlaceSite *</B></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>A pointer to the container's "view site" object associated with the new view. May be NULL in which case the caller must initialize the view with a call to <B>IOleDocumentView::SetInPlaceSite.</B></P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><I>pstm</I></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>IStream *</B></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>A pointer to the stream from which the view should initialize itself.  If NULL, then this function creates a new view with a default state.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><I>dwReserved</I></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>DWORD</B></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Reserved for future use. Must be zero.In the future this parameter could be used to specify the type of view that needs to be created. Currently there are no defined values for this argument.)</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><I>ppView</I></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>IOleDocumentView *</B></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Address of the variable to receive the interface pointer to the new view. If <B>CreateView</B><I> </I>succeeds, the caller is responsible for calling <B>Release</B><I> </I>through this pointer when the view object is no longer needed.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><p></P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="297pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Return Value</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Meaning</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>S_OK</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The view was created successfully.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>E_POINTER</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The address in <I>ppView</I> is NULL.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>E_OUTOFMEMORY</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>There is not enough memory to create the new view.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>E_UNEXPECTED</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>An unknown error occurred.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>DOCOBJ_E_ONLYONEVIEW</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>This document object only supports a single view which has already been created.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><p><B>Comments:</B></P>
<p>This function must be completely implemented in any document object; therefore E_NOTIMPL is not an acceptable return code.</P>
<p>As with all new interface pointers, <B>CreateView</B><I> </I>calls <I>AddRef </I>on the pointer in <I>*ppView </I>before returning.  The caller is responsible for calling <B>Release</B><I> </I>through this pointer when it is no longer needed.</P>
<p>If <I>pIPSite</I> is non-NULL, then the document object should pass the pointer to the new view through <B>IOleDocumentView::SetInPlaceSite</B>. If NULL, the caller is responsible for this same call.  In addition, if <I>pstm</I> is non-NULL, then the object should initialize the view object by passing <I>pstm </I>to <B>IOleDocumentView::ApplyViewState</B>.</P>
<H4> </A>IOleDocument::GetDocMiscStatus</H4>
<pre><FONT FACE="Courier New" SIZE="3">HRESULT IOleDocument::GetDocMiscStatus([out] DWORD *pdwStatus)</font></pre>
<p>Returns miscellaneous status bits describing the document object, such as whether the object can create multiple views and accept complex rectangles. (One rectangle each for view, horizontal scroll bar, vertical scroll bar and size box. See <B>IOleDocumentView::SetRectComplex</B>.) These values are also stored in the registry as the value of the "DocObject" key:</P>

<pre><FONT FACE="Courier New" SIZE="3">typedef enum
    {
    DOCMISC_CANCREATEMULTIPLEVIEWS   = 1, //Object supports multiple views
    DOCMISC_SUPPORTCOMPLEXRECTANGLES = 2, //IOleDocumentView::SetRectComplex is supported
    DOCMISC_CANTOPENEDIT             = 4, //IOleDocumentView::Open is unsupported
    DOCMISC_NOFILESUPPORT            = 8  //Object does not support file read/write
    } DOCMISC;</font></pre>
<p>The bits DOCMISC_CANTOPENEDIT, DOCMISC_NOFILESUPPORT need further explanation. There can be objects which can only be embedded, can only be in-place activated, and which do not have files of their own, regardless of whether they are implemented as in-process or local servers. Objects which have limited UI for activation purposes should set DOCMISC_CANTOPENEDIT. Those that only support <B>IPersistStorage</B><I> </I>as a persistence mechanism should specify DOCMISC_NOFILESUPPORT. Otherwise and object must also implement <B>IPersistFile</B> implementation.</P>
<p>If an object desires none of these status bits it must return a zero in <I>*pdwStatus</I>.</P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="99pt" VALIGN="TOP"><COL WIDTH="270pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Argument</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Type</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Description</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><I>pdwStatus</I></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>DWORD *</B></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The address of the variable to receive the status bits about this document object.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><p></P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="297pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Return Value</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Meaning</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>S_OK</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The status bits were returned successfully.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>E_POINTER</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The address in <I>pdwStatus </I>is NULL.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><p><B>Comments:</B></P>
<p>This function must be completely implemented in any document object even if a zero is returned; therefore E_NOTIMPL is not an acceptable return code.</P>
<H4> </A>IOleDocument::EnumViews</H4>
<pre><FONT FACE="Courier New" SIZE="3">HRESULT IOleDocument::EnumViews([out] IEnumOleDocumentViews **ppEnum<BR>, [out] IOleDocumentView **ppView)</font></pre>
<p>Creates an enumerator object that enumerates the <B>IOleDocumentView</B> interface pointers of the views of the document object. The enumerator supports the interface <B>IEnumOleDocumentViews</B><I>, </I>a pointer to which is returned in *<I>ppEnum</I>.  An object that supports only a single view (that is, DOCMISC_CANCREATEMULTIPLEVIEWS is not specified through <B>IOleDocument::GetMiscStatus</B>) does not create an enumerator but instead returns the single view pointer through *<I>ppView</I>.</P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="77pt" VALIGN="TOP"><COL WIDTH="159pt" VALIGN="TOP"><COL WIDTH="205pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Argument</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Type</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Description</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><I>ppEnum</I></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>IEnumOleDocumentViews **</B></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The address of the variable to receive the interface pointer of the enumerator.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><I>ppView</I></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>IOleDocumentView **</B></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The address of the variable to receive the interface pointer of a single view.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><p></P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="297pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Return Value</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Meaning</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>S_OK</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>If the object supports multiple views, then <I>*ppEnum </I>contains the enumerator pointer.  Otherwise <I>*ppEnum</I> is NULL and <I>*ppView </I>contains the interface pointer to the single view..</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>E_POINTER</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The address in <I>ppEnum </I>or <I>ppView </I>is invalid. The caller must pass pointers for both arguments.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>E_OUTOFMEMORY</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The enumerator could not be created because there is insufficient memory.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><p><B>Comments:</B></P>
<p>This function must be completely implemented in any document object; therefore E_NOTIMPL is not an acceptable return code.</P>
<a name="#sec35"></a><h3>The IEnumOleDocumentViews<I> </I>Interface</H3><p>A document object can be asked to enumerate its views through <B>IOleDocument::EnumViews</B>. The resulting enumerator returned from this member implements the interface <B>IEnumOleDocumentViews</B><I> </I>through which a client can access all the individual view sub-objects supported within the document object itself, where each view implements <B>IOleDocumentView</B><I>.</I></P>
<p>Therefore<B> IEnumOleDocumentViews</B><B><I> </I></B>is a standard enumerator interface typed for <B>IOleDocumentView *</B>.</P>
<p>IDL:</P>

<pre><FONT FACE="Courier New" SIZE="3">[
uuid(B722BCC8-4E68-101B-A2BC-00AA00404770)
    , object, pointer_default(unique)
]
interface IEnumOleDocumentViews : IUnknown
    {
    HRESULT Next([in] ULONG cViews
        , [out, max_is(cViews)] IConnectionPoint **rgpView
        , [out] ULONG *pcFetched);

    HRESULT Skip([in] ULONG cViews);
    HRESULT Reset(void);
    HRESULT Clone([out] IEnumDocumentView **ppEnum);
    }</font></pre>
<H4> </A>IEnumOleDocumentViews::Next</H4>
<pre><FONT FACE="Courier New" SIZE="3">HRESULT IEnumOleDocumentViews::Next([in] ULONG cViews , [out, max_is(cViews)] IOleDocumentView **rgpView, [out] ULONG *pcFetched);</font></pre>
<p>Enumerates the next cViews elements in the enumerator's list, returning them in rgpView along with the actual number of enumerated elements in pcFetched. The caller is responsible for calling <B>IOleDocumentView::Release</B> through each pointer returned in rgpView.</P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="99pt" VALIGN="TOP"><COL WIDTH="270pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Argument</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Type</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Description</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><I>cViews</I></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>ULONG</B></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Specifies the number of <B>IOleDocumentView*</B> values to return in the array pointed to by rgpView.  This argument must be 1 if pcFetched is NULL.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><I>rgpView</I></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>IOleDocumentView</B>*</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>A pointer to a caller-allocated<B> IOleDocumentView*</B> array of size cViews in which to return the enumerated connection points. The caller is responsible for calling <B>IOleDocumentView::Release</B> through each pointer enumerated into the array once this method returns successfully. If cViews is greater than one the caller must also pass a non-NULL pointer passed to pcFetched to know how many pointers to release.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><I>pcFetched</I></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>ULONG</B></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>A pointer to the variable to receive the actual number of connection points enumerated in rgpView. This argument can be NULL in which case the cViews argument must be 1.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><p></P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="297pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Return Value</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Meaning</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>S_OK</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The requested number of elements has been returned and <I>*pcFetched </I>(if non-NULL) is set to <I>cViews.</I></P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>S_FALSE</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The enumerator returned fewer elements than <I>cViews </I>because there were not that many elements left in the list. In this case, unused elements in <I>rgpView </I>in the enumeration are not set to NULL and <I>*pcFetched </I>holds the number of valid entries, even if zero is returned.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>E_POINTER</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The address in <I>rgpView </I>is not valid (such as NULL)</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>E_INVALIDARG</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The value of <I>cViews </I>is not 1 when <I>pcFetched </I>is NULL; or the value of <I>cViews </I>is zero.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>E_UNEXPECTED</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>An unknown error occurred.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>E_OUTOFMEMORY</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>There is not enough memory to enumerate the elements.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><p><B>Comments:</B></P>
<p>E_NOTIMPL is not allowed as a return value.  If an error value is returned, no entries in the <I>rgpView </I>array are valid on exit and require no release.</P>
<H4> </A>IEnumOleDocumentViews::Skip</H4>
<pre><FONT FACE="Courier New" SIZE="3">HRESULT IEnumOleDocumentViews::Skip([in] ULONG cConnections);</font></pre>
<p>Instructs the enumerator to skip the next cViews elements in the enumeration such that the next call to <B>IEnumOleDocumentViews::Next</B> will not return those elements.</P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="59pt" VALIGN="TOP"><COL WIDTH="311pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Argument</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Type</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Description</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>cViews</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>ULONG</B></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Specifies the number of elements to skip in the enumeration.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><p></P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="297pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Return Value</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Meaning</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>S_OK</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The number of elements skipped is <I>cViews</I>.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>S_FALSE</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The enumerator skipped fewer than <I>cViews </I>because there were not that many left in the list. The enumerator will, at this point, be positioned at the end of the list such that subsequent calls to <I>Next </I>(without an intervening <I>Reset</I>) will return zero elements.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>E_INVALIDARG</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The value of <I>cViews</I>is zero, which is not valid.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>E_UNEXPECTED</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>An unknown error occurred.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><H4> </A>IEnumOleDocumentViews::Reset</H4>
<pre><FONT FACE="Courier New" SIZE="3">HRESULT IEnumOleDocumentViews::Reset(void);</font></pre>
<p>Instructs the enumerator to position itself back to the beginning of the list of elements.</P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="59pt" VALIGN="TOP"><COL WIDTH="311pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Argument</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Type</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Description</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>NA</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>NA</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>NA</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><p></P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="297pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Return Value</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Meaning</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>S_OK</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The enumerator was successfully reset to the beginning of the list.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>S_FALSE</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The enumerator was not reset to the beginning of the list.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>E_UNEXPECTED</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>An unknown error occurred.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><p><B>Comments:</B></P>
<p>There is no guarantee that the same set of elements will be enumerated on each pass through the list; it depends on the collection being enumerated. It is too expensive for some collections, such as files in a directory, to maintain this condition.</P>
<H4> </A>IEnumOleDocumentViews::Clone</H4>
<pre><FONT FACE="Courier New" SIZE="3">HRESULT IEnumOleDocumentViews::Clone([out] IEnumOleDocumentViews **ppEnum);</font></pre>
<p>Creates another view enumerator with the same state as the current enumerator, which iterates over the same list. This makes it possible to record a point in the enumeration sequence in order to return to that point at a later time.</P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="126pt" VALIGN="TOP"><COL WIDTH="243pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Argument</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Type</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Description</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>ppEnum</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>IEnumOleDocumentViews**</B></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The address of the variable to receive the <B>IEnumOleDocumentViews</B> interface pointer to the newly created enumerator. The caller must release this new enumerator separately from the first enumerator.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><p></P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="297pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Return Value</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Meaning</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>S_OK</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Clone creation succeeded.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>E_NOTIMPL</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Cloning is not supported for this enumerator.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>E_POINTER</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The address in <I>ppEnum </I>is not valid (such as NULL)</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>E_UNEXPECTED</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>An unknown error occurred.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>E_OUTOFMEMORY</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>There is not enough memory to create the clone enumerator.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><a name="#sec40"></a><h3>The IOleDocumentSite<I> </I>Interface</H3><p>By implementing this interface on an client site alongside other client site interfaces required by OLE Documents, a container indicates its support for document object activation to any such objects associated with this site. The interface allows a document object to ask the container to activate it as a document instead of as an in-place embedded object. The document object can alternately specify which view to activate.</P>
<p>The view site encapsulates the view port (the HWND and a rectangle in that HWND) and the frame context of the view port.  There can be multiple view ports in a single window. A view site is attached to a view through the <I>pIPSite </I>argument of <B>IOleDocument::CreateView</B><I> </I>or through <B>IOleDocumentView::SetInPlaceSite</B><I>.</I></P>
<p>IDL:</P>

<pre><FONT FACE="Courier New" SIZE="3">[
uuid(B722BCC7-4E68-101B-A2BC-00AA00404770)
    , object, pointer_default(unique)
]
interface IOleDocumentSite : IUnknown
    {
    HRESULT ActivateMe([in] IOleDocumentView *pViewToActivate);
    };</font></pre>
<H4> </A>IOleDocumentSite::ActivateMe</H4>
<pre><FONT FACE="Courier New" SIZE="3">HRESULT IOleDocumentSiteActivateMe([in] IOleDocumentView *pViewToActivate)</font></pre>
<p>When a document object is asked to in-place activate through <B>IOleObject::DoVerb</B>, a document object bypasses the normal in-place activation sequence of OLE Documents and instead calls <B>IOleDocumentSite::ActivateMe</B><I> </I>to become active as a document. This should be done in the OLEIVERB_OPEN, OLEIVERB_SHOW, OLEIVERB_INPLACEACTIVATE, and OLEIVERB_UIACTIVATE cases.</P>
<p>The document object can specify which view to activate by passing that view's <B>IOleDocumentView</B><I> </I>pointer in <I>pViewToActivate</I>.  The container in this case will proceed and activate that view through that pointer.  Otherwise, the container calls the object's <B>IOleDocument::CreateView</B><I> </I>to obtain the view it wishes to activate.</P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="81pt" VALIGN="TOP"><COL WIDTH="130pt" VALIGN="TOP"><COL WIDTH="230pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Argument</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Type</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Description</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>pViewToActivate</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>IOleDocumentView **</B></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>If non-NULL, specifies the view to bring forward.  The caller does not call AddRef on this pointer before passing it in&mdash;if the receiver wishes to hold the pointer outside of this member function it must call pViewToActivate-&gt;AddRef();</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><p></P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="297pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Return Value</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Meaning</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>S_OK</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The container activated the view successfully.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>E_OUTOFMEMORY</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><I>pViewToActivate </I>is NULL and the container's call to <B>IOleDocument::CreateView</B><I> </I>failed with E_OUTOFMEMORY.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>E_FAIL</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Another error occurred in either view creation or activation.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><p><B>Comments:</B></P>
<p>This function must be completely implemented in a container; therefore E_NOTIMPL is not an acceptable return code.</P>
<a name="#sec42"></a><h3>The IOleDocumentView Interface</H3><p>Each view of a document object is a sub-object that implements <B>IOleDocumentView</B><I> </I>alongside <B>IOleInPlaceObject</B><I>, </I><B>IOleInPlaceActiveObject</B><I>, </I>and other optional interfaces like <B>IPrint</B> and <B>IOleCommandTarget</B>. This interface provides all the necessary operations for a container to manipulate, manage, and activate a view.</P>
<p>IDL:</P>

<pre><FONT FACE="Courier New" SIZE="3">[
uuid(B722BCC6-4E68-101B-A2BC-00AA00404770)
    , object, pointer_default(unique)
]
interface IOleDocumentView : IUnknown
    {
    //import "unknwn.idl";

    HRESULT SetInPlaceSite([in] IOleInPlaceSite *pIPSite);
    HRESULT GetInPlaceSite([out] IOleInPlaceSite **ppIPSite);
    HRESULT GetDocument([out] IUnknown **ppunk);
    [input_sync] HRESULT SetRect([in] LPRECT prcView);
    HRESULT GetRect([out] LPRECT prcView);
    [input_sync] HRESULT SetRectComplex([in] LPRECT prcView
        , [in] LPRECT prcHScroll, [in] LPRECT prcVScroll
        , [in] LPRECT prcSizeBox);
    HRESULT Show ([in] BOOL fShow);
    HRESULT UIActivate([in] BOOL fUIActivate);
    HRESULT Open(void);
    HRESULT CloseView([in] DWORD dwReserved);
    HRESULT SaveViewState([in] IStream *pstm);
    HRESULT ApplyViewState([in] IStream *pstm);
    HRESULT Clone([in] IOleInPlaceSite *pIPSiteNew
        , [out] IOleDocumentView **ppViewNew);
    }</font></pre>
<p>The members <I>SetInPlaceSite </I>and <I>GetInPlaceSite</I> manage the <B>IOleInPlaceSite</B><I> </I>interface pointer for the container's view site associated with this view. The semantics of <I>SetInPlaceSite </I>are encompassed in the <I>pIPSite </I>argument of <B>IOleDocument::CreateView</B><I>.</I></P>
<p>GetDocument provides access to the <B>IUnknown</B><I> </I>pointer of the document object that owns this view.</P>
<p>The <I>SetRect </I>and <I>GetRect </I>members manage the simple rectangle that the view will occupy in the container. <I>SetRectComplex</I> allows the container to specify not only the simple rectangle but also the spaces that should be occupied by the view's scrollbars and size box. An view specifies whether it understands <I>SetRectComplex </I>through the DOCMISC_SUPPORTCOMPLEXRECTANGLES status bit (see <B>IOleDocument::GetMiscStatus</B>).</P>
<p>The view's visual state is managed through the pair <B>Show</B><I> </I>and <B>UIActivate</B><I> </I>as well as <B>Open.</B> <B>Show i</B>nstructs the view to activate or deactivate itself in-place; when the view is active, <B>UIActivate</B><I> </I>instructs the view to activate or deactivate its user interface elements such as menus, toolbars, and accelerators. <B>Show</B><I> </I>and <B>UIActivate</B><I> </I>in this interface are thus equivalents of the <B>IOleInPlaceObject</B> members of <B>InPlaceActivate</B><I>,</I><B> InPlaceDeactivate</B><I>,</I><B> UIActivate</B><I>, </I>and <B>UIDeactivate </B>that are used for control of an in-place embedding.</P>
<p>The <B>Open</B><I> </I>member, on the other hand, works with activation in a separate window (as happens with embeddings in OLE Documents when in-place is not supported). DocObjects marked with DOCMISC_CANTOPENEDIT (see <B>IOleDocument::GetMiscStatus</B>) do not support this form of activation. If support is present, however, <B>Open</B><I> </I>instructs the view to activate in a separate window similar to <B>IOleObject::DoVerb(OLEIVERB_OPEN</B><I>)</I>. At this point <B>Show</B><I> </I>instructs the view to show and hide this window.</P>
<p>In all cases, <B>CloseView</B><I> </I>instructs the view to deactivate the view, destroying any separate window and releasing the view site pointer passed previously to <B>IOleDocumentView::SetInPlaceSite</B><I>. </I>This functionality is similar to that described for <B>IOleObject::Close</B>.</P>
<p>A view's internal state can be saved to a stream through <B>SaveViewState</B><I> </I>and later reloaded from a stream with the same contents through <B>ApplyViewState</B>. The semantics of <B>ApplyViewState</B><I> </I>are encompassed in the <I>pstm </I>argument of <B>IOleDocument::CreateView</B>.</P>
<p>Finally, a container can create a duplicate view object to the current one with <I>Clone</I>.</P>
<H4> </A>IOleDocumentView::SetInPlaceSite</H4>
<pre><FONT FACE="Courier New" SIZE="3">HRESULT IOleDocumentView::SetInPlaceSite([in] IOleInPlaceSite *pIPSite)</font></pre>
<p>Associates a view site object with this view. If this member is called and the view already has an associated view site, the view must first deactivate itself in that site, release that site, then remember the new pointer if that pointer is non-NULL (save the value and call <I>AddRef </I>on the pointer). The container will tell the view when to activate itself in the new site.</P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="81pt" VALIGN="TOP"><COL WIDTH="130pt" VALIGN="TOP"><COL WIDTH="230pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Argument</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Type</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Description</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>pIPSite</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>IOleInPlaceSite *</B></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The interface pointer of the site to associate with this view. Can be NULL in which case the view loses all association with the container.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><p></P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="297pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Return Value</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Meaning</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>S_OK</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The site was successfully associated (or disassociated if <I>pIPSite </I>is NULL)</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>E_FAIL</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Another error occurred.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><p><B>Comments:</B></P>
<p>This function must be completely implemented in a view; therefore E_NOTIMPL is not an acceptable return code.</P>
<H4> </A>IOleDocumentView::GetInPlaceSite</H4>
<pre><FONT FACE="Courier New" SIZE="3">HRESULT IOleDocumentView::GetInPlaceSite([out] IOleInPlaceSite **ppIPSite)</font></pre>
<p>Returns the most recent <B>IOleInPlaceSite</B><I> </I>pointer passed to <B>SetInPlaceSite</B>, or NULL if <B>SetInPlaceSite</B><I> </I>has not yet been called.  The view will call <I>AddRef </I>on this pointer before returning it, thus the caller must later call <I>Release.</I></P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="81pt" VALIGN="TOP"><COL WIDTH="130pt" VALIGN="TOP"><COL WIDTH="230pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Argument</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Type</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Description</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>ppIPSite</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>IOleInPlaceSite **</B></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The address in which to return the current view site interface pointer associated with this view object.  The caller becomes responsible for this pointer.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><p></P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="297pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Return Value</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Meaning</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>S_OK</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The site was successfully returned.  The caller must call <I>Release </I>through this pointer when it is no longer needed.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>E_FAIL</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Another error occurred.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><p><B>Comments:</B></P>
<p>This function must be completely implemented in a view; therefore E_NOTIMPL is not an acceptable return code.</P>
<H4> </A>IOleDocumentView::GetDocument</H4>
<pre><FONT FACE="Courier New" SIZE="3">HRESULT IOleDocumentView::GetDocument([out] IUnknown **ppunk)</font></pre>
<p>Returns the <B>IUnknown</B><I> </I>interface pointer of the document object that owns this view. As a document owning the view must always exist, this function will always succeed, calling <I>AddRef </I>on the pointer stored in <I>*ppunk </I>before returning.</P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="81pt" VALIGN="TOP"><COL WIDTH="130pt" VALIGN="TOP"><COL WIDTH="230pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Argument</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Type</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Description</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>ppunk</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>IUnknown**</B></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The address in which to return the <B>IUnknown </B>pointer of the document object that owns this view.  The caller becomes responsible for this pointer.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><p></P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="297pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Return Value</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Meaning</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>S_OK</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The document object's interface pointer was successfully returned.  This is the only valid return code for this function.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><H4> </A>IOleDocumentView::SetRect</H4>
<pre><FONT FACE="Courier New" SIZE="3">[input_sync] HRESULT IOleDocumentView::SetRect([in] LPRECT prcView)</font></pre>
<p>Sets the rectangular coordinates of the view port in the client coordinates of the view window (the window is obtained through <B>IOleInPlaceSite::GetWindow</B>). The view must resize itself to view the new coordinates.</P>
<p>This member function is defined with the [input_sync] attribute, hence the implementing object cannot yield or make another non input_sync RPC call while executing this method.</P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="81pt" VALIGN="TOP"><COL WIDTH="130pt" VALIGN="TOP"><COL WIDTH="230pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Argument</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Type</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Description</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>prcView</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>LPRECT</B></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Points to a RECT structure containing the coordinates of the view port in the client coordinates of the view window.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><p></P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="297pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Return Value</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Meaning</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>S_OK</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The view was successfully resized to the rectangle.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>E_FAIL</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Some other critical error occurred that prevented resizing to occur.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><p><B>Comments:</B></P>
<p>This function must be completely implemented in a view; therefore E_NOTIMPL is not an acceptable return code.</P>
<H4> </A>IOleDocumentView::GetRect</H4>
<pre><FONT FACE="Courier New" SIZE="3">HRESULT IOleDocumentView::GetRect([out] LPRECT prcView)</font></pre>
<p>Returns the rectangular coordinates of the view port in the client coordinates of the view window, as was last specified through <B>IOleDocumentView::SetRect</B><I> </I>or <B>IOleDocumentView::SetRectComplex</B>.</P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="81pt" VALIGN="TOP"><COL WIDTH="130pt" VALIGN="TOP"><COL WIDTH="230pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Argument</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Type</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Description</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>prcView</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>LPRECT</B></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Points to a RECT structure to receive the current view coordinates.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><p></P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="297pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Return Value</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Meaning</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>S_OK</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The view was successfully resized to the rectangle.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>E_UNEXPECTED</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>This view has not yet seen a call to <B>IOleDocumentView::SetRect</B><I> </I>or <B>IOleDocumentView::SetRectComplex</B>, thus it has no rectangle to return.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><p><B>Comments:</B></P>
<p>This function must be completely implemented in a view; therefore E_NOTIMPL is not an acceptable return code.</P>
<H4> </A>IOleDocumentView::SetRectComplex</H4>
<pre><FONT FACE="Courier New" SIZE="3">[input_sync] HRESULT IOleDocumentView::SetRectComplex([in] LPRECT prcView, [in] LPRECT prcHScroll, [in] LPRECT prcVScroll, [in] LPRECT prcSizeBox)</font></pre>
<p>Sets the rectangular coordinates of the view port, horizontal and vertical scroll bars, and the size box. This method typically gets used by the view frames which have a workbook metaphor. However, not all DocObjects support these detailed specifications; those that do mark themselves with DOCMISC_SUPPORTCOMPLEXRECTANGLES as described in <B>IOleDocument::GetMiscStatus</B><I>. </I>DocObjects that do not support this member can return E_NOTIMPL.</P>
<p>Within this member, the view should resize itself according to <I>prcView</I> and fit its scrollbars and size box to the areas described in <I>prcHScroll, prcVScroll, </I>and <I>prcSizeBox, </I>respectively.</P>
<p>This member function is defined with the [input_sync] attribute, hence the implementing object cannot yield or make another non input_sync RPC call while executing this method.</P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="77pt" VALIGN="TOP"><COL WIDTH="130pt" VALIGN="TOP"><COL WIDTH="234pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Argument</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Type</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Description</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>prcView</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>[in] LPRECT</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Points to a RECT structure containing the coordinates of the view port in client coordinates of the view window.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>prcHScroll</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>[in] LPRECT</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Points to a RECT structure containing the coordinates of the horizontal scroll bar in client coordinates of the view window.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>prcVScroll</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>[in] LPRECT</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Points to a RECT structure containing the coordinates of the vertical scroll bar in client coordinates of the view window.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>prcSizeBox</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>[in] LPRECT</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Points to a RECT structure containing the coordinates of the size box in client coordinates of the view window.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><p></P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="297pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Return Value</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Meaning</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>S_OK</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The view was successfully resized to the rectangle.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>E_NOTIMPL</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The document object that owns this view does not support complex rectangle specifications.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>E_FAIL</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Some other critical error occurred that prevented resizing of the view or placement of the scrollbars and size box.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><H4> </A>IOleDocumentView::Show</H4>
<pre><FONT FACE="Courier New" SIZE="3">HRESULT Show ([in] BOOL fShow)</font></pre>
<p>Instructs a view to in-place activate or in-place deactivate itself as described in the following pseudo-code:</P>

<pre><FONT FACE="Courier New" SIZE="3">if (fShow) 
    {
    in-place activate the view but do not UI activate it.
    Show the view window. 
    {
else
    {
    call IOleDocumentView::UIActivate(FALSE) on this view
    Hide the view window
    }</font></pre>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="77pt" VALIGN="TOP"><COL WIDTH="90pt" VALIGN="TOP"><COL WIDTH="275pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Argument</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Type</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Description</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>fShow</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>BOOL</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>TRUE instructs the view to show itself, FALSE instructs the view to hide itself.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><p></P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="297pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Return Value</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Meaning</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>S_OK</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The view was successfully shown or hidden.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>E_OUTOFMEMORY</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>There was not enough memory to activate or hide the view.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>E_FAIL</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Some other critical error occurred that prevented activation or hiding.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>E_UNEXPECTED</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>This member was called before a call to <B>IOleDocumentView::SetInPlaceSite</B><I>.</I></P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><p><B>Comments:</B></P>
<p>All views of a document object must at least support the in-place activation mode, therefore E_NOTIMPL is not allowed as a return value.</P>
<H4> </A>IOleDocumentView::UIActivate</H4>
<pre><FONT FACE="Courier New" SIZE="3">HRESULT IOleDocumentView::UIActivate([in] BOOL fUIActivate)</font></pre>
<p>Instructs the view to activate or deactivate its user interface elements (menus, toolbars, accelerators) as described in the following pseudo-code:</P>

<pre><FONT FACE="Courier New" SIZE="3">if (fActivate)
    {
    UI activate the view (do menu merging, show frame level tools, process accelerators)
    Take focus, and bring the view window forward.
    }
else
    call IOleInPlaceObject::UIDeactivate() on this view</font></pre>
<p>The view may, and should, participate in extended Help menu merging if it desires.</P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="77pt" VALIGN="TOP"><COL WIDTH="90pt" VALIGN="TOP"><COL WIDTH="275pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Argument</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Type</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Description</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P> fActivate</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>BOOL</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>TRUE instructs the view to activate its UI, FALSE instructs the view to deactivate its UI.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><p></P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="297pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Return Value</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Meaning</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>S_OK</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The view's UI was successfully activated or deactivated.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>E_OUTOFMEMORY</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>There was not enough memory to activate the UI elements.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>E_FAIL</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Some other error occurred that prevented success.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>E_UNEXPECTED</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>This member was called before a call to <B>IOleDocumentView::SetInPlaceSite</B><I>.</I></P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><p><B>Comments:</B></P>
<p>All views of a document object must at least support the in-place activation mode, therefore E_NOTIMPL is not allowed as a return value.</P>
<H4> </A>IOleDocumentView::Open</H4>
<pre><FONT FACE="Courier New" SIZE="3">HRESULT IOleDocumentView::Open(void)</font></pre>
<p>Asks the view to display itself in a separate popup window with semantics equivalent to <B>IOleObject:;DoVerb(OLEIVERB_OPEN</B><B><I>)</I></B>. If the document object specified DOCMISC_CANTOPENEDIT through <B>IOleDocument::GetMiscStatus</B><I>, </I>this call can return E_NOTIMPL. Otherwise implementation generally calls the view's own <B>IOleInPlaceObject::InPlaceDeactivate</B> after which the view shows its separate popup window and brings that window to the foreground.</P>
<p>Contrary to the normal in-place deactivation sequence for OLE Documents, a view <I>continues to hold </I>the <B>IOleInPlaceSite</B><I> </I>pointer that it obtained in <B>IOleDocumentView::SetInPlaceSite</B><I> </I>(likewise the view site continues to hold the view's interface pointers, obviously). This pointer is only released through <B>IOleDocumentView::SetInPlaceSite(NULL</B><I>) </I>or in <B>IOleDocumentView::CloseView</B>.</P>
<p>When the user closes the view's window (via File.Close), then the view should not shut itself down. Instead it should call <I>pIPSite-&gt;OnInPlaceActivate. </I>The view site then decides whether to UI activate the view at that time or at a later time.</P>
<p>When the container decides that the view window is no longer needed, it calls <B>IOleDocumentView::CloseView</B><I>.</I> The view uses that call to determine when to release the site pointer and destroy the window.</P>
<p>It is legal for the container to call <B>IOleDocumentView::Show(FALSE)</B><I> </I>when the view is in this Open mode. In this case the view hides its window. Similarly, <B>IOleDocumentView::Show(TRUE)</B><I> </I>instructs the view to show the window again and bring it to the foreground.</P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="77pt" VALIGN="TOP"><COL WIDTH="90pt" VALIGN="TOP"><COL WIDTH="275pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Argument</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Type</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Description</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>NA</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>NA</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>NA</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><p></P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="297pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Return Value</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Meaning</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>S_OK</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The view successfully created its separate window.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>E_OUTOFMEMORY</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>There was not enough memory to activate the view in a separate window.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>E_FAIL</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Some other error occurred that prevented success.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>E_NOTIMPL</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The document object that owns this view does not support separate window activation.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>E_UNEXPECTED</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>This member was called before a call to <B>IOleDocumentView::SetInPlaceSite</B><I>.</I></P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><H4> </A>IOleDocumentView::CloseView</H4>
<pre><FONT FACE="Courier New" SIZE="3">HRESULT IOleDocumentView::CloseView([in] DWORD dwReserved)</font></pre>
<p>Asks the view to close down and release its <B>IOleInPlaceSite</B><I> </I>pointer obtained in <B>IOleDocumentView::SetInPlaceSite.</B> The container must call this method before it wants to delete the view (that is, release its last reference to the view). In general, implementation of this member will call <B>IOleDocumentView::Show (FALSE)</B> to hide the view if it's not already, then call <B>IOleDocumentView::SetInPlaceSite(NULL</B><I>)</I> to deactivate itself and release the view site pointer.</P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="77pt" VALIGN="TOP"><COL WIDTH="90pt" VALIGN="TOP"><COL WIDTH="275pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Argument</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Type</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Description</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>dwReserved</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>DWORD</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Reserved. Must be zero.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><p></P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="297pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Return Value</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Meaning</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>S_OK</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The view successfully closed itself.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><p><B>Comments:</B></P>
<p>Because <B>CloseView</B><I> </I>is called when the container wishes to completely shut down the view, this member must be implemented and has no reason to fail.</P>
<H4> </A>IOleDocumentView::SaveViewState</H4>
<pre><FONT FACE="Courier New" SIZE="3">HRESULT IOleDocumentView::SaveViewState([in] IStream *pstm)</font></pre>
<p>Instructs the view to save its state into the given stream, where the state includes properties like the view type, zoom factor, insertion point, and so on. The container typically calls this function before deactivating the view. The stream can then later be used to reinitialize a view of the same document to this saved state through <B>IOleDocumentView::ApplyViewState</B><I>.</I></P>
<p>The view must write its CLSID as the first element in the stream according to the rules that apply to <B>IPersistStream</B><I>. </I>Any cross-platform file format compatibility issues that apply to the document's storage representation also apply to this context.</P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="77pt" VALIGN="TOP"><COL WIDTH="162pt" VALIGN="TOP"><COL WIDTH="203pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Argument</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Type</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Description</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>pstm</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B><I>[in] IStream *</I></B></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Asks the view to save the view state into this stream.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><p></P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="77pt" VALIGN="TOP"><COL WIDTH="90pt" VALIGN="TOP"><COL WIDTH="275pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Argument</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Type</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Description</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>pstm</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>IStream *</B></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The stream in which the view should save its state.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><p></P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="297pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Return Value</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Meaning</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>S_OK</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The view successfully saved its state to the stream.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>E_POINTER</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The value in <I>pstm </I>is NULL.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>E_NOTIMPL</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>This view has no meaningful state to save; this should be a rare case as most views will have at least some information.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><H4> </A>IOleDocumentView::ApplyViewState</H4>
<pre><FONT FACE="Courier New" SIZE="3">HRESULT IOleDocumentView::ApplyViewState([in] IStream *pstm)</font></pre>
<p>Instructs a view to reinitialize itself according to the data in a stream that was previously written through <B>IOleDocumentView::SaveViewState</B><I>. </I>Typically this function is called when the view is being displayed for first time after its instantiation. It is the responsibility of the view to validate the data in the view stream as the container does not attempt to interpret view state stream data in any way.</P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="77pt" VALIGN="TOP"><COL WIDTH="90pt" VALIGN="TOP"><COL WIDTH="275pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Argument</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Type</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Description</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>pstm</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>IStream *</B></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The stream from which the view should load its state.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><p></P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="297pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Return Value</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Meaning</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>S_OK</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The view successfully loaded its state from the stream.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>E_POINTER</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The value in <I>pstm </I>is NULL.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>E_NOTIMPL</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>This view has no meaningful state that it would load; this should be a rare case as most views will have at least some information.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><H4> </A>IOleDocumentView::Clone</H4>
<pre><FONT FACE="Courier New" SIZE="3">HRESULT IOleDocumentView::Clone([in] IOleInPlaceSite *pIPSiteNew, [out] IOleDocumentView **ppViewNew)</font></pre>
<p>Creates a duplicate view object with an identical internal state to the current view. This is useful for creating a new view with a different view port and view site but with the same view context as the view being cloned. Typically this will be used to implement the "Window-New window" functionality.</P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="81pt" VALIGN="TOP"><COL WIDTH="162pt" VALIGN="TOP"><COL WIDTH="203pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Argument</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Type</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Description</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>pipsiteClone</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>[in] <B>IOleInPlaceSite *</B></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Pointer to the in-place site for the clone</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>ppviewClone</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>[out] <B>IOleDocumentView **</B></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The location where the pointer to the new view should be returned.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><p></P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="77pt" VALIGN="TOP"><COL WIDTH="99pt" VALIGN="TOP"><COL WIDTH="266pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Argument</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Type</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Description</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>pIPSiteNew</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>IOleInPlaceSite *</B></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The <B>IOleInPlaceSite</B> pointer of the view site to associate with the clone. The view being cloned should pass this to the new view's <B>IOleDocumentView::SetInPlaceSite</B> member. This can be NULL in which case the caller is responsible for calling <B>SetInPlaceSite </B>on this new view directly.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>ppViewNew</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>IOleDocumentView *</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The address of the variable to receive the pointer to the new view's <B>IOleDocumentView</B> interface. The caller is responsible for this pointer any must call Release through it when it is no longer needed.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><p></P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="297pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Return Value</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Meaning</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>S_OK</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The view successfully cloned.  The caller is responsible for the pointer in <B>*ppViewNew</B><I>.</I></P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>E_POINTER</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The value in <B>ppViewNew </B>is NULL.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><p><B>Comments:</B></P>
<p>Because the functionality of this member is nearly identical to <B>IOleDocument::CreateView,</B> it must be supported through a view object.  Therefore E_NOTIMPL is not allowed as a return code.</P>
<a name="#sec56"></a><h3>The IPrint<I> </I>Interface</H3><p>Any object that wishes to support programmatic printing can implement the <B>IPrint</B><I> </I>interface.  Through this interface a caller can tell the object to print, set the initial page number (for printing multiple documents together), and retrieve print-related information from the object:</P>
<p>IDL:</P>

<pre><FONT FACE="Courier New" SIZE="3">[
uuid(B722BCC9-4E68-101B-A2BC-00AA00404770)
    , object, pointer_default(unique)
]
interface IPrint : IUnknown
    {
    typedef [unique] IPrint *LPPRINT;

    typedef enum
        {
        PRINTFLAG_MAYBOTHERUSER        = 1,
        PRINTFLAG_PROMPTUSER           = 2,
        PRINTFLAG_USERMAYCHANGEPRINTER = 4,
        PRINTFLAG_RECOMPOSETODEVICE    = 8,
        PRINTFLAG_DONTACTUALLYPRINT    = 16,
        PRINTFLAG_FORCEPROPERTIES      = 32,
        PRINTFLAG_PRINTTOFILE          = 64
        } PRINTFLAG;

    typedef struct tagPAGERANGE
        {
        LONG nFromPage;
        LONG nToPage;
        } PAGERANGE;

    typedef struct tagPAGESET
        {
        ULONG cbStruct;
        BOOL  fOddPages;
        BOOL  fEvenPages;
        ULONG cPageRange;
        [size_is(cPageRange)] PAGERANGE rgPages[];
        } PAGESET;


    HRESULT SetInitialPageNum([in] LONG nFirstPage);
    HRESULT GetPageInfo([out] LONG *pnFirstPage, [out] LONG *pcPages);
    HRESULT Print([in] DWORD grfFlags, [in,out] DVTARGETDEVICE **pptd
        , [in,out] PAGESET **ppPageSet
        , [unique][in,out] STGMEDIUM *pstgmOptions
        , [in] IContinueCallback *pcallback, [in] LONG nFirstPage
        , [out] LONG *pcPagesPrinted, [out] LONG *pnLastPage);
    };

#define PAGESET_TOLASTPAGE ((WORD)(-1L))</font></pre>
<p>The structures of this interface will be described first, followed by the member functions.</P>
<H4> </A>PAGERANGE Structure</H4><p>Identifies a single range of pages.</P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="90pt" VALIGN="TOP"><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="341pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Member</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Type</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Description</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>nFromPage</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>LONG</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The first page to print. The first page of a document is 1.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>nToPage</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>LONG</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The last page to print. A special value of PAGESET_TOLASTPAGE indicates that all the remaining pages should be printed.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><H4> </A>PAGESET Structure</H4><p>Identifies a series of page-ranges and optionally identifies only the even or odd pages as part of this PAGESET.</P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="90pt" VALIGN="TOP"><COL WIDTH="77pt" VALIGN="TOP"><COL WIDTH="336pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Member</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Type</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Description</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>cbStruct</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>ULONG</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The number of bytes in this instance of the PAGESET structure. Must be a multiple of 4.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>fOddPages</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>BOOL</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>If true, then only the odd-numbered pages in the page-set indicated by rgPages are to be printed.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>fEvenPages</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>BOOL</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>If true, then only the even-numbered pages in the page-set indicated by rgPages are to be printed.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>cPageRange</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>ULONG</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The number of page-range pairs specified in rgPageRange.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>rgPageRange</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>PAGERANGE *</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Specifies the pages to be printed. The page ranges must be sorted in increasing order and non-overlapping. It is an error to attempt to print a page which does not exist.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><H4> </A>PRINTFLAG Enumeration</H4><p>A combination of values from PRINTFLAG is passed in as <B>grfFlags</B><I> </I>to <B>IPrint::Print</B>.</P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="212pt" VALIGN="TOP"><COL WIDTH="291pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Value</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Description</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>PRINTFLAG_MAYBOTHERUSER</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Specifies whether any interaction is permitted with the user at all. Unless this flag is set, no part of the printing process may interact with the user.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>PRINTFLAG_PROMPTUSER</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Only valid if PRINTFLAG_MAYBOTHERUSER is specified. Prompt the user for job-specific printing options using the normal print dialog for the object.  Support for this option is required.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>PRINTFLAG_USERMAYCHANGEPRINTER</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Only valid if PRINTFLAG_PROMPTUSER is specified. Indicates that the user may change the printer to be printed to; in the absence of this flag, the user must print on the printer provided.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>PRINTFLAG_RECOMPOSETODEVICE</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Indicates that the object should attempt to recompose itself to the indicated target device. In the absence of this flag, the object should retain any existing compositional-device association that it may happen to presently have if at all possible.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>PRINTFLAG_DONTACTUALLYPRINT</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Carry out any indicated user-prompting and object-recomposing actions as indicated, but don't actually carry out the printing operation.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>PRINTFLAG_PRINTTOFILE</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The object should print to the file, name of which is passed through "portname" field of DVTARGETDEVICE.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><H4> </A>IPrint::SetInitialPageNum</H4>
<pre><FONT FACE="Courier New" SIZE="3">HRESULT IPrint::SetInitialPageNum([in] LONG nFirstPage)</font></pre>
<p>Attempt to set the number of the first page of this document. Note that setting a negative first page number is legal. This may be useful in printing a portion of the document with offset page numbers from what it would normally print. Note also that not all implementations permit the initial page number to be set, as some implementations simply lack the information as to how this page information should be reflected in the final output.</P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="90pt" VALIGN="TOP"><COL WIDTH="54pt" VALIGN="TOP"><COL WIDTH="359pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Argument</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Type</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Description</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>nFirstPage</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>LONG</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The desired first page number.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><p></P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="297pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Return Value</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Meaning</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>S_OK</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The first page was set as requested.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>E_FAIL</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The first page could not be set to the indicated value.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>E_UNEXPECTED</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>An unknown error occurred.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><H4> </A>IPrint::GetPageInfo</H4>
<pre><FONT FACE="Courier New" SIZE="3">HRESULT IPrint::GetPageInfo([out] LONG *nFirstPage, [out] LONG *pcPages)</font></pre>
<p>Return information about the pages in the document.</P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="90pt" VALIGN="TOP"><COL WIDTH="54pt" VALIGN="TOP"><COL WIDTH="359pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Argument</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Type</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Description</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>pnFirstPage</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>LONG*</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Location to return the page number of the first page. May be NULL, indicating the caller doesn't need this number.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>pcPages</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>LONG*</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Location to return the total number of pages in this document. May be NULL, indicating the caller doesn't need this number.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><p></P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="126pt" VALIGN="TOP"><COL WIDTH="315pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Return Value</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Meaning</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>S_OK</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Success.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>E_UNEXPECTED</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>An unexpected error occurred.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><H4> </A>IPrint::Print</H4>
<pre><FONT FACE="Courier New" SIZE="3">HRESULT IPrint::Print([in] DWORD grfFlags, [in,out] DVTARGETDEVICE **pptd<BR>, [in,out] PAGESET **pppageset, [unique][in,out] STGMEDIUM *pstgmOptions<BR>, [in] IContinueCallback *pcallback, [in] LONG nFirstPage, [out] LONG *pcPagesPrinted<BR>, [out] LONG *pnLastPage)</font></pre>
<p>Print this object on the printer indicated by the <B>DVTARGETDEVICE</B> structure in <I>ptd</I>. The <B>DEVMODE</B> in the target device indicates whole-job printer-specific options, such as number of copies, paper size, or print quality. It may or may not also contain orientation information in the <I>dmOrientation </I>field (this is indicated in the <I>dmFields </I>field). If present, then this paper orientation should be used; if absent, then natural orientation as determined by the object content is to be used.</P>
<p>Due to the possibility of user input, the parameters <I>pptd </I>and <I>ppPageSet </I>are both [in,out] structures. In the absence of user interaction (that is, without PRINTFLAG_PROMPTUSER), both the target device and the page set will necessarily be the same on input and output. However, if the user is prompted for print options, then the object returns target device and page set information appropriate to what the user has actually chosen during interaction.</P>
<p><I>ppstgmOptions </I>is an [in,out] parameter. On exit, the object should return through <I>*ppstgmOptions </I>any object-specific information that it would need to reproduce this exact print job. Examples might include whether the user selected "sheet, notes, or both" in a spreadsheet application. The data returned is in the format of a serialized property set. The returned data can usually only be usefully used by passing it back in a subsequent call to the same object; however, that call may have different user interaction flags, different target device, etc. Thus, the caller can cause the exact same document to be printed multiple times in slightly different printing contexts.</P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="90pt" VALIGN="TOP"><COL WIDTH="113pt" VALIGN="TOP"><COL WIDTH="300pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Argument</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Type</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Description</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>grfFlags</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>DWORD</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>A bit field whose values are taken from the enumeration PRINTFLAG.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>pptd</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>DVTARGETDEVICE**</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The target device on which the printing is to occur.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>ppPageSet</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>PAGESET**</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Indicates which pages are to be printed.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>ppstgmOptions</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>STGMEDIUM**</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Contains object-specific printing options in the form of a serialized OLE property set.  May be NULL in one or both directions.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>pCallback</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>IContinueCallback*</B></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>A callback interface which is to be periodically polled at human-response speeds to determine whether printing should be abandoned. May be NULL.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>pcPagesPrinted</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>LONG*</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The place at which the object is to return the actual number of pages that were successfully printed.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>pnLastPage</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>LONG*</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The place at which the object is to return the last legal page number.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><p></P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="297pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Return Value</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Meaning</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>S_OK</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Success.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>PRINT_E_CANCELLED</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The print process was canceled. *pcPagesPrinted indicates the number of pages that were in fact successfully printed before this occurred.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>PRINT_E_NOSUCHPAGE</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>An attempt has been made to print a page which does not exist.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>E_UNEXPECTED</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>An unexpected error occurred.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><a name="#sec63"></a><h3>The IContinueCallback Interface</H3><p>This interface is a generic callback mechanism for interruptible processes that should periodically ask an object with this interface whether to continue the process. </P>
<p>IDL:</P>

<pre><FONT FACE="Courier New" SIZE="3">[
uuid(B722BCCA-4E68-101B-A2BC-00AA00404770)
    , object, pointer_default(unique)
]
interface IContinueCallback : IUnknown
    {
    HRESULT FContinue(void);
    HRESULT FContinuePrinting([in] LONG nCntPrinted
        , [in] LONG nCurPage, [unique][in] wchar_t *pszPrintStatus);
    }</font></pre>
<p>The <B>FContinue</B><I> </I>function is a generic continuation request. <B>FContinuePrinting </B>carries extra information pertaining to a printing process and is used in the context of <B>IPrint</B><I>.</I></P>
<H4> </A>IContinueCallback::FContinue</H4>
<pre><FONT FACE="Courier New" SIZE="3">HRESULT IContinueCallback::FContinue(void)</font></pre>
<p>Answer as to whether a given generic operation should continue.</P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="90pt" VALIGN="TOP"><COL WIDTH="90pt" VALIGN="TOP"><COL WIDTH="323pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Argument</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Type</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Description</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>NA</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>NA</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>NA</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><p></P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="297pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Return Value</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Meaning</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>S_OK</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Continue the operation.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>S_FALSE</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Cancel the operation as soon as possible.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><H4> </A>IContinueCallback::FContinuePrinting</H4>
<pre><FONT FACE="Courier New" SIZE="3">HRESULT IContinueCallback::FContinuePrinting(cPagesPrinted, nCurrentPage, wszPrintStatus)</font></pre>
<p>Answer as to whether a given lengthy printing operation should continue. Implementations of <B>IPrint</B><I> </I>call back on this method at periodic intervals during the printing process.  The <B>IPrint </B>implementation should call back at least after printing each page, so that its client can display useful visual feedback to the user. Further, the implementation can legally call back multiple times with the same <I>cPagesPrinted </I>and <I>nCurrentPage </I>values; this is sometimes useful when a page being printed is complex and it is appropriate to give the user a chance to cancel mid-page.</P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="90pt" VALIGN="TOP"><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="341pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Argument</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Type</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Description</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><I>cPagesPrinted</I></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>LONG</B></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The total number of pages printed so far.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><I>nCurrentPage</I></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>LONG</B></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The page number of the current page being printed.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><I>pszPrintStatus</I></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>LPOLESTR</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Status message about the print job which the recipient of this call may choose to display to the user.  May be NULL.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><p></P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="297pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Return Value</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Meaning</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>S_OK</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Continue printing.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>S_FALSE</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Cancel the print job as soon as possible.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>E_UNEXPECTED</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>An unknown error occurred.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><a name="#sec66"></a><h3>The IOleCommandTarget Interface</H3><p>The command dispatch interface <B>IOleCommandTarget</B><I> </I>defines a simple and extensible mechanism to query and execute commands which are defined as integer identifiers in a group. The group is identified itself with a GUID. The interface allows a caller to both query for support of commands within a group as well as to instruct the object to execute those commands.</P>
<p>IDL:</P>

<pre><FONT FACE="Courier New" SIZE="3">[
uuid(B722BCCB-4E68-101B-A2BC-00AA00404770)
    , object, pointer_default(unique)
]
interface IOleCommandTarget : IUnknown
    {
    typedef [unique] IOleCommandTarget *LPOLECOMMANDTARGET;

    typedef enum
        {
        OLECMDF_SUPPORTED   = 0x00000001,
        OLECMDF_ENABLED     = 0x00000002,
        OLECMDF_LATCHED     = 0x00000004,
        OLECMDF_NINCHED     = 0x00000008
        } OLECMDF;

    typedef struct _tagOLECMD
        {
        ULONG cmdID;
        DWORD cmdf;
        } OLECMD;

    typedef enum
        {
        OLECMDTEXTF_NONE   = 0,
        OLECMDTEXTF_NAME   = 1,
        OLECMDTEXTF_STATUS = 2
        } OLECMDTEXTF;

    typedef struct  _tagOLECMDTEXT
        {
        DWORD cmdtextf;
        ULONG cwActual;
        ULONG cwBuf;
        [size_is(cwBuf)] wchar_t rgwz[];
        } OLECMDTEXT;

    typedef enum
        {
        OLECMDEXECOPT_DODEFAULT      = 0,
        OLECMDEXECOPT_PROMPTUSER     = 1,
        OLECMDEXECOPT_DONTPROMPTUSER = 2,
        OLECMDEXECOPT_SHOWHELP       = 3
        } OLECMDEXECOPT;

    typedef enum
        {
        OLECMDID_OPEN           = 1,
        OLECMDID_NEW            = 2,
        OLECMDID_SAVE           = 3,
        OLECMDID_SAVEAS         = 4,
        OLECMDID_SAVECOPYAS     = 5,
        OLECMDID_PRINT          = 6,
        OLECMDID_PRINTPREVIEW   = 7,
        OLECMDID_PAGESETUP      = 8,
        OLECMDID_SPELL          = 9,
        OLECMDID_PROPERTIES     = 10,
        OLECMDID_CUT            = 11,
        OLECMDID_COPY           = 12,
        OLECMDID_PASTE          = 13,
        OLECMDID_PASTESPECIAL   = 14,
        OLECMDID_UNDO           = 15,
        OLECMDID_REDO           = 16,
        OLECMDID_SELECTALL      = 17,
        OLECMDID_CLEARSELECTION = 18,
        OLECMDID_ZOOM           = 19,
        OLECMDID_GETZOOMRANGE   = 20
        } OLECMDID;

    [input_sync] HRESULT QueryStatus([unique][in] const GUID *pguidCmdGroup
        , [in] ULONG cCmds, [in,out][size_is(cCmds)] OLECMD *prgCmds
        , [unique][in,out] OLECMDTEXT *pCmdText);
    HRESULT Exec([unique][in] const GUID *pguidCmdGroup
        , [in] DWORD nCmdID, [in] DWORD nCmdExecOpt
        , [unique][in] VARIANTARG *pvaIn
        , [unique][in,out] VARIANTARG *pvaOut);
    };</font></pre>
<H4> </A>OLECMDF Enumeration</H4><p>Values from the OLECMDF enumeration are used to fill the value of the <I>cmdf </I>field in OLECMD structures as passed to <B>IOleCommandTarget::QueryStatus</B>.</P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="126pt" VALIGN="TOP"><COL WIDTH="377pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Flag</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Description</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>OLECMDF_SUPPORTED</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The command is supported by this object.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>OLECMDF_ENABLED</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The command is available and enabled.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>OLECMDF_LATCHED</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The command is an on-off toggle and is currently on.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>OLECMDF_NINCHED</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The command is an on-off toggle but the state cannot be determined because the attribute of this command is found in both on and off states in the relevant selection. This state corresponds to an "indeterminate" state of a 3-state checkbox, for example. </P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><H4> </A>OLECMD Structure</H4><p>The OLECMD structure is used to associate command flags from the OLECMDF enumeration with a command identifer through <B>IOleCommandTarget::QueryStatus</B>.</P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="59pt" VALIGN="TOP"><COL WIDTH="117pt" VALIGN="TOP"><COL WIDTH="327pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Field</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Type</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Decryption</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>cmdID</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>ULONG</B></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>A command identifier.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>cmdf</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>DWORD</B></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Flags associated with <I>cmdID </I>taken from the OLECMDF enumeration.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><H4> </A>OLECMDTEXTF Enumeration</H4><p>Values from the OLECMDTEXTF enumeration are used to describe what a command target object should store in the OLECMDTEXT structure passed to <B>IOleCommandTarget::QueryStatus</B>. One value from this enumeration is stored in the <I>cmdtextf </I>of the structure to indicate the desired information.</P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="131pt" VALIGN="TOP"><COL WIDTH="372pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Flag</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Description</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>OLECMDTEXTF_NONE</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>No extra information is requested.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>OLECMDTEXTF_NAME</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The object should return the localized name of the command.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>OLECMDTEXTF_STATUS</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The object should return a localized status string for the command.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><H4> </A>OLECMDTEXT Structure</H4><p>Used to return a text name or a status string for a single command identifier when used with <B>IOleCommandTarget::QueryStatus</B>.</P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="59pt" VALIGN="TOP"><COL WIDTH="117pt" VALIGN="TOP"><COL WIDTH="327pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Field</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Type</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Description</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>cmdtextf</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>DWORD</B></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Filled on input; a value from the OLECMDTEXTF enumeration describing the information the caller wishes to receive in return.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>cwActual</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>ULONG</B></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Filled on output; the number of characters actually written into the rgwz buffer before the function returns.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>cwBuf</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>ULONG</B></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Filled on input; the size of the string buffer in cwBuf.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>rgwz</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>wchar_t</B></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>A caller allocated array of wide characters to receive the string on output.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><H4> </A>OLECMDEXECOPT Enumeration</H4>
<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="207pt" VALIGN="TOP"><COL WIDTH="296pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Flag</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Description</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>OLECMDEXECOPT_PROMPTUSER</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Execute the command after taking user input.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>OLECMDEXECOPT_DONTPROMPTUSER</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Execute the command without prompting the user For example, clicking on the Print toolbar button causes the document to be immediately printed without requiring the user input. </P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>OLECMDEXECOPT_DODEFAULT</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Caller is not sure whether the user should be prompted or not.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>OLECMDEXECOPT_SHOWHELP</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Object should show Help for the corresponding command and not execute.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><H4> </A>OLECMDID Enumeration</H4><p>See below under "Standard Command List."</P>
<H4> </A>IOleCommandTarget::QueryStatus</H4>
<pre><FONT FACE="Courier New" SIZE="3">[input_sync] HRESULT QueryStatus([unique][in] const GUID *pguidCmdGroup, [in] ULONG cCmds, [in,out][size_is(cCmds)] OLECMD *prgCmds , [unique][in,out] OLECMDTEXT *pCmdText);</font></pre>
<p>Queries the object for the status of one or more commands, typically used in WM_INITMENU or WM_INITMENUPOPUP messages, enabling the caller to disable those commands that would be routed to the object but that are not available. The caller passes an array of OLECMD structures in <I>prgCmds </I>that describe the commands of interest from the group specified in <I>pguidCmdGroup</I>, where each structure's <I>cmdID </I>is set to a command identifier and the <I>cmdf </I>field is set to zero. The object receiving the call the fills the <I>cmdf </I>field for each command with bits taken from the OLECMDF enumeration to describe the status of each command.</P>
<p>The caller can also use this method to get the name or status text of a single command. The called object should first mark the command as described above. If the command is supported (OLECMDF_SUPPORTED) then the object should check the OLECMDTEXTF flags in the OLECMDTEXT structure.  If the OLECMDFTEXF_NAME flag is specified, then the object should copy the localized name of the command (for example, "Open", "Copy", etc.) into the <I>rgwz</I> field of OLECMDTEXT, paying attention to the size specified by the <I>cwBuf</I> field in that same structure<I>.</I></P>
<p>If, however, the caller specifies OLECMDFTEXTF_STATUS then the object should instead copy a localized status string for the command into the <I>rgwz</I> field. The status string is typically contextual, and it depends on the state of the command such as enabled/disabled. If the buffer is not big enough then the object should zero terminate the buffer. Whether the buffer is big enough or not the object must return the total actual size of the string(s), that he attempted to copy, via <I>cwActual</I> field.</P>
<p>If the command array contains more than one command, then the textual information should be returned for the first command in the command array that the object supports. Typically this functionality is used to show the status text of a command. Note that the caller can use a stack or global variable for <I>rgwz</I>, it not be dynamically allocated memory.</P>
<p>This member function is defined with the [input_sync] attribute, hence the implementing object cannot yield or make another non input_sync RPC call while executing this method.</P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="90pt" VALIGN="TOP"><COL WIDTH="90pt" VALIGN="TOP"><COL WIDTH="323pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Argument</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Type</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Description</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>pguidCmdGroup</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>const GUID *</B></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Unique identifier of the command group which can be NULL to specify the standard group.  All the commands that are passed in the rgCmds array must belong to this group.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>cCmds</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>ULONG</B></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The number of commands in the prgCmds array.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>prgCmds</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>OLECMD *</B></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>An caller-allocated array of OLECMD structures where the cmdID fields of the structures initialized with the commands being queried.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>pcmdText</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>OLECMDTEXT *</B></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Pointer to the structure in which to return name and/or status information.  Can be NULL to indicate that the caller is not interested in such information.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><p></P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="176pt" VALIGN="TOP"><COL WIDTH="265pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Return Value</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Meaning</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>S_OK</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The command status as any optional strings were returned successfully.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>E_POINTER</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The <I>prgCmds </I>argument is NULL.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>E_UNEXPECTED</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>An unexpected error occurred.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>E_FAIL</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>An error occurred.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>OLECMDERR_E_UNKNOWNGROUP</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><I>pguidCmdGroup </I>is non-NULL but does not specify a recognized command group.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><p><B>Comments:</B></P>
<p>A command target must implement this function; therefore E_NOTIMPL is not a valid return code.</P>
<H4> </A>IOleCommandTarget::Exec</H4>
<pre><FONT FACE="Courier New" SIZE="3">HRESULT Exec([unique][in] const GUID *pguidCmdGroup, [in] DWORD nCmdID<BR>, [in] DWORD nCmdExecOpt, [unique][in] VARIANTARG *pvaIn<BR>, [unique][in,out] VARIANTARG *pvaOut)</font></pre>
<p>Executes a specified command or displays Help for a command. As in the case of <B>IOleCommandTarget::QueryStatus</B><I>, </I>the <I>pguidCmdGroup</I> and <I>nCmdID</I> arguments uniquely identify the command to invoke. The exact action to take is specified in <I>nCmdExecOpt</I> (see the OLECMDEXECOPT enumeration for more details).</P>
<p>Most of the commands take no arguments nor do they return any values. Hence, for the majority of the commands the caller can pass NULLs for <I>pvaIn</I> and <I>pvaOut</I>. For the commands which expect one or more input value, the caller can declare and initialize a VARIANTARG variable and pass a pointer to that variable in <I>pvaIn. (</I>VARIANTARG is defined in OLE Automation.)<I> </I>If the input to the command is a single value, then the argument can be stored directly in the VARIANTARG and passed to the function. If the command expects multiple arguments then they must be packaged appropriately within the VARIANTARG using one of the supported types, such as<B><I> Idispatch </I></B>or<I> </I><B>SAFEARRAY</B>. </P>
<p>Similarly, if a command returns one or more arguments the caller is expected to declare a VARIANTARG, initialize it to VT_EMPTY, and pass its address in <I>pvaOut. </I>If the command returns a single value then the object can store that value directly in <I>pvaOut. </I>If the command has multiple output values then it will package those in some way appropriate for the VARIANTARG.<I> </I></P>
<p>Note that both <I>pvaIn</I> and <I>pvOut </I>are caller-allocated, thus stack variables are perfectly usable. For commands that take zero or one argument on input and return zero or one values, then no extra memory allocation is necessary. (Most of the types supported by VARIANTARG do not require memory allocation, few of the exceptions are SAFEARRAY and BSTR. For the complete list, see OLE documentation.) The caller and callee can use stack variables.</P>
<p>The list of <I>in</I> and <I>out</I> arguments of a command and how they are packaged is unique to each command; such information should be documented with the specification of the command group (see the Zoom command later in this section). In the absence of any specific information the command is assumed to take no arguments and have no return value. </P>

<TABLE COLS="3" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="90pt" VALIGN="TOP"><COL WIDTH="86pt" VALIGN="TOP"><COL WIDTH="327pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Argument</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Type</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Description</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><I>pguidCmdGroup</I></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>const GUID *</B></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Unique identifier of the command group which can be NULL to specify the standard group. The command passed in nCmdID must belong to this group.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><I>nCmdID</I></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>DWORD</B></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The command to execute which must be in the group specified with pguidCmdGroup.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><I>nCmdExecOpt</I></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>DWORD</B></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>One or more values from the OLECMDEXECOPT enumeration describing how the object should execute the command.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><I>pvaIn</I></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>VARIANTARG *</B></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Pointer to a VARIANTARG containing input arguments. Can be NULL.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><I>pvaOut</I></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><B>VARIANTARG *</B></P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Pointer to a VARIANTARG to receive the output return values. Can be NULL.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><p></P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="171pt" VALIGN="TOP"><COL WIDTH="270pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Return Value</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Meaning</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>S_OK</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The command was executed successfully.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>E_UNEXPECTED</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>An unexpected error occurred.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>E_FAIL</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>An error occurred</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>OLECMDERR_E_UNKNOWNGROUP</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P><I>pguidCmdGroup </I>is non-NULL but does not specify a recognized command group.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>OLECMDERR_E_NOTSUPPORTED</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The <I>nCmdID </I>argument is not recognized as a valid command in the group identified with <I>pguidCmdGroup</I>.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>OLECMDERR_DISABLED</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The command identified with <I>nCmdID</I> is currently disabled and cannot be executed.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>OLECMDERR_NOHELP</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The caller has asked for help on the command identified by <I>nCmdID</I> but no help is available.</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>OLECMDERR_CANCELED</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>The user canceled the execution of the action.</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><p><B>Comments:</B></P>
<p>A command target must implement this function; therefore E_NOTIMPL is not a valid return code.</P>
<H4> </A>Standard Command List</H4><p>Following is the list of standard commands that have been defined by Office 95 which are identified as the group with a NULL GUID (that is, <I>pguidCmdGroup</I> as passed to <B>IOleCommandTarget::Exec </B>is NULL; this is not the same as GUID_NULL, which is <I>not </I>used in this context).</P>

<TABLE COLS="2" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="152pt" VALIGN="TOP"><COL WIDTH="290pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Identifier</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Description</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>OLECMDID_OPEN</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>File Open</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>OLECMDID_NEW</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>File New</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>OLECMDID_SAVE</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>File Save</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>OLECMDID_SAVEAS</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>File Save As</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>OLECMDID_SAVECOPYAS</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>File Save Copy As</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>OLECMDID_PRINT</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>File Print</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>OLECMDID_PRINTPREVIEW </P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>File Print Preview</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>OLECMDID_PAGESETUP</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>File Page Setup</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>OLECMDID_SPELL</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Tools Spelling</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>OLECMDID_PROPERTIES</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>File Properties</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>OLECMDID_CUT</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Edit Cut</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>OLECMDID_COPY</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Edit Copy</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>OLECMDID_PASTE</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Edit Paste</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>OLECMDID_PASTESPECIAL</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Edit Paste Special</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>OLECMDID_UNDO</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Edit Undo</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>OLECMDID_REDO</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Edit Redo</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>OLECMDID_SELECTALL</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Edit Select All</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>OLECMDID_CLEARSELECTION </P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Edit Clear</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>OLECMDID_ZOOM </P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>View Zoom (see below for details)</P></td>

</TR><TR><TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>OLECMDID_GETZOOMRANGE</P></td>

<TD VALIGN="TOP"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P>Retrieves zoom range applicable to View Zoom (see below for details)</P></td>

</TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><H4> </A>The Zoom Commands</H4><p>Under normal OLE Documents functionality, when an object being edited in-place is disabled, its Zoom control on its toolbar and its View.Zoom menu are disabled, because logically the Zoom applies to the container document and not the object. With the OLECMDID_ZOOM and OLECMDID_GETZOOMRANGE commands in the standard set for <B>IOleCommandTarget</B><I>, </I>the object now has a means through which it can notify the container's frame object (the one with IOleInPlaceFrame<I> </I>as well as <B>IOleCommandTarget</B>, if supported) as well as retrieve the zoom range that it should display in its user interface.</P>
<H5 CLASS="h4"> </A>OLECMDID_ZOOM</H5><p>The OLECMDID_ZOOM command takes one LONG argument as input and returns one LONG argument on output.  This command is used for three purposes:</P>
<ul><li><I>To query the current zoom value</I> the caller passes OLECMDEXECOPT_DONTPROMPTUSER as the execute option in <I>nCmdExecOpt </I>and NULL for <I>pvIn</I>. The object returns the current zoom value in <I>pvaOut</I>. When the object goes UI active, it retrieves the current zoom value from the container's frame object using this same mechanism and updates its zoom control with the returned value. </LI><li><I>To display the Zoom dialog box</I> the caller passes OLECMDEXECOPT_PROMPTUSER in <I>nCmdExecOpt</I>. The caller can optionally pass the initial value for the dialog box through <I>pvaIn</I>, otherwise <I>pvaIn</I> must be NULL. If the user presses CANCEL, the object returns OLECMDERR_E_CANCELED; if the user presses OK, then the object returns the user selected value in <I>pvaOut.</I> When user selects the View.Zoom menu item, the object calls container's frame object in the same manner. The container then zooms the document to the user-selected value, and the object updates its Zoom control with that value.</LI><li><I>To set a Zoom value</I> the caller passes OLECMDEXECOPT_DONTPROMPTUSER in <I>nCmdExecOpt </I>and passes the zoom value to apply through <I>pvaIn. </I>The object validates and normalizes the new value and returns the validated value in <I>pvaOut. </I>When the user selects a new zoom value (using the Zoom control on the toolbar for instance) the object calls the container's frame object in this manner. The container zooms the document to the normalized value and object updates the Zoom control with that value.</LI></UL></SPAN><H5 CLASS="h4"> </A>OLECMDID_GETZOOMRANGE</H5><p>The OLECMDID_GETZOOMRANGE command is used to determine the range of valid zoom values from a command target object. The caller passes MSOCMDEXECOPT_DONTPROMPTUSER in <I>nCmdExecOpt</I> and NULL for <I>pvaIn</I>. The object returns its zoom range as a DWORD in <I>pvaOut</I> where the HIWORD contains the maximum zoom value and the LOWORD contains the minimum zoom value. Typically, this command is used when the user drops down the Zoom control on the toolbar of the UI active object. The applications and objects that support this command are required to support all the integral zoom values that are within the (min,max) pair they return.</P>
<a name="#sec79"></a><H2>Appendix:  Office Binder Issues</H2><p>This short appendix describes some of the details concerning Office Binder's implementation of programmatic printing. In addition, one other note is worth mention which is that Binder allows the user to open a document object into a separate window (the semantics of <B>IOleDocumentView::Open</B>). It is recommended that Office-compatible DocObjects support separate window activation if possible.</P>
<p>As for printing, Binder uses <B>IPrint</B><I> </I>for Binder level printing, thus DocObjects that wish to work well with Binder must implement <B>IPrint</B><I>. </I>The Binder supports two distinct levels of printing. At the Binder level, users can print multiple sections. At the section level, only the selected section will be printed (implemented via the <B>IOleCommandTarget</B><I> </I>interface).</P>
<H3> </A>Binder Level Printing</H3><p>When printing a section of the Binder level, the Binder will be responsible for displaying the user interface elements that are related to print progress, canceling of the print job, and so forth. This will be indicated by the absence of the PRINTFLAG_MAYBOTHERUSER flag in the call to <B>IPrint::Print</B>. The Binder is always going to call <B>IPrint::Print</B><I> </I>with PRINTFLAG_RECOMPOSETODEVICE bit set. Depending on the user's selection, the Binder may set the DM_COLLATE and DM_COPIES bits of <I>dmFields</I> field of DVTARGETDEVICE.  When DM_COPIES bit is set then the <I>dmCopies</I> field contains the number of copies that need to be printed. The document object being printed must look at these fields and use the information they contain when it prints. </P>
<p>When the user selects the Print to file<I> </I>option in the print dialog box, the Binder will call<I> </I><B>IPrint::Print </B>with PRINTFLAG_PRINTTOFILE and it will pass the name of the file (into which the document object must print) through the "<I>portname" </I>field of DVTARGETDEVICE. The document object can then put that file name in the DOCINFO structure, and pass it to the Win32 StartDoc API as part of the printing process. This will take handle the "Print to file" request.</P>
<H3> </A>Section Level Page Setup and Printing</H3><p>A user can opt to perform Page Setup and Printing at the section level. When Page Setup is chosen, the Binder will call the <B>IOleCommandTarget::Exec</B><I> </I>method with OLECMDID_PAGESETUP.  This indicates that the object should prompt the user for page-specific options using its Page Setup dialog. </P>
<p>Similarly when printing a section at the section level, the Binder will call the <B>IOleCommandTarget::Exec</B><I> </I>method with OLECMDID_PRINT, indicating that printing is to be performed. The document object should prompt the user with its File/Print dialog and use its own settings to perform the print job.</P>
<p>During section level printing the object should display any user interface elements that are needed by the user&mdash;print job status, cancellation buttons, etc.).</P>
<H3> </A>Calling IContinueCallback::FContinuePrinting</H3><p>During Binder-level printing, it is important for DocObjects to call <B>IContinueCallback::FContinuePrinting</B><I> </I>often, so that the Binder can response quickly if the user presses the Cancel button in the Binder's print dialog box. The document object must call at least once for each page that it is printing. If a specific page will take a long time to compose and print, then the document object should call more often to assure a timely response to the user's commands.</P></BODY></HTML>
