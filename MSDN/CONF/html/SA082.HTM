 <HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Local Data Management Features</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>	<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>


	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<h3>Local Data Management Features</H3><H4> </A>Database Engine Capabilities</H4><p><B>Table-level validation</B>: In Access version 1.1, the forms inherited the validations specified in the tables. Validation is now enforced from the engine. This includes:</P>
<P>Normal validation rules/expressions set in tables.</P>
<P>REQUIRED &lt;yes/no&gt;&mdash;set if data must be entered in a field when adding a record.</P>
<P>ALLOWZEROLENGTH &lt;yes/no&gt;&mdash;Use in conjunction with REQUIRED to enable differentiation between information that doesn't exist (zero length string) and information that may exist, but is unknown (Null).</P>
<p><B>Rushmore</B><B>&trade;</B><B> optimization</B>: Improved speed when performing optimizable queries. Optimizable queries consist of the ability to use set operations against indexes to quickly find a set of records. See the attached<I> Rushmore Query Optimization in the Jet Database Engine Version 2.0,</I> by Neil Black, for details.</P>
<p><B>Updateability</B>: Now both sides of joins are updateable. Updateable views become very powerful and intuitive. The 'updatability' matrix is significantly simpler (See <I>Updating Underlying Tables</I> in the on-line help). This new functionality will save developers hundreds of lines of code because they no longer have to hand code this functionality into their applications.</P>
<p><B>Cascading updates and deletes:</B> With cascading updates and deletes, you can now update or delete a field in a table and have related fields automatically updated or deleted as well. This is a powerful feature that further eliminates the need for code to synchronize data changes.</P>
<p><B>Query on top values</B>: View the most important data in a query by setting the top values (or top percent) to be returned. This is difficult to do in other query tools.</P>
<p><B>Elimination of the 4 megabyte transaction limitation</B>: Transaction space could run out in Access version 1.1 on queries that updated a lot of data; his limit has been eliminated.</P>
<p><B>Support for union queries: </B>Enables you combine fields from two or more tables or queries. When you run a union query, it returns the records from corresponding fields in the included tables or queries. For example, you can find companies that exist in both a customer table and a vendor table.</P>
<p><B>Support for sub queries: </B>You can now use SQL SELECT statements as subqueries within your expressions in the Criteria row of the Query window. This makes it easy for developers to create complex queries and return only the desired information.</P>
<H5>Data Access Objects</H5><p>Using Access Basic, you can now define and manage a wide variety of objects, including tables, queries, fields, indexes, relationships, forms, reports, and controls. Microsoft&nbsp;Access version 2.0 provides data access objects in Access Basic to use when programmatically defining, manipulating, and controlling your database system. Data access objects provide the operations generally included in the Data Definition Language, Data Manipulation Language, and Data Control Language components of SQL.</P>
<p>Data access objects provide an object-oriented data access hierarchy. All objects now have methods and properties. For example, <B>Dynaset</B>, <B>Snapshot</B>, and <B>Table</B> now are a type of <B>Recordset</B>. Each <B>Recordset </B>type has its own properties and methods. This is a more structured and intuitive programming paradigm.</P>
<p>The following chart illustrates the new object hierarchy (taken from the Access <I>Building Applications</I> user document).</P>
<P><img src="40052.gif"></P>
<BR>Increased programmatic control over engine features through data access objects including:</BR>
<UL><LI>Security</LI>
<LI>DDL</LI>
<LI>Relationships</LI>
<LI>New data objects (User, Group, Containers)</LI>
<LI>Pass-through properties</LI>
<LI>Multiple distinct transactions available through Access to Jet Workspaces</LI>
<LI>Programmatic control over ODBC attachments: </LI>
<LI>Local data buffering optimizes data access and scrolling (see Network Traffic Management below)</LI>
<LI>Management of attachments and SQL pass-through to refresh links or develop SQL pass-through calls.</LI></UL>
<H5>New Security Features</H5>
<BR>You can now set permissions on who can open a database; shared or exclusively, or open at all.</BR>
<UL><LI>Row or column level security is possible by granting access to pre-defined queries only. This was not so for Access version 1.1 on attached Jet tables.</LI>
<LI>Increased length of PINs, as well as allowing alphanumerics in the PIN, provides greater security.</LI></UL>
<H5>SQL Pass-through Support</H5>
<BR>SQL pass-through is completely integrated into the Access User Interface (UI). This is a huge gain for our client-server message. This enables Access to call server stored procedures and to be able to use non-standard SQL syntax and return the results directly into an Access object.</BR>
<UL><LI>Both row-returning and non-row-returning SPT queries are supported.</LI>
<LI>Pass-through queries are populated on-demand, for faster open and for less network traffic.</LI>
<LI>A row-returning pass-through query is just like a <B>Snapshot</B>; you can use it as the basis for queries, forms, reports, lists and combo-boxes, and in data access objects.</LI>
<LI>Pass-through queries can optionally log server warning and informational messages into a Jet table.</LI>
<LI>Pass-through queries that return multiple result sets are stored in multiple Jet tables.</LI>
<LI>The connect-string builder relieves the user of having to enter arcane ODBC connect strings.</LI></UL>
<H4>Client/Server Data Management Features</H4>
<H5>Remote Transaction Management</H5>
<BR>High-integrity transaction processing applications are now possible through the ability to group transactions in data access objects that properly propagate to the server. These cases now work (they didn't use to).</BR>
<P></P>
<pre><FONT FACE="Courier New" SIZE="3">BeginTrans
Set ds = d.CreateDynaset("select * from authors")
ds.Delete
ds.Close
CommitTrans/Rollback

BeginTrans
d.Execute ("UPDATE Accounts1 SET Balance = Balance + 10")
d.Execute ("UPDATE Accounts2 SET Balance = Balance - 10")
CommitTrans/Rollback</font></pre>
<H5>Server Updatability</H5><p><B>Updateable server views</B>: Server views were strictly read-only in Access version 1.1. Attached views can now be made updateable by creating an index specification on them. This is a big hit for companies that like to use server views for security.</P>
<p><B>Row reselect</B>: Jet can now deal elegantly with a server based trigger that changes the primary key of a table when a record is inserted (similar to a counter field on SQL Server). It does this by automatically re-selecting the new row. Access used to show these rows as "#DELETED."</P>
<H5>Improved Transaction Speed</H5><p><B>Custom update</B>: Updates in datasheets/forms no longer update all columns. Only the columns actually edited will be included in the UPDATE statement sent to the server. This lessens network traffic (especially when memos and OLE objects have not been changed), and prevents gratuitous server-based trigger firing.</P>
<p><B>Custom insert</B>: Inserts in datasheets/forms no longer insert all columns. Only the non-NULL columns will be included in the INSERT statement sent to the server. This reduces network traffic and prevents overwriting of server-based default values. The server-based default values will appear in the datasheet as soon as the new row is saved.</P>
<H5>Improved ODBC Driver Support</H5><p>ODBC Drivers with a CURSOR_COMMIT_BEHAVIOR or CURSOR_ROLLBACK_BEHAVIOR value of zero were read-only in Jet version 1.1, and may now be updateable.</P>
<UL><LI>Single connection drivers linked to servers that required multiple connections for updateabiliy can now be used in read-only mode rather than not at all.</LI>
<LI>The ODBC type SQL_TIME is now mapped to Text, rather than DateTime. Access does not have a time field, and mapping it to DateTime produces garbage. Also, restrictions involving constant date-values and time-values work properly.</LI></UL>
<H5>Connection Management</H5>
<BR><B>More aggressive connection time-out</B>: Connections will now be timed-out even if they are being used by a datasheet, form, data access objects, and so on. Only two things prevent a connection from being timed-out:</BR>
<OL><LI>A pending transaction</LI>
<LI>Unfetched results on a query</LI></OL>
<P><B>Automatic reconnection</B>: Connections that have been timed out will automatically be re-connected when needed.</LI>
<P><B>Delayed connection:</B> Servers that do not allow multiple statements on a connection (such as SQL Server) require two connections to browse a dynaset. A new delayed-connection algorithm allows small <B>Dynasets</B> (less than 100 rows) to be browsed on a single connection, even against such servers.</P>
<H5>Network Traffic Management</H5><p>Network traffic is a continual concern in client/server computing. Now, Jet enables the user to manage default Access behavior to optimize network traffic for his environment.</P>
<p><B>Configurable background-population</B>: Two new settings in the server-based MSysConf configuration table control how fast Access does background-population of query results. This setting controls the behavior of all connections to that server.</P>
<P></P>
<pre><FONT FACE="Courier New" SIZE="3">FetchDelay    how often to fetch another chunk of query results &lt;default = 10 seconds&gt;
FetchRows    how many rows to fetch in a chunk &lt;default = 100 rows&gt;</font></pre>
<p><B>Programmatic control over data caching</B>: Remote data caching is available through data access objects, using the CacheStart, CacheSize properties, and the FillCache method. Now the application can be highly optimized when repeatedly referencing a heavily used data set. This also allows for more efficient "chunk-fetching" of <B>Dynaset </B>results in data access objects.</P>
<H5>Query Optimization</H5><p>New query optimization techniques will have a significant impact on the usability and processing speed of queries to remote tables.</P>
<p><B>Inferred parameter data types</B>: It's no longer necessary to explicitly declare query parameters against ODBC data. Jet will now infer the parameter type from its surrounding expression context, and send such restrictions to the server for processing. This has been one of the most undiscovered and difficult problems for client/server processing because undeclared parameters caused local query processing in Access version 1.1.</P>
<p><B>Remote index joins: </B>Remote index joins dramatically speed heterogeneous queries and reduces network traffic. When a large server table is joined to a small local table on an indexed column, the large server table is not completely fetched and joined locally, as in Access version 1.1. Now only the rows needed are fetched, based on the keys in the small local table and any additional restrictions on the remote table are also sent to the server.</P>
<BR><B>Constant sub-expressions</B> are internally changed into query parameters. This means that a user-defined function, expression, or domain function not involving any remote columns will be evaluated once, and sent to the server as a query parameter. This allows queries to analyze and change parameters before sending them remotely.</BR>
<UL><LI>Other operations now sent to the server:</LI>
<LI>Queries containing subqueries </LI>
<LI>Unions</LI>
<LI>Conversions functions (CInt, CLng, CSng, CDbl, CCur, CStr, CVDate)</LI>
<LI>Multi-column outer joins (Access version 1.1 supported only single-column outer joins)</LI>
<LI>A single outer join along with any number of inner joins. Access version 1.1 sent only multiple inner joins, or a single outer join, but did not send both in the same query to the server.</LI>
<LI>The LIKE operator is always sent to the server, if supported. Access version 1.1 sent only simple LIKE expressions.</LI>
<LI>The LIKE operator is always sent to the server along with any wildcard characters. Access version 1.1 translated wildcards in literal strings, but not within input parameters. This allows queries such as:</LI>
<BR><FONT FACE="Courier New" SIZE="2"><B>SELECT RemoteTable.*<BR>FROM RemoteTable<BR>WHERE RemoteColumn LIKE [QueryParameter]</B></FONT></BR><UL></BODY></HTML>
