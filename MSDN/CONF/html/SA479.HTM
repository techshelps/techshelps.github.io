<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Dynamic Load Balancing</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>	<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>


	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<h3>Dynamic Load Balancing</H3><P>Static load balancing is a good technique for dealing with growing user demand, but it requires the intervention of an administrator and works well only for predictable loads.</P>
<P>The idea of the referral component can be used to provide more intelligent load balancing. Instead of just basing the choice of server on the user ID, the referral component can use information about server load, network topology between client and available servers, and statistics about past demands of a given user. Every time a client connects to a component, the referral component can assign it to the most appropriate server available at that moment. Again, from the client's point of view this all happens transparently. This method is called dynamic load balancing.</P>
<P>For some applications, dynamic load balancing at connection time may not be sufficient. Clients may not typically disconnect for long periods of time, or demand may be unevenly distributed among users. DCOM does not, by itself, provide support for this kind of dynamic reconnection and distribution of method invocations, since doing so requires intimate knowledge of the interaction between client and component: The component typically retains some client-specific status information (state) between method invocations. If DCOM suddenly reconnected the client to a different component on another machine, this information would be lost. </P>
<P>However, DCOM makes it easy for application designers to introduce this logic explicitly into the protocol between client and component. The client and the component can have special interfaces to decide when a connection can safely be rerouted to another server without loss of any critical state information. At this point, either the client or the component can initiate a reconnection to another component on another machine before the next method invocation. DCOM provides all the rich protocol extensibility mechanisms necessary to implement these additional application-specific protocols.</P>
<P>The DCOM architecture also permits injecting component-specific code into the client process. Whenever the client invokes a method, a proxy component provided by the real component intercepts this invocation in the client process and can reroute it to other servers. The client does not have to be aware of this at all; DCOM provides flexible mechanisms to transparently establish these "distributed components." For details, see the section on custom marshaling in the "DCOM Architecture" White Paper. </P>
<P>With this unique feature, DCOM makes possible the development of generic infrastructures that deal with load balancing and dynamic method routing. Such an infrastructure can define a standard set of interfaces that convey the presence or absence of state information between a client and a component. Whenever the client-side part of the component detects absence of state information, it can dynamically reconnect the client to a different server.</P>
<P><B>Example:</B> Microsoft's Transaction Server (formerly code-named "Viper") uses this mechanism to extend the DCOM programming model. By requiring a simple set of standardized state information management interfaces, Transaction Server can obtain the necessary information to offer sophisticated load balancing. In this new programming model, client and component interactions are bundled into transactions that basically indicate when a sequence of method invocations has reached a point where no state information remains pending between the two components.</P>
<P>DCOM provides a powerful infrastructure for implementing dynamic load balancing. Simple referral components can be used to transparently implement dynamic server allocations at connection time. More sophisticated mechanisms for rerouting individual method invocations to different servers can easily be implemented, but they require more intimate knowledge of the interaction between clients and components. Microsoft's Transaction Server ("Viper"), built entirely on DCOM, provides a standardized programming model that conveys this additional application-specific knowledge to the Transaction Server infrastructure, which in turn can perform very sophisticated static and dynamic reconfiguration and load balancing.</P></BODY></HTML>
