<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Secure Data Solutions Using the Jet Database Engine </title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>



	<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>



	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<h1>Secure Data Solutions Using the Jet Database Engine </h1>
<p>
Presented by:&#09;Paul Litwin</p>
<p>
Paul Litwin is a senior consultant with MCW Technologies focusing on application development employing Microsoft&reg; Access, Microsoft&reg; Visual Basic&reg; Microsoft&reg; Office, Microsoft&reg; SQL Server™, VBScript and Microsoft Internet technologies. He's the editor of <i>Smart Access,</i> a monthly newsletter for Microsoft Access developers (www.pinpub.com), and has written numerous articles and reviews for various publications, including <i>Smart Access,</i> <i>Visual Basic Programmer's Journal,</i> <i>Visual Basic Developer,</i> and <i>PC World.</i> Paul is a Microsoft Access MVP and a section leader on the VBPJ CompuServe forum and Windows Developer's Exchange (www.windx.com). He recently completed work on <i>Microsoft Access 97 Developer's Handbook</i> and has authored several books on Microsoft Access 2.0 and Microsoft Access 95. Paul trains developers for Application Developers Training Company and is a regular speaker at conferences</p>
<p>
This talk has been adapted, with permission, from <i>Access 97 Developer's Handbook</i> by Paul Litwin, Ken Getz, and Mike Gilbert (Sybex 1997). Copyright &copy; 1997 Sybex Inc.</p>
<p>
Email: plitwin@mcwtech.com</p>
<h2>Introduction</h2>
<p>
Since Microsoft&reg; Access 1.0, the Jet engine has offered a sophisticated <i>workgroup-based</i> security model (it's also referred to as a user-based security model) rather than the more common database-based model most other desktop database management systems use. Under the simpler file-oriented model, security revolves around a database and is self contained within the confines of that database. Each database has its own security system that is independent of others. In contrast, in Jet's workgroup-based security model, every database used by members of a workgroup shares the same security system.</p>
<p>
Jet's workgroup-based security is based on <i>users and their permissions,</i> not passwords. Most desktop databases employ password-based security if they implement any security features at all. (Jet also offers a limited password-based system that's briefly discussed later in this paper.) In these systems users enter a password that identifies them to the system as valid users. Every user who shares a given security level shares that same password, so the system is incapable of identifying individual users. In contrast, Jet's security model requires each user to have both a user name and a password. The password merely verifies that users are who they claim to be. Once verified, the password leaves the picture. With Jet, users manage their own individual passwords, which they can change at will without affecting other users. Passwords can be more secure since they're not shared by lots of users.</p>
<h3>Two Parts to Security</h3>
<p>
Jet security is made up of two parts:
<ul>
<li>
User and group accounts and their passwords are stored in the workgroup file. This file, usually kept centrally on a file server in a multiuser environment, is, by default, named SYSTEM.MDW.<br><br></li>
<li>
Object permissions are stored in each database.</li>
</ul>
<h3>Enabling Security</h3>
<p>
Security in Jet is always on; it can't be turned off. The security system, however, remains invisible until you're ready to use it. This is possible because of the presence of several default user and group accounts.</p>
<p>
Every workgroup file starts out with two predefined group accounts (Admins and Users) and one predefined user account (Admin). When a user starts an Microsoft Access session, Jet always attempts to log on the user as <i>Admin</i> with a blank password. If this logon attempt fails, only then does Jet prompt the user for a user name and password using the Logon dialog. Thus, as long as you keep the Admin password blank (a zero-length string), security remains invisible.</p>
<h3>Database Passwords</h3>
<p>
With the introduction of Jet 3.0 (Microsoft&reg; Access 95), Microsoft has added a much simpler alternative to workgroup-bases security: database passwords. This system allows you to set a single password for a database that all users must know to open the database. While much simpler to implement and use, this system is very easily compromised because all users use the same password. In addition, it doesn't let you track individual users' activity in a shared database. However, you can use both workgroup-based security and database passwords at the same time.</p>
<p>
You set a database password by selecting Tools/Security/Set Database Password. Once this option is set, whenever you open the database you will be met with the Password Required dialog. You must have the database open exclusively to set the database password.</p>
<p>
The remainder of this paper focuses on the more powerful workgroup-based security model.</p>
<h2>Workgroups</h2>
<p>
At the interface level, a workgroup is defined as a group of users who work together. At the Jet engine level, a workgroup is defined as all users sharing the same workgroup file.</p>
<p>
The workgroup file is a special encrypted database, by default called SYSTEM.MDW, that Microsoft Access and Jet use to store a number of pieces of information having to do with users, including:
<ul>
<li>
User account names, their personal identifiers (PIDs), and passwords<br><br></li>
<li>
Group account names and their PIDs<br><br></li>
<li>
Information regarding which users belong to which groups</li>
</ul>
<p>
In a multiuser environment you can choose to place the workgroup file either on the file server or on each workstation. Usually, you'll want to place it on the file server, which makes the maintenance of user and group accounts much easier. On the other hand, if your security settings are fairly static, you could reduce network traffic by placing a copy of the workgroup file on each workstation.</p>
<h3>Creating a New Workgroup</h3>
<p>
Microsoft includes a utility program called the Workgroup Administrator (WRKGADM.EXE) you can use to create a new workgroup (workgroup file) or to change to another workgroup. You won't find this program on your Start menu, nor will you find the executable file in your Microsoft Access directory. The Microsoft Access 97 install program places WRKGADM.EXE in the \Windows\System directory. Go figure! Once you've located the Workgroup Administrator program, run it and choose to create a new workgroup, you are met with the Workgroup Owner Information dialog, as shown in Figure 1.</p>
<p>
<img src="off412ef_1.gif" border=0></p>
<p>
<b>Figure 1: The information entered into the Workgroup Owner Information dialog is used to uniquely identify a workgroup.  </b></p>
<p>
Since the workgroup file is such a vital part of security, we recommend regularly backing up this file and storing a copy of it safely off site. You should also consider storing a copy of the Name, Organization, and Workgroup ID fields in hard-copy form in a secure off-site location. </p>
<dl>
<dt>
The third field in the Workgroup Owner Information dialog, Workgroup ID, is the most critical one. You can enter from 0 to 20 numbers or <i>case-sensitive</i> letters into this field. Take extra care to keep this entry secret but backed up somewhere off site. If you leave this field blank, you'll be warned, but you won't be prevented from proceeding. Once you commit your entries to these fields by clicking the OK button, you will have one more chance to change your mind, and then you will never be able to view or change them again. Thus, it's important to write them down.</dt>
<dd>
<b>Warning</b>&nbsp;&nbsp;&nbsp;Microsoft Access creates a default workgroup named SYSTEM.MDA when you install Microsoft Access. To create this workgroup, it uses the name and company installation parameters and a blank Workgroup ID. <i>This makes the default workgroup file insecure</i> because anyone who can get to the Help/About Microsoft Access command with your copy of Microsoft Access can break your security! When you need to secure a database, the first thing you should do is create a brand-new secured workgroup file. </dd>
</dl>
<p>
Based on your entries in the Workgroup Owner Information dialog, Jet generates an encrypted binary ID called the Workgroup security identifier (SID). Jet uses the Workgroup SID to uniquely identify the Admins group account in the workgroup. The significance of this built-in account is discussed in the section &quot;Special Status: Built-In Accounts&quot; later in this paper.</p>
<h2>User and Group Accounts</h2>
<p>
Jet uses user and group accounts to dole out security permissions. Only users and groups can have permissions. Both types of accounts share the same name space, so you need to ensure that all names are unique for a workgroup. Thus, you can't have a user and a group with the same name.</p>
<p>
In Microsoft Access you use the Tools/Security/User and Group Accounts command to create and manage user and group accounts (see Figure 2).</p>
<p>
<img src="off412ef_2.gif" border=0></p>
<p>
<b>Figure 2: The user Geoff is a member of the Users, Employees, and Programmers groups</b></p>
<p>
Only members of the Admins group can add, delete, and change the membership for user and group accounts, but any user can view accounts (this is change from Microsoft Access 2.0) and change his or her account password.</p>
<h3>PIDs, SIDs, and Passwords</h3>
<p>
When you create a new user or group account in Jet, you must enter a non-blank, 4–20 character, case-sensitive <i>personal identifier </i>(<i>PID</i>). Jet combines the name of the account with the PID to create a SID for each user or group account. Once you've entered a PID, you can <i>never</i> view or change it.</p>
<p>
We recommend that only a single database administrator create accounts and PIDs and that this individual keep a written off-site record. </p>
<p>
After you create a new user account, you can add an optional 1–14-character, case-sensitive account password using the Change Logon Password tab of the User and Group Accounts dialog. (Unlike PIDs, passwords <i>are</i> optional.) Jet uses passwords only at logon time to verify the identity of a user.</p>
<p>
Only users can change their own passwords, but members of the Admins group can clear another user's password. </p>
<p>
Both passwords and PIDs are stored in the workgroup file in an encrypted format.</p>
<p>
Jet uses the internally generated account SIDs to uniquely identify user and group accounts across workgroups. Except for some of the special built-in accounts that are discussed in the section &quot;Special Status: Built-In Accounts&quot; later in this paper, Jet treats accounts in different workgroups with the same name, but different PIDs (and thus different SIDs) as distinct.</p>
<h3>Groups Are More Than Collections of Users</h3>
<p>
A group account is more than simply a collection of users. In many situations you can use a group account in place of a user account. Although you cannot log on as a group, you can do almost anything else with a group account, including owning objects. A group account may not own a database.</p>
<h3>Special Status: Built-In Accounts</h3>
<p>
As mentioned earlier in this paper, the Jet security system includes several built-in accounts that make it possible for security to remain invisible until it's needed. These built-in accounts include the Admin <i>user</i> and the Admins and Users <i>groups.</i> It's important that you understand how these &quot;special status&quot; accounts work; otherwise your database won't be secure. The following table describes the three built-in accounts:</p>
<table>
<tr valign=top>
<td>
<b>Account Type</b></td>
<td>
<b>Account</b></td>
<td>
<b>Same SID for All Workgroups?</b></td>
<td>
<b>Comments</b></td>
</tr>
<tr valign=top>
<td>
User</td>
<td>
Admin</td>
<td>
Yes</td>
<td>
Default user account</td>
</tr>
<tr valign=top>
<td>
Group</td>
<td>
Admins</td>
<td>
No</td>
<td>
Members have special privileges</td>
</tr>
<tr valign=top>
<td>
Group</td>
<td>
Users</td>
<td>
Yes</td>
<td>
All user accounts are members of Users</td>
</tr>
</table><br>
<p>
None of the special accounts can ever be deleted from a workgroup. Each of these accounts is described in more detail in the next few sections.</p>
<p>
<b>Admin user</b></p>
<p>
All new workgroups initially contain the Admin user account with a blank password. As mentioned previously, Microsoft Access always attempts to log you on as the Admin user with a blank password. Only if this logon attempt fails does Microsoft Access prompt you for a user name and password.</p>
<p>
You cannot delete the Admin user, but you can remove it from the Admins group as long as Admins has at least one other member.</p>
<p>
<b>Admins group</b></p>
<p>
The Admins group is uniquely identified across workgroups. Jet requires that there always be at least one member of the Admins group. This requirement makes it impossible to have a workgroup with no administrator.</p>
<p>
Members of the Admins group have special, irrevocable administrative rights. Their membership in Admins, however, <i>is</i> revocable by another Admins member. As long as they are members of Admins, they can grant themselves permissions to all database objects in the databases in their workgroup. In addition, members of Admins always have the ability to manage user and group accounts in their workgroup.</p>
<p>
<b>Users group</b></p>
<p>
The Users group is the default group for all Microsoft Access users. All built-in user accounts&#45;as well as new user accounts created using the Microsoft Access UI&#45;will be members of the Users group. Microsoft Access won't allow you to remove users from the Users group. </p>
<p>
By default, the Users group gets full permissions on newly created objects.</p>
<h2>Assigning Permissions</h2>
<p>
Using the Microsoft Access user interface (UI), you assign permissions to database objects with the Tools/Security/User and Group Permissions command (see Figure 3). Although you can change only one <i>type</i> of object at a time, you can select multiple objects (in contiguous or discontiguous groups) in the Permissions dialog.</p>
<p>
<img src="off412ef_3.gif" border=0></p>
<p>
<b>Figure 3: The Programmers group account has ReadDesign and ModifyDesign permissions for the basSecurityUtilities module.  </b></p>
<h3>Which Objects Have Which Permissions?</h3>
<p>
Each database container object in Jet has a set of associated permissions you can set. Each type of object has a different set of settable permissions. For example, tables and queries don't have an Open/Run permission, but they have several permissions that control how data may be read or updated. On the other hand, forms, reports, and macros have no data permissions but do have an Open/Run permission. </p>
<p>
Permissions are not completely independent of each other; some permissions imply other permissions. For example, you can't have UpdateData permissions if you don't also have ReadDesign and ReadData permissions. Thus, UpdateData permission also implies these other permissions. </p>
<h3>Permissions for New Objects</h3>
<p>
In addition to setting permissions on existing objects, you can set permissions on new objects. You do this by choosing &lt;New <i>objectname</i>&gt; in the User and Group Permissions dialog (see Figure 3). This setting does <i>not</i> control the ability to create new objects; it controls only the permissions the account will receive for new objects. Although you can remove all permissions for new objects, this will <i>not</i> prevent users from creating new objects. In addition, since they will become the owner of any objects <i>they</i> create, they can always grant themselves Administer rights to these objects.</p>
<p>
By using DAO, however, you <i>can</i> prevent users from creating new tables and queries.</p>
<h3>Explicit Versus Implicit Permissions</h3>
<p>
Users in the Jet security model have both implicit and explicit permissions. <i>Explicit permissions</i> are those permissions explicitly given to users and associated directly with a user account. <i>Implicit permissions </i>are those permissions users receive because of their membership in groups.</p>
<p>
A user's set of permissions for an object will be based on the union of the user's explicit permissions and implicit permissions. A user's security level is always the <i>least restrictive</i> of the user's explicit permissions and the permissions of any and all groups to which the user belongs.</p>
<h2>Ownership</h2>
<p>
In addition to the permissions that are granted to accounts, you need to be aware of ownership, because database owners and object owners have special privileges.</p>
<h3>Who Owns a Database?</h3>
<p>
The user who creates a database is the database's owner. This user maintains special irrevocable rights to the database. This user will always be able to open the database. Only user accounts, not group accounts, can own databases.</p>
<p>
Database ownership cannot be changed, but you can always create a new database using a different user account and import all the database's objects into another database. </p>
<h3>Who Owns a Database's Objects?</h3>
<p>
Each database container object also has an owner. Initially, this is the user who created the object and may or may not be the same user account as the database owner. You can use the Change Owner tab of the Tools/Security/User and Group Permissions command to view and change object owners (see Figure 4).</p>
<p>
<img src="off412ef_4.gif" border=0></p>
<p>
<b>Figure 4: Using the Change Owner dialog, Alicia is about to change the ownership for four tables from Admin to the Managers group. </b></p>
<p>
The new owner for an object may be a group account.</p>
<h3>OwnerAccess Queries</h3>
<p>
Queries created in Microsoft Access QBE have a property, RunPermissions, that governs whether Jet uses the query user's (the person running the query) permissions or the owner's permissions when checking the security permissions for each of the source tables in a query. In Microsoft Access SQL, setting this property to &quot;Owner's&quot; translates to the &quot;WITH OWNERACCESS OPTION&quot; clause.</p>
<p>
This property allows you to present data to users who lack access rights to the underlying tables. Using this feature, you can effectively apply column-level and row-level security to a table.</p>
<p>
For example, using an OwnerAccess query, you could let members of the Programmers group view and update all the columns in the tblEmployee table except for the Salary field. To do this, you would perform the following steps:
<ol>
<li>
Remove all permissions to tblEmployee for the Programmers group.<br><br></li>
<li>
Using an account that has ReadData and UpdateData permissions to tblEmployee, create a query, qryEmployee, that includes all the columns from tblEmployee except Salary.<br><br></li>
<li>
Set the RunPermissions of qryEmployee to &quot;Owner's&quot; (or include the &quot;WITH OWNERACCESS OPTION&quot; clause in the SQL statement for the query).</li>
</ol>
<h2>Encryption</h2>
<p>
As good as Jet security is, a very knowledgeable hacker equipped with a low-level disk editor might be able to directly open the .MDB file and break into your database. The only way to guard against such a hacker is to encrypt the database.</p>
<p>
Encrypting a database does not secure it. It is only one of a series of steps for properly securing a database. Only the database owner or members of the Admins group can encrypt or decrypt a database.Using Microsoft Microsoft Access, you can encrypt or decrypt a database using the Tools/Security/Encrypt/Decrypt Database command. The Microsoft Access Security Wizard encrypts databases as its final step in securing a database.</p>
<p>
Encryption has two negative side effects. First, it reduces database performance by approximately 10 to 15 percent. Second, it makes the database uncompressible by programs such as PKZip, LHA, Stacker, and DriveSpace. </p>
<h2>Programming Security Using Data Access Objects</h2>
<p>
Programming security with DAO revolves around two object hierarchies that correspond to the division in Jet security discussed in the section &quot;Two Parts to Security&quot; earlier in this paper:</p>
<table>
<tr valign=top>
<td>
<b>Part of Security</b></td>
<td>
<b>Corresponding DAO Object Hierarchy</b></td>
</tr>
<tr valign=top>
<td>
User and group accounts and their passwords</td>
<td>
Users and Groups hierarchy</td>
</tr>
<tr valign=top>
<td>
Object permissions</td>
<td>
Containers and Documents hierarchy</td>
</tr>
</table><br>
<h3>The User and Groups Hierarchy</h3>
<p>
You manipulate user and group accounts&#45;the elements of security that are stored in the workgroup file&#45;using the object hierarchy shown in Figure 4.</p>
<p>
<img src="off412ef_5.gif" border=0></p>
<p>
<b>Figure 4: Data access objects hierarchy for users and groups.</b></p>
<p>
User and group objects are direct descendants of a workspace object; they are independent of any database objects. This is consistent with the physical location of the user and group account information&#45;in the workgroup file.</p>
<p>
The user and group object hierarchies overlap. Each user object contains a <i>Groups</i> collection that contains the names of all the groups to which a user belongs. Similarly, each group object contains a <i>Users</i> collection that contains the names of all users belonging to that group.</p>
<h3>The Collections and Documents Hierarchy</h3>
<p>
You manipulate object permissions&#45;the elements of security that are stored in databases&#45;using the object hierarchy shown in Figure 5.</p>
<p>
<img src="off412ef_6.gif" border=0></p>
<p>
<b>Figure 5: Data access objects hierarchy for containers and documents. You use these object collections to manage security permissions.</b></p>
<p>
Unlike user and group objects, permissions are manipulated using container and document objects that <i>are</i> descendants of the database object. Again, this is consistent with the physical location of these security elements.</p>
<h3>Managing Accounts</h3>
<p>
Using DAO, you can create, delete, and list user and group accounts. In addition, you can list the groups to which a user belongs and the users who are members of a group. Jet 3.5 lets any user view user and group account information, although only Admins members can update account information.</p>
<p>
<b>Users collections and user objects</b></p>
<p>
There are two types of collections of users: collections of a workspace and collections of a group account. The Users collection for a workspace contains all the user accounts for that workspace. The Users collection for a group account contains all the members of the group.</p>
<p>
The <b>Users collection</b> has a single property<i>,</i> Count, and three methods<i>,</i> described in the following table.</p>
<table>
<tr valign=top>
<td>
<b>Type</b></td>
<td>
<b>Property/Method</b></td>
<td>
Purpose</td>
</tr>
<tr valign=top>
<td>
Property</td>
<td>
Count</td>
<td>
The number of user objects contained in the collection</td>
</tr>
<tr valign=top>
<td>
Method</td>
<td>
Append</td>
<td>
Adds a new user to a collection</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
Delete</td>
<td>
Removes a user from a collection</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
Refresh</td>
<td>
Refreshes the collection</td>
</tr>
</table><br>
<p>
The Users collection contains user objects. <b>User objects</b> have three properties and two methods, described in the following table.</p>
<table>
<tr valign=top>
<td>
<b>Type</b></td>
<td>
<b>Property/Method</b></td>
<td>
Purpose</td>
</tr>
<tr valign=top>
<td>
Property</td>
<td>
Name</td>
<td>
Name of the user. Read/write for new users not yet appended to the Users collection. Read-only otherwise</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
Password</td>
<td>
Case-sensitive password for the user account. Write-only for new users not yet appended to the Users collection. Not available otherwise</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
PID</td>
<td>
Case-sensitive personal identifier for the user account. Write-only for new users not yet appended to the Users collection. Not available otherwise</td>
</tr>
<tr valign=top>
<td>
Method</td>
<td>
CreateGroup</td>
<td>
Creates a new group object. When appended to the user object's Groups collection, this method adds the user to that group</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
NewPassword</td>
<td>
Replaces an existing password with a new one</td>
</tr>
</table><br>
<p>
For example, you could use the following subroutine to enumerate the user accounts in the workgroup to the Debug window:</p>
<pre><FONT FACE="Courier New" SIZE="2">Sub ListUsers()
    Dim wrk As WorkSpace
    Dim usr As User
    Set wrk = DBEngine.Workspaces(0)
    Debug.Print &quot;The Users collection has the following &quot; &amp; _
     wrk.Users.Count &amp; &quot; members:&quot;
    For Each usr In wrk.Users
       Debug.Print usr.Name
    Next usr
End Sub
</font></pre>
<p>
If you wished instead to list only user accounts that were members of the Managers group, you could use the following:</p>
<pre><FONT FACE="Courier New" SIZE="2">Sub ListManagers()
    Dim wrk As WorkSpace
    Dim grpManagers As Group
    Dim usr As User
    Set wrk = DBEngine.Workspaces(0)
    Set grpManagers = wrk.Groups!Managers
    For Each usr In grpManagers.Users
        Debug.Print usr.Name
    Next usr
End Sub
</font></pre>
<p>
To create a new user account, you use the CreateUser method of a workspace object.</p>
<p>
<b>Groups collections and group objects</b></p>
<p>
There are two types of collections of groups: collections of a workspace and collections of a user account. The Groups collection for a workspace contains all the group accounts for that workspace. The Groups collection for a user account contains all the groups to which that user belongs.</p>
<p>
The <b>Groups collection</b> has a single property and three methods<i>,</i> described in the following table.</p>
<table>
<tr valign=top>
<td>
<b>Type</b></td>
<td>
<b>Property/Method</b></td>
<td>
<b>Purpose</b></td>
</tr>
<tr valign=top>
<td>
Property</td>
<td>
Count</td>
<td>
The number of group objects contained in the collection</td>
</tr>
<tr valign=top>
<td>
Method</td>
<td>
Append</td>
<td>
Adds a new group to a collection</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
Delete</td>
<td>
Removes a group from a collection</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
Refresh</td>
<td>
Refreshes the collection</td>
</tr>
</table><br>
<p>
The Groups collection contains group objects. <b>Group objects</b> have two properties and a single method, described in the following table.</p>
<table>
<tr valign=top>
<td>
<b>Type</b></td>
<td>
<b>Property/Method</b></td>
<td>
<b>Purpose</b></td>
</tr>
<tr valign=top>
<td>
Property</td>
<td>
Name</td>
<td>
Name of the group. Read/write for new groups not yet appended to the Groups collection. Read-only otherwise</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
PID</td>
<td>
Case-sensitive personal identifier for the group account. Write-only for new groups not yet appended to the Groups collection. Not available otherwise</td>
</tr>
<tr valign=top>
<td>
Method</td>
<td>
CreateUser</td>
<td>
Creates a new user object. When appended to the group object's Users collection, this method adds the user to the group</td>
</tr>
</table><br>
<p>
Groups don't have passwords; you can't log on as a member of a group.</p>
<p>
You might use the following code to enumerate the names of all the groups in the Groups collection of the default workspace:</p>
<pre><FONT FACE="Courier New" SIZE="2">Sub ListGroups()
    Dim wrk As WorkSpace
    Dim grp As Group
    Set wrk = DBEngine.Workspaces(0)
    Debug.Print &quot;The Groups collection has the following &quot; &amp; _
     wrk.Groups.Count &amp; &quot; members:&quot;
    For Each grp In wrk.Groups
       Debug.Print grp.Name
    Next grp
End Sub
</font></pre>
<p>
To create a new group account, you use the CreateGroup method of a workspace object.</p>
<p>
<b>Creating new accounts</b></p>
<p>
You can use the adhCreateUser function, located in the basSecurityUtilities module of OFF412.MDB, to create a new user account. It takes as its parameters the name of the new user, the new user's PID, and the new user's password. It returns True if successful. This function, which requires the user running it to be a member of the Admins group, is shown here:</p>
<pre><FONT FACE="Courier New" SIZE="2">Function adhCreateUser(ByVal strName As String, _
 ByVal strPID As String, ByVal strPW As String) As Boolean
    Dim wrk As Workspace
    Dim usrNew As User
    Dim strMsg As String
    Const adhcProcName = &quot;adhCreateUser&quot;
    adhCreateUser = False
    Set wrk = DBEngine.Workspaces(0)
    'Create new user account and append to Users collection
    Set usrNew = wrk.CreateUser(strName, strPID, strPW)
    wrk.Users.Append usrNew
    'Must also add user account to Users group
    usrNew.Groups.Append wrk.CreateGroup(&quot;Users&quot;)
    adhCreateUser = True
End Function
</font></pre>
<p>
Creating a new user is much like creating any new object with DAO. adhCreateUser works by creating a new user object using the CreateUser method of the default workspace. The new user is created when the user's object is appended to the workspace's Users collection. To be consistent with the Microsoft Access UI&#45;and more important, to make it so the new account will be able to open databases in the workgroup&#45;adhCreateUser finishes by appending the new account to the built-in Users group.</p>
<p>
basSecurityUtilities also includes a similar function, adhCreateGroup, for creating new group accounts.</p>
<p>
<b>Checking for group membership</b></p>
<p>
You can check whether a user is a member of a group using adhIsGroupMember. This function takes as its input the name of the user and the group and returns True if the user is a member. adhIsGroupMember is shown here (if the optional varUser parameter is missing, it defaults to the current user):</p>
<pre><FONT FACE="Courier New" SIZE="2">Function adhIsGroupMember(ByVal strGroup As String, _
 Optional ByVal varUser As Variant) As Boolean
    On Error GoTo adhIsGroupMemberErr
    Dim wrk As Workspace
    Dim usr As User
    Dim grp As Group
    Dim strMsg As String
    Dim intErrHndlrFlag As Integer
    Dim varGroupName As Variant
    Const adhcFlagSetUser = 1
    Const adhcFlagSetGroup = 2
    Const adhcFlagCheckMember = 4
    Const adhcFlagElse = 0
    Const adhcProcName = &quot;adhIsGroupMember&quot;
    adhIsGroupMember = False
    'Initialize flag for determining
    'context for error handler
    intErrHndlrFlag = adhcFlagElse
    Set wrk = DBEngine.Workspaces(0)
    'Refresh users and groups collections
    wrk.Users.Refresh
    wrk.Groups.Refresh
    If IsMissing(varUser) Then varUser = CurrentUser()
    intErrHndlrFlag = adhcFlagSetUser
    Set usr = wrk.Users(varUser)
    intErrHndlrFlag = adhcFlagSetGroup
    Set grp = wrk.Groups(strGroup)
    intErrHndlrFlag = adhcFlagCheckMember
    varGroupName = usr.Groups(strGroup).Name
    If Not IsEmpty(varGroupName) Then
        adhIsGroupMember = True
    End If
adhIsGroupMemberDone:
    On Error GoTo 0
    Exit Function
adhIsGroupMemberErr:
    Select Case Err
    Case adhcErrNameNotInCollection
        Select Case intErrHndlrFlag
        Case adhcFlagSetUser
            strMsg = &quot;The user account '&quot; &amp; varUser &amp; _
             &quot;' doesn't exist.&quot;
        Case adhcFlagSetGroup
            strMsg = &quot;The group account '&quot; &amp; strGroup &amp; _
             &quot;' doesn't exist.&quot;
        Case adhcFlagCheckMember
            Resume Next
        Case Else
            strMsg = &quot;Error &quot; &amp; Err.Number &amp; &quot;: &quot; &amp; _
             Err.Description
        End Select
    Case adhcErrNoPermission
        strMsg = &quot;You don't have permission to perform &quot; &amp; _
         &quot;this operation.&quot;
    Case Else
        strMsg = &quot;Error &quot; &amp; Err.Number &amp; &quot;: &quot; &amp; Err.Description
    End Select
        MsgBox strMsg, vbCritical + vbOKOnly, &quot;Procedure &quot; &amp; _
         adhcProcName
    Resume adhIsGroupMemberDone
End Function
</font></pre>
<p>
This function checks for membership using the following statement:</p>
<pre><FONT FACE="Courier New" SIZE="2">varGroupName = usr.Groups(strGroup).Name
</font></pre>
<p>
This statement attempts to set a variable to the Name property of the group object in the Groups collection of the user object. There's nothing special here about the Name property; any readable property of the group object would suffice. Because of the symmetry of the Users and Groups collections, adhIsGroupMember could have also checked for the name of the user object in the Users collection of the group object. The following alternate statement would yield the same result:</p>
<pre><FONT FACE="Courier New" SIZE="2">varUserName = grp.Users(strUser).Name
</font></pre>
<p>
adhIsGroupMember <i>doesn't</i> require the user running it to be a member of the Admins group.</p>
<p>
The adhIsGroupMember function would be useful if you wish to change application functionality based on the security level of the user. For example, you might disable or hide certain command buttons if a user is of one level of security while enabling or showing these same buttons for a higher level of user. </p>
<p>
The following code, from frmCheckGroup, disables the cmdEdit command button if the user is not a member of the Admins group:</p>
<pre><FONT FACE="Courier New" SIZE="2">    ' Enable Edit button if member of Admins
    If adhIsGroupMember(&quot;Admins&quot;) Then
        Me!cmdEdit.Enabled = True
        Me!cmdEdit.ControlTipText = _
         &quot;Toggles between Edit and Browse modes.&quot;
    Else
        Me!cmdEdit.Enabled = False
        Me!cmdEdit.ControlTipText = _
         &quot;You're not a member of Admins, so you can't edit data.&quot;
    End If
</font></pre>
<p>
The control would only be enabled if the current user was a member of the Admins group.</p>
<h3>Programming Permissions</h3>
<p>
Permissions are properties of <i>documents</i> and their <i>containers.</i> Like other DAO collections, the Containers collection and Documents collection have a single property, Count, that indicates the number of objects in the collection. These two collections also have a single method, Refresh, which you can use to make sure the collections are current.</p>
<p>
<b>Document and container objects</b></p>
<p>
Container and document objects have several properties. They are listed in the following table.</p>
<table>
<tr valign=top>
<td>
<b>Object</b></td>
<td>
<b>Property</b></td>
<td>
<b>Description</b></td>
</tr>
<tr valign=top>
<td>
Container</td>
<td>
Inherit</td>
<td>
Determines whether any changes are inherited by new objects. If you set permissions on a container and set Inherit to True, Jet uses these permissions when creating new documents for the container</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
Name</td>
<td>
Read-only. The name of the container. For example, the Tables container contains a database's tables and queries</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
Owner</td>
<td>
Read/write. The user or group account that owns the object. By default, all object containers are owned by the engine user</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
Permissions</td>
<td>
Read/write. A Long Integer that stores explicit permission information for the container. When you use this property with the Inherit property, you can set permissions for new documents of a container</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
AllPermissions</td>
<td>
Read-only. A Long Integer that stores the union of explicit and implicit permission information for the container</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
UserName</td>
<td>
Read/write. When you read or write permissions for a container, the permissions are account specific. By default, this property points to the current user. You use UserName to view or set permissions for different user and group accounts</td>
</tr>
<tr valign=top>
<td>
Document</td>
<td>
Container</td>
<td>
Read-only. The container to which the document belongs</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
DateCreated</td>
<td>
Read-only. The date the document was created</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
LastUpdated</td>
<td>
Read-only. The date the document's schema was last changed</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
Name</td>
<td>
Read-only. The name of the document</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
Owner</td>
<td>
Read/write. The user or group account that owns the object. By default, the owner is the document's creator</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
Permissions</td>
<td>
Read/write. A Long Integer that stores explicit permission information for the document</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
AllPermissions</td>
<td>
Read-only. A Long Integer that stores the union of explicit and implicit permission information for the document</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
UserName</td>
<td>
Read/write. When you read or write permissions for a document, the permissions are account specific. By default, this property points to the current user. You can use UserName to view or set permissions for different user and group accounts</td>
</tr>
</table><br>
<p>
<b>Permission constants</b></p>
<p>
Microsoft predefines several database security constants you can use to simplify the reading and writing of permissions. These constants are outlined in following table. They also can be viewed with the Object Browser. The use of these constants is discussed in the next few sections.</p>
<table>
<tr valign=top>
<td>
Constant</td>
<td>
Meaning</td>
</tr>
<tr valign=top>
<td>
dbSecNoAccess</td>
<td>
No access to the object</td>
</tr>
<tr valign=top>
<td>
dbSecFullAccess</td>
<td>
Full access to the object</td>
</tr>
<tr valign=top>
<td>
dbSecDelete</td>
<td>
Can delete the object</td>
</tr>
<tr valign=top>
<td>
dbSecReadSec</td>
<td>
Can read the object's security-related information</td>
</tr>
<tr valign=top>
<td>
dbSecWriteSec</td>
<td>
Can alter access permissions</td>
</tr>
<tr valign=top>
<td>
dbSecWriteOwner</td>
<td>
Can change the Owner property setting</td>
</tr>
<tr valign=top>
<td>
dbSecCreate</td>
<td>
Can create new documents; valid only with a Container object</td>
</tr>
<tr valign=top>
<td>
dbSecReadDef</td>
<td>
Can read the table definition, including column and index information</td>
</tr>
<tr valign=top>
<td>
dbSecWriteDef</td>
<td>
Can modify or delete the table definition, including column and index information</td>
</tr>
<tr valign=top>
<td>
dbSecRetrieveData</td>
<td>
Can retrieve data from the Document object</td>
</tr>
<tr valign=top>
<td>
dbSecInsertData</td>
<td>
Can add records</td>
</tr>
<tr valign=top>
<td>
dbSecReplaceData</td>
<td>
Can modify records</td>
</tr>
<tr valign=top>
<td>
dbSecDeleteData</td>
<td>
Can delete records</td>
</tr>
<tr valign=top>
<td>
dbSecDBAdmin</td>
<td>
Gives user permission to make a database replicable, change the database password, and set startup properties</td>
</tr>
<tr valign=top>
<td>
dbSecDBCreate</td>
<td>
Can create new databases; valid only on the Databases container object in the workgroup file (SYSTEM.MDW)</td>
</tr>
<tr valign=top>
<td>
dbSecDBExclusive</td>
<td>
Can open the database exclusively</td>
</tr>
<tr valign=top>
<td>
dbSecDBOpen</td>
<td>
Can open the database</td>
</tr>
<tr valign=top>
<td>
acSecMacExecute</td>
<td>
Can run the macro</td>
</tr>
<tr valign=top>
<td>
acSecMacReadDef</td>
<td>
Can read the definition of the macro</td>
</tr>
<tr valign=top>
<td>
acSecMacWriteDef</td>
<td>
Can modify the definition of the macro</td>
</tr>
<tr valign=top>
<td>
acSecFrmRptExecute</td>
<td>
Can open the form or report</td>
</tr>
<tr valign=top>
<td>
acSecFrmRptReadDef</td>
<td>
Can read the definition of the form or report and its module</td>
</tr>
<tr valign=top>
<td>
acSecFrmRptWriteDef</td>
<td>
Can modify the definition of the form or report and its module</td>
</tr>
<tr valign=top>
<td>
acSecModReadDef</td>
<td>
Can read the definition of the global module</td>
</tr>
<tr valign=top>
<td>
acSecModWriteDef</td>
<td>
Can modify the definition of the global module</td>
</tr>
</table><br>
<p>
<b>Reading permissions</b></p>
<p>
You can read the permissions of an object simply by checking the value of the Permissions or AllPermissions property of the object. Permissions returns explicit permissions only, whereas AllPermissions returns the union of explicit and implicit permissions. They both return the Long Integer corresponding to the user's permissions for the object. For example, you could query the permission of the tblOrder table and store the value into the variable lngPermission with the following assignment statement (assuming you have previously set the db object variable to point to a database):</p>
<pre><FONT FACE="Courier New" SIZE="2">lngPermission = _
 db.Containers!Tables.Documents!tblOrder.Permissions
</font></pre>
<p>
Often, you'll want to check whether a user has some minimum permissions to an object. You can do this using bitwise arithmetic (also referred to as <i>bit twiddling</i>). This works because Jet stores each individual permission as a different bit of the 4-byte Long Integer value. You check a permission value for a specific set of bits&#45;some permissions are actually the result of setting several bits&#45;by using the And operator to mask off the bits in which you are interested and comparing the result of the operation to these same bits. Using the predefined permission constants makes this easy:</p>
<pre><FONT FACE="Courier New" SIZE="2">fOk =  ((doc.Permissions And <i>dbSecConstant</i>) = <i>dbSecConstant</i>)
</font></pre>
<p>
fOk will be set to True if the document object has that permission&#45;as defined by dbSecConstant&#45;set to True, and False if the document object does not.</p>
<p>
For example, you could use the following function (found in the basSimpleExamples module of OFF412.MDB) to determine whether the user Kizzie has read permission for tblCustomer:</p>
<pre><FONT FACE="Courier New" SIZE="2">Function CanKizzieRead() As Boolean
    ' Simple example that illustrates correct
    ' syntax to check a specfic permission
    ' against Permissions property.
    
    ' Checks explicit permissions only for:
    '   User = Kizzie,
    '   Object = tblCustomer,
    '   Permission = dbSecRetrieveData.
    Dim db As Database
    Dim doc As Document
    Set db = CurrentDb()
    Set doc = db.Containers!Tables.Documents!tblCustomer
    doc.UserName = &quot;Kizzie&quot;
    CanKizzieRead = _
     ((doc.Permissions And dbSecRetrieveData) _
     = dbSecRetrieveData)
End Function
</font></pre>
<p>
If Kizzie has ReadData permission to tblCustomer, CanKizzieRead returns True; otherwise it returns False. The trick in this example is to use the bitwise And operator to mask off the complete permissions with only the permission you are interested in&#45;in this case, dbSecRetrieveData (ReadData permission).</p>
<p>
CanKizzieRead checks only for explicit permissions. We could have also checked Kizzie's implicit permissions by replacing the last part of the function with:</p>
<pre><FONT FACE="Courier New" SIZE="2">CanKizzieRead =  ((doc.AllPermissions And dbSecRetrieveData) _
 = dbSecRetrieveData)
</font></pre>
<p>
Another function in the OFF412.MDB, CanKizzieReadAtAll, checks the AllPermissions property.</p>
<p>
There's another way to check a permission value against a constant that works <i>only</i> if one bit is set on in the constant:</p>
<pre><FONT FACE="Courier New" SIZE="2">' Don't do this
fOk =  (doc.Permissions And <i>dbSecConstant</i>) &lt;&gt;0
</font></pre>
<p>
This method, however, will <i>fail</i> with constants that have more than one bit set. Thus, because many of the security constants have multiple bits set, you shouldn't use it.</p>
<p>
<b>Writing permissions</b></p>
<p>
Writing permissions is similar to reading them. You have two choices when writing the permissions of an object:
<ul>
<li>
You can replace the existing permissions with a brand-new set of permissions.<br><br></li>
<li>
You can add or subtract a permission on top of the existing permissions.</li>
</ul>
<p>
To <i>replace</i> a set of permissions, you simply set the permissions to the new value. For example, you could change the permission for tblOrder to give the user ModifyDesign permission using the following code:</p>
<pre><FONT FACE="Courier New" SIZE="2">Set doc = db.Containers!Tables.Documents!tblOrder
doc.Permissions = dbSecWriteDef
</font></pre>
<p>
To <i>add</i> a permission on top of the existing permission set, you use the bitwise Or operator. For example, you could use the following code to add ModifyDesign permission to the existing set of permissions for tblOrder:</p>
<pre><FONT FACE="Courier New" SIZE="2">Set doc = db.Containers!Tables.Documents!tblOrder
doc.Permissions = doc.Permissions Or dbSecWriteDef
</font></pre>
<p>
Using this method of assigning permissions is often preferable because it guards against inadvertently removing other permissions the user may have. For example, if the user also had ReadData permission to tblOrder, that permission would be preserved using this technique. This would not be true in the previous example.</p>
<p>
To <i>subtract</i> a permission from a user while preserving all other permissions, you use a bitwise And Not operation. For example, to take away the same permission from a user, replace the second line in the preceding example with the following:</p>
<pre><FONT FACE="Courier New" SIZE="2">doc.Permissions = doc.Permissions And Not dbSecWriteDef
</font></pre>
<p>
The following subroutine can be used to toggle Kizzie's ReadData permission for tblCustomer:</p>
<pre><FONT FACE="Courier New" SIZE="2">Sub SetKizzieRead(fRead As Boolean)
    ' Simple example that illustrates correct
    ' syntax to set a specfic permission.
    
    ' Sets permission for:
    '   User = Kizzie,
    '   Object = tblCustomer,
    '   Permission = dbSecRetrieveData.
    
    Dim db As Database
    Dim doc As Document
    Set db = CurrentDb()
    Set doc = db.Containers!Tables.Documents!tblCustomer
    doc.UserName = &quot;Kizzie&quot;
    
    If fRead Then
        doc.Permissions = _
         doc.Permissions Or dbSecRetrieveData
    Else
        doc.Permissions = _
         doc.Permissions And Not dbSecRetrieveData
    End If
End Sub
</font></pre>
<p>
For example, if you typed the following into the Debug window, Kizzie would have ReadData permission for tblCustomer:</p>
<pre><FONT FACE="Courier New" SIZE="2">Call SetKizzieRead(True)
</font></pre>
<p>
Note that this code affects Kizzie's explicit permissions only. The only way to affect a user's implicit permissions is to change the permission properties of any groups to which he or she belongs.</p>
<h2>Properly Securing a Database with the Microsoft Access Security Wizard</h2>
<p>
Securing a database properly takes great care. It's very easy to make a mistake and leave yourself open to possible security intrusions. Fortunately, Microsoft has created a wizard that ships with Microsoft Access to help secure databases properly. Using the Security Wizard, however, does not automatically guarantee a secure database; the wizard is only one step in a series of steps that you must follow to properly secure a database:
<ol>
<li>
Use the Workgroup Administrator program (WRKGADM.EXE located in the \Windows\System directory) to create a new workgroup with a non-null Workgroup ID.<br><br></li>
<li>
Start Microsoft Access and create a password for the Admin account.<br><br></li>
<li>
Create a new user account that will be the administrator of the workgroup.<br><br></li>
<li>
Add the new account to the Admins group.<br><br></li>
<li>
Remove the Admin account from the Admins group.<br><br></li>
<li>
Restart Microsoft Access, logging on as the new administrator user, and create a password for this account.<br><br></li>
<li>
Select Tools/Security/User-Level Security Wizard to run the Security Wizard.<br><br></li>
<li>
Create the group accounts for your workgroup.<br><br></li>
<li>
Create the user accounts for your workgroup, adding each user to the appropriate groups.<br><br></li>
<li>
Set permissions on objects for the group accounts. If you wish to reduce permission maintenance, don't set any permissions for individual users.<p>
<b>Warning</b>&nbsp;&nbsp;&nbsp;Don't skip any steps or you run the risk of thinking you have a secured database when you do not. </p>
</li>
</ol>
<p>
Note: New for Microsoft Access 97, the Security Wizard now removes the database’s Open/Run permission for all user and group accounts except the Admins group and the user account of the user who ran the wizard. This means that users who are not members of the Admins group will not be able to open the database after you’ve run the wizard. You can, of course, add this permission to any user or group in the workgroup.</p>
<h2>Unsecuring a Secured Database</h2>
<p>
You can reverse the process of securing a database by following these steps:
<ol>
<li>
Log on as a member of the Admins group.<br><br></li>
<li>
Grant full permissions, including Administer permission, to the built-in Users group for all objects in the database.<br><br></li>
<li>
Clear the password for the Admin user.<br><br></li>
<li>
Make Admin a member of the Admins group.<br><br></li>
<li>
Exit Microsoft Access.<br><br></li>
<li>
Restart Microsoft Access and log on as Admin.<br><br></li>
<li>
Create a new blank database and import all the secured database's objects using the File/Get External Data Import command.</li>
</ol>
<p>
The trick to this technique is to give an unsecured group&#45;Users&#45;full permissions on all the objects and to then transfer ownership of the database and all its objects to an unsecured user&#45;Admin.</p>
<h2>Conclusion</h2>
<p>
The Jet security system is powerful and fully programmable. Because of its power, however, it can be difficult to grasp. Give yourself time to grasp it all&#45;it may take a while.</p>
<h2>Appendix</h2>
<p>
For more information on security, check out the following resources:</p>
<p>
Access 97 Developer's Handbook, by Paul Litwin, Ken Getz, and Mike Gilbert (Sybex 1997).</p>
<p>
This paper is excerpted from the book. The security chapter in the book is much more detailed and includes a library of reusable security functions you can use in your code. The book is available in most major bookstores as well as many electronic bookstores, including www.caryp.com and www.amazon.com.</p>
<p>
Control Jet Security, by Paul Litwin. Visual Basic Programmer's Journal, September 1996 (Volume 6, Number 10).</p>
<p>
This article details Jet 3.0 security and how to control it from Visual Basic 4.0. Includes code samples for both 16-bit and 32-bit versions of Visual Basic.</p>
<p>
Microsoft Access Security White Paper</p>
<p>
The Microsoft Access 95 version of the Microsoft security white paper can be found at ftp://ftp.microsoft.com/kb/softlib/mslfiles/SECURE70.EXE. At the time this paper went to press, the Microsoft Access 97 version of the white paper was not yet available. There are very little changes in security, however, between Microsoft Access 95 and Microsoft Access 97. (It's also possible that the Microsoft Access 97 version of the white paper will be available by the time you read this. Look for a similarly-named file at http://www.microsoft.com/kb/softlib/mslfiles/.)</p>
<p>
Microsoft Access Security FAQ</p>
<p>
The Microsoft Access Security Frequently Asked Questions (FAQ) paper, co-authored by Andy Baron, Mary Chipman, Chris Bell, and Paul Litwin, can be found at http://www.wji.com/access/w1002314.html. This paper provides answers to a number of commonly asked security questions for all versions of Microsoft Access and Visual Basic.</p>
<p>
&copy; 1997 Microsoft Corporation. All rights reserved.</p>
<p>
The information contained in this document represents the current view of Microsoft Corporation on the issues discussed as of the date of publication. Because Microsoft must respond to changing market </p>
<p>
conditions, it should not be interpreted to be a commitment on the part of Microsoft, and Microsoft cannot guarantee the accuracy of any information presented after the date of publication.</p>
<p>
This document is for informational purposes only. MICROSOFT MAKES NO WARRANTIES, EXPRESS OR IMPLIED, IN THIS SUMMARY.</p>
<p>
Microsoft and Visual Basic are registered trademarks and SQL Server is a trademark of Microsoft Corporation.</p>
<p>
Other product or company names mentioned herein may be the trademarks of their respective owners.</p>
</font></BODY>
</HTML>
