<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Multitier Client/Server Applications with Microsoft Visual FoxPro</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>



	<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>



	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<h1>Multitier Client/Server Applications with Microsoft Visual FoxPro</h1>
<p>
Presented by:&#09;Robert Green</p>
<p>
Robert Green is a product manager for desktop databases in the Tools Marketing division at Microsoft Corporation.</p>
<p>
Phone: (425) 882-8080<BR>Fax: (425) 936-7329<BR>Email: rgreen@microsoft.com</p>
<h2>Introduction</h2>
<p>
The Microsoft&reg; Visual FoxPro™ database is a robust and powerful interface for client/server applications. Remote views and Structured Query Language (SQL) pass-through provide powerful tools to take advantage of SQL servers such as ORACLE&reg; and Microsoft SQL Server™ client/server database management system using ODBC (Open Database Connectivity).</p>
<p>
One of the great truisms of application development is that there are many ways to do something. One of the hardest things to do when building an application is to decide on an approach and to know if it is better than the other approaches. In client/server development this is compounded by the fact that you are dealing with two database engines, Visual FoxPro as the interface and a very powerful SQL database engine on the server. </p>
<p>
In this session a Microsoft ActiveX™ Automation server framework built with Visual FoxPro is used to create three-tier client/server applications. Adding a middle layer gives you an additional place to put code and perform validations. </p>
<h2>The Fat Client Problem</h2>
<p>
The client/server application developer's dilemma is knowing how to split up the work between the applications and servers. Visual FoxPro and SQL Server both have very powerful database engines. Both have powerful programming languages and are capable of validating data and enforcing business rules. </p>
<p>
There has been much talk in the industry about fat clients and thin clients and the effect they have on your client/server development efforts. As the available front-end tools have grown in power there has been a tendency to rely on them more. This does ease the burden on the server but it can also lead to problems. </p>
<p>
The first problem with loading up the front end is that it requires a more powerful computer. If you are using Visual FoxPro as the front end you will want at least a 486 with 12 MB of RAM. This issue spawned the phrase fat client. When choosing a front end, girth is a consideration .. You need to weigh the strengths and weaknesses and resource requirements of Visual FoxPro, the Visual Basic&reg; programming system, the Microsoft Access database, Delphi, PowerBuilder&reg;, Java™, and others. Java promiss to be a truly thin client that has enough power to be a robust front end. Visual FoxPro 5.0 is significantly less fat than version 3.0.</p>
<p>
The second problem with having the front end do a lot of the work is that if your validations and business rules change you have to change the code in the front end. This may or may not be a problem. Suppose you are developing the Visual FoxPro front end and you also happen to be in charge of the SQL Server back end. If you write the validation and business rule code, you will presumably write it once, either in Visual FoxPro, as SQL Server–stored procedures, or as some combination of the two. If some logic has to be changed and you are the one who changes it, how much of an issue will be the location of the code?</p>
<p>
On the other hand, you may be writing the front end and not have any say on the back end. You may not be allowed to write your own select, insert, update, and delete procedures. The keepers of the back end may limit you to using stored procedures only . This approach guarantees that the front end does things right. If your only access to the data is through the stored procedures, you will be forced to do things in the correct order and not leave out any steps. For instance, if you are deleting a member, you will not forget to remove the member's reservations. If you are adding a new member, you will not forget to put the new ID into the Adult table. </p>
<p>
If your front end is one of several front ends all accessing the same back-end data, you will want all logic to be on the back end. That way, if any of it needs to change it only needs to be changed in one place.</p>
<h2>Multitier Architecture</h2>
<p>
A recent advance in client/server development is the three-tier architecture scheme. Traditional client/server development is two-tier, consisting of a client and a server. As previously discussed, this can lead to problems if too much work is concentrated in either the client or the server. The three-tier architecture introduces a middle layer, which serves to ease the processing burden for both the client and the server. </p>
<p>
In a classic three-tier architecture, shown in Figure 1, each tier is responsible for providing a service. The client provides user services, consisting mainly of the user interface. The server provides data services, consisting of the data and the means of accessing and maintaining it. The middle layer provides business services, consisting of data validations and enforcement of business rules. </p>
<p>
<img src="ent519ef_1.gif" border=0></p>
<p>
<b>Figure 1. A Layered application architecture</b></p>
<p>
To fully realize the potential of this architecture, you should make the middle layer easily accessible to multiple front ends. If it is enforcing your business rules then all clients need to be able to talk to it. This is true whether the clients are written in Visual FoxPro, Visual Basic or another language. </p>
<p>
The middle tier should be running on a separate machine. This allows it to be accessible to multiple clients and it provides for the maximum performance. Because the problem with fat clients is that the client machine is overburdened. In a two-tier architecture you may have to provide each of the clients with at least a 16 MB Pentium&reg; machine. In a three-tier architecture you can locate the middle layer on a 32 MB dual microprocessor Pentium machine but use a 12 MB 486 as the client. </p>
<p>
There are several ways to set up the middle layer. One approach is to use a SQL Server machine as both the middle layer and server, such as using an Automation server created in Visual FoxPro. The Automation server is called from Visual FoxPro or any Automation controller using the CreateObject() function, in the same manner as you call a Microsoft Excel spreadsheet or Microsoft Word word-processor as Automation servers. </p>
<h2>Creating a Visual FoxPro Automation Server</h2>
<p>
To create an Automation server in Visual FoxPro, read <i>Custom OLE Servers</i> on the Visual FoxPro Web site (www.microsoft.com), or see Chapter 16 of the <i>Visual FoxPro Developers Guide</i>.</p>
<p>
The Automation server can be created as an InProc or OutOfProc server. In the world of the Win32&reg; application programming interface (using Windows&reg; 95 and Windows NT&reg; operating systems) a process is a running application and can address up to 4 GB of memory, half of which is used to store the processes code and data and half of which is used by the system. An InProc server is compiled as a dynamic-link library (DLL) and runs in the same address space as the process that called it. An OutOfProc server is compiled as an executable and runs as a separate process. An InProc server offers better performance because <i>interprocess</i> communication is slower than <i>intraprocess</i> communication. On the other hand, since an OutOfProc server runs in a separate process you can take advantage of a multiprocessor environment. </p>
<p>
The Automation server can be run locally or remotely. Typically, a remote Automation server is created as an OutOfProc server and sits on a powerful computer. That allows it to be accessed by any number of client machines. The Remote Automation Connection Manager can be used to configure the server and client machines for remote automation.</p>
<h2>The Sample Data</h2>
<p>
The data used in this session's examples is from a SQL Server–based application for a library. The library wants to keep track of its members, books and loans. The library database schema is shown in Figure 2.</p>
<p>
<img src="ent519ef_2.gif" border=0></p>
<p>
<b>Figure 2. Library database schema</b></p>
<h3>Table Structures</h3>
<p>
One of the central tables in the library application is the Member table, which contains one row for every member of the library. The juveniles can only be members of the library if they have a sponsoring adult. Since a juvenile lives, presumably, in the same place as the adult there are separate tables for adults and juveniles. This saves disk space because a juvenile's address information is redundant once you know who the adult is. Also, the juvenile's expiration date is the same as the adult's. Furthermore, you don't care about the adult's birth date although you do care about a juvenile's birth date because on their 18<sup>th</sup> birthday he or she becomes an adult. </p>
<p>
The following code shows the SQL Server statements used to create the Member, Adult and Juvenile tables:</p>
<pre><FONT FACE="Courier New" SIZE="2">CREATE TABLE member
  ( member_no        member_no    NOT NULL IDENTITY(1,1),
    lastname         shortstring  NOT NULL ,
    firstname        shortstring  NOT NULL ,
    middleinitial    letter           NULL ,
    photograph       image            NULL )

CREATE TABLE adult
  ( member_no        member_no    NOT NULL ,
    street           shortstring  NOT NULL ,
    city             shortstring  NOT NULL ,
    state            statecode    NOT NULL ,
    zip              zipcode      NOT NULL ,
    phone_no         phonenumber      NULL ,
    expr_date        datetime     NOT NULL )

CREATE TABLE juvenile
  ( member_no        member_no    NOT NULL ,
    adult_member_no  member_no    NOT NULL ,
    birth_date       datetime     NOT NULL )
</font></pre>
<p>
The member_no field in the Member table is generated automatically by SQL Server when a new row is added. This field is an Identity column. The seed value of 1 and the increment value of 1 specify that the first row entered into the table should have a member_no of 1. For every row inserted after that the member_no is incremented by 1. When adding a row the client does not specify the member_no. SQL Server takes care of it automatically and the client can ask what number was used.</p>
<p>
The member_no field in the Adult and Juvenile tables is not an Identity column. The value in that column has to match the member_no of the corresponding row in the Member table. When a new member is added to the library, a row is first added to the Member table. The SQL Server global variable @@Identity contains the automatically generated member_no. A row is then added to the Adult or Juvenile table and the value for the member_no will be whatever is in @@Identity.</p>
<h3>Declarative Referential Integrity</h3>
<p>
In prior versions of SQL Server referential integrity was enforced through the use of triggers, which is the same way Visual FoxPro enforces referential integrity. SQL Server version 6.0 added declarative referential integrity (RI), so you can define your RI rules as part of the data structure. The first step is to create a Primary Key constraint in each table, as shown in the following code:</p>
<pre><FONT FACE="Courier New" SIZE="2">ALTER TABLE member
  ADD CONSTRAINT member_ident PRIMARY KEY CLUSTERED 
    (member_no) 
ALTER TABLE adult
  ADD CONSTRAINT adult_ident PRIMARY KEY CLUSTERED
    (member_no) 
ALTER TABLE juvenile
  ADD CONSTRAINT juvenile_ident PRIMARY KEY CLUSTERED 
      (member_no) 
</font></pre>
<p>
The Primary Key constraint creates a Unique index, which enforces the uniqueness of the member_no. In these examples a clustered index, which physically sorts the data, is created. </p>
<p>
The second step in defining declarative referential integrity is to create Foreign Key constraints between related tables, as shown in the following code:</p>
<pre><FONT FACE="Courier New" SIZE="2">ALTER TABLE adult
  ADD CONSTRAINT adult_member_link FOREIGN KEY (member_no) 
      REFERENCES member (member_no)
ALTER TABLE juvenile
  ADD CONSTRAINT juvenile_member_link FOREIGN KEY
     (member_no) REFERENCES member (member_no)
ALTER TABLE juvenile
  ADD CONSTRAINT juvenile_adult_link FOREIGN KEY 
    (adult_member_no) REFERENCES adult (member_no)
</font></pre>
<p>
The first Alter Table defines a relationship between the Member and Adult tables. This is a one-to-one relationship, although there is nothing in the code to indicate or enforce that aspect of the relationship. The second Alter Table defines a relationship between the Member and Juvenile tables. The final Alter Table defines a relationship between the Adult and Juvenile tables. This is a one-to-many relationship.</p>
<p>
Be aware that SQL Server currently does not support cascading updates or deletes. If you want those you can use triggers instead of constraints.</p>
<h2>The Library Automation Server</h2>
<p>
The Library Automation Server uses SQL pass-through to talk to the SQL Server Library database. The server will contain methods to take actions such as retrieving information for a member, adding a new member, changing a member's information and deleting a member. The server exposes a few properties, including properties to determine what errors have occurred. </p>
<p>
The Automation Server project is the file LibraryServer.pjx. The project contains a custom class called Members. Click the appropriate check box in the Class Info dialog box to identify the OLE Public class.</p>
<p>
The methods and properties of the Members class, and hence the Automation Server, are listed in Table 1 and Table 2, respectively.</p>
<p>
<b>Table 1: Library Automation Server Methods</b></p>
<table>
<tr valign=top>
<td>
<b>Method</b></td>
<td>
<b>Visibility</b></td>
<td>
<b>Description</b></td>
</tr>
<tr valign=top>
<td>
InitConnection</td>
<td>
Public</td>
<td>
Initiate a connection to SQL Server.</td>
</tr>
<tr valign=top>
<td>
CloseConnection</td>
<td>
Public</td>
<td>
Close the connection to SQL Server.</td>
</tr>
<tr valign=top>
<td>
GetMember</td>
<td>
Public</td>
<td>
Retrieve information for a member.</td>
</tr>
<tr valign=top>
<td>
AddMember</td>
<td>
Public</td>
<td>
Add a new member.</td>
</tr>
<tr valign=top>
<td>
UpdateMember</td>
<td>
Public</td>
<td>
Update a member's information.</td>
</tr>
<tr valign=top>
<td>
RemoveMember</td>
<td>
Public</td>
<td>
Remove a member.</td>
</tr>
<tr valign=top>
<td>
SetError</td>
<td>
Protected</td>
<td>
Store the SQL Server error.</td>
</tr>
<tr valign=top>
<td>
Convert</td>
<td>
Protected</td>
<td>
Convert values to strings.</td>
</tr>
</table><br>
<p>
<b>Table 2: Library Automation Server Properties</b></p>
<table>
<tr valign=top>
<td>
<b>Property</b></td>
<td>
<b>Visibility</b></td>
<td>
<b>Description</b></td>
</tr>
<tr valign=top>
<td>
nHandle</td>
<td>
Public</td>
<td>
Connection handle</td>
</tr>
<tr valign=top>
<td>
NewID</td>
<td>
Public</td>
<td>
ID of newly added member</td>
</tr>
<tr valign=top>
<td>
LastErrDesc</td>
<td>
Public</td>
<td>
Description of the last error that occurred</td>
</tr>
</table><br>
<p>
In the Project Info dialog box, shown in Figure 3, the project has been given the name VFPLibraryOLEServer. This, combined with the class name Members, yields the registered OLE name of VFPLibraryOLEServer.Members. This can be found in the HKEY_CLASSES_ROOT hive in the Registry, as shown in Figure 4.</p>
<p>
<img src="ent519ef_3.gif" border=0></p>
<p>
<b>Figure 3. Libraryserver project information dialog box</b></p>
<p>
The Automation server is registered automatically on the machine that built it. If you move it to another machine you can register it by running Regsvr32.exe, found in the Windows/System directory in Windows 95 and in the Windows/System32 directory in Windows NT.</p>
<p>
<img src="ent519ef_4.gif" border=0></p>
<p>
<b>Figure 4. Windows registry showing automation server</b></p>
<p>
To use the Automation server, a client application uses a similar line of code:</p>
<pre><FONT FACE="Courier New" SIZE="2">oLibrary = CreateObject(&quot;VFPLibraryOLEServer.Members&quot;)
</font></pre>
<p>
Visual FoxPro first checks this code to see if the object name is a Visual FoxPro class. If it isn't, the Registry is checked. The object name is found and the CLSID, the object's unique identifier, is noted. </p>
<p>
Also in the Registry's HKEY_CLASSES_ROOT hive is a key named CLSID, which contains an entry for all objects that have CLSIDs. As shown in Figure 5, the Registry stores the executable file associated with each CLSID. That is how Windows knows to start the Automation Server when Visual FoxPro executes its CreateObject command.</p>
<p>
<img src="ent519ef_5.gif" border=0></p>
<p>
<b>Figure 5. Registry CLSID entries for Library Automation Server</b></p>
<h2>Using the Library Automation Server</h2>
<p>
The form Membolefp.scx uses the Visual FoxPro Library Automation server as the middle layer to talk to the SQL Server Library database. After calling the server, the form invokes methods to retrieve member information, delete and update members, etc. </p>
<h3>Loading the Form</h3>
<p>
To call the Automation server, the form uses the same CreateObject() function that is used to call Microsoft Excel or Word. The official registered name of the Automation server as it appears in the Windows Registry is vfpLibraryOLEServer.Members. The following code is located in the Load event of the form:</p>
<pre><FONT FACE="Courier New" SIZE="2">This.oLibrary = CreateObject(&quot;vfpLibraryOLEServer.Members&quot;)

If Type(&quot;This.oLibrary&quot;) # &quot;O&quot; Or IsNull(This.oLibrary)
  = MessageBox(&quot;Couldn't set up the OLE Server.&quot;, ;
               MB_ICONINFORMATION)
  This.lConnected = .F.
  Return
Else
  If This.oLibrary.InitConnection(&quot;robertg&quot;,&quot;vfpguru&quot;)
    = MessageBox(&quot;Welcome to the library&quot;, MB_ICONINFORMATION)
    ThisForm.lConnected = .T.
  Else
    = MessageBox(&quot;Access to the library denied&quot;, ;
                 MB_ICONINFORMATION)
    This.lConnected = .F.
    Return
  Endif  
Endif 
</font></pre>
<p>
The code tries to create a reference to the Automation server. If it works, the form property oLibrary will contain a reference to the Automation server. If the reference can't be created, there is nothing left to do. If the object can be created, the form will invoke the InitConnection method of the Automation server in an attempt to log on to SQL Server. If that doesn't work, there is nothing to do.</p>
<p>
If the connection is made successfully, the form creates a cursor and then sets optimistic row buffering. The cursor will be used for adding and editing and allows you to use familiar data entry functions such as GetFldState() and OldVal(), as you will see later.</p>
<pre><FONT FACE="Courier New" SIZE="2">Set Multilocks On
Create Cursor c_member ;
  ( member_no I, firstname C(50), middleinitial C(1), ;
    lastname C(50), street C(50), city C(50), state C(10), ;
    zip C(10), phone_no C(20), expr_date T, ;
    birth_date T, adult_member_no I )
= CursorSetProp(&quot;Buffering&quot;, DB_BUFOPTRECORD, 'c_member')
</font></pre>
<h3>Connecting to SQL Server</h3>
<p>
The InitConnection method of the Automation server takes the user ID and password as parameters and then uses SQLConnect() to connect to SQL Server. The method returns true if the connection worked and false if it didn't.</p>
<pre><FONT FACE="Courier New" SIZE="2">lParameters cUserID, cPassword
This.nHandle = SQLConnect('Library', cUserID, cPassword)
Return Iif(This.nHandle &lt; 0, .F., .T.)
</font></pre>
<h3>Locating a Member</h3>
<p>
The GetMember method of the Automation server is used to retrieve information for a member. In the SQL pass-through examples from Session BKO02, the sample forms used SQLExec() to either run a Select statement or to execute a stored procedure. In either case the results were returned in a cursor, which was then used to populate the form. </p>
<p>
Because the Automation server is specifically designed to be used with any client, including Microsoft Access and Visual Basic, it cannot simply return results in a Visual FoxPro cursor. </p>
<p>
The Automation server's GetMember method takes three parameters: a string that holds a delimited list of the retrieved data, the character you want to use as the delimiter, and the ID of the member you want retrieved. The Click event of the form's Locate button calls the GetMember method of the Automation server. </p>
<p>
The string is passed by reference because the GetMember method will fill it with the member's information. The delimiter character will be used to separate the columns of information. If GetMember returns 0, there is no member with the supplied ID. If it returns a negative number, there was an error, which will be stored in the Automation server's LastErrDesc property.</p>
<pre><FONT FACE="Courier New" SIZE="2">nRetVal = ThisForm.oLibrary.GetMember(@lcMemberInfo, &quot;|&quot;, ;
          ThisForm.txtMemberID.Value)

If nRetVal &lt; 0
  lcMessage = ThisForm.oLibrary.LastErrDesc
  = MessageBox(Substr(lcMessage, RAt(']',lcMessage)+1), ;
               MB_ICONINFORMATION) 
&lt;code intentionally left out&gt;
If nRetVal = 0
  = MessageBox(&quot;There is no member with this ID.&quot;, ;
                MB_ICONINFORMATION)
&lt;code intentionally left out&gt;
</font></pre>
<p>
If the member's information is found, the string needs to be parsed to read the individual columns of information. The cursor created in the form's Load method is populated with the information and the form is refreshed.</p>
<pre><FONT FACE="Courier New" SIZE="2">For i = 1 To 10
  j = AllTrim(Str(i))
  nPipe&amp;j = At(&quot;|&quot;, lcMemberInfo, i)
Next  
nPipe11 = Len(lcMemberInfo)

Select c_member
Append Blank
Replace ;
    firstname       With Substr(lcMemberInfo, 1, nPipe1 - 1), ;
    middleinitial   With Substr(lcMemberInfo, nPipe1 + 1, ;
                                    nPipe2 - nPipe1 - 1), ;
    lastname        With Substr(lcMemberInfo, nPipe2 + 1, ;
                                    nPipe3 - nPipe2 - 1), ;
    street          With Substr(lcMemberInfo, nPipe3 + 1, ;
                                    nPipe4 - nPipe3 - 1), ;
    city            With Substr(lcMemberInfo, nPipe4 + 1, ;
                                    nPipe5 - nPipe4 - 1), ;
    state           With Substr(lcMemberInfo, nPipe5 + 1, ;
                                    nPipe6 - nPipe5 - 1), ;
    zip             With Substr(lcMemberInfo, nPipe6 + 1, ;
                                    nPipe7 - nPipe6 - 1), ;
    phone_no        With Substr(lcMemberInfo, nPipe7 + 1, ;
                                    nPipe8 - nPipe7 - 1), ;
    expr_date       With Ctot(Substr(lcMemberInfo, nPipe8 + 1, ;
                                         nPipe9 - nPipe8 - 1)), ;
    birth_date      With Ctot(Substr(lcMemberInfo, nPipe9 + 1, ;
                                         nPipe10 - nPipe9 - 1)), ;
    adult_member_no With Val(Substr(lcMemberInfo, nPipe10 + 1, ;
                                        nPipe11 - nPipe10 - 1))
&lt;code intentionally left out&gt;
ThisForm.Refresh
&lt;code intentionally left out&gt;
</font></pre>
<p>
The code in the For loop determines the location of each pipe delimiter. Everything up to the first delimiter is the member's first name. Everything between the first delimiter and the second is the member's middle initial. Everything between the second delimiter and the third is the member's last name. </p>
<h3>The Automation Server's GetMember Method</h3>
<p>
As mentioned above, the GetMember method of the Automation server takes three parameters, a string that will contain a delimited list of the member's information, the delimiter and the member ID of the desired member. A Select statement is constructed and sent to SQL Server to retrieve the information. If the member is found, the string is constructed. Since the string was passed by reference it will be sent back to the form. The GetMember method itself returns 0 if the member was not found and 1 if the member was found.</p>
<pre><FONT FACE="Courier New" SIZE="2">LParameters cMemberInfo, cDelimiter, cSearchID
lcSQL = &quot;Select firstname, middleinitial, lastname, street, &quot; + ;
        &quot;  city, state, zip, phone_no, expr_date, &quot; + ;
        &quot; birth_date = null, adult_member_no = null &quot; + ;
        &quot;From member, adult &quot; + ;
        &quot;Where member.member_no = adult.member_no &quot; + ;
        &quot;  And member.member_no = &quot; + AllTrim(cSearchID) + &quot; &quot; + ;
        &quot;Union &quot; + ;
        &quot;Select firstname, middleinitial, lastname, street, &quot; + ;
        &quot;  city, state, zip, phone_no, expr_date, &quot; + ;
        &quot;  birth_date, adult_member_no &quot; + ;
        &quot;From member, adult, juvenile &quot; + ;
        &quot;Where member.member_no = juvenile.member_no &quot; + ;
        &quot;  And adult.member_no = juvenile.adult_member_no &quot; + ;
        &quot;  And member.member_no = &quot; + AllTrim(cSearchID)
&lt;code intentionally left out&gt;
If RecCount(&quot;c_member&quot;) = 0
  Return 0
Else
  cMemberInfo = AllTrim(This.Convert(c_member.firstname)) + ; + 
                cDelimiter + ;
                AllTrim(This.Convert(c_member.middleinitial)) + ; 
                cDelimiter + ;
                AllTrim(This.Convert(c_member.lastname)) + ;
                cDelimiter + ;
                AllTrim(This.Convert(c_member.street)) + ;
                cDelimiter + ;
                AllTrim(This.Convert(c_member.city)) + ;
                cDelimiter + ;
                AllTrim(This.Convert(c_member.state)) + ;
                cDelimiter + ;
                AllTrim(This.Convert(c_member.zip)) + ;
                cDelimiter + ;
                AllTrim(This.Convert(c_member.phone_no)) + ; 
                cDelimiter + ;
                AllTrim(This.Convert(c_member.expr_date)) + ;
                cDelimiter + ;
                AllTrim(This.Convert(c_member.birth_date)) + ;
                cDelimiter + ;
                AllTrim(This.Convert(c_member.adult_member_no))+ ;
                cDelimiter
  Return RecCount(&quot;c_member&quot;) 
Endif
</font></pre>
<h3>Adding an Adult</h3>
<p>
The AddMember method of the Automation server is used to add a member to the library. For ease of use the method takes as a parameter a two-dimensional array. The first column contains field names and the second column contains the associated information. The form's AddMember method is called from the Click event of the Save button and in turn calls the GetMember method of the Automation server.</p>
<pre><FONT FACE="Courier New" SIZE="2">Dimension laMember[11,2]
laMember[1,1] = &quot;firstname&quot;
laMember[2,1] = &quot;middleinitial&quot;
laMember[3,1] = &quot;lastname&quot;
laMember[4,1] = &quot;street&quot;
laMember[5,1] = &quot;city&quot;
laMember[6,1] = &quot;state&quot;
laMember[7,1] = &quot;zip&quot;
laMember[8,1] = &quot;phone_no&quot;
laMember[9,1] = &quot;expr_date&quot;
laMember[10,1] = &quot;birth_date&quot;
laMember[11,1] = &quot;adult_member_no&quot;

* Some of the data is either left empty or supplied by the server
laMember[1,2] = AllTrim(ThisForm.txtFirstName.Value)
laMember[2,2] = AllTrim(ThisForm.txtMiddleInitial.Value)
laMember[3,2] = AllTrim(ThisForm.txtLastName.Value)
laMember[4,2] = AllTrim(ThisForm.txtStreet.Value)
laMember[5,2] = AllTrim(ThisForm.txtCity.Value)
laMember[6,2] = AllTrim(ThisForm.txtState.Value)
laMember[7,2] = AllTrim(ThisForm.txtZip.Value)
laMember[8,2] = AllTrim(ThisForm.txtPhoneNumber.Value)

If ThisForm.oLibrary.AddMember(@laMember) &lt; 0
  lcMessage = ThisForm.oLibrary.LastErrDesc
  = MessageBox(Substr(lcMessage, RAt(']',lcMessage)+1), ;
               MB_ICONINFORMATION)
Else
  = MessageBox(&quot;This member has been added.&quot;, MB_ICONINFORMATION)
  * Find out the member_no of the new member
  ThisForm.txtMemberID.Value = ;
    AllTrim(Str(ThisForm.oLibrary.NewID))
&lt;code intentionally left out&gt;
</font></pre>
<p>
The first column of the array laMember contains the names of the fields. The second column contains the actual data, which is taken from the controls on the form. The array is passed (by reference to ensure it all goes) to the AddMember method, which returns 1 if the member was added, and -1 if he or she wasn't. The LastErrDesc property of the Automation server displays the error message if the addition was unsuccessful.</p>
<h3>The Automation Server's AddMember Method</h3>
<p>
As mentioned above, the AddMember method of the Automation server takes one parameter, an array of field names and values.</p>
<pre><FONT FACE="Courier New" SIZE="2">LParameters aMemberInfo
</font></pre>
<p>
Adding a member to the library is a two-step procedure. First, a new row is added to the Member table, which contains the member's name. The member_no field in that table has been assigned the Identity property and SQL Server automatically determines the next value to use. The second step is to add a corresponding row to the Adult table, which contains the member's address. The same member_no must be used in both tables to maintain the one-to-one relationship.</p>
<p>
The two steps need to be part of a transaction so that either both rows go in correctly or neither go in.</p>
<pre><FONT FACE="Courier New" SIZE="2">= SQLSetProp(This.nHandle, &quot;Transactions&quot;, 2)
</font></pre>
<p>
Next, an Insert statement for the Member table is constructed and sent to SQL Server. If the Insert fails the transaction is rolled back and the AddMember method returns -1, alerting the client that the Insert failed. </p>
<pre><FONT FACE="Courier New" SIZE="2">cSQL = &quot;Insert member (firstname, middleinitial, lastname, &quot; + ;
                       &quot;photograph) &quot; + ;
       &quot;Values ('&quot; + AllTrim(aMemberInfo[1,2]) + &quot;', &quot; + ;
               &quot;'&quot; + AllTrim(aMemberInfo[2,2]) + &quot;', &quot; + ;
               &quot;'&quot; + AllTrim(aMemberInfo[3,2]) + &quot;', &quot; + ;
               &quot;NULL)&quot;
If SQLExec(This.nHandle, cSQL) &lt; 0
  This.SetError
  * Rollback the transaction
  = SQLRollback(This.nHandle)
  Return -1
Endif
</font></pre>
<p>
The SQL Server global variable @@Identity stores the most recent value inserted into an Identity column. In this case it contains the new user's member_no. That number is stored in the NewID property of the Automation server.</p>
<pre><FONT FACE="Courier New" SIZE="2">If SQLExec(This.nHandle, &quot;Select @@identity&quot;) &lt; 0
  This.SetError
  * Rollback the transaction
  = SQLRollback(This.nHandle)
  Return -1
Endif
This.NewID = sqlresult.exp
</font></pre>
<p>
Next, the corresponding row in the Adult table is added. The value for member_no comes from the value of @@Identity. As before, if this Insert fails, the whole transaction is rolled back and AddMember returns -1.</p>
<pre><FONT FACE="Courier New" SIZE="2">cSQL = &quot;Insert adult (member_no, street, city, state, zip, &quot; + ;
                     &quot;phone_no, expr_date) &quot; + ;
       &quot;Values (&quot; + AllTrim(Str(This.NewID)) + &quot;, &quot; + ;
               &quot;'&quot; + AllTrim(aMemberInfo[4,2]) + &quot;', &quot; + ;
               &quot;'&quot; + AllTrim(aMemberInfo[5,2]) + &quot;', &quot; + ;
               &quot;'&quot; + AllTrim(aMemberInfo[6,2]) + &quot;', &quot; + ;
               &quot;'&quot; + AllTrim(aMemberInfo[7,2]) + &quot;', &quot; + ;
               &quot;'&quot; + AllTrim(aMemberInfo[8,2]) + &quot;', &quot; + ;
               &quot;'&quot; + TToC(DToT(GoMonth(Date(),12))) + &quot;' )&quot;
If SQLExec(This.nHandle, cSQL) &lt; 0
  This.SetError
  * Rollback the transaction
  = SQLRollback(This.nHandle)
  Return -1
Endif
</font></pre>
<p>
The last step is to try to commit the transaction. If that fails, everything is rolled back. If the Commit works, the new member has been added and AddMember returns 1, indicating success. </p>
<pre><FONT FACE="Courier New" SIZE="2">If SQLCommit(This.nHandle) &lt; 0
  This.SetError
  * Rollback the transaction
  = SQLRollback(This.nHandle)
  Return -1
Else
  Return 1
Endif
</font></pre>
<h3>Saving Changes</h3>
<p>
The UpdateMember method of the form calls the UpdateMember method of the Automation server. The form passes to the Automation server a two-dimensional array and the ID of the member. As with the AddMember method above, the first column of the array contains the names of fields to be updated, while the second column contains the new information for a particular member.</p>
<p>
When a member is added, the array adds a row for each field. In this case, however, it should contain a row for only those fields where the value has changed. SQL Server does not update information that hasn't changed. </p>
<p>
The form looks at each control to see if its value has changed. If so, a row is added to the array. Notice the use of OldVal() to see if the field changed. The use of the buffered cursor makes this possible.</p>
<pre><FONT FACE="Courier New" SIZE="2">i = 0
If c_member.firstname &lt;&gt; OldVal(&quot;c_member.firstname&quot;)
  i = i + 1
  Dimension laMember[i, 2]
  laMember[i,1] = &quot;firstname&quot;
  laMember[i,2] = AllTrim(ThisForm.txtFirstName.Value)
Endif
If c_member.lastname &lt;&gt; OldVal(&quot;c_member.lastname&quot;)
  i = i + 1
  Dimension laMember[i, 2]
  laMember[i,1] = &quot;lastname&quot;
  laMember[i,2] = AllTrim(ThisForm.txtLastName.Value)
Endif
&lt;code intentionally left out&gt;
</font></pre>
<p>
If no fields were changed, there is nothing to do and therefore no point in bothering SQL Server.</p>
<pre><FONT FACE="Courier New" SIZE="2">If i = 0
  = MessageBox(&quot;There is nothing to save.&quot;, MB_ICONINFORMATION)
  Return
Endif          
</font></pre>
<p>
If any fields have been changed, the form invokes the UpdateMember method of the Automation server. The array, as well as the member's ID, is passed. If UpdateMember returns -1 the update failed and the reason is displayed to the user.</p>
<pre><FONT FACE="Courier New" SIZE="2">If ThisForm.oLibrary.UpdateMember(@laMember, ;
                                  ThisForm.txtMemberID.Value) &lt; 0
  lcMessage = ThisForm.oLibrary.LastErrDesc
  = MessageBox(Substr(lcMessage, RAt(']',lcMessage)+1), ;
               MB_ICONINFORMATION)
Else
  = MessageBox(&quot;This member's information has been saved.&quot;, ;
               MB_ICONINFORMATION)
&lt;code intentionally left out&gt;
</font></pre>
<h3>The Automation Server's UpdateMember Method</h3>
<p>
As mentioned above, the Automation server UpdateMember method takes two parameters, the array of field names and data and the ID of the member to update.</p>
<pre><FONT FACE="Courier New" SIZE="2">LParameters aMemberInfo, cSearchID
</font></pre>
<p>
Just as adding a member required two Inserts wrapped in a transaction, updating a member requires two Updates wrapped in a transaction. To build each Update statement UpdateMember searches each array for each field. For instance, if the string &quot;firstname&quot; is found in the array and if it is in the first column, the firstname field should be updated in the Member table. Two strings, cSQL1 and cSQL2 are constructed, each containing part of an Update statement.</p>
<pre><FONT FACE="Courier New" SIZE="2">cSQL1 = &quot;&quot;
nPos = AScan(aMemberInfo, &quot;firstname&quot;)
If Mod(nPos, 2) = 1
  cSQL1 = cSQL1 + &quot;firstname = '&quot; + aMemberInfo[nPos + 1] + &quot;', &quot;
Endif
nPos = AScan(aMemberInfo, &quot;lastname&quot;)
If Mod(nPos, 2) = 1
  cSQL1 = cSQL1 + &quot;lastname = '&quot; + aMemberInfo[nPos + 1] + &quot;', &quot;
Endif
&lt;code intentionally left out&gt;
cSQL2 = &quot;&quot;
nPos = AScan(aMemberInfo, &quot;street&quot;)
If Mod(nPos, 2) = 1
  cSQL2 = cSQL2 + &quot;street = '&quot; + aMemberInfo[nPos + 1] + &quot;', &quot;
Endif
nPos = AScan(aMemberInfo, &quot;city&quot;)
If Mod(nPos, 2) = 1
  cSQL2 = cSQL2 + &quot;city = '&quot; + aMemberInfo[nPos + 1] + &quot;', &quot;
Endif
</font></pre>
<p>
A transaction is then begun.</p>
<pre><FONT FACE="Courier New" SIZE="2">= SQLSetProp(This.nHandle, &quot;Transactions&quot;, 2)
</font></pre>
<p>
If anything has been stored to the cSQL1 variable, the rest of the Update statement for the Member table is constructed and passed to SQL Server. If it fails the transaction is rolled back.</p>
<pre><FONT FACE="Courier New" SIZE="2">If Len(cSQL1) &gt; 0
  * Add the Update, strip off the last comma, add a Where clause
  cSQL1 = &quot;Update member Set &quot; + Left(cSQL1, Len(cSQL1) - 2) + ;
          &quot;Where member_no = &quot; + AllTrim(cSearchID)
  If SQLExec(This.nHandle, cSQL1) &lt; 0
    This.SetError
    * Rollback the transaction
    = SQLRollback(This.nHandle)
    Return -1
  Endif
Endif
</font></pre>
<p>
Similarly, if anything has been stored to the cSQL2 variable, the rest of the Update statement for the Adult table is constructed and passed to SQL Server. If it fails the transaction is rolled back.</p>
<pre><FONT FACE="Courier New" SIZE="2">If Len(cSQL2) &gt; 0
  * Add the Update, strip off the last comma, add a Where clause
  cSQL2 = &quot;Update adult Set &quot; + Left(cSQL2, Len(cSQL2) - 2) + ;
          &quot;Where member_no = &quot; + AllTrim(cSearchID)
  If SQLExec(This.nHandle, cSQL2) &lt; 0
    This.SetError
    * Rollback the transaction
    = SQLRollback(This.nHandle)
    Return -1
  Endif
Endif
</font></pre>
<p>
The last step is to commit the transaction. If the Commit fails the transaction is rolled back.</p>
<pre><FONT FACE="Courier New" SIZE="2">If SQLCommit(This.nHandle) &lt; 0
  This.SetError
  * Rollback the transaction
  = SQLRollback(This.nHandle)
  Return -1
Else
  Return 1
Endif
</font></pre>
<h3>Deleting a Member</h3>
<p>
The Automation Server's RemoveMember method is used to delete a member. The method takes as a parameter the ID of the member to delete. RemoveMember returns 1 if the member was deleted and -1 if otherwise. If the deletion fails, the Automation server property LastErrDesc contains the reason. The deletion could fail because referential integrity is violated. For instance, a member with outstanding loans or active juveniles cannot be deleted. It could also fail because a SQLExec() failed. Either way, the form code assumes the reason will be contained in oLibrary.LastErrDesc and can also be displayed to the user.</p>
<pre><FONT FACE="Courier New" SIZE="2">If ThisForm.oLibrary.RemoveMember(ThisForm.txtMemberID.Value) &lt; 0
  lcMessage = ThisForm.oLibrary.LastErrDesc
  = MessageBox(Substr(lcMessage, RAt(']',lcMessage)+1), ;
               MB_ICONINFORMATION)
Else
  = MessageBox(&quot;This member has been deleted.&quot;, ;
               MB_ICONINFORMATION)
&lt;code intentionally left out&gt;
</font></pre>
<h3>The Automation Server's RemoveMember Method</h3>
<p>
The Automation server's RemoveMember method takes one parameter, the member ID of the member the user is attempted to delete.</p>
<pre><FONT FACE="Courier New" SIZE="2">LParameters cSearchID
</font></pre>
<p>
There are several reasons a delete attempt may fail. The two most frequent reasons for this example are because the member either has outstanding loans or is an adult sponsoring active juveniles. If either of those is true the Delete will fail. </p>
<p>
The RemoveMember method code could have been written to try the deletion and then monitor failures to see if either of these is the reason. But this is inefficient, especially compared to the alternative of checking these two conditions first. If the member has active loans or is sponsoring juveniles then the Delete won't even be tried. This makes it easier to trap for the error and also spares processing on the SQL Server.</p>
<pre><FONT FACE="Courier New" SIZE="2">* First check to see if this member has active loans
cSQL = &quot;Select member_no From loan Where member_no = &quot; + ;
       AllTrim(cSearchID)
If SQLExec(This.nHandle, cSQL) &lt; 0
  This.SetError
  Return -1
Else
  If RecCount(&quot;sqlresult&quot;) &lt;&gt; 0  
    This.LastErrDesc = &quot;This member can not be deleted. &quot; + ;
                       &quot;He/she has active loans.&quot;
    Return -1
  Endif  
Endif

* Now check to see if this is an adult with active juveniles
cSQL = &quot;Select member_no From juvenile Where adult_member_no = &quot; ;
       + AllTrim(cSearchID)
If SQLExec(This.nHandle, cSQL) &lt; 0
  This.SetError
  Return -1
Else
  If RecCount(&quot;sqlresult&quot;) &lt;&gt; 0  
    This.LastErrDesc = &quot;This member can not be deleted. &quot; + ;
                       &quot;He/she is an adult with active juveniles.&quot;
    Return -1
  Endif  
Endif
</font></pre>
<p>
If there are other things to check, the code for them could follow the lines above. If none of the obvious problems is present, a transaction is started and the deletion proceeds.</p>
<pre><FONT FACE="Courier New" SIZE="2">= SQLSetProp(This.nHandle, &quot;Transactions&quot;, 2)
</font></pre>
<p>
A member may have related records in the Loanhist table, which contains a row for every borrowed book that was returned, or in the Reservation table, which contains a row for every book on reserve. These related rows are deleted first. If not, referential integrity will be violated when the member was deleted. If either of these Deletes fails the transaction is rolled back.</p>
<pre><FONT FACE="Courier New" SIZE="2">* Delete the loan history records for this member
cSQL = &quot;Delete loanhist Where member_no = &quot; + AllTrim(cSearchID)
If SQLExec(This.nHandle, cSQL) &lt; 0
  This.SetError
  * Rollback the transaction
  = SQLRollback(This.nHandle)
  Return -1
Endif

* Delete the loan reservation records for this member
cSQL = &quot;Delete reservation Where member_no = &quot; + AllTrim(cSearchID)
If SQLExec(This.nHandle, cSQL) &lt; 0
  This.SetError
  * Rollback the transaction
  = SQLRollback(This.nHandle)
  Return -1
Endif
</font></pre>
<p>
Any other related records will also be deleted at this point. Once all the related rows are gone, the member can be deleted, first from the Adult table and then from the Member table. The Deletes must be in this order to preserve referential integrity. Again, if either of these Deletes fails, the transaction is rolled back.</p>
<pre><FONT FACE="Courier New" SIZE="2">* Delete the member's row in the Adult table
cSQL = &quot;Delete adult Where member_no = &quot; + AllTrim(cSearchID)
If SQLExec(This.nHandle, cSQL) &lt; 0
  This.SetError
  * Rollback the transaction
  = SQLRollback(This.nHandle)
  Return -1
Endif

* Delete the member's row in the Member table
cSQL = &quot;Delete member Where member_no = &quot; + AllTrim(cSearchID)
If SQLExec(This.nHandle, cSQL) &lt; 0
  This.SetError
  * Rollback the transaction
  = SQLRollback(This.nHandle)
  Return -1
Endif
</font></pre>
<p>
If the next part is not familiar, you either didn't read the preceding parts of these notes or you slept through them. Commit if go, rollback if no. The RemoveMember method returns -1 if the delete failed and 1 if it succeeded.</p>
<pre><FONT FACE="Courier New" SIZE="2">If SQLCommit(This.nHandle) &lt; 0
  This.SetError
  * Rollback the transaction
  = SQLRollback(This.nHandle)
  Return -1
Else
  Return 1
Endif
</font></pre>
<h3>Storing SQL Server Errors</h3>
<p>
The SetError method of the Automation server stores the SQL Server error to the LastErrDesc property, which is then available to the client.</p>
<pre><FONT FACE="Courier New" SIZE="2">lnError = AError(laError)
This.LastErrDesc = Substr(laError[3], RAt(']',laError[3]) + 1)
</font></pre>
<h2>Black Box Programming with Automation Servers</h2>
<p>
A two-tier approach to client/server development is to use SQL Server stored procedures to add, update, and delete members. A benefit to this technique is that processing occurs on the server and not the client. This not only avoids the fat client problem but also makes it unlikely that developers will jumble the data. For instance, you couldn't forget to remove the member's related loan history records if all you did was invoke a stored procedure. </p>
<p>
Using a three-tier architecture is very similar to using stored procedures in terms of coding difficulty (low) and the level of control you retain (also low). For instance, the code to invoke the stored procedure to delete a member is </p>
<pre><FONT FACE="Courier New" SIZE="2">If SQLExec(ThisForm.nHandle, &quot;Execute RemoveMember &quot; + ;
           ThisForm.txtMemberID.Value) &lt; 0
</font></pre>
<p>
while the code to invoke the equivalent Automation server method is</p>
<pre><FONT FACE="Courier New" SIZE="2">If ThisForm.oLibrary.RemoveMember(ThisForm.txtMemberID.Value) &lt; 0
</font></pre>
<p>
In both of these cases all the developer needs to know is the name of the method or procedure, what parameters it takes and what it returns. Both the SQL Server stored procedures and the Automation server methods become black boxes. </p>
<p>
Someone who is in charge of the front end only doesn't need to know what is in the middle layer as opposed to the back end. He or she may just want to know how to call the methods and how to tell whether they succeeded. </p>
<h2>Where Is the Fat?</h2>
<p>
In a two-tier architecture, SQLExec() can be used from the client form to handle all communications with SQL Server. The select, insert, update, and delete procedures are sent and the results are manipulated as necessary. Most of the work other than the actual physical managing of data is done by the client. The risk here is winding up with a fat client.</p>
<p>
Another two-tier approach is to use SQLExec()to call stored procedures sitting on SQL Server. No work is done on the client, other than managing a local cursor filled with one row at a time. Both data manipulation and validation are performed on the server. The risk here is winding up with a fat server.</p>
<p>
In the example used in this session, the front end does nothing but invoke methods of the Automation server. In fact, in this example, the middle layer looks strikingly like the first SQLExec() example. In fact, much of the code for the Automation server was taken from the form Membexec.scx.</p>
<p>
If all the data validations and business rule checking are put into the middle layer does this lead to a problem of fat middles? Has the fat problem merely been moved up the hierarchy? To be sure, it is possible to overload the Automation server to the point where it can't perform its role satisfactorily. However, since it runs on one machine it will be easier to solve the fat issue by improving the hardware than if the problem were fat clients. For a relatively small amount of money you could stick one or two more microprocessors and 16 or 32 MB more RAM in the middle-tier machine and, conceivably, see any performance problems disappear. Of course, that works only if the processing power of the machine is the bottleneck.</p>
<p>
The important point is that because Visual FoxPro and SQL Server, and for that matter ORACLE and others, have both powerful data engines and powerful languages, you can fine tune the fat. You can decide where to place code and where to put the processing burden and you can tweak it and adjust it until performance is acceptable.</p>
<h2>When Do You Need This?</h2>
<p>
It is not difficult to create a Visual FoxPro Automation server, to call an Automation server's methods from a form or other code, or to set up remote automation. Writing a client/server application using a three-tier architecture is only mildly more difficult than using a two-tier architecture.</p>
<p>
So why would you do it? You need to move up to a three-tier architecture when your client machines are underpowered and, if by moving large chunks of code to a more powerful middle-tier box, you can significantly improve performance. </p>
<p>
How likely is this? While it is true that the resource requirements for Visual FoxPro have decreased with version 5.0, you still want at least a 486 personal computer with 12 MB of RAM. Consider a company who is moving an application off the mainframe and rewriting it using Visual FoxPro and SQL Server. The company buys 100 brand new machines and has a fairly fast network. It may or may not realize a large performance gain by using a three-tier as opposed to two-tier architecture. </p>
<p>
A more compelling reason to consider three-tier architecture is that you can move your data validation and business rules code into one location. Suppose there is a rule that no new orders can be placed if a customer has more than $20,000 60 days past due. In a two-tier architecture you can easily code this into the Click event of the Add button and immediately display a message telling the user he or she can't place the order. The users love it and everyone is happy. </p>
<p>
Suppose the rule changes and the limit is raised to $30,000. How many client machines have to be upgraded? Do you have to regenerate the .app or .exe file and redistribute it? This can be quite a burden and costly. You may have designed the system so that business rules are stored in a metatable somewhere. If not, there is a lot of work to do for a simple change.</p>
<p>
However, if the business rules were in an Automation server, the change is fairly simple. You can change the code and recompile the one .exe. None of the client machines will have to change. The rule will go into effect as soon as the executable was done and the maintenance burden is a fraction of what it could have been.</p>
<p>
Even if a remote Automation server decreased overall performance slightly you can still use it to take advantage of the decreased maintenance burden. </p>
<h2>Conclusion</h2>
<p>
The Automation server middle-layer approach provides several enticing benefits. Because it runs on a separate machine you can run your validations and business rules on a powerful machine without going over your budget. You can purchase one very powerful machine instead of having to upgrade every client. </p>
<p>
When you need to change the validations or business rules you will only need to change the middle layer. You will change the Visual FoxPro code and remake the Automation server. Every client will automatically use the new rules because they are located in a single location. This dramatically simplifies the problem of distributing changes and also guarantees that all clients are using the same, updated, rules.</p>
<p>
&copy; 1997 Microsoft Corporation. All rights reserved. </p>
<p>
The information contained in this document represents the current view of Microsoft Corporation on the issues discussed as of the date of publication. Because Microsoft must respond to changing market conditions, it should not be interpreted to be a commitment on the part of Microsoft, and Microsoft cannot guarantee the accuracy of any information presented after the date of publication.</p>
<p>
This document is for informational purposes only. MICROSOFT MAKES NO WARRANTIES, EXPRESS OR IMPLIED, IN THIS SUMMARY.</p>
<p>
Microsoft, Visual Basic, Win32, Windows, and Windows NT are registered trademarks and ActiveX and Visual FoxPro are trademarks of Microsoft Corporation. </p>
<p>
Java is a trademark of Sun Microsystems, Inc.</p>
<p>
Other product or company names mentioned herein may by the trademarks of their respective owners.</p>
</font></BODY>
</HTML>
