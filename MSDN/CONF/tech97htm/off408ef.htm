<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Integrating Enterprise Data with Microsoft Outlook</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>



	<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>



	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<h1>Integrating Enterprise Data with Microsoft Outlook</h1>
<h2>Introduction</h2>
<p>
This white paper provides an overview of several of the current technologies that Microsoft&reg; Outlook application developers should consider when attempting to integrate Outlook workflow applications with Enterprise data. While Outlook does not currently offer its own native data access functionality, the Item.Application.CreateObject method opens the object door to either Open Database Connectivity Direct (ODBCDirect), which is a subset of Remote Data Objects (RDO) 2.0 or ActiveX Data Objects (ADO). Both of these object models provide fast and efficient access to back-end enterprise data. You can also create ActiveX components to communicate with Enterprise data. An ActiveX component provides a middle-tier in your Workflow application. Using Distributed Component Object Model (DCOM) and Microsoft Transaction Server, these components provide greater security, performance, and error trapping over the complexities of Outlook data access calling either ODBCDirect or ADO from Visual Basic Script (VBScript). I’ll show you a simple ListServer object developed in Microsoft&reg; Visual Basic&reg; 5.0 that provides significant performance enhancements for accessing static data that will be presented to the user in an ActiveX ListBox or ComboBox control on an Outlook form.</p>
<p>
Enterprise data encompasses many forms of data storage&#45;from departmental data that resides on a local area network (LAN)-based database such as Microsoft&reg; Access or Paradox&reg;, corporate data in a relational database management system (RDBMS) such as Microsoft&reg; SQL Server™, Informix&reg; OnLine Dynamic Server, and ORACLE&reg; 7.x Sever, or legacy mainframe data stores such as VSAM, IMS, and DB2&reg;. I’ll show you several different approaches to integrating Enterprise data with Outlook applications. No one method is preferable over the others; the final choice depends upon the nature and design of your workflow application. After this presentation, you should be able to make an informed choice about data access methods depending upon your design goals and data stores.</p>
<h3>Why Integrate Enterprise Data With Outlook Applications?</h3>
<p>
As companies develop workflow applications using the rich messaging and forms development environment of Microsoft&reg; Exchange 5.0, some of these applications will require integration with other corporate data stores. Enterprise data stores reside in a variety of DBMS&#45;from LAN file-based data to mainframe data.</p>
<p>
Outlook/Microsoft Exchange applications store their data in messaging application programming interface (MAPI) data stores. While MAPI data stores are adequate for many workflow applications, more sophisticated applications require additional links with existing corporate data that inhabits more traditional database containers. Additionally MAPI data stores do not lend themselves currently to relational database design. One-to-many relationships cannot be modeled in the typical MAPI folder. You will find that you can add relational design principles to your workflow application by accessing external data and linking that data to your MAPI data store in a relational manner. I’ll discuss this design concept when I take you step by step through the Northwind  Structured Query Language (SQL) Order Application. </p>
<p>
For example, you could design a billing and time tracking application using the Outlook contacts and tasks folders. What happens when the design specification calls for adding general ledger (G/L) codes to specific tasks so that the billing for these tasks can be sent to a corporate invoicing application? If you are the application designer, you know that it’s not practical to code the G/L codes and descriptions into the Column property of an MSForms ComboBox. You’ll have to retrieve the G/L account data from a database in your organization and then load the data into your combo box. Once you have crossed the bridge named enterprise data, you’ll need to consider issues relating to security, performance, data integrity, and scalability. The design alternatives that confront you initially might seem somewhat daunting. The choice that you will finally make depends upon the scope of your project and the depth of your programming resources. I’ll try to point out the pluses and minuses of each approach. </p>
<h3>Methods of Accessing Data in Outlook Forms</h3>
<p>
Currently there are two principle methods of accessing data in Outlook forms. The first and primary method involves writing VBScript code and using the Item.Application.CreateObject(“ProgID”) to instantiate an object model that provides data services to your application. RDO 2.0 ships with Visual Basic 5.0 Enterprise Edition. ODBCDirect, which is part of the DAO 3.5 object model, is in fact a subset of RDO 2.0. Its properties and methods closely resemble those of RDO. RDO implements a thin wrapper over ODBC and provides a high level of developer control and substantial performance gains over Jet and DAO 3.0. However, the RDO object model is complex and hierarchical, a feature which makes it difficult to write and debug in the somewhat constrained environment of VBScript. </p>
<p>
ActiveX Data Objects 1.0 (ADO) is Microsoft’s data access object model of the future. You should heed the following statement from the recently published <u>Data Access Interfaces</u>: “While ADO represents an evolution of both DAO and RDO into a single, simplified, and extensible interface, Microsoft plans that later versions of ADO will supersede all DB-Library, DAO, and RDO functionality.”</p>
<p>
 While my testing of the different data access interfaces showed ADO to be slower than RDO when called from Outlook’s VBScript, this situation is bound to change in the future as OLE DB drivers are created by major database vendors. Currently ADO is the preferred data access object model for Internet Information Server 3.0.  One of the major benefits of ADO is that it requires fewer calls to achieve the same result as RDO. In Outlook’s VBScript environment all variables must be dimensioned as variants. Consequently, all objects pertaining to a given object model are late bound. Late binding of objects strongly suggests that a simpler object model and fewer calls to properties and methods will result in better performance. ADO offers the benefits of simplicity without sacrificing functionality.</p>
<p>
ActiveX components let you encapsulate RDO or ADO functionality within your own objects that can be instanced from VBScript’s CreateObject method. I’ve included both code and components for the ListServerRDO and ListServerADO ActiveX components that implement a CListServer class. The CListServer class was created using Visual Basic 5.0 Enterprise edition. The purpose of this class is to supply a variant array to either Outlook’s MSForms ListBox or ComboBox controls. Both of these controls have List and Column properties. If you assign a variant array to the Column property, the control is populated with data from the array in one statement. The Column property is currently the only means of creating a multicolumn MSForms list box or combo box. In the combo box, the BoundColumn property allows you to determine which column of the drop-down list is bound to the edit portion of the control. Additionally you would bind the edit portion of the combo box control to a user-defined field on an Outlook form. Database filled combo and list boxes are important elements of Outlook forms that use Enterprise data.</p>
<p>
The benefits of custom components for Outlook forms are numerous. First, you can tailor the data access functionality in your component to a specific business application. Security can be tightened within the component framework. If you desire, you can remove the ConnectString property and place all login passwords in the component itself. Error trapping within Visual Basic 5.0 is superior to error trapping within VBScript. You should use the Err.Raise method in the component to return errors to your Outlook form. Performance is enhanced because Visual Basic components use early binding of all data interface objects rather than the late binding of VBScript. For application developers who want to package their components for enterprise distribution, you can use Microsoft Transaction Server and DCOM to distribute those components securely over your network. By using technologies such as Microsoft Transaction Server, systems network architecture (SNA) Server, and the forthcoming “Cedar” (a Microsoft Transaction Server component that allows intranet, Internet and client/server applications to interoperate with mainframe programs), Outlook developers will be able to reach data on the mainframe and create components that provide that data to Outlook forms. For additional information regarding Microsoft’s mainframe interoperability strategy, see “Integrate the Enterprise” (MSDN Library, Backgrounders, Enterprise Computing Articles).</p>
<p>
ActiveX controls will also become available for Outlook forms development. At this point the native MSForms controls on Outlook forms can only be bound to MAPI user-defined fields. Any data binding to remote databases must be accomplished through code. The ActiveX Outlook data control which was in alpha during this writing will provide a means of accessing ODBC compliant databases without writing VBScript code. Finally, the Visual Basic 5.0 Custom Control Edition offers the avenue of customizing ActiveX controls for Outlook forms. You can create those forms on your own or purchase them from third-party vendors.</p>
<p>
Here is a summary outline of the technologies discussed above for providing data access to Outlook forms:</p>
<h4>Using Item.Application.CreateObject (“ProgID”)</h4>
<p>
<b>ODBCDirect (RDO 2.0)</b></p>
<p>
<b>General Features:</b>
<ul>
<li>
Subset of Remote Data Objects 2.0<br><br></li>
<li>
Thin wrapper over ODBC<br><br></li>
<li>
High performance, low memory overhead<br><br></li>
<li>
Supports server-side cursors, asynchronous queries, and batch updating of Recordsets<br><br></li>
<li>
Improved support for stored procedures</li>
</ul>
<p>
<b>Outlook-specific features:</b>
<ul>
<li>
GetRows method provides variant array for MSForms ListBox or ComboBox Column property<br><br></li>
<li>
High level of developer control<br><br></li>
<li>
Uses Data Access Objects (DAO) object model which is familiar to large group of VB developers<br><br></li>
<li>
Ships with Office 97 or Microsoft Exchange/Outlook client</li>
</ul>
<p>
<b>ActiveX Data objects (ADO)</b></p>
<p>
<b>General Features:</b>
<ul>
<li>
Independently created objects<br><br></li>
<li>
Free-threaded objects<br><br></li>
<li>
Uses simpler, less hierarchical object model than ODBCDirect <br><br></li>
<li>
Supports server-side cursors, asynchronous queries, and batch updating of Recordsets<br><br></li>
<li>
Support for stored procedures with in/out parameters and return values</li>
</ul>
<p>
<b>Outlook-specific features:</b>
<ul>
<li>
GetRows method provides variant array for MSForms ListBox or ComboBox Column property<br><br></li>
<li>
Medium level of developer control<br><br></li>
<li>
Numerous code examples available for VBScript<br><br></li>
<li>
Must be installed separately. Does not ship with Outlook.</li>
</ul>
<p>
<b>ActiveX components</b></p>
<h4>General features:</h4>
<ul>
<li>
Create your own Outlook ActiveX components with Visual Basic 5.0 to integrate Outlook forms with Enterprise data. Outlook List Server Automation component provides ClistServer class which is used to populate MSForms combo and list boxes on Outlook forms.<br><br></li>
<li>
Use Distributed COM to provide object instances to your Outlook forms.<br><br></li>
<li>
Improved security with DCOM.<br><br></li>
<li>
Pooled ODBC connections using Microsoft Transaction Server (MTS)<br><br></li>
<li>
Package components with MTS - Let MTS manage the ‘plumbing’ of your objects<br><br></li>
<li>
Use ActiveX components to construct three-tier or n-tier workflow applications</li>
</ul>
<h4>Outlook-specific features:</h4>
<ul>
<li>
GetList method of cListServer class provides variant array for MSForms ListBox or ComboBox Column property.<br><br></li>
<li>
Highest level of developer control.<br><br></li>
<li>
Custom Object methods and properties tailored to your application.<br><br></li>
<li>
Security is contained in ActiveX component - does not require passwords in VBScript code or user logins in Outlook forms.</li>
</ul>
<h4>Using ActiveX Controls</h4>
<p>
<b>Outlook data control</b>
<ul>
<li>
Available for public beta Q2 97<br><br></li>
<li>
Binds to external data sources using ODBC connect strings<br><br></li>
<li>
Creates either edit box, list box, or combo box type of control<br><br></li>
<li>
Read only or read/write functionality<br><br></li>
<li>
Does not require coding<br><br></li>
<li>
For Combo Box control, bind Row Source to external data and Bound Column to user-defined Item field<br><br></li>
<li>
Validation checking</li>
</ul>
<p>
<b>ActiveX custom controls</b>
<ul>
<li>
Write your own VB 5 custom ActiveX control using VB5 CCE<br><br></li>
<li>
Integrate Enterprise data with ActiveX controls that you place on an Outlook form in design mode<br><br></li>
<li>
Third-party ActiveX controls will also be available for Outlook Form design<br><br></li>
<li>
High level of customization<br><br></li>
<li>
Caution: Limited number of events available in Outlook forms container for your custom ActiveX controls</li>
</ul>
<h3>Creating an ActiveX Component for Outlook Data Access</h3>
<p>
The initial point of creating the CListServer class in its various flavors was to provide a testing environment for data access methods through the CreateObject method. Since VBScript does not implement Win32 API calls, CListServer also provides a GetTick method which simply is a wrapper around the GetTickCount API function. GetTickCount returns the number of milliseconds elapsed since Windows started running. GetTick provides an accurate method of determining elapsed time. However, the real benefit of Automation components in Outlook forms is that they can provide a middle tier between the Outlook form and your data store. You can create a persistent database connection in your ActiveX component that serves many users opening forms simultaneously. It is not necessary to open a connection for each user that opens a form. Moreover, you can create static variant arrays for recordsets that are required consistently on the forms in your application. For example, the cmbSuppliers combo box in the Northwind SQL application shows all suppliers so that the end user can select a supplier for the items they wish to order. The GetSuppliers method of CListServer can return the variant array to Outlook with a performance gain in the order of 100-300 times faster than using ODBCDirect natively in VBScript.</p>
<p>
The GetSuppliers and GetShippers methods in CListServer provide variant arrays based upon a predetermined select statement for the Nwind database upsized to SQL Server. To provide greater functionality, the ConnectString property lets you set a connect string which establishes a persistent connection to a remote database through either RDO or ADO. Finally, you call the GetList method which takes a SQL string as its argument and returns a variant array containing the recordset created by the SQL statement.</p>
<p>
For purposes of simplicity, the Northwind SQL Order sample application does not use the CListServer class to access data in SQL Server. The ListServer folder provided with this article contains several examples with VBScript code for using an ActiveX component for data access. I’ll leave it to you to adopt the ListServerADO and ListServerRDO components in the Northwind SQL application. Remember that you can embrace and extend this technology so that all remote data inserts, updates, and deletes are completed via component technology. You’ve moved the bulk of your coding from the sparse environment of VBScript to the robust features of Visual Basic 5.0. C++ developers can also create Outlook ActiveX components using Microsoft Visual C++ 5.0 Enterprise edition. </p>
<h3>Turning the Tables: Accessing Outlook Data for Enterprise databases</h3>
<p>
If you need to turn the tables and access Outlook data in order to write that data to a remote data store, what options do you have? Although this article focuses on bringing enterprise data into Outlook workflow applications, I’ll briefly discuss the current options you face when you want to bring MAPI data into a database. An Microsoft Exchange indexed sequential access method (ISAM) driver is available which can link or import an Microsoft Exchange folder (Mailbox or Public folder) or an Microsoft Exchange Address Book (including the GAL) with Microsoft Access.</p>
<p>
Download the Outlook Microsoft ExchangeWizard at http://www.microsoft.com/AccessDev/AccWhite/ExchWiz.htm. This URL also contains a comprehensive article on “Accessing Exchange and Outlook Data Using Visual Basic.” You should be aware however that the Microsoft Exchange ISAM contains several constraints including the following:
<ul>
<li>
You can't select which fields are available to you in opened and linked folders.<br><br></li>
<li>
The available fields are not editable. You can use the ISAM to add or delete records.<br><br></li>
<li>
You cannot index the records in the linked or imported table.<br><br></li>
<li>
Only a subset of the total number of Microsoft Exchange Client or Outlook fields is available.<br><br></li>
<li>
These fields are preprogrammed in the Microsoft Jet Exchange installable ISAM.<br><br></li>
<li>
No user-defined fields for an custom Outlook form or folder are available through the ISAM.</li>
</ul>
<p>
If you need greater functionality, you should consider (surprise, surprise) building an ActiveX component that uses a combination of the Microsoft Outlook Object Library, the ActiveX Messaging Library 1.1 (available with Microsoft Exchange Server 5.0), and either DAO 3.5, RDO 2.0, or ADO 1.0. An ActiveX component will give you full reciprocal access between your MAPI data store and your Enterprise data.</p>
<h3>Outlook ListServer ADO and Outlook ListServer RDO</h3>
<p>
Two components are included with this article. ListServerRDO uses RDO to provide variant arrays to MSForms combo and list box controls on Outlook forms. ListServerADO uses ADO to accomplish the same functionality. Here are the step-by-step installation instructions for ListRDO. To install ListADO, just follow the same steps but substitute ListADO for ListRDO.</p>
<h4>Installing ListRDO</h4>
<ol>
<li>
Copy ListRDO to an empty subdirectory.<br><br></li>
<li>
Double-click ListRDO in the Explorer. ListRDO is a self-extracting Zip file.<br><br></li>
<li>
Double-click Setup in the subdirectory where you copied ListRDO.<br><br></li>
<li>
Follow the installation instructions in the Setup program. ListServerRDO and ListServerRDODLL will be registered for you automatically. ListServerRDODLL provides exactly the same functionality as ListServerRDO except that it uses an ActiveX DLL instead of an ActiveX EXE.<br><br></li>
<li>
VB5 source code is provided in the SourceRDO.zip file which is contained in ListRDO.</li>
</ol>
<h4>Using ListServerRDO</h4>
<ol>
<li>
Dim a script-level object in VBScript named objListRDO.<br><br></li>
<li>
Set objListRDO = Item.Application.CreateObject(“ListServerRDO.CListServer”)<br><br></li>
<li>
Now you can use the properties and methods of CListServer. See the ListServerRDO Example form in the ListServer folder of Enterprise Data.pst for sample VBScript code. Basically you set a ConnectString property with DSN, UserID, and Password to establish a connection to the remote database. Once the ConnectString has been passed to the ActiveX component, you can call the GetList method to obtain a variant array which you can then assign to the Column property of an MSForms control.</li>
</ol>
<h4>Running the Visual Basic 5.0 Source Code</h4>
<ol>
<li>
You must have Visual Basic 5.0 Enterprise edition installed.<br><br></li>
<li>
Unzip SourceRDO.zip to a directory where you will store this project. <br><br></li>
<li>
Double-click ListServerRDO.vbp in the directory where you unzipped SourceRDO.zip.<br><br></li>
<li>
When the project loads, you will see an Alert Box warning you that VB was “Unable to set the Version Compatible Component.” Press OK to dismiss this warning. Setting the version compatible component ensures that each time you compile your component you do not create a separate ClassID in the registry. The version compatible component is now set to No Compatibility in the Version Compatibility frame.<br><br></li>
<li>
Select the Project | ListServerRDO Properties command, click the Component tab, and select the Compatibility tab. If you want to recompile the component, you should set Version Compatibility option to Binary Compatibility. See “When Should I Use Version Compatibility?” in Visual Basic 5.0 Books Online.</li>
</ol>
<h3>Testing Performance With Sample ListServer Forms</h3>
<p>
You can test the performance of ActiveX components with the Outlook forms contained in the ListServer folder of Enterprise Data.pst. When you press a command button on the sample ListServerRDO and ListServerADO forms, the GetTick method is called to begin timing the process. When the process of retrieving a variant array and populating the ComboBox1 control is complete, the GetTick method is called again and the result in milliseconds is displayed in a message box. An ActiveX component, once instantiated, offers the best performance gains when retrieving data from a remote data source. ADO in its current version 1.0 iteration is slower than RDO. As stated above, this situation is likely to change in the future as ADO begins to come in ‘flavors’ optimized for different environments. Here’s a code fragment that demonstrates how the ListServerRDO object is instantiated and called from VBScript:</p>
<pre><FONT FACE="Courier New" SIZE="2">'Script Level Declarations
Dim ComboBox1
Dim objListRDO
Const rdDriverNoPrompt = 1
Const rdOpenStatic = 3
Sub Item_Open()
Set ComboBox1 = Item.GetInspector.ModifiedFormPages _
(&quot;ListServer Example&quot;).Controls(&quot;ComboBox1&quot;)
Set objListRDO = CreateObject(&quot;ListServerRDO.CListServer&quot;)
End Sub
Sub cmdRDOGetList_Click()
Dim lngStart
Dim lngEnd
Dim strSQL
ComboBox1.Clear
strSQL = &quot;Select CompanyName, Phone, SupplierId &quot;
strSQL = strSQL &amp; &quot;from Suppliers ORDER BY CompanyName&quot;
lngStart = objListRDO.GetTick()
'Modify this connect string if necessary
objListRDO.ConnectString = &quot;DSN=NwindSQL;UID=sa;PWD=&quot;
ComboBox1.Column = objListRDO.GetList(strSQL)
lngEnd = objListRDO.GetTick()
MsgBox &quot;Elapsed Time: &quot; &amp; (lngEnd-lngStart) &amp; &quot;milliseconds&quot;, vbInformation
End Sub
</font></pre>
<p>
The chart shown in Figure 1 provides a dramatic illustration of the performance benefits of ActiveX components.</p>
<p>
<img src="off408ef_1.gif" border=0></p>
<p>
<b>Figure 1. Performance Data for ActiveX Components</b></p>
<h3>Overall Recommendations</h3>
<p>
While it is not possible to draw conclusions that apply to every Outlook application development project that integrates with Enterprise data, the following overall recommendations should be looked at closely when you devise a method for reading and writing remote data in your Outlook forms:
<ol>
<li>
Follow generally accepted client/server design principles. Don’t bring more information from a remote database into your Outlook form than is absolutely necessary. See “Building Successful Client/Server Applications” (MSDN Library, Backgrounders, Enterprise Computing Articles) for a detailed list of accepted principles. Consider calling stored procedures from ActiveX components rather than from within VBScript. Let VBScript call a method in an ActiveX component which in turn calls the stored procedure and returns errors to the calling application. Also maintain referential integrity by using two-phase commits when you write to the remote database. Use the CommitTrans, BeginTrans, and Rollback methods to ensure data integrity.<br><br></li>
<li>
Remember that an Outlook form is<b><i> not</i></b> a data browsing application.<br><br></li>
<li>
Scalability can dictate which data access solution you employ. An Outlook application that serves 10 users in a small workgroup will mandate a different approach than an application that serves hundreds of simultaneous users.<br><br></li>
<li>
Consider encapsulating business rules into ActiveX components.<br><br></li>
<li>
Remember that all remote object calls in VBScript are late bound and consequently suffer a performance penalty. Wrap your calls into one call and then perform remote object calls in an ActiveX component which can accomplish early binding.<br><br></li>
<li>
If your application requires additional security and maintainability, consider using Microsoft Transaction Server to package your components for distribution through DCOM.</li>
</ol>
<h3>Northwind SQL Order Sample Application</h3>
<h4>Overview</h4>
<p>
The Northwind SQL Order application illustrates the use of ODBCDirect with Outlook forms. An ODBCDirect connection is established with a SQL Server database created by upsizing the Northwind sample database that ships with Access 97. If you did not install the sample databases with Access 97, you must use Setup to install the Northwind sample database. Once you have installed northwind.mdb, you should then download the Access 97 upsizing wizard from the Access Developer's web site:</p>
<p>
<u>http://www.microsoft.com/accessdev/AccInfo/AUT97dat.htm</u></p>
<p>
Use the Upsizing wizard to upsize the Northwind database to SQL Server or any other ODBC Level 2 compliant back-end database.</p>
<p>
The Northwind SQL Order application also demonstrates persistence of data in normalized tables. A MAPI folder allows storage of data in its folder's properties and custom user properties. However, a MAPI folder does not lend itself to normalized storage of data. In the Northwind SQL Order example, a user can create an order with custom properties such as date needed, order id, and order total amount. These fields are stored in the Northwind SQL folder. How can you store data that participates in a one-to-many relationship with the Order ID? In order to create relationships with MAPI folder data, you need to use a database container. If a user creates a Purchase Order and posts that order to the Northwind SQL database, the next time they open the Post item for the order in Outlook, the Northwind SQL Order form 'remembers' the detail items associated with that purchase order's Order ID.</p>
<p>
Remember that the Northwind SQL Order application focuses on showing you how to use ODBCDirect in conjunction with Microsoft Forms in an Outlook custom form. Microsoft Forms consist of a special set of lightweight ActiveX controls that are intrinsic to Office 97 applications. This sample application will show you how to populate the Microsoft Forms combo box and list box from the tables in the Northwind SQL database. What you won’t see here is a demonstration of custom actions that might route the purchase order to a supervisor for approval. For additional examples that will expand your knowledge of custom forms design and programming, see the sample applications available on the Outlook web site at <u>http://www.microsoft.com/outlook</u>.</p>
<p>
Samples that come with Outlook can only be used with Microsoft Outlook. Users of the Microsoft Exchange Client cannot read Microsoft Outlook forms.  For more information on creating forms and public folders, see <i>Building Microsoft Outlook 97 Applications</i>, available from Microsoft Press, and these web sites:</p>
<p>
<u>http://www.microsoft.com/outlook/</u></p>
<p>
<u>http://www.microsoft.com/OfficeDev/outlook/</u></p>
<h4>Before running Northwind SQL Sample Application</h4>
<p>
<b>A. Establish an ODBC DSN for Northwind.</b></p>
<p>
Before you run the Northwind SQL sample application, you must establish a user DSN (Data Source Name) that points to the Nwind database in SQL Server. </p>
<p>
To establish a DSN for Nwind:
<ol>
<li>
Click <b>Start</b> menu.<br><br></li>
<li>
Select Settings | Control Panel option.<br><br></li>
<li>
Double-click the <b>32-bit ODBC </b>icon in the control panel.<br><br></li>
<li>
Click the <b>User DSN </b>tab.<br><br></li>
<li>
Click the <b>Add</b> button.<br><br></li>
<li>
Select <b>SQL Server </b>in the list of drivers.<br><br></li>
<li>
Click the <b>Finish </b>button.<br><br></li>
<li>
In the Data Source Name edit box, type<p>
NwindSQL</p>
</li>
<li>
In the Description edit box, type<p>
Northwind Sample Database</p>
</li>
<li>
Click the <b>Options</b> button and enter<b> Nwind </b>as the Database name in the Login frame. Make sure that the server name drop-down is set correctly for your SQL Server. If you have any questions, consult your database or system administrator before you proceed.<br><br></li>
<li>
Click OK button to accept your addition.</li>
</ol>
<p>
<b>B. Upsize the Access 97 Northwind database.</b>
<ol>
<li>
Use the SQL Enterprise manager to create two database devices for Northwind. Name the first database device Nwind and size this device at 10MB. Name the second device NwindLog and size the device at 2MB.<br><br></li>
<li>
Create a new database named Nwind. Place the Nwind log on the NwindLog device. Select <b>Manage | Databases </b>and double-click Nwind. Click the Options tab and check the <b>Select Into / Bulk Copy </b>option and the <b>Truncate Log on Checkpoint </b>option.<br><br></li>
<li>
Open northwind.mdb.<br><br></li>
<li>
Select <b>Tools | Add-Ins | Upsize to SQL-Server </b>and select <b>Use Existing Database </b>option in the first dialog of &#09;the Upsizing wizard. Click<b> Next </b>button.<br><br></li>
<li>
Double-click <b>NwindSQL</b> in the <b>Select Data Source </b>dialog.<br><br></li>
<li>
Accept defaults in wizard dialogs and click <b>Finish</b> to upsize the database.<br><br></li>
<li>
If you do not have access under the SA Login and blank password, you will have to change the connect string in the Northwind SQL example. The connect string assumes a user account of SA and a blank password. Also if you do not login under SA, you will have to grant permissions on table objects in Nwind.</li>
</ol>
<p>
<b>C. Install VBScript version 2.0 and the Microsoft Script Debugger for Internet Explorer.</b></p>
<p>
The VBScript code in this sample application utilizes functions (such as FormatCurrency) available in <b>VBScript version 2.0</b>. If you have not already upgraded your version of VBScript, connect to <u>http://www.microsoft.com/vbscript</u> in order to download VBScript version 2.0. If you are visiting the VBScript forum, you should download the current version of <b>Microsoft Script Debugger for Internet Explorer</b>. At the time of this writing, the Script Debugger was still a beta product. Script Debugger provides a vastly improved development environment for VBScript code in Outlook forms. The script debugger in combination with VBScript 2.0 allows you to set breakpoints in code, step the code using the familiar F8 key, and examine variables in the debugger's immediate window. </p>
<p>
<b>D. Connect to the Enterprise Data personal folder.</b></p>
<p>
By default, the information store that contains the Northwind SQL Sample Application will be installed to:</p>
<p>
<b>c:\program files\microsoft office\office</b></p>
<p>
Follow these instructions to add the folder to your Outlook folders:</p>
<p>
Select <b>File | Open Special Folder | Personal Folder</b> command and open Enterprise Data.pst. See the default installation directory information above. Click <b>OK</b>.</p>
<h3>Installation Guidelines</h3>
<h4>Where should I install the sample application?</h4>
<p>
If you only want to see how the forms are designed, or if you want to customize the forms that come with the sample application, install the sample for your own private use.</p>
<p>
If you want to make the forms available to your organization, or if you want to test the folders, install them in the organization. If you are testing the folder and forms, it is a good idea to restrict access to the public folders while you test them. You must have owner permissions on the organization forms library to install the forms in an organization. For more information, see your Microsoft Exchangeserver administrator.</p>
<h4>Install the Northwind SQL Order application for your private use.</h4>
<p>
Follow this procedure to register the <b>Northwind SQL Order </b>sample form in the Personal Forms Library for your private use.
<ol>
<li>
On the <b>Tools</b> menu, click <b>Options,</b> and then click the <b>Manage Forms</b> tab.<br><br></li>
<li>
Click <b>Manage Forms </b>button<b>.</b><br><br></li>
<li>
Above the box on the left, click <b>Set.</b><br><br></li>
<li>
Click Folder Forms Library, click the Northwind SQL folder (in Enterprise Data), and then click OK.<br><br></li>
<li>
Above the box on the right, click <b>Set.</b><br><br></li>
<li>
Click <b>Forms Library,</b> click <b>Personal Forms</b> in the box below, and then click <b>OK.</b><br><br></li>
<li>
In the box on the left, click the <b>Northwind SQL Order </b>form.<br><br></li>
<li>
Click <b>Copy.</b><br><br></li>
<li>
Click <b>Close</b>, and then click <b>OK.</b></li>
</ol>
<h4>Install the Northwind SQL Order application in an organization.</h4>
<p>
Follow this procedure to register the <b>Northwind SQL Order</b> sample form in the Organization Forms Library for use by yourself and others. You must have administrator privileges to complete this procedure.
<ol>
<li>
On the <b>Tools</b> menu, click <b>Options,</b> and then click the <b>Manage Forms</b> tab.<br><br></li>
<li>
Click Manage Forms.<br><br></li>
<li>
Above the box on the left, click <b>Set.</b><br><br></li>
<li>
Click Folder Forms Library, click the Northwind SQL folder (in Enterprise Data), and then click OK.<br><br></li>
<li>
Above the box on the right, click <b>Set.</b><br><br></li>
<li>
Click <b>Forms Library,</b> click <b>Organization Forms</b> in the box, and then click <b>OK.</b><br><br></li>
<li>
In the box on the left, click the <b>Northwind SQL Order </b>form.<br><br></li>
<li>
Click <b>Copy.</b><br><br></li>
<li>
Click <b>Close</b>, and then click <b>OK.</b></li>
</ol>
<h3>Using the Northwind SQL Order Form</h3>
<ul>
<li>
To post a Northwind SQL Order message, click <b>Choose Form</b> on the <b>Compose</b> menu, click <b>Personal Forms</b> or <b>Organizational Forms</b> in the box at the top, and then double-click <b>Northwind SQL Order.</b><br><br></li>
<li>
If you select the Northwind SQL folder in the Outlook Folder View, you can select the Compose menu and click the <b>New Northwind SQL Order </b>menu item.<br><br></li>
<li>
When you open a new Northwind SQL Order form, you will see the Select Items tab. You can select items by checking the selection box in the list box of items. You can select multiple and items by holding down the control key while you click the checkbox. If you wish to select items from a different supplier, select a new supplier in the suppliers combo box. You’ll notice that when you select a new supplier, the items list is refreshed with items sold by that supplier.<br><br></li>
<li>
If you want to change the quantity of all selected items, click the Edit Quantity button.<br><br></li>
<li>
In order to add items to your hypothetical purchase order, click the Add Items to Purchase Order button. The items you have selected will be added to the Items list box on the Purchase Order tab. Notice that as you select additional items, extensions and total amount are calculated for the purchase order.<br><br></li>
<li>
If you click the Post Purchase Order button, you will create order and order detail records in the Nwind database. If you reopen the Purchase Order item in the Northwind SQL folder, the form will refill the items list with the detailed order items that pertain to that order number.<br><br></li>
<li>
If you want to remove all the items from a purchase order which has not been submitted, click the Delete All Items button.</li>
</ul>
<h3>Examining the VBScript Code Example</h3>
<p>
To examine the extensive VBScript code that comes with Northwind Order application, post a New Northwind order into the folder. Select the <b>Tools | Design Outlook Form </b>command. Select the <b>Forms | View Code </b>command to view VBScript code. If you wish to examine the code in a different editor than the Outlook Script editor, do the following:
<ol>
<li>
Obtain the Microsoft Internet Explorer Script Debugger and VBScript version 2.0. (See above). <br><br></li>
<li>
Use Compose | New Northwind SQL Order to create a new item.<br><br></li>
<li>
Use <b>Tools | Design Outlook Form</b> to switch to design mode. Open the Outlook Script editor by clicking the toolbar icon.<br><br></li>
<li>
Uncomment the Stop statement at the beginning of the Item_Open VBScript code and then select <b>Script | Run</b> command in the native Outlook Script editor.<br><br></li>
<li>
If you have installed the Microsoft Internet Explorer Script Debugger, you will see your VBScript code in the improved environment of the Script Debugger. You can set breakpoints, examine variables in the immediate window and the call stack in the call window, and step your code. For Visual Basic and Visual Basic for Applications developers, this editor has a superior feature set compared to the Script Editor that ships with Outlook.<br><br></li>
<li>
To single step the code in Northwind SQL sample application, press <b>F8</b> once the Script Debugger editor has entered break mode and is visible.<br><br></li>
<li>
Check the value of variables by selecting the <b>View | Immediate Window</b> command.<br><br></li>
<li>
Check the call stack by selecting the <b>View | Call Stack</b> command.</li>
</ol>
<h3>Features of Northwind SQL Sample Application VBScript code</h3>
<h4>Establishing an ODBCDirect Connection</h4>
<ul>
<li>
This code uses ODBCDirect to establish a connection to an ODBC-compliant database. In this example, the Data Source Name (DSN) points to the Northwind sample database that ships with Access 97. However, you can establish a data source for SQL Server or any other ODBC-compliant RDBMS.  The ODBCDirect method of data access uses a thin wrapper over Remote Data Objects 2.0 (RDO) and does not incur the large memory footprint associated with Jet and DAO.<br><br></li>
<li>
Note that the connection is established through the <u>GetODBCConnection</u> function. This function can be used to connect to any valid DSN. The function takes three required arguments<font face="Symbol"><span style="font-family:symbol">&#190;</span></font>the DSN name, the connection string which can include user name and password information, and the connection option constant which determines whether to prompt the user for additional DSN information.<br><br></li>
<li>
You should be aware that under 32-bit ODBC version 3.0 or above at least three different types of Data Source Names are available. A User DSN is specific to the logged-on user who establishes the DSN. A System DSN can be used by all users on a specific machine. File DSN’s are available as shared or non-shared DSN’s and are typically read from a share point on a network drive. If you are using DSN’s with Outlook and ODBCDirect connections to a database, the type of DSN should be planned carefully for ease of installation and administration. Consult the help that accompanies the ODBC Administrator for additional information on DSN setup and configuration.</li>
</ul>
<h4>Using the CreateObject method</h4>
<ul>
<li>
Outlook’s object model supports the use of the Item.Application.CreateObject(“ProgID”) method. The CreateObject method is used to establish the DAO object. Once the DAO application object has been instanced, you create Workspace, Connection, and Recordset objects. If you have both DAO 3.0 and DAO 3.5 installed on the same machine, you must use the following syntax when you call CreateObject or you will cause a page fault:<pre><FONT FACE="Courier New" SIZE="2">Item.Application.CreateObject(“DAO.dbEngine.35”)
</font></pre>
</li>
<li>
Since you have the CreateObject method at your disposal, you can use VB4 or VB5 to create your own ActiveX automation servers for Outlook. You can also use existing Automation servers to add functionality to Outlook that is not available in Outlook’s native object model. For example, you might want to write a wrapper Automation Server that encapsulates the methods required to send data to a custom Outlook form from a backend database. You can call the properties and methods of your own objects from within Outlook VBScript code.<br><br></li>
<li>
For additional information on Automation servers and object models in general, see “Understanding Object Models” in Chapter 2 of the Office 97 Programmer’s Guide. For an excellent advanced discussion of Automation Servers with several useful examples (including type libraries that enable Windows API calls and File I/O functions), take a careful look at Bruce McKinney’s <i>Hardcore Visual Basic</i> published by Microsoft Press.</li>
</ul>
<h4>Declaring variables and writing code in VBScript</h4>
<ul>
<li>
VBScript has some peculiarities that take a while to get accustomed to for a Visual Basic programmer. Once you learn that VBScript is still solidly related to its Visual Basic parent, you’ll be right at home if you’ve programmed Visual Basic previously. For additional help on VBScript beyond the discussion of VBScript provided with Outlook, download the VBScript documentation available at <u>http://www.microsoft.com/vbscript</u>. This help is in HTML format.<br><br></li>
<li>
Remember that all variables in VBScript are dimensioned as variants. The AS keyword is illegal. Variants can contain the following Visual Basic data types: boolean, byte, currency, date, decimal, double, integer, long, object, single, string, and variant array. To maintain code readability and to guard against type conversion/mismatch errors, I find it useful to use type prefix notation when dimensioning variables and control object variables. For the most part, I’ve followed standard Visual Basic naming conventions when dimensioning variables in the VBScript code for the Northwind sample application.<br><br></li>
<li>
Variables are scoped by position within VBScript. Any variables which precede sub or function are known as <i>script</i> variables. Variables that are contained in sub or function procedures are <i>procedure</i> level variables. <br><br></li>
<li>
Declare constants in VBScript 2.0 with the Const statement. Certain constants such as the MsgBox constants like vbcritical, vbinformation, vbYesNo, etc. are available in the VBScript environment without requiring definition. Other typical VB constants are not available and must be declared. Moreover, the constants for objects created using the CreateObject method are also not available in VBScript. My preference is to declare the constants using their constant names in the Object Library and then assign the variables to their constant values in the script-level declarations. You can examine the script-level declarations of the Northwind SQL application to see how I’ve followed this approach for certain DAO constants. How do you know what the values of the constants are? I use the Object Browser in Excel as a convenient point of reference. Follow these steps to copy constant values from the Object Browser:<br><br></li>
<li>
Start Excel 97.<br><br></li>
<li>
Press <b>Alt+F11</b> to launch the VBA IDE.<br><br></li>
<li>
Use the <b>Tools | References</b> command to set references to the type or object libraries you wish to browse. For ODBCDirect, set a reference to the Microsoft DAO 3.5 object library. Click OK in the References dialog once you have selected all necessary references.<br><br></li>
<li>
Press F2 to invoke the Object Browser window.<br><br></li>
<li>
Navigate to the constant group you wish to browse.<br><br></li>
<li>
When you click the constant name in the list view, you will see the constant and its value at the bottom of the Object Browser. You can copy the equivalence statement and paste it into your VBScript code.<br><br></li>
<li>
You write code in either sub or function procedures. Outlook function procedures differ from sub procedures in that they return a variant value. Again you cannot use the AS keyword to specify the type of value returned from a function. The <u>GetODBCConnection</u> function is a typical function procedure in that it takes arguments and returns True if the connection is successful or False if the connection fails.<br><br></li>
<li>
Outlook also supports event procedures which are documented in several of the documents listed in <u>Additional Sources of Information</u>. Event procedures can be either Function event or Sub event procedures. I’ve used both in the Northwind SQL VBScript code. The important distinction is that Function event procedures can cancel the event whereas Sub event procedures cannot. The <u>Item_Write</u> function procedure below illustrates how the write event can be canceled. If you use the statement Item_Write = False in a Sub event procedure, you will raise an error.</li>
</ul>
<h4>Working with ActiveX controls on an Outlook form</h4>
<ul>
<li>
When you work with ActiveX controls on an Outlook form, you must set a reference to the specific control in order to set properties and call methods. I find it useful dimension all form pages and controls in the script-level declarations section of my Outlook form code. The script-level declarations in VBScript code precede any sub or function procedures. These quasi-global variables are known as <i>script</i> variables rather than <i>procedure</i> variables which are defined within a function or sub procedure. Once these page and their controls have been dimensioned as script-level variables, I create references to all pages and controls on the form in the Item_Open procedure. Since these control variables are global in scope, you can reference the controls on your Outlook form by using the control object variables in any subsequent procedure without a dim and set statement. The exception to this general rule would be if you want to add controls at run time. These controls must be dimensioned and instanced in a procedure rather than in the script-level declarations section.<br><br></li>
<li>
Controls are contained in the controls collection object of each page on the Outlook form MultiPage. See the Microsoft Forms help (FM20.HLP) for a complete description of the Microsoft Forms object model. Instance a Page object as follows:<p>
Set MyPage = Item.GetInspector.ModifiedFormPages(“My Page”)</p>
</li>
<li>
Once you have instanced a given page object, set a reference to the controls collection for that page. You can then reference the individual controls in that collection by instancing a control object for each control in the collection. Examine the sample code in Northwind SQL Sample Application. Here are more generic examples:<p>
Set MyControls = MyPage.Controls</p>
<p>
Set txtName = MyControls.Controls(“txtName”)</p>
</li>
<li>
You’ll notice that I don’t use an alias for the control object. I prefer to name the control object on the left side of the set statement with the same name as the actual control. Consequently, you can refer to form controls and set their properties and methods in your VBScript code with the actual name of the control. This practice makes your code more readable since the name of the control in VBScript code is the same as the control name in design mode.<br><br></li>
<li>
Some of the properties for the ActiveX controls on Northwind SQL sample application can only be set through the advanced properties pop-up window. For example, the cmbSuppliers combo box has a hidden column that contains the SupplierID value. This column is hidden by supplying a zero value for the column width in the ColumnWidths property for the combo box. To see the advanced properties for an Outlook control, select the control in design mode (activate design mode by selecting <b>Tools | Design Outlook Form </b>command) and then use the <b>Form | Advanced Properties </b>command.</li>
</ul>
<h4>Binding ActiveX controls to a MAPI field</h4>
<ul>
<li>
One of the most important aspects of Outlook form design is binding the fields defined for a custom Outlook form to the ActiveX controls that you place on the form.  In fact you can bind controls to fields in other containers besides your custom form. ActiveX controls can be bound to the inherent fields for a given folder, the user-defined fields in a folder, and the user-defined fields which are defined for custom form items. Controls bound to a custom form can be bound to either the user-defined fields for the custom form on which they are placed or user-defined fields on other forms in the folder in which the original custom form is published.<br><br></li>
<li>
The folder in which the custom form is published is known as the <i>active folder</i> for the custom form item. Table 1 illustrates that the source of available fields is dependent upon the base message class of the custom form. The <i>base message class</i> of a custom form is dependent upon the form you used to initially create your custom Outlook form. Since the Northwind SQL Sample application was created as a post item, its base message class is IPM.Post.<br><br></li>
<li>
If you create a Custom form from an Office document item, be aware that you create custom fields using the <b>Custom</b> tab on the document <b>Properties</b> dialog in the native application for the Office document rather than within the Outlook design environment. For example, if you want to create custom fields for a custom Office Document form based upon an Excel document, select the <b>File | Properties</b> command within Excel and click the <b>Custom</b> tab to define new custom properties. Custom properties in an Excel document can be linked to a named range on a sheet. These custom fields can be manipulated programmatically as members of the DocumentProperties Collection Object.<table>
<tr valign=top>
<td>
<b>Base Form Type:</b></td>
<td>
<b>Base Message Class:</b></td>
<td>
<b>Field categories available:</b></td>
<td>
<b>User-defined fields created in:</b></td>
</tr>
<tr valign=top>
<td>
Appointment</td>
<td>
IPM.Appointment</td>
<td>
All</td>
<td>
Active Folder</td>
</tr>
<tr valign=top>
<td>
Contact</td>
<td>
IPM.Contact</td>
<td>
All</td>
<td>
Active Folder</td>
</tr>
<tr valign=top>
<td>
Journal</td>
<td>
IPM.Activity</td>
<td>
All</td>
<td>
Active Folder</td>
</tr>
<tr valign=top>
<td>
Message</td>
<td>
IPM.Note</td>
<td>
Field categories for built-in forms such as All Contact items are not available for Messages.</td>
<td>
Inbox</td>
</tr>
<tr valign=top>
<td>
Office Document</td>
<td>
IPM.Document.[ClassID]<p>
Example:</p>
<p>
IPM.Document.Office.Binder.8</p>
</td>
<td>
Defined within the source Office application by using Custom tab on document Properties dialog.</td>
<td>
Must be created at the folder level rather than the item level.</td>
</tr>
<tr valign=top>
<td>
Post</td>
<td>
IPM.Post</td>
<td>
All</td>
<td>
Active Folder</td>
</tr>
<tr valign=top>
<td>
Task</td>
<td>
IPM.Task</td>
<td>
All</td>
<td>
Active Folder</td>
</tr>
</table><br>
</li>
</ul>
<p>
<b>Table 1 - Field Binding for Outlook custom forms</b>
<ul>
<li>
Bind a control to a MAPI folder field by using either the Field Chooser window or the Value tab of the Properties dialog.  To use the Field Chooser window:<ol>
<li>
In design mode, check the <b>Field Chooser</b> menu item on the <b>Form</b> menu or click the Field Chooser icon on the Outlook form design toolbar.<br><br></li>
<li>
Drag and drop a field name from the Field Chooser window to the active page on your form. Outlook will automatically bind the field to the control that is appropriate to that field. For example, if you drag the Read field to your page then Outlook uses a checkbox to bind the boolean value of the read field.<br><br></li>
<li>
If you need to add new fields, click the <b>New</b> button on the Field Chooser window.</li>
</ol>
</li>
<li>
The Value tab provides greater control over the binding of the field to your control, but you can access the value tab after you use the Field Chooser method simply by right-clicking the ActiveX control and selecting the <b>Properties</b> command on the shortcut menu. Use the Value tab as follows:<ol>
<li>
Select the control you want to bind on the active page. Click the <b>Properties</b> icon on the Outlook form design toolbar.<br><br></li>
<li>
Click the Value tab on the Properties dialog and click the <b>Choose Field</b> button. A drop-down menu appears that allows you to select fields from a variety of sources. Click <b>New</b> if you need to add a field.<br><br></li>
<li>
Check the <b>Initial</b> checkbox if you want to set the field to an initial value. You can either type a constant value or compute an initial value. The DateNeeded field is set to 5 days from today’s date using the DateAdd function. You can invoke a larger edit box by clicking the <b>Edit</b> button. The Functions available are extensive and include the ability to perform conditional evaluation using the IIF construct.</li>
</ol>
</li>
</ul>
<h4>Populating Outlook ActiveX controls with data from an ODBC data source</h4>
<ul>
<li>
If you want to bind controls on an Outlook form to an ODBCDirect data source, you must bind the control to the data field through code. The Northwind SQL application illustrates the binding through code approach.<br><br></li>
<li>
At present there is no ActiveX control that can be placed on an Outlook form to serve as the equivalent of the Visual Basic Data Control to which other controls on the form can be bound.  However, such a control hopefully will be forthcoming either through Microsoft or third-party vendors. ActiveX controls with a DataSource and a DataField property could then be bound to an Outlook custom forms data control.<br><br></li>
<li>
Notice the use of the List method to populate ListBoxes and ComboBoxes in the example code. The recordset obtained from the database is read into a variant array and then the List method assigns the contents of the array to the control. Since MSForms controls cannot currently be data bound within the context of Outlook, the List or Column methods are the only effective way to bind the controls to data obtained in a recordset. The GetRows method (available in both ODBCDirect and ADO) provides a very fast means of populating a variant array. You can then assign the Column property of either the MSForms ListBox or ComboBox to the variant array. Data binding occurs with less than six statements. The cmbShippers control is filled using the GetRows method. However, since other queries return unformatted data, I elected to use VBScript 2.0’s FormatCurrency function to format the data in the variant arrays which populate the lstItems and lstPO controls.<br><br></li>
<li>
VBScript does not allow use of the bang (!) operator to reference items in the fields collection of a recordset object. Consequently, use RS(0) or RS.Fields(“My Field”) notation to access the fields of a recordset.<br><br></li>
<li>
The AddItem method does not work appropriately for multi-column combo and list boxes. Items separated by the tab delimited character do not always align correctly in the control. If you want to add multiple columns to list or combo boxes, I strongly recommend using the List or Column methods instead of the AddItem method to populate the controls. Since the List or Column methods require variant arrays and the GetRows method of the ODBCDirect recordset object supplies a variant array, these methods were made for each other and provide good performance.<br><br></li>
<li>
MSForms controls do not consistently respond to their intrinsic events within the Outlook container. For example, a MSForms ComboBox control has an intrinsic Change event. When you add a cmbSuppliers_Change procedure to VBScript for Northwind SQL, you’ll find that this event does not fire when you change the selected item in the control as it does if the control is operating on an Excel UserForm. If you want a control event to generate a change in other controls, bind the control to a MAPI user-defined field and use the CustomPropertyChange event of the Outlook Item itself. This approach is illustrated in the <u>Item_CustomPropertyChange</u> procedure in Northwind. CmbSuppliers is bound to the user-defined item field named Supplier. The rows in the drop-down are supplied from the Suppliers table in Northwind. When the user selects a different supplier in the drop-down portion of the combo, the lstItems control is refreshed with items that are sold by the selected supplier. This type of functionality can be extended to many different scenarios.</li>
</ul>
<h4>Using the Column property of ListBox and ComboBox controls</h4>
<ul>
<li>
When you retrieve a value from a row in a ComboBox or ListBox control, use the Column property to determine the value for a given column in the given row. If you are trying to inspect selected rows in a multiselect ListBox, you must first test the object.Selected( <i>row </i>) property to determine if the row is selected. The syntax of the Column property is as follows:</li>
</ul>
<p>
Variant = object.Column( <i>column, row </i>) 
<ul>
<li>
In the <u>cmdAdd</u> procedure, the ability to add additional rows to the lstPO list box is dependent upon the Column property. In this code example, selected items are read from the lstItems control. The existing elements in MyArrayPO (which serves as the source array for lstPO) are copied into a temporary array named TempArrayPO. TempArrayPO has been redimensioned so that it can contain all elements in lstPO plus the number of selected rows in lstItems.  Finally the selected items are read into TempArrayPO, MyArrayPO is assigned to TempArrayPO, and the List method is used to populate lstPO with the variant array MyArrayPO. Step the code if you are curious about exactly how this strategy works.<br><br></li>
<li>
To hide columns in listbox and combobox controls, use the Advanced Properties window to set the ColumnWidths property. Hidden column widths come in handy when you want to hide certain column values from the user. In the cmbSuppliers combo box, the SupplierID field is contained in a hidden column. When a user selects a column in the drop-down list, use the Column property to read the value in the hidden column. This value is then used to construct a dynamic SQL statement that refreshes the lstItems list box with items that are sold by the selected supplier.</li>
</ul>
<h4>In-Line Error Trapping and Transaction Wrappers</h4>
<ul>
<li>
VBScript does not support the On Error Go To Label construct. If you want to trap errors, you must use in-line error trapping. The VBScript Err object does provide access to the error number, description, and other properties. Place an On Error Resume Next statement at the beginning of your Sub or Function procedure and then test the Err.Number value to determine if an error has occurred at critical points in your code.<br><br></li>
<li>
The Northwind SQL application uses dynamic SQL to insert records into the Orders and Order_Details tables. Any application that operates against a backend database over network connections must be prepared for network and database server errors. Consequently, it is imperative to provide transaction wrapping for operations that require data integrity. For example, if the insert into orders table fails, the insert into order_details also must fail in order to preserve data integrity and prevent orphaned records. See the <u>cmd_PostPO</u> subroutine for an example of transactions within VBScript. Use the BeginTrans method to begin the transaction. If no error occurs, then use CommitTrans to commit changes to the database. If an error occurs, use Rollback to rollback changes. Since you can’t use On Error GoTo Label traps, I’ve set the procedure level variable to False when the cmdPost procedure begins. If any SQL execute errors occur during the procedure, intFail is set to True and all database tranasctions are rolled back at the end of the procedure.<br><br></li>
<li>
In most C/S environments, you should actually call stored procedures to perform inserts, update, and deletes against database tables. The typical permissions structure prohibits users from changing tables directly. They should have execute permissions on stored procedures and perhaps Select permissions against Tables and Views. You can also design your Outlook applications so that they use stored procedures in this manner. For the highest level of security and data integrity, create methods in VB5 ActiveX components that execute stored procedures and utilize the full level of RDO or ADO functionality within the component environment.</li>
</ul>
<h3>VBScript Code</h3>
<pre><FONT FACE="Courier New" SIZE="2">'******************************************************************************
'*                           Northwind SQL Sample Application
'* Purpose: &#09;Demonstrates use of ODBCDirect in Outlook Forms
'* &#09;&#09;&#09;using VBScript and ActiveX controls.
'* Author:  &#09;Randy Byrne, MCSD Charter Member, MVP Outlook 97
'*          &#09;Micro Eye, Microsoft Solution Provider
'*&#09;&#09;&#09;E-mail: randy_byrne@msn.com or microeye@ncal.net
'* Comments:&#09;If you want to step execution in this code,
'*&#09;&#09;&#09;remove the comment from the stop statement below.
'*&#09;&#09;&#09;This code uses functions only available in VBScript 2.0.
'*&#09;&#09;&#09;You must install VBScript 2.0 to run this script.
'*&#09;&#09;&#09;You must be using Internet Explorer Script Debugger 1.0
'*&#09;&#09;&#09;and VBScript 2.0 in order to step code (Press F8).
'*&#09;&#09;&#09;Both are available on http://www.microsoft.com/vbscript
'*&#09;&#09;&#09;Extensive VBScript documentation is also available.
'******************************************************************************
'Force explicit variable declaration
Option Explicit
'Remove comment from stop only if you want to step execution of code
'Stop
'Script level declarations
'Remember that in VBScript the AS keyword and typed variables
'are not allowed. All variables are typed as variant by default.
Dim dbe 
Dim wrkODBC
Dim conDB 
Dim Rs
Dim gstrAppName
Dim IsLoading
Dim MyArray
Dim MyArrayShip
Dim MyArrayPO
'Dim page objects and controls collections
Dim objPage
Dim objControls
Dim objPagePO
Dim objControlsPO
'Dim all controls on the form
Dim cmbSuppliers
Dim cmbShippers
Dim lstItems
Dim lstPO
Dim cmdAdd
Dim cmdEditQty
Dim cmdPostPO
Dim cmdDeleteAll
Dim txtOrderID
Dim txtTotal
Dim txtDateNeeded
'Application Name
gstrAppName = &quot;Northwind SQL Sample Application&quot;
'******************************************************************************
'DAO Constants
'Remember that DAO constants must be declared with Const statement.
'The Const statement is only available in VBScript 2.0 or above.
'They cannot be called directly as you would in VB or VBA.
'******************************************************************************
'WorkspaceTypeEnum
Const dbUseODBC=1
'DriverPromptEnum
Const dbDriverComplete = 0
Const dbDriverNoPrompt = 1
Const dbDriverPrompt = 2
Const dbDriverCompleteRequired = 3
'RecordsetTypeEnum
Const dbOpenTable = 1
Const dbOpenDynaset = 2
Const dbOpenSnapshot = 4
Const dbOpenForwardOnly = 8
Const dbOpenDynamic = 16
'RecordsetOptionEnum
Const dbAppendOnly = 8
Const dbConsistent = 32
Const dbDenyRead = 2
Const dbDenyWrite = 1
Const dbExecDirect = 2048
Const dbFailOnError = 128
Const dbForwardOnly = 256
Const dbInconsistent = 16
Const dbReadOnly = 4
Const dbRunAsync = 1024
Const dbSeeChanges = 512
Const dbSQLPassThrough = 64
'******************************************************************************
'Message Box Constants
'Message Box constants do not have to be declared as constants
'They are built into VBScript 2.0
'******************************************************************************
&#09;
'******************************************************************************
'* Procedure:  &#09;Item_Open()
'* Description: &#09;Upon open, create an ODBCDirect connection to Northwind DSN
'*&#09;&#09;&#09;If an order number exists in the MAPI Folder, then supply
'*&#09;&#09;&#09;order details to lstPO and give focus to Purchase Order tab.
'*&#09;&#09;&#09;If order number is zero, we have a new order and give the
'*&#09;&#09;&#09;focus to Select Items tab.&#09;&#09;
'******************************************************************************
Sub Item_Open()
'Dim procedure variables.
Dim curExtension
Dim lngOrderID
Dim i
Dim strSQL
'Error trapping-remove this statement if you are debugging
'On Error Resume Next
'Set this variable to True to indicate loading state
IsLoading = True
'Set references to pages and controls so that their properties can be set
'Note that controls are set in the Open procedure. You do not have
'to set these controls again in subsequent procedures since their
'variable names have been dimensioned globally.
'Must unhide in case it's hidden otherwise can't set controls
Item.GetInspector.ShowFormPage (&quot;Select Items&quot;)
Set objPage = Item.GetInspector.ModifiedFormPages(&quot;Select Items&quot;)
Set objControls = objPage.Controls
Set cmbSuppliers = objControls(&quot;cmbSuppliers&quot;)
Set lstItems = objControls(&quot;lstItems&quot;)
Set cmdAdd = objControls(&quot;cmdAdd&quot;)
Set cmdEditQty = objControls(&quot;cmdEditQty&quot;)
Set objPagePO = Item.GetInspector.ModifiedFormPages(&quot;Purchase Order&quot;)
Set objControlsPO = objPagePO.Controls
Set cmbShippers = objControlsPO(&quot;cmbShippers&quot;)
Set lstPO = objControlsPO(&quot;lstPO&quot;)
Set txtOrderID = objControlsPO(&quot;txtOrderID&quot;)
Set cmdPostPO = objControlsPO(&quot;cmdPostPO&quot;)
Set cmdDeleteAll = objControlsPO(&quot;cmdDeleteAll&quot;)
Set txtTotal = objControlsPO(&quot;txtTotal&quot;)
Set txtDateNeeded = objControlsPO(&quot;txtDateNeeded&quot;)
'Use the GetODBCConnection function to establish an ODBC Connection
If Not (GetODBCConnection(&quot;NWindSQL&quot;,&quot;ODBC;DSN=NwindSQL;UID=sa;PWD=&quot;, _
&#09;dbDriverCompleteRequired)) Then
&#09;Exit Sub
End If
'Hide the message page
Item.GetInspector.HideFormPage (&quot;Message&quot;)
'If the order number exists (&lt;&gt;0), then fill lstPO (persistent data on form)
'Otherwise, we have a new order and give Select Items tab the focus
lngOrderID = Item.UserProperties(&quot;Order Number&quot;)
If lngOrderID = 0 Then
&#09;'New order
&#09;Item.GetInspector.ShowFormPage (&quot;Select Items&quot;)
&#09;Item.GetInspector.SetCurrentFormPage (&quot;Select Items&quot;)
&#09;txtTotal.Text = FormatCurrency(0)
&#09;lstPO.Clear
&#09;cmdPostPO.Enabled = True
&#09;cmdDeleteAll.Enabled = True
&#09;cmdAdd.Enabled = True
Else
&#09;'Existing Order
&#09;Item.GetInspector.HideFormPage (&quot;Select Items&quot;)
&#09;Item.GetInspector.SetCurrentFormPage (&quot;Purchase Order&quot;)
&#09;lstPO.Clear
&#09;'Retrieve persistent data from Database
&#09;strSQL = &quot;SELECT Order_Details.ProductID, Products.ProductName,&quot;
 &#09;strSQL = strSQL &amp; &quot;Order_Details.Quantity, Products.QuantityPerUnit,&quot;
&#09;strSQL = strSQL &amp; &quot;Order_Details.UnitPrice FROM Products&quot;
&#09;strSQL = strSQL &amp; &quot; INNER JOIN Order_Details ON&quot;
&#09;strSQL = strSQL &amp; &quot; Products.ProductID = Order_Details.ProductID&quot;
&#09;strSQL = strSQL &amp; &quot; Where Order_Details.OrderID = &quot; &amp; lngOrderID
&#09;Set RS = conDB.OpenRecordset(strSQL, dbOpenSnapshot)
&#09;If RS.RecordCount Then
&#09;&#09;i = 0
&#09;&#09;Redim MyArrayPO(RS.RecordCount - 1, 5)
&#09;&#09;Do Until RS.EOF
&#09;&#09;&#09;MyArrayPO(i, 0) = RS(0)
&#09;&#09;&#09;MyArrayPO(i, 1) = RS(1)
&#09;&#09;&#09;MyArrayPO(i, 2) = RS(2)
&#09;&#09;&#09;MyArrayPO(i, 3) = RS(3)
&#09;&#09;&#09;MyArrayPO(i, 4) = FormatCurrency(RS(4), 2)
&#09;&#09;&#09;curExtension = RS(2)* RS(4)
&#09;&#09;&#09;MyArrayPO(i, 5) = FormatCurrency(curExtension, 2)
&#09;&#09;&#09;i = i + 1
&#09;&#09;&#09;RS.MoveNext
&#09;&#09;Loop
&#09;&#09;lstPO.List = MyArrayPO
&#09;End IF
&#09;cmdPostPO.Enabled = False
&#09;cmdDeleteAll.Enabled = False
&#09;cmdAdd.Enabled = False
End If
'Create a recordset to fill an array
'Caution: VBScript does not support the use of bang (!) operator
'to reference fields within recordset such as RS!CompanyName
strSQL = &quot;Select CompanyName, Phone, SupplierId &quot;
strSQL = strSQL &amp; &quot;from Suppliers ORDER BY CompanyName&quot;
Set RS = conDB.OpenRecordset(strSQL, dbOpenSnapshot)
If RS.RecordCount Then
    i = 0
    ReDim MyArray(RS.RecordCount-1, RS.Fields.Count)
    Do Until RS.EOF
&#09;  MyArray(i, 0) = RS(0)
&#09;  MyArray(i, 1) = RS(1)
&#09;  MyArray(i, 2) = RS(2)
&#09;  i = i + 1&#09;
       RS.MoveNext
    Loop
    RS.Close
    'Use the List method to populate the cmbSuppliers drop-down
    cmbSuppliers.List = MyArray
    cmbSuppliers.ListIndex = 0
End If
strSQL = &quot;Select companyname, phone, shipperID &quot;
strSQL = strSQL + &quot;from shippers order by companyname&quot;
Set RS = conDB.OpenRecordset(strSQL, dbOpenSnapshot)
If RS.RecordCount Then
    ReDim MyArrayShip(RS.RecordCount, RS.Fields.Count)
    MyArrayShip = RS.GetRows(RS.RecordCount)
    RS.Close
    'Use the Column method to populate the cmbShippers drop-down
    cmbShippers.Column = MyArrayShip
End If
'Create dynamic SQL for items recordset
strSQL = &quot;SELECT ProductName, QuantityperUnit, UnitPrice, ProductID&quot;
strSQL = strSQL &amp; &quot; FROM products&quot;
strSQL = strSQL &amp; &quot; WHERE Discontinued = 0 and SupplierID = &quot;
strSQL = strSQL &amp; cmbSuppliers.Column(2)
strSQL = strSQL &amp; &quot; ORDER BY ProductName&quot;
Set RS = conDB.OpenRecordset(strSQL, dbOpenSnapshot)
If RS.RecordCount Then
   &#09;ReDim MyArray(RS.RecordCount - 1, 4)
&#09;i = 0
    &#09;lstItems.Clear
    &#09;Do Until RS.EOF
        &#09;'Populate lstItems
&#09;  &#09;MyArray(i, 0) = RS(0)
&#09;&#09;MyArray(i, 1) = 1
&#09;&#09;MyArray(i, 2) = RS(1)
&#09;&#09;MyArray(i, 3) = FormatCurrency(RS(2), 2)
&#09;&#09;MyArray(i, 4) = RS(3)
&#09;&#09;lstItems.List = MyArray
&#09;&#09;i = i + 1
        &#09;RS.MoveNext
    &#09;Loop
      RS.Close    
End If
'Now the cmbSuppliers control can respond to a change event
Isloading = False
End Sub
'******************************************************************************
'* Procedure:  &#09;Item_Write()
'* Description: &#09;Note: This procedure only works if it is defined
'*&#09;&#09;&#09;as a function rather than a sub procedure.
'*&#09;&#09;&#09;Illustrates the use of Outlook events to enforce
'*&#09;&#09;&#09;business rules.
'******************************************************************************
Function Item_Write()
On Error Resume Next
Dim lngOrderID
'Access Order Number through the UserProperties collection
lngOrderID = Item.UserProperties(&quot;Order Number&quot;)
If lngOrderID = 0 and lstPO.ListCount &gt; 0 Then
&#09;If MsgBox(&quot;You are posting an open order to the Northwind folder.&quot; _
&#09;&amp; Chr(13) &amp; &quot;Use the Post Purchase Order command&quot; &amp; Chr(13) _
&#09;&amp; &quot;to post to the database and folder.&quot; &amp; Chr(13) _
&#09;&amp; &quot;Continue to post open order?&quot;, _
&#09;vbQuestion + vbYesNo , gstrAppName) = vbYes Then
&#09;&#09;Item_Write = True
&#09;Else
&#09;&#09;Item_Write = False
&#09;End If
End If
End Function
'******************************************************************************
'* Procedure:  &#09;Item_Close()
'* Description: &#09;Housekeeping function to close ODBC connection.
'******************************************************************************
Function Item_Close()
On Error Resume Next
conDB.Close
wrkODBC.Close
End Function
'******************************************************************************
'* Procedure:  &#09;Item_CustomPropertyChange(ByVal MyPropName)
'* Description: &#09;You use a custom property change event to respond to a change
'*&#09;&#09;&#09;in supplier in drop-down. You can't use the control's 
'*&#09;&#09;&#09;intrinsic events. These events currently do not fire
'*&#09;&#09;&#09;in the VBScript of an Outlook form.
'******************************************************************************
Sub Item_CustomPropertyChange(ByVal MyPropName)
Dim strSQL
Dim i
Select Case MyPropName
Case &quot;Supplier&quot;
&#09;If Not(IsLoading) Then
    &#09;lstItems.Clear
    &#09;strSQL = &quot;SELECT ProductName, QuantityperUnit, UnitPrice, ProductID&quot;
&#09;strSQL = strSQL &amp; &quot; FROM products&quot;
&#09;strSQL = strSQL &amp; &quot; WHERE Discontinued = 0 and SupplierID = &quot;
&#09;strSQL = strSQL &amp; cmbSuppliers.Column(2)
&#09;strSQL = strSQL &amp; &quot; ORDER BY ProductName;&quot;
&#09;Set RS = conDB.OpenRecordset(strSQL, dbOpenSnapshot)
    &#09;If RS.RecordCount Then
&#09;&#09;ReDim MyArray(RS.RecordCount - 1, 4)
&#09;&#09;i = 0
    &#09;&#09;lstItems.Clear
       &#09;Do Until RS.EOF
        &#09;&#09;'Populate lstItems
&#09;  &#09;&#09;MyArray(i, 0) = RS(0) 'Produce Name Column 0
&#09;&#09;&#09;MyArray(i, 1) = 1     'Initial Qty  Column 1
&#09;&#09;&#09;MyArray(i, 2) = RS(1) 'Unit per Qty Column 2
&#09;&#09;&#09;MyArray(i, 3) = FormatCurrency(RS(2), 2) 'Unit Price Column 3
&#09;&#09;&#09;MyArray(i, 4) = RS(3) 'Item ID Column 4
&#09;&#09;&#09;lstItems.List = MyArray
&#09;&#09;&#09;i = i + 1
        &#09;&#09;RS.MoveNext
    &#09;  &#09;Loop
    &#09;  &#09;RS.Close
    &#09;End If
&#09;End If
End Select
End Sub
'******************************************************************************
'* Procedure:  &#09;cmdAdd_Click()
'* Description: &#09;This procedure adds selected items from lstItems
'*&#09;&#09;&#09;to the lstPO. Copies the existing elements of MyArrayPO
'*&#09;&#09;&#09;into TempArrayPO and adds selected items in lstItems
'*&#09;&#09;&#09;to TempArrayPO. Finally uses the List method to 
'*&#09;&#09;&#09;repopulate lstPO with old and new selected items.
'******************************************************************************
Sub cmdAdd_Click()
Dim i
Dim j
Dim intUbound
Dim curTotal
Dim curExtension
Dim intSelected
Dim TempArrayPO 
curTotal = CCur(txtTotal.Text)
intSelected = 0
'Determine the count of select items in lstItems
For i = 0 To lstItems.ListCount - 1
&#09;If lstItems.Selected(i) Then
&#09;&#09;intSelected = intSelected + 1
&#09;End if
Next
'Bail out if none are selected
If intSelected = 0 Then
&#09;MsgBox &quot;You must select items in the list.&quot;, vbInformation, gstrAppName
&#09;Exit Sub
End If
'If lstPO contains items then copy MyArray into TempArrayPO
If lstPO.ListCount Then
&#09;intUbound = lstPO.ListCount + (intSelected - 1)
&#09;Redim TempArrayPO(intUbound, 5)
&#09;For i = 0 to Ubound(MyArrayPO, 1)
&#09;&#09;For j = 0 to Ubound(MyArrayPO, 2)
&#09;&#09;&#09;TempArrayPO(i, j) = MyArrayPO(i, j)
&#09;&#09;Next
&#09;Next
&#09;j = lstPO.ListCount
&#09;For i = 0 to lstItems.ListCount -1
&#09;&#09;If lstItems.Selected(i) Then
&#09;&#09;&#09;TempArrayPO(j, 0) = lstItems.Column(4, i)
&#09;&#09;&#09;TempArrayPO(j, 1) = lstItems.Column(0, i)
&#09;&#09;&#09;TempArrayPO(j, 2) = lstItems.Column(1, i)
&#09;&#09;&#09;TempArrayPO(j, 3) = lstItems.Column(2, i)
&#09;&#09;&#09;TempArrayPO(j, 4) = lstItems.Column(3, i)
&#09;&#09;&#09;curExtension = lstItems.Column(1, i) * lstItems.Column(3, i)
&#09;&#09;&#09;TempArrayPO(j, 5) = FormatCurrency(curExtension, 2)
&#09;&#09;&#09;curTotal = curTotal + curExtension
&#09;&#09;&#09;j = j + 1
&#09;&#09;End If
&#09;Next
&#09;Redim MyArrayPO(intUbound, 5)
&#09;MyArrayPO = TempArrayPO
&#09;lstPO.List = MyArrayPO
Else
&#09;Redim MyArrayPO(intSelected - 1, 5)
&#09;j = 0
&#09;For i = 0 to lstItems.ListCount -1
&#09;&#09;If lstItems.Selected(i) Then
&#09;&#09;&#09;MyArrayPO(j, 0) = lstItems.Column(4, i)
&#09;&#09;&#09;MyArrayPO(j, 1) = lstItems.Column(0, i)
&#09;&#09;&#09;MyArrayPO(j, 2) = lstItems.Column(1, i)
&#09;&#09;&#09;MyArrayPO(j, 3) = lstItems.Column(2, i)
&#09;&#09;&#09;MyArrayPO(j, 4) = lstItems.Column(3, i)
&#09;&#09;&#09;curExtension = lstItems.Column(1, i) * lstItems.Column(3, i)
&#09;&#09;&#09;MyArrayPO(j, 5) = FormatCurrency(curExtension, 2)
&#09;&#09;&#09;curTotal = curTotal + curExtension
&#09;&#09;&#09;j = j + 1
&#09;&#09;End If
&#09;Next
&#09;lstPO.List = MyArrayPO
End If
'Set total in txtTotal
txtTotal.Text = FormatCurrency(curTotal)&#09;
End Sub
'******************************************************************************
'* Procedure:  &#09;cmdDeleteAll_Click()
'* Description: &#09;Enables deletion of all items in lstPO using clear method.
'******************************************************************************
Sub cmdDeleteAll_Click()
'Use the clear method to remove all items from list box
lstPO.Clear
'Reset total to zero
txtTotal.Text = FormatCurrency(0, 2)
End Sub
'******************************************************************************
'* Procedure:  &#09;cmdAbout_Click()
'* Description: &#09;Show About Message Box.
'******************************************************************************
Sub cmdAbout_Click()
MsgBox &quot;Northwind SQL Sample Application code by:&quot; &amp; chr(13) _
&amp; &quot;Randy Byrne, MCSD, Micro Eye&quot; &amp; chr(13) &amp; &quot;E-mail: randy_byrne@msn.com&quot; _
&amp; chr(13) &amp; chr(13) &amp; &quot;Uses Northwind SQL Sample Database&quot; _
&amp; chr(13) &amp; &quot;to demonstrate ODBCDirect in Outlook Forms.&quot; _
&amp; chr(13) &amp; &quot;You must upsize Northwind database and&quot; _
&amp; chr(13) &amp; &quot;establish NwindSQL DSN before you open this form.&quot;, _
vbInformation, &quot;About Northwind SQL Sample Application&quot;
End Sub
'******************************************************************************
'* Procedure:  &#09;cmdPostPO_Click()
'* Description: &#09;Uses insert into to insert PO items into Northwind.
'******************************************************************************
Sub cmdPostPO_Click()
Dim i
Dim strSQL
Dim lngOrderID
Dim intFail 
'Use in-line error trapping
On Error Resume Next
IntFail = 0
If lstPO.ListCount = 0 Then
&#09;MsgBox &quot;Add items to Purchase Order before posting!&quot;, _
&#09;vbExclamation, gstrAppName
&#09;Exit Sub
End If
'Begin transaction wrapper
'Note-This transaction would ideally be wrapped in an ActiveX Automation server
wrkODBC.BeginTrans
'Insert into orders table
strSQL = &quot;Insert Into Orders (CustomerID,EmployeeID,ShipVia,OrderDate,RequiredDate)&quot; _
&amp; &quot; Values ('WHITC',1,&quot; &amp; cmbShippers.Column(2) &amp; &quot;,'&quot; &amp; Now() _
&amp; &quot;','&quot; &amp; txtDateNeeded.Text &amp; &quot;')&quot;
conDB.Execute strSQL
If Err &lt;&gt; 0 Then
&#09;MsgBox Err.Description , vbCritical, gstrAppName
&#09;intFail = True
&#09;Err.Clear
End If
'Returns OrderId of order just added
strSQL = &quot;Select Max(OrderID) from Orders&quot;
Set RS = conDB.OpenRecordset(strSQL)
lngOrderID = RS(0)
'Insert line items in lstPO into order detail table
For i = 0 To lstPO.ListCount - 1
&#09;strSQL = &quot;Insert Into Order_Details (OrderID, ProductID, UnitPrice,&quot;
&#09;strSQL = strSQL &amp; &quot; Quantity, Discount) Values (&quot; &amp; lngOrderID
&#09;strSQL = strSQL &amp; &quot;,&quot; &amp; lstPO.Column(0, i)
&#09;strSQL = strSQL &amp; &quot;,&quot; &amp; cDbl(lstPO.Column(4, i))
&#09;strSQL = strSQL &amp; &quot;,&quot; &amp; cDbl(lstPO.Column(2, i))
&#09;strSQL = strSQL &amp; &quot;,0)&quot;
&#09;conDB.Execute strSQL
&#09;If Err &lt;&gt; 0 Then
&#09;&#09;MsgBox Err.Description , vbCritical, gstrAppName
&#09;&#09;intFail = True
&#09;&#09;Err.Clear
&#09;End If
Next
'Commit the transaction if no error occurred
If Not (intFail) Then
&#09;wrkODBC.CommitTrans
&#09;txtOrderID.Text = lngOrderID
&#09;cmdPostPO.Enabled = False
&#09;cmdDeleteAll.Enabled = False
&#09;cmdAdd.Enabled = False
&#09;Item.GetInspector.HideFormPage (&quot;Select Items&quot;)
&#09;Item.Subject = &quot;Northwind Order &quot; &amp; lngOrderID
&#09;'Save the form item.
&#09;Item.Save
Else
&#09;MsgBox &quot;Could not post the order!&quot;, vbCritical, gstrAppName
&#09;wrkODBC.Rollback
End If
End Sub
'******************************************************************************
'* Procedure:  &#09;cmdEditQty_Click()
'* Description: &#09;Since the grid cannot be edited directly, this allows
'*&#09;&#09;&#09;the user to change the quantity for a selected items.
'******************************************************************************
Sub cmdEditQty_Click()
Dim i
Dim intQty
intQty=InputBox (&quot;Enter Quantity&quot;, gstrAppName)
If Cint(intQty)&gt; 0 Then
&#09;For i = 0 to lstItems.ListCount - 1
&#09;&#09;If lstItems.Selected(i) Then
&#09;&#09;&#09;lstItems.Column(1, i) = intQty
&#09;&#09;End If
&#09;Next
End If
End Sub
'******************************************************************************
'* Procedure:  &#09;GetODBCConnection (ByVal MyDSN, ByVal MyConn, ByVal MyPrompt)
'* Description: &#09;This procedure establishes an ODBCDirect connection object
'*&#09;&#09;&#09;which can be used to open recordsets and execute SQL code.
'* Arguments:&#09;MyDSN = A valid User DSN.
'*&#09;&#09;&#09;MyConn = A valid ODBC connect property string.
'*&#09;&#09;&#09;Example: &quot;ODBC;DSN=Nwind&quot; or &quot;ODBC;DSN=Pubs&quot;&#09;&#09;&#09;
'*&#09;&#09;&#09;MyPrompt = A valid option value specifying ODBC driver
'*&#09;&#09;&#09;prompt options.
'*&#09;&#09;&#09;Note: The options argument determines if and when to prompt
'*&#09;&#09;&#09;the user to establish the connection.
'* Returns:&#09;&#09;TRUE if successful; FALSE if connection fails.
'******************************************************************************
Function GetODBCConnection (ByVal MyDSN, ByVal MyConn, ByVal MyPrompt)
Dim strUser
Dim strPass
'Turn on error trappping
On Error Resume Next
'Set to defaults-change these values if required
strUser = &quot;admin&quot;
strPass = &quot;&quot;
'Create a DAO object. You must use DAO.dbEngine.35 or you will cause
'a page fault on machines with both DAO 3 and DAO 3.5 installed.
Set dbe = Item.Application.CreateObject(&quot;DAO.dbEngine.35&quot;)
If Err.Number &lt;&gt; 0 Then
    &#09;Msgbox &quot;Error#: &quot; &amp; err.number &amp; chr(13) &amp; err.description &amp; chr(13) _
 &#09;&amp; &quot;Warning -- Could not create DAO 3.5 Object!&quot; &amp; Chr(13) _
&#09;&amp; &quot;Please make sure that DAO 3.5 is installed on this machine!&quot;, _
&#09;vbCritical, gstrAppName
&#09;GetODBCConnection = False
    &#09;Exit Function
End If
'Create an ODBCDirect Workspace
Set wrkODBC = dbe.CreateWorkspace(&quot;ODBCWorkspace&quot;, strUser , strPass , dbUseODBC)
If Err.Number &lt;&gt; 0 Then
    &#09;Msgbox &quot;Error#: &quot; &amp; err.number &amp; chr(13) &amp; err.description &amp; chr(13) _
&#09;&amp; &quot;Warning -- Could not create ODBC workspace!&quot; &amp; chr(13) _
&#09;&amp; &quot;Please make sure that user name and password are correct.&quot;, _
&#09;vbCritical, gstrAppName
&#09;GetODBCConnection = False
    &#09;Exit Function
End If
dbe.Workspaces.Append wrkODBC
'Establish the connection to DSN
Set conDB = wrkODBC.OpenConnection(&quot;Connection1&quot;, MyPrompt, , MyConn)
If Err.Number &lt;&gt; 0 Then
    &#09;Msgbox &quot;Error#: &quot; &amp; err.number &amp; chr(13) &amp; err.description &amp; chr(13) _
&#09;&amp; &quot;Warning -- Could not create connection to &quot; &amp; MyDSN &amp; &quot;!&quot; &amp; chr(13) _
&#09;&amp; &quot;Please make sure that &quot; &amp; MyDSN &amp; &quot; is a valid DSN!&quot;, _
&#09;vbCritical, gstrAppName
&#09;GetODBCConnection = False
    &#09;Exit Function
End If
GetODBCConnection = True
End Function
</font></pre>
<h3>Visual Basic 5.0 Code for Outlook List Server</h3>
<p>
The following code is for ListServerRDO.vbp is contained in one module and one class. You must use Tools | References to set a reference to Microsoft Remote Data Objects 2.0. This listing contains the complete code for ListServerRDO:</p>
<pre><FONT FACE="Courier New" SIZE="2">'******************************************************************************
'Name: basListServer
'Purpose: Module level code for ListServerRDO
'Created By: Randy Byrne, randy_byrne@msn.com
'Date: 3/20/97
'Arguments: None
'Returns: None
'*******************************************************************************
Option Explicit
Public lngInstanceCount As Integer
Public intColumnCount As Integer
Public strConnect As String
Public blnConnected As Boolean
Public MyEnv As rdoEnvironment
Public MyConn As rdoConnection
Public avarSuppliers As Variant
Public avarShippers As Variant
Public Const ERR_CONNECT = 1000
Public Const ERR_RECORDSET = 1001
Declare Function GetTickCount Lib &quot;Kernel32&quot; () As Long
'Entry point of component
Sub Main()
End Sub
'******************************************************************************
'Name: RDOOpen
'Purpose: Open rdoConnection
'Created By: Randy Byrne, randy_byrne@msn.com
'Date: 3/20/97
'Arguments: None
'Returns: True if successful, False if error
'*******************************************************************************
Function RDOOpen() As Boolean
Dim lngRowCount As Long
Dim MyRSSuppliers As rdoResultset
Dim MyRSShippers As rdoResultset
Dim strSQL As String
On Error Resume Next
Set MyEnv = rdoEngine.rdoEnvironments(0)
Set MyConn = MyEnv.OpenConnection(&quot;&quot;, _
rdDriverNoPrompt, , strConnect)
If Err &lt;&gt; 0 Then
    RDOOpen = False
    blnConnected = False
    On Error GoTo 0
    Err.Raise vbObjectError + ERR_CONNECT, , _
    &quot;Connection to database failed!&quot; _
    &amp; vbCr &amp; &quot;Connect String:&quot; &amp; vbCr &amp; strConnect
    Exit Function
Else
    RDOOpen = True
    blnConnected = True
End If
On Error Resume Next
'Create a static variant array that is passed when GetSuppliers
'method is called from base client
strSQL = &quot;Select CompanyName, Phone, SupplierId &quot;
strSQL = strSQL &amp; &quot;from Suppliers ORDER BY CompanyName&quot;
Set MyRSSuppliers = MyConn.OpenResultset(strSQL, rdOpenStatic)
lngRowCount = MyRSSuppliers.RowCount
If lngRowCount &gt; 0 Then
    ReDim avarSuppliers(lngRowCount, MyRSSuppliers.rdoColumns.Count)
    avarSuppliers = MyRSSuppliers.GetRows(lngRowCount)
End If
strSQL = &quot;Select companyname, phone, shipperID &quot;
strSQL = strSQL + &quot;from shippers order by companyname&quot;
Set MyRSShippers = MyConn.OpenResultset(strSQL, rdOpenStatic)
lngRowCount = MyRSShippers.RowCount
If lngRowCount &gt; 0 Then
    ReDim avarShippers(lngRowCount, MyRSShippers.rdoColumns.Count)
    avarShippers = MyRSShippers.GetRows(lngRowCount)
End If
MyRSShippers.Close
MyRSSuppliers.Close
End Function
'******************************************************************************
'Name: RDOClose
'Purpose: Close rdoConnection
'Created By: Randy Byrne, randy_byrne@msn.com
'Date: 3/20/97
'Arguments: None
'Returns: None
'*******************************************************************************
Sub RDOClose()
On Error Resume Next
MyEnv.Close
MyConn.Close
blnConnected = False
strConnect = &quot;&quot;
End Sub
Option Explicit
'******************************************************************************
'Name: ClistServer Class
'Purpose: Provide Variant Arrays to controls on Outlook Forms
'Uses: Remote Data Objects 2.0
'Created By: Randy Byrne, randy_byrne@msn.com
'Date: 3/21/97
'*******************************************************************************
Private Sub Class_Initialize()
lngInstanceCount = lngInstanceCount + 1
End Sub
Private Sub Class_Terminate()
lngInstanceCount = lngInstanceCount - 1
If lngInstanceCount = 0 Then
    'Close the rdoConnection
    RDOClose
End If
End Sub
'******************************************************************************
'Name: GetList
'Purpose: Returns variant array to base client
'Created By: Randy Byrne, randy_byrne@msn.com
'Date: 3/20/97
'Arguments: strSQL
'Returns: Variant Array populated with resultset created by strSQL
'*******************************************************************************
Public Function GetList(ByVal strSQL As String) As Variant
Dim RS As rdoResultset
Dim avarList As Variant
Dim intRows As Integer
Dim intColumns As Integer
On Error Resume Next
If MyConn Is Nothing Then
    ReDim avarList(0, 0)
    GetList = avarList
    On Error GoTo 0
    Err.Raise vbObjectError + ERR_CONNECT, , _
    &quot;Connection to database failed!&quot; _
    &amp; vbCr &amp; &quot;Connect String:&quot; &amp; vbCr &amp; strConnect
Else
    Set RS = MyConn.OpenResultset(strSQL, rdOpenStatic)
    If Err &lt;&gt; 0 Then
        On Error GoTo 0
        Err.Raise vbObjectError + ERR_RECORDSET, , _
        &quot;Could not open Recordset for SQL statement&quot; _
        &amp; vbCr &amp; strSQL
    Else
        intRows = RS.RowCount
        intColumns = RS.rdoColumns.Count
        intColumnCount = intColumns
    End If
    If intRows Then
        ReDim avarList(intRows, intColumns)
        avarList = RS.GetRows(intRows)
        GetList = avarList
    Else
        intColumnCount = 1
        ReDim avarList(0, 0)
        GetList = avarList
    End If
    RS.Close
End If
End Function
'******************************************************************************
'Name: GetTick
'Purpose: Return number of seconds elapsed since midnight to base client
'This function is a wrapper for Win32 GetTickCount
'API calls cannot be made from within VBScript
'Created By: Randy Byrne, randy_byrne@msn.com
'Date: 3/12/97
'Arguments: None
'Returns: None
'*******************************************************************************
Public Function GetTick() As Long
GetTick = GetTickCount
End Function
'******************************************************************************
'Name: GetSuppliers
'Purpose: Returns variant array to base client
'Created By: Randy Byrne, randy_byrne@msn.com
'Date: 3/20/97
'Arguments: None
'Returns: None
'*******************************************************************************
Public Function GetSuppliers() As Variant
If MyConn Is Nothing Then
    ReDim avarSuppliers(0, 0)
    GetSuppliers = avarSuppliers
    Err.Raise vbObjectError + ERR_CONNECT, , _
    &quot;Connection to database failed!&quot; _
    &amp; vbCr &amp; &quot;Connect String:&quot; &amp; vbCr &amp; strConnect
Else
    intColumnCount = UBound(avarSuppliers) + 1
    GetSuppliers = avarSuppliers
End If
End Function
'******************************************************************************
'Name: GetShippers
'Purpose: Returns variant array to base client
'Created By: Randy Byrne, randy_byrne@msn.com
'Date: 3/20/97
'Arguments: None
'Returns: None
'*******************************************************************************
Public Function GetShippers() As Variant
If MyConn Is Nothing Then
    ReDim avarShippers(0, 0)
    GetShippers = avarShippers
    Err.Raise vbObjectError + ERR_CONNECT, , _
    &quot;Connection to database failed!&quot; _
    &amp; vbCr &amp; &quot;Connect String:&quot; &amp; vbCr &amp; strConnect
Else
    intColumnCount = UBound(avarSuppliers) + 1
    GetShippers = avarShippers
    
End If
End Function
'******************************************************************************
'Name: ConnectString Property Let
'Purpose: Establish rdoConnection based on strConn
'Created By: Randy Byrne, randy_byrne@msn.com
'Date: 3/20/97
'Arguments: strConn
'Returns: None
'*******************************************************************************
Public Property Let ConnectString(ByVal strConn As String)
    If strConnect = &quot;&quot; Then
        strConnect = strConn
        RDOOpen
    Else
        If Not (blnConnected) And strConn &lt;&gt; strConnect Then
            'Close existing connection
            RDOClose
            'Open new connection
            RDOOpen
            If blnConnected Then
                strConnect = strConn
            End If
        End If
        If Not (blnConnected) Then
            RDOOpen
        End If
    End If
End Property
'******************************************************************************
'Name: ConnectString Property Get
'Purpose: Return strConnect to base client
'Created By: Randy Byrne, randy_byrne@msn.com
'Date: 3/20/97
'Arguments: None
'Returns: strConnect
'*******************************************************************************
Public Property Get ConnectString() As String
    ConnectString = strConnect
End Property
'******************************************************************************
'Name: ColumnCount Property Get
'Purpose: Returns intColumnCount to base client
'Created By: Randy Byrne, randy_byrne@msn.com
'Date: 3/20/97
'Arguments: None
'Returns: intColumnCount
'*******************************************************************************
Public Property Get ColumnCount() As Integer
    ColumnCount = intColumnCount
End Property
</font></pre>
<h3>Additional Sources of Information</h3>
<p>
<b>Available on http://www.microsoft.com:</b></p>
<p>
<u>Building Custom Applications with Microsoft Outlook</u></p>
<p>
<u>Building Outlook Information-Sharing Solutions</u></p>
<p>
<b>Available on http://www.microsoft.com/outlookdev</b></p>
<p>
The Microsoft Outlook 97 Automation Server Programming Model <BR><u>http://www.microsoft.com/OutlookDev/TechInfo/outprog.htm</u></p>
<p>
Using ODBCDirect in Outlook 97: The Northwind Order Application <BR><u>http://www.microsoft.com/OutlookDev/TechInfo/odbcoutl.htm</u></p>
<p>
From Office 97/Visual Basic Programmer’s Guide<BR><u>http://www.microsoft.com/OfficeDev/Docs/OPG/</u></p>
<p>
Understanding Object Models<BR><u>http://www.microsoft.com/OfficeDev/Docs/Opg/002/002.htm</u></p>
<p>
Microsoft Outlook Objects<BR><u>http://www.microsoft.com/OfficeDev/Docs/Opg/005/005.htm</u></p>
<p>
Data Access Objects<BR><u>http://www.microsoft.com/OfficeDev/Docs/Opg/011/011.htm</u></p>
<p>
Accessing Exchange and Outlook Data Using Visual Basic<BR><u>http://www.microsoft.com/AccessDev/AccWhite/ExcOutlk.htm</u></p>
<p>
Building Successful Client/Server Applications<BR><u>http://www.microsoft.com/visualtools/scenarios/ClientServer.htm</u></p>
<p>
Web Collaboration and Workflow Applications<BR><u>http://www.microsoft.com/visualtools/scenarios/WebWorkflow.htm</u></p>
<p>
Integrate the Enterprise<BR><u>http://www.microsoft.com/visualtools/scenarios/LegacyInteroperability.htm</u></p>
<p>
Data Access Interfaces<BR><u>http://www.microsoft.com/visualtools/strategy/DataAccess.htm</u></p>
<p>
<b>Other Important Sites for Microsoft Outlook:</b></p>
<p>
Outlook Resource Site<BR><u>http://outlook.useast.net/outlook/</u></p>
<p>
Slipstick Systems Microsoft ExchangeCenter<BR><u>http://www.slipstick.com/exchange/</u></p>
<p>
&copy; 1997 Microsoft Corporation. All rights reserved.</p>
<p>
The information contained in this document represents the current view of Microsoft Corporation on the issues discussed as of the date of publication. Because Microsoft must respond to changing market conditions, it should not be interpreted to be a commitment on the part of Microsoft, and Microsoft cannot guarantee the accuracy of any information presented after the date of publication.</p>
<p>
This document is for informational purposes only. MICROSOFT MAKES NO WARRANTIES, EXPRESS OR IMPLIED, IN THIS SUMMARY.</p>
<p>
Microsoft and Visual Basic are registered trademarks and SQL Server is a trademark of Microsoft Corporation.</p>
<p>
DB2 is a registered trademark of International Business Machines Corporation.  Informix is a registered trademark of Informix Softeware, Inc. ORACLE is a registered trademark of Oracle Corporation. Paradox is a registered trademark of Borland Ingernational, Inc.</p>
<p>
Other product or company names mentioned herein may be the trademarks of their respective owners.</p>
</font></BODY>
</HTML>
