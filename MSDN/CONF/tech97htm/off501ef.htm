<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Database Replication with the Microsoft Jet Database Engine: A Technical Overview</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>



	<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>



	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<h1>Database Replication with the Microsoft Jet Database Engine: A Technical Overview </h1>
<p>
Presented by: Tony Poll<BR>Microsoft Corporation<BR>Redmond, WA</p>
<p>
Published: November 1996. <BR>For the latest information, see http://www.microsoft.com/officedev/</p>
<p>
The Microsoft&reg; Jet database engine version 3.5 is a 32-bit engine that provides database processing and replication functionality to a variety of applications. This document is intended for experienced Microsoft Access users who want to understand database replication as implemented in Microsoft Jet and use it more effectively in their applications. </p>
<h2>What Is Database Replication?</h2>
<p>
Database replication is a technique you can use to support multiple users of an application. Replication is the process of creating multiple copies of an application and its data, to be used at locations that are not always connected to each other. Collectively, the copies are called a <i>replica set</i>. One member of the replica set must be designated as the <i>Design Master; </i>any other copy is a <i>replica</i>. Each replica contains a common set of <i>replicated objects</i>. Any single replica can also contain <i>local objects</i> that exist only in that replica.</p>
<p>
A replica set can contain only one Design Master, but can contain as many replicas as needed. The Design Master is the only copy where changes to the database design are allowed. You can designate any replica as the Design Master, but be sure that only one replica is marked as the Design Master at any time. To create a Design Master, you convert an existing database to replicable format and set certain properties to identify it as the Design Master. Some of the replication tools available do this for you automatically. </p>
<p>
A database in replicable format includes a number of fields and tables that Microsoft Jet uses to manage the replicated application. For example, one field in each row in a replicated table has a globally unique identifier (GUID) that distinguishes the row from every other row in the replica set. Another field records the <i>lineage</i> (replica ID/version pair) of each row. When a record is updated, the version number for that replica's record in the lineage is incremented.</p>
<p>
Any copy&#45;the Design Master or a replica&#45;can update the data. This is called a <i>multi-master data update</i> design; it permits a fully distributed system where data updates are not centralized. This is a significant benefit of using Microsoft Jet, because most other relational database engines support <i>single-master data updates</i> where data can only be updated at a single replica. A row is the most basic unit of information recognized in replication. This means that if any cell in a row is modified then the whole row is marked as changed. When changes are transmitted during synchronization, the whole row is updated. OLE objects and memo fields are exceptions; these items&#45;due to their potential large size&#45;are not transmitted unless they have been changed.</p>
<p>
<i>Synchronization</i>, an important part of the replication process, reconciles all these changes and updates the data set in each replica. The <i>file tracking system</i> in Microsoft Jet tracks and records all changes at all replicas, in preparation for updating data during synchronization. Only rows marked as changed are updated when you synchronize replicas. If two replicas simultaneously update the same record at different replicas, Microsoft Jet reconciles the updates. Synchronization can be performed on a regular schedule or as often as necessary to ensure all users have current data. This means that all information will reach all replicas, but there is no guarantee it will reach all replicas within any specified amount of time. When using Microsoft Jet, application designers must allow for this in their designs. </p>
<p>
Microsoft Jet uses incremental replication. This means that, during a single synchronization between two replicas, the only updates made are those resulting from changes made since the last synchronization. This provides significant benefits over methods of data distribution that transmit the whole database whenever new data or objects require distribution. Each row in a replicable database has a generation counter; Microsoft Jet uses this field to control incremental exchanges. Microsoft Jet also records the maximum generation in the local database.</p>
<p>
Not all applications that support Microsoft Jet use its features in the same way. For example, although Microsoft Excel cannot replicate a database, it can update a database replicated by another product. Microsoft Jet monitors the changes made by Microsoft Excel, Microsoft Visual Basic&reg;, or Microsoft Access to a replica, and updates these changes when you synchronize the replicas.</p>
<h2>Where Is Microsoft Jet supported?</h2>
<p>
Microsoft&reg; Windows&reg; 95 and Microsoft Windows NT&reg; Intel platforms support the Microsoft Jet database engine. These products support Microsoft Jet either directly or through Microsoft Data Access Objects (DAO): 
<ul>
<li>
Microsoft Access 97<br><br></li>
<li>
Microsoft Visual Basic<br><br></li>
<li>
Microsoft Excel 97<br><br></li>
<li>
Microsoft Visual C++&reg;<br><br></li>
<li>
Microsoft Project 97<br><br></li>
<li>
Microsoft Office 97, Developer Edition</li>
</ul>
<p>
In addition, Microsoft Windows NT, Novell&reg; NetWare&reg;, and Windows 95 peer-to-peer networks support Microsoft Jet. Banyan&reg; Vines and LANtastic&reg; do not support the Microsoft Jet Database. Microsoft Jet includes replication code that monitors whether a replica has been copied or moved to a new network location, and determines whether a replica requires a new ReplicaID. Microsoft Jet presumes that files are named in accordance with Microsoft and Novell network file-naming conventions, which are different from the file-naming conventions used by Banyan and LANtastic.</p>
<p>
Replication is a feature of the Jet database engine, not of the specific applications that include the Jet database engine. Microsoft Jet performs all database processing for Microsoft Access and Visual Basic, and can provide data to Open Database Connectivity (ODBC) client applications using the Microsoft Access 2.0 ODBC driver.</p>
<h2>When Should I Use Replication?</h2>
<p>
Replication is well suited for distributed systems that focus primarily on adding new records rather than on updating existing records. Sales representatives who visit customer offices, parcel delivery drivers, and inspectors who visit a variety of construction sites are all examples of users who might benefit from replication. There are many tools and techniques for implementing replication. Some factors to consider when choosing a replication technique are: 
<ul>
<li>
How quickly you want the application to respond.<br><br></li>
<li>
How quickly you need data synchronized across all sites.<br><br></li>
<li>
Budget for hardware, software, and communication services.<br><br></li>
<li>
Overall system reliability requirements.</li>
</ul>
<p>
The best candidates for replication are applications that can tolerate some latency in data updates in exchange for a robust configuration that can allow updates from any replica and that supports users who are only occasionally connected. This flexibility means the system can work more effectively, potentially improving business performance. Using flexible, low-cost, off-peak asynchronous communication links and asynchronous data duplication provides &quot;real-time-enough&quot; updates without the expense and vulnerability of full-time connection between all nodes. When the application's users are connected, it might be via a direct connection on a local area network (LAN) or wide area network (WAN), or via the Internet. Data can be exchanged on a LAN, a WAN, or the Internet. </p>
<p>
Microsoft Jet replication is a good solution if you want to: 
<ul>
<li>
Share data among users at multiple remote locations.<br><br></li>
<li>
Automate the distribution of new features and updates to multiple users.<br><br></li>
<li>
Use different machines for system queries and transaction processing (this can improve transaction-processing performance).<br><br></li>
<li>
Automatically back up data without disabling the system (each replica serves as a backup, so a separate backup procedure is not needed).</li>
</ul>
<p>
If your multiuser application requires very frequent data updates, if it will update a large number of records at one or more sites, or if it is critical for data changes to be very quickly obvious to other users, replication may not be the best solution for you to use. Applications in these categories are better served by two-phase commit solutions. A &quot;two-phase commit&quot; is where replicas are connected all the time, and an update at any one site will only be accepted if agreement is immediately given from all other sites. It's called a two-phase commit because the initial phase is notification of a proposed update sent to all replicas, and the second phase is the actual update only when all sites have agreed (that is, committed) to the update.</p>
<h2>Tools that Implement Replication</h2>
<p>
There are several tools you can use to implement Microsoft Jet replication. These tools allow you to convert a database to replicable format, identify a replicable database as the Design Master or a replica, initiate synchronization of the replica set, and a variety of other management tasks. You can use the following tools to implement Microsoft Jet replication: 
<ul>
<li>
Microsoft Access 95 or Microsoft Access 97, running under Windows 95 or Windows NT<br><br></li>
<li>
Briefcase replication<br><br></li>
<li>
Microsoft Replication Manager, available through Microsoft Office 97, Developer Edition<br><br></li>
<li>
DAO programming, available in Windows 95 or Windows NT version 3.51 or later</li>
</ul>
<p>
The first three of these tools provide an easy-to-use visual interface, while the last enables programmers to build replication directly into their applications.</p>
<p>
<b>Microsoft Access Replication Commands</b></p>
<p>
The <b>Replication</b> submenu on the <b>Tools</b> menu in Microsoft Access provides several commands to help you create a replica, synchronize a replica with another member of the replica set, resolve synchronization conflicts, and recover a replica set's Design Master. For more information about these commands, refer to the Help system provided with Microsoft Access or to <i>Building Applications with Microsoft Access 97</i>. </p>
<p>
<b>Briefcase Replication</b></p>
<p>
The Briefcase is an accessory available in Windows 95 or Windows NT version 4.0. When Microsoft Access is installed on your computer, you can use the Briefcase as a replication tool by simply dragging an MDB file from the Windows Explorer onto the Briefcase icon on the Windows desktop. Like magic, your database is converted into replicable format and becomes a member of your replica set. The Briefcase menus include commands to synchronize the replicas.</p>
<p>
Behind the scenes, of course, Windows is busy making the magic work. When you install Microsoft Access, the Setup program adds Class ID (CLSID) entries for MDB files and for the Briefcase reconciler to the Windows registry. (The Briefcase reconciler is installed only by Microsoft Access; it is not included with Visual Basic or Microsoft Excel.) The reconciler includes the code required to support replication and synchronization. When you drag an MDB file onto the My Briefcase icon, Windows recognizes the class ID and responds by calling the reconciler.  The reconciler converts the database into a replicable form, leaves the Design Master at the source, and places a replica in the Briefcase. The reconciler gives you the option of putting the Design Master in your Briefcase and leaving a replica on the desktop. When you synchronize the replicas, the Briefcase calls the reconciler to merge the replicas. With Briefcase replication, synchronization cannot be scheduled; it occurs only when the <b>Update</b> command is clicked and only between the current member and the specified member.</p>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;Before converting the database, Microsoft Jet asks if you want to make a backup. If you anticipate that any users will need to use a nonreplicable version of the database, it's a good idea to make this backup.</p>
<p>
You can use the Briefcase with files other than MDB files, and with applications other than Microsoft Access. However, doing so will not call the Microsoft Jet replication code; it will call the default Briefcase code instead. If you use the Briefcase when Microsoft Access is not installed or with a non-Microsoft Jet database, dragging a file into the Briefcase is equivalent to simply copying the file into the Briefcase&#45;there is no conversion to replicable format. Therefore, when you update files on your main computer with files from the Briefcase, the Briefcase simply copies over the original file&#45;changes to data and objects are not merged, they are overwritten. </p>
<p>
<b>Microsoft Replication Manager</b></p>
<p>
Microsoft Replication Manager is included with Microsoft Office 97, Developer Edition. It is another tool that lets you use replication to administer a distributed application. It offers more functionality and more features than the Briefcase. Key features include:
<ul>
<li>
Graphical user interface and tools for system development and maintenance.  <br><br></li>
<li>
Visual representation of replica set topologies, which greatly assist system management.  <br><br></li>
<li>
Activity reports to assist with troubleshooting, and synchronization reports to help monitor the activity among replicas. <br><br></li>
<li>
Property dialog boxes that provide valuable information about components.  <br><br></li>
<li>
Administration commands controlling the conversion, creation, location, and management of replicas.<br><br></li>
<li>
Scheduled exchanges between replicas administered via a graphical user interface, plus immediate synchronization with remote replicas via point-and-click commands.<br><br></li>
<li>
Direct and indirect exchanges provide additional support for &quot;rarely connected&quot; users.  Laptop users may specify a networked file location where exchange information may be deposited for later processing. Synchronization is optimized over a LAN or WAN for indirect exchanges, and optimized for direct exchanges when a direct connection can be established between local replicas.<br><br></li>
<li>
Synchronization over the Internet.<br><br></li>
<li>
Exchanges can be configured to only send data, receive data, or send and receive.</li>
</ul>
<p>
Synchronizer</p>
<p>
The Synchronizer is an agent you can use with the Replication Manager to provide scheduled background exchanges between replicas. These exchanges can be made while two replicas are directly connected, or through a file-system transport that does not require a direct connection for the exchange. In either type of transfer, the Synchronizer collects the changes at one replica and transmits them to other replicas. If the file-transfer system is used, one replica must deposit changes in a temporary file. The Synchronizer, initiated from the target replica, collects the updates at a later time and applies them to the target replica. This is a great benefit for rarely connected users; they can post changes whenever convenient rather than depending on an available connection. </p>
<p>
The file-system transport<i> </i>provides an interface to the messaging service, with provision for additional messaging services in later releases.</p>
<p>
<b>Data Access Objects (DAO)</b></p>
<p>
In Microsoft Access and Microsoft Visual Basic, DAO provides a programmatic interface to replication functions. Microsoft Jet includes a variety of extensions to the DAO programming interface. These extensions allow developers to convert a database to replicable format, make additional replicas, synchronize replicas, and manage certain properties of a replicated database. These properties include the description of a single replica or of a replica set, the ID of a particular replica or of the replica set's Design Master, the default replica to be used in an exchange, and the local/global property of each object in the database.</p>
<h2>Structure of a Replicable Database</h2>
<p>
Before you can use replication, you must convert the original database to replicable format. Any of the tools listed earlier can help you do this. A database in replicable format includes a number of tables and fields that are not typically present in a nonreplicable database. When you use the tools listed earlier, Microsoft Jet automatically adds the fields and tables it needs to manage your replicated application. A database in replicable format includes: 
<ul>
<li>
<i>User tables</i>&#45;The tables an application developer constructs (for example, Products, Prices, Customers, and so on ). When you convert the database to replicable format, Microsoft Jet retains your table definitions and adds certain fields it needs to manage the application. <br><br></li>
<li>
<i>System tables</i>&#45;The tables Microsoft Jet requires to manage the application. For example, the MSysIndex table records all indexes in an application.  These tables are generally hidden from users. When a Microsoft Jet database is converted into a replicable database, Microsoft Jet adds new system tables that record the history of exchanges between replicas, the location of other replicas in the replica set, and other information required by the system.<br><br></li>
<li>
<i>GUID</i>&#45;A field that provides a 16-byte globally unique identifier (GUID) for each row in each table. A GUID is guaranteed to be unique, even if two users simultaneously construct a new row at different locations. If Microsoft Jet adds this field to your tables, the default name for the field is s_GUID. If your table already includes a numeric field whose data type is Replicable ID, Microsoft Jet will use the existing field instead of adding a new one. <br><br></li>
<li>
<i>Generation</i>&#45;A field used to ensure that only changed data gets exchanged when two replicas are synchronized. Microsoft Jet adds this field to each table in your application. The default name for the field is s_Generation.<br><br></li>
<li>
<i>Lineage</i>&#45;A field that tracks the version and replica number of each row in each table. Microsoft Jet uses this field to keep track of changes that have already been processed and to ensure that changes to a row are not forever sent in a circle between replicas. Microsoft Jet adds this field to each table in your application. The default name for this field is s_Lineage.</li>
</ul>
<p>
Additional columns are inserted in the table where there are OLE links to embedded graphics or memo fields. This is an exception to the rule that data changes are tracked on a row level. Because OLE objects may be of a significant size, (a bit image may easily be 1 MB or more) and therefore expensive to send over a communications line, Microsoft Jet replication only sends the OLE object if it has been modified.</p>
<p>
<b>System Tables</b></p>
<p>
System tables support code within Microsoft Jet. You should not rely upon the format remaining the same between releases. Treat the descriptions of these tables as &quot;for information only,&quot; which may assist you in debugging certain applications.
<ul>
<li>
<i>MSysErrors</i> identifies where and why errors occurred during data synchronization. This table is replicated to all members of the replica set.<br><br></li>
<li>
<i>MSysExchangeLog</i> is a local table that appears in each member of the replica set, and stores information about synchronizations that have taken place between this member and other members of the replica set.<br><br></li>
<li>
<i>MSysGenHistory </i>stores a history of generations. It contains a record for each generation that a replica knows about. It is used to avoid sending common generations during synchronizations and to resynchronize replicas that are restored from backups. This table appears in all members of the replica set, but it is merged by a process slightly different from that used with normal replicated tables. <br><br></li>
<li>
<i>MSysOthersHistory </i>stores a record of generations received from other replicas. It contains one generation from every message seen from other replicas. <br><br></li>
<li>
<i>MSysRepInfo </i>stores information relevant to the entire replica set, including the identity of the Design Master. It contains a single record. This table is replicated to all members of the replica set. <br><br></li>
<li>
<i>MSysReplicas </i>stores information about all replicas in the replica set. This table is replicated to all members of the replica set. <br><br></li>
<li>
<i>MSysSchChange </i>stores design changes that have occurred in the Design Master so that they can be dispersed to any member of the replica set. The records in this table are deleted periodically to minimize the size of the table. <br><br></li>
<li>
<i>MSysSchemaProb</i> identifies errors that occurred while synchronizing the design of the replica. This table exists only if a design conflict has occurred between the user's replica and another member of the replica set.<br><br></li>
<li>
<i>MSysSchedule </i>stores information for scheduled synchronization. The Synchronizer for a local replica set member uses this table to determine when the next synchronization with another Synchronizer should take place, and how to synchronize data and design changes with the other Synchronizer.<br><br></li>
<li>
<i>MSysSidetable</i> identifies the tables that experienced a conflict and the name of the table that contains the conflicting records. This table is visible only if a conflict has occurred between the user's replica and another in the replica set. This is a local table and is only created at the losing replica in a conflict.<br><br></li>
<li>
<i>MSysTableGuids </i>relates table names to GUIDs. TableGuids are used in tables such as MSysTombstone as a reference to a table name stored in this table. This allows efficient renaming of tables. In addition, this table includes the level number used for ordering tables so that updates can be processed efficiently. This is a local table that is updated by the tracking layer at the Design Master and, as part of the processing of design changes, at all other members of the replica set.<br><br></li>
<li>
<i>MSysTombstone </i>stores information on deleted records, and allows deletes to be dispersed to other replicas. This table appears in all members of the replica set.<br><br></li>
<li>
<i>MSysTranspAddress </i>stores addressing information for Synchronizers and defines the set of Synchronizers known to this replica set. This table appears in all members of the replica set.<br><br></li>
<li>
<i>MSysTranspCoords</i> stores the display layout of the Synchronizers and replicas used by Replication Manager.</li>
</ul>
<p>
<b>GUIDs</b></p>
<p>
Just as a fingerprints distinguish one person from all other people, every object in a set of data must have a unique identifier to distinguish it from all other objects. This identifier is called a GUID (globally unique identifier) or universally unique identifier (UUID). Within a database, the primary key serves a similar purpose; it ensures every record in a table has a unique identifier.</p>
<p>
When you replicate a database, Microsoft Jet adds several fields to each table in the database. One of those fields, s_GUID, contains a GUID that uniquely identifies a single record. A record, or row, in a database, is the smallest unit of information that replication tools will manage. If you change information in a replicated database, the entire row is marked as changed, and the entire row will be updated when you synchronize the data in the table. </p>
<p>
You can use the s_GUID field as the primary key in the database. The advantage of doing so is that it virtually eliminates the possibility of duplicate keys; the potential disadvantage is that the GUID field does not convey any meaning to the user.</p>
<p>
If you choose AutoNumber or Number as the data type for a field, you can select <b>Replication ID</b> as the setting for the <b>FieldSize</b> property. The result is that a GUID is assigned for the row and stored in the field. If a table already includes a field with a GUID, the s_GUID field is not added when you replicate the table. Microsoft Jet uses the existing GUID instead.  </p>
<p>
GUID Generation</p>
<p>
The question &quot;How do I know a GUID is really unique?&quot; is a common one. The process of generating a GUID includes numerous checks to ensure its uniqueness. GUIDs are created from:
<ul>
<li>
The network node ID<br><br></li>
<li>
A time value<br><br></li>
<li>
A clock sequence value<br><br></li>
<li>
A version value<p>
Here is a sample GUID:</p>
<p>
2fac1234-31f8-11b4-a222-08002b34c003</p>
</li>
</ul>
<p>
The hyphens make it easier to read and are used only when the GUID is displayed; they are not part of the GUID. A GUID is derived from the following components: 
<ul>
<li>
<i>Time</i> is a 60-bit timestamp representing the number of 100ns ticks since Oct. 15, 1582 AD. This means time values are valid until approximately AD 3400.<br><br></li>
<li>
<i>Version</i> identifies the version of the algorithm used to generate the GUID.<br><br></li>
<li>
<i>Clock sequence</i> accounts for loss of continuity of the clock, for example when a clock is reset.</li>
</ul>
<p>
A GUID includes the following fields:</p>
<p>
&lt;time_low&gt;-&lt;time_mid&gt;-&lt;time_hi_and_version&gt;-&lt;clock_seq_hi_and_reserved&gt;-&lt;clock_seq_low&gt;-&lt;node&gt; </p>
<p>
where:
<ul>
<li>
The <i>time_low</i> field is set to the least significant 32 bits of the timestamp.<br><br></li>
<li>
The<i> time_mid</i> field is set to bits 32 through 47 of the timestamp.<br><br></li>
<li>
The 12 least significant bits of the <i>time_hi_and_version</i> field are set to bits 48 through 59 of the timestamp.  The four most significant bits are set to the 4-bit version number of the GUID algorithm being used.<br><br></li>
<li>
The six least significant bits of the <i>clock_seq_hi_and_reserved</i> field are set to the six most significant bits of the clock sequence. The most significant two bits are set to &quot;0&quot; and &quot;'1&quot;, respectively. <br><br></li>
<li>
The <i>clock_seq_low</i> field is set to the eight least significant bits of the clock sequence.<br><br></li>
<li>
The <i>node</i> field stores the node ID. The construction of the node ID depends on whether a network card is present. If a network card is present, the node ID is retrieved from NetBIOS. The first six bytes are extracted from the synchronous adapter status NCB.  This is the IEEE 802 48-bit node address.</li>
</ul>
<p>
If a network card is not installed, the node ID is set to a 48-bit number (a 47-bit random number plus 1 bit for local usage). This number is not guaranteed to be unique, even on the generating machine, but is unlikely to be duplicated on another machine. However, because GUIDs are <i>time + sequence</i> this is a reasonable approximation for a local GUID. The node ID returned is explicitly made into a multicast IEEE 802 address so that it will not conflict with a &quot;real&quot; IEEE 802 based node address. The LocalOnly bit contains 1 if the address was cooked up, 0 if it's a real IEEE 802 address. The 48-bit number will be composed of: 
<ul>
<li>
The computer's name.<br><br></li>
<li>
The value of the performance counter.<br><br></li>
<li>
The system memory status.<br><br></li>
<li>
The total bytes and free bytes on drive C.<br><br></li>
<li>
The stack pointer (value).<br><br></li>
<li>
A LUID (locally unique ID).<br><br></li>
<li>
Whatever random data was in the node ID buffer at create time.</li>
</ul>
<p>
GUID Usage</p>
<p>
There can be more than one column with coltypeGUID in a table, but there can be only one autogenerated column of coltypeGUID in a table, regardless of whether the table is replicable.</p>
<p>
Autogenerated GUID columns are identified by the coltypeGUID and
<ul>
<li>
JET_bitColumnAutogenerate <p>
-or-</p>
</li>
<li>
JET_bitPreventDelete  (System column)</li>
</ul>
<p>
If an autogenerated GUID column is added to a table, GUID values are generated for all rows in the table. The value of an autogenerated GUID cannot be changed or deleted.</p>
<p>
<b>Generations</b></p>
<p>
When you convert a table to replicable format, Microsoft Jet adds a new field, s_Generation, to every replicable table in the replicated database.</p>
<p>
The s_Generation field controls which records are sent during an exchange. When a record is modified, its generation is set to zero (0). In general, all records with generation 0 are sent during an exchange, and then the generation for the record is incremented to one more than the last generation, which now becomes the new highest generation.</p>
<p>
When an exchange occurs, the sending replica knows the last generation sent to that specific receiving replica. Only records with generations higher than the previous generations or generation 0 are sent.  </p>
<p>
The receiving replica will not apply generations received out of sequence.</p>
<p>
In some cases Microsoft Jet replication may determine that there are too many records to be sent in a single exchange message. In these situations, the first set of records for the exchange will be of one generation and the following sets of records will be of higher generations. Therefore, it is possible that a single exchange may contain records with different generations.</p>
<p>
Generally there is one generation field per record. To optimize exchanges for databases that contain Memo or OLE Object fields (sometimes referred to as a BLOB, or <u>b</u>inary <u>l</u>arge <u>ob</u>ject) an extra generation field is associated with each BLOB.  This generation value is set to 0, ensuring it is sent during the next exchange, only if the BLOB is modified.  If other fields in a record are modified, but not the BLOB field, then the BLOB generation is not set to 0 and the BLOB is not sent with the exchange.</p>
<p>
<b>Lineage</b></p>
<p>
The s_Lineage field is added to every table in the replicated database.</p>
<p>
The lineage is used to determine which replicas have already received an update and also to determine the winner when conflicts occur.  The lineage consists of a series of entries representing each replica that has changed this row. Each lineage entry consists of a shortened form (2 bytes) of the replica ID and a version number (2 bytes). The shortened version of the replica ID is the replica's <i>nickname</i>. The version number starts at 1 and is incremented each time the record is modified.</p>
<p>
<b>Design Considerations</b></p>
<p>
Microsoft Jet enforces a 2048-byte and 255-field limit to any record. These limits include fields and data you add to tables yourself as well as any fields and data Microsoft Jet adds in the course of replication. When you design tables in an application you plan to replicate, make sure you allow for the fields Microsoft Jet is likely to add.</p>
<p>
At a minimum, each record will receive GUID, s_Lineage and s_Generation fields, which collectively require 24 bytes per record. This means you should design tables with no more than 252 fields (255 maximum, minus 3) and 2,024 bytes (2,048 maximum, minus 24). However, this is not generally a hindrance to good design; very few well-designed applications use either the maximum allowable fields or bytes in a single record. </p>
<p>
If your application uses long binary fields, replication will add an additional 4-byte field per long binary field. This is the result of an exchange optimization, whereby only long binary fields that have been modified are sent in an exchange.</p>
<h2>Updates</h2>
<p>
<b>Data Updates</b></p>
<p>
The Microsoft Jet database engine tracks all data updates in the database. This tracking occurs only in replicated databases, and does not impact the performance of the Microsoft Jet engine for nonreplicated databases.</p>
<p>
In general, updates are marked on a per-row basis. That is, when a row in a table is updated, the whole row is marked as changed. At the same time, the s_Generation field is set to zero and the version number in the s_Lineage field is incremented.</p>
<p>
OLE Object and Memo fields are an exception to this rule. OLE Object and Memo fields are marked separately from the rest of the row, and are sent with the rest of the row only if the OLE Object or Memo field has changed. This is because OLE Object and Memo fields can be large, and therefore expensive and time-consuming to send over a communication link. Therefore, Microsoft Jet doesn't send them unless it is necessary. </p>
<p>
<b>Design Updates</b></p>
<p>
Design changes must be made at the Design Master and then distributed to all other replicas. </p>
<p>
In the rare event the Design Master is lost, you can designate any other replica as the new Design Master.  This action should only be taken when you are certain that the original Design Master will never return, because a replica set with two Design Masters typically corrupts the whole database because conflicting design updates leave the database in an undefined condition.</p>
<p>
If you need to make design changes in a replica that is not currently the Design Master, you can transfer the Design Master designation from the current Design Master to that replica.</p>
<p>
There are situations where it is desirable to have private objects in the database that are not known to all users in the replica set. For example, one user might have a particular query or report of no interest to other users, or the application designer might want to work on a new feature privately until it is ready to distribute to other users. <i>Local objects</i> can be created at any replica for cases like these. Microsoft Jet ignores local objects during synchronization. If you decide that a local object should actually be part of the replicated application, add it to the Design Master and designate it as a <i>global object</i> by opening its <b>Properties</b> box and selecting the <b>Replicable</b> attribute<i>. </i>At the next exchange, the object will be distributed amongst the other replicas in the replica set.  </p>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;If a local object of the same name already exists in a replica, Microsoft Jet will change its name to O<i>riginalName</i>_Local.</p>
<h2>Synchronization</h2>
<p>
Synchronization is the process of exchanging information between two replicas about data and design changes in the replicated application. Updating an entire replica set is a series of synchronizations between pairs of replicas. A replica can behave in one of three ways during an exchange: 
<ul>
<li>
Only send changes (sometimes known as a push exchange).<br><br></li>
<li>
Only receive changes (also known as a pull exchange).<br><br></li>
<li>
Send and receive changes (a bidirectional exchange).</li>
</ul>
<p>
In a push (send-only) indirect exchange, the local replica collects any design changes it has not previously sent to the particular remote replica, and attempts to bundle these changes into a &quot;message&quot; before sending them. (The size of the message may be restricted by physical factors). If there are any generation-zero rows, the generation counter at the local replica is incremented. The changes sent are the combination of all generations larger than the last generation sent, plus any new generations, which are recognized as having a generation of zero. Rows of generation zero are updated with the new, incremented generation number.</p>
<p>
If an exchange gets lost between the remote and local replicas, Microsoft Jet's error-correcting protocol rejects the new message and requests a resend of the lost generations.</p>
<p>
When running the Synchronizer to schedule exchanges between replicas, you may find it advantageous to disable the Windows 95 System Agents (such as Start, Programs, Accessories, and System Tools). Disk compression and defragmenting can make heavy demands upon your PC that prevent scheduled replication exchanges from completing in a timely fashion. To halt these System Agent tasks, right-click the System Agent icon in the Windows 95 taskbar and click <b>Suspend System Agent</b>.</p>
<p>
<b>Internet Synchronization</b></p>
<p>
Synchronization over the Internet is a new feature in Microsoft Jet 3.5/Microsoft Access. When a replica and Replication Manager are both on an Internet server, users can synchronize using a standard HTTP connection. Note, however, that you cannot schedule synchronization over the Internet with Replication Manager, because Replication Manager cannot control the communication link to your Internet service provider. As an alternative, you can write Visual Basic for Applications code to create the link to your Internet service provider, execute a synchronization, and then drop the communications link.</p>
<p>
How Internet Synchronization Works</p>
<p>
You need the following three things to use synchronization over the Internet: a client PC with a replica (R1), an Internet server that is also configured as a Microsoft Jet replication Synchronizer, and a second replica (R2) on the same PC as the Internet server.</p>
<p>
The client PC, where R1 resides, starts the synchronization process with the following actions: 
<ul>
<li>
Identifying the changes to be sent to R2 and bundling them in a message.<br><br></li>
<li>
Establishing a connection to the Internet server and getting the address of the server's FTP folder.<br><br></li>
<li>
Sending the bundled changes to the FTP address.</li>
</ul>
<p>
Once the changes are stored on the server, the client PC drops out of the process. The server continues the synchronization by notifying the Synchronizer that there is data in the FTP folder. The Synchronizer then takes the following actions:
<ul>
<li>
Picks up the data in the FTP folder and applies it to replica R2 on the Internet server.<br><br></li>
<li>
Queries replica R2 to see if there is any data to send back to R1. </li>
</ul>
<p>
If R2 has no changes to send to R1, the synchronization is complete at this point. If R2 needs to send data back to R1, the Synchronizer, Internet server, and client PC complete the process as follows: 
<ul>
<li>
The Synchronizer places the data in the FTP folder and notifies the Internet server there is data for the client PC.<br><br></li>
<li>
The server sends a message to the client PC that there is data to collect.<br><br></li>
<li>
The client PC collects the data and applies it to the client replica, R1.</li>
</ul>
<p>
Internet synchronization works only between replicas on different machines. If you attempt to synchronize two replicas&#45;one managed with an Internet Synchronizer and one unmanaged&#45;on the same machine, you will get a message saying the exchange was unsuccessful because the Internet is slow or because there is a problem with the Internet server. However, if you have the same two replicas on two different computers, the Internet exchange succeeds. </p>
<p>
Preparing for Internet Synchronization</p>
<p>
Before you can synchronize over the Internet, you must property configure your Internet server and Replication Manager. For full details, see &quot;Setting Up an Internet or Intranet Server for Replication&quot; in the Help file provided with Replication Manager. If you're new to the Internet, here is the easiest way to configure everything: 
<ol>
<li>
Set up your Internet server with an operating system and server software. For example, you can use Microsoft Windows NT 4.0 with Microsoft Internet Information Server (IIS). <br><br></li>
<li>
Install Microsoft Access on the same computer. Install Replication Manager on the same computer. Note that Replication Manager runs on Intel server platforms only, and supports the Microsoft Internet Explorer and Netscape server platforms. Internet proxy servers are not supported.<br><br></li>
<li>
Create a replica on the Internet server computer and manage it using Replication Manager. This will &quot;stamp&quot; the replica with information about the Internet server's HTTP address and other internal system information. <br><br></li>
<li>
Create a copy of the replica (you can use the Windows Explorer to do this) and distribute this copy to your users. When they open the replica in Microsoft Access and synchronize, they will be able to synchronize back to the replica on the Internet server by using the automatically configured HTTP address.<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;Some Internet providers may require you to stop and restart Replication Manager and/or the communications connection if synchronization is canceled before it is complete.</p>
</li>
</ol>
<p>
The procedure above describes the easiest way to confirm you have set up your Internet server and your Microsoft Access application for replication. Once you have the system working, you may decide you do not need to install the full version of Microsoft Access on the Internet server, but only the run-time version of Microsoft Access that is included with Office 97, Developer Edition (ODE).  If you decide to use only the run-time version, you can install it on the Internet server by using the ODE Setup Wizard to create a custom Setup program for the Microsoft Access application you want to replicate. When you're creating the Setup program, make sure you select the Microsoft Replication Manager and Microsoft Access Run-Time Version redistributable components. When you run the custom Setup program on the Internet server, it  will extract only the files you need and create the correct registry settings. </p>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;The ODE Setup Wizard is the recommended tool for installing your application on an Internet server because it automatically updates the system for you. For example, the Setup programs created by the Setup Wizard update registry settings for you. Updating these entries manually is complex and prone to error, particularly with regard to Internet settings and versions of system DLLs that interact with other applications. If you manually copy your application and associated files to the server, you must also update system settings such as registry entries. For this reason, we strongly recommend you use the ODE Setup Wizard to create a Setup program for the application.</p>
<p>
Special Considerations When Using CompuServe</p>
<p>
Connections through CompuServe may require extra configuration steps. You may receive the error message &quot;Dial-up Networking could not negotiate a compatible set of protocols you specified in server type settings. Check your network configuration in Control Panel then try the connection again.&quot; Follow these steps to correct the problem:
<ol>
<li>
Start WinCim. Make note of your CompuServe password and CompuServe dial-up phone number. <br><br></li>
<li>
Click the Winsock box and select Configure. Note the host name and, if available, the Host IP address. <br><br></li>
<li>
Close WinCim. <br><br></li>
<li>
If the Host IP address was blank go to an MS-DOS prompt and type ping Host Name.  Note the IP address returned by the system. The address is a number; for example, 149.174.214.47.<br><br></li>
<li>
Double-click the My Computer icon on the Windows 95 desktop. <br><br></li>
<li>
Double-click Dial-<b>Up Networking</b> in the My Computer window. Make sure CompuServe is among the icons in the Dial-Up Networking window. <p>
If CompuServe is not already an option, click <b>Make New Connection</b> in the Dial-Up Networking window. Type <b>CompuServe</b> as the name of the computer you are dialing. Enter the CompuServe phone number as the number to dial. </p>
<p>
If Dial-Up Networking is not on your computer, open Control Panel, double-click <b>Add/Remove Programs</b>, click the <b>Windows Setup</b> tab, click <b>Communications</b>, click the <b>Details</b> button, and then select the <b>Dial-Up Networking</b> check box.</p>
</li>
</ol>
<p>
The next step is to configure your Internet connection properties, as follows: 
<ol>
<li>
Right-click the Internet Explorer icon on your desktop and then click Properties. <br><br></li>
<li>
Click the Connection tab. Select the Connect to the internet as needed check box in the Dialing section, and then select CompuServe in the list of Dial-Up Networking connections. <br><br></li>
<li>
Click the Properties button. You should see the telephone number for CompuServe. <br><br></li>
<li>
Under Connect Using, click Configure. You probably do not need to change the settings on the General tab. <br><br></li>
<li>
Click the Connection tab. Under Call preferences, select the Wait for dial tone before dialing check box. <br><br></li>
<li>
Click the Options tab. Under Connection control, make sure that neither the Bring up terminal window before dialing nor the Bring up terminal window after dialing check box is selected. <br><br></li>
<li>
Click OK to return to the General dialog box. <br><br></li>
<li>
Click the Server Type button.  In the Type of Dial-Up Server box, make sure PPP:Windows 95, Windows NT 3.51, Internet is selected. Under Advanced options, make sure Log on to network, Enable software compression, and Required encrypted password are not selected. Under Allowed network protocols, make sure NetBEUI and IPX/SPX Compatible are not selected, and that TCP/IP is selected.<br><br></li>
<li>
Click the TCP/IP Settings button. Make sure Server assigned IP address is selected. Click the Specify name server addresses option button and enter the IP address (for example, 149.174.214.47) that you obtained earlier as the setting for Primary DNS. Make sure the Use IP header compression and Use default gateway on remote networks check boxes are both selected.<br><br></li>
<li>
Click OK four times to return to the desktop.<br><br></li>
<li>
Click the Start button, point to Programs, point to Accessories, and then click Dial-Up Scripting Tool. With this tool, you can create a script to create a dial-up connection to CompuServe. <p>
If the Scripting Tool is not installed, open the Control Panel and double-click Add/Remove Program. Click the Windows Setup tab, and then click the Have Disk button. A dialog box appears with a prompt for the location of the manufacturer's files. Set this to the  \Admin\Apptools\Dscript folder on your Windows 95 CD and click OK. In the next dialog box, select the SLIP and Scripting for Dial-Up Networking check box and then click the Install button. Click OK twice to install the tool and close Add/Remove Programs.</p>
</li>
<li>
In the Dial-Up Scripting Tool, select the CompuServe connection you just created. Click Browse, then click Cis.scp, and then click Open. Make sure Step through script is not selected, and that Start terminal screen minimized is selected. Click Apply, and then click Close.</li>
</ol>
<p>
You should now be ready to go! Now, whenever you attempt a Microsoft Jet replication synchronization across the Internet, you will connect via the CompuServe Internet server. To do this, double-click the CompuServe icon in the Dial-Up Networking window. Enter your CompuServe ID (for example, 12345,1234) in the<b> User name</b> box, and then enter your password in the <b>Password</b> box. You can choose to save the password; if you do, you will not be prompted to enter it each time you connect to CompuServe.</p>
<p>
Internet Synchronization with DAO</p>
<p>
DAO includes a new parameter, dbRepSyncInternet, that supports Internet synchronization. You cannot use dbRepSyncInternet independently; you must fully specify which type of synchronization you want to use. Here are three statements that illustrate how you can use this parameter:</p>
<pre><FONT FACE="Courier New" SIZE="2">db.Synchronize &quot;DatabasePathName&quot;, _
&#09; dbRepImpChanges + dbRepSyncInternet

db.Synchronize &quot;DatabasePathName&quot;, _
&#09; dbRepExpChanges + dbRepSyncInternet

db.Synchronize &quot;DatabasePathName&quot;, _
&#09; dbRepImpExpChanges + dbRepSyncInternet
</font></pre>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;DAO provides dbRepExpChanges as a default parameter only if the user does not specify any parameters at all.</p>
<p>
<b>Conflicts and Errors</b></p>
<p>
When two users simultaneously update data, there are three possible outcomes: 
<ul>
<li>
The synchronization results in transparent updates with no errors or conflicts.<br><br></li>
<li>
A <i>conflict</i> occurs because the two users updated the same record.<br><br></li>
<li>
An error occurs because the changes made by the user cannot be resolved in synchronization.</li>
</ul>
<p>
The first case is the most common; in well-designed replicable database applications, users can simultaneously update data without any adverse side effects. However, if two or more users modify the same row at the same time, conflicts or errors can occur. </p>
<p>
A <i>conflict</i> occurs when two users update the same record. When this happens, Microsoft Jet chooses one replica to win the conflict and one to lose. The record from the winning replica is placed in the table and replicated to the rest of the replica set. The losing record is returned to the loser, and reported in a special table called <i>TableName</i>_Conflict, where <i>TableName</i> identifies the table where the conflict occurred. The user of the losing replica is notified that conflicts exist and is prompted to either reapply the data or delete it. Conflicts do not cause the data in the replica set to diverge, and are usually a minor problem that is easily fixed.</p>
<p>
<i>Errors</i> are simultaneous changes that can cause divergence in the data stored in the conflicting replicas. For example, an error occurs if users at two or more replicas simultaneously insert a new record and both records use an index value that was previously defined as unique. When the replicas attempt to synchronize, a duplicate key error will be returned.</p>
<p>
Several conditions can cause an error: 
<ul>
<li>
A duplicate primary key.<br><br></li>
<li>
A locked table during an exchange.<br><br></li>
<li>
Violation of a table-level validation (TLV) rule.<br><br></li>
<li>
Violation of a referential integrity constraint. </li>
</ul>
<p>
For example, a TLV rule may prevent one replica from accepting an update that was successfully inserted in another replica. Consider a replica set with only two members: the Design Master and one other replica. The owner of the Design Master creates a TLV rule on a field (such as  Salary &gt; $10,000).  Simultaneously a user modifying the replica enters a new record with a value in the Salary field of $9,000, which is accepted since the TLV rule has not been sent to the replica. When the two replica is synchronized with the Design Master, Microsoft Jet attempts to insert the salary record from the replica into the Design Master. The Design Master rejects it and records an error. (Of course, you can avoid this situation by synchronizing the Design Master with all replicas before a new TLV rule is introduced.)</p>
<p>
Errors are recorded in the MSysErrors table and replicated to all replicas. Errors must be corrected as soon as possible because they indicate that data in different replicas may be diverging.</p>
<p>
Sometimes errors are self-correcting. For example, Microsoft Jet rejects updates on records that are locked when synchronization is attempted. Microsoft Jet records this as an error and attempts the update at a later time.  Microsoft Jet removes the error if it later updates the record successfully. </p>
<p>
<b>Conflict Resolution</b></p>
<p>
If two users simultaneously update the same record in different replicas, a conflict occurs when Microsoft Jet next attempts to synchronize these two replicas. When a conflict occurs, Microsoft Jet uses the following conflict-resolution algorithm to determine a winner and a loser:
<ul>
<li>
The replica where the record has been changed most often wins.  (Each change to the record increments the record's version number, so the record with the highest version number is the one that has been changed most often.)<br><br></li>
<li>
If the version numbers are equal, the replica with the lowest replica ID wins.</li>
</ul>
<p>
This algorithm is guaranteed to be deterministic. There is no provision to modify this algorithm.  </p>
<p>
The winning record is placed in the table in both replicas.  The losing record is placed in the loser's replica only in a &quot;conflict table&quot;.  The conflict-table is named <i>TableName</i>_Conflict (where <i>TableName</i> is the name of the table where the conflict occurred).  Microsoft Access automatically invokes a wizard to assist the user in resolving entries in conflict tables. </p>
<p>
Microsoft Jet uses a merge reconciler that merges individual rows from multiple replicas into a single database; it does not use the default Windows 95 Briefcase reconciler. The default reconciler simply determines which version of the file has the later time stamp and copies that file over the version with the earlier time stamp. It has no provision for record-level conflict resolution; any updates outstanding in the losing file are lost in the process. By merging changes from multiple replicas, the Microsoft Jet reconciler retains changes from the losing replica rather than simply overwriting them with data from the winning replica.</p>
<p>
You can enhance the Microsoft Jet algorithm with your own Visual Basic for Applications function. Microsoft Jet will still initially resolve conflicts using its own algorithm but you can use your code to manipulate the results. You must register your function as a database property. To do this, click <b>Database Properties</b> on the <b>File</b> menu, and then click the <b>Custom</b> tab. In the <b>Name</b> box, type <b>ReplicationConflictFunction</b>; in the <b>Type</b> box, select <b>Text</b>; and in the <b>Value</b> box, type the name of your function; for example, <b>Resolve()</b>. </p>
<p>
Here is a simple function to display the name of any table with a conflict in the Debug window:</p>
<pre><FONT FACE="Courier New" SIZE="2">Public Function Resolve()     'Find tables with conflicts
&#09;Dim db As Database
&#09;Dim tdf As TableDef

&#09;Set db = CurrentDb
&#09;For Each tdf In db.TableDefs
&#09;&#09;If (tdf.ConflictTable &lt;&gt; &quot;&quot;) Then
&#09;&#09;&#09;Debug.Print tdf.Name &amp; &quot; had a conflict&quot;
&#09;&#09;End If
&#09;Next tdf
End Function
</font></pre>
<p>
To view the Debug window, press CTRL+G.</p>
<p>
You can customize this function to resolve conflicts according to your own business rules. For example, if your application includes a special date/time field that is always updated when a record is inserted or edited, your Visual Basic for Applications function could use this field to select the record with the most recent update as the winner. However, your code will replace the Conflict Resolver provided by Microsoft;  therefore your function must resolve all errors and conflict situations. It is not sufficient to resolve conflicts and ignore errors; the net result will be inconsistent replicas with unresolved errors.</p>
<h2>Partial Replicas</h2>
<p>
A <i>partial replica</i> is one that contains a subset of data. Support for partial replicas is a new feature in Microsoft Jet 3.5/Microsoft Access 97. You can use either the Partial Replica Wizard or Visual Basic for Applications code to create a partial replica. The Partial Replica Wizard is available on the Internet; visit the Office Developer web site at http://microsoft.com/officedev/ for more details. </p>
<p>
A WHERE clause on a table defines a partial replica. For example, to create a partial replica with customers from California, you would specify &quot;Region = 'CA'&quot;. You cannot use user-defined or aggregate functions, nor can you prompt the user at run-time for parameter values. By using Visual Basic for Applications, you can apply restrictions to any number of tables. The Partial Replica wizard limits you to placing restrictions on a single table.</p>
<dl>
<dt>
You must enclose date variables with the number sign (#). For example, to select orders placed after March 31, 1995, and before December 31, 1996, enter the following:</dt>
<dd>
[Order Date] &gt; #3/13/95# AND [Order Date] &lt; #12/31/96#<br>
</dd>
<dt>
You must surround the contents of Text and Memo fields with quotation marks. For example, to specify Jane Doe's name, enter the following:</dt>
<dd>
[FirstName] = &quot;Jane&quot; AND [LastName] = &quot;Doe&quot;<br>
</dd>
<dt>
To enter numeric values, use the field's name and the value. For example, to enter 1 as the category ID, enter the following: </dt>
<dd>
[CategoryID] = 1</dd>
</dl>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;Multiple filters are OR'ed together. For example, if you set a filter of &quot;Region = 'CA'&quot; for the Customers table and a filter of &quot;Value &gt; $1,000&quot; for the Orders table, the result will include all records for customers from California PLUS all orders with a value greater than $1,000. You would <i>not </i>get orders of over $1,000 only for customers from California.</p>
<p>
The <b>PartialReplica</b> property lets you specify which relationships to follow when creating a partial replica. For example, to select only the orders for the customers in California, set the <b>PartialReplica</b> property for the CustomersOrders relationship to <b>True</b>.</p>
<p>
With Visual Basic for Applications, you can create more sophisticated partial replicas by applying restrictions to any number of tables. The following example shows how you can create a partial replica, set a filter on a table, set the <b>PartialReplica</b> filter property, and populate the partial replica with data:
<ol>
<li>
Create a partial replica. This will be an empty database with no filters, and no data records.<pre><FONT FACE="Courier New" SIZE="2">Public Function CreatePartialReplica()
&#09;Dim dbsFull As Database     'The source replica

&#09;Set dbsFull = OpenDatabase(&quot;C:\NWIND.MDB&quot;)
&#09;'Create partial replica from full replica, description, 
&#09;'set the dbRepMakePartial option.
&#09;dbsFull.MakeReplica &quot;C:\PARTIAL.MDB&quot;, _
&#09;   &quot;Replica of NWIND.MDB&quot;, dbRepMakePartial
&#09;dbsFull.Close
&#09;'You have a partial replica, but no data rows.
End Function
</font></pre>
</li>
<li>
Set a filter to select customers from Washington state.<pre><FONT FACE="Courier New" SIZE="2">Public Function CreatePartialFilter()
&#09;Dim dbsPartial As Database
&#09;Dim tdfCustomers As TableDef

&#09;'Open the partial replica in exclusive mode.
&#09;Set dbsPartial =OpenDatabase(&quot;C:\PARTIAL.MDB&quot;, True)
&#09;'Open the Customers table.
&#09;Set tdfCustomers = dbsPartial.TableDefs(&quot;Customers&quot;)
&#09;'Set a filter on the Customers table.
&#09;tdfCustomers.ReplicaFilter = &quot;Region = 'WA' &quot;
&#09;dbsPartial.Close
End Function
</font></pre>
</li>
<li>
Set the <b>PartialReplica</b> property on the CustomerOrders relationship to only get the orders for records in the filtered Customers table.<pre><FONT FACE="Courier New" SIZE="2">Public Function CreatePartialRelationships()
&#09;Dim dbsPartial As Database
&#09;Dim Rel As Relation

&#09;'Open the partial replica in exclusive mode.
&#09;Set dbsPartial = DBEngine(0).OpenDatabase(&quot;C:\Partial.MDB&quot;, True)
&#09;For Each Rel in dbsPartial.Relations
&#09;&#09;If (Rel.Table = &quot;Customers&quot;) And _
&#09;&#09;&#09;(Rel.ForeignTable = &quot;Orders&quot;) Then
&#09;&#09;&#09;'Set CustOrd relationship PartialReplica property to True.
&#09;&#09;&#09;Rel.PartialReplica = True
&#09;&#09;Exit For
&#09;&#09;End If
&#09;Next Rel
&#09;dbsPartial.Close
End Function
</font></pre>
</li>
<li>
Populate the partial replica from a full replica.</li>
</ol>
<pre><FONT FACE="Courier New" SIZE="2">Public Function PopulatePartial()
&#09;Dim dbsPartial As Database
&#09;Dim strFull As String

&#09;'Open the partial replica in exclusive mode.
&#09;Set dbsPartial = OpenDatabase(&quot;C:\PARTIAL.MDB&quot;, True)
&#09;'Point to the full replica.
&#09;strFull = &quot;C:\NWIND.MDB&quot;
&#09;'Populate the partial replica from the full replica.
&#09;dbsPartial.PopulatePartial strFull
&#09;dbsPartial.Close
End Function
</font></pre>
<p>
You should call <b>PopulatePartial</b> under any of the following circumstances: 
<ul>
<li>
Before synchronizing a full and a partial replica for the first time. This ensures the partial replica has all the system information required. If you simply create an empty partial replica and do not call <b>PopulatePartial</b> before synchronizing, you will see the message that &quot;the filters are not synchronized&quot; even if no filters are set on the partial replica. <b>PopulatePartial</b> is required to initialize the replica with internal system information before the first synchronization.<p>
Note that <b>PopulatePartial</b> works only with direct connections; it does not support indirect synchronization such as drop box (file transfer) synchronization, Internet synchronization, or FTP folder synchronizations. </p>
</li>
<li>
Whenever you modify the filter for a partial replica. <b>PopulatePartial</b> removes any records from the partial replica that do not comply with the new filter. Simply using the <b>Synchronize</b> method after a change of filters will not remove these &quot;orphaned&quot; records.</li>
</ul>
<p>
Synchronizing between full and partial replicas may require careful attention. Say you create a replica set with three members: Full_1, Partial_1, and Full_2. Now assume Full_1 synchronizes with Partial_1, and because Partial_1 has a filter, it only gets a subset of the changes made at Full_1. Now Partial_1 synchronizes with Full_2. Obviously only the subset of the changes stored in Partial_1 can be sent to Full_2. It would be a mistake to assume that Full_2, having successfully completed the exchange, has all the updates from Full_1. The only way to guarantee that Full_2 has all the changes is to synchronize with another full replica. When synchronizing full and partial replicas, the best process is to treat partial replicas as 'leaf' nodes. That is, designate them as the end of a synchronization chain. This also increases the efficiency of synchronizations, because the protocol that ensures correct propagation of updates between partial and full replicas may result in redundant data exchange.</p>
<p>
Partial replicas introduce a number of subtleties for deleting or updating records when referential integrity and cascading updates or deletes are used in the same application. Consider what might occur in a simple database with two tables: Customers and Orders. Referential integrity is enforced between these tables, and cascading updates or deletes are not enabled.  Consider Customer A who has Orders records in the full replica. Now assume there is a partial replica with only the Customers table.  If Microsoft Jet allowed the records pertaining to Customer A to be deleted at the partial replica, then this delete would fail when it was sent to the full replica, because there would be existing records for Customer A.</p>
<p>
To prevent this, Microsoft Jet traps attempts to update or delete primary keys in the parent table in partial replicas, and permits them only if
<ul>
<li>
The parent table has no children.</li>
</ul>
<p>
Or if, for each child table:
<ul>
<li>
Any <b>PartialReplica</b> property of any enforced relationship between the parent and child is set to <b>True</b>.<p>
-or-</p>
</li>
<li>
The child table's filter is set to <b>True</b> (which indicates all records in child table are present).</li>
</ul>
<p>
For partial replicas, Microsoft Jet looks only at the immediate child table to decide whether to permit an update or delete. However, it's important to remember the effect that cascading updates and deletes can have. Consider an example of three related tables (Customers, Orders, and OrderDetails). If cascading updates and deletes are enabled, an attempt to update a Customer record in a partial replica will also attempt to update any Order records, which in turn will attempt to update any OrderDetails records. If cascading updates and deletes are not enabled, an update to a Customer record would check the Order records and ignore the OrderDetails records.</p>
<h2>Security</h2>
<p>
Replicated databases use the same security model as nonreplicated database. The permissions assigned to a user's logon ID control the actions that user can take on the database. </p>
<p>
The application designer must ensure that the same security information is available in each replica. There are two ways to do this: 
<ul>
<li>
Make the <i>exact</i> same security file, System.mdw, available to each replica. The security file can not be replicated, but it can be physically copied to each location.<br><br></li>
<li>
Recreate the entries for users and groups at each location in the <i>local</i> security file. To do this, copy the user and group names and associated PIDs from System.mdw into the local file. Make sure to copy the entries exactly.</li>
</ul>
<p>
Microsoft Jet 3.5 includes a new security permission, Administrator, for a database object. By default, this permission is granted to the Users and Admins groups, as well as to the user logged on when a new database is created or converted from an earlier version of Microsoft Access. It is up to the application developer to restrict this permission to selected users if security is to be enforced.</p>
<p>
A user with Administrator permission can do the following in the Design Master: 
<ul>
<li>
Convert a nonreplicable database into a replicable database.<br><br></li>
<li>
Execute the <b>Move Replica</b> command for the Design Master.<br><br></li>
<li>
Make a local object replicable, or make a replicable object local.<br><br></li>
<li>
Modify the retention period.</li>
</ul>
<p>
In addition, a user with Administrator permission can execute the <b>Recover Design Master</b> command from any replica.</p>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;Make sure there is always at least one user with Administrator permission on the database. If the Design Master and the associated System.mdw file are destroyed (for example, through a hard disk failure), it is possible to designate another replica as the new Design Master&#45;but only a user with Administrator permission can do this.</p>
<h2>Registry Entries</h2>
<p>
Parameters for Microsoft Jet 3.5/Microsoft Access 97 replication components are stored in the system registry. In addition to the entries listed here, the registry includes many minor entries for the Synchronizer, such as the log file location, the last viewed replica, the security database, and so on, under the following key:</p>
<pre><FONT FACE="Courier New" SIZE="2">HKEY_LOCAL_MACHINE\Software\Microsoft\Jet\3.5\Transporter
</font></pre>
<p>
<b>Briefcase Reconciler</b></p>
<pre><FONT FACE="Courier New" SIZE="2">HKEY_CLASSES_ROOT\CLSID\{ClassID of Access.Database.8} \Roles\Reconciler = {DB5B8C90-7B62-11CF-A9E4-00AA00B676FC}
HKEY_CLASSES_ROOT\CLSID\{ClassID of Access.Database.8} \Roles\NotifyReplica = {DB5B8C90-7B62-11CF-A9E4-00AA00B676FC}
HKEY_CLASSES_ROOT\CLSID\{DB5B8C90-7B62-11CF-A9E4-00AA00B676FC}
&#09;\InProcServer32 = &quot;full path of msRCLR35.dll&quot;
&#09;\ResourceDll = &quot;full path of msRECR35.dll&quot;
&#09;\SystemDb = &quot;full path of system.mdw&quot;
&#09;\ThreadingModel = &quot;Apartment&quot;
HKEY_CLASSES_ROOT\CLSID\{ DB5B8C90-7B62-11CF-A9E4-00AA00B676FC} \SingleChangeHook
</font></pre>
<p>
<b>Replication Manager Registry Entry</b></p>
<pre><FONT FACE="Courier New" SIZE="2">HKEY_LOCAL_MACHINE\Software\Microsoft\Jet\3.5\Replication Manager
&#09;&quot;Path&quot; <i>path to Replman.exe
</i></font></pre>
<p>
<b>Synchronizer Registry Entry</b></p>
<pre><FONT FACE="Courier New" SIZE="2">HKEY_LOCAL_MACHINE\Software\Microsoft\Jet\3.5\Replication Manager\3.5
&#09;&quot;SynchronizerPath&quot; path to mstran35.exe
</font></pre>
<h2>For More Information</h2>
<p>
Here is a list of publications you can refer to if you want more information about database replication, the Microsoft Jet database engine, or using replication in Microsoft products.
<ul>
<li>
<i>Microsoft Jet Database Engine Programmer's Guide, </i>Microsoft Press. 1995 ISBN 1-55615-877-7. A detailed analysis of the Microsoft Jet database engine, including extensive information on Microsoft Jet replication.<br><br></li>
<li>
<i>Building Applications with Microsoft Access 97</i>, a thorough guide to creating and distributing Microsoft Access applications. </li>
</ul>
<h2>Glossary</h2>
<p>
<b>Bidirectional exchange</b>&#45;An exchange between two replicas, in which both replicas send and receive updates.</p>
<p>
<b>Cascade update/cascade delete</b>&#45;Referential integrity options which specify that changes or deletions to the primary key in one table will be propagated to any other tables that reference that primary key value.</p>
<p>
<b>Conflict</b>&#45;An attempt by two replicas to simultaneously update the same row in a table. One replica &quot;wins&quot; the conflict and its value is propagated to the rest of the replica set. The losing replica is notified that it lost and is offered the chance to resubmit its update.</p>
<p>
<b>Data Access Objects (DAO)</b>&#45;The programming language-independent object-based data access language used to manipulate Microsoft Jet engine data.</p>
<p>
<b>Database engine</b>&#45;A program, or part of a program, that serves as the link between a database management system (DBMS) or application and the data. Specifically, the part of a DBMS program that reads and writes data records.</p>
<p>
<b>Design Master</b>&#45;The single member of a replica set in which schema changes may be made for propagation around the whole replica set.</p>
<p>
<b>Error</b>&#45;In some situations an update received from one replica causes an error in the receiving replica (for example, it violates a unique key rule, or a TLV rule).  In these cases, an error is registered and the user must manually correct the error.</p>
<p>
<b>Exchange</b>&#45;The process of sending schema and data updates between replicas.</p>
<p>
<b>Foreign key</b>&#45;A reference to the primary key in another table.</p>
<p>
<b>Generation</b>&#45;A counter, specific to each replica, which is incremented each time an exchange occurs with any other replica.</p>
<p>
<b>Global object</b>&#45;An object that is replicated around the replica set.  Global objects can only be created in the Design Master.</p>
<p>
<b>GUID</b>&#45;Globally unique identifier. A primary key in a database that is always guaranteed to be unique. Also known as a UUID (universal unique identifier). </p>
<p>
<b>Lineage</b>&#45;A record of each nickname/generation pair.  Used to optimize exchanges between replicas and resolve conflicts.</p>
<p>
<b>Local object</b>&#45;An object that is not replicated around the replica set. A local object can be created in any replica.</p>
<p>
<b>Method</b>&#45;An action that can be applied to an object. For example, to move to the first row of a recordset, you apply the <b>MoveFirst</b> method to the <b>Recordset</b> object.</p>
<p>
<b>Multi-master</b>&#45;The ability to modify any data at any replica.</p>
<p>
<b>Nickname</b>&#45;A shortened name for of the ReplicaID GUID, used in the lineage.</p>
<p>
<b>OLE</b>&#45;A standard method of linking and embedding objects created by one program to another program. Also, a type of field in Microsoft Jet used to store complex objects created by other programs.</p>
<p>
<b>Objects</b>&#45;A package of things created and manipulated by programs. In Microsoft Jet, Tables, Users and Query Definitions are all examples of objects.</p>
<p>
<b>Open database connectivity (ODBC)</b>&#45;A standard way to connect to and read and write records from other databases, usually server databases.</p>
<p>
<b>Primary key</b>&#45;A column (or multiple columns) in a table that ensures that a record can be uniquely identified.</p>
<p>
<b>Property</b>&#45;An attribute of an object that can be retrieved and (sometimes) set. For example, the <b>Index </b>property of a table can be set to the name of one or more columns in the table.</p>
<p>
<b>Pull exchange</b>&#45;An exchange between two replicas where one replica only receives, or pulls, update from the other replica.</p>
<p>
<b>Push exchange</b>&#45;An exchange between two replicas where one replica only sends, or pushes, its update to the other replica.</p>
<p>
<b>Read-only replica</b>&#45;A replica that is not permitted to update either data or the schema.</p>
<p>
<b>Referential integrity</b>&#45;A relational database rule that requires that all foreign key values reference valid primary key values.</p>
<p>
<b>Replica</b>&#45;A special copy of a database that is created in such a way to allow changes made in the replica to be exchanged at a later time with other replicas in a replica set, eventually bringing all the replicas in the replica set into a consistent state.</p>
<p>
<b>Replication</b>&#45;The process of creating special copies of a database, where the copies have a special relationship to each other.</p>
<p>
<b>Replica ID</b>&#45;A GUID that uniquely identifies a replica.</p>
<p>
<b>Replica set</b>&#45;Replicas that share a common heritage and are able to synchronize their data and schema.  Replicas can synchronize only with other replicas in the same set.</p>
<p>
<b>Retention period</b>&#45;The amount of time, measured in days, that a replica set retains details of deleted records, schema changes, and other system-specific information. This value can be modified only by opening the Design Master in Microsoft Replication Manager and changing the value.</p>
<p>
<b>Synchronization</b>&#45;The process of bringing two replicas into a consistent state.</p>
<p>
<b>Transaction</b>&#45;A sequence of actions that must occur as a single unit.</p>
<p>
<b>Transaction processing</b>&#45;A mode of database processing that supports the creation, and saving (<b>CommitTrans</b>) or undoing (<b>Rollback</b>) of transactions.</p>
<p>
<b>Two-phase commit protocol</b>&#45;A system used in some distributed databases systems whereby each database either agrees to or rejects a proposed change, and only if every database in the system agrees is the change actually made.</p>
<p>
<b>Validation rule</b>&#45;An expression that can be linked to a change of data so that it is always evaluated when a certain type of data modification is made.</p>
<p>
&copy; 1997 Microsoft Corporation. All rights reserved.</p>
<p>
The information contained in this document represents the current view of Microsoft Corporation on the issues discussed as of the date of publication. Because Microsoft must respond to changing market conditions, it should not be interpreted to be a commitment on the part of Microsoft, and Microsoft cannot guarantee the accuracy of any information presented after the date of publication.</p>
<p>
This document is for informational purposes only. MICROSOFT MAKES NO WARRANTIES, EXPRESS OR IMPLIED, IN THIS SUMMARY.</p>
<p>
Microsoft, Visual Basic, Windows 95, Windows NT, and Visual C++ are registered trademarks of Microsoft Corporation.</p>
<p>
Intel is a registered trademark of Intel Corporation.  Novell and NetWare are registered trademarks of Novell, Inc.</p>
<p>
Other product or company names mentioned herein may be the trademarks of their respective owners.</p>
</font></BODY>
</HTML>
