<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Winsock2 Generic QOS Mapping</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>



	<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>



	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<h1>Winsock2 Generic QOS Mapping </h1>
<p>
<i>Version 2.6</i></p>
<p>
Presented by:&#09;Yoram Bernet, Jim Stewart, Raj Yavatkar, Dave Andersen, Charlie Tai<BR>Microsoft Windows Networking Group</p>
<h2>1&#09;Overview</h2>
<p>
This document discusses the mapping of the existing Winsock2 QoS-related application programming interfaces (APIs) to underlying QoS-enabled service providers. Two underlying QoS service providers are under consideration. These are the RSVP service provider (RSVP SP) and the Traffic Control service provider (TCSP). This document addresses the RSVP SP.</p>
<p>
The RSVP SP provides a resource reservation protocol which negotiates with a network to satisfy QoS requests from applications. The RSVP SP also configures kernel traffic control components in compliance with the QoS negotiated with the network.</p>
<p>
The TCSP allows applications to configure kernel traffic control components directly, with no resource reservation protocol involved. The TCSP will be discussed in a separate document.</p>
<h2>2&#09;Generic QoS vs. Annexes</h2>
<p>
This document addresses the generic<i> </i>QoS interfaces to the RSVP SP. These are standard Winsock2 API calls, which carry QoS related parameters, in a general form. There are also specific API sets defined for the RSVP SP and for the TCSP. From here on, the standard Winsock2 QoS APIs are referred to as the generic QoS (GQoS) APIs, and the specific API sets as annexes. </p>
<p>
It is expected that the majority of applications requiring QoS support will be modified to use GQoS. Designing applications to this interface has the benefit of enabling the application to invoke QoS from any QoS service provider transparently, whereas the annexes are specific to particular QoS service providers.</p>
<p>
The annexes provide interfaces by which applications can exercise close control over specific features of a particular QoS service provider. The annexes also enable third-party applications. These applications that request QoS on behalf of another application that is not QoS-aware.</p>
<p>
The QoS service providers support both the GQoS interfaces and the annex interfaces specific to the provider. However, any single application is expected to invoke the service provider’s functionality through one set of interfaces or the other.</p>
<h2>3&#09;General Strategy for Mapping GQoS to RSVP</h2>
<p>
In mapping GQoS to RSVP, this paper reviews the required RSVP functionality and parameters and then shows how Winsock2 GQoS calls can be used to invoke this functionality and provide the required parameters.</p>
<h3>3.1&#09;RSVP Functionality </h3>
<p>
In simple terms, relevant RSVP functionality on a host amounts to the exchange of <i>PATH </i>and <i>RESV </i>messages with the network. </p>
<p>
An application intending to transmit traffic with a certain QoS must indicate so to RSVP. In turn, RSVP will respond by beginning the periodic transmission of <i>PATH </i>messages on the network. <i>PATH </i>messages describe the QoS parameters of the traffic to be sent (<i>Tspec</i>), the sender’s address (<i>SenderTemplate</i>) and the destination of the traffic (<i>session</i>).</p>
<p>
An application wishing to receive traffic with a certain QoS must indicate so to RSVP. In turn, RSVP should respond by beginning the periodic transmission of <i>RESV </i>messages on the network. <i>RESV </i>messages describe the QoS parameters of the traffic to be received (<i>flowspec</i>), the source(s) from which QoS traffic is to be received (<i>filterspec</i>), and the destination of the traffic (<i>session</i>).</p>
<h3>3.2&#09;Using Winsock2 APIs to Invoke RSVP Functionality</h3>
<p>
The key to mapping Winsock2 calls to RSVP is to determine when to trigger the transmission of <i>PATH </i>and/or <i>RESV </i>messages by the RSVP SP, and when to stop their transmission. In general, the transmission of these messages should begin at the time that the RSVP SP has determined the application intends to invoke QoS in a specific direction (sending or receiving) and<i> </i>all information required for the generation of the messages is available.</p>
<p>
<b>3.2.1&#09;QoS Related Calls</b></p>
<p>
The following Winsock2 calls provide a mechanism by which applications can specify QoS parameters of sent and received traffic. These parameters are specified in the <i>SendingFlowspec </i>and <i>ReceivingFlowspec </i>structures (within the QoS<i> </i>structure) that may be included with these calls:
<ul>
<li>
WSAConnect<br><br></li>
<li>
WSAJoinLeaf<br><br></li>
<li>
The condition function callback (<i>lpfnCondition</i>) to WSAAccept<br><br></li>
<li>
WSAIoctl (<i>SIO_SET_QOS, SIO_GET_QOS</i>)</li>
</ul>
<p>
<b>3.2.2&#09;Implicit Invocation of QoS</b></p>
<p>
The RSVP SP assumes that an application that includes a non-NULL pointer to a QoS<i> </i>structure with any of the previous calls is implicitly invoking QoS functionality. The QoS structure includes a <i>SendingFlowspec </i>and a <i>ReceivingFlowspec.</i> Within each <i>flowspec</i> there is a <i>ServiceType </i>field. QoS functionality will be invoked if the <i>ServiceType </i>field in the corresponding direction specifies a value other than <i>SERVICETYPE_BESTEFFORT </i>or <i>SERVICETYPE_NOTRAFFIC</i>. The specification of either of these values in one of the <i>flowspecs </i>will suppress QoS functionality in the corresponding direction. </p>
<p>
Each of the QoS related calls specify a particular socket to which the call applies. Thus, QoS is invoked relative to a particular socket. A socket on which QoS has been invoked is said to be a QoS socket.</p>
<p>
<b>3.2.3&#09;Information Required to Generate <i>PATH </i>and <i>RESV </i>Messages</b></p>
<p>
The following information is required to begin the transmission of <i>PATH </i>messages:</p>
<table>
<tr valign=top>
<td>
<b>RSVP Parameter</b></td>
<td>
<b>Derived from the following Winsock parameter</b></td>
</tr>
<tr valign=top>
<td>
Sender <i>Tspec </i>(QoS parameters of sent traffic)</td>
<td>
<i>SendingFlowspec</i></td>
</tr>
<tr valign=top>
<td>
<i>SenderTemplate </i>(sender’s address)</td>
<td>
Source IP address and port that sending socket is bound to</td>
</tr>
<tr valign=top>
<td>
<i>Session </i>(destination of sent traffic)</td>
<td>
Destination IP address, port, and protocol ID that socket is sending to (sockaddr_in)<p>
[Note that the RSVP <i>session </i>includes specification of the protocol ID (e.g., UDP, TCP). The protocol ID is determined by the type of socket for which QoS is being invoked. In the remainder of this document, protocol ID is not discussed.]</p>
</td>
</tr>
</table><br>
<p>
The following information is required to begin the transmission of <i>RESV </i>messages:</p>
<table>
<tr valign=top>
<td>
<b>RSVP Parameter</b></td>
<td>
<b>Derived from the following Winsock parameter</b></td>
</tr>
<tr valign=top>
<td>
<i>Flowspec</i> (QoS parameters of traffic to be received)</td>
<td>
<i>ReceivingFlowspec</i></td>
</tr>
<tr valign=top>
<td>
<i>Filterspec</i> (source(s) from which QoS traffic will be received)<p>
[Strictly speaking, <i>RESV </i>messages can be generated without knowledge of the sender’s address. These type of <i>RESV </i>messages are said to be WF style, meaning that they apply to all senders to the <i>session</i>.]</p>
</td>
<td>
Address(es) of peer(s) from which the socket is receiving</td>
</tr>
<tr valign=top>
<td>
<i>Session </i>(destination of sent traffic)</td>
<td>
Local IP address and port to which the receiving socket is bound (unicast), or multicast <i>session</i> address on which the socket is a leaf (multicast)</td>
</tr>
</table><br>
<p>
<b>3.2.4&#09;Triggering the Transmission of <i>PATH </i>and <i>RESV </i>Messages</b></p>
<p>
Upon being called through any of the QoS related calls listed above (with a <i>SendingFlowspec </i>and/or a <i>ReceivingFlowspec</i>), the RSVP SP can assume that the application is invoking QoS and obtains at least the QoS parameters describing the traffic to be sent and/or received. Depending on the state of the relevant QoS socket at the time the call is invoked, the RSVP SP may or may not have the additional parameters describing the source(s) and destination(s) of the QoS traffic. </p>
<p>
In general, the address of the local host (the source address in the case that the application resides on the sending host, or the destination address in the case that the application resides on the receiving host) is available only after the socket has been bound by use of the Winsock2 <b>bind </b>call. Alternatively, the socket may be bound implicitly as a result of a call to <b>WSAConnect </b>or <b>WSAJoinLeaf</b>. See the subsequent section on binding.</p>
<p>
In general, the address of the peer (the source address in the case that the application resides on the receiving host, or the destination address in the case that the application resides on the sending host) is available following one of the connection-oriented calls (<b>WSAConnect</b>, <b>WSAJoinLeaf</b>, and <b>WSAAccept</b>), but not necessarily following the <b>WSAIoctl </b>call. </p>
<p>
Consequently, the RSVP SP typically begins sending <i>PATH </i>and/or <i>RESV </i>messages only after an application has called one of the connection-oriented calls, and the socket is unambiguously bound to a local address. However, there are cases in which the RSVP SP can begin sending <i>PATH </i>and/or <i>RESV </i>messages, even in the absence of one of the connection-oriented calls described. Subsequent sections discuss this sequence of events as it occurs in different cases, and the requirements imposed on applications.</p>
<h3>3.3&#09;Responses/Notifications From RSVP to Applications</h3>
<p>
RSVP will provide the following indications to applications using the GQoS interface:
<ul>
<li>
Information regarding the acceptance or rejection of the application’s QoS requests by the RSVP module or by the network. Note that rejection of a QoS request may indicate a transient failure, which will be corrected at a later time.<br><br></li>
<li>
Significant changes in the QoS provided by the network (as compared to a previously negotiated QoS).<br><br></li>
<li>
Status regarding the preparedness of a QoS peer to send or receive a particular QoS traffic flow.</li>
</ul>
<p>
These indications are mediated through status returned to Winsock2 calls, or through FD_QOS asynchronous event notifications.</p>
<h2>4&#09;General Concepts</h2>
<p>
Before delving into the detailed mapping of GQoS to RSVP, it is helpful to introduce some general concepts.</p>
<p>
<b>4.1.1&#09;RSVP as a Service Provider </b></p>
<p>
RSVP functionality is implemented in a Winsock2 service provider. It may be implemented as part of a base service provider or as a layered service provider which is layered over a base service provider. In either case, it intercepts and acts upon Winsock API calls from an application to a transport service provider. Throughout this document, the RSVP service provider (RSVP SP) is recognized as being an integral part of a base transport service provider. </p>
<p>
An application may use the GQoS interface to the RSVP SP to invoke QoS on its own behalf. Alternatively, third-party applications may invoke QoS on behalf of another application’s traffic flows, by using the RSVP annex interface. In this case, the third-party application will have to learn the addresses and ports used by the application for which it is invoking QoS. It is assumed that some out of band method is used for doing so, or that these are known a-priori.</p>
<p>
<b>4.1.2&#09;Binding</b></p>
<p>
In general, RSVP identifies packets associated with a particular traffic flow, by the source and destination IP addresses and ports included in the packets. Consequently, it is necessary for RSVP to learn the local and remote addresses and port numbers associated with each QoS socket. The local address and port associated with a socket are defined by either implicit or explicit binding<i> </i>of the socket. These are used by RSVP to compose the <i>SenderTemplate </i>on a sender, and the <i>session </i>on a receiver (for receiving sockets, the <i>session </i>indicated in <i>RESV </i>messages is determined by matching <i>PATH </i>state with local address and port parameters&#45;see the section titled <i>Sending RESV Messages Based on Matching PATH State</i>).</p>
<p>
Applications typically invoke the Winsock <b>bind </b>call to explicitly associate a local address and port with a socket. In general, an application may call <b>bind </b>without explicitly specifying an IP address or port or, in certain cases, may not call <b>bind </b>at all. When a socket is not explicitly bound by an application, the underlying transport service provider will automatically bind the socket to a specific port. The RSVP SP (and applications using RSVP), can readily determine the port bound, by issuing a <b>getsockname </b>call to the underlying transport service provider. </p>
<p>
For Transmission Control Protocol (TCP) sockets, the local address to which the socket is bound can also be unambiguously determined using <b>getsockname</b>. However, in the case of UDP sockets, certain implementations of the transport service provider reserve the right to change the sending interface (and the address included in the source address field of sent packet headers), based on routing information. Because of this, calls to <b>getsockname </b>on UDP sockets are not guaranteed to return a bound address. </p>
<p>
This presents a problem, primarily in the case of sending sockets, for which RSVP is required to compose a <i>SenderTemplate </i>object that matches the source address and interface on which the socket’s QoS data is transmitted. To address this problem, applications using the GQoS interfaces to the RSVP SP may use one of the approaches described later. Note that these approaches apply both in the case of unicast and multicast RSVP <i>sessions</i>. Also note that these are used for UDP sockets only. For TCP sockets, the RSVP SP can call <b>getsockname </b>to determine the local bound address.</p>
<p>
<i>4.1.2.1&#09;</i>Binding Using <i>INADDR_ANY</i></p>
<p>
The application may bind using <i>INADDR_ANY. </i>In this case, the RSVP SP will use the interface query Ioctl, <b>WSAIoctl</b>(<i>SIO_LOCAL_INTERFACE_QUERY</i>), to determine which source address to use when composing the <i>SenderTemplate. </i>To do so, the RSVP SP waits until the application calls <b>WSAConnect</b> or <b>WSAJoinLeaf</b>. At that time, the RSVP SP issues the interface query Ioctl, providing the peer address specified in the connection-oriented call. The RSVP SP composes the <i>SenderTemplate </i>based on the address returned in response, from the underlying transport service provider. The RSVP SP registers for routing change notifications through the <i>FD_ROUTING_CHANGE </i>event, or by calling <b>WSAIoctl</b>(<i>SIO_LOCAL_INTERFACE_CHANGE</i>). This ensures that it will be notified in the case of routing changes and is able to modify the <i>SenderTemplate </i>accordingly. </p>
<p>
In this mode, the application remains unaware of the sending interface used and of routing changes. Calls to <b>getsockname </b>are not guaranteed to return a valid address. In addition, the address included in the source address field of transmitted packets, is subject to change as a result of routing changes. Although the RSVP SP will respond by correcting the <i>SenderTemplate </i>in transmitted <i>PATH </i>messages, the application will receive no indication of the change.</p>
<p>
4.1.2.2&#09;Binding a Specific Address Based on an Interface Query</p>
<p>
For details regarding the usage of the interface query Ioctl and the associated change notification mechanisms, see the subsequent section in this document and/or the references in the <i>Windows Sockets 2 Application Programming Interface </i>(revision 2.2.1).</p>
<p>
In this case, the application assumes full responsibility for binding to a specific address. The application may use the interface query Ioctl to determine the address to which it should bind, based on the destination address to which it will be sending. Once it has determined the correct address to bind, it issues a <b>bind </b>call, specifying the address. The RSVP SP will either monitor <b>bind </b>calls issued by the application, or issue <b>getsockname </b>calls to the underlying transport service provider, to determine the address to be used in the <i>SenderTemplate</i>. </p>
<p>
For resilience in the unlikely event of a routing change, applications using this method on multihomed hosts, may register for routing change notifications through the <i>FD_ROUTING_CHANGE </i>event or by calling <b>WSAIoctl</b>(<i>SIO_LOCAL_INTERFACE_CHANGE</i>). Note that when an application binds explicitly, route changes will result in data being sent from a new interface, but will not cause a change in the source address used in datagram headers. Since the source address will not change, the <i>SenderTemplate </i>is not required to change. Therefore, strictly speaking, applications are not required to react to routing changes. There may be an intermittent disruption in RSVP service, however, due to the soft state maintained by RSVP, the network will eventually respond to the routing change, transparently. </p>
<p>
By binding to specific addresses and tracking routing changes, the application can be fully aware of the sending interface used at any time. </p>
<p>
4.1.2.3&#09;No Bind by Application</p>
<p>
An application does not have to bind a socket at all. This case is handled by the RSVP SP, as a variation on the case of a bind using <i>INADDR_ANY. </i>From the perspective of <i>PATH</i> message generation, the cases are identical. The RSVP SP issues the interface query ioctl (following one of the connection-oriented calls) and monitors routing changes to maintain the correct <i>SenderTemplate.</i> From the perspective of <i>RESV </i>message generation, unbound sockets provide no criteria by which the RSVP SP can search for matching <i>PATH </i>state. Consequently, no <i>RESV </i>messages will be sent on behalf of these sockets until they are bound, either explicitly by the application or implicitly by the transport provider, following one of the connection-oriented calls listed above. </p>
<p>
Note that per standard Winsock protocol, applications calling <b>WSAAccept </b>must call <b>bind </b>first.</p>
<p>
<b>4.1.3&#09;WSAIoctl(<i>SIO_LOCAL_INTERFACE_QUERY</i>) and Change Notifications</b></p>
<p>
The interface query ioctl takes a unicast or multicast destination address as input. It returns the address of the interface which will be used by the transport provider, to send packets to the receiving peer. </p>
<p>
The ioctl is guaranteed to return the correct interface for both unicast and multicast addresses. The interface returned in response to unicast queries is based on routing information. Routing information is not necessarily available for multicast addresses. Therefore, while the interface returned in response to multicast queries is the interface that will be used, this interface may have been chosen arbitrarily. Applications that require control over the choice of multicast interface used should explicitly set the multicast interface by calling <b>setsockopt</b>(<i>IP_MULTICAST_IF</i>).</p>
<p>
Note that, on hosts acting as multicast gateways, an interface query on a multicast address may return a list of interfaces. QoS applications of the type described here are not expected to run directly on multicast gateways.</p>
<p>
<b>4.1.4&#09;Port Number Negotiation</b></p>
<p>
It is assumed that there is some application specific mechanism to allow peers to negotiate port numbers (or that they are implied by the application, such as in the case of FTP). Methods for negotiation of port numbers is beyond the scope of this document. </p>
<p>
<b>4.1.5&#09;WSAIoctl (<i>SIO_SET_QOS</i>)</b></p>
<p>
This call can be invoked by an application at any time to change or initialize the QoS parameters on a socket. The RSVP SP will respond differently depending on the state of the socket. The use of <b>WSAIoctl</b>(<i>SIO_SET_QOS</i>) will be discussed in subsequent sections.</p>
<p>
<b>4.1.6&#09;Sending <i>RESV </i>Messages Based on Matching PATH State</b></p>
<p>
When a <i>PATH </i>message is received, the RSVP SP creates an RSVP <i>session</i> and associates <i>PATH </i>state with it. The RSVP SP will also create a <i>session</i> (in the absence of <i>PATH </i>messages) when QoS is indicated on any receive socket. (However, in this case <i>PATH </i>state is not associated with the <i>session </i>until a corresponding <i>PATH </i>message is received.) </p>
<p>
The RSVP SP will generally send <i>RESV </i>messages when it determines that <i>PATH </i>state exists for a <i>session </i>matching a socket for which receiving QoS is indicated. As a result, the transmission of <i>RESV </i>messages may be triggered either by the receipt of a <i>PATH </i>message (which matches the <i>session</i> associated with a preexisting socket), or by the creation of a socket (which matches the <i>session</i> associated with preexisting <i>PATH </i>state). The following rules are used to determine whether a match exists between <i>session</i>s with associated <i>PATH </i>state and sockets for which receiving QoS is indicated.</p>
<p>
4.1.6.1&#09;TCP Sessions</p>
<p>
In this case, matches are readily determined. TCP sockets, once they are connected, are associated with specific source and destination addresses and ports. </p>
<table>
<tr valign=top>
<td>
<b>TCP sockets</b></td>
<td>
<b>Will match</b></td>
</tr>
<tr valign=top>
<td>
Not bound, or bound and not connected (WSAConnect not issued)</td>
<td>
Never</td>
</tr>
<tr valign=top>
<td>
Bound and connected </td>
<td>
If port and address specified in any <i>session </i>matches the socket’s bound port and address <i>and SenderTemplate</i> (specified in <i>PATH </i>state associated with the <i>session</i>) matches connected peer’s port and address</td>
</tr>
</table><br>
<p>
4.1.6.2&#09;UDP Sessions</p>
<p>
UDP <i>sessions</i> are subject to less stringent matching rules, since it is not always possible to determine unique addresses associated with a UDP socket.  The rules are tabulated separately for unicast vs. multicast.</p>
<table>
<tr valign=top>
<td>
<b>Unicast UDP Sockets:</b></td>
<td>
<b>will match:</b></td>
</tr>
<tr valign=top>
<td>
Not bound and not connected.</td>
<td>
Never.</td>
</tr>
<tr valign=top>
<td>
Bound using <i>INADDR_ANY, </i>and not connected (WSAConnect not issued).</td>
<td>
If port specified in any <i>session</i> matches the socket’s bound port.</td>
</tr>
<tr valign=top>
<td>
Bound using a specific address and not connected. </td>
<td>
If port and address specified in any <i>session </i>matches the socket’s bound port and address.</td>
</tr>
<tr valign=top>
<td>
Bound using <i>INADDR_ANY</i>, and connected.</td>
<td>
If port specified in any <i>session </i>matches the socket’s bound port <i>and</i> <i>SenderTemplate </i>(specified in <i>PATH </i>state associated with the <i>session</i>) matches the connected peer’s port and address.</td>
</tr>
<tr valign=top>
<td>
Bound using a specific address and connected.</td>
<td>
If port and address specified in any <i>session</i> matches the socket’s bound port and address and <i>SenderTemplate </i>(specified in <i>PATH </i>state associated with the <i>session</i>) matches the connected peer’s port and address.</td>
</tr>
</table><br>
<p>
In the case of multicast sockets, the application is expected to create the socket using <b>WSASocket</b>, setting the appropriate flags to indicate that it is a multicast sender (or receiver). Otherwise, the RSVP SP may be unable to determine that the socket is multicast and may send undesired <i>RESV </i>messages based on the unicast matching rules described above.</p>
<table>
<tr valign=top>
<td>
Multicast UDP sockets</td>
<td>
Will match</td>
</tr>
<tr valign=top>
<td>
Not joined to a specific multicast group (WSAJoinLeaf not issued).</td>
<td>
Never.</td>
</tr>
<tr valign=top>
<td>
Joined to a specific multicast group (using WSAJoinLeaf).</td>
<td>
If multicast port and address specified in any <i>session </i>matches the multicast port and address specified in the WSAJoinLeaf call.</td>
</tr>
</table><br>
<p>
<b>4.1.7&#09;QoS for Transmitted Data Contingent on RESV</b></p>
<p>
The RSVP SP typically will not activate traffic control on behalf of a sending application’s flow unless there is <i>RESV </i>state for the flow (<i>RESV </i>messages are arriving). Until such time, sent traffic will be treated by the local network components and by the network at large, as best-effort traffic. Senders may register for notification that <i>RESV </i>state has been established, by using <b>WSAEventSelect </b>(<i>FD_QOS</i>). </p>
<p>
In general, the default behavior of any QoS service provider, is to delay activation of traffic control until there is an indication from the network that there exists at least one listener. Applications may override this behavior by setting the <i>SERVICE_IMMEDIATE_TRAFFIC_CONTROL </i>bit in the <i>ServiceType </i>parameter of the <i>SendingFlowspec</i>.  This will cause the QoS service provider to immediately invoke sending traffic control per the parameters in the <i>SendingFlowspec</i>. </p>
<p>
<b>4.1.8&#09;GQoS and IP</b></p>
<p>
Although RSVP and GQoS are supposed to be protocol independent, the reality is that they assume the IP protocol. Nonetheless, efforts were made to assure that the GQoS specification is as independent of a specific protocol as practically realizable.</p>
<p>
<b>4.1.9&#09;Use of </b>WSAJoinLeaf<b> and </b>sendto <b>for Multicast <i>Sessions</i></b></p>
<p>
To invoke QoS service, applications are required to use the <b>WSAJoinLeaf </b>call both to send and receive multicast traffic. Alternate multicast semantics, such as simply calling <b>sendto</b> with a multicast address (for transmit) or using <i>IP_ADD_MEMBERSHIP</i> (for receive), will not invoke QoS service.</p>
<p>
Applications are required to set the <i>dwFlags </i>parameter to <i>JL_SENDER_ONLY, JL_RECEIVER_ONLY </i>or <i>JL_BOTH</i>, to indicate the direction in which QoS service is requested.</p>
<p>
Note that senders that have joined multicast <i>sessions</i> using <b>WSAJoinLeaf </b>are required to call <b>sendto</b> or <b>WSASendTo </b>with the correct multicast <i>session</i> address to send data to the multicast <i>session</i> (even though the multicast <i>session</i> address was already provided with the call to <b>WSAJoinLeaf</b>). The RSVP SP on a sender, generates the <i>SenderTemplate </i>based on the multicast <i>session</i> address specified in the call to <b>WSAJoinLeaf</b>. Therefore, if the sending application calls <b>sendto </b>or <b>WSASendTo </b>specifying a multicast <i>session</i> address other than the one specified with the <b>WSAJoinLeaf</b>, it will not receive QoS service for the data sent.</p>
<p>
Also, note that the only<i> </i>case in which a QoS application should call <b>sendto </b>or <b>WSASendTo</b>, is the case of a multicast sender. For unicast UDP or TCP senders, the destination address must be specified using <b>WSAConnect </b>and it is sufficient for the application to call <b>send</b> or <b>WSASend</b>, rather than <b>sendto</b> or <b>WSASendTo</b>.</p>
<h2>5&#09;Detailed Mapping of GQoS to RSVP&#45;Call Sequences</h2>
<p>
Applications must issue a sequence of QoS-related calls to invoke QoS functionality from the RSVP SP. The sequence may vary depending on the type of communication (such as UDP versus TCP and unicast versus multicast) and on the specific application. This section discusses these call sequences. For a list of sample call sequences, see <i>Appendix A&#45;Sample Call Sequences.</i></p>
<p>
For the sake of simplicity, the following section covers sending applications separately from receiving applications. Applications are classified as sending or receiving, based on their QoS requirements. Most applications do not exclusively send or receive, however&#45;many applications may be interested in QoS <i>service</i> only for traffic sent or only for traffic received.  This is the case for playback applications, such as video and audio servers, in which the server sends QoS traffic and the receiver receives QoS traffic. For other types of applications, such as conferencing, the application may be interested in QoS service for both traffic sent and traffic received. In this case, the sequences described below can be combined.</p>
<h3>5.1&#09;Sending Applications</h3>
<p>
Sending applications must provide the RSVP SP with the following information to invoke RSVP processing:
<ul>
<li>
Peer (destination) address, for the composition of RSVP <i>session</i> objects.<br><br></li>
<li>
Local (source) address, for the composition of the RSVP <i>SenderTemplate </i>objects.<br><br></li>
<li>
QoS parameters, in a <i>SendingFlowspec</i>, for the generation of <i>Tspec</i> objects.</li>
</ul>
<p>
Once this information is available to the RSVP SP, it begins to transmit RSVP <i>PATH </i>messages on behalf of the application.</p>
<p>
The following table summarizes how the RSVP SP obtains the information for <i>session </i>and <i>SenderTemplate</i> for various cases of sending applications.</p>
<table>
<tr valign=top>
<td>
<b>Case</b></td>
<td>
<b>Session</b></td>
<td>
<b>SenderTemplate</b></td>
</tr>
<tr valign=top>
<td>
UDP unicast sender</td>
<td>
Destination address and port specified in WSAConnect <i>name </i>field.</td>
<td>
<font face="Symbol"><span style="font-family:symbol">&#183;</span></font>&#09;Local port determined by RSVP SP call to getsockname.<p>
<font face="Symbol"><span style="font-family:symbol">&#183;</span></font>&#09;For sockets bound explicitly by the application, to a specific address, the RSVP SP calls getsockname to get the local address.</p>
<p>
<font face="Symbol"><span style="font-family:symbol">&#183;</span></font>&#09;For sockets bound by the application to <i>INADDR_ANY</i>, the RSVP SP gets the local address by issuing an interface query on the destination address (as obtained from the application’s call to WSAConnect or WSAJoinLeaf).</p>
</td>
</tr>
<tr valign=top>
<td>
UDP multicast sender</td>
<td>
Multicast IP address and port as specified in WSAJoinLeaf <i>name</i> field.</td>
<td>
</td>
</tr>
<tr valign=top>
<td>
TCP unicast sender </td>
<td>
Peer (destination) address and port as determined by call to getpeername following connection establishment.</td>
<td>
Local address and local port determined by call to getsockname following connection establishment.</td>
</tr>
</table><br>
<p>
The RSVP SP obtains QoS parameters from a <i>SendingFlowspec</i> which is included either in the application’s call to <b>WSAConnect </b>or <b>WSAJoinLeaf</b>, or provided separately in a call to <b>WSAIoctl</b>(<i>SIO_SET_QOS</i>).</p>
<p>
<b>5.1.1&#09;Unicast UDP Senders</b></p>
<p>
Unicast UDP senders will typically call <b>WSAConnect </b>to invoke RSVP functionality. This call provides the peer address to the RSVP SP and may also provide QoS parameters. The RSVP SP uses the address passed to directly generate the <i>session </i>object included in <i>PATH </i>messages. For sockets that have been bound using <i>INADDR_ANY</i>, the RSVP SP uses the peer address to determine the local address to be used in the <i>SenderTemplate </i>object. It does so by issuing an interface query to the underlying transport service provider. This returns the address of the local interface, which should be used to reach the peer specified. </p>
<p>
Typically, the call to <b>WSAConnect </b>will include sending QoS parameters. However, the sending application may use the <b>WSAIoctl</b>(<i>SIO_SET_QOS</i>) to provide the sending QoS parameters to the RSVP SP before or after the call to <b>WSAConnect</b>. In all cases, RSVP processing will begin at the earliest time the RSVP SP knows the peer address (from which it may also determine the local bound address) and the sending QoS parameters.</p>
<p>
<b>5.1.2&#09;Multicast UDP Senders</b></p>
<p>
The previous discussion on unicast UDP senders applies to multicast UDP senders as well. The only difference between the two cases is that multicast UDP senders use the <b>WSAJoinLeaf </b>call, instead of the <b>WSAConnect </b>call used in the unicast case. The <b>WSAJoinLeaf </b>call provides the destination multicast <i>session</i> address and may also be used to provide QoS parameters. If QoS parameters are not provided with the call to <b>WSAJoinLeaf</b>, they must be provided separately, with a call to <b>WSAIoctl</b>(<i>SIO_SET_QOS</i>). The multicast <i>session</i> address is used to compose the RSVP <i>session </i>object to be included in RSVP <i>PATH </i>messages.</p>
<p>
Note that in the case that a sending multicast UDP socket is bound using <i>INADDR_ANY</i>, the RSVP SP will use the multicast <i>session</i> address to perform an interface query, just as it would in the unicast case. The RSVP SP will use the interface address returned from the interface query to compose the RSVP <i>SenderTemplate</i> to be included in <i>PATH </i>messages<i>. </i></p>
<p>
<b>5.1.3&#09;Unicast TCP Senders</b></p>
<p>
For TCP <i>sessions</i>, the active peer issues a <b>WSAConnect </b>and the passive peer issues a <b>WSAAccept</b>. Typically, the passive peer is the sender, and the active peer is the receiver, although this is not necessarily the case. In this section, the passive peer is assumed  also to be the sender. For the case in which the active peer is the sender, the subsequent section on unicast receivers can be applied.</p>
<p>
As the passive peer, the sending application calls <b>WSAAccept</b>. This call returns the connecting peer’s address but does not carry QoS parameters. Instead, the application defines a callback function (<i>ConditionFunc</i>) which is called by the transport service provider when the active peer initiates a connection. <i>ConditionFunc </i>tells QoS parameters to be passed to the application or for the application to pass QoS parameters back to the service provider. </p>
<p>
Therefore, passive TCP peers may provide QoS parameters to the RSVP SP with the completion of the <i>ConditionFunc </i>or, alternatively, using <b>WSAIoctl</b>(<i>SIO_SET_QOS</i>). The application may call <b>WSAIoctl</b>(<i>SIO_SET_QOS</i>) to associate QoS parameters with a socket, at any time following the creation of the socket (The RSVP SP will call the <i>ConditionFunc </i>with no <i>ProviderSpecific </i>buffer. Therefore, if the passive TCP application wishes to convey <i>ProviderSpecific </i>QoS parameters, it must call <b>WSAIoctl</b>(<i>SIO_SET_QOS</i>) to do so.). RSVP sender processing will begin at the earliest time at which the RSVP SP knows the peer address, the address to which the socket is bound locally and the QoS parameters.</p>
<p>
To provide QoS parameters through the <i>ConditionFunc</i>, the application is required to complete the <i>ConditionFunc </i>with status <i>CF_ACCEPT. </i>In addition, if the application has previously associated QoS parameters with the socket by calling <b>WSAIoctl</b>(<i>SIO_SET_QOS</i>), then completion of the <i>ConditionFunc </i>may cause modification of the QoS parameters unless the <i>ServiceType </i>parameters in the corresponding <i>flowspec</i>s are set to <i>SERVICETYPE_NOCHANGE.</i></p>
<p>
The RSVP SP can readily determine the connected peer’s address by monitoring the application’s call to <b>WSAConnect </b>or by calling <b>getpeername</b> after the socket is connected.</p>
<p>
Recall that, for TCP sockets, the RSVP SP can unambiguously determine the local address bound to the socket, by calling <b>getsockname</b> at any time following the establishment of the connection. This address is used to compose the <i>SenderTemplate</i> for inclusion in RSVP <i>PATH </i>messages. As a result, no interface query is required in the case of TCP connections, even if the application binds using <i>INADDR_ANY</i>.</p>
<h3>5.2&#09;Receiving Applications</h3>
<p>
Receiving applications must provide the RSVP SP with at least, the QoS parameters, in a <i>ReceivingFlowspec</i> to invoke RSVP processing. The application includes the <i>ReceivingFlowspec</i> in a call to <b>WSAConnect </b>or <b>WSAJoinLeaf</b>, or separately, in a call to <b>WSAIoctl</b>(<i>SIO_SET_QOS</i>).</p>
<p>
The RSVP SP must compose a <i>session</i> object, and in certain cases, a <i>filterspec </i>(defining the senders from which QoS traffic is to be received) for inclusion in <i>RESV </i>messages. Generally, these are obtained from all matching <i>PATH </i>states. However, to limit the <i>PATH </i>state matched, receiving applications may provide the following addresses to the RSVP SP:
<ul>
<li>
Peer (source) address, to compose the RSVP <i>filterspec</i>, thereby limiting the RSVP senders for which <i>RESV </i>messages are sent.<br><br></li>
<li>
Local (destination) address, to limit the RSVP <i>sessions </i>for which <i>RESV </i>messages are sent.</li>
</ul>
<p>
See the previous section titled <i>Sending RESV Messages Based on Matching PATH State</i>, for further details.</p>
<p>
Once sufficient information is available to the RSVP SP, it begins to transmit RSVP <i>RESV </i>messages on behalf of the application.</p>
<p>
<b>5.2.1&#09;Unicast UDP Receivers</b></p>
<p>
UDP-receiving applications may use either the <b>WSAConnect </b>call or the <b>WSAIoctl</b>(<i>SIO_SET_QOS</i>) call to provide QoS parameters to the RSVP SP, indicating they are interested in receiving QoS traffic. The <b>WSAConnect </b>call can be used to provide a peer address, in so selecting a specific sender.</p>
<p>
If the application calls <b>WSAIoctl</b>(<i>SIO_SET_QOS</i>) to indicate receiving QoS parameters, the RSVP SP will begin transmitting <i>RESV </i>messages for any matching <i>PATH </i>state (see the previous section titled <i>Sending RESV Messages Based on Matching PATH State</i>). Since the <b>WSAIoctl</b>(<i>SIO_SET_QOS</i>) call does not associate a peer address with the socket (except in the case that the <i>ProviderSpecific </i>structure is used to specify a particular sender&#45;use of the <i>ProviderSpecific </i>structure is addressed later in the document), the socket will match <i>PATH </i>state regardless of sender. The RSVP SP will transmit Wildcard Filter (WF)-style <i>RESV </i>messages.</p>
<p>
The <b>WSAConnect </b>call should be used if the application is interested in receiving traffic from a single sender only (<b>WSAConnect </b>will cause traffic received from senders other than the one specified to be discarded&#45;to receive traffic from multiple senders, using <b>WSAConnect</b>, requires that a separate socket be created for each sender). In this case, the RSVP SP will send <i>RESV </i>messages only when <i>PATH </i>state exists for the sender specified. It will use the peer address included to compose FF-style <i>RESV </i>messages, selecting the specified sender. </p>
<p>
Receiving applications may call both <b>WSAIoctl</b>(<i>SIO_SET_QOS</i>) and <b>WSAConnect</b>, and may do so in any order. The RSVP SP will send <i>RESV </i>messages at the earliest indication of QoS parameters and the existence of matching <i>PATH </i>state. If <b>WSAIoctl</b>(<i>SIO_SET_QOS</i>) is called prior to <b>WSAConnect</b>, the RSVP SP will send WF-style <i>RESV </i>messages (provided there is matching <i>PATH </i>state) initially and will send FF-style <i>RESV </i>messages as soon as a peer is specified by <b>WSAConnect</b> (provided that matching <i>PATH </i>state exists for the particular sender specified). </p>
<p>
Note that calling <b>WSAIoctl</b>(<i>SIO_SET_QOS</i>) after <b>WSAConnect </b>does not negate the selection of a specific sender. Thus, although <b>WSAIoctl</b>(<i>SIO_SET_QOS</i>) may be called after <b>WSAConnect </b>to alter the QoS parameters indicated in the <i>RESV </i>messages (or to terminate the transmission of <i>RESV </i>messages&#45;by specifying <i>BestEffort </i>service), it will not cause the RSVP SP to send WF-style <i>RESV </i>messages. </p>
<p>
Calling <b>WSAConnect </b>may actually cause the RSVP SP to cease sending <i>RESV </i>messages triggered by a previous call to <b>WSAIoctl</b>(<i>SIO_SET_QOS</i>), since <i>PATH </i>state may have existed for some senders, but not for the particular sender specified. </p>
<p>
<b>5.2.2&#09;Multicast UDP Receivers</b></p>
<p>
Multicast receiving applications are expected to create UDP sockets using <b>WASocket </b>and to indicate in the accompanying flags that they are multicast receivers. Such applications are required to call <b>WSAJoinLeaf</b> to indicate the multicast <i>session</i> they are interested in joining. QoS parameters may be indicated either with the call to <b>WSAJoinLeaf</b> or separately, using <b>WSAIoctl</b>(<i>SIO_SET_QOS</i>).</p>
<p>
Unlike the unicast case, the RSVP SP will not send <i>RESV </i>messages for multicast <i>sessions</i> until a multicast <i>session</i> address is unambiguously specified in a call to <b>WSAJoinLeaf</b>. The RSVP SP makes no use of the parameters with which the multicast socket is bound. Also, since no peer is specified, the RSVP SP makes no assumptions about specific senders. Consequently, <i>RESV </i>messages sent on behalf of multicast receivers, are by default the WF style (applications may use the <i>ProviderSpecific </i>fields of the QoS structure to specify particular senders, thereby causing the RSVP SP to send FF or SE-style <i>RESV </i>messages).</p>
<p>
Receiving applications may call both <b>WSAIoctl</b>(<i>SIO_SET_QOS</i>) and <b>WSAJoinLeaf</b>, and may do so in any order. The RSVP SP will send <i>RESV </i>messages at the earliest indication of QoS parameters and the existence of matching <i>PATH </i>state. However, note that in the multicast case, matching <i>PATH </i>state will only be found if a multicast socket has been created with a matching multicast <i>session</i> address. </p>
<p>
The RSVP SP does not preclude a receiving application from joining multiple multicast groups on a single socket. In this case, the RSVP SP will send <i>RESV </i>messages for all groups for which there is a matching <i>PATH </i>state. Unless <b>WSAIoctl</b>(<i>SIO_SET_QOS</i>) is called, QoS parameters will be obtained separately from the <i>ReceivingFlowspec</i>s<i> </i>included with the <b>WSAJoinLeaf </b>calls for each multicast group. If <b>WSAIoctl</b>(<i>SIO_SET_QOS</i>) is called, the QoS parameters included will be applied to all multicast groups joined.</p>
<p>
<b>5.2.3&#09;Unicast TCP Receivers</b></p>
<p>
Typically, the TCP receiver is the active peer in a TCP connection. As such, receiving TCP applications are expected to use <b>WSAConnect</b> to initiate a connection to the sender. Rules for invoking RSVP processing from the RSVP SP are similar to those which apply in the unicast UDP sender case. Specifically, the receiving application must use <b>WSAConnect </b>to specify the peer sender’s address. The RSVP SP uses this address directly to compose the <i>filterspec </i>for Fixed Filter (FF)-style <i>RESV </i>messages. </p>
<p>
Typically, the call to <b>WSAConnect </b>will include receiving QoS parameters. However, the receiving application may use the <b>WSAIoctl</b>(<i>SIO_SET_QOS</i>) to provide the receiving QoS parameters to the RSVP SP before or after the call to <b>WSAConnect</b>. In all cases, the RSVP SP will begin RSVP processing at the earliest time it knows the receiving QoS parameters and<i> </i>there is a matching <i>PATH </i>state. In the case of TCP receivers, <i>PATH </i>state will match only if the <i>session </i>address and the <i>SenderTemplate </i>match the bound address and the peer address associated with the socket. </p>
<p>
In case the receiving socket is bound using <i>INADDR_ANY</i>, the bound address cannot be determined until <b>WSAConnect </b>is called. If the receiving socket is bound with a specific address, the bound address can be determined earlier. However, if the peer address remains unknown and it is impossible to match <i>PATH </i>state, the transmission of <i>RESV </i>messages will still be delayed. Following connection establishment, the RSVP SP calls <b>getpeername </b>to determine the peer address. At that time sufficient information is available to generate <i>RESV </i>messages.</p>
<h3>5.3&#09;Use of WSAIoctl(SIO_SET_QOS)</h3>
<p>
The previous paragraphs covered the use of <b>WSAIoctl</b>(<i>SIO_SET_QOS</i>) in conjunction with the various QoS connection-oriented calls. Typically, connection-oriented calls will be used both to indicate the QoS parameters and address parameters to the RSVP SP so the call to <b>WSAIoctl</b>(<i>SIO_SET_QOS</i>) is not required. </p>
<p>
One exception is a UDP receiving application, which receives from multiple senders. In this case, the application must use <b>WSAIoctl</b>(<i>SIO_SET_QOS</i>) to specify QoS parameters without calling <b>WSAConnect </b>(which will limit the socket to receive traffic from a single sender). </p>
<p>
In other cases, applications may use <b>WSAIoctl</b>(<i>SIO_SET_QOS</i>) to specify QoS parameters, even if one of the connection-oriented calls is also used. An application can then modify QoS parameters at any time after they were originally indicated in one of the connection-oriented calls. It also allows the application to separate the specification of the QoS parameters from the determination of local and peer addresses implicit in the connection-oriented call. </p>
<h3>5.4&#09;Terminating QoS Service</h3>
<p>
The previous paragraphs discuss the method that applications invoke RSVP processing. Several events may cause the termination of RSVP processing associated with a socket. Specific examples include:
<ul>
<li>
Closing a socket by calling <b>closesocket</b>.<br><br></li>
<li>
Shutting down a socket by calling <b>shutdown</b> (note that shutting down a socket for reception or transmission only will not terminate QoS processing for transmission or reception, respectively).<br><br></li>
<li>
Calling <b>WSAConnect </b>with a NULL peer address.<br><br></li>
<li>
Calling <b>WSAIoctl </b>(<i>SIO_SET_QOS</i>) with <i>SERVICETYPE_</i> <i>NOTRAFFIC </i>or <i>SERVICETYPE_BESTEFFORT.</i></li>
</ul>
<p>
Note that in the first two cases, all RSVP processing on the socket will be terminated. However, in the third case, it is possible to terminate sending only or receiving only RSVP processing by selectively specifying <i>SERVICETYPE_NOTRAFFIC </i>or <i>SERVICETYPE_BESTEFORT </i>in <i>SendingFlowspec </i>or <i>ReceivingFlowspec</i>, respectively.</p>
<p>
In general, any event that closes a socket, will also terminate RSVP processing on the socket.</p>
<h2>6&#09;Detailed Mapping of GQoS to RSVP&#45; QoS Parameters</h2>
<p>
This section covers the mapping of QoS parameters from GQoS to RSVP.</p>
<p>
Winsock2 QoS calls include two <i>flowspec </i>structures, <i>SendingFlowspec </i>and <i>ReceivingFlowspec</i>. <i>SendingFlowspec </i>is used to invoke RSVP-sender processing and <i>ReceivingFlowspec </i>is used to invoke receiver processing. RSVP-sender processing requires the inclusion of a <i>Tspec</i> with <i>PATH </i>messages. The <i>Tspec </i>describes the traffic flow offered by the sender and is readily derived from <i>SendingFlowspec</i>. RSVP-receiver processing varies depending on the service type requested. Receiver processing for controlled load service requires inclusion of a <i>Tspec </i>with <i>RESV </i>messages. Receiver processing for guaranteed load service requires inclusion of a <i>Tspec </i>and an <i>Rspec</i>. The <i>Rspec </i>defines the QoS desired by the receiver. </p>
<p>
The following table shows the general mapping of parameters from the Winsock2 QoS <i>flowspecs</i> to RSVP <i>Tspec</i>s and <i>Rspec</i>s.</p>
<table>
<tr valign=top>
<td>
<b>Winsock2 <i>flowspec</i></b></td>
<td>
<b>Tspec</b></td>
<td>
<b>Rspec</b></td>
</tr>
<tr valign=top>
<td>
<i>TokenRate</i></td>
<td>
<i>TokenBucketRate</i></td>
<td>
<i>Rate</i></td>
</tr>
<tr valign=top>
<td>
<i>TokenBucketSize</i></td>
<td>
<i>TokenBucketSize</i></td>
<td>
</td>
</tr>
<tr valign=top>
<td>
<i>PeakBandwidth</i></td>
<td>
<i>PeakRate</i></td>
<td>
</td>
</tr>
<tr valign=top>
<td>
<i>MinimumPolicedSize</i></td>
<td>
<i>MinimumPolicedUnit</i></td>
<td>
</td>
</tr>
<tr valign=top>
<td>
<i>MaxSduSize</i></td>
<td>
<i>MaximumPacketSize</i></td>
<td>
</td>
</tr>
<tr valign=top>
<td>
<i>DelayVariation</i></td>
<td>
</td>
<td>
<i>DelaySlackTerm</i></td>
</tr>
<tr valign=top>
<td>
<i>Latency</i></td>
<td>
</td>
<td>
</td>
</tr>
</table><br>
<p>
By specifying the value ‘-1’ as a <i>flowspec </i>parameter, applications can indicate that a default parameter will be inferred by the RSVP SP. Additionally, applications may specify <i>SERVICETYPE_NOCHANGE </i>in one or both <i>flowspec</i>s, to indicate that the QoS parameters in the corresponding direction(s) should remain unchanged. This is especially useful, for example, so an application can change sending parameters without affecting receiving parameters (or vice versa).</p>
<h3>6.1&#09;Tspec</h3>
<p>
<b><i>6.1.1&#09;SenderTspec</i></b></p>
<p>
On senders, RSVP uses the mapping tabulated above, to derive a <i>SenderTspec </i>from the <i>SendingFlowspec</i>, for inclusion in <i>PATH </i>messages (with the possible exceptions noted below).</p>
<p>
If the sending application does not specify the parameter <i>MaxSduSize</i>, the RSVP SP will use a default value of 1514 bytes.</p>
<p>
If the application does not specify the parameter <i>MinimumPolicedSize</i>, the RSVP SP will use a default value of 128 bytes.</p>
<p>
<i>6.1.2&#09;ReceiverTspec</i></p>
<p>
6.1.2.1&#09;Controlled Load Service</p>
<p>
On receivers, for <i>ControlledLoadService</i>, the application may specify only the <i>ServiceType </i>parameter in the <i>ReceivingFlowspec. </i>In this case, the RSVP SP copies the <i>SenderTspec </i>from matching <i>PATH </i>messages (see the section titled <i>Sending RESV Messages Based on Matching PATH State</i>), to the <i>ReceiverTspec </i>sent with the <i>RESV </i>messages (with the possible exceptions noted below). Alternatively, the receiving application may specify, in the <i>ReceivingFlowspec</i>, any of the <i>Tspec </i>parameters tabulated above. This will cause the RSVP SP to use the specified parameters in the <i>ReceiverTspec </i>sent with the <i>RESV </i>messages (instead of the corresponding parameter from received <i>PATH </i>messages). Parameters not specified by the application should be set to ‘-1’ in the <i>ReceivingFlowspec</i> and will be copied from the matching <i>PATH </i>messages.</p>
<p>
6.1.2.2&#09;Guaranteed Service</p>
<p>
On receivers, for <i>GuaranteedService</i>, the RSVP SP will copy the <i>SenderTspec </i>from matching <i>PATH </i>messages to the <i>ReceiverTspec </i>sent with the <i>RESV </i>messages (with the possible exceptions noted below). The application cannot override <i>Tspec </i>parameters in this case. </p>
<p>
6.1.2.3&#09;Exceptions</p>
<p>
In the case of Wildcard Filter reservation styles, multiple <i>PATH </i>messages may be received (corresponding to the same <i>session</i>) but with different <i>SenderTspec</i>s (representing different senders). In this case, the RSVP SP will copy the greater (as determined by the RSVP least upper bound calculation) of the <i>SenderTspec</i>s, to the <i>ReceiverTspec </i>included with <i>RESV </i>messages.</p>
<p>
The RSVP SP will populate the <i>MaximumPacketSize </i>in the <i>ReceiverTspec </i>with the <i>PATH_MTU </i>value from the <i>Adspec </i>in the corresponding inbound <i>PATH </i>message. If there are multiple <i>PATH </i>messages, the lowest <i>PATH_MTU </i>value from all corresponding <i>Adspec</i>s will be used. </p>
<h3>6.2&#09;Rspec</h3>
<p>
The <i>Rspec </i>is included by the RSVP SP in <i>RESV </i>messages sent on behalf of a receiving application, only when <i>GuaranteedService </i>is specified by the receiving application. The application is expected to specify two of the three parameters; <i>TokenRate</i>, <i>DelayVariation, </i>and <i>Latency</i>, as shown in the following table:</p>
<table>
<tr valign=top>
<td>
<b>Application specifies:</b></td>
<td>
<b>RSVP SP constructs </b><i>Rspec</i><b>:</b></td>
</tr>
<tr valign=top>
<td>
<i>TokenRate </i>and <i>DelayVariation</i></td>
<td>
<font face="Symbol"><span style="font-family:symbol">&#183;</span></font>&#09;<i>Rate </i>is copied from <i>TokenRate.</i><p>
<font face="Symbol"><span style="font-family:symbol">&#183;</span></font>&#09;<i>DelaySlackTerm </i>is copied from <i>DelayVariation.</i></p>
<p>
<font face="Symbol"><span style="font-family:symbol">&#183;</span></font>&#09;<i>Latency </i>parameter is ignored.</p>
</td>
</tr>
<tr valign=top>
<td>
<i>DelayVariation </i>and <i>Latency</i></td>
<td>
<font face="Symbol"><span style="font-family:symbol">&#183;</span></font>&#09;<i>Rate </i>parameter of <i>Rspec is </i>calculated based on <i>DelayVariation </i>and <i>Latency </i>and other parameters obtained from <i>Adspec.</i></td>
</tr>
</table><br>
<p>
If the application does not specify two of the three parameters (all parameters are set to ‘-1’), then the RSVP SP will infer appropriate default values based on corresponding received <i>PATH </i>messages.</p>
<h3>6.3&#09;Service Types</h3>
<p>
The following values may be specified in the <i>ServiceType </i>parameter of the <i>SendingFlowspec </i>and the <i>ReceivingFlowspec</i>:</p>
<table>
<tr valign=top>
<td>
<b>SERVICETYPE_</b></td>
<td>
<b>In </b><i>SendingFlowspec</i></td>
<td>
<b>In </b><i>ReceivingFlowspec</i></td>
</tr>
<tr valign=top>
<td>
<b>BESTEFFORT</b></td>
<td>
Indicates that only best-effort service is supported for this traffic flow.</td>
<td>
Requests best-effort service (no QoS treatment).</td>
</tr>
<tr valign=top>
<td>
<b>NOTRAFFIC</b></td>
<td>
Indicates that there will be no traffic in this direction. On duplex capable media, this signals underlying software to set up unidirectional connections only.</td>
<td>
Indicates that there will be no traffic in this direction. On duplex capable media, this signals underlying software to setup unidirectional connections only.</td>
</tr>
<tr valign=top>
<td>
<b>CONTROLLEDLOAD</b></td>
<td>
Indicates that only controlled load service is supported for this traffic flow.</td>
<td>
Per the <i>Intserv </i>specification.</td>
</tr>
<tr valign=top>
<td>
<b>GUARANTEED</b></td>
<td>
Indicates that only guaranteed service is supported for this traffic flow.</td>
<td>
Per the <i>Intserv </i>specification.</td>
</tr>
<tr valign=top>
<td>
<b>NETWORK_UNAVAILABLE</b></td>
<td>
May be used by certain service providers to indicate a loss of network service in the corresponding direction.</td>
<td>
May be used by certain service providers to indicate a loss of network service in the corresponding direction.</td>
</tr>
<tr valign=top>
<td>
<b>GENERAL_INFORMATION</b></td>
<td>
Indicates that all service types are supported or this traffic flow.</td>
<td>
Not applicable.</td>
</tr>
<tr valign=top>
<td>
<b>NO_CHANGE</b></td>
<td>
Allows an application to modify QoS in one direction while leaving the other unchanged, or to provide <i>ProviderSpecific </i>parameters without altering values previously specified in the <i>flowspec</i>s. </td>
<td>
Allows an application to modify QoS in one direction while leaving the other unchanged, or to provide <i>ProviderSpecific </i>parameters without altering values previously specified in the <i>flowspec</i>s. </td>
</tr>
<tr valign=top>
<td>
<b>IMMEDIATE_TRAFFIC_CONTROL</b></td>
<td>
Requests the service provider to activate traffic control coincident with provision of the <i>flowspec</i>. This value should be ‘ored’ with the service type specified.</td>
<td>
Not applicable.</td>
</tr>
</table><br>
<h2>7&#09;Reservation Styles</h2>
<p>
Three reservation styles are recognized by RSVP. These are <i>Fixed Filter </i>(FF), <i>Shared Explicit </i>(SE), and <i>Wildcard Filter </i>(WF). Not all reservation styles can be accommodated using the GQoS interface (unless the <i>ProviderSpecific</i> structure is also used). The RSVP SP will infer the reservation style desired by a receiving application per the following rules.</p>
<p>
For details on invocation of alternate reservation styles, see the section titled <i>Use of the Provider Specific Structure</i>.</p>
<h3>7.1&#09;Fixed Filter&#45;Unicast</h3>
<p>
Receiving applications requesting QoS for a unicast <i>session</i> will be assumed to require the FF reservation style. TCP receivers are always assumed to be unicast receivers. </p>
<p>
Note that UDP unicast receivers will be handled using FF-style reservations, only if they call <b>WSAConnect</b>. UDP unicast receivers which do not call <b>WSAConnect </b>will be handled using WF-style reservations.</p>
<h3>7.2&#09;Wildcard Filter&#45;Multicast</h3>
<p>
Receiving applications requesting QoS for a multicast address and UDP applications that do not call <b>WSAConnect</b> will be assumed to require the W-style reservation. This is necessary because there is no means for the receiving application to specify selected senders for the multicast <i>session</i>. If an SE- or FF-style reservation is required, either the <i>ProviderSpecific </i>structure must be used to supply the required <i>flowdescriptor</i>s, or the RSVP annex must be used. </p>
<h3>7.3&#09;Shared Explicit</h3>
<p>
Shared Explicit (SE) reservations require the specification of multiple <i>flowdescriptor</i>s. The standard structures included with the Winsock2 GQoS interface do not provide for this. Therefore, in general, the SE reservation style will require use of the <i>ProviderSpecific </i>structure or the RSVP Annex.</p>
<h2>8&#09;Use of <i>ProviderSpecific </i>Structure</h2>
<p>
The GQoS interfaces support the QoS requirements of a majority of applications without using the <i>ProviderSpecific </i>buffer. In certain cases, the application will be required to provide information which cannot be provided through the standard GQoS parameters. In these cases, the application will provide additional parameters in the <i>ProviderSpecific </i>buffer which is a member of the QoS structure. The following paragraphs describe the use of the <i>ProviderSpecific </i>structure. </p>
<p>
The <i>ProviderSpecific </i>buffer is of type <i>WSABUF</i>. This structure includes a length field and a pointer to a buffer. The buffer may include a number of objects. Each object includes a <i>type</i> field (which identifies the object), followed by a <i>length</i> field (which contains the length of the object, excluding the header), followed by the object data itself. </p>
<h3>8.1&#09;The RSVP_RESERVE_INFO Object</h3>
<p>
This object may be used by applications to override the default reservation styles. It includes a <i>Style </i>parameter that specifies the reservation style to be used, and allows for the specification of a list of <i>flowdescriptors</i>. For detailed structure formats, refer to the “ws2rsvp.h” header file.</p>
<p>
The following reservation styles may be specified:
<ul>
<li>
<i>RSVP_WILDCARD_SYLE</i>: Used to request RSVP to make reservations using the WF style. Note that this is the default for multicast receivers and unconnected UDP unicast receivers, while FF is the default for connected unicast receivers. This command type can be used to override the default FF style for connected unicast receivers.<br><br></li>
<li>
<i>RSVP_FIXED_FILTER_STYLE</i>: This style object may be used to override the default WF style for multicast receivers or unconnected UDP unicast receivers. It may also be used to generate multiple FF-style reservations where only a single FF-style reservation would have been generated by default (connected unicast receivers).<br><br></li>
<li>
<i>RSVP_SHARED_EXPLICIT_STYLE</i>: Used to request RSVP to make reservations for a number of explicitly specified sources (<i>filterpsecs</i>).</li>
</ul>
<p>
The <i>flowdescriptor </i>list is specified using the <i>RSVP_FLOWDESCRIPTOR </i>structure, which is a member of the <i>RSVP_RESERVE_INFO </i>object.</p>
<h3>8.2&#09;Alternate Reservation Styles</h3>
<p>
The following reservation styles are provided by default:
<ul>
<li>
Unicast&#45;a single FF-style reservation.<br><br></li>
<li>
Multicast&#45;a WF-style reservation.</li>
</ul>
<p>
In the absence of an <i>RSVP_RESERVE_INFO </i>object in the <i>ProviderSpecific </i>structure, these reservation styles will be provided. To override the default reservation styles, the <i>RSPV_RESERVE_INFO </i>object is used to specify a reservation style, and one or more <i>RSVP_FLOWDESCRIPTOR </i>structures follow, as described below. </p>
<p>
<b>8.2.1&#09;Single FixedFilter Reservations</b></p>
<p>
This is the default reservation style invoked for connected unicast receivers. To invoke this reservation style for multicast receivers, it is necessary to override the default WF-style reservation by specifying the FF-style object, followed by a single <i>RSVP_FLOWDESCRIPTOR</i>.</p>
<p>
<b>8.2.2&#09;Multiple FixedFilter Reservations in a Single Reservation</b></p>
<p>
This style allows a receiver to reserve mutually exclusive flows from multiple, explicitly identified sources. It is invoked by specifying the FF style followed by a list of multiple <i>RSVP_FLOWDESCRIPTOR</i>s. Note that this style cannot be applied to TCP receivers since they are assumed to be connected to a single peer sender. Also, this style cannot be applied to UDP receivers that have been connected (by calling <b>WSAConnect</b>), since the transport will discard data from all senders other than the one specified in the call to <b>WSAConnect</b>.</p>
<p>
<b>8.2.3&#09;Shared Explicit Reservations</b></p>
<p>
This style allows a receiver to specify multiple sources. The flow resources requested will be shared between all sources. It is invoked by specifying the corresponding style, followed by a single <i>RSVP_FLOWDESCRIPTOR</i>, which includes multiple <i>RSVP_FILTERSPEC</i>s. As is the case with multiple FF-style reservations, this style cannot be applied to TCP receivers or to connected UDP receivers.</p>
<p>
<b>8.2.4&#09;WF Reservations</b></p>
<p>
This is the default reservation style for multicast receivers and unconnected UDP receivers. To invoke this reservation style for TCP unicast receivers or for connected UDP unicast receivers, it is necessary to override the default FF reservation style by specifying the WF style, followed by a single <i>RSVP_FLOWDESCRIPTOR</i>.</p>
<h3>8.3&#09;The Priority Object</h3>
<p>
The optional priority object contains two parameters. One indicates the transmission priority of a requested flow, the other represents the receive priority of the requested flow. It should be used to supplement the standard <i>flowspec</i>. Note that the transmit priority object will be used by the kernel to determine relative priorities for multiple flows of the same Intserv service type. Priorities between Intserv service types are defined by the Intserv service type definitions.</p>
<p>
<b>8.3.1&#09;Packet Sequencing</b></p>
<p>
The transmit priority object will be interpreted by packet sequencing components in the network stack (typically in the kernel), and will determine which flow’s packets get access to the wire under congested conditions. The typical packet sequencer will group flows according to the value specified in the priority object. Under congested conditions, a packet sequencer will send packets from each flow, in the highest priority group for which packets are pending. Flows within the group will be serviced in a round-robin fashion. </p>
<p>
Note that flow priority is machinewide, not within an application. Thus, flows from two different applications, given the same priority, will be serviced as part of the same priority group.</p>
<p>
<b>8.3.2&#09;Avoiding Starvation </b></p>
<p>
Although this priority mechanism has the potential to starve low priority flows, this is unlikely to happen in a correctly configured system. Traffic control components will limit the admission of high-priority flows so sustained capacity of the media is not exceeded. In this case, priority will determine the latencies perceived by packets on particular flows, under transient congestion conditions, while maintaining the sustained rates specified in the token bucket parameters of the <i>flowspec</i>.</p>
<p>
<b>8.3.3&#09;Usage</b></p>
<p>
The priority object can be used to specify a range of priorities between 0 and 7 (with 0 being the lowest priority and 7 being the highest). This value will be used by the kernel, together with the service type specified in the <i>flowspec</i>, to control the prioritization in the kernel. The absence of a priority object with a <i>flowspec</i> will be interpreted as default priority (equivalent to a priority object of three).</p>
<p>
The kernel is not required to implement multiple priority levels for each Intserv service class. Applications should specify relative priority by use of the Intserv service class whenever possible. Where it is absolutely necessary to specify prioritization within an Intserv service class, applications should restrict the priority levels to the minimum possible. For example, use 7 to specify higher than default for the class, and 0 to specify lower than default for the class. </p>
<p>
Consider a video-conferencing or whiteboard application. Such an application should specify service as follows:</p>
<table>
<tr valign=top>
<td>
<b>Flow Type</b></td>
<td>
<b>ServiceType in flowspec</b></td>
<td>
<b>QOS_PRIORITY Object</b></td>
</tr>
<tr valign=top>
<td>
Whiteboard data</td>
<td>
SERVICETYPE_BESTEFFORT</td>
<td>
No priority object</td>
</tr>
<tr valign=top>
<td>
Video data</td>
<td>
SERVICETYPE_CONTROLLEDLOAD</td>
<td>
No priority object</td>
</tr>
<tr valign=top>
<td>
Audio data</td>
<td>
SERVICETYPE_CONTROLLEDLOAD</td>
<td>
Priority object = 7</td>
</tr>
</table><br>
<p>
<b>8.3.4&#09;Relation to Socket Group Priority</b></p>
<p>
The socket group priority mechanism has been eliminated. It was intended to specify relative priorities of sockets within a group without defining the interpretation of priorities across groups. The priority object defined here, specifies the relative priority across all flows on the host.</p>
<p>
<b>8.3.5&#09;Relation to 802.1p</b></p>
<p>
The priority object is unrelated to 802.1p traffic classes, which are indicated in tags attached to transmitted packets. The kernel traffic control components will determine the 802.1p traffic classes based on standardized Intserv <i>flowspec</i> to 802.1p traffic class mappings.</p>
<h2>9&#09;Status Indications from the RSVP SP to Applications</h2>
<p>
Applications are expected to register interest in <i>FD_QOS </i>(<b>WSAEventSelect</b> or <b>WSAAsyncSelect</b>) to receive asynchronous notifications of status events from the RSVP SP. When a significant QoS event occurs on the specified socket, the RSVP SP posts a message or signals the event, as appropriate.  In either case, one of the error codes below will be included. Alternatively, these error codes may be retrieved by calling <b>WSAEnumNetworkEvents</b>. These error codes may be found in the “winsock2.h” header file.
<ul>
<li>
WSA_QOS_RECEIVERS&#45;at least one <i>RESV</i> has arrived.<br><br></li>
<li>
WSA_QOS_SENDERS&#45;at least one <i>PATH</i> has arrived.<br><br></li>
<li>
WSA_QOS_NO_SENDERS&#45;there are no senders.<br><br></li>
<li>
WSA_QOS_NO_RECEIVERS&#45;there are no receivers.<br><br></li>
<li>
WSA_QOS_REQUEST_CONFIRMED&#45;reserve has been confirmed.<br><br></li>
<li>
WSA_QOS_ADMISSION_FAILURE&#45;error due to lack of resources.<br><br></li>
<li>
WSA_QOS_POLICY_FAILURE&#45;rejected for administrative reasons.<br><br></li>
<li>
WSA_QOS_BAD_STYLE&#45;unknown or conflicting style.<br><br></li>
<li>
WSA_QOS_BAD_OBJECT&#45;problem with some part of the <i>flowspec.</i><br><br></li>
<li>
WSA_QOS_TRAFFIC_CTRL_ERROR&#45;problem with some part of the <i>filterspec.</i><br><br></li>
<li>
WSA_QOS_GENERIC_ERROR - general error.</li>
</ul>
<p>
When the <i>FD_QOS </i>event is signaled, the application should issue a <b>WSAIoctl </b>(<i>SIO_GET_QOS</i>) to retrieve a QoS<i> </i>structure. The returned QoS<i> </i>structure will indicate the current QoS parameters. The application should inspect these parameters to determine the extent of the QoS change. </p>
<p>
Regardless of the status code indicated, the application must issue the <b>WSAIoctl</b> (<i>SIO_GET_QOS</i>) to reenable the <i>FD_QOS </i>event.</p>
<h3>9.1&#09;Use of the ProviderSpecific Structure for Status Indications</h3>
<p>
The status indication mechanisms described so far provide for the indication of a single status code, and the notification of a change in specific QoS parameters. Additional information can be indicated from the RSVP SP to applications, by use of the <i>ProviderSpecific </i>member of the QoS<i> </i>structure which is indicated in response to <b>WSAIoctl </b>(<i>SIO_GET_QOS</i>). </p>
<p>
When the <i>ProviderSpecific</i> structure included is at least as the size of the <i>QOS_STATUS</i> structure then the following additional information will be returned. The first value in the structure is the same as the status value returned in response to <b>WSAEnumNetworkEvents</b>. Additional parameters provide the specific RSVP error code and error value from the standard RSVP <i>ErrorSpec</i> object, if available.</p>
<h2>10&#09;WSAGetQoSByName</h2>
<p>
Applications call <b>WSAGetQoSByName </b>to retrieve a list of available QoS templates and to populate <i>flowspec</i> structures with a named template. This facility is particularly useful to applications which are aware of the codec which they are using, since these tend to have well-defined <i>flowspec </i>parameters. </p>
<p>
General usage of the <b>WSAGetQoSByName </b>call is as follows: 
<ol>
<li>
Applications call <b>WSAGetQoSByName </b>with a NULL <i>lpQoSName </i>parameter and a pointer to a <i>WSABUF s</i>tructure in the <i>lpQoS </i>parameter. <br><br></li>
<li>
Winsock returns a list of QoS template names. <br><br></li>
<li>
The application selects a template name based on the type of QoS flow it will be generating. It passes the selected template name to Winsock, in the <i>lpQoSName </i>parameter. It passes a pointer to the <i>flowspec </i>structure to be used in the <i>lpQoS </i>parameter.<br><br></li>
<li>
Winsock fills in the <i>flowspec </i>structure with the parameters from the selected template.</li>
</ol>
<h2>11&#09;QoS For Socket Groups</h2>
<p>
The socket group mechanism for specifying QoS priority has been eliminated. Instead, priorities are specified by the <i>ServiceType </i>parameter of the <i>flowspec </i>structure. Applications may use the <i>QOS_PRIORITY </i>object in the <i>ProviderSpecific </i>buffer that accompanies <i>flowspecs</i>, to specify some degree of prioritization within the service class specified by <i>ServiceType.</i></p>
<h2>12&#09;Protocol Chaining</h2>
<p>
QoS-aware applications are expected to call <b>WSAEnumProtocols </b>to get a list of <i>WSAPROTOCOL_INFO </i>structures, which describe the various protocols (chains) available as service providers. The application should inspect the <i>XP1_QOS_SUPPORTED </i>flag in the <i>dwServiceFlags1 </i>field of each structure to determine whether QoS is supported by the protocol (chain). It may then scan additional fields of the <i>WSAPROTOCOL_INFO</i>, in particular the <i>szProtocol </i>text field, to select a specific QoS provider. The RSVP SP will register the following chains: </p>
<table>
<tr valign=top>
<td>
<b>Description</b></td>
<td>
<b>iProtocol</b></td>
</tr>
<tr valign=top>
<td>
RSVP over UDP</td>
<td>
RSVP_UDP</td>
</tr>
<tr valign=top>
<td>
RSVP over TCP</td>
<td>
RSVP_TCP</td>
</tr>
<tr valign=top>
<td>
Traffic control over UDP</td>
<td>
TC_UDP</td>
</tr>
<tr valign=top>
<td>
Traffic control over TCP</td>
<td>
TC_TCP</td>
</tr>
</table><br>
<p>
These chain configurations are available both to applications using the GQoS interface and to those using the RSVP-specific annex interface.</p>
<p>
Specific implementations of RSVP SPs may support additional underlying transport protocols. These will be indicated by the registration of corresponding protocol chains.</p>
<h2>13&#09;Appendix A&#45;Sample Call Sequences</h2>
<p>
In the following paragraphs there are examples of legitimate call sequences that may be invoked by QoS-aware applications. Each sequence is shown to begin with a call to <b>bind</b>. Strictly speaking, this call is not required, except in the case of the passive TCP application calling <b>WSAAccept</b>, as long as the application calls one of the connection-oriented calls (<b>WSAConnect</b> or <b>WSAJoinLeaf</b>). The transport provider will bind on its behalf at that time.</p>
<h3>13.1&#09;UDP Unicast Sender, Bound Using INADDR_ANY</h3>
<p>
In this example, the sending application binds using <i>INADDR_ANY</i>. As a result, the RSVP SP calls <b>WSAIoctl</b>(<i>SIO_LOCAL_INTERFACE_QUERY</i>) as soon as the peer address is available from the application’s call to <b>WSAConnect</b>. </p>
<table>
<tr valign=top>
<td>
<b>Sending Application</b></td>
<td>
<b>RSVP SP</b></td>
</tr>
<tr valign=top>
<td>
<b>bind </b>(<i>INADDR_ANY</i>)</td>
<td>
</td>
</tr>
<tr valign=top>
<td>
<b>WSAConnect </b>(<i>SendingFlowspec</i>) </td>
<td>
</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
<b>WSAIoctl</b>(<i>SIO_LOCAL_INTERFACE_QUERY</i>)</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
<b>WSAIoctl</b>(<i>SIO_LOCAL_INTERFACE_QUERY</i>) returns</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
Begin sending <i>PATH</i> messages</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
<i>RESV </i>messages received</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
Indicate presence of <i>RESV </i>state to application</td>
</tr>
<tr valign=top>
<td>
Begin sending QoS traffic </td>
<td>
</td>
</tr>
</table><br>
<h3>13.2&#09;UDP Unicast Sender Bound to a Specific Address</h3>
<p>
In this example, the application binds using a specific address. The RSVP SP is not required to call <b>WSAIoctl</b>(<i>SIO_LOCAL_INTERFACE_QUERY</i>), and it will not be responsible for directly handling routing changes. The application must handle routing changes if it wishes to maintain QoS following a routing change. It does so by closing the existing socket and creating a new one, bound to the new address.</p>
<table>
<tr valign=top>
<td>
<b>Sending Application</b></td>
<td>
<b>RSVP SP</b></td>
</tr>
<tr valign=top>
<td>
<b>WSAIoctl</b>(<i>SIO_LOCAL_INTERFACE_QUERY</i>) </td>
<td>
</td>
</tr>
<tr valign=top>
<td>
<b>WSAIoctl</b>(<i>SIO_LOCAL_INTERFACE_QUERY</i>) returns </td>
<td>
</td>
</tr>
<tr valign=top>
<td>
<b>WSAIoctl</b>(<i>SIO_LOCAL_INTERFACE_CHANGE</i>)</td>
<td>
</td>
</tr>
<tr valign=top>
<td>
<b>bind </b>(specific address)</td>
<td>
</td>
</tr>
<tr valign=top>
<td>
<b>WSAConnect </b>(<i>SendingFlowspec</i>) </td>
<td>
</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
Begin sending <i>PATH</i> messages</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
<i>RESV </i>messages received </td>
</tr>
<tr valign=top>
<td>
</td>
<td>
Indicate presence of <i>RESV </i>state to application</td>
</tr>
<tr valign=top>
<td>
Begin sending QoS traffic</td>
<td>
</td>
</tr>
<tr valign=top>
<td>
<i>FD_ROUTING_CHANGE </i>indicated to application</td>
<td>
</td>
</tr>
<tr valign=top>
<td>
Close and recreate socket</td>
<td>
</td>
</tr>
</table><br>
<h3>13.3&#09;UDP Unicast Sender, QoS Parameters Modified </h3>
<p>
In this example, a QoS <i>session</i> is initiated according to the QoS parameters supplied by the sender (with the <b>WSAConnect </b>call). The application later modifies the sending QoS by calling <b>WSAIoctl</b>(<i>SIO_SET_QOS</i>) with modified QoS parameters.</p>
<table>
<tr valign=top>
<td>
<b>Sending Application</b></td>
<td>
<b>RSVP SP</b></td>
</tr>
<tr valign=top>
<td>
<b>bind </b>(<i>INADDR_ANY</i>)</td>
<td>
</td>
</tr>
<tr valign=top>
<td>
<b>WSAConnect </b>(<i>SendingFlowspec</i>) </td>
<td>
</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
<b>WSAIoctl</b>(<i>SIO_LOCAL_INTERFACE_QUERY</i>)</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
<b>WSAIoctl</b>(<i>SIO_LOCAL_INTERFACE_QUERY</i>) returns</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
Begin sending <i>PATH</i> messages</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
<i>RESV </i>messages received</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
Indicate presence of <i>RESV </i>state to application</td>
</tr>
<tr valign=top>
<td>
Begin sending QoS traffic </td>
<td>
</td>
</tr>
<tr valign=top>
<td>
<b>WSAIoctl</b>(<i>SIO_SET_QOS</i>)</td>
<td>
</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
Send modified <i>PATH </i>messages</td>
</tr>
</table><br>
<h3>13.4&#09;UDP Multicast Sender, QoS Parameters in WSAIoctl</h3>
<p>
In the following example, a sending UDP application binds a socket using <i>INADDR_ANY </i>. Later it calls <b>WSAJoinLeaf</b>, indicating the destination <i>session</i> address. However, since no QoS parameters are included with the call to <b>WSAJoinLeaf</b>, it does not begin RSVP processing. The application supplies QoS parameters later, with a call to <b>WSAIoctl</b>. At that time, the RSVP SP performs an interface query on the multicast <i>session</i> address to determine which address to use in the <i>SenderTemplate</i>. The RSVP SP is then able to begin sending <i>PATH </i>messages.</p>
<table>
<tr valign=top>
<td>
<b>Sending Application</b></td>
<td>
<b>RSVP SP</b></td>
</tr>
<tr valign=top>
<td>
<b>bind </b>(<i>INADDR_ANY</i>)</td>
<td>
</td>
</tr>
<tr valign=top>
<td>
<b>WSAJoinLeaf </b>(no <i>flowspec</i>) </td>
<td>
</td>
</tr>
<tr valign=top>
<td>
<b>WSAIoctl</b>(<i>SIO_SET_QOS</i>)</td>
<td>
</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
<b>WSAIoctl</b>(<i>SIO_LOCAL_INTERFACE_QUERY</i>)</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
<b>WSAIoctl</b>(<i>SIO_LOCAL_INTERFACE_QUERY</i>) returns</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
Begin sending <i>PATH</i> messages</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
<i>RESV </i>messages received</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
Indicate presence of <i>RESV </i>state to application</td>
</tr>
<tr valign=top>
<td>
Begin sending QoS traffic </td>
<td>
</td>
</tr>
</table><br>
<h3>13.5&#09;TCP Unicast Sender, QoS Parameters Included With ConditionFunc</h3>
<p>
In the following example, a unicast TCP sender accepts a connection from a receiving peer. The sender is the passive peer, indicating its preparedness to receive a connection, using <b>WSAAccept</b>. In this example, the <i>ConditionFunc </i>is used by the application to provide QoS parameters to the RSVP SP. The RSVP SP learns of the application’s intent to invoke QoS at this time. Since this is a TCP socket, the RSVP SP can call <b>getsockname </b>to unambiguously obtain the address of the sending interface. This address is used to compose the <i>SenderTemplate </i>and to begin sending <i>PATH </i>messages. The RSVP SP calls <b>getpeername </b>following connection establishment to obtain the remote peer’s address. This address is used to generate the RSVP <i>session </i>address.</p>
<table>
<tr valign=top>
<td>
<b>Sending Application</b></td>
<td>
<b>RSVP SP</b></td>
</tr>
<tr valign=top>
<td>
<b>bind </b>(<i>INADDR_ANY</i>)</td>
<td>
</td>
</tr>
<tr valign=top>
<td>
Application calls <b>WSAAccept</b> </td>
<td>
</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
RSVP SP calls <i>ConditionFunc</i></td>
</tr>
<tr valign=top>
<td>
Application completes <i>ConditionFunc</i></td>
<td>
</td>
</tr>
<tr valign=top>
<td>
Transport completes <b>WSAAccept</b></td>
<td>
</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
RSVP SP calls <b>getsockname</b></td>
</tr>
<tr valign=top>
<td>
</td>
<td>
<b>getsockname</b> returns</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
RSVP SP calls <b>getpeername</b></td>
</tr>
<tr valign=top>
<td>
</td>
<td>
<b>getpeername </b>returns</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
Begin sending <i>PATH</i> messages</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
<i>RESV </i>messages received</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
Indicate presence of <i>RESV </i>state to application</td>
</tr>
<tr valign=top>
<td>
Begin sending QoS traffic </td>
<td>
</td>
</tr>
</table><br>
<h3>13.6&#09;TCP Unicast Sender, WSAAccept Followed by WSAIoctl</h3>
<p>
In the following example, a unicast TCP sender accepts a connection from a receiving peer. The sender is the passive peer, indicating its preparedness to receive a connection, using <b>WSAAccept</b>. In this example, the <i>ConditionFunc </i>is not used to provide QoS parameters. Instead, the application follows the acceptance of the connection, with a call to <b>WSAIoctl</b>(<i>SIO_SET_QOS</i>). The RSVP SP learns of the application’s intent to invoke QoS at this time. Since this is a TCP socket, the RSVP SP can call <b>getsockname </b>to unambiguously obtain the address of the sending interface. This address is used to compose the <i>SenderTemplate </i>and to begin sending <i>PATH </i>messages. The RSVP SP calls <b>getpeername </b>following connection establishment, to obtain the remote peer’s address. This address is used to generate the RSVP <i>session </i>address.</p>
<table>
<tr valign=top>
<td>
<b>Sending Application</b></td>
<td>
<b>RSVP SP</b></td>
</tr>
<tr valign=top>
<td>
<b>bind </b>(<i>INADDR_ANY</i>)</td>
<td>
</td>
</tr>
<tr valign=top>
<td>
Application calls <b>WSAAccept</b> </td>
<td>
</td>
</tr>
<tr valign=top>
<td>
Transport completes <b>WSAAccept</b></td>
<td>
</td>
</tr>
<tr valign=top>
<td>
<b>WSAIoctl</b>(<i>SIO_SET_QOS</i>)</td>
<td>
</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
RSVP SP calls <b>getsockname</b></td>
</tr>
<tr valign=top>
<td>
</td>
<td>
<b>getsockname</b> returns</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
RSVP SP calls <b>getpeername</b></td>
</tr>
<tr valign=top>
<td>
</td>
<td>
<b>getpeername </b>returns</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
Begin sending <i>PATH</i> messages</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
<i>RESV </i>messages received</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
Indicate presence of <i>RESV </i>state to application</td>
</tr>
<tr valign=top>
<td>
Begin sending QoS traffic </td>
<td>
</td>
</tr>
</table><br>
<h3>13.7&#09;TCP Unicast Sender, WSAIoctl Precedes WSAAccept</h3>
<p>
This example is similar to the previous example, except that the sending application indicates its interest in sending QoS traffic by calling <b>WSAIoctl</b>(<i>SIO_SET_QOS</i>) prior to connection establishment. In this case, the RSVP SP has all the information required to begin transmitting <i>PATH </i>messages upon completion of <b>WSAAccept, </b>which includes the receiving peer’s address. As in the previous example, the RSVP SP generates the <i>SenderTemplate </i>based on the address returned from <b>getsockname </b>and generates the <i>session </i>based on the address returned from <b>getpeername</b>.</p>
<p>
 </p>
<table>
<tr valign=top>
<td>
<b>Sending Application</b></td>
<td>
<b>RSVP SP</b></td>
</tr>
<tr valign=top>
<td>
<b>bind </b>(<i>INADDR_ANY</i>)</td>
<td>
</td>
</tr>
<tr valign=top>
<td>
<b>WSAIoctl</b>(<i>SIO_SET_QOS</i>)</td>
<td>
</td>
</tr>
<tr valign=top>
<td>
Application calls <b>WSAAccept</b> </td>
<td>
</td>
</tr>
<tr valign=top>
<td>
Transport completes <b>WSAAccept</b></td>
<td>
Peer address extracted by RSVP SP</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
RSVP SP calls <b>getsockname</b></td>
</tr>
<tr valign=top>
<td>
</td>
<td>
<b>getsockname</b> returns</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
RSVP SP calls <b>getpeername</b></td>
</tr>
<tr valign=top>
<td>
</td>
<td>
<b>getpeername </b>returns</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
Begin sending <i>PATH</i> messages</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
<i>RESV </i>messages received</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
Indicate presence of <i>RESV </i>state to application</td>
</tr>
<tr valign=top>
<td>
Begin sending QoS traffic </td>
<td>
</td>
</tr>
</table><br>
<h3>13.8&#09;TCP Unicast Sender, Active Sender</h3>
<p>
In this example, the TCP sender is the active TCP peer. Consequently, the sender calls <b>WSAConnect</b>. This is similar to the UDP sender case, with the exception that the local address and the peer address can be unambiguously determined by calling <b>getsockname</b> and <b>getpeername </b>following connection establishment.</p>
<table>
<tr valign=top>
<td>
<b>Sending Application</b></td>
<td>
<b>RSVP SP</b></td>
</tr>
<tr valign=top>
<td>
<b>bind </b>(<i>INADDR_ANY</i>)</td>
<td>
</td>
</tr>
<tr valign=top>
<td>
<b>WSAConnect </b>(<i>SendingFlowspec</i>) </td>
<td>
</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
RSVP SP calls <b>getsockname</b></td>
</tr>
<tr valign=top>
<td>
</td>
<td>
<b>getsockname</b> returns</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
RSVP SP calls <b>getpeername</b></td>
</tr>
<tr valign=top>
<td>
</td>
<td>
<b>getpeername </b>returns</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
Begin sending <i>PATH</i> messages</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
<i>RESV </i>messages received</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
Indicate presence of <i>RESV </i>state to app</td>
</tr>
<tr valign=top>
<td>
Begin sending QoS traffic </td>
<td>
</td>
</tr>
</table><br>
<h3>13.9&#09;UDP Receiver, Bound to INADDR_ANY, Followed by WSAConnect</h3>
<p>
In this example, a receiving application binds using <i>INADDR_ANY</i>. As a result, the RSVP SP will match any <i>PATH </i>messages for which the <i>session</i> port matches the bound socket’s port, and for which the <i>SenderTemplate</i> matches the peer address specified in the connect, regardless of the <i>session </i>address.</p>
<p>
If <i>PATH </i>messages were received prior to the <b>WSAConnect</b>, and if they are determined to match, the RSVP SP will begin to send <i>RESV </i>messages immediately following the <b>WSAConnect</b>. This is depicted in the following sequence.</p>
<p>
Also in this example, the receiving application issues a <b>WSAConnect</b>. As a result, traffic originating from peers other than the one specified will be discarded by the transport provider. </p>
<table>
<tr valign=top>
<td>
<b>Receiving Application</b></td>
<td>
<b>RSVP SP</b></td>
</tr>
<tr valign=top>
<td>
<b>bind </b>(<i>INADDR_ANY</i>)</td>
<td>
</td>
</tr>
<tr valign=top>
<td>
<b>WSAConnect </b>(<i>ReceivingFlowspec</i>) from app</td>
<td>
</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
Matching <i>PATH </i>messages received</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
RSVP begins sending <i>RESV </i>messages</td>
</tr>
<tr valign=top>
<td>
QoS traffic begins to arrive at application</td>
<td>
</td>
</tr>
</table><br>
<h3>UDP Receiver, Bound to Specific Address, Followed by WSAIoctl</h3>
<p>
In this example, the receiving application binds using a specific address. As a result, the RSVP SP will be more discriminating in searching for matching <i>PATH </i>state. It will match only <i>PATH </i>messages for which both the <i>session </i>address and port match the bound socket’s address and port. However, since no sender was specified (no <b>WSAConnect</b>), <i>SenderTemplate </i>will not be considered when searching for matching <i>PATH </i>state.</p>
<table>
<tr valign=top>
<td>
<b>Receiving Application</b></td>
<td>
<b>RSVP SP</b></td>
</tr>
<tr valign=top>
<td>
</td>
<td>
<i>PATH </i>messages received</td>
</tr>
<tr valign=top>
<td>
<b>bind </b>(specific address)</td>
<td>
</td>
</tr>
<tr valign=top>
<td>
<b>WSAIoctl</b>(<i>SIO_SET_QOS</i>) with <i>ReceivingFlowspec</i></td>
<td>
</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
Match found in received <i>PATH </i>state</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
RSVP begins sending <i>RESV </i>messages</td>
</tr>
<tr valign=top>
<td>
QoS traffic begins to arrive at application</td>
<td>
</td>
</tr>
</table><br>
<h3>13.10&#09;UDP Receiver, WSAIoctl Followed by WSAConnect</h3>
<p>
In the following example, the receiving application calls <b>WSAIoctl</b>(<i>SIO_SET_QOS</i>) to associate QoS parameters with the socket. <i>PATH </i>state is matched at this time, initiating the transmission of WF-style <i>RESV </i>messages. Subsequently, the application calls <b>WSAConnect</b>, specifying a peer sender and causing the RSVP SP to send FF-style <i>RESV </i>messages, selectively, for the specified sender.</p>
<table>
<tr valign=top>
<td>
<b>Receiving Application</b></td>
<td>
<b>RSVP SP</b></td>
</tr>
<tr valign=top>
<td>
</td>
<td>
<i>PATH </i>messages received</td>
</tr>
<tr valign=top>
<td>
<b>bind </b>(<i>INADDR_ANY</i>)</td>
<td>
</td>
</tr>
<tr valign=top>
<td>
<b>WSAIoctl </b>(<i>SendingFlowspec</i>) </td>
<td>
</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
Match found in received <i>PATH </i>state </td>
</tr>
<tr valign=top>
<td>
</td>
<td>
RSVP begins sending WF-style <i>RESV </i>messages</td>
</tr>
<tr valign=top>
<td>
QoS traffic begins to arrive from all senders</td>
<td>
</td>
</tr>
<tr valign=top>
<td>
<b>WSAConnect</b> (no <i>flowspec</i>)</td>
<td>
</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
Match found in received <i>PATH </i>state</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
RSVP begins sending FF-style <i>REV </i>messages</td>
</tr>
<tr valign=top>
<td>
QoS traffic arrives only from sender specified</td>
<td>
</td>
</tr>
</table><br>
<h3>13.11&#09;Multicast UDP Receiver, WSAIoctl Followed by WSAJoinLeaf</h3>
<p>
In the following example, a UDP-receiving application calls <b>WSAIoctl</b>(<i>SIO_SET_QOS</i>) to associate QoS parameters with a multicast socket. Since the socket is multicast and has not yet been joined to a multicast group, no <i>RESV </i>messages will be sent on its behalf. Subsequently, the application calls <b>WSAJoinLeaf </b>to join a multicast group. At this time, <i>PATH </i>state for the multicast group is matched, and the RSVP SP begins sending <i>RESV </i>messages.</p>
<table>
<tr valign=top>
<td>
<b>Receiving Application</b></td>
<td>
<b>RSVP SP</b></td>
</tr>
<tr valign=top>
<td>
</td>
<td>
<i>PATH </i>messages received</td>
</tr>
<tr valign=top>
<td>
<b>bind </b>(specific address)</td>
<td>
</td>
</tr>
<tr valign=top>
<td>
<b>WSAIoctl</b>(<i>SIO_SET_QOS</i>) with <i>ReceivingFlowspec</i></td>
<td>
</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
No match found in received <i>PATH </i>state</td>
</tr>
<tr valign=top>
<td>
Application calls <b>WSAJoinLeaf</b></td>
<td>
</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
Match found in received <i>PATH </i>state</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
RSVP begins sending <i>RESV </i>messages</td>
</tr>
<tr valign=top>
<td>
QoS traffic begins to arrive at application</td>
<td>
</td>
</tr>
</table><br>
<h3>13.12&#09;Multicast UDP Receiver, QoS Parameters in WSAJoinLeaf</h3>
<p>
In this example, QoS parameters are provided at the time the multicast group is joined.</p>
<table>
<tr valign=top>
<td>
<b>Receiving Application</b></td>
<td>
<b>RSVP SP</b></td>
</tr>
<tr valign=top>
<td>
</td>
<td>
<i>PATH </i>messages received</td>
</tr>
<tr valign=top>
<td>
<b>bind </b>(specific address)</td>
<td>
</td>
</tr>
<tr valign=top>
<td>
Application calls <b>WSAJoinLeaf</b></td>
<td>
</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
Match found in received <i>PATH </i>state</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
RSVP begins sending <i>RESV </i>messages</td>
</tr>
<tr valign=top>
<td>
QoS traffic begins to arrive at application</td>
<td>
</td>
</tr>
</table><br>
<h3>13.13&#09;Unicast TCP Receiver, Active Receiver</h3>
<p>
This example illustrates the typical case of active receiver. Recall that, for TCP receivers, <i>PATH </i>state will not be matched until the specific sending peer’s address is known. The RSVP SP determines the sending peer’s address by calling <b>getpeername </b>following connection establishment.</p>
<table>
<tr valign=top>
<td>
<b>Receiving Application</b></td>
<td>
<b>RSVP SP</b></td>
</tr>
<tr valign=top>
<td>
</td>
<td>
<i>PATH </i>messages received</td>
</tr>
<tr valign=top>
<td>
<b>bind </b>(specific address)</td>
<td>
</td>
</tr>
<tr valign=top>
<td>
Application calls <b>WSAConnect</b></td>
<td>
</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
RSVP SP calls <b>getpeername</b></td>
</tr>
<tr valign=top>
<td>
</td>
<td>
<b>getpeername </b>returns</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
Match found in received <i>PATH </i>state</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
RSVP begins sending <i>RESV </i>messages</td>
</tr>
<tr valign=top>
<td>
QoS traffic begins to arrive at application</td>
<td>
</td>
</tr>
</table><br>
<h3>13.14&#09;Unicast TCP Receiver, Passive Receiver</h3>
<p>
This example illustrates the atypical case of a passive receiver. As a passive receiver, the application calls <b>WSAAccept </b>to indicate readiness to accept a connection. In this case, the RSVP SP obtains the peer address by calling <b>getpeername </b>following connection establishment. The peer address returned is used to find matching <i>PATH </i>state for a specific sending peer. </p>
<p>
Note that, in this example, the application does not indicate its interest in receiving QoS traffic using the <i>ConditionFunc</i>. Instead, it does so by providing a <i>ReceivingFlowspec</i> with a call to <b>WSAIoctl</b>(<i>SIO_SET_QOS</i>). In this case, the application calls <b>WSAIoctl</b>(<i>SIO_SET_QOS</i>) after<i> </i>the connection is established, delaying the transmission of <i>RESV </i>messages until that time. Alternatively, it may call <b>WSAIoctl</b>(<i>SIO_SET_QOS</i>) before a connection is established.</p>
<table>
<tr valign=top>
<td>
<b>Receiving Application</b></td>
<td>
<b>RSVP SP</b></td>
</tr>
<tr valign=top>
<td>
</td>
<td>
<i>PATH </i>messages received</td>
</tr>
<tr valign=top>
<td>
<b>bind </b>(specific address)</td>
<td>
</td>
</tr>
<tr valign=top>
<td>
Application calls <b>WSAAccept</b></td>
<td>
</td>
</tr>
<tr valign=top>
<td>
Transport completes <b>WSAAccept</b></td>
<td>
</td>
</tr>
<tr valign=top>
<td>
Application calls <b>WSAIoctl</b>(<i>SIO_SET_QOS</i>)</td>
<td>
</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
RSVP SP calls <b>getpeername</b></td>
</tr>
<tr valign=top>
<td>
</td>
<td>
<b>getpeername </b>returns</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
Match found in received <i>PATH </i>state</td>
</tr>
<tr valign=top>
<td>
</td>
<td>
RSVP begins sending <i>RESV </i>messages</td>
</tr>
<tr valign=top>
<td>
QoS traffic begins to arrive at application</td>
<td>
</td>
</tr>
</table><br>
<h2>14&#09;Bibliography</h2>
<ul>
<li>
<i>Windows Sockets 2 Protocol-Specific Annex, rev. 2.0.2, January22, 1996</i><br><br></li>
<li>
Windows Sockets 2 Application Programming Interface, rev. 2.2.0, May, 1996<br><br></li>
<li>
Windows Sockets 2 Service Provider Interface, rev. 2.2.0, May, 1996<br><br></li>
<li>
IETF Draft of RSVP Protocol, version 14, November 5, 1996<br><br></li>
<li>
The Use of RSVP With Integrated Services (from the INTSERV WG of the IETF)</li>
</ul>
<p>
&copy; 1997 Microsoft Corporation. All rights reserved. </p>
<p>
The information contained in this document represents the current view of Microsoft Corporation on the issues discussed as of the date of publication. Because Microsoft must respond to changing market conditions, it should not be interpreted to be a commitment on the part of Microsoft, and Microsoft cannot guarantee the accuracy of any information presented after the date of publication.</p>
<p>
This document is for informational purposes only. MICROSOFT MAKES NO WARRANTIES, EXPRESS OR IMPLIED, IN THIS SUMMARY.</p>
<p>
Microsoft and Windows are registered trademarks of Microsoft Corporation. </p>
<p>
Other product or company names mentioned herein may by the trademarks of their respective owners.</p>
</font></BODY>
</HTML>
