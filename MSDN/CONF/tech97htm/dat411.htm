<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Microsoft SQL Server Performance Tuning and Optimization for Developers, Part 2: The Query Optimizer</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>



	<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>



	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<h1>Microsoft SQL Server Performance Tuning and Optimization for Developers, Part 2: The Query Optimizer</h1>
<p>
Adam Shapiro</p>
<h3>Objectives</h3>
<ul>
<li>
List the steps in processing a query.<br><br></li>
<li>
Distinguish between search arguments and non-search arguments.<br><br></li>
<li>
Describe how the query optimizer uses index statistics to develop a query plan.<br><br></li>
<li>
Describe how the query optimizer calculates the cost of a query.<br><br></li>
<li>
Describe how joins are processed.</li>
</ul>
<h2>Query Optimizer Overview</h2>
<p>
The query optimizer evaluates each SQL statement and determines the best plan of execution.</p>
<p>
Understanding how the query optimizer works will help you write better queries and create useful indexes.</p>
<h3>Purpose of the Query Optimizer</h3>
<p>
<img src="dat411_3.gif" border=0></p>
<p>
<b>Determining the most efficient plan</b></p>
<p>
The query optimizer determines the best plan for retrieving data and the order of execution for data manipulation queries, such as SELECT, INSERT, UPDATE, and DELETE. The query optimizer produces a query plan that outlines the sequence of steps required to perform the query. The optimizer can only optimize the processes of finding rows, joining rows, and ordering rows.</p>
<p>
<b>SQL Server uses cost-based optimization</b></p>
<p>
A cost-based optimizer evaluates each query plan generated and estimates the cost of executing the plan in terms of the number of rows returned and the amount of physical disk I/O required for each relational operation.</p>
<p>
A cost-based optimizer uses its knowledge of underlying data and storage structures such as table size, table structure, and available indexes. It also estimates the selectivity of each relational operation based on the statistics kept for each index.</p>
<p>
By evaluating various orderings of the relational operations required to produce the results set, a cost-based optimizer arrives at an execution plan that has the lowest estimated cost in terms of system overhead. </p>
<p>
The cost estimates can only be as accurate as the available statistical data that estimates the selectivity of each relational operation.</p>
<p>
Performance of a query is determined by the speed of the individual tactics and by whether an efficient join order was selected. The query optimizer chooses to limit the number of choices it considers, so it can run in a reasonable amount of time.</p>
<p>
Performance is also measured by the amount of logical and physical page access.</p>
<p>
The query optimizer considers both logical and physical access to evaluate the cost of a query plan. It also takes into account that a fixed percentage of pages are in cache.</p>
<p>
The query optimizer evaluates strategies to find the one with the least amount of work, which is the accumulation of CPU and I/O time. The amount of physical I/O is used to measure this. The goal is to reduce the amount of physical I/O.</p>
<p>
Understanding how the query optimizer works should provide you with insights to help you write better queries, choose better indexes, and detect performance problems.</p>
<h3>Where Does Query Optimization Fit in?</h3>
<p>
<img src="dat411_4.gif" border=0></p>
<p>
After a query is submitted to SQL Server, several steps occur to transform the original query into a format that the optimizer can interpret. The following briefly outlines the steps that must occur before the query can be processed and a results set returned.</p>
<p>
<b>Parsing process</b></p>
<p>
The parsing process checks the incoming query for correct syntax and breaks down the syntax into component parts that can be understood by the relational database management system. The output of this step is a parsed query tree.</p>
<p>
<b>Standardization process</b></p>
<p>
The standardization process transforms a query into a useful format for optimization. Any redundant syntax clauses that are detected are removed. Subqueries are flattened if possible. The output of this step is a standardized query tree.</p>
<p>
<b>Query optimization</b></p>
<p>
The query optimizer produces an efficient query plan for processing the query. There are three steps involved in this phase: query analysis, index selection, and join selection. The query optimizer automatically limits the number of possible execution plans. The output of this step is called an execution plan or a query plan.</p>
<p>
<b>Compilation</b></p>
<p>
The code is compiled into executable code.</p>
<p>
<b>Database access routines</b></p>
<p>
The optimizer has determined the best method to access data, choosing to perform a table scan or use an available index. That method is now applied.</p>
<h3>Query Optimizer Information</h3>
<p>
<img src="dat411_5.gif" border=0></p>
<p>
The query optimizer analyzes the information it has available to determine the best choice of query plan.</p>
<p>
<b>The <i>sysindexes</i> table</b></p>
<p>
The optimizer can use the following information in <i>sysindexes</i>:</p>
<table>
<tr valign=top>
<td>
Column Name</td>
<td>
Description</td>
</tr>
<tr valign=top>
<td>
<i>indid</i></td>
<td>
ID of the index. Possible values are:<p>
0 &#09;&#09;Table (nonclustered table)</p>
<p>
1 &#09;&#09;Clustered index</p>
<p>
&gt;1 &#09;&#09;Nonclustered</p>
<p>
255 &#09;Entry for tables that have text or image data</p>
</td>
</tr>
<tr valign=top>
<td>
<i>dpages</i></td>
<td>
For indid = 0 or indid = 1, dpages is the count of used data-only pages. For indid = 255, rows is set to 0. Otherwise dpages is the count of leaf-level index pages.</td>
</tr>
<tr valign=top>
<td>
<i>rows</i></td>
<td>
The data-level row count based on indid = 0 or indid = 1. This value is repeated for indid &gt; 1. For indid = 255, rows is set to 0.</td>
</tr>
<tr valign=top>
<td>
<i>distribution</i></td>
<td>
Pointer to distribution page (if entry is an index).</td>
</tr>
<tr valign=top>
<td>
<i>rowpage</i></td>
<td>
Maximum count of rows per page.</td>
</tr>
<tr valign=top>
<td>
<i>minlen</i></td>
<td>
Minimum size of a row.</td>
</tr>
<tr valign=top>
<td>
<i>maxlen</i></td>
<td>
Maximum size of a row.</td>
</tr>
<tr valign=top>
<td>
<i>maxirow</i></td>
<td>
Maximum size of a nonleaf index row</td>
</tr>
<tr valign=top>
<td>
<i>keys1</i></td>
<td>
Description of key columns (if entry is an index).</td>
</tr>
<tr valign=top>
<td>
<i>keys2</i></td>
<td>
Description of key columns (if entry is an index).</td>
</tr>
<tr valign=top>
<td>
<i>soid</i></td>
<td>
Sort order ID that the index was created with; 0 if there is no character data in the keys.</td>
</tr>
<tr valign=top>
<td>
<i>csid</i></td>
<td>
Character set ID that the index was created with; 0 if there is no character data in the keys.</td>
</tr>
</table><br>
<p>
<b>Statistical distribution of key values</b></p>
<p>
This information is found on the distribution page. </p>
<p>
<b>The query to be executed</b></p>
<p>
The query gives the optimizer the selection criteria it needs to determine which index, if any, would be most useful. The way that row qualifications are expressed in the query can affect the optimizer’s decisions.</p>
<p>
<b>SHOWPLAN</b></p>
<p>
This SET statement option will report the optimizer’s final decision on which indexes have been selected for use with which tables, the order in which the tables will be joined, and the update mode selected. Work tables and other strategies are also reported in the SHOWPLAN output.</p>
<h2>Phase One: Query Analysis</h2>
<p>
<img src="dat411_6.gif" border=0></p>
<p>
The first phase of the query optimizer is called query analysis. In this phase the optimizer looks at each clause that was parsed and determines whether it can be optimized. Clauses that can be optimized are those that limit a scan &#45; for example, those containing a search argument or join clause. For those clauses that can be optimized, the optimizer determines whether there is an appropriate index.</p>
<h3>Search Arguments</h3>
<p>
<img src="dat411_7.gif" border=0></p>
<p>
A search argument limits a search because it is very specific in the information it is requesting. It specifies an exact match, a range of values, or a conjunction of two or more items joined by an AND operator. A search argument contains a constant expression that acts on a column using an operator. 
<ul>
<li>
Format for search arguments is: <p>
&lt;column&gt; &lt;inclusive operator&gt; &lt;constant&gt; [AND...]<BR>OR<BR>&lt;constant&gt; &lt;inclusive operator&gt; &lt;column&gt; [AND...]</p>
</li>
<li>
Common operators include &gt;, &lt;, =, BETWEEN, LIKE.<br><br></li>
<li>
All columns must be in the same table.<br><br></li>
<li>
A search argument can contain multiple conditions if they are linked with ANDs.</li>
</ul>
<p>
<b>Examples</b></p>
<pre><FONT FACE="Courier New" SIZE="2">name = 'jones'
salary &gt; 40000
60000 &lt; salary
department = 'sales'
name = 'jones' AND salary &gt; 100000
</font></pre>
<h3>Non-Search Arguments</h3>
<p>
<img src="dat411_8.gif" border=0></p>
<p>
If an expression does not limit a search, it is considered a non-search argument. This includes expressions that are exclusive rather than inclusive. </p>
<p>
For example, a not-equal (!=) expression must first look at all the data before it can determine which data does not fit the search criteria.</p>
<p>
Another example is a comparison between columns, such as:</p>
<pre><FONT FACE="Courier New" SIZE="2">salary = commission
</font></pre>
<p>
Because both columns are contained in the table itself, an index may not be very useful.</p>
<p>
Another example is one that involves computation prior to data access. For example:</p>
<pre><FONT FACE="Courier New" SIZE="2">salary * 12 &gt; 36000
</font></pre>
<p>
In this case, the salary column must be accessed and the calculation performed before SQL Server can determine whether a row qualifies.</p>
<p>
<b>Class discussion</b></p>
<p>
What are the search arguments in the following query?</p>
<pre><FONT FACE="Courier New" SIZE="2">SELECT COUNT(*) <BR>FROM dept, empl, job<BR>WHERE empl.age &gt; 30<BR>AND (dept.floor = 2 OR dept.floor = 3)<BR>AND job.rate &gt; $20.00<BR>AND empl.jobno = job.jobno
</font></pre>
<h3>Converting Non-search Arguments</h3>
<p>
<img src="dat411_9.gif" border=0></p>
<p>
In many cases, non-search arguments can be rewritten into search arguments. A query that contains a search argument increases the chances that the optimizer will select an index.</p>
<p>
Expressions that involve computations on a column can be converted into a search argument by isolating the column.
<ul>
<li>
Non-search argument&#09;&#09;&#09;&#09;<code>WHERE price * 12 = 100</code><br><br></li>
<li>
Search argument&#09;&#09;&#09;&#09;&#09;<code>WHERE price = 100/12</code><p>
<b>Tip</b>&nbsp;&nbsp;&nbsp;When writing queries, keep the column information on one side of the operator and the search criterion on the other.</p>
</li>
</ul>
<p>
Some expressions are internally modified by the query optimizer into search arguments, such as BETWEENs and LIKEs.
<ul>
<li>
A BETWEEN clause is equivalent to a range expressed with &gt; = and &lt;&nbsp;= to define the bounds.<br><br></li>
<li>
A LIKE expression can be processed by an index if the first character of the expression is a constant &#45; for example, <code>name LIKE 'jo%'</code>. This is the same as <code>name <font face="Symbol"><span style="font-family:Symbol">&#179;</span></font> 'jo' AND name &lt; 'jp'</code>. The expression <code>name</code> <code>LIKE '%jo'</code> is not a search argument because it does not limit the search.</li>
</ul>
<p>
<b>Using non-search arguments to avoid the use of an index</b></p>
<p>
If you want the query optimizer to avoid selecting a particular index, you can use a non-search argument in the search clause &#45; for example, add a zero to the column as follows:</p>
<pre><FONT FACE="Courier New" SIZE="2"> salary + 0 &gt; 30000
</font></pre>
<p>
This statement guarantees that the optimizer will not evaluate an index on <i>salary</i>.</p>
<h3>OR Clauses</h3>
<p>
<img src="dat411_10.gif" border=0></p>
<p>
OR clauses are mentioned here because they are detected as part of query analysis. They will be covered in much more detail later.</p>
<h3>Join Clauses</h3>
<p>
<img src="dat411_11.gif" border=0></p>
<p>
Retrieving data from two or more tables requires a join clause. A join clause links the data from various tables in the same database or in different databases.</p>
<p>
A self-join is also an example of a join clause.</p>
<p>
<b>Example</b></p>
<pre><FONT FACE="Courier New" SIZE="2">SELECT e1.manager_name, e2.name<BR>FROM empl e1, empl e2<BR>WHERE e1.emplno = e2.manager_no
</font></pre>
<h2>Phase Two: Index Selection</h2>
<p>
<img src="dat411_12.gif" border=0></p>
<p>
Index selection is the second phase of query optimization. During this phase, the query optimizer determines whether an index exists for a clause, assesses the usefulness by determining the selectivity of the clause (how many rows will be returned), and estimates the number of page accesses (both logical and physical) required to find the qualifying rows.</p>
<h3>Determining Whether a Useful Index Exists</h3>
<p>
<img src="dat411_13.gif" border=0></p>
<p>
The first step in determining whether a useful index exists is to check for an index that matches the clause.</p>
<p>
An index is useful if:
<ul>
<li>
The first column of the index is used in the search argument.<br><br></li>
<li>
A search argument establishes a lower bound, upper bound, or both, to limit the search.</li>
</ul>
<p>
<b>Considerations</b></p>
<p>
The query optimizer can evaluate using a nonclustered index if the high-order column is specified in the WHERE clause.</p>
<p>
The query optimizer can always evaluate a covering index regardless of whether the indexed column is specified in the WHERE clause.</p>
<h3>Determining the Selectivity of a Clause</h3>
<p>
<img src="dat411_14.gif" border=0></p>
<p>
<b>If statistics are available</b></p>
<p>
After a useful index is found that matches the clause, its usefulness is assessed by determining the selectivity of the clause. Even if a useful index is present, it may not be used if the optimizer determines that index access is not the best access method. The selectivity is determined by estimating the number of rows that satisfy the clause. If statistics are available, the server evaluates indexes using the distribution steps. </p>
<p>
<b>If no statistics are available</b></p>
<p>
If no statistics are available, the server uses fixed percentages depending on the operator.</p>
<p>
The optimizer uses the following defaults if no statistics are available:</p>
<table>
<tr valign=top>
<td>
<b>Operator</b></td>
<td>
<b>Assumed Percentage of Rows</b></td>
</tr>
<tr valign=top>
<td>
=</td>
<td>
10%</td>
</tr>
<tr valign=top>
<td>
&gt;</td>
<td>
33%</td>
</tr>
<tr valign=top>
<td>
&lt;</td>
<td>
33%</td>
</tr>
<tr valign=top>
<td>
BETWEEN</td>
<td>
25%</td>
</tr>
</table><br>
<p>
A special case is when the optimizer recognizes that there is an equality in the WHERE clause and the index is unique. Because this is an exact match and always returns one row, the optimizer doesn’t have to use statistics.</p>
<p>
There will be no statistics available if the index was created before there was any data in the table, or if the table has been truncated.</p>
<h3>Index Statistics</h3>
<p>
<img src="dat411_15.gif" border=0></p>
<p>
Statistics are used by the optimizer to estimate how useful an index is in limiting a search or in deciding the join order for multiple table queries. Statistics are kept on every index to provide information about the distribution of values in a given index.</p>
<p>
In SQL Server, an even distribution of values is maintained for the index statistics. The number of rows per step remains constant while the key value ranges change. (In a standard distribution, the key value ranges remain constant while the number per range changes.) An even distribution allows the query optimizer to easily determine the selectivity of a query by estimating the number of qualifying rows as a percentage of the total rows in the table.</p>
<h3>Distribution Page</h3>
<p>
<img src="dat411_16.gif" border=0></p>
<p>
The distribution page represents a sampling of the values contained in the index.</p>
<p>
To determine whether a distribution page has been created for an index, query the <i>distribution</i> column in the <i>sysindexes</i> table. A zero in the <i>distribution</i> column indicates that no statistics are available for that index. Otherwise, the number indicates the location of the distribution page.</p>
<p>
Executing UPDATE STATISTICS creates a distribution page for each index on a table.</p>
<p>
The density refers to the average number of duplicates. A separate value is maintained for each left-based subset of columns in a composite index.</p>
<h3>Distribution Steps</h3>
<p>
<img src="dat411_17.gif" border=0></p>
<p>
The size of the index key determines the total number of distribution steps for each index. A limit is imposed by the number of values that can fit on the distribution page. The first and last key values in the index are always included.
<ul>
<li>
Data is divided into equal steps, each containing the same number of rows.<br><br></li>
<li>
The number of steps is based on the size of the index key.<br><br></li>
<li>
There is one index key per step.<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;Because the first index key is always included on the distribution page, subtract one from the number of index keys per page to get the total number of distribution steps.</p>
</li>
</ul>
<p>
The total number of distribution steps is then divided into the total number of index keys to determine the number of keys to be included in each step. One index key at each step is recorded on the distribution page. SQL Server calculates the size of the step.</p>
<p>
The number of index keys per page minus 1 equals the number of distribution steps. The greater the number of steps, the more accurate the information is. Indexes with smaller keys have more accurate statistics. If the number of steps equals the total number of rows, you have complete information.</p>
<p>
For composite indexes, only the keys in the first column are used to determine the distribution steps.</p>
<h3>Distribution Steps: Example</h3>
<p>
<img src="dat411_18.gif" border=0></p>
<p>
<b>Calculating the number of distribution steps</b></p>
<p>
Index key size = 250 bytes</p>
<p>
<img src="dat411_19.gif" border=0></p>
<p>
8 index keys per page minus 1 = 7 distribution steps</p>
<p>
Total number of index keys = 22</p>
<p>
<img src="dat411_20.gif" border=0></p>
<p>
There are a total of 7 steps, with 3 keys per step.</p>
<p>
One seventh of the table is in each step.</p>
<p>
One index key at each step (every third row) is placed on the distribution page.</p>
<p>
<b>Class example</b></p>
<p>
Index key size = 18 bytes</p>
<p>
How many index keys per page?__________________________________</p>
<p>
How many distribution steps?_____________________________________</p>
<p>
Total number of index keys = 94,795</p>
<p>
How many keys per step?________________________________________</p>
<p>
How much of the table is in each step?______________________________</p>
<h3>Looking at Distribution Steps</h3>
<p>
<img src="dat411_21.gif" border=0></p>
<p>
<b>Syntax</b></p>
<p>
<b>DBCC SHOW_STATISTICS (<i>table_name</i>, <i>index_name</i>)</b></p>
<p>
Displays all the statistical information in the distribution page for an index (<i>index_name</i>) on a specified table (<i>table_name</i>). The results returned indicate the selectivity of an index (the lower the density returned, the higher the selectivity) and provide the basis for determining whether or not an index would be useful to the optimizer.</p>
<p>
<b>Enterprise manager</b></p>
<p>
Using SQL Enterprise Manager, on the Manage menu you can click Indexes, or drill down to the name of a table, right-click the name, and then click Indexes. In either case, you will get a dialog box that enables you to examine any index on any table in the database.</p>
<p>
Click the Distribution button and you will see much of the same information that DBCC SHOW_STATISTICS provides.</p>
<h3>UPDATE STATISTICS</h3>
<p>
<img src="dat411_22.gif" border=0></p>
<p>
<b>UPDATE STATISTICS [[<i>database</i>.]<i>owner</i>.]<i>table</i>_<i>name</i> [<i>index</i>_<i>name</i>]</b></p>
<p>
The <i>table_name </i>parameter specifies the table with which the index is associated. It is required because SQL Server does not require index names to be unique in a database.</p>
<p>
The <i>index_name </i>parameter specifies the index to be updated. If an index name is not specified, the distribution statistics for all indexes in the specified table are updated. To see a list of index names and descriptions, execute the <b>sp_helpindex</b> system stored procedure with the table name.</p>
<p>
<b>Syntax</b></p>
<p>
<b>STATS_DATE&nbsp;&nbsp;&nbsp;&nbsp;(<i>table_id</i>, <i>index_id</i>)&#09;</b></p>
<p>
This function returns the date that the statistics for the specified index (<i>index_id</i>) were last updated.</p>
<p>
<b>Example</b></p>
<p>
To see the date on which the statistics were updated for all indexes on a table, use the following statement:</p>
<pre><FONT FACE="Courier New" SIZE="2">SELECT 'Index Name' = i.name, 'Statistics Updated' = <BR>&#09;stats_date(i.id, i.indid)
FROM sysobjects o, sysindexes i
WHERE o.name = 'charge' AND o.id = i.id
</font></pre>
<h3>Exceptions to Using Statistics</h3>
<p>
<img src="dat411_23.gif" border=0></p>
<p>
There are some cases in which statistics are not used. This happens when statistics are not available or there is an unknown value in a WHERE clause. Statistics will be unavailable if the index was created before any data was put into the table and UPDATE STATISTICS has not been run, or if the table has been truncated.</p>
<p>
<b>Unknown value</b></p>
<p>
<b> Example</b></p>
<pre><FONT FACE="Courier New" SIZE="2">DECLARE @var int<BR>SELECT @var = 15<BR>SELECT X FROM Y WHERE col = @var
</font></pre>
<p>
Because the WHERE clause contains an unknown value, the key values in the index statistics cannot be used. However, if the operator is =, SQL Server will use the density information to estimate the number of qualifying rows.</p>
<p>
The fixed percentages are slightly different from the default numbers used if there are no statistics.</p>
<table>
<tr valign=top>
<td>
<b>Operator</b></td>
<td>
<b>Assumed Percentag be of Rows</b></td>
</tr>
<tr valign=top>
<td>
</td>
<td>
</td>
</tr>
<tr valign=top>
<td>
=</td>
<td>
Determined by density</td>
</tr>
<tr valign=top>
<td>
&lt;, &gt;, BETWEEN</td>
<td>
33%</td>
</tr>
</table><br>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;Just because statistics are available does not mean they are up to date.</p>
<h3>Determining the Amount of Page Access</h3>
<p>
<img src="dat411_24.gif" border=0></p>
<p>
As a second part of determining the selectivity of a clause, the query optimizer calculates the logical page estimates based on row estimates. This determines the best index to select for a particular clause. There can be a big difference between the page estimates for a clustered index and a nonclustered index. With a nonclustered index, the query optimizer assumes the worst-case scenario: that each row will be found on a different page. This factors into the cost-based optimization calculation of the query optimizer.</p>
<p>
<b>For no index</b></p>
<p>
Logical page accesses = total number of data pages in table.</p>
<p>
<b>For a clustered index</b></p>
<p>
Logical page accesses = number of levels in index plus the number of data pages to scan (data pages = number of qualifying rows / rows per data page).</p>
<p>
<b>For a nonclustered index</b></p>
<p>
Logical page accesses = number of levels in index plus the number of leaf pages (qualifying rows / rows per leaf page) plus the number of qualifying rows. (This assumes each row is on a separate page.)</p>
<p>
<b>For a covering index</b></p>
<p>
Logical page accesses = number of levels in the index plus the number of leaf pages (qualifying rows / rows per leaf page).</p>
<p>
<b>For a unique index</b></p>
<p>
If the query is searching for an equality on all parts of the key of a unique index, logical page accesses = 1 plus the number of index levels.</p>
<h2>Phase Three: Join Selection</h2>
<p>
<img src="dat411_25.gif" border=0></p>
<p>
Join selection is the third major step in the query optimization phase. If there is a multiple table query or self-join, the optimizer will evaluate join selection. The optimizer compares how the clauses are ordered and selects the join plan with the lowest estimated processing costs in terms of logical page I/O.</p>
<h3>Determining the Selectivity of a Join Clause</h3>
<p>
<img src="dat411_26.gif" border=0></p>
<p>
Join selectivity determines how many rows from table A will join with a single row from table B. This is different from determining how many rows match a search argument. Join selectivity is a useful element in determining the order in which joins will be processed.</p>
<p>
If statistics are available, join selectivity is based on the density of the index. If statistics are not available, the heuristic is 1 divided by the number of rows in the smaller table.</p>
<p>
Join selectivity refers to the number of rows expected from a join clause. This can be calculated or based on density (average percentage of duplicate rows).</p>
<p>
<b>Join clause example</b></p>
<pre><FONT FACE="Courier New" SIZE="2">WHERE dept.deptno = empl.deptno
</font></pre>
<p>
Assumptions:<BR>&nbsp;&nbsp;&nbsp;&nbsp;1,000 employees<BR>&nbsp;&nbsp;&nbsp;&nbsp;100 departments</p>
<p>
Intuitively one would estimate that there are 10 employees per department. Because the query optimizer lacks intuition, it must calculate the selectivity through other means.</p>
<p>
The selectivity for the above clause is 1 / 100 or .01.</p>
<p>
Given a row in the <i>department</i> table, the number of rows in the <i>employee</i> table that join it is: 1,000 * .01 = 10</p>
<p>
Given a row in the <i>employee</i> table, the number of rows in the <i>department</i> table that join it is: 100 * .01 = 1</p>
<h3>Nested Iteration of Joins</h3>
<p>
<img src="dat411_27.gif" border=0></p>
<p>
If there is a join clause in the query, the optimizer evaluates the number of tables, indexes, and joins to determine the optimal order for the nested iteration.</p>
<p>
<b>Strategy</b>
<ul>
<li>
Four tables at a time are evaluated to determine optimum join order.<br><br></li>
<li>
Projects value from next qualifying row in outer table into inner query.<br><br></li>
<li>
Outer table search argument can use an index because it limits the search.<br><br></li>
<li>
Processes single-table queries according to previously described tactics.</li>
</ul>
<p>
<b>Guidelines</b>
<ul>
<li>
Add more join clauses to allow the optimizer more choices in query plans.<br><br></li>
<li>
Add redundant clauses.</li>
</ul>
<h3>Nested Iteration of Joins: Example</h3>
<p>
<img src="dat411_28.gif" border=0></p>
<p>
The optimizer may choose to do a nested iteration of joins. If this strategy is chosen, SQL Server constructs a set of nested loops by finding a row from the first table and then using that row to scan the next table, and so on until the result that matches is used to scan the last table. The results set is narrowed down as it progresses from table to table with each iteration.</p>
<p>
The query plan specifies the ordered set of nested tables to use. The number of different possible plans is related to the number of tables, indexes, and joins.</p>
<h3>Join of <i>titles</i> to <i>titleauthor</i>: Example</h3>
<p>
<img src="dat411_29.gif" border=0></p>
<p>
<b>Example</b></p>
<pre><FONT FACE="Courier New" SIZE="2">SELECT title <BR>FROM titles, titleauthor<BR>WHERE titles.title_id = titleauthor.title_id <BR>AND titleauthor.royaltyper &gt; 50
</font></pre>
<p>
Processing steps
<ol>
<li>
Get next row of <i>titles</i>.<br><br></li>
<li>
Get value of <i>title_id</i>.<p>
Using index on <i>title_id</i>, locate each matching row in <i>titleauthor</i>.</p>
<p>
Compare value of <i>royaltyper</i>, and return row if it’s &gt; 50.</p>
</li>
<li>
Repeat Steps 1 and 2 until all qualifying rows in the outer table have been accessed.</li>
</ol>
<h3>Join of <i>titleauthor</i> to <i>titles</i>: Example</h3>
<p>
<img src="dat411_30.gif" border=0></p>
<p>
<b>Example</b></p>
<pre><FONT FACE="Courier New" SIZE="2">SELECT title <BR>FROM titles, titleauthor<BR>WHERE titles.title_id = titleauthor.title_id <BR>AND titleauthor.royaltyper &gt; 50
</font></pre>
<p>
Processing steps
<ol>
<li>
Get next row of <i>titleauthor</i> WHERE <i>royaltyper</i> &gt; 50.<br><br></li>
<li>
Use index on <i>title_id</i> to search <i>titles</i> and return rows.<br><br></li>
<li>
Repeat Steps 1 and 2 until all qualifying rows in the outer table have been accessed.</li>
</ol>
<h3>Three-Way Join: Examples</h3>
<p>
<img src="dat411_31.gif" border=0></p>
<p>
<b>Example</b></p>
<pre><FONT FACE="Courier New" SIZE="2">SELECT t.title, a.au_lname <BR>FROM titles t, authors a, titleauthor ta<BR>WHERE t.title_id = ta.title_id<BR>&#09;AND a.au_id = ta.au_id<BR>&#09;AND a.au_lname = 'Green'
</font></pre>
<p>
<b>Example 1</b></p>
<p>
<b><i>titles</i> to <i>ta</i> (<i>titleauthor</i>) to <i>authors </i>(shown above)</b></p>
<p>
Because there are three titles, search <i>titleauthor</i> three times and search <i>authors</i> six times.</p>
<p>
<b>Example 2</b></p>
<p>
<b><i>authors</i> to <i>ta</i> (<i>titleauthor</i>) to <i>titles </i>(shown above)</b></p>
<p>
Because there is only one <b>author = Green</b>, search <i>titleauthor</i> one time and search <i>titles</i> two times.</p>
<p>
The difference in these examples is that <i>authors</i> is searched six times in the first case and only one time in the second case.</p>
<p>
Key points
<ul>
<li>
As the number of tables increases, the number of iterations of the inner table increases. <br><br></li>
<li>
The cost of a table search depends on whether there are useful indexes. <br><br></li>
<li>
The cost of the search is also related to the number of rows returned from each level in addition to the size of the tables.</li>
</ul>
<h2>Choosing the Best Plan</h2>
<p>
<img src="dat411_32.gif" border=0></p>
<h3>Calculating the Total Cost</h3>
<ul>
<li>
For each permutation, the query optimizer figures out which indexes and join strategies are best.<p>
It calculates the costs for each join order.</p>
</li>
<li>
For each table, the query optimizer calculates the number of logical page accesses.<p>
The query optimizer recognizes that if the index is unique and the WHERE clause equals a specific value, the cost is always one page access plus the number of levels in the index.</p>
</li>
<li>
The query optimizer takes into account the size of each table relative to cache.</li>
</ul>
<h3>Summary of Query Processing Phases</h3>
<p>
<img src="dat411_33.gif" border=0></p>
<h3>SHOWPLAN Output</h3>
<p>
<img src="dat411_34.gif" border=0></p>
<p>
The output from the SHOWPLAN parameter of the SET statement details the final access method that the query optimizer chooses for processing a query. Below is an explanation of the output messages.</p>
<p>
<b>STEP </b><i>n</i></p>
<p>
This statement is included in the SHOWPLAN output for every query. In some cases, SQL Server cannot effectively retrieve the results in a single step, so it breaks the query plan down into several steps.</p>
<p>
<b>The type of query is &lt;</b><i>query type</i><b>&gt;</b></p>
<p>
This statement describes the type of query (SELECT, INSERT, UPDATE, or DELETE) used in each step. If SHOWPLAN is turned on while other commands are issued, &lt;<i>query type</i>&gt; reflects the issued command.</p>
<p>
<b>The update mode is deferred</b></p>
<p>
This statement indicates that the update mode that was selected is deferred. </p>
<p>
<b>The update mode is direct</b></p>
<p>
This statement indicates that the update mode that was selected is direct. </p>
<p>
<b>GROUP BY</b></p>
<p>
This appears in the SHOWPLAN output for any query that contains a GROUP BY clause. A GROUP BY always requires at least two steps: one step to select the qualifying rows into a worktable and group them, and another step to return the results.</p>
<p>
<b>Scalar aggregate</b></p>
<p>
This indicates that an aggregate function was used in the SELECT statement. Because a single value is returned, regardless of the number of rows involved, the first step calculates the aggregate and the second step returns the final value.</p>
<p>
<b>Vector aggregate</b></p>
<p>
If a GROUP BY clause is used in conjunction with an aggregate function, the query optimizer uses a vector aggregate. A single value is returned for each group. </p>
<p>
<b>FROM TABLE</b></p>
<p>
This statement indicates the name of the table that the query is accessing. The order of the tables listed after FROM TABLE indicates the order in which the tables were joined together to process the query. </p>
<p>
<b>TO TABLE</b></p>
<p>
This indicates the target table that is being modified. In some cases, the table is a worktable rather than a physical table in the database.</p>
<p>
<b>Worktable</b></p>
<p>
This indicates that a temporary table was created to hold the intermediate results of a query. This occurs when rows need to be sorted. Worktables are always created in the <i>tempdb</i> database and are automatically dropped after the results are returned.</p>
<p>
<b>Worktable created for &lt;</b><i>query type</i><b>&gt;</b></p>
<p>
This indicates that a worktable was created to process a query. The <i>query type </i>could be: SELECT_INTO, DISTINCT, or ORDER BY, or the worktable could be created for the purposes of REFORMATTING.</p>
<p>
<b>This step involves sorting</b></p>
<p>
This indicates that the intermediate results of the query must be sorted before they are returned to the user. This happens when there is no useful index for queries that either specify DISTINCT or that include an ORDER BY.</p>
<p>
<b>Using GETSORTED</b></p>
<p>
This indicates that SQL Server has created a temporary worktable to sort the rows in the results set. Note that not all queries that return rows in sorted order use this step.</p>
<p>
<b>Nested iteration</b></p>
<p>
Nested iteration is the default technique of the optimizer, and this phrase occurs in all SHOWPLAN output.</p>
<p>
<b>EXISTS TABLE: nested iteration</b></p>
<p>
This statement indicates a nested iteration on a table that is used as part of an existence test. In Transact-SQL, an existence test can be written as EXISTS, IN, or =ANY.</p>
<p>
<b>Table scan</b></p>
<p>
This indicates that the query optimizer has selected the table scan strategy to retrieve the results.</p>
<p>
<b>Using clustered index</b></p>
<p>
This indicates that the query optimizer is using the clustered index to retrieve the results set.</p>
<p>
<b>Index: &lt;</b><i>index name</i><b>&gt;</b></p>
<p>
This indicates the name of the nonclustered index that the query optimizer is using to retrieve the results set.</p>
<p>
<b>Using dynamic index</b></p>
<p>
This indicates that the optimizer has chosen to build its own index as part of the OR processing strategy.</p>
<h3>STATISTICS IO Output</h3>
<p>
<img src="dat411_35.gif" border=0></p>
<p>
The output from STATISTICS IO includes the following values:
<ul>
<li>
Logical Reads<p>
This value indicates the total number of pages that were accessed to process this query. All page accesses are done through the data cache, so if a page is not already available in cache, it must be read in.</p>
</li>
<li>
Physical Reads<p>
This value indicates the number of pages that were read in from disk. It will always be less than or equal to the value of Logical Reads.</p>
<p>
The value of Cache Hit Ratio can be computed from the above two values as follows:</p>
<p>
&#09;Cache Hit Ratio = (Logical Reads – Physical Reads) / Logical Reads</p>
</li>
<li>
Read Ahead Reads<p>
This value indicates the number of pages that were read into cache by the Read Ahead Manager. A high number for this value will mean that the value for Physical Reads is lower, and the Cache Hit Ratio is higher than if read ahead was not enabled.</p>
</li>
<li>
Scan Count<p>
This value indicates the number of times that the corresponding table was accessed. Outer tables should always have a scan count of 1. For inner tables, the number of Logical Reads will be determined by the Scan Count times the number of pages accessed on each scan.</p>
<p>
<img src="dat411_36.gif" border=0></p>
</li>
</ul>
<p>
<b>Objectives</b>
<ul>
<li>
Verify that the optimizer has chosen the best plan.<br><br></li>
<li>
Examine the available statistics.<br><br></li>
<li>
Use trace flags to determine how the optimizer made its decisions.<br><br></li>
<li>
Explain how the optimizer hints can be used and when you would want to use them.<br><br></li>
<li>
Determine opportunities for overriding the optimizer’s join order decisions by using FORCEPLAN.</li>
</ul>
<h3>Analyzing the Optimizer’s Choices</h3>
<p>
<img src="dat411_37.gif" border=0></p>
<p>
In most cases the optimizer chooses the best indexes and the best join order for the queries it processes. </p>
<p>
If you suspect that the optimizer may not have made the best choice, there are tools available to analyze why the optimizer made the choices it made. Sometimes just knowing the reasons is enough to persuade you that the right choice was made. </p>
<p>
In other situations, you may still not be convinced. There are also tools available to override the optimizer. You can use these tools to determine if your choice really is better than the optimizer’s choice.</p>
<p>
<b>Statistics management tools</b></p>
<p>
<img src="dat411_38.gif" border=0></p>
<p>
DBCC UPDATEUSAGE</p>
<p>
This command reports and corrects inaccuracies in the <i>sysindexes</i> table that can result in incorrect space usage reports by the <b>sp_spaceused</b> system stored procedure. </p>
<p>
This statement corrects the <i>used</i>, <i>reserved</i>, and <i>dpages</i> columns of the <i>sysindexes</i> table for any clustered indexes on objects of the type <b>U</b> (user-defined table) or <b>S</b> (system table). Size information is not maintained for nonclustered indexes. This statement can be used to synchronize space usage counters in <i>sysindexes</i>, which will result in accurate usage information being returned. When you use 0 instead of the <i>database_name</i>, the update is performed in the current database.</p>
<p>
Syntax</p>
<p>
<b>DBCC UPDATEUSAGE ({0 | <i>database_name</i>} [, <i>table_name</i> [, <i>index_id</i>]])<BR>[WITH COUNT_ROWS]</b></p>
<p>
The WITH COUNT_ROWS option specifies that the <i>rows</i> column of <i>sysindexes</i> is updated with the current count of the number of rows in the table. This only applies to <i>sysindexes</i> rows that have an <i>index_id</i> of 0 or 1. This option can affect performance on large tables.</p>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;The stored procedure <b>sp_spaceused</b> can be used with the @updateusage qualifier to provide the same functionality as DBCC UPDATEUSAGE. The <b>sp_spaceused</b> stored procedure takes longer to execute. Using this option on large tables may take longer to complete because every row in the table is counted.</p>
<p>
DBCC SHOW_STATISTICS</p>
<p>
This command displays all the statistical information in the distribution page for an index on a specified table. The results returned indicate the selectivity of an index (the lower the density returned, the higher the selectivity) and provide the basis for determining whether or not an index would be useful to the optimizer. The results returned are based on distribution steps of the index. </p>
<p>
Syntax</p>
<p>
<b>DBCC SHOW_STATISTICS (<i>table_name</i>, <i>index_name</i>)</b></p>
<p>
STATS_DATE function</p>
<p>
This function returns the date that the statistics for the specified index were last updated.</p>
<p>
Syntax</p>
<p>
<b>STATS_DATE (<i>table_id, index_id</i></b>)</p>
<p>
All of the above information is available in Enterprise Manager, using the Manage Indexes dialog box. (On the Manage menu, click Indexes.)</p>
<p>
<b>Trace flags</b></p>
<p>
<img src="dat411_39.gif" border=0></p>
<p>
Trace flags</p>
<p>
SQL Server trace flags provide additional information about SQL Server operations or change certain behaviors, usually for backward compatibility. In general, trace flags should only be used as a temporary work-around for a problem until a permanent solution is put in place. Although the information provided by trace flags can help diagnose problems, keep in mind that trace flags are not part of the supported feature set. This means that future compatibility or continued use is not assured. In addition, your primary support provider, including Microsoft, will usually not have further information and will not answer questions regarding the trace flags or their output. In other words, the information provided in this section is to be used at your own risk.</p>
<p>
Optimizer trace flags</p>
<table>
<tr valign=top>
<td>
<b>Trace flag</b></td>
<td>
<b>Information</b></td>
</tr>
<tr valign=top>
<td>
302</td>
<td>
Gives information about whether the statistics page is used, the actual selectivity (if available), and what SQL Server estimated the physical and logical I/O would be for the indexes. Trace flag 302 should be used with trace flag 310 to show the actual join ordering.</td>
</tr>
<tr valign=top>
<td>
310</td>
<td>
Gives information about join order. Index selection information is also available in a more readable format using SET SHOWPLAN ON, as described in the SET statement.</td>
</tr>
<tr valign=top>
<td>
325</td>
<td>
Gives information about the cost of using a nonclustered index or a sort to process an ORDER BY clause.</td>
</tr>
<tr valign=top>
<td>
326</td>
<td>
Gives information about the estimated and actual cost of sorts.</td>
</tr>
<tr valign=top>
<td>
330</td>
<td>
Enables full output when using the SET SHOWPLAN option, which gives detailed information about joins.</td>
</tr>
<tr valign=top>
<td>
3604</td>
<td>
Sends trace output to the client. This trace flag is used only when setting trace flags with DBCC TRACEON and DBCC TRACEOFF.</td>
</tr>
<tr valign=top>
<td>
3605</td>
<td>
Sends trace output to the error log. (If SQL Server is started from a command prompt, the output will also appear on the screen.)</td>
</tr>
</table><br>
<p>
Alternate startup options</p>
<p>
When SQL Server is installed, the <b>setup</b> program writes a set of default startup options in the Windows NT Registry under the key:</p>
<pre><FONT FACE="Courier New" SIZE="2">HKEY_LOCAL_MACHINE
&#09;\SOFTWARE
&#09;&#09;\Microsoft
&#09;&#09;&#09;\MSSQLServer
&#09;&#09;&#09;&#09;\MSSQLServer
</font></pre>
<p>
If you want to create and store alternate sets of startup options in the Registry&#45;for example, to start SQL Server in single-user mode or with a specific set of trace flags&#45;copy the MSSQLServer key (under MSSQLServer) to a new key, and then edit the options in the new key to suit your needs. Each startup option, including each trace flag, is stored as a separate parameter in the Parameters entry of the MSSQLServer key, starting with SQLArg0, then SQLArg1, and so on. The order of the parameters is not important.</p>
<p>
Editing of the Registry is not generally recommended, and inappropriate or incorrect changes can cause serious configuration problems for your system. </p>
<p>
You could create a new key called SingleUser, and then edit this entry</p>
<pre><FONT FACE="Courier New" SIZE="2">HKEY_LOCAL_MACHINE
&#09;\SOFTWARE
&#09;&#09;\Microsoft
&#09;&#09;&#09;\MSSQLServer
&#09;&#09;&#09;&#09;\SingleUser
&#09;&#09;&#09;&#09;&#09;\Parameters
</font></pre>
<p>
to include the additional -m startup option. The entire Parameters entry for the SingleUser key would look like this:</p>
<pre><FONT FACE="Courier New" SIZE="2">HKEY_LOCAL_MACHINE
&#09;\Software
&#09;&#09;\Microsoft
&#09;&#09;&#09;\MSSQLServer
&#09;&#09;&#09;&#09;\SingleUser
&#09;&#09;&#09;&#09;&#09;\Parameters
SQLArg0 : REG_SZ : -dC:\SQL\DAT\MASTER.DAT
SQLArg1 : REG_SZ : -eC:\SQL\LOG\ERRORLOG
SQLArg2 : REG_SZ : -m
</font></pre>
<p>
To start SQL Server using this alternate key, you would start SQL Server from the command prompt using the <b>–s</b> startup option, as shown in the following example:</p>
<pre><FONT FACE="Courier New" SIZE="2">  sqlservr -c -sSingleUser
</font></pre>
<p>
<b>Using optimizer trace flags</b></p>
<p>
<img src="dat411_40.gif" border=0></p>
<p>
The optimizer trace flags provide a lot of information, most of it intended for Microsoft engineers. There are a few specific things you can look for:
<ul>
<li>
Is every search argument (SARG) mentioned with the correct operator?<br><br></li>
<li>
Is every index considered?<br><br></li>
<li>
Is a statistics page available?<br><br></li>
<li>
Are the row estimates close to reality?<br><br></li>
<li>
Are the page estimates reasonable?<br><br></li>
<li>
Are all join orders considered?<br><br></li>
<li>
Are the appropriate indexes tested with each different join order?</li>
</ul>
<p>
Example</p>
<p>
Here is some Transact-SQL code and its output. The output that answers the questions above is in bold type.</p>
<pre><FONT FACE="Courier New" SIZE="2">DBCC TRACEON(3604, 302)
SET SHOWPLAN ON
SET NOEXEC ON
GO
SELECT * FROM charge
WHERE charge_no &gt; 99950
DBCC execution completed. If DBCC printed error messages, see your System Administrator.
 
*******************************
Leaving q_init_sclause() for table 'charge' (varno 0).

<b>The table has 100000 rows and 3408 pages.

Cheapest index is index 0, costing 3408 pages per scan.
 
*******************************
Entering q_score_index() for table 'charge' (varno 0).
The table has 100000 rows and 3408 pages.
Scoring the search clause:
AND (!:0xb8e492)  (andstat:0xa)
  GT</b> (L:0xb8e47e)  (rsltype:0x38 rsllen:4 rslprec:10 rslscale:0
  opstat:0x0)
    VAR (L:0xb8e4d0)  (<b>varname:charge_no</b> varno:0 colid:1
    coltype(0x38):INT4 colen:4 coloff:2 colprec:10 colscale:0
    vartypeid:101 varusecnt:2 varstat:0x4001 varlevel:0 varsubq:0)
    INT4 (R:0xb8e464)  (left:0xb8e46c len:4 maxlen:4 prec:5 scale:0
    <b>value:99950</b>)
 
Scoring clause for<b> index 6
Relop bits are: 0x4000,0x80,0x10,0x1

Qualifying stat page; </b>pgno: 10616 steps: 332 
Search value: INT4 value:99950
No steps for search value--qualpage for LT search value finds 
value between steps 330 and 331--use betweenSC 

<b>Estimate: </b>indid 6, selectivity 4.513098e-003, <b>rows 451 pages 457 
Cheapest index is index 6, costing 457 pages and generating 451 rows
per scan.
Search argument selectivity is 0.004513.
*******************************
STEP 1
The type of query is SELECT
FROM TABLE
charge 
Nested iteration
Index : charge_charge_amt
</b></font></pre>
<h3>Overriding the Optimizer</h3>
<p>
<img src="dat411_41.gif" border=0></p>
<p>
<b>FORCEPLAN</b></p>
<p>
<img src="dat411_42.gif" border=0></p>
<p>
FORCEPLAN is an option of the SET statement, and it can be either ON or OFF. Once FORCEPLAN is turned ON, it stays in effect for the session, or until set to OFF.</p>
<p>
When FORCEPLAN is ON, the order in which tables are listed in the FROM clause controls the order in which the tables will actually be joined; the optimizer will bypass making any decisions about join order.</p>
<p>
<b>Using FORCEPLAN</b></p>
<p>
<img src="dat411_43.gif" border=0></p>
<p>
Example</p>
<p>
In this example, the query will be processed by accessing the <i>corporation</i> table first, and then the <i>member</i> table, no matter what the optimizer might have chosen as the best order.</p>
<pre><FONT FACE="Courier New" SIZE="2">SET FORCEPLAN ON
GO
SELECT *
FROM corporation, member
WHERE member.corp_no = corporation.corp_no
AND member_no &lt; 100
GO
</font></pre>
<p>
<b>Forcing an index</b></p>
<p>
<img src="dat411_44.gif" border=0></p>
<p>
Optimizer indexing hints</p>
<p>
SQL Server provides a number of hints that can be supplied to the optimizer within a SELECT statement. Most of these will be discussed in a later module, because they apply to locking behavior. One hint that deals with indexing is the INDEX hint. You must supply an index ID or an index name after the name of the table in the SELECT statement:</p>
<p>
Partial syntax</p>
<pre><FONT FACE="Courier New" SIZE="2">SELECT select_list
FROM table_name [(INDEX = {index_name | index_id})]
</font></pre>
<p>
The hint specifies the index name or ID to use for the table. An <i>index_id</i> of 0 forces a table scan, and 1 forces the use of a clustered index (if one exists).</p>
<p>
Example</p>
<p>
In this example, the query will be processed by using the index on <i>corp_no</i>, no matter what the optimizer might have chosen as the best index.<code> </code></p>
<pre><FONT FACE="Courier New" SIZE="2">SELECT *
FROM member (INDEX = member_corporation_link)
WHERE member_no &lt; 100
AND corp_no BETWEEN 200 AND 300
</font></pre>
<p>
FASTFIRSTROW</p>
<p>
This option causes the optimizer to use a nonclustered index if it matches the ORDER BY clause and there is no WHERE clause. The first row will be returned more quickly and a work table for sorting will not be built in <i>tempdb</i>; read-ahead will not be used, and the total amount of I/O and the time required to complete the query may be greater. If the query contains a WHERE clause as well as an ORDER BY clause, then SQL Server may use an index that resolves the WHERE clause instead of the index that resolves the ORDER BY clause. The decision will be based on the selectivity of the WHERE clause, but it will be influenced by the presence of FASTFIRSTROW.</p>
<p>
<b>Additional Considerations</b></p>
<p>
<img src="dat411_45.gif" border=0></p>
<p>
When it improves performance</p>
<p>
Be sure to verify that performance has been improved. Turn on STATISTICS IO and STATISTICS TIME to determine that overriding the optimizer has had a positive impact. Usually the optimizer really does know best, and overriding the optimizer does not make performance better.</p>
<p>
As a last resort</p>
<p>
Try other methods of getting the optimizer to behave as you would like it to behave. Have you updated statistics recently? Have stored procedures been recompiled lately? Can you rewrite your query or search arguments? Can you build slightly different indexes?</p>
<p>
Document your reasons for hinting</p>
<p>
Make sure to leave a record of why you needed to override the optimizer. If those reasons change long after you originally wrote the code, you may not realize that your hints are no longer necessary.</p>
<p>
Retest after every upgrade</p>
<p>
The SQL Server optimizer is continually being improved. After installing a new version, it may no longer be necessary to override the optimizer. Your suggestions may actually be worse than the optimizer’s own choices.</p>
<p>
The SQL Server optimizer is dynamic and can find a new best plan as your data changes. If you have to force the optimizer, that decision becomes non-dynamic. As your data changes, your plan will stay the same. For this reason, you should consider retesting on a regular basis any query for which you chose to override the optimizer, even if the version of SQL Server has not been upgraded.</p>
</font></BODY>
</HTML>
