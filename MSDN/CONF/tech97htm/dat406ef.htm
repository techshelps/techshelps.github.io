<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MFC DAO and MFC ODBC Classes: Which Set Do I Use?</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>



	<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>



	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<h1>MFC DAO and MFC ODBC Classes: Which Set Do I Use?</h1>
<p>
Presented by:&#09;Jocelyn Garner<BR>Software Design Engineer, Microsoft Visual C++ development system/Microsoft Foundation Classes (MFC)</p>
<h2>More Flexible than Ever</h2>
<p>
Ever since the MFC Data Access Objects (DAO) database classes were released in October of 1995, the question of which set of classes to use has been on the mind of MFC database developers. This paper does not attempt to answer the question in general terms. Instead the emphasis here is on examining the options so that you, the developer, can decide which set of MFC database classes is best for each situation. </p>
<p>
Most MFC developers are familiar with the Open Database Connectivity (ODBC) database classes<font face="Symbol"><span style="font-family:symbol">&#190;</span></font>they’ve been around for three and a half years. With MFC 4.2, there are some significant improvements in those classes. </p>
<p>
As C++ developers, you may not be familiar with DAO because to date it has been available only with Microsoft&reg; Access and the Visual Basic&reg; programming system. If you are familiar with DAO, you need to know that MFC’s implementation of DAO is different, but still comprehensive.</p>
<p>
Developers who know the MFC ODBC classes need to know that the MFC DAO classes have more functionality than the ODBC classes, but that the DAO classes do not supplant them. </p>
<h2>The MFC Database Strategy</h2>
<p>
For those of you who are not familiar with MFC in general, let me remind you that MFC has a design philosophy that pervades the database classes as well. </p>
<p>
MFC encapsulates the Windows&reg; operating system API as a thin wrapper, providing the C++ capabilities you want along with the abstraction you need. We add value to the underlying API when it makes sense. Most of the time though, MFC tries to stay out of the way.</p>
<p>
Just as MFC encapsulates a more complex API, so do the database classes encapsulate more complicated technologies. Because of MFC’s portability across Intel, Unix, and Alpha, database application solutions can be portable.</p>
<p>
We use the same recordset model that Microsoft Access and Visual Basic use, so developers who already use those products don’t have to learn a new paradigm. In addition, because the architecture of the two sets of classes is essentially the same, developers using one set of classes can easily switch and use the other.</p>
<h3>The MFC Database Classes</h3>
<p>
The ODBC database classes have been available in MFC since version 1.5. Visual C++ version 2.0 offered 32-bit versions of the same classes. These classes are widely in use, are based on an industry-accepted standard, and are favored over other database development options because of the portability of ODBC<font face="Symbol"><span style="font-family:symbol">&#190;</span></font>the ability to use applications created with these classes with a variety of ODBC data sources. Recent performance improvements make the ODBC database classes an attractive option.</p>
<p>
The DAO database classes in MFC 4.0 give you direct access to desktop data sources without the use of ODBC in most cases. The ability to have more than one database type open at a time, to address a wide variety of data sources, and the Data Definition Language capabilities make the DAO database classes a serious development option.</p>
<p>
By now you’re ready to ask which set of database classes you should use. The answer to this question is difficult to determine without a lot of information from you regarding your project. The first thing to consider, however, is what data sources you’re using. If you’re using mostly desktop data, we encourage you to consider the MFC DAO database classes, because you’ll find them to be efficient and powerful. If you primarily use ODBC server-based data, your project may function more efficiently with the ODBC-based classes.</p>
<p>
Other considerations include the kind of network you have, the scalability requirements, and whether speed is more important than anything else. The best thing to do is to prototype applications using the set of database classes you think will work best. Do some benchmarking to determine your best performance options.</p>
<p>
The decision is really up to you. </p>
<h2>A Continuum of Choices</h2>
<p>
The set of choices you have for creating database applications is vast. It turns out to be a continuum of choices, with desktop database applications at one end and strict client/server database applications at the other. Probably the only two choices that might seem obvious are to use the MFC DAO database classes with Microsoft Access 97 .mdb data, and to use the MFC ODBC database classes with Microsoft SQL Server™ 6.5. These two pairings were pretty much designed to work with each other and both are very efficient. But you probably already knew about those choices. What about everything else?</p>
<p>
Briefly, here is the process by which you can make a decision:
<ol>
<li>
Determine data source needs<p>
How large a database do you need? Does more than one person need to get to the data at a time? Sometimes the data source you select can determine most of the rest of these steps.</p>
</li>
<li>
Determine interface needs<p>
If you need to have an interface with lots of user input (such as users being able to design their own queries), you have to tune and distribute your database(s) carefully. For example, if you need to populate list boxes with data that doesn’t change much, and you’ve selected a server-based data source, it makes sense to store the typically unchanging data locally rather than on the server.</p>
</li>
<li>
Determine connectivity needs<p>
There are a number of network protocols in use today, and each one has its impact on data moving across the network. A discussion of networks is outside the scope of this paper, but you need to know how to optimize your database application to avoid encountering your network’s data pitfalls.</p>
</li>
<li>
Select the appropriate tool(s)<p>
Microsoft has a variety of options for the database developer (Microsoft Access, Visual Basic, Visual Basic Enterprise and Visual C++/MFC, and SQL Server), and in some cases the functionality overlaps a bit. The scope of this paper is to discuss the Visual C++/MFC options specifically, but if you haven’t also considered these other options, you should look at them, too.</p>
</li>
<li>
Prototype before implementation</li>
</ol>
<p>
You’ll see this statement several times in this paper because it’s important. You may have selected well, but unless your solution actually works, the job isn’t finished!</p>
<p>
Again, for this paper, we’re assuming that you want to know about MFC’s database classes. Let’s examine as many of the options as possible so that you will recognize the direction you want to take for your first prototype.</p>
<p>
The MFC ODBC database classes use the recordset model found in Microsoft Access and Visual Basic. You can filter, sort, scroll through, and otherwise manipulate the records using the member functions built into the classes. The underlying ODBC driver affects the functionality of a particular application. So to be more portable, your applications have to be more general, or rely on a lower level of ODBC functionality. You can call ODBC directly, if necessary, to accomplish a particular task. Now let’s examine the individual classes in this set.</p>
<h2>MFC’s ODBC Database Classes</h2>
<p>
As always with MFC, you can make calls to the underlying API (in this case ODBC) as necessary.</p>
<p>
A <b>CDatabase</b> object represents a connection to a data source, through which you can operate on the data source. A data source is a specific instance of data hosted by some database management system (DBMS). Examples include Microsoft SQL Server, Microsoft Access, Borland dBASE, and xBASE. You can have one or more <b>CDatabase</b> objects active at a time in your application, and you can have multiple connections to a database object. </p>
<p>
A <b>CRecordset</b> object represents a set of records selected from a data source. Known as “recordsets,” <b>CRecordset</b> objects are available in three forms: dynasets, snapshots, and dynamic recordsets. A dynaset is a recordset that stays synchronized with updates by other users. A snapshot is a static recordset that reflects the state of the database at the time of the snapshot. A dynamic recordset is similar to a dynaset, and is generally only used with Microsoft SQL Server. Each form represents a set of records fixed at the time the recordset is opened, but when you scroll to a record in a dynaset or a dynamic recordset, it reflects changes subsequently made to the record, either by other users or by other recordsets in your application. </p>
<p>
MFC 4.2 adds new navigation functionality to the <b>CRecordset</b> class in the form of bookmarks and an ability to identify the <b>AbsolutePosition</b> of a record and navigate to it. Bookmarks are unique identifiers that you can use to return to a specific record by calling that identifier.</p>
<p>
Class <b>CRecordView</b> is an MFC construct<font face="Symbol"><span style="font-family:symbol">&#190;</span></font>a form for displaying data. Because <b>CRecordView</b> is based on <b>CFormView</b>, it has all of the inherited functionality of that base class. Essentially, a form view stretches a dialog template over the client area of a window. This makes adding controls and displaying field data very easy to do.</p>
<p>
When you use AppWizard and ClassWizard to create an ODBC-based database application, the columns of the recordset are automatically bound (statically) to member variables, which can then be added to the dialog template.</p>
<p>
A <b>CDBException</b> object represents an exception condition arising from the database classes. The class includes two public data members you can use to determine the cause of the exception or to display a text message describing the exception. <b>CDBException</b> objects are constructed and thrown by member functions of the database classes. </p>
<p>
The <b>CFieldExchange</b> class supports the record field exchange (RFX) routines used by the database classes. Use this class if you are writing data exchange routines for custom data types; otherwise, you will not directly use this class. RFX exchanges data between the field data members of your recordset object and the corresponding fields of the current record on the data source. RFX manages the exchange in both directions, from the data source and to the data source.</p>
<h2>Data Access Objects</h2>
<p>
In its native format, DAO consists of 21 objects and 20 collections. DAO then provides individual objects such as tables and fields, as well as collections to which they belong. This clear hierarchy of objects makes it easy to apply object-oriented principles to database development. </p>
<p>
DAO has been around for a while. DAO version 1.0 appeared in Microsoft Access version 1.0, providing only an interface to table and query structures, and objects to represent tables, dynasets, and snapshots with a limited number of properties. Data Access Objects 1.0 in Visual Basic version 3.0 added <b>TableDef</b>, <b>QueryDef</b>,<b> </b>and <b>Field</b> objects to programmatically expose structures.</p>
<p>
DAO version 2.0 in Microsoft Access version 2.0 had the first vestiges of OLE Automation and full programmatic access to almost all Microsoft Jet functionality. It had a full object model with a robust set of objects and properties.</p>
<p>
DAO version 2.5 consisted of ODBC Desktop Database Drivers that were created for 16-bit platforms for use with ODBC Desktop Database Drivers version 2.0. The 16-bit version was shipped for use with the 16-bit version of Visual Basic version 4.0.</p>
<p>
DAO version 3.0 shipped with Microsoft Access for Windows 95, Visual Basic version 4.0 (32-bit), Microsoft Excel version 7.0, and Visual C ++ version 4.0. DAO was enhanced to support a stand-alone interface for any compatible host.</p>
<p>
DAO version 3.5 shipped with Microsoft Access for Windows 97, and includes the new ODBCDirect COM objects. The MFC DAO database classes do not include classes for these objects.</p>
<p>
Most important, the DAO interfaces are based on OLE COM, which positions DAO well for the future technologies and operating systems.</p>
<p>
<img src="dat406ef_1.gif" border=0></p>
<p>
Here is the DAO hierarchy chart. At the top, you see the DBEngine object, which contains all of the other objects. This is the only object without a collection, because you can have only one engine. You can have multiple workspaces, databases, and so on, which is why the remaining objects have collections to which they belong. </p>
<p>
In a workspace, you can have more than one database, either a base table (.MDB) or an attached/linked table. In each database will be one or more tables, queries, and recordsets, and in each of those will be fields and/or indexes, as well as other types of objects.</p>
<p>
Also connected with the workspace are the user and group objects that constitute the security model for DAO.</p>
<p>
Off by itself, and connected to the engine object, is the Errors object. </p>
<p>
Objects in the Errors collection are appended in a manner different from the other DAO collections. The most detailed errors are placed at the end of the collection, and the most general errors are placed at the beginning.</p>
<h2>MFC and DAO</h2>
<p>
Now let’s talk about how MFC implements DAO. Because we don’t individually wrap each DAO object, MFC essentially flattens the DAO hierarchy. We offer you 8 objects instead of 21.</p>
<p>
We encapsulate all of the DAO functionality with the exception of the Security objects - Users and Groups and the new ODBCDirect objects. We did this deliberately. In looking at the security objects, for example, we felt that creating classes around them would not add any value to the use of DAO, so we just let you make direct calls to DAO to handle those objects. This is in keeping also with the MFC philosophy: Create classes where it makes sense from a value-added standpoint. We do, however, provide instructions on how to implement the security model in MFC Technical Note 54.</p>
<p>
We also manage the DAO requirements for adding objects to collections. In DAO, you create an object then append it to a collection. With one exception, we do this automatically. For that one case, it made sense to have the developer be able to Append the object or not, as a separate step. </p>
<p>
While dynamic binding is possible with the ODBC database classes, functionality for doing so is not built into the MFC classes. It IS built into the DAO database classes, and you can do dynamic binding rather easily. Our second demo today will talk more about that.</p>
<p>
DAO offers the Data Definition Language from SQL that lets you create databases, tables, recordsets, etc. DDL is not available in the ODBC classes.</p>
<p>
Finally, you can always make direct calls to the underlying DAO OLE objects as you need to.</p>
<h3>MFC DAO Database Class Hierarchy</h3>
<p>
<img src="dat406ef_2.gif" border=0></p>
<p>
The five MFC DAO classes that derive from <b>CObject</b> (<b>CDaoWorkspace</b>, <b>CDaoDatabase</b>, <b>CDaoTableDef</b>, <b>CDaoQueryDef</b>, and <b>CDaoRecordset</b>) have all of that base class’s functionality.</p>
<p>
<b>CDaoException</b> derives from <b>CException</b>, and has that class’s advantages, including the ability to display the error messages from the underlying DAO Errors object.</p>
<p>
<b>CDaoRecordView</b>, as mentioned earlier, derives from <b>CFormView</b>, which derives from <b>CScrollView</b>, etc. You can see all the advantages a <b>CDaoRecordView</b> class has for making a form-based display of data quick and easy to implement. In addition, there is wizard support for <b>CDaoRecordView</b>. The functionality in this class is virtually identical to the <b>CRecordView</b> class.</p>
<p>
The <b>CDaoFieldExchange</b> class supports the DAO record field exchange (DFX) routines used by the DAO database classes. You only call this object directly if you are creating custom DFX routines.</p>
<h3>The MFC DAO Database Classes</h3>
<p>
<b>CDaoWorkspace</b> encapsulates both the DBEngine object and the Workspace object. The fact that the MFC DAO classes offer a workspace is very important. The ODBC database classes do not support having more than one database connection at a time. </p>
<p>
Transactions are done at the Workspace level in the DAO database classes instead of the Recordset level as in the ODBC classes. One transaction can affect all open databases and recordsets, or you can isolate transactions so that they affect only specific databases, and so on. </p>
<p>
Most of the time you don’t have to worry about creating a workspace object. MFC will open one for you if you don’t. The DAO database classes support having multiple workspaces if you need them.</p>
<p>
Finally, you don’t have to worry about a workspace object going out of scope or closing before the database session is through. You can use a workspace pointer to access the Workspaces collection, access the Databases collection, access properties of the database engine, and so on.</p>
<h3>CDaoDatabase</h3>
<p>
<b>CDaoDatabase</b> is similar in architecture to the ODBC-based <b>CDatabase</b> class. <b>CDaoDatabase</b> also encapsulates the database connection. Because you don’t have to always use ODBC, the location of the data source is expressed as a path for most desktop data sources. <b>CDaoDatabase</b> can store tabledef and querydef objects, a great convenience for you as a developer. <b>CDaoDatabase</b> works with both local and remote data sources. We’ll see a list of the data sources you can use a little later in this paper.</p>
<p>
The database object also persists for the duration of the session. You can explicitly close the database connection as necessary. Just for purposes of comparison, the <b>CDatabase</b> class has 21 member functions, and <b>CDaoDatabase</b> has 26 member functions. The member functions themselves are very similar, with a few more available in <b>CDaoDatabase</b>.</p>
<p>
There is no class that corresponds to <b>CDaoTableDef</b> among the ODBC database classes. TableDef objects let you examine the schema (structure) of a database, regardless of whether the table is a native Microsoft Access table (base table) or the table is linked. You can add fields &amp; indexes to external data sources if you open them directly with DAO. If you link the table, you can examine the structure, but you cannot change it. You can base a recordset on a table. Doing so gives you several advantages, including the use of a high-speed search member function called <b>Seek</b>.</p>
<p>
You use <b>CDaoTableDef</b> to determine whether data in a table can be edited by calling <b>CDaoTableDef::CanUpdate</b>. MFC takes care of managing the DAO Fields and Indexes collections for you. With <b>CDaoTableDef</b>, you have the option of appending a table to the TableDefs collection or not<font face="Symbol"><span style="font-family:symbol">&#190;</span></font>with all other objects, appending is done automatically.</p>
<p>
The SQL you use to retrieve records is stored in a <b>CDaoQueryDef</b> object. This object lets you store the “questions” you ask of your data, such as “How many customers did X dollars of business last month?” You can retrieve and reuse stored queries, and they can be used in one of three ways:
<ul>
<li>
To create a recordset by passing a pointer to the <b>CDaoQueryDef</b> object.<br><br></li>
<li>
Directly execute action queries, a query that moves or changes data. Action queries include append, delete, make-table, and update queries. Delete and update queries change existing data; append and make-table queries move existing data. <br><br></li>
<li>
To execute SQLPASSTHROUGH queries: SQL pass-through queries are SQL statements that are sent directly to the database server without interpretation by the Microsoft Jet database engine. SQL pass-through queries provide your application with the ability to directly manipulate the features of your database server. </li>
</ul>
<p>
<b>CDaoRecordset</b> is also very similar to the ODBC-based <b>CRecordset</b> class. Recordsets can be based on tables as well as dynasets and snapshots. Remember, the recordset represents both the records you’ve retrieved and a way to move through the data. Options for moving through the data include <b>Seek</b> (for table-type recordsets only), Find and Move operations, <b>AbsolutePosition</b>, and, if your data source supports them, bookmarks. Bookmarks are unique identifiers that you can use to return to a specific record by calling that identifier.</p>
<p>
The bulk of the functionality in the MFC DAO database classes is found in <b>CDaoRecordset</b>. <b>CRecordset</b> has only 44 member functions compared to 91 member functions for <b>CDaoRecordset</b>. This additional functionality is found in the navigation, caching, setting and retrieving of field values and in setting and retrieving recordset attributes.</p>
<p>
The <b>CDaoRecordView</b> and <b>CRecordView</b> classes have functionality that is nearly identical. They both also have the advantages that come with being based on <b>CFormView</b>. Remember, a form view is like a dialog template stretched across the client area of a window, and that makes it easy to add controls and to display field data. AppWizard and ClassWizard support the form-based display of data. If you use AppWizard to create your initial application, the columns of your database are automatically bound to member variables for you.</p>
<p>
Exception handling is slightly different for the DAO database classes. Class <b>CDaoException</b> will return the error messages of the underlying DAO OLE object. Most of the time, you can retrieve more information about errors than is typically available with the ODBC-based classes. In MFC, all DAO errors are expressed as exceptions, of type <b>CDaoException</b>.</p>
<p>
When you catch an exception of this type, you can use <b>CDaoException</b> member functions to retrieve information from any DAO error objects stored in the database engine’s Errors collection. As each error occurs, one or more error objects are placed in the Errors collection. When another DAO operation generates an error, the Errors collection is cleared, and the new error object is placed in the Errors collection.</p>
<p>
The <b>CDaoFieldExchange</b> class supports the DAO record field exchange (DFX) routines used by the DAO database classes. Use this class if you are writing data exchange routines for custom data types; otherwise, you will not directly use this class. DFX exchanges data between the field data members of your <b>CDaoRecordset</b> object and the corresponding fields of the current record on the data source. DFX manages the exchange in both directions, from the data source and to the data source. See Technical Note 53, available under MFC in Books Online, for information about writing custom DFX routines.</p>
<p>
A <b>CDaoFieldExchange</b> object provides the context information needed for DAO record field exchange to take place. <b>CDaoFieldExchange</b> objects support a number of operations, including binding parameters and field data members and setting various flags on the fields of the current record. DFX operations are performed on recordset-class data members of types defined by the <b>enum</b> <b>FieldType</b> in <b>CDaoFieldExchange</b>. Possible <b>FieldType</b> values are:
<ul>
<li>
CDaoFieldExchange::outputColumn for field data members.<br><br></li>
<li>
CDaoFieldExchange::param for parameter data members.</li>
</ul>
<p>
Here then is a picture of the ODBC-based database classes, as you’ve known them. The bar at the top represents the ODBC-based MFC classes that talk to ODBC. The ODBC drivers for each database interpret the SQL calls and translate them for each data source. A variety of data sources are shown with their corresponding drivers along the bottom of the diagram to remind you of ODBC’s flexibility.</p>
<p>
<img src="dat406ef_3.gif" border=0></p>
<p>
<b>Figure 1. The MFC ODBC database classes</b></p>
<p>
Figure 2 is a picture of the DAO database classes. They communicate via OLE with DAO, and DAO talks to the Jet database engine. The Jet database engine has separate DLLs that are used to communicate with various desktop data sources. </p>
<p>
<img src="dat406ef_4.gif" border=0></p>
<p>
<b>Figure 2. The MFC DAO database classes - desktop data sources</b></p>
<p>
The Microsoft Jet database engine can open data sources such as the FoxPro<font face="Symbol"><span style="font-family:symbol">&#210;</span></font> database and Paradox directly. But unless you need to change the schema of these data sources, it is actually more efficient to link these tables to a Microsoft Access database. This is why the FoxPro and Paradox tables (which are just examples) are shown in two places. The dotted line is meant to imply that while it is possible to open the data sources directly, it is less efficient. </p>
<p>
A linked table appears and behaves just like any other table in your Microsoft Jet database (although there are slight performance differences associated with connecting to and retrieving remote data). Information necessary to establish and maintain a connection to the remote data source is stored within the table definition. </p>
<p>
In contrast, when you open a table directly, you must supply the connection information at the beginning of each session to establish a connection to the data source. None of the information needed to establish a connection to the remote data source is stored in your Microsoft Jet database. To open a table directly, you must use the <b>CDaoTableDef::Create</b>, and you must supply connection information (such as the data source, user name, password, and database name).</p>
<p>
With the DAO database classes, you can reach server-type databases such as Microsoft SQL Server and ORACLE by way of ODBC. Figure 3 completes the picture as far as reaching all types of data sources.</p>
<p>
<img src="dat406ef_5.gif" border=0></p>
<p>
<b>Figure 3. The MFC DAO Database Classes, including SQL databases</b></p>
<p>
Finally, Figure 4 is the complete picture of the MFC database classes. Please understand that the vertical line on the MFC bar and the ODBC bar indicates that the two sets of MFC database classes are designed to be used as an either/or decision. You have options for reaching all types of data sources, but you cannot mix MFC database classes from both sets.</p>
<p>
<img src="dat406ef_1.gif" border=0></p>
<p>
<b>Figure 4. The MFC Database Classes</b></p>
<h3>Data Source Options for the ODBC Database Classes</h3>
<p>
When you write applications using the MFC ODBC classes, you can connect to any data source for which you have an ODBC driver. The operation of ODBC Driver Manager and ODBC drivers is transparent in applications you write with these classes, but the individual driver capabilities affect the functionality of an application.</p>
<p>
Generally, MFC dynasets (but not forward-only recordsets) require an ODBC driver with level 2 API conformance. If the driver for your data source conforms to the level 1 API set, you can still use both updatable and read-only snapshots and forward-only recordsets, but not dynasets. However, a level 1 driver can support dynasets if it supports extended fetching and keyset-driven cursors. </p>
<p>
The ODBC Desktop Driver Pack version 3.0 supports the level 2 ODBC API call <b>SQLExtendedFetch</b>.</p>
<p>
AppWizard and ClassWizard will automatically bind columns of a data source statically to member variables in your application. This is the easiest way to establish a connection between your application and a data source, but not the most flexible. You can add custom Record Field Exchange (RFX) calls to your application by using class <b>CFieldExchange</b>. See Technical Note 43: RFX Routines for more information. </p>
<p>
You might also consider binding the database columns dynamically. At the most general level, you follow these steps:
<ol>
<li>
Construct your main recordset object. Optionally, pass a pointer to an open <b>CDatabase</b> object, or be able to supply connection information to the column recordset in some other way.<br><br></li>
<li>
Take steps to add columns dynamically.<br><br></li>
<li>
Open your main recordset.</li>
</ol>
<p>
The recordset selects records and uses record field exchange (RFX) to bind both the “static” columns (those mapped to recordset field data members) and the dynamic columns (mapped to extra storage that you allocate).</p>
<h3>Data Source Options for the DAO Database Classes</h3>
<p>
Now let’s talk about the data sources you can connect to with the DAO database classes, binding columns statically, binding them dynamically, and the double-buffering of records.</p>
<p>
You’ll get the fastest access to Microsoft Access databases, naturally, since they are native to Jet. Microsoft Access 97 has the database format that is native to DAO version 3.5. You’ll get the fastest performance if you use a Microsoft Access 97 database.</p>
<p>
Jet uses a separate DLL to provide access to Microsoft Jet version 1.<i>x</i> and 2.0 databases. The storage engine and format were completely revised with Microsoft Jet version 3.0. Given the large number of structural changes, Microsoft Jet version 3.0 treats version 2.0 databases as external ISAMs. This has an impact on performance, so if you have not already considered upgrading your Microsoft Access database, this is a good reason to do so.</p>
<p>
You can also access installable ISAM databases and ODBC data sources. ISAMs (indexed sequential access method) databases such as FoxPro and dBASE can be opened directly or linked to Access databases for best performance. Here is a list of the data sources DAO can access:
<ul>
<li>
Microsoft FoxPro, versions 2.0, 2.5, and 2.6. Can import and export data to and from version 3.0, but can’t create objects.<br><br></li>
<li>
dBASE III, dBASE IV, and dBASE 5.0<br><br></li>
<li>
Paradox, versions 3.<i>x</i>, 4.<i>x</i>, and 5.<i>x</i><br><br></li>
<li>
Btrieve, versions 5.1<i>x</i> and 6.0<br><br></li>
<li>
Microsoft Excel version 3.0, 4.0, 5.0, 7.0, and 8.0 worksheets<br><br></li>
<li>
Lotus WKS, WK1, WK3, WK4 spreadsheets<br><br></li>
<li>
Text files</li>
</ul>
<p>
Remember that Microsoft Access versions 1.<i>x</i>, 2.0, and 7.0 databases fall into this category.</p>
<p>
You can reach ODBC Data sources such as SQL Server and Oracle through ODBC, so you have the option to use DAO for those data sources. An ODBC data source is any DBMS for which you have the appropriate ODBC driver. For Visual C++ versions 2.0 and later, you need 32-bit ODBC drivers (except on Win32s, where you need 16-bit ODBC drivers). Here is a list of ODBC drivers included in this version of Visual C++. 
<ul>
<li>
Microsoft SQL Server<br><br></li>
<li>
Microsoft Access<br><br></li>
<li>
Microsoft FoxPro<br><br></li>
<li>
Microsoft Excel<br><br></li>
<li>
dBASE<br><br></li>
<li>
Paradox<br><br></li>
<li>
Text file</li>
</ul>
<p>
The Microsoft Desktop Database Drivers version 3.0 (which cover the last six items in the list) offers the best performance for those data sources. These are 32-bit drivers only.</p>
<p>
Linking external data sources such as SQL Server to a Microsoft Access table is the most efficient way to handle the data access. Before you can connect your application to a remote data source, you must make sure that the remote data is accessible to your application’s users and that your application is properly designed to handle remote data source security challenges. You must also make sure that your application interacts correctly with case-sensitive data sources and that the installable ISAM is correctly initialized for the data source you want to access. Finally, you must check to see that your code doesn’t use objects or calls that are specific to Microsoft Jet data sources when accessing non-Jet data sources.</p>
<p>
The easiest way to set up a link is to go into Microsoft Access and use the File/Attach Table command in Microsoft Access version 2.0 or the File/Get External Data/Link Tables command in Microsoft Access 95 and Microsoft Access 97.</p>
<p>
Connection information is stored in the base table (.MDB) you are using. If you move the location of the external data, you must reestablish the link from within Microsoft Access, or by calling <b>CDaoTableDef::RefreshLink</b> from within your code.</p>
<p>
The DAO Record field exchange mechanism works the same way RFX works in the ODBC-based database classes. The recordset object’s field data members, taken together, constitute an “edit buffer” that holds the selected columns of one record. When the recordset is first opened and is about to read the first record, DFX binds (associates) each selected column to the address of the appropriate field data member. When the recordset updates a record, DFX calls DAO to send the appropriate commands to the database engine. DFX uses its knowledge of the field data members to specify the columns (fields) in the data source to write. </p>
<p>
The wizards support binding columns statically. You can add your own DFX calls as you can with the ODBC-based classes. First, members must be added to the <b>CDaoRecordset</b> derived class for each bound field and parameter. Following this, <b>CDaoRecordset::DoFieldExchange</b> should be overridden. Note that the data type of the member is important. It should match the data from the field in the database or at least be convertible to that type. MFC Technical #53 describes the process in greater detail.</p>
<p>
The <b>CDaoFieldExchange</b> class supports the DAO record field exchange (DFX) routines used by the DAO database classes. Use this class if you are writing data exchange routines for custom data types. A <b>CDaoFieldExchange</b> object provides the context information needed for the DAO record field exchange to take place. <b>CDaoFieldExchange</b> objects support a number of operations, including binding parameters and field data members and setting various flags on the fields of the current record.</p>
<h3>Dynamic Binding in the DAO Database Classes</h3>
<p>
While it is possible to bind columns dynamically using the ODBC-based classes, the support for doing so is not built into the MFC classes. Dynamic binding IS built into the DAO database classes, and it is fairly easy to do. </p>
<p>
There are other things you can do to optimize performance such as retrieving a part of a record instead of an entire record. We’ll cover ways to optimize your application a little later in this presentation.</p>
<p>
DFX and dynamic binding are not mutually exclusive options. With the DAO database classes, you can mix static and dynamic binding calls for maximum efficiency.</p>
<h3>Double-Buffering in the DAO Database Classes</h3>
<p>
In MFC's <b>CDaoRecordset</b> class, double-buffering is a mechanism that simplifies detecting when the current record in a recordset has changed. Using double-buffering with your DAO recordsets reduces the amount of work you have to do when adding new records and editing existing records. By default, your MFC DAO recordsets keep a second copy of the edit buffer (the field data members of the recordset class, taken collectively; DAO Help calls the corresponding buffer a “copy buffer”). As you make changes to the data members, MFC compares them to the copy (the &quot;double-buffer&quot;) to detect the changes.</p>
<p>
The alternative to double-buffering&#45;not keeping a copy of the data&#45;requires you to make additional function calls when you edit a field of the current record. </p>
<p>
Double-buffering has been a part of the ODBC-based database classes all along. With the DAO database classes, you can turn that mechanism off if you need to for improved efficiency. </p>
<p>
The master switch for this mechanism is called <b>m_bCheckCacheForDirtyFields</b>, dirty meaning “changed.” When you turn this switch ON, you can turn off double-buffering for all or part of the fields. If this master switch is OFF, the entire double-buffering mechanism is disabled.</p>
<p>
The fields for which you’re most likely to turn off double-buffering include memo fields, picture fields, and other BLOBs (binary large objects).</p>
<h2>DAO SDK Classes</h2>
<p>
The DAO SDK includes some C++ database classes that are separate and distinct from the MFC DAO Database classes. These C++ classes encapsulate the individual objects in the DAO hierarchy. While you can mix the DAO SDK C++ classes with the MFC DAO database classes, the DAO SDK C++ classes do not follow the MFC guidelines for operator overloading, and you must exercise caution when using these classes together. For more information, see the article “The DAO of Databases: Using Data Access Objects and the Jet Engine in C++” in the <i>Microsoft Systems Journal</i>, January 1996.</p>
<p>
The following table compares features of the DAO SDK classes and the MFC DAO database classes. </p>
<table>
<tr valign=top>
<td>
<b>DAO SDK Database Classes</b></td>
<td>
<b>MFC DAO Database Classes</b></td>
</tr>
<tr valign=top>
<td>
Simple migration from Visual Basic</td>
<td>
Simple migration from MFC ODBC database classes</td>
</tr>
<tr valign=top>
<td>
Direct mappings to DAO’s OLE automation objects</td>
<td>
Conforms to MFC standard two-phase construction</td>
</tr>
<tr valign=top>
<td>
More Jet/DAO functionality</td>
<td>
AppWizard and ClassWizard support</td>
</tr>
<tr valign=top>
<td>
Doesn’t conform to MFC standard two-phase construction</td>
<td>
Hides more difficult DAO functionality</td>
</tr>
</table><br>
<p>
Using the DAO SDK classes is an easier transition for those accustomed to Visual Basic, but it doesn’t conform to MFC. Those developers who already use the MFC ODBC database classes will find the MFC DAO classes to be more familiar in architecture and usage.</p>
<h2>Comparing the MFC Database Classes</h2>
<p>
Let’s focus first on the common database functionality in both sets of classes.
<ul>
<li>
Both support scrolling through recordsets<p>
<b>ODBC</b> classes rely on the underlying driver.</p>
<p>
<b>DAO</b> classes have better support for MDB, good for installable ISAMs and the same support as the ODBC database classes for server-based data.</p>
</li>
<li>
Both support transactions<p>
<b>ODBC</b> classes at Database level.</p>
<p>
<b>DAO</b> classes at Workspace level.</p>
</li>
<li>
The Recordset update functions are almost identical. <br><br></li>
<li>
Both support locking records during updates.<br><br></li>
<li>
Both sets of classes support detection of field data changes.<br><br></li>
<li>
Both have Move operations.<br><br></li>
<li>
Both <b>CDatabase</b> and <b>CDaoDatabase</b> can detect whether a data source accepts transactions. Transaction requirements have been considerably relaxed in the ODBC database classes as of MFC 4.2.<br><br></li>
<li>
Both database objects allow you to set a predetermined query timeout period. <br><br></li>
<li>
Both can execute direct SQL statements. </li>
</ul>
<h3>Additional ODBC Database Class Functionality</h3>
<ul>
<li>
The ODBC database classes are multithreaded as of MFC 4.2. To take advantage of this capability, you must use a multithreaded ODBC driver. DAO is looking into becoming apartment-model threaded, but no dates have been given for its availability.<br><br></li>
<li>
The bulk row fetching functionality is new in MFC 4.2. Special navigation capabilities have been added. <br><br></li>
<li>
In answer to many requests, we have added better support for console database applications. The new options in <b>CDatabase::OpenEx</b> are: <p>
<b>CDatabase::noOdbcDialog:</b> Do not display the ODBC connection dialog box, regardless of whether enough connection information is supplied.</p>
<p>
<b>CDatabase::forceOdbcDialog:</b> Always display the ODBC connection dialog box.</p>
</li>
</ul>
<h3>Additional DAO Database Class Functionality</h3>
<ul>
<li>
The Workspace, TableDef, and QueryDef objects are unique to the DAO Database classes. There is no direct equivalent for these objects in the ODBC database classes.<br><br></li>
<li>
<b>CDaoTableDef</b> and <b>CDaoQueryDef</b> functionality can generally be reproduced with direct ODBC calls, as found in the CATALOG2 sample. <br><br></li>
<li>
<b>CDaoDatabase</b> supports creation of TableDefs, QueryDefs, and Relations.<br><br></li>
<li>
<b>CDaoRecordset</b> has greater navigation functionality<ul>
<li>
Find operations<br><br></li>
<li>
Percent position<br><br></li>
<li>
Seek<br><br></li>
<li>
Bulk record fetching functionality and related caching is built-in</li>
</ul>
</li>
<li>
The ability to create fields and indexes at runtime using a <b>CDaoTableDef</b> object is a wonderful advantage, as is the validation for data sources that support it.<br><br></li>
<li>
<b>CDaoQueryDefs</b> can be created using fields and indexes and stored for repeated use.<br><br></li>
<li>
CDaoQueryDefs can also control ODBC timeouts.</li>
</ul>
<h2>Optimizing Your MFC Database Application</h2>
<p>
There are some obvious, but often overlooked ways to improve performance for an application. For example, find out what your network might do to enhance or deter data retrieval (for example, asynchronous queries).</p>
<p>
The type of ODBC driver you have may also affect performance across the network. 
<ul>
<li>
<i>Single-tier drivers</i> are intended for non-SQL–based databases. The database file is processed directly by the driver. The driver processes SQL statements and retrieves information from the database. SQL statements, once parsed and translated, are passed to the database as basic file operations. A driver that manipulates an xBASE file is an example of a single-tier implementation.<br><br></li>
<li>
A single-tier driver may limit the set of SQL statements that may be submitted. The minimum set of SQL statements that must be supported by a single-tier driver is defined in the ODBC SDK <i>Programmer’s Reference</i> in Appendix C, “SQL Grammar.”<br><br></li>
<li>
Single-tier drivers are generally slower than using the native DBMS tools such as Microsoft FoxPro, because they parse and translate the SQL statements into basic file operations. The degree to which they are slower depends on how optimized this process is. Difference in speed between two different single-tier drivers is usually attributed to the method of optimization.<br><br></li>
<li>
In a multiple-tier configuration, the driver sends requests to a server that processes these requests. The requests may be SQL or a DBMS-specific format. Although the entire installation may reside on a single system, it is more often divided across platforms. Typically, the application, driver, and Driver Manager reside on one system, called the client. The database and the software that controls access to the database reside on another system, called the server. There are two types of multiple-tier drivers: two-tier and three-tier (or gateway). For more information, see Colleen Lambert’s article &quot;<i>ODBC: Architecture, Performance, and Tuning,</i>&quot; found on the Microsoft Developer Network CD.</li>
</ul>
<h3>Optimizing the ODBC Database and Recordset Objects</h3>
<p>
When you open a <b>CDatabase</b> object, you can supply a data source name or NULL to present the user with a selection dialog. MFC ODBC database classes do not support exclusive access to a database, so connections are always shared. You can, however, open a database as read-only. Remember that if you do, all recordsets derived from this <b>CDatabase</b> object will also be read-only. The following options make writing console applications easier. These new options were among the most requested by customers.
<ul>
<li>
<b>CDatabase::noOdbcDialog:</b> Do not display the ODBC connection dialog box, regardless of whether enough connection information is supplied.<br><br></li>
<li>
<b>CDatabase::forceOdbcDialog:</b> Always display the ODBC connection dialog box.</li>
</ul>
<p>
You have the option of loading the ODBC Cursor Library with your application. Depending on the capabilities of the underlying driver, you may not need it. The Cursor Library masks some functionality of the underlying ODBC driver, effectively preventing the use of dynasets (if the driver supports them). The only cursors supported if the Cursor Library is loaded are static snapshots and “forwardOnly” cursors.</p>
<p>
The type of <b>CRecordset</b> object you open greatly affects the performance of your application. If you want to have a dynamic recordset with bi-directional scrolling, choose the <b>CRecordset::dynaset</b> type. For a static recordset with bi-directional scrolling, choose <b>CRecordset::snapshot</b> type. If you don’t need to scroll around in the data, choose <b>CRecordset::forwardOnly</b> type, which creates a read-only recordset with only forward scrolling. The new <b>CRecordset::dynamic</b> type recordset is a recordset with bi-directional scrolling. Changes made by other users to the membership, ordering, and data values are visible following a fetch operation. Note, however, that many ODBC drivers do not support this type of recordset.</p>
<p>
Additional options for <b>CRecordset</b> include:
<ul>
<li>
<b>CRecordset::none</b>   No options set. By default, the recordset can be updated with <b>Edit</b> or <b>Delete</b> and allows appending new records with <b>AddNew</b>. Updatability depends on the data source as well as on the option you specify.<br><br></li>
<li>
<b>CRecordset::appendOnly</b>   Do not allow <b>Edit</b> or <b>Delete</b> on the recordset. Allow <b>AddNew</b> only.<br><br></li>
<li>
<b>CRecordset::readOnly</b>   Open the recordset as read-only.<br><br></li>
<li>
<b>CRecordset::optimizeBulkAdd</b>   Use a prepared SQL statement to optimize adding many records at one time. This option is mutually exclusive with <b>CRecordset::useMultiRowFetch</b>.<br><br></li>
<li>
<b>CRecordset::useMultiRowFetch</b>   Implement bulk row fetching to allow multiple rows to be retrieved in a single fetch operation. This option is mutually exclusive with <b>CRecordset::optimizeBulkAdd</b>. Note that if you specify <b>CRecordset::useMultiRowFetch</b>, then the option <b>CRecordset::noDirtyFieldCheck</b> will be turned on automatically (double-buffering will not be available); on forward-only recordsets, the option <b>CRecordset::useExtendedFetch</b> will be turned on automatically.<br><br></li>
<li>
<b>CRecordset::skipDeletedRecords</b>   Skip deleted records when navigating through the recordset. This will slow performance in certain relative fetches. This option is not valid on forward-only recordsets. Note that <b>CRecordset::skipDeletedRecords</b> is similar to <i>driver packing</i>, which means that deleted rows are removed from the recordset. <br><br></li>
<li>
<b>CRecordset::useBookmarks</b>   May use bookmarks on the recordset, if supported. Bookmarks slow data retrieval, but improve performance for data navigation. Not valid on forward-only recordsets. <br><br></li>
<li>
<b>CRecordset::noDirtyFieldCheck</b>   Turn off automatic dirty field checking (double-buffering). This will improve performance; however, you must manually mark fields as dirty by calling the <b>SetFieldDirty</b> and <b>SetFieldNull</b> member functions. <br><br></li>
<li>
<b>CRecordset::executeDirect</b>   Do not use a prepared SQL statement. For improved performance, specify this option if the <b>Requery</b> member function will never be called.<br><br></li>
<li>
<b>CRecordset::useExtendedFetch</b>   Implement <b>SQLExtendedFetch</b> instead of <b>SQLFetch</b>. This is designed for implementing bulk row fetching on forward-only recordsets. If you specify the option <b>CRecordset::useMultiRowFetch</b> on a forward-only recordset, then <b>CRecordset::useExtendedFetch</b> will be turned on automatically.<br><br></li>
<li>
<b>CRecordset::userAllocMultiRowBuffers</b>   The user will allocate storage buffers for the data. Use this option in conjunction with <b>CRecordset::useMultiRowFetch</b> if you want to allocate your own storage; otherwise, the framework will automatically allocate the necessary storage.</li>
</ul>
<p>
If you want, you can use bulk row fetching to improve performance. Before opening your recordset object, you can define a rowset size with the <b>SetRowsetSize</b> member function. The rowset size specifies how many records should be retrieved during a single fetch. When bulk row fetching is implemented, the default rowset size is 25. Note that if bulk row fetching is not implemented, the rowset size remains fixed at 1.</p>
<p>
After you have initialized the rowset size, call the <b>Open</b> member function. Here you must specify the <b>CRecordset::useMultiRowFetch</b> option of the <i>dwOptions</i> parameter to implement bulk row fetching. You can additionally set the <b>CRecordset::userAllocMultiRowBuffers</b> option. The bulk record field exchange mechanism uses arrays to store the multiple rows of data retrieved during a fetch. These storage buffers can be allocated automatically by the framework, or you can allocate them manually. Specifying the <b>CRecordset::userAllocMultiRowBuffers</b> option means that you will do the allocation.</p>
<h3>Optimizing the DAO Database and Recordset Objects</h3>
<p>
When you use a <b>CDaoDatabase</b> object, you use a string expression that is the name of an existing Microsoft Jet (.MDB) database file. If the filename has an extension, it is required. If your network supports the uniform naming convention (UNC), you can also specify a network path, such as “\\\\MYSERVER\\MYSHARE\\MYDIR\\MYDB.MDB.” (Double backslashes are required in string literals, because “\” is the C++ escape character.) Some considerations apply when using the database this way. </p>
<p>
If a database is already open for exclusive access by another user, MFC throws an exception. Use that exception to let your user know that the database is unavailable.</p>
<p>
If you open the database with an empty string (&quot;&quot;) and you’re connecting to an ODBC data source, a dialog box listing all registered ODBC data source names is displayed so that the user can select a database. You should avoid direct connections to ODBC data sources; use a linked table instead.</p>
<p>
<b>CDaoDatabase</b> object can be opened for exclusive access. By default, it is opened for shared access. You can open it as a read-only data source, or for read/write access. All recordsets derived from a <b>CDaoDatabase</b> object inherit the read capabilities of the database object.</p>
<p>
As with the <b>CRecordset</b> object, a <b>CDaoRecordset</b> has more than one type. If you select <b>dbOpenDynaset</b>, you have a dynaset-type recordset with bi-directional scrolling. This is the default. A <b>dbOpenSnapshot</b> selection gives you a snapshot-type recordset with bi-directional scrolling. Finally, you can open a table-type recordset with bi-directional scrolling using <b>dbOpenTable.</b> You cannot open a recordset based on a table with the MFC ODBC database classes.</p>
<p>
A <b>CDaoRecordset</b> object has options similar to that of a <b>CRecordset</b> object. 
<ul>
<li>
<b>dbAppendOnly:</b> You can only append new records (dynaset-type recordset only). This option means literally that records may only be appended. The MFC ODBC database classes have an append-only option that allows records to be retrieved and appended.<br><br></li>
<li>
<b>dbForwardOnly:</b> The recordset is a forward-only scrolling snapshot.<br><br></li>
<li>
<b>dbSeeChanges:</b> Generate an exception if another user is changing data you are editing. <br><br></li>
<li>
<b>dbDenyWrite:</b> Other users cannot modify or add records. <br><br></li>
<li>
<b>dbDenyRead:</b> Other users cannot view records (table-type recordset only).<br><br></li>
<li>
<b>dbReadOnly:</b> You can only view records; other users can modify them. <br><br></li>
<li>
<b>dbInconsistent:</b> Inconsistent updates are allowed (dynaset-type recordset only).<br><br></li>
<li>
<b>dbConsistent:</b> Only consistent updates are allowed (dynaset-type recordset only). <p>
<b>Note</b>&nbsp;&nbsp;&nbsp;The constants <b>dbConsistent</b> and <b>dbInconsistent</b> are mutually exclusive. You can use one or the other, but not both in a given instance of Open.</p>
</li>
</ul>
<h3>Optimizing ODBC-Based Database Interactions</h3>
<p>
The following recommendations apply to any interaction that involves ODBC. This applies to the ODBC database classes, but also to the DAO database classes used with server-based data where DAO uses ODBC to communicate with the data source. Many of these recommendations come from Colleen Lambert’s article &quot;<i>ODBC: Architecture, Performance, and Tuning,</i>&quot; found on the Microsoft Developer Network CD. 
<ul>
<li>
Use as much of a driver’s capabilities as possible by querying driver conformance levels. If you do not need to port an application to another platform, you can maximize your application’s capabilities by focusing on the capabilities of a particular driver. <br><br></li>
<li>
Avoid calling data source catalog routines. These can be very time-consuming. Try calling the routine once and cache the information locally. <br><br></li>
<li>
Keep scalability in mind and put data locally and remotely as appropriate. Try to avoid filling combo boxes with data from remoted data sources. <br><br></li>
<li>
Use <b>SQLExtendedFetch</b> for scrolling. If your driver supports it, this is the fastest way to scroll around your ODBC data source.<br><br></li>
<li>
Prepared SQL statements run faster. Take the time to prepare your SQL calls so that they attach to an HSTMT, which won’t be freed until that handle is freed.<br><br></li>
<li>
Use <b>SQLBindCol</b> rather than <b>SQLGetData</b>. <b>SQLBindCol</b> takes care of the storage and the data type for a column so that you don’t have to reacquire it for a result set.<br><br></li>
<li>
Cache <b>SQLTypeInfo</b> locally. Some data sources handle this call as a stored procedure, which can be very expensive to execute.<br><br></li>
<li>
Use as few connections as possible and avoid disconnecting and reconnecting repeatedly. Remember that the ODBC driver manager makes calls to prepare a connection in addition to calls made by the driver. All that overhead adds up, and can slow an application considerably.<br><br></li>
<li>
Use block fetches for multiple-tier drivers. Multiple-tier drivers often use the network capabilities as part of their own work, and relying on <b>SQLFetch</b> instead of <b>SQLExtendedFetch</b> exposes your application to the vagaries of network operation. <br><br></li>
<li>
Optimize your queries by knowing your SQL thoroughly. This may seem obvious, but many programmers get by on a limited set of SQL commands, when more study and refining of SQL statements could mean the difference between a fast application and an even faster one.<br><br></li>
<li>
Use high-performance DBMSs. We talked about this at the beginning of the papera good data source is fundamental to the abilities and operation of an application. Get the best one your client can afford.</li>
</ul>
<p>
The following recommendations are specifically applicable to the DAO database classes. The starred items in this list refer primarily to interactions with ODBC (server-based) data sources. 
<ul>
<li>
Use linkedtables instead of directly opened tables whenever possible. See the article DAO External: Working with External Data Sources and the topic Accessing External Databases with DAO in DAO Help. <b>This recommendation has the most significant impact on performance of all the recommendations in this list.*</b><br><br></li>
<li>
Don't use dynaset-type recordsets if you're not updating the data. Use forward-scrolling snapshot-type recordsets if you're only scrolling forward. Don't scroll through records unnecessarily and avoid jumping to the last record of a large table.<br><br></li>
<li>
Retrieve and view only the data you need. Use restricted queries to limit the number of records you retrieve and select only the columns you need. This requires transferring less data across the network.<br><br></li>
<li>
Use caching. In class CDaoRecordset, MFC supports caching a specified number of records. Doing so takes longer initially, when the data is retrieved into the cache, but moving through the records in the cache is faster than retrieving each record as it is scrolled to.*<br><br></li>
<li>
Turn off the double-buffering option in MFC CDaoRecordset objects. This is a general way to improve performance that applies as well to working with external data sources.<br><br></li>
<li>
For bulk operations, such as adding records in bulk, use an SQL pass-through query. When you use an SQL pass-through query, you only need to set the connection information once, as long as you are always performing your SQL pass-through queries through the same connection.*<br><br></li>
<li>
Avoid using queries that cause processing to be done locally.* Don't use user-defined functions with remote column arguments. Use heterogeneous joins (joins on tables in two databases) only on indexed columns, and realize if you do this that some processing is done locally. When accessing external data, the Microsoft Jet database engine processes data locally only when the operation can't be performed by the external database. Query operations performed locally include:<ul>
<li>
<b>WHERE clause restrictions on top of a query with a DISTINCT predicate.</b> Often, you can rearrange your queries to calculate totals or DISTINCT queries after all other operations.<br><br></li>
<li>
<b>WHERE clauses containing operations that can't be processed remotely</b>, such as user-defined functions that involve remote columns. (Note that in this case only the parts of the WHERE clause that can't be processed remotely will be processed locally.)<br><br></li>
<li>
<b>Joins between tables from different data sources.</b> Simply having joins between tables from different data sources doesn't mean that all of the processing occurs locally. If restrictions are sent to the server, only relevant rows are processed locally.<br><br></li>
<li>
<b>Joins over aggregation or the DISTINCT predicate.</b> Doing joins properly is an art anyway, and adding aggregation functions such as AVG, MAX, and MIN, or a predicate containing DISTINCT will only slow down your queries.<br><br></li>
<li>
<b>Outer joins containing syntax not supported by the ODBC driver.</b> The Desktop Database Drivers support left and right outer joins, as well as inner joins. The right table in a left outer join, or the left table in a right outer join, can be used in an inner join. Full and nested outer joins are not supported.</li>
</ul>
</li>
</ul>
<p>
The next three items apply specifically to data you’re trying to access from a remote data source.
<ul>
<li>
DISTINCT predicates containing operations that can't be processed remotely. <br><br></li>
<li>
ORDER BY arguments (if the remote data source doesn't support them). <br><br></li>
<li>
ORDER BY or GROUP BY arguments containing operations that can't be processed remotely. <br><br></li>
<li>
A <i>non-remoteable </i>expression is one that cannot be evaluated by your server. Non-remoteable output expressions (those in the SELECT clause) don’t force local evaluation of your query unless they occur in a totals query, a DISTINCT query, or a UNION query. Non-remoteable expressions in other clauses (WHERE, ORDER BY, GROUP BY, HAVING, and so on) force at least part of your query to be evaluated locally.<br><br></li>
<li>
GROUP BY arguments on top of a query with a DISTINCT option. Use SELECT DISTINCTROW followed by the GROUP BY clause. </li>
</ul>
<p>
The following features are unsupported on all known ODBC-accessible servers&#45;usually operations that are Microsoft Jet-specific extensions to SQL such as: 
<ul>
<li>
Multiple-level GROUP BY arguments, such as those used in reports with multiple grouping levels. <br><br></li>
<li>
TOP or TOP PERCENT predicate. <br><br></li>
<li>
Cross-tab queries that have more than one aggregate or that have an ORDER BY clause that matches the GROUP BY clause. Simple crosstab queries can be sent to the server.</li>
</ul>
<h3>Other Resources for Optimizing Your Applications</h3>
<p>
The documentation that ships with Visual C++ should be your first source of information about MFC’s implementation of DAO. Be sure to look over the MFC DAO samples and MFC Technical notes as well as the <i>Class Library Reference</i> and <i>Programming with MFC</i>. </p>
<p>
For additional information on how DAO works, consult the <i>Microsoft Jet Database Engine Programmer’s Guide,</i> published by Microsoft Press.</p>
<p>
Two additional articles found on the Microsoft Developer Network CD are recommended: 
<ul>
<li>
Black, Neil, and Stephen Hecht. “Jet Database Engine ODBC Connectivity.”<p>
This describes in great detail how Microsoft Jet uses ODBC to retrieve server data. Required reading for anyone using DAO to write significant server applications.</p>
</li>
<li>
Lambert, Colleen. “ODBC: Architecture, Performance, and Tuning.”</li>
</ul>
<p>
This paper provides a good overview of how ODBC works and addresses performance issues in a realistic and useful fashion.</p>
<h2>In Conclusion</h2>
<p>
MFC’s fundamental concept of providing high-level abstractions to more complicated technologies is true in these database classes. You have choices&#45;ODBC or DAO&#45;to give you your best route to success with your clients.</p>
<p>
We’ve taken quite a bit of time to examine ways to improve performance, seen some numbers on how the classes perform on a variety of data sources, and given you lots of things to think about. Whatever you do, prototype before you decide. We hope that today’s session will help narrow your options and make your decision easier to reach.</p>
<p>
&copy; 1997 Microsoft Corporation. All rights reserved.</p>
<p>
The information contained in this document represents the current view of Microsoft Corporation on the issues discussed as of the date of publication. Because Microsoft must respond to changing market conditions, it should not be interpreted to be a commitment on the part of Microsoft, and Microsoft cannot guarantee the accuracy of any information presented after the date of publication.</p>
<p>
This document is for informational purposes only. MICROSOFT MAKES NO WARRANTIES, EXPRESS OR IMPLIED, IN THIS DOCUMENT.</p>
<p>
Microsoft, FoxPro, Visual Basic, Visual C++, and Windows are registered trademarks of Microsoft Corporation.</p>
<p>
Other product and company names listed herein may be the trademarks of their respective owners.</p>
</font></BODY>
</HTML>
