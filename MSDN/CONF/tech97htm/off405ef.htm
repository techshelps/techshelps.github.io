<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Creating Large-Scale Applications with Microsoft Access 97 </title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>



	<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>



	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<h1>Creating Large-Scale Applications with Microsoft Access 97 </h1>
<p>
Presented by James Sturms</p>
<h2>Session Goal</h2>
<p>
The goal of this session is to enable the developer of Microsoft&reg;&nbsp;Access-based applications to be able to use and understand fully the Microsoft&nbsp;Access Upsizing Tools. The developer should be able to use the tools to facilitate client-server development between Microsoft&nbsp;Access and Microsoft&reg; SQL Server™. The session will discuss design strategies for using the tool optimally in the development process.</p>
<h3>What You Will Learn</h3>
<ul>
<li>
Have a clear understanding of the Microsoft&nbsp;Access Upsizing Tools and how it interacts with Microsoft SQL Server.<br><br></li>
<li>
Understand how to prepare for the upsizing process, complete upsizing, and take the next steps required to make your application’s complete client-server solutions.</li>
</ul>
<h2>Overview</h2>
<p>
This session will break down into three sections:
<ul>
<li>
First we will discuss the benefits of upsizing and the steps one needs to take before the upsizing process begins.<br><br></li>
<li>
We will then detail the upsizing process, discussing exactly what the Upsizing Tools can do and cannot do.<br><br></li>
<li>
Finally, we will discuss the next steps required after upsizing in order to complete your client-server application.</li>
</ul>
<p>
The Upsizing Tools and the sample application used in this document will be available on your conference CD. The application is for your personal use: You may learn from it and reuse code segments. They cannot be redistributed, however, for production use.</p>
<p>
The reader should be familiar with the design of Microsoft&nbsp;Access-based applications and conversant with Microsoft&nbsp;Access programming techniques. No prior experience with Structured Query Language (SQL) database data sources is needed for this session.</p>
<p>
This session focuses on the use of the Microsoft&nbsp;Access Upsizing Tools. The tools, which were released in January of 1997, are a free add-on for Microsoft&nbsp;Access 97. The tools are designed to work with Microsoft SQL Server database management system versions 4.21, 6.0, and 6.5. You need both Microsoft Access 97 and Microsoft SQL Server to use the Upsizing Tools.</p>
<p>
The Upsizing Tools consist of two major components:
<ul>
<li>
Upsizing Wizard<br><br></li>
<li>
SQL Server Browser</li>
</ul>
<p>
Below is a description of these two major components that we will be discussing throughout the session.</p>
<h3>Upsizing Wizard</h3>
<p>
The first component of the Upsizing Tools is the Upsizing Wizard. It takes a Microsoft&nbsp;Access database and creates an equivalent database on SQL Server with the same table structure, data, and many other attributes of the original Microsoft&nbsp;Access database.</p>
<p>
This will allow developers who design client-server applications on their desktop in Microsoft&nbsp;Access to generate a SQL Server database from their prototype. Also, developers who have existing Microsoft&nbsp;Access-based applications will be able to “grow” those applications to SQL Server and gain the benefits of a client-server architecture.</p>
<h3>SQL Server Browser</h3>
<p>
The SQL Server Browser allows developers to view, create, and edit SQL Server objects including tables, views, defaults, rules, stored procedures, and triggers. The Browser can be used to manage a SQL Server database created by the Upsizing Wizard or any other existing SQL Server objects.</p>
<h2>Before Upsizing</h2>
<p>
The first question we need to discuss is, “Why do we want to upsize a file server database to client-server?” The main reasons to do this are the benefits that a client-server configuration can offer, including improved performance, security, and reliability. Database application solutions inherently grow and become more complex over time. Developers need the assurance that they have a path to scale as their applications become larger and more complex and must support more users. In addition to scaling an existing application, the process of upsizing is useful for jump-starting client-server development. By this I mean that Microsoft&nbsp;Access is a very powerful file server database management system that, in addition to allowing a developer to build solid solutions, also offers the ability to rapidly prototype client-server solutions for prospective clients. Microsoft&nbsp;Access’ rapid application development tools allow for many iterations of a prototype without the inherent complexities of client-server. It also allows for testing the initial designs without deploying the final, more robust back end. Once the plan is final, the upsizing process allows the developer to use the initial prototyping work to quickly build the data structure and rules on the server to jump-start the server-based work.</p>
<p>
Before we can upsize an application to SQL Server, there are several important design issues we need to take into consideration. Ideally, we would design an application with client-server deployment in mind from the very beginning. As we will see, the design to build an optimized client-server application is often very different than a file server-only application. If you have an existing application that was not built with client-server in mind you will likely need to retrofit your application in order to take advantage of the upsizing process to follow.</p>
<h3>Design Tips&#45;Client Side</h3>
<ul>
<li>
Design forms so that a form does not require data to be retrieved from the server during the form-opening process. Add a command button to the form to fetch data to populate the form. In many cases, you may want to save the last set of form data in a local table, then load the form from the saved data the first time the user opens the form.<br><br></li>
<li>
Use <b>Recordset</b> objects of the <b>Snapshot</b> type if the result set contains relatively few columns and doesn’t contain OLE Object or large Memo fields, and you don’t need to update the server tables. Set the value of the <code>RecordSetType</code> property of the form to Snapshot to create a <b>Snapshot</b> instead of a <b>Dynaset</b>. Pass-through queries always return <b>Snapshot Recordset</b> objects.<br><br></li>
<li>
Minimize the number of items in server-populated pick list combo boxes. Use <b>Snapshot Recordset</b> objects to populate the combo boxes. It is important to remember that as database sizes increase, certain solutions may become unworkable. For instance, a combo box of 30 records is reasonable for a user to browse and pick from. When the list of possibilities is in the hundreds, this list becomes unworkable.<br><br></li>
<li>
If pick list data changes infrequently, maintain a local copy of the server table that populates the combo boxes. Include only the field(s) you need for the pick list in the table. Create an index on the local table to speed pick list population. Provide the user a simple means of replacing the local tables.<br><br></li>
<li>
If decision-support application users need to compare multiple sets of data, consider storing the data returned by the server in temporary local tables. Provide a form in which the user can elect to use the previously stored data, or execute a new query. Adding the ability to quickly compare results of successive queries is especially important in applications that process financial information.<br><br></li>
<li>
Adhere to server-based naming restrictions from the beginning. The Upsizing Wizard will correct many common mistakes in this regard, but not 100 percent. It is best to adhere to SQL Server’s restrictions from the beginning in order to assure a painless migration to the back end. SQL Server names must be 30 characters or less. The first character must be a letter or the symbol “@”. The remaining characters may be numbers, letters, or the “$,” “#,” and “_” symbols. No spaces are allowed.<br><br></li>
<li>
In code, do not use table-specific commands such as Table-Type RecordSets, DoCmd.OpenTable, or the SEEK method. These operations are only supported on the local Jet tables and will break if they are suddenly referring to server-based tables.</li>
</ul>
<p>
<b>Create ODBC data source</b></p>
<p>
You need to make sure you have the Open Database Connectivity (ODBC) data source you will need for upsizing. You should also decide which database you plan to upsize and make a backup copy of it.</p>
<p>
The Upsizing Wizard requires that you log in to a SQL Server database. If you are creating a new SQL Server database, you should make sure you have an ODBC data source for the Master database for the SQL Server you want to upsize to.</p>
<p>
If you are upsizing to an existing database, the Pubs sample database for instance, make sure you have an ODBC data source for Pubs.</p>
<p>
You can create an ODBC data source by running the ODBC Administrator. When using Microsoft&reg; Windows 95&reg; or Microsoft&reg; Windows NT&reg; 4.0, you create an ODBC data source using the 32bit ODBC icon in the Control Panel.</p>
<p>
<b>Important</b>&nbsp;&nbsp;&nbsp;If you click Options, and then select the Convert OEM to ANSI Characters check box when you create your data source, you must click Select and then specify a code page translator. If you select the Convert OEM to ANSI Characters check box and don’t select a code page translator, the Upsizing Wizard will fail.</p>
<h3>Design Tips&#45;Server Side</h3>
<ul>
<li>
To make upsizing go as smoothly as possible, you should make sure that you have sufficient permissions on the SQL Server you want to upsize to. Calculate how much disk space upsizing will require and make sure you have enough free disk space.<br><br></li>
<li>
The permissions you need vary according to what you want to accomplish. At minimum, you must have CREATE TABLE permissions on the server you wish to upsize to. This will allow you to upsize to existing databases.<br><br></li>
<li>
If you want to build a new database from scratch, you must have CREATE DATABASE permissions. Finally, if you want to create new devices, you must be a member of the admin group.</li>
</ul>
<p>
<b>Estimate SQL Server database and device size</b></p>
<p>
If you are creating a new database, the Upsizing Wizard will ask you to select devices for your database and, optionally, a log. It will also ask you to set the size of the database itself. In order to answer these questions, you should estimate how much space your new database will require. </p>
<p>
Database size</p>
<p>
When SQL Server creates a database, it sets aside a fixed amount of space for that database on one or more devices. Not all this space is necessarily used by the database. Database size is just the upper limit on how large a database can grow before it runs out of space.</p>
<p>
By looking at the size of your Microsoft&nbsp;Access database and estimating the rate at which your new SQL Server database will grow, you can arrive at a rough estimate of the space needed for your database. </p>
<p>
If you have ample disk space on your server, simply multiply the size of your Microsoft&nbsp;Access database by two. This will ensure that the Upsizing Wizard has enough space to upsize your database and leave it some room to grow as well. If you expect a lot of data to be added to the database, you should make the multiple larger.</p>
<p>
The Upsizing Wizard works best when there is plenty of disk space available. In situations where disk space is scarce, it is possible to fit a Microsoft&nbsp;Access database onto&nbsp;a SQL Server database less than twice its size. In general, every megabyte of Microsoft&nbsp;Access data will require 1.3 to 1.5 megabytes on SQL Server. Remember that the size of a Microsoft&nbsp;Access MDB file includes all Microsoft&nbsp;Access objects, not just data. </p>
<p>
Device size</p>
<p>
All SQL Server databases and logs are placed on devices. At one level, a device is merely a logical location to put databases and logs. At a lower level, a device is a physical file. When a device is created, SQL Server creates a file, thus reserving a set amount of disk space for its own use. A device can be thought of as a fixed portion of disk space that SQL Server sets aside for its own use.</p>
<p>
If no devices have enough free space, you may create a new device using the Upsizing Wizard. New devices should be at least as big as your estimated database size. It is recommended that you make the device still larger, if possible. This will let you expand your new database later or place other databases or logs on the same device.</p>
<p>
In SQL Server 4.21, the size of a device cannot be changed. Make sure you create devices that are sufficiently large. SQL Server 6.x allows you to increase the size of your devices, but not decrease them.</p>
<p>
Once you’ve arrived at an estimate of how much space your new database will require, you will know how big a device you must have. The Upsizing Wizard will show how much free space is available on each available SQL Server device and allow you to choose which one you want.</p>
<p>
<b>Devices</b></p>
<p>
In most cases, the Upsizing Wizard provides more than enough control over SQL Server devices. There are two cases where you may wish to create devices before running the Upsizing Wizard.</p>
<p>
Servers with more than one physical disk</p>
<p>
If your server has more than one physical hard disk, you may want to place your database on one disk and the log for the database on a different disk. In the event of a disk failure, the likelihood of recovering will be much greater.</p>
<p>
The Upsizing Wizard allows you to create new devices, but only on one physical disk<font face="Symbol"><span style="font-family:symbol">&#190;</span></font>the same disk as the Master database device. To place a database and log on separate disks, make sure you have devices that are big enough on both disks, creating new devices if necessary, then run the Upsizing Wizard.</p>
<p>
Placing new databases or logs on multiple devices</p>
<p>
SQL Server allows databases and logs to span several devices. However, the Upsizing Wizard allows you to place databases and logs only on a single device or the “Default” device.</p>
<p>
If you want to specify multiple devices for a database or log, make those devices default devices. Make sure only those devices are set as default. Then run the Upsizing Wizard and choose “Default” for the database or log device. </p>
<p>
Note that if the size you specify in the Upsizing Wizard for the new SQL Server database, or the size of the log doesn’t require using all the devices set as default, SQL Server will use only the devices necessary to accommodate the database or log. </p>
<h2>The Upsizing Process</h2>
<p>
The Upsizing Wizard allows you to create a new SQL Server database. However, if you have previously upsized your Microsoft&nbsp;Access database, or you want to add Microsoft&nbsp;Access tables to an existing SQL Server database, you can upsize to an existing database.</p>
<p>
<img src="off405ef_1.gif" border=0></p>
<h3>Exporting Table Properties and Linking Server&nbsp;Tables</h3>
<p>
The Upsizing Wizard can export additional table properties and create timestamp columns in the SQL Server table. The wizard can also modify your Microsoft&nbsp;Access database so that your queries, forms, and reports use the data in your new SQL Server tables, rather than the data in the local Microsoft&nbsp;Access database.</p>
<p>
<img src="off405ef_2.gif" border=0></p>
<h3>Timestamp Columns</h3>
<p>
By default, the Upsizing Wizard creates new columns with the data type of timestamp in SQL Server tables generated from Microsoft&nbsp;Access tables which contain floating-point (single or double), memo, or OLE fields.</p>
<p>
A timestamp field contains a unique value, generated by SQL Server, which is updated whenever the record is updated. Microsoft&nbsp;Access uses the value in timestamp fields to see if a record has been changed before updating it. </p>
<p>
A timestamp field provides the best performance and reliability. In the absence of a timestamp field, the Microsoft&nbsp;Access Jet engine must check all the fields in the record to determine if the record has changed, this will slow performance.</p>
<p>
Microsoft&nbsp;Access does not check to determine if text or image fields have changed because these fields could be many megabytes in size and the comparison could be too network intensive and time consuming. Therefore, if only a text or image field has changed and there is no timestamp field, the Microsoft&nbsp;Access Jet engine will overwrite the change. Also, the value of a floating-point field may appear to have changed when it hasn’t, so Microsoft&nbsp;Access may determine that the record has been changed when it has not. </p>
<p>
You can also choose to have the Upsizing Wizard create a timestamp field for all upsized tables, regardless of what field types they contain. In particular, this improves the performance of tables that don't contain Memo, OLE Object, or floating-point fields, but have many fields of other types. A timestamp field prevents Microsoft Jet from having to check all of the fields to determine if a record has been changed.</p>
<p>
<b>Linking server tables</b></p>
<p>
The Upsizing Wizard can modify your Microsoft&nbsp;Access database so that your queries, forms, and reports use the data in the new SQL Server database rather than the data in your Microsoft&nbsp;Access database. </p>
<p>
The wizard renames the Microsoft&nbsp;Access tables you export with the suffix “_local.”  For instance, if you export a table named “Employees,” the table is renamed “Employees_local” in your database. Then, the Wizard creates a linked SQL Server table named “Employees.” </p>
<p>
Forms, reports, and queries based on the original Employees tables will now use the SQL Server “Employees” table.</p>
<p>
<b>Field names and aliasing queries</b></p>
<p>
SQL Server will not allow spaces or symbols in field names other than #, $, and _. The Upsizing Wizard automatically replaces spaces and illegal characters with the “_” symbol.</p>
<p>
If field names were changed when a table was exported, the wizard names the linked table with the suffix “_remote.” The Upsizing Wizard then creates an aliasing query, so that forms, reports, and queries will work properly on the new server table.</p>
<p>
For example, if you export a table “Employees,” the wizard creates a linked table called “Employees_remote” and renames the “Employees” table to “Employees_local.” The wizard then creates an aliasing query called “Employees,” to accommodate the fact that the field names on the SQL Server are different.</p>
<p>
<img src="off405ef_3.gif" border=0></p>
<p>
<b>Figure 1. There is no performance penalty for using aliasing queries instead of linked tables.</b></p>
<h3>Finishing</h3>
<p>
When you reach the final screen in the Upsizing Wizard, it offers to create an Upsizing Report. The upsizing report documents what objects the Upsizing Wizard created on SQL Server. It includes information about any devices and databases that were created as well as a complete explanation of how each Microsoft&nbsp;Access object that was upsized maps to a SQL Server object. After upsizing is complete, you can view this report on screen or print it for future reference. The upsizing report cannot be saved to disk. In order to save this information, you must print the report or output the report to Microsoft Word.</p>
<h2>How the Upsizing Wizard Works </h2>
<p>
The Upsizing Wizard makes upsizing a Microsoft&nbsp;Access database to SQL Server practically transparent. </p>
<p>
This section refers to specific SQL Server objects that are created when the database, Employee.MDB, is upsized. This sample database is included with the Upsizing Tools. You may find the examples easier to understand if you upsize this database and then use the SQL Server Browser to access the objects discussed in the examples.</p>
<h3>Overview of Object Mapping</h3>
<p>
To upsize a Microsoft&nbsp;Access database to SQL Server, the Upsizing Wizard creates SQL Server objects that, as far as possible, do everything the Microsoft&nbsp;Access database did.</p>
<p>
In some cases, mapping Microsoft&nbsp;Access objects to SQL Server objects is very straightforward. Microsoft&nbsp;Access databases, tables, fields, defaults, and indexes map to SQL Server databases, tables, fields, defaults, and indexes. This is a direct, one-to-one mapping.</p>
<p>
However, this is not the case for all objects. Validation rules and referential integrity, in Microsoft&nbsp;Access, are part of the data dictionary and are enforced at the engine level. In SQL Server, validation rules and referential integrity can also be implemented with code bound to a table (triggers).</p>
<p>
These differences, as well as design decisions made by the Upsizing Wizard, mean that much of the Microsoft&nbsp;Access data dictionary cannot be mapped directly to SQL Server constructs.</p>
<p>
The following table summarizes how objects are mapped from Microsoft&nbsp;Access objects to SQL Server:</p>
<table>
<tr valign=top>
<td>
<b>Microsoft&nbsp;Access</b></td>
<td>
<b>SQL Server 4.21</b></td>
<td>
<b>SQL Server 6.x</b></td>
</tr>
<tr valign=top>
<td>
Database</td>
<td>
Database</td>
<td>
Database</td>
</tr>
<tr valign=top>
<td>
Table</td>
<td>
Table</td>
<td>
Table</td>
</tr>
<tr valign=top>
<td>
Indexes</td>
<td>
Indexes</td>
<td>
Indexes</td>
</tr>
<tr valign=top>
<td>
Primary Keys</td>
<td>
Non-clustered Unique Index</td>
<td>
Non-clustered Unique Index,  Primary Key</td>
</tr>
<tr valign=top>
<td>
Field</td>
<td>
Field</td>
<td>
Field</td>
</tr>
<tr valign=top>
<td>
Default</td>
<td>
Default</td>
<td>
Default</td>
</tr>
<tr valign=top>
<td>
Table validation rule</td>
<td>
Update and Insert triggers</td>
<td>
Update and Insert triggers</td>
</tr>
<tr valign=top>
<td>
Field validation rule</td>
<td>
Update and Insert triggers</td>
<td>
Update and Insert triggers</td>
</tr>
<tr valign=top>
<td>
Field Required property</td>
<td>
Update and Insert triggers</td>
<td>
Update and Insert triggers</td>
</tr>
<tr valign=top>
<td>
Relations</td>
<td>
Update, Insert, and Delete triggers</td>
<td>
Update, Insert, and Delete triggers or DRI</td>
</tr>
</table><br>
<p>
The following sections discuss each Microsoft&nbsp;Access object and the SQL Server object (or objects) to which it maps.</p>
<p>
<b>Database and table objects</b></p>
<p>
A Microsoft&nbsp;Access .MDB file maps directly to a SQL Server database. A Microsoft&nbsp;Access table, excluding much of its data dictionary, maps to a SQL Server table.</p>
<p>
The Upsizing Wizard replaces illegal characters with the “_” symbol. Any names that are SQL Server keywords, FROM or GROUP for example, have the “_” symbol appended to them, resulting in the names FROM_ and GROUP_.</p>
<p>
<b>Links to new server tables</b></p>
<p>
If you selected the Attach newly created SQL Server tables check box, the Upsizing Wizard will create the linked tables as well as give them many of the properties of the fields in the original local table.</p>
<p>
Fields in linked tables inherit the following properties from the original fields:
<ul>
<li>
Description<br><br></li>
<li>
Caption<br><br></li>
<li>
Format<br><br></li>
<li>
InputMask<br><br></li>
<li>
DecimalPlaces<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;Linked tables were referred to as Attached tables in Microsoft Access 2.0.</p>
</li>
</ul>
<p>
<b>Indexes</b></p>
<p>
SQL Server and Microsoft&nbsp;Access indexes are very similar. Microsoft&nbsp;Access primary keys are converted to SQL Server non-clustered, unique indexes. The primary key index is always named with a prefix of “aaaaa.”  In SQL Server 6.x, this index is also marked as a SQL Server Primary Key. When linking to a remote table, Microsoft&nbsp;Access chooses the index that is first alphabetically in the list of available indexes as the primary key. The “aaaaa” prefix ensures that the right index is chosen. All other indexes retain their names, except where they contain illegal characters. Illegal characters are replaced with the “_” symbol.</p>
<p>
Unique and non-unique Microsoft&nbsp;Access indexes become unique and non-unique SQL Server indexes. SQL Server doesn’t support ascending or descending indexes.</p>
<p>
<b>Example</b></p>
<p>
The following table lists the indexes created when an Employees table is upsized.</p>
<table>
<tr valign=top>
<td>
<b>Microsoft&nbsp;Access Index Name</b></td>
<td>
<b>Index type</b></td>
<td>
<b>SQL Server Index&nbsp;Name</b></td>
<td>
<b>Index type</b></td>
</tr>
<tr valign=top>
<td>
PrimaryKey</td>
<td>
Unique primary key</td>
<td>
aaaaaEmployees_PK</td>
<td>
Unique</td>
</tr>
<tr valign=top>
<td>
Dept ID</td>
<td>
Non-unique, ascending</td>
<td>
Dept_ID</td>
<td>
Non-unique</td>
</tr>
<tr valign=top>
<td>
Reports To</td>
<td>
Non-unique, ascending</td>
<td>
Reports_To</td>
<td>
Non-unique</td>
</tr>
</table><br>
<p>
<b>Fields</b></p>
<p>
Field names and data types are automatically translated into SQL Server fields when a Microsoft&nbsp;Access table is exported by the Upsizing Wizard.</p>
<p>
Microsoft&nbsp;Access data types map to SQL Server data types as follows:</p>
<table>
<tr valign=top>
<td>
<b>Microsoft&nbsp;Access Type</b></td>
<td>
<b>SQL Server Type</b></td>
</tr>
<tr valign=top>
<td>
Yes/No</td>
<td>
bit</td>
</tr>
<tr valign=top>
<td>
Number (Byte)</td>
<td>
smallint</td>
</tr>
<tr valign=top>
<td>
Number (Integer)</td>
<td>
smallint</td>
</tr>
<tr valign=top>
<td>
Number (Long Integer)</td>
<td>
int</td>
</tr>
<tr valign=top>
<td>
Number (Single)</td>
<td>
real</td>
</tr>
<tr valign=top>
<td>
Number (Double)</td>
<td>
float</td>
</tr>
<tr valign=top>
<td>
Currency</td>
<td>
money</td>
</tr>
<tr valign=top>
<td>
Date/Time</td>
<td>
datetime</td>
</tr>
<tr valign=top>
<td>
AutoNumber</td>
<td>
int </td>
</tr>
<tr valign=top>
<td>
Text(n)</td>
<td>
varchar(n)</td>
</tr>
<tr valign=top>
<td>
Memo</td>
<td>
text</td>
</tr>
<tr valign=top>
<td>
OLE Object</td>
<td>
image</td>
</tr>
</table><br>
<p>
<b>Defaults</b></p>
<p>
A Microsoft&nbsp;Access default expression maps directly to a single SQL Server default. While largely similar, there are some differences in the way defaults are created and behave in the two products.</p>
<p>
SQL Server defaults are independent of any particular field or table. Once a default has been created, it can be used or “bound” to any number of different fields. The Upsizing Wizard tries to create a SQL Server default based on the default expression for a Microsoft&nbsp;Access field.</p>
<p>
Defaults created by the Upsizing Wizard are named according to the SQL Server table to which they are bound, with a number that represents the position of the field in the Microsoft&nbsp;Access table definition. (This is the same as the order in which the fields appear in table design view.)</p>
<p>
If two or more fields have the same nonzero default expression, the Upsizing Wizard creates two defaults that are functionally identical with different names. Fields with a default expression of zero are bound to a default named UW_ZeroDefault.</p>
<p>
Any Yes/No fields that don’t have a default will automatically have a “no” default bound to them. This makes interaction between Microsoft&nbsp;Access and SQL Server much smoother.</p>
<p>
The upsizing report will indicate whether the Upsizing Wizard was successful in translating the Microsoft&nbsp;Access expression to SQL Server Transact-SQL. If the default was successfully created, the wizard binds it to the appropriate SQL Server field.</p>
<p>
<b>Triggers</b></p>
<p>
A trigger is a series of Transact-SQL statements associated with a particular SQL Server table. The Upsizing Wizard uses triggers differently depending on whether you are upsizing to SQL Server 4.21 or 6.x and whether you choose to use Declarative Referential Integrity on SQL Server 6.x.</p>
<p>
SQL Server 4.21</p>
<p>
AutoNumber fields, validation rules, and table relations map to SQL Server triggers. The Upsizing Wizard creates triggers when you export validation rules or table relationships, or when your table contains an AutoNumber field.</p>
<p>
SQL Server 6.x</p>
<p>
If you choose to use triggers to implement referential integrity, table relations will map to SQL Server triggers. Validation rules always map to SQL Server triggers.</p>
<p>
Validation rules and table relations do not map directly to triggers. Each rule or relation may become part of several triggers. Each trigger may contain code to emulate the functionality of several validation and referential integrity rules.</p>
<p>
A table can have three triggers, one for each of the commands that can modify data in the table: the UPDATE, INSERT, and DELETE commands. The trigger is automatically executed when the command is carried out.</p>
<p>
The following table describes the triggers created by the Upsizing Wizard. Any specific trigger may contain code to emulate one, all, or none of the Microsoft&nbsp;Access functions listed.</p>
<table>
<tr valign=top>
<td>
<b>Trigger</b></td>
<td>
<b>Microsoft&nbsp;Access Functionality Emulated</b></td>
</tr>
<tr valign=top>
<td>
UPDATE</td>
<td>
Validation rules: Record validation, Field validation, and Required property<p>
Referential integrity</p>
</td>
</tr>
<tr valign=top>
<td>
INSERT</td>
<td>
Validation rules: Record validation, Field validation, and Required property<p>
Referential integrity (Child table triggers only)</p>
<p>
AutoNumber data type (SQL Server 4.21 only)</p>
</td>
</tr>
<tr valign=top>
<td>
DELETE (Parent table triggers only)</td>
<td>
Referential integrity</td>
</tr>
</table><br>
<p>
<b>Declarative referential integrity</b></p>
<p>
Declarative Referential Integrity (DRI) is new functionality introduced in SQL Server 6.0. DRI allows you to declare relationships between tables with the table definition. For example the Dept ID field in the Employees table is a foreign key to the Dept ID field in the Departments table. SQL Server DRI allows you to create these foreign keys as part of the table definition. DRI on SQL Server does not support the cascading updates and deletes that are allowed in Microsoft Access.</p>
<p>
When upsizing to SQL Server 6.x, the Upsizing Wizard gives you the option of using DRI or triggers to enforce referential integrity. If your Microsoft Access database contains cascading updates and deletes, the Upsizing Tools will default to using triggers to maintain the cascades. You have the option of using DRI instead, but your cascades will not be upsized.</p>
<p>
<b>AutoNumber fields</b></p>
<p>
AutoNumber fields in Microsoft&nbsp;Access are long integer fields that are automatically incremented. SQL Server 4.21 doesn’t support the AutoNumber data type, so the Upsizing Wizard includes code in the INSERT triggers that provides equivalent functionality. </p>
<p>
In SQL Server 6.x, AutoNumber fields are upsized to SQL Server Identity columns. Identity columns are functionally equivalent to AutoNumbers.</p>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;On all supported versions of SQL Server, the functionality of random AutoNumber fields that use the Long Integer field size are reproduced by using triggers. The functionality of random AutoNumber fields that use the ReplicationID (GUID) field size cannot be reproduced.</p>
<p>
<b>Example</b></p>
<p>
The Transact-SQL code below was generated as part of upsizing a Tasks table to SQL Server 4.21, and is contained in the trigger called Tasks_ITrigger. This code provides the same functionality as the AutoNumber field “Task ID” in a Microsoft&nbsp;Access table Tasks.</p>
<pre><FONT FACE="Courier New" SIZE="2">DECLARE @maxc int, @newc int
SELECT @maxc = (SELECT Max(Task_ID) FROM Tasks) 
SELECT @newc = (SELECT Task_ID FROM inserted) 
IF @newc = 0 OR @maxc &lt;&gt; @newc SELECT @maxc = @maxc + 1 
UPDATE Tasks SET Task_ID = @maxc WHERE Task_ID = @newc
</font></pre>
<p>
<b>Validation rules</b></p>
<p>
The Upsizing Wizard can export table validation rules and field validation.</p>
<p>
For each table, the Upsizing Wizard:
<ul>
<li>
Converts each validation rule to Transact-SQL, if possible. The upsizing report will indicate whether conversion was successful.<br><br></li>
<li>
Creates a fragment of Transact-SQL code for each Microsoft&nbsp;Access field where the Required property is set to true. This code presents an error message, similar to the one Microsoft&nbsp;Access displays if the field is null when a record is added or updated. <br><br></li>
<li>
Combines all the converted validation rules and Required property code.<br><br></li>
<li>
Places a copy of the combined code into both an UPDATE and an INSERT trigger on the SQL Server table.<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;The Upsizing Wizard uses triggers rather than SQL Server rules to enforce field level validation because SQL Server rules do not allow you to display custom error messages.</p>
</li>
</ul>
<p>
Example</p>
<p>
The following code is contained in both the Tasks_Itrig and Tasks_Utrig triggers, which are associated with the Tasks table.</p>
<p>
This code is the SQL Server equivalent of two Microsoft&nbsp;Access field level validation rules (for the Status and Date Completed fields) and one Microsoft&nbsp;Access table validation rule.</p>
<pre><FONT FACE="Courier New" SIZE="2">...
ELSE 
/*
 * VALIDATION RULE FOR FIELD 'Status'
 */
IF (SELECT Count(*) FROM inserted WHERE NOT (Status In ('Not Started','Started','Done'))) &gt; 0
    BEGIN
        RAISERROR(778218, 16, 1)
        ROLLBACK TRANSACTION
    END
ELSE 
/*
 * VALIDATION RULE FOR FIELD 'Date Completed'
 */
IF (SELECT Count(*) FROM inserted WHERE NOT (Date_Completed Is Null Or Date_Completed&gt;'1/1/94')) &gt; 0
    BEGIN
        RAISERROR(778219, 16, 1)
        ROLLBACK TRANSACTION
    END
ELSE 
/*
 * VALIDATION RULE FOR TABLE
 */
IF (SELECT Count(*) FROM inserted WHERE NOT (Status='Done' Or Date_Completed Is Null)) &gt; 0
    BEGIN
        RAISERROR(778220, 16, 1)
        ROLLBACK TRANSACTION
    END
...
</font></pre>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;The numbers in the RAISERROR statements (778218-778220) map to unique error messages in the sysmessages table of the master database.</p>
<p>
<b>Required property</b></p>
<p>
When the Required property of a Microsoft&nbsp;Access field is set to true, a user cannot insert a record and leave the required field null (if there is no default bound to the field), or make the field null when updating a record. </p>
<p>
Example</p>
<p>
The following code is generated because the Required property of the Emp ID field in the Tasks table is set to true. The code is contained in both the Tasks_Utrig and Tasks_Itrig triggers of the Tasks table.</p>
<pre><FONT FACE="Courier New" SIZE="2">IF (SELECT Count(*) FROM inserted WHERE Emp_ID IS NULL) &gt; 0
    BEGIN
        RAISERROR 44444 'Field ''Emp_ID'' cannot contain a null value.'
        ROLLBACK TRANSACTION
    END
ELSE
</font></pre>
<p>
<b>Table relationships</b></p>
<p>
Table relationships are handled differently on SQL Server 4.21 and SQL Server 6.x.</p>
<p>
<b>Important</b>&nbsp;&nbsp;&nbsp;If only one of the tables in a relationship is upsized, or if referential integrity is not enforced in Microsoft&nbsp;Access, the relationship is not exported.</p>
<p>
SQL Server 4.21</p>
<p>
The Upsizing Wizard creates triggers that include the Transact-SQL code required to duplicate Microsoft&nbsp;Access table relationships. Microsoft&nbsp;Access supports declarative referential integrity that is enforced at the engine level. In SQL Server 4.21, referential integrity is enforced by Transact-SQL code in triggers. A Microsoft&nbsp;Access relationship becomes four SQL Server triggers: two for the parent table and two for the child table.</p>
<p>
<b>Parent Table</b></p>
<p>
The Upsizing Wizard will create an UPDATE trigger that will either prevent changing the parent table’s primary key or cascade that change through the child table, depending on the type of relationship that was created in Microsoft&nbsp;Access.</p>
<p>
The wizard will also create a DELETE trigger that prevents deleting a record with related child records, or that deletes the child records, again depending on the type of the original relationship between the tables in Microsoft&nbsp;Access.</p>
<p>
<b>Examples</b></p>
<p>
The following Transact-SQL code is contained in the Departments_Dtrig trigger of the Departments table. It prevents deleting a parent record that would orphan related records in the Employees table.</p>
<pre><FONT FACE="Courier New" SIZE="2">IF (SELECT COUNT(*) FROM deleted, Employees WHERE 
(deleted.Dept_ID = Employees.Dept_ID)) &gt; 0
    BEGIN
        RAISERROR(778221, 16, 1)
        ROLLBACK TRANSACTION
    END
</font></pre>
<p>
The second example illustrates how changes to the primary key (the Email field) are cascaded to the child table’s foreign key. The code is contained in the Employees_Utrig trigger of the Employees table. </p>
<pre><FONT FACE="Courier New" SIZE="2">IF UPDATE(Email)
    BEGIN
       UPDATE Tasks
       SET Tasks.Emp_ID = inserted.Email
       FROM Tasks, deleted, inserted
       WHERE deleted.Email = Tasks.Emp_ID
    END
</font></pre>
<p>
<b>Child Table</b></p>
<p>
For the child table, the Upsizing Wizard creates an UPDATE trigger that prevents changes to the foreign key that would orphan the record. Likewise, an INSERT trigger is created to prevent a new record from being added that has no parent.</p>
<p>
<b>Example</b></p>
<p>
This code prevents adding a record to the Tasks table if no parent record exists in the Employees table, and is contained in the Tasks_Itrig trigger.</p>
<pre><FONT FACE="Courier New" SIZE="2">IF (SELECT COUNT(*) FROM inserted) !=
   (SELECT COUNT(*) FROM Employees, inserted WHERE 
      (Employees.Email = inserted.Emp_ID))
    BEGIN
        RAISERROR(778296, 16, 1)
        ROLLBACK TRANSACTION
    END
</font></pre>
<p>
Similar code is found in the Tasks_Utrig trigger to prevent orphaning records through changing the foreign key.</p>
<p>
<b>Custom Error Values</b></p>
<p>
When the referential integrity established by the wizard-created triggers is violated, the Upsizing Wizard places a custom error value into the @@ERROR variable. The value depends on the validation rule that was violated. A custom error message for each value is stored in the sysmessages table in the master database. To add user-defined error messages, use sp_addmessage system stored procedure. To delete user-defined error messages, use sp_dropmessage system stored procedure</p>
<p>
SQL Server 6.x</p>
<p>
You have the choice of using triggers or DRI. If you use DRI, you get engine level enforcement of you referential integrity via Foreign Keys, but lose the cascading updates and deletes supplied by the triggers.</p>
<h2>Next Steps </h2>
<p>
At this point in the process you have the basics completed for your application but you still have work to do to create a full-fledged client-server application. You need take a number of additional steps, in both your SQL Server and Microsoft&nbsp;Access databases, to ensure that your application and data are secure and functioning properly.</p>
<h3>Server Steps</h3>
<p>
On your SQL Server-based server, you should:
<ul>
<li>
Make sure that tables you want to edit from Microsoft&nbsp;Access can be updated.<br><br></li>
<li>
Set permissions on the database so that users are able to access the objects they need.<br><br></li>
<li>
Optionally, prevent unauthorized users from gaining access to server data by preventing the storing of passwords with linked tables.<br><br></li>
<li>
Protect your work by making your new database recoverable in case it is damaged or lost.</li>
</ul>
<p>
<b>Adding unique indexes for updatability</b></p>
<p>
A linked table must have a unique index to be updatable in Microsoft&nbsp;Access. The Upsizing Wizard can export an existing unique index, but will not create one where none exists. Make sure that tables you want to edit from Microsoft&nbsp;Access are updatable.</p>
<p>
You can use the SQL Server Browser to add unique indexes to tables.</p>
<p>
<b>Setting permissions</b></p>
<p>
The Upsizing Wizard does not export users, groups, or permissions that you have set in your Microsoft&nbsp;Access database. The new SQL Server database and its objects receive a set of default permissions from the SQL Server. Set permissions on the database so that your users are able to access the objects they need.</p>
<p>
<b>Database logon permissions</b></p>
<p>
The default permissions of a new database make it accessible only to system administrators and the database owner.</p>
<p>
You can add new users and groups using the SQL Server Security Manager or the system procedures <b>sp_adduser</b> and <b>sp_addgroup</b>. (For more information on adding users and groups, see the SQL Server Security Manager Help file and the documentation of the system procedures <b>sp_adduser</b> and <b>sp_addgroup</b> in the SQL Server Transact-SQL Reference.)</p>
<p>
<b>Object permissions</b></p>
<p>
All objects created by the Upsizing Wizard, including tables, triggers, and defaults, are accessible initially only to the database owner and system administrators. This is true whether you upsized to a new or existing database. If you overwrite existing objects, you also overwrite all object permissions.</p>
<p>
To grant permissions on tables, use the SQL Object Manager or the GRANT and REVOKE commands. (For more information on setting object permissions, see the section “Managing Object Permissions” in Part 3 of the SQL Object Manager User’s Guide, or the GRANT and REVOKE commands in the SQL Server Transact-SQL Reference.)</p>
<p>
<b>Synchronizing local and remote permissions</b></p>
<p>
Although Microsoft&nbsp;Access isn’t aware of SQL Server security, it can’t violate it. For example, if you’re editing a remote table for which you don’t have INSERT permission, Microsoft&nbsp;Access lets you type a new record; however, when you try to save it, the server returns an error message, and prevents you from inserting the record. </p>
<p>
You can minimize these discrepancies by synchronizing local and remote user permissions and passwords. Then you need log on only once, as Microsoft&nbsp;Access automatically attempts to log in to the server using your local user permission and password and prompts you only if this login fails.</p>
<p>
<b>Saving passwords locally</b></p>
<p>
When a remote table is linked in Microsoft&nbsp;Access, the user can save his or her server password locally with the table, and will no longer need to log on when opening the table. This also makes it possible for unauthorized users to gain access to server data. You can prevent this by creating a table named MsysConf on SQL Server.</p>
<p>
When a user logs on to a SQL Server database, Microsoft&nbsp;Access looks for the MSysConf table. If it exists, its values control whether users can save their passwords with linked tables, and also control the rate of background population of records. If no MSysConf table exists, default values are used, and users are allowed to store passwords locally.</p>
<p>
<b>To prevent users from storing passwords locally</b>
<ol>
<li>
Create the MSysConf table. For information on creating the MSysConf table, search Upsizing Tools Help for  “MSysConf table: creating.”<br><br></li>
<li>
Add a new record.<br><br></li>
<li>
Set the Config column value to 101.<br><br></li>
<li>
Set the value to zero.</li>
</ol>
<p>
These settings disable the “Save login ID and password locally” check box when you link to a server table. To enable the check box, set the value to 1.</p>
<p>
Changes made to the MSysConf table will not take effect until the connection is re-established.</p>
<p>
The options set in an MSysConf table apply to all Microsoft&nbsp;Access applications linked to the table’s database.</p>
<p>
<b>Ensuring recoverability</b></p>
<p>
Protect your work by making your new database recoverable in case it is damaged or lost.</p>
<p>
<b>Dumping the master database</b></p>
<p>
When a database is created on a SQL Server–based server, new records are added to the system tables in the Master database. Dumping the Master database provides you with a backup copy including all the latest changes.</p>
<p>
<b>Scheduling backups</b></p>
<p>
Schedule regular backups of your database so that you can restore your database from this backup copy in the event of a serious problem.</p>
<p>
<b>Device mirroring</b></p>
<p>
Mirroring a device continuously duplicates the information from one SQL Server device to another. In the event that one device fails, the other contains an up-to-date copy of all transactions.</p>
<p>
If you anticipate that many changes will be made to a database between backups and you can’t afford to lose those changes, consider device mirroring. Device mirroring is most effective when the devices are located on separate disks, as both devices may be lost if they are on the same disk and the disk fails.</p>
<h3>Client Steps</h3>
<p>
Once you have transferred objects from Microsoft&nbsp;Access to SQL Server, you may need to modify code in the original Microsoft&nbsp;Access database so that it functions properly with the new SQL Server database.</p>
<h3>Unsupported Objects and Methods</h3>
<p>
You may need to change code that uses objects and methods that are not supported in remote tables. In many cases, such as the CompactDatabase method or the Container object, there is simply no equivalent on a SQL Server.</p>
<p>
The following data access objects are not supported:
<ul>
<li>
Container<br><br></li>
<li>
Document<br><br></li>
<li>
Index<br><br></li>
<li>
QueryDef<br><br></li>
<li>
Relation</li>
</ul>
<p>
The following methods are not supported:
<ul>
<li>
CompactDatabase<br><br></li>
<li>
CreateDatabase<br><br></li>
<li>
CreateField<br><br></li>
<li>
CreateQueryDef<br><br></li>
<li>
DeleteQueryDef<br><br></li>
<li>
ListParameters<br><br></li>
<li>
ListTables<br><br></li>
<li>
OpenQueryDef<br><br></li>
<li>
RepairDatabase<br><br></li>
<li>
Seek<br><br></li>
<li>
SetDefaultWorkspace</li>
</ul>
<p>
<b>Nested transactions</b></p>
<p>
Microsoft&nbsp;Access supports transactions nested up to five levels. SQL Server supports only one transaction at a time. If your Microsoft&nbsp;Access code includes nested transactions, only the outermost transaction is sent to the server; the other transactions are ignored, and no error is produced.</p>
<p>
<b>Example</b></p>
<pre><FONT FACE="Courier New" SIZE="2">BeginTrans
'Outermost transaction sent to the server
'edits, updates

 BeginTrans
 'Nested transaction is <b>not </b>sent to the server
 'edits, updates

 CommittTrans

CommittTrans
</font></pre>
<p>
You may need to modify your code in light of this difference. If your nested transactions are rolled back when any of them fail, the single-transaction limitation won’t pose major difficulties. If some nested transactions are committed even if others fail, duplicating this functionality with one transaction may prove to be difficult.</p>
<p>
<b>Default and AutoNumber values</b></p>
<p>
Microsoft&nbsp;Access default and AutoNumber field values appear when you begin editing a new record. Default values generated by SQL Server defaults and AutoNumber values generated by table triggers appear only after a record has been inserted. You will need to change any code, such as code for lookups, that depends on having the values before the record is committed.</p>
<p>
<b>Validation rules</b></p>
<p>
In Microsoft&nbsp;Access, field validation occurs when the user tabs out of a field. When you edit SQL Server data in linked tables, triggers and rules are not fired until you leave the record. Record validation rules that rely on field validation occurring when a field is exited may need to be modified.</p>
<p>
<b>Unconverted expressions</b></p>
<p>
The upsizing report shows whether each Microsoft&nbsp;Access table validation rule, field validation rule, and default was successfully converted. If the Upsizing Wizard was not successful in translating a Microsoft&nbsp;Access expression, you will need to rewrite it using Transact-SQL.</p>
<p>
For example, if a field validation rule could not be converted, you should rewrite the validation rule in Transact-SQL and then add it to the update and insert trigger for the table. You could also create a rule.</p>
<p>
Another option is to perform validation at the form level in Microsoft&nbsp;Access. However, if server data is then modified without using a particular form, the validation will not be applied and invalid data may be entered.</p>
<p>
<b>Record locking</b></p>
<p>
You cannot open a Dynaset object against a linked server table in exclusive mode. Consequently, the value of the Record Locks property of all forms must be set to No Locks or Edited Record. (Edited Record is treated the same as No Locks.) The value All Records is illegal and generates an error. </p>
<p>
With server tables, Microsoft&nbsp;Access uses optimistic locking internally. The row is locked only while the update process occurs, when the edited value is committed, which is usually a very brief interval.</p>
<p>
<b>Back-end databases</b></p>
<p>
Many developers take a &quot;back end, front end&quot; approach to developing Microsoft Access applications. They keep tables in one database (the back end) and all other objects such as forms and reports in another database (the front end).</p>
<p>
To upsize a back-end/front-end application
<ul>
<li>
Upsize the back-end database using the Upsizing Wizard.<br><br></li>
<li>
Delete the renamed local tables (table names ending with &quot;_local&quot;) from the back-end database.<br><br></li>
<li>
Open the front-end database in Microsoft Access, and then delete the links to the tables in the original back-end database.<br><br></li>
<li>
On the File menu, point to Get External Data, and then click Link Tables.<br><br></li>
<li>
In the Files Of Type box, click ODBC Databases, and then select the Data Source that specifies the SQL Server database to which you upsized the back-end tables, and log on.<br><br></li>
<li>
In the Link Tables dialog box, select all of the upsized back-end tables.<br><br></li>
<li>
If in the future you don't want to require users to log on to open the tables, select the Save Password check box, and then click OK.<br><br></li>
<li>
On the File menu, point to Get External Data, and then click Import.<br><br></li>
<li>
In the Import dialog box, select the original Microsoft Access back-end database.<br><br></li>
<li>
In the Import Objects dialog box, click the Queries tab, and select any aliasing queries created when upsizing (they will have the same names as the original names of upsized tables), and then click OK.</li>
</ul>
<h3>Setting User-Defined Constants</h3>
<p>
The Upsizing Wizard has several default settings that you can change by modifying the constants in the UT_modUserConstants module in the Upsizing Wizard add-in database (Wzcs97.mda) before you run the Upsizing Wizard. In most cases, you should use default behavior, but there may be situations where you want change one or more of these settings.</p>
<p>
<b>Important</b>&nbsp;&nbsp;&nbsp;Microsoft Technical Support does not support use of the Upsizing Wizard with settings other than the default values.</p>
<p>
To modify the values in the UT_modUserConstants module
<ul>
<li>
Close Microsoft Access.<br><br></li>
<li>
If you are using Windows 95 or Windows NT Workstation version 4.0, in My Computer or Windows Explorer, open the folder where Microsoft Access is installed, and then double-click Wzcs97.mda. <br><br></li>
<li>
If you are using Windows NT Workstation version 3.51, in File Manager, open the directory where Microsoft Access is installed, and then double-click Wzcs97.mda.<br><br></li>
<li>
In the Database window, click the Modules tab, and then double-click UT_modUserConstants.<br><br></li>
<li>
Modify any of the user-defined constants.<br><br></li>
<li>
Close the database. The new values will be used the next time you upsize a database.</li>
</ul>
<p>
The following table describes each of the user-defined constants.</p>
<table>
<tr valign=top>
<td>
<b>Constant</b></td>
<td>
<b>Description</b></td>
</tr>
<tr valign=top>
<td>
UT_CAREFUL</td>
<td>
If this constant is set to False, the Upsizing Wizard uses Microsoft Access field or table names containing SQL Server reserved words as the upsized table and field names. If set to True, the wizard converts those names to allow for compliance. The default value is False.</td>
</tr>
<tr valign=top>
<td>
UT_USE_CHAR</td>
<td>
If this constant is set to False, when upsizing Microsoft Access Text fields, the wizard creates fields with the VARCHAR data type. If set to True, the wizard creates CHAR fields. The default value is False.</td>
</tr>
<tr valign=top>
<td>
UT_CLUSTERED</td>
<td>
If this constant is set to False, and you're using SQL Server version 6.0 or later, the wizard doesn't create a clustered primary key for your upsized table. If you're using SQL Server version 4.21, the index on the primary key is not created as a clustered index. If set to True, the wizard creates tables with a clustered primary key (version 6.x) or a clustered index on the primary key (version 4.21). The default value is False. Before you change this constant, see Chapter 5, &quot;Clustered Indexes&quot; in the SQL Server Database Developer's Companion for information on the implications of using clustered indexes on a monotonically increasing column such as an Identity column.</td>
</tr>
<tr valign=top>
<td>
UT_QUIET</td>
<td>
If this constant is set to False, the wizard halts on all errors after you click the Finish button. If set to True, the wizard prevents the display of most error messages. Most errors will be logged in the final report, but some may not be. If you need to upsize a database that will take a long time and don't want the wizard to halt for errors, set this constant to True. The default value is False.</td>
</tr>
<tr valign=top>
<td>
UT_EXPORT_<p>
GUID</p>
</td>
<td>
If this constant is set to True, the wizard exports tables with AutoNumber fields with that have their FieldSize property set to ReplicationID (GUID). The field's data is exported, but their AutoNumber behavior is lost, because there is no equivalent behavior in SQL Server tables. If set to False, the wizard doesn't export such tables. The default value is True.</td>
</tr>
<tr valign=top>
<td>
UT_USE_NULL_<p>
CONSTRAINTS</p>
</td>
<td>
When creating tables on SQL Server version 6.x, if this constant is set to True, the wizard sets NULL or NOT NULL on each column to duplicate the functionality of the Primary, Unique, and Required properties in Microsoft Access tables. If set to False, the wizard creates triggers to control when null values can be entered. The benefit of using triggers is that you can change the nullability of columns without dropping the entire table.When creating tables on SQL Server version 4.21a, this setting is ignored; the wizard always creates triggers. The default value is False.</td>
</tr>
<tr valign=top>
<td>
UT_CHECK_<p>
FOR_FULL_LOG</p>
</td>
<td>
If this constant is set to True, the wizard checks to see if the database’s transaction log is full whenever an ODBC Call Failed error occurs. If the log is full and the database is new, the wizard dumps (deletes) the log automatically. If the database is not new, the wizard prompts the user whether or not to dump the log. You may want to set this constant to False to speed up the process of upsizing. If you do this, make sure enough log space is free before upsizing a database. The default value is True.</td>
</tr>
<tr valign=top>
<td>
UT_DELETE_<p>
SERVER_XLAT</p>
</td>
<td>
When upsizing a database, the wizard creates a character translation table on your server which takes some time to generate. If this constant is set to True, the wizard deletes the character translation table when it is finished upsizing a database. If set to False, the wizard doesn’t delete the table, which will save time if you upsize several tables to the same server. The default value is True.</td>
</tr>
</table><br>
<h2>SQL Server Browser</h2>
<p>
As we discussed earlier in this document, the Upsizing Tools consists of an additional tool&#45;the SQL Server Browser. It is essentially a client-server database container integrated into your Microsoft&nbsp;Access development environment. It allows you to view, edit, and modify SQL Server objects including: Tables; Views; Rules; Defaults; and Stored Procedures. This allows the developer to leverage their understanding of the Microsoft&nbsp;Access developer toolset when developing against the back-end database. </p>
<p>
The SQL Server Browser can perform many of the same functions as the SQL Enterprise Manager, which is provided with Microsoft SQL Server 6.x. This section outlines the important differences between the SQL Server Browser and the SQL Enterprise Manager, to help you choose the tool that best suits the task.</p>
<p>
<b>User interface</b></p>
<p>
Microsoft Access users will find the SQL Server Browser interface familiar and easy to use. The SQL Enterprise Manager is powerful and easy to use, but doesn't resemble the Microsoft Access interface.</p>
<p>
The SQL Server Browser allows you to view, edit, create and delete objects, in windows similar to the Microsoft Access Database window, and Table window in Design view.</p>
<p>
However, in the SQL Server Browser, you must use ad hoc SQL for the following tasks:
<ul>
<li>
Device and database management<br><br></li>
<li>
Segment management<br><br></li>
<li>
Backup and recovery<br><br></li>
<li>
Security<br><br></li>
<li>
User and group administration<br><br></li>
<li>
Server configuration<br><br></li>
<li>
Defining CHECK, FOREIGN KEY, PRIMARY KEY, or UNIQUE constraints, or the IDENTITY property</li>
</ul>
<p>
From within the Browser, you must run stored procedures to:
<ul>
<li>
Drop (delete) databases or increase their size<br><br></li>
<li>
Bind or unbind rules and defaults outside the table Design tool<br><br></li>
<li>
View object dependencies</li>
</ul>
<p>
<b>Modifying a SQL Server table</b></p>
<p>
You cannot delete any fields in the Table window because SQL Server doesn't allow you to drop columns from existing tables.</p>
<p>
<b>Caution</b>&nbsp;&nbsp;&nbsp;Each modification to an existing table is made immediately, rather than when you close the Table window.</p>
<p>
To modify a table:
<ul>
<li>
In the SQL Server Browser window, click Table.<br><br></li>
<li>
Select a table.<br><br></li>
<li>
Click Design.</li>
</ul>
<p>
The SQL Server Browser downloads the table definition from the server and displays it in a Table window similar to the Microsoft Access Table window in Design view.</p>
<dl>
<dt>
Make the changes you want to the field names, defaults, triggers, and indexes.</dt>
<dd>
<b>Note</b>&nbsp;&nbsp;&nbsp;Data type, field length, the Required property setting, and validation rules cannot be modified in existing tables.</dd>
</dl>
<p>
<b>Expression translation</b></p>
<p>
When adding defaults to SQL Server via the SQL Server Browser, you can use the most common Microsoft Access expression and the SQL Server Browser will convert this expression to a SQL Server expression. The following expressions are converted:</p>
<table>
<tr valign=top>
<td>
<b>Microsoft Access functions</b></td>
<td>
<b>SQL Server functions</b></td>
</tr>
<tr valign=top>
<td>
String functions</td>
<td>
</td>
</tr>
<tr valign=top>
<td>
chr$(x)</td>
<td>
char(x)</td>
</tr>
<tr valign=top>
<td>
asc(x)</td>
<td>
ascii(x)</td>
</tr>
<tr valign=top>
<td>
str$(x)</td>
<td>
str(x)</td>
</tr>
<tr valign=top>
<td>
space$( x)</td>
<td>
space(x)</td>
</tr>
<tr valign=top>
<td>
lcase$(x)</td>
<td>
lower(x)</td>
</tr>
<tr valign=top>
<td>
ucase$( x)</td>
<td>
upper(x)</td>
</tr>
<tr valign=top>
<td>
len(x)</td>
<td>
datalength(x)</td>
</tr>
<tr valign=top>
<td>
ltrim$( x)</td>
<td>
ltrim(x)</td>
</tr>
<tr valign=top>
<td>
rtrim$(x)</td>
<td>
rtrim(x)</td>
</tr>
<tr valign=top>
<td>
right$(x,y)</td>
<td>
right(x,y)</td>
</tr>
<tr valign=top>
<td>
mid$(x,y,z)</td>
<td>
substring(x,y,z)</td>
</tr>
<tr valign=top>
<td>
<b>Conversion functions</b></td>
<td>
</td>
</tr>
<tr valign=top>
<td>
cint(x)</td>
<td>
convert(smallint,x)</td>
</tr>
<tr valign=top>
<td>
clng(x)</td>
<td>
convert(int,x)</td>
</tr>
<tr valign=top>
<td>
csng(x)</td>
<td>
convert(real,x)</td>
</tr>
<tr valign=top>
<td>
cdbl(x)</td>
<td>
convert(float,x)</td>
</tr>
<tr valign=top>
<td>
cstr(x)</td>
<td>
convert(varchar,x)</td>
</tr>
<tr valign=top>
<td>
ccur(x)</td>
<td>
convert(money,x)</td>
</tr>
<tr valign=top>
<td>
cvdate(x)</td>
<td>
convert(datetime,x)</td>
</tr>
<tr valign=top>
<td>
<b>Date functions</b></td>
<td>
</td>
</tr>
<tr valign=top>
<td>
now(x)</td>
<td>
getdate(x)</td>
</tr>
<tr valign=top>
<td>
date(x )</td>
<td>
convert(datetime,convert(varchar,<p>
getdate(x)))</p>
</td>
</tr>
<tr valign=top>
<td>
year(x)</td>
<td>
datepart(yy,x)</td>
</tr>
<tr valign=top>
<td>
month(x)</td>
<td>
datepart(mm,x)</td>
</tr>
<tr valign=top>
<td>
day(x)</td>
<td>
datepart(dd,x)</td>
</tr>
<tr valign=top>
<td>
weekday(x)</td>
<td>
datepart(dw,x)</td>
</tr>
<tr valign=top>
<td>
hour(x)</td>
<td>
datepart(hh,x)</td>
</tr>
<tr valign=top>
<td>
minute(x)</td>
<td>
datepart(mi,x)</td>
</tr>
<tr valign=top>
<td>
second(x)</td>
<td>
datepart(ss,x)</td>
</tr>
<tr valign=top>
<td>
datepart(&quot;&lt;Access datepart&gt;&quot;<p>
, x)</p>
</td>
<td>
datepart(&lt;SQL Server datepart&gt;, x)</td>
</tr>
<tr valign=top>
<td>
dateadd(&quot;&lt;Access datepart&gt;&quot;<p>
, x, y)</p>
</td>
<td>
dateadd(&lt;SQL Server datepart&gt;, x, y)</td>
</tr>
<tr valign=top>
<td>
datediff(&quot;&lt;Access datepart&gt;&quot;<p>
, x, y)</p>
</td>
<td>
datediff(&lt;SQL Server datepart&gt;, x, y)</td>
</tr>
<tr valign=top>
<td>
<b>Math functions</b></td>
<td>
</td>
</tr>
<tr valign=top>
<td>
int(x)</td>
<td>
floor(x)</td>
</tr>
<tr valign=top>
<td>
sgn(x)</td>
<td>
sign(x)</td>
</tr>
</table><br>
<p>
As part of translating expressions, the Upsizing Wizard and SQL Server Browser replace a number of delimiters, operators, constants and wildcard characters, as listed in the following table.</p>
<table>
<tr valign=top>
<td>
<b>Description</b></td>
<td>
<b>Microsoft Access</b></td>
<td>
<b>SQL Server</b></td>
</tr>
<tr valign=top>
<td>
Date delimiter</td>
<td>
#</td>
<td>
'</td>
</tr>
<tr valign=top>
<td>
String delimiter</td>
<td>
&quot;</td>
<td>
'</td>
</tr>
<tr valign=top>
<td>
Mod operator</td>
<td>
mod</td>
<td>
%</td>
</tr>
<tr valign=top>
<td>
Concatenation operator</td>
<td>
&amp;</td>
<td>
+</td>
</tr>
<tr valign=top>
<td>
Wildcard character</td>
<td>
?</td>
<td>
_</td>
</tr>
<tr valign=top>
<td>
Wildcard character</td>
<td>
*</td>
<td>
%</td>
</tr>
<tr valign=top>
<td>
Constant</td>
<td>
Yes</td>
<td>
1</td>
</tr>
<tr valign=top>
<td>
Constant</td>
<td>
On</td>
<td>
1</td>
</tr>
<tr valign=top>
<td>
Constant</td>
<td>
True</td>
<td>
1</td>
</tr>
<tr valign=top>
<td>
Constant</td>
<td>
No</td>
<td>
0</td>
</tr>
<tr valign=top>
<td>
Constant</td>
<td>
Off</td>
<td>
0</td>
</tr>
<tr valign=top>
<td>
Constant</td>
<td>
False</td>
<td>
0</td>
</tr>
</table><br>
<p>
&copy; 1997 Microsoft Corporation. All rights reserved.</p>
<p>
The information contained in this document represents the current view of Microsoft Corporation on the issues discussed as of the date of publication. Because Microsoft must respond to changing market conditions, it should not be interpreted to be a commitment on the part of Microsoft, and Microsoft cannot guarantee the accuracy of any information presented after the date of publication.</p>
<p>
This document is for informational purposes only. MICROSOFT MAKES NO WARRANTIES, EXPRESS OR IMPLIED, IN THIS SUMMARY.</p>
<p>
Microsoft, Windows, and Windows NT are registered trademarks and SQL Server is a trademark of Microsoft Corporation.</p>
<p>
Other product or company names mentioned herein may be the trademarks of their respective owners.</p>
</font></BODY>
</HTML>
