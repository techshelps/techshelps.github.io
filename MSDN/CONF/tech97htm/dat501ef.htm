<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Developing Business Objects with Visual FoxPro </title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>



	<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>



	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<h1>Developing Business Objects with Visual FoxPro </h1>
<p>
Presented by: Yair Alan Griver</p>
<p>
Yair Alan Griver is Chief Information Officer at Flash Creative Management, a database development and management consulting firm based in Hackensack, NJ. Flash, a Microsoft Solution Provider Partner and Authorized Technical Education Center, is a three time Inc. 500 company, that specializes in client/server database development, designs and installs custom software solutions and offers training classes in Microsoft&reg; Visual FoxPro&reg;, Microsoft&reg; SQL Server™ and Microsoft&reg; Visual Basic&reg;. </p>
<p>
A Contributing Editor to Data Based Advisor and FoxPro Advisor magazines, Alan has written articles and been quoted in many industry journals. He has spoken at the Fox Developers Conference, Borland Database Conference, DB/Expo, Business Software Solutions, Windows &amp; OS/2 Conference and Database World in addition to providing training around the world</p>
<p>
Alan is author of The Visual FoxPro 3.0 Codebook, published by Sybex. This book discusses a methodology for developing robust applications, and provides an object oriented framework for these applications.</p>
<p>
Phone: (201) 489-2500<BR>Email via CompuServe: 71541,3150</p>
<h2>Introduction</h2>
<p>
Ubiquitous and fast connectivity is just around the corner. As a result, database systems are shifting from single-server, two-tier, local area network (LAN)-based, departmental systems to a new form of client/server where every machine on the Internet can be both a client and a server. As a response to this, many of today’s developers are implementing three-tier type applications using OLE services. These are generally comprised of user interface (UI), business and data services, each of which is applied along logical boundaries. A critical component of this three-tier architecture is the business services that consists of reusable business objects which define the corporations processes and rules. This session focuses on this aspect of three-tier development, including various approaches to developing and deploying business objects in Visual FoxPro.</p>
<h2>Why Three-Tier?</h2>
<p>
In a word, scalability. A multi-tiered logical model allows you to scale your application as needed, going from single machine to multiple machines communicating over the internet.  Let’s look at how this works:</p>
<h3>Two-Tier Systems</h3>
<p>
In a two-tier system, you place the interface on one machine, the data on another, and then decide where to place the business rules: on the front end or the back end. Fat client systems, in which you place the rules on the front end, use field level validation functions. Fat server systems use the back end’s stored procedures and triggers in order to validate the data as it is being saved. </p>
<p>
There are problems with both approaches. A fat client requires a very robust machine, and makes updating the software difficult, since every business change requires shipping new software to each client machine. A fat server, on the other hand, has to be upgraded regularly as new users come on line, stressing the limits of the hardware. </p>
<h3>Three-Tier Systems</h3>
<p>
A logically three-tiered design is one in which an application’s implementation is divided into three logical areas&#45;user, business and data.  This segmentation allows developers to introduce flexible layers between databases and the applications that use them.  Each tier is responsible for a different task, and when put together, they form a cooperating system that is flexible and robust.</p>
<p>
Items in the data layer are primarily responsible for the locating and storing of data.  Typical examples of these items would be a relational database, any stored procedures contained in it, and anything that deals primarily with data access, like a customer searching component.  The data layer worries about things like data persistence, recovery, and consistency, and is not involved in implementing any business-specific rules.</p>
<p>
Object ins the business layer, on the other hand, are responsible for implementing business-specific rules.  They interact with data services to retrieve and store data, but they add the functionality of applying business rules.  Typical examples of business objects include components that do tax calculation, validation of customer information, and automation of a business process (when a customer is saved, e-mail a certain manager).  Business services are non-visual, and are updated as frequently as a business changes.  </p>
<p>
The UI layer includes objects that are the visual part of an information system.  These objects are responsible for displaying data to the user, allowing the user to manipulate that data, and communicating with business services to validate data that is dependent on business rules.  Examples of objects in this layer are the controls and forms used by an application as well as any calls to the Windows MESSAGEBOX function. </p>
<p>
A three-tier system is more scalable, robust and flexible. Once you have your logical separation, you can place each layer on one machine or multiple machines, as your company grows. In a physically partitioned system, the client machine contains a thin graphical user interface (GUI) layer, which can run on lower end machines (for instance, using a Web Browser), the database resides on its server, worrying only about serving data and handling backups, and the business logic resides on either of these machines, <b>or on their own server</b>. The front end and the database talk only with the business layer, which mediates between the two. In this way, you can integrate data from multiple sources, change business rules as needed, and use the Web, without having to change hardware at the client.</p>
<p>
In fact, with a three-tier model, we no longer create applications, we <b>model our business</b>, with front ends that provide entry points into our business. This is how we end the application backlog&#45;we stop writing applications.</p>
<h2>How Do We Analyze Our Business?</h2>
<p>
In focusing on the business layer of our three tiers, we need to look at what this layer contains. In simple terms: <b>the business layer contains an object model of our business</b>. In other words, if we have an invoicing process, that process should be available as objects and methods in our business layer. It should match what we do. If an aspect of our business changes, it should be easily traced to the code that matches that aspect, allowing us to quickly implement that change across all of our systems.</p>
<p>
Let’s look at an approach to modeling our business processes, finding the classes and ensuring traceability from the initial model to the code. We’ll use Use Cases to begin our analysis and move to CRC cards to design our classes.</p>
<h3>Use Case Design - A User Centered Analysis Tool</h3>
<p>
During discussions with the client, we build “use cases.” These are drawings and text that allow us to formally define what is to occur. A use case is composed of an “actor” (the person or thing that causes the chain of events to occur) and a “use case” (the process that occurs). In fact, a use case is very similar to a cause and effect diagram or a process chart. Something happens, which causes some process to occur that has an output.</p>
<p>
We draw the use case and under it place a description of the output. I recommend placing the usual output first as the primary use case. Secondary occurrences can go underneath it. In this way, you can optimize the User Interface of your dialogs to work most cleanly with the primary occurrence.</p>
<p>
In our case, we have one use case:</p>
<p>
<img src="dat501ef_1.gif" border=0></p>
<p>
<b>Primary case</b>
<ol>
<li>
A user selects a type of import: customer, employee or timesheet<br><br></li>
<li>
A user selects a spreadsheet file<br><br></li>
<li>
The XLS file is imported</li>
</ol>
<p>
In showing this to the user, we can ask them questions like:
<ul>
<li>
What if the file import fails due to bad data?<br><br></li>
<li>
Is it always a spreadsheet file?<br><br></li>
<li>
Are there only these types of imports, or may there be more?</li>
</ul>
<p>
We discover that if any data is bad, we want to print the bad data and cancel the entire import. We also learn that the import may be from other file types due to the upcoming merger possibilities. Finally, the users mention that they’d love to be able to add expense information in the future. Our use case description now looks like this:</p>
<p>
<b>Primary case</b>
<ol>
<li>
A user selects a type of import: customer, employee or timesheet for now, future additions are possible.<br><br></li>
<li>
A user selects a file to be imported. This file will usually be a spreadsheet.<br><br></li>
<li>
The selected file is imported</li>
</ol>
<p>
<b>Secondary cases</b></p>
<p>
If the data is incorrect, cancel the import and print an “incorrect data report.”</p>
<h3>Designing the User Interface</h3>
<p>
The use case allows us to focus in on the interface requirements of the system. In our case, our design may look like this:</p>
<p>
<img src="dat501ef_2.gif" border=0></p>
<p>
Notice that the design falls immediately out of the use case&#45;we can optimize for the usual occurrences. In an order entry system, for instance, the use case description may be:</p>
<p>
<b>Primary case</b>
<ol>
<li>
The customer provides their customer # or name<br><br></li>
<li>
The customer address is verified<br><br></li>
<li>
The customer states the items that they wish to purchase<br><br></li>
<li>
The item list and order total is verified<br><br></li>
<li>
The customer provides a payment method (credit card or PO#)<br><br></li>
<li>
They payment method is verified</li>
</ol>
<p>
<b>Secondary cases</b>
<ol>
<li>
If the customer is new (the number and name aren’t found):<p>
Add the customer name and address</p>
</li>
<li>
If the customer has moved:<p>
Modify the customer address</p>
</li>
<li>
If the payment is rejected:<p>
Select another payment type</p>
</li>
</ol>
<p>
Note how this can be used to streamline UI design. It doesn’t matter if we’re talking about a paper system, computer front end, a web page, or an automated phone ordering system. The steps are standardized for all methods of entry. In designing a computer front end, we would focus on the primary case, using the secondary cases as alternates. </p>
<p>
I’ve seen systems of this sort that make the customer address “live” in order entry. This is wonderful for the case where you have a new customer, or the customer has a new address. However, in the above case, 80% of the time this won’t occur, but will force the data entry operator to tab multiple times through the address information (even more if you have both a billing and shipping address) in order to enter an order. You’ve designed a UI for every eventuality, slowing down the one that usually occurs! Having a button that allows entry into the other section would allow the system to display the extra address information, but would allow for fast entry of the customer number, followed immediately by order entry.</p>
<h3>Back to Our Import Routine: The CRC Cards</h3>
<p>
Now that we have the use cases and the interface completed, let’s take a look at designing the classes that may be involved. To do this, we’ll use a simplified version of Class-Responsibility-Collaboration (CRC) Cards. These are regular index cards which contain information about a class (one per card) and which classes it collaborates with in order to fulfill its responsibilities.</p>
<p>
We begin by grabbing the nouns from our Use Case descriptions. These become our candidate classes.:</p>
<p>
<b>Nouns:</b></p>
<table>
<tr valign=top>
<td>
<b>User</b></td>
<td>
<b>File</b></td>
</tr>
<tr valign=top>
<td>
Import type</td>
<td>
Spreadsheet</td>
</tr>
<tr valign=top>
<td>
Customer</td>
<td>
Selected file</td>
</tr>
<tr valign=top>
<td>
Employee</td>
<td>
Incorrect data report</td>
</tr>
<tr valign=top>
<td>
Timesheet</td>
<td>
Future additions</td>
</tr>
</table><br>
<p>
We throw out any classes that we know we don’t want to model, and close up duplicates. We also create some simple hierarchies if we find them in our list. In this case, we throw out “user” because we aren’t going to be modeling the user as a class. We also look at “future additions” to see what it means and find out that it, like “customer”, “employee” and “time sheet” are types of imports. So we create a hierarchy for “import type” that includes “customer”, “employee” and “time sheet” knowing that we can further subclass “import type” in the future. </p>
<p>
Looking at “file”, “spreadsheet” and “selected file”, we see that they are all related. We probably want a “file” class that is subclassed into “spreadsheet” and whatever else may come along. Finally, an “incorrect data report” is a type of report, so we’ll probably want to have a hierarchy there as well. Our candidate list now looks like this:</p>
<p>
<b>Nouns:</b></p>
<pre><FONT FACE="Courier New" SIZE="2">Import type
&#09;Customer
&#09;Employee
&#09;Timesheet
File
&#09;Spreadsheet
Report
&#09;Incorrect data report
</font></pre>
<p>
We continue by grabbing the verbs that describe our system. These will be candidates for “responsibilities” which we will then match to our classes.</p>
<p>
<b>Verbs:</b></p>
<pre><FONT FACE="Courier New" SIZE="2">selects 
is imported
cancel 
print 
</font></pre>
<p>
We throw out “selects” because that is a user action. The “cancel” is tied to an import type class (that is what we are canceling) and “print” is tied to the report class. The “is imported” verb is a tricky one. It can be tied to  the import type class because each type knows how to import itself, but it can also be tied to the file class which should know how to handle its type of file. In fact, we have a responsibility that should probably be broken up into two: the import type class should know how to verify itself (in other words, know if the data is correct and where it goes), while the file class should know how to pass its data to whoever requests it. Bingo! We’ve got a collaboration here.</p>
<p>
We then assign methods and properties for any responsibility. (Here I did that for the Import class.) Looking at our classes now, we see:</p>
<p>
<b>Classes:</b></p>
<pre><FONT FACE="Courier New" SIZE="2">Import type
&#09;Subclasses:  Customer, Employee, Timesheet
&#09;Responsibilities: Verify itself, Import itself, Cancel itself
&#09;Collaborates with: File (to get data), Incorrect data report (upon cancel)
&#09;Methods:&#09;Import (Public) - Starts the whole shebang
&#09;&#09;&#09;CheckFileExists (Prot) - See if the file to be imported exists
&#09;&#09;&#09;AppendToTemp (Prot) - Works with “File” to get a temp file
&#09;&#09;&#09;CheckTemp (Prot) - Checks that the temp file is correct
&#09;&#09;&#09;AppendToFinal (Prot) - Appends the data to the main file
&#09;&#09;&#09;Cleanup (Prot) - Does any final operations
&#09;Properties:&#09;cFileName - The name of the input file
File
&#09;Subclasses:  Spreadsheet
&#09;Responsibilities: Pass data
Report
&#09;Subclasses:  Incorrect data report
&#09;Responsibilities: Print itself
</font></pre>
<p>
Reviewing this hierarchy, we can see that adding a new type of import (like Expenses) would simply require subclassing the “import type” class, with no application changes. Changing an import to work with a mainframe comma delimited file would require a new subclass of the “file” class, and once again, would not affect the application. </p>
<h3>Enhancing Traceability</h3>
<p>
In order to trace from the Use Case down to the CRC and finally to the code itself, we number each Use Case and CRC card. We place the number of every CRC card that was derived from a Use Case on that Use Case, and place the number of the Use Case on the derived CRC Card. The CRC Card includes the name of the class and its methods, allowing us to trace to the code.</p>
<p>
When a business change is made, we simply go over the Use Cases with our users, noting what has changed, find the appropriate CRC Cards, make the necessary design changes, and finally modify the code to implement the business change in our classes. In this way, our documentation stays current with our code, easing future maintenance as well!</p>
<h2>How Do We Develop These In Visual FoxPro?</h2>
<p>
Once we have our classes designed in our CRC cards, we have a “blueprint” for each class and its public interface. In other words, we develop according to the CRC, adding any additional protected or private properties and methods that may be necessary to implement the class (for instance, we may need some properties to save state information). </p>
<p>
Review each class to ensure that its public interface is easy to understand. Use standard terms for method names, even creating multiple internal methods that have a single entry point that calls them in order. For instance, in the above import routine, the public interface is the method <b>import()</b>. However, it calls multiple protected methods that each do one function. This is a good general rule: each method should perform one (and only one) function. You may have a method that automates a process by calling multiple methods, but then that process method is also only doing one thing&#45;detailing a process.</p>
<p>
One other option is to create a business object that contains all of the information for modeling something in the real world, and then creating <b>role and process objects</b> that automate the roles and processes that happen in the business. These role and process objects are used by the UI front ends, while the business is used only by the role or process object.</p>
<p>
For example, you may create a Part object that knows how to keep track of how many parts are available, how to build itself from other parts, how to reorder itself, where it is located, etc. You can then create an Inventory Role object that queries reorder information, minimum information, and location information. </p>
<p>
One implementation issue to remember is that you cannot pass parameters to OLE objects upon instantiation, so don’t set up your business objects to expect a parameter.</p>
<h2>How Do We Deploy Them?</h2>
<p>
Once the business objects are created, they can be deployed in any format that you require. You can bind them into one executable with their interface and data objects by placing them all in a single project. This works well on smaller systems that are to be physically deployed on one machine or a small departmental LAN. </p>
<p>
As the LAN grows, you can separate the business objects into their own project, and place them on another machine, accessing them automatically through DCOM (Distributed OLE) or Remote OLE Automation. Visual FoxPro does all the work&#45;all that is necessary is that you compile them separately and register them on the other machine with DCOMCFG or another tool of that sort.</p>
<h2>Conclusion</h2>
<p>
Visual FoxPro’s strong object-oriented capabilities have been greatly enhanced through the integration of DCOM and Remote OLE Automation. Creating your business objects as separate classes in their own logical layer will allow you to have your applications grow as your business does. </p>
<p>
&copy; 1997 Microsoft Corporation. All rights reserved.</p>
<p>
The information contained in this document represents the current view of Microsoft Corporation on the issues discussed as of the date of publication. Because Microsoft must respond to changing market conditions, it should not be interpreted to be a commitment on the part of Microsoft, and Microsoft cannot guarantee the accuracy of any information presented after the date of publication.</p>
<p>
This document is for informational purposes only. MICROSOFT MAKES NO WARRANTIES, EXPRESS OR IMPLIED, IN THIS SUMMARY.</p>
<p>
Microsoft, Visual FoxPro, and Visual Basic are registered trademarks and SQL Server is a trademark of Microsoft Corporation.</p>
<p>
Other product or company names mentioned herein may be the trademarks of their respective owners.</p>
</font></BODY>
</HTML>
