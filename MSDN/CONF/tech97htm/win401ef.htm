<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ANSI C++ Conformity in Visual C++ 5.0</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>


	<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>


	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<h1>ANSI C++ Conformity in Visual C++ 5.0</h1>
<p>
Presented by Jonathan Caves<BR>Visual C++ Business Unit<BR>Microsoft Corporation</p>
<h2>Introduction</h2>
<p>
This paper lists the C++ language features that are supported for the first time in Microsoft&reg; Visual C++&reg; 5.0, or that have undergone a major revision since Microsoft Visual C++ 4.0. Where applicable, we will describe problems that users may encounter while using these new features.</p>
<p>
For a full description of these C++ language features please see the latest ANSI/ISO working paper for the draft proposed standard for C++, or the online documentation contiguous supplied with Visual C++ 5.0</p>
<h2>Support for Bool</h2>
<p>
Visual C++ 5.0 includes support for the C++ built-in type “bool” along with the Boolean values “true” and “false”. This type can be used as follows:</p>
<pre><FONT FACE="Courier New" SIZE="2">bool flag = true;
bool test(int value1, int value2) {
   flag = false;
   return value + value2 &gt; 0
}
</font></pre>
<p>
The only special rule about the built-in type “bool” is that when a postfix or prefix version of “operator ++” is applied to a variable of type “bool”, the value of the variable is set to “true”. The postfix and prefix versions of “operator&#45;” cannot be applied to a variable of type “bool”. In arithmetic operations a Boolean value of “true” is converted to “1” while a Boolean value of “false” is converted to “0”.</p>
<pre><FONT FACE="Courier New" SIZE="2">void f() {
   int i = 2;
   i += true;
   DASSERT(i == 3);
}
</font></pre>
<p>
Visual C++ 5.0 defines a macro __BOOL_DEFINED that can be used to wrap code that is dependent on whether or not “bool” is supported.</p>
<pre><FONT FACE="Courier New" SIZE="2">#if !defined(__BOOL_DEFINED)
typedef int bool
#define true  1
#define false 0
#endif
</font></pre>
<p>
Support for “bool” can be turned off by using the “/noBool” compiler switch.</p>
<p>
A common problem we discovered when we converted to using “bool” instead of “int” was that a lot of programs did not respect the fact that a Boolean variable (even when it is represented by an “int”) should only take one of two values. For example, code like the following was not uncommon.</p>
<pre><FONT FACE="Courier New" SIZE="2">void f(BOOL fFlag) {
   switch (fFlag) {
      case TRUE:
         //Ö
         break;
      case FALSE:
         //Ö
         break;
      case 3:
         //Ö
         break;
   }
}
</font></pre>
<p>
And</p>
<pre><FONT FACE="Courier New" SIZE="2">BOOL Test();
void f() {
   if (Test() == 3) {
      //Ö
   }
} 
</font></pre>
<p>
Both of the above code fragments will generate warnings when compiled with Visual C++ 5.0.</p>
<p>
Another problem that was discovered while testing the use of “bool” internally was that there was existing iostream code that had the C++ operator precedence wrong. This “bug” did not manifest itself as long as “int” or some other built-in type was used to represent “bool”. However, once “bool” was fully supported as a separate type the code broke. The code in question looks something like the following (it is shown in a much-reduced pre-bool form).</p>
<pre><FONT FACE="Courier New" SIZE="2">typedef int bool;
#define true 1
#define false 0
class ostream {
public:
   // Ö
   ostream &amp;operator&lt;&lt;(int);
};
class X {
public:
   // Ö
   bool Test() const {
      return ‘some-expr’ ? true : false;
   }
};
ostream&amp; operator&lt;&lt;(ostream&amp; os, const X&amp; x) {
   os &lt;&lt; x.Test() ? '1' : '0';
   return os;
}
</font></pre>
<p>
The problem is with the statement. </p>
<pre><FONT FACE="Courier New" SIZE="2">os &lt;&lt; x.Test() ? '1' : '0';
</font></pre>
<p>
Due to the fact that operator &lt;&lt; has a higher precedence than operator ?: this statement is parsed by the C++ grammar as follows.</p>
<pre><FONT FACE="Courier New" SIZE="2">(os &lt;&lt; x.Test()) ? '1' : '0';
</font></pre>
<p>
when what the user intends is the following:</p>
<pre><FONT FACE="Courier New" SIZE="2">os &lt;&lt; (x.Test() ? '1' : '0');
</font></pre>
<p>
When “bool” is fully supported as a built-in type the code breaks because class ostream does not have a member “operator&lt;&lt; (bool)”.</p>
<h2>Support for Mutable</h2>
<p>
Visual C++ 5.0 includes support for the C++ storage class specifier “mutable”. This specifier can only be applied to non-const, non-static, data member of a class. Any data member, which is declared to be mutable, can be modified from within a “const” member function; for example, with Visual C++ 5.0 the following code fragment will compile without error.</p>
<pre><FONT FACE="Courier New" SIZE="2">class X {
public:
   bool GetFlag() const {
      m_accessCount++;
      return m_flag;
   }
private:
           bool m_flag;
   mutable int  m_accessCount;
};
</font></pre>
<p>
This will compile without error as “m_accessCount” has been declared to be “mutable”, and therefore can be modified from within “GetFlag ()” even though “GetFlag ()” is a const member function.</p>
<h2>Support for Explicit</h2>
<p>
Visual C++ 5.0 includes support for the C++ function specifier “explicit”. This specifier can only be applied to the declarations of constructors within class declarations.</p>
<pre><FONT FACE="Courier New" SIZE="2">class X {
public:
   explicit X(int);        // legal
   explicit X(double) {        // legal
      // Ö
   }
};
explicit X::X(int) {        // illegal
   // Ö
}
</font></pre>
<p>
An “explicit” constructor cannot take part in implicit conversions&#45;it can only be used to explicitly construct an object, e.g., using the above class.</p>
<pre><FONT FACE="Courier New" SIZE="2">void f(X) {
   // Ö
}
void g(int i) {
   f(i);        // Will cause an error
}
void h() {
   X x1(1);        // Legal
}
</font></pre>
<dl>
<dt>
The function call “f(i)” will fail, as there is no available implicit conversion from an “int” to an “X”.</dt>
<dd>
<b>Note</b>   Applying “explicit” to a constructor that requires more than one explicit argument is superfluous, as such constructors can never take part in implicit conversions.<pre><FONT FACE="Courier New" SIZE="2">class X {
public:
   explicit X(int);                // Meaningful
   explicit X(double, int = 0);        // Meaningful
   explicit X(int, int, int);            // Superfluous
};
</font></pre>
</dd>
</dl>
<h2>Support for Local Classes</h2>
<p>
While previous versions of Visual C++ did support local classes they did not support local class member functions, Visual C++ 5.0 supports this feature. For example, the following code fragment will compile without error.</p>
<pre><FONT FACE="Courier New" SIZE="2">void f() {
   class X {
   public:
      void mf() {
      }
   }; 
   X x;
   x.mf();
}
</font></pre>
<p>
<b>Note</b>   The following restrictions apply to local classes:
<ul>
<li>
Any member functions of a local class must be fully defined within the class.<br><br></li>
<li>
A local class cannot have static data members.<br><br></li>
<li>
A local class cannot only access type names, static variables, extern variables and functions, and enumerators from the enclosing scope.</li>
</ul>
<h2>Syntax Checking of Template Definitions</h2>
<p>
The proposed ANSI/ISO standard for C++ requires that compilers parse and syntax check template definitions. This feature is implemented in Visual C++ 5.0. This means that Visual C++ 5.0 can detect many errors that previous versions of Visual C++ could not detect. For example, the following code will give an error with Visual C++ 5.0 but not with Visual C++ 4.0.</p>
<pre><FONT FACE="Courier New" SIZE="2">template&lt;class T&gt;
class X {
public:
   void mf() const;
};
template&lt;class T&gt;
void X&lt;T&gt;::mf() {      // Error: Missing ‘const’
   // Ö
}
</font></pre>
<p>
This also means that the compiler will detect syntax errors in template classes that are defined, but never instantiated. With previous versions of Visual C++, if a class or function template were never instantiated, then the compiler would not check its definition for errors.</p>
<p>
While testing this feature internally we came across three common errors that users may run into once they start using Visual C++ 5.0.</p>
<p>
The first problem is the case of a type being used in a template definition before it has been declared, but then the type is declared before the first instantiation, or use, of the template. This would compile with Visual C++ 4.0, but it will not compile with Visual C++ 5.0 because, as Visual C++ 5.0 syntax checks the class template declaration, it requires that the type has been declared.</p>
<pre><FONT FACE="Courier New" SIZE="2">template&lt;class T&gt;
class X {
   // Ö
   Data m_data;    // Error seen here with Visual C++ 5.0
};
class Data {
   // Ö
};
void g() {
   X&lt;int&gt; x1;
}
</font></pre>
<p>
The fix for this problem is to move the definition of the class Data to before the definition of the class template X.</p>
<p>
The second problem is a member function being defined outside of a class template when it was never declared inside the class.</p>
<pre><FONT FACE="Courier New" SIZE="2">template&lt;class T&gt;
class X {
   // No mf declared here
};
// This definition did not cause an error with Visual C++ 4.0 but
// it will cause an error with Visual C++ 5.0
//
template&lt;class T&gt;
void X&lt;T&gt;::mf() {
   // Ö
}
</font></pre>
<p>
The third problem is related to the first problem and has to do with the fact that a class is considered to be a “normal” class unless it has been explicitly declared to be a class template. The following code will produce errors with Visual C++ 5.0 but not with Visual C++ 4.0.</p>
<pre><FONT FACE="Courier New" SIZE="2">template&lt;class T&gt;
class X {
   friend class Y&lt;T&gt;;    // Parsed as Y 'less-than' T
                        // 'greater-than'
   Z&lt;T&gt; *mf();        // Parsed as Z 'less-than' T
                        // 'greater-than'
};
template&lt;class T&gt;
class Y {
};
template&lt;class T&gt;
class Z {
};
X&lt;int&gt; x;
</font></pre>
<p>
To correct this problem, a user should forward declare Y and Z before the definition of X.</p>
<pre><FONT FACE="Courier New" SIZE="2">template&lt;class T&gt; class Y;
template&lt;class T&gt; class Z;
template&lt;class T&gt; class X {
   // Ö
};
</font></pre>
<h2>Support for the Reuse of Template Parameters</h2>
<p>
Visual C++ 5.0 supports the reuse of template parameters within template parameter lists. For example, code like the following is now supported.</p>
<pre><FONT FACE="Courier New" SIZE="2">class Y {
  // Ö
};
template&lt;class T, T* pT&gt;
class A {
  // Ö
};
Y aY;
A&lt;Y, &amp;aY&gt; a;
</font></pre>
<p>
In Visual C++ 5.0 a template parameter can also be used as the default argument for a subsequent template parameter. For example, in the following code fragment the class template specialization B&lt;int&gt; is identical to the class template specialization B&lt;int, int&gt;:</p>
<pre><FONT FACE="Courier New" SIZE="2">template&lt;class T1, class T2 = T1&gt;
class B {
  // Ö
};
B&lt;int&gt; b1;
B&lt;int, int&gt; b2;
</font></pre>
<h2>Support for Typename</h2>
<p>
Visual C++ 5.0 supports the new keyword “typename”. This keyword has two uses.</p>
<p>
The first use is that “typename” can be used instead of “class” in template parameter lists. For example, the following two template parameter lists are identical.</p>
<pre><FONT FACE="Courier New" SIZE="2">template&lt;class T1, class T2&gt; // Ö
template&lt;typename T1, typename T2&gt; // Ö
</font></pre>
<p>
The second use of “typename” is within class template definitions where “typename” is used to indicate, during the syntax checking of the template definition, that a qualified name that is dependent on a template parameter denotes a type. This is necessary as under strict ANSI/ISO C++ rules the following code should produce an error, as any name used within a template definition is assumed not to name a type unless the lookup of the name finds a type. As the compiler knows nothing about “T” (apart from the fact that it is some generic type), it cannot know anything about “N”; thus, it should not treat “N” as a type.</p>
<pre><FONT FACE="Courier New" SIZE="2">template&lt;class T&gt;
class X {
   typedef T::N M;
};
</font></pre>
<p>
The introduction of the keyword “typename” allows the user to explicitly specify to the compiler that N is a type. For example, the following code should compile without an error.</p>
<pre><FONT FACE="Courier New" SIZE="2">template&lt;class T&gt;
class X {
   typedef typename T::N M;
};
</font></pre>
<p>
<b>Note</b>   As “typename” only applies to the immediately following qualified name, the two “statements” cannot be separated. For example, the following code fragment will generate an error.</p>
<pre><FONT FACE="Courier New" SIZE="2">template&lt;class T&gt;
class X {
   typename T::N;
   typedef T::N M;    // Illegal - ‘N’ is not a type name
};
</font></pre>
<p>
It is illegal to instantiate a class template with a type which does not declare the identifier introduced via a “typename” as a type. For example, the following two instantiations of the class template X will generate errors.</p>
<pre><FONT FACE="Courier New" SIZE="2">class A {
  // No ‘N’ declared
};
class B {
public:
   int N;    // A ‘N’ is declared but is not a type
};
X&lt;A&gt; x1;
X&lt;B&gt; x2;
</font></pre>
<p>
<b>Note</b>   In Visual C++ 5.0 “typename” is only really necessary if the user compiles with /Za (ANSI C++ mode). Under /Ze (Extended C++ mode) the compiler assumes that any name in a qualified name that it cannot resolve via normal name lookup is a type&#45;if a type can appear in the current context in the C++ grammar.</p>
<pre><FONT FACE="Courier New" SIZE="2">template&lt;class T&gt;
class X {
   T::N x;            // Compiler assumes 'N' is a type
   void mf() {        
      T::mf();        // Compiler assumes 'mf' is an identifier
   }
};
</font></pre>
<h2>Support for the Explicit Specification of Template Arguments for Function Templates</h2>
<p>
In previous versions of Visual C++ each of the template arguments associated with a function template had to be deduced from the function arguments at the call site. Visual C++ 5.0 allows users to explicitly specify the template arguments. For example, the following code is now legal.</p>
<pre><FONT FACE="Courier New" SIZE="2">template&lt;typename T&gt;
void f(T) {
   // Ö
}
void g(char j) {
   f&lt;int&gt;(j);    // generate the specialization ‘f(int)’
}
</font></pre>
<p>
When a template argument is explicitly specified in this way, implicit conversions are allowed in order to convert the function argument to the type of the corresponding function parameters. For example, in this case the compiler will convert “j” to type “int”. Implicit conversions are not allowed when a template argument is deduced.</p>
<p>
The addition of this feature provides a way for calling function templates that have a generic return type. This was impossible in previous versions of Visual C++.</p>
<pre><FONT FACE="Courier New" SIZE="2">template&lt;typename T1, typename T2&gt;
T1 convert(T2 t2) {
   // Ö
}
int g(char c) {
   return convert&lt;int&gt;(c);   
}
</font></pre>
<h2>Support for Explicit Specialization of Templates</h2>
<p>
Visual C++ 5.0 supports the new syntax for declaring explicit specializations of function or class templates. For example, the following code is now accepted by Visual C++ 5.0.</p>
<pre><FONT FACE="Courier New" SIZE="2">template&lt;typename T&gt;
class X {
};
template&lt;typename T&gt;
void f(T t) {
}
// Explicit specialization of X with ‘int’
//
template&lt;&gt; class X&lt;int&gt; {
};
// Explicit specialization of f with ‘char’ with the
// template argument explicitly specified
//
template&lt;&gt; void f&lt;char&gt;(char c) {
}
// Explicit specialization of f with ‘double’ with the
// template argument deduced
//
template&lt;&gt; void f(double d) {
}
</font></pre>
<p>
In order to support existing code, Visual C++ 5.0 continues to allow the older syntax.</p>
<pre><FONT FACE="Courier New" SIZE="2">// Explicit specialization of X with ‘char’
//
class X&lt;char&gt; {
};
// Explicit specialization of f with ‘char; with the
// template argument deduced.
//
void f(char) {
}
</font></pre>
<h2>Support for Explicit Instantiation of Function Templates</h2>
<p>
Visual C++ 5.0 supports the explicit instantiation of function templates&#45;previous versions only supported the explicit instantiation of class templates. Thus, the following code is now accepted.</p>
<pre><FONT FACE="Courier New" SIZE="2">template&lt;typename T&gt;
void f(T) {
}
// Instantiate f with the explicitly specified
// template argument 'int'
//
template void f&lt;int&gt;(int);
// Instantiate f with the deduced template
// argument 'char'
//
template void f(char);
</font></pre>
<h2>Support for Importing and Exporting Templates </h2>
<p>
Visual C++ 5.0 allows users to import or export instantiations of a template class or function from a DLL. This is achieved by explicitly instantiating the template in question with the desired arguments and marking the instantiation as either dllimport or dllexport.</p>
<pre><FONT FACE="Courier New" SIZE="2">template&lt;typename T&gt;
class X {
};
// Explicitly instantiate X with ‘int’ and export it from the DLL
//
template class __declspec(dllexport) X&lt;int&gt;;
</font></pre>
<p>
When a class template is explicitly instantiated, a definition must be available for each of the members of the class. The following code fragment will generate diagnostics when compiled with Visual C++ 5.0.</p>
<pre><FONT FACE="Courier New" SIZE="2">template&lt;typename T&gt;
class X {
public:
   void mf();
private:
   static int m_flag;
};
// No definition for either the member function ‘mf’ or 
// for the static data member ‘m_flag’
//
template class __declspec(dllexport) X&lt;char&gt;;
</font></pre>
<p>
<b>Note</b>   A template definition itself cannot be marked for export or import. For example, the following is illegal.</p>
<pre><FONT FACE="Courier New" SIZE="2">template&lt;typename T&gt;
class __declspec(dllexport) X {
};
</font></pre>
<h2>Fix for  the Namespace Using-Directive</h2>
<p>
In Visual C++ 4.0 the namespace using-directive was implemented incorrectly. For example, given the following code Visual C++ 4.0 would print out “data = 4” instead of the correct answer “data = 0”.</p>
<pre><FONT FACE="Courier New" SIZE="2">namespace N {
  int data = 4;
}
void f(bool flag) {
   int data = 0;
   if (flag) {
      using namespace N;
      printf(&quot;data = %d\n&quot;, data);
   }
}
void main() {
   f(true);
}
</font></pre>
<p>
This problem has been fixed in Visual C++ 5.0.</p>
<h2>Fix for Qualified-Name Lookup</h2>
<p>
Just before Visual C++ 4.0 shipped, the ANSI/ISO C++ committee changed the way qualified-names were looked up in the presence of namespace using-directives. The committee decided that the following code should be legal.</p>
<pre><FONT FACE="Courier New" SIZE="2">namespace A {
   int flag = 0;
}
namespace B {
   using namespace A;
}
namespace C {
   using namespace A;
   using namespace B;
}
void main() {
   printf(&quot;C::flag = %d\n&quot;, C::flag);  
}
</font></pre>
<p>
The qualified-name “C::flag” should resolve to “A::flag” due to the namespace using directives within namespace C. Visual C++ 5.0 implements this feature.</p>
<h2>Support for Member Array New and Delete</h2>
<p>
Visual C++ 5.0 supports the definition of member operators for array new and array delete. For example, the following code will compile.</p>
<pre><FONT FACE="Courier New" SIZE="2">class X {
public:
   void* operator new[](size_t);
   void  operator delete[](void*);
};
void f() {
   X *pX = new X[5];
   delete [] pX;
}
</font></pre>
<h2>The C++ Standard Library</h2>
<p>
Visual C++ 5.0 includes an implementation of the C++ Standard Library.</p>
<h3>What Is It?</h3>
<p>
The C++ Standard Library grew out of the C++ standardization process. It is a specification of a collection of classes and routines for extending the C++ language. An implementation of the C++ Standard Library first shipped with Visual C++ 4.2.</p>
<p>
<b>Language support </b></p>
<p>
Language support provides access to limits; memory allocation; new and delete; exception processing; definition of exception; and typeinfo.</p>
<table>
<tr valign=top>
<td>
Types</td>
<td>
<code>&lt;cstddef&gt;</code></td>
</tr>
<tr valign=top>
<td>
Implementation Properties</td>
<td>
<code>&lt;limits&gt;</code><p>
<code>&lt;climits&gt;</code></p>
<pre><FONT FACE="Courier New" SIZE="2">&lt;cfloat&gt;</font></pre>
</td>
</tr>
<tr valign=top>
<td>
Start and Termination</td>
<td>
<code>&lt;cstdlib&gt;</code></td>
</tr>
<tr valign=top>
<td>
Dynamic Memory<p>
Management</p>
</td>
<td>
<code>&lt;new&gt;</code></td>
</tr>
<tr valign=top>
<td>
Type Identification</td>
<td>
<code>&lt;typeinfo&gt;</code></td>
</tr>
<tr valign=top>
<td>
Exception Handling</td>
<td>
<code>&lt;exception&gt;</code></td>
</tr>
<tr valign=top>
<td>
Runtime Support</td>
<td>
<code>&lt;cstdarg&gt;</code><p>
<code>&lt;csetjmp&gt;</code></p>
<p>
<code>&lt;ctime&gt;</code></p>
<p>
<code>&lt;csignal&gt;</code></p>
<pre><FONT FACE="Courier New" SIZE="2">&lt;cstdlib&gt;</font></pre>
</td>
</tr>
</table><br>
<p>
<b>Diagnostics</b></p>
<p>
Diagnostics defines the standard exceptions that can be generated by the C++ Standard Library, such as, logic_error, domain_error, invalid_argument.</p>
<table>
<tr valign=top>
<td>
Exception Classes</td>
<td>
<code>&lt;stdexcept&gt;</code></td>
</tr>
<tr valign=top>
<td>
Assertions</td>
<td>
<code>&lt;cassert&gt;</code></td>
</tr>
<tr valign=top>
<td>
Error Numbers</td>
<td>
<code>&lt;cerrno&gt;</code></td>
</tr>
</table><br>
<p>
<b>General utilities</b></p>
<p>
General utilities defines utilities that are required by the rest of the library, such as allocators, comparison operators, and functional objects.</p>
<table>
<tr valign=top>
<td>
Utilities</td>
<td>
<code>&lt;utility&gt;</code></td>
</tr>
<tr valign=top>
<td>
Function Objects</td>
<td>
<code>&lt;functional&gt;</code></td>
</tr>
<tr valign=top>
<td>
Memory</td>
<td>
<code>&lt;memory&gt;</code></td>
</tr>
<tr valign=top>
<td>
Date and Time</td>
<td>
<code>&lt;ctime&gt;</code></td>
</tr>
</table><br>
<p>
<b>Strings</b></p>
<p>
Strings provide support for character manipulation, where a character may be a “char”, or a “wchar_t”, or some other user specified representation.</p>
<table>
<tr valign=top>
<td>
String Classes</td>
<td>
<code>&lt;string&gt;</code></td>
</tr>
<tr valign=top>
<td>
C String Utilities</td>
<td>
<code>&lt;cctype&gt;</code><p>
<code>&lt;cwctype&gt;</code></p>
<p>
<code>&lt;cstring&gt;</code></p>
<p>
<code>&lt;cwchar&gt;</code></p>
<pre><FONT FACE="Courier New" SIZE="2">&lt;cstdlib&gt;</font></pre>
</td>
</tr>
</table><br>
<p>
<b>Localization</b></p>
<p>
Localiazation provides support for the localization of software, such as how a date should be represented and how a monetary value should be printed.</p>
<table>
<tr valign=top>
<td>
Locales</td>
<td>
<code>&lt;locale&gt;</code></td>
</tr>
<tr valign=top>
<td>
C Locales</td>
<td>
<code>&lt;clocale&gt;</code></td>
</tr>
</table><br>
<p>
<b>Containers</b></p>
<p>
Containers provide C++ access to common data structures, such as list, stack.</p>
<table>
<tr valign=top>
<td>
Sequences</td>
<td>
<code>&lt;bitset&gt;</code><p>
<code>&lt;deque&gt;</code></p>
<p>
<code>&lt;list&gt;</code></p>
<p>
<code>&lt;queue&gt;</code></p>
<p>
<code>&lt;stack&gt;</code></p>
<pre><FONT FACE="Courier New" SIZE="2">&lt;vector&gt;</font></pre>
</td>
</tr>
<tr valign=top>
<td>
Associative Containers</td>
<td>
<code>&lt;map&gt;</code><pre><FONT FACE="Courier New" SIZE="2">&lt;set&gt;</font></pre>
</td>
</tr>
</table><br>
<p>
<b>Iterators</b></p>
<p>
Iterators are common iterators, such as input, output, forward, and reverse.</p>
<table>
<tr valign=top>
<td>
Iterators</td>
<td>
<code>&lt;iterator&gt;</code></td>
</tr>
</table><br>
<p>
<b>Algorithms</b></p>
<p>
Common algorithms, such as find, sort, replace, and merge.</p>
<table>
<tr valign=top>
<td>
Algorithms</td>
<td>
<code>&lt;algorithm&gt;</code></td>
</tr>
<tr valign=top>
<td>
C Algorithms</td>
<td>
<code>&lt;cstdlib&gt;</code></td>
</tr>
</table><br>
<p>
<b>Numerics</b></p>
<p>
Numerics provide C++ support for complex and valarray.</p>
<table>
<tr valign=top>
<td>
Complex Numbers</td>
<td>
<code>&lt;complex&gt;</code></td>
</tr>
<tr valign=top>
<td>
Numeric Arrays</td>
<td>
<code>&lt;valarray&gt;</code></td>
</tr>
<tr valign=top>
<td>
General Numeric Operations</td>
<td>
<code>&lt;numeric&gt;</code></td>
</tr>
<tr valign=top>
<td>
C Numeric Operations</td>
<td>
<code>&lt;cmath&gt;</code><pre><FONT FACE="Courier New" SIZE="2">&lt;cstdlib&gt;</font></pre>
</td>
</tr>
</table><br>
<p>
<b>Input/Output Library</b></p>
<p>
Input/output Libraries provide C++ I/O support using streams, such as iostream, and fstream.</p>
<table>
<tr valign=top>
<td>
Forward Declarations</td>
<td>
<code>&lt;iosfwd&gt;</code></td>
</tr>
<tr valign=top>
<td>
Iostream objects</td>
<td>
<code>&lt;iostream&gt;</code></td>
</tr>
<tr valign=top>
<td>
Iostream base classes</td>
<td>
<code>&lt;ios&gt;</code></td>
</tr>
<tr valign=top>
<td>
Stream Buffers</td>
<td>
<code>&lt;streambuf&gt;</code></td>
</tr>
<tr valign=top>
<td>
Formatting and Manipulators</td>
<td>
<code>&lt;istream&gt;</code><p>
<code>&lt;ostream&gt;</code></p>
<pre><FONT FACE="Courier New" SIZE="2">&lt;iomanip&gt;</font></pre>
</td>
</tr>
<tr valign=top>
<td>
String Streams</td>
<td>
<code>&lt;sstream&gt;</code><pre><FONT FACE="Courier New" SIZE="2">&lt;cstdlib&gt;</font></pre>
</td>
</tr>
<tr valign=top>
<td>
File Streams</td>
<td>
<code>&lt;fstream&gt;</code><p>
<code>&lt;cstdio&gt;</code></p>
<pre><FONT FACE="Courier New" SIZE="2">&lt;cwchar&gt;</font></pre>
</td>
</tr>
</table><br>
<h3>Changes Since Visual C++ 4.2</h3>
<p>
Since Visual C++ 4.2, the following changes have been made to the Visual C++ implementation of the C++ Standard Library. </p>
<p>
<b>Support for the C++ Standard Library in a DLL</b></p>
<p>
Visual C++ 5.0 comes with a version of the C++ Standard Library in a DLL (msvcprt.lib and msvcp50.dll). Therefore, users no longer have to always statically link to the C++ Standard Library.</p>
<p>
<b>Support for “std” namespace</b></p>
<p>
In accordance with the draft ANSI/ISO C++ Standard, the C++ Standard Library is now defined within the “std” namespace. Users must therefore change their existing code in order to be able to access elements of the C++ Standard Library.</p>
<pre><FONT FACE="Courier New" SIZE="2">#include &lt;list&gt;
// Use a ‘using directive’
//
using namespace std
list&lt;int&gt; g_list;
// or a ‘using declaration’
//
using std::list;
list&lt;int&gt; g_list;
// or explicitly qualify the name
//
std::list&lt;int&gt; g_list;
</font></pre>
<p>
<b>Support for default allocators</b></p>
<p>
As Visual C++ 5.0 supports default template parameters, users no longer have to explicitly specify an allocator and, in some cases, a container whenever they specialize a container from the C++ Standard Library. </p>
<pre><FONT FACE="Courier New" SIZE="2">#include &lt;stack&gt;
// Visual C++ 4.2
//
stack&lt;int, deque&lt;int, allocator&lt;int&gt; &gt; &gt; g_stack;
// Visual C++ 5.0
//
std::stack&lt;int&gt; g_stack;
</font></pre>
<h3>Problem Specializing a Container With a User-Defined Type</h3>
<p>
Due to the way that Visual C++ 5.0 handles the member functions of a class template that are fully defined within the class, users may find that they are unable to specialize a C++ Standard Library container with a user-defined type. For example, the following code fragment will not compile cleanly.</p>
<pre><FONT FACE="Courier New" SIZE="2">#include &lt;stack&gt;
using namespace std;
class X {
   // Ö
private:
   int m_data;
};
stack&lt;X&gt; g_stack;        // Errors here
</font></pre>
<p>
The reason this code will not compile is that when Visual C++ 5.0 instantiates a specialization of a class template it also instantiates all the member functions that are fully defined within the class, regardless of whether they are used or not. This means, in the case of the stack container, that Visual C++ 5.0 instantiates both of the following operators.</p>
<pre><FONT FACE="Courier New" SIZE="2">bool std::stack&lt;int&gt;::operator&lt;(const std::stack&lt;int&gt; &amp;) const;
bool std::stack&lt;int&gt;::operator==(const std::stack&lt;int&gt; &amp;) const;
</font></pre>
<p>
The instantiation of these functions causes (eventually) the compiler to search for the following two declarations.</p>
<pre><FONT FACE="Courier New" SIZE="2">bool X::operator&lt;(const X &amp;) const;
bool X::operator==(const X &amp;) const;
</font></pre>
<p>
As the user has not declared these functions the compiler will generate appropriate error messages.</p>
<p>
The solution to this problem is for the user to add the above declarations to his or her class. For example, X should be defined as follows.</p>
<pre><FONT FACE="Courier New" SIZE="2">class X {
   // Ö
   bool operator&lt;(const X &amp;) const;
   bool operator==(const X &amp;) const;
private:
   int m_data;
};
</font></pre>
<p>
<b>Note</b>   Only the declarations of these functions are required. As the functions that require these declarations are not called, they will be removed at the link phase, and thus linker errors will be avoided.</p>
<p>
If the user really does want to compare two containers, then the member comparison operators need to be defined; otherwise, linker error will occur.</p>
<p>
In some cases it may also be necessary to declare a default constructor. For example, if class X had been defined as follows:</p>
<pre><FONT FACE="Courier New" SIZE="2">class X {
oublic:
   X(int);
   // Ö
   bool operator&lt;(const X &amp;) const;
   bool operator==(const X &amp;) const;
private:
   int m_data;
};
</font></pre>
<p>
Then a default constructor would be necessary, as many of the container routines (like the constructor for deque) are defined along the following lines.</p>
<pre><FONT FACE="Courier New" SIZE="2">template&lt;class _Ty, class _A = allocator&lt;_Ty&gt; &gt;
class deque {
public:
   explicit deque(size_type _N, const _Ty&amp; _V = _Ty(),
                   const _A&amp; _Al = _A());
   // ...
};
</font></pre>
<p>
Again the problem occurs because that Visual C++ 5.0 is doing more processing than is really necessary. In this case it is processing the default argument even though it is not required.</p>
<p>
&copy; 1997 Microsoft Corporation. All rights reserved.</p>
<p>
The information contained in this document represents the current view of Microsoft Corporation on the issues discussed as of the date of publication. Because Microsoft must respond to changing market conditions, it should not be interpreted to be a commitment on the part of Microsoft, and Microsoft cannot guarantee the accuracy of any information presented after the date of publication.</p>
<p>
This document is for informational purposes only. MICROSOFT MAKES NO WARRANTIES, EXPRESS OR IMPLIED, IN THIS SUMMARY.</p>
<p>
Microsoft and Visual C++ are registered trademarks of Microsoft Corporation.</p>
<p>
Other product or company names mentioned herein may be the trademarks of their respective owners.</p>
</font></BODY>
</HTML>
