<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Multitier Architecture Part II</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>



	<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>



	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<h1>Multitier Architecture Part II</h1>
<p>
Copyright 1994-97 Paul D. Sheriff &amp; Associates</p>
<p>
All Rights Reserved Worldwide, Reproduction is strictly prohibited.</p>
<p>
Creating reusable classes that you can use in every database application is a great productivity tool. Of course, you must take some time up front to develop these; the payoff will come on your next application. There are many examples of reusable classes you can create. In this course, you will learn about a couple of them.</p>
<p>
A data access class is a wrapper around all of the things you may do to a base table. Adding, editing, deleting and retrieving records will all become methods that you invoke. You can even add functionality such as specifying the WHERE clause and the ORDER BY clause. Once you have created one of these classes, you will never have SQL statements all over your source code again. Instead, you will always be instantiating an object, setting some properties, and invoking some methods. You will find that by doing this, you will greatly speed up your development time, cut down the number of bugs, and greatly reduce the maintenance time.</p>
<h2>Reusable Classes</h2>
<p>
The BARK sample application uses many different classes. There will be classes that are generic that can be used in many applications, and there are others that are specific to the BARK application. In this section, you will learn how to create some of the generic classes that you will be able to use and reuse in all of your applications. The following is a list of the generic functions you will learn to create in this chapter.
<ul>
<li>
Database Connection Class<br><br></li>
<li>
Recordset Class</li>
</ul>
<h2>Database Connection Class</h2>
<p>
In every database application you design, you will generally need to keep track of several pieces of information to make that connection:
<ul>
<li>
Data Source Name (DSN)<br><br></li>
<li>
Database Name<br><br></li>
<li>
Login ID<br><br></li>
<li>
Password<br><br></li>
<li>
Are you connected to a database server or a local MDB?<br><br></li>
<li>
Is there a system database for security on an MDB?<br><br></li>
<li>
Database object, connection object, or connection handle<br><br></li>
<li>
Workspace object, engine object, or environment handle</li>
</ul>
<p>
Most programmers will keep this information in separate global variables. Next you would then have some public functions that perform the following services:
<ul>
<li>
Initialize the database engine, workspace, or environment<br><br></li>
<li>
Open a connection to the database<br><br></li>
<li>
Create a Recordset object from the connection<br><br></li>
<li>
Execute an action query<br><br></li>
<li>
Disconnect from a database<br><br></li>
<li>
Free the resources used by the database engine, workspace, or environment</li>
</ul>
<p>
Each of the above functions relies on one or more of the global variables you defined above. All of this information taken together is an ideal candidate for a class. You have the global variables, which can become properties, and the functions that act upon those global variables (properties), which can become the methods.</p>
<h3>Class Name</h3>
<p>
The name of this database class is DBConnect. To create an instance of this Database Connection Class, you would use the following code:</p>
<pre><FONT FACE="Courier New" SIZE="2">Public goConnect As New DBConnect
</font></pre>
<p>
The Database Connection Class you create will be for one type of database access method.  Depending on the database access methods you want to use, you will need to create a Database Connection Class for each one. The class you will see in this chapter is the one for Jet.</p>
<h3>The Properties</h3>
<p>
The DBConnect Class will have both private variables and corresponding public properties that are implemented using Property Get and Property Let procedures. Below is a list of each of the public properties that you will use to reference the data from your global database connection object:</p>
<table>
<tr valign=top>
<td>
<b>Public Name</b></td>
<td>
<b>Private Name</b></td>
<td>
<b>Description</b></td>
</tr>
<tr valign=top>
<td>
ConnectString</td>
<td>
NA</td>
<td>
Builds an ODBC connect string using other variables within this object.</td>
</tr>
<tr valign=top>
<td>
DBPath</td>
<td>
pstrDBPath</td>
<td>
The path of the local MDB.</td>
</tr>
<tr valign=top>
<td>
DBName</td>
<td>
pstrDBName</td>
<td>
The name of the local MDB.</td>
</tr>
<tr valign=top>
<td>
DatabaseName</td>
<td>
pstrDatabase</td>
<td>
The full name of the local MDB or the name of the server database.</td>
</tr>
<tr valign=top>
<td>
DBObject</td>
<td>
pdb</td>
<td>
The database object.</td>
</tr>
<tr valign=top>
<td>
DSN</td>
<td>
pstrDSN</td>
<td>
The Data Source Name.</td>
</tr>
<tr valign=top>
<td>
InfoCode</td>
<td>
plngInfoCode</td>
<td>
Returns the last error code generated within this class.</td>
</tr>
<tr valign=top>
<td>
InfoMsg</td>
<td>
pstrInfoMsg</td>
<td>
Returns the last error message generated within this class.</td>
</tr>
<tr valign=top>
<td>
LoginID</td>
<td>
pstrLoginID</td>
<td>
The login id used to login to the data source.</td>
</tr>
<tr valign=top>
<td>
OnServer</td>
<td>
pboolServer</td>
<td>
Are you on a database server or on a local MDB?</td>
</tr>
<tr valign=top>
<td>
Password</td>
<td>
pstrPassword</td>
<td>
The password used to login to the data source.</td>
</tr>
<tr valign=top>
<td>
RecordsAffected</td>
<td>
pintRecords</td>
<td>
The number of records affected by the last action query.</td>
</tr>
<tr valign=top>
<td>
SystemDB</td>
<td>
pstrSystemDB</td>
<td>
The name of the System database for a secured Jet database.</td>
</tr>
<tr valign=top>
<td>
ValidLogon</td>
<td>
pboolValidLogon</td>
<td>
Have you made a valid connection to the database?</td>
</tr>
<tr valign=top>
<td>
UserID</td>
<td>
pstrUserID</td>
<td>
The local MDB. </td>
</tr>
<tr valign=top>
<td>
WSObject</td>
<td>
pws</td>
<td>
The workspace object.</td>
</tr>
</table><br>
<h3>The Public Methods</h3>
<p>
There are some methods that you will need to use to make the connection to the database.  Below is a table listing each of the method names and the description of each:</p>
<table>
<tr valign=top>
<td>
<b>Method Name</b></td>
<td>
<b>Description</b></td>
</tr>
<tr valign=top>
<td>
ConfigGet</td>
<td>
Retrieves information from the registry for this application about the DSN, Database Path, Database Name, and the last LoginID.</td>
</tr>
<tr valign=top>
<td>
ConfigSave</td>
<td>
Saves the information to the registry.</td>
</tr>
<tr valign=top>
<td>
DataClose</td>
<td>
Close the database connection.</td>
</tr>
<tr valign=top>
<td>
DataInit</td>
<td>
Initialize the database engine.</td>
</tr>
<tr valign=top>
<td>
DataOpen</td>
<td>
Opens the database connection.</td>
</tr>
<tr valign=top>
<td>
Execute</td>
<td>
Executes action queries.</td>
</tr>
</table><br>
<h3>Usage of the Database Connection Class</h3>
<p>
To use the database connection class, you need to invoke certain methods at certain times.  Below is a sample of how you would use the Database Connection Class:</p>
<pre><FONT FACE="Courier New" SIZE="2">Dim boolPerform As Boolean

<b>boolPerform = goConnect.ConfigGet()

   
' Initialize the Database Engine
If boolPerform Then
   If Not goConnect.OnServer Then

      boolPerform = goConnect.DataInit()

   End If
End If
   
' Open Connection to Database
If boolPerform Then
   If Not goConnect.OnServer Then

      boolPerform = goConnect.DataOpen()

   End If
Else
   Beep
   MsgBox goConnect.InfoMsg
End If
</b></font></pre>
<p>
You first call the ConfigGet() method to retrieve all the appropriate information from the registry.  You then have to initialize the database engine, and then you can open a connection to the database.</p>
<h3>Retrieving Configuration Information&#45; ConfigGet()</h3>
<p>
The ConfigGet() method will retrieve the base information needed to make a connection to a database.  Below is some of the code for this method:</p>
<pre><FONT FACE="Courier New" SIZE="2">Public Function ConfigGet() As Boolean
   Dim strLoc As String
   Dim vntArray As Variant
   Dim boolPerform As Boolean
   
   On Error GoTo ConfigGet_EH
   

<b>   vntArray = GetAllSettings(App.EXEName, &quot;DataSource&quot;)

   If IsEmpty(vntArray) Then

      frmConfig.Show vbModal

      boolPerform = frmConfig.Saved
   Else
      boolPerform = True
   End If
   
   If boolPerform Then
      ' Get Location of Data Source Info

      strLoc = GetSetting(App.EXEName, _

                          &quot;DataSource&quot;, _

                          &quot;DataLoc&quot;, &quot;&quot;)

      
      ' Get the Database Path
      pstrDBPath = GetSetting(App.EXEName, _
                              strLoc, _
                              &quot;DBPath&quot;, &quot;&quot;)
      
      …
      …
      
      ConfigGet = True
   Else
      ConfigGet = False
   End If
   
   Exit Function
   
ConfigGet_EH:
   ConfigGet = False
   pstrInfoMsg = Err.Description
   plngInfoCode = Err.Number
   Exit Function
End Function
</b></font></pre>
<h3>Initializing the Database&#45;DataInit()</h3>
<p>
You have now seen how to retrieve the majority of the database connection information from the registry. Now you need to use that information to make the connection to the database. DataInit() is the method you will call after calling the ConfigGet() method of the Database Connection Class. The DataInit() method for the Jet engine will initialize the Workspace object. Below is the code for the DataInit() method:</p>
<pre><FONT FACE="Courier New" SIZE="2">Public Function DataInit() As Integer
   On Error GoTo DataInit_EH
      
   If pws Is Nothing Then

<b>      Set pws = DBEngine.CreateWorkspace(&quot;MultiTierApp&quot;, _

                                         pstrLoginID, _

                                         pstrPassword, _

                                         dbUseJet)

      
      DataInit = True
   End If
   
   Exit Function
   
DataInit_EH:
   pboolValidLogon = False
   pstrInfoMsg = Err.Description
   DataInit = False
   Exit Function
End Function
</b></font></pre>
<p>
Notice how you are creating a generic name for this method instead of something like an OpenWorkspace() method. The reason is you want to create a method name that is generic across many different data access methods. In ADO or in RDO, there is no Workspace object. So an OpenWorkspace() method name would not make sense. By using DataInit(), you can write your Sub Main() to call this routine, and if you change the database connection object to use ADO or RDO, you don’t have to change the Sub Main(), just the DataInit() method.</p>
<h3>Opening the Database&#45;DataOpen()</h3>
<p>
After you have initialized the Workspace object, you then attempt to open the connection to the database by opening a database object. The DataOpen() method is called after DataInit() to establish the connection with the database:</p>
<pre><FONT FACE="Courier New" SIZE="2">Public Function DataOpen() As Integer
   Dim strConnect As String
   
   On Error GoTo DataOpen_EH
   
   If pdb Is Nothing Then

      DataOpen = True
      If pboolServer Then

<b>         ' Logon to ODBC Data Source

         strConnect = &quot;ODBC&quot; &amp; Me.ConnectString

         Set pdb = pws.OpenDatabase(&quot;&quot;, False, _

                                    False, strConnect)

      Else

         ' Logon to Local Access Database

         Set pdb = pws.OpenDatabase(pstrDatabase)

      End If

   End If
   DataOpen = True
   pboolValidLogon = True
   
   Exit Function

DataOpen_EH:
   DataOpen = False
   pstrInfoMsg = Err.Description
   pboolValidLogon = False
   Exit Function
End Function
</b></font></pre>
<p>
The above method will either open a local database or make a connection to an ODBC data source. By checking the private variable <i>pboolServer</i>, you can determine which OpenDatabase() method to call. After calling the appropriate routine, you now have a Database object and a Workspace object encapsulated within this object.</p>
<p>
To return the Database object when using this routine, you will use the DBObject property. Below is the Property Get procedure for the DBObject property:</p>
<pre><FONT FACE="Courier New" SIZE="2">Property Get DBObject() As Database
   Set DBObject = pdb
End Property
</font></pre>
<p>
To use this property from anywhere in your source code, you will need to reference the public variable goConnect, then the DBObject property of that object. Below is the code you would use to open a Recordset object:</p>
<pre><FONT FACE="Courier New" SIZE="2">Dim oRS As Recordset
Dim strSQL As String
<BR>strSQL = &quot;SELECT * FROM tblDogs&quot;<BR>
Set oRS = goConnect.DBObject.OpenRecordset(strSQL, _
                                     dbOpenSnapshot)
</font></pre>
<h3>Building a Connect String&#45;ConnectString()</h3>
<p>
In the code for the DataOpen() routine, you will find a call to a method of the Database Connection Class called ConnectString(). This routine will build an ODBC connection string from information in the connection class: </p>
<pre><FONT FACE="Courier New" SIZE="2">Property Get ConnectString() As String
   Dim strConn As String
   
   strConn = strConn &amp; &quot;;DSN=&quot; &amp; pstrDSN
   strConn = strConn &amp; &quot;;UID=&quot; &amp; pstrLoginID
   strConn = strConn &amp; &quot;;PWD=&quot; &amp; pstrPassword
   strConn = strConn &amp; &quot;;Database=&quot; &amp; pstrDatabase
   strConn = strConn &amp; &quot;;WSID=&quot; &amp; App.EXEName &amp; _
                       &quot;(&quot; &amp; pstrLoginID &amp; &quot;)&quot;
   
   ConnectString = strConn
End Property
</font></pre>
<p>
To build the connection string, you will need to know which variables your database server requires. The above connection string will work with SQL Server<font face="Symbol"><span style="font-family:symbol">&#212;</span></font>. Below is an example of what this connection string might look like.</p>
<pre><FONT FACE="Courier New" SIZE="2">DSN=Dogs;UID=sa;PWD=;Database=Dogs;WSID=MultiApp(sa)
</font></pre>
<p>
Notice the use of the WSID at the end of the string. This WorkStation ID is passed to SQL Server so that a system administrator can see which connections are being used by which applications and which users. To see this information, execute the <i>sp_who</i> system procedure in SQL Enterprise Manager.</p>
<h3>Submitting SQL Statements&#45;Execute()</h3>
<p>
Many times you may want to submit an SQL statement such as INSERT, UPDATE, or DELETE. These action queries do not return any values, so you can use the Database objects’ Execute() method. In your connection class, you should encapsulate the Database objects Execute() method so that you can duplicate this functionality for other database access methods. Below is the code for the Execute method of the Database Connection Class:</p>
<pre><FONT FACE="Courier New" SIZE="2">Function Execute(strSQL As String) As Integer
   On Error GoTo Execute_EH

   ' Execute the SQL Statement

<b>   pdb.Execute strSQL

   ' Get number of records affected

   pintRecords = pdb.RecordsAffected


   Execute = True

   Exit Function

Execute_EH:
   Execute = False
   pstrInfoMsg = Err.Description
   plngInfoCode = Err.Number
   Exit Function
End Function
</b></font></pre>
<p>
You will pass in an SQL statement to be executed to this method. It will then perform the SQL and store the number of records affected by the query in the RecordsAffected property of the database connection object. Below is an example of how you might call this routine:</p>
<pre><FONT FACE="Courier New" SIZE="2">…
strSQL = &quot;DELETE FROM tblDogs &quot;
' Submit the SQL Statement

<b>If goConnect.Execute(strSQL) Then

   If goConnect.RecordsAffected = 0 Then

      MsgBox &quot;SQL statement did not change any records&quot;
   End If
End If
…
</b></font></pre>
<p>
If the Execute() method is successful, a True value is returned. However, this does not necessarily mean any records were affected by this query. If you want to see if any records were affected, you need to check the RecordsAffected property.</p>
<h3>Closing the Database&#45;DataClose()</h3>
<p>
When you are finished with a database connection, you should close it. This helps free up some client side and server side resources. Ideally you would open a connection, perform some work, then close the connection. You would constantly be opening, closing, and reopening a connection. However, because of performance, you will generally open a connection one time and leave that connection open. The DataClose() method is what you will use to close the database connection:</p>
<pre><FONT FACE="Courier New" SIZE="2">Public Function DataClose() As Integer
   On Error Resume Next
   
   If Not (pdb Is Nothing) Then
      pdb.Close
      Set pdb = Nothing
   End If
   If Not (pws Is Nothing) Then
      pws.Close
      Set pws = Nothing
   End If
End Function
</font></pre>
<h2>Recordset Class</h2>
<p>
Let’s now create another class to interact with databases called a Recordset Class. Some may think this is unnecessary. After all, Jet already has a Recordset object that you can use. While this is true for Jet, not all database access methods have a Recordset object. Some do not even have objects at all. For example, ADO uses an ADODB.Recordset, but RDO uses a Resultset, and the ODBC API simply uses a long integer. Therefore, you need to build a common Recordset Class that you can wrap all of these methods into so that you don’t have to change any other source code in your system; just this one class.</p>
<h3>Class Name</h3>
<p>
The class name for the Recordset Class is <i>DBRecordset</i>. To create an instance of this class, you would use the following code:</p>
<pre><FONT FACE="Courier New" SIZE="2">Dim oRS As New DBRecordset
</font></pre>
<p>
Let’s now look at some of the standard private variables in this class that you will generally use in each application. You will also see the public interface for these properties and some of the methods of this class.</p>
<h3>The Properties</h3>
<p>
The DBRecordset Class has both private variables and corresponding public properties that are implemented using Property Get and Property Let procedures. Other variables are used internally by the Recordset Class itself. Below is a list of each of the public properties that you will use to reference the data from your recordset object:</p>
<table>
<tr valign=top>
<td>
<b>Public Name</b></td>
<td>
<b>Private Name</b></td>
<td>
<b>Description</b></td>
</tr>
<tr valign=top>
<td>
Connection</td>
<td>
poConnect</td>
<td>
A reference to the DBConnect object stored in the DBRecordset object.</td>
</tr>
<tr valign=top>
<td>
DBObject</td>
<td>
NA</td>
<td>
A reference to the DBConnect.DBObject property.</td>
</tr>
<tr valign=top>
<td>
EOF</td>
<td>
pboolEOF</td>
<td>
Is the Recordset at the end of file?</td>
</tr>
<tr valign=top>
<td>
InfoCode</td>
<td>
plngInfoCode</td>
<td>
Returns the last error code generated within this class.</td>
</tr>
<tr valign=top>
<td>
InfoMsg</td>
<td>
pstrInfoMsg</td>
<td>
Returns the last error message generated within this class.</td>
</tr>
<tr valign=top>
<td>
LockType</td>
<td>
pintLockType</td>
<td>
Return or set the lock type to use for the Recordset object.</td>
</tr>
<tr valign=top>
<td>
Options</td>
<td>
pintOptions</td>
<td>
Return or set the options to use for the Recordset object.</td>
</tr>
<tr valign=top>
<td>
RSType</td>
<td>
pintRSType</td>
<td>
Used to set the type of Recordset.  You may set this to one of the valid Jet Recordset types such as dbOpenSnapshot, dbOpenDynaset, etc.</td>
</tr>
</table><br>
<h3>The Public Methods</h3>
<p>
There are many methods in the DBRecordset Class that you can use to manipulate the Recordset object itself. Below is a table listing each of the method names and the description of each:</p>
<table>
<tr valign=top>
<td>
<b>Method Name</b></td>
<td>
<b>Description</b></td>
</tr>
<tr valign=top>
<td>
BooleanData</td>
<td>
Returns a column that contains a Boolean data type.</td>
</tr>
<tr valign=top>
<td>
CloseRecordset</td>
<td>
Closes an open set of records.</td>
</tr>
<tr valign=top>
<td>
ConcurrencyData</td>
<td>
Returns a column that contains a Single data type.</td>
</tr>
<tr valign=top>
<td>
CurrencyData</td>
<td>
Returns a column that contains a Currency data type.</td>
</tr>
<tr valign=top>
<td>
DateData</td>
<td>
Returns a column that contains a Date data type.</td>
</tr>
<tr valign=top>
<td>
DateStringData</td>
<td>
Returns a column that contains a Date data type, but returns it as a string.</td>
</tr>
<tr valign=top>
<td>
DoubleData</td>
<td>
Returns a column that contains a Double data type.</td>
</tr>
<tr valign=top>
<td>
Find</td>
<td>
Finds a particular row(s) based on an SQL string passed to this method.</td>
</tr>
<tr valign=top>
<td>
IntegerData</td>
<td>
Returns a column that contains a Integer data type.</td>
</tr>
<tr valign=top>
<td>
LongData</td>
<td>
Returns a column that contains a Long data type.</td>
</tr>
<tr valign=top>
<td>
MemoData</td>
<td>
Returns a column that contains a Memo data type.</td>
</tr>
<tr valign=top>
<td>
MoveFirst</td>
<td>
Moves to the first row in the record set.</td>
</tr>
<tr valign=top>
<td>
MoveLast</td>
<td>
Moves to the last row in the record set.</td>
</tr>
<tr valign=top>
<td>
MoveNext</td>
<td>
Moves to the next row in the record set.</td>
</tr>
<tr valign=top>
<td>
MovePrevious</td>
<td>
Moves to the previous row in the record set.</td>
</tr>
<tr valign=top>
<td>
OpenRecordset</td>
<td>
Opens a record set based on an SQL string passed in.</td>
</tr>
<tr valign=top>
<td>
SingleData</td>
<td>
Returns a column that contains a Single data type.</td>
</tr>
<tr valign=top>
<td>
StringData</td>
<td>
Returns a column that contains a String data type.</td>
</tr>
<tr valign=top>
<td>
VarData</td>
<td>
Returns any column as a Variant data type.</td>
</tr>
</table><br>
<h3>Usage of the Recordset Object</h3>
<p>
To use this DBRecordset object, you will first need to declare the object, then you can use it with syntax very similar to Jet.</p>
<pre><FONT FACE="Courier New" SIZE="2">Dim oRS As New <b>DBRecordset
Dim strSQL As String
Dim strName As String
Dim lngID As Long

strSQL = &quot;SELECT szDog_nm, lDog_id FROM tblDogs&quot;

oRS.OpenRecordset(strSQL)

Do Until oRS.EOF

   strName = oRS.StringData()

   lngID = oRS.LongData()

   oRS.MoveNext

Loop

oRS.CloseRecordset
</b></font></pre>
<p>
You can see that this code looks very similar to Jet. However, you have to retrieve the columns in the exact order you specified them in the SELECT statement. This will allow you to use this DBRecordset across all data access methods. If you want to use a new method for accessing data, such as ADO, you only need to change the DBRecordset object, not all of the source code in your project.</p>
<h3>Class Initialization</h3>
<p>
When you create an instance of the DBRecordset Class, the Class_Initialize() event will automatically set the connection object to the value of the global connection object. This can always be overriden if you have another connection object you want to use. It will also assume you want a Snapshot type of Recordset object created:</p>
<pre><FONT FACE="Courier New" SIZE="2">Private Sub Class_Initialize()

<b>   Set poConnect = goConnect

   pintRSType = dbOpenSnapshot
   pintOptions = dbForwardOnly
   pintLockType = dbReadOnly
End Sub
</b></font></pre>
<h3>Opening a Recordset&#45;OpenRecordset()</h3>
<p>
To open a set of records against a specific table, you will need to call the OpenRecordset() method just like you would in Jet. You need to pass in an SQL statement and optionally any record set type, options, and lock type you want. Below is the source code for the OpenRecordset() method:</p>
<pre><FONT FACE="Courier New" SIZE="2">Public Function OpenRecordset(ByVal strSQL As String, _
                      Optional intRSType As Integer = -1, _
                      Optional intOptions As Integer = -1, _
                      Optional intLockType As Integer = -1) _
                               As Boolean
   Dim intStatus As Integer

   On Error GoTo OpenRecordset_EH
   

<b>   ' Reset Column Number

   pintColumn = 0

   
   ' Check Optional Parameters
   If intRSType &lt;&gt; -1 Then
      pintRSType = intRSType
   End If
   If intOptions &lt;&gt; -1 Then
      pintOptions = intOptions
   End If
   If intLockType &lt;&gt; -1 Then
      pintLockType = intLockType
   End If
   
   ' Clear Informational/Error Messages
   Call ClearMessages
   
   ' Open Result Set

   Set poRS = _

       poConnect.DBObject.OpenRecordset(strSQL, _

                                        pintRSType, _

                                        pintOptions, _

                                        pintLockType)


   If poRS.EOF Then
      Call CloseRecordset
      OpenRecordset = False
   Else
      OpenRecordset = True
      pboolRSActive = True
   End If
   
   Exit Function

OpenRecordset_EH:
   pintInfoCode = Err.Number
   pstrInfoMsg = Err.Description
   OpenRecordset = False
   Exit Function
End Function
</b></font></pre>
<p>
Notice how the pintColumn variable is set to 1. This allows you to just call one of the *Data() methods to retrieve the appropriate data type for the 1<sup>st</sup> column.</p>
<h3>Retrieving Column Data&#45;*Data() methods</h3>
<p>
There are many methods that return column data. You may return each column as a specific data type, or you may simply choose to return all columns as a variant. Below are two of the *Data() methods:</p>
<pre><FONT FACE="Courier New" SIZE="2">Public Function VarData(Optional intColumn As Variant) _
                        As Variant
   
   On Error GoTo Var_EH
   

<b>   If Not IsMissing(intColumn) Then

      pintColumn = intColumn

   End If

   
   ' Retrieve Column Data

   VarData = poRS(pintColumn)

   
   ' Increment The Column Number
   pintColumn = pintColumn + 1
   
   Exit Function

Var_EH:
   pintInfoCode = Err.Number
   pstrInfoMsg = Err.Description
   VarData = False
   Exit Function
End Function
</b></font></pre>
<p>
Here is the function to return LongData():</p>
<pre><FONT FACE="Courier New" SIZE="2">Public Function LongData(Optional intColumn As Variant) _
                      As Long
   
   On Error GoTo Long_EH
   

<b>   If Not IsMissing(intColumn) Then

      pintColumn = intColumn

   End If

   
   ' Retrieve The Data

   LongData = Field2Long(poRS(pintColumn))

   
   ' Increment the Column Number
   pintColumn = pintColumn + 1
   
   Exit Function

Long_EH:
   pintInfoCode = Err.Number
   pstrInfoMsg = Err.Description
   LongData = False
   Exit Function
End Function
</b></font></pre>
<h3>Moving the Record Pointer&#45;Move*()</h3>
<p>
There are four methods that you can use to move the record pointer in various directions. MoveNext(), MovePrevious(), MoveFirst(), and MoveLast() are the method names. These are pretty self-explanatory, so let’s just look at a couple:</p>
<pre><FONT FACE="Courier New" SIZE="2">Public Function MoveNext() As Boolean
   Dim intStatus As Integer
   
   MoveNext = False
   
   On Error GoTo MoveNext_EH

   If pboolRSActive Then
      ' Reset Column Number
      pintColumn = 0
      ' Move To Next Row

<b>      poRS.MoveNext

      If Not poRS.EOF Then

         pboolEOF = True
         MoveNext = True
      Else
         pboolEOF = False
         MoveNext = False
      End If
   End If
   
   Exit Function

MoveNext_EH:
   pintInfoCode = Err.Number
   pstrInfoMsg = Err.Description
   pboolEOF = False
   MoveNext = False
   Exit Function
End Function
</b></font></pre>
<p>
Here is the MoveFirst() method:</p>
<pre><FONT FACE="Courier New" SIZE="2">Public Function MoveFirst() As Boolean
   On Error GoTo MoveFirst_EH
   
   If pboolRSActive Then

<b>      poRS.MoveFirst

      MoveFirst = True
   End If
   
   Exit Function
   
MoveFirst_EH:
   pintInfoCode = Err.Number
   pstrInfoMsg = Err.Description
   MoveFirst = False
   Exit Function
End Function
</b></font></pre>
<h3>Closing a Recordset&#45;CloseRecordset()</h3>
<p>
When you are through with a Recordset object, you should always close that record set. Unfortunately, in the Microsoft&reg; Visual Basic&reg; programming system, <b>Close</b>, is a reserved word, and you may not use reserved words for method names. Thus, you will need to name this method CloseRecordset():</p>
<pre><FONT FACE="Courier New" SIZE="2">Public Sub CloseRecordset()
   Dim intStatus As Integer
   
   On Error Resume Next
   
   If pboolRSActive Then
      ' Release Result Set

<b>      poRS.Close

      Set poRS = Nothing

      pboolRSActive = False
   End If
   
   ' Clear Information/Error Messages
   Call ClearMessages
End Sub
</b></font></pre>
<h2>Data Access Template</h2>
<p>
Below is a table of the services our data access classes should accomplish for each of the base tables contained in our database application.</p>
<table>
<tr valign=top>
<td>
<b>Method</b></td>
<td>
<b>Description</b></td>
</tr>
<tr valign=top>
<td>
AddNew</td>
<td>
Performs an INSERT to add a new row to the table.</td>
</tr>
<tr valign=top>
<td>
Check</td>
<td>
Check all the data in the properties prior to saving the data. Returns a True if everything is OK. If something is in error, it will fill in a property with a message describing the error.</td>
</tr>
<tr valign=top>
<td>
CloseRecordSet</td>
<td>
Close the recordset created by this class.</td>
</tr>
<tr valign=top>
<td>
Delete</td>
<td>
Performs a DELETE to remove a row from the table based on the primary key.</td>
</tr>
<tr valign=top>
<td>
DeleteByFilter</td>
<td>
Performs a DELETE to remove a row(s) from the table based on any WHERE filter you specify.</td>
</tr>
<tr valign=top>
<td>
FilterGet</td>
<td>
Returns a WHERE clause to be added to the end of a SELECT or DELETE statement.</td>
</tr>
<tr valign=top>
<td>
Find</td>
<td>
Find a particular row based on the primary key.</td>
</tr>
<tr valign=top>
<td>
FindByFilter</td>
<td>
SELECTs a row(s) from the table based on any WHERE filter you specify.</td>
</tr>
<tr valign=top>
<td>
MoveNext</td>
<td>
Moves to the next row in the recordset.</td>
</tr>
<tr valign=top>
<td>
OpenRecordset</td>
<td>
Opens a recordset for moving through. Can be generated with a particular filter by passing in a specified string.</td>
</tr>
<tr valign=top>
<td>
Replace</td>
<td>
Performs an UPDATE on a row in the table.</td>
</tr>
<tr valign=top>
<td>
Retrieve</td>
<td>
Retrieves the fields from the table and loads properties in the object with the current row in the recordset.</td>
</tr>
<tr valign=top>
<td>
SelectSQL</td>
<td>
Returns the SQL statement that will load all of the columns in the table and create a recordset out of these columns.</td>
</tr>
<tr valign=top>
<td>
SortGet</td>
<td>
Returns an ORDER BY clause to be added to the end of a SELECT statement.</td>
</tr>
</table><br>
<p>
Besides the standard methods that perform actions, you will also have several properties that hold information about the object. These include a reference to a connection object and an instance of the DBRecordset object. A filter name for adding a WHERE clause. A filter name for adding an ORDER BY. A filter name for the SELECT statement to use:</p>
<pre><FONT FACE="Courier New" SIZE="2">' Private Connection and Recordset
Private poConnect As DBConnect
Private poRS As New DBRecordset

' Filters for WHERE, ORDER BY and SELECT
Private pstrFilterName As String
Private pstrSortName As String
Private pstrSelectFilter As String

' For Info &amp; Error Handling Messages
Private pstrInfoMsg As String
Private pintInfoCode As Integer
</font></pre>
<p>
All of the rest of the properties in your data access classes will be unique based on the underlying base table the class is based on. In this section, you will look at a class that deals with a dog information table.</p>
<h3>Dog Class</h3>
<p>
There is a table in our dogs database called <i>tblDogs</i>. This table holds various information about the dog in the application.  Below is the structure for this table:</p>
<table>
<tr valign=top>
<td>
<b>Column Name</b></td>
<td>
<b>Description</b></td>
</tr>
<tr valign=top>
<td>
lDog_id</td>
<td>
Primary key of dog.</td>
</tr>
<tr valign=top>
<td>
szDog_nm</td>
<td>
The name of the dog.</td>
</tr>
<tr valign=top>
<td>
lBreed_id</td>
<td>
Foreign key to breed table.</td>
</tr>
<tr valign=top>
<td>
lBreeder_id</td>
<td>
Foreign key to breeder table.</td>
</tr>
<tr valign=top>
<td>
szColor_nm</td>
<td>
The color of the dog.</td>
</tr>
<tr valign=top>
<td>
sBark_type</td>
<td>
What the dog’s bark sounds like.</td>
</tr>
<tr valign=top>
<td>
cCost_amt</td>
<td>
The cost of the dog.</td>
</tr>
<tr valign=top>
<td>
cPrice_amt</td>
<td>
The selling price of the dog.</td>
</tr>
<tr valign=top>
<td>
dtBirth_dt</td>
<td>
The birth date of the dog.</td>
</tr>
<tr valign=top>
<td>
sSex_nm</td>
<td>
The sex of the dog.</td>
</tr>
<tr valign=top>
<td>
sLastUpdate_id</td>
<td>
Last user to update this row.</td>
</tr>
<tr valign=top>
<td>
dtLastUpdate_dt</td>
<td>
Last date this row was updated.</td>
</tr>
<tr valign=top>
<td>
iConcurrency_id</td>
<td>
Concurrency id.</td>
</tr>
</table><br>
<h3>Properties</h3>
<p>
In our Data Access Class, you will need private variables, and Property Get and Property Let procedures that correspond to each of the column names in the above table. You should use hungarian notation for the private variables, but make meaningful names for the properties.  Below is a table showing each of the columns, public names, and private names:</p>
<table>
<tr valign=top>
<td>
<b>Column Name</b></td>
<td>
<b>Public Properties</b></td>
<td>
<b>Private Variables</b></td>
</tr>
<tr valign=top>
<td>
lDog_id</td>
<td>
DogID</td>
<td>
plngDogID</td>
</tr>
<tr valign=top>
<td>
szDog_nm</td>
<td>
DogName</td>
<td>
pstrDogName</td>
</tr>
<tr valign=top>
<td>
lBreed_id</td>
<td>
BreedID</td>
<td>
plngBreedID</td>
</tr>
<tr valign=top>
<td>
lbreeder_id</td>
<td>
BreederID</td>
<td>
plngBreederID</td>
</tr>
<tr valign=top>
<td>
sColor_nm</td>
<td>
ColorName</td>
<td>
pstrColorName</td>
</tr>
<tr valign=top>
<td>
sBark_type</td>
<td>
BarkType</td>
<td>
pstrBarkType</td>
</tr>
<tr valign=top>
<td>
cCost_amt</td>
<td>
CostAmount</td>
<td>
pcurCostAmount</td>
</tr>
<tr valign=top>
<td>
cPrice_amt</td>
<td>
PriceAmount</td>
<td>
pcurPriceAmount</td>
</tr>
<tr valign=top>
<td>
dtBirth_dt</td>
<td>
BirthDate</td>
<td>
pdtBirthDate</td>
</tr>
<tr valign=top>
<td>
sSex_nm</td>
<td>
Sex</td>
<td>
pstrSex</td>
</tr>
<tr valign=top>
<td>
sLastUpdate_id</td>
<td>
N/A</td>
<td>
pstrLastUpdateID</td>
</tr>
<tr valign=top>
<td>
dtLastUpdate_dt</td>
<td>
N/A</td>
<td>
pdtLastUpdateDt</td>
</tr>
<tr valign=top>
<td>
iConcurrency_id</td>
<td>
N/A</td>
<td>
pintConcurrencyID</td>
</tr>
</table><br>
<h3>OpenRecordset Method</h3>
<p>
The first standard method you will create for your Data Access Class is one that will create a result set of data from our underlying base table. This method will use other properties and methods of the class to perform its job:</p>
<pre><FONT FACE="Courier New" SIZE="2">Public Function OpenRecordset() As Boolean
   Dim strSQL As String

   Screen.MousePointer = vbHourglass

   ' Initialize Variables
   OpenRecordset = False
   pstrInfoMsg = &quot;&quot;
   
   ' Set Connection

<b>   Set poRS.DBObject = poConnect


   ' Build Select Statement

   strSQL = SelectSQL()


   ' Build Recordset Object

   If poRS.OpenRecordset(strSQL) Then

      ' Retrieve the info

      Call Retrieve

      OpenRecordset = True
   Else

      Call CloseRecordset

      OpenRecordset = False
      ' Get Any Error Information

      pstrInfoMsg = poRS.InfoMsg

      pstrInfoCode = poRS.InfoCode

   End If
   
   Screen.MousePointer = vbDefault
End Function
</b></font></pre>
<p>
This method first needs to take the connection object from itself and give it to its DBRecordset object. This will ensure that both this object and the Recordset object are using the same connection. This is only needed if you will be making multiple connections to one or to many different database sources.</p>
<p>
Next, this method will need to create the SELECT statement to create the set of records. You will learn how to build this SELECT statement later.</p>
<p>
After you have the SELECT statement, you can now pass this SELECT statement to the OpenRecordset() method of the DBRecordset object you created. This routine will use the current data access method to create a result set. If the result set is created correctly, a True value will be returned. If it is not created correctly, a False value will be returned. You can then get any error messages and numbers by checking the InfoMsg and InfoCode properties of the DBRecordset object.</p>
<p>
Notice that the OpenRecordset method uses a poConnect object. This is set in the Class_Initialize() for this class to the value of goConnect. There is a Connection property that you may use to override this connection with another connection.</p>
<pre><FONT FACE="Courier New" SIZE="2">Private Sub Class_Initialize()
   Set poConnect = goConnect
End Sub
</font></pre>
<h3>SelectSQL Method</h3>
<p>
The SelectSQL is a private method that will return a SELECT statement based on the SelectFilter property. You can create as many SELECT CASE statements as you want for however many SELECT statements you want to use. Below is the source code for the SelectSQL method:</p>
<pre><FONT FACE="Courier New" SIZE="2">Private Function SelectSQL() As String
   Dim strSQL As String

<b>   Select Case UCase$(pstrSelectFilter)

      Case &quot;LISTBOX&quot;

         strSQL = &quot;SELECT &quot;
         strSQL = strSQL &amp; &quot;lDog_id, &quot;
         strSQL = strSQL &amp; &quot;szDog_nm &quot;
         strSQL = strSQL &amp; &quot;FROM tblDogs &quot;
      

      Case &quot;LISTBREEDLOAD&quot;

         strSQL = &quot;SELECT lDog_id, &quot;
         strSQL = strSQL &amp; &quot;szDog_nm, &quot;
         strSQL = strSQL &amp; &quot;szBreed_nm  &quot;
         strSQL = strSQL &amp; &quot;FROM tblDogs, tblBreed &quot;
         strSQL = strSQL &amp; &quot;WHERE tblDogs.lBreed_id = tblBreed.lBreed_id &quot;

      Case Else

         strSQL = &quot;SELECT &quot;
         strSQL = strSQL &amp; &quot;lDog_id, &quot;
         strSQL = strSQL &amp; &quot;szDog_nm, &quot;
         strSQL = strSQL &amp; &quot;lBreed_id, &quot;
         strSQL = strSQL &amp; &quot;lBreeder_id, &quot;
         strSQL = strSQL &amp; &quot;szColor_nm, &quot;
         strSQL = strSQL &amp; &quot;sBark_type, &quot;
         strSQL = strSQL &amp; &quot;cCost_amt, &quot;
         strSQL = strSQL &amp; &quot;cPrice_amt, &quot;
         strSQL = strSQL &amp; &quot;dtBirth_dt, &quot;
         strSQL = strSQL &amp; &quot;sSex_nm, &quot;
         strSQL = strSQL &amp; &quot;sLastUpdate_id, &quot;
         strSQL = strSQL &amp; &quot;dtLastUpdate_dt, &quot;
         strSQL = strSQL &amp; &quot;iConcurrency_id &quot;
         strSQL = strSQL &amp; &quot;FROM tblDogs &quot;
   End Select

   ' Add Filter To This SELECT Statement

   strSQL = strSQL &amp; FilterGet()


   ' Add Sort To This SELECT Statement

   strSQL = strSQL &amp; SortGet()


   SelectSQL = strSQL
End Function
</b></font></pre>
<p>
After checking the pstrSelectFilter variable (SelectFilter property), a SELECT statement is built. Next the FilterGet() method is called to add any WHERE clause that may have been requested. Finally the SortGet() method is called to add any ORDER BY clause that may have been requested.</p>
<h3>FilterGet() Method</h3>
<p>
The FilterGet() method is another method that can change over time as you decide you need to retrieve your data using different critieria. Below is the code for the FilterGet() method:</p>
<pre><FONT FACE="Courier New" SIZE="2">Private Function FilterGet() As String
   Dim strSQL As String

   ' Select Records using Requested Filter

<b>   Select Case UCase$(pstrFilterName)

      Case &quot;PRIMARYKEY&quot;

         strSQL = strSQL &amp; &quot; WHERE lDog_id = &quot; &amp; plngDogId
      Case &quot;DOGNAME&quot;
         strSQL = strSQL &amp; &quot; WHERE szDog_nm = &quot; &amp; Str2Field(pstrDogName)
      Case &quot;BREEDID&quot;
         strSQL = strSQL &amp; &quot; WHERE lBreed_id = &quot; &amp; plngBreedId
      Case &quot;BREEDID_BREED&quot;
         strSQL = strSQL &amp; &quot; AND tblDogs.lBreed_id = &quot; &amp; plngBreedId
      Case &quot;BREEDERID&quot;
         strSQL = strSQL &amp; &quot; WHERE lBreeder_id = &quot; &amp; plngBreederId
      Case &quot;&quot;
         ' Do Nothing
      Case Else
         MsgBox &quot;clsDogs Can't Find Filter Passed: &quot; &amp; pstrFilterName
   End Select

   FilterGet = strSQL
End Function
</b></font></pre>
<p>
You may use this method for WHERE clauses for SELECTs or DELETEs. You can create any WHERE clause you want within each CASE statement.</p>
<h3>SortGet() method</h3>
<p>
The SortGet() method is a method you can modify as you decide you need additional ordering of your result sets. Below is the code for the SortGet() method:</p>
<pre><FONT FACE="Courier New" SIZE="2">Private Function SortGet() As String
   Dim strSQL As String

   ' Add ORDER BY

<b>   Select Case UCase$(pstrSortName)

      Case &quot;DOGNAME&quot;

         strSQL = strSQL &amp; &quot; ORDER BY szDog_nm&quot;
   End Select

   SortGet = strSQL
End Function
</b></font></pre>
<h3>MoveNext() Method</h3>
<p>
The MoveNext() method is used to move to the next row in the result set, then call the Retrieve() method to load the current row of the result set into the private variables in the object. This method returns a False when the end of the file is hit:</p>
<pre><FONT FACE="Courier New" SIZE="2">Public Function MoveNext() As Boolean
   ' Move to Next Record

<b>   If poRS.MoveNext() Then

      ' Load Properties

      Call Retrieve

      MoveNext = True
   Else
      MoveNext = False
      Call CloseRecordset
      pstrInfoMsg = poRS.InfoMsg
   End If
End Function
</b></font></pre>
<p>
The first call is to the DBRecordset object to have it move to the next row in the result set. If this method returns a True value, then the Retrieve() method is called to take the data from the result set and move it into the private variables.</p>
<h3>Retrieve() Method</h3>
<p>
The retrieve method will use the SelectFilter filter in conjunction with the SelectSQL() method. The number of columns you are selecting must match the number of columns you are retrieving. If you change your SELECT statement, you must remember to change your retrieval method also:</p>
<pre><FONT FACE="Courier New" SIZE="2">Private Sub Retrieve()
   With poRS

<b>      Select Case UCase(pstrSelectFilter)

         Case &quot;LISTBOX&quot;

            plngDogId = .LongData()
            pstrDogName = .StringData()
         

         Case &quot;LISTBREEDLOAD&quot;

            plngDogId = .LongData()
            pstrDogName = .StringData()
            pstrBreedName = .StringData()
   

         Case Else

            plngDogId = .LongData()
            pstrDogName = .StringData()
            plngBreedId = .LongData()
            plngBreederId = .LongData()
            pstrColorName = .StringData()
            pstrBarkType = .StringData()
            pcurCostAmount = .CurrencyData()
            pcurPriceAmount = .CurrencyData()
            pstrBirthDate = .StringData()
            pstrSex = .StringData()
            pstrLastUpdateId = .StringData()
            pstrLastUpdateDate = .StringData()
            pintConcurrencyId = .ConcurrencyData()
      End Select
   End With
End Sub
</b></font></pre>
<p>
Notice that this method retrieves the data from the DBRecordset object. It retrieves each column in the order specified in the SELECT and uses the appropriate method of the DBRecordset object to retrieve the data type. Be sure to always retrieve the columns in the exact order you specified them in the SELECT statement. Doing this ensures that you can choose any data access method you want. The reason for this is the ODBC API must retrieve columns in the exact order in which you specified them in the SELECT statement.</p>
<h3>Find() Method</h3>
<p>
This method will create a result set based on the primary key filter. You must be sure to fill in the primary key property of your object prior to calling the Find() method. Find simply sets the SelectFilter property to “PRIMARYKEY” prior to calling the FindByFilter() method:</p>
<pre><FONT FACE="Courier New" SIZE="2">Public Function Find() As Boolean
   Dim strOldFilter As String

   ' Set Filter For Retrieving One Row

<b>   strOldFilter = pstrFilterName

   pstrFilterName = &quot;PRIMARYKEY&quot;


   Find = FindByFilter()

   
   ' Reset The Filter
   pstrFilterName = strOldFilter
End Function
</b></font></pre>
<p>
<b>Note</b>&nbsp;&nbsp;&nbsp;Find will always return only one row.</p>
<h3>FindByFilter() Method</h3>
<p>
This method is called whenever you want to retrieve a result set based on a FilterName and some property or properties. The idea is if you want to find all dogs by a certain breed, you would fill in the BreedID property, then fill in the FilterName property with a string that defines a WHERE clause in the FilterGet() method:</p>
<pre><FONT FACE="Courier New" SIZE="2">Public Function FindByFilter() As Boolean
   ' Build Recordset &amp; Retrieve Data

<b>   If OpenRecordset() Then

      FindByFilter = True
   Else
      Call CloseRecordset
      FindByFilter = False
   End If
End Function
</b></font></pre>
<p>
Of course you could always just call the OpenRecordset() method.</p>
<h3>Check() Method</h3>
<p>
Business rules must be enforced for all of your data. For example, in our Dog Class you should create a rule that no dog record can be saved unless there is a Dog’s Name filled in, and if a birth data is filled in, that it is a valid date. All of these business rules should go into a method called Check(). Below is an example of a Check() method for the Dog Class:</p>
<pre><FONT FACE="Courier New" SIZE="2">Public Function Check() As Boolean
   Check = False

<b>   If Trim$(pstrDogName) = &quot;&quot; Then

      pstrInfoMsg = &quot;Dog Name must be filled in.&quot;

   ElseIf Trim$(pstrBirthDate) &lt;&gt; &quot;&quot; Then

      If Not IsDate(pstrBirthDate) Then

         pstrInfoMsg = &quot;Birth Date is an invalid date&quot;
      Else
         Check = True
      End If
   Else
      Check = True
   End If
End Function
</b></font></pre>
<p>
The Check method is called from both the AddNew() and Replace() methods in our Dog Class. This ensures that the rules are always checked prior to saving the data to the base table. Notice that no message boxes are displayed from this routine. It simply returns a True or False value. If anything is in error, the InfoMsg property is filled in with an error message that the user can print out using their client software.</p>
<h3>AddNew() Method</h3>
<p>
The AddNew method is responsible for inserting a new row into the base table. You will need to decide if you will be using an Identity or AutoNumber type of field for the primary key or not. If you are, then you do not need to include the primary key in the INSERT. If you are not, then you will need to write a routine to generate a unique ID for each table.</p>
<pre><FONT FACE="Courier New" SIZE="2">Public Function AddNew() As Boolean
   Dim strSQL As String

   AddNew = False

   Screen.MousePointer = vbHourglass

   ' Check Business Rules and Duplicate Values First

<b>   If Check() Then

      strSQL = &quot;INSERT INTO tblDogs (&quot;

      strSQL = strSQL &amp; &quot;szDog_nm, &quot;
      strSQL = strSQL &amp; &quot;lBreed_id, &quot;
      strSQL = strSQL &amp; &quot;lBreeder_id, &quot;
      strSQL = strSQL &amp; &quot;szColor_nm, &quot;
      strSQL = strSQL &amp; &quot;sBark_type, &quot;
      strSQL = strSQL &amp; &quot;cCost_amt, &quot;
      strSQL = strSQL &amp; &quot;cPrice_amt, &quot;
      strSQL = strSQL &amp; &quot;dtBirth_dt, &quot;
      strSQL = strSQL &amp; &quot;sSex_nm, &quot;
      strSQL = strSQL &amp; &quot;sLastUpdate_id, &quot;
      strSQL = strSQL &amp; &quot;dtLastUpdate_dt, &quot;
      strSQL = strSQL &amp; &quot;iConcurrency_id &quot;
      strSQL = strSQL &amp; &quot;) VALUES (&quot;
      strSQL = strSQL &amp; Str2Field(pstrDogName) &amp; &quot;, &quot;
      strSQL = strSQL &amp; plngBreedId &amp; &quot;, &quot;
      strSQL = strSQL &amp; plngBreederId &amp; &quot;, &quot;
      strSQL = strSQL &amp; Str2Field(pstrColorName) &amp; &quot;, &quot;
      strSQL = strSQL &amp; Str2Field(pstrBarkType) &amp; &quot;, &quot;
      strSQL = strSQL &amp; pcurCostAmount &amp; &quot;, &quot;
      strSQL = strSQL &amp; pcurPriceAmount &amp; &quot;, &quot;
      strSQL = strSQL &amp; Date2Field(pstrBirthDate) &amp; &quot;, &quot;
      strSQL = strSQL &amp; Str2Field(pstrSex) &amp; &quot;, &quot;
      strSQL = strSQL &amp; Str2Field(poConnect.LoginID) &amp; &quot;, &quot;
      strSQL = strSQL &amp; Date2Field(Date) &amp; &quot;, 1) &quot;

      ' Submit the SQL Statement

      If poConnect.Execute(strSQL) Then

         If poConnect.RecordsAffected = 1 Then

            AddNew = True
         Else
            AddNew = False
         End If
      Else

         pstrInfoMsg = poConnect.InfoMsg

         AddNew = False
      End If
   End If

   Screen.MousePointer = vbDefault
End Function
</b></font></pre>
<p>
The INSERT statement is submitted to the database using the connection object’s Execute() method. After this routine returns a True value, you can check the RecordsAffected property to determine if one row was added. If the Execute() method fails, you can retrieve any error information from the connection object.</p>
<h3>Replace Method</h3>
<p>
The Replace method is very similar to the AddNew() method.  It will build an UPDATE statement using the data in the properties of the class, then submit that statement to the database for processing:</p>
<pre><FONT FACE="Courier New" SIZE="2">Public Function Replace() As Boolean
   Dim strSQL As String

   Screen.MousePointer = vbHourglass

<b>   If Check() Then

      strSQL = &quot;UPDATE tblDogs SET &quot;

      strSQL = strSQL &amp; &quot;szDog_nm = &quot; &amp; Str2Field(pstrDogName) &amp; &quot;, &quot;
      strSQL = strSQL &amp; &quot;lBreed_id = &quot; &amp; plngBreedId &amp; &quot;, &quot;
      strSQL = strSQL &amp; &quot;lBreeder_id = &quot; &amp; plngBreederId &amp; &quot;, &quot;
      strSQL = strSQL &amp; &quot;szColor_nm = &quot; &amp; Str2Field(pstrColorName) &amp; &quot;, &quot;
      strSQL = strSQL &amp; &quot;sBark_type = &quot; &amp; Str2Field(pstrBarkType) &amp; &quot;, &quot;
      strSQL = strSQL &amp; &quot;cCost_amt = &quot; &amp; pcurCostAmount &amp; &quot;, &quot;
      strSQL = strSQL &amp; &quot;cPrice_amt = &quot; &amp; pcurPriceAmount &amp; &quot;, &quot;
      strSQL = strSQL &amp; &quot;dtBirth_dt = &quot; &amp; Date2Field(pstrBirthDate) &amp; &quot;, &quot;
      strSQL = strSQL &amp; &quot;sSex_nm = &quot; &amp; Str2Field(pstrSex) &amp; &quot;, &quot;
      strSQL = strSQL &amp; &quot;sLastUpdate_id = &quot; &amp; _
                          Str2Field(poConnect.LoginID) &amp; &quot;, &quot;
      strSQL = strSQL &amp; &quot;dtLastUpdate_dt = &quot; &amp; Date2Field(Date) &amp; &quot;, &quot;
      If pintConcurrencyId = -1 Then
         strSQL = strSQL &amp; &quot;iConcurrency_id = 1 &quot;
      Else
         strSQL = strSQL &amp; &quot;iConcurrency_id = iConcurrency_id + 1 &quot;
      End If
      strSQL = strSQL &amp; &quot; WHERE &quot;
      strSQL = strSQL &amp; &quot;lDog_id = &quot; &amp; plngDogId &amp; &quot; &quot;
      If pintConcurrencyId = -1 Then
         strSQL = strSQL &amp; &quot; AND iConcurrency_id = Null&quot;
      Else
         strSQL = strSQL &amp; &quot; AND iConcurrency_id = &quot; &amp; pintConcurrencyId
      End If

      ' Submit the SQL Statement

      If poConnect.Execute(strSQL) Then

         If poConnect.RecordsAffected = 1 Then

            Replace = True
            If pintConcurrencyId = -1 Then
               pintConcurrencyId = 1
            Else
               pintConcurrencyId = pintConcurrencyId + 1
            End If
         Else
            Replace = False
            pstrInfoMsg = poConnect.InfoMsg &amp; _
                          vbCrLf &amp; &quot;Could Not Update This Table: tblDogs &quot;
         End If
      Else
         Replace = False
      End If
   End If

   Screen.MousePointer = vbDefault
End Function
</b></font></pre>
<p>
The UPDATE statement is submitted using the Execute() method of the connection object. You then check the RecordsAffected property to see if one row was updated. If it was, you know that the update was successful. If not, then you know it was not, and you can return error information.</p>
<h3>Multiple User Considerations</h3>
<p>
When performing updates on data, you must be careful not to overwrite other people’s changes. Take the example where two people read the same record at the same time. If User 1 replaces the information first, User 2 still has the old data in their memory. If User 2 updates that information, the changes from User 1 will be lost.</p>
<p>
To stop this from happening, you must have some mechanism to determine if the data has changed prior to performing an update. There are several techniques to make this happen. First you could reread the data from the table and compare field by field to an old copy of the original data. If any one field has changed, you know someone else has updated the row.</p>
<p>
Another method is to use a TimeStamp. This is a special type of field that is updated by the database server everytime, and UPDATE is performed on a row. Unfortunately, not all database servers support this, and ISAM file systems such as Microsoft Access or dBase do not have this capability at all.</p>
<p>
Knowing this, you need to devise some method of keeping track of when something changes.</p>
<p>
A method that has worked very succssfully at our shop is to add one column to every table called <i>iConcurrency_id</i>. This is an Integer type that starts at the value 1 and will be incremented every time you perform an UPDATE. Unfortunately, you must take care of updating this value yourself. Look at the Replace() method you wrote earlier. In the UPDATE statement, you wrote the following:</p>
<pre><FONT FACE="Courier New" SIZE="2">…

<b>If pintConcurrencyId = -1 Then

   strSQL = strSQL &amp; &quot;iConcurrency_id = 1 &quot;
Else
   strSQL = strSQL &amp; &quot;iConcurrency_id = iConcurrency_id + 1 &quot;
End If
strSQL = strSQL &amp; &quot; WHERE &quot;
strSQL = strSQL &amp; &quot;lDog_id = &quot; &amp; plngDogId &amp; &quot; &quot;
If pintConcurrencyId = -1 Then
   strSQL = strSQL &amp; &quot; AND iConcurrency_id = Null&quot;
Else
   strSQL = strSQL &amp; &quot; AND iConcurrency_id = &quot; &amp; pintConcurrencyId

End If
</b></font></pre>
<p>
First you check to see if the concurrency id is equal to –1. This means that it was a Null. If the value is Null, you want to set the concurrency id to 1 Otherwise, you increment the concurrency id by one. Now take the scenario presented above. If User 1 and User 2 both read the same row at the same time, they both read the same value for the concurrency id.</p>
<p>
Say the value was a 1, then User 1 updates the row. The concurrency id is now equal to 2. User 2 still has the value of a 1 in their memory. When they attempt the update, the WHERE clause says to to check for where the concurrency id is equal to the value in User 2’s private variable pintConcurrencyId. This value is a 1. This means that the UPDATE statement will not find any rows, so the update will not take place. User 2 will receive 0 rows in the RecordsAffected property, which will signal that another user has updated the data before them. User 2 should then refresh their data to get User 1’s updated data.</p>
<h3>Delete() Method</h3>
<p>
The Delete() method will delete a row from the base table based on the primary key. Only one row will be deleted from the table. You need to fill in the primary key property with the value of the row you want to delete:</p>
<pre><FONT FACE="Courier New" SIZE="2">Public Function Delete() As Boolean
   Dim strOldFilter As String

   Screen.MousePointer = vbHourglass

   ' Set Filter Name
   strOldFilter = pstrFilterName

<b>   pstrFilterName = &quot;PRIMARYKEY&quot;


   Delete = DeleteByFilter()

   If poConnect.RecordsAffected = 1 Then

      Delete = True
   Else
      Delete = False
   End If

   ' Reset The Filter
   pstrFilterName = strOldFilter

   Screen.MousePointer = vbDefault
End Function
</b></font></pre>
<p>
You can see that this method simply sets a filter to “PRIMARYKEY,” then calls the DeleteByFilter() method. It then checks the connection object’s RecordsAffected property to see if a 1 is returned. If a 1 is returned, then you know the row was deleted.</p>
<h3>DeleteByFilter() Method</h3>
<p>
This method is called whenever you want to delete a set of rows based on a FilterName and some property or properties. The idea is if you want to delete all dogs by a certain breed, you would fill in the BreedID property, then fill in the FilterName property with a string that defines a WHERE clause in the FilterGet() method:</p>
<pre><FONT FACE="Courier New" SIZE="2">Public Function DeleteByFilter() As Boolean
   Dim strSQL As String

   Screen.MousePointer = vbHourglass

   ' Setup Delete SQL

<b>   strSQL = &quot;DELETE FROM tblDogs &quot;


   ' Get The WHERE Clause for the DELETE statement
   ' Using the Existing Filter

   strSQL = strSQL &amp; FilterGet()


   ' Submit the SQL Statement

   If poConnect.Execute(strSQL) Then

      DeleteByFilter = True
   Else
      pstrInfoMsg = poConnect.InfoMsg
      DeleteByFilter = False
   End If
   
   Screen.MousePointer = vbDefault
End Function
</b></font></pre>
<h3>CloseRecordset Method</h3>
<p>
When you are finished with the object, you should always close the recordset that was generated. The CloseRecordset method is used to close the recordset:</p>
<pre><FONT FACE="Courier New" SIZE="2">Public Sub CloseRecordset()
   If pboolRSActive Then
      poRS.Close
      pboolRSActive = False
   End If
End Sub
</font></pre>
<p>
In fact, this method is called from the Class_Terminate() event. This handles the case where the object goes out of scope and the CloseRecordset method was not called:</p>
<pre><FONT FACE="Courier New" SIZE="2">Private Sub Class_Terminate()
   Call CloseRecordset
End Sub
</font></pre>
<h2>Changing the Database Access Method</h2>
<p>
This next section will present Database Connection Classes and Recordset Classes for different data access methods. The idea is to build a set of classes using different data access methods that you can plug into your application. This means you can swap your data access method at any time and not have to rewrite your application.</p>
<h2>Database Connection Class&#45;ODBCDirect</h2>
<p>
You are already familiar with the Database Connection Class for Jet. The connection class for ODBCDirect is very similar to this. Let’s look at where the changes have been made in this class so that you can get an idea of how to create additional Database Connection Classes as you need them.</p>
<h3>Class Name &amp; Public Interface</h3>
<p>
The name of this database class is <b>STILL</b> DBConnect. You never want to change the name of the Class or any of the public interface. You can modify the private interface all you want as long as the functionality remains the same.</p>
<h3>The Private Interface</h3>
<p>
There is just one change to make to the private variables for the ODBCDirect Connection Class. Instead of a Database object, you need to use a Connection object:</p>
<pre><FONT FACE="Courier New" SIZE="2">Private poConn As Connection
</font></pre>
<h3>The Public Properties</h3>
<p>
There is only one public property that needs to change to implement ODBCDirect. First is the Property Get procedure for the DBObject. This property returns a reference to the connection object. In the case of Jet, it was a Database object. For ODBCDirect, it is a Connection object. Below is the code for the DBObject() property:</p>
<pre><FONT FACE="Courier New" SIZE="2">Property Get DBObject() As Connection

<b>   Set DBObject = poConn

End Property
</b></font></pre>
<h3>The Public Methods</h3>
<p>
The major changes for converting to a new database access method will occur in the public methods you created for this class. Specifically, the DataInit and DataOpen methods will need to be rewritten for ODBCDirect. Below are the samples for each one of these methods.</p>
<h3>Initializing the Database&#45; DataInit()</h3>
<p>
The DataInit() method is similar to the Jet engine version except the last parameter passed to the CreateWorkspace() method is to use ODBCDirect instead of Jet.</p>
<pre><FONT FACE="Courier New" SIZE="2">Public Function DataInit() As Integer
   On Error GoTo DataInit_EH
   
   If pws Is Nothing Then

<b>      Set pws = _

          DBEngine.CreateWorkspace(&quot;MultiTierODBCDirect&quot;, _

                                   &quot;sa&quot;, &quot;&quot;, _

                                   dbUseODBC)

   End If
   
   DataInit = True
   
   Exit Function
   
DataInit_EH:
   pboolValidLogon = False
   pstrInfoMsg = Err.Description
   plngInfoCode = Err.Number
   DataInit = False
   Exit Function
End Function
</b></font></pre>
<h3>Opening the Database&#45;DataOpen()</h3>
<p>
In the DataOpen() method, you will need to open a Connection object instead of a Database object as in Jet:</p>
<pre><FONT FACE="Courier New" SIZE="2">Public Function DataOpen() As Integer
Dim strOldMsg As String
   
   On Error GoTo DataOpen_EH
   
   ' Display Status Message
   strOldMsg = StatusProcess(&quot;Opening Database...&quot;)
   
   DataOpen = True
   

<b>   ' Open the Connection Object

   strConnect = &quot;ODBC&quot; &amp; Me.ConnectString

   Set poConn = _

       pws.OpenConnection(&quot;&quot;, _

                          dbDriverNoPrompt, _

                          False, _

                          strConnect)


   pboolOpen = True
   
   Call StatusRestore(strOldMsg)
   
   DataOpen = True
   pboolValidLogon = True
   
   Exit Function

DataOpen_EH:
   DataOpen = False
   pstrInfoMsg = Err.Description
   plngInfoCode = Err.Number
   pboolValidLogon = False
   Exit Function
End Function
</b></font></pre>
<h2>Recordset Class&#45;ODBCDirect</h2>
<p>
The Recordset Class for ODBCDirect is <b>exactly the same</b> as the Jet engine. The only difference is in the types of Recordset objects you can create. You are a little more limited on the range of Recordset objects you can create.</p>
<h3>Creating Code Components</h3>
<p>
Have you ever wanted an easy way to use just a portion of your application from a Microsoft Office application? Or maybe you needed to use some of it from a Microsoft C++ application. By creating an ActiveX<font face="Symbol"><span style="font-family:symbol">&#212;</span></font> code component (formerly OLE Server) as a component, you are able to expose objects from your server to another application. The best part is you can use this server as just a normal application also.</p>
<p>
These code components are a core part of creating a multi-tier architecture. Learning to create code components that are exposed in a server is actually quite simple. In this chapter, you will learn how to create servers that can be called from many different applications.</p>
<h3>ActiveX Code Components</h3>
<p>
Probably the most exciting technology added to Visual Basic is the ability to create ActiveX code components. By building class modules and exposing properties and methods, you can create an application that has the ability to be called from any client application. You can create both in-process (DLLs) and out-of-process (EXE) code components. Using this technology, you can easily build a multi-tier client/server architecture.</p>
<p>
Another feature of the code component is the ability to run the code component on any workstation in your network. This means you can put your business rules and data access routines on one very powerful machine, and all of your users can simply use the CPU of this other machine to perform the validation and data manipulation routines.</p>
<h2>Creating a Simple Code Component</h2>
<p>
Let’s now walk step by step through the creation of a simple code component. You will create a Dog object that has two properties; Bark and Name. You will then create one method for this Dog object called BarkTheDog. This method will simply return a string that tells the dog’s name and what type of bark the dog has.</p>
<p>
<b>Sample File Name: AutoDog.vbp</b>
<ol>
<li>
Start Visual Basic version 5.0.<br><br></li>
<li>
Select ActiveX EXE from the list of project templates.<br><br></li>
<li>
Press F4 to bring up the Properties window.<br><br></li>
<li>
Set the Name Property to Dog.<br><br></li>
<li>
Set the Instancing Property to 6 - GlobalMultiUse.<br><br></li>
<li>
Add the following private variables to the (General) (Declarations) area of this Class:<pre><FONT FACE="Courier New" SIZE="2">Option Explicit

Private pstrName As String
Private pstrBark As String
</font></pre>
</li>
</ol>
<h3>Read Properties</h3>
<p>
After creating the private variables, you now need to create a couple of Property Get procedures so that you can read the data in each of these private variables:</p>
<pre><FONT FACE="Courier New" SIZE="2">Property Get Name() As String
   Name = pstrName
End Property

Property Get Bark() As String
   Bark = pstrBark
End Property
</font></pre>
<h3>Class Initialization</h3>
<p>
To keep things simple, you should just default the private variables to some values. Enter the following code in the Class_Initialize event:</p>
<pre><FONT FACE="Courier New" SIZE="2">Private Sub Class_Initialize()
   pstrName = &quot;Rusty&quot;
   pstrBark = &quot;Howl&quot;
End Sub
</font></pre>
<p>
When the object is instantiated, the above code will fill in the values for this object.</p>
<h3>Bark the Dog Method</h3>
<p>
Let’s create a method that will return the Dog’s name and bark. You will create a string that can be displayed in any front end:</p>
<pre><FONT FACE="Courier New" SIZE="2">Public Function BarkTheDog() As String
   Dim strMsg As String
   

<b>   strMsg = &quot;My Name is &quot; &amp; pstrName &amp; vbCrLf

   strMsg = strMsg &amp; &quot; and I can &quot; &amp; pstrBark

   

   BarkTheDog = strMsg

End Function
</b></font></pre>
<h3>Creating the Server</h3>
<p>
Now that all the pieces are filled in, you should fill in some project attributes so that you can identify this server by a meaningful name and a description:
<ol>
<li>
Select <u>P</u>roject, Project1 Prop<u>e</u>rties… from the menu.<br><br></li>
<li>
Set the Project <u>N</u>ame to <b>AutoDog</b>. This will become the name of your code component.<br><br></li>
<li>
Set the <u>P</u>roject Description to “Automation Server For Dog Object.” This will be the name that will show up in the References section of any client application that needs to use this class.</li>
</ol>
<p>
Your screen should look something like the following:</p>
<p>
<img src="dat403-2ef_1.gif" border=0></p>
<p>
When you are finished, click the OK button to save the changes. At this point you should save your project.</p>
<h3>Run the Server</h3>
<p>
Now run this project. The application will appear to start and will be in run mode, but will not do anything.</p>
<h3>Testing the Server</h3>
<p>
To test this code component, follow the steps below:
<ol>
<li>
Open another instance of Visual Basic.<br><br></li>
<li>
Select the Standard EXE option from the list of project templates.<br><br></li>
<li>
Add a Command button to the form in the project.<br><br></li>
<li>
Double-click on the Command button to bring up the code window.<pre><FONT FACE="Courier New" SIZE="2">Private Sub Command1_Click()
    Dim oDog As New Dog
    
    MsgBox oDog.BarkTheDog
End Sub
</font></pre>
</li>
</ol>
<p>
Of course, this instance of Visual Basic does not know what a Dog object is, so you need to tell it where to find the server that has this type of object. Follow the steps below to specify the reference to the server:
<ol>
<li>
Select <u>P</u>roject, Refere<u>n</u>ces from the menu.<br><br></li>
<li>
Find the Available Reference named “Automation Server For Dog Object” and select it. This is our code component that is running in the other instance of Visual Basic.<br><br></li>
<li>
Press the OK button.<br><br></li>
<li>
Run the project and click on the Command button. If everything went OK, you should see the following Message Box:<p>
<img src="dat403-2ef_2.gif" border=0></p>
</li>
</ol>
<p>
Congratulations!  You have created your first code component in Visual Basic.</p>
<h3>Running from Microsoft Excel</h3>
<p>
Let’s now test our code component from Microsoft Excel.  To accomplish this, follow the steps below:
<ol>
<li>
Start your code component in Visual Basic Design Mode.<br><br></li>
<li>
Start up Microsoft Excel version 5.<br><br></li>
<li>
Type in the code below.<pre><FONT FACE="Courier New" SIZE="2">Sub Test()
   Dim oDog As New Dog
   
   MsgBox <b>oDog.BarkTheDog
End Sub
</b></font></pre>
</li>
</ol>
<p>
There are actually two methods for calling a code component. The above method uses a technique called early binding. The code below will use a technique called late binding:</p>
<pre><FONT FACE="Courier New" SIZE="2">Sub Test()

<b>   Dim oDog As Object

   
   Set oDog = CreateObject(&quot;AutoDog.Dog&quot;)
   
   MsgBox oDog.BarkTheDog
End Sub
</b></font></pre>
<p>
Notice how you just declared the oDog variable to be of the generic type <b>Object</b>. You then must use the CreateObject() function and pass as a paramter the name of the server and the name of the Class inside that server from which you want to create an object.</p>
<h2>Binding</h2>
<p>
In the examples used in the previous section, we used two different kinds of binding techniques; early and late. Early binding means you have explicitly declared a code component name and a specific object in that code component in a Dim statement. For example:</p>
<pre><FONT FACE="Courier New" SIZE="2">     Dim oDog As New AutoDog.Dog
</font></pre>
<p>
Since you have explicitly stated the name of the server and the object within that server you are using early binding.</p>
<p>
With late binding, you are waiting until run time to determine the object that will be loaded, and what server will be used. To use late binding, you must use the CreateObject() method.</p>
<pre><FONT FACE="Courier New" SIZE="2">Dim oDog As Object
    
Set oDog = CreateObject(&quot;AutoDog.Dog&quot;)
</font></pre>
<p>
The CreateObject() method will access the system registry at run time to find out which code component to run.</p>
<h3>Reasons for Binding</h3>
<p>
There are different reasons why you may want to use late binding versus early binding or vice versa. Early binding is much faster, but this also means that if you change your code component and you change something in this version, it could cause your client application to fail.</p>
<p>
Late binding is slower, but if you change the version of your code component, your application may still continue to run, as long as the properties and methods are still compatible.</p>
<h3>Registering and Unregistering</h3>
<p>
To register a code component after making an .EXE file, locate the file in File Manager, and double-click on the .EXE file. Visual Basic adds start-up code to any .EXE you make that has objects in it with the Public property set to true. This code tells Visual Basic to create registry entries for all exposed objects. Double-clicking on the code component does not start the code component.</p>
<p>
Code components are only started at the request of another application and unloaded when all references to them are destroyed. Entries for your code components are contained under the HKEY_CLASSES_ROOT hive. The registered objects will all have a prefix of the Project Name you entered under the <u>P</u>roject, Prop<u>e</u>rties.., General tab.</p>
<p>
To unregister a code component from the registry, run the .EXE file with the /U command line option.</p>
<h3>Data Access Code Component</h3>
<p>
Active code components may be used in two ways: either through Automation or by embedding an object in a Visual Basic form and using Visual Basic as the Active Container. Using Visual Basic, you can create code components that can be controlled through Automation.</p>
<p>
So the question becomes, what kind of code component would you build using Visual Basic that can be useful to other programs? One of the best examples is a multi-tier client/server application. This type of architecture is based on having your user interface as one .EXE, all of the business rules and data access routines as a separate .EXE or .DLL (a code component), and the database engine as the third level. Other uses of code components are specialized applications like Microsoft Excel, or a drawing package like Visio.</p>
<p>
<b>Master</b>&nbsp;&nbsp;&nbsp;<b>Note: </b>You must have Visual Basic 5.0 Professional Edition or Enterprise Edition to run this sample.</p>
<p>
<b>BARK server</b></p>
<p>
Let’s now take the BARK application that you created earlier and separate the data access classes from the user interface. The idea is you will create two separate project files that each have different pieces of the complete BARK application in it. One project will have the CLS files and some .BAS files (the server), while the other will have the FRM files and some .BAS files, but no CLS files (the client).</p>
<p>
Once you have created these two projects, you need to create an EXE out of the Server, then close that instance of Visual Basic. Next you load the client and, using the early binding technique shown earlier, set a reference to the Dog server.</p>
<p>
Sample project files: DogServ.vbp and DogClient.vbp</p>
<p>
<b>Steps to run the code component:</b>
<ol>
<li>
Open the project dogserv.vbp and run the project.<br><br></li>
<li>
Open the project dogclient.vbp.<br><br></li>
<li>
Set a reference to the “Server for BARK Application” in the <u>P</u>roject, Refere<u>n</u>ces…<br><br></li>
<li>
Run the project.<br><br></li>
<li>
You should now have the Dogs application running against the code component.</li>
</ol>
<p>
The reason the objects from the data access classes are available is because of the reference that was set to the “Server for BARK Application.” If you stop the other instance of Visual Basic from running, then return to this instance, you should not see this reference anymore. What happens is that Visual Basic temporarily registers the code component so that other applications can see it. When you end the program, Visual Basic cleans up the registry.</p>
<p>
<b>Using the code component from Microsoft Excel</b></p>
<p>
Now that you have made a real code component out of the BARK application, you can use this code component from any application that supports Automation. Let’s call our Dog object from Microsoft Excel and create a list of dogs in the spreadsheet.
<ol>
<li>
To begin, you can open <b>bark.xls</b> in Microsoft Excel. <br><br></li>
<li>
Click on the Command button to load the list of dogs and their birth dates.<p>
<img src="dat403-2ef_3.gif" border=0></p>
</li>
</ol>
<p>
Here is the VBA code you will write in Microsoft Excel:</p>
<pre><FONT FACE="Courier New" SIZE="2">Private Sub cmdLoad_Click()

<b>   Dim oApp As New DogServer.Application

   Dim oDog As New DogServer.Dog
   Dim boolPerform As Boolean
   Dim intRow As Integer
   
   Call oApp.OpenDatabase

   Range(&quot;A4:B100&quot;).Select
   Selection.ClearContents
   Range(&quot;A4&quot;).Select

   oDog.SortName = &quot;DOGNAME&quot;
   boolPerform = oDog.OpenRecordset
   If boolPerform Then
      intRow = 4
      Do While boolPerform
         Worksheets(&quot;DogList&quot;).Cells(intRow, 1) = oDog.DogName
         Worksheets(&quot;DogList&quot;).Cells(intRow, 2) = _
                                    oDog.BirthDate
         intRow = intRow + 1
         
         boolPerform = oDog.MoveNext
      Loop
      oDog.CloseRecordset
   Else
      Beep
      MsgBox oDog.InfoMsg
   End If
End Sub
</b></font></pre>
<p>
The only difference between the code shown above and the code from the Visual Basic sample is that you specify the name of the server as well as the object within the object. Also, you specify the cells you want to put the data into. Other than that, the code is nearly identical to the code that you write in Visual Basic.</p>
<h3>Out-of-Process Servers</h3>
<p>
When you make an .EXE file out of a Visual Basic project that has a public class, you are creating an out-of-process server. This means that your application .EXE will run in one process space, and the code component you call will run in another process space. You will be performing cross-process communication via Active Automation.</p>
<h3>In-Process servers</h3>
<p>
An In-Process Server (IPS) is an Active DLL that can be created in Visual Basic. These Active DLLs have to be created with the 32-bit version of Visual Basic and can only be run in a 32-bit environment. These DLLs share the same process space as the .EXE file that uses them. This makes them much faster than the out-of-process code components. Using an in-process server is exactly the same as an out-of-process code component.</p>
<p>
<b>Rules of In-Process servers</b></p>
<p>
These require particular coding conventions, and there are a lot of rules to programming them. You should learn some of the these rules before coding your servers. Below are some of the rules for an IPS:
<ul>
<li>
No MDI forms are allowed.<br><br></li>
<li>
A Sub Main is required and will load every time the code component is loaded.<br><br></li>
<li>
The End Statement is not allowed.<br><br></li>
<li>
You may not set the Instancing property to Createable SingleUse since this requires another instance of the server to load, and DLLs can only be loaded once.<br><br></li>
<li>
DDE can not be used from the IPS.</li>
</ul>
<p>
This is just a partial list of the rules associated with an IPS. Search the Help for more information on In-Process Servers.</p>
<p>
<b>Benefits of In-Process servers</b></p>
<p>
The major benefit of an in-process server as opposed to an out-of-process server is SPEED! Since this runs as a DLL in the same process space, there is no cross-process communication that has to take place. This can significantly speed up the time it takes to invoke methods and set/read properties.</p>
<h2>Summary</h2>
<p>
In this chapter, you learned to put together a template for all your data access classes. By putting together your data access classes to use the DBRecordset object, you can change your data access method within the DBRecordset object, and you don’t need to change the Data Access Class. This means as new ways of accessing data are introduced, you don’t need to rewrite your whole application, only a couple of classes.</p>
<p>
A couple of other benefits are that you encapsulate business rules in one place. You have a common interface to a table. There is no need to write SQL code all over your application; you can put it all into one place.</p>
<p>
In this chapter, you learned to create database connection classes for some other database access methods. By abstracting connections, your base classes that deal with tables can remain the same, and you only need to add the new connection class for the database access method you want to use.</p>
<p>
You also learned to create Recordset classes for additional database methods. Once again, this helps you abstract dealing with result sets of data so that your base classes do not need to change.</p>
<p>
You also learned how to create a code component out of the application built in the previous chapter. </p>
<p>
&copy; 1997 Microsoft Corporation. All rights reserved.</p>
<p>
The information contained in this document represents the current view of Microsoft Corporation on the issues discussed as of the date of publication. Because Microsoft must respond to changing market conditions, it should not be interpreted to be a commitment on the part of Microsoft, and Microsoft cannot guarantee the accuracy of any information presented after the date of publication.</p>
<p>
This document is for informational purposes only. MICROSOFT MAKES NO WARRANTIES, EXPRESS OR IMPLIED, IN THIS DOCUMENT.</p>
<p>
Microsoft and Visual Basic are registered trademarks and ActiveX is a trademark of Microsoft Corporation.</p>
<p>
Other product and company names listed herein may be the trademarks of their respective owners.</p>
</font></BODY>
</HTML>
