<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Sample Provider Overview</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
	<BODY bgcolor="#FFFFFF" link=#003399 vlink=#996699>



	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1>Sample Provider Overview</h1>
<p>
OLE DB</p>
<p>
Universal Data Access for Microsoft<i>®</i> Windows<i>®</i> and Windows NT<i>®</i> Operating Systems</p>
<p>
<b>White Paper</b></p>
<h2><a name="abstract"></a>Abstract</h2>
<p>
This White Paper describes the Microsoft® OLE DB sample provider (SAMPPROV.DLL) which developers can use to learn about building OLE DB providers. In addition to general guidelines on how to construct an OLE DB data provider, there is a section which takes users step-by-step through the process of writing an OLE DB provider.</p>
<p>
© 1997 Microsoft Corporation. All rights reserved.</p>
<p>
The information contained in this document represents the current view of Microsoft Corporation on the issues discussed as of the date of publication. Because Microsoft must respond to changing market conditions, it should not be interpreted to be a commitment on the part of Microsoft, and Microsoft cannot guarantee the accuracy of any information presented after the date of publication.</p>
<p>
This White Paper is for informational purposes only. MICROSOFT MAKES NO WARRANTIES, EXPRESS OR IMPLIED, IN THIS DOCUMENT.</p>
<p>
Microsoft, Visual Basic, Windows, and Windows NT are registered trademarks of Microsoft Corporation.</p>
<p>
Other product or company names mentioned herein may be the trademarks of their respective owners.</p>
<p>
Microsoft Corporation · One Microsoft Way · Redmond, WA 98052-6399 · USA</p>
<p>
0997</p>
<h2><a name="introduction"></a>Introduction</h2>
<p>
The Microsoft® OLE DB sample provider, SAMPPROV.DLL, is a learning tool for developers new to OLE DB. Users can displaying the source code in the debugger to learn about building OLE DB providers. Although this provider uses a simple interface to access data in the underlying data source, it demonstrates the general procedures that developers need to follow to expose rowsets over a file-based data source using <b>IOpenRowset</b>.</p>
<h2><a name="sampleproviderfeatures"></a>Sample Provider Features</h2>
<p>
The sample provider exposes data in a single, comma-separated value file named CUSTOMER.CSV. If you alter the code to use a different file, you must follow the formatting conventions of the sample file, which follow.</p>
<p>
The first line of a .csv file that can be read by SAMPPROV must contain the column names in quotation marks. The second line must list the column types and lengths. All additional lines contain data, in comma-separated format. Every line of data in the file must contain the correct number of values. The following example illustrates the file format. </p>
<pre><code>"Column1","Column2","Column3"
Char(20),SLONG,SLONG
"Name1",10,-10
@@@@@@@@@@@@@@@@@@@@@           // Deleted Row
"Name2",110,-110</code></pre>
<p>
In addition, the sample provider replaces deleted rows in the file with the at sign (@). These rows are ignored by the sample provider when the file is initialized. If a user updates a row, the new data is appended to the end of the file and the original row is overwritten with at signs, indicating that it is deleted.</p>
<h2><a name="sampleproviderlimitations"></a>Sample Provider Limitations </h2>
<p>
The following are limitations in SAMPPROV.DLL:
<ul>
<li>
This code example is for illustrative purposes; the sample provider has not been rigorously tested.<br><br></li>
<li>
<b>IDBInitialize::Initialize</b> requires the path to the .csv file. If the path is not supplied by the calling application, SAMPPROV prompts the user for the path.<br><br></li>
<li>
The data source object can create only one session; the session can create only one rowset. This is because the underlying Cfileio object opens the .csv text files in exclusive mode, and has no mechanism to share access to the file.<br><br></li>
<li>
The use of properties is very simple. Only a small set of properties are illustrated, and properties are read-only.</li>
</ul>
<h2><a name="sampleproviderfiles"></a>Sample Provider Files</h2>
<p>
The following source files are included with the sample provider. The source files are located in the &lt;install directory&gt;\SAMPLES\SAMPPROV directory. The sample provider executable file SAMPPROV.DLL is located in the &lt;install directory&gt;\BIN directory.</p>
<table cols=2>
<tr valign=top>
<td width=152><b>File name</b></td>
<td width=334><b>Description</b></td>
</tr>
<tr valign=top>
<td colspan=2 width=588></td>
</tr>
<tr valign=top>
<td width=152>ACCESSOR.cpp</td>
<td width=334>CImpIAccessor object implementation.</td>
</tr>
<tr valign=top>
<td colspan=2 width=588></td>
</tr>
<tr valign=top>
<td width=152>ASSERTS.cpp</td>
<td width=334>Simple assertion routines.</td>
</tr>
<tr valign=top>
<td colspan=2 width=588></td>
</tr>
<tr valign=top>
<td width=152>ASSERTS.h</td>
<td width=334>Simple assertion routine header file.</td>
</tr>
<tr valign=top>
<td colspan=2 width=588></td>
</tr>
<tr valign=top>
<td width=152>BITARRAY.cpp</td>
<td width=334>An implementation of a bit array class used by the internal buffer to mark released or unreleased rows.</td>
</tr>
<tr valign=top>
<td colspan=2 width=588></td>
</tr>
<tr valign=top>
<td width=152>BITARRAY.h</td>
<td width=334>Class definitions for the bit array class.</td>
</tr>
<tr valign=top>
<td colspan=2 width=588></td>
</tr>
<tr valign=top>
<td width=152>CLASSFAC.cpp</td>
<td width=334>DLL entry and exit points and the OLE ClassFactory class.</td>
</tr>
<tr valign=top>
<td colspan=2 width=588></td>
</tr>
<tr valign=top>
<td width=152>CLASSFAC.h</td>
<td width=334>Class definitions for CClassFactory and DLL entry points.</td>
</tr>
<tr valign=top>
<td colspan=2 width=588></td>
</tr>
<tr valign=top>
<td width=152>COLINFO.cpp</td>
<td width=334><b>IColumnsInfo</b> interface implementation.</td>
</tr>
<tr valign=top>
<td colspan=2 width=588></td>
</tr>
<tr valign=top>
<td width=152>CRTSESS.cpp</td>
<td width=334><b>IDBCreateSession</b> interface implementation.</td>
</tr>
<tr valign=top>
<td colspan=2 width=588></td>
</tr>
<tr valign=top>
<td width=152>CVTTYPE.cpp</td>
<td width=334><b>IConvertType</b> interface implementation.</td>
</tr>
<tr valign=top>
<td colspan=2 width=588></td>
</tr>
<tr valign=top>
<td width=152>DATASRC.cpp</td>
<td width=334>CDataSource object implementation.</td>
</tr>
<tr valign=top>
<td colspan=2 width=588></td>
</tr>
<tr valign=top>
<td width=152>DATASRC.h</td>
<td width=334>CDataSource base object and contained interface definitions.</td>
</tr>
<tr valign=top>
<td colspan=2 width=588></td>
</tr>
<tr valign=top>
<td width=152>DBINIT.cpp</td>
<td width=334><b>IDBInitialize</b> interface implementation.</td>
</tr>
<tr valign=top>
<td colspan=2 width=588></td>
</tr>
<tr valign=top>
<td width=152>DBPROP.cpp</td>
<td width=334><b>IDBProperties</b> and <b>IDBInfo</b> interface implementations.</td>
</tr>
<tr valign=top>
<td colspan=2 width=588></td>
</tr>
<tr valign=top>
<td width=152>DBSESS.cpp</td>
<td width=334>CDBSession object implementation.</td>
</tr>
<tr valign=top>
<td colspan=2 width=588></td>
</tr>
<tr valign=top>
<td width=152>DBSESS.h</td>
<td width=334>CDBSession base object and contained interface definitions.</td>
</tr>
<tr valign=top>
<td colspan=2 width=588></td>
</tr>
<tr valign=top>
<td width=152>EXTBUFF.cpp</td>
<td width=334>The class that provides array-based access to a big block of memory.</td>
</tr>
<tr valign=top>
<td colspan=2 width=588></td>
</tr>
<tr valign=top>
<td width=152>EXTBUFF.h</td>
<td width=334>Class definitions for CExtBuffer class.</td>
</tr>
<tr valign=top>
<td colspan=2 width=588></td>
</tr>
<tr valign=top>
<td width=152>FILEIDX.cpp</td>
<td width=334>The index array code for a comma-separated value (.csv) provider.</td>
</tr>
<tr valign=top>
<td colspan=2 width=588></td>
</tr>
<tr valign=top>
<td width=152>FILEIDX.h</td>
<td width=334>Class definitions for CFileIO class.</td>
</tr>
<tr valign=top>
<td colspan=2 width=588></td>
</tr>
<tr valign=top>
<td width=152>FILEIO.cpp</td>
<td width=334>The file manipulation code for a comma-separated value (.csv) provider.</td>
</tr>
<tr valign=top>
<td colspan=2 width=588></td>
</tr>
<tr valign=top>
<td width=152>FILEIO.h</td>
<td width=334>Class definitions for CFileIO class.</td>
</tr>
<tr valign=top>
<td colspan=2 width=588></td>
</tr>
<tr valign=top>
<td width=152>GLOBALS.cpp</td>
<td width=334>Global initialization object.</td>
</tr>
<tr valign=top>
<td colspan=2 width=588></td>
</tr>
<tr valign=top>
<td width=152>GUIDS.h</td>
<td width=334>Internal GUIDs.</td>
</tr>
<tr valign=top>
<td colspan=2 width=588></td>
</tr>
<tr valign=top>
<td width=152>HASHTBL.cpp</td>
<td width=334>Hashing routines for row manipulation.</td>
</tr>
<tr valign=top>
<td colspan=2 width=588></td>
</tr>
<tr valign=top>
<td width=152>HASHTBL.h</td>
<td width=334>Class definitions for CHashTbl class and miscellaneous bookmark functions.</td>
</tr>
<tr valign=top>
<td colspan=2 width=588></td>
</tr>
<tr valign=top>
<td width=152>HEADERS.cpp</td>
<td width=334>Precompiled headers module.</td>
</tr>
<tr valign=top>
<td width=152><b>File name</b></td>
<td width=334><b>Description</b></td>
</tr>
<tr valign=top>
<td colspan=2 width=588></td>
</tr>
<tr valign=top>
<td width=152>HEADERS.h</td>
<td width=334>Precompiled headers.</td>
</tr>
<tr valign=top>
<td colspan=2 width=588></td>
</tr>
<tr valign=top>
<td width=152>IROWSET.cpp</td>
<td width=334><b>IRowset</b> interface implementation.</td>
</tr>
<tr valign=top>
<td colspan=2 width=588></td>
</tr>
<tr valign=top>
<td width=152>LOCAL.RC</td>
<td width=334>Localizable resource.</td>
</tr>
<tr valign=top>
<td colspan=2 width=588></td>
</tr>
<tr valign=top>
<td width=152>OPNROWST.cpp</td>
<td width=334><b>IOpenRowset</b> interface implementation.</td>
</tr>
<tr valign=top>
<td colspan=2 width=588></td>
</tr>
<tr valign=top>
<td width=152>PERSIST.cpp</td>
<td width=334><b>IPersist</b> interface implementation.</td>
</tr>
<tr valign=top>
<td colspan=2 width=588></td>
</tr>
<tr valign=top>
<td width=152>RC.h</td>
<td width=334>Resource IDs.</td>
</tr>
<tr valign=top>
<td colspan=2 width=588></td>
</tr>
<tr valign=top>
<td width=152>ROWCHNG.cpp</td>
<td width=334><b>IRowsetChange</b> interface implementation.</td>
</tr>
<tr valign=top>
<td colspan=2 width=588> </td>
</tr>
<tr valign=top>
<td width=152>ROWINFO.cpp</td>
<td width=334><b>IRowsetInfo</b> interface implementation.</td>
</tr>
<tr valign=top>
<td colspan=2 width=588></td>
</tr>
<tr valign=top>
<td width=152>ROWSET.cpp</td>
<td width=334>CRowset object implementation.</td>
</tr>
<tr valign=top>
<td colspan=2 width=588></td>
</tr>
<tr valign=top>
<td width=152>ROWSET.h</td>
<td width=334>CRowset base object and contained interface definitions.</td>
</tr>
<tr valign=top>
<td colspan=2 width=588></td>
</tr>
<tr valign=top>
<td width=152>SAMPPROV.DEF</td>
<td width=334>Project definitions.</td>
</tr>
<tr valign=top>
<td colspan=2 width=588></td>
</tr>
<tr valign=top>
<td width=152>SAMPPROV.h</td>
<td width=334>Main include file.</td>
</tr>
<tr valign=top>
<td colspan=2 width=588></td>
</tr>
<tr valign=top>
<td width=152>SAMPPROV.MAK</td>
<td width=334>Microsoft Developer Studio&ndash;generated NMAKE File.</td>
</tr>
<tr valign=top>
<td colspan=2 width=588></td>
</tr>
<tr valign=top>
<td width=152>SAMPPROV.RC</td>
<td width=334>Main resource file.</td>
</tr>
<tr valign=top>
<td colspan=2 width=588></td>
</tr>
<tr valign=top>
<td width=152>SAMPVER.h</td>
<td width=334>Version include file.</td>
</tr>
<tr valign=top>
<td colspan=2 width=588></td>
</tr>
<tr valign=top>
<td width=152>UTILPROP.cpp</td>
<td width=334>Properties utility object implementation.</td>
</tr>
<tr valign=top>
<td colspan=2 width=588></td>
</tr>
<tr valign=top>
<td width=152>UTILPROP.h</td>
<td width=334>CUtilProp object definitions.</td>
</tr>
</table><br>
<ol>
</ol>
<h2><a name="buildingsampleprovider"></a>Building the Sample Provider</h2>
<p>
The file &lt;install directory&gt;\SAMPLES\SAMPPROV\SAMPPROV.MAK is set up for compilation with NMAKE, the Microsoft Program Maintenance Utility provided with Microsoft Developer Studio. SAMPPROV must have access to the following OLE DB files:
<ul>
<li>
OLEDB.h<br><br></li>
<li>
OLEDBERR.h<br><br></li>
<li>
OLEDB.LIB</li>
</ul>
<p>
Verify that these files are on the path referred to by the INCLUDE environment variable.</p>
<p>
The following example syntax builds a debug version of SAMPPROV on the Intel <i>x</i>86 platform based on the Win32 (<i>x</i>86) Dynamic-Link Library configuration.</p>
<pre><code>NMAKE /f "sampprov.mak" CFG="sampprov - Win32 x86 Debug"</code></pre>
<ol>
</ol>
<p>
To build SAMPPROV on another platform or with a different configuration, use one of the following configuration options.</p>
<table cols=2>
<tr valign=top>
<td width=272><b>Configuration option</b></td>
<td width=208><b>Type of file built</b></td>
</tr>
<tr valign=top>
<td colspan=2 width=480></td>
</tr>
<tr valign=top>
<td width=272>"sampprov - Win32 x86 Debug"</td>
<td width=208>Debug version of SAMPPROV based on Win32 (<i>x</i>86) Dynamic-Link Library.</td>
</tr>
<tr valign=top>
<td colspan=2 width=480></td>
</tr>
<tr valign=top>
<td width=272>"sampprov - Win32 x86 Release"</td>
<td width=208>Retail version of SAMPPROV based on Win32 (<i>x</i>86) Dynamic-Link Library.</td>
</tr>
<tr valign=top>
<td colspan=2 width=480></td>
</tr>
<tr valign=top>
<td width=272>"sampprov - Win32 (ALPHA) axp Debug"</td>
<td width=208>Debug version of SAMPPROV based on Win32 (ALPHA) Dynamic-Link Library.</td>
</tr>
<tr valign=top>
<td colspan=2 width=480></td>
</tr>
<tr valign=top>
<td width=272>"sampprov - Win32 (ALPHA) axp Release"</td>
<td width=208>Retail version of SAMPPROV based on Win32 (ALPHA) Dynamic-Link Library.</td>
</tr>
<tr valign=top>
<td colspan=2 width=480></td>
</tr>
<tr valign=top>
<td width=272>"sampprov - Win32 (PPC) ppc Debug"</td>
<td width=208>Debug version of SAMPPROV based on Win32 (PPC) Dynamic-Link Library.</td>
</tr>
<tr valign=top>
<td colspan=2 width=480></td>
</tr>
<tr valign=top>
<td width=272>"sampprov - Win32 (PPC) ppc Release"</td>
<td width=208>Retail version of SAMPPROV based on Win32 (PPC) Dynamic-Link Library.</td>
</tr>
</table><br>
<ol>
</ol>
<p>
For additional information on using NMAKE, see the Developer Studio documentation.</p>
<h2><a name="writingoledbprovideranintroduction"></a>Writing an OLE DB Provider: An Introduction</h2>
<p>
The purpose of this section is to offer some general guidelines on how to construct an OLE DB data provider. </p>
<h3><a name="informationneededtowriteoledbprovider"></a>Information Needed to Write an OLE DB Provider</h3>
<p>
OLE DB is based on the Component Object Model. Developers must be familiar with this model as well as with basic object-oriented coding practices to create an OLE DB provider. Although many different implementations are possible, the sample provider implements the TDataSource, TDBSession, and TRowset CoTypes. The sample provider uses the <b>IOpenRowset</b> interface, which is a required interface on the session for all providers. <b>IOpenRowset</b> is used by consumers that need access to the full data set and do not need to specify selection criteria.</p>
<p>
Developers should become familiar with data source objects, sessions, and rowsets by reading the <i>OLE DB Programmer&rsquo;s Reference</i>. In addition, developers may want to read the &ldquo;Overview&rdquo; in the <i>OLE DB Programmer&rsquo;s Reference</i> to get a general introduction to OLE DB conventions, design considerations, and a complete introduction to the objects that make up OLE DB.</p>
<h3><a name="thesampleprovider"></a>The Sample Provider</h3>
<p>
The sample provider offers access to a fixed-length text data file using OLE DB interfaces. The purpose of this sample provider is purely illustrative. The capabilities of the sample provider are limited; these limitations are discussed in &ldquo;Sample Provider Overview,&rdquo; previously in this paper.</p>
<p>
The sample provider opens the sample data file and enables the consumer to read the data, using the <b>IRowset</b> interface, in a forward-only fashion. The consumer can update or delete the current row but cannot add new rows. The format of the data file is discussed in &ldquo;Sample Provider Overview,&rdquo; previously in this paper.</p>
<h2><a name="objectsinterfacesimplementedbysampleprovider"></a>Objects and Interfaces Implemented by the Sample Provider</h2>
<p>
The sample provider implements three OLE DB objects.
<ul>
<li>
The data source object, which enables consumers to connect and initialize the interaction with the data file.<br><br></li>
<li>
The session, which enables consumers to create a rowset for the data set in the data file.<br><br></li>
<li>
The rowset, which exposes a data set to the consumer.<p>
These objects, along with the interfaces implemented in the sample, are described in detail in the following topics, which also contain some of the implementation code for specific interfaces and methods.
<p>
The following table lists the interfaces and methods implemented in the sample provider along with the name of the source code file in which each can be found.
</li>
</ul>
<table cols=3>
<tr valign=top>
<td width=160><b>Interface name</b></td>
<td width=160><b>Method name</b></td>
<td width=160><b>Source code file</b></td>
</tr>
<tr valign=top>
<td colspan=3 width=480></td>
</tr>
<tr valign=top>
<td width=160><b>IDBInitialize</b></td>
<td width=160><b>Initialize</b></td>
<td width=160>DBInit.cpp</td>
</tr>
<tr valign=top>
<td width=160></td>
<td width=160><b>Uninitialize</b></td>
<td width=160>DBInit.cpp</td>
</tr>
<tr valign=top>
<td colspan=3 width=480></td>
</tr>
<tr valign=top>
<td width=160><b>IDBCreateSession</b></td>
<td width=160><b>CreateSession</b></td>
<td width=160>CrtSess.cpp</td>
</tr>
<tr valign=top>
<td colspan=3 width=480></td>
</tr>
<tr valign=top>
<td width=160><b>IDBProperties</b></td>
<td width=160><b>GetProperties</b></td>
<td width=160>UtilProp.cpp</td>
</tr>
<tr valign=top>
<td width=160></td>
<td width=160><b>GetPropertyInfo</b></td>
<td width=160>UtilProp.cpp</td>
</tr>
<tr valign=top>
<td width=160></td>
<td width=160><b>SetProperties</b></td>
<td width=160>UtilProp.cpp</td>
</tr>
<tr valign=top>
<td colspan=3 width=480></td>
</tr>
<tr valign=top>
<td width=160><b>IPersist</b></td>
<td width=160><b>GetClassID</b></td>
<td width=160>Persist.cpp</td>
</tr>
<tr valign=top>
<td colspan=3 width=480></td>
</tr>
<tr valign=top>
<td width=160><b>IGetDataSource</b></td>
<td width=160><b>GetDataSource</b></td>
<td width=160>DBSess.cpp</td>
</tr>
<tr valign=top>
<td colspan=3 width=480></td>
</tr>
<tr valign=top>
<td width=160><b>IOpenRowset</b></td>
<td width=160><b>OpenRowset</b></td>
<td width=160>OpnRowst.cpp</td>
</tr>
<tr valign=top>
<td colspan=3 width=480></td>
</tr>
<tr valign=top>
<td width=160><b>IColumnsInfo</b></td>
<td width=160><b>GetColumnInfo</b></td>
<td width=160>ColInfo.cpp</td>
</tr>
<tr valign=top>
<td width=160></td>
<td width=160><b>MapColumnIDs</b></td>
<td width=160>ColInfo.cpp</td>
</tr>
<tr valign=top>
<td colspan=3 width=480></td>
</tr>
<tr valign=top>
<td width=160><b>IConvertType</b></td>
<td width=160><b>CanConvert</b></td>
<td width=160>CvtType.cpp</td>
</tr>
<tr valign=top>
<td colspan=3 width=480></td>
</tr>
<tr valign=top>
<td width=160><b>IAccessor</b></td>
<td width=160><b>AddRefAccessor</b></td>
<td width=160>Accessor.cpp</td>
</tr>
<tr valign=top>
<td width=160></td>
<td width=160><b>CreateAccessor</b></td>
<td width=160>Accessor.cpp</td>
</tr>
<tr valign=top>
<td width=160></td>
<td width=160><b>GetBindings</b></td>
<td width=160>Accessor.cpp</td>
</tr>
<tr valign=top>
<td width=160></td>
<td width=160><b>ReleaseAccessor</b></td>
<td width=160>Accessor.cpp</td>
</tr>
<tr valign=top>
<td colspan=3 width=480></td>
</tr>
<tr valign=top>
<td width=160><b>IRowset</b></td>
<td width=160><b>AddRefRows</b></td>
<td width=160>IRowset.cpp</td>
</tr>
<tr valign=top>
<td width=160></td>
<td width=160><b>GetData</b></td>
<td width=160>IRowset.cpp</td>
</tr>
<tr valign=top>
<td width=160></td>
<td width=160><b>GetNextRows</b></td>
<td width=160>IRowset.cpp</td>
</tr>
<tr valign=top>
<td width=160></td>
<td width=160><b>ReleaseRows</b></td>
<td width=160>IRowset.cpp</td>
</tr>
<tr valign=top>
<td width=160></td>
<td width=160><b>RestartPosition</b></td>
<td width=160>IRowset.cpp</td>
</tr>
<tr valign=top>
<td colspan=3 width=480> </td>
</tr>
<tr valign=top>
<td width=160><b>IRowsetInfo</b></td>
<td width=160><b>GetProperties</b></td>
<td width=160>RowInfo.cpp</td>
</tr>
<tr valign=top>
<td width=160></td>
<td width=160><b>GetReferencedRowset</b></td>
<td width=160>RowInfo.cpp</td>
</tr>
<tr valign=top>
<td width=160></td>
<td width=160><b>GetSpecification</b></td>
<td width=160>RowInfo.cpp</td>
</tr>
<tr valign=top>
<td colspan=3 width=480></td>
</tr>
<tr valign=top>
<td width=160><b>IRowsetChange</b></td>
<td width=160><b>DeleteRows</b></td>
<td width=160>RowChng.cpp</td>
</tr>
<tr valign=top>
<td width=160></td>
<td width=160><b>InsertRow</b></td>
<td width=160>RowChng.cpp</td>
</tr>
<tr valign=top>
<td width=160></td>
<td width=160><b>SetData</b></td>
<td width=160>RowChng.cpp</td>
</tr>
<tr valign=top>
<td colspan=3 width=480></td>
</tr>
<tr valign=top>
<td width=160><b>ISessionProperties</b></td>
<td width=160><b>GetProperties</b> </td>
<td width=160>DBSess.cpp</td>
</tr>
<tr valign=top>
<td width=160></td>
<td width=160><b>SetProperties</b></td>
<td width=160>DBSess.cpp</td>
</tr>
</table><br>
<h2><a name="settinggettingproviderproperties"></a>Setting and Getting Provider Properties</h2>
<p>
The data source object is the first object created when a consumer instantiates an OLE DB data provider by calling <b>CoCreateInstance</b> or through some other technique.</p>
<p>
The data source object provides the starting point for communications between the provider and consumer. For example, a consumer can call <b>CoCreateInstance</b> and request an <b>IDBInitialize</b> interface pointer to instantiate a data source object. The provider&rsquo;s developer must generate a CLSID (class ID) and store the ID in the Windows Registry. The consumer can use this CLSID with <b>CoCreateInstance</b> to instantiate the data source object. To facilitate this operation, providers should add their application or library information to the Windows Registry upon installation on a new system. The sample provider setup program registers the sample provider in the Windows Registry.</p>
<p>
The data source object is also responsible for setting and returning information about the properties supported by the provider and exposing the list of supported keywords and literals. This functionality is supported through the mandatory <b>IDBProperties</b> interface and the optional <b>IDBInfo</b> interface. The <b>IDBProperties</b> interface contains three methods:
<ul>
<li>
<b>GetProperties</b> returns the list of properties currently set on the data source object.<br><br></li>
<li>
<b>GetPropertyInfo</b> returns information about supported rowset and data source properties.<br><br></li>
<li>
<b>SetProperties</b> sets the properties on the data source object.</li>
</ul>
<ol>
</ol>
<p>
The <b>IDBInfo</b> interface contains two methods:
<ul>
<li>
<b>GetKeywords</b> returns a list of supported keywords.<br><br></li>
<li>
<b>GetLiteralInfo</b> returns information about literals used in text commands.</li>
</ul>
<ol>
</ol>
<p>
In the sample provider implementation, no command interfaces are implemented, so <b>GetKeywords</b> returns NULL. <b>GetLiteralInfo</b> is not implemented and returns E_NOTIMPL. <b>GetProperties</b>, <b>GetPropertyInfo</b>, and <b>SetProperties</b> are handled by passing the calls to the utility object that manages properties, which is found in UtilProp.cpp. The structure containing the properties known to the sample provider, which is also found in UtilProp.cpp, follows.</p>
<table cols=1>
<tr valign=top>
<td width=762><pre><code>// Struct containing the properties we know about. The GUID and string fields are</code><pre><code>// initialized in the constructor, because C++ makes it awkward to do so at declaration
// time. So, if you change this table, be sure to make parallel changes in CUtilProp::CUtilProp.
PROPSTRUCT s_rgprop[] =
   {
/* 0 */ {DBPROP_IAccessor,       FLAGS_ROWSETRO,   VT_BOOL, TRUE,  0, NULL,         L"IAccessor"},
/* 1 */ {DBPROP_IColumnsInfo,    FLAGS_ROWSETRO,   VT_BOOL, TRUE,  0, NULL,         L"IColumnsInfo"},
/* 2 */ {DBPROP_IConvertType,    FLAGS_ROWSETRO,   VT_BOOL, TRUE,  0, NULL,         L"IConvertType"},
/* 3 */ {DBPROP_IRowset,         FLAGS_ROWSETRO,   VT_BOOL, TRUE,  0, NULL,         L"IRowset"},
/* 4 */ {DBPROP_IRowsetChange,   FLAGS_ROWSETRW,   VT_BOOL, TRUE,  0, NULL,         L"IRowsetChange"},
/* 5 */ {DBPROP_IRowsetInfo,     FLAGS_ROWSETRO,   VT_BOOL, TRUE,  0, NULL,         L"IRowsetInfo"},
/* 6 */ {DBPROP_ACTIVESESSIONS,  FLAGS_DATASOURCE, VT_I4,   FALSE, 1, NULL,         L"Active Sessions"},
/* 7 */ {DBPROP_PROVIDERNAME,    FLAGS_DATASOURCE, VT_BSTR, FALSE, 0, L"SAMPPROV.DLL",L"Provider Name"},
/* 8 */ {DBPROP_PROVIDEROLEDBVER,FLAGS_DATASOURCE, VT_BSTR, FALSE, 0, L"01.10",     L"OLE DB Version"},
/* 9 */ {DBPROP_PROVIDERVER,     FLAGS_DATASOURCE, VT_BSTR, FALSE, 0, _TEXT(VER_PRODUCTVERSION_STR), L"Provider Version"},
/* 10*/ {DBPROP_INIT_DATASOURCE, FLAGS_DBINITRW,   VT_BSTR, FALSE, 0, L"",          L"Data Source"},
/* 11*/ {DBPROP_INIT_HWND,       FLAGS_DBINITRW,   VT_I4,   FALSE, 0, NULL,         L"Window Handle"},
/* 12*/ {DBPROP_INIT_PROMPT,     FLAGS_DBINITRW,   VT_I2,   FALSE, 4, NULL,         L"Prompt"}
    };</code></pre>
</pre>
</td>
</tr>
</table><br>
<ol>
</ol>
<p>
The source code for <b>GetPropertyInfo</b>, which passes property information back to the provider, follows.
<ol>
</ol>
<table cols=1>
<tr valign=top>
<td width=600><pre><code>// CUtilProp::GetPropertyInfo  -----------------------------------------</code><pre><code>//
// @mfunc   Returns information about rowset and data source properties 
//         supported by the provider
//
// @rdesc HRESULT
//      @flag S_OK          | The method succeeded
//      @flag E_INVALIDARG  | pcPropertyIDSets or prgPropertyInfo was NULL
//      @flag E_OUTOFMEMORY | Out of memory
//

STDMETHODIMP CUtilProp::GetPropertyInfo
    (
    BOOL              fDSOInitialized,     //@parm IN  | if Initialized
    ULONG             cPropertyIDSets,     //@parm IN  | # properties
    const DBPROPIDSET rgPropertyIDSets[],  //@parm IN  | Array of property sets
    ULONG*            pcPropertyInfoSets,  //@parm OUT | # DBPROPSET structures
    DBPROPINFOSET**   prgPropertyInfoSets, //@parm OUT | DBPROPSET structures property 
                                           //          | information returned
    WCHAR**           ppDescBuffer         //@parm OUT | Property descriptions
    )
{
   BOOL           fRet               = TRUE;
   BOOL           fPropsinError      = FALSE;
   BOOL           fPropsSucceed      = FALSE;
   BOOL           fIsSpecialGUID     = FALSE;
   BOOL           fIsNotSpecialGUID  = FALSE;
   ULONG          cProps             = 0;
   ULONG          cCount             = 0;
   ULONG          ulPropertySets     = 0;
   WCHAR*         pDescBuffer        = NULL;
   DBPROPINFO*    pPropInfo;
   DBPROPINFOSET* pPropInfoSet;

   // init out params
   if (pcPropertyInfoSets)
      *pcPropertyInfoSets    = 0;
   if (prgPropertyInfoSets)
      *prgPropertyInfoSets   = NULL;
   if (ppDescBuffer)
      *ppDescBuffer = NULL;

   // Check Arguments, on failure post HRESULT to error queue
   if( ((cPropertyIDSets &gt; 0) &amp;&amp; !rgPropertyIDSets) ||
      !pcPropertyInfoSets || !prgPropertyInfoSets )
      return ResultFromScode( E_INVALIDARG );

   // New argument check for &gt; 1 cPropertyIDs and NULL pointer for 
   // array of property ids.
   for(ULONG ul=0; ul&lt;cPropertyIDSets; ul++)
   {
      if( rgPropertyIDSets[ul].cPropertyIDs &amp;&amp; !(rgPropertyIDSets[ul].rgPropertyIDs) )
         return ResultFromScode( E_INVALIDARG );
      
      if (DBPROPSET_ROWSETALL == rgPropertyIDSets[ul].guidPropertySet          ||
         DBPROPSET_DATASOURCEALL == rgPropertyIDSets[ul].guidPropertySet       ||
         DBPROPSET_DATASOURCEINFOALL == rgPropertyIDSets[ul].guidPropertySet   ||
         DBPROPSET_SESSIONALL == rgPropertyIDSets[ul].guidPropertySet          ||
         DBPROPSET_DBINITALL == rgPropertyIDSets[ul].guidPropertySet)
         fIsSpecialGUID = TRUE;
      else
         fIsNotSpecialGUID = TRUE;

      if(fIsSpecialGUID &amp;&amp; fIsNotSpecialGUID)
         return ResultFromScode( E_INVALIDARG );
   }

   // save the count of PropertyIDSets
   cProps = cPropertyIDSets;

   // If the consumer does not restrict the property sets
   // by specify an array of property sets and a cPropertySets
   // greater than 0, then we need to make sure we 
   // have some to return
   if ( (cPropertyIDSets == 0) )
   {
      if( fDSOInitialized )
         cProps = NUMBER_OF_SUPPORTED_PROPERTY_SETS;
      else
         cProps = 1;
   }   

   // use task memory allocater to alloc a DBPROPINFOSET struct
   pPropInfoSet = (DBPROPINFOSET*) g_pIMalloc-&gt;Alloc(cProps *
                                         sizeof( DBPROPINFOSET ));
   if ( !pPropInfoSet )
      return ResultFromScode( E_OUTOFMEMORY );

   memset( pPropInfoSet, 0, (cProps * sizeof( DBPROPINFOSET )));

   // Alloc memory for ppDescBuffer
   if ( ppDescBuffer )
   {
      pDescBuffer = (WCHAR*)g_pIMalloc-&gt;Alloc(NUMBER_OF_SUPPORTED_PROPERTIES * 
         CCH_GETPROPERTYINFO_DESCRIP_BUFFER_SIZE * sizeof(WCHAR) );
      
      if( pDescBuffer )
      {
         memset(pDescBuffer, 0, (NUMBER_OF_SUPPORTED_PROPERTIES * 
            CCH_GETPROPERTYINFO_DESCRIP_BUFFER_SIZE * sizeof(WCHAR)));
      
         *ppDescBuffer = pDescBuffer;
      }
      else
      {
         g_pIMalloc-&gt;Free( pPropInfoSet );
         return ResultFromScode( E_OUTOFMEMORY );
      }
   }

   // For each supported Property Set
   for (ulPropertySets=0; ulPropertySets &lt; cProps; ulPropertySets++)
   {
      BOOL fGetAllProps = FALSE;

      // If no restrictions return all properties from the three supported property sets
      if( cPropertyIDSets == 0 )
      {
         fGetAllProps = TRUE;

         // only do this once
         if (ulPropertySets == 0)
         {
            pPropInfoSet[0].guidPropertySet = DBPROPSET_DBINIT;
            pPropInfoSet[0].cPropertyInfos  = NUMBER_OF_SUPPORTED_DBINIT_PROPERTIES;

            if ( fDSOInitialized )
            {
               pPropInfoSet[1].guidPropertySet = DBPROPSET_DATASOURCEINFO;
               pPropInfoSet[1].cPropertyInfos  = NUMBER_OF_SUPPORTED_DATASOURCEINFO_PROPERTIES;
               pPropInfoSet[2].guidPropertySet = DBPROPSET_ROWSET;
               pPropInfoSet[2].cPropertyInfos  = NUMBER_OF_SUPPORTED_ROWSET_PROPERTIES;
            }
         }
      }
      else
      {
         pPropInfoSet[ulPropertySets].guidPropertySet = rgPropertyIDSets[ulPropertySets].guidPropertySet;
         pPropInfoSet[ulPropertySets].cPropertyInfos  = rgPropertyIDSets[ulPropertySets].cPropertyIDs;

         if ((rgPropertyIDSets[ulPropertySets].guidPropertySet == DBPROPSET_DBINITALL) ||
            (rgPropertyIDSets[ulPropertySets].guidPropertySet == DBPROPSET_DBINIT     &amp;&amp;
             rgPropertyIDSets[ulPropertySets].cPropertyIDs == 0))
         {
            fGetAllProps = TRUE;
            pPropInfoSet[ulPropertySets].guidPropertySet = DBPROPSET_DBINIT;
            pPropInfoSet[ulPropertySets].cPropertyInfos  = NUMBER_OF_SUPPORTED_DBINIT_PROPERTIES;
         }
         else if (rgPropertyIDSets[ulPropertySets].guidPropertySet == DBPROPSET_DATASOURCEALL)
         {
            // Since we do not support it should return DB_E_ERRORSOCCURRED with 0 &amp; NULL
            fPropsinError = TRUE;
            pPropInfoSet[ulPropertySets].guidPropertySet = DBPROPSET_DATASOURCE;
            pPropInfoSet[ulPropertySets].cPropertyInfos  = 0;
         }
         else if( fDSOInitialized )
         {
            if( (rgPropertyIDSets[ulPropertySets].guidPropertySet == DBPROPSET_DATASOURCEINFOALL) ||
               ((rgPropertyIDSets[ulPropertySets].guidPropertySet == DBPROPSET_DATASOURCEINFO)   &amp;&amp;
                (rgPropertyIDSets[ulPropertySets].cPropertyIDs == 0)) )
            {
               fGetAllProps = TRUE;
               pPropInfoSet[ulPropertySets].guidPropertySet = DBPROPSET_DATASOURCEINFO;
               pPropInfoSet[ulPropertySets].cPropertyInfos  = NUMBER_OF_SUPPORTED_DATASOURCEINFO_PROPERTIES;
            }
            else if (rgPropertyIDSets[ulPropertySets].guidPropertySet == DBPROPSET_SESSIONALL)
            {
               // Since we do not support it should return a error with 0 &amp; NULL
               fPropsinError = TRUE;
               pPropInfoSet[ulPropertySets].guidPropertySet = DBPROPSET_SESSION;
               pPropInfoSet[ulPropertySets].cPropertyInfos  = 0;
            }
            else if( (rgPropertyIDSets[ulPropertySets].guidPropertySet == DBPROPSET_ROWSETALL) ||
                   ((rgPropertyIDSets[ulPropertySets].guidPropertySet == DBPROPSET_ROWSET) &amp;&amp;
                    (rgPropertyIDSets[ulPropertySets].cPropertyIDs == 0)) )
            {
               fGetAllProps = TRUE;
               pPropInfoSet[ulPropertySets].guidPropertySet = DBPROPSET_ROWSET;
               pPropInfoSet[ulPropertySets].cPropertyInfos  = NUMBER_OF_SUPPORTED_ROWSET_PROPERTIES;
            }
            else if (rgPropertyIDSets[ulPropertySets].cPropertyIDs == 0)
               fPropsinError = TRUE;
         }
         else if (rgPropertyIDSets[ulPropertySets].cPropertyIDs == 0)
         {
            // Since we do not support it should return a error with 0 &amp; NULL
            fPropsinError = TRUE;
         }
      }
      
      if (pPropInfoSet[ulPropertySets].cPropertyInfos)
      {
          // use task memory allocater to alloc array of DBPROPINFO structs
         pPropInfo = (DBPROPINFO*) g_pIMalloc-&gt;Alloc(sizeof( DBPROPINFO ) *
                           pPropInfoSet[ulPropertySets].cPropertyInfos);

         if (!pPropInfo)
         {
            if ( ppDescBuffer ) 
               *ppDescBuffer = NULL;
            g_pIMalloc-&gt;Free( pPropInfoSet );
            g_pIMalloc-&gt;Free( pDescBuffer );
            
            return ResultFromScode( E_OUTOFMEMORY );
         }
      
         pPropInfoSet[ulPropertySets].rgPropertyInfos = &amp;pPropInfo[0];

         memset( pPropInfo, 0, 
            (pPropInfoSet[ulPropertySets].cPropertyInfos * sizeof( DBPROPINFO )));
      }

       // for each prop in our table..
      for (cCount=0; cCount &lt; pPropInfoSet[ulPropertySets].cPropertyInfos; cCount++)
      {
         // init the Variant right up front
         // that way we can VariantClear with no worried (if we need to)
         VariantInit( &amp;pPropInfo[cCount].vValues );

         // set the description pointer
         pPropInfo[cCount].pwszDescription = pDescBuffer;

         // Check supported property sets
         if ( (pPropInfoSet[ulPropertySets].guidPropertySet == DBPROPSET_DBINIT) &amp;&amp; 
             (fGetAllProps) )
         {
            // load up their DBPROPINFO from our table
            fPropsSucceed = TRUE;
            fRet = LoadDBPROPINFO( &amp;m_rgproperties[START_OF_SUPPORTED_DBINIT_PROPERTIES + cCount], 
                     &amp;pPropInfo[cCount] );
         }
         else if ( (pPropInfoSet[ulPropertySets].guidPropertySet == DBPROPSET_DATASOURCEINFO) &amp;&amp; 
              fGetAllProps &amp;&amp; fDSOInitialized)
         {
            // load up their DBPROPINFO from our table
            fPropsSucceed = TRUE;
            fRet = LoadDBPROPINFO( &amp;m_rgproperties[START_OF_SUPPORTED_DATASOURCEINFO_PROPERTIES + cCount], 
                     &amp;pPropInfo[cCount] );
         }

         else if ( (pPropInfoSet[ulPropertySets].guidPropertySet == DBPROPSET_ROWSET) &amp;&amp;
                 fGetAllProps &amp;&amp; fDSOInitialized)
         {
            // load up their DBPROPINFO from our table
            fPropsSucceed = TRUE;
            fRet = LoadDBPROPINFO( &amp;m_rgproperties[START_OF_SUPPORTED_ROWSET_PROPERTIES + cCount], 
                     &amp;pPropInfo[cCount] );
         }
         else
         {
            ULONG ulIndex;

            pPropInfo[cCount].dwPropertyID   = rgPropertyIDSets[ulPropertySets].rgPropertyIDs[cCount];
            pPropInfo[cCount].dwFlags      = DBPROPFLAGS_NOTSUPPORTED;

            if ( (GetPropIndex(rgPropertyIDSets[ulPropertySets].rgPropertyIDs[cCount], &amp;ulIndex)) &amp;&amp;
                (fDSOInitialized || (pPropInfoSet[ulPropertySets].guidPropertySet == DBPROPSET_DBINIT)) )
            {
               fPropsSucceed = TRUE;
               fRet = LoadDBPROPINFO( &amp;m_rgproperties[ulIndex], &amp;pPropInfo[cCount] );
            }
            else
            {
               fPropsinError = TRUE;
               pPropInfo[cCount].pwszDescription = NULL;
            }
         }

         if (!fRet)
         {
            ULONG ulFor;

            // something went wrong
            // clear all variants used so far..
            for (ulFor = 0; ulFor &lt; cCount; ulFor++)
               VariantClear( &amp;pPropInfo[ulFor].vValues );

            // .. delete the pPropInfo array, return failure
            if ( ppDescBuffer ) *ppDescBuffer = NULL;
            g_pIMalloc-&gt;Free( pPropInfo );
            g_pIMalloc-&gt;Free( pPropInfoSet );
            g_pIMalloc-&gt;Free( pDescBuffer );
            return ResultFromScode( E_FAIL );
         }

         // move the description pointer to the next
         if ( pPropInfo[cCount].pwszDescription )
            pDescBuffer += (wcslen(pPropInfo[cCount].pwszDescription) + sizeof(CHAR));
      }
      // Set local back to FALSE
      fGetAllProps = FALSE;
   }

   // set count of properties and property information
   *pcPropertyInfoSets    = cProps;
   *prgPropertyInfoSets = pPropInfoSet;

   if ( !fPropsSucceed &amp;&amp; fPropsinError )
   {
      if ( ppDescBuffer ) *ppDescBuffer = NULL;
      g_pIMalloc-&gt;Free( pDescBuffer );
      return ResultFromScode( DB_E_ERRORSOCCURRED );
   }
   else if ( fPropsSucceed &amp;&amp; fPropsinError )
      return ResultFromScode( DB_S_ERRORSOCCURRED );
   else
      return ResultFromScode( S_OK );
}</code></pre>
</pre>
</td>
</tr>
</table><br>
<ol>
</ol>
<p>
The source code for <b>GetProperties</b>, which returns the current settings of all supported properties, follows. Immediately following the creation of the data source object, none of the properties are set. Properties are set by the <b>SetProperties</b> method.
<ol>
</ol>
<table cols=1>
<tr valign=top>
<td width=738><pre><code>// CUtilProp::GetProperties ----------------------------------------------------</code><pre><code>//
// @mfunc Returns current settings of all properties supported by the DSO/rowset
//
// @rdesc HRESULT
//      @flag S_OK          | The method succeeded
//      @flag E_INVALIDARG  | pcProperties or prgPropertyInfo was NULL
//      @flag E_OUTOFMEMORY | Out of memory
//
STDMETHODIMP CUtilProp::GetProperties
    (
    DWORD               dwBitMask,           //@parm IN  | Mask if Initialized
    ULONG               cPropertyIDSets,     //@parm IN  | # of restiction property IDs
    const DBPROPIDSET   rgPropertyIDSets[],  //@parm IN  | restriction guids
    ULONG*              pcPropertySets,      //@parm OUT | count of properties returned
    DBPROPSET**         prgPropertySets      //@parm OUT | property information returned
    )
{
   BOOL         fRet           = TRUE;
   BOOL         fPropsinError  = FALSE;
   BOOL         fPropsSucceed  = FALSE;
   ULONG        cProps         = 0;
   ULONG        cCount         = 0;
   ULONG        ulPropertySets = 0;
   DBPROP*      pProp;
   DBPROPSET*   pPropSet;

   // save the count of PropertyIDSets
   cProps = cPropertyIDSets;

   // If the consumer does not restrict the property sets
   // by specify an array of property sets and a cPropertySets
   // greater than 0, then we need to make sure we 
   // have some to return
   if( cPropertyIDSets == 0 )
   {
      // only allow the DBINIT and DATASOURCE if Initialized
      if ( (dwBitMask &amp; PROPSET_DSOINIT) == PROPSET_DSOINIT )
         cProps = 2;
      else
         cProps = 1;
   }

   // use task memory allocater to alloc a DBPROPINFOSET struct
   pPropSet = (DBPROPSET*) g_pIMalloc-&gt;Alloc(cProps *
                                             sizeof( DBPROPSET ));
   if ( !pPropSet )
      return ResultFromScode( E_OUTOFMEMORY );

   memset( pPropSet, 0, (cProps * sizeof( DBPROPSET )));

   // For each supported Property Set
   for (ulPropertySets=0; ulPropertySets &lt; cProps; ulPropertySets++)
   {
      BOOL fGetAllProps = FALSE;

      // If no restrictions return all properties from the three supported property sets
      if ( cPropertyIDSets == 0 )
      {
            fGetAllProps = TRUE;
            
            // only do this once
            if ( ulPropertySets == 0 )
            {
               if( !(dwBitMask &amp; PROPSET_SESSION) )
               {                  
                  if ( !(dwBitMask &amp; PROPSET_ROWSET) )
                  {
                        pPropSet[0].guidPropertySet = DBPROPSET_DBINIT;
                        pPropSet[0].cProperties  = NUMBER_OF_SUPPORTED_DBINIT_PROPERTIES;

                     if( dwBitMask &amp; PROPSET_INIT )
                     {
                        pPropSet[1].guidPropertySet = DBPROPSET_DATASOURCEINFO;
                        pPropSet[1].cProperties  = NUMBER_OF_SUPPORTED_DATASOURCEINFO_PROPERTIES;
                     }
                  }
                  else
                  {
                     pPropSet[0].guidPropertySet = DBPROPSET_ROWSET;
                     pPropSet[0].cProperties  = NUMBER_OF_SUPPORTED_ROWSET_PROPERTIES;
                  }
               }
            }
      }
      else
      {
         pPropSet[ulPropertySets].guidPropertySet = rgPropertyIDSets[ulPropertySets].guidPropertySet;
         pPropSet[ulPropertySets].cProperties  = rgPropertyIDSets[ulPropertySets].cPropertyIDs;

         if( rgPropertyIDSets[ulPropertySets].cPropertyIDs == 0 )
         {
            fGetAllProps = TRUE;

            if( rgPropertyIDSets[ulPropertySets].guidPropertySet == DBPROPSET_DBINIT )
            {
               pPropSet[ulPropertySets].cProperties  = NUMBER_OF_SUPPORTED_DBINIT_PROPERTIES;
            }
            else if( (rgPropertyIDSets[ulPropertySets].guidPropertySet == DBPROPSET_DATASOURCEINFO) &amp;&amp;
                   ((dwBitMask &amp; PROPSET_DSOINIT) == PROPSET_DSOINIT) )
            {
               pPropSet[ulPropertySets].cProperties  = NUMBER_OF_SUPPORTED_DATASOURCEINFO_PROPERTIES;
            }
            else if( (rgPropertyIDSets[ulPropertySets].guidPropertySet == DBPROPSET_ROWSET) &amp;&amp;
                   (dwBitMask &amp; PROPSET_ROWSET))
            {
               pPropSet[ulPropertySets].cProperties  = NUMBER_OF_SUPPORTED_ROWSET_PROPERTIES;
            }
            else
            {
               fGetAllProps = FALSE;
            }
         }
      }
      
      if( pPropSet[ulPropertySets].cProperties )
      {
          // use task memory allocater to alloc array of DBPROPINFO structs
         pProp = (DBPROP*) g_pIMalloc-&gt;Alloc(sizeof( DBPROP ) *
                               pPropSet[ulPropertySets].cProperties);

         if (!pProp)
         {
            for(ULONG ul=0; ul&lt;ulPropertySets; ul++)
            {
               for(ULONG ul2=0; ul2&lt;pPropSet[ul].cProperties; ul2++)
                  VariantClear( &amp;pPropSet[ul].rgProperties[ul2].vValue );

               g_pIMalloc-&gt;Free( pPropSet[ul].rgProperties );
            }
            g_pIMalloc-&gt;Free( pPropSet );

            return ResultFromScode( E_OUTOFMEMORY );
         }
      
         pPropSet[ulPropertySets].rgProperties = &amp;pProp[0];

         memset( pProp, 0, 
            (pPropSet[ulPropertySets].cProperties * sizeof( DBPROP )));
      }

       // for each prop in our table..
      for (cCount=0; cCount &lt; pPropSet[ulPropertySets].cProperties; cCount++)
      {
         // init the Variant right up front
         // that way we can VariantClear with no worried (if we need to)
         VariantInit( &amp;pProp[cCount].vValue );

         // Check supported property sets
         if ( pPropSet[ulPropertySets].guidPropertySet == DBPROPSET_DBINIT &amp;&amp;
             fGetAllProps )
         {
            fPropsSucceed = TRUE;
            // load up their DBPROP from our table
            fRet = LoadDBPROP( &amp;m_rgproperties[START_OF_SUPPORTED_DBINIT_PROPERTIES + cCount], 
                              &amp;pProp[cCount] );
         }
         else if ( pPropSet[ulPropertySets].guidPropertySet == DBPROPSET_DATASOURCEINFO &amp;&amp;
                  fGetAllProps )
         {
            fPropsSucceed = TRUE;
            // load up their DBPROPINFO from our table
            fRet = LoadDBPROP( &amp;m_rgproperties[START_OF_SUPPORTED_DATASOURCEINFO_PROPERTIES + cCount], 
                              &amp;pProp[cCount] );
         }
         else if ( pPropSet[ulPropertySets].guidPropertySet == DBPROPSET_ROWSET &amp;&amp;
                  fGetAllProps )
         {
            fPropsSucceed = TRUE;
            // load up their DBPROPINFO from our table
            fRet = LoadDBPROP( &amp;m_rgproperties[START_OF_SUPPORTED_ROWSET_PROPERTIES + cCount], 
                              &amp;pProp[cCount] );
         }
         else
         {
            ULONG ulIndex;

            pProp[cCount].dwPropertyID   = rgPropertyIDSets[ulPropertySets].rgPropertyIDs[cCount];
            pProp[cCount].dwStatus      = DBPROPSTATUS_NOTSUPPORTED;

            if(  (GetPropIndex(rgPropertyIDSets[ulPropertySets].rgPropertyIDs[cCount], &amp;ulIndex)) &amp;&amp;
                (((dwBitMask &amp; PROPSET_DSO) &amp;&amp; 
                  (rgPropertyIDSets[ulPropertySets].guidPropertySet == DBPROPSET_DBINIT)) ||
                 (((dwBitMask &amp; PROPSET_DSOINIT) == PROPSET_DSOINIT) &amp;&amp;
                  ((rgPropertyIDSets[ulPropertySets].guidPropertySet == DBPROPSET_DATASOURCE) ||
                  (rgPropertyIDSets[ulPropertySets].guidPropertySet == DBPROPSET_DATASOURCEINFO))) ||
                 ((dwBitMask &amp; PROPSET_SESSION) &amp;&amp; 
                  (rgPropertyIDSets[ulPropertySets].guidPropertySet == DBPROPSET_SESSION)) ||
                 ((dwBitMask &amp; PROPSET_ROWSET) &amp;&amp; 
                  (rgPropertyIDSets[ulPropertySets].guidPropertySet == DBPROPSET_ROWSET))) )
            {
               fPropsSucceed = TRUE;
               fRet = LoadDBPROP( &amp;m_rgproperties[ulIndex], &amp;pProp[cCount] );
            }
            else
               fPropsinError = TRUE;
         }

         if (!fRet)
         {
            ULONG ulFor;

            // something went wrong
            // clear all variants used so far..
            for (ulFor = 0; ulFor &lt; cCount; ulFor++)
               VariantClear( &amp;pProp[ulFor].vValue );

            // .. delete the pPropInfo array, return failure
            g_pIMalloc-&gt;Free( pProp );
            g_pIMalloc-&gt;Free( pPropSet );
            return ResultFromScode( E_FAIL );
         }
      }
      // Set local back to FALSE
      fGetAllProps = FALSE;
   }

   // set count of properties and property information
   *pcPropertySets    = cProps;
   *prgPropertySets = pPropSet;

   if ( !fPropsSucceed &amp;&amp; fPropsinError )
      return ResultFromScode( DB_E_ERRORSOCCURRED );
   else if ( fPropsSucceed &amp;&amp; fPropsinError )
      return ResultFromScode( DB_S_ERRORSOCCURRED );
   else
      return ResultFromScode( S_OK );
}</code></pre>
</pre>
</td>
</tr>
</table><br>
<ol>
</ol>
<p>
The source code for <b>SetProperties</b>, which sets the values of all supported properties, follows. The consumer must set properties on the provider before initializing the data source object. In most providers, these properties provide information such as a database location, database name, user ID, and password. The sample provider requires only one value: a valid directory path to the data file.</p>
</BODY>
</HTML>
