<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SQL Data Types</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="odbcsql_data_types"></a>SQL Data Types</h1>
<p>
Each DBMS defines its own SQL types. Each ODBC driver exposes only those SQL data types that the associated DBMS defines. How a driver maps DBMS SQL types to the ODBC-defined SQL type identifiers, and how a driver maps DBMS SQL types to its own driver-specific SQL type identifiers, are returned through a call to <b>SQLGetTypeInfo</b>. A driver also returns the SQL data types when describing the data types of columns and parameters through calls to <b>SQLColAttribute</b>, <b>SQLColumns</b>, <b>SQLDescribeCol</b>, <b>SQLDescribeParam</b>, <b>SQLProcedureColumns</b>, and <b>SQLSpecialColumns</b>. </p>
<p class=indent>
<B><b>Note&nbsp;&nbsp;&nbsp;</b></B>The SQL data types are contained in the SQL_DESC_ CONCISE_TYPE, SQL_DESC_TYPE, and SQL_DESC_DATETIME_INTERVAL_CODE fields of the implementation descriptors. Characteristics of the SQL data types are contained in the SQL_DESC_PRECISION, SQL_DESC_SCALE, SQL_DESC_LENGTH, and SQL_DESC_OCTET_LENGTH fields of the implementation descriptors. For more information, see “<a href="odappdpr_1zeb.htm">Data Type Identifiers and Descriptors</a>” later in this appendix.</p>
<p>
A given driver and data source do not necessarily support all of the SQL data types defined in this appendix. A driver’s support for SQL data types depends upon the level of SQL92 that the driver conforms to. To determine the level of SQL92 grammar supported by the driver, an application calls <b>SQLGetInfo</b> with the SQL_SQL_CONFORMANCE information type. Furthermore, a given driver and data source may support additional, driver-specific SQL data types. To determine which data types a driver supports, an application calls <b>SQLGetTypeInfo</b>. For information about driver-specific SQL data types, see the driver’s documentation. For information about the data types in a specific data source, see the documentation for that data source.</p>
<p class=indent>
<B><b>Important&nbsp;&nbsp;&nbsp;</b></B>The tables throughout this appendix are only a guideline and show commonly used names, ranges, and limits of SQL data types. A given data source may support only some of the listed data types and the characteristics of the supported data types may differ from those listed.</p>
<p>
The following table lists valid SQL type identifiers for all SQL data types. The table also lists the name and description of the corresponding data type from SQL92 (if one exists).</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows width=612>
<tr valign=top>
<td class=label width=33%><b>SQL type identifier [1]</b></td>
<td class=label width=26%><b>Typical SQL data type [2]</b></td>
<td class=label width=41%><b>Typical type description</b></td>
</tr>
<tr valign=top>
<td width=33%>SQL_CHAR</td>
<td width=26%>CHAR(<i>n</i>)</td>
<td width=41%>Character string of fixed string length <i>n</i>.</td>
</tr>
<tr valign=top>
<td width=33%>SQL_VARCHAR</td>
<td width=26%>VARCHAR(<i>n</i>)</td>
<td width=41%>Variable-length character string with a maximum string length <i>n</i>.</td>
</tr>
<tr valign=top>
<td width=33%>SQL_LONGVARCHAR</td>
<td width=26%>LONG VARCHAR</td>
<td width=41%>Variable length character data. Maximum length is data source&nbsp;–&nbsp;dependent. [9]</td>
</tr>
<tr valign=top>
<td width=33%>SQL_WCHAR</td>
<td width=26%>WCHAR(<i>n</i>)</td>
<td width=41%>Unicode character string of fixed string length <i>n</i></td>
</tr>
<tr valign=top>
<td width=33%>SQL_WVARCHAR</td>
<td width=26%>VARWCHAR(n)</td>
<td width=41%>Unicode variable-length character string with a maximum string length n</td>
</tr>
<tr valign=top>
<td width=33%>SQL_WLONGVARCHAR</td>
<td width=26%>LONGWVARCHAR</td>
<td width=41%>Unicode variable-length character data. Maximum length is data source-dependent</td>
</tr>
<tr valign=top>
<td width=33%>SQL_DECIMAL</td>
<td width=26%>DECIMAL(<i>p</i>,<i>s</i>)</td>
<td width=41%>Signed, exact, numeric value with a precision of at least <i>p</i> and scale <i>s. </i>(The maximum precision is driver-defined.)<br>
(1 &lt;= <i>p</i> &lt;= 15; <i>s</i> &lt;= <i>p</i>). [4]<i> </i></td>
</tr>
<tr valign=top>
<td width=33%>SQL_NUMERIC</td>
<td width=26%>NUMERIC(<i>p</i>,<i>s</i>)</td>
<td width=41%>Signed, exact, numeric value with a precision <i>p</i> and scale <i>s</i> <br>
(1 &lt;= <i>p</i> &lt;= 15; <i>s</i> &lt;= <i>p</i>). [4]</td>
</tr>
<tr valign=top>
<td width=33%>SQL_SMALLINT</td>
<td width=26%>SMALLINT</td>
<td width=41%>Exact numeric value with precision 5 and scale 0 (signed: –32,768 &lt;= <i>n</i> &lt;= 32,767, unsigned: <br>
0 &lt;= <i>n</i> &lt;= 65,535) [3] .</td>
</tr>
<tr valign=top>
<td width=33%>SQL_INTEGER</td>
<td width=26%>INTEGER</td>
<td width=41%>Exact numeric value with precision 10 and scale 0 (signed: –2[31] &lt;= <i>n</i> &lt;= 2[31] – 1, unsigned: 0 &lt;= <i>n</i> &lt;= 2[32] – 1) [3] .</td>
</tr>
<tr valign=top>
<td width=33%>SQL_REAL</td>
<td width=26%>REAL</td>
<td width=41%>Signed, approximate, numeric value with a binary precision 24 (zero or absolute value 10[–38] to 10[38]). </td>
</tr>
<tr valign=top>
<td width=33%>SQL_FLOAT</td>
<td width=26%>FLOAT(<i>p</i>)</td>
<td width=41%>Signed, approximate, numeric value with a binary precision of at least p. (The maximum precision is driver-defined.) [5]</td>
</tr>
<tr valign=top>
<td width=33%>SQL_DOUBLE</td>
<td width=26%>DOUBLE<br>
PRECISION</td>
<td width=41%>Signed, approximate, numeric value with a binary precision 53 (zero or absolute value 10[–308] to 10[308]).</td>
</tr>
<tr valign=top>
<td width=33%>SQL_BIT</td>
<td width=26%>BIT</td>
<td width=41%>Single bit binary data. [8]</td>
</tr>
<tr valign=top>
<td width=33%>SQL_TINYINT</td>
<td width=26%>TINYINT</td>
<td width=41%>Exact numeric value with precision 3 and scale 0 (signed: –128 &lt;= <i>n</i> &lt;= 127, unsigned: 0 &lt;= <i>n</i> &lt;= 255) [3] .</td>
</tr>
<tr valign=top>
<td width=33%>SQL_BIGINT</td>
<td width=26%>BIGINT</td>
<td width=41%>Exact numeric value with precision 19 (if signed) or 20 (if unsigned) and scale 0 (signed: –2[63] &lt;= <i>n</i> &lt;= 2[63] – 1, unsigned:&nbsp; 0 &lt;= <i>n</i> &lt;= 2[64] – 1) [3], [9].</td>
</tr>
<tr valign=top>
<td width=33%>SQL_BINARY</td>
<td width=26%>BINARY(<i>n</i>)</td>
<td width=41%>Binary data of fixed length <i>n</i>. [9]</td>
</tr>
<tr valign=top>
<td width=33%>SQL_VARBINARY</td>
<td width=26%>VARBINARY(<i>n</i>)</td>
<td width=41%>Variable length binary data of maximum length <i>n</i>. The maximum is set by the user. [9]</td>
</tr>
<tr valign=top>
<td width=33%>SQL_LONGVARBINARY</td>
<td width=26%>LONG VARBINARY</td>
<td width=41%>Variable length binary data. Maximum length is data source&nbsp;–&nbsp;dependent. [9]</td>
</tr>
<tr valign=top>
<td width=33%>SQL_TYPE_DATE [6]</td>
<td width=26%>DATE</td>
<td width=41%>Year, month, and day fields, conforming to the rules of the Gregorian calendar (see "<a href="odappdpr_7z1u.htm">Constraints of the Gregorian Calendar</a>" later in this appendix).</td>
</tr>
<tr valign=top>
<td width=33%>SQL_TYPE_TIME [6]</td>
<td width=26%>TIME(p)</td>
<td width=41%>Hour, minute, and second fields, with valid values for hours of 00 to 23, valid values for minutes of 00 to 59, and valid values for seconds of 00 to 61. Precision p indicates the seconds precision. </td>
</tr>
<tr valign=top>
<td width=33%>SQL_TYPE_TIMESTAMP [6]</td>
<td width=26%>TIMESTAMP(p)</td>
<td width=41%>Year, month, day, hour, minute, and second fields, with valid values as defined for the DATE and TIME data types.</td>
</tr>
<tr valign=top>
<td width=33%>SQL_INTERVAL_<br>
MONTH [7]</td>
<td width=26%>INTERVAL MONTH(p)</td>
<td width=41%>Number of months between two dates; p is the interval leading precision.</td>
</tr>
<tr valign=top>
<td width=33%>SQL_INTERVAL_YEAR [7]</td>
<td width=26%>INTERVAL YEAR(p)</td>
<td width=41%>Number of years between two dates; p is the interval leading precision.</td>
</tr>
<tr valign=top>
<td width=33%>SQL_INTERVAL_YEAR_<br>
TO_MONTH [7]</td>
<td width=26%>INTERVAL YEAR(p) TO MONTH</td>
<td width=41%>Number of years and months between two dates; p is the interval leading precision.</td>
</tr>
<tr valign=top>
<td width=33%>SQL_INTERVAL_DAY [7]</td>
<td width=26%>INTERVAL DAY(p)</td>
<td width=41%>Number of days between two dates; p is the interval leading precision.</td>
</tr>
<tr valign=top>
<td width=33%>SQL_INTERVAL_HOUR [7]</td>
<td width=26%>INTERVAL HOUR(p)</td>
<td width=41%>Number of hours between two date/times; p is the interval leading precision.</td>
</tr>
<tr valign=top>
<td width=33%>SQL_INTERVAL_<br>
MINUTE [7]</td>
<td width=26%>INTERVAL MINUTE(p)</td>
<td width=41%>Number of minutes between two date/times; p is the interval leading precision.</td>
</tr>
<tr valign=top>
<td width=33%>SQL_INTERVAL_<br>
SECOND [7]</td>
<td width=26%>INTERVAL SECOND(p,q)</td>
<td width=41%>Number of seconds between two date/times; p is the interval leading precision and q is the interval seconds precision.</td>
</tr>
<tr valign=top>
<td width=33%>SQL_INTERVAL_DAY_<br>
TO_HOUR [7]</td>
<td width=26%>INTERVAL DAY(p) TO HOUR</td>
<td width=41%>Number of days/hours between two date/times; p is the interval leading precision.</td>
</tr>
<tr valign=top>
<td width=33%>SQL_INTERVAL_DAY_<br>
TO_MINUTE [7]</td>
<td width=26%>INTERVAL DAY(p) TO MINUTE</td>
<td width=41%>Number of days/hours/minutes between two date/times; p is the interval leading precision.</td>
</tr>
<tr valign=top>
<td width=33%>SQL_INTERVAL_DAY_<p>
TO_SECOND [7]</p>
</td>
<td width=26%>INTERVAL DAY(p) TO SECOND(q)</td>
<td width=41%>Number of days/hours/minutes/seconds between two date/times; p is the interval leading precision and q is the interval seconds precision.</td>
</tr>
<tr valign=top>
<td width=33%>SQL_INTERVAL_HOUR_<p>
TO_MINUTE [7]</p>
</td>
<td width=26%>INTERVAL HOUR(p) TO MINUTE</td>
<td width=41%>Number of hours/minutes between two date/times; p is the interval leading precision.</td>
</tr>
<tr valign=top>
<td width=33%>SQL_INTERVAL_HOUR_<p>
TO_SECOND [7]</p>
</td>
<td width=26%>INTERVAL HOUR(p) TO SECOND(q)</td>
<td width=41%>Number of hours/minutes/seconds between two date/times; p is the interval leading precision and q is the interval seconds precision.</td>
</tr>
<tr valign=top>
<td width=33%>SQL_INTERVAL_</td>
<td width=26%>INTERVAL MINUTE(p) TO SECOND(q)</td>
<td width=41%>Number of minutes/seconds between two date/times; p is the interval leading precision and q is the interval seconds precision.</td>
</tr>
<tr valign=top>
<td width=33%>MINUTE_TO_SECOND [7]</td>
<td width=26%>INTERVAL MINUTE(p) TO SECOND(q)</td>
<td width=41%>Number of minutes/seconds between two date/times; p is the interval leading precision and q is the interval seconds precision.</td>
</tr>
<tr valign=top>
<td width=33%>SQL_GUID</td>
<td width=26%>GUID</td>
<td width=41%>Fixed length Globally Unique Identifier.</td>
</tr>
</table><br>
<p class=mini>
[1]This is the value returned in the DATA_TYPE column by a call to <b>SQLGetTypeInfo</b>.</p>
<p class=mini>
[2]This is the value returned in the NAME and CREATE PARAMS column by a call to <b>SQLGetTypeInfo</b>. The NAME column returns the designation; for example, CHAR, while the CREATE PARAMS column returns a comma-separated list of creation parameters such as precision, scale, and length.</p>
<p class=mini>
[3]An application uses <b>SQLGetTypeInfo</b> or <b>SQLColAttribute</b> to determine if a particular data type or a particular column in a result set is unsigned. </p>
<p class=mini>
[4]SQL_DECIMAL and SQL_NUMERIC data types differ only in their precision. The precision of a DECIMAL(p,s) is an implementation-defined decimal precision that is no less than p, while the precision of a NUMERIC(p,s) is exactly equal to p. </p>
<p class=mini>
[5]Depending on the implementation, the precision of SQL_FLOAT can be either 24 or 53: if it is 24, the SQL_FLOAT data type is the same as SQL_REAL, if it is 53, the SQL_FLOAT data type is the same as SQL_DOUBLE. </p>
<p class=mini>
[6]In ODBC 3.x, the SQL date, time, and timestamp data types are SQL_TYPE_DATE, SQL_TYPE_TIME, and SQL_TYPE_TIMESTAMP, respectively; in ODBC 2.<i>x</i>, the data types are SQL_DATE, SQL_TIME, and SQL_TIMESTAMP. </p>
<p class=mini>
[7]For more information on the interval SQL data types, see the “<a href="odappdpr_30s3.htm">Interval Data Types</a>” section later in this appendix. </p>
<p class=mini>
[8]The SQL_BIT data type has different characteristics than the BIT type in SQL92. </p>
<p class=mini>
[9]This data type has no corresponding data type in SQL92.</p>
</font></BODY>
</HTML>
