<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Processing Positioned Update and Delete Statements</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h3><a name="odbcprocessing_positioned_update_and_delete_statements"></a>Processing Positioned Update and Delete Statements</h3>
<p>
The cursor library supports positioned update and delete statements by replacing the <b>WHERE CURRENT OF</b> clause in such statements with a <b>WHERE</b> clause that enumerates the values stored in its cache for each bound column. The cursor library passes the newly constructed <b>UPDATE</b> and <b>DELETE</b> statements to the driver for execution. For positioned update statements, it then updates its cache from the values in the rowset buffers and sets the corresponding value in the row status array to SQL_ROW_UPDATED. For positioned delete statements, it sets the corresponding value in the row status array to SQL_ROW_DELETED.</p>
<p class=indent>
<B><b>Caution</b></B> The <b>WHERE</b> clause constructed by the cursor library to identify the current row can fail to identify any rows, identify a different row, or identify more than one row. For more information, see “<a href="odappfpr_701f.htm">Constructing Searched Statements</a>” later in this appendix.</p>
<p>
Positioned update and delete statements are subject to the following restrictions:
<ul type=disc>
<li>
Positioned update and delete statements can only be used when a <b>SELECT</b> statement generated the result set, the <b>SELECT</b> statement did not contain a join, a <b>UNION</b> clause, or a <b>GROUP BY</b> clause, and any columns that used an alias or expression in the select list were not bound with <b>SQLBindCol</b>.<br><br></li>
<li>
If an application prepares a positioned update or delete statement, it must do so after it has called <b>SQLFetch</b> or <b>SQLFetchScroll</b>. Although the cursor library submits the statement to the driver for preparation, it closes the statement and executes it directly when the application calls <b>SQLExecute</b>.<br><br></li>
<li>
If the driver only supports one active statement, the cursor library fetches the rest of the result set and then refetches the current rowset from its cache before it executes a positioned update or delete statement. If the application then calls a function that returns metadata in a result set (for example, <b>SQLNumResultCols</b> or <b>SQLDescribeCol</b>), the cursor library returns an error.<br><br></li>
<li>
If a positioned update or delete statement is performed on a column of a table that includes a timestamp column that is automatically updated every time an update is performed, all subsequent positioned update or delete statements will fail if the timestamp column is bound. This occurs because the searched update or delete statement that the Cursor Library creates will not accurately identify the row to update. The value in the searched statement for the timestamp column will not match the automatically updated value of the timestamp column.</li>
</ul>
</font></BODY>
</HTML>
