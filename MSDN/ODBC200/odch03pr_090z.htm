<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Other Driver Architectures</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h3><a name="odbcother_driver_architectures"></a>Other Driver Architectures</h3>
<p>
Some ODBC drivers do not strictly conform to the architecture described previously. This may be because the drivers perform duties other than those of a traditional ODBC driver, or are not drivers in the normal sense.</p>
<h4>The Driver as a Middle Component</h4>
<p>
The ODBC driver may reside between the Driver Manager and one or more other ODBC drivers. When the driver in the middle is capable of working with multiple data sources, it acts as a dispatcher of ODBC calls (or appropriately translated calls) to other modules that actually access the data sources. In this architecture, the driver in the middle is taking on some of the role of a Driver Manager.</p>
<p>
Another example of this sort of driver is a spy program for ODBC, which intercepts and copies ODBC functions being sent between the Driver Manager and the driver. This layer can be used to emulate either a driver or an application. To the Driver Manager, the layer appears to be the driver; to the driver, the layer appears to be the Driver Manager. </p>
<h4>Heterogeneous Join Engines</h4>
<p>
Some ODBC drivers are built upon a query engine for performing heterogeneous joins. In one architecture of a heterogeneous join engine (see the following figure), the driver appears to the application as a driver, but appears to another instance of the Driver Manager as an application. This driver processes a heterogeneous join from the application by calling separate SQL statements in drivers for each joined database.</p>
<p>
<img src="fig3-4.gif" border=0></p>
<p class=label>
<b>Heterogeneous join engine architecture</b></p>
<p>
This architecture provides a common interface for the application to access data from different databases. It can use a common way to retrieve metadata, such as information about special columns (row identifiers), and it can call common catalog functions to retrieve data dictionary information. By calling the ODBC function <b>SQLStatistics</b>, for instance, the application can retrieve information about the indexes on the tables to be joined, even if the tables are on two separate databases. The query processor does not have to worry about how the databases store metadata.</p>
<p>
The application also has standard access to data types. ODBC defines common SQL data types that DBMS-specific data types are mapped to. An application can call <b>SQLGetTypeInfo</b> to retrieve information about data types on different databases.</p>
<p>
When the application generates a heterogeneous join statement, the query processor in this architecture parses the SQL statement, then generates separate SQL statements for each database to be joined. By using metadata about each driver, the query processor can determine the most efficient, intelligent join. For example, if the statement joins two tables on one database with one table on another database, the query processor can join the two tables on the one database before joining the result with the table from the other database. </p>
<h4>ODBC on the Server</h4>
<p>
ODBC drivers can be installed on a server so that they can be used by applications on any of a series of client machines. In this architecture (see the following figure), a Driver Manager and a single ODBC driver are installed on each client, and another Driver Manager and a series of ODBC drivers are installed on the server. This allows each client access to a variety of drivers used and maintained on the server.</p>
<p>
<img src="fig3-5.gif" border=0></p>
<p class=label>
<b>ODBC on the server</b></p>
<p>
One advantage of this architecture is efficient software maintenance and configuration. Drivers need only be updated in one place: on the server. By using system data sources, data sources can be defined on the server for use by all clients. The data sources need not be defined on the client. Connection pooling can be used to streamline the process by which clients connect to data sources.</p>
<p>
The driver on the client is generally a very small driver that transfers the Driver Manager call to the server. Its footprint can be significantly smaller than the fully functional ODBC drivers on the server. In this architecture, client resources can be freed if the server has more computing power. In addition, the efficiency and security of the entire system can be enhanced by installing backup servers and performing load balancing to optimize server use.</p>
</font></BODY>
</HTML>
