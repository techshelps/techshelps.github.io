<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Allocating and Freeing Buffers</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h2><a name="odbcallocating_and_freeing_buffers"></a>Allocating and Freeing Buffers</h2>
<p>
All buffers are allocated and freed by the application. If a buffer is not deferred, it need only exist for the duration of the call to a function. For example, <b>SQLGetInfo</b> returns the value associated with a particular option in the buffer pointed to by the <i>InfoValuePtr</i> argument. This buffer can be freed immediately after the call to <b>SQLGetInfo</b>, as shown in the following code example:</p>
<pre><code>SQLSMALLINT InfoValueLen;
SQLCHAR&nbsp;&nbsp; *InfoValuePtr = malloc(50);&nbsp; // Allocate InfoValuePtr.

SQLGetInfo(hdbc, SQL_DBMS_NAME, (SQLPOINTER)InfoValuePtr, 50,
 &nbsp;&nbsp;&nbsp; &amp;InfoValueLen);

free(InfoValuePtr);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // OK to free InfoValuePtr.
</code></pre>
<p>
Because deferred buffers are specified in one function and used in another, it is an application programming error to free a deferred buffer while the driver still expects it to exist. For example, the address of the *<i>ValuePtr</i> buffer is passed to <b>SQLBindCol</b> for later use by <b>SQLFetch</b>. This buffer cannot be freed until the column is unbound, such as with a call to <b>SQLBindCol</b> or <b>SQLFreeStmt</b> as shown in the following code example:</p>
<pre><code>SQLRETURN rc;
SQLINTEGER&nbsp; ValueLenOrInd;
SQLHSTMT&nbsp; hstmt;

// Allocate ValuePtr
SQLCHAR&nbsp; *ValuePtr = malloc(50);

// Bind ValuePtr to column 1. It is an error to free ValuePtr here.
SQLBindCol(hstmt, 1, SQL_C_CHAR, ValuePtr, 50, &amp;ValueLenOrInd);

// Fetch each row of data and place the value for column 1 in *ValuePtr. Code
// to check if rc equals SQL_ERROR or SQL_SUCCESS_WITH_INFO not shown.
while ((rc = SQLFetch(hstmt)) != SQL_NO_DATA) {
 // It is an error to free ValuePtr here.
}

// Unbind ValuePtr from column 1.&nbsp; It is now OK to free ValuePtr.
SQLFreeStmt(hstmt, SQL_UNBIND);
free(ValuePtr);
</code></pre>
<p>
Such an error is easily made by declaring the buffer locally in a function; the buffer is freed when the application leaves the function. For example, the following code causes undefined and probably fatal behavior in the driver:</p>
<pre><code>SQLRETURN rc; 
SQLHSTMT&nbsp; hstmt;

BindAColumn(hstmt);

// Fetch each row of data and try to place the value for column 1 in *ValuePtr. Because
// ValuePtr has been freed, the behavior is undefined and probably fatal. Code to check
// if rc equals SQL_ERROR or SQL_SUCCESS_WITH_INFO not shown.
while ((rc = SQLFetch(hstmt)) != SQL_NO_DATA) {}

 .
 .
 .

void BindAColumn(SQLHSTMT hstmt)&nbsp; // WARNING! This function won't work!
{
 // Declare ValuePtr locally.
 SQLCHAR&nbsp; ValuePtr[50];
 SQLINTEGER ValueLenOrInd;

 // Bind rgbValue to column.
 SQLBindCol(hstmt, 1, SQL_C_CHAR, ValuePtr, sizeof(ValuePtr), &amp;ValueLenOrInd);

 // ValuePtr is freed when BindAColumn exits.
}
</code></pre>
</font></BODY>
</HTML>
