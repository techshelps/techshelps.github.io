<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SQLDescribeParam</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="odbcsqldescribeparam"></a>SQLDescribeParam</h1>
<p class=label>
<b>Conformance</b></p>
<p>
Version Introduced:ODBC 1.0<br>
Standards Compliance:ODBC</p>
<p class=label>
<b>Summary</b></p>
<p>
<b>SQLDescribeParam</b> returns the description of a parameter marker associated with a prepared SQL statement. This information is also available in the fields of the IPD.</p>
<p class=label>
<b>Syntax</b></p>
<p>
SQLRETURN <b>SQLDescribeParam</b>(<br>
SQLHSTMT<i>StatementHandle</i>,<br>
SQLUSMALLINT<i>ParameterNumber</i>,<br>
SQLSMALLINT *<i>DataTypePtr</i>,<br>
SQLUINTEGER *<i>ParameterSizePtr</i>,<br>
SQLSMALLINT *<i>DecimalDigitsPtr</i>,<br>
SQLSMALLINT *<i>NullablePtr</i>);</p>
<p class=label>
<b>Argument</b></p>
<p class=dt>
<i>StatementHandle</i></p>
<p class=indent>
[Input]<br>
Statement handle.</p>
<p class=dt>
<i>ParameterNumber</i></p>
<p class=indent>
[Input]<br>
Parameter marker number ordered sequentially in increasing parameter order, starting at 1.</p>
<p class=dt>
<i>DataTypePtr</i></p>
<p class=indent>
[Output]<br>
Pointer to a buffer in which to return the SQL data type of the parameter. This value is read from the SQL_DESC_CONCISE_TYPE record field of the IPD. This will be one of the values in the “<a href="odappdpr_8fcj.htm">SQL Data Types</a>” section of Appendix D, “Data Types,” or a driver-specific SQL data type.</p>
<p class=tl>
In ODBC 3.x, SQL_TYPE_DATE, SQL_TYPE_TIME, or SQL_TYPE_TIMESTAMP will be returned in <i>*DataTypePtr</i> for date, time, or timestamp data, respectively; in ODBC 2<i>.x</i>, SQL_DATE, SQL_TIME, or SQL_TIMESTAMP will be returned. The Driver Manager performs the required mappings when an ODBC 2.<i>x</i> application is working with an ODBC 3.x driver, or an ODBC 3.x application is working with an ODBC 2.<i>x</i> driver.</P><p class=tl>
When <i>ColumnNumber</i> is equal to 0 (for a bookmark column), SQL_BINARY is returned in <i>*DataTypePtr</i> for variable-length bookmarks. (SQL_INTEGER is returned if bookmarks are used by an ODBC 3.x application working with an ODBC 2.<i>x</i> driver, or an ODBC 2.<i>x</i> application working with an ODBC 3.x driver.)</P><p class=tl>
For more information, see “<a href="odappdpr_8fcj.htm">SQL Data Types</a>” in Appendix D, “Data Types.” For information about driver-specific SQL data types, see the driver’s documentation.</P><p class=dt>
<i>ParameterSizePtr</i></p>
<p class=indent>
[Output]<br>
Pointer to a buffer in which to return the size of the column or expression of the corresponding parameter marker as defined by the data source. For further information concerning column size, see “<a href="odappdpr_7ch1.htm">Column Size, Decimal Digits, Transfer Octet Length, and Display Size</a>,” in Appendix D, “Data Types.”</p>
<p class=dt>
<i>DecimalDigitsPtr</i></p>
<p class=indent>
[Output]<br>
Pointer to a buffer in which to return the number of decimal digits of the column or expression of the corresponding parameter as defined by the data source. For more information on decimal digits, see “<a href="odappdpr_7ch1.htm">Column Size, Decimal Digits, Transfer Octet Length, and Display Size</a>,” in Appendix D, “Data Types.”</p>
<p class=dt>
<i>NullablePtr</i></p>
<p class=indent>
[Output]<br>
Pointer to a buffer in which to return a value that indicates whether the parameter allows NULL values. This value is read from the SQL_DESC_NULLABLE field of the IPD. One of the following:
<ul type=disc>
<li>
SQL_NO_NULLS: The parameter does not allow NULL values (this is the default value).<br><br></li>
<li>
SQL_NULLABLE: The parameter allows NULL values.<br><br></li>
<li>
SQL_NULLABLE_UNKNOWN: The driver cannot determine if the parameter allows NULL values.</li>
</ul>
<p class=label>
<b>Returns</b></p>
<p>
SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_STILL_EXECUTING, SQL_ERROR, or SQL_INVALID_HANDLE.</p>
<p class=label>
<b>Diagnostics</b></p>
<p>
When <b>SQLDescribeParam</b> returns SQL_ERROR or SQL_SUCCESS_WITH_INFO, an associated SQLSTATE value may be obtained by calling <b>SQLGetDiagRec</b> with a <i>HandleType</i> of SQL_HANDLE_STMT and a <i>Handle</i> of <i>StatementHandle</i>. The following table lists the SQLSTATE values commonly returned by <b>SQLDescribeParam</b> and explains each one in the context of this function; the notation “(DM)” precedes the descriptions of SQLSTATEs returned by the Driver Manager. The return code associated with each SQLSTATE value is SQL_ERROR, unless noted otherwise.</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=22%><b>SQLSTATE</b></td>
<td class=label width=26%><b>Error</b></td>
<td class=label width=52%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=22%>01000</td>
<td width=26%>General warning</td>
<td width=52%>Driver-specific informational message. (Function returns SQL_SUCCESS_WITH_INFO.)</td>
</tr>
<tr valign=top>
<td width=22%>07009</td>
<td width=26%>Invalid descriptor index</td>
<td width=52%>(DM) The value specified for the argument <i>ParameterNumber</i> is less than 1.<p>
The value specified for the argument <i>ParameterNumber</i> was greater than the number of parameters in the associated SQL statement.</p>
<p>
The parameter marker was part of a non-DML statement.</p>
<p>
The parameter marker was part of a <b>SELECT</b> list.</p>
</td>
</tr>
<tr valign=top>
<td width=22%>08S01</td>
<td width=26%>Communication link failure</td>
<td width=52%>The communication link between the driver and the data source to which the driver was connected failed before the function completed processing.</td>
</tr>
<tr valign=top>
<td width=22%>21S01</td>
<td width=26%>Insert value list does not match column list</td>
<td width=52%>The number of parameters in the <b>INSERT</b> statement did not match the number of columns in the table named in the statement.</td>
</tr>
<tr valign=top>
<td width=22%>HY000</td>
<td width=26%>General error</td>
<td width=52%>An error occurred for which there was no specific SQLSTATE and for which no implementation-specific SQLSTATE was defined. The error message returned by <b>SQLGetDiagRec</b> in the <i>*MessageText</i> buffer describes the error and its cause.</td>
</tr>
<tr valign=top>
<td width=22%>HY001</td>
<td width=26%>Memory allocation error</td>
<td width=52%>The driver was unable to allocate memory required to support execution or completion of the function.</td>
</tr>
<tr valign=top>
<td width=22%>HY008</td>
<td width=26%>Operation canceled</td>
<td width=52%>Asynchronous processing was enabled for the <i>StatementHandle</i>. The function was called and, before it completed execution, <b>SQLCancel</b> was called on the <i>StatementHandle</i>. Then the function was called again on the <i>StatementHandle</i>.<p>
The function was called and, before it completed execution, <b>SQLCancel</b> was called on the <i>StatementHandle</i> from a different thread in a multithread application.</p>
</td>
</tr>
<tr valign=top>
<td width=22%>HY010</td>
<td width=26%>Function sequence error</td>
<td width=52%>(DM) The function was called prior to calling <b>SQLPrepare</b> or <b>SQLExecDirect</b> for the <i>StatementHandle</i>.<p>
(DM) An asynchronously executing function (not this one) was called for the <i>StatementHandle</i> and was still executing when this function was called.</p>
<p>
(DM) <b>SQLExecute</b>, <b>SQLExecDirect</b>, <b>SQLBulkOperations</b>, or <b>SQLSetPos</b> was called for the <i>StatementHandle</i> and returned SQL_NEED_DATA. This function was called before data was sent for all data-at-execution parameters or columns.</p>
</td>
</tr>
<tr valign=top>
<td width=22%>HY013</td>
<td width=26%>Memory management error</td>
<td width=52%>The function call could not be processed because the underlying memory objects could not be accessed, possibly because of low memory conditions.</td>
</tr>
<tr valign=top>
<td width=22%>HYT01</td>
<td width=26%>Connection timeout expired</td>
<td width=52%>The connection timeout period expired before the data source responded to the request. The connection timeout period is set through <b>SQLSetConnectAttr</b>, SQL_ATTR_CONNECTION_TIMEOUT.</td>
</tr>
<tr valign=top>
<td width=22%>IM001</td>
<td width=26%>Driver does not support this function</td>
<td width=52%>(DM) The driver associated with the <i>StatementHandle</i> does not support the function.</td>
</tr>
</table><br>
<p class=label>
<b>Comments</b></p>
<p>
Parameter markers are numbered in increasing parameter order, starting with 1, in the order they appear in the SQL statement.</p>
<p>
<b>SQLDescribeParam</b> does not return the type (input, input/output, or output) of a parameter in an SQL statement. Except in calls to procedures, all parameters in SQL statements are input parameters. To determine the type of each parameter in a call to a procedure, an application calls <b>SQLProcedureColumns</b>.</p>
<p>
For more information, see “<a href="odch09pr_254j.htm">Describing Parameters</a>” in Chapter 9, “Executing Statements.”</p>
<p class=label>
<b>Code Example</b></p>
<p>
The following example prompts the user for an SQL statement and then prepares that statement. Next, it calls <b>SQLNumParams</b> to determine if the statement contains any parameters. If so, it calls <b>SQLDescribeParam</b> to describe those parameters and <b>SQLBindParameter</b> to bind them. Finally, it prompts the user for the values of any parameters and then executes the statement.</p>
<pre><code>SQLCHAR&nbsp;&nbsp; Statement[100];
SQLSMALLINT NumParams, i, DataType, DecimalDigits, Nullable;
SQLUINTEGER ParamSize;
SQLHSTMT&nbsp; hstmt;

// Prompt the user for an SQL statement and prepare it.
GetSQLStatement(Statement);
SQLPrepare(hstmt, Statement, SQL_NTS);

// Check to see if there are any parameters. If so, process them.
SQLNumParams(hstmt, &amp;NumParams);
if (NumParams) {
 // Allocate memory for three arrays. The first holds pointers to buffers in which
 // each parameter value will be stored in character form. The second contains the
 // length of each buffer. The third contains the length/indicator value for each
 // parameter.
 SQLPOINTER * PtrArray = (SQLPOINTER *) malloc(NumParams * sizeof(SQLPOINTER));
 SQLINTEGER * BufferLenArray (SQLINTEGER *) malloc(NumParams * sizeof(SQLINTEGER));
 SQLINTEGER * LenOrIndArray = (SQLINTEGER *) malloc(NumParams * sizeof(SQLINTEGER));

 for (i = 0; i &lt; NumParams; i++) {
  // Describe the parameter.
  SQLDescribeParam(hstmt, i + 1, &amp;DataType, &amp;ParamSize, &amp;DecimalDigits, &amp;Nullable);

  // Call a helper function to allocate a buffer in which to store the parameter
  // value in character form. The function determines the size of the buffer from
  // the SQL data type and parameter size returned by SQLDescribeParam and returns
  // a pointer to the buffer and the length of the buffer.
  AllocParamBuffer(DataType, ParamSize, &amp;PtrArray[i], &amp;BufferLenArray[i]);

  // Bind the memory to the parameter. Assume that we only have input parameters.
  SQLBindParameter(hstmt, i + 1, SQL_PARAM_INPUT, SQL_C_CHAR, DataType, ParamSize,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DecimalDigits, PtrArray[i], BufferLenArray[i],
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;LenOrIndArray[i]);

  // Prompt the user for the value of the parameter and store it in the memory
  // allocated earlier. For simplicity, this function does not check the value
  // against the information returned by SQLDescribeParam. Instead, the driver does
  // this when the statement is executed.
  GetParamValue(PtrArray[i], BufferLenArray[i], &amp;LenOrIndArray[i]);
 }
}

// Execute the statement.
SQLExecute(hstmt);

// Process the statement further, such as retrieving results (if any) and closing the
// cursor (if any). Code not shown.

// Free the memory allocated for each parameter and the memory allocated for the arrays
// of pointers, buffer lengths, and length/indicator values.
for (i = 0; i &lt; NumParams; i++) free(PtrArray[i]);
free(PtrArray);
free(BufferLenArray);
free(LenOrIndArray);
</code></pre>
<p class=label>
<b>Related Functions</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=48%><b>For information about</b></td>
<td class=label width=52%><b>See</b></td>
</tr>
<tr valign=top>
<td width=48%>Binding a buffer to a parameter</td>
<td width=52%><a href="odch21bpr_6jhu.htm">SQLBindParameter</a></td>
</tr>
<tr valign=top>
<td width=48%>Canceling statement processing</td>
<td width=52%><a href="odch21bpr_5b58.htm">SQLCancel</a></td>
</tr>
<tr valign=top>
<td width=48%>Executing a prepared SQL statement</td>
<td width=52%><a href="odch21epr_0yg5.htm">SQLExecute</a></td>
</tr>
<tr valign=top>
<td width=48%>Preparing a statement for execution</td>
<td width=52%><a href="odch21ipr_3td1.htm">SQLPrepare</a></td>
</tr>
</table><br>
</font></BODY>
</HTML>
