<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>C Data Types</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="odbcc_data_types"></a>C Data Types</h1>
<p>
ODBC C data types indicate the data type of C buffers used to store data in the application. </p>
<p>
All drivers must support all C data types. This is required because all drivers must support all C types to which SQL types that they support can be converted, and all drivers support at least one character SQL type. Because the character SQL type can be converted to and from all C types, all drivers must support all C types.</p>
<p>
The C data type is specified in the <b>SQLBindCol </b>and <b>SQLGetData</b> functions with the <i>TargetType</i> argument and in the <b>SQLBindParameter</b> function with the <i>ValueType</i> argument. It can also be specified by calling <b>SQLSetDescField</b> to set the SQL_DESC_CONCISE_TYPE field of an ARD or APD, or by calling <b>SQLSetDescRec</b> with the <i>Type</i> argument (and the <i>SubType</i> argument if needed) and the <i>DescriptorHandle</i> argument set to the handle of an ARD or APD.</p>
<p>
The following table lists valid type identifiers for the C data types. The table also lists the ODBC C data type that corresponds to each identifier and the definition of this data type.</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows width=600>
<tr valign=top>
<td class=label width=29%><b>C type identifier</b></td>
<td class=label width=30%><b>ODBC C typedef</b></td>
<td class=label width=41%><b>C type</b></td>
</tr>
<tr valign=top>
<td width=29%>SQL_C_CHAR</td>
<td width=30%>SQLCHAR *</td>
<td width=41%>unsigned char *</td>
</tr>
<tr valign=top>
<td width=29%>SQL_C_SSHORT [j]</td>
<td width=30%>SQLSMALLINT</td>
<td width=41%>short int</td>
</tr>
<tr valign=top>
<td width=29%>SQL_C_USHORT [j]</td>
<td width=30%>SQLUSMALLINT</td>
<td width=41%>unsigned short int</td>
</tr>
<tr valign=top>
<td width=29%>SQL_C_SLONG [j]</td>
<td width=30%>SQLINTEGER</td>
<td width=41%>long int</td>
</tr>
<tr valign=top>
<td width=29%>SQL_C_ULONG [j]</td>
<td width=30%>SQLUINTEGER</td>
<td width=41%>unsigned long int</td>
</tr>
<tr valign=top>
<td width=29%>SQL_C_FLOAT</td>
<td width=30%>SQLREAL</td>
<td width=41%>float</td>
</tr>
<tr valign=top>
<td width=29%>SQL_C_DOUBLE</td>
<td width=30%>SQLDOUBLE, SQLFLOAT</td>
<td width=41%>double</td>
</tr>
<tr valign=top>
<td width=29%>SQL_C_BIT</td>
<td width=30%>SQLCHAR</td>
<td width=41%>unsigned char</td>
</tr>
<tr valign=top>
<td width=29%> SQL_C_STINYINT [j]</td>
<td width=30%>SQLSCHAR</td>
<td width=41%>signed char</td>
</tr>
<tr valign=top>
<td width=29%>SQL_C_UTINYINT [j]</td>
<td width=30%>SQLCHAR</td>
<td width=41%>unsigned char</td>
</tr>
<tr valign=top>
<td width=29%>SQL_C_SBIGINT</td>
<td width=30%>SQLBIGINT</td>
<td width=41%>_int64 [h]</td>
</tr>
<tr valign=top>
<td width=29%>SQL_C_UBIGINT</td>
<td width=30%>SQLUBIGINT</td>
<td width=41%>unsigned _int64 [h]</td>
</tr>
<tr valign=top>
<td width=29%>SQL_C_BINARY</td>
<td width=30%>SQLCHAR *</td>
<td width=41%>unsigned char *</td>
</tr>
<tr valign=top>
<td width=29%>SQL_C_BOOKMARK [i]</td>
<td width=30%>BOOKMARK</td>
<td width=41%>unsigned long int [d]</td>
</tr>
<tr valign=top>
<td width=29%>SQL_C_VAR-<br>
BOOKMARK</td>
<td width=30%>SQLCHAR *</td>
<td width=41%>unsigned char *</td>
</tr>
<tr valign=top>
<td width=29%>SQL_C_TYPE_DATE [c]</td>
<td width=30%>SQL_DATE_STRUCT</td>
<td width=41%>struct tagDATE_STRUCT {<br>
  SQLSMALLINT year; <br>
  SQLUSMALLINT month; <br>
  SQLUSMALLINT day; <br>
} DATE_STRUCT; [a]</td>
</tr>
<tr valign=top>
<td width=29%>SQL_C_TYPE_TIME [c]</td>
<td width=30%>SQL_TIME_STRUCT</td>
<td width=41%>struct tagTIME_STRUCT {<br>
  SQLUSMALLINT hour; <br>
  SQLUSMALLINT minute; <br>
  SQLUSMALLINT second; <br>
} TIME_STRUCT; [a]</td>
</tr>
<tr valign=top>
<td width=29%>SQL_C_TYPE_<br>
TIMESTAMP [c]</td>
<td width=30%>SQL_TIMESTAMP_<br>
STRUCT</td>
<td width=41%>struct tagTIMESTAMP_STRUCT {<br>
  SQLSMALLINT year; <br>
  SQLUSMALLINT month; <br>
  SQLUSMALLINT day; <br>
  SQLUSMALLINT hour; <br>
  SQLUSMALLINT minute; <br>
  SQLUSMALLINT second; <br>
  SQLUINTEGER fraction; [b]<br>
} TIMESTAMP_STRUCT; [a]</td>
</tr>
<tr valign=top>
<td width=29%>SQL_C_NUMERIC</td>
<td width=30%>SQL_NUMERIC_<br>
STRUCT</td>
<td width=41%>struct tagSQL_NUMERIC_STRUCT {<br>
  SQLCHAR precision;<br>
  SQLSCHAR scale; <br>
  SQLCHAR sign [g]; <br>
  SQLCHAR<br>
 val[SQL_MAX_NUMERIC_LEN]; [e], [f] <br>
} SQL_NUMERIC_STRUCT;</td>
</tr>
<tr valign=top>
<td width=29%>SQL_C_GUID</td>
<td width=30%>SQLGUID</td>
<td width=41%>struct tagSQLGUID {<br>
DWORD Data1;<br>
WORD Data2;<br>
WORD Data3;<br>
BYTE Data4[8];<br>
} SQLGUID; [k]</td>
</tr>
<tr valign=top>
<td width=29%>All C interval data types</td>
<td width=30%>SQL_INTERVAL_STRUCT</td>
<td width=41%>See the “<a href="odappdpr_31t1.htm">C Interval Structure</a>” section later in this appendix.</td>
</tr>
</table><br>
<p class=mini>
[a]The values of the year, month, day, hour, minute, and second fields in the datetime C data types must conform to the constraints of the Gregorian calendar (see “<a href="odappdpr_7z1u.htm">Constraints of the Gregorian Calendar</a>” later in this appendix).</p>
<p class=mini>
[b]The value of the fraction field is the number of billionths of a second and ranges from 0 to 999,999,999 (1 less than 1 billion). For example, the value of the fraction field for a half-second is 500,000,000, for a thousandth of a second (one millisecond) is 1,000,000, for a millionth of a second (one microsecond) is 1,000, and for a billionth of a second (one nanosecond) is 1.</p>
<p class=mini>
[c]In ODBC 2.<i>x</i>, the C date, time, and timestamp data types are SQL_C_DATE, SQL_C_TIME, and SQL_C_TIMESTAMP.</p>
<p class=mini>
[d]ODBC 3.x applications should use SQL_C_VARBOOKMARK, not SQL_C_BOOKMARK. When an ODBC 3.x application works with an ODBC 2.<i>x</i> driver, the ODBC 3.x Driver Manager will map SQL_C_VARBOOKMARK to SQL_C_BOOKMARK. </p>
<p class=mini>
[e]A number is stored in the <i>val</i> field of the SQL_NUMERIC_STRUCT structure as a scaled integer, in little endian mode (the leftmost byte being the least-significant byte). For example, the number 10.001 base 10, with a scale of 4, is scaled to an integer of 100010. Because this is 186AA in hexadecimal format, the value in SQL_NUMERIC_STRUCT would be “AA 86 01 00 00 … 00”, with the number of bytes defined by the SQL_MAX_NUMERIC_LEN <b>#define</b>.</p>
<p class=mini>
[f]The precision and scale fields of the SQL_C_NUMERIC data type are never used for input from an application, only for output from the driver to the application. When the driver writes a numeric value into the SQL_NUMERIC_STRUCT, it will use its own driver-specific default as the value for the <i>precision</i> field, and it will use the value in the SQL_DESC_SCALE field of the application descriptor (which defaults to 0) for the <i>scale</i> field. An application can provide its own values for precision and scale by setting the SQL_DESC_PRECISION and SQL_DESC_SCALE fields of the application descriptor.</p>
<p class=mini>
[g]The sign field is 1 if positive, 0 if negative.</p>
<p class=mini>
[h]_int64 may not be supplied by some compilers. </p>
<p class=mini>
[i]_SQL_C_BOOKMARK has been deprecated in ODBC 3.x. </p>
<p class=mini>
[j]_SQL_C_SHORT, SQL_C_LONG, and SQL_C_TINYINT have been replaced in ODBC by signed and unsigned types: SQL_C_SSHORT and SQL_C_USHORT, SQL_C_SLONG and SQL_C_ULONG, and SQL_C_STINYINT and SQL_C_UTINYINT. An ODBC 3.x driver that should work with ODBC 2.<i>x</i> applications should support SQL_C_SHORT, SQL_C_LONG, and SQL_C_TINYINT, because when they are called, the Driver Manager passes them through to the driver. </p>
<p class=mini>
[k]SQL_C_GUID may only be converted to SQL_CHAR or SQL_WCHAR.</p>
</font></BODY>
</HTML>
