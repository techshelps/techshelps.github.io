<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Simulating Positioned Update and Delete Statements</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="odbcsimulating_positioned_update_and_delete_statements"></a>Simulating Positioned Update and Delete Statements</h1>
<p>
If the data source does not support positioned update and delete statements, the driver can simulate these. For example, the ODBC cursor library simulates positioned update and delete statements. The general strategy for simulating positioned update and delete statements is to convert positioned statements to searched ones. This is done by replacing the <b>WHERE CURRENT OF</b> clause with a searched <b>WHERE</b> clause that identifies the current row.</p>
<p>
For example, because the CustID column uniquely identifies each row in the Customers table, the positioned delete statement:</p>
<pre><code>DELETE FROM Customers WHERE CURRENT OF CustCursor
</code></pre>
<p>
might be converted to:</p>
<pre><code>DELETE FROM Customers WHERE (CustID = ?)
</code></pre>
<p>
The driver may use one of the following <i>row identifiers</i> in the <b>WHERE</b> clause:
<ul type=disc>
<li>
Columns whose values serve to identify uniquely every row in the table. For example, calling <b>SQLSpecialColumns</b> with SQL_BEST_ROWID returns the optimal column or set of columns that serve this purpose.<br><br></li>
<li>
Pseudo-columns, provided by some data sources, for the purpose of uniquely identifying every row. These may also be retrievable by calling <b>SQLSpecialColumns</b>.<br><br></li>
<li>
A unique index, if available.<br><br></li>
<li>
All the columns in the result set.</li>
</ul>
<p>
Exactly which columns a driver should use in the <b>WHERE</b> clause it constructs depends on the driver. On some data sources, determining a row identifier can be costly. However, it is faster to execute and guarantees that a simulated statement updates or deletes at most one row. Depending on the capabilities of the underlying DBMS, using a row identifier can be expensive to set up. However, it is faster to execute and guarantees that a simulated statement will update or delete only one row. Using all the columns in the result set is usually much easier to set up. However, it is slower to execute and, if the columns do not uniquely identify a row, can result in rows being unintentionally updated or deleted, especially when the select list for the result set does not contain all the columns that exist in the underlying table.</p>
<p>
Depending upon which of these strategies the driver supports, an application can choose which strategy it wants the driver to use with the SQL_ATTR_SIMULATE_CURSOR statement attribute. Although it might seem odd for an application to risk unintentionally updating or deleting a row, the application can remove this risk by ensuring that the columns in the result set uniquely identify each row in the result set. This saves the driver the effort of having to do this.</p>
<p>
If the driver chooses to use a row identifier, it intercepts the <b>SELECT FOR UPDATE</b> statement that creates the result set. If the columns in the select list do not effectively identify a row, the driver adds the necessary columns to the end of the select list. Some data sources have a single column that always uniquely identifies a row, such as the ROWID column in Oracle; if so, the driver uses this. Otherwise, the driver calls <b>SQLSpecialColumns</b> for each table in the <b>FROM</b> clause to retrieve a list of the columns that uniquely identify each row. A common restriction that results from this technique is that cursor simulation fails if there is more than one table in the <b>FROM</b> clause. </p>
<p>
No matter how the driver identifies rows, it usually strips the <b>FOR UPDATE OF</b> clause off the <b>SELECT FOR UPDATE</b> statement before sending it to the data source. The <b>FOR UPDATE OF</b> clause is used only with positioned update and delete statements. Data sources that do not support positioned update and delete statements generally do not support it.</p>
<p>
When the application submits a positioned update or delete statement for execution, the driver replaces the <b>WHERE CURRENT OF</b> clause with a <b>WHERE</b> clause containing the row identifier. The values of these columns are retrieved from a cache maintained by the driver for each column it uses in the <b>WHERE</b> clause. After the driver has replaced the <b>WHERE</b> clause, it sends the statement to the data source for execution.</p>
<p>
For example, suppose that the application submits the following statement to create a result set:</p>
<pre><code>SELECT Name, Address, Phone FROM Customers FOR UPDATE OF Phone, Address
</code></pre>
<p>
If the application has set SQL_ATTR_SIMULATE_CURSOR to request a guarantee of uniqueness and if the data source does not provide a pseudo-column that always uniquely identifies a row, the driver calls <b>SQLSpecialColumns</b> for the Customers table, discovers that CustID is the key to the Customers table and adds this to the select list, and strips the <b>FOR UPDATE OF</b> clause:</p>
<pre><code>SELECT Name, Address, Phone, CustID FROM Customers
</code></pre>
<p>
If the application has not requested a guarantee of uniqueness, the driver strips only the <b>FOR UPDATE OF</b> clause:</p>
<pre><code>SELECT Name, Address, Phone FROM Customers
</code></pre>
<p>
Suppose the application scrolls through the result set and submits the following positioned update statement for execution, where Cust is the name of the cursor over the result set:</p>
<pre><code>UPDATE Customers SET Address = ?, Phone = ? WHERE CURRENT OF Cust
</code></pre>
<p>
If the application has not requested a guarantee of uniqueness, the driver replaces the <b>WHERE</b> clause and binds the CustID parameter to the variable in its cache:</p>
<pre><code>UPDATE Customers SET Address = ?, Phone = ? WHERE (CustID = ?)
</code></pre>
<p>
If the application has not requested a guarantee of uniqueness, the driver replaces the <b>WHERE</b> clause and binds the Name, Address, and Phone parameters in this clause to the variables in its cache:</p>
<pre><code>UPDATE Customers SET Address = ?, Phone = ?
 WHERE (Name = ?) AND (Address = ?) AND (Phone = ?)
</code></pre>
</font></BODY>
</HTML>
