<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SQLBindParameter</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="odbcsqlbindparameter"></a>SQLBindParameter</h1>
<p class=label>
<b>Conformance</b></p>
<p>
Version Introduced:ODBC 2.0<br>
Standards Compliance:ODBC</p>
<p class=label>
<b>Summary</b></p>
<p>
<b>SQLBindParameter</b> binds a buffer to a parameter marker in an SQL statement. <b>SQLBindParameter supports binding to a Unicode C data type, even if the underlying driver does not support Unicode data.</b></p>
<p class=indent>
<B><b>Note&nbsp;&nbsp;&nbsp;</b></B>This function replaces the ODBC 1.0 function <b>SQLSetParam</b>. For more information, see “Comments.”</p>
<p class=label>
<b>Syntax</b></p>
<p>
SQLRETURN <b>SQLBindParameter</b>(<br>
SQLHSTMT<i>StatementHandle</i>,<br>
SQLUSMALLINT<i>ParameterNumber</i>,<br>
SQLSMALLINT<i>InputOutputType</i>,<br>
SQLSMALLINT<i>ValueType</i>,<br>
SQLSMALLINT<i>ParameterType</i>,<br>
SQLUINTEGER<i>ColumnSize</i>,<br>
SQLSMALLINT<i>DecimalDigits</i>,<br>
SQLPOINTER<i>ParameterValuePtr</i>,<br>
SQLINTEGER<i>BufferLength</i>,<br>
SQLINTEGER *<i>StrLen_or_IndPtr</i>);</p>
<p class=label>
<b>Arguments</b></p>
<p class=dt>
<i>StatementHandle</i></p>
<p class=indent>
[Input]<br>
Statement handle.</p>
<p class=dt>
<i>ParameterNumber</i></p>
<p class=indent>
[Input]<br>
Parameter number, ordered sequentially in increasing parameter order, starting at 1.</p>
<p class=dt>
<i>InputOutputType</i></p>
<p class=indent>
[Input]<br>
The type of the parameter. For more information, see “<i>InputOutputType</i> Argument” in “Comments.”</p>
<p class=dt>
<i>ValueType</i></p>
<p class=indent>
[Input]<br>
The C data type of the parameter. For more information, see “<i>ValueType</i> Argument” in “Comments.”</p>
<p class=dt>
<i>ParameterType</i></p>
<p class=indent>
[Input]<br>
The SQL data type of the parameter. For more information, see “<i>ParameterType</i> Argument” in “Comments.”</p>
<p class=dt>
<i>ColumnSize</i></p>
<p class=indent>
[Input]<br>
The size of the column or expression of the corresponding parameter marker. For more information, see “<i>ColumnSize</i> Argument” in “Comments.”</p>
<p class=dt>
<i>DecimalDigits</i></p>
<p class=indent>
[Input]<br>
The decimal digits of the column or expression of the corresponding parameter marker. For further information concerning column size, see “<a href="odappdpr_7ch1.htm">Column Size, Decimal Digits, Transfer Octet Length, and Display Size</a>,” in Appendix D, “Data Types.”</p>
<p class=dt>
<i>ParameterValuePtr</i></p>
<p class=indent>
[Deferred Input]<br>
A pointer to a buffer for the parameter’s data. For more information, see “<i>ParameterValuePtr</i> Argument” in “Comments.”</p>
<p class=dt>
<i>BufferLength</i></p>
<p class=indent>
[Input/Output]<br>
Length of the <i>ParameterValuePtr</i> buffer in bytes. For more information, see “<i>BufferLength</i> Argument” in “Comments.”</p>
<p class=dt>
<i>StrLen_or_IndPtr</i></p>
<p class=indent>
[Deferred Input]<br>
A pointer to a buffer for the parameter’s length. For more information, see “<i>StrLen_or_IndPtr</i> Argument” in “Comments.”</p>
<p class=label>
<b>Returns</b></p>
<p>
SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_ERROR, or SQL_INVALID_HANDLE.</p>
<p class=label>
<b>Diagnostics</b></p>
<p>
When <b>SQLBindParameter</b> returns SQL_ERROR or SQL_SUCCESS_WITH_INFO, an associated SQLSTATE value may be obtained by calling <b>SQLGetDiagRec</b> with a <i>HandleType</i> of SQL_HANDLE_STMT and a <i>Handle</i> of <i>StatementHandle</i>. The following table lists the SQLSTATE values commonly returned by <b>SQLBindParameter </b>and explains each one in the context of this function; the notation “(DM)” precedes the descriptions of SQLSTATEs returned by the Driver Manager. The return code associated with each SQLSTATE value is SQL_ERROR, unless noted otherwise.</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows width=595>
<tr valign=top>
<td class=label width=22%><b>SQLSTATE</b></td>
<td class=label width=26%><b>Error</b></td>
<td class=label width=52%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=22%>01000</td>
<td width=26%>General warning</td>
<td width=52%>Driver-specific informational message. (Function returns SQL_SUCCESS_WITH_INFO.)</td>
</tr>
<tr valign=top>
<td width=22%>07006</td>
<td width=26%>Restricted data type attribute violation</td>
<td width=52%>The data type identified by the <i>ValueType</i> argument cannot be converted to the data type identified by the <i>ParameterType</i> argument. Note that this error may be returned by <b>SQLExecDirect</b>, <b>SQLExecute</b>, or <b>SQLPutData</b> at execution time, instead of by <b>SQLBindParameter</b>.</td>
</tr>
<tr valign=top>
<td width=22%>07009</td>
<td width=26%>Invalid descriptor index</td>
<td width=52%>(DM) The value specified for the argument <i>ParameterNumber</i> was less than 1.</td>
</tr>
<tr valign=top>
<td width=22%>HY000</td>
<td width=26%>General error</td>
<td width=52%>An error occurred for which there was no specific SQLSTATE and for which no implementation-specific SQLSTATE was defined. The error message returned by <b>SQLGetDiagRec</b> in the *<i>MessageText</i> buffer describes the error and its cause. </td>
</tr>
<tr valign=top>
<td width=22%>HY001</td>
<td width=26%>Memory allocation <br>
error</td>
<td width=52%>The driver was unable to allocate memory required to support execution or completion of the function.</td>
</tr>
<tr valign=top>
<td width=22%>HY003</td>
<td width=26%>Invalid application buffer type</td>
<td width=52%>The value specified by the argument <i>ValueType</i> was not a valid C data type or SQL_C_DEFAULT.</td>
</tr>
<tr valign=top>
<td width=22%>HY004</td>
<td width=26%>Invalid SQL data type</td>
<td width=52%>The value specified for the argument <i>ParameterType</i> was neither a valid ODBC SQL data type identifier nor a driver-specific SQL data type identifier supported by the driver.</td>
</tr>
<tr valign=top>
<td width=22%>HY009</td>
<td width=26%>Invalid use of null pointer</td>
<td width=52%>(DM) The argument <i>ParameterValuePtr</i> was a null pointer, the argument <i>StrLen_or_IndPtr</i> was a null pointer, and the argument <i>InputOutputType</i> was not SQL_PARAM_OUTPUT.</td>
</tr>
<tr valign=top>
<td width=22%>HY010</td>
<td width=26%>Function sequence <br>
error</td>
<td width=52%>(DM) An asynchronously executing function was called for the <i>StatementHandle</i> and was still executing when this function was called.<p>
(DM) <b>SQLExecute</b>, <b>SQLExecDirect</b>, <b>SQLBulkOperations</b>, or <b>SQLSetPos</b> was called for the <i>StatementHandle</i> and returned SQL_NEED_DATA. This function was called before data was sent for all data-at-execution parameters or columns.</p>
</td>
</tr>
<tr valign=top>
<td width=22%>HY013</td>
<td width=26%>Memory management error</td>
<td width=52%>The function call could not be processed because the underlying memory objects could not be accessed, possibly because of low memory conditions.</td>
</tr>
<tr valign=top>
<td width=22%>HY021</td>
<td width=26%>Inconsistent descriptor information</td>
<td width=52%>The descriptor information checked during a consistency check was not consistent. (See the “Consistency Checks” section in <b>SQLSetDescField</b>.)<p>
The value specified for the argument <i>DecimalDigits</i> was outside the range of values supported by the data source for a column of the SQL data type specified by the <i>ParameterType</i> argument.</p>
</td>
</tr>
<tr valign=top>
<td width=22%>HY090</td>
<td width=26%>Invalid string or buffer length</td>
<td width=52%>(DM) The value in <i>BufferLength</i> was less than 0. (See the description of the SQL_DESC_DATA_PTR field in <b>SQLSetDescField</b>.)</td>
</tr>
<tr valign=top>
<td width=22%>HY104</td>
<td width=26%>Invalid precision or scale value</td>
<td width=52%>The value specified for the argument <i>ColumnSize</i> or <i>DecimalDigits</i> was outside the range of values supported by the data source for a column of the SQL data type specified by the <i>ParameterType</i> argument.</td>
</tr>
<tr valign=top>
<td width=22%>HY105</td>
<td width=26%>Invalid parameter type</td>
<td width=52%>(DM) The value specified for the argument <i>InputOutputType</i> was invalid (see “Comments”). </td>
</tr>
<tr valign=top>
<td width=22%>HYC00</td>
<td width=26%>Optional feature not implemented</td>
<td width=52%>The driver or data source does not support the conversion specified by the combination of the value specified for the argument <i>ValueType</i> and the driver-specific value specified for the argument <i>ParameterType</i>.<p>
The value specified for the argument <i>ParameterType</i> was a valid ODBC SQL data type identifier for the version of ODBC supported by the driver, but was not supported by the driver or data source.</p>
<p>
The driver supports only ODBC 2.<i>x</i> and the argument <i>ValueType</i> was one of the following:</p>
<p>
SQL_C_NUMERIC<br>
SQL_C_SBIGINT <br>
SQL_C_UBIGINT </p>
<p>
and all of the interval C data types listed in “<a href="odappdpr_40j7.htm">C Data Types</a>” in Appendix D, “Data Types.”</p>
</td>
</tr>
<tr valign=top>
<td width=22%>HYT01</td>
<td width=26%>Connection timeout expired</td>
<td width=52%>The connection timeout period expired before the data source responded to the request. The connection timeout period is set through <b>SQLSetConnectAttr</b>, SQL_ATTR_CONNECTION_TIMEOUT.</td>
</tr>
<tr valign=top>
<td width=22%>IM001</td>
<td width=26%>Driver does not support this function</td>
<td width=52%>(DM) The driver associated with the <i>StatementHandle</i> does not support the function.</td>
</tr>
</table><br>
<p class=label>
<b>Comments</b></p>
<p>
An application calls <b>SQLBindParameter</b> to bind each parameter marker in an SQL statement. Bindings remain in effect until the application calls <b>SQLBindParameter</b> again, calls <b>SQLFreeStmt</b> with the SQL_RESET_PARAMS option, or calls <b>SQLSetDescField</b> to set the SQL_DESC_COUNT header field of the APD to 0.</p>
<p>
For more information about parameters, see “<a href="odch09pr_2tpv.htm">Statement Parameters</a>” in Chapter 9, “Executing Statements.” For more information concerning parameter data types and parameter markers, see “<a href="odappcpr_7bjn.htm">Parameter Data Types</a>” and “<a href="odappcpr_1cz7.htm">Parameter Markers</a>” in Appendix C, “SQL Grammar.”</p>
<h1><i>ParameterNumber</i> Argument</h1>
<p>
If <i>ParameterNumber</i> in the call to <b>SQLBindParameter </b>is greater than the value of SQL_DESC_COUNT, <b>SQLSetDescField </b>is called to increase the value of SQL_DESC_COUNT to <i>ParameterNumber</i>.</p>
<h1><i>InputOutputType</i> Argument</h1>
<p>
The <i>InputOutputType</i> argument specifies the type of the parameter. This argument sets the SQL_DESC_PARAMETER_TYPE field of the IPD. All parameters in SQL statements that do not call procedures, such as <b>INSERT</b> statements, are input parameters. Parameters in procedure calls can be input, input/output, or output parameters. (An application calls <b>SQLProcedureColumns</b> to determine the type of a parameter in a procedure call; parameters in procedure calls whose type cannot be determined are assumed to be input parameters.)</p>
<p>
The <i>InputOutputType</i> argument is one of the following values:
<ul type=disc>
<li>
SQL_PARAM_INPUT. The parameter marks a parameter in an SQL statement that does not call a procedure, such as an <b>INSERT</b> statement, or it marks an input parameter in a procedure; these are collectively known as <i>input parameters</i>. For example, the parameters in <b>INSERT INTO Employee VALUES (?, ?, ?)</b> are input parameters, while the parameters in <b>{call AddEmp(?, ?, ?)}</b> can be, but are not necessarily, input parameters.<p class=tl>
When the statement is executed, the driver sends data for the parameter to the data source; the *<i>ParameterValuePtr</i> buffer must contain a valid input value or the *<i>StrLen_or_IndPtr</i> buffer must contain SQL_NULL_DATA, SQL_DATA_AT_EXEC, or the result of the SQL_LEN_DATA_AT_EXEC macro.</P><p class=tl>
If an application cannot determine the type of a parameter in a procedure call, it sets <i>InputOutputType</i> to SQL_PARAM_INPUT; if the data source returns a value for the parameter, the driver discards it.</P></li>
<li>
SQL_PARAM_INPUT_OUTPUT. The parameter marks an input/output parameter in a procedure. For example, the parameter in <b>{call GetEmpDept(?)}</b> is an input/output parameter that accepts an employee’s name and returns the name of the employee’s department.<p class=tl>
When the statement is executed, the driver sends data for the parameter to the data source; the *<i>ParameterValuePtr</i> buffer must contain a valid input value or the *<i>StrLen_or_IndPtr</i> buffer must contain SQL_NULL_DATA, SQL_DATA_AT_EXEC, or the result of the SQL_LEN_DATA_AT_EXEC macro. After the statement is executed, the driver returns data for the parameter to the application; if the data source does not return a value for an input/output parameter, the driver sets the *<i>StrLen_or_IndPtr</i> buffer to SQL_NULL_DATA.</P><p class=atl>
<B><b>Note&nbsp;&nbsp;&nbsp;</b></B>When an ODBC 1.0 application calls <b>SQLSetParam</b> in an ODBC 2.0 driver, the Driver Manager converts this to a call to <b>SQLBindParameter</b> in which the <i>InputOutputType</i> argument is set to SQL_PARAM_INPUT_OUTPUT.</p></li>
<li>
SQL_PARAM_OUTPUT. The parameter marks the return value of a procedure or an output parameter in a procedure; these are collectively known as <i>output parameters</i>. For example, the parameter in <b>{?=call GetNextEmpID}</b> is an output parameter that returns the next employee ID.<p class=tl>
After the statement is executed, the driver returns data for the parameter to the application, unless the <i>ParameterValuePtr</i> and <i>StrLen_or_IndPtr</i> arguments are both null pointers, in which case the driver discards the output value. If the data source does not return a value for an output parameter, the driver sets the *<i>StrLen_or_IndPtr</i> buffer to SQL_NULL_DATA.</P></li>
</ul>
<h1><i>ValueType</i> Argument</h1>
<p>
The C data type of the parameter. This argument sets the SQL_DESC_TYPE, SQL_DESC_CONCISE_TYPE, and SQL_DESC_DATETIME_INTERVAL_CODE fields of the APD. This must be one of the values in the “<a href="odappdpr_40j7.htm">C Data Types</a>” section of Appendix D, “Data Types.”</p>
<p>
If the <i>ValueType</i> argument is one of the interval data types, the SQL_DESC_TYPE field of the <i>ParameterNumber</i> record of the APD is set to SQL_INTERVAL, the SQL_DESC_CONCISE_TYPE field of the APD is set to the concise interval data type, and the SQL_DESC_DATETIME_INTERVAL_CODE field of the <i>ParameterNumber</i> record is set to a subcode for the specific interval data type (see Appendix D, “<a href="odappdpr_8kab.htm">Data Types</a>”). The default interval leading precision (2) and default interval seconds precision (6), as set in the SQL_DESC_DATETIME_INTERVAL_PRECISION and SQL_DESC_PRECISION fields of the APD, respectively, are used for the data. If either default precision is not appropriate, the application should explicitly set the descriptor field by a call to <b>SQLSetDescField</b> or <b>SQLSetDescRec</b>.</p>
<p>
If the <i>ValueType</i> argument is one of the datetime data types, the SQL_DESC_TYPE field of the <i>ParameterNumber</i> record of the APD is set to SQL_DATETIME, the SQL_DESC_CONCISE_TYPE field of the <i>ParameterNumber</i> record of the APD is set to the concise datetime C data type, and the SQL_DESC_DATETIME_INTERVAL_CODE field of the <i>ParameterNumber</i> record is set to a subcode for the specific datetime data type (see Appendix D, “<a href="odappdpr_8kab.htm">Data Types</a>”).</p>
<p>
If the <i>ValueType</i> argument is an SQL_C_NUMERIC data type, the default precision (which is driver-defined) and the default scale (0), as set in the SQL_DESC_PRECISION and SQL_DESC_SCALE fields of the APD, are used for the data. If the default precision or scale is not appropriate, the application should explicitly set the descriptor field by a call to <b>SQLSetDescField</b> or <b>SQLSetDescRec</b>.</p>
<p>
SQL_C_DEFAULT specifies that the parameter value be transferred from the default C data type for the SQL data type specified with <i>ParameterType</i>.</p>
<p>
For more information, see “<a href="odappdpr_141f.htm">Default C Data Types</a>,” “<a href="odappdpr_744z.htm">Converting Data from C to SQL Data Types</a>,” and “<a href="odappdpr_4o4z.htm">Converting Data from SQL to C Data Types</a>” in Appendix D, “Data Types.”</p>
<h1><i>ParameterType</i> Argument</h1>
<p>
This must be one of the values in the “<a href="odappdpr_8fcj.htm">SQL Data Types</a>” section of Appendix D, “Data Types,” or a driver-specific value. This argument sets the SQL_DESC_TYPE, SQL_DESC_CONCISE_TYPE, and SQL_DESC_DATETIME_INTERVAL_CODE fields of the IPD. </p>
<p>
If the <i>ParameterType</i> argument is one of the datetime identifiers, the SQL_DESC_TYPE field of the IPD is set to SQL_DATETIME, the SQL_DESC_CONCISE_TYPE field of the IPD is set to the concise datetime SQL data type, and the SQL_DESC_DATETIME_INTERVAL_CODE field is set to the appropriate datetime subcode value.</p>
<p>
If <i>ParameterType</i> is one of the interval identifiers, the SQL_DESC_TYPE field of the IPD is set to SQL_INTERVAL, the SQL_DESC_CONCISE_TYPE field of the IPD is set to the concise SQL interval data type, and the SQL_DESC_DATETIME_INTERVAL_CODE field of the IPD is set to the appropriate interval subcode. The SQL_DESC_DATETIME_INTERVAL_PRECISION field of the IPD is set to the interval leading precision, and the SQL_DESC_PRECISION field is set to the interval seconds precision, if applicable. If the default value of SQL_DESC_DATETIME_INTERVAL_PRECISION or SQL_DESC_PRECISION is not appropriate, the application should explicitly set it by calling <b>SQLSetDescField</b>. For more information about any of these fields, see <a href="odch21jpr_7e90.htm">SQLSetDescField</a>.</p>
<p>
If the <i>ValueType</i> argument is a SQL_NUMERIC data type, the default precision (which is driver-defined) and the default scale (0), as set in the SQL_DESC_PRECISION and SQL_DESC_SCALE fields of the IPD, are used for the data. If the default precision or scale is not appropriate, the application should explicitly set the descriptor field by a call to <b>SQLSetDescField</b> or <b>SQLSetDescRec</b>.</p>
<p>
For information about how data is converted, see “<a href="odappdpr_744z.htm">Converting Data from C to SQL Data Types</a>” and “<a href="odappdpr_4o4z.htm">Converting Data from SQL to C Data Types</a>” in Appendix D, “Data Types.”</p>
<h1><i>ColumnSize</i> Argument</h1>
<p>
The <i>ColumnSize </i>argument specifies the size of the column or expression corresponding to the parameter marker, or the length of that data, or both. This argument sets different fields of the IPD, depending on the SQL data type (the <i>ParameterType</i> argument). The following rules apply to this mapping:
<ul type=disc>
<li>
If <i>ParameterType</i> is SQL_CHAR, SQL_VARCHAR, SQL_LONGVARCHAR, SQL_BINARY, SQL_VARBINARY, SQL_LONGVARBINARY, or one of the concise SQL datetime or interval data types, the SQL_DESC_LENGTH field of the IPD is set to the value of <i>ColumnSize</i>. (For more information, see the “<a href="odappdpr_7ch1.htm">Column Size, Decimal Digits, Transfer Octet Length, and Display Size</a>” section in Appendix D, “Data Types.”)<br><br></li>
<li>
If <i>ParameterType</i> is SQL_DECIMAL, SQL_NUMERIC, SQL_FLOAT, SQL_REAL, or SQL_DOUBLE, the SQL_DESC_PRECISION field of the IPD is set to the value of <i>ColumnSize</i>.<br><br></li>
<li>
For other data types, the <i>ColumnSize </i>argument is ignored.</li>
</ul>
<p>
For more information, see “Passing Parameter Values” and SQL_DATA_AT_EXEC in “<i>StrLen_or_IndPtr</i> Argument.”</p>
<h1><i>DecimalDigits</i> Argument</h1>
<p>
If <i>ParameterType</i> is SQL_TYPE_TIME, SQL_TYPE_TIMESTAMP, SQL_INTERVAL_SECOND, SQL_INTERVAL_DAY_TO_SECOND, SQL_INTERVAL_HOUR_TO_SECOND, or SQL_INTERVAL_MINUTE_TO_SECOND, the SQL_DESC_PRECISION field of the IPD is set to <i>DecimalDigits</i>. If <i>ParameterType</i> is SQL_NUMERIC or SQL_DECIMAL, the SQL_DESC_SCALE field of the IPD is set to <i>DecimalDigits</i>. For all other data types, the <i>DecimalDigits</i> argument is ignored.</p>
<h1><i>ParameterValuePtr</i> Argument</h1>
<p>
The <i>ParameterValuePtr</i> argument points to a buffer that, when <b>SQLExecute</b> or <b>SQLExecDirect</b> is called, contains the actual data for the parameter. The data must be in the form specified by the <i>ValueType</i> argument. This argument sets the SQL_DESC_DATA_PTR field of the APD. An application can set the <i>ParameterValuePtr</i> argument to a null pointer, as long as <i>*StrLen_or_IndPtr</i> is SQL_NULL_DATA or SQL_DATA_AT_EXEC. (This applies only to input or input/output parameters.)</p>
<p>
If *<i>StrLen_or_IndPtr</i> is the result of the SQL_LEN_DATA_AT_EXEC(<i>length</i>) macro or SQL_DATA_AT_EXEC, then <i>ParameterValuePtr</i> is an application-defined, 32-bit value that is associated with the parameter. It is returned to the application through <b>SQLParamData</b>. For example, <i>ParameterValuePtr</i> might be a token such as a parameter number, a pointer to data, or a pointer to a structure that the application used to bind input parameters. Note, however, that if the parameter is an input/output parameter, <i>ParameterValuePtr</i> must be a pointer to a buffer where the output value will be stored. If the value in the SQL_ATTR_PARAMSET_SIZE statement attribute is greater than 1, the application can use the value pointed to by the SQL_ATTR_PARAMS_PROCESSED_PTR statement attribute in conjunction with the <i>ParameterValuePtr</i> argument. For example, <i>ParameterValuePtr</i> might point to an array of values and the application might use the value pointed to by SQL_ATTR_PARAMS_PROCESSED_PTR to retrieve the correct value from the array. For more information, see “Passing Parameter Values” later in this section.</p>
<p>
If the <i>InputOutputType</i> argument is SQL_PARAM_INPUT_OUTPUT or SQL_PARAM_OUTPUT, <i>ParameterValuePtr</i> points to a buffer in which the driver returns the output value. If the procedure returns one or more result sets, the *<i>ParameterValuePtr</i> buffer is not guaranteed to be set until all result sets/row counts have been processed. If the buffer is not set until processing is complete, the output parameters and return values are unavailable until <b>SQLMoreResults</b> returns SQL_NO_DATA. Calling <b>SQLCloseCursor</b> or <b>SQLFreeStmt</b> with an Option of SQL_CLOSE will cause these values to be discarded.</p>
<p>
If the value in the SQL_ATTR_PARAMSET_SIZE statement attribute is greater than 1, <i>ParameterValuePtr</i> points to an array. A single SQL statement processes the entire array of input values for an input or input/output parameter and returns an array of output values for an input/output or output parameter.</p>
<h1><i>BufferLength</i> Argument</h1>
<p>
For character and binary C data, the <i>BufferLength</i> argument specifies the length of the *<i>ParameterValuePtr</i> buffer (if it is a single element) or the length of an element in the *<i>ParameterValuePtr</i> array (if the value in the SQL_ATTR_PARAMSET_SIZE statement attribute is greater than 1). This argument sets the SQL_DESC_OCTET_LENGTH record field of the APD. If the application specifies multiple values, <i>BufferLength</i> is used to determine the location of values in the *<i>ParameterValuePtr</i> array, both on input and on output. For input/output and output parameters, it is used to determine whether to truncate character and binary C data on output:
<ul type=disc>
<li>
For character C data, if the number of bytes available to return is greater than or equal to <i>BufferLength</i>, the data in *<i>ParameterValuePtr</i> is truncated to <i>BufferLength</i> less the length of a null-termination character and is null-terminated by the driver.<br><br></li>
<li>
For binary C data, if the number of bytes available to return is greater than <i>BufferLength</i>, the data in *<i>ParameterValuePtr</i> is truncated to <i>BufferLength</i> bytes.</li>
</ul>
<p>
For all other types of C data, the <i>BufferLength</i> argument is ignored. The length of the *<i>ParameterValuePtr</i> buffer (if it is a single element) or the length of an element in the *<i>ParameterValuePtr</i> array (if the application calls <b>SQLSetStmtAttr</b> with an <i>Attribute</i> argument of SQL_ATTR_PARAMSET_SIZE to specify multiple values for each parameter) is assumed to be the length of the C data type.</p>
<p class=indent>
<B><b>Note</b></B> When an ODBC 1.0 application calls <b>SQLSetParam</b> in an ODBC 3.x driver, the Driver Manager converts this to a call to <b>SQLBindParameter</b> in which the <i>BufferLength</i> argument is always SQL_SETPARAM_VALUE_MAX. Because the Driver Manager returns an error if an ODBC 3.x application sets <i>BufferLength</i> to SQL_SETPARAM_VALUE_MAX, an ODBC 3.x driver can use this to determine when it is called by an ODBC 1.0 application.</p>
<p class=indent>
In <b>SQLSetParam</b>, the way in which an application specifies the length of the *<i>ParameterValuePtr</i> buffer so that the driver can return character or binary data, and the way in which an application sends an array of character or binary parameter values to the driver, are driver-defined.</p>
<h1><i>StrLen_or_IndPtr</i> Argument</h1>
<p>
The <i>StrLen_or_IndPtr</i> argument points to a buffer that, when <b>SQLExecute</b> or <b>SQLExecDirect</b> is called, contains one of the following. This argument sets the SQL_DESC_OCTET_LENGTH_PTR and SQL_DESC_INDICATOR_PTR record fields of the application parameter pointers.
<ul type=disc>
<li>
The length of the parameter value stored in *<i>ParameterValuePtr</i>. This is ignored except for character or binary C data.<br><br></li>
<li>
SQL_NTS. The parameter value is a null-terminated string.<br><br></li>
<li>
SQL_NULL_DATA. The parameter value is NULL.<br><br></li>
<li>
SQL_DEFAULT_PARAM. A procedure is to use the default value of a parameter, rather than a value retrieved from the application. This value is valid only in a procedure called in ODBC canonical syntax, and then only if the <i>InputOutputType</i> argument is SQL_PARAM_INPUT or SQL_PARAM_INPUT_OUTPUT. When *<i>StrLen_or_IndPtr</i> is SQL_DEFAULT_PARAM, the <i>ValueType</i>, <i>ParameterType</i>, <i>ColumnSize</i>, <i>DecimalDigits</i>, <i>BufferLength,</i> and <i>ParameterValuePtr</i> arguments are ignored for input parameters and are used only to define the output parameter value for input/output parameters.<br><br></li>
<li>
The result of the SQL_LEN_DATA_AT_EXEC(<i>length</i>) macro. The data for the parameter will be sent with <b>SQLPutData</b>. If the <i>ParameterType</i> argument is SQL_LONGVARBINARY, SQL_LONGVARCHAR, or a long, data source&nbsp;–&nbsp;specific data type and the driver returns “Y” for the SQL_NEED_LONG_DATA_LEN information type in <b>SQLGetInfo</b>, <i>length</i> is the number of bytes of data to be sent for the parameter; otherwise, <i>length</i> must be a nonnegative value and is ignored. For more information, see “Passing Parameter Values” later in this section.<p class=tl>
For example, to specify that 10,000 bytes of data will be sent with <b>SQLPutData</b> for an SQL_LONGVARCHAR parameter, an application sets *<i>StrLen_or_IndPtr</i> to SQL_LEN_DATA_AT_EXEC(10000).</P></li>
<li>
SQL_DATA_AT_EXEC. The data for the parameter will be sent with <b>SQLPutData</b>. This value is used by ODBC 1.0 applications when calling ODBC 3.x drivers. For more information, see “Passing Parameter Values” later in this section.</li>
</ul>
<p>
If <i>StrLen_or_IndPtr</i> is a null pointer, the driver assumes that all input parameter values are non-NULL and that character and binary data are null-terminated. If <i>InputOutputType</i> is SQL_PARAM_OUTPUT and <i>ParameterValuePtr</i> and <i>StrLen_or_IndPtr</i> are both null pointers, the driver discards the output value.</p>
<p class=indent>
<B><b>Note</b></B> Application developers are strongly discouraged from specifying a null pointer for <i>StrLen_or_IndPtr</i> when the data type of the parameter is SQL_C_BINARY. To ensure that a driver does not unexpectedly truncate SQL_C_BINARY data, <i>StrLen_or_IndPtr</i> should contain a pointer to a valid length value.</p>
<p>
If the <i>InputOutputType</i> argument is SQL_PARAM_INPUT_OUTPUT or SQL_PARAM_OUTPUT, <i>StrLen_or_IndPtr</i> points to a buffer in which the driver returns SQL_NULL_DATA, the number of bytes available to return in *<i>ParameterValuePtr</i> (excluding the null-termination byte of character data), or SQL_NO_TOTAL if the number of bytes available to return cannot be determined. If the procedure returns one or more result sets, the *<i>StrLen_or_IndPtr</i> buffer is not guaranteed to be set until all results have been fetched.</p>
<p>
If the value in the SQL_ATTR_PARAMSET_SIZE statement attribute is greater than 1, <i>StrLen_or_IndPtr</i> points to an array of SQLINTEGER values. These can be any of the values listed earlier in this section and are processed with a single SQL statement.</p>
<h1>Passing Parameter Values</h1>
<p>
An application can pass the value for a parameter either in the *<i>ParameterValuePtr</i> buffer or with one or more calls to <b>SQLPutData</b>. Parameters whose data is passed with <b>SQLPutData</b> are known as <i>data-at-execution</i> parameters. These are commonly used to send data for SQL_LONGVARBINARY and SQL_LONGVARCHAR parameters, and can be mixed with other parameters.</p>
<p>
To pass parameter values, an application performs the following sequence of steps:
<ol>
<li>
Calls <b>SQLBindParameter</b> for each parameter to bind buffers for the parameter’s value (<i>ParameterValuePtr</i> argument) and length/indicator (<i>StrLen_or_IndPtr</i> argument). For data-at-execution parameters, <i>ParameterValuePtr</i> is an application-defined, 32-bit value such as a parameter number or a pointer to data. The value will be returned later and can be used to identify the parameter.<br><br></li>
<li>
Places values for input and input/output parameters in the *<i>ParameterValuePtr</i> and *<i>StrLen_or_IndPtr</i> buffers:<ul type=disc>
<li>
For normal parameters, the application places the parameter value in the *<i>ParameterValuePtr</i> buffer and the length of that value in the *<i>StrLen_or_IndPtr</i> buffer. For more information, see “<a href="odch09pr_64ab.htm">Setting Parameter Values</a>” in Chapter 9, “Executing Statements.”<br><br></li>
<li>
For data-at-execution parameters, the application places the result of the SQL_LEN_DATA_AT_EXEC(<i>length</i>) macro (when calling an ODBC 2.0 driver) in the *<i>StrLen_or_IndPtr</i> buffer.</li>
</ul>
</li>
<li>
Calls <b>SQLExecute</b> or <b>SQLExecDirect</b> to execute the SQL statement.<ul type=disc>
<li>
If there are no data-at-execution parameters, the process is complete.<br><br></li>
<li>
If there are any data-at-execution parameters, the function returns SQL_NEED_DATA.</li>
</ul>
</li>
<li>
Calls <b>SQLParamData</b> to retrieve the application-defined value specified in the <i>ParameterValuePtr</i> argument of <b>SQLBindParameter</b> for the first data-at-execution parameter to be processed. <b>SQLParamData</b> returns SQL_NEED_DATA.<p class=atl>
<B><b>Note&nbsp;&nbsp;&nbsp;</b></B>Although data-at-execution parameters are similar to data-at-execution columns, the value returned by <b>SQLParamData</b> is different for each.</p><p class=tl>
Data-at-execution parameters are parameters in an SQL statement for which data will be sent with <b>SQLPutData</b> when the statement is executed with <b>SQLExecDirect</b> or <b>SQLExecute</b>. They are bound with <b>SQLBindParameter</b>. The value returned by <b>SQLParamData</b> is a 32-bit value passed to <b>SQLBindParameter</b> in the <i>ParameterValuePtr</i> argument.</P><p class=tl>
Data-at-execution columns are columns in a rowset for which data will be sent with <b>SQLPutData</b> when a row is updated or added with <b>SQLBulkOperations</b> or updated with <b>SQLSetPos</b>. They are bound with <b>SQLBindCol</b>. The value returned by <b>SQLParamData</b> is the address of the row in the *<i>TargetValuePtr</i> buffer (set by a call to <b>SQLBindCol</b>) that is being processed.</P><p class=tl>
Calls <b>SQLPutData</b> one or more times to send data for the parameter. More than one call is needed if the data value is larger than the *<i>ParameterValuePtr</i> buffer specified in <b>SQLPutData</b>; note that multiple calls to <b>SQLPutData</b> for the same parameter are allowed only when sending character C data to a column with a character, binary, or data source&nbsp;–&nbsp;specific data type or when sending binary C data to a column with a character, binary, or data source&nbsp;–&nbsp;specific data type.</P></li>
<li>
Calls <b>SQLParamData</b> again to signal that all data has been sent for the parameter.<ul type=disc>
<li>
If there are more data-at-execution parameters, <b>SQLParamData</b> returns SQL_NEED_DATA and the application-defined value for the next data-at-execution parameter to be processed. The application repeats steps 4 and 5.<br><br></li>
<li>
If there are no more data-at-execution parameters, the process is complete. If the statement was successfully executed, <b>SQLParamData</b> returns SQL_SUCCESS or SQL_SUCCESS_WITH_INFO; if the execution failed, it returns SQL_ERROR. At this point, <b>SQLParamData</b> can return any SQLSTATE that can be returned by the function used to execute the statement (<b>SQLExecDirect</b> or <b>SQLExecute</b>).<p class=tl>
Output values for any input/output or output parameters are available in the *<i>ParameterValuePtr</i> and *<i>StrLen_or_IndPtr</i> buffers after the application retrieves all result sets generated by the statement.</P></li>
</ul>
</li>
</ol>
<p>
Calling <b>SQLExecute</b> or <b>SQLExecDirect</b> puts the statement in an SQL_NEED_DATA state. At this point, the application can call only <b>SQLCancel</b>, <b>SQLGetDiagField</b>, <b>SQLGetDiagRec</b>, <b>SQLGetFunctions</b>, <b>SQLParamData</b>, or <b>SQLPutData </b>with the statement or the <i>connection handle</i> associated with the statement. If it calls any other function with the statement or the connection associated with the statement, the function returns SQLSTATE HY010 (Function sequence error). The statement leaves the SQL_NEED_DATA state when <b>SQLParamData</b> or <b>SQLPutData</b> returns an error, <b>SQLParamData</b> returns SQL_SUCCESS or SQL_SUCCESS_WITH_INFO, or the statement is canceled.</p>
<p>
If the application calls <b>SQLCancel</b> while the driver still needs data for data-at-execution parameters, the driver cancels statement execution; the application can then call <b>SQLExecute</b> or <b>SQLExecDirect</b> again.</p>
<h1>Using Arrays of Parameters</h1>
<p>
When an application prepares a statement with parameter markers and passes in an array of parameters, there are two different ways this can be executed. One way is for the driver to rely on the array-processing capabilities of the back end, in which case the entire statement with the array of parameters is treated as one atomic unit. Oracle is an example of a data source that supports array processing capabilities. Another way to implement this feature is for the driver to generate a batch of SQL statements, one SQL statement for each set of parameters in the parameter array, and execute the batch. Arrays of parameters cannot be used with an <b>UPDATE WHERE CURRENT OF</b> statement.</p>
<p>
When an array of parameters is processed, individual result sets/row counts (one for each parameter set) can be available, or result sets/rows counts can be rolled up into one. The SQL_PARAM_ARRAY_ROW_COUNTS option in <b>SQLGetInfo</b> indicates whether row counts are available for each set of parameters (SQL_PARC_BATCH), or only one row count is available (SQL_PARC_NO_BATCH). </p>
<p>
The SQL_PARAM_ARRAY_SELECTS option in <b>SQLGetInfo</b> indicates whether a result set is available for each set of parameters (SQL_PAS_BATCH), or only one result set is available (SQL_PAS_NO_BATCH). If the driver does not allow a result set&nbsp;–&nbsp;generating statement to be executed with an array of parameters, SQL_PARAM_ARRAY_SELECTS returns SQL_PAS_NO_SELECT. </p>
<p>
For more information, see <a href="odch21gpr_5fu7.htm">SQLGetInfo</a>.</p>
<p>
To support arrays of parameters, the SQL_ATTR_PARAMSET_SIZE statement attribute is set to specify the number of values for each parameter. If the field is greater than 1, the SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR, and SQL_DESC_OCTET_LENGTH_PTR fields of the APD must point to arrays. The cardinality of each array is equal to the value of SQL_ATTR_PARAMSET_SIZE.</p>
<p>
The SQL_DESC_ROWS_PROCESSED_PTR field of the APD points to a buffer that contains the number of sets of parameters that have been processed, including error sets. As each set of parameters is processed, the driver stores a new value in the buffer. No number will be returned if this is a null pointer. When arrays of parameters are used, the value pointed to by the SQL_DESC_ROWS_PROCESSED_PTR field of the APD is populated even if SQL_ERROR is returned by the setting function. If SQL_NEED_DATA is returned, the value pointed to by the SQL_DESC_ROWS_PROCESSED_PTR field of the APD is set to the set of parameters that is being processed.</p>
<p>
It is driver-defined what occurs when an array of parameters is bound and an <b>UPDATE WHERE CURRENT OF</b> statement is executed.</p>
<h1>Column-Wise Parameter Binding</h1>
<p>
In column-wise binding, the application binds separate parameter and length/indicator arrays to each parameter.</p>
<p>
To use column-wise binding, the application first sets the SQL_ATTR_PARAM_BIND_TYPE statement attribute to SQL_PARAM_BIND_BY_COLUMN (this is the default). For each column to be bound, the application performs the following steps:
<ol>
<li>
Allocates a parameter buffer array.<br><br></li>
<li>
Allocates an array of length/indicator buffers.<p class=atl>
<B><b>Note&nbsp;&nbsp;&nbsp;</b></B>If the application writes directly to descriptors when column-wise binding is used, then separate arrays can be used for length and indicator data.</p></li>
<li>
Calls <b>SQLBindParameter</b> with the following arguments:<ul type=disc>
<li>
<i>ValueType</i> is the C type of a single element in the parameter buffer array.<br><br></li>
<li>
<i>ParameterType</i> is the SQL type of the parameter.<br><br></li>
<li>
<i>ParameterValuePtr</i> is the address of the parameter buffer array.<br><br></li>
<li>
<i>BufferLength</i> is the size of a single element in the parameter buffer array. The <i>BufferLength</i> argument is ignored when the data is fixed-length data.<br><br></li>
<li>
<i>StrLen_or_IndPtr</i> is the address of the length/indicator array.</li>
</ul>
</li>
</ol>
<p>
For more information about how this information is used, see “ParameterValuePtr Argument” in “Comments” later in this section. For more information about column-wise binding of parameters, see the “<a href="odch09pr_3j3n.htm">Binding Arrays of Parameters</a>” section in Chapter 9, “Executing Statements.”</p>
<h1>Row-Wise Parameter Binding</h1>
<p>
In row-wise binding, the application defines a structure containing parameter and length/indicator buffers for each parameter to be bound.</p>
<p>
To use row-wise binding, the application performs the following steps:
<ol>
<li>
Defines a structure to hold a single set of parameters (including both parameter and length/indicator buffers) and allocates an array of these structures.<p class=atl>
<B><b>Note&nbsp;&nbsp;&nbsp;</b></B>If the application writes directly to descriptors when row-wise binding is used, then separate fields can be used for length and indicator data.</p></li>
<li>
Sets the SQL_ATTR_PARAM_BIND_TYPE statement attribute to the size of the structure containing a single set of parameters, or to the size of an instance of a buffer into which the parameters will be bound. The length must include space for all of the bound parameters, and any padding of the structure or buffer to make sure that when the address of a bound parameter is incremented with the specified length, the result will point to the beginning of the same parameter in the next row. When using the <i>sizeof</i> operator in ANSI C, this behavior is guaranteed.<br><br></li>
<li>
Calls <b>SQLBindParameter</b> with the following arguments for each parameter to be bound:<ul type=disc>
<li>
<i>ValueType</i> is the type of the parameter buffer member to be bound to the column.<br><br></li>
<li>
<i>ParameterType</i> is the SQL type of the parameter.<br><br></li>
<li>
<i>ParameterValuePtr</i> is the address of the parameter buffer member in the first array element.<br><br></li>
<li>
<i>BufferLength</i> is the size of the parameter buffer member.<br><br></li>
<li>
<i>StrLen_or_IndPtr</i> is the address of the length/indicator member to be bound.</li>
</ul>
</li>
</ol>
<p>
For more information about how this information is used, see “<i>ParameterValuePtr</i> Argument,” later in this section. For more information about row-wise binding of parameters, see the “<a href="odch09pr_3j3n.htm">Binding Arrays of Parameters</a>” section in Chapter 9, “Executing Statements.”</p>
<h1>Error Information</h1>
<p>
If a driver does not implement parameter arrays as batches (the SQL_PARAM_ARRAY_ROW_COUNTS option<i> </i>is equal to SQL_PARC_NO_BATCH), error situations are handled as if one statement were executed. If the driver does implement parameter arrays as batches, an application can use the SQL_DESC_ARRAY_STATUS_PTR header field of the IPD to determine which parameter of an SQL statement, or which parameter in an array of parameters, caused <b>SQLExecDirect</b> or <b>SQLExecute</b> to return an error. This field contains status information for each row of parameter values. If the field indicates that an error has occurred, fields in the diagnostic data structure will indicate the row and parameter number of the parameter that failed. The number of elements in the array will be defined by the SQL_DESC_ARRAY_SIZE header field in the APD, which can be set by the SQL_ATTR_PARAMSET_SIZE statement attribute. </p>
<p class=indent>
<B><b>Note&nbsp;&nbsp;&nbsp;</b></B>The SQL_DESC_ARRAY_STATUS_PTR header field in the APD is used to ignore parameters. For more information about ignoring parameters, see the next section, “Ignoring a Set of Parameters.”</p>
<p>
When <b>SQLExecute</b> or <b>SQLExecDirect</b> returns SQL_ERROR, the elements in the array pointed to by the SQL_DESC_ARRAY_STATUS_PTR field in the IPD will contain SQL_PARAM_ERROR, SQL_PARAM_SUCCESS, SQL_PARAM_SUCCESS_WITH_INFO, SQL_PARAM_UNUSED, or SQL_PARAM_DIAG_UNAVAILABLE. </p>
<p>
For each in this array, the diagnostic data structure contains one or more status records. The SQL_DIAG_ROW_NUMBER field of the structure indicates the row number of the parameter values that caused the error. If it is possible to determine the particular parameter in a row of parameters that caused the error, then the parameter number will be entered in the SQL_DIAG_COLUMN_NUMBER field.</p>
<p>
SQL_PARAM_UNUSED is entered when a parameter has not been used because an error occurred in an earlier parameter that forced <b>SQLExecute </b>or <b>SQLExecDirect </b>to abort. For example, if there are 50 parameters and an error occurred while executing the fortieth set of parameters that caused <b>SQLExecute </b>or <b>SQLExecDirect </b>to abort, then SQL_PARAM_UNUSED is entered in the status array for parameters 41 through 50.</p>
<p>
SQL_PARAM_DIAG_UNAVAILABLE is entered when the driver treats arrays of parameters as a monolithic unit, so it does not generate this level of error information.</p>
<p>
Some errors in the processing of a single set of parameters cause processing of the subsequent sets of parameters in the array to stop. Other errors do not affect the processing of subsequent parameters. It is driver-defined which errors will stop processing. If processing is not stopped, all parameters in the array are processed, SQL_SUCCESS_WITH_INFO is returned as a result of the error, and the buffer defined by SQL_ATTR_PARAMS_PROCESSED_PTR is set to the total number of sets of parameters processed (as defined by the SQL_ATTR_PARAMSET_SIZE statement attribute), which includes error sets.</p>
<p class=indent>
<B><b>Caution&nbsp;&nbsp;&nbsp;</b></B>ODBC behavior when an error occurs in the processing of an array of parameters is different in ODBC 3.x than it was in ODBC 2.<i>x</i>. In ODBC 2.<i>x</i>, the function returned SQL_ERROR and processing ceased. The buffer pointed to by the <i>pirow</i> argument of <b>SQLParamOptions</b> contained the number of the error row. In ODBC 3.x, the function returns SQL_SUCCESS_WITH_INFO and processing may either cease or continue. If it continues, the buffer specified by SQL_ATTR_PARAMS_PROCESSED_PTR will be set to the value of all parameters processed, including those that resulted in an error. This change in behavior may cause problems for existing applications.</p>
<p>
When <b>SQLExecute</b> or <b>SQLExecDirect</b> returns before completing the processing of all parameter sets in a parameter array, such as when SQL_ERROR or SQL_NEED_DATA is returned, the status array contains statuses for those parameters that have already been processed. The location pointed to by the SQL_DESC_ROWS_PROCESSED_PTR field in the IPD contains the row number in the parameter array that caused the SQL_ERROR or SQL_NEED_DATA error code. When an array of parameters is sent to a SELECT statement, the availability of status array values is driver-defined; they may be available after the statement has been executed, or as result sets are fetched.</p>
<h1>Ignoring a Set of Parameters</h1>
<p>
The SQL_DESC_ARRAY_STATUS_PTR field of the APD (as set by the SQL_ATTR_PARAM_STATUS_PTR statement attribute) can be used to indicate that a set of bound parameters in an SQL statement should be ignored. To direct the driver to ignore one or more sets of parameters during execution, an application should perform the following steps:
<ol>
<li>
Call <b>SQLSetDescField</b> to set the SQL_DESC_ARRAY_STATUS_PTR header field of the APD to point to an array of SQLUSMALLINT values to contain status information. This field can also be set by calling <b>SQLSetStmtAttr</b> with an <i>Attribute</i> of SQL_ATTR_PARAM_OPERATION_PTR, which allows an application to set the field without obtaining a descriptor handle.<br><br></li>
<li>
Set each element of the array defined by the SQL_DESC_ARRAY_STATUS_PTR field of the APD to one of two values:<ul type=disc>
<li>
SQL_PARAM_IGNORE, to indicate that the row is excluded from statement execution.<br><br></li>
<li>
SQL_PARAM_PROCEED, to indicate that the row is included in statement execution.</li>
</ul>
</li>
<li>
Call <b>SQLExecDirect</b> or <b>SQLExecute</b> to execute the prepared statement.</li>
</ol>
<p>
The following rules apply to the array defined by the SQL_DESC_ARRAY_STATUS_PTR field of the APD:
<ul type=disc>
<li>
The pointer is set to null by default.<br><br></li>
<li>
If the pointer is null, then all sets of parameters are used, as if all elements were set to SQL_ROW_PROCEED.<br><br></li>
<li>
Setting an element to SQL_PARAM_PROCEED does not guarantee that the operation will use that particular set of parameters.<br><br></li>
<li>
SQL_PARAM_PROCEED is defined as 0 in the header file.</li>
</ul>
<p>
An application can set the SQL_DESC_ARRAY_STATUS_PTR field in the APD to point to the same array as that pointed to by the SQL_DESC_ARRAY_STATUS_PTR field in the IRD. This is useful when binding parameters to row data. Parameters then can be ignored according to the status of the row data. The following codes cause a parameter in an SQL statement to be ignored, in addition to SQL_PARAM_IGNORE: SQL_ROW_DELETED, SQL_ROW_UPDATED, and SQL_ROW_ERROR. The following codes cause an SQL statement to proceed, in addition to SQL_PARAM_PROCEED: SQL_ROW_SUCCESS, SQL_ROW_SUCCESS_WITH_INFO, and SQL_ROW_ADDED.</p>
<h1>Rebinding Parameters</h1>
<p>
An application can perform either of two operations to change a binding:
<ul type=disc>
<li>
Call <b>SQLBindParameter</b> to specify a new binding for a column that is already bound. The driver overwrites the old binding with the new one.<br><br></li>
<li>
Specify an offset to be added to the buffer address that was specified by the binding call to <b>SQLBindParameter</b>. For more information, see the next section, “Rebinding with Offsets.”</li>
</ul>
<h1>Rebinding with Offsets</h1>
<p>
Rebinding of parameters is especially useful when an application has a buffer area setup that is capable of containing many parameters, but a call to <b>SQLExecDirect</b> or <b>SQLExecute</b> uses only a few of the parameters. The remaining space in the buffer area can be used for the next set of parameters by modifying the existing binding by an offset.</p>
<p>
The SQL_DESC_BIND_OFFSET_PTR header field in the APD points to the binding offset. If the field is non-null, the driver dereferences the pointer and, if none of the values in the SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR, and SQL_DESC_OCTET_LENGTH_PTR fields is a null pointer, adds the dereferenced value to those fields in the descriptor records at execution time. The new pointer values are used when the SQL statements are executed. The offset remains valid after rebinding. Because SQL_DESC_BIND_OFFSET_PTR is a pointer to the offset, rather than the offset itself, an application can change the offset directly, without having to call <a href="odch21jpr_7e90.htm">SQLSetDescField</a> or <a href="odch21jpr_0q3n.htm">SQLSetDescRec</a> to change the descriptor field. The pointer is set to null by default. The SQL_DESC_BIND_OFFSET_PTR field of the ARD can be set by a call to <a href="odch21jpr_7e90.htm">SQLSetDescField</a> or<b> </b>by a call to <a href="odch21kpr_77jm.htm">SQLSetStmtAttr</a><b> </b>with an <i>fAttribute</i> of SQL_ATTR_PARAM_BIND_OFFSET_PTR.</p>
<p>
The binding offset is always added directly to the values in the SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR, and SQL_DESC_OCTET_LENGTH_PTR fields. If the offset is changed to a different value, the new value is still added directly to the value in each descriptor field. The new offset is not added to the sum of the field value and any earlier offsets.</p>
<h1>Descriptors</h1>
<p>
How a parameter is bound is determined by fields of the APDs and IPDs. The arguments in <b>SQLBindParameter</b> are used to set those descriptor fields. The fields also can be set by the <b>SQLSetDescField</b> functions, although <b>SQLBindParameter</b> is more efficient to use because the application does not have to obtain a descriptor handle to call <b>SQLBindParameter</b>. </p>
<p class=indent>
<B><b>Caution&nbsp;&nbsp;&nbsp;</b></B>Calling <b>SQLBindParameter</b> for one statement can affect other statements. This occurs when the ARD associated with the statement is explicitly allocated and is also associated with other statements. Because <b>SQLBindParameter</b> modifies the fields of the APD, the modifications apply to all statements with which this descriptor is associated. If this is not the required behavior, the application should dissociate this descriptor from the other statements before calling <b>SQLBindParameter</b>.</p>
<p>
Conceptually, <b>SQLBindParameter</b> performs the following steps in sequence:
<ol>
<li>
Calls <a href="odch21hpr_9uya.htm">SQLGetStmtAttr</a> to obtain the APD handle.<br><br></li>
<li>
Calls <a href="odch21gpr_70bo.htm">SQLGetDescField</a> to get the APD’s SQL_DESC_COUNT field, and if the value of the <i>ColumnNumber</i> argument exceeds the value of SQL_DESC_COUNT, calls <b>SQLSetDescField</b> to increase the value of SQL_DESC_COUNT to <i>ColumnNumber</i>.<br><br></li>
<li>
Calls <a href="odch21jpr_7e90.htm">SQLSetDescField</a> multiple times to assign values to the following fields of the APD:<ul type=disc>
<li>
Sets SQL_DESC_TYPE and SQL_DESC_CONCISE_TYPE to the value of <i>ValueType</i>, except that if <i>ValueType</i> is one of the concise identifiers of a datetime or interval subtype, it sets SQL_DESC_TYPE to SQL_DATETIME or SQL_INTERVAL, respectively, sets SQL_DESC_CONCISE_TYPE to the concise identifier, and sets SQL_DESC_DATETIME_INTERVAL_CODE to the corresponding datetime or interval subcode.<br><br></li>
<li>
Sets the SQL_DESC_OCTET_LENGTH field to the value of <i>BufferLength</i>.<br><br></li>
<li>
Sets the SQL_DESC_DATA_PTR field to the value of <i>ParameterValue</i>.<br><br></li>
<li>
Sets the SQL_DESC_OCTET_LENGTH_PTR field to the value of <i>StrLen_or_Ind</i>.<br><br></li>
<li>
Sets the SQL_DESC_INDICATOR_PTR field also to the value of <i>StrLen_or_Ind</i>.</li>
</ul>
<p class=tl>
The <i>StrLen_or_Ind</i> parameter specifies both the indicator information and the length for the parameter value.</P></li>
<li>
Calls <a href="odch21hpr_9uya.htm">SQLGetStmtAttr</a> to obtain the IPD handle.<br><br></li>
<li>
Calls <a href="odch21gpr_70bo.htm">SQLGetDescField</a> to get the IPD’s SQL_DESC_COUNT field, and if the value of the <i>ColumnNumber</i> argument exceeds the value of SQL_DESC_COUNT, calls <b>SQLSetDescField</b> to increase the value of SQL_DESC_COUNT to <i>ColumnNumber</i>.<br><br></li>
<li>
Calls <a href="odch21jpr_7e90.htm">SQLSetDescField</a> multiple times to assign values to the following fields of the IPD:<ul type=disc>
<li>
Sets SQL_DESC_TYPE and SQL_DESC_CONCISE_TYPE to the value of <i>ParameterType</i>, except that if <i>ParameterType</i> is one of the concise identifiers of a datetime or interval subtype, it sets SQL_DESC_TYPE to SQL_DATETIME or SQL_INTERVAL, respectively, sets SQL_DESC_CONCISE_TYPE to the concise identifier, and sets SQL_DESC_DATETIME_INTERVAL_CODE to the corresponding datetime or interval subcode.<br><br></li>
<li>
Sets one or more of SQL_DESC_LENGTH, SQL_DESC_PRECISION, and SQL_DESC_DATETIME_INTERVAL_PRECISION, as appropriate for <i>ParameterType</i>.<br><br></li>
<li>
Sets SQL_DESC_SCALE to the value of <i>DecimalDigits</i>.</li>
</ul>
</li>
</ol>
<p>
If the call to <b>SQLBindParameter</b> fails, the content of the descriptor fields that it would have set in the APD are undefined, and the SQL_DESC_COUNT field of the APD is unchanged. In addition, the SQL_DESC_LENGTH, SQL_DESC_PRECISION, SQL_DESC_SCALE, and SQL_DESC_TYPE fields of the appropriate record in the IPD are undefined and the SQL_DESC_COUNT field of the IPD is unchanged.</p>
<h1>Conversion of Calls to and from SQLSetParam</h1>
<p>
When an ODBC 1.0 application calls <b>SQLSetParam</b> in an ODBC 3.x driver, the ODBC 3.x Driver Manager maps the call as follows:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=595>
<tr valign=top>
<td class=label width=44%><b>Call by ODBC 1.0 application</b></td>
<td class=label width=56%><b>Call to ODBC 3.x driver</b></td>
</tr>
<tr valign=top>
<td width=44%>SQLSetParam(<br>
StatementHandle,<br>
ParameterNumber,<br>
ValueType,<br>
ParameterType,<br>
LengthPrecision,<br>
ParameterScale,<br>
ParameterValuePtr,<br>
StrLen_or_IndPtr);</td>
<td width=56%>SQLBindParameter(<br>
StatementHandle,<br>
ParameterNumber,<br>
SQL_PARAM_INPUT_OUTPUT,<br>
ValueType,<br>
ParameterType,<br>
<i>ColumnSize</i>,<br>
<i>DecimalDigits</i>,<br>
ParameterValuePtr,<br>
SQL_SETPARAM_VALUE_MAX,<br>
StrLen_or_IndPtr);</td>
</tr>
</table><br>
<p class=label>
<b>Code Example</b></p>
<p>
In the following example, an application prepares an SQL statement to insert data into the ORDERS table. The SQL statement contains parameters for the ORDERID, CUSTID, OPENDATE, SALESPERSON, and STATUS columns. For each parameter in the statement, the application calls <b>SQLBindParameter</b> to specify the ODBC C data type and the SQL data type of the parameter, and to bind a buffer to each parameter. For each row of data, the application assigns data values to each parameter and calls <b>SQLExecute</b> to execute the statement.</p>
<p>
For more code examples, see <a href="odch21bpr_9er7.htm">SQLBulkOperations</a>, <a href="odch21jpr_2y0j.htm">SQLProcedures</a>, <a href="odch21jpr_2cf5.htm">SQLPutData</a>, and <a href="odch21kpr_2rsj.htm">SQLSetPos</a>.</p>
<pre><code>#define SALES_PERSON_LEN 10
#define STATUS_LEN 6

SQLSMALLINT&nbsp;&nbsp; sOrderID;
SQLSMALLINT&nbsp;&nbsp; sCustID;
DATE_STRUCT dsOpenDate;
SQLCHAR&nbsp;&nbsp; szSalesPerson[SALES_PERSON_LEN];
SQLCHAR&nbsp;&nbsp; szStatus[STATUS_LEN);
SQLINTEGER&nbsp; cbOrderID = 0, cbCustID = 0, cbOpenDate = 0, cbSalesPerson = SQL_NTS,
 &nbsp;&nbsp; cbStatus = SQL_NTS;
SQLRETURN retcode;
SQLHSTMT&nbsp; hstmt;

/* Prepare the SQL statement with parameter markers. */
retcode = SQLPrepare(hstmt,
 &nbsp;&nbsp; "INSERT INTO ORDERS (ORDERID, CUSTID, OPENDATE, SALESPERSON,
 &nbsp;&nbsp; STATUS) VALUES (?, ?, ?, ?, ?)", SQL_NTS);

if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) {

   /* Specify data types and buffers for OrderID, CustID, OpenDate, SalesPerson, */
 /* Status&nbsp; parameter data. */

   SQLBindParameter(hstmt, 1, SQL_PARAM_INPUT, SQL_C_SSHORT,
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SQL_INTEGER, 0, 0, &amp;sOrderID, 0, &amp;cbOrderID);
   SQLBindParameter(hstmt, 2, SQL_PARAM_INPUT, SQL_C_SSHORT,
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SQL_INTEGER, 0, 0, &amp;sCustID, 0, &amp;cbCustID);
   SQLBindParameter(hstmt, 3, SQL_PARAM_INPUT, SQL_C_TYPE_DATE,
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SQL_TYPE_DATE, 0, 0, &amp;dsOpenDate, 0, &amp;cbOpenDate); 
   SQLBindParameter(hstmt, 4, SQL_PARAM_INPUT, SQL_C_CHAR,
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SQL_CHAR, SALES_PERSON_LEN, 0, szSalesPerson, 0, &amp;cbSalesPerson); 
   SQLBindParameter(hstmt, 5, SQL_PARAM_INPUT, SQL_C_CHAR,
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SQL_CHAR, STATUS_LEN, 0, szStatus, 0, &amp;cbStatus);

   /* Specify first row of parameter data. */
   sOrderID = 1001;&nbsp; 
   sCustID = 298;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
   dsOpenDate.year = 1996;
   dsOpenDate.month = 3;
   dsOpenDate.day = 8;
   strcpy(szSalesPerson, "Johnson");
   strcpy(szStatus, "Closed");

/* Execute statement with first row. */
   retcode = SQLExecute(hstmt);&nbsp;&nbsp; 

/* Specify second row of parameter data. */
   sOrderID = 1002;&nbsp;&nbsp; 
   sCustID = 501;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
   dsOpenDate.year = 1996;
   dsOpenDate.month = 3;
   dsOpenDate.day = 9; 
   strcpy(szSalesPerson, "Bailey");
   strcpy(szStatus, "Open");

/* Execute statement with second row. */
   retcode = SQLExecute(hstmt);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
}
</code></pre>
<p class=label>
<b>Code Example</b></p>
<p>
In the following example, an application executes an SQL Server stored procedure using a named parameter. Note that the named parameter (@quote) is bound with a <i>ParameterNumber</i> of 1, while it is the second parameter in the procedure definition. Because the first parameter (@title_id) has a default value of 1, the named parameter is the only dynamic parameter.</p>
<pre><code>/* Define the stored procedure “test” */
CREATE PROCEDURE test @title_id int = 1, @quote char(30)
AS &lt;blah&gt;

/* Prepare the procedure invocation statement */
SQLPrepare(hstmt, “{call test(?)}”, SQL_NTS);

/* Populate record 1 of IPD */
SQLBindParameter(hstmt, 1, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_CHAR, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 30, 0, szQuote, 0, &amp;cbValue);

/* Get IPD handle and set the NAMED and UNNAMED fields for record # 1 */
SQLGetStmtAttr(hstmt, SQL_ATTR_IMP_PARAM_DESC, &amp;hIpd, 0, 0);
SQLSetDescField(hIpd, 1, SQL_DESC_NAME, “@quote”, SQL_NTS);

/* Assuming that szQuote has been appropriately initialized, execute the statement */
SQLExecute(hstmt);
</code></pre>
<p class=label>
<b>Related Functions</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=595>
<tr valign=top>
<td class=label width=54%><b>For information about</b></td>
<td class=label width=46%><b>See</b></td>
</tr>
<tr valign=top>
<td width=54%>Returning information about a parameter in <br>
a statement</td>
<td width=46%><a href="odch21dpr_14x9.htm">SQLDescribeParam</a></td>
</tr>
<tr valign=top>
<td width=54%>Executing an SQL statement</td>
<td width=46%><a href="odch21epr_35x0.htm">SQLExecDirect</a></td>
</tr>
<tr valign=top>
<td width=54%>Executing a prepared SQL statement</td>
<td width=46%><a href="odch21epr_0yg5.htm">SQLExecute</a></td>
</tr>
<tr valign=top>
<td width=54%>Releasing parameter buffers on the statement</td>
<td width=46%><a href="odch21fpr_84hg.htm">SQLFreeStmt</a></td>
</tr>
<tr valign=top>
<td width=54%>Returning the number of statement <br>
parameters</td>
<td width=46%><a href="odch21hpr_08fn.htm">SQLNumParams</a></td>
</tr>
<tr valign=top>
<td width=54%>Returning the next parameter to send data <br>
for</td>
<td width=46%><a href="odch21ipr_11i9.htm">SQLParamData</a></td>
</tr>
<tr valign=top>
<td width=54%>Specifying multiple parameter values</td>
<td width=46%><a href="odch21ipr_7y0j.htm">SQLParamOptions</a></td>
</tr>
<tr valign=top>
<td width=54%>Sending parameter data at execution time</td>
<td width=46%><a href="odch21jpr_2cf5.htm">SQLPutData</a></td>
</tr>
</table><br>
</font></BODY>
</HTML>
