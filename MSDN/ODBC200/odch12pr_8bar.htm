<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Updating Rows in the Rowset with SQLSetPos</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h2><a name="odbcupdating_rows_in_the_rowset_with_sqlsetpos"></a>Updating Rows in the Rowset with SQLSetPos</h2>
<p>
The update operation of <b>SQLSetPos</b> makes the data source update one or more selected rows of a table, using data in the application buffers for each bound column (unless the value in the length/indicator buffer is SQL_COLUMN_IGNORE). Columns that are not bound will not be updated.</p>
<p>
To update rows with <b>SQLSetPos</b>, the application does the following:
<ol>
<li>
Places the new data values in the rowset buffers. For information on how to send long data with <b>SQLSetPos</b>, see “<a href="odch12pr_8qgj.htm">Long Data and SQLSetPos and SQLBulkOperations</a>,” later in this chapter.<br><br></li>
<li>
Sets the value in the length/indicator buffer of each column as necessary. This is the byte length of the data or SQL_NTS for columns bound to string buffers, the byte length of the data for columns bound to binary buffers, and SQL_NULL_DATA for any columns to be set to NULL.<br><br></li>
<li>
Sets the value in the length/indicator buffer of those columns which are not to be updated to SQL_COLUMN_IGNORE. Although the application can skip this step and resend existing data, this is inefficient and risks sending values to the data source that were truncated when they were read.<br><br></li>
<li>
Calls <b>SQLSetPos</b> with <i>Operation</i> set to SQL_UPDATE and <i>RowNumber</i> set to the number of the row to update. If <i>RowNumber</i> is 0, all rows in the rowset are updated. </li>
</ol>
<p>
After <b>SQLSetPos</b> returns, the current row is set to the updated row.</p>
<p>
When updating all rows of the rowset (<i>RowNumber</i> is equal to 0), an application can disable the update of certain rows by setting the corresponding elements of the row operation array (pointed to by the SQL_ATTR_ROW_OPERATION_PTR statement attribute) to SQL_ROW_IGNORE. The row operation array corresponds in size and number of elements to the row status array (pointed to by the SQL_ATTR_ROW_STATUS_PTR statement attribute). To update only those rows in the result set that were successfully fetched and have not been deleted from the rowset, the application uses the row status array from the function that fetched the rowset as the row operation array to <b>SQLSetPos</b>.</p>
<p>
For every row that is sent to the data source as an update, the application buffers should have valid row data. If the application buffers were filled by fetching and if a row status array has been maintained, its values at each of these row positions should not be SQL_ROW_DELETED, SQL_ROW_ERROR, or SQL_ROW_NOROW.</p>
<p>
For example, the following code allows a user to scroll through the Customers table and update, delete, or add new rows. It places the new data in the rowset buffers before calling <b>SQLSetPos</b> to update or add new rows. An extra row is allocated at the end of the rowset buffers to hold new rows; this prevents existing data from being overwritten when data for a new row is placed in the buffers.</p>
<pre><code>#define UPDATE_ROW 100
#define DELETE_ROW 101
#define ADD_ROW&nbsp; 102

SQLUINTEGER&nbsp; CustIDArray[11];
SQLCHAR&nbsp; NameArray[11][51], AddressArray[11][51], PhoneArray[11][11];
SQLINTEGER CustIDIndArray[11], NameLenOrIndArray[11], AddressLenOrIndArray[11],
 &nbsp;&nbsp;&nbsp; PhoneLenOrIndArray[11];
SQLUSMALLINT RowStatusArray[10], Action, RowNum;
SQLRETURN&nbsp; rc;
SQLHSTMT&nbsp;&nbsp; hstmt;

// Set the SQL_ATTR_ROW_BIND_TYPE statement attribute to use column-wise binding. 
// Declare the rowset size with the SQL_ATTR_ROW_ARRAY_SIZE statement attribute. 
// Set the SQL_ATTR_ROW_STATUS_PTR statement attribute to point to the row status
// array.
SQLSetStmtAttr(hstmt, SQL_ATTR_CURSOR_TYPE, SQL_CURSOR_KEYSET_DRIVEN, 0);
SQLSetStmtAttr(hstmt, SQL_ATTR_ROW_BIND_TYPE, SQL_BIND_BY_COLUMN, 0);
SQLSetStmtAttr(hstmt, SQL_ATTR_ROW_ARRAY_SIZE, 10, 0);
SQLSetStmtAttr(hstmt, SQL_ATTR_ROW_STATUS_PTR, RowStatusArray, 0);

// Bind arrays to the CustID, Name, Address, and Phone columns.
SQLBindCol(hstmt, 1, SQL_C_ULONG, CustIDArray, 0, CustIDIndArray);
SQLBindCol(hstmt, 2, SQL_C_CHAR, NameArray, sizeof(NameArray[0]), NameLenOrIndArray);
SQLBindCol(hstmt, 3, SQL_C_CHAR, AddressArray, sizeof(AddressArray[0]),
 &nbsp;&nbsp;&nbsp; AddressLenOrIndArray);
SQLBindCol(hstmt, 4, SQL_C_CHAR, PhoneArray, sizeof(PhoneArray[0]),
 &nbsp;&nbsp;&nbsp; PhoneLenOrIndArray);

// Execute a statement to retrieve rows from the Customers table.
SQLExecDirect(hstmt, "SELECT CustID, Name, Address, Phone FROM Customers", SQL_NTS);

// Fetch and display the first 10 rows.
rc = SQLFetchScroll(hstmt, SQL_FETCH_NEXT, 0);
DisplayData(CustIDArray, CustIDIndArray, NameArray, NameLenOrIndArray, AddressArray,
 &nbsp;&nbsp; AddressLenOrIndArray, PhoneArray, PhoneLenOrIndArray, RowStatusArray);

// Call GetAction to get an action and a row number from the user.
while (GetAction(&amp;Action, &amp;RowNum)) {
 switch (Action) {

  case SQL_FETCH_NEXT:
  case SQL_FETCH_PRIOR:
  case SQL_FETCH_FIRST:
  case SQL_FETCH_LAST:
  case SQL_FETCH_ABSOLUTE:
  case SQL_FETCH_RELATIVE:
 &nbsp; // Fetch and display the requested data.
 &nbsp; SQLFetchScroll(hstmt, Action, RowNum);
 &nbsp; DisplayData(CustIDArray, CustIDIndArray,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NameArray, NameLenOrIndArray,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AddressArray, AddressLenOrIndArray,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PhoneArray, PhoneLenOrIndArray, RowStatusArray);
 &nbsp; break;

  case UPDATE_ROW:
 &nbsp; // Place the new data in the rowset buffers and update the specified row.
 &nbsp; GetNewData(&amp;CustIDArray[RowNum - 1], &amp;CustIDIndArray[RowNum - 1],
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NameArray[RowNum - 1], &amp;NameLenOrIndArray[RowNum - 1],
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AddressArray[RowNum - 1], &amp;AddressLenOrIndArray[RowNum - 1],
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PhoneArray[RowNum - 1], &amp;PhoneLenOrIndArray[RowNum - 1]);
 &nbsp; SQLSetPos(hstmt, RowNum, SQL_UPDATE, SQL_LOCK_NO_CHANGE);
 &nbsp; break;

  case DELETE_ROW:
 &nbsp; // Delete the specified row.
 &nbsp; SQLSetPos(hstmt, RowNum, SQL_DELETE, SQL_LOCK_NO_CHANGE);
 &nbsp; break;

  case ADD_ROW:
 &nbsp; // Place the new data in the rowset buffers at index 10. This is an extra
 &nbsp; // element for new rows so rowset data is not overwritten. Insert the new
 &nbsp; // row. Row 11 corresponds to index 10.
 &nbsp; GetNewData(&amp;CustIDArray[10], &amp;CustIDIndArray[10],
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NameArray[10], &amp;NameLenOrIndArray[10],
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AddressArray[10], &amp;AddressLenOrIndArray[10],
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PhoneArray[10], &amp;PhoneLenOrIndArray[10]);
 &nbsp; SQLSetPos(hstmt, 11, SQL_ADD, SQL_LOCK_NO_CHANGE);
 &nbsp; break;
 }
}

// Close the cursor.
SQLCloseCursor(hstmt);
</code></pre>
</font></BODY>
</HTML>
