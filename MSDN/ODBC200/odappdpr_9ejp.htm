<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Column Size</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="odbccolumn_size"></a>Column Size</h1>
<p>
The column (or parameter) size of numeric data types is defined as the maximum number of digits used by the data type of the column or parameter, or the precision of the data. For character types, this is the length in characters of the data; for binary data types, column size is defined as the length in bytes of the data. For the time, timestamp, and all interval data types, this is the number of characters in the character representation of this data. The column size defined for each concise SQL data type is shown in the following table.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=606>
<tr valign=top>
<td class=label width=44%><b>SQL type identifier</b></td>
<td class=label width=56%><b>Column size</b></td>
</tr>
<tr valign=top>
<td width=44%>All character types [a], [b]</td>
<td width=56%>The defined or maximum column size in characters of the column or parameter (as contained in the SQL_DESC_LENGTH descriptor field). For example, the column size of a single-byte character column defined as CHAR(10) is 10.</td>
</tr>
<tr valign=top>
<td width=44%>SQL_DECIMAL<br>
SQL_NUMERIC</td>
<td width=56%>The defined number of digits. For example, the precision of a column defined as NUMERIC(10,3) is 10.</td>
</tr>
<tr valign=top>
<td width=44%>SQL_BIT [c]</td>
<td width=56%>1</td>
</tr>
<tr valign=top>
<td width=44%>SQL_TINYINT [c]</td>
<td width=56%>3</td>
</tr>
<tr valign=top>
<td width=44%>SQL_SMALLINT [c]</td>
<td width=56%>5</td>
</tr>
<tr valign=top>
<td width=44%>SQL_INTEGER [c]</td>
<td width=56%>10</td>
</tr>
<tr valign=top>
<td width=44%>SQL_BIGINT [c]</td>
<td width=56%>19 (if signed) or 20 (if unsigned)</td>
</tr>
<tr valign=top>
<td width=44%>SQL_REAL [c]</td>
<td width=56%>7</td>
</tr>
<tr valign=top>
<td width=44%>SQL_FLOAT [c]</td>
<td width=56%>15</td>
</tr>
<tr valign=top>
<td width=44%>SQL_DOUBLE [c]</td>
<td width=56%>15</td>
</tr>
<tr valign=top>
<td width=44%>All binary types [a], [b]</td>
<td width=56%>The defined or maximum length in bytes of the column or parameter. For example, the length of a column defined as BINARY(10) is 10.</td>
</tr>
<tr valign=top>
<td width=44%>SQL_TYPE_DATE [c]</td>
<td width=56%>10 (the number of characters in the yyyy-mm-dd format).</td>
</tr>
<tr valign=top>
<td width=44%>SQL_TYPE_TIME [c]</td>
<td width=56%>8 (the number of characters in the hh-mm-ss format), or 9 + s (the number of characters in the hh:mm:ss[.fff…] format, where s is the seconds precision).</td>
</tr>
<tr valign=top>
<td width=44%>SQL_TYPE_TIMESTAMP</td>
<td width=56%>19 (the number of characters in the yyyy-mm-dd hh:mm:ss format)<p>
or </p>
<p>
20 + s (the number of characters in the yyyy-mm-dd hh:mm:ss[.fff…] format, where s is the seconds precision). </p>
</td>
</tr>
<tr valign=top>
<td width=44%>SQL_INTERVAL_SECOND</td>
<td width=56%>Where p is the interval leading precision and s is the seconds precision, p (if s=0) or p+s+1 (if s&gt;0). [d]</td>
</tr>
<tr valign=top>
<td width=44%>SQL_INTERVAL_DAY_<br>
TO_SECOND</td>
<td width=56%>Where p is the interval leading precision and s is the seconds precision, 9+p (if s=0) or 10+p+s (if s&gt;0). [d]</td>
</tr>
<tr valign=top>
<td width=44%>SQL_INTERVAL_HOUR_TO_<br>
SECOND</td>
<td width=56%>Where p is the interval leading precision and s is the seconds precision, 6+p (if s=0) or 7+p+s (if s&gt;0). [d]</td>
</tr>
<tr valign=top>
<td width=44%>SQL_INTERVAL_<br>
MINUTE_TO_<br>
SECOND</td>
<td width=56%>Where p is the interval leading precision and s is the seconds precision, 3+p (if s=0) or 4+p+s (if s&gt;0). [d]</td>
</tr>
<tr valign=top>
<td width=44%>SQL_INTERVAL_YEAR <br>
SQL_INTERVAL_MONTH<br>
SQL_INTERVAL_DAY<br>
SQL_INTERVAL_HOUR<br>
SQL_INTERVAL_MINUTE</td>
<td width=56%>p, where p is the interval leading precision. [d]</td>
</tr>
<tr valign=top>
<td width=44%>SQL_INTERVAL_<br>
YEAR_TO_MONTH<br>
SQL_INTERVAL_DAY_<br>
TO_HOUR</td>
<td width=56%>3+p, where p is the interval leading precision. [d]</td>
</tr>
<tr valign=top>
<td width=44%>SQL_INTERVAL_<br>
DAY_TO_MINUTE</td>
<td width=56%>6+p, where p is the interval leading precision. [d]</td>
</tr>
<tr valign=top>
<td width=44%>SQL_INTERVAL_HOUR_TO_<br>
MINUTE</td>
<td width=56%>3+p, where p is the interval leading precision. [d]</td>
</tr>
<tr valign=top>
<td width=44%>SQL_GUID</td>
<td width=56%> 32 (the number of characters in the aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee format, as defined in the OSF conventions) </td>
</tr>
</table><br>
<p class=mini>
[a]For an ODBC 1.0 application calling <b>SQLSetParam</b> in an ODBC 2.0 driver, and for an ODBC 2.0 application calling <b>SQLBindParameter</b> in an ODBC 1.0 driver, when *<i>StrLen_or_IndPtr</i> is SQL_DATA_AT_EXEC for a SQL_LONGVARCHAR or SQL_LONGVARBINARY type, <i>ColumnSize</i> must be set to the total length of the data to be sent, not the precision as defined in this table.</p>
<p class=mini>
[b]If the driver cannot determine the column or parameter length for a variable type, it returns SQL_NO_TOTAL.</p>
<p class=mini>
[c]The <i>ColumnSize</i> argument of <b>SQLBindParameter</b> is ignored for this data type. </p>
<p class=mini>
[d]For general rules about column length in interval data types, see “<a href="odappdpr_3qp4.htm">Interval Data Type Length</a>” earlier in this appendix.</p>
<p>
The values returned for the column (or parameter) size do not correspond to the values in any one descriptor field. The values can come from either the SQL_DESC_PRECISION or SQL_DESC_LENGTH field, depending on the type of data, as shown in the following table.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=48%><b>SQL type</b></td>
<td class=label width=52%><b>Descriptor field corresponding to column or parameter size</b></td>
</tr>
<tr valign=top>
<td width=48%>All character and binary types</td>
<td width=52%>LENGTH</td>
</tr>
<tr valign=top>
<td width=48%>All numeric types</td>
<td width=52%>PRECISION</td>
</tr>
<tr valign=top>
<td width=48%>All datetime and interval types</td>
<td width=52%>LENGTH</td>
</tr>
<tr valign=top>
<td width=48%>SQL_BIT</td>
<td width=52%>LENGTH</td>
</tr>
</table><br>
</font></BODY>
</HTML>
