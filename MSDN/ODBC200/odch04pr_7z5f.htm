<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using Length/Indicator Values</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h2><a name="odbcusing_length_indicator_values"></a>Using Length/Indicator Values</h2>
<p>
The length/indicator buffer is used to pass the byte length of the data in the data buffer or a special indicator such as SQL_NULL_DATA, which indicates that the data is NULL. Depending on the function in which it is used, a length/indicator buffer is defined to be an SQLINTEGER or an SQLSMALLINT. Therefore, a single argument is needed to describe it. If the data buffer is a nondeferred input buffer, this argument contains the byte length of the data itself or an indicator value. It is often named <i>StrLen_or_Ind</i> or a similar name. For example, the following code calls <b>SQLPutData</b> to pass a buffer full of data; the byte length (<i>ValueLen</i>) is passed directly because the data buffer (<i>ValuePtr</i>) is an input buffer.</p>
<pre><code>SQLCHAR&nbsp; ValuePtr[50];
SQLINTEGER ValueLen;

// Call local function to place data in ValuePtr. In ValueLen, return the number
// of bytes of data placed in ValuePtr. If there is not enough data, this will be
// less than 50.
FillBuffer(ValuePtr, sizeof(ValuePtr), &amp;ValueLen);

// Call SQLPutData to send the data to the driver.
SQLPutData(hstmt, ValuePtr, ValueLen);
</code></pre>
<p>
If the data buffer is a deferred input buffer, a nondeferred output buffer, or an output buffer, the argument contains the address of the length/indicator buffer. It is often named <i>StrLen_or_IndPtr</i> or a similar name. For example, the following code calls <b>SQLGetData</b> to retrieve a buffer full of data; the byte length is returned to the application in the length/indicator buffer (<i>ValueLenOrInd</i>), whose address is passed to <b>SQLGetData</b> because the corresponding data buffer (<i>ValuePtr</i>) is a nondeferred output buffer.</p>
<pre><code>SQLCHAR&nbsp; ValuePtr[50];
SQLINTEGER ValueLenOrInd;
SQLGetData(hstmt, 1, SQL_C_CHAR, ValuePtr, sizeof(ValuePtr), &amp;ValueLenOrInd);
</code></pre>
<p>
Unless it is specifically prohibited, a length/indicator buffer argument can be 0 (if nondeferred input) or a null pointer (if output or deferred input). For input buffers, this causes the driver to ignore the byte length of the data. This returns an error when passing variable-length data but is common when passing non-null, fixed-length data, as neither a length nor an indicator value is needed. For output buffers, this causes the driver to not return the byte length of the data or an indicator value. This is an error if the data returned by the driver is NULL but is common when retrieving fixed-length, non-nullable data because neither a length nor an indicator value is needed.</p>
<p>
As is the case when the address of a deferred data buffer is passed to the driver, the address of a deferred length/indicator buffer must remain valid until the buffer is unbound.</p>
<p>
The following lengths are valid as length/indicator values:
<ul type=disc>
<li>
<i>n</i>, where <i>n</i> &gt; 0.<br><br></li>
<li>
0. <br><br></li>
<li>
SQL_NTS. A string sent to the driver in the corresponding data buffer is null-terminated; this is a convenient way for C programmers to pass strings without having to calculate their byte length. This value is legal only when the application sends data to the driver. When the driver returns data to the application, it always returns the actual byte length of the data.</li>
</ul>
<p>
The following values are valid as length/indicator values. SQL_NULL_DATA is stored in the SQL_DESC_INDICATOR_PTR descriptor field; all other values are stored in the SQL_DESC_OCTET_LENGTH_PTR descriptor field.
<ul type=disc>
<li>
SQL_NULL_DATA. The data is a NULL data value and the value in the corresponding data buffer is ignored. This value is legal only for SQL data sent to or retrieved from the driver.<br><br></li>
<li>
SQL_DATA_AT_EXEC. The data buffer does not contain any data. Instead, the data will be sent with <b>SQLPutData</b> when the statement is executed, or when <b>SQLBulkOperations</b> or <b>SQLSetPos</b> is called. This value is legal only for SQL data sent to the driver. For more information, see <a href="odch21bpr_6jhu.htm">SQLBindParameter</a>, <a href="odch21bpr_9er7.htm">SQLBulkOperations</a>, and <a href="odch21kpr_2rsj.htm">SQLSetPos</a>.<br><br></li>
<li>
Result of the SQL_LEN_DATA_AT_EXEC(<i>length</i>) macro. This value is similar to SQL_DATA_AT_EXEC. For more information, see “<a href="odch09pr_7f4x.htm">Sending Long Data</a>” in Chapter 9, “Executing Statements.”<br><br></li>
<li>
SQL_NO_TOTAL. The driver cannot determine the number of bytes of long data still available to return in an output buffer. This value is legal only for SQL data retrieved from the driver.<br><br></li>
<li>
SQL_DEFAULT_PARAM. A procedure is to use the default value of an input parameter in a procedure instead of the value in the corresponding data buffer.<br><br></li>
<li>
SQL_COLUMN_IGNORE. <b>SQLBulkOperations</b> or<b> SQLSetPos</b> is to ignore the value in the data buffer. When updating a row of data by a call to <b>SQLBulkOperations</b> or<b> SQLSetPos,</b> the column value is not changed. When inserting a new row of data by a call to <b>SQLBulkOperations</b>, the column value is set to its default or, if the column does not have a default, to NULL.</li>
</ul>
</font></BODY>
</HTML>
