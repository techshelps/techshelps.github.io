<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Datetime Data Type Changes</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="odbcdatetime_data_type_changes"></a>Datetime Data Type Changes</h1>
<p>
In ODBC 3.<i>x</i>, the identifiers for date, time, and timestamp SQL data types have changed from SQL_DATE, SQL_TIME, and SQL_TIMESTAMP (with instances of <b>#define</b> in the header file of 9, 10, and 11) to SQL_TYPE_DATE, SQL_TYPE_TIME, and SQL_TYPE_TIMESTAMP (with instances of <b>#define</b> in the header file of 91, 92, and 93), respectively. The corresponding C type identifiers have changed from SQL_C_DATE, SQL_C_TIME, and SQL_C_TIMESTAMP to SQL_C_TYPE_DATE, SQL_C_TYPE_TIME, and SQL_C_TYPE_TIMESTAMP, respectively. </p>
<p>
The column size and decimal digits returned for the SQL datetime data types in ODBC 3.<i>x</i> are the same as the precision and scale returned for them in ODBC 2.<i>x</i>. These values are different than the values in the SQL_DESC_PRECISION and SQL_DESC_SCALE descriptor fields. (For more information, see Appendix D, "<a href="odappdpr_8kab.htm">Data Types</a>.")</p>
<p>
These changes affect <b>SQLDescribeCol</b>, <b>SQLDescribeParam</b>, and <b>SQLColAttribute</b>; <b>SQLBindCol</b>, <b>SQLBindParameter</b>, and <b>SQLGetData</b>; and <b>SQLColumns</b>, <b>SQLGetTypeInfo</b>, <b>SQLProcedureColumns</b>, <b>SQLStatistics</b>, and <b>SQLSpecialColumns</b>.</p>
<p>
The following table shows how the ODBC 3.x Driver Manager performs mapping of the date, time, and timestamp C data types entered in the <i>TargetType</i> arguments of <b>SQLBindCol</b> and <b>SQLGetData</b> or the <i>ValueType</i> argument of <b>SQLBindParameter</b>.</p>
<table border=1 cellpadding=5 cols=5 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=20%><b>Data type code<br>
entered</b></td>
<td class=label width=15%><b>2.<i>x</i> app to<br>
2.<i>x</i> driver</b></td>
<td class=label width=21%><b>2.<i>x</i> app to<br>
3.<i>x</i> driver</b></td>
<td class=label width=21%><b>3.<i>x</i> app to<br>
2.<i>x </i>driver</b></td>
<td class=label width=23%><b>3.<i>x</i> app to<br>
3.<i>x</i> driver</b></td>
</tr>
<tr valign=top>
<td width=20%>SQL_C_DATE (9)</td>
<td width=15%>No mapping</td>
<td width=21%>SQL_C_<br>
TYPE_DATE (91)</td>
<td width=21%>No mapping<sup> </sup>[1]</td>
<td width=23%>SQL_C_<br>
TYPE_DATE (91)</td>
</tr>
<tr valign=top>
<td width=20%>SQL_C_<br>
TYPE_DATE (91)</td>
<td width=15%>Error (from DM)</td>
<td width=21%>Error (from DM)</td>
<td width=21%>SQL_C_DATE (9)</td>
<td width=23%>No mapping<sup> </sup>[2]</td>
</tr>
<tr valign=top>
<td width=20%>SQL_C_TIME (10)</td>
<td width=15%>No mapping</td>
<td width=21%>SQL_C_<br>
TYPE_TIME (92)</td>
<td width=21%>No mapping<sup> </sup>[1]</td>
<td width=23%>SQL_C_<br>
TYPE_TIME (92)</td>
</tr>
<tr valign=top>
<td width=20%>SQL_C_<br>
TYPE_TIME (92)</td>
<td width=15%>Error (from DM)</td>
<td width=21%>Error (from DM)</td>
<td width=21%>SQL_C_TIME (10)</td>
<td width=23%>No mapping<sup> </sup>[2]</td>
</tr>
<tr valign=top>
<td width=20%>SQL_C_<br>
TIMESTAMP (11)</td>
<td width=15%>No mapping</td>
<td width=21%>SQL_C_<br>
TYPE_<br>
TIMESTAMP (93)</td>
<td width=21%>No mapping<sup> </sup>[1]</td>
<td width=23%>SQL_C_<br>
TYPE_<br>
TIMESTAMP (93)</td>
</tr>
<tr valign=top>
<td width=20%>SQL_C_<br>
TYPE_<br>
TIMESTAMP (93)</td>
<td width=15%>Error (from DM)</td>
<td width=21%>Error (from DM)</td>
<td width=21%>SQL_C_<br>
TIMESTAMP (11)</td>
<td width=23%>No mapping<sup> </sup>[2]</td>
</tr>
</table><br>
<p class=mini>
[1]&nbsp; As a result of this, an ODBC 3.<i>x</i> application working with an ODBC 2.<i>x</i> driver can use the date, time, or timestamp codes returned in the result sets that are returned by the catalog functions. </p>
<p class=mini>
[2]&nbsp; As a result of this, an ODBC 3.<i>x</i> application working with an ODBC 3.<i>x</i> driver can use the date, time, or timestamp codes returned in the result sets that are returned by the catalog functions.</p>
<p>
The following table shows how the ODBC 3.x Driver Manager performs mapping of the date, time, and timestamp SQL data types entered in the <i>ParameterType</i> argument of <b>SQLBindParameter</b> or the <i>DataType</i> argument of <b>SQLGetTypeInfo</b>.</p>
<table border=1 cellpadding=5 cols=5 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=21%><b>Data type<br>
code entered</b></td>
<td class=label width=18%><b>2.<i>x</i> app to<br>
2.<i>x</i> driver</b></td>
<td class=label width=20%><b>2.<i>x</i> app to<br>
3.<i>x</i> driver</b></td>
<td class=label width=20%><b>3.<i>x</i> app to<br>
2.<i>x</i> driver</b></td>
<td class=label width=21%><b>3.<i>x</i> app to<br>
3.<i>x</i> driver</b></td>
</tr>
<tr valign=top>
<td width=21%>SQL_DATE (9)</td>
<td width=18%>No mapping</td>
<td width=20%>SQL_TYPE_<br>
DATE (91)</td>
<td width=20%>No mapping<sup> </sup>[1]</td>
<td width=21%>SQL_TYPE_<br>
DATE (91)</td>
</tr>
<tr valign=top>
<td width=21%>SQL_TYPE_<br>
DATE (91)</td>
<td width=18%>Error (from DM)</td>
<td width=20%>Error (from DM)</td>
<td width=20%>SQL_DATE (9)</td>
<td width=21%>No mapping<sup> </sup>[2]</td>
</tr>
<tr valign=top>
<td width=21%>SQL_TIME (10)</td>
<td width=18%>No mapping</td>
<td width=20%>SQL_TYPE_<br>
TIME (92)</td>
<td width=20%>No mapping<sup> </sup>[1]</td>
<td width=21%>SQL_TYPE_<br>
TIME (92)</td>
</tr>
<tr valign=top>
<td width=21%>SQL_TYPE_<br>
TIME (92)</td>
<td width=18%>Error (from DM)</td>
<td width=20%>Error (from DM)</td>
<td width=20%>SQL_TIME (10)</td>
<td width=21%>No mapping<sup> </sup>[2]</td>
</tr>
<tr valign=top>
<td width=21%>SQL_<br>
TIMESTAMP (11)</td>
<td width=18%>No mapping</td>
<td width=20%>SQL_TYPE_<br>
TIMESTAMP (93)</td>
<td width=20%>No mapping<sup> </sup>[1]</td>
<td width=21%>SQL_TYPE_<br>
TIMESTAMP (93)</td>
</tr>
<tr valign=top>
<td width=21%>SQL_TYPE_<br>
TIMESTAMP (93)</td>
<td width=18%>Error (from DM)</td>
<td width=20%>Error (from DM)</td>
<td width=20%>SQL_<br>
TIMESTAMP (11)</td>
<td width=21%>No mapping<sup> </sup>[2]</td>
</tr>
</table><br>
<p class=mini>
<sup>1</sup>As a result of this, an ODBC 3.<i>x</i> application working with an ODBC 2.<i>x</i> driver can used the date, time, or timestamp codes returned in the result sets that are returned by the catalog functions. </p>
<p class=mini>
<sup>2</sup>As a result of this, an ODBC 3.<i>x</i> application working with an ODBC 3.<i>x</i> driver can used the date, time, or timestamp codes returned in the result sets that are returned by the catalog functions.</p>
</font></BODY>
</HTML>
