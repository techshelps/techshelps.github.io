<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Explicit Data Type Conversion</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="odbcexplicit_data_type_conversion"></a>Explicit Data Type Conversion</h1>
<p>
Explicit data type conversion is specified in terms of SQL data type definitions.</p>
<p>
The ODBC syntax for the explicit data type conversion function does not restrict conversions. The validity of specific conversions of one data type to another data type will be determined by each driver-specific implementation. The driver will, as it translates the ODBC syntax into the native syntax, reject those conversions that, although legal in the ODBC syntax, are not supported by the data source. The ODBC function <b>SQLGetInfo</b> with the conversion options (such as SQL_CONVERT_BIGINT, SQL_CONVERT_BINARY, SQL_CONVERT_INTERVAL_YEAR_MONTH, and so on) provides a way to inquire about conversions supported by the data source.</p>
<p>
The format of the <b>CONVERT</b> function is:</p>
<p>
<b>CONVERT(</b><i>value_exp</i><b>, </b><i>data_type</i><b>)</b></p>
<p>
The function returns the value specified by <i>value_exp</i> converted to the specified <i>data_type</i>, where <i>data_type</i> is one of the following keywords:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td width=46%>SQL_BIGINT</td>
<td width=54%>SQL_INTERVAL_HOUR_TO_MINUTE </td>
</tr>
<tr valign=top>
<td width=46%>SQL_BINARY</td>
<td width=54%>SQL_INTERVAL_HOUR_TO_SECOND </td>
</tr>
<tr valign=top>
<td width=46%>SQL_BIT</td>
<td width=54%>SQL_INTERVAL_MINUTE_TO_SECOND</td>
</tr>
<tr valign=top>
<td width=46%>SQL_CHAR</td>
<td width=54%>SQL_LONGVARBINARY</td>
</tr>
<tr valign=top>
<td width=46%>SQL_DECIMAL</td>
<td width=54%>SQL_LONGVARCHAR</td>
</tr>
<tr valign=top>
<td width=46%>SQL_DOUBLE</td>
<td width=54%>SQL_NUMERIC</td>
</tr>
<tr valign=top>
<td width=46%>SQL_FLOAT</td>
<td width=54%>SQL_REAL</td>
</tr>
<tr valign=top>
<td width=46%>SQL_INTEGER</td>
<td width=54%>SQL_SMALLINT</td>
</tr>
<tr valign=top>
<td width=46%>SQL_INTERVAL_MONTH</td>
<td width=54%>SQL_TYPE_DATE</td>
</tr>
<tr valign=top>
<td width=46%>SQL_INTERVAL_YEAR </td>
<td width=54%>SQL_TYPE_TIME</td>
</tr>
<tr valign=top>
<td width=46%>SQL_INTERVAL_YEAR_TO_MONTH </td>
<td width=54%>SQL_TYPE_TIMESTAMP</td>
</tr>
<tr valign=top>
<td width=46%>SQL_INTERVAL_DAY </td>
<td width=54%>SQL_TINYINT</td>
</tr>
<tr valign=top>
<td width=46%>SQL_INTERVAL_HOUR </td>
<td width=54%>SQL_VARBINARY</td>
</tr>
<tr valign=top>
<td width=46%>SQL_INTERVAL_MINUTE </td>
<td width=54%>SQL_VARCHAR</td>
</tr>
<tr valign=top>
<td width=46%>SQL_INTERVAL_SECOND </td>
<td width=54%>SQL_WCHAR</td>
</tr>
<tr valign=top>
<td width=46%>SQL_INTERVAL_DAY_TO_HOUR </td>
<td width=54%>SQL_WLONGVARCHAR</td>
</tr>
<tr valign=top>
<td width=46%>SQL_INTERVAL_DAY_TO_MINUTE </td>
<td width=54%>SQL_WVARCHAR</td>
</tr>
<tr valign=top>
<td width=46%>SQL_INTERVAL_DAY_TO_SECOND </td>
<td width=54%></td>
</tr>
</table><br>
<p>
The ODBC syntax for the explicit data type conversion function does not support specification of conversion format. If specification of explicit formats is supported by the underlying data source, a driver must specify a default value or implement format specification.</p>
<p>
The argument <i>value_exp</i> can be a column name, the result of another scalar function, or a numeric or string literal. For example:</p>
<pre><code>{ fn CONVERT( { fn CURDATE() }, SQL_CHAR) }
</code></pre>
<p>
converts the output of the CURDATE scalar function to a character string.</p>
<p>
Because ODBC does not mandate a data type for return values from scalar functions as the functions are often data source&nbsp;–&nbsp;specific, applications should use the CONVERT scalar function whenever possible to force data type conversion.</p>
<p>
The following two examples illustrate the use of the <b>CONVERT</b> function. These examples assume the existence of a table called EMPLOYEES, with an EMPNO column of type SQL_SMALLINT and an EMPNAME column of type SQL_CHAR. </p>
<p>
If an application specifies the following SQL statement:</p>
<pre><code>SELECT EMPNO FROM EMPLOYEES WHERE {fn CONVERT(EMPNO,SQL_CHAR)} LIKE '1%'
</code></pre>
<ul type=disc>
<li>
A driver for ORACLE translates the SQL statement to:<pre><code>SELECT EMPNO FROM EMPLOYEES WHERE to_char(EMPNO) LIKE '1%'
</code></pre>
</li>
<li>
A driver for SQL Server translates the SQL statement to:<pre><code>SELECT EMPNO FROM EMPLOYEES WHERE convert(char,EMPNO) LIKE '1%'
</code></pre>
</li>
</ul>
<p>
If an application specifies the following SQL statement:</p>
<pre><code>SELECT {fn ABS(EMPNO)}, {fn CONVERT(EMPNAME,SQL_SMALLINT)}
 FROM EMPLOYEES WHERE EMPNO &lt;&gt; 0
</code></pre>
<ul type=disc>
<li>
A driver for ORACLE translates the SQL statement to:<pre><code>SELECT abs(EMPNO), to_number(EMPNAME) FROM EMPLOYEES WHERE EMPNO &lt;&gt; 0
</code></pre>
</li>
<li>
A driver for SQL Server translates the SQL statement to:<pre><code>SELECT abs(EMPNO), convert(smallint, EMPNAME) FROM EMPLOYEES
 WHERE EMPNO &lt;&gt; 0
</code></pre>
</li>
<li>
A driver for Ingres translates the SQL statement to:<pre><code>SELECT abs(EMPNO), int2(EMPNAME) FROM EMPLOYEES WHERE EMPNO &lt;&gt; 0
</code></pre>
</li>
</ul>
</font></BODY>
</HTML>
