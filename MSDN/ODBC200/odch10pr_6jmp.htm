<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Getting Long Data</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h2><a name="odbcgetting_long_data"></a>Getting Long Data</h2>
<p>
DBMSs define <i>long data</i> as any character or binary data over a certain size, such as 255 characters. This data may be small enough to be stored in a single buffer, such as a part description of several thousand characters. However, it may be too long to store in memory, such as long text documents or bitmaps. Because such data cannot be stored in a single buffer, it is retrieved from the driver in parts with <b>SQLGetData</b> after the other data in the row has been fetched.</p>
<p class=indent>
<B><b>Note&nbsp;&nbsp;&nbsp;</b></B>An application can actually retrieve any type of data with <b>SQLGetData</b>, not just long data, although only character and binary data can be retrieved in parts. However, if the data is small enough to fit in a single buffer, there is generally no reason to use <b>SQLGetData</b>. It is much easier to bind a buffer to the column and let the driver return the data in the buffer.</p>
<p>
To retrieve long data from a column, an application first calls <b>SQLFetchScroll</b> or <b>SQLFetch</b> to move to a row and fetch the data for bound columns. The application then calls <b>SQLGetData</b>. <b>SQLGetData</b> has the same arguments as <b>SQLBindCol</b>: a statement handle; a column number; the C data type, address, and byte length of an application variable; and the address of a length/indicator buffer. Both functions have the same arguments because they perform essentially the same task: They both describe an application variable to the driver and specify that the data for a particular column should be returned in that variable. The major differences are that <b>SQLGetData</b> is called after a row is fetched (and is sometimes called <i>late binding</i> for this reason), and that the binding specified by <b>SQLGetData</b> lasts only for the duration of the call.</p>
<p>
With respect to a single column, <b>SQLGetData</b> behaves in the same manner as <b>SQLFetch</b>: It retrieves the data for the column, converts it to the type of the application variable, and returns it in that variable. It also returns the byte length of the data in the length/indicator buffer. For more information on how <b>SQLFetch</b> returns data, see the immediately preceding section, “<a href="odch10pr_0601.htm">Fetching a Row of Data</a>.”</p>
<p>
<b>SQLGetData</b> differs from <b>SQLFetch</b> in one important respect. If it is called more than once in succession for the same column, each call returns a successive part of the data. Each call except the last call returns SQL_SUCCESS_WITH_INFO and SQLSTATE 01004 (String data, right truncated); the last call returns SQL_SUCCESS. This is how <b>SQLGetData</b> is used to retrieve long data in parts. When there is no more data to return, <b>SQLGetData</b> returns SQL_NO_DATA. The application is responsible for putting the long data together, which might mean concatenating the parts of the data. Each part is null-terminated; the application must remove the null-termination character if concatenating the parts. Retrieving data in parts can be done for variable-length bookmarks, as well as other long data. The value returned in the length/indicator buffer decreases in each call by the number of bytes returned in the previous call, although it is common for the driver to be unable to discover the amount of available data and return a byte length of SQL_NO_TOTAL. For example:</p>
<pre><code>// Declare a binary buffer to retrieve 5000 bytes of data at a time.
SQLCHAR&nbsp;&nbsp; BinaryPtr[5000];
SQLUINTEGER PartID;
SQLINTEGER&nbsp; PartIDInd, BinaryLenOrInd, NumBytes;
SQLRETURN rc; 
SQLHSTMT&nbsp; hstmt;

// Create a result set containing the ID and picture of each part.
SQLExecDirect(hstmt, "SELECT PartID, Picture FROM Pictures", SQL_NTS);

// Bind PartID to the PartID column.
SQLBindCol(hstmt, 1, SQL_C_ULONG, &amp;PartID, 0, &amp;PartIDInd);

// Retrieve and display each row of data.
while ((rc = SQLFetch(hstmt)) != SQL_NO_DATA) {
 // Display the part ID and initialize the picture.
 DisplayID(PartID, PartIDInd);
 InitPicture();

 // Retrieve the picture data in parts. Send each part and the number of bytes in
 // each part to a function that displays it. The number of bytes is always 5000 if
 // there were more than 5000 bytes available to return (cbBinaryBuffer &gt; 5000).
 // Code to check if rc equals SQL_ERROR or SQL_SUCCESS_WITH_INFO not shown.
 while ((rc = SQLGetData(hstmt, 2, SQL_C_BINARY, BinaryPtr, sizeof(BinaryPtr),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;BinaryLenOrInd)) != SQL_NO_DATA) {
  NumBytes = (BinaryLenOrInd &gt; 5000) || (BinaryLenOrInd == SQL_NO_TOTAL) ?
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5000 : BinaryLenOrInd;
  DisplayNextPictPart(BinaryPtr, NumBytes);
 }
}

// Close the cursor.
SQLCloseCursor(hstmt);
</code></pre>
<p>
There are a number of restrictions on using <b>SQLGetData</b>. In general, columns accessed with <b>SQLGetData</b>:
<ul type=disc>
<li>
Must be accessed in order of increasing column number (because of the way the columns of a result set are read from the data source). For example, it is an error to call <b>SQLGetData</b> for column 5 and then call it for column 4.<br><br></li>
<li>
Cannot be bound.<br><br></li>
<li>
Must have a higher column number than the last bound column. For example, if the last bound column is column 3, it is an error to call <b>SQLGetData</b> for column 2. For this reason, applications should be careful to place long data columns at the end of the select list.<br><br></li>
<li>
Cannot be used if <b>SQLFetch</b> or <b>SQLFetchScroll</b> was called to retrieve more than one row. For more information, see “<a href="odch11pr_9x0z.htm">Using Block Cursors</a>” in Chapter 11, “Retrieving Results (Advanced).”</li>
</ul>
<p>
Some drivers do not enforce these restrictions. Interoperable applications should either assume they exist or determine which restrictions are not enforced by calling <b>SQLGetInfo</b> with the SQL_GETDATA_EXTENSIONS option.</p>
<p>
If the application does not need all of the data in a character or binary data column, it can reduce network traffic in DBMS-based drivers by setting the SQL_ATTR_MAX_LENGTH statement attribute before executing the statement. This restricts the number of bytes of data that will be returned for any character or binary column. For example, suppose a column contains long text documents. An application that browses the table containing this column might need to display only the first page of each document. Although this statement attribute can be simulated in the driver, there is no reason to do so. In particular, if an application wants to truncate character or binary data, it should bind a small buffer to the column with <b>SQLBindCol</b> and let the driver truncate the data.</p>
</font></BODY>
</HTML>
