<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SQLSetCursorName</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="odbcsqlsetcursorname"></a>SQLSetCursorName</h1>
<p class=label>
<b>Conformance</b></p>
<p>
Version Introduced:ODBC 1.0<br>
Standards Compliance:ISO 92</p>
<p class=label>
<b>Summary</b></p>
<p>
<b>SQLSetCursorName</b> associates a cursor name with an active statement. If an application does not call <b>SQLSetCursorName</b>, the driver generates cursor names as needed for SQL statement processing.</p>
<p class=label>
<b>Syntax</b></p>
<p>
SQLRETURN <b>SQLSetCursorName</b>(<br>
SQLHSTMT<i>StatementHandle</i>,<br>
SQLCHAR *<i>CursorName</i>,<br>
SQLSMALLINT<i>NameLength</i>);</p>
<p class=label>
<b>Arguments</b></p>
<p class=dt>
<i>StatementHandle</i></p>
<p class=indent>
[Input]<br>
Statement handle.</p>
<p class=dt>
<i>CursorName</i></p>
<p class=indent>
[Input]<br>
Cursor name. For efficient processing, the cursor name should not include any leading or trailing spaces in the cursor name, and if the cursor name includes a delimited identifier, the delimiter should be positioned as the first character in the cursor name.</p>
<p class=dt>
<i>NameLength</i></p>
<p class=indent>
[Input]<br>
Length of *<i>CursorName</i>.</p>
<p class=label>
<b>Returns</b></p>
<p>
SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_ERROR, or SQL_INVALID_HANDLE.</p>
<p class=label>
<b>Diagnostics</b></p>
<p>
When <b>SQLSetCursorName</b> returns SQL_ERROR or SQL_SUCCESS_WITH_INFO, an associated SQLSTATE value can be obtained by calling <b>SQLGetDiagRec</b> with a <i>HandleType</i> of SQL_HANDLE_STMT and a <i>Handle</i> of <i>StatementHandle</i>. The following table lists the SQLSTATE values commonly returned by <b>SQLSetCursorName</b> and explains each one in the context of this function; the notation “(DM)” precedes the descriptions of SQLSTATEs returned by the Driver Manager. The return code associated with each SQLSTATE value is SQL_ERROR, unless noted otherwise.</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=22%><b>SQLSTATE</b></td>
<td class=label width=26%><b>Error</b></td>
<td class=label width=52%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=22%>01000</td>
<td width=26%>General warning</td>
<td width=52%>Driver-specific informational message. (Function returns SQL_SUCCESS_WITH_INFO.)</td>
</tr>
<tr valign=top>
<td width=22%>01004</td>
<td width=26%>String data, right truncated</td>
<td width=52%>The cursor name exceeded the maximum limit, so only the maximum allowable number of characters was used.</td>
</tr>
<tr valign=top>
<td width=22%>24000</td>
<td width=26%>Invalid cursor state</td>
<td width=52%>The statement corresponding to <i>StatementHandle</i> was already in an executed or cursor-positioned state.</td>
</tr>
<tr valign=top>
<td width=22%>34000</td>
<td width=26%>Invalid cursor name</td>
<td width=52%>The cursor name specified in *<i>CursorName</i> was invalid, because it exceeded the maximum length as defined by the driver, or it started with “SQLCUR” or “SQL_CUR.”</td>
</tr>
<tr valign=top>
<td width=22%>3C000</td>
<td width=26%>Duplicate cursor name</td>
<td width=52%>The cursor name specified in *<i>CursorName</i> already exists.</td>
</tr>
<tr valign=top>
<td width=22%>HY000</td>
<td width=26%>General error</td>
<td width=52%>An error occurred for which there was no specific SQLSTATE and for which no implementation-specific SQLSTATE was defined. The error message returned by <b>SQLGetDiagRec</b> in the <i>*MessageText</i> buffer describes the error and its cause.</td>
</tr>
<tr valign=top>
<td width=22%>HY001</td>
<td width=26%>Memory allocation <br>
error</td>
<td width=52%>The driver was unable to allocate memory required to support execution or completion of the function.</td>
</tr>
<tr valign=top>
<td width=22%>HY009</td>
<td width=26%>Invalid use of null pointer</td>
<td width=52%>(DM) The argument <i>CursorName</i> was a null pointer.</td>
</tr>
<tr valign=top>
<td width=22%>HY010</td>
<td width=26%>Function sequence error</td>
<td width=52%>(DM) An asynchronously executing function was called for the <i>StatementHandle</i> and was still executing when this function was called.<p>
(DM) <b>SQLExecute</b>, <b>SQLExecDirect</b>, <b>SQLBulkOperations</b>, or <b>SQLSetPos</b> was called for the <i>StatementHandle</i> and returned SQL_NEED_DATA. This function was called before data was sent for all data-at-execution parameters or columns.</p>
</td>
</tr>
<tr valign=top>
<td width=22%>HY013</td>
<td width=26%>Memory management error</td>
<td width=52%>The function call could not be processed because the underlying memory objects could not be accessed, possibly because of low memory conditions.</td>
</tr>
<tr valign=top>
<td width=22%>HY090</td>
<td width=26%>Invalid string or buffer length</td>
<td width=52%>(DM) The argument <i>NameLength</i> was less than 0, but not equal to SQL_NTS.</td>
</tr>
<tr valign=top>
<td width=22%>HYT01</td>
<td width=26%>Connection timeout expired</td>
<td width=52%>The connection timeout period expired before the data source responded to the request. The connection timeout period is set through <b>SQLSetConnectAttr</b>, SQL_ATTR_CONNECTION_TIMEOUT.</td>
</tr>
<tr valign=top>
<td width=22%>IM001</td>
<td width=26%>Driver does not support this function</td>
<td width=52%>(DM) The driver associated with the <i>StatementHandle</i> does not support the function.</td>
</tr>
</table><br>
<p class=label>
<b>Comments</b></p>
<p>
Cursor names are used only in positioned update and delete statements (for example, <b>UPDATE</b> <i>table-name</i> ...<b>WHERE CURRENT OF</b> <i>cursor-name</i>). For more information, see “<a href="odch12pr_58qb.htm">Positioned Update and Delete Statements</a>” in Chapter 12, “Updating Data.” If the application does not call <b>SQLSetCursorName</b> to define a cursor name, on execution of a query statement the driver generates a name that begins with the letters SQL_CUR and does not exceed 18 characters in length.</p>
<p>
All cursor names within the connection must be unique. The maximum length of a cursor name is defined by the driver. For maximum interoperability, it is recommended that applications limit cursor names to no more than 18 characters. In ODBC 3.<i>x</i>, if a cursor name is a quoted identifier, it is treated in a case-sensitive manner, and it can contain characters that the syntax of SQL would not permit or would treat specially, such as blanks or reserved keywords. If a cursor name must be treated in a case-sensitive manner, it must be passed as a quoted identifier.</p>
<p>
A cursor name that is set either explicitly or implicitly remains set until the statement with which it is associated is dropped, using <b>SQLFreeHandle</b>. <b>SQLSetCursorName</b> can be called to rename a cursor on a statement as long as the cursor is in an allocated or prepared state.</p>
<p class=label>
<b>Code Example</b></p>
<p>
In the following example, an application uses <b>SQLSetCursorName</b> to set a cursor name for a statement. It then uses that statement to retrieve results from the CUSTOMERS table. Finally, it performs a positioned update to change the phone number of John Smith. Note that the application uses different statement handles for the <b>SELECT</b> and <b>UPDATE</b> statements.</p>
<p>
For another code example, see <a href="odch21kpr_2rsj.htm">SQLSetPos</a>.</p>
<pre><code>#define NAME_LEN 50
#define PHONE_LEN 10

SQLHSTMT hstmtSelect,
SQLHSTMT hstmtUpdate;
SQLRETURN&nbsp; retcode;
SQLHDBC&nbsp; hdbc;
SQLCHAR&nbsp; szName[NAME_LEN], szPhone[PHONE_LEN];
SQLINTEGER cbName, cbPhone;

/* Allocate the statements and set the cursor name. */

SQLAllocHandle(SQL_HANDLE_STMT, hdbc, &amp;hstmtSelect);
SQLAllocHandle(SQL_HANDLE_STMT, hdbc, &amp;hstmtUpdate);
SQLSetCursorName(hstmtSelect, "C1", SQL_NTS);

/* SELECT the result set and bind its columns to local buffers. */

SQLExecDirect(hstmtSelect,
 &nbsp;&nbsp;&nbsp;&nbsp; "SELECT NAME, PHONE FROM CUSTOMERS",
 &nbsp;&nbsp;&nbsp;&nbsp; SQL_NTS);
SQLBindCol(hstmtSelect, 1, SQL_C_CHAR, szName, NAME_LEN, &amp;cbName);
SQLBindCol(hstmtSelect, 2, SQL_C_CHAR, szPhone, PHONE_LEN, &amp;cbPhone);

/* Read through the result set until the cursor is&nbsp; */
/* positioned on the row for John Smith. */

do
 retcode = SQLFetch(hstmtSelect);
while ((retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) &amp;&amp;
 &nbsp; (strcmp(szName, "Smith, John") != 0));

/* Perform a positioned update of John Smith's name. */

if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) {
   SQLExecDirect(hstmtUpdate,
  "UPDATE EMPLOYEE SET PHONE=\"2064890154\" WHERE CURRENT OF C1",
  SQL_NTS);
}
</code></pre>
<p class=label>
<b>Related Functions</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=48%><b>For information about</b></td>
<td class=label width=52%><b>See</b></td>
</tr>
<tr valign=top>
<td width=48%>Executing an SQL statement</td>
<td width=52%><a href="odch21epr_35x0.htm">SQLExecDirect</a></td>
</tr>
<tr valign=top>
<td width=48%>Executing a prepared SQL statement</td>
<td width=52%><a href="odch21epr_0yg5.htm">SQLExecute</a></td>
</tr>
<tr valign=top>
<td width=48%>Returning a cursor name</td>
<td width=52%><a href="odch21fpr_7f39.htm">SQLGetCursorName</a></td>
</tr>
<tr valign=top>
<td width=48%>Setting cursor scrolling options</td>
<td width=52%><a href="odch21kpr_7t2r.htm">SQLSetScrollOptions</a></td>
</tr>
</table><br>
</font></BODY>
</HTML>
