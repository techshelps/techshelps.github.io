<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Date, Time, and Timestamp Literals</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h2><a name="odbcdate__time__and_timestamp_literals"></a>Date, Time, and Timestamp Literals</h2>
<p>
The escape sequence for date, time, and timestamp literals is:</p>
<p>
<b>{</b><i>literal-type</i><b> '</b><i>value</i><b>'}</b></p>
<p>
where <i>literal-type</i> is one of the following:</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=17%><b><i>literal-<br>
type</i></b></td>
<td class=label width=34%><b>Meaning</b></td>
<td class=label width=49%><b>Format of <i>value</i></b></td>
</tr>
<tr valign=top>
<td width=17%><b>d</b></td>
<td width=34%>Date</td>
<td width=49%><i>yyyy</i>-<i>mm</i>-<i>dd</i></td>
</tr>
<tr valign=top>
<td width=17%><b>t</b></td>
<td width=34%>Time</td>
<td width=49%><i>hh</i>:<i>mm</i>:<i>ss</i> [1]</td>
</tr>
<tr valign=top>
<td width=17%><b>ts</b></td>
<td width=34%>Timestamp</td>
<td width=49%><i>yyyy</i>-<i>mm</i>-<i>dd</i> <i>hh</i>:<i>mm</i>:<i>ss</i>[.<i>f...</i>] [1]</td>
</tr>
</table><br>
<p class=mini>
[1]&nbsp; The number of digits to the right of the decimal point in a time or timestamp interval literal containing a seconds component is dependent upon the seconds precision, as contained in the SQL_DESC_PRECISION descriptor field (for more information, see <a href="odch21jpr_7e90.htm">SQLSetDescField</a>).</p>
<p>
For more information about the date, time, and timestamp escape sequences, see “<a href="odappcpr_4gfn.htm">Date, Time, and Timestamp Escape Sequences</a>” in Appendix C, “SQL Grammar.”</p>
<p>
For example, both of the following SQL statements update the open date of sales order 1023 in the Orders table. The first statement uses the escape sequence syntax. The second statement uses the native syntax for a DATE column in the Rdb from Digital Equipment Corporation; this statement is not interoperable.</p>
<pre><code>UPDATE Orders SET OpenDate={d '1995-01-15'} WHERE OrderID=1023

UPDATE Orders SET OpenDate='15-Jan-1995' WHERE OrderID=1023
</code></pre>
<p>
The escape sequence for a date, time, or timestamp literal also can be placed in a character variable bound to a date, time, or timestamp parameter. For example, the following code uses a date parameter bound to a character variable to update the open date of sales order 1023 in the Orders table:</p>
<pre><code>SQLCHAR&nbsp; OpenDate[56]; // The size of a date literal is 55.
SQLINTEGER OpenDateLenOrInd = SQL_NTS;

// Bind the parameter.
SQLBindParameter(hstmt, 1, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_TYPE_DATE, 0, 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OpenDate, sizeof(OpenDate), &amp;OpenDateLenOrInd);

// Place the date in the OpenDate variable. In addition to the escape sequence shown,
// it would also be possible to use either of the strings "{d '1995-01-15'}" and
// "15-Jan-1995", although the latter is data source-specific.
strcpy(OpenDate, "{d '1995-01-15'}");

// Execute the statement.
SQLExecDirect(hstmt, "UPDATE Orders SET OpenDate=? WHERE OrderID = 1023", SQL_NTS);
</code></pre>
<p>
However, it is usually more efficient to bind the parameter directly to a date structure:</p>
<pre><code>SQL_DATE_STRUCT OpenDate;
SQLINTEGER&nbsp; OpenDateInd = 0;

// Bind the parameter.
SQLBindParameter(hstmt, 1, SQL_PARAM_INPUT, SQL_C_TYPE_DATE, SQL_TYPE_DATE, 0, 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;OpenDate, 0, &amp;OpenDateLen);

// Place the date in the dsOpenDate structure.
OpenDate.year = 1995;
OpenDate.month = 1;
OpenDate.day = 15;

// Execute the statement.
SQLExecDirect(hstmt, "UPDATE Employee SET OpenDate=? WHERE OrderID = 1023", SQL_NTS);
</code></pre>
<p>
To determine if a driver supports the ODBC escape sequences for date, time, or timestamp literals, an application calls <b>SQLGetTypeInfo</b>. If the data source supports a date, time, or timestamp data type, it must also support the corresponding escape sequence.</p>
<p>
Data sources can also support the datetime literals defined in the ANSI SQL92 specification, which are different from the ODBC escape sequences for date, time, or timestamp literals. To determine if a data source supports the ANSI literals, an application calls <b>SQLGetInfo</b> with the SQL_ANSI_SQL_DATETIME_LITERALS option.</p>
<p>
To determine if a driver supports the ODBC escape sequences for interval literals, an application calls <b>SQLGetTypeInfo</b>. If the data source supports a datetime interval data type, it must also support the corresponding escape sequence.</p>
<p>
Data sources can also support the datetime literals defined in the ANSI SQL92 specification, which are different from the ODBC escape sequences for datetime interval literals. To determine if a data source supports the ANSI literals, an application calls <b>SQLGetInfo</b> with the SQL_ANSI_SQL_DATETIME_LITERALS option.</p>
</font></BODY>
</HTML>
