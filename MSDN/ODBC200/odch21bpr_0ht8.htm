<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SQLBindCol</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="odbcsqlbindcol"></a>SQLBindCol</h1>
<p class=label>
<b>Conformance</b></p>
<p>
Version Introduced:ODBC 1.0<br>
Standards Compliance:ISO 92</p>
<p class=label>
<b>Summary</b></p>
<p>
<b>SQLBindCol</b> binds application data buffers to columns in the result set.</p>
<p class=label>
<b>Syntax</b></p>
<p>
SQLRETURN <b>SQLBindCol</b>(<br>
SQLHSTMT<i>StatementHandle</i>,<br>
SQLUSMALLINT<i>ColumnNumber</i>,<br>
SQLSMALLINT<i>TargetType</i>,<br>
SQLPOINTER<i>TargetValuePtr</i>,<br>
SQLINTEGER<i>BufferLength</i>,<br>
SQLINTEGER *<i>StrLen_or_IndPtr</i>);</p>
<p class=label>
<b>Arguments</b></p>
<p class=dt>
<i>StatementHandle</i></p>
<p class=indent>
[Input]<br>
Statement handle.</p>
<p class=dt>
<i>ColumnNumber</i></p>
<p class=indent>
[Input]<br>
Number of the result set column to bind. Columns are numbered in increasing column order starting at 0, where column 0 is the bookmark column. If bookmarks are not used — that is, the SQL_ATTR_USE_BOOKMARKS statement attribute is set to SQL_UB_OFF — then column numbers start at 1.</p>
<p class=dt>
<i>TargetType</i></p>
<p class=indent>
[Input]<br>
The identifier of the C data type of the *<i>TargetValuePtr</i> buffer. When retrieving data from the data source with <b>SQLFetch</b>, <b>SQLFetchScroll</b>, <b>SQLBulkOperations</b>, or <b>SQLSetPos</b>, the driver converts the data to this type; when sending data to the data source with <b>SQLBulkOperations</b> or <b>SQLSetPos</b>, the driver converts the data from this type. For a list of valid C data types and type identifiers, see the “<a href="odappdpr_40j7.htm">C Data Types</a>” section in Appendix D, “Data Types.” </p>
<p class=tl>
If the <i>TargetType</i> argument is an interval data type, the default interval leading precision (2) and the default interval seconds precision (6), as set in the SQL_DESC_DATETIME_INTERVAL_PRECISION and SQL_DESC_PRECISION fields of the ARD, respectively, are used for the data. If the <i>TargetType</i> argument is SQL_C_NUMERIC, the default precision (driver-defined) and default scale (0), as set in the SQL_DESC_PRECISION and SQL_DESC_SCALE fields of the ARD, are used for the data. If any default precision or scale is not appropriate, the application should explicitly set the appropriate descriptor field by a call to <b>SQLSetDescField</b> or <b>SQLSetDescRec</b>.</P><p class=dt>
<i>TargetValuePtr</i></p>
<p class=indent>
[Deferred Input/Output]<br>
Pointer to the data buffer to bind to the column. <b>SQLFetch</b> and <b>SQLFetchScroll</b> return data in this buffer. <b>SQLBulkOperations</b> returns data in this buffer when <i>Operation</i> is SQL_FETCH_BY_BOOKMARK; it retrieves data from this buffer when <i>Operation</i> is SQL_ADD or SQL_UPDATE_BY_BOOKMARK. <b>SQLSetPos</b> returns data in this buffer when <i>Operation</i> is SQL_REFRESH; it retrieves data from this buffer when <i>Operation</i> is SQL_UPDATE.</p>
<p class=tl>
If <i>TargetValuePtr</i> is a null pointer, the driver unbinds the data buffer for the column. An application can unbind all columns by calling <b>SQLFreeStmt</b> with the SQL_UNBIND option. An application can unbind the data buffer for a column, but still have a length/indicator buffer bound for the column, if the <i>TargetValuePtr</i> argument in the call to <b>SQLBindCol</b> is a null pointer, but the <i>StrLen_or_IndPtr</i> argument is a valid value.</P><p class=dt>
<i>BufferLength</i></p>
<p class=indent>
[Input]<br>
Length of the *<i>TargetValuePtr</i> buffer in bytes.</p>
<p class=tl>
The driver uses <i>BufferLength</i> to avoid writing past the end of the *<i>TargetValuePtr</i> buffer when returning variable-length data, such as character or binary data. Note that the driver counts the null-termination character when returning character data to *<i>TargetValuePtr</i>. *<i>TargetValuePtr</i> must therefore contain space for the null-termination character or the driver will truncate the data.</P><p class=tl>
When the driver returns fixed-length data, such as an integer or a date structure, the driver ignores <i>BufferLength</i> and assumes the buffer is large enough to hold the data. It is therefore important for the application to allocate a large enough buffer for fixed-length data or the driver will write past the end of the buffer.</P><p class=tl>
<b>SQLBindCol</b> returns SQLSTATE HY090 (Invalid string or buffer length) when <i>BufferLength</i> is less than 0 but not when <i>BufferLength</i> is 0. However, if <i>TargetType</i> specifies a character type, an application should not set <i>BufferLength</i> to 0, because ISO CLI&nbsp;–&nbsp;compliant drivers return SQLSTATE HY090 (Invalid string or buffer length) in that case.</P><p class=dt>
<i>StrLen_or_IndPtr</i></p>
<p class=indent>
[Deferred Input/Output]<br>
Pointer to the length/indicator buffer to bind to the column. <b>SQLFetch </b>and <b>SQLFetchScroll</b> return a value in this buffer. <b>SQLBulkOperations</b> retrieves a value from this buffer when <i>Operation</i> is SQL_ADD, SQL_UPDATE_BY_BOOKMARK, or SQL_DELETE_BY_BOOKMARK. <b>SQLBulkOperations</b> returns a value in this buffer when <i>Operation</i> is SQL_FETCH_BY_BOOKMARK. <b>SQLSetPos</b> returns a value in this buffer when <i>Operation</i> is SQL_REFRESH; it retrieves a value from this buffer when <i>Operation</i> is SQL_UPDATE.<b> </b></p>
<p class=tl>
<b>SQLFetch</b>, <b>SQLFetchScroll</b>, <b>SQLBulkOperations</b>, and <b>SQLSetPos</b> can return the following values in the length/indicator buffer:</P><ul type=disc>
<li>
The length of the data available to return<br><br></li>
<li>
SQL_NO_TOTAL<br><br></li>
<li>
SQL_NULL_DATA<p class=tl>
The application can place the following values in the length/indicator buffer for use with <b>SQLBulkOperations </b>or<b> SQLSetPos</b>:</P></li>
<li>
The length of the data being sent<br><br></li>
<li>
SQL_NTS<br><br></li>
<li>
SQL_NULL_DATA<br><br></li>
<li>
SQL_DATA_AT_EXEC<br><br></li>
<li>
The result of the SQL_LEN_DATA_AT_EXEC macro<br><br></li>
<li>
SQL_COLUMN_IGNORE<p class=tl>
If the indicator buffer and the length buffer are separate buffers, the indicator buffer can return only SQL_NULL_DATA, while the length buffer can return all other values.</P><p class=tl>
For more information, see <a href="odch21bpr_9er7.htm">SQLBulkOperations</a>, <a href="odch21epr_4zoo.htm">SQLFetch</a>, <a href="odch21kpr_2rsj.htm">SQLSetPos</a>, and the “<a href="odch04pr_7z5f.htm">Using Length/Indicator Values</a>” section in Chapter 4, “ODBC Fundamentals.”</P><p class=tl>
If <i>StrLen_or_IndPtr</i> is a null pointer, no length or indicator value is used. This is an error when fetching data and the data is NULL.</P></li>
</ul>
<p class=label>
<b>Returns</b></p>
<p>
SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_ERROR, or SQL_INVALID_HANDLE.</p>
<p class=label>
<b>Diagnostics</b></p>
<p>
When <b>SQLBindCol</b> returns SQL_ERROR or SQL_SUCCESS_WITH_INFO, an associated SQLSTATE value may be obtained by calling <b>SQLGetDiagRec</b> with a <i>HandleType</i> of SQL_HANDLE_STMT and a <i>Handle</i> of <i>StatementHandle</i>. The following table lists the SQLSTATE values commonly returned by <b>SQLBindCol </b>and explains each one in the context of this function; the notation “(DM)” precedes the descriptions of SQLSTATEs returned by the Driver Manager. The return code associated with each SQLSTATE value is SQL_ERROR, unless noted otherwise.</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows width=595>
<tr valign=top>
<td class=label width=22%><b>SQLSTATE</b></td>
<td class=label width=26%><b>Error</b></td>
<td class=label width=52%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=22%>01000</td>
<td width=26%>General warning</td>
<td width=52%>Driver-specific informational message. (Function returns SQL_SUCCESS_WITH_INFO.)</td>
</tr>
<tr valign=top>
<td width=22%>07006</td>
<td width=26%>Restricted data type attribute violation</td>
<td width=52%>(DM) The <i>ColumnNumber</i> argument was 0, and the <i>TargetType</i> argument was not SQL_C_BOOKMARK or SQL_C_VARBOOKMARK.</td>
</tr>
<tr valign=top>
<td width=22%>07009</td>
<td width=26%>Invalid descriptor index</td>
<td width=52%>The value specified for the argument <i>ColumnNumber</i> exceeded the maximum number of columns in the result set.</td>
</tr>
<tr valign=top>
<td width=22%>HY000</td>
<td width=26%>General error</td>
<td width=52%>An error occurred for which there was no specific SQLSTATE and for which no implementation-specific SQLSTATE was defined. The error message returned by <b>SQLGetDiagRec</b> in the <i>*MessageText</i> buffer describes the error and its cause.</td>
</tr>
<tr valign=top>
<td width=22%>HY001</td>
<td width=26%>Memory allocation <br>
error</td>
<td width=52%>The driver was unable to allocate memory required to support execution or completion of the function.</td>
</tr>
<tr valign=top>
<td width=22%>HY003</td>
<td width=26%>Invalid application buffer type</td>
<td width=52%>The argument <i>TargetType</i> was neither a valid data type nor SQL_C_DEFAULT.</td>
</tr>
<tr valign=top>
<td width=22%>HY010</td>
<td width=26%>Function sequence error</td>
<td width=52%>(DM) An asynchronously executing function was called for the <i>StatementHandle</i> and was still executing when this function was called.<p>
(DM) <b>SQLExecute</b>, <b>SQLExecDirect</b>, <b>SQLBulkOperations</b>, or <b>SQLSetPos</b> was called for the <i>StatementHandle</i> and returned SQL_NEED_DATA. This function was called before data was sent for all data-at-execution parameters or columns.</p>
</td>
</tr>
<tr valign=top>
<td width=22%>HY013</td>
<td width=26%>Memory management error</td>
<td width=52%>The function call could not be processed because the underlying memory objects could not be accessed, possibly because of low memory conditions.</td>
</tr>
<tr valign=top>
<td width=22%>HY090</td>
<td width=26%>Invalid string or buffer length</td>
<td width=52%>(DM) The value specified for the argument <i>BufferLength</i> was less than 0.<p>
(DM) The driver was an ODBC 2<i>.x</i> driver, the <i>ColumnNumber</i> argument was set to 0, and the value specified for the argument <i>BufferLength</i> was not equal to 4.</p>
</td>
</tr>
<tr valign=top>
<td width=22%>HYC00</td>
<td width=26%>Optional feature not implemented</td>
<td width=52%>The driver or data source does not support the conversion specified by the combination of the <i>TargetType</i> argument and the driver-specific SQL data type of the corresponding column.<p>
The argument <i>ColumnNumber</i> was 0 and the driver does not support bookmarks.</p>
<p>
The driver supports only ODBC 2.<i>x</i> and the argument <i>TargetType</i> was one of the following:</p>
<p>
SQL_C_NUMERIC<br>
SQL_C_SBIGINT<br>
SQL_C_UBIGINT</p>
<p>
and any of the interval C data types listed in “<a href="odappdpr_40j7.htm">C Data Types</a>” in Appendix D, “Data Types.”</p>
</td>
</tr>
<tr valign=top>
<td width=22%>HYT01</td>
<td width=26%>Connection timeout expired</td>
<td width=52%>The connection timeout period expired before the data source responded to the request. The connection timeout period is set through <b>SQLSetConnectAttr</b>, SQL_ATTR_CONNECTION_TIMEOUT.</td>
</tr>
<tr valign=top>
<td width=22%>IM001</td>
<td width=26%>Driver does not support this function</td>
<td width=52%>(DM) The driver associated with the <i>StatementHandle</i> does not support the function.</td>
</tr>
</table><br>
<p class=label>
<b>Comments</b></p>
<p>
<b>SQLBindCol</b> is used to associate, or <i>bind</i>, columns in the result set to data buffers and length/indicator buffers in the application. When the application calls <b>SQLFetch</b>, <b>SQLFetchScroll</b>, or <b>SQLSetPos</b> to fetch data, the driver returns the data for the bound columns in the specified buffers; for more information, see <a href="odch21epr_4zoo.htm">SQLFetch</a>. When the application calls <b>SQLBulkOperations</b> to update or insert a row or <b>SQLSetPos</b> to update a row, the driver retrieves the data for the bound columns from the specified buffers; for more information, see <a href="odch21bpr_9er7.htm">SQLBulkOperations</a> or <a href="odch21kpr_2rsj.htm">SQLSetPos</a>. For more information about binding, see “<a href="odch10pr_9iu7.htm">Overview</a>” in Chapter 10, “Retrieving Results (Basic).”</p>
<p>
Note that columns do not have to be bound to retrieve data from them. An application can also call <b>SQLGetData</b> to retrieve data from columns. Although it is possible to bind some columns in a row and call <b>SQLGetData</b> for others, this is subject to some restrictions. For more information, see <a href="odch21gpr_682p.htm">SQLGetData</a>.</p>
<h1>Binding, Unbinding, and Rebinding Columns</h1>
<p>
A column can be bound, unbound, or rebound at any time, even after data has been fetched from the result set. The new binding takes effect the next time a function that uses bindings is called. For example, suppose an application binds the columns in a result set and calls <b>SQLFetch</b>. The driver returns the data in the bound buffers. Now suppose the application binds the columns to a different set of buffers. The driver does not place the data for the just-fetched row in the newly bound buffers. Instead, it waits until <b>SQLFetch</b> is called again and then places the data for the next row in the newly bound buffers.</p>
<p class=indent>
<B><b>Note&nbsp;&nbsp;&nbsp;</b></B>The statement attribute SQL_ATTR_USE_BOOKMARKS should always be set before binding a column to column 0. This is not required, but is strongly recommended.</p>
<h1>Binding Columns</h1>
<p>
To bind a column, an application calls <b>SQLBindCol</b> and passes the column number, type, address, and length of a data buffer, and the address of a length/indicator buffer. For information about how these addresses are used, see “Buffer Addresses,” later in this section. For more information about binding columns, see “<a href="odch10pr_59nw.htm">Using SQLBindCol</a>” in Chapter 10, “Retrieving Results (Basic).”</p>
<p>
The use of these buffers is deferred; that is, the application binds them in <b>SQLBindCol</b> but the driver accesses them from other functions — namely <b>SQLBulkOperations</b>, <b>SQLFetch</b>, <b>SQLFetchScroll</b>, or <b>SQLSetPos</b>. It is the application’s responsibility to make sure that the pointers specified in <b>SQLBindCol</b> remain valid as long as the binding remains in effect. If the application allows these pointers to become invalid — for example, it frees a buffer — and then calls a function that expects them to be valid, the consequences are undefined. For more information, see “<a href="odch04pr_4y9f.htm">Deferred Buffers</a>” in Chapter 4, “ODBC Fundamentals.”</p>
<p>
The binding remains in effect until it is replaced by a new binding, the column is unbound, or the statement is freed.</p>
<h1>Unbinding Columns</h1>
<p>
To unbind a single column, an application calls <b>SQLBindCol</b> with <i>ColumnNumber</i> set to the number of that column and <i>TargetValuePtr</i> set to a null pointer. If <i>ColumnNumber</i> refers to an unbound column, <b>SQLBindCol</b> still returns SQL_SUCCESS.</p>
<p>
To unbind all columns, an application calls <b>SQLFreeStmt</b> with <i>fOption</i> set to SQL_UNBIND. This also can be accomplished by setting the SQL_DESC_COUNT field of the ARD to zero.</p>
<h1>Rebinding Columns</h1>
<p>
An application can perform either of two operations to change a binding:
<ul type=disc>
<li>
Call <b>SQLBindCol</b> to specify a new binding for a column that is already bound. The driver overwrites the old binding with the new one.<br><br></li>
<li>
Specify an offset to be added to the buffer address that was specified by the binding call to <b>SQLBindCol</b>. For more information, see the next section, “Binding Offsets.”</li>
</ul>
<h1>Binding Offsets</h1>
<p>
A binding offset is a value that is added to the addresses of the data and length/indicator buffers (as specified in the <i>TargetValuePtr</i> and <i>StrLen_or_IndPtr </i>arguments) before they are dereferenced. When offsets are used, the bindings are a “template” of how the application’s buffers are laid out and the application can move this “template” to different areas of memory by changing the offset. Because the same offset is added to each address in each binding, the relative offsets between buffers for different columns must be the same within each set of buffers. This is always true when row-wise binding is used; the application must carefully lay out its buffers for this to be true when column-wise binding is used.</p>
<p>
Using a binding offset has much the same effect as rebinding a column by calling <b>SQLBindCol</b>. The difference is that a new call to <b>SQLBindCol</b> specifies new addresses for the data buffer and length/indicator buffer, while use of a binding offset does not change the addresses, but merely adds an offset to them. The application can specify a new offset whenever it wants, and this offset is always added to the originally bound addresses. In particular, if the offset is set to 0 or if the statement attribute is set to a null pointer, the driver uses the originally bound addresses.</p>
<p>
To specify a binding offset, the application sets the SQL_ATTR_ROW_BIND_OFFSET_PTR statement attribute to the address of an SQLINTEGER buffer. Before the application calls a function that uses bindings, it places an offset in bytes in this buffer. To determine the address of the buffer to use, the driver adds the offset to the address in the binding. Note that the sum of the address and the offset must be a valid address, but that the address to which the offset is added need not be valid. For more information about how binding offsets are used, see “Buffer Addresses,” later in this section.</p>
<h1>Binding Arrays</h1>
<p>
If the rowset size (the value of the SQL_ATTR_ROW_ARRAY_SIZE statement attribute) is greater than 1, the application binds arrays of buffers rather than single buffers. For more information, see “<a href="odch11pr_2x6b.htm">Block Cursors</a>” in Chapter 11, “Retrieving Results (Advanced).”</p>
<p>
The application can bind arrays in two ways:
<ul type=disc>
<li>
Bind an array to each column. This is called <i>column-wise binding</i> because each data structure (array) contains data for a single column.<br><br></li>
<li>
Define a structure to hold the data for an entire row and bind an array of these structures. This is called <i>row-wise binding</i> because each data structure contains the data for a single row.</li>
</ul>
<p>
Each array of buffers must have at least as many elements as the size of the rowset.</p>
<p class=indent>
<B><b>Note&nbsp;&nbsp;&nbsp;</b></B>An application must verify that alignment is valid. For more information about alignment considerations, see “<a href="odch17pr_46b8.htm">Alignment</a>” in Chapter 17, “Programming Considerations.”</p>
<h1>Column-Wise Binding</h1>
<p>
In column-wise binding, the application binds separate data and length/indicator arrays to each column.</p>
<p>
To use column-wise binding, the application first sets the SQL_ATTR_ROW_BIND_TYPE statement attribute to SQL_BIND_BY_COLUMN (this is the default). For each column to be bound, the application performs the following steps:
<ol>
<li>
Allocates a data buffer array.<br><br></li>
<li>
Allocates an array of length/indicator buffers.<p class=atl>
<B><b>Note</b></B> If the application writes directly to descriptors when column-wise binding is used, then separate arrays can be used for length and indicator data.</p></li>
<li>
Calls <b>SQLBindCol</b> with the following arguments:<ul type=disc>
<li>
<i>TargetType</i> is the type of a single element in the data buffer array.<br><br></li>
<li>
<i>TargetValuePtr</i> is the address of the data buffer array.<br><br></li>
<li>
<i>BufferLength</i> is the size of a single element in the data buffer array. The <i>BufferLength</i> argument is ignored when the data is fixed-length data.<br><br></li>
<li>
<i>StrLen_or_IndPtr</i> is the address of the length/indicator array.</li>
</ul>
</li>
</ol>
<p>
For more information about how this information is used, see “Buffer Addresses,” later in this section. For more information about column-wise binding, see “<a href="odch11pr_6dbb.htm">Column-Wise Binding</a>” in Chapter 11, “Retrieving Results (Advanced).”</p>
<h1>Row-Wise Binding</h1>
<p>
In row-wise binding, the application defines a structure containing data and length/indicator buffers for each column to be bound.</p>
<p>
To use row-wise binding, the application performs the following steps:
<ol>
<li>
Defines a structure to hold a single row of data (including both data and length/indicator buffers) and allocates an array of these structures.<p class=atl>
<B><b>Note&nbsp;&nbsp;&nbsp;</b></B>If the application writes directly to descriptors when row-wise binding is used, then separate fields can be used for length and indicator data.</p></li>
<li>
Sets the SQL_ATTR_ROW_BIND_TYPE statement attribute to the size of the structure containing a single row of data, or to the size of an instance of a buffer into which the results columns will be bound. The length must include space for all of the bound columns, and any padding of the structure or buffer to make sure that when the address of a bound column is incremented with the specified length, the result will point to the beginning of the same column in the next row. When using the <i>sizeof</i> operator in ANSI C, this behavior is guaranteed.<br><br></li>
<li>
Calls <b>SQLBindCol</b> with the following arguments for each column to be bound:<ul type=disc>
<li>
<i>TargetType</i> is the type of the data buffer member to be bound to the column.<br><br></li>
<li>
<i>TargetValuePtr</i> is the address of the data buffer member in the first array element.<br><br></li>
<li>
<i>BufferLength</i> is the size of the data buffer member.<br><br></li>
<li>
<i>StrLen_or_IndPtr</i> is the address of the length/indicator member to be bound.</li>
</ul>
</li>
</ol>
<p>
For more information about how this information is used, see “Buffer Addresses,” later in this section. For more information about column-wise binding, see “<a href="odch11pr_2uw7.htm">Row-Wise Binding</a>” in Chapter 11, “Retrieving Results (Advanced).”</p>
<h1>Buffer Addresses</h1>
<p>
The <i>buffer address</i> is the actual address of the data or length/indicator buffer. The driver calculates the buffer address just prior to writing to the buffers (such as during fetch time). It is calculated from the following formula, which uses the addresses specified in the <i>TargetValuePtr</i> and <i>StrLen_or_IndPtr</i> arguments, the binding offset, and the row number:</p>
<p>
<i>Bound Address</i> + <i>Binding Offset</i> + ((<i>Row Number</i> – 1) x <i>Element Size</i>)</p>
<p>
where:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=595>
<tr valign=top>
<td class=label width=18%><b>Variable</b></td>
<td class=label width=82%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=18%><i>Bound Address</i></td>
<td width=82%>For data buffers, the address specified with the <i>TargetValuePtr</i> argument in <b>SQLBindCol</b>.<p>
For length/indicator buffers, the address specified with the <i>StrLen_or_IndPtr</i> argument in <b>SQLBindCol</b>. For more information, see “Additional Comments” in the “Descriptors and SQLBindCol” section.</p>
<p>
If the bound address is 0, no data value is returned, even if the address as calculated by the previous formula is non-zero.</p>
</td>
</tr>
<tr valign=top>
<td width=18%><i>Binding Offset</i></td>
<td width=82%>If row-wise binding is used, the value stored at the address specified with the SQL_ATTR_ROW_BIND_OFFSET_PTR statement attribute.<p>
If column-wise binding is used or if the value of the SQL_ATTR_ROW_BIND_OFFSET_PTR statement attribute is a null pointer, <i>Binding Offset</i> is 0.</p>
</td>
</tr>
<tr valign=top>
<td width=18%><i>Row Number</i></td>
<td width=82%>The 1-based number of the row in the rowset. For single-row fetches, which are the default, this is 1.</td>
</tr>
<tr valign=top>
<td width=18%><i>Element Size</i></td>
<td width=82%>The size of an element in the bound array.<p>
If column-wise binding is used, this is <b>sizeof(SQLINTEGER)</b> for length/indicator buffers. For data buffers, it is the value of the <i>BufferLength</i> argument in <b>SQLBindCol</b> if the data type is variable length, and the size of the data type if the data type is fixed length.</p>
<p>
If row-wise binding is used, this is the value of the SQL_ATTR_ROW_BIND_TYPE statement attribute for both data and length/indicator buffers.</p>
</td>
</tr>
</table><br>
<h1>Descriptors and SQLBindCol</h1>
<p>
The following sections describe how <b>SQLBindCol</b> interacts with descriptors.</p>
<p class=indent>
<B><b>Caution</b></B> Calling <b>SQLBindCol</b> for one statement can affect other statements. This occurs when the ARD associated with the statement is explicitly allocated and is also associated with other statements. Because <b>SQLBindCol</b> modifies the descriptor, the modifications apply to all statements with which this descriptor is associated. If this is not the required behavior, the application should dissociate this descriptor from the other statements before calling <b>SQLBindCol</b>.</p>
<h1><B>Argument Mappings</B></h1>
<p>
Conceptually, <b>SQLBindCol</b> performs the following steps in sequence:
<ol>
<li>
Calls <b>SQLGetStmtAttr</b> to obtain the ARD handle.<br><br></li>
<li>
Calls <b>SQLGetDescField</b> to get this descriptor’s SQL_DESC_COUNT field, and if the value in the <i>ColumnNumber</i> argument exceeds the value of SQL_DESC_COUNT, calls <b>SQLSetDescField</b> to increase the value of SQL_DESC_COUNT to <i>ColumnNumber</i>.<br><br></li>
<li>
Calls <b>SQLSetDescField</b> multiple times to assign values to the following fields of the ARD:<ul type=disc>
<li>
Sets SQL_DESC_TYPE and SQL_DESC_CONCISE_TYPE to the value of <i>TargetType</i>, except that if <i>TargetType</i> is one of the concise identifiers of a datetime or interval subtype, it sets SQL_DESC_TYPE to SQL_DATETIME or SQL_INTERVAL, respectively, sets SQL_DESC_CONCISE_TYPE to the concise identifier, and sets SQL_DESC_DATETIME_INTERVAL_CODE to the corresponding datetime or interval subcode.<br><br></li>
<li>
Sets one or more of SQL_DESC_LENGTH, SQL_DESC_PRECISION, SQL_DESC_SCALE, and SQL_DESC_DATETIME_INTERVAL_PRECISION, as appropriate for <i>TargetType</i>.<br><br></li>
<li>
Sets the SQL_DESC_OCTET_LENGTH field to the value of <i>BufferLength</i>.<br><br></li>
<li>
Sets the SQL_DESC_DATA_PTR field to the value of <i>TargetValue</i>.<br><br></li>
<li>
Sets the SQL_DESC_INDICATOR_PTR field to the value of <i>StrLen_or_Ind</i> (see the following paragraph).<br><br></li>
<li>
Sets the SQL_DESC_OCTET_LENGTH_PTR field to the value of <i>StrLen_or_Ind</i> (see the following paragraph).</li>
</ul>
</li>
</ol>
<p>
The variable that the <i>StrLen_or_Ind</i> argument refers to is used for both indicator and length information. If a fetch encounters a null value for the column, it stores SQL_NULL_DATA in this variable; otherwise, it stores the data length in this variable. Passing a null pointer as <i>StrLen_or_Ind</i> keeps the fetch operation from returning the data length, but makes the fetch fail if it encounters a null value and has no way to return SQL_NULL_DATA.</p>
<p>
If the call to <b>SQLBindCol</b> fails, the content of the descriptor fields it would have set in the ARD are undefined, and the value of the SQL_DESC_COUNT field of the ARD is unchanged.</p>
<h1>Implicit Resetting of COUNT Field</h1>
<p>
<b>SQLBindCol</b> sets SQL_DESC_COUNT to the value of the <i>ColumnNumber</i> argument only when this would increase the value of SQL_DESC_COUNT. If the value in the <i>TargetValuePtr</i> argument is a null pointer and the value in the <i>ColumnNumber</i> argument is equal to SQL_DESC_COUNT (that is, when unbinding the highest bound column), then SQL_DESC_COUNT is set to the number of the highest remaining bound column.</p>
<h1>Cautions Regarding SQL_DEFAULT</h1>
<p>
To retrieve column data successfully, the application must determine correctly the length and starting point of the data in the application buffer. When the application specifies an explicit <i>TargetType</i>, application misconceptions are readily detected. However, when the application specifies a <i>TargetType</i> of SQL_DEFAULT, <b>SQLBindCol</b> can be applied to a column of a different data type from the one intended by the application, either from changes to the metadata or by applying the code to a different column. In this case, the application may fail to determine the start or length of the fetched column data. This can lead to unreported data errors or memory violations.</p>
<p class=label>
<b>Code Example</b></p>
<p>
In the following example, an application executes a <b>SELECT</b> statement on the Customers table to return a result set of the customer IDs, names, and phone numbers, sorted by name. It then calls <b>SQLBindCol</b> to bind the columns of data to local buffers. Finally, the application fetches each row of data with <b>SQLFetch</b> and prints each customer’s name, ID, and phone number.</p>
<p>
For more code examples, see <a href="odch21bpr_9er7.htm">SQLBulkOperations</a>, <a href="odch21cpr_8nsj.htm">SQLColumns</a>, <a href="odch21epr_5m24.htm">SQLFetchScroll</a>, and <a href="odch21kpr_2rsj.htm">SQLSetPos</a>.</p>
<pre><code>#define NAME_LEN 50
#define PHONE_LEN 10

SQLCHAR      szName[NAME_LEN], szPhone[PHONE_LEN];
SQLINTEGER   sCustID, cbName, cbCustID, cbPhone;
SQLHSTMT      hstmt;
SQLRETURN      retcode;

retcode = SQLExecDirect(hstmt,
            "SELECT CUSTID, NAME, PHONE FROM CUSTOMERS ORDER BY 2, 1, 3", 
            SQL_NTS);

if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) {

   /* Bind columns 1, 2, and 3 */

   SQLBindCol(hstmt, 1, SQL_C_ULONG, &amp;sCustID, 0, &amp;cbCustID);
   SQLBindCol(hstmt, 2, SQL_C_CHAR, szName, NAME_LEN, &amp;cbName);
   SQLBindCol(hstmt, 3, SQL_C_CHAR, szPhone, PHONE_LEN, &amp;cbPhone);

   /* Fetch and print each row of data.&nbsp; On */
   /* an error, display a message and exit. */

   while (TRUE) {
      retcode = SQLFetch(hstmt);
      if (retcode == SQL_ERROR || retcode == SQL_SUCCESS_WITH_INFO) {
         show_error();
      }
      if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO){
         fprintf(out, "%-*s %-5d %*s", NAME_LEN-1, szName,
          &nbsp;&nbsp; sCustID, PHONE_LEN-1, szPhone);
      } else {
         break;
      }
   }
}
</code></pre>
<p class=label>
<b>Related Functions</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=595>
<tr valign=top>
<td class=label width=47%><b>For information about</b></td>
<td class=label width=53%><b>See</b></td>
</tr>
<tr valign=top>
<td width=47%>Returning information about a column in a result set</td>
<td width=53%><a href="odch21dpr_92jw.htm">SQLDescribeCol</a></td>
</tr>
<tr valign=top>
<td width=47%>Fetching a block of data or scrolling through a result set</td>
<td width=53%><a href="odch21epr_5m24.htm">SQLFetchScroll</a></td>
</tr>
<tr valign=top>
<td width=47%>Fetching multiple rows of data</td>
<td width=53%><a href="odch21epr_4zoo.htm">SQLFetch</a></td>
</tr>
<tr valign=top>
<td width=47%>Releasing column buffers on the statement</td>
<td width=53%><a href="odch21fpr_84hg.htm">SQLFreeStmt</a></td>
</tr>
<tr valign=top>
<td width=47%>Fetching part or all of a column of data</td>
<td width=53%><a href="odch21gpr_682p.htm">SQLGetData</a></td>
</tr>
<tr valign=top>
<td width=47%>Returning the number of result set columns</td>
<td width=53%><a href="odch21ipr_74hf.htm">SQLNumResultCols</a></td>
</tr>
</table><br>
</font></BODY>
</HTML>
