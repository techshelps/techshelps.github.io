<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SQLCopyDesc</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="odbcsqlcopydesc"></a>SQLCopyDesc</h1>
<p class=label>
<b>Conformance</b></p>
<p>
Version Introduced:ODBC 3.0<br>
Standards Compliance:ISO 92</p>
<p class=label>
<b>Summary</b></p>
<p>
<b>SQLCopyDesc</b> copies descriptor information from one descriptor handle to another.</p>
<p class=label>
<b>Syntax</b></p>
<p>
SQLRETURN <b>SQLCopyDesc</b>(<br>
SQLHDESC<i>SourceDescHandle</i>,<br>
SQLHDESC<i>TargetDescHandle</i>);</p>
<p class=label>
<b>Arguments</b></p>
<p class=dt>
<i>SourceDescHandle</i></p>
<p class=indent>
[Input]<br>
Source descriptor handle.</p>
<p class=dt>
<i>TargetDescHandle</i></p>
<p class=indent>
[Input]<br>
Target descriptor handle. The <i>TargetDescHandle</i> argument can be a handle to an application descriptor or an IPD. <i>TargetDescHandle</i> cannot be set to a handle to an IRD, or<b> SQLCopyDesc</b> will return SQLSTATE HY016 (Cannot modify an implementation row descriptor).</p>
<p class=label>
<b>Returns</b></p>
<p>
SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_ERROR, or SQL_INVALID_HANDLE.</p>
<p class=label>
<b>Diagnostics</b></p>
<p>
When <b>SQLCopyDesc</b> returns SQL_ERROR or SQL_SUCCESS_WITH_INFO, an associated SQLSTATE value can be obtained by calling <b>SQLGetDiagRec</b> with a <i>HandleType</i> of SQL_HANDLE_DESC and a <i>Handle</i> of <i>TargetDescHandle</i>. If an invalid <i>SourceDescHandle</i> was passed in the call, SQL_INVALID_HANDLE will be returned, but no SQLSTATE will be returned. The following table lists the SQLSTATE values commonly returned by <b>SQLCopyDesc</b> and explains each one in the context of this function; the notation “(DM)” precedes the descriptions of SQLSTATEs returned by the Driver Manager. The return code associated with each SQLSTATE value is SQL_ERROR, unless noted otherwise.</p>
<p>
When an error is returned, the call to <b>SQLCopyDesc</b> is immediately aborted, and the contents of the fields in the <i>TargetDescHandle</i> descriptor are undefined.</p>
<p>
Because <b>SQLCopyDesc</b> may be implemented by calling <b>SQLGetDescField</b> and <b>SQLSetDescField</b>, <b>SQLCopyDesc</b> may return SQLSTATEs returned by <b>SQLGetDescField</b> or <b>SQLSetDescField</b>.</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=22%><b>SQLSTATE</b></td>
<td class=label width=26%><b>Error</b></td>
<td class=label width=52%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=22%>01000</td>
<td width=26%>General warning</td>
<td width=52%>Driver-specific informational message. (Function returns SQL_SUCCESS_WITH_INFO.)</td>
</tr>
<tr valign=top>
<td width=22%>08S01</td>
<td width=26%>Communication link failure</td>
<td width=52%>The communication link between the driver and the data source to which the driver was connected failed before the function completed processing.</td>
</tr>
<tr valign=top>
<td width=22%>HY000</td>
<td width=26%>General error</td>
<td width=52%>An error occurred for which there was no specific SQLSTATE and for which no implementation-specific SQLSTATE was defined. The error message returned by <b>SQLGetDiagRec</b> in the <i>*MessageText</i> buffer describes the error and its cause.</td>
</tr>
<tr valign=top>
<td width=22%>HY001</td>
<td width=26%>Memory allocation error</td>
<td width=52%>The driver was unable to allocate the memory required to support execution or completion of the function.</td>
</tr>
<tr valign=top>
<td width=22%>HY007</td>
<td width=26%>Associated statement is not prepared</td>
<td width=52%><i>SourceDescHandle</i> was associated with an IRD, and the associated statement handle was not in the prepared or executed state.</td>
</tr>
<tr valign=top>
<td width=22%>HY010</td>
<td width=26%>Function sequence error</td>
<td width=52%>(DM) The descriptor handle in <i>SourceDescHandle</i> or <i>TargetDescHandle</i> was associated with a <i>StatementHandle</i> for which an asynchronously executing function (not this one) was called and was still executing when this function was called.<p>
(DM) The descriptor handle in <i>SourceDescHandle</i> or <i>TargetDescHandle</i> was associated with a <i>StatementHandle</i> for which <b>SQLExecute</b>, <b>SQLExecDirect</b>, <b>SQLBulkOperations</b>, or <b>SQLSetPos</b> was called and returned SQL_NEED_DATA. This function was called before data was sent for all data-at-execution parameters or columns.</p>
</td>
</tr>
<tr valign=top>
<td width=22%>HY013</td>
<td width=26%>Memory management error</td>
<td width=52%>The function call could not be processed because the underlying memory objects could not be accessed, possibly because of low memory conditions.</td>
</tr>
<tr valign=top>
<td width=22%>HY016</td>
<td width=26%>Cannot modify an implementation row descriptor</td>
<td width=52%><i>TargetDescHandle</i> was associated with an IRD.</td>
</tr>
<tr valign=top>
<td width=22%>HY021</td>
<td width=26%>Inconsistent descriptor information</td>
<td width=52%>The descriptor information checked during a consistency check was not consistent. For more information, see “Consistency Checks” in <b>SQLSetDescField</b>.</td>
</tr>
<tr valign=top>
<td width=22%>HY092</td>
<td width=26%>Invalid attribute/option identifier</td>
<td width=52%>The call to <b>SQLCopyDesc</b> prompted a call to <b>SQLSetDescField</b>, but <i>*ValuePtr</i> was not valid for the <i>FieldIdentifier</i> argument on <i>TargetDescHandle</i>.</td>
</tr>
<tr valign=top>
<td width=22%>HYT01</td>
<td width=26%>Connection timeout expired</td>
<td width=52%>The connection timeout period expired before the data source responded to the request. The connection timeout period is set through <b>SQLSetConnectAttr</b>, SQL_ATTR_CONNECTION_TIMEOUT.</td>
</tr>
<tr valign=top>
<td width=22%>IM001</td>
<td width=26%>Driver does not support this function</td>
<td width=52%>(DM) The driver associated with the <i>SourceDescHandle</i> or <i>TargetDescHandle</i> does not support the function.</td>
</tr>
</table><br>
<p class=label>
<b>Comments</b></p>
<p>
A call to <b>SQLCopyDesc</b> copies the fields of the source descriptor handle to the target descriptor handle. Fields can be copied only to an application descriptor or an IPD, but not to an IRD. Fields can be copied from either an application or an implementation descriptor. </p>
<p>
Fields can be copied from an IRD only if the statement handle is in the prepared or executed state; otherwise, the function returns SQLSTATE HY007 (Associated statement is not prepared). </p>
<p>
Fields can be copied from an IPD whether a statement has been prepared or not. If an SQL statement with dynamic parameters has been prepared, and automatic population of the IPD is supported and enabled, then the IPD is populated by the driver. When <b>SQLCopyDesc</b> is called with the IPD as the <i>SourceDescHandle</i>, the populated fields are copied. If the IPD is not populated by the driver, the contents of the fields originally in the IPD are copied.</p>
<p>
All fields of the descriptor, except SQL_DESC_ALLOC_TYPE (which specifies whether the descriptor handle was automatically or explicitly allocated) are copied, whether or not the field is defined for the destination descriptor. Copied fields overwrite the existing fields.</p>
<p>
The driver copies all descriptor fields if the <i>SourceDescHandle</i> and <i>TargetDescHandle</i> arguments are associated with the same driver, even if the drivers are on two different connections or environments. If the <i>SourceDescHandle</i> and <i>TargetDescHandle</i> arguments are associated with different drivers, the Driver Manager copies ODBC-defined fields, but does not copy driver-defined fields or fields that are not defined by ODBC for the type of descriptor.</p>
<p>
The call to<b> SQLCopyDesc</b> is aborted immediately if an error occurs. </p>
<p>
When the SQL_DESC_DATA_PTR field is copied, a consistency check is performed on the target descriptor. If the consistency check fails, SQLSTATE HY021 (Inconsistent descriptor information) is returned and the call to <b>SQLCopyDesc</b> is immediately aborted. For more information on consistency checks, see “Consistency Checks” in <a href="odch21jpr_0q3n.htm">SQLSetDescRec</a>.</p>
<p>
Descriptor handles can be copied across connections even if the connections are under different environments. If the Driver Manager detects that the source and the destination descriptor handles do not belong to the same connection and the two connections belong to separate drivers, it implements <b>SQLCopyDesc</b> by performing a field-by-field copy using <b>SQLGetDescField</b> and <b>SQLSetDescField</b>.</p>
<p>
When <b>SQLCopyDesc</b> is called with a <i>SourceDescHandle</i> on one driver and a <i>TargetDescHandle</i> on another driver, the error queue of the <i>SourceDescHandle</i> is cleared. This occurs because <b>SQLCopyDesc</b> in this case is implemented by calls to <b>SQLGetDescField</b> and <b>SQLSetDescField</b>.</p>
<p class=indent>
<B><b>Note</b></B> An application may be able to associate an explicitly allocated descriptor handle with a <i>StatementHandle</i>, rather than calling <b>SQLCopyDesc</b> to copy fields from one descriptor to another. An explicitly allocated descriptor can be associated with another <i>StatementHandle</i> on the same <i>ConnectionHandle</i> by setting the SQL_ATTR_APP_ROW_DESC or SQL_ATTR_APP_PARAM_DESC statement attribute to the handle of the explicitly allocated descriptor. When this is done, <b>SQLCopyDesc</b> does not have to be called to copy descriptor field values from one descriptor to another. A descriptor handle cannot be associated with a <i>StatementHandle</i> on another <i>ConnectionHandle</i>, however; to use the same descriptor field values on <i>StatementHandles</i> on different <i>ConnectionHandles</i>, <b>SQLCopyDesc</b> has to be called.</p>
<p>
For a description of the fields in a descriptor header or record, see <a href="odch21jpr_7e90.htm">SQLSetDescField</a>. For more information on descriptors, see Chapter 13, “<a href="odch13pr_6l0z.htm">Descriptors</a>.”</p>
<h1>Copying Rows between Tables</h1>
<p>
An application may copy data from one table to another without copying the data at the application level. To do this, the application binds the same data buffers and descriptor information to a statement that fetches the data and another statement that inserts the data into a copy. This can be accomplished either by sharing an application descriptor (binding an explicitly allocated descriptor as both the ARD to one statement and the APD in another), or by using <b>SQLCopyDesc</b> to copy the bindings between the ARD and the APD of the two statements. If the statements are on different connections, <b>SQLCopyDesc</b> must be used. In addition, <b>SQLCopyDesc</b> has to be called to copy the bindings between the IRD and the IPD of the two statements. When copying across statements on the same connection, the SQL_ACTIVE_STATEMENTS information type returned by the driver for a call to <b>SQLGetInfo</b> must be greater than 1 for this operation to succeed (this is not the case when copying across connections).</p>
<p class=label>
<b>Code Example</b></p>
<p>
In the following example, descriptor operations are used to copy the fields of the PartsSource table into the PartsCopy table. The contents of the PartsSource table are fetched into rowset buffers in <i>hstmt0</i>. These values are used as parameters of an INSERT statement on <i>hstmt1</i> to populate the columns of the PartsCopy table. To do so, the fields of the IRD of <i>hstmt0</i> are copied to the fields of the IPD of <i>hstmt1</i>, and the fields of the ARD of <i>hstmt0</i> are copied to the fields of the APD of <i>hstmt1</i>.</p>
<pre><code>#define ROWS 100
#define DESC_LEN 50
#define SQL_SUCCEEDED(rc) (rc == SQL_SUCCESS || rc == SQL_SUCCESS_WITH_INFO)

// Template for a row
typedef struct {
   SQLINTEGER&nbsp; sPartID;
   SQLINTEGER&nbsp; cbPartID;
   SQLUCHAR&nbsp; szDescription[DESC_LENGTH];
   SQLINTEGER&nbsp; cbDescription;
   REAL&nbsp;&nbsp;&nbsp; sPrice;
   SQLINTEGER&nbsp; cbPrice;
}   PartsSource;

PartsSource       rget[ROWS];   // rowset buffer
SQLUSMALLINT      sts_ptr[ROWS];    //status pointer
SQLHSTMT         hstmt0, hstmt1;
SQLHDESC         hArd0, hIrd0, hApd1, hIpd1;

// ARD and IRD of hstmt0
SQLGetStmtAttr(hstmt0, SQL_ATTR_APP_ROW_DESC, &amp;hArd0, 0, NULL);
SQLGetStmtAttr(hstmt0, SQL_ATTR_IMP_ROW_DESC, &amp;hIrd0, 0, NULL);

// APD and IPD of hstmt1
SQLGetStmtAttr(hstmt1, SQL_ATTR_APP_PARAM_DESC, &amp;hApd1, 0, NULL);
SQLGetStmtAttr(hstmt1, SQL_ATTR_IMP_PARAM_DESC, &amp;hIpd1, 0, NULL);

// Use row-wise binding on hstmt0 to fetch rows
SQLSetStmtAttr(hstmt0, SQL_ATTR_ROW_BIND_TYPE, (SQLPOINTER) sizeof(PartsSource), 0);

// Set rowset size for hstmt0
SQLSetStmtAttr(hstmt0, SQL_ATTR_ROW_ARRAY_SIZE, (SQLPOINTER) ROWS, 0);

// Execute a select statement
SQLExecDirect(hstmt0, "SELECT PARTID, DESCRIPTION, PRICE FROM PARTS ORDER BY 3, 1, 2",               SQL_NTS);

// Bind
SQLBindCol(hstmt0, 1, SQL_C_SLONG, rget[0].sPartID, 0, 
 &nbsp;&nbsp;&nbsp; &amp;rget[0].cbPartID);
SQLBindCol(hstmt0, 2, SQL_C_CHAR, &amp;rget[0].szDescription, DESC_LEN, 
 &nbsp;&nbsp;&nbsp; &amp;rget[0].cbDescription);
SQLBindCol(hstmt0, 3, SQL_C_FLOAT, rget[0].sPrice, 
 &nbsp;&nbsp;&nbsp; 0, &amp;rget[0].cbPrice);

// Perform parameter bindings on hstmt1. 
SQLCopyDesc(hArd0, hApd1);
SQLCopyDesc(hIrd0, hIpd1);

// Set the array status pointer of IRD
SQLSetStmtAttr(hstmt0, SQL_ATTR_ROW_STATUS_PTR, sts_ptr, SQL_IS_POINTER);

// Set the ARRAY_STATUS_PTR field of APD to be the same
// as that in IRD.
SQLSetStmtAttr(hstmt1, SQL_ATTR_PARAM_OPERATION_PTR, sts_ptr, SQL_IS_POINTER);

// Prepare an insert statement on hstmt1. PartsCopy is a copy of
// PartsSource
SQLPrepare(hstmt1, "INSERT INTO PARTS_COPY VALUES (?, ?, ?)", SQL_NTS);

// In a loop, fetch a rowset, and copy the fetched rowset to PARTS_COPY

rc = SQLFetchScroll(hstmt0, SQL_FETCH_NEXT, 0);
while (SQL_SUCCEEDED(rc)) {

   // After the call to SQLFetchScroll, the status array has row 
   // statuses. This array is used as input status in the APD
   // and hence determines which elements of the rowset buffer
   // are inserted.
   SQLExecute(hstmt1);

   rc = SQLFetchScroll(hstmt0, SQL_FETCH_NEXT, 0);
} // while
</code></pre>
<p class=label>
<b>Related Functions</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=48%><b>For information about</b></td>
<td class=label width=52%><b>See</b></td>
</tr>
<tr valign=top>
<td width=48%>Getting multiple descriptor fields</td>
<td width=52%><a href="odch21gpr_12ub.htm">SQLGetDescRec</a></td>
</tr>
<tr valign=top>
<td width=48%>Setting a single descriptor field</td>
<td width=52%><a href="odch21jpr_7e90.htm">SQLSetDescField</a></td>
</tr>
<tr valign=top>
<td width=48%>Setting multiple descriptor fields</td>
<td width=52%><a href="odch21jpr_0q3n.htm">SQLSetDescRec</a></td>
</tr>
</table><br>
</font></BODY>
</HTML>
