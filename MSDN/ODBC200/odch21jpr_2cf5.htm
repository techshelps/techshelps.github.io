<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SQLPutData</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="odbcsqlputdata"></a>SQLPutData</h1>
<p class=label>
<b>Conformance</b></p>
<p>
Version Introduced:ODBC 1.0<br>
Standards Compliance:ISO 92</p>
<p class=label>
<b>Summary</b></p>
<p>
<b>SQLPutData</b> allows an application to send data for a parameter or column to the driver at statement execution time. This function can be used to send character or binary data values in parts to a column with a character, binary, or data source&nbsp;–&nbsp;specific data type (for example, parameters of the SQL_LONGVARBINARY or SQL_LONGVARCHAR types). <b>SQLPutData supports binding to a Unicode C data type, even if the underlying driver does not support Unicode data.</b></p>
<p class=label>
<b>Syntax</b></p>
<p>
SQLRETURN <b>SQLPutData</b>(<br>
SQLHSTMT<i>StatementHandle</i>,<br>
SQLPOINTER<i>DataPtr</i>,<br>
SQLINTEGER<i>StrLen_or_Ind</i>);</p>
<p class=label>
<b>Arguments</b></p>
<p class=dt>
<i>StatementHandle</i></p>
<p class=indent>
[Input]<br>
Statement handle.</p>
<p class=dt>
<i>DataPtr</i></p>
<p class=indent>
[Input]<br>
Pointer to a buffer containing the actual data for the parameter or column. The data must be in the C data type specified in the <i>ValueType</i> argument of <b>SQLBindParameter</b> (for parameter data) or the <i>TargetType</i> argument of <b>SQLBindCol</b> (for column data).</p>
<p class=dt>
<i>StrLen_or_Ind</i></p>
<p class=indent>
[Input]<br>
Length of *<i>DataPtr</i>. Specifies the amount of data sent in a call to <b>SQLPutData</b>. The amount of data can vary with each call for a given parameter or column. <i>StrLen_or_Ind</i> is ignored unless it is one of the following: 
<ul type=disc>
<li>
SQL_NTS, SQL_NULL_DATA, or SQL_DEFAULT_PARAM<br><br></li>
<li>
The C data type specified in <b>SQLBindParameter</b> or <b>SQLBindCol</b> is SQL_C_CHAR or SQL_C_BINARY. <br><br></li>
<li>
The C data type is SQL_C_DEFAULT and the default C data type for the specified SQL data type is SQL_C_CHAR or SQL_C_BINARY. </li>
</ul>
<p>
For all other types of C data, if <i>StrLen_or_Ind</i> is not SQL_NULL_DATA or SQL_DEFAULT_PARAM, the driver assumes that the size of the *<i>DataPtr</i> buffer is the size of the C data type specified with <i>ValueType</i> or <i>TargetType</i> and sends the entire data value. For more information, see <a href="odappdpr_744z.htm">“Converting Data from C to SQL Data Types</a>" in Appendix D, “Data Types.”</p>
<p class=label>
<b>Returns</b></p>
<p>
SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_STILL_EXECUTING, SQL_ERROR, or SQL_INVALID_HANDLE.</p>
<p class=label>
<b>Diagnostics</b></p>
<p>
When <b>SQLPutData</b> returns SQL_ERROR or SQL_SUCCESS_WITH_INFO, an associated SQLSTATE value can be obtained by calling <b>SQLGetDiagRec</b> with a <i>HandleType</i> of SQL_HANDLE_STMT and a <i>Handle</i> of <i>StatementHandle</i>. The following table lists the SQLSTATE values commonly returned by <b>SQLPutData</b> and explains each one in the context of this function; the notation “(DM)” precedes the descriptions of SQLSTATEs returned by the Driver Manager. The return code associated with each SQLSTATE value is SQL_ERROR, unless noted otherwise.</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=22%><b>SQLSTATE</b></td>
<td class=label width=28%><b>Error</b></td>
<td class=label width=50%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=22%>01000</td>
<td width=28%>General warning</td>
<td width=50%>Driver-specific informational message. (Function returns SQL_SUCCESS_WITH_INFO.)</td>
</tr>
<tr valign=top>
<td width=22%>01004</td>
<td width=28%>String data, right truncated</td>
<td width=50%>String or binary data returned for an output parameter resulted in the truncation of non-blank character or non-NULL binary data. If it was a string value, it was right truncated. (Function returns SQL_SUCCESS_WITH_INFO.)</td>
</tr>
<tr valign=top>
<td width=22%>07006</td>
<td width=28%>Restricted data type <br>
attribute violation</td>
<td width=50%>The data value identified by the <i>ValueType</i> argument in <b>SQLBindParameter</b> for the bound parameter could not be converted to the data type identified by the <i>ParameterType</i> argument in <b>SQLBindParameter</b>.</td>
</tr>
<tr valign=top>
<td width=22%>07S01</td>
<td width=28%>Invalid use of default parameter</td>
<td width=50%>A parameter value, set with <b>SQLBindParameter</b>, was SQL_DEFAULT_PARAM, and the corresponding parameter did not have a default value.</td>
</tr>
<tr valign=top>
<td width=22%>08S01</td>
<td width=28%>Communication link failure</td>
<td width=50%>The communication link between the driver and the data source to which the driver was connected failed before the function completed processing.</td>
</tr>
<tr valign=top>
<td width=22%>22001</td>
<td width=28%>String data, right truncation</td>
<td width=50%>The assignment of a character or binary value to a column resulted in the truncation of non-blank (character) or non-null (binary) characters or bytes. <p>
The SQL_NEED_LONG_DATA_LEN information type in <b>SQLGetInfo</b> was “Y” and more data was sent for a long parameter (the data type was SQL_LONGVARCHAR, SQL_LONGVARBINARY, or a long, data source&nbsp;–&nbsp;specific data type) than was specified with the <i>StrLen_or_IndPtr</i> argument in <b>SQLBindParameter</b>.</p>
<p>
The SQL_NEED_LONG_DATA_LEN information type in <b>SQLGetInfo</b> was “Y” and more data was sent for a long column (the data type was SQL_LONGVARCHAR, SQL_LONGVARBINARY, or a long, data source&nbsp;–&nbsp;specific data type) than was specified in the length buffer corresponding to a column in a row of data that was added or updated with <b>SQLBulkOperations</b>, or updated with <b>SQLSetPos</b>.</p>
</td>
</tr>
<tr valign=top>
<td width=22%>22003</td>
<td width=28%>Numeric value out of range</td>
<td width=50%>The data sent for a bound numeric parameter or column caused the whole (as opposed to fractional) part of the number to be truncated when assigned to the associated table column.<p>
Returning a numeric value (as numeric or string) for one or more input/output or output parameters would have caused the whole (as opposed to fractional) part of the number to be truncated.</p>
</td>
</tr>
<tr valign=top>
<td width=22%>22007</td>
<td width=28%>Invalid datetime format</td>
<td width=50%>The data sent for a parameter or column that was bound to a date, time, or timestamp structure was, respectively, an invalid date, time, or timestamp.<p>
An input/output or output parameter was bound to a date, time, or timestamp C structure, and a value in the returned parameter was, respectively, an invalid date, time, or timestamp. (Function returns SQL_SUCCESS_WITH_INFO.)</p>
</td>
</tr>
<tr valign=top>
<td width=22%>22008</td>
<td width=28%>Datetime field overflow</td>
<td width=50%>A datetime expression computed for an input/output or output parameter resulted in a date, time, or timestamp C structure that was invalid.</td>
</tr>
<tr valign=top>
<td width=22%>22012</td>
<td width=28%>Division by zero</td>
<td width=50%>An arithmetic expression calculated for an input/output or output parameter resulted in division by zero.</td>
</tr>
<tr valign=top>
<td width=22%>22015</td>
<td width=28%>Interval field overflow</td>
<td width=50%>The data sent for an exact numeric or interval column or parameter to an interval SQL data type caused a loss of significant digits. <p>
Data was sent for an interval column or parameter with more than one field, and was converted to a numeric data type, and had no representation in the numeric data type. </p>
<p>
The data sent for column or parameter data was assigned to an interval SQL type, and there was no representation of the value of the C type in the interval SQL type. </p>
<p>
The data sent for an exact numeric or interval C column or parameter to an interval C type caused a loss of significant digits. </p>
<p>
The data sent for column or parameter data was assigned to an interval C structure, and there was no representation of the data in the interval data structure.</p>
</td>
</tr>
<tr valign=top>
<td width=22%>22018</td>
<td width=28%>Invalid character value for cast specification</td>
<td width=50%>The C type was an exact or approximate numeric, a datetime, or an interval data type; the SQL type of the column was a character data type; and the value in the column or parameter was not a valid literal of the bound C type. <p>
The SQL type was an exact or approximate numeric, a datetime, or an interval data type; the C type was SQL_C_CHAR; and the value in the column or parameter was not a valid literal of the bound SQL type.</p>
</td>
</tr>
<tr valign=top>
<td width=22%>HY000</td>
<td width=28%>General error</td>
<td width=50%>An error occurred for which there was no specific SQLSTATE and for which no implementation-specific SQLSTATE was defined. The error message returned by <b>SQLGetDiagRec</b> in the <i>*MessageText</i> buffer describes the error and its cause.</td>
</tr>
<tr valign=top>
<td width=22%>HY001</td>
<td width=28%>Memory allocation error</td>
<td width=50%>The driver was unable to allocate memory required to support execution or completion of the function.</td>
</tr>
<tr valign=top>
<td width=22%>HY008</td>
<td width=28%>Operation canceled</td>
<td width=50%>Asynchronous processing was enabled for the <i>StatementHandle</i>. The function was called and, before it completed execution, <b>SQLCancel</b> was called on the <i>StatementHandle</i>. Then the function was called again on the <i>StatementHandle</i>.<p>
The function was called and, before it completed execution, <b>SQLCancel</b> was called on the <i>StatementHandle</i> from a different thread in a multithread application.</p>
</td>
</tr>
<tr valign=top>
<td width=22%>HY009</td>
<td width=28%>Invalid use of null pointer</td>
<td width=50%>(DM) The argument <i>DataPtr</i> was a null pointer and the argument <i>StrLen_or_Ind</i> was not 0, SQL_DEFAULT_PARAM, or SQL_NULL_DATA.</td>
</tr>
<tr valign=top>
<td width=22%>HY010</td>
<td width=28%>Function sequence error</td>
<td width=50%>(DM) The previous function call was not a call to <b>SQLPutData</b> or <b>SQLParamData</b>.</td>
</tr>
<tr valign=top>
<td width=22%></td>
<td width=28%></td>
<td width=50%>(DM) An asynchronously executing function (not this one) was called for the <i>StatementHandle</i> and was still executing when this function was called.</td>
</tr>
<tr valign=top>
<td width=22%>HY013</td>
<td width=28%>Memory management error</td>
<td width=50%>The function call could not be processed because the underlying memory objects could not be accessed, possibly because of low memory conditions.</td>
</tr>
<tr valign=top>
<td width=22%>HY019</td>
<td width=28%>Non-character and non-binary data sent in pieces</td>
<td width=50%><b>SQLPutData</b> was called more than once for a parameter or column and it was not being used to send character C data to a column with a character, binary, or data source&nbsp;–&nbsp;specific data type or to send binary C data to a column with a character, binary, or data source&nbsp;–&nbsp;specific data type.</td>
</tr>
<tr valign=top>
<td width=22%>HY020</td>
<td width=28%>Attempt to concatenate a null value</td>
<td width=50%><b>SQLPutData</b> was called more than once since the call that returned SQL_NEED_DATA, and in one of those calls, the <i>StrLen_or_Ind</i> argument contained SQL_NULL_DATA or SQL_DEFAULT_PARAM.</td>
</tr>
<tr valign=top>
<td width=22%>HY090</td>
<td width=28%>Invalid string or buffer length</td>
<td width=50%>The argument <i>DataPtr</i> was not a null pointer and the argument <i>StrLen_or_Ind</i> was less than 0, but not equal to SQL_NTS or SQL_NULL_DATA.</td>
</tr>
<tr valign=top>
<td width=22%>HYT01</td>
<td width=28%>Connection timeout expired</td>
<td width=50%>The connection timeout period expired before the data source responded to the request. The connection timeout period is set through <b>SQLSetConnectAttr</b>, SQL_ATTR_CONNECTION_TIMEOUT.</td>
</tr>
<tr valign=top>
<td width=22%>IM001</td>
<td width=28%>Driver does not support this function</td>
<td width=50%>(DM) The driver associated with the <i>StatementHandle</i> does not support the function.</td>
</tr>
</table><br>
<p>
If <b>SQLPutData</b> is called while sending data for a parameter in an SQL statement, it can return any SQLSTATE that can be returned by the function called to execute the statement (<b>SQLExecute</b> or <b>SQLExecDirect</b>). If it is called while sending data for a column being updated or added with <b>SQLBulkOperations</b>, or updated with <b>SQLSetPos</b>, it can return any SQLSTATE that can be returned by <b>SQLBulkOperations</b> or <b>SQLSetPos</b>.</p>
<p class=label>
<b>Comments</b></p>
<p>
<b>SQLPutData</b> can be called to supply data-at-execution data for two uses: parameter data to be used in a call to <b>SQLExecute</b> or <b>SQLExecDirect</b>, or column data to be used when a row is updated or added by a call to <b>SQLBulkOperations</b>, or updated by a call to <b>SQLSetPos</b>.</p>
<p>
When an application calls <b>SQLParamData</b> to determine which data it should send, the driver returns an indicator that the application can use to determine which parameter data to send, or where column data can be found. It also returns SQL_NEED_DATA, which is an indicator to the application that it should call <b>SQLPutData</b> to send the data. In the <i>DataPtr</i> argument to <b>SQLPutData</b>, the application passes a pointer to the buffer containing the actual data for the parameter or column. </p>
<p>
When the driver returns SQL_SUCCESS for <b>SQLPutData</b>, the application calls <b>SQLParamData</b> again. <b>SQLParamData</b> returns SQL_NEED_DATA if more data needs to be sent, in which case the application calls <b>SQLPutData</b> again. It returns SQL_SUCCESS if all data-at-execution data has been sent. The application then calls <b>SQLParamData</b> again. If the driver returns SQL_NEED_DATA and another indicator in <i>*ValuePtrPtr</i>, it requires data for another parameter or column, and <b>SQLPutData</b> is called again. If the driver returns SQL_SUCCESS, then all data-at-execution data has been sent, and the SQL statement can be executed or the <b>SQLBulkOperations</b> or <b>SQLSetPos</b> call can be processed.</p>
<p>
For more information on how data-at-execution parameter data is passed at statement execution time, see “Passing Parameter Values” in <b>SQLBindParameter</b> and “<a href="odch09pr_7f4x.htm">Sending Long Data</a>” in Chapter 9, “Executing Statements.” For more information on how data-at-execution column data is updated or added, see the section “Using SQLSetPos” in <a href="odch21kpr_2rsj.htm">SQLSetPos</a>, “Performing Bulk Updates Using Bookmarks” in <a href="odch21bpr_9er7.htm">SQLBulkOperations</a>, and “<a href="odch12pr_8qgj.htm">Long Data and SQLSetPos and SQLBulkOperations</a>” in Chapter 12, “Updating Data.”</p>
<p class=indent>
<B><b>Note</b></B> An application can use <b>SQLPutData</b> to send data in parts only when sending character C data to a column with a character, binary, or data source&nbsp;–&nbsp;specific data type or when sending binary C data to a column with a character, binary, or data source&nbsp;–&nbsp;specific data type. If <b>SQLPutData</b> is called more than once under any other conditions, it returns SQL_ERROR and SQLSTATE HY019 (Non-character and non-binary data sent in pieces).</p>
<p class=label>
<b>Code Example</b></p>
<p>
In the following example, an application prepares an SQL statement to insert data into the PICTURES table. The statement contains parameters for the PARTID and PICTURE columns. For each parameter, the application calls <b>SQLBindParameter</b> to specify the C and SQL data types of the parameter. It also specifies that the data for the second parameter will be passed at execution time, and passes the value 2 for later retrieval by <b>SQLParamData</b>. This value will identify the parameter that is being processed.</p>
<p>
The application calls <b>GetNextID</b> to get the next available part ID number. It then calls <b>SQLExecute</b> to execute the statement. <b>SQLExecute</b> returns SQL_NEED_DATA when it needs data for the second parameter. The application calls <b>SQLParamData</b> to retrieve the value it stored with <b>SQLBindParameter</b>; it uses this value to determine which parameter to send data for. For each parameter, the application calls <b>InitUserData</b> to initialize the data routine. It repeatedly calls <b>GetUserData</b> and <b>SQLPutData</b> to get and send the parameter data. Finally, it calls <b>SQLParamData</b> to indicate it has sent all the data for the parameter, at which point it returns SQL_SUCCESS.</p>
<p>
For the second parameter, <b>InitUserData</b> calls a routine to prompt the user for the name of a file containing a bitmap photo of the part and opens the file. <b>GetUserData</b> retrieves the next MAX_DATA_LEN bytes of photo data from the file. After it has retrieved all the photo data, it closes the photo file.</p>
<p>
Note that some application routines are omitted for clarity.</p>
<pre><code>#define&nbsp; MAX_DATA_LEN 1024
SQLINTEGER cbPartID = 0, cbPhotoParam, cbData;
SQLUINTEGER&nbsp; sPartID;
 &nbsp;&nbsp;&nbsp; szPhotoFile;
SQLPOINTER pToken, InitValue;
SQLCHAR&nbsp; Data[MAX_DATA_LEN];
SQLRETURN&nbsp; retcode;
SQLHSTMT&nbsp;&nbsp; hstmt;

retcode = SQLPrepare(hstmt,
 &nbsp;&nbsp; "INSERT INTO PICTURES (PARTID, PICTURE) VALUES 
         (?, ?)", SQL_NTS);
if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) {

   /* Bind the parameters. For parameter 2, pass */
   /* the parameter number in ParameterValuePtr instead of a buffer */    
   /* address. */

   SQLBindParameter(hstmt, 1, SQL_PARAM_INPUT, SQL_C_ULONG, 
                &nbsp; SQL_INTEGER, 0, 0, &amp;sPartID, 0, &amp;cbPartID);
   SQLBindParameter(hstmt, 2, SQL_PARAM_INPUT,
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SQL_C_BINARY, SQL_LONGVARBINARY,
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 0, (SQLPOINTER) 2, 0, &amp;cbPhotoParam);

   /* Set values so data for parameter 2 will be */
   /* passed at execution. Note that the length parameter in */
   /* the macro SQL_LEN_DATA_AT_EXEC is 0. This assumes that */
   /* the driver returns "N" for the SQL_NEED_LONG_DATA_LEN */
   /* information type in SQLGetInfo.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */

   cbPhotoParam = SQL_LEN_DATA_AT_EXEC(0);

   sPartID = GetNextID();&nbsp; /* Get next available employee ID */
                   /* number. */

   retcode = SQLExecute(hstmt);

   /* For data-at-execution parameters, call SQLParamData to */
   /* get the parameter number set by SQLBindParameter. */
   /* Call InitUserData. Call GetUserData and SQLPutData */
   /* repeatedly to get and put all data for the parameter. */
   /* Call SQLParamData to finish processing this parameter */

   while (retcode == SQL_NEED_DATA) {
      retcode = SQLParamData(hstmt, &amp;pToken);
      if (retcode == SQL_NEED_DATA) {
         InitUserData((SQLSMALLINT)pToken, InitValue);
         while (GetUserData(InitValue, (SQLSMALLINT)pToken, Data, 
                            &amp;cbData))
            SQLPutData(hstmt, Data, cbData);
      }
   }
}

VOID InitUserData(sParam, InitValue)
SQLPOINTER InitValue;
{
 SQLCHAR&nbsp; szPhotoFile[MAX_FILE_NAME_LEN];

 /* Prompt user for bitmap file containing employee */
 /* photo. OpenPhotoFile opens the file and returns the */
 /* file handle. */

 PromptPhotoFileName(szPhotoFile);
 OpenPhotoFile(szPhotoFile, (FILE *)InitValue);
 break;
 }

BOOL GetUserData(InitValue, sParam, Data, cbData)
SQLPOINTER InitValue;
SQLCHAR&nbsp; *Data;
SQLINTEGER *cbData;
BOOL&nbsp;&nbsp; Done;

{

 /* GetNextPhotoData returns the next piece of photo */
 /* data and the number of bytes of data returned    */
 /* (up to MAX_DATA_LEN). */

 Done = GetNextPhotoData((FILE *)InitValue, Data,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MAX_DATA_LEN, &amp;cbData);
 if (Done) {
    ClosePhotoFile((FILE *)InitValue);
    return (TRUE);
 }
 return (FALSE);
 }
</code></pre>
<p class=label>
<b>Related Functions</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=50%><b>For information about</b></td>
<td class=label width=50%><b>See</b></td>
</tr>
<tr valign=top>
<td width=50%>Binding a buffer to a parameter</td>
<td width=50%><a href="odch21bpr_6jhu.htm">SQLBindParameter</a></td>
</tr>
<tr valign=top>
<td width=50%>Canceling statement processing</td>
<td width=50%><a href="odch21bpr_5b58.htm">SQLCancel</a></td>
</tr>
<tr valign=top>
<td width=50%>Executing an SQL statement</td>
<td width=50%><a href="odch21epr_35x0.htm">SQLExecDirect</a></td>
</tr>
<tr valign=top>
<td width=50%>Executing a prepared SQL statement</td>
<td width=50%><a href="odch21epr_0yg5.htm">SQLExecute</a></td>
</tr>
<tr valign=top>
<td width=50%>Returning the next parameter to send data for</td>
<td width=50%><a href="odch21ipr_11i9.htm">SQLParamData</a></td>
</tr>
</table><br>
</font></BODY>
</HTML>
