<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SQLFetchScroll in the Cursor Library</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h3><a name="odbcsqlfetchscroll_in_the_cursor_library"></a>SQLFetchScroll in the Cursor Library</h3>
<p>
The cursor library implements <b>SQLFetchScroll</b> by repeatedly calling <b>SQLFetch</b> in the driver. It transfers the data it retrieves from the driver to the rowset buffers provided by the application. It also caches the data in memory and disk files. When an application requests a new rowset, the cursor library retrieves it as necessary from the driver (if it has not been previously fetched) or the cache (if it has been previously fetched). Finally, the cursor library maintains the status of the cached data and returns this information to the application in the row status array.</p>
<p>
When the cursor library is used, calls to <b>SQLFetchScroll</b> cannot be mixed with calls to either <b>SQLFetch</b> or <b>SQLExtendedFetch</b>.</p>
<p>
When the cursor library is used, calls to <b>SQLFetchScroll</b> are supported for both ODBC 2.<i>x</i> and ODBC 3.<i>x</i> drivers.</p>
<h4>Rowset Buffers</h4>
<p>
The cursor library optimizes the transfer of data from the driver to the rowset buffer provided by the application if:
<ul type=disc>
<li>
The application uses row-wise binding.<br><br></li>
<li>
There are no unused bytes between fields in the structure the application declares to hold a row of data.<br><br></li>
<li>
The fields in which <b>SQLFetch</b> or <b>SQLFetchScroll</b> returns the length/indicator for a column follows the buffer for that column and precedes the buffer for the next column. Note that these fields are optional.</li>
</ul>
<p>
When the application requests a new rowset, the cursor library retrieves data from its cache and from the driver as necessary. If the new and old rowsets overlap, the cursor library may optimize its performance by reusing the data from the overlapping sections of the rowset buffers. Thus, unsaved changes to the rowset buffers are lost unless the new and old rowsets overlap and the changes are in the overlapping sections of the rowset buffers. To save the changes, an application submits a positioned update statement.</p>
<p>
Note that the cursor library always refreshes the rowset buffers with data from the cache when an application calls <b>SQLFetchScroll</b> with the <i>FetchOrientation</i> argument set to SQL_FETCH_RELATIVE and the <i>FetchOffset</i> argument set to 0.</p>
<p>
The cursor library supports calling <b>SQLSetStmtAttr</b> with an <i>Attribute</i> of SQL_ATTR_ROW_ARRAY_SIZE to change the rowset size while a cursor is open. The new rowset size will take effect the next time <b>SQLFetchScroll</b> is called.</p>
<h4>Result Set Membership</h4>
<p>
The cursor library retrieves data from the driver only as the application requests it. Depending on the data source and the setting of the SQL_CONCURRENCY statement attribute, this has the following consequences:
<ul type=disc>
<li>
The data retrieved by the cursor library may differ from the data that was available at the time the statement was executed. For example, after the cursor was opened, rows inserted at a point beyond the current cursor position can be retrieved by some drivers.<br><br></li>
<li>
The data in the result set may be locked by the data source for the cursor library and therefore be unavailable to other users.</li>
</ul>
<p>
After the cursor library has cached a row of data, it cannot detect changes to that row in the underlying data source (except for positioned updates and deletes operating on the same cursor’s cache). This occurs because, for calls to <b>SQLFetchScroll</b>, the cursor library never refetches data from the data source. Instead it refetches data from its cache.</p>
<h4>Scrolling</h4>
<p>
The cursor library supports the following fetch types in <b>SQLFetchScroll</b>.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=48%><b>Cursor type</b></td>
<td class=label width=52%><b>Fetch types</b></td>
</tr>
<tr valign=top>
<td width=48%>Forward-only</td>
<td width=52%>SQL_FETCH_NEXT</td>
</tr>
<tr valign=top>
<td width=48%>Static</td>
<td width=52%>SQL_FETCH_NEXT<br>
SQL_FETCH_PRIOR<br>
SQL_FETCH_FIRST<br>
SQL_FETCH_LAST<br>
SQL_FETCH_RELATIVE<br>
SQL_FETCH_ABSOLUTE<br>
SQL_FETCH_BOOKMARK</td>
</tr>
</table><br>
<h4>Errors</h4>
<p>
When <b>SQLFetchScroll</b> is called, and one of the calls to <b>SQLFetch</b> returns SQL_ERROR, the cursor library proceeds as follows. After it completes these steps, the cursor library continues processing.
<ol>
<li>
Calls <b>SQLGetDiagRec</b> to obtain error information from the driver, and posts this as a diagnostic record in the Driver Manager.<br><br></li>
<li>
Sets the SQL_DIAG_ROW_NUMBER field in the diagnostic record to the appropriate value.<br><br></li>
<li>
Sets the SQL_DIAG_COLUMN_NUMBER field in the diagnostic record to the appropriate value, if applicable; otherwise, it sets it to 0.<br><br></li>
<li>
Sets the value for the row in error in the row status array to SQL_ROW_ERROR.</li>
</ol>
<p>
After the cursor library has called <b>SQLFetch</b> multiple times in its implementation of <b>SQLFetchScroll</b>, any error or warning returned by one of the calls to <b>SQLFetch</b> will be in a diagnostic record, and may be retrieved by a call to <b>SQLGetDiagRec</b>. If the data was truncated when it was fetched, the truncated data will now reside in the cursor library’s cache. Subsequent calls to <b>SQLFetchScroll</b> to scroll to a row with truncated data will return the truncated data, and no warning will be raised because the data is fetched from the cursor library’s cache. To keep track of the length of data returned, so it can determine if the data returned in a buffer has been truncated, an application should bind the length/indicator buffer.</p>
<h4>Bookmark Operations</h4>
<p>
The cursor library supports calling <b>SQLFetchScroll</b> with a <i>FetchOrientation</i> of SQL_FETCH_BOOKMARK. It also supports specifying an offset in the <i>FetchOffset</i> argument to be used in the bookmark operation. This is the only bookmark operation the cursor library supports. The cursor library does not support calling <b>SQLBulkOperations</b>.</p>
<p>
If the application has set the SQL_ATTR_USE_BOOKMARKS statement attribute, and has bound to the bookmark column, then the cursor library generates a fixed-length bookmark and returns it to the application. The cursor library creates and maintains the bookmarks that it uses; it does not use bookmarks maintained at the data source. When <b>SQLFetchScroll</b> is called to retrieve a block of data that has already been fetched from the data source, it retrieves the data from the cursor library cache. As a result, the bookmark used in a call to <b>SQLFetchScroll</b> with a <i>FetchOrientation</i> of SQL_FETCH_BOOKMARK must be created and maintained by the cursor library.</p>
<h4>Interaction with Other Functions</h4>
<p>
An application must call <b>SQLFetch</b> or <b>SQLFetchScroll</b> before it prepares or executes any positioned update or delete statements.</p>
</font></BODY>
</HTML>
