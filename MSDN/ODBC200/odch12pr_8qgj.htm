<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Long Data and SQLSetPos and SQLBulkOperations</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="odbclong_data_and_sqlsetpos_and_sqlbulkoperations"></a>Long Data and SQLSetPos and SQLBulkOperations</h1>
<p>
As is the case with parameters in SQL statements, long data can be sent when updating rows with <b>SQLBulkOperations</b> or <b>SQLSetPos</b> or inserting rows with <b>SQLBulkOperations</b>. The data is sent in parts with multiple calls to <b>SQLPutData</b>. Columns for which data is sent at execution time are known as <i>data-at-execution columns</i>.</p>
<p class=indent>
<B><b>Note&nbsp;&nbsp;&nbsp;</b></B>An application actually can send any type of data at execution time with <b>SQLPutData</b>, although only character and binary data can be sent in parts. However, if the data is small enough to fit in a single buffer, there is generally no reason to use <b>SQLPutData</b>. It is much easier to bind the buffer and let the driver retrieve the data from the buffer.</p>
<p>
Because long data columns typically are not bound, the application must bind the column before calling <b>SQLBulkOperations</b> or <b>SQLSetPos</b>, and unbind it after calling <b>SQLBulkOperations</b> or <b>SQLSetPos</b>. The column must be bound because <b>SQLBulkOperations</b> or <b>SQLSetPos</b> operates only on bound columns, and must be unbound so <b>SQLGetData</b> can be used to retrieve data from the column.</p>
<p>
To send data at execution time, the application:
<ol>
<li>
Places a 32-bit value in the rowset buffer instead of a data value. This value will be returned to the application later, so the application should set it to a meaningful value, such as the number of the column or the handle of a file containing data.<br><br></li>
<li>
Sets the value in the length/indicator buffer to the result of the SQL_LEN_DATA_AT_EXEC(<i>length</i>) macro. This value indicates to the driver that the data for the parameter will be sent with <b>SQLPutData</b>. The <i>length</i> value is used when sending long data to a data source that needs to know how many bytes of long data will be sent so that it can preallocate space. To determine if a data source requires this value, the application calls <b>SQLGetInfo</b> with the SQL_NEED_LONG_DATA_LEN option. All drivers must support this macro; if the data source does not require the byte length, the driver can ignore it.<br><br></li>
<li>
Calls <b>SQLBulkOperations</b> or <b>SQLSetPos</b>. The driver discovers that a length/indicator buffer contains the result of the SQL_LEN_DATA_AT_EXEC(<i>length</i>) macro and returns SQL_NEED_DATA as the return value of the function.<br><br></li>
<li>
Calls <b>SQLParamData</b> in response to the SQL_NEED_DATA return value. If long data needs to be sent, <b>SQLParamData</b> returns SQL_NEED_DATA. In the buffer pointed to by the <i>ValuePtrPtr</i> argument, the driver returns the unique value that the application placed in the rowset buffer. If there is more than one data-at-execution column, the application uses this value to determine which column to send data for; the driver is not required to request data for data-at-execution columns in any particular order.<br><br></li>
<li>
Calls <b>SQLPutData</b> to send the column data to the driver. If the column data does not fit in a single buffer, as is often the case with long data, the application calls <b>SQLPutData</b> repeatedly to send the data in parts; it is up to the driver and data source to reassemble the data. If the application passes null-terminated string data, the driver or data source must remove the null-termination character as part of the reassembly process.<br><br></li>
<li>
Calls <b>SQLParamData</b> again to indicate that it has sent all of the data for the column. If there are any data-at-execution columns for which data has not been sent, the driver returns SQL_NEED_DATA and the unique value for the next data-at-execution column; the application returns to Step 5. If data has been sent for all data-at-execution columns, the data for the row is sent to the data source. <b>SQLParamData</b> then returns SQL_SUCCESS or SQL_SUCCESS_WITH_INFO, and can return any SQLSTATE that <b>SQLBulkOperations</b> or <b>SQLSetPos</b> can return.</li>
</ol>
<p>
After <b>SQLBulkOperations</b> or <b>SQLSetPos</b> returns SQL_NEED_DATA and before data has been completely sent for the last data-at-execution column, the statement is in a Need Data state. In this state, the application can call only <b>SQLPutData</b>, <b>SQLParamData</b>, <b>SQLCancel</b>, <b>SQLGetDiagField</b>, or <b>SQLGetDiagRec</b>; all other functions return SQLSTATE HY010 (Function sequence error). Calling <b>SQLCancel</b> cancels execution of the statement and returns it to its previous state. For more information, see Appendix B, “<a href="odappbpr_5v3n.htm">ODBC State Transition Tables</a>.”</p>
</font></BODY>
</HTML>
