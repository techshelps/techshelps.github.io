<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Transaction Isolation Levels</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h2><a name="odbctransaction_isolation_levels"></a>Transaction Isolation Levels</h2>
<p>
<i>Transaction isolation levels</i> are a measure of the extent to which transaction isolation succeeds. In particular, transaction isolation levels are defined by the presence or absence of the following phenomena:
<ul type=disc>
<li>
<b>Dirty Reads</b>. A <i>dirty read</i> occurs when a transaction reads data that has not yet been committed. For example, suppose transaction 1 updates a row. Transaction 2 reads the updated row before transaction 1 commits the update. If transaction 1 rolls back the change, transaction 2 will have read data that is considered never to have existed.<br><br></li>
<li>
<b>Nonrepeatable Reads</b>. A <i>nonrepeatable read</i> occurs when a transaction reads the same row twice but gets different data each time. For example, suppose transaction 1 reads a row. Transaction 2 updates or deletes that row and commits the update or delete. If transaction 1 rereads the row, it retrieves different row values or discovers that the row has been deleted.<br><br></li>
<li>
<b>Phantoms</b>. A <i>phantom</i> is a row that matches the search criteria but is not initially seen. For example, suppose transaction 1 reads a set of rows that satisfy some search criteria. Transaction 2 generates a new row (either through an update or insert) that matches the search criteria for transaction 1. If transaction 1 reexecutes the statement that reads the rows, it gets a different set of rows.</li>
</ul>
<p>
The four transaction isolation levels (as defined by SQL-92) are defined in terms of these phenomena. In the following table, an “X” marks each phenomenon that can occur:</p>
<table border=1 cellpadding=5 cols=4 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=33%><b>Transaction isolation level</b></td>
<td class=label width=19%><b>Dirty<br>
reads</b></td>
<td class=label width=29%><b><br>
Nonrepeatable reads</b></td>
<td class=label width=19%><b><br>
Phantoms</b></td>
</tr>
<tr valign=top>
<td width=33%>Read uncommitted</td>
<td width=19%>X</td>
<td width=29%>X</td>
<td width=19%>X</td>
</tr>
<tr valign=top>
<td width=33%>Read committed</td>
<td width=19%>--</td>
<td width=29%>X</td>
<td width=19%>X</td>
</tr>
<tr valign=top>
<td width=33%>Repeatable read</td>
<td width=19%>--</td>
<td width=29%>--</td>
<td width=19%>X</td>
</tr>
<tr valign=top>
<td width=33%>Serializable</td>
<td width=19%>--</td>
<td width=29%>--</td>
<td width=19%>--</td>
</tr>
</table><br>
<p>
The following table describes simple ways that a DBMS might implement the transaction isolation levels.</p>
<p class=indent>
<B><b>Important&nbsp;&nbsp;&nbsp;</b></B>Most DBMSs use more complex schemes than these to increase concurrency. These examples are provided for illustrative purposes only. In particular, ODBC does not prescribe how particular DBMSs isolate transactions from each other.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=25%><b>Transaction isolation</b></td>
<td class=label width=75%><b>Possible implementation</b></td>
</tr>
<tr valign=top>
<td width=25%>Read uncommitted</td>
<td width=75%>Transactions are not isolated from each other. If the DBMS supports other transaction isolation levels, it ignores whatever mechanism it uses to implement those levels. So that they do not adversely affect other transactions, transactions running at the Read Uncommitted level are usually read-only.</td>
</tr>
<tr valign=top>
<td width=25%>Read committed</td>
<td width=75%>The transaction waits until rows write-locked by other transactions are unlocked; this prevents it from reading any “dirty” data.<p>
The transaction holds a read lock (if it only reads the row) or write lock (if it updates or deletes the row) on the current row to prevent other transactions from updating or deleting it. The transaction releases read locks when it moves off the current row. It holds write locks until it is committed or rolled back.</p>
</td>
</tr>
<tr valign=top>
<td width=25%><p>
Repeatable read</p>
</td>
<td width=75%>The transaction waits until rows write-locked by other transactions are unlocked; this prevents it from reading any “dirty” data.<p>
The transaction holds read locks on all rows it returns to the application and write locks on all rows it inserts, updates, or deletes. For example, if the transaction includes the SQL statement <b>SELECT * FROM Orders</b>, the transaction read-locks rows as the application fetches them. If the transaction includes the SQL statement <b>DELETE FROM Orders WHERE Status = 'CLOSED'</b>, the transaction write-locks rows as it deletes them.</p>
<p>
Because other transactions cannot update or delete these rows, the current transaction avoids any nonrepeatable reads. The transaction releases its locks when it is committed or rolled back.</p>
</td>
</tr>
<tr valign=top>
<td width=25%>Serializable</td>
<td width=75%>The transaction waits until rows write-locked by other transactions are unlocked; this prevents it from reading any “dirty” data.<p>
The transaction holds a read lock (if it only reads rows) or write lock (if it can update or delete rows) on the range of rows it affects. For example, if the transaction includes the SQL statement <b>SELECT * FROM Orders</b>, the range is the entire Orders table; the transaction read-locks the table and does not allow any new rows to be inserted into it. If the transaction includes the SQL statement <b>DELETE FROM Orders WHERE Status = 'CLOSED'</b>, the range is all rows with a Status of “CLOSED”; the transaction write-locks all rows in the Orders table with a Status of “CLOSED” and does not allow any rows to be inserted or updated such that the resulting row has a Status of “CLOSED”.</p>
<p>
Because other transactions cannot update or delete the rows in the range, the current transaction avoids any nonrepeatable reads. Because other transactions cannot insert any rows in the range, the current transaction avoids any phantoms. The transaction releases its lock when it is committed or rolled back.</p>
</td>
</tr>
</table><br>
<p>
It is important to note that the transaction isolation level does not affect a transaction’s ability to see its own changes; transactions can always see any changes they make. For example, a transaction might consist of two <b>UPDATE</b> statements, the first of which raises the pay of all employees by 10 percent and the second of which sets the pay of any employees over some maximum amount to that amount. This succeeds as a single transaction only because the second <b>UPDATE</b> statement can see the results of the first.</p>
</font></BODY>
</HTML>
