<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SQLFetchScroll</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="odbcsqlfetchscroll"></a>SQLFetchScroll</h1>
<p class=label>
<b>Conformance</b></p>
<p>
Version Introduced:ODBC 3.0<br>
Standards Compliance:ISO 92</p>
<p class=label>
<b>Summary</b></p>
<p>
<b>SQLFetchScroll</b> fetches the specified rowset of data from the result set and returns data for all bound columns. Rowsets can be specified at an absolute or relative position or by bookmark.</p>
<p>
When working with an ODBC 2.<i>x</i> driver, the Driver Manager maps this function to <b>SQLExtendedFetch</b>. For more information, see “<a href="odch17pr_6mpf.htm">Mapping Replacement Functions for Backward Compatibility of Applications</a>” in Chapter 17, “Programming Considerations.”</p>
<p class=label>
<b>Syntax</b></p>
<p>
SQLRETURN <b>SQLFetchScroll</b>(<br>
SQLHSTMT<i>StatementHandle</i>,<br>
SQLSMALLINT<i>FetchOrientation</i>,<br>
SQLINTEGER<i>FetchOffset</i>);</p>
<p class=label>
<b>Arguments</b></p>
<p class=dt>
<i>StatementHandle</i></p>
<p class=indent>
[Input]<br>
Statement handle.</p>
<p class=dt>
<i>FetchOrientation</i></p>
<p class=indent>
[Input]<br>
Type of fetch:</p>
<p class=tl>
SQL_FETCH_NEXT<br>
SQL_FETCH_PRIOR<br>
SQL_FETCH_FIRST<br>
SQL_FETCH_LAST<br>
SQL_FETCH_ABSOLUTE<br>
SQL_FETCH_RELATIVE<br>
SQL_FETCH_BOOKMARK</P><p class=tl>
For more information, see “Positioning the Cursor” in the “Comments” section.</P><p class=dt>
<i>FetchOffset</i></p>
<p class=indent>
[Input]<br>
Number of the row to fetch. The interpretation of this argument depends on the value of the <i>FetchOrientation</i> argument. For more information, see “Positioning the Cursor” in the “Comments” section.</p>
<p class=label>
<b>Returns</b></p>
<p>
SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_NO_DATA, SQL_STILL_EXECUTING, SQL_ERROR, or SQL_INVALID_HANDLE.</p>
<p class=label>
<b>Diagnostics</b></p>
<p>
When <b>SQLFetchScroll</b> returns either SQL_ERROR or SQL_SUCCESS_WITH_INFO, an associated SQLSTATE value can be obtained by calling <b>SQLGetDiagRec</b> with a <i>HandleType</i> of SQL_HANDLE_STMT and a <i>Handle</i> of <i>StatementHandle</i>. The following table lists the SQLSTATE values commonly returned by <b>SQLFetchScroll</b> and explains each one in the context of this function; the notation “(DM)” precedes the descriptions of SQLSTATEs returned by the Driver Manager. The return code associated with each SQLSTATE value is SQL_ERROR, unless noted otherwise. If an error occurs on a single column, <b>SQLGetDiagField</b> can be called with a <i>DiagIdentifier</i> of SQL_DIAG_COLUMN_NUMBER to determine the column the error occurred on; and <b>SQLGetDiagField</b> can be called with a <i>DiagIdentifier</i> of SQL_DIAG_ROW_NUMBER to determine the row containing that column. </p>
<p>
For all those SQLSTATEs that can return SQL_SUCCESS_WITH_INFO or SQL_ERROR (except 01xxx SQLSTATEs), SQL_SUCCESS_WITH_INFO is returned if an error occurs on one or more, but not all, rows of a multirow operation, and SQL_ERROR is returned if an error occurs on a single-row operation.</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=22%><b>SQLSTATE</b></td>
<td class=label width=26%><b>Error</b></td>
<td class=label width=52%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=22%>01000</td>
<td width=26%>General warning</td>
<td width=52%>Driver-specific informational message. (Function returns SQL_SUCCESS_WITH_INFO.)</td>
</tr>
<tr valign=top>
<td width=22%>01004</td>
<td width=26%>String data, right truncated</td>
<td width=52%>String or binary data returned for a column resulted in the truncation of non-blank character or non-NULL binary data. String values are right truncated.</td>
</tr>
<tr valign=top>
<td width=22%>01S01</td>
<td width=26%>Error in row</td>
<td width=52%>An error occurred while fetching one or more rows. <p>
(This SQLSTATE is returned only by ODBC 2<i>.x</i> drivers.)</p>
</td>
</tr>
<tr valign=top>
<td width=22%>01S06</td>
<td width=26%>Attempt to fetch before the result set returned the first rowset</td>
<td width=52%>The requested rowset overlapped the start of the result set when<i> FetchOrientation</i> was SQL_FETCH_PRIOR, the current position was beyond the first row, and the number of the current row is less than or equal to the rowset size.<p>
The requested rowset overlapped the start of the result set when<i> FetchOrientation</i> was SQL_FETCH_PRIOR, the current position was beyond the end of the result set, and the rowset size was greater than the result set size.</p>
<p>
The requested rowset overlapped the start of the result set when<i> FetchOrientation</i> was SQL_FETCH_RELATIVE, <i>FetchOffset</i> was negative, and the absolute value of <i>FetchOffset</i> was less than or equal to the rowset size.</p>
<p>
The requested rowset overlapped the start of the result set when <i>FetchOrientation</i> was SQL_FETCH_ABSOLUTE, <i>FetchOffset</i> was negative, and the absolute value of <i>FetchOffset</i> was greater than the result set size but less than or equal to the rowset size.</p>
<p>
(Function returns SQL_SUCCESS_WITH_INFO.)</p>
</td>
</tr>
<tr valign=top>
<td width=22%>01S07</td>
<td width=26%>Fractional truncation</td>
<td width=52%>The data returned for a column was truncated. For numeric data types, the fractional part of the number was truncated. For time, timestamp, and interval data types containing a time component, the fractional portion of the time was truncated. <p>
(Function returns SQL_SUCCESS_WITH_INFO.)</p>
</td>
</tr>
<tr valign=top>
<td width=22%>07006</td>
<td width=26%>Restricted data type attribute violation</td>
<td width=52%>A data value of a column in the result set could not be converted to the C data type specified by <i>TargetType</i> in <b>SQLBindCol</b>. <p>
Column 0 was bound with a data type of SQL_C_BOOKMARK and the SQL_ATTR_USE_BOOKMARKS statement attribute was set to SQL_UB_VARIABLE. </p>
<p>
Column 0 was bound with a data type of SQL_C_VARBOOKMARK and the SQL_ATTR_USE_BOOKMARKS statement attribute was not set to SQL_UB_VARIABLE.</p>
</td>
</tr>
<tr valign=top>
<td width=22%>07009</td>
<td width=26%>Invalid descriptor index</td>
<td width=52%>Column 0 was bound and the SQL_ATTR_USE_BOOKMARKS statement attribute was set to SQL_UB_OFF.</td>
</tr>
<tr valign=top>
<td width=22%>08S01</td>
<td width=26%>Communication link failure</td>
<td width=52%>The communication link between the driver and the data source to which the driver was connected failed before the function completed processing.</td>
</tr>
<tr valign=top>
<td width=22%>22001</td>
<td width=26%>String data, right truncation</td>
<td width=52%>A variable-length bookmark returned for a row was truncated.</td>
</tr>
<tr valign=top>
<td width=22%>22002</td>
<td width=26%>Indicator variable required but not supplied</td>
<td width=52%>NULL data was fetched into a column whose <i>StrLen_or_IndPtr</i> set by <b>SQLBindCol</b> (or SQL_DESC_INDICATOR_PTR set by <b>SQLSetDescField</b> or <b>SQLSetDescRec</b>) was a null pointer. </td>
</tr>
<tr valign=top>
<td width=22%>22003</td>
<td width=26%>Numeric value out of range</td>
<td width=52%>Returning the numeric value (as numeric or string) for one or more bound columns would have caused the whole (as opposed to fractional) part of the number to be truncated.<p>
For more information, see Appendix D, “<a href="odappdpr_8kab.htm">Data Types</a>.”</p>
</td>
</tr>
<tr valign=top>
<td width=22%>22007</td>
<td width=26%>Invalid datetime format</td>
<td width=52%>A character column in the result set was bound to a date, time, or timestamp C structure, and a value in the column was, respectively, an invalid date, time, or timestamp. </td>
</tr>
<tr valign=top>
<td width=22%>22012</td>
<td width=26%>Division by zero</td>
<td width=52%>A value from an arithmetic expression was returned, which resulted in division by zero. </td>
</tr>
<tr valign=top>
<td width=22%>22015</td>
<td width=26%>Interval field overflow</td>
<td width=52%>Assigning from an exact numeric or interval SQL type to an interval C type caused a loss of significant digits in the leading field.<p>
When fetching data to an interval C type, there was no representation of the value of the SQL type in the interval C type. </p>
</td>
</tr>
<tr valign=top>
<td width=22%>22018</td>
<td width=26%>Invalid character value for cast specification</td>
<td width=52%>A character column in the result set was bound to a character C buffer and the column contained a character for which there was no representation in the character set of the buffer.<p>
The C type was an exact or approximate numeric, a datetime, or an interval data type; the SQL type of the column was a character data type; and the value in the column was not a valid literal of the bound C type.</p>
</td>
</tr>
<tr valign=top>
<td width=22%>24000</td>
<td width=26%>Invalid cursor state</td>
<td width=52%>The <i>StatementHandle</i> was in an executed state but no result set was associated with the <i>StatementHandle</i>.</td>
</tr>
<tr valign=top>
<td width=22%>40001</td>
<td width=26%>Serialization failure</td>
<td width=52%>The transaction in which the fetch was executed was terminated to prevent deadlock.</td>
</tr>
<tr valign=top>
<td width=22%>40003</td>
<td width=26%>Statement completion unknown</td>
<td width=52%>The associated connection failed during the execution of this function and the state of the transaction cannot be determined.</td>
</tr>
<tr valign=top>
<td width=22%>HY000</td>
<td width=26%>General error</td>
<td width=52%>An error occurred for which there was no specific SQLSTATE and for which no implementation-specific SQLSTATE was defined. The error message returned by <b>SQLGetDiagRec</b> in the <i>*MessageText</i> buffer describes the error and its cause. </td>
</tr>
<tr valign=top>
<td width=22%>HY001</td>
<td width=26%>Memory allocation <br>
error</td>
<td width=52%>The driver was unable to allocate memory required to support execution or completion of the function.</td>
</tr>
<tr valign=top>
<td width=22%>HY008</td>
<td width=26%>Operation canceled</td>
<td width=52%>Asynchronous processing was enabled for the <i>StatementHandle</i>. The function was called and, before it completed execution, <b>SQLCancel</b> was called on the <i>StatementHandle</i>. Then the function was called again on the <i>StatementHandle</i>.<p>
The function was called and, before it completed execution, <b>SQLCancel</b> was called on the <i>StatementHandle</i> from a different thread in a multithread application.</p>
</td>
</tr>
<tr valign=top>
<td width=22%>HY010</td>
<td width=26%>Function sequence error</td>
<td width=52%>(DM) The specified <i>StatementHandle</i> was not in an executed state. The function was called without first calling <b>SQLExecDirect</b>, <b>SQLExecute</b>, or a catalog function.<p>
(DM) An asynchronously executing function (not this one) was called for the <i>StatementHandle</i> and was still executing when this function was called.</p>
<p>
(DM) <b>SQLExecute</b>, <b>SQLExecDirect</b>, <b>SQLBulkOperations</b>, or <b>SQLSetPos</b> was called for the <i>StatementHandle</i> and returned SQL_NEED_DATA. This function was called before data was sent for all data-at-execution parameters or columns.</p>
<p>
(DM) <b>SQLFetchScroll</b> was called for a <i>StatementHandle</i> after <b>SQLExtendedFetch</b> was called and before <b>SQLFreeStmt</b> with SQL_CLOSE was called.</p>
</td>
</tr>
<tr valign=top>
<td width=22%>HY013</td>
<td width=26%>Memory management error</td>
<td width=52%>The function call could not be processed because the underlying memory objects could not be accessed, possibly because of low memory conditions.</td>
</tr>
<tr valign=top>
<td width=22%>HY090</td>
<td width=26%>Invalid string or buffer length</td>
<td width=52%>The SQL_ATTR_USE_BOOKMARK statement attribute was set to SQL_UB_VARIABLE, and column 0 was bound to a buffer whose length was not equal to the maximum length for the bookmark for this result set. (This length is available in the SQL_DESC_OCTET_LENGTH field of the IRD, and can be obtained by calling <b>SQLDescribeCol</b>, <b>SQLColAttribute</b>, or <b>SQLGetDescField</b>.)</td>
</tr>
<tr valign=top>
<td width=22%>HY106</td>
<td width=26%>Fetch type out of range</td>
<td width=52%>(DM) The value specified for the argument <i>FetchOrientation</i> was invalid.<p>
(DM) The argument <i>FetchOrientation</i> was SQL_FETCH_BOOKMARK, and the SQL_ATTR_USE_BOOKMARKS statement attribute was set to SQL_UB_OFF.</p>
<p>
The value of the SQL_ATTR_CURSOR_TYPE statement attribute was SQL_CURSOR_FORWARD_ONLY and the value of argument <i>FetchOrientation</i> was not SQL_FETCH_NEXT. </p>
<p>
The value of the SQL_ATTR_CURSOR_SCROLLABLE statement attribute was SQL_NONSCROLLABLE and the value of argument <i>FetchOrientation</i> was not SQL_FETCH_NEXT.</p>
</td>
</tr>
<tr valign=top>
<td width=22%>HY107</td>
<td width=26%>Row value out of range</td>
<td width=52%>The value specified with the SQL_ATTR_CURSOR_TYPE statement attribute was SQL_CURSOR_KEYSET_DRIVEN, but the value specified with the SQL_ATTR_KEYSET_SIZE statement attribute was greater than 0 and less than the value specified with the SQL_ATTR_ROW_ARRAY_SIZE statement attribute.</td>
</tr>
<tr valign=top>
<td width=22%>HY111</td>
<td width=26%>Invalid bookmark value</td>
<td width=52%>The argument <i>FetchOrientation</i> was SQL_FETCH_BOOKMARK and the bookmark pointed to by the value in the SQL_ATTR_FETCH_BOOKMARK_PTR statement attribute was not valid or was a null pointer.</td>
</tr>
<tr valign=top>
<td width=22%>HYC00</td>
<td width=26%>Optional feature not implemented</td>
<td width=52%>Driver or data source does not support the specified fetch type.<p>
The driver or data source does not support the conversion specified by the combination of the <i>TargetType</i> in <b>SQLBindCol</b> and the SQL data type of the corresponding column.</p>
<p>
<i>FetchOrientation</i> was SQL_FETCH_BOOKMARK, <i>FetchOffset</i> was not equal to 0, and the underlying driver is an ODBC 2.<i>x</i> driver.</p>
</td>
</tr>
<tr valign=top>
<td width=22%>HYT01</td>
<td width=26%>Connection timeout expired</td>
<td width=52%>The connection timeout period expired before the data source responded to the request. The connection timeout period is set through <b>SQLSetConnectAttr</b>, SQL_ATTR_CONNECTION_TIMEOUT.</td>
</tr>
<tr valign=top>
<td width=22%>IM001</td>
<td width=26%>Driver does not support this function</td>
<td width=52%>(DM) The driver associated with the <i>StatementHandle</i> does not support the function.</td>
</tr>
</table><br>
<p class=label>
<b>Comments</b></p>
<p>
<b>SQLFetchScroll</b> returns a specified rowset from the result set. Rowsets can be specified by absolute or relative position or by bookmark. <b>SQLFetchScroll</b> can be called only while a result set exists — that is, after a call that creates a result set and before the cursor over that result set is closed. If any columns are bound, it returns the data in those columns. If the application has specified a pointer to a row status array or a buffer in which to return the number of rows fetched, <b>SQLFetchScroll</b> returns this information as well. Calls to <b>SQLFetchScroll</b> can be mixed with calls to <b>SQLFetch</b> but cannot be mixed with calls to <b>SQLExtendedFetch</b>.</p>
<p>
For more information, see “<a href="odch11pr_9x0z.htm">Using Block Cursors</a>” and “<a href="odch11pr_2rxw.htm">Using Scrollable Cursors</a>” in Chapter 11, “Retrieving Results (Advanced).”</p>
<h1>Positioning the Cursor</h1>
<p>
When the result set is created, the cursor is positioned before the start of the result set. <b>SQLFetchScroll</b> positions the block cursor based on the values of the <i>FetchOrientation</i> and <i>FetchOffset</i> arguments as shown in the following table. The exact rules for determining the start of the new rowset are shown in the next section.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=34%><b><i>FetchOrientation</i></b></td>
<td class=label width=66%><b>Meaning</b></td>
</tr>
<tr valign=top>
<td width=34%>SQL_FETCH_NEXT</td>
<td width=66%>Return the next rowset. This is equivalent to calling <b>SQLFetch</b>.<p>
<b>SQLFetchScroll</b> ignores the value of <i>FetchOffset</i>.</p>
</td>
</tr>
<tr valign=top>
<td width=34%>SQL_FETCH_PRIOR</td>
<td width=66%>Return the prior rowset.<p>
<b>SQLFetchScroll</b> ignores the value of <i>FetchOffset</i>.</p>
</td>
</tr>
<tr valign=top>
<td width=34%>SQL_FETCH_RELATIVE</td>
<td width=66%>Return the rowset <i>FetchOffset</i> from the start of the current rowset. </td>
</tr>
<tr valign=top>
<td width=34%>SQL_FETCH_ABSOLUTE</td>
<td width=66%>Return the rowset starting at row <i>FetchOffset</i>. </td>
</tr>
<tr valign=top>
<td width=34%>SQL_FETCH_FIRST</td>
<td width=66%>Return the first rowset in the result set.<p>
<b>SQLFetchScroll</b> ignores the value of <i>FetchOffset</i>.</p>
</td>
</tr>
<tr valign=top>
<td width=34%>SQL_FETCH_LAST</td>
<td width=66%>Return the last complete rowset in the result set.<p>
<b>SQLFetchScroll</b> ignores the value of <i>FetchOffset</i>.</p>
</td>
</tr>
<tr valign=top>
<td width=34%>SQL_FETCH_BOOKMARK</td>
<td width=66%>Return the rowset <i>FetchOffset</i> rows from the bookmark specified by the SQL_ATTR_FETCH_BOOKMARK_PTR statement attribute.</td>
</tr>
</table><br>
<p>
Drivers are not required to support all fetch orientations; an application calls <b>SQLGetInfo</b> with an information type of SQL_DYNAMIC_CURSOR_ATTRIBUTES1, SQL_KEYSET_CURSOR_ATTRIBUTES1, or SQL_STATIC_CURSOR_ATTRIBUTES1 (depending on the type of the cursor) to determine which fetch orientations are supported by the driver. The application should look at the SQL_CA1_NEXT, SQL_CA1_RELATIVE, SQL_CA1_ABSOLUTE, and WQL_CA1_BOOKMARK bitmasks in these information types. Furthermore, if the cursor is forward-only and <i>FetchOrientation</i> is not SQL_FETCH_NEXT, <b>SQLFetchScroll</b> returns SQLSTATE HY106 (Fetch type out of range).</p>
<p>
The SQL_ATTR_ROW_ARRAY_SIZE statement attribute specifies the number of rows in the rowset. If the rowset being fetched by <b>SQLFetchScroll</b> overlaps the end of the result set, <b>SQLFetchScroll</b> returns a partial rowset. That is, if S + R&nbsp;–&nbsp;1 is greater than L, where S is the starting row of the rowset being fetched, R is the rowset size, and L is the last row in the result set, then only the first L&nbsp;–&nbsp;S+1 rows of the rowset are valid. The remaining rows are empty and have a status of SQL_ROW_NOROW.</p>
<p>
After <b>SQLFetchScroll</b> returns, the current row is the first row of the rowset.</p>
<h1>Cursor Positioning Rules</h1>
<p>
The following sections describe the exact rules for each value of <i>FetchOrientation</i>. These rules use the following notation.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=26%><b>Notation</b></td>
<td class=label width=74%><b>Meaning</b></td>
</tr>
<tr valign=top>
<td width=26%><i>Before start</i></td>
<td width=74%>The block cursor is positioned before the start of the result set. If the first row of the new rowset is before the start of the result set, <b>SQLFetchScroll</b> returns SQL_NO_DATA.</td>
</tr>
<tr valign=top>
<td width=26%><i>After end</i></td>
<td width=74%>The block cursor is positioned after the end of the result set. If the first row of the new rowset is after the end of the result set, <b>SQLFetchScroll</b> returns SQL_NO_DATA.</td>
</tr>
<tr valign=top>
<td width=26%><i>CurrRowsetStart</i></td>
<td width=74%>The number of the first row in the current rowset.</td>
</tr>
<tr valign=top>
<td width=26%><i>LastResultRow</i></td>
<td width=74%>The number of the last row in the result set.</td>
</tr>
<tr valign=top>
<td width=26%><i>RowsetSize</i></td>
<td width=74%>The rowset size.</td>
</tr>
<tr valign=top>
<td width=26%><i>FetchOffset</i></td>
<td width=74%>The value of the <i>FetchOffset</i> argument.</td>
</tr>
<tr valign=top>
<td width=26%><i>BookmarkRow</i></td>
<td width=74%>The row corresponding to the bookmark specified by the SQL_ATTR_FETCH_BOOKMARK_PTR statement attribute.</td>
</tr>
</table><br>
<h1><B>SQL_FETCH_NEXT</B></h1>
<p>
The following rules apply.</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=58%><b>Condition</b></td>
<td class=label colspan=2 width=42%><b>First row of new rowset</b></td>
</tr>
<tr valign=top>
<td width=58%><i>Before start</i></td>
<td colspan=2 width=42%>1</td>
</tr>
<tr valign=top>
<td width=58%><i>CurrRowsetStart</i> + <i>RowsetSize </i><sup>1</sup> &lt;= <i>LastResultRow</i></td>
<td colspan=2 width=42%><i>CurrRowsetStart</i> + <i>RowsetSize </i><sup>1</sup></td>
</tr>
<tr valign=top>
<td width=58%><i>CurrRowsetStart</i> + <i>RowsetSize </i><sup>1</sup> &gt; <i>LastResultRow</i></td>
<td colspan=2 width=42%><i>After end</i></td>
</tr>
<tr valign=top>
<td width=58%><i>After end</i></td>
<td colspan=2 width=42%><i>After end</i></td>
</tr>
<tr valign=top>
<td colspan=2 width=81%></td>
</tr>
<tr valign=top>
<td class=mini colspan=2 width=81%><sup>1</sup>If the rowset size has been changed since the previous call to fetch rows, this is the rowset size that was used with the previous call.</td>
</tr>
</table><br>
<h1><B>SQL_FETCH_PRIOR</B></h1>
<p>
The following rules apply.</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=58%><b>Condition</b></td>
<td class=label colspan=2 width=42%><b>First row of new rowset</b></td>
</tr>
<tr valign=top>
<td width=58%><i>Before start</i></td>
<td colspan=2 width=42%><i>Before start</i></td>
</tr>
<tr valign=top>
<td width=58%><i>CurrRowsetStart</i> = 1</td>
<td colspan=2 width=42%><i>Before start</i></td>
</tr>
<tr valign=top>
<td width=58%>1 &lt; <i>CurrRowsetStart</i> &lt;= <i>RowsetSize</i> <sup>2</sup></td>
<td colspan=2 width=42%>1 <sup>1</sup></td>
</tr>
<tr valign=top>
<td width=58%><i>CurrRowsetStart</i> &gt; <i>RowsetSize</i> <sup>2</sup></td>
<td colspan=2 width=42%><i>CurrRowsetStart</i> – <i>RowsetSize</i> <sup>2</sup></td>
</tr>
<tr valign=top>
<td width=58%><i>After</i> <i>end</i> AND <i>LastResultRow</i> &lt; <i>RowsetSize</i> <sup>2</sup></td>
<td colspan=2 width=42%>1 <sup>1</sup></td>
</tr>
<tr valign=top>
<td width=58%><i>After</i> <i>end</i> AND <i>LastResultRow</i> &gt;= <i>RowsetSize</i> <sup>2</sup></td>
<td colspan=2 width=42%><i>LastResultRow</i> – <i>RowsetSize</i> + 1 <sup>2</sup> </td>
</tr>
<tr valign=top>
<td class=mini colspan=2 width=81%><sup>1</sup><b>SQLFetchScroll</b> returns SQLSTATE 01S06 (Attempt to fetch before the result set returned the first rowset) and SQL_SUCCESS_WITH_INFO.<p class=mini>
<sup>2</sup>If the rowset size has been changed since the previous call to fetch rows, this is the new rowset size.</p>
</td>
</tr>
</table><br>
<h1><B>SQL_FETCH_RELATIVE</B></h1>
<p>
The following rules apply.</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=58%><b>Condition</b></td>
<td class=label colspan=2 width=42%><b>First row of new rowset</b></td>
</tr>
<tr valign=top>
<td width=58%><i>(Before</i> <i>start</i> AND <i>FetchOffset</i> &gt; 0) OR<br>
(<i>After</i> <i>end AND FetchOffset </i>&lt;<i> 0)</i></td>
<td colspan=2 width=42%>-- <sup>1</sup></td>
</tr>
<tr valign=top>
<td width=58%><i>BeforeStart </i>AND <i>FetchOffset</i> &lt;= 0</td>
<td colspan=2 width=42%><i>Before</i> <i>start</i></td>
</tr>
<tr valign=top>
<td width=58%><i>CurrRowsetStart</i> = 1 AND <i>FetchOffset</i> &lt; <i>0</i></td>
<td colspan=2 width=42%><i>Before</i> <i>start</i></td>
</tr>
<tr valign=top>
<td width=58%><i>CurrRowsetStart</i> &gt; 1 AND<i> CurrRowsetStart</i> + <i>FetchOffset</i> &lt; 1 AND<br>
| <i>FetchOffset</i> | &gt; <i>RowsetSize</i> <sup>3</sup></td>
<td colspan=2 width=42%><i>Before</i> <i>start</i></td>
</tr>
<tr valign=top>
<td width=58%><i>CurrRowsetStart</i> &gt; 1 AND<i> CurrRowsetStart</i> + <i>FetchOffset</i> &lt; 1 AND<br>
| <i>FetchOffset</i> | &lt;= <i>RowsetSize</i> <sup>3</sup></td>
<td colspan=2 width=42%>1 <sup>2</sup></td>
</tr>
<tr valign=top>
<td width=58%>1 &lt;= <i>CurrRowsetStart</i> + <i>FetchOffset</i> &lt;= <i>LastResultRow</i></td>
<td colspan=2 width=42%><i>CurrRowsetStart</i> + <i>FetchOffset</i></td>
</tr>
<tr valign=top>
<td width=58%><i>CurrRowsetStart</i> + <i>FetchOffset</i> &gt; <i>LastResultRow</i></td>
<td colspan=2 width=42%><i>After</i> <i>end</i></td>
</tr>
<tr valign=top>
<td width=58%><i>After</i> <i>end AND FetchOffset </i>&gt;=<i> 0</i></td>
<td colspan=2 width=42%><i>After</i> <i>end</i></td>
</tr>
<tr valign=top>
<td class=mini colspan=2 width=81%><sup>1</sup><b>SQLFetchScroll</b> returns the same rowset as if it was called with <i>FetchOrientation</i> set to SQL_FETCH_ABSOLUTE. For more information, see the “SQL_FETCH_ABSOLUTE” section.<p class=mini>
<sup>2</sup><b>SQLFetchScroll</b> returns SQLSTATE 01S06 (Attempt to fetch before the result set returned the first rowset) and SQL_SUCCESS_WITH_INFO. </p>
<p class=mini>
<sup>3</sup>If the rowset size has been changed since the previous call to fetch rows, this is the new rowset size.</p>
</td>
</tr>
</table><br>
<h1><B>SQL_FETCH_ABSOLUTE</B></h1>
<p>
The following rules apply.</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=58%><b>Condition</b></td>
<td class=label colspan=2 width=42%><b>First row of new rowset</b></td>
</tr>
<tr valign=top>
<td width=58%><i>FetchOffset</i> &lt; 0 AND<br>
| <i>FetchOffset</i> | &lt;= <i>LastResultRow</i></td>
<td colspan=2 width=42%><i>LastResultRow</i> + <i>FetchOffset</i> + 1</td>
</tr>
<tr valign=top>
<td width=58%><i>FetchOffset</i> &lt; 0 AND<br>
| <i>FetchOffset</i> | &gt; <i>LastResultRow</i> AND<br>
| <i>FetchOffset</i> | &gt; <i>RowsetSize</i> <sup>2</sup></td>
<td colspan=2 width=42%><i>Before</i> <i>start</i></td>
</tr>
<tr valign=top>
<td width=58%><i>FetchOffset</i> &lt; 0 AND<br>
| <i>FetchOffset</i> | &gt; <i>LastResultRow</i> AND<br>
| <i>FetchOffset</i> | &lt;= <i>RowsetSize</i> <sup>2</sup></td>
<td colspan=2 width=42%>1 <sup>1</sup></td>
</tr>
<tr valign=top>
<td width=58%><i>FetchOffset</i> = 0</td>
<td colspan=2 width=42%><i>Before</i> <i>start</i></td>
</tr>
<tr valign=top>
<td width=58%>1 &lt;= <i>FetchOffset</i> &lt;= <i>LastResultRow</i></td>
<td colspan=2 width=42%><i>FetchOffset</i></td>
</tr>
<tr valign=top>
<td width=58%><i>FetchOffset</i> &gt; <i>LastResultRow</i></td>
<td colspan=2 width=42%><i>After</i> <i>end</i></td>
</tr>
<tr valign=top>
<td class=mini colspan=2 width=81%><sup>1</sup><b>SQLFetchScroll</b> returns SQLSTATE 01S06 (Attempt to fetch before the result set returned the first rowset) and SQL_SUCCESS_WITH_INFO. <p class=mini>
<sup>2</sup>If the rowset size has been changed since the previous call to fetch rows, this is the new rowset size.</p>
</td>
</tr>
</table><br>
<p>
An absolute fetch performed against a dynamic cursor cannot provide the required result because row positions in a dynamic cursor are undetermined. Such an operation is equivalent to a fetch first followed by a fetch relative; it is not an atomic operation, as is an absolute fetch on a static cursor.</p>
<h1><B>SQL_FETCH_FIRST</B></h1>
<p>
The following rules apply.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=58%><b>Condition</b></td>
<td class=label width=42%><b>First row of new rowset</b></td>
</tr>
<tr valign=top>
<td width=58%>Any</td>
<td width=42%>1</td>
</tr>
</table><br>
<h1><B>SQL_FETCH_LAST</B></h1>
<p>
The following rules apply.</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=58%><b>Condition</b></td>
<td class=label colspan=2 width=42%><b>First row of new rowset</b></td>
</tr>
<tr valign=top>
<td width=58%><i>RowsetSize</i> <sup>1</sup> &lt;= <i>LastResultRow</i></td>
<td colspan=2 width=42%><i>LastResultRow</i> – <i>RowsetSize</i> + 1 <sup>1</sup> </td>
</tr>
<tr valign=top>
<td width=58%><i>RowsetSize</i> <sup>1</sup> &gt; <i>LastResultRow</i></td>
<td colspan=2 width=42%>1</td>
</tr>
<tr valign=top>
<td class=mini colspan=2 width=81%><sup>1</sup>If the rowset size has been changed since the previous call to fetch rows, this is the new rowset size.</td>
</tr>
</table><br>
<h1><B>SQL_FETCH_BOOKMARK</B></h1>
<p>
The following rules apply.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=58%><b>Condition</b></td>
<td class=label width=42%><b>First row of new rowset</b></td>
</tr>
<tr valign=top>
<td width=58%><i>BookmarkRow</i> + <i>FetchOffset</i> &lt; 1</td>
<td width=42%><i>Before</i> <i>start</i></td>
</tr>
<tr valign=top>
<td width=58%>1 &lt;= <i>BookmarkRow</i> + <i>FetchOffset</i> &lt;= <i>LastResultRow</i></td>
<td width=42%><i>BookmarkRow</i> + <i>FetchOffset</i></td>
</tr>
<tr valign=top>
<td width=58%><i>BookmarkRow</i> + <i>FetchOffset</i> &gt; <i>LastResultRow</i></td>
<td width=42%><i>After</i> <i>end</i></td>
</tr>
</table><br>
<p>
For information about bookmarks, see the “<a href="odch11pr_846r.htm">Bookmarks</a>” section in Chapter 11, “Retrieving Results (Advanced).”</p>
<h1>Effect of Deleted, Added, and Error Rows on Cursor Movement</h1>
<p>
Static and keyset-driven cursors sometimes detect rows added to the result set and remove rows deleted from the result set. An application determines whether the cursors implemented by a particular driver do this by calling <b>SQLGetInfo</b> with the SQL_STATIC_CURSOR_ATTRIBUTES2 and SQL_KEYSET_CURSOR_ATTRIBUTES2 options, and looking at the SQL_CA2_SENSITIVITY_ADDITIONS, SQL_CA2_SENSITIVITY_DELETIONS, and SQL_CA2_SENSITIVITY_UPDATES bitmasks. For drivers that can detect deleted rows and remove them, the following paragraphs describe the effects of this behavior. For drivers that can detect deleted rows but cannot remove them, deletions have no effect on cursor movements, and the following paragraphs do not apply.</p>
<p>
If the cursor detects rows added to the result set or removes rows deleted from the result set, it appears as if it detects these changes only when it fetches data. This includes the case when <b>SQLFetchScroll</b> is called with <i>FetchOrientation</i> set to SQL_FETCH_RELATIVE and <i>FetchOffset</i> set to 0 to refetch the same rowset, but does not include the case when <b>SQLSetPos</b> is called with <i>fOption</i> set to SQL_REFRESH. In the latter case, the data in the rowset buffers is refreshed, but not refetched, and deleted rows are not removed from the result set. Thus, when a row is deleted from or inserted into the current rowset, the cursor does not modify the rowset buffers. Instead, it detects the change when it fetches any rowset that previously included the deleted row or now includes the inserted row.</p>
<p>
For example:</p>
<pre><code>// Fetch the next rowset.
SQLFetchScroll(hstmt, SQL_FETCH_NEXT, 0);

// Delete third row of the rowset. Does not modify the rowset buffers.
SQLSetPos(hstmt, 3, SQL_DELETE, SQL_LOCK_NO_CHANGE);

// The third row has a status of SQL_ROW_DELETED after this call.
SQLSetPos(hstmt, 3, SQL_REFRESH, SQL_LOCK_NO_CHANGE);

// Refetch the same rowset. The third row is removed, replaced by what
// was previously the fourth row.
SQLFetchScroll(hstmt, SQL_FETCH_RELATIVE, 0);
</code></pre>
<p>
When <b>SQLFetchScroll</b> returns a new rowset that has a position relative to the current rowset — that is, <i>FetchOrientation</i> is SQL_FETCH_NEXT, SQL_FETCH_PRIOR, or SQL_FETCH_RELATIVE — it does not include changes to the current rowset when calculating the starting position of the new rowset. However, it does include changes outside the current rowset if it is capable of detecting them. Furthermore, when <b>SQLFetchScroll</b> returns a new rowset that has a position independent of the current rowset — that is, <i>FetchOrientation</i> is SQL_FETCH_FIRST, SQL_FETCH_LAST, SQL_FETCH_ABSOLUTE, or SQL_FETCH_BOOKMARK — it includes all changes it is capable of detecting, even if they are in the current rowset.</p>
<p>
When determining whether newly added rows are inside or outside the current rowset, a partial rowset is considered to end at the last valid row; that is, the last row for which the row status is not SQL_ROW_NOROW. For example, suppose the cursor is capable of detecting newly added rows, the current rowset is a partial rowset, the application adds new rows, and the cursor adds these rows to the end of the result set. If the application calls <b>SQLFetchScroll</b> with <i>FetchOrientation</i> set to SQL_FETCH_NEXT, <b>SQLFetchScroll</b> returns the rowset starting with the first newly added row.</p>
<p>
For example, suppose the current rowset comprises rows 21 to 30, the rowset size is 10, the cursor removes rows deleted from the result set, and the cursor detects rows added to the result set. The following table shows the rows <b>SQLFetchScroll</b> returns in various situations.</p>
<table border=1 cellpadding=5 cols=5 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=37%><b>Change</b></td>
<td class=label width=17%><b>Fetch type</b></td>
<td class=label width=17%><b>FetchOffset</b></td>
<td class=label colspan=2 width=29%><b>New rowset <sup>1</sup></b></td>
</tr>
<tr valign=top>
<td width=37%>Delete row 21</td>
<td width=17%>NEXT</td>
<td width=17%>0</td>
<td colspan=2 width=29%>31 to 40</td>
</tr>
<tr valign=top>
<td width=37%>Delete row 31</td>
<td width=17%>NEXT</td>
<td width=17%>0</td>
<td colspan=2 width=29%>32 to 41</td>
</tr>
<tr valign=top>
<td width=37%>Insert row between rows 21 and 22</td>
<td width=17%>NEXT</td>
<td width=17%>0</td>
<td colspan=2 width=29%>31 to 40</td>
</tr>
<tr valign=top>
<td width=37%>Insert row between rows 30 and 31</td>
<td width=17%>NEXT</td>
<td width=17%>0</td>
<td colspan=2 width=29%>Inserted row, 31 to 39</td>
</tr>
<tr valign=top>
<td width=37%>Delete row 21</td>
<td width=17%>PRIOR</td>
<td width=17%>0</td>
<td colspan=2 width=29%>11 to 20</td>
</tr>
<tr valign=top>
<td width=37%>Delete row 20</td>
<td width=17%>PRIOR</td>
<td width=17%>0</td>
<td colspan=2 width=29%>10 to 19</td>
</tr>
<tr valign=top>
<td width=37%>Insert row between rows 21 and 22</td>
<td width=17%>PRIOR</td>
<td width=17%>0</td>
<td colspan=2 width=29%>11 to 20</td>
</tr>
<tr valign=top>
<td width=37%>Insert row between rows 20 and 21</td>
<td width=17%>PRIOR</td>
<td width=17%>0</td>
<td colspan=2 width=29%>12 to 20, inserted row</td>
</tr>
<tr valign=top>
<td width=37%>Delete row 21</td>
<td width=17%>RELATIVE</td>
<td width=17%>0</td>
<td colspan=2 width=29%>22 to 31 <sup>2</sup></td>
</tr>
<tr valign=top>
<td width=37%>Delete row 21</td>
<td width=17%>RELATIVE</td>
<td width=17%>1</td>
<td colspan=2 width=29%>22 to 31</td>
</tr>
<tr valign=top>
<td width=37%>Insert row between rows 21 and 22</td>
<td width=17%>RELATIVE</td>
<td width=17%>0</td>
<td colspan=2 width=29%>21, inserted row, 22 to 29</td>
</tr>
<tr valign=top>
<td width=37%>Insert row between rows 21 and 22</td>
<td width=17%>RELATIVE</td>
<td width=17%>1</td>
<td colspan=2 width=29%>22 to 31</td>
</tr>
<tr valign=top>
<td width=37%>Delete row 21</td>
<td width=17%>ABSOLUTE</td>
<td width=17%>21</td>
<td colspan=2 width=29%>22 to 31 <sup>2</sup></td>
</tr>
<tr valign=top>
<td width=37%>Delete row 22</td>
<td width=17%>ABSOLUTE</td>
<td width=17%>21</td>
<td colspan=2 width=29%>21, 23 to 31</td>
</tr>
<tr valign=top>
<td width=37%>Insert row between rows 21 and 22</td>
<td width=17%>ABSOLUTE</td>
<td width=17%>22</td>
<td colspan=2 width=29%>Inserted row, 22 to 29</td>
</tr>
<tr valign=top>
<td class=mini colspan=4 width=81%><sup>1</sup>This column uses the row numbers before any rows were inserted or deleted.<p class=mini>
<sup>2</sup>In this case, the cursor attempts to return rows starting with row 21. Because row 21 has been deleted, the first row it returns is row 22.</p>
</td>
</tr>
</table><br>
<p>
Error rows (that is, rows with a status of SQL_ROW_ERROR) do not affect cursor movement. For example, if the current rowset starts with row 11 and the status of row 11 is SQL_ROW_ERROR, calling <b>SQLFetchScroll</b> with <i>FetchOrientation</i> set to SQL_FETCH_RELATIVE and <i>FetchOffset</i> set to 5 returns the rowset starting with row 16, just as it would if the status for row 11 was SQL_SUCCESS.</p>
<h1>Returning Data in Bound Columns</h1>
<p>
<b>SQLFetchScroll</b> returns data in bound columns in the same way as <b>SQLFetch</b>. For more information, see “Returning Data in Bound Columns” in <a href="odch21epr_4zoo.htm">SQLFetch</a>.</p>
<p>
If no columns are bound, <b>SQLFetchScroll</b> does not return data but does move the block cursor to the specified position. Whether data can be retrieved from unbound columns of a block cursor with <b>SQLGetData</b> depends on the driver. This capability is supported if a call to <b>SQLGetInfo</b> returns the SQL_GD_BLOCK bit for the SQL_GETDATA_EXTENSIONS information type.</p>
<h1>Buffer Addresses</h1>
<p>
<b>SQLFetchScroll</b> uses the same formula to determine the address of data and length/indicator buffers as <b>SQLFetch</b>. For more information, see “Buffer Addresses” in <a href="odch21bpr_0ht8.htm">SQLBindCol</a>.</p>
<h1>Row Status Array</h1>
<p>
<b>SQLFetchScroll</b> sets values in the row status array in the same manner as <b>SQLFetch</b>. For more information, see “Row Status Array” in <a href="odch21epr_4zoo.htm">SQLFetch</a>.</p>
<h1>Rows Fetched Buffer</h1>
<p>
<b>SQLFetchScroll</b> returns the number of rows fetched in the rows fetched buffer in the same manner as <b>SQLFetch</b>. For more information, see “Rows Fetched Buffer” in <a href="odch21epr_4zoo.htm">SQLFetch</a>.</p>
<h1>Error Handling</h1>
<p>
When an application calls <b>SQLFetchScroll</b> in an ODBC 3.x driver, the Driver Manager calls <b>SQLFetchScroll</b> in the driver. When an application calls <b>SQLFetchScroll</b> in an ODBC 2<i>.x</i> driver, the Driver Manager calls <b>SQLExtendedFetch</b> in the driver. Because <b>SQLFetchScroll</b> and <b>SQLExtendedFetch</b> handle errors in a slightly different manner, the application sees slightly different error behavior when it calls <b>SQLFetchScroll</b> in ODBC 2<i>.x</i> and ODBC 3.x drivers.</p>
<p>
<b>SQLFetchScroll</b> returns errors and warnings in the same manner as <b>SQLFetch</b>; for more information, see “Error Handling” in <a href="odch21epr_4zoo.htm">SQLFetch</a>. <b>SQLExtendedFetch</b> returns errors in the same manner as <b>SQLFetch</b> with the following exceptions:
<ul type=disc>
<li>
When a warning occurs that applies to a particular row in the rowset, <b>SQLExtendedFetch </b>sets the corresponding entry in the row status array to SQL_ROW_SUCCESS, not SQL_ROW_SUCCESS_WITH_INFO.<br><br></li>
<li>
If errors occur in every row in the rowset, <b>SQLExtendedFetch</b> returns SQL_SUCCESS_WITH_INFO, not SQL_ERROR.<br><br></li>
<li>
In each group of status records that applies to an individual row, the first status record returned by <b>SQLExtendedFetch</b> must contain SQLSTATE 01S01 (Error in row); <b>SQLFetchScroll</b> does not return this SQLSTATE. Note that if <b>SQLExtendedFetch</b> is unable to return additional SQLSTATEs, it still must return this SQLSTATE.</li>
</ul>
<h1>SQLFetchScroll and Optimistic Concurrency</h1>
<p>
If a cursor uses optimistic concurrency — that is, the SQL_ATTR_CONCURRENCY statement attribute has a value of SQL_CONCUR_VALUES or SQL_CONCUR_ROWVER — <b>SQLFetchScroll</b> updates the optimistic concurrency values used by the data source to detect whether a row has changed. This happens whenever <b>SQLFetchScroll</b> fetches a new rowset, including when it refetches the current rowset (it is called with <i>FetchOrientation</i> set to SQL_FETCH_RELATIVE and <i>FetchOffset</i> set to 0).</p>
<h1>SQLFetchScroll and ODBC 2<i>.x</i> Drivers</h1>
<p>
When an application calls <b>SQLFetchScroll</b> in an ODBC 2<i>.x</i> driver, the Driver Manager maps this call to <b>SQLExtendedFetch</b>. It passes the following values for the arguments of <b>SQLExtendedFetch</b>.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=29%><b>SQLExtendedFetch<br>
Argument</b></td>
<td class=label width=71%><b><br>
Value</b></td>
</tr>
<tr valign=top>
<td width=29%><i>StatementHandle</i></td>
<td width=71%><i>StatementHandle</i> in <b>SQLFetchScroll</b>.</td>
</tr>
<tr valign=top>
<td width=29%><i>FetchOrientation</i></td>
<td width=71%><i>FetchOrientation</i> in <b>SQLFetchScroll</b>.</td>
</tr>
<tr valign=top>
<td width=29%><i>FetchOffset</i></td>
<td width=71%>If <i>FetchOrientation</i> is not SQL_FETCH_BOOKMARK, the value of the <i>FetchOffset</i> argument in <b>SQLFetchScroll</b> is used.<p>
If <i>FetchOrientation</i> is SQL_FETCH_BOOKMARK, the value stored at the address specified by the SQL_ATTR_FETCH_BOOKMARK_PTR statement attribute is used.</p>
</td>
</tr>
<tr valign=top>
<td width=29%><i>RowCountPtr</i></td>
<td width=71%>The address specified by the SQL_ATTR_ROWS_FETCHED_PTR statement attribute.</td>
</tr>
<tr valign=top>
<td width=29%><i>RowStatusArray</i></td>
<td width=71%>The address specified by the SQL_ATTR_ROW_STATUS_PTR statement attribute.</td>
</tr>
</table><br>
<p>
For more information, see <a href="odappgpr_5drt.htm">“Block Cursors, Scrollable Cursors, and Backward Compatibility</a>” in Appendix G, “Driver Guidelines for Backward Compatibility.”</p>
<h1>Descriptors and SQLFetchScroll</h1>
<p>
<b>SQLFetchScroll</b> interacts with descriptors in the same manner as <b>SQLFetch</b>. For more information, see the “Descriptors and SQLFetchScroll” section in <a href="odch21epr_4zoo.htm">SQLFetch</a>.</p>
<p class=label>
<b>Code Example</b></p>
<p>
See “<a href="odch11pr_6dbb.htm">Column-Wise Binding</a>” and “<a href="odch11pr_2uw7.htm">Row-Wise Binding</a>” in Chapter 11, “Retrieving Results (Advanced)”, and “<a href="odch12pr_58qb.htm">Positioned Update and Delete Statements</a>” and “<a href="odch12pr_8bar.htm">Updating Rows in the Rowset with SQLSetPos</a>” in Chapter 12, “Updating Data.”</p>
<p class=label>
<b>Related Functions</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=48%><b>For information about</b></td>
<td class=label width=52%><b>See</b></td>
</tr>
<tr valign=top>
<td width=48%>Binding a buffer to a column in a result set</td>
<td width=52%><a href="odch21bpr_0ht8.htm">SQLBindCol</a></td>
</tr>
<tr valign=top>
<td width=48%>Performing bulk insert, update, or delete operations</td>
<td width=52%><a href="odch21bpr_9er7.htm">SQLBulkOperations</a></td>
</tr>
<tr valign=top>
<td width=48%>Canceling statement processing</td>
<td width=52%><a href="odch21bpr_5b58.htm">SQLCancel</a></td>
</tr>
<tr valign=top>
<td width=48%>Returning information about a column in a result set</td>
<td width=52%><a href="odch21dpr_92jw.htm">SQLDescribeCol</a></td>
</tr>
<tr valign=top>
<td width=48%>Executing an SQL statement</td>
<td width=52%><a href="odch21epr_35x0.htm">SQLExecDirect</a></td>
</tr>
<tr valign=top>
<td width=48%>Executing a prepared SQL statement</td>
<td width=52%><a href="odch21epr_0yg5.htm">SQLExecute</a></td>
</tr>
<tr valign=top>
<td width=48%>Fetching a single row or a block of data in a forward-only direction</td>
<td width=52%><a href="odch21epr_4zoo.htm">SQLFetch</a></td>
</tr>
<tr valign=top>
<td width=48%>Closing the cursor on the statement</td>
<td width=52%><a href="odch21fpr_84hg.htm">SQLFreeStmt</a></td>
</tr>
<tr valign=top>
<td width=48%>Returning the number of result set columns</td>
<td width=52%><a href="odch21ipr_74hf.htm">SQLNumResultCols</a></td>
</tr>
<tr valign=top>
<td width=48%>Positioning the cursor, refreshing data in the rowset, or updating or deleting data in the result set</td>
<td width=52%><a href="odch21kpr_2rsj.htm">SQLSetPos</a></td>
</tr>
<tr valign=top>
<td width=48%>Setting a statement attribute</td>
<td width=52%><a href="odch21kpr_77jm.htm">SQLSetStmtAttr</a></td>
</tr>
</table><br>
</font></BODY>
</HTML>
