<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Block Cursors, Scrollable Cursors, and Backward Compatibility for ODBC 3.x Applications</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="odbcblock_cursors__scrollable_cursors__and_backward_compatibility_for_odbc_3.x_applications"></a>Block Cursors, Scrollable Cursors, and Backward Compatibility for ODBC 3.x Applications</h1>
<p>
The existence of both <b>SQLFetchScroll</b> and <b>SQLExtendedFetch</b> represents the first clear split in ODBC between the Application Programming Interface (API), which is the set of functions the application calls, and the Service Provider Interface (SPI), which is the set of functions the driver implements. This split is required to balance the requirement in ODBC 3.<i>x</i> to align with the standards, which uses <b>SQLFetchScroll</b>, and be compatible with ODBC 2.<i>x</i>, which uses <b>SQLExtendedFetch</b>.</p>
<p>
The ODBC 3.x API, which is the set of functions the application calls, includes <b>SQLFetchScroll</b> and related statement attributes. The ODBC 3.xSPI, which is the set of functions the driver implements, includes <b>SQLFetchScroll</b>, <b>SQLExtendedFetch</b>, and related statement attributes. Note that because ODBC does not formally enforce this split between the API and the SPI, it is possible for ODBC 3.x applications to call <b>SQLExtendedFetch</b> and related statement attributes. However, there is no reason for ODBC 3.x application to do this. For more information about APIs and SPIs, see the introduction to Chapter 3, "<a href="odch03pr_6gh1.htm">ODBC Architecture</a>."</p>
<p>
For information about how the ODBC 3.<i>x</i> Driver Manager maps calls to ODBC 2.<i>x</i> and ODBC 3.<i>x</i> drivers, and what functions and statement attributes an ODBC 3.<i>x</i> driver should implement for block and scrollable cursors, see "<a href="odappgpr_2gmr.htm">What the Driver Does</a>" in Appendix G, "Driver Guidelines for Backward Compatibility."</p>
<p>
The following table summarizes what functions and statement attributes an ODBC 3.<i>x</i> application should use with block and scrollable cursors. It also lists changes between ODBC 2.<i>x</i> and ODBC 3.<i>x</i> in this area that ODBC 3.<i>x</i> applications should be aware of to be compatible with ODBC 2.<i>x</i> drivers.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=31%><b>Function or<br>
statement attribute</b></td>
<td class=label width=69%><b><br>
Comments</b></td>
</tr>
<tr valign=top>
<td width=31%>SQL_ATTR_FETCH<br>
_BOOKMARK_PTR</td>
<td width=69%>Points to the bookmark to use with <b>SQLFetchScroll</b>. The following are implementation details:<ul type=disc>
<li>
When an application sets this in an ODBC 2.<i>x</i> driver, this must point to a fixed-length bookmark.</li>
</ul>
</td>
</tr>
<tr valign=top>
<td width=31%>SQL_ATTR_ROW_<br>
STATUS_PTR</td>
<td width=69%>Points to the row status array filled by <b>SQLFetch</b>, <b>SQLFetchScroll</b>, <b>SQLBulkOperations</b>, and <b>SQLSetPos</b>. The following are implementation details:<ul type=disc>
<li>
If an application sets this in an ODBC 2.<i>x</i> driver and calls <b>SQLBulkOperation</b> with an <i>Operation</i> of SQL_ADD before calling <b>SQLFetchScroll</b>, <b>SQLFetch</b>, or <b>SQLExtendedFetch, SQLSTATE HY011 </b>(Attribute cannot be set now) is returned.</li>
</ul>
<p>
Note that when an application calls <b>SQLFetch</b> in an ODBC 2.<i>x</i> driver, <b>SQLFetch</b> is mapped to <b>SQLExtendedFetch</b>, so returns values in this array.</p>
</td>
</tr>
<tr valign=top>
<td width=31%>SQL_ATTR_ROWS_<br>
FETCHED_PTR</td>
<td width=69%>Points to the buffer in which <b>SQLFetch</b> and <b>SQLFetchScroll</b> return the number of rows fetched. <p>
Note that when an application calls <b>SQLFetch</b> in an ODBC 2.<i>x</i> driver, <b>SQLFetch</b> is mapped to <b>SQLExtendedFetch</b>, so returns a value in this buffer.</p>
</td>
</tr>
<tr valign=top>
<td width=31%>SQL_ATTR_<br>
ROW_ARRAY_SIZE</td>
<td width=69%>Sets the rowset size. <p>
If an application calls <b>SQLBulkOperations</b> with an <i>Operation</i> of SQL_ADD in an ODBC 2.<i>x</i> driver, SQL_ROWSET_SIZE will be used for the call, not SQL_ATTR_ROW_ARRAY_SIZE, because the call is mapped to <b>SQLSetPos</b> with an <i>Operation</i> of SQL_ADD, which uses SQL_ROWSET_SIZE.</p>
<p>
Calling <b>SQLSetPos</b> with an <i>Operation</i> of SQL_ADD or <b>SQLExtendedFetch</b> in an ODBC 2.<i>x</i> driver uses SQL_ROWSET_SIZE.</p>
<p>
Calling <b>SQLFetch</b> or <b>SQLFetchScroll</b> in an ODBC 2.<i>x</i> driver uses SQL_ATTR_ROW_ARRAY_SIZE.</p>
</td>
</tr>
<tr valign=top>
<td width=31%><b>SQLBulkOperations</b></td>
<td width=69%>Performs insert and bookmark operations. When <b>SQLBulkOperations</b> with an <i>Operation</i> of SQL_ADD is called in an ODBC 2.<i>x</i> driver, it is mapped to <b>SQLSetPos</b> with an <i>Operation</i> of SQL_ADD. The following are implementation details:<ul type=disc>
<li>
When working with an ODBC 2.<i>x</i> driver, an application must use only the implicitly allocated ARD associated with the <i>StatementHandle</i>; it cannot allocate another ARD for adding rows, because explicit descriptor operations are not supported in an ODBC 2.<i>x</i> driver. An application must use <b>SQLBindCol</b> to bind to the ARD, not <b>SQLSetDescField</b> or <b>SQLSetDescRec</b>.<br><br></li>
<li>
When calling an ODBC 3.<i>x</i> driver, an application can call <b>SQLBulkOperations</b> with an <i>Operation</i> of SQL_ADD before calling <b>SQLFetch</b> or <b>SQLFetchScroll</b>. When calling an ODBC 2.<i>x</i> driver, an application must call <b>SQLFetchScroll</b> before calling <b>SQLBulkOperations </b>with an Operation of SQL_ADD.</li>
</ul>
</td>
</tr>
<tr valign=top>
<td width=31%><b>SQLFetch</b></td>
<td width=69%>Returns the next rowset. The following are implementation details:<ul type=disc>
<li>
When an application calls <b>SQLFetch</b> in an ODBC 2.<i>x</i> driver, it is mapped to <b>SQLExtendedFetch</b>.<br><br></li>
<li>
When an application calls <b>SQLFetch</b> in an ODBC 3.<i>x</i> driver, it returns the number of rows specified with the SQL_ATTR_ROW_ARRAY_SIZE statement attribute.</li>
</ul>
</td>
</tr>
<tr valign=top>
<td width=31%><b>SQLFetchScroll</b></td>
<td width=69%>Returns the specified rowset. The following are implementation details:<ul type=disc>
<li>
When an application calls <b>SQLFetchScroll</b> in an ODBC 2.<i>x</i> driver, it returns SQLSTATE 01S01 (Error in row) before each error that applies to a single row. It does this only because the ODBC 3.x Driver Manager maps this to <b>SQLExtendedFetch</b> and <b>SQLExtendedFetch</b> returns this SQLSTATE. When an application calls <b>SQLFetchScroll</b> in an ODBC 3.<i>x</i> driver, it never returns SQLSTATE 01S01 (Error in row).<br><br></li>
<li>
When an application calls <b>SQLFetchScroll</b> in an ODBC 2.<i>x</i> driver with <i>FetchOrientation</i> set to SQL_FETCH_BOOKMARK, the <i>FetchOffset</i> argument must be set to 0. SQLSTATE HYC00 (Optional feature not implemented) is returned if offset-based bookmark fetching is attempted with an ODBC 2.<i>x</i> driver.</li>
</ul>
</td>
</tr>
</table><br>
<p class=indent>
<B><b>Note&nbsp;&nbsp;&nbsp;</b></B>ODBC 3.<i>x</i> applications should not use <b>SQLExtendedFetch</b> or the SQL_ROWSET_SIZE statement attribute. Instead, they should use <b>SQLFetchScroll</b> and the SQL_ATTR_ROW_ARRAY_SIZE statement attribute. ODBC 3.<i>x</i> applications should not use <b>SQLSetPos</b> with an <i>Operation</i> of SQL_ADD, but should use <b>SQLBulkOperations</b> with an <i>Operation</i> of SQL_ADD.</p>
</font></BODY>
</HTML>
