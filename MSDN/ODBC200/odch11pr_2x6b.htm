<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Block Cursors</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="odbcblock_cursors"></a>Block Cursors</h1>
<p>
Many applications spend a significant amount of time bringing data across the network. Part of this time is spent actually bringing the data across the network and part of it is spent on network overhead, such as the call made by the driver to request a row of data. The latter time can be reduced if the application makes efficient use of <i>block</i>, or <i>fat</i>, <i>cursors</i>, which can return more than one row at a time.</p>
<p>
An application always has the option of using a block cursor. On data sources from which only one row at a time can be fetched, block cursors must be simulated in the driver. This can be done by performing multiple single-row fetches. While this is unlikely to provide any performance gains, it opens opportunities for applications. Such applications will then experience performance increases as DBMSs implement block cursors natively and the drivers associated with those DBMSs expose them.</p>
<p>
The rows returned in a single fetch with a block cursor are called the <i>rowset</i>. It is important not to confuse the rowset with the result set. The result set is maintained at the data source, while the rowset is maintained in application buffers. While the result set is fixed, the rowset is not—it changes position and contents each time a new set of rows is fetched. Just as a single-row cursor such as the traditional SQL forward-only cursor points to a current row, a block cursor points to the rowset, which can be thought of as “current rows.”</p>
<p>
To perform operations that operate on a single row when multiple rows have been fetched, the application must first indicate which row is the <i>current row</i>. The current row is required by calls to <b>SQLGetData</b> and positioned update and delete statements. When a block cursor first returns a rowset, the current row is the first row of the rowset. To change the current row, the application calls <b>SQLSetPos</b> or <b>SQLBulkOperations </b>(to update by bookmark). The following figure shows the relationship of the result set, rowset, current row, rowset cursor, and block cursor. For more information, see “<a href="odch11pr_9x0z.htm">Using Block Cursors</a>,” later in this chapter, and “<a href="odch12pr_58qb.htm">Positioned Update and Delete Statements</a>” and “<a href="odch12pr_7q2b.htm">Updating Data with SQLSetPos</a>” in Chapter 12, “Updating Data.”</p>
<p>
<img src="pr20.gif" border=0></p>
<p class=label>
<b>Block cursor and rowset cursor</b></p>
<p>
Whether a cursor is a block cursor is independent of whether it is scrollable. For example, most of the work in a report application is spent retrieving and printing rows. Because of this, it will work fastest with a forward-only, block cursor. It uses a forward-only cursor to avoid the expense of a scrollable cursor, and a block cursor to reduce the network traffic.</p>
</font></BODY>
</HTML>
